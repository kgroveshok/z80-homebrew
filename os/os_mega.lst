# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 17 1d			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			if BASE_KEV = 1  
001c			 
001c				; need to be at $66 for nmi support 
001c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0022 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0028 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0034 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003a 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0040 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0046 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0052 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0058 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0064 00 ff			db 0,255 
0066 c3 fe 75			jp nmi 
0069			endif 
0069			 
0069			include "firmware.asm" 
0069			  
0069			; main constants (used here and in firmware)  
0069			  
0069			; TODO have page 0 of storage as bios  
0069			  
0069			Device_A: equ 0h  
0069			Device_B: equ 040h          ; Sound  
0069			  
0069			if BASE_KEV  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_SC114  
0069			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			; TODO fixup for CPM  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			Device_D: equ 0c0h             ; Keyboard and LCD  
0069			  
0069			; Odd specific debug points for testing hardware dev  
0069			  
0069			DEBUG_SOUND: equ 0       
0069			DEBUG_STK_FAULT: equ 0  
0069			DEBUG_INPUT: equ 0     ; Debug input entry code  
0069			DEBUG_KEYCINWAIT: equ 0  
0069			DEBUG_KEYCIN: equ 0  
0069			DEBUG_KEY: equ 0  
0069			DEBUG_KEY_MATRIX: equ 0  
0069			DEBUG_STORECF: equ 0  
0069			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0069			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0069			DEBUG_SPI: equ 0    ; low level spi tests  
0069			  
0069			; Enable many break points  
0069			  
0069			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0069			DEBUG_FORTH_JP: equ 0    ; 4  
0069			DEBUG_FORTH_MALLOC: equ 0  
0069			DEBUG_FORTH_MALLOC_INT: equ 0  
0069			DEBUG_FORTH_DOT: equ 1  
0069			DEBUG_FORTH_DOT_WAIT: equ 0  
0069			DEBUG_FORTH_MATHS: equ 0  
0069			DEBUG_FORTH_TOK: equ 0    ; 4  
0069			DEBUG_FORTH_PARSE: equ 0    ; 3  
0069			DEBUG_FORTH: equ 0  ;2  
0069			DEBUG_FORTH_WORDS: equ 1   ; 1  
0069			DEBUG_FORTH_PUSH: equ 1   ; 1  
0069			DEBUG_FORTH_UWORD: equ 1   ; 1  
0069			  
0069			; Enable key point breakpoints  
0069			  
0069			DEBUG_FORTH_DOT_KEY: equ 0  
0069			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0069			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0069			  
0069			; Debug stack imbalances  
0069			  
0069			ON: equ 1  
0069			OFF: equ 0  
0069			  
0069			DEBUG_STACK_IMB: equ 0  
0069			STACK_IMB_STORE: equ 20  
0069			  
0069			; House keeping and protections  
0069			  
0069			DEBUG_FORTH_STACK_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0069			FORTH_ENABLE_FREE: equ 0  
0069			FORTH_ENABLE_MALLOCFREE: equ 1  
0069			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0069			FORTH_ENABLE_FLOATMATH: equ 0  
0069			  
0069			  
0069			CALLMONITOR: macro  
0069			;	call break_point_state  
0069			; now use the break point debug vector  
0069				call debug_vector  
0069				endm  
0069			  
0069			MALLOC_1: equ 1        ; from dk88   
0069			MALLOC_2: equ 0           ; broke  
0069			MALLOC_3: equ 0           ; really broke  
0069			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0069			  
0069			if BASE_KEV   
0069			stacksize: equ 256  
0069			  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 512  
0069			endif  
0069			if BASE_SC114  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			;if STORAGE_SE == 0  
0069			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0069			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0069			;endif  
0069			  
0069			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0069			  
0069			STORE_0_AUTORUN: equ $20  
0069			  
0069			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0069			  
0069			STORE_0_AUTOFILE: equ $21  
0069			STORE_0_BANKRUN: equ $23  
0069			STORE_0_FILERUN: equ $24  
0069			  
0069			; Block 0 offsets for settings  
0069			  
0069			; if set then skip prompt for start up and accept all  
0069			  
0069			STORE_0_QUICKSTART: equ $25  
0069			  
0069			; Blocks where directory table is held  
0069			  
0069			; Reducing the number of entries increases the max file size  
0069			  
0069			;STORE_DIR_START: equ 1  
0069			;STORE_DIR_END: equ 33  
0069			  
0069			; Blocks from where file data is stored  
0069			  
0069			;STORE_DATA_START: equ STORE_DIR_END + 1  
0069			  
0069			; Block indicators (<32 are data files)  
0069			  
0069			;STORE_BLOCK_CFG: equ $8f       ; config block  
0069			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0069			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0069			;STORE_BLOCK_FREE: equ $85       ; data block free  
0069			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0069			  
0069			  
0069			  
0069			; Directory entry flags  
0069			  
0069			;STORE_DIR_FREE: equ 0  
0069			;STORE_DIR_FILE:  equ 1  
0069			  
0069			; Structure offsets to directory entries  
0069			;STORE_DE_FLAG: equ 0  
0069			;STORE_DE_MAXEXT: equ 1  
0069			;STORE_DE_FILENAME: equ 2  
0069			  
0069			; Structure offsets to block 0  
0069			  
0069			;STORE_BK0_ISFOR: equ 1  
0069			;STORE_BK0_LABEL: equ 3  
0069			  
0069			; memory allocation   
0069			  
0069			chk_stund: equ tos+2           ; underflow check word  
0069			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0069			  
0069			; keyscan table needs rows x cols buffer  
0069			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0069			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0069			  
0069			keyscan_table_row1: equ chk_stovr -key_cols-1  
0069			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0069			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0069			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0069			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0069			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0069			keyscan_scancol: equ keyscan_table-key_cols  
0069			;keyscan_table_len: equ key_rows*key_cols  
0069			;keybufptr: equ keyscan_table - 2  
0069			;keysymbol: equ keybufptr - 1  
0069			key_held: equ keyscan_scancol-1	; currently held  
0069			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0069			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0069			key_fa: equ key_repeat_ct -1 ;  
0069			key_fb: equ key_fa -1 ;  
0069			key_fc: equ key_fb -1 ;  
0069			key_fd: equ key_fc -1 ;  
0069			key_face_held: equ key_fd - 1   
0069			  
0069			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0069			  
0069			hardware_config: equ key_face_held - 10  
0069			  
0069			; hardware config switches  
0069			; TODO add bitmasks on includes for hardware  
0069			; high byte for expansion ids  
0069			;     0000 0000  no card inserted  
0069			;     0000 0001  storage card inserted  
0069			;     0000 0010  spi sd card active  
0069			  
0069			;       
0069			; low byte:  
0069			;     0000 0001   4x4 keypad  
0069			;     0000 0010   full keyboard  
0069			;     0000 0011   spi/ext keyboard  
0069			;     0000 0100   20x4 lcd  
0069			;     0000 1000   40x4 lcd  
0069			;     0000 1100   spi/ext display  
0069			;     0001 0000   ide interface available  
0069			  
0069			hardware_word: equ hardware_config - 2  
0069			  
0069			; debug marker - optional display of debug point on the debug screens  
0069			  
0069			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0069			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0069			  
0069			debug_mark: equ debug_vector - 4  
0069			  
0069			; input_str vars  
0069			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0069			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0069			input_size: equ input_start -1  ; number of chars  
0069			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0069			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0069			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0069			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0069			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0069			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0069			input_len: equ input_cur_onoff - 5 ; length of current input  
0069			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0069			  
0069			CUR_BLINK_RATE: equ 15  
0069			  
0069			key_actual_pressed: equ input_cursor - 1   
0069			key_symbol: equ key_actual_pressed - 1   
0069			key_shift: equ key_symbol - 1   
0069			  
0069			; Display allocation  
0069			  
0069			;display_rows: equ 4     ; move out to mini and mega files  
0069			;display_cols: equ 20  
0069			  
0069			display_fb_len: equ display_rows*display_cols  
0069			  
0069			; primary frame buffer     
0069			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0069			; working frame buffers  
0069			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0069			display_fb3: equ  display_fb1-display_fb_len - 1  
0069			display_fb2: equ  display_fb3-display_fb_len - 1  
0069			;  
0069			; pointer to active frame buffer  
0069			display_fb_active: equ display_fb2 - 2  
0069			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0069			display_write_tmp: equ display_lcde1e2 - 2  
0069			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0069			  
0069			;  
0069			  
0069			;; can load into de directory  
0069			cursor_col: equ display_active-1  
0069			cursor_row: equ cursor_col-1  
0069			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0069			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0069			  
0069			; maths vars  
0069			  
0069			LFSRSeed: equ cursor_shape -20   
0069			randData: equ LFSRSeed - 2  
0069			xrandc: equ randData - 2  
0069			stackstore: equ xrandc - 2  
0069			seed1: equ  stackstore -2   
0069			seed2: equ seed1 - 2  
0069			  
0069			; cf storage vars  
0069			  
0069			iErrorNum:  equ seed2-1         ;Error number  
0069			iErrorReg:  equ iErrorNum -1              ;Error register  
0069			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0069			  
0069			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0069			  
0069			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0069			  
0069			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0069			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0069			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0069			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0069			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0069			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0069			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0069			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0069			store_tmpid: equ store_tmp3 - 1		; page temp id  
0069			store_tmpext: equ store_tmpid - 1		; file extent temp  
0069			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0069			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0069			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0069			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0069			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0069			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0069			;  
0069			; spi vars  
0069			  
0069			  
0069			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0069			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0069			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0069			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0069			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0069			spi_device_id: equ spi_device - 1    ; human readable bank number  
0069			  
0069			;;;;; forth cli params  
0069			  
0069			; TODO use a different frame buffer for forth???  
0069			  
0069			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0069			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0069			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0069			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0069			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0069			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0069			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0069			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0069			  
0069			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0069			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0069			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0069			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0069			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0069			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0069			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0069			  
0069			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0069			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0069			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0069			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0069			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0069			  
0069			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0069			  
0069			; os/forth token vars  
0069			  
0069			os_last_cmd: equ os_var_array-255  
0069			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0069			os_current_i: equ os_cli_cmd-2  
0069			os_cur_ptr: equ os_current_i-2  
0069			os_word_scratch: equ os_cur_ptr-30  
0069			os_tok_len: equ os_word_scratch - 2  
0069			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0069			os_tok_malloc: equ os_tok_ptr - 2  
0069			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0069			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0069			execscratch: equ os_input-255        ; exec cmd eval buffer  
0069			scratch: equ execscratch-255  
0069			  
0069			  
0069			; temp locations for new word processing to save on adding more   
0069			  
0069			os_new_malloc: equ scratch-2  
0069			os_new_parse_len: equ os_new_malloc - 2  
0069			os_new_word_len: equ os_new_parse_len - 2  
0069			os_new_work_ptr: equ os_new_word_len - 2  
0069			os_new_src_ptr: equ os_new_work_ptr - 2  
0069			os_new_exec: equ os_new_src_ptr - 2  
0069			os_new_exec_ptr: equ os_new_exec - 2  
0069			  
0069			; resume memory alloocations....  
0069			  
0069			;os_view_disable: equ os_new_exec_ptr - 1  
0069			os_view_af: equ os_new_exec_ptr - 2  
0069			os_view_hl: equ os_view_af -2  
0069			os_view_de: equ os_view_hl - 2  
0069			os_view_bc: equ os_view_de - 2  
0069			  
0069			; stack checksum word  
0069			if DEBUG_STACK_IMB  
0069				curframe: equ  os_view_de - 5  
0069				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0069				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			else  
0069				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			endif  
0069			  
0069			; with data stack could see memory filled with junk. need some memory management   
0069			; malloc and free entry points added  
0069			  
0069			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0069			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			;heap_end: equ free_list-1  ; Starting address of heap  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			heap_end: equ chk_word-1  ; Starting address of heap  
0069			  
0069			  
0069			;if BASE_KEV   
0069			;heap_start: equ 0800eh  ; Starting address of heap  
0069			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;heap_start: equ baseram+15  ; Starting address of heap  
0069			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;endif  
0069			  
0069			  
0069			;;;;  
0069			  
0069			  
0069			; change below to point to last memory alloc above  
0069			topusermem:  equ   heap_start  
0069			  
0069			;if BASE_KEV   
0069			;baseusermem: equ 08000h  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;;aseusermem:     equ    12  
0069			;baseusermem:     equ    prompt  
0069			;;baseusermem:     equ    endofcode  
0069			;endif  
0069			  
0069			  
0069			; **********************************************************************  
0069			; **  Constants  
0069			; **********************************************************************  
0069			  
0069			; Constants used by this code module  
0069			kDataReg:   EQU Device_D           ;PIO port A data register  
0069			kContReg:   EQU Device_D+2           ;PIO port A control register  
0069			  
0069			  
0069			portbdata:  equ Device_D+1    ; port b data  
0069			portbctl:   equ Device_D+3    ; port b control  
0069			  
0069			  
0069			;KEY_SHIFT:   equ 5  
0069			;KEY_SYMBOLSHIFT:  equ 6  
0069			  
0069			KEY_SHIFTLOCK: equ 4  
0069			  
0069			  
0069			KEY_UP: equ 5  
0069			KEY_NEXTWORD: equ 6  
0069			KEY_PREVWORD: equ 7  
0069			KEY_BS: equ 8  
0069			KEY_TAB:  equ 9  
0069			KEY_DOWN: equ 10  
0069			KEY_LEFT: equ 11  
0069			KEY_RIGHT: equ 12  
0069			KEY_CR:   equ 13  
0069			KEY_HOME: equ 14  
0069			KEY_END: equ 15  
0069			  
0069			KEY_F1: equ 16  
0069			KEY_F2: equ 17  
0069			KEY_F3: equ 18  
0069			KEY_F4: equ 19  
0069			  
0069			KEY_F5: equ 20  
0069			KEY_F6: equ 21  
0069			KEY_F7: equ 22  
0069			KEY_F8: equ 23  
0069			  
0069			KEY_F9: equ 24  
0069			KEY_F10: equ 25  
0069			KEY_F11: equ 26  
0069			KEY_F12: equ 27  
0069			  
0069			;if DEBUG_KEY  
0069			;	KEY_MATRIX_NO_PRESS: equ '.'  
0069			;	KEY_SHIFT:   equ '.'  
0069			;	KEY_SYMBOLSHIFT:  equ '.'  
0069			;else  
0069				KEY_SHIFT:   equ '~'  
0069				KEY_SYMBOLSHIFT:  equ '~'  
0069				KEY_MATRIX_NO_PRESS: equ '~'  
0069			;endi  
0069			  
0069			  
0069			  
0069			  
0069			; Macro to make adding debug marks easier  
0069			  
0069			DMARK: macro str  
0069				push af  
0069				ld a, (.dmark)  
0069				ld (debug_mark),a  
0069				ld a, (.dmark+1)  
0069				ld (debug_mark+1),a  
0069				ld a, (.dmark+2)  
0069				ld (debug_mark+2),a  
0069				jr .pastdmark  
0069			.dmark: db str  
0069			.pastdmark: pop af  
0069			  
0069			endm  
0069			  
0069			  
0069			; macro to detect for stack imbalances  
0069			  
0069			include "stackimbal.asm"  
0069			; Macro and code to detect stock imbalances 
0069			 
0069			SPPUSH: equ 0 
0069			 
0069			; Add a stack frame which can be checked before return 
0069			 
0069			STACKFRAME: macro onoff frame1 frame2 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069						exx 
0069			 
0069						ld de, frame1 
0069						ld a, d 
0069						ld hl, curframe 
0069						call hexout 
0069						ld a, e 
0069						ld hl, curframe+2 
0069						call hexout 
0069			  
0069						ld hl, frame1 
0069						push hl 
0069						ld hl, frame2 
0069						push hl 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			endm 
0069			 
0069			STACKFRAMECHK: macro onoff frame1 frame2 
0069			 
0069					 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						exx 
0069						; check stack frame SP 
0069			 
0069						ld hl, frame2 
0069						pop de   ; frame2 
0069			 
0069						call cmp16 
0069						jr nz, .spnosame 
0069						 
0069			 
0069						ld hl, frame1 
0069						pop de   ; frame1 
0069			 
0069						call cmp16 
0069						jr z, .spfrsame 
0069			 
0069						.spnosame: call showsperror 
0069			 
0069						.spfrsame: nop 
0069			 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			 
0069			 
0069			endm 
0069			 
0069			 
0069			; for a sub routine, wrap SP collection and comparisons 
0069			 
0069			; Usage: 
0069			; 
0069			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0069			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0069			 
0069			SAVESP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069			 
0069						ld (store_sp+(storeword*4)), sp 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			CHECKSP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069			 
0069						; save SP after last save 
0069				 
0069						ld (store_sp+(storeword*4)+2), sp 
0069			 
0069						push hl 
0069						ld hl, store_sp+(storeword*4) 
0069						call check_stack_sp  
0069						pop hl 
0069			 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			if DEBUG_STACK_IMB 
0069			 
0069			check_stack_sp: 
0069					push de 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					push de 
0069			 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					pop hl 
0069			 
0069			 
0069					; check to see if the same 
0069			 
0069					call cmp16 
0069					jr z, .spsame 
0069			 
0069					; not same 
0069			 
0069					call showsperror 
0069			.spsame: 
0069			 
0069					pop de 
0069			 
0069					ret 
0069			 
0069			.sperr:  db "Stack imbalance",0 
0069			 
0069			 
0069			showsperror: 
0069			 
0069			 
0069				push hl 
0069				push af 
0069				push de 
0069				call clear_display 
0069				ld de, .sperr 
0069				ld a,0 
0069			;	ld de,os_word_scratch 
0069				call str_at_display 
0069				ld a, display_row_1+17 
0069				ld de, debug_mark 
0069				call str_at_display 
0069				ld a, 0 
0069				ld (curframe+4),a 
0069				ld hl, curframe 
0069				ld de, os_word_scratch 
0069				ld a, display_row_4 
0069				call str_at_display 
0069				call update_display 
0069				;call break_point_state 
0069				call cin_wait 
0069			 
0069			;	ld a, ' ' 
0069			;	ld (os_view_disable), a 
0069				call bp_on 
0069				pop de	 
0069				pop af 
0069				pop hl 
0069				CALLMONITOR 
0069				ret 
0069			 
0069			endif 
0069			 
0069			 
0069			 
0069			; eof 
# End of file stackimbal.asm
0069			  
0069			;TODO macro to calc col and row offset into screen  
0069			  
0069			  
0069			  
0069			hardware_init:  
0069			  
0069				  
0069			  
0069					;ld a, 0  
0069					;ld (hardware_diag), a  
0069			  
0069					; clear all the buffers  
0069			  
0069 21 0d fd				ld hl, display_fb1  
006c 22 c9 fb				ld (display_fb_active), hl  
006f			  
006f cd 9c 0d				call clear_display  
0072			  
0072 21 cb fb				ld hl, display_fb2  
0075 22 c9 fb				ld (display_fb_active), hl  
0078			  
0078 cd 9c 0d				call clear_display  
007b			  
007b					; init primary frame buffer area  
007b 21 ae fd				ld hl, display_fb0  
007e 22 c9 fb				ld (display_fb_active), hl  
0081			  
0081 cd 9c 0d				call clear_display  
0084			  
0084			  
0084 cd 0b 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0087			  
0087 cd a2 78			call key_init  
008a cd 48 02			call storage_init  
008d			  
008d				; setup malloc functions  
008d			  
008d				if MALLOC_1  
008d cd 73 14				call  heap_init  
0090				endif  
0090				if MALLOC_4  
0090					call  heap_init  
0090				endif  
0090			  
0090				; init sound hardware if present  
0090			  
0090				if SOUND_ENABLE  
0090					call sound_init  
0090				endif  
0090			  
0090				; lcd test sequence  
0090					  
0090 cd bf 0d			call update_display  
0093 cd df 0c			call delay1s  
0096 3e 2b			ld a,'+'  
0098 cd a1 0d			call fill_display  
009b cd bf 0d			call update_display  
009e cd df 0c			call delay1s  
00a1 3e 2a			ld a,'*'  
00a3 cd a1 0d			call fill_display  
00a6 cd bf 0d			call update_display  
00a9 cd df 0c			call delay1s  
00ac 3e 2d			ld a,'-'  
00ae cd a1 0d			call fill_display  
00b1 cd bf 0d			call update_display  
00b4 cd df 0c			call delay1s  
00b7			  
00b7			; boot splash screen  
00b7			if display_cols == 20	  
00b7			        ld a, display_row_1    
00b7			else  
00b7 3e 0a		        ld a, display_row_1 +10   
00b9			endif  
00b9 11 0f 1c			ld de, prom_bootmsg  
00bc cd af 0d			call str_at_display  
00bf cd bf 0d			call update_display  
00c2			  
00c2			  
00c2 cd df 0c			call delay1s  
00c5 cd df 0c			call delay1s  
00c8			if display_cols == 20	  
00c8			            LD   A, display_row_3+2  
00c8			else  
00c8 3e 5c		            LD   A, display_row_3+12  
00ca			endif  
00ca 11 24 1c			ld de, prom_bootmsg1  
00cd cd af 0d			call str_at_display  
00d0 cd bf 0d			call update_display  
00d3 cd df 0c			call delay1s  
00d6 cd df 0c			call delay1s  
00d9			  
00d9			;	ld a, display_row_4+3  
00d9			;	ld de, bootmsg2  
00d9			;	call str_at_display  
00d9			;	call update_display  
00d9			;	call delay1s  
00d9			;	call delay1s  
00d9			  
00d9			; debug mark setup  
00d9			  
00d9 3e 5f		ld a, '_'  
00db 32 68 fe		ld (debug_mark),a  
00de 32 69 fe		ld (debug_mark+1),a  
00e1 32 6a fe		ld (debug_mark+2),a  
00e4 3e 00		ld a,0  
00e6 32 6b fe		ld (debug_mark+3),a  
00e9			  
00e9 c9					ret  
00ea			  
00ea			  
00ea			;bootmsg2:	db "Firmware v0.1",0  
00ea			  
00ea			; a 4x20 lcd  
00ea			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ea			  
00ea			;if display_cols == 20  
00ea			;	include "firmware_lcd_4x20.asm"  
00ea			;endif  
00ea			  
00ea			;if display_cols == 40  
00ea			;	include "firmware_lcd_4x40.asm"  
00ea			;endif  
00ea			  
00ea			;  
00ea			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ea			; TODO abstract the bit bang video out interface for dual display  
00ea			; TODO wire video out to tx pin on rc2014 bus  
00ea			  
00ea			; must supply cin, and cin_wait for low level hardware abstraction   
00ea			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ea			; test scancode  
00ea			  
00ea			;;;;;  
00ea			;;;  
00ea			; Moved out to mini and maxi versions  
00ea			;  
00ea			; include "firmware_key_4x4.asm"  
00ea			; using existing 4 wire x 4 resistor array for input  
00ea			;include "firmware_key_4x10.asm"  
00ea			; need to mod the board for 5 rows due to resistor array  
00ea			;include "firmware_key_5x10.asm"  
00ea			  
00ea			; storage hardware interface  
00ea			  
00ea			; use microchip serial eeprom for storage  
00ea			  
00ea			  
00ea			if STORAGE_SE  
00ea				include "firmware_spi.asm"  
00ea			; my spi protocol (used by storage) 
00ea			 
00ea			; SPI pins 
00ea			 
00ea			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ea			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ea			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ea			 
00ea			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ea			; chip pin 4 gnd 
00ea			 
00ea			 
00ea			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ea			SPI_CE1: equ 1      ;    port a1 pin 14  
00ea			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ea			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ea			SPI_CE4: equ 4      ; port a4     pin 10 
00ea			 
00ea			; active low AND masks 
00ea			 
00ea			;SPI_CE0_MASK: equ    255-1 
00ea			;SPI_CE1_MASK: equ   255-2 
00ea			;SPI_CE2_MASK: equ   255-4 
00ea			;SPI_CE3_MASK: equ   255-8 
00ea			;SPI_CE4_MASK: equ   255-16 
00ea			SPI_CE_HIGH:  equ 255 
00ea			 
00ea			 
00ea			 
00ea			;  Perform SCLK wait pulse 
00ea			 
00ea			spi_clk: 
00ea f5				push af 
00eb 3a 61 fa			ld a, (spi_clktime) 
00ee fe 00			cp 0 
00f0 28 03			jr z, .scskip 
00f2 cd c4 0c			call aDelayInMS 
00f5			.scskip: 
00f5 f1				pop af 
00f6 c9				ret 
00f7			 
00f7			 
00f7			 
00f7			; TODO store port id for spi device ie dev c 
00f7			; TODO store pin for SO 
00f7			; TODO store pin for SI 
00f7			; TODO store pin for SCLK 
00f7			 
00f7			; 
00f7			 
00f7			; ensure that spi bus is in a stable state with default pins  
00f7			 
00f7			se_stable_spi:   
00f7			 
00f7				 ; set DI high, CE high , SCLK low 
00f7				;ld a, SPI_DI | SPI_CE0 
00f7 3e 07			ld a, SPI_DI  
00f9 cd 03 02			call spi_ce_high 
00fc d3 80			 out (storage_adata),a 
00fe 32 5e fa			ld (spi_portbyte),a 
0101			 
0101				if DEBUG_SPI 
0101					push hl 
0101					ld l, a 
0101					DMARK "SPI" 
0101					CALLMONITOR 
0101					pop hl 
0101				endif 
0101 c9				ret 
0102			 
0102			; byte to send in a 
0102			 
0102			spi_send_byte: 
0102				; save byte to send for bit mask shift out 
0102 4f			        ld c,a 
0103 3a 5e fa			ld a,(spi_portbyte) 
0106				  
0106				; clock out	each bit of the byte msb first 
0106			 
0106 06 08			ld b, 8 
0108			.ssb1: 
0108				; clear so bit  
0108 cb bf			res SPI_DI, a 
010a cb 11			rl c 
010c				; if bit 7 is set then carry is set 
010c 30 02			jr nc, .ssb2 
010e cb ff			set SPI_DI,a 
0110			.ssb2:  ; output bit to ensure it is stable 
0110 d3 80			out (storage_adata),a 
0112 00				nop 
0113				; clock bit high 
0113 cb ef			set SPI_SCLK,a 
0115 d3 80			out (storage_adata),a 
0117 00				nop 
0118 cd ea 00			call spi_clk 
011b				; then low 
011b cb af			res SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120 cd ea 00			call spi_clk 
0123 10 e3			djnz .ssb1 
0125			 
0125 32 5e fa			ld (spi_portbyte),a 
0128 c9				ret 
0129			 
0129			; TODO low level get byte into A on spi 
0129			 
0129			spi_read_byte:  
0129			 
0129				; save byte to send for bit mask shift out 
0129 0e 00		    ld c,0 
012b 3a 5e fa			ld a,(spi_portbyte) 
012e				  
012e				; clock out	each bit of the byte msb first 
012e			 
012e			 
012e				; clock bit high 
012e cb ef			set SPI_SCLK,a 
0130 d3 80			out (storage_adata),a 
0132 00				nop 
0133 cd ea 00			call spi_clk 
0136			 
0136			    ; read DO  
0136			 
0136 cb f9		    set 7,c 
0138 db 80			in a,(storage_adata) 
013a cb 77		    bit SPI_DO,a 
013c 20 02		    jr nz, .b7 
013e cb b9		    res 7,c 
0140			.b7: 
0140				; then low 
0140 cb af			res SPI_SCLK,a 
0142 d3 80			out (storage_adata),a 
0144 00				nop 
0145 cd ea 00			call spi_clk 
0148			     
0148			 
0148				; clock bit high 
0148 cb ef			set SPI_SCLK,a 
014a d3 80			out (storage_adata),a 
014c 00				nop 
014d cd ea 00			call spi_clk 
0150			 
0150			    ; read DO  
0150			 
0150 cb f1		    set 6,c 
0152 db 80			in a,(storage_adata) 
0154 cb 77		    bit SPI_DO,a 
0156 20 02		    jr nz, .b6 
0158 cb b1		    res 6,c 
015a			.b6: 
015a				; then low 
015a cb af			res SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f cd ea 00			call spi_clk 
0162			 
0162				; clock bit high 
0162 cb ef			set SPI_SCLK,a 
0164 d3 80			out (storage_adata),a 
0166 00				nop 
0167 cd ea 00			call spi_clk 
016a			 
016a			 
016a			    ; read DO  
016a			 
016a cb e9		    set 5,c 
016c db 80			in a,(storage_adata) 
016e cb 77		    bit SPI_DO,a 
0170 20 02		    jr nz, .b5 
0172 cb a9		    res 5,c 
0174			.b5: 
0174				; then low 
0174 cb af			res SPI_SCLK,a 
0176 d3 80			out (storage_adata),a 
0178 00				nop 
0179 cd ea 00			call spi_clk 
017c				; clock bit high 
017c cb ef			set SPI_SCLK,a 
017e d3 80			out (storage_adata),a 
0180 00				nop 
0181 cd ea 00			call spi_clk 
0184			 
0184			    ; read DO  
0184			 
0184 cb e1		    set 4,c 
0186 db 80			in a,(storage_adata) 
0188 cb 77		    bit SPI_DO,a 
018a 20 02		    jr nz, .b4 
018c cb a1		    res 4,c 
018e			.b4: 
018e				; then low 
018e cb af			res SPI_SCLK,a 
0190 d3 80			out (storage_adata),a 
0192 00				nop 
0193 cd ea 00			call spi_clk 
0196				; clock bit high 
0196 cb ef			set SPI_SCLK,a 
0198 d3 80			out (storage_adata),a 
019a 00				nop 
019b cd ea 00			call spi_clk 
019e			 
019e			    ; read DO  
019e			 
019e cb d9		    set 3,c 
01a0 db 80			in a,(storage_adata) 
01a2 cb 77		    bit SPI_DO,a 
01a4 20 02		    jr nz, .b3 
01a6 cb 99		    res 3,c 
01a8			.b3: 
01a8				; then low 
01a8 cb af			res SPI_SCLK,a 
01aa d3 80			out (storage_adata),a 
01ac 00				nop 
01ad cd ea 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4 00				nop 
01b5 cd ea 00			call spi_clk 
01b8			 
01b8			    ; read DO  
01b8			 
01b8 cb d1		    set 2,c 
01ba db 80			in a,(storage_adata) 
01bc cb 77		    bit SPI_DO,a 
01be 20 02		    jr nz, .b2 
01c0 cb 91		    res 2,c 
01c2			.b2: 
01c2				; then low 
01c2 cb af			res SPI_SCLK,a 
01c4 d3 80			out (storage_adata),a 
01c6 00				nop 
01c7 cd ea 00			call spi_clk 
01ca				; clock bit high 
01ca cb ef			set SPI_SCLK,a 
01cc d3 80			out (storage_adata),a 
01ce 00				nop 
01cf cd ea 00			call spi_clk 
01d2			 
01d2			    ; read DO  
01d2			 
01d2 cb c9		    set 1,c 
01d4 db 80			in a,(storage_adata) 
01d6 cb 77		    bit SPI_DO,a 
01d8 20 02		    jr nz, .b1 
01da cb 89		    res 1,c 
01dc			.b1: 
01dc				; then low 
01dc cb af			res SPI_SCLK,a 
01de d3 80			out (storage_adata),a 
01e0 00				nop 
01e1 cd ea 00			call spi_clk 
01e4				; clock bit high 
01e4 cb ef			set SPI_SCLK,a 
01e6 d3 80			out (storage_adata),a 
01e8 00				nop 
01e9 cd ea 00			call spi_clk 
01ec			 
01ec			    ; read DO  
01ec			 
01ec cb c1		    set 0,c 
01ee db 80			in a,(storage_adata) 
01f0 cb 77		    bit SPI_DO,a 
01f2 20 02		    jr nz, .b0 
01f4 cb 81		    res 0,c 
01f6			.b0: 
01f6				; then low 
01f6 cb af			res SPI_SCLK,a 
01f8 d3 80			out (storage_adata),a 
01fa 00				nop 
01fb cd ea 00			call spi_clk 
01fe			 
01fe			 
01fe 32 5e fa			ld (spi_portbyte),a 
0201			 
0201			    ; return byte 
0201 79			    ld a,c 
0202			 
0202			 
0202 c9				ret 
0203			 
0203			 
0203			 
0203			spi_ce_high: 
0203			 
0203				if DEBUG_SPI_HARD_CE0 
0203			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0203					ret 
0203			 
0203				endif 
0203			 
0203			 
0203 f5				push af 
0204			 
0204				; send direct ce to port b 
0204 3e ff			ld a, 255 
0206 d3 81			out (storage_bdata), a 
0208			 
0208 f1				pop af 
0209			 
0209				; for port a that shares with spi lines AND the mask 
0209			  
0209				if DEBUG_SPI 
0209					push hl 
0209					ld h, a 
0209				endif 
0209			;	ld c, SPI_CE_HIGH 
0209			;	and c 
0209 cb c7			set SPI_CE0, a 
020b cb cf			set SPI_CE1, a 
020d cb d7			set SPI_CE2, a 
020f cb df			set SPI_CE3, a 
0211 cb e7			set SPI_CE4, a 
0213			 
0213				if DEBUG_SPI 
0213					ld l, a 
0213					DMARK "CEh" 
0213					CALLMONITOR 
0213					pop hl 
0213				endif 
0213 c9				ret 
0214			 
0214			 
0214			spi_ce_low: 
0214			 
0214				if DEBUG_SPI_HARD_CE0 
0214			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0214					ret 
0214			 
0214				endif 
0214			 
0214 c5				push bc 
0215 f5				push af 
0216			 
0216				; send direct ce to port b 
0216 3a 60 fa			ld a, (spi_cartdev) 
0219 d3 81			out (storage_bdata), a 
021b			 
021b			 
021b			 
021b				; for port a that shares with spi lines AND the mask 
021b			 
021b 3a 5d fa			ld a, (spi_device)  
021e 4f				ld c, a 
021f			 
021f f1				pop af 
0220			 
0220				; detect CEx 
0220			 
0220				if DEBUG_SPI 
0220					push hl 
0220					ld h, a 
0220				endif 
0220			 
0220 cb 41			bit SPI_CE0, c 
0222 20 04			jr nz, .cel1 
0224 cb 87			res SPI_CE0, a 
0226 18 1e			jr .celn 
0228			.cel1: 
0228 cb 49			bit SPI_CE1, c 
022a 20 04			jr nz, .cel2 
022c cb 8f			res SPI_CE1, a 
022e 18 16			jr .celn 
0230			.cel2: 
0230 cb 51			bit SPI_CE2, c 
0232 20 04			jr nz, .cel3 
0234 cb 97			res SPI_CE2, a 
0236 18 0e			jr .celn 
0238			.cel3: 
0238 cb 59			bit SPI_CE3, c 
023a 20 04			jr nz, .cel4 
023c cb 9f			res SPI_CE3, a 
023e 18 06			jr .celn 
0240			.cel4: 
0240 cb 61			bit SPI_CE4, c 
0242 20 02			jr nz, .celn 
0244 cb a7			res SPI_CE4, a 
0246			.celn: 
0246			 
0246			 
0246			 
0246			;	add c 
0246			 
0246				if DEBUG_SPI 
0246					ld l, a 
0246					DMARK "CEl" 
0246					CALLMONITOR 
0246					pop hl 
0246				endif 
0246 c1				pop bc 
0247 c9				ret 
0248			 
0248			 
0248			 
0248			; eof 
0248			 
0248			 
0248			 
0248			 
0248			 
# End of file firmware_spi.asm
0248				include "firmware_seeprom.asm"  
0248			; 
0248			; persisent storage interface via microchip serial eeprom 
0248			 
0248			; port a pio 2 
0248			; pa 7 - si 
0248			; pa 6 - sclk  
0248			; pa 5 - so 
0248			; pa 4 - cs 
0248			; pa 3 - cs 
0248			; pa 2 - cs 
0248			; pa 1 - cs 
0248			; pa 0 - cs 
0248			; 
0248			; TODO get block 
0248			; TODO save block 
0248			; TODO load file 
0248			; TODO save file 
0248			; TODO get dir  
0248			 
0248			;  
0248			storage_adata: equ Device_C    ; device c port a - onboard storage 
0248			storage_actl: equ Device_C+2     ; device c port a 
0248			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0248			storage_bctl: equ Device_C+3     ; device c port b 
0248			 
0248			 
0248			; TODO move these to hardware driver file 
0248			 
0248			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0248			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0248			; storage bank file system format 
0248			; 
0248			; first page of bank: 
0248			; 	addr 0 - status check 
0248			;       addr 1 - write protect flag 
0248			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0248			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0248			;         TODO see if scanning whole of for available next file id is fast enough 
0248			;	addr 4 > zero term string of bank label 
0248			; 
0248			;        
0248			;  
0248			; first page of any file: 
0248			;      byte 0 - file id  
0248			;      byte 1-17 - fixed file name  
0248			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0248			; 
0248			; other pages of any file: 
0248			;      byte 0 - file id 
0248			;      byte 1> - file data 
0248			; 
0248			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0248			;  
0248			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0248			 
0248			 
0248			;storage_so_bit: 5 
0248			;storage_si_bit: 7 
0248			;storage_sclk_bit: 6 
0248			  
0248			 
0248			; init storage pio 
0248			 
0248			storage_init: 
0248			 
0248			 
0248					; set default SPI clk pulse time as disabled 
0248			 
0248 3e 00				ld a, 0 
024a 32 61 fa				ld (spi_clktime), a 
024d			 
024d					; init hardware 
024d			 
024d 3e cf		            LD   A, 11001111b 
024f d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0251 3e 00		            LD   A, 00000000b 
0253 cb f7			set SPI_DO,a 
0255			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0255 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0257			 
0257 3e cf		            LD   A, 11001111b 
0259 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025b 3e 00		            LD   A, 00000000b 
025d d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025f			 
025f				; set all external spi devices off  
025f 3e ff			ld a, 255 
0261 32 5d fa			ld (spi_device), a 
0264 32 60 fa			ld (spi_cartdev), a 
0267			 
0267					; ensure the spi bus is in a default stable state 
0267 cd f7 00				call se_stable_spi 
026a			 
026a			; TODO scan spi bus and gather which storage banks are present 
026a			 
026a			; populate store_bank_active  
026a			; for each ce line activate and attempt to write first byte of bank and read back 
026a			; if zero is returned then bank is empty 
026a			;   
026a			; 
026a			 
026a					; init file extent cache to save on slow reads 
026a			 
026a			;	ld hl, store_filecache 
026a			;	ld de, 0 
026a			;	ld hl,(de)	 
026a			 
026a			 
026a c9			    ret 
026b			 
026b			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026b			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026b			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026b			 
026b			; INSTRUCTION SET 
026b			; READ 0000 0011 Read data from memory array beginning at selected address 
026b			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026b			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026b			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026b			; RDSR 0000 0101 Read STATUS register 
026b			; WRSR 0000 0001 Write STATUS register 
026b			; PE 0100 0010 Page Erase – erase one page in memory array 
026b			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026b			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026b			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026b			 
026b			; TODO send byte steam for page without setting the address for every single byte 
026b			; TODO read byte  
026b			 
026b			; byte in a 
026b			; address in hl  
026b			se_writebyte: 
026b			        
026b			    ;   ld c, a 
026b f5			        push af 
026c e5			        push hl 
026d			 
026d			    ; initi write mode 
026d			    ; 
026d			    ;CS low 
026d			 
026d 3a 5e fa		       ld a,(spi_portbyte) 
0270 cd 14 02			call spi_ce_low 
0273			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0273 d3 80		       out (storage_adata),a 
0275 32 5e fa		       ld (spi_portbyte), a 
0278			 
0278			    ;clock out wren instruction 
0278			 
0278 3e 06		    ld a, store_wren_ins 
027a cd 02 01		    call spi_send_byte  
027d			 
027d			    ;cs high to enable write latch 
027d			 
027d 3a 5e fa		       ld a,(spi_portbyte) 
0280 cd 03 02			call spi_ce_high 
0283			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0283 d3 80		       out (storage_adata),a 
0285 32 5e fa		       ld (spi_portbyte), a 
0288			 
0288 00				nop 
0289			    ; 
0289			    ; intial write data 
0289			    ; 
0289			    ; cs low 
0289			     
0289 3a 5e fa		       ld a,(spi_portbyte) 
028c cd 14 02			call spi_ce_low 
028f			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028f d3 80		       out (storage_adata),a 
0291 32 5e fa		       ld (spi_portbyte), a 
0294			 
0294			    ; clock out write instruction 
0294			     
0294 3e 02		    ld a, store_write_ins  
0296 cd 02 01		    call spi_send_byte  
0299			 
0299			    ; clock out address (depending on address size) 
0299			     
0299 e1			    pop hl 
029a 7c			    ld a,h    ; address out msb first 
029b cd 02 01		    call spi_send_byte  
029e 7d			    ld a,l 
029f cd 02 01		    call spi_send_byte  
02a2			 
02a2			    ; clock out byte(s) for page 
02a2			 
02a2 f1			    pop af 
02a3 cd 02 01		    call spi_send_byte  
02a6			 
02a6			    ; end write with ce high 
02a6 3a 5e fa		       ld a,(spi_portbyte) 
02a9			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a9 cd 03 02			call spi_ce_high 
02ac d3 80		       out (storage_adata),a 
02ae 32 5e fa		       ld (spi_portbyte), a 
02b1			 
02b1				; pause for internal write cycle 
02b1 3e 0a			ld a, 10 
02b3 cd c4 0c			call aDelayInMS 
02b6 c9			    ret 
02b7			 
02b7			; buffer to write in de 
02b7			; address in hl  
02b7			se_writepage: 
02b7			        
02b7			    ;   ld c, a 
02b7 d5				push de 
02b8 e5			        push hl 
02b9			 
02b9			    ; initi write mode 
02b9			    ; 
02b9			    ;CS low 
02b9			 
02b9 3a 5e fa		       ld a,(spi_portbyte) 
02bc cd 14 02			call spi_ce_low 
02bf			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02bf d3 80		       out (storage_adata),a 
02c1 32 5e fa		       ld (spi_portbyte), a 
02c4			 
02c4			    ;clock out wren instruction 
02c4			 
02c4 3e 06		    ld a, store_wren_ins 
02c6 cd 02 01		    call spi_send_byte  
02c9			 
02c9			    ;cs high to enable write latch 
02c9			 
02c9 3a 5e fa		       ld a,(spi_portbyte) 
02cc cd 03 02			call spi_ce_high 
02cf			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cf d3 80		       out (storage_adata),a 
02d1 32 5e fa		       ld (spi_portbyte), a 
02d4			 
02d4 00				nop 
02d5			    ; 
02d5			    ; intial write data 
02d5			    ; 
02d5			    ; cs low 
02d5			     
02d5 3a 5e fa		       ld a,(spi_portbyte) 
02d8			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d8 cd 14 02			call spi_ce_low 
02db d3 80		       out (storage_adata),a 
02dd 32 5e fa		       ld (spi_portbyte), a 
02e0			 
02e0			    ; clock out write instruction 
02e0			     
02e0 3e 02		    ld a, store_write_ins  
02e2 cd 02 01		    call spi_send_byte  
02e5			 
02e5			    ; clock out address (depending on address size) 
02e5			     
02e5 e1			    pop hl 
02e6 7c			    ld a,h    ; address out msb first 
02e7 cd 02 01		    call spi_send_byte  
02ea 7d			    ld a,l 
02eb cd 02 01		    call spi_send_byte  
02ee			 
02ee			    ; clock out byte(s) for page 
02ee			 
02ee e1				pop hl 
02ef 06 40			ld b, STORE_BLOCK_PHY 
02f1			.bytewrite: 
02f1			 
02f1 7e				ld a,(hl) 
02f2 e5			    push hl 
02f3 c5				push bc 
02f4 cd 02 01		    call spi_send_byte  
02f7 c1				pop bc 
02f8 e1				pop hl 
02f9			 
02f9			    ; end write with ce high 
02f9 3a 5e fa		       ld a,(spi_portbyte) 
02fc cd 03 02			call spi_ce_high 
02ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ff d3 80		       out (storage_adata),a 
0301 32 5e fa		       ld (spi_portbyte), a 
0304			 
0304 23				inc hl 
0305 10 ea			djnz .bytewrite 
0307			 
0307				; pause for internal write cycle 
0307 3e 64			ld a, 100 
0309 cd c4 0c			call aDelayInMS 
030c c9			    ret 
030d			; returns byte in a 
030d			; address in hl  
030d			se_readbyte: 
030d d5				push de 
030e c5				push bc 
030f			 
030f			    ;   ld c, a 
030f e5			        push hl 
0310			 
0310			    ; initi write mode 
0310			    ; 
0310			    ;CS low 
0310			 
0310 3a 5e fa		       ld a,(spi_portbyte) 
0313 cd 14 02			call spi_ce_low 
0316			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0316 d3 80		       out (storage_adata),a 
0318 32 5e fa		       ld (spi_portbyte), a 
031b			 
031b			    ;clock out wren instruction 
031b			 
031b 3e 03		    ld a, store_read_ins 
031d cd 02 01		    call spi_send_byte  
0320			 
0320			 
0320			    ; clock out address (depending on address size) 
0320			     
0320 e1			    pop hl 
0321 7c			    ld a,h    ; address out msb first 
0322 cd 02 01		    call spi_send_byte  
0325 7d			    ld a,l 
0326 cd 02 01		    call spi_send_byte  
0329			 
0329			    ; clock in byte(s) for page 
0329			 
0329 cd 29 01		    call spi_read_byte  
032c f5				push af 
032d			 
032d			    ; end write with ce high 
032d 3a 5e fa		       ld a,(spi_portbyte) 
0330			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0330 cd 03 02			call spi_ce_high 
0333 d3 80		       out (storage_adata),a 
0335 32 5e fa		       ld (spi_portbyte), a 
0338			 
0338 f1				pop af 
0339			 
0339 c1				pop bc 
033a d1				pop de 
033b			 
033b c9			    ret 
033c			 
033c			if DEBUG_STORESE 
033c			 
033c			storageput:  
033c			 
033c			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033c			 
033c 21 c0 f1			ld hl,scratch+2 
033f cd 87 13			call get_word_hl 
0342			 
0342				; stuff it here for the moment as it will be overwritten later anyway 
0342			 
0342 22 e1 f4			ld (os_cur_ptr),hl	 
0345			 
0345			 
0345			; get pointer to start of string 
0345			 
0345 21 c5 f1			ld hl, scratch+7 
0348			 
0348			; loop writing char of string to eeprom 
0348			 
0348 7e			.writestr:	ld a,(hl) 
0349 fe 00				cp 0 
034b 28 12				jr z, .wsdone		; done writing 
034d e5					push hl 
034e 2a e1 f4				ld hl,(os_cur_ptr) 
0351 cd 6b 02				call se_writebyte 
0354			 
0354 2a e1 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0357 23					inc hl 
0358 22 e1 f4				ld (os_cur_ptr),hl 
035b			 
035b					; restore string pointer and get next char 
035b			 
035b e1					pop hl 
035c 23					inc hl 
035d 18 e9				jr .writestr 
035f			 
035f			 
035f			 
035f			.wsdone: 
035f			 
035f			 
035f			; when done load first page into a buffer  
035f			 
035f 21 00 80				ld hl,08000h		; start in ram 
0362 22 e1 f4				ld (os_cur_ptr),hl 
0365 21 00 00				ld hl, 0		 ; start of page 
0368 22 e6 f1				ld (scratch+40),hl	; hang on to it 
036b			 
036b 06 80				ld b, 128		; actually get more then one page 
036d c5			.wsload:	push bc 
036e 2a e6 f1				ld hl,(scratch+40) 
0371 e5					push hl 
0372 cd 0d 03				call se_readbyte 
0375			 
0375					; a now as the byte 
0375			 
0375 2a e1 f4				ld hl,(os_cur_ptr) 
0378 77					ld (hl),a 
0379					; inc next buffer area 
0379 23					inc hl 
037a 22 e1 f4				ld (os_cur_ptr),hl 
037d			 
037d					; get eeprom position, inc and save for next round 
037d e1					pop hl		 
037e 23					inc hl 
037f 22 e6 f1				ld (scratch+40),hl 
0382 c1					pop bc 
0383 10 e8				djnz .wsload 
0385			 
0385			; set 'd' pointer to start of buffer 
0385			 
0385 21 00 80				ld hl,08000h 
0388 22 e1 f4				ld (os_cur_ptr),hl 
038b			 
038b			 
038b c9			ret 
038c			 
038c			 
038c c9			storageread: ret 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			endif 
038d			 
038d			 
038d			 
# End of file firmware_seeprom.asm
038d			else  
038d			   ; create some stubs for the labels  
038d			se_readbyte: ret  
038d			se_writebyte: ret  
038d			storage_init: ret  
038d			  
038d			endif  
038d			  
038d			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038d			;include "firmware_cf.asm"  
038d			  
038d			; load up high level storage hardward abstractions  
038d			include "firmware_storage.asm"  
038d			 
038d			; persisent storage hardware abstraction layer  
038d			 
038d			 
038d			 
038d			; Block 0 on storage is a config state 
038d			 
038d			 
038d			 
038d			; TODO add read phy block and write phy block functions 
038d			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038d			 
038d			; Abstraction layer  
038d			 
038d			; Logocial block size is same size as physical size - using tape concept 
038d			 
038d			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038d			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038d			 
038d			 
038d			 
038d			; Filesystem layout (Logical layout) 
038d			; 
038d			; Block 0 - Bank config  
038d			; 
038d			;      Byte - 0 file id counter 
038d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038d			;      Byte - 3-20 zero terminated bank label 
038d			; 
038d			; Block 1 > File storage 
038d			; 
038d			;      Byte 0 file id    - block 0 file details 
038d			;      Byte 1 block id - block 0 is file  
038d			;            Byte 2-15 - File name 
038d			; 
038d			;       - to end of block data 
038d			; 
038d			 
038d			; Get ID for the file named in pointer held HL 
038d			; Returns ID in HL = 255 if no file found 
038d			 
038d			storage_getid: 
038d			 
038d 22 70 fa			ld (store_tmp1), hl 
0390			 
0390				if DEBUG_STORESE 
0390					DMARK "SGI" 
0390 f5				push af  
0391 3a a5 03			ld a, (.dmark)  
0394 32 68 fe			ld (debug_mark),a  
0397 3a a6 03			ld a, (.dmark+1)  
039a 32 69 fe			ld (debug_mark+1),a  
039d 3a a7 03			ld a, (.dmark+2)  
03a0 32 6a fe			ld (debug_mark+2),a  
03a3 18 03			jr .pastdmark  
03a5 ..			.dmark: db "SGI"  
03a8 f1			.pastdmark: pop af  
03a9			endm  
# End of macro DMARK
03a9					CALLMONITOR 
03a9 cd 6c fe			call debug_vector  
03ac				endm  
# End of macro CALLMONITOR
03ac				endif 
03ac				; get block 0 and set counter for number of files to scan 
03ac			 
03ac cd 17 05			call storage_get_block_0 
03af			 
03af 3a 77 fa			ld a, (store_page) 
03b2 47				ld b, a 
03b3			 
03b3				; get extent 0 of each file id 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 68 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 69 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 6a fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd 6c fe			call debug_vector  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf 60			.getloop:	ld h, b 
03d0 2e 00				ld l, 0 
03d2 c5					push bc 
03d3			 
03d3 11 77 fa				ld de, store_page 
03d6				if DEBUG_STORESE 
03d6					DMARK "SGr" 
03d6 f5				push af  
03d7 3a eb 03			ld a, (.dmark)  
03da 32 68 fe			ld (debug_mark),a  
03dd 3a ec 03			ld a, (.dmark+1)  
03e0 32 69 fe			ld (debug_mark+1),a  
03e3 3a ed 03			ld a, (.dmark+2)  
03e6 32 6a fe			ld (debug_mark+2),a  
03e9 18 03			jr .pastdmark  
03eb ..			.dmark: db "SGr"  
03ee f1			.pastdmark: pop af  
03ef			endm  
# End of macro DMARK
03ef					CALLMONITOR 
03ef cd 6c fe			call debug_vector  
03f2				endm  
# End of macro CALLMONITOR
03f2				endif 
03f2 cd bf 09				call storage_read 
03f5 cd f9 0f				call ishlzero 
03f8 28 2d				jr z, .gap 
03fa					 
03fa					; have a file name read. Is it one we want. 
03fa			 
03fa 2a 70 fa				ld hl, (store_tmp1) 
03fd 11 7a fa				ld de, store_page+3   ; file name 
0400			 
0400				if DEBUG_STORESE 
0400					DMARK "SGc" 
0400 f5				push af  
0401 3a 15 04			ld a, (.dmark)  
0404 32 68 fe			ld (debug_mark),a  
0407 3a 16 04			ld a, (.dmark+1)  
040a 32 69 fe			ld (debug_mark+1),a  
040d 3a 17 04			ld a, (.dmark+2)  
0410 32 6a fe			ld (debug_mark+2),a  
0413 18 03			jr .pastdmark  
0415 ..			.dmark: db "SGc"  
0418 f1			.pastdmark: pop af  
0419			endm  
# End of macro DMARK
0419					CALLMONITOR 
0419 cd 6c fe			call debug_vector  
041c				endm  
# End of macro CALLMONITOR
041c				endif 
041c cd 66 14				call strcmp 
041f 20 06				jr nz, .gap   ; not this one 
0421			 
0421 c1				        pop bc 
0422			 
0422 26 00				ld h, 0 
0424 68					ld l, b 
0425 18 22				jr .getdone 
0427						 
0427			 
0427			 
0427			 
0427			.gap: 
0427				if DEBUG_STORESE 
0427					DMARK "SGg" 
0427 f5				push af  
0428 3a 3c 04			ld a, (.dmark)  
042b 32 68 fe			ld (debug_mark),a  
042e 3a 3d 04			ld a, (.dmark+1)  
0431 32 69 fe			ld (debug_mark+1),a  
0434 3a 3e 04			ld a, (.dmark+2)  
0437 32 6a fe			ld (debug_mark+2),a  
043a 18 03			jr .pastdmark  
043c ..			.dmark: db "SGg"  
043f f1			.pastdmark: pop af  
0440			endm  
# End of macro DMARK
0440					CALLMONITOR 
0440 cd 6c fe			call debug_vector  
0443				endm  
# End of macro CALLMONITOR
0443				endif 
0443			 
0443 c1					pop bc 
0444 10 89				djnz .getloop 
0446 21 ff 00				ld hl, 255 
0449			.getdone: 
0449			 
0449				if DEBUG_STORESE 
0449					DMARK "SGe" 
0449 f5				push af  
044a 3a 5e 04			ld a, (.dmark)  
044d 32 68 fe			ld (debug_mark),a  
0450 3a 5f 04			ld a, (.dmark+1)  
0453 32 69 fe			ld (debug_mark+1),a  
0456 3a 60 04			ld a, (.dmark+2)  
0459 32 6a fe			ld (debug_mark+2),a  
045c 18 03			jr .pastdmark  
045e ..			.dmark: db "SGe"  
0461 f1			.pastdmark: pop af  
0462			endm  
# End of macro DMARK
0462					CALLMONITOR 
0462 cd 6c fe			call debug_vector  
0465				endm  
# End of macro CALLMONITOR
0465				endif 
0465			 
0465 c9				ret 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			; Read Block 
0466			; ---------- 
0466			; 
0466			; With current bank 
0466			;  
0466			; Get block number to read 
0466			; Load physical blocks starting at start block into buffer 
0466			 
0466			; de points to buffer to use 
0466			; hl holds logical block number  
0466			 
0466			storage_read_block: 
0466			 
0466				; TODO bank selection 
0466			 
0466				; for each of the physical blocks read it into the buffer 
0466 06 40			ld b, STORE_BLOCK_PHY 
0468			 
0468				if DEBUG_STORESE 
0468 d5					push de 
0469				endif 
0469				 
0469			.rl1:    
0469			 
0469				; read physical block at hl into de 
0469			        ; increment hl and de to next read position on exit 
0469			 
0469 e5				push hl 
046a d5				push de	 
046b c5				push bc 
046c			;	if DEBUG_STORESE 
046c			;		push af 
046c			;		ld a, 'R' 
046c			;		ld (debug_mark),a 
046c			;		pop af 
046c			;		CALLMONITOR 
046c			;	endif 
046c cd 0d 03			call se_readbyte 
046f			;	if DEBUG_STORESE 
046f			;		ld a,(spi_portbyte) 
046f			;		ld l, a 
046f			;		push af 
046f			;		ld a, '1' 
046f			;		ld (debug_mark),a 
046f			;		pop af 
046f			;		CALLMONITOR 
046f			;	endif 
046f c1				pop bc 
0470 d1				pop de 
0471 e1				pop hl 
0472 12				ld (de),a 
0473 23				inc hl 
0474 13				inc de 
0475			 
0475			;	if DEBUG_STORESE 
0475			;		push af 
0475			;		ld a, 'r' 
0475			;		ld (debug_mark),a 
0475			;		pop af 
0475			;		CALLMONITOR 
0475			;	endif 
0475			 
0475 10 f2			djnz .rl1 
0477			 
0477				if DEBUG_STORESE 
0477					DMARK "SRB" 
0477 f5				push af  
0478 3a 8c 04			ld a, (.dmark)  
047b 32 68 fe			ld (debug_mark),a  
047e 3a 8d 04			ld a, (.dmark+1)  
0481 32 69 fe			ld (debug_mark+1),a  
0484 3a 8e 04			ld a, (.dmark+2)  
0487 32 6a fe			ld (debug_mark+2),a  
048a 18 03			jr .pastdmark  
048c ..			.dmark: db "SRB"  
048f f1			.pastdmark: pop af  
0490			endm  
# End of macro DMARK
0490 d1					pop de 
0491			; 
0491			;		push af 
0491			;		ld a, 'R' 
0491			;		ld (debug_mark),a 
0491			;		pop af 
0491					CALLMONITOR 
0491 cd 6c fe			call debug_vector  
0494				endm  
# End of macro CALLMONITOR
0494				endif 
0494 c9				ret	 
0495				 
0495			 
0495			; File Size 
0495			; --------- 
0495			; 
0495			;   hl file id 
0495			; 
0495			;  returns in hl the number of blocks 
0495			 
0495			storage_file_size: 
0495 5d				ld e, l 
0496 16 00			ld d, 0 
0498 21 40 00			ld hl, STORE_BLOCK_PHY 
049b					if DEBUG_FORTH_WORDS 
049b						DMARK "SIZ" 
049b f5				push af  
049c 3a b0 04			ld a, (.dmark)  
049f 32 68 fe			ld (debug_mark),a  
04a2 3a b1 04			ld a, (.dmark+1)  
04a5 32 69 fe			ld (debug_mark+1),a  
04a8 3a b2 04			ld a, (.dmark+2)  
04ab 32 6a fe			ld (debug_mark+2),a  
04ae 18 03			jr .pastdmark  
04b0 ..			.dmark: db "SIZ"  
04b3 f1			.pastdmark: pop af  
04b4			endm  
# End of macro DMARK
04b4						CALLMONITOR 
04b4 cd 6c fe			call debug_vector  
04b7				endm  
# End of macro CALLMONITOR
04b7					endif 
04b7 cd 99 07			call storage_findnextid 
04ba			 
04ba cd f9 0f			call ishlzero 
04bd			;	ld a, l 
04bd			;	add h 
04bd			;	cp 0 
04bd c8				ret z			; block not found so EOF 
04be			 
04be 11 77 fa			ld de, store_page 
04c1 cd 66 04			call storage_read_block 
04c4			 
04c4 3a 79 fa			ld a, (store_page+2)	 ; get extent count 
04c7 6f				ld l, a 
04c8 26 00			ld h, 0 
04ca c9			 	ret 
04cb			 
04cb			 
04cb			; Write Block 
04cb			; ----------- 
04cb			; 
04cb			; With current bank 
04cb			;  
04cb			; Get block number to write 
04cb			; Write physical blocks starting at start block from buffer 
04cb			  
04cb			storage_write_block: 
04cb				; TODO bank selection 
04cb			 
04cb				; for each of the physical blocks read it into the buffer 
04cb 06 40			ld b, STORE_BLOCK_PHY 
04cd			 
04cd				if DEBUG_STORESE 
04cd					DMARK "SWB" 
04cd f5				push af  
04ce 3a e2 04			ld a, (.dmark)  
04d1 32 68 fe			ld (debug_mark),a  
04d4 3a e3 04			ld a, (.dmark+1)  
04d7 32 69 fe			ld (debug_mark+1),a  
04da 3a e4 04			ld a, (.dmark+2)  
04dd 32 6a fe			ld (debug_mark+2),a  
04e0 18 03			jr .pastdmark  
04e2 ..			.dmark: db "SWB"  
04e5 f1			.pastdmark: pop af  
04e6			endm  
# End of macro DMARK
04e6			 
04e6					;push af 
04e6					;ld a, 'W' 
04e6					;ld (debug_mark),a 
04e6					;pop af 
04e6					CALLMONITOR 
04e6 cd 6c fe			call debug_vector  
04e9				endm  
# End of macro CALLMONITOR
04e9				endif 
04e9			 
04e9			; might not be working 
04e9			;	call se_writepage 
04e9			 
04e9			;	ret 
04e9			; 
04e9			 
04e9			 
04e9			 
04e9			.wl1:    
04e9			 
04e9				; read physical block at hl into de 
04e9			        ; increment hl and de to next read position on exit 
04e9			 
04e9 e5				push hl 
04ea d5				push de	 
04eb c5				push bc 
04ec 1a				ld a,(de) 
04ed				;if DEBUG_STORESE 
04ed			;		push af 
04ed			;		ld a, 'W' 
04ed			;		ld (debug_mark),a 
04ed			;		pop af 
04ed			;		CALLMONITOR 
04ed			;	endif 
04ed cd 6b 02			call se_writebyte 
04f0			;	call delay250ms 
04f0 00				nop 
04f1 00				nop 
04f2 00				nop 
04f3			;	if DEBUG_STORESE 
04f3			;		push af 
04f3			;		ld a, 'w' 
04f3			;		ld (debug_mark),a 
04f3			;		pop af 
04f3			;		CALLMONITOR 
04f3			;	endif 
04f3 c1				pop bc 
04f4 d1				pop de 
04f5 e1				pop hl 
04f6 23				inc hl 
04f7 13				inc de 
04f8			 
04f8			 
04f8 10 ef			djnz .wl1 
04fa			 
04fa				if DEBUG_STORESE 
04fa					DMARK "SW2" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 68 fe			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 69 fe			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 6a fe			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "SW2"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513			 
0513					;push af 
0513					;ld a, 'W' 
0513					;ld (debug_mark),a 
0513					;pop af 
0513					CALLMONITOR 
0513 cd 6c fe			call debug_vector  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 c9				ret	 
0517			 
0517			; Init bank 
0517			; --------- 
0517			; 
0517			; With current bank 
0517			; 
0517			; Setup block 0 config 
0517			;     Set 0 file id counter 
0517			;     Set formatted byte pattern 
0517			;     Zero out bank label 
0517			;      
0517			; For every logical block write 0-1 byte as null 
0517			 
0517			storage_get_block_0: 
0517			 
0517				; TODO check presence 
0517			 
0517				; get block 0 config 
0517			 
0517 21 00 00			ld hl, 0 
051a 11 77 fa			ld de, store_page 
051d cd 66 04			call storage_read_block 
0520			 
0520				if DEBUG_STORESE 
0520					DMARK "SB0" 
0520 f5				push af  
0521 3a 35 05			ld a, (.dmark)  
0524 32 68 fe			ld (debug_mark),a  
0527 3a 36 05			ld a, (.dmark+1)  
052a 32 69 fe			ld (debug_mark+1),a  
052d 3a 37 05			ld a, (.dmark+2)  
0530 32 6a fe			ld (debug_mark+2),a  
0533 18 03			jr .pastdmark  
0535 ..			.dmark: db "SB0"  
0538 f1			.pastdmark: pop af  
0539			endm  
# End of macro DMARK
0539 11 77 fa				ld de, store_page 
053c			;		push af 
053c			;		ld a, 'i' 
053c			;		ld (debug_mark),a 
053c			;		pop af 
053c					CALLMONITOR 
053c cd 6c fe			call debug_vector  
053f				endm  
# End of macro CALLMONITOR
053f				endif 
053f			 
053f				; is this area formatted? 
053f			 
053f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053f 2a 78 fa			ld hl, (store_page+1) 
0542 3e 80			ld a,0x80 
0544 bd				cp l 
0545 20 22			jr nz, .ininotformatted 
0547				; do a double check 
0547 3e 27			ld a, 0x27 
0549 bc				cp h 
054a 20 1d			jr nz, .ininotformatted 
054c			 
054c				; formatted then 
054c			 
054c				if DEBUG_STORESE 
054c					DMARK "SB1" 
054c f5				push af  
054d 3a 61 05			ld a, (.dmark)  
0550 32 68 fe			ld (debug_mark),a  
0553 3a 62 05			ld a, (.dmark+1)  
0556 32 69 fe			ld (debug_mark+1),a  
0559 3a 63 05			ld a, (.dmark+2)  
055c 32 6a fe			ld (debug_mark+2),a  
055f 18 03			jr .pastdmark  
0561 ..			.dmark: db "SB1"  
0564 f1			.pastdmark: pop af  
0565			endm  
# End of macro DMARK
0565					;push af 
0565					;ld a, 'I' 
0565					;ld (debug_mark),a 
0565					;pop af 
0565					CALLMONITOR 
0565 cd 6c fe			call debug_vector  
0568				endm  
# End of macro CALLMONITOR
0568				endif 
0568 c9				ret 
0569			 
0569			.ininotformatted: 
0569				; bank not formatted so poke various bits to make sure 
0569			 
0569				if DEBUG_STORESE 
0569					DMARK "SB2" 
0569 f5				push af  
056a 3a 7e 05			ld a, (.dmark)  
056d 32 68 fe			ld (debug_mark),a  
0570 3a 7f 05			ld a, (.dmark+1)  
0573 32 69 fe			ld (debug_mark+1),a  
0576 3a 80 05			ld a, (.dmark+2)  
0579 32 6a fe			ld (debug_mark+2),a  
057c 18 03			jr .pastdmark  
057e ..			.dmark: db "SB2"  
0581 f1			.pastdmark: pop af  
0582			endm  
# End of macro DMARK
0582					;push af 
0582					;ld a, 'f' 
0582					;ld (debug_mark),a 
0582					;pop af 
0582					CALLMONITOR 
0582 cd 6c fe			call debug_vector  
0585				endm  
# End of macro CALLMONITOR
0585				endif 
0585			 
0585 cd a2 0c			call storage_clear_page 
0588			 
0588 21 77 fa			ld hl, store_page 
058b 3e 00			ld a, 0 
058d				 
058d 77				ld (hl),a   ; reset file counter 
058e			 
058e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0591 22 78 fa		 	ld (store_page+1), hl	 
0594			 
0594				; set default label 
0594			 
0594 21 30 06			ld hl, .defaultbanklabl 
0597 11 7a fa		 	ld de, store_page+3 
059a 01 0f 00			ld bc, 15 
059d ed b0			ldir 
059f			 
059f				; Append the current bank id 
059f 21 83 fa			ld hl, store_page+3+9 
05a2 3a 5c fa			ld a, (spi_device_id) 
05a5 77				ld (hl), a 
05a6			 
05a6				; save default page 0 
05a6			 
05a6 21 00 00			ld hl, 0 
05a9 11 77 fa			ld de, store_page 
05ac				if DEBUG_STORESE 
05ac					DMARK "SB3" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 68 fe			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 69 fe			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 6a fe			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "SB3"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5			;		push af 
05c5			;		ld a, 'F' 
05c5			;		ld (debug_mark),a 
05c5			;		pop af 
05c5					CALLMONITOR 
05c5 cd 6c fe			call debug_vector  
05c8				endm  
# End of macro CALLMONITOR
05c8				endif 
05c8 cd cb 04			call storage_write_block 
05cb				if DEBUG_STORESE 
05cb					DMARK "SB4" 
05cb f5				push af  
05cc 3a e0 05			ld a, (.dmark)  
05cf 32 68 fe			ld (debug_mark),a  
05d2 3a e1 05			ld a, (.dmark+1)  
05d5 32 69 fe			ld (debug_mark+1),a  
05d8 3a e2 05			ld a, (.dmark+2)  
05db 32 6a fe			ld (debug_mark+2),a  
05de 18 03			jr .pastdmark  
05e0 ..			.dmark: db "SB4"  
05e3 f1			.pastdmark: pop af  
05e4			endm  
# End of macro DMARK
05e4			;		push af 
05e4			;		ld a, '>' 
05e4			;		ld (debug_mark),a 
05e4			;		pop af 
05e4					CALLMONITOR 
05e4 cd 6c fe			call debug_vector  
05e7				endm  
# End of macro CALLMONITOR
05e7				endif 
05e7			 
05e7 00				nop 
05e8 00				nop 
05e9 00				nop 
05ea			 
05ea				; now set 0 in every page to mark as a free block 
05ea			 
05ea 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ec 21 40 00			ld hl, STORE_BLOCK_PHY 
05ef			 
05ef 3e 00		.setmark1:   	ld a,0 
05f1 e5					push hl 
05f2 c5					push bc 
05f3 cd 6b 02				call se_writebyte 
05f6 3e 0a			ld a, 10 
05f8 cd c4 0c			call aDelayInMS 
05fb 23				inc hl 
05fc cd 6b 02				call se_writebyte 
05ff 3e 0a			ld a, 10 
0601 cd c4 0c			call aDelayInMS 
0604 2b				dec hl 
0605 c1					pop bc 
0606 e1					pop hl 
0607 3e 40				ld a, STORE_BLOCK_PHY 
0609 cd d0 0f				call addatohl 
060c 10 e1				djnz .setmark1 
060e			 
060e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0610 3e 00		.setmark2:   	ld a,0 
0612 e5					push hl 
0613 c5					push bc 
0614 cd 6b 02				call se_writebyte 
0617 3e 0a			ld a, 10 
0619 cd c4 0c			call aDelayInMS 
061c 23				inc hl 
061d cd 6b 02				call se_writebyte 
0620 3e 0a			ld a, 10 
0622 cd c4 0c			call aDelayInMS 
0625 2b				dec hl 
0626 c1					pop bc 
0627 e1					pop hl 
0628 3e 40				ld a, STORE_BLOCK_PHY 
062a cd d0 0f				call addatohl 
062d 10 e1				djnz .setmark2 
062f			 
062f					 
062f			 
062f			 
062f c9				ret 
0630			 
0630			 
0630			 
0630			 
0630 .. 00		.defaultbanklabl:   db "BankLabel_",0 
063b			 
063b			 
063b			 
063b			; Label Bank 
063b			; ---------- 
063b			; 
063b			; With current bank 
063b			; Read block 0 
063b			; Set label 
063b			; Write block 0 
063b			 
063b			; label str pointer in hl 
063b			 
063b			storage_label:     
063b			 
063b				if DEBUG_STORESE 
063b					DMARK "LBL" 
063b f5				push af  
063c 3a 50 06			ld a, (.dmark)  
063f 32 68 fe			ld (debug_mark),a  
0642 3a 51 06			ld a, (.dmark+1)  
0645 32 69 fe			ld (debug_mark+1),a  
0648 3a 52 06			ld a, (.dmark+2)  
064b 32 6a fe			ld (debug_mark+2),a  
064e 18 03			jr .pastdmark  
0650 ..			.dmark: db "LBL"  
0653 f1			.pastdmark: pop af  
0654			endm  
# End of macro DMARK
0654					CALLMONITOR 
0654 cd 6c fe			call debug_vector  
0657				endm  
# End of macro CALLMONITOR
0657				endif 
0657			 
0657 e5				push hl 
0658			 
0658 cd 17 05			call storage_get_block_0 
065b			 
065b				; set default label 
065b			 
065b e1				pop hl 
065c			 
065c 11 7a fa		 	ld de, store_page+3 
065f 01 0f 00			ld bc, 15 
0662				if DEBUG_STORESE 
0662					DMARK "LB3" 
0662 f5				push af  
0663 3a 77 06			ld a, (.dmark)  
0666 32 68 fe			ld (debug_mark),a  
0669 3a 78 06			ld a, (.dmark+1)  
066c 32 69 fe			ld (debug_mark+1),a  
066f 3a 79 06			ld a, (.dmark+2)  
0672 32 6a fe			ld (debug_mark+2),a  
0675 18 03			jr .pastdmark  
0677 ..			.dmark: db "LB3"  
067a f1			.pastdmark: pop af  
067b			endm  
# End of macro DMARK
067b					CALLMONITOR 
067b cd 6c fe			call debug_vector  
067e				endm  
# End of macro CALLMONITOR
067e				endif 
067e ed b0			ldir 
0680				; save default page 0 
0680			 
0680 21 00 00			ld hl, 0 
0683 11 77 fa			ld de, store_page 
0686				if DEBUG_STORESE 
0686					DMARK "LBW" 
0686 f5				push af  
0687 3a 9b 06			ld a, (.dmark)  
068a 32 68 fe			ld (debug_mark),a  
068d 3a 9c 06			ld a, (.dmark+1)  
0690 32 69 fe			ld (debug_mark+1),a  
0693 3a 9d 06			ld a, (.dmark+2)  
0696 32 6a fe			ld (debug_mark+2),a  
0699 18 03			jr .pastdmark  
069b ..			.dmark: db "LBW"  
069e f1			.pastdmark: pop af  
069f			endm  
# End of macro DMARK
069f					CALLMONITOR 
069f cd 6c fe			call debug_vector  
06a2				endm  
# End of macro CALLMONITOR
06a2				endif 
06a2 cd cb 04			call storage_write_block 
06a5			 
06a5 c9				ret 
06a6			 
06a6			 
06a6			 
06a6			; Read Block 0 - Config 
06a6			; --------------------- 
06a6			; 
06a6			; With current bank 
06a6			; Call presence test 
06a6			;    If not present format/init bank  
06a6			; Read block 0  
06a6			;  
06a6			 
06a6			 
06a6			; Dir 
06a6			; --- 
06a6			; 
06a6			; With current bank 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block read byte 2 
06a6			;      if first block of file 
06a6			;         Display file name 
06a6			;         Display type flags for file 
06a6			;        
06a6			 
06a6			; moving to words as this requires stack control 
06a6			 
06a6			 
06a6			; Delete File 
06a6			; ----------- 
06a6			; 
06a6			; With current bank 
06a6			; 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block file id 
06a6			;      If first block of file and dont have file id 
06a6			;         if file to delete 
06a6			;         Save file id 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			;      If file id is one saved 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			 
06a6			 
06a6			.se_done: 
06a6 e1				pop hl 
06a7 c9				ret 
06a8			 
06a8			storage_erase: 
06a8			 
06a8				; hl contains the file id 
06a8			 
06a8 5d				ld e, l 
06a9 16 00			ld d, 0 
06ab 21 40 00			ld hl, STORE_BLOCK_PHY 
06ae					if DEBUG_FORTH_WORDS 
06ae						DMARK "ERA" 
06ae f5				push af  
06af 3a c3 06			ld a, (.dmark)  
06b2 32 68 fe			ld (debug_mark),a  
06b5 3a c4 06			ld a, (.dmark+1)  
06b8 32 69 fe			ld (debug_mark+1),a  
06bb 3a c5 06			ld a, (.dmark+2)  
06be 32 6a fe			ld (debug_mark+2),a  
06c1 18 03			jr .pastdmark  
06c3 ..			.dmark: db "ERA"  
06c6 f1			.pastdmark: pop af  
06c7			endm  
# End of macro DMARK
06c7						CALLMONITOR 
06c7 cd 6c fe			call debug_vector  
06ca				endm  
# End of macro CALLMONITOR
06ca					endif 
06ca cd 99 07			call storage_findnextid 
06cd cd f9 0f			call ishlzero 
06d0 c8				ret z 
06d1			 
06d1 e5				push hl 
06d2			 
06d2				; TODO check file not found 
06d2			 
06d2 11 77 fa			ld de, store_page 
06d5 cd 66 04			call storage_read_block 
06d8			 
06d8 cd f9 0f			call ishlzero 
06db ca a6 06			jp z,.se_done 
06de			 
06de					if DEBUG_FORTH_WORDS 
06de						DMARK "ER1" 
06de f5				push af  
06df 3a f3 06			ld a, (.dmark)  
06e2 32 68 fe			ld (debug_mark),a  
06e5 3a f4 06			ld a, (.dmark+1)  
06e8 32 69 fe			ld (debug_mark+1),a  
06eb 3a f5 06			ld a, (.dmark+2)  
06ee 32 6a fe			ld (debug_mark+2),a  
06f1 18 03			jr .pastdmark  
06f3 ..			.dmark: db "ER1"  
06f6 f1			.pastdmark: pop af  
06f7			endm  
# End of macro DMARK
06f7						CALLMONITOR 
06f7 cd 6c fe			call debug_vector  
06fa				endm  
# End of macro CALLMONITOR
06fa					endif 
06fa 3a 77 fa			ld a, (store_page)	; get file id 
06fd 32 6b fa			ld (store_tmpid), a 
0700			 
0700 3a 79 fa			ld a, (store_page+2)    ; get count of extends 
0703 32 6a fa			ld (store_tmpext), a 
0706			 
0706				; wipe file header 
0706			 
0706 e1				pop hl 
0707 3e 00			ld a, 0 
0709 32 77 fa			ld (store_page), a 
070c 32 78 fa			ld (store_page+1),a 
070f 11 77 fa			ld de, store_page 
0712					if DEBUG_FORTH_WORDS 
0712						DMARK "ER2" 
0712 f5				push af  
0713 3a 27 07			ld a, (.dmark)  
0716 32 68 fe			ld (debug_mark),a  
0719 3a 28 07			ld a, (.dmark+1)  
071c 32 69 fe			ld (debug_mark+1),a  
071f 3a 29 07			ld a, (.dmark+2)  
0722 32 6a fe			ld (debug_mark+2),a  
0725 18 03			jr .pastdmark  
0727 ..			.dmark: db "ER2"  
072a f1			.pastdmark: pop af  
072b			endm  
# End of macro DMARK
072b						CALLMONITOR 
072b cd 6c fe			call debug_vector  
072e				endm  
# End of macro CALLMONITOR
072e					endif 
072e cd cb 04			call storage_write_block 
0731			 
0731			 
0731				; wipe file extents 
0731			 
0731 3a 6a fa			ld a, (store_tmpext) 
0734 47				ld b, a 
0735			 
0735			.eraext:	  
0735 c5				push bc 
0736			 
0736 21 40 00			ld hl, STORE_BLOCK_PHY 
0739 3a 6b fa			ld a,(store_tmpid) 
073c 5f				ld e, a 
073d 50				ld d, b	 
073e					if DEBUG_FORTH_WORDS 
073e						DMARK "ER3" 
073e f5				push af  
073f 3a 53 07			ld a, (.dmark)  
0742 32 68 fe			ld (debug_mark),a  
0745 3a 54 07			ld a, (.dmark+1)  
0748 32 69 fe			ld (debug_mark+1),a  
074b 3a 55 07			ld a, (.dmark+2)  
074e 32 6a fe			ld (debug_mark+2),a  
0751 18 03			jr .pastdmark  
0753 ..			.dmark: db "ER3"  
0756 f1			.pastdmark: pop af  
0757			endm  
# End of macro DMARK
0757						CALLMONITOR 
0757 cd 6c fe			call debug_vector  
075a				endm  
# End of macro CALLMONITOR
075a					endif 
075a cd 99 07			call storage_findnextid 
075d cd f9 0f			call ishlzero 
0760 ca a6 06			jp z,.se_done 
0763			 
0763 e5				push hl 
0764 11 77 fa			ld de, store_page 
0767 cd 66 04			call storage_read_block 
076a			 
076a				; free block	 
076a			 
076a 3e 00			ld a, 0 
076c 32 77 fa			ld (store_page), a 
076f 32 78 fa			ld (store_page+1),a 
0772 11 77 fa			ld de, store_page 
0775 e1				pop hl 
0776					if DEBUG_FORTH_WORDS 
0776						DMARK "ER4" 
0776 f5				push af  
0777 3a 8b 07			ld a, (.dmark)  
077a 32 68 fe			ld (debug_mark),a  
077d 3a 8c 07			ld a, (.dmark+1)  
0780 32 69 fe			ld (debug_mark+1),a  
0783 3a 8d 07			ld a, (.dmark+2)  
0786 32 6a fe			ld (debug_mark+2),a  
0789 18 03			jr .pastdmark  
078b ..			.dmark: db "ER4"  
078e f1			.pastdmark: pop af  
078f			endm  
# End of macro DMARK
078f						CALLMONITOR 
078f cd 6c fe			call debug_vector  
0792				endm  
# End of macro CALLMONITOR
0792					endif 
0792 cd cb 04			call storage_write_block 
0795			 
0795 c1				pop bc 
0796 10 9d			djnz .eraext 
0798			 
0798 c9				ret 
0799			 
0799			 
0799			; Find Free Block 
0799			; --------------- 
0799			; 
0799			; With current bank 
0799			;  
0799			; From given starting logical block 
0799			;    Read block  
0799			;    If no file id 
0799			;         Return block id 
0799			 
0799			 
0799			; hl starting page number 
0799			; hl contains free page number or zero if no pages free 
0799			; e contains the file id to locate 
0799			; d contains the block number 
0799			 
0799			; TODO change to find file id and use zero for free block 
0799			 
0799			storage_findnextid: 
0799			 
0799				; now locate first 0 page to mark as a free block 
0799			 
0799 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079b			;	ld hl, STORE_BLOCK_PHY 
079b			 
079b					if DEBUG_FORTH_WORDS 
079b					DMARK "FNI" 
079b f5				push af  
079c 3a b0 07			ld a, (.dmark)  
079f 32 68 fe			ld (debug_mark),a  
07a2 3a b1 07			ld a, (.dmark+1)  
07a5 32 69 fe			ld (debug_mark+1),a  
07a8 3a b2 07			ld a, (.dmark+2)  
07ab 32 6a fe			ld (debug_mark+2),a  
07ae 18 03			jr .pastdmark  
07b0 ..			.dmark: db "FNI"  
07b3 f1			.pastdmark: pop af  
07b4			endm  
# End of macro DMARK
07b4						CALLMONITOR 
07b4 cd 6c fe			call debug_vector  
07b7				endm  
# End of macro CALLMONITOR
07b7					endif 
07b7			.ff1:   	 
07b7 e5					push hl 
07b8 c5					push bc 
07b9 d5					push de 
07ba cd 0d 03				call se_readbyte 
07bd 5f					ld e,a 
07be 23					inc hl 
07bf cd 0d 03				call se_readbyte 
07c2 57					ld d, a 
07c3 e1					pop hl 
07c4 e5					push hl 
07c5 cd ee 0f				call cmp16 
07c8 28 49				jr z, .fffound 
07ca			 
07ca d1					pop de 
07cb c1					pop bc 
07cc e1					pop hl 
07cd			 
07cd					; is found? 
07cd					;cp e 
07cd					;ret z 
07cd			 
07cd 3e 40				ld a, STORE_BLOCK_PHY 
07cf cd d0 0f				call addatohl 
07d2 10 e3				djnz .ff1 
07d4			 
07d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d6			.ff2:   	 
07d6			 
07d6 e5					push hl 
07d7 c5					push bc 
07d8 d5					push de 
07d9 cd 0d 03				call se_readbyte 
07dc 5f					ld e,a 
07dd 23					inc hl 
07de cd 0d 03				call se_readbyte 
07e1 57					ld d, a 
07e2			 
07e2 e1					pop hl 
07e3 e5					push hl 
07e4 cd ee 0f				call cmp16 
07e7 28 2a				jr z, .fffound 
07e9			 
07e9 d1					pop de 
07ea c1					pop bc 
07eb e1					pop hl 
07ec					; is found? 
07ec					;cp e 
07ec					;ret z 
07ec			 
07ec 3e 40				ld a, STORE_BLOCK_PHY 
07ee cd d0 0f				call addatohl 
07f1 10 e3				djnz .ff2 
07f3			 
07f3			 
07f3					if DEBUG_FORTH_WORDS 
07f3					DMARK "FN-" 
07f3 f5				push af  
07f4 3a 08 08			ld a, (.dmark)  
07f7 32 68 fe			ld (debug_mark),a  
07fa 3a 09 08			ld a, (.dmark+1)  
07fd 32 69 fe			ld (debug_mark+1),a  
0800 3a 0a 08			ld a, (.dmark+2)  
0803 32 6a fe			ld (debug_mark+2),a  
0806 18 03			jr .pastdmark  
0808 ..			.dmark: db "FN-"  
080b f1			.pastdmark: pop af  
080c			endm  
# End of macro DMARK
080c					;	push af 
080c					;	ld a, 'n' 
080c					;	ld (debug_mark),a 
080c					;	pop af 
080c						CALLMONITOR 
080c cd 6c fe			call debug_vector  
080f				endm  
# End of macro CALLMONITOR
080f					endif 
080f				; no free marks! 
080f 21 00 00				ld hl, 0 
0812 c9				ret 
0813			.fffound: 
0813				 
0813			 
0813 d1					pop de 
0814 c1					pop bc 
0815 e1					pop hl 
0816					if DEBUG_FORTH_WORDS 
0816					DMARK "FNF" 
0816 f5				push af  
0817 3a 2b 08			ld a, (.dmark)  
081a 32 68 fe			ld (debug_mark),a  
081d 3a 2c 08			ld a, (.dmark+1)  
0820 32 69 fe			ld (debug_mark+1),a  
0823 3a 2d 08			ld a, (.dmark+2)  
0826 32 6a fe			ld (debug_mark+2),a  
0829 18 03			jr .pastdmark  
082b ..			.dmark: db "FNF"  
082e f1			.pastdmark: pop af  
082f			endm  
# End of macro DMARK
082f					;	push af 
082f					;	ld a, 'n' 
082f					;	ld (debug_mark),a 
082f					;	pop af 
082f						CALLMONITOR 
082f cd 6c fe			call debug_vector  
0832				endm  
# End of macro CALLMONITOR
0832					endif 
0832 c9				ret 
0833			 
0833			 
0833			 
0833			; Free Space 
0833			; ---------- 
0833			; 
0833			; With current bank 
0833			; 
0833			; Set block count to zero 
0833			; Starting with first logical block 
0833			;      Find free block  
0833			;      If block id given, increment block count 
0833			; 
0833			;  
0833			 
0833			 
0833			; hl contains count of free blocks 
0833			 
0833			storage_freeblocks: 
0833			 
0833				; now locate first 0 page to mark as a free block 
0833			 
0833 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0835 21 40 00			ld hl, STORE_BLOCK_PHY 
0838 11 00 00			ld de, 0 
083b			 
083b			.fb1:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd 0d 03				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844 fe 00				cp 0 
0846 20 01				jr nz, .ff1cont 
0848 13					inc de 
0849			 
0849			.ff1cont: 
0849			 
0849			 
0849 3e 40				ld a, STORE_BLOCK_PHY 
084b cd d0 0f				call addatohl 
084e 10 eb				djnz .fb1 
0850			 
0850 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0852			.fb2:   	 
0852 e5					push hl 
0853 c5					push bc 
0854 d5					push de 
0855 cd 0d 03				call se_readbyte 
0858 d1					pop de 
0859 c1					pop bc 
085a e1					pop hl 
085b			 
085b					; is free? 
085b fe 00				cp 0 
085d 20 01				jr nz, .ff2cont 
085f 13					inc de 
0860			 
0860			.ff2cont: 
0860			 
0860 3e 40				ld a, STORE_BLOCK_PHY 
0862 cd d0 0f				call addatohl 
0865 10 eb				djnz .fb2 
0867			 
0867 eb				ex de, hl 
0868 c9				ret 
0869			 
0869			; Get File ID 
0869			; ----------- 
0869			; 
0869			; With current bank 
0869			;  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; For each logical block 
0869			;    Read block file id 
0869			;      If first block of file and dont have file id 
0869			;         if file get id and exit 
0869			 
0869			 
0869			 
0869			 
0869			; Create File 
0869			; ----------- 
0869			; 
0869			; With current bank  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; Increment file id number 
0869			; Save Config 
0869			; Find free block 
0869			; Set buffer with file name and file id 
0869			; Write buffer to free block  
0869			 
0869			 
0869			; hl point to file name 
0869			; hl returns file id 
0869			 
0869			; file format: 
0869			; byte 0 - file id 
0869			; byte 1 - extent number 
0869			; byte 2-> data 
0869			 
0869			; format for extent number 0: 
0869			; 
0869			; byte 0 - file id 
0869			; byte 1 - extent 0 
0869			; byte 2 - extent count 
0869			; byte 3 -> file name and meta data 
0869			 
0869			 
0869			storage_create: 
0869				if DEBUG_STORESE 
0869					DMARK "SCR" 
0869 f5				push af  
086a 3a 7e 08			ld a, (.dmark)  
086d 32 68 fe			ld (debug_mark),a  
0870 3a 7f 08			ld a, (.dmark+1)  
0873 32 69 fe			ld (debug_mark+1),a  
0876 3a 80 08			ld a, (.dmark+2)  
0879 32 6a fe			ld (debug_mark+2),a  
087c 18 03			jr .pastdmark  
087e ..			.dmark: db "SCR"  
0881 f1			.pastdmark: pop af  
0882			endm  
# End of macro DMARK
0882					CALLMONITOR 
0882 cd 6c fe			call debug_vector  
0885				endm  
# End of macro CALLMONITOR
0885				endif 
0885			 
0885 e5				push hl		; save file name pointer 
0886			 
0886 cd 17 05			call storage_get_block_0 
0889			 
0889 3a 77 fa			ld a,(store_page)	; get current file id 
088c 3c				inc a 
088d 32 77 fa			ld (store_page),a 
0890				 
0890 32 6b fa			ld (store_tmpid),a			; save id 
0893			 
0893 21 00 00			ld hl, 0 
0896 11 77 fa			ld de, store_page 
0899				if DEBUG_STORESE 
0899					DMARK "SCw" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 68 fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 69 fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 6a fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCw"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 6c fe			call debug_vector  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5 cd cb 04			call storage_write_block	 ; save update 
08b8			 
08b8				if DEBUG_STORESE 
08b8 11 77 fa				ld de, store_page 
08bb					DMARK "SCC" 
08bb f5				push af  
08bc 3a d0 08			ld a, (.dmark)  
08bf 32 68 fe			ld (debug_mark),a  
08c2 3a d1 08			ld a, (.dmark+1)  
08c5 32 69 fe			ld (debug_mark+1),a  
08c8 3a d2 08			ld a, (.dmark+2)  
08cb 32 6a fe			ld (debug_mark+2),a  
08ce 18 03			jr .pastdmark  
08d0 ..			.dmark: db "SCC"  
08d3 f1			.pastdmark: pop af  
08d4			endm  
# End of macro DMARK
08d4					CALLMONITOR 
08d4 cd 6c fe			call debug_vector  
08d7				endm  
# End of macro CALLMONITOR
08d7				endif 
08d7				;  
08d7				 
08d7 21 40 00			ld hl, STORE_BLOCK_PHY 
08da 11 00 00			ld de, 0 
08dd cd 99 07			call storage_findnextid 
08e0			 
08e0 22 62 fa			ld (store_tmppageid), hl    ; save page to use  
08e3			 
08e3				; TODO detect 0 = no spare blocks 
08e3			 
08e3				; hl now contains the free page to use for the file header page 
08e3			 
08e3				if DEBUG_STORESE 
08e3				DMARK "SCF" 
08e3 f5				push af  
08e4 3a f8 08			ld a, (.dmark)  
08e7 32 68 fe			ld (debug_mark),a  
08ea 3a f9 08			ld a, (.dmark+1)  
08ed 32 69 fe			ld (debug_mark+1),a  
08f0 3a fa 08			ld a, (.dmark+2)  
08f3 32 6a fe			ld (debug_mark+2),a  
08f6 18 03			jr .pastdmark  
08f8 ..			.dmark: db "SCF"  
08fb f1			.pastdmark: pop af  
08fc			endm  
# End of macro DMARK
08fc					CALLMONITOR 
08fc cd 6c fe			call debug_vector  
08ff				endm  
# End of macro CALLMONITOR
08ff				endif 
08ff			 
08ff 22 62 fa			ld (store_tmppageid), hl 
0902				 
0902 3a 6b fa			ld a,(store_tmpid)    ; get file id 
0905			;	ld a, (store_filecache)			; save to cache 
0905			 
0905 32 77 fa			ld (store_page),a    ; set page id 
0908 3e 00			ld a, 0			 ; extent 0 is file header 
090a 32 78 fa			ld (store_page+1), a   ; set file extent 
090d			 
090d 32 79 fa			ld (store_page+2), a   ; extent count for the file 
0910			 
0910			;	inc hl 		; init block 0 of file 
0910			;	inc hl   		; skip file and extent id 
0910			 ;       ld a, 0 
0910			;	ld (hl),a 
0910			;	ld a, (store_filecache+1)  	; save to cache 
0910			 
0910			;	inc hl    ; file name 
0910				 
0910				 
0910 11 7a fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0913				if DEBUG_STORESE 
0913					DMARK "SCc" 
0913 f5				push af  
0914 3a 28 09			ld a, (.dmark)  
0917 32 68 fe			ld (debug_mark),a  
091a 3a 29 09			ld a, (.dmark+1)  
091d 32 69 fe			ld (debug_mark+1),a  
0920 3a 2a 09			ld a, (.dmark+2)  
0923 32 6a fe			ld (debug_mark+2),a  
0926 18 03			jr .pastdmark  
0928 ..			.dmark: db "SCc"  
092b f1			.pastdmark: pop af  
092c			endm  
# End of macro DMARK
092c					CALLMONITOR 
092c cd 6c fe			call debug_vector  
092f				endm  
# End of macro CALLMONITOR
092f				endif 
092f e1				pop hl    ; get zero term string 
0930 e5				push hl 
0931 3e 00			ld a, 0 
0933 cd 39 14			call strlent 
0936 23				inc hl   ; cover zero term 
0937 06 00			ld b,0 
0939 4d				ld c,l 
093a e1				pop hl 
093b				;ex de, hl 
093b				if DEBUG_STORESE 
093b					DMARK "SCa" 
093b f5				push af  
093c 3a 50 09			ld a, (.dmark)  
093f 32 68 fe			ld (debug_mark),a  
0942 3a 51 09			ld a, (.dmark+1)  
0945 32 69 fe			ld (debug_mark+1),a  
0948 3a 52 09			ld a, (.dmark+2)  
094b 32 6a fe			ld (debug_mark+2),a  
094e 18 03			jr .pastdmark  
0950 ..			.dmark: db "SCa"  
0953 f1			.pastdmark: pop af  
0954			endm  
# End of macro DMARK
0954					;push af 
0954					;ld a, 'a' 
0954					;ld (debug_mark),a 
0954					;pop af 
0954					CALLMONITOR 
0954 cd 6c fe			call debug_vector  
0957				endm  
# End of macro CALLMONITOR
0957				endif 
0957 ed b0			ldir    ; copy zero term string 
0959				if DEBUG_STORESE 
0959					DMARK "SCA" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 68 fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 69 fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 6a fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "SCA"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd 6c fe			call debug_vector  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975			 
0975				; write file header page 
0975			 
0975 2a 62 fa			ld hl,(store_tmppageid) 
0978 11 77 fa			ld de, store_page 
097b				if DEBUG_STORESE 
097b					DMARK "SCb" 
097b f5				push af  
097c 3a 90 09			ld a, (.dmark)  
097f 32 68 fe			ld (debug_mark),a  
0982 3a 91 09			ld a, (.dmark+1)  
0985 32 69 fe			ld (debug_mark+1),a  
0988 3a 92 09			ld a, (.dmark+2)  
098b 32 6a fe			ld (debug_mark+2),a  
098e 18 03			jr .pastdmark  
0990 ..			.dmark: db "SCb"  
0993 f1			.pastdmark: pop af  
0994			endm  
# End of macro DMARK
0994					;push af 
0994					;ld a, 'b' 
0994					;ld (debug_mark),a 
0994					;pop af 
0994					CALLMONITOR 
0994 cd 6c fe			call debug_vector  
0997				endm  
# End of macro CALLMONITOR
0997				endif 
0997 cd cb 04			call storage_write_block 
099a			 
099a 3a 6b fa			ld a, (store_tmpid) 
099d 6f				ld l, a 
099e 26 00			ld h,0 
09a0				if DEBUG_STORESE 
09a0					DMARK "SCz" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 68 fe			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 69 fe			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 6a fe			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "SCz"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6c fe			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc c9				ret 
09bd				 
09bd			 
09bd			 
09bd			; 
09bd			; Read File 
09bd			; 
09bd			; h - file id to locate 
09bd			; l - extent to locate 
09bd			; de - pointer to string to read into 
09bd			; 
09bd			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bd			 
09bd			.sr_fail: 
09bd d1				pop de 
09be c9				ret 
09bf			 
09bf			storage_read: 
09bf			 
09bf			 
09bf d5				push de 
09c0			 
09c0			; TODO BUG the above push is it popped before the RET Z? 
09c0			 
09c0			; TODO how to handle multiple part blocks 
09c0			 
09c0				; locate file extent to read 
09c0			 
09c0 5c				ld e, h 
09c1 55				ld d, l 
09c2			 
09c2			.srext: 
09c2 22 75 fa			ld (store_readptr), hl     ; save the current extent to load 
09c5 ed 53 73 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
09c9			 
09c9 21 40 00			ld hl, STORE_BLOCK_PHY 
09cc				if DEBUG_STORESE 
09cc					DMARK "sre" 
09cc f5				push af  
09cd 3a e1 09			ld a, (.dmark)  
09d0 32 68 fe			ld (debug_mark),a  
09d3 3a e2 09			ld a, (.dmark+1)  
09d6 32 69 fe			ld (debug_mark+1),a  
09d9 3a e3 09			ld a, (.dmark+2)  
09dc 32 6a fe			ld (debug_mark+2),a  
09df 18 03			jr .pastdmark  
09e1 ..			.dmark: db "sre"  
09e4 f1			.pastdmark: pop af  
09e5			endm  
# End of macro DMARK
09e5					CALLMONITOR 
09e5 cd 6c fe			call debug_vector  
09e8				endm  
# End of macro CALLMONITOR
09e8				endif 
09e8 cd 99 07			call storage_findnextid 
09eb			 
09eb				if DEBUG_STORESE 
09eb					DMARK "srf" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 68 fe			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 69 fe			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 6a fe			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "srf"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 6c fe			call debug_vector  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd f9 0f			call ishlzero 
0a0a			;	ld a, l 
0a0a			;	add h 
0a0a			;	cp 0 
0a0a 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0c			 
0a0c				; save current address for use by higher level words etc 
0a0c			 
0a0c 22 68 fa			ld (store_openaddr),hl 
0a0f			 
0a0f			 
0a0f				; hl contains page number to load 
0a0f d1				pop de   ; get storage 
0a10 ed 53 73 fa		ld (store_readbuf), de     ; current buffer to load in to 
0a14 d5				push de 
0a15				if DEBUG_STORESE 
0a15					DMARK "srg" 
0a15 f5				push af  
0a16 3a 2a 0a			ld a, (.dmark)  
0a19 32 68 fe			ld (debug_mark),a  
0a1c 3a 2b 0a			ld a, (.dmark+1)  
0a1f 32 69 fe			ld (debug_mark+1),a  
0a22 3a 2c 0a			ld a, (.dmark+2)  
0a25 32 6a fe			ld (debug_mark+2),a  
0a28 18 03			jr .pastdmark  
0a2a ..			.dmark: db "srg"  
0a2d f1			.pastdmark: pop af  
0a2e			endm  
# End of macro DMARK
0a2e					CALLMONITOR 
0a2e cd 6c fe			call debug_vector  
0a31				endm  
# End of macro CALLMONITOR
0a31				endif 
0a31 cd 66 04			call storage_read_block 
0a34			 
0a34				; if this a continuation read??? 
0a34			 
0a34 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a37			 
0a37 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a39 cd d0 0f			call addatohl 
0a3c 7e				ld a,(hl) 
0a3d fe 00			cp 0 
0a3f 28 02			jr z, .markiscont 
0a41 3e ff			ld a, 255 
0a43			 
0a43			.markiscont: 
0a43 32 6a fa			ld (store_readcont), a 
0a46			 
0a46				if DEBUG_STORESE 
0a46					DMARK "srC" 
0a46 f5				push af  
0a47 3a 5b 0a			ld a, (.dmark)  
0a4a 32 68 fe			ld (debug_mark),a  
0a4d 3a 5c 0a			ld a, (.dmark+1)  
0a50 32 69 fe			ld (debug_mark+1),a  
0a53 3a 5d 0a			ld a, (.dmark+2)  
0a56 32 6a fe			ld (debug_mark+2),a  
0a59 18 03			jr .pastdmark  
0a5b ..			.dmark: db "srC"  
0a5e f1			.pastdmark: pop af  
0a5f			endm  
# End of macro DMARK
0a5f					CALLMONITOR 
0a5f cd 6c fe			call debug_vector  
0a62				endm  
# End of macro CALLMONITOR
0a62				endif 
0a62				; only short reads enabled 
0a62			 
0a62 3a 72 fa			ld a, (store_longread) 
0a65 fe 00			cp 0 
0a67 ca 34 0b			jp z, .readdone 
0a6a			 
0a6a			; TODO if block has no zeros then need to read next block  
0a6a			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a6a			; check last byte of physical block. 
0a6a			; if not zero then the next block needs to be loaded 
0a6a			 
0a6a			 
0a6a 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6d			 
0a6d 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6f cd d0 0f			call addatohl 
0a72				;dec hl 
0a72 7e				ld a,(hl) 
0a73				if DEBUG_STORESE 
0a73					DMARK "sr?" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 68 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 69 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 6a fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sr?"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd 6c fe			call debug_vector  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f fe 00			cp 0 
0a91 ca 34 0b			jp z, .readdone 
0a94			 
0a94				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a94			 
0a94 23				inc hl 
0a95			 
0a95 22 73 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a98			 
0a98 ed 5b 75 fa		ld de, (store_readptr)     ; save the current extent to load 
0a9c			 
0a9c eb				ex de, hl 
0a9d			 
0a9d				; next ext 
0a9d			 
0a9d 23				inc hl 
0a9e 22 75 fa			ld  (store_readptr), hl     ; save the current extent to load 
0aa1			 
0aa1				if DEBUG_STORESE 
0aa1					DMARK "sF2" 
0aa1 f5				push af  
0aa2 3a b6 0a			ld a, (.dmark)  
0aa5 32 68 fe			ld (debug_mark),a  
0aa8 3a b7 0a			ld a, (.dmark+1)  
0aab 32 69 fe			ld (debug_mark+1),a  
0aae 3a b8 0a			ld a, (.dmark+2)  
0ab1 32 6a fe			ld (debug_mark+2),a  
0ab4 18 03			jr .pastdmark  
0ab6 ..			.dmark: db "sF2"  
0ab9 f1			.pastdmark: pop af  
0aba			endm  
# End of macro DMARK
0aba					CALLMONITOR 
0aba cd 6c fe			call debug_vector  
0abd				endm  
# End of macro CALLMONITOR
0abd				endif 
0abd			 
0abd				; get and load block 
0abd			 
0abd cd 99 07			call storage_findnextid 
0ac0			 
0ac0				if DEBUG_STORESE 
0ac0					DMARK "sf2" 
0ac0 f5				push af  
0ac1 3a d5 0a			ld a, (.dmark)  
0ac4 32 68 fe			ld (debug_mark),a  
0ac7 3a d6 0a			ld a, (.dmark+1)  
0aca 32 69 fe			ld (debug_mark+1),a  
0acd 3a d7 0a			ld a, (.dmark+2)  
0ad0 32 6a fe			ld (debug_mark+2),a  
0ad3 18 03			jr .pastdmark  
0ad5 ..			.dmark: db "sf2"  
0ad8 f1			.pastdmark: pop af  
0ad9			endm  
# End of macro DMARK
0ad9					CALLMONITOR 
0ad9 cd 6c fe			call debug_vector  
0adc				endm  
# End of macro CALLMONITOR
0adc				endif 
0adc cd f9 0f			call ishlzero 
0adf			;	ld a, l 
0adf			;	add h 
0adf			;	cp 0 
0adf ca bd 09			jp z,.sr_fail			; block not found so EOF 
0ae2				 
0ae2				; save current address for use by higher level words etc 
0ae2			 
0ae2 22 68 fa			ld (store_openaddr),hl 
0ae5			 
0ae5 cd 66 04			call storage_read_block 
0ae8			 
0ae8				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae8				; we need to pull everything back  
0ae8			 
0ae8 ed 5b 73 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aec 2a 73 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aef 23				inc hl 
0af0 23				inc hl     ; skip id and ext 
0af1 01 40 00			ld bc, STORE_BLOCK_PHY 
0af4				if DEBUG_STORESE 
0af4					DMARK "SR<" 
0af4 f5				push af  
0af5 3a 09 0b			ld a, (.dmark)  
0af8 32 68 fe			ld (debug_mark),a  
0afb 3a 0a 0b			ld a, (.dmark+1)  
0afe 32 69 fe			ld (debug_mark+1),a  
0b01 3a 0b 0b			ld a, (.dmark+2)  
0b04 32 6a fe			ld (debug_mark+2),a  
0b07 18 03			jr .pastdmark  
0b09 ..			.dmark: db "SR<"  
0b0c f1			.pastdmark: pop af  
0b0d			endm  
# End of macro DMARK
0b0d					CALLMONITOR 
0b0d cd 6c fe			call debug_vector  
0b10				endm  
# End of macro CALLMONITOR
0b10				endif 
0b10 ed b0			ldir     ; copy data 
0b12			 
0b12				; move the pointer back and pretend we have a full buffer for next recheck 
0b12			 
0b12 1b				dec de 
0b13 1b				dec de 
0b14			 
0b14			; TODO do pop below now short circuit loop????? 
0b14 c1				pop bc     ; get rid of spare de on stack 
0b15				if DEBUG_STORESE 
0b15					DMARK "SR>" 
0b15 f5				push af  
0b16 3a 2a 0b			ld a, (.dmark)  
0b19 32 68 fe			ld (debug_mark),a  
0b1c 3a 2b 0b			ld a, (.dmark+1)  
0b1f 32 69 fe			ld (debug_mark+1),a  
0b22 3a 2c 0b			ld a, (.dmark+2)  
0b25 32 6a fe			ld (debug_mark+2),a  
0b28 18 03			jr .pastdmark  
0b2a ..			.dmark: db "SR>"  
0b2d f1			.pastdmark: pop af  
0b2e			endm  
# End of macro DMARK
0b2e					CALLMONITOR 
0b2e cd 6c fe			call debug_vector  
0b31				endm  
# End of macro CALLMONITOR
0b31				endif 
0b31 c3 c2 09			jp .srext 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			.readdone:		 
0b34 e1				pop hl 		 ; return start of data to show as not EOF 
0b35 23				inc hl   ; past file id 
0b36 23				inc hl   ; past ext 
0b37				if DEBUG_STORESE 
0b37					DMARK "SRe" 
0b37 f5				push af  
0b38 3a 4c 0b			ld a, (.dmark)  
0b3b 32 68 fe			ld (debug_mark),a  
0b3e 3a 4d 0b			ld a, (.dmark+1)  
0b41 32 69 fe			ld (debug_mark+1),a  
0b44 3a 4e 0b			ld a, (.dmark+2)  
0b47 32 6a fe			ld (debug_mark+2),a  
0b4a 18 03			jr .pastdmark  
0b4c ..			.dmark: db "SRe"  
0b4f f1			.pastdmark: pop af  
0b50			endm  
# End of macro DMARK
0b50					CALLMONITOR 
0b50 cd 6c fe			call debug_vector  
0b53				endm  
# End of macro CALLMONITOR
0b53				endif 
0b53 c9					ret 
0b54			 
0b54			 
0b54			 
0b54			; 
0b54			; Append File 
0b54			; 
0b54			; hl - file id to locate 
0b54			; de - pointer to (multi block) string to write 
0b54			 
0b54			.sa_notfound: 
0b54 d1				pop de 
0b55 c9				ret 
0b56			 
0b56			 
0b56			storage_append: 
0b56				; hl -  file id to append to 
0b56				; de - string to append 
0b56			 
0b56 d5				push de 
0b57				 
0b57				if DEBUG_STORESE 
0b57					DMARK "AP1" 
0b57 f5				push af  
0b58 3a 6c 0b			ld a, (.dmark)  
0b5b 32 68 fe			ld (debug_mark),a  
0b5e 3a 6d 0b			ld a, (.dmark+1)  
0b61 32 69 fe			ld (debug_mark+1),a  
0b64 3a 6e 0b			ld a, (.dmark+2)  
0b67 32 6a fe			ld (debug_mark+2),a  
0b6a 18 03			jr .pastdmark  
0b6c ..			.dmark: db "AP1"  
0b6f f1			.pastdmark: pop af  
0b70			endm  
# End of macro DMARK
0b70					CALLMONITOR 
0b70 cd 6c fe			call debug_vector  
0b73				endm  
# End of macro CALLMONITOR
0b73				endif 
0b73			 
0b73 7d				ld a, l 
0b74 32 6b fa			ld (store_tmpid), a 
0b77			 
0b77				; get file header  
0b77			 
0b77 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b79 3a 6b fa			ld a, (store_tmpid) 
0b7c 5f				ld e, a 
0b7d			 
0b7d 21 40 00				ld hl, STORE_BLOCK_PHY 
0b80 cd 99 07				call storage_findnextid 
0b83			 
0b83 cd f9 0f			call ishlzero 
0b86 28 cc			jr z, .sa_notfound 
0b88			 
0b88 22 62 fa			ld (store_tmppageid), hl 
0b8b			 
0b8b				; TODO handle file id not found 
0b8b			 
0b8b				if DEBUG_STORESE 
0b8b					DMARK "AP2" 
0b8b f5				push af  
0b8c 3a a0 0b			ld a, (.dmark)  
0b8f 32 68 fe			ld (debug_mark),a  
0b92 3a a1 0b			ld a, (.dmark+1)  
0b95 32 69 fe			ld (debug_mark+1),a  
0b98 3a a2 0b			ld a, (.dmark+2)  
0b9b 32 6a fe			ld (debug_mark+2),a  
0b9e 18 03			jr .pastdmark  
0ba0 ..			.dmark: db "AP2"  
0ba3 f1			.pastdmark: pop af  
0ba4			endm  
# End of macro DMARK
0ba4					CALLMONITOR 
0ba4 cd 6c fe			call debug_vector  
0ba7				endm  
# End of macro CALLMONITOR
0ba7				endif 
0ba7			 
0ba7				; update file extent count 
0ba7			 
0ba7 11 77 fa			ld de, store_page 
0baa			 
0baa cd 66 04			call storage_read_block 
0bad			 
0bad				if DEBUG_STORESE 
0bad					DMARK "AP3" 
0bad f5				push af  
0bae 3a c2 0b			ld a, (.dmark)  
0bb1 32 68 fe			ld (debug_mark),a  
0bb4 3a c3 0b			ld a, (.dmark+1)  
0bb7 32 69 fe			ld (debug_mark+1),a  
0bba 3a c4 0b			ld a, (.dmark+2)  
0bbd 32 6a fe			ld (debug_mark+2),a  
0bc0 18 03			jr .pastdmark  
0bc2 ..			.dmark: db "AP3"  
0bc5 f1			.pastdmark: pop af  
0bc6			endm  
# End of macro DMARK
0bc6					CALLMONITOR 
0bc6 cd 6c fe			call debug_vector  
0bc9				endm  
# End of macro CALLMONITOR
0bc9				endif 
0bc9			;	ld (store_tmppageid), hl 
0bc9			 
0bc9 3a 79 fa			ld a, (store_page+2) 
0bcc 3c				inc a 
0bcd 32 79 fa			ld (store_page+2), a 
0bd0 32 6a fa			ld (store_tmpext), a 
0bd3				 
0bd3				if DEBUG_STORESE 
0bd3					DMARK "AP3" 
0bd3 f5				push af  
0bd4 3a e8 0b			ld a, (.dmark)  
0bd7 32 68 fe			ld (debug_mark),a  
0bda 3a e9 0b			ld a, (.dmark+1)  
0bdd 32 69 fe			ld (debug_mark+1),a  
0be0 3a ea 0b			ld a, (.dmark+2)  
0be3 32 6a fe			ld (debug_mark+2),a  
0be6 18 03			jr .pastdmark  
0be8 ..			.dmark: db "AP3"  
0beb f1			.pastdmark: pop af  
0bec			endm  
# End of macro DMARK
0bec					CALLMONITOR 
0bec cd 6c fe			call debug_vector  
0bef				endm  
# End of macro CALLMONITOR
0bef				endif 
0bef 2a 62 fa			ld hl, (store_tmppageid) 
0bf2 11 77 fa			ld de, store_page 
0bf5 cd cb 04			call storage_write_block 
0bf8			 
0bf8				; find free block 
0bf8			 
0bf8 11 00 00			ld de, 0			 ; file extent to locate 
0bfb			 
0bfb 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfe cd 99 07				call storage_findnextid 
0c01 cd f9 0f			call ishlzero 
0c04 ca 54 0b			jp z, .sa_notfound 
0c07			 
0c07					; TODO handle no space left 
0c07					 
0c07 22 62 fa				ld (store_tmppageid), hl 
0c0a			 
0c0a				if DEBUG_STORESE 
0c0a					DMARK "AP4" 
0c0a f5				push af  
0c0b 3a 1f 0c			ld a, (.dmark)  
0c0e 32 68 fe			ld (debug_mark),a  
0c11 3a 20 0c			ld a, (.dmark+1)  
0c14 32 69 fe			ld (debug_mark+1),a  
0c17 3a 21 0c			ld a, (.dmark+2)  
0c1a 32 6a fe			ld (debug_mark+2),a  
0c1d 18 03			jr .pastdmark  
0c1f ..			.dmark: db "AP4"  
0c22 f1			.pastdmark: pop af  
0c23			endm  
# End of macro DMARK
0c23					CALLMONITOR 
0c23 cd 6c fe			call debug_vector  
0c26				endm  
# End of macro CALLMONITOR
0c26				endif 
0c26					; init the buffer with zeros so we can id if the buffer is full or not 
0c26			 
0c26 e5					push hl 
0c27 c5					push bc 
0c28			 
0c28 21 77 fa				ld hl, store_page 
0c2b 06 40				ld b, STORE_BLOCK_PHY 
0c2d 3e 00				ld a, 0 
0c2f 77			.zeroblock:	ld (hl), a 
0c30 23					inc hl 
0c31 10 fc				djnz .zeroblock 
0c33			 
0c33 c1					pop bc 
0c34 e1					pop hl 
0c35			 
0c35					; construct block 
0c35			 
0c35 3a 6b fa				ld a, (store_tmpid) 
0c38 32 77 fa				ld (store_page), a   ; file id 
0c3b 3a 6a fa				ld a, (store_tmpext)   ; extent for this block 
0c3e 32 78 fa				ld (store_page+1), a 
0c41			 
0c41 e1					pop hl    ; get string to write 
0c42 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c44 11 79 fa				ld de, store_page+2 
0c47			 
0c47				if DEBUG_STORESE 
0c47					DMARK "AP5" 
0c47 f5				push af  
0c48 3a 5c 0c			ld a, (.dmark)  
0c4b 32 68 fe			ld (debug_mark),a  
0c4e 3a 5d 0c			ld a, (.dmark+1)  
0c51 32 69 fe			ld (debug_mark+1),a  
0c54 3a 5e 0c			ld a, (.dmark+2)  
0c57 32 6a fe			ld (debug_mark+2),a  
0c5a 18 03			jr .pastdmark  
0c5c ..			.dmark: db "AP5"  
0c5f f1			.pastdmark: pop af  
0c60			endm  
# End of macro DMARK
0c60					CALLMONITOR 
0c60 cd 6c fe			call debug_vector  
0c63				endm  
# End of macro CALLMONITOR
0c63				endif 
0c63			 
0c63			 
0c63			 
0c63					; fill buffer with data until end of string or full block 
0c63			 
0c63 7e			.appd:		ld a, (hl) 
0c64 12					ld (de), a 
0c65 fe 00				cp 0 
0c67 28 04				jr z, .appdone 
0c69 23					inc hl 
0c6a 13					inc de 
0c6b 10 f6				djnz .appd 
0c6d			 
0c6d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6e f5					push af   		; save last byte dumped 
0c6f			 
0c6f			 
0c6f 2a 62 fa			ld hl, (store_tmppageid) 
0c72 11 77 fa			ld de, store_page 
0c75				if DEBUG_STORESE 
0c75					DMARK "AP6" 
0c75 f5				push af  
0c76 3a 8a 0c			ld a, (.dmark)  
0c79 32 68 fe			ld (debug_mark),a  
0c7c 3a 8b 0c			ld a, (.dmark+1)  
0c7f 32 69 fe			ld (debug_mark+1),a  
0c82 3a 8c 0c			ld a, (.dmark+2)  
0c85 32 6a fe			ld (debug_mark+2),a  
0c88 18 03			jr .pastdmark  
0c8a ..			.dmark: db "AP6"  
0c8d f1			.pastdmark: pop af  
0c8e			endm  
# End of macro DMARK
0c8e					CALLMONITOR 
0c8e cd 6c fe			call debug_vector  
0c91				endm  
# End of macro CALLMONITOR
0c91				endif 
0c91 cd cb 04				call storage_write_block 
0c94			 
0c94			 
0c94				; was that a full block of data written? 
0c94				; any more to write out? 
0c94			 
0c94				; if yes then set vars and jump to start of function again 
0c94			 
0c94 f1					pop af 
0c95 d1					pop de 
0c96			 
0c96 fe 00				cp 0		 ; no, string was fully written 
0c98 c8					ret z 
0c99			 
0c99					; setup vars for next cycle 
0c99			 
0c99 3a 6b fa				ld a, (store_tmpid) 
0c9c 6f					ld l, a 
0c9d 26 00				ld h, 0 
0c9f			 
0c9f c3 56 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			if DEBUG_STORECF 
0ca2			storageput:	 
0ca2					ret 
0ca2			storageread: 
0ca2					ld hl, store_page 
0ca2					ld b, 200 
0ca2					ld a,0 
0ca2			.src:		ld (hl),a 
0ca2					inc hl 
0ca2					djnz .src 
0ca2					 
0ca2			 
0ca2					ld de, 0 
0ca2					ld bc, 1 
0ca2					ld hl, store_page 
0ca2					call cfRead 
0ca2			 
0ca2				call cfGetError 
0ca2				ld hl,scratch 
0ca2				call hexout 
0ca2				ld hl, scratch+2 
0ca2				ld a, 0 
0ca2				ld (hl),a 
0ca2				ld de, scratch 
0ca2				ld a,display_row_1 
0ca2				call str_at_display 
0ca2				call update_display 
0ca2			 
0ca2					ld hl, store_page 
0ca2					ld (os_cur_ptr),hl 
0ca2			 
0ca2					ret 
0ca2			endif 
0ca2			 
0ca2			 
0ca2			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca2			 
0ca2			storage_clear_page: 
0ca2 e5				push hl 
0ca3 d5				push de 
0ca4 c5				push bc 
0ca5 21 77 fa			ld hl, store_page 
0ca8 3e 00			ld a, 0 
0caa 77				ld (hl), a 
0cab			 
0cab 11 78 fa			ld de, store_page+1 
0cae 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb1			 
0cb1 ed b0			ldir 
0cb3				 
0cb3 c1				pop bc 
0cb4 d1				pop de 
0cb5 e1				pop hl 
0cb6 c9				ret 
0cb7			 
0cb7			; eof 
# End of file firmware_storage.asm
0cb7			  
0cb7			; support routines for above hardware abstraction layer  
0cb7			  
0cb7			include "firmware_general.asm"        ; general support functions  
0cb7			 
0cb7			; word look up 
0cb7			 
0cb7			; in 
0cb7			; a is the index 
0cb7			; hl is pointer start of array 
0cb7			; 
0cb7			; returns 
0cb7			; hl to the word 
0cb7			; 
0cb7			 
0cb7			table_lookup:  
0cb7 d5					push de 
0cb8 eb					ex de, hl 
0cb9			 
0cb9 6f					ld l, a 
0cba 26 00				ld h, 0 
0cbc 29					add hl, hl 
0cbd 19					add hl, de 
0cbe 7e					ld a, (hl) 
0cbf 23					inc hl 
0cc0 66					ld h,(hl) 
0cc1 6f					ld l, a 
0cc2			 
0cc2 d1					pop de 
0cc3 c9					ret 
0cc4			 
0cc4			; Delay loops 
0cc4			 
0cc4			 
0cc4			 
0cc4			aDelayInMS: 
0cc4 c5				push bc 
0cc5 47				ld b,a 
0cc6			msdelay: 
0cc6 c5				push bc 
0cc7				 
0cc7			 
0cc7 01 41 00			ld bc,041h 
0cca cd e2 0c			call delayloop 
0ccd c1				pop bc 
0cce 05				dec b 
0ccf 20 f5			jr nz,msdelay 
0cd1			 
0cd1			;if CPU_CLOCK_8MHZ 
0cd1			;msdelay8: 
0cd1			;	push bc 
0cd1			;	 
0cd1			; 
0cd1			;	ld bc,041h 
0cd1			;	call delayloop 
0cd1			;	pop bc 
0cd1			;	dec b 
0cd1			;	jr nz,msdelay8 
0cd1			;endif 
0cd1			 
0cd1			 
0cd1 c1				pop bc 
0cd2 c9				ret 
0cd3			 
0cd3			 
0cd3			delay250ms: 
0cd3				;push de 
0cd3 01 00 40			ld bc, 04000h 
0cd6 c3 e2 0c			jp delayloop 
0cd9			delay500ms: 
0cd9				;push de 
0cd9 01 00 80			ld bc, 08000h 
0cdc c3 e2 0c			jp delayloop 
0cdf			delay1s: 
0cdf				;push bc 
0cdf			   ; Clobbers A, d and e 
0cdf 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce2			delayloop: 
0ce2 c5			    push bc 
0ce3			 
0ce3			if BASE_CPM 
0ce3				ld bc, CPM_DELAY_TUNE 
0ce3			.cpmloop: 
0ce3				push bc 
0ce3			 
0ce3			endif 
0ce3			 
0ce3			 
0ce3			 
0ce3			delayloopi: 
0ce3			;	push bc 
0ce3			;.dl: 
0ce3 cb 47		    bit     0,a    	; 8 
0ce5 cb 47		    bit     0,a    	; 8 
0ce7 cb 47		    bit     0,a    	; 8 
0ce9 e6 ff		    and     255  	; 7 
0ceb 0b			    dec     bc      	; 6 
0cec 79			    ld      a,c     	; 4 
0ced b0			    or      b     	; 4 
0cee c2 e3 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf1			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf1				;pop de 
0cf1			;pop bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				pop bc 
0cf1				 
0cf1			    dec     bc      	; 6 
0cf1			    ld      a,c     	; 4 
0cf1			    or      b     	; 4 
0cf1			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf1				 
0cf1			 
0cf1			endif 
0cf1			;if CPU_CLOCK_8MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1			 
0cf1			;if CPU_CLOCK_10MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1 c1			    pop bc 
0cf2			 
0cf2 c9				ret 
0cf3			 
0cf3			 
0cf3			 
0cf3			; eof 
# End of file firmware_general.asm
0cf3			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf3			; display routines that use the physical hardware abstraction layer 
0cf3			 
0cf3			 
0cf3			; Display an activity indicator 
0cf3			; Each call returns the new char pointed to in hl 
0cf3			 
0cf3			active: 
0cf3 3a c3 fb			ld a, (display_active) 
0cf6 fe 06			cp 6 
0cf8			 
0cf8 20 02			jr nz, .sne 
0cfa				; gone past the last one reset sequence 
0cfa 3e ff			ld a, 255 
0cfc			 
0cfc			.sne:   
0cfc				; get the next char in seq 
0cfc 3c				inc a 
0cfd 32 c3 fb			ld (display_active), a 
0d00			 
0d00				; look up the string in the table 
0d00 21 17 0d			ld hl, actseq 
0d03 cb 27			sla a 
0d05 cd d0 0f			call addatohl 
0d08 cd 42 24			call loadwordinhl 
0d0b			 
0d0b				; forth will write the to string when pushing so move from rom to ram 
0d0b			 
0d0b 11 c4 fb			ld de, display_active+1 
0d0e 01 02 00			ld bc, 2 
0d11 ed b0			ldir 
0d13			 
0d13 21 c4 fb			ld hl, display_active+1 
0d16 c9				ret 
0d17				 
0d17				 
0d17			 
0d17			 
0d17			;db "|/-\|-\" 
0d17			 
0d17			actseq: 
0d17			 
0d17 25 0d		dw spin0 
0d19 27 0d		dw spin1 
0d1b 29 0d		dw spin2 
0d1d 2b 0d		dw spin3 
0d1f 29 0d		dw spin2 
0d21 27 0d		dw spin1 
0d23 25 0d		dw spin0 
0d25			 
0d25 .. 00		spin0: db " ", 0 
0d27 .. 00		spin1: db "-", 0 
0d29 .. 00		spin2: db "+", 0 
0d2b .. 00		spin3: db "#", 0 
0d2d			 
0d2d			 
0d2d			; information window 
0d2d			 
0d2d			; pass hl with 1st string to display 
0d2d			; pass de with 2nd string to display 
0d2d			 
0d2d			info_panel: 
0d2d e5				push hl 
0d2e			 
0d2e 2a c9 fb			ld hl, (display_fb_active) 
0d31 e5				push hl    ; future de destination 
0d32 21 ae fd				ld hl, display_fb0 
0d35 22 c9 fb				ld (display_fb_active), hl 
0d38			 
0d38			;	call clear_display 
0d38			 
0d38				if BASE_CPM 
0d38				ld a, '.' 
0d38				else 
0d38 3e a5			ld a, 165 
0d3a				endif 
0d3a cd a1 0d			call fill_display 
0d3d			 
0d3d			 
0d3d 3e 55			ld a, display_row_3 + 5 
0d3f cd af 0d			call str_at_display 
0d42			 
0d42 e1				pop hl 
0d43 d1				pop de 
0d44			 
0d44 e5				push hl 
0d45			 
0d45			 
0d45 3e 2d			ld a, display_row_2 + 5 
0d47 cd af 0d			call str_at_display 
0d4a			 
0d4a			 
0d4a cd bf 0d			call update_display 
0d4d cd 8b 20			call next_page_prompt 
0d50 cd 9c 0d			call clear_display 
0d53			 
0d53				 
0d53 21 0d fd				ld hl, display_fb1 
0d56 22 c9 fb				ld (display_fb_active), hl 
0d59 cd bf 0d			call update_display 
0d5c			 
0d5c e1				pop hl 
0d5d			 
0d5d c9				ret 
0d5e			 
0d5e			 
0d5e			 
0d5e			 
0d5e			; TODO windowing? 
0d5e			 
0d5e			; TODO scroll line up 
0d5e			 
0d5e			scroll_up: 
0d5e			 
0d5e e5				push hl 
0d5f d5				push de 
0d60 c5				push bc 
0d61			 
0d61				; get frame buffer  
0d61			 
0d61 2a c9 fb			ld hl, (display_fb_active) 
0d64 e5				push hl    ; future de destination 
0d65			 
0d65 11 28 00			ld  de, display_cols 
0d68 19				add hl, de 
0d69			 
0d69 d1				pop de 
0d6a			 
0d6a				;ex de, hl 
0d6a 01 9f 00			ld bc, display_fb_len -1  
0d6d			;if DEBUG_FORTH_WORDS 
0d6d			;	DMARK "SCL" 
0d6d			;	CALLMONITOR 
0d6d			;endif	 
0d6d ed b0			ldir 
0d6f			 
0d6f				; wipe bottom row 
0d6f			 
0d6f			 
0d6f 2a c9 fb			ld hl, (display_fb_active) 
0d72 11 a0 00			ld de, display_cols*display_rows 
0d75 19				add hl, de 
0d76 06 28			ld b, display_cols 
0d78 3e 20			ld a, ' ' 
0d7a			.scwipe: 
0d7a 77				ld (hl), a 
0d7b 2b				dec hl 
0d7c 10 fc			djnz .scwipe 
0d7e			 
0d7e				;pop hl 
0d7e			 
0d7e c1				pop bc 
0d7f d1				pop de 
0d80 e1				pop hl 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			;scroll_upo: 
0d82			;	ld de, display_row_1 
0d82			 ;	ld hl, display_row_2 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_2 
0d82			 ;	ld hl, display_row_3 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_3 
0d82			 ;	ld hl, display_row_4 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			 
0d82			; TODO clear row 4 
0d82			 
0d82			;	ret 
0d82			 
0d82				 
0d82			scroll_down: 
0d82			 
0d82 e5				push hl 
0d83 d5				push de 
0d84 c5				push bc 
0d85			 
0d85				; get frame buffer  
0d85			 
0d85 2a c9 fb			ld hl, (display_fb_active) 
0d88			 
0d88 11 9f 00			ld de, display_fb_len - 1 
0d8b 19				add hl, de 
0d8c			 
0d8c e5			push hl    ; future de destination 
0d8d			 
0d8d 11 28 00			ld  de, display_cols 
0d90 ed 52			sbc hl, de 
0d92			 
0d92			 
0d92 d1				pop de 
0d93			 
0d93			;	ex de, hl 
0d93 01 9f 00			ld bc, display_fb_len -1  
0d96			 
0d96			 
0d96				 
0d96			 
0d96 ed b0			ldir 
0d98			 
0d98				; wipe bottom row 
0d98			 
0d98			 
0d98			;	ld hl, (display_fb_active) 
0d98			;;	ld de, display_cols*display_rows 
0d98			;;	add hl, de 
0d98			;	ld b, display_cols 
0d98			;	ld a, ' ' 
0d98			;.scwiped: 
0d98			;	ld (hl), a 
0d98			;	dec hl 
0d98			;	djnz .scwiped 
0d98			 
0d98				;pop hl 
0d98			 
0d98 c1				pop bc 
0d99 d1				pop de 
0d9a e1				pop hl 
0d9b			 
0d9b c9				ret 
0d9c			;scroll_down: 
0d9c			;	ld de, display_row_4 
0d9c			;	ld hl, display_row_3 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_3 
0d9c			; 	ld hl, display_row_2 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_2 
0d9c			;	ld hl, display_row_1 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;;; TODO clear row 1 
0d9c			;	ret 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			; clear active frame buffer 
0d9c			 
0d9c			clear_display: 
0d9c 3e 20			ld a, ' ' 
0d9e c3 a1 0d			jp fill_display 
0da1			 
0da1			; fill active frame buffer with a char in A 
0da1			 
0da1			fill_display: 
0da1 06 a0			ld b,display_fb_len 
0da3 2a c9 fb			ld hl, (display_fb_active) 
0da6 77			.fd1:	ld (hl),a 
0da7 23				inc hl 
0da8 10 fc			djnz .fd1 
0daa 23				inc hl 
0dab 3e 00			ld a,0 
0dad 77				ld (hl),a 
0dae			 
0dae			 
0dae c9				ret 
0daf			; Write string (DE) at pos (A) to active frame buffer 
0daf			 
0daf 2a c9 fb		str_at_display:    ld hl,(display_fb_active) 
0db2 06 00					ld b,0 
0db4 4f					ld c,a 
0db5 09					add hl,bc 
0db6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db7 b7			            OR   A              ;Null terminator? 
0db8 c8			            RET  Z              ;Yes, so finished 
0db9 77					ld (hl),a 
0dba 23				inc hl 
0dbb 13			            INC  DE             ;Point to next character 
0dbc 18 f8		            JR   .sad1     ;Repeat 
0dbe c9					ret 
0dbf			 
0dbf			; using current frame buffer write to physical display 
0dbf			 
0dbf			update_display: 
0dbf e5				push hl 
0dc0 2a c9 fb			ld hl, (display_fb_active) 
0dc3 cd 37 76			call write_display 
0dc6 e1				pop hl 
0dc7 c9				ret 
0dc8			 
0dc8			; TODO scrolling 
0dc8			 
0dc8			 
0dc8			; move cursor right one char 
0dc8			cursor_right: 
0dc8			 
0dc8				; TODO shift right 
0dc8				; TODO if beyond max col 
0dc8				; TODO       cursor_next_line 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			 
0dc9			cursor_next_line: 
0dc9				; TODO first char 
0dc9				; TODO line down 
0dc9				; TODO if past last row 
0dc9				; TODO    scroll up 
0dc9			 
0dc9 c9				ret 
0dca			 
0dca			cursor_left: 
0dca				; TODO shift left 
0dca				; TODO if beyond left  
0dca				; TODO     cursor prev line 
0dca				 
0dca c9				ret 
0dcb			 
0dcb			cursor_prev_line: 
0dcb				; TODO last char 
0dcb				; TODO line up 
0dcb				; TODO if past first row 
0dcb				; TODO   scroll down 
0dcb			 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			cout: 
0dcc				; A - char 
0dcc c9				ret 
0dcd			 
0dcd			 
0dcd			; Display a menu and allow item selection (optional toggle items) 
0dcd			; 
0dcd			; format: 
0dcd			; hl pointer to word array with zero term for items 
0dcd			; e.g.    db item1 
0dcd			;         db .... 
0dcd			;         db 0 
0dcd			; 
0dcd			; a = starting menu item  
0dcd			; 
0dcd			; de = pointer item toggle array   (todo) 
0dcd			; 
0dcd			; returns item selected in a 1-... 
0dcd			; returns 0 if back button pressed 
0dcd			; 
0dcd			; NOTE: Uses system frame buffer to display 
0dcd			; 
0dcd			; LEFT, Q = go back 
0dcd			; RIGHT, SPACE, CR = select 
0dcd			; UP, A - Up 
0dcd			; DOWN, Z - Down 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			menu: 
0dcd			 
0dcd					; keep array pointer 
0dcd			 
0dcd 22 70 fa				ld (store_tmp1), hl 
0dd0 32 6e fa				ld (store_tmp2), a 
0dd3			 
0dd3					; check for key bounce 
0dd3			 
0dd3			if BASE_KEV 
0dd3			 
0dd3 cd 82 79		.mbounce:	call cin 
0dd6 fe 00				cp 0 
0dd8 20 f9				jr nz, .mbounce 
0dda			endif 
0dda					; for ease use ex 
0dda			 
0dda					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dda 21 ae fd				ld hl, display_fb0 
0ddd 22 c9 fb				ld (display_fb_active), hl 
0de0			 
0de0 cd 9c 0d		.mloop:		call clear_display 
0de3 cd bf 0d				call update_display 
0de6			 
0de6					; draw selection id '>' at 1 
0de6			 
0de6					; init start of list display 
0de6			 
0de6 3e 05				ld a, 5 
0de8 32 6c fa				ld (store_tmp3), a   ; display row count 
0deb 3a 6e fa				ld a,( store_tmp2) 
0dee 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0df1			 
0df1					 
0df1			.mitem:	 
0df1			 
0df1			 
0df1 3a 6f fa				ld a,(store_tmp2+1) 
0df4 6f					ld l, a 
0df5 26 00				ld h, 0 
0df7 29					add hl, hl 
0df8 ed 5b 70 fa			ld de, (store_tmp1) 
0dfc 19					add hl, de 
0dfd 7e					ld a, (hl) 
0dfe 23					inc hl 
0dff 66					ld h,(hl) 
0e00 6f					ld l, a 
0e01			 
0e01 cd f9 0f				call ishlzero 
0e04 28 1a				jr z, .mdone 
0e06			 
0e06 eb					ex de, hl 
0e07 3a 6c fa				ld a, (store_tmp3) 
0e0a cd af 0d				call str_at_display 
0e0d					 
0e0d			 
0e0d					; next item 
0e0d 3a 6f fa				ld a, (store_tmp2+1) 
0e10 3c					inc a 
0e11 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0e14			 
0e14			 		; next row 
0e14			 
0e14 3a 6c fa				ld a, (store_tmp3) 
0e17 c6 28				add display_cols 
0e19 32 6c fa				ld (store_tmp3), a 
0e1c			 
0e1c					; at end of screen? 
0e1c			 
0e1c fe 10				cp display_rows*4 
0e1e 20 d1				jr nz, .mitem 
0e20			 
0e20			 
0e20			.mdone: 
0e20 cd f9 0f				call ishlzero 
0e23 28 08				jr z, .nodn 
0e25			 
0e25 3e 78				ld a, display_row_4 
0e27 11 a6 0e				ld de, .mdown 
0e2a cd af 0d				call str_at_display 
0e2d			 
0e2d					; draw options to fill the screens with active item on line 1 
0e2d					; if current option is 2 or more then display ^ in top 
0e2d			 
0e2d 3a 6e fa		.nodn:		ld a, (store_tmp2) 
0e30 fe 00				cp 0 
0e32 28 08				jr z, .noup 
0e34			 
0e34 3e 00				ld a, 0 
0e36 11 a4 0e				ld de, .mup 
0e39 cd af 0d				call str_at_display 
0e3c			 
0e3c 3e 02		.noup:		ld a, 2 
0e3e 11 a2 0e				ld de, .msel 
0e41 cd af 0d				call str_at_display 
0e44			 
0e44					; if current option + 1 is not null then display V in bottom 
0e44					; get key 
0e44 cd bf 0d				call update_display 
0e47			 
0e47			 
0e47					; handle key 
0e47			 
0e47 cd 71 79				call cin_wait 
0e4a			 
0e4a fe 05				cp KEY_UP 
0e4c 28 2b				jr z, .mgoup 
0e4e fe 61				cp 'a' 
0e50 28 27				jr z, .mgoup 
0e52 fe 0a				cp KEY_DOWN 
0e54 28 32				jr z, .mgod 
0e56 fe 7a				cp 'z' 
0e58 28 2e				jr z, .mgod 
0e5a fe 20				cp ' ' 
0e5c 28 34				jr z, .goend 
0e5e fe 0c				cp KEY_RIGHT 
0e60 28 30				jr z, .goend 
0e62 fe 0d				cp KEY_CR 
0e64 28 2c				jr z, .goend 
0e66 fe 71				cp 'q' 
0e68 28 0b				jr z, .goback 
0e6a			 
0e6a fe 0b				cp KEY_LEFT 
0e6c 28 07				jr z, .goback 
0e6e fe 08				cp KEY_BS 
0e70 28 03				jr z, .goback 
0e72 c3 e0 0d				jp .mloop 
0e75			 
0e75			.goback: 
0e75 3e 00			ld a, 0 
0e77 18 1d			jr .goend2 
0e79			 
0e79				; move up one 
0e79			.mgoup: 
0e79 3a 6e fa				ld a, (store_tmp2) 
0e7c fe 00				cp 0 
0e7e ca e0 0d				jp z, .mloop 
0e81 3d					dec a 
0e82 32 6e fa				ld (store_tmp2), a 
0e85 c3 e0 0d				jp .mloop 
0e88			 
0e88				; move down one 
0e88			.mgod: 
0e88 3a 6e fa				ld a, (store_tmp2) 
0e8b 3c					inc a 
0e8c 32 6e fa				ld (store_tmp2), a 
0e8f c3 e0 0d				jp .mloop 
0e92			 
0e92			 
0e92			.goend: 
0e92					; get selected item number 
0e92			 
0e92 3a 6e fa				ld a, (store_tmp2) 
0e95 3c					inc a 
0e96			 
0e96			.goend2: 
0e96 f5					push af 
0e97			 
0e97					; restore active fb 
0e97					; TODO BUG assumes fb1 
0e97			 
0e97 21 0d fd				ld hl, display_fb1 
0e9a 22 c9 fb				ld (display_fb_active), hl 
0e9d			 
0e9d					; restore main regs 
0e9d			 
0e9d			 
0e9d cd bf 0d				call update_display 
0ea0			 
0ea0 f1					pop af 
0ea1			 
0ea1 c9				ret 
0ea2			 
0ea2 .. 00		.msel:   db ">",0 
0ea4 .. 00		.mup:   db "^",0 
0ea6 .. 00		.mdown:   db "v",0 
0ea8			 
0ea8			 
0ea8			; eof 
0ea8			 
# End of file firmware_display.asm
0ea8			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea8			; random number generators 
0ea8			 
0ea8			 
0ea8			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea8			 
0ea8			 
0ea8			;-----> Generate a random number 
0ea8			; output a=answer 0<=a<=255 
0ea8			; all registers are preserved except: af 
0ea8			random: 
0ea8 e5			        push    hl 
0ea9 d5			        push    de 
0eaa 2a a8 fb		        ld      hl,(randData) 
0ead ed 5f		        ld      a,r 
0eaf 57			        ld      d,a 
0eb0 5e			        ld      e,(hl) 
0eb1 19			        add     hl,de 
0eb2 85			        add     a,l 
0eb3 ac			        xor     h 
0eb4 22 a8 fb		        ld      (randData),hl 
0eb7 d1			        pop     de 
0eb8 e1			        pop     hl 
0eb9 c9			        ret 
0eba			 
0eba			 
0eba			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eba			 
0eba			 
0eba			 
0eba			;------LFSR------ 
0eba			;James Montelongo 
0eba			;optimized by Spencer Putt 
0eba			;out: 
0eba			; a = 8 bit random number 
0eba			RandLFSR: 
0eba 21 ae fb		        ld hl,LFSRSeed+4 
0ebd 5e			        ld e,(hl) 
0ebe 23			        inc hl 
0ebf 56			        ld d,(hl) 
0ec0 23			        inc hl 
0ec1 4e			        ld c,(hl) 
0ec2 23			        inc hl 
0ec3 7e			        ld a,(hl) 
0ec4 47			        ld b,a 
0ec5 cb 13		        rl e  
0ec7 cb 12			rl d 
0ec9 cb 11		        rl c  
0ecb 17				rla 
0ecc cb 13		        rl e  
0ece cb 12			rl d 
0ed0 cb 11		        rl c  
0ed2 17				rla 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda 67			        ld h,a 
0edb cb 13		        rl e  
0edd cb 12			rl d 
0edf cb 11		        rl c  
0ee1 17				rla 
0ee2 a8			        xor b 
0ee3 cb 13		        rl e  
0ee5 cb 12			rl d 
0ee7 ac			        xor h 
0ee8 a9			        xor c 
0ee9 aa			        xor d 
0eea 21 b0 fb		        ld hl,LFSRSeed+6 
0eed 11 b1 fb		        ld de,LFSRSeed+7 
0ef0 01 07 00		        ld bc,7 
0ef3 ed b8		        lddr 
0ef5 12			        ld (de),a 
0ef6 c9			        ret 
0ef7			 
0ef7			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef7			 
0ef7			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef7			 
0ef7			 
0ef7			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef7			 
0ef7			prng16: 
0ef7			;Inputs: 
0ef7			;   (seed1) contains a 16-bit seed value 
0ef7			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef7			;Outputs: 
0ef7			;   HL is the result 
0ef7			;   BC is the result of the LCG, so not that great of quality 
0ef7			;   DE is preserved 
0ef7			;Destroys: 
0ef7			;   AF 
0ef7			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef7			;160cc 
0ef7			;26 bytes 
0ef7 2a a2 fb		    ld hl,(seed1) 
0efa 44			    ld b,h 
0efb 4d			    ld c,l 
0efc 29			    add hl,hl 
0efd 29			    add hl,hl 
0efe 2c			    inc l 
0eff 09			    add hl,bc 
0f00 22 a2 fb		    ld (seed1),hl 
0f03 2a a0 fb		    ld hl,(seed2) 
0f06 29			    add hl,hl 
0f07 9f			    sbc a,a 
0f08 e6 2d		    and %00101101 
0f0a ad			    xor l 
0f0b 6f			    ld l,a 
0f0c 22 a0 fb		    ld (seed2),hl 
0f0f 09			    add hl,bc 
0f10 c9			    ret 
0f11			 
0f11			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f11			 
0f11			rand32: 
0f11			;Inputs: 
0f11			;   (seed1_0) holds the lower 16 bits of the first seed 
0f11			;   (seed1_1) holds the upper 16 bits of the first seed 
0f11			;   (seed2_0) holds the lower 16 bits of the second seed 
0f11			;   (seed2_1) holds the upper 16 bits of the second seed 
0f11			;   **NOTE: seed2 must be non-zero 
0f11			;Outputs: 
0f11			;   HL is the result 
0f11			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f11			;Destroys: 
0f11			;   AF 
0f11			;Tested and passes all CAcert tests 
0f11			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f11			;it has a period of 18,446,744,069,414,584,320 
0f11			;roughly 18.4 quintillion. 
0f11			;LFSR taps: 0,2,6,7  = 11000101 
0f11			;291cc 
0f11			;seed1_0=$+1 
0f11			;    ld hl,12345 
0f11			;seed1_1=$+1 
0f11			;    ld de,6789 
0f11			;    ld b,h 
0f11			;    ld c,l 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    inc l 
0f11			;    add hl,bc 
0f11			;    ld (seed1_0),hl 
0f11			;    ld hl,(seed1_1) 
0f11			;    adc hl,de 
0f11			;    ld (seed1_1),hl 
0f11			;    ex de,hl 
0f11			;seed2_0=$+1 
0f11			;    ld hl,9876 
0f11			;seed2_1=$+1 
0f11			;    ld bc,54321 
0f11			;    add hl,hl \ rl c \ rl b 
0f11			;    ld (seed2_1),bc 
0f11			;    sbc a,a 
0f11			;    and %11000101 
0f11			;    xor l 
0f11			;    ld l,a 
0f11			;    ld (seed2_0),hl 
0f11			;    ex de,hl 
0f11			;    add hl,bc 
0f11			;    ret 
0f11			; 
0f11			 
0f11			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f11			; 20 bytes, 86 cycles (excluding ret) 
0f11			 
0f11			; returns   hl = pseudorandom number 
0f11			; corrupts   a 
0f11			 
0f11			; generates 16-bit pseudorandom numbers with a period of 65535 
0f11			; using the xorshift method: 
0f11			 
0f11			; hl ^= hl << 7 
0f11			; hl ^= hl >> 9 
0f11			; hl ^= hl << 8 
0f11			 
0f11			; some alternative shift triplets which also perform well are: 
0f11			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f11			 
0f11			;  org 32768 
0f11			 
0f11			xrnd: 
0f11 2a a6 fb		  ld hl,(xrandc)       ; seed must not be 0 
0f14 3e 00		  ld a,0 
0f16 bd			  cp l 
0f17 20 02		  jr nz, .xrnd1 
0f19 2e 01		  ld l, 1 
0f1b			.xrnd1: 
0f1b			 
0f1b 7c			  ld a,h 
0f1c 1f			  rra 
0f1d 7d			  ld a,l 
0f1e 1f			  rra 
0f1f ac			  xor h 
0f20 67			  ld h,a 
0f21 7d			  ld a,l 
0f22 1f			  rra 
0f23 7c			  ld a,h 
0f24 1f			  rra 
0f25 ad			  xor l 
0f26 6f			  ld l,a 
0f27 ac			  xor h 
0f28 67			  ld h,a 
0f29			 
0f29 22 a6 fb		  ld (xrandc),hl 
0f2c			 
0f2c c9			  ret 
0f2d			;  
0f2d			 
0f2d			 
0f2d			;;;; int maths 
0f2d			 
0f2d			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2d			; Divide 16-bit values (with 16-bit result) 
0f2d			; In: Divide BC by divider DE 
0f2d			; Out: BC = result, HL = rest 
0f2d			; 
0f2d			Div16: 
0f2d 21 00 00		    ld hl,0 
0f30 78			    ld a,b 
0f31 06 08		    ld b,8 
0f33			Div16_Loop1: 
0f33 17			    rla 
0f34 ed 6a		    adc hl,hl 
0f36 ed 52		    sbc hl,de 
0f38 30 01		    jr nc,Div16_NoAdd1 
0f3a 19			    add hl,de 
0f3b			Div16_NoAdd1: 
0f3b 10 f6		    djnz Div16_Loop1 
0f3d 17			    rla 
0f3e 2f			    cpl 
0f3f 47			    ld b,a 
0f40 79			    ld a,c 
0f41 48			    ld c,b 
0f42 06 08		    ld b,8 
0f44			Div16_Loop2: 
0f44 17			    rla 
0f45 ed 6a		    adc hl,hl 
0f47 ed 52		    sbc hl,de 
0f49 30 01		    jr nc,Div16_NoAdd2 
0f4b 19			    add hl,de 
0f4c			Div16_NoAdd2: 
0f4c 10 f6		    djnz Div16_Loop2 
0f4e 17			    rla 
0f4f 2f			    cpl 
0f50 41			    ld b,c 
0f51 4f			    ld c,a 
0f52 c9			ret 
0f53			 
0f53			 
0f53			;http://z80-heaven.wikidot.com/math 
0f53			; 
0f53			;Inputs: 
0f53			;     DE and A are factors 
0f53			;Outputs: 
0f53			;     A is not changed 
0f53			;     B is 0 
0f53			;     C is not changed 
0f53			;     DE is not changed 
0f53			;     HL is the product 
0f53			;Time: 
0f53			;     342+6x 
0f53			; 
0f53			Mult16: 
0f53			 
0f53 06 08		     ld b,8          ;7           7 
0f55 21 00 00		     ld hl,0         ;10         10 
0f58 29			       add hl,hl     ;11*8       88 
0f59 07			       rlca          ;4*8        32 
0f5a 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5c 19			         add hl,de   ;--         -- 
0f5d 10 f9		       djnz $-5      ;13*7+8     99 
0f5f c9			ret 
0f60			 
0f60			; 
0f60			; Square root of 16-bit value 
0f60			; In:  HL = value 
0f60			; Out:  D = result (rounded down) 
0f60			; 
0f60			;Sqr16: 
0f60			;    ld de,#0040 
0f60			;    ld a,l 
0f60			;    ld l,h 
0f60			;    ld h,d 
0f60			;    or a 
0f60			;    ld b,8 
0f60			;Sqr16_Loop: 
0f60			;    sbc hl,de 
0f60			;    jr nc,Sqr16_Skip 
0f60			;    add hl,de 
0f60			;Sqr16_Skip: 
0f60			;    ccf 
0f60			;    rl d 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    djnz Sqr16_Loop 
0f60			;    ret 
0f60			; 
0f60			; 
0f60			; Divide 8-bit values 
0f60			; In: Divide E by divider C 
0f60			; Out: A = result, B = rest 
0f60			; 
0f60			Div8: 
0f60 af			    xor a 
0f61 06 08		    ld b,8 
0f63			Div8_Loop: 
0f63 cb 13		    rl e 
0f65 17			    rla 
0f66 91			    sub c 
0f67 30 01		    jr nc,Div8_NoAdd 
0f69 81			    add a,c 
0f6a			Div8_NoAdd: 
0f6a 10 f7		    djnz Div8_Loop 
0f6c 47			    ld b,a 
0f6d 7b			    ld a,e 
0f6e 17			    rla 
0f6f 2f			    cpl 
0f70 c9			    ret 
0f71			 
0f71			; 
0f71			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f71			; In: Multiply A with DE 
0f71			; Out: HL = result 
0f71			; 
0f71			Mult12U: 
0f71 2e 00		    ld l,0 
0f73 87			    add a,a 
0f74 30 01		    jr nc,Mult12U_NoAdd0 
0f76 19			    add hl,de 
0f77			Mult12U_NoAdd0: 
0f77 29			    add hl,hl 
0f78 87			    add a,a 
0f79 30 01		    jr nc,Mult12U_NoAdd1 
0f7b 19			    add hl,de 
0f7c			Mult12U_NoAdd1: 
0f7c 29			    add hl,hl 
0f7d 87			    add a,a 
0f7e 30 01		    jr nc,Mult12U_NoAdd2 
0f80 19			    add hl,de 
0f81			Mult12U_NoAdd2: 
0f81 29			    add hl,hl 
0f82 87			    add a,a 
0f83 30 01		    jr nc,Mult12U_NoAdd3 
0f85 19			    add hl,de 
0f86			Mult12U_NoAdd3: 
0f86 29			    add hl,hl 
0f87 87			    add a,a 
0f88 30 01		    jr nc,Mult12U_NoAdd4 
0f8a 19			    add hl,de 
0f8b			Mult12U_NoAdd4: 
0f8b 29			    add hl,hl 
0f8c 87			    add a,a 
0f8d 30 01		    jr nc,Mult12U_NoAdd5 
0f8f 19			    add hl,de 
0f90			Mult12U_NoAdd5: 
0f90 29			    add hl,hl 
0f91 87			    add a,a 
0f92 30 01		    jr nc,Mult12U_NoAdd6 
0f94 19			    add hl,de 
0f95			Mult12U_NoAdd6: 
0f95 29			    add hl,hl 
0f96 87			    add a,a 
0f97 d0			    ret nc 
0f98 19			    add hl,de 
0f99 c9			    ret 
0f9a			 
0f9a			; 
0f9a			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f9a			; In: Multiply A with DE 
0f9a			;      Put lowest value in A for most efficient calculation 
0f9a			; Out: HL = result 
0f9a			; 
0f9a			Mult12R: 
0f9a 21 00 00		    ld hl,0 
0f9d			Mult12R_Loop: 
0f9d cb 3f		    srl a 
0f9f 30 01		    jr nc,Mult12R_NoAdd 
0fa1 19			    add hl,de 
0fa2			Mult12R_NoAdd: 
0fa2 cb 23		    sla e 
0fa4 cb 12		    rl d 
0fa6 b7			    or a 
0fa7 c2 9d 0f		    jp nz,Mult12R_Loop 
0faa c9			    ret 
0fab			 
0fab			; 
0fab			; Multiply 16-bit values (with 32-bit result) 
0fab			; In: Multiply BC with DE 
0fab			; Out: BCHL = result 
0fab			; 
0fab			Mult32: 
0fab 79			    ld a,c 
0fac 48			    ld c,b 
0fad 21 00 00		    ld hl,0 
0fb0 06 10		    ld b,16 
0fb2			Mult32_Loop: 
0fb2 29			    add hl,hl 
0fb3 17			    rla 
0fb4 cb 11		    rl c 
0fb6 30 07		    jr nc,Mult32_NoAdd 
0fb8 19			    add hl,de 
0fb9 ce 00		    adc a,0 
0fbb d2 bf 0f		    jp nc,Mult32_NoAdd 
0fbe 0c			    inc c 
0fbf			Mult32_NoAdd: 
0fbf 10 f1		    djnz Mult32_Loop 
0fc1 41			    ld b,c 
0fc2 4f			    ld c,a 
0fc3 c9			    ret 
0fc4			 
0fc4			 
0fc4			 
0fc4			; 
0fc4			; Multiply 8-bit values 
0fc4			; In:  Multiply H with E 
0fc4			; Out: HL = result 
0fc4			; 
0fc4			Mult8: 
0fc4 16 00		    ld d,0 
0fc6 6a			    ld l,d 
0fc7 06 08		    ld b,8 
0fc9			Mult8_Loop: 
0fc9 29			    add hl,hl 
0fca 30 01		    jr nc,Mult8_NoAdd 
0fcc 19			    add hl,de 
0fcd			Mult8_NoAdd: 
0fcd 10 fa		    djnz Mult8_Loop 
0fcf c9			    ret 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			;;http://z80-heaven.wikidot.com/math 
0fd0			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fd0			; 
0fd0			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fd0			;     ld a,16        ;7 
0fd0			;     ld hl,0        ;10 
0fd0			;     jp $+5         ;10 
0fd0			;.DivLoop: 
0fd0			;       add hl,bc    ;-- 
0fd0			;       dec a        ;64 
0fd0			;       jr z,.DivLoopEnd        ;86 
0fd0			; 
0fd0			;       sla e        ;128 
0fd0			;       rl d         ;128 
0fd0			;       adc hl,hl    ;240 
0fd0			;       sbc hl,bc    ;240 
0fd0			;       jr nc,.DivLoop ;23|21 
0fd0			;       inc e        ;-- 
0fd0			;       jp .DivLoop+1 
0fd0			; 
0fd0			;.DivLoopEnd: 
0fd0			 
0fd0			;HL_Div_C: 
0fd0			;Inputs: 
0fd0			;     HL is the numerator 
0fd0			;     C is the denominator 
0fd0			;Outputs: 
0fd0			;     A is the remainder 
0fd0			;     B is 0 
0fd0			;     C is not changed 
0fd0			;     DE is not changed 
0fd0			;     HL is the quotient 
0fd0			; 
0fd0			;       ld b,16 
0fd0			;       xor a 
0fd0			;         add hl,hl 
0fd0			;         rla 
0fd0			;         cp c 
0fd0			;         jr c,$+4 
0fd0			;           inc l 
0fd0			;           sub c 
0fd0			;         djnz $-7 
0fd0			 
0fd0			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fd0			 
0fd0			addatohl: 
0fd0 85			    add   a, l    ; A = A+L 
0fd1 6f			    ld    l, a    ; L = A+L 
0fd2 8c			    adc   a, h    ; A = A+L+H+carry 
0fd3 95			    sub   l       ; A = H+carry 
0fd4 67			    ld    h, a    ; H = H+carry 
0fd5 c9			ret 
0fd6			 
0fd6			addatode: 
0fd6 83			    add   a, e    ; A = A+L 
0fd7 5f			    ld    e, a    ; L = A+L 
0fd8 8a			    adc   a, d    ; A = A+L+H+carry 
0fd9 93			    sub   e       ; A = H+carry 
0fda 57			    ld    d, a    ; H = H+carry 
0fdb c9			ret 
0fdc			 
0fdc			 
0fdc			addatobc: 
0fdc 81			    add   a, c    ; A = A+L 
0fdd 4f			    ld    c, a    ; L = A+L 
0fde 88			    adc   a, b    ; A = A+L+H+carry 
0fdf 91			    sub   c       ; A = H+carry 
0fe0 47			    ld    b, a    ; H = H+carry 
0fe1 c9			ret 
0fe2			 
0fe2			subafromhl: 
0fe2			   ; If A=0 do nothing 
0fe2			    ; Otherwise flip A's sign. Since 
0fe2			    ; the upper byte becomes -1, also 
0fe2			    ; substract 1 from H. 
0fe2 ed 44		    neg 
0fe4 ca ed 0f		    jp    z, Skip 
0fe7 25			    dec   h 
0fe8			     
0fe8			    ; Now add the low byte as usual 
0fe8			    ; Two's complement takes care of 
0fe8			    ; ensuring the result is correct 
0fe8 85			    add   a, l 
0fe9 6f			    ld    l, a 
0fea 8c			    adc   a, h 
0feb 95			    sub   l 
0fec 67			    ld    h, a 
0fed			Skip: 
0fed c9				ret 
0fee			 
0fee			 
0fee			; compare hl and de 
0fee			; returns:  
0fee			; if hl = de, z=1, s=0, c0=0 
0fee			; if hl > de, z=0, s=0, c=0 
0fee			; if hl < de, z=0, s=1, c=1 
0fee			cmp16:	 
0fee b7				or a 
0fef ed 52			sbc hl,de 
0ff1 e0				ret po 
0ff2 7c				ld a,h 
0ff3 1f				rra 
0ff4 ee 40			xor 01000000B 
0ff6 37				scf 
0ff7 8f				adc a,a 
0ff8 c9				ret 
0ff9			 
0ff9			 
0ff9			; test if hl contains zero   - A is destroyed 
0ff9			 
0ff9			ishlzero:    
0ff9 b7				or a     ; reset flags 
0ffa 7c				ld a, h 
0ffb b5				or l        	 
0ffc			 
0ffc c9				ret 
0ffd			 
0ffd			 
0ffd			 
0ffd			 
0ffd			if FORTH_ENABLE_FLOATMATH 
0ffd			;include "float/bbcmath.z80" 
0ffd			include "float/lpfpcalc.asm" 
0ffd			endif 
0ffd			 
0ffd			 
0ffd			; eof 
0ffd			 
# End of file firmware_maths.asm
0ffd			include "firmware_strings.asm"   ; string handling  
0ffd			 
0ffd			 
0ffd			; TODO string len 
0ffd			; input text string, end on cr with zero term 
0ffd			; a offset into frame buffer to start prompt 
0ffd			; d is max length 
0ffd			; e is display size TODO 
0ffd			; c is current cursor position 
0ffd			; hl is ptr to where string will be stored 
0ffd			 
0ffd			 
0ffd			; TODO check limit of buffer for new inserts 
0ffd			; TODO check insert does not push beyond buffer 
0ffd			; TODO scroll in a limited display area 
0ffd			; TODO scroll whole screen on page wrap 
0ffd			 
0ffd			 
0ffd			; TODO handle KEY_PREVWORD 
0ffd			; TODO handle KEY_NEXTWORD 
0ffd			; TODO handle KEY_HOME 
0ffd			; TODO handle KEY_END 
0ffd			; TODO use LCD cursor? 
0ffd			 
0ffd 32 61 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
1000 81					add c 
1001 32 5f fe				ld (input_at_cursor),a	; save draw pos of cursor 
1004 22 64 fe				ld (input_start), hl     ; save ptr to buffer 
1007 79					ld a, c 
1008 cd d0 0f				call addatohl 
100b 22 66 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
100e 7a					ld a,d 
100f 32 63 fe			        ld (input_size), a       ; save length of input area 
1012 79					ld a, c 
1013 32 52 fe				ld (input_cursor),a      ; init cursor start position  
1016 7b					ld a,e 
1017 32 62 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101a					 
101a					 
101a			 
101a			;		ld a,(input_ptr) 
101a			;		ld (input_under_cursor),a 	; save what is under the cursor 
101a			 
101a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101a					; init cursor shape if not set by the cin routines 
101a 21 be fb				ld hl, cursor_shape 
101d 3e ff				ld a, 255 
101f 77					ld (hl), a 
1020 23					inc hl 
1021 3e 00				ld a, 0 
1023 77					ld (hl), a 
1024			 
1024 3e 0f				ld a, CUR_BLINK_RATE 
1026 32 5d fe				ld (input_cur_flash), a 
1029 3e 01				ld a, 1 
102b 32 5c fe				ld (input_cur_onoff),a 
102e			 
102e			;	if DEBUG_INPUT 
102e			;		push af 
102e			;		ld a, 'I' 
102e			;		ld (debug_mark),a 
102e			;		pop af 
102e			;		CALLMONITOR 
102e			;	endif 
102e			.is1:		; main entry loop 
102e			 
102e			 
102e			 
102e					; pause 1ms 
102e			 
102e 3e 01				ld a, 1 
1030 cd c4 0c				call aDelayInMS 
1033			 
1033					; dec flash counter 
1033 3a 5d fe				ld a, (input_cur_flash) 
1036 3d					dec a 
1037 32 5d fe				ld (input_cur_flash), a 
103a fe 00				cp 0 
103c 20 0d				jr nz, .nochgstate 
103e			 
103e			 
103e					; change state 
103e 3a 5c fe				ld a,(input_cur_onoff) 
1041 ed 44				neg 
1043 32 5c fe				ld (input_cur_onoff),a 
1046			 
1046			 
1046					; reset on change of state 
1046 3e 0f				ld a, CUR_BLINK_RATE 
1048 32 5d fe				ld (input_cur_flash), a 
104b			 
104b			.nochgstate: 
104b					 
104b					 
104b			 
104b					; display cursor  
104b			 
104b			;		ld hl, (input_start) 
104b			;		ld a, (input_cursor) 
104b			;		call addatohl 
104b			 
104b					; get char under cursor and replace with cursor 
104b 2a 66 fe		ld hl, (input_ptr) 
104e			;		ld a, (hl) 
104e			;		ld (input_under_cursor),a 
104e			;		ld a, '_' 
104e			;		ld (hl), a 
104e			 
104e					; display string 
104e			 
104e ed 5b 64 fe			ld de, (input_start) 
1052 3a 61 fe				ld a, (input_at_pos) 
1055 cd af 0d				call str_at_display 
1058			;	        call update_display 
1058			 
1058					; find place to put the cursor 
1058			;		add h 
1058			;		ld l, display_row_1 
1058			;		sub l 
1058			; (input_at_pos) 
1058					;ld c, a 
1058			;		ld a, (input_cursor) 
1058			;		ld l, (input_at_pos) 
1058			;		;ld b, h 
1058			;		add l 
1058			;		ld (input_at_cursor),a 
1058					;ld l,h 
1058			 
1058			;		ld h, 0 
1058			;		ld l,(input_at_pos) 
1058			;		ld a, (input_cursor) 
1058			;		call addatohl 
1058			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1058			;		call subafromhl 
1058			;		ld a,l 
1058			;		ld (input_at_cursor), a 
1058			 
1058				if DEBUG_INPUT 
1058					ld a, (hardware_diag) 
1058					cp 0 
1058					jr z, .skip_input_diag 
1058			 
1058					ld a,(input_at_pos) 
1058					ld hl, LFSRSeed 
1058					call hexout 
1058					ld a, (input_cursor) 
1058					ld hl, LFSRSeed+2 
1058					call hexout 
1058					ld a,(input_at_cursor) 
1058					ld hl, LFSRSeed+4 
1058					call hexout 
1058			 
1058					ld a,(input_cur_onoff) 
1058					ld hl, LFSRSeed+6 
1058					call hexout 
1058			 
1058					ld a,(input_cur_flash) 
1058					ld hl, LFSRSeed+8 
1058					call hexout 
1058			 
1058					ld a,(input_len) 
1058					ld hl, LFSRSeed+10 
1058					call hexout 
1058					ld hl, LFSRSeed+12 
1058					ld a, 0 
1058					ld (hl),a 
1058					ld a, display_row_4 
1058					ld de, LFSRSeed 
1058					call str_at_display 
1058					.skip_input_diag: 
1058				endif 
1058			 
1058					; decide on if we are showing the cursor this time round 
1058			 
1058 3a 5c fe				ld a, (input_cur_onoff) 
105b fe ff				cp 255 
105d 28 13				jr z, .skipcur 
105f			 
105f			 
105f 3a 5f fe				ld a,(input_at_cursor) 
1062 11 be fb				ld de, cursor_shape 
1065 cd af 0d				call str_at_display 
1068			 
1068					; save length of current input string 
1068 2a 64 fe				ld hl, (input_start) 
106b cd 2e 14				call strlenz 
106e 7d					ld a,l 
106f 32 57 fe				ld (input_len),a 
1072			 
1072			.skipcur: 
1072			 
1072 cd bf 0d			        call update_display 
1075					 
1075			 
1075			 
1075					; wait 
1075				 
1075					; TODO loop without wait to flash the cursor and char under cursor	 
1075 cd 82 79				call cin    ; _wait 
1078			 
1078 fe 00				cp 0 
107a ca 2e 10				jp z, .is1 
107d			 
107d					; get ptr to char to input into 
107d			 
107d 4f					ld c,a 
107e 2a 64 fe				ld hl, (input_start) 
1081 3a 52 fe				ld a, (input_cursor) 
1084 cd d0 0f				call addatohl 
1087 22 66 fe				ld (input_ptr), hl 
108a 79					ld a,c 
108b			 
108b					; replace char under cursor 
108b			 
108b			;		ld hl, (input_ptr) 
108b			;		ld a, (input_under_cursor) 	; get what is under the cursor 
108b			;		ld (hl), a 
108b			 
108b			;	if DEBUG_INPUT 
108b			;		push af 
108b			;		ld a, 'i' 
108b			;		ld (debug_mark),a 
108b			;		pop af 
108b			;		CALLMONITOR 
108b			;	endif 
108b fe 0e				cp KEY_HOME 
108d 20 0e				jr nz, .iske 
108f			 
108f 3a 61 fe				ld a, (input_at_pos) 
1092 32 5f fe				ld (input_at_cursor),a 
1095 3e 00				ld a, 0 
1097 32 52 fe				ld (input_cursor), a 
109a c3 2e 10				jp .is1 
109d					 
109d fe 0f		.iske:		cp KEY_END 
109f 20 03				jr nz, .isknw 
10a1 c3 2e 10				jp .is1 
10a4			 
10a4 fe 06		.isknw:		cp KEY_NEXTWORD 
10a6 20 1b				jr nz, .iskpw 
10a8			 
10a8 2a 66 fe		.isknwm:	ld hl, (input_ptr) 
10ab 7e					ld a,(hl)	 
10ac fe 00				cp 0 
10ae ca 2e 10				jp z, .is1    ; end of string 
10b1 fe 20				cp ' ' 
10b3 ca 2e 10				jp z, .is1    ; end of word 
10b6 23					inc hl 
10b7 22 66 fe				ld (input_ptr), hl 
10ba 3a 5f fe				ld a, (input_at_cursor) 
10bd 3c					inc a 
10be 32 5f fe				ld (input_at_cursor), a 
10c1 18 e5				jr .isknwm 
10c3			 
10c3 fe 07		.iskpw:		cp KEY_PREVWORD 
10c5 20 1b				jr nz, .iskl 
10c7			.iskpwm:	 
10c7 2a 66 fe				ld hl, (input_ptr) 
10ca 7e					ld a,(hl)	 
10cb fe 00				cp 0  
10cd ca 2e 10				jp z, .is1    ; end of string 
10d0 fe 20				cp ' ' 
10d2 ca 2e 10				jp z, .is1    ; end of word 
10d5 2b					dec hl 
10d6 22 66 fe				ld (input_ptr), hl 
10d9 3a 5f fe				ld a, (input_at_cursor) 
10dc 3d					dec a 
10dd 32 5f fe				ld (input_at_cursor), a 
10e0 18 e5				jr .iskpwm 
10e2			 
10e2			 
10e2 fe 0b		.iskl:		cp KEY_LEFT 
10e4 20 27				jr nz, .isk1 
10e6			 
10e6 3a 52 fe				ld a, (input_cursor) 
10e9			 
10e9 fe 00				cp 0 
10eb ca 2e 10				jp z, .is1 		; at start of line to ignore  
10ee			 
10ee 3d					dec  a 		; TODO check underflow 
10ef 32 52 fe				ld (input_cursor), a 
10f2			 
10f2 2a 66 fe				ld hl, (input_ptr) 
10f5 2b					dec hl 
10f6 22 66 fe				ld (input_ptr), hl 
10f9					 
10f9 3a 5f fe				ld a, (input_at_cursor) 
10fc 3d					dec a 
10fd 32 5f fe				ld (input_at_cursor), a 
1100			 
1100 3e 01				ld a, 1		; show cursor moving 
1102 32 5c fe				ld (input_cur_onoff),a 
1105 3e 0f				ld a, CUR_BLINK_RATE 
1107 32 5d fe				ld (input_cur_flash), a 
110a			 
110a c3 2e 10				jp .is1 
110d			 
110d fe 0c		.isk1:		cp KEY_RIGHT 
110f 20 2a				jr nz, .isk2 
1111			 
1111 3a 57 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1114 5f					ld e,a 
1115 3a 52 fe				ld a, (input_cursor) 
1118 bb					cp e 
1119 ca 2e 10				jp z, .is1		; at the end of string so dont go right 
111c			 
111c 3c					inc  a 		; TODO check overflow 
111d 32 52 fe				ld (input_cursor), a 
1120			 
1120 3a 5f fe				ld a, (input_at_cursor) 
1123 3c					inc a 
1124 32 5f fe				ld (input_at_cursor), a 
1127			 
1127 2a 66 fe				ld hl, (input_ptr) 
112a 23					inc hl 
112b 22 66 fe				ld (input_ptr), hl 
112e			 
112e 3e 01				ld a, 1		; show cursor moving 
1130 32 5c fe				ld (input_cur_onoff),a 
1133 3e 0f				ld a, CUR_BLINK_RATE 
1135 32 5d fe				ld (input_cur_flash), a 
1138			 
1138 c3 2e 10				jp .is1 
113b			 
113b fe 05		.isk2:		cp KEY_UP 
113d			 
113d 20 26				jr nz, .isk3 
113f			 
113f					; swap last command with the current on 
113f			 
113f					; move cursor to start of string 
113f 2a 64 fe				ld hl, (input_start) 
1142 22 66 fe				ld (input_ptr), hl 
1145			 
1145 3a 61 fe				ld a, (input_at_pos) 
1148 32 5f fe				ld (input_at_cursor), a 
114b			 
114b 3e 00				ld a, 0 
114d 32 52 fe				ld (input_cursor), a 
1150					 
1150					; swap input and last command buffers 
1150			 
1150 21 e5 f4				ld hl, os_cli_cmd 
1153 11 e4 f5				ld de, os_last_cmd 
1156 06 ff				ld b, 255 
1158 7e			.swap1:		ld a, (hl) 
1159 4f					ld c,a 
115a 1a					ld a, (de) 
115b 77					ld (hl), a 
115c 79					ld a,c 
115d 12					ld (de),a 
115e 23					inc hl 
115f 13					inc de 
1160 10 f6				djnz .swap1 
1162			 
1162			 
1162			 
1162			 
1162			 
1162 c3 2e 10				jp .is1 
1165			 
1165 fe 08		.isk3:		cp KEY_BS 
1167 20 3c				jr nz, .isk4 
1169			 
1169 3a 52 fe				ld a, (input_cursor) 
116c			 
116c fe 00				cp 0 
116e ca 2e 10				jp z, .is1 		; at start of line to ignore  
1171			 
1171 3d					dec  a 		; TODO check underflow 
1172 32 52 fe				ld (input_cursor), a 
1175			 
1175					; hl is source 
1175					; de needs to be source - 1 
1175			 
1175			;		ld a, 0 
1175			;		dec hl 
1175			;		ld (hl), a 
1175			 
1175 2a 66 fe				ld hl, (input_ptr) 
1178 2b					dec hl 
1179 22 66 fe				ld (input_ptr), hl 
117c			 
117c					; shift all data 
117c			 
117c e5					push hl 
117d 23					inc hl 
117e d1					pop de 
117f 3a 57 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1182 4f					ld c,a 
1183 06 00				ld b,0 
1185 ed b0				ldir  
1187			 
1187			 
1187			 
1187			 
1187 3a 5f fe				ld a, (input_at_cursor) 
118a 3d					dec a 
118b 32 5f fe				ld (input_at_cursor), a 
118e			 
118e			 
118e 3e 01				ld a, 1		; show cursor moving 
1190 32 5c fe				ld (input_cur_onoff),a 
1193 3e 0f				ld a, CUR_BLINK_RATE 
1195 32 5d fe				ld (input_cur_flash), a 
1198			 
1198					; remove char 
1198 3a 5f fe				ld a, (input_at_cursor) 
119b 3c					inc a 
119c 11 26 12				ld de,.iblank 
119f cd af 0d				call str_at_display 
11a2			 
11a2 c3 2e 10				jp .is1 
11a5			 
11a5 fe 0d		.isk4:		cp KEY_CR 
11a7 28 6c				jr z, .endinput 
11a9			 
11a9					; else add the key press to the end 
11a9			 
11a9 4f					ld c, a			; save key pressed 
11aa			 
11aa 7e					ld a,(hl)		; get what is currently under char 
11ab			 
11ab fe 00				cp 0			; we are at the end of the string 
11ad 20 2f				jr nz, .onchar 
11af					 
11af					; add a char to the end of the string 
11af				 
11af 71					ld (hl),c 
11b0 23					inc hl 
11b1			;		ld a,' ' 
11b1			;		ld (hl),a 
11b1			;		inc hl 
11b1 3e 00				ld a,0 
11b3 77					ld (hl),a 
11b4 2b					dec hl 
11b5			 
11b5 3a 52 fe				ld a, (input_cursor) 
11b8 3c					inc a				; TODO check max string length and scroll  
11b9 32 52 fe				ld (input_cursor), a		; inc cursor pos 
11bc							 
11bc 3a 5f fe				ld a, (input_at_cursor) 
11bf 3c					inc a 
11c0 32 5f fe				ld (input_at_cursor), a 
11c3			 
11c3 2a 66 fe				ld hl, (input_ptr) 
11c6 23					inc hl 
11c7 22 66 fe				ld (input_ptr), hl 
11ca			 
11ca 2a 66 fe				ld hl, (input_ptr) 
11cd 23					inc hl 
11ce 22 66 fe				ld (input_ptr), hl 
11d1			;	if DEBUG_INPUT 
11d1			;		push af 
11d1			;		ld a, '+' 
11d1			;		ld (debug_mark),a 
11d1			;		pop af 
11d1			;		CALLMONITOR 
11d1			;	endif 
11d1 3e 01				ld a, 1		; show cursor moving 
11d3 32 5c fe				ld (input_cur_onoff),a 
11d6 3e 0f				ld a, CUR_BLINK_RATE 
11d8 32 5d fe				ld (input_cur_flash), a 
11db c3 2e 10				jp .is1 
11de					 
11de			 
11de			 
11de					; if on a char then insert 
11de			.onchar: 
11de			 
11de					; TODO over flow check: make sure insert does not blow out buffer 
11de			 
11de					; need to do some maths to use lddr 
11de			 
11de e5					push hl   ; save char pos 
11df c5					push bc 
11e0			 
11e0 2a 64 fe				ld hl, (input_start) 
11e3 3a 57 fe				ld a, (input_len) 
11e6 cd d0 0f				call addatohl  		; end of string 
11e9 23					inc hl 
11ea 23					inc hl		; past zero term 
11eb e5					push hl 
11ec 23					inc hl 
11ed e5					push hl  
11ee			 
11ee								; start and end of lddr set, now how much to move? 
11ee			 
11ee							 
11ee 3a 52 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11f1 47					ld b,a 
11f2 3a 57 fe				ld a,(input_len) 
11f5 5f					ld e,a 
11f6 90					sub b 
11f7 3c					inc a		;?? 
11f8 3c					inc a		;?? 
11f9 3c					inc a		;?? 
11fa			 
11fa 06 00				ld b,0 
11fc 4f					ld c,a 
11fd			 
11fd				if DEBUG_INPUT 
11fd					push af 
11fd					ld a, 'i' 
11fd					ld (debug_mark),a 
11fd					pop af 
11fd			;		CALLMONITOR 
11fd				endif 
11fd d1					pop de 
11fe e1					pop hl 
11ff				if DEBUG_INPUT 
11ff					push af 
11ff					ld a, 'I' 
11ff					ld (debug_mark),a 
11ff					pop af 
11ff			;		CALLMONITOR 
11ff				endif 
11ff ed b8				lddr 
1201				 
1201			 
1201			 
1201					; TODO have a key for insert/overwrite mode???? 
1201 c1					pop bc 
1202 e1					pop hl 
1203 71					ld (hl), c		; otherwise overwrite current char 
1204					 
1204			 
1204			 
1204			 
1204 3a 52 fe				ld a, (input_cursor) 
1207 3c					inc  a 		; TODO check overflow 
1208 32 52 fe				ld (input_cursor), a 
120b			 
120b 3a 5f fe				ld a, (input_at_cursor) 
120e 3c					inc a 
120f 32 5f fe				ld (input_at_cursor), a 
1212			 
1212 c3 2e 10				jp .is1 
1215			 
1215			.endinput:	; TODO look for end of string 
1215			 
1215					; add trailing space for end of token 
1215			 
1215 2a 64 fe				ld hl, (input_start) 
1218 3a 57 fe				ld a,(input_len) 
121b cd d0 0f				call addatohl 
121e 3e 20				ld a, ' ' 
1220 77					ld (hl),a 
1221					; TODO eof of parse marker 
1221			 
1221 23					inc hl 
1222 3e 00				ld a, 0 
1224 77					ld (hl),a 
1225			 
1225			 
1225 c9					ret 
1226			 
1226 .. 00		.iblank: db " ",0 
1228			 
1228			 
1228 32 61 fe		input_str_prev:	ld (input_at_pos), a 
122b 22 64 fe				ld (input_start), hl 
122e 3e 01				ld a,1			; add cursor 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235 22 66 fe				ld (input_ptr), hl 
1238 7a					ld a,d 
1239 32 63 fe				ld (input_size), a 
123c 3e 00				ld a,0 
123e 32 52 fe				ld (input_cursor),a 
1241			.instr1:	 
1241			 
1241					; TODO do block cursor 
1241					; TODO switch cursor depending on the modifer key 
1241			 
1241					; update cursor shape change on key hold 
1241			 
1241 2a 66 fe				ld hl, (input_ptr) 
1244 2b					dec hl 
1245 3a be fb				ld a,(cursor_shape) 
1248 77					ld (hl), a 
1249			 
1249					; display entered text 
1249 3a 61 fe				ld a,(input_at_pos) 
124c cd 46 77		            	CALL fLCD_Pos       ;Position cursor to location in A 
124f ed 5b 64 fe	            	LD   de, (input_start) 
1253 cd 68 77		            	CALL fLCD_Str       ;Display string pointed to by DE 
1256			 
1256 cd 82 79				call cin 
1259 fe 00				cp 0 
125b 28 e4				jr z, .instr1 
125d			 
125d					; proecess keyboard controls first 
125d			 
125d 2a 66 fe				ld hl,(input_ptr) 
1260			 
1260 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1262 28 5a				jr z, .instrcr 
1264			 
1264 fe 08				cp KEY_BS 	; back space 
1266 20 0f				jr nz, .instr2 
1268					; process back space 
1268			 
1268					; TODO stop back space if at start of string 
1268 2b					dec hl 
1269 2b					dec hl ; to over write cursor 
126a 3a be fb				ld a,(cursor_shape) 
126d					;ld a,0 
126d 77					ld (hl),a 
126e 23					inc hl 
126f 3e 20				ld a," " 
1271 77					ld (hl),a 
1272 22 66 fe				ld (input_ptr),hl 
1275					 
1275			 
1275 18 ca				jr .instr1 
1277			 
1277 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1279 20 06				jr nz, .instr3 
127b 2b					dec hl 
127c 22 66 fe				ld (input_ptr),hl 
127f 18 c0				jr .instr1 
1281				 
1281 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1283 20 06				jr nz, .instr4 
1285 23					inc hl 
1286 22 66 fe				ld (input_ptr),hl 
1289 18 b6				jr .instr1 
128b			 
128b fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
128d 20 06				jr nz, .instr5 
128f 2b					dec hl 
1290 22 66 fe				ld (input_ptr),hl 
1293 18 ac				jr .instr1 
1295			 
1295 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1297 20 06				jr nz, .instr6 
1299 2b					dec hl 
129a 22 66 fe				ld (input_ptr),hl 
129d 18 a2				jr .instr1 
129f fe 05		.instr6:        cp KEY_UP      ; recall last command 
12a1 20 0b				jr nz, .instrnew 
12a3			 
12a3 21 be f1			ld hl, scratch 
12a6 11 e4 f5			ld de, os_last_cmd 
12a9 cd c7 12			call strcpy 
12ac 18 93				jr .instr1 
12ae			 
12ae			 
12ae			.instrnew:	; no special key pressed to see if we have room to store it 
12ae			 
12ae					; TODO do string size test 
12ae			 
12ae 2b					dec hl ; to over write cursor 
12af 77					ld (hl),a 
12b0 23					inc hl 
12b1 3a be fb				ld a,(cursor_shape) 
12b4 77					ld (hl),a 
12b5 23					inc hl 
12b6 3e 00				ld a,0 
12b8 77					ld (hl),a 
12b9			 
12b9 22 66 fe				ld (input_ptr),hl 
12bc					 
12bc 18 83				jr .instr1 
12be 2b			.instrcr:	dec hl		; remove cursor 
12bf 3e 20				ld a,' '	; TODO add a trailing space for safety 
12c1 77					ld (hl),a 
12c2 23					inc hl 
12c3 3e 00				ld a,0 
12c5 77					ld (hl),a 
12c6			 
12c6			 
12c6					; if at end of line scroll up    
12c6					; TODO detecting only end of line 4 for scroll up  
12c6			 
12c6					;ld   
12c6			 
12c6 c9					ret 
12c7			 
12c7			 
12c7			; strcpy hl = dest, de source 
12c7			 
12c7 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12c8 b7			            OR   A              ;Null terminator? 
12c9 c8			            RET  Z              ;Yes, so finished 
12ca 1a					ld a,(de) 
12cb 77					ld (hl),a 
12cc 13			            INC  DE             ;Point to next character 
12cd 23					inc hl 
12ce 18 f7		            JR   strcpy       ;Repeat 
12d0 c9					ret 
12d1			 
12d1			 
12d1			; TODO string_at  
12d1			; pass string which starts with lcd offset address and then null term string 
12d1			 
12d1			; TODO string to dec 
12d1			; TODO string to hex 
12d1			; TODO byte to string hex 
12d1			; TODO byte to string dec 
12d1			 
12d1			 
12d1			 
12d1			; from z80uartmonitor 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12d1			; pass hl for where to put the text 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1 c5			hexout:	PUSH BC 
12d2 f5					PUSH AF 
12d3 47					LD B, A 
12d4					; Upper nybble 
12d4 cb 3f				SRL A 
12d6 cb 3f				SRL A 
12d8 cb 3f				SRL A 
12da cb 3f				SRL A 
12dc cd ec 12				CALL tohex 
12df 77					ld (hl),a 
12e0 23					inc hl	 
12e1					 
12e1					; Lower nybble 
12e1 78					LD A, B 
12e2 e6 0f				AND 0FH 
12e4 cd ec 12				CALL tohex 
12e7 77					ld (hl),a 
12e8 23					inc hl	 
12e9					 
12e9 f1					POP AF 
12ea c1					POP BC 
12eb c9					RET 
12ec					 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			tohex: 
12ec e5					PUSH HL 
12ed d5					PUSH DE 
12ee 16 00				LD D, 0 
12f0 5f					LD E, A 
12f1 21 f9 12				LD HL, .DATA 
12f4 19					ADD HL, DE 
12f5 7e					LD A, (HL) 
12f6 d1					POP DE 
12f7 e1					POP HL 
12f8 c9					RET 
12f9			 
12f9			.DATA: 
12f9 30					DEFB	30h	; 0 
12fa 31					DEFB	31h	; 1 
12fb 32					DEFB	32h	; 2 
12fc 33					DEFB	33h	; 3 
12fd 34					DEFB	34h	; 4 
12fe 35					DEFB	35h	; 5 
12ff 36					DEFB	36h	; 6 
1300 37					DEFB	37h	; 7 
1301 38					DEFB	38h	; 8 
1302 39					DEFB	39h	; 9 
1303 41					DEFB	41h	; A 
1304 42					DEFB	42h	; B 
1305 43					DEFB	43h	; C 
1306 44					DEFB	44h	; D 
1307 45					DEFB	45h	; E 
1308 46					DEFB	46h	; F 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1309			;;    subtract $30, if result > 9 then subtract $7 more 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			atohex: 
1309 d6 30				SUB $30 
130b fe 0a				CP 10 
130d f8					RET M		; If result negative it was 0-9 so we're done 
130e d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1310 c9					RET		 
1311			 
1311			 
1311			 
1311			 
1311			; Get 2 ASCII characters as hex byte from pointer in hl 
1311			 
1311			BYTERD: 
1311 16 00			LD	D,00h		;Set up 
1313 cd 1b 13			CALL	HEXCON		;Get byte and convert to hex 
1316 87				ADD	A,A		;First nibble so 
1317 87				ADD	A,A		;multiply by 16 
1318 87				ADD	A,A		; 
1319 87				ADD	A,A		; 
131a 57				LD	D,A		;Save hi nibble in D 
131b			HEXCON: 
131b 7e				ld a, (hl)		;Get next chr 
131c 23				inc hl 
131d d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
131f fe 0a			CP	00Ah		;Is it 0-9 ? 
1321 38 02			JR	C,NALPHA	;If so miss next bit 
1323 d6 07			SUB	007h		;Else convert alpha 
1325			NALPHA: 
1325 b2				OR	D		;Add hi nibble back 
1326 c9				RET			; 
1327			 
1327			 
1327			; 
1327			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1327			; Since the routines get_byte and therefore get_nibble are called, only valid 
1327			; characters (0-9a-f) are accepted. 
1327			; 
1327			;get_word        push    af 
1327			;                call    get_byte        ; Get the upper byte 
1327			;                ld      h, a 
1327			;                call    get_byte        ; Get the lower byte 
1327			;                ld      l, a 
1327			;                pop     af 
1327			;                ret 
1327			; 
1327			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1327			; the routine get_nibble is used only valid characters are accepted - the  
1327			; input routine only accepts characters 0-9a-f. 
1327			; 
1327 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1328 7e					ld a,(hl) 
1329 23					inc hl 
132a cd 4f 13		                call    nibble2val      ; Get upper nibble 
132d cb 07		                rlc     a 
132f cb 07		                rlc     a 
1331 cb 07		                rlc     a 
1333 cb 07		                rlc     a 
1335 47			                ld      b, a            ; Save upper four bits 
1336 7e					ld a,(hl) 
1337 cd 4f 13		                call    nibble2val      ; Get lower nibble 
133a b0			                or      b               ; Combine both nibbles 
133b c1			                pop     bc              ; Restore B (and C) 
133c c9			                ret 
133d			; 
133d			; Get a hexadecimal digit from the serial line. This routine blocks until 
133d			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
133d			; to the serial line interface. The lower 4 bits of A contain the value of  
133d			; that particular digit. 
133d			; 
133d			;get_nibble      ld a,(hl)           ; Read a character 
133d			;                call    to_upper        ; Convert to upper case 
133d			;                call    is_hex          ; Was it a hex digit? 
133d			;                jr      nc, get_nibble  ; No, get another character 
133d			 ;               call    nibble2val      ; Convert nibble to value 
133d			 ;               call    print_nibble 
133d			 ;               ret 
133d			; 
133d			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
133d			; A valid hexadecimal digit is denoted by a set C flag. 
133d			; 
133d			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
133d			;                ret     nc              ; Yes 
133d			;                cp      '0'             ; Less than '0'? 
133d			;                jr      nc, is_hex_1    ; No, continue 
133d			;                ccf                     ; Complement carry (i.e. clear it) 
133d			;                ret 
133d			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
133d			;                ret     c               ; Yes 
133d			;                cp      'A'             ; Less than 'A'? 
133d			;                jr      nc, is_hex_2    ; No, continue 
133d			;                ccf                     ; Yes - clear carry and return 
133d			;                ret 
133d			;is_hex_2        scf                     ; Set carry 
133d			;                ret 
133d			; 
133d			; Convert a single character contained in A to upper case: 
133d			; 
133d fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
133f d8			                ret     c 
1340 fe 7b		                cp      'z' + 1         ; > 'z'? 
1342 d0			                ret     nc              ; Nothing to do, either 
1343 e6 5f		                and     $5f             ; Convert to upper case 
1345 c9			                ret 
1346			 
1346			 
1346			to_lower: 
1346			 
1346			   ; if char is in [A-Z] make it lower case 
1346			 
1346			   ; enter : a = char 
1346			   ; exit  : a = lower case char 
1346			   ; uses  : af 
1346			 
1346 fe 41		   cp 'A' 
1348 d8			   ret c 
1349			    
1349 fe 5b		   cp 'Z'+1 
134b d0			   ret nc 
134c			    
134c f6 20		   or $20 
134e c9			   ret 
134f			 
134f			; 
134f			; Expects a hexadecimal digit (upper case!) in A and returns the 
134f			; corresponding value in A. 
134f			; 
134f fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1351 38 02		                jr      c, nibble2val_1 ; Yes 
1353 d6 07		                sub     7               ; Adjust for A-F 
1355 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1357 e6 0f		                and     $f              ; Only return lower 4 bits 
1359 c9			                ret 
135a			; 
135a			; Print_nibble prints a single hex nibble which is contained in the lower  
135a			; four bits of A: 
135a			; 
135a			;print_nibble    push    af              ; We won't destroy the contents of A 
135a			;                and     $f              ; Just in case... 
135a			;                add     a, '0'             ; If we have a digit we are done here. 
135a			;                cp      '9' + 1         ; Is the result > 9? 
135a			;                jr      c, print_nibble_1 
135a			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
135a			;print_nibble_1  call    putc            ; Print the nibble and 
135a			;                pop     af              ; restore the original value of A 
135a			;                ret 
135a			;; 
135a			;; Send a CR/LF pair: 
135a			; 
135a			;crlf            push    af 
135a			;                ld      a, cr 
135a			;                call    putc 
135a			;                ld      a, lf 
135a			;                call    putc 
135a			;                pop     af 
135a			;                ret 
135a			; 
135a			; Print_word prints the four hex digits of a word to the serial line. The  
135a			; word is expected to be in HL. 
135a			; 
135a			;print_word      push    hl 
135a			;                push    af 
135a			;                ld      a, h 
135a			;                call    print_byte 
135a			;                ld      a, l 
135a			;                call    print_byte 
135a			;                pop     af 
135a			;                pop     hl 
135a			;                ret 
135a			; 
135a			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
135a			; The byte to be printed is expected to be in A. 
135a			; 
135a			;print_byte      push    af              ; Save the contents of the registers 
135a			;                push    bc 
135a			;                ld      b, a 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                call    print_nibble    ; Print high nibble 
135a			;                ld      a, b 
135a			;                call    print_nibble    ; Print low nibble 
135a			;                pop     bc              ; Restore original register contents 
135a			;                pop     af 
135a			;                ret 
135a			 
135a			 
135a			 
135a			 
135a			 
135a			fourehexhl:  
135a 7e				ld a,(hl) 
135b cd 09 13			call atohex 
135e cb 3f				SRL A 
1360 cb 3f				SRL A 
1362 cb 3f				SRL A 
1364 cb 3f				SRL A 
1366 47				ld b, a 
1367 23				inc hl 
1368 7e				ld a,(hl) 
1369 23				inc hl 
136a cd 09 13			call atohex 
136d 80				add b 
136e 57				ld d,a 
136f 7e				ld a,(hl) 
1370 cd 09 13			call atohex 
1373 cb 3f				SRL A 
1375 cb 3f				SRL A 
1377 cb 3f				SRL A 
1379 cb 3f				SRL A 
137b 47				ld b, a 
137c 23				inc hl 
137d 7e				ld a,(hl) 
137e 23				inc hl 
137f cd 09 13			call atohex 
1382 80				add b 
1383 5f				ld e, a 
1384 d5				push de 
1385 e1				pop hl 
1386 c9				ret 
1387			 
1387			; pass hl. returns z set if the byte at hl is a digit 
1387			;isdigithl:  
1387			;	push bc 
1387			;	ld a,(hl) 
1387			;	cp ':' 
1387			;	jr nc, .isdf 		; > 
1387			;	cp '0' 
1387			;	jr c, .isdf		; < 
1387			; 
1387			;	; TODO find a better way to set z 
1387			; 
1387			;	ld b,a 
1387			;	cp b 
1387			;	pop bc 
1387			;	ret 
1387			; 
1387			;.isdf:	; not digit so clear z 
1387			; 
1387			;	; TODO find a better way to unset z 
1387			; 
1387			;	ld b,a 
1387			;	inc b 
1387			;	cp b 
1387			; 
1387			;	pop bc 
1387			;	ret 
1387				 
1387				 
1387			 
1387			 
1387			; pass hl as the four byte address to load 
1387			 
1387			get_word_hl:  
1387 e5				push hl 
1388 cd 27 13			call get_byte 
138b				 
138b 47				ld b, a 
138c			 
138c e1				pop hl 
138d 23				inc hl 
138e 23				inc hl 
138f			 
138f			; TODO not able to handle a-f  
138f 7e				ld a,(hl) 
1390			;	;cp ':' 
1390			;	cp 'g' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp 'G' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp '0' 
1390			;	jr c, .single_byte_hl		; < 
1390			 
1390				;call isdigithl 
1390 fe 00			cp 0 
1392 28 06			jr z, .single_byte_hl 
1394			 
1394			.getwhln:   ; hex word so get next byte 
1394			 
1394 cd 27 13			call get_byte 
1397 6f				ld l, a 
1398 60				ld h,b 
1399 c9				ret 
139a 68			.single_byte_hl:   ld l,b 
139b 26 00				ld h,0 
139d c9					ret 
139e			 
139e			 
139e			 
139e			 
139e 21 02 1e			ld hl,asc+1 
13a1			;	ld a, (hl) 
13a1			;	call nibble2val 
13a1 cd 27 13			call get_byte 
13a4			 
13a4			;	call fourehexhl 
13a4 32 f2 f1			ld (scratch+52),a 
13a7				 
13a7 21 f0 f1			ld hl,scratch+50 
13aa 22 e1 f4			ld (os_cur_ptr),hl 
13ad			 
13ad c9				ret 
13ae			 
13ae			 
13ae			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13ae			 
13ae			; Decimal Unsigned Version 
13ae			 
13ae			;Number in a to decimal ASCII 
13ae			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13ae			;Example: display a=56 as "056" 
13ae			;input: a = number 
13ae			;Output: a=0,value of a in the screen 
13ae			;destroys af,bc (don't know about hl and de) 
13ae			DispAToASCII: 
13ae 0e 9c			ld	c,-100 
13b0 cd ba 13			call	.Na1 
13b3 0e f6			ld	c,-10 
13b5 cd ba 13			call	.Na1 
13b8 0e ff			ld	c,-1 
13ba 06 2f		.Na1:	ld	b,'0'-1 
13bc 04			.Na2:	inc	b 
13bd 81				add	a,c 
13be 38 fc			jr	c,.Na2 
13c0 91				sub	c		;works as add 100/10/1 
13c1 f5				push af		;safer than ld c,a 
13c2 78				ld	a,b		;char is in b 
13c3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13c3 f1				pop af		;safer than ld a,c 
13c4 c9				ret 
13c5			 
13c5			; Decimal Signed Version 
13c5			 
13c5			; DispA 
13c5			; -------------------------------------------------------------- 
13c5			; Converts a signed integer value to a zero-terminated ASCII 
13c5			; string representative of that value (using radix 10). 
13c5			; -------------------------------------------------------------- 
13c5			; INPUTS: 
13c5			;     HL     Value to convert (two's complement integer). 
13c5			;     DE     Base address of string destination. (pointer). 
13c5			; -------------------------------------------------------------- 
13c5			; OUTPUTS: 
13c5			;     None 
13c5			; -------------------------------------------------------------- 
13c5			; REGISTERS/MEMORY DESTROYED 
13c5			; AF HL 
13c5			; -------------------------------------------------------------- 
13c5			 
13c5			;DispHLToASCII: 
13c5			;   push    de 
13c5			;   push    bc 
13c5			; 
13c5			;; Detect sign of HL. 
13c5			;    bit    7, h 
13c5			;    jr     z, ._DoConvert 
13c5			; 
13c5			;; HL is negative. Output '-' to string and negate HL. 
13c5			;    ld     a, '-' 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			; 
13c5			;; Negate HL (using two's complement) 
13c5			;    xor    a 
13c5			;    sub    l 
13c5			;    ld     l, a 
13c5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13c5			;    sbc    a, h 
13c5			;    ld     h, a 
13c5			; 
13c5			;; Convert HL to digit characters 
13c5			;._DoConvert: 
13c5			;    ld     b, 0     ; B will count character length of number 
13c5			;-   ld     a, 10 
13c5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13c5			;    push   af 
13c5			;    inc    b 
13c5			;    ld     a, h 
13c5			;    or     l 
13c5			;    jr     nz, - 
13c5			; 
13c5			;; Retrieve digits from stack 
13c5			;-   pop    af 
13c5			;    or     $30 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			;    djnz   - 
13c5			; 
13c5			;; Terminate string with NULL 
13c5			;    xor    a 
13c5			;    ld     (de), a 
13c5			; 
13c5			;    pop    bc 
13c5			;    pop    de 
13c5			;    ret 
13c5			 
13c5			;Comments 
13c5			; 
13c5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13c5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13c5			;    Note that the output string will not be fixed-width. 
13c5			; 
13c5			;Example Usage 
13c5			; 
13c5			;    ld    hl, -1004 
13c5			;    ld    de, OP1 
13c5			;    call  DispA 
13c5			;    ld    hl, OP1 
13c5			;    syscall  PutS 
13c5			 
13c5			 
13c5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13c5			 
13c5			 
13c5			;Converts an ASCII string to an unsigned 16-bit integer 
13c5			;Quits when it reaches a non-decimal digit 
13c5			 
13c5			string_to_uint16: 
13c5			atoui_16: 
13c5			;Input: 
13c5			;     DE points to the string 
13c5			;Outputs: 
13c5			;     HL is the result 
13c5			;     A is the 8-bit value of the number 
13c5			;     DE points to the byte after the number 
13c5			;Destroys: 
13c5			;     BC 
13c5			;       if the string is non-empty, BC is HL/10 
13c5			;Size:  24 bytes 
13c5			;Speed: 42+d(104+{0,9}) 
13c5			;       d is the number of digits in the number 
13c5			;       max is 640 cycles for a 5 digit number 
13c5			;Assuming no leading zeros: 
13c5			;1 digit:  146cc 
13c5			;2 digit:  250cc 
13c5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13c5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13c5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13c5			;avg: 544.81158447265625cc (544+13297/16384) 
13c5			;=============================================================== 
13c5 21 00 00		  ld hl,0 
13c8			.u16a: 
13c8 1a			  ld a,(de) 
13c9 d6 30		  sub 30h 
13cb fe 0a		  cp 10 
13cd d0			  ret nc 
13ce 13			  inc de 
13cf 44			  ld b,h 
13d0 4d			  ld c,l 
13d1 29			  add hl,hl 
13d2 29			  add hl,hl 
13d3 09			  add hl,bc 
13d4 29			  add hl,hl 
13d5 85			  add a,l 
13d6 6f			  ld l,a 
13d7 30 ef		  jr nc,.u16a 
13d9 24			  inc h 
13da c3 c8 13		  jp .u16a 
13dd			 
13dd			 
13dd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13dd			 
13dd			;written by Zeda 
13dd			;Converts a 16-bit unsigned integer to an ASCII string. 
13dd			 
13dd			uitoa_16: 
13dd			;Input: 
13dd			;   DE is the number to convert 
13dd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
13dd			;Output: 
13dd			;   HL points to the null-terminated ASCII string 
13dd			;      NOTE: This isn't necessarily the same as the input HL. 
13dd d5			  push de 
13de c5			  push bc 
13df f5			  push af 
13e0 eb			  ex de,hl 
13e1			 
13e1 01 f0 d8		  ld bc,-10000 
13e4 3e 2f		  ld a,'0'-1 
13e6 3c			  inc a 
13e7 09			  add hl,bc  
13e8 38 fc		   jr c,$-2 
13ea 12			  ld (de),a 
13eb 13			  inc de 
13ec			 
13ec 01 e8 03		  ld bc,1000 
13ef 3e 3a		  ld a,'9'+1 
13f1 3d			  dec a  
13f2 09			  add hl,bc  
13f3 30 fc		   jr nc,$-2 
13f5 12			  ld (de),a 
13f6 13			  inc de 
13f7			 
13f7 01 9c ff		  ld bc,-100 
13fa 3e 2f		  ld a,'0'-1 
13fc 3c			  inc a  
13fd 09			  add hl,bc  
13fe 38 fc		   jr c,$-2 
1400 12			  ld (de),a 
1401 13			  inc de 
1402			 
1402 7d			  ld a,l 
1403 26 3a		  ld h,'9'+1 
1405 25			  dec h  
1406 c6 0a		  add a,10  
1408 30 fb		   jr nc,$-3 
140a c6 30		  add a,'0' 
140c eb			  ex de,hl 
140d 72			  ld (hl),d 
140e 23			  inc hl 
140f 77			  ld (hl),a 
1410 23			  inc hl 
1411 36 00		  ld (hl),0 
1413			 
1413			;Now strip the leading zeros 
1413 0e fa		  ld c,-6 
1415 09			  add hl,bc 
1416 3e 30		  ld a,'0' 
1418 23			  inc hl  
1419 be			  cp (hl)  
141a 28 fc		  jr z,$-2 
141c			 
141c			;Make sure that the string is non-empty! 
141c 7e			  ld a,(hl) 
141d b7			  or a 
141e 20 01		  jr nz,.atoub 
1420 2b			  dec hl 
1421			.atoub: 
1421			 
1421 f1			  pop af 
1422 c1			  pop bc 
1423 d1			  pop de 
1424 c9			  ret 
1425			 
1425			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1425			 
1425			toUpper: 
1425			;A is the char. 
1425			;If A is a lowercase letter, this sets it to the matching uppercase 
1425			;18cc or 30cc or 41cc 
1425			;avg: 26.75cc 
1425 fe 61		  cp 'a' 
1427 d8			  ret c 
1428 fe 7b		  cp 'z'+1 
142a d0			  ret nc 
142b d6 20		  sub 'a'-'A' 
142d c9			  ret 
142e			 
142e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
142e			 
142e			; String Length 
142e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
142e			 
142e			; Get the length of the null-terminated string starting at $8000 hl 
142e			;    LD     HL, $8000 
142e			 
142e			strlenz: 
142e			 
142e af			    XOR    A               ; Zero is the value we are looking for. 
142f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1430 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1431			                           ; 65, 536 bytes (the entire addressable memory space). 
1431 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1433			 
1433			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1433 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1434 6f			    LD     L, A             ; number of bytes 
1435 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1437 2b			    DEC    HL              ; Compensate for null. 
1438 c9				ret 
1439			 
1439			; Get the length of the A terminated string starting at $8000 hl 
1439			;    LD     HL, $8000 
1439			 
1439			strlent: 
1439			 
1439			                  ; A is the value we are looking for. 
1439 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
143b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
143d			                           ; 65, 536 bytes (the entire addressable memory space). 
143d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
143f			 
143f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
143f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1441 2e 00		    LD     L, 0             ; number of bytes 
1443 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1445 2b			    DEC    HL              ; Compensate for null. 
1446 c9				ret 
1447			 
1447			 
1447			;Comparing Strings 
1447			 
1447			;IN    HL     Address of string1. 
1447			;      DE     Address of string2. 
1447			 
1447			; doc given but wrong??? 
1447			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1447			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1447			; tested 
1447			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1447			 
1447			strcmp_old: 
1447 e5			    PUSH   HL 
1448 d5			    PUSH   DE 
1449			 
1449 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
144a be			    CP     (HL)            ; (want to minimize work). 
144b 38 01		    JR     C, Str1IsBigger 
144d 7e			    LD     A, (HL) 
144e			 
144e			Str1IsBigger: 
144e 4f			    LD     C, A             ; Put length in BC 
144f 06 00		    LD     B, 0 
1451 13			    INC    DE              ; Increment pointers to meat of string. 
1452 23			    INC    HL 
1453			 
1453			CmpLoop: 
1453 1a			    LD     A, (DE)          ; Compare bytes. 
1454 ed a1		    CPI 
1456 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1458 13			    INC    DE              ; Update pointer. 
1459 ea 53 14		    JP     PE, CmpLoop 
145c			 
145c d1			    POP    DE 
145d e1			    POP    HL 
145e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
145f be			    CP     (HL) 
1460 c9			    RET 
1461			 
1461			NoMatch: 
1461 2b			    DEC    HL 
1462 be			    CP     (HL)            ; Compare again to affect carry. 
1463 d1			    POP    DE 
1464 e1			    POP    HL 
1465 c9			    RET 
1466			 
1466			;; test strmp 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr z, .z1 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z1: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr z, .z2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr c, .c1 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c1: 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr c, .c2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;	NEXTW 
1466			;.str1:   db "string1",0 
1466			;.str2:   db "string2",0 
1466			 
1466			; only care about direct match or not 
1466			; hl and de strings 
1466			; zero set if the same 
1466			 
1466			strcmp: 
1466 1a				ld a, (de) 
1467 be				cp (hl) 
1468 28 02			jr z, .ssame 
146a b7				or a 
146b c9				ret 
146c			 
146c			.ssame:  
146c fe 00			cp 0 
146e c8				ret z 
146f			 
146f 23				inc hl 
1470 13				inc de 
1471 18 f3			jr strcmp 
1473				 
1473				 
1473			 
1473			 
1473			 
1473			 
1473			; eof 
1473			 
1473			 
1473			 
1473			 
1473			 
1473			 
# End of file firmware_strings.asm
1473			include "firmware_memory.asm"   ; malloc and free  
1473			 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			.mallocsize: db "Wants malloc >256",0 
1473			.mallocasize: db "MALLOC gives >256",0 
1473			.malloczero: db "MALLOC gives zero",0 
1473			 
1473			malloc_guard_zerolen: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473				ld de, 0 
1473			        call cmp16 
1473				jr nz, .lowalloz 
1473			 
1473				push hl 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .malloczero 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473				call bp_on 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473			.lowalloz: 
1473			 
1473			 
1473				pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_entry: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowalloc 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocsize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473				jr .lowdone 
1473			.lowalloc: 
1473			 
1473			 
1473				pop hl 
1473			.lowdone:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_exit: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowallocx 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocasize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473				pop de 
1473				pop hl 
1473			 
1473				CALLMONITOR 
1473				jr .lowdonex 
1473			.lowallocx: 
1473			 
1473				pop hl 
1473			.lowdonex:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			endif 
1473			 
1473			if MALLOC_2 
1473			; Z80 Malloc and Free Functions 
1473			 
1473			; Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc: 
1473				 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_entry 
1473			endif 
1473			 
1473			 
1473			 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "mal" 
1473						CALLMONITOR 
1473					endif 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of size into A 
1473			    or h               ; Check if size is zero 
1473			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1473			 
1473			    ; Allocate memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma1" 
1473						CALLMONITOR 
1473					endif 
1473			    call malloc_internal ; Call internal malloc function 
1473			    pop af             ; Restore AF register 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret                ; Return 
1473			 
1473			; Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free: 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of pointer into A 
1473			    or h               ; Check if pointer is NULL 
1473			    jp z, free_exit    ; If pointer is NULL, exit 
1473			 
1473			    ; Free memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473			    call free_internal  ; Call internal free function 
1473			    pop af             ; Restore AF register 
1473			    ret                ; Return 
1473			 
1473			; Internal Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc_internal: 
1473			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to requested size 
1473			    ex de, hl          ; Save total size in DE, and keep it in HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			 
1473			    ; Search for free memory block 
1473			    ld de, (heap_end)  ; Load end of heap into DE 
1473			    ld bc, 0           ; Initialize counter 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			malloc_search_loop: 
1473			    ; Check if current block is free 
1473			    ld a, (hl)         ; Load current block's status (free or used) 
1473			    cp 0               ; Compare with zero (free) 
1473			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1473			 
1473			    ; Check if current block is large enough 
1473			    ld a, (hl+1)       ; Load high byte of block size 
1473			    cp l               ; Compare with low byte of requested size 
1473			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1473			 
1473			    ld a, (hl+2)       ; Load low byte of block size 
1473			    cp h               ; Compare with high byte of requested size 
1473			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1473			 
1473			    ; Mark block as used 
1473			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1473			 
1473			    ; Calculate remaining space in block 
1473			    ld bc, 0           ; Clear BC 
1473			    add hl, bc         ; Increment HL to point to start of data block 
1473			    add hl, de         ; HL = HL + DE (total size) 
1473			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to start of data block 
1473			 
1473			    ; Save pointer to allocated block in HL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma5" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			malloc_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3           ; Size of management overhead 
1473			    add hl, bc         ; Move to the next block 
1473			    inc de             ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e            ; Load low byte of heap end address 
1473			    cp (hl)            ; Compare with low byte of current address 
1473			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1473			    ld a, d            ; Load high byte of heap end address 
1473			    cp 0               ; Check if it's zero (end of memory) 
1473			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, allocation failed 
1473			    xor a              ; Set result to NULL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma6" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			malloc_exit: 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma7" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			; Internal Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free_internal: 
1473			    ld de, (heap_start) ; Load start of heap into DE 
1473			    ld bc, 0            ; Initialize counter 
1473			 
1473			free_search_loop: 
1473			    ; Check if current block contains the pointer 
1473			    ld a, l             ; Load low byte of pointer 
1473			    cp (hl+1)           ; Compare with high byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			    ld a, h             ; Load high byte of pointer 
1473			    cp (hl+2)           ; Compare with low byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			 
1473			    ; Mark block as free 
1473			    ld (hl), 0          ; Set status byte to indicate free block 
1473			    ret                 ; Return 
1473			 
1473			free_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3            ; Size of management overhead 
1473			    add hl, bc          ; Move to the next block 
1473			    inc de              ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e             ; Load low byte of heap end address 
1473			    cp (hl)             ; Compare with low byte of current address 
1473			    jr nz, free_search_loop  ; If not equal, continue searching 
1473			    ld a, d             ; Load high byte of heap end address 
1473			    cp 0                ; Check if it's zero (end of memory) 
1473			    jr nz, free_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, pointer is not found in heap 
1473			    ret 
1473			 
1473			free_exit: 
1473			    ret                 ; Return 
1473			 
1473			; Define heap start and end addresses 
1473			;heap_start:    .dw 0xC000   ; Start of heap 
1473			;heap_end:      .dw 0xE000   ; End of heap 
1473			 
1473			endif 
1473			 
1473			 
1473			if MALLOC_1 
1473			 
1473			 
1473			 
1473			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1473			 
1473			;moved to firmware.asm 
1473			;heap_start        .equ  0x9000      ; Starting address of heap 
1473			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1473			 
1473			;      .org 0 
1473			;      jp    main 
1473			 
1473			 
1473			;      .org  0x100 
1473			;main: 
1473			;      ld    HL, 0x8100 
1473			;      ld    SP, HL 
1473			; 
1473			;      call  heap_init 
1473			; 
1473			;      ; Make some allocations 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9004 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9014 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9024 
1473			; 
1473			;      ; Free some allocations 
1473			;      ld    HL, 0x9014 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9004 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9024 
1473			;      call  free 
1473			; 
1473			; 
1473			;      halt 
1473			 
1473			 
1473			;------------------------------------------------------------------------------ 
1473			;     heap_init                                                               : 
1473			;                                                                             : 
1473			; Description                                                                 : 
1473			;     Initialise the heap and make it ready for malloc and free operations.   : 
1473			;                                                                             : 
1473			;     The heap is maintained as a linked list, starting with an initial       : 
1473			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1473			;     the first free block in the heap. Each block then points to the next    : 
1473			;     free block within the heap, and the free list ends at the first block   : 
1473			;     with a null pointer to the next free block.                             : 
1473			;                                                                             : 
1473			; Parameters                                                                  : 
1473			;     Inputs are compile-time only. Two defines which specify the starting    : 
1473			;     address of the heap and its size are required, along with a memory      : 
1473			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1473			;     principally stores a pointer to the first free block in the heap.       : 
1473			;                                                                             : 
1473			; Returns                                                                     : 
1473			;     Nothing                                                                 : 
1473			;------------------------------------------------------------------------------ 
1473			heap_init: 
1473 e5			      push  HL 
1474			 
1474			      ; Initialise free list struct 
1474 21 0e 80		      ld    HL, heap_start 
1477 22 0a 80		      ld    (free_list), HL 
147a 21 00 00		      ld    HL, 0 
147d 22 0c 80		      ld    (free_list+2), HL 
1480			 
1480			      ; Insert first free block at bottom of heap, consumes entire heap 
1480 21 a1 f1		      ld    HL, heap_start+heap_size-4 
1483 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1486 21 93 71		      ld    HL, heap_size-4 
1489 22 10 80		      ld    (heap_start+2), HL      ; Block size 
148c			 
148c			      ; Insert end of free list block at top of heap - two null words will 
148c			      ; terminate the free list 
148c 21 00 00		      ld    HL, 0 
148f 22 a3 f1		      ld    (heap_start+heap_size-2), HL 
1492 22 a1 f1		      ld    (heap_start+heap_size-4), HL 
1495			 
1495 e1			      pop   HL 
1496			 
1496 c9			      ret 
1497			 
1497			 
1497			;------------------------------------------------------------------------------ 
1497			;     malloc                                                                  : 
1497			;                                                                             : 
1497			; Description                                                                 : 
1497			;     Allocates the wanted space from the heap and returns the address of the : 
1497			;     first useable byte of the allocation.                                   : 
1497			;                                                                             : 
1497			;     Allocations can happen in one of two ways:                              : 
1497			;                                                                             : 
1497			;     1. A free block may be found which is the exact size wanted. In this    : 
1497			;        case the block is removed from the free list and retuedn to the      : 
1497			;        caller.                                                              : 
1497			;     2. A free block may be found which is larger than the size wanted. In   : 
1497			;        this case, the larger block is split into two. The first portion of  : 
1497			;        this block will become the requested space by the malloc call and    : 
1497			;        is returned to the caller. The second portion becomes a new free     : 
1497			;        block, and the free list is adjusted to maintain continuity via this : 
1497			;        newly created block.                                                 : 
1497			;                                                                             : 
1497			;     malloc does not set any initial value in the allocated space, the       : 
1497			;     caller is required to do this as required.                              : 
1497			;                                                                             : 
1497			;     This implementation of malloc uses the stack exclusively, and is        : 
1497			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1497			;     advisable to disable interrupts before calling malloc, and recommended  : 
1497			;     to avoid the use of malloc inside ISRs in general.                      : 
1497			;                                                                             : 
1497			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1497			;                                                                             : 
1497			; Parameters                                                                  : 
1497			;     HL  Number of bytes wanted                                              : 
1497			;                                                                             : 
1497			; Returns                                                                     : 
1497			;     HL  Address of the first useable byte of the allocation                 : 
1497			;                                                                             : 
1497			; Flags                                                                       : 
1497			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1497			;                                                                             : 
1497			; Stack frame                                                                 : 
1497			;       |             |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     BC      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     DE      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     IX      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |  prev_free  |                                                       : 
1497			;   +4  +-------------+                                                       : 
1497			;       |  this_free  |                                                       : 
1497			;   +2  +-------------+                                                       : 
1497			;       |  next_free  |                                                       : 
1497			;   +0  +-------------+                                                       : 
1497			;       |             |                                                       : 
1497			;                                                                             : 
1497			;------------------------------------------------------------------------------ 
1497			 
1497			 
1497			;malloc: 
1497			; 
1497			;	SAVESP ON 1 
1497			; 
1497			;	call malloc_code 
1497			; 
1497			;	CHECKSP ON 1 
1497			;	ret 
1497			 
1497			 
1497			malloc: 
1497 c5			      push  BC 
1498 d5			      push  DE 
1499 dd e5		      push  IX 
149b			if DEBUG_FORTH_MALLOC_HIGH 
149b			call malloc_guard_entry 
149b			endif 
149b			 
149b					if DEBUG_FORTH_MALLOC 
149b						DMARK "mal" 
149b						CALLMONITOR 
149b					endif 
149b 7c			      ld    A, H                    ; Exit if no space requested 
149c b5			      or    L 
149d ca 5c 15		      jp    Z, malloc_early_exit 
14a0			 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			; 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			 
14a0			 
14a0			 
14a0			 
14a0					if DEBUG_FORTH_MALLOC 
14a0						DMARK "maA" 
14a0						CALLMONITOR 
14a0					endif 
14a0			      ; Set up stack frame 
14a0 eb			      ex    DE, HL 
14a1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14a4 39			      add   HL, SP 
14a5 f9			      ld    SP, HL 
14a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14aa dd 39		      add   IX, SP 
14ac			 
14ac			      ; Setup initial state 
14ac 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14af 19			      add   HL, DE 
14b0			 
14b0 44			      ld    B, H                    ; Move want to BC 
14b1 4d			      ld    C, L 
14b2			 
14b2 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
14b5 dd 75 04		      ld    (IX+4), L 
14b8 dd 74 05		      ld    (IX+5), H 
14bb			 
14bb 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14bc 23			      inc   HL 
14bd 56			      ld    D, (HL) 
14be dd 73 02		      ld    (IX+2), E 
14c1 dd 72 03		      ld    (IX+3), D 
14c4 eb			      ex    DE, HL                  ; this_free ptr into HL 
14c5			 
14c5					if DEBUG_FORTH_MALLOC 
14c5						DMARK "maB" 
14c5						CALLMONITOR 
14c5					endif 
14c5			      ; Loop through free block list to find some space 
14c5			malloc_find_space: 
14c5 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
14c6 23			      inc   HL 
14c7 56			      ld    D, (HL) 
14c8			 
14c8 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
14c9 b3			      or    E 
14ca ca 56 15		      jp    Z, malloc_no_space 
14cd			 
14cd dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
14d0 dd 72 01		      ld    (IX+1), D 
14d3			 
14d3			      ; Does this block have enough space to make the allocation? 
14d3 23			      inc   HL                      ; Load free block size into DE 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7			 
14d7 eb			      ex    DE, HL                  ; Check size of block against want 
14d8 b7			      or    A                       ; Ensure carry flag clear 
14d9 ed 42		      sbc   HL, BC 
14db e5			      push  HL                      ; Store the result for later (new block size) 
14dc			 
14dc ca 2b 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
14df 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
14e1			 
14e1			      ; this_free block is not big enough, setup ptrs to test next free block 
14e1 e1			      pop   HL                      ; Discard previous result 
14e2			 
14e2 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
14e5 dd 66 03		      ld    H, (IX+3) 
14e8 dd 75 04		      ld    (IX+4), L 
14eb dd 74 05		      ld    (IX+5), H 
14ee			 
14ee dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4 dd 75 02		      ld    (IX+2), L 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa					if DEBUG_FORTH_MALLOC 
14fa						DMARK "MA>" 
14fa						CALLMONITOR 
14fa					endif 
14fa 18 c9		      jr    malloc_find_space 
14fc			 
14fc			      ; split a bigger block into two - requested size and remaining size 
14fc			malloc_alloc_split: 
14fc					if DEBUG_FORTH_MALLOC 
14fc						DMARK "MAs" 
14fc						CALLMONITOR 
14fc					endif 
14fc eb			      ex    DE, HL                  ; Calculate address of new free block 
14fd 2b			      dec   HL 
14fe 2b			      dec   HL 
14ff 2b			      dec   HL 
1500 09			      add   HL, BC 
1501			 
1501			      ; Create a new block and point it at next_free 
1501 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1504 dd 56 01		      ld    D, (IX+1) 
1507			 
1507 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1508 23			      inc   HL 
1509 72			      ld    (HL), D 
150a			 
150a d1			      pop   DE                      ; Store size of new block into new block 
150b 23			      inc   HL 
150c 73			      ld    (HL), E 
150d 23			      inc   HL 
150e 72			      ld    (HL), D 
150f			 
150f			      ; Update this_free ptr to point to new block 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511 2b			      dec   HL 
1512			 
1512 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1515 dd 56 03		      ld    D, (IX+3) 
1518			 
1518 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
151b dd 74 03		      ld    (IX+3), H 
151e			 
151e			      ; Modify this_free block to be allocation 
151e eb			      ex    DE, HL 
151f af			      xor   A                       ; Null the next block ptr of allocated block 
1520 77			      ld    (HL), A 
1521 23			      inc   HL 
1522 77			      ld    (HL), A 
1523			 
1523 23			      inc   HL                      ; Store want size into allocated block 
1524 71			      ld    (HL), C 
1525 23			      inc   HL 
1526 70			      ld    (HL), B 
1527 23			      inc   HL 
1528 e5			      push  HL                      ; Address of allocation to return 
1529			 
1529 18 19		      jr    malloc_update_links 
152b			 
152b			malloc_alloc_fit: 
152b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
152c			 
152c					if DEBUG_FORTH_MALLOC 
152c						DMARK "MAf" 
152c						CALLMONITOR 
152c					endif 
152c			      ; Modify this_free block to be allocation 
152c eb			      ex    DE, HL 
152d 2b			      dec   HL 
152e 2b			      dec   HL 
152f 2b			      dec   HL 
1530			 
1530 af			      xor   A                       ; Null the next block ptr of allocated block 
1531 77			      ld    (HL), A 
1532 23			      inc   HL 
1533 77			      ld    (HL), A 
1534			 
1534 23			      inc   HL                      ; Store address of allocation to return 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 e5			      push  HL 
1538			 
1538			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1538 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
153b dd 66 01		      ld    H, (IX+1) 
153e			 
153e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1541 dd 74 03		      ld    (IX+3), H 
1544			 
1544			 
1544			malloc_update_links: 
1544			      ; Update prev_free ptr to point to this_free 
1544 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1547 dd 66 05		      ld    H, (IX+5) 
154a			 
154a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
154d dd 56 03		      ld    D, (IX+3) 
1550			 
1550 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1551 23			      inc   HL 
1552 72			      ld    (HL), D 
1553			 
1553					if DEBUG_FORTH_MALLOC 
1553						DMARK "Mul" 
1553						CALLMONITOR 
1553					endif 
1553			      ; Clear the Z flag to indicate successful allocation 
1553 7a			      ld    A, D 
1554 b3			      or    E 
1555			 
1555 d1			      pop   DE                      ; Address of allocation 
1556					if DEBUG_FORTH_MALLOC 
1556						DMARK "MAu" 
1556						CALLMONITOR 
1556					endif 
1556			 
1556			malloc_no_space: 
1556 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1559 39			      add   HL, SP 
155a f9			      ld    SP, HL 
155b			 
155b eb			      ex    DE, HL                  ; Alloc addr into HL for return 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAN" 
155c						CALLMONITOR 
155c					endif 
155c			 
155c			malloc_early_exit: 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAx" 
155c						CALLMONITOR 
155c					endif 
155c dd e1		      pop   IX 
155e d1			      pop   DE 
155f c1			      pop   BC 
1560			 
1560			if DEBUG_FORTH_MALLOC_HIGH 
1560			call malloc_guard_exit 
1560			call malloc_guard_zerolen 
1560			endif 
1560 c9			      ret 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     free                                                                    : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1561			;     returned by malloc, otherwise the behaviour is undefined.               : 
1561			;                                                                             : 
1561			;     Where possible, directly adjacent free blocks will be merged together   : 
1561			;     into larger blocks to help ensure that the heap does not become         : 
1561			;     excessively fragmented.                                                 : 
1561			;                                                                             : 
1561			;     free does not clear or set any other value into the freed space, and    : 
1561			;     therefore its contents may be visible through subsequent malloc's. The  : 
1561			;     caller should clear the freed space as required.                        : 
1561			;                                                                             : 
1561			;     This implementation of free uses the stack exclusively, and is          : 
1561			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1561			;     advisable to disable interrupts before calling free, and recommended    : 
1561			;     to avoid the use of free inside ISRs in general.                        : 
1561			;                                                                             : 
1561			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     HL  Pointer to address of first byte of allocation to be freed          : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     Nothing                                                                 : 
1561			;                                                                             : 
1561			; Stack frame                                                                 : 
1561			;       |             |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     BC      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     DE      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     IX      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |  prev_free  |                                                       : 
1561			;   +2  +-------------+                                                       : 
1561			;       |  next_free  |                                                       : 
1561			;   +0  +-------------+                                                       : 
1561			;       |             |                                                       : 
1561			;                                                                             : 
1561			;------------------------------------------------------------------------------ 
1561			free: 
1561 c5			      push  BC 
1562 d5			      push  DE 
1563 dd e5		      push  IX 
1565			 
1565 7c			      ld    A, H                    ; Exit if ptr is null 
1566 b5			      or    L 
1567 ca 2b 16		      jp    Z, free_early_exit 
156a			 
156a			      ; Set up stack frame 
156a eb			      ex    DE, HL 
156b 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
156e 39			      add   HL, SP 
156f f9			      ld    SP, HL 
1570 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1574 dd 39		      add   IX, SP 
1576			 
1576			      ; The address in HL points to the start of the useable allocated space, 
1576			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1576			      ; address of the block itself. 
1576 eb			      ex    DE, HL 
1577 11 fc ff		      ld    DE, -4 
157a 19			      add   HL, DE 
157b			 
157b			      ; An allocated block must have a null next block pointer in it 
157b 7e			      ld    A, (HL) 
157c 23			      inc   HL 
157d b6			      or    (HL) 
157e c2 26 16		      jp    NZ, free_done 
1581			 
1581 2b			      dec   HL 
1582			 
1582 44			      ld    B, H                    ; Copy HL to BC 
1583 4d			      ld    C, L 
1584			 
1584			      ; Loop through the free list to find the first block with an address 
1584			      ; higher than the block being freed 
1584 21 0a 80		      ld    HL, free_list 
1587			 
1587			free_find_higher_block: 
1587 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1588 23			      inc   HL 
1589 56			      ld    D, (HL) 
158a 2b			      dec   HL 
158b			 
158b dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
158e dd 72 01		      ld    (IX+1), D 
1591 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1594 dd 74 03		      ld    (IX+3), H 
1597			 
1597 78			      ld    A, B                    ; Check if DE is greater than BC 
1598 ba			      cp    D                       ; Compare MSB first 
1599 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
159b 30 04		      jr    NC, free_find_higher_block_skip 
159d 79			      ld    A, C 
159e bb			      cp    E                       ; Then compare LSB 
159f 38 08		      jr    C, free_found_higher_block 
15a1			 
15a1			free_find_higher_block_skip: 
15a1 7a			      ld    A, D                    ; Reached the end of the free list? 
15a2 b3			      or    E 
15a3 ca 26 16		      jp    Z, free_done 
15a6			 
15a6 eb			      ex    DE, HL 
15a7			 
15a7 18 de		      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9 71			      ld    (HL), C                 ; Point prev free block to freed block 
15aa 23			      inc   HL 
15ab 70			      ld    (HL), B 
15ac			 
15ac 60			      ld    H, B                    ; Point freed block at next free block 
15ad 69			      ld    L, C 
15ae 73			      ld    (HL), E 
15af 23			      inc   HL 
15b0 72			      ld    (HL), D 
15b1			 
15b1			      ; Check if the freed block is adjacent to the next free block 
15b1 23			      inc   HL                      ; Load size of freed block into HL 
15b2 5e			      ld    E, (HL) 
15b3 23			      inc   HL 
15b4 56			      ld    D, (HL) 
15b5 eb			      ex    DE, HL 
15b6			 
15b6 09			      add   HL, BC                  ; Add addr of freed block and its size 
15b7			 
15b7 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ba dd 56 01		      ld    D, (IX+1) 
15bd			 
15bd b7			      or    A                       ; Clear the carry flag 
15be ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15c0 20 22		      jr    NZ, free_check_adjacent_to_prev 
15c2			 
15c2			      ; Freed block is adjacent to next, merge into one bigger block 
15c2 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15c3 5e			      ld    E, (HL) 
15c4 23			      inc   HL 
15c5 56			      ld    D, (HL) 
15c6 e5			      push  HL                      ; Save ptr to next block for later 
15c7			 
15c7 60			      ld    H, B                    ; Store ptr from next block into freed block 
15c8 69			      ld    L, C 
15c9 73			      ld    (HL), E 
15ca 23			      inc   HL 
15cb 72			      ld    (HL), D 
15cc			 
15cc e1			      pop   HL                      ; Restore ptr to next block 
15cd 23			      inc   HL                      ; Load size of next block into DE 
15ce 5e			      ld    E, (HL) 
15cf 23			      inc   HL 
15d0 56			      ld    D, (HL) 
15d1 d5			      push  DE                      ; Save next block size for later 
15d2			 
15d2 60			      ld    H, B                    ; Load size of freed block into HL 
15d3 69			      ld    L, C 
15d4 23			      inc   HL 
15d5 23			      inc   HL 
15d6 5e			      ld    E, (HL) 
15d7 23			      inc   HL 
15d8 56			      ld    D, (HL) 
15d9 eb			      ex    DE, HL 
15da			 
15da d1			      pop   DE                      ; Restore size of next block 
15db 19			      add   HL, DE                  ; Add sizes of both blocks 
15dc eb			      ex    DE, HL 
15dd			 
15dd 60			      ld    H, B                    ; Store new bigger size into freed block 
15de 69			      ld    L, C 
15df 23			      inc   HL 
15e0 23			      inc   HL 
15e1 73			      ld    (HL), E 
15e2 23			      inc   HL 
15e3 72			      ld    (HL), D 
15e4			 
15e4			free_check_adjacent_to_prev: 
15e4			      ; Check if the freed block is adjacent to the prev free block 
15e4 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e7 dd 66 03		      ld    H, (IX+3) 
15ea			 
15ea 23			      inc   HL                      ; Size of prev free block into DE 
15eb 23			      inc   HL 
15ec 5e			      ld    E, (HL) 
15ed 23			      inc   HL 
15ee 56			      ld    D, (HL) 
15ef 2b			      dec   HL 
15f0 2b			      dec   HL 
15f1 2b			      dec   HL 
15f2			 
15f2 19			      add   HL, DE                  ; Add prev block addr and size 
15f3			 
15f3 b7			      or    A                       ; Clear the carry flag 
15f4 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15f6 20 2e		      jr    NZ, free_done 
15f8			 
15f8			      ; Freed block is adjacent to prev, merge into one bigger block 
15f8 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15f9 69			      ld    L, C 
15fa 5e			      ld    E, (HL) 
15fb 23			      inc   HL 
15fc 56			      ld    D, (HL) 
15fd e5			      push  HL                      ; Save freed block ptr for later 
15fe			 
15fe dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1601 dd 66 03		      ld    H, (IX+3) 
1604 73			      ld    (HL), E 
1605 23			      inc   HL 
1606 72			      ld    (HL), D 
1607			 
1607 e1			      pop   HL                      ; Restore freed block ptr 
1608 23			      inc   HL                      ; Load size of freed block into DE 
1609 5e			      ld    E, (HL) 
160a 23			      inc   HL 
160b 56			      ld    D, (HL) 
160c d5			      push  DE                      ; Save freed block size for later 
160d			 
160d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1610 dd 66 03		      ld    H, (IX+3) 
1613 23			      inc   HL 
1614 23			      inc   HL 
1615 5e			      ld    E, (HL) 
1616 23			      inc   HL 
1617 56			      ld    D, (HL) 
1618			 
1618 e1			      pop   HL                      ; Add sizes of both blocks 
1619 19			      add   HL, DE 
161a eb			      ex    DE, HL 
161b			 
161b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
161e dd 66 03		      ld    H, (IX+3) 
1621 23			      inc   HL 
1622 23			      inc   HL 
1623 73			      ld    (HL), E 
1624 23			      inc   HL 
1625 72			      ld    (HL), D 
1626			 
1626			free_done: 
1626 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1629 39			      add   HL, SP 
162a f9			      ld    SP, HL 
162b			 
162b			free_early_exit: 
162b dd e1		      pop   IX 
162d d1			      pop   DE 
162e c1			      pop   BC 
162f			 
162f c9			      ret 
1630			 
1630			; moved to firmware.asm 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			;                  .dw   0 
1630			 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_3 
1630			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1630			;heap_start        .equ  0x9000      ; Starting address of heap 
1630			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1630			; 
1630			 ;     .org 0 
1630			  ;    jp    main 
1630			; 
1630			; 
1630			 ;     .org  0x100 
1630			;main: 
1630			 ;     ld    HL, 0x8100 
1630			  ;    ld    SP, HL 
1630			; 
1630			;      call  heap_init 
1630			 
1630			      ; Make some allocations 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9004 
1630			; 
1630			 ;     ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9014 
1630			 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9024 
1630			 
1630			      ; Free some allocations 
1630			;      ld    HL, 0x9014 
1630			;      call  free 
1630			 
1630			;      ld    HL, 0x9004 
1630			;      call  free 
1630			; 
1630			;      ld    HL, 0x9024 
1630			;      call  free 
1630			 
1630			 
1630			 ;     halt 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     heap_init                                                               : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Initialise the heap and make it ready for malloc and free operations.   : 
1630			;                                                                             : 
1630			;     The heap is maintained as a linked list, starting with an initial       : 
1630			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1630			;     the first free block in the heap. Each block then points to the next    : 
1630			;     free block within the heap, and the free list ends at the first block   : 
1630			;     with a null pointer to the next free block.                             : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     Inputs are compile-time only. Two defines which specify the starting    : 
1630			;     address of the heap and its size are required, along with a memory      : 
1630			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1630			;     principally stores a pointer to the first free block in the heap.       : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;------------------------------------------------------------------------------ 
1630			heap_init: 
1630			      push  HL 
1630			 
1630			      ; Initialise free list struct 
1630			      ld    HL, heap_start 
1630			      ld    (free_list), HL 
1630			      ld    HL, 0 
1630			      ld    (free_list+2), HL 
1630			 
1630			      ; Insert first free block at bottom of heap, consumes entire heap 
1630			      ld    HL, heap_start+heap_size-4 
1630			      ld    (heap_start), HL        ; Next block (end of free list) 
1630			      ld    HL, heap_size-4 
1630			      ld    (heap_start+2), HL      ; Block size 
1630			 
1630			      ; Insert end of free list block at top of heap - two null words will 
1630			      ; terminate the free list 
1630			      ld    HL, 0 
1630			      ld    (heap_start+heap_size-2), HL 
1630			      ld    (heap_start+heap_size-4), HL 
1630			 
1630			      pop   HL 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     malloc                                                                  : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Allocates the wanted space from the heap and returns the address of the : 
1630			;     first useable byte of the allocation.                                   : 
1630			;                                                                             : 
1630			;     Allocations can happen in one of two ways:                              : 
1630			;                                                                             : 
1630			;     1. A free block may be found which is the exact size wanted. In this    : 
1630			;        case the block is removed from the free list and retuedn to the      : 
1630			;        caller.                                                              : 
1630			;     2. A free block may be found which is larger than the size wanted. In   : 
1630			;        this case, the larger block is split into two. The first portion of  : 
1630			;        this block will become the requested space by the malloc call and    : 
1630			;        is returned to the caller. The second portion becomes a new free     : 
1630			;        block, and the free list is adjusted to maintain continuity via this : 
1630			;        newly created block.                                                 : 
1630			;                                                                             : 
1630			;     malloc does not set any initial value in the allocated space, the       : 
1630			;     caller is required to do this as required.                              : 
1630			;                                                                             : 
1630			;     This implementation of malloc uses the stack exclusively, and is        : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling malloc, and recommended  : 
1630			;     to avoid the use of malloc inside ISRs in general.                      : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Number of bytes wanted                                              : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     HL  Address of the first useable byte of the allocation                 : 
1630			;                                                                             : 
1630			; Flags                                                                       : 
1630			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +4  +-------------+                                                       : 
1630			;       |  this_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			malloc: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if no space requested 
1630			      or    L 
1630			      jp    Z, malloc_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; Setup initial state 
1630			      ld    HL, 4                   ; want must also include space used by block struct 
1630			      add   HL, DE 
1630			 
1630			      ld    B, H                    ; Move want to BC 
1630			      ld    C, L 
1630			 
1630			      ld    HL, free_list           ; Store prev_free ptr to stack 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    E, (HL)                 ; Store this_free ptr to stack 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ld    (IX+2), E 
1630			      ld    (IX+3), D 
1630			      ex    DE, HL                  ; this_free ptr into HL 
1630			 
1630			      ; Loop through free block list to find some space 
1630			malloc_find_space: 
1630			      ld    E, (HL)                 ; Load next_free ptr into DE 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1630			      or    E 
1630			      jp    Z, malloc_no_space 
1630			 
1630			      ld    (IX+0), E               ; Store next_free ptr to stack 
1630			      ld    (IX+1), D 
1630			 
1630			      ; Does this block have enough space to make the allocation? 
1630			      inc   HL                      ; Load free block size into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ex    DE, HL                  ; Check size of block against want 
1630			      or    A                       ; Ensure carry flag clear 
1630			      sbc   HL, BC 
1630			      push  HL                      ; Store the result for later (new block size) 
1630			 
1630			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1630			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1630			 
1630			      ; this_free block is not big enough, setup ptrs to test next free block 
1630			      pop   HL                      ; Discard previous result 
1630			 
1630			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1630			      ld    H, (IX+3) 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1630			      ld    H, (IX+1) 
1630			      ld    (IX+2), L 
1630			      ld    (IX+3), H 
1630			 
1630			      jr    malloc_find_space 
1630			 
1630			      ; split a bigger block into two - requested size and remaining size 
1630			malloc_alloc_split: 
1630			      ex    DE, HL                  ; Calculate address of new free block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      add   HL, BC 
1630			 
1630			      ; Create a new block and point it at next_free 
1630			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      ld    (HL), E                 ; Store next_free ptr into new block 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   DE                      ; Store size of new block into new block 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Update this_free ptr to point to new block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1630			      ld    (IX+3), H 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store want size into allocated block 
1630			      ld    (HL), C 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			      inc   HL 
1630			      push  HL                      ; Address of allocation to return 
1630			 
1630			      jr    malloc_update_links 
1630			 
1630			malloc_alloc_fit: 
1630			      pop   HL                      ; Dont need new block size, want is exact fit 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store address of allocation to return 
1630			      inc   HL 
1630			      inc   HL 
1630			      push  HL 
1630			 
1630			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1630			      ld    L, (IX+0)               ; next_free to HL 
1630			      ld    H, (IX+1) 
1630			 
1630			      ld    (IX+2), L               ; HL to this_free 
1630			      ld    (IX+3), H 
1630			 
1630			 
1630			malloc_update_links: 
1630			      ; Update prev_free ptr to point to this_free 
1630			      ld    L, (IX+4)               ; prev_free ptr to HL 
1630			      ld    H, (IX+5) 
1630			 
1630			      ld    E, (IX+2)               ; this_free ptr to DE 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (HL), E                 ; this_free ptr into prev_free 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Clear the Z flag to indicate successful allocation 
1630			      ld    A, D 
1630			      or    E 
1630			 
1630			      pop   DE                      ; Address of allocation 
1630			 
1630			malloc_no_space: 
1630			      ld    HL, 6                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			      ex    DE, HL                  ; Alloc addr into HL for return 
1630			 
1630			malloc_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     free                                                                    : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1630			;     returned by malloc, otherwise the behaviour is undefined.               : 
1630			;                                                                             : 
1630			;     Where possible, directly adjacent free blocks will be merged together   : 
1630			;     into larger blocks to help ensure that the heap does not become         : 
1630			;     excessively fragmented.                                                 : 
1630			;                                                                             : 
1630			;     free does not clear or set any other value into the freed space, and    : 
1630			;     therefore its contents may be visible through subsequent malloc's. The  : 
1630			;     caller should clear the freed space as required.                        : 
1630			;                                                                             : 
1630			;     This implementation of free uses the stack exclusively, and is          : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling free, and recommended    : 
1630			;     to avoid the use of free inside ISRs in general.                        : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Pointer to address of first byte of allocation to be freed          : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			free: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if ptr is null 
1630			      or    L 
1630			      jp    Z, free_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; The address in HL points to the start of the useable allocated space, 
1630			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1630			      ; address of the block itself. 
1630			      ex    DE, HL 
1630			      ld    DE, -4 
1630			      add   HL, DE 
1630			 
1630			      ; An allocated block must have a null next block pointer in it 
1630			      ld    A, (HL) 
1630			      inc   HL 
1630			      or    (HL) 
1630			      jp    NZ, free_done 
1630			 
1630			      dec   HL 
1630			 
1630			      ld    B, H                    ; Copy HL to BC 
1630			      ld    C, L 
1630			 
1630			      ; Loop through the free list to find the first block with an address 
1630			      ; higher than the block being freed 
1630			      ld    HL, free_list 
1630			 
1630			free_find_higher_block: 
1630			      ld    E, (HL)                 ; Load next ptr from free block 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			 
1630			      ld    (IX+0), E               ; Save ptr to next free block 
1630			      ld    (IX+1), D 
1630			      ld    (IX+2), L               ; Save ptr to prev free block 
1630			      ld    (IX+3), H 
1630			 
1630			      ld    A, B                    ; Check if DE is greater than BC 
1630			      cp    D                       ; Compare MSB first 
1630			      jr    Z, $+4                  ; MSB the same, compare LSB 
1630			      jr    NC, free_find_higher_block_skip 
1630			      ld    A, C 
1630			      cp    E                       ; Then compare LSB 
1630			      jr    C, free_found_higher_block 
1630			 
1630			free_find_higher_block_skip: 
1630			      ld    A, D                    ; Reached the end of the free list? 
1630			      or    E 
1630			      jp    Z, free_done 
1630			 
1630			      ex    DE, HL 
1630			 
1630			      jr    free_find_higher_block 
1630			 
1630			free_found_higher_block: 
1630			      ; Insert freed block between prev and next free blocks 
1630			      ld    (HL), C                 ; Point prev free block to freed block 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			 
1630			      ld    H, B                    ; Point freed block at next free block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Check if the freed block is adjacent to the next free block 
1630			      inc   HL                      ; Load size of freed block into HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      add   HL, BC                  ; Add addr of freed block and its size 
1630			 
1630			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_check_adjacent_to_prev 
1630			 
1630			      ; Freed block is adjacent to next, merge into one bigger block 
1630			      ex    DE, HL                  ; Load next ptr from next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save ptr to next block for later 
1630			 
1630			      ld    H, B                    ; Store ptr from next block into freed block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore ptr to next block 
1630			      inc   HL                      ; Load size of next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save next block size for later 
1630			 
1630			      ld    H, B                    ; Load size of freed block into HL 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      pop   DE                      ; Restore size of next block 
1630			      add   HL, DE                  ; Add sizes of both blocks 
1630			      ex    DE, HL 
1630			 
1630			      ld    H, B                    ; Store new bigger size into freed block 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_check_adjacent_to_prev: 
1630			      ; Check if the freed block is adjacent to the prev free block 
1630			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1630			      ld    H, (IX+3) 
1630			 
1630			      inc   HL                      ; Size of prev free block into DE 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      add   HL, DE                  ; Add prev block addr and size 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_done 
1630			 
1630			      ; Freed block is adjacent to prev, merge into one bigger block 
1630			      ld    H, B                    ; Load next ptr from freed block into DE 
1630			      ld    L, C 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save freed block ptr for later 
1630			 
1630			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1630			      ld    H, (IX+3) 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore freed block ptr 
1630			      inc   HL                      ; Load size of freed block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save freed block size for later 
1630			 
1630			      ld    L, (IX+2)               ; Load size of prev block into DE 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      pop   HL                      ; Add sizes of both blocks 
1630			      add   HL, DE 
1630			      ex    DE, HL 
1630			 
1630			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_done: 
1630			      ld    HL, 4                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			free_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;      .org 0x8000 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			 ;                 .dw   0 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_4 
1630			 
1630			; My memory allocation code. Very very simple.... 
1630			; allocate space under 250 chars 
1630			 
1630			heap_init: 
1630				; init start of heap as zero 
1630				;  
1630			 
1630				ld hl, heap_start 
1630				ld a, 0 
1630				ld (hl), a      ; empty block 
1630				inc hl 
1630				ld a, 0 
1630				ld (hl), a      ; length of block 
1630				; write end of list 
1630				inc hl 
1630				ld a,(hl) 
1630				inc hl 
1630				ld a,(hl) 
1630				 
1630			 
1630				; init some malloc vars 
1630			 
1630				ld hl, 0 
1630				ld (free_list), hl       ; store last malloc location 
1630			 
1630				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1630				ld a, 0 
1630				ld (hl), a 
1630			 
1630			 
1630				ld hl, heap_start 
1630				;  
1630				  
1630				ret 
1630			 
1630			 
1630			;    free block marker 
1630			;    requested size  
1630			;    pointer to next block 
1630			;    .... 
1630			;    next block marker 
1630			 
1630			 
1630			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1630			; 
1630			 
1630			 
1630			malloc:  
1630				push de 
1630				push bc 
1630				push af 
1630			 
1630				; hl space required 
1630				 
1630				ld c, l    ; hold space   (TODO only a max of 255) 
1630			 
1630			;	inc c     ; TODO BUG need to fix memory leak on push str 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			 
1630			 
1630			 
1630				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1630			 
1630				ld a, (free_list+3) 
1630				cp 0 
1630				jr z, .contheap 
1630			 
1630				ld hl, (free_list)     ; get last alloc 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mrs" 
1630						CALLMONITOR 
1630					endif 
1630				jr .startalloc 
1630			 
1630			.contheap: 
1630				ld hl, heap_start 
1630			 
1630			.startalloc: 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mym" 
1630						CALLMONITOR 
1630					endif 
1630			.findblock: 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmf" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630				ld a,(hl)  
1630				; if byte is zero then clear to use 
1630			 
1630				cp 0 
1630				jr z, .foundemptyblock 
1630			 
1630				; if byte is not clear 
1630				;     then byte is offset to next block 
1630			 
1630				inc hl 
1630				ld a, (hl) ; get size 
1630			.nextblock:	inc hl 
1630					ld e, (hl) 
1630					inc hl 
1630					ld d, (hl) 
1630					ex de, hl 
1630			;	inc hl  ; move past the store space 
1630			;	inc hl  ; move past zero index  
1630			 
1630				; TODO detect no more space 
1630			 
1630				push hl 
1630				ld de, heap_end 
1630				call cmp16 
1630				pop hl 
1630				jr nc, .nospace 
1630			 
1630				jr .findblock 
1630			 
1630			.nospace: ld hl, 0 
1630				jp .exit 
1630			 
1630			 
1630			.foundemptyblock:	 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mme" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; TODO has block enough space if reusing??? 
1630			 
1630				;  
1630			 
1630			; see if this block has been previously used 
1630				inc hl 
1630				ld a, (hl) 
1630				dec hl 
1630				cp 0 
1630				jr z, .newblock 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meR" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; no reusing previously allocated block 
1630			 
1630			; is it smaller than previously used? 
1630				 
1630				inc hl    ; move to size 
1630				ld a, c 
1630				sub (hl)        ; we want c < (hl) 
1630				dec hl    ; move back to marker 
1630			        jr z, .findblock 
1630			 
1630				; update with the new size which should be lower 
1630			 
1630			        ;inc  hl   ; negate next move. move back to size  
1630			 
1630			.newblock: 
1630				; need to be at marker here 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meN" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			 
1630				ld a, c 
1630			 
1630				ld (free_list+3), a	 ; flag resume from last malloc  
1630				ld (free_list), hl    ; save out last location 
1630			 
1630			 
1630				;inc a     ; space for length byte 
1630				ld (hl), a     ; save block in use marker 
1630			 
1630				inc hl   ; move to space marker 
1630				ld (hl), a    ; save new space 
1630			 
1630				inc hl   ; move to start of allocated area 
1630				 
1630			;	push hl     ; save where we are - 1  
1630			 
1630			;	inc hl  ; move past zero index  
1630				; skip space to set down new marker 
1630			 
1630				; provide some extra space for now 
1630			 
1630				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1630				inc a 
1630				inc a 
1630			 
1630				push hl   ; save where we are in the node block 
1630			 
1630				call addatohl 
1630			 
1630				; write linked list point 
1630			 
1630				pop de     ; get our node position 
1630				ex de, hl 
1630			 
1630				ld (hl), e 
1630				inc hl 
1630				ld (hl), d 
1630			 
1630				inc hl 
1630			 
1630				; now at start of allocated data so save pointer 
1630			 
1630				push hl 
1630			 
1630				; jump to position of next node and setup empty header in DE 
1630			 
1630				ex de, hl 
1630			 
1630			;	inc hl ; move past end of block 
1630			 
1630				ld a, 0 
1630				ld (hl), a   ; empty marker 
1630				inc hl 
1630				ld (hl), a   ; size 
1630				inc hl  
1630				ld (hl), a   ; ptr 
1630				inc hl 
1630				ld (hl), a   ; ptr 
1630			 
1630			 
1630				pop hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmr" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			.exit: 
1630				pop af 
1630				pop bc 
1630				pop de  
1630				ret 
1630			 
1630			 
1630			 
1630			 
1630			free:  
1630				push hl 
1630				push af 
1630				; get address in hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "fre" 
1630						CALLMONITOR 
1630					endif 
1630				; data is at hl - move to block count 
1630				dec hl 
1630				dec hl    ; get past pointer 
1630				dec hl 
1630			 
1630				ld a, (hl)    ; need this for a validation check 
1630			 
1630				dec hl    ; move to block marker 
1630			 
1630				; now check that the block count and block marker are the same  
1630			        ; this checks that we are on a malloc node and not random memory 
1630			        ; OK a faint chance this could be a problem but rare - famous last words! 
1630			 
1630				ld c, a 
1630				ld a, (hl)    
1630			 
1630				cp c 
1630				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1630			 
1630				; yes good chance we are on a malloc node 
1630			 
1630				ld a, 0      
1630				ld (hl), a   ; mark as free 
1630			 
1630				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1630			 
1630			.freeignore:  
1630			 
1630				pop af 
1630				pop hl 
1630			 
1630				ret 
1630			 
1630			 
1630			 
1630			endif 
1630			 
1630			; eof 
# End of file firmware_memory.asm
1630			  
1630			; device C  
1630			; Now handled by SPI  
1630			;if SOUND_ENABLE  
1630			;	include "firmware_sound.asm"  
1630			;endif  
1630			  
1630			include "firmware_diags.asm"  
1630			; Hardware diags menu 
1630			 
1630			 
1630			config: 
1630			 
1630 3e 00			ld a, 0 
1632 21 5b 16			ld hl, .configmn 
1635 cd cd 0d			call menu 
1638			 
1638 fe 00			cp 0 
163a c8				ret z 
163b			 
163b			;	cp 1 
163b			;	call z, .savetostore 
163b			 
163b fe 01			cp 1 
163d			if STARTUP_V1 
163d				call z, .selautoload 
163d			endif 
163d			 
163d			if STARTUP_V2 
163d cc 69 16			call z, .enautoload 
1640			endif 
1640 fe 02			cp 2 
1642 cc 80 16			call z, .disautoload 
1645			;	cp 3 
1645			;	call z, .selbank 
1645 fe 03			cp 3 
1647 cc f8 18			call z, .debug_tog 
164a fe 04			cp 4 
164c cc 46 1a			call z, .bpsgo 
164f fe 05			cp 5 
1651 cc 21 19			call z, hardware_diags 
1654			if STARTUP_V2 
1654 fe 06			cp 6 
1656 cc ac 16			call z, create_startup 
1659			endif 
1659 18 d5			jr config 
165b			 
165b			.configmn: 
165b			;	dw prom_c3 
165b 34 1c			dw prom_c2 
165d 4a 1c			dw prom_c2a 
165f			;	dw prom_c2b 
165f			;	dw prom_c4 
165f b9 1c			dw prom_m4 
1661 d4 1c			dw prom_m4b 
1663 dc 1c			dw prom_c1 
1665			if STARTUP_V2 
1665 eb 1c			dw prom_c9 
1667			endif 
1667 00 00			dw 0 
1669				 
1669			 
1669			if STARTUP_V2 
1669			.enautoload: 
1669				if STORAGE_SE 
1669 3e fe			ld a, $fe      ; bit 0 clear 
166b 32 5d fa			ld (spi_device), a 
166e			 
166e cd 17 05			call storage_get_block_0 
1671			 
1671 3e 01			ld a, 1 
1673 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
1676			 
1676 21 00 00				ld hl, 0 
1679 11 77 fa				ld de, store_page 
167c cd cb 04			call storage_write_block	 ; save update 
167f				else 
167f			 
167f				ld hl, prom_notav 
167f				ld de, prom_empty 
167f				call info_panel 
167f				endif 
167f			 
167f			 
167f c9				ret 
1680			endif 
1680			 
1680			.disautoload: 
1680				if STORAGE_SE 
1680 3e fe			ld a, $fe      ; bit 0 clear 
1682 32 5d fa			ld (spi_device), a 
1685			 
1685 cd 17 05			call storage_get_block_0 
1688			 
1688 3e 00			ld a, 0 
168a 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
168d			 
168d 21 00 00				ld hl, 0 
1690 11 77 fa				ld de, store_page 
1693 cd cb 04			call storage_write_block	 ; save update 
1696				else 
1696			 
1696				ld hl, prom_notav 
1696				ld de, prom_empty 
1696				call info_panel 
1696				endif 
1696			 
1696			 
1696 c9				ret 
1697			 
1697			if STARTUP_V1 
1697			 
1697			; Select auto start 
1697			 
1697			.selautoload: 
1697			 
1697				 
1697				if STORAGE_SE 
1697			 
1697					call config_dir 
1697				        ld hl, scratch 
1697					ld a, 0 
1697					call menu 
1697			 
1697					cp 0 
1697					ret z 
1697			 
1697					dec a 
1697			 
1697			 
1697					; locate menu option 
1697			 
1697					ld hl, scratch 
1697					call table_lookup 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALl" 
1697						CALLMONITOR 
1697					endif 
1697					; with the pointer to the menu it, the byte following the zero term is the file id 
1697			 
1697					ld a, 0 
1697					ld bc, 50   ; max of bytes to look at 
1697					cpir  
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALb" 
1697						CALLMONITOR 
1697					endif 
1697					;inc hl 
1697			 
1697					ld a, (hl)   ; file id 
1697					 
1697				        ; save bank and file ids 
1697			 
1697					push af 
1697			 
1697			; TODO need to save to block 0 on bank 1	 
1697			 
1697					call storage_get_block_0 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "AL0" 
1697						CALLMONITOR 
1697					endif 
1697					pop af 
1697			 
1697					ld (store_page+STORE_0_FILERUN),a 
1697					 
1697					; save bank id 
1697			 
1697					ld a,(spi_device) 
1697					ld (store_page+STORE_0_BANKRUN),a 
1697			 
1697					; enable auto run of store file 
1697			 
1697					ld a, 1 
1697					ld (store_page+STORE_0_AUTOFILE),a 
1697			 
1697					; save buffer 
1697			 
1697					ld hl, 0 
1697					ld de, store_page 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALw" 
1697						CALLMONITOR 
1697					endif 
1697				call storage_write_block	 ; save update 
1697			  
1697			 
1697			 
1697			 
1697					ld hl, scratch 
1697					call config_fdir 
1697			 
1697				else 
1697			 
1697				ld hl, prom_notav 
1697				ld de, prom_empty 
1697				call info_panel 
1697			 
1697				endif 
1697				ret 
1697			endif 
1697			 
1697			 
1697			; Select storage bank 
1697			 
1697			.selbank: 
1697			 
1697			;	if STORAGE_SE 
1697			;	else 
1697			 
1697 21 00 1d			ld hl, prom_notav 
169a 11 16 1d			ld de, prom_empty 
169d cd 2d 0d			call info_panel 
16a0			;	endif 
16a0				 
16a0 c9				ret 
16a1			 
16a1			if STORAGE_SE 
16a1			 
16a1			.config_ldir:   
16a1				; Load storage bank labels into menu array 
16a1			 
16a1				 
16a1			 
16a1			 
16a1 c9				ret 
16a2			 
16a2			 
16a2			endif 
16a2			 
16a2			 
16a2			; Save user words to storage 
16a2			 
16a2			.savetostore: 
16a2			 
16a2			;	if STORAGE_SE 
16a2			; 
16a2			;		call config_dir 
16a2			;	        ld hl, scratch 
16a2			;		ld a, 0 
16a2			;		call menu 
16a2			;		 
16a2			;		ld hl, scratch 
16a2			;		call config_fdir 
16a2			; 
16a2			;	else 
16a2			 
16a2 21 00 1d			ld hl, prom_notav 
16a5 11 16 1d			ld de, prom_empty 
16a8 cd 2d 0d			call info_panel 
16ab			 
16ab			;	endif 
16ab			 
16ab c9				ret 
16ac			 
16ac			if STARTUP_V2 
16ac			 
16ac			create_startup: 
16ac			 
16ac 3e 00			ld a, 0 
16ae 21 21 18			ld hl, .crstart 
16b1 cd cd 0d			call menu 
16b4			 
16b4 fe 00			cp 0 
16b6 c8				ret z 
16b7			 
16b7 fe 01			cp 1 
16b9 cc e6 16			call z, .genlsword 
16bc fe 02			cp 2 
16be cc f0 16			call z, .genedword 
16c1			 
16c1 fe 03			cp 3 
16c3 cc fa 16			call z, .gendemword 
16c6			 
16c6 fe 04			cp 4 
16c8 cc 04 17			call z, .genutlword 
16cb fe 05			cp 5 
16cd cc 0e 17			call z, .genspiword 
16d0 fe 06			cp 6 
16d2 cc 18 17			call z, .genkeyword 
16d5 fe 07			cp 7 
16d7 cc dc 16			call z, .gensoundword 
16da 18 d0			jr create_startup 
16dc			 
16dc			.gensoundword: 
16dc 21 a4 1c			ld hl, crs_sound 
16df 11 65 17			ld de, .soundworddef 
16e2 cd 22 17			call .genfile 
16e5 c9				ret 
16e6			.genlsword: 
16e6 21 61 1c			ld hl, crs_s1 
16e9 11 8d 17			ld de, .lsworddef 
16ec cd 22 17			call .genfile 
16ef c9				ret 
16f0			 
16f0			.genedword: 
16f0 11 91 17			ld de, .edworddef 
16f3 21 6a 1c			ld hl, crs_s2 
16f6 cd 22 17			call .genfile 
16f9 c9				ret 
16fa			 
16fa			.gendemword: 
16fa 11 99 17			ld de, .demoworddef 
16fd 21 73 1c			ld hl, crs_s3 
1700 cd 22 17			call .genfile 
1703 c9				ret 
1704			 
1704			.genutlword: 
1704 21 82 1c			ld hl, crs_s4 
1707 11 79 17			ld de, .utilwordef 
170a cd 22 17			call .genfile 
170d c9				ret 
170e			.genspiword: 
170e 21 89 1c			ld hl, crs_s5 
1711 11 df 17			ld de, .spiworddef 
1714 cd 22 17			call .genfile 
1717 c9				ret 
1718			.genkeyword: 
1718 21 95 1c			ld hl, crs_s6 
171b 11 f5 17			ld de, .keyworddef 
171e cd 22 17			call .genfile 
1721 c9				ret 
1722			 
1722			; hl - points to file name 
1722			; de - points to strings to add to file 
1722			 
1722			.genfile: 
1722 e5				push hl 
1723 d5				push de 
1724			 
1724 cd 9c 0d			call clear_display 
1727 3e 00			ld a, display_row_1 
1729 11 54 17			ld de, .genfiletxt 
172c cd af 0d			call str_at_display 
172f cd bf 0d			call update_display 
1732			 
1732 d1				pop de 
1733 e1				pop hl 
1734			 
1734			 
1734 d5				push de 
1735 cd 69 08			call storage_create 
1738				; id in hl 
1738 d1				pop de   ; table of strings to add 
1739			 
1739			.genloop: 
1739			 
1739 e5				push hl ; save id for next time around 
173a d5				push de ; save de for next time around 
173b			 
173b eb				ex de, hl 
173c cd 42 24			call loadwordinhl 
173f eb				ex de, hl 
1740			 
1740				; need hl to be the id 
1740				; need de to be the string ptr 
1740				 
1740 cd 56 0b			call storage_append 
1743			 
1743 d1				pop de 
1744 e1				pop hl 
1745			 
1745 13				inc de 
1746 13				inc de 
1747			 
1747 1a				ld a,(de) 
1748 fe 00			cp 0 
174a 20 ed			jr nz, .genloop 
174c 13				inc de 
174d 1a				ld a, (de) 
174e 1b				dec de 
174f fe 00			cp 0 
1751 20 e6			jr nz, .genloop	 
1753			 
1753 c9				ret 
1754			 
1754 .. 00		.genfiletxt:  db "Creating file...",0 
1765			 
1765			.soundworddef: 
1765 c0 69			dw sound1 
1767 e4 69			dw sound2 
1769 14 6a			dw sound3 
176b 39 6a			dw sound4 
176d 46 6a			dw sound5 
176f 53 6a			dw sound6 
1771 60 6a			dw sound7 
1773 6d 6a			dw sound8 
1775 85 6a			dw sound9 
1777 00 00			dw 0 
1779			 
1779			.utilwordef: 
1779 11 63			dw strncpy 
177b ec 62			dw type 
177d b8 62			dw clrstack 
177f 71 62			dw longread 
1781 72 63			dw start1 
1783 82 63			dw start2 
1785 93 63			dw start3b 
1787 0e 64			dw start3c 
1789 6e 64			dw list 
178b 00 00			dw 0 
178d			 
178d			.lsworddef: 
178d 93 63			dw start3b 
178f 00 00			dw 0 
1791			 
1791			.edworddef: 
1791 fa 5e			dw edit1 
1793 1b 5f			dw edit2 
1795 50 5f			dw edit3 
1797 00 00			dw 0 
1799			 
1799			.demoworddef: 
1799 b6 68			dw test5 
179b ee 68			dw test6 
179d 26 69			dw test7 
179f 3a 69			dw test8 
17a1 66 69			dw test9 
17a3 7c 69			dw test10 
17a5 9c 6a			dw game1 
17a7 ad 6a			dw game1a 
17a9 0f 6b			dw game1b 
17ab 44 6b			dw game1c 
17ad 7a 6b			dw game1d 
17af ab 6b			dw game1s 
17b1 bf 6b			dw game1t 
17b3 d4 6b			dw game1f 
17b5 08 6c			dw game1z 
17b7 4c 6c			dw game1zz 
17b9 b5 6c			dw ssv2 
17bb eb 6c			dw ssv3 
17bd 07 6d			dw ssv4 
17bf 23 6d			dw ssv5 
17c1 3c 6d			dw ssv1 
17c3 84 6d			dw ssv1cpm	 
17c5 db 6d			dw game2b 
17c7 49 6e			dw game2bf 
17c9 93 6e			dw game2mba 
17cb 29 6f			dw game2mbas	 
17cd 4e 6f			dw game2mbht 
17cf 5d 6f			dw game2mbms 
17d1 6b 6f			dw game2mb 
17d3 e8 6f			dw game3w 
17d5 16 70			dw game3p 
17d7 34 70			dw game3sc 
17d9 65 70			dw game3vsi 
17db 91 70			dw game3vs 
17dd 00 00			dw 0 
17df			 
17df			 
17df			.spiworddef: 
17df			 
17df 88 5f		    dw spi1 
17e1 e1 5f		    dw spi2 
17e3 6f 60		    dw spi3 
17e5 17 60		    dw spi4 
17e7 42 60		    dw spi5 
17e9 d5 60		    dw spi6 
17eb 2a 61		    dw spi7 
17ed			 
17ed 82 61		    dw spi8 
17ef a1 61		    dw spi9 
17f1 f9 61		    dw spi10 
17f3 00 00		    dw 0 
17f5			 
17f5			.keyworddef: 
17f5			 
17f5 d0 70			dw keyup 
17f7 de 70			dw keydown 
17f9 ee 70			dw keyleft 
17fb fe 70			dw keyright 
17fd 0f 71			dw 	keyf1 
17ff 1d 71			dw keyf2 
1801 2b 71			dw keyf3 
1803 39 71			dw keyf4 
1805 47 71			dw keyf5 
1807 55 71			dw keyf6 
1809 63 71			dw keyf7 
180b 71 71			dw keyf8 
180d 7f 71			dw keyf9 
180f 8d 71			dw keyf10 
1811 9c 71			dw keyf11 
1813 ab 71			dw keyf12 
1815 ba 71			dw keytab 
1817 c9 71			dw keycr 
1819 d7 71			dw keyhome 
181b e7 71			dw keyend 
181d f6 71			dw keybs 
181f 00 00			dw 0 
1821			 
1821			.crstart: 
1821 61 1c			dw crs_s1 
1823 6a 1c			dw crs_s2 
1825 73 1c			dw crs_s3 
1827 82 1c			dw crs_s4 
1829 89 1c			dw crs_s5 
182b 95 1c			dw crs_s6 
182d 00 00			dw 0 
182f			 
182f			endif 
182f			 
182f			 
182f			if STORAGE_SE 
182f			 
182f			config_fdir: 
182f				; using the scratch dir go through and release the memory allocated for each string 
182f				 
182f 21 be f1			ld hl, scratch 
1832 5e			.cfdir:	ld e,(hl) 
1833 23				inc hl 
1834 56				ld d,(hl) 
1835 23				inc hl 
1836			 
1836 eb				ex de, hl 
1837 cd f9 0f			call ishlzero 
183a c8				ret z     ; return on null pointer 
183b cd 61 15			call free 
183e eb				ex de, hl 
183f 18 f1			jr .cfdir 
1841			 
1841			 
1841 c9				ret 
1842			 
1842			 
1842			config_dir: 
1842			 
1842				; for the config menus that need to build a directory of storage call this routine 
1842				; it will construct a menu in scratch to pass to menu 
1842			 
1842				; open storage device 
1842			 
1842				; execute DIR to build a list of files and their ids into scratch in menu format 
1842				; once the menu has finished then will need to call config_fdir to release the strings 
1842				 
1842				; c = number items 
1842			 
1842				 
1842 cd 17 05			call storage_get_block_0 
1845			 
1845 21 77 fa			ld hl, store_page     ; get current id count 
1848 46				ld b, (hl) 
1849 0e 00			ld c, 0    ; count of files   
184b			 
184b			 
184b 21 be f1			ld hl, scratch 
184e 22 6e fa			ld (store_tmp2), hl    ; location to poke strings 
1851			 
1851				; check for empty drive 
1851			 
1851 3e 00			ld a, 0 
1853 b8				cp b 
1854 ca ee 18			jp z, .dirdone 
1857			 
1857				 
1857					if DEBUG_FORTH_WORDS 
1857						DMARK "Cdc" 
1857 f5				push af  
1858 3a 6c 18			ld a, (.dmark)  
185b 32 68 fe			ld (debug_mark),a  
185e 3a 6d 18			ld a, (.dmark+1)  
1861 32 69 fe			ld (debug_mark+1),a  
1864 3a 6e 18			ld a, (.dmark+2)  
1867 32 6a fe			ld (debug_mark+2),a  
186a 18 03			jr .pastdmark  
186c ..			.dmark: db "Cdc"  
186f f1			.pastdmark: pop af  
1870			endm  
# End of macro DMARK
1870						CALLMONITOR 
1870 cd 6c fe			call debug_vector  
1873				endm  
# End of macro CALLMONITOR
1873					endif 
1873			 
1873			 
1873			.diritem:	 
1873 c5				push bc 
1874				; for each of the current ids do a search for them and if found push to stack 
1874			 
1874 21 40 00				ld hl, STORE_BLOCK_PHY 
1877 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1879 58					ld e,b 
187a			 
187a cd 99 07				call storage_findnextid 
187d			 
187d			 
187d					; if found hl will be non zero 
187d			 
187d cd f9 0f				call ishlzero 
1880 28 69				jr z, .dirnotfound 
1882			 
1882					; increase count 
1882			 
1882 c1					pop bc	 
1883 0c					inc c 
1884 c5					push bc 
1885					 
1885			 
1885					; get file header and push the file name 
1885			 
1885 11 77 fa				ld de, store_page 
1888 cd 66 04				call storage_read_block 
188b			 
188b					; push file id to stack 
188b				 
188b 3a 77 fa				ld a, (store_page) 
188e 26 00				ld h, 0 
1890 6f					ld l, a 
1891			 
1891					;call forth_push_numhl 
1891					; TODO store id 
1891			 
1891 e5					push hl 
1892			 
1892					; push extent count to stack  
1892				 
1892 21 7a fa				ld hl, store_page+3 
1895			 
1895					; get file name length 
1895			 
1895 cd 2e 14				call strlenz   
1898			 
1898 23					inc hl   ; cover zero term 
1899 23					inc hl  ; stick the id at the end of the area 
189a			 
189a e5					push hl 
189b c1					pop bc    ; move length to bc 
189c			 
189c cd 97 14				call malloc 
189f			 
189f					; TODO save malloc area to scratch 
189f			 
189f eb					ex de, hl 
18a0 2a 6e fa				ld hl, (store_tmp2) 
18a3 73					ld (hl), e 
18a4 23					inc hl 
18a5 72					ld (hl), d 
18a6 23					inc hl 
18a7 22 6e fa				ld (store_tmp2), hl 
18aa			 
18aa					 
18aa			 
18aa					;pop hl   ; get source 
18aa			;		ex de, hl    ; swap aronund	 
18aa			 
18aa 21 7a fa				ld hl, store_page+3 
18ad					if DEBUG_FORTH_WORDS 
18ad						DMARK "CFd" 
18ad f5				push af  
18ae 3a c2 18			ld a, (.dmark)  
18b1 32 68 fe			ld (debug_mark),a  
18b4 3a c3 18			ld a, (.dmark+1)  
18b7 32 69 fe			ld (debug_mark+1),a  
18ba 3a c4 18			ld a, (.dmark+2)  
18bd 32 6a fe			ld (debug_mark+2),a  
18c0 18 03			jr .pastdmark  
18c2 ..			.dmark: db "CFd"  
18c5 f1			.pastdmark: pop af  
18c6			endm  
# End of macro DMARK
18c6						CALLMONITOR 
18c6 cd 6c fe			call debug_vector  
18c9				endm  
# End of macro CALLMONITOR
18c9					endif 
18c9 ed b0				ldir 
18cb			 
18cb					; de is past string, move back one and store id 
18cb					 
18cb 1b					dec de 
18cc			 
18cc					; store file id 
18cc			 
18cc e1					pop hl 
18cd eb					ex de,hl 
18ce 73					ld (hl), e 
18cf			 
18cf					if DEBUG_FORTH_WORDS 
18cf						DMARK "Cdi" 
18cf f5				push af  
18d0 3a e4 18			ld a, (.dmark)  
18d3 32 68 fe			ld (debug_mark),a  
18d6 3a e5 18			ld a, (.dmark+1)  
18d9 32 69 fe			ld (debug_mark+1),a  
18dc 3a e6 18			ld a, (.dmark+2)  
18df 32 6a fe			ld (debug_mark+2),a  
18e2 18 03			jr .pastdmark  
18e4 ..			.dmark: db "Cdi"  
18e7 f1			.pastdmark: pop af  
18e8			endm  
# End of macro DMARK
18e8						CALLMONITOR 
18e8 cd 6c fe			call debug_vector  
18eb				endm  
# End of macro CALLMONITOR
18eb					endif 
18eb					 
18eb			.dirnotfound: 
18eb c1					pop bc     
18ec 10 85				djnz .diritem 
18ee				 
18ee			.dirdone:	 
18ee			 
18ee 3e 00				ld a, 0 
18f0 2a 6e fa				ld hl, (store_tmp2) 
18f3 77					ld (hl), a 
18f4 23					inc hl 
18f5 77					ld (hl), a 
18f6 23					inc hl 
18f7					; push a count of the dir items found 
18f7			 
18f7			;		ld h, 0 
18f7			;		ld l, c 
18f7			 
18f7 c9				ret 
18f8			 
18f8			endif 
18f8			 
18f8			 
18f8			; Settings 
18f8			; Run  
18f8			 
18f8			 
18f8			 
18f8			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18f8			;;hd_menu2:   db "        2: Editor",0   
18f8			;hd_menu2:   db "        2: Editor       6: Menu",0   
18f8			;hd_menu3:   db "        3: Storage",0 
18f8			;hd_menu4:   db "0=quit  4: Debug",0 
18f8			;hd_don:     db "ON",0 
18f8			;hd_doff:     db "OFF",0 
18f8			; 
18f8			; 
18f8			; 
18f8			;hardware_diags_old:       
18f8			; 
18f8			;.diagmenu: 
18f8			;	call clear_display 
18f8			;	ld a, display_row_1 
18f8			;	ld de, hd_menu1 
18f8			;	call str_at_display 
18f8			; 
18f8			;	ld a, display_row_2 
18f8			;	ld de, hd_menu2 
18f8			;	call str_at_display 
18f8			; 
18f8			;	ld a, display_row_3 
18f8			;	ld de, hd_menu3 
18f8			;	call str_at_display 
18f8			; 
18f8			;	ld a,  display_row_4 
18f8			;	ld de, hd_menu4 
18f8			;	call str_at_display 
18f8			; 
18f8			;	; display debug state 
18f8			; 
18f8			;	ld de, hd_don 
18f8			;	ld a, (os_view_disable) 
18f8			;	cp 0 
18f8			;	jr z, .distog 
18f8			;	ld de, hd_doff 
18f8			;.distog: ld a, display_row_4+17 
18f8			;	call str_at_display 
18f8			; 
18f8			;	call update_display 
18f8			; 
18f8			;	call cin_wait 
18f8			; 
18f8			; 
18f8			; 
18f8			;	cp '4' 
18f8			;	jr nz, .diagn1 
18f8			; 
18f8			;	; debug toggle 
18f8			; 
18f8			;	ld a, (os_view_disable) 
18f8			;	ld b, '*' 
18f8			;	cp 0 
18f8			;	jr z, .debtog 
18f8			;	ld b, 0 
18f8			;.debtog:	 
18f8			;	ld a,b 
18f8			;	ld (os_view_disable),a 
18f8			; 
18f8			;.diagn1: cp '0' 
18f8			;	 ret z 
18f8			; 
18f8			;;	cp '1' 
18f8			;;       jp z, matrix	 
18f8			;;   TODO keyboard matrix test 
18f8			; 
18f8			;	cp '2' 
18f8			;	jp z, .diagedit 
18f8			; 
18f8			;;	cp '6' 
18f8			;;	jp z, .menutest 
18f8			;;if ENABLE_BASIC 
18f8			;;	cp '6' 
18f8			;;	jp z, basic 
18f8			;;endif 
18f8			 ; 
18f8			;	jp .diagmenu 
18f8			; 
18f8			; 
18f8			;	ret 
18f8			 
18f8			 
18f8			.debug_tog: 
18f8 21 42 19			ld hl, .menudebug 
18fb				 
18fb			;	ld a, (os_view_disable) 
18fb			;	cp '*' 
18fb 3a 6c fe			ld a,(debug_vector) 
18fe fe c9			cp $C9   ; RET 
1900 20 04			jr nz,.tdon  
1902 3e 01			ld a, 1 
1904 18 02			jr .tog1 
1906 3e 00		.tdon: ld a, 0 
1908			 
1908			.tog1: 
1908 cd cd 0d			call menu 
190b fe 00			cp 0 
190d c8				ret z 
190e fe 01			cp 1    ; disable debug 
1910 28 04			jr z, .dtog0 
1912 3e 2a			ld a, '*' 
1914 18 05			jr .dtogset 
1916			.dtog0:  
1916				;ld a, 0 
1916 cd 34 1a			call bp_on 
1919 18 dd			jr .debug_tog 
191b			.dtogset:  
191b				; ld (os_view_disable), a 
191b cd 40 1a			call bp_off 
191e c3 f8 18			jp .debug_tog 
1921			 
1921			 
1921			hardware_diags:       
1921			 
1921			.diagm: 
1921 21 34 19			ld hl, .menuitems 
1924 3e 00			ld a, 0 
1926 cd cd 0d			call menu 
1929			 
1929 fe 00		         cp 0 
192b c8				 ret z 
192c			 
192c fe 02			cp 2 
192e ca 8d 19			jp z, .diagedit 
1931			 
1931			;	cp '6' 
1931			;	jp z, .menutest 
1931			;if ENABLE_BASIC 
1931			;	cp '6' 
1931			;	jp z, basic 
1931			;endif 
1931			  
1931 c3 21 19			jp .diagm 
1934			 
1934				 
1934 48 19		.menuitems:   	dw .m1 
1936 53 19				dw .m2 
1938 5a 19				dw .m3 
193a 62 19				dw .m5 
193c 68 19				dw .m5a 
193e 71 19				dw .m5b 
1940 00 00				dw 0 
1942			 
1942			.menudebug: 
1942 7a 19				dw .m6 
1944 83 19				dw .m7 
1946 00 00				dw 0 
1948			 
1948 .. 00		.m1:   db "Key Matrix",0 
1953 .. 00		.m2:   db "Editor",0 
195a .. 00		.m3:   db "Storage",0 
1962 .. 00		.m5:   db "Sound",0 
1968 .. 00		.m5a:  db "RAM Test",0 
1971 .. 00		.m5b:  db "LCD Test",0 
197a			 
197a .. 00		.m6:   db "Debug ON",0 
1983 .. 00		.m7:   db "Debug OFF",0 
198d			 
198d			; debug editor 
198d			 
198d			.diagedit: 
198d			 
198d 21 be f1			ld hl, scratch 
1990			;	ld bc, 250 
1990			;	ldir 
1990				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1990 3e 00			ld a, 0 
1992 77				ld (hl), a 
1993 23				inc hl 
1994 77				ld (hl), a 
1995 23				inc hl 
1996 77				ld (hl), a 
1997			 
1997 cd 9c 0d		        call clear_display 
199a cd bf 0d			call update_display 
199d				;ld a, 1 
199d				;ld (hardware_diag), a 
199d			.diloop: 
199d 3e 00			ld a, display_row_1 
199f 0e 00			ld c, 0 
19a1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19a3 1e 28			ld e, 40 
19a5			 
19a5 21 be f1			ld hl, scratch	 
19a8 cd fd 0f			call input_str 
19ab			 
19ab 3e 28			ld a, display_row_2 
19ad 11 be f1			ld de, scratch 
19b0 cd af 0d			call str_at_display 
19b3 cd bf 0d			call update_display 
19b6			 
19b6 c3 9d 19			jp .diloop 
19b9			 
19b9			 
19b9			; pass word in hl 
19b9			; a has display location 
19b9			display_word_at: 
19b9 f5				push af 
19ba e5				push hl 
19bb 7c				ld a,h 
19bc 21 c3 f4			ld hl, os_word_scratch 
19bf cd d1 12			call hexout 
19c2 e1				pop hl 
19c3 7d				ld a,l 
19c4 21 c5 f4			ld hl, os_word_scratch+2 
19c7 cd d1 12			call hexout 
19ca 21 c7 f4			ld hl, os_word_scratch+4 
19cd 3e 00			ld a,0 
19cf 77				ld (hl),a 
19d0 11 c3 f4			ld de,os_word_scratch 
19d3 f1				pop af 
19d4 cd af 0d				call str_at_display 
19d7 c9				ret 
19d8			 
19d8			display_ptr_state: 
19d8			 
19d8				; to restore afterwards 
19d8			 
19d8 d5				push de 
19d9 c5				push bc 
19da e5				push hl 
19db f5				push af 
19dc			 
19dc				; for use in here 
19dc			 
19dc			;	push bc 
19dc			;	push de 
19dc			;	push hl 
19dc			;	push af 
19dc			 
19dc cd 9c 0d			call clear_display 
19df			 
19df 11 b7 1b			ld de, .ptrstate 
19e2 3e 00			ld a, display_row_1 
19e4 cd af 0d			call str_at_display 
19e7			 
19e7				; display debug step 
19e7			 
19e7			 
19e7 11 68 fe			ld de, debug_mark 
19ea 3e 26			ld a, display_row_1+display_cols-2 
19ec cd af 0d			call str_at_display 
19ef			 
19ef				; display a 
19ef 11 c1 1b			ld de, .ptrcliptr 
19f2 3e 28			ld a, display_row_2 
19f4 cd af 0d			call str_at_display 
19f7			 
19f7 f1				pop af 
19f8 2a 3d fa			ld hl,(cli_ptr) 
19fb 3e 30			ld a, display_row_2+8 
19fd cd b9 19			call display_word_at 
1a00			 
1a00			 
1a00				; display hl 
1a00			 
1a00			 
1a00 11 c9 1b			ld de, .ptrclioptr 
1a03 3e 32			ld a, display_row_2+10 
1a05 cd af 0d			call str_at_display 
1a08			; 
1a08			;	pop hl 
1a08 3e 35			ld a, display_row_2+13 
1a0a 2a 3b fa			ld hl,(cli_origptr) 
1a0d cd b9 19			call display_word_at 
1a10			; 
1a10			;	 
1a10			;	; display de 
1a10			 
1a10			;	ld de, .regstatede 
1a10			;	ld a, display_row_3 
1a10			;	call str_at_display 
1a10			 
1a10			;	pop de 
1a10			;	ld h,d 
1a10			;	ld l, e 
1a10			;	ld a, display_row_3+3 
1a10			;	call display_word_at 
1a10			 
1a10			 
1a10				; display bc 
1a10			 
1a10			;	ld de, .regstatebc 
1a10			;	ld a, display_row_3+10 
1a10			;	call str_at_display 
1a10			 
1a10			;	pop bc 
1a10			;	ld h,b 
1a10			;	ld l, c 
1a10			;	ld a, display_row_3+13 
1a10			;	call display_word_at 
1a10			 
1a10			 
1a10				; display dsp 
1a10			 
1a10			;	ld de, .regstatedsp 
1a10			;	ld a, display_row_4 
1a10			;	call str_at_display 
1a10			 
1a10				 
1a10			;	ld hl,(cli_data_sp) 
1a10			;	ld a, display_row_4+4 
1a10			;	call display_word_at 
1a10			 
1a10				; display rsp 
1a10			 
1a10 11 f8 1b			ld de, .regstatersp 
1a13 3e 82			ld a, display_row_4+10 
1a15 cd af 0d			call str_at_display 
1a18			 
1a18				 
1a18 2a ef f9			ld hl,(cli_ret_sp) 
1a1b 3e 86			ld a, display_row_4+14 
1a1d cd b9 19			call display_word_at 
1a20			 
1a20 cd bf 0d			call update_display 
1a23			 
1a23 cd df 0c			call delay1s 
1a26 cd df 0c			call delay1s 
1a29 cd df 0c			call delay1s 
1a2c			 
1a2c			 
1a2c cd 8b 20			call next_page_prompt 
1a2f			 
1a2f				; restore  
1a2f			 
1a2f f1				pop af 
1a30 e1				pop hl 
1a31 c1				pop bc 
1a32 d1				pop de 
1a33 c9				ret 
1a34			 
1a34			; Update the break point vector so that the user can hook a new routine 
1a34			 
1a34			bp_on: 
1a34 3e c3			ld a, $c3    ; JP 
1a36 32 6c fe			ld (debug_vector), a 
1a39 21 46 1a			ld hl, break_point_state 
1a3c 22 6d fe			ld (debug_vector+1), hl 
1a3f c9				ret 
1a40			 
1a40			bp_off: 
1a40 3e c9			ld a, $c9    ; RET 
1a42 32 6c fe			ld (debug_vector), a 
1a45 c9				ret 
1a46			 
1a46			 
1a46			break_point_state: 
1a46			;	push af 
1a46			; 
1a46			;	; see if disabled 
1a46			; 
1a46			;	ld a, (os_view_disable) 
1a46			;	cp '*' 
1a46			;	jr nz, .bpsgo 
1a46			;	pop af 
1a46			;	ret 
1a46			 
1a46			.bpsgo: 
1a46			;	pop af 
1a46 f5				push af 
1a47 22 ac f1			ld (os_view_hl), hl 
1a4a ed 53 aa f1		ld (os_view_de), de 
1a4e ed 43 a8 f1		ld (os_view_bc), bc 
1a52 e5				push hl 
1a53 6f				ld l, a 
1a54 26 00			ld h, 0 
1a56 22 ae f1			ld (os_view_af),hl 
1a59			 
1a59 21 ae fd				ld hl, display_fb0 
1a5c 22 c9 fb				ld (display_fb_active), hl 
1a5f e1				pop hl	 
1a60			 
1a60 3e 31			ld a, '1' 
1a62 fe 2a		.bps1:  cp '*' 
1a64 cc 40 1a			call z, bp_off 
1a67			;	jr nz, .bps1b 
1a67			;	ld (os_view_disable),a 
1a67 fe 31		.bps1b:  cp '1' 
1a69 20 14			jr nz, .bps2 
1a6b			 
1a6b				; display reg 
1a6b			 
1a6b				 
1a6b			 
1a6b 3a ae f1			ld a, (os_view_af) 
1a6e 2a ac f1			ld hl, (os_view_hl) 
1a71 ed 5b aa f1		ld de, (os_view_de) 
1a75 ed 4b a8 f1		ld bc, (os_view_bc) 
1a79 cd 13 1b			call display_reg_state 
1a7c c3 ff 1a			jp .bpschk 
1a7f			 
1a7f fe 32		.bps2:  cp '2' 
1a81 20 08			jr nz, .bps3 
1a83				 
1a83				; display hl 
1a83 2a ac f1			ld hl, (os_view_hl) 
1a86 cd fd 1b			call display_dump_at_hl 
1a89			 
1a89 18 74			jr .bpschk 
1a8b			 
1a8b fe 33		.bps3:  cp '3' 
1a8d 20 08			jr nz, .bps4 
1a8f			 
1a8f			        ; display de 
1a8f 2a aa f1			ld hl, (os_view_de) 
1a92 cd fd 1b			call display_dump_at_hl 
1a95			 
1a95 18 68			jr .bpschk 
1a97 fe 34		.bps4:  cp '4' 
1a99 20 08			jr nz, .bps5 
1a9b			 
1a9b			        ; display bc 
1a9b 2a a8 f1			ld hl, (os_view_bc) 
1a9e cd fd 1b			call display_dump_at_hl 
1aa1			 
1aa1 18 5c			jr .bpschk 
1aa3 fe 35		.bps5:  cp '5' 
1aa5 20 08		        jr nz, .bps7 
1aa7			 
1aa7				; display cur ptr 
1aa7 2a 3d fa			ld hl, (cli_ptr) 
1aaa cd fd 1b			call display_dump_at_hl 
1aad			 
1aad 18 50			jr .bpschk 
1aaf fe 36		.bps7:  cp '6' 
1ab1 20 08			jr nz, .bps8b 
1ab3				 
1ab3				; display cur orig ptr 
1ab3 2a 3b fa			ld hl, (cli_origptr) 
1ab6 cd fd 1b			call display_dump_at_hl 
1ab9 18 44			jr .bpschk 
1abb fe 37		.bps8b:  cp '7' 
1abd 20 08			jr nz, .bps9 
1abf				 
1abf				; display dsp 
1abf 2a eb f9			ld hl, (cli_data_sp) 
1ac2 cd fd 1b			call display_dump_at_hl 
1ac5			 
1ac5 18 38			jr .bpschk 
1ac7 fe 39		.bps9:  cp '9' 
1ac9 20 05			jr nz, .bps8c 
1acb				 
1acb				; display SP 
1acb			;	ld hl, sp 
1acb cd fd 1b			call display_dump_at_hl 
1ace			 
1ace 18 2f			jr .bpschk 
1ad0 fe 38		.bps8c:  cp '8' 
1ad2 20 08			jr nz, .bps8d 
1ad4				 
1ad4				; display rsp 
1ad4 2a ef f9			ld hl, (cli_ret_sp) 
1ad7 cd fd 1b			call display_dump_at_hl 
1ada			 
1ada 18 23			jr .bpschk 
1adc fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1ade 20 05			jr nz, .bps8 
1ae0 cd 59 1e			call monitor 
1ae3			 
1ae3 18 1a			jr .bpschk 
1ae5 fe 30		.bps8:  cp '0' 
1ae7 20 16			jr nz, .bpschk 
1ae9			 
1ae9 21 0d fd				ld hl, display_fb1 
1aec 22 c9 fb				ld (display_fb_active), hl 
1aef cd bf 0d				call update_display 
1af2			 
1af2				;ld a, (os_view_af) 
1af2 2a ac f1			ld hl, (os_view_hl) 
1af5 ed 5b aa f1		ld de, (os_view_de) 
1af9 ed 4b a8 f1		ld bc, (os_view_bc) 
1afd f1				pop af 
1afe c9				ret 
1aff			 
1aff			.bpschk:   
1aff cd df 0c			call delay1s 
1b02 3e 9f		ld a,display_row_4 + display_cols - 1 
1b04 11 89 20		        ld de, endprg 
1b07 cd af 0d			call str_at_display 
1b0a cd bf 0d			call update_display 
1b0d cd 71 79			call cin_wait 
1b10			 
1b10 c3 62 1a			jp .bps1 
1b13			 
1b13			 
1b13			display_reg_state: 
1b13			 
1b13				; to restore afterwards 
1b13			 
1b13 d5				push de 
1b14 c5				push bc 
1b15 e5				push hl 
1b16 f5				push af 
1b17			 
1b17				; for use in here 
1b17			 
1b17 c5				push bc 
1b18 d5				push de 
1b19 e5				push hl 
1b1a f5				push af 
1b1b			 
1b1b cd 9c 0d			call clear_display 
1b1e			 
1b1e 11 d3 1b			ld de, .regstate 
1b21 3e 00			ld a, display_row_1 
1b23 cd af 0d			call str_at_display 
1b26			 
1b26				; display debug step 
1b26			 
1b26			 
1b26 11 68 fe			ld de, debug_mark 
1b29 3e 25			ld a, display_row_1+display_cols-3 
1b2b cd af 0d			call str_at_display 
1b2e			 
1b2e				; display a 
1b2e 11 ef 1b			ld de, .regstatea 
1b31 3e 28			ld a, display_row_2 
1b33 cd af 0d			call str_at_display 
1b36			 
1b36 e1				pop hl 
1b37			;	ld h,0 
1b37			;	ld l, a 
1b37 3e 2b			ld a, display_row_2+3 
1b39 cd b9 19			call display_word_at 
1b3c			 
1b3c			 
1b3c				; display hl 
1b3c			 
1b3c			 
1b3c 11 e3 1b			ld de, .regstatehl 
1b3f 3e 32			ld a, display_row_2+10 
1b41 cd af 0d			call str_at_display 
1b44			 
1b44 e1				pop hl 
1b45 3e 35			ld a, display_row_2+13 
1b47 cd b9 19			call display_word_at 
1b4a			 
1b4a				 
1b4a				; display de 
1b4a			 
1b4a 11 e7 1b			ld de, .regstatede 
1b4d 3e 50			ld a, display_row_3 
1b4f cd af 0d			call str_at_display 
1b52			 
1b52 e1				pop hl 
1b53			;	ld h,d 
1b53			;	ld l, e 
1b53 3e 53			ld a, display_row_3+3 
1b55 cd b9 19			call display_word_at 
1b58			 
1b58			 
1b58				; display bc 
1b58			 
1b58 11 eb 1b			ld de, .regstatebc 
1b5b 3e 5a			ld a, display_row_3+10 
1b5d cd af 0d			call str_at_display 
1b60			 
1b60 e1				pop hl 
1b61			;	ld h,b 
1b61			;	ld l, c 
1b61 3e 5d			ld a, display_row_3+13 
1b63 cd b9 19			call display_word_at 
1b66			 
1b66			 
1b66				; display dsp 
1b66			 
1b66 11 f3 1b			ld de, .regstatedsp 
1b69 3e 78			ld a, display_row_4 
1b6b cd af 0d			call str_at_display 
1b6e			 
1b6e				 
1b6e 2a eb f9			ld hl,(cli_data_sp) 
1b71 3e 7c			ld a, display_row_4+4 
1b73 cd b9 19			call display_word_at 
1b76			 
1b76				; display rsp 
1b76			 
1b76 11 f8 1b			ld de, .regstatersp 
1b79 3e 82			ld a, display_row_4+10 
1b7b cd af 0d			call str_at_display 
1b7e			 
1b7e				 
1b7e 2a ef f9			ld hl,(cli_ret_sp) 
1b81 3e 86			ld a, display_row_4+14 
1b83 cd b9 19			call display_word_at 
1b86			 
1b86 cd bf 0d			call update_display 
1b89			 
1b89			;	call delay1s 
1b89			;	call delay1s 
1b89			;	call delay1s 
1b89			 
1b89			 
1b89			;	call next_page_prompt 
1b89			 
1b89				; restore  
1b89			 
1b89 f1				pop af 
1b8a e1				pop hl 
1b8b c1				pop bc 
1b8c d1				pop de 
1b8d c9				ret 
1b8e			 
1b8e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ba2 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1bb7 .. 00		.ptrstate:	db "Ptr State",0 
1bc1 .. 00		.ptrcliptr:     db "cli_ptr",0 
1bc9 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1bd3 .. 00		.regstate:	db "Reg State (1/0)",0 
1be3 .. 00		.regstatehl:	db "HL:",0 
1be7 .. 00		.regstatede:	db "DE:",0 
1beb .. 00		.regstatebc:	db "BC:",0 
1bef .. 00		.regstatea:	db "A :",0 
1bf3 .. 00		.regstatedsp:	db "DSP:",0 
1bf8 .. 00		.regstatersp:	db "RSP:",0 
1bfd			 
1bfd			display_dump_at_hl: 
1bfd e5				push hl 
1bfe d5				push de 
1bff c5				push bc 
1c00 f5				push af 
1c01			 
1c01 22 e1 f4			ld (os_cur_ptr),hl	 
1c04 cd 9c 0d			call clear_display 
1c07 cd 93 1f			call dumpcont 
1c0a			;	call delay1s 
1c0a			;	call next_page_prompt 
1c0a			 
1c0a			 
1c0a f1				pop af 
1c0b c1				pop bc 
1c0c d1				pop de 
1c0d e1				pop hl 
1c0e c9				ret 
1c0f			 
1c0f			;if ENABLE_BASIC 
1c0f			;	include "nascombasic.asm" 
1c0f			;	basic: 
1c0f			;	include "forth/FORTH.ASM" 
1c0f			;endif 
1c0f			 
1c0f			; eof 
1c0f			 
1c0f			 
# End of file firmware_diags.asm
1c0f			  
1c0f			include "firmware_prompts.asm"  
1c0f			; Prompts  
1c0f			 
1c0f			; boot messages 
1c0f			 
1c0f .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1c24 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1c34			 
1c34			 
1c34			; config menus 
1c34			 
1c34			;prom_c3: db "Add Dictionary To File",0 
1c34			 
1c34			if STARTUP_V1 
1c34			prom_c2: db "Select Autoload File",0 
1c34			prom_c2a: db "Disable Autoload File", 0 
1c34			endif 
1c34			 
1c34			if STARTUP_V2 
1c34 .. 00		prom_c2: db "Enable Autoload Files",0 
1c4a .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c61			 
1c61 .. 00		crs_s1: db "*ls-word", 0 
1c6a .. 00		crs_s2: db "*ed-word", 0 
1c73 .. 00		crs_s3: db "*Demo-Programs", 0 
1c82 .. 00		crs_s4: db "*Utils", 0 
1c89 .. 00		crs_s5: db "*SPI-Addons", 0 
1c95 .. 00		crs_s6: db "*Key-constants", 0 
1ca4 .. 00		crs_sound: db "*Sound-Util", 0 
1cb0			 
1cb0			 
1cb0			 
1cb0			endif 
1cb0			;prom_c2b: db "Select Storage Bank",0 
1cb0 .. 00		prom_c4: db "Settings",0 
1cb9 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cd4 .. 00		prom_m4b:   db "Monitor",0 
1cdc .. 00		prom_c1: db "Hardware Diags",0 
1ceb			 
1ceb			 
1ceb			if STARTUP_V2 
1ceb .. 00		prom_c9: db "Create Startup Files",0 
1d00			endif 
1d00			 
1d00 .. 00		prom_notav:    db "Feature not available",0 
1d16 .. 00		prom_empty:    db "",0 
1d17			 
1d17			; eof 
1d17			 
# End of file firmware_prompts.asm
1d17			  
1d17			  
1d17			; eof  
1d17			  
# End of file firmware.asm
1d17			 
1d17			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1d17			;if BASE_KEV  
1d17			;baseram: equ 08000h 
1d17			;endif 
1d17			 
1d17			;if BASE_SC114 
1d17			;baseram:     equ    endofcode 
1d17			;endif 
1d17			 
1d17			 
1d17			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1d17			 
1d17			; start system 
1d17			 
1d17			coldstart: 
1d17				; set sp 
1d17				; di/ei 
1d17			 
1d17 f3				di 
1d18 31 fd ff			ld sp, tos 
1d1b cd f8 75			call init_nmi 
1d1e			;	ei 
1d1e			 
1d1e				; init spinner 
1d1e 3e 00			ld a,0 
1d20 32 c3 fb			ld (display_active), a 
1d23			 
1d23				; disable breakpoint by default 
1d23			 
1d23				;ld a,'*' 
1d23			;	ld a,' ' 
1d23			;	ld (os_view_disable),a 
1d23			 
1d23				; set break point vector as new break point on or off 
1d23 cd 40 1a			call bp_off 
1d26			 
1d26				; init hardware 
1d26			 
1d26				; init keyboard and screen hardware 
1d26			 
1d26 cd 69 00			call hardware_init 
1d29			 
1d29			 
1d29 cd df 0c			call delay1s 
1d2c 3e 58			ld a, display_row_3+8 
1d2e 11 03 00			ld de, buildtime 
1d31 cd af 0d			call str_at_display 
1d34 cd bf 0d			call update_display 
1d37			 
1d37 cd df 0c			call delay1s 
1d3a cd df 0c			call delay1s 
1d3d cd df 0c			call delay1s 
1d40			 
1d40				; detect if any keys are held down to enable breakpoints at start up 
1d40			 
1d40 cd 82 79			call cin  
1d43 fe 00			cp 0 
1d45 28 03			jr z, .nokeys 
1d47			 
1d47				;call hardware_diags 
1d47 cd 30 16			call config 
1d4a			 
1d4a			;	ld de, .bpen 
1d4a			;	ld a, display_row_4 
1d4a			;	call str_at_display 
1d4a			;	call update_display 
1d4a			; 
1d4a			;	ld a,0 
1d4a			;	ld (os_view_disable),a 
1d4a			; 
1d4a			;.bpwait: 
1d4a			;	call cin 
1d4a			;	cp 0 
1d4a			;	jr z, .bpwait 
1d4a			;	jr .nokeys 
1d4a			; 
1d4a			; 
1d4a			;.bpen:  db "Break points enabled!",0 
1d4a			 
1d4a			 
1d4a			 
1d4a			 
1d4a			 
1d4a			 
1d4a			.nokeys: 
1d4a			 
1d4a			 
1d4a				 
1d4a			 
1d4a			;jp  testkey 
1d4a			 
1d4a			;call storage_get_block_0 
1d4a			; 
1d4a			;ld hl, 0 
1d4a			;ld de, store_page 
1d4a			;call storage_read_block 
1d4a			 
1d4a				 
1d4a			;ld hl, 10 
1d4a			;ld de, store_page 
1d4a			;call storage_read_block 
1d4a			 
1d4a			 
1d4a			 
1d4a			 
1d4a			 
1d4a			;stop:	nop 
1d4a			;	jp stop 
1d4a			 
1d4a			 
1d4a			 
1d4a			main: 
1d4a cd 9c 0d			call clear_display 
1d4d cd bf 0d			call update_display 
1d50			 
1d50			 
1d50			 
1d50			;	call testlcd 
1d50			 
1d50			 
1d50			 
1d50 cd 90 24			call forth_init 
1d53			 
1d53			 
1d53			warmstart: 
1d53 cd 66 24			call forth_warmstart 
1d56			 
1d56				; run startup word load 
1d56			        ; TODO prevent this running at warmstart after crash  
1d56			 
1d56				if STARTUP_ENABLE 
1d56			 
1d56					if STARTUP_V1 
1d56			 
1d56						if STORAGE_SE 
1d56							call forth_autoload 
1d56						endif 
1d56						call forth_startup 
1d56					endif 
1d56			 
1d56					if STARTUP_V2 
1d56			 
1d56						if STORAGE_SE 
1d56 cd 26 74						call forth_autoload 
1d59						else 
1d59							call forth_startup 
1d59						endif 
1d59			 
1d59			 
1d59					endif 
1d59			 
1d59				endif 
1d59			 
1d59				; show free memory after boot 
1d59 11 f3 1d			ld de, freeram 
1d5c 3e 00			ld a, display_row_1 
1d5e cd af 0d			call str_at_display 
1d61			 
1d61			; Or use heap_size word???? 
1d61 21 a5 f1			ld hl, heap_end 
1d64 11 0e 80			ld de, heap_start 
1d67 ed 52			sbc hl, de 
1d69 e5				push hl 
1d6a 7c				ld a,h	         	 
1d6b 21 c3 f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d6e cd d1 12			call hexout 
1d71 e1			   	pop hl 
1d72			 
1d72 7d				ld a,l 
1d73 21 c5 f4			ld hl, os_word_scratch+2 
1d76 cd d1 12			call hexout 
1d79 21 c7 f4			ld hl, os_word_scratch+4 
1d7c 3e 00			ld a, 0 
1d7e 77				ld (hl),a 
1d7f 11 c3 f4			ld de, os_word_scratch 
1d82 3e 0d			ld a, display_row_1 + 13 
1d84 cd af 0d			call str_at_display 
1d87 cd bf 0d			call update_display 
1d8a			 
1d8a			 
1d8a				;call demo 
1d8a			 
1d8a			 
1d8a				; init scratch input area for cli commands 
1d8a			 
1d8a 21 e5 f4			ld hl, os_cli_cmd 
1d8d 3e 00			ld a,0 
1d8f 77				ld (hl),a 
1d90 23				inc hl 
1d91 77				ld (hl),a 
1d92			 
1d92 3e 00			ld a,0 
1d94 32 e4 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d97			 
1d97 32 e1 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d9a 32 e2 f4			ld (os_cur_ptr+1),a	 
1d9d			 
1d9d 32 c3 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1da0 32 c4 f4			ld (os_word_scratch+1),a	 
1da3				 
1da3			 
1da3				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1da3 21 e5 f4			ld hl, os_cli_cmd 
1da6			 
1da6 3e 00			ld a, 0		 ; init cli input 
1da8 77				ld (hl), a 
1da9 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dab			cli: 
1dab				; show cli prompt 
1dab				;push af 
1dab				;ld a, 0 
1dab				;ld de, prompt 
1dab				;call str_at_display 
1dab			 
1dab				;call update_display 
1dab				;pop af 
1dab				;inc a 
1dab				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1dab 0e 00			ld c, 0 
1dad 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1daf 1e 28			ld e, 40 
1db1			 
1db1 21 e5 f4			ld hl, os_cli_cmd 
1db4			 
1db4				STACKFRAME OFF $fefe $9f9f 
1db4				if DEBUG_STACK_IMB 
1db4					if OFF 
1db4						exx 
1db4						ld de, $fefe 
1db4						ld a, d 
1db4						ld hl, curframe 
1db4						call hexout 
1db4						ld a, e 
1db4						ld hl, curframe+2 
1db4						call hexout 
1db4						ld hl, $fefe 
1db4						push hl 
1db4						ld hl, $9f9f 
1db4						push hl 
1db4						exx 
1db4					endif 
1db4				endif 
1db4			endm 
# End of macro STACKFRAME
1db4			 
1db4 cd fd 0f			call input_str 
1db7			 
1db7				STACKFRAMECHK OFF $fefe $9f9f 
1db7				if DEBUG_STACK_IMB 
1db7					if OFF 
1db7						exx 
1db7						ld hl, $9f9f 
1db7						pop de   ; $9f9f 
1db7						call cmp16 
1db7						jr nz, .spnosame 
1db7						ld hl, $fefe 
1db7						pop de   ; $fefe 
1db7						call cmp16 
1db7						jr z, .spfrsame 
1db7						.spnosame: call showsperror 
1db7						.spfrsame: nop 
1db7						exx 
1db7					endif 
1db7				endif 
1db7			endm 
# End of macro STACKFRAMECHK
1db7			 
1db7				; copy input to last command 
1db7			 
1db7 21 e5 f4			ld hl, os_cli_cmd 
1dba 11 e4 f5			ld de, os_last_cmd 
1dbd 01 ff 00			ld bc, 255 
1dc0 ed b0			ldir 
1dc2			 
1dc2				; wipe current buffer 
1dc2			 
1dc2			;	ld a, 0 
1dc2			;	ld hl, os_cli_cmd 
1dc2			;	ld de, os_cli_cmd+1 
1dc2			;	ld bc, 254 
1dc2			;	ldir 
1dc2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1dc2			;	call strcpy 
1dc2			;	ld a, 0 
1dc2			;	ld (hl), a 
1dc2			;	inc hl 
1dc2			;	ld (hl), a 
1dc2			;	inc hl 
1dc2			;	ld (hl), a 
1dc2			 
1dc2				; switch frame buffer to program  
1dc2			 
1dc2 21 0d fd				ld hl, display_fb1 
1dc5 22 c9 fb				ld (display_fb_active), hl 
1dc8			 
1dc8			;	nop 
1dc8				STACKFRAME ON $fbfe $8f9f 
1dc8				if DEBUG_STACK_IMB 
1dc8					if ON 
1dc8						exx 
1dc8						ld de, $fbfe 
1dc8						ld a, d 
1dc8						ld hl, curframe 
1dc8						call hexout 
1dc8						ld a, e 
1dc8						ld hl, curframe+2 
1dc8						call hexout 
1dc8						ld hl, $fbfe 
1dc8						push hl 
1dc8						ld hl, $8f9f 
1dc8						push hl 
1dc8						exx 
1dc8					endif 
1dc8				endif 
1dc8			endm 
# End of macro STACKFRAME
1dc8				; first time into the parser so pass over the current scratch pad 
1dc8 21 e5 f4			ld hl,os_cli_cmd 
1dcb				; tokenise the entered statement(s) in HL 
1dcb cd 0e 25			call forthparse 
1dce			        ; exec forth statements in top of return stack 
1dce cd 4e 25			call forthexec 
1dd1				;call forthexec_cleanup 
1dd1			;	call parsenext 
1dd1			 
1dd1				STACKFRAMECHK ON $fbfe $8f9f 
1dd1				if DEBUG_STACK_IMB 
1dd1					if ON 
1dd1						exx 
1dd1						ld hl, $8f9f 
1dd1						pop de   ; $8f9f 
1dd1						call cmp16 
1dd1						jr nz, .spnosame 
1dd1						ld hl, $fbfe 
1dd1						pop de   ; $fbfe 
1dd1						call cmp16 
1dd1						jr z, .spfrsame 
1dd1						.spnosame: call showsperror 
1dd1						.spfrsame: nop 
1dd1						exx 
1dd1					endif 
1dd1				endif 
1dd1			endm 
# End of macro STACKFRAMECHK
1dd1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1dd1			 
1dd1 3e 78			ld a, display_row_4 
1dd3 11 05 1e			ld de, endprog 
1dd6			 
1dd6 cd bf 0d			call update_display		 
1dd9			 
1dd9 cd 8b 20			call next_page_prompt 
1ddc			 
1ddc				; switch frame buffer to cli 
1ddc			 
1ddc 21 ae fd				ld hl, display_fb0 
1ddf 22 c9 fb				ld (display_fb_active), hl 
1de2			 
1de2			 
1de2 cd 9c 0d		        call clear_display 
1de5 cd bf 0d			call update_display		 
1de8			 
1de8 21 e5 f4			ld hl, os_cli_cmd 
1deb			 
1deb 3e 00			ld a, 0		 ; init cli input 
1ded 77				ld (hl), a 
1dee			 
1dee				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1dee			 
1dee				; now on last line 
1dee			 
1dee				; TODO scroll screen up 
1dee			 
1dee				; TODO instead just clear screen and place at top of screen 
1dee			 
1dee			;	ld a, 0 
1dee			;	ld (f_cursor_ptr),a 
1dee			 
1dee				;call clear_display 
1dee				;call update_display 
1dee			 
1dee				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dee 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1df0 c3 ab 1d			jp cli 
1df3			 
1df3 .. 00		freeram: db "Free bytes: $",0 
1e01 ..			asc: db "1A2F" 
1e05 .. 00		endprog: db "End prog...",0 
1e11			 
1e11			testenter2:   
1e11 21 f0 f1			ld hl,scratch+50 
1e14 22 e1 f4			ld (os_cur_ptr),hl 
1e17 c3 ab 1d			jp cli 
1e1a			 
1e1a			testenter:  
1e1a			 
1e1a 21 01 1e			ld hl,asc 
1e1d			;	ld a,(hl) 
1e1d			;	call nibble2val 
1e1d cd 27 13			call get_byte 
1e20			 
1e20			 
1e20			;	ld a,(hl) 
1e20			;	call atohex 
1e20			 
1e20			;	call fourehexhl 
1e20 32 f0 f1			ld (scratch+50),a 
1e23			 
1e23			 
1e23			 
1e23 21 03 1e			ld hl,asc+2 
1e26			;	ld a, (hl) 
1e26			;	call nibble2val 
1e26 cd 27 13			call get_byte 
1e29			 
1e29			;	call fourehexhl 
1e29 32 f2 f1			ld (scratch+52),a 
1e2c				 
1e2c 21 f0 f1			ld hl,scratch+50 
1e2f 22 e1 f4			ld (os_cur_ptr),hl 
1e32 c3 ab 1d			jp cli 
1e35			 
1e35			enter:	 
1e35 3a c2 f1			ld a,(scratch+4) 
1e38 fe 00			cp 0 
1e3a 28 0c			jr z, .entercont 
1e3c				; no, not a null term line so has an address to work out.... 
1e3c			 
1e3c 21 c0 f1			ld hl,scratch+2 
1e3f cd 87 13			call get_word_hl 
1e42			 
1e42 22 e1 f4			ld (os_cur_ptr),hl	 
1e45 c3 ab 1d			jp cli 
1e48			 
1e48			 
1e48			.entercont:  
1e48			 
1e48 21 c0 f1			ld hl, scratch+2 
1e4b cd 27 13			call get_byte 
1e4e			 
1e4e 2a e1 f4		   	ld hl,(os_cur_ptr) 
1e51 77					ld (hl),a 
1e52 23					inc hl 
1e53 22 e1 f4				ld (os_cur_ptr),hl 
1e56				 
1e56			; get byte  
1e56			 
1e56			 
1e56 c3 ab 1d			jp cli 
1e59			 
1e59			 
1e59			; basic monitor support 
1e59			 
1e59			monitor: 
1e59				;  
1e59 cd 9c 0d			call clear_display 
1e5c 3e 00			ld a, 0 
1e5e 11 ad 1e			ld de, .monprompt 
1e61 cd af 0d			call str_at_display 
1e64 cd bf 0d			call update_display 
1e67			 
1e67				; get a monitor command 
1e67			 
1e67 0e 00			ld c, 0     ; entry at top left 
1e69 16 64			ld d, 100   ; max buffer size 
1e6b 1e 0f			ld e, 15    ; input scroll area 
1e6d 3e 00			ld a, 0     ; init string 
1e6f 21 bc f3			ld hl, os_input 
1e72 77				ld (hl), a 
1e73 23				inc hl 
1e74 77				ld (hl), a 
1e75 21 bc f3			ld hl, os_input 
1e78 3e 01			ld a, 1     ; init string 
1e7a cd fd 0f			call input_str 
1e7d			 
1e7d cd 9c 0d		        call clear_display 
1e80 cd bf 0d			call update_display		 
1e83			 
1e83 3a bc f3			ld a, (os_input) 
1e86 cd 25 14			call toUpper 
1e89 fe 48		        cp 'H' 
1e8b ca 12 1f		        jp z, .monhelp 
1e8e fe 44			cp 'D'		; dump 
1e90 ca 45 1f			jp z, .mondump	 
1e93 fe 43			cp 'C'		; dump 
1e95 ca 5f 1f			jp z, .moncdump	 
1e98 fe 4d			cp 'M'		; dump 
1e9a ca af 1e			jp z, .moneditstart 
1e9d fe 55			cp 'U'		; dump 
1e9f ca bb 1e			jp z, .monedit	 
1ea2 fe 47			cp 'G'		; dump 
1ea4 ca 3b 1f			jp z, .monjump 
1ea7 fe 51			cp 'Q'		; dump 
1ea9 c8				ret z	 
1eaa			 
1eaa			 
1eaa				; TODO "S" to access symbol by name and not need the address 
1eaa				; TODO "F" to find a string in memory 
1eaa			 
1eaa c3 59 1e			jp monitor 
1ead			 
1ead .. 00		.monprompt: db ">", 0 
1eaf			 
1eaf			.moneditstart: 
1eaf				; get starting address 
1eaf			 
1eaf 21 be f3			ld hl,os_input+2 
1eb2 cd 87 13			call get_word_hl 
1eb5			 
1eb5 22 e1 f4			ld (os_cur_ptr),hl	 
1eb8			 
1eb8 c3 59 1e			jp monitor 
1ebb			 
1ebb			.monedit: 
1ebb				; get byte to load 
1ebb			 
1ebb 21 be f3			ld hl,os_input+2 
1ebe cd 27 13			call get_byte 
1ec1			 
1ec1				; get address to update 
1ec1 2a e1 f4			ld hl, (os_cur_ptr) 
1ec4			 
1ec4				; update byte 
1ec4			 
1ec4 77				ld (hl), a 
1ec5			 
1ec5				; move to next address and save it 
1ec5			 
1ec5 23				inc hl 
1ec6 22 e1 f4			ld (os_cur_ptr),hl	 
1ec9			 
1ec9 c3 59 1e			jp monitor 
1ecc			 
1ecc			 
1ecc .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ee0 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1efc .. 00		.monhelptext3:  db "G-Call address",0 
1f0b .. 00		.monhelptext4:  db "Q-Quit",0 
1f12			        
1f12			.monhelp: 
1f12 3e 00			ld a, display_row_1 
1f14 11 cc 1e		        ld de, .monhelptext1 
1f17			 
1f17 cd af 0d			call str_at_display 
1f1a 3e 28			ld a, display_row_2 
1f1c 11 e0 1e		        ld de, .monhelptext2 
1f1f					 
1f1f cd af 0d			call str_at_display 
1f22 3e 50			ld a, display_row_3 
1f24 11 fc 1e		        ld de, .monhelptext3 
1f27					 
1f27 cd af 0d			call str_at_display 
1f2a 3e 78			ld a, display_row_4 
1f2c 11 0b 1f		        ld de, .monhelptext4 
1f2f cd af 0d			call str_at_display 
1f32			 
1f32 cd bf 0d			call update_display		 
1f35			 
1f35 cd 8b 20			call next_page_prompt 
1f38 c3 59 1e			jp monitor 
1f3b			 
1f3b			.monjump:    
1f3b 21 be f3			ld hl,os_input+2 
1f3e cd 87 13			call get_word_hl 
1f41			 
1f41 e9				jp (hl) 
1f42 c3 59 1e			jp monitor 
1f45			 
1f45			.mondump:    
1f45 21 be f3			ld hl,os_input+2 
1f48 cd 87 13			call get_word_hl 
1f4b			 
1f4b 22 e1 f4			ld (os_cur_ptr),hl	 
1f4e cd 93 1f			call dumpcont 
1f51 3e 78			ld a, display_row_4 
1f53 11 05 1e			ld de, endprog 
1f56			 
1f56 cd bf 0d			call update_display		 
1f59			 
1f59 cd 8b 20			call next_page_prompt 
1f5c c3 59 1e			jp monitor 
1f5f			.moncdump: 
1f5f cd 93 1f			call dumpcont 
1f62 3e 78			ld a, display_row_4 
1f64 11 05 1e			ld de, endprog 
1f67			 
1f67 cd bf 0d			call update_display		 
1f6a			 
1f6a cd 8b 20			call next_page_prompt 
1f6d c3 59 1e			jp monitor 
1f70			 
1f70			 
1f70			; TODO symbol access  
1f70			 
1f70			.symbols:     ;; A list of symbols that can be called up  
1f70 ae fd			dw display_fb0 
1f72 .. 00			db "fb0",0  
1f76 77 fa		     	dw store_page 
1f78 .. 00			db "store_page",0 
1f83			 
1f83			 
1f83			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f83			 
1f83 3a bf f1			ld a,(scratch+1) 
1f86 fe 00			cp 0 
1f88 28 09			jr z, dumpcont 
1f8a			 
1f8a				; no, not a null term line so has an address to work out.... 
1f8a			 
1f8a 21 c0 f1			ld hl,scratch+2 
1f8d cd 87 13			call get_word_hl 
1f90			 
1f90 22 e1 f4			ld (os_cur_ptr),hl	 
1f93			 
1f93			 
1f93			 
1f93			dumpcont: 
1f93			 
1f93				; dump bytes at ptr 
1f93			 
1f93			 
1f93 3e 00			ld a, display_row_1 
1f95 2a c9 fb			ld hl, (display_fb_active) 
1f98 cd d0 0f			call addatohl 
1f9b cd c3 1f			call .dumpbyterow 
1f9e			 
1f9e 3e 28			ld a, display_row_2 
1fa0 2a c9 fb			ld hl, (display_fb_active) 
1fa3 cd d0 0f			call addatohl 
1fa6 cd c3 1f			call .dumpbyterow 
1fa9			 
1fa9			 
1fa9 3e 50			ld a, display_row_3 
1fab 2a c9 fb			ld hl, (display_fb_active) 
1fae cd d0 0f			call addatohl 
1fb1 cd c3 1f			call .dumpbyterow 
1fb4			 
1fb4 3e 78			ld a, display_row_4 
1fb6 2a c9 fb			ld hl, (display_fb_active) 
1fb9 cd d0 0f			call addatohl 
1fbc cd c3 1f			call .dumpbyterow 
1fbf			 
1fbf cd bf 0d			call update_display 
1fc2			;		jp cli 
1fc2 c9				ret 
1fc3			 
1fc3			.dumpbyterow: 
1fc3			 
1fc3				;push af 
1fc3			 
1fc3 e5				push hl 
1fc4			 
1fc4				; calc where to poke the ascii 
1fc4			if display_cols == 20 
1fc4				ld a, 16 
1fc4			else 
1fc4 3e 1f			ld a, 31 
1fc6			endif 
1fc6			 
1fc6 cd d0 0f			call addatohl 
1fc9 22 c3 f4			ld (os_word_scratch),hl  		; save pos for later 
1fcc			 
1fcc			 
1fcc			; display decoding address 
1fcc 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fcf			 
1fcf 7c				ld a,h 
1fd0 e1				pop hl 
1fd1 e5				push hl 
1fd2			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fd2 cd d1 12			call hexout 
1fd5 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fd8			 
1fd8 7d				ld a,l 
1fd9 e1				pop hl 
1fda 23				inc hl 
1fdb 23				inc hl 
1fdc e5				push hl 
1fdd			;	ld hl, os_word_scratch+2 
1fdd cd d1 12			call hexout 
1fe0 e1				pop hl 
1fe1 23				inc hl 
1fe2 23				inc hl 
1fe3				;ld hl, os_word_scratch+4 
1fe3 3e 3a			ld a, ':' 
1fe5 77				ld (hl),a 
1fe6 23				inc hl 
1fe7				;ld a, 0 
1fe7				;ld (hl),a 
1fe7				;ld de, os_word_scratch 
1fe7				;pop af 
1fe7				;push af 
1fe7			;		ld a, display_row_2 
1fe7			;		call str_at_display 
1fe7			;		call update_display 
1fe7			 
1fe7			 
1fe7			;pop af 
1fe7			;	add 5 
1fe7			 
1fe7			if display_cols == 20 
1fe7				ld b, 4 
1fe7			else 
1fe7 06 08			ld b, 8 
1fe9			endif	 
1fe9			 
1fe9			.dumpbyte: 
1fe9 c5				push bc 
1fea e5				push hl 
1feb			 
1feb			 
1feb 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fee 7e					ld a,(hl) 
1fef			 
1fef					; poke the ascii to display 
1fef 2a c3 f4				ld hl,(os_word_scratch) 
1ff2 77					ld (hl),a 
1ff3 23					inc hl 
1ff4 22 c3 f4				ld (os_word_scratch),hl 
1ff7			 
1ff7					 
1ff7			 
1ff7			 
1ff7 e1					pop hl 
1ff8 e5					push hl 
1ff9			 
1ff9 cd d1 12				call hexout 
1ffc			 
1ffc					 
1ffc 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fff 23				inc hl 
2000 22 e1 f4		   	ld (os_cur_ptr),hl 
2003			 
2003 e1					pop hl 
2004 23					inc hl 
2005 23					inc hl 
2006 23					inc hl 
2007			 
2007			 
2007			 
2007					;ld a,0 
2007					;ld (os_word_scratch+2),a 
2007					;pop af 
2007					;push af 
2007			 
2007					;ld de, os_word_scratch 
2007					;call str_at_display 
2007			;		call update_display 
2007			;		pop af 
2007 c1					pop bc 
2008 c6 03				add 3 
200a 10 dd			djnz .dumpbyte 
200c			 
200c				 
200c			 
200c c9				ret 
200d			 
200d			jump:	 
200d			 
200d 21 c0 f1			ld hl,scratch+2 
2010 cd 87 13			call get_word_hl 
2013				;ld hl,(scratch+2) 
2013				;call fourehexhl 
2013			 
2013 22 e1 f4			ld (os_cur_ptr),hl	 
2016			 
2016 e9				jp (hl) 
2017			 
2017			 
2017			 
2017			; TODO implement a basic monitor mode to start with 
2017			 
2017			 
2017			 
2017			 
2017			 
2017			 
2017			 
2017			 
2017			 
2017			; testing and demo code during development 
2017			 
2017			 
2017 .. 00		str1: db "Enter some text...",0 
202a .. 00		clear: db "                    ",0 
203f			 
203f			demo: 
203f			 
203f			 
203f			 
203f			;	call update_display 
203f			 
203f				; init scratch input area for testing 
203f 21 be f1			ld hl, scratch	 
2042 3e 00			ld a,0 
2044 77				ld (hl),a 
2045			 
2045			 
2045 3e 28		            LD   A, display_row_2 
2047			;            CALL fLCD_Pos       ;Position cursor to location in A 
2047 11 17 20		            LD   DE, str1 
204a cd af 0d			call str_at_display 
204d			 
204d			;            CALL fLCD_Str       ;Display string pointed to by DE 
204d			cloop:	 
204d 3e 50		            LD   A, display_row_3 
204f			;            CALL fLCD_Pos       ;Position cursor to location in A 
204f 11 2a 20		            LD   DE, clear 
2052			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2052 cd af 0d				call str_at_display 
2055 3e 78			ld a, display_row_4 
2057 11 87 20			ld de, prompt 
205a			 
205a cd af 0d				call str_at_display 
205d cd bf 0d			call update_display 
2060			 
2060 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2062 16 0a			ld d, 10 
2064 21 be f1			ld hl, scratch	 
2067 cd fd 0f			call input_str 
206a			 
206a			;	call clear_display 
206a			;'	call update_display 
206a			 
206a 3e 00		            LD   A, display_row_1 
206c			;            CALL fLCD_Pos       ;Position cursor to location in A 
206c 11 2a 20		            LD   DE, clear 
206f cd af 0d				call str_at_display 
2072			;            CALL fLCD_Str       ;Display string pointed to by DE 
2072 3e 00		            LD   A, display_row_1 
2074			;            CALL fLCD_Pos       ;Position cursor to location in A 
2074 11 be f1		            LD   DE, scratch 
2077			;            CALL fLCD_Str       ;Display string pointed to by DE 
2077 cd af 0d				call str_at_display 
207a cd bf 0d			call update_display 
207d			 
207d 3e 00				ld a,0 
207f 21 be f1			ld hl, scratch 
2082 77				ld (hl),a 
2083			 
2083 00				nop 
2084 c3 4d 20			jp cloop 
2087			 
2087			 
2087			 
2087			; OS Prompt 
2087			 
2087 .. 00		prompt: db ">",0 
2089 .. 00		endprg: db "?",0 
208b			 
208b			 
208b			; handy next page prompt 
208b			next_page_prompt: 
208b e5				push hl 
208c d5				push de 
208d f5				push af 
208e c5				push bc 
208f			 
208f 3e 9f			ld a,display_row_4 + display_cols - 1 
2091 11 89 20		        ld de, endprg 
2094 cd af 0d			call str_at_display 
2097 cd bf 0d			call update_display 
209a cd 71 79			call cin_wait 
209d c1				pop bc 
209e f1				pop af 
209f d1				pop de 
20a0 e1				pop hl 
20a1			 
20a1			 
20a1 c9				ret 
20a2			 
20a2			 
20a2			; forth parser 
20a2			 
20a2			; My forth kernel 
20a2			include "forth_kernel.asm" 
20a2			; 
20a2			; kernel to the forth OS 
20a2			 
20a2			DS_TYPE_STR: equ 1     ; string type 
20a2			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
20a2			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
20a2			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
20a2			 
20a2			FORTH_PARSEV1: equ 0 
20a2			FORTH_PARSEV2: equ 0 
20a2			FORTH_PARSEV3: equ 0 
20a2			FORTH_PARSEV4: equ 0 
20a2			FORTH_PARSEV5: equ 1 
20a2			 
20a2			;if FORTH_PARSEV5 
20a2			;	FORTH_END_BUFFER: equ 0 
20a2			;else 
20a2			FORTH_END_BUFFER: equ 127 
20a2			;endif 
20a2			 
20a2			FORTH_TRUE: equ 1 
20a2			FORTH_FALSE: equ 0 
20a2			 
20a2			if FORTH_PARSEV4 
20a2			include "forth_stackops.asm" 
20a2			endif 
20a2			 
20a2			if FORTH_PARSEV5 
20a2			include "forth_stackopsv5.asm" 
20a2			 
20a2			; Stack operations for v5 parser on wards 
20a2			; * DATA stack 
20a2			; * LOOP stack 
20a2			; * RETURN stack 
20a2			 
20a2			 
20a2			 
20a2			FORTH_CHK_DSP_UNDER: macro 
20a2				push hl 
20a2				push de 
20a2				ld hl,(cli_data_sp) 
20a2				ld de, cli_data_stack 
20a2				call cmp16 
20a2				jp c, fault_dsp_under 
20a2				pop de 
20a2				pop hl 
20a2				endm 
20a2			 
20a2			 
20a2			FORTH_CHK_RSP_UNDER: macro 
20a2				push hl 
20a2				push de 
20a2				ld hl,(cli_ret_sp) 
20a2				ld de, cli_ret_stack 
20a2				call cmp16 
20a2				jp c, fault_rsp_under 
20a2				pop de 
20a2				pop hl 
20a2				endm 
20a2			 
20a2			FORTH_CHK_LOOP_UNDER: macro 
20a2				push hl 
20a2				push de 
20a2				ld hl,(cli_loop_sp) 
20a2				ld de, cli_loop_stack 
20a2				call cmp16 
20a2				jp c, fault_loop_under 
20a2				pop de 
20a2				pop hl 
20a2				endm 
20a2			 
20a2			FORTH_ERR_TOS_NOTSTR: macro 
20a2				; TOSO might need more for checks when used 
20a2				push af 
20a2				ld a,(hl) 
20a2				cp DS_TYPE_STR 
20a2				jp nz, type_faultn   
20a2				pop af 
20a2				endm 
20a2			 
20a2			FORTH_ERR_TOS_NOTNUM: macro 
20a2				push af 
20a2				ld a,(hl) 
20a2				cp DS_TYPE_INUM 
20a2				jp nz, type_faultn   
20a2				pop af 
20a2				endm 
20a2			 
20a2			 
20a2			; increase data stack pointer and save hl to it 
20a2				 
20a2			FORTH_DSP_NEXT: macro 
20a2				call macro_forth_dsp_next 
20a2				endm 
20a2			 
20a2			 
20a2			macro_forth_dsp_next: 
20a2				if DEBUG_FORTH_STACK_GUARD 
20a2 cd 1e 72				call check_stacks 
20a5				endif 
20a5 e5				push hl 
20a6 d5				push de 
20a7 eb				ex de,hl 
20a8 2a eb f9			ld hl,(cli_data_sp) 
20ab 23				inc hl 
20ac 23				inc hl 
20ad			 
20ad			; PARSEV5 
20ad 23				inc hl 
20ae 22 eb f9			ld (cli_data_sp),hl 
20b1 73				ld (hl), e 
20b2 23				inc hl 
20b3 72				ld (hl), d 
20b4 d1				pop de 
20b5 e1				pop hl 
20b6				if DEBUG_FORTH_STACK_GUARD 
20b6 cd 1e 72				call check_stacks 
20b9				endif 
20b9 c9				ret 
20ba			 
20ba			 
20ba			; increase ret stack pointer and save hl to it 
20ba				 
20ba			FORTH_RSP_NEXT: macro 
20ba				call macro_forth_rsp_next 
20ba				endm 
20ba			 
20ba			macro_forth_rsp_next: 
20ba				if DEBUG_FORTH_STACK_GUARD 
20ba cd 1e 72				call check_stacks 
20bd				endif 
20bd e5				push hl 
20be d5				push de 
20bf eb				ex de,hl 
20c0 2a ef f9			ld hl,(cli_ret_sp) 
20c3 23				inc hl 
20c4 23				inc hl 
20c5 22 ef f9			ld (cli_ret_sp),hl 
20c8 73				ld (hl), e 
20c9 23				inc hl 
20ca 72				ld (hl), d 
20cb d1				pop de 
20cc e1				pop hl 
20cd				if DEBUG_FORTH_STACK_GUARD 
20cd cd 1e 72				call check_stacks 
20d0				endif 
20d0 c9				ret 
20d1			 
20d1			; get current ret stack pointer and save to hl  
20d1				 
20d1			FORTH_RSP_TOS: macro 
20d1				call macro_forth_rsp_tos 
20d1				endm 
20d1			 
20d1			macro_forth_rsp_tos: 
20d1				;push de 
20d1 2a ef f9			ld hl,(cli_ret_sp) 
20d4 cd 0c 21			call loadhlptrtohl 
20d7				;ld e, (hl) 
20d7				;inc hl 
20d7				;ld d, (hl) 
20d7				;ex de, hl 
20d7					if DEBUG_FORTH_WORDS 
20d7			;			DMARK "RST" 
20d7						CALLMONITOR 
20d7 cd 6c fe			call debug_vector  
20da				endm  
# End of macro CALLMONITOR
20da					endif 
20da				;pop de 
20da c9				ret 
20db			 
20db			; pop ret stack pointer 
20db				 
20db			FORTH_RSP_POP: macro 
20db				call macro_forth_rsp_pop 
20db				endm 
20db			 
20db			 
20db			macro_forth_rsp_pop: 
20db				if DEBUG_FORTH_STACK_GUARD 
20db			;		DMARK "RPP" 
20db cd 1e 72				call check_stacks 
20de					FORTH_CHK_RSP_UNDER 
20de e5				push hl 
20df d5				push de 
20e0 2a ef f9			ld hl,(cli_ret_sp) 
20e3 11 a9 f9			ld de, cli_ret_stack 
20e6 cd ee 0f			call cmp16 
20e9 da 32 73			jp c, fault_rsp_under 
20ec d1				pop de 
20ed e1				pop hl 
20ee				endm 
# End of macro FORTH_CHK_RSP_UNDER
20ee				endif 
20ee e5				push hl 
20ef 2a ef f9			ld hl,(cli_ret_sp) 
20f2			 
20f2			 
20f2				if FORTH_ENABLE_FREE 
20f2			 
20f2					; get pointer 
20f2			 
20f2					push de 
20f2					push hl 
20f2			 
20f2					ld e, (hl) 
20f2					inc hl 
20f2					ld d, (hl) 
20f2			 
20f2					ex de, hl 
20f2					call free 
20f2			 
20f2					pop hl 
20f2					pop de 
20f2			 
20f2			 
20f2				endif 
20f2			 
20f2			 
20f2 2b				dec hl 
20f3 2b				dec hl 
20f4 22 ef f9			ld (cli_ret_sp), hl 
20f7				; do stack underflow checks 
20f7 e1				pop hl 
20f8				if DEBUG_FORTH_STACK_GUARD 
20f8 cd 1e 72				call check_stacks 
20fb					FORTH_CHK_RSP_UNDER 
20fb e5				push hl 
20fc d5				push de 
20fd 2a ef f9			ld hl,(cli_ret_sp) 
2100 11 a9 f9			ld de, cli_ret_stack 
2103 cd ee 0f			call cmp16 
2106 da 32 73			jp c, fault_rsp_under 
2109 d1				pop de 
210a e1				pop hl 
210b				endm 
# End of macro FORTH_CHK_RSP_UNDER
210b				endif 
210b c9				ret 
210c			 
210c			 
210c			 
210c			; routine to load word pointed to by hl into hl 
210c			 
210c			loadhlptrtohl: 
210c			 
210c d5				push de 
210d 5e				ld e, (hl) 
210e 23				inc hl 
210f 56				ld d, (hl) 
2110 eb				ex de, hl 
2111 d1				pop de 
2112			 
2112 c9				ret 
2113			 
2113			 
2113			 
2113			 
2113			 
2113			; push a number held in HL onto the data stack 
2113			; entry point for pushing a value when already in hl used in function above 
2113			 
2113			forth_push_numhl: 
2113			 
2113 e5				push hl    ; save value to push 
2114			 
2114			if DEBUG_FORTH_PUSH 
2114				; see if disabled 
2114			 
2114			 
2114 f5				push af 
2115 3a 6c fe			ld a,(debug_vector) 
2118 fe c9			cp $c9   ; ret 
211a			;	ld a, (os_view_disable) 
211a			;	cp '*' 
211a 28 34			jr z, .pskip2 
211c e5				push hl 
211d e5			push hl 
211e cd 9c 0d			call clear_display 
2121 e1			pop hl 
2122 7c				ld a,h 
2123 21 c3 f4			ld hl, os_word_scratch 
2126 cd d1 12			call hexout 
2129 e1				pop hl 
212a 7d				ld a,l 
212b 21 c5 f4			ld hl, os_word_scratch+2 
212e cd d1 12			call hexout 
2131			 
2131 21 c7 f4			ld hl, os_word_scratch+4 
2134 3e 00			ld a,0 
2136 77				ld (hl),a 
2137 11 c3 f4			ld de,os_word_scratch 
213a 3e 28				ld a, display_row_2 
213c cd af 0d				call str_at_display 
213f 11 5a 5d			ld de, .push_num 
2142 3e 00			ld a, display_row_1 
2144			 
2144 cd af 0d				call str_at_display 
2147			 
2147			 
2147 cd bf 0d			call update_display 
214a cd df 0c			call delay1s 
214d cd df 0c			call delay1s 
2150			.pskip2:  
2150			 
2150 f1				pop af 
2151			endif	 
2151			 
2151			 
2151				FORTH_DSP_NEXT 
2151 cd a2 20			call macro_forth_dsp_next 
2154				endm 
# End of macro FORTH_DSP_NEXT
2154			 
2154 2a eb f9			ld hl, (cli_data_sp) 
2157			 
2157				; save item type 
2157 3e 02			ld a,  DS_TYPE_INUM 
2159 77				ld (hl), a 
215a 23				inc hl 
215b			 
215b				; get word off stack 
215b d1				pop de 
215c 7b				ld a,e 
215d 77				ld (hl), a 
215e 23				inc hl 
215f 7a				ld a,d 
2160 77				ld (hl), a 
2161			 
2161			if DEBUG_FORTH_PUSH 
2161 2b				dec hl 
2162 2b				dec hl 
2163 2b				dec hl 
2164						DMARK "PH5" 
2164 f5				push af  
2165 3a 79 21			ld a, (.dmark)  
2168 32 68 fe			ld (debug_mark),a  
216b 3a 7a 21			ld a, (.dmark+1)  
216e 32 69 fe			ld (debug_mark+1),a  
2171 3a 7b 21			ld a, (.dmark+2)  
2174 32 6a fe			ld (debug_mark+2),a  
2177 18 03			jr .pastdmark  
2179 ..			.dmark: db "PH5"  
217c f1			.pastdmark: pop af  
217d			endm  
# End of macro DMARK
217d				CALLMONITOR 
217d cd 6c fe			call debug_vector  
2180				endm  
# End of macro CALLMONITOR
2180			endif	 
2180			 
2180 c9				ret 
2181			 
2181			 
2181			; Push a string to stack pointed to by hl 
2181			 
2181			forth_push_str: 
2181			 
2181			if DEBUG_FORTH_PUSH 
2181						DMARK "PSQ" 
2181 f5				push af  
2182 3a 96 21			ld a, (.dmark)  
2185 32 68 fe			ld (debug_mark),a  
2188 3a 97 21			ld a, (.dmark+1)  
218b 32 69 fe			ld (debug_mark+1),a  
218e 3a 98 21			ld a, (.dmark+2)  
2191 32 6a fe			ld (debug_mark+2),a  
2194 18 03			jr .pastdmark  
2196 ..			.dmark: db "PSQ"  
2199 f1			.pastdmark: pop af  
219a			endm  
# End of macro DMARK
219a				CALLMONITOR 
219a cd 6c fe			call debug_vector  
219d				endm  
# End of macro CALLMONITOR
219d			endif	 
219d			    
219d e5				push hl 
219e e5				push hl 
219f			 
219f			;	ld a, 0   ; find end of string 
219f cd 2e 14			call strlenz 
21a2			if DEBUG_FORTH_PUSH 
21a2						DMARK "PQ2" 
21a2 f5				push af  
21a3 3a b7 21			ld a, (.dmark)  
21a6 32 68 fe			ld (debug_mark),a  
21a9 3a b8 21			ld a, (.dmark+1)  
21ac 32 69 fe			ld (debug_mark+1),a  
21af 3a b9 21			ld a, (.dmark+2)  
21b2 32 6a fe			ld (debug_mark+2),a  
21b5 18 03			jr .pastdmark  
21b7 ..			.dmark: db "PQ2"  
21ba f1			.pastdmark: pop af  
21bb			endm  
# End of macro DMARK
21bb				CALLMONITOR 
21bb cd 6c fe			call debug_vector  
21be				endm  
# End of macro CALLMONITOR
21be			endif	 
21be eb				ex de, hl 
21bf e1				pop hl   ; get ptr to start of string 
21c0			if DEBUG_FORTH_PUSH 
21c0						DMARK "PQ3" 
21c0 f5				push af  
21c1 3a d5 21			ld a, (.dmark)  
21c4 32 68 fe			ld (debug_mark),a  
21c7 3a d6 21			ld a, (.dmark+1)  
21ca 32 69 fe			ld (debug_mark+1),a  
21cd 3a d7 21			ld a, (.dmark+2)  
21d0 32 6a fe			ld (debug_mark+2),a  
21d3 18 03			jr .pastdmark  
21d5 ..			.dmark: db "PQ3"  
21d8 f1			.pastdmark: pop af  
21d9			endm  
# End of macro DMARK
21d9				CALLMONITOR 
21d9 cd 6c fe			call debug_vector  
21dc				endm  
# End of macro CALLMONITOR
21dc			endif	 
21dc 19				add hl,de 
21dd			if DEBUG_FORTH_PUSH 
21dd						DMARK "PQE" 
21dd f5				push af  
21de 3a f2 21			ld a, (.dmark)  
21e1 32 68 fe			ld (debug_mark),a  
21e4 3a f3 21			ld a, (.dmark+1)  
21e7 32 69 fe			ld (debug_mark+1),a  
21ea 3a f4 21			ld a, (.dmark+2)  
21ed 32 6a fe			ld (debug_mark+2),a  
21f0 18 03			jr .pastdmark  
21f2 ..			.dmark: db "PQE"  
21f5 f1			.pastdmark: pop af  
21f6			endm  
# End of macro DMARK
21f6				CALLMONITOR 
21f6 cd 6c fe			call debug_vector  
21f9				endm  
# End of macro CALLMONITOR
21f9			endif	 
21f9			 
21f9 2b				dec hl    ; see if there is an optional trailing double quote 
21fa 7e				ld a,(hl) 
21fb fe 22			cp '"' 
21fd 20 03			jr nz, .strnoq 
21ff 3e 00			ld a, 0      ; get rid of double quote 
2201 77				ld (hl), a 
2202 23			.strnoq: inc hl 
2203			 
2203 3e 00			ld a, 0 
2205 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2206			 
2206 13				inc de ; add one for the type string 
2207 13				inc de ; add one for null term??? 
2208			 
2208				; tos is get string pointer again 
2208				; de contains space to allocate 
2208				 
2208 d5				push de 
2209			 
2209 eb				ex de, hl 
220a			 
220a				;push af 
220a			 
220a			if DEBUG_FORTH_PUSH 
220a						DMARK "PHm" 
220a f5				push af  
220b 3a 1f 22			ld a, (.dmark)  
220e 32 68 fe			ld (debug_mark),a  
2211 3a 20 22			ld a, (.dmark+1)  
2214 32 69 fe			ld (debug_mark+1),a  
2217 3a 21 22			ld a, (.dmark+2)  
221a 32 6a fe			ld (debug_mark+2),a  
221d 18 03			jr .pastdmark  
221f ..			.dmark: db "PHm"  
2222 f1			.pastdmark: pop af  
2223			endm  
# End of macro DMARK
2223				CALLMONITOR 
2223 cd 6c fe			call debug_vector  
2226				endm  
# End of macro CALLMONITOR
2226			endif	 
2226 cd 97 14			call malloc	; on ret hl now contains allocated memory 
2229				if DEBUG_FORTH_MALLOC_GUARD 
2229 cc b2 5d				call z,malloc_error 
222c				endif 
222c			 
222c				 
222c c1				pop bc    ; get length 
222d d1				pop de   ;  get string start    
222e			 
222e				; hl has destination from malloc 
222e			 
222e eb				ex de, hl    ; prep for ldir 
222f			 
222f d5				push de   ; save malloc area for DSP later 
2230				;push hl   ; save malloc area for DSP later 
2230			 
2230			if DEBUG_FORTH_PUSH 
2230						DMARK "PHc" 
2230 f5				push af  
2231 3a 45 22			ld a, (.dmark)  
2234 32 68 fe			ld (debug_mark),a  
2237 3a 46 22			ld a, (.dmark+1)  
223a 32 69 fe			ld (debug_mark+1),a  
223d 3a 47 22			ld a, (.dmark+2)  
2240 32 6a fe			ld (debug_mark+2),a  
2243 18 03			jr .pastdmark  
2245 ..			.dmark: db "PHc"  
2248 f1			.pastdmark: pop af  
2249			endm  
# End of macro DMARK
2249				CALLMONITOR 
2249 cd 6c fe			call debug_vector  
224c				endm  
# End of macro CALLMONITOR
224c			endif	 
224c			 
224c			 
224c ed b0			ldir 
224e			 
224e			 
224e				; push malloc to data stack     macro?????  
224e			 
224e				FORTH_DSP_NEXT 
224e cd a2 20			call macro_forth_dsp_next 
2251				endm 
# End of macro FORTH_DSP_NEXT
2251			 
2251				; save value and type 
2251			 
2251 2a eb f9			ld hl, (cli_data_sp) 
2254			 
2254				; save item type 
2254 3e 01			ld a,  DS_TYPE_STR 
2256 77				ld (hl), a 
2257 23				inc hl 
2258			 
2258				; get malloc word off stack 
2258 d1				pop de 
2259 73				ld (hl), e 
225a 23				inc hl 
225b 72				ld (hl), d 
225c			 
225c			 
225c			 
225c			if DEBUG_FORTH_PUSH 
225c 2a eb f9			ld hl, (cli_data_sp) 
225f						DMARK "PHS" 
225f f5				push af  
2260 3a 74 22			ld a, (.dmark)  
2263 32 68 fe			ld (debug_mark),a  
2266 3a 75 22			ld a, (.dmark+1)  
2269 32 69 fe			ld (debug_mark+1),a  
226c 3a 76 22			ld a, (.dmark+2)  
226f 32 6a fe			ld (debug_mark+2),a  
2272 18 03			jr .pastdmark  
2274 ..			.dmark: db "PHS"  
2277 f1			.pastdmark: pop af  
2278			endm  
# End of macro DMARK
2278				CALLMONITOR 
2278 cd 6c fe			call debug_vector  
227b				endm  
# End of macro CALLMONITOR
227b			;	ex de,hl 
227b			endif	 
227b				; in case of spaces, skip the ptr past the copied string 
227b				;pop af 
227b				;ld (cli_origptr),hl 
227b			 
227b c9				ret 
227c			 
227c			 
227c			 
227c			; TODO ascii push input onto stack given hl to start of input 
227c			 
227c			; identify type 
227c			; if starts with a " then a string 
227c			; otherwise it is a number 
227c			;  
227c			; if a string 
227c			;     scan for ending " to get length of string to malloc for + 1 
227c			;     malloc 
227c			;     put pointer to string on stack first byte flags as string 
227c			; 
227c			; else a number 
227c			;    look for number format identifier 
227c			;    $xx hex 
227c			;    %xxxxx bin 
227c			;    xxxxx decimal 
227c			;    convert number to 16bit word.  
227c			;    malloc word + 1 with flag to identiy as num 
227c			;    put pointer to number on stack 
227c			;   
227c			;  
227c			  
227c			forth_apush: 
227c				; kernel push 
227c			 
227c			if DEBUG_FORTH_PUSH 
227c						DMARK "PSH" 
227c f5				push af  
227d 3a 91 22			ld a, (.dmark)  
2280 32 68 fe			ld (debug_mark),a  
2283 3a 92 22			ld a, (.dmark+1)  
2286 32 69 fe			ld (debug_mark+1),a  
2289 3a 93 22			ld a, (.dmark+2)  
228c 32 6a fe			ld (debug_mark+2),a  
228f 18 03			jr .pastdmark  
2291 ..			.dmark: db "PSH"  
2294 f1			.pastdmark: pop af  
2295			endm  
# End of macro DMARK
2295				CALLMONITOR 
2295 cd 6c fe			call debug_vector  
2298				endm  
# End of macro CALLMONITOR
2298			endif	 
2298				; identify input type 
2298			 
2298 7e				ld a,(hl) 
2299 fe 22			cp '"' 
229b 28 0a			jr z, .fapstr 
229d fe 24			cp '$' 
229f ca c7 22			jp z, .faphex 
22a2 fe 25			cp '%' 
22a4 ca af 22			jp z, .fapbin 
22a7			;	cp 'b' 
22a7			;	jp z, .fabin 
22a7				; else decimal 
22a7			 
22a7				; TODO do decimal conversion 
22a7				; decimal is stored as a 16bit word 
22a7			 
22a7				; by default everything is a string if type is not detected 
22a7			.fapstr: ; 
22a7 fe 22			cp '"' 
22a9 20 01			jr nz, .strnoqu 
22ab 23				inc hl 
22ac			.strnoqu: 
22ac c3 81 21			jp forth_push_str 
22af			 
22af			 
22af			 
22af			.fapbin:    ; push a binary string.  
22af 11 00 00			ld de, 0   ; hold a 16bit value 
22b2			 
22b2 23			.fapbinshift:	inc hl  
22b3 7e				ld a,(hl) 
22b4 fe 00			cp 0     ; done scanning  
22b6 28 0b			jr z, .fapbdone  	; got it in HL so push  
22b8			 
22b8				; left shift de 
22b8 eb				ex de, hl	 
22b9 29				add hl, hl 
22ba			 
22ba				; is 1 
22ba fe 31			cp '1' 
22bc 20 02			jr nz, .binzero 
22be cb 4d			bit 1, l 
22c0			.binzero: 
22c0 eb				ex de, hl	 ; save current de 
22c1 18 ef			jr .fapbinshift 
22c3			 
22c3			.fapbdone: 
22c3 eb				ex de, hl 
22c4 c3 13 21			jp forth_push_numhl 
22c7			 
22c7			 
22c7			.faphex:   ; hex is always stored as a 16bit word 
22c7				; skip number prefix 
22c7 23				inc hl 
22c8				; turn ascii into number 
22c8 cd 87 13			call get_word_hl	; ret 16bit word in hl 
22cb			 
22cb c3 13 21			jp forth_push_numhl 
22ce			 
22ce 00				 nop 
22cf			 
22cf			.fabin:   ; TODO bin conversion 
22cf			 
22cf			 
22cf c9				ret 
22d0			 
22d0			 
22d0			; get either a string ptr or a 16bit word from the data stack 
22d0			 
22d0			FORTH_DSP: macro 
22d0				call macro_forth_dsp 
22d0				endm 
22d0			 
22d0			macro_forth_dsp: 
22d0				; data stack pointer points to current word on tos 
22d0			 
22d0 2a eb f9			ld hl,(cli_data_sp) 
22d3			 
22d3				if DEBUG_FORTH_PUSH 
22d3						DMARK "DSP" 
22d3 f5				push af  
22d4 3a e8 22			ld a, (.dmark)  
22d7 32 68 fe			ld (debug_mark),a  
22da 3a e9 22			ld a, (.dmark+1)  
22dd 32 69 fe			ld (debug_mark+1),a  
22e0 3a ea 22			ld a, (.dmark+2)  
22e3 32 6a fe			ld (debug_mark+2),a  
22e6 18 03			jr .pastdmark  
22e8 ..			.dmark: db "DSP"  
22eb f1			.pastdmark: pop af  
22ec			endm  
# End of macro DMARK
22ec			 
22ec cd e5 5d				call display_data_sp 
22ef				;call break_point_state 
22ef				;rst 030h 
22ef				CALLMONITOR 
22ef cd 6c fe			call debug_vector  
22f2				endm  
# End of macro CALLMONITOR
22f2				endif 
22f2			 
22f2 c9				ret 
22f3			 
22f3			; return hl to start of value on stack 
22f3			 
22f3			FORTH_DSP_VALUE: macro 
22f3				call macro_forth_dsp_value 
22f3				endm 
22f3			 
22f3			macro_forth_dsp_value: 
22f3			 
22f3				FORTH_DSP 
22f3 cd d0 22			call macro_forth_dsp 
22f6				endm 
# End of macro FORTH_DSP
22f6			 
22f6 d5				push de 
22f7			 
22f7 23				inc hl ; skip type 
22f8			 
22f8 5e				ld e, (hl) 
22f9 23				inc hl 
22fa 56				ld d, (hl) 
22fb eb				ex de,hl  
22fc			 
22fc d1				pop de 
22fd			 
22fd c9				ret 
22fe			 
22fe			; return hl to start of value to second item on stack 
22fe			 
22fe			FORTH_DSP_VALUEM1: macro 
22fe				call macro_forth_dsp_value_m1 
22fe				endm 
22fe			 
22fe			macro_forth_dsp_value_m1: 
22fe			 
22fe				FORTH_DSP 
22fe cd d0 22			call macro_forth_dsp 
2301				endm 
# End of macro FORTH_DSP
2301			 
2301 2b				dec hl 
2302 2b				dec hl 
2303			;	dec hl 
2303			 
2303 d5				push de 
2304			 
2304 5e				ld e, (hl) 
2305 23				inc hl 
2306 56				ld d, (hl) 
2307 eb				ex de,hl  
2308			 
2308 d1				pop de 
2309			 
2309 c9				ret 
230a			 
230a				 
230a			 
230a			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
230a			 
230a			FORTH_DSP_POP: macro 
230a				call macro_forth_dsp_pop 
230a				endm 
230a			 
230a			 
230a			; get the tos data type 
230a			 
230a			FORTH_DSP_TYPE:   macro 
230a			 
230a				;FORTH_DSP_VALUE 
230a				FORTH_DSP 
230a				 
230a				; hl points to value 
230a				; check type 
230a			 
230a				ld a,(hl) 
230a			 
230a				endm 
230a			 
230a			; load the tos value into hl 
230a			 
230a			 
230a			FORTH_DSP_VALUEHL:  macro 
230a				call macro_dsp_valuehl 
230a				endm 
230a			 
230a			 
230a			 
230a			macro_dsp_valuehl: 
230a				FORTH_DSP_VALUE 
230a cd f3 22			call macro_forth_dsp_value 
230d				endm 
# End of macro FORTH_DSP_VALUE
230d			 
230d				;FORTH_ERR_TOS_NOTNUM 
230d			 
230d				;inc hl   ; skip type id 
230d			 
230d			;	push de 
230d			; 
230d			;	ld e, (hl) 
230d			;	inc hl 
230d			;	ld d, (hl) 
230d			;	ex de,hl  
230d			 
230d			;	pop de 
230d			 
230d				if DEBUG_FORTH_PUSH 
230d						DMARK "DVL" 
230d f5				push af  
230e 3a 22 23			ld a, (.dmark)  
2311 32 68 fe			ld (debug_mark),a  
2314 3a 23 23			ld a, (.dmark+1)  
2317 32 69 fe			ld (debug_mark+1),a  
231a 3a 24 23			ld a, (.dmark+2)  
231d 32 6a fe			ld (debug_mark+2),a  
2320 18 03			jr .pastdmark  
2322 ..			.dmark: db "DVL"  
2325 f1			.pastdmark: pop af  
2326			endm  
# End of macro DMARK
2326				CALLMONITOR 
2326 cd 6c fe			call debug_vector  
2329				endm  
# End of macro CALLMONITOR
2329				endif 
2329 c9				ret 
232a			 
232a			forth_apushstrhl:      
232a				; push of string requires use of cli_origptr 
232a				; bodge use 
232a			 
232a				; get current cli_origptr, save, update with temp pointer  
232a ed 5b 3b fa		ld de, (cli_origptr) 
232e 22 3b fa			ld (cli_origptr), hl 
2331 d5				push de 
2332 cd 7c 22			call forth_apush 
2335 d1				pop de 
2336 ed 53 3b fa		ld (cli_origptr), de 
233a c9			        ret	 
233b			 
233b			 
233b			; increase loop stack pointer and save hl to it 
233b				 
233b			FORTH_LOOP_NEXT: macro 
233b				call macro_forth_loop_next 
233b				;nop 
233b				endm 
233b			 
233b			macro_forth_loop_next: 
233b				if DEBUG_FORTH_STACK_GUARD 
233b cd 1e 72				call check_stacks 
233e				endif 
233e e5				push hl 
233f d5				push de 
2340 eb				ex de,hl 
2341 2a ed f9			ld hl,(cli_loop_sp) 
2344 23				inc hl 
2345 23				inc hl 
2346					if DEBUG_FORTH_WORDS 
2346						DMARK "LNX" 
2346 f5				push af  
2347 3a 5b 23			ld a, (.dmark)  
234a 32 68 fe			ld (debug_mark),a  
234d 3a 5c 23			ld a, (.dmark+1)  
2350 32 69 fe			ld (debug_mark+1),a  
2353 3a 5d 23			ld a, (.dmark+2)  
2356 32 6a fe			ld (debug_mark+2),a  
2359 18 03			jr .pastdmark  
235b ..			.dmark: db "LNX"  
235e f1			.pastdmark: pop af  
235f			endm  
# End of macro DMARK
235f						CALLMONITOR 
235f cd 6c fe			call debug_vector  
2362				endm  
# End of macro CALLMONITOR
2362					endif 
2362 22 ed f9			ld (cli_loop_sp),hl 
2365 73				ld (hl), e 
2366 23				inc hl 
2367 72				ld (hl), d 
2368 d1				pop de    ; been reversed so save a swap on restore 
2369 e1				pop hl 
236a				if DEBUG_FORTH_STACK_GUARD 
236a cd 1e 72				call check_stacks 
236d				endif 
236d c9				ret 
236e			 
236e			; get current ret stack pointer and save to hl  
236e				 
236e			FORTH_LOOP_TOS: macro 
236e				call macro_forth_loop_tos 
236e				endm 
236e			 
236e			macro_forth_loop_tos: 
236e d5				push de 
236f 2a ed f9			ld hl,(cli_loop_sp) 
2372 5e				ld e, (hl) 
2373 23				inc hl 
2374 56				ld d, (hl) 
2375 eb				ex de, hl 
2376 d1				pop de 
2377 c9				ret 
2378			 
2378			; pop loop stack pointer 
2378				 
2378			FORTH_LOOP_POP: macro 
2378				call macro_forth_loop_pop 
2378				endm 
2378			 
2378			 
2378			macro_forth_loop_pop: 
2378				if DEBUG_FORTH_STACK_GUARD 
2378					DMARK "LPP" 
2378 f5				push af  
2379 3a 8d 23			ld a, (.dmark)  
237c 32 68 fe			ld (debug_mark),a  
237f 3a 8e 23			ld a, (.dmark+1)  
2382 32 69 fe			ld (debug_mark+1),a  
2385 3a 8f 23			ld a, (.dmark+2)  
2388 32 6a fe			ld (debug_mark+2),a  
238b 18 03			jr .pastdmark  
238d ..			.dmark: db "LPP"  
2390 f1			.pastdmark: pop af  
2391			endm  
# End of macro DMARK
2391 cd 1e 72				call check_stacks 
2394					FORTH_CHK_LOOP_UNDER 
2394 e5				push hl 
2395 d5				push de 
2396 2a ed f9			ld hl,(cli_loop_sp) 
2399 11 27 f9			ld de, cli_loop_stack 
239c cd ee 0f			call cmp16 
239f da 38 73			jp c, fault_loop_under 
23a2 d1				pop de 
23a3 e1				pop hl 
23a4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23a4				endif 
23a4 e5				push hl 
23a5 2a ed f9			ld hl,(cli_loop_sp) 
23a8 2b				dec hl 
23a9 2b				dec hl 
23aa 22 ed f9			ld (cli_loop_sp), hl 
23ad				; TODO do stack underflow checks 
23ad e1				pop hl 
23ae				if DEBUG_FORTH_STACK_GUARD 
23ae cd 1e 72				call check_stacks 
23b1					FORTH_CHK_LOOP_UNDER 
23b1 e5				push hl 
23b2 d5				push de 
23b3 2a ed f9			ld hl,(cli_loop_sp) 
23b6 11 27 f9			ld de, cli_loop_stack 
23b9 cd ee 0f			call cmp16 
23bc da 38 73			jp c, fault_loop_under 
23bf d1				pop de 
23c0 e1				pop hl 
23c1				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23c1				endif 
23c1 c9				ret 
23c2			 
23c2			macro_forth_dsp_pop: 
23c2			 
23c2 e5				push hl 
23c3			 
23c3				; release malloc data 
23c3			 
23c3				if DEBUG_FORTH_STACK_GUARD 
23c3 cd 1e 72				call check_stacks 
23c6					FORTH_CHK_DSP_UNDER 
23c6 e5				push hl 
23c7 d5				push de 
23c8 2a eb f9			ld hl,(cli_data_sp) 
23cb 11 25 f7			ld de, cli_data_stack 
23ce cd ee 0f			call cmp16 
23d1 da 2c 73			jp c, fault_dsp_under 
23d4 d1				pop de 
23d5 e1				pop hl 
23d6				endm 
# End of macro FORTH_CHK_DSP_UNDER
23d6				endif 
23d6				;ld hl,(cli_data_sp) 
23d6			if DEBUG_FORTH_DOT 
23d6				DMARK "DPP" 
23d6 f5				push af  
23d7 3a eb 23			ld a, (.dmark)  
23da 32 68 fe			ld (debug_mark),a  
23dd 3a ec 23			ld a, (.dmark+1)  
23e0 32 69 fe			ld (debug_mark+1),a  
23e3 3a ed 23			ld a, (.dmark+2)  
23e6 32 6a fe			ld (debug_mark+2),a  
23e9 18 03			jr .pastdmark  
23eb ..			.dmark: db "DPP"  
23ee f1			.pastdmark: pop af  
23ef			endm  
# End of macro DMARK
23ef				CALLMONITOR 
23ef cd 6c fe			call debug_vector  
23f2				endm  
# End of macro CALLMONITOR
23f2			endif	 
23f2			 
23f2			 
23f2			if FORTH_ENABLE_DSPPOPFREE 
23f2			 
23f2				FORTH_DSP 
23f2 cd d0 22			call macro_forth_dsp 
23f5				endm 
# End of macro FORTH_DSP
23f5			 
23f5 7e				ld a, (hl) 
23f6 fe 01			cp DS_TYPE_STR 
23f8 20 23			jr nz, .skippopfree 
23fa			 
23fa				FORTH_DSP_VALUEHL 
23fa cd 0a 23			call macro_dsp_valuehl 
23fd				endm 
# End of macro FORTH_DSP_VALUEHL
23fd 00				nop 
23fe			if DEBUG_FORTH_DOT 
23fe				DMARK "DPf" 
23fe f5				push af  
23ff 3a 13 24			ld a, (.dmark)  
2402 32 68 fe			ld (debug_mark),a  
2405 3a 14 24			ld a, (.dmark+1)  
2408 32 69 fe			ld (debug_mark+1),a  
240b 3a 15 24			ld a, (.dmark+2)  
240e 32 6a fe			ld (debug_mark+2),a  
2411 18 03			jr .pastdmark  
2413 ..			.dmark: db "DPf"  
2416 f1			.pastdmark: pop af  
2417			endm  
# End of macro DMARK
2417				CALLMONITOR 
2417 cd 6c fe			call debug_vector  
241a				endm  
# End of macro CALLMONITOR
241a			endif	 
241a cd 61 15			call free 
241d			.skippopfree: 
241d				 
241d			 
241d			endif 
241d			 
241d			if DEBUG_FORTH_DOT_KEY 
241d				DMARK "DP2" 
241d				CALLMONITOR 
241d			endif	 
241d			 
241d				; move pointer down 
241d			 
241d 2a eb f9			ld hl,(cli_data_sp) 
2420 2b				dec hl 
2421 2b				dec hl 
2422			; PARSEV5 
2422 2b				dec hl 
2423 22 eb f9			ld (cli_data_sp), hl 
2426			 
2426				if DEBUG_FORTH_STACK_GUARD 
2426 cd 1e 72				call check_stacks 
2429					FORTH_CHK_DSP_UNDER 
2429 e5				push hl 
242a d5				push de 
242b 2a eb f9			ld hl,(cli_data_sp) 
242e 11 25 f7			ld de, cli_data_stack 
2431 cd ee 0f			call cmp16 
2434 da 2c 73			jp c, fault_dsp_under 
2437 d1				pop de 
2438 e1				pop hl 
2439				endm 
# End of macro FORTH_CHK_DSP_UNDER
2439				endif 
2439			 
2439 e1				pop hl 
243a			 
243a c9				ret 
243b			 
243b			getwordathl: 
243b				; hl points to an address 
243b				; load hl with the word at that address 
243b			 
243b d5				push de 
243c			 
243c 5e				ld e, (hl) 
243d 23				inc hl 
243e 56				ld d, (hl) 
243f eb				ex de, hl 
2440			 
2440 d1				pop de 
2441 c9				ret 
2442			 
2442			 
2442			 
2442			 
2442			 
2442			; eof 
2442			 
# End of file forth_stackopsv5.asm
2442			endif 
2442			 
2442			loadwordinhl:	 
2442			 
2442 d5				push de 
2443			 
2443 5e				ld e, (hl) 
2444 23				inc hl 
2445 56				ld d, (hl) 
2446 eb				ex de,hl  
2447			 
2447 d1				pop de 
2448			 
2448 c9				ret 
2449			 
2449			user_word_eol:  
2449				; hl contains the pointer to where to create a linked list item from the end 
2449				; of the user dict to continue on at the system word dict 
2449				 
2449				; poke the stub of the word list linked list to repoint to rom words 
2449			 
2449				; stub format 
2449				; db   word id 
2449				; dw    link to next word 
2449			        ; db char length of token 
2449				; db string + 0 term 
2449				; db exec code....  
2449			 
2449 3e 00			ld a, WORD_SYS_ROOT     ; root word 
244b 77				ld (hl), a		; word id 
244c 23				inc hl 
244d			 
244d 11 18 26			ld de, sysdict 
2450 73				ld (hl), e		; next word link ie system dict 
2451 23				inc hl 
2452 72				ld (hl), d		; next word link ie system dict 
2453 23				inc hl	 
2454			 
2454			;	ld (hl), sysdict		; next word link ie system dict 
2454			;	inc hl 
2454			;	inc hl 
2454			 
2454			;	inc hl 
2454			;	inc hl 
2454			 
2454 3e 02			ld a, 2			; word length is 0 
2456 77				ld (hl), a	 
2457 23				inc hl 
2458			 
2458 3e 7e			ld a, '~'			; word length is 0 
245a 77				ld (hl), a	 
245b 23				inc hl 
245c 3e 00			ld a, 0			; save empty word 
245e 77				ld (hl), a 
245f			 
245f c9				ret 
2460			 
2460				 
2460			 
2460			forthexec_cleanup: 
2460				FORTH_RSP_POP 
2460 cd db 20			call macro_forth_rsp_pop 
2463				endm 
# End of macro FORTH_RSP_POP
2463 c9				ret 
2464			 
2464			forth_call_hl: 
2464				; taking hl 
2464 e5				push hl 
2465 c9				ret 
2466			 
2466			; this is called to reset Forth system but keep existing uwords etc 
2466			 
2466			forth_warmstart: 
2466				; setup stack over/under flow checks 
2466				if DEBUG_FORTH_STACK_GUARD 
2466 cd 04 72				call chk_stk_init 
2469				endif 
2469			 
2469				; init stack pointers  - * these stacks go upwards *  
2469 21 a9 f9			ld hl, cli_ret_stack 
246c 22 ef f9			ld (cli_ret_sp), hl	 
246f				; set bottom of stack 
246f 3e 00			ld a,0 
2471 77				ld (hl),a 
2472 23				inc hl 
2473 77				ld (hl),a 
2474			 
2474 21 25 f7			ld hl, cli_data_stack 
2477 22 eb f9			ld (cli_data_sp), hl	 
247a				; set bottom of stack 
247a 3e 00			ld a,0 
247c 77				ld (hl),a 
247d 23				inc hl 
247e 77				ld (hl),a 
247f			 
247f 21 27 f9			ld hl, cli_loop_stack 
2482 22 ed f9			ld (cli_loop_sp), hl	 
2485				; set bottom of stack 
2485 3e 00			ld a,0 
2487 77				ld (hl),a 
2488 23				inc hl 
2489 77				ld (hl),a 
248a			 
248a				; init extent of current open file 
248a			 
248a 3e 00			ld a, 0 
248c 32 67 fa			ld (store_openext), a 
248f			 
248f c9				ret 
2490			 
2490			 
2490			 
2490			; Cold Start - this is called to setup the whole Forth system 
2490			 
2490			forth_init: 
2490			 
2490				; setup stack over/under flow checks 
2490			 
2490			;	if DEBUG_FORTH_STACK_GUARD 
2490			;		call chk_stk_init 
2490			;	endif 
2490			 
2490				; enable auto display updates (slow.....) 
2490			 
2490 3e 01			ld a, 1 
2492 32 39 fa			ld (cli_autodisplay), a 
2495			 
2495				; if storage is in use disable long reads for now 
2495 3e 00			ld a, 0 
2497 32 72 fa			ld (store_longread), a 
249a			 
249a			 
249a				; show start up screen 
249a			 
249a cd 9c 0d			call clear_display 
249d			 
249d 3e 00			ld a,0 
249f 32 5b fa			ld (f_cursor_ptr), a 
24a2			 
24a2				; set start of word list in start of ram - for use when creating user words 
24a2			 
24a2 21 00 80			ld hl, baseram 
24a5 22 bb f4			ld (os_last_new_uword), hl 
24a8 cd 49 24			call user_word_eol 
24ab				 
24ab			;		call display_data_sp 
24ab			;		call next_page_prompt 
24ab			 
24ab			 
24ab			 
24ab			 
24ab c9				ret 
24ac			 
24ac .. 00		.bootforth: db " Forth Kernel Init ",0 
24c0			 
24c0			; TODO push to stack 
24c0			 
24c0			;  
24c0			 
24c0			if FORTH_PARSEV2 
24c0			 
24c0			 
24c0				include "forth_parserv2.asm" 
24c0			 
24c0			endif 
24c0			 
24c0			 
24c0			; parse cli version 1 
24c0			 
24c0			if FORTH_PARSEV1 
24c0			 
24c0			 
24c0			 
24c0			      include "forth_parserv1.asm" 
24c0			endif 
24c0				 
24c0			if FORTH_PARSEV3 
24c0			 
24c0			 
24c0			 
24c0			      include "forth_parserv3.asm" 
24c0				include "forth_wordsv3.asm" 
24c0			endif 
24c0			 
24c0			if FORTH_PARSEV4 
24c0			 
24c0			 
24c0			 
24c0			      include "forth_parserv4.asm" 
24c0				include "forth_wordsv4.asm" 
24c0			endif 
24c0			 
24c0			if FORTH_PARSEV5 
24c0			 
24c0			 
24c0			 
24c0			      include "forth_parserv5.asm" 
24c0			 
24c0			 
24c0			; A better parser without using malloc and string copies all over the place.  
24c0			; Exec in situ should be faster 
24c0			 
24c0			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24c0			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24c0			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24c0			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24c0			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24c0			WORD_SYS_END: equ 0   ; Opcode for all user words 
24c0			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24c0			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24c0			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24c0			 
24c0			; Core word preamble macro 
24c0			 
24c0			CWHEAD:   macro nxtword opcode lit len opflags 
24c0				db WORD_SYS_CORE+opcode             
24c0				; internal op code number 
24c0				dw nxtword            
24c0				; link to next dict word block 
24c0				db len + 1 
24c0				; literal length of dict word inc zero term 
24c0				db lit,0              
24c0				; literal dict word 
24c0			        ; TODO db opflags        
24c0				endm 
24c0			 
24c0			 
24c0			NEXTW: macro  
24c0				jp macro_next 
24c0				endm 
24c0			 
24c0			macro_next: 
24c0			if DEBUG_FORTH_PARSE_KEY 
24c0				DMARK "NXT" 
24c0				CALLMONITOR 
24c0			endif	 
24c0			;	inc hl  ; skip token null term  
24c0 ed 4b 3d fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24c4 ed 5b 3b fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24c8 2a bf f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24cb			if DEBUG_FORTH_PARSE_KEY 
24cb				DMARK "}AA" 
24cb				CALLMONITOR 
24cb			endif	 
24cb c3 ce 25			jp execnext 
24ce				;jp exec1 
24ce			       
24ce			 
24ce			 
24ce			; Another go at the parser to compile  
24ce			 
24ce			 
24ce			; TODO rework parser to change all of the string words to byte tokens 
24ce			; TODO do a search for  
24ce			 
24ce			; TODO first run normal parser to zero term sections 
24ce			; TODO for each word do a token look up to get the op code 
24ce			; TODO need some means to flag to the exec that this is a byte code form    
24ce			 
24ce			 
24ce			forthcompile: 
24ce			 
24ce			; 
24ce			; line parse: 
24ce			;       parse raw input buffer 
24ce			;       tokenise the words 
24ce			;       malloc new copy (for looping etc) 
24ce			;       copy to malloc + current pc in line to start of string and add line term 
24ce			;       save on new rsp 
24ce			; 
24ce			 
24ce			; hl to point to the line to tokenise 
24ce			 
24ce			;	push hl 
24ce 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
24d1			 
24d1			;	ld a,0		; string term on input 
24d1			;	call strlent 
24d1			 
24d1			;	ld (os_tok_len), hl	 ; save string length 
24d1			 
24d1			;if DEBUG_FORTH_TOK 
24d1			;	ex de,hl		 
24d1			;endif 
24d1			 
24d1			;	pop hl 		; get back string pointer 
24d1			 
24d1			if DEBUG_FORTH_TOK 
24d1						DMARK "TOc" 
24d1				CALLMONITOR 
24d1			endif 
24d1 7e			.cptoken2:    ld a,(hl) 
24d2 23				inc hl 
24d3 fe 7f			cp FORTH_END_BUFFER 
24d5 28 29			jr z, .cptokendone2 
24d7 fe 00			cp 0 
24d9 28 25			jr z, .cptokendone2 
24db fe 22			cp '"' 
24dd 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24df fe 20			cp ' ' 
24e1 20 ee			jr nz,  .cptoken2 
24e3			 
24e3			; TODO consume comments held between ( and ) 
24e3			 
24e3				; we have a space so change to zero term for dict match later 
24e3 2b				dec hl 
24e4 3e 00			ld a,0 
24e6 77				ld (hl), a 
24e7 23				inc hl 
24e8 18 e7			jr .cptoken2 
24ea				 
24ea			 
24ea			.cptokenstr2: 
24ea				; skip all white space until either eol (because forgot to term) or end double quote 
24ea			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24ea				;inc hl ; skip current double quote 
24ea 7e				ld a,(hl) 
24eb 23				inc hl 
24ec fe 22			cp '"' 
24ee 28 e1			jr z, .cptoken2 
24f0 fe 7f			cp FORTH_END_BUFFER 
24f2 28 0c			jr z, .cptokendone2 
24f4 fe 00			cp 0 
24f6 28 08			jr z, .cptokendone2 
24f8 fe 20			cp ' ' 
24fa 28 02			jr z, .cptmp2 
24fc 18 ec			jr .cptokenstr2 
24fe			 
24fe			.cptmp2:	; we have a space so change to zero term for dict match later 
24fe				;dec hl 
24fe				;ld a,"-"	; TODO remove this when working 
24fe				;ld (hl), a 
24fe				;inc hl 
24fe 18 ea			jr .cptokenstr2 
2500			 
2500			.cptokendone2: 
2500				;inc hl 
2500 3e 7f			ld a, FORTH_END_BUFFER 
2502 77				ld (hl),a 
2503 23				inc hl 
2504 3e 21			ld a, '!' 
2506 77				ld (hl),a 
2507			 
2507 2a bf f4			ld hl,(os_tok_ptr) 
250a			         
250a			if DEBUG_FORTH_TOK 
250a						DMARK "Tc1" 
250a				CALLMONITOR 
250a			endif 
250a			 
250a				; push exec string to top of return stack 
250a				FORTH_RSP_NEXT 
250a cd ba 20			call macro_forth_rsp_next 
250d				endm 
# End of macro FORTH_RSP_NEXT
250d c9				ret 
250e			 
250e			; Another go at the parser need to simplify the process 
250e			 
250e			forthparse: 
250e			 
250e			; 
250e			; line parse: 
250e			;       parse raw input buffer 
250e			;       tokenise the words 
250e			;       malloc new copy (for looping etc) 
250e			;       copy to malloc + current pc in line to start of string and add line term 
250e			;       save on new rsp 
250e			; 
250e			 
250e			; hl to point to the line to tokenise 
250e			 
250e			;	push hl 
250e 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
2511			 
2511			;	ld a,0		; string term on input 
2511			;	call strlent 
2511			 
2511			;	ld (os_tok_len), hl	 ; save string length 
2511			 
2511			;if DEBUG_FORTH_TOK 
2511			;	ex de,hl		 
2511			;endif 
2511			 
2511			;	pop hl 		; get back string pointer 
2511			 
2511			if DEBUG_FORTH_TOK 
2511						DMARK "TOK" 
2511				CALLMONITOR 
2511			endif 
2511 7e			.ptoken2:    ld a,(hl) 
2512 23				inc hl 
2513 fe 7f			cp FORTH_END_BUFFER 
2515 28 29			jr z, .ptokendone2 
2517 fe 00			cp 0 
2519 28 25			jr z, .ptokendone2 
251b fe 22			cp '"' 
251d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
251f fe 20			cp ' ' 
2521 20 ee			jr nz,  .ptoken2 
2523			 
2523			; TODO consume comments held between ( and ) 
2523			 
2523				; we have a space so change to zero term for dict match later 
2523 2b				dec hl 
2524 3e 00			ld a,0 
2526 77				ld (hl), a 
2527 23				inc hl 
2528 18 e7			jr .ptoken2 
252a				 
252a			 
252a			.ptokenstr2: 
252a				; skip all white space until either eol (because forgot to term) or end double quote 
252a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
252a				;inc hl ; skip current double quote 
252a 7e				ld a,(hl) 
252b 23				inc hl 
252c fe 22			cp '"' 
252e 28 e1			jr z, .ptoken2 
2530 fe 7f			cp FORTH_END_BUFFER 
2532 28 0c			jr z, .ptokendone2 
2534 fe 00			cp 0 
2536 28 08			jr z, .ptokendone2 
2538 fe 20			cp ' ' 
253a 28 02			jr z, .ptmp2 
253c 18 ec			jr .ptokenstr2 
253e			 
253e			.ptmp2:	; we have a space so change to zero term for dict match later 
253e				;dec hl 
253e				;ld a,"-"	; TODO remove this when working 
253e				;ld (hl), a 
253e				;inc hl 
253e 18 ea			jr .ptokenstr2 
2540			 
2540			.ptokendone2: 
2540				;inc hl 
2540 3e 7f			ld a, FORTH_END_BUFFER 
2542 77				ld (hl),a 
2543 23				inc hl 
2544 3e 21			ld a, '!' 
2546 77				ld (hl),a 
2547			 
2547 2a bf f4			ld hl,(os_tok_ptr) 
254a			         
254a			if DEBUG_FORTH_TOK 
254a						DMARK "TK1" 
254a				CALLMONITOR 
254a			endif 
254a			 
254a				; push exec string to top of return stack 
254a				FORTH_RSP_NEXT 
254a cd ba 20			call macro_forth_rsp_next 
254d				endm 
# End of macro FORTH_RSP_NEXT
254d c9				ret 
254e			 
254e			; 
254e			;	; malloc size + buffer pointer + if is loop flag 
254e			;	ld hl,(os_tok_len) 		 ; get string length 
254e			; 
254e			;	ld a,l 
254e			; 
254e			;	cp 0			; we dont want to use a null string 
254e			;	ret z 
254e			; 
254e			;;	add 3    ; prefix malloc with buffer for current word ptr 
254e			; 
254e			;	add 5     ; TODO when certain not over writing memory remove 
254e			; 
254e			;		 
254e			; 
254e			;if DEBUG_FORTH_TOK 
254e			;			DMARK "TKE" 
254e			;	CALLMONITOR 
254e			;endif 
254e			; 
254e			;	ld l,a 
254e			;	ld h,0 
254e			;;	push hl   ; save required space for the copy later 
254e			;	call malloc 
254e			;if DEBUG_FORTH_TOK 
254e			;			DMARK "TKM" 
254e			;	CALLMONITOR 
254e			;endif 
254e			;	if DEBUG_FORTH_MALLOC_GUARD 
254e			;		push af 
254e			;		call ishlzero 
254e			;;		ld a, l 
254e			;;		add h 
254e			;;		cp 0 
254e			;		pop af 
254e			;		 
254e			;		call z,malloc_error 
254e			;	endif 
254e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
254e			; 
254e			; 
254e			;if DEBUG_FORTH_TOK 
254e			;			DMARK "TKR" 
254e			;	CALLMONITOR 
254e			;endif 
254e			; 
254e			;	FORTH_RSP_NEXT 
254e			; 
254e			;	;inc hl	 ; go past current buffer pointer 
254e			;	;inc hl 
254e			;	;inc hl   ; and past if loop flag 
254e			;		; TODO Need to set flag  
254e			; 
254e			;	 
254e			;	 
254e			;	ex de,hl	; malloc is dest 
254e			;	ld hl, (os_tok_len) 
254e			;;	pop bc 
254e			;	ld c, l                
254e			;	ld b,0 
254e			;	ld hl, (os_tok_ptr) 
254e			; 
254e			;if DEBUG_FORTH_TOK 
254e			;			DMARK "TKT" 
254e			;	CALLMONITOR 
254e			;endif 
254e			; 
254e			;	; do str cpy 
254e			; 
254e			;	ldir      ; copy byte in hl to de 
254e			; 
254e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
254e			; 
254e			;if DEBUG_FORTH_TOK 
254e			; 
254e			;			DMARK "TKY" 
254e			;	CALLMONITOR 
254e			;endif 
254e			;	;ld a,0 
254e			;	;ld a,FORTH_END_BUFFER 
254e			;	ex de, hl 
254e			;	;dec hl			 ; go back over the space delim at the end of word 
254e			;	;ld (hl),a 
254e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
254e			;	ld a,FORTH_END_BUFFER 
254e			;	ld (hl),a 
254e			;	inc hl 
254e			;	ld a,FORTH_END_BUFFER 
254e			;	ld (hl),a 
254e			; 
254e			;	; init the malloc area data 
254e			;	; set pc for in current area 
254e			;	;ld hl, (os_tok_malloc) 
254e			;	;inc hl 
254e			;	;inc hl 
254e			;	;inc hl 
254e			;	;ex de,hl 
254e			;	;ld hl, (os_tok_malloc) 
254e			;	;ld (hl),e 
254e			;	;inc hl 
254e			;	;ld (hl),d 
254e			; 
254e			; 
254e			;	ld hl,(os_tok_malloc) 
254e			;if DEBUG_FORTH_PARSE_KEY 
254e			;			DMARK "TKU" 
254e			;	CALLMONITOR 
254e			;endif 
254e			; 
254e			;	ret 
254e			 
254e			forthexec: 
254e			 
254e			; line exec: 
254e			; forth parser 
254e			 
254e			; 
254e			;       get current exec line on rsp 
254e			 
254e				FORTH_RSP_TOS 
254e cd d1 20			call macro_forth_rsp_tos 
2551				endm 
# End of macro FORTH_RSP_TOS
2551			 
2551			;       restore current pc - hl points to malloc of data 
2551			 
2551				;ld e, (hl) 
2551				;inc hl 
2551				;ld d, (hl) 
2551				;ex de,hl 
2551			 
2551			 
2551			exec1: 
2551 22 bf f4			ld (os_tok_ptr), hl 
2554			 
2554				; copy our PC to working vars  
2554 22 3d fa			ld (cli_ptr), hl 
2557 22 3b fa			ld (cli_origptr), hl 
255a			 
255a 7e				ld a,(hl) 
255b fe 7f			cp FORTH_END_BUFFER 
255d c8				ret z 
255e			 
255e				; skip any nulls 
255e			 
255e fe 00			cp 0 
2560 20 03			jr nz, .execword 
2562 23				inc hl 
2563 18 ec			jr exec1 
2565			 
2565			 
2565			.execword: 
2565			 
2565			 
2565			 
2565			if DEBUG_FORTH_PARSE_KEY 
2565						DMARK "KYQ" 
2565				CALLMONITOR 
2565			endif 
2565			;       while at start of word: 
2565			; get start of dict (in user area first) 
2565			 
2565 21 00 80		ld hl, baseram 
2568			;ld hl, sysdict 
2568 22 3f fa		ld (cli_nextword),hl 
256b			;           match word at pc 
256b			;           exec word 
256b			;           or push to dsp 
256b			;           forward to next token 
256b			;           if line term pop rsp and exit 
256b			;        
256b			 
256b			if DEBUG_FORTH_PARSE_KEY 
256b						DMARK "KYq" 
256b				CALLMONITOR 
256b			endif 
256b			 
256b			; 
256b			; word comp 
256b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
256b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
256b			;    move to start of word  
256b			;    compare word to cli_token 
256b			 
256b			.execpnword:	; HL at start of a word in the dictionary to check 
256b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
256b			;	ld (cli_ptr), hl 
256b			 
256b 2a 3f fa			ld hl,(cli_nextword) 
256e			 
256e cd 11 26			call forth_tok_next 
2571			; tok next start here 
2571			;	; TODO skip compiled symbol for now 
2571			;	inc hl 
2571			; 
2571			;	; save pointer to next word 
2571			; 
2571			;	; hl now points to the address of the next word pointer  
2571			;	ld e, (hl) 
2571			;	inc hl 
2571			;	ld d, (hl) 
2571			;	inc l 
2571			; 
2571			;	ex de,hl 
2571			;if DEBUG_FORTH_PARSE_NEXTWORD 
2571			;	push bc 
2571			;	ld bc, (cli_nextword) 
2571			;			DMARK "NXW" 
2571			;	CALLMONITOR 
2571			;	pop bc 
2571			;endif 
2571			; tok next end here 
2571 22 3f fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2574 eb				ex de, hl 
2575			 
2575			 
2575				; save the pointer of the current token - 1 to check against 
2575				 
2575 22 43 fa			ld (cli_token), hl   
2578				; TODO maybe remove below save if no debug 
2578				; save token string ptr for any debug later 
2578 23				inc hl  
2579 22 45 fa			ld (cli_origtoken), hl 
257c 2b				dec hl 
257d				; save pointer to the start of the next dictionay word 
257d 7e				ld a,(hl)   ; get string length 
257e 47				ld b,a 
257f			.execpnwordinc:  
257f 23				inc hl 
2580 10 fd			djnz .execpnwordinc 
2582 22 41 fa			ld (cli_execword), hl      ; save start of this words code 
2585			 
2585				; now check the word token against the string being parsed 
2585			 
2585 2a 43 fa			ld hl,(cli_token) 
2588 23				inc hl     ; skip string length (use zero term instead to end) 
2589 22 43 fa			ld (cli_token), hl 
258c			 
258c			if DEBUG_FORTH_PARSE_KEY 
258c						DMARK "KY2" 
258c			endif 
258c			if DEBUG_FORTH_PARSE_EXEC 
258c				; see if disabled 
258c			 
258c			;	ld a, (os_view_disable) 
258c			;	cp '*' 
258c				ld a, (debug_vector) 
258c				cp $c9   ; RET  
258c				jr z, .skip 
258c			 
258c				push hl 
258c				push hl 
258c				call clear_display 
258c				ld de, .compword 
258c				ld a, display_row_1 
258c				call str_at_display 
258c				pop de 
258c				ld a, display_row_2 
258c				call str_at_display 
258c				ld hl,(cli_ptr) 
258c				ld a,(hl) 
258c			        ld hl, os_word_scratch 
258c				ld (hl),a 
258c				ld a,0 
258c				inc hl 
258c				ld (hl),a 	 
258c				ld de, os_word_scratch 
258c				ld a, display_row_2+10 
258c				call str_at_display 
258c				call update_display 
258c				ld a, 100 
258c				call aDelayInMS 
258c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
258c				call delay250ms 
258c				endif 
258c				pop hl 
258c			.skip:  
258c			endif	 
258c			.execpnchar:    ; compare char between token and string to parse 
258c			 
258c			if DEBUG_FORTH_PARSE_KEY 
258c						DMARK "Ky3" 
258c			endif 
258c			if DEBUG_FORTH_PARSE_EXEC 
258c				; see if disabled 
258c			 
258c			;	ld a, (os_view_disable) 
258c			;	cp '*' 
258c				ld a, (debug_vector) 
258c				cp $C9  ; RET 
258c				jr z, .skip2 
258c			 
258c			;	call clear_display 
258c			ld hl,(cli_token) 
258c			ld a,(hl) 
258c			ld (os_word_scratch),a 
258c				ld hl,(cli_ptr) 
258c			ld a,(hl) 
258c				ld (os_word_scratch+1),a 
258c				ld a,0 
258c				ld (os_word_scratch+2),a 
258c				ld de,os_word_scratch 
258c				ld a,display_row_4 
258c				call str_at_display 
258c				call update_display 
258c			.skip2:  
258c			endif 
258c 2a 43 fa			ld hl,(cli_token) 
258f 7e				ld a, (hl)	 ; char in word token 
2590 23				inc hl 		; move to next char 
2591 22 43 fa			ld (cli_token), hl ; and save it 
2594 47				ld b,a 
2595			 
2595 2a 3d fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2598 7e				ld a,(hl) 
2599 23				inc hl 
259a 22 3d fa			ld (cli_ptr), hl		; move to next char 
259d cd 25 14			call toUpper 		; make sure the input string matches case 
25a0			 
25a0			if DEBUG_FORTH_PARSE 
25a0			endif 
25a0			 
25a0				; input stream end of token is a space so get rid of it 
25a0			 
25a0			;	cp ' ' 
25a0			;	jr nz, .pnskipspace 
25a0			; 
25a0			;	ld a, 0		; make same term as word token term 
25a0			; 
25a0			;.pnskipspace: 
25a0			 
25a0			if DEBUG_FORTH_PARSE_KEY 
25a0						DMARK "KY7" 
25a0			endif 
25a0 b8				cp b 
25a1 c2 b7 25			jp nz, .execpnskipword	 ; no match so move to next word 
25a4				 
25a4			;    if same 
25a4			;       scan for string terms 0 for token and 32 for input 
25a4			 
25a4				 
25a4			if DEBUG_FORTH_PARSE_KEY 
25a4						DMARK "KY8" 
25a4			endif 
25a4			 
25a4 80				add b			 
25a5 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
25a7							; TODO need to make sure last word in zero term string is accounted for 
25a7 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
25a9			 
25a9			 
25a9				; at end of both strings so both are exact match 
25a9			 
25a9			;       skip ptr for next word 
25a9			 
25a9 2a 3d fa			ld hl,(cli_ptr) 	; at input string term 
25ac 23				inc hl			 ; at next char 
25ad 22 3d fa			ld (cli_ptr), hl     ; save for next round of the parser 
25b0 22 3b fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
25b3				 
25b3				 
25b3			if DEBUG_FORTH_PARSE_KEY 
25b3						DMARK "KY3" 
25b3			endif 
25b3			 
25b3			 
25b3			 
25b3			;       exec code block 
25b3			if DEBUG_FORTH_JP 
25b3				call clear_display 
25b3				call update_display 
25b3				call delay1s 
25b3				ld hl, (cli_execword)     ; save for next check if no match on this word 
25b3				ld a,h 
25b3				ld hl, os_word_scratch 
25b3				call hexout 
25b3				ld hl, (cli_execword)     ; save for next check if no match on this word 
25b3				ld a,l 
25b3				ld hl, os_word_scratch+2 
25b3				call hexout 
25b3				ld hl, os_word_scratch+4 
25b3				ld a,0 
25b3				ld (hl),a 
25b3				ld de,os_word_scratch 
25b3				call str_at_display 
25b3					ld a, display_row_2 
25b3					call str_at_display 
25b3				ld de, (cli_origtoken) 
25b3				ld a, display_row_1+10 
25b3					call str_at_display 
25b3			 
25b3				ld a,display_row_1 
25b3				ld de, .foundword 
25b3				ld a, display_row_3 
25b3				call str_at_display 
25b3				call update_display 
25b3				call delay1s 
25b3				call delay1s 
25b3				call delay1s 
25b3			endif 
25b3			 
25b3			if DEBUG_FORTH_PARSE_KEY 
25b3						DMARK "KYj" 
25b3			endif 
25b3				; TODO save the word pointer in this exec 
25b3			 
25b3 2a 41 fa			ld hl,(cli_execword) 
25b6 e9				jp (hl) 
25b7			 
25b7			 
25b7			;    if not same 
25b7			;	scan for zero term 
25b7			;	get ptr for next word 
25b7			;	goto word comp 
25b7			 
25b7			.execpnskipword:	; get pointer to next word 
25b7 2a 3f fa			ld hl,(cli_nextword) 
25ba			 
25ba 7e				ld a,(hl) 
25bb fe 00			cp WORD_SYS_END 
25bd			;	cp 0 
25bd 28 09			jr z, .execendofdict			 ; at end of words 
25bf			 
25bf			if DEBUG_FORTH_PARSE_KEY 
25bf						DMARK "KY4" 
25bf			endif 
25bf			if DEBUG_FORTH_PARSE_EXEC 
25bf			 
25bf				; see if disabled 
25bf			 
25bf			;	ld a, (os_view_disable) 
25bf			;	cp '*' 
25bf				ld a,(debug_vector) 
25bf				cp $c9   ; RET 
25bf				jr z, .noskip 
25bf			 
25bf			 
25bf				ld de, .nowordfound 
25bf				ld a, display_row_3 
25bf				call str_at_display 
25bf				call update_display 
25bf				ld a, 100 
25bf				call aDelayInMS 
25bf				 
25bf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25bf					call delay250ms 
25bf				endif 
25bf			.noskip:  
25bf			 
25bf			endif	 
25bf			 
25bf 2a 3b fa			ld hl,(cli_origptr) 
25c2 22 3d fa			ld (cli_ptr),hl 
25c5			 
25c5			if DEBUG_FORTH_PARSE_KEY 
25c5						DMARK "KY5" 
25c5			endif 
25c5 c3 6b 25			jp .execpnword			; else go to next word 
25c8			 
25c8			.execendofdict:  
25c8			 
25c8			if DEBUG_FORTH_PARSE_KEY 
25c8						DMARK "KYe" 
25c8			endif 
25c8			if DEBUG_FORTH_PARSE_EXEC 
25c8				; see if disabled 
25c8			 
25c8			;	ld a, (os_view_disable) 
25c8			;	cp '*' 
25c8				ld a,(debug_vector) 
25c8				cp $c9   ; ret 
25c8				jr z, .ispskip 
25c8			 
25c8				call clear_display 
25c8				call update_display 
25c8				call delay1s 
25c8				ld de, (cli_origptr) 
25c8				ld a, display_row_1 
25c8				call str_at_display 
25c8				 
25c8				ld de, .enddict 
25c8				ld a, display_row_3 
25c8				call str_at_display 
25c8				call update_display 
25c8				ld a, 100 
25c8				call aDelayInMS 
25c8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25c8				call delay1s 
25c8				call delay1s 
25c8				call delay1s 
25c8				endif 
25c8			.ispskip:  
25c8				 
25c8			endif	 
25c8			 
25c8			 
25c8			 
25c8				; if the word is not a keyword then must be a literal so push it to stack 
25c8			 
25c8			; push token to stack to end of word 
25c8			 
25c8				STACKFRAME ON $1efe $2f9f 
25c8				if DEBUG_STACK_IMB 
25c8					if ON 
25c8						exx 
25c8						ld de, $1efe 
25c8						ld a, d 
25c8						ld hl, curframe 
25c8						call hexout 
25c8						ld a, e 
25c8						ld hl, curframe+2 
25c8						call hexout 
25c8						ld hl, $1efe 
25c8						push hl 
25c8						ld hl, $2f9f 
25c8						push hl 
25c8						exx 
25c8					endif 
25c8				endif 
25c8			endm 
# End of macro STACKFRAME
25c8			 
25c8 2a bf f4		ld hl,(os_tok_ptr) 
25cb cd 7c 22		call forth_apush 
25ce			 
25ce				STACKFRAMECHK ON $1efe $2f9f 
25ce				if DEBUG_STACK_IMB 
25ce					if ON 
25ce						exx 
25ce						ld hl, $2f9f 
25ce						pop de   ; $2f9f 
25ce						call cmp16 
25ce						jr nz, .spnosame 
25ce						ld hl, $1efe 
25ce						pop de   ; $1efe 
25ce						call cmp16 
25ce						jr z, .spfrsame 
25ce						.spnosame: call showsperror 
25ce						.spfrsame: nop 
25ce						exx 
25ce					endif 
25ce				endif 
25ce			endm 
# End of macro STACKFRAMECHK
25ce			 
25ce			execnext: 
25ce			 
25ce			if DEBUG_FORTH_PARSE_KEY 
25ce						DMARK "KY>" 
25ce			endif 
25ce			; move past token to next word 
25ce			 
25ce 2a bf f4		ld hl, (os_tok_ptr) 
25d1 3e 00		ld a, 0 
25d3 01 ff 00		ld bc, 255     ; input buffer size 
25d6 ed b1		cpir 
25d8			 
25d8			if DEBUG_FORTH_PARSE_KEY 
25d8						DMARK "KY!" 
25d8				CALLMONITOR 
25d8			endif	 
25d8			; TODO this might place hl on the null, so will need to forward on??? 
25d8			;inc hl   ; see if this gets onto the next item 
25d8			 
25d8			 
25d8			; TODO pass a pointer to the buffer to push 
25d8			; TODO call function to push 
25d8			 
25d8			; look for end of input 
25d8			 
25d8			;inc hl 
25d8			;ld a,(hl) 
25d8			;cp FORTH_END_BUFFER 
25d8			;ret z 
25d8			 
25d8			 
25d8 c3 51 25		jp exec1 
25db			 
25db			 
25db			 
25db			 
25db			 
25db			 
25db			 
25db			 
25db			 
25db			findnexttok: 
25db			 
25db				; hl is pointer to move 
25db				; de is the token to locate 
25db			 
25db					if DEBUG_FORTH 
25db						DMARK "NTK" 
25db						CALLMONITOR 
25db					endif 
25db d5				push de 
25dc			 
25dc			.fnt1:	 
25dc				; find first char of token to locate 
25dc			 
25dc 1a				ld a, (de) 
25dd 4f				ld c,a 
25de 7e				ld a,(hl) 
25df cd 25 14			call toUpper 
25e2					if DEBUG_FORTH 
25e2						DMARK "NT1" 
25e2						CALLMONITOR 
25e2					endif 
25e2 b9				cp c 
25e3			 
25e3 28 03			jr z, .fnt2cmpmorefirst	 
25e5			 
25e5				; first char not found move to next char 
25e5			 
25e5 23				inc hl 
25e6 18 f4			jr .fnt1 
25e8			 
25e8			.fnt2cmpmorefirst:	 
25e8				; first char of token found.  
25e8			 
25e8 e5				push hl     ; save start of token just in case it is the right one 
25e9 d9				exx 
25ea e1				pop hl        ; save it to hl' 
25eb d9				exx 
25ec			 
25ec			 
25ec			.fnt2cmpmore:	 
25ec				; compare the rest 
25ec				 
25ec 23				inc hl 
25ed 13				inc de 
25ee				 
25ee 1a				ld a, (de) 
25ef 4f				ld c,a 
25f0 7e				ld a,(hl) 
25f1 cd 25 14			call toUpper 
25f4			 
25f4					if DEBUG_FORTH 
25f4						DMARK "NT2" 
25f4						CALLMONITOR 
25f4					endif 
25f4				; c has the token to find char 
25f4				; a has the mem to scan char 
25f4			 
25f4 b9				cp c 
25f5 28 04			jr z,.fntmatch1 
25f7			 
25f7				; they are not the same 
25f7			 
25f7					if DEBUG_FORTH 
25f7						DMARK "NT3" 
25f7						CALLMONITOR 
25f7					endif 
25f7 d1				pop de	; reset de token to look for 
25f8 d5				push de 
25f9 18 e1			jr .fnt1 
25fb				 
25fb			.fntmatch1: 
25fb			 
25fb				; is the same char a null which means we might have a full hit? 
25fb					if DEBUG_FORTH 
25fb						DMARK "NT4" 
25fb						CALLMONITOR 
25fb					endif 
25fb			 
25fb fe 00			cp 0 
25fd 28 0b			jr z, .fntmatchyes 
25ff			 
25ff				; are we at the end of the token to find? 
25ff			 
25ff					if DEBUG_FORTH 
25ff						DMARK "NT5" 
25ff						CALLMONITOR 
25ff					endif 
25ff 3e 00			ld a, 0 
2601 b9				cp c 
2602			 
2602 c2 ec 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2605			 
2605					if DEBUG_FORTH 
2605						DMARK "NT6" 
2605						CALLMONITOR 
2605					endif 
2605				; token to find is exhusted but no match to stream 
2605			 
2605				; restore tok pointer and continue on 
2605 d1				pop de 
2606 d5				push de 
2607 c3 dc 25			jp .fnt1 
260a			 
260a			 
260a			.fntmatchyes: 
260a			 
260a				; hl now contains the end of the found token 
260a			 
260a				; get rid of saved token pointer to find 
260a			 
260a d1				pop de 
260b			 
260b					if DEBUG_FORTH 
260b						DMARK "NT9" 
260b						CALLMONITOR 
260b					endif 
260b			 
260b				; hl will be on the null term so forward on 
260b			 
260b				; get back the saved start of the token 
260b			 
260b d9				exx 
260c e5				push hl     ; save start of token just in case it is the right one 
260d d9				exx 
260e e1				pop hl        ; save it to hl 
260f			 
260f c9				ret 
2610			 
2610			 
2610			; LIST needs to find a specific token   
2610			; FORGET needs to find a spefici token 
2610			 
2610			; SAVE needs to find all tokens by flag 
2610			; WORDS just needs to scan through all  by flag 
2610			; UWORDS needs to scan through all by flag 
2610			 
2610			 
2610			; given hl as pointer to start of dict look up string 
2610			; return hl as pointer to start of word block 
2610			; or 0 if not found 
2610			 
2610			forth_find_tok: 
2610 c9				ret 
2611			 
2611			; given hl as pointer to dict structure 
2611			; move to the next dict block structure 
2611			 
2611			forth_tok_next: 
2611				; hl now points to the address of the next word pointer  
2611				; TODO skip compiled symbol for now 
2611			;	push de 
2611 23				inc hl 
2612 5e				ld e, (hl) 
2613 23				inc hl 
2614 56				ld d, (hl) 
2615 23				inc hl 
2616			 
2616 eb				ex de,hl 
2617			if DEBUG_FORTH_PARSE_NEXTWORD 
2617				push bc 
2617				ld bc, (cli_nextword) 
2617						DMARK "NXW" 
2617				CALLMONITOR 
2617				pop bc 
2617			endif 
2617			;	pop de	 
2617 c9				ret 
2618			 
2618			 
2618			 
2618			; eof 
# End of file forth_parserv5.asm
2618				include "forth_wordsv4.asm" 
2618			 
2618			; the core word dictionary v4 
2618			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2618			 
2618			; this is a linked list for each of the system words used 
2618			; user defined words will follow the same format but will be in ram 
2618			 
2618			 
2618			; 
2618			; 
2618			; define linked list: 
2618			; 
2618			; 1. compiled byte op code 
2618			; 2. len of text word 
2618			; 3. text word 
2618			; 4. ptr to next dictionary word 
2618			; 5. asm, calls etc for the word 
2618			; 
2618			;  if 1 == 0 then last word in dict  
2618			;   
2618			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2618			;  
2618			;  
2618			; create basic standard set of words 
2618			; 
2618			;  
2618			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2618			; 2DUP 2DROP 2SWAP  
2618			; @ C@ - get byte  
2618			; ! C! - store byte 
2618			; 0< true if less than zero 
2618			; 0= true if zero 
2618			; < >  
2618			; = true if same 
2618			; variables 
2618			 
2618			 
2618			; Hardware specific words I may need 
2618			; 
2618			; IN OUT  
2618			; calls to key util functions 
2618			; calls to hardward abstraction stuff 
2618			; easy control of frame buffers and lcd i/o 
2618			; keyboard  
2618			 
2618			 
2618			;DICT: macro 
2618			; op_code, len, word, next 
2618			;    word: 
2618			;    db op_code 
2618			;    ds word zero term 
2618			;    dw next 
2618			;    endm 
2618			 
2618			 
2618			 
2618			 
2618			; op code 1 is a flag for user define words which are to be handled differently 
2618			 
2618			 
2618			; 
2618			; 
2618			;    TODO on entry to a word this should be the expected environment 
2618			;    hl - tos value if number then held, if string this is the ptr 
2618			;    de -  
2618			 
2618			 
2618			; opcode ranges 
2618			; 0 - end of word dict 
2618			; 255 - user define words 
2618			 
2618			sysdict: 
2618			include "forth_opcodes.asm" 
2618			; op codes for forth keywords 
2618			; free to use code 0  
2618				OPCODE_HEAP: equ  1 
2618				OPCODE_EXEC: equ 2 
2618				OPCODE_DUP: equ 3 
2618				OPCODE_SWAP: equ 4 
2618				OPCODE_COLN: equ 5 
2618				OPCODE_SCOLN: equ 6 
2618				OPCODE_DROP: equ 7 
2618				OPCODE_DUP2: equ 8 
2618				OPCODE_DROP2: equ 9 
2618				OPCODE_SWAP2: equ 10 
2618				OPCODE_AT: equ 11 
2618				OPCODE_CAT: equ 12 
2618				OPCODE_BANG: equ 13 
2618				OPCODE_CBANG: equ 14 
2618				OPCODE_SCALL: equ 15 
2618				OPCODE_DEPTH: equ 16 
2618				OPCODE_OVER: equ 17 
2618				OPCODE_PAUSE: equ 18 
2618				OPCODE_PAUSES: equ 19 
2618				OPCODE_ROT: equ 20 
2618			;free to reuse	OPCODE_WORDS: equ 21 
2618			        OPCODE_NOT: equ 21 
2618				OPCODE_UWORDS: equ 22 
2618				OPCODE_BP: equ 23 
2618				OPCODE_MONITOR: equ 24  
2618				OPCODE_MALLOC: equ 25 
2618				OPCODE_FREE: equ 26 
2618				OPCODE_LIST: equ 27 
2618				OPCODE_FORGET: equ 28 
2618				OPCODE_NOP: equ 29 
2618				OPCODE_COMO: equ 30 
2618				OPCODE_COMC: equ 31 
2618			;free to reuse	OPCODE_ENDCORE: equ 32 
2618				OPCODE_AFTERSOUND: equ 33 
2618				OPCODE_GP2: equ 34 
2618				OPCODE_GP3: equ 35 
2618				OPCODE_GP4: equ 36 
2618				OPCODE_SIN: equ 37 
2618				OPCODE_SOUT: equ 38 
2618				OPCODE_SPIO: equ 39 
2618				OPCODE_SPICEH: equ 40 
2618				OPCODE_SPIOb: equ 41 
2618				OPCODE_SPII: equ 42 
2618				OPCODE_SESEL: equ 43 
2618				OPCODE_CARTDEV: equ 44 
2618			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2618				OPCODE_FB: equ 46 
2618				OPCODE_EMIT: equ 47 
2618				OPCODE_DOTH: equ 48 
2618				OPCODE_DOTF: equ 49 
2618				OPCODE_DOT: equ 50 
2618				OPCODE_CLS: equ 51 
2618				OPCODE_DRAW: equ 52 
2618				OPCODE_DUMP: equ 53 
2618				OPCODE_CDUMP: equ 54 
2618				OPCODE_DAT: equ 55 
2618				OPCODE_HOME: equ 56 
2618				OPCODE_SPACE: equ 57 
2618				OPCODE_SPACES: equ 58 
2618				OPCODE_SCROLL: equ 59 
2618				OPCODE_ATQ: equ 60 
2618				OPCODE_AUTODSP: equ 61 
2618				OPCODE_MENU: equ 62 
2618			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2618				OPCODE_THEN: equ 64 
2618				OPCODE_ELSE: equ 65 
2618				OPCODE_DO: equ 66 
2618				OPCODE_LOOP: equ 67 
2618				OPCODE_I: equ 68 
2618				OPCODE_DLOOP: equ 69  
2618				OPCODE_REPEAT: equ 70  
2618				OPCODE_UNTIL: equ 71 
2618				OPCODE_ENDFLOW: equ 72 
2618				OPCODE_WAITK: equ 73 
2618				OPCODE_ACCEPT: equ 74 
2618				OPCODE_EDIT: equ 75 
2618			;free to reuse	OPCODE_ENDKEY: equ 76 
2618				OPCODE_LZERO: equ 77 
2618				OPCODE_TZERO: equ 78 
2618				OPCODE_LESS: equ 79 
2618				OPCODE_GT: equ 80 
2618				OPCODE_EQUAL: equ 81  
2618			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2618				OPCODE_NEG: equ 83 
2618				OPCODE_DIV: equ 84 
2618				OPCODE_MUL: equ 85 
2618				OPCODE_MIN: equ 86 
2618				OPCODE_MAX: equ 87 
2618				OPCODE_RND16: equ 88 
2618				OPCODE_RND8: equ 89 
2618				OPCODE_RND: equ 90 
2618			;free to reuse	OPCODE_ENDMATHS: equ 91  
2618				OPCODE_BYNAME: equ 92 
2618				OPCODE_DIR: equ 93 
2618				OPCODE_SAVE: equ 94 
2618				OPCODE_LOAD: equ 95 
2618				OPCODE_BSAVE: equ 96 
2618				OPCODE_BLOAD: equ 97 
2618				OPCODE_SEO: equ 98  
2618				OPCODE_SEI: equ 99 
2618				OPCODE_SFREE: equ 100 
2618				OPCODE_SIZE: equ 101 
2618				OPCODE_CREATE: equ 102 
2618				OPCODE_APPEND: equ 103 
2618				OPCODE_SDEL: equ 104 
2618				OPCODE_OPEN: equ 105 
2618				OPCODE_READ: equ 106 
2618				OPCODE_EOF: equ 106 
2618				OPCODE_FORMAT: equ 107 
2618				OPCODE_LABEL: equ 108 
2618				OPCODE_LABELS: equ 109 
2618			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2618				OPCODE_UPPER: equ 111 
2618				OPCODE_LOWER: equ 112 
2618				OPCODE_SUBSTR: equ 113 
2618				OPCODE_LEFT: equ 114 
2618				OPCODE_RIGHT: equ 115 
2618				OPCODE_STR2NUM: equ 116 
2618				OPCODE_NUM2STR: equ 117 
2618				OPCODE_CONCAT: equ 118 
2618				OPCODE_FIND: equ 119 
2618				OPCODE_LEN: equ 120 
2618				OPCODE_CHAR: equ 121 
2618			; free to reuse	OPCODE_STRLEN: equ 122 
2618			; free to reuse	OPCODE_ENDSTR: equ 123 
2618				OPCODE_V0S: equ 124 
2618				OPCODE_V0Q: equ 125 
2618				OPCODE_V1S: equ 126 
2618				OPCODE_V1Q: equ 127 
2618				OPCODE_V2S: equ 128 
2618				OPCODE_V2Q: equ 129 
2618				OPCODE_V3S: equ 130 
2618				OPCODE_V3Q: equ 131 
2618			;free to reuse	OPCODE_END: equ 132 
2618				OPCODE_ZDUP: equ 133 
2618			 
2618			; eof 
# End of file forth_opcodes.asm
2618			 
2618			include "forth_words_core.asm" 
2618			 
2618			; | ## Core Words 
2618			 
2618			;if MALLOC_4 
2618			 
2618			.HEAP: 
2618				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2618 15				db WORD_SYS_CORE+OPCODE_HEAP             
2619 57 26			dw .EXEC            
261b 05				db 4 + 1 
261c .. 00			db "HEAP",0              
2621				endm 
# End of macro CWHEAD
2621			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2621			; | | u1 - Current number of bytes in the heap 
2621			; | | u2 - Remaining bytes left on the heap 
2621			; | |  
2621			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2621			 
2621			 
2621					if DEBUG_FORTH_WORDS_KEY 
2621						DMARK "HEP" 
2621 f5				push af  
2622 3a 36 26			ld a, (.dmark)  
2625 32 68 fe			ld (debug_mark),a  
2628 3a 37 26			ld a, (.dmark+1)  
262b 32 69 fe			ld (debug_mark+1),a  
262e 3a 38 26			ld a, (.dmark+2)  
2631 32 6a fe			ld (debug_mark+2),a  
2634 18 03			jr .pastdmark  
2636 ..			.dmark: db "HEP"  
2639 f1			.pastdmark: pop af  
263a			endm  
# End of macro DMARK
263a						CALLMONITOR 
263a cd 6c fe			call debug_vector  
263d				endm  
# End of macro CALLMONITOR
263d					endif 
263d 2a 0a 80				ld hl, (free_list )      
2640 11 0e 80				ld de, heap_start 
2643			 
2643 ed 52				sbc hl, de  
2645			 
2645 cd 13 21				call forth_push_numhl 
2648			 
2648			 
2648 ed 5b 0a 80			ld de, (free_list )      
264c 21 a5 f1				ld hl, heap_end 
264f			 
264f ed 52				sbc hl, de 
2651			 
2651 cd 13 21				call forth_push_numhl 
2654					 
2654			 
2654					 
2654			 
2654			 
2654			 
2654					NEXTW 
2654 c3 c0 24			jp macro_next 
2657				endm 
# End of macro NEXTW
2657			;endif 
2657			 
2657			.EXEC: 
2657			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2657			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2657			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2657			;; > > 
2657			;; > >   
2657			;	STACKFRAME OFF $5efe $5f9f 
2657			; 
2657			;		if DEBUG_FORTH_WORDS_KEY 
2657			;			DMARK "EXE" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			; 
2657			;	FORTH_DSP_VALUEHL 
2657			; 
2657			;	FORTH_DSP_POP 
2657			; 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EX1" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;;	ld e,(hl) 
2657			;;	inc hl 
2657			;;	ld d,(hl) 
2657			;;	ex de,hl 
2657			; 
2657			;;		if DEBUG_FORTH_WORDS 
2657			;;			DMARK "EX2" 
2657			;;			CALLMONITOR 
2657			;;		endif 
2657			;	push hl 
2657			; 
2657			;	;ld a, 0 
2657			;	;ld a, FORTH_END_BUFFER 
2657			;	call strlenz 
2657			;	inc hl   ; include zero term to copy 
2657			;	inc hl   ; include term 
2657			;	inc hl   ; include term 
2657			;	ld b,0 
2657			;	ld c,l 
2657			;	pop hl 
2657			;	ld de, execscratch 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EX3" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;	ldir 
2657			; 
2657			; 
2657			;	ld hl, execscratch 
2657			; 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EXe" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			; 
2657			;	call forthparse 
2657			;	call forthexec 
2657			;;	call forthexec_cleanup 
2657			;;	call forthparse 
2657			;;	call forthexec 
2657			; 
2657			;	STACKFRAMECHK OFF $5efe $5f9f 
2657			; 
2657			;	; an immediate word so no need to process any more words 
2657			;	ret 
2657			;	NEXTW 
2657			 
2657			; dead code - old version  
2657			;	FORTH_RSP_NEXT 
2657			 
2657			;  
2657			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2657			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2657			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2657			;	push hl 
2657			;	push de 
2657			;	push bc 
2657			; 
2657			; 
2657			;		if DEBUG_FORTH_WORDS_KEY 
2657			;			DMARK "EXR" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			; 
2657			; 
2657			; 
2657			;	;v5 FORTH_DSP_VALUE 
2657			;	FORTH_DSP_VALUEHL 
2657			; 
2657			;	; TODO do string type checks 
2657			; 
2657			;;v5	inc hl   ; skip type 
2657			; 
2657			;	push hl  ; source code  
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EX1" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;	ld a, 0 
2657			;	call strlent 
2657			; 
2657			;	inc hl 
2657			;	inc hl 
2657			;	inc hl 
2657			;	inc hl 
2657			; 
2657			;	push hl    ; size 
2657			; 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EX2" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;	call malloc 
2657			; 
2657			;	ex de, hl    ; de now contains malloc area 
2657			;	pop bc   	; get byte count 
2657			;	pop hl      ; get string to copy 
2657			; 
2657			;	push de     ; save malloc for free later 
2657			; 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EX3" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;	ldir       ; duplicate string 
2657			; 
2657			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2657			;	 
2657			;	; TODO fix the parse would be better than this...  
2657			;	ex de, hl 
2657			;	dec hl 
2657			;	ld a, 0 
2657			;	ld (hl), a 
2657			;	dec hl 
2657			;	ld a, ' ' 
2657			;	ld (hl), a 
2657			;	dec hl 
2657			;	ld (hl), a 
2657			; 
2657			;	dec hl 
2657			;	ld (hl), a 
2657			; 
2657			; 
2657			;	FORTH_DSP_POP  
2657			; 
2657			;	pop hl     
2657			;	push hl    ; save malloc area 
2657			; 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EX4" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			; 
2657			;	call forthparse 
2657			;	call forthexec 
2657			;	 
2657			;	pop hl 
2657			;	if DEBUG_FORTH_WORDS 
2657			;		DMARK "EX5" 
2657			;		CALLMONITOR 
2657			;	endif 
2657			; 
2657			;	if FORTH_ENABLE_FREE 
2657			;	call free 
2657			;	endif 
2657			; 
2657			;	if DEBUG_FORTH_WORDS 
2657			;		DMARK "EX6" 
2657			;		CALLMONITOR 
2657			;	endif 
2657			; 
2657			;	pop bc 
2657			;	pop de 
2657			;	pop hl 
2657			;;	FORTH_RSP_POP	  
2657			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2657			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2657			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2657			; 
2657			;	if DEBUG_FORTH_WORDS 
2657			;		DMARK "EX7" 
2657			;		CALLMONITOR 
2657			;	endif 
2657			;	NEXTW 
2657			 
2657			;.STKEXEC: 
2657			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2657			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2657			; 
2657			; 
2657			;		if DEBUG_FORTH_WORDS_KEY 
2657			;			DMARK "STX" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			; 
2657			;	FORTH_DSP_VALUEHL 
2657			; 
2657			;	ld (store_tmp1), hl    ; count 
2657			; 
2657			;	FORTH_DSP_POP 
2657			;.stkexec1: 
2657			;	ld hl, (store_tmp1)   ; count 
2657			;	ld a, 0 
2657			;	cp l 
2657			;	ret z 
2657			; 
2657			;	dec hl 
2657			;	ld (store_tmp1), hl    ; count 
2657			;	 
2657			;	FORTH_DSP_VALUEHL 
2657			;	push hl 
2657			;	 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EXp" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;	FORTH_DSP_POP 
2657			; 
2657			;	call strlenz 
2657			;	inc hl   ; include zero term to copy 
2657			;	inc hl   ; include zero term to copy 
2657			;	inc hl   ; include zero term to copy 
2657			;	ld b,0 
2657			;	ld c,l 
2657			;	pop hl 
2657			;	ld de, execscratch 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EX3" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;	ldir 
2657			; 
2657			; 
2657			;	ld hl, execscratch 
2657			; 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EXP" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			; 
2657			;	call forthparse 
2657			;	ld hl, execscratch 
2657			;		if DEBUG_FORTH_WORDS 
2657			;			DMARK "EXx" 
2657			;			CALLMONITOR 
2657			;		endif 
2657			;	call forthexec 
2657			; 
2657			;	jp .stkexec1 
2657			; 
2657			;	ret 
2657			 
2657			 
2657			.DUP: 
2657				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2657 17				db WORD_SYS_CORE+OPCODE_DUP             
2658 cd 26			dw .ZDUP            
265a 04				db 3 + 1 
265b .. 00			db "DUP",0              
265f				endm 
# End of macro CWHEAD
265f			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
265f			 
265f					if DEBUG_FORTH_WORDS_KEY 
265f						DMARK "DUP" 
265f f5				push af  
2660 3a 74 26			ld a, (.dmark)  
2663 32 68 fe			ld (debug_mark),a  
2666 3a 75 26			ld a, (.dmark+1)  
2669 32 69 fe			ld (debug_mark+1),a  
266c 3a 76 26			ld a, (.dmark+2)  
266f 32 6a fe			ld (debug_mark+2),a  
2672 18 03			jr .pastdmark  
2674 ..			.dmark: db "DUP"  
2677 f1			.pastdmark: pop af  
2678			endm  
# End of macro DMARK
2678						CALLMONITOR 
2678 cd 6c fe			call debug_vector  
267b				endm  
# End of macro CALLMONITOR
267b					endif 
267b			 
267b					FORTH_DSP 
267b cd d0 22			call macro_forth_dsp 
267e				endm 
# End of macro FORTH_DSP
267e			 
267e 7e					ld a, (HL) 
267f fe 01				cp DS_TYPE_STR 
2681 20 25				jr nz, .dupinum 
2683			 
2683					; push another string 
2683			 
2683					FORTH_DSP_VALUEHL     		 
2683 cd 0a 23			call macro_dsp_valuehl 
2686				endm 
# End of macro FORTH_DSP_VALUEHL
2686			 
2686				if DEBUG_FORTH_WORDS 
2686					DMARK "DUs" 
2686 f5				push af  
2687 3a 9b 26			ld a, (.dmark)  
268a 32 68 fe			ld (debug_mark),a  
268d 3a 9c 26			ld a, (.dmark+1)  
2690 32 69 fe			ld (debug_mark+1),a  
2693 3a 9d 26			ld a, (.dmark+2)  
2696 32 6a fe			ld (debug_mark+2),a  
2699 18 03			jr .pastdmark  
269b ..			.dmark: db "DUs"  
269e f1			.pastdmark: pop af  
269f			endm  
# End of macro DMARK
269f					CALLMONITOR 
269f cd 6c fe			call debug_vector  
26a2				endm  
# End of macro CALLMONITOR
26a2				endif 
26a2 cd 81 21				call forth_push_str 
26a5			 
26a5					NEXTW 
26a5 c3 c0 24			jp macro_next 
26a8				endm 
# End of macro NEXTW
26a8			 
26a8			 
26a8			.dupinum: 
26a8					 
26a8			 
26a8			 
26a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26a8 cd 0a 23			call macro_dsp_valuehl 
26ab				endm 
# End of macro FORTH_DSP_VALUEHL
26ab			 
26ab				; TODO add floating point number detection 
26ab			 
26ab				if DEBUG_FORTH_WORDS 
26ab					DMARK "DUi" 
26ab f5				push af  
26ac 3a c0 26			ld a, (.dmark)  
26af 32 68 fe			ld (debug_mark),a  
26b2 3a c1 26			ld a, (.dmark+1)  
26b5 32 69 fe			ld (debug_mark+1),a  
26b8 3a c2 26			ld a, (.dmark+2)  
26bb 32 6a fe			ld (debug_mark+2),a  
26be 18 03			jr .pastdmark  
26c0 ..			.dmark: db "DUi"  
26c3 f1			.pastdmark: pop af  
26c4			endm  
# End of macro DMARK
26c4					CALLMONITOR 
26c4 cd 6c fe			call debug_vector  
26c7				endm  
# End of macro CALLMONITOR
26c7				endif 
26c7			 
26c7 cd 13 21				call forth_push_numhl 
26ca					NEXTW 
26ca c3 c0 24			jp macro_next 
26cd				endm 
# End of macro NEXTW
26cd			.ZDUP: 
26cd				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26cd 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26ce 05 27			dw .SWAP            
26d0 05				db 4 + 1 
26d1 .. 00			db "?DUP",0              
26d6				endm 
# End of macro CWHEAD
26d6			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26d6			 
26d6					if DEBUG_FORTH_WORDS_KEY 
26d6						DMARK "qDU" 
26d6 f5				push af  
26d7 3a eb 26			ld a, (.dmark)  
26da 32 68 fe			ld (debug_mark),a  
26dd 3a ec 26			ld a, (.dmark+1)  
26e0 32 69 fe			ld (debug_mark+1),a  
26e3 3a ed 26			ld a, (.dmark+2)  
26e6 32 6a fe			ld (debug_mark+2),a  
26e9 18 03			jr .pastdmark  
26eb ..			.dmark: db "qDU"  
26ee f1			.pastdmark: pop af  
26ef			endm  
# End of macro DMARK
26ef						CALLMONITOR 
26ef cd 6c fe			call debug_vector  
26f2				endm  
# End of macro CALLMONITOR
26f2					endif 
26f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f2 cd 0a 23			call macro_dsp_valuehl 
26f5				endm 
# End of macro FORTH_DSP_VALUEHL
26f5			 
26f5 e5					push hl 
26f6			 
26f6					; is it a zero? 
26f6			 
26f6 3e 00				ld a, 0 
26f8 84					add h 
26f9 85					add l 
26fa			 
26fa e1					pop hl 
26fb			 
26fb fe 00				cp 0 
26fd 28 03				jr z, .dup2orig 
26ff			 
26ff			 
26ff cd 13 21				call forth_push_numhl 
2702			 
2702			 
2702				; TODO add floating point number detection 
2702			 
2702			.dup2orig: 
2702			 
2702					NEXTW 
2702 c3 c0 24			jp macro_next 
2705				endm 
# End of macro NEXTW
2705			.SWAP: 
2705				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2705 18				db WORD_SYS_CORE+OPCODE_SWAP             
2706 44 27			dw .COLN            
2708 05				db 4 + 1 
2709 .. 00			db "SWAP",0              
270e				endm 
# End of macro CWHEAD
270e			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
270e					if DEBUG_FORTH_WORDS_KEY 
270e						DMARK "SWP" 
270e f5				push af  
270f 3a 23 27			ld a, (.dmark)  
2712 32 68 fe			ld (debug_mark),a  
2715 3a 24 27			ld a, (.dmark+1)  
2718 32 69 fe			ld (debug_mark+1),a  
271b 3a 25 27			ld a, (.dmark+2)  
271e 32 6a fe			ld (debug_mark+2),a  
2721 18 03			jr .pastdmark  
2723 ..			.dmark: db "SWP"  
2726 f1			.pastdmark: pop af  
2727			endm  
# End of macro DMARK
2727						CALLMONITOR 
2727 cd 6c fe			call debug_vector  
272a				endm  
# End of macro CALLMONITOR
272a					endif 
272a			 
272a					FORTH_DSP_VALUEHL 
272a cd 0a 23			call macro_dsp_valuehl 
272d				endm 
# End of macro FORTH_DSP_VALUEHL
272d e5					push hl     ; w2 
272e			 
272e					FORTH_DSP_POP 
272e cd c2 23			call macro_forth_dsp_pop 
2731				endm 
# End of macro FORTH_DSP_POP
2731			 
2731					FORTH_DSP_VALUEHL 
2731 cd 0a 23			call macro_dsp_valuehl 
2734				endm 
# End of macro FORTH_DSP_VALUEHL
2734			 
2734					FORTH_DSP_POP 
2734 cd c2 23			call macro_forth_dsp_pop 
2737				endm 
# End of macro FORTH_DSP_POP
2737			 
2737 d1					pop de     ; w2	, hl = w1 
2738			 
2738 eb					ex de, hl 
2739 d5					push de 
273a			 
273a cd 13 21				call forth_push_numhl 
273d			 
273d e1					pop hl 
273e			 
273e cd 13 21				call forth_push_numhl 
2741					 
2741			 
2741					NEXTW 
2741 c3 c0 24			jp macro_next 
2744				endm 
# End of macro NEXTW
2744			.COLN: 
2744				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2744 19				db WORD_SYS_CORE+OPCODE_COLN             
2745 d0 28			dw .SCOLN            
2747 02				db 1 + 1 
2748 .. 00			db ":",0              
274a				endm 
# End of macro CWHEAD
274a			; | : ( -- )         Create new word | DONE 
274a			 
274a					if DEBUG_FORTH_WORDS_KEY 
274a						DMARK "CLN" 
274a f5				push af  
274b 3a 5f 27			ld a, (.dmark)  
274e 32 68 fe			ld (debug_mark),a  
2751 3a 60 27			ld a, (.dmark+1)  
2754 32 69 fe			ld (debug_mark+1),a  
2757 3a 61 27			ld a, (.dmark+2)  
275a 32 6a fe			ld (debug_mark+2),a  
275d 18 03			jr .pastdmark  
275f ..			.dmark: db "CLN"  
2762 f1			.pastdmark: pop af  
2763			endm  
# End of macro DMARK
2763						CALLMONITOR 
2763 cd 6c fe			call debug_vector  
2766				endm  
# End of macro CALLMONITOR
2766					endif 
2766				STACKFRAME OFF $8efe $989f 
2766				if DEBUG_STACK_IMB 
2766					if OFF 
2766						exx 
2766						ld de, $8efe 
2766						ld a, d 
2766						ld hl, curframe 
2766						call hexout 
2766						ld a, e 
2766						ld hl, curframe+2 
2766						call hexout 
2766						ld hl, $8efe 
2766						push hl 
2766						ld hl, $989f 
2766						push hl 
2766						exx 
2766					endif 
2766				endif 
2766			endm 
# End of macro STACKFRAME
2766				; get parser buffer length  of new word 
2766			 
2766				 
2766			 
2766					; move tok past this to start of name defintition 
2766					; TODO get word to define 
2766					; TODO Move past word token 
2766					; TODO get length of string up to the ';' 
2766			 
2766 2a bf f4			ld hl, (os_tok_ptr) 
2769 23				inc hl 
276a 23				inc hl 
276b			 
276b 3e 3b			ld a, ';' 
276d cd 39 14			call strlent 
2770			 
2770 7d				ld a,l 
2771 32 ba f1			ld (os_new_parse_len), a 
2774			 
2774			 
2774			if DEBUG_FORTH_UWORD 
2774 ed 5b bf f4		ld de, (os_tok_ptr) 
2778						DMARK ":01" 
2778 f5				push af  
2779 3a 8d 27			ld a, (.dmark)  
277c 32 68 fe			ld (debug_mark),a  
277f 3a 8e 27			ld a, (.dmark+1)  
2782 32 69 fe			ld (debug_mark+1),a  
2785 3a 8f 27			ld a, (.dmark+2)  
2788 32 6a fe			ld (debug_mark+2),a  
278b 18 03			jr .pastdmark  
278d ..			.dmark: db ":01"  
2790 f1			.pastdmark: pop af  
2791			endm  
# End of macro DMARK
2791				CALLMONITOR 
2791 cd 6c fe			call debug_vector  
2794				endm  
# End of macro CALLMONITOR
2794			endif 
2794			 
2794			; 
2794			;  new word memory layout: 
2794			;  
2794			;    : adg 6666 ;  
2794			; 
2794			;    db   1     ; user defined word  
2794 23				inc hl    
2795			;    dw   sysdict 
2795 23				inc hl 
2796 23				inc hl 
2797			;    db <word len>+1 (for null) 
2797 23				inc hl 
2798			;    db .... <word> 
2798			; 
2798			 
2798 23				inc hl    ; some extras for the word preamble before the above 
2799 23				inc hl 
279a 23				inc hl 
279b 23				inc hl 
279c 23				inc hl 
279d 23				inc hl 
279e 23				inc hl  
279f 23				inc hl 
27a0 23				inc hl 
27a1 23				inc hl 
27a2 23				inc hl 
27a3 23				inc hl 
27a4 23				inc hl 
27a5 23				inc hl     ; TODO how many do we really need?     maybe only 6 
27a6			;       exec word buffer 
27a6			;	<ptr word>   
27a6 23				inc hl 
27a7 23				inc hl 
27a8			;       <word list><null term> 7F final term 
27a8			 
27a8			 
27a8			if DEBUG_FORTH_UWORD 
27a8						DMARK ":02" 
27a8 f5				push af  
27a9 3a bd 27			ld a, (.dmark)  
27ac 32 68 fe			ld (debug_mark),a  
27af 3a be 27			ld a, (.dmark+1)  
27b2 32 69 fe			ld (debug_mark+1),a  
27b5 3a bf 27			ld a, (.dmark+2)  
27b8 32 6a fe			ld (debug_mark+2),a  
27bb 18 03			jr .pastdmark  
27bd ..			.dmark: db ":02"  
27c0 f1			.pastdmark: pop af  
27c1			endm  
# End of macro DMARK
27c1				CALLMONITOR 
27c1 cd 6c fe			call debug_vector  
27c4				endm  
# End of macro CALLMONITOR
27c4			endif 
27c4			 
27c4				 
27c4					; malloc the size 
27c4			 
27c4 cd 97 14				call malloc 
27c7 22 bc f1				ld (os_new_malloc), hl     ; save malloc start 
27ca			 
27ca			;    db   1     ; user defined word  
27ca 3e 01				ld a, WORD_SYS_UWORD  
27cc 77					ld (hl), a 
27cd				 
27cd 23				inc hl    
27ce			;    dw   sysdict 
27ce 11 18 26			ld de, sysdict       ; continue on with the scan to the system dict 
27d1 73				ld (hl), e 
27d2 23				inc hl 
27d3 72				ld (hl), d 
27d4 23				inc hl 
27d5			 
27d5			 
27d5			;    Setup dict word 
27d5			 
27d5 23				inc hl 
27d6 22 b6 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
27d9			 
27d9				; 1. get length of dict word 
27d9			 
27d9			 
27d9 2a bf f4			ld hl, (os_tok_ptr) 
27dc 23				inc hl 
27dd 23				inc hl    ; position to start of dict word 
27de 3e 00			ld a, 0 
27e0 cd 39 14			call strlent 
27e3			 
27e3			 
27e3 23				inc hl    ; to include null??? 
27e4			 
27e4				; write length of dict word 
27e4			 
27e4 ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27e8 1b				dec de 
27e9 eb				ex de, hl 
27ea 73				ld (hl), e 
27eb eb				ex de, hl 
27ec			 
27ec				 
27ec			 
27ec				; copy  
27ec 4d				ld c, l 
27ed 06 00			ld b, 0 
27ef ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27f3 2a bf f4			ld hl, (os_tok_ptr) 
27f6 23				inc hl 
27f7 23				inc hl    ; position to start of dict word 
27f8				 
27f8			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27f8				 
27f8				; TODO need to convert word to upper case 
27f8			 
27f8			ucasetok:	 
27f8 7e				ld a,(hl) 
27f9 cd 25 14			call toUpper 
27fc 77				ld (hl),a 
27fd ed a0			ldi 
27ff f2 f8 27		 	jp p, ucasetok 
2802			 
2802			 
2802			 
2802				; de now points to start of where the word body code should be placed 
2802 ed 53 b6 f1		ld (os_new_work_ptr), de 
2806				; hl now points to the words to throw at forthexec which needs to be copied 
2806 22 b4 f1			ld (os_new_src_ptr), hl 
2809			 
2809				; TODO add 'call to forthexec' 
2809			 
2809			if DEBUG_FORTH_UWORD 
2809 c5				push bc 
280a ed 4b bc f1		ld bc, (os_new_malloc) 
280e						DMARK ":0x" 
280e f5				push af  
280f 3a 23 28			ld a, (.dmark)  
2812 32 68 fe			ld (debug_mark),a  
2815 3a 24 28			ld a, (.dmark+1)  
2818 32 69 fe			ld (debug_mark+1),a  
281b 3a 25 28			ld a, (.dmark+2)  
281e 32 6a fe			ld (debug_mark+2),a  
2821 18 03			jr .pastdmark  
2823 ..			.dmark: db ":0x"  
2826 f1			.pastdmark: pop af  
2827			endm  
# End of macro DMARK
2827				CALLMONITOR 
2827 cd 6c fe			call debug_vector  
282a				endm  
# End of macro CALLMONITOR
282a c1				pop bc 
282b			endif 
282b			 
282b			 
282b				; create word preamble which should be: 
282b			 
282b			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
282b			 
282b				;    ld hl, <word code> 
282b				;    jp user_exec 
282b			        ;    <word code bytes> 
282b			 
282b			 
282b			;	inc de     ; TODO ??? or are we already past the word's null 
282b eb				ex de, hl 
282c			 
282c 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
282e			 
282e 23				inc hl 
282f 22 b0 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2832 23				inc hl 
2833			 
2833 23				inc hl 
2834 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2836			 
2836 01 e0 5c			ld bc, user_exec 
2839 23				inc hl 
283a 71				ld (hl), c     ; poke address of user_exec 
283b 23				inc hl 
283c 70				ld (hl), b     
283d			 ; 
283d			;	inc hl 
283d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
283d			; 
283d			; 
283d			;	ld bc, macro_forth_rsp_next 
283d			;	inc hl 
283d			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
283d			;	inc hl 
283d			;	ld (hl), b     
283d			 ; 
283d			;	inc hl 
283d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
283d			; 
283d			; 
283d			;	inc hl 
283d			;	ld bc, forthexec 
283d			;	ld (hl), c     ; poke address of forthexec 
283d			;	inc hl 
283d			;	ld (hl), b      
283d			; 
283d			;	inc hl 
283d			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
283d			; 
283d			;	ld bc, user_dict_next 
283d			;	inc hl 
283d			;	ld (hl), c     ; poke address of forthexec 
283d			;	inc hl 
283d			;	ld (hl), b      
283d			 
283d				; hl is now where we need to copy the word byte data to save this 
283d			 
283d 23				inc hl 
283e 22 b2 f1			ld (os_new_exec), hl 
2841				 
2841				; copy definition 
2841			 
2841 eb				ex de, hl 
2842			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2842			;	inc de    ; skip the PC for this parse 
2842 3a ba f1			ld a, (os_new_parse_len) 
2845 4f				ld c, a 
2846 06 00			ld b, 0 
2848 ed b0			ldir		 ; copy defintion 
284a			 
284a			 
284a				; poke the address of where the new word bytes live for forthexec 
284a			 
284a 2a b0 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
284d			 
284d ed 5b b2 f1		ld de, (os_new_exec)      
2851				 
2851 73				ld (hl), e 
2852 23				inc hl 
2853 72				ld (hl), d 
2854			 
2854					; TODO copy last user dict word next link to this word 
2854					; TODO update last user dict word to point to this word 
2854			; 
2854			; hl f923 de 812a ; bc 811a 
2854			 
2854			if DEBUG_FORTH_UWORD 
2854 c5				push bc 
2855 ed 4b bc f1		ld bc, (os_new_malloc) 
2859						DMARK ":0A" 
2859 f5				push af  
285a 3a 6e 28			ld a, (.dmark)  
285d 32 68 fe			ld (debug_mark),a  
2860 3a 6f 28			ld a, (.dmark+1)  
2863 32 69 fe			ld (debug_mark+1),a  
2866 3a 70 28			ld a, (.dmark+2)  
2869 32 6a fe			ld (debug_mark+2),a  
286c 18 03			jr .pastdmark  
286e ..			.dmark: db ":0A"  
2871 f1			.pastdmark: pop af  
2872			endm  
# End of macro DMARK
2872				CALLMONITOR 
2872 cd 6c fe			call debug_vector  
2875				endm  
# End of macro CALLMONITOR
2875 c1				pop bc 
2876			endif 
2876			if DEBUG_FORTH_UWORD 
2876 c5				push bc 
2877 ed 4b bc f1		ld bc, (os_new_malloc) 
287b 03				inc bc 
287c 03				inc bc 
287d 03				inc bc 
287e 03				inc bc 
287f 03				inc bc 
2880 03				inc bc 
2881 03				inc bc 
2882 03				inc bc 
2883			 
2883						DMARK ":0B" 
2883 f5				push af  
2884 3a 98 28			ld a, (.dmark)  
2887 32 68 fe			ld (debug_mark),a  
288a 3a 99 28			ld a, (.dmark+1)  
288d 32 69 fe			ld (debug_mark+1),a  
2890 3a 9a 28			ld a, (.dmark+2)  
2893 32 6a fe			ld (debug_mark+2),a  
2896 18 03			jr .pastdmark  
2898 ..			.dmark: db ":0B"  
289b f1			.pastdmark: pop af  
289c			endm  
# End of macro DMARK
289c				CALLMONITOR 
289c cd 6c fe			call debug_vector  
289f				endm  
# End of macro CALLMONITOR
289f c1				pop bc 
28a0			endif 
28a0			 
28a0			; update word dict linked list for new word 
28a0			 
28a0			 
28a0 2a bb f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
28a3 23			inc hl     ; move to next work linked list ptr 
28a4			 
28a4 ed 5b bc f1	ld de, (os_new_malloc)		 ; new next word 
28a8 73			ld (hl), e 
28a9 23			inc hl 
28aa 72			ld (hl), d 
28ab			 
28ab			if DEBUG_FORTH_UWORD 
28ab ed 4b bb f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
28af			endif 
28af			 
28af ed 53 bb f4	ld (os_last_new_uword), de      ; update last new uword ptr 
28b3			 
28b3			 
28b3			if DEBUG_FORTH_UWORD 
28b3						DMARK ":0+" 
28b3 f5				push af  
28b4 3a c8 28			ld a, (.dmark)  
28b7 32 68 fe			ld (debug_mark),a  
28ba 3a c9 28			ld a, (.dmark+1)  
28bd 32 69 fe			ld (debug_mark+1),a  
28c0 3a ca 28			ld a, (.dmark+2)  
28c3 32 6a fe			ld (debug_mark+2),a  
28c6 18 03			jr .pastdmark  
28c8 ..			.dmark: db ":0+"  
28cb f1			.pastdmark: pop af  
28cc			endm  
# End of macro DMARK
28cc				CALLMONITOR 
28cc cd 6c fe			call debug_vector  
28cf				endm  
# End of macro CALLMONITOR
28cf			endif 
28cf			 
28cf				STACKFRAMECHK OFF $8efe $989f 
28cf				if DEBUG_STACK_IMB 
28cf					if OFF 
28cf						exx 
28cf						ld hl, $989f 
28cf						pop de   ; $989f 
28cf						call cmp16 
28cf						jr nz, .spnosame 
28cf						ld hl, $8efe 
28cf						pop de   ; $8efe 
28cf						call cmp16 
28cf						jr z, .spfrsame 
28cf						.spnosame: call showsperror 
28cf						.spfrsame: nop 
28cf						exx 
28cf					endif 
28cf				endif 
28cf			endm 
# End of macro STACKFRAMECHK
28cf			 
28cf c9			ret    ; dont process any remaining parser tokens as they form new word 
28d0			 
28d0			 
28d0			 
28d0			 
28d0			;		NEXT 
28d0			.SCOLN: 
28d0			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28d0 06				db OPCODE_SCOLN 
28d1 1c 29			dw .DROP 
28d3 02				db 2 
28d4 .. 00			db ";",0           
28d6			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28d6					if DEBUG_FORTH_WORDS_KEY 
28d6						DMARK "SCN" 
28d6 f5				push af  
28d7 3a eb 28			ld a, (.dmark)  
28da 32 68 fe			ld (debug_mark),a  
28dd 3a ec 28			ld a, (.dmark+1)  
28e0 32 69 fe			ld (debug_mark+1),a  
28e3 3a ed 28			ld a, (.dmark+2)  
28e6 32 6a fe			ld (debug_mark+2),a  
28e9 18 03			jr .pastdmark  
28eb ..			.dmark: db "SCN"  
28ee f1			.pastdmark: pop af  
28ef			endm  
# End of macro DMARK
28ef						CALLMONITOR 
28ef cd 6c fe			call debug_vector  
28f2				endm  
# End of macro CALLMONITOR
28f2					endif 
28f2					FORTH_RSP_TOS 
28f2 cd d1 20			call macro_forth_rsp_tos 
28f5				endm 
# End of macro FORTH_RSP_TOS
28f5 e5					push hl 
28f6					FORTH_RSP_POP 
28f6 cd db 20			call macro_forth_rsp_pop 
28f9				endm 
# End of macro FORTH_RSP_POP
28f9 e1					pop hl 
28fa			;		ex de,hl 
28fa 22 bf f4				ld (os_tok_ptr),hl 
28fd			 
28fd			if DEBUG_FORTH_UWORD 
28fd						DMARK "SCL" 
28fd f5				push af  
28fe 3a 12 29			ld a, (.dmark)  
2901 32 68 fe			ld (debug_mark),a  
2904 3a 13 29			ld a, (.dmark+1)  
2907 32 69 fe			ld (debug_mark+1),a  
290a 3a 14 29			ld a, (.dmark+2)  
290d 32 6a fe			ld (debug_mark+2),a  
2910 18 03			jr .pastdmark  
2912 ..			.dmark: db "SCL"  
2915 f1			.pastdmark: pop af  
2916			endm  
# End of macro DMARK
2916				CALLMONITOR 
2916 cd 6c fe			call debug_vector  
2919				endm  
# End of macro CALLMONITOR
2919			endif 
2919					NEXTW 
2919 c3 c0 24			jp macro_next 
291c				endm 
# End of macro NEXTW
291c			 
291c			.DROP: 
291c				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
291c 1b				db WORD_SYS_CORE+OPCODE_DROP             
291d 47 29			dw .DUP2            
291f 05				db 4 + 1 
2920 .. 00			db "DROP",0              
2925				endm 
# End of macro CWHEAD
2925			; | DROP ( w -- )   drop the TOS item   | DONE 
2925					if DEBUG_FORTH_WORDS_KEY 
2925						DMARK "DRP" 
2925 f5				push af  
2926 3a 3a 29			ld a, (.dmark)  
2929 32 68 fe			ld (debug_mark),a  
292c 3a 3b 29			ld a, (.dmark+1)  
292f 32 69 fe			ld (debug_mark+1),a  
2932 3a 3c 29			ld a, (.dmark+2)  
2935 32 6a fe			ld (debug_mark+2),a  
2938 18 03			jr .pastdmark  
293a ..			.dmark: db "DRP"  
293d f1			.pastdmark: pop af  
293e			endm  
# End of macro DMARK
293e						CALLMONITOR 
293e cd 6c fe			call debug_vector  
2941				endm  
# End of macro CALLMONITOR
2941					endif 
2941					FORTH_DSP_POP 
2941 cd c2 23			call macro_forth_dsp_pop 
2944				endm 
# End of macro FORTH_DSP_POP
2944					NEXTW 
2944 c3 c0 24			jp macro_next 
2947				endm 
# End of macro NEXTW
2947			.DUP2: 
2947				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2947 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2948 8c 29			dw .DROP2            
294a 05				db 4 + 1 
294b .. 00			db "2DUP",0              
2950				endm 
# End of macro CWHEAD
2950			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2950					if DEBUG_FORTH_WORDS_KEY 
2950						DMARK "2DU" 
2950 f5				push af  
2951 3a 65 29			ld a, (.dmark)  
2954 32 68 fe			ld (debug_mark),a  
2957 3a 66 29			ld a, (.dmark+1)  
295a 32 69 fe			ld (debug_mark+1),a  
295d 3a 67 29			ld a, (.dmark+2)  
2960 32 6a fe			ld (debug_mark+2),a  
2963 18 03			jr .pastdmark  
2965 ..			.dmark: db "2DU"  
2968 f1			.pastdmark: pop af  
2969			endm  
# End of macro DMARK
2969						CALLMONITOR 
2969 cd 6c fe			call debug_vector  
296c				endm  
# End of macro CALLMONITOR
296c					endif 
296c					FORTH_DSP_VALUEHL 
296c cd 0a 23			call macro_dsp_valuehl 
296f				endm 
# End of macro FORTH_DSP_VALUEHL
296f e5					push hl      ; 2 
2970			 
2970					FORTH_DSP_POP 
2970 cd c2 23			call macro_forth_dsp_pop 
2973				endm 
# End of macro FORTH_DSP_POP
2973					 
2973					FORTH_DSP_VALUEHL 
2973 cd 0a 23			call macro_dsp_valuehl 
2976				endm 
# End of macro FORTH_DSP_VALUEHL
2976			;		push hl      ; 1 
2976			 
2976					FORTH_DSP_POP 
2976 cd c2 23			call macro_forth_dsp_pop 
2979				endm 
# End of macro FORTH_DSP_POP
2979			 
2979			;		pop hl       ; 1 
2979 d1					pop de       ; 2 
297a			 
297a cd 13 21				call forth_push_numhl 
297d eb					ex de, hl 
297e cd 13 21				call forth_push_numhl 
2981			 
2981					 
2981 eb					ex de, hl 
2982			 
2982 cd 13 21				call forth_push_numhl 
2985 eb					ex de, hl 
2986 cd 13 21				call forth_push_numhl 
2989			 
2989			 
2989					NEXTW 
2989 c3 c0 24			jp macro_next 
298c				endm 
# End of macro NEXTW
298c			.DROP2: 
298c				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
298c 1d				db WORD_SYS_CORE+OPCODE_DROP2             
298d bb 29			dw .SWAP2            
298f 06				db 5 + 1 
2990 .. 00			db "2DROP",0              
2996				endm 
# End of macro CWHEAD
2996			; | 2DROP ( w w -- )    Double drop | DONE 
2996					if DEBUG_FORTH_WORDS_KEY 
2996						DMARK "2DR" 
2996 f5				push af  
2997 3a ab 29			ld a, (.dmark)  
299a 32 68 fe			ld (debug_mark),a  
299d 3a ac 29			ld a, (.dmark+1)  
29a0 32 69 fe			ld (debug_mark+1),a  
29a3 3a ad 29			ld a, (.dmark+2)  
29a6 32 6a fe			ld (debug_mark+2),a  
29a9 18 03			jr .pastdmark  
29ab ..			.dmark: db "2DR"  
29ae f1			.pastdmark: pop af  
29af			endm  
# End of macro DMARK
29af						CALLMONITOR 
29af cd 6c fe			call debug_vector  
29b2				endm  
# End of macro CALLMONITOR
29b2					endif 
29b2					FORTH_DSP_POP 
29b2 cd c2 23			call macro_forth_dsp_pop 
29b5				endm 
# End of macro FORTH_DSP_POP
29b5					FORTH_DSP_POP 
29b5 cd c2 23			call macro_forth_dsp_pop 
29b8				endm 
# End of macro FORTH_DSP_POP
29b8					NEXTW 
29b8 c3 c0 24			jp macro_next 
29bb				endm 
# End of macro NEXTW
29bb			.SWAP2: 
29bb				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29bb 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29bc e4 29			dw .AT            
29be 06				db 5 + 1 
29bf .. 00			db "2SWAP",0              
29c5				endm 
# End of macro CWHEAD
29c5			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29c5					if DEBUG_FORTH_WORDS_KEY 
29c5						DMARK "2SW" 
29c5 f5				push af  
29c6 3a da 29			ld a, (.dmark)  
29c9 32 68 fe			ld (debug_mark),a  
29cc 3a db 29			ld a, (.dmark+1)  
29cf 32 69 fe			ld (debug_mark+1),a  
29d2 3a dc 29			ld a, (.dmark+2)  
29d5 32 6a fe			ld (debug_mark+2),a  
29d8 18 03			jr .pastdmark  
29da ..			.dmark: db "2SW"  
29dd f1			.pastdmark: pop af  
29de			endm  
# End of macro DMARK
29de						CALLMONITOR 
29de cd 6c fe			call debug_vector  
29e1				endm  
# End of macro CALLMONITOR
29e1					endif 
29e1					NEXTW 
29e1 c3 c0 24			jp macro_next 
29e4				endm 
# End of macro NEXTW
29e4			.AT: 
29e4				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29e4 1f				db WORD_SYS_CORE+OPCODE_AT             
29e5 16 2a			dw .CAT            
29e7 02				db 1 + 1 
29e8 .. 00			db "@",0              
29ea				endm 
# End of macro CWHEAD
29ea			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29ea			 
29ea					if DEBUG_FORTH_WORDS_KEY 
29ea						DMARK "AT." 
29ea f5				push af  
29eb 3a ff 29			ld a, (.dmark)  
29ee 32 68 fe			ld (debug_mark),a  
29f1 3a 00 2a			ld a, (.dmark+1)  
29f4 32 69 fe			ld (debug_mark+1),a  
29f7 3a 01 2a			ld a, (.dmark+2)  
29fa 32 6a fe			ld (debug_mark+2),a  
29fd 18 03			jr .pastdmark  
29ff ..			.dmark: db "AT."  
2a02 f1			.pastdmark: pop af  
2a03			endm  
# End of macro DMARK
2a03						CALLMONITOR 
2a03 cd 6c fe			call debug_vector  
2a06				endm  
# End of macro CALLMONITOR
2a06					endif 
2a06			.getbyteat:	 
2a06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a06 cd 0a 23			call macro_dsp_valuehl 
2a09				endm 
# End of macro FORTH_DSP_VALUEHL
2a09					 
2a09			;		push hl 
2a09				 
2a09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a09 cd c2 23			call macro_forth_dsp_pop 
2a0c				endm 
# End of macro FORTH_DSP_POP
2a0c			 
2a0c			;		pop hl 
2a0c			 
2a0c 7e					ld a, (hl) 
2a0d			 
2a0d 6f					ld l, a 
2a0e 26 00				ld h, 0 
2a10 cd 13 21				call forth_push_numhl 
2a13			 
2a13					NEXTW 
2a13 c3 c0 24			jp macro_next 
2a16				endm 
# End of macro NEXTW
2a16			.CAT: 
2a16				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a16 20				db WORD_SYS_CORE+OPCODE_CAT             
2a17 3f 2a			dw .BANG            
2a19 03				db 2 + 1 
2a1a .. 00			db "C@",0              
2a1d				endm 
# End of macro CWHEAD
2a1d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a1d					if DEBUG_FORTH_WORDS_KEY 
2a1d						DMARK "CAA" 
2a1d f5				push af  
2a1e 3a 32 2a			ld a, (.dmark)  
2a21 32 68 fe			ld (debug_mark),a  
2a24 3a 33 2a			ld a, (.dmark+1)  
2a27 32 69 fe			ld (debug_mark+1),a  
2a2a 3a 34 2a			ld a, (.dmark+2)  
2a2d 32 6a fe			ld (debug_mark+2),a  
2a30 18 03			jr .pastdmark  
2a32 ..			.dmark: db "CAA"  
2a35 f1			.pastdmark: pop af  
2a36			endm  
# End of macro DMARK
2a36						CALLMONITOR 
2a36 cd 6c fe			call debug_vector  
2a39				endm  
# End of macro CALLMONITOR
2a39					endif 
2a39 c3 06 2a				jp .getbyteat 
2a3c					NEXTW 
2a3c c3 c0 24			jp macro_next 
2a3f				endm 
# End of macro NEXTW
2a3f			.BANG: 
2a3f				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a3f 21				db WORD_SYS_CORE+OPCODE_BANG             
2a40 75 2a			dw .CBANG            
2a42 02				db 1 + 1 
2a43 .. 00			db "!",0              
2a45				endm 
# End of macro CWHEAD
2a45			; | ! ( x w -- ) Store x at address w      | DONE 
2a45					if DEBUG_FORTH_WORDS_KEY 
2a45						DMARK "BNG" 
2a45 f5				push af  
2a46 3a 5a 2a			ld a, (.dmark)  
2a49 32 68 fe			ld (debug_mark),a  
2a4c 3a 5b 2a			ld a, (.dmark+1)  
2a4f 32 69 fe			ld (debug_mark+1),a  
2a52 3a 5c 2a			ld a, (.dmark+2)  
2a55 32 6a fe			ld (debug_mark+2),a  
2a58 18 03			jr .pastdmark  
2a5a ..			.dmark: db "BNG"  
2a5d f1			.pastdmark: pop af  
2a5e			endm  
# End of macro DMARK
2a5e						CALLMONITOR 
2a5e cd 6c fe			call debug_vector  
2a61				endm  
# End of macro CALLMONITOR
2a61					endif 
2a61			 
2a61			.storebyteat:		 
2a61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a61 cd 0a 23			call macro_dsp_valuehl 
2a64				endm 
# End of macro FORTH_DSP_VALUEHL
2a64					 
2a64 e5					push hl 
2a65				 
2a65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a65 cd c2 23			call macro_forth_dsp_pop 
2a68				endm 
# End of macro FORTH_DSP_POP
2a68			 
2a68					; get byte to poke 
2a68			 
2a68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a68 cd 0a 23			call macro_dsp_valuehl 
2a6b				endm 
# End of macro FORTH_DSP_VALUEHL
2a6b e5					push hl 
2a6c			 
2a6c			 
2a6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a6c cd c2 23			call macro_forth_dsp_pop 
2a6f				endm 
# End of macro FORTH_DSP_POP
2a6f			 
2a6f			 
2a6f d1					pop de 
2a70 e1					pop hl 
2a71			 
2a71 73					ld (hl),e 
2a72			 
2a72			 
2a72					NEXTW 
2a72 c3 c0 24			jp macro_next 
2a75				endm 
# End of macro NEXTW
2a75			.CBANG: 
2a75				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a75 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a76 9e 2a			dw .SCALL            
2a78 03				db 2 + 1 
2a79 .. 00			db "C!",0              
2a7c				endm 
# End of macro CWHEAD
2a7c			; | C!  ( x w -- ) Store x at address w  | DONE 
2a7c					if DEBUG_FORTH_WORDS_KEY 
2a7c						DMARK "CBA" 
2a7c f5				push af  
2a7d 3a 91 2a			ld a, (.dmark)  
2a80 32 68 fe			ld (debug_mark),a  
2a83 3a 92 2a			ld a, (.dmark+1)  
2a86 32 69 fe			ld (debug_mark+1),a  
2a89 3a 93 2a			ld a, (.dmark+2)  
2a8c 32 6a fe			ld (debug_mark+2),a  
2a8f 18 03			jr .pastdmark  
2a91 ..			.dmark: db "CBA"  
2a94 f1			.pastdmark: pop af  
2a95			endm  
# End of macro DMARK
2a95						CALLMONITOR 
2a95 cd 6c fe			call debug_vector  
2a98				endm  
# End of macro CALLMONITOR
2a98					endif 
2a98 c3 61 2a				jp .storebyteat 
2a9b					NEXTW 
2a9b c3 c0 24			jp macro_next 
2a9e				endm 
# End of macro NEXTW
2a9e			.SCALL: 
2a9e				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a9e 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a9f d2 2a			dw .DEPTH            
2aa1 05				db 4 + 1 
2aa2 .. 00			db "CALL",0              
2aa7				endm 
# End of macro CWHEAD
2aa7			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2aa7					if DEBUG_FORTH_WORDS_KEY 
2aa7						DMARK "CLL" 
2aa7 f5				push af  
2aa8 3a bc 2a			ld a, (.dmark)  
2aab 32 68 fe			ld (debug_mark),a  
2aae 3a bd 2a			ld a, (.dmark+1)  
2ab1 32 69 fe			ld (debug_mark+1),a  
2ab4 3a be 2a			ld a, (.dmark+2)  
2ab7 32 6a fe			ld (debug_mark+2),a  
2aba 18 03			jr .pastdmark  
2abc ..			.dmark: db "CLL"  
2abf f1			.pastdmark: pop af  
2ac0			endm  
# End of macro DMARK
2ac0						CALLMONITOR 
2ac0 cd 6c fe			call debug_vector  
2ac3				endm  
# End of macro CALLMONITOR
2ac3					endif 
2ac3			 
2ac3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ac3 cd 0a 23			call macro_dsp_valuehl 
2ac6				endm 
# End of macro FORTH_DSP_VALUEHL
2ac6			 
2ac6			;		push hl 
2ac6			 
2ac6					; destroy value TOS 
2ac6			 
2ac6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ac6 cd c2 23			call macro_forth_dsp_pop 
2ac9				endm 
# End of macro FORTH_DSP_POP
2ac9			 
2ac9						 
2ac9			;		pop hl 
2ac9			 
2ac9					; how to do a call with hl???? save SP? 
2ac9 cd 64 24				call forth_call_hl 
2acc			 
2acc			 
2acc					; TODO push value back onto stack for another op etc 
2acc			 
2acc cd 13 21				call forth_push_numhl 
2acf					NEXTW 
2acf c3 c0 24			jp macro_next 
2ad2				endm 
# End of macro NEXTW
2ad2			.DEPTH: 
2ad2				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ad2 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ad3 0f 2b			dw .OVER            
2ad5 06				db 5 + 1 
2ad6 .. 00			db "DEPTH",0              
2adc				endm 
# End of macro CWHEAD
2adc			; | DEPTH ( -- u ) Push count of stack | DONE 
2adc					; take current TOS and remove from base value div by two to get count 
2adc					if DEBUG_FORTH_WORDS_KEY 
2adc						DMARK "DEP" 
2adc f5				push af  
2add 3a f1 2a			ld a, (.dmark)  
2ae0 32 68 fe			ld (debug_mark),a  
2ae3 3a f2 2a			ld a, (.dmark+1)  
2ae6 32 69 fe			ld (debug_mark+1),a  
2ae9 3a f3 2a			ld a, (.dmark+2)  
2aec 32 6a fe			ld (debug_mark+2),a  
2aef 18 03			jr .pastdmark  
2af1 ..			.dmark: db "DEP"  
2af4 f1			.pastdmark: pop af  
2af5			endm  
# End of macro DMARK
2af5						CALLMONITOR 
2af5 cd 6c fe			call debug_vector  
2af8				endm  
# End of macro CALLMONITOR
2af8					endif 
2af8			 
2af8			 
2af8 2a eb f9			ld hl, (cli_data_sp) 
2afb 11 25 f7			ld de, cli_data_stack 
2afe ed 52			sbc hl,de 
2b00				 
2b00				; div by size of stack item 
2b00			 
2b00 5d				ld e,l 
2b01 0e 03			ld c, 3 
2b03 cd 60 0f			call Div8 
2b06			 
2b06 6f				ld l,a 
2b07 26 00			ld h,0 
2b09			 
2b09				;srl h 
2b09				;rr l 
2b09			 
2b09 cd 13 21				call forth_push_numhl 
2b0c					NEXTW 
2b0c c3 c0 24			jp macro_next 
2b0f				endm 
# End of macro NEXTW
2b0f			.OVER: 
2b0f				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2b0f 42				db WORD_SYS_CORE+46             
2b10 56 2b			dw .PAUSE            
2b12 05				db 4 + 1 
2b13 .. 00			db "OVER",0              
2b18				endm 
# End of macro CWHEAD
2b18			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b18					if DEBUG_FORTH_WORDS_KEY 
2b18						DMARK "OVR" 
2b18 f5				push af  
2b19 3a 2d 2b			ld a, (.dmark)  
2b1c 32 68 fe			ld (debug_mark),a  
2b1f 3a 2e 2b			ld a, (.dmark+1)  
2b22 32 69 fe			ld (debug_mark+1),a  
2b25 3a 2f 2b			ld a, (.dmark+2)  
2b28 32 6a fe			ld (debug_mark+2),a  
2b2b 18 03			jr .pastdmark  
2b2d ..			.dmark: db "OVR"  
2b30 f1			.pastdmark: pop af  
2b31			endm  
# End of macro DMARK
2b31						CALLMONITOR 
2b31 cd 6c fe			call debug_vector  
2b34				endm  
# End of macro CALLMONITOR
2b34					endif 
2b34			 
2b34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b34 cd 0a 23			call macro_dsp_valuehl 
2b37				endm 
# End of macro FORTH_DSP_VALUEHL
2b37 e5					push hl    ; n2 
2b38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b38 cd c2 23			call macro_forth_dsp_pop 
2b3b				endm 
# End of macro FORTH_DSP_POP
2b3b			 
2b3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b3b cd 0a 23			call macro_dsp_valuehl 
2b3e				endm 
# End of macro FORTH_DSP_VALUEHL
2b3e e5					push hl    ; n1 
2b3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b3f cd c2 23			call macro_forth_dsp_pop 
2b42				endm 
# End of macro FORTH_DSP_POP
2b42			 
2b42 d1					pop de     ; n1 
2b43 e1					pop hl     ; n2 
2b44			 
2b44 d5					push de 
2b45 e5					push hl 
2b46 d5					push de 
2b47			 
2b47					; push back  
2b47			 
2b47 e1					pop hl 
2b48 cd 13 21				call forth_push_numhl 
2b4b e1					pop hl 
2b4c cd 13 21				call forth_push_numhl 
2b4f e1					pop hl 
2b50 cd 13 21				call forth_push_numhl 
2b53					NEXTW 
2b53 c3 c0 24			jp macro_next 
2b56				endm 
# End of macro NEXTW
2b56			 
2b56			.PAUSE: 
2b56				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b56 43				db WORD_SYS_CORE+47             
2b57 8b 2b			dw .PAUSES            
2b59 08				db 7 + 1 
2b5a .. 00			db "PAUSEMS",0              
2b62				endm 
# End of macro CWHEAD
2b62			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b62					if DEBUG_FORTH_WORDS_KEY 
2b62						DMARK "PMS" 
2b62 f5				push af  
2b63 3a 77 2b			ld a, (.dmark)  
2b66 32 68 fe			ld (debug_mark),a  
2b69 3a 78 2b			ld a, (.dmark+1)  
2b6c 32 69 fe			ld (debug_mark+1),a  
2b6f 3a 79 2b			ld a, (.dmark+2)  
2b72 32 6a fe			ld (debug_mark+2),a  
2b75 18 03			jr .pastdmark  
2b77 ..			.dmark: db "PMS"  
2b7a f1			.pastdmark: pop af  
2b7b			endm  
# End of macro DMARK
2b7b						CALLMONITOR 
2b7b cd 6c fe			call debug_vector  
2b7e				endm  
# End of macro CALLMONITOR
2b7e					endif 
2b7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b7e cd 0a 23			call macro_dsp_valuehl 
2b81				endm 
# End of macro FORTH_DSP_VALUEHL
2b81			;		push hl    ; n2 
2b81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b81 cd c2 23			call macro_forth_dsp_pop 
2b84				endm 
# End of macro FORTH_DSP_POP
2b84			;		pop hl 
2b84			 
2b84 7d					ld a, l 
2b85 cd c4 0c				call aDelayInMS 
2b88				       NEXTW 
2b88 c3 c0 24			jp macro_next 
2b8b				endm 
# End of macro NEXTW
2b8b			.PAUSES:  
2b8b				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b8b 44				db WORD_SYS_CORE+48             
2b8c fa 2b			dw .ROT            
2b8e 06				db 5 + 1 
2b8f .. 00			db "PAUSE",0              
2b95				endm 
# End of macro CWHEAD
2b95			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b95					if DEBUG_FORTH_WORDS_KEY 
2b95						DMARK "PAU" 
2b95 f5				push af  
2b96 3a aa 2b			ld a, (.dmark)  
2b99 32 68 fe			ld (debug_mark),a  
2b9c 3a ab 2b			ld a, (.dmark+1)  
2b9f 32 69 fe			ld (debug_mark+1),a  
2ba2 3a ac 2b			ld a, (.dmark+2)  
2ba5 32 6a fe			ld (debug_mark+2),a  
2ba8 18 03			jr .pastdmark  
2baa ..			.dmark: db "PAU"  
2bad f1			.pastdmark: pop af  
2bae			endm  
# End of macro DMARK
2bae						CALLMONITOR 
2bae cd 6c fe			call debug_vector  
2bb1				endm  
# End of macro CALLMONITOR
2bb1					endif 
2bb1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bb1 cd 0a 23			call macro_dsp_valuehl 
2bb4				endm 
# End of macro FORTH_DSP_VALUEHL
2bb4			;		push hl    ; n2 
2bb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bb4 cd c2 23			call macro_forth_dsp_pop 
2bb7				endm 
# End of macro FORTH_DSP_POP
2bb7			;		pop hl 
2bb7 45					ld b, l 
2bb8					if DEBUG_FORTH_WORDS 
2bb8						DMARK "PAU" 
2bb8 f5				push af  
2bb9 3a cd 2b			ld a, (.dmark)  
2bbc 32 68 fe			ld (debug_mark),a  
2bbf 3a ce 2b			ld a, (.dmark+1)  
2bc2 32 69 fe			ld (debug_mark+1),a  
2bc5 3a cf 2b			ld a, (.dmark+2)  
2bc8 32 6a fe			ld (debug_mark+2),a  
2bcb 18 03			jr .pastdmark  
2bcd ..			.dmark: db "PAU"  
2bd0 f1			.pastdmark: pop af  
2bd1			endm  
# End of macro DMARK
2bd1						CALLMONITOR 
2bd1 cd 6c fe			call debug_vector  
2bd4				endm  
# End of macro CALLMONITOR
2bd4					endif 
2bd4 c5			.pauses1:	push bc 
2bd5 cd df 0c				call delay1s 
2bd8 c1					pop bc 
2bd9					if DEBUG_FORTH_WORDS 
2bd9						DMARK "PA1" 
2bd9 f5				push af  
2bda 3a ee 2b			ld a, (.dmark)  
2bdd 32 68 fe			ld (debug_mark),a  
2be0 3a ef 2b			ld a, (.dmark+1)  
2be3 32 69 fe			ld (debug_mark+1),a  
2be6 3a f0 2b			ld a, (.dmark+2)  
2be9 32 6a fe			ld (debug_mark+2),a  
2bec 18 03			jr .pastdmark  
2bee ..			.dmark: db "PA1"  
2bf1 f1			.pastdmark: pop af  
2bf2			endm  
# End of macro DMARK
2bf2						CALLMONITOR 
2bf2 cd 6c fe			call debug_vector  
2bf5				endm  
# End of macro CALLMONITOR
2bf5					endif 
2bf5 10 dd				djnz .pauses1 
2bf7			 
2bf7				       NEXTW 
2bf7 c3 c0 24			jp macro_next 
2bfa				endm 
# End of macro NEXTW
2bfa			.ROT: 
2bfa				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bfa 45				db WORD_SYS_CORE+49             
2bfb 48 2c			dw .UWORDS            
2bfd 04				db 3 + 1 
2bfe .. 00			db "ROT",0              
2c02				endm 
# End of macro CWHEAD
2c02			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2c02					if DEBUG_FORTH_WORDS_KEY 
2c02						DMARK "ROT" 
2c02 f5				push af  
2c03 3a 17 2c			ld a, (.dmark)  
2c06 32 68 fe			ld (debug_mark),a  
2c09 3a 18 2c			ld a, (.dmark+1)  
2c0c 32 69 fe			ld (debug_mark+1),a  
2c0f 3a 19 2c			ld a, (.dmark+2)  
2c12 32 6a fe			ld (debug_mark+2),a  
2c15 18 03			jr .pastdmark  
2c17 ..			.dmark: db "ROT"  
2c1a f1			.pastdmark: pop af  
2c1b			endm  
# End of macro DMARK
2c1b						CALLMONITOR 
2c1b cd 6c fe			call debug_vector  
2c1e				endm  
# End of macro CALLMONITOR
2c1e					endif 
2c1e			 
2c1e					FORTH_DSP_VALUEHL 
2c1e cd 0a 23			call macro_dsp_valuehl 
2c21				endm 
# End of macro FORTH_DSP_VALUEHL
2c21 e5					push hl    ; u3  
2c22			 
2c22					FORTH_DSP_POP 
2c22 cd c2 23			call macro_forth_dsp_pop 
2c25				endm 
# End of macro FORTH_DSP_POP
2c25			   
2c25					FORTH_DSP_VALUEHL 
2c25 cd 0a 23			call macro_dsp_valuehl 
2c28				endm 
# End of macro FORTH_DSP_VALUEHL
2c28 e5					push hl     ; u2 
2c29			 
2c29					FORTH_DSP_POP 
2c29 cd c2 23			call macro_forth_dsp_pop 
2c2c				endm 
# End of macro FORTH_DSP_POP
2c2c			 
2c2c					FORTH_DSP_VALUEHL 
2c2c cd 0a 23			call macro_dsp_valuehl 
2c2f				endm 
# End of macro FORTH_DSP_VALUEHL
2c2f e5					push hl     ; u1 
2c30			 
2c30					FORTH_DSP_POP 
2c30 cd c2 23			call macro_forth_dsp_pop 
2c33				endm 
# End of macro FORTH_DSP_POP
2c33			 
2c33 c1					pop bc      ; u1 
2c34 e1					pop hl      ; u2 
2c35 d1					pop de      ; u3 
2c36			 
2c36			 
2c36 c5					push bc 
2c37 d5					push de 
2c38 e5					push hl 
2c39			 
2c39			 
2c39 e1					pop hl 
2c3a cd 13 21				call forth_push_numhl 
2c3d			 
2c3d e1					pop hl 
2c3e cd 13 21				call forth_push_numhl 
2c41			 
2c41 e1					pop hl 
2c42 cd 13 21				call forth_push_numhl 
2c45					 
2c45			 
2c45			 
2c45			 
2c45			 
2c45			 
2c45				       NEXTW 
2c45 c3 c0 24			jp macro_next 
2c48				endm 
# End of macro NEXTW
2c48			 
2c48			.UWORDS: 
2c48				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c48 50				db WORD_SYS_CORE+60             
2c49 0a 2d			dw .BP            
2c4b 07				db 6 + 1 
2c4c .. 00			db "UWORDS",0              
2c53				endm 
# End of macro CWHEAD
2c53			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c53			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c53			; | | Following the count are the individual words. 
2c53			; | | 
2c53			; | | e.g. UWORDS 
2c53			; | | BOX DIRLIST 2 
2c53			; | |  
2c53			; | | Can be used to save the words to storage via: 
2c53			; | | UWORDS $01 DO $01 APPEND LOOP 
2c53				if DEBUG_FORTH_WORDS_KEY 
2c53					DMARK "UWR" 
2c53 f5				push af  
2c54 3a 68 2c			ld a, (.dmark)  
2c57 32 68 fe			ld (debug_mark),a  
2c5a 3a 69 2c			ld a, (.dmark+1)  
2c5d 32 69 fe			ld (debug_mark+1),a  
2c60 3a 6a 2c			ld a, (.dmark+2)  
2c63 32 6a fe			ld (debug_mark+2),a  
2c66 18 03			jr .pastdmark  
2c68 ..			.dmark: db "UWR"  
2c6b f1			.pastdmark: pop af  
2c6c			endm  
# End of macro DMARK
2c6c					CALLMONITOR 
2c6c cd 6c fe			call debug_vector  
2c6f				endm  
# End of macro CALLMONITOR
2c6f				endif 
2c6f 21 00 80				ld hl, baseram 
2c72					;ld hl, baseusermem 
2c72 01 00 00				ld bc, 0    ; start a counter 
2c75			 
2c75				; skip dict stub 
2c75			 
2c75 cd 11 26				call forth_tok_next 
2c78			 
2c78			 
2c78			; while we have words to look for 
2c78			 
2c78 7e			.douscan:	ld a, (hl)      
2c79				if DEBUG_FORTH_WORDS 
2c79					DMARK "UWs" 
2c79 f5				push af  
2c7a 3a 8e 2c			ld a, (.dmark)  
2c7d 32 68 fe			ld (debug_mark),a  
2c80 3a 8f 2c			ld a, (.dmark+1)  
2c83 32 69 fe			ld (debug_mark+1),a  
2c86 3a 90 2c			ld a, (.dmark+2)  
2c89 32 6a fe			ld (debug_mark+2),a  
2c8c 18 03			jr .pastdmark  
2c8e ..			.dmark: db "UWs"  
2c91 f1			.pastdmark: pop af  
2c92			endm  
# End of macro DMARK
2c92					CALLMONITOR 
2c92 cd 6c fe			call debug_vector  
2c95				endm  
# End of macro CALLMONITOR
2c95				endif 
2c95 fe 00				cp WORD_SYS_END 
2c97 28 4d				jr z, .udone 
2c99 fe 01				cp WORD_SYS_UWORD 
2c9b 20 44				jr nz, .nuword 
2c9d			 
2c9d				if DEBUG_FORTH_WORDS 
2c9d					DMARK "UWu" 
2c9d f5				push af  
2c9e 3a b2 2c			ld a, (.dmark)  
2ca1 32 68 fe			ld (debug_mark),a  
2ca4 3a b3 2c			ld a, (.dmark+1)  
2ca7 32 69 fe			ld (debug_mark+1),a  
2caa 3a b4 2c			ld a, (.dmark+2)  
2cad 32 6a fe			ld (debug_mark+2),a  
2cb0 18 03			jr .pastdmark  
2cb2 ..			.dmark: db "UWu"  
2cb5 f1			.pastdmark: pop af  
2cb6			endm  
# End of macro DMARK
2cb6					CALLMONITOR 
2cb6 cd 6c fe			call debug_vector  
2cb9				endm  
# End of macro CALLMONITOR
2cb9				endif 
2cb9					; we have a uword so push its name to the stack 
2cb9			 
2cb9 e5				   	push hl  ; save so we can move to next dict block 
2cba			 
2cba					; skip opcode 
2cba 23					inc hl  
2cbb					; skip next ptr 
2cbb 23					inc hl  
2cbc 23					inc hl 
2cbd					; skip len 
2cbd 23					inc hl 
2cbe				if DEBUG_FORTH_WORDS 
2cbe					DMARK "UWt" 
2cbe f5				push af  
2cbf 3a d3 2c			ld a, (.dmark)  
2cc2 32 68 fe			ld (debug_mark),a  
2cc5 3a d4 2c			ld a, (.dmark+1)  
2cc8 32 69 fe			ld (debug_mark+1),a  
2ccb 3a d5 2c			ld a, (.dmark+2)  
2cce 32 6a fe			ld (debug_mark+2),a  
2cd1 18 03			jr .pastdmark  
2cd3 ..			.dmark: db "UWt"  
2cd6 f1			.pastdmark: pop af  
2cd7			endm  
# End of macro DMARK
2cd7					CALLMONITOR 
2cd7 cd 6c fe			call debug_vector  
2cda				endm  
# End of macro CALLMONITOR
2cda				endif 
2cda 03					inc bc 
2cdb			 
2cdb c5					push bc 
2cdc cd 81 21				call forth_push_str 
2cdf c1					pop bc 
2ce0			 
2ce0 e1					pop hl 	 
2ce1			 
2ce1 cd 11 26		.nuword:	call forth_tok_next 
2ce4 18 92				jr .douscan  
2ce6			 
2ce6			.udone:		 ; push count of uwords found 
2ce6 c5					push bc 
2ce7 e1					pop hl 
2ce8			 
2ce8				if DEBUG_FORTH_WORDS 
2ce8					DMARK "UWc" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 68 fe			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 69 fe			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 6a fe			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "UWc"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01					CALLMONITOR 
2d01 cd 6c fe			call debug_vector  
2d04				endm  
# End of macro CALLMONITOR
2d04				endif 
2d04 cd 13 21				call forth_push_numhl 
2d07			 
2d07			 
2d07				       NEXTW 
2d07 c3 c0 24			jp macro_next 
2d0a				endm 
# End of macro NEXTW
2d0a			 
2d0a			.BP: 
2d0a				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2d0a 54				db WORD_SYS_CORE+64             
2d0b 44 2d			dw .MONITOR            
2d0d 03				db 2 + 1 
2d0e .. 00			db "BP",0              
2d11				endm 
# End of macro CWHEAD
2d11			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2d11			; | | $00 Will enable the break points within specific code paths 
2d11			; | | $01 Will disable break points 
2d11			; | |  
2d11			; | | By default break points are off. Either the above can be used to enable them 
2d11			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2d11			; | | and on release of the pressed key a message will be disaplayed to notify 
2d11			; | | that break points are enabled. Pressing any key will then continue boot process. 
2d11					; get byte count 
2d11					if DEBUG_FORTH_WORDS_KEY 
2d11						DMARK "BP." 
2d11 f5				push af  
2d12 3a 26 2d			ld a, (.dmark)  
2d15 32 68 fe			ld (debug_mark),a  
2d18 3a 27 2d			ld a, (.dmark+1)  
2d1b 32 69 fe			ld (debug_mark+1),a  
2d1e 3a 28 2d			ld a, (.dmark+2)  
2d21 32 6a fe			ld (debug_mark+2),a  
2d24 18 03			jr .pastdmark  
2d26 ..			.dmark: db "BP."  
2d29 f1			.pastdmark: pop af  
2d2a			endm  
# End of macro DMARK
2d2a						CALLMONITOR 
2d2a cd 6c fe			call debug_vector  
2d2d				endm  
# End of macro CALLMONITOR
2d2d					endif 
2d2d			 
2d2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d2d cd 0a 23			call macro_dsp_valuehl 
2d30				endm 
# End of macro FORTH_DSP_VALUEHL
2d30			 
2d30			;		push hl 
2d30			 
2d30					; destroy value TOS 
2d30			 
2d30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d30 cd c2 23			call macro_forth_dsp_pop 
2d33				endm 
# End of macro FORTH_DSP_POP
2d33			 
2d33			;		pop hl 
2d33			 
2d33 3e 00				ld a,0 
2d35 bd					cp l 
2d36 28 06				jr z, .bpset 
2d38			;		ld a, '*' 
2d38 cd 40 1a				call bp_off 
2d3b					NEXTW 
2d3b c3 c0 24			jp macro_next 
2d3e				endm 
# End of macro NEXTW
2d3e			 
2d3e			.bpset:	 
2d3e					;	ld (os_view_disable), a 
2d3e cd 34 1a				call bp_on 
2d41			 
2d41			 
2d41					NEXTW 
2d41 c3 c0 24			jp macro_next 
2d44				endm 
# End of macro NEXTW
2d44			 
2d44			 
2d44			.MONITOR: 
2d44				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d44 55				db WORD_SYS_CORE+65             
2d45 75 2d			dw .MALLOC            
2d47 08				db 7 + 1 
2d48 .. 00			db "MONITOR",0              
2d50				endm 
# End of macro CWHEAD
2d50			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d50			; | | At start the current various registers will be displayed with contents. 
2d50			; | | Top right corner will show the most recent debug marker seen. 
2d50			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d50			; | | and the return stack pointer (RSP). 
2d50			; | | Pressing: 
2d50			; | |    1 - Initial screen 
2d50			; | |    2 - Display a data dump of HL 
2d50			; | |    3 - Display a data dump of DE 
2d50			; | |    4 - Display a data dump of BC 
2d50			; | |    5 - Display a data dump of HL 
2d50			; | |    6 - Display a data dump of DSP 
2d50			; | |    7 - Display a data dump of RSP 
2d50			; | |    8 - Display a data dump of what is at DSP 
2d50			; | |    9 - Display a data dump of what is at RSP 
2d50			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d50			; | |    * - Disable break points 
2d50			; | |    # - Enter traditional monitor mode 
2d50			; | | 
2d50			; | | Monitor Mode 
2d50			; | | ------------ 
2d50			; | | A prompt of '>' will be shown for various commands: 
2d50			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d50			; | |    C - Continue display a data dump from the last set address 
2d50			; | |    M xxxx - Set start of memory edit at address xx 
2d50			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d50			; | |    Q - Return to previous 
2d50					if DEBUG_FORTH_WORDS_KEY 
2d50						DMARK "MON" 
2d50 f5				push af  
2d51 3a 65 2d			ld a, (.dmark)  
2d54 32 68 fe			ld (debug_mark),a  
2d57 3a 66 2d			ld a, (.dmark+1)  
2d5a 32 69 fe			ld (debug_mark+1),a  
2d5d 3a 67 2d			ld a, (.dmark+2)  
2d60 32 6a fe			ld (debug_mark+2),a  
2d63 18 03			jr .pastdmark  
2d65 ..			.dmark: db "MON"  
2d68 f1			.pastdmark: pop af  
2d69			endm  
# End of macro DMARK
2d69						CALLMONITOR 
2d69 cd 6c fe			call debug_vector  
2d6c				endm  
# End of macro CALLMONITOR
2d6c					endif 
2d6c			;		ld a, 0 
2d6c			;		ld (os_view_disable), a 
2d6c cd 34 1a				call bp_on 
2d6f			 
2d6f					CALLMONITOR 
2d6f cd 6c fe			call debug_vector  
2d72				endm  
# End of macro CALLMONITOR
2d72			 
2d72			;	call monitor 
2d72			 
2d72					NEXTW 
2d72 c3 c0 24			jp macro_next 
2d75				endm 
# End of macro NEXTW
2d75			 
2d75			 
2d75			.MALLOC: 
2d75				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d75 56				db WORD_SYS_CORE+66             
2d76 9e 2d			dw .MALLOC2            
2d78 06				db 5 + 1 
2d79 .. 00			db "ALLOT",0              
2d7f				endm 
# End of macro CWHEAD
2d7f			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d7f					if DEBUG_FORTH_WORDS_KEY 
2d7f						DMARK "ALL" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 68 fe			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 69 fe			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 6a fe			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "ALL"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98						CALLMONITOR 
2d98 cd 6c fe			call debug_vector  
2d9b				endm  
# End of macro CALLMONITOR
2d9b					endif 
2d9b c3 c5 2d				jp .mallocc 
2d9e			.MALLOC2: 
2d9e				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d9e 56				db WORD_SYS_CORE+66             
2d9f dc 2d			dw .FREE            
2da1 07				db 6 + 1 
2da2 .. 00			db "MALLOC",0              
2da9				endm 
# End of macro CWHEAD
2da9			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2da9					; get byte count 
2da9					if DEBUG_FORTH_WORDS_KEY 
2da9						DMARK "MAL" 
2da9 f5				push af  
2daa 3a be 2d			ld a, (.dmark)  
2dad 32 68 fe			ld (debug_mark),a  
2db0 3a bf 2d			ld a, (.dmark+1)  
2db3 32 69 fe			ld (debug_mark+1),a  
2db6 3a c0 2d			ld a, (.dmark+2)  
2db9 32 6a fe			ld (debug_mark+2),a  
2dbc 18 03			jr .pastdmark  
2dbe ..			.dmark: db "MAL"  
2dc1 f1			.pastdmark: pop af  
2dc2			endm  
# End of macro DMARK
2dc2						CALLMONITOR 
2dc2 cd 6c fe			call debug_vector  
2dc5				endm  
# End of macro CALLMONITOR
2dc5					endif 
2dc5			.mallocc: 
2dc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dc5 cd 0a 23			call macro_dsp_valuehl 
2dc8				endm 
# End of macro FORTH_DSP_VALUEHL
2dc8			 
2dc8			;		push hl 
2dc8			 
2dc8					; destroy value TOS 
2dc8			 
2dc8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dc8 cd c2 23			call macro_forth_dsp_pop 
2dcb				endm 
# End of macro FORTH_DSP_POP
2dcb			 
2dcb			;		pop hl 
2dcb cd 97 14				call malloc 
2dce				if DEBUG_FORTH_MALLOC_GUARD 
2dce f5					push af 
2dcf cd f9 0f				call ishlzero 
2dd2			;		ld a, l 
2dd2			;		add h 
2dd2			;		cp 0 
2dd2 f1					pop af 
2dd3					 
2dd3 cc b2 5d				call z,malloc_error 
2dd6				endif 
2dd6			 
2dd6 cd 13 21				call forth_push_numhl 
2dd9					NEXTW 
2dd9 c3 c0 24			jp macro_next 
2ddc				endm 
# End of macro NEXTW
2ddc			 
2ddc			.FREE: 
2ddc				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2ddc 57				db WORD_SYS_CORE+67             
2ddd 0d 2e			dw .LIST            
2ddf 05				db 4 + 1 
2de0 .. 00			db "FREE",0              
2de5				endm 
# End of macro CWHEAD
2de5			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2de5					if DEBUG_FORTH_WORDS_KEY 
2de5						DMARK "FRE" 
2de5 f5				push af  
2de6 3a fa 2d			ld a, (.dmark)  
2de9 32 68 fe			ld (debug_mark),a  
2dec 3a fb 2d			ld a, (.dmark+1)  
2def 32 69 fe			ld (debug_mark+1),a  
2df2 3a fc 2d			ld a, (.dmark+2)  
2df5 32 6a fe			ld (debug_mark+2),a  
2df8 18 03			jr .pastdmark  
2dfa ..			.dmark: db "FRE"  
2dfd f1			.pastdmark: pop af  
2dfe			endm  
# End of macro DMARK
2dfe						CALLMONITOR 
2dfe cd 6c fe			call debug_vector  
2e01				endm  
# End of macro CALLMONITOR
2e01					endif 
2e01					; get address 
2e01			 
2e01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e01 cd 0a 23			call macro_dsp_valuehl 
2e04				endm 
# End of macro FORTH_DSP_VALUEHL
2e04			 
2e04			;		push hl 
2e04			 
2e04					; destroy value TOS 
2e04			 
2e04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e04 cd c2 23			call macro_forth_dsp_pop 
2e07				endm 
# End of macro FORTH_DSP_POP
2e07			 
2e07			;		pop hl 
2e07			if FORTH_ENABLE_MALLOCFREE 
2e07 cd 61 15				call free 
2e0a			endif 
2e0a					NEXTW 
2e0a c3 c0 24			jp macro_next 
2e0d				endm 
# End of macro NEXTW
2e0d			.LIST: 
2e0d				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2e0d 5c				db WORD_SYS_CORE+72             
2e0e fb 2f			dw .FORGET            
2e10 05				db 4 + 1 
2e11 .. 00			db "LIST",0              
2e16				endm 
# End of macro CWHEAD
2e16			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2e16			; | | The quoted word must be in upper case. 
2e16				if DEBUG_FORTH_WORDS_KEY 
2e16					DMARK "LST" 
2e16 f5				push af  
2e17 3a 2b 2e			ld a, (.dmark)  
2e1a 32 68 fe			ld (debug_mark),a  
2e1d 3a 2c 2e			ld a, (.dmark+1)  
2e20 32 69 fe			ld (debug_mark+1),a  
2e23 3a 2d 2e			ld a, (.dmark+2)  
2e26 32 6a fe			ld (debug_mark+2),a  
2e29 18 03			jr .pastdmark  
2e2b ..			.dmark: db "LST"  
2e2e f1			.pastdmark: pop af  
2e2f			endm  
# End of macro DMARK
2e2f					CALLMONITOR 
2e2f cd 6c fe			call debug_vector  
2e32				endm  
# End of macro CALLMONITOR
2e32				endif 
2e32			 
2e32					FORTH_DSP_VALUEHL 
2e32 cd 0a 23			call macro_dsp_valuehl 
2e35				endm 
# End of macro FORTH_DSP_VALUEHL
2e35			 
2e35 e5					push hl 
2e36					FORTH_DSP_POP 
2e36 cd c2 23			call macro_forth_dsp_pop 
2e39				endm 
# End of macro FORTH_DSP_POP
2e39 c1					pop bc 
2e3a			 
2e3a			; Start format of scratch string 
2e3a			 
2e3a 21 be f1				ld hl, scratch 
2e3d			 
2e3d 3e 3a				ld a, ':' 
2e3f 77					ld (hl),a 
2e40 23					inc hl 
2e41 3e 20				ld a, ' ' 
2e43 77					ld (hl), a 
2e44			 
2e44					; Get ptr to the word we need to look up 
2e44			 
2e44			;		FORTH_DSP_VALUEHL 
2e44					;v5 FORTH_DSP_VALUE 
2e44				; TODO type check 
2e44			;		inc hl    ; Skip type check  
2e44			;		push hl 
2e44			;		ex de, hl    ; put into DE 
2e44			 
2e44			 
2e44 21 00 80				ld hl, baseram 
2e47					;ld hl, baseusermem 
2e47			 
2e47 e5			push hl   ; sacreifical push 
2e48			 
2e48			.ldouscanm: 
2e48 e1				pop hl 
2e49			.ldouscan: 
2e49				if DEBUG_FORTH_WORDS 
2e49					DMARK "LSs" 
2e49 f5				push af  
2e4a 3a 5e 2e			ld a, (.dmark)  
2e4d 32 68 fe			ld (debug_mark),a  
2e50 3a 5f 2e			ld a, (.dmark+1)  
2e53 32 69 fe			ld (debug_mark+1),a  
2e56 3a 60 2e			ld a, (.dmark+2)  
2e59 32 6a fe			ld (debug_mark+2),a  
2e5c 18 03			jr .pastdmark  
2e5e ..			.dmark: db "LSs"  
2e61 f1			.pastdmark: pop af  
2e62			endm  
# End of macro DMARK
2e62					CALLMONITOR 
2e62 cd 6c fe			call debug_vector  
2e65				endm  
# End of macro CALLMONITOR
2e65				endif 
2e65				; skip dict stub 
2e65 cd 11 26				call forth_tok_next 
2e68			 
2e68			 
2e68			; while we have words to look for 
2e68			 
2e68 7e				ld a, (hl)      
2e69				if DEBUG_FORTH_WORDS 
2e69					DMARK "LSk" 
2e69 f5				push af  
2e6a 3a 7e 2e			ld a, (.dmark)  
2e6d 32 68 fe			ld (debug_mark),a  
2e70 3a 7f 2e			ld a, (.dmark+1)  
2e73 32 69 fe			ld (debug_mark+1),a  
2e76 3a 80 2e			ld a, (.dmark+2)  
2e79 32 6a fe			ld (debug_mark+2),a  
2e7c 18 03			jr .pastdmark  
2e7e ..			.dmark: db "LSk"  
2e81 f1			.pastdmark: pop af  
2e82			endm  
# End of macro DMARK
2e82					CALLMONITOR 
2e82 cd 6c fe			call debug_vector  
2e85				endm  
# End of macro CALLMONITOR
2e85				endif 
2e85					;cp WORD_SYS_END 
2e85					;jp z, .lunotfound 
2e85			 
2e85					; if we hit non uwords then gone too far 
2e85 fe 01				cp WORD_SYS_UWORD 
2e87 c2 b7 2f				jp nz, .lunotfound 
2e8a			 
2e8a				if DEBUG_FORTH_WORDS 
2e8a					DMARK "LSu" 
2e8a f5				push af  
2e8b 3a 9f 2e			ld a, (.dmark)  
2e8e 32 68 fe			ld (debug_mark),a  
2e91 3a a0 2e			ld a, (.dmark+1)  
2e94 32 69 fe			ld (debug_mark+1),a  
2e97 3a a1 2e			ld a, (.dmark+2)  
2e9a 32 6a fe			ld (debug_mark+2),a  
2e9d 18 03			jr .pastdmark  
2e9f ..			.dmark: db "LSu"  
2ea2 f1			.pastdmark: pop af  
2ea3			endm  
# End of macro DMARK
2ea3					CALLMONITOR 
2ea3 cd 6c fe			call debug_vector  
2ea6				endm  
# End of macro CALLMONITOR
2ea6				endif 
2ea6			 
2ea6					; found a uword but is it the one we want... 
2ea6			 
2ea6 c5					push bc     ; uword to find is on bc 
2ea7 d1					pop de 
2ea8			 
2ea8 e5					push hl  ; to save the ptr 
2ea9			 
2ea9					; skip opcode 
2ea9 23					inc hl  
2eaa					; skip next ptr 
2eaa 23					inc hl  
2eab 23					inc hl 
2eac					; skip len 
2eac 23					inc hl 
2ead			 
2ead				if DEBUG_FORTH_WORDS 
2ead					DMARK "LSc" 
2ead f5				push af  
2eae 3a c2 2e			ld a, (.dmark)  
2eb1 32 68 fe			ld (debug_mark),a  
2eb4 3a c3 2e			ld a, (.dmark+1)  
2eb7 32 69 fe			ld (debug_mark+1),a  
2eba 3a c4 2e			ld a, (.dmark+2)  
2ebd 32 6a fe			ld (debug_mark+2),a  
2ec0 18 03			jr .pastdmark  
2ec2 ..			.dmark: db "LSc"  
2ec5 f1			.pastdmark: pop af  
2ec6			endm  
# End of macro DMARK
2ec6					CALLMONITOR 
2ec6 cd 6c fe			call debug_vector  
2ec9				endm  
# End of macro CALLMONITOR
2ec9				endif 
2ec9 cd 66 14				call strcmp 
2ecc c2 48 2e				jp nz, .ldouscanm 
2ecf				 
2ecf			 
2ecf			 
2ecf					; we have a uword so push its name to the stack 
2ecf			 
2ecf			;	   	push hl  ; save so we can move to next dict block 
2ecf e1			pop hl 
2ed0			 
2ed0				if DEBUG_FORTH_WORDS 
2ed0					DMARK "LSm" 
2ed0 f5				push af  
2ed1 3a e5 2e			ld a, (.dmark)  
2ed4 32 68 fe			ld (debug_mark),a  
2ed7 3a e6 2e			ld a, (.dmark+1)  
2eda 32 69 fe			ld (debug_mark+1),a  
2edd 3a e7 2e			ld a, (.dmark+2)  
2ee0 32 6a fe			ld (debug_mark+2),a  
2ee3 18 03			jr .pastdmark  
2ee5 ..			.dmark: db "LSm"  
2ee8 f1			.pastdmark: pop af  
2ee9			endm  
# End of macro DMARK
2ee9					CALLMONITOR 
2ee9 cd 6c fe			call debug_vector  
2eec				endm  
# End of macro CALLMONITOR
2eec				endif 
2eec			 
2eec					; skip opcode 
2eec 23					inc hl  
2eed					; skip next ptr 
2eed 23					inc hl  
2eee 23					inc hl 
2eef					; skip len 
2eef 7e					ld a, (hl)   ; save length to add 
2ef0				if DEBUG_FORTH_WORDS 
2ef0					DMARK "LS2" 
2ef0 f5				push af  
2ef1 3a 05 2f			ld a, (.dmark)  
2ef4 32 68 fe			ld (debug_mark),a  
2ef7 3a 06 2f			ld a, (.dmark+1)  
2efa 32 69 fe			ld (debug_mark+1),a  
2efd 3a 07 2f			ld a, (.dmark+2)  
2f00 32 6a fe			ld (debug_mark+2),a  
2f03 18 03			jr .pastdmark  
2f05 ..			.dmark: db "LS2"  
2f08 f1			.pastdmark: pop af  
2f09			endm  
# End of macro DMARK
2f09					CALLMONITOR 
2f09 cd 6c fe			call debug_vector  
2f0c				endm  
# End of macro CALLMONITOR
2f0c				endif 
2f0c			 
2f0c					; save this location 
2f0c				 
2f0c e5					push hl 
2f0d			 
2f0d 23					inc hl 
2f0e 11 c0 f1				ld de, scratch+2 
2f11 4f					ld c, a 
2f12 06 00				ld b, 0 
2f14			 
2f14				if DEBUG_FORTH_WORDS 
2f14					DMARK "LSn" 
2f14 f5				push af  
2f15 3a 29 2f			ld a, (.dmark)  
2f18 32 68 fe			ld (debug_mark),a  
2f1b 3a 2a 2f			ld a, (.dmark+1)  
2f1e 32 69 fe			ld (debug_mark+1),a  
2f21 3a 2b 2f			ld a, (.dmark+2)  
2f24 32 6a fe			ld (debug_mark+2),a  
2f27 18 03			jr .pastdmark  
2f29 ..			.dmark: db "LSn"  
2f2c f1			.pastdmark: pop af  
2f2d			endm  
# End of macro DMARK
2f2d					CALLMONITOR 
2f2d cd 6c fe			call debug_vector  
2f30				endm  
# End of macro CALLMONITOR
2f30				endif 
2f30			 
2f30					; copy uword name to scratch 
2f30			 
2f30 ed b0				ldir 
2f32			 
2f32 1b					dec de 
2f33 3e 20				ld a, ' '    ; change null to space 
2f35 12					ld (de), a 
2f36			 
2f36 13					inc de 
2f37			 
2f37 d5					push de 
2f38 c1					pop bc     ; move scratch pointer to end of word name and save it 
2f39			 
2f39 e1					pop hl 
2f3a 7e					ld a, (hl) 
2f3b					;inc hl 
2f3b					; skip word string 
2f3b cd d0 0f				call addatohl 
2f3e			 
2f3e 23					inc hl 
2f3f			 
2f3f				if DEBUG_FORTH_WORDS 
2f3f					DMARK "LS3" 
2f3f f5				push af  
2f40 3a 54 2f			ld a, (.dmark)  
2f43 32 68 fe			ld (debug_mark),a  
2f46 3a 55 2f			ld a, (.dmark+1)  
2f49 32 69 fe			ld (debug_mark+1),a  
2f4c 3a 56 2f			ld a, (.dmark+2)  
2f4f 32 6a fe			ld (debug_mark+2),a  
2f52 18 03			jr .pastdmark  
2f54 ..			.dmark: db "LS3"  
2f57 f1			.pastdmark: pop af  
2f58			endm  
# End of macro DMARK
2f58					CALLMONITOR 
2f58 cd 6c fe			call debug_vector  
2f5b				endm  
# End of macro CALLMONITOR
2f5b				endif 
2f5b					; should now be at the start of the machine code to setup the eval of the uword 
2f5b					; now locate the ptr to the string defintion 
2f5b			 
2f5b					; skip ld hl, 
2f5b					; then load the ptr 
2f5b			; TODO use get from hl ptr 
2f5b 23					inc hl 
2f5c 5e					ld e, (hl) 
2f5d 23					inc hl 
2f5e 56					ld d, (hl) 
2f5f eb					ex de, hl 
2f60			 
2f60			 
2f60				if DEBUG_FORTH_WORDS 
2f60					DMARK "LSt" 
2f60 f5				push af  
2f61 3a 75 2f			ld a, (.dmark)  
2f64 32 68 fe			ld (debug_mark),a  
2f67 3a 76 2f			ld a, (.dmark+1)  
2f6a 32 69 fe			ld (debug_mark+1),a  
2f6d 3a 77 2f			ld a, (.dmark+2)  
2f70 32 6a fe			ld (debug_mark+2),a  
2f73 18 03			jr .pastdmark  
2f75 ..			.dmark: db "LSt"  
2f78 f1			.pastdmark: pop af  
2f79			endm  
# End of macro DMARK
2f79					CALLMONITOR 
2f79 cd 6c fe			call debug_vector  
2f7c				endm  
# End of macro CALLMONITOR
2f7c				endif 
2f7c			 
2f7c			; cant push right now due to tokenised strings  
2f7c			 
2f7c			; get the destination of where to copy this definition to. 
2f7c			 
2f7c c5					push bc 
2f7d d1					pop de 
2f7e			 
2f7e 7e			.listl:         ld a,(hl) 
2f7f fe 00				cp 0 
2f81 28 09				jr z, .lreplsp     ; replace zero with space 
2f83					;cp FORTH_END_BUFFER 
2f83 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f85 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f87				 
2f87					; just copy this char as is then 
2f87			 
2f87 12					ld (de), a 
2f88			 
2f88 23			.listnxt:	inc hl 
2f89 13					inc de 
2f8a 18 f2				jr .listl 
2f8c			 
2f8c 3e 20		.lreplsp:	ld a,' ' 
2f8e 12					ld (de), a 
2f8f 18 f7				jr .listnxt 
2f91			 
2f91			; close up uword def 
2f91			 
2f91			.listdone: 
2f91 12					ld (de), a 
2f92 13					inc de 
2f93 3e 00				ld a, 0 
2f95 12					ld (de), a 
2f96			 
2f96			; now have def so clean up and push to stack 
2f96			 
2f96 21 be f1				ld hl, scratch 
2f99				if DEBUG_FORTH_WORDS 
2f99					DMARK "Ltp" 
2f99 f5				push af  
2f9a 3a ae 2f			ld a, (.dmark)  
2f9d 32 68 fe			ld (debug_mark),a  
2fa0 3a af 2f			ld a, (.dmark+1)  
2fa3 32 69 fe			ld (debug_mark+1),a  
2fa6 3a b0 2f			ld a, (.dmark+2)  
2fa9 32 6a fe			ld (debug_mark+2),a  
2fac 18 03			jr .pastdmark  
2fae ..			.dmark: db "Ltp"  
2fb1 f1			.pastdmark: pop af  
2fb2			endm  
# End of macro DMARK
2fb2					CALLMONITOR 
2fb2 cd 6c fe			call debug_vector  
2fb5				endm  
# End of macro CALLMONITOR
2fb5				endif 
2fb5			 
2fb5 18 1f			jr .listpush 
2fb7			 
2fb7			;.lnuword:	pop hl 
2fb7			;		call forth_tok_next 
2fb7			;		jp .ldouscan  
2fb7			 
2fb7			.lunotfound:		  
2fb7			 
2fb7				if DEBUG_FORTH_WORDS 
2fb7					DMARK "LSn" 
2fb7 f5				push af  
2fb8 3a cc 2f			ld a, (.dmark)  
2fbb 32 68 fe			ld (debug_mark),a  
2fbe 3a cd 2f			ld a, (.dmark+1)  
2fc1 32 69 fe			ld (debug_mark+1),a  
2fc4 3a ce 2f			ld a, (.dmark+2)  
2fc7 32 6a fe			ld (debug_mark+2),a  
2fca 18 03			jr .pastdmark  
2fcc ..			.dmark: db "LSn"  
2fcf f1			.pastdmark: pop af  
2fd0			endm  
# End of macro DMARK
2fd0					CALLMONITOR 
2fd0 cd 6c fe			call debug_vector  
2fd3				endm  
# End of macro CALLMONITOR
2fd3				endif 
2fd3			 
2fd3					 
2fd3			;		FORTH_DSP_POP 
2fd3			;		ld hl, .luno 
2fd3			 
2fd3					NEXTW			 
2fd3 c3 c0 24			jp macro_next 
2fd6				endm 
# End of macro NEXTW
2fd6			 
2fd6			.listpush: 
2fd6				if DEBUG_FORTH_WORDS 
2fd6					DMARK "LS>" 
2fd6 f5				push af  
2fd7 3a eb 2f			ld a, (.dmark)  
2fda 32 68 fe			ld (debug_mark),a  
2fdd 3a ec 2f			ld a, (.dmark+1)  
2fe0 32 69 fe			ld (debug_mark+1),a  
2fe3 3a ed 2f			ld a, (.dmark+2)  
2fe6 32 6a fe			ld (debug_mark+2),a  
2fe9 18 03			jr .pastdmark  
2feb ..			.dmark: db "LS>"  
2fee f1			.pastdmark: pop af  
2fef			endm  
# End of macro DMARK
2fef					CALLMONITOR 
2fef cd 6c fe			call debug_vector  
2ff2				endm  
# End of macro CALLMONITOR
2ff2				endif 
2ff2 cd 81 21				call forth_push_str 
2ff5			 
2ff5			 
2ff5			 
2ff5					NEXTW 
2ff5 c3 c0 24			jp macro_next 
2ff8				endm 
# End of macro NEXTW
2ff8			 
2ff8			;.luno:    db "Word not found",0 
2ff8			 
2ff8			 
2ff8			 
2ff8			 
2ff8			 
2ff8			;		push hl   ; save pointer to start of uword def string 
2ff8			; 
2ff8			;; look for FORTH_EOL_LINE 
2ff8			;		ld a, FORTH_END_BUFFER 
2ff8			;		call strlent 
2ff8			; 
2ff8			;		inc hl		 ; space for coln def 
2ff8			;		inc hl 
2ff8			;		inc hl          ; space for terms 
2ff8			;		inc hl 
2ff8			; 
2ff8			;		ld a, 20   ; TODO get actual length 
2ff8			;		call addatohl    ; include a random amount of room for the uword name 
2ff8			; 
2ff8			;		 
2ff8			;	if DEBUG_FORTH_WORDS 
2ff8			;		DMARK "Lt1" 
2ff8			;		CALLMONITOR 
2ff8			;	endif 
2ff8			;		 
2ff8			; 
2ff8			;; malloc space for the string because we cant change it 
2ff8			; 
2ff8			;		call malloc 
2ff8			;	if DEBUG_FORTH_MALLOC_GUARD 
2ff8			;		push af 
2ff8			;		call ishlzero 
2ff8			;		pop af 
2ff8			;		 
2ff8			;		call z,malloc_error 
2ff8			;	endif 
2ff8			; 
2ff8			;	if DEBUG_FORTH_WORDS 
2ff8			;		DMARK "Lt2" 
2ff8			;		CALLMONITOR 
2ff8			;	endif 
2ff8			;		pop de 
2ff8			;		push hl    ; push the malloc to release later 
2ff8			;		push hl   ;  push back a copy for the later stack push 
2ff8			;		 
2ff8			;; copy the string swapping out the zero terms for spaces 
2ff8			; 
2ff8			;		; de has our source 
2ff8			;		; hl has our dest 
2ff8			; 
2ff8			;; add the coln def 
2ff8			; 
2ff8			;		ld a, ':' 
2ff8			;		ld (hl), a 
2ff8			;		inc hl 
2ff8			;		ld a, ' ' 
2ff8			;		ld (hl), a 
2ff8			;		inc hl 
2ff8			; 
2ff8			;; add the uname word 
2ff8			;		push de   ; save our string for now 
2ff8			;		ex de, hl 
2ff8			; 
2ff8			;		FORTH_DSP_VALUE 
2ff8			;		;v5 FORTH_DSP_VALUE 
2ff8			; 
2ff8			;		inc hl   ; skip type but we know by now this is OK 
2ff8			; 
2ff8			;.luword:	ld a,(hl) 
2ff8			;		cp 0 
2ff8			;		jr z, .luword2 
2ff8			;		ld (de), a 
2ff8			;		inc de 
2ff8			;		inc hl 
2ff8			;		jr .luword 
2ff8			; 
2ff8			;.luword2:	ld a, ' ' 
2ff8			;		ld (de), a 
2ff8			;;		inc hl 
2ff8			;;		inc de 
2ff8			;;		ld (de), a 
2ff8			;;		inc hl 
2ff8			;		inc de 
2ff8			; 
2ff8			;		ex de, hl 
2ff8			;		pop de 
2ff8			;		 
2ff8			;		 
2ff8			; 
2ff8			;; detoken that string and copy it 
2ff8			; 
2ff8			;	if DEBUG_FORTH_WORDS 
2ff8			;		DMARK "Lt2" 
2ff8			;		CALLMONITOR 
2ff8			;	endif 
2ff8			;.ldetok:	ld a, (de) 
2ff8			;		cp FORTH_END_BUFFER 
2ff8			;		jr z, .ldetokend 
2ff8			;		; swap out any zero term for space 
2ff8			;		cp 0 
2ff8			;		jr nz, .ldetoknext 
2ff8			;		ld a, ' ' 
2ff8			; 
2ff8			;	if DEBUG_FORTH_WORDS 
2ff8			;		DMARK "LtS" 
2ff8			;		CALLMONITOR 
2ff8			;	endif 
2ff8			;.ldetoknext:	ld (hl), a 
2ff8			;		inc de 
2ff8			;		inc hl 
2ff8			;		jr .ldetok 
2ff8			; 
2ff8			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2ff8			;		ld (hl), a  
2ff8			; 
2ff8			;; free that temp malloc 
2ff8			; 
2ff8			;		pop hl    
2ff8			; 
2ff8			;	if DEBUG_FORTH_WORDS 
2ff8			;		DMARK "Lt4" 
2ff8			;		CALLMONITOR 
2ff8			;	endif 
2ff8			;		call forth_apushstrhl 
2ff8			; 
2ff8			;		; get rid of temp malloc area 
2ff8			; 
2ff8			;		pop hl 
2ff8			;		call free 
2ff8			; 
2ff8			;		jr .ludone 
2ff8			; 
2ff8			;.lnuword:	pop hl 
2ff8			;		call forth_tok_next 
2ff8			;		jp .ldouscan  
2ff8			; 
2ff8			;.ludone:		 pop hl 
2ff8			; 
2ff8					NEXTW 
2ff8 c3 c0 24			jp macro_next 
2ffb				endm 
# End of macro NEXTW
2ffb			 
2ffb			.FORGET: 
2ffb				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2ffb 5d				db WORD_SYS_CORE+73             
2ffc 74 30			dw .NOP            
2ffe 07				db 6 + 1 
2fff .. 00			db "FORGET",0              
3006				endm 
# End of macro CWHEAD
3006			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
3006			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
3006			; | |  
3006			; | | e.g. "MORE" forget 
3006					if DEBUG_FORTH_WORDS_KEY 
3006						DMARK "FRG" 
3006 f5				push af  
3007 3a 1b 30			ld a, (.dmark)  
300a 32 68 fe			ld (debug_mark),a  
300d 3a 1c 30			ld a, (.dmark+1)  
3010 32 69 fe			ld (debug_mark+1),a  
3013 3a 1d 30			ld a, (.dmark+2)  
3016 32 6a fe			ld (debug_mark+2),a  
3019 18 03			jr .pastdmark  
301b ..			.dmark: db "FRG"  
301e f1			.pastdmark: pop af  
301f			endm  
# End of macro DMARK
301f						CALLMONITOR 
301f cd 6c fe			call debug_vector  
3022				endm  
# End of macro CALLMONITOR
3022					endif 
3022			 
3022				; find uword 
3022			        ; update start of word with "_" 
3022				; replace uword with deleted flag 
3022			 
3022			 
3022			;	if DEBUG_FORTH_WORDS 
3022			;		DMARK "FOG" 
3022			;		CALLMONITOR 
3022			;	endif 
3022			 
3022			 
3022					; Get ptr to the word we need to look up 
3022			 
3022					FORTH_DSP_VALUEHL 
3022 cd 0a 23			call macro_dsp_valuehl 
3025				endm 
# End of macro FORTH_DSP_VALUEHL
3025					;v5 FORTH_DSP_VALUE 
3025				; TODO type check 
3025			;		inc hl    ; Skip type check  
3025 e5					push hl 
3026 c1					pop bc 
3027			;		ex de, hl    ; put into DE 
3027			 
3027			 
3027 21 00 80				ld hl, baseram 
302a					;ld hl, baseusermem 
302a			 
302a				; skip dict stub 
302a			;	call forth_tok_next 
302a e5			push hl   ; sacreifical push 
302b			 
302b			.fldouscanm: 
302b e1				pop hl 
302c			.fldouscan: 
302c			;	if DEBUG_FORTH_WORDS 
302c			;		DMARK "LSs" 
302c			;		CALLMONITOR 
302c			;	endif 
302c				; skip dict stub 
302c cd 11 26				call forth_tok_next 
302f			 
302f			 
302f			; while we have words to look for 
302f			 
302f 7e				ld a, (hl)      
3030			;	if DEBUG_FORTH_WORDS 
3030			;		DMARK "LSk" 
3030			;		CALLMONITOR 
3030			;	endif 
3030 fe 00				cp WORD_SYS_END 
3032 ca 6e 30				jp z, .flunotfound 
3035 fe 01				cp WORD_SYS_UWORD 
3037 c2 2c 30				jp nz, .fldouscan 
303a			 
303a			;	if DEBUG_FORTH_WORDS 
303a			;		DMARK "LSu" 
303a			;		CALLMONITOR 
303a			;	endif 
303a			 
303a					; found a uword but is it the one we want... 
303a			 
303a c5					push bc     ; uword to find is on bc 
303b d1					pop de 
303c			 
303c e5					push hl  ; to save the ptr 
303d			 
303d					; skip opcode 
303d 23					inc hl  
303e					; skip next ptr 
303e 23					inc hl  
303f 23					inc hl 
3040					; skip len 
3040 23					inc hl 
3041			 
3041			;	if DEBUG_FORTH_WORDS 
3041			;		DMARK "LSc" 
3041			;		CALLMONITOR 
3041			;	endif 
3041 cd 66 14				call strcmp 
3044 c2 2b 30				jp nz, .fldouscanm 
3047			; 
3047			; 
3047			;; while we have words to look for 
3047			; 
3047			;.fdouscan:	ld a, (hl)      
3047			;	if DEBUG_FORTH_WORDS 
3047			;		DMARK "LSs" 
3047			;		CALLMONITOR 
3047			;	endif 
3047			;		cp WORD_SYS_END 
3047			;		jp z, .fudone 
3047			;		cp WORD_SYS_UWORD 
3047			;		jp nz, .fnuword 
3047			; 
3047			;	if DEBUG_FORTH_WORDS 
3047			;		DMARK "FGu" 
3047			;		CALLMONITOR 
3047			;	endif 
3047			; 
3047			;		; found a uword but is it the one we want... 
3047			; 
3047			; 
3047			;	        pop de   ; get back the dsp name 
3047			;		push de 
3047			; 
3047			;		push hl  ; to save the ptr 
3047			; 
3047			;		; skip opcode 
3047			;		inc hl  
3047			;		; skip next ptr 
3047			;		inc hl  
3047			;		inc hl 
3047			;		; skip len 
3047			;		inc hl 
3047			; 
3047			;	if DEBUG_FORTH_WORDS 
3047			;		DMARK "FGc" 
3047			;		CALLMONITOR 
3047			;	endif 
3047			;		call strcmp 
3047			;		jp nz, .fnuword 
3047			 
3047			 
3047 e1			pop hl 
3048			 
3048				 
3048				if DEBUG_FORTH_WORDS 
3048					DMARK "FGm" 
3048 f5				push af  
3049 3a 5d 30			ld a, (.dmark)  
304c 32 68 fe			ld (debug_mark),a  
304f 3a 5e 30			ld a, (.dmark+1)  
3052 32 69 fe			ld (debug_mark+1),a  
3055 3a 5f 30			ld a, (.dmark+2)  
3058 32 6a fe			ld (debug_mark+2),a  
305b 18 03			jr .pastdmark  
305d ..			.dmark: db "FGm"  
3060 f1			.pastdmark: pop af  
3061			endm  
# End of macro DMARK
3061					CALLMONITOR 
3061 cd 6c fe			call debug_vector  
3064				endm  
# End of macro CALLMONITOR
3064				endif 
3064			 
3064			 
3064			 
3064					; we have a uword so push its name to the stack 
3064			 
3064			;	   	push hl  ; save so we can move to next dict block 
3064			;pop hl 
3064			 
3064					; update opcode to deleted 
3064 3e 03				ld a, WORD_SYS_DELETED 
3066 77					ld (hl), a 
3067			 
3067 23					inc hl  
3068					; skip next ptr 
3068 23					inc hl  
3069 23					inc hl 
306a					; skip len 
306a 23					inc hl 
306b			 
306b					; TODO change parser to skip deleted words but for now mark it out 
306b 3e 5f				ld a, "_" 
306d 77					ld  (hl),a 
306e			 
306e			;		jr .fudone 
306e			; 
306e			;.fnuword:	pop hl 
306e			;		call forth_tok_next 
306e			;		jp .fdouscan  
306e			 
306e			.flunotfound:		  
306e			 
306e			 
306e					 
306e					FORTH_DSP_POP 
306e cd c2 23			call macro_forth_dsp_pop 
3071				endm 
# End of macro FORTH_DSP_POP
3071			;		ld hl, .luno 
3071			;.fudone:		 pop hl 
3071					NEXTW 
3071 c3 c0 24			jp macro_next 
3074				endm 
# End of macro NEXTW
3074			.NOP: 
3074				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3074 61				db WORD_SYS_CORE+77             
3075 9b 30			dw .COMO            
3077 04				db 3 + 1 
3078 .. 00			db "NOP",0              
307c				endm 
# End of macro CWHEAD
307c			; | NOP (  --  ) Do nothing | DONE 
307c					if DEBUG_FORTH_WORDS_KEY 
307c						DMARK "NOP" 
307c f5				push af  
307d 3a 91 30			ld a, (.dmark)  
3080 32 68 fe			ld (debug_mark),a  
3083 3a 92 30			ld a, (.dmark+1)  
3086 32 69 fe			ld (debug_mark+1),a  
3089 3a 93 30			ld a, (.dmark+2)  
308c 32 6a fe			ld (debug_mark+2),a  
308f 18 03			jr .pastdmark  
3091 ..			.dmark: db "NOP"  
3094 f1			.pastdmark: pop af  
3095			endm  
# End of macro DMARK
3095						CALLMONITOR 
3095 cd 6c fe			call debug_vector  
3098				endm  
# End of macro CALLMONITOR
3098					endif 
3098				       NEXTW 
3098 c3 c0 24			jp macro_next 
309b				endm 
# End of macro NEXTW
309b			.COMO: 
309b				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
309b 6e				db WORD_SYS_CORE+90             
309c ed 30			dw .COMC            
309e 02				db 1 + 1 
309f .. 00			db "(",0              
30a1				endm 
# End of macro CWHEAD
30a1			; | ( ( -- )  Start of comment | DONE 
30a1			 
30a1			 
30a1 2a bf f4				ld hl, ( os_tok_ptr) 
30a4 11 e8 30			ld de, .closepar 
30a7					 
30a7					if DEBUG_FORTH_WORDS 
30a7						DMARK ").." 
30a7 f5				push af  
30a8 3a bc 30			ld a, (.dmark)  
30ab 32 68 fe			ld (debug_mark),a  
30ae 3a bd 30			ld a, (.dmark+1)  
30b1 32 69 fe			ld (debug_mark+1),a  
30b4 3a be 30			ld a, (.dmark+2)  
30b7 32 6a fe			ld (debug_mark+2),a  
30ba 18 03			jr .pastdmark  
30bc ..			.dmark: db ").."  
30bf f1			.pastdmark: pop af  
30c0			endm  
# End of macro DMARK
30c0						CALLMONITOR 
30c0 cd 6c fe			call debug_vector  
30c3				endm  
# End of macro CALLMONITOR
30c3					endif 
30c3 cd db 25			call findnexttok  
30c6			 
30c6					if DEBUG_FORTH_WORDS 
30c6						DMARK "IF5" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 68 fe			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 69 fe			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 6a fe			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "IF5"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df						CALLMONITOR 
30df cd 6c fe			call debug_vector  
30e2				endm  
# End of macro CALLMONITOR
30e2					endif 
30e2				; replace below with ) exec using tok_ptr 
30e2 22 bf f4			ld (os_tok_ptr), hl 
30e5 c3 51 25			jp exec1 
30e8			 
30e8 .. 00			.closepar:   db ")",0 
30ea			 
30ea				       NEXTW 
30ea c3 c0 24			jp macro_next 
30ed				endm 
# End of macro NEXTW
30ed			.COMC: 
30ed				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30ed 6f				db WORD_SYS_CORE+91             
30ee f6 30			dw .SCRATCH            
30f0 02				db 1 + 1 
30f1 .. 00			db ")",0              
30f3				endm 
# End of macro CWHEAD
30f3			; | ) ( -- )  End of comment |  DONE  
30f3				       NEXTW 
30f3 c3 c0 24			jp macro_next 
30f6				endm 
# End of macro NEXTW
30f6			 
30f6			.SCRATCH: 
30f6				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30f6 6f				db WORD_SYS_CORE+91             
30f7 31 31			dw .INC            
30f9 08				db 7 + 1 
30fa .. 00			db "SCRATCH",0              
3102				endm 
# End of macro CWHEAD
3102			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3102			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3102			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3102			; | |  
3102			; | | e.g.    : score $00 scratch ; 
3102			; | |  
3102			; | | $00 score ! 
3102			; | | $01 score +! 
3102			; | |  
3102			; | | e.g.   : varword $0a scratch ;  
3102			; | | 
3102			; | | $8000 varword ! 
3102					if DEBUG_FORTH_WORDS_KEY 
3102						DMARK "SCR" 
3102 f5				push af  
3103 3a 17 31			ld a, (.dmark)  
3106 32 68 fe			ld (debug_mark),a  
3109 3a 18 31			ld a, (.dmark+1)  
310c 32 69 fe			ld (debug_mark+1),a  
310f 3a 19 31			ld a, (.dmark+2)  
3112 32 6a fe			ld (debug_mark+2),a  
3115 18 03			jr .pastdmark  
3117 ..			.dmark: db "SCR"  
311a f1			.pastdmark: pop af  
311b			endm  
# End of macro DMARK
311b						CALLMONITOR 
311b cd 6c fe			call debug_vector  
311e				endm  
# End of macro CALLMONITOR
311e					endif 
311e			 
311e					FORTH_DSP_VALUEHL 
311e cd 0a 23			call macro_dsp_valuehl 
3121				endm 
# End of macro FORTH_DSP_VALUEHL
3121				 
3121					FORTH_DSP_POP 
3121 cd c2 23			call macro_forth_dsp_pop 
3124				endm 
# End of macro FORTH_DSP_POP
3124			 
3124 7d					ld a, l 
3125 21 e3 f6				ld hl, os_var_array 
3128 cd d0 0f				call addatohl 
312b			 
312b cd 13 21				call forth_push_numhl 
312e			 
312e				       NEXTW 
312e c3 c0 24			jp macro_next 
3131				endm 
# End of macro NEXTW
3131			 
3131			.INC: 
3131				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3131 6f				db WORD_SYS_CORE+91             
3132 85 31			dw .DEC            
3134 03				db 2 + 1 
3135 .. 00			db "+!",0              
3138				endm 
# End of macro CWHEAD
3138			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3138					if DEBUG_FORTH_WORDS_KEY 
3138						DMARK "+s_" 
3138 f5				push af  
3139 3a 4d 31			ld a, (.dmark)  
313c 32 68 fe			ld (debug_mark),a  
313f 3a 4e 31			ld a, (.dmark+1)  
3142 32 69 fe			ld (debug_mark+1),a  
3145 3a 4f 31			ld a, (.dmark+2)  
3148 32 6a fe			ld (debug_mark+2),a  
314b 18 03			jr .pastdmark  
314d ..			.dmark: db "+s_"  
3150 f1			.pastdmark: pop af  
3151			endm  
# End of macro DMARK
3151						CALLMONITOR 
3151 cd 6c fe			call debug_vector  
3154				endm  
# End of macro CALLMONITOR
3154					endif 
3154			 
3154					FORTH_DSP_VALUEHL 
3154 cd 0a 23			call macro_dsp_valuehl 
3157				endm 
# End of macro FORTH_DSP_VALUEHL
3157			 
3157 e5					push hl   ; save address 
3158			 
3158					FORTH_DSP_POP 
3158 cd c2 23			call macro_forth_dsp_pop 
315b				endm 
# End of macro FORTH_DSP_POP
315b			 
315b					FORTH_DSP_VALUEHL 
315b cd 0a 23			call macro_dsp_valuehl 
315e				endm 
# End of macro FORTH_DSP_VALUEHL
315e			 
315e					FORTH_DSP_POP 
315e cd c2 23			call macro_forth_dsp_pop 
3161				endm 
# End of macro FORTH_DSP_POP
3161			 
3161					; hl contains value to add to byte at a 
3161				 
3161 eb					ex de, hl 
3162			 
3162 e1					pop hl 
3163			 
3163					if DEBUG_FORTH_WORDS 
3163						DMARK "INC" 
3163 f5				push af  
3164 3a 78 31			ld a, (.dmark)  
3167 32 68 fe			ld (debug_mark),a  
316a 3a 79 31			ld a, (.dmark+1)  
316d 32 69 fe			ld (debug_mark+1),a  
3170 3a 7a 31			ld a, (.dmark+2)  
3173 32 6a fe			ld (debug_mark+2),a  
3176 18 03			jr .pastdmark  
3178 ..			.dmark: db "INC"  
317b f1			.pastdmark: pop af  
317c			endm  
# End of macro DMARK
317c						CALLMONITOR 
317c cd 6c fe			call debug_vector  
317f				endm  
# End of macro CALLMONITOR
317f					endif 
317f			 
317f 7e					ld a,(hl) 
3180 83					add e 
3181 77					ld (hl),a 
3182			 
3182			 
3182			 
3182				       NEXTW 
3182 c3 c0 24			jp macro_next 
3185				endm 
# End of macro NEXTW
3185			 
3185			.DEC: 
3185				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3185 6f				db WORD_SYS_CORE+91             
3186 d6 31			dw .INC2            
3188 03				db 2 + 1 
3189 .. 00			db "-!",0              
318c				endm 
# End of macro CWHEAD
318c			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
318c					if DEBUG_FORTH_WORDS_KEY 
318c						DMARK "-s_" 
318c f5				push af  
318d 3a a1 31			ld a, (.dmark)  
3190 32 68 fe			ld (debug_mark),a  
3193 3a a2 31			ld a, (.dmark+1)  
3196 32 69 fe			ld (debug_mark+1),a  
3199 3a a3 31			ld a, (.dmark+2)  
319c 32 6a fe			ld (debug_mark+2),a  
319f 18 03			jr .pastdmark  
31a1 ..			.dmark: db "-s_"  
31a4 f1			.pastdmark: pop af  
31a5			endm  
# End of macro DMARK
31a5						CALLMONITOR 
31a5 cd 6c fe			call debug_vector  
31a8				endm  
# End of macro CALLMONITOR
31a8					endif 
31a8			 
31a8					FORTH_DSP_VALUEHL 
31a8 cd 0a 23			call macro_dsp_valuehl 
31ab				endm 
# End of macro FORTH_DSP_VALUEHL
31ab			 
31ab e5					push hl   ; save address 
31ac			 
31ac					FORTH_DSP_POP 
31ac cd c2 23			call macro_forth_dsp_pop 
31af				endm 
# End of macro FORTH_DSP_POP
31af			 
31af					FORTH_DSP_VALUEHL 
31af cd 0a 23			call macro_dsp_valuehl 
31b2				endm 
# End of macro FORTH_DSP_VALUEHL
31b2			 
31b2					; hl contains value to add to byte at a 
31b2				 
31b2 eb					ex de, hl 
31b3			 
31b3 e1					pop hl 
31b4			 
31b4					if DEBUG_FORTH_WORDS 
31b4						DMARK "DEC" 
31b4 f5				push af  
31b5 3a c9 31			ld a, (.dmark)  
31b8 32 68 fe			ld (debug_mark),a  
31bb 3a ca 31			ld a, (.dmark+1)  
31be 32 69 fe			ld (debug_mark+1),a  
31c1 3a cb 31			ld a, (.dmark+2)  
31c4 32 6a fe			ld (debug_mark+2),a  
31c7 18 03			jr .pastdmark  
31c9 ..			.dmark: db "DEC"  
31cc f1			.pastdmark: pop af  
31cd			endm  
# End of macro DMARK
31cd						CALLMONITOR 
31cd cd 6c fe			call debug_vector  
31d0				endm  
# End of macro CALLMONITOR
31d0					endif 
31d0			 
31d0 7e					ld a,(hl) 
31d1 93					sub e 
31d2 77					ld (hl),a 
31d3			 
31d3			 
31d3			 
31d3				       NEXTW 
31d3 c3 c0 24			jp macro_next 
31d6				endm 
# End of macro NEXTW
31d6			 
31d6			.INC2: 
31d6				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31d6 6f				db WORD_SYS_CORE+91             
31d7 80 32			dw .DEC2            
31d9 04				db 3 + 1 
31da .. 00			db "+2!",0              
31de				endm 
# End of macro CWHEAD
31de			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31de			 
31de					if DEBUG_FORTH_WORDS_KEY 
31de						DMARK "+2s" 
31de f5				push af  
31df 3a f3 31			ld a, (.dmark)  
31e2 32 68 fe			ld (debug_mark),a  
31e5 3a f4 31			ld a, (.dmark+1)  
31e8 32 69 fe			ld (debug_mark+1),a  
31eb 3a f5 31			ld a, (.dmark+2)  
31ee 32 6a fe			ld (debug_mark+2),a  
31f1 18 03			jr .pastdmark  
31f3 ..			.dmark: db "+2s"  
31f6 f1			.pastdmark: pop af  
31f7			endm  
# End of macro DMARK
31f7						CALLMONITOR 
31f7 cd 6c fe			call debug_vector  
31fa				endm  
# End of macro CALLMONITOR
31fa					endif 
31fa			 
31fa					; Address 
31fa			 
31fa					FORTH_DSP_VALUEHL 
31fa cd 0a 23			call macro_dsp_valuehl 
31fd				endm 
# End of macro FORTH_DSP_VALUEHL
31fd			 
31fd e5					push hl    ; save address 
31fe			 
31fe					; load content into de 
31fe			 
31fe 5e					ld e,(hl) 
31ff 23					inc hl 
3200 56					ld d, (hl) 
3201			 
3201					if DEBUG_FORTH_WORDS 
3201						DMARK "+2a" 
3201 f5				push af  
3202 3a 16 32			ld a, (.dmark)  
3205 32 68 fe			ld (debug_mark),a  
3208 3a 17 32			ld a, (.dmark+1)  
320b 32 69 fe			ld (debug_mark+1),a  
320e 3a 18 32			ld a, (.dmark+2)  
3211 32 6a fe			ld (debug_mark+2),a  
3214 18 03			jr .pastdmark  
3216 ..			.dmark: db "+2a"  
3219 f1			.pastdmark: pop af  
321a			endm  
# End of macro DMARK
321a						CALLMONITOR 
321a cd 6c fe			call debug_vector  
321d				endm  
# End of macro CALLMONITOR
321d					endif 
321d			 
321d					FORTH_DSP_POP 
321d cd c2 23			call macro_forth_dsp_pop 
3220				endm 
# End of macro FORTH_DSP_POP
3220			 
3220					; Get value to add 
3220			 
3220					FORTH_DSP_VALUE 
3220 cd f3 22			call macro_forth_dsp_value 
3223				endm 
# End of macro FORTH_DSP_VALUE
3223			 
3223					if DEBUG_FORTH_WORDS 
3223						DMARK "+2v" 
3223 f5				push af  
3224 3a 38 32			ld a, (.dmark)  
3227 32 68 fe			ld (debug_mark),a  
322a 3a 39 32			ld a, (.dmark+1)  
322d 32 69 fe			ld (debug_mark+1),a  
3230 3a 3a 32			ld a, (.dmark+2)  
3233 32 6a fe			ld (debug_mark+2),a  
3236 18 03			jr .pastdmark  
3238 ..			.dmark: db "+2v"  
323b f1			.pastdmark: pop af  
323c			endm  
# End of macro DMARK
323c						CALLMONITOR 
323c cd 6c fe			call debug_vector  
323f				endm  
# End of macro CALLMONITOR
323f					endif 
323f			 
323f 19					add hl, de 
3240			 
3240					if DEBUG_FORTH_WORDS 
3240						DMARK "+2+" 
3240 f5				push af  
3241 3a 55 32			ld a, (.dmark)  
3244 32 68 fe			ld (debug_mark),a  
3247 3a 56 32			ld a, (.dmark+1)  
324a 32 69 fe			ld (debug_mark+1),a  
324d 3a 57 32			ld a, (.dmark+2)  
3250 32 6a fe			ld (debug_mark+2),a  
3253 18 03			jr .pastdmark  
3255 ..			.dmark: db "+2+"  
3258 f1			.pastdmark: pop af  
3259			endm  
# End of macro DMARK
3259						CALLMONITOR 
3259 cd 6c fe			call debug_vector  
325c				endm  
# End of macro CALLMONITOR
325c					endif 
325c			 
325c					; move result to de 
325c			 
325c eb					ex de, hl 
325d			 
325d					; Address 
325d			 
325d e1					pop hl 
325e			 
325e					; save it back 
325e			 
325e 73					ld (hl), e 
325f 23					inc hl 
3260 72					ld (hl), d 
3261			 
3261					if DEBUG_FORTH_WORDS 
3261						DMARK "+2e" 
3261 f5				push af  
3262 3a 76 32			ld a, (.dmark)  
3265 32 68 fe			ld (debug_mark),a  
3268 3a 77 32			ld a, (.dmark+1)  
326b 32 69 fe			ld (debug_mark+1),a  
326e 3a 78 32			ld a, (.dmark+2)  
3271 32 6a fe			ld (debug_mark+2),a  
3274 18 03			jr .pastdmark  
3276 ..			.dmark: db "+2e"  
3279 f1			.pastdmark: pop af  
327a			endm  
# End of macro DMARK
327a						CALLMONITOR 
327a cd 6c fe			call debug_vector  
327d				endm  
# End of macro CALLMONITOR
327d					endif 
327d			 
327d			 
327d			 
327d			 
327d			 
327d				       NEXTW 
327d c3 c0 24			jp macro_next 
3280				endm 
# End of macro NEXTW
3280			 
3280			.DEC2: 
3280				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3280 6f				db WORD_SYS_CORE+91             
3281 2c 33			dw .GET2            
3283 04				db 3 + 1 
3284 .. 00			db "-2!",0              
3288				endm 
# End of macro CWHEAD
3288			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3288			 
3288			 
3288					if DEBUG_FORTH_WORDS_KEY 
3288						DMARK "-2s" 
3288 f5				push af  
3289 3a 9d 32			ld a, (.dmark)  
328c 32 68 fe			ld (debug_mark),a  
328f 3a 9e 32			ld a, (.dmark+1)  
3292 32 69 fe			ld (debug_mark+1),a  
3295 3a 9f 32			ld a, (.dmark+2)  
3298 32 6a fe			ld (debug_mark+2),a  
329b 18 03			jr .pastdmark  
329d ..			.dmark: db "-2s"  
32a0 f1			.pastdmark: pop af  
32a1			endm  
# End of macro DMARK
32a1						CALLMONITOR 
32a1 cd 6c fe			call debug_vector  
32a4				endm  
# End of macro CALLMONITOR
32a4					endif 
32a4			 
32a4					; Address 
32a4			 
32a4					FORTH_DSP_VALUEHL 
32a4 cd 0a 23			call macro_dsp_valuehl 
32a7				endm 
# End of macro FORTH_DSP_VALUEHL
32a7			 
32a7 e5					push hl    ; save address 
32a8			 
32a8					; load content into de 
32a8			 
32a8 5e					ld e,(hl) 
32a9 23					inc hl 
32aa 56					ld d, (hl) 
32ab			 
32ab					if DEBUG_FORTH_WORDS 
32ab						DMARK "-2a" 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 68 fe			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 69 fe			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 6a fe			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "-2a"  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd 6c fe			call debug_vector  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7			 
32c7					FORTH_DSP_POP 
32c7 cd c2 23			call macro_forth_dsp_pop 
32ca				endm 
# End of macro FORTH_DSP_POP
32ca			 
32ca					; Get value to remove 
32ca			 
32ca					FORTH_DSP_VALUE 
32ca cd f3 22			call macro_forth_dsp_value 
32cd				endm 
# End of macro FORTH_DSP_VALUE
32cd			 
32cd					if DEBUG_FORTH_WORDS 
32cd						DMARK "-2v" 
32cd f5				push af  
32ce 3a e2 32			ld a, (.dmark)  
32d1 32 68 fe			ld (debug_mark),a  
32d4 3a e3 32			ld a, (.dmark+1)  
32d7 32 69 fe			ld (debug_mark+1),a  
32da 3a e4 32			ld a, (.dmark+2)  
32dd 32 6a fe			ld (debug_mark+2),a  
32e0 18 03			jr .pastdmark  
32e2 ..			.dmark: db "-2v"  
32e5 f1			.pastdmark: pop af  
32e6			endm  
# End of macro DMARK
32e6						CALLMONITOR 
32e6 cd 6c fe			call debug_vector  
32e9				endm  
# End of macro CALLMONITOR
32e9					endif 
32e9			 
32e9 eb					ex de, hl 
32ea ed 52				sbc hl, de 
32ec			 
32ec					if DEBUG_FORTH_WORDS 
32ec						DMARK "-2d" 
32ec f5				push af  
32ed 3a 01 33			ld a, (.dmark)  
32f0 32 68 fe			ld (debug_mark),a  
32f3 3a 02 33			ld a, (.dmark+1)  
32f6 32 69 fe			ld (debug_mark+1),a  
32f9 3a 03 33			ld a, (.dmark+2)  
32fc 32 6a fe			ld (debug_mark+2),a  
32ff 18 03			jr .pastdmark  
3301 ..			.dmark: db "-2d"  
3304 f1			.pastdmark: pop af  
3305			endm  
# End of macro DMARK
3305						CALLMONITOR 
3305 cd 6c fe			call debug_vector  
3308				endm  
# End of macro CALLMONITOR
3308					endif 
3308			 
3308					; move result to de 
3308			 
3308 eb					ex de, hl 
3309			 
3309					; Address 
3309			 
3309 e1					pop hl 
330a			 
330a					; save it back 
330a			 
330a 73					ld (hl), e 
330b 23					inc hl 
330c 72					ld (hl), d 
330d			 
330d					if DEBUG_FORTH_WORDS 
330d						DMARK "-2e" 
330d f5				push af  
330e 3a 22 33			ld a, (.dmark)  
3311 32 68 fe			ld (debug_mark),a  
3314 3a 23 33			ld a, (.dmark+1)  
3317 32 69 fe			ld (debug_mark+1),a  
331a 3a 24 33			ld a, (.dmark+2)  
331d 32 6a fe			ld (debug_mark+2),a  
3320 18 03			jr .pastdmark  
3322 ..			.dmark: db "-2e"  
3325 f1			.pastdmark: pop af  
3326			endm  
# End of macro DMARK
3326						CALLMONITOR 
3326 cd 6c fe			call debug_vector  
3329				endm  
# End of macro CALLMONITOR
3329					endif 
3329			 
3329			 
3329			 
3329			 
3329			 
3329				       NEXTW 
3329 c3 c0 24			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			.GET2: 
332c				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
332c 6f				db WORD_SYS_CORE+91             
332d 5c 33			dw .BANG2            
332f 03				db 2 + 1 
3330 .. 00			db "2@",0              
3333				endm 
# End of macro CWHEAD
3333			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3333					if DEBUG_FORTH_WORDS_KEY 
3333						DMARK "2A_" 
3333 f5				push af  
3334 3a 48 33			ld a, (.dmark)  
3337 32 68 fe			ld (debug_mark),a  
333a 3a 49 33			ld a, (.dmark+1)  
333d 32 69 fe			ld (debug_mark+1),a  
3340 3a 4a 33			ld a, (.dmark+2)  
3343 32 6a fe			ld (debug_mark+2),a  
3346 18 03			jr .pastdmark  
3348 ..			.dmark: db "2A_"  
334b f1			.pastdmark: pop af  
334c			endm  
# End of macro DMARK
334c						CALLMONITOR 
334c cd 6c fe			call debug_vector  
334f				endm  
# End of macro CALLMONITOR
334f					endif 
334f			 
334f					FORTH_DSP_VALUEHL 
334f cd 0a 23			call macro_dsp_valuehl 
3352				endm 
# End of macro FORTH_DSP_VALUEHL
3352			 
3352 5e					ld e, (hl) 
3353 23					inc hl 
3354 56					ld d, (hl) 
3355			 
3355 eb					ex de, hl 
3356			 
3356 cd 13 21				call forth_push_numhl 
3359			 
3359				       NEXTW 
3359 c3 c0 24			jp macro_next 
335c				endm 
# End of macro NEXTW
335c			.BANG2: 
335c				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
335c 6f				db WORD_SYS_CORE+91             
335d 94 33			dw .CONFIG            
335f 03				db 2 + 1 
3360 .. 00			db "2!",0              
3363				endm 
# End of macro CWHEAD
3363			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3363					if DEBUG_FORTH_WORDS_KEY 
3363						DMARK "2S_" 
3363 f5				push af  
3364 3a 78 33			ld a, (.dmark)  
3367 32 68 fe			ld (debug_mark),a  
336a 3a 79 33			ld a, (.dmark+1)  
336d 32 69 fe			ld (debug_mark+1),a  
3370 3a 7a 33			ld a, (.dmark+2)  
3373 32 6a fe			ld (debug_mark+2),a  
3376 18 03			jr .pastdmark  
3378 ..			.dmark: db "2S_"  
337b f1			.pastdmark: pop af  
337c			endm  
# End of macro DMARK
337c						CALLMONITOR 
337c cd 6c fe			call debug_vector  
337f				endm  
# End of macro CALLMONITOR
337f					endif 
337f			 
337f					FORTH_DSP_VALUEHL 
337f cd 0a 23			call macro_dsp_valuehl 
3382				endm 
# End of macro FORTH_DSP_VALUEHL
3382			 
3382 e5					push hl   ; save address 
3383			 
3383			 
3383					FORTH_DSP_POP 
3383 cd c2 23			call macro_forth_dsp_pop 
3386				endm 
# End of macro FORTH_DSP_POP
3386			 
3386					 
3386					FORTH_DSP_VALUEHL 
3386 cd 0a 23			call macro_dsp_valuehl 
3389				endm 
# End of macro FORTH_DSP_VALUEHL
3389			 
3389					FORTH_DSP_POP 
3389 cd c2 23			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c			 
338c eb					ex de, hl    ; value now in de 
338d			 
338d e1					pop hl 
338e			 
338e 73					ld (hl), e 
338f			 
338f 23					inc hl 
3390			 
3390 72					ld (hl), d 
3391			 
3391			 
3391				       NEXTW 
3391 c3 c0 24			jp macro_next 
3394				endm 
# End of macro NEXTW
3394			.CONFIG: 
3394				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3394 6f				db WORD_SYS_CORE+91             
3395 a5 33			dw .ENDCORE            
3397 07				db 6 + 1 
3398 .. 00			db "CONFIG",0              
339f				endm 
# End of macro CWHEAD
339f			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
339f			 
339f cd 30 16				call config 
33a2					NEXTW 
33a2 c3 c0 24			jp macro_next 
33a5				endm 
# End of macro NEXTW
33a5			.ENDCORE: 
33a5			 
33a5			; eof 
33a5			 
33a5			 
# End of file forth_words_core.asm
33a5			include "forth_words_flow.asm" 
33a5			 
33a5			; | ## Program Flow Words 
33a5			 
33a5			.IF: 
33a5				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
33a5 1e				db WORD_SYS_CORE+10             
33a6 9a 34			dw .THEN            
33a8 03				db 2 + 1 
33a9 .. 00			db "IF",0              
33ac				endm 
# End of macro CWHEAD
33ac			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
33ac			; 
33ac					if DEBUG_FORTH_WORDS_KEY 
33ac						DMARK "IF." 
33ac f5				push af  
33ad 3a c1 33			ld a, (.dmark)  
33b0 32 68 fe			ld (debug_mark),a  
33b3 3a c2 33			ld a, (.dmark+1)  
33b6 32 69 fe			ld (debug_mark+1),a  
33b9 3a c3 33			ld a, (.dmark+2)  
33bc 32 6a fe			ld (debug_mark+2),a  
33bf 18 03			jr .pastdmark  
33c1 ..			.dmark: db "IF."  
33c4 f1			.pastdmark: pop af  
33c5			endm  
# End of macro DMARK
33c5						CALLMONITOR 
33c5 cd 6c fe			call debug_vector  
33c8				endm  
# End of macro CALLMONITOR
33c8					endif 
33c8			; eval TOS 
33c8			 
33c8				FORTH_DSP_VALUEHL 
33c8 cd 0a 23			call macro_dsp_valuehl 
33cb				endm 
# End of macro FORTH_DSP_VALUEHL
33cb			 
33cb			;	push hl 
33cb				FORTH_DSP_POP 
33cb cd c2 23			call macro_forth_dsp_pop 
33ce				endm 
# End of macro FORTH_DSP_POP
33ce			;	pop hl 
33ce			 
33ce					if DEBUG_FORTH_WORDS 
33ce						DMARK "IF1" 
33ce f5				push af  
33cf 3a e3 33			ld a, (.dmark)  
33d2 32 68 fe			ld (debug_mark),a  
33d5 3a e4 33			ld a, (.dmark+1)  
33d8 32 69 fe			ld (debug_mark+1),a  
33db 3a e5 33			ld a, (.dmark+2)  
33de 32 6a fe			ld (debug_mark+2),a  
33e1 18 03			jr .pastdmark  
33e3 ..			.dmark: db "IF1"  
33e6 f1			.pastdmark: pop af  
33e7			endm  
# End of macro DMARK
33e7						CALLMONITOR 
33e7 cd 6c fe			call debug_vector  
33ea				endm  
# End of macro CALLMONITOR
33ea					endif 
33ea b7				or a        ; clear carry flag 
33eb 11 00 00			ld de, 0 
33ee eb				ex de,hl 
33ef ed 52			sbc hl, de 
33f1 c2 7b 34			jp nz, .iftrue 
33f4			 
33f4					if DEBUG_FORTH_WORDS 
33f4						DMARK "IF2" 
33f4 f5				push af  
33f5 3a 09 34			ld a, (.dmark)  
33f8 32 68 fe			ld (debug_mark),a  
33fb 3a 0a 34			ld a, (.dmark+1)  
33fe 32 69 fe			ld (debug_mark+1),a  
3401 3a 0b 34			ld a, (.dmark+2)  
3404 32 6a fe			ld (debug_mark+2),a  
3407 18 03			jr .pastdmark  
3409 ..			.dmark: db "IF2"  
340c f1			.pastdmark: pop af  
340d			endm  
# End of macro DMARK
340d						CALLMONITOR 
340d cd 6c fe			call debug_vector  
3410				endm  
# End of macro CALLMONITOR
3410					endif 
3410			 
3410			; if not true then skip to THEN 
3410			 
3410				; TODO get tok_ptr 
3410				; TODO consume toks until we get to THEN 
3410			 
3410 2a bf f4			ld hl, (os_tok_ptr) 
3413					if DEBUG_FORTH_WORDS 
3413						DMARK "IF3" 
3413 f5				push af  
3414 3a 28 34			ld a, (.dmark)  
3417 32 68 fe			ld (debug_mark),a  
341a 3a 29 34			ld a, (.dmark+1)  
341d 32 69 fe			ld (debug_mark+1),a  
3420 3a 2a 34			ld a, (.dmark+2)  
3423 32 6a fe			ld (debug_mark+2),a  
3426 18 03			jr .pastdmark  
3428 ..			.dmark: db "IF3"  
342b f1			.pastdmark: pop af  
342c			endm  
# End of macro DMARK
342c						CALLMONITOR 
342c cd 6c fe			call debug_vector  
342f				endm  
# End of macro CALLMONITOR
342f						 
342f					endif 
342f 11 76 34			ld de, .ifthen 
3432					if DEBUG_FORTH_WORDS 
3432						DMARK "IF4" 
3432 f5				push af  
3433 3a 47 34			ld a, (.dmark)  
3436 32 68 fe			ld (debug_mark),a  
3439 3a 48 34			ld a, (.dmark+1)  
343c 32 69 fe			ld (debug_mark+1),a  
343f 3a 49 34			ld a, (.dmark+2)  
3442 32 6a fe			ld (debug_mark+2),a  
3445 18 03			jr .pastdmark  
3447 ..			.dmark: db "IF4"  
344a f1			.pastdmark: pop af  
344b			endm  
# End of macro DMARK
344b						CALLMONITOR 
344b cd 6c fe			call debug_vector  
344e				endm  
# End of macro CALLMONITOR
344e					endif 
344e cd db 25			call findnexttok  
3451			 
3451					if DEBUG_FORTH_WORDS 
3451						DMARK "IF5" 
3451 f5				push af  
3452 3a 66 34			ld a, (.dmark)  
3455 32 68 fe			ld (debug_mark),a  
3458 3a 67 34			ld a, (.dmark+1)  
345b 32 69 fe			ld (debug_mark+1),a  
345e 3a 68 34			ld a, (.dmark+2)  
3461 32 6a fe			ld (debug_mark+2),a  
3464 18 03			jr .pastdmark  
3466 ..			.dmark: db "IF5"  
3469 f1			.pastdmark: pop af  
346a			endm  
# End of macro DMARK
346a						CALLMONITOR 
346a cd 6c fe			call debug_vector  
346d				endm  
# End of macro CALLMONITOR
346d					endif 
346d				; TODO replace below with ; exec using tok_ptr 
346d 22 bf f4			ld (os_tok_ptr), hl 
3470 c3 51 25			jp exec1 
3473				NEXTW 
3473 c3 c0 24			jp macro_next 
3476				endm 
# End of macro NEXTW
3476			 
3476 .. 00		.ifthen:  db "THEN",0 
347b			 
347b			.iftrue:		 
347b				; Exec next words normally 
347b			 
347b				; if true then exec following IF as normal 
347b					if DEBUG_FORTH_WORDS 
347b						DMARK "IFT" 
347b f5				push af  
347c 3a 90 34			ld a, (.dmark)  
347f 32 68 fe			ld (debug_mark),a  
3482 3a 91 34			ld a, (.dmark+1)  
3485 32 69 fe			ld (debug_mark+1),a  
3488 3a 92 34			ld a, (.dmark+2)  
348b 32 6a fe			ld (debug_mark+2),a  
348e 18 03			jr .pastdmark  
3490 ..			.dmark: db "IFT"  
3493 f1			.pastdmark: pop af  
3494			endm  
# End of macro DMARK
3494						CALLMONITOR 
3494 cd 6c fe			call debug_vector  
3497				endm  
# End of macro CALLMONITOR
3497					endif 
3497			 
3497					NEXTW 
3497 c3 c0 24			jp macro_next 
349a				endm 
# End of macro NEXTW
349a			.THEN: 
349a				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
349a 1f				db WORD_SYS_CORE+11             
349b c2 34			dw .ELSE            
349d 05				db 4 + 1 
349e .. 00			db "THEN",0              
34a3				endm 
# End of macro CWHEAD
34a3			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
34a3					if DEBUG_FORTH_WORDS_KEY 
34a3						DMARK "THN" 
34a3 f5				push af  
34a4 3a b8 34			ld a, (.dmark)  
34a7 32 68 fe			ld (debug_mark),a  
34aa 3a b9 34			ld a, (.dmark+1)  
34ad 32 69 fe			ld (debug_mark+1),a  
34b0 3a ba 34			ld a, (.dmark+2)  
34b3 32 6a fe			ld (debug_mark+2),a  
34b6 18 03			jr .pastdmark  
34b8 ..			.dmark: db "THN"  
34bb f1			.pastdmark: pop af  
34bc			endm  
# End of macro DMARK
34bc						CALLMONITOR 
34bc cd 6c fe			call debug_vector  
34bf				endm  
# End of macro CALLMONITOR
34bf					endif 
34bf					NEXTW 
34bf c3 c0 24			jp macro_next 
34c2				endm 
# End of macro NEXTW
34c2			.ELSE: 
34c2				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
34c2 20				db WORD_SYS_CORE+12             
34c3 ea 34			dw .DO            
34c5 03				db 2 + 1 
34c6 .. 00			db "ELSE",0              
34cb				endm 
# End of macro CWHEAD
34cb			; | ELSE ( -- ) Not supported - does nothing | TODO 
34cb			 
34cb					if DEBUG_FORTH_WORDS_KEY 
34cb						DMARK "ELS" 
34cb f5				push af  
34cc 3a e0 34			ld a, (.dmark)  
34cf 32 68 fe			ld (debug_mark),a  
34d2 3a e1 34			ld a, (.dmark+1)  
34d5 32 69 fe			ld (debug_mark+1),a  
34d8 3a e2 34			ld a, (.dmark+2)  
34db 32 6a fe			ld (debug_mark+2),a  
34de 18 03			jr .pastdmark  
34e0 ..			.dmark: db "ELS"  
34e3 f1			.pastdmark: pop af  
34e4			endm  
# End of macro DMARK
34e4						CALLMONITOR 
34e4 cd 6c fe			call debug_vector  
34e7				endm  
# End of macro CALLMONITOR
34e7					endif 
34e7			 
34e7			 
34e7					NEXTW 
34e7 c3 c0 24			jp macro_next 
34ea				endm 
# End of macro NEXTW
34ea			.DO: 
34ea				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
34ea 21				db WORD_SYS_CORE+13             
34eb 11 36			dw .LOOP            
34ed 03				db 2 + 1 
34ee .. 00			db "DO",0              
34f1				endm 
# End of macro CWHEAD
34f1			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34f1			 
34f1					if DEBUG_FORTH_WORDS_KEY 
34f1						DMARK "DO." 
34f1 f5				push af  
34f2 3a 06 35			ld a, (.dmark)  
34f5 32 68 fe			ld (debug_mark),a  
34f8 3a 07 35			ld a, (.dmark+1)  
34fb 32 69 fe			ld (debug_mark+1),a  
34fe 3a 08 35			ld a, (.dmark+2)  
3501 32 6a fe			ld (debug_mark+2),a  
3504 18 03			jr .pastdmark  
3506 ..			.dmark: db "DO."  
3509 f1			.pastdmark: pop af  
350a			endm  
# End of macro DMARK
350a						CALLMONITOR 
350a cd 6c fe			call debug_vector  
350d				endm  
# End of macro CALLMONITOR
350d					endif 
350d			;  push pc to rsp stack past the DO 
350d			 
350d 2a bf f4				ld hl, (os_tok_ptr) 
3510 23					inc hl   ; D 
3511 23					inc hl  ; O 
3512 23					inc hl   ; null 
3513					if DEBUG_FORTH_WORDS 
3513						DMARK "DO2" 
3513 f5				push af  
3514 3a 28 35			ld a, (.dmark)  
3517 32 68 fe			ld (debug_mark),a  
351a 3a 29 35			ld a, (.dmark+1)  
351d 32 69 fe			ld (debug_mark+1),a  
3520 3a 2a 35			ld a, (.dmark+2)  
3523 32 6a fe			ld (debug_mark+2),a  
3526 18 03			jr .pastdmark  
3528 ..			.dmark: db "DO2"  
352b f1			.pastdmark: pop af  
352c			endm  
# End of macro DMARK
352c						CALLMONITOR 
352c cd 6c fe			call debug_vector  
352f				endm  
# End of macro CALLMONITOR
352f					endif 
352f					FORTH_RSP_NEXT 
352f cd ba 20			call macro_forth_rsp_next 
3532				endm 
# End of macro FORTH_RSP_NEXT
3532					if DEBUG_FORTH_WORDS 
3532						DMARK "DO3" 
3532 f5				push af  
3533 3a 47 35			ld a, (.dmark)  
3536 32 68 fe			ld (debug_mark),a  
3539 3a 48 35			ld a, (.dmark+1)  
353c 32 69 fe			ld (debug_mark+1),a  
353f 3a 49 35			ld a, (.dmark+2)  
3542 32 6a fe			ld (debug_mark+2),a  
3545 18 03			jr .pastdmark  
3547 ..			.dmark: db "DO3"  
354a f1			.pastdmark: pop af  
354b			endm  
# End of macro DMARK
354b						CALLMONITOR 
354b cd 6c fe			call debug_vector  
354e				endm  
# End of macro CALLMONITOR
354e					endif 
354e			 
354e					;if DEBUG_FORTH_WORDS 
354e				;		push hl 
354e			;		endif  
354e			 
354e			; get counters from data stack 
354e			 
354e			 
354e					FORTH_DSP_VALUEHL 
354e cd 0a 23			call macro_dsp_valuehl 
3551				endm 
# End of macro FORTH_DSP_VALUEHL
3551 e5					push hl		 ; hl now has starting counter which needs to be tos 
3552			 
3552					if DEBUG_FORTH_WORDS 
3552						DMARK "DO4" 
3552 f5				push af  
3553 3a 67 35			ld a, (.dmark)  
3556 32 68 fe			ld (debug_mark),a  
3559 3a 68 35			ld a, (.dmark+1)  
355c 32 69 fe			ld (debug_mark+1),a  
355f 3a 69 35			ld a, (.dmark+2)  
3562 32 6a fe			ld (debug_mark+2),a  
3565 18 03			jr .pastdmark  
3567 ..			.dmark: db "DO4"  
356a f1			.pastdmark: pop af  
356b			endm  
# End of macro DMARK
356b						CALLMONITOR 
356b cd 6c fe			call debug_vector  
356e				endm  
# End of macro CALLMONITOR
356e					endif 
356e					FORTH_DSP_POP 
356e cd c2 23			call macro_forth_dsp_pop 
3571				endm 
# End of macro FORTH_DSP_POP
3571			 
3571					if DEBUG_FORTH_WORDS 
3571						DMARK "DO5" 
3571 f5				push af  
3572 3a 86 35			ld a, (.dmark)  
3575 32 68 fe			ld (debug_mark),a  
3578 3a 87 35			ld a, (.dmark+1)  
357b 32 69 fe			ld (debug_mark+1),a  
357e 3a 88 35			ld a, (.dmark+2)  
3581 32 6a fe			ld (debug_mark+2),a  
3584 18 03			jr .pastdmark  
3586 ..			.dmark: db "DO5"  
3589 f1			.pastdmark: pop af  
358a			endm  
# End of macro DMARK
358a						CALLMONITOR 
358a cd 6c fe			call debug_vector  
358d				endm  
# End of macro CALLMONITOR
358d					endif 
358d			 
358d					FORTH_DSP_VALUEHL 
358d cd 0a 23			call macro_dsp_valuehl 
3590				endm 
# End of macro FORTH_DSP_VALUEHL
3590			;		push hl		 ; hl now has starting limit counter 
3590			 
3590					if DEBUG_FORTH_WORDS 
3590						DMARK "DO6" 
3590 f5				push af  
3591 3a a5 35			ld a, (.dmark)  
3594 32 68 fe			ld (debug_mark),a  
3597 3a a6 35			ld a, (.dmark+1)  
359a 32 69 fe			ld (debug_mark+1),a  
359d 3a a7 35			ld a, (.dmark+2)  
35a0 32 6a fe			ld (debug_mark+2),a  
35a3 18 03			jr .pastdmark  
35a5 ..			.dmark: db "DO6"  
35a8 f1			.pastdmark: pop af  
35a9			endm  
# End of macro DMARK
35a9						CALLMONITOR 
35a9 cd 6c fe			call debug_vector  
35ac				endm  
# End of macro CALLMONITOR
35ac					endif 
35ac					FORTH_DSP_POP 
35ac cd c2 23			call macro_forth_dsp_pop 
35af				endm 
# End of macro FORTH_DSP_POP
35af			 
35af			; put counters on the loop stack 
35af			 
35af			;		pop hl			 ; limit counter 
35af d1					pop de			; start counter 
35b0			 
35b0					; push limit counter 
35b0			 
35b0					if DEBUG_FORTH_WORDS 
35b0						DMARK "DO7" 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 68 fe			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 69 fe			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 6a fe			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "DO7"  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9						CALLMONITOR 
35c9 cd 6c fe			call debug_vector  
35cc				endm  
# End of macro CALLMONITOR
35cc					endif 
35cc					FORTH_LOOP_NEXT 
35cc cd 3b 23			call macro_forth_loop_next 
35cf				endm 
# End of macro FORTH_LOOP_NEXT
35cf			 
35cf					; push start counter 
35cf			 
35cf eb					ex de, hl 
35d0					if DEBUG_FORTH_WORDS 
35d0						DMARK "DO7" 
35d0 f5				push af  
35d1 3a e5 35			ld a, (.dmark)  
35d4 32 68 fe			ld (debug_mark),a  
35d7 3a e6 35			ld a, (.dmark+1)  
35da 32 69 fe			ld (debug_mark+1),a  
35dd 3a e7 35			ld a, (.dmark+2)  
35e0 32 6a fe			ld (debug_mark+2),a  
35e3 18 03			jr .pastdmark  
35e5 ..			.dmark: db "DO7"  
35e8 f1			.pastdmark: pop af  
35e9			endm  
# End of macro DMARK
35e9						CALLMONITOR 
35e9 cd 6c fe			call debug_vector  
35ec				endm  
# End of macro CALLMONITOR
35ec					endif 
35ec					FORTH_LOOP_NEXT 
35ec cd 3b 23			call macro_forth_loop_next 
35ef				endm 
# End of macro FORTH_LOOP_NEXT
35ef			 
35ef			 
35ef					; init first round of I counter 
35ef			 
35ef 22 e3 f4				ld (os_current_i), hl 
35f2			 
35f2					if DEBUG_FORTH_WORDS 
35f2						DMARK "DO8" 
35f2 f5				push af  
35f3 3a 07 36			ld a, (.dmark)  
35f6 32 68 fe			ld (debug_mark),a  
35f9 3a 08 36			ld a, (.dmark+1)  
35fc 32 69 fe			ld (debug_mark+1),a  
35ff 3a 09 36			ld a, (.dmark+2)  
3602 32 6a fe			ld (debug_mark+2),a  
3605 18 03			jr .pastdmark  
3607 ..			.dmark: db "DO8"  
360a f1			.pastdmark: pop af  
360b			endm  
# End of macro DMARK
360b						CALLMONITOR 
360b cd 6c fe			call debug_vector  
360e				endm  
# End of macro CALLMONITOR
360e					endif 
360e			 
360e					NEXTW 
360e c3 c0 24			jp macro_next 
3611				endm 
# End of macro NEXTW
3611			.LOOP: 
3611				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3611 22				db WORD_SYS_CORE+14             
3612 29 37			dw .I            
3614 05				db 4 + 1 
3615 .. 00			db "LOOP",0              
361a				endm 
# End of macro CWHEAD
361a			; | LOOP ( -- ) Increment and test loop counter  | DONE 
361a			 
361a				; pop tos as current loop count to hl 
361a			 
361a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
361a			 
361a				FORTH_LOOP_TOS 
361a cd 6e 23			call macro_forth_loop_tos 
361d				endm 
# End of macro FORTH_LOOP_TOS
361d e5				push hl 
361e			 
361e					if DEBUG_FORTH_WORDS_KEY 
361e						DMARK "LOP" 
361e f5				push af  
361f 3a 33 36			ld a, (.dmark)  
3622 32 68 fe			ld (debug_mark),a  
3625 3a 34 36			ld a, (.dmark+1)  
3628 32 69 fe			ld (debug_mark+1),a  
362b 3a 35 36			ld a, (.dmark+2)  
362e 32 6a fe			ld (debug_mark+2),a  
3631 18 03			jr .pastdmark  
3633 ..			.dmark: db "LOP"  
3636 f1			.pastdmark: pop af  
3637			endm  
# End of macro DMARK
3637						CALLMONITOR 
3637 cd 6c fe			call debug_vector  
363a				endm  
# End of macro CALLMONITOR
363a					endif 
363a				; next item on the stack is the limit. get it 
363a			 
363a			 
363a				FORTH_LOOP_POP 
363a cd 78 23			call macro_forth_loop_pop 
363d				endm 
# End of macro FORTH_LOOP_POP
363d			 
363d				FORTH_LOOP_TOS 
363d cd 6e 23			call macro_forth_loop_tos 
3640				endm 
# End of macro FORTH_LOOP_TOS
3640			 
3640 d1				pop de		 ; de = i, hl = limit 
3641			 
3641					if DEBUG_FORTH_WORDS 
3641						DMARK "LP1" 
3641 f5				push af  
3642 3a 56 36			ld a, (.dmark)  
3645 32 68 fe			ld (debug_mark),a  
3648 3a 57 36			ld a, (.dmark+1)  
364b 32 69 fe			ld (debug_mark+1),a  
364e 3a 58 36			ld a, (.dmark+2)  
3651 32 6a fe			ld (debug_mark+2),a  
3654 18 03			jr .pastdmark  
3656 ..			.dmark: db "LP1"  
3659 f1			.pastdmark: pop af  
365a			endm  
# End of macro DMARK
365a						CALLMONITOR 
365a cd 6c fe			call debug_vector  
365d				endm  
# End of macro CALLMONITOR
365d					endif 
365d			 
365d				; go back to previous word 
365d			 
365d d5				push de    ; save I for inc later 
365e			 
365e			 
365e				; get limit 
365e				;  is I at limit? 
365e			 
365e			 
365e					if DEBUG_FORTH_WORDS 
365e						DMARK "LP1" 
365e f5				push af  
365f 3a 73 36			ld a, (.dmark)  
3662 32 68 fe			ld (debug_mark),a  
3665 3a 74 36			ld a, (.dmark+1)  
3668 32 69 fe			ld (debug_mark+1),a  
366b 3a 75 36			ld a, (.dmark+2)  
366e 32 6a fe			ld (debug_mark+2),a  
3671 18 03			jr .pastdmark  
3673 ..			.dmark: db "LP1"  
3676 f1			.pastdmark: pop af  
3677			endm  
# End of macro DMARK
3677						CALLMONITOR 
3677 cd 6c fe			call debug_vector  
367a				endm  
# End of macro CALLMONITOR
367a					endif 
367a			 
367a ed 52			sbc hl, de 
367c			 
367c			 
367c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
367c			 
367c 20 26				jr nz, .loopnotdone 
367e			 
367e e1				pop hl   ; get rid of saved I 
367f				FORTH_LOOP_POP     ; get rid of limit 
367f cd 78 23			call macro_forth_loop_pop 
3682				endm 
# End of macro FORTH_LOOP_POP
3682			 
3682				FORTH_RSP_POP     ; get rid of DO ptr 
3682 cd db 20			call macro_forth_rsp_pop 
3685				endm 
# End of macro FORTH_RSP_POP
3685			 
3685			if DEBUG_FORTH_WORDS 
3685						DMARK "LP>" 
3685 f5				push af  
3686 3a 9a 36			ld a, (.dmark)  
3689 32 68 fe			ld (debug_mark),a  
368c 3a 9b 36			ld a, (.dmark+1)  
368f 32 69 fe			ld (debug_mark+1),a  
3692 3a 9c 36			ld a, (.dmark+2)  
3695 32 6a fe			ld (debug_mark+2),a  
3698 18 03			jr .pastdmark  
369a ..			.dmark: db "LP>"  
369d f1			.pastdmark: pop af  
369e			endm  
# End of macro DMARK
369e				CALLMONITOR 
369e cd 6c fe			call debug_vector  
36a1				endm  
# End of macro CALLMONITOR
36a1			endif 
36a1			 
36a1					NEXTW 
36a1 c3 c0 24			jp macro_next 
36a4				endm 
# End of macro NEXTW
36a4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36a4			 
36a4			.loopnotdone: 
36a4			 
36a4 e1				pop hl    ; get I 
36a5 23				inc hl 
36a6			 
36a6			   	; save new I 
36a6			 
36a6			 
36a6					; set I counter 
36a6			 
36a6 22 e3 f4				ld (os_current_i), hl 
36a9			 
36a9					if DEBUG_FORTH_WORDS 
36a9						DMARK "LPN" 
36a9 f5				push af  
36aa 3a be 36			ld a, (.dmark)  
36ad 32 68 fe			ld (debug_mark),a  
36b0 3a bf 36			ld a, (.dmark+1)  
36b3 32 69 fe			ld (debug_mark+1),a  
36b6 3a c0 36			ld a, (.dmark+2)  
36b9 32 6a fe			ld (debug_mark+2),a  
36bc 18 03			jr .pastdmark  
36be ..			.dmark: db "LPN"  
36c1 f1			.pastdmark: pop af  
36c2			endm  
# End of macro DMARK
36c2					CALLMONITOR 
36c2 cd 6c fe			call debug_vector  
36c5				endm  
# End of macro CALLMONITOR
36c5					endif 
36c5					 
36c5				FORTH_LOOP_NEXT 
36c5 cd 3b 23			call macro_forth_loop_next 
36c8				endm 
# End of macro FORTH_LOOP_NEXT
36c8			 
36c8			 
36c8					if DEBUG_FORTH_WORDS 
36c8 eb						ex de,hl 
36c9					endif 
36c9			 
36c9			;	; get DO ptr 
36c9			; 
36c9					if DEBUG_FORTH_WORDS 
36c9						DMARK "LP7" 
36c9 f5				push af  
36ca 3a de 36			ld a, (.dmark)  
36cd 32 68 fe			ld (debug_mark),a  
36d0 3a df 36			ld a, (.dmark+1)  
36d3 32 69 fe			ld (debug_mark+1),a  
36d6 3a e0 36			ld a, (.dmark+2)  
36d9 32 6a fe			ld (debug_mark+2),a  
36dc 18 03			jr .pastdmark  
36de ..			.dmark: db "LP7"  
36e1 f1			.pastdmark: pop af  
36e2			endm  
# End of macro DMARK
36e2					CALLMONITOR 
36e2 cd 6c fe			call debug_vector  
36e5				endm  
# End of macro CALLMONITOR
36e5					endif 
36e5				FORTH_RSP_TOS 
36e5 cd d1 20			call macro_forth_rsp_tos 
36e8				endm 
# End of macro FORTH_RSP_TOS
36e8			 
36e8					if DEBUG_FORTH_WORDS 
36e8						DMARK "LP8" 
36e8 f5				push af  
36e9 3a fd 36			ld a, (.dmark)  
36ec 32 68 fe			ld (debug_mark),a  
36ef 3a fe 36			ld a, (.dmark+1)  
36f2 32 69 fe			ld (debug_mark+1),a  
36f5 3a ff 36			ld a, (.dmark+2)  
36f8 32 6a fe			ld (debug_mark+2),a  
36fb 18 03			jr .pastdmark  
36fd ..			.dmark: db "LP8"  
3700 f1			.pastdmark: pop af  
3701			endm  
# End of macro DMARK
3701					CALLMONITOR 
3701 cd 6c fe			call debug_vector  
3704				endm  
# End of macro CALLMONITOR
3704					endif 
3704				;push hl 
3704			 
3704				; not going to DO any more 
3704				; get rid of the RSP pointer as DO will add it back in 
3704				;FORTH_RSP_POP 
3704				;pop hl 
3704			 
3704				;ld hl,(cli_ret_sp) 
3704				;ld e, (hl) 
3704				;inc hl 
3704				;ld d, (hl) 
3704				;ex de,hl 
3704 22 bf f4			ld (os_tok_ptr), hl 
3707					if DEBUG_FORTH_WORDS 
3707						DMARK "LP<" 
3707 f5				push af  
3708 3a 1c 37			ld a, (.dmark)  
370b 32 68 fe			ld (debug_mark),a  
370e 3a 1d 37			ld a, (.dmark+1)  
3711 32 69 fe			ld (debug_mark+1),a  
3714 3a 1e 37			ld a, (.dmark+2)  
3717 32 6a fe			ld (debug_mark+2),a  
371a 18 03			jr .pastdmark  
371c ..			.dmark: db "LP<"  
371f f1			.pastdmark: pop af  
3720			endm  
# End of macro DMARK
3720					CALLMONITOR 
3720 cd 6c fe			call debug_vector  
3723				endm  
# End of macro CALLMONITOR
3723				endif 
3723 c3 51 25			jp exec1 
3726			 
3726					 
3726			 
3726			 
3726					NEXTW 
3726 c3 c0 24			jp macro_next 
3729				endm 
# End of macro NEXTW
3729			.I:  
3729			 
3729				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3729 5e				db WORD_SYS_CORE+74             
372a 54 37			dw .DLOOP            
372c 02				db 1 + 1 
372d .. 00			db "I",0              
372f				endm 
# End of macro CWHEAD
372f			; | I ( -- ) Current loop counter | DONE 
372f					if DEBUG_FORTH_WORDS_KEY 
372f						DMARK "I.." 
372f f5				push af  
3730 3a 44 37			ld a, (.dmark)  
3733 32 68 fe			ld (debug_mark),a  
3736 3a 45 37			ld a, (.dmark+1)  
3739 32 69 fe			ld (debug_mark+1),a  
373c 3a 46 37			ld a, (.dmark+2)  
373f 32 6a fe			ld (debug_mark+2),a  
3742 18 03			jr .pastdmark  
3744 ..			.dmark: db "I.."  
3747 f1			.pastdmark: pop af  
3748			endm  
# End of macro DMARK
3748						CALLMONITOR 
3748 cd 6c fe			call debug_vector  
374b				endm  
# End of macro CALLMONITOR
374b					endif 
374b			 
374b 2a e3 f4				ld hl,(os_current_i) 
374e cd 13 21				call forth_push_numhl 
3751			 
3751					NEXTW 
3751 c3 c0 24			jp macro_next 
3754				endm 
# End of macro NEXTW
3754			.DLOOP: 
3754				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3754 5f				db WORD_SYS_CORE+75             
3755 35 38			dw .REPEAT            
3757 06				db 5 + 1 
3758 .. 00			db "-LOOP",0              
375e				endm 
# End of macro CWHEAD
375e			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
375e				; pop tos as current loop count to hl 
375e					if DEBUG_FORTH_WORDS_KEY 
375e						DMARK "-LP" 
375e f5				push af  
375f 3a 73 37			ld a, (.dmark)  
3762 32 68 fe			ld (debug_mark),a  
3765 3a 74 37			ld a, (.dmark+1)  
3768 32 69 fe			ld (debug_mark+1),a  
376b 3a 75 37			ld a, (.dmark+2)  
376e 32 6a fe			ld (debug_mark+2),a  
3771 18 03			jr .pastdmark  
3773 ..			.dmark: db "-LP"  
3776 f1			.pastdmark: pop af  
3777			endm  
# End of macro DMARK
3777						CALLMONITOR 
3777 cd 6c fe			call debug_vector  
377a				endm  
# End of macro CALLMONITOR
377a					endif 
377a			 
377a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
377a			 
377a				FORTH_LOOP_TOS 
377a cd 6e 23			call macro_forth_loop_tos 
377d				endm 
# End of macro FORTH_LOOP_TOS
377d e5				push hl 
377e			 
377e					if DEBUG_FORTH_WORDS 
377e						DMARK "-LP" 
377e f5				push af  
377f 3a 93 37			ld a, (.dmark)  
3782 32 68 fe			ld (debug_mark),a  
3785 3a 94 37			ld a, (.dmark+1)  
3788 32 69 fe			ld (debug_mark+1),a  
378b 3a 95 37			ld a, (.dmark+2)  
378e 32 6a fe			ld (debug_mark+2),a  
3791 18 03			jr .pastdmark  
3793 ..			.dmark: db "-LP"  
3796 f1			.pastdmark: pop af  
3797			endm  
# End of macro DMARK
3797						CALLMONITOR 
3797 cd 6c fe			call debug_vector  
379a				endm  
# End of macro CALLMONITOR
379a					endif 
379a				; next item on the stack is the limit. get it 
379a			 
379a			 
379a				FORTH_LOOP_POP 
379a cd 78 23			call macro_forth_loop_pop 
379d				endm 
# End of macro FORTH_LOOP_POP
379d			 
379d				FORTH_LOOP_TOS 
379d cd 6e 23			call macro_forth_loop_tos 
37a0				endm 
# End of macro FORTH_LOOP_TOS
37a0			 
37a0 d1				pop de		 ; de = i, hl = limit 
37a1			 
37a1					if DEBUG_FORTH_WORDS 
37a1						DMARK "-L1" 
37a1 f5				push af  
37a2 3a b6 37			ld a, (.dmark)  
37a5 32 68 fe			ld (debug_mark),a  
37a8 3a b7 37			ld a, (.dmark+1)  
37ab 32 69 fe			ld (debug_mark+1),a  
37ae 3a b8 37			ld a, (.dmark+2)  
37b1 32 6a fe			ld (debug_mark+2),a  
37b4 18 03			jr .pastdmark  
37b6 ..			.dmark: db "-L1"  
37b9 f1			.pastdmark: pop af  
37ba			endm  
# End of macro DMARK
37ba						CALLMONITOR 
37ba cd 6c fe			call debug_vector  
37bd				endm  
# End of macro CALLMONITOR
37bd					endif 
37bd			 
37bd				; go back to previous word 
37bd			 
37bd d5				push de    ; save I for inc later 
37be			 
37be			 
37be				; get limit 
37be				;  is I at limit? 
37be			 
37be			 
37be					if DEBUG_FORTH_WORDS 
37be						DMARK "-L1" 
37be f5				push af  
37bf 3a d3 37			ld a, (.dmark)  
37c2 32 68 fe			ld (debug_mark),a  
37c5 3a d4 37			ld a, (.dmark+1)  
37c8 32 69 fe			ld (debug_mark+1),a  
37cb 3a d5 37			ld a, (.dmark+2)  
37ce 32 6a fe			ld (debug_mark+2),a  
37d1 18 03			jr .pastdmark  
37d3 ..			.dmark: db "-L1"  
37d6 f1			.pastdmark: pop af  
37d7			endm  
# End of macro DMARK
37d7						CALLMONITOR 
37d7 cd 6c fe			call debug_vector  
37da				endm  
# End of macro CALLMONITOR
37da					endif 
37da			 
37da ed 52			sbc hl, de 
37dc			 
37dc			 
37dc				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
37dc			 
37dc 20 26				jr nz, .mloopnotdone 
37de			 
37de e1				pop hl   ; get rid of saved I 
37df				FORTH_LOOP_POP     ; get rid of limit 
37df cd 78 23			call macro_forth_loop_pop 
37e2				endm 
# End of macro FORTH_LOOP_POP
37e2			 
37e2				FORTH_RSP_POP     ; get rid of DO ptr 
37e2 cd db 20			call macro_forth_rsp_pop 
37e5				endm 
# End of macro FORTH_RSP_POP
37e5			 
37e5			if DEBUG_FORTH_WORDS 
37e5						DMARK "-L>" 
37e5 f5				push af  
37e6 3a fa 37			ld a, (.dmark)  
37e9 32 68 fe			ld (debug_mark),a  
37ec 3a fb 37			ld a, (.dmark+1)  
37ef 32 69 fe			ld (debug_mark+1),a  
37f2 3a fc 37			ld a, (.dmark+2)  
37f5 32 6a fe			ld (debug_mark+2),a  
37f8 18 03			jr .pastdmark  
37fa ..			.dmark: db "-L>"  
37fd f1			.pastdmark: pop af  
37fe			endm  
# End of macro DMARK
37fe				CALLMONITOR 
37fe cd 6c fe			call debug_vector  
3801				endm  
# End of macro CALLMONITOR
3801			endif 
3801			 
3801					NEXTW 
3801 c3 c0 24			jp macro_next 
3804				endm 
# End of macro NEXTW
3804				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3804			 
3804			.mloopnotdone: 
3804			 
3804 e1				pop hl    ; get I 
3805 2b				dec hl 
3806			 
3806			   	; save new I 
3806			 
3806			 
3806					; set I counter 
3806			 
3806 22 e3 f4				ld (os_current_i), hl 
3809			 
3809					 
3809				FORTH_LOOP_NEXT 
3809 cd 3b 23			call macro_forth_loop_next 
380c				endm 
# End of macro FORTH_LOOP_NEXT
380c			 
380c			 
380c					if DEBUG_FORTH_WORDS 
380c eb						ex de,hl 
380d					endif 
380d			 
380d			;	; get DO ptr 
380d			; 
380d				FORTH_RSP_TOS 
380d cd d1 20			call macro_forth_rsp_tos 
3810				endm 
# End of macro FORTH_RSP_TOS
3810			 
3810				;push hl 
3810			 
3810				; not going to DO any more 
3810				; get rid of the RSP pointer as DO will add it back in 
3810				;FORTH_RSP_POP 
3810				;pop hl 
3810			 
3810			 
3810 22 bf f4			ld (os_tok_ptr), hl 
3813					if DEBUG_FORTH_WORDS 
3813						DMARK "-L<" 
3813 f5				push af  
3814 3a 28 38			ld a, (.dmark)  
3817 32 68 fe			ld (debug_mark),a  
381a 3a 29 38			ld a, (.dmark+1)  
381d 32 69 fe			ld (debug_mark+1),a  
3820 3a 2a 38			ld a, (.dmark+2)  
3823 32 6a fe			ld (debug_mark+2),a  
3826 18 03			jr .pastdmark  
3828 ..			.dmark: db "-L<"  
382b f1			.pastdmark: pop af  
382c			endm  
# End of macro DMARK
382c					CALLMONITOR 
382c cd 6c fe			call debug_vector  
382f				endm  
# End of macro CALLMONITOR
382f				endif 
382f c3 51 25			jp exec1 
3832			 
3832					 
3832			 
3832			 
3832			 
3832				NEXTW 
3832 c3 c0 24			jp macro_next 
3835				endm 
# End of macro NEXTW
3835			 
3835			 
3835			 
3835			 
3835			.REPEAT: 
3835				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3835 71				db WORD_SYS_CORE+93             
3836 88 38			dw .UNTIL            
3838 06				db 5 + 1 
3839 .. 00			db "REPEAT",0              
3840				endm 
# End of macro CWHEAD
3840			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3840			;  push pc to rsp stack past the REPEAT 
3840					if DEBUG_FORTH_WORDS_KEY 
3840						DMARK "REP" 
3840 f5				push af  
3841 3a 55 38			ld a, (.dmark)  
3844 32 68 fe			ld (debug_mark),a  
3847 3a 56 38			ld a, (.dmark+1)  
384a 32 69 fe			ld (debug_mark+1),a  
384d 3a 57 38			ld a, (.dmark+2)  
3850 32 6a fe			ld (debug_mark+2),a  
3853 18 03			jr .pastdmark  
3855 ..			.dmark: db "REP"  
3858 f1			.pastdmark: pop af  
3859			endm  
# End of macro DMARK
3859						CALLMONITOR 
3859 cd 6c fe			call debug_vector  
385c				endm  
# End of macro CALLMONITOR
385c					endif 
385c			 
385c 2a bf f4				ld hl, (os_tok_ptr) 
385f 23					inc hl   ; R 
3860 23					inc hl  ; E 
3861 23					inc hl   ; P 
3862 23					inc hl   ; E 
3863 23					inc hl   ; A 
3864 23					inc hl   ; T 
3865 23					inc hl   ; zero 
3866					FORTH_RSP_NEXT 
3866 cd ba 20			call macro_forth_rsp_next 
3869				endm 
# End of macro FORTH_RSP_NEXT
3869			 
3869			 
3869					if DEBUG_FORTH_WORDS 
3869						DMARK "REP" 
3869 f5				push af  
386a 3a 7e 38			ld a, (.dmark)  
386d 32 68 fe			ld (debug_mark),a  
3870 3a 7f 38			ld a, (.dmark+1)  
3873 32 69 fe			ld (debug_mark+1),a  
3876 3a 80 38			ld a, (.dmark+2)  
3879 32 6a fe			ld (debug_mark+2),a  
387c 18 03			jr .pastdmark  
387e ..			.dmark: db "REP"  
3881 f1			.pastdmark: pop af  
3882			endm  
# End of macro DMARK
3882						;pop bc    ; TODO BUG ?????? what is this for???? 
3882						CALLMONITOR 
3882 cd 6c fe			call debug_vector  
3885				endm  
# End of macro CALLMONITOR
3885					endif 
3885			 
3885					NEXTW 
3885 c3 c0 24			jp macro_next 
3888				endm 
# End of macro NEXTW
3888			;	       NEXTW 
3888			 
3888			.UNTIL: 
3888				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3888 72				db WORD_SYS_CORE+94             
3889 1f 39			dw .ENDFLOW            
388b 06				db 5 + 1 
388c .. 00			db "UNTIL",0              
3892				endm 
# End of macro CWHEAD
3892			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3892			 
3892				; pop tos as check 
3892			 
3892				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3892			 
3892				FORTH_DSP_VALUEHL 
3892 cd 0a 23			call macro_dsp_valuehl 
3895				endm 
# End of macro FORTH_DSP_VALUEHL
3895			 
3895					if DEBUG_FORTH_WORDS_KEY 
3895						DMARK "UNT" 
3895 f5				push af  
3896 3a aa 38			ld a, (.dmark)  
3899 32 68 fe			ld (debug_mark),a  
389c 3a ab 38			ld a, (.dmark+1)  
389f 32 69 fe			ld (debug_mark+1),a  
38a2 3a ac 38			ld a, (.dmark+2)  
38a5 32 6a fe			ld (debug_mark+2),a  
38a8 18 03			jr .pastdmark  
38aa ..			.dmark: db "UNT"  
38ad f1			.pastdmark: pop af  
38ae			endm  
# End of macro DMARK
38ae						CALLMONITOR 
38ae cd 6c fe			call debug_vector  
38b1				endm  
# End of macro CALLMONITOR
38b1					endif 
38b1			 
38b1			;	push hl 
38b1				FORTH_DSP_POP 
38b1 cd c2 23			call macro_forth_dsp_pop 
38b4				endm 
# End of macro FORTH_DSP_POP
38b4			 
38b4			;	pop hl 
38b4			 
38b4				; test if true 
38b4			 
38b4 cd f9 0f			call ishlzero 
38b7			;	ld a,l 
38b7			;	add h 
38b7			; 
38b7			;	cp 0 
38b7			 
38b7 20 3e			jr nz, .untilnotdone 
38b9			 
38b9					if DEBUG_FORTH_WORDS 
38b9						DMARK "UNf" 
38b9 f5				push af  
38ba 3a ce 38			ld a, (.dmark)  
38bd 32 68 fe			ld (debug_mark),a  
38c0 3a cf 38			ld a, (.dmark+1)  
38c3 32 69 fe			ld (debug_mark+1),a  
38c6 3a d0 38			ld a, (.dmark+2)  
38c9 32 6a fe			ld (debug_mark+2),a  
38cc 18 03			jr .pastdmark  
38ce ..			.dmark: db "UNf"  
38d1 f1			.pastdmark: pop af  
38d2			endm  
# End of macro DMARK
38d2						CALLMONITOR 
38d2 cd 6c fe			call debug_vector  
38d5				endm  
# End of macro CALLMONITOR
38d5					endif 
38d5			 
38d5			 
38d5			 
38d5				FORTH_RSP_POP     ; get rid of DO ptr 
38d5 cd db 20			call macro_forth_rsp_pop 
38d8				endm 
# End of macro FORTH_RSP_POP
38d8			 
38d8			if DEBUG_FORTH_WORDS 
38d8						DMARK "UN>" 
38d8 f5				push af  
38d9 3a ed 38			ld a, (.dmark)  
38dc 32 68 fe			ld (debug_mark),a  
38df 3a ee 38			ld a, (.dmark+1)  
38e2 32 69 fe			ld (debug_mark+1),a  
38e5 3a ef 38			ld a, (.dmark+2)  
38e8 32 6a fe			ld (debug_mark+2),a  
38eb 18 03			jr .pastdmark  
38ed ..			.dmark: db "UN>"  
38f0 f1			.pastdmark: pop af  
38f1			endm  
# End of macro DMARK
38f1				CALLMONITOR 
38f1 cd 6c fe			call debug_vector  
38f4				endm  
# End of macro CALLMONITOR
38f4			endif 
38f4			 
38f4					NEXTW 
38f4 c3 c0 24			jp macro_next 
38f7				endm 
# End of macro NEXTW
38f7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38f7			 
38f7			.untilnotdone: 
38f7			 
38f7			 
38f7			;	; get DO ptr 
38f7			; 
38f7				FORTH_RSP_TOS 
38f7 cd d1 20			call macro_forth_rsp_tos 
38fa				endm 
# End of macro FORTH_RSP_TOS
38fa			 
38fa				;push hl 
38fa			 
38fa				; not going to DO any more 
38fa				; get rid of the RSP pointer as DO will add it back in 
38fa				;FORTH_RSP_POP 
38fa				;pop hl 
38fa			 
38fa			 
38fa 22 bf f4			ld (os_tok_ptr), hl 
38fd					if DEBUG_FORTH_WORDS 
38fd						DMARK "UN<" 
38fd f5				push af  
38fe 3a 12 39			ld a, (.dmark)  
3901 32 68 fe			ld (debug_mark),a  
3904 3a 13 39			ld a, (.dmark+1)  
3907 32 69 fe			ld (debug_mark+1),a  
390a 3a 14 39			ld a, (.dmark+2)  
390d 32 6a fe			ld (debug_mark+2),a  
3910 18 03			jr .pastdmark  
3912 ..			.dmark: db "UN<"  
3915 f1			.pastdmark: pop af  
3916			endm  
# End of macro DMARK
3916					CALLMONITOR 
3916 cd 6c fe			call debug_vector  
3919				endm  
# End of macro CALLMONITOR
3919				endif 
3919 c3 51 25			jp exec1 
391c			 
391c					 
391c			 
391c			 
391c					NEXTW 
391c c3 c0 24			jp macro_next 
391f				endm 
# End of macro NEXTW
391f			 
391f			 
391f			.ENDFLOW: 
391f			 
391f			; eof 
391f			 
# End of file forth_words_flow.asm
391f			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
391f			include "forth_words_logic.asm" 
391f			 
391f			; | ## Logic Words 
391f			 
391f			.NOT: 
391f				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
391f 2d				db WORD_SYS_CORE+25             
3920 67 39			dw .IS            
3922 04				db 3 + 1 
3923 .. 00			db "NOT",0              
3927				endm 
# End of macro CWHEAD
3927			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3927					if DEBUG_FORTH_WORDS_KEY 
3927						DMARK "NOT" 
3927 f5				push af  
3928 3a 3c 39			ld a, (.dmark)  
392b 32 68 fe			ld (debug_mark),a  
392e 3a 3d 39			ld a, (.dmark+1)  
3931 32 69 fe			ld (debug_mark+1),a  
3934 3a 3e 39			ld a, (.dmark+2)  
3937 32 6a fe			ld (debug_mark+2),a  
393a 18 03			jr .pastdmark  
393c ..			.dmark: db "NOT"  
393f f1			.pastdmark: pop af  
3940			endm  
# End of macro DMARK
3940						CALLMONITOR 
3940 cd 6c fe			call debug_vector  
3943				endm  
# End of macro CALLMONITOR
3943					endif 
3943					FORTH_DSP 
3943 cd d0 22			call macro_forth_dsp 
3946				endm 
# End of macro FORTH_DSP
3946 7e					ld a,(hl)	; get type of value on TOS 
3947 fe 02				cp DS_TYPE_INUM  
3949 28 03				jr z, .noti 
394b					NEXTW 
394b c3 c0 24			jp macro_next 
394e				endm 
# End of macro NEXTW
394e			.noti:          FORTH_DSP_VALUEHL 
394e cd 0a 23			call macro_dsp_valuehl 
3951				endm 
# End of macro FORTH_DSP_VALUEHL
3951			;		push hl 
3951					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3951 cd c2 23			call macro_forth_dsp_pop 
3954				endm 
# End of macro FORTH_DSP_POP
3954			;		pop hl 
3954 3e 00				ld a,0 
3956 bd					cp l 
3957 28 04				jr z, .not2t 
3959 2e 00				ld l, 0 
395b 18 02				jr .notip 
395d			 
395d 2e ff		.not2t:		ld l, 255 
395f			 
395f 26 00		.notip:		ld h, 0	 
3961			 
3961 cd 13 21				call forth_push_numhl 
3964					NEXTW 
3964 c3 c0 24			jp macro_next 
3967				endm 
# End of macro NEXTW
3967			 
3967			.IS: 
3967				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3967 2d				db WORD_SYS_CORE+25             
3968 8d 39			dw .LZERO            
396a 03				db 2 + 1 
396b .. 00			db "IS",0              
396e				endm 
# End of macro CWHEAD
396e			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
396e					if DEBUG_FORTH_WORDS_KEY 
396e						DMARK "IS." 
396e f5				push af  
396f 3a 83 39			ld a, (.dmark)  
3972 32 68 fe			ld (debug_mark),a  
3975 3a 84 39			ld a, (.dmark+1)  
3978 32 69 fe			ld (debug_mark+1),a  
397b 3a 85 39			ld a, (.dmark+2)  
397e 32 6a fe			ld (debug_mark+2),a  
3981 18 03			jr .pastdmark  
3983 ..			.dmark: db "IS."  
3986 f1			.pastdmark: pop af  
3987			endm  
# End of macro DMARK
3987						CALLMONITOR 
3987 cd 6c fe			call debug_vector  
398a				endm  
# End of macro CALLMONITOR
398a					endif 
398a					NEXTW 
398a c3 c0 24			jp macro_next 
398d				endm 
# End of macro NEXTW
398d			.LZERO: 
398d				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
398d 2d				db WORD_SYS_CORE+25             
398e 97 39			dw .TZERO            
3990 03				db 2 + 1 
3991 .. 00			db "0<",0              
3994				endm 
# End of macro CWHEAD
3994			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3994					NEXTW 
3994 c3 c0 24			jp macro_next 
3997				endm 
# End of macro NEXTW
3997			.TZERO: 
3997				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3997 2e				db WORD_SYS_CORE+26             
3998 de 39			dw .LESS            
399a 03				db 2 + 1 
399b .. 00			db "0=",0              
399e				endm 
# End of macro CWHEAD
399e			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
399e				; TODO add floating point number detection 
399e					;v5 FORTH_DSP_VALUE 
399e					if DEBUG_FORTH_WORDS_KEY 
399e						DMARK "0=." 
399e f5				push af  
399f 3a b3 39			ld a, (.dmark)  
39a2 32 68 fe			ld (debug_mark),a  
39a5 3a b4 39			ld a, (.dmark+1)  
39a8 32 69 fe			ld (debug_mark+1),a  
39ab 3a b5 39			ld a, (.dmark+2)  
39ae 32 6a fe			ld (debug_mark+2),a  
39b1 18 03			jr .pastdmark  
39b3 ..			.dmark: db "0=."  
39b6 f1			.pastdmark: pop af  
39b7			endm  
# End of macro DMARK
39b7						CALLMONITOR 
39b7 cd 6c fe			call debug_vector  
39ba				endm  
# End of macro CALLMONITOR
39ba					endif 
39ba					FORTH_DSP 
39ba cd d0 22			call macro_forth_dsp 
39bd				endm 
# End of macro FORTH_DSP
39bd 7e					ld a,(hl)	; get type of value on TOS 
39be fe 02				cp DS_TYPE_INUM  
39c0 28 00				jr z, .tz_inum 
39c2			 
39c2				if FORTH_ENABLE_FLOATMATH 
39c2					jr .tz_done 
39c2			 
39c2				endif 
39c2					 
39c2			 
39c2			.tz_inum: 
39c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39c2 cd 0a 23			call macro_dsp_valuehl 
39c5				endm 
# End of macro FORTH_DSP_VALUEHL
39c5			 
39c5			;		push hl 
39c5			 
39c5					; destroy value TOS 
39c5			 
39c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c5 cd c2 23			call macro_forth_dsp_pop 
39c8				endm 
# End of macro FORTH_DSP_POP
39c8			 
39c8			;		pop hl 
39c8			 
39c8 3e 00				ld a,0 
39ca			 
39ca bd					cp l 
39cb 20 08				jr nz, .tz_notzero 
39cd			 
39cd bc					cp h 
39ce			 
39ce 20 05				jr nz, .tz_notzero 
39d0			 
39d0			 
39d0 21 01 00				ld hl, FORTH_TRUE 
39d3 18 03				jr .tz_done 
39d5			 
39d5 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
39d8			 
39d8					; push value back onto stack for another op etc 
39d8			 
39d8			.tz_done: 
39d8 cd 13 21				call forth_push_numhl 
39db			 
39db					NEXTW 
39db c3 c0 24			jp macro_next 
39de				endm 
# End of macro NEXTW
39de			.LESS: 
39de				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
39de 2f				db WORD_SYS_CORE+27             
39df 47 3a			dw .GT            
39e1 02				db 1 + 1 
39e2 .. 00			db "<",0              
39e4				endm 
# End of macro CWHEAD
39e4			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
39e4				; TODO add floating point number detection 
39e4					if DEBUG_FORTH_WORDS_KEY 
39e4						DMARK "LES" 
39e4 f5				push af  
39e5 3a f9 39			ld a, (.dmark)  
39e8 32 68 fe			ld (debug_mark),a  
39eb 3a fa 39			ld a, (.dmark+1)  
39ee 32 69 fe			ld (debug_mark+1),a  
39f1 3a fb 39			ld a, (.dmark+2)  
39f4 32 6a fe			ld (debug_mark+2),a  
39f7 18 03			jr .pastdmark  
39f9 ..			.dmark: db "LES"  
39fc f1			.pastdmark: pop af  
39fd			endm  
# End of macro DMARK
39fd						CALLMONITOR 
39fd cd 6c fe			call debug_vector  
3a00				endm  
# End of macro CALLMONITOR
3a00					endif 
3a00					FORTH_DSP 
3a00 cd d0 22			call macro_forth_dsp 
3a03				endm 
# End of macro FORTH_DSP
3a03					;v5 FORTH_DSP_VALUE 
3a03 7e					ld a,(hl)	; get type of value on TOS 
3a04 fe 02				cp DS_TYPE_INUM  
3a06 28 00				jr z, .less_inum 
3a08			 
3a08				if FORTH_ENABLE_FLOATMATH 
3a08					jr .less_done 
3a08			 
3a08				endif 
3a08					 
3a08			 
3a08			.less_inum: 
3a08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a08 cd 0a 23			call macro_dsp_valuehl 
3a0b				endm 
# End of macro FORTH_DSP_VALUEHL
3a0b			 
3a0b e5					push hl  ; u2 
3a0c			 
3a0c					; destroy value TOS 
3a0c			 
3a0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0c cd c2 23			call macro_forth_dsp_pop 
3a0f				endm 
# End of macro FORTH_DSP_POP
3a0f			 
3a0f			 
3a0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a0f cd 0a 23			call macro_dsp_valuehl 
3a12				endm 
# End of macro FORTH_DSP_VALUEHL
3a12			 
3a12 e5					push hl    ; u1 
3a13			 
3a13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a13 cd c2 23			call macro_forth_dsp_pop 
3a16				endm 
# End of macro FORTH_DSP_POP
3a16			 
3a16			 
3a16 b7			 or a      ;clear carry flag 
3a17 01 00 00		 ld bc, FORTH_FALSE 
3a1a e1			  pop hl    ; u1 
3a1b d1			  pop de    ; u2 
3a1c ed 52		  sbc hl,de 
3a1e 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3a20			 
3a20 01 01 00		 ld bc, FORTH_TRUE 
3a23			.lscont:  
3a23 c5					push bc 
3a24 e1					pop hl 
3a25			 
3a25					if DEBUG_FORTH_WORDS 
3a25						DMARK "LT1" 
3a25 f5				push af  
3a26 3a 3a 3a			ld a, (.dmark)  
3a29 32 68 fe			ld (debug_mark),a  
3a2c 3a 3b 3a			ld a, (.dmark+1)  
3a2f 32 69 fe			ld (debug_mark+1),a  
3a32 3a 3c 3a			ld a, (.dmark+2)  
3a35 32 6a fe			ld (debug_mark+2),a  
3a38 18 03			jr .pastdmark  
3a3a ..			.dmark: db "LT1"  
3a3d f1			.pastdmark: pop af  
3a3e			endm  
# End of macro DMARK
3a3e						CALLMONITOR 
3a3e cd 6c fe			call debug_vector  
3a41				endm  
# End of macro CALLMONITOR
3a41					endif 
3a41 cd 13 21				call forth_push_numhl 
3a44			 
3a44					NEXTW 
3a44 c3 c0 24			jp macro_next 
3a47				endm 
# End of macro NEXTW
3a47			.GT: 
3a47				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a47 30				db WORD_SYS_CORE+28             
3a48 b0 3a			dw .EQUAL            
3a4a 02				db 1 + 1 
3a4b .. 00			db ">",0              
3a4d				endm 
# End of macro CWHEAD
3a4d			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a4d				; TODO add floating point number detection 
3a4d					if DEBUG_FORTH_WORDS_KEY 
3a4d						DMARK "GRT" 
3a4d f5				push af  
3a4e 3a 62 3a			ld a, (.dmark)  
3a51 32 68 fe			ld (debug_mark),a  
3a54 3a 63 3a			ld a, (.dmark+1)  
3a57 32 69 fe			ld (debug_mark+1),a  
3a5a 3a 64 3a			ld a, (.dmark+2)  
3a5d 32 6a fe			ld (debug_mark+2),a  
3a60 18 03			jr .pastdmark  
3a62 ..			.dmark: db "GRT"  
3a65 f1			.pastdmark: pop af  
3a66			endm  
# End of macro DMARK
3a66						CALLMONITOR 
3a66 cd 6c fe			call debug_vector  
3a69				endm  
# End of macro CALLMONITOR
3a69					endif 
3a69					FORTH_DSP 
3a69 cd d0 22			call macro_forth_dsp 
3a6c				endm 
# End of macro FORTH_DSP
3a6c					;FORTH_DSP_VALUE 
3a6c 7e					ld a,(hl)	; get type of value on TOS 
3a6d fe 02				cp DS_TYPE_INUM  
3a6f 28 00				jr z, .gt_inum 
3a71			 
3a71				if FORTH_ENABLE_FLOATMATH 
3a71					jr .gt_done 
3a71			 
3a71				endif 
3a71					 
3a71			 
3a71			.gt_inum: 
3a71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a71 cd 0a 23			call macro_dsp_valuehl 
3a74				endm 
# End of macro FORTH_DSP_VALUEHL
3a74			 
3a74 e5					push hl  ; u2 
3a75			 
3a75					; destroy value TOS 
3a75			 
3a75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a75 cd c2 23			call macro_forth_dsp_pop 
3a78				endm 
# End of macro FORTH_DSP_POP
3a78			 
3a78			 
3a78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a78 cd 0a 23			call macro_dsp_valuehl 
3a7b				endm 
# End of macro FORTH_DSP_VALUEHL
3a7b			 
3a7b e5					push hl    ; u1 
3a7c			 
3a7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a7c cd c2 23			call macro_forth_dsp_pop 
3a7f				endm 
# End of macro FORTH_DSP_POP
3a7f			 
3a7f			 
3a7f b7			 or a      ;clear carry flag 
3a80 01 00 00		 ld bc, FORTH_FALSE 
3a83 e1			  pop hl    ; u1 
3a84 d1			  pop de    ; u2 
3a85 ed 52		  sbc hl,de 
3a87 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a89			 
3a89 01 01 00		 ld bc, FORTH_TRUE 
3a8c			.gtcont:  
3a8c c5					push bc 
3a8d e1					pop hl 
3a8e			 
3a8e					if DEBUG_FORTH_WORDS 
3a8e						DMARK "GT1" 
3a8e f5				push af  
3a8f 3a a3 3a			ld a, (.dmark)  
3a92 32 68 fe			ld (debug_mark),a  
3a95 3a a4 3a			ld a, (.dmark+1)  
3a98 32 69 fe			ld (debug_mark+1),a  
3a9b 3a a5 3a			ld a, (.dmark+2)  
3a9e 32 6a fe			ld (debug_mark+2),a  
3aa1 18 03			jr .pastdmark  
3aa3 ..			.dmark: db "GT1"  
3aa6 f1			.pastdmark: pop af  
3aa7			endm  
# End of macro DMARK
3aa7						CALLMONITOR 
3aa7 cd 6c fe			call debug_vector  
3aaa				endm  
# End of macro CALLMONITOR
3aaa					endif 
3aaa cd 13 21				call forth_push_numhl 
3aad			 
3aad					NEXTW 
3aad c3 c0 24			jp macro_next 
3ab0				endm 
# End of macro NEXTW
3ab0			.EQUAL: 
3ab0				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3ab0 31				db WORD_SYS_CORE+29             
3ab1 1b 3b			dw .ENDLOGIC            
3ab3 02				db 1 + 1 
3ab4 .. 00			db "=",0              
3ab6				endm 
# End of macro CWHEAD
3ab6			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3ab6				; TODO add floating point number detection 
3ab6					if DEBUG_FORTH_WORDS_KEY 
3ab6						DMARK "EQ." 
3ab6 f5				push af  
3ab7 3a cb 3a			ld a, (.dmark)  
3aba 32 68 fe			ld (debug_mark),a  
3abd 3a cc 3a			ld a, (.dmark+1)  
3ac0 32 69 fe			ld (debug_mark+1),a  
3ac3 3a cd 3a			ld a, (.dmark+2)  
3ac6 32 6a fe			ld (debug_mark+2),a  
3ac9 18 03			jr .pastdmark  
3acb ..			.dmark: db "EQ."  
3ace f1			.pastdmark: pop af  
3acf			endm  
# End of macro DMARK
3acf						CALLMONITOR 
3acf cd 6c fe			call debug_vector  
3ad2				endm  
# End of macro CALLMONITOR
3ad2					endif 
3ad2					FORTH_DSP 
3ad2 cd d0 22			call macro_forth_dsp 
3ad5				endm 
# End of macro FORTH_DSP
3ad5					;v5 FORTH_DSP_VALUE 
3ad5 7e					ld a,(hl)	; get type of value on TOS 
3ad6 fe 02				cp DS_TYPE_INUM  
3ad8 28 00				jr z, .eq_inum 
3ada			 
3ada				if FORTH_ENABLE_FLOATMATH 
3ada					jr .eq_done 
3ada			 
3ada				endif 
3ada					 
3ada			 
3ada			.eq_inum: 
3ada					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ada cd 0a 23			call macro_dsp_valuehl 
3add				endm 
# End of macro FORTH_DSP_VALUEHL
3add			 
3add e5					push hl 
3ade			 
3ade					; destroy value TOS 
3ade			 
3ade					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ade cd c2 23			call macro_forth_dsp_pop 
3ae1				endm 
# End of macro FORTH_DSP_POP
3ae1			 
3ae1			 
3ae1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae1 cd 0a 23			call macro_dsp_valuehl 
3ae4				endm 
# End of macro FORTH_DSP_VALUEHL
3ae4			 
3ae4					; one value on hl get other one back 
3ae4			 
3ae4 e5					push hl 
3ae5			 
3ae5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ae5 cd c2 23			call macro_forth_dsp_pop 
3ae8				endm 
# End of macro FORTH_DSP_POP
3ae8			 
3ae8 0e 00				ld c, FORTH_FALSE 
3aea			 
3aea e1					pop hl 
3aeb d1					pop de 
3aec			 
3aec 7b					ld a, e 
3aed bd					cp l 
3aee			 
3aee 20 06				jr nz, .eq_done 
3af0			 
3af0 7a					ld a, d 
3af1 bc					cp h 
3af2			 
3af2 20 02				jr nz, .eq_done 
3af4			 
3af4 0e 01				ld c, FORTH_TRUE 
3af6					 
3af6			 
3af6			 
3af6			.eq_done: 
3af6			 
3af6					; TODO push value back onto stack for another op etc 
3af6			 
3af6 26 00				ld h, 0 
3af8 69					ld l, c 
3af9					if DEBUG_FORTH_WORDS 
3af9						DMARK "EQ1" 
3af9 f5				push af  
3afa 3a 0e 3b			ld a, (.dmark)  
3afd 32 68 fe			ld (debug_mark),a  
3b00 3a 0f 3b			ld a, (.dmark+1)  
3b03 32 69 fe			ld (debug_mark+1),a  
3b06 3a 10 3b			ld a, (.dmark+2)  
3b09 32 6a fe			ld (debug_mark+2),a  
3b0c 18 03			jr .pastdmark  
3b0e ..			.dmark: db "EQ1"  
3b11 f1			.pastdmark: pop af  
3b12			endm  
# End of macro DMARK
3b12						CALLMONITOR 
3b12 cd 6c fe			call debug_vector  
3b15				endm  
# End of macro CALLMONITOR
3b15					endif 
3b15 cd 13 21				call forth_push_numhl 
3b18			 
3b18					NEXTW 
3b18 c3 c0 24			jp macro_next 
3b1b				endm 
# End of macro NEXTW
3b1b			 
3b1b			 
3b1b			.ENDLOGIC: 
3b1b			; eof 
3b1b			 
3b1b			 
# End of file forth_words_logic.asm
3b1b			include "forth_words_maths.asm" 
3b1b			 
3b1b			; | ## Maths Words 
3b1b			 
3b1b			.PLUS:	 
3b1b				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3b1b 15				db WORD_SYS_CORE+1             
3b1c 79 3b			dw .NEG            
3b1e 02				db 1 + 1 
3b1f .. 00			db "+",0              
3b21				endm 
# End of macro CWHEAD
3b21			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3b21					if DEBUG_FORTH_WORDS_KEY 
3b21						DMARK "PLU" 
3b21 f5				push af  
3b22 3a 36 3b			ld a, (.dmark)  
3b25 32 68 fe			ld (debug_mark),a  
3b28 3a 37 3b			ld a, (.dmark+1)  
3b2b 32 69 fe			ld (debug_mark+1),a  
3b2e 3a 38 3b			ld a, (.dmark+2)  
3b31 32 6a fe			ld (debug_mark+2),a  
3b34 18 03			jr .pastdmark  
3b36 ..			.dmark: db "PLU"  
3b39 f1			.pastdmark: pop af  
3b3a			endm  
# End of macro DMARK
3b3a						CALLMONITOR 
3b3a cd 6c fe			call debug_vector  
3b3d				endm  
# End of macro CALLMONITOR
3b3d					endif 
3b3d					; add top two values and push back result 
3b3d			 
3b3d					;for v5 FORTH_DSP_VALUE 
3b3d					FORTH_DSP 
3b3d cd d0 22			call macro_forth_dsp 
3b40				endm 
# End of macro FORTH_DSP
3b40 7e					ld a,(hl)	; get type of value on TOS 
3b41 fe 02				cp DS_TYPE_INUM  
3b43 28 03				jr z, .dot_inum 
3b45			 
3b45					NEXTW 
3b45 c3 c0 24			jp macro_next 
3b48				endm 
# End of macro NEXTW
3b48			 
3b48			; float maths 
3b48			 
3b48				if FORTH_ENABLE_FLOATMATH 
3b48						inc hl      ; now at start of numeric as string 
3b48			 
3b48					if DEBUG_FORTH_MATHS 
3b48						DMARK "ADD" 
3b48				CALLMONITOR 
3b48					endif 
3b48			 
3b48					;ld ix, hl 
3b48					call CON 
3b48			 
3b48			 
3b48					push hl 
3b48					 
3b48					 
3b48			 
3b48						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b48			 
3b48					; get next number 
3b48			 
3b48						FORTH_DSP_VALUE 
3b48			 
3b48						inc hl      ; now at start of numeric as string 
3b48			 
3b48					;ld ix, hl 
3b48					call CON 
3b48			 
3b48					push hl 
3b48			 
3b48			 
3b48						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b48			 
3b48						; TODO do add 
3b48			 
3b48						call IADD 
3b48			 
3b48						; TODO get result back as ascii 
3b48			 
3b48						; TODO push result  
3b48			 
3b48			 
3b48			 
3b48						jr .dot_done 
3b48				endif 
3b48			 
3b48			.dot_inum: 
3b48			 
3b48			 
3b48					if DEBUG_FORTH_DOT 
3b48						DMARK "+IT" 
3b48 f5				push af  
3b49 3a 5d 3b			ld a, (.dmark)  
3b4c 32 68 fe			ld (debug_mark),a  
3b4f 3a 5e 3b			ld a, (.dmark+1)  
3b52 32 69 fe			ld (debug_mark+1),a  
3b55 3a 5f 3b			ld a, (.dmark+2)  
3b58 32 6a fe			ld (debug_mark+2),a  
3b5b 18 03			jr .pastdmark  
3b5d ..			.dmark: db "+IT"  
3b60 f1			.pastdmark: pop af  
3b61			endm  
# End of macro DMARK
3b61				CALLMONITOR 
3b61 cd 6c fe			call debug_vector  
3b64				endm  
# End of macro CALLMONITOR
3b64					endif 
3b64			 
3b64					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b64 cd 0a 23			call macro_dsp_valuehl 
3b67				endm 
# End of macro FORTH_DSP_VALUEHL
3b67			 
3b67				; TODO add floating point number detection 
3b67			 
3b67 e5					push hl 
3b68			 
3b68					; destroy value TOS 
3b68			 
3b68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b68 cd c2 23			call macro_forth_dsp_pop 
3b6b				endm 
# End of macro FORTH_DSP_POP
3b6b			 
3b6b			 
3b6b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b6b cd 0a 23			call macro_dsp_valuehl 
3b6e				endm 
# End of macro FORTH_DSP_VALUEHL
3b6e			 
3b6e					; one value on hl get other one back 
3b6e			 
3b6e d1					pop de 
3b6f			 
3b6f					; do the add 
3b6f			 
3b6f 19					add hl,de 
3b70			 
3b70					; save it 
3b70			 
3b70			;		push hl	 
3b70			 
3b70					; 
3b70			 
3b70					; destroy value TOS 
3b70			 
3b70					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b70 cd c2 23			call macro_forth_dsp_pop 
3b73				endm 
# End of macro FORTH_DSP_POP
3b73			 
3b73					; TODO push value back onto stack for another op etc 
3b73			 
3b73			;		pop hl 
3b73			 
3b73			.dot_done: 
3b73 cd 13 21				call forth_push_numhl 
3b76			 
3b76					NEXTW 
3b76 c3 c0 24			jp macro_next 
3b79				endm 
# End of macro NEXTW
3b79			.NEG: 
3b79			 
3b79				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b79 17				db WORD_SYS_CORE+3             
3b7a bc 3b			dw .DIV            
3b7c 02				db 1 + 1 
3b7d .. 00			db "-",0              
3b7f				endm 
# End of macro CWHEAD
3b7f			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b7f					if DEBUG_FORTH_WORDS_KEY 
3b7f						DMARK "SUB" 
3b7f f5				push af  
3b80 3a 94 3b			ld a, (.dmark)  
3b83 32 68 fe			ld (debug_mark),a  
3b86 3a 95 3b			ld a, (.dmark+1)  
3b89 32 69 fe			ld (debug_mark+1),a  
3b8c 3a 96 3b			ld a, (.dmark+2)  
3b8f 32 6a fe			ld (debug_mark+2),a  
3b92 18 03			jr .pastdmark  
3b94 ..			.dmark: db "SUB"  
3b97 f1			.pastdmark: pop af  
3b98			endm  
# End of macro DMARK
3b98						CALLMONITOR 
3b98 cd 6c fe			call debug_vector  
3b9b				endm  
# End of macro CALLMONITOR
3b9b					endif 
3b9b			 
3b9b			 
3b9b				; TODO add floating point number detection 
3b9b					; v5 FORTH_DSP_VALUE 
3b9b					FORTH_DSP 
3b9b cd d0 22			call macro_forth_dsp 
3b9e				endm 
# End of macro FORTH_DSP
3b9e 7e					ld a,(hl)	; get type of value on TOS 
3b9f fe 02				cp DS_TYPE_INUM  
3ba1 28 03				jr z, .neg_inum 
3ba3			 
3ba3					NEXTW 
3ba3 c3 c0 24			jp macro_next 
3ba6				endm 
# End of macro NEXTW
3ba6			 
3ba6			; float maths 
3ba6			 
3ba6				if FORTH_ENABLE_FLOATMATH 
3ba6					jr .neg_done 
3ba6			 
3ba6				endif 
3ba6					 
3ba6			 
3ba6			.neg_inum: 
3ba6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ba6 cd 0a 23			call macro_dsp_valuehl 
3ba9				endm 
# End of macro FORTH_DSP_VALUEHL
3ba9			 
3ba9 e5					push hl 
3baa			 
3baa					; destroy value TOS 
3baa			 
3baa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3baa cd c2 23			call macro_forth_dsp_pop 
3bad				endm 
# End of macro FORTH_DSP_POP
3bad			 
3bad			 
3bad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bad cd 0a 23			call macro_dsp_valuehl 
3bb0				endm 
# End of macro FORTH_DSP_VALUEHL
3bb0			 
3bb0					; one value on hl get other one back 
3bb0			 
3bb0 d1					pop de 
3bb1			 
3bb1					; do the sub 
3bb1			;		ex de, hl 
3bb1			 
3bb1 ed 52				sbc hl,de 
3bb3			 
3bb3					; save it 
3bb3			 
3bb3			;		push hl	 
3bb3			 
3bb3					; 
3bb3			 
3bb3					; destroy value TOS 
3bb3			 
3bb3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb3 cd c2 23			call macro_forth_dsp_pop 
3bb6				endm 
# End of macro FORTH_DSP_POP
3bb6			 
3bb6					; TODO push value back onto stack for another op etc 
3bb6			 
3bb6			;		pop hl 
3bb6			 
3bb6 cd 13 21				call forth_push_numhl 
3bb9			.neg_done: 
3bb9			 
3bb9					NEXTW 
3bb9 c3 c0 24			jp macro_next 
3bbc				endm 
# End of macro NEXTW
3bbc			.DIV: 
3bbc				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3bbc 18				db WORD_SYS_CORE+4             
3bbd 09 3c			dw .MUL            
3bbf 02				db 1 + 1 
3bc0 .. 00			db "/",0              
3bc2				endm 
# End of macro CWHEAD
3bc2			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3bc2					if DEBUG_FORTH_WORDS_KEY 
3bc2						DMARK "DIV" 
3bc2 f5				push af  
3bc3 3a d7 3b			ld a, (.dmark)  
3bc6 32 68 fe			ld (debug_mark),a  
3bc9 3a d8 3b			ld a, (.dmark+1)  
3bcc 32 69 fe			ld (debug_mark+1),a  
3bcf 3a d9 3b			ld a, (.dmark+2)  
3bd2 32 6a fe			ld (debug_mark+2),a  
3bd5 18 03			jr .pastdmark  
3bd7 ..			.dmark: db "DIV"  
3bda f1			.pastdmark: pop af  
3bdb			endm  
# End of macro DMARK
3bdb						CALLMONITOR 
3bdb cd 6c fe			call debug_vector  
3bde				endm  
# End of macro CALLMONITOR
3bde					endif 
3bde				; TODO add floating point number detection 
3bde					; v5 FORTH_DSP_VALUE 
3bde					FORTH_DSP 
3bde cd d0 22			call macro_forth_dsp 
3be1				endm 
# End of macro FORTH_DSP
3be1 7e					ld a,(hl)	; get type of value on TOS 
3be2 fe 02				cp DS_TYPE_INUM  
3be4 28 03				jr z, .div_inum 
3be6			 
3be6				if FORTH_ENABLE_FLOATMATH 
3be6					jr .div_done 
3be6			 
3be6				endif 
3be6					NEXTW 
3be6 c3 c0 24			jp macro_next 
3be9				endm 
# End of macro NEXTW
3be9			.div_inum: 
3be9			 
3be9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be9 cd 0a 23			call macro_dsp_valuehl 
3bec				endm 
# End of macro FORTH_DSP_VALUEHL
3bec			 
3bec e5					push hl    ; to go to bc 
3bed			 
3bed					; destroy value TOS 
3bed			 
3bed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bed cd c2 23			call macro_forth_dsp_pop 
3bf0				endm 
# End of macro FORTH_DSP_POP
3bf0			 
3bf0			 
3bf0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf0 cd 0a 23			call macro_dsp_valuehl 
3bf3				endm 
# End of macro FORTH_DSP_VALUEHL
3bf3			 
3bf3					; hl to go to de 
3bf3			 
3bf3 e5					push hl 
3bf4			 
3bf4 c1					pop bc 
3bf5 d1					pop de		 
3bf6			 
3bf6			 
3bf6					if DEBUG_FORTH_MATHS 
3bf6						DMARK "DIV" 
3bf6				CALLMONITOR 
3bf6					endif 
3bf6					; one value on hl but move to a get other one back 
3bf6			 
3bf6			        
3bf6 cd 2d 0f			call Div16 
3bf9			 
3bf9			;	push af	 
3bf9 e5				push hl 
3bfa c5				push bc 
3bfb			 
3bfb					if DEBUG_FORTH_MATHS 
3bfb						DMARK "DI1" 
3bfb				CALLMONITOR 
3bfb					endif 
3bfb			 
3bfb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfb cd c2 23			call macro_forth_dsp_pop 
3bfe				endm 
# End of macro FORTH_DSP_POP
3bfe			 
3bfe			 
3bfe			 
3bfe e1					pop hl    ; result 
3bff			 
3bff cd 13 21				call forth_push_numhl 
3c02			 
3c02 e1					pop hl    ; reminder 
3c03			;		ld h,0 
3c03			;		ld l,d 
3c03			 
3c03 cd 13 21				call forth_push_numhl 
3c06			.div_done: 
3c06					NEXTW 
3c06 c3 c0 24			jp macro_next 
3c09				endm 
# End of macro NEXTW
3c09			.MUL: 
3c09				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c09 19				db WORD_SYS_CORE+5             
3c0a 4e 3c			dw .MIN            
3c0c 02				db 1 + 1 
3c0d .. 00			db "*",0              
3c0f				endm 
# End of macro CWHEAD
3c0f			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3c0f				; TODO add floating point number detection 
3c0f					if DEBUG_FORTH_WORDS_KEY 
3c0f						DMARK "MUL" 
3c0f f5				push af  
3c10 3a 24 3c			ld a, (.dmark)  
3c13 32 68 fe			ld (debug_mark),a  
3c16 3a 25 3c			ld a, (.dmark+1)  
3c19 32 69 fe			ld (debug_mark+1),a  
3c1c 3a 26 3c			ld a, (.dmark+2)  
3c1f 32 6a fe			ld (debug_mark+2),a  
3c22 18 03			jr .pastdmark  
3c24 ..			.dmark: db "MUL"  
3c27 f1			.pastdmark: pop af  
3c28			endm  
# End of macro DMARK
3c28						CALLMONITOR 
3c28 cd 6c fe			call debug_vector  
3c2b				endm  
# End of macro CALLMONITOR
3c2b					endif 
3c2b					FORTH_DSP 
3c2b cd d0 22			call macro_forth_dsp 
3c2e				endm 
# End of macro FORTH_DSP
3c2e					; v5 FORTH_DSP_VALUE 
3c2e 7e					ld a,(hl)	; get type of value on TOS 
3c2f fe 02				cp DS_TYPE_INUM  
3c31 28 03				jr z, .mul_inum 
3c33			 
3c33				if FORTH_ENABLE_FLOATMATH 
3c33					jr .mul_done 
3c33			 
3c33				endif 
3c33			 
3c33					NEXTW 
3c33 c3 c0 24			jp macro_next 
3c36				endm 
# End of macro NEXTW
3c36			.mul_inum:	 
3c36			 
3c36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c36 cd 0a 23			call macro_dsp_valuehl 
3c39				endm 
# End of macro FORTH_DSP_VALUEHL
3c39			 
3c39 e5					push hl 
3c3a			 
3c3a					; destroy value TOS 
3c3a			 
3c3a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c3a cd c2 23			call macro_forth_dsp_pop 
3c3d				endm 
# End of macro FORTH_DSP_POP
3c3d			 
3c3d			 
3c3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3d cd 0a 23			call macro_dsp_valuehl 
3c40				endm 
# End of macro FORTH_DSP_VALUEHL
3c40			 
3c40					; one value on hl but move to a get other one back 
3c40			 
3c40 7d					ld a, l 
3c41			 
3c41 d1					pop de 
3c42			 
3c42					; do the mull 
3c42			;		ex de, hl 
3c42			 
3c42 cd 53 0f				call Mult16 
3c45					; save it 
3c45			 
3c45			;		push hl	 
3c45			 
3c45					; 
3c45			 
3c45					; destroy value TOS 
3c45			 
3c45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c45 cd c2 23			call macro_forth_dsp_pop 
3c48				endm 
# End of macro FORTH_DSP_POP
3c48			 
3c48					; TODO push value back onto stack for another op etc 
3c48			 
3c48			;		pop hl 
3c48			 
3c48 cd 13 21				call forth_push_numhl 
3c4b			 
3c4b			.mul_done: 
3c4b					NEXTW 
3c4b c3 c0 24			jp macro_next 
3c4e				endm 
# End of macro NEXTW
3c4e			 
3c4e			 
3c4e			 
3c4e			 
3c4e			.MIN: 
3c4e				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c4e 49				db WORD_SYS_CORE+53             
3c4f cf 3c			dw .MAX            
3c51 04				db 3 + 1 
3c52 .. 00			db "MIN",0              
3c56				endm 
# End of macro CWHEAD
3c56			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c56					if DEBUG_FORTH_WORDS_KEY 
3c56						DMARK "MIN" 
3c56 f5				push af  
3c57 3a 6b 3c			ld a, (.dmark)  
3c5a 32 68 fe			ld (debug_mark),a  
3c5d 3a 6c 3c			ld a, (.dmark+1)  
3c60 32 69 fe			ld (debug_mark+1),a  
3c63 3a 6d 3c			ld a, (.dmark+2)  
3c66 32 6a fe			ld (debug_mark+2),a  
3c69 18 03			jr .pastdmark  
3c6b ..			.dmark: db "MIN"  
3c6e f1			.pastdmark: pop af  
3c6f			endm  
# End of macro DMARK
3c6f						CALLMONITOR 
3c6f cd 6c fe			call debug_vector  
3c72				endm  
# End of macro CALLMONITOR
3c72					endif 
3c72					; get u2 
3c72			 
3c72					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c72 cd 0a 23			call macro_dsp_valuehl 
3c75				endm 
# End of macro FORTH_DSP_VALUEHL
3c75			 
3c75 e5					push hl   ; u2 
3c76			 
3c76					; destroy value TOS 
3c76			 
3c76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c76 cd c2 23			call macro_forth_dsp_pop 
3c79				endm 
# End of macro FORTH_DSP_POP
3c79			 
3c79					; get u1 
3c79			 
3c79					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c79 cd 0a 23			call macro_dsp_valuehl 
3c7c				endm 
# End of macro FORTH_DSP_VALUEHL
3c7c			 
3c7c e5					push hl  ; u1 
3c7d			 
3c7d					; destroy value TOS 
3c7d			 
3c7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7d cd c2 23			call macro_forth_dsp_pop 
3c80				endm 
# End of macro FORTH_DSP_POP
3c80			 
3c80 b7			 or a      ;clear carry flag 
3c81 e1			  pop hl    ; u1 
3c82 d1			  pop de    ; u2 
3c83 e5				push hl   ; saved in case hl is lowest 
3c84 ed 52		  sbc hl,de 
3c86 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c88			 
3c88 e1				pop hl 
3c89					if DEBUG_FORTH_WORDS 
3c89						DMARK "MIN" 
3c89 f5				push af  
3c8a 3a 9e 3c			ld a, (.dmark)  
3c8d 32 68 fe			ld (debug_mark),a  
3c90 3a 9f 3c			ld a, (.dmark+1)  
3c93 32 69 fe			ld (debug_mark+1),a  
3c96 3a a0 3c			ld a, (.dmark+2)  
3c99 32 6a fe			ld (debug_mark+2),a  
3c9c 18 03			jr .pastdmark  
3c9e ..			.dmark: db "MIN"  
3ca1 f1			.pastdmark: pop af  
3ca2			endm  
# End of macro DMARK
3ca2						CALLMONITOR 
3ca2 cd 6c fe			call debug_vector  
3ca5				endm  
# End of macro CALLMONITOR
3ca5					endif 
3ca5 cd 13 21				call forth_push_numhl 
3ca8			 
3ca8				       NEXTW 
3ca8 c3 c0 24			jp macro_next 
3cab				endm 
# End of macro NEXTW
3cab			 
3cab			.mincont:  
3cab c1				pop bc   ; tidy up 
3cac eb				ex de , hl  
3cad					if DEBUG_FORTH_WORDS 
3cad						DMARK "MI1" 
3cad f5				push af  
3cae 3a c2 3c			ld a, (.dmark)  
3cb1 32 68 fe			ld (debug_mark),a  
3cb4 3a c3 3c			ld a, (.dmark+1)  
3cb7 32 69 fe			ld (debug_mark+1),a  
3cba 3a c4 3c			ld a, (.dmark+2)  
3cbd 32 6a fe			ld (debug_mark+2),a  
3cc0 18 03			jr .pastdmark  
3cc2 ..			.dmark: db "MI1"  
3cc5 f1			.pastdmark: pop af  
3cc6			endm  
# End of macro DMARK
3cc6						CALLMONITOR 
3cc6 cd 6c fe			call debug_vector  
3cc9				endm  
# End of macro CALLMONITOR
3cc9					endif 
3cc9 cd 13 21				call forth_push_numhl 
3ccc			 
3ccc				       NEXTW 
3ccc c3 c0 24			jp macro_next 
3ccf				endm 
# End of macro NEXTW
3ccf			.MAX: 
3ccf				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3ccf 4a				db WORD_SYS_CORE+54             
3cd0 50 3d			dw .RND16            
3cd2 04				db 3 + 1 
3cd3 .. 00			db "MAX",0              
3cd7				endm 
# End of macro CWHEAD
3cd7			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3cd7					if DEBUG_FORTH_WORDS_KEY 
3cd7						DMARK "MAX" 
3cd7 f5				push af  
3cd8 3a ec 3c			ld a, (.dmark)  
3cdb 32 68 fe			ld (debug_mark),a  
3cde 3a ed 3c			ld a, (.dmark+1)  
3ce1 32 69 fe			ld (debug_mark+1),a  
3ce4 3a ee 3c			ld a, (.dmark+2)  
3ce7 32 6a fe			ld (debug_mark+2),a  
3cea 18 03			jr .pastdmark  
3cec ..			.dmark: db "MAX"  
3cef f1			.pastdmark: pop af  
3cf0			endm  
# End of macro DMARK
3cf0						CALLMONITOR 
3cf0 cd 6c fe			call debug_vector  
3cf3				endm  
# End of macro CALLMONITOR
3cf3					endif 
3cf3					; get u2 
3cf3			 
3cf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cf3 cd 0a 23			call macro_dsp_valuehl 
3cf6				endm 
# End of macro FORTH_DSP_VALUEHL
3cf6			 
3cf6 e5					push hl   ; u2 
3cf7			 
3cf7					; destroy value TOS 
3cf7			 
3cf7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cf7 cd c2 23			call macro_forth_dsp_pop 
3cfa				endm 
# End of macro FORTH_DSP_POP
3cfa			 
3cfa					; get u1 
3cfa			 
3cfa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cfa cd 0a 23			call macro_dsp_valuehl 
3cfd				endm 
# End of macro FORTH_DSP_VALUEHL
3cfd			 
3cfd e5					push hl  ; u1 
3cfe			 
3cfe					; destroy value TOS 
3cfe			 
3cfe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cfe cd c2 23			call macro_forth_dsp_pop 
3d01				endm 
# End of macro FORTH_DSP_POP
3d01			 
3d01 b7			 or a      ;clear carry flag 
3d02 e1			  pop hl    ; u1 
3d03 d1			  pop de    ; u2 
3d04 e5				push hl   ; saved in case hl is lowest 
3d05 ed 52		  sbc hl,de 
3d07 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d09			 
3d09 e1				pop hl 
3d0a					if DEBUG_FORTH_WORDS 
3d0a						DMARK "MAX" 
3d0a f5				push af  
3d0b 3a 1f 3d			ld a, (.dmark)  
3d0e 32 68 fe			ld (debug_mark),a  
3d11 3a 20 3d			ld a, (.dmark+1)  
3d14 32 69 fe			ld (debug_mark+1),a  
3d17 3a 21 3d			ld a, (.dmark+2)  
3d1a 32 6a fe			ld (debug_mark+2),a  
3d1d 18 03			jr .pastdmark  
3d1f ..			.dmark: db "MAX"  
3d22 f1			.pastdmark: pop af  
3d23			endm  
# End of macro DMARK
3d23						CALLMONITOR 
3d23 cd 6c fe			call debug_vector  
3d26				endm  
# End of macro CALLMONITOR
3d26					endif 
3d26 cd 13 21				call forth_push_numhl 
3d29			 
3d29				       NEXTW 
3d29 c3 c0 24			jp macro_next 
3d2c				endm 
# End of macro NEXTW
3d2c			 
3d2c			.maxcont:  
3d2c c1				pop bc   ; tidy up 
3d2d eb				ex de , hl  
3d2e					if DEBUG_FORTH_WORDS 
3d2e						DMARK "MA1" 
3d2e f5				push af  
3d2f 3a 43 3d			ld a, (.dmark)  
3d32 32 68 fe			ld (debug_mark),a  
3d35 3a 44 3d			ld a, (.dmark+1)  
3d38 32 69 fe			ld (debug_mark+1),a  
3d3b 3a 45 3d			ld a, (.dmark+2)  
3d3e 32 6a fe			ld (debug_mark+2),a  
3d41 18 03			jr .pastdmark  
3d43 ..			.dmark: db "MA1"  
3d46 f1			.pastdmark: pop af  
3d47			endm  
# End of macro DMARK
3d47						CALLMONITOR 
3d47 cd 6c fe			call debug_vector  
3d4a				endm  
# End of macro CALLMONITOR
3d4a					endif 
3d4a cd 13 21				call forth_push_numhl 
3d4d				       NEXTW 
3d4d c3 c0 24			jp macro_next 
3d50				endm 
# End of macro NEXTW
3d50			 
3d50			.RND16: 
3d50				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d50 4e				db WORD_SYS_CORE+58             
3d51 7f 3d			dw .RND8            
3d53 06				db 5 + 1 
3d54 .. 00			db "RND16",0              
3d5a				endm 
# End of macro CWHEAD
3d5a			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d5a					if DEBUG_FORTH_WORDS_KEY 
3d5a						DMARK "R16" 
3d5a f5				push af  
3d5b 3a 6f 3d			ld a, (.dmark)  
3d5e 32 68 fe			ld (debug_mark),a  
3d61 3a 70 3d			ld a, (.dmark+1)  
3d64 32 69 fe			ld (debug_mark+1),a  
3d67 3a 71 3d			ld a, (.dmark+2)  
3d6a 32 6a fe			ld (debug_mark+2),a  
3d6d 18 03			jr .pastdmark  
3d6f ..			.dmark: db "R16"  
3d72 f1			.pastdmark: pop af  
3d73			endm  
# End of macro DMARK
3d73						CALLMONITOR 
3d73 cd 6c fe			call debug_vector  
3d76				endm  
# End of macro CALLMONITOR
3d76					endif 
3d76 cd f7 0e				call prng16  
3d79 cd 13 21				call forth_push_numhl 
3d7c				       NEXTW 
3d7c c3 c0 24			jp macro_next 
3d7f				endm 
# End of macro NEXTW
3d7f			.RND8: 
3d7f				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d7f 60				db WORD_SYS_CORE+76             
3d80 b4 3d			dw .RND            
3d82 05				db 4 + 1 
3d83 .. 00			db "RND8",0              
3d88				endm 
# End of macro CWHEAD
3d88			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d88					if DEBUG_FORTH_WORDS_KEY 
3d88						DMARK "RN8" 
3d88 f5				push af  
3d89 3a 9d 3d			ld a, (.dmark)  
3d8c 32 68 fe			ld (debug_mark),a  
3d8f 3a 9e 3d			ld a, (.dmark+1)  
3d92 32 69 fe			ld (debug_mark+1),a  
3d95 3a 9f 3d			ld a, (.dmark+2)  
3d98 32 6a fe			ld (debug_mark+2),a  
3d9b 18 03			jr .pastdmark  
3d9d ..			.dmark: db "RN8"  
3da0 f1			.pastdmark: pop af  
3da1			endm  
# End of macro DMARK
3da1						CALLMONITOR 
3da1 cd 6c fe			call debug_vector  
3da4				endm  
# End of macro CALLMONITOR
3da4					endif 
3da4 2a a6 fb				ld hl,(xrandc) 
3da7 23					inc hl 
3da8 cd 11 0f				call xrnd 
3dab 6f					ld l,a	 
3dac 26 00				ld h,0 
3dae cd 13 21				call forth_push_numhl 
3db1				       NEXTW 
3db1 c3 c0 24			jp macro_next 
3db4				endm 
# End of macro NEXTW
3db4			.RND: 
3db4				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3db4 60				db WORD_SYS_CORE+76             
3db5 ba 3e			dw .ENDMATHS            
3db7 04				db 3 + 1 
3db8 .. 00			db "RND",0              
3dbc				endm 
# End of macro CWHEAD
3dbc			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3dbc			 
3dbc					if DEBUG_FORTH_WORDS_KEY 
3dbc						DMARK "RND" 
3dbc f5				push af  
3dbd 3a d1 3d			ld a, (.dmark)  
3dc0 32 68 fe			ld (debug_mark),a  
3dc3 3a d2 3d			ld a, (.dmark+1)  
3dc6 32 69 fe			ld (debug_mark+1),a  
3dc9 3a d3 3d			ld a, (.dmark+2)  
3dcc 32 6a fe			ld (debug_mark+2),a  
3dcf 18 03			jr .pastdmark  
3dd1 ..			.dmark: db "RND"  
3dd4 f1			.pastdmark: pop af  
3dd5			endm  
# End of macro DMARK
3dd5						CALLMONITOR 
3dd5 cd 6c fe			call debug_vector  
3dd8				endm  
# End of macro CALLMONITOR
3dd8					endif 
3dd8					 
3dd8					FORTH_DSP_VALUEHL    ; upper range 
3dd8 cd 0a 23			call macro_dsp_valuehl 
3ddb				endm 
# End of macro FORTH_DSP_VALUEHL
3ddb			 
3ddb 22 aa fb				ld (LFSRSeed), hl	 
3dde			 
3dde					if DEBUG_FORTH_WORDS 
3dde						DMARK "RN1" 
3dde f5				push af  
3ddf 3a f3 3d			ld a, (.dmark)  
3de2 32 68 fe			ld (debug_mark),a  
3de5 3a f4 3d			ld a, (.dmark+1)  
3de8 32 69 fe			ld (debug_mark+1),a  
3deb 3a f5 3d			ld a, (.dmark+2)  
3dee 32 6a fe			ld (debug_mark+2),a  
3df1 18 03			jr .pastdmark  
3df3 ..			.dmark: db "RN1"  
3df6 f1			.pastdmark: pop af  
3df7			endm  
# End of macro DMARK
3df7						CALLMONITOR 
3df7 cd 6c fe			call debug_vector  
3dfa				endm  
# End of macro CALLMONITOR
3dfa					endif 
3dfa					FORTH_DSP_POP 
3dfa cd c2 23			call macro_forth_dsp_pop 
3dfd				endm 
# End of macro FORTH_DSP_POP
3dfd			 
3dfd					FORTH_DSP_VALUEHL    ; low range 
3dfd cd 0a 23			call macro_dsp_valuehl 
3e00				endm 
# End of macro FORTH_DSP_VALUEHL
3e00			 
3e00					if DEBUG_FORTH_WORDS 
3e00						DMARK "RN2" 
3e00 f5				push af  
3e01 3a 15 3e			ld a, (.dmark)  
3e04 32 68 fe			ld (debug_mark),a  
3e07 3a 16 3e			ld a, (.dmark+1)  
3e0a 32 69 fe			ld (debug_mark+1),a  
3e0d 3a 17 3e			ld a, (.dmark+2)  
3e10 32 6a fe			ld (debug_mark+2),a  
3e13 18 03			jr .pastdmark  
3e15 ..			.dmark: db "RN2"  
3e18 f1			.pastdmark: pop af  
3e19			endm  
# End of macro DMARK
3e19						CALLMONITOR 
3e19 cd 6c fe			call debug_vector  
3e1c				endm  
# End of macro CALLMONITOR
3e1c					endif 
3e1c 22 ac fb				ld (LFSRSeed+2), hl 
3e1f			 
3e1f					FORTH_DSP_POP 
3e1f cd c2 23			call macro_forth_dsp_pop 
3e22				endm 
# End of macro FORTH_DSP_POP
3e22			 
3e22 e5					push hl 
3e23			 
3e23 e1			.inrange:	pop hl 
3e24 cd f7 0e				call prng16  
3e27					if DEBUG_FORTH_WORDS 
3e27						DMARK "RN3" 
3e27 f5				push af  
3e28 3a 3c 3e			ld a, (.dmark)  
3e2b 32 68 fe			ld (debug_mark),a  
3e2e 3a 3d 3e			ld a, (.dmark+1)  
3e31 32 69 fe			ld (debug_mark+1),a  
3e34 3a 3e 3e			ld a, (.dmark+2)  
3e37 32 6a fe			ld (debug_mark+2),a  
3e3a 18 03			jr .pastdmark  
3e3c ..			.dmark: db "RN3"  
3e3f f1			.pastdmark: pop af  
3e40			endm  
# End of macro DMARK
3e40						CALLMONITOR 
3e40 cd 6c fe			call debug_vector  
3e43				endm  
# End of macro CALLMONITOR
3e43					endif 
3e43					 
3e43					; if the range is 8bit knock out the high byte 
3e43			 
3e43 ed 5b aa fb			ld de, (LFSRSeed)     ; check high level 
3e47			 
3e47 3e 00				ld a, 0 
3e49 ba					cp d  
3e4a 20 1e				jr nz, .hirange 
3e4c 26 00				ld h, 0   ; knock it down to 8bit 
3e4e			 
3e4e					if DEBUG_FORTH_WORDS 
3e4e						DMARK "RNk" 
3e4e f5				push af  
3e4f 3a 63 3e			ld a, (.dmark)  
3e52 32 68 fe			ld (debug_mark),a  
3e55 3a 64 3e			ld a, (.dmark+1)  
3e58 32 69 fe			ld (debug_mark+1),a  
3e5b 3a 65 3e			ld a, (.dmark+2)  
3e5e 32 6a fe			ld (debug_mark+2),a  
3e61 18 03			jr .pastdmark  
3e63 ..			.dmark: db "RNk"  
3e66 f1			.pastdmark: pop af  
3e67			endm  
# End of macro DMARK
3e67						CALLMONITOR 
3e67 cd 6c fe			call debug_vector  
3e6a				endm  
# End of macro CALLMONITOR
3e6a					endif 
3e6a			.hirange:   
3e6a e5					push hl  
3e6b b7					or a  
3e6c ed 52		                sbc hl, de 
3e6e			 
3e6e					;call cmp16 
3e6e			 
3e6e 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e70 e1					pop hl 
3e71 e5					push hl 
3e72			 
3e72					if DEBUG_FORTH_WORDS 
3e72						DMARK "RN4" 
3e72 f5				push af  
3e73 3a 87 3e			ld a, (.dmark)  
3e76 32 68 fe			ld (debug_mark),a  
3e79 3a 88 3e			ld a, (.dmark+1)  
3e7c 32 69 fe			ld (debug_mark+1),a  
3e7f 3a 89 3e			ld a, (.dmark+2)  
3e82 32 6a fe			ld (debug_mark+2),a  
3e85 18 03			jr .pastdmark  
3e87 ..			.dmark: db "RN4"  
3e8a f1			.pastdmark: pop af  
3e8b			endm  
# End of macro DMARK
3e8b						CALLMONITOR 
3e8b cd 6c fe			call debug_vector  
3e8e				endm  
# End of macro CALLMONITOR
3e8e					endif 
3e8e ed 5b ac fb			ld de, (LFSRSeed+2)   ; check low range 
3e92					;call cmp16 
3e92				 
3e92 b7					or a  
3e93 ed 52		                sbc hl, de 
3e95 38 8c				jr c, .inrange 
3e97			 
3e97 e1					pop hl 
3e98					 
3e98					if DEBUG_FORTH_WORDS 
3e98						DMARK "RNd" 
3e98 f5				push af  
3e99 3a ad 3e			ld a, (.dmark)  
3e9c 32 68 fe			ld (debug_mark),a  
3e9f 3a ae 3e			ld a, (.dmark+1)  
3ea2 32 69 fe			ld (debug_mark+1),a  
3ea5 3a af 3e			ld a, (.dmark+2)  
3ea8 32 6a fe			ld (debug_mark+2),a  
3eab 18 03			jr .pastdmark  
3ead ..			.dmark: db "RNd"  
3eb0 f1			.pastdmark: pop af  
3eb1			endm  
# End of macro DMARK
3eb1						CALLMONITOR 
3eb1 cd 6c fe			call debug_vector  
3eb4				endm  
# End of macro CALLMONITOR
3eb4					endif 
3eb4			 
3eb4			 
3eb4 cd 13 21				call forth_push_numhl 
3eb7				       NEXTW 
3eb7 c3 c0 24			jp macro_next 
3eba				endm 
# End of macro NEXTW
3eba			 
3eba			.ENDMATHS: 
3eba			 
3eba			; eof 
3eba			 
# End of file forth_words_maths.asm
3eba			include "forth_words_display.asm" 
3eba			 
3eba			; | ## Display Words 
3eba			 
3eba			.ACT: 
3eba			 
3eba				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3eba 62				db WORD_SYS_CORE+78             
3ebb 06 3f			dw .INFO            
3ebd 07				db 6 + 1 
3ebe .. 00			db "ACTIVE",0              
3ec5				endm 
# End of macro CWHEAD
3ec5			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3ec5			;  
3ec5			; | | e.g. $ff $00 do active . $01 pause loop 
3ec5			 
3ec5					if DEBUG_FORTH_WORDS_KEY 
3ec5						DMARK "ACT" 
3ec5 f5				push af  
3ec6 3a da 3e			ld a, (.dmark)  
3ec9 32 68 fe			ld (debug_mark),a  
3ecc 3a db 3e			ld a, (.dmark+1)  
3ecf 32 69 fe			ld (debug_mark+1),a  
3ed2 3a dc 3e			ld a, (.dmark+2)  
3ed5 32 6a fe			ld (debug_mark+2),a  
3ed8 18 03			jr .pastdmark  
3eda ..			.dmark: db "ACT"  
3edd f1			.pastdmark: pop af  
3ede			endm  
# End of macro DMARK
3ede						CALLMONITOR 
3ede cd 6c fe			call debug_vector  
3ee1				endm  
# End of macro CALLMONITOR
3ee1					endif 
3ee1 cd f3 0c				call active 
3ee4					if DEBUG_FORTH_WORDS 
3ee4						DMARK "ACp" 
3ee4 f5				push af  
3ee5 3a f9 3e			ld a, (.dmark)  
3ee8 32 68 fe			ld (debug_mark),a  
3eeb 3a fa 3e			ld a, (.dmark+1)  
3eee 32 69 fe			ld (debug_mark+1),a  
3ef1 3a fb 3e			ld a, (.dmark+2)  
3ef4 32 6a fe			ld (debug_mark+2),a  
3ef7 18 03			jr .pastdmark  
3ef9 ..			.dmark: db "ACp"  
3efc f1			.pastdmark: pop af  
3efd			endm  
# End of macro DMARK
3efd						CALLMONITOR 
3efd cd 6c fe			call debug_vector  
3f00				endm  
# End of macro CALLMONITOR
3f00					endif 
3f00 cd 81 21				call forth_push_str 
3f03			 
3f03					NEXTW 
3f03 c3 c0 24			jp macro_next 
3f06				endm 
# End of macro NEXTW
3f06			.INFO: 
3f06			 
3f06				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f06 62				db WORD_SYS_CORE+78             
3f07 23 3f			dw .ATP            
3f09 05				db 4 + 1 
3f0a .. 00			db "INFO",0              
3f0f				endm 
# End of macro CWHEAD
3f0f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3f0f					FORTH_DSP_VALUEHL 
3f0f cd 0a 23			call macro_dsp_valuehl 
3f12				endm 
# End of macro FORTH_DSP_VALUEHL
3f12			 
3f12					FORTH_DSP_POP 
3f12 cd c2 23			call macro_forth_dsp_pop 
3f15				endm 
# End of macro FORTH_DSP_POP
3f15			 
3f15 e5					push hl 
3f16			 
3f16					FORTH_DSP_VALUEHL 
3f16 cd 0a 23			call macro_dsp_valuehl 
3f19				endm 
# End of macro FORTH_DSP_VALUEHL
3f19			 
3f19					FORTH_DSP_POP 
3f19 cd c2 23			call macro_forth_dsp_pop 
3f1c				endm 
# End of macro FORTH_DSP_POP
3f1c			 
3f1c d1					pop de 
3f1d			 
3f1d cd 2d 0d				call info_panel 
3f20			 
3f20			 
3f20					NEXTW 
3f20 c3 c0 24			jp macro_next 
3f23				endm 
# End of macro NEXTW
3f23			.ATP: 
3f23				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f23 62				db WORD_SYS_CORE+78             
3f24 9a 3f			dw .FB            
3f26 04				db 3 + 1 
3f27 .. 00			db "AT?",0              
3f2b				endm 
# End of macro CWHEAD
3f2b			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f2b					if DEBUG_FORTH_WORDS_KEY 
3f2b						DMARK "AT?" 
3f2b f5				push af  
3f2c 3a 40 3f			ld a, (.dmark)  
3f2f 32 68 fe			ld (debug_mark),a  
3f32 3a 41 3f			ld a, (.dmark+1)  
3f35 32 69 fe			ld (debug_mark+1),a  
3f38 3a 42 3f			ld a, (.dmark+2)  
3f3b 32 6a fe			ld (debug_mark+2),a  
3f3e 18 03			jr .pastdmark  
3f40 ..			.dmark: db "AT?"  
3f43 f1			.pastdmark: pop af  
3f44			endm  
# End of macro DMARK
3f44						CALLMONITOR 
3f44 cd 6c fe			call debug_vector  
3f47				endm  
# End of macro CALLMONITOR
3f47					endif 
3f47 3a 5b fa				ld a, (f_cursor_ptr) 
3f4a			 
3f4a			if DEBUG_FORTH_WORDS 
3f4a				DMARK "AT?" 
3f4a f5				push af  
3f4b 3a 5f 3f			ld a, (.dmark)  
3f4e 32 68 fe			ld (debug_mark),a  
3f51 3a 60 3f			ld a, (.dmark+1)  
3f54 32 69 fe			ld (debug_mark+1),a  
3f57 3a 61 3f			ld a, (.dmark+2)  
3f5a 32 6a fe			ld (debug_mark+2),a  
3f5d 18 03			jr .pastdmark  
3f5f ..			.dmark: db "AT?"  
3f62 f1			.pastdmark: pop af  
3f63			endm  
# End of macro DMARK
3f63				CALLMONITOR 
3f63 cd 6c fe			call debug_vector  
3f66				endm  
# End of macro CALLMONITOR
3f66			endif	 
3f66					; count the number of rows 
3f66			 
3f66 06 00				ld b, 0 
3f68 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f69 d6 28				sub display_cols 
3f6b f2 71 3f				jp p, .atprunder 
3f6e 04					inc b 
3f6f 18 f7				jr .atpr 
3f71			.atprunder:	 
3f71			if DEBUG_FORTH_WORDS 
3f71				DMARK "A?2" 
3f71 f5				push af  
3f72 3a 86 3f			ld a, (.dmark)  
3f75 32 68 fe			ld (debug_mark),a  
3f78 3a 87 3f			ld a, (.dmark+1)  
3f7b 32 69 fe			ld (debug_mark+1),a  
3f7e 3a 88 3f			ld a, (.dmark+2)  
3f81 32 6a fe			ld (debug_mark+2),a  
3f84 18 03			jr .pastdmark  
3f86 ..			.dmark: db "A?2"  
3f89 f1			.pastdmark: pop af  
3f8a			endm  
# End of macro DMARK
3f8a				CALLMONITOR 
3f8a cd 6c fe			call debug_vector  
3f8d				endm  
# End of macro CALLMONITOR
3f8d			endif	 
3f8d 26 00				ld h, 0 
3f8f 69					ld l, c 
3f90 cd 13 21				call forth_push_numhl 
3f93 68					ld l, b  
3f94 cd 13 21				call forth_push_numhl 
3f97			 
3f97			 
3f97				NEXTW 
3f97 c3 c0 24			jp macro_next 
3f9a				endm 
# End of macro NEXTW
3f9a			 
3f9a			.FB: 
3f9a				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f9a 1b				db WORD_SYS_CORE+7             
3f9b e8 3f			dw .EMIT            
3f9d 03				db 2 + 1 
3f9e .. 00			db "FB",0              
3fa1				endm 
# End of macro CWHEAD
3fa1			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3fa1			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3fa1			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3fa1			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3fa1					if DEBUG_FORTH_WORDS_KEY 
3fa1						DMARK "FB." 
3fa1 f5				push af  
3fa2 3a b6 3f			ld a, (.dmark)  
3fa5 32 68 fe			ld (debug_mark),a  
3fa8 3a b7 3f			ld a, (.dmark+1)  
3fab 32 69 fe			ld (debug_mark+1),a  
3fae 3a b8 3f			ld a, (.dmark+2)  
3fb1 32 6a fe			ld (debug_mark+2),a  
3fb4 18 03			jr .pastdmark  
3fb6 ..			.dmark: db "FB."  
3fb9 f1			.pastdmark: pop af  
3fba			endm  
# End of macro DMARK
3fba						CALLMONITOR 
3fba cd 6c fe			call debug_vector  
3fbd				endm  
# End of macro CALLMONITOR
3fbd					endif 
3fbd			 
3fbd					FORTH_DSP_VALUEHL 
3fbd cd 0a 23			call macro_dsp_valuehl 
3fc0				endm 
# End of macro FORTH_DSP_VALUEHL
3fc0			 
3fc0 7d					ld a, l 
3fc1 fe 01				cp 1 
3fc3 20 05				jr nz, .fbn1 
3fc5 21 0d fd				ld hl, display_fb1 
3fc8 18 15				jr .fbset 
3fca fe 02		.fbn1:		cp 2 
3fcc 20 05				jr nz, .fbn2 
3fce 21 cb fb				ld hl, display_fb2 
3fd1 18 0c				jr .fbset 
3fd3 fe 03		.fbn2:		cp 3 
3fd5 20 05				jr nz, .fbn3 
3fd7 21 6c fc				ld hl, display_fb3 
3fda 18 03				jr .fbset 
3fdc			.fbn3:		 ; if invalid number select first 
3fdc 21 0d fd				ld hl, display_fb1 
3fdf 22 c9 fb		.fbset:		ld (display_fb_active), hl 
3fe2			 
3fe2					FORTH_DSP_POP 
3fe2 cd c2 23			call macro_forth_dsp_pop 
3fe5				endm 
# End of macro FORTH_DSP_POP
3fe5			 
3fe5					NEXTW 
3fe5 c3 c0 24			jp macro_next 
3fe8				endm 
# End of macro NEXTW
3fe8			 
3fe8			 
3fe8			.EMIT: 
3fe8				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3fe8 1b				db WORD_SYS_CORE+7             
3fe9 39 40			dw .DOTH            
3feb 05				db 4 + 1 
3fec .. 00			db "EMIT",0              
3ff1				endm 
# End of macro CWHEAD
3ff1			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3ff1					; get value off TOS and display it 
3ff1			 
3ff1					if DEBUG_FORTH_WORDS_KEY 
3ff1						DMARK "EMT" 
3ff1 f5				push af  
3ff2 3a 06 40			ld a, (.dmark)  
3ff5 32 68 fe			ld (debug_mark),a  
3ff8 3a 07 40			ld a, (.dmark+1)  
3ffb 32 69 fe			ld (debug_mark+1),a  
3ffe 3a 08 40			ld a, (.dmark+2)  
4001 32 6a fe			ld (debug_mark+2),a  
4004 18 03			jr .pastdmark  
4006 ..			.dmark: db "EMT"  
4009 f1			.pastdmark: pop af  
400a			endm  
# End of macro DMARK
400a						CALLMONITOR 
400a cd 6c fe			call debug_vector  
400d				endm  
# End of macro CALLMONITOR
400d					endif 
400d			 
400d					FORTH_DSP_VALUEHL 
400d cd 0a 23			call macro_dsp_valuehl 
4010				endm 
# End of macro FORTH_DSP_VALUEHL
4010			 
4010 7d					ld a,l 
4011			 
4011					; TODO write to display 
4011			 
4011 32 bc f3				ld (os_input), a 
4014 3e 00				ld a, 0 
4016 32 bd f3				ld (os_input+1), a 
4019					 
4019 3a 5b fa				ld a, (f_cursor_ptr) 
401c 11 bc f3				ld de, os_input 
401f cd af 0d				call str_at_display 
4022			 
4022			 
4022 3a 39 fa				ld a,(cli_autodisplay) 
4025 fe 00				cp 0 
4027 28 03				jr z, .enoupdate 
4029 cd bf 0d						call update_display 
402c					.enoupdate: 
402c			 
402c 3a 5b fa				ld a, (f_cursor_ptr) 
402f 3c					inc a 
4030 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
4033			 
4033			 
4033					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4033 cd c2 23			call macro_forth_dsp_pop 
4036				endm 
# End of macro FORTH_DSP_POP
4036			  
4036			 
4036					NEXTW 
4036 c3 c0 24			jp macro_next 
4039				endm 
# End of macro NEXTW
4039			.DOTH: 
4039				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
4039 1c				db WORD_SYS_CORE+8             
403a 69 40			dw .DOTF            
403c 03				db 2 + 1 
403d .. 00			db ".-",0              
4040				endm 
# End of macro CWHEAD
4040			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4040					; get value off TOS and display it 
4040					if DEBUG_FORTH_WORDS_KEY 
4040						DMARK "DTD" 
4040 f5				push af  
4041 3a 55 40			ld a, (.dmark)  
4044 32 68 fe			ld (debug_mark),a  
4047 3a 56 40			ld a, (.dmark+1)  
404a 32 69 fe			ld (debug_mark+1),a  
404d 3a 57 40			ld a, (.dmark+2)  
4050 32 6a fe			ld (debug_mark+2),a  
4053 18 03			jr .pastdmark  
4055 ..			.dmark: db "DTD"  
4058 f1			.pastdmark: pop af  
4059			endm  
# End of macro DMARK
4059						CALLMONITOR 
4059 cd 6c fe			call debug_vector  
405c				endm  
# End of macro CALLMONITOR
405c					endif 
405c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
405e 3e 00			ld a, 0 
4060 32 3a fa			ld (cli_mvdot), a 
4063 c3 c0 40			jp .dotgo 
4066				NEXTW 
4066 c3 c0 24			jp macro_next 
4069				endm 
# End of macro NEXTW
4069			.DOTF: 
4069				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4069 1c				db WORD_SYS_CORE+8             
406a 97 40			dw .DOT            
406c 03				db 2 + 1 
406d .. 00			db ".>",0              
4070				endm 
# End of macro CWHEAD
4070			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
4070					; get value off TOS and display it 
4070			        ; TODO BUG adds extra spaces 
4070			        ; TODO BUG handle numerics? 
4070					if DEBUG_FORTH_WORDS_KEY 
4070						DMARK "DTC" 
4070 f5				push af  
4071 3a 85 40			ld a, (.dmark)  
4074 32 68 fe			ld (debug_mark),a  
4077 3a 86 40			ld a, (.dmark+1)  
407a 32 69 fe			ld (debug_mark+1),a  
407d 3a 87 40			ld a, (.dmark+2)  
4080 32 6a fe			ld (debug_mark+2),a  
4083 18 03			jr .pastdmark  
4085 ..			.dmark: db "DTC"  
4088 f1			.pastdmark: pop af  
4089			endm  
# End of macro DMARK
4089						CALLMONITOR 
4089 cd 6c fe			call debug_vector  
408c				endm  
# End of macro CALLMONITOR
408c					endif 
408c 3e 01			ld a, 1 
408e 32 3a fa			ld (cli_mvdot), a 
4091 c3 c0 40			jp .dotgo 
4094				NEXTW 
4094 c3 c0 24			jp macro_next 
4097				endm 
# End of macro NEXTW
4097			 
4097			.DOT: 
4097				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4097 1c				db WORD_SYS_CORE+8             
4098 73 42			dw .CLS            
409a 02				db 1 + 1 
409b .. 00			db ".",0              
409d				endm 
# End of macro CWHEAD
409d			        ; | . ( u -- ) Display TOS | DONE 
409d					; get value off TOS and display it 
409d			 
409d					if DEBUG_FORTH_WORDS_KEY 
409d						DMARK "DOT" 
409d f5				push af  
409e 3a b2 40			ld a, (.dmark)  
40a1 32 68 fe			ld (debug_mark),a  
40a4 3a b3 40			ld a, (.dmark+1)  
40a7 32 69 fe			ld (debug_mark+1),a  
40aa 3a b4 40			ld a, (.dmark+2)  
40ad 32 6a fe			ld (debug_mark+2),a  
40b0 18 03			jr .pastdmark  
40b2 ..			.dmark: db "DOT"  
40b5 f1			.pastdmark: pop af  
40b6			endm  
# End of macro DMARK
40b6						CALLMONITOR 
40b6 cd 6c fe			call debug_vector  
40b9				endm  
# End of macro CALLMONITOR
40b9					endif 
40b9 3e 00			ld a, 0 
40bb 32 3a fa			ld (cli_mvdot), a 
40be 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
40c0				 
40c0			 
40c0			.dotgo: 
40c0			 
40c0			; move up type to on stack for parserv5 
40c0					FORTH_DSP 
40c0 cd d0 22			call macro_forth_dsp 
40c3				endm 
# End of macro FORTH_DSP
40c3				;FORTH_DSP_VALUE  
40c3			 
40c3			if DEBUG_FORTH_DOT 
40c3				DMARK "DOT" 
40c3 f5				push af  
40c4 3a d8 40			ld a, (.dmark)  
40c7 32 68 fe			ld (debug_mark),a  
40ca 3a d9 40			ld a, (.dmark+1)  
40cd 32 69 fe			ld (debug_mark+1),a  
40d0 3a da 40			ld a, (.dmark+2)  
40d3 32 6a fe			ld (debug_mark+2),a  
40d6 18 03			jr .pastdmark  
40d8 ..			.dmark: db "DOT"  
40db f1			.pastdmark: pop af  
40dc			endm  
# End of macro DMARK
40dc				CALLMONITOR 
40dc cd 6c fe			call debug_vector  
40df				endm  
# End of macro CALLMONITOR
40df			endif	 
40df			;		.print: 
40df			 
40df 7e				ld a,(hl)  ; work out what type of value is on the TOS 
40e0 23				inc hl   ; position to the actual value 
40e1 fe 01			cp DS_TYPE_STR 
40e3 20 06			jr nz, .dotnum1  
40e5			 
40e5			; display string 
40e5				FORTH_DSP_VALUE  
40e5 cd f3 22			call macro_forth_dsp_value 
40e8				endm 
# End of macro FORTH_DSP_VALUE
40e8 eb				ex de,hl 
40e9 18 49			jr .dotwrite 
40eb			 
40eb			.dotnum1: 
40eb fe 02			cp DS_TYPE_INUM 
40ed 20 44			jr nz, .dotflot 
40ef			 
40ef			 
40ef			; display number 
40ef			 
40ef			;	push hl 
40ef			;	call clear_display 
40ef			;	pop hl 
40ef			 
40ef 5e				ld e, (hl) 
40f0 23				inc hl 
40f1 56				ld d, (hl) 
40f2 21 be f1			ld hl, scratch 
40f5			if DEBUG_FORTH_DOT 
40f5				DMARK "DT1" 
40f5 f5				push af  
40f6 3a 0a 41			ld a, (.dmark)  
40f9 32 68 fe			ld (debug_mark),a  
40fc 3a 0b 41			ld a, (.dmark+1)  
40ff 32 69 fe			ld (debug_mark+1),a  
4102 3a 0c 41			ld a, (.dmark+2)  
4105 32 6a fe			ld (debug_mark+2),a  
4108 18 03			jr .pastdmark  
410a ..			.dmark: db "DT1"  
410d f1			.pastdmark: pop af  
410e			endm  
# End of macro DMARK
410e				CALLMONITOR 
410e cd 6c fe			call debug_vector  
4111				endm  
# End of macro CALLMONITOR
4111			endif	 
4111			 
4111 cd dd 13			call uitoa_16 
4114 eb				ex de,hl 
4115			 
4115			if DEBUG_FORTH_DOT 
4115				DMARK "DT2" 
4115 f5				push af  
4116 3a 2a 41			ld a, (.dmark)  
4119 32 68 fe			ld (debug_mark),a  
411c 3a 2b 41			ld a, (.dmark+1)  
411f 32 69 fe			ld (debug_mark+1),a  
4122 3a 2c 41			ld a, (.dmark+2)  
4125 32 6a fe			ld (debug_mark+2),a  
4128 18 03			jr .pastdmark  
412a ..			.dmark: db "DT2"  
412d f1			.pastdmark: pop af  
412e			endm  
# End of macro DMARK
412e				CALLMONITOR 
412e cd 6c fe			call debug_vector  
4131				endm  
# End of macro CALLMONITOR
4131			endif	 
4131			 
4131			;	ld de, os_word_scratch 
4131 18 01			jr .dotwrite 
4133			 
4133 00			.dotflot:   nop 
4134			; TODO print floating point number 
4134			 
4134			.dotwrite:		 
4134			 
4134					; if c is set then set all '-' to spaces 
4134					; need to also take into account .>  
4134			 
4134 3e 01				ld a, 1 
4136 b9					cp c 
4137 20 67				jr nz, .nodashswap 
4139			 
4139					; DE has the string to write, working with HL 
4139			 
4139 06 ff				ld b, 255 
413b d5					push de 
413c e1					pop hl 
413d			 
413d			if DEBUG_FORTH_DOT 
413d				DMARK "DT-" 
413d f5				push af  
413e 3a 52 41			ld a, (.dmark)  
4141 32 68 fe			ld (debug_mark),a  
4144 3a 53 41			ld a, (.dmark+1)  
4147 32 69 fe			ld (debug_mark+1),a  
414a 3a 54 41			ld a, (.dmark+2)  
414d 32 6a fe			ld (debug_mark+2),a  
4150 18 03			jr .pastdmark  
4152 ..			.dmark: db "DT-"  
4155 f1			.pastdmark: pop af  
4156			endm  
# End of macro DMARK
4156				CALLMONITOR 
4156 cd 6c fe			call debug_vector  
4159				endm  
# End of macro CALLMONITOR
4159			endif	 
4159 7e			.dashscan:	ld a, (hl) 
415a fe 00				cp 0 
415c 28 42				jr z, .nodashswap 
415e fe 2d				cp '-' 
4160 20 03				jr nz, .dashskip 
4162 3e 20				ld a, ' ' 
4164 77					ld (hl), a 
4165 23			.dashskip:	inc hl 
4166			if DEBUG_FORTH_DOT 
4166				DMARK "D-2" 
4166 f5				push af  
4167 3a 7b 41			ld a, (.dmark)  
416a 32 68 fe			ld (debug_mark),a  
416d 3a 7c 41			ld a, (.dmark+1)  
4170 32 69 fe			ld (debug_mark+1),a  
4173 3a 7d 41			ld a, (.dmark+2)  
4176 32 6a fe			ld (debug_mark+2),a  
4179 18 03			jr .pastdmark  
417b ..			.dmark: db "D-2"  
417e f1			.pastdmark: pop af  
417f			endm  
# End of macro DMARK
417f				CALLMONITOR 
417f cd 6c fe			call debug_vector  
4182				endm  
# End of macro CALLMONITOR
4182			endif	 
4182 10 d5				djnz .dashscan 
4184			 
4184			if DEBUG_FORTH_DOT 
4184				DMARK "D-1" 
4184 f5				push af  
4185 3a 99 41			ld a, (.dmark)  
4188 32 68 fe			ld (debug_mark),a  
418b 3a 9a 41			ld a, (.dmark+1)  
418e 32 69 fe			ld (debug_mark+1),a  
4191 3a 9b 41			ld a, (.dmark+2)  
4194 32 6a fe			ld (debug_mark+2),a  
4197 18 03			jr .pastdmark  
4199 ..			.dmark: db "D-1"  
419c f1			.pastdmark: pop af  
419d			endm  
# End of macro DMARK
419d				CALLMONITOR 
419d cd 6c fe			call debug_vector  
41a0				endm  
# End of macro CALLMONITOR
41a0			endif	 
41a0			 
41a0			.nodashswap: 
41a0			 
41a0			if DEBUG_FORTH_DOT 
41a0				DMARK "D-o" 
41a0 f5				push af  
41a1 3a b5 41			ld a, (.dmark)  
41a4 32 68 fe			ld (debug_mark),a  
41a7 3a b6 41			ld a, (.dmark+1)  
41aa 32 69 fe			ld (debug_mark+1),a  
41ad 3a b7 41			ld a, (.dmark+2)  
41b0 32 6a fe			ld (debug_mark+2),a  
41b3 18 03			jr .pastdmark  
41b5 ..			.dmark: db "D-o"  
41b8 f1			.pastdmark: pop af  
41b9			endm  
# End of macro DMARK
41b9				CALLMONITOR 
41b9 cd 6c fe			call debug_vector  
41bc				endm  
# End of macro CALLMONITOR
41bc			endif	 
41bc			 
41bc d5					push de   ; save string start in case we need to advance print 
41bd			 
41bd 3a 5b fa				ld a, (f_cursor_ptr) 
41c0 cd af 0d				call str_at_display 
41c3 3a 39 fa				ld a,(cli_autodisplay) 
41c6 fe 00				cp 0 
41c8 28 03				jr z, .noupdate 
41ca cd bf 0d						call update_display 
41cd					.noupdate: 
41cd			 
41cd			 
41cd					; see if we need to advance the print position 
41cd			 
41cd e1					pop hl   ; get back string 
41ce			;		ex de,hl 
41ce			 
41ce 3a 3a fa				ld a, (cli_mvdot) 
41d1			if DEBUG_FORTH_DOT 
41d1			;		ld e,a 
41d1				DMARK "D>1" 
41d1 f5				push af  
41d2 3a e6 41			ld a, (.dmark)  
41d5 32 68 fe			ld (debug_mark),a  
41d8 3a e7 41			ld a, (.dmark+1)  
41db 32 69 fe			ld (debug_mark+1),a  
41de 3a e8 41			ld a, (.dmark+2)  
41e1 32 6a fe			ld (debug_mark+2),a  
41e4 18 03			jr .pastdmark  
41e6 ..			.dmark: db "D>1"  
41e9 f1			.pastdmark: pop af  
41ea			endm  
# End of macro DMARK
41ea				CALLMONITOR 
41ea cd 6c fe			call debug_vector  
41ed				endm  
# End of macro CALLMONITOR
41ed			endif	 
41ed fe 00				cp 0 
41ef 28 44				jr z, .noadv 
41f1					; yes, lets advance the print position 
41f1 3e 00				ld a, 0 
41f3 cd 39 14				call strlent 
41f6			if DEBUG_FORTH_DOT 
41f6				DMARK "D-?" 
41f6 f5				push af  
41f7 3a 0b 42			ld a, (.dmark)  
41fa 32 68 fe			ld (debug_mark),a  
41fd 3a 0c 42			ld a, (.dmark+1)  
4200 32 69 fe			ld (debug_mark+1),a  
4203 3a 0d 42			ld a, (.dmark+2)  
4206 32 6a fe			ld (debug_mark+2),a  
4209 18 03			jr .pastdmark  
420b ..			.dmark: db "D-?"  
420e f1			.pastdmark: pop af  
420f			endm  
# End of macro DMARK
420f				CALLMONITOR 
420f cd 6c fe			call debug_vector  
4212				endm  
# End of macro CALLMONITOR
4212			endif	 
4212 3a 5b fa				ld a, (f_cursor_ptr) 
4215 85					add a,l 
4216					;call addatohl 
4216					;ld a, l 
4216 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
4219			 
4219			if DEBUG_FORTH_DOT 
4219				DMARK "D->" 
4219 f5				push af  
421a 3a 2e 42			ld a, (.dmark)  
421d 32 68 fe			ld (debug_mark),a  
4220 3a 2f 42			ld a, (.dmark+1)  
4223 32 69 fe			ld (debug_mark+1),a  
4226 3a 30 42			ld a, (.dmark+2)  
4229 32 6a fe			ld (debug_mark+2),a  
422c 18 03			jr .pastdmark  
422e ..			.dmark: db "D->"  
4231 f1			.pastdmark: pop af  
4232			endm  
# End of macro DMARK
4232				CALLMONITOR 
4232 cd 6c fe			call debug_vector  
4235				endm  
# End of macro CALLMONITOR
4235			endif	 
4235			 
4235			.noadv:	 
4235			 
4235					if DEBUG_FORTH_DOT_WAIT 
4235							call next_page_prompt 
4235					endif	 
4235			; TODO this pop off the stack causes a crash. i dont know why 
4235			 
4235			 
4235			if DEBUG_FORTH_DOT 
4235				DMARK "DTh" 
4235 f5				push af  
4236 3a 4a 42			ld a, (.dmark)  
4239 32 68 fe			ld (debug_mark),a  
423c 3a 4b 42			ld a, (.dmark+1)  
423f 32 69 fe			ld (debug_mark+1),a  
4242 3a 4c 42			ld a, (.dmark+2)  
4245 32 6a fe			ld (debug_mark+2),a  
4248 18 03			jr .pastdmark  
424a ..			.dmark: db "DTh"  
424d f1			.pastdmark: pop af  
424e			endm  
# End of macro DMARK
424e				CALLMONITOR 
424e cd 6c fe			call debug_vector  
4251				endm  
# End of macro CALLMONITOR
4251			endif	 
4251			 
4251					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4251 cd c2 23			call macro_forth_dsp_pop 
4254				endm 
# End of macro FORTH_DSP_POP
4254			 
4254			if DEBUG_FORTH_DOT 
4254				DMARK "DTi" 
4254 f5				push af  
4255 3a 69 42			ld a, (.dmark)  
4258 32 68 fe			ld (debug_mark),a  
425b 3a 6a 42			ld a, (.dmark+1)  
425e 32 69 fe			ld (debug_mark+1),a  
4261 3a 6b 42			ld a, (.dmark+2)  
4264 32 6a fe			ld (debug_mark+2),a  
4267 18 03			jr .pastdmark  
4269 ..			.dmark: db "DTi"  
426c f1			.pastdmark: pop af  
426d			endm  
# End of macro DMARK
426d				CALLMONITOR 
426d cd 6c fe			call debug_vector  
4270				endm  
# End of macro CALLMONITOR
4270			endif	 
4270			 
4270			 
4270					NEXTW 
4270 c3 c0 24			jp macro_next 
4273				endm 
# End of macro NEXTW
4273			 
4273			.CLS: 
4273				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4273 35				db WORD_SYS_CORE+33             
4274 a0 42			dw .DRAW            
4276 04				db 3 + 1 
4277 .. 00			db "CLS",0              
427b				endm 
# End of macro CWHEAD
427b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
427b					if DEBUG_FORTH_WORDS_KEY 
427b						DMARK "CLS" 
427b f5				push af  
427c 3a 90 42			ld a, (.dmark)  
427f 32 68 fe			ld (debug_mark),a  
4282 3a 91 42			ld a, (.dmark+1)  
4285 32 69 fe			ld (debug_mark+1),a  
4288 3a 92 42			ld a, (.dmark+2)  
428b 32 6a fe			ld (debug_mark+2),a  
428e 18 03			jr .pastdmark  
4290 ..			.dmark: db "CLS"  
4293 f1			.pastdmark: pop af  
4294			endm  
# End of macro DMARK
4294						CALLMONITOR 
4294 cd 6c fe			call debug_vector  
4297				endm  
# End of macro CALLMONITOR
4297					endif 
4297 cd 9c 0d				call clear_display 
429a c3 ae 43				jp .home		; and home cursor 
429d					NEXTW 
429d c3 c0 24			jp macro_next 
42a0				endm 
# End of macro NEXTW
42a0			 
42a0			.DRAW: 
42a0				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
42a0 36				db WORD_SYS_CORE+34             
42a1 cb 42			dw .DUMP            
42a3 05				db 4 + 1 
42a4 .. 00			db "DRAW",0              
42a9				endm 
# End of macro CWHEAD
42a9			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
42a9					if DEBUG_FORTH_WORDS_KEY 
42a9						DMARK "DRW" 
42a9 f5				push af  
42aa 3a be 42			ld a, (.dmark)  
42ad 32 68 fe			ld (debug_mark),a  
42b0 3a bf 42			ld a, (.dmark+1)  
42b3 32 69 fe			ld (debug_mark+1),a  
42b6 3a c0 42			ld a, (.dmark+2)  
42b9 32 6a fe			ld (debug_mark+2),a  
42bc 18 03			jr .pastdmark  
42be ..			.dmark: db "DRW"  
42c1 f1			.pastdmark: pop af  
42c2			endm  
# End of macro DMARK
42c2						CALLMONITOR 
42c2 cd 6c fe			call debug_vector  
42c5				endm  
# End of macro CALLMONITOR
42c5					endif 
42c5 cd bf 0d				call update_display 
42c8					NEXTW 
42c8 c3 c0 24			jp macro_next 
42cb				endm 
# End of macro NEXTW
42cb			 
42cb			.DUMP: 
42cb				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
42cb 37				db WORD_SYS_CORE+35             
42cc 03 43			dw .CDUMP            
42ce 05				db 4 + 1 
42cf .. 00			db "DUMP",0              
42d4				endm 
# End of macro CWHEAD
42d4			; | DUMP ( x -- ) With address x display dump   | DONE 
42d4			; TODO pop address to use off of the stack 
42d4					if DEBUG_FORTH_WORDS_KEY 
42d4						DMARK "DUM" 
42d4 f5				push af  
42d5 3a e9 42			ld a, (.dmark)  
42d8 32 68 fe			ld (debug_mark),a  
42db 3a ea 42			ld a, (.dmark+1)  
42de 32 69 fe			ld (debug_mark+1),a  
42e1 3a eb 42			ld a, (.dmark+2)  
42e4 32 6a fe			ld (debug_mark+2),a  
42e7 18 03			jr .pastdmark  
42e9 ..			.dmark: db "DUM"  
42ec f1			.pastdmark: pop af  
42ed			endm  
# End of macro DMARK
42ed						CALLMONITOR 
42ed cd 6c fe			call debug_vector  
42f0				endm  
# End of macro CALLMONITOR
42f0					endif 
42f0 cd 9c 0d				call clear_display 
42f3			 
42f3					; get address 
42f3			 
42f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42f3 cd 0a 23			call macro_dsp_valuehl 
42f6				endm 
# End of macro FORTH_DSP_VALUEHL
42f6				 
42f6					; save it for cdump 
42f6			 
42f6 22 e1 f4				ld (os_cur_ptr),hl 
42f9			 
42f9					; destroy value TOS 
42f9			 
42f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42f9 cd c2 23			call macro_forth_dsp_pop 
42fc				endm 
# End of macro FORTH_DSP_POP
42fc			 
42fc cd 93 1f				call dumpcont	; skip old style of param parsing	 
42ff c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4300					NEXTW 
4300 c3 c0 24			jp macro_next 
4303				endm 
# End of macro NEXTW
4303			.CDUMP: 
4303				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4303 38				db WORD_SYS_CORE+36             
4304 33 43			dw .DAT            
4306 06				db 5 + 1 
4307 .. 00			db "CDUMP",0              
430d				endm 
# End of macro CWHEAD
430d			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
430d					if DEBUG_FORTH_WORDS_KEY 
430d						DMARK "CDP" 
430d f5				push af  
430e 3a 22 43			ld a, (.dmark)  
4311 32 68 fe			ld (debug_mark),a  
4314 3a 23 43			ld a, (.dmark+1)  
4317 32 69 fe			ld (debug_mark+1),a  
431a 3a 24 43			ld a, (.dmark+2)  
431d 32 6a fe			ld (debug_mark+2),a  
4320 18 03			jr .pastdmark  
4322 ..			.dmark: db "CDP"  
4325 f1			.pastdmark: pop af  
4326			endm  
# End of macro DMARK
4326						CALLMONITOR 
4326 cd 6c fe			call debug_vector  
4329				endm  
# End of macro CALLMONITOR
4329					endif 
4329 cd 9c 0d				call clear_display 
432c cd 93 1f				call dumpcont	 
432f c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4330					NEXTW 
4330 c3 c0 24			jp macro_next 
4333				endm 
# End of macro NEXTW
4333			 
4333			 
4333			 
4333			 
4333			.DAT: 
4333				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4333 3d				db WORD_SYS_CORE+41             
4334 89 43			dw .HOME            
4336 03				db 2 + 1 
4337 .. 00			db "AT",0              
433a				endm 
# End of macro CWHEAD
433a			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
433a					if DEBUG_FORTH_WORDS_KEY 
433a						DMARK "AT." 
433a f5				push af  
433b 3a 4f 43			ld a, (.dmark)  
433e 32 68 fe			ld (debug_mark),a  
4341 3a 50 43			ld a, (.dmark+1)  
4344 32 69 fe			ld (debug_mark+1),a  
4347 3a 51 43			ld a, (.dmark+2)  
434a 32 6a fe			ld (debug_mark+2),a  
434d 18 03			jr .pastdmark  
434f ..			.dmark: db "AT."  
4352 f1			.pastdmark: pop af  
4353			endm  
# End of macro DMARK
4353						CALLMONITOR 
4353 cd 6c fe			call debug_vector  
4356				endm  
# End of macro CALLMONITOR
4356					endif 
4356					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4356 cd 0a 23			call macro_dsp_valuehl 
4359				endm 
# End of macro FORTH_DSP_VALUEHL
4359			 
4359			 
4359					; TODO save cursor row 
4359 7d					ld a,l 
435a fe 02				cp 2 
435c 20 04				jr nz, .crow3 
435e 3e 28				ld a, display_row_2 
4360 18 12				jr .ccol1 
4362 fe 03		.crow3:		cp 3 
4364 20 04				jr nz, .crow4 
4366 3e 50				ld a, display_row_3 
4368 18 0a				jr .ccol1 
436a fe 04		.crow4:		cp 4 
436c 20 04				jr nz, .crow1 
436e 3e 78				ld a, display_row_4 
4370 18 02				jr .ccol1 
4372 3e 00		.crow1:		ld a,display_row_1 
4374 f5			.ccol1:		push af			; got row offset 
4375 6f					ld l,a 
4376 26 00				ld h,0 
4378					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4378 cd c2 23			call macro_forth_dsp_pop 
437b				endm 
# End of macro FORTH_DSP_POP
437b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
437b cd 0a 23			call macro_dsp_valuehl 
437e				endm 
# End of macro FORTH_DSP_VALUEHL
437e					; TODO save cursor col 
437e f1					pop af 
437f 85					add l		; add col offset 
4380 32 5b fa				ld (f_cursor_ptr), a 
4383					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4383 cd c2 23			call macro_forth_dsp_pop 
4386				endm 
# End of macro FORTH_DSP_POP
4386			 
4386					; calculate  
4386			 
4386					NEXTW 
4386 c3 c0 24			jp macro_next 
4389				endm 
# End of macro NEXTW
4389			 
4389			 
4389			.HOME: 
4389				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4389 41				db WORD_SYS_CORE+45             
438a b6 43			dw .SPACE            
438c 05				db 4 + 1 
438d .. 00			db "HOME",0              
4392				endm 
# End of macro CWHEAD
4392			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4392					if DEBUG_FORTH_WORDS_KEY 
4392						DMARK "HOM" 
4392 f5				push af  
4393 3a a7 43			ld a, (.dmark)  
4396 32 68 fe			ld (debug_mark),a  
4399 3a a8 43			ld a, (.dmark+1)  
439c 32 69 fe			ld (debug_mark+1),a  
439f 3a a9 43			ld a, (.dmark+2)  
43a2 32 6a fe			ld (debug_mark+2),a  
43a5 18 03			jr .pastdmark  
43a7 ..			.dmark: db "HOM"  
43aa f1			.pastdmark: pop af  
43ab			endm  
# End of macro DMARK
43ab						CALLMONITOR 
43ab cd 6c fe			call debug_vector  
43ae				endm  
# End of macro CALLMONITOR
43ae					endif 
43ae 3e 00		.home:		ld a, 0		; and home cursor 
43b0 32 5b fa				ld (f_cursor_ptr), a 
43b3					NEXTW 
43b3 c3 c0 24			jp macro_next 
43b6				endm 
# End of macro NEXTW
43b6			 
43b6			 
43b6			.SPACE: 
43b6				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
43b6 46				db WORD_SYS_CORE+50             
43b7 ec 43			dw .SPACES            
43b9 03				db 2 + 1 
43ba .. 00			db "BL",0              
43bd				endm 
# End of macro CWHEAD
43bd			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
43bd					if DEBUG_FORTH_WORDS_KEY 
43bd						DMARK "BL." 
43bd f5				push af  
43be 3a d2 43			ld a, (.dmark)  
43c1 32 68 fe			ld (debug_mark),a  
43c4 3a d3 43			ld a, (.dmark+1)  
43c7 32 69 fe			ld (debug_mark+1),a  
43ca 3a d4 43			ld a, (.dmark+2)  
43cd 32 6a fe			ld (debug_mark+2),a  
43d0 18 03			jr .pastdmark  
43d2 ..			.dmark: db "BL."  
43d5 f1			.pastdmark: pop af  
43d6			endm  
# End of macro DMARK
43d6						CALLMONITOR 
43d6 cd 6c fe			call debug_vector  
43d9				endm  
# End of macro CALLMONITOR
43d9					endif 
43d9 3e 20				ld a, " " 
43db 32 be f1				ld (scratch),a 
43de 3e 00				ld a, 0 
43e0 32 bf f1				ld (scratch+1),a 
43e3 21 be f1				ld hl, scratch 
43e6 cd 81 21				call forth_push_str 
43e9					 
43e9				       NEXTW 
43e9 c3 c0 24			jp macro_next 
43ec				endm 
# End of macro NEXTW
43ec			 
43ec			;.blstr: db " ", 0 
43ec			 
43ec			.SPACES: 
43ec				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
43ec 47				db WORD_SYS_CORE+51             
43ed 87 44			dw .SCROLL            
43ef 07				db 6 + 1 
43f0 .. 00			db "SPACES",0              
43f7				endm 
# End of macro CWHEAD
43f7			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
43f7					if DEBUG_FORTH_WORDS_KEY 
43f7						DMARK "SPS" 
43f7 f5				push af  
43f8 3a 0c 44			ld a, (.dmark)  
43fb 32 68 fe			ld (debug_mark),a  
43fe 3a 0d 44			ld a, (.dmark+1)  
4401 32 69 fe			ld (debug_mark+1),a  
4404 3a 0e 44			ld a, (.dmark+2)  
4407 32 6a fe			ld (debug_mark+2),a  
440a 18 03			jr .pastdmark  
440c ..			.dmark: db "SPS"  
440f f1			.pastdmark: pop af  
4410			endm  
# End of macro DMARK
4410						CALLMONITOR 
4410 cd 6c fe			call debug_vector  
4413				endm  
# End of macro CALLMONITOR
4413					endif 
4413			 
4413			 
4413					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4413 cd 0a 23			call macro_dsp_valuehl 
4416				endm 
# End of macro FORTH_DSP_VALUEHL
4416			 
4416 e5					push hl    ; u 
4417					if DEBUG_FORTH_WORDS 
4417						DMARK "SPA" 
4417 f5				push af  
4418 3a 2c 44			ld a, (.dmark)  
441b 32 68 fe			ld (debug_mark),a  
441e 3a 2d 44			ld a, (.dmark+1)  
4421 32 69 fe			ld (debug_mark+1),a  
4424 3a 2e 44			ld a, (.dmark+2)  
4427 32 6a fe			ld (debug_mark+2),a  
442a 18 03			jr .pastdmark  
442c ..			.dmark: db "SPA"  
442f f1			.pastdmark: pop af  
4430			endm  
# End of macro DMARK
4430						CALLMONITOR 
4430 cd 6c fe			call debug_vector  
4433				endm  
# End of macro CALLMONITOR
4433					endif 
4433			 
4433					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4433 cd c2 23			call macro_forth_dsp_pop 
4436				endm 
# End of macro FORTH_DSP_POP
4436 e1					pop hl 
4437 0e 00				ld c, 0 
4439 45					ld b, l 
443a 21 be f1				ld hl, scratch  
443d			 
443d					if DEBUG_FORTH_WORDS 
443d						DMARK "SP2" 
443d f5				push af  
443e 3a 52 44			ld a, (.dmark)  
4441 32 68 fe			ld (debug_mark),a  
4444 3a 53 44			ld a, (.dmark+1)  
4447 32 69 fe			ld (debug_mark+1),a  
444a 3a 54 44			ld a, (.dmark+2)  
444d 32 6a fe			ld (debug_mark+2),a  
4450 18 03			jr .pastdmark  
4452 ..			.dmark: db "SP2"  
4455 f1			.pastdmark: pop af  
4456			endm  
# End of macro DMARK
4456						CALLMONITOR 
4456 cd 6c fe			call debug_vector  
4459				endm  
# End of macro CALLMONITOR
4459					endif 
4459 3e 20				ld a, ' ' 
445b			.spaces1:	 
445b 77					ld (hl),a 
445c 23					inc hl 
445d					 
445d 10 fc				djnz .spaces1 
445f 3e 00				ld a,0 
4461 77					ld (hl),a 
4462 21 be f1				ld hl, scratch 
4465					if DEBUG_FORTH_WORDS 
4465						DMARK "SP3" 
4465 f5				push af  
4466 3a 7a 44			ld a, (.dmark)  
4469 32 68 fe			ld (debug_mark),a  
446c 3a 7b 44			ld a, (.dmark+1)  
446f 32 69 fe			ld (debug_mark+1),a  
4472 3a 7c 44			ld a, (.dmark+2)  
4475 32 6a fe			ld (debug_mark+2),a  
4478 18 03			jr .pastdmark  
447a ..			.dmark: db "SP3"  
447d f1			.pastdmark: pop af  
447e			endm  
# End of macro DMARK
447e						CALLMONITOR 
447e cd 6c fe			call debug_vector  
4481				endm  
# End of macro CALLMONITOR
4481					endif 
4481 cd 81 21				call forth_push_str 
4484			 
4484				       NEXTW 
4484 c3 c0 24			jp macro_next 
4487				endm 
# End of macro NEXTW
4487			 
4487			 
4487			 
4487			.SCROLL: 
4487				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4487 53				db WORD_SYS_CORE+63             
4488 b4 44			dw .SCROLLD            
448a 07				db 6 + 1 
448b .. 00			db "SCROLL",0              
4492				endm 
# End of macro CWHEAD
4492			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4492					if DEBUG_FORTH_WORDS_KEY 
4492						DMARK "SCR" 
4492 f5				push af  
4493 3a a7 44			ld a, (.dmark)  
4496 32 68 fe			ld (debug_mark),a  
4499 3a a8 44			ld a, (.dmark+1)  
449c 32 69 fe			ld (debug_mark+1),a  
449f 3a a9 44			ld a, (.dmark+2)  
44a2 32 6a fe			ld (debug_mark+2),a  
44a5 18 03			jr .pastdmark  
44a7 ..			.dmark: db "SCR"  
44aa f1			.pastdmark: pop af  
44ab			endm  
# End of macro DMARK
44ab						CALLMONITOR 
44ab cd 6c fe			call debug_vector  
44ae				endm  
# End of macro CALLMONITOR
44ae					endif 
44ae			 
44ae cd 5e 0d			call scroll_up 
44b1			;	call update_display 
44b1			 
44b1					NEXTW 
44b1 c3 c0 24			jp macro_next 
44b4				endm 
# End of macro NEXTW
44b4			 
44b4			 
44b4			 
44b4			;		; get dir 
44b4			; 
44b4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b4			; 
44b4			;		push hl 
44b4			; 
44b4			;		; destroy value TOS 
44b4			; 
44b4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b4			; 
44b4			;		; get count 
44b4			; 
44b4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b4			; 
44b4			;		push hl 
44b4			; 
44b4			;		; destroy value TOS 
44b4			; 
44b4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b4			; 
44b4			;		; one value on hl get other one back 
44b4			; 
44b4			;		pop bc    ; count 
44b4			; 
44b4			;		pop de   ; dir 
44b4			; 
44b4			; 
44b4			;		ld b, c 
44b4			; 
44b4			;.scrolldir:     push bc 
44b4			;		push de 
44b4			; 
44b4			;		ld a, 0 
44b4			;		cp e 
44b4			;		jr z, .scrollup  
44b4			;		call scroll_down 
44b4			;		jr .scrollnext 
44b4			;.scrollup:	call scroll_up 
44b4			; 
44b4			;		 
44b4			;.scrollnext: 
44b4			;		pop de 
44b4			;		pop bc 
44b4			;		djnz .scrolldir 
44b4			; 
44b4			; 
44b4			; 
44b4			; 
44b4			; 
44b4			;		NEXTW 
44b4			 
44b4			.SCROLLD: 
44b4				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
44b4 53				db WORD_SYS_CORE+63             
44b5 e2 44			dw .ATQ            
44b7 08				db 7 + 1 
44b8 .. 00			db "SCROLLD",0              
44c0				endm 
# End of macro CWHEAD
44c0			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
44c0					if DEBUG_FORTH_WORDS_KEY 
44c0						DMARK "SCD" 
44c0 f5				push af  
44c1 3a d5 44			ld a, (.dmark)  
44c4 32 68 fe			ld (debug_mark),a  
44c7 3a d6 44			ld a, (.dmark+1)  
44ca 32 69 fe			ld (debug_mark+1),a  
44cd 3a d7 44			ld a, (.dmark+2)  
44d0 32 6a fe			ld (debug_mark+2),a  
44d3 18 03			jr .pastdmark  
44d5 ..			.dmark: db "SCD"  
44d8 f1			.pastdmark: pop af  
44d9			endm  
# End of macro DMARK
44d9						CALLMONITOR 
44d9 cd 6c fe			call debug_vector  
44dc				endm  
# End of macro CALLMONITOR
44dc					endif 
44dc			 
44dc cd 82 0d			call scroll_down 
44df			;	call update_display 
44df			 
44df					NEXTW 
44df c3 c0 24			jp macro_next 
44e2				endm 
# End of macro NEXTW
44e2			 
44e2			 
44e2			.ATQ: 
44e2				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
44e2 62				db WORD_SYS_CORE+78             
44e3 40 45			dw .AUTODSP            
44e5 04				db 3 + 1 
44e6 .. 00			db "AT@",0              
44ea				endm 
# End of macro CWHEAD
44ea			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
44ea					if DEBUG_FORTH_WORDS_KEY 
44ea						DMARK "ATA" 
44ea f5				push af  
44eb 3a ff 44			ld a, (.dmark)  
44ee 32 68 fe			ld (debug_mark),a  
44f1 3a 00 45			ld a, (.dmark+1)  
44f4 32 69 fe			ld (debug_mark+1),a  
44f7 3a 01 45			ld a, (.dmark+2)  
44fa 32 6a fe			ld (debug_mark+2),a  
44fd 18 03			jr .pastdmark  
44ff ..			.dmark: db "ATA"  
4502 f1			.pastdmark: pop af  
4503			endm  
# End of macro DMARK
4503						CALLMONITOR 
4503 cd 6c fe			call debug_vector  
4506				endm  
# End of macro CALLMONITOR
4506					endif 
4506			 
4506			 
4506					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4506 cd 0a 23			call macro_dsp_valuehl 
4509				endm 
# End of macro FORTH_DSP_VALUEHL
4509			 
4509					; TODO save cursor row 
4509 7d					ld a,l 
450a fe 02				cp 2 
450c 20 04				jr nz, .crow3aq 
450e 3e 28				ld a, display_row_2 
4510 18 12				jr .ccol1aq 
4512 fe 03		.crow3aq:		cp 3 
4514 20 04				jr nz, .crow4aq 
4516 3e 50				ld a, display_row_3 
4518 18 0a				jr .ccol1aq 
451a fe 04		.crow4aq:		cp 4 
451c 20 04				jr nz, .crow1aq 
451e 3e 78				ld a, display_row_4 
4520 18 02				jr .ccol1aq 
4522 3e 00		.crow1aq:		ld a,display_row_1 
4524 f5			.ccol1aq:		push af			; got row offset 
4525 6f					ld l,a 
4526 26 00				ld h,0 
4528					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4528 cd c2 23			call macro_forth_dsp_pop 
452b				endm 
# End of macro FORTH_DSP_POP
452b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
452b cd 0a 23			call macro_dsp_valuehl 
452e				endm 
# End of macro FORTH_DSP_VALUEHL
452e					; TODO save cursor col 
452e f1					pop af 
452f 85					add l		; add col offset 
4530			 
4530					; add current frame buffer address 
4530 2a c9 fb				ld hl, (display_fb_active) 
4533 cd d0 0f				call addatohl 
4536			 
4536			 
4536			 
4536			 
4536					; get char frame buffer location offset in hl 
4536			 
4536 7e					ld a,(hl) 
4537 26 00				ld h, 0 
4539 6f					ld l, a 
453a			 
453a cd 13 21				call forth_push_numhl 
453d			 
453d			 
453d					NEXTW 
453d c3 c0 24			jp macro_next 
4540				endm 
# End of macro NEXTW
4540			 
4540			.AUTODSP: 
4540				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4540 63				db WORD_SYS_CORE+79             
4541 56 45			dw .MENU            
4543 05				db 4 + 1 
4544 .. 00			db "ADSP",0              
4549				endm 
# End of macro CWHEAD
4549			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4549			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4549			 
4549					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4549 cd 0a 23			call macro_dsp_valuehl 
454c				endm 
# End of macro FORTH_DSP_VALUEHL
454c			 
454c			;		push hl 
454c			 
454c					; destroy value TOS 
454c			 
454c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
454c cd c2 23			call macro_forth_dsp_pop 
454f				endm 
# End of macro FORTH_DSP_POP
454f			 
454f			;		pop hl 
454f			 
454f 7d					ld a,l 
4550 32 39 fa				ld (cli_autodisplay), a 
4553				       NEXTW 
4553 c3 c0 24			jp macro_next 
4556				endm 
# End of macro NEXTW
4556			 
4556			.MENU: 
4556				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4556 70				db WORD_SYS_CORE+92             
4557 ff 45			dw .ENDDISPLAY            
4559 05				db 4 + 1 
455a .. 00			db "MENU",0              
455f				endm 
# End of macro CWHEAD
455f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
455f			 
455f			;		; get number of items on the stack 
455f			; 
455f				 
455f					FORTH_DSP_VALUEHL 
455f cd 0a 23			call macro_dsp_valuehl 
4562				endm 
# End of macro FORTH_DSP_VALUEHL
4562				 
4562					if DEBUG_FORTH_WORDS_KEY 
4562						DMARK "MNU" 
4562 f5				push af  
4563 3a 77 45			ld a, (.dmark)  
4566 32 68 fe			ld (debug_mark),a  
4569 3a 78 45			ld a, (.dmark+1)  
456c 32 69 fe			ld (debug_mark+1),a  
456f 3a 79 45			ld a, (.dmark+2)  
4572 32 6a fe			ld (debug_mark+2),a  
4575 18 03			jr .pastdmark  
4577 ..			.dmark: db "MNU"  
457a f1			.pastdmark: pop af  
457b			endm  
# End of macro DMARK
457b						CALLMONITOR 
457b cd 6c fe			call debug_vector  
457e				endm  
# End of macro CALLMONITOR
457e					endif 
457e			 
457e 45					ld b, l	 
457f 05					dec b 
4580			 
4580					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4580 cd c2 23			call macro_forth_dsp_pop 
4583				endm 
# End of macro FORTH_DSP_POP
4583			 
4583			 
4583					; go directly through the stack to pluck out the string pointers and build an array 
4583			 
4583			;		FORTH_DSP 
4583			 
4583					; hl contains top most stack item 
4583				 
4583 11 be f1				ld de, scratch 
4586			 
4586			.mbuild: 
4586			 
4586					FORTH_DSP_VALUEHL 
4586 cd 0a 23			call macro_dsp_valuehl 
4589				endm 
# End of macro FORTH_DSP_VALUEHL
4589			 
4589					if DEBUG_FORTH_WORDS 
4589						DMARK "MN3" 
4589 f5				push af  
458a 3a 9e 45			ld a, (.dmark)  
458d 32 68 fe			ld (debug_mark),a  
4590 3a 9f 45			ld a, (.dmark+1)  
4593 32 69 fe			ld (debug_mark+1),a  
4596 3a a0 45			ld a, (.dmark+2)  
4599 32 6a fe			ld (debug_mark+2),a  
459c 18 03			jr .pastdmark  
459e ..			.dmark: db "MN3"  
45a1 f1			.pastdmark: pop af  
45a2			endm  
# End of macro DMARK
45a2						CALLMONITOR 
45a2 cd 6c fe			call debug_vector  
45a5				endm  
# End of macro CALLMONITOR
45a5					endif 
45a5 eb					ex de, hl 
45a6 73					ld (hl), e 
45a7 23					inc hl 
45a8 72					ld (hl), d 
45a9 23					inc hl 
45aa eb					ex de, hl 
45ab			 
45ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45ab cd c2 23			call macro_forth_dsp_pop 
45ae				endm 
# End of macro FORTH_DSP_POP
45ae			 
45ae 10 d6				djnz .mbuild 
45b0			 
45b0					; done add term 
45b0			 
45b0 eb					ex de, hl 
45b1 36 00				ld (hl), 0 
45b3 23					inc hl 
45b4 36 00				ld (hl), 0 
45b6			 
45b6				 
45b6					 
45b6 21 be f1				ld hl, scratch 
45b9			 
45b9					if DEBUG_FORTH_WORDS 
45b9						DMARK "MNx" 
45b9 f5				push af  
45ba 3a ce 45			ld a, (.dmark)  
45bd 32 68 fe			ld (debug_mark),a  
45c0 3a cf 45			ld a, (.dmark+1)  
45c3 32 69 fe			ld (debug_mark+1),a  
45c6 3a d0 45			ld a, (.dmark+2)  
45c9 32 6a fe			ld (debug_mark+2),a  
45cc 18 03			jr .pastdmark  
45ce ..			.dmark: db "MNx"  
45d1 f1			.pastdmark: pop af  
45d2			endm  
# End of macro DMARK
45d2						CALLMONITOR 
45d2 cd 6c fe			call debug_vector  
45d5				endm  
# End of macro CALLMONITOR
45d5					endif 
45d5			 
45d5			 
45d5			 
45d5 3e 00				ld a, 0 
45d7 cd cd 0d				call menu 
45da			 
45da			 
45da 6f					ld l, a 
45db 26 00				ld h, 0 
45dd			 
45dd					if DEBUG_FORTH_WORDS 
45dd						DMARK "MNr" 
45dd f5				push af  
45de 3a f2 45			ld a, (.dmark)  
45e1 32 68 fe			ld (debug_mark),a  
45e4 3a f3 45			ld a, (.dmark+1)  
45e7 32 69 fe			ld (debug_mark+1),a  
45ea 3a f4 45			ld a, (.dmark+2)  
45ed 32 6a fe			ld (debug_mark+2),a  
45f0 18 03			jr .pastdmark  
45f2 ..			.dmark: db "MNr"  
45f5 f1			.pastdmark: pop af  
45f6			endm  
# End of macro DMARK
45f6						CALLMONITOR 
45f6 cd 6c fe			call debug_vector  
45f9				endm  
# End of macro CALLMONITOR
45f9					endif 
45f9			 
45f9 cd 13 21				call forth_push_numhl 
45fc			 
45fc			 
45fc			 
45fc			 
45fc				       NEXTW 
45fc c3 c0 24			jp macro_next 
45ff				endm 
# End of macro NEXTW
45ff			 
45ff			 
45ff			.ENDDISPLAY: 
45ff			 
45ff			; eof 
# End of file forth_words_display.asm
45ff			include "forth_words_str.asm" 
45ff			 
45ff			; | ## String Words 
45ff			 
45ff			.PTR:   
45ff			 
45ff				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
45ff 48				db WORD_SYS_CORE+52             
4600 2c 46			dw .STYPE            
4602 04				db 3 + 1 
4603 .. 00			db "PTR",0              
4607				endm 
# End of macro CWHEAD
4607			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4607			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4607			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4607			 
4607					if DEBUG_FORTH_WORDS_KEY 
4607						DMARK "PTR" 
4607 f5				push af  
4608 3a 1c 46			ld a, (.dmark)  
460b 32 68 fe			ld (debug_mark),a  
460e 3a 1d 46			ld a, (.dmark+1)  
4611 32 69 fe			ld (debug_mark+1),a  
4614 3a 1e 46			ld a, (.dmark+2)  
4617 32 6a fe			ld (debug_mark+2),a  
461a 18 03			jr .pastdmark  
461c ..			.dmark: db "PTR"  
461f f1			.pastdmark: pop af  
4620			endm  
# End of macro DMARK
4620						CALLMONITOR 
4620 cd 6c fe			call debug_vector  
4623				endm  
# End of macro CALLMONITOR
4623					endif 
4623					FORTH_DSP_VALUEHL 
4623 cd 0a 23			call macro_dsp_valuehl 
4626				endm 
# End of macro FORTH_DSP_VALUEHL
4626 cd 13 21				call forth_push_numhl 
4629			 
4629			 
4629					NEXTW 
4629 c3 c0 24			jp macro_next 
462c				endm 
# End of macro NEXTW
462c			.STYPE: 
462c				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
462c 48				db WORD_SYS_CORE+52             
462d 7b 46			dw .UPPER            
462f 06				db 5 + 1 
4630 .. 00			db "STYPE",0              
4636				endm 
# End of macro CWHEAD
4636			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4636					if DEBUG_FORTH_WORDS_KEY 
4636						DMARK "STY" 
4636 f5				push af  
4637 3a 4b 46			ld a, (.dmark)  
463a 32 68 fe			ld (debug_mark),a  
463d 3a 4c 46			ld a, (.dmark+1)  
4640 32 69 fe			ld (debug_mark+1),a  
4643 3a 4d 46			ld a, (.dmark+2)  
4646 32 6a fe			ld (debug_mark+2),a  
4649 18 03			jr .pastdmark  
464b ..			.dmark: db "STY"  
464e f1			.pastdmark: pop af  
464f			endm  
# End of macro DMARK
464f						CALLMONITOR 
464f cd 6c fe			call debug_vector  
4652				endm  
# End of macro CALLMONITOR
4652					endif 
4652					FORTH_DSP 
4652 cd d0 22			call macro_forth_dsp 
4655				endm 
# End of macro FORTH_DSP
4655					;v5 FORTH_DSP_VALUE 
4655			 
4655 7e					ld a, (hl) 
4656			 
4656 f5					push af 
4657			 
4657			; Dont destroy TOS		FORTH_DSP_POP 
4657			 
4657 f1					pop af 
4658			 
4658 fe 01				cp DS_TYPE_STR 
465a 28 09				jr z, .typestr 
465c			 
465c fe 02				cp DS_TYPE_INUM 
465e 28 0a				jr z, .typeinum 
4660			 
4660 21 79 46				ld hl, .tna 
4663 18 0a				jr .tpush 
4665			 
4665 21 75 46		.typestr:	ld hl, .tstr 
4668 18 05				jr .tpush 
466a 21 77 46		.typeinum:	ld hl, .tinum 
466d 18 00				jr .tpush 
466f			 
466f			.tpush: 
466f			 
466f cd 81 21				call forth_push_str 
4672			 
4672					NEXTW 
4672 c3 c0 24			jp macro_next 
4675				endm 
# End of macro NEXTW
4675 .. 00		.tstr:	db "s",0 
4677 .. 00		.tinum:  db "i",0 
4679 .. 00		.tna:   db "?", 0 
467b			 
467b			 
467b			.UPPER: 
467b				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
467b 48				db WORD_SYS_CORE+52             
467c b6 46			dw .LOWER            
467e 06				db 5 + 1 
467f .. 00			db "UPPER",0              
4685				endm 
# End of macro CWHEAD
4685			; | UPPER ( s -- s ) Upper case string s  | DONE 
4685					if DEBUG_FORTH_WORDS_KEY 
4685						DMARK "UPR" 
4685 f5				push af  
4686 3a 9a 46			ld a, (.dmark)  
4689 32 68 fe			ld (debug_mark),a  
468c 3a 9b 46			ld a, (.dmark+1)  
468f 32 69 fe			ld (debug_mark+1),a  
4692 3a 9c 46			ld a, (.dmark+2)  
4695 32 6a fe			ld (debug_mark+2),a  
4698 18 03			jr .pastdmark  
469a ..			.dmark: db "UPR"  
469d f1			.pastdmark: pop af  
469e			endm  
# End of macro DMARK
469e						CALLMONITOR 
469e cd 6c fe			call debug_vector  
46a1				endm  
# End of macro CALLMONITOR
46a1					endif 
46a1			 
46a1					FORTH_DSP 
46a1 cd d0 22			call macro_forth_dsp 
46a4				endm 
# End of macro FORTH_DSP
46a4					 
46a4			; TODO check is string type 
46a4			 
46a4					FORTH_DSP_VALUEHL 
46a4 cd 0a 23			call macro_dsp_valuehl 
46a7				endm 
# End of macro FORTH_DSP_VALUEHL
46a7			; get pointer to string in hl 
46a7			 
46a7 7e			.toup:		ld a, (hl) 
46a8 fe 00				cp 0 
46aa 28 07				jr z, .toupdone 
46ac			 
46ac cd 3d 13				call to_upper 
46af			 
46af 77					ld (hl), a 
46b0 23					inc hl 
46b1 18 f4				jr .toup 
46b3			 
46b3					 
46b3			 
46b3			 
46b3			; for each char convert to upper 
46b3					 
46b3			.toupdone: 
46b3			 
46b3			 
46b3					NEXTW 
46b3 c3 c0 24			jp macro_next 
46b6				endm 
# End of macro NEXTW
46b6			.LOWER: 
46b6				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
46b6 48				db WORD_SYS_CORE+52             
46b7 f1 46			dw .TCASE            
46b9 06				db 5 + 1 
46ba .. 00			db "LOWER",0              
46c0				endm 
# End of macro CWHEAD
46c0			; | LOWER ( s -- s ) Lower case string s  | DONE 
46c0					if DEBUG_FORTH_WORDS_KEY 
46c0						DMARK "LWR" 
46c0 f5				push af  
46c1 3a d5 46			ld a, (.dmark)  
46c4 32 68 fe			ld (debug_mark),a  
46c7 3a d6 46			ld a, (.dmark+1)  
46ca 32 69 fe			ld (debug_mark+1),a  
46cd 3a d7 46			ld a, (.dmark+2)  
46d0 32 6a fe			ld (debug_mark+2),a  
46d3 18 03			jr .pastdmark  
46d5 ..			.dmark: db "LWR"  
46d8 f1			.pastdmark: pop af  
46d9			endm  
# End of macro DMARK
46d9						CALLMONITOR 
46d9 cd 6c fe			call debug_vector  
46dc				endm  
# End of macro CALLMONITOR
46dc					endif 
46dc			 
46dc					FORTH_DSP 
46dc cd d0 22			call macro_forth_dsp 
46df				endm 
# End of macro FORTH_DSP
46df					 
46df			; TODO check is string type 
46df			 
46df					FORTH_DSP_VALUEHL 
46df cd 0a 23			call macro_dsp_valuehl 
46e2				endm 
# End of macro FORTH_DSP_VALUEHL
46e2			; get pointer to string in hl 
46e2			 
46e2 7e			.tolow:		ld a, (hl) 
46e3 fe 00				cp 0 
46e5 28 07				jr z, .tolowdone 
46e7			 
46e7 cd 46 13				call to_lower 
46ea			 
46ea 77					ld (hl), a 
46eb 23					inc hl 
46ec 18 f4				jr .tolow 
46ee			 
46ee					 
46ee			 
46ee			 
46ee			; for each char convert to low 
46ee					 
46ee			.tolowdone: 
46ee					NEXTW 
46ee c3 c0 24			jp macro_next 
46f1				endm 
# End of macro NEXTW
46f1			.TCASE: 
46f1				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
46f1 48				db WORD_SYS_CORE+52             
46f2 27 48			dw .SUBSTR            
46f4 06				db 5 + 1 
46f5 .. 00			db "TCASE",0              
46fb				endm 
# End of macro CWHEAD
46fb			; | TCASE ( s -- s ) Title case string s  | DONE 
46fb					if DEBUG_FORTH_WORDS_KEY 
46fb						DMARK "TCS" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 68 fe			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 69 fe			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 6a fe			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "TCS"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd 6c fe			call debug_vector  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717			 
4717					FORTH_DSP 
4717 cd d0 22			call macro_forth_dsp 
471a				endm 
# End of macro FORTH_DSP
471a					 
471a			; TODO check is string type 
471a			 
471a					FORTH_DSP_VALUEHL 
471a cd 0a 23			call macro_dsp_valuehl 
471d				endm 
# End of macro FORTH_DSP_VALUEHL
471d			; get pointer to string in hl 
471d			 
471d					if DEBUG_FORTH_WORDS 
471d						DMARK "TC1" 
471d f5				push af  
471e 3a 32 47			ld a, (.dmark)  
4721 32 68 fe			ld (debug_mark),a  
4724 3a 33 47			ld a, (.dmark+1)  
4727 32 69 fe			ld (debug_mark+1),a  
472a 3a 34 47			ld a, (.dmark+2)  
472d 32 6a fe			ld (debug_mark+2),a  
4730 18 03			jr .pastdmark  
4732 ..			.dmark: db "TC1"  
4735 f1			.pastdmark: pop af  
4736			endm  
# End of macro DMARK
4736						CALLMONITOR 
4736 cd 6c fe			call debug_vector  
4739				endm  
# End of macro CALLMONITOR
4739					endif 
4739			 
4739					; first time in turn to upper case first char 
4739			 
4739 7e					ld a, (hl) 
473a c3 c4 47				jp .totsiptou 
473d			 
473d			 
473d 7e			.tot:		ld a, (hl) 
473e fe 00				cp 0 
4740 ca 08 48				jp z, .totdone 
4743			 
4743					if DEBUG_FORTH_WORDS 
4743						DMARK "TC2" 
4743 f5				push af  
4744 3a 58 47			ld a, (.dmark)  
4747 32 68 fe			ld (debug_mark),a  
474a 3a 59 47			ld a, (.dmark+1)  
474d 32 69 fe			ld (debug_mark+1),a  
4750 3a 5a 47			ld a, (.dmark+2)  
4753 32 6a fe			ld (debug_mark+2),a  
4756 18 03			jr .pastdmark  
4758 ..			.dmark: db "TC2"  
475b f1			.pastdmark: pop af  
475c			endm  
# End of macro DMARK
475c						CALLMONITOR 
475c cd 6c fe			call debug_vector  
475f				endm  
# End of macro CALLMONITOR
475f					endif 
475f					; check to see if current char is a space 
475f			 
475f fe 20				cp ' ' 
4761 28 21				jr z, .totsp 
4763 cd 46 13				call to_lower 
4766					if DEBUG_FORTH_WORDS 
4766						DMARK "TC3" 
4766 f5				push af  
4767 3a 7b 47			ld a, (.dmark)  
476a 32 68 fe			ld (debug_mark),a  
476d 3a 7c 47			ld a, (.dmark+1)  
4770 32 69 fe			ld (debug_mark+1),a  
4773 3a 7d 47			ld a, (.dmark+2)  
4776 32 6a fe			ld (debug_mark+2),a  
4779 18 03			jr .pastdmark  
477b ..			.dmark: db "TC3"  
477e f1			.pastdmark: pop af  
477f			endm  
# End of macro DMARK
477f						CALLMONITOR 
477f cd 6c fe			call debug_vector  
4782				endm  
# End of macro CALLMONITOR
4782					endif 
4782 18 63				jr .totnxt 
4784			 
4784			.totsp:         ; on a space, find next char which should be upper 
4784			 
4784					if DEBUG_FORTH_WORDS 
4784						DMARK "TC4" 
4784 f5				push af  
4785 3a 99 47			ld a, (.dmark)  
4788 32 68 fe			ld (debug_mark),a  
478b 3a 9a 47			ld a, (.dmark+1)  
478e 32 69 fe			ld (debug_mark+1),a  
4791 3a 9b 47			ld a, (.dmark+2)  
4794 32 6a fe			ld (debug_mark+2),a  
4797 18 03			jr .pastdmark  
4799 ..			.dmark: db "TC4"  
479c f1			.pastdmark: pop af  
479d			endm  
# End of macro DMARK
479d						CALLMONITOR 
479d cd 6c fe			call debug_vector  
47a0				endm  
# End of macro CALLMONITOR
47a0					endif 
47a0					;; 
47a0			 
47a0 fe 20				cp ' ' 
47a2 20 20				jr nz, .totsiptou 
47a4 23					inc hl 
47a5 7e					ld a, (hl) 
47a6					if DEBUG_FORTH_WORDS 
47a6						DMARK "TC5" 
47a6 f5				push af  
47a7 3a bb 47			ld a, (.dmark)  
47aa 32 68 fe			ld (debug_mark),a  
47ad 3a bc 47			ld a, (.dmark+1)  
47b0 32 69 fe			ld (debug_mark+1),a  
47b3 3a bd 47			ld a, (.dmark+2)  
47b6 32 6a fe			ld (debug_mark+2),a  
47b9 18 03			jr .pastdmark  
47bb ..			.dmark: db "TC5"  
47be f1			.pastdmark: pop af  
47bf			endm  
# End of macro DMARK
47bf						CALLMONITOR 
47bf cd 6c fe			call debug_vector  
47c2				endm  
# End of macro CALLMONITOR
47c2					endif 
47c2 18 c0				jr .totsp 
47c4 fe 00		.totsiptou:    cp 0 
47c6 28 40				jr z, .totdone 
47c8					; not space and not zero term so upper case it 
47c8 cd 3d 13				call to_upper 
47cb			 
47cb					if DEBUG_FORTH_WORDS 
47cb						DMARK "TC6" 
47cb f5				push af  
47cc 3a e0 47			ld a, (.dmark)  
47cf 32 68 fe			ld (debug_mark),a  
47d2 3a e1 47			ld a, (.dmark+1)  
47d5 32 69 fe			ld (debug_mark+1),a  
47d8 3a e2 47			ld a, (.dmark+2)  
47db 32 6a fe			ld (debug_mark+2),a  
47de 18 03			jr .pastdmark  
47e0 ..			.dmark: db "TC6"  
47e3 f1			.pastdmark: pop af  
47e4			endm  
# End of macro DMARK
47e4						CALLMONITOR 
47e4 cd 6c fe			call debug_vector  
47e7				endm  
# End of macro CALLMONITOR
47e7					endif 
47e7			 
47e7			 
47e7			.totnxt: 
47e7			 
47e7 77					ld (hl), a 
47e8 23					inc hl 
47e9					if DEBUG_FORTH_WORDS 
47e9						DMARK "TC7" 
47e9 f5				push af  
47ea 3a fe 47			ld a, (.dmark)  
47ed 32 68 fe			ld (debug_mark),a  
47f0 3a ff 47			ld a, (.dmark+1)  
47f3 32 69 fe			ld (debug_mark+1),a  
47f6 3a 00 48			ld a, (.dmark+2)  
47f9 32 6a fe			ld (debug_mark+2),a  
47fc 18 03			jr .pastdmark  
47fe ..			.dmark: db "TC7"  
4801 f1			.pastdmark: pop af  
4802			endm  
# End of macro DMARK
4802						CALLMONITOR 
4802 cd 6c fe			call debug_vector  
4805				endm  
# End of macro CALLMONITOR
4805					endif 
4805 c3 3d 47				jp .tot 
4808			 
4808					 
4808			 
4808			 
4808			; for each char convert to low 
4808					 
4808			.totdone: 
4808					if DEBUG_FORTH_WORDS 
4808						DMARK "TCd" 
4808 f5				push af  
4809 3a 1d 48			ld a, (.dmark)  
480c 32 68 fe			ld (debug_mark),a  
480f 3a 1e 48			ld a, (.dmark+1)  
4812 32 69 fe			ld (debug_mark+1),a  
4815 3a 1f 48			ld a, (.dmark+2)  
4818 32 6a fe			ld (debug_mark+2),a  
481b 18 03			jr .pastdmark  
481d ..			.dmark: db "TCd"  
4820 f1			.pastdmark: pop af  
4821			endm  
# End of macro DMARK
4821						CALLMONITOR 
4821 cd 6c fe			call debug_vector  
4824				endm  
# End of macro CALLMONITOR
4824					endif 
4824					NEXTW 
4824 c3 c0 24			jp macro_next 
4827				endm 
# End of macro NEXTW
4827			 
4827			.SUBSTR: 
4827				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4827 48				db WORD_SYS_CORE+52             
4828 85 48			dw .LEFT            
482a 07				db 6 + 1 
482b .. 00			db "SUBSTR",0              
4832				endm 
# End of macro CWHEAD
4832			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4832			 
4832					if DEBUG_FORTH_WORDS_KEY 
4832						DMARK "SST" 
4832 f5				push af  
4833 3a 47 48			ld a, (.dmark)  
4836 32 68 fe			ld (debug_mark),a  
4839 3a 48 48			ld a, (.dmark+1)  
483c 32 69 fe			ld (debug_mark+1),a  
483f 3a 49 48			ld a, (.dmark+2)  
4842 32 6a fe			ld (debug_mark+2),a  
4845 18 03			jr .pastdmark  
4847 ..			.dmark: db "SST"  
484a f1			.pastdmark: pop af  
484b			endm  
# End of macro DMARK
484b						CALLMONITOR 
484b cd 6c fe			call debug_vector  
484e				endm  
# End of macro CALLMONITOR
484e					endif 
484e			; TODO check string type 
484e					FORTH_DSP_VALUEHL 
484e cd 0a 23			call macro_dsp_valuehl 
4851				endm 
# End of macro FORTH_DSP_VALUEHL
4851			 
4851 e5					push hl      ; string length 
4852			 
4852					FORTH_DSP_POP 
4852 cd c2 23			call macro_forth_dsp_pop 
4855				endm 
# End of macro FORTH_DSP_POP
4855			 
4855					FORTH_DSP_VALUEHL 
4855 cd 0a 23			call macro_dsp_valuehl 
4858				endm 
# End of macro FORTH_DSP_VALUEHL
4858			 
4858 e5					push hl     ; start char 
4859			 
4859					FORTH_DSP_POP 
4859 cd c2 23			call macro_forth_dsp_pop 
485c				endm 
# End of macro FORTH_DSP_POP
485c			 
485c			 
485c					FORTH_DSP_VALUE 
485c cd f3 22			call macro_forth_dsp_value 
485f				endm 
# End of macro FORTH_DSP_VALUE
485f			 
485f d1					pop de    ; get start post offset 
4860			 
4860 19					add hl, de    ; starting offset 
4861			 
4861 c1					pop bc 
4862 c5					push bc      ; grab size of string 
4863			 
4863 e5					push hl    ; save string start  
4864			 
4864 26 00				ld h, 0 
4866 69					ld l, c 
4867 23					inc hl 
4868 23					inc hl 
4869			 
4869 cd 97 14				call malloc 
486c				if DEBUG_FORTH_MALLOC_GUARD 
486c cc b2 5d				call z,malloc_error 
486f				endif 
486f			 
486f eb					ex de, hl      ; save malloc area for string copy 
4870 e1					pop hl    ; get back source 
4871 c1					pop bc    ; get length of string back 
4872			 
4872 d5					push de    ; save malloc area for after we push 
4873 ed b0				ldir     ; copy substr 
4875			 
4875			 
4875 eb					ex de, hl 
4876 3e 00				ld a, 0 
4878 77					ld (hl), a   ; term substr 
4879			 
4879					 
4879 e1					pop hl    ; get malloc so we can push it 
487a e5					push hl   ; save so we can free it afterwards 
487b			 
487b cd 81 21				call forth_push_str 
487e			 
487e e1					pop hl 
487f cd 61 15				call free 
4882			 
4882					 
4882					 
4882			 
4882			 
4882					NEXTW 
4882 c3 c0 24			jp macro_next 
4885				endm 
# End of macro NEXTW
4885			 
4885			.LEFT: 
4885				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4885 48				db WORD_SYS_CORE+52             
4886 ad 48			dw .RIGHT            
4888 05				db 4 + 1 
4889 .. 00			db "LEFT",0              
488e				endm 
# End of macro CWHEAD
488e			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
488e					if DEBUG_FORTH_WORDS_KEY 
488e						DMARK "LEF" 
488e f5				push af  
488f 3a a3 48			ld a, (.dmark)  
4892 32 68 fe			ld (debug_mark),a  
4895 3a a4 48			ld a, (.dmark+1)  
4898 32 69 fe			ld (debug_mark+1),a  
489b 3a a5 48			ld a, (.dmark+2)  
489e 32 6a fe			ld (debug_mark+2),a  
48a1 18 03			jr .pastdmark  
48a3 ..			.dmark: db "LEF"  
48a6 f1			.pastdmark: pop af  
48a7			endm  
# End of macro DMARK
48a7						CALLMONITOR 
48a7 cd 6c fe			call debug_vector  
48aa				endm  
# End of macro CALLMONITOR
48aa					endif 
48aa			 
48aa					NEXTW 
48aa c3 c0 24			jp macro_next 
48ad				endm 
# End of macro NEXTW
48ad			.RIGHT: 
48ad				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
48ad 48				db WORD_SYS_CORE+52             
48ae d6 48			dw .STR2NUM            
48b0 06				db 5 + 1 
48b1 .. 00			db "RIGHT",0              
48b7				endm 
# End of macro CWHEAD
48b7			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
48b7					if DEBUG_FORTH_WORDS_KEY 
48b7						DMARK "RIG" 
48b7 f5				push af  
48b8 3a cc 48			ld a, (.dmark)  
48bb 32 68 fe			ld (debug_mark),a  
48be 3a cd 48			ld a, (.dmark+1)  
48c1 32 69 fe			ld (debug_mark+1),a  
48c4 3a ce 48			ld a, (.dmark+2)  
48c7 32 6a fe			ld (debug_mark+2),a  
48ca 18 03			jr .pastdmark  
48cc ..			.dmark: db "RIG"  
48cf f1			.pastdmark: pop af  
48d0			endm  
# End of macro DMARK
48d0						CALLMONITOR 
48d0 cd 6c fe			call debug_vector  
48d3				endm  
# End of macro CALLMONITOR
48d3					endif 
48d3			 
48d3					NEXTW 
48d3 c3 c0 24			jp macro_next 
48d6				endm 
# End of macro NEXTW
48d6			 
48d6			 
48d6			.STR2NUM: 
48d6				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
48d6 48				db WORD_SYS_CORE+52             
48d7 62 49			dw .NUM2STR            
48d9 08				db 7 + 1 
48da .. 00			db "STR2NUM",0              
48e2				endm 
# End of macro CWHEAD
48e2			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
48e2			 
48e2			 
48e2			; TODO STR type check to do 
48e2					if DEBUG_FORTH_WORDS_KEY 
48e2						DMARK "S2N" 
48e2 f5				push af  
48e3 3a f7 48			ld a, (.dmark)  
48e6 32 68 fe			ld (debug_mark),a  
48e9 3a f8 48			ld a, (.dmark+1)  
48ec 32 69 fe			ld (debug_mark+1),a  
48ef 3a f9 48			ld a, (.dmark+2)  
48f2 32 6a fe			ld (debug_mark+2),a  
48f5 18 03			jr .pastdmark  
48f7 ..			.dmark: db "S2N"  
48fa f1			.pastdmark: pop af  
48fb			endm  
# End of macro DMARK
48fb						CALLMONITOR 
48fb cd 6c fe			call debug_vector  
48fe				endm  
# End of macro CALLMONITOR
48fe					endif 
48fe			 
48fe					;FORTH_DSP 
48fe					FORTH_DSP_VALUE 
48fe cd f3 22			call macro_forth_dsp_value 
4901				endm 
# End of macro FORTH_DSP_VALUE
4901					;inc hl 
4901			 
4901 eb					ex de, hl 
4902					if DEBUG_FORTH_WORDS 
4902						DMARK "S2a" 
4902 f5				push af  
4903 3a 17 49			ld a, (.dmark)  
4906 32 68 fe			ld (debug_mark),a  
4909 3a 18 49			ld a, (.dmark+1)  
490c 32 69 fe			ld (debug_mark+1),a  
490f 3a 19 49			ld a, (.dmark+2)  
4912 32 6a fe			ld (debug_mark+2),a  
4915 18 03			jr .pastdmark  
4917 ..			.dmark: db "S2a"  
491a f1			.pastdmark: pop af  
491b			endm  
# End of macro DMARK
491b						CALLMONITOR 
491b cd 6c fe			call debug_vector  
491e				endm  
# End of macro CALLMONITOR
491e					endif 
491e cd c5 13				call string_to_uint16 
4921			 
4921					if DEBUG_FORTH_WORDS 
4921						DMARK "S2b" 
4921 f5				push af  
4922 3a 36 49			ld a, (.dmark)  
4925 32 68 fe			ld (debug_mark),a  
4928 3a 37 49			ld a, (.dmark+1)  
492b 32 69 fe			ld (debug_mark+1),a  
492e 3a 38 49			ld a, (.dmark+2)  
4931 32 6a fe			ld (debug_mark+2),a  
4934 18 03			jr .pastdmark  
4936 ..			.dmark: db "S2b"  
4939 f1			.pastdmark: pop af  
493a			endm  
# End of macro DMARK
493a						CALLMONITOR 
493a cd 6c fe			call debug_vector  
493d				endm  
# End of macro CALLMONITOR
493d					endif 
493d			;		push hl 
493d					FORTH_DSP_POP 
493d cd c2 23			call macro_forth_dsp_pop 
4940				endm 
# End of macro FORTH_DSP_POP
4940			;		pop hl 
4940					 
4940					if DEBUG_FORTH_WORDS 
4940						DMARK "S2b" 
4940 f5				push af  
4941 3a 55 49			ld a, (.dmark)  
4944 32 68 fe			ld (debug_mark),a  
4947 3a 56 49			ld a, (.dmark+1)  
494a 32 69 fe			ld (debug_mark+1),a  
494d 3a 57 49			ld a, (.dmark+2)  
4950 32 6a fe			ld (debug_mark+2),a  
4953 18 03			jr .pastdmark  
4955 ..			.dmark: db "S2b"  
4958 f1			.pastdmark: pop af  
4959			endm  
# End of macro DMARK
4959						CALLMONITOR 
4959 cd 6c fe			call debug_vector  
495c				endm  
# End of macro CALLMONITOR
495c					endif 
495c cd 13 21				call forth_push_numhl	 
495f			 
495f				 
495f				       NEXTW 
495f c3 c0 24			jp macro_next 
4962				endm 
# End of macro NEXTW
4962			.NUM2STR: 
4962				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4962 48				db WORD_SYS_CORE+52             
4963 71 49			dw .CONCAT            
4965 08				db 7 + 1 
4966 .. 00			db "NUM2STR",0              
496e				endm 
# End of macro CWHEAD
496e			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
496e			 
496e			;		; malloc a string to target 
496e			;		ld hl, 10     ; TODO max string size should be fine 
496e			;		call malloc 
496e			;		push hl    ; save malloc location 
496e			; 
496e			; 
496e			;; TODO check int type 
496e			;		FORTH_DSP_VALUEHL 
496e			;		ld a, l 
496e			;		call DispAToASCII   
496e			;;TODO need to chage above call to dump into string 
496e			; 
496e			; 
496e			 
496e				       NEXTW 
496e c3 c0 24			jp macro_next 
4971				endm 
# End of macro NEXTW
4971			 
4971			.CONCAT: 
4971				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4971 48				db WORD_SYS_CORE+52             
4972 24 4a			dw .FIND            
4974 07				db 6 + 1 
4975 .. 00			db "CONCAT",0              
497c				endm 
# End of macro CWHEAD
497c			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
497c			 
497c			; TODO check string type 
497c			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
497c			 
497c					if DEBUG_FORTH_WORDS_KEY 
497c						DMARK "CON" 
497c f5				push af  
497d 3a 91 49			ld a, (.dmark)  
4980 32 68 fe			ld (debug_mark),a  
4983 3a 92 49			ld a, (.dmark+1)  
4986 32 69 fe			ld (debug_mark+1),a  
4989 3a 93 49			ld a, (.dmark+2)  
498c 32 6a fe			ld (debug_mark+2),a  
498f 18 03			jr .pastdmark  
4991 ..			.dmark: db "CON"  
4994 f1			.pastdmark: pop af  
4995			endm  
# End of macro DMARK
4995						CALLMONITOR 
4995 cd 6c fe			call debug_vector  
4998				endm  
# End of macro CALLMONITOR
4998					endif 
4998			 
4998			 
4998					FORTH_DSP_VALUE 
4998 cd f3 22			call macro_forth_dsp_value 
499b				endm 
# End of macro FORTH_DSP_VALUE
499b e5					push hl   ; s2 
499c			 
499c					FORTH_DSP_POP 
499c cd c2 23			call macro_forth_dsp_pop 
499f				endm 
# End of macro FORTH_DSP_POP
499f			 
499f					FORTH_DSP_VALUE 
499f cd f3 22			call macro_forth_dsp_value 
49a2				endm 
# End of macro FORTH_DSP_VALUE
49a2			 
49a2 e5					push hl   ; s1 
49a3			 
49a3					FORTH_DSP_POP 
49a3 cd c2 23			call macro_forth_dsp_pop 
49a6				endm 
# End of macro FORTH_DSP_POP
49a6					 
49a6			 
49a6					; copy s1 
49a6			 
49a6				 
49a6					; save ptr 
49a6 e1					pop hl  
49a7 e5					push hl 
49a8 3e 00				ld a, 0 
49aa cd 39 14				call strlent 
49ad					;inc hl    ; zer0 
49ad 06 00				ld b, 0 
49af 4d					ld c, l 
49b0 e1					pop hl		 
49b1 11 be f1				ld de, scratch	 
49b4					if DEBUG_FORTH_WORDS 
49b4						DMARK "CO1" 
49b4 f5				push af  
49b5 3a c9 49			ld a, (.dmark)  
49b8 32 68 fe			ld (debug_mark),a  
49bb 3a ca 49			ld a, (.dmark+1)  
49be 32 69 fe			ld (debug_mark+1),a  
49c1 3a cb 49			ld a, (.dmark+2)  
49c4 32 6a fe			ld (debug_mark+2),a  
49c7 18 03			jr .pastdmark  
49c9 ..			.dmark: db "CO1"  
49cc f1			.pastdmark: pop af  
49cd			endm  
# End of macro DMARK
49cd						CALLMONITOR 
49cd cd 6c fe			call debug_vector  
49d0				endm  
# End of macro CALLMONITOR
49d0					endif 
49d0 ed b0				ldir 
49d2			 
49d2 e1					pop hl 
49d3 e5					push hl 
49d4 d5					push de 
49d5			 
49d5			 
49d5 3e 00				ld a, 0 
49d7 cd 39 14				call strlent 
49da 23					inc hl    ; zer0 
49db 23					inc hl 
49dc 06 00				ld b, 0 
49de 4d					ld c, l 
49df d1					pop de 
49e0 e1					pop hl		 
49e1					if DEBUG_FORTH_WORDS 
49e1						DMARK "CO2" 
49e1 f5				push af  
49e2 3a f6 49			ld a, (.dmark)  
49e5 32 68 fe			ld (debug_mark),a  
49e8 3a f7 49			ld a, (.dmark+1)  
49eb 32 69 fe			ld (debug_mark+1),a  
49ee 3a f8 49			ld a, (.dmark+2)  
49f1 32 6a fe			ld (debug_mark+2),a  
49f4 18 03			jr .pastdmark  
49f6 ..			.dmark: db "CO2"  
49f9 f1			.pastdmark: pop af  
49fa			endm  
# End of macro DMARK
49fa						CALLMONITOR 
49fa cd 6c fe			call debug_vector  
49fd				endm  
# End of macro CALLMONITOR
49fd					endif 
49fd ed b0				ldir 
49ff			 
49ff			 
49ff			 
49ff 21 be f1				ld hl, scratch 
4a02					if DEBUG_FORTH_WORDS 
4a02						DMARK "CO5" 
4a02 f5				push af  
4a03 3a 17 4a			ld a, (.dmark)  
4a06 32 68 fe			ld (debug_mark),a  
4a09 3a 18 4a			ld a, (.dmark+1)  
4a0c 32 69 fe			ld (debug_mark+1),a  
4a0f 3a 19 4a			ld a, (.dmark+2)  
4a12 32 6a fe			ld (debug_mark+2),a  
4a15 18 03			jr .pastdmark  
4a17 ..			.dmark: db "CO5"  
4a1a f1			.pastdmark: pop af  
4a1b			endm  
# End of macro DMARK
4a1b						CALLMONITOR 
4a1b cd 6c fe			call debug_vector  
4a1e				endm  
# End of macro CALLMONITOR
4a1e					endif 
4a1e			 
4a1e cd 81 21				call forth_push_str 
4a21			 
4a21			 
4a21			 
4a21			 
4a21				       NEXTW 
4a21 c3 c0 24			jp macro_next 
4a24				endm 
# End of macro NEXTW
4a24			 
4a24			 
4a24			.FIND: 
4a24				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a24 4b				db WORD_SYS_CORE+55             
4a25 e2 4a			dw .LEN            
4a27 05				db 4 + 1 
4a28 .. 00			db "FIND",0              
4a2d				endm 
# End of macro CWHEAD
4a2d			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a2d			 
4a2d					if DEBUG_FORTH_WORDS_KEY 
4a2d						DMARK "FND" 
4a2d f5				push af  
4a2e 3a 42 4a			ld a, (.dmark)  
4a31 32 68 fe			ld (debug_mark),a  
4a34 3a 43 4a			ld a, (.dmark+1)  
4a37 32 69 fe			ld (debug_mark+1),a  
4a3a 3a 44 4a			ld a, (.dmark+2)  
4a3d 32 6a fe			ld (debug_mark+2),a  
4a40 18 03			jr .pastdmark  
4a42 ..			.dmark: db "FND"  
4a45 f1			.pastdmark: pop af  
4a46			endm  
# End of macro DMARK
4a46						CALLMONITOR 
4a46 cd 6c fe			call debug_vector  
4a49				endm  
# End of macro CALLMONITOR
4a49					endif 
4a49			 
4a49			; TODO check string type 
4a49					FORTH_DSP_VALUE 
4a49 cd f3 22			call macro_forth_dsp_value 
4a4c				endm 
# End of macro FORTH_DSP_VALUE
4a4c			 
4a4c e5					push hl    
4a4d 7e					ld a,(hl)    ; char to find   
4a4e			; TODO change char to substr 
4a4e			 
4a4e f5					push af 
4a4f					 
4a4f			 
4a4f			 
4a4f					if DEBUG_FORTH_WORDS 
4a4f						DMARK "FN1" 
4a4f f5				push af  
4a50 3a 64 4a			ld a, (.dmark)  
4a53 32 68 fe			ld (debug_mark),a  
4a56 3a 65 4a			ld a, (.dmark+1)  
4a59 32 69 fe			ld (debug_mark+1),a  
4a5c 3a 66 4a			ld a, (.dmark+2)  
4a5f 32 6a fe			ld (debug_mark+2),a  
4a62 18 03			jr .pastdmark  
4a64 ..			.dmark: db "FN1"  
4a67 f1			.pastdmark: pop af  
4a68			endm  
# End of macro DMARK
4a68						CALLMONITOR 
4a68 cd 6c fe			call debug_vector  
4a6b				endm  
# End of macro CALLMONITOR
4a6b					endif 
4a6b			 
4a6b					FORTH_DSP_POP 
4a6b cd c2 23			call macro_forth_dsp_pop 
4a6e				endm 
# End of macro FORTH_DSP_POP
4a6e			 
4a6e					; string to search 
4a6e			 
4a6e					FORTH_DSP_VALUE 
4a6e cd f3 22			call macro_forth_dsp_value 
4a71				endm 
# End of macro FORTH_DSP_VALUE
4a71			 
4a71 d1					pop de  ; d is char to find  
4a72			 
4a72					if DEBUG_FORTH_WORDS 
4a72						DMARK "FN2" 
4a72 f5				push af  
4a73 3a 87 4a			ld a, (.dmark)  
4a76 32 68 fe			ld (debug_mark),a  
4a79 3a 88 4a			ld a, (.dmark+1)  
4a7c 32 69 fe			ld (debug_mark+1),a  
4a7f 3a 89 4a			ld a, (.dmark+2)  
4a82 32 6a fe			ld (debug_mark+2),a  
4a85 18 03			jr .pastdmark  
4a87 ..			.dmark: db "FN2"  
4a8a f1			.pastdmark: pop af  
4a8b			endm  
# End of macro DMARK
4a8b						CALLMONITOR 
4a8b cd 6c fe			call debug_vector  
4a8e				endm  
# End of macro CALLMONITOR
4a8e					endif 
4a8e					 
4a8e 01 00 00				ld bc, 0 
4a91 7e			.findchar:      ld a,(hl) 
4a92 fe 00				cp 0   		 
4a94 28 27				jr z, .finddone     
4a96 ba					cp d 
4a97 28 20				jr z, .foundchar 
4a99 03					inc bc 
4a9a 23					inc hl 
4a9b					if DEBUG_FORTH_WORDS 
4a9b						DMARK "FN3" 
4a9b f5				push af  
4a9c 3a b0 4a			ld a, (.dmark)  
4a9f 32 68 fe			ld (debug_mark),a  
4aa2 3a b1 4a			ld a, (.dmark+1)  
4aa5 32 69 fe			ld (debug_mark+1),a  
4aa8 3a b2 4a			ld a, (.dmark+2)  
4aab 32 6a fe			ld (debug_mark+2),a  
4aae 18 03			jr .pastdmark  
4ab0 ..			.dmark: db "FN3"  
4ab3 f1			.pastdmark: pop af  
4ab4			endm  
# End of macro DMARK
4ab4						CALLMONITOR 
4ab4 cd 6c fe			call debug_vector  
4ab7				endm  
# End of macro CALLMONITOR
4ab7					endif 
4ab7 18 d8				jr .findchar 
4ab9			 
4ab9			 
4ab9 c5			.foundchar:	push bc 
4aba e1					pop hl 
4abb 18 03				jr .findexit 
4abd			 
4abd			 
4abd							 
4abd			 
4abd			.finddone:     ; got to end of string with no find 
4abd 21 00 00				ld hl, 0 
4ac0			.findexit: 
4ac0			 
4ac0					if DEBUG_FORTH_WORDS 
4ac0						DMARK "FNd" 
4ac0 f5				push af  
4ac1 3a d5 4a			ld a, (.dmark)  
4ac4 32 68 fe			ld (debug_mark),a  
4ac7 3a d6 4a			ld a, (.dmark+1)  
4aca 32 69 fe			ld (debug_mark+1),a  
4acd 3a d7 4a			ld a, (.dmark+2)  
4ad0 32 6a fe			ld (debug_mark+2),a  
4ad3 18 03			jr .pastdmark  
4ad5 ..			.dmark: db "FNd"  
4ad8 f1			.pastdmark: pop af  
4ad9			endm  
# End of macro DMARK
4ad9						CALLMONITOR 
4ad9 cd 6c fe			call debug_vector  
4adc				endm  
# End of macro CALLMONITOR
4adc					endif 
4adc cd 13 21			call forth_push_numhl 
4adf			 
4adf				       NEXTW 
4adf c3 c0 24			jp macro_next 
4ae2				endm 
# End of macro NEXTW
4ae2			 
4ae2			.LEN: 
4ae2				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4ae2 4c				db WORD_SYS_CORE+56             
4ae3 4c 4b			dw .ASC            
4ae5 06				db 5 + 1 
4ae6 .. 00			db "COUNT",0              
4aec				endm 
# End of macro CWHEAD
4aec			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4aec			 
4aec					if DEBUG_FORTH_WORDS_KEY 
4aec						DMARK "CNT" 
4aec f5				push af  
4aed 3a 01 4b			ld a, (.dmark)  
4af0 32 68 fe			ld (debug_mark),a  
4af3 3a 02 4b			ld a, (.dmark+1)  
4af6 32 69 fe			ld (debug_mark+1),a  
4af9 3a 03 4b			ld a, (.dmark+2)  
4afc 32 6a fe			ld (debug_mark+2),a  
4aff 18 03			jr .pastdmark  
4b01 ..			.dmark: db "CNT"  
4b04 f1			.pastdmark: pop af  
4b05			endm  
# End of macro DMARK
4b05						CALLMONITOR 
4b05 cd 6c fe			call debug_vector  
4b08				endm  
# End of macro CALLMONITOR
4b08					endif 
4b08			; TODO check string type 
4b08					FORTH_DSP_VALUE 
4b08 cd f3 22			call macro_forth_dsp_value 
4b0b				endm 
# End of macro FORTH_DSP_VALUE
4b0b			 
4b0b			 
4b0b					if DEBUG_FORTH_WORDS 
4b0b						DMARK "CN?" 
4b0b f5				push af  
4b0c 3a 20 4b			ld a, (.dmark)  
4b0f 32 68 fe			ld (debug_mark),a  
4b12 3a 21 4b			ld a, (.dmark+1)  
4b15 32 69 fe			ld (debug_mark+1),a  
4b18 3a 22 4b			ld a, (.dmark+2)  
4b1b 32 6a fe			ld (debug_mark+2),a  
4b1e 18 03			jr .pastdmark  
4b20 ..			.dmark: db "CN?"  
4b23 f1			.pastdmark: pop af  
4b24			endm  
# End of macro DMARK
4b24						CALLMONITOR 
4b24 cd 6c fe			call debug_vector  
4b27				endm  
# End of macro CALLMONITOR
4b27					endif 
4b27 cd 2e 14				call strlenz 
4b2a					if DEBUG_FORTH_WORDS 
4b2a						DMARK "CNl" 
4b2a f5				push af  
4b2b 3a 3f 4b			ld a, (.dmark)  
4b2e 32 68 fe			ld (debug_mark),a  
4b31 3a 40 4b			ld a, (.dmark+1)  
4b34 32 69 fe			ld (debug_mark+1),a  
4b37 3a 41 4b			ld a, (.dmark+2)  
4b3a 32 6a fe			ld (debug_mark+2),a  
4b3d 18 03			jr .pastdmark  
4b3f ..			.dmark: db "CNl"  
4b42 f1			.pastdmark: pop af  
4b43			endm  
# End of macro DMARK
4b43						CALLMONITOR 
4b43 cd 6c fe			call debug_vector  
4b46				endm  
# End of macro CALLMONITOR
4b46					endif 
4b46			 
4b46 cd 13 21				call forth_push_numhl 
4b49			 
4b49			 
4b49			 
4b49				       NEXTW 
4b49 c3 c0 24			jp macro_next 
4b4c				endm 
# End of macro NEXTW
4b4c			.ASC: 
4b4c				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b4c 4d				db WORD_SYS_CORE+57             
4b4d ba 4b			dw .CHR            
4b4f 04				db 3 + 1 
4b50 .. 00			db "ASC",0              
4b54				endm 
# End of macro CWHEAD
4b54			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4b54					if DEBUG_FORTH_WORDS_KEY 
4b54						DMARK "ASC" 
4b54 f5				push af  
4b55 3a 69 4b			ld a, (.dmark)  
4b58 32 68 fe			ld (debug_mark),a  
4b5b 3a 6a 4b			ld a, (.dmark+1)  
4b5e 32 69 fe			ld (debug_mark+1),a  
4b61 3a 6b 4b			ld a, (.dmark+2)  
4b64 32 6a fe			ld (debug_mark+2),a  
4b67 18 03			jr .pastdmark  
4b69 ..			.dmark: db "ASC"  
4b6c f1			.pastdmark: pop af  
4b6d			endm  
# End of macro DMARK
4b6d						CALLMONITOR 
4b6d cd 6c fe			call debug_vector  
4b70				endm  
# End of macro CALLMONITOR
4b70					endif 
4b70					FORTH_DSP_VALUE 
4b70 cd f3 22			call macro_forth_dsp_value 
4b73				endm 
# End of macro FORTH_DSP_VALUE
4b73					;v5 FORTH_DSP_VALUE 
4b73			;		inc hl      ; now at start of numeric as string 
4b73			 
4b73 e5					push hl 
4b74			 
4b74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b74 cd c2 23			call macro_forth_dsp_pop 
4b77				endm 
# End of macro FORTH_DSP_POP
4b77			 
4b77 e1					pop hl 
4b78			 
4b78					if DEBUG_FORTH_WORDS 
4b78						DMARK "AS1" 
4b78 f5				push af  
4b79 3a 8d 4b			ld a, (.dmark)  
4b7c 32 68 fe			ld (debug_mark),a  
4b7f 3a 8e 4b			ld a, (.dmark+1)  
4b82 32 69 fe			ld (debug_mark+1),a  
4b85 3a 8f 4b			ld a, (.dmark+2)  
4b88 32 6a fe			ld (debug_mark+2),a  
4b8b 18 03			jr .pastdmark  
4b8d ..			.dmark: db "AS1"  
4b90 f1			.pastdmark: pop af  
4b91			endm  
# End of macro DMARK
4b91						CALLMONITOR 
4b91 cd 6c fe			call debug_vector  
4b94				endm  
# End of macro CALLMONITOR
4b94					endif 
4b94					; push the content of a onto the stack as a value 
4b94			 
4b94 7e					ld a,(hl)   ; get char 
4b95 26 00				ld h,0 
4b97 6f					ld l,a 
4b98					if DEBUG_FORTH_WORDS 
4b98						DMARK "AS2" 
4b98 f5				push af  
4b99 3a ad 4b			ld a, (.dmark)  
4b9c 32 68 fe			ld (debug_mark),a  
4b9f 3a ae 4b			ld a, (.dmark+1)  
4ba2 32 69 fe			ld (debug_mark+1),a  
4ba5 3a af 4b			ld a, (.dmark+2)  
4ba8 32 6a fe			ld (debug_mark+2),a  
4bab 18 03			jr .pastdmark  
4bad ..			.dmark: db "AS2"  
4bb0 f1			.pastdmark: pop af  
4bb1			endm  
# End of macro DMARK
4bb1						CALLMONITOR 
4bb1 cd 6c fe			call debug_vector  
4bb4				endm  
# End of macro CALLMONITOR
4bb4					endif 
4bb4 cd 13 21				call forth_push_numhl 
4bb7			 
4bb7				       NEXTW 
4bb7 c3 c0 24			jp macro_next 
4bba				endm 
# End of macro NEXTW
4bba			 
4bba			.CHR: 
4bba				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4bba 4d				db WORD_SYS_CORE+57             
4bbb f6 4b			dw .ENDSTR            
4bbd 04				db 3 + 1 
4bbe .. 00			db "CHR",0              
4bc2				endm 
# End of macro CWHEAD
4bc2			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4bc2					if DEBUG_FORTH_WORDS_KEY 
4bc2						DMARK "CHR" 
4bc2 f5				push af  
4bc3 3a d7 4b			ld a, (.dmark)  
4bc6 32 68 fe			ld (debug_mark),a  
4bc9 3a d8 4b			ld a, (.dmark+1)  
4bcc 32 69 fe			ld (debug_mark+1),a  
4bcf 3a d9 4b			ld a, (.dmark+2)  
4bd2 32 6a fe			ld (debug_mark+2),a  
4bd5 18 03			jr .pastdmark  
4bd7 ..			.dmark: db "CHR"  
4bda f1			.pastdmark: pop af  
4bdb			endm  
# End of macro DMARK
4bdb						CALLMONITOR 
4bdb cd 6c fe			call debug_vector  
4bde				endm  
# End of macro CALLMONITOR
4bde					endif 
4bde					FORTH_DSP_VALUEHL 
4bde cd 0a 23			call macro_dsp_valuehl 
4be1				endm 
# End of macro FORTH_DSP_VALUEHL
4be1			 
4be1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4be1 cd c2 23			call macro_forth_dsp_pop 
4be4				endm 
# End of macro FORTH_DSP_POP
4be4			 
4be4					; save asci byte as a zero term string and push string 
4be4			 
4be4 7d					ld a,l 
4be5 32 be f1				ld (scratch), a 
4be8			 
4be8 3e 00				ld a, 0 
4bea 32 bf f1				ld (scratch+1), a 
4bed			 
4bed 21 be f1				ld hl, scratch 
4bf0 cd 81 21				call forth_push_str 
4bf3			 
4bf3			 
4bf3				       NEXTW 
4bf3 c3 c0 24			jp macro_next 
4bf6				endm 
# End of macro NEXTW
4bf6			 
4bf6			 
4bf6			 
4bf6			 
4bf6			.ENDSTR: 
4bf6			; eof 
4bf6			 
# End of file forth_words_str.asm
4bf6			include "forth_words_key.asm" 
4bf6			 
4bf6			; | ## Keyboard Words 
4bf6			 
4bf6			.KEY: 
4bf6				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4bf6 3e				db WORD_SYS_CORE+42             
4bf7 26 4c			dw .WAITK            
4bf9 04				db 3 + 1 
4bfa .. 00			db "KEY",0              
4bfe				endm 
# End of macro CWHEAD
4bfe			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4bfe			 
4bfe					if DEBUG_FORTH_WORDS_KEY 
4bfe						DMARK "KEY" 
4bfe f5				push af  
4bff 3a 13 4c			ld a, (.dmark)  
4c02 32 68 fe			ld (debug_mark),a  
4c05 3a 14 4c			ld a, (.dmark+1)  
4c08 32 69 fe			ld (debug_mark+1),a  
4c0b 3a 15 4c			ld a, (.dmark+2)  
4c0e 32 6a fe			ld (debug_mark+2),a  
4c11 18 03			jr .pastdmark  
4c13 ..			.dmark: db "KEY"  
4c16 f1			.pastdmark: pop af  
4c17			endm  
# End of macro DMARK
4c17						CALLMONITOR 
4c17 cd 6c fe			call debug_vector  
4c1a				endm  
# End of macro CALLMONITOR
4c1a					endif 
4c1a			; TODO currently waits 
4c1a cd 82 79				call cin 
4c1d					;call cin_wait 
4c1d 6f					ld l, a 
4c1e 26 00				ld h, 0 
4c20 cd 13 21				call forth_push_numhl 
4c23					NEXTW 
4c23 c3 c0 24			jp macro_next 
4c26				endm 
# End of macro NEXTW
4c26			.WAITK: 
4c26				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c26 3f				db WORD_SYS_CORE+43             
4c27 58 4c			dw .ACCEPT            
4c29 06				db 5 + 1 
4c2a .. 00			db "WAITK",0              
4c30				endm 
# End of macro CWHEAD
4c30			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c30					if DEBUG_FORTH_WORDS_KEY 
4c30						DMARK "WAI" 
4c30 f5				push af  
4c31 3a 45 4c			ld a, (.dmark)  
4c34 32 68 fe			ld (debug_mark),a  
4c37 3a 46 4c			ld a, (.dmark+1)  
4c3a 32 69 fe			ld (debug_mark+1),a  
4c3d 3a 47 4c			ld a, (.dmark+2)  
4c40 32 6a fe			ld (debug_mark+2),a  
4c43 18 03			jr .pastdmark  
4c45 ..			.dmark: db "WAI"  
4c48 f1			.pastdmark: pop af  
4c49			endm  
# End of macro DMARK
4c49						CALLMONITOR 
4c49 cd 6c fe			call debug_vector  
4c4c				endm  
# End of macro CALLMONITOR
4c4c					endif 
4c4c cd 71 79				call cin_wait 
4c4f 6f					ld l, a 
4c50 26 00				ld h, 0 
4c52 cd 13 21				call forth_push_numhl 
4c55					NEXTW 
4c55 c3 c0 24			jp macro_next 
4c58				endm 
# End of macro NEXTW
4c58			.ACCEPT: 
4c58				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c58 40				db WORD_SYS_CORE+44             
4c59 b6 4c			dw .EDIT            
4c5b 07				db 6 + 1 
4c5c .. 00			db "ACCEPT",0              
4c63				endm 
# End of macro CWHEAD
4c63			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c63					; TODO crashes on push 
4c63					if DEBUG_FORTH_WORDS_KEY 
4c63						DMARK "ACC" 
4c63 f5				push af  
4c64 3a 78 4c			ld a, (.dmark)  
4c67 32 68 fe			ld (debug_mark),a  
4c6a 3a 79 4c			ld a, (.dmark+1)  
4c6d 32 69 fe			ld (debug_mark+1),a  
4c70 3a 7a 4c			ld a, (.dmark+2)  
4c73 32 6a fe			ld (debug_mark+2),a  
4c76 18 03			jr .pastdmark  
4c78 ..			.dmark: db "ACC"  
4c7b f1			.pastdmark: pop af  
4c7c			endm  
# End of macro DMARK
4c7c						CALLMONITOR 
4c7c cd 6c fe			call debug_vector  
4c7f				endm  
# End of macro CALLMONITOR
4c7f					endif 
4c7f 21 bc f3				ld hl, os_input 
4c82 3e 00				ld a, 0 
4c84 77					ld (hl),a 
4c85 3a 5b fa				ld a,(f_cursor_ptr) 
4c88 16 64				ld d, 100 
4c8a 0e 00				ld c, 0 
4c8c 1e 28				ld e, 40 
4c8e cd fd 0f				call input_str 
4c91					; TODO perhaps do a type check and wrap in quotes if not a number 
4c91 21 bc f3				ld hl, os_input 
4c94					if DEBUG_FORTH_WORDS 
4c94						DMARK "AC1" 
4c94 f5				push af  
4c95 3a a9 4c			ld a, (.dmark)  
4c98 32 68 fe			ld (debug_mark),a  
4c9b 3a aa 4c			ld a, (.dmark+1)  
4c9e 32 69 fe			ld (debug_mark+1),a  
4ca1 3a ab 4c			ld a, (.dmark+2)  
4ca4 32 6a fe			ld (debug_mark+2),a  
4ca7 18 03			jr .pastdmark  
4ca9 ..			.dmark: db "AC1"  
4cac f1			.pastdmark: pop af  
4cad			endm  
# End of macro DMARK
4cad						CALLMONITOR 
4cad cd 6c fe			call debug_vector  
4cb0				endm  
# End of macro CALLMONITOR
4cb0					endif 
4cb0 cd 81 21				call forth_push_str 
4cb3					NEXTW 
4cb3 c3 c0 24			jp macro_next 
4cb6				endm 
# End of macro NEXTW
4cb6			 
4cb6			.EDIT: 
4cb6				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4cb6 40				db WORD_SYS_CORE+44             
4cb7 58 4d			dw .DEDIT            
4cb9 05				db 4 + 1 
4cba .. 00			db "EDIT",0              
4cbf				endm 
# End of macro CWHEAD
4cbf			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4cbf			 
4cbf					; TODO does not copy from stack 
4cbf					if DEBUG_FORTH_WORDS_KEY 
4cbf						DMARK "EDT" 
4cbf f5				push af  
4cc0 3a d4 4c			ld a, (.dmark)  
4cc3 32 68 fe			ld (debug_mark),a  
4cc6 3a d5 4c			ld a, (.dmark+1)  
4cc9 32 69 fe			ld (debug_mark+1),a  
4ccc 3a d6 4c			ld a, (.dmark+2)  
4ccf 32 6a fe			ld (debug_mark+2),a  
4cd2 18 03			jr .pastdmark  
4cd4 ..			.dmark: db "EDT"  
4cd7 f1			.pastdmark: pop af  
4cd8			endm  
# End of macro DMARK
4cd8						CALLMONITOR 
4cd8 cd 6c fe			call debug_vector  
4cdb				endm  
# End of macro CALLMONITOR
4cdb					endif 
4cdb			 
4cdb					;FORTH_DSP 
4cdb					FORTH_DSP_VALUEHL 
4cdb cd 0a 23			call macro_dsp_valuehl 
4cde				endm 
# End of macro FORTH_DSP_VALUEHL
4cde			;		inc hl    ; TODO do type check 
4cde			 
4cde			;		call get_word_hl 
4cde e5					push hl 
4cdf					if DEBUG_FORTH_WORDS 
4cdf						DMARK "EDp" 
4cdf f5				push af  
4ce0 3a f4 4c			ld a, (.dmark)  
4ce3 32 68 fe			ld (debug_mark),a  
4ce6 3a f5 4c			ld a, (.dmark+1)  
4ce9 32 69 fe			ld (debug_mark+1),a  
4cec 3a f6 4c			ld a, (.dmark+2)  
4cef 32 6a fe			ld (debug_mark+2),a  
4cf2 18 03			jr .pastdmark  
4cf4 ..			.dmark: db "EDp"  
4cf7 f1			.pastdmark: pop af  
4cf8			endm  
# End of macro DMARK
4cf8						CALLMONITOR 
4cf8 cd 6c fe			call debug_vector  
4cfb				endm  
# End of macro CALLMONITOR
4cfb					endif 
4cfb				;	ld a, 0 
4cfb cd 2e 14				call strlenz 
4cfe 23					inc hl 
4cff			 
4cff 06 00				ld b, 0 
4d01 4d					ld c, l 
4d02			 
4d02 e1					pop hl 
4d03 11 bc f3				ld de, os_input 
4d06					if DEBUG_FORTH_WORDS_KEY 
4d06						DMARK "EDc" 
4d06 f5				push af  
4d07 3a 1b 4d			ld a, (.dmark)  
4d0a 32 68 fe			ld (debug_mark),a  
4d0d 3a 1c 4d			ld a, (.dmark+1)  
4d10 32 69 fe			ld (debug_mark+1),a  
4d13 3a 1d 4d			ld a, (.dmark+2)  
4d16 32 6a fe			ld (debug_mark+2),a  
4d19 18 03			jr .pastdmark  
4d1b ..			.dmark: db "EDc"  
4d1e f1			.pastdmark: pop af  
4d1f			endm  
# End of macro DMARK
4d1f						CALLMONITOR 
4d1f cd 6c fe			call debug_vector  
4d22				endm  
# End of macro CALLMONITOR
4d22					endif 
4d22 ed b0				ldir 
4d24			 
4d24			 
4d24 21 bc f3				ld hl, os_input 
4d27					;ld a, 0 
4d27					;ld (hl),a 
4d27 3a 5b fa				ld a,(f_cursor_ptr) 
4d2a 16 64				ld d, 100 
4d2c 0e 00				ld c, 0 
4d2e 1e 28				ld e, 40 
4d30 cd fd 0f				call input_str 
4d33					; TODO perhaps do a type check and wrap in quotes if not a number 
4d33 21 bc f3				ld hl, os_input 
4d36					if DEBUG_FORTH_WORDS 
4d36						DMARK "ED1" 
4d36 f5				push af  
4d37 3a 4b 4d			ld a, (.dmark)  
4d3a 32 68 fe			ld (debug_mark),a  
4d3d 3a 4c 4d			ld a, (.dmark+1)  
4d40 32 69 fe			ld (debug_mark+1),a  
4d43 3a 4d 4d			ld a, (.dmark+2)  
4d46 32 6a fe			ld (debug_mark+2),a  
4d49 18 03			jr .pastdmark  
4d4b ..			.dmark: db "ED1"  
4d4e f1			.pastdmark: pop af  
4d4f			endm  
# End of macro DMARK
4d4f						CALLMONITOR 
4d4f cd 6c fe			call debug_vector  
4d52				endm  
# End of macro CALLMONITOR
4d52					endif 
4d52 cd 81 21				call forth_push_str 
4d55					NEXTW 
4d55 c3 c0 24			jp macro_next 
4d58				endm 
# End of macro NEXTW
4d58			 
4d58			.DEDIT: 
4d58				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d58 40				db WORD_SYS_CORE+44             
4d59 ba 4d			dw .ENDKEY            
4d5b 06				db 5 + 1 
4d5c .. 00			db "DEDIT",0              
4d62				endm 
# End of macro CWHEAD
4d62			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d62			 
4d62					; TODO does not copy from stack 
4d62					if DEBUG_FORTH_WORDS_KEY 
4d62						DMARK "DED" 
4d62 f5				push af  
4d63 3a 77 4d			ld a, (.dmark)  
4d66 32 68 fe			ld (debug_mark),a  
4d69 3a 78 4d			ld a, (.dmark+1)  
4d6c 32 69 fe			ld (debug_mark+1),a  
4d6f 3a 79 4d			ld a, (.dmark+2)  
4d72 32 6a fe			ld (debug_mark+2),a  
4d75 18 03			jr .pastdmark  
4d77 ..			.dmark: db "DED"  
4d7a f1			.pastdmark: pop af  
4d7b			endm  
# End of macro DMARK
4d7b						CALLMONITOR 
4d7b cd 6c fe			call debug_vector  
4d7e				endm  
# End of macro CALLMONITOR
4d7e					endif 
4d7e			 
4d7e					;FORTH_DSP 
4d7e					FORTH_DSP_VALUEHL 
4d7e cd 0a 23			call macro_dsp_valuehl 
4d81				endm 
# End of macro FORTH_DSP_VALUEHL
4d81			;		inc hl    ; TODO do type check 
4d81			 
4d81			;		call get_word_hl 
4d81 e5					push hl 
4d82 e5					push hl 
4d83					FORTH_DSP_POP 
4d83 cd c2 23			call macro_forth_dsp_pop 
4d86				endm 
# End of macro FORTH_DSP_POP
4d86 e1					pop hl 
4d87					if DEBUG_FORTH_WORDS 
4d87						DMARK "EDp" 
4d87 f5				push af  
4d88 3a 9c 4d			ld a, (.dmark)  
4d8b 32 68 fe			ld (debug_mark),a  
4d8e 3a 9d 4d			ld a, (.dmark+1)  
4d91 32 69 fe			ld (debug_mark+1),a  
4d94 3a 9e 4d			ld a, (.dmark+2)  
4d97 32 6a fe			ld (debug_mark+2),a  
4d9a 18 03			jr .pastdmark  
4d9c ..			.dmark: db "EDp"  
4d9f f1			.pastdmark: pop af  
4da0			endm  
# End of macro DMARK
4da0						CALLMONITOR 
4da0 cd 6c fe			call debug_vector  
4da3				endm  
# End of macro CALLMONITOR
4da3					endif 
4da3				;	ld a, 0 
4da3 cd 2e 14				call strlenz 
4da6 23					inc hl 
4da7			 
4da7 06 00				ld b, 0 
4da9 4d					ld c, l 
4daa			 
4daa e1					pop hl 
4dab			 
4dab					;ld a, 0 
4dab					;ld (hl),a 
4dab 3a 5b fa				ld a,(f_cursor_ptr) 
4dae 16 64				ld d, 100 
4db0 0e 00				ld c, 0 
4db2 1e 28				ld e, 40 
4db4 cd fd 0f				call input_str 
4db7					; TODO perhaps do a type check and wrap in quotes if not a number 
4db7					NEXTW 
4db7 c3 c0 24			jp macro_next 
4dba				endm 
# End of macro NEXTW
4dba			 
4dba			 
4dba			.ENDKEY: 
4dba			; eof 
4dba			 
# End of file forth_words_key.asm
4dba			include "forth_words_const.asm" 
4dba			 
4dba			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4dba			 
4dba			 
4dba			.SPITIME: 
4dba				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4dba 77				db WORD_SYS_CORE+99             
4dbb cf 4d			dw .VA            
4dbd 08				db 7 + 1 
4dbe .. 00			db "SPITIME",0              
4dc6				endm 
# End of macro CWHEAD
4dc6			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4dc6			; 
4dc6			; | If using BANK devices then leave as is. 
4dc6			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4dc6			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4dc6			 
4dc6 21 61 fa				ld hl, spi_clktime  
4dc9 cd 13 21				call forth_push_numhl 
4dcc			 
4dcc					NEXTW 
4dcc c3 c0 24			jp macro_next 
4dcf				endm 
# End of macro NEXTW
4dcf			 
4dcf			 
4dcf			.VA: 
4dcf				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4dcf 77				db WORD_SYS_CORE+99             
4dd0 df 4d			dw .SYMBOL            
4dd2 03				db 2 + 1 
4dd3 .. 00			db "VA",0              
4dd6				endm 
# End of macro CWHEAD
4dd6			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4dd6 21 25 fa				ld hl, cli_var_array 
4dd9 cd 13 21				call forth_push_numhl 
4ddc			 
4ddc					NEXTW 
4ddc c3 c0 24			jp macro_next 
4ddf				endm 
# End of macro NEXTW
4ddf			 
4ddf			.SYMBOL: 
4ddf				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4ddf 77				db WORD_SYS_CORE+99             
4de0 e9 4e			dw .ENDCONST            
4de2 07				db 6 + 1 
4de3 .. 00			db "SYMBOL",0              
4dea				endm 
# End of macro CWHEAD
4dea			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4dea			; | 
4dea			; | The value is the number reference and the final address is pushed to stack 
4dea			 
4dea			; | dw sym_table 
4dea			; | dw nmi_vector 
4dea			; | dw cli_autodisplay 
4dea			; | dw cli_data_sp 
4dea			; | dw cli_data_stack 
4dea			; | dw cli_loop_sp 
4dea			; | dw cli_loop_stack 
4dea			; | dw cli_var_array 
4dea			; | dw cursor_col 
4dea			; | dw cursor_ptr 
4dea			; | ; 10 
4dea			; | dw cursor_row 
4dea			; | dw debug_mark 
4dea			; | dw display_fb0 
4dea			; | dw display_fb1 
4dea			; | dw display_fb2 
4dea			; | dw display_fb3 
4dea			; | dw display_fb_active 
4dea			; | dw execscratch 
4dea			; | dw f_cursor_ptr 
4dea			; | dw hardware_word 
4dea			; | ;20 
4dea			; | dw input_at_cursor 
4dea			; | dw input_at_pos 
4dea			; | dw input_cur_flash 
4dea			; | dw input_cur_onoff 
4dea			; | dw input_cursor 
4dea			; | dw input_display_size 
4dea			; | dw input_len 
4dea			; | dw input_ptr 
4dea			; | dw input_size 
4dea			; | dw input_start 
4dea			; | ; 30 
4dea			; | dw input_str 
4dea			; | dw input_under_cursor 
4dea			; | dw os_cli_cmd 
4dea			; | dw os_cur_ptr 
4dea			; | dw os_current_i 
4dea			; | dw os_input 
4dea			; | dw os_last_cmd 
4dea			; | dw os_last_new_uword 
4dea			; | dw debug_vector 
4dea			; | dw os_view_hl 
4dea			; | ;40 
4dea			; | dw os_word_scratch 
4dea			; | dw portbctl 
4dea			; | dw portbdata 
4dea			; | dw spi_cartdev 
4dea			; | dw spi_cartdev2 
4dea			; | dw spi_clktime 
4dea			; | dw spi_device 
4dea			; | dw spi_device_id 
4dea			; | dw spi_portbyte 
4dea			; | dw stackstore 
4dea			; | ; 50 
4dea			; | if STORAGE_SE 
4dea			; | dw storage_actl 
4dea			; | dw storage_adata 
4dea			; | else 
4dea			; | dw 0 
4dea			; | dw 0 
4dea			; | endif 
4dea			; | dw storage_append 
4dea			; | if STORAGE_SE 
4dea			; | dw storage_bctl 
4dea			; | else 
4dea			; | dw 0 
4dea			; | endif 
4dea			; | dw store_bank_active 
4dea			; | dw store_filecache 
4dea			; | dw store_longread 
4dea			; | dw store_openaddr 
4dea			; | dw store_openext 
4dea			; | dw store_openmaxext 
4dea			; | ; 60 
4dea			; | dw store_page 
4dea			; | dw store_readbuf 
4dea			; | dw store_readcont 
4dea			; | dw store_readptr 
4dea			; | dw store_tmpext 
4dea			; | dw store_tmpid 
4dea			; | dw store_tmppageid 
4dea			; | dw malloc 
4dea			; | dw free 
4dea			; | dw cin 
4dea			; | ; 70 
4dea			; | dw cin_wait 
4dea			; | dw forth_push_numhl 
4dea			; | dw forth_push_str 
4dea			 
4dea					if DEBUG_FORTH_WORDS_KEY 
4dea						DMARK "SYM" 
4dea f5				push af  
4deb 3a ff 4d			ld a, (.dmark)  
4dee 32 68 fe			ld (debug_mark),a  
4df1 3a 00 4e			ld a, (.dmark+1)  
4df4 32 69 fe			ld (debug_mark+1),a  
4df7 3a 01 4e			ld a, (.dmark+2)  
4dfa 32 6a fe			ld (debug_mark+2),a  
4dfd 18 03			jr .pastdmark  
4dff ..			.dmark: db "SYM"  
4e02 f1			.pastdmark: pop af  
4e03			endm  
# End of macro DMARK
4e03						CALLMONITOR 
4e03 cd 6c fe			call debug_vector  
4e06				endm  
# End of macro CALLMONITOR
4e06					endif 
4e06			 
4e06					FORTH_DSP_VALUEHL 
4e06 cd 0a 23			call macro_dsp_valuehl 
4e09				endm 
# End of macro FORTH_DSP_VALUEHL
4e09			 
4e09 7d					ld a, l     
4e0a			 
4e0a			 
4e0a					if DEBUG_FORTH_WORDS 
4e0a						DMARK "SY1" 
4e0a f5				push af  
4e0b 3a 1f 4e			ld a, (.dmark)  
4e0e 32 68 fe			ld (debug_mark),a  
4e11 3a 20 4e			ld a, (.dmark+1)  
4e14 32 69 fe			ld (debug_mark+1),a  
4e17 3a 21 4e			ld a, (.dmark+2)  
4e1a 32 6a fe			ld (debug_mark+2),a  
4e1d 18 03			jr .pastdmark  
4e1f ..			.dmark: db "SY1"  
4e22 f1			.pastdmark: pop af  
4e23			endm  
# End of macro DMARK
4e23						CALLMONITOR 
4e23 cd 6c fe			call debug_vector  
4e26				endm  
# End of macro CALLMONITOR
4e26					endif 
4e26					 
4e26 f5					push af	 
4e27					FORTH_DSP_POP 
4e27 cd c2 23			call macro_forth_dsp_pop 
4e2a				endm 
# End of macro FORTH_DSP_POP
4e2a f1					pop af 
4e2b			 
4e2b cb 27				sla a  
4e2d				 
4e2d					 
4e2d					if DEBUG_FORTH_WORDS 
4e2d						DMARK "SY" 
4e2d f5				push af  
4e2e 3a 42 4e			ld a, (.dmark)  
4e31 32 68 fe			ld (debug_mark),a  
4e34 3a 43 4e			ld a, (.dmark+1)  
4e37 32 69 fe			ld (debug_mark+1),a  
4e3a 3a 44 4e			ld a, (.dmark+2)  
4e3d 32 6a fe			ld (debug_mark+2),a  
4e40 18 02			jr .pastdmark  
4e42 ..			.dmark: db "SY"  
4e44 f1			.pastdmark: pop af  
4e45			endm  
# End of macro DMARK
4e45						CALLMONITOR 
4e45 cd 6c fe			call debug_vector  
4e48				endm  
# End of macro CALLMONITOR
4e48					endif 
4e48			 
4e48 21 57 4e				ld hl, sym_table 
4e4b cd d0 0f				call addatohl 
4e4e cd 42 24				call loadwordinhl 
4e51 cd 13 21				call forth_push_numhl 
4e54			 
4e54			 
4e54				       NEXTW 
4e54 c3 c0 24			jp macro_next 
4e57				endm 
# End of macro NEXTW
4e57			 
4e57			sym_table: 
4e57			 
4e57			; 0 
4e57 57 4e		dw sym_table 
4e59 6f fe		dw nmi_vector 
4e5b 39 fa		dw cli_autodisplay 
4e5d eb f9		dw cli_data_sp 
4e5f 25 f7		dw cli_data_stack 
4e61 ed f9		dw cli_loop_sp 
4e63 27 f9		dw cli_loop_stack 
4e65 25 fa		dw cli_var_array 
4e67 c2 fb		dw cursor_col 
4e69 c0 fb		dw cursor_ptr 
4e6b			; 10 
4e6b c1 fb		dw cursor_row 
4e6d 68 fe		dw debug_mark 
4e6f ae fd		dw display_fb0 
4e71 0d fd		dw display_fb1 
4e73 cb fb		dw display_fb2 
4e75 6c fc		dw display_fb3 
4e77 c9 fb		dw display_fb_active 
4e79 bd f2		dw execscratch 
4e7b 5b fa		dw f_cursor_ptr 
4e7d 72 fe		dw hardware_word 
4e7f			;20 
4e7f 5f fe		dw input_at_cursor 
4e81 61 fe		dw input_at_pos 
4e83 5d fe		dw input_cur_flash 
4e85 5c fe		dw input_cur_onoff 
4e87 52 fe		dw input_cursor 
4e89 62 fe		dw input_display_size 
4e8b 57 fe		dw input_len 
4e8d 66 fe		dw input_ptr 
4e8f 63 fe		dw input_size 
4e91 64 fe		dw input_start 
4e93			; 30 
4e93 fd 0f		dw input_str 
4e95 60 fe		dw input_under_cursor 
4e97 e5 f4		dw os_cli_cmd 
4e99 e1 f4		dw os_cur_ptr 
4e9b e3 f4		dw os_current_i 
4e9d bc f3		dw os_input 
4e9f e4 f5		dw os_last_cmd 
4ea1 bb f4		dw os_last_new_uword 
4ea3 6c fe		dw debug_vector 
4ea5 ac f1		dw os_view_hl 
4ea7			;40 
4ea7 c3 f4		dw os_word_scratch 
4ea9 c3 00		dw portbctl 
4eab c1 00		dw portbdata 
4ead 60 fa		dw spi_cartdev 
4eaf 5f fa		dw spi_cartdev2 
4eb1 61 fa		dw spi_clktime 
4eb3 5d fa		dw spi_device 
4eb5 5c fa		dw spi_device_id 
4eb7 5e fa		dw spi_portbyte 
4eb9 a4 fb		dw stackstore 
4ebb			; 50 
4ebb			if STORAGE_SE 
4ebb 82 00		dw storage_actl 
4ebd 80 00		dw storage_adata 
4ebf			else 
4ebf			dw 0 
4ebf			dw 0 
4ebf			endif 
4ebf 56 0b		dw storage_append 
4ec1			if STORAGE_SE 
4ec1 83 00		dw storage_bctl 
4ec3			else 
4ec3			dw 0 
4ec3			endif 
4ec3 90 fb		dw store_bank_active 
4ec5 64 fa		dw store_filecache 
4ec7 72 fa		dw store_longread 
4ec9 68 fa		dw store_openaddr 
4ecb 67 fa		dw store_openext 
4ecd 66 fa		dw store_openmaxext 
4ecf			; 60 
4ecf 77 fa		dw store_page 
4ed1 73 fa		dw store_readbuf 
4ed3 6a fa		dw store_readcont 
4ed5 75 fa		dw store_readptr 
4ed7 6a fa		dw store_tmpext 
4ed9 6b fa		dw store_tmpid 
4edb 62 fa		dw store_tmppageid 
4edd 97 14		dw malloc 
4edf 61 15		dw free 
4ee1 82 79		dw cin 
4ee3			; 70 
4ee3 71 79		dw cin_wait 
4ee5 13 21		dw forth_push_numhl 
4ee7 81 21		dw forth_push_str 
4ee9			 
4ee9			 
4ee9			.ENDCONST: 
4ee9			 
4ee9			; eof 
4ee9			 
4ee9			 
# End of file forth_words_const.asm
4ee9			 
4ee9			if STORAGE_SE 
4ee9			   	include "forth_words_storage.asm" 
4ee9			 
4ee9			; | ## Fixed Storage Words 
4ee9			 
4ee9			.RENAME: 
4ee9			  
4ee9				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4ee9 3a				db WORD_SYS_CORE+38             
4eea df 4f			dw .RECORD            
4eec 07				db 6 + 1 
4eed .. 00			db "RENAME",0              
4ef4				endm 
# End of macro CWHEAD
4ef4			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4ef4			; | | Compatible with PicoSPINet  
4ef4					if DEBUG_FORTH_WORDS_KEY 
4ef4						DMARK "REN" 
4ef4 f5				push af  
4ef5 3a 09 4f			ld a, (.dmark)  
4ef8 32 68 fe			ld (debug_mark),a  
4efb 3a 0a 4f			ld a, (.dmark+1)  
4efe 32 69 fe			ld (debug_mark+1),a  
4f01 3a 0b 4f			ld a, (.dmark+2)  
4f04 32 6a fe			ld (debug_mark+2),a  
4f07 18 03			jr .pastdmark  
4f09 ..			.dmark: db "REN"  
4f0c f1			.pastdmark: pop af  
4f0d			endm  
# End of macro DMARK
4f0d						CALLMONITOR 
4f0d cd 6c fe			call debug_vector  
4f10				endm  
# End of macro CALLMONITOR
4f10					endif 
4f10			 
4f10			 
4f10					; preserve some internal vars used by other file handing routines 
4f10			 
4f10 2a 68 fa				ld hl, (store_openaddr) 
4f13 e5					push hl 
4f14 3a 6a fa				ld a, (store_readcont) 
4f17 f5					push af 
4f18			 
4f18					FORTH_DSP_VALUEHL 
4f18 cd 0a 23			call macro_dsp_valuehl 
4f1b				endm 
# End of macro FORTH_DSP_VALUEHL
4f1b			 
4f1b					; move ext and id around for the file header 
4f1b			 
4f1b 65					ld h, l 
4f1c 2e 00				ld l, 0 
4f1e			 
4f1e e5					push hl    ; id 
4f1f			 
4f1f					FORTH_DSP_POP 
4f1f cd c2 23			call macro_forth_dsp_pop 
4f22				endm 
# End of macro FORTH_DSP_POP
4f22			 
4f22					; Locate the file header 
4f22			 
4f22 e1					pop hl 
4f23 e5					push hl 
4f24 11 77 fa				ld de, store_page      ; get block zero of file 
4f27					if DEBUG_FORTH_WORDS 
4f27						DMARK "REr" 
4f27 f5				push af  
4f28 3a 3c 4f			ld a, (.dmark)  
4f2b 32 68 fe			ld (debug_mark),a  
4f2e 3a 3d 4f			ld a, (.dmark+1)  
4f31 32 69 fe			ld (debug_mark+1),a  
4f34 3a 3e 4f			ld a, (.dmark+2)  
4f37 32 6a fe			ld (debug_mark+2),a  
4f3a 18 03			jr .pastdmark  
4f3c ..			.dmark: db "REr"  
4f3f f1			.pastdmark: pop af  
4f40			endm  
# End of macro DMARK
4f40						CALLMONITOR 
4f40 cd 6c fe			call debug_vector  
4f43				endm  
# End of macro CALLMONITOR
4f43					endif 
4f43 cd bf 09				call storage_read 
4f46			 
4f46 cd f9 0f			call ishlzero 
4f49 20 05			jr nz, .rnfound 
4f4b			 
4f4b				; file does not exist so indicate with 255 extents in use 
4f4b			 
4f4b 3e ff			ld a, 255 
4f4d e1				pop hl ; clear dup hl 
4f4e 18 7b			jr .skiprneof 
4f50			 
4f50			 
4f50			.rnfound: 
4f50					; file found so rename 
4f50			 
4f50					FORTH_DSP_VALUEHL 
4f50 cd 0a 23			call macro_dsp_valuehl 
4f53				endm 
# End of macro FORTH_DSP_VALUEHL
4f53			 
4f53 e5				push hl 
4f54 3e 00			ld a, 0 
4f56 cd 39 14			call strlent 
4f59 23				inc hl   ; cover zero term 
4f5a 06 00			ld b,0 
4f5c 4d				ld c,l 
4f5d e1				pop hl 
4f5e 11 7a fa				ld de, store_page + 3 
4f61 ed b0				ldir 
4f63			 
4f63 11 77 fa				ld de, store_page 
4f66					if DEBUG_FORTH_WORDS 
4f66						DMARK "RER" 
4f66 f5				push af  
4f67 3a 7b 4f			ld a, (.dmark)  
4f6a 32 68 fe			ld (debug_mark),a  
4f6d 3a 7c 4f			ld a, (.dmark+1)  
4f70 32 69 fe			ld (debug_mark+1),a  
4f73 3a 7d 4f			ld a, (.dmark+2)  
4f76 32 6a fe			ld (debug_mark+2),a  
4f79 18 03			jr .pastdmark  
4f7b ..			.dmark: db "RER"  
4f7e f1			.pastdmark: pop af  
4f7f			endm  
# End of macro DMARK
4f7f						CALLMONITOR 
4f7f cd 6c fe			call debug_vector  
4f82				endm  
# End of macro CALLMONITOR
4f82					endif 
4f82			 
4f82 e1					pop hl    ; get orig file id and mangle it for find id 
4f83 55					ld d, l 
4f84 5c					ld e, h 
4f85			 
4f85 21 00 00				ld hl, 0 
4f88					if DEBUG_FORTH_WORDS 
4f88						DMARK "REf" 
4f88 f5				push af  
4f89 3a 9d 4f			ld a, (.dmark)  
4f8c 32 68 fe			ld (debug_mark),a  
4f8f 3a 9e 4f			ld a, (.dmark+1)  
4f92 32 69 fe			ld (debug_mark+1),a  
4f95 3a 9f 4f			ld a, (.dmark+2)  
4f98 32 6a fe			ld (debug_mark+2),a  
4f9b 18 03			jr .pastdmark  
4f9d ..			.dmark: db "REf"  
4fa0 f1			.pastdmark: pop af  
4fa1			endm  
# End of macro DMARK
4fa1						CALLMONITOR 
4fa1 cd 6c fe			call debug_vector  
4fa4				endm  
# End of macro CALLMONITOR
4fa4					endif 
4fa4 cd 99 07				call storage_findnextid 
4fa7 11 77 fa				ld de, store_page 
4faa					if DEBUG_FORTH_WORDS 
4faa						DMARK "REw" 
4faa f5				push af  
4fab 3a bf 4f			ld a, (.dmark)  
4fae 32 68 fe			ld (debug_mark),a  
4fb1 3a c0 4f			ld a, (.dmark+1)  
4fb4 32 69 fe			ld (debug_mark+1),a  
4fb7 3a c1 4f			ld a, (.dmark+2)  
4fba 32 6a fe			ld (debug_mark+2),a  
4fbd 18 03			jr .pastdmark  
4fbf ..			.dmark: db "REw"  
4fc2 f1			.pastdmark: pop af  
4fc3			endm  
# End of macro DMARK
4fc3						CALLMONITOR 
4fc3 cd 6c fe			call debug_vector  
4fc6				endm  
# End of macro CALLMONITOR
4fc6					endif 
4fc6 cd cb 04				call storage_write_block 
4fc9			 
4fc9 3e 00				ld a, 0 
4fcb			.skiprneof: 
4fcb					; drop file name 
4fcb					FORTH_DSP_POP 
4fcb cd c2 23			call macro_forth_dsp_pop 
4fce				endm 
# End of macro FORTH_DSP_POP
4fce			 
4fce 6f					ld l, a 
4fcf 26 00				ld h, 0 
4fd1 cd 13 21				call forth_push_numhl 
4fd4			 
4fd4			 
4fd4 f1					pop af 
4fd5 32 6a fa				ld (store_readcont),a 
4fd8 e1					pop hl 
4fd9 22 68 fa				ld (store_openaddr), hl 
4fdc						 
4fdc				NEXTW 
4fdc c3 c0 24			jp macro_next 
4fdf				endm 
# End of macro NEXTW
4fdf			.RECORD: 
4fdf			  
4fdf				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4fdf 3a				db WORD_SYS_CORE+38             
4fe0 83 50			dw .BREAD            
4fe2 07				db 6 + 1 
4fe3 .. 00			db "RECORD",0              
4fea				endm 
# End of macro CWHEAD
4fea			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4fea			; | | Compatible with PicoSPINet  
4fea			 
4fea					if DEBUG_FORTH_WORDS_KEY 
4fea						DMARK "REC" 
4fea f5				push af  
4feb 3a ff 4f			ld a, (.dmark)  
4fee 32 68 fe			ld (debug_mark),a  
4ff1 3a 00 50			ld a, (.dmark+1)  
4ff4 32 69 fe			ld (debug_mark+1),a  
4ff7 3a 01 50			ld a, (.dmark+2)  
4ffa 32 6a fe			ld (debug_mark+2),a  
4ffd 18 03			jr .pastdmark  
4fff ..			.dmark: db "REC"  
5002 f1			.pastdmark: pop af  
5003			endm  
# End of macro DMARK
5003						CALLMONITOR 
5003 cd 6c fe			call debug_vector  
5006				endm  
# End of macro CALLMONITOR
5006					endif 
5006			 
5006					FORTH_DSP_VALUEHL 
5006 cd 0a 23			call macro_dsp_valuehl 
5009				endm 
# End of macro FORTH_DSP_VALUEHL
5009			 
5009 e5					push hl    ; id 
500a			 
500a					FORTH_DSP_POP 
500a cd c2 23			call macro_forth_dsp_pop 
500d				endm 
# End of macro FORTH_DSP_POP
500d			 
500d					FORTH_DSP_VALUEHL 
500d cd 0a 23			call macro_dsp_valuehl 
5010				endm 
# End of macro FORTH_DSP_VALUEHL
5010			 
5010					FORTH_DSP_POP 
5010 cd c2 23			call macro_forth_dsp_pop 
5013				endm 
# End of macro FORTH_DSP_POP
5013			 
5013 d1					pop de     ; get file id 
5014			 
5014					; e = file id 
5014					; l = file extent 
5014			 
5014			 
5014					; construct request to access file extent 
5014			 
5014			;		ld a, e 
5014 63					ld h, e 
5015					 
5015					 
5015					 
5015			 
5015					; e has id 
5015			 
5015 11 77 fa			ld de, store_page 
5018					if DEBUG_FORTH_WORDS 
5018						DMARK "REr" 
5018 f5				push af  
5019 3a 2d 50			ld a, (.dmark)  
501c 32 68 fe			ld (debug_mark),a  
501f 3a 2e 50			ld a, (.dmark+1)  
5022 32 69 fe			ld (debug_mark+1),a  
5025 3a 2f 50			ld a, (.dmark+2)  
5028 32 6a fe			ld (debug_mark+2),a  
502b 18 03			jr .pastdmark  
502d ..			.dmark: db "REr"  
5030 f1			.pastdmark: pop af  
5031			endm  
# End of macro DMARK
5031						CALLMONITOR 
5031 cd 6c fe			call debug_vector  
5034				endm  
# End of macro CALLMONITOR
5034					endif 
5034 cd bf 09				call storage_read 
5037 cd f9 0f			call ishlzero 
503a 28 22			jr z, .recnotfound 
503c			 
503c			 
503c					if DEBUG_FORTH_WORDS 
503c						DMARK "REe" 
503c f5				push af  
503d 3a 51 50			ld a, (.dmark)  
5040 32 68 fe			ld (debug_mark),a  
5043 3a 52 50			ld a, (.dmark+1)  
5046 32 69 fe			ld (debug_mark+1),a  
5049 3a 53 50			ld a, (.dmark+2)  
504c 32 6a fe			ld (debug_mark+2),a  
504f 18 03			jr .pastdmark  
5051 ..			.dmark: db "REe"  
5054 f1			.pastdmark: pop af  
5055			endm  
# End of macro DMARK
5055						CALLMONITOR 
5055 cd 6c fe			call debug_vector  
5058				endm  
# End of macro CALLMONITOR
5058					endif 
5058 cd 81 21			call forth_push_str 
505b			 
505b					NEXTW 
505b c3 c0 24			jp macro_next 
505e				endm 
# End of macro NEXTW
505e			 
505e			.recnotfound: 
505e					if DEBUG_FORTH_WORDS 
505e						DMARK "REf" 
505e f5				push af  
505f 3a 73 50			ld a, (.dmark)  
5062 32 68 fe			ld (debug_mark),a  
5065 3a 74 50			ld a, (.dmark+1)  
5068 32 69 fe			ld (debug_mark+1),a  
506b 3a 75 50			ld a, (.dmark+2)  
506e 32 6a fe			ld (debug_mark+2),a  
5071 18 03			jr .pastdmark  
5073 ..			.dmark: db "REf"  
5076 f1			.pastdmark: pop af  
5077			endm  
# End of macro DMARK
5077						CALLMONITOR 
5077 cd 6c fe			call debug_vector  
507a				endm  
# End of macro CALLMONITOR
507a					endif 
507a 21 ff 00			ld hl, 255 
507d cd 13 21			call forth_push_numhl 
5080				NEXTW 
5080 c3 c0 24			jp macro_next 
5083				endm 
# End of macro NEXTW
5083			 
5083			 
5083			.BREAD: 
5083			  
5083				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5083 3a				db WORD_SYS_CORE+38             
5084 06 51			dw .BWRITE            
5086 06				db 5 + 1 
5087 .. 00			db "BREAD",0              
508d				endm 
# End of macro CWHEAD
508d			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
508d			; | | Compatible with PicoSPINet  
508d				 
508d					if DEBUG_FORTH_WORDS_KEY 
508d						DMARK "BRD" 
508d f5				push af  
508e 3a a2 50			ld a, (.dmark)  
5091 32 68 fe			ld (debug_mark),a  
5094 3a a3 50			ld a, (.dmark+1)  
5097 32 69 fe			ld (debug_mark+1),a  
509a 3a a4 50			ld a, (.dmark+2)  
509d 32 6a fe			ld (debug_mark+2),a  
50a0 18 03			jr .pastdmark  
50a2 ..			.dmark: db "BRD"  
50a5 f1			.pastdmark: pop af  
50a6			endm  
# End of macro DMARK
50a6						CALLMONITOR 
50a6 cd 6c fe			call debug_vector  
50a9				endm  
# End of macro CALLMONITOR
50a9					endif 
50a9			 
50a9				FORTH_DSP_VALUEHL 
50a9 cd 0a 23			call macro_dsp_valuehl 
50ac				endm 
# End of macro FORTH_DSP_VALUEHL
50ac			 
50ac				FORTH_DSP_POP 
50ac cd c2 23			call macro_forth_dsp_pop 
50af				endm 
# End of macro FORTH_DSP_POP
50af			 
50af				; calc block address 
50af			 
50af eb				ex de, hl 
50b0 3e 40			ld a, STORE_BLOCK_PHY 
50b2 cd 53 0f			call Mult16 
50b5			 
50b5			 
50b5 11 77 fa			ld de, store_page 
50b8			 
50b8					if DEBUG_FORTH_WORDS 
50b8						DMARK "BR1" 
50b8 f5				push af  
50b9 3a cd 50			ld a, (.dmark)  
50bc 32 68 fe			ld (debug_mark),a  
50bf 3a ce 50			ld a, (.dmark+1)  
50c2 32 69 fe			ld (debug_mark+1),a  
50c5 3a cf 50			ld a, (.dmark+2)  
50c8 32 6a fe			ld (debug_mark+2),a  
50cb 18 03			jr .pastdmark  
50cd ..			.dmark: db "BR1"  
50d0 f1			.pastdmark: pop af  
50d1			endm  
# End of macro DMARK
50d1						CALLMONITOR 
50d1 cd 6c fe			call debug_vector  
50d4				endm  
# End of macro CALLMONITOR
50d4					endif 
50d4			 
50d4 cd 66 04			call storage_read_block 
50d7			 
50d7 cd f9 0f			call ishlzero 
50da 20 05			jr nz, .brfound 
50dc			 
50dc cd 13 21			call forth_push_numhl 
50df 18 22			jr .brdone 
50e1			 
50e1			 
50e1			.brfound: 
50e1 21 79 fa		        ld hl, store_page+2 
50e4			 
50e4					if DEBUG_FORTH_WORDS 
50e4						DMARK "BR2" 
50e4 f5				push af  
50e5 3a f9 50			ld a, (.dmark)  
50e8 32 68 fe			ld (debug_mark),a  
50eb 3a fa 50			ld a, (.dmark+1)  
50ee 32 69 fe			ld (debug_mark+1),a  
50f1 3a fb 50			ld a, (.dmark+2)  
50f4 32 6a fe			ld (debug_mark+2),a  
50f7 18 03			jr .pastdmark  
50f9 ..			.dmark: db "BR2"  
50fc f1			.pastdmark: pop af  
50fd			endm  
# End of macro DMARK
50fd						CALLMONITOR 
50fd cd 6c fe			call debug_vector  
5100				endm  
# End of macro CALLMONITOR
5100					endif 
5100			 
5100 cd 81 21			call forth_push_str 
5103			 
5103			 
5103			.brdone: 
5103			 
5103					NEXTW 
5103 c3 c0 24			jp macro_next 
5106				endm 
# End of macro NEXTW
5106			.BWRITE: 
5106				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5106 3a				db WORD_SYS_CORE+38             
5107 9b 51			dw .BUPD            
5109 07				db 6 + 1 
510a .. 00			db "BWRITE",0              
5111				endm 
# End of macro CWHEAD
5111			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5111			; | | Compatible with PicoSPINet  
5111			 
5111					if DEBUG_FORTH_WORDS_KEY 
5111						DMARK "BWR" 
5111 f5				push af  
5112 3a 26 51			ld a, (.dmark)  
5115 32 68 fe			ld (debug_mark),a  
5118 3a 27 51			ld a, (.dmark+1)  
511b 32 69 fe			ld (debug_mark+1),a  
511e 3a 28 51			ld a, (.dmark+2)  
5121 32 6a fe			ld (debug_mark+2),a  
5124 18 03			jr .pastdmark  
5126 ..			.dmark: db "BWR"  
5129 f1			.pastdmark: pop af  
512a			endm  
# End of macro DMARK
512a						CALLMONITOR 
512a cd 6c fe			call debug_vector  
512d				endm  
# End of macro CALLMONITOR
512d					endif 
512d			 
512d				FORTH_DSP_VALUEHL 
512d cd 0a 23			call macro_dsp_valuehl 
5130				endm 
# End of macro FORTH_DSP_VALUEHL
5130			 
5130				; calc block address 
5130			 
5130 eb				ex de, hl 
5131 3e 40			ld a, STORE_BLOCK_PHY 
5133 cd 53 0f			call Mult16 
5136			 
5136 e5				push hl         ; address 
5137			 
5137				FORTH_DSP_POP 
5137 cd c2 23			call macro_forth_dsp_pop 
513a				endm 
# End of macro FORTH_DSP_POP
513a			 
513a				FORTH_DSP_VALUEHL 
513a cd 0a 23			call macro_dsp_valuehl 
513d				endm 
# End of macro FORTH_DSP_VALUEHL
513d			 
513d				FORTH_DSP_POP 
513d cd c2 23			call macro_forth_dsp_pop 
5140				endm 
# End of macro FORTH_DSP_POP
5140			 
5140 cd a2 0c			call storage_clear_page 
5143			 
5143				; copy string to store page 
5143			 
5143 e5				push hl     ; save string address 
5144			 
5144 3e 00			ld a, 0 
5146 cd 39 14			call strlent 
5149			 
5149 23				inc hl 
514a			 
514a 4d				ld c, l 
514b 06 00			ld b, 0 
514d			 
514d e1				pop hl 
514e 11 79 fa			ld de, store_page + 2 
5151					if DEBUG_FORTH_WORDS 
5151						DMARK "BW1" 
5151 f5				push af  
5152 3a 66 51			ld a, (.dmark)  
5155 32 68 fe			ld (debug_mark),a  
5158 3a 67 51			ld a, (.dmark+1)  
515b 32 69 fe			ld (debug_mark+1),a  
515e 3a 68 51			ld a, (.dmark+2)  
5161 32 6a fe			ld (debug_mark+2),a  
5164 18 03			jr .pastdmark  
5166 ..			.dmark: db "BW1"  
5169 f1			.pastdmark: pop af  
516a			endm  
# End of macro DMARK
516a						CALLMONITOR 
516a cd 6c fe			call debug_vector  
516d				endm  
# End of macro CALLMONITOR
516d					endif 
516d ed b0			ldir 
516f			 
516f			 
516f				; poke the start of the block with flags to prevent high level file ops hitting the block 
516f			 
516f 21 ff ff			ld hl, $ffff 
5172			 
5172 22 77 fa			ld (store_page), hl	 
5175				 
5175 e1				pop hl    ; get address 
5176 11 77 fa			ld de, store_page 
5179			 
5179					if DEBUG_FORTH_WORDS 
5179						DMARK "BW2" 
5179 f5				push af  
517a 3a 8e 51			ld a, (.dmark)  
517d 32 68 fe			ld (debug_mark),a  
5180 3a 8f 51			ld a, (.dmark+1)  
5183 32 69 fe			ld (debug_mark+1),a  
5186 3a 90 51			ld a, (.dmark+2)  
5189 32 6a fe			ld (debug_mark+2),a  
518c 18 03			jr .pastdmark  
518e ..			.dmark: db "BW2"  
5191 f1			.pastdmark: pop af  
5192			endm  
# End of macro DMARK
5192						CALLMONITOR 
5192 cd 6c fe			call debug_vector  
5195				endm  
# End of macro CALLMONITOR
5195					endif 
5195			 
5195 cd cb 04			call storage_write_block 
5198			 
5198					NEXTW 
5198 c3 c0 24			jp macro_next 
519b				endm 
# End of macro NEXTW
519b			 
519b			.BUPD: 
519b				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
519b 3a				db WORD_SYS_CORE+38             
519c f1 51			dw .BYID            
519e 05				db 4 + 1 
519f .. 00			db "BUPD",0              
51a4				endm 
# End of macro CWHEAD
51a4			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51a4			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51a4			; | | or completely different file system structure. 
51a4			; | | Compatible with PicoSPINet  
51a4			 
51a4					if DEBUG_FORTH_WORDS_KEY 
51a4						DMARK "BUD" 
51a4 f5				push af  
51a5 3a b9 51			ld a, (.dmark)  
51a8 32 68 fe			ld (debug_mark),a  
51ab 3a ba 51			ld a, (.dmark+1)  
51ae 32 69 fe			ld (debug_mark+1),a  
51b1 3a bb 51			ld a, (.dmark+2)  
51b4 32 6a fe			ld (debug_mark+2),a  
51b7 18 03			jr .pastdmark  
51b9 ..			.dmark: db "BUD"  
51bc f1			.pastdmark: pop af  
51bd			endm  
# End of macro DMARK
51bd						CALLMONITOR 
51bd cd 6c fe			call debug_vector  
51c0				endm  
# End of macro CALLMONITOR
51c0					endif 
51c0			 
51c0				FORTH_DSP_VALUEHL 
51c0 cd 0a 23			call macro_dsp_valuehl 
51c3				endm 
# End of macro FORTH_DSP_VALUEHL
51c3			 
51c3				; calc block address 
51c3			 
51c3 eb				ex de, hl 
51c4 3e 40			ld a, STORE_BLOCK_PHY 
51c6 cd 53 0f			call Mult16 
51c9			 
51c9				FORTH_DSP_POP 
51c9 cd c2 23			call macro_forth_dsp_pop 
51cc				endm 
# End of macro FORTH_DSP_POP
51cc			 
51cc			 
51cc 11 77 fa			ld de, store_page 
51cf			 
51cf					if DEBUG_FORTH_WORDS 
51cf						DMARK "BUe" 
51cf f5				push af  
51d0 3a e4 51			ld a, (.dmark)  
51d3 32 68 fe			ld (debug_mark),a  
51d6 3a e5 51			ld a, (.dmark+1)  
51d9 32 69 fe			ld (debug_mark+1),a  
51dc 3a e6 51			ld a, (.dmark+2)  
51df 32 6a fe			ld (debug_mark+2),a  
51e2 18 03			jr .pastdmark  
51e4 ..			.dmark: db "BUe"  
51e7 f1			.pastdmark: pop af  
51e8			endm  
# End of macro DMARK
51e8						CALLMONITOR 
51e8 cd 6c fe			call debug_vector  
51eb				endm  
# End of macro CALLMONITOR
51eb					endif 
51eb			 
51eb cd cb 04			call storage_write_block 
51ee			 
51ee					NEXTW 
51ee c3 c0 24			jp macro_next 
51f1				endm 
# End of macro NEXTW
51f1			 
51f1			.BYID: 
51f1			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
51f1			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
51f1			; 
51f1			;		 
51f1			;		if DEBUG_FORTH_WORDS_KEY 
51f1			;			DMARK "BYID" 
51f1			;			CALLMONITOR 
51f1			;		endif 
51f1			; 
51f1			;		; get direct address 
51f1			; 
51f1			;		FORTH_DSP_VALUEHL 
51f1			; 
51f1			;		FORTH_DSP_POP 
51f1			; 
51f1			;	; calc block address 
51f1			; 
51f1			;	ex de, hl 
51f1			;	ld a, STORE_BLOCK_PHY 
51f1			;	call Mult16 
51f1			;	;	do BREAD with number as param 
51f1			;	; push the file name	 
51f1			;	ld de, store_page 
51f1			;	call storage_read_block 
51f1			 ;       ld hl, store_page+2 
51f1			; 
51f1			; 
51f1			;		NEXTW 
51f1			;.BYNAME: 
51f1				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
51f1 3a				db WORD_SYS_CORE+38             
51f2 0a 52			dw .DIR            
51f4 06				db 5 + 1 
51f5 .. 00			db "GETID",0              
51fb				endm 
# End of macro CWHEAD
51fb			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
51fb			; | | Compatible with PicoSPINet  
51fb			 
51fb					; get pointer to file name to seek 
51fb			 
51fb					FORTH_DSP_VALUEHL 
51fb cd 0a 23			call macro_dsp_valuehl 
51fe				endm 
# End of macro FORTH_DSP_VALUEHL
51fe			 
51fe			 
51fe cd 8d 03				call storage_getid  
5201			 
5201					FORTH_DSP_POP 
5201 cd c2 23			call macro_forth_dsp_pop 
5204				endm 
# End of macro FORTH_DSP_POP
5204			 
5204 cd 13 21				call forth_push_numhl 
5207			 
5207					NEXTW 
5207 c3 c0 24			jp macro_next 
520a				endm 
# End of macro NEXTW
520a			; 
520a			.DIR: 
520a				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
520a 3a				db WORD_SYS_CORE+38             
520b 0e 53			dw .SAVE            
520d 04				db 3 + 1 
520e .. 00			db "DIR",0              
5212				endm 
# End of macro CWHEAD
5212			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5212			; | | Compatible with PicoSPINet  
5212			 
5212					if DEBUG_FORTH_WORDS_KEY 
5212						DMARK "DIR" 
5212 f5				push af  
5213 3a 27 52			ld a, (.dmark)  
5216 32 68 fe			ld (debug_mark),a  
5219 3a 28 52			ld a, (.dmark+1)  
521c 32 69 fe			ld (debug_mark+1),a  
521f 3a 29 52			ld a, (.dmark+2)  
5222 32 6a fe			ld (debug_mark+2),a  
5225 18 03			jr .pastdmark  
5227 ..			.dmark: db "DIR"  
522a f1			.pastdmark: pop af  
522b			endm  
# End of macro DMARK
522b						CALLMONITOR 
522b cd 6c fe			call debug_vector  
522e				endm  
# End of macro CALLMONITOR
522e					endif 
522e cd 17 05			call storage_get_block_0 
5231			 
5231 21 77 fa			ld hl, store_page     ; get current id count 
5234 46				ld b, (hl) 
5235 0e 00			ld c, 0    ; count of files   
5237					if DEBUG_FORTH_WORDS 
5237						DMARK "DI1" 
5237 f5				push af  
5238 3a 4c 52			ld a, (.dmark)  
523b 32 68 fe			ld (debug_mark),a  
523e 3a 4d 52			ld a, (.dmark+1)  
5241 32 69 fe			ld (debug_mark+1),a  
5244 3a 4e 52			ld a, (.dmark+2)  
5247 32 6a fe			ld (debug_mark+2),a  
524a 18 03			jr .pastdmark  
524c ..			.dmark: db "DI1"  
524f f1			.pastdmark: pop af  
5250			endm  
# End of macro DMARK
5250						CALLMONITOR 
5250 cd 6c fe			call debug_vector  
5253				endm  
# End of macro CALLMONITOR
5253					endif 
5253			 
5253				; check for empty drive 
5253			 
5253 3e 00			ld a, 0 
5255 b8				cp b 
5256 ca c4 52			jp z, .dirdone 
5259			 
5259				; for each of the current ids do a search for them and if found push to stack 
5259			 
5259 c5			.diritem:	push bc 
525a 21 40 00				ld hl, STORE_BLOCK_PHY 
525d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
525f 58					ld e,b 
5260			 
5260			;		if DEBUG_FORTH_WORDS 
5260			;			DMARK "DI2" 
5260			;			CALLMONITOR 
5260			;		endif 
5260			 
5260 cd 99 07				call storage_findnextid 
5263			 
5263			;		if DEBUG_FORTH_WORDS 
5263			;			DMARK "DI3" 
5263			;			CALLMONITOR 
5263			;		endif 
5263			 
5263					; if found hl will be non zero 
5263			 
5263 cd f9 0f				call ishlzero 
5266			;		ld a, l 
5266			;		add h 
5266			; 
5266			;		cp 0 
5266 28 59				jr z, .dirnotfound 
5268			 
5268					; increase count 
5268			 
5268 c1					pop bc	 
5269 0c					inc c 
526a c5					push bc 
526b					 
526b			 
526b					; get file header and push the file name 
526b			 
526b 11 77 fa				ld de, store_page 
526e cd 66 04				call storage_read_block 
5271			 
5271					; push file id to stack 
5271				 
5271 3a 77 fa				ld a, (store_page) 
5274 26 00				ld h, 0 
5276 6f					ld l, a 
5277 cd 13 21				call forth_push_numhl 
527a			 
527a					; push extent count to stack  
527a				 
527a 3a 79 fa				ld a, (store_page+2) 
527d 26 00				ld h, 0 
527f 6f					ld l, a 
5280 cd 13 21				call forth_push_numhl 
5283			 
5283					; push file name 
5283			 
5283 21 7a fa				ld hl, store_page+3 
5286					if DEBUG_FORTH_WORDS 
5286						DMARK "DI5" 
5286 f5				push af  
5287 3a 9b 52			ld a, (.dmark)  
528a 32 68 fe			ld (debug_mark),a  
528d 3a 9c 52			ld a, (.dmark+1)  
5290 32 69 fe			ld (debug_mark+1),a  
5293 3a 9d 52			ld a, (.dmark+2)  
5296 32 6a fe			ld (debug_mark+2),a  
5299 18 03			jr .pastdmark  
529b ..			.dmark: db "DI5"  
529e f1			.pastdmark: pop af  
529f			endm  
# End of macro DMARK
529f						CALLMONITOR 
529f cd 6c fe			call debug_vector  
52a2				endm  
# End of macro CALLMONITOR
52a2					endif 
52a2 cd 81 21				call forth_push_str 
52a5					if DEBUG_FORTH_WORDS 
52a5						DMARK "DI6" 
52a5 f5				push af  
52a6 3a ba 52			ld a, (.dmark)  
52a9 32 68 fe			ld (debug_mark),a  
52ac 3a bb 52			ld a, (.dmark+1)  
52af 32 69 fe			ld (debug_mark+1),a  
52b2 3a bc 52			ld a, (.dmark+2)  
52b5 32 6a fe			ld (debug_mark+2),a  
52b8 18 03			jr .pastdmark  
52ba ..			.dmark: db "DI6"  
52bd f1			.pastdmark: pop af  
52be			endm  
# End of macro DMARK
52be						CALLMONITOR 
52be cd 6c fe			call debug_vector  
52c1				endm  
# End of macro CALLMONITOR
52c1					endif 
52c1			.dirnotfound: 
52c1 c1					pop bc     
52c2 10 95				djnz .diritem 
52c4				 
52c4			.dirdone:	 
52c4					if DEBUG_FORTH_WORDS 
52c4						DMARK "DI7" 
52c4 f5				push af  
52c5 3a d9 52			ld a, (.dmark)  
52c8 32 68 fe			ld (debug_mark),a  
52cb 3a da 52			ld a, (.dmark+1)  
52ce 32 69 fe			ld (debug_mark+1),a  
52d1 3a db 52			ld a, (.dmark+2)  
52d4 32 6a fe			ld (debug_mark+2),a  
52d7 18 03			jr .pastdmark  
52d9 ..			.dmark: db "DI7"  
52dc f1			.pastdmark: pop af  
52dd			endm  
# End of macro DMARK
52dd						CALLMONITOR 
52dd cd 6c fe			call debug_vector  
52e0				endm  
# End of macro CALLMONITOR
52e0					endif 
52e0			 
52e0					; push a count of the dir items found 
52e0			 
52e0 26 00				ld h, 0 
52e2 69					ld l, c 
52e3 cd 13 21				call forth_push_numhl 
52e6			 
52e6					; push the bank label 
52e6			 
52e6 cd 17 05				call storage_get_block_0 
52e9			 
52e9				 
52e9 21 7a fa		 		ld hl, store_page+3 
52ec			 
52ec					if DEBUG_FORTH_WORDS 
52ec						DMARK "DI8" 
52ec f5				push af  
52ed 3a 01 53			ld a, (.dmark)  
52f0 32 68 fe			ld (debug_mark),a  
52f3 3a 02 53			ld a, (.dmark+1)  
52f6 32 69 fe			ld (debug_mark+1),a  
52f9 3a 03 53			ld a, (.dmark+2)  
52fc 32 6a fe			ld (debug_mark+2),a  
52ff 18 03			jr .pastdmark  
5301 ..			.dmark: db "DI8"  
5304 f1			.pastdmark: pop af  
5305			endm  
# End of macro DMARK
5305						CALLMONITOR 
5305 cd 6c fe			call debug_vector  
5308				endm  
# End of macro CALLMONITOR
5308					endif 
5308 cd 81 21				call forth_push_str 
530b			 
530b			 
530b				 
530b					NEXTW 
530b c3 c0 24			jp macro_next 
530e				endm 
# End of macro NEXTW
530e			.SAVE: 
530e			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
530e			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
530e			;		NEXTW 
530e			;.LOAD: 
530e			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
530e			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
530e			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
530e			;; > > The LOAD command can not be used in any user words or compound lines. 
530e			; 
530e			;		; store_openext use it. If zero it is EOF 
530e			; 
530e			;		; read block from current stream id 
530e			;		; if the block does not contain zero term keep reading blocks until zero found 
530e			;		; push the block to stack 
530e			;		; save the block id to stream 
530e			; 
530e			; 
530e			;		FORTH_DSP_VALUEHL 
530e			; 
530e			;;		push hl 
530e			; 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LOA" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			;		FORTH_DSP_POP 
530e			; 
530e			;;		pop hl 
530e			; 
530e			;		ld h, l 
530e			;		ld l, 0 
530e			; 
530e			;		push hl     ; stack holds current file id and extent to work with 
530e			; 
530e			; 
530e			;		ld de, store_page      ; get block zero of file 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LO0" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			;		call storage_read 
530e			; 
530e			;		ld a, (store_page+2)    ; max extents for this file 
530e			;		ld  (store_openmaxext),a   ; get our limit 
530e			; 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LOE" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			; 
530e			;; TODO dont know why max extents are not present 
530e			;;		cp 0 
530e			;;		jp z, .loadeof     ; dont read past eof 
530e			; 
530e			;;		ld a, 1   ; start from the head of the file 
530e			; 
530e			;.loadline:	pop hl 
530e			;		inc hl 
530e			;		ld  a, (store_openmaxext)   ; get our limit 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LOx" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			;		inc a 
530e			;		cp l 
530e			;		jp z, .loadeof 
530e			;		push hl    ; save current extent 
530e			; 
530e			;		ld de, store_page 
530e			; 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LO1" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			;		call storage_read 
530e			; 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LO2" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			;	call ishlzero 
530e			;	ld a, l 
530e			;	add h 
530e			;	cp 0 
530e			;	jr z, .loadeof 
530e			; 
530e			;	; not eof so hl should point to data to exec 
530e			; 
530e			;	; will need to add the FORTH_END_BUFFER flag 
530e			 ; 
530e			;	ld hl, store_page+2 
530e			;	ld bc, 255 
530e			;	ld a, 0 
530e			;	cpir 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LOt" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			;	dec hl 
530e			;	ld a, ' ' 
530e			;	ld (hl), a 
530e			;	inc hl 
530e			;	ld (hl), a 
530e			;	inc hl 
530e			;	ld (hl), a 
530e			;	inc hl 
530e			;	ld a, FORTH_END_BUFFER 
530e			;	ld (hl), a 
530e			; 
530e			;	; TODO handle more than a single block read 
530e			; 
530e			; 
530e			;	ld hl, store_page+2 
530e			; 
530e			;	ld (os_tok_ptr), hl 
530e			; 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LO3" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			; 
530e			;	call forthparse 
530e			;	call forthexec 
530e			;	call forthexec_cleanup 
530e			; 
530e			;	; go to next extent 
530e			; 
530e			;	; get next block  or mark as eof 
530e			;	jp .loadline 
530e			; 
530e			; 
530e			; 
530e			;	       NEXTW 
530e			;.loadeof:	ld a, 0 
530e			;		ld (store_openext), a 
530e			; 
530e			;	if DEBUG_STORESE 
530e			;		DMARK "LOF" 
530e			;		CALLMONITOR 
530e			;	endif 
530e			;		ret 
530e			;		;NEXTW 
530e			;.BSAVE:   
530e			; 
530e			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
530e			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
530e			;		NEXTW 
530e			;.BLOAD: 
530e			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
530e			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
530e			;		NEXTW 
530e			;;;; counter gap 
530e			 
530e			 
530e			.SEO: 
530e				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
530e 64				db WORD_SYS_CORE+80             
530f 2d 53			dw .SEI            
5311 04				db 3 + 1 
5312 .. 00			db "SEO",0              
5316				endm 
# End of macro CWHEAD
5316			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5316			 
5316					; get port 
5316			 
5316					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5316 cd 0a 23			call macro_dsp_valuehl 
5319				endm 
# End of macro FORTH_DSP_VALUEHL
5319			 
5319 e5					push hl    ; u2 - byte 
531a			 
531a					; destroy value TOS 
531a			 
531a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
531a cd c2 23			call macro_forth_dsp_pop 
531d				endm 
# End of macro FORTH_DSP_POP
531d			 
531d					; get byte to send 
531d			 
531d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
531d cd 0a 23			call macro_dsp_valuehl 
5320				endm 
# End of macro FORTH_DSP_VALUEHL
5320			 
5320 e5					push hl    ; u1 - addr 
5321			 
5321					; destroy value TOS 
5321			 
5321					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5321 cd c2 23			call macro_forth_dsp_pop 
5324				endm 
# End of macro FORTH_DSP_POP
5324			 
5324					; one value on hl get other one back 
5324			 
5324 d1					pop de   ; u1 - byte 
5325			 
5325 e1					pop hl   ; u2 - addr 
5326			 
5326					; TODO Send SPI byte 
5326			 
5326			 
5326 7b					ld a, e 
5327 cd 6b 02				call se_writebyte 
532a			 
532a					 
532a			 
532a					NEXTW 
532a c3 c0 24			jp macro_next 
532d				endm 
# End of macro NEXTW
532d			 
532d			.SEI: 
532d				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
532d 65				db WORD_SYS_CORE+81             
532e 47 53			dw .SFREE            
5330 04				db 3 + 1 
5331 .. 00			db "SEI",0              
5335				endm 
# End of macro CWHEAD
5335			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5335			 
5335					; get port 
5335			 
5335					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5335 cd 0a 23			call macro_dsp_valuehl 
5338				endm 
# End of macro FORTH_DSP_VALUEHL
5338			 
5338			;		push hl 
5338			 
5338					; destroy value TOS 
5338			 
5338					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5338 cd c2 23			call macro_forth_dsp_pop 
533b				endm 
# End of macro FORTH_DSP_POP
533b			 
533b					; one value on hl get other one back 
533b			 
533b			;		pop hl 
533b			 
533b			 
533b					; TODO Get SPI byte 
533b			 
533b cd 0d 03				call se_readbyte 
533e			 
533e 26 00				ld h, 0 
5340 6f					ld l, a 
5341 cd 13 21				call forth_push_numhl 
5344			 
5344					NEXTW 
5344 c3 c0 24			jp macro_next 
5347				endm 
# End of macro NEXTW
5347			 
5347			.SFREE: 
5347				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5347 67				db WORD_SYS_CORE+83             
5348 76 53			dw .SIZE            
534a 06				db 5 + 1 
534b .. 00			db "FFREE",0              
5351				endm 
# End of macro CWHEAD
5351			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5351			; | | Compatible with PicoSPINet  
5351					if DEBUG_FORTH_WORDS_KEY 
5351						DMARK "FFR" 
5351 f5				push af  
5352 3a 66 53			ld a, (.dmark)  
5355 32 68 fe			ld (debug_mark),a  
5358 3a 67 53			ld a, (.dmark+1)  
535b 32 69 fe			ld (debug_mark+1),a  
535e 3a 68 53			ld a, (.dmark+2)  
5361 32 6a fe			ld (debug_mark+2),a  
5364 18 03			jr .pastdmark  
5366 ..			.dmark: db "FFR"  
5369 f1			.pastdmark: pop af  
536a			endm  
# End of macro DMARK
536a						CALLMONITOR 
536a cd 6c fe			call debug_vector  
536d				endm  
# End of macro CALLMONITOR
536d					endif 
536d			 
536d cd 33 08				call storage_freeblocks 
5370			 
5370 cd 13 21				call forth_push_numhl 
5373			 
5373				       NEXTW 
5373 c3 c0 24			jp macro_next 
5376				endm 
# End of macro NEXTW
5376			.SIZE: 
5376				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5376 67				db WORD_SYS_CORE+83             
5377 aa 53			dw .CREATE            
5379 05				db 4 + 1 
537a .. 00			db "SIZE",0              
537f				endm 
# End of macro CWHEAD
537f			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
537f			; | | Compatible with PicoSPINet  
537f					if DEBUG_FORTH_WORDS_KEY 
537f						DMARK "SIZ" 
537f f5				push af  
5380 3a 94 53			ld a, (.dmark)  
5383 32 68 fe			ld (debug_mark),a  
5386 3a 95 53			ld a, (.dmark+1)  
5389 32 69 fe			ld (debug_mark+1),a  
538c 3a 96 53			ld a, (.dmark+2)  
538f 32 6a fe			ld (debug_mark+2),a  
5392 18 03			jr .pastdmark  
5394 ..			.dmark: db "SIZ"  
5397 f1			.pastdmark: pop af  
5398			endm  
# End of macro DMARK
5398						CALLMONITOR 
5398 cd 6c fe			call debug_vector  
539b				endm  
# End of macro CALLMONITOR
539b					endif 
539b			 
539b					FORTH_DSP_VALUEHL 
539b cd 0a 23			call macro_dsp_valuehl 
539e				endm 
# End of macro FORTH_DSP_VALUEHL
539e			;		push hl 
539e					FORTH_DSP_POP 
539e cd c2 23			call macro_forth_dsp_pop 
53a1				endm 
# End of macro FORTH_DSP_POP
53a1			;		pop hl 
53a1 cd 95 04				call storage_file_size 
53a4			 
53a4 cd 13 21				call forth_push_numhl 
53a7			  
53a7			 
53a7				       NEXTW 
53a7 c3 c0 24			jp macro_next 
53aa				endm 
# End of macro NEXTW
53aa			 
53aa			.CREATE: 
53aa				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53aa 68				db WORD_SYS_CORE+84             
53ab 18 54			dw .APPEND            
53ad 07				db 6 + 1 
53ae .. 00			db "CREATE",0              
53b5				endm 
# End of macro CWHEAD
53b5			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
53b5			; | | e.g.  
53b5			; | | TestProgram CREATE 
53b5			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
53b5			; | |  
53b5			; | | Max file IDs are 255. 
53b5			; | |  
53b5			; | | Compatible with PicoSPINet  
53b5					 
53b5					if DEBUG_FORTH_WORDS_KEY 
53b5						DMARK "CRT" 
53b5 f5				push af  
53b6 3a ca 53			ld a, (.dmark)  
53b9 32 68 fe			ld (debug_mark),a  
53bc 3a cb 53			ld a, (.dmark+1)  
53bf 32 69 fe			ld (debug_mark+1),a  
53c2 3a cc 53			ld a, (.dmark+2)  
53c5 32 6a fe			ld (debug_mark+2),a  
53c8 18 03			jr .pastdmark  
53ca ..			.dmark: db "CRT"  
53cd f1			.pastdmark: pop af  
53ce			endm  
# End of macro DMARK
53ce						CALLMONITOR 
53ce cd 6c fe			call debug_vector  
53d1				endm  
# End of macro CALLMONITOR
53d1					endif 
53d1			;		call storage_get_block_0 
53d1			 
53d1					; TODO pop hl 
53d1			 
53d1					;v5 FORTH_DSP_VALUE 
53d1					FORTH_DSP_VALUE 
53d1 cd f3 22			call macro_forth_dsp_value 
53d4				endm 
# End of macro FORTH_DSP_VALUE
53d4			 
53d4				if DEBUG_STORESE 
53d4					DMARK "CR1" 
53d4 f5				push af  
53d5 3a e9 53			ld a, (.dmark)  
53d8 32 68 fe			ld (debug_mark),a  
53db 3a ea 53			ld a, (.dmark+1)  
53de 32 69 fe			ld (debug_mark+1),a  
53e1 3a eb 53			ld a, (.dmark+2)  
53e4 32 6a fe			ld (debug_mark+2),a  
53e7 18 03			jr .pastdmark  
53e9 ..			.dmark: db "CR1"  
53ec f1			.pastdmark: pop af  
53ed			endm  
# End of macro DMARK
53ed					CALLMONITOR 
53ed cd 6c fe			call debug_vector  
53f0				endm  
# End of macro CALLMONITOR
53f0				endif 
53f0			;		push hl 
53f0			;		FORTH_DSP_POP 
53f0			;		pop hl 
53f0			 
53f0			;		inc hl   ; move past the type marker 
53f0			 
53f0 cd 69 08				call storage_create 
53f3			 
53f3				if DEBUG_STORESE 
53f3					DMARK "CT1" 
53f3 f5				push af  
53f4 3a 08 54			ld a, (.dmark)  
53f7 32 68 fe			ld (debug_mark),a  
53fa 3a 09 54			ld a, (.dmark+1)  
53fd 32 69 fe			ld (debug_mark+1),a  
5400 3a 0a 54			ld a, (.dmark+2)  
5403 32 6a fe			ld (debug_mark+2),a  
5406 18 03			jr .pastdmark  
5408 ..			.dmark: db "CT1"  
540b f1			.pastdmark: pop af  
540c			endm  
# End of macro DMARK
540c					CALLMONITOR 
540c cd 6c fe			call debug_vector  
540f				endm  
# End of macro CALLMONITOR
540f				endif 
540f			;		push hl 
540f					FORTH_DSP_POP 
540f cd c2 23			call macro_forth_dsp_pop 
5412				endm 
# End of macro FORTH_DSP_POP
5412			;		pop hl 
5412					; push file id to stack 
5412 cd 13 21				call forth_push_numhl 
5415			 
5415			 
5415			 
5415				       NEXTW 
5415 c3 c0 24			jp macro_next 
5418				endm 
# End of macro NEXTW
5418			 
5418			.APPEND: 
5418				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5418 69				db WORD_SYS_CORE+85             
5419 a9 54			dw .SDEL            
541b 07				db 6 + 1 
541c .. 00			db "APPEND",0              
5423				endm 
# End of macro CWHEAD
5423			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5423			; | | e.g. 
5423			; | | Test CREATE      -> $01 
5423			; | | "A string to add to file" $01 APPEND 
5423			; | |  
5423			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5423			; | | Compatible with PicoSPINet  
5423					if DEBUG_FORTH_WORDS_KEY 
5423						DMARK "APP" 
5423 f5				push af  
5424 3a 38 54			ld a, (.dmark)  
5427 32 68 fe			ld (debug_mark),a  
542a 3a 39 54			ld a, (.dmark+1)  
542d 32 69 fe			ld (debug_mark+1),a  
5430 3a 3a 54			ld a, (.dmark+2)  
5433 32 6a fe			ld (debug_mark+2),a  
5436 18 03			jr .pastdmark  
5438 ..			.dmark: db "APP"  
543b f1			.pastdmark: pop af  
543c			endm  
# End of macro DMARK
543c						CALLMONITOR 
543c cd 6c fe			call debug_vector  
543f				endm  
# End of macro CALLMONITOR
543f					endif 
543f			 
543f					FORTH_DSP_VALUEHL 
543f cd 0a 23			call macro_dsp_valuehl 
5442				endm 
# End of macro FORTH_DSP_VALUEHL
5442 e5					push hl 	; save file id 
5443			 
5443				if DEBUG_STORESE 
5443					DMARK "AP1" 
5443 f5				push af  
5444 3a 58 54			ld a, (.dmark)  
5447 32 68 fe			ld (debug_mark),a  
544a 3a 59 54			ld a, (.dmark+1)  
544d 32 69 fe			ld (debug_mark+1),a  
5450 3a 5a 54			ld a, (.dmark+2)  
5453 32 6a fe			ld (debug_mark+2),a  
5456 18 03			jr .pastdmark  
5458 ..			.dmark: db "AP1"  
545b f1			.pastdmark: pop af  
545c			endm  
# End of macro DMARK
545c					CALLMONITOR 
545c cd 6c fe			call debug_vector  
545f				endm  
# End of macro CALLMONITOR
545f				endif 
545f					FORTH_DSP_POP 
545f cd c2 23			call macro_forth_dsp_pop 
5462				endm 
# End of macro FORTH_DSP_POP
5462			 
5462					FORTH_DSP_VALUEHL 
5462 cd 0a 23			call macro_dsp_valuehl 
5465				endm 
# End of macro FORTH_DSP_VALUEHL
5465					;v5 FORTH_DSP_VALUE 
5465 e5					push hl 	; save ptr to string to save 
5466			 
5466				if DEBUG_STORESE 
5466					DMARK "AP1" 
5466 f5				push af  
5467 3a 7b 54			ld a, (.dmark)  
546a 32 68 fe			ld (debug_mark),a  
546d 3a 7c 54			ld a, (.dmark+1)  
5470 32 69 fe			ld (debug_mark+1),a  
5473 3a 7d 54			ld a, (.dmark+2)  
5476 32 6a fe			ld (debug_mark+2),a  
5479 18 03			jr .pastdmark  
547b ..			.dmark: db "AP1"  
547e f1			.pastdmark: pop af  
547f			endm  
# End of macro DMARK
547f					CALLMONITOR 
547f cd 6c fe			call debug_vector  
5482				endm  
# End of macro CALLMONITOR
5482				endif 
5482					FORTH_DSP_POP 
5482 cd c2 23			call macro_forth_dsp_pop 
5485				endm 
# End of macro FORTH_DSP_POP
5485			 
5485 d1					pop de 
5486 e1					pop hl 
5487				if DEBUG_STORESE 
5487					DMARK "AP2" 
5487 f5				push af  
5488 3a 9c 54			ld a, (.dmark)  
548b 32 68 fe			ld (debug_mark),a  
548e 3a 9d 54			ld a, (.dmark+1)  
5491 32 69 fe			ld (debug_mark+1),a  
5494 3a 9e 54			ld a, (.dmark+2)  
5497 32 6a fe			ld (debug_mark+2),a  
549a 18 03			jr .pastdmark  
549c ..			.dmark: db "AP2"  
549f f1			.pastdmark: pop af  
54a0			endm  
# End of macro DMARK
54a0					CALLMONITOR 
54a0 cd 6c fe			call debug_vector  
54a3				endm  
# End of macro CALLMONITOR
54a3				endif 
54a3					;inc de ; skip var type indicator 
54a3			 
54a3					; TODO how to append numerics???? 
54a3			 
54a3 cd 56 0b				call storage_append		 
54a6			 
54a6				       NEXTW 
54a6 c3 c0 24			jp macro_next 
54a9				endm 
# End of macro NEXTW
54a9			.SDEL: 
54a9				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54a9 6a				db WORD_SYS_CORE+86             
54aa f5 54			dw .OPEN            
54ac 05				db 4 + 1 
54ad .. 00			db "ERA",0              
54b1				endm 
# End of macro CWHEAD
54b1			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
54b1			; | | Compatible with PicoSPINet  
54b1					FORTH_DSP_VALUEHL 
54b1 cd 0a 23			call macro_dsp_valuehl 
54b4				endm 
# End of macro FORTH_DSP_VALUEHL
54b4			;		push hl 	; save file id 
54b4			 
54b4					if DEBUG_FORTH_WORDS_KEY 
54b4						DMARK "ERA" 
54b4 f5				push af  
54b5 3a c9 54			ld a, (.dmark)  
54b8 32 68 fe			ld (debug_mark),a  
54bb 3a ca 54			ld a, (.dmark+1)  
54be 32 69 fe			ld (debug_mark+1),a  
54c1 3a cb 54			ld a, (.dmark+2)  
54c4 32 6a fe			ld (debug_mark+2),a  
54c7 18 03			jr .pastdmark  
54c9 ..			.dmark: db "ERA"  
54cc f1			.pastdmark: pop af  
54cd			endm  
# End of macro DMARK
54cd						CALLMONITOR 
54cd cd 6c fe			call debug_vector  
54d0				endm  
# End of macro CALLMONITOR
54d0					endif 
54d0				if DEBUG_STORESE 
54d0					DMARK "ER1" 
54d0 f5				push af  
54d1 3a e5 54			ld a, (.dmark)  
54d4 32 68 fe			ld (debug_mark),a  
54d7 3a e6 54			ld a, (.dmark+1)  
54da 32 69 fe			ld (debug_mark+1),a  
54dd 3a e7 54			ld a, (.dmark+2)  
54e0 32 6a fe			ld (debug_mark+2),a  
54e3 18 03			jr .pastdmark  
54e5 ..			.dmark: db "ER1"  
54e8 f1			.pastdmark: pop af  
54e9			endm  
# End of macro DMARK
54e9					CALLMONITOR 
54e9 cd 6c fe			call debug_vector  
54ec				endm  
# End of macro CALLMONITOR
54ec				endif 
54ec					FORTH_DSP_POP 
54ec cd c2 23			call macro_forth_dsp_pop 
54ef				endm 
# End of macro FORTH_DSP_POP
54ef			 
54ef			;		pop hl 
54ef			 
54ef cd a8 06				call storage_erase 
54f2				       NEXTW 
54f2 c3 c0 24			jp macro_next 
54f5				endm 
# End of macro NEXTW
54f5			 
54f5			.OPEN: 
54f5				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
54f5 6b				db WORD_SYS_CORE+87             
54f6 89 55			dw .READ            
54f8 05				db 4 + 1 
54f9 .. 00			db "OPEN",0              
54fe				endm 
# End of macro CWHEAD
54fe			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
54fe			; | | e.g. 
54fe			; | | $01 OPEN $01 DO $01 READ . LOOP 
54fe			; | | 
54fe			; | | Will return with 255 blocks if the file does not exist 
54fe			; | | Compatible with PicoSPINet  
54fe			 
54fe					if DEBUG_FORTH_WORDS_KEY 
54fe						DMARK "OPN" 
54fe f5				push af  
54ff 3a 13 55			ld a, (.dmark)  
5502 32 68 fe			ld (debug_mark),a  
5505 3a 14 55			ld a, (.dmark+1)  
5508 32 69 fe			ld (debug_mark+1),a  
550b 3a 15 55			ld a, (.dmark+2)  
550e 32 6a fe			ld (debug_mark+2),a  
5511 18 03			jr .pastdmark  
5513 ..			.dmark: db "OPN"  
5516 f1			.pastdmark: pop af  
5517			endm  
# End of macro DMARK
5517						CALLMONITOR 
5517 cd 6c fe			call debug_vector  
551a				endm  
# End of macro CALLMONITOR
551a					endif 
551a					; TODO handle multiple file opens 
551a			 
551a 3e 01			       	ld a, 1 
551c 32 67 fa				ld (store_openext), a 
551f			 
551f					; get max extents for this file 
551f				 
551f								 
551f					FORTH_DSP_VALUEHL 
551f cd 0a 23			call macro_dsp_valuehl 
5522				endm 
# End of macro FORTH_DSP_VALUEHL
5522			 
5522 65					ld h, l 
5523 2e 00				ld l, 0 
5525			 
5525					; store file id 
5525			 
5525 7c					ld a, h 
5526 32 64 fa				ld (store_filecache), a 
5529			 
5529				if DEBUG_STORESE 
5529					DMARK "OPN" 
5529 f5				push af  
552a 3a 3e 55			ld a, (.dmark)  
552d 32 68 fe			ld (debug_mark),a  
5530 3a 3f 55			ld a, (.dmark+1)  
5533 32 69 fe			ld (debug_mark+1),a  
5536 3a 40 55			ld a, (.dmark+2)  
5539 32 6a fe			ld (debug_mark+2),a  
553c 18 03			jr .pastdmark  
553e ..			.dmark: db "OPN"  
5541 f1			.pastdmark: pop af  
5542			endm  
# End of macro DMARK
5542					CALLMONITOR 
5542 cd 6c fe			call debug_vector  
5545				endm  
# End of macro CALLMONITOR
5545				endif 
5545			;		push hl 
5545					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5545 cd c2 23			call macro_forth_dsp_pop 
5548				endm 
# End of macro FORTH_DSP_POP
5548			;		pop hl 
5548						 
5548 11 77 fa				ld de, store_page      ; get block zero of file 
554b cd bf 09				call storage_read 
554e cd f9 0f			call ishlzero 
5551 20 04			jr nz, .opfound 
5553			 
5553				; file does not exist so indicate with 255 extents in use 
5553			 
5553 3e ff			ld a, 255 
5555 18 29			jr .skipopeneof 
5557			 
5557			 
5557			.opfound: 
5557			 
5557			 
5557 3a 79 fa				ld a, (store_page+2)    ; max extents for this file 
555a 32 66 fa				ld  (store_openmaxext), a   ; get our limit and push 
555d					 
555d				if DEBUG_STORESE 
555d					DMARK "OPx" 
555d f5				push af  
555e 3a 72 55			ld a, (.dmark)  
5561 32 68 fe			ld (debug_mark),a  
5564 3a 73 55			ld a, (.dmark+1)  
5567 32 69 fe			ld (debug_mark+1),a  
556a 3a 74 55			ld a, (.dmark+2)  
556d 32 6a fe			ld (debug_mark+2),a  
5570 18 03			jr .pastdmark  
5572 ..			.dmark: db "OPx"  
5575 f1			.pastdmark: pop af  
5576			endm  
# End of macro DMARK
5576					CALLMONITOR 
5576 cd 6c fe			call debug_vector  
5579				endm  
# End of macro CALLMONITOR
5579				endif 
5579 fe 00				cp 0 
557b 20 03				jr nz, .skipopeneof 
557d					; have opened an empty file 
557d					 
557d 32 67 fa				ld (store_openext), a 
5580			 
5580			.skipopeneof: 
5580			 
5580 6f					ld l, a 
5581 26 00				ld h, 0 
5583 cd 13 21				call forth_push_numhl 
5586			 
5586			 
5586				       NEXTW 
5586 c3 c0 24			jp macro_next 
5589				endm 
# End of macro NEXTW
5589			.READ: 
5589				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5589 6c				db WORD_SYS_CORE+88             
558a b3 56			dw .EOF            
558c 05				db 4 + 1 
558d .. 00			db "READ",0              
5592				endm 
# End of macro CWHEAD
5592			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5592			; | | e.g. 
5592			; | | $01 OPEN $01 DO READ . LOOP 
5592			; | | 
5592			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5592			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5592			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5592			; | | two bytes contain the file id and extent. 
5592			; | |  
5592			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5592			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5592			; | | Compatible with PicoSPINet  
5592			 
5592					if DEBUG_FORTH_WORDS_KEY 
5592						DMARK "REA" 
5592 f5				push af  
5593 3a a7 55			ld a, (.dmark)  
5596 32 68 fe			ld (debug_mark),a  
5599 3a a8 55			ld a, (.dmark+1)  
559c 32 69 fe			ld (debug_mark+1),a  
559f 3a a9 55			ld a, (.dmark+2)  
55a2 32 6a fe			ld (debug_mark+2),a  
55a5 18 03			jr .pastdmark  
55a7 ..			.dmark: db "REA"  
55aa f1			.pastdmark: pop af  
55ab			endm  
# End of macro DMARK
55ab						CALLMONITOR 
55ab cd 6c fe			call debug_vector  
55ae				endm  
# End of macro CALLMONITOR
55ae					endif 
55ae					; store_openext use it. If zero it is EOF 
55ae			 
55ae					; read block from current stream id 
55ae					; if the block does not contain zero term keep reading blocks until zero found 
55ae					; push the block to stack 
55ae					; save the block id to stream 
55ae			 
55ae			 
55ae cd e0 56				call .testeof 
55b1 3e 01				ld a, 1 
55b3 bd					cp l 
55b4 ca 8f 56				jp z, .ateof 
55b7			 
55b7			 
55b7			;		FORTH_DSP_VALUEHL 
55b7			 
55b7			;		push hl 
55b7			 
55b7			;	if DEBUG_STORESE 
55b7			;		DMARK "REA" 
55b7			;		CALLMONITOR 
55b7			;	endif 
55b7			;		FORTH_DSP_POP 
55b7			 
55b7			;		pop hl 
55b7				 
55b7 3a 64 fa				ld a, (store_filecache) 
55ba 67					ld h,a 
55bb			 
55bb 3a 67 fa				ld a, (store_openext) 
55be 6f					ld l, a 
55bf					 
55bf fe 00				cp 0 
55c1 ca 8f 56				jp z, .ateof     ; dont read past eof 
55c4			 
55c4 cd a2 0c				call storage_clear_page 
55c7			 
55c7 11 77 fa				ld de, store_page 
55ca				if DEBUG_STORESE 
55ca					DMARK "RE1" 
55ca f5				push af  
55cb 3a df 55			ld a, (.dmark)  
55ce 32 68 fe			ld (debug_mark),a  
55d1 3a e0 55			ld a, (.dmark+1)  
55d4 32 69 fe			ld (debug_mark+1),a  
55d7 3a e1 55			ld a, (.dmark+2)  
55da 32 6a fe			ld (debug_mark+2),a  
55dd 18 03			jr .pastdmark  
55df ..			.dmark: db "RE1"  
55e2 f1			.pastdmark: pop af  
55e3			endm  
# End of macro DMARK
55e3					CALLMONITOR 
55e3 cd 6c fe			call debug_vector  
55e6				endm  
# End of macro CALLMONITOR
55e6				endif 
55e6 cd bf 09				call storage_read 
55e9			 
55e9				if DEBUG_STORESE 
55e9					DMARK "RE2" 
55e9 f5				push af  
55ea 3a fe 55			ld a, (.dmark)  
55ed 32 68 fe			ld (debug_mark),a  
55f0 3a ff 55			ld a, (.dmark+1)  
55f3 32 69 fe			ld (debug_mark+1),a  
55f6 3a 00 56			ld a, (.dmark+2)  
55f9 32 6a fe			ld (debug_mark+2),a  
55fc 18 03			jr .pastdmark  
55fe ..			.dmark: db "RE2"  
5601 f1			.pastdmark: pop af  
5602			endm  
# End of macro DMARK
5602					CALLMONITOR 
5602 cd 6c fe			call debug_vector  
5605				endm  
# End of macro CALLMONITOR
5605				endif 
5605 cd f9 0f			call ishlzero 
5608			;	ld a, l 
5608			;	add h 
5608			;	cp 0 
5608 ca 8f 56			jp z, .readeof 
560b			 
560b				; not eof so hl should point to data to push to stack 
560b			 
560b				if DEBUG_STORESE 
560b					DMARK "RE3" 
560b f5				push af  
560c 3a 20 56			ld a, (.dmark)  
560f 32 68 fe			ld (debug_mark),a  
5612 3a 21 56			ld a, (.dmark+1)  
5615 32 69 fe			ld (debug_mark+1),a  
5618 3a 22 56			ld a, (.dmark+2)  
561b 32 6a fe			ld (debug_mark+2),a  
561e 18 03			jr .pastdmark  
5620 ..			.dmark: db "RE3"  
5623 f1			.pastdmark: pop af  
5624			endm  
# End of macro DMARK
5624					CALLMONITOR 
5624 cd 6c fe			call debug_vector  
5627				endm  
# End of macro CALLMONITOR
5627				endif 
5627 cd 81 21			call forth_push_str 
562a			 
562a				if DEBUG_STORESE 
562a					DMARK "RE4" 
562a f5				push af  
562b 3a 3f 56			ld a, (.dmark)  
562e 32 68 fe			ld (debug_mark),a  
5631 3a 40 56			ld a, (.dmark+1)  
5634 32 69 fe			ld (debug_mark+1),a  
5637 3a 41 56			ld a, (.dmark+2)  
563a 32 6a fe			ld (debug_mark+2),a  
563d 18 03			jr .pastdmark  
563f ..			.dmark: db "RE4"  
5642 f1			.pastdmark: pop af  
5643			endm  
# End of macro DMARK
5643					CALLMONITOR 
5643 cd 6c fe			call debug_vector  
5646				endm  
# End of macro CALLMONITOR
5646				endif 
5646				; get next block  or mark as eof 
5646			 
5646 3a 66 fa			ld a, (store_openmaxext)   ; get our limit 
5649 4f				ld c, a	 
564a 3a 67 fa			ld a, (store_openext) 
564d			 
564d				if DEBUG_STORESE 
564d					DMARK "RE5" 
564d f5				push af  
564e 3a 62 56			ld a, (.dmark)  
5651 32 68 fe			ld (debug_mark),a  
5654 3a 63 56			ld a, (.dmark+1)  
5657 32 69 fe			ld (debug_mark+1),a  
565a 3a 64 56			ld a, (.dmark+2)  
565d 32 6a fe			ld (debug_mark+2),a  
5660 18 03			jr .pastdmark  
5662 ..			.dmark: db "RE5"  
5665 f1			.pastdmark: pop af  
5666			endm  
# End of macro DMARK
5666					CALLMONITOR 
5666 cd 6c fe			call debug_vector  
5669				endm  
# End of macro CALLMONITOR
5669				endif 
5669 b9				cp c 
566a 28 23			jr z, .readeof     ; at last extent 
566c			 
566c 3c					inc a 
566d 32 67 fa				ld (store_openext), a 
5670			 
5670				if DEBUG_STORESE 
5670					DMARK "RE6" 
5670 f5				push af  
5671 3a 85 56			ld a, (.dmark)  
5674 32 68 fe			ld (debug_mark),a  
5677 3a 86 56			ld a, (.dmark+1)  
567a 32 69 fe			ld (debug_mark+1),a  
567d 3a 87 56			ld a, (.dmark+2)  
5680 32 6a fe			ld (debug_mark+2),a  
5683 18 03			jr .pastdmark  
5685 ..			.dmark: db "RE6"  
5688 f1			.pastdmark: pop af  
5689			endm  
# End of macro DMARK
5689					CALLMONITOR 
5689 cd 6c fe			call debug_vector  
568c				endm  
# End of macro CALLMONITOR
568c				endif 
568c			 
568c			 
568c				       NEXTW 
568c c3 c0 24			jp macro_next 
568f				endm 
# End of macro NEXTW
568f			.ateof: 
568f				;	ld hl, .showeof 
568f				;	call forth_push_str 
568f 3e 00		.readeof:	ld a, 0 
5691 32 67 fa				ld (store_openext), a 
5694			 
5694					 
5694				if DEBUG_STORESE 
5694					DMARK "REF" 
5694 f5				push af  
5695 3a a9 56			ld a, (.dmark)  
5698 32 68 fe			ld (debug_mark),a  
569b 3a aa 56			ld a, (.dmark+1)  
569e 32 69 fe			ld (debug_mark+1),a  
56a1 3a ab 56			ld a, (.dmark+2)  
56a4 32 6a fe			ld (debug_mark+2),a  
56a7 18 03			jr .pastdmark  
56a9 ..			.dmark: db "REF"  
56ac f1			.pastdmark: pop af  
56ad			endm  
# End of macro DMARK
56ad					CALLMONITOR 
56ad cd 6c fe			call debug_vector  
56b0				endm  
# End of macro CALLMONITOR
56b0				endif 
56b0				       NEXTW 
56b0 c3 c0 24			jp macro_next 
56b3				endm 
# End of macro NEXTW
56b3			 
56b3			;.showeof:   db "eof", 0 
56b3			 
56b3			 
56b3			.EOF: 
56b3				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
56b3 6d				db WORD_SYS_CORE+89             
56b4 f5 56			dw .FORMAT            
56b6 04				db 3 + 1 
56b7 .. 00			db "EOF",0              
56bb				endm 
# End of macro CWHEAD
56bb			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
56bb			; | | e.g. 
56bb			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
56bb			; | | Compatible with PicoSPINet  
56bb					; TODO if current block id for stream is zero then push true else false 
56bb			 
56bb					if DEBUG_FORTH_WORDS_KEY 
56bb						DMARK "EOF" 
56bb f5				push af  
56bc 3a d0 56			ld a, (.dmark)  
56bf 32 68 fe			ld (debug_mark),a  
56c2 3a d1 56			ld a, (.dmark+1)  
56c5 32 69 fe			ld (debug_mark+1),a  
56c8 3a d2 56			ld a, (.dmark+2)  
56cb 32 6a fe			ld (debug_mark+2),a  
56ce 18 03			jr .pastdmark  
56d0 ..			.dmark: db "EOF"  
56d3 f1			.pastdmark: pop af  
56d4			endm  
# End of macro DMARK
56d4						CALLMONITOR 
56d4 cd 6c fe			call debug_vector  
56d7				endm  
# End of macro CALLMONITOR
56d7					endif 
56d7			 
56d7					; TODO handlue multiple file streams 
56d7			 
56d7			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56d7 cd e0 56				call .testeof 
56da cd 13 21				call forth_push_numhl 
56dd			 
56dd			 
56dd				       NEXTW 
56dd c3 c0 24			jp macro_next 
56e0				endm 
# End of macro NEXTW
56e0			 
56e0			.testeof: 
56e0 2e 01				ld l, 1 
56e2 3a 66 fa				ld a, (store_openmaxext) 
56e5 fe 00				cp 0 
56e7 28 09				jr  z, .eofdone   ; empty file 
56e9 3a 67 fa				ld a, (store_openext) 
56ec fe 00				cp 0 
56ee 28 02				jr  z, .eofdone 
56f0 2e 00				ld l, 0 
56f2 26 00		.eofdone:	ld h, 0 
56f4 c9					ret 
56f5			 
56f5			 
56f5			 
56f5			 
56f5			.FORMAT: 
56f5				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
56f5 6d				db WORD_SYS_CORE+89             
56f6 46 57			dw .LABEL            
56f8 07				db 6 + 1 
56f9 .. 00			db "FORMAT",0              
5700				endm 
# End of macro CWHEAD
5700			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5700			; | | Compatible with PicoSPINet  
5700					; TODO if current block id for stream is zero then push true else false 
5700				 
5700				if DEBUG_STORESE 
5700					DMARK "FOR" 
5700 f5				push af  
5701 3a 15 57			ld a, (.dmark)  
5704 32 68 fe			ld (debug_mark),a  
5707 3a 16 57			ld a, (.dmark+1)  
570a 32 69 fe			ld (debug_mark+1),a  
570d 3a 17 57			ld a, (.dmark+2)  
5710 32 6a fe			ld (debug_mark+2),a  
5713 18 03			jr .pastdmark  
5715 ..			.dmark: db "FOR"  
5718 f1			.pastdmark: pop af  
5719			endm  
# End of macro DMARK
5719					CALLMONITOR 
5719 cd 6c fe			call debug_vector  
571c				endm  
# End of macro CALLMONITOR
571c				endif 
571c					; Wipes the bank check flags to cause a reformat on next block 0 read 
571c			 
571c 21 01 00				ld hl, 1 
571f 3e 00				ld a, 0 
5721 cd 6b 02				call se_writebyte 
5724			 
5724				if DEBUG_STORESE 
5724					DMARK "FO0" 
5724 f5				push af  
5725 3a 39 57			ld a, (.dmark)  
5728 32 68 fe			ld (debug_mark),a  
572b 3a 3a 57			ld a, (.dmark+1)  
572e 32 69 fe			ld (debug_mark+1),a  
5731 3a 3b 57			ld a, (.dmark+2)  
5734 32 6a fe			ld (debug_mark+2),a  
5737 18 03			jr .pastdmark  
5739 ..			.dmark: db "FO0"  
573c f1			.pastdmark: pop af  
573d			endm  
# End of macro DMARK
573d					CALLMONITOR 
573d cd 6c fe			call debug_vector  
5740				endm  
# End of macro CALLMONITOR
5740				endif 
5740					; force bank init 
5740			 
5740 cd 17 05				call storage_get_block_0 
5743					 
5743				       NEXTW 
5743 c3 c0 24			jp macro_next 
5746				endm 
# End of macro NEXTW
5746			.LABEL: 
5746				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5746 6d				db WORD_SYS_CORE+89             
5747 94 57			dw .STOREPAGE            
5749 06				db 5 + 1 
574a .. 00			db "LABEL",0              
5750				endm 
# End of macro CWHEAD
5750			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5750			; | | Compatible with PicoSPINet  
5750					; TODO test to see if bank is selected 
5750				 
5750					if DEBUG_FORTH_WORDS_KEY 
5750						DMARK "LBL" 
5750 f5				push af  
5751 3a 65 57			ld a, (.dmark)  
5754 32 68 fe			ld (debug_mark),a  
5757 3a 66 57			ld a, (.dmark+1)  
575a 32 69 fe			ld (debug_mark+1),a  
575d 3a 67 57			ld a, (.dmark+2)  
5760 32 6a fe			ld (debug_mark+2),a  
5763 18 03			jr .pastdmark  
5765 ..			.dmark: db "LBL"  
5768 f1			.pastdmark: pop af  
5769			endm  
# End of macro DMARK
5769						CALLMONITOR 
5769 cd 6c fe			call debug_vector  
576c				endm  
# End of macro CALLMONITOR
576c					endif 
576c			;	if DEBUG_STORESE 
576c			;		DMARK "LBL" 
576c			;		CALLMONITOR 
576c			;	endif 
576c					FORTH_DSP_VALUEHL 
576c cd 0a 23			call macro_dsp_valuehl 
576f				endm 
# End of macro FORTH_DSP_VALUEHL
576f					;v5FORTH_DSP_VALUE 
576f					 
576f			;		push hl 
576f					FORTH_DSP_POP 
576f cd c2 23			call macro_forth_dsp_pop 
5772				endm 
# End of macro FORTH_DSP_POP
5772			;		pop hl 
5772			 
5772			;v5		inc hl   ; move past the type marker 
5772			 
5772				if DEBUG_STORESE 
5772					DMARK "LBl" 
5772 f5				push af  
5773 3a 87 57			ld a, (.dmark)  
5776 32 68 fe			ld (debug_mark),a  
5779 3a 88 57			ld a, (.dmark+1)  
577c 32 69 fe			ld (debug_mark+1),a  
577f 3a 89 57			ld a, (.dmark+2)  
5782 32 6a fe			ld (debug_mark+2),a  
5785 18 03			jr .pastdmark  
5787 ..			.dmark: db "LBl"  
578a f1			.pastdmark: pop af  
578b			endm  
# End of macro DMARK
578b					CALLMONITOR 
578b cd 6c fe			call debug_vector  
578e				endm  
# End of macro CALLMONITOR
578e				endif 
578e cd 3b 06				call storage_label 
5791			 
5791				       NEXTW 
5791 c3 c0 24			jp macro_next 
5794				endm 
# End of macro NEXTW
5794			.STOREPAGE: 
5794				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5794 6d				db WORD_SYS_CORE+89             
5795 c7 57			dw .LABELS            
5797 0a				db 9 + 1 
5798 .. 00			db "STOREPAGE",0              
57a2				endm 
# End of macro CWHEAD
57a2			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57a2			; | | Compatible with PicoSPINet  
57a2					; TODO test to see if bank is selected 
57a2				 
57a2					if DEBUG_FORTH_WORDS_KEY 
57a2						DMARK "STP" 
57a2 f5				push af  
57a3 3a b7 57			ld a, (.dmark)  
57a6 32 68 fe			ld (debug_mark),a  
57a9 3a b8 57			ld a, (.dmark+1)  
57ac 32 69 fe			ld (debug_mark+1),a  
57af 3a b9 57			ld a, (.dmark+2)  
57b2 32 6a fe			ld (debug_mark+2),a  
57b5 18 03			jr .pastdmark  
57b7 ..			.dmark: db "STP"  
57ba f1			.pastdmark: pop af  
57bb			endm  
# End of macro DMARK
57bb						CALLMONITOR 
57bb cd 6c fe			call debug_vector  
57be				endm  
# End of macro CALLMONITOR
57be					endif 
57be			;	if DEBUG_STORESE 
57be			;		DMARK "STP" 
57be			;		CALLMONITOR 
57be			;	endif 
57be			 
57be 21 77 fa			ld hl, store_page 
57c1 cd 13 21			call forth_push_numhl 
57c4			 
57c4			 
57c4				       NEXTW 
57c4 c3 c0 24			jp macro_next 
57c7				endm 
# End of macro NEXTW
57c7			.LABELS: 
57c7				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57c7 6d				db WORD_SYS_CORE+89             
57c8 51 58			dw .SCONST1            
57ca 07				db 6 + 1 
57cb .. 00			db "LABELS",0              
57d2				endm 
# End of macro CWHEAD
57d2			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
57d2			; | | *NOT* Compatible with PicoSPINet  
57d2					;  
57d2			 
57d2					; save the current device selected to restore afterwards 
57d2				 
57d2 3a 5d fa				ld a, (spi_device) 
57d5 f5					push af 
57d6			 
57d6			 
57d6					; run through each of the banks 
57d6			 
57d6 21 01 00				ld hl, 1 
57d9 cd 13 21				call forth_push_numhl 
57dc 3e ff				ld a, SPI_CE_HIGH 
57de cb 87				res SPI_CE0, a 
57e0 32 5d fa				ld (spi_device), a 
57e3 cd 17 05				call storage_get_block_0 
57e6 21 7a fa				ld hl, store_page+3 
57e9 cd 81 21				call forth_push_str 
57ec			 
57ec					 
57ec 21 02 00				ld hl, 2 
57ef cd 13 21				call forth_push_numhl 
57f2 3e ff				ld a, SPI_CE_HIGH 
57f4 cb 8f				res SPI_CE1, a 
57f6 32 5d fa				ld (spi_device), a 
57f9 cd 17 05				call storage_get_block_0 
57fc 21 7a fa				ld hl, store_page+3 
57ff cd 81 21				call forth_push_str 
5802			 
5802					 
5802 21 03 00				ld hl, 3 
5805 cd 13 21				call forth_push_numhl 
5808 3e ff				ld a, SPI_CE_HIGH 
580a cb 97				res SPI_CE2, a 
580c 32 5d fa				ld (spi_device), a 
580f cd 17 05				call storage_get_block_0 
5812 21 7a fa				ld hl, store_page+3 
5815 cd 81 21				call forth_push_str 
5818			 
5818			 
5818 21 04 00				ld hl, 4 
581b cd 13 21				call forth_push_numhl 
581e 3e ff				ld a, SPI_CE_HIGH 
5820 cb 9f				res SPI_CE3, a 
5822 32 5d fa				ld (spi_device), a 
5825 cd 17 05				call storage_get_block_0 
5828 21 7a fa				ld hl, store_page+3 
582b cd 81 21				call forth_push_str 
582e			 
582e					 
582e			 
582e 21 05 00				ld hl, 5 
5831 cd 13 21				call forth_push_numhl 
5834 3e ff				ld a, SPI_CE_HIGH 
5836 cb a7				res SPI_CE4, a 
5838 32 5d fa				ld (spi_device), a 
583b cd 17 05				call storage_get_block_0 
583e 21 7a fa				ld hl, store_page+3 
5841 cd 81 21				call forth_push_str 
5844			 
5844					 
5844					; push fixed count of storage devices (on board) for now 
5844			 
5844 21 05 00				ld hl, 5 
5847 cd 13 21				call forth_push_numhl 
584a			 
584a					; restore selected device  
584a				 
584a f1					pop af 
584b 32 5d fa				ld (spi_device), a 
584e			 
584e				       NEXTW 
584e c3 c0 24			jp macro_next 
5851				endm 
# End of macro NEXTW
5851			 
5851			.SCONST1: 
5851				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5851 6d				db WORD_SYS_CORE+89             
5852 68 58			dw .SCONST2            
5854 07				db 6 + 1 
5855 .. 00			db "FILEID",0              
585c				endm 
# End of macro CWHEAD
585c			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
585c			; | | Compatible with PicoSPINet  
585c 3a 64 fa				ld a, (store_filecache) 
585f 26 00				ld h, 0 
5861 6f					ld l, a 
5862 cd 13 21				call forth_push_numhl 
5865					NEXTW 
5865 c3 c0 24			jp macro_next 
5868				endm 
# End of macro NEXTW
5868			.SCONST2: 
5868				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5868 6d				db WORD_SYS_CORE+89             
5869 80 58			dw .SCONST3            
586b 08				db 7 + 1 
586c .. 00			db "FILEEXT",0              
5874				endm 
# End of macro CWHEAD
5874			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5874			; | | Compatible with PicoSPINet  
5874 3a 67 fa				ld a, (store_openext) 
5877 26 00				ld h, 0 
5879 6f					ld l, a 
587a cd 13 21				call forth_push_numhl 
587d					NEXTW 
587d c3 c0 24			jp macro_next 
5880				endm 
# End of macro NEXTW
5880			.SCONST3: 
5880				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5880 6d				db WORD_SYS_CORE+89             
5881 98 58			dw .SCONST4            
5883 08				db 7 + 1 
5884 .. 00			db "FILEMAX",0              
588c				endm 
# End of macro CWHEAD
588c			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
588c			; | | Compatible with PicoSPINet  
588c 3a 66 fa				ld a, (store_openmaxext) 
588f 26 00				ld h, 0 
5891 6f					ld l, a 
5892 cd 13 21				call forth_push_numhl 
5895					NEXTW 
5895 c3 c0 24			jp macro_next 
5898				endm 
# End of macro NEXTW
5898			.SCONST4: 
5898				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5898 6d				db WORD_SYS_CORE+89             
5899 ae 58			dw .SCONST5            
589b 09				db 8 + 1 
589c .. 00			db "FILEADDR",0              
58a5				endm 
# End of macro CWHEAD
58a5			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
58a5			; | | Compatible with PicoSPINet  
58a5 2a 68 fa				ld hl, (store_openaddr) 
58a8 cd 13 21				call forth_push_numhl 
58ab					NEXTW 
58ab c3 c0 24			jp macro_next 
58ae				endm 
# End of macro NEXTW
58ae			.SCONST5: 
58ae				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
58ae 6d				db WORD_SYS_CORE+89             
58af cf 58			dw .SCONST6            
58b1 09				db 8 + 1 
58b2 .. 00			db "FILEPAGE",0              
58bb				endm 
# End of macro CWHEAD
58bb			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
58bb			; | | Compatible with PicoSPINet  
58bb 2a 68 fa				ld hl, (store_openaddr) 
58be e5					push hl 
58bf c1					pop bc 
58c0 16 00				ld d, 0 
58c2 1e 40				ld e, STORE_BLOCK_PHY 
58c4 cd 2d 0f				call Div16 
58c7 c5					push bc 
58c8 e1					pop hl 
58c9 cd 13 21				call forth_push_numhl 
58cc					NEXTW 
58cc c3 c0 24			jp macro_next 
58cf				endm 
# End of macro NEXTW
58cf			.SCONST6: 
58cf				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58cf 6d				db WORD_SYS_CORE+89             
58d0 e8 58			dw .ENDSTORAGE            
58d2 09				db 8 + 1 
58d3 .. 00			db "READCONT",0              
58dc				endm 
# End of macro CWHEAD
58dc			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58dc			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58dc			; | | a further read should, if applicable, be CONCAT to the previous read. 
58dc			; | | Compatible with PicoSPINet  
58dc 3a 6a fa				ld a, (store_readcont) 
58df 26 00				ld h, 0 
58e1 6f					ld l, a 
58e2 cd 13 21				call forth_push_numhl 
58e5					NEXTW 
58e5 c3 c0 24			jp macro_next 
58e8				endm 
# End of macro NEXTW
58e8			.ENDSTORAGE: 
58e8			; eof 
# End of file forth_words_storage.asm
58e8			endif 
58e8				include "forth_words_device.asm" 
58e8			; Device related words 
58e8			 
58e8			; | ## Device Words 
58e8			 
58e8			;if SOUND_ENABLE 
58e8			;.NOTE: 
58e8			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58e8			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
58e8			;		if DEBUG_FORTH_WORDS_KEY 
58e8			;			DMARK "NTE" 
58e8			;			CALLMONITOR 
58e8			;		endif 
58e8			; 
58e8			;	 
58e8			; 
58e8			;		NEXTW 
58e8			;.AFTERSOUND: 
58e8			;endif 
58e8			 
58e8			 
58e8			USE_GPIO: equ 0 
58e8			 
58e8			if USE_GPIO 
58e8			.GP1: 
58e8				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58e8			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
58e8					NEXTW 
58e8			.GP2: 
58e8				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58e8			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
58e8			 
58e8					NEXTW 
58e8			 
58e8			.GP3: 
58e8				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58e8			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
58e8			 
58e8					NEXTW 
58e8			 
58e8			.GP4: 
58e8				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58e8			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
58e8			 
58e8					NEXTW 
58e8			.SIN: 
58e8			 
58e8			 
58e8			endif 
58e8			 
58e8			 
58e8				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58e8 33				db WORD_SYS_CORE+31             
58e9 1d 59			dw .SOUT            
58eb 03				db 2 + 1 
58ec .. 00			db "IN",0              
58ef				endm 
# End of macro CWHEAD
58ef			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
58ef					if DEBUG_FORTH_WORDS_KEY 
58ef						DMARK "IN." 
58ef f5				push af  
58f0 3a 04 59			ld a, (.dmark)  
58f3 32 68 fe			ld (debug_mark),a  
58f6 3a 05 59			ld a, (.dmark+1)  
58f9 32 69 fe			ld (debug_mark+1),a  
58fc 3a 06 59			ld a, (.dmark+2)  
58ff 32 6a fe			ld (debug_mark+2),a  
5902 18 03			jr .pastdmark  
5904 ..			.dmark: db "IN."  
5907 f1			.pastdmark: pop af  
5908			endm  
# End of macro DMARK
5908						CALLMONITOR 
5908 cd 6c fe			call debug_vector  
590b				endm  
# End of macro CALLMONITOR
590b					endif 
590b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
590b cd 0a 23			call macro_dsp_valuehl 
590e				endm 
# End of macro FORTH_DSP_VALUEHL
590e			 
590e e5					push hl 
590f			 
590f					; destroy value TOS 
590f			 
590f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
590f cd c2 23			call macro_forth_dsp_pop 
5912				endm 
# End of macro FORTH_DSP_POP
5912			 
5912					; one value on hl get other one back 
5912			 
5912 c1					pop bc 
5913			 
5913					; do the sub 
5913			;		ex de, hl 
5913			 
5913 ed 68				in l,(c) 
5915			 
5915					; save it 
5915			 
5915 26 00				ld h,0 
5917			 
5917					; TODO push value back onto stack for another op etc 
5917			 
5917 cd 13 21				call forth_push_numhl 
591a					NEXTW 
591a c3 c0 24			jp macro_next 
591d				endm 
# End of macro NEXTW
591d			.SOUT: 
591d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
591d 34				db WORD_SYS_CORE+32             
591e 70 59			dw .SPIO            
5920 04				db 3 + 1 
5921 .. 00			db "OUT",0              
5925				endm 
# End of macro CWHEAD
5925			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5925					if DEBUG_FORTH_WORDS_KEY 
5925						DMARK "OUT" 
5925 f5				push af  
5926 3a 3a 59			ld a, (.dmark)  
5929 32 68 fe			ld (debug_mark),a  
592c 3a 3b 59			ld a, (.dmark+1)  
592f 32 69 fe			ld (debug_mark+1),a  
5932 3a 3c 59			ld a, (.dmark+2)  
5935 32 6a fe			ld (debug_mark+2),a  
5938 18 03			jr .pastdmark  
593a ..			.dmark: db "OUT"  
593d f1			.pastdmark: pop af  
593e			endm  
# End of macro DMARK
593e						CALLMONITOR 
593e cd 6c fe			call debug_vector  
5941				endm  
# End of macro CALLMONITOR
5941					endif 
5941			 
5941					; get port 
5941			 
5941					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5941 cd 0a 23			call macro_dsp_valuehl 
5944				endm 
# End of macro FORTH_DSP_VALUEHL
5944			 
5944 e5					push hl 
5945			 
5945					; destroy value TOS 
5945			 
5945					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5945 cd c2 23			call macro_forth_dsp_pop 
5948				endm 
# End of macro FORTH_DSP_POP
5948			 
5948					; get byte to send 
5948			 
5948					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5948 cd 0a 23			call macro_dsp_valuehl 
594b				endm 
# End of macro FORTH_DSP_VALUEHL
594b			 
594b			;		push hl 
594b			 
594b					; destroy value TOS 
594b			 
594b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
594b cd c2 23			call macro_forth_dsp_pop 
594e				endm 
# End of macro FORTH_DSP_POP
594e			 
594e					; one value on hl get other one back 
594e			 
594e			;		pop hl 
594e			 
594e c1					pop bc 
594f			 
594f					if DEBUG_FORTH_WORDS 
594f						DMARK "OUT" 
594f f5				push af  
5950 3a 64 59			ld a, (.dmark)  
5953 32 68 fe			ld (debug_mark),a  
5956 3a 65 59			ld a, (.dmark+1)  
5959 32 69 fe			ld (debug_mark+1),a  
595c 3a 66 59			ld a, (.dmark+2)  
595f 32 6a fe			ld (debug_mark+2),a  
5962 18 03			jr .pastdmark  
5964 ..			.dmark: db "OUT"  
5967 f1			.pastdmark: pop af  
5968			endm  
# End of macro DMARK
5968						CALLMONITOR 
5968 cd 6c fe			call debug_vector  
596b				endm  
# End of macro CALLMONITOR
596b					endif 
596b			 
596b ed 69				out (c), l 
596d			 
596d					NEXTW 
596d c3 c0 24			jp macro_next 
5970				endm 
# End of macro NEXTW
5970			 
5970			 
5970			.SPIO: 
5970			 
5970			if STORAGE_SE 
5970				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5970 51				db WORD_SYS_CORE+61             
5971 81 59			dw .SPICEH            
5973 07				db 6 + 1 
5974 .. 00			db "SPICEL",0              
597b				endm 
# End of macro CWHEAD
597b			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
597b			 
597b cd 14 02				call spi_ce_low 
597e			    NEXTW 
597e c3 c0 24			jp macro_next 
5981				endm 
# End of macro NEXTW
5981			 
5981			.SPICEH: 
5981				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5981 51				db WORD_SYS_CORE+61             
5982 92 59			dw .SPIOb            
5984 07				db 6 + 1 
5985 .. 00			db "SPICEH",0              
598c				endm 
# End of macro CWHEAD
598c			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
598c			 
598c cd 03 02				call spi_ce_high 
598f			    NEXTW 
598f c3 c0 24			jp macro_next 
5992				endm 
# End of macro NEXTW
5992			 
5992			 
5992			.SPIOb: 
5992			 
5992				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5992 51				db WORD_SYS_CORE+61             
5993 c4 59			dw .SPII            
5995 05				db 4 + 1 
5996 .. 00			db "SPIO",0              
599b				endm 
# End of macro CWHEAD
599b			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
599b			 
599b					if DEBUG_FORTH_WORDS_KEY 
599b						DMARK "SPo" 
599b f5				push af  
599c 3a b0 59			ld a, (.dmark)  
599f 32 68 fe			ld (debug_mark),a  
59a2 3a b1 59			ld a, (.dmark+1)  
59a5 32 69 fe			ld (debug_mark+1),a  
59a8 3a b2 59			ld a, (.dmark+2)  
59ab 32 6a fe			ld (debug_mark+2),a  
59ae 18 03			jr .pastdmark  
59b0 ..			.dmark: db "SPo"  
59b3 f1			.pastdmark: pop af  
59b4			endm  
# End of macro DMARK
59b4						CALLMONITOR 
59b4 cd 6c fe			call debug_vector  
59b7				endm  
# End of macro CALLMONITOR
59b7					endif 
59b7					; get port 
59b7			 
59b7			 
59b7					; get byte to send 
59b7			 
59b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59b7 cd 0a 23			call macro_dsp_valuehl 
59ba				endm 
# End of macro FORTH_DSP_VALUEHL
59ba			 
59ba			;		push hl    ; u1  
59ba			 
59ba					; destroy value TOS 
59ba			 
59ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59ba cd c2 23			call macro_forth_dsp_pop 
59bd				endm 
# End of macro FORTH_DSP_POP
59bd			 
59bd					; one value on hl get other one back 
59bd			 
59bd			;		pop hl   ; u2 - addr 
59bd			 
59bd					; TODO Send SPI byte 
59bd			 
59bd			;		push hl 
59bd			;		call spi_ce_low 
59bd			;		pop hl 
59bd 7d					ld a, l 
59be cd 02 01				call spi_send_byte 
59c1			;		call spi_ce_high 
59c1			 
59c1					NEXTW 
59c1 c3 c0 24			jp macro_next 
59c4				endm 
# End of macro NEXTW
59c4			 
59c4			.SPII: 
59c4				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59c4 52				db WORD_SYS_CORE+62             
59c5 2d 5a			dw .SESEL            
59c7 06				db 5 + 1 
59c8 .. 00			db "SPII",0              
59cd				endm 
# End of macro CWHEAD
59cd			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59cd					if DEBUG_FORTH_WORDS_KEY 
59cd						DMARK "SPi" 
59cd f5				push af  
59ce 3a e2 59			ld a, (.dmark)  
59d1 32 68 fe			ld (debug_mark),a  
59d4 3a e3 59			ld a, (.dmark+1)  
59d7 32 69 fe			ld (debug_mark+1),a  
59da 3a e4 59			ld a, (.dmark+2)  
59dd 32 6a fe			ld (debug_mark+2),a  
59e0 18 03			jr .pastdmark  
59e2 ..			.dmark: db "SPi"  
59e5 f1			.pastdmark: pop af  
59e6			endm  
# End of macro DMARK
59e6						CALLMONITOR 
59e6 cd 6c fe			call debug_vector  
59e9				endm  
# End of macro CALLMONITOR
59e9					endif 
59e9			 
59e9					; TODO Get SPI byte 
59e9			 
59e9 cd 29 01				call spi_read_byte 
59ec			 
59ec					if DEBUG_FORTH_WORDS 
59ec						DMARK "Si2" 
59ec f5				push af  
59ed 3a 01 5a			ld a, (.dmark)  
59f0 32 68 fe			ld (debug_mark),a  
59f3 3a 02 5a			ld a, (.dmark+1)  
59f6 32 69 fe			ld (debug_mark+1),a  
59f9 3a 03 5a			ld a, (.dmark+2)  
59fc 32 6a fe			ld (debug_mark+2),a  
59ff 18 03			jr .pastdmark  
5a01 ..			.dmark: db "Si2"  
5a04 f1			.pastdmark: pop af  
5a05			endm  
# End of macro DMARK
5a05						CALLMONITOR 
5a05 cd 6c fe			call debug_vector  
5a08				endm  
# End of macro CALLMONITOR
5a08					endif 
5a08 26 00				ld h, 0 
5a0a 6f					ld l, a 
5a0b					if DEBUG_FORTH_WORDS 
5a0b						DMARK "Si3" 
5a0b f5				push af  
5a0c 3a 20 5a			ld a, (.dmark)  
5a0f 32 68 fe			ld (debug_mark),a  
5a12 3a 21 5a			ld a, (.dmark+1)  
5a15 32 69 fe			ld (debug_mark+1),a  
5a18 3a 22 5a			ld a, (.dmark+2)  
5a1b 32 6a fe			ld (debug_mark+2),a  
5a1e 18 03			jr .pastdmark  
5a20 ..			.dmark: db "Si3"  
5a23 f1			.pastdmark: pop af  
5a24			endm  
# End of macro DMARK
5a24						CALLMONITOR 
5a24 cd 6c fe			call debug_vector  
5a27				endm  
# End of macro CALLMONITOR
5a27					endif 
5a27 cd 13 21				call forth_push_numhl 
5a2a			 
5a2a					NEXTW 
5a2a c3 c0 24			jp macro_next 
5a2d				endm 
# End of macro NEXTW
5a2d			 
5a2d			 
5a2d			 
5a2d			.SESEL: 
5a2d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a2d 66				db WORD_SYS_CORE+82             
5a2e d6 5a			dw .CARTDEV            
5a30 05				db 4 + 1 
5a31 .. 00			db "BANK",0              
5a36				endm 
# End of macro CWHEAD
5a36			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a36					if DEBUG_FORTH_WORDS_KEY 
5a36						DMARK "BNK" 
5a36 f5				push af  
5a37 3a 4b 5a			ld a, (.dmark)  
5a3a 32 68 fe			ld (debug_mark),a  
5a3d 3a 4c 5a			ld a, (.dmark+1)  
5a40 32 69 fe			ld (debug_mark+1),a  
5a43 3a 4d 5a			ld a, (.dmark+2)  
5a46 32 6a fe			ld (debug_mark+2),a  
5a49 18 03			jr .pastdmark  
5a4b ..			.dmark: db "BNK"  
5a4e f1			.pastdmark: pop af  
5a4f			endm  
# End of macro DMARK
5a4f						CALLMONITOR 
5a4f cd 6c fe			call debug_vector  
5a52				endm  
# End of macro CALLMONITOR
5a52					endif 
5a52			 
5a52 3e ff				ld a, 255 
5a54 32 60 fa				ld (spi_cartdev), a 
5a57			 
5a57					; get bank 
5a57			 
5a57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a57 cd 0a 23			call macro_dsp_valuehl 
5a5a				endm 
# End of macro FORTH_DSP_VALUEHL
5a5a			 
5a5a			;		push hl 
5a5a			 
5a5a					; destroy value TOS 
5a5a			 
5a5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a5a cd c2 23			call macro_forth_dsp_pop 
5a5d				endm 
# End of macro FORTH_DSP_POP
5a5d			 
5a5d					; one value on hl get other one back 
5a5d			 
5a5d			;		pop hl 
5a5d			 
5a5d			 
5a5d 0e ff				ld c, SPI_CE_HIGH 
5a5f 06 30				ld b, '0'    ; human readable bank number 
5a61			 
5a61 7d					ld a, l 
5a62			 
5a62					if DEBUG_FORTH_WORDS 
5a62						DMARK "BNK" 
5a62 f5				push af  
5a63 3a 77 5a			ld a, (.dmark)  
5a66 32 68 fe			ld (debug_mark),a  
5a69 3a 78 5a			ld a, (.dmark+1)  
5a6c 32 69 fe			ld (debug_mark+1),a  
5a6f 3a 79 5a			ld a, (.dmark+2)  
5a72 32 6a fe			ld (debug_mark+2),a  
5a75 18 03			jr .pastdmark  
5a77 ..			.dmark: db "BNK"  
5a7a f1			.pastdmark: pop af  
5a7b			endm  
# End of macro DMARK
5a7b						CALLMONITOR 
5a7b cd 6c fe			call debug_vector  
5a7e				endm  
# End of macro CALLMONITOR
5a7e					endif 
5a7e			 
5a7e					; active low 
5a7e			 
5a7e fe 00				cp 0 
5a80 28 28				jr z, .bset 
5a82 fe 01				cp 1 
5a84 20 04				jr nz, .b2 
5a86 cb 81				res 0, c 
5a88 06 31				ld b, '1'    ; human readable bank number 
5a8a fe 02		.b2:		cp 2 
5a8c 20 04				jr nz, .b3 
5a8e cb 89				res 1, c 
5a90 06 32				ld b, '2'    ; human readable bank number 
5a92 fe 03		.b3:		cp 3 
5a94 20 04				jr nz, .b4 
5a96 cb 91				res 2, c 
5a98 06 33				ld b, '3'    ; human readable bank number 
5a9a fe 04		.b4:		cp 4 
5a9c 20 04				jr nz, .b5 
5a9e cb 99				res 3, c 
5aa0 06 34				ld b, '4'    ; human readable bank number 
5aa2 fe 05		.b5:		cp 5 
5aa4 20 04				jr nz, .bset 
5aa6 cb a1				res 4, c 
5aa8 06 35				ld b, '5'    ; human readable bank number 
5aaa			 
5aaa			.bset: 
5aaa 79					ld a, c 
5aab 32 5d fa				ld (spi_device),a 
5aae 78					ld a, b 
5aaf 32 5c fa				ld (spi_device_id),a 
5ab2					if DEBUG_FORTH_WORDS 
5ab2						DMARK "BN2" 
5ab2 f5				push af  
5ab3 3a c7 5a			ld a, (.dmark)  
5ab6 32 68 fe			ld (debug_mark),a  
5ab9 3a c8 5a			ld a, (.dmark+1)  
5abc 32 69 fe			ld (debug_mark+1),a  
5abf 3a c9 5a			ld a, (.dmark+2)  
5ac2 32 6a fe			ld (debug_mark+2),a  
5ac5 18 03			jr .pastdmark  
5ac7 ..			.dmark: db "BN2"  
5aca f1			.pastdmark: pop af  
5acb			endm  
# End of macro DMARK
5acb						CALLMONITOR 
5acb cd 6c fe			call debug_vector  
5ace				endm  
# End of macro CALLMONITOR
5ace					endif 
5ace			 
5ace					; set default SPI clk pulse time as disabled for BANK use 
5ace			 
5ace 3e 00				ld a, 0 
5ad0 32 61 fa				ld (spi_clktime), a 
5ad3			 
5ad3					NEXTW 
5ad3 c3 c0 24			jp macro_next 
5ad6				endm 
# End of macro NEXTW
5ad6			 
5ad6			.CARTDEV: 
5ad6				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5ad6 66				db WORD_SYS_CORE+82             
5ad7 84 5b			dw .ENDDEVICE            
5ad9 08				db 7 + 1 
5ada .. 00			db "CARTDEV",0              
5ae2				endm 
# End of macro CWHEAD
5ae2			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5ae2					if DEBUG_FORTH_WORDS_KEY 
5ae2						DMARK "CDV" 
5ae2 f5				push af  
5ae3 3a f7 5a			ld a, (.dmark)  
5ae6 32 68 fe			ld (debug_mark),a  
5ae9 3a f8 5a			ld a, (.dmark+1)  
5aec 32 69 fe			ld (debug_mark+1),a  
5aef 3a f9 5a			ld a, (.dmark+2)  
5af2 32 6a fe			ld (debug_mark+2),a  
5af5 18 03			jr .pastdmark  
5af7 ..			.dmark: db "CDV"  
5afa f1			.pastdmark: pop af  
5afb			endm  
# End of macro DMARK
5afb						CALLMONITOR 
5afb cd 6c fe			call debug_vector  
5afe				endm  
# End of macro CALLMONITOR
5afe					endif 
5afe			 
5afe					; disable se storage bank selection 
5afe			 
5afe 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b00 32 5d fa				ld (spi_device), a 
5b03			 
5b03					; get bank 
5b03			 
5b03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b03 cd 0a 23			call macro_dsp_valuehl 
5b06				endm 
# End of macro FORTH_DSP_VALUEHL
5b06			 
5b06			;		push hl 
5b06			 
5b06					; destroy value TOS 
5b06			 
5b06					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b06 cd c2 23			call macro_forth_dsp_pop 
5b09				endm 
# End of macro FORTH_DSP_POP
5b09			 
5b09					; one value on hl get other one back 
5b09			 
5b09			;		pop hl 
5b09			 
5b09					; active low 
5b09			 
5b09 0e ff				ld c, 255 
5b0b			 
5b0b 7d					ld a, l 
5b0c					if DEBUG_FORTH_WORDS 
5b0c						DMARK "CDV" 
5b0c f5				push af  
5b0d 3a 21 5b			ld a, (.dmark)  
5b10 32 68 fe			ld (debug_mark),a  
5b13 3a 22 5b			ld a, (.dmark+1)  
5b16 32 69 fe			ld (debug_mark+1),a  
5b19 3a 23 5b			ld a, (.dmark+2)  
5b1c 32 6a fe			ld (debug_mark+2),a  
5b1f 18 03			jr .pastdmark  
5b21 ..			.dmark: db "CDV"  
5b24 f1			.pastdmark: pop af  
5b25			endm  
# End of macro DMARK
5b25						CALLMONITOR 
5b25 cd 6c fe			call debug_vector  
5b28				endm  
# End of macro CALLMONITOR
5b28					endif 
5b28 fe 00				cp 0 
5b2a 28 30				jr z, .cset 
5b2c fe 01				cp 1 
5b2e 20 02				jr nz, .c2 
5b30 cb 81				res 0, c 
5b32 fe 02		.c2:		cp 2 
5b34 20 02				jr nz, .c3 
5b36 cb 89				res 1, c 
5b38 fe 03		.c3:		cp 3 
5b3a 20 02				jr nz, .c4 
5b3c cb 91				res 2, c 
5b3e fe 04		.c4:		cp 4 
5b40 20 02				jr nz, .c5 
5b42 cb 99				res 3, c 
5b44 fe 05		.c5:		cp 5 
5b46 20 02				jr nz, .c6 
5b48 cb a1				res 4, c 
5b4a fe 06		.c6:		cp 6 
5b4c 20 02				jr nz, .c7 
5b4e cb a9				res 5, c 
5b50 fe 07		.c7:		cp 7 
5b52 20 02				jr nz, .c8 
5b54 cb b1				res 6, c 
5b56 fe 08		.c8:		cp 8 
5b58 20 02				jr nz, .cset 
5b5a cb b9				res 7, c 
5b5c 79			.cset:		ld a, c 
5b5d 32 60 fa				ld (spi_cartdev),a 
5b60			 
5b60					if DEBUG_FORTH_WORDS 
5b60						DMARK "CD2" 
5b60 f5				push af  
5b61 3a 75 5b			ld a, (.dmark)  
5b64 32 68 fe			ld (debug_mark),a  
5b67 3a 76 5b			ld a, (.dmark+1)  
5b6a 32 69 fe			ld (debug_mark+1),a  
5b6d 3a 77 5b			ld a, (.dmark+2)  
5b70 32 6a fe			ld (debug_mark+2),a  
5b73 18 03			jr .pastdmark  
5b75 ..			.dmark: db "CD2"  
5b78 f1			.pastdmark: pop af  
5b79			endm  
# End of macro DMARK
5b79						CALLMONITOR 
5b79 cd 6c fe			call debug_vector  
5b7c				endm  
# End of macro CALLMONITOR
5b7c					endif 
5b7c			 
5b7c					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b7c			 
5b7c 3e 0a				ld a, $0a 
5b7e 32 61 fa				ld (spi_clktime), a 
5b81					NEXTW 
5b81 c3 c0 24			jp macro_next 
5b84				endm 
# End of macro NEXTW
5b84			endif 
5b84			 
5b84			.ENDDEVICE: 
5b84			; eof 
5b84			 
# End of file forth_words_device.asm
5b84			 
5b84			; var handler 
5b84			 
5b84			 
5b84			.VARS: 
5b84				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b84 77				db WORD_SYS_CORE+99             
5b85 35 5c			dw .V0            
5b87 04				db 3 + 1 
5b88 .. 00			db "VAR",0              
5b8c				endm 
# End of macro CWHEAD
5b8c			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5b8c			;| 
5b8c			;| The variable name should consist of a single letter. e.g. "a" 
5b8c			;! If a full string is passed then only the first char is looked at 
5b8c			;| Any other char could exceed bounds checks!  
5b8c			 
5b8c					if DEBUG_FORTH_WORDS_KEY 
5b8c						DMARK "VAR" 
5b8c f5				push af  
5b8d 3a a1 5b			ld a, (.dmark)  
5b90 32 68 fe			ld (debug_mark),a  
5b93 3a a2 5b			ld a, (.dmark+1)  
5b96 32 69 fe			ld (debug_mark+1),a  
5b99 3a a3 5b			ld a, (.dmark+2)  
5b9c 32 6a fe			ld (debug_mark+2),a  
5b9f 18 03			jr .pastdmark  
5ba1 ..			.dmark: db "VAR"  
5ba4 f1			.pastdmark: pop af  
5ba5			endm  
# End of macro DMARK
5ba5						CALLMONITOR 
5ba5 cd 6c fe			call debug_vector  
5ba8				endm  
# End of macro CALLMONITOR
5ba8					endif 
5ba8			 
5ba8					FORTH_DSP_VALUEHL 
5ba8 cd 0a 23			call macro_dsp_valuehl 
5bab				endm 
# End of macro FORTH_DSP_VALUEHL
5bab			 
5bab 7e					ld a, (hl)    ; get first char on of the string 
5bac			 
5bac			 
5bac					if DEBUG_FORTH_WORDS 
5bac						DMARK "VR1" 
5bac f5				push af  
5bad 3a c1 5b			ld a, (.dmark)  
5bb0 32 68 fe			ld (debug_mark),a  
5bb3 3a c2 5b			ld a, (.dmark+1)  
5bb6 32 69 fe			ld (debug_mark+1),a  
5bb9 3a c3 5b			ld a, (.dmark+2)  
5bbc 32 6a fe			ld (debug_mark+2),a  
5bbf 18 03			jr .pastdmark  
5bc1 ..			.dmark: db "VR1"  
5bc4 f1			.pastdmark: pop af  
5bc5			endm  
# End of macro DMARK
5bc5						CALLMONITOR 
5bc5 cd 6c fe			call debug_vector  
5bc8				endm  
# End of macro CALLMONITOR
5bc8					endif 
5bc8					 
5bc8 f5					push af	 
5bc9					FORTH_DSP_POP 
5bc9 cd c2 23			call macro_forth_dsp_pop 
5bcc				endm 
# End of macro FORTH_DSP_POP
5bcc f1					pop af 
5bcd			 
5bcd					; convert to upper 
5bcd			 
5bcd cd 3d 13				call to_upper 
5bd0					if DEBUG_FORTH_WORDS 
5bd0						DMARK "Vaa" 
5bd0 f5				push af  
5bd1 3a e5 5b			ld a, (.dmark)  
5bd4 32 68 fe			ld (debug_mark),a  
5bd7 3a e6 5b			ld a, (.dmark+1)  
5bda 32 69 fe			ld (debug_mark+1),a  
5bdd 3a e7 5b			ld a, (.dmark+2)  
5be0 32 6a fe			ld (debug_mark+2),a  
5be3 18 03			jr .pastdmark  
5be5 ..			.dmark: db "Vaa"  
5be8 f1			.pastdmark: pop af  
5be9			endm  
# End of macro DMARK
5be9						CALLMONITOR 
5be9 cd 6c fe			call debug_vector  
5bec				endm  
# End of macro CALLMONITOR
5bec					endif 
5bec 06 41				ld b, 'A' 
5bee 90					sub b			; set offset 
5bef					if DEBUG_FORTH_WORDS 
5bef						DMARK "Vbb" 
5bef f5				push af  
5bf0 3a 04 5c			ld a, (.dmark)  
5bf3 32 68 fe			ld (debug_mark),a  
5bf6 3a 05 5c			ld a, (.dmark+1)  
5bf9 32 69 fe			ld (debug_mark+1),a  
5bfc 3a 06 5c			ld a, (.dmark+2)  
5bff 32 6a fe			ld (debug_mark+2),a  
5c02 18 03			jr .pastdmark  
5c04 ..			.dmark: db "Vbb"  
5c07 f1			.pastdmark: pop af  
5c08			endm  
# End of macro DMARK
5c08						CALLMONITOR 
5c08 cd 6c fe			call debug_vector  
5c0b				endm  
# End of macro CALLMONITOR
5c0b					endif 
5c0b cb 27				sla a  
5c0d				 
5c0d					 
5c0d					if DEBUG_FORTH_WORDS 
5c0d						DMARK "VR2" 
5c0d f5				push af  
5c0e 3a 22 5c			ld a, (.dmark)  
5c11 32 68 fe			ld (debug_mark),a  
5c14 3a 23 5c			ld a, (.dmark+1)  
5c17 32 69 fe			ld (debug_mark+1),a  
5c1a 3a 24 5c			ld a, (.dmark+2)  
5c1d 32 6a fe			ld (debug_mark+2),a  
5c20 18 03			jr .pastdmark  
5c22 ..			.dmark: db "VR2"  
5c25 f1			.pastdmark: pop af  
5c26			endm  
# End of macro DMARK
5c26						CALLMONITOR 
5c26 cd 6c fe			call debug_vector  
5c29				endm  
# End of macro CALLMONITOR
5c29					endif 
5c29			 
5c29 21 f1 f9				ld hl, cli_var_array2 
5c2c cd d0 0f				call addatohl 
5c2f cd 13 21				call forth_push_numhl 
5c32			 
5c32			 
5c32				       NEXTW 
5c32 c3 c0 24			jp macro_next 
5c35				endm 
# End of macro NEXTW
5c35			.V0: 
5c35				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c35 78				db WORD_SYS_CORE+100             
5c36 4d 5c			dw .V0Q            
5c38 04				db 3 + 1 
5c39 .. 00			db "V0!",0              
5c3d				endm 
# End of macro CWHEAD
5c3d			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c3d			 
5c3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c3d cd 0a 23			call macro_dsp_valuehl 
5c40				endm 
# End of macro FORTH_DSP_VALUEHL
5c40			 
5c40 11 25 fa				ld de, cli_var_array 
5c43			 
5c43 eb					ex de, hl 
5c44 73					ld (hl), e 
5c45 23					inc hl 
5c46 72					ld (hl), d 
5c47			 
5c47					; destroy value TOS 
5c47			 
5c47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c47 cd c2 23			call macro_forth_dsp_pop 
5c4a				endm 
# End of macro FORTH_DSP_POP
5c4a			 
5c4a				       NEXTW 
5c4a c3 c0 24			jp macro_next 
5c4d				endm 
# End of macro NEXTW
5c4d			.V0Q: 
5c4d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c4d 79				db WORD_SYS_CORE+101             
5c4e 5e 5c			dw .V1S            
5c50 04				db 3 + 1 
5c51 .. 00			db "V0@",0              
5c55				endm 
# End of macro CWHEAD
5c55			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c55 2a 25 fa				ld hl, (cli_var_array) 
5c58 cd 13 21				call forth_push_numhl 
5c5b			 
5c5b				       NEXTW 
5c5b c3 c0 24			jp macro_next 
5c5e				endm 
# End of macro NEXTW
5c5e			.V1S: 
5c5e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c5e 7a				db WORD_SYS_CORE+102             
5c5f 76 5c			dw .V1Q            
5c61 04				db 3 + 1 
5c62 .. 00			db "V1!",0              
5c66				endm 
# End of macro CWHEAD
5c66			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c66					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c66 cd 0a 23			call macro_dsp_valuehl 
5c69				endm 
# End of macro FORTH_DSP_VALUEHL
5c69			 
5c69 11 27 fa				ld de, cli_var_array+2 
5c6c				 
5c6c eb					ex de, hl 
5c6d 73					ld (hl), e 
5c6e 23					inc hl 
5c6f 72					ld (hl), d 
5c70			 
5c70					; destroy value TOS 
5c70			 
5c70					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c70 cd c2 23			call macro_forth_dsp_pop 
5c73				endm 
# End of macro FORTH_DSP_POP
5c73				       NEXTW 
5c73 c3 c0 24			jp macro_next 
5c76				endm 
# End of macro NEXTW
5c76			.V1Q: 
5c76				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c76 7b				db WORD_SYS_CORE+103             
5c77 87 5c			dw .V2S            
5c79 04				db 3 + 1 
5c7a .. 00			db "V1@",0              
5c7e				endm 
# End of macro CWHEAD
5c7e			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c7e 2a 27 fa				ld hl, (cli_var_array+2) 
5c81 cd 13 21				call forth_push_numhl 
5c84				       NEXTW 
5c84 c3 c0 24			jp macro_next 
5c87				endm 
# End of macro NEXTW
5c87			.V2S: 
5c87				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c87 7c				db WORD_SYS_CORE+104             
5c88 9f 5c			dw .V2Q            
5c8a 04				db 3 + 1 
5c8b .. 00			db "V2!",0              
5c8f				endm 
# End of macro CWHEAD
5c8f			;| V2! ( u1 -- )  Store value to v2 | DONE 
5c8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c8f cd 0a 23			call macro_dsp_valuehl 
5c92				endm 
# End of macro FORTH_DSP_VALUEHL
5c92			 
5c92 11 29 fa				ld de, cli_var_array+4 
5c95				 
5c95 eb					ex de, hl 
5c96 73					ld (hl), e 
5c97 23					inc hl 
5c98 72					ld (hl), d 
5c99			 
5c99					; destroy value TOS 
5c99			 
5c99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c99 cd c2 23			call macro_forth_dsp_pop 
5c9c				endm 
# End of macro FORTH_DSP_POP
5c9c				       NEXTW 
5c9c c3 c0 24			jp macro_next 
5c9f				endm 
# End of macro NEXTW
5c9f			.V2Q: 
5c9f				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5c9f 7d				db WORD_SYS_CORE+105             
5ca0 b0 5c			dw .V3S            
5ca2 04				db 3 + 1 
5ca3 .. 00			db "V2@",0              
5ca7				endm 
# End of macro CWHEAD
5ca7			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5ca7 2a 29 fa				ld hl, (cli_var_array+4) 
5caa cd 13 21				call forth_push_numhl 
5cad				       NEXTW 
5cad c3 c0 24			jp macro_next 
5cb0				endm 
# End of macro NEXTW
5cb0			.V3S: 
5cb0				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5cb0 7c				db WORD_SYS_CORE+104             
5cb1 c8 5c			dw .V3Q            
5cb3 04				db 3 + 1 
5cb4 .. 00			db "V3!",0              
5cb8				endm 
# End of macro CWHEAD
5cb8			;| V3! ( u1 -- )  Store value to v3 | DONE 
5cb8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cb8 cd 0a 23			call macro_dsp_valuehl 
5cbb				endm 
# End of macro FORTH_DSP_VALUEHL
5cbb			 
5cbb 11 2b fa				ld de, cli_var_array+6 
5cbe				 
5cbe eb					ex de, hl 
5cbf 73					ld (hl), e 
5cc0 23					inc hl 
5cc1 72					ld (hl), d 
5cc2			 
5cc2					; destroy value TOS 
5cc2			 
5cc2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cc2 cd c2 23			call macro_forth_dsp_pop 
5cc5				endm 
# End of macro FORTH_DSP_POP
5cc5				       NEXTW 
5cc5 c3 c0 24			jp macro_next 
5cc8				endm 
# End of macro NEXTW
5cc8			.V3Q: 
5cc8				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cc8 7d				db WORD_SYS_CORE+105             
5cc9 d9 5c			dw .END            
5ccb 04				db 3 + 1 
5ccc .. 00			db "V3@",0              
5cd0				endm 
# End of macro CWHEAD
5cd0			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5cd0 2a 2b fa				ld hl, (cli_var_array+6) 
5cd3 cd 13 21				call forth_push_numhl 
5cd6				       NEXTW 
5cd6 c3 c0 24			jp macro_next 
5cd9				endm 
# End of macro NEXTW
5cd9			 
5cd9			 
5cd9			 
5cd9			 
5cd9			 
5cd9			; end of dict marker 
5cd9			 
5cd9 00			.END:    db WORD_SYS_END 
5cda 00 00			dw 0 
5cdc 00				db 0 
5cdd			 
5cdd			; use to jp here for user dict words to save on macro expansion  
5cdd			 
5cdd			user_dict_next: 
5cdd				NEXTW 
5cdd c3 c0 24			jp macro_next 
5ce0				endm 
# End of macro NEXTW
5ce0			 
5ce0			 
5ce0			user_exec: 
5ce0				;    ld hl, <word code> 
5ce0				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5ce0				;    call forthexec 
5ce0				;    jp user_dict_next   (NEXT) 
5ce0			        ;    <word code bytes> 
5ce0 eb				ex de, hl 
5ce1 2a bf f4			ld hl,(os_tok_ptr) 
5ce4				 
5ce4				FORTH_RSP_NEXT 
5ce4 cd ba 20			call macro_forth_rsp_next 
5ce7				endm 
# End of macro FORTH_RSP_NEXT
5ce7			 
5ce7			if DEBUG_FORTH_UWORD 
5ce7						DMARK "UEX" 
5ce7 f5				push af  
5ce8 3a fc 5c			ld a, (.dmark)  
5ceb 32 68 fe			ld (debug_mark),a  
5cee 3a fd 5c			ld a, (.dmark+1)  
5cf1 32 69 fe			ld (debug_mark+1),a  
5cf4 3a fe 5c			ld a, (.dmark+2)  
5cf7 32 6a fe			ld (debug_mark+2),a  
5cfa 18 03			jr .pastdmark  
5cfc ..			.dmark: db "UEX"  
5cff f1			.pastdmark: pop af  
5d00			endm  
# End of macro DMARK
5d00				CALLMONITOR 
5d00 cd 6c fe			call debug_vector  
5d03				endm  
# End of macro CALLMONITOR
5d03			endif 
5d03			 
5d03			 
5d03			 
5d03 eb				ex de, hl 
5d04 22 bf f4			ld (os_tok_ptr), hl 
5d07				 
5d07				; Don't use next - Skips the first word in uword. 
5d07			 
5d07 c3 51 25			jp exec1 
5d0a			;	NEXT 
5d0a			 
5d0a			 
5d0a			; eof 
# End of file forth_wordsv4.asm
5d0a			endif 
5d0a			;;;;;;;;;;;;;; Debug code 
5d0a			 
5d0a			 
5d0a			;if DEBUG_FORTH_PARSE 
5d0a .. 00		.nowordfound: db "No match",0 
5d13 .. 00		.compword:	db "Comparing word ",0 
5d23 .. 00		.nextwordat:	db "Next word at",0 
5d30 .. 00		.charmatch:	db "Char match",0 
5d3b			;endif 
5d3b			if DEBUG_FORTH_JP 
5d3b			.foundword:	db "Word match. Exec..",0 
5d3b			endif 
5d3b			;if DEBUG_FORTH_PUSH 
5d3b .. 00		.enddict:	db "Dict end. Push.",0 
5d4b .. 00		.push_str:	db "Pushing string",0 
5d5a .. 00		.push_num:	db "Pushing number",0 
5d69 .. 00		.data_sp:	db "SP:",0 
5d6d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d7f .. 00		.wordinde:	db "Word in DE (3/0):",0 
5d91 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5da3			;endif 
5da3			;if DEBUG_FORTH_MALLOC 
5da3 .. 00		.push_malloc:	db "Malloc address",0 
5db2			;endif 
5db2			 
5db2			 
5db2			 
5db2			; display malloc address and current data stack pointer  
5db2			 
5db2			malloc_error: 
5db2 d5				push de 
5db3 f5				push af 
5db4 e5				push hl 
5db5 cd 9c 0d			call clear_display 
5db8 11 d8 5d			ld de, .mallocerr 
5dbb 3e 00			ld a,0 
5dbd			;	ld de,os_word_scratch 
5dbd cd af 0d			call str_at_display 
5dc0 3e 11			ld a, display_row_1+17 
5dc2 11 68 fe			ld de, debug_mark 
5dc5 cd af 0d			call str_at_display 
5dc8 cd bf 0d			call update_display 
5dcb				;call break_point_state 
5dcb cd 71 79			call cin_wait 
5dce			 
5dce			;	ld a, ' ' 
5dce			;	ld (os_view_disable), a 
5dce cd 34 1a			call bp_on 
5dd1 e1				pop hl 
5dd2 f1				pop af 
5dd3 d1				pop de	 
5dd4				CALLMONITOR 
5dd4 cd 6c fe			call debug_vector  
5dd7				endm  
# End of macro CALLMONITOR
5dd7 c9				ret 
5dd8			 
5dd8 .. 00		.mallocerr: 	db "Malloc Error",0 
5de5			;if DEBUG_FORTH_PUSH 
5de5			display_data_sp: 
5de5 f5				push af 
5de6			 
5de6				; see if disabled 
5de6			 
5de6			 
5de6 3a 6c fe			ld a, (debug_vector) 
5de9 fe c9			cp $C9  ; RET 
5deb				;ld a, (os_view_disable) 
5deb				;cp '*' 
5deb 28 67			jr z, .skipdsp 
5ded			 
5ded e5				push hl 
5dee e5				push hl 
5def e5			push hl 
5df0 cd 9c 0d			call clear_display 
5df3 e1			pop hl 
5df4 7c				ld a,h 
5df5 21 c3 f4			ld hl, os_word_scratch 
5df8 cd d1 12			call hexout 
5dfb e1				pop hl 
5dfc 7d				ld a,l 
5dfd 21 c5 f4			ld hl, os_word_scratch+2 
5e00 cd d1 12			call hexout 
5e03 21 c7 f4			ld hl, os_word_scratch+4 
5e06 3e 00			ld a,0 
5e08 77				ld (hl),a 
5e09 11 c3 f4			ld de,os_word_scratch 
5e0c 3e 28				ld a, display_row_2 
5e0e cd af 0d				call str_at_display 
5e11 11 6d 5d			ld de, .wordinhl 
5e14 3e 00			ld a, display_row_1 
5e16			 
5e16 cd af 0d				call str_at_display 
5e19 11 68 fe			ld de, debug_mark 
5e1c 3e 11			ld a, display_row_1+17 
5e1e			 
5e1e cd af 0d				call str_at_display 
5e21			 
5e21				; display current data stack pointer 
5e21 11 69 5d			ld de,.data_sp 
5e24 3e 30				ld a, display_row_2 + 8 
5e26 cd af 0d				call str_at_display 
5e29			 
5e29 2a eb f9			ld hl,(cli_data_sp) 
5e2c e5				push hl 
5e2d 7c				ld a,h 
5e2e 21 c3 f4			ld hl, os_word_scratch 
5e31 cd d1 12			call hexout 
5e34 e1				pop hl 
5e35 7d				ld a,l 
5e36 21 c5 f4			ld hl, os_word_scratch+2 
5e39 cd d1 12			call hexout 
5e3c 21 c7 f4			ld hl, os_word_scratch+4 
5e3f 3e 00			ld a,0 
5e41 77				ld (hl),a 
5e42 11 c3 f4			ld de,os_word_scratch 
5e45 3e 33				ld a, display_row_2 + 11 
5e47 cd af 0d				call str_at_display 
5e4a			 
5e4a			 
5e4a cd bf 0d			call update_display 
5e4d cd df 0c			call delay1s 
5e50 cd df 0c			call delay1s 
5e53 e1				pop hl 
5e54			.skipdsp: 
5e54 f1				pop af 
5e55 c9				ret 
5e56			 
5e56			display_data_malloc: 
5e56			 
5e56 f5				push af 
5e57 e5				push hl 
5e58 e5				push hl 
5e59 e5			push hl 
5e5a cd 9c 0d			call clear_display 
5e5d e1			pop hl 
5e5e 7c				ld a,h 
5e5f 21 c3 f4			ld hl, os_word_scratch 
5e62 cd d1 12			call hexout 
5e65 e1				pop hl 
5e66 7d				ld a,l 
5e67 21 c5 f4			ld hl, os_word_scratch+2 
5e6a cd d1 12			call hexout 
5e6d 21 c7 f4			ld hl, os_word_scratch+4 
5e70 3e 00			ld a,0 
5e72 77				ld (hl),a 
5e73 11 c3 f4			ld de,os_word_scratch 
5e76 3e 28				ld a, display_row_2 
5e78 cd af 0d				call str_at_display 
5e7b 11 a3 5d			ld de, .push_malloc 
5e7e 3e 00			ld a, display_row_1 
5e80			 
5e80 cd af 0d				call str_at_display 
5e83			 
5e83				; display current data stack pointer 
5e83 11 69 5d			ld de,.data_sp 
5e86 3e 30				ld a, display_row_2 + 8 
5e88 cd af 0d				call str_at_display 
5e8b			 
5e8b 2a eb f9			ld hl,(cli_data_sp) 
5e8e e5				push hl 
5e8f 7c				ld a,h 
5e90 21 c3 f4			ld hl, os_word_scratch 
5e93 cd d1 12			call hexout 
5e96 e1				pop hl 
5e97 7d				ld a,l 
5e98 21 c5 f4			ld hl, os_word_scratch+2 
5e9b cd d1 12			call hexout 
5e9e 21 c7 f4			ld hl, os_word_scratch+4 
5ea1 3e 00			ld a,0 
5ea3 77				ld (hl),a 
5ea4 11 c3 f4			ld de,os_word_scratch 
5ea7 3e 33				ld a, display_row_2 + 11 
5ea9 cd af 0d				call str_at_display 
5eac			 
5eac cd bf 0d			call update_display 
5eaf cd df 0c			call delay1s 
5eb2 cd df 0c			call delay1s 
5eb5 e1				pop hl 
5eb6 f1				pop af 
5eb7 c9				ret 
5eb8			;endif 
5eb8			 
5eb8			include "forth_autostart.asm" 
5eb8			; list of commands to perform at system start up 
5eb8			 
5eb8			startcmds: 
5eb8			;	dw test11 
5eb8			;	dw test12 
5eb8			;	dw test13 
5eb8			;	dw test14 
5eb8			;	dw test15 
5eb8			;	dw test16 
5eb8			;	dw test17 
5eb8			;	dw ifthtest1 
5eb8			;	dw ifthtest2 
5eb8			;	dw ifthtest3 
5eb8			;	dw mmtest1 
5eb8			;	dw mmtest2 
5eb8			;	dw mmtest3 
5eb8			;	dw mmtest4 
5eb8			;	dw mmtest5 
5eb8			;	dw mmtest6 
5eb8			;	dw iftest1 
5eb8			;	dw iftest2 
5eb8			;	dw iftest3 
5eb8			;	dw looptest1 
5eb8			;	dw looptest2 
5eb8			;	dw test1 
5eb8			;	dw test2 
5eb8			;	dw test3 
5eb8			;	dw test4 
5eb8			;	dw game2r 
5eb8			;	dw game2b1 
5eb8			;	dw game2b2 
5eb8			 
5eb8				; start up words that are actually useful 
5eb8			 
5eb8			;    dw spi1 
5eb8			;    dw spi2 
5eb8			;    dw spi3 
5eb8			;    dw spi4 
5eb8			;    dw spi5 
5eb8			;    dw spi6 
5eb8			;    dw spi7 
5eb8			; 
5eb8			;    dw spi8 
5eb8			;    dw spi9 
5eb8			;    dw spi10 
5eb8			 
5eb8			; file editor 
5eb8			;	dw edit1 
5eb8			;	dw edit2 
5eb8			;	dw edit3 
5eb8			 
5eb8			;	dw longread 
5eb8 b8 62			dw clrstack 
5eba ec 62			dw type 
5ebc			;	dw stest 
5ebc 11 63			dw strncpy 
5ebe			;	dw list 
5ebe 72 63			dw start1 
5ec0 82 63			dw start2 
5ec2			;	dw start3 
5ec2			;	dw start3b 
5ec2			;	dw start3c 
5ec2			 
5ec2				; (unit) testing words 
5ec2			 
5ec2			;	dw mtesta 
5ec2			;	dw mtestb 
5ec2			;	dw mtestc 
5ec2			;	dw mtestd 
5ec2			;	dw mteste 
5ec2			 
5ec2				; demo/game words 
5ec2			 
5ec2			;        dw game3w 
5ec2			;        dw game3p 
5ec2			;        dw game3sc 
5ec2			;        dw game3vsi 
5ec2			;        dw game3vs 
5ec2				 
5ec2 db 6d			dw game2b 
5ec4 49 6e			dw game2bf 
5ec6 93 6e			dw game2mba 
5ec8 29 6f			dw game2mbas 
5eca 6b 6f			dw game2mb 
5ecc			 
5ecc 9c 6a			dw game1 
5ece ad 6a			dw game1a 
5ed0 0f 6b			dw game1b 
5ed2 44 6b			dw game1c 
5ed4 7a 6b			dw game1d 
5ed6 ab 6b			dw game1s 
5ed8 bf 6b			dw game1t 
5eda d4 6b			dw game1f 
5edc 08 6c			dw game1z 
5ede 4c 6c			dw game1zz 
5ee0			 
5ee0 b6 68			dw test5 
5ee2 ee 68			dw test6 
5ee4 26 69			dw test7 
5ee6 3a 69			dw test8 
5ee8 66 69			dw test9 
5eea 7c 69			dw test10 
5eec				 
5eec 23 6d		        dw ssv5 
5eee 07 6d		        dw ssv4 
5ef0 eb 6c		        dw ssv3 
5ef2 b5 6c		        dw ssv2 
5ef4 3c 6d		        dw ssv1 
5ef6 84 6d		        dw ssv1cpm 
5ef8			;	dw keyup 
5ef8			;	dw keydown 
5ef8			;	dw keyleft 
5ef8			;	dw keyright 
5ef8			;	dw 	keyf1 
5ef8			;	dw keyf2 
5ef8			;	dw keyf3 
5ef8			;	dw keyf4 
5ef8			;	dw keyf5 
5ef8			;	dw keyf6 
5ef8			;	dw keyf7 
5ef8			;	dw keyf8 
5ef8			;	dw keyf9 
5ef8			;	dw keyf10 
5ef8			;	dw keyf11 
5ef8			;	dw keyf12 
5ef8			;	dw keytab 
5ef8			;	dw keycr 
5ef8			;	dw keyhome 
5ef8			;	dw keyend 
5ef8			;	dw keybs 
5ef8 00 00			db 0, 0	 
5efa			 
5efa			 
5efa			; File Editor 
5efa			 
5efa			; ( id - ) use 'e' to edit the displayed line 
5efa .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f1b .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f50			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f50 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5f88			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5f88			 
5f88			; SPI Net support words 
5f88			 
5f88			; v0! = node to send to 
5f88			; ( str count - ) 
5f88 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5fe1			 
5fe1			; spiputchr ( char node - ) 
5fe1 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
6017			 
6017			; spigetchr ( - n ) 
6017 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
6042			 
6042			; getnode ( - n ) 
6042 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
606f			 
606f			; ( str node - )  
606f .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
60d5			; store string ( str i - ) 
60d5			 
60d5			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
60d5 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
612a			 
612a			; get string ( addr i -  )    TO FIX 
612a			 
612a .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6182			 
6182			 
6182			; NETCHAT (TODO) 
6182			; Program to allow two nodes to chat with eachother 
6182			; 
6182			; v0 - target node 
6182			;  
6182			; accept input at 0,0 
6182			; if input is string send spitype to target node 
6182			; starting at row 2,0 , while spigetchr is not zero ->  
6182			; 
6182			; 
6182			; TODO add paging of get request 
6182			 
6182			; ( node - ) 
6182 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61a1 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
61f9 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6271			 
6271			 
6271			; Long read of currently open file 
6271 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62b8			 
62b8			; clear stack  
62b8			 
62b8 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
62ec			 
62ec			; type ( addr count - ) 
62ec .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6311			 
6311			; some direct memory words 
6311			; strncpy ( len t f -- t ) 
6311			 
6311 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6372			 
6372 .. 00		start1:     	db ": bpon $00 bp ;",0 
6382 .. 00		start2:     	db ": bpoff $01 bp ;",0 
6393 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
640e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
646e			 
646e			 
646e			; a handy word to list items on the stack 
646e			 
646e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
64d8			 
64d8			 
64d8			; test stack  
64d8			; rnd8 stest 
64d8			 
64d8 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
654f			 
654f			; random malloc and free cycles 
654f			 
654f .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6604			 
6604			; fixed malloc and free cycles 
6604			 
6604 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66a7			 
66a7			; fixed double string push and drop cycle  
66a7			 
66a7 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
675c			 
675c			; consistent fixed string push and drop cycle  
675c			 
675c .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6800			 
6800 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
68b6			 
68b6			;test1:		db ": aa 1 2 3 ;", 0 
68b6			;test2:     	db "111 aa 888 999",0 
68b6			;test3:     	db ": bb 77 ;",0 
68b6			;test4:     	db "$02 $01 do i . loop bb",0 
68b6			 
68b6 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
68ee .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6926 .. 00		test7:     	db ": box hline vline ;",0 
693a .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6966 .. 00		test9:     	db ": sw $01 adsp world ;",0 
697c .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69a1 .. 00		test11:     	db "hello create .",0 
69b0 .. 00		test12:     	db "hello2 create .",0 
69c0			 
69c0			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
69c0			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
69c0			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
69c0			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
69c0			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
69c0			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
69c0			 
69c0			;iftest1:     	db "$0001 IF cls .",0 
69c0			;iftest2:     	db "$0000 IF cls .",0 
69c0			;iftest3:     	db "$0002 $0003 - IF cls .",0 
69c0			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
69c0			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
69c0			 
69c0			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69c0			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69c0			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69c0			 
69c0			 
69c0 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
69e4 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6a14 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6a39 .. 00		sound4: db ": cha $00 ; ",0 
6a46 .. 00		sound5: db ": chb $20 ; ",0 
6a53 .. 00		sound6: db ": chc $40 ; ",0 
6a60 .. 00		sound7: db ": chd $60 ; ",0 
6a6d .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6a85 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6a9c			 
6a9c			 
6a9c			 
6a9c			 
6a9c			; a small guess the number game 
6a9c			 
6a9c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6aad .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6b0f			 
6b0f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6b44 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6b7a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6bab .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6bbf .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6bd4 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6c08 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6c4c			 
6c4c			; Using 'ga' save a high score across multiple runs using external storage 
6c4c			 
6c4c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6cb5			 
6cb5			 
6cb5			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6cb5			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6cb5			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6cb5			 
6cb5			; simple screen saver to test code memory reuse to destruction 
6cb5			 
6cb5 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6ceb .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6d07 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6d23 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6d3c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d84 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6ddb			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6ddb			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6ddb			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6ddb			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6ddb			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6ddb			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6ddb			 
6ddb			 
6ddb			 
6ddb			; minesweeper/battleship finding game 
6ddb			; draws a game board of random ship/mine positions 
6ddb			; user enters coords to see if it hits on 
6ddb			; game ends when all are hit 
6ddb			; when hit or miss says how many may be in the area 
6ddb			 
6ddb			; setup the game board and then hide it 
6ddb .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6e49 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6e93			; prompt for where to target 
6e93 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6f29 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6f4e			; TODO see if the entered coords hits or misses pushes char hit of miss 
6f4e .. 00		game2mbht:      db ": mbckht nop ;",0 
6f5d .. 00		game2mbms:      db ": mbcms nop ;",0 
6f6b			; TODO how many might be near by 
6f6b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6fe8			 
6fe8			; Game 3 
6fe8			 
6fe8			; Vert scroller ski game - avoid the trees! 
6fe8			 
6fe8			; v0 score (ie turns) 
6fe8			; v1 player pos 
6fe8			; v2 left wall 
6fe8			; v3 right wall 
6fe8			 
6fe8			; Draw side walls randomly 
6fe8			 
6fe8 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7016			 
7016			; Draw player 
7016 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7034			 
7034			; TODO Get Key 
7034			 
7034			; TODO Move left right 
7034			 
7034			; scroll and move walls a bit 
7034			 
7034 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
7065			 
7065			; main game loop 
7065			 
7065 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
7091 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
70d0			 
70d0			; key board defs 
70d0			 
70d0 .. 00		keyup:       db ": keyup $05 ;",0 
70de .. 00		keydown:       db ": keydown $0a ;",0 
70ee .. 00		keyleft:       db ": keyleft $0b ;",0 
70fe .. 00		keyright:       db ": keyright $0c ;",0 
710f .. 00		keyf1:       db ": keyf1 $10 ;",0 
711d .. 00		keyf2:       db ": keyf2 $11 ;",0 
712b .. 00		keyf3:       db ": keyf3 $12 ;",0 
7139 .. 00		keyf4:       db ": keyf4 $13 ;",0 
7147 .. 00		keyf5:       db ": keyf5 $14 ;",0 
7155 .. 00		keyf6:       db ": keyf6 $15 ;",0 
7163 .. 00		keyf7:       db ": keyf7 $16 ;",0 
7171 .. 00		keyf8:       db ": keyf8 $17 ;",0 
717f .. 00		keyf9:       db ": keyf9 $18 ;",0 
718d .. 00		keyf10:       db ": keyf10 $19 ;",0 
719c .. 00		keyf11:       db ": keyf11 $1a ;",0 
71ab .. 00		keyf12:       db ": keyf12 $1b ;",0 
71ba			 
71ba .. 00		keytab:       db ": keytab $09 ;",0 
71c9 .. 00		keycr:       db ": keycr $0d ;",0 
71d7 .. 00		keyhome:       db ": keyhome $0e ;",0 
71e7 .. 00		keyend:       db ": keyend $0f ;",0 
71f6 .. 00		keybs:       db ": keybs $08 ;",0 
7204			 
7204			   
7204			 
7204			 
7204			 
7204			; eof 
# End of file forth_autostart.asm
7204			 
7204			 
7204			 
7204			; stack over and underflow checks 
7204			 
7204			; init the words to detect the under/overflow 
7204			 
7204			chk_stk_init: 
7204				; a vague random number to check so we dont get any "lucky" hits 
7204 3e 2d			ld a, 45 
7206 6f				ld l, a 
7207 00				nop 
7208 3e 17			ld a, 23 
720a 67				ld h, a 
720b			 
720b 22 a6 f1			ld (chk_word), hl     ; the word we need to check against 
720e			 
720e			;	ld (chk_stund), hl	; stack points.... 
720e 22 fd fe			ld (chk_stovr), hl 
7211 22 e9 f9			ld (chk_ret_und), hl 
7214 22 a7 f9			ld (chk_ret_ovr), hl 
7217 22 25 f9			ld (chk_loop_ovr), hl 
721a 22 23 f7			ld (chk_data_ovr), hl 
721d c9				ret 
721e				 
721e			check_stacks: 
721e				; check all stack words 
721e			 
721e e5				push hl 
721f d5				push de 
7220			 
7220			;	ld de,(chk_word) 
7220			;	ld hl, (chk_stund)	; stack points.... 
7220			;	if DEBUG_STK_FAULT 
7220			;		DMARK "FAa" 
7220			;		CALLMONITOR 
7220			;	endif 
7220			;	call cmp16 
7220			;	jp z, .chk_faulta 
7220			; 
7220			;	ld de, sfaultsu 
7220			;	jp .chk_fault 
7220			 
7220 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7223 ed 5b a6 f1		ld de,(chk_word) 
7227				if DEBUG_STK_FAULT 
7227					DMARK "FAb" 
7227					CALLMONITOR 
7227				endif 
7227 cd ee 0f			call cmp16 
722a 28 06			jr z, .chk_fault1 
722c 11 cd 72			ld de, sfaultso 
722f c3 81 72			jp .chk_fault 
7232			.chk_fault1:  
7232 2a e9 f9			ld hl, (chk_ret_und) 
7235 ed 5b a6 f1		ld de,(chk_word) 
7239				if DEBUG_STK_FAULT 
7239					DMARK "FAU" 
7239					CALLMONITOR 
7239				endif 
7239 cd ee 0f			call cmp16 
723c ca 45 72			jp z, .chk_fault2 
723f 11 dd 72			ld de, sfaultru 
7242 c3 81 72			jp .chk_fault 
7245			.chk_fault2:  
7245 2a a7 f9			ld hl, (chk_ret_ovr) 
7248 ed 5b a6 f1		ld de,(chk_word) 
724c				if DEBUG_STK_FAULT 
724c					DMARK "FA1" 
724c					CALLMONITOR 
724c				endif 
724c cd ee 0f			call cmp16 
724f ca 58 72			jp z, .chk_fault3 
7252 11 eb 72			ld de, sfaultro 
7255 c3 81 72			jp .chk_fault 
7258			.chk_fault3:  
7258 2a 25 f9			ld hl, (chk_loop_ovr) 
725b ed 5b a6 f1		ld de,(chk_word) 
725f				if DEBUG_STK_FAULT 
725f					DMARK "FA2" 
725f					CALLMONITOR 
725f				endif 
725f cd ee 0f			call cmp16 
7262 ca 6b 72			jp z, .chk_fault4 
7265 11 05 73			ld de, sfaultlo 
7268 c3 81 72			jp .chk_fault 
726b			.chk_fault4:  
726b 2a 23 f7			ld hl, (chk_data_ovr) 
726e ed 5b a6 f1		ld de,(chk_word) 
7272				if DEBUG_STK_FAULT 
7272					DMARK "FA3" 
7272					CALLMONITOR 
7272				endif 
7272 cd ee 0f			call cmp16 
7275 ca 7e 72			jp z, .chk_fault5 
7278 11 1f 73			ld de, sfaultdo 
727b c3 81 72			jp .chk_fault 
727e			 
727e			 
727e			.chk_fault5:  
727e d1				pop de 
727f e1				pop hl 
7280			 
7280 c9				ret 
7281			 
7281 cd 9c 0d		.chk_fault: 	call clear_display 
7284 3e 28				ld a, display_row_2 
7286 cd af 0d				call str_at_display 
7289 11 af 72				   ld de, .stackfault 
728c 3e 00				ld a, display_row_1 
728e cd af 0d				call str_at_display 
7291 11 68 fe				    ld de, debug_mark 
7294 3e 11				ld a, display_row_1+17 
7296 cd af 0d				call str_at_display 
7299 cd bf 0d				call update_display 
729c			 
729c				; prompt before entering montior for investigating issue 
729c			 
729c 3e 78			ld a, display_row_4 
729e 11 05 1e			ld de, endprog 
72a1			 
72a1 cd bf 0d			call update_display		 
72a4			 
72a4 cd 8b 20			call next_page_prompt 
72a7			 
72a7 d1				pop de 
72a8 e1				pop hl 
72a9 cd 59 1e				call monitor 
72ac c3 53 1d				jp warmstart 
72af					;jp 0 
72af					;halt 
72af			 
72af			 
72af			 
72af .. 00		.stackfault: 	db "Stack fault:",0 
72bc			 
72bc .. 00		sfaultsu: 	db	"Stack under flow",0 
72cd .. 00		sfaultso: 	db	"Stack over flow",0 
72dd .. 00		sfaultru:	db "RTS underflow",0 
72eb .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7305 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
731f .. 00		sfaultdo:	db "DTS overflow", 0 
732c			 
732c			 
732c			fault_dsp_under: 
732c 11 3e 73			ld de, .dsp_under 
732f c3 ee 73			jp .show_fault 
7332			 
7332			fault_rsp_under: 
7332 11 4c 73			ld de, .rsp_under 
7335 c3 ee 73			jp .show_fault 
7338			fault_loop_under: 
7338 11 5a 73			ld de, .loop_under 
733b c3 ee 73			jp .show_fault 
733e			 
733e .. 00		.dsp_under: db "DSP Underflow",0 
734c .. 00		.rsp_under: db "RSP Underflow",0 
735a .. 00		.loop_under: db "LOOP Underflow",0 
7369			 
7369			 
7369 d5			type_faultn: 	push de 
736a e5					push hl 
736b cd 9c 0d				call clear_display 
736e 11 95 73				   ld de, .typefaultn 
7371 3e 00				ld a, display_row_1 
7373 cd af 0d				call str_at_display 
7376 11 68 fe				    ld de, debug_mark 
7379 3e 11				ld a, display_row_1+17 
737b cd af 0d				call str_at_display 
737e cd bf 0d				call update_display 
7381			 
7381				; prompt before entering montior for investigating issue 
7381			 
7381 3e 78			ld a, display_row_4 
7383 11 05 1e			ld de, endprog 
7386			 
7386 cd bf 0d			call update_display		 
7389			 
7389 cd 8b 20			call next_page_prompt 
738c			 
738c e5					push hl 
738d d5					push de 
738e cd 59 1e				call monitor 
7391 c3 53 1d				jp warmstart 
7394 76					halt 
7395			 
7395			 
7395 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
73ac			 
73ac d5			type_faults: 	push de 
73ad e5					push hl 
73ae cd 9c 0d				call clear_display 
73b1 11 d7 73				   ld de, .typefaults 
73b4 3e 00				ld a, display_row_1 
73b6 cd af 0d				call str_at_display 
73b9 11 68 fe				    ld de, debug_mark 
73bc 3e 11				ld a, display_row_1+17 
73be cd af 0d				call str_at_display 
73c1 cd bf 0d				call update_display 
73c4			 
73c4				; prompt before entering montior for investigating issue 
73c4			 
73c4 3e 78			ld a, display_row_4 
73c6 11 05 1e			ld de, endprog 
73c9			 
73c9 cd bf 0d			call update_display		 
73cc			 
73cc cd 8b 20			call next_page_prompt 
73cf			 
73cf e1					pop hl 
73d0 d1					pop de 
73d1 cd 59 1e				call monitor 
73d4 c3 53 1d				jp warmstart 
73d7			 
73d7			 
73d7 .. 00		.typefaults: db "STR Type Expected TOS!",0 
73ee			 
73ee			.show_fault: 	 
73ee d5					push de 
73ef cd 9c 0d				call clear_display 
73f2 d1					pop de 
73f3 3e 00				ld a, display_row_1 
73f5 cd af 0d				call str_at_display 
73f8 11 68 fe				    ld de, debug_mark 
73fb 3e 11				ld a, display_row_1+17 
73fd cd af 0d				call str_at_display 
7400 cd bf 0d				call update_display 
7403			 
7403				; prompt before entering montior for investigating issue 
7403			 
7403 3e 78			ld a, display_row_4 
7405 11 05 1e			ld de, endprog 
7408			 
7408 cd bf 0d			call update_display		 
740b			 
740b cd 8b 20			call next_page_prompt 
740e			 
740e e1					pop hl 
740f d1					pop de 
7410 cd 59 1e				call monitor 
7413			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7413			; TODO Make optional fault restart to cli or warm boot? 
7413					;jp warmstart 
7413 c3 ab 1d				jp cli 
7416 76					halt 
7417			 
7417			; handle the auto run of code from files in storage 
7417			 
7417			 
7417			include "forth_startup.asm" 
7417			; Which startup method to use? 
7417			; 
7417			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7417			; followed by loading of a list of scripts in eeprom 
7417			 
7417			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7417			; from eeprom 
7417			 
7417			; Select with define in main stubs 
7417			 
7417			if STARTUP_V1 
7417				include "forth_startupv1.asm" 
7417			endif 
7417			if STARTUP_V2 
7417				include "forth_startupv2.asm" 
7417			; Version 2 of the startup  
7417			;  
7417			; Auto load any files in bank 1 that start with a '*' 
7417			; If no se storage then revert to using eprom 
7417			 
7417			 
7417			if STORAGE_SE = 0 
7417			 
7417			sprompt1: db "Startup load...",0 
7417			sprompt2: db "Run? 1=No *=End #=All",0 
7417			 
7417			 
7417			 
7417			 
7417			forth_startup: 
7417				ld hl, startcmds 
7417				ld a, 0 
7417				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7417			 
7417			.start1:	push hl 
7417				call clear_display 
7417				ld de, sprompt1 
7417			        ld a, display_row_1 
7417				call str_at_display 
7417				ld de, sprompt2 
7417			        ld a, display_row_2 
7417				call str_at_display 
7417				pop hl 
7417				push hl 
7417				ld e,(hl) 
7417				inc hl 
7417				ld d,(hl) 
7417			        ld a, display_row_3 
7417				call str_at_display 
7417				call update_display 
7417			 
7417			 
7417				ld a, (os_last_cmd) 
7417				cp 0 
7417				jr z, .startprompt 
7417				call delay250ms 
7417				jr .startdo 
7417				 
7417				 
7417			 
7417			.startprompt: 
7417			 
7417				ld a,display_row_4 + display_cols - 1 
7417			        ld de, endprg 
7417				call str_at_display 
7417				call update_display 
7417				call delay1s 
7417				call cin_wait 
7417						 
7417				cp '*' 
7417				jr z, .startupend1 
7417				cp '#' 
7417				jr nz, .startno 
7417				ld a, 1 
7417				ld (os_last_cmd),a 
7417				jr .startdo 
7417			.startno:	cp '1' 
7417				jr z,.startnxt  
7417			 
7417				; exec startup line 
7417			.startdo:	 
7417				pop hl 
7417				push hl 
7417				 
7417				ld e,(hl) 
7417				inc hl 
7417				ld d,(hl) 
7417				ex de,hl 
7417			 
7417				push hl 
7417			 
7417				ld a, 0 
7417				;ld a, FORTH_END_BUFFER 
7417				call strlent 
7417				inc hl   ; include zero term to copy 
7417				ld b,0 
7417				ld c,l 
7417				pop hl 
7417				ld de, scratch 
7417				ldir 
7417			 
7417			 
7417				ld hl, scratch 
7417				call forthparse 
7417				call forthexec 
7417				call forthexec_cleanup 
7417			 
7417				ld a, display_row_4 
7417				ld de, endprog 
7417			 
7417				call update_display		 
7417			 
7417				ld a, (os_last_cmd) 
7417				cp 0 
7417				jr nz, .startnxt 
7417				call next_page_prompt 
7417			        call clear_display 
7417				call update_display		 
7417			 
7417				; move onto next startup line? 
7417			.startnxt: 
7417			 
7417				call delay250ms 
7417				pop hl 
7417			 
7417				inc hl 
7417				inc hl 
7417			 
7417				push hl 
7417				ld e, (hl) 
7417				inc hl 
7417				ld d, (hl) 
7417				pop hl 
7417				; TODO replace 0 test 
7417			 
7417				ex de, hl 
7417				call ishlzero 
7417			;	ld a,e 
7417			;	add d 
7417			;	cp 0    ; any left to do? 
7417				ex de, hl 
7417				jp nz, .start1 
7417				jr .startupend 
7417			 
7417			.startupend1: pop hl 
7417			.startupend: 
7417			 
7417				call clear_display 
7417				call update_display 
7417				ret 
7417			endif 
7417			 
7417			 
7417			if STORAGE_SE 
7417			 
7417			;sprompt3: db "Loading from start-up file:",0 
7417 .. 00		sprompt3: db "  Searching...",0 
7426			;sprompt4: db "(Any key to stop)",0 
7426			 
7426			 
7426			forth_autoload: 
7426			 
7426				; load block 0 of store 1 
7426				 
7426 3e fe			ld a, $fe      ; bit 0 clear 
7428 32 5d fa			ld (spi_device), a 
742b			 
742b cd 17 05			call storage_get_block_0 
742e			 
742e 3a 98 fa			ld a, (store_page+STORE_0_AUTOFILE) 
7431			 
7431 fe 00			cp 0 
7433 c8				ret z     ; auto start not enabled 
7434			 
7434 cd 9c 0d			call clear_display 
7437			 
7437				; set bank 
7437			 
7437 3a 9a fa				ld a, (store_page+STORE_0_BANKRUN) 
743a 32 5d fa				ld (spi_device), a 
743d			 
743d			 
743d				; generate a directory of bank 1 and search for flagged files 
743d			 
743d					if DEBUG_FORTH_WORDS_KEY 
743d						DMARK "DIR" 
743d f5				push af  
743e 3a 52 74			ld a, (.dmark)  
7441 32 68 fe			ld (debug_mark),a  
7444 3a 53 74			ld a, (.dmark+1)  
7447 32 69 fe			ld (debug_mark+1),a  
744a 3a 54 74			ld a, (.dmark+2)  
744d 32 6a fe			ld (debug_mark+2),a  
7450 18 03			jr .pastdmark  
7452 ..			.dmark: db "DIR"  
7455 f1			.pastdmark: pop af  
7456			endm  
# End of macro DMARK
7456						CALLMONITOR 
7456 cd 6c fe			call debug_vector  
7459				endm  
# End of macro CALLMONITOR
7459					endif 
7459			 
7459 cd 17 05			call storage_get_block_0 
745c			 
745c 21 77 fa			ld hl, store_page     ; get current id count 
745f 46				ld b, (hl) 
7460 0e 00			ld c, 0    ; count of files   
7462					if DEBUG_FORTH_WORDS 
7462						DMARK "DI1" 
7462 f5				push af  
7463 3a 77 74			ld a, (.dmark)  
7466 32 68 fe			ld (debug_mark),a  
7469 3a 78 74			ld a, (.dmark+1)  
746c 32 69 fe			ld (debug_mark+1),a  
746f 3a 79 74			ld a, (.dmark+2)  
7472 32 6a fe			ld (debug_mark+2),a  
7475 18 03			jr .pastdmark  
7477 ..			.dmark: db "DI1"  
747a f1			.pastdmark: pop af  
747b			endm  
# End of macro DMARK
747b						CALLMONITOR 
747b cd 6c fe			call debug_vector  
747e				endm  
# End of macro CALLMONITOR
747e					endif 
747e			 
747e				; check for empty drive 
747e			 
747e 3e 00			ld a, 0 
7480 b8				cp b 
7481 ca ce 74			jp z, .dirdone 
7484			 
7484				; for each of the current ids do a search for them and if found push to stack 
7484			 
7484 c5			.diritem:	push bc 
7485 21 40 00				ld hl, STORE_BLOCK_PHY 
7488 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
748a 58					ld e,b 
748b			 
748b d5					push de 
748c e5					push hl 
748d cd 9c 0d			call clear_display 
7490 3e 32			ld a, display_row_2 + 10 
7492 11 17 74			ld de, sprompt3 
7495 cd af 0d			call str_at_display 
7498 cd f3 0c			call active 
749b eb				ex de, hl 
749c 3e 2f			ld a, display_row_2 + 7 
749e cd af 0d			call str_at_display 
74a1 cd bf 0d			call update_display 
74a4 e1				pop hl 
74a5 d1				pop de 
74a6			 
74a6			;		if DEBUG_FORTH_WORDS 
74a6			;			DMARK "DI2" 
74a6			;			CALLMONITOR 
74a6			;		endif 
74a6			 
74a6 cd 99 07				call storage_findnextid 
74a9			 
74a9			;		if DEBUG_FORTH_WORDS 
74a9			;			DMARK "DI3" 
74a9			;			CALLMONITOR 
74a9			;		endif 
74a9			 
74a9					; if found hl will be non zero 
74a9			 
74a9 cd f9 0f				call ishlzero 
74ac			;		ld a, l 
74ac			;		add h 
74ac			; 
74ac			;		cp 0 
74ac 28 1d				jr z, .dirnotfound 
74ae			 
74ae					; increase count 
74ae			 
74ae c1					pop bc	 
74af 0c					inc c 
74b0 c5					push bc 
74b1					 
74b1			 
74b1					; get file header and push the file name 
74b1			 
74b1 11 77 fa				ld de, store_page 
74b4 cd 66 04				call storage_read_block 
74b7			 
74b7					; push file id to stack 
74b7				 
74b7			 
74b7					; is this a file we want to run? 
74b7			 
74b7 21 7a fa				ld hl, store_page+3 
74ba 7e					ld a,(hl) 
74bb fe 2a				cp '*' 
74bd 20 0c				jr nz,  .dirnotfound 
74bf					 
74bf			 
74bf			 
74bf 3a 77 fa				ld a, (store_page) 
74c2 d5					push de 
74c3 e5					push hl 
74c4 c5					push bc 
74c5 cd f1 74				call .autorunf 
74c8 c1					pop bc 
74c9 e1					pop hl 
74ca d1					pop de 
74cb			 
74cb			 
74cb			 
74cb				; save this extent 
74cb			 
74cb					; push file name 
74cb			;display file name to run 
74cb			 
74cb			;		ld hl, store_page+3 
74cb			;		if DEBUG_FORTH_WORDS 
74cb			;			DMARK "DI5" 
74cb			;			CALLMONITOR 
74cb			;		endif 
74cb			; 
74cb			;		 
74cb			; 
74cb			;		call forth_push_str 
74cb			;		if DEBUG_FORTH_WORDS 
74cb			;			DMARK "DI6" 
74cb			;			CALLMONITOR 
74cb			;		endif 
74cb			.dirnotfound: 
74cb c1					pop bc     
74cc 10 b6				djnz .diritem 
74ce				 
74ce			.dirdone:	 
74ce					if DEBUG_FORTH_WORDS 
74ce						DMARK "DI7" 
74ce f5				push af  
74cf 3a e3 74			ld a, (.dmark)  
74d2 32 68 fe			ld (debug_mark),a  
74d5 3a e4 74			ld a, (.dmark+1)  
74d8 32 69 fe			ld (debug_mark+1),a  
74db 3a e5 74			ld a, (.dmark+2)  
74de 32 6a fe			ld (debug_mark+2),a  
74e1 18 03			jr .pastdmark  
74e3 ..			.dmark: db "DI7"  
74e6 f1			.pastdmark: pop af  
74e7			endm  
# End of macro DMARK
74e7						CALLMONITOR 
74e7 cd 6c fe			call debug_vector  
74ea				endm  
# End of macro CALLMONITOR
74ea					endif 
74ea			 
74ea cd 9c 0d				call clear_display 
74ed cd bf 0d				call update_display 
74f0			 
74f0 c9					ret 
74f1			 
74f1			 
74f1			 
74f1			 
74f1			 
74f1			.autorunf: 
74f1			 
74f1			 
74f1				; get file id to load from and get the file name to display 
74f1			 
74f1			;		ld a, (store_page+STORE_0_FILERUN) 
74f1			 
74f1 2e 00				ld l, 0 
74f3 67					ld h, a 
74f4 11 77 fa				ld de, store_page 
74f7			 
74f7					if DEBUG_FORTH_WORDS 
74f7						DMARK "ASp" 
74f7 f5				push af  
74f8 3a 0c 75			ld a, (.dmark)  
74fb 32 68 fe			ld (debug_mark),a  
74fe 3a 0d 75			ld a, (.dmark+1)  
7501 32 69 fe			ld (debug_mark+1),a  
7504 3a 0e 75			ld a, (.dmark+2)  
7507 32 6a fe			ld (debug_mark+2),a  
750a 18 03			jr .pastdmark  
750c ..			.dmark: db "ASp"  
750f f1			.pastdmark: pop af  
7510			endm  
# End of macro DMARK
7510						CALLMONITOR 
7510 cd 6c fe			call debug_vector  
7513				endm  
# End of macro CALLMONITOR
7513					endif 
7513 cd bf 09				call storage_read 
7516			 
7516					if DEBUG_FORTH_WORDS 
7516						DMARK "ASr" 
7516 f5				push af  
7517 3a 2b 75			ld a, (.dmark)  
751a 32 68 fe			ld (debug_mark),a  
751d 3a 2c 75			ld a, (.dmark+1)  
7520 32 69 fe			ld (debug_mark+1),a  
7523 3a 2d 75			ld a, (.dmark+2)  
7526 32 6a fe			ld (debug_mark+2),a  
7529 18 03			jr .pastdmark  
752b ..			.dmark: db "ASr"  
752e f1			.pastdmark: pop af  
752f			endm  
# End of macro DMARK
752f						CALLMONITOR 
752f cd 6c fe			call debug_vector  
7532				endm  
# End of macro CALLMONITOR
7532					endif 
7532			 
7532 cd f9 0f				call ishlzero 
7535 c8					ret z             ; file not found 
7536			 
7536					; display file name we are loading 
7536			 
7536 cd 9c 0d				call clear_display 
7539			 
7539 3e 32				ld a, display_row_2 + 10 
753b 11 7a fa				ld de, store_page+3 
753e cd af 0d				call str_at_display 
7541				 
7541			; 
7541			 
7541			;	ld a, display_row_1+5 
7541			;	ld de, sprompt3 
7541			;	call str_at_display 
7541			;	ld a, display_row_2+7 
7541			;	call active 
7541			;	ex de, hl 
7541			;;	ld de, sprompt4 
7541			;	call str_at_display 
7541			; 
7541 cd bf 0d			call update_display 
7544			 
7544			;	call cin_wait 
7544			;	cp 'n' 
7544			;	ret z 
7544			;	cp 'N' 
7544			;	ret z 
7544			 
7544			;	call delay1s 
7544			 
7544 3a 79 fa			ld a, (store_page+2) 
7547 32 66 fa			ld (store_openmaxext), a    ; save count of ext 
754a 3e 01			ld a, 1  
754c 32 67 fa			ld (store_openext), a    ; save count of ext 
754f			 
754f			.autof: 
754f				; begin to read a line from file 
754f			 
754f 21 e5 f4			ld hl, os_cli_cmd 
7552 22 e3 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7555			  
7555			.readext: 
7555 3a 67 fa			ld a, (store_openext) 
7558 6f				ld l , a 
7559				 
7559 3a 77 fa			ld a, (store_page) 
755c 67				ld h, a	 
755d 11 77 fa			ld de, store_page 
7560					if DEBUG_FORTH_WORDS 
7560						DMARK "ASl" 
7560 f5				push af  
7561 3a 75 75			ld a, (.dmark)  
7564 32 68 fe			ld (debug_mark),a  
7567 3a 76 75			ld a, (.dmark+1)  
756a 32 69 fe			ld (debug_mark+1),a  
756d 3a 77 75			ld a, (.dmark+2)  
7570 32 6a fe			ld (debug_mark+2),a  
7573 18 03			jr .pastdmark  
7575 ..			.dmark: db "ASl"  
7578 f1			.pastdmark: pop af  
7579			endm  
# End of macro DMARK
7579						CALLMONITOR 
7579 cd 6c fe			call debug_vector  
757c				endm  
# End of macro CALLMONITOR
757c					endif 
757c cd bf 09				call storage_read 
757f cd f9 0f			call ishlzero 
7582 c8				ret z 
7583			 
7583			; TODO copy to exec buffer 
7583			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7583			 
7583				; copy the record buffer to the cli buffer 
7583			 
7583 ed 5b e3 f6		ld de, (os_var_array) 
7587 21 79 fa			ld hl, store_page+2 
758a			;	ex de, hl 
758a 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
758d ed b0			ldir 
758f ed 53 e3 f6		ld (os_var_array), de 
7593				 
7593 3a 67 fa			ld a, (store_openext) 
7596 3c				inc a 
7597 32 67 fa			ld (store_openext), a    ; save count of ext 
759a			 
759a			 
759a			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
759a				 
759a 3a 6a fa			ld a, (store_readcont) 
759d fe 00			cp 0 
759f 20 b4			jr nz, .readext 
75a1			 
75a1			;	jr z, .autoend 
75a1			 
75a1					if DEBUG_FORTH_WORDS 
75a1						DMARK "ASc" 
75a1 f5				push af  
75a2 3a b6 75			ld a, (.dmark)  
75a5 32 68 fe			ld (debug_mark),a  
75a8 3a b7 75			ld a, (.dmark+1)  
75ab 32 69 fe			ld (debug_mark+1),a  
75ae 3a b8 75			ld a, (.dmark+2)  
75b1 32 6a fe			ld (debug_mark+2),a  
75b4 18 03			jr .pastdmark  
75b6 ..			.dmark: db "ASc"  
75b9 f1			.pastdmark: pop af  
75ba			endm  
# End of macro DMARK
75ba						CALLMONITOR 
75ba cd 6c fe			call debug_vector  
75bd				endm  
# End of macro CALLMONITOR
75bd					endif 
75bd e5				push hl	 
75be d5				push de 
75bf cd f3 0c			call active 
75c2 eb				ex de, hl 
75c3 3e 2f			ld a, display_row_2 + 7 
75c5 cd af 0d			call str_at_display 
75c8			 
75c8 cd bf 0d			call update_display 
75cb d1				pop de  
75cc e1				pop hl 
75cd			;	call delay250ms 
75cd			 
75cd			 
75cd			 
75cd			 
75cd			.autoexec: 
75cd			 
75cd			 
75cd 21 e5 f4			ld hl, os_cli_cmd 
75d0					if DEBUG_FORTH_WORDS 
75d0						DMARK "ASx" 
75d0 f5				push af  
75d1 3a e5 75			ld a, (.dmark)  
75d4 32 68 fe			ld (debug_mark),a  
75d7 3a e6 75			ld a, (.dmark+1)  
75da 32 69 fe			ld (debug_mark+1),a  
75dd 3a e7 75			ld a, (.dmark+2)  
75e0 32 6a fe			ld (debug_mark+2),a  
75e3 18 03			jr .pastdmark  
75e5 ..			.dmark: db "ASx"  
75e8 f1			.pastdmark: pop af  
75e9			endm  
# End of macro DMARK
75e9						CALLMONITOR 
75e9 cd 6c fe			call debug_vector  
75ec				endm  
# End of macro CALLMONITOR
75ec					endif 
75ec cd 0e 25			call forthparse 
75ef cd 4e 25			call forthexec 
75f2 cd 60 24			call forthexec_cleanup 
75f5			 
75f5			 
75f5			 
75f5 c3 4f 75			jp .autof 
75f8			;.autofdone: 
75f8			; 
75f8			;		if DEBUG_FORTH_WORDS 
75f8			;			DMARK "ASx" 
75f8			;			CALLMONITOR 
75f8			;		endif 
75f8			;;	call clear_display 
75f8			;	ret 
75f8			 
75f8			 
75f8			 
75f8			endif 
# End of file forth_startupv2.asm
75f8			endif 
75f8			 
# End of file forth_startup.asm
75f8			 
75f8			; eof 
# End of file forth_kernel.asm
75f8			;include "nascombasic.asm" 
75f8			 
75f8			 
75f8			; find out where the code ends if loaded into RAM (for SC114) 
75f8			;endofcode:  
75f8			;	nop 
75f8			 
75f8			 
75f8			; jump to nmi vector 
75f8			 
75f8			init_nmi: 
75f8 3e c9			ld a, $c9   ; RET 
75fa 32 6f fe			ld (nmi_vector), a 
75fd c9				ret 
75fe			nmi: 
75fe e5				push hl 
75ff d5				push de 
7600 c5				push bc 
7601 f5				push af 
7602 cd 6f fe			call nmi_vector 
7605 f5				push af 
7606 c5				push bc 
7607 d5				push de 
7608 e5				push hl 
7609 ed 4d			reti 
760b			 
760b			 
760b			; eof 
760b			 
# End of file main.asm
760b			include "firmware_lcd_4x40.asm" 
760b			; **********************************************************************  
760b			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
760b			; **********************************************************************  
760b			;  
760b			; **  Written as a Small Computer Monitor App  
760b			; **  www.scc.me.uk  
760b			;  
760b			; History  
760b			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
760b			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
760b			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
760b			;  
760b			; **********************************************************************  
760b			;  
760b			; This program is an example of one of the methods of interfacing an   
760b			; alphanumeric LCD module.   
760b			;  
760b			; In this example the display is connected to either a Z80 PIO or a   
760b			; simple 8-bit output port.   
760b			;  
760b			; This interfacing method uses 4-bit data mode and uses time delays  
760b			; rather than polling the display's ready status. As a result the   
760b			; interface only requires 6 simple output lines:  
760b			;   Output bit 0 = not used  
760b			;   Output bit 1 = not used  
760b			;   Output bit 2 = RS         High = data, Low = instruction  
760b			;   Output bit 3 = E          Active high  
760b			;   Output bit 4 = DB4  
760b			;   Output bit 5 = DB5  
760b			;   Output bit 6 = DB6  
760b			;   Output bit 7 = DB7  
760b			; Display's R/W is connected to 0v so it is always in write mode  
760b			;  
760b			; This set up should work with any system supporting the RC2014 bus  
760b			  
760b			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
760b			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
760b			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
760b			;  
760b			; **********************************************************************  
760b			  
760b			; Additonal for 4x40. E1 and E2 instead of just E   
760b			; TODO swipe vidout signal on port a to activate E2  
760b			  
760b			; **********************************************************************  
760b			; **  Constants  
760b			; **********************************************************************  
760b			; LCD constants required by LCD support module  
760b			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
760b			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
760b			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
760b			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
760b			; TODO Decide which E is being set  
760b			kLCDWidth:  EQU display_cols             ;Width in characters  
760b			  
760b			; **********************************************************************  
760b			; **  Code library usage  
760b			; **********************************************************************  
760b			  
760b			; send character to current cursor position  
760b			; wraps and/or scrolls screen automatically  
760b			  
760b			  
760b			  
760b			lcd_init:  
760b			  
760b			; SCMonAPI functions used  
760b			  
760b			; Alphanumeric LCD functions used  
760b			; no need to specify specific functions for this module  
760b			  
760b 3e cf		            LD   A, 11001111b  
760d d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
760f 3e 00		            LD   A, 00000000b  
7611 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7613			  
7613			; Initialise alphanumeric LCD module  
7613 3e 00				ld a, 0  
7615 32 c8 fb				ld (display_lcde1e2), a  
7618 cd 99 76		            CALL fLCD_Init      ;Initialise LCD module  
761b 3e 01				ld a, 1  
761d 32 c8 fb				ld (display_lcde1e2), a  
7620 cd 99 76		            CALL fLCD_Init      ;Initialise LCD module  
7623			  
7623 c9				ret  
7624			  
7624			;  
7624			;;  
7624			; lcd functions  
7624			;  
7624			;  
7624			  
7624			; what is at cursor position   
7624			  
7624			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7624			;		call curptr  
7624			;		ret  
7624			  
7624			  
7624			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7624			  
7624			curptr:  
7624 c5				push bc  
7625 21 ae fd			ld hl, display_fb0  
7628			cpr:	  
7628				; loop for cursor whole row  
7628 0e 28			ld c, display_cols  
762a 23			cpr1:	inc hl  
762b 0d				dec c  
762c 20 fc			jr nz, cpr1  
762e 05				dec b  
762f 20 f7			jr nz, cpr  
7631			  
7631				; add col	  
7631			  
7631 23			cpr2:	inc hl  
7632 1d				dec e  
7633 20 fc			jr nz, cpr2  
7635			  
7635 c1				pop bc  
7636 c9				ret  
7637				  
7637			  
7637			  
7637			  
7637			  
7637			; write the frame buffer given in hl to hardware   
7637 22 c6 fb		write_display: ld (display_write_tmp), hl 	   
763a 3e 00			ld a, kLCD_Line1  
763c cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
763f 06 28			ld b, display_cols  
7641 ed 5b c6 fb		ld de, (display_write_tmp)  
7645 cd 91 76			call write_len_string  
7648				  
7648				  
7648 2a c6 fb			ld hl, (display_write_tmp)  
764b 11 28 00			ld de, display_cols  
764e 19				add hl,de  
764f 22 c6 fb			ld (display_write_tmp),hl  
7652			  
7652				  
7652 3e 28			ld a, kLCD_Line2  
7654 cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7657 06 28			ld b, display_cols  
7659 ed 5b c6 fb		ld de, (display_write_tmp)  
765d cd 91 76			call write_len_string  
7660				  
7660 2a c6 fb			ld hl, (display_write_tmp)  
7663 11 28 00			ld de, display_cols  
7666 19				add hl,de  
7667 22 c6 fb			ld (display_write_tmp),hl  
766a			  
766a				  
766a 3e 50			ld a, kLCD_Line3  
766c cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
766f 06 28			ld b, display_cols  
7671 ed 5b c6 fb		ld de, (display_write_tmp)  
7675 cd 91 76			call write_len_string  
7678				  
7678 2a c6 fb			ld hl, (display_write_tmp)  
767b 11 28 00			ld de, display_cols  
767e 19				add hl,de  
767f 22 c6 fb			ld (display_write_tmp),hl  
7682			  
7682				  
7682 3e 78			ld a, kLCD_Line4  
7684 cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7687 06 28			ld b, display_cols  
7689 ed 5b c6 fb		ld de, (display_write_tmp)  
768d cd 91 76			call write_len_string  
7690 c9					ret  
7691				  
7691				; write out a fixed length string given in b from de  
7691			  
7691 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7692 cd fe 76		            CALL fLCD_Data      ;Write character to display  
7695 13				inc de  
7696 10 f9			djnz write_len_string  
7698 c9				ret  
7699			  
7699			; Some other things to do  
7699			;            LD   A, kLCD_Clear ;Display clear  
7699			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7699			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7699			;            LD   A, kLCD_On     ;Display on with no cursor  
7699			;            ;LD   A, kLCD_Off   ;Display off  
7699			;            CALL fLCD_Inst      ;Send instruction to display  
7699			;  
7699			;  
7699			;            halt  
7699			;  
7699			;  
7699			;MsgHello:   DB  "Hello World!",0  
7699			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7699			  
7699			; Custom characters 5 pixels wide by 8 pixels high  
7699			; Up to 8 custom characters can be defined  
7699			;BitMaps:      
7699			;; Character 0x00 = Battery icon  
7699			;            DB  01110b  
7699			;            DB  11011b  
7699			;            DB  10001b  
7699			;            DB  10001b  
7699			;            DB  11111b  
7699			;            DB  11111b  
7699			;            DB  11111b  
7699			;            DB  11111b  
7699			;; Character 0x01 = Bluetooth icon  
7699			;            DB  01100b  
7699			;            DB  01010b  
7699			;            DB  11100b  
7699			;            DB  01000b  
7699			;            DB  11100b  
7699			;            DB  01010b  
7699			;            DB  01100b  
7699			;            DB  00000b  
7699			;  
7699			  
7699			  
7699			; **********************************************************************  
7699			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7699			; **********************************************************************  
7699			;  
7699			; **  Written as a Small Computer Monitor App   
7699			; **  Version 0.1 SCC 2018-05-16  
7699			; **  www.scc.me.uk  
7699			;  
7699			; **********************************************************************  
7699			;  
7699			; This module provides support for alphanumeric LCD modules using with  
7699			; *  HD44780 (or compatible) controller  
7699			; *  5 x 7 pixel fonts  
7699			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7699			; *  Interface via six digital outputs to the display (see below)  
7699			;  
7699			; LCD module pinout:  
7699			;   1  Vss   0v supply  
7699			;   2  Vdd   5v supply  
7699			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7699			;   4  RS    High = data, Low = instruction  
7699			;   5  R/W   High = Read, Low = Write  
7699			;   6  E     Enable signal (active high)  
7699			;   7  DB0   Data bit 0  
7699			;   8  DB1   Data bit 1  
7699			;   9  DB2   Data bit 2  
7699			;  10  DB3   Data bit 3  
7699			;  11  DB4   Data bit 4  
7699			;  12  DB5   Data bit 5  
7699			;  13  DB6   Data bit 6  
7699			;  14  DB7   Data bit 7  
7699			;  15  A     Backlight anode (+)  
7699			;  16  K     Backlight cathode (-)  
7699			;  
7699			; This interfacing method uses 4-bit data mode and uses time delays  
7699			; rather than polling the display's ready status. As a result the   
7699			; interface only requires 6 simple output lines:  
7699			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7699			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7699			;   LCD DB4 = Microcomputer output port bit 4  
7699			;   LCD DB5 = Microcomputer output port bit 5  
7699			;   LCD DB6 = Microcomputer output port bit 6  
7699			;   LCD DB7 = Microcomputer output port bit 7  
7699			; Display's R/W is connected to 0v so it is always in write mode  
7699			; All 6 connections must be on the same port address <kLCDPrt>  
7699			; This method also allows a decent length of cable from micro to LCD  
7699			;  
7699			; **********************************************************************  
7699			;  
7699			; To include the code for any given function provided by this module,   
7699			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7699			; the parent source file.  
7699			; For example:  #REQUIRES   uHexPrefix  
7699			;  
7699			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7699			; in the parent source file.  
7699			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7699			;  
7699			; These are the function names provided by this module:  
7699			; fLCD_Init                     ;Initialise LCD  
7699			; fLCD_Inst                     ;Send instruction to LCD  
7699			; fLCD_Data                     ;Send data byte to LCD  
7699			; fLCD_Pos                      ;Position cursor  
7699			; fLCD_Str                      ;Display string  
7699			; fLCD_Def                      ;Define custom character  
7699			;  
7699			; **********************************************************************  
7699			;  
7699			; Requires SCMonAPI.asm to also be included in the project  
7699			;  
7699			  
7699			  
7699			; **********************************************************************  
7699			; **  Constants  
7699			; **********************************************************************  
7699			  
7699			; Constants that must be defined externally  
7699			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7699			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7699			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7699			;kLCDWidth: EQU 20             ;Width in characters  
7699			  
7699			; general line offsets in any frame buffer  
7699			  
7699			  
7699			display_row_1: equ 0  
7699			display_row_2: equ display_row_1+display_cols  
7699			display_row_3: equ display_row_2 + display_cols  
7699			display_row_4: equ display_row_3 + display_cols  
7699			;display_row_4_eol:   
7699			  
7699			  
7699			; Cursor position values for the start of each line  
7699			  
7699			; E  
7699			kLCD_Line1: EQU 0x00   
7699			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7699			; E1  
7699			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7699			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7699			  
7699			; Instructions to send as A register to fLCD_Inst  
7699			kLCD_Clear: EQU 00000001b     ;LCD clear  
7699			kLCD_Off:   EQU 00001000b     ;LCD off  
7699			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7699			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7699			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7699			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7699			  
7699			; Constants used by this code module  
7699			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7699			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7699			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7699			  
7699			  
7699			  
7699			; **********************************************************************  
7699			; **  LCD support functions  
7699			; **********************************************************************  
7699			  
7699			; Initialise alphanumeric LCD module  
7699			; LCD control register codes:  
7699			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7699			;   N    0 = 1-line mode       1 = 2-line mode  
7699			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7699			;   D    0 = Display off       1 = Display on  
7699			;   C    0 = Cursor off        1 = Cursor on  
7699			;   B    0 = Blinking off      1 = Blinking on  
7699			;   ID   0 = Decrement mode    1 = Increment mode  
7699			;   SH   0 = Entire shift off  1 = Entire shift on  
7699 3e 28		fLCD_Init:  LD   A, 40  
769b cd c0 77		            CALL LCDDelay       ;Delay 40ms after power up  
769e			; For reliable reset set 8-bit mode - 3 times  
769e cd 90 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76a1 cd 90 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76a4 cd 90 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76a7			; Set 4-bit mode  
76a7 cd 8c 77		            CALL WrFn4bit       ;Function = 4-bit mode  
76aa cd be 77		            CALL LCDDelay1      ;Delay 37 us or more  
76ad			; Function set  
76ad 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
76af cd c2 76		            CALL fLCD_Inst      ;2 line, display on  
76b2			; Display On/Off control  
76b2 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
76b4 cd c2 76		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
76b7			; Display Clear  
76b7 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
76b9 cd c2 76		            CALL fLCD_Inst      ;Clear display  
76bc			; Entry mode  
76bc 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
76be cd c2 76		            CALL fLCD_Inst      ;Increment mode, shift off  
76c1			; Display module now initialised  
76c1 c9			            RET  
76c2			; ok to here  
76c2			  
76c2			; Write instruction to LCD  
76c2			;   On entry: A = Instruction byte to be written  
76c2			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76c2 f5			fLCD_Inst:  PUSH AF  
76c3 f5			            PUSH AF  
76c4 cd d6 76		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
76c7 f1			            POP  AF  
76c8 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
76c9 17			            RLA  
76ca 17			            RLA  
76cb 17			            RLA  
76cc cd d6 76		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
76cf 3e 02		            LD   A, 2  
76d1 cd c0 77		            CALL LCDDelay       ;Delay 2 ms to complete   
76d4 f1			            POP  AF  
76d5 c9			            RET  
76d6			Wr4bits:   
76d6 f5					push af  
76d7 3a c8 fb				ld a, (display_lcde1e2)  
76da fe 00				cp 0     ; e  
76dc 20 10				jr nz, .wea2	  
76de f1					pop af  
76df e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
76e1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76e3 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
76e5 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
76e7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76e9 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
76eb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76ed c9			            RET  
76ee f1			.wea2:		pop af  
76ef e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
76f1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76f3 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
76f5 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
76f7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76f9 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
76fb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76fd c9			            RET  
76fe			  
76fe			  
76fe			; Write data to LCD  
76fe			;   On entry: A = Data byte to be written  
76fe			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76fe f5			fLCD_Data:  PUSH AF  
76ff f5			            PUSH AF  
7700 cd 12 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7703 f1			            POP  AF  
7704 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7705 17			            RLA  
7706 17			            RLA  
7707 17			            RLA  
7708 cd 12 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
770b 3e 96		            LD   A, 150  
770d 3d			Wait:      DEC  A              ;Wait a while to allow data   
770e 20 fd		            JR   NZ, Wait      ;  write to complete  
7710 f1			            POP  AF  
7711 c9			            RET  
7712			Wr4bitsa:     
7712 f5					push af  
7713 3a c8 fb				ld a, (display_lcde1e2)  
7716 fe 00				cp 0     ; e1  
7718 20 16				jr nz, .we2	  
771a f1					pop af  
771b e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
771d cb d7		            SET  kLCDBitRS, A  
771f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7721 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7723 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7725 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7727 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7729 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
772b cb 97		            RES  kLCDBitRS, A  
772d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
772f c9			            RET  
7730 f1			.we2:		pop af  
7731 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7733 cb d7		            SET  kLCDBitRS, A  
7735 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7737 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7739 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
773b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
773d cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
773f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7741 cb 97		            RES  kLCDBitRS, A  
7743 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7745 c9			            RET  
7746			  
7746			  
7746			; Position cursor to specified location  
7746			;   On entry: A = Cursor position  
7746			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7746 f5			fLCD_Pos:   PUSH AF  
7747					; at this point set the E1 or E2 flag depending on position  
7747			  
7747 c5					push bc  
7748			;		push af  
7748 06 00				ld b, 0  
774a 4f					ld c, a  
774b 3e 4f				ld a, kLCD_Line3-1  
774d b7			 		or a      ;clear carry flag  
774e 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
774f 38 04				jr c, .pe1  
7751			  
7751					; E selection  
7751 cb 80				res 0, b         ; bit 0 unset e  
7753			;		pop af    ; before line 3 so recover orig pos  
7753			;		ld c, a    ; save for poking back  
7753 18 06				jr .peset	          
7755			.pe1:          	; E2 selection  
7755 cb c0				set 0, b         ; bit 0 set e1  
7757 79					ld a, c  
7758 de 4f				sbc a, kLCD_Line3-1  
775a 4f					ld c, a	         ; save caculated offset  
775b			;		pop af     ; bin this original value now we have calculated form  
775b			  
775b			.peset:		; set bit  
775b 78					ld a, b  
775c 32 c8 fb				ld (display_lcde1e2), a 	  
775f 79					ld a, c  
7760 c1					pop bc  
7761			  
7761 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7763 cd c2 76		            CALL fLCD_Inst      ;Write instruction to LCD  
7766 f1			            POP  AF  
7767 c9			            RET  
7768			  
7768			  
7768			; Output text string to LCD  
7768			;   On entry: DE = Pointer to null terminated text string  
7768			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7768 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7769 b7			            OR   A              ;Null terminator?  
776a c8			            RET  Z              ;Yes, so finished  
776b cd fe 76		            CALL fLCD_Data      ;Write character to display  
776e 13			            INC  DE             ;Point to next character  
776f 18 f7		            JR   fLCD_Str       ;Repeat  
7771 c9					ret  
7772			  
7772			; Define custom character  
7772			;   On entry: A = Character number (0 to 7)  
7772			;             DE = Pointer to character bitmap data  
7772			;   On exit:  A = Next character number  
7772			;             DE = Next location following bitmap  
7772			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7772			; Character is   
7772 c5			fLCD_Def:   PUSH BC  
7773 f5			            PUSH AF  
7774 07			            RLCA                ;Calculate location  
7775 07			            RLCA                ;  for bitmap data  
7776 07			            RLCA                ;  = 8 x CharacterNumber  
7777 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7779 cd c2 76		            CALL fLCD_Inst      ;Write instruction to LCD  
777c 06 00		            LD   B, 0  
777e 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
777f cd fe 76		            CALL fLCD_Data      ;Write byte to display  
7782 13			            INC  DE             ;Point to next byte  
7783 04			            INC  B              ;Count bytes  
7784 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7786 28 f6		            JR   Z, Loop       ;No, so repeat  
7788 f1			            POP  AF  
7789 3c			            INC  A              ;Increment character number  
778a c1			            POP  BC  
778b c9			            RET  
778c			  
778c			  
778c			; **********************************************************************  
778c			; **  Private functions  
778c			; **********************************************************************  
778c			  
778c			; Write function to LCD  
778c			;   On entry: A = Function byte to be written  
778c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
778c 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
778e 18 02		            JR   WrFunc  
7790 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7792 f5			WrFunc:     PUSH AF  
7793 f5					push af  
7794 3a c8 fb				ld a, (display_lcde1e2)  
7797 fe 00				cp 0     ; e1  
7799 20 0f				jr nz, .wfea2	  
779b f1					pop af  
779c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
779e cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
77a0 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77a2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77a4 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77a6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77a8 18 0d			jr .wfskip  
77aa f1			.wfea2:		pop af  
77ab d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77ad cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
77af cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77b1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77b3 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77b5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77b7 3e 05		.wfskip:            LD  A, 5  
77b9 cd c0 77		            CALL LCDDelay       ;Delay 5 ms to complete  
77bc f1			            POP  AF  
77bd c9			            RET  
77be			  
77be			  
77be			; Delay in milliseconds  
77be			;   On entry: A = Number of milliseconds delay  
77be			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77be 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
77c0 d5			LCDDelay:   PUSH DE  
77c1 5f			            LD   E, A           ;Delay by 'A' ms  
77c2 16 00		            LD   D, 0  
77c4 cd c4 0c		            CALL aDelayInMS  
77c7 d1			            POP  DE  
77c8 c9			            RET  
77c9			  
77c9			  
77c9			testlcd:  
77c9 3e 00			ld a, kLCD_Line1  
77cb cd 46 77			call fLCD_Pos  
77ce 06 28			ld b, 40  
77d0 11 fe 77			ld de, .ttext1  
77d3 cd 91 76			call write_len_string  
77d6			  
77d6 3e 28			ld a, kLCD_Line2  
77d8 cd 46 77			call fLCD_Pos  
77db 06 28			ld b, 40  
77dd 11 27 78			ld de, .ttext2  
77e0 cd 91 76			call write_len_string  
77e3 3e 50			ld a, kLCD_Line3  
77e5 cd 46 77			call fLCD_Pos  
77e8 06 28			ld b, 40  
77ea 11 50 78			ld de, .ttext3  
77ed cd 91 76			call write_len_string  
77f0 3e 78			ld a, kLCD_Line4  
77f2 cd 46 77			call fLCD_Pos  
77f5 06 28			ld b, 40  
77f7 11 79 78			ld de, .ttext4  
77fa cd 91 76			call write_len_string  
77fd			  
77fd 76				halt  
77fe			  
77fe			  
77fe .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7827 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7850 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7879 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
78a2			   
78a2			  
78a2			  
78a2			; eof  
78a2			  
# End of file firmware_lcd_4x40.asm
78a2			;include "firmware_lcd_4x20.asm" 
78a2			include "firmware_key_5x10.asm" 
78a2			; 5 x 10 decade counter scanner  
78a2			  
78a2			  
78a2			; TODO do cursor shape change for shift keys  
78a2			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
78a2			  
78a2			  
78a2			; bit mask for each scan column and row for teing the matrix  
78a2			  
78a2			  
78a2			key_init:  
78a2			  
78a2			; SCMonAPI functions used  
78a2			  
78a2			; Alphanumeric LCD functions used  
78a2			; no need to specify specific functions for this module  
78a2			  
78a2			  
78a2 3e cf		            LD   A, 11001111b  
78a4 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
78a6			;            LD   A, 00000000b  
78a6 3e 1f		            LD   A, 00011111b  
78a8 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
78aa			  
78aa			  
78aa				; TODO Configure cursor shapes  
78aa			  
78aa				; Load cursor shapes   
78aa 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
78ac 11 bc 78		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
78af 06 02		            LD   B, 2           ;Number of characters to define  
78b1 cd 72 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
78b4 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
78b6			  
78b6 3e 01				ld a, 1  
78b8 32 be fb			ld (cursor_shape),a  
78bb c9				ret  
78bc			  
78bc			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
78bc			; Up to 8 custom characters can be defined  
78bc			.cursor_shapes:      
78bc			;; Character 0x00 = Normal  
78bc 1f			            DB  11111b  
78bd 1f			            DB  11111b  
78be 1f			            DB  11111b  
78bf 1f			            DB  11111b  
78c0 1f			            DB  11111b  
78c1 1f			            DB  11111b  
78c2 1f			            DB  11111b  
78c3 1f			            DB  11111b  
78c4			;; Character 0x01 = Modifier  
78c4 1f			            DB  11111b  
78c5 1b			            DB  11011b  
78c6 1b			            DB  11011b  
78c7 1b			            DB  11011b  
78c8 1b			            DB  11011b  
78c9 1f			            DB  11111b  
78ca 1b			            DB  11011b  
78cb 1f			            DB  11111b  
78cc			  
78cc			  
78cc			  
78cc			  
78cc			; Display custom character 0  
78cc			;            LD   A, kLCD_Line1+14  
78cc			;            CALL fLCD_Pos       ;Position cursor to location in A  
78cc			;            LD   A, 0  
78cc			;            CALL fLCD_Data      ;Write character in A at cursor  
78cc			  
78cc			; Display custom character 1  
78cc			;            LD   A, kLCD_Line2+14  
78cc			;            CALL fLCD_Pos      ;Position cursor to location in A  
78cc			;            LD   A, 1  
78cc			;            CALL fLCD_Data     ;Write character in A at cursor  
78cc			  
78cc			; keyboard scanning   
78cc			  
78cc			; character in from keyboard  
78cc			  
78cc			; mapping for the pcb layout  
78cc			  
78cc			.matrix_to_char:  
78cc .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
78d7 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
78e2 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
78ed 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
78f8 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7903			.matrix_to_shift:  
7903			  
7903 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
790e .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7919 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7924 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
792f .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
793a			  
793a			.matrix_to_symbolshift:  
793a			  
793a fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7945 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7950 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
795b			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
795b 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7966 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7971			  
7971			  
7971			  
7971			; mapping for a simple straight through breadboard layout  
7971			  
7971			;.matrix_to_char:  
7971			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7971			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7971			;		db "asdfghjkl",KEY_CR,0  
7971			;		db "qwertyuiop",0  
7971			;		 db "1234567890",0  
7971			;.matrix_to_shift:  
7971			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7971			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7971			;		db "ASDFGHJKL",KEY_CR,0  
7971			;		db "QWERTYUIOP",0  
7971			;		 db "!",'"',"#$%^&*()",0  
7971			;.matrix_to_symbolshift:  
7971			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7971			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7971			;		db "_?*fghjk=",KEY_CR,0  
7971			;		db "-/+*[]{}@#",0  
7971			;		 db "1234567890",0  
7971			  
7971			;.matrix_to_char: db "D#0*C987B654A321"  
7971			  
7971			  
7971				  
7971			  
7971			; add cin and cin_wait  
7971			  
7971 cd 82 79		cin_wait: 	call cin  
7974						if DEBUG_KEYCINWAIT  
7974							push af  
7974							  
7974							ld hl,key_repeat_ct  
7974							ld (hl),a  
7974							inc hl  
7974							call hexout  
7974							ld hl,key_repeat_ct+3  
7974							ld a,0  
7974							ld (hl),a  
7974			  
7974							    LD   A, kLCD_Line1+11  
7974							    CALL fLCD_Pos       ;Position cursor to location in A  
7974							    LD   DE, key_repeat_ct  
7974							    ;LD   DE, MsgHello  
7974							    CALL fLCD_Str       ;Display string pointed to by DE  
7974			  
7974			  
7974			  
7974							pop af  
7974						endif  
7974 fe 00			cp 0  
7976 28 f9			jr z, cin_wait   ; block until key press  
7978			  
7978							if DEBUG_KEYCINWAIT  
7978								push af  
7978			  
7978								ld a, 'A'	  
7978								ld hl,key_repeat_ct  
7978								ld (hl),a  
7978								inc hl  
7978								ld a,0  
7978								ld (hl),a  
7978			  
7978								    LD   A, kLCD_Line2+11  
7978								    CALL fLCD_Pos       ;Position cursor to location in A  
7978								    LD   DE, key_repeat_ct  
7978								    ;LD   DE, MsgHello  
7978								    CALL fLCD_Str       ;Display string pointed to by DE  
7978			  
7978							call delay500ms  
7978			  
7978								pop af  
7978							endif  
7978 f5				push af   ; save key pressed  
7979			  
7979			.cin_wait1:	  
7979							if DEBUG_KEYCINWAIT  
7979								push af  
7979			  
7979								ld a, 'b'	  
7979								ld hl,key_repeat_ct  
7979								ld (hl),a  
7979								inc hl  
7979								ld a,0  
7979								ld (hl),a  
7979			  
7979								    LD   A, kLCD_Line2+11  
7979								    CALL fLCD_Pos       ;Position cursor to location in A  
7979								    LD   DE, key_repeat_ct  
7979								    ;LD   DE, MsgHello  
7979								    CALL fLCD_Str       ;Display string pointed to by DE  
7979			  
7979			  
7979							call delay500ms  
7979			  
7979								pop af  
7979							endif  
7979			  
7979 cd 82 79		call cin  
797c fe 00			cp 0  
797e 20 f9			jr nz, .cin_wait1  	; wait for key release  
7980			if DEBUG_KEYCINWAIT  
7980				push af  
7980			  
7980				ld a, '3'	  
7980				ld hl,key_repeat_ct  
7980				ld (hl),a  
7980				inc hl  
7980				ld a,0  
7980				ld (hl),a  
7980			  
7980			            LD   A, kLCD_Line2+11  
7980			            CALL fLCD_Pos       ;Position cursor to location in A  
7980			            LD   DE, key_repeat_ct  
7980			            ;LD   DE, MsgHello  
7980			            CALL fLCD_Str       ;Display string pointed to by DE  
7980			  
7980			  
7980			call delay500ms  
7980			  
7980				pop af  
7980			endif  
7980			  
7980 f1				pop af   ; get key  
7981 c9				ret  
7982			  
7982			  
7982 cd 96 79		cin: 	call .mtoc  
7985			  
7985			if DEBUG_KEYCIN  
7985				push af  
7985				  
7985				ld hl,key_repeat_ct  
7985				ld (hl),a  
7985				inc hl  
7985				call hexout  
7985				ld hl,key_repeat_ct+3  
7985				ld a,0  
7985				ld (hl),a  
7985			  
7985			            LD   A, kLCD_Line3+15  
7985			            CALL fLCD_Pos       ;Position cursor to location in A  
7985			            LD   DE, key_repeat_ct  
7985			            ;LD   DE, MsgHello  
7985			            CALL fLCD_Str       ;Display string pointed to by DE  
7985			  
7985			  
7985			call delay500ms  
7985			  
7985				pop af  
7985			endif  
7985			  
7985			  
7985				; no key held  
7985 fe 00			cp 0  
7987 c8				ret z  
7988			  
7988			if DEBUG_KEYCIN  
7988				push af  
7988			  
7988				ld a, '1'	  
7988				ld hl,key_repeat_ct  
7988				ld (hl),a  
7988				inc hl  
7988				ld a,0  
7988				ld (hl),a  
7988			  
7988			            LD   A, kLCD_Line4+15  
7988			            CALL fLCD_Pos       ;Position cursor to location in A  
7988			            LD   DE, key_repeat_ct  
7988			            ;LD   DE, MsgHello  
7988			            CALL fLCD_Str       ;Display string pointed to by DE  
7988			  
7988			  
7988			call delay500ms  
7988			  
7988				pop af  
7988			endif  
7988			  
7988				; stop key bounce  
7988			  
7988 32 88 fe			ld (key_held),a		 ; save it  
798b 47				ld b, a  
798c			  
798c c5			.cina1:	push bc  
798d			if DEBUG_KEYCIN  
798d				push af  
798d			  
798d				ld hl,key_repeat_ct  
798d				inc hl  
798d				call hexout  
798d				ld hl,key_repeat_ct+3  
798d				ld a,0  
798d				ld (hl),a  
798d				ld hl,key_repeat_ct  
798d				ld a, '2'	  
798d				ld (hl),a  
798d			  
798d			            LD   A, kLCD_Line4+15  
798d			            CALL fLCD_Pos       ;Position cursor to location in A  
798d			            LD   DE, key_repeat_ct  
798d			            ;LD   DE, MsgHello  
798d			            CALL fLCD_Str       ;Display string pointed to by DE  
798d			  
798d				pop af  
798d			endif  
798d cd 96 79			call .mtoc  
7990 c1				pop bc  
7991 b8				cp b  
7992 28 f8			jr z, .cina1  
7994 78				ld a,b		  
7995			if DEBUG_KEYCIN  
7995				push af  
7995			  
7995				ld hl,key_repeat_ct  
7995				inc hl  
7995				call hexout  
7995				ld hl,key_repeat_ct+3  
7995				ld a,0  
7995				ld (hl),a  
7995				ld hl,key_repeat_ct  
7995				ld a, '3'	  
7995				ld (hl),a  
7995			  
7995			            LD   A, kLCD_Line4+15  
7995			            CALL fLCD_Pos       ;Position cursor to location in A  
7995			            LD   DE, key_repeat_ct  
7995			            ;LD   DE, MsgHello  
7995			            CALL fLCD_Str       ;Display string pointed to by DE  
7995			  
7995				pop af  
7995			endif  
7995 c9				ret  
7996			  
7996			; detect keyboard modifier key press and apply new overlay to the face key held  
7996			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7996			  
7996			;.cin_map_modifier:   
7996			;	ld a, (hl)  
7996			;	and 255  
7996			;	ret NZ		; modifier key not flagged  
7996			;  
7996			;	; get key face  
7996			;  
7996			;	ld b,(key_face_held)  
7996			;  
7996			;	ld b, key_cols * key_rows  
7996			;  
7996			;	push de  
7996			;	pop hl  
7996			;  
7996			;.mmod1: ld a,(hl)   ; get map test  
7996			;	cp b  
7996			;	jr z, .mmod2  
7996			;  
7996			;  
7996			;  
7996			;.mmod2: inc hl    ;   
7996			;  
7996			;	  
7996			;  
7996			;	  
7996			;  
7996			;	ld hl,key_actual_pressed  
7996			;	ld (hl),a,  
7996			;	ret  
7996			  
7996			; map matrix key held to char on face of key  
7996			  
7996			.mtoc:  
7996			  
7996			; test decade counter strobes  
7996			  
7996			;.decadetest1:  
7996			  
7996			; reset counter  
7996			;ld a, 128  
7996			;out (portbdata),a  
7996			  
7996			  
7996			;ld b, 5  
7996			;.dec1:  
7996			;ld a, 0  
7996			;out (portbdata),a  
7996			;call delay1s  
7996			  
7996			;ld a, 32  
7996			;out (portbdata),a  
7996			;call delay1s  
7996			;call delay1s  
7996			;call delay1s  
7996			;  
7996			;ld a, 64+32  
7996			;out (portbdata),a  
7996			;call delay1s  
7996			;;djnz .dec1  
7996			;  
7996			;jp .decadetest1  
7996			  
7996			  
7996			  
7996			  
7996			  
7996			  
7996			  
7996			  
7996			  
7996			  
7996				; scan keyboard matrix and generate raw scan map  
7996 cd 29 7a			call matrix  
7999			  
7999				; reuse c bit 0 left modifer button - ie shift  
7999			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7999				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7999			  
7999 0e 00			ld c, 0  
799b			  
799b				; TODO set flags for modifer key presses   
799b				; TODO do a search for modifer key...  
799b			  
799b				;ld hl,keyscan_table_row4  
799b 21 e7 fe			ld hl,keyscan_table_row2  
799e			  
799e 7e				ld a, (hl)  
799f fe 23			cp '#'  
79a1 20 07			jr nz, .nextmodcheck  
79a3 cb c1			set 0, c  
79a5 21 03 79			ld hl, .matrix_to_shift  
79a8 18 21			jr .dokeymap  
79aa				; TODO for now igonre  
79aa			.nextmodcheck:  
79aa 21 dc fe			ld hl,keyscan_table_row3  
79ad			  
79ad 7e				ld a, (hl)  
79ae fe 23			cp '#'  
79b0 20 07			jr nz, .nextmodcheck2  
79b2 cb c9			set 1, c   
79b4 21 3a 79			ld hl, .matrix_to_symbolshift  
79b7 18 12			jr .dokeymap  
79b9			.nextmodcheck2:  
79b9 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
79bc			  
79bc 7e				ld a, (hl)  
79bd fe 23			cp '#'  
79bf 20 07			jr nz, .donemodcheck  
79c1 cb c9			set 1, c   
79c3 21 03 79			ld hl, .matrix_to_shift  
79c6 18 03			jr .dokeymap  
79c8			  
79c8				; no modifer found so just map to normal keys  
79c8				; get mtoc map matrix to respective keys  
79c8			;	ld hl, .matrix_to_char  
79c8			;	ld hl, .matrix_to_char  
79c8			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
79c8			;	ld a, KEY_SHIFT  
79c8			;	call findchar  
79c8			;  
79c8			;	; got offset to key modifer in b  
79c8			;  
79c8			;	ld hl,keyscan_table_row5  
79c8			;  
79c8			;	ld a,b  
79c8			;	call addatohl  
79c8			;	ld a,(hl)  
79c8			;  
79c8			;	cp '#'  
79c8			;	jr nz, .nextmodcheck  
79c8			;	set 0, c  
79c8			;	ld hl, .matrix_to_char  
79c8			;	jr .dokeymap  
79c8			;	; TODO for now igonre  
79c8			;.nextmodcheck:  
79c8			;	ld hl, .matrix_to_symbolshift  
79c8			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
79c8			;	ld a, KEY_SYMBOLSHIFT  
79c8			;	call findchar  
79c8			;  
79c8			;  
79c8			;	; got offset to key modifer in b  
79c8			;  
79c8			;	ld hl,keyscan_table_row5  
79c8			;  
79c8			;	ld a,b  
79c8			;	call addatohl  
79c8			;	ld a,(hl)  
79c8			;  
79c8			;	cp '#'  
79c8			;	jr nz, .donemodcheck  
79c8			;	set 1, c   
79c8			;	ld hl, .matrix_to_symbolshift  
79c8			;	jr .dokeymap  
79c8			  
79c8			  
79c8			  
79c8			.donemodcheck:  
79c8				; no modifer found so just map to normal keys  
79c8				; get mtoc map matrix to respective keys  
79c8 21 cc 78			ld hl, .matrix_to_char  
79cb			  
79cb			.dokeymap:  
79cb				;ld (key_fa), c   
79cb cd e4 79			call .mapkeys  
79ce			  
79ce			  
79ce			if DEBUG_KEY  
79ce			  
79ce			; Display text on first line  
79ce			            LD   A, kLCD_Line1  
79ce			            CALL fLCD_Pos       ;Position cursor to location in A  
79ce			            LD   DE, keyscan_table_row1  
79ce			            ;LD   DE, MsgHello  
79ce			            CALL fLCD_Str       ;Display string pointed to by DE  
79ce			  
79ce			; Display text on second line  
79ce			            LD   A, kLCD_Line2  
79ce			            CALL fLCD_Pos       ;Position cursor to location in A  
79ce			            LD   DE, keyscan_table_row2  
79ce			            CALL fLCD_Str       ;Display string pointed to by DE  
79ce			            LD   A, kLCD_Line3  
79ce			            CALL fLCD_Pos       ;Position cursor to location in A  
79ce			            LD   DE, keyscan_table_row3  
79ce			            CALL fLCD_Str       ;Display string pointed to by DE  
79ce			            LD   A, kLCD_Line4  
79ce			            CALL fLCD_Pos       ;Position cursor to location in A  
79ce			            LD   DE, keyscan_table_row4  
79ce			            CALL fLCD_Str       ;Display string pointed to by DE  
79ce			            LD   A, kLCD_Line1+10  
79ce			            CALL fLCD_Pos       ;Position cursor to location in A  
79ce			            LD   DE, keyscan_table_row5  
79ce			            CALL fLCD_Str       ;Display string pointed to by DE  
79ce			  
79ce				;call delay250ms  
79ce			endif  
79ce			;	jp testkey  
79ce			  
79ce			; get first char reported  
79ce			  
79ce 21 c6 fe			ld hl,keyscan_table_row5  
79d1			  
79d1				;ld b, 46   ; 30 keys to remap + 8 nulls   
79d1 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
79d3			.findkey:  
79d3 7e				ld a,(hl)  
79d4 fe 00			cp 0  
79d6 28 04			jr z, .nextkey  
79d8 fe 7e			cp KEY_MATRIX_NO_PRESS  
79da 20 06			jr nz, .foundkey  
79dc			.nextkey:  
79dc 23				inc hl  
79dd 10 f4			djnz .findkey  
79df 3e 00			ld a,0  
79e1 c9				ret  
79e2			.foundkey:  
79e2 7e				ld a,(hl)  
79e3 c9				ret  
79e4				  
79e4			  
79e4			; convert the raw key map given hl for destination key  
79e4			.mapkeys:  
79e4 11 c6 fe			ld de,keyscan_table_row5  
79e7			  
79e7 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
79e9			.remap:  
79e9 1a				ld a,(de)  
79ea fe 23			cp '#'  
79ec 20 02			jr nz, .remapnext  
79ee				;CALLMONITOR  
79ee 7e				ld a,(hl)  
79ef 12				ld (de),a  
79f0			  
79f0			  
79f0			  
79f0			.remapnext:  
79f0 23				inc hl  
79f1 13				inc de  
79f2 10 f5			djnz .remap  
79f4				  
79f4 c9				ret  
79f5			  
79f5			  
79f5			  
79f5			.mtocold2:  
79f5			  
79f5			;	; flag if key D is held down and remove from reporting  
79f5			;	ld bc, .key_map_fd    
79f5			;	ld hl, keyscan_table  
79f5			;	ld de, key_fd  
79f5			;	call .key_shift_hold  
79f5			;	cp 255  
79f5			;	jr z, .cinmap  
79f5			;	; flag if key C is held down and remove from reporting  
79f5			;	ld bc, .key_map_fc    
79f5			;	ld hl, keyscan_table+key_cols  
79f5			;	ld de, key_fc  
79f5			;	call .key_shift_hold  
79f5			;	cp 255  
79f5			;	jr z, .cinmap  
79f5			;	; flag if key B is held down and remove from reporting  
79f5			;	ld bc, .key_map_fb    
79f5			;	ld hl, keyscan_table+(key_cols*2)  
79f5			;	ld de, key_fb  
79f5			;	call .key_shift_hold  
79f5			;	cp 255  
79f5			;	jr z, .cinmap  
79f5			;	; flag if key A is held down and remove from reporting  
79f5			;	ld bc, .key_map_fa    
79f5			;	ld hl, keyscan_table+(key_cols*3)  
79f5			;	ld de, key_fa  
79f5			;	call .key_shift_hold  
79f5			;	cp 255  
79f5			;	jr z, .cinmap  
79f5			  
79f5 11 cc 78			ld de, .matrix_to_char  
79f8			  
79f8			  
79f8			.cinmap1:   
79f8				if DEBUG_KEY  
79f8			            LD   A, kLCD_Line4  
79f8			            CALL fLCD_Pos       ;Position cursor to location in A  
79f8					push de  
79f8			            LD   DE, keyscan_table  
79f8			            CALL fLCD_Str       ;Display string pointed to by DE  
79f8					pop de  
79f8				endif  
79f8			  
79f8				; scan key matrix table for any held key  
79f8			  
79f8				; de holds either the default matrix or one selected above  
79f8			  
79f8 21 93 fe			ld hl, keyscan_table  
79fb 06 32			ld b,key_cols*key_rows  
79fd			  
79fd 7e			.cin11:	ld a,(hl)  
79fe fe 23			cp '#'  
7a00 28 08			jr z, .cinhit1  
7a02 23				inc hl  
7a03 13				inc de  
7a04 05				dec b  
7a05 20 f6			jr nz, .cin11  
7a07				; no key found held  
7a07 3e 00			ld a,0  
7a09 c9				ret  
7a0a d5			.cinhit1: push de  
7a0b e1				pop hl  
7a0c 7e				ld a,(hl)  
7a0d c9				ret  
7a0e			  
7a0e			; flag a control key is held   
7a0e			; hl is key pin, de is flag indicator  
7a0e			  
7a0e			.key_shift_hold1:  
7a0e c5				push bc  
7a0f 3e 01			ld a, 1  
7a11 32 be fb			ld (cursor_shape),a  
7a14 06 00			ld b, 0  
7a16 7e				ld a, (hl)  
7a17 fe 2e			cp '.'  
7a19 28 0a			jr z, .key_shift11  
7a1b 06 ff			ld b, 255  
7a1d 3e 2b			ld a, '+'    ; hide key from later scans  
7a1f 77				ld (hl),a  
7a20 3e 02			ld a, 2  
7a22 32 be fb			ld (cursor_shape),a  
7a25			.key_shift11:  
7a25				; write flag indicator  
7a25 78				ld a,b  
7a26 12				ld (de),a  
7a27			  
7a27 d1				pop de    ; de now holds the key map ptr  
7a28 c9				ret  
7a29			  
7a29				  
7a29			  
7a29			; scans keyboard matrix and flags key press in memory array	  
7a29				  
7a29			matrix:  
7a29				;call matrix  
7a29				; TODO optimise the code....  
7a29			  
7a29			  
7a29			;ld hl, keyscan_table_row1  
7a29			;ld de, keyscan_table_row1+1  
7a29			;ld bc,46  
7a29			;ld a,KEY_MATRIX_NO_PRESS  
7a29			;ldir  
7a29			  
7a29			  
7a29			  
7a29			; reset counter  
7a29 3e 80		ld a, 128  
7a2b d3 c1		out (portbdata),a  
7a2d			  
7a2d 06 0a		ld b, 10  
7a2f 0e 00		ld c, 0       ; current clock toggle  
7a31			  
7a31			.colscan:  
7a31			  
7a31			; set current column  
7a31			; disable clock enable and set clock low  
7a31			  
7a31			;ld a, 0  
7a31			;out (portbdata),a  
7a31			  
7a31			; For each column scan for switches  
7a31			  
7a31 c5			push bc  
7a32 21 89 fe		ld hl, keyscan_scancol  
7a35 cd 3e 7b		call .rowscan  
7a38 c1			pop bc  
7a39			  
7a39			  
7a39			; get back current column  
7a39			  
7a39			; translate the row scan  
7a39			  
7a39			;   
7a39			; row 1  
7a39			  
7a39 78			ld a,b  
7a3a			  
7a3a 21 fc fe		LD   hl, keyscan_table_row1+10  
7a3d			  
7a3d cd e2 0f		call subafromhl  
7a40			;call addatohl  
7a40			  
7a40 11 89 fe		ld de, keyscan_scancol  
7a43			  
7a43 1a			ld a,(de)  
7a44 77			ld (hl),a  
7a45			  
7a45			  
7a45			  
7a45			  
7a45			; row 2  
7a45			  
7a45 78			ld a,b  
7a46			  
7a46 21 f1 fe		LD   hl, keyscan_table_row2+10  
7a49			  
7a49			;call addatohl  
7a49 cd e2 0f		call subafromhl  
7a4c			  
7a4c			  
7a4c 11 8a fe		ld de, keyscan_scancol+1  
7a4f			  
7a4f 1a			ld a,(de)  
7a50 77			ld (hl),a  
7a51			  
7a51			  
7a51			; row 3  
7a51			  
7a51 78			ld a,b  
7a52			  
7a52 21 e6 fe		LD   hl, keyscan_table_row3+10  
7a55			  
7a55			;call addatohl  
7a55 cd e2 0f		call subafromhl  
7a58			  
7a58 11 8b fe		ld de, keyscan_scancol+2  
7a5b			  
7a5b 1a			ld a,(de)  
7a5c 77			ld (hl),a  
7a5d			  
7a5d			  
7a5d			  
7a5d			; row 4  
7a5d			  
7a5d 78			ld a,b  
7a5e			  
7a5e 21 db fe		LD   hl, keyscan_table_row4+10  
7a61			  
7a61			;call addatohl  
7a61 cd e2 0f		call subafromhl  
7a64			  
7a64 11 8c fe		ld de, keyscan_scancol+3  
7a67			  
7a67 1a			ld a,(de)  
7a68 77			ld (hl),a  
7a69			  
7a69			; row 5  
7a69			  
7a69 78			ld a,b  
7a6a			  
7a6a 21 d0 fe		LD   hl, keyscan_table_row5+10  
7a6d			  
7a6d			;call addatohl  
7a6d cd e2 0f		call subafromhl  
7a70			  
7a70 11 8d fe		ld de, keyscan_scancol+4  
7a73			  
7a73 1a			ld a,(de)  
7a74 77			ld (hl),a  
7a75			  
7a75			; handshake next column  
7a75			  
7a75			  
7a75 3e 40		ld a, 64  
7a77 d3 c1		out (portbdata),a  
7a79			  
7a79 3e 00		ld a, 0  
7a7b d3 c1		out (portbdata),a  
7a7d			  
7a7d			; toggle clk and move to next column  
7a7d			;ld a, 64  
7a7d			;cp c  
7a7d			;  
7a7d			;jr z, .coltoglow  
7a7d			;ld c, a  
7a7d			;jr .coltog  
7a7d			;.coltoglow:  
7a7d			;ld c, 0  
7a7d			;.coltog:  
7a7d			;ld a, c  
7a7d			;out (portbdata),a  
7a7d			  
7a7d 10 b2		djnz .colscan  
7a7f			  
7a7f 3e 0a		ld a,10  
7a81 21 f2 fe		LD   hl, keyscan_table_row1  
7a84 cd d0 0f		call addatohl  
7a87 3e 00		ld a, 0  
7a89 77			ld (hl), a  
7a8a			  
7a8a			  
7a8a 3e 0a		ld a,10  
7a8c 21 e7 fe		LD   hl, keyscan_table_row2  
7a8f cd d0 0f		call addatohl  
7a92 3e 00		ld a, 0  
7a94 77			ld (hl), a  
7a95			  
7a95 3e 0a		ld a,10  
7a97 21 dc fe		LD   hl, keyscan_table_row3  
7a9a cd d0 0f		call addatohl  
7a9d 3e 00		ld a, 0  
7a9f 77			ld (hl), a  
7aa0			  
7aa0 3e 0a		ld a,10  
7aa2 21 d1 fe		LD   hl, keyscan_table_row4  
7aa5 cd d0 0f		call addatohl  
7aa8 3e 00		ld a, 0  
7aaa 77			ld (hl), a  
7aab			  
7aab 3e 0a		ld a,10  
7aad 21 c6 fe		LD   hl, keyscan_table_row5  
7ab0 cd d0 0f		call addatohl  
7ab3 3e 00		ld a, 0  
7ab5 77			ld (hl), a  
7ab6			  
7ab6			if DEBUG_KEY_MATRIX  
7ab6			  
7ab6			; Display text on first line  
7ab6			            LD   A, kLCD_Line1  
7ab6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ab6			            LD   DE, keyscan_table_row1  
7ab6			            ;LD   DE, MsgHello  
7ab6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ab6			  
7ab6			; Display text on second line  
7ab6			            LD   A, kLCD_Line2  
7ab6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ab6			            LD   DE, keyscan_table_row2  
7ab6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ab6			            LD   A, kLCD_Line3  
7ab6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ab6			            LD   DE, keyscan_table_row3  
7ab6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ab6			            LD   A, kLCD_Line4  
7ab6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ab6			            LD   DE, keyscan_table_row4  
7ab6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ab6			            LD   A, kLCD_Line4+10  
7ab6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ab6			            LD   DE, keyscan_table_row5  
7ab6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ab6			  
7ab6			;call delay250ms  
7ab6				jp matrix  
7ab6			endif  
7ab6 c9			ret  
7ab7			  
7ab7			; using decade counter....  
7ab7			  
7ab7			  
7ab7			; TODO reset decade counter to start of scan  
7ab7			  
7ab7			; reset 15  
7ab7			; clock 14  
7ab7			; ce 13  
7ab7			  
7ab7			; 1 - q5  
7ab7			; 2 - q1  
7ab7			; 3 - q0  
7ab7			; 4 - q2  
7ab7			; 5 - q6  
7ab7			; 6 - q7  
7ab7			; 7 - q3  
7ab7			; 8 - vss  
7ab7			; 9 - q8  
7ab7			; 10 - q4  
7ab7			; 11 - q9  
7ab7			; 12 - cout  
7ab7			; 16 - vdd  
7ab7			  
7ab7			; clock      ce       reset     output  
7ab7			; 0          x        0         n  
7ab7			; x          1        0         n  
7ab7			; x          x        1         q0  
7ab7			; rising     0        0         n+1  
7ab7			; falling    x        0         n  
7ab7			; x          rising   0         n  
7ab7			; 1          falling  0         x+1  
7ab7			;  
7ab7			; x = dont care, if n < 5 carry = 1 otherwise 0  
7ab7			  
7ab7			;   
7ab7			; reset   
7ab7			; 13=0, 14=0, 15=1 .. 15=0  
7ab7			;  
7ab7			; handshake line  
7ab7			; 14=1.... read line 14=0  
7ab7			  
7ab7			  
7ab7			  
7ab7			  
7ab7			  
7ab7			; TODO hand shake clock for next column scan  
7ab7			; TODO detect each row  
7ab7			  
7ab7			  
7ab7			  
7ab7			  
7ab7			; reset 128  
7ab7			; clock 64  
7ab7			; ce 32  
7ab7			  
7ab7			  
7ab7			.cyclestart:  
7ab7			  
7ab7			; reset counter  
7ab7 3e 80		ld a, 128  
7ab9 d3 c1		out (portbdata),a  
7abb			  
7abb			; loop leds  
7abb 06 0a		ld b,10  
7abd			  
7abd			.cycle1:  
7abd c5			push bc  
7abe 3e 00		ld a, 0  
7ac0 d3 c1		out (portbdata),a  
7ac2 cd d3 0c		call delay250ms  
7ac5			  
7ac5 3e 40		ld a, 64  
7ac7 d3 c1		out (portbdata),a  
7ac9 cd d3 0c		call delay250ms  
7acc			  
7acc 3e 00		ld a, 0  
7ace d3 c1		out (portbdata),a  
7ad0 cd d3 0c		call delay250ms  
7ad3			  
7ad3 c1			pop bc  
7ad4 10 e7		djnz .cycle1  
7ad6			  
7ad6			  
7ad6 18 df		jr .cyclestart  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			; map matrix key held to char on face of key  
7ad8			  
7ad8			;.mtocold:  
7ad8			;  
7ad8			;  
7ad8			;; reset counter  
7ad8			;ld a, 128  
7ad8			;out (portbdata),a  
7ad8			;  
7ad8			;  
7ad8			;; scan keyboard row 1  
7ad8			;ld a, 0  
7ad8			;out (portbdata),a  
7ad8			;;ld a, 64  
7ad8			;;out (portbdata),a  
7ad8			;  
7ad8			;  
7ad8			;	ld a, 128  
7ad8			;	ld hl, keyscan_table  
7ad8			;	call .rowscan  
7ad8			;  
7ad8			;;ld a, 0  
7ad8			;;out (portbdata),a  
7ad8			;ld a, 64  
7ad8			;out (portbdata),a  
7ad8			;  
7ad8			;	ld a, 64  
7ad8			;	ld hl, keyscan_table+key_cols  
7ad8			;	call .rowscan  
7ad8			;  
7ad8			;ld a, 0  
7ad8			;out (portbdata),a  
7ad8			;;ld a, 64  
7ad8			;;out (portbdata),a  
7ad8			;	ld a, 32  
7ad8			;	ld hl, keyscan_table+(key_cols*2)  
7ad8			;	call .rowscan  
7ad8			;  
7ad8			;  
7ad8			;;ld a, 0  
7ad8			;;out (portbdata),a  
7ad8			;ld a, 64  
7ad8			;out (portbdata),a  
7ad8			;  
7ad8			;	ld a, 16  
7ad8			;	ld hl, keyscan_table+(key_cols*3)  
7ad8			;	call .rowscan  
7ad8			;  
7ad8			;  
7ad8			;	; flag if key D is held down and remove from reporting  
7ad8			;	ld bc, .key_map_fd    
7ad8			;	ld hl, keyscan_table  
7ad8			;	ld de, key_fd  
7ad8			;	call .key_shift_hold  
7ad8			;	cp 255  
7ad8			;	jr z, .cinmap  
7ad8			;	; flag if key C is held down and remove from reporting  
7ad8			;	ld bc, .key_map_fc    
7ad8			;	ld hl, keyscan_table+key_cols  
7ad8			;	ld de, key_fc  
7ad8			;	call .key_shift_hold  
7ad8			;	cp 255  
7ad8			;	jr z, .cinmap  
7ad8			;	; flag if key B is held down and remove from reporting  
7ad8			;	ld bc, .key_map_fb    
7ad8			;	ld hl, keyscan_table+(key_cols*2)  
7ad8			;	ld de, key_fb  
7ad8			;	call .key_shift_hold  
7ad8			;	cp 255  
7ad8			;	jr z, .cinmap  
7ad8			;	; flag if key A is held down and remove from reporting  
7ad8			;	ld bc, .key_map_fa    
7ad8			;	ld hl, keyscan_table+(key_cols*3)  
7ad8			;	ld de, key_fa  
7ad8			;	call .key_shift_hold  
7ad8			;	cp 255  
7ad8			;	jr z, .cinmap  
7ad8			;  
7ad8			;	ld de, .matrix_to_char  
7ad8			;  
7ad8			;  
7ad8			;.cinmap:   
7ad8			;	if DEBUG_KEY  
7ad8			;            LD   A, kLCD_Line4  
7ad8			;            CALL fLCD_Pos       ;Position cursor to location in A  
7ad8			;		push de  
7ad8			;            LD   DE, keyscan_table  
7ad8			;            CALL fLCD_Str       ;Display string pointed to by DE  
7ad8			;		pop de  
7ad8			;	endif  
7ad8			  
7ad8				; scan key matrix table for any held key  
7ad8			  
7ad8				; de holds either the default matrix or one selected above  
7ad8			  
7ad8			;	ld hl, keyscan_table  
7ad8			;	ld b,key_cols*key_rows  
7ad8			;  
7ad8			;.cin1:	ld a,(hl)  
7ad8			;	cp '#'  
7ad8			;	jr z, .cinhit  
7ad8			;	inc hl  
7ad8			;	inc de  
7ad8			;	dec b  
7ad8			;	jr nz, .cin1  
7ad8			;	; no key found held  
7ad8			;	ld a,0  
7ad8			;	ret  
7ad8			;.cinhit: push de  
7ad8			;	pop hl  
7ad8			;	ld a,(hl)  
7ad8			;	ret  
7ad8			  
7ad8			; flag a control key is held   
7ad8			; hl is key pin, de is flag indicator  
7ad8			  
7ad8			;.key_shift_hold:  
7ad8			;	push bc  
7ad8			;	ld a, 1  
7ad8			;	ld (cursor_shape),a  
7ad8			;	ld b, 0  
7ad8			;	ld a, (hl)  
7ad8			;	cp '.'  
7ad8			;	jr z, .key_shift1  
7ad8			;	ld b, 255  
7ad8			;	ld a, '+'    ; hide key from later scans  
7ad8			;	ld (hl),a  
7ad8			;	ld a, 2  
7ad8			;	ld (cursor_shape),a  
7ad8			;.key_shift1:  
7ad8			;	; write flag indicator  
7ad8			;	ld a,b  
7ad8			;	ld (de),a  
7ad8			;  
7ad8			;	pop de    ; de now holds the key map ptr  
7ad8			;	ret  
7ad8			  
7ad8				  
7ad8				  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			;	push hl  
7ad8			;	push de  
7ad8			;	push bc  
7ad8			;	call keyscan  
7ad8			;	; map key matrix to ascii value of key face  
7ad8			;  
7ad8			;	ld hl, key_face_map  
7ad8			;	ld de, keyscan_table  
7ad8			;  
7ad8			;	; get how many keys to look at  
7ad8			;	ld b, keyscan_table_len  
7ad8			;	  
7ad8			;  
7ad8			;	; at this stage fall out on first key hit  
7ad8			;	; TODO handle multiple key press  
7ad8			;  
7ad8			;map1:	ld a,(hl)  
7ad8			;	cp '#'  
7ad8			;	jr z, keyhit  
7ad8			;	inc hl  
7ad8			;	inc de  
7ad8			;	dec b  
7ad8			;	jr nz, map1  
7ad8			;nohit:	ld a, 0  
7ad8			;	jr keydone  
7ad8			;keyhit: push de  
7ad8			;	pop hl  
7ad8			;	ld a,(hl)  
7ad8			;keydone:  
7ad8			;	push bc  
7ad8			;	push de  
7ad8			; 	push hl  
7ad8			;	ret   
7ad8			;  
7ad8			  
7ad8			  
7ad8			  
7ad8			  
7ad8			; scan physical key matrix  
7ad8			  
7ad8			  
7ad8			;keyscan:  
7ad8			;  
7ad8			;; for each key_row use keyscanr bit mask for out  
7ad8			;; then read in for keyscanc bitmask  
7ad8			;; save result of row scan to keyscantable  
7ad8			;  
7ad8			;; scan keyboard row 1  
7ad8			;  
7ad8			;	ld b, key_rows  
7ad8			;	ld hl, key_scanr  
7ad8			;	ld de, keyscan_table  
7ad8			;  
7ad8			;rowloop:  
7ad8			;  
7ad8			;	ld a,(hl)		; out bit mask to energise keyboard row  
7ad8			;	call rowscan  
7ad8			;	inc hl  
7ad8			;	dec b  
7ad8			;	jr nz, rowloop  
7ad8			;  
7ad8			;	ret  
7ad8			;  
7ad8			;  
7ad8			;; pass a out bitmask, b row number  
7ad8			;arowscan:   
7ad8			;	push bc  
7ad8			;  
7ad8			;	ld d, b  
7ad8			;  
7ad8			;	; calculate buffer location for this row  
7ad8			;  
7ad8			;	ld hl, keyscan_table	  
7ad8			;kbufr:  ld e, key_cols  
7ad8			;kbufc:	inc hl  
7ad8			;	dec e  
7ad8			;	jr nz, kbufc  
7ad8			;	dec d  
7ad8			;	jr nz, kbufr  
7ad8			;  
7ad8			;	; energise row and read columns  
7ad8			;  
7ad8			;	out (portbdata),a  
7ad8			;	in a,(portbdata)  
7ad8			;	ld c,a  
7ad8			;  
7ad8			;  
7ad8			;	; save buffer loc  
7ad8			;  
7ad8			;	ld (keybufptr), hl  
7ad8			;  
7ad8			;	ld hl, key_scanc  
7ad8			;	ld d, key_cols  
7ad8			;  
7ad8			;	; for each column check each bit mask  
7ad8			;  
7ad8			;colloop:  
7ad8			;	  
7ad8			;  
7ad8			;	; reset flags for the row   
7ad8			;  
7ad8			;	ld b,'.'  
7ad8			;	and (hl)  
7ad8			;	jr z, maskskip  
7ad8			;	ld b,'#'  
7ad8			;maskskip:  
7ad8			;	; save  key state  
7ad8			;	push hl  
7ad8			;	ld hl, (keybufptr)  
7ad8			;	ld (hl), b  
7ad8			;	inc hl  
7ad8			;	ld (keybufptr), hl  
7ad8			;  
7ad8			;	; move to next bit mask  
7ad8			;	pop hl  
7ad8			;	inc hl  
7ad8			;  
7ad8			;	dec d  
7ad8			;	jr nz, colloop  
7ad8			;  
7ad8			;	ret  
7ad8			;  
7ad8			;  
7ad8			;;  
7ad8			; lcd functions  
7ad8			;  
7ad8			;  
7ad8			  
7ad8			;if DEBUG_KEY_MATRIX  
7ad8			  
7ad8			; test function to display hardware view of matrix state  
7ad8			  
7ad8			matrixold:  
7ad8			  
7ad8			  
7ad8			  
7ad8			; reset counter  
7ad8 3e 80		ld a, 128  
7ada d3 c1		out (portbdata),a  
7adc			; scan keyboard row 1  
7adc 3e 00		ld a, 0  
7ade d3 c1		out (portbdata),a  
7ae0			;ld a, 64  
7ae0			;out (portbdata),a  
7ae0 3e 80			ld a, 128  
7ae2 21 f2 fe			ld hl, keyscan_table_row1  
7ae5 cd 3e 7b			call .rowscan  
7ae8			  
7ae8			;ld a, 0  
7ae8			;out (portbdata),a  
7ae8 3e 40		ld a, 64  
7aea d3 c1		out (portbdata),a  
7aec 3e 40			ld a, 64  
7aee 21 e7 fe			ld hl, keyscan_table_row2  
7af1 cd 3e 7b			call .rowscan  
7af4			  
7af4 3e 00		ld a, 0  
7af6 d3 c1		out (portbdata),a  
7af8			;ld a, 64  
7af8			;out (portbdata),a  
7af8 3e 20			ld a, 32  
7afa 21 dc fe			ld hl, keyscan_table_row3  
7afd cd 3e 7b			call .rowscan  
7b00			  
7b00			;ld a, 0  
7b00			;out (portbdata),a  
7b00 3e 40		ld a, 64  
7b02 d3 c1		out (portbdata),a  
7b04 3e 10			ld a, 16  
7b06 21 d1 fe			ld hl, keyscan_table_row4  
7b09 cd 3e 7b			call .rowscan  
7b0c			  
7b0c			; Display text on first line  
7b0c 3e 00		            LD   A, kLCD_Line1  
7b0e cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b11 11 f2 fe		            LD   DE, keyscan_table_row1  
7b14			            ;LD   DE, MsgHello  
7b14 cd 68 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b17			  
7b17			; Display text on second line  
7b17 3e 28		            LD   A, kLCD_Line2  
7b19 cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b1c 11 e7 fe		            LD   DE, keyscan_table_row2  
7b1f cd 68 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b22 3e 50		            LD   A, kLCD_Line3  
7b24 cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b27 11 dc fe		            LD   DE, keyscan_table_row3  
7b2a cd 68 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b2d 3e 78		            LD   A, kLCD_Line4  
7b2f cd 46 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b32 11 d1 fe		            LD   DE, keyscan_table_row4  
7b35 cd 68 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b38			  
7b38 cd d3 0c			call delay250ms  
7b3b c3 29 7a			jp matrix  
7b3e			  
7b3e			; pass de as row display flags  
7b3e			.rowscan:   
7b3e			;	out (portbdata),a  
7b3e db c1			in a,(portbdata)  
7b40 4f				ld c,a  
7b41				; reset flags for the row   
7b41 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b43 e6 01			and 1  
7b45 28 02			jr z, .p1on  
7b47 06 23			ld b,'#'  
7b49			.p1on:  
7b49 70				ld (hl), b  
7b4a 23				inc hl  
7b4b			  
7b4b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b4d 79				ld a,c  
7b4e e6 02			and 2  
7b50			;	bit 0,a  
7b50 28 02			jr z, .p2on  
7b52 06 23			ld b,'#'  
7b54			.p2on:  
7b54 70				ld (hl), b  
7b55 23				inc hl  
7b56			;  
7b56 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b58 79				ld a,c  
7b59 e6 04			and 4  
7b5b			;;	bit 0,a  
7b5b 28 02			jr z, .p3on  
7b5d 06 23			ld b,'#'  
7b5f			.p3on:  
7b5f 70				ld (hl), b  
7b60 23				inc hl  
7b61			;;  
7b61 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b63			;;	bit 0,a  
7b63 79				ld a,c  
7b64 e6 08			and 8  
7b66 28 02			jr z, .p4on  
7b68 06 23			ld b,'#'  
7b6a			.p4on:  
7b6a 70				ld (hl), b  
7b6b 23				inc hl  
7b6c			  
7b6c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b6e			;;	bit 0,a  
7b6e 79				ld a,c  
7b6f e6 10			and 16  
7b71 28 02			jr z, .p5on  
7b73 06 23			ld b,'#'  
7b75			.p5on:  
7b75 70				ld (hl), b  
7b76 23				inc hl  
7b77			; zero term  
7b77 06 00			ld b,0  
7b79 70				ld (hl), b  
7b7a			  
7b7a c9			.rscandone: ret  
7b7b			  
7b7b			;addatohl:  
7b7b			;  
7b7b			 ;add   a, l    ; A = A+L  
7b7b			  ;  ld    l, a    ; L = A+L  
7b7b			   ; adc   a, h    ; A = A+L+H+carry  
7b7b			   ; sub   l       ; A = H+carry  
7b7b			   ; ld    h, a    ; H = H+carry  
7b7b			  
7b7b			;ret  
7b7b			; eof  
# End of file firmware_key_5x10.asm
7b7b			;include "firmware_key_4x10.asm" 
7b7b			 
7b7b			heap_size:    equ heap_end - heap_start 
7b7b			;eof 
# End of file os_mega.asm
7b7b
