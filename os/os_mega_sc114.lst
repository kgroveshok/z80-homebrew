# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 5a 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-07 17:04' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b			 
801b			 
801b			 
801b			;        nop  
801b			;        nop 
801b			;;	org 05h		; null out bdos call 
801b			; 
801b			;        nop  
801b			;        nop  
801b			;        nop 
801b			;;	org 08h 
801b			;;; 
801b			;;	jp cin		; rst 8 - char in 
801b			;;; 
801b			; 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;	org 010h 
801b			;; 
801b			;	jp cout		; rest 010h  - char out 
801b			;; 
801b			;	org 01bh   
801b			; 
801b			;	;jp  		; rst 01bh   - write string to display 
801b			;	jp str_at_display 
801b			; 
801b			; 
801b			;	org 020h 
801b			; 
801b			;	; jp		 ; rst 020h - read char at screen location 
801b			; 
801b			;	org 028h 
801b			 
801b				; jp		 ; rst 028h  - storage i/o 
801b			 
801b			; 	org 030h 
801b			;	jp break_point_state 
801b			  
801b			; $30  
801b			; org 038h 
801b			; $38 
801b			 
801b			; TODO any more important entry points to add to jump table for easier coding use? 
801b			 
801b			if BASE_KEV = 1  
801b			 
801b				; need to be at $66 for nmi support 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255 
801b				jp nmi 
801b			endif 
801b			 
801b			include "firmware.asm" 
801b			  
801b			; main constants (used here and in firmware)  
801b			  
801b			; TODO have page 0 of storage as bios  
801b			  
801b			Device_A: equ 0h  
801b			Device_B: equ 040h          ; Sound  
801b			  
801b			if BASE_KEV  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_SC114  
801b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			; TODO fixup for CPM  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			Device_D: equ 0c0h             ; Keyboard and LCD  
801b			  
801b			; Odd specific debug points for testing hardware dev  
801b			  
801b			DEBUG_SOUND: equ 0       
801b			DEBUG_STK_FAULT: equ 0  
801b			DEBUG_INPUT: equ 0     ; Debug input entry code  
801b			DEBUG_KEYCINWAIT: equ 0  
801b			DEBUG_KEYCIN: equ 0  
801b			DEBUG_KEY: equ 0  
801b			DEBUG_KEY_MATRIX: equ 0  
801b			DEBUG_STORECF: equ 0  
801b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801b			DEBUG_SPI: equ 0    ; low level spi tests  
801b			  
801b			; Enable many break points  
801b			  
801b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801b			DEBUG_FORTH_JP: equ 0    ; 4  
801b			DEBUG_FORTH_MALLOC: equ 0  
801b			DEBUG_FORTH_MALLOC_INT: equ 0  
801b			DEBUG_FORTH_DOT: equ 1  
801b			DEBUG_FORTH_DOT_WAIT: equ 0  
801b			DEBUG_FORTH_MATHS: equ 0  
801b			DEBUG_FORTH_TOK: equ 0    ; 4  
801b			DEBUG_FORTH_PARSE: equ 0    ; 3  
801b			DEBUG_FORTH: equ 0  ;2  
801b			DEBUG_FORTH_WORDS: equ 1   ; 1  
801b			DEBUG_FORTH_PUSH: equ 1   ; 1  
801b			DEBUG_FORTH_UWORD: equ 1   ; 1  
801b			  
801b			; Enable key point breakpoints  
801b			  
801b			DEBUG_FORTH_DOT_KEY: equ 0  
801b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801b			  
801b			; Debug stack imbalances  
801b			  
801b			ON: equ 1  
801b			OFF: equ 0  
801b			  
801b			DEBUG_STACK_IMB: equ 0  
801b			STACK_IMB_STORE: equ 20  
801b			  
801b			; House keeping and protections  
801b			  
801b			DEBUG_FORTH_STACK_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801b			FORTH_ENABLE_FREE: equ 0  
801b			FORTH_ENABLE_MALLOCFREE: equ 1  
801b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801b			FORTH_ENABLE_FLOATMATH: equ 0  
801b			  
801b			  
801b			CALLMONITOR: macro  
801b			;	call break_point_state  
801b			; now use the break point debug vector  
801b				call debug_vector  
801b				endm  
801b			  
801b			MALLOC_1: equ 1        ; from dk88   
801b			MALLOC_2: equ 0           ; broke  
801b			MALLOC_3: equ 0           ; really broke  
801b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801b			  
801b			if BASE_KEV   
801b			;stacksize: equ 256  
801b			; each stack entry is three bytes (type + word)  
801b			stacksize: equ 3*150  
801b			  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 512  
801b			endif  
801b			if BASE_SC114  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			;if STORAGE_SE == 0  
801b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801b			;endif  
801b			  
801b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801b			  
801b			STORE_0_AUTORUN: equ $20  
801b			  
801b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801b			  
801b			STORE_0_AUTOFILE: equ $21  
801b			STORE_0_BANKRUN: equ $23  
801b			STORE_0_FILERUN: equ $24  
801b			  
801b			; Block 0 offsets for settings  
801b			  
801b			; if set then skip prompt for start up and accept all  
801b			  
801b			STORE_0_QUICKSTART: equ $25  
801b			  
801b			; Blocks where directory table is held  
801b			  
801b			; Reducing the number of entries increases the max file size  
801b			  
801b			;STORE_DIR_START: equ 1  
801b			;STORE_DIR_END: equ 33  
801b			  
801b			; Blocks from where file data is stored  
801b			  
801b			;STORE_DATA_START: equ STORE_DIR_END + 1  
801b			  
801b			; Block indicators (<32 are data files)  
801b			  
801b			;STORE_BLOCK_CFG: equ $8f       ; config block  
801b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801b			;STORE_BLOCK_FREE: equ $85       ; data block free  
801b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801b			  
801b			  
801b			  
801b			; Directory entry flags  
801b			  
801b			;STORE_DIR_FREE: equ 0  
801b			;STORE_DIR_FILE:  equ 1  
801b			  
801b			; Structure offsets to directory entries  
801b			;STORE_DE_FLAG: equ 0  
801b			;STORE_DE_MAXEXT: equ 1  
801b			;STORE_DE_FILENAME: equ 2  
801b			  
801b			; Structure offsets to block 0  
801b			  
801b			;STORE_BK0_ISFOR: equ 1  
801b			;STORE_BK0_LABEL: equ 3  
801b			  
801b			; memory allocation   
801b			  
801b			chk_stund: equ tos+2           ; underflow check word  
801b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801b			  
801b			; keyscan table needs rows x cols buffer  
801b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801b			  
801b			keyscan_table_row1: equ chk_stovr -key_cols-1  
801b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801b			keyscan_scancol: equ keyscan_table-key_cols  
801b			;keyscan_table_len: equ key_rows*key_cols  
801b			;keybufptr: equ keyscan_table - 2  
801b			;keysymbol: equ keybufptr - 1  
801b			key_held: equ keyscan_scancol-1	; currently held  
801b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801b			key_fa: equ key_repeat_ct -1 ;  
801b			key_fb: equ key_fa -1 ;  
801b			key_fc: equ key_fb -1 ;  
801b			key_fd: equ key_fc -1 ;  
801b			key_face_held: equ key_fd - 1   
801b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801b			  
801b			hardware_config: equ key_face_held - 10  
801b			  
801b			; hardware config switches  
801b			; TODO add bitmasks on includes for hardware  
801b			; high byte for expansion ids  
801b			;     0000 0000  no card inserted  
801b			;     0000 0001  storage card inserted  
801b			;     0000 0010  spi sd card active  
801b			  
801b			;       
801b			; low byte:  
801b			;     0000 0001   4x4 keypad  
801b			;     0000 0010   full keyboard  
801b			;     0000 0011   spi/ext keyboard  
801b			;     0000 0100   20x4 lcd  
801b			;     0000 1000   40x4 lcd  
801b			;     0000 1100   spi/ext display  
801b			;     0001 0000   ide interface available  
801b			  
801b			hardware_word: equ hardware_config - 2  
801b			  
801b			; debug marker - optional display of debug point on the debug screens  
801b			  
801b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801b			  
801b			debug_mark: equ debug_vector - 4  
801b			  
801b			; input_str vars  
801b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801b			input_size: equ input_start -1  ; number of chars  
801b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801b			input_len: equ input_cur_onoff - 5 ; length of current input  
801b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801b			  
801b			CUR_BLINK_RATE: equ 15  
801b			  
801b			key_actual_pressed: equ input_cursor - 1   
801b			key_symbol: equ key_actual_pressed - 1   
801b			key_shift: equ key_symbol - 1   
801b			  
801b			; Display allocation  
801b			  
801b			;display_rows: equ 4     ; move out to mini and mega files  
801b			;display_cols: equ 20  
801b			  
801b			display_fb_len: equ display_rows*display_cols  
801b			  
801b			; primary frame buffer     
801b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801b			; working frame buffers  
801b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801b			display_fb3: equ  display_fb1-display_fb_len - 1  
801b			display_fb2: equ  display_fb3-display_fb_len - 1  
801b			;  
801b			; pointer to active frame buffer  
801b			display_fb_active: equ display_fb2 - 2  
801b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801b			display_write_tmp: equ display_lcde1e2 - 2  
801b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801b			  
801b			;  
801b			  
801b			;; can load into de directory  
801b			cursor_col: equ display_active-1  
801b			cursor_row: equ cursor_col-1  
801b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801b			  
801b			; maths vars  
801b			  
801b			LFSRSeed: equ cursor_shape -20   
801b			randData: equ LFSRSeed - 2  
801b			xrandc: equ randData - 2  
801b			stackstore: equ xrandc - 2  
801b			seed1: equ  stackstore -2   
801b			seed2: equ seed1 - 2  
801b			  
801b			; cf storage vars  
801b			  
801b			iErrorNum:  equ seed2-1         ;Error number  
801b			iErrorReg:  equ iErrorNum -1              ;Error register  
801b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801b			  
801b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801b			  
801b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801b			  
801b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801b			store_tmpid: equ store_tmp3 - 1		; page temp id  
801b			store_tmpext: equ store_tmpid - 1		; file extent temp  
801b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801b			;  
801b			; spi vars  
801b			  
801b			  
801b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801b			spi_device_id: equ spi_device - 1    ; human readable bank number  
801b			  
801b			;;;;; forth cli params  
801b			  
801b			; TODO use a different frame buffer for forth???  
801b			  
801b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801b			  
801b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801b			  
801b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801b			  
801b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801b			  
801b			; os/forth token vars  
801b			  
801b			os_last_cmd: equ os_var_array-255  
801b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801b			os_current_i: equ os_cli_cmd-2  
801b			os_cur_ptr: equ os_current_i-2  
801b			os_word_scratch: equ os_cur_ptr-30  
801b			os_tok_len: equ os_word_scratch - 2  
801b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801b			os_tok_malloc: equ os_tok_ptr - 2  
801b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801b			execscratch: equ os_input-255        ; exec cmd eval buffer  
801b			scratch: equ execscratch-255  
801b			  
801b			os_stack_1: equ scratch - 3       ; stack holding area 1  
801b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801b			  
801b			  
801b			; temp locations for new word processing to save on adding more   
801b			  
801b			os_new_malloc: equ os_stack_4-2  
801b			os_new_parse_len: equ os_new_malloc - 2  
801b			os_new_word_len: equ os_new_parse_len - 2  
801b			os_new_work_ptr: equ os_new_word_len - 2  
801b			os_new_src_ptr: equ os_new_work_ptr - 2  
801b			os_new_exec: equ os_new_src_ptr - 2  
801b			os_new_exec_ptr: equ os_new_exec - 2  
801b			  
801b			; resume memory alloocations....  
801b			  
801b			;os_view_disable: equ os_new_exec_ptr - 1  
801b			os_view_af: equ os_new_exec_ptr - 2  
801b			os_view_hl: equ os_view_af -2  
801b			os_view_de: equ os_view_hl - 2  
801b			os_view_bc: equ os_view_de - 2  
801b			  
801b			; stack checksum word  
801b			if DEBUG_STACK_IMB  
801b				curframe: equ  os_view_de - 5  
801b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			else  
801b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			endif  
801b			  
801b			; with data stack could see memory filled with junk. need some memory management   
801b			; malloc and free entry points added  
801b			  
801b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			;heap_end: equ free_list-1  ; Starting address of heap  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			heap_end: equ chk_word-1  ; Starting address of heap  
801b			  
801b			  
801b			;if BASE_KEV   
801b			;heap_start: equ 0800eh  ; Starting address of heap  
801b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;heap_start: equ baseram+15  ; Starting address of heap  
801b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;endif  
801b			  
801b			  
801b			;;;;  
801b			  
801b			  
801b			; change below to point to last memory alloc above  
801b			topusermem:  equ   heap_start  
801b			  
801b			;if BASE_KEV   
801b			;baseusermem: equ 08000h  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;;aseusermem:     equ    12  
801b			;baseusermem:     equ    prompt  
801b			;;baseusermem:     equ    endofcode  
801b			;endif  
801b			  
801b			  
801b			; **********************************************************************  
801b			; **  Constants  
801b			; **********************************************************************  
801b			  
801b			; Constants used by this code module  
801b			kDataReg:   EQU Device_D           ;PIO port A data register  
801b			kContReg:   EQU Device_D+2           ;PIO port A control register  
801b			  
801b			  
801b			portbdata:  equ Device_D+1    ; port b data  
801b			portbctl:   equ Device_D+3    ; port b control  
801b			  
801b			  
801b			;KEY_SHIFT:   equ 5  
801b			;KEY_SYMBOLSHIFT:  equ 6  
801b			  
801b			KEY_SHIFTLOCK: equ 4  
801b			  
801b			  
801b			KEY_UP: equ 5  
801b			KEY_NEXTWORD: equ 6  
801b			KEY_PREVWORD: equ 7  
801b			KEY_BS: equ 8  
801b			KEY_TAB:  equ 9  
801b			KEY_DOWN: equ 10  
801b			KEY_LEFT: equ 11  
801b			KEY_RIGHT: equ 12  
801b			KEY_CR:   equ 13  
801b			KEY_HOME: equ 14  
801b			KEY_END: equ 15  
801b			  
801b			KEY_F1: equ 16  
801b			KEY_F2: equ 17  
801b			KEY_F3: equ 18  
801b			KEY_F4: equ 19  
801b			  
801b			KEY_F5: equ 20  
801b			KEY_F6: equ 21  
801b			KEY_F7: equ 22  
801b			KEY_F8: equ 23  
801b			  
801b			KEY_F9: equ 24  
801b			KEY_F10: equ 25  
801b			KEY_F11: equ 26  
801b			KEY_F12: equ 27  
801b			  
801b			;if DEBUG_KEY  
801b			;	KEY_MATRIX_NO_PRESS: equ '.'  
801b			;	KEY_SHIFT:   equ '.'  
801b			;	KEY_SYMBOLSHIFT:  equ '.'  
801b			;else  
801b				KEY_SHIFT:   equ '~'  
801b				KEY_SYMBOLSHIFT:  equ '~'  
801b				KEY_MATRIX_NO_PRESS: equ '~'  
801b			;endi  
801b			  
801b			  
801b			  
801b			  
801b			; Macro to make adding debug marks easier  
801b			  
801b			DMARK: macro str  
801b				push af  
801b				ld a, (.dmark)  
801b				ld (debug_mark),a  
801b				ld a, (.dmark+1)  
801b				ld (debug_mark+1),a  
801b				ld a, (.dmark+2)  
801b				ld (debug_mark+2),a  
801b				jr .pastdmark  
801b			.dmark: db str  
801b			.pastdmark: pop af  
801b			  
801b			endm  
801b			  
801b			  
801b			; macro to detect for stack imbalances  
801b			  
801b			include "stackimbal.asm"  
801b			; Macro and code to detect stock imbalances 
801b			 
801b			SPPUSH: equ 0 
801b			 
801b			; Add a stack frame which can be checked before return 
801b			 
801b			STACKFRAME: macro onoff frame1 frame2 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b						exx 
801b			 
801b						ld de, frame1 
801b						ld a, d 
801b						ld hl, curframe 
801b						call hexout 
801b						ld a, e 
801b						ld hl, curframe+2 
801b						call hexout 
801b			  
801b						ld hl, frame1 
801b						push hl 
801b						ld hl, frame2 
801b						push hl 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			endm 
801b			 
801b			STACKFRAMECHK: macro onoff frame1 frame2 
801b			 
801b					 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						exx 
801b						; check stack frame SP 
801b			 
801b						ld hl, frame2 
801b						pop de   ; frame2 
801b			 
801b						call cmp16 
801b						jr nz, .spnosame 
801b						 
801b			 
801b						ld hl, frame1 
801b						pop de   ; frame1 
801b			 
801b						call cmp16 
801b						jr z, .spfrsame 
801b			 
801b						.spnosame: call showsperror 
801b			 
801b						.spfrsame: nop 
801b			 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			 
801b			 
801b			endm 
801b			 
801b			 
801b			; for a sub routine, wrap SP collection and comparisons 
801b			 
801b			; Usage: 
801b			; 
801b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801b			 
801b			SAVESP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b			 
801b						ld (store_sp+(storeword*4)), sp 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			CHECKSP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b			 
801b						; save SP after last save 
801b				 
801b						ld (store_sp+(storeword*4)+2), sp 
801b			 
801b						push hl 
801b						ld hl, store_sp+(storeword*4) 
801b						call check_stack_sp  
801b						pop hl 
801b			 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			if DEBUG_STACK_IMB 
801b			 
801b			check_stack_sp: 
801b					push de 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					push de 
801b			 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					pop hl 
801b			 
801b			 
801b					; check to see if the same 
801b			 
801b					call cmp16 
801b					jr z, .spsame 
801b			 
801b					; not same 
801b			 
801b					call showsperror 
801b			.spsame: 
801b			 
801b					pop de 
801b			 
801b					ret 
801b			 
801b			.sperr:  db "Stack imbalance",0 
801b			 
801b			 
801b			showsperror: 
801b			 
801b			 
801b				push hl 
801b				push af 
801b				push de 
801b				call clear_display 
801b				ld de, .sperr 
801b				ld a,0 
801b			;	ld de,os_word_scratch 
801b				call str_at_display 
801b				ld a, display_row_1+17 
801b				ld de, debug_mark 
801b				call str_at_display 
801b				ld a, 0 
801b				ld (curframe+4),a 
801b				ld hl, curframe 
801b				ld de, os_word_scratch 
801b				ld a, display_row_4 
801b				call str_at_display 
801b				call update_display 
801b				;call break_point_state 
801b				call cin_wait 
801b			 
801b			;	ld a, ' ' 
801b			;	ld (os_view_disable), a 
801b				call bp_on 
801b				pop de	 
801b				pop af 
801b				pop hl 
801b				CALLMONITOR 
801b				ret 
801b			 
801b			endif 
801b			 
801b			 
801b			 
801b			; eof 
# End of file stackimbal.asm
801b			  
801b			;TODO macro to calc col and row offset into screen  
801b			  
801b			  
801b			  
801b			hardware_init:  
801b			  
801b				  
801b			  
801b					;ld a, 0  
801b					;ld (hardware_diag), a  
801b			  
801b					; clear all the buffers  
801b			  
801b 21 10 ed				ld hl, display_fb1  
801e 22 cc eb				ld (display_fb_active), hl  
8021			  
8021 cd ae 8a				call clear_display  
8024			  
8024 21 ce eb				ld hl, display_fb2  
8027 22 cc eb				ld (display_fb_active), hl  
802a			  
802a cd ae 8a				call clear_display  
802d			  
802d					; init primary frame buffer area  
802d 21 b1 ed				ld hl, display_fb0  
8030 22 cc eb				ld (display_fb_active), hl  
8033			  
8033 cd ae 8a				call clear_display  
8036			  
8036			  
8036 cd 2c e4				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8039			  
8039 cd ce e4			call key_init  
803c cd 9e 80			call storage_init  
803f			  
803f				; setup malloc functions  
803f			  
803f				if MALLOC_1  
803f cd 8a 91				call  heap_init  
8042				endif  
8042				if MALLOC_4  
8042					call  heap_init  
8042				endif  
8042			  
8042				; init sound hardware if present  
8042			  
8042				if SOUND_ENABLE  
8042					call sound_init  
8042				endif  
8042			  
8042				; lcd test sequence  
8042					  
8042 cd d1 8a			call update_display  
8045 cd f1 89			call delay1s  
8048 3e 2b			ld a,'+'  
804a cd b3 8a			call fill_display  
804d cd d1 8a			call update_display  
8050 cd f1 89			call delay1s  
8053 3e 2a			ld a,'*'  
8055 cd b3 8a			call fill_display  
8058 cd d1 8a			call update_display  
805b cd f1 89			call delay1s  
805e 3e 2d			ld a,'-'  
8060 cd b3 8a			call fill_display  
8063 cd d1 8a			call update_display  
8066 cd f1 89			call delay1s  
8069			  
8069			; boot splash screen  
8069			if display_cols == 20	  
8069			        ld a, display_row_1    
8069			else  
8069 3e 0a		        ld a, display_row_1 +10   
806b			endif  
806b 11 b8 96			ld de, prom_bootmsg  
806e cd c1 8a			call str_at_display  
8071 cd d1 8a			call update_display  
8074			  
8074			  
8074 cd f1 89			call delay1s  
8077 cd f1 89			call delay1s  
807a			if display_cols == 20	  
807a			            LD   A, display_row_3+2  
807a			else  
807a 3e 5c		            LD   A, display_row_3+12  
807c			endif  
807c 11 cd 96			ld de, prom_bootmsg1  
807f cd c1 8a			call str_at_display  
8082 cd d1 8a			call update_display  
8085 cd f1 89			call delay1s  
8088 cd f1 89			call delay1s  
808b			  
808b			;	ld a, display_row_4+3  
808b			;	ld de, bootmsg2  
808b			;	call str_at_display  
808b			;	call update_display  
808b			;	call delay1s  
808b			;	call delay1s  
808b			  
808b			; debug mark setup  
808b			  
808b 3e 5f		ld a, '_'  
808d 32 6b ee		ld (debug_mark),a  
8090 32 6c ee		ld (debug_mark+1),a  
8093 32 6d ee		ld (debug_mark+2),a  
8096 3e 00		ld a,0  
8098 32 6e ee		ld (debug_mark+3),a  
809b			  
809b c9					ret  
809c			  
809c			  
809c			;bootmsg2:	db "Firmware v0.1",0  
809c			  
809c			; a 4x20 lcd  
809c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809c			  
809c			;if display_cols == 20  
809c			;	include "firmware_lcd_4x20.asm"  
809c			;endif  
809c			  
809c			;if display_cols == 40  
809c			;	include "firmware_lcd_4x40.asm"  
809c			;endif  
809c			  
809c			;  
809c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809c			; TODO abstract the bit bang video out interface for dual display  
809c			; TODO wire video out to tx pin on rc2014 bus  
809c			  
809c			; must supply cin, and cin_wait for low level hardware abstraction   
809c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809c			; test scancode  
809c			  
809c			;;;;;  
809c			;;;  
809c			; Moved out to mini and maxi versions  
809c			;  
809c			; include "firmware_key_4x4.asm"  
809c			; using existing 4 wire x 4 resistor array for input  
809c			;include "firmware_key_4x10.asm"  
809c			; need to mod the board for 5 rows due to resistor array  
809c			;include "firmware_key_5x10.asm"  
809c			  
809c			; storage hardware interface  
809c			  
809c			; use microchip serial eeprom for storage  
809c			  
809c			  
809c			if STORAGE_SE  
809c				include "firmware_spi.asm"  
809c				include "firmware_seeprom.asm"  
809c			else  
809c			   ; create some stubs for the labels  
809c c9			se_readbyte: ret  
809d c9			se_writebyte: ret  
809e c9			storage_init: ret  
809f			  
809f			endif  
809f			  
809f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
809f			;include "firmware_cf.asm"  
809f			  
809f			; load up high level storage hardward abstractions  
809f			include "firmware_storage.asm"  
809f			 
809f			; persisent storage hardware abstraction layer  
809f			 
809f			 
809f			 
809f			; Block 0 on storage is a config state 
809f			 
809f			 
809f			 
809f			; TODO add read phy block and write phy block functions 
809f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
809f			 
809f			; Abstraction layer  
809f			 
809f			; Logocial block size is same size as physical size - using tape concept 
809f			 
809f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
809f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
809f			 
809f			 
809f			 
809f			; Filesystem layout (Logical layout) 
809f			; 
809f			; Block 0 - Bank config  
809f			; 
809f			;      Byte - 0 file id counter 
809f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
809f			;      Byte - 3-20 zero terminated bank label 
809f			; 
809f			; Block 1 > File storage 
809f			; 
809f			;      Byte 0 file id    - block 0 file details 
809f			;      Byte 1 block id - block 0 is file  
809f			;            Byte 2-15 - File name 
809f			; 
809f			;       - to end of block data 
809f			; 
809f			 
809f			; Get ID for the file named in pointer held HL 
809f			; Returns ID in HL = 255 if no file found 
809f			 
809f			storage_getid: 
809f			 
809f 22 73 ea			ld (store_tmp1), hl 
80a2			 
80a2				if DEBUG_STORESE 
80a2					DMARK "SGI" 
80a2 f5				push af  
80a3 3a b7 80			ld a, (.dmark)  
80a6 32 6b ee			ld (debug_mark),a  
80a9 3a b8 80			ld a, (.dmark+1)  
80ac 32 6c ee			ld (debug_mark+1),a  
80af 3a b9 80			ld a, (.dmark+2)  
80b2 32 6d ee			ld (debug_mark+2),a  
80b5 18 03			jr .pastdmark  
80b7 ..			.dmark: db "SGI"  
80ba f1			.pastdmark: pop af  
80bb			endm  
# End of macro DMARK
80bb					CALLMONITOR 
80bb cd 6f ee			call debug_vector  
80be				endm  
# End of macro CALLMONITOR
80be				endif 
80be				; get block 0 and set counter for number of files to scan 
80be			 
80be cd 29 82			call storage_get_block_0 
80c1			 
80c1 3a 7a ea			ld a, (store_page) 
80c4 47				ld b, a 
80c5			 
80c5				; get extent 0 of each file id 
80c5			 
80c5				if DEBUG_STORESE 
80c5					DMARK "SGc" 
80c5 f5				push af  
80c6 3a da 80			ld a, (.dmark)  
80c9 32 6b ee			ld (debug_mark),a  
80cc 3a db 80			ld a, (.dmark+1)  
80cf 32 6c ee			ld (debug_mark+1),a  
80d2 3a dc 80			ld a, (.dmark+2)  
80d5 32 6d ee			ld (debug_mark+2),a  
80d8 18 03			jr .pastdmark  
80da ..			.dmark: db "SGc"  
80dd f1			.pastdmark: pop af  
80de			endm  
# End of macro DMARK
80de					CALLMONITOR 
80de cd 6f ee			call debug_vector  
80e1				endm  
# End of macro CALLMONITOR
80e1				endif 
80e1 60			.getloop:	ld h, b 
80e2 2e 00				ld l, 0 
80e4 c5					push bc 
80e5			 
80e5 11 7a ea				ld de, store_page 
80e8				if DEBUG_STORESE 
80e8					DMARK "SGr" 
80e8 f5				push af  
80e9 3a fd 80			ld a, (.dmark)  
80ec 32 6b ee			ld (debug_mark),a  
80ef 3a fe 80			ld a, (.dmark+1)  
80f2 32 6c ee			ld (debug_mark+1),a  
80f5 3a ff 80			ld a, (.dmark+2)  
80f8 32 6d ee			ld (debug_mark+2),a  
80fb 18 03			jr .pastdmark  
80fd ..			.dmark: db "SGr"  
8100 f1			.pastdmark: pop af  
8101			endm  
# End of macro DMARK
8101					CALLMONITOR 
8101 cd 6f ee			call debug_vector  
8104				endm  
# End of macro CALLMONITOR
8104				endif 
8104 cd d1 86				call storage_read 
8107 cd 04 8d				call ishlzero 
810a 28 2d				jr z, .gap 
810c					 
810c					; have a file name read. Is it one we want. 
810c			 
810c 2a 73 ea				ld hl, (store_tmp1) 
810f 11 7d ea				ld de, store_page+3   ; file name 
8112			 
8112				if DEBUG_STORESE 
8112					DMARK "SGc" 
8112 f5				push af  
8113 3a 27 81			ld a, (.dmark)  
8116 32 6b ee			ld (debug_mark),a  
8119 3a 28 81			ld a, (.dmark+1)  
811c 32 6c ee			ld (debug_mark+1),a  
811f 3a 29 81			ld a, (.dmark+2)  
8122 32 6d ee			ld (debug_mark+2),a  
8125 18 03			jr .pastdmark  
8127 ..			.dmark: db "SGc"  
812a f1			.pastdmark: pop af  
812b			endm  
# End of macro DMARK
812b					CALLMONITOR 
812b cd 6f ee			call debug_vector  
812e				endm  
# End of macro CALLMONITOR
812e				endif 
812e cd 71 91				call strcmp 
8131 20 06				jr nz, .gap   ; not this one 
8133			 
8133 c1				        pop bc 
8134			 
8134 26 00				ld h, 0 
8136 68					ld l, b 
8137 18 22				jr .getdone 
8139						 
8139			 
8139			 
8139			 
8139			.gap: 
8139				if DEBUG_STORESE 
8139					DMARK "SGg" 
8139 f5				push af  
813a 3a 4e 81			ld a, (.dmark)  
813d 32 6b ee			ld (debug_mark),a  
8140 3a 4f 81			ld a, (.dmark+1)  
8143 32 6c ee			ld (debug_mark+1),a  
8146 3a 50 81			ld a, (.dmark+2)  
8149 32 6d ee			ld (debug_mark+2),a  
814c 18 03			jr .pastdmark  
814e ..			.dmark: db "SGg"  
8151 f1			.pastdmark: pop af  
8152			endm  
# End of macro DMARK
8152					CALLMONITOR 
8152 cd 6f ee			call debug_vector  
8155				endm  
# End of macro CALLMONITOR
8155				endif 
8155			 
8155 c1					pop bc 
8156 10 89				djnz .getloop 
8158 21 ff 00				ld hl, 255 
815b			.getdone: 
815b			 
815b				if DEBUG_STORESE 
815b					DMARK "SGe" 
815b f5				push af  
815c 3a 70 81			ld a, (.dmark)  
815f 32 6b ee			ld (debug_mark),a  
8162 3a 71 81			ld a, (.dmark+1)  
8165 32 6c ee			ld (debug_mark+1),a  
8168 3a 72 81			ld a, (.dmark+2)  
816b 32 6d ee			ld (debug_mark+2),a  
816e 18 03			jr .pastdmark  
8170 ..			.dmark: db "SGe"  
8173 f1			.pastdmark: pop af  
8174			endm  
# End of macro DMARK
8174					CALLMONITOR 
8174 cd 6f ee			call debug_vector  
8177				endm  
# End of macro CALLMONITOR
8177				endif 
8177			 
8177 c9				ret 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			; Read Block 
8178			; ---------- 
8178			; 
8178			; With current bank 
8178			;  
8178			; Get block number to read 
8178			; Load physical blocks starting at start block into buffer 
8178			 
8178			; de points to buffer to use 
8178			; hl holds logical block number  
8178			 
8178			storage_read_block: 
8178			 
8178				; TODO bank selection 
8178			 
8178				; for each of the physical blocks read it into the buffer 
8178 06 40			ld b, STORE_BLOCK_PHY 
817a			 
817a				if DEBUG_STORESE 
817a d5					push de 
817b				endif 
817b				 
817b			.rl1:    
817b			 
817b				; read physical block at hl into de 
817b			        ; increment hl and de to next read position on exit 
817b			 
817b e5				push hl 
817c d5				push de	 
817d c5				push bc 
817e			;	if DEBUG_STORESE 
817e			;		push af 
817e			;		ld a, 'R' 
817e			;		ld (debug_mark),a 
817e			;		pop af 
817e			;		CALLMONITOR 
817e			;	endif 
817e cd 9c 80			call se_readbyte 
8181			;	if DEBUG_STORESE 
8181			;		ld a,(spi_portbyte) 
8181			;		ld l, a 
8181			;		push af 
8181			;		ld a, '1' 
8181			;		ld (debug_mark),a 
8181			;		pop af 
8181			;		CALLMONITOR 
8181			;	endif 
8181 c1				pop bc 
8182 d1				pop de 
8183 e1				pop hl 
8184 12				ld (de),a 
8185 23				inc hl 
8186 13				inc de 
8187			 
8187			;	if DEBUG_STORESE 
8187			;		push af 
8187			;		ld a, 'r' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187			;		CALLMONITOR 
8187			;	endif 
8187			 
8187 10 f2			djnz .rl1 
8189			 
8189				if DEBUG_STORESE 
8189					DMARK "SRB" 
8189 f5				push af  
818a 3a 9e 81			ld a, (.dmark)  
818d 32 6b ee			ld (debug_mark),a  
8190 3a 9f 81			ld a, (.dmark+1)  
8193 32 6c ee			ld (debug_mark+1),a  
8196 3a a0 81			ld a, (.dmark+2)  
8199 32 6d ee			ld (debug_mark+2),a  
819c 18 03			jr .pastdmark  
819e ..			.dmark: db "SRB"  
81a1 f1			.pastdmark: pop af  
81a2			endm  
# End of macro DMARK
81a2 d1					pop de 
81a3			; 
81a3			;		push af 
81a3			;		ld a, 'R' 
81a3			;		ld (debug_mark),a 
81a3			;		pop af 
81a3					CALLMONITOR 
81a3 cd 6f ee			call debug_vector  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6 c9				ret	 
81a7				 
81a7			 
81a7			; File Size 
81a7			; --------- 
81a7			; 
81a7			;   hl file id 
81a7			; 
81a7			;  returns in hl the number of blocks 
81a7			 
81a7			storage_file_size: 
81a7 5d				ld e, l 
81a8 16 00			ld d, 0 
81aa 21 40 00			ld hl, STORE_BLOCK_PHY 
81ad					if DEBUG_FORTH_WORDS 
81ad						DMARK "SIZ" 
81ad f5				push af  
81ae 3a c2 81			ld a, (.dmark)  
81b1 32 6b ee			ld (debug_mark),a  
81b4 3a c3 81			ld a, (.dmark+1)  
81b7 32 6c ee			ld (debug_mark+1),a  
81ba 3a c4 81			ld a, (.dmark+2)  
81bd 32 6d ee			ld (debug_mark+2),a  
81c0 18 03			jr .pastdmark  
81c2 ..			.dmark: db "SIZ"  
81c5 f1			.pastdmark: pop af  
81c6			endm  
# End of macro DMARK
81c6						CALLMONITOR 
81c6 cd 6f ee			call debug_vector  
81c9				endm  
# End of macro CALLMONITOR
81c9					endif 
81c9 cd ab 84			call storage_findnextid 
81cc			 
81cc cd 04 8d			call ishlzero 
81cf			;	ld a, l 
81cf			;	add h 
81cf			;	cp 0 
81cf c8				ret z			; block not found so EOF 
81d0			 
81d0 11 7a ea			ld de, store_page 
81d3 cd 78 81			call storage_read_block 
81d6			 
81d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81d9 6f				ld l, a 
81da 26 00			ld h, 0 
81dc c9			 	ret 
81dd			 
81dd			 
81dd			; Write Block 
81dd			; ----------- 
81dd			; 
81dd			; With current bank 
81dd			;  
81dd			; Get block number to write 
81dd			; Write physical blocks starting at start block from buffer 
81dd			  
81dd			storage_write_block: 
81dd				; TODO bank selection 
81dd			 
81dd				; for each of the physical blocks read it into the buffer 
81dd 06 40			ld b, STORE_BLOCK_PHY 
81df			 
81df				if DEBUG_STORESE 
81df					DMARK "SWB" 
81df f5				push af  
81e0 3a f4 81			ld a, (.dmark)  
81e3 32 6b ee			ld (debug_mark),a  
81e6 3a f5 81			ld a, (.dmark+1)  
81e9 32 6c ee			ld (debug_mark+1),a  
81ec 3a f6 81			ld a, (.dmark+2)  
81ef 32 6d ee			ld (debug_mark+2),a  
81f2 18 03			jr .pastdmark  
81f4 ..			.dmark: db "SWB"  
81f7 f1			.pastdmark: pop af  
81f8			endm  
# End of macro DMARK
81f8			 
81f8					;push af 
81f8					;ld a, 'W' 
81f8					;ld (debug_mark),a 
81f8					;pop af 
81f8					CALLMONITOR 
81f8 cd 6f ee			call debug_vector  
81fb				endm  
# End of macro CALLMONITOR
81fb				endif 
81fb			 
81fb			; might not be working 
81fb			;	call se_writepage 
81fb			 
81fb			;	ret 
81fb			; 
81fb			 
81fb			 
81fb			 
81fb			.wl1:    
81fb			 
81fb				; read physical block at hl into de 
81fb			        ; increment hl and de to next read position on exit 
81fb			 
81fb e5				push hl 
81fc d5				push de	 
81fd c5				push bc 
81fe 1a				ld a,(de) 
81ff				;if DEBUG_STORESE 
81ff			;		push af 
81ff			;		ld a, 'W' 
81ff			;		ld (debug_mark),a 
81ff			;		pop af 
81ff			;		CALLMONITOR 
81ff			;	endif 
81ff cd 9d 80			call se_writebyte 
8202			;	call delay250ms 
8202 00				nop 
8203 00				nop 
8204 00				nop 
8205			;	if DEBUG_STORESE 
8205			;		push af 
8205			;		ld a, 'w' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205			;		CALLMONITOR 
8205			;	endif 
8205 c1				pop bc 
8206 d1				pop de 
8207 e1				pop hl 
8208 23				inc hl 
8209 13				inc de 
820a			 
820a			 
820a 10 ef			djnz .wl1 
820c			 
820c				if DEBUG_STORESE 
820c					DMARK "SW2" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 6b ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 6c ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 6d ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SW2"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			 
8225					;push af 
8225					;ld a, 'W' 
8225					;ld (debug_mark),a 
8225					;pop af 
8225					CALLMONITOR 
8225 cd 6f ee			call debug_vector  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228 c9				ret	 
8229			 
8229			; Init bank 
8229			; --------- 
8229			; 
8229			; With current bank 
8229			; 
8229			; Setup block 0 config 
8229			;     Set 0 file id counter 
8229			;     Set formatted byte pattern 
8229			;     Zero out bank label 
8229			;      
8229			; For every logical block write 0-1 byte as null 
8229			 
8229			storage_get_block_0: 
8229			 
8229				; TODO check presence 
8229			 
8229				; get block 0 config 
8229			 
8229 21 00 00			ld hl, 0 
822c 11 7a ea			ld de, store_page 
822f cd 78 81			call storage_read_block 
8232			 
8232				if DEBUG_STORESE 
8232					DMARK "SB0" 
8232 f5				push af  
8233 3a 47 82			ld a, (.dmark)  
8236 32 6b ee			ld (debug_mark),a  
8239 3a 48 82			ld a, (.dmark+1)  
823c 32 6c ee			ld (debug_mark+1),a  
823f 3a 49 82			ld a, (.dmark+2)  
8242 32 6d ee			ld (debug_mark+2),a  
8245 18 03			jr .pastdmark  
8247 ..			.dmark: db "SB0"  
824a f1			.pastdmark: pop af  
824b			endm  
# End of macro DMARK
824b 11 7a ea				ld de, store_page 
824e			;		push af 
824e			;		ld a, 'i' 
824e			;		ld (debug_mark),a 
824e			;		pop af 
824e					CALLMONITOR 
824e cd 6f ee			call debug_vector  
8251				endm  
# End of macro CALLMONITOR
8251				endif 
8251			 
8251				; is this area formatted? 
8251			 
8251			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8251 2a 7b ea			ld hl, (store_page+1) 
8254 3e 80			ld a,0x80 
8256 bd				cp l 
8257 20 22			jr nz, .ininotformatted 
8259				; do a double check 
8259 3e 27			ld a, 0x27 
825b bc				cp h 
825c 20 1d			jr nz, .ininotformatted 
825e			 
825e				; formatted then 
825e			 
825e				if DEBUG_STORESE 
825e					DMARK "SB1" 
825e f5				push af  
825f 3a 73 82			ld a, (.dmark)  
8262 32 6b ee			ld (debug_mark),a  
8265 3a 74 82			ld a, (.dmark+1)  
8268 32 6c ee			ld (debug_mark+1),a  
826b 3a 75 82			ld a, (.dmark+2)  
826e 32 6d ee			ld (debug_mark+2),a  
8271 18 03			jr .pastdmark  
8273 ..			.dmark: db "SB1"  
8276 f1			.pastdmark: pop af  
8277			endm  
# End of macro DMARK
8277					;push af 
8277					;ld a, 'I' 
8277					;ld (debug_mark),a 
8277					;pop af 
8277					CALLMONITOR 
8277 cd 6f ee			call debug_vector  
827a				endm  
# End of macro CALLMONITOR
827a				endif 
827a c9				ret 
827b			 
827b			.ininotformatted: 
827b				; bank not formatted so poke various bits to make sure 
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "SB2" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 6b ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 6c ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 6d ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "SB2"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					;push af 
8294					;ld a, 'f' 
8294					;ld (debug_mark),a 
8294					;pop af 
8294					CALLMONITOR 
8294 cd 6f ee			call debug_vector  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 cd b4 89			call storage_clear_page 
829a			 
829a 21 7a ea			ld hl, store_page 
829d 3e 00			ld a, 0 
829f				 
829f 77				ld (hl),a   ; reset file counter 
82a0			 
82a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a3 22 7b ea		 	ld (store_page+1), hl	 
82a6			 
82a6				; set default label 
82a6			 
82a6 21 42 83			ld hl, .defaultbanklabl 
82a9 11 7d ea		 	ld de, store_page+3 
82ac 01 0f 00			ld bc, 15 
82af ed b0			ldir 
82b1			 
82b1				; Append the current bank id 
82b1 21 86 ea			ld hl, store_page+3+9 
82b4 3a 5f ea			ld a, (spi_device_id) 
82b7 77				ld (hl), a 
82b8			 
82b8				; save default page 0 
82b8			 
82b8 21 00 00			ld hl, 0 
82bb 11 7a ea			ld de, store_page 
82be				if DEBUG_STORESE 
82be					DMARK "SB3" 
82be f5				push af  
82bf 3a d3 82			ld a, (.dmark)  
82c2 32 6b ee			ld (debug_mark),a  
82c5 3a d4 82			ld a, (.dmark+1)  
82c8 32 6c ee			ld (debug_mark+1),a  
82cb 3a d5 82			ld a, (.dmark+2)  
82ce 32 6d ee			ld (debug_mark+2),a  
82d1 18 03			jr .pastdmark  
82d3 ..			.dmark: db "SB3"  
82d6 f1			.pastdmark: pop af  
82d7			endm  
# End of macro DMARK
82d7			;		push af 
82d7			;		ld a, 'F' 
82d7			;		ld (debug_mark),a 
82d7			;		pop af 
82d7					CALLMONITOR 
82d7 cd 6f ee			call debug_vector  
82da				endm  
# End of macro CALLMONITOR
82da				endif 
82da cd dd 81			call storage_write_block 
82dd				if DEBUG_STORESE 
82dd					DMARK "SB4" 
82dd f5				push af  
82de 3a f2 82			ld a, (.dmark)  
82e1 32 6b ee			ld (debug_mark),a  
82e4 3a f3 82			ld a, (.dmark+1)  
82e7 32 6c ee			ld (debug_mark+1),a  
82ea 3a f4 82			ld a, (.dmark+2)  
82ed 32 6d ee			ld (debug_mark+2),a  
82f0 18 03			jr .pastdmark  
82f2 ..			.dmark: db "SB4"  
82f5 f1			.pastdmark: pop af  
82f6			endm  
# End of macro DMARK
82f6			;		push af 
82f6			;		ld a, '>' 
82f6			;		ld (debug_mark),a 
82f6			;		pop af 
82f6					CALLMONITOR 
82f6 cd 6f ee			call debug_vector  
82f9				endm  
# End of macro CALLMONITOR
82f9				endif 
82f9			 
82f9 00				nop 
82fa 00				nop 
82fb 00				nop 
82fc			 
82fc				; now set 0 in every page to mark as a free block 
82fc			 
82fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82fe 21 40 00			ld hl, STORE_BLOCK_PHY 
8301			 
8301 3e 00		.setmark1:   	ld a,0 
8303 e5					push hl 
8304 c5					push bc 
8305 cd 9d 80				call se_writebyte 
8308 3e 0a			ld a, 10 
830a cd d6 89			call aDelayInMS 
830d 23				inc hl 
830e cd 9d 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd d6 89			call aDelayInMS 
8316 2b				dec hl 
8317 c1					pop bc 
8318 e1					pop hl 
8319 3e 40				ld a, STORE_BLOCK_PHY 
831b cd db 8c				call addatohl 
831e 10 e1				djnz .setmark1 
8320			 
8320 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8322 3e 00		.setmark2:   	ld a,0 
8324 e5					push hl 
8325 c5					push bc 
8326 cd 9d 80				call se_writebyte 
8329 3e 0a			ld a, 10 
832b cd d6 89			call aDelayInMS 
832e 23				inc hl 
832f cd 9d 80				call se_writebyte 
8332 3e 0a			ld a, 10 
8334 cd d6 89			call aDelayInMS 
8337 2b				dec hl 
8338 c1					pop bc 
8339 e1					pop hl 
833a 3e 40				ld a, STORE_BLOCK_PHY 
833c cd db 8c				call addatohl 
833f 10 e1				djnz .setmark2 
8341			 
8341					 
8341			 
8341			 
8341 c9				ret 
8342			 
8342			 
8342			 
8342			 
8342 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834d			 
834d			 
834d			 
834d			; Label Bank 
834d			; ---------- 
834d			; 
834d			; With current bank 
834d			; Read block 0 
834d			; Set label 
834d			; Write block 0 
834d			 
834d			; label str pointer in hl 
834d			 
834d			storage_label:     
834d			 
834d				if DEBUG_STORESE 
834d					DMARK "LBL" 
834d f5				push af  
834e 3a 62 83			ld a, (.dmark)  
8351 32 6b ee			ld (debug_mark),a  
8354 3a 63 83			ld a, (.dmark+1)  
8357 32 6c ee			ld (debug_mark+1),a  
835a 3a 64 83			ld a, (.dmark+2)  
835d 32 6d ee			ld (debug_mark+2),a  
8360 18 03			jr .pastdmark  
8362 ..			.dmark: db "LBL"  
8365 f1			.pastdmark: pop af  
8366			endm  
# End of macro DMARK
8366					CALLMONITOR 
8366 cd 6f ee			call debug_vector  
8369				endm  
# End of macro CALLMONITOR
8369				endif 
8369			 
8369 e5				push hl 
836a			 
836a cd 29 82			call storage_get_block_0 
836d			 
836d				; set default label 
836d			 
836d e1				pop hl 
836e			 
836e 11 7d ea		 	ld de, store_page+3 
8371 01 0f 00			ld bc, 15 
8374				if DEBUG_STORESE 
8374					DMARK "LB3" 
8374 f5				push af  
8375 3a 89 83			ld a, (.dmark)  
8378 32 6b ee			ld (debug_mark),a  
837b 3a 8a 83			ld a, (.dmark+1)  
837e 32 6c ee			ld (debug_mark+1),a  
8381 3a 8b 83			ld a, (.dmark+2)  
8384 32 6d ee			ld (debug_mark+2),a  
8387 18 03			jr .pastdmark  
8389 ..			.dmark: db "LB3"  
838c f1			.pastdmark: pop af  
838d			endm  
# End of macro DMARK
838d					CALLMONITOR 
838d cd 6f ee			call debug_vector  
8390				endm  
# End of macro CALLMONITOR
8390				endif 
8390 ed b0			ldir 
8392				; save default page 0 
8392			 
8392 21 00 00			ld hl, 0 
8395 11 7a ea			ld de, store_page 
8398				if DEBUG_STORESE 
8398					DMARK "LBW" 
8398 f5				push af  
8399 3a ad 83			ld a, (.dmark)  
839c 32 6b ee			ld (debug_mark),a  
839f 3a ae 83			ld a, (.dmark+1)  
83a2 32 6c ee			ld (debug_mark+1),a  
83a5 3a af 83			ld a, (.dmark+2)  
83a8 32 6d ee			ld (debug_mark+2),a  
83ab 18 03			jr .pastdmark  
83ad ..			.dmark: db "LBW"  
83b0 f1			.pastdmark: pop af  
83b1			endm  
# End of macro DMARK
83b1					CALLMONITOR 
83b1 cd 6f ee			call debug_vector  
83b4				endm  
# End of macro CALLMONITOR
83b4				endif 
83b4 cd dd 81			call storage_write_block 
83b7			 
83b7 c9				ret 
83b8			 
83b8			 
83b8			 
83b8			; Read Block 0 - Config 
83b8			; --------------------- 
83b8			; 
83b8			; With current bank 
83b8			; Call presence test 
83b8			;    If not present format/init bank  
83b8			; Read block 0  
83b8			;  
83b8			 
83b8			 
83b8			; Dir 
83b8			; --- 
83b8			; 
83b8			; With current bank 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block read byte 2 
83b8			;      if first block of file 
83b8			;         Display file name 
83b8			;         Display type flags for file 
83b8			;        
83b8			 
83b8			; moving to words as this requires stack control 
83b8			 
83b8			 
83b8			; Delete File 
83b8			; ----------- 
83b8			; 
83b8			; With current bank 
83b8			; 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block file id 
83b8			;      If first block of file and dont have file id 
83b8			;         if file to delete 
83b8			;         Save file id 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			;      If file id is one saved 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			 
83b8			 
83b8			.se_done: 
83b8 e1				pop hl 
83b9 c9				ret 
83ba			 
83ba			storage_erase: 
83ba			 
83ba				; hl contains the file id 
83ba			 
83ba 5d				ld e, l 
83bb 16 00			ld d, 0 
83bd 21 40 00			ld hl, STORE_BLOCK_PHY 
83c0					if DEBUG_FORTH_WORDS 
83c0						DMARK "ERA" 
83c0 f5				push af  
83c1 3a d5 83			ld a, (.dmark)  
83c4 32 6b ee			ld (debug_mark),a  
83c7 3a d6 83			ld a, (.dmark+1)  
83ca 32 6c ee			ld (debug_mark+1),a  
83cd 3a d7 83			ld a, (.dmark+2)  
83d0 32 6d ee			ld (debug_mark+2),a  
83d3 18 03			jr .pastdmark  
83d5 ..			.dmark: db "ERA"  
83d8 f1			.pastdmark: pop af  
83d9			endm  
# End of macro DMARK
83d9						CALLMONITOR 
83d9 cd 6f ee			call debug_vector  
83dc				endm  
# End of macro CALLMONITOR
83dc					endif 
83dc cd ab 84			call storage_findnextid 
83df cd 04 8d			call ishlzero 
83e2 c8				ret z 
83e3			 
83e3 e5				push hl 
83e4			 
83e4				; TODO check file not found 
83e4			 
83e4 11 7a ea			ld de, store_page 
83e7 cd 78 81			call storage_read_block 
83ea			 
83ea cd 04 8d			call ishlzero 
83ed ca b8 83			jp z,.se_done 
83f0			 
83f0					if DEBUG_FORTH_WORDS 
83f0						DMARK "ER1" 
83f0 f5				push af  
83f1 3a 05 84			ld a, (.dmark)  
83f4 32 6b ee			ld (debug_mark),a  
83f7 3a 06 84			ld a, (.dmark+1)  
83fa 32 6c ee			ld (debug_mark+1),a  
83fd 3a 07 84			ld a, (.dmark+2)  
8400 32 6d ee			ld (debug_mark+2),a  
8403 18 03			jr .pastdmark  
8405 ..			.dmark: db "ER1"  
8408 f1			.pastdmark: pop af  
8409			endm  
# End of macro DMARK
8409						CALLMONITOR 
8409 cd 6f ee			call debug_vector  
840c				endm  
# End of macro CALLMONITOR
840c					endif 
840c 3a 7a ea			ld a, (store_page)	; get file id 
840f 32 6e ea			ld (store_tmpid), a 
8412			 
8412 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8415 32 6d ea			ld (store_tmpext), a 
8418			 
8418				; wipe file header 
8418			 
8418 e1				pop hl 
8419 3e 00			ld a, 0 
841b 32 7a ea			ld (store_page), a 
841e 32 7b ea			ld (store_page+1),a 
8421 11 7a ea			ld de, store_page 
8424					if DEBUG_FORTH_WORDS 
8424						DMARK "ER2" 
8424 f5				push af  
8425 3a 39 84			ld a, (.dmark)  
8428 32 6b ee			ld (debug_mark),a  
842b 3a 3a 84			ld a, (.dmark+1)  
842e 32 6c ee			ld (debug_mark+1),a  
8431 3a 3b 84			ld a, (.dmark+2)  
8434 32 6d ee			ld (debug_mark+2),a  
8437 18 03			jr .pastdmark  
8439 ..			.dmark: db "ER2"  
843c f1			.pastdmark: pop af  
843d			endm  
# End of macro DMARK
843d						CALLMONITOR 
843d cd 6f ee			call debug_vector  
8440				endm  
# End of macro CALLMONITOR
8440					endif 
8440 cd dd 81			call storage_write_block 
8443			 
8443			 
8443				; wipe file extents 
8443			 
8443 3a 6d ea			ld a, (store_tmpext) 
8446 47				ld b, a 
8447			 
8447			.eraext:	  
8447 c5				push bc 
8448			 
8448 21 40 00			ld hl, STORE_BLOCK_PHY 
844b 3a 6e ea			ld a,(store_tmpid) 
844e 5f				ld e, a 
844f 50				ld d, b	 
8450					if DEBUG_FORTH_WORDS 
8450						DMARK "ER3" 
8450 f5				push af  
8451 3a 65 84			ld a, (.dmark)  
8454 32 6b ee			ld (debug_mark),a  
8457 3a 66 84			ld a, (.dmark+1)  
845a 32 6c ee			ld (debug_mark+1),a  
845d 3a 67 84			ld a, (.dmark+2)  
8460 32 6d ee			ld (debug_mark+2),a  
8463 18 03			jr .pastdmark  
8465 ..			.dmark: db "ER3"  
8468 f1			.pastdmark: pop af  
8469			endm  
# End of macro DMARK
8469						CALLMONITOR 
8469 cd 6f ee			call debug_vector  
846c				endm  
# End of macro CALLMONITOR
846c					endif 
846c cd ab 84			call storage_findnextid 
846f cd 04 8d			call ishlzero 
8472 ca b8 83			jp z,.se_done 
8475			 
8475 e5				push hl 
8476 11 7a ea			ld de, store_page 
8479 cd 78 81			call storage_read_block 
847c			 
847c				; free block	 
847c			 
847c 3e 00			ld a, 0 
847e 32 7a ea			ld (store_page), a 
8481 32 7b ea			ld (store_page+1),a 
8484 11 7a ea			ld de, store_page 
8487 e1				pop hl 
8488					if DEBUG_FORTH_WORDS 
8488						DMARK "ER4" 
8488 f5				push af  
8489 3a 9d 84			ld a, (.dmark)  
848c 32 6b ee			ld (debug_mark),a  
848f 3a 9e 84			ld a, (.dmark+1)  
8492 32 6c ee			ld (debug_mark+1),a  
8495 3a 9f 84			ld a, (.dmark+2)  
8498 32 6d ee			ld (debug_mark+2),a  
849b 18 03			jr .pastdmark  
849d ..			.dmark: db "ER4"  
84a0 f1			.pastdmark: pop af  
84a1			endm  
# End of macro DMARK
84a1						CALLMONITOR 
84a1 cd 6f ee			call debug_vector  
84a4				endm  
# End of macro CALLMONITOR
84a4					endif 
84a4 cd dd 81			call storage_write_block 
84a7			 
84a7 c1				pop bc 
84a8 10 9d			djnz .eraext 
84aa			 
84aa c9				ret 
84ab			 
84ab			 
84ab			; Find Free Block 
84ab			; --------------- 
84ab			; 
84ab			; With current bank 
84ab			;  
84ab			; From given starting logical block 
84ab			;    Read block  
84ab			;    If no file id 
84ab			;         Return block id 
84ab			 
84ab			 
84ab			; hl starting page number 
84ab			; hl contains free page number or zero if no pages free 
84ab			; e contains the file id to locate 
84ab			; d contains the block number 
84ab			 
84ab			; TODO change to find file id and use zero for free block 
84ab			 
84ab			storage_findnextid: 
84ab			 
84ab				; now locate first 0 page to mark as a free block 
84ab			 
84ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ad			;	ld hl, STORE_BLOCK_PHY 
84ad			 
84ad					if DEBUG_FORTH_WORDS 
84ad					DMARK "FNI" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 6b ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 6c ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 6d ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "FNI"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6						CALLMONITOR 
84c6 cd 6f ee			call debug_vector  
84c9				endm  
# End of macro CALLMONITOR
84c9					endif 
84c9			.ff1:   	 
84c9 e5					push hl 
84ca c5					push bc 
84cb d5					push de 
84cc cd 9c 80				call se_readbyte 
84cf 5f					ld e,a 
84d0 23					inc hl 
84d1 cd 9c 80				call se_readbyte 
84d4 57					ld d, a 
84d5 e1					pop hl 
84d6 e5					push hl 
84d7 cd f9 8c				call cmp16 
84da 28 49				jr z, .fffound 
84dc			 
84dc d1					pop de 
84dd c1					pop bc 
84de e1					pop hl 
84df			 
84df					; is found? 
84df					;cp e 
84df					;ret z 
84df			 
84df 3e 40				ld a, STORE_BLOCK_PHY 
84e1 cd db 8c				call addatohl 
84e4 10 e3				djnz .ff1 
84e6			 
84e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e8			.ff2:   	 
84e8			 
84e8 e5					push hl 
84e9 c5					push bc 
84ea d5					push de 
84eb cd 9c 80				call se_readbyte 
84ee 5f					ld e,a 
84ef 23					inc hl 
84f0 cd 9c 80				call se_readbyte 
84f3 57					ld d, a 
84f4			 
84f4 e1					pop hl 
84f5 e5					push hl 
84f6 cd f9 8c				call cmp16 
84f9 28 2a				jr z, .fffound 
84fb			 
84fb d1					pop de 
84fc c1					pop bc 
84fd e1					pop hl 
84fe					; is found? 
84fe					;cp e 
84fe					;ret z 
84fe			 
84fe 3e 40				ld a, STORE_BLOCK_PHY 
8500 cd db 8c				call addatohl 
8503 10 e3				djnz .ff2 
8505			 
8505			 
8505					if DEBUG_FORTH_WORDS 
8505					DMARK "FN-" 
8505 f5				push af  
8506 3a 1a 85			ld a, (.dmark)  
8509 32 6b ee			ld (debug_mark),a  
850c 3a 1b 85			ld a, (.dmark+1)  
850f 32 6c ee			ld (debug_mark+1),a  
8512 3a 1c 85			ld a, (.dmark+2)  
8515 32 6d ee			ld (debug_mark+2),a  
8518 18 03			jr .pastdmark  
851a ..			.dmark: db "FN-"  
851d f1			.pastdmark: pop af  
851e			endm  
# End of macro DMARK
851e					;	push af 
851e					;	ld a, 'n' 
851e					;	ld (debug_mark),a 
851e					;	pop af 
851e						CALLMONITOR 
851e cd 6f ee			call debug_vector  
8521				endm  
# End of macro CALLMONITOR
8521					endif 
8521				; no free marks! 
8521 21 00 00				ld hl, 0 
8524 c9				ret 
8525			.fffound: 
8525				 
8525			 
8525 d1					pop de 
8526 c1					pop bc 
8527 e1					pop hl 
8528					if DEBUG_FORTH_WORDS 
8528					DMARK "FNF" 
8528 f5				push af  
8529 3a 3d 85			ld a, (.dmark)  
852c 32 6b ee			ld (debug_mark),a  
852f 3a 3e 85			ld a, (.dmark+1)  
8532 32 6c ee			ld (debug_mark+1),a  
8535 3a 3f 85			ld a, (.dmark+2)  
8538 32 6d ee			ld (debug_mark+2),a  
853b 18 03			jr .pastdmark  
853d ..			.dmark: db "FNF"  
8540 f1			.pastdmark: pop af  
8541			endm  
# End of macro DMARK
8541					;	push af 
8541					;	ld a, 'n' 
8541					;	ld (debug_mark),a 
8541					;	pop af 
8541						CALLMONITOR 
8541 cd 6f ee			call debug_vector  
8544				endm  
# End of macro CALLMONITOR
8544					endif 
8544 c9				ret 
8545			 
8545			 
8545			 
8545			; Free Space 
8545			; ---------- 
8545			; 
8545			; With current bank 
8545			; 
8545			; Set block count to zero 
8545			; Starting with first logical block 
8545			;      Find free block  
8545			;      If block id given, increment block count 
8545			; 
8545			;  
8545			 
8545			 
8545			; hl contains count of free blocks 
8545			 
8545			storage_freeblocks: 
8545			 
8545				; now locate first 0 page to mark as a free block 
8545			 
8545 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8547 21 40 00			ld hl, STORE_BLOCK_PHY 
854a 11 00 00			ld de, 0 
854d			 
854d			.fb1:   	 
854d e5					push hl 
854e c5					push bc 
854f d5					push de 
8550 cd 9c 80				call se_readbyte 
8553 d1					pop de 
8554 c1					pop bc 
8555 e1					pop hl 
8556			 
8556					; is free? 
8556 fe 00				cp 0 
8558 20 01				jr nz, .ff1cont 
855a 13					inc de 
855b			 
855b			.ff1cont: 
855b			 
855b			 
855b 3e 40				ld a, STORE_BLOCK_PHY 
855d cd db 8c				call addatohl 
8560 10 eb				djnz .fb1 
8562			 
8562 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8564			.fb2:   	 
8564 e5					push hl 
8565 c5					push bc 
8566 d5					push de 
8567 cd 9c 80				call se_readbyte 
856a d1					pop de 
856b c1					pop bc 
856c e1					pop hl 
856d			 
856d					; is free? 
856d fe 00				cp 0 
856f 20 01				jr nz, .ff2cont 
8571 13					inc de 
8572			 
8572			.ff2cont: 
8572			 
8572 3e 40				ld a, STORE_BLOCK_PHY 
8574 cd db 8c				call addatohl 
8577 10 eb				djnz .fb2 
8579			 
8579 eb				ex de, hl 
857a c9				ret 
857b			 
857b			; Get File ID 
857b			; ----------- 
857b			; 
857b			; With current bank 
857b			;  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; For each logical block 
857b			;    Read block file id 
857b			;      If first block of file and dont have file id 
857b			;         if file get id and exit 
857b			 
857b			 
857b			 
857b			 
857b			; Create File 
857b			; ----------- 
857b			; 
857b			; With current bank  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; Increment file id number 
857b			; Save Config 
857b			; Find free block 
857b			; Set buffer with file name and file id 
857b			; Write buffer to free block  
857b			 
857b			 
857b			; hl point to file name 
857b			; hl returns file id 
857b			 
857b			; file format: 
857b			; byte 0 - file id 
857b			; byte 1 - extent number 
857b			; byte 2-> data 
857b			 
857b			; format for extent number 0: 
857b			; 
857b			; byte 0 - file id 
857b			; byte 1 - extent 0 
857b			; byte 2 - extent count 
857b			; byte 3 -> file name and meta data 
857b			 
857b			 
857b			storage_create: 
857b				if DEBUG_STORESE 
857b					DMARK "SCR" 
857b f5				push af  
857c 3a 90 85			ld a, (.dmark)  
857f 32 6b ee			ld (debug_mark),a  
8582 3a 91 85			ld a, (.dmark+1)  
8585 32 6c ee			ld (debug_mark+1),a  
8588 3a 92 85			ld a, (.dmark+2)  
858b 32 6d ee			ld (debug_mark+2),a  
858e 18 03			jr .pastdmark  
8590 ..			.dmark: db "SCR"  
8593 f1			.pastdmark: pop af  
8594			endm  
# End of macro DMARK
8594					CALLMONITOR 
8594 cd 6f ee			call debug_vector  
8597				endm  
# End of macro CALLMONITOR
8597				endif 
8597			 
8597 e5				push hl		; save file name pointer 
8598			 
8598 cd 29 82			call storage_get_block_0 
859b			 
859b 3a 7a ea			ld a,(store_page)	; get current file id 
859e 3c				inc a 
859f 32 7a ea			ld (store_page),a 
85a2				 
85a2 32 6e ea			ld (store_tmpid),a			; save id 
85a5			 
85a5 21 00 00			ld hl, 0 
85a8 11 7a ea			ld de, store_page 
85ab				if DEBUG_STORESE 
85ab					DMARK "SCw" 
85ab f5				push af  
85ac 3a c0 85			ld a, (.dmark)  
85af 32 6b ee			ld (debug_mark),a  
85b2 3a c1 85			ld a, (.dmark+1)  
85b5 32 6c ee			ld (debug_mark+1),a  
85b8 3a c2 85			ld a, (.dmark+2)  
85bb 32 6d ee			ld (debug_mark+2),a  
85be 18 03			jr .pastdmark  
85c0 ..			.dmark: db "SCw"  
85c3 f1			.pastdmark: pop af  
85c4			endm  
# End of macro DMARK
85c4					CALLMONITOR 
85c4 cd 6f ee			call debug_vector  
85c7				endm  
# End of macro CALLMONITOR
85c7				endif 
85c7 cd dd 81			call storage_write_block	 ; save update 
85ca			 
85ca				if DEBUG_STORESE 
85ca 11 7a ea				ld de, store_page 
85cd					DMARK "SCC" 
85cd f5				push af  
85ce 3a e2 85			ld a, (.dmark)  
85d1 32 6b ee			ld (debug_mark),a  
85d4 3a e3 85			ld a, (.dmark+1)  
85d7 32 6c ee			ld (debug_mark+1),a  
85da 3a e4 85			ld a, (.dmark+2)  
85dd 32 6d ee			ld (debug_mark+2),a  
85e0 18 03			jr .pastdmark  
85e2 ..			.dmark: db "SCC"  
85e5 f1			.pastdmark: pop af  
85e6			endm  
# End of macro DMARK
85e6					CALLMONITOR 
85e6 cd 6f ee			call debug_vector  
85e9				endm  
# End of macro CALLMONITOR
85e9				endif 
85e9				;  
85e9				 
85e9 21 40 00			ld hl, STORE_BLOCK_PHY 
85ec 11 00 00			ld de, 0 
85ef cd ab 84			call storage_findnextid 
85f2			 
85f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f5			 
85f5				; TODO detect 0 = no spare blocks 
85f5			 
85f5				; hl now contains the free page to use for the file header page 
85f5			 
85f5				if DEBUG_STORESE 
85f5				DMARK "SCF" 
85f5 f5				push af  
85f6 3a 0a 86			ld a, (.dmark)  
85f9 32 6b ee			ld (debug_mark),a  
85fc 3a 0b 86			ld a, (.dmark+1)  
85ff 32 6c ee			ld (debug_mark+1),a  
8602 3a 0c 86			ld a, (.dmark+2)  
8605 32 6d ee			ld (debug_mark+2),a  
8608 18 03			jr .pastdmark  
860a ..			.dmark: db "SCF"  
860d f1			.pastdmark: pop af  
860e			endm  
# End of macro DMARK
860e					CALLMONITOR 
860e cd 6f ee			call debug_vector  
8611				endm  
# End of macro CALLMONITOR
8611				endif 
8611			 
8611 22 65 ea			ld (store_tmppageid), hl 
8614				 
8614 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8617			;	ld a, (store_filecache)			; save to cache 
8617			 
8617 32 7a ea			ld (store_page),a    ; set page id 
861a 3e 00			ld a, 0			 ; extent 0 is file header 
861c 32 7b ea			ld (store_page+1), a   ; set file extent 
861f			 
861f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8622			 
8622			;	inc hl 		; init block 0 of file 
8622			;	inc hl   		; skip file and extent id 
8622			 ;       ld a, 0 
8622			;	ld (hl),a 
8622			;	ld a, (store_filecache+1)  	; save to cache 
8622			 
8622			;	inc hl    ; file name 
8622				 
8622				 
8622 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8625				if DEBUG_STORESE 
8625					DMARK "SCc" 
8625 f5				push af  
8626 3a 3a 86			ld a, (.dmark)  
8629 32 6b ee			ld (debug_mark),a  
862c 3a 3b 86			ld a, (.dmark+1)  
862f 32 6c ee			ld (debug_mark+1),a  
8632 3a 3c 86			ld a, (.dmark+2)  
8635 32 6d ee			ld (debug_mark+2),a  
8638 18 03			jr .pastdmark  
863a ..			.dmark: db "SCc"  
863d f1			.pastdmark: pop af  
863e			endm  
# End of macro DMARK
863e					CALLMONITOR 
863e cd 6f ee			call debug_vector  
8641				endm  
# End of macro CALLMONITOR
8641				endif 
8641 e1				pop hl    ; get zero term string 
8642 e5				push hl 
8643 3e 00			ld a, 0 
8645 cd 44 91			call strlent 
8648 23				inc hl   ; cover zero term 
8649 06 00			ld b,0 
864b 4d				ld c,l 
864c e1				pop hl 
864d				;ex de, hl 
864d				if DEBUG_STORESE 
864d					DMARK "SCa" 
864d f5				push af  
864e 3a 62 86			ld a, (.dmark)  
8651 32 6b ee			ld (debug_mark),a  
8654 3a 63 86			ld a, (.dmark+1)  
8657 32 6c ee			ld (debug_mark+1),a  
865a 3a 64 86			ld a, (.dmark+2)  
865d 32 6d ee			ld (debug_mark+2),a  
8660 18 03			jr .pastdmark  
8662 ..			.dmark: db "SCa"  
8665 f1			.pastdmark: pop af  
8666			endm  
# End of macro DMARK
8666					;push af 
8666					;ld a, 'a' 
8666					;ld (debug_mark),a 
8666					;pop af 
8666					CALLMONITOR 
8666 cd 6f ee			call debug_vector  
8669				endm  
# End of macro CALLMONITOR
8669				endif 
8669 ed b0			ldir    ; copy zero term string 
866b				if DEBUG_STORESE 
866b					DMARK "SCA" 
866b f5				push af  
866c 3a 80 86			ld a, (.dmark)  
866f 32 6b ee			ld (debug_mark),a  
8672 3a 81 86			ld a, (.dmark+1)  
8675 32 6c ee			ld (debug_mark+1),a  
8678 3a 82 86			ld a, (.dmark+2)  
867b 32 6d ee			ld (debug_mark+2),a  
867e 18 03			jr .pastdmark  
8680 ..			.dmark: db "SCA"  
8683 f1			.pastdmark: pop af  
8684			endm  
# End of macro DMARK
8684					CALLMONITOR 
8684 cd 6f ee			call debug_vector  
8687				endm  
# End of macro CALLMONITOR
8687				endif 
8687			 
8687				; write file header page 
8687			 
8687 2a 65 ea			ld hl,(store_tmppageid) 
868a 11 7a ea			ld de, store_page 
868d				if DEBUG_STORESE 
868d					DMARK "SCb" 
868d f5				push af  
868e 3a a2 86			ld a, (.dmark)  
8691 32 6b ee			ld (debug_mark),a  
8694 3a a3 86			ld a, (.dmark+1)  
8697 32 6c ee			ld (debug_mark+1),a  
869a 3a a4 86			ld a, (.dmark+2)  
869d 32 6d ee			ld (debug_mark+2),a  
86a0 18 03			jr .pastdmark  
86a2 ..			.dmark: db "SCb"  
86a5 f1			.pastdmark: pop af  
86a6			endm  
# End of macro DMARK
86a6					;push af 
86a6					;ld a, 'b' 
86a6					;ld (debug_mark),a 
86a6					;pop af 
86a6					CALLMONITOR 
86a6 cd 6f ee			call debug_vector  
86a9				endm  
# End of macro CALLMONITOR
86a9				endif 
86a9 cd dd 81			call storage_write_block 
86ac			 
86ac 3a 6e ea			ld a, (store_tmpid) 
86af 6f				ld l, a 
86b0 26 00			ld h,0 
86b2				if DEBUG_STORESE 
86b2					DMARK "SCz" 
86b2 f5				push af  
86b3 3a c7 86			ld a, (.dmark)  
86b6 32 6b ee			ld (debug_mark),a  
86b9 3a c8 86			ld a, (.dmark+1)  
86bc 32 6c ee			ld (debug_mark+1),a  
86bf 3a c9 86			ld a, (.dmark+2)  
86c2 32 6d ee			ld (debug_mark+2),a  
86c5 18 03			jr .pastdmark  
86c7 ..			.dmark: db "SCz"  
86ca f1			.pastdmark: pop af  
86cb			endm  
# End of macro DMARK
86cb					CALLMONITOR 
86cb cd 6f ee			call debug_vector  
86ce				endm  
# End of macro CALLMONITOR
86ce				endif 
86ce c9				ret 
86cf				 
86cf			 
86cf			 
86cf			; 
86cf			; Read File 
86cf			; 
86cf			; h - file id to locate 
86cf			; l - extent to locate 
86cf			; de - pointer to string to read into 
86cf			; 
86cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86cf			 
86cf			.sr_fail: 
86cf d1				pop de 
86d0 c9				ret 
86d1			 
86d1			storage_read: 
86d1			 
86d1			 
86d1 d5				push de 
86d2			 
86d2			; TODO BUG the above push is it popped before the RET Z? 
86d2			 
86d2			; TODO how to handle multiple part blocks 
86d2			 
86d2				; locate file extent to read 
86d2			 
86d2 5c				ld e, h 
86d3 55				ld d, l 
86d4			 
86d4			.srext: 
86d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86db			 
86db 21 40 00			ld hl, STORE_BLOCK_PHY 
86de				if DEBUG_STORESE 
86de					DMARK "sre" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 6b ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 6c ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 6d ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "sre"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 6f ee			call debug_vector  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd ab 84			call storage_findnextid 
86fd			 
86fd				if DEBUG_STORESE 
86fd					DMARK "srf" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 6b ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 6c ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 6d ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "srf"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 6f ee			call debug_vector  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 cd 04 8d			call ishlzero 
871c			;	ld a, l 
871c			;	add h 
871c			;	cp 0 
871c 28 b1			jr z,.sr_fail			; block not found so EOF 
871e			 
871e				; save current address for use by higher level words etc 
871e			 
871e 22 6b ea			ld (store_openaddr),hl 
8721			 
8721			 
8721				; hl contains page number to load 
8721 d1				pop de   ; get storage 
8722 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8726 d5				push de 
8727				if DEBUG_STORESE 
8727					DMARK "srg" 
8727 f5				push af  
8728 3a 3c 87			ld a, (.dmark)  
872b 32 6b ee			ld (debug_mark),a  
872e 3a 3d 87			ld a, (.dmark+1)  
8731 32 6c ee			ld (debug_mark+1),a  
8734 3a 3e 87			ld a, (.dmark+2)  
8737 32 6d ee			ld (debug_mark+2),a  
873a 18 03			jr .pastdmark  
873c ..			.dmark: db "srg"  
873f f1			.pastdmark: pop af  
8740			endm  
# End of macro DMARK
8740					CALLMONITOR 
8740 cd 6f ee			call debug_vector  
8743				endm  
# End of macro CALLMONITOR
8743				endif 
8743 cd 78 81			call storage_read_block 
8746			 
8746				; if this a continuation read??? 
8746			 
8746 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8749			 
8749 3e 3f			ld a, STORE_BLOCK_PHY-1 
874b cd db 8c			call addatohl 
874e 7e				ld a,(hl) 
874f fe 00			cp 0 
8751 28 02			jr z, .markiscont 
8753 3e ff			ld a, 255 
8755			 
8755			.markiscont: 
8755 32 6d ea			ld (store_readcont), a 
8758			 
8758				if DEBUG_STORESE 
8758					DMARK "srC" 
8758 f5				push af  
8759 3a 6d 87			ld a, (.dmark)  
875c 32 6b ee			ld (debug_mark),a  
875f 3a 6e 87			ld a, (.dmark+1)  
8762 32 6c ee			ld (debug_mark+1),a  
8765 3a 6f 87			ld a, (.dmark+2)  
8768 32 6d ee			ld (debug_mark+2),a  
876b 18 03			jr .pastdmark  
876d ..			.dmark: db "srC"  
8770 f1			.pastdmark: pop af  
8771			endm  
# End of macro DMARK
8771					CALLMONITOR 
8771 cd 6f ee			call debug_vector  
8774				endm  
# End of macro CALLMONITOR
8774				endif 
8774				; only short reads enabled 
8774			 
8774 3a 75 ea			ld a, (store_longread) 
8777 fe 00			cp 0 
8779 ca 46 88			jp z, .readdone 
877c			 
877c			; TODO if block has no zeros then need to read next block  
877c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877c			; check last byte of physical block. 
877c			; if not zero then the next block needs to be loaded 
877c			 
877c			 
877c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877f			 
877f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8781 cd db 8c			call addatohl 
8784				;dec hl 
8784 7e				ld a,(hl) 
8785				if DEBUG_STORESE 
8785					DMARK "sr?" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 6b ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 6c ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 6d ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "sr?"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 6f ee			call debug_vector  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 fe 00			cp 0 
87a3 ca 46 88			jp z, .readdone 
87a6			 
87a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a6			 
87a6 23				inc hl 
87a7			 
87a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87aa			 
87aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ae			 
87ae eb				ex de, hl 
87af			 
87af				; next ext 
87af			 
87af 23				inc hl 
87b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b3			 
87b3				if DEBUG_STORESE 
87b3					DMARK "sF2" 
87b3 f5				push af  
87b4 3a c8 87			ld a, (.dmark)  
87b7 32 6b ee			ld (debug_mark),a  
87ba 3a c9 87			ld a, (.dmark+1)  
87bd 32 6c ee			ld (debug_mark+1),a  
87c0 3a ca 87			ld a, (.dmark+2)  
87c3 32 6d ee			ld (debug_mark+2),a  
87c6 18 03			jr .pastdmark  
87c8 ..			.dmark: db "sF2"  
87cb f1			.pastdmark: pop af  
87cc			endm  
# End of macro DMARK
87cc					CALLMONITOR 
87cc cd 6f ee			call debug_vector  
87cf				endm  
# End of macro CALLMONITOR
87cf				endif 
87cf			 
87cf				; get and load block 
87cf			 
87cf cd ab 84			call storage_findnextid 
87d2			 
87d2				if DEBUG_STORESE 
87d2					DMARK "sf2" 
87d2 f5				push af  
87d3 3a e7 87			ld a, (.dmark)  
87d6 32 6b ee			ld (debug_mark),a  
87d9 3a e8 87			ld a, (.dmark+1)  
87dc 32 6c ee			ld (debug_mark+1),a  
87df 3a e9 87			ld a, (.dmark+2)  
87e2 32 6d ee			ld (debug_mark+2),a  
87e5 18 03			jr .pastdmark  
87e7 ..			.dmark: db "sf2"  
87ea f1			.pastdmark: pop af  
87eb			endm  
# End of macro DMARK
87eb					CALLMONITOR 
87eb cd 6f ee			call debug_vector  
87ee				endm  
# End of macro CALLMONITOR
87ee				endif 
87ee cd 04 8d			call ishlzero 
87f1			;	ld a, l 
87f1			;	add h 
87f1			;	cp 0 
87f1 ca cf 86			jp z,.sr_fail			; block not found so EOF 
87f4				 
87f4				; save current address for use by higher level words etc 
87f4			 
87f4 22 6b ea			ld (store_openaddr),hl 
87f7			 
87f7 cd 78 81			call storage_read_block 
87fa			 
87fa				; on a continuation block, we now have the file id and ext in the middle of the block 
87fa				; we need to pull everything back  
87fa			 
87fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8801 23				inc hl 
8802 23				inc hl     ; skip id and ext 
8803 01 40 00			ld bc, STORE_BLOCK_PHY 
8806				if DEBUG_STORESE 
8806					DMARK "SR<" 
8806 f5				push af  
8807 3a 1b 88			ld a, (.dmark)  
880a 32 6b ee			ld (debug_mark),a  
880d 3a 1c 88			ld a, (.dmark+1)  
8810 32 6c ee			ld (debug_mark+1),a  
8813 3a 1d 88			ld a, (.dmark+2)  
8816 32 6d ee			ld (debug_mark+2),a  
8819 18 03			jr .pastdmark  
881b ..			.dmark: db "SR<"  
881e f1			.pastdmark: pop af  
881f			endm  
# End of macro DMARK
881f					CALLMONITOR 
881f cd 6f ee			call debug_vector  
8822				endm  
# End of macro CALLMONITOR
8822				endif 
8822 ed b0			ldir     ; copy data 
8824			 
8824				; move the pointer back and pretend we have a full buffer for next recheck 
8824			 
8824 1b				dec de 
8825 1b				dec de 
8826			 
8826			; TODO do pop below now short circuit loop????? 
8826 c1				pop bc     ; get rid of spare de on stack 
8827				if DEBUG_STORESE 
8827					DMARK "SR>" 
8827 f5				push af  
8828 3a 3c 88			ld a, (.dmark)  
882b 32 6b ee			ld (debug_mark),a  
882e 3a 3d 88			ld a, (.dmark+1)  
8831 32 6c ee			ld (debug_mark+1),a  
8834 3a 3e 88			ld a, (.dmark+2)  
8837 32 6d ee			ld (debug_mark+2),a  
883a 18 03			jr .pastdmark  
883c ..			.dmark: db "SR>"  
883f f1			.pastdmark: pop af  
8840			endm  
# End of macro DMARK
8840					CALLMONITOR 
8840 cd 6f ee			call debug_vector  
8843				endm  
# End of macro CALLMONITOR
8843				endif 
8843 c3 d4 86			jp .srext 
8846			 
8846			 
8846			 
8846			 
8846			 
8846			.readdone:		 
8846 e1				pop hl 		 ; return start of data to show as not EOF 
8847 23				inc hl   ; past file id 
8848 23				inc hl   ; past ext 
8849				if DEBUG_STORESE 
8849					DMARK "SRe" 
8849 f5				push af  
884a 3a 5e 88			ld a, (.dmark)  
884d 32 6b ee			ld (debug_mark),a  
8850 3a 5f 88			ld a, (.dmark+1)  
8853 32 6c ee			ld (debug_mark+1),a  
8856 3a 60 88			ld a, (.dmark+2)  
8859 32 6d ee			ld (debug_mark+2),a  
885c 18 03			jr .pastdmark  
885e ..			.dmark: db "SRe"  
8861 f1			.pastdmark: pop af  
8862			endm  
# End of macro DMARK
8862					CALLMONITOR 
8862 cd 6f ee			call debug_vector  
8865				endm  
# End of macro CALLMONITOR
8865				endif 
8865 c9					ret 
8866			 
8866			 
8866			 
8866			; 
8866			; Append File 
8866			; 
8866			; hl - file id to locate 
8866			; de - pointer to (multi block) string to write 
8866			 
8866			.sa_notfound: 
8866 d1				pop de 
8867 c9				ret 
8868			 
8868			 
8868			storage_append: 
8868				; hl -  file id to append to 
8868				; de - string to append 
8868			 
8868 d5				push de 
8869				 
8869				if DEBUG_STORESE 
8869					DMARK "AP1" 
8869 f5				push af  
886a 3a 7e 88			ld a, (.dmark)  
886d 32 6b ee			ld (debug_mark),a  
8870 3a 7f 88			ld a, (.dmark+1)  
8873 32 6c ee			ld (debug_mark+1),a  
8876 3a 80 88			ld a, (.dmark+2)  
8879 32 6d ee			ld (debug_mark+2),a  
887c 18 03			jr .pastdmark  
887e ..			.dmark: db "AP1"  
8881 f1			.pastdmark: pop af  
8882			endm  
# End of macro DMARK
8882					CALLMONITOR 
8882 cd 6f ee			call debug_vector  
8885				endm  
# End of macro CALLMONITOR
8885				endif 
8885			 
8885 7d				ld a, l 
8886 32 6e ea			ld (store_tmpid), a 
8889			 
8889				; get file header  
8889			 
8889 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888b 3a 6e ea			ld a, (store_tmpid) 
888e 5f				ld e, a 
888f			 
888f 21 40 00				ld hl, STORE_BLOCK_PHY 
8892 cd ab 84				call storage_findnextid 
8895			 
8895 cd 04 8d			call ishlzero 
8898 28 cc			jr z, .sa_notfound 
889a			 
889a 22 65 ea			ld (store_tmppageid), hl 
889d			 
889d				; TODO handle file id not found 
889d			 
889d				if DEBUG_STORESE 
889d					DMARK "AP2" 
889d f5				push af  
889e 3a b2 88			ld a, (.dmark)  
88a1 32 6b ee			ld (debug_mark),a  
88a4 3a b3 88			ld a, (.dmark+1)  
88a7 32 6c ee			ld (debug_mark+1),a  
88aa 3a b4 88			ld a, (.dmark+2)  
88ad 32 6d ee			ld (debug_mark+2),a  
88b0 18 03			jr .pastdmark  
88b2 ..			.dmark: db "AP2"  
88b5 f1			.pastdmark: pop af  
88b6			endm  
# End of macro DMARK
88b6					CALLMONITOR 
88b6 cd 6f ee			call debug_vector  
88b9				endm  
# End of macro CALLMONITOR
88b9				endif 
88b9			 
88b9				; update file extent count 
88b9			 
88b9 11 7a ea			ld de, store_page 
88bc			 
88bc cd 78 81			call storage_read_block 
88bf			 
88bf				if DEBUG_STORESE 
88bf					DMARK "AP3" 
88bf f5				push af  
88c0 3a d4 88			ld a, (.dmark)  
88c3 32 6b ee			ld (debug_mark),a  
88c6 3a d5 88			ld a, (.dmark+1)  
88c9 32 6c ee			ld (debug_mark+1),a  
88cc 3a d6 88			ld a, (.dmark+2)  
88cf 32 6d ee			ld (debug_mark+2),a  
88d2 18 03			jr .pastdmark  
88d4 ..			.dmark: db "AP3"  
88d7 f1			.pastdmark: pop af  
88d8			endm  
# End of macro DMARK
88d8					CALLMONITOR 
88d8 cd 6f ee			call debug_vector  
88db				endm  
# End of macro CALLMONITOR
88db				endif 
88db			;	ld (store_tmppageid), hl 
88db			 
88db 3a 7c ea			ld a, (store_page+2) 
88de 3c				inc a 
88df 32 7c ea			ld (store_page+2), a 
88e2 32 6d ea			ld (store_tmpext), a 
88e5				 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP3" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 6b ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 6c ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 6d ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP3"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6f ee			call debug_vector  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901 2a 65 ea			ld hl, (store_tmppageid) 
8904 11 7a ea			ld de, store_page 
8907 cd dd 81			call storage_write_block 
890a			 
890a				; find free block 
890a			 
890a 11 00 00			ld de, 0			 ; file extent to locate 
890d			 
890d 21 40 00				ld hl, STORE_BLOCK_PHY 
8910 cd ab 84				call storage_findnextid 
8913 cd 04 8d			call ishlzero 
8916 ca 66 88			jp z, .sa_notfound 
8919			 
8919					; TODO handle no space left 
8919					 
8919 22 65 ea				ld (store_tmppageid), hl 
891c			 
891c				if DEBUG_STORESE 
891c					DMARK "AP4" 
891c f5				push af  
891d 3a 31 89			ld a, (.dmark)  
8920 32 6b ee			ld (debug_mark),a  
8923 3a 32 89			ld a, (.dmark+1)  
8926 32 6c ee			ld (debug_mark+1),a  
8929 3a 33 89			ld a, (.dmark+2)  
892c 32 6d ee			ld (debug_mark+2),a  
892f 18 03			jr .pastdmark  
8931 ..			.dmark: db "AP4"  
8934 f1			.pastdmark: pop af  
8935			endm  
# End of macro DMARK
8935					CALLMONITOR 
8935 cd 6f ee			call debug_vector  
8938				endm  
# End of macro CALLMONITOR
8938				endif 
8938					; init the buffer with zeros so we can id if the buffer is full or not 
8938			 
8938 e5					push hl 
8939 c5					push bc 
893a			 
893a 21 7a ea				ld hl, store_page 
893d 06 40				ld b, STORE_BLOCK_PHY 
893f 3e 00				ld a, 0 
8941 77			.zeroblock:	ld (hl), a 
8942 23					inc hl 
8943 10 fc				djnz .zeroblock 
8945			 
8945 c1					pop bc 
8946 e1					pop hl 
8947			 
8947					; construct block 
8947			 
8947 3a 6e ea				ld a, (store_tmpid) 
894a 32 7a ea				ld (store_page), a   ; file id 
894d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8950 32 7b ea				ld (store_page+1), a 
8953			 
8953 e1					pop hl    ; get string to write 
8954 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8956 11 7c ea				ld de, store_page+2 
8959			 
8959				if DEBUG_STORESE 
8959					DMARK "AP5" 
8959 f5				push af  
895a 3a 6e 89			ld a, (.dmark)  
895d 32 6b ee			ld (debug_mark),a  
8960 3a 6f 89			ld a, (.dmark+1)  
8963 32 6c ee			ld (debug_mark+1),a  
8966 3a 70 89			ld a, (.dmark+2)  
8969 32 6d ee			ld (debug_mark+2),a  
896c 18 03			jr .pastdmark  
896e ..			.dmark: db "AP5"  
8971 f1			.pastdmark: pop af  
8972			endm  
# End of macro DMARK
8972					CALLMONITOR 
8972 cd 6f ee			call debug_vector  
8975				endm  
# End of macro CALLMONITOR
8975				endif 
8975			 
8975			 
8975			 
8975					; fill buffer with data until end of string or full block 
8975			 
8975 7e			.appd:		ld a, (hl) 
8976 12					ld (de), a 
8977 fe 00				cp 0 
8979 28 04				jr z, .appdone 
897b 23					inc hl 
897c 13					inc de 
897d 10 f6				djnz .appd 
897f			 
897f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8980 f5					push af   		; save last byte dumped 
8981			 
8981			 
8981 2a 65 ea			ld hl, (store_tmppageid) 
8984 11 7a ea			ld de, store_page 
8987				if DEBUG_STORESE 
8987					DMARK "AP6" 
8987 f5				push af  
8988 3a 9c 89			ld a, (.dmark)  
898b 32 6b ee			ld (debug_mark),a  
898e 3a 9d 89			ld a, (.dmark+1)  
8991 32 6c ee			ld (debug_mark+1),a  
8994 3a 9e 89			ld a, (.dmark+2)  
8997 32 6d ee			ld (debug_mark+2),a  
899a 18 03			jr .pastdmark  
899c ..			.dmark: db "AP6"  
899f f1			.pastdmark: pop af  
89a0			endm  
# End of macro DMARK
89a0					CALLMONITOR 
89a0 cd 6f ee			call debug_vector  
89a3				endm  
# End of macro CALLMONITOR
89a3				endif 
89a3 cd dd 81				call storage_write_block 
89a6			 
89a6			 
89a6				; was that a full block of data written? 
89a6				; any more to write out? 
89a6			 
89a6				; if yes then set vars and jump to start of function again 
89a6			 
89a6 f1					pop af 
89a7 d1					pop de 
89a8			 
89a8 fe 00				cp 0		 ; no, string was fully written 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 6e ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 68 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4					ld a,0 
89b4			.src:		ld (hl),a 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4				ld a, 0 
89b4				ld (hl),a 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 7a ea			ld hl, store_page 
89ba 3e 00			ld a, 0 
89bc 77				ld (hl), a 
89bd			 
89bd 11 7b ea			ld de, store_page+1 
89c0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c3			 
89c3 ed b0			ldir 
89c5				 
89c5 c1				pop bc 
89c6 d1				pop de 
89c7 e1				pop hl 
89c8 c9				ret 
89c9			 
89c9			; eof 
# End of file firmware_storage.asm
89c9			  
89c9			; support routines for above hardware abstraction layer  
89c9			  
89c9			include "firmware_general.asm"        ; general support functions  
89c9			 
89c9			; word look up 
89c9			 
89c9			; in 
89c9			; a is the index 
89c9			; hl is pointer start of array 
89c9			; 
89c9			; returns 
89c9			; hl to the word 
89c9			; 
89c9			 
89c9			table_lookup:  
89c9 d5					push de 
89ca eb					ex de, hl 
89cb			 
89cb 6f					ld l, a 
89cc 26 00				ld h, 0 
89ce 29					add hl, hl 
89cf 19					add hl, de 
89d0 7e					ld a, (hl) 
89d1 23					inc hl 
89d2 66					ld h,(hl) 
89d3 6f					ld l, a 
89d4			 
89d4 d1					pop de 
89d5 c9					ret 
89d6			 
89d6			; Delay loops 
89d6			 
89d6			 
89d6			 
89d6			aDelayInMS: 
89d6 c5				push bc 
89d7 47				ld b,a 
89d8			msdelay: 
89d8 c5				push bc 
89d9				 
89d9			 
89d9 01 41 00			ld bc,041h 
89dc cd f4 89			call delayloop 
89df c1				pop bc 
89e0 05				dec b 
89e1 20 f5			jr nz,msdelay 
89e3			 
89e3			;if CPU_CLOCK_8MHZ 
89e3			;msdelay8: 
89e3			;	push bc 
89e3			;	 
89e3			; 
89e3			;	ld bc,041h 
89e3			;	call delayloop 
89e3			;	pop bc 
89e3			;	dec b 
89e3			;	jr nz,msdelay8 
89e3			;endif 
89e3			 
89e3			 
89e3 c1				pop bc 
89e4 c9				ret 
89e5			 
89e5			 
89e5			delay250ms: 
89e5				;push de 
89e5 01 00 40			ld bc, 04000h 
89e8 c3 f4 89			jp delayloop 
89eb			delay500ms: 
89eb				;push de 
89eb 01 00 80			ld bc, 08000h 
89ee c3 f4 89			jp delayloop 
89f1			delay1s: 
89f1				;push bc 
89f1			   ; Clobbers A, d and e 
89f1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f4			delayloop: 
89f4 c5			    push bc 
89f5			 
89f5			if BASE_CPM 
89f5				ld bc, CPM_DELAY_TUNE 
89f5			.cpmloop: 
89f5				push bc 
89f5			 
89f5			endif 
89f5			 
89f5			 
89f5			 
89f5			delayloopi: 
89f5			;	push bc 
89f5			;.dl: 
89f5 cb 47		    bit     0,a    	; 8 
89f7 cb 47		    bit     0,a    	; 8 
89f9 cb 47		    bit     0,a    	; 8 
89fb e6 ff		    and     255  	; 7 
89fd 0b			    dec     bc      	; 6 
89fe 79			    ld      a,c     	; 4 
89ff b0			    or      b     	; 4 
8a00 c2 f5 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a03			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a03				;pop de 
8a03			;pop bc 
8a03			 
8a03			if BASE_CPM 
8a03				pop bc 
8a03				 
8a03			    dec     bc      	; 6 
8a03			    ld      a,c     	; 4 
8a03			    or      b     	; 4 
8a03			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a03				 
8a03			 
8a03			endif 
8a03			;if CPU_CLOCK_8MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03			 
8a03			;if CPU_CLOCK_10MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03 c1			    pop bc 
8a04			 
8a04 c9				ret 
8a05			 
8a05			 
8a05			 
8a05			; eof 
# End of file firmware_general.asm
8a05			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a05			; display routines that use the physical hardware abstraction layer 
8a05			 
8a05			 
8a05			; Display an activity indicator 
8a05			; Each call returns the new char pointed to in hl 
8a05			 
8a05			active: 
8a05 3a c6 eb			ld a, (display_active) 
8a08 fe 06			cp 6 
8a0a			 
8a0a 20 02			jr nz, .sne 
8a0c				; gone past the last one reset sequence 
8a0c 3e ff			ld a, 255 
8a0e			 
8a0e			.sne:   
8a0e				; get the next char in seq 
8a0e 3c				inc a 
8a0f 32 c6 eb			ld (display_active), a 
8a12			 
8a12				; look up the string in the table 
8a12 21 29 8a			ld hl, actseq 
8a15 cb 27			sla a 
8a17 cd db 8c			call addatohl 
8a1a cd 76 9e			call loadwordinhl 
8a1d			 
8a1d				; forth will write the to string when pushing so move from rom to ram 
8a1d			 
8a1d 11 c7 eb			ld de, display_active+1 
8a20 01 02 00			ld bc, 2 
8a23 ed b0			ldir 
8a25			 
8a25 21 c7 eb			ld hl, display_active+1 
8a28 c9				ret 
8a29				 
8a29				 
8a29			 
8a29			 
8a29			;db "|/-\|-\" 
8a29			 
8a29			actseq: 
8a29			 
8a29 37 8a		dw spin0 
8a2b 39 8a		dw spin1 
8a2d 3b 8a		dw spin2 
8a2f 3d 8a		dw spin3 
8a31 3b 8a		dw spin2 
8a33 39 8a		dw spin1 
8a35 37 8a		dw spin0 
8a37			 
8a37 .. 00		spin0: db " ", 0 
8a39 .. 00		spin1: db "-", 0 
8a3b .. 00		spin2: db "+", 0 
8a3d .. 00		spin3: db "#", 0 
8a3f			 
8a3f			 
8a3f			; information window 
8a3f			 
8a3f			; pass hl with 1st string to display 
8a3f			; pass de with 2nd string to display 
8a3f			 
8a3f			info_panel: 
8a3f e5				push hl 
8a40			 
8a40 2a cc eb			ld hl, (display_fb_active) 
8a43 e5				push hl    ; future de destination 
8a44 21 b1 ed				ld hl, display_fb0 
8a47 22 cc eb				ld (display_fb_active), hl 
8a4a			 
8a4a			;	call clear_display 
8a4a			 
8a4a				if BASE_CPM 
8a4a				ld a, '.' 
8a4a				else 
8a4a 3e a5			ld a, 165 
8a4c				endif 
8a4c cd b3 8a			call fill_display 
8a4f			 
8a4f			 
8a4f 3e 55			ld a, display_row_3 + 5 
8a51 cd c1 8a			call str_at_display 
8a54			 
8a54 e1				pop hl 
8a55 d1				pop de 
8a56			 
8a56 e5				push hl 
8a57			 
8a57			 
8a57 3e 2d			ld a, display_row_2 + 5 
8a59 cd c1 8a			call str_at_display 
8a5c			 
8a5c			 
8a5c cd d1 8a			call update_display 
8a5f cd bf 9a			call next_page_prompt 
8a62 cd ae 8a			call clear_display 
8a65			 
8a65				 
8a65 21 10 ed				ld hl, display_fb1 
8a68 22 cc eb				ld (display_fb_active), hl 
8a6b cd d1 8a			call update_display 
8a6e			 
8a6e e1				pop hl 
8a6f			 
8a6f c9				ret 
8a70			 
8a70			 
8a70			 
8a70			 
8a70			; TODO windowing? 
8a70			 
8a70			; TODO scroll line up 
8a70			 
8a70			scroll_up: 
8a70			 
8a70 e5				push hl 
8a71 d5				push de 
8a72 c5				push bc 
8a73			 
8a73				; get frame buffer  
8a73			 
8a73 2a cc eb			ld hl, (display_fb_active) 
8a76 e5				push hl    ; future de destination 
8a77			 
8a77 11 28 00			ld  de, display_cols 
8a7a 19				add hl, de 
8a7b			 
8a7b d1				pop de 
8a7c			 
8a7c				;ex de, hl 
8a7c 01 9f 00			ld bc, display_fb_len -1  
8a7f			;if DEBUG_FORTH_WORDS 
8a7f			;	DMARK "SCL" 
8a7f			;	CALLMONITOR 
8a7f			;endif	 
8a7f ed b0			ldir 
8a81			 
8a81				; wipe bottom row 
8a81			 
8a81			 
8a81 2a cc eb			ld hl, (display_fb_active) 
8a84 11 a0 00			ld de, display_cols*display_rows 
8a87 19				add hl, de 
8a88 06 28			ld b, display_cols 
8a8a 3e 20			ld a, ' ' 
8a8c			.scwipe: 
8a8c 77				ld (hl), a 
8a8d 2b				dec hl 
8a8e 10 fc			djnz .scwipe 
8a90			 
8a90				;pop hl 
8a90			 
8a90 c1				pop bc 
8a91 d1				pop de 
8a92 e1				pop hl 
8a93			 
8a93 c9				ret 
8a94			 
8a94			 
8a94			;scroll_upo: 
8a94			;	ld de, display_row_1 
8a94			 ;	ld hl, display_row_2 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_2 
8a94			 ;	ld hl, display_row_3 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_3 
8a94			 ;	ld hl, display_row_4 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			 
8a94			; TODO clear row 4 
8a94			 
8a94			;	ret 
8a94			 
8a94				 
8a94			scroll_down: 
8a94			 
8a94 e5				push hl 
8a95 d5				push de 
8a96 c5				push bc 
8a97			 
8a97				; get frame buffer  
8a97			 
8a97 2a cc eb			ld hl, (display_fb_active) 
8a9a			 
8a9a 11 9f 00			ld de, display_fb_len - 1 
8a9d 19				add hl, de 
8a9e			 
8a9e e5			push hl    ; future de destination 
8a9f			 
8a9f 11 28 00			ld  de, display_cols 
8aa2 ed 52			sbc hl, de 
8aa4			 
8aa4			 
8aa4 d1				pop de 
8aa5			 
8aa5			;	ex de, hl 
8aa5 01 9f 00			ld bc, display_fb_len -1  
8aa8			 
8aa8			 
8aa8				 
8aa8			 
8aa8 ed b0			ldir 
8aaa			 
8aaa				; wipe bottom row 
8aaa			 
8aaa			 
8aaa			;	ld hl, (display_fb_active) 
8aaa			;;	ld de, display_cols*display_rows 
8aaa			;;	add hl, de 
8aaa			;	ld b, display_cols 
8aaa			;	ld a, ' ' 
8aaa			;.scwiped: 
8aaa			;	ld (hl), a 
8aaa			;	dec hl 
8aaa			;	djnz .scwiped 
8aaa			 
8aaa				;pop hl 
8aaa			 
8aaa c1				pop bc 
8aab d1				pop de 
8aac e1				pop hl 
8aad			 
8aad c9				ret 
8aae			;scroll_down: 
8aae			;	ld de, display_row_4 
8aae			;	ld hl, display_row_3 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_3 
8aae			; 	ld hl, display_row_2 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_2 
8aae			;	ld hl, display_row_1 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;;; TODO clear row 1 
8aae			;	ret 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			; clear active frame buffer 
8aae			 
8aae			clear_display: 
8aae 3e 20			ld a, ' ' 
8ab0 c3 b3 8a			jp fill_display 
8ab3			 
8ab3			; fill active frame buffer with a char in A 
8ab3			 
8ab3			fill_display: 
8ab3 06 a0			ld b,display_fb_len 
8ab5 2a cc eb			ld hl, (display_fb_active) 
8ab8 77			.fd1:	ld (hl),a 
8ab9 23				inc hl 
8aba 10 fc			djnz .fd1 
8abc 23				inc hl 
8abd 3e 00			ld a,0 
8abf 77				ld (hl),a 
8ac0			 
8ac0			 
8ac0 c9				ret 
8ac1			; Write string (DE) at pos (A) to active frame buffer 
8ac1			 
8ac1 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac4 06 00					ld b,0 
8ac6 4f					ld c,a 
8ac7 09					add hl,bc 
8ac8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac9 b7			            OR   A              ;Null terminator? 
8aca c8			            RET  Z              ;Yes, so finished 
8acb 77					ld (hl),a 
8acc 23				inc hl 
8acd 13			            INC  DE             ;Point to next character 
8ace 18 f8		            JR   .sad1     ;Repeat 
8ad0 c9					ret 
8ad1			 
8ad1			; using current frame buffer write to physical display 
8ad1			 
8ad1			update_display: 
8ad1 e5				push hl 
8ad2 2a cc eb			ld hl, (display_fb_active) 
8ad5 cd 43 e4			call write_display 
8ad8 e1				pop hl 
8ad9 c9				ret 
8ada			 
8ada			; TODO scrolling 
8ada			 
8ada			 
8ada			; move cursor right one char 
8ada			cursor_right: 
8ada			 
8ada				; TODO shift right 
8ada				; TODO if beyond max col 
8ada				; TODO       cursor_next_line 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cursor_next_line: 
8adb				; TODO first char 
8adb				; TODO line down 
8adb				; TODO if past last row 
8adb				; TODO    scroll up 
8adb			 
8adb c9				ret 
8adc			 
8adc			cursor_left: 
8adc				; TODO shift left 
8adc				; TODO if beyond left  
8adc				; TODO     cursor prev line 
8adc				 
8adc c9				ret 
8add			 
8add			cursor_prev_line: 
8add				; TODO last char 
8add				; TODO line up 
8add				; TODO if past first row 
8add				; TODO   scroll down 
8add			 
8add c9				ret 
8ade			 
8ade			 
8ade			cout: 
8ade				; A - char 
8ade c9				ret 
8adf			 
8adf			 
8adf			; Display a menu and allow item selection (optional toggle items) 
8adf			; 
8adf			; format: 
8adf			; hl pointer to word array with zero term for items 
8adf			; e.g.    db item1 
8adf			;         db .... 
8adf			;         db 0 
8adf			; 
8adf			; a = starting menu item  
8adf			; 
8adf			; de = pointer item toggle array   (todo) 
8adf			; 
8adf			; returns item selected in a 1-... 
8adf			; returns 0 if back button pressed 
8adf			; 
8adf			; NOTE: Uses system frame buffer to display 
8adf			; 
8adf			; LEFT, Q = go back 
8adf			; RIGHT, SPACE, CR = select 
8adf			; UP, A - Up 
8adf			; DOWN, Z - Down 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			menu: 
8adf			 
8adf					; keep array pointer 
8adf			 
8adf 22 73 ea				ld (store_tmp1), hl 
8ae2 32 71 ea				ld (store_tmp2), a 
8ae5			 
8ae5					; check for key bounce 
8ae5			 
8ae5			if BASE_KEV 
8ae5			 
8ae5			.mbounce:	call cin 
8ae5					cp 0 
8ae5					jr nz, .mbounce 
8ae5			endif 
8ae5					; for ease use ex 
8ae5			 
8ae5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae5 21 b1 ed				ld hl, display_fb0 
8ae8 22 cc eb				ld (display_fb_active), hl 
8aeb			 
8aeb cd ae 8a		.mloop:		call clear_display 
8aee cd d1 8a				call update_display 
8af1			 
8af1					; draw selection id '>' at 1 
8af1			 
8af1					; init start of list display 
8af1			 
8af1 3e 05				ld a, 5 
8af3 32 6f ea				ld (store_tmp3), a   ; display row count 
8af6 3a 71 ea				ld a,( store_tmp2) 
8af9 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afc			 
8afc					 
8afc			.mitem:	 
8afc			 
8afc			 
8afc 3a 72 ea				ld a,(store_tmp2+1) 
8aff 6f					ld l, a 
8b00 26 00				ld h, 0 
8b02 29					add hl, hl 
8b03 ed 5b 73 ea			ld de, (store_tmp1) 
8b07 19					add hl, de 
8b08 7e					ld a, (hl) 
8b09 23					inc hl 
8b0a 66					ld h,(hl) 
8b0b 6f					ld l, a 
8b0c			 
8b0c cd 04 8d				call ishlzero 
8b0f 28 1a				jr z, .mdone 
8b11			 
8b11 eb					ex de, hl 
8b12 3a 6f ea				ld a, (store_tmp3) 
8b15 cd c1 8a				call str_at_display 
8b18					 
8b18			 
8b18					; next item 
8b18 3a 72 ea				ld a, (store_tmp2+1) 
8b1b 3c					inc a 
8b1c 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b1f			 
8b1f			 		; next row 
8b1f			 
8b1f 3a 6f ea				ld a, (store_tmp3) 
8b22 c6 28				add display_cols 
8b24 32 6f ea				ld (store_tmp3), a 
8b27			 
8b27					; at end of screen? 
8b27			 
8b27 fe 10				cp display_rows*4 
8b29 20 d1				jr nz, .mitem 
8b2b			 
8b2b			 
8b2b			.mdone: 
8b2b cd 04 8d				call ishlzero 
8b2e 28 08				jr z, .nodn 
8b30			 
8b30 3e 78				ld a, display_row_4 
8b32 11 b1 8b				ld de, .mdown 
8b35 cd c1 8a				call str_at_display 
8b38			 
8b38					; draw options to fill the screens with active item on line 1 
8b38					; if current option is 2 or more then display ^ in top 
8b38			 
8b38 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3b fe 00				cp 0 
8b3d 28 08				jr z, .noup 
8b3f			 
8b3f 3e 00				ld a, 0 
8b41 11 af 8b				ld de, .mup 
8b44 cd c1 8a				call str_at_display 
8b47			 
8b47 3e 02		.noup:		ld a, 2 
8b49 11 ad 8b				ld de, .msel 
8b4c cd c1 8a				call str_at_display 
8b4f			 
8b4f					; if current option + 1 is not null then display V in bottom 
8b4f					; get key 
8b4f cd d1 8a				call update_display 
8b52			 
8b52			 
8b52					; handle key 
8b52			 
8b52 cd cf e4				call cin_wait 
8b55			 
8b55 fe 05				cp KEY_UP 
8b57 28 2b				jr z, .mgoup 
8b59 fe 61				cp 'a' 
8b5b 28 27				jr z, .mgoup 
8b5d fe 0a				cp KEY_DOWN 
8b5f 28 32				jr z, .mgod 
8b61 fe 7a				cp 'z' 
8b63 28 2e				jr z, .mgod 
8b65 fe 20				cp ' ' 
8b67 28 34				jr z, .goend 
8b69 fe 0c				cp KEY_RIGHT 
8b6b 28 30				jr z, .goend 
8b6d fe 0d				cp KEY_CR 
8b6f 28 2c				jr z, .goend 
8b71 fe 71				cp 'q' 
8b73 28 0b				jr z, .goback 
8b75			 
8b75 fe 0b				cp KEY_LEFT 
8b77 28 07				jr z, .goback 
8b79 fe 08				cp KEY_BS 
8b7b 28 03				jr z, .goback 
8b7d c3 eb 8a				jp .mloop 
8b80			 
8b80			.goback: 
8b80 3e 00			ld a, 0 
8b82 18 1d			jr .goend2 
8b84			 
8b84				; move up one 
8b84			.mgoup: 
8b84 3a 71 ea				ld a, (store_tmp2) 
8b87 fe 00				cp 0 
8b89 ca eb 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 71 ea				ld (store_tmp2), a 
8b90 c3 eb 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 71 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 71 ea				ld (store_tmp2), a 
8b9a c3 eb 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 71 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 10 ed				ld hl, display_fb1 
8ba5 22 cc eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d1 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a ab eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 ab eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 b1 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 b3 eb		        ld hl,LFSRSeed+6 
8bf8 11 b4 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a a5 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 a5 eb		    ld (seed1),hl 
8c0e 2a a3 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 a3 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 a9 eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO handle KEY_PREVWORD 
8d08			; TODO handle KEY_NEXTWORD 
8d08			; TODO handle KEY_HOME 
8d08			; TODO handle KEY_END 
8d08			; TODO use LCD cursor? 
8d08			 
8d08 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0b 81					add c 
8d0c 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d0f 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d12 79					ld a, c 
8d13 cd db 8c				call addatohl 
8d16 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d19 7a					ld a,d 
8d1a 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1d 79					ld a, c 
8d1e 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8d21 7b					ld a,e 
8d22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d25					 
8d25					 
8d25			 
8d25			;		ld a,(input_ptr) 
8d25			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d25			 
8d25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d25					; init cursor shape if not set by the cin routines 
8d25 21 c1 eb				ld hl, cursor_shape 
8d28 3e ff				ld a, 255 
8d2a 77					ld (hl), a 
8d2b 23					inc hl 
8d2c 3e 00				ld a, 0 
8d2e 77					ld (hl), a 
8d2f			 
8d2f 3e 0f				ld a, CUR_BLINK_RATE 
8d31 32 60 ee				ld (input_cur_flash), a 
8d34 3e 01				ld a, 1 
8d36 32 5f ee				ld (input_cur_onoff),a 
8d39			 
8d39			;	if DEBUG_INPUT 
8d39			;		push af 
8d39			;		ld a, 'I' 
8d39			;		ld (debug_mark),a 
8d39			;		pop af 
8d39			;		CALLMONITOR 
8d39			;	endif 
8d39			.is1:		; main entry loop 
8d39			 
8d39			 
8d39			 
8d39					; pause 1ms 
8d39			 
8d39 3e 01				ld a, 1 
8d3b cd d6 89				call aDelayInMS 
8d3e			 
8d3e					; dec flash counter 
8d3e 3a 60 ee				ld a, (input_cur_flash) 
8d41 3d					dec a 
8d42 32 60 ee				ld (input_cur_flash), a 
8d45 fe 00				cp 0 
8d47 20 0d				jr nz, .nochgstate 
8d49			 
8d49			 
8d49					; change state 
8d49 3a 5f ee				ld a,(input_cur_onoff) 
8d4c ed 44				neg 
8d4e 32 5f ee				ld (input_cur_onoff),a 
8d51			 
8d51			 
8d51					; reset on change of state 
8d51 3e 0f				ld a, CUR_BLINK_RATE 
8d53 32 60 ee				ld (input_cur_flash), a 
8d56			 
8d56			.nochgstate: 
8d56					 
8d56					 
8d56			 
8d56					; display cursor  
8d56			 
8d56			;		ld hl, (input_start) 
8d56			;		ld a, (input_cursor) 
8d56			;		call addatohl 
8d56			 
8d56					; get char under cursor and replace with cursor 
8d56 2a 69 ee		ld hl, (input_ptr) 
8d59			;		ld a, (hl) 
8d59			;		ld (input_under_cursor),a 
8d59			;		ld a, '_' 
8d59			;		ld (hl), a 
8d59			 
8d59					; display string 
8d59			 
8d59 ed 5b 67 ee			ld de, (input_start) 
8d5d 3a 64 ee				ld a, (input_at_pos) 
8d60 cd c1 8a				call str_at_display 
8d63			;	        call update_display 
8d63			 
8d63					; find place to put the cursor 
8d63			;		add h 
8d63			;		ld l, display_row_1 
8d63			;		sub l 
8d63			; (input_at_pos) 
8d63					;ld c, a 
8d63			;		ld a, (input_cursor) 
8d63			;		ld l, (input_at_pos) 
8d63			;		;ld b, h 
8d63			;		add l 
8d63			;		ld (input_at_cursor),a 
8d63					;ld l,h 
8d63			 
8d63			;		ld h, 0 
8d63			;		ld l,(input_at_pos) 
8d63			;		ld a, (input_cursor) 
8d63			;		call addatohl 
8d63			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d63			;		call subafromhl 
8d63			;		ld a,l 
8d63			;		ld (input_at_cursor), a 
8d63			 
8d63				if DEBUG_INPUT 
8d63					ld a, (hardware_diag) 
8d63					cp 0 
8d63					jr z, .skip_input_diag 
8d63			 
8d63					ld a,(input_at_pos) 
8d63					ld hl, LFSRSeed 
8d63					call hexout 
8d63					ld a, (input_cursor) 
8d63					ld hl, LFSRSeed+2 
8d63					call hexout 
8d63					ld a,(input_at_cursor) 
8d63					ld hl, LFSRSeed+4 
8d63					call hexout 
8d63			 
8d63					ld a,(input_cur_onoff) 
8d63					ld hl, LFSRSeed+6 
8d63					call hexout 
8d63			 
8d63					ld a,(input_cur_flash) 
8d63					ld hl, LFSRSeed+8 
8d63					call hexout 
8d63			 
8d63					ld a,(input_len) 
8d63					ld hl, LFSRSeed+10 
8d63					call hexout 
8d63					ld hl, LFSRSeed+12 
8d63					ld a, 0 
8d63					ld (hl),a 
8d63					ld a, display_row_4 
8d63					ld de, LFSRSeed 
8d63					call str_at_display 
8d63					.skip_input_diag: 
8d63				endif 
8d63			 
8d63					; decide on if we are showing the cursor this time round 
8d63			 
8d63 3a 5f ee				ld a, (input_cur_onoff) 
8d66 fe ff				cp 255 
8d68 28 13				jr z, .skipcur 
8d6a			 
8d6a			 
8d6a 3a 62 ee				ld a,(input_at_cursor) 
8d6d 11 c1 eb				ld de, cursor_shape 
8d70 cd c1 8a				call str_at_display 
8d73			 
8d73					; save length of current input string 
8d73 2a 67 ee				ld hl, (input_start) 
8d76 cd 39 91				call strlenz 
8d79 7d					ld a,l 
8d7a 32 5a ee				ld (input_len),a 
8d7d			 
8d7d			.skipcur: 
8d7d			 
8d7d cd d1 8a			        call update_display 
8d80					 
8d80			 
8d80			 
8d80					; wait 
8d80				 
8d80					; TODO loop without wait to flash the cursor and char under cursor	 
8d80 cd d5 e4				call cin    ; _wait 
8d83			 
8d83 fe 00				cp 0 
8d85 ca 39 8d				jp z, .is1 
8d88			 
8d88					; get ptr to char to input into 
8d88			 
8d88 4f					ld c,a 
8d89 2a 67 ee				ld hl, (input_start) 
8d8c 3a 55 ee				ld a, (input_cursor) 
8d8f cd db 8c				call addatohl 
8d92 22 69 ee				ld (input_ptr), hl 
8d95 79					ld a,c 
8d96			 
8d96					; replace char under cursor 
8d96			 
8d96			;		ld hl, (input_ptr) 
8d96			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d96			;		ld (hl), a 
8d96			 
8d96			;	if DEBUG_INPUT 
8d96			;		push af 
8d96			;		ld a, 'i' 
8d96			;		ld (debug_mark),a 
8d96			;		pop af 
8d96			;		CALLMONITOR 
8d96			;	endif 
8d96 fe 0e				cp KEY_HOME 
8d98 20 0e				jr nz, .iske 
8d9a			 
8d9a 3a 64 ee				ld a, (input_at_pos) 
8d9d 32 62 ee				ld (input_at_cursor),a 
8da0 3e 00				ld a, 0 
8da2 32 55 ee				ld (input_cursor), a 
8da5 c3 39 8d				jp .is1 
8da8					 
8da8 fe 0f		.iske:		cp KEY_END 
8daa 20 03				jr nz, .isknw 
8dac c3 39 8d				jp .is1 
8daf			 
8daf fe 06		.isknw:		cp KEY_NEXTWORD 
8db1 20 1b				jr nz, .iskpw 
8db3			 
8db3 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8db6 7e					ld a,(hl)	 
8db7 fe 00				cp 0 
8db9 ca 39 8d				jp z, .is1    ; end of string 
8dbc fe 20				cp ' ' 
8dbe ca 39 8d				jp z, .is1    ; end of word 
8dc1 23					inc hl 
8dc2 22 69 ee				ld (input_ptr), hl 
8dc5 3a 62 ee				ld a, (input_at_cursor) 
8dc8 3c					inc a 
8dc9 32 62 ee				ld (input_at_cursor), a 
8dcc 18 e5				jr .isknwm 
8dce			 
8dce fe 07		.iskpw:		cp KEY_PREVWORD 
8dd0 20 1b				jr nz, .iskl 
8dd2			.iskpwm:	 
8dd2 2a 69 ee				ld hl, (input_ptr) 
8dd5 7e					ld a,(hl)	 
8dd6 fe 00				cp 0  
8dd8 ca 39 8d				jp z, .is1    ; end of string 
8ddb fe 20				cp ' ' 
8ddd ca 39 8d				jp z, .is1    ; end of word 
8de0 2b					dec hl 
8de1 22 69 ee				ld (input_ptr), hl 
8de4 3a 62 ee				ld a, (input_at_cursor) 
8de7 3d					dec a 
8de8 32 62 ee				ld (input_at_cursor), a 
8deb 18 e5				jr .iskpwm 
8ded			 
8ded			 
8ded fe 0b		.iskl:		cp KEY_LEFT 
8def 20 27				jr nz, .isk1 
8df1			 
8df1 3a 55 ee				ld a, (input_cursor) 
8df4			 
8df4 fe 00				cp 0 
8df6 ca 39 8d				jp z, .is1 		; at start of line to ignore  
8df9			 
8df9 3d					dec  a 		; TODO check underflow 
8dfa 32 55 ee				ld (input_cursor), a 
8dfd			 
8dfd 2a 69 ee				ld hl, (input_ptr) 
8e00 2b					dec hl 
8e01 22 69 ee				ld (input_ptr), hl 
8e04					 
8e04 3a 62 ee				ld a, (input_at_cursor) 
8e07 3d					dec a 
8e08 32 62 ee				ld (input_at_cursor), a 
8e0b			 
8e0b 3e 01				ld a, 1		; show cursor moving 
8e0d 32 5f ee				ld (input_cur_onoff),a 
8e10 3e 0f				ld a, CUR_BLINK_RATE 
8e12 32 60 ee				ld (input_cur_flash), a 
8e15			 
8e15 c3 39 8d				jp .is1 
8e18			 
8e18 fe 0c		.isk1:		cp KEY_RIGHT 
8e1a 20 2a				jr nz, .isk2 
8e1c			 
8e1c 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e1f 5f					ld e,a 
8e20 3a 55 ee				ld a, (input_cursor) 
8e23 bb					cp e 
8e24 ca 39 8d				jp z, .is1		; at the end of string so dont go right 
8e27			 
8e27 3c					inc  a 		; TODO check overflow 
8e28 32 55 ee				ld (input_cursor), a 
8e2b			 
8e2b 3a 62 ee				ld a, (input_at_cursor) 
8e2e 3c					inc a 
8e2f 32 62 ee				ld (input_at_cursor), a 
8e32			 
8e32 2a 69 ee				ld hl, (input_ptr) 
8e35 23					inc hl 
8e36 22 69 ee				ld (input_ptr), hl 
8e39			 
8e39 3e 01				ld a, 1		; show cursor moving 
8e3b 32 5f ee				ld (input_cur_onoff),a 
8e3e 3e 0f				ld a, CUR_BLINK_RATE 
8e40 32 60 ee				ld (input_cur_flash), a 
8e43			 
8e43 c3 39 8d				jp .is1 
8e46			 
8e46 fe 05		.isk2:		cp KEY_UP 
8e48			 
8e48 20 26				jr nz, .isk3 
8e4a			 
8e4a					; swap last command with the current on 
8e4a			 
8e4a					; move cursor to start of string 
8e4a 2a 67 ee				ld hl, (input_start) 
8e4d 22 69 ee				ld (input_ptr), hl 
8e50			 
8e50 3a 64 ee				ld a, (input_at_pos) 
8e53 32 62 ee				ld (input_at_cursor), a 
8e56			 
8e56 3e 00				ld a, 0 
8e58 32 55 ee				ld (input_cursor), a 
8e5b					 
8e5b					; swap input and last command buffers 
8e5b			 
8e5b 21 e8 e5				ld hl, os_cli_cmd 
8e5e 11 e7 e6				ld de, os_last_cmd 
8e61 06 ff				ld b, 255 
8e63 7e			.swap1:		ld a, (hl) 
8e64 4f					ld c,a 
8e65 1a					ld a, (de) 
8e66 77					ld (hl), a 
8e67 79					ld a,c 
8e68 12					ld (de),a 
8e69 23					inc hl 
8e6a 13					inc de 
8e6b 10 f6				djnz .swap1 
8e6d			 
8e6d			 
8e6d			 
8e6d			 
8e6d			 
8e6d c3 39 8d				jp .is1 
8e70			 
8e70 fe 08		.isk3:		cp KEY_BS 
8e72 20 3c				jr nz, .isk4 
8e74			 
8e74 3a 55 ee				ld a, (input_cursor) 
8e77			 
8e77 fe 00				cp 0 
8e79 ca 39 8d				jp z, .is1 		; at start of line to ignore  
8e7c			 
8e7c 3d					dec  a 		; TODO check underflow 
8e7d 32 55 ee				ld (input_cursor), a 
8e80			 
8e80					; hl is source 
8e80					; de needs to be source - 1 
8e80			 
8e80			;		ld a, 0 
8e80			;		dec hl 
8e80			;		ld (hl), a 
8e80			 
8e80 2a 69 ee				ld hl, (input_ptr) 
8e83 2b					dec hl 
8e84 22 69 ee				ld (input_ptr), hl 
8e87			 
8e87					; shift all data 
8e87			 
8e87 e5					push hl 
8e88 23					inc hl 
8e89 d1					pop de 
8e8a 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8d 4f					ld c,a 
8e8e 06 00				ld b,0 
8e90 ed b0				ldir  
8e92			 
8e92			 
8e92			 
8e92			 
8e92 3a 62 ee				ld a, (input_at_cursor) 
8e95 3d					dec a 
8e96 32 62 ee				ld (input_at_cursor), a 
8e99			 
8e99			 
8e99 3e 01				ld a, 1		; show cursor moving 
8e9b 32 5f ee				ld (input_cur_onoff),a 
8e9e 3e 0f				ld a, CUR_BLINK_RATE 
8ea0 32 60 ee				ld (input_cur_flash), a 
8ea3			 
8ea3					; remove char 
8ea3 3a 62 ee				ld a, (input_at_cursor) 
8ea6 3c					inc a 
8ea7 11 31 8f				ld de,.iblank 
8eaa cd c1 8a				call str_at_display 
8ead			 
8ead c3 39 8d				jp .is1 
8eb0			 
8eb0 fe 0d		.isk4:		cp KEY_CR 
8eb2 28 6c				jr z, .endinput 
8eb4			 
8eb4					; else add the key press to the end 
8eb4			 
8eb4 4f					ld c, a			; save key pressed 
8eb5			 
8eb5 7e					ld a,(hl)		; get what is currently under char 
8eb6			 
8eb6 fe 00				cp 0			; we are at the end of the string 
8eb8 20 2f				jr nz, .onchar 
8eba					 
8eba					; add a char to the end of the string 
8eba				 
8eba 71					ld (hl),c 
8ebb 23					inc hl 
8ebc			;		ld a,' ' 
8ebc			;		ld (hl),a 
8ebc			;		inc hl 
8ebc 3e 00				ld a,0 
8ebe 77					ld (hl),a 
8ebf 2b					dec hl 
8ec0			 
8ec0 3a 55 ee				ld a, (input_cursor) 
8ec3 3c					inc a				; TODO check max string length and scroll  
8ec4 32 55 ee				ld (input_cursor), a		; inc cursor pos 
8ec7							 
8ec7 3a 62 ee				ld a, (input_at_cursor) 
8eca 3c					inc a 
8ecb 32 62 ee				ld (input_at_cursor), a 
8ece			 
8ece 2a 69 ee				ld hl, (input_ptr) 
8ed1 23					inc hl 
8ed2 22 69 ee				ld (input_ptr), hl 
8ed5			 
8ed5 2a 69 ee				ld hl, (input_ptr) 
8ed8 23					inc hl 
8ed9 22 69 ee				ld (input_ptr), hl 
8edc			;	if DEBUG_INPUT 
8edc			;		push af 
8edc			;		ld a, '+' 
8edc			;		ld (debug_mark),a 
8edc			;		pop af 
8edc			;		CALLMONITOR 
8edc			;	endif 
8edc 3e 01				ld a, 1		; show cursor moving 
8ede 32 5f ee				ld (input_cur_onoff),a 
8ee1 3e 0f				ld a, CUR_BLINK_RATE 
8ee3 32 60 ee				ld (input_cur_flash), a 
8ee6 c3 39 8d				jp .is1 
8ee9					 
8ee9			 
8ee9			 
8ee9					; if on a char then insert 
8ee9			.onchar: 
8ee9			 
8ee9					; TODO over flow check: make sure insert does not blow out buffer 
8ee9			 
8ee9					; need to do some maths to use lddr 
8ee9			 
8ee9 e5					push hl   ; save char pos 
8eea c5					push bc 
8eeb			 
8eeb 2a 67 ee				ld hl, (input_start) 
8eee 3a 5a ee				ld a, (input_len) 
8ef1 cd db 8c				call addatohl  		; end of string 
8ef4 23					inc hl 
8ef5 23					inc hl		; past zero term 
8ef6 e5					push hl 
8ef7 23					inc hl 
8ef8 e5					push hl  
8ef9			 
8ef9								; start and end of lddr set, now how much to move? 
8ef9			 
8ef9							 
8ef9 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efc 47					ld b,a 
8efd 3a 5a ee				ld a,(input_len) 
8f00 5f					ld e,a 
8f01 90					sub b 
8f02 3c					inc a		;?? 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05			 
8f05 06 00				ld b,0 
8f07 4f					ld c,a 
8f08			 
8f08				if DEBUG_INPUT 
8f08					push af 
8f08					ld a, 'i' 
8f08					ld (debug_mark),a 
8f08					pop af 
8f08			;		CALLMONITOR 
8f08				endif 
8f08 d1					pop de 
8f09 e1					pop hl 
8f0a				if DEBUG_INPUT 
8f0a					push af 
8f0a					ld a, 'I' 
8f0a					ld (debug_mark),a 
8f0a					pop af 
8f0a			;		CALLMONITOR 
8f0a				endif 
8f0a ed b8				lddr 
8f0c				 
8f0c			 
8f0c			 
8f0c					; TODO have a key for insert/overwrite mode???? 
8f0c c1					pop bc 
8f0d e1					pop hl 
8f0e 71					ld (hl), c		; otherwise overwrite current char 
8f0f					 
8f0f			 
8f0f			 
8f0f			 
8f0f 3a 55 ee				ld a, (input_cursor) 
8f12 3c					inc  a 		; TODO check overflow 
8f13 32 55 ee				ld (input_cursor), a 
8f16			 
8f16 3a 62 ee				ld a, (input_at_cursor) 
8f19 3c					inc a 
8f1a 32 62 ee				ld (input_at_cursor), a 
8f1d			 
8f1d c3 39 8d				jp .is1 
8f20			 
8f20			.endinput:	; TODO look for end of string 
8f20			 
8f20					; add trailing space for end of token 
8f20			 
8f20 2a 67 ee				ld hl, (input_start) 
8f23 3a 5a ee				ld a,(input_len) 
8f26 cd db 8c				call addatohl 
8f29 3e 20				ld a, ' ' 
8f2b 77					ld (hl),a 
8f2c					; TODO eof of parse marker 
8f2c			 
8f2c 23					inc hl 
8f2d 3e 00				ld a, 0 
8f2f 77					ld (hl),a 
8f30			 
8f30			 
8f30 c9					ret 
8f31			 
8f31 .. 00		.iblank: db " ",0 
8f33			 
8f33			 
8f33 32 64 ee		input_str_prev:	ld (input_at_pos), a 
8f36 22 67 ee				ld (input_start), hl 
8f39 3e 01				ld a,1			; add cursor 
8f3b 77					ld (hl),a 
8f3c 23					inc hl 
8f3d 3e 00				ld a,0 
8f3f 77					ld (hl),a 
8f40 22 69 ee				ld (input_ptr), hl 
8f43 7a					ld a,d 
8f44 32 66 ee				ld (input_size), a 
8f47 3e 00				ld a,0 
8f49 32 55 ee				ld (input_cursor),a 
8f4c			.instr1:	 
8f4c			 
8f4c					; TODO do block cursor 
8f4c					; TODO switch cursor depending on the modifer key 
8f4c			 
8f4c					; update cursor shape change on key hold 
8f4c			 
8f4c 2a 69 ee				ld hl, (input_ptr) 
8f4f 2b					dec hl 
8f50 3a c1 eb				ld a,(cursor_shape) 
8f53 77					ld (hl), a 
8f54			 
8f54					; display entered text 
8f54 3a 64 ee				ld a,(input_at_pos) 
8f57 cd 33 e4		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5a ed 5b 67 ee	            	LD   de, (input_start) 
8f5e cd 2d e4		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f61			 
8f61 cd d5 e4				call cin 
8f64 fe 00				cp 0 
8f66 28 e4				jr z, .instr1 
8f68			 
8f68					; proecess keyboard controls first 
8f68			 
8f68 2a 69 ee				ld hl,(input_ptr) 
8f6b			 
8f6b fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6d 28 5a				jr z, .instrcr 
8f6f			 
8f6f fe 08				cp KEY_BS 	; back space 
8f71 20 0f				jr nz, .instr2 
8f73					; process back space 
8f73			 
8f73					; TODO stop back space if at start of string 
8f73 2b					dec hl 
8f74 2b					dec hl ; to over write cursor 
8f75 3a c1 eb				ld a,(cursor_shape) 
8f78					;ld a,0 
8f78 77					ld (hl),a 
8f79 23					inc hl 
8f7a 3e 20				ld a," " 
8f7c 77					ld (hl),a 
8f7d 22 69 ee				ld (input_ptr),hl 
8f80					 
8f80			 
8f80 18 ca				jr .instr1 
8f82			 
8f82 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f84 20 06				jr nz, .instr3 
8f86 2b					dec hl 
8f87 22 69 ee				ld (input_ptr),hl 
8f8a 18 c0				jr .instr1 
8f8c				 
8f8c fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8e 20 06				jr nz, .instr4 
8f90 23					inc hl 
8f91 22 69 ee				ld (input_ptr),hl 
8f94 18 b6				jr .instr1 
8f96			 
8f96 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f98 20 06				jr nz, .instr5 
8f9a 2b					dec hl 
8f9b 22 69 ee				ld (input_ptr),hl 
8f9e 18 ac				jr .instr1 
8fa0			 
8fa0 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa2 20 06				jr nz, .instr6 
8fa4 2b					dec hl 
8fa5 22 69 ee				ld (input_ptr),hl 
8fa8 18 a2				jr .instr1 
8faa fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fac 20 0b				jr nz, .instrnew 
8fae			 
8fae 21 c1 e2			ld hl, scratch 
8fb1 11 e7 e6			ld de, os_last_cmd 
8fb4 cd d2 8f			call strcpy 
8fb7 18 93				jr .instr1 
8fb9			 
8fb9			 
8fb9			.instrnew:	; no special key pressed to see if we have room to store it 
8fb9			 
8fb9					; TODO do string size test 
8fb9			 
8fb9 2b					dec hl ; to over write cursor 
8fba 77					ld (hl),a 
8fbb 23					inc hl 
8fbc 3a c1 eb				ld a,(cursor_shape) 
8fbf 77					ld (hl),a 
8fc0 23					inc hl 
8fc1 3e 00				ld a,0 
8fc3 77					ld (hl),a 
8fc4			 
8fc4 22 69 ee				ld (input_ptr),hl 
8fc7					 
8fc7 18 83				jr .instr1 
8fc9 2b			.instrcr:	dec hl		; remove cursor 
8fca 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcc 77					ld (hl),a 
8fcd 23					inc hl 
8fce 3e 00				ld a,0 
8fd0 77					ld (hl),a 
8fd1			 
8fd1			 
8fd1					; if at end of line scroll up    
8fd1					; TODO detecting only end of line 4 for scroll up  
8fd1			 
8fd1					;ld   
8fd1			 
8fd1 c9					ret 
8fd2			 
8fd2			 
8fd2			; strcpy hl = dest, de source 
8fd2			 
8fd2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd3 b7			            OR   A              ;Null terminator? 
8fd4 c8			            RET  Z              ;Yes, so finished 
8fd5 1a					ld a,(de) 
8fd6 77					ld (hl),a 
8fd7 13			            INC  DE             ;Point to next character 
8fd8 23					inc hl 
8fd9 18 f7		            JR   strcpy       ;Repeat 
8fdb c9					ret 
8fdc			 
8fdc			 
8fdc			; TODO string_at  
8fdc			; pass string which starts with lcd offset address and then null term string 
8fdc			 
8fdc			; TODO string to dec 
8fdc			; TODO string to hex 
8fdc			; TODO byte to string hex 
8fdc			; TODO byte to string dec 
8fdc			 
8fdc			 
8fdc			 
8fdc			; from z80uartmonitor 
8fdc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdc			; pass hl for where to put the text 
8fdc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdc c5			hexout:	PUSH BC 
8fdd f5					PUSH AF 
8fde 47					LD B, A 
8fdf					; Upper nybble 
8fdf cb 3f				SRL A 
8fe1 cb 3f				SRL A 
8fe3 cb 3f				SRL A 
8fe5 cb 3f				SRL A 
8fe7 cd f7 8f				CALL tohex 
8fea 77					ld (hl),a 
8feb 23					inc hl	 
8fec					 
8fec					; Lower nybble 
8fec 78					LD A, B 
8fed e6 0f				AND 0FH 
8fef cd f7 8f				CALL tohex 
8ff2 77					ld (hl),a 
8ff3 23					inc hl	 
8ff4					 
8ff4 f1					POP AF 
8ff5 c1					POP BC 
8ff6 c9					RET 
8ff7					 
8ff7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff7			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff7			tohex: 
8ff7 e5					PUSH HL 
8ff8 d5					PUSH DE 
8ff9 16 00				LD D, 0 
8ffb 5f					LD E, A 
8ffc 21 04 90				LD HL, .DATA 
8fff 19					ADD HL, DE 
9000 7e					LD A, (HL) 
9001 d1					POP DE 
9002 e1					POP HL 
9003 c9					RET 
9004			 
9004			.DATA: 
9004 30					DEFB	30h	; 0 
9005 31					DEFB	31h	; 1 
9006 32					DEFB	32h	; 2 
9007 33					DEFB	33h	; 3 
9008 34					DEFB	34h	; 4 
9009 35					DEFB	35h	; 5 
900a 36					DEFB	36h	; 6 
900b 37					DEFB	37h	; 7 
900c 38					DEFB	38h	; 8 
900d 39					DEFB	39h	; 9 
900e 41					DEFB	41h	; A 
900f 42					DEFB	42h	; B 
9010 43					DEFB	43h	; C 
9011 44					DEFB	44h	; D 
9012 45					DEFB	45h	; E 
9013 46					DEFB	46h	; F 
9014			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9014			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9014			;;    subtract $30, if result > 9 then subtract $7 more 
9014			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9014			atohex: 
9014 d6 30				SUB $30 
9016 fe 0a				CP 10 
9018 f8					RET M		; If result negative it was 0-9 so we're done 
9019 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901b c9					RET		 
901c			 
901c			 
901c			 
901c			 
901c			; Get 2 ASCII characters as hex byte from pointer in hl 
901c			 
901c			BYTERD: 
901c 16 00			LD	D,00h		;Set up 
901e cd 26 90			CALL	HEXCON		;Get byte and convert to hex 
9021 87				ADD	A,A		;First nibble so 
9022 87				ADD	A,A		;multiply by 16 
9023 87				ADD	A,A		; 
9024 87				ADD	A,A		; 
9025 57				LD	D,A		;Save hi nibble in D 
9026			HEXCON: 
9026 7e				ld a, (hl)		;Get next chr 
9027 23				inc hl 
9028 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902a fe 0a			CP	00Ah		;Is it 0-9 ? 
902c 38 02			JR	C,NALPHA	;If so miss next bit 
902e d6 07			SUB	007h		;Else convert alpha 
9030			NALPHA: 
9030 b2				OR	D		;Add hi nibble back 
9031 c9				RET			; 
9032			 
9032			 
9032			; 
9032			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9032			; Since the routines get_byte and therefore get_nibble are called, only valid 
9032			; characters (0-9a-f) are accepted. 
9032			; 
9032			;get_word        push    af 
9032			;                call    get_byte        ; Get the upper byte 
9032			;                ld      h, a 
9032			;                call    get_byte        ; Get the lower byte 
9032			;                ld      l, a 
9032			;                pop     af 
9032			;                ret 
9032			; 
9032			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9032			; the routine get_nibble is used only valid characters are accepted - the  
9032			; input routine only accepts characters 0-9a-f. 
9032			; 
9032 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9033 7e					ld a,(hl) 
9034 23					inc hl 
9035 cd 5a 90		                call    nibble2val      ; Get upper nibble 
9038 cb 07		                rlc     a 
903a cb 07		                rlc     a 
903c cb 07		                rlc     a 
903e cb 07		                rlc     a 
9040 47			                ld      b, a            ; Save upper four bits 
9041 7e					ld a,(hl) 
9042 cd 5a 90		                call    nibble2val      ; Get lower nibble 
9045 b0			                or      b               ; Combine both nibbles 
9046 c1			                pop     bc              ; Restore B (and C) 
9047 c9			                ret 
9048			; 
9048			; Get a hexadecimal digit from the serial line. This routine blocks until 
9048			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9048			; to the serial line interface. The lower 4 bits of A contain the value of  
9048			; that particular digit. 
9048			; 
9048			;get_nibble      ld a,(hl)           ; Read a character 
9048			;                call    to_upper        ; Convert to upper case 
9048			;                call    is_hex          ; Was it a hex digit? 
9048			;                jr      nc, get_nibble  ; No, get another character 
9048			 ;               call    nibble2val      ; Convert nibble to value 
9048			 ;               call    print_nibble 
9048			 ;               ret 
9048			; 
9048			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9048			; A valid hexadecimal digit is denoted by a set C flag. 
9048			; 
9048			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9048			;                ret     nc              ; Yes 
9048			;                cp      '0'             ; Less than '0'? 
9048			;                jr      nc, is_hex_1    ; No, continue 
9048			;                ccf                     ; Complement carry (i.e. clear it) 
9048			;                ret 
9048			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9048			;                ret     c               ; Yes 
9048			;                cp      'A'             ; Less than 'A'? 
9048			;                jr      nc, is_hex_2    ; No, continue 
9048			;                ccf                     ; Yes - clear carry and return 
9048			;                ret 
9048			;is_hex_2        scf                     ; Set carry 
9048			;                ret 
9048			; 
9048			; Convert a single character contained in A to upper case: 
9048			; 
9048 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904a d8			                ret     c 
904b fe 7b		                cp      'z' + 1         ; > 'z'? 
904d d0			                ret     nc              ; Nothing to do, either 
904e e6 5f		                and     $5f             ; Convert to upper case 
9050 c9			                ret 
9051			 
9051			 
9051			to_lower: 
9051			 
9051			   ; if char is in [A-Z] make it lower case 
9051			 
9051			   ; enter : a = char 
9051			   ; exit  : a = lower case char 
9051			   ; uses  : af 
9051			 
9051 fe 41		   cp 'A' 
9053 d8			   ret c 
9054			    
9054 fe 5b		   cp 'Z'+1 
9056 d0			   ret nc 
9057			    
9057 f6 20		   or $20 
9059 c9			   ret 
905a			 
905a			; 
905a			; Expects a hexadecimal digit (upper case!) in A and returns the 
905a			; corresponding value in A. 
905a			; 
905a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905c 38 02		                jr      c, nibble2val_1 ; Yes 
905e d6 07		                sub     7               ; Adjust for A-F 
9060 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9062 e6 0f		                and     $f              ; Only return lower 4 bits 
9064 c9			                ret 
9065			; 
9065			; Print_nibble prints a single hex nibble which is contained in the lower  
9065			; four bits of A: 
9065			; 
9065			;print_nibble    push    af              ; We won't destroy the contents of A 
9065			;                and     $f              ; Just in case... 
9065			;                add     a, '0'             ; If we have a digit we are done here. 
9065			;                cp      '9' + 1         ; Is the result > 9? 
9065			;                jr      c, print_nibble_1 
9065			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9065			;print_nibble_1  call    putc            ; Print the nibble and 
9065			;                pop     af              ; restore the original value of A 
9065			;                ret 
9065			;; 
9065			;; Send a CR/LF pair: 
9065			; 
9065			;crlf            push    af 
9065			;                ld      a, cr 
9065			;                call    putc 
9065			;                ld      a, lf 
9065			;                call    putc 
9065			;                pop     af 
9065			;                ret 
9065			; 
9065			; Print_word prints the four hex digits of a word to the serial line. The  
9065			; word is expected to be in HL. 
9065			; 
9065			;print_word      push    hl 
9065			;                push    af 
9065			;                ld      a, h 
9065			;                call    print_byte 
9065			;                ld      a, l 
9065			;                call    print_byte 
9065			;                pop     af 
9065			;                pop     hl 
9065			;                ret 
9065			; 
9065			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9065			; The byte to be printed is expected to be in A. 
9065			; 
9065			;print_byte      push    af              ; Save the contents of the registers 
9065			;                push    bc 
9065			;                ld      b, a 
9065			;                rrca 
9065			;                rrca 
9065			;                rrca 
9065			;                rrca 
9065			;                call    print_nibble    ; Print high nibble 
9065			;                ld      a, b 
9065			;                call    print_nibble    ; Print low nibble 
9065			;                pop     bc              ; Restore original register contents 
9065			;                pop     af 
9065			;                ret 
9065			 
9065			 
9065			 
9065			 
9065			 
9065			fourehexhl:  
9065 7e				ld a,(hl) 
9066 cd 14 90			call atohex 
9069 cb 3f				SRL A 
906b cb 3f				SRL A 
906d cb 3f				SRL A 
906f cb 3f				SRL A 
9071 47				ld b, a 
9072 23				inc hl 
9073 7e				ld a,(hl) 
9074 23				inc hl 
9075 cd 14 90			call atohex 
9078 80				add b 
9079 57				ld d,a 
907a 7e				ld a,(hl) 
907b cd 14 90			call atohex 
907e cb 3f				SRL A 
9080 cb 3f				SRL A 
9082 cb 3f				SRL A 
9084 cb 3f				SRL A 
9086 47				ld b, a 
9087 23				inc hl 
9088 7e				ld a,(hl) 
9089 23				inc hl 
908a cd 14 90			call atohex 
908d 80				add b 
908e 5f				ld e, a 
908f d5				push de 
9090 e1				pop hl 
9091 c9				ret 
9092			 
9092			; pass hl. returns z set if the byte at hl is a digit 
9092			;isdigithl:  
9092			;	push bc 
9092			;	ld a,(hl) 
9092			;	cp ':' 
9092			;	jr nc, .isdf 		; > 
9092			;	cp '0' 
9092			;	jr c, .isdf		; < 
9092			; 
9092			;	; TODO find a better way to set z 
9092			; 
9092			;	ld b,a 
9092			;	cp b 
9092			;	pop bc 
9092			;	ret 
9092			; 
9092			;.isdf:	; not digit so clear z 
9092			; 
9092			;	; TODO find a better way to unset z 
9092			; 
9092			;	ld b,a 
9092			;	inc b 
9092			;	cp b 
9092			; 
9092			;	pop bc 
9092			;	ret 
9092				 
9092				 
9092			 
9092			 
9092			; pass hl as the four byte address to load 
9092			 
9092			get_word_hl:  
9092 e5				push hl 
9093 cd 32 90			call get_byte 
9096				 
9096 47				ld b, a 
9097			 
9097 e1				pop hl 
9098 23				inc hl 
9099 23				inc hl 
909a			 
909a			; TODO not able to handle a-f  
909a 7e				ld a,(hl) 
909b			;	;cp ':' 
909b			;	cp 'g' 
909b			;	jr nc, .single_byte_hl 		; > 
909b			;	cp 'G' 
909b			;	jr nc, .single_byte_hl 		; > 
909b			;	cp '0' 
909b			;	jr c, .single_byte_hl		; < 
909b			 
909b				;call isdigithl 
909b fe 00			cp 0 
909d 28 06			jr z, .single_byte_hl 
909f			 
909f			.getwhln:   ; hex word so get next byte 
909f			 
909f cd 32 90			call get_byte 
90a2 6f				ld l, a 
90a3 60				ld h,b 
90a4 c9				ret 
90a5 68			.single_byte_hl:   ld l,b 
90a6 26 00				ld h,0 
90a8 c9					ret 
90a9			 
90a9			 
90a9			 
90a9			 
90a9 21 36 98			ld hl,asc+1 
90ac			;	ld a, (hl) 
90ac			;	call nibble2val 
90ac cd 32 90			call get_byte 
90af			 
90af			;	call fourehexhl 
90af 32 f5 e2			ld (scratch+52),a 
90b2				 
90b2 21 f3 e2			ld hl,scratch+50 
90b5 22 e4 e5			ld (os_cur_ptr),hl 
90b8			 
90b8 c9				ret 
90b9			 
90b9			 
90b9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90b9			 
90b9			; Decimal Unsigned Version 
90b9			 
90b9			;Number in a to decimal ASCII 
90b9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90b9			;Example: display a=56 as "056" 
90b9			;input: a = number 
90b9			;Output: a=0,value of a in the screen 
90b9			;destroys af,bc (don't know about hl and de) 
90b9			DispAToASCII: 
90b9 0e 9c			ld	c,-100 
90bb cd c5 90			call	.Na1 
90be 0e f6			ld	c,-10 
90c0 cd c5 90			call	.Na1 
90c3 0e ff			ld	c,-1 
90c5 06 2f		.Na1:	ld	b,'0'-1 
90c7 04			.Na2:	inc	b 
90c8 81				add	a,c 
90c9 38 fc			jr	c,.Na2 
90cb 91				sub	c		;works as add 100/10/1 
90cc f5				push af		;safer than ld c,a 
90cd 78				ld	a,b		;char is in b 
90ce			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90ce f1				pop af		;safer than ld a,c 
90cf c9				ret 
90d0			 
90d0			; Decimal Signed Version 
90d0			 
90d0			; DispA 
90d0			; -------------------------------------------------------------- 
90d0			; Converts a signed integer value to a zero-terminated ASCII 
90d0			; string representative of that value (using radix 10). 
90d0			; -------------------------------------------------------------- 
90d0			; INPUTS: 
90d0			;     HL     Value to convert (two's complement integer). 
90d0			;     DE     Base address of string destination. (pointer). 
90d0			; -------------------------------------------------------------- 
90d0			; OUTPUTS: 
90d0			;     None 
90d0			; -------------------------------------------------------------- 
90d0			; REGISTERS/MEMORY DESTROYED 
90d0			; AF HL 
90d0			; -------------------------------------------------------------- 
90d0			 
90d0			;DispHLToASCII: 
90d0			;   push    de 
90d0			;   push    bc 
90d0			; 
90d0			;; Detect sign of HL. 
90d0			;    bit    7, h 
90d0			;    jr     z, ._DoConvert 
90d0			; 
90d0			;; HL is negative. Output '-' to string and negate HL. 
90d0			;    ld     a, '-' 
90d0			;    ld     (de), a 
90d0			;    inc    de 
90d0			; 
90d0			;; Negate HL (using two's complement) 
90d0			;    xor    a 
90d0			;    sub    l 
90d0			;    ld     l, a 
90d0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d0			;    sbc    a, h 
90d0			;    ld     h, a 
90d0			; 
90d0			;; Convert HL to digit characters 
90d0			;._DoConvert: 
90d0			;    ld     b, 0     ; B will count character length of number 
90d0			;-   ld     a, 10 
90d0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d0			;    push   af 
90d0			;    inc    b 
90d0			;    ld     a, h 
90d0			;    or     l 
90d0			;    jr     nz, - 
90d0			; 
90d0			;; Retrieve digits from stack 
90d0			;-   pop    af 
90d0			;    or     $30 
90d0			;    ld     (de), a 
90d0			;    inc    de 
90d0			;    djnz   - 
90d0			; 
90d0			;; Terminate string with NULL 
90d0			;    xor    a 
90d0			;    ld     (de), a 
90d0			; 
90d0			;    pop    bc 
90d0			;    pop    de 
90d0			;    ret 
90d0			 
90d0			;Comments 
90d0			; 
90d0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d0			;    Note that the output string will not be fixed-width. 
90d0			; 
90d0			;Example Usage 
90d0			; 
90d0			;    ld    hl, -1004 
90d0			;    ld    de, OP1 
90d0			;    call  DispA 
90d0			;    ld    hl, OP1 
90d0			;    syscall  PutS 
90d0			 
90d0			 
90d0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d0			 
90d0			 
90d0			;Converts an ASCII string to an unsigned 16-bit integer 
90d0			;Quits when it reaches a non-decimal digit 
90d0			 
90d0			string_to_uint16: 
90d0			atoui_16: 
90d0			;Input: 
90d0			;     DE points to the string 
90d0			;Outputs: 
90d0			;     HL is the result 
90d0			;     A is the 8-bit value of the number 
90d0			;     DE points to the byte after the number 
90d0			;Destroys: 
90d0			;     BC 
90d0			;       if the string is non-empty, BC is HL/10 
90d0			;Size:  24 bytes 
90d0			;Speed: 42+d(104+{0,9}) 
90d0			;       d is the number of digits in the number 
90d0			;       max is 640 cycles for a 5 digit number 
90d0			;Assuming no leading zeros: 
90d0			;1 digit:  146cc 
90d0			;2 digit:  250cc 
90d0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d0			;avg: 544.81158447265625cc (544+13297/16384) 
90d0			;=============================================================== 
90d0 21 00 00		  ld hl,0 
90d3			.u16a: 
90d3 1a			  ld a,(de) 
90d4 d6 30		  sub 30h 
90d6 fe 0a		  cp 10 
90d8 d0			  ret nc 
90d9 13			  inc de 
90da 44			  ld b,h 
90db 4d			  ld c,l 
90dc 29			  add hl,hl 
90dd 29			  add hl,hl 
90de 09			  add hl,bc 
90df 29			  add hl,hl 
90e0 85			  add a,l 
90e1 6f			  ld l,a 
90e2 30 ef		  jr nc,.u16a 
90e4 24			  inc h 
90e5 c3 d3 90		  jp .u16a 
90e8			 
90e8			 
90e8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e8			 
90e8			;written by Zeda 
90e8			;Converts a 16-bit unsigned integer to an ASCII string. 
90e8			 
90e8			uitoa_16: 
90e8			;Input: 
90e8			;   DE is the number to convert 
90e8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e8			;Output: 
90e8			;   HL points to the null-terminated ASCII string 
90e8			;      NOTE: This isn't necessarily the same as the input HL. 
90e8 d5			  push de 
90e9 c5			  push bc 
90ea f5			  push af 
90eb eb			  ex de,hl 
90ec			 
90ec 01 f0 d8		  ld bc,-10000 
90ef 3e 2f		  ld a,'0'-1 
90f1 3c			  inc a 
90f2 09			  add hl,bc  
90f3 38 fc		   jr c,$-2 
90f5 12			  ld (de),a 
90f6 13			  inc de 
90f7			 
90f7 01 e8 03		  ld bc,1000 
90fa 3e 3a		  ld a,'9'+1 
90fc 3d			  dec a  
90fd 09			  add hl,bc  
90fe 30 fc		   jr nc,$-2 
9100 12			  ld (de),a 
9101 13			  inc de 
9102			 
9102 01 9c ff		  ld bc,-100 
9105 3e 2f		  ld a,'0'-1 
9107 3c			  inc a  
9108 09			  add hl,bc  
9109 38 fc		   jr c,$-2 
910b 12			  ld (de),a 
910c 13			  inc de 
910d			 
910d 7d			  ld a,l 
910e 26 3a		  ld h,'9'+1 
9110 25			  dec h  
9111 c6 0a		  add a,10  
9113 30 fb		   jr nc,$-3 
9115 c6 30		  add a,'0' 
9117 eb			  ex de,hl 
9118 72			  ld (hl),d 
9119 23			  inc hl 
911a 77			  ld (hl),a 
911b 23			  inc hl 
911c 36 00		  ld (hl),0 
911e			 
911e			;Now strip the leading zeros 
911e 0e fa		  ld c,-6 
9120 09			  add hl,bc 
9121 3e 30		  ld a,'0' 
9123 23			  inc hl  
9124 be			  cp (hl)  
9125 28 fc		  jr z,$-2 
9127			 
9127			;Make sure that the string is non-empty! 
9127 7e			  ld a,(hl) 
9128 b7			  or a 
9129 20 01		  jr nz,.atoub 
912b 2b			  dec hl 
912c			.atoub: 
912c			 
912c f1			  pop af 
912d c1			  pop bc 
912e d1			  pop de 
912f c9			  ret 
9130			 
9130			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9130			 
9130			toUpper: 
9130			;A is the char. 
9130			;If A is a lowercase letter, this sets it to the matching uppercase 
9130			;18cc or 30cc or 41cc 
9130			;avg: 26.75cc 
9130 fe 61		  cp 'a' 
9132 d8			  ret c 
9133 fe 7b		  cp 'z'+1 
9135 d0			  ret nc 
9136 d6 20		  sub 'a'-'A' 
9138 c9			  ret 
9139			 
9139			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9139			 
9139			; String Length 
9139			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9139			 
9139			; Get the length of the null-terminated string starting at $8000 hl 
9139			;    LD     HL, $8000 
9139			 
9139			strlenz: 
9139			 
9139 af			    XOR    A               ; Zero is the value we are looking for. 
913a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913c			                           ; 65, 536 bytes (the entire addressable memory space). 
913c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913e			 
913e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
913f 6f			    LD     L, A             ; number of bytes 
9140 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9142 2b			    DEC    HL              ; Compensate for null. 
9143 c9				ret 
9144			 
9144			; Get the length of the A terminated string starting at $8000 hl 
9144			;    LD     HL, $8000 
9144			 
9144			strlent: 
9144			 
9144			                  ; A is the value we are looking for. 
9144 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9146 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9148			                           ; 65, 536 bytes (the entire addressable memory space). 
9148 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914a			 
914a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914c 2e 00		    LD     L, 0             ; number of bytes 
914e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9150 2b			    DEC    HL              ; Compensate for null. 
9151 c9				ret 
9152			 
9152			 
9152			;Comparing Strings 
9152			 
9152			;IN    HL     Address of string1. 
9152			;      DE     Address of string2. 
9152			 
9152			; doc given but wrong??? 
9152			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9152			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9152			; tested 
9152			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9152			 
9152			strcmp_old: 
9152 e5			    PUSH   HL 
9153 d5			    PUSH   DE 
9154			 
9154 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9155 be			    CP     (HL)            ; (want to minimize work). 
9156 38 01		    JR     C, Str1IsBigger 
9158 7e			    LD     A, (HL) 
9159			 
9159			Str1IsBigger: 
9159 4f			    LD     C, A             ; Put length in BC 
915a 06 00		    LD     B, 0 
915c 13			    INC    DE              ; Increment pointers to meat of string. 
915d 23			    INC    HL 
915e			 
915e			CmpLoop: 
915e 1a			    LD     A, (DE)          ; Compare bytes. 
915f ed a1		    CPI 
9161 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9163 13			    INC    DE              ; Update pointer. 
9164 ea 5e 91		    JP     PE, CmpLoop 
9167			 
9167 d1			    POP    DE 
9168 e1			    POP    HL 
9169 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916a be			    CP     (HL) 
916b c9			    RET 
916c			 
916c			NoMatch: 
916c 2b			    DEC    HL 
916d be			    CP     (HL)            ; Compare again to affect carry. 
916e d1			    POP    DE 
916f e1			    POP    HL 
9170 c9			    RET 
9171			 
9171			;; test strmp 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str2 
9171			;call strcmp 
9171			;jr z, .z1 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "NZ1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.z1: 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "ZZ1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str1 
9171			;call strcmp 
9171			;jr z, .z2 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "NZ2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.z2: 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "ZZ2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str2 
9171			;call strcmp 
9171			;jr c, .c1 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "Nc1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.c1: 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "cc1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str1 
9171			;call strcmp 
9171			;jr c, .c2 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "Nc2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.c2: 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "cc2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;	NEXTW 
9171			;.str1:   db "string1",0 
9171			;.str2:   db "string2",0 
9171			 
9171			; only care about direct match or not 
9171			; hl and de strings 
9171			; zero set if the same 
9171			 
9171			strcmp: 
9171 1a				ld a, (de) 
9172 be				cp (hl) 
9173 28 02			jr z, .ssame 
9175 b7				or a 
9176 c9				ret 
9177			 
9177			.ssame:  
9177 fe 00			cp 0 
9179 c8				ret z 
917a			 
917a 23				inc hl 
917b 13				inc de 
917c 18 f3			jr strcmp 
917e				 
917e				 
917e			 
917e			;Copyright (c) 2014, Luke Maurits 
917e			;All rights reserved. 
917e			; 
917e			;Redistribution and use in source and binary forms, with or without 
917e			;modification, are permitted provided that the following conditions are met: 
917e			; 
917e			;* Redistributions of source code must retain the above copyright notice, this 
917e			;  list of conditions and the following disclaimer. 
917e			; 
917e			;* Redistributions in binary form must reproduce the above copyright notice, 
917e			;  this list of conditions and the following disclaimer in the documentation 
917e			;  and/or other materials provided with the distribution. 
917e			; 
917e			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
917e			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
917e			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
917e			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
917e			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
917e			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
917e			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
917e			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
917e			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
917e			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
917e			 
917e			; https://github.com/lmaurits/lm512/blob/master/string.z80 
917e			 
917e			StrictStrCmp: 
917e				; Load next chars of each string 
917e 1a				ld a, (de) 
917f 47				ld b, a 
9180 7e				ld a, (hl) 
9181				; Compare 
9181 b8				cp b 
9182				; Return non-zero if chars don't match 
9182 c0				ret nz 
9183				; Check for end of both strings 
9183 fe 00			cp "\0" 
9185				; Return if strings have ended 
9185 c8				ret z 
9186				; Otherwise, advance to next chars 
9186 23				inc hl 
9187 13				inc de 
9188 18 f4			jr StrictStrCmp 
918a			 
918a			;end 
918a			; eof 
918a			 
918a			 
918a			 
918a			 
918a			 
918a			 
# End of file firmware_strings.asm
918a			include "firmware_memory.asm"   ; malloc and free  
918a			 
918a			if DEBUG_FORTH_MALLOC_HIGH 
918a			.mallocsize: db "Wants malloc >256",0 
918a			.mallocasize: db "MALLOC gives >256",0 
918a			.malloczero: db "MALLOC gives zero",0 
918a			 
918a			malloc_guard_zerolen: 
918a				push hl 
918a				push de 
918a				push af 
918a			 
918a				ld de, 0 
918a			        call cmp16 
918a				jr nz, .lowalloz 
918a			 
918a				push hl 
918a				push de 
918a					ld hl, display_fb0 
918a					ld (display_fb_active), hl 
918a				call clear_display 
918a				ld a, 0 
918a				ld de, .malloczero 
918a				call str_at_display 
918a				call update_display 
918a				call delay1s 
918a				call delay1s 
918a				call bp_on 
918a			;	ld a, 0 
918a			;	ld (os_view_disable), a 
918a			 
918a				pop de 
918a				pop hl 
918a			 
918a				 
918a			 
918a				CALLMONITOR 
918a			.lowalloz: 
918a			 
918a			 
918a				pop af 
918a				pop de 
918a				pop hl 
918a			ret 
918a			 
918a			malloc_guard_entry: 
918a				push hl 
918a				push de 
918a				push af 
918a			 
918a			 	or a      ;clear carry flag 
918a				push hl 
918a				ld de, 255 
918a				sbc hl, de 
918a				jr c, .lowalloc 
918a			 
918a				push de 
918a					ld hl, display_fb0 
918a					ld (display_fb_active), hl 
918a				call clear_display 
918a				ld a, 0 
918a				ld de, .mallocsize 
918a				call str_at_display 
918a				call update_display 
918a				call delay1s 
918a				call delay1s 
918a			;	ld a, 0 
918a			;	ld (os_view_disable), a 
918a				call bp_on 
918a			 
918a				pop de 
918a				pop hl 
918a			 
918a				 
918a			 
918a				CALLMONITOR 
918a				jr .lowdone 
918a			.lowalloc: 
918a			 
918a			 
918a				pop hl 
918a			.lowdone:	pop af 
918a				pop de 
918a				pop hl 
918a			ret 
918a			 
918a			malloc_guard_exit: 
918a				push hl 
918a				push de 
918a				push af 
918a			 
918a			 	or a      ;clear carry flag 
918a				push hl 
918a				ld de, 255 
918a				sbc hl, de 
918a				jr c, .lowallocx 
918a			 
918a				push de 
918a					ld hl, display_fb0 
918a					ld (display_fb_active), hl 
918a				call clear_display 
918a				ld a, 0 
918a				ld de, .mallocasize 
918a				call str_at_display 
918a				call update_display 
918a				call delay1s 
918a				call delay1s 
918a			;	ld a, 0 
918a			;	ld (os_view_disable), a 
918a				call bp_on 
918a				pop de 
918a				pop hl 
918a			 
918a				CALLMONITOR 
918a				jr .lowdonex 
918a			.lowallocx: 
918a			 
918a				pop hl 
918a			.lowdonex:	pop af 
918a				pop de 
918a				pop hl 
918a			ret 
918a			endif 
918a			 
918a			if MALLOC_2 
918a			; Z80 Malloc and Free Functions 
918a			 
918a			; Malloc Function: 
918a			; Input: 
918a			;   HL: Size of block to allocate 
918a			; Output: 
918a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
918a			 
918a			malloc: 
918a				 
918a			if DEBUG_FORTH_MALLOC_HIGH 
918a			call malloc_guard_entry 
918a			endif 
918a			 
918a			 
918a			 
918a			 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "mal" 
918a						CALLMONITOR 
918a					endif 
918a			    push af            ; Save AF register 
918a			    ld a, l            ; Load low byte of size into A 
918a			    or h               ; Check if size is zero 
918a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
918a			 
918a			    ; Allocate memory 
918a			    ld hl, (heap_start) ; Load start of heap into HL 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "ma1" 
918a						CALLMONITOR 
918a					endif 
918a			    call malloc_internal ; Call internal malloc function 
918a			    pop af             ; Restore AF register 
918a			if DEBUG_FORTH_MALLOC_HIGH 
918a			call malloc_guard_exit 
918a			call malloc_guard_zerolen 
918a			endif 
918a			    ret                ; Return 
918a			 
918a			; Free Function: 
918a			; Input: 
918a			;   HL: Pointer to memory block to free 
918a			; Output: 
918a			;   None 
918a			 
918a			free: 
918a			    push af            ; Save AF register 
918a			    ld a, l            ; Load low byte of pointer into A 
918a			    or h               ; Check if pointer is NULL 
918a			    jp z, free_exit    ; If pointer is NULL, exit 
918a			 
918a			    ; Free memory 
918a			    ld hl, (heap_start) ; Load start of heap into HL 
918a			    call free_internal  ; Call internal free function 
918a			    pop af             ; Restore AF register 
918a			    ret                ; Return 
918a			 
918a			; Internal Malloc Function: 
918a			; Input: 
918a			;   HL: Size of block to allocate 
918a			; Output: 
918a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
918a			 
918a			malloc_internal: 
918a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
918a			    add hl, bc         ; Add management overhead to requested size 
918a			    ex de, hl          ; Save total size in DE, and keep it in HL 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "ma2" 
918a						CALLMONITOR 
918a					endif 
918a			 
918a			    ; Search for free memory block 
918a			    ld de, (heap_end)  ; Load end of heap into DE 
918a			    ld bc, 0           ; Initialize counter 
918a			 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "ma2" 
918a						CALLMONITOR 
918a					endif 
918a			malloc_search_loop: 
918a			    ; Check if current block is free 
918a			    ld a, (hl)         ; Load current block's status (free or used) 
918a			    cp 0               ; Compare with zero (free) 
918a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
918a			 
918a			    ; Check if current block is large enough 
918a			    ld a, (hl+1)       ; Load high byte of block size 
918a			    cp l               ; Compare with low byte of requested size 
918a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
918a			 
918a			    ld a, (hl+2)       ; Load low byte of block size 
918a			    cp h               ; Compare with high byte of requested size 
918a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
918a			 
918a			    ; Mark block as used 
918a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
918a			 
918a			    ; Calculate remaining space in block 
918a			    ld bc, 0           ; Clear BC 
918a			    add hl, bc         ; Increment HL to point to start of data block 
918a			    add hl, de         ; HL = HL + DE (total size) 
918a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
918a			    add hl, bc         ; Add management overhead to start of data block 
918a			 
918a			    ; Save pointer to allocated block in HL 
918a			if DEBUG_FORTH_MALLOC_HIGH 
918a						DMARK "ma5" 
918a			call malloc_guard_exit 
918a			call malloc_guard_zerolen 
918a			endif 
918a			    ret 
918a			 
918a			malloc_skip_block_check: 
918a			    ; Move to the next block 
918a			    ld bc, 3           ; Size of management overhead 
918a			    add hl, bc         ; Move to the next block 
918a			    inc de             ; Increment counter 
918a			 
918a			    ; Check if we have reached the end of heap 
918a			    ld a, e            ; Load low byte of heap end address 
918a			    cp (hl)            ; Compare with low byte of current address 
918a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
918a			    ld a, d            ; Load high byte of heap end address 
918a			    cp 0               ; Check if it's zero (end of memory) 
918a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
918a			 
918a			    ; If we reached here, allocation failed 
918a			    xor a              ; Set result to NULL 
918a			if DEBUG_FORTH_MALLOC_HIGH 
918a						DMARK "ma6" 
918a			call malloc_guard_exit 
918a			call malloc_guard_zerolen 
918a			endif 
918a			    ret 
918a			malloc_exit: 
918a			if DEBUG_FORTH_MALLOC_HIGH 
918a						DMARK "ma7" 
918a			call malloc_guard_exit 
918a			call malloc_guard_zerolen 
918a			endif 
918a			    ret 
918a			 
918a			; Internal Free Function: 
918a			; Input: 
918a			;   HL: Pointer to memory block to free 
918a			; Output: 
918a			;   None 
918a			 
918a			free_internal: 
918a			    ld de, (heap_start) ; Load start of heap into DE 
918a			    ld bc, 0            ; Initialize counter 
918a			 
918a			free_search_loop: 
918a			    ; Check if current block contains the pointer 
918a			    ld a, l             ; Load low byte of pointer 
918a			    cp (hl+1)           ; Compare with high byte of current block's address 
918a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
918a			    ld a, h             ; Load high byte of pointer 
918a			    cp (hl+2)           ; Compare with low byte of current block's address 
918a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
918a			 
918a			    ; Mark block as free 
918a			    ld (hl), 0          ; Set status byte to indicate free block 
918a			    ret                 ; Return 
918a			 
918a			free_skip_block_check: 
918a			    ; Move to the next block 
918a			    ld bc, 3            ; Size of management overhead 
918a			    add hl, bc          ; Move to the next block 
918a			    inc de              ; Increment counter 
918a			 
918a			    ; Check if we have reached the end of heap 
918a			    ld a, e             ; Load low byte of heap end address 
918a			    cp (hl)             ; Compare with low byte of current address 
918a			    jr nz, free_search_loop  ; If not equal, continue searching 
918a			    ld a, d             ; Load high byte of heap end address 
918a			    cp 0                ; Check if it's zero (end of memory) 
918a			    jr nz, free_search_loop  ; If not zero, continue searching 
918a			 
918a			    ; If we reached here, pointer is not found in heap 
918a			    ret 
918a			 
918a			free_exit: 
918a			    ret                 ; Return 
918a			 
918a			; Define heap start and end addresses 
918a			;heap_start:    .dw 0xC000   ; Start of heap 
918a			;heap_end:      .dw 0xE000   ; End of heap 
918a			 
918a			endif 
918a			 
918a			 
918a			if MALLOC_1 
918a			 
918a			 
918a			 
918a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
918a			 
918a			;moved to firmware.asm 
918a			;heap_start        .equ  0x9000      ; Starting address of heap 
918a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
918a			 
918a			;      .org 0 
918a			;      jp    main 
918a			 
918a			 
918a			;      .org  0x100 
918a			;main: 
918a			;      ld    HL, 0x8100 
918a			;      ld    SP, HL 
918a			; 
918a			;      call  heap_init 
918a			; 
918a			;      ; Make some allocations 
918a			;      ld    HL, 12 
918a			;      call  malloc            ; Allocates 0x9004 
918a			; 
918a			;      ld    HL, 12 
918a			;      call  malloc            ; Allocates 0x9014 
918a			; 
918a			;      ld    HL, 12 
918a			;      call  malloc            ; Allocates 0x9024 
918a			; 
918a			;      ; Free some allocations 
918a			;      ld    HL, 0x9014 
918a			;      call  free 
918a			; 
918a			;      ld    HL, 0x9004 
918a			;      call  free 
918a			; 
918a			;      ld    HL, 0x9024 
918a			;      call  free 
918a			; 
918a			; 
918a			;      halt 
918a			 
918a			 
918a			;------------------------------------------------------------------------------ 
918a			;     heap_init                                                               : 
918a			;                                                                             : 
918a			; Description                                                                 : 
918a			;     Initialise the heap and make it ready for malloc and free operations.   : 
918a			;                                                                             : 
918a			;     The heap is maintained as a linked list, starting with an initial       : 
918a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
918a			;     the first free block in the heap. Each block then points to the next    : 
918a			;     free block within the heap, and the free list ends at the first block   : 
918a			;     with a null pointer to the next free block.                             : 
918a			;                                                                             : 
918a			; Parameters                                                                  : 
918a			;     Inputs are compile-time only. Two defines which specify the starting    : 
918a			;     address of the heap and its size are required, along with a memory      : 
918a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
918a			;     principally stores a pointer to the first free block in the heap.       : 
918a			;                                                                             : 
918a			; Returns                                                                     : 
918a			;     Nothing                                                                 : 
918a			;------------------------------------------------------------------------------ 
918a			heap_init: 
918a e5			      push  HL 
918b			 
918b			      ; Initialise free list struct 
918b 21 f3 e4		      ld    HL, heap_start 
918e 22 ee e4		      ld    (free_list), HL 
9191 21 00 00		      ld    HL, 0 
9194 22 f0 e4		      ld    (free_list+2), HL 
9197			 
9197			      ; Insert first free block at bottom of heap, consumes entire heap 
9197 21 98 e2		      ld    HL, heap_start+heap_size-4 
919a 22 f3 e4		      ld    (heap_start), HL        ; Next block (end of free list) 
919d 21 a5 fd		      ld    HL, heap_size-4 
91a0 22 f5 e4		      ld    (heap_start+2), HL      ; Block size 
91a3			 
91a3			      ; Insert end of free list block at top of heap - two null words will 
91a3			      ; terminate the free list 
91a3 21 00 00		      ld    HL, 0 
91a6 22 9a e2		      ld    (heap_start+heap_size-2), HL 
91a9 22 98 e2		      ld    (heap_start+heap_size-4), HL 
91ac			 
91ac e1			      pop   HL 
91ad			 
91ad c9			      ret 
91ae			 
91ae			 
91ae			;------------------------------------------------------------------------------ 
91ae			;     malloc                                                                  : 
91ae			;                                                                             : 
91ae			; Description                                                                 : 
91ae			;     Allocates the wanted space from the heap and returns the address of the : 
91ae			;     first useable byte of the allocation.                                   : 
91ae			;                                                                             : 
91ae			;     Allocations can happen in one of two ways:                              : 
91ae			;                                                                             : 
91ae			;     1. A free block may be found which is the exact size wanted. In this    : 
91ae			;        case the block is removed from the free list and retuedn to the      : 
91ae			;        caller.                                                              : 
91ae			;     2. A free block may be found which is larger than the size wanted. In   : 
91ae			;        this case, the larger block is split into two. The first portion of  : 
91ae			;        this block will become the requested space by the malloc call and    : 
91ae			;        is returned to the caller. The second portion becomes a new free     : 
91ae			;        block, and the free list is adjusted to maintain continuity via this : 
91ae			;        newly created block.                                                 : 
91ae			;                                                                             : 
91ae			;     malloc does not set any initial value in the allocated space, the       : 
91ae			;     caller is required to do this as required.                              : 
91ae			;                                                                             : 
91ae			;     This implementation of malloc uses the stack exclusively, and is        : 
91ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
91ae			;     to avoid the use of malloc inside ISRs in general.                      : 
91ae			;                                                                             : 
91ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91ae			;                                                                             : 
91ae			; Parameters                                                                  : 
91ae			;     HL  Number of bytes wanted                                              : 
91ae			;                                                                             : 
91ae			; Returns                                                                     : 
91ae			;     HL  Address of the first useable byte of the allocation                 : 
91ae			;                                                                             : 
91ae			; Flags                                                                       : 
91ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91ae			;                                                                             : 
91ae			; Stack frame                                                                 : 
91ae			;       |             |                                                       : 
91ae			;       +-------------+                                                       : 
91ae			;       |     BC      |                                                       : 
91ae			;       +-------------+                                                       : 
91ae			;       |     DE      |                                                       : 
91ae			;       +-------------+                                                       : 
91ae			;       |     IX      |                                                       : 
91ae			;       +-------------+                                                       : 
91ae			;       |  prev_free  |                                                       : 
91ae			;   +4  +-------------+                                                       : 
91ae			;       |  this_free  |                                                       : 
91ae			;   +2  +-------------+                                                       : 
91ae			;       |  next_free  |                                                       : 
91ae			;   +0  +-------------+                                                       : 
91ae			;       |             |                                                       : 
91ae			;                                                                             : 
91ae			;------------------------------------------------------------------------------ 
91ae			 
91ae			 
91ae			;malloc: 
91ae			; 
91ae			;	SAVESP ON 1 
91ae			; 
91ae			;	call malloc_code 
91ae			; 
91ae			;	CHECKSP ON 1 
91ae			;	ret 
91ae			 
91ae			 
91ae			malloc: 
91ae c5			      push  BC 
91af d5			      push  DE 
91b0 dd e5		      push  IX 
91b2			if DEBUG_FORTH_MALLOC_HIGH 
91b2			call malloc_guard_entry 
91b2			endif 
91b2			 
91b2					if DEBUG_FORTH_MALLOC 
91b2						DMARK "mal" 
91b2						CALLMONITOR 
91b2					endif 
91b2 7c			      ld    A, H                    ; Exit if no space requested 
91b3 b5			      or    L 
91b4 ca 73 92		      jp    Z, malloc_early_exit 
91b7			 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			; 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			;inc hl 
91b7			 
91b7			 
91b7			 
91b7			 
91b7					if DEBUG_FORTH_MALLOC 
91b7						DMARK "maA" 
91b7						CALLMONITOR 
91b7					endif 
91b7			      ; Set up stack frame 
91b7 eb			      ex    DE, HL 
91b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91bb 39			      add   HL, SP 
91bc f9			      ld    SP, HL 
91bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91c1 dd 39		      add   IX, SP 
91c3			 
91c3			      ; Setup initial state 
91c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91c6 19			      add   HL, DE 
91c7			 
91c7 44			      ld    B, H                    ; Move want to BC 
91c8 4d			      ld    C, L 
91c9			 
91c9 21 ee e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
91cc dd 75 04		      ld    (IX+4), L 
91cf dd 74 05		      ld    (IX+5), H 
91d2			 
91d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91d3 23			      inc   HL 
91d4 56			      ld    D, (HL) 
91d5 dd 73 02		      ld    (IX+2), E 
91d8 dd 72 03		      ld    (IX+3), D 
91db eb			      ex    DE, HL                  ; this_free ptr into HL 
91dc			 
91dc					if DEBUG_FORTH_MALLOC 
91dc						DMARK "maB" 
91dc						CALLMONITOR 
91dc					endif 
91dc			      ; Loop through free block list to find some space 
91dc			malloc_find_space: 
91dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91dd 23			      inc   HL 
91de 56			      ld    D, (HL) 
91df			 
91df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91e0 b3			      or    E 
91e1 ca 6d 92		      jp    Z, malloc_no_space 
91e4			 
91e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91e7 dd 72 01		      ld    (IX+1), D 
91ea			 
91ea			      ; Does this block have enough space to make the allocation? 
91ea 23			      inc   HL                      ; Load free block size into DE 
91eb 5e			      ld    E, (HL) 
91ec 23			      inc   HL 
91ed 56			      ld    D, (HL) 
91ee			 
91ee eb			      ex    DE, HL                  ; Check size of block against want 
91ef b7			      or    A                       ; Ensure carry flag clear 
91f0 ed 42		      sbc   HL, BC 
91f2 e5			      push  HL                      ; Store the result for later (new block size) 
91f3			 
91f3 ca 42 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91f8			 
91f8			      ; this_free block is not big enough, setup ptrs to test next free block 
91f8 e1			      pop   HL                      ; Discard previous result 
91f9			 
91f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91fc dd 66 03		      ld    H, (IX+3) 
91ff dd 75 04		      ld    (IX+4), L 
9202 dd 74 05		      ld    (IX+5), H 
9205			 
9205 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9208 dd 66 01		      ld    H, (IX+1) 
920b dd 75 02		      ld    (IX+2), L 
920e dd 74 03		      ld    (IX+3), H 
9211			 
9211					if DEBUG_FORTH_MALLOC 
9211						DMARK "MA>" 
9211						CALLMONITOR 
9211					endif 
9211 18 c9		      jr    malloc_find_space 
9213			 
9213			      ; split a bigger block into two - requested size and remaining size 
9213			malloc_alloc_split: 
9213					if DEBUG_FORTH_MALLOC 
9213						DMARK "MAs" 
9213						CALLMONITOR 
9213					endif 
9213 eb			      ex    DE, HL                  ; Calculate address of new free block 
9214 2b			      dec   HL 
9215 2b			      dec   HL 
9216 2b			      dec   HL 
9217 09			      add   HL, BC 
9218			 
9218			      ; Create a new block and point it at next_free 
9218 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
921b dd 56 01		      ld    D, (IX+1) 
921e			 
921e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
921f 23			      inc   HL 
9220 72			      ld    (HL), D 
9221			 
9221 d1			      pop   DE                      ; Store size of new block into new block 
9222 23			      inc   HL 
9223 73			      ld    (HL), E 
9224 23			      inc   HL 
9225 72			      ld    (HL), D 
9226			 
9226			      ; Update this_free ptr to point to new block 
9226 2b			      dec   HL 
9227 2b			      dec   HL 
9228 2b			      dec   HL 
9229			 
9229 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
922c dd 56 03		      ld    D, (IX+3) 
922f			 
922f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9232 dd 74 03		      ld    (IX+3), H 
9235			 
9235			      ; Modify this_free block to be allocation 
9235 eb			      ex    DE, HL 
9236 af			      xor   A                       ; Null the next block ptr of allocated block 
9237 77			      ld    (HL), A 
9238 23			      inc   HL 
9239 77			      ld    (HL), A 
923a			 
923a 23			      inc   HL                      ; Store want size into allocated block 
923b 71			      ld    (HL), C 
923c 23			      inc   HL 
923d 70			      ld    (HL), B 
923e 23			      inc   HL 
923f e5			      push  HL                      ; Address of allocation to return 
9240			 
9240 18 19		      jr    malloc_update_links 
9242			 
9242			malloc_alloc_fit: 
9242 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9243			 
9243					if DEBUG_FORTH_MALLOC 
9243						DMARK "MAf" 
9243						CALLMONITOR 
9243					endif 
9243			      ; Modify this_free block to be allocation 
9243 eb			      ex    DE, HL 
9244 2b			      dec   HL 
9245 2b			      dec   HL 
9246 2b			      dec   HL 
9247			 
9247 af			      xor   A                       ; Null the next block ptr of allocated block 
9248 77			      ld    (HL), A 
9249 23			      inc   HL 
924a 77			      ld    (HL), A 
924b			 
924b 23			      inc   HL                      ; Store address of allocation to return 
924c 23			      inc   HL 
924d 23			      inc   HL 
924e e5			      push  HL 
924f			 
924f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
924f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9252 dd 66 01		      ld    H, (IX+1) 
9255			 
9255 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9258 dd 74 03		      ld    (IX+3), H 
925b			 
925b			 
925b			malloc_update_links: 
925b			      ; Update prev_free ptr to point to this_free 
925b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
925e dd 66 05		      ld    H, (IX+5) 
9261			 
9261 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9264 dd 56 03		      ld    D, (IX+3) 
9267			 
9267 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9268 23			      inc   HL 
9269 72			      ld    (HL), D 
926a			 
926a					if DEBUG_FORTH_MALLOC 
926a						DMARK "Mul" 
926a						CALLMONITOR 
926a					endif 
926a			      ; Clear the Z flag to indicate successful allocation 
926a 7a			      ld    A, D 
926b b3			      or    E 
926c			 
926c d1			      pop   DE                      ; Address of allocation 
926d					if DEBUG_FORTH_MALLOC 
926d						DMARK "MAu" 
926d						CALLMONITOR 
926d					endif 
926d			 
926d			malloc_no_space: 
926d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9270 39			      add   HL, SP 
9271 f9			      ld    SP, HL 
9272			 
9272 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9273					if DEBUG_FORTH_MALLOC 
9273						DMARK "MAN" 
9273						CALLMONITOR 
9273					endif 
9273			 
9273			malloc_early_exit: 
9273					if DEBUG_FORTH_MALLOC 
9273						DMARK "MAx" 
9273						CALLMONITOR 
9273					endif 
9273 dd e1		      pop   IX 
9275 d1			      pop   DE 
9276 c1			      pop   BC 
9277			 
9277			if DEBUG_FORTH_MALLOC_HIGH 
9277			call malloc_guard_exit 
9277			call malloc_guard_zerolen 
9277			endif 
9277 c9			      ret 
9278			 
9278			 
9278			;------------------------------------------------------------------------------ 
9278			;     free                                                                    : 
9278			;                                                                             : 
9278			; Description                                                                 : 
9278			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9278			;     returned by malloc, otherwise the behaviour is undefined.               : 
9278			;                                                                             : 
9278			;     Where possible, directly adjacent free blocks will be merged together   : 
9278			;     into larger blocks to help ensure that the heap does not become         : 
9278			;     excessively fragmented.                                                 : 
9278			;                                                                             : 
9278			;     free does not clear or set any other value into the freed space, and    : 
9278			;     therefore its contents may be visible through subsequent malloc's. The  : 
9278			;     caller should clear the freed space as required.                        : 
9278			;                                                                             : 
9278			;     This implementation of free uses the stack exclusively, and is          : 
9278			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9278			;     advisable to disable interrupts before calling free, and recommended    : 
9278			;     to avoid the use of free inside ISRs in general.                        : 
9278			;                                                                             : 
9278			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9278			;                                                                             : 
9278			; Parameters                                                                  : 
9278			;     HL  Pointer to address of first byte of allocation to be freed          : 
9278			;                                                                             : 
9278			; Returns                                                                     : 
9278			;     Nothing                                                                 : 
9278			;                                                                             : 
9278			; Stack frame                                                                 : 
9278			;       |             |                                                       : 
9278			;       +-------------+                                                       : 
9278			;       |     BC      |                                                       : 
9278			;       +-------------+                                                       : 
9278			;       |     DE      |                                                       : 
9278			;       +-------------+                                                       : 
9278			;       |     IX      |                                                       : 
9278			;       +-------------+                                                       : 
9278			;       |  prev_free  |                                                       : 
9278			;   +2  +-------------+                                                       : 
9278			;       |  next_free  |                                                       : 
9278			;   +0  +-------------+                                                       : 
9278			;       |             |                                                       : 
9278			;                                                                             : 
9278			;------------------------------------------------------------------------------ 
9278			free: 
9278 c5			      push  BC 
9279 d5			      push  DE 
927a dd e5		      push  IX 
927c			 
927c 7c			      ld    A, H                    ; Exit if ptr is null 
927d b5			      or    L 
927e ca 42 93		      jp    Z, free_early_exit 
9281			 
9281			      ; Set up stack frame 
9281 eb			      ex    DE, HL 
9282 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9285 39			      add   HL, SP 
9286 f9			      ld    SP, HL 
9287 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
928b dd 39		      add   IX, SP 
928d			 
928d			      ; The address in HL points to the start of the useable allocated space, 
928d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
928d			      ; address of the block itself. 
928d eb			      ex    DE, HL 
928e 11 fc ff		      ld    DE, -4 
9291 19			      add   HL, DE 
9292			 
9292			      ; An allocated block must have a null next block pointer in it 
9292 7e			      ld    A, (HL) 
9293 23			      inc   HL 
9294 b6			      or    (HL) 
9295 c2 3d 93		      jp    NZ, free_done 
9298			 
9298 2b			      dec   HL 
9299			 
9299 44			      ld    B, H                    ; Copy HL to BC 
929a 4d			      ld    C, L 
929b			 
929b			      ; Loop through the free list to find the first block with an address 
929b			      ; higher than the block being freed 
929b 21 ee e4		      ld    HL, free_list 
929e			 
929e			free_find_higher_block: 
929e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
929f 23			      inc   HL 
92a0 56			      ld    D, (HL) 
92a1 2b			      dec   HL 
92a2			 
92a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
92a5 dd 72 01		      ld    (IX+1), D 
92a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92ab dd 74 03		      ld    (IX+3), H 
92ae			 
92ae 78			      ld    A, B                    ; Check if DE is greater than BC 
92af ba			      cp    D                       ; Compare MSB first 
92b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92b2 30 04		      jr    NC, free_find_higher_block_skip 
92b4 79			      ld    A, C 
92b5 bb			      cp    E                       ; Then compare LSB 
92b6 38 08		      jr    C, free_found_higher_block 
92b8			 
92b8			free_find_higher_block_skip: 
92b8 7a			      ld    A, D                    ; Reached the end of the free list? 
92b9 b3			      or    E 
92ba ca 3d 93		      jp    Z, free_done 
92bd			 
92bd eb			      ex    DE, HL 
92be			 
92be 18 de		      jr    free_find_higher_block 
92c0			 
92c0			free_found_higher_block: 
92c0			      ; Insert freed block between prev and next free blocks 
92c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
92c1 23			      inc   HL 
92c2 70			      ld    (HL), B 
92c3			 
92c3 60			      ld    H, B                    ; Point freed block at next free block 
92c4 69			      ld    L, C 
92c5 73			      ld    (HL), E 
92c6 23			      inc   HL 
92c7 72			      ld    (HL), D 
92c8			 
92c8			      ; Check if the freed block is adjacent to the next free block 
92c8 23			      inc   HL                      ; Load size of freed block into HL 
92c9 5e			      ld    E, (HL) 
92ca 23			      inc   HL 
92cb 56			      ld    D, (HL) 
92cc eb			      ex    DE, HL 
92cd			 
92cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
92ce			 
92ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92d1 dd 56 01		      ld    D, (IX+1) 
92d4			 
92d4 b7			      or    A                       ; Clear the carry flag 
92d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
92d9			 
92d9			      ; Freed block is adjacent to next, merge into one bigger block 
92d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd e5			      push  HL                      ; Save ptr to next block for later 
92de			 
92de 60			      ld    H, B                    ; Store ptr from next block into freed block 
92df 69			      ld    L, C 
92e0 73			      ld    (HL), E 
92e1 23			      inc   HL 
92e2 72			      ld    (HL), D 
92e3			 
92e3 e1			      pop   HL                      ; Restore ptr to next block 
92e4 23			      inc   HL                      ; Load size of next block into DE 
92e5 5e			      ld    E, (HL) 
92e6 23			      inc   HL 
92e7 56			      ld    D, (HL) 
92e8 d5			      push  DE                      ; Save next block size for later 
92e9			 
92e9 60			      ld    H, B                    ; Load size of freed block into HL 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 5e			      ld    E, (HL) 
92ee 23			      inc   HL 
92ef 56			      ld    D, (HL) 
92f0 eb			      ex    DE, HL 
92f1			 
92f1 d1			      pop   DE                      ; Restore size of next block 
92f2 19			      add   HL, DE                  ; Add sizes of both blocks 
92f3 eb			      ex    DE, HL 
92f4			 
92f4 60			      ld    H, B                    ; Store new bigger size into freed block 
92f5 69			      ld    L, C 
92f6 23			      inc   HL 
92f7 23			      inc   HL 
92f8 73			      ld    (HL), E 
92f9 23			      inc   HL 
92fa 72			      ld    (HL), D 
92fb			 
92fb			free_check_adjacent_to_prev: 
92fb			      ; Check if the freed block is adjacent to the prev free block 
92fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92fe dd 66 03		      ld    H, (IX+3) 
9301			 
9301 23			      inc   HL                      ; Size of prev free block into DE 
9302 23			      inc   HL 
9303 5e			      ld    E, (HL) 
9304 23			      inc   HL 
9305 56			      ld    D, (HL) 
9306 2b			      dec   HL 
9307 2b			      dec   HL 
9308 2b			      dec   HL 
9309			 
9309 19			      add   HL, DE                  ; Add prev block addr and size 
930a			 
930a b7			      or    A                       ; Clear the carry flag 
930b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
930d 20 2e		      jr    NZ, free_done 
930f			 
930f			      ; Freed block is adjacent to prev, merge into one bigger block 
930f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9310 69			      ld    L, C 
9311 5e			      ld    E, (HL) 
9312 23			      inc   HL 
9313 56			      ld    D, (HL) 
9314 e5			      push  HL                      ; Save freed block ptr for later 
9315			 
9315 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9318 dd 66 03		      ld    H, (IX+3) 
931b 73			      ld    (HL), E 
931c 23			      inc   HL 
931d 72			      ld    (HL), D 
931e			 
931e e1			      pop   HL                      ; Restore freed block ptr 
931f 23			      inc   HL                      ; Load size of freed block into DE 
9320 5e			      ld    E, (HL) 
9321 23			      inc   HL 
9322 56			      ld    D, (HL) 
9323 d5			      push  DE                      ; Save freed block size for later 
9324			 
9324 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
9327 dd 66 03		      ld    H, (IX+3) 
932a 23			      inc   HL 
932b 23			      inc   HL 
932c 5e			      ld    E, (HL) 
932d 23			      inc   HL 
932e 56			      ld    D, (HL) 
932f			 
932f e1			      pop   HL                      ; Add sizes of both blocks 
9330 19			      add   HL, DE 
9331 eb			      ex    DE, HL 
9332			 
9332 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9335 dd 66 03		      ld    H, (IX+3) 
9338 23			      inc   HL 
9339 23			      inc   HL 
933a 73			      ld    (HL), E 
933b 23			      inc   HL 
933c 72			      ld    (HL), D 
933d			 
933d			free_done: 
933d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9340 39			      add   HL, SP 
9341 f9			      ld    SP, HL 
9342			 
9342			free_early_exit: 
9342 dd e1		      pop   IX 
9344 d1			      pop   DE 
9345 c1			      pop   BC 
9346			 
9346 c9			      ret 
9347			 
9347			; moved to firmware.asm 
9347			; 
9347			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9347			;                  .dw   0 
9347			 
9347			 
9347			endif 
9347			 
9347			 
9347			if MALLOC_3 
9347			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9347			;heap_start        .equ  0x9000      ; Starting address of heap 
9347			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9347			; 
9347			 ;     .org 0 
9347			  ;    jp    main 
9347			; 
9347			; 
9347			 ;     .org  0x100 
9347			;main: 
9347			 ;     ld    HL, 0x8100 
9347			  ;    ld    SP, HL 
9347			; 
9347			;      call  heap_init 
9347			 
9347			      ; Make some allocations 
9347			;      ld    HL, 12 
9347			;      call  malloc            ; Allocates 0x9004 
9347			; 
9347			 ;     ld    HL, 12 
9347			;      call  malloc            ; Allocates 0x9014 
9347			 
9347			;      ld    HL, 12 
9347			;      call  malloc            ; Allocates 0x9024 
9347			 
9347			      ; Free some allocations 
9347			;      ld    HL, 0x9014 
9347			;      call  free 
9347			 
9347			;      ld    HL, 0x9004 
9347			;      call  free 
9347			; 
9347			;      ld    HL, 0x9024 
9347			;      call  free 
9347			 
9347			 
9347			 ;     halt 
9347			 
9347			 
9347			;------------------------------------------------------------------------------ 
9347			;     heap_init                                                               : 
9347			;                                                                             : 
9347			; Description                                                                 : 
9347			;     Initialise the heap and make it ready for malloc and free operations.   : 
9347			;                                                                             : 
9347			;     The heap is maintained as a linked list, starting with an initial       : 
9347			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9347			;     the first free block in the heap. Each block then points to the next    : 
9347			;     free block within the heap, and the free list ends at the first block   : 
9347			;     with a null pointer to the next free block.                             : 
9347			;                                                                             : 
9347			; Parameters                                                                  : 
9347			;     Inputs are compile-time only. Two defines which specify the starting    : 
9347			;     address of the heap and its size are required, along with a memory      : 
9347			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9347			;     principally stores a pointer to the first free block in the heap.       : 
9347			;                                                                             : 
9347			; Returns                                                                     : 
9347			;     Nothing                                                                 : 
9347			;------------------------------------------------------------------------------ 
9347			heap_init: 
9347			      push  HL 
9347			 
9347			      ; Initialise free list struct 
9347			      ld    HL, heap_start 
9347			      ld    (free_list), HL 
9347			      ld    HL, 0 
9347			      ld    (free_list+2), HL 
9347			 
9347			      ; Insert first free block at bottom of heap, consumes entire heap 
9347			      ld    HL, heap_start+heap_size-4 
9347			      ld    (heap_start), HL        ; Next block (end of free list) 
9347			      ld    HL, heap_size-4 
9347			      ld    (heap_start+2), HL      ; Block size 
9347			 
9347			      ; Insert end of free list block at top of heap - two null words will 
9347			      ; terminate the free list 
9347			      ld    HL, 0 
9347			      ld    (heap_start+heap_size-2), HL 
9347			      ld    (heap_start+heap_size-4), HL 
9347			 
9347			      pop   HL 
9347			 
9347			      ret 
9347			 
9347			 
9347			;------------------------------------------------------------------------------ 
9347			;     malloc                                                                  : 
9347			;                                                                             : 
9347			; Description                                                                 : 
9347			;     Allocates the wanted space from the heap and returns the address of the : 
9347			;     first useable byte of the allocation.                                   : 
9347			;                                                                             : 
9347			;     Allocations can happen in one of two ways:                              : 
9347			;                                                                             : 
9347			;     1. A free block may be found which is the exact size wanted. In this    : 
9347			;        case the block is removed from the free list and retuedn to the      : 
9347			;        caller.                                                              : 
9347			;     2. A free block may be found which is larger than the size wanted. In   : 
9347			;        this case, the larger block is split into two. The first portion of  : 
9347			;        this block will become the requested space by the malloc call and    : 
9347			;        is returned to the caller. The second portion becomes a new free     : 
9347			;        block, and the free list is adjusted to maintain continuity via this : 
9347			;        newly created block.                                                 : 
9347			;                                                                             : 
9347			;     malloc does not set any initial value in the allocated space, the       : 
9347			;     caller is required to do this as required.                              : 
9347			;                                                                             : 
9347			;     This implementation of malloc uses the stack exclusively, and is        : 
9347			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9347			;     advisable to disable interrupts before calling malloc, and recommended  : 
9347			;     to avoid the use of malloc inside ISRs in general.                      : 
9347			;                                                                             : 
9347			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9347			;                                                                             : 
9347			; Parameters                                                                  : 
9347			;     HL  Number of bytes wanted                                              : 
9347			;                                                                             : 
9347			; Returns                                                                     : 
9347			;     HL  Address of the first useable byte of the allocation                 : 
9347			;                                                                             : 
9347			; Flags                                                                       : 
9347			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9347			;                                                                             : 
9347			; Stack frame                                                                 : 
9347			;       |             |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |     BC      |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |     DE      |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |     IX      |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |  prev_free  |                                                       : 
9347			;   +4  +-------------+                                                       : 
9347			;       |  this_free  |                                                       : 
9347			;   +2  +-------------+                                                       : 
9347			;       |  next_free  |                                                       : 
9347			;   +0  +-------------+                                                       : 
9347			;       |             |                                                       : 
9347			;                                                                             : 
9347			;------------------------------------------------------------------------------ 
9347			malloc: 
9347			      push  BC 
9347			      push  DE 
9347			      push  IX 
9347			 
9347			      ld    A, H                    ; Exit if no space requested 
9347			      or    L 
9347			      jp    Z, malloc_early_exit 
9347			 
9347			      ; Set up stack frame 
9347			      ex    DE, HL 
9347			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9347			      add   HL, SP 
9347			      ld    SP, HL 
9347			      ld    IX, 0                   ; Use IX as a frame pointer 
9347			      add   IX, SP 
9347			 
9347			      ; Setup initial state 
9347			      ld    HL, 4                   ; want must also include space used by block struct 
9347			      add   HL, DE 
9347			 
9347			      ld    B, H                    ; Move want to BC 
9347			      ld    C, L 
9347			 
9347			      ld    HL, free_list           ; Store prev_free ptr to stack 
9347			      ld    (IX+4), L 
9347			      ld    (IX+5), H 
9347			 
9347			      ld    E, (HL)                 ; Store this_free ptr to stack 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      ld    (IX+2), E 
9347			      ld    (IX+3), D 
9347			      ex    DE, HL                  ; this_free ptr into HL 
9347			 
9347			      ; Loop through free block list to find some space 
9347			malloc_find_space: 
9347			      ld    E, (HL)                 ; Load next_free ptr into DE 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			 
9347			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9347			      or    E 
9347			      jp    Z, malloc_no_space 
9347			 
9347			      ld    (IX+0), E               ; Store next_free ptr to stack 
9347			      ld    (IX+1), D 
9347			 
9347			      ; Does this block have enough space to make the allocation? 
9347			      inc   HL                      ; Load free block size into DE 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			 
9347			      ex    DE, HL                  ; Check size of block against want 
9347			      or    A                       ; Ensure carry flag clear 
9347			      sbc   HL, BC 
9347			      push  HL                      ; Store the result for later (new block size) 
9347			 
9347			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9347			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9347			 
9347			      ; this_free block is not big enough, setup ptrs to test next free block 
9347			      pop   HL                      ; Discard previous result 
9347			 
9347			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9347			      ld    H, (IX+3) 
9347			      ld    (IX+4), L 
9347			      ld    (IX+5), H 
9347			 
9347			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9347			      ld    H, (IX+1) 
9347			      ld    (IX+2), L 
9347			      ld    (IX+3), H 
9347			 
9347			      jr    malloc_find_space 
9347			 
9347			      ; split a bigger block into two - requested size and remaining size 
9347			malloc_alloc_split: 
9347			      ex    DE, HL                  ; Calculate address of new free block 
9347			      dec   HL 
9347			      dec   HL 
9347			      dec   HL 
9347			      add   HL, BC 
9347			 
9347			      ; Create a new block and point it at next_free 
9347			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9347			      ld    D, (IX+1) 
9347			 
9347			      ld    (HL), E                 ; Store next_free ptr into new block 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			      pop   DE                      ; Store size of new block into new block 
9347			      inc   HL 
9347			      ld    (HL), E 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			      ; Update this_free ptr to point to new block 
9347			      dec   HL 
9347			      dec   HL 
9347			      dec   HL 
9347			 
9347			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9347			      ld    D, (IX+3) 
9347			 
9347			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9347			      ld    (IX+3), H 
9347			 
9347			      ; Modify this_free block to be allocation 
9347			      ex    DE, HL 
9347			      xor   A                       ; Null the next block ptr of allocated block 
9347			      ld    (HL), A 
9347			      inc   HL 
9347			      ld    (HL), A 
9347			 
9347			      inc   HL                      ; Store want size into allocated block 
9347			      ld    (HL), C 
9347			      inc   HL 
9347			      ld    (HL), B 
9347			      inc   HL 
9347			      push  HL                      ; Address of allocation to return 
9347			 
9347			      jr    malloc_update_links 
9347			 
9347			malloc_alloc_fit: 
9347			      pop   HL                      ; Dont need new block size, want is exact fit 
9347			 
9347			      ; Modify this_free block to be allocation 
9347			      ex    DE, HL 
9347			      dec   HL 
9347			      dec   HL 
9347			      dec   HL 
9347			 
9347			      xor   A                       ; Null the next block ptr of allocated block 
9347			      ld    (HL), A 
9347			      inc   HL 
9347			      ld    (HL), A 
9347			 
9347			      inc   HL                      ; Store address of allocation to return 
9347			      inc   HL 
9347			      inc   HL 
9347			      push  HL 
9347			 
9347			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9347			      ld    L, (IX+0)               ; next_free to HL 
9347			      ld    H, (IX+1) 
9347			 
9347			      ld    (IX+2), L               ; HL to this_free 
9347			      ld    (IX+3), H 
9347			 
9347			 
9347			malloc_update_links: 
9347			      ; Update prev_free ptr to point to this_free 
9347			      ld    L, (IX+4)               ; prev_free ptr to HL 
9347			      ld    H, (IX+5) 
9347			 
9347			      ld    E, (IX+2)               ; this_free ptr to DE 
9347			      ld    D, (IX+3) 
9347			 
9347			      ld    (HL), E                 ; this_free ptr into prev_free 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			      ; Clear the Z flag to indicate successful allocation 
9347			      ld    A, D 
9347			      or    E 
9347			 
9347			      pop   DE                      ; Address of allocation 
9347			 
9347			malloc_no_space: 
9347			      ld    HL, 6                   ; Clean up stack frame 
9347			      add   HL, SP 
9347			      ld    SP, HL 
9347			 
9347			      ex    DE, HL                  ; Alloc addr into HL for return 
9347			 
9347			malloc_early_exit: 
9347			      pop   IX 
9347			      pop   DE 
9347			      pop   BC 
9347			 
9347			      ret 
9347			 
9347			 
9347			;------------------------------------------------------------------------------ 
9347			;     free                                                                    : 
9347			;                                                                             : 
9347			; Description                                                                 : 
9347			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9347			;     returned by malloc, otherwise the behaviour is undefined.               : 
9347			;                                                                             : 
9347			;     Where possible, directly adjacent free blocks will be merged together   : 
9347			;     into larger blocks to help ensure that the heap does not become         : 
9347			;     excessively fragmented.                                                 : 
9347			;                                                                             : 
9347			;     free does not clear or set any other value into the freed space, and    : 
9347			;     therefore its contents may be visible through subsequent malloc's. The  : 
9347			;     caller should clear the freed space as required.                        : 
9347			;                                                                             : 
9347			;     This implementation of free uses the stack exclusively, and is          : 
9347			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9347			;     advisable to disable interrupts before calling free, and recommended    : 
9347			;     to avoid the use of free inside ISRs in general.                        : 
9347			;                                                                             : 
9347			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9347			;                                                                             : 
9347			; Parameters                                                                  : 
9347			;     HL  Pointer to address of first byte of allocation to be freed          : 
9347			;                                                                             : 
9347			; Returns                                                                     : 
9347			;     Nothing                                                                 : 
9347			;                                                                             : 
9347			; Stack frame                                                                 : 
9347			;       |             |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |     BC      |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |     DE      |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |     IX      |                                                       : 
9347			;       +-------------+                                                       : 
9347			;       |  prev_free  |                                                       : 
9347			;   +2  +-------------+                                                       : 
9347			;       |  next_free  |                                                       : 
9347			;   +0  +-------------+                                                       : 
9347			;       |             |                                                       : 
9347			;                                                                             : 
9347			;------------------------------------------------------------------------------ 
9347			free: 
9347			      push  BC 
9347			      push  DE 
9347			      push  IX 
9347			 
9347			      ld    A, H                    ; Exit if ptr is null 
9347			      or    L 
9347			      jp    Z, free_early_exit 
9347			 
9347			      ; Set up stack frame 
9347			      ex    DE, HL 
9347			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9347			      add   HL, SP 
9347			      ld    SP, HL 
9347			      ld    IX, 0                   ; Use IX as a frame pointer 
9347			      add   IX, SP 
9347			 
9347			      ; The address in HL points to the start of the useable allocated space, 
9347			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9347			      ; address of the block itself. 
9347			      ex    DE, HL 
9347			      ld    DE, -4 
9347			      add   HL, DE 
9347			 
9347			      ; An allocated block must have a null next block pointer in it 
9347			      ld    A, (HL) 
9347			      inc   HL 
9347			      or    (HL) 
9347			      jp    NZ, free_done 
9347			 
9347			      dec   HL 
9347			 
9347			      ld    B, H                    ; Copy HL to BC 
9347			      ld    C, L 
9347			 
9347			      ; Loop through the free list to find the first block with an address 
9347			      ; higher than the block being freed 
9347			      ld    HL, free_list 
9347			 
9347			free_find_higher_block: 
9347			      ld    E, (HL)                 ; Load next ptr from free block 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      dec   HL 
9347			 
9347			      ld    (IX+0), E               ; Save ptr to next free block 
9347			      ld    (IX+1), D 
9347			      ld    (IX+2), L               ; Save ptr to prev free block 
9347			      ld    (IX+3), H 
9347			 
9347			      ld    A, B                    ; Check if DE is greater than BC 
9347			      cp    D                       ; Compare MSB first 
9347			      jr    Z, $+4                  ; MSB the same, compare LSB 
9347			      jr    NC, free_find_higher_block_skip 
9347			      ld    A, C 
9347			      cp    E                       ; Then compare LSB 
9347			      jr    C, free_found_higher_block 
9347			 
9347			free_find_higher_block_skip: 
9347			      ld    A, D                    ; Reached the end of the free list? 
9347			      or    E 
9347			      jp    Z, free_done 
9347			 
9347			      ex    DE, HL 
9347			 
9347			      jr    free_find_higher_block 
9347			 
9347			free_found_higher_block: 
9347			      ; Insert freed block between prev and next free blocks 
9347			      ld    (HL), C                 ; Point prev free block to freed block 
9347			      inc   HL 
9347			      ld    (HL), B 
9347			 
9347			      ld    H, B                    ; Point freed block at next free block 
9347			      ld    L, C 
9347			      ld    (HL), E 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			      ; Check if the freed block is adjacent to the next free block 
9347			      inc   HL                      ; Load size of freed block into HL 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      ex    DE, HL 
9347			 
9347			      add   HL, BC                  ; Add addr of freed block and its size 
9347			 
9347			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9347			      ld    D, (IX+1) 
9347			 
9347			      or    A                       ; Clear the carry flag 
9347			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9347			      jr    NZ, free_check_adjacent_to_prev 
9347			 
9347			      ; Freed block is adjacent to next, merge into one bigger block 
9347			      ex    DE, HL                  ; Load next ptr from next block into DE 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      push  HL                      ; Save ptr to next block for later 
9347			 
9347			      ld    H, B                    ; Store ptr from next block into freed block 
9347			      ld    L, C 
9347			      ld    (HL), E 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			      pop   HL                      ; Restore ptr to next block 
9347			      inc   HL                      ; Load size of next block into DE 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      push  DE                      ; Save next block size for later 
9347			 
9347			      ld    H, B                    ; Load size of freed block into HL 
9347			      ld    L, C 
9347			      inc   HL 
9347			      inc   HL 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      ex    DE, HL 
9347			 
9347			      pop   DE                      ; Restore size of next block 
9347			      add   HL, DE                  ; Add sizes of both blocks 
9347			      ex    DE, HL 
9347			 
9347			      ld    H, B                    ; Store new bigger size into freed block 
9347			      ld    L, C 
9347			      inc   HL 
9347			      inc   HL 
9347			      ld    (HL), E 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			free_check_adjacent_to_prev: 
9347			      ; Check if the freed block is adjacent to the prev free block 
9347			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9347			      ld    H, (IX+3) 
9347			 
9347			      inc   HL                      ; Size of prev free block into DE 
9347			      inc   HL 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      dec   HL 
9347			      dec   HL 
9347			      dec   HL 
9347			 
9347			      add   HL, DE                  ; Add prev block addr and size 
9347			 
9347			      or    A                       ; Clear the carry flag 
9347			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9347			      jr    NZ, free_done 
9347			 
9347			      ; Freed block is adjacent to prev, merge into one bigger block 
9347			      ld    H, B                    ; Load next ptr from freed block into DE 
9347			      ld    L, C 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      push  HL                      ; Save freed block ptr for later 
9347			 
9347			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9347			      ld    H, (IX+3) 
9347			      ld    (HL), E 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			      pop   HL                      ; Restore freed block ptr 
9347			      inc   HL                      ; Load size of freed block into DE 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			      push  DE                      ; Save freed block size for later 
9347			 
9347			      ld    L, (IX+2)               ; Load size of prev block into DE 
9347			      ld    H, (IX+3) 
9347			      inc   HL 
9347			      inc   HL 
9347			      ld    E, (HL) 
9347			      inc   HL 
9347			      ld    D, (HL) 
9347			 
9347			      pop   HL                      ; Add sizes of both blocks 
9347			      add   HL, DE 
9347			      ex    DE, HL 
9347			 
9347			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9347			      ld    H, (IX+3) 
9347			      inc   HL 
9347			      inc   HL 
9347			      ld    (HL), E 
9347			      inc   HL 
9347			      ld    (HL), D 
9347			 
9347			free_done: 
9347			      ld    HL, 4                   ; Clean up stack frame 
9347			      add   HL, SP 
9347			      ld    SP, HL 
9347			 
9347			free_early_exit: 
9347			      pop   IX 
9347			      pop   DE 
9347			      pop   BC 
9347			 
9347			      ret 
9347			 
9347			 
9347			;      .org 0x8000 
9347			; 
9347			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9347			 ;                 .dw   0 
9347			 
9347			endif 
9347			 
9347			 
9347			if MALLOC_4 
9347			 
9347			; My memory allocation code. Very very simple.... 
9347			; allocate space under 250 chars 
9347			 
9347			heap_init: 
9347				; init start of heap as zero 
9347				;  
9347			 
9347				ld hl, heap_start 
9347				ld a, 0 
9347				ld (hl), a      ; empty block 
9347				inc hl 
9347				ld a, 0 
9347				ld (hl), a      ; length of block 
9347				; write end of list 
9347				inc hl 
9347				ld a,(hl) 
9347				inc hl 
9347				ld a,(hl) 
9347				 
9347			 
9347				; init some malloc vars 
9347			 
9347				ld hl, 0 
9347				ld (free_list), hl       ; store last malloc location 
9347			 
9347				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9347				ld a, 0 
9347				ld (hl), a 
9347			 
9347			 
9347				ld hl, heap_start 
9347				;  
9347				  
9347				ret 
9347			 
9347			 
9347			;    free block marker 
9347			;    requested size  
9347			;    pointer to next block 
9347			;    .... 
9347			;    next block marker 
9347			 
9347			 
9347			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9347			; 
9347			 
9347			 
9347			malloc:  
9347				push de 
9347				push bc 
9347				push af 
9347			 
9347				; hl space required 
9347				 
9347				ld c, l    ; hold space   (TODO only a max of 255) 
9347			 
9347			;	inc c     ; TODO BUG need to fix memory leak on push str 
9347			;	inc c 
9347			;	inc c 
9347			;	inc c 
9347			;	inc c 
9347			;	inc c 
9347			;	inc c 
9347			 
9347			 
9347			 
9347				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9347			 
9347				ld a, (free_list+3) 
9347				cp 0 
9347				jr z, .contheap 
9347			 
9347				ld hl, (free_list)     ; get last alloc 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "mrs" 
9347						CALLMONITOR 
9347					endif 
9347				jr .startalloc 
9347			 
9347			.contheap: 
9347				ld hl, heap_start 
9347			 
9347			.startalloc: 
9347			 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "mym" 
9347						CALLMONITOR 
9347					endif 
9347			.findblock: 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "mmf" 
9347						CALLMONITOR 
9347					endif 
9347			 
9347				ld a,(hl)  
9347				; if byte is zero then clear to use 
9347			 
9347				cp 0 
9347				jr z, .foundemptyblock 
9347			 
9347				; if byte is not clear 
9347				;     then byte is offset to next block 
9347			 
9347				inc hl 
9347				ld a, (hl) ; get size 
9347			.nextblock:	inc hl 
9347					ld e, (hl) 
9347					inc hl 
9347					ld d, (hl) 
9347					ex de, hl 
9347			;	inc hl  ; move past the store space 
9347			;	inc hl  ; move past zero index  
9347			 
9347				; TODO detect no more space 
9347			 
9347				push hl 
9347				ld de, heap_end 
9347				call cmp16 
9347				pop hl 
9347				jr nc, .nospace 
9347			 
9347				jr .findblock 
9347			 
9347			.nospace: ld hl, 0 
9347				jp .exit 
9347			 
9347			 
9347			.foundemptyblock:	 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "mme" 
9347						CALLMONITOR 
9347					endif 
9347			 
9347			; TODO has block enough space if reusing??? 
9347			 
9347				;  
9347			 
9347			; see if this block has been previously used 
9347				inc hl 
9347				ld a, (hl) 
9347				dec hl 
9347				cp 0 
9347				jr z, .newblock 
9347			 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "meR" 
9347						CALLMONITOR 
9347					endif 
9347			 
9347			; no reusing previously allocated block 
9347			 
9347			; is it smaller than previously used? 
9347				 
9347				inc hl    ; move to size 
9347				ld a, c 
9347				sub (hl)        ; we want c < (hl) 
9347				dec hl    ; move back to marker 
9347			        jr z, .findblock 
9347			 
9347				; update with the new size which should be lower 
9347			 
9347			        ;inc  hl   ; negate next move. move back to size  
9347			 
9347			.newblock: 
9347				; need to be at marker here 
9347			 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "meN" 
9347						CALLMONITOR 
9347					endif 
9347			 
9347			 
9347				ld a, c 
9347			 
9347				ld (free_list+3), a	 ; flag resume from last malloc  
9347				ld (free_list), hl    ; save out last location 
9347			 
9347			 
9347				;inc a     ; space for length byte 
9347				ld (hl), a     ; save block in use marker 
9347			 
9347				inc hl   ; move to space marker 
9347				ld (hl), a    ; save new space 
9347			 
9347				inc hl   ; move to start of allocated area 
9347				 
9347			;	push hl     ; save where we are - 1  
9347			 
9347			;	inc hl  ; move past zero index  
9347				; skip space to set down new marker 
9347			 
9347				; provide some extra space for now 
9347			 
9347				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9347				inc a 
9347				inc a 
9347			 
9347				push hl   ; save where we are in the node block 
9347			 
9347				call addatohl 
9347			 
9347				; write linked list point 
9347			 
9347				pop de     ; get our node position 
9347				ex de, hl 
9347			 
9347				ld (hl), e 
9347				inc hl 
9347				ld (hl), d 
9347			 
9347				inc hl 
9347			 
9347				; now at start of allocated data so save pointer 
9347			 
9347				push hl 
9347			 
9347				; jump to position of next node and setup empty header in DE 
9347			 
9347				ex de, hl 
9347			 
9347			;	inc hl ; move past end of block 
9347			 
9347				ld a, 0 
9347				ld (hl), a   ; empty marker 
9347				inc hl 
9347				ld (hl), a   ; size 
9347				inc hl  
9347				ld (hl), a   ; ptr 
9347				inc hl 
9347				ld (hl), a   ; ptr 
9347			 
9347			 
9347				pop hl 
9347			 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "mmr" 
9347						CALLMONITOR 
9347					endif 
9347			 
9347			.exit: 
9347				pop af 
9347				pop bc 
9347				pop de  
9347				ret 
9347			 
9347			 
9347			 
9347			 
9347			free:  
9347				push hl 
9347				push af 
9347				; get address in hl 
9347			 
9347					if DEBUG_FORTH_MALLOC_INT 
9347						DMARK "fre" 
9347						CALLMONITOR 
9347					endif 
9347				; data is at hl - move to block count 
9347				dec hl 
9347				dec hl    ; get past pointer 
9347				dec hl 
9347			 
9347				ld a, (hl)    ; need this for a validation check 
9347			 
9347				dec hl    ; move to block marker 
9347			 
9347				; now check that the block count and block marker are the same  
9347			        ; this checks that we are on a malloc node and not random memory 
9347			        ; OK a faint chance this could be a problem but rare - famous last words! 
9347			 
9347				ld c, a 
9347				ld a, (hl)    
9347			 
9347				cp c 
9347				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9347			 
9347				; yes good chance we are on a malloc node 
9347			 
9347				ld a, 0      
9347				ld (hl), a   ; mark as free 
9347			 
9347				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9347			 
9347			.freeignore:  
9347			 
9347				pop af 
9347				pop hl 
9347			 
9347				ret 
9347			 
9347			 
9347			 
9347			endif 
9347			 
9347			; eof 
# End of file firmware_memory.asm
9347			  
9347			; device C  
9347			; Now handled by SPI  
9347			;if SOUND_ENABLE  
9347			;	include "firmware_sound.asm"  
9347			;endif  
9347			  
9347			include "firmware_diags.asm"  
9347			; Hardware diags menu 
9347			 
9347			 
9347			config: 
9347			 
9347 3e 00			ld a, 0 
9349 21 6d 93			ld hl, .configmn 
934c cd df 8a			call menu 
934f			 
934f fe 00			cp 0 
9351 c8				ret z 
9352			 
9352			;	cp 1 
9352			;	call z, .savetostore 
9352			 
9352 fe 01			cp 1 
9354			if STARTUP_V1 
9354 cc 83 93			call z, .selautoload 
9357			endif 
9357			 
9357			if STARTUP_V2 
9357				call z, .enautoload 
9357			endif 
9357 fe 02			cp 2 
9359 cc 79 93			call z, .disautoload 
935c			;	cp 3 
935c			;	call z, .selbank 
935c fe 03			cp 3 
935e cc a1 93			call z, .debug_tog 
9361 fe 04			cp 4 
9363 cc ef 94			call z, .bpsgo 
9366 fe 05			cp 5 
9368 cc ca 93			call z, hardware_diags 
936b			if STARTUP_V2 
936b				cp 6 
936b				call z, create_startup 
936b			endif 
936b 18 da			jr config 
936d			 
936d			.configmn: 
936d			;	dw prom_c3 
936d dd 96			dw prom_c2 
936f f2 96			dw prom_c2a 
9371			;	dw prom_c2b 
9371			;	dw prom_c4 
9371 11 97			dw prom_m4 
9373 2c 97			dw prom_m4b 
9375 34 97			dw prom_c1 
9377			if STARTUP_V2 
9377				dw prom_c9 
9377			endif 
9377 00 00			dw 0 
9379				 
9379			 
9379			if STARTUP_V2 
9379			.enautoload: 
9379				if STORAGE_SE 
9379				ld a, $fe      ; bit 0 clear 
9379				ld (spi_device), a 
9379			 
9379				call storage_get_block_0 
9379			 
9379				ld a, 1 
9379				ld (store_page+STORE_0_AUTOFILE), a 
9379			 
9379					ld hl, 0 
9379					ld de, store_page 
9379				call storage_write_block	 ; save update 
9379				else 
9379			 
9379				ld hl, prom_notav 
9379				ld de, prom_empty 
9379				call info_panel 
9379				endif 
9379			 
9379			 
9379				ret 
9379			endif 
9379			 
9379			.disautoload: 
9379				if STORAGE_SE 
9379				ld a, $fe      ; bit 0 clear 
9379				ld (spi_device), a 
9379			 
9379				call storage_get_block_0 
9379			 
9379				ld a, 0 
9379				ld (store_page+STORE_0_AUTOFILE), a 
9379			 
9379					ld hl, 0 
9379					ld de, store_page 
9379				call storage_write_block	 ; save update 
9379				else 
9379			 
9379 21 43 97			ld hl, prom_notav 
937c 11 59 97			ld de, prom_empty 
937f cd 3f 8a			call info_panel 
9382				endif 
9382			 
9382			 
9382 c9				ret 
9383			 
9383			if STARTUP_V1 
9383			 
9383			; Select auto start 
9383			 
9383			.selautoload: 
9383			 
9383				 
9383				if STORAGE_SE 
9383			 
9383					call config_dir 
9383				        ld hl, scratch 
9383					ld a, 0 
9383					call menu 
9383			 
9383					cp 0 
9383					ret z 
9383			 
9383					dec a 
9383			 
9383			 
9383					; locate menu option 
9383			 
9383					ld hl, scratch 
9383					call table_lookup 
9383			 
9383					if DEBUG_FORTH_WORDS 
9383						DMARK "ALl" 
9383						CALLMONITOR 
9383					endif 
9383					; with the pointer to the menu it, the byte following the zero term is the file id 
9383			 
9383					ld a, 0 
9383					ld bc, 50   ; max of bytes to look at 
9383					cpir  
9383			 
9383					if DEBUG_FORTH_WORDS 
9383						DMARK "ALb" 
9383						CALLMONITOR 
9383					endif 
9383					;inc hl 
9383			 
9383					ld a, (hl)   ; file id 
9383					 
9383				        ; save bank and file ids 
9383			 
9383					push af 
9383			 
9383			; TODO need to save to block 0 on bank 1	 
9383			 
9383					call storage_get_block_0 
9383			 
9383					if DEBUG_FORTH_WORDS 
9383						DMARK "AL0" 
9383						CALLMONITOR 
9383					endif 
9383					pop af 
9383			 
9383					ld (store_page+STORE_0_FILERUN),a 
9383					 
9383					; save bank id 
9383			 
9383					ld a,(spi_device) 
9383					ld (store_page+STORE_0_BANKRUN),a 
9383			 
9383					; enable auto run of store file 
9383			 
9383					ld a, 1 
9383					ld (store_page+STORE_0_AUTOFILE),a 
9383			 
9383					; save buffer 
9383			 
9383					ld hl, 0 
9383					ld de, store_page 
9383					if DEBUG_FORTH_WORDS 
9383						DMARK "ALw" 
9383						CALLMONITOR 
9383					endif 
9383				call storage_write_block	 ; save update 
9383			  
9383			 
9383			 
9383			 
9383					ld hl, scratch 
9383					call config_fdir 
9383			 
9383				else 
9383			 
9383 21 43 97			ld hl, prom_notav 
9386 11 59 97			ld de, prom_empty 
9389 cd 3f 8a			call info_panel 
938c			 
938c				endif 
938c c9				ret 
938d			endif 
938d			 
938d			 
938d			; Select storage bank 
938d			 
938d			.selbank: 
938d			 
938d			;	if STORAGE_SE 
938d			;	else 
938d			 
938d 21 43 97			ld hl, prom_notav 
9390 11 59 97			ld de, prom_empty 
9393 cd 3f 8a			call info_panel 
9396			;	endif 
9396				 
9396 c9				ret 
9397			 
9397			if STORAGE_SE 
9397			 
9397			.config_ldir:   
9397				; Load storage bank labels into menu array 
9397			 
9397				 
9397			 
9397			 
9397				ret 
9397			 
9397			 
9397			endif 
9397			 
9397			 
9397			; Save user words to storage 
9397			 
9397			.savetostore: 
9397			 
9397			;	if STORAGE_SE 
9397			; 
9397			;		call config_dir 
9397			;	        ld hl, scratch 
9397			;		ld a, 0 
9397			;		call menu 
9397			;		 
9397			;		ld hl, scratch 
9397			;		call config_fdir 
9397			; 
9397			;	else 
9397			 
9397 21 43 97			ld hl, prom_notav 
939a 11 59 97			ld de, prom_empty 
939d cd 3f 8a			call info_panel 
93a0			 
93a0			;	endif 
93a0			 
93a0 c9				ret 
93a1			 
93a1			if STARTUP_V2 
93a1			 
93a1			create_startup: 
93a1			 
93a1				ld a, 0 
93a1				ld hl, .crstart 
93a1				call menu 
93a1			 
93a1				cp 0 
93a1				ret z 
93a1			 
93a1				cp 1 
93a1				call z, .genlsword 
93a1				cp 2 
93a1				call z, .genedword 
93a1			 
93a1				cp 3 
93a1				call z, .gendemword 
93a1			 
93a1				cp 4 
93a1				call z, .genutlword 
93a1				cp 5 
93a1				call z, .genspiword 
93a1				cp 6 
93a1				call z, .genkeyword 
93a1				cp 7 
93a1				call z, .gensoundword 
93a1				jr create_startup 
93a1			 
93a1			.gensoundword: 
93a1				ld hl, crs_sound 
93a1				ld de, .soundworddef 
93a1				call .genfile 
93a1				ret 
93a1			.genlsword: 
93a1				ld hl, crs_s1 
93a1				ld de, .lsworddef 
93a1				call .genfile 
93a1				ret 
93a1			 
93a1			.genedword: 
93a1				ld de, .edworddef 
93a1				ld hl, crs_s2 
93a1				call .genfile 
93a1				ret 
93a1			 
93a1			.gendemword: 
93a1				ld de, .demoworddef 
93a1				ld hl, crs_s3 
93a1				call .genfile 
93a1				ret 
93a1			 
93a1			.genutlword: 
93a1				ld hl, crs_s4 
93a1				ld de, .utilwordef 
93a1				call .genfile 
93a1				ret 
93a1			.genspiword: 
93a1				ld hl, crs_s5 
93a1				ld de, .spiworddef 
93a1				call .genfile 
93a1				ret 
93a1			.genkeyword: 
93a1				ld hl, crs_s6 
93a1				ld de, .keyworddef 
93a1				call .genfile 
93a1				ret 
93a1			 
93a1			; hl - points to file name 
93a1			; de - points to strings to add to file 
93a1			 
93a1			.genfile: 
93a1				push hl 
93a1				push de 
93a1			 
93a1				call clear_display 
93a1				ld a, display_row_1 
93a1				ld de, .genfiletxt 
93a1				call str_at_display 
93a1				call update_display 
93a1			 
93a1				pop de 
93a1				pop hl 
93a1			 
93a1			 
93a1				push de 
93a1				call storage_create 
93a1				; id in hl 
93a1				pop de   ; table of strings to add 
93a1			 
93a1			.genloop: 
93a1			 
93a1				push hl ; save id for next time around 
93a1				push de ; save de for next time around 
93a1			 
93a1				ex de, hl 
93a1				call loadwordinhl 
93a1				ex de, hl 
93a1			 
93a1				; need hl to be the id 
93a1				; need de to be the string ptr 
93a1				 
93a1				call storage_append 
93a1			 
93a1				pop de 
93a1				pop hl 
93a1			 
93a1				inc de 
93a1				inc de 
93a1			 
93a1				ld a,(de) 
93a1				cp 0 
93a1				jr nz, .genloop 
93a1				inc de 
93a1				ld a, (de) 
93a1				dec de 
93a1				cp 0 
93a1				jr nz, .genloop	 
93a1			 
93a1				ret 
93a1			 
93a1			.genfiletxt:  db "Creating file...",0 
93a1			 
93a1			.soundworddef: 
93a1				dw sound1 
93a1				dw sound2 
93a1				dw sound3 
93a1				dw sound4 
93a1				dw sound5 
93a1				dw sound6 
93a1				dw sound7 
93a1				dw sound8 
93a1				dw sound9 
93a1				dw 0 
93a1			 
93a1			.utilwordef: 
93a1				dw strncpy 
93a1				dw type 
93a1				dw clrstack 
93a1				dw longread 
93a1				dw start1 
93a1				dw start2 
93a1			; duplicated 
93a1			;	dw start3b 
93a1			;	dw start3c 
93a1				dw list 
93a1				dw 0 
93a1			 
93a1			.lsworddef: 
93a1				dw start3b 
93a1				dw 0 
93a1			 
93a1			.edworddef: 
93a1				dw edit1 
93a1				dw edit2 
93a1				dw edit3 
93a1				dw 0 
93a1			 
93a1			.demoworddef: 
93a1				dw test5 
93a1				dw test6 
93a1				dw test7 
93a1				dw test8 
93a1				dw test9 
93a1				dw test10 
93a1				dw game1 
93a1				dw game1a 
93a1				dw game1b 
93a1				dw game1c 
93a1				dw game1d 
93a1				dw game1s 
93a1				dw game1t 
93a1				dw game1f 
93a1				dw game1z 
93a1				dw game1zz 
93a1				dw ssv2 
93a1				dw ssv3 
93a1				dw ssv4 
93a1				dw ssv5 
93a1				dw ssv1 
93a1				dw ssv1cpm	 
93a1				dw game2b 
93a1				dw game2bf 
93a1				dw game2mba 
93a1				dw game2mbas	 
93a1				dw game2mbht 
93a1				dw game2mbms 
93a1				dw game2mb 
93a1				dw game3w 
93a1				dw game3p 
93a1				dw game3sc 
93a1				dw game3vsi 
93a1				dw game3vs 
93a1				dw 0 
93a1			 
93a1			 
93a1			.spiworddef: 
93a1			 
93a1			    dw spi1 
93a1			    dw spi2 
93a1			    dw spi2b 
93a1			    dw spi3 
93a1			    dw spi4 
93a1			    dw spi5 
93a1			;    dw spi6 
93a1			;    dw spi7 
93a1			 
93a1			;    dw spi8 
93a1			;    dw spi9 
93a1			;    dw spi10 
93a1			    dw 0 
93a1			 
93a1			.keyworddef: 
93a1			 
93a1				dw keyup 
93a1				dw keydown 
93a1				dw keyleft 
93a1				dw keyright 
93a1				dw 	keyf1 
93a1				dw keyf2 
93a1				dw keyf3 
93a1				dw keyf4 
93a1				dw keyf5 
93a1				dw keyf6 
93a1				dw keyf7 
93a1				dw keyf8 
93a1				dw keyf9 
93a1				dw keyf10 
93a1				dw keyf11 
93a1				dw keyf12 
93a1				dw keytab 
93a1				dw keycr 
93a1				dw keyhome 
93a1				dw keyend 
93a1				dw keybs 
93a1				dw 0 
93a1			 
93a1			.crstart: 
93a1				dw crs_s1 
93a1				dw crs_s2 
93a1				dw crs_s3 
93a1				dw crs_s4 
93a1				dw crs_s5 
93a1				dw crs_s6 
93a1				dw crs_sound 
93a1				dw 0 
93a1			 
93a1			endif 
93a1			 
93a1			 
93a1			if STORAGE_SE 
93a1			 
93a1			config_fdir: 
93a1				; using the scratch dir go through and release the memory allocated for each string 
93a1				 
93a1				ld hl, scratch 
93a1			.cfdir:	ld e,(hl) 
93a1				inc hl 
93a1				ld d,(hl) 
93a1				inc hl 
93a1			 
93a1				ex de, hl 
93a1				call ishlzero 
93a1				ret z     ; return on null pointer 
93a1				call free 
93a1				ex de, hl 
93a1				jr .cfdir 
93a1			 
93a1			 
93a1				ret 
93a1			 
93a1			 
93a1			config_dir: 
93a1			 
93a1				; for the config menus that need to build a directory of storage call this routine 
93a1				; it will construct a menu in scratch to pass to menu 
93a1			 
93a1				; open storage device 
93a1			 
93a1				; execute DIR to build a list of files and their ids into scratch in menu format 
93a1				; once the menu has finished then will need to call config_fdir to release the strings 
93a1				 
93a1				; c = number items 
93a1			 
93a1				 
93a1				call storage_get_block_0 
93a1			 
93a1				ld hl, store_page     ; get current id count 
93a1				ld b, (hl) 
93a1				ld c, 0    ; count of files   
93a1			 
93a1			 
93a1				ld hl, scratch 
93a1				ld (store_tmp2), hl    ; location to poke strings 
93a1			 
93a1				; check for empty drive 
93a1			 
93a1				ld a, 0 
93a1				cp b 
93a1				jp z, .dirdone 
93a1			 
93a1				 
93a1					if DEBUG_FORTH_WORDS 
93a1						DMARK "Cdc" 
93a1						CALLMONITOR 
93a1					endif 
93a1			 
93a1			 
93a1			.diritem:	 
93a1				push bc 
93a1				; for each of the current ids do a search for them and if found push to stack 
93a1			 
93a1					ld hl, STORE_BLOCK_PHY 
93a1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
93a1					ld e,b 
93a1			 
93a1					call storage_findnextid 
93a1			 
93a1			 
93a1					; if found hl will be non zero 
93a1			 
93a1					call ishlzero 
93a1					jr z, .dirnotfound 
93a1			 
93a1					; increase count 
93a1			 
93a1					pop bc	 
93a1					inc c 
93a1					push bc 
93a1					 
93a1			 
93a1					; get file header and push the file name 
93a1			 
93a1					ld de, store_page 
93a1					call storage_read_block 
93a1			 
93a1					; push file id to stack 
93a1				 
93a1					ld a, (store_page) 
93a1					ld h, 0 
93a1					ld l, a 
93a1			 
93a1					;call forth_push_numhl 
93a1					; TODO store id 
93a1			 
93a1					push hl 
93a1			 
93a1					; push extent count to stack  
93a1				 
93a1					ld hl, store_page+3 
93a1			 
93a1					; get file name length 
93a1			 
93a1					call strlenz   
93a1			 
93a1					inc hl   ; cover zero term 
93a1					inc hl  ; stick the id at the end of the area 
93a1			 
93a1					push hl 
93a1					pop bc    ; move length to bc 
93a1			 
93a1					call malloc 
93a1			 
93a1					; TODO save malloc area to scratch 
93a1			 
93a1					ex de, hl 
93a1					ld hl, (store_tmp2) 
93a1					ld (hl), e 
93a1					inc hl 
93a1					ld (hl), d 
93a1					inc hl 
93a1					ld (store_tmp2), hl 
93a1			 
93a1					 
93a1			 
93a1					;pop hl   ; get source 
93a1			;		ex de, hl    ; swap aronund	 
93a1			 
93a1					ld hl, store_page+3 
93a1					if DEBUG_FORTH_WORDS 
93a1						DMARK "CFd" 
93a1						CALLMONITOR 
93a1					endif 
93a1					ldir 
93a1			 
93a1					; de is past string, move back one and store id 
93a1					 
93a1					dec de 
93a1			 
93a1					; store file id 
93a1			 
93a1					pop hl 
93a1					ex de,hl 
93a1					ld (hl), e 
93a1			 
93a1					if DEBUG_FORTH_WORDS 
93a1						DMARK "Cdi" 
93a1						CALLMONITOR 
93a1					endif 
93a1					 
93a1			.dirnotfound: 
93a1					pop bc     
93a1					djnz .diritem 
93a1				 
93a1			.dirdone:	 
93a1			 
93a1					ld a, 0 
93a1					ld hl, (store_tmp2) 
93a1					ld (hl), a 
93a1					inc hl 
93a1					ld (hl), a 
93a1					inc hl 
93a1					; push a count of the dir items found 
93a1			 
93a1			;		ld h, 0 
93a1			;		ld l, c 
93a1			 
93a1				ret 
93a1			 
93a1			endif 
93a1			 
93a1			 
93a1			; Settings 
93a1			; Run  
93a1			 
93a1			 
93a1			 
93a1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
93a1			;;hd_menu2:   db "        2: Editor",0   
93a1			;hd_menu2:   db "        2: Editor       6: Menu",0   
93a1			;hd_menu3:   db "        3: Storage",0 
93a1			;hd_menu4:   db "0=quit  4: Debug",0 
93a1			;hd_don:     db "ON",0 
93a1			;hd_doff:     db "OFF",0 
93a1			; 
93a1			; 
93a1			; 
93a1			;hardware_diags_old:       
93a1			; 
93a1			;.diagmenu: 
93a1			;	call clear_display 
93a1			;	ld a, display_row_1 
93a1			;	ld de, hd_menu1 
93a1			;	call str_at_display 
93a1			; 
93a1			;	ld a, display_row_2 
93a1			;	ld de, hd_menu2 
93a1			;	call str_at_display 
93a1			; 
93a1			;	ld a, display_row_3 
93a1			;	ld de, hd_menu3 
93a1			;	call str_at_display 
93a1			; 
93a1			;	ld a,  display_row_4 
93a1			;	ld de, hd_menu4 
93a1			;	call str_at_display 
93a1			; 
93a1			;	; display debug state 
93a1			; 
93a1			;	ld de, hd_don 
93a1			;	ld a, (os_view_disable) 
93a1			;	cp 0 
93a1			;	jr z, .distog 
93a1			;	ld de, hd_doff 
93a1			;.distog: ld a, display_row_4+17 
93a1			;	call str_at_display 
93a1			; 
93a1			;	call update_display 
93a1			; 
93a1			;	call cin_wait 
93a1			; 
93a1			; 
93a1			; 
93a1			;	cp '4' 
93a1			;	jr nz, .diagn1 
93a1			; 
93a1			;	; debug toggle 
93a1			; 
93a1			;	ld a, (os_view_disable) 
93a1			;	ld b, '*' 
93a1			;	cp 0 
93a1			;	jr z, .debtog 
93a1			;	ld b, 0 
93a1			;.debtog:	 
93a1			;	ld a,b 
93a1			;	ld (os_view_disable),a 
93a1			; 
93a1			;.diagn1: cp '0' 
93a1			;	 ret z 
93a1			; 
93a1			;;	cp '1' 
93a1			;;       jp z, matrix	 
93a1			;;   TODO keyboard matrix test 
93a1			; 
93a1			;	cp '2' 
93a1			;	jp z, .diagedit 
93a1			; 
93a1			;;	cp '6' 
93a1			;;	jp z, .menutest 
93a1			;;if ENABLE_BASIC 
93a1			;;	cp '6' 
93a1			;;	jp z, basic 
93a1			;;endif 
93a1			 ; 
93a1			;	jp .diagmenu 
93a1			; 
93a1			; 
93a1			;	ret 
93a1			 
93a1			 
93a1			.debug_tog: 
93a1 21 eb 93			ld hl, .menudebug 
93a4				 
93a4			;	ld a, (os_view_disable) 
93a4			;	cp '*' 
93a4 3a 6f ee			ld a,(debug_vector) 
93a7 fe c9			cp $C9   ; RET 
93a9 20 04			jr nz,.tdon  
93ab 3e 01			ld a, 1 
93ad 18 02			jr .tog1 
93af 3e 00		.tdon: ld a, 0 
93b1			 
93b1			.tog1: 
93b1 cd df 8a			call menu 
93b4 fe 00			cp 0 
93b6 c8				ret z 
93b7 fe 01			cp 1    ; disable debug 
93b9 28 04			jr z, .dtog0 
93bb 3e 2a			ld a, '*' 
93bd 18 05			jr .dtogset 
93bf			.dtog0:  
93bf				;ld a, 0 
93bf cd dd 94			call bp_on 
93c2 18 dd			jr .debug_tog 
93c4			.dtogset:  
93c4				; ld (os_view_disable), a 
93c4 cd e9 94			call bp_off 
93c7 c3 a1 93			jp .debug_tog 
93ca			 
93ca			 
93ca			hardware_diags:       
93ca			 
93ca			.diagm: 
93ca 21 dd 93			ld hl, .menuitems 
93cd 3e 00			ld a, 0 
93cf cd df 8a			call menu 
93d2			 
93d2 fe 00		         cp 0 
93d4 c8				 ret z 
93d5			 
93d5 fe 02			cp 2 
93d7 ca 36 94			jp z, .diagedit 
93da			 
93da			;	cp '6' 
93da			;	jp z, .menutest 
93da			;if ENABLE_BASIC 
93da			;	cp '6' 
93da			;	jp z, basic 
93da			;endif 
93da			  
93da c3 ca 93			jp .diagm 
93dd			 
93dd				 
93dd f1 93		.menuitems:   	dw .m1 
93df fc 93				dw .m2 
93e1 03 94				dw .m3 
93e3 0b 94				dw .m5 
93e5 11 94				dw .m5a 
93e7 1a 94				dw .m5b 
93e9 00 00				dw 0 
93eb			 
93eb			.menudebug: 
93eb 23 94				dw .m6 
93ed 2c 94				dw .m7 
93ef 00 00				dw 0 
93f1			 
93f1 .. 00		.m1:   db "Key Matrix",0 
93fc .. 00		.m2:   db "Editor",0 
9403 .. 00		.m3:   db "Storage",0 
940b .. 00		.m5:   db "Sound",0 
9411 .. 00		.m5a:  db "RAM Test",0 
941a .. 00		.m5b:  db "LCD Test",0 
9423			 
9423 .. 00		.m6:   db "Debug ON",0 
942c .. 00		.m7:   db "Debug OFF",0 
9436			 
9436			; debug editor 
9436			 
9436			.diagedit: 
9436			 
9436 21 c1 e2			ld hl, scratch 
9439			;	ld bc, 250 
9439			;	ldir 
9439				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9439 3e 00			ld a, 0 
943b 77				ld (hl), a 
943c 23				inc hl 
943d 77				ld (hl), a 
943e 23				inc hl 
943f 77				ld (hl), a 
9440			 
9440 cd ae 8a		        call clear_display 
9443 cd d1 8a			call update_display 
9446				;ld a, 1 
9446				;ld (hardware_diag), a 
9446			.diloop: 
9446 3e 00			ld a, display_row_1 
9448 0e 00			ld c, 0 
944a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
944c 1e 28			ld e, 40 
944e			 
944e 21 c1 e2			ld hl, scratch	 
9451 cd 08 8d			call input_str 
9454			 
9454 3e 28			ld a, display_row_2 
9456 11 c1 e2			ld de, scratch 
9459 cd c1 8a			call str_at_display 
945c cd d1 8a			call update_display 
945f			 
945f c3 46 94			jp .diloop 
9462			 
9462			 
9462			; pass word in hl 
9462			; a has display location 
9462			display_word_at: 
9462 f5				push af 
9463 e5				push hl 
9464 7c				ld a,h 
9465 21 c6 e5			ld hl, os_word_scratch 
9468 cd dc 8f			call hexout 
946b e1				pop hl 
946c 7d				ld a,l 
946d 21 c8 e5			ld hl, os_word_scratch+2 
9470 cd dc 8f			call hexout 
9473 21 ca e5			ld hl, os_word_scratch+4 
9476 3e 00			ld a,0 
9478 77				ld (hl),a 
9479 11 c6 e5			ld de,os_word_scratch 
947c f1				pop af 
947d cd c1 8a				call str_at_display 
9480 c9				ret 
9481			 
9481			display_ptr_state: 
9481			 
9481				; to restore afterwards 
9481			 
9481 d5				push de 
9482 c5				push bc 
9483 e5				push hl 
9484 f5				push af 
9485			 
9485				; for use in here 
9485			 
9485			;	push bc 
9485			;	push de 
9485			;	push hl 
9485			;	push af 
9485			 
9485 cd ae 8a			call clear_display 
9488			 
9488 11 60 96			ld de, .ptrstate 
948b 3e 00			ld a, display_row_1 
948d cd c1 8a			call str_at_display 
9490			 
9490				; display debug step 
9490			 
9490			 
9490 11 6b ee			ld de, debug_mark 
9493 3e 26			ld a, display_row_1+display_cols-2 
9495 cd c1 8a			call str_at_display 
9498			 
9498				; display a 
9498 11 6a 96			ld de, .ptrcliptr 
949b 3e 28			ld a, display_row_2 
949d cd c1 8a			call str_at_display 
94a0			 
94a0 f1				pop af 
94a1 2a 40 ea			ld hl,(cli_ptr) 
94a4 3e 30			ld a, display_row_2+8 
94a6 cd 62 94			call display_word_at 
94a9			 
94a9			 
94a9				; display hl 
94a9			 
94a9			 
94a9 11 72 96			ld de, .ptrclioptr 
94ac 3e 32			ld a, display_row_2+10 
94ae cd c1 8a			call str_at_display 
94b1			; 
94b1			;	pop hl 
94b1 3e 35			ld a, display_row_2+13 
94b3 2a 3e ea			ld hl,(cli_origptr) 
94b6 cd 62 94			call display_word_at 
94b9			; 
94b9			;	 
94b9			;	; display de 
94b9			 
94b9			;	ld de, .regstatede 
94b9			;	ld a, display_row_3 
94b9			;	call str_at_display 
94b9			 
94b9			;	pop de 
94b9			;	ld h,d 
94b9			;	ld l, e 
94b9			;	ld a, display_row_3+3 
94b9			;	call display_word_at 
94b9			 
94b9			 
94b9				; display bc 
94b9			 
94b9			;	ld de, .regstatebc 
94b9			;	ld a, display_row_3+10 
94b9			;	call str_at_display 
94b9			 
94b9			;	pop bc 
94b9			;	ld h,b 
94b9			;	ld l, c 
94b9			;	ld a, display_row_3+13 
94b9			;	call display_word_at 
94b9			 
94b9			 
94b9				; display dsp 
94b9			 
94b9			;	ld de, .regstatedsp 
94b9			;	ld a, display_row_4 
94b9			;	call str_at_display 
94b9			 
94b9				 
94b9			;	ld hl,(cli_data_sp) 
94b9			;	ld a, display_row_4+4 
94b9			;	call display_word_at 
94b9			 
94b9				; display rsp 
94b9			 
94b9 11 a1 96			ld de, .regstatersp 
94bc 3e 82			ld a, display_row_4+10 
94be cd c1 8a			call str_at_display 
94c1			 
94c1				 
94c1 2a f2 e9			ld hl,(cli_ret_sp) 
94c4 3e 86			ld a, display_row_4+14 
94c6 cd 62 94			call display_word_at 
94c9			 
94c9 cd d1 8a			call update_display 
94cc			 
94cc cd f1 89			call delay1s 
94cf cd f1 89			call delay1s 
94d2 cd f1 89			call delay1s 
94d5			 
94d5			 
94d5 cd bf 9a			call next_page_prompt 
94d8			 
94d8				; restore  
94d8			 
94d8 f1				pop af 
94d9 e1				pop hl 
94da c1				pop bc 
94db d1				pop de 
94dc c9				ret 
94dd			 
94dd			; Update the break point vector so that the user can hook a new routine 
94dd			 
94dd			bp_on: 
94dd 3e c3			ld a, $c3    ; JP 
94df 32 6f ee			ld (debug_vector), a 
94e2 21 ef 94			ld hl, break_point_state 
94e5 22 70 ee			ld (debug_vector+1), hl 
94e8 c9				ret 
94e9			 
94e9			bp_off: 
94e9 3e c9			ld a, $c9    ; RET 
94eb 32 6f ee			ld (debug_vector), a 
94ee c9				ret 
94ef			 
94ef			 
94ef			break_point_state: 
94ef			;	push af 
94ef			; 
94ef			;	; see if disabled 
94ef			; 
94ef			;	ld a, (os_view_disable) 
94ef			;	cp '*' 
94ef			;	jr nz, .bpsgo 
94ef			;	pop af 
94ef			;	ret 
94ef			 
94ef			.bpsgo: 
94ef			;	pop af 
94ef f5				push af 
94f0 22 a3 e2			ld (os_view_hl), hl 
94f3 ed 53 a1 e2		ld (os_view_de), de 
94f7 ed 43 9f e2		ld (os_view_bc), bc 
94fb e5				push hl 
94fc 6f				ld l, a 
94fd 26 00			ld h, 0 
94ff 22 a5 e2			ld (os_view_af),hl 
9502			 
9502 21 b1 ed				ld hl, display_fb0 
9505 22 cc eb				ld (display_fb_active), hl 
9508 e1				pop hl	 
9509			 
9509 3e 31			ld a, '1' 
950b fe 2a		.bps1:  cp '*' 
950d cc e9 94			call z, bp_off 
9510			;	jr nz, .bps1b 
9510			;	ld (os_view_disable),a 
9510 fe 31		.bps1b:  cp '1' 
9512 20 14			jr nz, .bps2 
9514			 
9514				; display reg 
9514			 
9514				 
9514			 
9514 3a a5 e2			ld a, (os_view_af) 
9517 2a a3 e2			ld hl, (os_view_hl) 
951a ed 5b a1 e2		ld de, (os_view_de) 
951e ed 4b 9f e2		ld bc, (os_view_bc) 
9522 cd bc 95			call display_reg_state 
9525 c3 a8 95			jp .bpschk 
9528			 
9528 fe 32		.bps2:  cp '2' 
952a 20 08			jr nz, .bps3 
952c				 
952c				; display hl 
952c 2a a3 e2			ld hl, (os_view_hl) 
952f cd a6 96			call display_dump_at_hl 
9532			 
9532 18 74			jr .bpschk 
9534			 
9534 fe 33		.bps3:  cp '3' 
9536 20 08			jr nz, .bps4 
9538			 
9538			        ; display de 
9538 2a a1 e2			ld hl, (os_view_de) 
953b cd a6 96			call display_dump_at_hl 
953e			 
953e 18 68			jr .bpschk 
9540 fe 34		.bps4:  cp '4' 
9542 20 08			jr nz, .bps5 
9544			 
9544			        ; display bc 
9544 2a 9f e2			ld hl, (os_view_bc) 
9547 cd a6 96			call display_dump_at_hl 
954a			 
954a 18 5c			jr .bpschk 
954c fe 35		.bps5:  cp '5' 
954e 20 08		        jr nz, .bps7 
9550			 
9550				; display cur ptr 
9550 2a 40 ea			ld hl, (cli_ptr) 
9553 cd a6 96			call display_dump_at_hl 
9556			 
9556 18 50			jr .bpschk 
9558 fe 36		.bps7:  cp '6' 
955a 20 08			jr nz, .bps8b 
955c				 
955c				; display cur orig ptr 
955c 2a 3e ea			ld hl, (cli_origptr) 
955f cd a6 96			call display_dump_at_hl 
9562 18 44			jr .bpschk 
9564 fe 37		.bps8b:  cp '7' 
9566 20 08			jr nz, .bps9 
9568				 
9568				; display dsp 
9568 2a ee e9			ld hl, (cli_data_sp) 
956b cd a6 96			call display_dump_at_hl 
956e			 
956e 18 38			jr .bpschk 
9570 fe 39		.bps9:  cp '9' 
9572 20 05			jr nz, .bps8c 
9574				 
9574				; display SP 
9574			;	ld hl, sp 
9574 cd a6 96			call display_dump_at_hl 
9577			 
9577 18 2f			jr .bpschk 
9579 fe 38		.bps8c:  cp '8' 
957b 20 08			jr nz, .bps8d 
957d				 
957d				; display rsp 
957d 2a f2 e9			ld hl, (cli_ret_sp) 
9580 cd a6 96			call display_dump_at_hl 
9583			 
9583 18 23			jr .bpschk 
9585 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9587 20 05			jr nz, .bps8 
9589 cd 8d 98			call monitor 
958c			 
958c 18 1a			jr .bpschk 
958e fe 30		.bps8:  cp '0' 
9590 20 16			jr nz, .bpschk 
9592			 
9592 21 10 ed				ld hl, display_fb1 
9595 22 cc eb				ld (display_fb_active), hl 
9598 cd d1 8a				call update_display 
959b			 
959b				;ld a, (os_view_af) 
959b 2a a3 e2			ld hl, (os_view_hl) 
959e ed 5b a1 e2		ld de, (os_view_de) 
95a2 ed 4b 9f e2		ld bc, (os_view_bc) 
95a6 f1				pop af 
95a7 c9				ret 
95a8			 
95a8			.bpschk:   
95a8 cd f1 89			call delay1s 
95ab 3e 9f		ld a,display_row_4 + display_cols - 1 
95ad 11 bd 9a		        ld de, endprg 
95b0 cd c1 8a			call str_at_display 
95b3 cd d1 8a			call update_display 
95b6 cd cf e4			call cin_wait 
95b9			 
95b9 c3 0b 95			jp .bps1 
95bc			 
95bc			 
95bc			display_reg_state: 
95bc			 
95bc				; to restore afterwards 
95bc			 
95bc d5				push de 
95bd c5				push bc 
95be e5				push hl 
95bf f5				push af 
95c0			 
95c0				; for use in here 
95c0			 
95c0 c5				push bc 
95c1 d5				push de 
95c2 e5				push hl 
95c3 f5				push af 
95c4			 
95c4 cd ae 8a			call clear_display 
95c7			 
95c7 11 7c 96			ld de, .regstate 
95ca 3e 00			ld a, display_row_1 
95cc cd c1 8a			call str_at_display 
95cf			 
95cf				; display debug step 
95cf			 
95cf			 
95cf 11 6b ee			ld de, debug_mark 
95d2 3e 25			ld a, display_row_1+display_cols-3 
95d4 cd c1 8a			call str_at_display 
95d7			 
95d7				; display a 
95d7 11 98 96			ld de, .regstatea 
95da 3e 28			ld a, display_row_2 
95dc cd c1 8a			call str_at_display 
95df			 
95df e1				pop hl 
95e0			;	ld h,0 
95e0			;	ld l, a 
95e0 3e 2b			ld a, display_row_2+3 
95e2 cd 62 94			call display_word_at 
95e5			 
95e5			 
95e5				; display hl 
95e5			 
95e5			 
95e5 11 8c 96			ld de, .regstatehl 
95e8 3e 32			ld a, display_row_2+10 
95ea cd c1 8a			call str_at_display 
95ed			 
95ed e1				pop hl 
95ee 3e 35			ld a, display_row_2+13 
95f0 cd 62 94			call display_word_at 
95f3			 
95f3				 
95f3				; display de 
95f3			 
95f3 11 90 96			ld de, .regstatede 
95f6 3e 50			ld a, display_row_3 
95f8 cd c1 8a			call str_at_display 
95fb			 
95fb e1				pop hl 
95fc			;	ld h,d 
95fc			;	ld l, e 
95fc 3e 53			ld a, display_row_3+3 
95fe cd 62 94			call display_word_at 
9601			 
9601			 
9601				; display bc 
9601			 
9601 11 94 96			ld de, .regstatebc 
9604 3e 5a			ld a, display_row_3+10 
9606 cd c1 8a			call str_at_display 
9609			 
9609 e1				pop hl 
960a			;	ld h,b 
960a			;	ld l, c 
960a 3e 5d			ld a, display_row_3+13 
960c cd 62 94			call display_word_at 
960f			 
960f			 
960f				; display dsp 
960f			 
960f 11 9c 96			ld de, .regstatedsp 
9612 3e 78			ld a, display_row_4 
9614 cd c1 8a			call str_at_display 
9617			 
9617				 
9617 2a ee e9			ld hl,(cli_data_sp) 
961a 3e 7c			ld a, display_row_4+4 
961c cd 62 94			call display_word_at 
961f			 
961f				; display rsp 
961f			 
961f 11 a1 96			ld de, .regstatersp 
9622 3e 82			ld a, display_row_4+10 
9624 cd c1 8a			call str_at_display 
9627			 
9627				 
9627 2a f2 e9			ld hl,(cli_ret_sp) 
962a 3e 86			ld a, display_row_4+14 
962c cd 62 94			call display_word_at 
962f			 
962f cd d1 8a			call update_display 
9632			 
9632			;	call delay1s 
9632			;	call delay1s 
9632			;	call delay1s 
9632			 
9632			 
9632			;	call next_page_prompt 
9632			 
9632				; restore  
9632			 
9632 f1				pop af 
9633 e1				pop hl 
9634 c1				pop bc 
9635 d1				pop de 
9636 c9				ret 
9637			 
9637 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
964b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9660 .. 00		.ptrstate:	db "Ptr State",0 
966a .. 00		.ptrcliptr:     db "cli_ptr",0 
9672 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
967c .. 00		.regstate:	db "Reg State (1/0)",0 
968c .. 00		.regstatehl:	db "HL:",0 
9690 .. 00		.regstatede:	db "DE:",0 
9694 .. 00		.regstatebc:	db "BC:",0 
9698 .. 00		.regstatea:	db "A :",0 
969c .. 00		.regstatedsp:	db "DSP:",0 
96a1 .. 00		.regstatersp:	db "RSP:",0 
96a6			 
96a6			display_dump_at_hl: 
96a6 e5				push hl 
96a7 d5				push de 
96a8 c5				push bc 
96a9 f5				push af 
96aa			 
96aa 22 e4 e5			ld (os_cur_ptr),hl	 
96ad cd ae 8a			call clear_display 
96b0 cd c7 99			call dumpcont 
96b3			;	call delay1s 
96b3			;	call next_page_prompt 
96b3			 
96b3			 
96b3 f1				pop af 
96b4 c1				pop bc 
96b5 d1				pop de 
96b6 e1				pop hl 
96b7 c9				ret 
96b8			 
96b8			;if ENABLE_BASIC 
96b8			;	include "nascombasic.asm" 
96b8			;	basic: 
96b8			;	include "forth/FORTH.ASM" 
96b8			;endif 
96b8			 
96b8			; eof 
96b8			 
96b8			 
# End of file firmware_diags.asm
96b8			  
96b8			include "firmware_prompts.asm"  
96b8			; Prompts  
96b8			 
96b8			; boot messages 
96b8			 
96b8 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96cd .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96dd			 
96dd			 
96dd			; config menus 
96dd			 
96dd			;prom_c3: db "Add Dictionary To File",0 
96dd			 
96dd			if STARTUP_V1 
96dd .. 00		prom_c2: db "Select Autoload File",0 
96f2 .. 00		prom_c2a: db "Disable Autoload File", 0 
9708			endif 
9708			 
9708			if STARTUP_V2 
9708			prom_c2: db "Enable Autoload Files",0 
9708			prom_c2a: db "Disable Autoload Files", 0 
9708			 
9708			crs_s1: db "*ls-word", 0 
9708			crs_s2: db "*ed-word", 0 
9708			crs_s3: db "*Demo-Programs", 0 
9708			crs_s4: db "*Utils", 0 
9708			crs_s5: db "*SPI-Util", 0 
9708			crs_s6: db "*Key-constants", 0 
9708			crs_sound: db "*Sound-Util", 0 
9708			 
9708			 
9708			 
9708			endif 
9708			;prom_c2b: db "Select Storage Bank",0 
9708 .. 00		prom_c4: db "Settings",0 
9711 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
972c .. 00		prom_m4b:   db "Monitor",0 
9734 .. 00		prom_c1: db "Hardware Diags",0 
9743			 
9743			 
9743			if STARTUP_V2 
9743			prom_c9: db "Create Startup Files",0 
9743			endif 
9743			 
9743 .. 00		prom_notav:    db "Feature not available",0 
9759 .. 00		prom_empty:    db "",0 
975a			 
975a			; eof 
975a			 
# End of file firmware_prompts.asm
975a			  
975a			  
975a			; eof  
975a			  
# End of file firmware.asm
975a			 
975a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
975a			;if BASE_KEV  
975a			;baseram: equ 08000h 
975a			;endif 
975a			 
975a			;if BASE_SC114 
975a			;baseram:     equ    endofcode 
975a			;endif 
975a			 
975a			 
975a			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
975a			 
975a			; start system 
975a			 
975a			coldstart: 
975a				; set sp 
975a				; di/ei 
975a			 
975a f3				di 
975b 31 00 f0			ld sp, tos 
975e cd 19 e4			call init_nmi 
9761			;	ei 
9761			 
9761				; init spinner 
9761 3e 00			ld a,0 
9763 32 c6 eb			ld (display_active), a 
9766			 
9766				; disable breakpoint by default 
9766			 
9766				;ld a,'*' 
9766			;	ld a,' ' 
9766			;	ld (os_view_disable),a 
9766			 
9766				; set break point vector as new break point on or off 
9766 cd e9 94			call bp_off 
9769			 
9769				; init hardware 
9769			 
9769				; init keyboard and screen hardware 
9769			 
9769 cd 1b 80			call hardware_init 
976c			 
976c			 
976c cd f1 89			call delay1s 
976f 3e 58			ld a, display_row_3+8 
9771 11 03 80			ld de, buildtime 
9774 cd c1 8a			call str_at_display 
9777 cd d1 8a			call update_display 
977a			 
977a cd f1 89			call delay1s 
977d cd f1 89			call delay1s 
9780 cd f1 89			call delay1s 
9783			 
9783				; detect if any keys are held down to enable breakpoints at start up 
9783			 
9783 cd d5 e4			call cin  
9786 fe 00			cp 0 
9788 28 03			jr z, .nokeys 
978a			 
978a				;call hardware_diags 
978a cd 47 93			call config 
978d			 
978d			;	ld de, .bpen 
978d			;	ld a, display_row_4 
978d			;	call str_at_display 
978d			;	call update_display 
978d			; 
978d			;	ld a,0 
978d			;	ld (os_view_disable),a 
978d			; 
978d			;.bpwait: 
978d			;	call cin 
978d			;	cp 0 
978d			;	jr z, .bpwait 
978d			;	jr .nokeys 
978d			; 
978d			; 
978d			;.bpen:  db "Break points enabled!",0 
978d			 
978d			 
978d			 
978d			 
978d			 
978d			 
978d			.nokeys: 
978d			 
978d			 
978d				 
978d			 
978d			;jp  testkey 
978d			 
978d			;call storage_get_block_0 
978d			; 
978d			;ld hl, 0 
978d			;ld de, store_page 
978d			;call storage_read_block 
978d			 
978d				 
978d			;ld hl, 10 
978d			;ld de, store_page 
978d			;call storage_read_block 
978d			 
978d			 
978d			 
978d			 
978d			 
978d			;stop:	nop 
978d			;	jp stop 
978d			 
978d			 
978d			 
978d			main: 
978d cd ae 8a			call clear_display 
9790 cd d1 8a			call update_display 
9793			 
9793			 
9793			 
9793			;	call testlcd 
9793			 
9793			 
9793			 
9793 cd c4 9e			call forth_init 
9796			 
9796			 
9796			warmstart: 
9796 cd 9a 9e			call forth_warmstart 
9799			 
9799				; run startup word load 
9799			        ; TODO prevent this running at warmstart after crash  
9799			 
9799				if STARTUP_ENABLE 
9799			 
9799					if STARTUP_V1 
9799			 
9799						if STORAGE_SE 
9799							call forth_autoload 
9799						endif 
9799 cd 69 e3					call forth_startup 
979c					endif 
979c			 
979c					if STARTUP_V2 
979c			 
979c						if STORAGE_SE 
979c							call forth_autoload 
979c						else 
979c							call forth_startup 
979c						endif 
979c			 
979c			 
979c					endif 
979c			 
979c				endif 
979c			 
979c				; show free memory after boot 
979c 11 28 98			ld de, freeram 
979f 3e 00			ld a, display_row_1 
97a1 cd c1 8a			call str_at_display 
97a4			 
97a4				; get current heap start after loading any uwords 
97a4			 
97a4				;ld de, (os_last_new_uword) 
97a4				;ex de, hl 
97a4			 
97a4			; Or use heap_size word???? 
97a4				;ld hl, heap_end 
97a4				;ld hl, heap_size 
97a4				;ld de, topusermem 
97a4				;ld de, heap_start 
97a4 ed 5b ee e4			ld de, (free_list )      
97a8 21 9c e2				ld hl, heap_end 
97ab ed 52			sbc hl, de 
97ad				;push hl 
97ad				;ld a,h	         	 
97ad				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97ad				;call hexout 
97ad			   	;pop hl 
97ad			; 
97ad			;	ld a,l 
97ad			;	ld hl, os_word_scratch+2 
97ad			;	call hexout 
97ad			;	ld hl, os_word_scratch+4 
97ad			;	ld a, 0 
97ad			;	ld (hl),a 
97ad eb				ex de, hl 
97ae 21 c6 e5			ld hl, os_word_scratch 
97b1 cd e8 90			call uitoa_16 
97b4			 
97b4			 
97b4 11 c6 e5			ld de, os_word_scratch 
97b7 3e 0d			ld a, display_row_1 + 13 
97b9 cd c1 8a			call str_at_display 
97bc cd d1 8a			call update_display 
97bf			 
97bf			 
97bf				;call demo 
97bf			 
97bf			 
97bf				; init scratch input area for cli commands 
97bf			 
97bf 21 e8 e5			ld hl, os_cli_cmd 
97c2 3e 00			ld a,0 
97c4 77				ld (hl),a 
97c5 23				inc hl 
97c6 77				ld (hl),a 
97c7			 
97c7 3e 00			ld a,0 
97c9 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97cc			 
97cc 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97cf 32 e5 e5			ld (os_cur_ptr+1),a	 
97d2			 
97d2 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97d5 32 c7 e5			ld (os_word_scratch+1),a	 
97d8				 
97d8			 
97d8				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d8 21 e8 e5			ld hl, os_cli_cmd 
97db			 
97db 3e 00			ld a, 0		 ; init cli input 
97dd 77				ld (hl), a 
97de 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97e0			cli: 
97e0				; show cli prompt 
97e0				;push af 
97e0				;ld a, 0 
97e0				;ld de, prompt 
97e0				;call str_at_display 
97e0			 
97e0				;call update_display 
97e0				;pop af 
97e0				;inc a 
97e0				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97e0 0e 00			ld c, 0 
97e2 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97e4 1e 28			ld e, 40 
97e6			 
97e6 21 e8 e5			ld hl, os_cli_cmd 
97e9			 
97e9				STACKFRAME OFF $fefe $9f9f 
97e9				if DEBUG_STACK_IMB 
97e9					if OFF 
97e9						exx 
97e9						ld de, $fefe 
97e9						ld a, d 
97e9						ld hl, curframe 
97e9						call hexout 
97e9						ld a, e 
97e9						ld hl, curframe+2 
97e9						call hexout 
97e9						ld hl, $fefe 
97e9						push hl 
97e9						ld hl, $9f9f 
97e9						push hl 
97e9						exx 
97e9					endif 
97e9				endif 
97e9			endm 
# End of macro STACKFRAME
97e9			 
97e9 cd 08 8d			call input_str 
97ec			 
97ec				STACKFRAMECHK OFF $fefe $9f9f 
97ec				if DEBUG_STACK_IMB 
97ec					if OFF 
97ec						exx 
97ec						ld hl, $9f9f 
97ec						pop de   ; $9f9f 
97ec						call cmp16 
97ec						jr nz, .spnosame 
97ec						ld hl, $fefe 
97ec						pop de   ; $fefe 
97ec						call cmp16 
97ec						jr z, .spfrsame 
97ec						.spnosame: call showsperror 
97ec						.spfrsame: nop 
97ec						exx 
97ec					endif 
97ec				endif 
97ec			endm 
# End of macro STACKFRAMECHK
97ec			 
97ec				; copy input to last command 
97ec			 
97ec 21 e8 e5			ld hl, os_cli_cmd 
97ef 11 e7 e6			ld de, os_last_cmd 
97f2 01 ff 00			ld bc, 255 
97f5 ed b0			ldir 
97f7			 
97f7				; wipe current buffer 
97f7			 
97f7			;	ld a, 0 
97f7			;	ld hl, os_cli_cmd 
97f7			;	ld de, os_cli_cmd+1 
97f7			;	ld bc, 254 
97f7			;	ldir 
97f7				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97f7			;	call strcpy 
97f7			;	ld a, 0 
97f7			;	ld (hl), a 
97f7			;	inc hl 
97f7			;	ld (hl), a 
97f7			;	inc hl 
97f7			;	ld (hl), a 
97f7			 
97f7				; switch frame buffer to program  
97f7			 
97f7 21 10 ed				ld hl, display_fb1 
97fa 22 cc eb				ld (display_fb_active), hl 
97fd			 
97fd			;	nop 
97fd				STACKFRAME ON $fbfe $8f9f 
97fd				if DEBUG_STACK_IMB 
97fd					if ON 
97fd						exx 
97fd						ld de, $fbfe 
97fd						ld a, d 
97fd						ld hl, curframe 
97fd						call hexout 
97fd						ld a, e 
97fd						ld hl, curframe+2 
97fd						call hexout 
97fd						ld hl, $fbfe 
97fd						push hl 
97fd						ld hl, $8f9f 
97fd						push hl 
97fd						exx 
97fd					endif 
97fd				endif 
97fd			endm 
# End of macro STACKFRAME
97fd				; first time into the parser so pass over the current scratch pad 
97fd 21 e8 e5			ld hl,os_cli_cmd 
9800				; tokenise the entered statement(s) in HL 
9800 cd 42 9f			call forthparse 
9803			        ; exec forth statements in top of return stack 
9803 cd 82 9f			call forthexec 
9806				;call forthexec_cleanup 
9806			;	call parsenext 
9806			 
9806				STACKFRAMECHK ON $fbfe $8f9f 
9806				if DEBUG_STACK_IMB 
9806					if ON 
9806						exx 
9806						ld hl, $8f9f 
9806						pop de   ; $8f9f 
9806						call cmp16 
9806						jr nz, .spnosame 
9806						ld hl, $fbfe 
9806						pop de   ; $fbfe 
9806						call cmp16 
9806						jr z, .spfrsame 
9806						.spnosame: call showsperror 
9806						.spfrsame: nop 
9806						exx 
9806					endif 
9806				endif 
9806			endm 
# End of macro STACKFRAMECHK
9806				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9806			 
9806 3e 78			ld a, display_row_4 
9808 11 39 98			ld de, endprog 
980b			 
980b cd d1 8a			call update_display		 
980e			 
980e cd bf 9a			call next_page_prompt 
9811			 
9811				; switch frame buffer to cli 
9811			 
9811 21 b1 ed				ld hl, display_fb0 
9814 22 cc eb				ld (display_fb_active), hl 
9817			 
9817			 
9817 cd ae 8a		        call clear_display 
981a cd d1 8a			call update_display		 
981d			 
981d 21 e8 e5			ld hl, os_cli_cmd 
9820			 
9820 3e 00			ld a, 0		 ; init cli input 
9822 77				ld (hl), a 
9823			 
9823				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9823			 
9823				; now on last line 
9823			 
9823				; TODO scroll screen up 
9823			 
9823				; TODO instead just clear screen and place at top of screen 
9823			 
9823			;	ld a, 0 
9823			;	ld (f_cursor_ptr),a 
9823			 
9823				;call clear_display 
9823				;call update_display 
9823			 
9823				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9823 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9825 c3 e0 97			jp cli 
9828			 
9828 .. 00		freeram: db "Free bytes: ",0 
9835 ..			asc: db "1A2F" 
9839 .. 00		endprog: db "End prog...",0 
9845			 
9845			testenter2:   
9845 21 f3 e2			ld hl,scratch+50 
9848 22 e4 e5			ld (os_cur_ptr),hl 
984b c3 e0 97			jp cli 
984e			 
984e			testenter:  
984e			 
984e 21 35 98			ld hl,asc 
9851			;	ld a,(hl) 
9851			;	call nibble2val 
9851 cd 32 90			call get_byte 
9854			 
9854			 
9854			;	ld a,(hl) 
9854			;	call atohex 
9854			 
9854			;	call fourehexhl 
9854 32 f3 e2			ld (scratch+50),a 
9857			 
9857			 
9857			 
9857 21 37 98			ld hl,asc+2 
985a			;	ld a, (hl) 
985a			;	call nibble2val 
985a cd 32 90			call get_byte 
985d			 
985d			;	call fourehexhl 
985d 32 f5 e2			ld (scratch+52),a 
9860				 
9860 21 f3 e2			ld hl,scratch+50 
9863 22 e4 e5			ld (os_cur_ptr),hl 
9866 c3 e0 97			jp cli 
9869			 
9869			enter:	 
9869 3a c5 e2			ld a,(scratch+4) 
986c fe 00			cp 0 
986e 28 0c			jr z, .entercont 
9870				; no, not a null term line so has an address to work out.... 
9870			 
9870 21 c3 e2			ld hl,scratch+2 
9873 cd 92 90			call get_word_hl 
9876			 
9876 22 e4 e5			ld (os_cur_ptr),hl	 
9879 c3 e0 97			jp cli 
987c			 
987c			 
987c			.entercont:  
987c			 
987c 21 c3 e2			ld hl, scratch+2 
987f cd 32 90			call get_byte 
9882			 
9882 2a e4 e5		   	ld hl,(os_cur_ptr) 
9885 77					ld (hl),a 
9886 23					inc hl 
9887 22 e4 e5				ld (os_cur_ptr),hl 
988a				 
988a			; get byte  
988a			 
988a			 
988a c3 e0 97			jp cli 
988d			 
988d			 
988d			; basic monitor support 
988d			 
988d			monitor: 
988d				;  
988d cd ae 8a			call clear_display 
9890 3e 00			ld a, 0 
9892 11 e1 98			ld de, .monprompt 
9895 cd c1 8a			call str_at_display 
9898 cd d1 8a			call update_display 
989b			 
989b				; get a monitor command 
989b			 
989b 0e 00			ld c, 0     ; entry at top left 
989d 16 64			ld d, 100   ; max buffer size 
989f 1e 0f			ld e, 15    ; input scroll area 
98a1 3e 00			ld a, 0     ; init string 
98a3 21 bf e4			ld hl, os_input 
98a6 77				ld (hl), a 
98a7 23				inc hl 
98a8 77				ld (hl), a 
98a9 21 bf e4			ld hl, os_input 
98ac 3e 01			ld a, 1     ; init string 
98ae cd 08 8d			call input_str 
98b1			 
98b1 cd ae 8a		        call clear_display 
98b4 cd d1 8a			call update_display		 
98b7			 
98b7 3a bf e4			ld a, (os_input) 
98ba cd 30 91			call toUpper 
98bd fe 48		        cp 'H' 
98bf ca 46 99		        jp z, .monhelp 
98c2 fe 44			cp 'D'		; dump 
98c4 ca 79 99			jp z, .mondump	 
98c7 fe 43			cp 'C'		; dump 
98c9 ca 93 99			jp z, .moncdump	 
98cc fe 4d			cp 'M'		; dump 
98ce ca e3 98			jp z, .moneditstart 
98d1 fe 55			cp 'U'		; dump 
98d3 ca ef 98			jp z, .monedit	 
98d6 fe 47			cp 'G'		; dump 
98d8 ca 6f 99			jp z, .monjump 
98db fe 51			cp 'Q'		; dump 
98dd c8				ret z	 
98de			 
98de			 
98de				; TODO "S" to access symbol by name and not need the address 
98de				; TODO "F" to find a string in memory 
98de			 
98de c3 8d 98			jp monitor 
98e1			 
98e1 .. 00		.monprompt: db ">", 0 
98e3			 
98e3			.moneditstart: 
98e3				; get starting address 
98e3			 
98e3 21 c1 e4			ld hl,os_input+2 
98e6 cd 92 90			call get_word_hl 
98e9			 
98e9 22 e4 e5			ld (os_cur_ptr),hl	 
98ec			 
98ec c3 8d 98			jp monitor 
98ef			 
98ef			.monedit: 
98ef				; get byte to load 
98ef			 
98ef 21 c1 e4			ld hl,os_input+2 
98f2 cd 32 90			call get_byte 
98f5			 
98f5				; get address to update 
98f5 2a e4 e5			ld hl, (os_cur_ptr) 
98f8			 
98f8				; update byte 
98f8			 
98f8 77				ld (hl), a 
98f9			 
98f9				; move to next address and save it 
98f9			 
98f9 23				inc hl 
98fa 22 e4 e5			ld (os_cur_ptr),hl	 
98fd			 
98fd c3 8d 98			jp monitor 
9900			 
9900			 
9900 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9914 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9930 .. 00		.monhelptext3:  db "G-Call address",0 
993f .. 00		.monhelptext4:  db "Q-Quit",0 
9946			        
9946			.monhelp: 
9946 3e 00			ld a, display_row_1 
9948 11 00 99		        ld de, .monhelptext1 
994b			 
994b cd c1 8a			call str_at_display 
994e 3e 28			ld a, display_row_2 
9950 11 14 99		        ld de, .monhelptext2 
9953					 
9953 cd c1 8a			call str_at_display 
9956 3e 50			ld a, display_row_3 
9958 11 30 99		        ld de, .monhelptext3 
995b					 
995b cd c1 8a			call str_at_display 
995e 3e 78			ld a, display_row_4 
9960 11 3f 99		        ld de, .monhelptext4 
9963 cd c1 8a			call str_at_display 
9966			 
9966 cd d1 8a			call update_display		 
9969			 
9969 cd bf 9a			call next_page_prompt 
996c c3 8d 98			jp monitor 
996f			 
996f			.monjump:    
996f 21 c1 e4			ld hl,os_input+2 
9972 cd 92 90			call get_word_hl 
9975			 
9975 e9				jp (hl) 
9976 c3 8d 98			jp monitor 
9979			 
9979			.mondump:    
9979 21 c1 e4			ld hl,os_input+2 
997c cd 92 90			call get_word_hl 
997f			 
997f 22 e4 e5			ld (os_cur_ptr),hl	 
9982 cd c7 99			call dumpcont 
9985 3e 78			ld a, display_row_4 
9987 11 39 98			ld de, endprog 
998a			 
998a cd d1 8a			call update_display		 
998d			 
998d cd bf 9a			call next_page_prompt 
9990 c3 8d 98			jp monitor 
9993			.moncdump: 
9993 cd c7 99			call dumpcont 
9996 3e 78			ld a, display_row_4 
9998 11 39 98			ld de, endprog 
999b			 
999b cd d1 8a			call update_display		 
999e			 
999e cd bf 9a			call next_page_prompt 
99a1 c3 8d 98			jp monitor 
99a4			 
99a4			 
99a4			; TODO symbol access  
99a4			 
99a4			.symbols:     ;; A list of symbols that can be called up  
99a4 b1 ed			dw display_fb0 
99a6 .. 00			db "fb0",0  
99aa 7a ea		     	dw store_page 
99ac .. 00			db "store_page",0 
99b7			 
99b7			 
99b7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99b7			 
99b7 3a c2 e2			ld a,(scratch+1) 
99ba fe 00			cp 0 
99bc 28 09			jr z, dumpcont 
99be			 
99be				; no, not a null term line so has an address to work out.... 
99be			 
99be 21 c3 e2			ld hl,scratch+2 
99c1 cd 92 90			call get_word_hl 
99c4			 
99c4 22 e4 e5			ld (os_cur_ptr),hl	 
99c7			 
99c7			 
99c7			 
99c7			dumpcont: 
99c7			 
99c7				; dump bytes at ptr 
99c7			 
99c7			 
99c7 3e 00			ld a, display_row_1 
99c9 2a cc eb			ld hl, (display_fb_active) 
99cc cd db 8c			call addatohl 
99cf cd f7 99			call .dumpbyterow 
99d2			 
99d2 3e 28			ld a, display_row_2 
99d4 2a cc eb			ld hl, (display_fb_active) 
99d7 cd db 8c			call addatohl 
99da cd f7 99			call .dumpbyterow 
99dd			 
99dd			 
99dd 3e 50			ld a, display_row_3 
99df 2a cc eb			ld hl, (display_fb_active) 
99e2 cd db 8c			call addatohl 
99e5 cd f7 99			call .dumpbyterow 
99e8			 
99e8 3e 78			ld a, display_row_4 
99ea 2a cc eb			ld hl, (display_fb_active) 
99ed cd db 8c			call addatohl 
99f0 cd f7 99			call .dumpbyterow 
99f3			 
99f3 cd d1 8a			call update_display 
99f6			;		jp cli 
99f6 c9				ret 
99f7			 
99f7			.dumpbyterow: 
99f7			 
99f7				;push af 
99f7			 
99f7 e5				push hl 
99f8			 
99f8				; calc where to poke the ascii 
99f8			if display_cols == 20 
99f8				ld a, 16 
99f8			else 
99f8 3e 1f			ld a, 31 
99fa			endif 
99fa			 
99fa cd db 8c			call addatohl 
99fd 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9a00			 
9a00			 
9a00			; display decoding address 
9a00 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a03			 
9a03 7c				ld a,h 
9a04 e1				pop hl 
9a05 e5				push hl 
9a06			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9a06 cd dc 8f			call hexout 
9a09 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a0c			 
9a0c 7d				ld a,l 
9a0d e1				pop hl 
9a0e 23				inc hl 
9a0f 23				inc hl 
9a10 e5				push hl 
9a11			;	ld hl, os_word_scratch+2 
9a11 cd dc 8f			call hexout 
9a14 e1				pop hl 
9a15 23				inc hl 
9a16 23				inc hl 
9a17				;ld hl, os_word_scratch+4 
9a17 3e 3a			ld a, ':' 
9a19 77				ld (hl),a 
9a1a 23				inc hl 
9a1b				;ld a, 0 
9a1b				;ld (hl),a 
9a1b				;ld de, os_word_scratch 
9a1b				;pop af 
9a1b				;push af 
9a1b			;		ld a, display_row_2 
9a1b			;		call str_at_display 
9a1b			;		call update_display 
9a1b			 
9a1b			 
9a1b			;pop af 
9a1b			;	add 5 
9a1b			 
9a1b			if display_cols == 20 
9a1b				ld b, 4 
9a1b			else 
9a1b 06 08			ld b, 8 
9a1d			endif	 
9a1d			 
9a1d			.dumpbyte: 
9a1d c5				push bc 
9a1e e5				push hl 
9a1f			 
9a1f			 
9a1f 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a22 7e					ld a,(hl) 
9a23			 
9a23					; poke the ascii to display 
9a23 2a c6 e5				ld hl,(os_word_scratch) 
9a26 77					ld (hl),a 
9a27 23					inc hl 
9a28 22 c6 e5				ld (os_word_scratch),hl 
9a2b			 
9a2b					 
9a2b			 
9a2b			 
9a2b e1					pop hl 
9a2c e5					push hl 
9a2d			 
9a2d cd dc 8f				call hexout 
9a30			 
9a30					 
9a30 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a33 23				inc hl 
9a34 22 e4 e5		   	ld (os_cur_ptr),hl 
9a37			 
9a37 e1					pop hl 
9a38 23					inc hl 
9a39 23					inc hl 
9a3a 23					inc hl 
9a3b			 
9a3b			 
9a3b			 
9a3b					;ld a,0 
9a3b					;ld (os_word_scratch+2),a 
9a3b					;pop af 
9a3b					;push af 
9a3b			 
9a3b					;ld de, os_word_scratch 
9a3b					;call str_at_display 
9a3b			;		call update_display 
9a3b			;		pop af 
9a3b c1					pop bc 
9a3c c6 03				add 3 
9a3e 10 dd			djnz .dumpbyte 
9a40			 
9a40				 
9a40			 
9a40 c9				ret 
9a41			 
9a41			jump:	 
9a41			 
9a41 21 c3 e2			ld hl,scratch+2 
9a44 cd 92 90			call get_word_hl 
9a47				;ld hl,(scratch+2) 
9a47				;call fourehexhl 
9a47			 
9a47 22 e4 e5			ld (os_cur_ptr),hl	 
9a4a			 
9a4a e9				jp (hl) 
9a4b			 
9a4b			 
9a4b			 
9a4b			; TODO implement a basic monitor mode to start with 
9a4b			 
9a4b			 
9a4b			 
9a4b			 
9a4b			 
9a4b			 
9a4b			 
9a4b			 
9a4b			 
9a4b			; testing and demo code during development 
9a4b			 
9a4b			 
9a4b .. 00		str1: db "Enter some text...",0 
9a5e .. 00		clear: db "                    ",0 
9a73			 
9a73			demo: 
9a73			 
9a73			 
9a73			 
9a73			;	call update_display 
9a73			 
9a73				; init scratch input area for testing 
9a73 21 c1 e2			ld hl, scratch	 
9a76 3e 00			ld a,0 
9a78 77				ld (hl),a 
9a79			 
9a79			 
9a79 3e 28		            LD   A, display_row_2 
9a7b			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a7b 11 4b 9a		            LD   DE, str1 
9a7e cd c1 8a			call str_at_display 
9a81			 
9a81			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a81			cloop:	 
9a81 3e 50		            LD   A, display_row_3 
9a83			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a83 11 5e 9a		            LD   DE, clear 
9a86			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a86 cd c1 8a				call str_at_display 
9a89 3e 78			ld a, display_row_4 
9a8b 11 bb 9a			ld de, prompt 
9a8e			 
9a8e cd c1 8a				call str_at_display 
9a91 cd d1 8a			call update_display 
9a94			 
9a94 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a96 16 0a			ld d, 10 
9a98 21 c1 e2			ld hl, scratch	 
9a9b cd 08 8d			call input_str 
9a9e			 
9a9e			;	call clear_display 
9a9e			;'	call update_display 
9a9e			 
9a9e 3e 00		            LD   A, display_row_1 
9aa0			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aa0 11 5e 9a		            LD   DE, clear 
9aa3 cd c1 8a				call str_at_display 
9aa6			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aa6 3e 00		            LD   A, display_row_1 
9aa8			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aa8 11 c1 e2		            LD   DE, scratch 
9aab			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aab cd c1 8a				call str_at_display 
9aae cd d1 8a			call update_display 
9ab1			 
9ab1 3e 00				ld a,0 
9ab3 21 c1 e2			ld hl, scratch 
9ab6 77				ld (hl),a 
9ab7			 
9ab7 00				nop 
9ab8 c3 81 9a			jp cloop 
9abb			 
9abb			 
9abb			 
9abb			; OS Prompt 
9abb			 
9abb .. 00		prompt: db ">",0 
9abd .. 00		endprg: db "?",0 
9abf			 
9abf			 
9abf			; handy next page prompt 
9abf			next_page_prompt: 
9abf e5				push hl 
9ac0 d5				push de 
9ac1 f5				push af 
9ac2 c5				push bc 
9ac3			 
9ac3 3e 9f			ld a,display_row_4 + display_cols - 1 
9ac5 11 bd 9a		        ld de, endprg 
9ac8 cd c1 8a			call str_at_display 
9acb cd d1 8a			call update_display 
9ace cd cf e4			call cin_wait 
9ad1 c1				pop bc 
9ad2 f1				pop af 
9ad3 d1				pop de 
9ad4 e1				pop hl 
9ad5			 
9ad5			 
9ad5 c9				ret 
9ad6			 
9ad6			 
9ad6			; forth parser 
9ad6			 
9ad6			; My forth kernel 
9ad6			include "forth_kernel.asm" 
9ad6			; 
9ad6			; kernel to the forth OS 
9ad6			 
9ad6			DS_TYPE_STR: equ 1     ; string type 
9ad6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9ad6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9ad6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9ad6			 
9ad6			FORTH_PARSEV1: equ 0 
9ad6			FORTH_PARSEV2: equ 0 
9ad6			FORTH_PARSEV3: equ 0 
9ad6			FORTH_PARSEV4: equ 0 
9ad6			FORTH_PARSEV5: equ 1 
9ad6			 
9ad6			;if FORTH_PARSEV5 
9ad6			;	FORTH_END_BUFFER: equ 0 
9ad6			;else 
9ad6			FORTH_END_BUFFER: equ 127 
9ad6			;endif 
9ad6			 
9ad6			FORTH_TRUE: equ 1 
9ad6			FORTH_FALSE: equ 0 
9ad6			 
9ad6			if FORTH_PARSEV4 
9ad6			include "forth_stackops.asm" 
9ad6			endif 
9ad6			 
9ad6			if FORTH_PARSEV5 
9ad6			include "forth_stackopsv5.asm" 
9ad6			 
9ad6			; Stack operations for v5 parser on wards 
9ad6			; * DATA stack 
9ad6			; * LOOP stack 
9ad6			; * RETURN stack 
9ad6			 
9ad6			 
9ad6			 
9ad6			FORTH_CHK_DSP_UNDER: macro 
9ad6				push hl 
9ad6				push de 
9ad6				ld hl,(cli_data_sp) 
9ad6				ld de, cli_data_stack 
9ad6				call cmp16 
9ad6				jp c, fault_dsp_under 
9ad6				pop de 
9ad6				pop hl 
9ad6				endm 
9ad6			 
9ad6			 
9ad6			FORTH_CHK_RSP_UNDER: macro 
9ad6				push hl 
9ad6				push de 
9ad6				ld hl,(cli_ret_sp) 
9ad6				ld de, cli_ret_stack 
9ad6				call cmp16 
9ad6				jp c, fault_rsp_under 
9ad6				pop de 
9ad6				pop hl 
9ad6				endm 
9ad6			 
9ad6			FORTH_CHK_LOOP_UNDER: macro 
9ad6				push hl 
9ad6				push de 
9ad6				ld hl,(cli_loop_sp) 
9ad6				ld de, cli_loop_stack 
9ad6				call cmp16 
9ad6				jp c, fault_loop_under 
9ad6				pop de 
9ad6				pop hl 
9ad6				endm 
9ad6			 
9ad6			FORTH_ERR_TOS_NOTSTR: macro 
9ad6				; TOSO might need more for checks when used 
9ad6				push af 
9ad6				ld a,(hl) 
9ad6				cp DS_TYPE_STR 
9ad6				jp nz, type_faultn   
9ad6				pop af 
9ad6				endm 
9ad6			 
9ad6			FORTH_ERR_TOS_NOTNUM: macro 
9ad6				push af 
9ad6				ld a,(hl) 
9ad6				cp DS_TYPE_INUM 
9ad6				jp nz, type_faultn   
9ad6				pop af 
9ad6				endm 
9ad6			 
9ad6			 
9ad6			; increase data stack pointer and save hl to it 
9ad6				 
9ad6			FORTH_DSP_NEXT: macro 
9ad6				call macro_forth_dsp_next 
9ad6				endm 
9ad6			 
9ad6			 
9ad6			macro_forth_dsp_next: 
9ad6				if DEBUG_FORTH_STACK_GUARD 
9ad6 cd 4a e1				call check_stacks 
9ad9				endif 
9ad9 e5				push hl 
9ada d5				push de 
9adb eb				ex de,hl 
9adc 2a ee e9			ld hl,(cli_data_sp) 
9adf 23				inc hl 
9ae0 23				inc hl 
9ae1			 
9ae1			; PARSEV5 
9ae1 23				inc hl 
9ae2 22 ee e9			ld (cli_data_sp),hl 
9ae5 73				ld (hl), e 
9ae6 23				inc hl 
9ae7 72				ld (hl), d 
9ae8 d1				pop de 
9ae9 e1				pop hl 
9aea				if DEBUG_FORTH_STACK_GUARD 
9aea cd 4a e1				call check_stacks 
9aed				endif 
9aed c9				ret 
9aee			 
9aee			 
9aee			; increase ret stack pointer and save hl to it 
9aee				 
9aee			FORTH_RSP_NEXT: macro 
9aee				call macro_forth_rsp_next 
9aee				endm 
9aee			 
9aee			macro_forth_rsp_next: 
9aee				if DEBUG_FORTH_STACK_GUARD 
9aee cd 4a e1				call check_stacks 
9af1				endif 
9af1 e5				push hl 
9af2 d5				push de 
9af3 eb				ex de,hl 
9af4 2a f2 e9			ld hl,(cli_ret_sp) 
9af7 23				inc hl 
9af8 23				inc hl 
9af9 22 f2 e9			ld (cli_ret_sp),hl 
9afc 73				ld (hl), e 
9afd 23				inc hl 
9afe 72				ld (hl), d 
9aff d1				pop de 
9b00 e1				pop hl 
9b01				if DEBUG_FORTH_STACK_GUARD 
9b01 cd 4a e1				call check_stacks 
9b04				endif 
9b04 c9				ret 
9b05			 
9b05			; get current ret stack pointer and save to hl  
9b05				 
9b05			FORTH_RSP_TOS: macro 
9b05				call macro_forth_rsp_tos 
9b05				endm 
9b05			 
9b05			macro_forth_rsp_tos: 
9b05				;push de 
9b05 2a f2 e9			ld hl,(cli_ret_sp) 
9b08 cd 40 9b			call loadhlptrtohl 
9b0b				;ld e, (hl) 
9b0b				;inc hl 
9b0b				;ld d, (hl) 
9b0b				;ex de, hl 
9b0b					if DEBUG_FORTH_WORDS 
9b0b			;			DMARK "RST" 
9b0b						CALLMONITOR 
9b0b cd 6f ee			call debug_vector  
9b0e				endm  
# End of macro CALLMONITOR
9b0e					endif 
9b0e				;pop de 
9b0e c9				ret 
9b0f			 
9b0f			; pop ret stack pointer 
9b0f				 
9b0f			FORTH_RSP_POP: macro 
9b0f				call macro_forth_rsp_pop 
9b0f				endm 
9b0f			 
9b0f			 
9b0f			macro_forth_rsp_pop: 
9b0f				if DEBUG_FORTH_STACK_GUARD 
9b0f			;		DMARK "RPP" 
9b0f cd 4a e1				call check_stacks 
9b12					FORTH_CHK_RSP_UNDER 
9b12 e5				push hl 
9b13 d5				push de 
9b14 2a f2 e9			ld hl,(cli_ret_sp) 
9b17 11 ac e9			ld de, cli_ret_stack 
9b1a cd f9 8c			call cmp16 
9b1d da 5e e2			jp c, fault_rsp_under 
9b20 d1				pop de 
9b21 e1				pop hl 
9b22				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b22				endif 
9b22 e5				push hl 
9b23 2a f2 e9			ld hl,(cli_ret_sp) 
9b26			 
9b26			 
9b26				if FORTH_ENABLE_FREE 
9b26			 
9b26					; get pointer 
9b26			 
9b26					push de 
9b26					push hl 
9b26			 
9b26					ld e, (hl) 
9b26					inc hl 
9b26					ld d, (hl) 
9b26			 
9b26					ex de, hl 
9b26					call free 
9b26			 
9b26					pop hl 
9b26					pop de 
9b26			 
9b26			 
9b26				endif 
9b26			 
9b26			 
9b26 2b				dec hl 
9b27 2b				dec hl 
9b28 22 f2 e9			ld (cli_ret_sp), hl 
9b2b				; do stack underflow checks 
9b2b e1				pop hl 
9b2c				if DEBUG_FORTH_STACK_GUARD 
9b2c cd 4a e1				call check_stacks 
9b2f					FORTH_CHK_RSP_UNDER 
9b2f e5				push hl 
9b30 d5				push de 
9b31 2a f2 e9			ld hl,(cli_ret_sp) 
9b34 11 ac e9			ld de, cli_ret_stack 
9b37 cd f9 8c			call cmp16 
9b3a da 5e e2			jp c, fault_rsp_under 
9b3d d1				pop de 
9b3e e1				pop hl 
9b3f				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b3f				endif 
9b3f c9				ret 
9b40			 
9b40			 
9b40			 
9b40			; routine to load word pointed to by hl into hl 
9b40			 
9b40			loadhlptrtohl: 
9b40			 
9b40 d5				push de 
9b41 5e				ld e, (hl) 
9b42 23				inc hl 
9b43 56				ld d, (hl) 
9b44 eb				ex de, hl 
9b45 d1				pop de 
9b46			 
9b46 c9				ret 
9b47			 
9b47			 
9b47			 
9b47			 
9b47			 
9b47			; push a number held in HL onto the data stack 
9b47			; entry point for pushing a value when already in hl used in function above 
9b47			 
9b47			forth_push_numhl: 
9b47			 
9b47 e5				push hl    ; save value to push 
9b48			 
9b48			if DEBUG_FORTH_PUSH 
9b48				; see if disabled 
9b48			 
9b48			 
9b48 f5				push af 
9b49 3a 6f ee			ld a,(debug_vector) 
9b4c fe c9			cp $c9   ; ret 
9b4e			;	ld a, (os_view_disable) 
9b4e			;	cp '*' 
9b4e 28 34			jr z, .pskip2 
9b50 e5				push hl 
9b51 e5			push hl 
9b52 cd ae 8a			call clear_display 
9b55 e1			pop hl 
9b56 7c				ld a,h 
9b57 21 c6 e5			ld hl, os_word_scratch 
9b5a cd dc 8f			call hexout 
9b5d e1				pop hl 
9b5e 7d				ld a,l 
9b5f 21 c8 e5			ld hl, os_word_scratch+2 
9b62 cd dc 8f			call hexout 
9b65			 
9b65 21 ca e5			ld hl, os_word_scratch+4 
9b68 3e 00			ld a,0 
9b6a 77				ld (hl),a 
9b6b 11 c6 e5			ld de,os_word_scratch 
9b6e 3e 28				ld a, display_row_2 
9b70 cd c1 8a				call str_at_display 
9b73 11 5c cc			ld de, .push_num 
9b76 3e 00			ld a, display_row_1 
9b78			 
9b78 cd c1 8a				call str_at_display 
9b7b			 
9b7b			 
9b7b cd d1 8a			call update_display 
9b7e cd f1 89			call delay1s 
9b81 cd f1 89			call delay1s 
9b84			.pskip2:  
9b84			 
9b84 f1				pop af 
9b85			endif	 
9b85			 
9b85			 
9b85				FORTH_DSP_NEXT 
9b85 cd d6 9a			call macro_forth_dsp_next 
9b88				endm 
# End of macro FORTH_DSP_NEXT
9b88			 
9b88 2a ee e9			ld hl, (cli_data_sp) 
9b8b			 
9b8b				; save item type 
9b8b 3e 02			ld a,  DS_TYPE_INUM 
9b8d 77				ld (hl), a 
9b8e 23				inc hl 
9b8f			 
9b8f				; get word off stack 
9b8f d1				pop de 
9b90 7b				ld a,e 
9b91 77				ld (hl), a 
9b92 23				inc hl 
9b93 7a				ld a,d 
9b94 77				ld (hl), a 
9b95			 
9b95			if DEBUG_FORTH_PUSH 
9b95 2b				dec hl 
9b96 2b				dec hl 
9b97 2b				dec hl 
9b98						DMARK "PH5" 
9b98 f5				push af  
9b99 3a ad 9b			ld a, (.dmark)  
9b9c 32 6b ee			ld (debug_mark),a  
9b9f 3a ae 9b			ld a, (.dmark+1)  
9ba2 32 6c ee			ld (debug_mark+1),a  
9ba5 3a af 9b			ld a, (.dmark+2)  
9ba8 32 6d ee			ld (debug_mark+2),a  
9bab 18 03			jr .pastdmark  
9bad ..			.dmark: db "PH5"  
9bb0 f1			.pastdmark: pop af  
9bb1			endm  
# End of macro DMARK
9bb1				CALLMONITOR 
9bb1 cd 6f ee			call debug_vector  
9bb4				endm  
# End of macro CALLMONITOR
9bb4			endif	 
9bb4			 
9bb4 c9				ret 
9bb5			 
9bb5			 
9bb5			; Push a string to stack pointed to by hl 
9bb5			 
9bb5			forth_push_str: 
9bb5			 
9bb5			if DEBUG_FORTH_PUSH 
9bb5						DMARK "PSQ" 
9bb5 f5				push af  
9bb6 3a ca 9b			ld a, (.dmark)  
9bb9 32 6b ee			ld (debug_mark),a  
9bbc 3a cb 9b			ld a, (.dmark+1)  
9bbf 32 6c ee			ld (debug_mark+1),a  
9bc2 3a cc 9b			ld a, (.dmark+2)  
9bc5 32 6d ee			ld (debug_mark+2),a  
9bc8 18 03			jr .pastdmark  
9bca ..			.dmark: db "PSQ"  
9bcd f1			.pastdmark: pop af  
9bce			endm  
# End of macro DMARK
9bce				CALLMONITOR 
9bce cd 6f ee			call debug_vector  
9bd1				endm  
# End of macro CALLMONITOR
9bd1			endif	 
9bd1			    
9bd1 e5				push hl 
9bd2 e5				push hl 
9bd3			 
9bd3			;	ld a, 0   ; find end of string 
9bd3 cd 39 91			call strlenz 
9bd6			if DEBUG_FORTH_PUSH 
9bd6						DMARK "PQ2" 
9bd6 f5				push af  
9bd7 3a eb 9b			ld a, (.dmark)  
9bda 32 6b ee			ld (debug_mark),a  
9bdd 3a ec 9b			ld a, (.dmark+1)  
9be0 32 6c ee			ld (debug_mark+1),a  
9be3 3a ed 9b			ld a, (.dmark+2)  
9be6 32 6d ee			ld (debug_mark+2),a  
9be9 18 03			jr .pastdmark  
9beb ..			.dmark: db "PQ2"  
9bee f1			.pastdmark: pop af  
9bef			endm  
# End of macro DMARK
9bef				CALLMONITOR 
9bef cd 6f ee			call debug_vector  
9bf2				endm  
# End of macro CALLMONITOR
9bf2			endif	 
9bf2 eb				ex de, hl 
9bf3 e1				pop hl   ; get ptr to start of string 
9bf4			if DEBUG_FORTH_PUSH 
9bf4						DMARK "PQ3" 
9bf4 f5				push af  
9bf5 3a 09 9c			ld a, (.dmark)  
9bf8 32 6b ee			ld (debug_mark),a  
9bfb 3a 0a 9c			ld a, (.dmark+1)  
9bfe 32 6c ee			ld (debug_mark+1),a  
9c01 3a 0b 9c			ld a, (.dmark+2)  
9c04 32 6d ee			ld (debug_mark+2),a  
9c07 18 03			jr .pastdmark  
9c09 ..			.dmark: db "PQ3"  
9c0c f1			.pastdmark: pop af  
9c0d			endm  
# End of macro DMARK
9c0d				CALLMONITOR 
9c0d cd 6f ee			call debug_vector  
9c10				endm  
# End of macro CALLMONITOR
9c10			endif	 
9c10 19				add hl,de 
9c11			if DEBUG_FORTH_PUSH 
9c11						DMARK "PQE" 
9c11 f5				push af  
9c12 3a 26 9c			ld a, (.dmark)  
9c15 32 6b ee			ld (debug_mark),a  
9c18 3a 27 9c			ld a, (.dmark+1)  
9c1b 32 6c ee			ld (debug_mark+1),a  
9c1e 3a 28 9c			ld a, (.dmark+2)  
9c21 32 6d ee			ld (debug_mark+2),a  
9c24 18 03			jr .pastdmark  
9c26 ..			.dmark: db "PQE"  
9c29 f1			.pastdmark: pop af  
9c2a			endm  
# End of macro DMARK
9c2a				CALLMONITOR 
9c2a cd 6f ee			call debug_vector  
9c2d				endm  
# End of macro CALLMONITOR
9c2d			endif	 
9c2d			 
9c2d 2b				dec hl    ; see if there is an optional trailing double quote 
9c2e 7e				ld a,(hl) 
9c2f fe 22			cp '"' 
9c31 20 03			jr nz, .strnoq 
9c33 3e 00			ld a, 0      ; get rid of double quote 
9c35 77				ld (hl), a 
9c36 23			.strnoq: inc hl 
9c37			 
9c37 3e 00			ld a, 0 
9c39 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c3a			 
9c3a 13				inc de ; add one for the type string 
9c3b 13				inc de ; add one for null term??? 
9c3c			 
9c3c				; tos is get string pointer again 
9c3c				; de contains space to allocate 
9c3c				 
9c3c d5				push de 
9c3d			 
9c3d eb				ex de, hl 
9c3e			 
9c3e				;push af 
9c3e			 
9c3e			if DEBUG_FORTH_PUSH 
9c3e						DMARK "PHm" 
9c3e f5				push af  
9c3f 3a 53 9c			ld a, (.dmark)  
9c42 32 6b ee			ld (debug_mark),a  
9c45 3a 54 9c			ld a, (.dmark+1)  
9c48 32 6c ee			ld (debug_mark+1),a  
9c4b 3a 55 9c			ld a, (.dmark+2)  
9c4e 32 6d ee			ld (debug_mark+2),a  
9c51 18 03			jr .pastdmark  
9c53 ..			.dmark: db "PHm"  
9c56 f1			.pastdmark: pop af  
9c57			endm  
# End of macro DMARK
9c57				CALLMONITOR 
9c57 cd 6f ee			call debug_vector  
9c5a				endm  
# End of macro CALLMONITOR
9c5a			endif	 
9c5a cd ae 91			call malloc	; on ret hl now contains allocated memory 
9c5d				if DEBUG_FORTH_MALLOC_GUARD 
9c5d cc b4 cc				call z,malloc_error 
9c60				endif 
9c60			 
9c60				 
9c60 c1				pop bc    ; get length 
9c61 d1				pop de   ;  get string start    
9c62			 
9c62				; hl has destination from malloc 
9c62			 
9c62 eb				ex de, hl    ; prep for ldir 
9c63			 
9c63 d5				push de   ; save malloc area for DSP later 
9c64				;push hl   ; save malloc area for DSP later 
9c64			 
9c64			if DEBUG_FORTH_PUSH 
9c64						DMARK "PHc" 
9c64 f5				push af  
9c65 3a 79 9c			ld a, (.dmark)  
9c68 32 6b ee			ld (debug_mark),a  
9c6b 3a 7a 9c			ld a, (.dmark+1)  
9c6e 32 6c ee			ld (debug_mark+1),a  
9c71 3a 7b 9c			ld a, (.dmark+2)  
9c74 32 6d ee			ld (debug_mark+2),a  
9c77 18 03			jr .pastdmark  
9c79 ..			.dmark: db "PHc"  
9c7c f1			.pastdmark: pop af  
9c7d			endm  
# End of macro DMARK
9c7d				CALLMONITOR 
9c7d cd 6f ee			call debug_vector  
9c80				endm  
# End of macro CALLMONITOR
9c80			endif	 
9c80			 
9c80			 
9c80 ed b0			ldir 
9c82			 
9c82			 
9c82				; push malloc to data stack     macro?????  
9c82			 
9c82				FORTH_DSP_NEXT 
9c82 cd d6 9a			call macro_forth_dsp_next 
9c85				endm 
# End of macro FORTH_DSP_NEXT
9c85			 
9c85				; save value and type 
9c85			 
9c85 2a ee e9			ld hl, (cli_data_sp) 
9c88			 
9c88				; save item type 
9c88 3e 01			ld a,  DS_TYPE_STR 
9c8a 77				ld (hl), a 
9c8b 23				inc hl 
9c8c			 
9c8c				; get malloc word off stack 
9c8c d1				pop de 
9c8d 73				ld (hl), e 
9c8e 23				inc hl 
9c8f 72				ld (hl), d 
9c90			 
9c90			 
9c90			 
9c90			if DEBUG_FORTH_PUSH 
9c90 2a ee e9			ld hl, (cli_data_sp) 
9c93						DMARK "PHS" 
9c93 f5				push af  
9c94 3a a8 9c			ld a, (.dmark)  
9c97 32 6b ee			ld (debug_mark),a  
9c9a 3a a9 9c			ld a, (.dmark+1)  
9c9d 32 6c ee			ld (debug_mark+1),a  
9ca0 3a aa 9c			ld a, (.dmark+2)  
9ca3 32 6d ee			ld (debug_mark+2),a  
9ca6 18 03			jr .pastdmark  
9ca8 ..			.dmark: db "PHS"  
9cab f1			.pastdmark: pop af  
9cac			endm  
# End of macro DMARK
9cac				CALLMONITOR 
9cac cd 6f ee			call debug_vector  
9caf				endm  
# End of macro CALLMONITOR
9caf			;	ex de,hl 
9caf			endif	 
9caf				; in case of spaces, skip the ptr past the copied string 
9caf				;pop af 
9caf				;ld (cli_origptr),hl 
9caf			 
9caf c9				ret 
9cb0			 
9cb0			 
9cb0			 
9cb0			; TODO ascii push input onto stack given hl to start of input 
9cb0			 
9cb0			; identify type 
9cb0			; if starts with a " then a string 
9cb0			; otherwise it is a number 
9cb0			;  
9cb0			; if a string 
9cb0			;     scan for ending " to get length of string to malloc for + 1 
9cb0			;     malloc 
9cb0			;     put pointer to string on stack first byte flags as string 
9cb0			; 
9cb0			; else a number 
9cb0			;    look for number format identifier 
9cb0			;    $xx hex 
9cb0			;    %xxxxx bin 
9cb0			;    xxxxx decimal 
9cb0			;    convert number to 16bit word.  
9cb0			;    malloc word + 1 with flag to identiy as num 
9cb0			;    put pointer to number on stack 
9cb0			;   
9cb0			;  
9cb0			  
9cb0			forth_apush: 
9cb0				; kernel push 
9cb0			 
9cb0			if DEBUG_FORTH_PUSH 
9cb0						DMARK "PSH" 
9cb0 f5				push af  
9cb1 3a c5 9c			ld a, (.dmark)  
9cb4 32 6b ee			ld (debug_mark),a  
9cb7 3a c6 9c			ld a, (.dmark+1)  
9cba 32 6c ee			ld (debug_mark+1),a  
9cbd 3a c7 9c			ld a, (.dmark+2)  
9cc0 32 6d ee			ld (debug_mark+2),a  
9cc3 18 03			jr .pastdmark  
9cc5 ..			.dmark: db "PSH"  
9cc8 f1			.pastdmark: pop af  
9cc9			endm  
# End of macro DMARK
9cc9				CALLMONITOR 
9cc9 cd 6f ee			call debug_vector  
9ccc				endm  
# End of macro CALLMONITOR
9ccc			endif	 
9ccc				; identify input type 
9ccc			 
9ccc 7e				ld a,(hl) 
9ccd fe 22			cp '"' 
9ccf 28 0a			jr z, .fapstr 
9cd1 fe 24			cp '$' 
9cd3 ca fb 9c			jp z, .faphex 
9cd6 fe 25			cp '%' 
9cd8 ca e3 9c			jp z, .fapbin 
9cdb			;	cp 'b' 
9cdb			;	jp z, .fabin 
9cdb				; else decimal 
9cdb			 
9cdb				; TODO do decimal conversion 
9cdb				; decimal is stored as a 16bit word 
9cdb			 
9cdb				; by default everything is a string if type is not detected 
9cdb			.fapstr: ; 
9cdb fe 22			cp '"' 
9cdd 20 01			jr nz, .strnoqu 
9cdf 23				inc hl 
9ce0			.strnoqu: 
9ce0 c3 b5 9b			jp forth_push_str 
9ce3			 
9ce3			 
9ce3			 
9ce3			.fapbin:    ; push a binary string.  
9ce3 11 00 00			ld de, 0   ; hold a 16bit value 
9ce6			 
9ce6 23			.fapbinshift:	inc hl  
9ce7 7e				ld a,(hl) 
9ce8 fe 00			cp 0     ; done scanning  
9cea 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cec			 
9cec				; left shift de 
9cec eb				ex de, hl	 
9ced 29				add hl, hl 
9cee			 
9cee				; is 1 
9cee fe 31			cp '1' 
9cf0 20 02			jr nz, .binzero 
9cf2 cb 4d			bit 1, l 
9cf4			.binzero: 
9cf4 eb				ex de, hl	 ; save current de 
9cf5 18 ef			jr .fapbinshift 
9cf7			 
9cf7			.fapbdone: 
9cf7 eb				ex de, hl 
9cf8 c3 47 9b			jp forth_push_numhl 
9cfb			 
9cfb			 
9cfb			.faphex:   ; hex is always stored as a 16bit word 
9cfb				; skip number prefix 
9cfb 23				inc hl 
9cfc				; turn ascii into number 
9cfc cd 92 90			call get_word_hl	; ret 16bit word in hl 
9cff			 
9cff c3 47 9b			jp forth_push_numhl 
9d02			 
9d02 00				 nop 
9d03			 
9d03			.fabin:   ; TODO bin conversion 
9d03			 
9d03			 
9d03 c9				ret 
9d04			 
9d04			 
9d04			; get either a string ptr or a 16bit word from the data stack 
9d04			 
9d04			FORTH_DSP: macro 
9d04				call macro_forth_dsp 
9d04				endm 
9d04			 
9d04			macro_forth_dsp: 
9d04				; data stack pointer points to current word on tos 
9d04			 
9d04 2a ee e9			ld hl,(cli_data_sp) 
9d07			 
9d07				if DEBUG_FORTH_PUSH 
9d07						DMARK "DSP" 
9d07 f5				push af  
9d08 3a 1c 9d			ld a, (.dmark)  
9d0b 32 6b ee			ld (debug_mark),a  
9d0e 3a 1d 9d			ld a, (.dmark+1)  
9d11 32 6c ee			ld (debug_mark+1),a  
9d14 3a 1e 9d			ld a, (.dmark+2)  
9d17 32 6d ee			ld (debug_mark+2),a  
9d1a 18 03			jr .pastdmark  
9d1c ..			.dmark: db "DSP"  
9d1f f1			.pastdmark: pop af  
9d20			endm  
# End of macro DMARK
9d20			 
9d20 cd e7 cc				call display_data_sp 
9d23				;call break_point_state 
9d23				;rst 030h 
9d23				CALLMONITOR 
9d23 cd 6f ee			call debug_vector  
9d26				endm  
# End of macro CALLMONITOR
9d26				endif 
9d26			 
9d26 c9				ret 
9d27			 
9d27			; return hl to start of value on stack 
9d27			 
9d27			FORTH_DSP_VALUE: macro 
9d27				call macro_forth_dsp_value 
9d27				endm 
9d27			 
9d27			macro_forth_dsp_value: 
9d27			 
9d27				FORTH_DSP 
9d27 cd 04 9d			call macro_forth_dsp 
9d2a				endm 
# End of macro FORTH_DSP
9d2a			 
9d2a d5				push de 
9d2b			 
9d2b 23				inc hl ; skip type 
9d2c			 
9d2c 5e				ld e, (hl) 
9d2d 23				inc hl 
9d2e 56				ld d, (hl) 
9d2f eb				ex de,hl  
9d30			 
9d30 d1				pop de 
9d31			 
9d31 c9				ret 
9d32			 
9d32			; return hl to start of value to second item on stack 
9d32			 
9d32			FORTH_DSP_VALUEM1: macro 
9d32				call macro_forth_dsp_value_m1 
9d32				endm 
9d32			 
9d32			macro_forth_dsp_value_m1: 
9d32			 
9d32				FORTH_DSP 
9d32 cd 04 9d			call macro_forth_dsp 
9d35				endm 
# End of macro FORTH_DSP
9d35			 
9d35 2b				dec hl 
9d36 2b				dec hl 
9d37			;	dec hl 
9d37			 
9d37 d5				push de 
9d38			 
9d38 5e				ld e, (hl) 
9d39 23				inc hl 
9d3a 56				ld d, (hl) 
9d3b eb				ex de,hl  
9d3c			 
9d3c d1				pop de 
9d3d			 
9d3d c9				ret 
9d3e			 
9d3e				 
9d3e			 
9d3e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d3e			 
9d3e			FORTH_DSP_POP: macro 
9d3e				call macro_forth_dsp_pop 
9d3e				endm 
9d3e			 
9d3e			 
9d3e			; get the tos data type 
9d3e			 
9d3e			FORTH_DSP_TYPE:   macro 
9d3e			 
9d3e				;FORTH_DSP_VALUE 
9d3e				FORTH_DSP 
9d3e				 
9d3e				; hl points to value 
9d3e				; check type 
9d3e			 
9d3e				ld a,(hl) 
9d3e			 
9d3e				endm 
9d3e			 
9d3e			; load the tos value into hl 
9d3e			 
9d3e			 
9d3e			FORTH_DSP_VALUEHL:  macro 
9d3e				call macro_dsp_valuehl 
9d3e				endm 
9d3e			 
9d3e			 
9d3e			 
9d3e			macro_dsp_valuehl: 
9d3e				FORTH_DSP_VALUE 
9d3e cd 27 9d			call macro_forth_dsp_value 
9d41				endm 
# End of macro FORTH_DSP_VALUE
9d41			 
9d41				;FORTH_ERR_TOS_NOTNUM 
9d41			 
9d41				;inc hl   ; skip type id 
9d41			 
9d41			;	push de 
9d41			; 
9d41			;	ld e, (hl) 
9d41			;	inc hl 
9d41			;	ld d, (hl) 
9d41			;	ex de,hl  
9d41			 
9d41			;	pop de 
9d41			 
9d41				if DEBUG_FORTH_PUSH 
9d41						DMARK "DVL" 
9d41 f5				push af  
9d42 3a 56 9d			ld a, (.dmark)  
9d45 32 6b ee			ld (debug_mark),a  
9d48 3a 57 9d			ld a, (.dmark+1)  
9d4b 32 6c ee			ld (debug_mark+1),a  
9d4e 3a 58 9d			ld a, (.dmark+2)  
9d51 32 6d ee			ld (debug_mark+2),a  
9d54 18 03			jr .pastdmark  
9d56 ..			.dmark: db "DVL"  
9d59 f1			.pastdmark: pop af  
9d5a			endm  
# End of macro DMARK
9d5a				CALLMONITOR 
9d5a cd 6f ee			call debug_vector  
9d5d				endm  
# End of macro CALLMONITOR
9d5d				endif 
9d5d c9				ret 
9d5e			 
9d5e			forth_apushstrhl:      
9d5e				; push of string requires use of cli_origptr 
9d5e				; bodge use 
9d5e			 
9d5e				; get current cli_origptr, save, update with temp pointer  
9d5e ed 5b 3e ea		ld de, (cli_origptr) 
9d62 22 3e ea			ld (cli_origptr), hl 
9d65 d5				push de 
9d66 cd b0 9c			call forth_apush 
9d69 d1				pop de 
9d6a ed 53 3e ea		ld (cli_origptr), de 
9d6e c9			        ret	 
9d6f			 
9d6f			 
9d6f			; increase loop stack pointer and save hl to it 
9d6f				 
9d6f			FORTH_LOOP_NEXT: macro 
9d6f				call macro_forth_loop_next 
9d6f				;nop 
9d6f				endm 
9d6f			 
9d6f			macro_forth_loop_next: 
9d6f				if DEBUG_FORTH_STACK_GUARD 
9d6f cd 4a e1				call check_stacks 
9d72				endif 
9d72 e5				push hl 
9d73 d5				push de 
9d74 eb				ex de,hl 
9d75 2a f0 e9			ld hl,(cli_loop_sp) 
9d78 23				inc hl 
9d79 23				inc hl 
9d7a					if DEBUG_FORTH_WORDS 
9d7a						DMARK "LNX" 
9d7a f5				push af  
9d7b 3a 8f 9d			ld a, (.dmark)  
9d7e 32 6b ee			ld (debug_mark),a  
9d81 3a 90 9d			ld a, (.dmark+1)  
9d84 32 6c ee			ld (debug_mark+1),a  
9d87 3a 91 9d			ld a, (.dmark+2)  
9d8a 32 6d ee			ld (debug_mark+2),a  
9d8d 18 03			jr .pastdmark  
9d8f ..			.dmark: db "LNX"  
9d92 f1			.pastdmark: pop af  
9d93			endm  
# End of macro DMARK
9d93						CALLMONITOR 
9d93 cd 6f ee			call debug_vector  
9d96				endm  
# End of macro CALLMONITOR
9d96					endif 
9d96 22 f0 e9			ld (cli_loop_sp),hl 
9d99 73				ld (hl), e 
9d9a 23				inc hl 
9d9b 72				ld (hl), d 
9d9c d1				pop de    ; been reversed so save a swap on restore 
9d9d e1				pop hl 
9d9e				if DEBUG_FORTH_STACK_GUARD 
9d9e cd 4a e1				call check_stacks 
9da1				endif 
9da1 c9				ret 
9da2			 
9da2			; get current ret stack pointer and save to hl  
9da2				 
9da2			FORTH_LOOP_TOS: macro 
9da2				call macro_forth_loop_tos 
9da2				endm 
9da2			 
9da2			macro_forth_loop_tos: 
9da2 d5				push de 
9da3 2a f0 e9			ld hl,(cli_loop_sp) 
9da6 5e				ld e, (hl) 
9da7 23				inc hl 
9da8 56				ld d, (hl) 
9da9 eb				ex de, hl 
9daa d1				pop de 
9dab c9				ret 
9dac			 
9dac			; pop loop stack pointer 
9dac				 
9dac			FORTH_LOOP_POP: macro 
9dac				call macro_forth_loop_pop 
9dac				endm 
9dac			 
9dac			 
9dac			macro_forth_loop_pop: 
9dac				if DEBUG_FORTH_STACK_GUARD 
9dac					DMARK "LPP" 
9dac f5				push af  
9dad 3a c1 9d			ld a, (.dmark)  
9db0 32 6b ee			ld (debug_mark),a  
9db3 3a c2 9d			ld a, (.dmark+1)  
9db6 32 6c ee			ld (debug_mark+1),a  
9db9 3a c3 9d			ld a, (.dmark+2)  
9dbc 32 6d ee			ld (debug_mark+2),a  
9dbf 18 03			jr .pastdmark  
9dc1 ..			.dmark: db "LPP"  
9dc4 f1			.pastdmark: pop af  
9dc5			endm  
# End of macro DMARK
9dc5 cd 4a e1				call check_stacks 
9dc8					FORTH_CHK_LOOP_UNDER 
9dc8 e5				push hl 
9dc9 d5				push de 
9dca 2a f0 e9			ld hl,(cli_loop_sp) 
9dcd 11 2a e9			ld de, cli_loop_stack 
9dd0 cd f9 8c			call cmp16 
9dd3 da 64 e2			jp c, fault_loop_under 
9dd6 d1				pop de 
9dd7 e1				pop hl 
9dd8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dd8				endif 
9dd8 e5				push hl 
9dd9 2a f0 e9			ld hl,(cli_loop_sp) 
9ddc 2b				dec hl 
9ddd 2b				dec hl 
9dde 22 f0 e9			ld (cli_loop_sp), hl 
9de1				; TODO do stack underflow checks 
9de1 e1				pop hl 
9de2				if DEBUG_FORTH_STACK_GUARD 
9de2 cd 4a e1				call check_stacks 
9de5					FORTH_CHK_LOOP_UNDER 
9de5 e5				push hl 
9de6 d5				push de 
9de7 2a f0 e9			ld hl,(cli_loop_sp) 
9dea 11 2a e9			ld de, cli_loop_stack 
9ded cd f9 8c			call cmp16 
9df0 da 64 e2			jp c, fault_loop_under 
9df3 d1				pop de 
9df4 e1				pop hl 
9df5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9df5				endif 
9df5 c9				ret 
9df6			 
9df6			macro_forth_dsp_pop: 
9df6			 
9df6 e5				push hl 
9df7			 
9df7				; release malloc data 
9df7			 
9df7				if DEBUG_FORTH_STACK_GUARD 
9df7 cd 4a e1				call check_stacks 
9dfa					FORTH_CHK_DSP_UNDER 
9dfa e5				push hl 
9dfb d5				push de 
9dfc 2a ee e9			ld hl,(cli_data_sp) 
9dff 11 28 e8			ld de, cli_data_stack 
9e02 cd f9 8c			call cmp16 
9e05 da 58 e2			jp c, fault_dsp_under 
9e08 d1				pop de 
9e09 e1				pop hl 
9e0a				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e0a				endif 
9e0a				;ld hl,(cli_data_sp) 
9e0a			if DEBUG_FORTH_DOT 
9e0a				DMARK "DPP" 
9e0a f5				push af  
9e0b 3a 1f 9e			ld a, (.dmark)  
9e0e 32 6b ee			ld (debug_mark),a  
9e11 3a 20 9e			ld a, (.dmark+1)  
9e14 32 6c ee			ld (debug_mark+1),a  
9e17 3a 21 9e			ld a, (.dmark+2)  
9e1a 32 6d ee			ld (debug_mark+2),a  
9e1d 18 03			jr .pastdmark  
9e1f ..			.dmark: db "DPP"  
9e22 f1			.pastdmark: pop af  
9e23			endm  
# End of macro DMARK
9e23				CALLMONITOR 
9e23 cd 6f ee			call debug_vector  
9e26				endm  
# End of macro CALLMONITOR
9e26			endif	 
9e26			 
9e26			 
9e26			if FORTH_ENABLE_DSPPOPFREE 
9e26			 
9e26				FORTH_DSP 
9e26 cd 04 9d			call macro_forth_dsp 
9e29				endm 
# End of macro FORTH_DSP
9e29			 
9e29 7e				ld a, (hl) 
9e2a fe 01			cp DS_TYPE_STR 
9e2c 20 23			jr nz, .skippopfree 
9e2e			 
9e2e				FORTH_DSP_VALUEHL 
9e2e cd 3e 9d			call macro_dsp_valuehl 
9e31				endm 
# End of macro FORTH_DSP_VALUEHL
9e31 00				nop 
9e32			if DEBUG_FORTH_DOT 
9e32				DMARK "DPf" 
9e32 f5				push af  
9e33 3a 47 9e			ld a, (.dmark)  
9e36 32 6b ee			ld (debug_mark),a  
9e39 3a 48 9e			ld a, (.dmark+1)  
9e3c 32 6c ee			ld (debug_mark+1),a  
9e3f 3a 49 9e			ld a, (.dmark+2)  
9e42 32 6d ee			ld (debug_mark+2),a  
9e45 18 03			jr .pastdmark  
9e47 ..			.dmark: db "DPf"  
9e4a f1			.pastdmark: pop af  
9e4b			endm  
# End of macro DMARK
9e4b				CALLMONITOR 
9e4b cd 6f ee			call debug_vector  
9e4e				endm  
# End of macro CALLMONITOR
9e4e			endif	 
9e4e cd 78 92			call free 
9e51			.skippopfree: 
9e51				 
9e51			 
9e51			endif 
9e51			 
9e51			if DEBUG_FORTH_DOT_KEY 
9e51				DMARK "DP2" 
9e51				CALLMONITOR 
9e51			endif	 
9e51			 
9e51				; move pointer down 
9e51			 
9e51 2a ee e9			ld hl,(cli_data_sp) 
9e54 2b				dec hl 
9e55 2b				dec hl 
9e56			; PARSEV5 
9e56 2b				dec hl 
9e57 22 ee e9			ld (cli_data_sp), hl 
9e5a			 
9e5a				if DEBUG_FORTH_STACK_GUARD 
9e5a cd 4a e1				call check_stacks 
9e5d					FORTH_CHK_DSP_UNDER 
9e5d e5				push hl 
9e5e d5				push de 
9e5f 2a ee e9			ld hl,(cli_data_sp) 
9e62 11 28 e8			ld de, cli_data_stack 
9e65 cd f9 8c			call cmp16 
9e68 da 58 e2			jp c, fault_dsp_under 
9e6b d1				pop de 
9e6c e1				pop hl 
9e6d				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e6d				endif 
9e6d			 
9e6d e1				pop hl 
9e6e			 
9e6e c9				ret 
9e6f			 
9e6f			getwordathl: 
9e6f				; hl points to an address 
9e6f				; load hl with the word at that address 
9e6f			 
9e6f d5				push de 
9e70			 
9e70 5e				ld e, (hl) 
9e71 23				inc hl 
9e72 56				ld d, (hl) 
9e73 eb				ex de, hl 
9e74			 
9e74 d1				pop de 
9e75 c9				ret 
9e76			 
9e76			 
9e76			 
9e76			 
9e76			 
9e76			; eof 
9e76			 
# End of file forth_stackopsv5.asm
9e76			endif 
9e76			 
9e76			loadwordinhl:	 
9e76			 
9e76 d5				push de 
9e77			 
9e77 5e				ld e, (hl) 
9e78 23				inc hl 
9e79 56				ld d, (hl) 
9e7a eb				ex de,hl  
9e7b			 
9e7b d1				pop de 
9e7c			 
9e7c c9				ret 
9e7d			 
9e7d			user_word_eol:  
9e7d				; hl contains the pointer to where to create a linked list item from the end 
9e7d				; of the user dict to continue on at the system word dict 
9e7d				 
9e7d				; poke the stub of the word list linked list to repoint to rom words 
9e7d			 
9e7d				; stub format 
9e7d				; db   word id 
9e7d				; dw    link to next word 
9e7d			        ; db char length of token 
9e7d				; db string + 0 term 
9e7d				; db exec code....  
9e7d			 
9e7d 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e7f 77				ld (hl), a		; word id 
9e80 23				inc hl 
9e81			 
9e81 11 4c a0			ld de, sysdict 
9e84 73				ld (hl), e		; next word link ie system dict 
9e85 23				inc hl 
9e86 72				ld (hl), d		; next word link ie system dict 
9e87 23				inc hl	 
9e88			 
9e88			;	ld (hl), sysdict		; next word link ie system dict 
9e88			;	inc hl 
9e88			;	inc hl 
9e88			 
9e88			;	inc hl 
9e88			;	inc hl 
9e88			 
9e88 3e 02			ld a, 2			; word length is 0 
9e8a 77				ld (hl), a	 
9e8b 23				inc hl 
9e8c			 
9e8c 3e 7e			ld a, '~'			; word length is 0 
9e8e 77				ld (hl), a	 
9e8f 23				inc hl 
9e90 3e 00			ld a, 0			; save empty word 
9e92 77				ld (hl), a 
9e93			 
9e93 c9				ret 
9e94			 
9e94				 
9e94			 
9e94			forthexec_cleanup: 
9e94				FORTH_RSP_POP 
9e94 cd 0f 9b			call macro_forth_rsp_pop 
9e97				endm 
# End of macro FORTH_RSP_POP
9e97 c9				ret 
9e98			 
9e98			forth_call_hl: 
9e98				; taking hl 
9e98 e5				push hl 
9e99 c9				ret 
9e9a			 
9e9a			; this is called to reset Forth system but keep existing uwords etc 
9e9a			 
9e9a			forth_warmstart: 
9e9a				; setup stack over/under flow checks 
9e9a				if DEBUG_FORTH_STACK_GUARD 
9e9a cd 30 e1				call chk_stk_init 
9e9d				endif 
9e9d			 
9e9d				; init stack pointers  - * these stacks go upwards *  
9e9d 21 ac e9			ld hl, cli_ret_stack 
9ea0 22 f2 e9			ld (cli_ret_sp), hl	 
9ea3				; set bottom of stack 
9ea3 3e 00			ld a,0 
9ea5 77				ld (hl),a 
9ea6 23				inc hl 
9ea7 77				ld (hl),a 
9ea8			 
9ea8 21 28 e8			ld hl, cli_data_stack 
9eab 22 ee e9			ld (cli_data_sp), hl	 
9eae				; set bottom of stack 
9eae 3e 00			ld a,0 
9eb0 77				ld (hl),a 
9eb1 23				inc hl 
9eb2 77				ld (hl),a 
9eb3			 
9eb3 21 2a e9			ld hl, cli_loop_stack 
9eb6 22 f0 e9			ld (cli_loop_sp), hl	 
9eb9				; set bottom of stack 
9eb9 3e 00			ld a,0 
9ebb 77				ld (hl),a 
9ebc 23				inc hl 
9ebd 77				ld (hl),a 
9ebe			 
9ebe				; init extent of current open file 
9ebe			 
9ebe 3e 00			ld a, 0 
9ec0 32 6a ea			ld (store_openext), a 
9ec3			 
9ec3 c9				ret 
9ec4			 
9ec4			 
9ec4			 
9ec4			; Cold Start - this is called to setup the whole Forth system 
9ec4			 
9ec4			forth_init: 
9ec4			 
9ec4				; setup stack over/under flow checks 
9ec4			 
9ec4			;	if DEBUG_FORTH_STACK_GUARD 
9ec4			;		call chk_stk_init 
9ec4			;	endif 
9ec4			 
9ec4				; enable auto display updates (slow.....) 
9ec4			 
9ec4 3e 01			ld a, 1 
9ec6 32 3c ea			ld (cli_autodisplay), a 
9ec9			 
9ec9				; if storage is in use disable long reads for now 
9ec9 3e 00			ld a, 0 
9ecb 32 75 ea			ld (store_longread), a 
9ece			 
9ece			 
9ece				; show start up screen 
9ece			 
9ece cd ae 8a			call clear_display 
9ed1			 
9ed1 3e 00			ld a,0 
9ed3 32 5e ea			ld (f_cursor_ptr), a 
9ed6			 
9ed6				; set start of word list in start of ram - for use when creating user words 
9ed6			 
9ed6 21 e4 e4			ld hl, baseram 
9ed9 22 be e5			ld (os_last_new_uword), hl 
9edc cd 7d 9e			call user_word_eol 
9edf				 
9edf			;		call display_data_sp 
9edf			;		call next_page_prompt 
9edf			 
9edf			 
9edf			 
9edf			 
9edf c9				ret 
9ee0			 
9ee0 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ef4			 
9ef4			; TODO push to stack 
9ef4			 
9ef4			;  
9ef4			 
9ef4			if FORTH_PARSEV2 
9ef4			 
9ef4			 
9ef4				include "forth_parserv2.asm" 
9ef4			 
9ef4			endif 
9ef4			 
9ef4			 
9ef4			; parse cli version 1 
9ef4			 
9ef4			if FORTH_PARSEV1 
9ef4			 
9ef4			 
9ef4			 
9ef4			      include "forth_parserv1.asm" 
9ef4			endif 
9ef4				 
9ef4			if FORTH_PARSEV3 
9ef4			 
9ef4			 
9ef4			 
9ef4			      include "forth_parserv3.asm" 
9ef4				include "forth_wordsv3.asm" 
9ef4			endif 
9ef4			 
9ef4			if FORTH_PARSEV4 
9ef4			 
9ef4			 
9ef4			 
9ef4			      include "forth_parserv4.asm" 
9ef4				include "forth_wordsv4.asm" 
9ef4			endif 
9ef4			 
9ef4			if FORTH_PARSEV5 
9ef4			 
9ef4			 
9ef4			 
9ef4			      include "forth_parserv5.asm" 
9ef4			 
9ef4			 
9ef4			; A better parser without using malloc and string copies all over the place.  
9ef4			; Exec in situ should be faster 
9ef4			 
9ef4			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ef4			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ef4			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ef4			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ef4			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ef4			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ef4			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ef4			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ef4			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ef4			 
9ef4			; Core word preamble macro 
9ef4			 
9ef4			CWHEAD:   macro nxtword opcode lit len opflags 
9ef4				db WORD_SYS_CORE+opcode             
9ef4				; internal op code number 
9ef4				dw nxtword            
9ef4				; link to next dict word block 
9ef4				db len + 1 
9ef4				; literal length of dict word inc zero term 
9ef4				db lit,0              
9ef4				; literal dict word 
9ef4			        ; TODO db opflags        
9ef4				endm 
9ef4			 
9ef4			 
9ef4			NEXTW: macro  
9ef4				jp macro_next 
9ef4				endm 
9ef4			 
9ef4			macro_next: 
9ef4			if DEBUG_FORTH_PARSE_KEY 
9ef4				DMARK "NXT" 
9ef4				CALLMONITOR 
9ef4			endif	 
9ef4			;	inc hl  ; skip token null term  
9ef4 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9ef8 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9efc 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9eff			if DEBUG_FORTH_PARSE_KEY 
9eff				DMARK "}AA" 
9eff				CALLMONITOR 
9eff			endif	 
9eff c3 02 a0			jp execnext 
9f02				;jp exec1 
9f02			       
9f02			 
9f02			 
9f02			; Another go at the parser to compile  
9f02			 
9f02			 
9f02			; TODO rework parser to change all of the string words to byte tokens 
9f02			; TODO do a search for  
9f02			 
9f02			; TODO first run normal parser to zero term sections 
9f02			; TODO for each word do a token look up to get the op code 
9f02			; TODO need some means to flag to the exec that this is a byte code form    
9f02			 
9f02			 
9f02			forthcompile: 
9f02			 
9f02			; 
9f02			; line parse: 
9f02			;       parse raw input buffer 
9f02			;       tokenise the words 
9f02			;       malloc new copy (for looping etc) 
9f02			;       copy to malloc + current pc in line to start of string and add line term 
9f02			;       save on new rsp 
9f02			; 
9f02			 
9f02			; hl to point to the line to tokenise 
9f02			 
9f02			;	push hl 
9f02 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f05			 
9f05			;	ld a,0		; string term on input 
9f05			;	call strlent 
9f05			 
9f05			;	ld (os_tok_len), hl	 ; save string length 
9f05			 
9f05			;if DEBUG_FORTH_TOK 
9f05			;	ex de,hl		 
9f05			;endif 
9f05			 
9f05			;	pop hl 		; get back string pointer 
9f05			 
9f05			if DEBUG_FORTH_TOK 
9f05						DMARK "TOc" 
9f05				CALLMONITOR 
9f05			endif 
9f05 7e			.cptoken2:    ld a,(hl) 
9f06 23				inc hl 
9f07 fe 7f			cp FORTH_END_BUFFER 
9f09 28 29			jr z, .cptokendone2 
9f0b fe 00			cp 0 
9f0d 28 25			jr z, .cptokendone2 
9f0f fe 22			cp '"' 
9f11 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f13 fe 20			cp ' ' 
9f15 20 ee			jr nz,  .cptoken2 
9f17			 
9f17			; TODO consume comments held between ( and ) 
9f17			 
9f17				; we have a space so change to zero term for dict match later 
9f17 2b				dec hl 
9f18 3e 00			ld a,0 
9f1a 77				ld (hl), a 
9f1b 23				inc hl 
9f1c 18 e7			jr .cptoken2 
9f1e				 
9f1e			 
9f1e			.cptokenstr2: 
9f1e				; skip all white space until either eol (because forgot to term) or end double quote 
9f1e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f1e				;inc hl ; skip current double quote 
9f1e 7e				ld a,(hl) 
9f1f 23				inc hl 
9f20 fe 22			cp '"' 
9f22 28 e1			jr z, .cptoken2 
9f24 fe 7f			cp FORTH_END_BUFFER 
9f26 28 0c			jr z, .cptokendone2 
9f28 fe 00			cp 0 
9f2a 28 08			jr z, .cptokendone2 
9f2c fe 20			cp ' ' 
9f2e 28 02			jr z, .cptmp2 
9f30 18 ec			jr .cptokenstr2 
9f32			 
9f32			.cptmp2:	; we have a space so change to zero term for dict match later 
9f32				;dec hl 
9f32				;ld a,"-"	; TODO remove this when working 
9f32				;ld (hl), a 
9f32				;inc hl 
9f32 18 ea			jr .cptokenstr2 
9f34			 
9f34			.cptokendone2: 
9f34				;inc hl 
9f34 3e 7f			ld a, FORTH_END_BUFFER 
9f36 77				ld (hl),a 
9f37 23				inc hl 
9f38 3e 21			ld a, '!' 
9f3a 77				ld (hl),a 
9f3b			 
9f3b 2a c2 e5			ld hl,(os_tok_ptr) 
9f3e			         
9f3e			if DEBUG_FORTH_TOK 
9f3e						DMARK "Tc1" 
9f3e				CALLMONITOR 
9f3e			endif 
9f3e			 
9f3e				; push exec string to top of return stack 
9f3e				FORTH_RSP_NEXT 
9f3e cd ee 9a			call macro_forth_rsp_next 
9f41				endm 
# End of macro FORTH_RSP_NEXT
9f41 c9				ret 
9f42			 
9f42			; Another go at the parser need to simplify the process 
9f42			 
9f42			forthparse: 
9f42			 
9f42			; 
9f42			; line parse: 
9f42			;       parse raw input buffer 
9f42			;       tokenise the words 
9f42			;       malloc new copy (for looping etc) 
9f42			;       copy to malloc + current pc in line to start of string and add line term 
9f42			;       save on new rsp 
9f42			; 
9f42			 
9f42			; hl to point to the line to tokenise 
9f42			 
9f42			;	push hl 
9f42 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f45			 
9f45			;	ld a,0		; string term on input 
9f45			;	call strlent 
9f45			 
9f45			;	ld (os_tok_len), hl	 ; save string length 
9f45			 
9f45			;if DEBUG_FORTH_TOK 
9f45			;	ex de,hl		 
9f45			;endif 
9f45			 
9f45			;	pop hl 		; get back string pointer 
9f45			 
9f45			if DEBUG_FORTH_TOK 
9f45						DMARK "TOK" 
9f45				CALLMONITOR 
9f45			endif 
9f45 7e			.ptoken2:    ld a,(hl) 
9f46 23				inc hl 
9f47 fe 7f			cp FORTH_END_BUFFER 
9f49 28 29			jr z, .ptokendone2 
9f4b fe 00			cp 0 
9f4d 28 25			jr z, .ptokendone2 
9f4f fe 22			cp '"' 
9f51 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f53 fe 20			cp ' ' 
9f55 20 ee			jr nz,  .ptoken2 
9f57			 
9f57			; TODO consume comments held between ( and ) 
9f57			 
9f57				; we have a space so change to zero term for dict match later 
9f57 2b				dec hl 
9f58 3e 00			ld a,0 
9f5a 77				ld (hl), a 
9f5b 23				inc hl 
9f5c 18 e7			jr .ptoken2 
9f5e				 
9f5e			 
9f5e			.ptokenstr2: 
9f5e				; skip all white space until either eol (because forgot to term) or end double quote 
9f5e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f5e				;inc hl ; skip current double quote 
9f5e 7e				ld a,(hl) 
9f5f 23				inc hl 
9f60 fe 22			cp '"' 
9f62 28 e1			jr z, .ptoken2 
9f64 fe 7f			cp FORTH_END_BUFFER 
9f66 28 0c			jr z, .ptokendone2 
9f68 fe 00			cp 0 
9f6a 28 08			jr z, .ptokendone2 
9f6c fe 20			cp ' ' 
9f6e 28 02			jr z, .ptmp2 
9f70 18 ec			jr .ptokenstr2 
9f72			 
9f72			.ptmp2:	; we have a space so change to zero term for dict match later 
9f72				;dec hl 
9f72				;ld a,"-"	; TODO remove this when working 
9f72				;ld (hl), a 
9f72				;inc hl 
9f72 18 ea			jr .ptokenstr2 
9f74			 
9f74			.ptokendone2: 
9f74				;inc hl 
9f74 3e 7f			ld a, FORTH_END_BUFFER 
9f76 77				ld (hl),a 
9f77 23				inc hl 
9f78 3e 21			ld a, '!' 
9f7a 77				ld (hl),a 
9f7b			 
9f7b 2a c2 e5			ld hl,(os_tok_ptr) 
9f7e			         
9f7e			if DEBUG_FORTH_TOK 
9f7e						DMARK "TK1" 
9f7e				CALLMONITOR 
9f7e			endif 
9f7e			 
9f7e				; push exec string to top of return stack 
9f7e				FORTH_RSP_NEXT 
9f7e cd ee 9a			call macro_forth_rsp_next 
9f81				endm 
# End of macro FORTH_RSP_NEXT
9f81 c9				ret 
9f82			 
9f82			; 
9f82			;	; malloc size + buffer pointer + if is loop flag 
9f82			;	ld hl,(os_tok_len) 		 ; get string length 
9f82			; 
9f82			;	ld a,l 
9f82			; 
9f82			;	cp 0			; we dont want to use a null string 
9f82			;	ret z 
9f82			; 
9f82			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f82			; 
9f82			;	add 5     ; TODO when certain not over writing memory remove 
9f82			; 
9f82			;		 
9f82			; 
9f82			;if DEBUG_FORTH_TOK 
9f82			;			DMARK "TKE" 
9f82			;	CALLMONITOR 
9f82			;endif 
9f82			; 
9f82			;	ld l,a 
9f82			;	ld h,0 
9f82			;;	push hl   ; save required space for the copy later 
9f82			;	call malloc 
9f82			;if DEBUG_FORTH_TOK 
9f82			;			DMARK "TKM" 
9f82			;	CALLMONITOR 
9f82			;endif 
9f82			;	if DEBUG_FORTH_MALLOC_GUARD 
9f82			;		push af 
9f82			;		call ishlzero 
9f82			;;		ld a, l 
9f82			;;		add h 
9f82			;;		cp 0 
9f82			;		pop af 
9f82			;		 
9f82			;		call z,malloc_error 
9f82			;	endif 
9f82			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f82			; 
9f82			; 
9f82			;if DEBUG_FORTH_TOK 
9f82			;			DMARK "TKR" 
9f82			;	CALLMONITOR 
9f82			;endif 
9f82			; 
9f82			;	FORTH_RSP_NEXT 
9f82			; 
9f82			;	;inc hl	 ; go past current buffer pointer 
9f82			;	;inc hl 
9f82			;	;inc hl   ; and past if loop flag 
9f82			;		; TODO Need to set flag  
9f82			; 
9f82			;	 
9f82			;	 
9f82			;	ex de,hl	; malloc is dest 
9f82			;	ld hl, (os_tok_len) 
9f82			;;	pop bc 
9f82			;	ld c, l                
9f82			;	ld b,0 
9f82			;	ld hl, (os_tok_ptr) 
9f82			; 
9f82			;if DEBUG_FORTH_TOK 
9f82			;			DMARK "TKT" 
9f82			;	CALLMONITOR 
9f82			;endif 
9f82			; 
9f82			;	; do str cpy 
9f82			; 
9f82			;	ldir      ; copy byte in hl to de 
9f82			; 
9f82			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f82			; 
9f82			;if DEBUG_FORTH_TOK 
9f82			; 
9f82			;			DMARK "TKY" 
9f82			;	CALLMONITOR 
9f82			;endif 
9f82			;	;ld a,0 
9f82			;	;ld a,FORTH_END_BUFFER 
9f82			;	ex de, hl 
9f82			;	;dec hl			 ; go back over the space delim at the end of word 
9f82			;	;ld (hl),a 
9f82			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f82			;	ld a,FORTH_END_BUFFER 
9f82			;	ld (hl),a 
9f82			;	inc hl 
9f82			;	ld a,FORTH_END_BUFFER 
9f82			;	ld (hl),a 
9f82			; 
9f82			;	; init the malloc area data 
9f82			;	; set pc for in current area 
9f82			;	;ld hl, (os_tok_malloc) 
9f82			;	;inc hl 
9f82			;	;inc hl 
9f82			;	;inc hl 
9f82			;	;ex de,hl 
9f82			;	;ld hl, (os_tok_malloc) 
9f82			;	;ld (hl),e 
9f82			;	;inc hl 
9f82			;	;ld (hl),d 
9f82			; 
9f82			; 
9f82			;	ld hl,(os_tok_malloc) 
9f82			;if DEBUG_FORTH_PARSE_KEY 
9f82			;			DMARK "TKU" 
9f82			;	CALLMONITOR 
9f82			;endif 
9f82			; 
9f82			;	ret 
9f82			 
9f82			forthexec: 
9f82			 
9f82			; line exec: 
9f82			; forth parser 
9f82			 
9f82			; 
9f82			;       get current exec line on rsp 
9f82			 
9f82				FORTH_RSP_TOS 
9f82 cd 05 9b			call macro_forth_rsp_tos 
9f85				endm 
# End of macro FORTH_RSP_TOS
9f85			 
9f85			;       restore current pc - hl points to malloc of data 
9f85			 
9f85				;ld e, (hl) 
9f85				;inc hl 
9f85				;ld d, (hl) 
9f85				;ex de,hl 
9f85			 
9f85			 
9f85			exec1: 
9f85 22 c2 e5			ld (os_tok_ptr), hl 
9f88			 
9f88				; copy our PC to working vars  
9f88 22 40 ea			ld (cli_ptr), hl 
9f8b 22 3e ea			ld (cli_origptr), hl 
9f8e			 
9f8e 7e				ld a,(hl) 
9f8f fe 7f			cp FORTH_END_BUFFER 
9f91 c8				ret z 
9f92			 
9f92				; skip any nulls 
9f92			 
9f92 fe 00			cp 0 
9f94 20 03			jr nz, .execword 
9f96 23				inc hl 
9f97 18 ec			jr exec1 
9f99			 
9f99			 
9f99			.execword: 
9f99			 
9f99			 
9f99			 
9f99			if DEBUG_FORTH_PARSE_KEY 
9f99						DMARK "KYQ" 
9f99				CALLMONITOR 
9f99			endif 
9f99			;       while at start of word: 
9f99			; get start of dict (in user area first) 
9f99			 
9f99 21 e4 e4		ld hl, baseram 
9f9c			;ld hl, sysdict 
9f9c 22 42 ea		ld (cli_nextword),hl 
9f9f			;           match word at pc 
9f9f			;           exec word 
9f9f			;           or push to dsp 
9f9f			;           forward to next token 
9f9f			;           if line term pop rsp and exit 
9f9f			;        
9f9f			 
9f9f			if DEBUG_FORTH_PARSE_KEY 
9f9f						DMARK "KYq" 
9f9f				CALLMONITOR 
9f9f			endif 
9f9f			 
9f9f			; 
9f9f			; word comp 
9f9f			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f9f			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f9f			;    move to start of word  
9f9f			;    compare word to cli_token 
9f9f			 
9f9f			.execpnword:	; HL at start of a word in the dictionary to check 
9f9f			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f9f			;	ld (cli_ptr), hl 
9f9f			 
9f9f 2a 42 ea			ld hl,(cli_nextword) 
9fa2			 
9fa2 cd 45 a0			call forth_tok_next 
9fa5			; tok next start here 
9fa5			;	; TODO skip compiled symbol for now 
9fa5			;	inc hl 
9fa5			; 
9fa5			;	; save pointer to next word 
9fa5			; 
9fa5			;	; hl now points to the address of the next word pointer  
9fa5			;	ld e, (hl) 
9fa5			;	inc hl 
9fa5			;	ld d, (hl) 
9fa5			;	inc l 
9fa5			; 
9fa5			;	ex de,hl 
9fa5			;if DEBUG_FORTH_PARSE_NEXTWORD 
9fa5			;	push bc 
9fa5			;	ld bc, (cli_nextword) 
9fa5			;			DMARK "NXW" 
9fa5			;	CALLMONITOR 
9fa5			;	pop bc 
9fa5			;endif 
9fa5			; tok next end here 
9fa5 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9fa8 eb				ex de, hl 
9fa9			 
9fa9			 
9fa9				; save the pointer of the current token - 1 to check against 
9fa9				 
9fa9 22 46 ea			ld (cli_token), hl   
9fac				; TODO maybe remove below save if no debug 
9fac				; save token string ptr for any debug later 
9fac 23				inc hl  
9fad 22 48 ea			ld (cli_origtoken), hl 
9fb0 2b				dec hl 
9fb1				; save pointer to the start of the next dictionay word 
9fb1 7e				ld a,(hl)   ; get string length 
9fb2 47				ld b,a 
9fb3			.execpnwordinc:  
9fb3 23				inc hl 
9fb4 10 fd			djnz .execpnwordinc 
9fb6 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9fb9			 
9fb9				; now check the word token against the string being parsed 
9fb9			 
9fb9 2a 46 ea			ld hl,(cli_token) 
9fbc 23				inc hl     ; skip string length (use zero term instead to end) 
9fbd 22 46 ea			ld (cli_token), hl 
9fc0			 
9fc0			if DEBUG_FORTH_PARSE_KEY 
9fc0						DMARK "KY2" 
9fc0			endif 
9fc0			if DEBUG_FORTH_PARSE_EXEC 
9fc0				; see if disabled 
9fc0			 
9fc0			;	ld a, (os_view_disable) 
9fc0			;	cp '*' 
9fc0				ld a, (debug_vector) 
9fc0				cp $c9   ; RET  
9fc0				jr z, .skip 
9fc0			 
9fc0				push hl 
9fc0				push hl 
9fc0				call clear_display 
9fc0				ld de, .compword 
9fc0				ld a, display_row_1 
9fc0				call str_at_display 
9fc0				pop de 
9fc0				ld a, display_row_2 
9fc0				call str_at_display 
9fc0				ld hl,(cli_ptr) 
9fc0				ld a,(hl) 
9fc0			        ld hl, os_word_scratch 
9fc0				ld (hl),a 
9fc0				ld a,0 
9fc0				inc hl 
9fc0				ld (hl),a 	 
9fc0				ld de, os_word_scratch 
9fc0				ld a, display_row_2+10 
9fc0				call str_at_display 
9fc0				call update_display 
9fc0				ld a, 100 
9fc0				call aDelayInMS 
9fc0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc0				call delay250ms 
9fc0				endif 
9fc0				pop hl 
9fc0			.skip:  
9fc0			endif	 
9fc0			.execpnchar:    ; compare char between token and string to parse 
9fc0			 
9fc0			if DEBUG_FORTH_PARSE_KEY 
9fc0						DMARK "Ky3" 
9fc0			endif 
9fc0			if DEBUG_FORTH_PARSE_EXEC 
9fc0				; see if disabled 
9fc0			 
9fc0			;	ld a, (os_view_disable) 
9fc0			;	cp '*' 
9fc0				ld a, (debug_vector) 
9fc0				cp $C9  ; RET 
9fc0				jr z, .skip2 
9fc0			 
9fc0			;	call clear_display 
9fc0			ld hl,(cli_token) 
9fc0			ld a,(hl) 
9fc0			ld (os_word_scratch),a 
9fc0				ld hl,(cli_ptr) 
9fc0			ld a,(hl) 
9fc0				ld (os_word_scratch+1),a 
9fc0				ld a,0 
9fc0				ld (os_word_scratch+2),a 
9fc0				ld de,os_word_scratch 
9fc0				ld a,display_row_4 
9fc0				call str_at_display 
9fc0				call update_display 
9fc0			.skip2:  
9fc0			endif 
9fc0 2a 46 ea			ld hl,(cli_token) 
9fc3 7e				ld a, (hl)	 ; char in word token 
9fc4 23				inc hl 		; move to next char 
9fc5 22 46 ea			ld (cli_token), hl ; and save it 
9fc8 47				ld b,a 
9fc9			 
9fc9 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fcc 7e				ld a,(hl) 
9fcd 23				inc hl 
9fce 22 40 ea			ld (cli_ptr), hl		; move to next char 
9fd1 cd 30 91			call toUpper 		; make sure the input string matches case 
9fd4			 
9fd4			if DEBUG_FORTH_PARSE 
9fd4			endif 
9fd4			 
9fd4				; input stream end of token is a space so get rid of it 
9fd4			 
9fd4			;	cp ' ' 
9fd4			;	jr nz, .pnskipspace 
9fd4			; 
9fd4			;	ld a, 0		; make same term as word token term 
9fd4			; 
9fd4			;.pnskipspace: 
9fd4			 
9fd4			if DEBUG_FORTH_PARSE_KEY 
9fd4						DMARK "KY7" 
9fd4			endif 
9fd4 b8				cp b 
9fd5 c2 eb 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fd8				 
9fd8			;    if same 
9fd8			;       scan for string terms 0 for token and 32 for input 
9fd8			 
9fd8				 
9fd8			if DEBUG_FORTH_PARSE_KEY 
9fd8						DMARK "KY8" 
9fd8			endif 
9fd8			 
9fd8 80				add b			 
9fd9 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fdb							; TODO need to make sure last word in zero term string is accounted for 
9fdb 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fdd			 
9fdd			 
9fdd				; at end of both strings so both are exact match 
9fdd			 
9fdd			;       skip ptr for next word 
9fdd			 
9fdd 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9fe0 23				inc hl			 ; at next char 
9fe1 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fe4 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fe7				 
9fe7				 
9fe7			if DEBUG_FORTH_PARSE_KEY 
9fe7						DMARK "KY3" 
9fe7			endif 
9fe7			 
9fe7			 
9fe7			 
9fe7			;       exec code block 
9fe7			if DEBUG_FORTH_JP 
9fe7				call clear_display 
9fe7				call update_display 
9fe7				call delay1s 
9fe7				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fe7				ld a,h 
9fe7				ld hl, os_word_scratch 
9fe7				call hexout 
9fe7				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fe7				ld a,l 
9fe7				ld hl, os_word_scratch+2 
9fe7				call hexout 
9fe7				ld hl, os_word_scratch+4 
9fe7				ld a,0 
9fe7				ld (hl),a 
9fe7				ld de,os_word_scratch 
9fe7				call str_at_display 
9fe7					ld a, display_row_2 
9fe7					call str_at_display 
9fe7				ld de, (cli_origtoken) 
9fe7				ld a, display_row_1+10 
9fe7					call str_at_display 
9fe7			 
9fe7				ld a,display_row_1 
9fe7				ld de, .foundword 
9fe7				ld a, display_row_3 
9fe7				call str_at_display 
9fe7				call update_display 
9fe7				call delay1s 
9fe7				call delay1s 
9fe7				call delay1s 
9fe7			endif 
9fe7			 
9fe7			if DEBUG_FORTH_PARSE_KEY 
9fe7						DMARK "KYj" 
9fe7			endif 
9fe7				; TODO save the word pointer in this exec 
9fe7			 
9fe7 2a 44 ea			ld hl,(cli_execword) 
9fea e9				jp (hl) 
9feb			 
9feb			 
9feb			;    if not same 
9feb			;	scan for zero term 
9feb			;	get ptr for next word 
9feb			;	goto word comp 
9feb			 
9feb			.execpnskipword:	; get pointer to next word 
9feb 2a 42 ea			ld hl,(cli_nextword) 
9fee			 
9fee 7e				ld a,(hl) 
9fef fe 00			cp WORD_SYS_END 
9ff1			;	cp 0 
9ff1 28 09			jr z, .execendofdict			 ; at end of words 
9ff3			 
9ff3			if DEBUG_FORTH_PARSE_KEY 
9ff3						DMARK "KY4" 
9ff3			endif 
9ff3			if DEBUG_FORTH_PARSE_EXEC 
9ff3			 
9ff3				; see if disabled 
9ff3			 
9ff3			;	ld a, (os_view_disable) 
9ff3			;	cp '*' 
9ff3				ld a,(debug_vector) 
9ff3				cp $c9   ; RET 
9ff3				jr z, .noskip 
9ff3			 
9ff3			 
9ff3				ld de, .nowordfound 
9ff3				ld a, display_row_3 
9ff3				call str_at_display 
9ff3				call update_display 
9ff3				ld a, 100 
9ff3				call aDelayInMS 
9ff3				 
9ff3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ff3					call delay250ms 
9ff3				endif 
9ff3			.noskip:  
9ff3			 
9ff3			endif	 
9ff3			 
9ff3 2a 3e ea			ld hl,(cli_origptr) 
9ff6 22 40 ea			ld (cli_ptr),hl 
9ff9			 
9ff9			if DEBUG_FORTH_PARSE_KEY 
9ff9						DMARK "KY5" 
9ff9			endif 
9ff9 c3 9f 9f			jp .execpnword			; else go to next word 
9ffc			 
9ffc			.execendofdict:  
9ffc			 
9ffc			if DEBUG_FORTH_PARSE_KEY 
9ffc						DMARK "KYe" 
9ffc			endif 
9ffc			if DEBUG_FORTH_PARSE_EXEC 
9ffc				; see if disabled 
9ffc			 
9ffc			;	ld a, (os_view_disable) 
9ffc			;	cp '*' 
9ffc				ld a,(debug_vector) 
9ffc				cp $c9   ; ret 
9ffc				jr z, .ispskip 
9ffc			 
9ffc				call clear_display 
9ffc				call update_display 
9ffc				call delay1s 
9ffc				ld de, (cli_origptr) 
9ffc				ld a, display_row_1 
9ffc				call str_at_display 
9ffc				 
9ffc				ld de, .enddict 
9ffc				ld a, display_row_3 
9ffc				call str_at_display 
9ffc				call update_display 
9ffc				ld a, 100 
9ffc				call aDelayInMS 
9ffc				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ffc				call delay1s 
9ffc				call delay1s 
9ffc				call delay1s 
9ffc				endif 
9ffc			.ispskip:  
9ffc				 
9ffc			endif	 
9ffc			 
9ffc			 
9ffc			 
9ffc				; if the word is not a keyword then must be a literal so push it to stack 
9ffc			 
9ffc			; push token to stack to end of word 
9ffc			 
9ffc				STACKFRAME ON $1efe $2f9f 
9ffc				if DEBUG_STACK_IMB 
9ffc					if ON 
9ffc						exx 
9ffc						ld de, $1efe 
9ffc						ld a, d 
9ffc						ld hl, curframe 
9ffc						call hexout 
9ffc						ld a, e 
9ffc						ld hl, curframe+2 
9ffc						call hexout 
9ffc						ld hl, $1efe 
9ffc						push hl 
9ffc						ld hl, $2f9f 
9ffc						push hl 
9ffc						exx 
9ffc					endif 
9ffc				endif 
9ffc			endm 
# End of macro STACKFRAME
9ffc			 
9ffc 2a c2 e5		ld hl,(os_tok_ptr) 
9fff cd b0 9c		call forth_apush 
a002			 
a002				STACKFRAMECHK ON $1efe $2f9f 
a002				if DEBUG_STACK_IMB 
a002					if ON 
a002						exx 
a002						ld hl, $2f9f 
a002						pop de   ; $2f9f 
a002						call cmp16 
a002						jr nz, .spnosame 
a002						ld hl, $1efe 
a002						pop de   ; $1efe 
a002						call cmp16 
a002						jr z, .spfrsame 
a002						.spnosame: call showsperror 
a002						.spfrsame: nop 
a002						exx 
a002					endif 
a002				endif 
a002			endm 
# End of macro STACKFRAMECHK
a002			 
a002			execnext: 
a002			 
a002			if DEBUG_FORTH_PARSE_KEY 
a002						DMARK "KY>" 
a002			endif 
a002			; move past token to next word 
a002			 
a002 2a c2 e5		ld hl, (os_tok_ptr) 
a005 3e 00		ld a, 0 
a007 01 ff 00		ld bc, 255     ; input buffer size 
a00a ed b1		cpir 
a00c			 
a00c			if DEBUG_FORTH_PARSE_KEY 
a00c						DMARK "KY!" 
a00c				CALLMONITOR 
a00c			endif	 
a00c			; TODO this might place hl on the null, so will need to forward on??? 
a00c			;inc hl   ; see if this gets onto the next item 
a00c			 
a00c			 
a00c			; TODO pass a pointer to the buffer to push 
a00c			; TODO call function to push 
a00c			 
a00c			; look for end of input 
a00c			 
a00c			;inc hl 
a00c			;ld a,(hl) 
a00c			;cp FORTH_END_BUFFER 
a00c			;ret z 
a00c			 
a00c			 
a00c c3 85 9f		jp exec1 
a00f			 
a00f			 
a00f			 
a00f			 
a00f			 
a00f			 
a00f			 
a00f			 
a00f			 
a00f			findnexttok: 
a00f			 
a00f				; hl is pointer to move 
a00f				; de is the token to locate 
a00f			 
a00f					if DEBUG_FORTH 
a00f						DMARK "NTK" 
a00f						CALLMONITOR 
a00f					endif 
a00f d5				push de 
a010			 
a010			.fnt1:	 
a010				; find first char of token to locate 
a010			 
a010 1a				ld a, (de) 
a011 4f				ld c,a 
a012 7e				ld a,(hl) 
a013 cd 30 91			call toUpper 
a016					if DEBUG_FORTH 
a016						DMARK "NT1" 
a016						CALLMONITOR 
a016					endif 
a016 b9				cp c 
a017			 
a017 28 03			jr z, .fnt2cmpmorefirst	 
a019			 
a019				; first char not found move to next char 
a019			 
a019 23				inc hl 
a01a 18 f4			jr .fnt1 
a01c			 
a01c			.fnt2cmpmorefirst:	 
a01c				; first char of token found.  
a01c			 
a01c e5				push hl     ; save start of token just in case it is the right one 
a01d d9				exx 
a01e e1				pop hl        ; save it to hl' 
a01f d9				exx 
a020			 
a020			 
a020			.fnt2cmpmore:	 
a020				; compare the rest 
a020				 
a020 23				inc hl 
a021 13				inc de 
a022				 
a022 1a				ld a, (de) 
a023 4f				ld c,a 
a024 7e				ld a,(hl) 
a025 cd 30 91			call toUpper 
a028			 
a028					if DEBUG_FORTH 
a028						DMARK "NT2" 
a028						CALLMONITOR 
a028					endif 
a028				; c has the token to find char 
a028				; a has the mem to scan char 
a028			 
a028 b9				cp c 
a029 28 04			jr z,.fntmatch1 
a02b			 
a02b				; they are not the same 
a02b			 
a02b					if DEBUG_FORTH 
a02b						DMARK "NT3" 
a02b						CALLMONITOR 
a02b					endif 
a02b d1				pop de	; reset de token to look for 
a02c d5				push de 
a02d 18 e1			jr .fnt1 
a02f				 
a02f			.fntmatch1: 
a02f			 
a02f				; is the same char a null which means we might have a full hit? 
a02f					if DEBUG_FORTH 
a02f						DMARK "NT4" 
a02f						CALLMONITOR 
a02f					endif 
a02f			 
a02f fe 00			cp 0 
a031 28 0b			jr z, .fntmatchyes 
a033			 
a033				; are we at the end of the token to find? 
a033			 
a033					if DEBUG_FORTH 
a033						DMARK "NT5" 
a033						CALLMONITOR 
a033					endif 
a033 3e 00			ld a, 0 
a035 b9				cp c 
a036			 
a036 c2 20 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a039			 
a039					if DEBUG_FORTH 
a039						DMARK "NT6" 
a039						CALLMONITOR 
a039					endif 
a039				; token to find is exhusted but no match to stream 
a039			 
a039				; restore tok pointer and continue on 
a039 d1				pop de 
a03a d5				push de 
a03b c3 10 a0			jp .fnt1 
a03e			 
a03e			 
a03e			.fntmatchyes: 
a03e			 
a03e				; hl now contains the end of the found token 
a03e			 
a03e				; get rid of saved token pointer to find 
a03e			 
a03e d1				pop de 
a03f			 
a03f					if DEBUG_FORTH 
a03f						DMARK "NT9" 
a03f						CALLMONITOR 
a03f					endif 
a03f			 
a03f				; hl will be on the null term so forward on 
a03f			 
a03f				; get back the saved start of the token 
a03f			 
a03f d9				exx 
a040 e5				push hl     ; save start of token just in case it is the right one 
a041 d9				exx 
a042 e1				pop hl        ; save it to hl 
a043			 
a043 c9				ret 
a044			 
a044			 
a044			; LIST needs to find a specific token   
a044			; FORGET needs to find a spefici token 
a044			 
a044			; SAVE needs to find all tokens by flag 
a044			; WORDS just needs to scan through all  by flag 
a044			; UWORDS needs to scan through all by flag 
a044			 
a044			 
a044			; given hl as pointer to start of dict look up string 
a044			; return hl as pointer to start of word block 
a044			; or 0 if not found 
a044			 
a044			forth_find_tok: 
a044 c9				ret 
a045			 
a045			; given hl as pointer to dict structure 
a045			; move to the next dict block structure 
a045			 
a045			forth_tok_next: 
a045				; hl now points to the address of the next word pointer  
a045				; TODO skip compiled symbol for now 
a045			;	push de 
a045 23				inc hl 
a046 5e				ld e, (hl) 
a047 23				inc hl 
a048 56				ld d, (hl) 
a049 23				inc hl 
a04a			 
a04a eb				ex de,hl 
a04b			if DEBUG_FORTH_PARSE_NEXTWORD 
a04b				push bc 
a04b				ld bc, (cli_nextword) 
a04b						DMARK "NXW" 
a04b				CALLMONITOR 
a04b				pop bc 
a04b			endif 
a04b			;	pop de	 
a04b c9				ret 
a04c			 
a04c			 
a04c			 
a04c			; eof 
# End of file forth_parserv5.asm
a04c				include "forth_wordsv4.asm" 
a04c			 
a04c			; the core word dictionary v4 
a04c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a04c			 
a04c			; this is a linked list for each of the system words used 
a04c			; user defined words will follow the same format but will be in ram 
a04c			 
a04c			 
a04c			; 
a04c			; 
a04c			; define linked list: 
a04c			; 
a04c			; 1. compiled byte op code 
a04c			; 2. len of text word 
a04c			; 3. text word 
a04c			; 4. ptr to next dictionary word 
a04c			; 5. asm, calls etc for the word 
a04c			; 
a04c			;  if 1 == 0 then last word in dict  
a04c			;   
a04c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a04c			;  
a04c			;  
a04c			; create basic standard set of words 
a04c			; 
a04c			;  
a04c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a04c			; 2DUP 2DROP 2SWAP  
a04c			; @ C@ - get byte  
a04c			; ! C! - store byte 
a04c			; 0< true if less than zero 
a04c			; 0= true if zero 
a04c			; < >  
a04c			; = true if same 
a04c			; variables 
a04c			 
a04c			 
a04c			; Hardware specific words I may need 
a04c			; 
a04c			; IN OUT  
a04c			; calls to key util functions 
a04c			; calls to hardward abstraction stuff 
a04c			; easy control of frame buffers and lcd i/o 
a04c			; keyboard  
a04c			 
a04c			 
a04c			;DICT: macro 
a04c			; op_code, len, word, next 
a04c			;    word: 
a04c			;    db op_code 
a04c			;    ds word zero term 
a04c			;    dw next 
a04c			;    endm 
a04c			 
a04c			 
a04c			 
a04c			 
a04c			; op code 1 is a flag for user define words which are to be handled differently 
a04c			 
a04c			 
a04c			; 
a04c			; 
a04c			;    TODO on entry to a word this should be the expected environment 
a04c			;    hl - tos value if number then held, if string this is the ptr 
a04c			;    de -  
a04c			 
a04c			 
a04c			; opcode ranges 
a04c			; 0 - end of word dict 
a04c			; 255 - user define words 
a04c			 
a04c			sysdict: 
a04c			include "forth_opcodes.asm" 
a04c			; op codes for forth keywords 
a04c			; free to use code 0  
a04c				OPCODE_HEAP: equ  1 
a04c				OPCODE_EXEC: equ 2 
a04c				OPCODE_DUP: equ 3 
a04c				OPCODE_SWAP: equ 4 
a04c				OPCODE_COLN: equ 5 
a04c				OPCODE_SCOLN: equ 6 
a04c				OPCODE_DROP: equ 7 
a04c				OPCODE_DUP2: equ 8 
a04c				OPCODE_DROP2: equ 9 
a04c				OPCODE_SWAP2: equ 10 
a04c				OPCODE_AT: equ 11 
a04c				OPCODE_CAT: equ 12 
a04c				OPCODE_BANG: equ 13 
a04c				OPCODE_CBANG: equ 14 
a04c				OPCODE_SCALL: equ 15 
a04c				OPCODE_DEPTH: equ 16 
a04c				OPCODE_OVER: equ 17 
a04c				OPCODE_PAUSE: equ 18 
a04c				OPCODE_PAUSES: equ 19 
a04c				OPCODE_ROT: equ 20 
a04c			;free to reuse	OPCODE_WORDS: equ 21 
a04c			        OPCODE_NOT: equ 21 
a04c				OPCODE_UWORDS: equ 22 
a04c				OPCODE_BP: equ 23 
a04c				OPCODE_MONITOR: equ 24  
a04c				OPCODE_MALLOC: equ 25 
a04c				OPCODE_FREE: equ 26 
a04c				OPCODE_LIST: equ 27 
a04c				OPCODE_FORGET: equ 28 
a04c				OPCODE_NOP: equ 29 
a04c				OPCODE_COMO: equ 30 
a04c				OPCODE_COMC: equ 31 
a04c			;free to reuse	OPCODE_ENDCORE: equ 32 
a04c				OPCODE_AFTERSOUND: equ 33 
a04c				OPCODE_GP2: equ 34 
a04c				OPCODE_GP3: equ 35 
a04c				OPCODE_GP4: equ 36 
a04c				OPCODE_SIN: equ 37 
a04c				OPCODE_SOUT: equ 38 
a04c				OPCODE_SPIO: equ 39 
a04c				OPCODE_SPICEH: equ 40 
a04c				OPCODE_SPIOb: equ 41 
a04c				OPCODE_SPII: equ 42 
a04c				OPCODE_SESEL: equ 43 
a04c				OPCODE_CARTDEV: equ 44 
a04c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a04c				OPCODE_FB: equ 46 
a04c				OPCODE_EMIT: equ 47 
a04c				OPCODE_DOTH: equ 48 
a04c				OPCODE_DOTF: equ 49 
a04c				OPCODE_DOT: equ 50 
a04c				OPCODE_CLS: equ 51 
a04c				OPCODE_DRAW: equ 52 
a04c				OPCODE_DUMP: equ 53 
a04c				OPCODE_CDUMP: equ 54 
a04c				OPCODE_DAT: equ 55 
a04c				OPCODE_HOME: equ 56 
a04c				OPCODE_SPACE: equ 57 
a04c				OPCODE_SPACES: equ 58 
a04c				OPCODE_SCROLL: equ 59 
a04c				OPCODE_ATQ: equ 60 
a04c				OPCODE_AUTODSP: equ 61 
a04c				OPCODE_MENU: equ 62 
a04c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a04c				OPCODE_THEN: equ 64 
a04c				OPCODE_ELSE: equ 65 
a04c				OPCODE_DO: equ 66 
a04c				OPCODE_LOOP: equ 67 
a04c				OPCODE_I: equ 68 
a04c				OPCODE_DLOOP: equ 69  
a04c				OPCODE_REPEAT: equ 70  
a04c				OPCODE_UNTIL: equ 71 
a04c				OPCODE_ENDFLOW: equ 72 
a04c				OPCODE_WAITK: equ 73 
a04c				OPCODE_ACCEPT: equ 74 
a04c				OPCODE_EDIT: equ 75 
a04c			;free to reuse	OPCODE_ENDKEY: equ 76 
a04c				OPCODE_LZERO: equ 77 
a04c				OPCODE_TZERO: equ 78 
a04c				OPCODE_LESS: equ 79 
a04c				OPCODE_GT: equ 80 
a04c				OPCODE_EQUAL: equ 81  
a04c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a04c				OPCODE_NEG: equ 83 
a04c				OPCODE_DIV: equ 84 
a04c				OPCODE_MUL: equ 85 
a04c				OPCODE_MIN: equ 86 
a04c				OPCODE_MAX: equ 87 
a04c				OPCODE_RND16: equ 88 
a04c				OPCODE_RND8: equ 89 
a04c				OPCODE_RND: equ 90 
a04c			;free to reuse	OPCODE_ENDMATHS: equ 91  
a04c				OPCODE_BYNAME: equ 92 
a04c				OPCODE_DIR: equ 93 
a04c				OPCODE_SAVE: equ 94 
a04c				OPCODE_LOAD: equ 95 
a04c				OPCODE_BSAVE: equ 96 
a04c				OPCODE_BLOAD: equ 97 
a04c				OPCODE_SEO: equ 98  
a04c				OPCODE_SEI: equ 99 
a04c				OPCODE_SFREE: equ 100 
a04c				OPCODE_SIZE: equ 101 
a04c				OPCODE_CREATE: equ 102 
a04c				OPCODE_APPEND: equ 103 
a04c				OPCODE_SDEL: equ 104 
a04c				OPCODE_OPEN: equ 105 
a04c				OPCODE_READ: equ 106 
a04c				OPCODE_EOF: equ 106 
a04c				OPCODE_FORMAT: equ 107 
a04c				OPCODE_LABEL: equ 108 
a04c				OPCODE_LABELS: equ 109 
a04c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a04c				OPCODE_UPPER: equ 111 
a04c				OPCODE_LOWER: equ 112 
a04c				OPCODE_SUBSTR: equ 113 
a04c				OPCODE_LEFT: equ 114 
a04c				OPCODE_RIGHT: equ 115 
a04c				OPCODE_STR2NUM: equ 116 
a04c				OPCODE_NUM2STR: equ 117 
a04c				OPCODE_CONCAT: equ 118 
a04c				OPCODE_FIND: equ 119 
a04c				OPCODE_LEN: equ 120 
a04c				OPCODE_CHAR: equ 121 
a04c			; free to reuse	OPCODE_STRLEN: equ 122 
a04c			; free to reuse	OPCODE_ENDSTR: equ 123 
a04c				OPCODE_V0S: equ 124 
a04c				OPCODE_V0Q: equ 125 
a04c				OPCODE_V1S: equ 126 
a04c				OPCODE_V1Q: equ 127 
a04c				OPCODE_V2S: equ 128 
a04c				OPCODE_V2Q: equ 129 
a04c				OPCODE_V3S: equ 130 
a04c				OPCODE_V3Q: equ 131 
a04c			;free to reuse	OPCODE_END: equ 132 
a04c				OPCODE_ZDUP: equ 133 
a04c			 
a04c			; eof 
# End of file forth_opcodes.asm
a04c			 
a04c			include "forth_words_core.asm" 
a04c			 
a04c			; | ## Core Words 
a04c			 
a04c			;if MALLOC_4 
a04c			 
a04c			.HEAP: 
a04c			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a04c 15				db WORD_SYS_CORE+OPCODE_HEAP             
a04d 8b a0			dw .EXEC            
a04f 05				db 4 + 1 
a050 .. 00			db "HEAP",0              
a055				endm 
# End of macro CWHEAD
a055			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a055			; | | u1 - Current number of bytes in the heap 
a055			; | | u2 - Remaining bytes left on the heap 
a055			; | |  
a055			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a055			 
a055			 
a055				if DEBUG_FORTH_WORDS_KEY 
a055					DMARK "HEP" 
a055 f5				push af  
a056 3a 6a a0			ld a, (.dmark)  
a059 32 6b ee			ld (debug_mark),a  
a05c 3a 6b a0			ld a, (.dmark+1)  
a05f 32 6c ee			ld (debug_mark+1),a  
a062 3a 6c a0			ld a, (.dmark+2)  
a065 32 6d ee			ld (debug_mark+2),a  
a068 18 03			jr .pastdmark  
a06a ..			.dmark: db "HEP"  
a06d f1			.pastdmark: pop af  
a06e			endm  
# End of macro DMARK
a06e					CALLMONITOR 
a06e cd 6f ee			call debug_vector  
a071				endm  
# End of macro CALLMONITOR
a071				endif 
a071 2a ee e4			ld hl, (free_list )      
a074 11 f3 e4			ld de, heap_start 
a077			 
a077 ed 52			sbc hl, de  
a079			 
a079 cd 47 9b			call forth_push_numhl 
a07c			 
a07c			 
a07c ed 5b ee e4		ld de, (free_list )      
a080 21 9c e2			ld hl, heap_end 
a083			 
a083 ed 52			sbc hl, de 
a085			 
a085 cd 47 9b			call forth_push_numhl 
a088				 
a088			 
a088				 
a088			 
a088			 
a088			 
a088				NEXTW 
a088 c3 f4 9e			jp macro_next 
a08b				endm 
# End of macro NEXTW
a08b			;endif 
a08b			 
a08b			.EXEC: 
a08b			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a08b			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a08b			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a08b			;; > > 
a08b			;; > >   
a08b			;	STACKFRAME OFF $5efe $5f9f 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS_KEY 
a08b			;			DMARK "EXE" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			; 
a08b			;	FORTH_DSP_VALUEHL 
a08b			; 
a08b			;	FORTH_DSP_POP 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EX1" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;;	ld e,(hl) 
a08b			;;	inc hl 
a08b			;;	ld d,(hl) 
a08b			;;	ex de,hl 
a08b			; 
a08b			;;		if DEBUG_FORTH_WORDS 
a08b			;;			DMARK "EX2" 
a08b			;;			CALLMONITOR 
a08b			;;		endif 
a08b			;	push hl 
a08b			; 
a08b			;	;ld a, 0 
a08b			;	;ld a, FORTH_END_BUFFER 
a08b			;	call strlenz 
a08b			;	inc hl   ; include zero term to copy 
a08b			;	inc hl   ; include term 
a08b			;	inc hl   ; include term 
a08b			;	ld b,0 
a08b			;	ld c,l 
a08b			;	pop hl 
a08b			;	ld de, execscratch 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EX3" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;	ldir 
a08b			; 
a08b			; 
a08b			;	ld hl, execscratch 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EXe" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			; 
a08b			;	call forthparse 
a08b			;	call forthexec 
a08b			;;	call forthexec_cleanup 
a08b			;;	call forthparse 
a08b			;;	call forthexec 
a08b			; 
a08b			;	STACKFRAMECHK OFF $5efe $5f9f 
a08b			; 
a08b			;	; an immediate word so no need to process any more words 
a08b			;	ret 
a08b			;	NEXTW 
a08b			 
a08b			; dead code - old version  
a08b			;	FORTH_RSP_NEXT 
a08b			 
a08b			;  
a08b			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a08b			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a08b			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a08b			;	push hl 
a08b			;	push de 
a08b			;	push bc 
a08b			; 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS_KEY 
a08b			;			DMARK "EXR" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			; 
a08b			; 
a08b			; 
a08b			;	;v5 FORTH_DSP_VALUE 
a08b			;	FORTH_DSP_VALUEHL 
a08b			; 
a08b			;	; TODO do string type checks 
a08b			; 
a08b			;;v5	inc hl   ; skip type 
a08b			; 
a08b			;	push hl  ; source code  
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EX1" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;	ld a, 0 
a08b			;	call strlent 
a08b			; 
a08b			;	inc hl 
a08b			;	inc hl 
a08b			;	inc hl 
a08b			;	inc hl 
a08b			; 
a08b			;	push hl    ; size 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EX2" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;	call malloc 
a08b			; 
a08b			;	ex de, hl    ; de now contains malloc area 
a08b			;	pop bc   	; get byte count 
a08b			;	pop hl      ; get string to copy 
a08b			; 
a08b			;	push de     ; save malloc for free later 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EX3" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;	ldir       ; duplicate string 
a08b			; 
a08b			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a08b			;	 
a08b			;	; TODO fix the parse would be better than this...  
a08b			;	ex de, hl 
a08b			;	dec hl 
a08b			;	ld a, 0 
a08b			;	ld (hl), a 
a08b			;	dec hl 
a08b			;	ld a, ' ' 
a08b			;	ld (hl), a 
a08b			;	dec hl 
a08b			;	ld (hl), a 
a08b			; 
a08b			;	dec hl 
a08b			;	ld (hl), a 
a08b			; 
a08b			; 
a08b			;	FORTH_DSP_POP  
a08b			; 
a08b			;	pop hl     
a08b			;	push hl    ; save malloc area 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EX4" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			; 
a08b			;	call forthparse 
a08b			;	call forthexec 
a08b			;	 
a08b			;	pop hl 
a08b			;	if DEBUG_FORTH_WORDS 
a08b			;		DMARK "EX5" 
a08b			;		CALLMONITOR 
a08b			;	endif 
a08b			; 
a08b			;	if FORTH_ENABLE_FREE 
a08b			;	call free 
a08b			;	endif 
a08b			; 
a08b			;	if DEBUG_FORTH_WORDS 
a08b			;		DMARK "EX6" 
a08b			;		CALLMONITOR 
a08b			;	endif 
a08b			; 
a08b			;	pop bc 
a08b			;	pop de 
a08b			;	pop hl 
a08b			;;	FORTH_RSP_POP	  
a08b			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a08b			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a08b			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a08b			; 
a08b			;	if DEBUG_FORTH_WORDS 
a08b			;		DMARK "EX7" 
a08b			;		CALLMONITOR 
a08b			;	endif 
a08b			;	NEXTW 
a08b			 
a08b			;.STKEXEC: 
a08b			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a08b			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a08b			; 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS_KEY 
a08b			;			DMARK "STX" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			; 
a08b			;	FORTH_DSP_VALUEHL 
a08b			; 
a08b			;	ld (store_tmp1), hl    ; count 
a08b			; 
a08b			;	FORTH_DSP_POP 
a08b			;.stkexec1: 
a08b			;	ld hl, (store_tmp1)   ; count 
a08b			;	ld a, 0 
a08b			;	cp l 
a08b			;	ret z 
a08b			; 
a08b			;	dec hl 
a08b			;	ld (store_tmp1), hl    ; count 
a08b			;	 
a08b			;	FORTH_DSP_VALUEHL 
a08b			;	push hl 
a08b			;	 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EXp" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;	FORTH_DSP_POP 
a08b			; 
a08b			;	call strlenz 
a08b			;	inc hl   ; include zero term to copy 
a08b			;	inc hl   ; include zero term to copy 
a08b			;	inc hl   ; include zero term to copy 
a08b			;	ld b,0 
a08b			;	ld c,l 
a08b			;	pop hl 
a08b			;	ld de, execscratch 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EX3" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;	ldir 
a08b			; 
a08b			; 
a08b			;	ld hl, execscratch 
a08b			; 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EXP" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			; 
a08b			;	call forthparse 
a08b			;	ld hl, execscratch 
a08b			;		if DEBUG_FORTH_WORDS 
a08b			;			DMARK "EXx" 
a08b			;			CALLMONITOR 
a08b			;		endif 
a08b			;	call forthexec 
a08b			; 
a08b			;	jp .stkexec1 
a08b			; 
a08b			;	ret 
a08b			 
a08b			 
a08b			.DUP: 
a08b			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a08b 17				db WORD_SYS_CORE+OPCODE_DUP             
a08c 01 a1			dw .ZDUP            
a08e 04				db 3 + 1 
a08f .. 00			db "DUP",0              
a093				endm 
# End of macro CWHEAD
a093			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a093			 
a093				if DEBUG_FORTH_WORDS_KEY 
a093					DMARK "DUP" 
a093 f5				push af  
a094 3a a8 a0			ld a, (.dmark)  
a097 32 6b ee			ld (debug_mark),a  
a09a 3a a9 a0			ld a, (.dmark+1)  
a09d 32 6c ee			ld (debug_mark+1),a  
a0a0 3a aa a0			ld a, (.dmark+2)  
a0a3 32 6d ee			ld (debug_mark+2),a  
a0a6 18 03			jr .pastdmark  
a0a8 ..			.dmark: db "DUP"  
a0ab f1			.pastdmark: pop af  
a0ac			endm  
# End of macro DMARK
a0ac					CALLMONITOR 
a0ac cd 6f ee			call debug_vector  
a0af				endm  
# End of macro CALLMONITOR
a0af				endif 
a0af			 
a0af				FORTH_DSP 
a0af cd 04 9d			call macro_forth_dsp 
a0b2				endm 
# End of macro FORTH_DSP
a0b2			 
a0b2 7e				ld a, (HL) 
a0b3 fe 01			cp DS_TYPE_STR 
a0b5 20 25			jr nz, .dupinum 
a0b7			 
a0b7				; push another string 
a0b7			 
a0b7				FORTH_DSP_VALUEHL     		 
a0b7 cd 3e 9d			call macro_dsp_valuehl 
a0ba				endm 
# End of macro FORTH_DSP_VALUEHL
a0ba			 
a0ba			if DEBUG_FORTH_WORDS 
a0ba				DMARK "DUs" 
a0ba f5				push af  
a0bb 3a cf a0			ld a, (.dmark)  
a0be 32 6b ee			ld (debug_mark),a  
a0c1 3a d0 a0			ld a, (.dmark+1)  
a0c4 32 6c ee			ld (debug_mark+1),a  
a0c7 3a d1 a0			ld a, (.dmark+2)  
a0ca 32 6d ee			ld (debug_mark+2),a  
a0cd 18 03			jr .pastdmark  
a0cf ..			.dmark: db "DUs"  
a0d2 f1			.pastdmark: pop af  
a0d3			endm  
# End of macro DMARK
a0d3				CALLMONITOR 
a0d3 cd 6f ee			call debug_vector  
a0d6				endm  
# End of macro CALLMONITOR
a0d6			endif 
a0d6 cd b5 9b			call forth_push_str 
a0d9			 
a0d9				NEXTW 
a0d9 c3 f4 9e			jp macro_next 
a0dc				endm 
# End of macro NEXTW
a0dc			 
a0dc			 
a0dc			.dupinum: 
a0dc				 
a0dc			 
a0dc			 
a0dc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0dc cd 3e 9d			call macro_dsp_valuehl 
a0df				endm 
# End of macro FORTH_DSP_VALUEHL
a0df			 
a0df			; TODO add floating point number detection 
a0df			 
a0df			if DEBUG_FORTH_WORDS 
a0df				DMARK "DUi" 
a0df f5				push af  
a0e0 3a f4 a0			ld a, (.dmark)  
a0e3 32 6b ee			ld (debug_mark),a  
a0e6 3a f5 a0			ld a, (.dmark+1)  
a0e9 32 6c ee			ld (debug_mark+1),a  
a0ec 3a f6 a0			ld a, (.dmark+2)  
a0ef 32 6d ee			ld (debug_mark+2),a  
a0f2 18 03			jr .pastdmark  
a0f4 ..			.dmark: db "DUi"  
a0f7 f1			.pastdmark: pop af  
a0f8			endm  
# End of macro DMARK
a0f8				CALLMONITOR 
a0f8 cd 6f ee			call debug_vector  
a0fb				endm  
# End of macro CALLMONITOR
a0fb			endif 
a0fb			 
a0fb cd 47 9b			call forth_push_numhl 
a0fe				NEXTW 
a0fe c3 f4 9e			jp macro_next 
a101				endm 
# End of macro NEXTW
a101			.ZDUP: 
a101			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a101 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a102 39 a1			dw .SWAP            
a104 05				db 4 + 1 
a105 .. 00			db "?DUP",0              
a10a				endm 
# End of macro CWHEAD
a10a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a10a			 
a10a				if DEBUG_FORTH_WORDS_KEY 
a10a					DMARK "qDU" 
a10a f5				push af  
a10b 3a 1f a1			ld a, (.dmark)  
a10e 32 6b ee			ld (debug_mark),a  
a111 3a 20 a1			ld a, (.dmark+1)  
a114 32 6c ee			ld (debug_mark+1),a  
a117 3a 21 a1			ld a, (.dmark+2)  
a11a 32 6d ee			ld (debug_mark+2),a  
a11d 18 03			jr .pastdmark  
a11f ..			.dmark: db "qDU"  
a122 f1			.pastdmark: pop af  
a123			endm  
# End of macro DMARK
a123					CALLMONITOR 
a123 cd 6f ee			call debug_vector  
a126				endm  
# End of macro CALLMONITOR
a126				endif 
a126				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a126 cd 3e 9d			call macro_dsp_valuehl 
a129				endm 
# End of macro FORTH_DSP_VALUEHL
a129			 
a129 e5				push hl 
a12a			 
a12a				; is it a zero? 
a12a			 
a12a 3e 00			ld a, 0 
a12c 84				add h 
a12d 85				add l 
a12e			 
a12e e1				pop hl 
a12f			 
a12f fe 00			cp 0 
a131 28 03			jr z, .dup2orig 
a133			 
a133			 
a133 cd 47 9b			call forth_push_numhl 
a136			 
a136			 
a136			; TODO add floating point number detection 
a136			 
a136			.dup2orig: 
a136			 
a136				NEXTW 
a136 c3 f4 9e			jp macro_next 
a139				endm 
# End of macro NEXTW
a139			.SWAP: 
a139			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a139 18				db WORD_SYS_CORE+OPCODE_SWAP             
a13a 78 a1			dw .COLN            
a13c 05				db 4 + 1 
a13d .. 00			db "SWAP",0              
a142				endm 
# End of macro CWHEAD
a142			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a142				if DEBUG_FORTH_WORDS_KEY 
a142					DMARK "SWP" 
a142 f5				push af  
a143 3a 57 a1			ld a, (.dmark)  
a146 32 6b ee			ld (debug_mark),a  
a149 3a 58 a1			ld a, (.dmark+1)  
a14c 32 6c ee			ld (debug_mark+1),a  
a14f 3a 59 a1			ld a, (.dmark+2)  
a152 32 6d ee			ld (debug_mark+2),a  
a155 18 03			jr .pastdmark  
a157 ..			.dmark: db "SWP"  
a15a f1			.pastdmark: pop af  
a15b			endm  
# End of macro DMARK
a15b					CALLMONITOR 
a15b cd 6f ee			call debug_vector  
a15e				endm  
# End of macro CALLMONITOR
a15e				endif 
a15e			 
a15e			; TODO Use os stack swap memory 
a15e				FORTH_DSP_VALUEHL 
a15e cd 3e 9d			call macro_dsp_valuehl 
a161				endm 
# End of macro FORTH_DSP_VALUEHL
a161 e5				push hl     ; w2 
a162			 
a162				FORTH_DSP_POP 
a162 cd f6 9d			call macro_forth_dsp_pop 
a165				endm 
# End of macro FORTH_DSP_POP
a165			 
a165				FORTH_DSP_VALUEHL 
a165 cd 3e 9d			call macro_dsp_valuehl 
a168				endm 
# End of macro FORTH_DSP_VALUEHL
a168			 
a168				FORTH_DSP_POP 
a168 cd f6 9d			call macro_forth_dsp_pop 
a16b				endm 
# End of macro FORTH_DSP_POP
a16b			 
a16b d1				pop de     ; w2	, hl = w1 
a16c			 
a16c eb				ex de, hl 
a16d d5				push de 
a16e			 
a16e cd 47 9b			call forth_push_numhl 
a171			 
a171 e1				pop hl 
a172			 
a172 cd 47 9b			call forth_push_numhl 
a175				 
a175			 
a175				NEXTW 
a175 c3 f4 9e			jp macro_next 
a178				endm 
# End of macro NEXTW
a178			.COLN: 
a178			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a178 19				db WORD_SYS_CORE+OPCODE_COLN             
a179 04 a3			dw .SCOLN            
a17b 02				db 1 + 1 
a17c .. 00			db ":",0              
a17e				endm 
# End of macro CWHEAD
a17e			; | : ( -- )         Create new word | DONE 
a17e			 
a17e				if DEBUG_FORTH_WORDS_KEY 
a17e					DMARK "CLN" 
a17e f5				push af  
a17f 3a 93 a1			ld a, (.dmark)  
a182 32 6b ee			ld (debug_mark),a  
a185 3a 94 a1			ld a, (.dmark+1)  
a188 32 6c ee			ld (debug_mark+1),a  
a18b 3a 95 a1			ld a, (.dmark+2)  
a18e 32 6d ee			ld (debug_mark+2),a  
a191 18 03			jr .pastdmark  
a193 ..			.dmark: db "CLN"  
a196 f1			.pastdmark: pop af  
a197			endm  
# End of macro DMARK
a197					CALLMONITOR 
a197 cd 6f ee			call debug_vector  
a19a				endm  
# End of macro CALLMONITOR
a19a				endif 
a19a			STACKFRAME OFF $8efe $989f 
a19a				if DEBUG_STACK_IMB 
a19a					if OFF 
a19a						exx 
a19a						ld de, $8efe 
a19a						ld a, d 
a19a						ld hl, curframe 
a19a						call hexout 
a19a						ld a, e 
a19a						ld hl, curframe+2 
a19a						call hexout 
a19a						ld hl, $8efe 
a19a						push hl 
a19a						ld hl, $989f 
a19a						push hl 
a19a						exx 
a19a					endif 
a19a				endif 
a19a			endm 
# End of macro STACKFRAME
a19a			; get parser buffer length  of new word 
a19a			 
a19a			 
a19a			 
a19a				; move tok past this to start of name defintition 
a19a				; TODO get word to define 
a19a				; TODO Move past word token 
a19a				; TODO get length of string up to the ';' 
a19a			 
a19a 2a c2 e5		ld hl, (os_tok_ptr) 
a19d 23			inc hl 
a19e 23			inc hl 
a19f			 
a19f 3e 3b		ld a, ';' 
a1a1 cd 44 91		call strlent 
a1a4			 
a1a4 7d			ld a,l 
a1a5 32 b1 e2		ld (os_new_parse_len), a 
a1a8			 
a1a8			 
a1a8			if DEBUG_FORTH_UWORD 
a1a8 ed 5b c2 e5	ld de, (os_tok_ptr) 
a1ac					DMARK ":01" 
a1ac f5				push af  
a1ad 3a c1 a1			ld a, (.dmark)  
a1b0 32 6b ee			ld (debug_mark),a  
a1b3 3a c2 a1			ld a, (.dmark+1)  
a1b6 32 6c ee			ld (debug_mark+1),a  
a1b9 3a c3 a1			ld a, (.dmark+2)  
a1bc 32 6d ee			ld (debug_mark+2),a  
a1bf 18 03			jr .pastdmark  
a1c1 ..			.dmark: db ":01"  
a1c4 f1			.pastdmark: pop af  
a1c5			endm  
# End of macro DMARK
a1c5			CALLMONITOR 
a1c5 cd 6f ee			call debug_vector  
a1c8				endm  
# End of macro CALLMONITOR
a1c8			endif 
a1c8			 
a1c8			; 
a1c8			;  new word memory layout: 
a1c8			;  
a1c8			;    : adg 6666 ;  
a1c8			; 
a1c8			;    db   1     ; user defined word  
a1c8 23			inc hl    
a1c9			;    dw   sysdict 
a1c9 23			inc hl 
a1ca 23			inc hl 
a1cb			;    db <word len>+1 (for null) 
a1cb 23			inc hl 
a1cc			;    db .... <word> 
a1cc			; 
a1cc			 
a1cc 23			inc hl    ; some extras for the word preamble before the above 
a1cd 23			inc hl 
a1ce 23			inc hl 
a1cf 23			inc hl 
a1d0 23			inc hl 
a1d1 23			inc hl 
a1d2 23			inc hl  
a1d3 23			inc hl 
a1d4 23			inc hl 
a1d5 23			inc hl 
a1d6 23			inc hl 
a1d7 23			inc hl 
a1d8 23			inc hl 
a1d9 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a1da			;       exec word buffer 
a1da			;	<ptr word>   
a1da 23			inc hl 
a1db 23			inc hl 
a1dc			;       <word list><null term> 7F final term 
a1dc			 
a1dc			 
a1dc			if DEBUG_FORTH_UWORD 
a1dc					DMARK ":02" 
a1dc f5				push af  
a1dd 3a f1 a1			ld a, (.dmark)  
a1e0 32 6b ee			ld (debug_mark),a  
a1e3 3a f2 a1			ld a, (.dmark+1)  
a1e6 32 6c ee			ld (debug_mark+1),a  
a1e9 3a f3 a1			ld a, (.dmark+2)  
a1ec 32 6d ee			ld (debug_mark+2),a  
a1ef 18 03			jr .pastdmark  
a1f1 ..			.dmark: db ":02"  
a1f4 f1			.pastdmark: pop af  
a1f5			endm  
# End of macro DMARK
a1f5			CALLMONITOR 
a1f5 cd 6f ee			call debug_vector  
a1f8				endm  
# End of macro CALLMONITOR
a1f8			endif 
a1f8			 
a1f8			 
a1f8				; malloc the size 
a1f8			 
a1f8 cd ae 91			call malloc 
a1fb 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a1fe			 
a1fe			;    db   1     ; user defined word  
a1fe 3e 01			ld a, WORD_SYS_UWORD  
a200 77				ld (hl), a 
a201			 
a201 23			inc hl    
a202			;    dw   sysdict 
a202 11 4c a0		ld de, sysdict       ; continue on with the scan to the system dict 
a205 73			ld (hl), e 
a206 23			inc hl 
a207 72			ld (hl), d 
a208 23			inc hl 
a209			 
a209			 
a209			;    Setup dict word 
a209			 
a209 23			inc hl 
a20a 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a20d			 
a20d			; 1. get length of dict word 
a20d			 
a20d			 
a20d 2a c2 e5		ld hl, (os_tok_ptr) 
a210 23			inc hl 
a211 23			inc hl    ; position to start of dict word 
a212 3e 00		ld a, 0 
a214 cd 44 91		call strlent 
a217			 
a217			 
a217 23			inc hl    ; to include null??? 
a218			 
a218			; write length of dict word 
a218			 
a218 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a21c 1b			dec de 
a21d eb			ex de, hl 
a21e 73			ld (hl), e 
a21f eb			ex de, hl 
a220			 
a220			 
a220			 
a220			; copy  
a220 4d			ld c, l 
a221 06 00		ld b, 0 
a223 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a227 2a c2 e5		ld hl, (os_tok_ptr) 
a22a 23			inc hl 
a22b 23			inc hl    ; position to start of dict word 
a22c			 
a22c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a22c			 
a22c			; TODO need to convert word to upper case 
a22c			 
a22c			ucasetok:	 
a22c 7e			ld a,(hl) 
a22d cd 30 91		call toUpper 
a230 77			ld (hl),a 
a231 ed a0		ldi 
a233 f2 2c a2		jp p, ucasetok 
a236			 
a236			 
a236			 
a236			; de now points to start of where the word body code should be placed 
a236 ed 53 ad e2	ld (os_new_work_ptr), de 
a23a			; hl now points to the words to throw at forthexec which needs to be copied 
a23a 22 ab e2		ld (os_new_src_ptr), hl 
a23d			 
a23d			; TODO add 'call to forthexec' 
a23d			 
a23d			if DEBUG_FORTH_UWORD 
a23d c5			push bc 
a23e ed 4b b3 e2	ld bc, (os_new_malloc) 
a242					DMARK ":0x" 
a242 f5				push af  
a243 3a 57 a2			ld a, (.dmark)  
a246 32 6b ee			ld (debug_mark),a  
a249 3a 58 a2			ld a, (.dmark+1)  
a24c 32 6c ee			ld (debug_mark+1),a  
a24f 3a 59 a2			ld a, (.dmark+2)  
a252 32 6d ee			ld (debug_mark+2),a  
a255 18 03			jr .pastdmark  
a257 ..			.dmark: db ":0x"  
a25a f1			.pastdmark: pop af  
a25b			endm  
# End of macro DMARK
a25b			CALLMONITOR 
a25b cd 6f ee			call debug_vector  
a25e				endm  
# End of macro CALLMONITOR
a25e c1			pop bc 
a25f			endif 
a25f			 
a25f			 
a25f			; create word preamble which should be: 
a25f			 
a25f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a25f			 
a25f			;    ld hl, <word code> 
a25f			;    jp user_exec 
a25f			;    <word code bytes> 
a25f			 
a25f			 
a25f			;	inc de     ; TODO ??? or are we already past the word's null 
a25f eb			ex de, hl 
a260			 
a260 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a262			 
a262 23			inc hl 
a263 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a266 23			inc hl 
a267			 
a267 23			inc hl 
a268 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a26a			 
a26a 01 e2 cb		ld bc, user_exec 
a26d 23			inc hl 
a26e 71			ld (hl), c     ; poke address of user_exec 
a26f 23			inc hl 
a270 70			ld (hl), b     
a271			; 
a271			;	inc hl 
a271			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a271			; 
a271			; 
a271			;	ld bc, macro_forth_rsp_next 
a271			;	inc hl 
a271			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a271			;	inc hl 
a271			;	ld (hl), b     
a271			; 
a271			;	inc hl 
a271			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a271			; 
a271			; 
a271			;	inc hl 
a271			;	ld bc, forthexec 
a271			;	ld (hl), c     ; poke address of forthexec 
a271			;	inc hl 
a271			;	ld (hl), b      
a271			; 
a271			;	inc hl 
a271			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a271			; 
a271			;	ld bc, user_dict_next 
a271			;	inc hl 
a271			;	ld (hl), c     ; poke address of forthexec 
a271			;	inc hl 
a271			;	ld (hl), b      
a271			 
a271			; hl is now where we need to copy the word byte data to save this 
a271			 
a271 23			inc hl 
a272 22 a9 e2		ld (os_new_exec), hl 
a275			 
a275			; copy definition 
a275			 
a275 eb			ex de, hl 
a276			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a276			;	inc de    ; skip the PC for this parse 
a276 3a b1 e2		ld a, (os_new_parse_len) 
a279 4f			ld c, a 
a27a 06 00		ld b, 0 
a27c ed b0		ldir		 ; copy defintion 
a27e			 
a27e			 
a27e			; poke the address of where the new word bytes live for forthexec 
a27e			 
a27e 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a281			 
a281 ed 5b a9 e2	ld de, (os_new_exec)      
a285			 
a285 73			ld (hl), e 
a286 23			inc hl 
a287 72			ld (hl), d 
a288			 
a288				; TODO copy last user dict word next link to this word 
a288				; TODO update last user dict word to point to this word 
a288			; 
a288			; hl f923 de 812a ; bc 811a 
a288			 
a288			if DEBUG_FORTH_UWORD 
a288 c5			push bc 
a289 ed 4b b3 e2	ld bc, (os_new_malloc) 
a28d					DMARK ":0A" 
a28d f5				push af  
a28e 3a a2 a2			ld a, (.dmark)  
a291 32 6b ee			ld (debug_mark),a  
a294 3a a3 a2			ld a, (.dmark+1)  
a297 32 6c ee			ld (debug_mark+1),a  
a29a 3a a4 a2			ld a, (.dmark+2)  
a29d 32 6d ee			ld (debug_mark+2),a  
a2a0 18 03			jr .pastdmark  
a2a2 ..			.dmark: db ":0A"  
a2a5 f1			.pastdmark: pop af  
a2a6			endm  
# End of macro DMARK
a2a6			CALLMONITOR 
a2a6 cd 6f ee			call debug_vector  
a2a9				endm  
# End of macro CALLMONITOR
a2a9 c1			pop bc 
a2aa			endif 
a2aa			if DEBUG_FORTH_UWORD 
a2aa c5			push bc 
a2ab ed 4b b3 e2	ld bc, (os_new_malloc) 
a2af 03			inc bc 
a2b0 03			inc bc 
a2b1 03			inc bc 
a2b2 03			inc bc 
a2b3 03			inc bc 
a2b4 03			inc bc 
a2b5 03			inc bc 
a2b6 03			inc bc 
a2b7			 
a2b7					DMARK ":0B" 
a2b7 f5				push af  
a2b8 3a cc a2			ld a, (.dmark)  
a2bb 32 6b ee			ld (debug_mark),a  
a2be 3a cd a2			ld a, (.dmark+1)  
a2c1 32 6c ee			ld (debug_mark+1),a  
a2c4 3a ce a2			ld a, (.dmark+2)  
a2c7 32 6d ee			ld (debug_mark+2),a  
a2ca 18 03			jr .pastdmark  
a2cc ..			.dmark: db ":0B"  
a2cf f1			.pastdmark: pop af  
a2d0			endm  
# End of macro DMARK
a2d0			CALLMONITOR 
a2d0 cd 6f ee			call debug_vector  
a2d3				endm  
# End of macro CALLMONITOR
a2d3 c1			pop bc 
a2d4			endif 
a2d4			 
a2d4			; update word dict linked list for new word 
a2d4			 
a2d4			 
a2d4 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2d7 23			inc hl     ; move to next work linked list ptr 
a2d8			 
a2d8 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a2dc 73			ld (hl), e 
a2dd 23			inc hl 
a2de 72			ld (hl), d 
a2df			 
a2df			if DEBUG_FORTH_UWORD 
a2df ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2e3			endif 
a2e3			 
a2e3 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2e7			 
a2e7			 
a2e7			if DEBUG_FORTH_UWORD 
a2e7					DMARK ":0+" 
a2e7 f5				push af  
a2e8 3a fc a2			ld a, (.dmark)  
a2eb 32 6b ee			ld (debug_mark),a  
a2ee 3a fd a2			ld a, (.dmark+1)  
a2f1 32 6c ee			ld (debug_mark+1),a  
a2f4 3a fe a2			ld a, (.dmark+2)  
a2f7 32 6d ee			ld (debug_mark+2),a  
a2fa 18 03			jr .pastdmark  
a2fc ..			.dmark: db ":0+"  
a2ff f1			.pastdmark: pop af  
a300			endm  
# End of macro DMARK
a300			CALLMONITOR 
a300 cd 6f ee			call debug_vector  
a303				endm  
# End of macro CALLMONITOR
a303			endif 
a303			 
a303			STACKFRAMECHK OFF $8efe $989f 
a303				if DEBUG_STACK_IMB 
a303					if OFF 
a303						exx 
a303						ld hl, $989f 
a303						pop de   ; $989f 
a303						call cmp16 
a303						jr nz, .spnosame 
a303						ld hl, $8efe 
a303						pop de   ; $8efe 
a303						call cmp16 
a303						jr z, .spfrsame 
a303						.spnosame: call showsperror 
a303						.spfrsame: nop 
a303						exx 
a303					endif 
a303				endif 
a303			endm 
# End of macro STACKFRAMECHK
a303			 
a303 c9			ret    ; dont process any remaining parser tokens as they form new word 
a304			 
a304			 
a304			 
a304			 
a304			;		NEXT 
a304			.SCOLN: 
a304			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a304 06			db OPCODE_SCOLN 
a305 50 a3		dw .DROP 
a307 02			db 2 
a308 .. 00		db ";",0           
a30a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a30a				if DEBUG_FORTH_WORDS_KEY 
a30a					DMARK "SCN" 
a30a f5				push af  
a30b 3a 1f a3			ld a, (.dmark)  
a30e 32 6b ee			ld (debug_mark),a  
a311 3a 20 a3			ld a, (.dmark+1)  
a314 32 6c ee			ld (debug_mark+1),a  
a317 3a 21 a3			ld a, (.dmark+2)  
a31a 32 6d ee			ld (debug_mark+2),a  
a31d 18 03			jr .pastdmark  
a31f ..			.dmark: db "SCN"  
a322 f1			.pastdmark: pop af  
a323			endm  
# End of macro DMARK
a323					CALLMONITOR 
a323 cd 6f ee			call debug_vector  
a326				endm  
# End of macro CALLMONITOR
a326				endif 
a326				FORTH_RSP_TOS 
a326 cd 05 9b			call macro_forth_rsp_tos 
a329				endm 
# End of macro FORTH_RSP_TOS
a329 e5				push hl 
a32a				FORTH_RSP_POP 
a32a cd 0f 9b			call macro_forth_rsp_pop 
a32d				endm 
# End of macro FORTH_RSP_POP
a32d e1				pop hl 
a32e			;		ex de,hl 
a32e 22 c2 e5			ld (os_tok_ptr),hl 
a331			 
a331			if DEBUG_FORTH_UWORD 
a331					DMARK "SCL" 
a331 f5				push af  
a332 3a 46 a3			ld a, (.dmark)  
a335 32 6b ee			ld (debug_mark),a  
a338 3a 47 a3			ld a, (.dmark+1)  
a33b 32 6c ee			ld (debug_mark+1),a  
a33e 3a 48 a3			ld a, (.dmark+2)  
a341 32 6d ee			ld (debug_mark+2),a  
a344 18 03			jr .pastdmark  
a346 ..			.dmark: db "SCL"  
a349 f1			.pastdmark: pop af  
a34a			endm  
# End of macro DMARK
a34a			CALLMONITOR 
a34a cd 6f ee			call debug_vector  
a34d				endm  
# End of macro CALLMONITOR
a34d			endif 
a34d				NEXTW 
a34d c3 f4 9e			jp macro_next 
a350				endm 
# End of macro NEXTW
a350			 
a350			.DROP: 
a350			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a350 1b				db WORD_SYS_CORE+OPCODE_DROP             
a351 7b a3			dw .DUP2            
a353 05				db 4 + 1 
a354 .. 00			db "DROP",0              
a359				endm 
# End of macro CWHEAD
a359			; | DROP ( w -- )   drop the TOS item   | DONE 
a359				if DEBUG_FORTH_WORDS_KEY 
a359					DMARK "DRP" 
a359 f5				push af  
a35a 3a 6e a3			ld a, (.dmark)  
a35d 32 6b ee			ld (debug_mark),a  
a360 3a 6f a3			ld a, (.dmark+1)  
a363 32 6c ee			ld (debug_mark+1),a  
a366 3a 70 a3			ld a, (.dmark+2)  
a369 32 6d ee			ld (debug_mark+2),a  
a36c 18 03			jr .pastdmark  
a36e ..			.dmark: db "DRP"  
a371 f1			.pastdmark: pop af  
a372			endm  
# End of macro DMARK
a372					CALLMONITOR 
a372 cd 6f ee			call debug_vector  
a375				endm  
# End of macro CALLMONITOR
a375				endif 
a375				FORTH_DSP_POP 
a375 cd f6 9d			call macro_forth_dsp_pop 
a378				endm 
# End of macro FORTH_DSP_POP
a378				NEXTW 
a378 c3 f4 9e			jp macro_next 
a37b				endm 
# End of macro NEXTW
a37b			.DUP2: 
a37b			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a37b 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a37c c0 a3			dw .DROP2            
a37e 05				db 4 + 1 
a37f .. 00			db "2DUP",0              
a384				endm 
# End of macro CWHEAD
a384			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a384				if DEBUG_FORTH_WORDS_KEY 
a384					DMARK "2DU" 
a384 f5				push af  
a385 3a 99 a3			ld a, (.dmark)  
a388 32 6b ee			ld (debug_mark),a  
a38b 3a 9a a3			ld a, (.dmark+1)  
a38e 32 6c ee			ld (debug_mark+1),a  
a391 3a 9b a3			ld a, (.dmark+2)  
a394 32 6d ee			ld (debug_mark+2),a  
a397 18 03			jr .pastdmark  
a399 ..			.dmark: db "2DU"  
a39c f1			.pastdmark: pop af  
a39d			endm  
# End of macro DMARK
a39d					CALLMONITOR 
a39d cd 6f ee			call debug_vector  
a3a0				endm  
# End of macro CALLMONITOR
a3a0				endif 
a3a0				FORTH_DSP_VALUEHL 
a3a0 cd 3e 9d			call macro_dsp_valuehl 
a3a3				endm 
# End of macro FORTH_DSP_VALUEHL
a3a3 e5				push hl      ; 2 
a3a4			 
a3a4				FORTH_DSP_POP 
a3a4 cd f6 9d			call macro_forth_dsp_pop 
a3a7				endm 
# End of macro FORTH_DSP_POP
a3a7				 
a3a7				FORTH_DSP_VALUEHL 
a3a7 cd 3e 9d			call macro_dsp_valuehl 
a3aa				endm 
# End of macro FORTH_DSP_VALUEHL
a3aa			;		push hl      ; 1 
a3aa			 
a3aa				FORTH_DSP_POP 
a3aa cd f6 9d			call macro_forth_dsp_pop 
a3ad				endm 
# End of macro FORTH_DSP_POP
a3ad			 
a3ad			;		pop hl       ; 1 
a3ad d1				pop de       ; 2 
a3ae			 
a3ae cd 47 9b			call forth_push_numhl 
a3b1 eb				ex de, hl 
a3b2 cd 47 9b			call forth_push_numhl 
a3b5			 
a3b5				 
a3b5 eb				ex de, hl 
a3b6			 
a3b6 cd 47 9b			call forth_push_numhl 
a3b9 eb				ex de, hl 
a3ba cd 47 9b			call forth_push_numhl 
a3bd			 
a3bd			 
a3bd				NEXTW 
a3bd c3 f4 9e			jp macro_next 
a3c0				endm 
# End of macro NEXTW
a3c0			.DROP2: 
a3c0			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3c0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3c1 ef a3			dw .SWAP2            
a3c3 06				db 5 + 1 
a3c4 .. 00			db "2DROP",0              
a3ca				endm 
# End of macro CWHEAD
a3ca			; | 2DROP ( w w -- )    Double drop | DONE 
a3ca				if DEBUG_FORTH_WORDS_KEY 
a3ca					DMARK "2DR" 
a3ca f5				push af  
a3cb 3a df a3			ld a, (.dmark)  
a3ce 32 6b ee			ld (debug_mark),a  
a3d1 3a e0 a3			ld a, (.dmark+1)  
a3d4 32 6c ee			ld (debug_mark+1),a  
a3d7 3a e1 a3			ld a, (.dmark+2)  
a3da 32 6d ee			ld (debug_mark+2),a  
a3dd 18 03			jr .pastdmark  
a3df ..			.dmark: db "2DR"  
a3e2 f1			.pastdmark: pop af  
a3e3			endm  
# End of macro DMARK
a3e3					CALLMONITOR 
a3e3 cd 6f ee			call debug_vector  
a3e6				endm  
# End of macro CALLMONITOR
a3e6				endif 
a3e6				FORTH_DSP_POP 
a3e6 cd f6 9d			call macro_forth_dsp_pop 
a3e9				endm 
# End of macro FORTH_DSP_POP
a3e9				FORTH_DSP_POP 
a3e9 cd f6 9d			call macro_forth_dsp_pop 
a3ec				endm 
# End of macro FORTH_DSP_POP
a3ec				NEXTW 
a3ec c3 f4 9e			jp macro_next 
a3ef				endm 
# End of macro NEXTW
a3ef			.SWAP2: 
a3ef			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3ef 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3f0 18 a4			dw .AT            
a3f2 06				db 5 + 1 
a3f3 .. 00			db "2SWAP",0              
a3f9				endm 
# End of macro CWHEAD
a3f9			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3f9				if DEBUG_FORTH_WORDS_KEY 
a3f9					DMARK "2SW" 
a3f9 f5				push af  
a3fa 3a 0e a4			ld a, (.dmark)  
a3fd 32 6b ee			ld (debug_mark),a  
a400 3a 0f a4			ld a, (.dmark+1)  
a403 32 6c ee			ld (debug_mark+1),a  
a406 3a 10 a4			ld a, (.dmark+2)  
a409 32 6d ee			ld (debug_mark+2),a  
a40c 18 03			jr .pastdmark  
a40e ..			.dmark: db "2SW"  
a411 f1			.pastdmark: pop af  
a412			endm  
# End of macro DMARK
a412					CALLMONITOR 
a412 cd 6f ee			call debug_vector  
a415				endm  
# End of macro CALLMONITOR
a415				endif 
a415			; TODO Use os stack swap memory 
a415				NEXTW 
a415 c3 f4 9e			jp macro_next 
a418				endm 
# End of macro NEXTW
a418			.AT: 
a418			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a418 1f				db WORD_SYS_CORE+OPCODE_AT             
a419 4a a4			dw .CAT            
a41b 02				db 1 + 1 
a41c .. 00			db "@",0              
a41e				endm 
# End of macro CWHEAD
a41e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a41e			 
a41e				if DEBUG_FORTH_WORDS_KEY 
a41e					DMARK "AT." 
a41e f5				push af  
a41f 3a 33 a4			ld a, (.dmark)  
a422 32 6b ee			ld (debug_mark),a  
a425 3a 34 a4			ld a, (.dmark+1)  
a428 32 6c ee			ld (debug_mark+1),a  
a42b 3a 35 a4			ld a, (.dmark+2)  
a42e 32 6d ee			ld (debug_mark+2),a  
a431 18 03			jr .pastdmark  
a433 ..			.dmark: db "AT."  
a436 f1			.pastdmark: pop af  
a437			endm  
# End of macro DMARK
a437					CALLMONITOR 
a437 cd 6f ee			call debug_vector  
a43a				endm  
# End of macro CALLMONITOR
a43a				endif 
a43a			.getbyteat:	 
a43a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a43a cd 3e 9d			call macro_dsp_valuehl 
a43d				endm 
# End of macro FORTH_DSP_VALUEHL
a43d				 
a43d			;		push hl 
a43d			 
a43d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a43d cd f6 9d			call macro_forth_dsp_pop 
a440				endm 
# End of macro FORTH_DSP_POP
a440			 
a440			;		pop hl 
a440			 
a440 7e				ld a, (hl) 
a441			 
a441 6f				ld l, a 
a442 26 00			ld h, 0 
a444 cd 47 9b			call forth_push_numhl 
a447			 
a447				NEXTW 
a447 c3 f4 9e			jp macro_next 
a44a				endm 
# End of macro NEXTW
a44a			.CAT: 
a44a			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a44a 20				db WORD_SYS_CORE+OPCODE_CAT             
a44b 73 a4			dw .BANG            
a44d 03				db 2 + 1 
a44e .. 00			db "C@",0              
a451				endm 
# End of macro CWHEAD
a451			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a451				if DEBUG_FORTH_WORDS_KEY 
a451					DMARK "CAA" 
a451 f5				push af  
a452 3a 66 a4			ld a, (.dmark)  
a455 32 6b ee			ld (debug_mark),a  
a458 3a 67 a4			ld a, (.dmark+1)  
a45b 32 6c ee			ld (debug_mark+1),a  
a45e 3a 68 a4			ld a, (.dmark+2)  
a461 32 6d ee			ld (debug_mark+2),a  
a464 18 03			jr .pastdmark  
a466 ..			.dmark: db "CAA"  
a469 f1			.pastdmark: pop af  
a46a			endm  
# End of macro DMARK
a46a					CALLMONITOR 
a46a cd 6f ee			call debug_vector  
a46d				endm  
# End of macro CALLMONITOR
a46d				endif 
a46d c3 3a a4			jp .getbyteat 
a470				NEXTW 
a470 c3 f4 9e			jp macro_next 
a473				endm 
# End of macro NEXTW
a473			.BANG: 
a473			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a473 21				db WORD_SYS_CORE+OPCODE_BANG             
a474 a9 a4			dw .CBANG            
a476 02				db 1 + 1 
a477 .. 00			db "!",0              
a479				endm 
# End of macro CWHEAD
a479			; | ! ( x w -- ) Store x at address w      | DONE 
a479				if DEBUG_FORTH_WORDS_KEY 
a479					DMARK "BNG" 
a479 f5				push af  
a47a 3a 8e a4			ld a, (.dmark)  
a47d 32 6b ee			ld (debug_mark),a  
a480 3a 8f a4			ld a, (.dmark+1)  
a483 32 6c ee			ld (debug_mark+1),a  
a486 3a 90 a4			ld a, (.dmark+2)  
a489 32 6d ee			ld (debug_mark+2),a  
a48c 18 03			jr .pastdmark  
a48e ..			.dmark: db "BNG"  
a491 f1			.pastdmark: pop af  
a492			endm  
# End of macro DMARK
a492					CALLMONITOR 
a492 cd 6f ee			call debug_vector  
a495				endm  
# End of macro CALLMONITOR
a495				endif 
a495			 
a495			.storebyteat:		 
a495				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a495 cd 3e 9d			call macro_dsp_valuehl 
a498				endm 
# End of macro FORTH_DSP_VALUEHL
a498				 
a498 e5				push hl 
a499			 
a499				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a499 cd f6 9d			call macro_forth_dsp_pop 
a49c				endm 
# End of macro FORTH_DSP_POP
a49c			 
a49c				; get byte to poke 
a49c			 
a49c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a49c cd 3e 9d			call macro_dsp_valuehl 
a49f				endm 
# End of macro FORTH_DSP_VALUEHL
a49f e5				push hl 
a4a0			 
a4a0			 
a4a0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a0 cd f6 9d			call macro_forth_dsp_pop 
a4a3				endm 
# End of macro FORTH_DSP_POP
a4a3			 
a4a3			 
a4a3 d1				pop de 
a4a4 e1				pop hl 
a4a5			 
a4a5 73				ld (hl),e 
a4a6			 
a4a6			 
a4a6				NEXTW 
a4a6 c3 f4 9e			jp macro_next 
a4a9				endm 
# End of macro NEXTW
a4a9			.CBANG: 
a4a9			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a4a9 22				db WORD_SYS_CORE+OPCODE_CBANG             
a4aa d2 a4			dw .SCALL            
a4ac 03				db 2 + 1 
a4ad .. 00			db "C!",0              
a4b0				endm 
# End of macro CWHEAD
a4b0			; | C!  ( x w -- ) Store x at address w  | DONE 
a4b0				if DEBUG_FORTH_WORDS_KEY 
a4b0					DMARK "CBA" 
a4b0 f5				push af  
a4b1 3a c5 a4			ld a, (.dmark)  
a4b4 32 6b ee			ld (debug_mark),a  
a4b7 3a c6 a4			ld a, (.dmark+1)  
a4ba 32 6c ee			ld (debug_mark+1),a  
a4bd 3a c7 a4			ld a, (.dmark+2)  
a4c0 32 6d ee			ld (debug_mark+2),a  
a4c3 18 03			jr .pastdmark  
a4c5 ..			.dmark: db "CBA"  
a4c8 f1			.pastdmark: pop af  
a4c9			endm  
# End of macro DMARK
a4c9					CALLMONITOR 
a4c9 cd 6f ee			call debug_vector  
a4cc				endm  
# End of macro CALLMONITOR
a4cc				endif 
a4cc c3 95 a4			jp .storebyteat 
a4cf				NEXTW 
a4cf c3 f4 9e			jp macro_next 
a4d2				endm 
# End of macro NEXTW
a4d2			.SCALL: 
a4d2			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4d2 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4d3 06 a5			dw .DEPTH            
a4d5 05				db 4 + 1 
a4d6 .. 00			db "CALL",0              
a4db				endm 
# End of macro CWHEAD
a4db			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4db				if DEBUG_FORTH_WORDS_KEY 
a4db					DMARK "CLL" 
a4db f5				push af  
a4dc 3a f0 a4			ld a, (.dmark)  
a4df 32 6b ee			ld (debug_mark),a  
a4e2 3a f1 a4			ld a, (.dmark+1)  
a4e5 32 6c ee			ld (debug_mark+1),a  
a4e8 3a f2 a4			ld a, (.dmark+2)  
a4eb 32 6d ee			ld (debug_mark+2),a  
a4ee 18 03			jr .pastdmark  
a4f0 ..			.dmark: db "CLL"  
a4f3 f1			.pastdmark: pop af  
a4f4			endm  
# End of macro DMARK
a4f4					CALLMONITOR 
a4f4 cd 6f ee			call debug_vector  
a4f7				endm  
# End of macro CALLMONITOR
a4f7				endif 
a4f7			 
a4f7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4f7 cd 3e 9d			call macro_dsp_valuehl 
a4fa				endm 
# End of macro FORTH_DSP_VALUEHL
a4fa			 
a4fa			;		push hl 
a4fa			 
a4fa				; destroy value TOS 
a4fa			 
a4fa				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4fa cd f6 9d			call macro_forth_dsp_pop 
a4fd				endm 
# End of macro FORTH_DSP_POP
a4fd			 
a4fd					 
a4fd			;		pop hl 
a4fd			 
a4fd				; how to do a call with hl???? save SP? 
a4fd cd 98 9e			call forth_call_hl 
a500			 
a500			 
a500				; TODO push value back onto stack for another op etc 
a500			 
a500 cd 47 9b			call forth_push_numhl 
a503				NEXTW 
a503 c3 f4 9e			jp macro_next 
a506				endm 
# End of macro NEXTW
a506			.DEPTH: 
a506			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a506 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a507 43 a5			dw .OVER            
a509 06				db 5 + 1 
a50a .. 00			db "DEPTH",0              
a510				endm 
# End of macro CWHEAD
a510			; | DEPTH ( -- u ) Push count of stack | DONE 
a510				; take current TOS and remove from base value div by two to get count 
a510				if DEBUG_FORTH_WORDS_KEY 
a510					DMARK "DEP" 
a510 f5				push af  
a511 3a 25 a5			ld a, (.dmark)  
a514 32 6b ee			ld (debug_mark),a  
a517 3a 26 a5			ld a, (.dmark+1)  
a51a 32 6c ee			ld (debug_mark+1),a  
a51d 3a 27 a5			ld a, (.dmark+2)  
a520 32 6d ee			ld (debug_mark+2),a  
a523 18 03			jr .pastdmark  
a525 ..			.dmark: db "DEP"  
a528 f1			.pastdmark: pop af  
a529			endm  
# End of macro DMARK
a529					CALLMONITOR 
a529 cd 6f ee			call debug_vector  
a52c				endm  
# End of macro CALLMONITOR
a52c				endif 
a52c			 
a52c			 
a52c 2a ee e9		ld hl, (cli_data_sp) 
a52f 11 28 e8		ld de, cli_data_stack 
a532 ed 52		sbc hl,de 
a534			 
a534			; div by size of stack item 
a534			 
a534 5d			ld e,l 
a535 0e 03		ld c, 3 
a537 cd 6b 8c		call Div8 
a53a			 
a53a 6f			ld l,a 
a53b 26 00		ld h,0 
a53d			 
a53d			;srl h 
a53d			;rr l 
a53d			 
a53d cd 47 9b			call forth_push_numhl 
a540				NEXTW 
a540 c3 f4 9e			jp macro_next 
a543				endm 
# End of macro NEXTW
a543			.OVER: 
a543			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a543 42				db WORD_SYS_CORE+46             
a544 8a a5			dw .PAUSE            
a546 05				db 4 + 1 
a547 .. 00			db "OVER",0              
a54c				endm 
# End of macro CWHEAD
a54c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a54c				if DEBUG_FORTH_WORDS_KEY 
a54c					DMARK "OVR" 
a54c f5				push af  
a54d 3a 61 a5			ld a, (.dmark)  
a550 32 6b ee			ld (debug_mark),a  
a553 3a 62 a5			ld a, (.dmark+1)  
a556 32 6c ee			ld (debug_mark+1),a  
a559 3a 63 a5			ld a, (.dmark+2)  
a55c 32 6d ee			ld (debug_mark+2),a  
a55f 18 03			jr .pastdmark  
a561 ..			.dmark: db "OVR"  
a564 f1			.pastdmark: pop af  
a565			endm  
# End of macro DMARK
a565					CALLMONITOR 
a565 cd 6f ee			call debug_vector  
a568				endm  
# End of macro CALLMONITOR
a568				endif 
a568			 
a568			; TODO Use os stack swap memory 
a568				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a568 cd 3e 9d			call macro_dsp_valuehl 
a56b				endm 
# End of macro FORTH_DSP_VALUEHL
a56b e5				push hl    ; n2 
a56c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a56c cd f6 9d			call macro_forth_dsp_pop 
a56f				endm 
# End of macro FORTH_DSP_POP
a56f			 
a56f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a56f cd 3e 9d			call macro_dsp_valuehl 
a572				endm 
# End of macro FORTH_DSP_VALUEHL
a572 e5				push hl    ; n1 
a573				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a573 cd f6 9d			call macro_forth_dsp_pop 
a576				endm 
# End of macro FORTH_DSP_POP
a576			 
a576 d1				pop de     ; n1 
a577 e1				pop hl     ; n2 
a578			 
a578 d5				push de 
a579 e5				push hl 
a57a d5				push de 
a57b			 
a57b				; push back  
a57b			 
a57b e1				pop hl 
a57c cd 47 9b			call forth_push_numhl 
a57f e1				pop hl 
a580 cd 47 9b			call forth_push_numhl 
a583 e1				pop hl 
a584 cd 47 9b			call forth_push_numhl 
a587				NEXTW 
a587 c3 f4 9e			jp macro_next 
a58a				endm 
# End of macro NEXTW
a58a			 
a58a			.PAUSE: 
a58a			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a58a 43				db WORD_SYS_CORE+47             
a58b bf a5			dw .PAUSES            
a58d 08				db 7 + 1 
a58e .. 00			db "PAUSEMS",0              
a596				endm 
# End of macro CWHEAD
a596			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a596				if DEBUG_FORTH_WORDS_KEY 
a596					DMARK "PMS" 
a596 f5				push af  
a597 3a ab a5			ld a, (.dmark)  
a59a 32 6b ee			ld (debug_mark),a  
a59d 3a ac a5			ld a, (.dmark+1)  
a5a0 32 6c ee			ld (debug_mark+1),a  
a5a3 3a ad a5			ld a, (.dmark+2)  
a5a6 32 6d ee			ld (debug_mark+2),a  
a5a9 18 03			jr .pastdmark  
a5ab ..			.dmark: db "PMS"  
a5ae f1			.pastdmark: pop af  
a5af			endm  
# End of macro DMARK
a5af					CALLMONITOR 
a5af cd 6f ee			call debug_vector  
a5b2				endm  
# End of macro CALLMONITOR
a5b2				endif 
a5b2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b2 cd 3e 9d			call macro_dsp_valuehl 
a5b5				endm 
# End of macro FORTH_DSP_VALUEHL
a5b5			;		push hl    ; n2 
a5b5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b5 cd f6 9d			call macro_forth_dsp_pop 
a5b8				endm 
# End of macro FORTH_DSP_POP
a5b8			;		pop hl 
a5b8			 
a5b8 7d				ld a, l 
a5b9 cd d6 89			call aDelayInMS 
a5bc			       NEXTW 
a5bc c3 f4 9e			jp macro_next 
a5bf				endm 
# End of macro NEXTW
a5bf			.PAUSES:  
a5bf			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5bf 44				db WORD_SYS_CORE+48             
a5c0 2e a6			dw .ROT            
a5c2 06				db 5 + 1 
a5c3 .. 00			db "PAUSE",0              
a5c9				endm 
# End of macro CWHEAD
a5c9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5c9				if DEBUG_FORTH_WORDS_KEY 
a5c9					DMARK "PAU" 
a5c9 f5				push af  
a5ca 3a de a5			ld a, (.dmark)  
a5cd 32 6b ee			ld (debug_mark),a  
a5d0 3a df a5			ld a, (.dmark+1)  
a5d3 32 6c ee			ld (debug_mark+1),a  
a5d6 3a e0 a5			ld a, (.dmark+2)  
a5d9 32 6d ee			ld (debug_mark+2),a  
a5dc 18 03			jr .pastdmark  
a5de ..			.dmark: db "PAU"  
a5e1 f1			.pastdmark: pop af  
a5e2			endm  
# End of macro DMARK
a5e2					CALLMONITOR 
a5e2 cd 6f ee			call debug_vector  
a5e5				endm  
# End of macro CALLMONITOR
a5e5				endif 
a5e5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5e5 cd 3e 9d			call macro_dsp_valuehl 
a5e8				endm 
# End of macro FORTH_DSP_VALUEHL
a5e8			;		push hl    ; n2 
a5e8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5e8 cd f6 9d			call macro_forth_dsp_pop 
a5eb				endm 
# End of macro FORTH_DSP_POP
a5eb			;		pop hl 
a5eb 45				ld b, l 
a5ec				if DEBUG_FORTH_WORDS 
a5ec					DMARK "PAU" 
a5ec f5				push af  
a5ed 3a 01 a6			ld a, (.dmark)  
a5f0 32 6b ee			ld (debug_mark),a  
a5f3 3a 02 a6			ld a, (.dmark+1)  
a5f6 32 6c ee			ld (debug_mark+1),a  
a5f9 3a 03 a6			ld a, (.dmark+2)  
a5fc 32 6d ee			ld (debug_mark+2),a  
a5ff 18 03			jr .pastdmark  
a601 ..			.dmark: db "PAU"  
a604 f1			.pastdmark: pop af  
a605			endm  
# End of macro DMARK
a605					CALLMONITOR 
a605 cd 6f ee			call debug_vector  
a608				endm  
# End of macro CALLMONITOR
a608				endif 
a608 c5			.pauses1:	push bc 
a609 cd f1 89			call delay1s 
a60c c1				pop bc 
a60d				if DEBUG_FORTH_WORDS 
a60d					DMARK "PA1" 
a60d f5				push af  
a60e 3a 22 a6			ld a, (.dmark)  
a611 32 6b ee			ld (debug_mark),a  
a614 3a 23 a6			ld a, (.dmark+1)  
a617 32 6c ee			ld (debug_mark+1),a  
a61a 3a 24 a6			ld a, (.dmark+2)  
a61d 32 6d ee			ld (debug_mark+2),a  
a620 18 03			jr .pastdmark  
a622 ..			.dmark: db "PA1"  
a625 f1			.pastdmark: pop af  
a626			endm  
# End of macro DMARK
a626					CALLMONITOR 
a626 cd 6f ee			call debug_vector  
a629				endm  
# End of macro CALLMONITOR
a629				endif 
a629 10 dd			djnz .pauses1 
a62b			 
a62b			       NEXTW 
a62b c3 f4 9e			jp macro_next 
a62e				endm 
# End of macro NEXTW
a62e			.ROT: 
a62e			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a62e 45				db WORD_SYS_CORE+49             
a62f 7c a6			dw .UWORDS            
a631 04				db 3 + 1 
a632 .. 00			db "ROT",0              
a636				endm 
# End of macro CWHEAD
a636			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a636				if DEBUG_FORTH_WORDS_KEY 
a636					DMARK "ROT" 
a636 f5				push af  
a637 3a 4b a6			ld a, (.dmark)  
a63a 32 6b ee			ld (debug_mark),a  
a63d 3a 4c a6			ld a, (.dmark+1)  
a640 32 6c ee			ld (debug_mark+1),a  
a643 3a 4d a6			ld a, (.dmark+2)  
a646 32 6d ee			ld (debug_mark+2),a  
a649 18 03			jr .pastdmark  
a64b ..			.dmark: db "ROT"  
a64e f1			.pastdmark: pop af  
a64f			endm  
# End of macro DMARK
a64f					CALLMONITOR 
a64f cd 6f ee			call debug_vector  
a652				endm  
# End of macro CALLMONITOR
a652				endif 
a652			 
a652			; TODO Use os stack swap memory 
a652				FORTH_DSP_VALUEHL 
a652 cd 3e 9d			call macro_dsp_valuehl 
a655				endm 
# End of macro FORTH_DSP_VALUEHL
a655 e5				push hl    ; u3  
a656			 
a656				FORTH_DSP_POP 
a656 cd f6 9d			call macro_forth_dsp_pop 
a659				endm 
# End of macro FORTH_DSP_POP
a659			 
a659				FORTH_DSP_VALUEHL 
a659 cd 3e 9d			call macro_dsp_valuehl 
a65c				endm 
# End of macro FORTH_DSP_VALUEHL
a65c e5				push hl     ; u2 
a65d			 
a65d				FORTH_DSP_POP 
a65d cd f6 9d			call macro_forth_dsp_pop 
a660				endm 
# End of macro FORTH_DSP_POP
a660			 
a660				FORTH_DSP_VALUEHL 
a660 cd 3e 9d			call macro_dsp_valuehl 
a663				endm 
# End of macro FORTH_DSP_VALUEHL
a663 e5				push hl     ; u1 
a664			 
a664				FORTH_DSP_POP 
a664 cd f6 9d			call macro_forth_dsp_pop 
a667				endm 
# End of macro FORTH_DSP_POP
a667			 
a667 c1				pop bc      ; u1 
a668 e1				pop hl      ; u2 
a669 d1				pop de      ; u3 
a66a			 
a66a			 
a66a c5				push bc 
a66b d5				push de 
a66c e5				push hl 
a66d			 
a66d			 
a66d e1				pop hl 
a66e cd 47 9b			call forth_push_numhl 
a671			 
a671 e1				pop hl 
a672 cd 47 9b			call forth_push_numhl 
a675			 
a675 e1				pop hl 
a676 cd 47 9b			call forth_push_numhl 
a679				 
a679			 
a679			 
a679			 
a679			 
a679			 
a679			       NEXTW 
a679 c3 f4 9e			jp macro_next 
a67c				endm 
# End of macro NEXTW
a67c			 
a67c			.UWORDS: 
a67c			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a67c 50				db WORD_SYS_CORE+60             
a67d 3e a7			dw .BP            
a67f 07				db 6 + 1 
a680 .. 00			db "UWORDS",0              
a687				endm 
# End of macro CWHEAD
a687			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a687			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a687			; | | Following the count are the individual words. 
a687			; | | 
a687			; | | e.g. UWORDS 
a687			; | | BOX DIRLIST 2 
a687			; | |  
a687			; | | Can be used to save the words to storage via: 
a687			; | | UWORDS $01 DO $01 APPEND LOOP 
a687			if DEBUG_FORTH_WORDS_KEY 
a687				DMARK "UWR" 
a687 f5				push af  
a688 3a 9c a6			ld a, (.dmark)  
a68b 32 6b ee			ld (debug_mark),a  
a68e 3a 9d a6			ld a, (.dmark+1)  
a691 32 6c ee			ld (debug_mark+1),a  
a694 3a 9e a6			ld a, (.dmark+2)  
a697 32 6d ee			ld (debug_mark+2),a  
a69a 18 03			jr .pastdmark  
a69c ..			.dmark: db "UWR"  
a69f f1			.pastdmark: pop af  
a6a0			endm  
# End of macro DMARK
a6a0				CALLMONITOR 
a6a0 cd 6f ee			call debug_vector  
a6a3				endm  
# End of macro CALLMONITOR
a6a3			endif 
a6a3 21 e4 e4			ld hl, baseram 
a6a6				;ld hl, baseusermem 
a6a6 01 00 00			ld bc, 0    ; start a counter 
a6a9			 
a6a9			; skip dict stub 
a6a9			 
a6a9 cd 45 a0			call forth_tok_next 
a6ac			 
a6ac			 
a6ac			; while we have words to look for 
a6ac			 
a6ac 7e			.douscan:	ld a, (hl)      
a6ad			if DEBUG_FORTH_WORDS 
a6ad				DMARK "UWs" 
a6ad f5				push af  
a6ae 3a c2 a6			ld a, (.dmark)  
a6b1 32 6b ee			ld (debug_mark),a  
a6b4 3a c3 a6			ld a, (.dmark+1)  
a6b7 32 6c ee			ld (debug_mark+1),a  
a6ba 3a c4 a6			ld a, (.dmark+2)  
a6bd 32 6d ee			ld (debug_mark+2),a  
a6c0 18 03			jr .pastdmark  
a6c2 ..			.dmark: db "UWs"  
a6c5 f1			.pastdmark: pop af  
a6c6			endm  
# End of macro DMARK
a6c6				CALLMONITOR 
a6c6 cd 6f ee			call debug_vector  
a6c9				endm  
# End of macro CALLMONITOR
a6c9			endif 
a6c9 fe 00			cp WORD_SYS_END 
a6cb 28 4d			jr z, .udone 
a6cd fe 01			cp WORD_SYS_UWORD 
a6cf 20 44			jr nz, .nuword 
a6d1			 
a6d1			if DEBUG_FORTH_WORDS 
a6d1				DMARK "UWu" 
a6d1 f5				push af  
a6d2 3a e6 a6			ld a, (.dmark)  
a6d5 32 6b ee			ld (debug_mark),a  
a6d8 3a e7 a6			ld a, (.dmark+1)  
a6db 32 6c ee			ld (debug_mark+1),a  
a6de 3a e8 a6			ld a, (.dmark+2)  
a6e1 32 6d ee			ld (debug_mark+2),a  
a6e4 18 03			jr .pastdmark  
a6e6 ..			.dmark: db "UWu"  
a6e9 f1			.pastdmark: pop af  
a6ea			endm  
# End of macro DMARK
a6ea				CALLMONITOR 
a6ea cd 6f ee			call debug_vector  
a6ed				endm  
# End of macro CALLMONITOR
a6ed			endif 
a6ed				; we have a uword so push its name to the stack 
a6ed			 
a6ed e5				push hl  ; save so we can move to next dict block 
a6ee			 
a6ee				; skip opcode 
a6ee 23				inc hl  
a6ef				; skip next ptr 
a6ef 23				inc hl  
a6f0 23				inc hl 
a6f1				; skip len 
a6f1 23				inc hl 
a6f2			if DEBUG_FORTH_WORDS 
a6f2				DMARK "UWt" 
a6f2 f5				push af  
a6f3 3a 07 a7			ld a, (.dmark)  
a6f6 32 6b ee			ld (debug_mark),a  
a6f9 3a 08 a7			ld a, (.dmark+1)  
a6fc 32 6c ee			ld (debug_mark+1),a  
a6ff 3a 09 a7			ld a, (.dmark+2)  
a702 32 6d ee			ld (debug_mark+2),a  
a705 18 03			jr .pastdmark  
a707 ..			.dmark: db "UWt"  
a70a f1			.pastdmark: pop af  
a70b			endm  
# End of macro DMARK
a70b				CALLMONITOR 
a70b cd 6f ee			call debug_vector  
a70e				endm  
# End of macro CALLMONITOR
a70e			endif 
a70e 03				inc bc 
a70f			 
a70f c5				push bc 
a710 cd b5 9b			call forth_push_str 
a713 c1				pop bc 
a714			 
a714 e1				pop hl 	 
a715			 
a715 cd 45 a0		.nuword:	call forth_tok_next 
a718 18 92			jr .douscan  
a71a			 
a71a			.udone:		 ; push count of uwords found 
a71a c5				push bc 
a71b e1				pop hl 
a71c			 
a71c			if DEBUG_FORTH_WORDS 
a71c				DMARK "UWc" 
a71c f5				push af  
a71d 3a 31 a7			ld a, (.dmark)  
a720 32 6b ee			ld (debug_mark),a  
a723 3a 32 a7			ld a, (.dmark+1)  
a726 32 6c ee			ld (debug_mark+1),a  
a729 3a 33 a7			ld a, (.dmark+2)  
a72c 32 6d ee			ld (debug_mark+2),a  
a72f 18 03			jr .pastdmark  
a731 ..			.dmark: db "UWc"  
a734 f1			.pastdmark: pop af  
a735			endm  
# End of macro DMARK
a735				CALLMONITOR 
a735 cd 6f ee			call debug_vector  
a738				endm  
# End of macro CALLMONITOR
a738			endif 
a738 cd 47 9b			call forth_push_numhl 
a73b			 
a73b			 
a73b			       NEXTW 
a73b c3 f4 9e			jp macro_next 
a73e				endm 
# End of macro NEXTW
a73e			 
a73e			.BP: 
a73e			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a73e 54				db WORD_SYS_CORE+64             
a73f 78 a7			dw .MONITOR            
a741 03				db 2 + 1 
a742 .. 00			db "BP",0              
a745				endm 
# End of macro CWHEAD
a745			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a745			; | | $00 Will enable the break points within specific code paths 
a745			; | | $01 Will disable break points 
a745			; | |  
a745			; | | By default break points are off. Either the above can be used to enable them 
a745			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a745			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a745			; | | can disable break points. Exiting will then continue boot process. 
a745				; get byte count 
a745				if DEBUG_FORTH_WORDS_KEY 
a745					DMARK "BP." 
a745 f5				push af  
a746 3a 5a a7			ld a, (.dmark)  
a749 32 6b ee			ld (debug_mark),a  
a74c 3a 5b a7			ld a, (.dmark+1)  
a74f 32 6c ee			ld (debug_mark+1),a  
a752 3a 5c a7			ld a, (.dmark+2)  
a755 32 6d ee			ld (debug_mark+2),a  
a758 18 03			jr .pastdmark  
a75a ..			.dmark: db "BP."  
a75d f1			.pastdmark: pop af  
a75e			endm  
# End of macro DMARK
a75e					CALLMONITOR 
a75e cd 6f ee			call debug_vector  
a761				endm  
# End of macro CALLMONITOR
a761				endif 
a761			 
a761				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a761 cd 3e 9d			call macro_dsp_valuehl 
a764				endm 
# End of macro FORTH_DSP_VALUEHL
a764			 
a764			;		push hl 
a764			 
a764				; destroy value TOS 
a764			 
a764				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a764 cd f6 9d			call macro_forth_dsp_pop 
a767				endm 
# End of macro FORTH_DSP_POP
a767			 
a767			;		pop hl 
a767			 
a767 3e 00			ld a,0 
a769 bd				cp l 
a76a 28 06			jr z, .bpset 
a76c			;		ld a, '*' 
a76c cd e9 94			call bp_off 
a76f				NEXTW 
a76f c3 f4 9e			jp macro_next 
a772				endm 
# End of macro NEXTW
a772			 
a772			.bpset:	 
a772				;	ld (os_view_disable), a 
a772 cd dd 94			call bp_on 
a775			 
a775			 
a775				NEXTW 
a775 c3 f4 9e			jp macro_next 
a778				endm 
# End of macro NEXTW
a778			 
a778			 
a778			.MONITOR: 
a778			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a778 55				db WORD_SYS_CORE+65             
a779 a9 a7			dw .MALLOC            
a77b 08				db 7 + 1 
a77c .. 00			db "MONITOR",0              
a784				endm 
# End of macro CWHEAD
a784			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a784			; | | At start the current various registers will be displayed with contents. 
a784			; | | Top right corner will show the most recent debug marker seen. 
a784			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a784			; | | and the return stack pointer (RSP). 
a784			; | | Pressing: 
a784			; | |    1 - Initial screen 
a784			; | |    2 - Display a data dump of HL 
a784			; | |    3 - Display a data dump of DE 
a784			; | |    4 - Display a data dump of BC 
a784			; | |    5 - Display a data dump of HL 
a784			; | |    6 - Display a data dump of DSP 
a784			; | |    7 - Display a data dump of RSP 
a784			; | |    8 - Display a data dump of what is at DSP 
a784			; | |    9 - Display a data dump of what is at RSP 
a784			; | |    0 - Exit monitor and continue running. This will also enable break points 
a784			; | |    * - Disable break points 
a784			; | |    # - Enter traditional monitor mode 
a784			; | | 
a784			; | | Monitor Mode 
a784			; | | ------------ 
a784			; | | A prompt of '>' will be shown for various commands: 
a784			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a784			; | |    C - Continue display a data dump from the last set address 
a784			; | |    M xxxx - Set start of memory edit at address xx 
a784			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a784			; | |    G xxxx - Exec code at specific address 
a784			; | |    Q - Return to previous 
a784				if DEBUG_FORTH_WORDS_KEY 
a784					DMARK "MON" 
a784 f5				push af  
a785 3a 99 a7			ld a, (.dmark)  
a788 32 6b ee			ld (debug_mark),a  
a78b 3a 9a a7			ld a, (.dmark+1)  
a78e 32 6c ee			ld (debug_mark+1),a  
a791 3a 9b a7			ld a, (.dmark+2)  
a794 32 6d ee			ld (debug_mark+2),a  
a797 18 03			jr .pastdmark  
a799 ..			.dmark: db "MON"  
a79c f1			.pastdmark: pop af  
a79d			endm  
# End of macro DMARK
a79d					CALLMONITOR 
a79d cd 6f ee			call debug_vector  
a7a0				endm  
# End of macro CALLMONITOR
a7a0				endif 
a7a0			;		ld a, 0 
a7a0			;		ld (os_view_disable), a 
a7a0 cd dd 94			call bp_on 
a7a3			 
a7a3				CALLMONITOR 
a7a3 cd 6f ee			call debug_vector  
a7a6				endm  
# End of macro CALLMONITOR
a7a6			 
a7a6			;	call monitor 
a7a6			 
a7a6				NEXTW 
a7a6 c3 f4 9e			jp macro_next 
a7a9				endm 
# End of macro NEXTW
a7a9			 
a7a9			 
a7a9			.MALLOC: 
a7a9			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a7a9 56				db WORD_SYS_CORE+66             
a7aa d2 a7			dw .MALLOC2            
a7ac 06				db 5 + 1 
a7ad .. 00			db "ALLOT",0              
a7b3				endm 
# End of macro CWHEAD
a7b3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7b3				if DEBUG_FORTH_WORDS_KEY 
a7b3					DMARK "ALL" 
a7b3 f5				push af  
a7b4 3a c8 a7			ld a, (.dmark)  
a7b7 32 6b ee			ld (debug_mark),a  
a7ba 3a c9 a7			ld a, (.dmark+1)  
a7bd 32 6c ee			ld (debug_mark+1),a  
a7c0 3a ca a7			ld a, (.dmark+2)  
a7c3 32 6d ee			ld (debug_mark+2),a  
a7c6 18 03			jr .pastdmark  
a7c8 ..			.dmark: db "ALL"  
a7cb f1			.pastdmark: pop af  
a7cc			endm  
# End of macro DMARK
a7cc					CALLMONITOR 
a7cc cd 6f ee			call debug_vector  
a7cf				endm  
# End of macro CALLMONITOR
a7cf				endif 
a7cf c3 f9 a7			jp .mallocc 
a7d2			.MALLOC2: 
a7d2			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7d2 56				db WORD_SYS_CORE+66             
a7d3 10 a8			dw .FREE            
a7d5 07				db 6 + 1 
a7d6 .. 00			db "MALLOC",0              
a7dd				endm 
# End of macro CWHEAD
a7dd			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7dd				; get byte count 
a7dd				if DEBUG_FORTH_WORDS_KEY 
a7dd					DMARK "MAL" 
a7dd f5				push af  
a7de 3a f2 a7			ld a, (.dmark)  
a7e1 32 6b ee			ld (debug_mark),a  
a7e4 3a f3 a7			ld a, (.dmark+1)  
a7e7 32 6c ee			ld (debug_mark+1),a  
a7ea 3a f4 a7			ld a, (.dmark+2)  
a7ed 32 6d ee			ld (debug_mark+2),a  
a7f0 18 03			jr .pastdmark  
a7f2 ..			.dmark: db "MAL"  
a7f5 f1			.pastdmark: pop af  
a7f6			endm  
# End of macro DMARK
a7f6					CALLMONITOR 
a7f6 cd 6f ee			call debug_vector  
a7f9				endm  
# End of macro CALLMONITOR
a7f9				endif 
a7f9			.mallocc: 
a7f9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7f9 cd 3e 9d			call macro_dsp_valuehl 
a7fc				endm 
# End of macro FORTH_DSP_VALUEHL
a7fc			 
a7fc			;		push hl 
a7fc			 
a7fc				; destroy value TOS 
a7fc			 
a7fc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7fc cd f6 9d			call macro_forth_dsp_pop 
a7ff				endm 
# End of macro FORTH_DSP_POP
a7ff			 
a7ff			;		pop hl 
a7ff cd ae 91			call malloc 
a802			if DEBUG_FORTH_MALLOC_GUARD 
a802 f5				push af 
a803 cd 04 8d			call ishlzero 
a806			;		ld a, l 
a806			;		add h 
a806			;		cp 0 
a806 f1				pop af 
a807				 
a807 cc b4 cc			call z,malloc_error 
a80a			endif 
a80a			 
a80a cd 47 9b			call forth_push_numhl 
a80d				NEXTW 
a80d c3 f4 9e			jp macro_next 
a810				endm 
# End of macro NEXTW
a810			 
a810			.FREE: 
a810			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a810 57				db WORD_SYS_CORE+67             
a811 41 a8			dw .LIST            
a813 05				db 4 + 1 
a814 .. 00			db "FREE",0              
a819				endm 
# End of macro CWHEAD
a819			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a819				if DEBUG_FORTH_WORDS_KEY 
a819					DMARK "FRE" 
a819 f5				push af  
a81a 3a 2e a8			ld a, (.dmark)  
a81d 32 6b ee			ld (debug_mark),a  
a820 3a 2f a8			ld a, (.dmark+1)  
a823 32 6c ee			ld (debug_mark+1),a  
a826 3a 30 a8			ld a, (.dmark+2)  
a829 32 6d ee			ld (debug_mark+2),a  
a82c 18 03			jr .pastdmark  
a82e ..			.dmark: db "FRE"  
a831 f1			.pastdmark: pop af  
a832			endm  
# End of macro DMARK
a832					CALLMONITOR 
a832 cd 6f ee			call debug_vector  
a835				endm  
# End of macro CALLMONITOR
a835				endif 
a835				; get address 
a835			 
a835				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a835 cd 3e 9d			call macro_dsp_valuehl 
a838				endm 
# End of macro FORTH_DSP_VALUEHL
a838			 
a838			;		push hl 
a838			 
a838				; destroy value TOS 
a838			 
a838				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a838 cd f6 9d			call macro_forth_dsp_pop 
a83b				endm 
# End of macro FORTH_DSP_POP
a83b			 
a83b			;		pop hl 
a83b			if FORTH_ENABLE_MALLOCFREE 
a83b cd 78 92			call free 
a83e			endif 
a83e				NEXTW 
a83e c3 f4 9e			jp macro_next 
a841				endm 
# End of macro NEXTW
a841			.LIST: 
a841			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a841 5c				db WORD_SYS_CORE+72             
a842 31 aa			dw .FORGET            
a844 05				db 4 + 1 
a845 .. 00			db "LIST",0              
a84a				endm 
# End of macro CWHEAD
a84a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a84a			; | | The quoted word must be in upper case. 
a84a			if DEBUG_FORTH_WORDS_KEY 
a84a				DMARK "LST" 
a84a f5				push af  
a84b 3a 5f a8			ld a, (.dmark)  
a84e 32 6b ee			ld (debug_mark),a  
a851 3a 60 a8			ld a, (.dmark+1)  
a854 32 6c ee			ld (debug_mark+1),a  
a857 3a 61 a8			ld a, (.dmark+2)  
a85a 32 6d ee			ld (debug_mark+2),a  
a85d 18 03			jr .pastdmark  
a85f ..			.dmark: db "LST"  
a862 f1			.pastdmark: pop af  
a863			endm  
# End of macro DMARK
a863				CALLMONITOR 
a863 cd 6f ee			call debug_vector  
a866				endm  
# End of macro CALLMONITOR
a866			endif 
a866			 
a866				FORTH_DSP_VALUEHL 
a866 cd 3e 9d			call macro_dsp_valuehl 
a869				endm 
# End of macro FORTH_DSP_VALUEHL
a869			 
a869 e5				push hl 
a86a				FORTH_DSP_POP 
a86a cd f6 9d			call macro_forth_dsp_pop 
a86d				endm 
# End of macro FORTH_DSP_POP
a86d c1				pop bc 
a86e			 
a86e			; Start format of scratch string 
a86e			 
a86e 21 c1 e2			ld hl, scratch 
a871			 
a871 3e 3a			ld a, ':' 
a873 77				ld (hl),a 
a874 23				inc hl 
a875 3e 20			ld a, ' ' 
a877 77				ld (hl), a 
a878			 
a878				; Get ptr to the word we need to look up 
a878			 
a878			;		FORTH_DSP_VALUEHL 
a878				;v5 FORTH_DSP_VALUE 
a878			; TODO type check 
a878			;		inc hl    ; Skip type check  
a878			;		push hl 
a878			;		ex de, hl    ; put into DE 
a878			 
a878			 
a878 21 e4 e4			ld hl, baseram 
a87b				;ld hl, baseusermem 
a87b			 
a87b e5			push hl   ; sacreifical push 
a87c			 
a87c			.ldouscanm: 
a87c e1			pop hl 
a87d			.ldouscan: 
a87d			if DEBUG_FORTH_WORDS 
a87d				DMARK "LSs" 
a87d f5				push af  
a87e 3a 92 a8			ld a, (.dmark)  
a881 32 6b ee			ld (debug_mark),a  
a884 3a 93 a8			ld a, (.dmark+1)  
a887 32 6c ee			ld (debug_mark+1),a  
a88a 3a 94 a8			ld a, (.dmark+2)  
a88d 32 6d ee			ld (debug_mark+2),a  
a890 18 03			jr .pastdmark  
a892 ..			.dmark: db "LSs"  
a895 f1			.pastdmark: pop af  
a896			endm  
# End of macro DMARK
a896				CALLMONITOR 
a896 cd 6f ee			call debug_vector  
a899				endm  
# End of macro CALLMONITOR
a899			endif 
a899			; skip dict stub 
a899 cd 45 a0			call forth_tok_next 
a89c			 
a89c			 
a89c			; while we have words to look for 
a89c			 
a89c 7e			ld a, (hl)      
a89d			if DEBUG_FORTH_WORDS 
a89d				DMARK "LSk" 
a89d f5				push af  
a89e 3a b2 a8			ld a, (.dmark)  
a8a1 32 6b ee			ld (debug_mark),a  
a8a4 3a b3 a8			ld a, (.dmark+1)  
a8a7 32 6c ee			ld (debug_mark+1),a  
a8aa 3a b4 a8			ld a, (.dmark+2)  
a8ad 32 6d ee			ld (debug_mark+2),a  
a8b0 18 03			jr .pastdmark  
a8b2 ..			.dmark: db "LSk"  
a8b5 f1			.pastdmark: pop af  
a8b6			endm  
# End of macro DMARK
a8b6				CALLMONITOR 
a8b6 cd 6f ee			call debug_vector  
a8b9				endm  
# End of macro CALLMONITOR
a8b9			endif 
a8b9				;cp WORD_SYS_END 
a8b9				;jp z, .lunotfound 
a8b9			 
a8b9					; if we hit non uwords then gone too far 
a8b9 fe 01				cp WORD_SYS_UWORD 
a8bb c2 ed a9				jp nz, .lunotfound 
a8be			 
a8be				if DEBUG_FORTH_WORDS 
a8be					DMARK "LSu" 
a8be f5				push af  
a8bf 3a d3 a8			ld a, (.dmark)  
a8c2 32 6b ee			ld (debug_mark),a  
a8c5 3a d4 a8			ld a, (.dmark+1)  
a8c8 32 6c ee			ld (debug_mark+1),a  
a8cb 3a d5 a8			ld a, (.dmark+2)  
a8ce 32 6d ee			ld (debug_mark+2),a  
a8d1 18 03			jr .pastdmark  
a8d3 ..			.dmark: db "LSu"  
a8d6 f1			.pastdmark: pop af  
a8d7			endm  
# End of macro DMARK
a8d7					CALLMONITOR 
a8d7 cd 6f ee			call debug_vector  
a8da				endm  
# End of macro CALLMONITOR
a8da				endif 
a8da			 
a8da					; found a uword but is it the one we want... 
a8da			 
a8da c5					push bc     ; uword to find is on bc 
a8db d1					pop de 
a8dc			 
a8dc e5					push hl  ; to save the ptr 
a8dd			 
a8dd					; skip opcode 
a8dd 23					inc hl  
a8de					; skip next ptr 
a8de 23					inc hl  
a8df 23					inc hl 
a8e0					; skip len 
a8e0 23					inc hl 
a8e1			 
a8e1				if DEBUG_FORTH_WORDS 
a8e1					DMARK "LSc" 
a8e1 f5				push af  
a8e2 3a f6 a8			ld a, (.dmark)  
a8e5 32 6b ee			ld (debug_mark),a  
a8e8 3a f7 a8			ld a, (.dmark+1)  
a8eb 32 6c ee			ld (debug_mark+1),a  
a8ee 3a f8 a8			ld a, (.dmark+2)  
a8f1 32 6d ee			ld (debug_mark+2),a  
a8f4 18 03			jr .pastdmark  
a8f6 ..			.dmark: db "LSc"  
a8f9 f1			.pastdmark: pop af  
a8fa			endm  
# End of macro DMARK
a8fa					CALLMONITOR 
a8fa cd 6f ee			call debug_vector  
a8fd				endm  
# End of macro CALLMONITOR
a8fd				endif 
a8fd			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a8fd			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a8fd			; Nope that has gone the other way. It needs to be exact not on first zero 
a8fd			;		call strcmp 
a8fd c5					push bc 
a8fe cd 7e 91				call StrictStrCmp 
a901 c1					pop bc 
a902 c2 7c a8				jp nz, .ldouscanm 
a905				 
a905			 
a905			 
a905					; we have a uword so push its name to the stack 
a905			 
a905			;	   	push hl  ; save so we can move to next dict block 
a905 e1			pop hl 
a906			 
a906				if DEBUG_FORTH_WORDS 
a906					DMARK "LSm" 
a906 f5				push af  
a907 3a 1b a9			ld a, (.dmark)  
a90a 32 6b ee			ld (debug_mark),a  
a90d 3a 1c a9			ld a, (.dmark+1)  
a910 32 6c ee			ld (debug_mark+1),a  
a913 3a 1d a9			ld a, (.dmark+2)  
a916 32 6d ee			ld (debug_mark+2),a  
a919 18 03			jr .pastdmark  
a91b ..			.dmark: db "LSm"  
a91e f1			.pastdmark: pop af  
a91f			endm  
# End of macro DMARK
a91f					CALLMONITOR 
a91f cd 6f ee			call debug_vector  
a922				endm  
# End of macro CALLMONITOR
a922				endif 
a922			 
a922					; skip opcode 
a922 23					inc hl  
a923					; skip next ptr 
a923 23					inc hl  
a924 23					inc hl 
a925					; skip len 
a925 7e					ld a, (hl)   ; save length to add 
a926				if DEBUG_FORTH_WORDS 
a926					DMARK "LS2" 
a926 f5				push af  
a927 3a 3b a9			ld a, (.dmark)  
a92a 32 6b ee			ld (debug_mark),a  
a92d 3a 3c a9			ld a, (.dmark+1)  
a930 32 6c ee			ld (debug_mark+1),a  
a933 3a 3d a9			ld a, (.dmark+2)  
a936 32 6d ee			ld (debug_mark+2),a  
a939 18 03			jr .pastdmark  
a93b ..			.dmark: db "LS2"  
a93e f1			.pastdmark: pop af  
a93f			endm  
# End of macro DMARK
a93f					CALLMONITOR 
a93f cd 6f ee			call debug_vector  
a942				endm  
# End of macro CALLMONITOR
a942				endif 
a942			 
a942					; save this location 
a942				 
a942 e5					push hl 
a943			 
a943 23					inc hl 
a944 11 c3 e2				ld de, scratch+2 
a947 4f					ld c, a 
a948 06 00				ld b, 0 
a94a			 
a94a				if DEBUG_FORTH_WORDS 
a94a					DMARK "LSn" 
a94a f5				push af  
a94b 3a 5f a9			ld a, (.dmark)  
a94e 32 6b ee			ld (debug_mark),a  
a951 3a 60 a9			ld a, (.dmark+1)  
a954 32 6c ee			ld (debug_mark+1),a  
a957 3a 61 a9			ld a, (.dmark+2)  
a95a 32 6d ee			ld (debug_mark+2),a  
a95d 18 03			jr .pastdmark  
a95f ..			.dmark: db "LSn"  
a962 f1			.pastdmark: pop af  
a963			endm  
# End of macro DMARK
a963					CALLMONITOR 
a963 cd 6f ee			call debug_vector  
a966				endm  
# End of macro CALLMONITOR
a966				endif 
a966			 
a966					; copy uword name to scratch 
a966			 
a966 ed b0				ldir 
a968			 
a968 1b					dec de 
a969 3e 20				ld a, ' '    ; change null to space 
a96b 12					ld (de), a 
a96c			 
a96c 13					inc de 
a96d			 
a96d d5					push de 
a96e c1					pop bc     ; move scratch pointer to end of word name and save it 
a96f			 
a96f e1					pop hl 
a970 7e					ld a, (hl) 
a971					;inc hl 
a971					; skip word string 
a971 cd db 8c				call addatohl 
a974			 
a974 23					inc hl 
a975			 
a975				if DEBUG_FORTH_WORDS 
a975					DMARK "LS3" 
a975 f5				push af  
a976 3a 8a a9			ld a, (.dmark)  
a979 32 6b ee			ld (debug_mark),a  
a97c 3a 8b a9			ld a, (.dmark+1)  
a97f 32 6c ee			ld (debug_mark+1),a  
a982 3a 8c a9			ld a, (.dmark+2)  
a985 32 6d ee			ld (debug_mark+2),a  
a988 18 03			jr .pastdmark  
a98a ..			.dmark: db "LS3"  
a98d f1			.pastdmark: pop af  
a98e			endm  
# End of macro DMARK
a98e					CALLMONITOR 
a98e cd 6f ee			call debug_vector  
a991				endm  
# End of macro CALLMONITOR
a991				endif 
a991					; should now be at the start of the machine code to setup the eval of the uword 
a991					; now locate the ptr to the string defintion 
a991			 
a991					; skip ld hl, 
a991					; then load the ptr 
a991			; TODO use get from hl ptr 
a991 23					inc hl 
a992 5e					ld e, (hl) 
a993 23					inc hl 
a994 56					ld d, (hl) 
a995 eb					ex de, hl 
a996			 
a996			 
a996				if DEBUG_FORTH_WORDS 
a996					DMARK "LSt" 
a996 f5				push af  
a997 3a ab a9			ld a, (.dmark)  
a99a 32 6b ee			ld (debug_mark),a  
a99d 3a ac a9			ld a, (.dmark+1)  
a9a0 32 6c ee			ld (debug_mark+1),a  
a9a3 3a ad a9			ld a, (.dmark+2)  
a9a6 32 6d ee			ld (debug_mark+2),a  
a9a9 18 03			jr .pastdmark  
a9ab ..			.dmark: db "LSt"  
a9ae f1			.pastdmark: pop af  
a9af			endm  
# End of macro DMARK
a9af					CALLMONITOR 
a9af cd 6f ee			call debug_vector  
a9b2				endm  
# End of macro CALLMONITOR
a9b2				endif 
a9b2			 
a9b2			; cant push right now due to tokenised strings  
a9b2			 
a9b2			; get the destination of where to copy this definition to. 
a9b2			 
a9b2 c5					push bc 
a9b3 d1					pop de 
a9b4			 
a9b4 7e			.listl:         ld a,(hl) 
a9b5 fe 00				cp 0 
a9b7 28 09				jr z, .lreplsp     ; replace zero with space 
a9b9					;cp FORTH_END_BUFFER 
a9b9 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9bb 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9bd				 
a9bd					; just copy this char as is then 
a9bd			 
a9bd 12					ld (de), a 
a9be			 
a9be 23			.listnxt:	inc hl 
a9bf 13					inc de 
a9c0 18 f2				jr .listl 
a9c2			 
a9c2 3e 20		.lreplsp:	ld a,' ' 
a9c4 12					ld (de), a 
a9c5 18 f7				jr .listnxt 
a9c7			 
a9c7			; close up uword def 
a9c7			 
a9c7			.listdone: 
a9c7 12					ld (de), a 
a9c8 13					inc de 
a9c9 3e 00				ld a, 0 
a9cb 12					ld (de), a 
a9cc			 
a9cc			; now have def so clean up and push to stack 
a9cc			 
a9cc 21 c1 e2				ld hl, scratch 
a9cf				if DEBUG_FORTH_WORDS 
a9cf					DMARK "Ltp" 
a9cf f5				push af  
a9d0 3a e4 a9			ld a, (.dmark)  
a9d3 32 6b ee			ld (debug_mark),a  
a9d6 3a e5 a9			ld a, (.dmark+1)  
a9d9 32 6c ee			ld (debug_mark+1),a  
a9dc 3a e6 a9			ld a, (.dmark+2)  
a9df 32 6d ee			ld (debug_mark+2),a  
a9e2 18 03			jr .pastdmark  
a9e4 ..			.dmark: db "Ltp"  
a9e7 f1			.pastdmark: pop af  
a9e8			endm  
# End of macro DMARK
a9e8					CALLMONITOR 
a9e8 cd 6f ee			call debug_vector  
a9eb				endm  
# End of macro CALLMONITOR
a9eb				endif 
a9eb			 
a9eb 18 1f			jr .listpush 
a9ed			 
a9ed			;.lnuword:	pop hl 
a9ed			;		call forth_tok_next 
a9ed			;		jp .ldouscan  
a9ed			 
a9ed			.lunotfound:		  
a9ed			 
a9ed				if DEBUG_FORTH_WORDS 
a9ed					DMARK "LSn" 
a9ed f5				push af  
a9ee 3a 02 aa			ld a, (.dmark)  
a9f1 32 6b ee			ld (debug_mark),a  
a9f4 3a 03 aa			ld a, (.dmark+1)  
a9f7 32 6c ee			ld (debug_mark+1),a  
a9fa 3a 04 aa			ld a, (.dmark+2)  
a9fd 32 6d ee			ld (debug_mark+2),a  
aa00 18 03			jr .pastdmark  
aa02 ..			.dmark: db "LSn"  
aa05 f1			.pastdmark: pop af  
aa06			endm  
# End of macro DMARK
aa06					CALLMONITOR 
aa06 cd 6f ee			call debug_vector  
aa09				endm  
# End of macro CALLMONITOR
aa09				endif 
aa09			 
aa09					 
aa09			;		FORTH_DSP_POP 
aa09			;		ld hl, .luno 
aa09			 
aa09					NEXTW			 
aa09 c3 f4 9e			jp macro_next 
aa0c				endm 
# End of macro NEXTW
aa0c			 
aa0c			.listpush: 
aa0c				if DEBUG_FORTH_WORDS 
aa0c					DMARK "LS>" 
aa0c f5				push af  
aa0d 3a 21 aa			ld a, (.dmark)  
aa10 32 6b ee			ld (debug_mark),a  
aa13 3a 22 aa			ld a, (.dmark+1)  
aa16 32 6c ee			ld (debug_mark+1),a  
aa19 3a 23 aa			ld a, (.dmark+2)  
aa1c 32 6d ee			ld (debug_mark+2),a  
aa1f 18 03			jr .pastdmark  
aa21 ..			.dmark: db "LS>"  
aa24 f1			.pastdmark: pop af  
aa25			endm  
# End of macro DMARK
aa25					CALLMONITOR 
aa25 cd 6f ee			call debug_vector  
aa28				endm  
# End of macro CALLMONITOR
aa28				endif 
aa28 cd b5 9b				call forth_push_str 
aa2b			 
aa2b			 
aa2b			 
aa2b					NEXTW 
aa2b c3 f4 9e			jp macro_next 
aa2e				endm 
# End of macro NEXTW
aa2e			 
aa2e			;.luno:    db "Word not found",0 
aa2e			 
aa2e			 
aa2e			 
aa2e			 
aa2e			 
aa2e			;		push hl   ; save pointer to start of uword def string 
aa2e			; 
aa2e			;; look for FORTH_EOL_LINE 
aa2e			;		ld a, FORTH_END_BUFFER 
aa2e			;		call strlent 
aa2e			; 
aa2e			;		inc hl		 ; space for coln def 
aa2e			;		inc hl 
aa2e			;		inc hl          ; space for terms 
aa2e			;		inc hl 
aa2e			; 
aa2e			;		ld a, 20   ; TODO get actual length 
aa2e			;		call addatohl    ; include a random amount of room for the uword name 
aa2e			; 
aa2e			;		 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt1" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;		 
aa2e			; 
aa2e			;; malloc space for the string because we cant change it 
aa2e			; 
aa2e			;		call malloc 
aa2e			;	if DEBUG_FORTH_MALLOC_GUARD 
aa2e			;		push af 
aa2e			;		call ishlzero 
aa2e			;		pop af 
aa2e			;		 
aa2e			;		call z,malloc_error 
aa2e			;	endif 
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt2" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;		pop de 
aa2e			;		push hl    ; push the malloc to release later 
aa2e			;		push hl   ;  push back a copy for the later stack push 
aa2e			;		 
aa2e			;; copy the string swapping out the zero terms for spaces 
aa2e			; 
aa2e			;		; de has our source 
aa2e			;		; hl has our dest 
aa2e			; 
aa2e			;; add the coln def 
aa2e			; 
aa2e			;		ld a, ':' 
aa2e			;		ld (hl), a 
aa2e			;		inc hl 
aa2e			;		ld a, ' ' 
aa2e			;		ld (hl), a 
aa2e			;		inc hl 
aa2e			; 
aa2e			;; add the uname word 
aa2e			;		push de   ; save our string for now 
aa2e			;		ex de, hl 
aa2e			; 
aa2e			;		FORTH_DSP_VALUE 
aa2e			;		;v5 FORTH_DSP_VALUE 
aa2e			; 
aa2e			;		inc hl   ; skip type but we know by now this is OK 
aa2e			; 
aa2e			;.luword:	ld a,(hl) 
aa2e			;		cp 0 
aa2e			;		jr z, .luword2 
aa2e			;		ld (de), a 
aa2e			;		inc de 
aa2e			;		inc hl 
aa2e			;		jr .luword 
aa2e			; 
aa2e			;.luword2:	ld a, ' ' 
aa2e			;		ld (de), a 
aa2e			;;		inc hl 
aa2e			;;		inc de 
aa2e			;;		ld (de), a 
aa2e			;;		inc hl 
aa2e			;		inc de 
aa2e			; 
aa2e			;		ex de, hl 
aa2e			;		pop de 
aa2e			;		 
aa2e			;		 
aa2e			; 
aa2e			;; detoken that string and copy it 
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt2" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;.ldetok:	ld a, (de) 
aa2e			;		cp FORTH_END_BUFFER 
aa2e			;		jr z, .ldetokend 
aa2e			;		; swap out any zero term for space 
aa2e			;		cp 0 
aa2e			;		jr nz, .ldetoknext 
aa2e			;		ld a, ' ' 
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "LtS" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;.ldetoknext:	ld (hl), a 
aa2e			;		inc de 
aa2e			;		inc hl 
aa2e			;		jr .ldetok 
aa2e			; 
aa2e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa2e			;		ld (hl), a  
aa2e			; 
aa2e			;; free that temp malloc 
aa2e			; 
aa2e			;		pop hl    
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt4" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;		call forth_apushstrhl 
aa2e			; 
aa2e			;		; get rid of temp malloc area 
aa2e			; 
aa2e			;		pop hl 
aa2e			;		call free 
aa2e			; 
aa2e			;		jr .ludone 
aa2e			; 
aa2e			;.lnuword:	pop hl 
aa2e			;		call forth_tok_next 
aa2e			;		jp .ldouscan  
aa2e			; 
aa2e			;.ludone:		 pop hl 
aa2e			; 
aa2e					NEXTW 
aa2e c3 f4 9e			jp macro_next 
aa31				endm 
# End of macro NEXTW
aa31			 
aa31			.FORGET: 
aa31				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa31 5d				db WORD_SYS_CORE+73             
aa32 aa aa			dw .NOP            
aa34 07				db 6 + 1 
aa35 .. 00			db "FORGET",0              
aa3c				endm 
# End of macro CWHEAD
aa3c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa3c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
aa3c			; | |  
aa3c			; | | e.g. "MORE" forget 
aa3c					if DEBUG_FORTH_WORDS_KEY 
aa3c						DMARK "FRG" 
aa3c f5				push af  
aa3d 3a 51 aa			ld a, (.dmark)  
aa40 32 6b ee			ld (debug_mark),a  
aa43 3a 52 aa			ld a, (.dmark+1)  
aa46 32 6c ee			ld (debug_mark+1),a  
aa49 3a 53 aa			ld a, (.dmark+2)  
aa4c 32 6d ee			ld (debug_mark+2),a  
aa4f 18 03			jr .pastdmark  
aa51 ..			.dmark: db "FRG"  
aa54 f1			.pastdmark: pop af  
aa55			endm  
# End of macro DMARK
aa55						CALLMONITOR 
aa55 cd 6f ee			call debug_vector  
aa58				endm  
# End of macro CALLMONITOR
aa58					endif 
aa58			 
aa58				; find uword 
aa58			        ; update start of word with "_" 
aa58				; replace uword with deleted flag 
aa58			 
aa58			 
aa58			;	if DEBUG_FORTH_WORDS 
aa58			;		DMARK "FOG" 
aa58			;		CALLMONITOR 
aa58			;	endif 
aa58			 
aa58			 
aa58					; Get ptr to the word we need to look up 
aa58			 
aa58					FORTH_DSP_VALUEHL 
aa58 cd 3e 9d			call macro_dsp_valuehl 
aa5b				endm 
# End of macro FORTH_DSP_VALUEHL
aa5b					;v5 FORTH_DSP_VALUE 
aa5b				; TODO type check 
aa5b			;		inc hl    ; Skip type check  
aa5b e5					push hl 
aa5c c1					pop bc 
aa5d			;		ex de, hl    ; put into DE 
aa5d			 
aa5d			 
aa5d 21 e4 e4				ld hl, baseram 
aa60					;ld hl, baseusermem 
aa60			 
aa60				; skip dict stub 
aa60			;	call forth_tok_next 
aa60 e5			push hl   ; sacreifical push 
aa61			 
aa61			.fldouscanm: 
aa61 e1				pop hl 
aa62			.fldouscan: 
aa62			;	if DEBUG_FORTH_WORDS 
aa62			;		DMARK "LSs" 
aa62			;		CALLMONITOR 
aa62			;	endif 
aa62				; skip dict stub 
aa62 cd 45 a0				call forth_tok_next 
aa65			 
aa65			 
aa65			; while we have words to look for 
aa65			 
aa65 7e				ld a, (hl)      
aa66			;	if DEBUG_FORTH_WORDS 
aa66			;		DMARK "LSk" 
aa66			;		CALLMONITOR 
aa66			;	endif 
aa66 fe 00				cp WORD_SYS_END 
aa68 ca a4 aa				jp z, .flunotfound 
aa6b fe 01				cp WORD_SYS_UWORD 
aa6d c2 62 aa				jp nz, .fldouscan 
aa70			 
aa70			;	if DEBUG_FORTH_WORDS 
aa70			;		DMARK "LSu" 
aa70			;		CALLMONITOR 
aa70			;	endif 
aa70			 
aa70					; found a uword but is it the one we want... 
aa70			 
aa70 c5					push bc     ; uword to find is on bc 
aa71 d1					pop de 
aa72			 
aa72 e5					push hl  ; to save the ptr 
aa73			 
aa73					; skip opcode 
aa73 23					inc hl  
aa74					; skip next ptr 
aa74 23					inc hl  
aa75 23					inc hl 
aa76					; skip len 
aa76 23					inc hl 
aa77			 
aa77			;	if DEBUG_FORTH_WORDS 
aa77			;		DMARK "LSc" 
aa77			;		CALLMONITOR 
aa77			;	endif 
aa77 cd 71 91				call strcmp 
aa7a c2 61 aa				jp nz, .fldouscanm 
aa7d			; 
aa7d			; 
aa7d			;; while we have words to look for 
aa7d			; 
aa7d			;.fdouscan:	ld a, (hl)      
aa7d			;	if DEBUG_FORTH_WORDS 
aa7d			;		DMARK "LSs" 
aa7d			;		CALLMONITOR 
aa7d			;	endif 
aa7d			;		cp WORD_SYS_END 
aa7d			;		jp z, .fudone 
aa7d			;		cp WORD_SYS_UWORD 
aa7d			;		jp nz, .fnuword 
aa7d			; 
aa7d			;	if DEBUG_FORTH_WORDS 
aa7d			;		DMARK "FGu" 
aa7d			;		CALLMONITOR 
aa7d			;	endif 
aa7d			; 
aa7d			;		; found a uword but is it the one we want... 
aa7d			; 
aa7d			; 
aa7d			;	        pop de   ; get back the dsp name 
aa7d			;		push de 
aa7d			; 
aa7d			;		push hl  ; to save the ptr 
aa7d			; 
aa7d			;		; skip opcode 
aa7d			;		inc hl  
aa7d			;		; skip next ptr 
aa7d			;		inc hl  
aa7d			;		inc hl 
aa7d			;		; skip len 
aa7d			;		inc hl 
aa7d			; 
aa7d			;	if DEBUG_FORTH_WORDS 
aa7d			;		DMARK "FGc" 
aa7d			;		CALLMONITOR 
aa7d			;	endif 
aa7d			;		call strcmp 
aa7d			;		jp nz, .fnuword 
aa7d			 
aa7d			 
aa7d e1			pop hl 
aa7e			 
aa7e				 
aa7e				if DEBUG_FORTH_WORDS 
aa7e					DMARK "FGm" 
aa7e f5				push af  
aa7f 3a 93 aa			ld a, (.dmark)  
aa82 32 6b ee			ld (debug_mark),a  
aa85 3a 94 aa			ld a, (.dmark+1)  
aa88 32 6c ee			ld (debug_mark+1),a  
aa8b 3a 95 aa			ld a, (.dmark+2)  
aa8e 32 6d ee			ld (debug_mark+2),a  
aa91 18 03			jr .pastdmark  
aa93 ..			.dmark: db "FGm"  
aa96 f1			.pastdmark: pop af  
aa97			endm  
# End of macro DMARK
aa97					CALLMONITOR 
aa97 cd 6f ee			call debug_vector  
aa9a				endm  
# End of macro CALLMONITOR
aa9a				endif 
aa9a			 
aa9a			 
aa9a			 
aa9a					; we have a uword so push its name to the stack 
aa9a			 
aa9a			;	   	push hl  ; save so we can move to next dict block 
aa9a			;pop hl 
aa9a			 
aa9a					; update opcode to deleted 
aa9a 3e 03				ld a, WORD_SYS_DELETED 
aa9c 77					ld (hl), a 
aa9d			 
aa9d 23					inc hl  
aa9e					; skip next ptr 
aa9e 23					inc hl  
aa9f 23					inc hl 
aaa0					; skip len 
aaa0 23					inc hl 
aaa1			 
aaa1					; TODO change parser to skip deleted words but for now mark it out 
aaa1 3e 5f				ld a, "_" 
aaa3 77					ld  (hl),a 
aaa4			 
aaa4			;		jr .fudone 
aaa4			; 
aaa4			;.fnuword:	pop hl 
aaa4			;		call forth_tok_next 
aaa4			;		jp .fdouscan  
aaa4			 
aaa4			.flunotfound:		  
aaa4			 
aaa4			 
aaa4					 
aaa4					FORTH_DSP_POP 
aaa4 cd f6 9d			call macro_forth_dsp_pop 
aaa7				endm 
# End of macro FORTH_DSP_POP
aaa7			;		ld hl, .luno 
aaa7			;.fudone:		 pop hl 
aaa7					NEXTW 
aaa7 c3 f4 9e			jp macro_next 
aaaa				endm 
# End of macro NEXTW
aaaa			.NOP: 
aaaa				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aaaa 61				db WORD_SYS_CORE+77             
aaab d1 aa			dw .COMO            
aaad 04				db 3 + 1 
aaae .. 00			db "NOP",0              
aab2				endm 
# End of macro CWHEAD
aab2			; | NOP (  --  ) Do nothing | DONE 
aab2					if DEBUG_FORTH_WORDS_KEY 
aab2						DMARK "NOP" 
aab2 f5				push af  
aab3 3a c7 aa			ld a, (.dmark)  
aab6 32 6b ee			ld (debug_mark),a  
aab9 3a c8 aa			ld a, (.dmark+1)  
aabc 32 6c ee			ld (debug_mark+1),a  
aabf 3a c9 aa			ld a, (.dmark+2)  
aac2 32 6d ee			ld (debug_mark+2),a  
aac5 18 03			jr .pastdmark  
aac7 ..			.dmark: db "NOP"  
aaca f1			.pastdmark: pop af  
aacb			endm  
# End of macro DMARK
aacb						CALLMONITOR 
aacb cd 6f ee			call debug_vector  
aace				endm  
# End of macro CALLMONITOR
aace					endif 
aace				       NEXTW 
aace c3 f4 9e			jp macro_next 
aad1				endm 
# End of macro NEXTW
aad1			.COMO: 
aad1				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aad1 6e				db WORD_SYS_CORE+90             
aad2 23 ab			dw .COMC            
aad4 02				db 1 + 1 
aad5 .. 00			db "(",0              
aad7				endm 
# End of macro CWHEAD
aad7			; | ( ( -- )  Start of comment | DONE 
aad7			 
aad7			 
aad7 2a c2 e5				ld hl, ( os_tok_ptr) 
aada 11 1e ab			ld de, .closepar 
aadd					 
aadd					if DEBUG_FORTH_WORDS 
aadd						DMARK ").." 
aadd f5				push af  
aade 3a f2 aa			ld a, (.dmark)  
aae1 32 6b ee			ld (debug_mark),a  
aae4 3a f3 aa			ld a, (.dmark+1)  
aae7 32 6c ee			ld (debug_mark+1),a  
aaea 3a f4 aa			ld a, (.dmark+2)  
aaed 32 6d ee			ld (debug_mark+2),a  
aaf0 18 03			jr .pastdmark  
aaf2 ..			.dmark: db ").."  
aaf5 f1			.pastdmark: pop af  
aaf6			endm  
# End of macro DMARK
aaf6						CALLMONITOR 
aaf6 cd 6f ee			call debug_vector  
aaf9				endm  
# End of macro CALLMONITOR
aaf9					endif 
aaf9 cd 0f a0			call findnexttok  
aafc			 
aafc					if DEBUG_FORTH_WORDS 
aafc						DMARK "IF5" 
aafc f5				push af  
aafd 3a 11 ab			ld a, (.dmark)  
ab00 32 6b ee			ld (debug_mark),a  
ab03 3a 12 ab			ld a, (.dmark+1)  
ab06 32 6c ee			ld (debug_mark+1),a  
ab09 3a 13 ab			ld a, (.dmark+2)  
ab0c 32 6d ee			ld (debug_mark+2),a  
ab0f 18 03			jr .pastdmark  
ab11 ..			.dmark: db "IF5"  
ab14 f1			.pastdmark: pop af  
ab15			endm  
# End of macro DMARK
ab15						CALLMONITOR 
ab15 cd 6f ee			call debug_vector  
ab18				endm  
# End of macro CALLMONITOR
ab18					endif 
ab18				; replace below with ) exec using tok_ptr 
ab18 22 c2 e5			ld (os_tok_ptr), hl 
ab1b c3 85 9f			jp exec1 
ab1e			 
ab1e .. 00			.closepar:   db ")",0 
ab20			 
ab20				       NEXTW 
ab20 c3 f4 9e			jp macro_next 
ab23				endm 
# End of macro NEXTW
ab23			.COMC: 
ab23				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab23 6f				db WORD_SYS_CORE+91             
ab24 2c ab			dw .SCRATCH            
ab26 02				db 1 + 1 
ab27 .. 00			db ")",0              
ab29				endm 
# End of macro CWHEAD
ab29			; | ) ( -- )  End of comment |  DONE  
ab29				       NEXTW 
ab29 c3 f4 9e			jp macro_next 
ab2c				endm 
# End of macro NEXTW
ab2c			 
ab2c			.SCRATCH: 
ab2c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab2c 6f				db WORD_SYS_CORE+91             
ab2d 67 ab			dw .INC            
ab2f 08				db 7 + 1 
ab30 .. 00			db "SCRATCH",0              
ab38				endm 
# End of macro CWHEAD
ab38			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab38			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab38			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab38			; | |  
ab38			; | | e.g.    : score $00 scratch ; 
ab38			; | |  
ab38			; | | $00 score ! 
ab38			; | | $01 score +! 
ab38			; | |  
ab38			; | | e.g.   : varword $0a scratch ;  
ab38			; | | 
ab38			; | | $8000 varword ! 
ab38					if DEBUG_FORTH_WORDS_KEY 
ab38						DMARK "SCR" 
ab38 f5				push af  
ab39 3a 4d ab			ld a, (.dmark)  
ab3c 32 6b ee			ld (debug_mark),a  
ab3f 3a 4e ab			ld a, (.dmark+1)  
ab42 32 6c ee			ld (debug_mark+1),a  
ab45 3a 4f ab			ld a, (.dmark+2)  
ab48 32 6d ee			ld (debug_mark+2),a  
ab4b 18 03			jr .pastdmark  
ab4d ..			.dmark: db "SCR"  
ab50 f1			.pastdmark: pop af  
ab51			endm  
# End of macro DMARK
ab51						CALLMONITOR 
ab51 cd 6f ee			call debug_vector  
ab54				endm  
# End of macro CALLMONITOR
ab54					endif 
ab54			 
ab54					FORTH_DSP_VALUEHL 
ab54 cd 3e 9d			call macro_dsp_valuehl 
ab57				endm 
# End of macro FORTH_DSP_VALUEHL
ab57				 
ab57					FORTH_DSP_POP 
ab57 cd f6 9d			call macro_forth_dsp_pop 
ab5a				endm 
# End of macro FORTH_DSP_POP
ab5a			 
ab5a 7d					ld a, l 
ab5b 21 e6 e7				ld hl, os_var_array 
ab5e cd db 8c				call addatohl 
ab61			 
ab61 cd 47 9b				call forth_push_numhl 
ab64			 
ab64				       NEXTW 
ab64 c3 f4 9e			jp macro_next 
ab67				endm 
# End of macro NEXTW
ab67			 
ab67			.INC: 
ab67				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab67 6f				db WORD_SYS_CORE+91             
ab68 bd ab			dw .DEC            
ab6a 03				db 2 + 1 
ab6b .. 00			db "+!",0              
ab6e				endm 
# End of macro CWHEAD
ab6e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab6e					if DEBUG_FORTH_WORDS_KEY 
ab6e						DMARK "+s_" 
ab6e f5				push af  
ab6f 3a 83 ab			ld a, (.dmark)  
ab72 32 6b ee			ld (debug_mark),a  
ab75 3a 84 ab			ld a, (.dmark+1)  
ab78 32 6c ee			ld (debug_mark+1),a  
ab7b 3a 85 ab			ld a, (.dmark+2)  
ab7e 32 6d ee			ld (debug_mark+2),a  
ab81 18 03			jr .pastdmark  
ab83 ..			.dmark: db "+s_"  
ab86 f1			.pastdmark: pop af  
ab87			endm  
# End of macro DMARK
ab87						CALLMONITOR 
ab87 cd 6f ee			call debug_vector  
ab8a				endm  
# End of macro CALLMONITOR
ab8a					endif 
ab8a			 
ab8a					FORTH_DSP_VALUEHL 
ab8a cd 3e 9d			call macro_dsp_valuehl 
ab8d				endm 
# End of macro FORTH_DSP_VALUEHL
ab8d			 
ab8d e5					push hl   ; save address 
ab8e			 
ab8e					FORTH_DSP_POP 
ab8e cd f6 9d			call macro_forth_dsp_pop 
ab91				endm 
# End of macro FORTH_DSP_POP
ab91			 
ab91					FORTH_DSP_VALUEHL 
ab91 cd 3e 9d			call macro_dsp_valuehl 
ab94				endm 
# End of macro FORTH_DSP_VALUEHL
ab94			 
ab94 e5					push hl 
ab95					FORTH_DSP_POP 
ab95 cd f6 9d			call macro_forth_dsp_pop 
ab98				endm 
# End of macro FORTH_DSP_POP
ab98 e1					pop hl 
ab99			 
ab99					; hl contains value to add to byte at a 
ab99				 
ab99 eb					ex de, hl 
ab9a			 
ab9a e1					pop hl 
ab9b			 
ab9b					if DEBUG_FORTH_WORDS 
ab9b						DMARK "INC" 
ab9b f5				push af  
ab9c 3a b0 ab			ld a, (.dmark)  
ab9f 32 6b ee			ld (debug_mark),a  
aba2 3a b1 ab			ld a, (.dmark+1)  
aba5 32 6c ee			ld (debug_mark+1),a  
aba8 3a b2 ab			ld a, (.dmark+2)  
abab 32 6d ee			ld (debug_mark+2),a  
abae 18 03			jr .pastdmark  
abb0 ..			.dmark: db "INC"  
abb3 f1			.pastdmark: pop af  
abb4			endm  
# End of macro DMARK
abb4						CALLMONITOR 
abb4 cd 6f ee			call debug_vector  
abb7				endm  
# End of macro CALLMONITOR
abb7					endif 
abb7			 
abb7 7e					ld a,(hl) 
abb8 83					add e 
abb9 77					ld (hl),a 
abba			 
abba			 
abba			 
abba				       NEXTW 
abba c3 f4 9e			jp macro_next 
abbd				endm 
# End of macro NEXTW
abbd			 
abbd			.DEC: 
abbd				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abbd 6f				db WORD_SYS_CORE+91             
abbe 11 ac			dw .INC2            
abc0 03				db 2 + 1 
abc1 .. 00			db "-!",0              
abc4				endm 
# End of macro CWHEAD
abc4			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abc4					if DEBUG_FORTH_WORDS_KEY 
abc4						DMARK "-s_" 
abc4 f5				push af  
abc5 3a d9 ab			ld a, (.dmark)  
abc8 32 6b ee			ld (debug_mark),a  
abcb 3a da ab			ld a, (.dmark+1)  
abce 32 6c ee			ld (debug_mark+1),a  
abd1 3a db ab			ld a, (.dmark+2)  
abd4 32 6d ee			ld (debug_mark+2),a  
abd7 18 03			jr .pastdmark  
abd9 ..			.dmark: db "-s_"  
abdc f1			.pastdmark: pop af  
abdd			endm  
# End of macro DMARK
abdd						CALLMONITOR 
abdd cd 6f ee			call debug_vector  
abe0				endm  
# End of macro CALLMONITOR
abe0					endif 
abe0			 
abe0					FORTH_DSP_VALUEHL 
abe0 cd 3e 9d			call macro_dsp_valuehl 
abe3				endm 
# End of macro FORTH_DSP_VALUEHL
abe3			 
abe3 e5					push hl   ; save address 
abe4			 
abe4					FORTH_DSP_POP 
abe4 cd f6 9d			call macro_forth_dsp_pop 
abe7				endm 
# End of macro FORTH_DSP_POP
abe7			 
abe7					FORTH_DSP_VALUEHL 
abe7 cd 3e 9d			call macro_dsp_valuehl 
abea				endm 
# End of macro FORTH_DSP_VALUEHL
abea			 
abea					; hl contains value to add to byte at a 
abea				 
abea eb					ex de, hl 
abeb			 
abeb e1					pop hl 
abec			 
abec					if DEBUG_FORTH_WORDS 
abec						DMARK "DEC" 
abec f5				push af  
abed 3a 01 ac			ld a, (.dmark)  
abf0 32 6b ee			ld (debug_mark),a  
abf3 3a 02 ac			ld a, (.dmark+1)  
abf6 32 6c ee			ld (debug_mark+1),a  
abf9 3a 03 ac			ld a, (.dmark+2)  
abfc 32 6d ee			ld (debug_mark+2),a  
abff 18 03			jr .pastdmark  
ac01 ..			.dmark: db "DEC"  
ac04 f1			.pastdmark: pop af  
ac05			endm  
# End of macro DMARK
ac05						CALLMONITOR 
ac05 cd 6f ee			call debug_vector  
ac08				endm  
# End of macro CALLMONITOR
ac08					endif 
ac08			 
ac08 7e					ld a,(hl) 
ac09 93					sub e 
ac0a 77					ld (hl),a 
ac0b			 
ac0b			 
ac0b					FORTH_DSP_POP 
ac0b cd f6 9d			call macro_forth_dsp_pop 
ac0e				endm 
# End of macro FORTH_DSP_POP
ac0e			 
ac0e				       NEXTW 
ac0e c3 f4 9e			jp macro_next 
ac11				endm 
# End of macro NEXTW
ac11			 
ac11			.INC2: 
ac11				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ac11 6f				db WORD_SYS_CORE+91             
ac12 be ac			dw .DEC2            
ac14 04				db 3 + 1 
ac15 .. 00			db "+2!",0              
ac19				endm 
# End of macro CWHEAD
ac19			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac19			 
ac19					if DEBUG_FORTH_WORDS_KEY 
ac19						DMARK "+2s" 
ac19 f5				push af  
ac1a 3a 2e ac			ld a, (.dmark)  
ac1d 32 6b ee			ld (debug_mark),a  
ac20 3a 2f ac			ld a, (.dmark+1)  
ac23 32 6c ee			ld (debug_mark+1),a  
ac26 3a 30 ac			ld a, (.dmark+2)  
ac29 32 6d ee			ld (debug_mark+2),a  
ac2c 18 03			jr .pastdmark  
ac2e ..			.dmark: db "+2s"  
ac31 f1			.pastdmark: pop af  
ac32			endm  
# End of macro DMARK
ac32						CALLMONITOR 
ac32 cd 6f ee			call debug_vector  
ac35				endm  
# End of macro CALLMONITOR
ac35					endif 
ac35			 
ac35					; Address 
ac35			 
ac35					FORTH_DSP_VALUEHL 
ac35 cd 3e 9d			call macro_dsp_valuehl 
ac38				endm 
# End of macro FORTH_DSP_VALUEHL
ac38			 
ac38 e5					push hl    ; save address 
ac39			 
ac39					; load content into de 
ac39			 
ac39 5e					ld e,(hl) 
ac3a 23					inc hl 
ac3b 56					ld d, (hl) 
ac3c			 
ac3c					if DEBUG_FORTH_WORDS 
ac3c						DMARK "+2a" 
ac3c f5				push af  
ac3d 3a 51 ac			ld a, (.dmark)  
ac40 32 6b ee			ld (debug_mark),a  
ac43 3a 52 ac			ld a, (.dmark+1)  
ac46 32 6c ee			ld (debug_mark+1),a  
ac49 3a 53 ac			ld a, (.dmark+2)  
ac4c 32 6d ee			ld (debug_mark+2),a  
ac4f 18 03			jr .pastdmark  
ac51 ..			.dmark: db "+2a"  
ac54 f1			.pastdmark: pop af  
ac55			endm  
# End of macro DMARK
ac55						CALLMONITOR 
ac55 cd 6f ee			call debug_vector  
ac58				endm  
# End of macro CALLMONITOR
ac58					endif 
ac58			 
ac58					FORTH_DSP_POP 
ac58 cd f6 9d			call macro_forth_dsp_pop 
ac5b				endm 
# End of macro FORTH_DSP_POP
ac5b			 
ac5b					; Get value to add 
ac5b			 
ac5b					FORTH_DSP_VALUE 
ac5b cd 27 9d			call macro_forth_dsp_value 
ac5e				endm 
# End of macro FORTH_DSP_VALUE
ac5e			 
ac5e					if DEBUG_FORTH_WORDS 
ac5e						DMARK "+2v" 
ac5e f5				push af  
ac5f 3a 73 ac			ld a, (.dmark)  
ac62 32 6b ee			ld (debug_mark),a  
ac65 3a 74 ac			ld a, (.dmark+1)  
ac68 32 6c ee			ld (debug_mark+1),a  
ac6b 3a 75 ac			ld a, (.dmark+2)  
ac6e 32 6d ee			ld (debug_mark+2),a  
ac71 18 03			jr .pastdmark  
ac73 ..			.dmark: db "+2v"  
ac76 f1			.pastdmark: pop af  
ac77			endm  
# End of macro DMARK
ac77						CALLMONITOR 
ac77 cd 6f ee			call debug_vector  
ac7a				endm  
# End of macro CALLMONITOR
ac7a					endif 
ac7a			 
ac7a 19					add hl, de 
ac7b			 
ac7b					if DEBUG_FORTH_WORDS 
ac7b						DMARK "+2+" 
ac7b f5				push af  
ac7c 3a 90 ac			ld a, (.dmark)  
ac7f 32 6b ee			ld (debug_mark),a  
ac82 3a 91 ac			ld a, (.dmark+1)  
ac85 32 6c ee			ld (debug_mark+1),a  
ac88 3a 92 ac			ld a, (.dmark+2)  
ac8b 32 6d ee			ld (debug_mark+2),a  
ac8e 18 03			jr .pastdmark  
ac90 ..			.dmark: db "+2+"  
ac93 f1			.pastdmark: pop af  
ac94			endm  
# End of macro DMARK
ac94						CALLMONITOR 
ac94 cd 6f ee			call debug_vector  
ac97				endm  
# End of macro CALLMONITOR
ac97					endif 
ac97			 
ac97					; move result to de 
ac97			 
ac97 eb					ex de, hl 
ac98			 
ac98					; Address 
ac98			 
ac98 e1					pop hl 
ac99			 
ac99					; save it back 
ac99			 
ac99 73					ld (hl), e 
ac9a 23					inc hl 
ac9b 72					ld (hl), d 
ac9c			 
ac9c					if DEBUG_FORTH_WORDS 
ac9c						DMARK "+2e" 
ac9c f5				push af  
ac9d 3a b1 ac			ld a, (.dmark)  
aca0 32 6b ee			ld (debug_mark),a  
aca3 3a b2 ac			ld a, (.dmark+1)  
aca6 32 6c ee			ld (debug_mark+1),a  
aca9 3a b3 ac			ld a, (.dmark+2)  
acac 32 6d ee			ld (debug_mark+2),a  
acaf 18 03			jr .pastdmark  
acb1 ..			.dmark: db "+2e"  
acb4 f1			.pastdmark: pop af  
acb5			endm  
# End of macro DMARK
acb5						CALLMONITOR 
acb5 cd 6f ee			call debug_vector  
acb8				endm  
# End of macro CALLMONITOR
acb8					endif 
acb8			 
acb8			 
acb8			 
acb8					FORTH_DSP_POP 
acb8 cd f6 9d			call macro_forth_dsp_pop 
acbb				endm 
# End of macro FORTH_DSP_POP
acbb			 
acbb			 
acbb				       NEXTW 
acbb c3 f4 9e			jp macro_next 
acbe				endm 
# End of macro NEXTW
acbe			 
acbe			.DEC2: 
acbe				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
acbe 6f				db WORD_SYS_CORE+91             
acbf 6d ad			dw .GET2            
acc1 04				db 3 + 1 
acc2 .. 00			db "-2!",0              
acc6				endm 
# End of macro CWHEAD
acc6			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acc6			 
acc6			 
acc6					if DEBUG_FORTH_WORDS_KEY 
acc6						DMARK "-2s" 
acc6 f5				push af  
acc7 3a db ac			ld a, (.dmark)  
acca 32 6b ee			ld (debug_mark),a  
accd 3a dc ac			ld a, (.dmark+1)  
acd0 32 6c ee			ld (debug_mark+1),a  
acd3 3a dd ac			ld a, (.dmark+2)  
acd6 32 6d ee			ld (debug_mark+2),a  
acd9 18 03			jr .pastdmark  
acdb ..			.dmark: db "-2s"  
acde f1			.pastdmark: pop af  
acdf			endm  
# End of macro DMARK
acdf						CALLMONITOR 
acdf cd 6f ee			call debug_vector  
ace2				endm  
# End of macro CALLMONITOR
ace2					endif 
ace2			 
ace2					; Address 
ace2			 
ace2					FORTH_DSP_VALUEHL 
ace2 cd 3e 9d			call macro_dsp_valuehl 
ace5				endm 
# End of macro FORTH_DSP_VALUEHL
ace5			 
ace5 e5					push hl    ; save address 
ace6			 
ace6					; load content into de 
ace6			 
ace6 5e					ld e,(hl) 
ace7 23					inc hl 
ace8 56					ld d, (hl) 
ace9			 
ace9					if DEBUG_FORTH_WORDS 
ace9						DMARK "-2a" 
ace9 f5				push af  
acea 3a fe ac			ld a, (.dmark)  
aced 32 6b ee			ld (debug_mark),a  
acf0 3a ff ac			ld a, (.dmark+1)  
acf3 32 6c ee			ld (debug_mark+1),a  
acf6 3a 00 ad			ld a, (.dmark+2)  
acf9 32 6d ee			ld (debug_mark+2),a  
acfc 18 03			jr .pastdmark  
acfe ..			.dmark: db "-2a"  
ad01 f1			.pastdmark: pop af  
ad02			endm  
# End of macro DMARK
ad02						CALLMONITOR 
ad02 cd 6f ee			call debug_vector  
ad05				endm  
# End of macro CALLMONITOR
ad05					endif 
ad05			 
ad05					FORTH_DSP_POP 
ad05 cd f6 9d			call macro_forth_dsp_pop 
ad08				endm 
# End of macro FORTH_DSP_POP
ad08			 
ad08					; Get value to remove 
ad08			 
ad08					FORTH_DSP_VALUE 
ad08 cd 27 9d			call macro_forth_dsp_value 
ad0b				endm 
# End of macro FORTH_DSP_VALUE
ad0b			 
ad0b					if DEBUG_FORTH_WORDS 
ad0b						DMARK "-2v" 
ad0b f5				push af  
ad0c 3a 20 ad			ld a, (.dmark)  
ad0f 32 6b ee			ld (debug_mark),a  
ad12 3a 21 ad			ld a, (.dmark+1)  
ad15 32 6c ee			ld (debug_mark+1),a  
ad18 3a 22 ad			ld a, (.dmark+2)  
ad1b 32 6d ee			ld (debug_mark+2),a  
ad1e 18 03			jr .pastdmark  
ad20 ..			.dmark: db "-2v"  
ad23 f1			.pastdmark: pop af  
ad24			endm  
# End of macro DMARK
ad24						CALLMONITOR 
ad24 cd 6f ee			call debug_vector  
ad27				endm  
# End of macro CALLMONITOR
ad27					endif 
ad27			 
ad27 eb					ex de, hl 
ad28 ed 52				sbc hl, de 
ad2a			 
ad2a					if DEBUG_FORTH_WORDS 
ad2a						DMARK "-2d" 
ad2a f5				push af  
ad2b 3a 3f ad			ld a, (.dmark)  
ad2e 32 6b ee			ld (debug_mark),a  
ad31 3a 40 ad			ld a, (.dmark+1)  
ad34 32 6c ee			ld (debug_mark+1),a  
ad37 3a 41 ad			ld a, (.dmark+2)  
ad3a 32 6d ee			ld (debug_mark+2),a  
ad3d 18 03			jr .pastdmark  
ad3f ..			.dmark: db "-2d"  
ad42 f1			.pastdmark: pop af  
ad43			endm  
# End of macro DMARK
ad43						CALLMONITOR 
ad43 cd 6f ee			call debug_vector  
ad46				endm  
# End of macro CALLMONITOR
ad46					endif 
ad46			 
ad46					; move result to de 
ad46			 
ad46 eb					ex de, hl 
ad47			 
ad47					; Address 
ad47			 
ad47 e1					pop hl 
ad48			 
ad48					; save it back 
ad48			 
ad48 73					ld (hl), e 
ad49 23					inc hl 
ad4a 72					ld (hl), d 
ad4b			 
ad4b					if DEBUG_FORTH_WORDS 
ad4b						DMARK "-2e" 
ad4b f5				push af  
ad4c 3a 60 ad			ld a, (.dmark)  
ad4f 32 6b ee			ld (debug_mark),a  
ad52 3a 61 ad			ld a, (.dmark+1)  
ad55 32 6c ee			ld (debug_mark+1),a  
ad58 3a 62 ad			ld a, (.dmark+2)  
ad5b 32 6d ee			ld (debug_mark+2),a  
ad5e 18 03			jr .pastdmark  
ad60 ..			.dmark: db "-2e"  
ad63 f1			.pastdmark: pop af  
ad64			endm  
# End of macro DMARK
ad64						CALLMONITOR 
ad64 cd 6f ee			call debug_vector  
ad67				endm  
# End of macro CALLMONITOR
ad67					endif 
ad67			 
ad67			 
ad67					FORTH_DSP_POP 
ad67 cd f6 9d			call macro_forth_dsp_pop 
ad6a				endm 
# End of macro FORTH_DSP_POP
ad6a			 
ad6a			 
ad6a			 
ad6a				       NEXTW 
ad6a c3 f4 9e			jp macro_next 
ad6d				endm 
# End of macro NEXTW
ad6d			.GET2: 
ad6d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad6d 6f				db WORD_SYS_CORE+91             
ad6e a2 ad			dw .BANG2            
ad70 03				db 2 + 1 
ad71 .. 00			db "2@",0              
ad74				endm 
# End of macro CWHEAD
ad74			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad74					if DEBUG_FORTH_WORDS_KEY 
ad74						DMARK "2A_" 
ad74 f5				push af  
ad75 3a 89 ad			ld a, (.dmark)  
ad78 32 6b ee			ld (debug_mark),a  
ad7b 3a 8a ad			ld a, (.dmark+1)  
ad7e 32 6c ee			ld (debug_mark+1),a  
ad81 3a 8b ad			ld a, (.dmark+2)  
ad84 32 6d ee			ld (debug_mark+2),a  
ad87 18 03			jr .pastdmark  
ad89 ..			.dmark: db "2A_"  
ad8c f1			.pastdmark: pop af  
ad8d			endm  
# End of macro DMARK
ad8d						CALLMONITOR 
ad8d cd 6f ee			call debug_vector  
ad90				endm  
# End of macro CALLMONITOR
ad90					endif 
ad90			 
ad90					FORTH_DSP_VALUEHL 
ad90 cd 3e 9d			call macro_dsp_valuehl 
ad93				endm 
# End of macro FORTH_DSP_VALUEHL
ad93			 
ad93 e5					push hl   ; save address 
ad94			 
ad94					FORTH_DSP_POP 
ad94 cd f6 9d			call macro_forth_dsp_pop 
ad97				endm 
# End of macro FORTH_DSP_POP
ad97			 
ad97 e1					pop hl 
ad98			 
ad98 5e					ld e, (hl) 
ad99 23					inc hl 
ad9a 56					ld d, (hl) 
ad9b			 
ad9b eb					ex de, hl 
ad9c			 
ad9c cd 47 9b				call forth_push_numhl 
ad9f			 
ad9f				       NEXTW 
ad9f c3 f4 9e			jp macro_next 
ada2				endm 
# End of macro NEXTW
ada2			.BANG2: 
ada2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ada2 6f				db WORD_SYS_CORE+91             
ada3 da ad			dw .CONFIG            
ada5 03				db 2 + 1 
ada6 .. 00			db "2!",0              
ada9				endm 
# End of macro CWHEAD
ada9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ada9					if DEBUG_FORTH_WORDS_KEY 
ada9						DMARK "2S_" 
ada9 f5				push af  
adaa 3a be ad			ld a, (.dmark)  
adad 32 6b ee			ld (debug_mark),a  
adb0 3a bf ad			ld a, (.dmark+1)  
adb3 32 6c ee			ld (debug_mark+1),a  
adb6 3a c0 ad			ld a, (.dmark+2)  
adb9 32 6d ee			ld (debug_mark+2),a  
adbc 18 03			jr .pastdmark  
adbe ..			.dmark: db "2S_"  
adc1 f1			.pastdmark: pop af  
adc2			endm  
# End of macro DMARK
adc2						CALLMONITOR 
adc2 cd 6f ee			call debug_vector  
adc5				endm  
# End of macro CALLMONITOR
adc5					endif 
adc5			 
adc5					FORTH_DSP_VALUEHL 
adc5 cd 3e 9d			call macro_dsp_valuehl 
adc8				endm 
# End of macro FORTH_DSP_VALUEHL
adc8			 
adc8 e5					push hl   ; save address 
adc9			 
adc9			 
adc9					FORTH_DSP_POP 
adc9 cd f6 9d			call macro_forth_dsp_pop 
adcc				endm 
# End of macro FORTH_DSP_POP
adcc			 
adcc					 
adcc					FORTH_DSP_VALUEHL 
adcc cd 3e 9d			call macro_dsp_valuehl 
adcf				endm 
# End of macro FORTH_DSP_VALUEHL
adcf			 
adcf					FORTH_DSP_POP 
adcf cd f6 9d			call macro_forth_dsp_pop 
add2				endm 
# End of macro FORTH_DSP_POP
add2			 
add2 eb					ex de, hl    ; value now in de 
add3			 
add3 e1					pop hl 
add4			 
add4 73					ld (hl), e 
add5			 
add5 23					inc hl 
add6			 
add6 72					ld (hl), d 
add7			 
add7			 
add7				       NEXTW 
add7 c3 f4 9e			jp macro_next 
adda				endm 
# End of macro NEXTW
adda			.CONFIG: 
adda				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
adda 6f				db WORD_SYS_CORE+91             
addb eb ad			dw .ADTOS            
addd 07				db 6 + 1 
adde .. 00			db "CONFIG",0              
ade5				endm 
# End of macro CWHEAD
ade5			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ade5			 
ade5 cd 47 93				call config 
ade8					NEXTW 
ade8 c3 f4 9e			jp macro_next 
adeb				endm 
# End of macro NEXTW
adeb			 
adeb			.ADTOS: 
adeb				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
adeb 6f				db WORD_SYS_CORE+91             
adec 01 ae			dw .SBTOS            
adee 03				db 2 + 1 
adef .. 00			db "1+",0              
adf2				endm 
# End of macro CWHEAD
adf2			; | 1+ ( u -- u )  Increment value on TOS | DONE 
adf2			 
adf2					FORTH_DSP_VALUEHL 
adf2 cd 3e 9d			call macro_dsp_valuehl 
adf5				endm 
# End of macro FORTH_DSP_VALUEHL
adf5 e5					push hl 
adf6			 
adf6					FORTH_DSP_POP 
adf6 cd f6 9d			call macro_forth_dsp_pop 
adf9				endm 
# End of macro FORTH_DSP_POP
adf9 e1					pop hl 
adfa			 
adfa 23					inc hl 
adfb cd 47 9b				call forth_push_numhl 
adfe					 
adfe					NEXTW 
adfe c3 f4 9e			jp macro_next 
ae01				endm 
# End of macro NEXTW
ae01			.SBTOS: 
ae01				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ae01 6f				db WORD_SYS_CORE+91             
ae02 17 ae			dw .ADSTORE            
ae04 03				db 2 + 1 
ae05 .. 00			db "1-",0              
ae08				endm 
# End of macro CWHEAD
ae08			; | 1- ( u -- u )  Decrement value on TOS | DONE 
ae08			 
ae08					FORTH_DSP_VALUEHL 
ae08 cd 3e 9d			call macro_dsp_valuehl 
ae0b				endm 
# End of macro FORTH_DSP_VALUEHL
ae0b e5					push hl 
ae0c			 
ae0c					FORTH_DSP_POP 
ae0c cd f6 9d			call macro_forth_dsp_pop 
ae0f				endm 
# End of macro FORTH_DSP_POP
ae0f e1					pop hl 
ae10			 
ae10 2b					dec hl 
ae11 cd 47 9b				call forth_push_numhl 
ae14					 
ae14					NEXTW 
ae14 c3 f4 9e			jp macro_next 
ae17				endm 
# End of macro NEXTW
ae17			.ADSTORE: 
ae17				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ae17 6f				db WORD_SYS_CORE+91             
ae18 2d ae			dw .ADWSTORE            
ae1a 04				db 3 + 1 
ae1b .. 00			db "1+!",0              
ae1f				endm 
# End of macro CWHEAD
ae1f			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ae1f			 
ae1f					FORTH_DSP_VALUEHL 
ae1f cd 3e 9d			call macro_dsp_valuehl 
ae22				endm 
# End of macro FORTH_DSP_VALUEHL
ae22 e5					push hl 
ae23			 
ae23					FORTH_DSP_POP 
ae23 cd f6 9d			call macro_forth_dsp_pop 
ae26				endm 
# End of macro FORTH_DSP_POP
ae26 e1					pop hl 
ae27			 
ae27 7e					ld a, (hl) 
ae28 3c					inc a 
ae29 77					ld (hl), a 
ae2a					 
ae2a					NEXTW 
ae2a c3 f4 9e			jp macro_next 
ae2d				endm 
# End of macro NEXTW
ae2d			.ADWSTORE: 
ae2d				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ae2d 6f				db WORD_SYS_CORE+91             
ae2e 4b ae			dw .SBSTORE            
ae30 05				db 4 + 1 
ae31 .. 00			db "1+2!",0              
ae36				endm 
# End of macro CWHEAD
ae36			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ae36			 
ae36					FORTH_DSP_VALUEHL 
ae36 cd 3e 9d			call macro_dsp_valuehl 
ae39				endm 
# End of macro FORTH_DSP_VALUEHL
ae39 e5					push hl 
ae3a			 
ae3a					FORTH_DSP_POP 
ae3a cd f6 9d			call macro_forth_dsp_pop 
ae3d				endm 
# End of macro FORTH_DSP_POP
ae3d e1					pop hl 
ae3e			 
ae3e e5					push hl 
ae3f			 
ae3f cd 76 9e				call loadwordinhl 
ae42 23					inc hl 
ae43			 
ae43 d1					pop de 
ae44 eb					ex de, hl 
ae45 73					ld (hl), e 
ae46 23					inc hl 
ae47 72					ld (hl), d 
ae48					 
ae48					NEXTW 
ae48 c3 f4 9e			jp macro_next 
ae4b				endm 
# End of macro NEXTW
ae4b			.SBSTORE: 
ae4b				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ae4b 6f				db WORD_SYS_CORE+91             
ae4c 61 ae			dw .SBWSTORE            
ae4e 04				db 3 + 1 
ae4f .. 00			db "1-!",0              
ae53				endm 
# End of macro CWHEAD
ae53			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
ae53			 
ae53					FORTH_DSP_VALUEHL 
ae53 cd 3e 9d			call macro_dsp_valuehl 
ae56				endm 
# End of macro FORTH_DSP_VALUEHL
ae56 e5					push hl 
ae57			 
ae57					FORTH_DSP_POP 
ae57 cd f6 9d			call macro_forth_dsp_pop 
ae5a				endm 
# End of macro FORTH_DSP_POP
ae5a e1					pop hl 
ae5b			 
ae5b 7e					ld a, (hl) 
ae5c 3d					dec a 
ae5d 77					ld (hl), a 
ae5e					 
ae5e					NEXTW 
ae5e c3 f4 9e			jp macro_next 
ae61				endm 
# End of macro NEXTW
ae61			.SBWSTORE: 
ae61				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
ae61 6f				db WORD_SYS_CORE+91             
ae62 7f ae			dw .ENDCORE            
ae64 05				db 4 + 1 
ae65 .. 00			db "1-2!",0              
ae6a				endm 
# End of macro CWHEAD
ae6a			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
ae6a			 
ae6a					FORTH_DSP_VALUEHL 
ae6a cd 3e 9d			call macro_dsp_valuehl 
ae6d				endm 
# End of macro FORTH_DSP_VALUEHL
ae6d e5					push hl 
ae6e			 
ae6e					FORTH_DSP_POP 
ae6e cd f6 9d			call macro_forth_dsp_pop 
ae71				endm 
# End of macro FORTH_DSP_POP
ae71 e1					pop hl 
ae72			 
ae72 e5					push hl 
ae73			 
ae73 cd 76 9e				call loadwordinhl 
ae76 2b					dec hl 
ae77			 
ae77 d1					pop de 
ae78 eb					ex de, hl 
ae79 73					ld (hl), e 
ae7a 23					inc hl 
ae7b 72					ld (hl), d 
ae7c					 
ae7c					NEXTW 
ae7c c3 f4 9e			jp macro_next 
ae7f				endm 
# End of macro NEXTW
ae7f			.ENDCORE: 
ae7f			 
ae7f			; eof 
ae7f			 
ae7f			 
# End of file forth_words_core.asm
ae7f			include "forth_words_flow.asm" 
ae7f			 
ae7f			; | ## Program Flow Words 
ae7f			 
ae7f			.IF: 
ae7f				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ae7f 1e				db WORD_SYS_CORE+10             
ae80 74 af			dw .THEN            
ae82 03				db 2 + 1 
ae83 .. 00			db "IF",0              
ae86				endm 
# End of macro CWHEAD
ae86			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ae86			; 
ae86					if DEBUG_FORTH_WORDS_KEY 
ae86						DMARK "IF." 
ae86 f5				push af  
ae87 3a 9b ae			ld a, (.dmark)  
ae8a 32 6b ee			ld (debug_mark),a  
ae8d 3a 9c ae			ld a, (.dmark+1)  
ae90 32 6c ee			ld (debug_mark+1),a  
ae93 3a 9d ae			ld a, (.dmark+2)  
ae96 32 6d ee			ld (debug_mark+2),a  
ae99 18 03			jr .pastdmark  
ae9b ..			.dmark: db "IF."  
ae9e f1			.pastdmark: pop af  
ae9f			endm  
# End of macro DMARK
ae9f						CALLMONITOR 
ae9f cd 6f ee			call debug_vector  
aea2				endm  
# End of macro CALLMONITOR
aea2					endif 
aea2			; eval TOS 
aea2			 
aea2				FORTH_DSP_VALUEHL 
aea2 cd 3e 9d			call macro_dsp_valuehl 
aea5				endm 
# End of macro FORTH_DSP_VALUEHL
aea5			 
aea5			;	push hl 
aea5				FORTH_DSP_POP 
aea5 cd f6 9d			call macro_forth_dsp_pop 
aea8				endm 
# End of macro FORTH_DSP_POP
aea8			;	pop hl 
aea8			 
aea8					if DEBUG_FORTH_WORDS 
aea8						DMARK "IF1" 
aea8 f5				push af  
aea9 3a bd ae			ld a, (.dmark)  
aeac 32 6b ee			ld (debug_mark),a  
aeaf 3a be ae			ld a, (.dmark+1)  
aeb2 32 6c ee			ld (debug_mark+1),a  
aeb5 3a bf ae			ld a, (.dmark+2)  
aeb8 32 6d ee			ld (debug_mark+2),a  
aebb 18 03			jr .pastdmark  
aebd ..			.dmark: db "IF1"  
aec0 f1			.pastdmark: pop af  
aec1			endm  
# End of macro DMARK
aec1						CALLMONITOR 
aec1 cd 6f ee			call debug_vector  
aec4				endm  
# End of macro CALLMONITOR
aec4					endif 
aec4 b7				or a        ; clear carry flag 
aec5 11 00 00			ld de, 0 
aec8 eb				ex de,hl 
aec9 ed 52			sbc hl, de 
aecb c2 55 af			jp nz, .iftrue 
aece			 
aece					if DEBUG_FORTH_WORDS 
aece						DMARK "IF2" 
aece f5				push af  
aecf 3a e3 ae			ld a, (.dmark)  
aed2 32 6b ee			ld (debug_mark),a  
aed5 3a e4 ae			ld a, (.dmark+1)  
aed8 32 6c ee			ld (debug_mark+1),a  
aedb 3a e5 ae			ld a, (.dmark+2)  
aede 32 6d ee			ld (debug_mark+2),a  
aee1 18 03			jr .pastdmark  
aee3 ..			.dmark: db "IF2"  
aee6 f1			.pastdmark: pop af  
aee7			endm  
# End of macro DMARK
aee7						CALLMONITOR 
aee7 cd 6f ee			call debug_vector  
aeea				endm  
# End of macro CALLMONITOR
aeea					endif 
aeea			 
aeea			; if not true then skip to THEN 
aeea			 
aeea				; TODO get tok_ptr 
aeea				; TODO consume toks until we get to THEN 
aeea			 
aeea 2a c2 e5			ld hl, (os_tok_ptr) 
aeed					if DEBUG_FORTH_WORDS 
aeed						DMARK "IF3" 
aeed f5				push af  
aeee 3a 02 af			ld a, (.dmark)  
aef1 32 6b ee			ld (debug_mark),a  
aef4 3a 03 af			ld a, (.dmark+1)  
aef7 32 6c ee			ld (debug_mark+1),a  
aefa 3a 04 af			ld a, (.dmark+2)  
aefd 32 6d ee			ld (debug_mark+2),a  
af00 18 03			jr .pastdmark  
af02 ..			.dmark: db "IF3"  
af05 f1			.pastdmark: pop af  
af06			endm  
# End of macro DMARK
af06						CALLMONITOR 
af06 cd 6f ee			call debug_vector  
af09				endm  
# End of macro CALLMONITOR
af09						 
af09					endif 
af09 11 50 af			ld de, .ifthen 
af0c					if DEBUG_FORTH_WORDS 
af0c						DMARK "IF4" 
af0c f5				push af  
af0d 3a 21 af			ld a, (.dmark)  
af10 32 6b ee			ld (debug_mark),a  
af13 3a 22 af			ld a, (.dmark+1)  
af16 32 6c ee			ld (debug_mark+1),a  
af19 3a 23 af			ld a, (.dmark+2)  
af1c 32 6d ee			ld (debug_mark+2),a  
af1f 18 03			jr .pastdmark  
af21 ..			.dmark: db "IF4"  
af24 f1			.pastdmark: pop af  
af25			endm  
# End of macro DMARK
af25						CALLMONITOR 
af25 cd 6f ee			call debug_vector  
af28				endm  
# End of macro CALLMONITOR
af28					endif 
af28 cd 0f a0			call findnexttok  
af2b			 
af2b					if DEBUG_FORTH_WORDS 
af2b						DMARK "IF5" 
af2b f5				push af  
af2c 3a 40 af			ld a, (.dmark)  
af2f 32 6b ee			ld (debug_mark),a  
af32 3a 41 af			ld a, (.dmark+1)  
af35 32 6c ee			ld (debug_mark+1),a  
af38 3a 42 af			ld a, (.dmark+2)  
af3b 32 6d ee			ld (debug_mark+2),a  
af3e 18 03			jr .pastdmark  
af40 ..			.dmark: db "IF5"  
af43 f1			.pastdmark: pop af  
af44			endm  
# End of macro DMARK
af44						CALLMONITOR 
af44 cd 6f ee			call debug_vector  
af47				endm  
# End of macro CALLMONITOR
af47					endif 
af47				; TODO replace below with ; exec using tok_ptr 
af47 22 c2 e5			ld (os_tok_ptr), hl 
af4a c3 85 9f			jp exec1 
af4d				NEXTW 
af4d c3 f4 9e			jp macro_next 
af50				endm 
# End of macro NEXTW
af50			 
af50 .. 00		.ifthen:  db "THEN",0 
af55			 
af55			.iftrue:		 
af55				; Exec next words normally 
af55			 
af55				; if true then exec following IF as normal 
af55					if DEBUG_FORTH_WORDS 
af55						DMARK "IFT" 
af55 f5				push af  
af56 3a 6a af			ld a, (.dmark)  
af59 32 6b ee			ld (debug_mark),a  
af5c 3a 6b af			ld a, (.dmark+1)  
af5f 32 6c ee			ld (debug_mark+1),a  
af62 3a 6c af			ld a, (.dmark+2)  
af65 32 6d ee			ld (debug_mark+2),a  
af68 18 03			jr .pastdmark  
af6a ..			.dmark: db "IFT"  
af6d f1			.pastdmark: pop af  
af6e			endm  
# End of macro DMARK
af6e						CALLMONITOR 
af6e cd 6f ee			call debug_vector  
af71				endm  
# End of macro CALLMONITOR
af71					endif 
af71			 
af71					NEXTW 
af71 c3 f4 9e			jp macro_next 
af74				endm 
# End of macro NEXTW
af74			.THEN: 
af74				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
af74 1f				db WORD_SYS_CORE+11             
af75 9c af			dw .ELSE            
af77 05				db 4 + 1 
af78 .. 00			db "THEN",0              
af7d				endm 
# End of macro CWHEAD
af7d			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
af7d					if DEBUG_FORTH_WORDS_KEY 
af7d						DMARK "THN" 
af7d f5				push af  
af7e 3a 92 af			ld a, (.dmark)  
af81 32 6b ee			ld (debug_mark),a  
af84 3a 93 af			ld a, (.dmark+1)  
af87 32 6c ee			ld (debug_mark+1),a  
af8a 3a 94 af			ld a, (.dmark+2)  
af8d 32 6d ee			ld (debug_mark+2),a  
af90 18 03			jr .pastdmark  
af92 ..			.dmark: db "THN"  
af95 f1			.pastdmark: pop af  
af96			endm  
# End of macro DMARK
af96						CALLMONITOR 
af96 cd 6f ee			call debug_vector  
af99				endm  
# End of macro CALLMONITOR
af99					endif 
af99					NEXTW 
af99 c3 f4 9e			jp macro_next 
af9c				endm 
# End of macro NEXTW
af9c			.ELSE: 
af9c				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af9c 20				db WORD_SYS_CORE+12             
af9d c4 af			dw .DO            
af9f 03				db 2 + 1 
afa0 .. 00			db "ELSE",0              
afa5				endm 
# End of macro CWHEAD
afa5			; | ELSE ( -- ) Not supported - does nothing | TODO 
afa5			 
afa5					if DEBUG_FORTH_WORDS_KEY 
afa5						DMARK "ELS" 
afa5 f5				push af  
afa6 3a ba af			ld a, (.dmark)  
afa9 32 6b ee			ld (debug_mark),a  
afac 3a bb af			ld a, (.dmark+1)  
afaf 32 6c ee			ld (debug_mark+1),a  
afb2 3a bc af			ld a, (.dmark+2)  
afb5 32 6d ee			ld (debug_mark+2),a  
afb8 18 03			jr .pastdmark  
afba ..			.dmark: db "ELS"  
afbd f1			.pastdmark: pop af  
afbe			endm  
# End of macro DMARK
afbe						CALLMONITOR 
afbe cd 6f ee			call debug_vector  
afc1				endm  
# End of macro CALLMONITOR
afc1					endif 
afc1			 
afc1			 
afc1					NEXTW 
afc1 c3 f4 9e			jp macro_next 
afc4				endm 
# End of macro NEXTW
afc4			.DO: 
afc4				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
afc4 21				db WORD_SYS_CORE+13             
afc5 eb b0			dw .LOOP            
afc7 03				db 2 + 1 
afc8 .. 00			db "DO",0              
afcb				endm 
# End of macro CWHEAD
afcb			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
afcb			 
afcb					if DEBUG_FORTH_WORDS_KEY 
afcb						DMARK "DO." 
afcb f5				push af  
afcc 3a e0 af			ld a, (.dmark)  
afcf 32 6b ee			ld (debug_mark),a  
afd2 3a e1 af			ld a, (.dmark+1)  
afd5 32 6c ee			ld (debug_mark+1),a  
afd8 3a e2 af			ld a, (.dmark+2)  
afdb 32 6d ee			ld (debug_mark+2),a  
afde 18 03			jr .pastdmark  
afe0 ..			.dmark: db "DO."  
afe3 f1			.pastdmark: pop af  
afe4			endm  
# End of macro DMARK
afe4						CALLMONITOR 
afe4 cd 6f ee			call debug_vector  
afe7				endm  
# End of macro CALLMONITOR
afe7					endif 
afe7			;  push pc to rsp stack past the DO 
afe7			 
afe7 2a c2 e5				ld hl, (os_tok_ptr) 
afea 23					inc hl   ; D 
afeb 23					inc hl  ; O 
afec 23					inc hl   ; null 
afed					if DEBUG_FORTH_WORDS 
afed						DMARK "DO2" 
afed f5				push af  
afee 3a 02 b0			ld a, (.dmark)  
aff1 32 6b ee			ld (debug_mark),a  
aff4 3a 03 b0			ld a, (.dmark+1)  
aff7 32 6c ee			ld (debug_mark+1),a  
affa 3a 04 b0			ld a, (.dmark+2)  
affd 32 6d ee			ld (debug_mark+2),a  
b000 18 03			jr .pastdmark  
b002 ..			.dmark: db "DO2"  
b005 f1			.pastdmark: pop af  
b006			endm  
# End of macro DMARK
b006						CALLMONITOR 
b006 cd 6f ee			call debug_vector  
b009				endm  
# End of macro CALLMONITOR
b009					endif 
b009					FORTH_RSP_NEXT 
b009 cd ee 9a			call macro_forth_rsp_next 
b00c				endm 
# End of macro FORTH_RSP_NEXT
b00c					if DEBUG_FORTH_WORDS 
b00c						DMARK "DO3" 
b00c f5				push af  
b00d 3a 21 b0			ld a, (.dmark)  
b010 32 6b ee			ld (debug_mark),a  
b013 3a 22 b0			ld a, (.dmark+1)  
b016 32 6c ee			ld (debug_mark+1),a  
b019 3a 23 b0			ld a, (.dmark+2)  
b01c 32 6d ee			ld (debug_mark+2),a  
b01f 18 03			jr .pastdmark  
b021 ..			.dmark: db "DO3"  
b024 f1			.pastdmark: pop af  
b025			endm  
# End of macro DMARK
b025						CALLMONITOR 
b025 cd 6f ee			call debug_vector  
b028				endm  
# End of macro CALLMONITOR
b028					endif 
b028			 
b028					;if DEBUG_FORTH_WORDS 
b028				;		push hl 
b028			;		endif  
b028			 
b028			; get counters from data stack 
b028			 
b028			 
b028					FORTH_DSP_VALUEHL 
b028 cd 3e 9d			call macro_dsp_valuehl 
b02b				endm 
# End of macro FORTH_DSP_VALUEHL
b02b e5					push hl		 ; hl now has starting counter which needs to be tos 
b02c			 
b02c					if DEBUG_FORTH_WORDS 
b02c						DMARK "DO4" 
b02c f5				push af  
b02d 3a 41 b0			ld a, (.dmark)  
b030 32 6b ee			ld (debug_mark),a  
b033 3a 42 b0			ld a, (.dmark+1)  
b036 32 6c ee			ld (debug_mark+1),a  
b039 3a 43 b0			ld a, (.dmark+2)  
b03c 32 6d ee			ld (debug_mark+2),a  
b03f 18 03			jr .pastdmark  
b041 ..			.dmark: db "DO4"  
b044 f1			.pastdmark: pop af  
b045			endm  
# End of macro DMARK
b045						CALLMONITOR 
b045 cd 6f ee			call debug_vector  
b048				endm  
# End of macro CALLMONITOR
b048					endif 
b048					FORTH_DSP_POP 
b048 cd f6 9d			call macro_forth_dsp_pop 
b04b				endm 
# End of macro FORTH_DSP_POP
b04b			 
b04b					if DEBUG_FORTH_WORDS 
b04b						DMARK "DO5" 
b04b f5				push af  
b04c 3a 60 b0			ld a, (.dmark)  
b04f 32 6b ee			ld (debug_mark),a  
b052 3a 61 b0			ld a, (.dmark+1)  
b055 32 6c ee			ld (debug_mark+1),a  
b058 3a 62 b0			ld a, (.dmark+2)  
b05b 32 6d ee			ld (debug_mark+2),a  
b05e 18 03			jr .pastdmark  
b060 ..			.dmark: db "DO5"  
b063 f1			.pastdmark: pop af  
b064			endm  
# End of macro DMARK
b064						CALLMONITOR 
b064 cd 6f ee			call debug_vector  
b067				endm  
# End of macro CALLMONITOR
b067					endif 
b067			 
b067					FORTH_DSP_VALUEHL 
b067 cd 3e 9d			call macro_dsp_valuehl 
b06a				endm 
# End of macro FORTH_DSP_VALUEHL
b06a			;		push hl		 ; hl now has starting limit counter 
b06a			 
b06a					if DEBUG_FORTH_WORDS 
b06a						DMARK "DO6" 
b06a f5				push af  
b06b 3a 7f b0			ld a, (.dmark)  
b06e 32 6b ee			ld (debug_mark),a  
b071 3a 80 b0			ld a, (.dmark+1)  
b074 32 6c ee			ld (debug_mark+1),a  
b077 3a 81 b0			ld a, (.dmark+2)  
b07a 32 6d ee			ld (debug_mark+2),a  
b07d 18 03			jr .pastdmark  
b07f ..			.dmark: db "DO6"  
b082 f1			.pastdmark: pop af  
b083			endm  
# End of macro DMARK
b083						CALLMONITOR 
b083 cd 6f ee			call debug_vector  
b086				endm  
# End of macro CALLMONITOR
b086					endif 
b086					FORTH_DSP_POP 
b086 cd f6 9d			call macro_forth_dsp_pop 
b089				endm 
# End of macro FORTH_DSP_POP
b089			 
b089			; put counters on the loop stack 
b089			 
b089			;		pop hl			 ; limit counter 
b089 d1					pop de			; start counter 
b08a			 
b08a					; push limit counter 
b08a			 
b08a					if DEBUG_FORTH_WORDS 
b08a						DMARK "DO7" 
b08a f5				push af  
b08b 3a 9f b0			ld a, (.dmark)  
b08e 32 6b ee			ld (debug_mark),a  
b091 3a a0 b0			ld a, (.dmark+1)  
b094 32 6c ee			ld (debug_mark+1),a  
b097 3a a1 b0			ld a, (.dmark+2)  
b09a 32 6d ee			ld (debug_mark+2),a  
b09d 18 03			jr .pastdmark  
b09f ..			.dmark: db "DO7"  
b0a2 f1			.pastdmark: pop af  
b0a3			endm  
# End of macro DMARK
b0a3						CALLMONITOR 
b0a3 cd 6f ee			call debug_vector  
b0a6				endm  
# End of macro CALLMONITOR
b0a6					endif 
b0a6					FORTH_LOOP_NEXT 
b0a6 cd 6f 9d			call macro_forth_loop_next 
b0a9				endm 
# End of macro FORTH_LOOP_NEXT
b0a9			 
b0a9					; push start counter 
b0a9			 
b0a9 eb					ex de, hl 
b0aa					if DEBUG_FORTH_WORDS 
b0aa						DMARK "DO7" 
b0aa f5				push af  
b0ab 3a bf b0			ld a, (.dmark)  
b0ae 32 6b ee			ld (debug_mark),a  
b0b1 3a c0 b0			ld a, (.dmark+1)  
b0b4 32 6c ee			ld (debug_mark+1),a  
b0b7 3a c1 b0			ld a, (.dmark+2)  
b0ba 32 6d ee			ld (debug_mark+2),a  
b0bd 18 03			jr .pastdmark  
b0bf ..			.dmark: db "DO7"  
b0c2 f1			.pastdmark: pop af  
b0c3			endm  
# End of macro DMARK
b0c3						CALLMONITOR 
b0c3 cd 6f ee			call debug_vector  
b0c6				endm  
# End of macro CALLMONITOR
b0c6					endif 
b0c6					FORTH_LOOP_NEXT 
b0c6 cd 6f 9d			call macro_forth_loop_next 
b0c9				endm 
# End of macro FORTH_LOOP_NEXT
b0c9			 
b0c9			 
b0c9					; init first round of I counter 
b0c9			 
b0c9 22 e6 e5				ld (os_current_i), hl 
b0cc			 
b0cc					if DEBUG_FORTH_WORDS 
b0cc						DMARK "DO8" 
b0cc f5				push af  
b0cd 3a e1 b0			ld a, (.dmark)  
b0d0 32 6b ee			ld (debug_mark),a  
b0d3 3a e2 b0			ld a, (.dmark+1)  
b0d6 32 6c ee			ld (debug_mark+1),a  
b0d9 3a e3 b0			ld a, (.dmark+2)  
b0dc 32 6d ee			ld (debug_mark+2),a  
b0df 18 03			jr .pastdmark  
b0e1 ..			.dmark: db "DO8"  
b0e4 f1			.pastdmark: pop af  
b0e5			endm  
# End of macro DMARK
b0e5						CALLMONITOR 
b0e5 cd 6f ee			call debug_vector  
b0e8				endm  
# End of macro CALLMONITOR
b0e8					endif 
b0e8			 
b0e8					NEXTW 
b0e8 c3 f4 9e			jp macro_next 
b0eb				endm 
# End of macro NEXTW
b0eb			.LOOP: 
b0eb				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b0eb 22				db WORD_SYS_CORE+14             
b0ec 03 b2			dw .I            
b0ee 05				db 4 + 1 
b0ef .. 00			db "LOOP",0              
b0f4				endm 
# End of macro CWHEAD
b0f4			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b0f4			 
b0f4				; pop tos as current loop count to hl 
b0f4			 
b0f4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0f4			 
b0f4				FORTH_LOOP_TOS 
b0f4 cd a2 9d			call macro_forth_loop_tos 
b0f7				endm 
# End of macro FORTH_LOOP_TOS
b0f7 e5				push hl 
b0f8			 
b0f8					if DEBUG_FORTH_WORDS_KEY 
b0f8						DMARK "LOP" 
b0f8 f5				push af  
b0f9 3a 0d b1			ld a, (.dmark)  
b0fc 32 6b ee			ld (debug_mark),a  
b0ff 3a 0e b1			ld a, (.dmark+1)  
b102 32 6c ee			ld (debug_mark+1),a  
b105 3a 0f b1			ld a, (.dmark+2)  
b108 32 6d ee			ld (debug_mark+2),a  
b10b 18 03			jr .pastdmark  
b10d ..			.dmark: db "LOP"  
b110 f1			.pastdmark: pop af  
b111			endm  
# End of macro DMARK
b111						CALLMONITOR 
b111 cd 6f ee			call debug_vector  
b114				endm  
# End of macro CALLMONITOR
b114					endif 
b114				; next item on the stack is the limit. get it 
b114			 
b114			 
b114				FORTH_LOOP_POP 
b114 cd ac 9d			call macro_forth_loop_pop 
b117				endm 
# End of macro FORTH_LOOP_POP
b117			 
b117				FORTH_LOOP_TOS 
b117 cd a2 9d			call macro_forth_loop_tos 
b11a				endm 
# End of macro FORTH_LOOP_TOS
b11a			 
b11a d1				pop de		 ; de = i, hl = limit 
b11b			 
b11b					if DEBUG_FORTH_WORDS 
b11b						DMARK "LP1" 
b11b f5				push af  
b11c 3a 30 b1			ld a, (.dmark)  
b11f 32 6b ee			ld (debug_mark),a  
b122 3a 31 b1			ld a, (.dmark+1)  
b125 32 6c ee			ld (debug_mark+1),a  
b128 3a 32 b1			ld a, (.dmark+2)  
b12b 32 6d ee			ld (debug_mark+2),a  
b12e 18 03			jr .pastdmark  
b130 ..			.dmark: db "LP1"  
b133 f1			.pastdmark: pop af  
b134			endm  
# End of macro DMARK
b134						CALLMONITOR 
b134 cd 6f ee			call debug_vector  
b137				endm  
# End of macro CALLMONITOR
b137					endif 
b137			 
b137				; go back to previous word 
b137			 
b137 d5				push de    ; save I for inc later 
b138			 
b138			 
b138				; get limit 
b138				;  is I at limit? 
b138			 
b138			 
b138					if DEBUG_FORTH_WORDS 
b138						DMARK "LP1" 
b138 f5				push af  
b139 3a 4d b1			ld a, (.dmark)  
b13c 32 6b ee			ld (debug_mark),a  
b13f 3a 4e b1			ld a, (.dmark+1)  
b142 32 6c ee			ld (debug_mark+1),a  
b145 3a 4f b1			ld a, (.dmark+2)  
b148 32 6d ee			ld (debug_mark+2),a  
b14b 18 03			jr .pastdmark  
b14d ..			.dmark: db "LP1"  
b150 f1			.pastdmark: pop af  
b151			endm  
# End of macro DMARK
b151						CALLMONITOR 
b151 cd 6f ee			call debug_vector  
b154				endm  
# End of macro CALLMONITOR
b154					endif 
b154			 
b154 ed 52			sbc hl, de 
b156			 
b156			 
b156				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b156			 
b156 20 26				jr nz, .loopnotdone 
b158			 
b158 e1				pop hl   ; get rid of saved I 
b159				FORTH_LOOP_POP     ; get rid of limit 
b159 cd ac 9d			call macro_forth_loop_pop 
b15c				endm 
# End of macro FORTH_LOOP_POP
b15c			 
b15c				FORTH_RSP_POP     ; get rid of DO ptr 
b15c cd 0f 9b			call macro_forth_rsp_pop 
b15f				endm 
# End of macro FORTH_RSP_POP
b15f			 
b15f			if DEBUG_FORTH_WORDS 
b15f						DMARK "LP>" 
b15f f5				push af  
b160 3a 74 b1			ld a, (.dmark)  
b163 32 6b ee			ld (debug_mark),a  
b166 3a 75 b1			ld a, (.dmark+1)  
b169 32 6c ee			ld (debug_mark+1),a  
b16c 3a 76 b1			ld a, (.dmark+2)  
b16f 32 6d ee			ld (debug_mark+2),a  
b172 18 03			jr .pastdmark  
b174 ..			.dmark: db "LP>"  
b177 f1			.pastdmark: pop af  
b178			endm  
# End of macro DMARK
b178				CALLMONITOR 
b178 cd 6f ee			call debug_vector  
b17b				endm  
# End of macro CALLMONITOR
b17b			endif 
b17b			 
b17b					NEXTW 
b17b c3 f4 9e			jp macro_next 
b17e				endm 
# End of macro NEXTW
b17e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b17e			 
b17e			.loopnotdone: 
b17e			 
b17e e1				pop hl    ; get I 
b17f 23				inc hl 
b180			 
b180			   	; save new I 
b180			 
b180			 
b180					; set I counter 
b180			 
b180 22 e6 e5				ld (os_current_i), hl 
b183			 
b183					if DEBUG_FORTH_WORDS 
b183						DMARK "LPN" 
b183 f5				push af  
b184 3a 98 b1			ld a, (.dmark)  
b187 32 6b ee			ld (debug_mark),a  
b18a 3a 99 b1			ld a, (.dmark+1)  
b18d 32 6c ee			ld (debug_mark+1),a  
b190 3a 9a b1			ld a, (.dmark+2)  
b193 32 6d ee			ld (debug_mark+2),a  
b196 18 03			jr .pastdmark  
b198 ..			.dmark: db "LPN"  
b19b f1			.pastdmark: pop af  
b19c			endm  
# End of macro DMARK
b19c					CALLMONITOR 
b19c cd 6f ee			call debug_vector  
b19f				endm  
# End of macro CALLMONITOR
b19f					endif 
b19f					 
b19f				FORTH_LOOP_NEXT 
b19f cd 6f 9d			call macro_forth_loop_next 
b1a2				endm 
# End of macro FORTH_LOOP_NEXT
b1a2			 
b1a2			 
b1a2					if DEBUG_FORTH_WORDS 
b1a2 eb						ex de,hl 
b1a3					endif 
b1a3			 
b1a3			;	; get DO ptr 
b1a3			; 
b1a3					if DEBUG_FORTH_WORDS 
b1a3						DMARK "LP7" 
b1a3 f5				push af  
b1a4 3a b8 b1			ld a, (.dmark)  
b1a7 32 6b ee			ld (debug_mark),a  
b1aa 3a b9 b1			ld a, (.dmark+1)  
b1ad 32 6c ee			ld (debug_mark+1),a  
b1b0 3a ba b1			ld a, (.dmark+2)  
b1b3 32 6d ee			ld (debug_mark+2),a  
b1b6 18 03			jr .pastdmark  
b1b8 ..			.dmark: db "LP7"  
b1bb f1			.pastdmark: pop af  
b1bc			endm  
# End of macro DMARK
b1bc					CALLMONITOR 
b1bc cd 6f ee			call debug_vector  
b1bf				endm  
# End of macro CALLMONITOR
b1bf					endif 
b1bf				FORTH_RSP_TOS 
b1bf cd 05 9b			call macro_forth_rsp_tos 
b1c2				endm 
# End of macro FORTH_RSP_TOS
b1c2			 
b1c2					if DEBUG_FORTH_WORDS 
b1c2						DMARK "LP8" 
b1c2 f5				push af  
b1c3 3a d7 b1			ld a, (.dmark)  
b1c6 32 6b ee			ld (debug_mark),a  
b1c9 3a d8 b1			ld a, (.dmark+1)  
b1cc 32 6c ee			ld (debug_mark+1),a  
b1cf 3a d9 b1			ld a, (.dmark+2)  
b1d2 32 6d ee			ld (debug_mark+2),a  
b1d5 18 03			jr .pastdmark  
b1d7 ..			.dmark: db "LP8"  
b1da f1			.pastdmark: pop af  
b1db			endm  
# End of macro DMARK
b1db					CALLMONITOR 
b1db cd 6f ee			call debug_vector  
b1de				endm  
# End of macro CALLMONITOR
b1de					endif 
b1de				;push hl 
b1de			 
b1de				; not going to DO any more 
b1de				; get rid of the RSP pointer as DO will add it back in 
b1de				;FORTH_RSP_POP 
b1de				;pop hl 
b1de			 
b1de				;ld hl,(cli_ret_sp) 
b1de				;ld e, (hl) 
b1de				;inc hl 
b1de				;ld d, (hl) 
b1de				;ex de,hl 
b1de 22 c2 e5			ld (os_tok_ptr), hl 
b1e1					if DEBUG_FORTH_WORDS 
b1e1						DMARK "LP<" 
b1e1 f5				push af  
b1e2 3a f6 b1			ld a, (.dmark)  
b1e5 32 6b ee			ld (debug_mark),a  
b1e8 3a f7 b1			ld a, (.dmark+1)  
b1eb 32 6c ee			ld (debug_mark+1),a  
b1ee 3a f8 b1			ld a, (.dmark+2)  
b1f1 32 6d ee			ld (debug_mark+2),a  
b1f4 18 03			jr .pastdmark  
b1f6 ..			.dmark: db "LP<"  
b1f9 f1			.pastdmark: pop af  
b1fa			endm  
# End of macro DMARK
b1fa					CALLMONITOR 
b1fa cd 6f ee			call debug_vector  
b1fd				endm  
# End of macro CALLMONITOR
b1fd				endif 
b1fd c3 85 9f			jp exec1 
b200			 
b200					 
b200			 
b200			 
b200					NEXTW 
b200 c3 f4 9e			jp macro_next 
b203				endm 
# End of macro NEXTW
b203			.I:  
b203			 
b203				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b203 5e				db WORD_SYS_CORE+74             
b204 2e b2			dw .DLOOP            
b206 02				db 1 + 1 
b207 .. 00			db "I",0              
b209				endm 
# End of macro CWHEAD
b209			; | I ( -- ) Current loop counter | DONE 
b209					if DEBUG_FORTH_WORDS_KEY 
b209						DMARK "I.." 
b209 f5				push af  
b20a 3a 1e b2			ld a, (.dmark)  
b20d 32 6b ee			ld (debug_mark),a  
b210 3a 1f b2			ld a, (.dmark+1)  
b213 32 6c ee			ld (debug_mark+1),a  
b216 3a 20 b2			ld a, (.dmark+2)  
b219 32 6d ee			ld (debug_mark+2),a  
b21c 18 03			jr .pastdmark  
b21e ..			.dmark: db "I.."  
b221 f1			.pastdmark: pop af  
b222			endm  
# End of macro DMARK
b222						CALLMONITOR 
b222 cd 6f ee			call debug_vector  
b225				endm  
# End of macro CALLMONITOR
b225					endif 
b225			 
b225 2a e6 e5				ld hl,(os_current_i) 
b228 cd 47 9b				call forth_push_numhl 
b22b			 
b22b					NEXTW 
b22b c3 f4 9e			jp macro_next 
b22e				endm 
# End of macro NEXTW
b22e			.DLOOP: 
b22e				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b22e 5f				db WORD_SYS_CORE+75             
b22f 0f b3			dw .REPEAT            
b231 06				db 5 + 1 
b232 .. 00			db "-LOOP",0              
b238				endm 
# End of macro CWHEAD
b238			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b238				; pop tos as current loop count to hl 
b238					if DEBUG_FORTH_WORDS_KEY 
b238						DMARK "-LP" 
b238 f5				push af  
b239 3a 4d b2			ld a, (.dmark)  
b23c 32 6b ee			ld (debug_mark),a  
b23f 3a 4e b2			ld a, (.dmark+1)  
b242 32 6c ee			ld (debug_mark+1),a  
b245 3a 4f b2			ld a, (.dmark+2)  
b248 32 6d ee			ld (debug_mark+2),a  
b24b 18 03			jr .pastdmark  
b24d ..			.dmark: db "-LP"  
b250 f1			.pastdmark: pop af  
b251			endm  
# End of macro DMARK
b251						CALLMONITOR 
b251 cd 6f ee			call debug_vector  
b254				endm  
# End of macro CALLMONITOR
b254					endif 
b254			 
b254				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b254			 
b254				FORTH_LOOP_TOS 
b254 cd a2 9d			call macro_forth_loop_tos 
b257				endm 
# End of macro FORTH_LOOP_TOS
b257 e5				push hl 
b258			 
b258					if DEBUG_FORTH_WORDS 
b258						DMARK "-LP" 
b258 f5				push af  
b259 3a 6d b2			ld a, (.dmark)  
b25c 32 6b ee			ld (debug_mark),a  
b25f 3a 6e b2			ld a, (.dmark+1)  
b262 32 6c ee			ld (debug_mark+1),a  
b265 3a 6f b2			ld a, (.dmark+2)  
b268 32 6d ee			ld (debug_mark+2),a  
b26b 18 03			jr .pastdmark  
b26d ..			.dmark: db "-LP"  
b270 f1			.pastdmark: pop af  
b271			endm  
# End of macro DMARK
b271						CALLMONITOR 
b271 cd 6f ee			call debug_vector  
b274				endm  
# End of macro CALLMONITOR
b274					endif 
b274				; next item on the stack is the limit. get it 
b274			 
b274			 
b274				FORTH_LOOP_POP 
b274 cd ac 9d			call macro_forth_loop_pop 
b277				endm 
# End of macro FORTH_LOOP_POP
b277			 
b277				FORTH_LOOP_TOS 
b277 cd a2 9d			call macro_forth_loop_tos 
b27a				endm 
# End of macro FORTH_LOOP_TOS
b27a			 
b27a d1				pop de		 ; de = i, hl = limit 
b27b			 
b27b					if DEBUG_FORTH_WORDS 
b27b						DMARK "-L1" 
b27b f5				push af  
b27c 3a 90 b2			ld a, (.dmark)  
b27f 32 6b ee			ld (debug_mark),a  
b282 3a 91 b2			ld a, (.dmark+1)  
b285 32 6c ee			ld (debug_mark+1),a  
b288 3a 92 b2			ld a, (.dmark+2)  
b28b 32 6d ee			ld (debug_mark+2),a  
b28e 18 03			jr .pastdmark  
b290 ..			.dmark: db "-L1"  
b293 f1			.pastdmark: pop af  
b294			endm  
# End of macro DMARK
b294						CALLMONITOR 
b294 cd 6f ee			call debug_vector  
b297				endm  
# End of macro CALLMONITOR
b297					endif 
b297			 
b297				; go back to previous word 
b297			 
b297 d5				push de    ; save I for inc later 
b298			 
b298			 
b298				; get limit 
b298				;  is I at limit? 
b298			 
b298			 
b298					if DEBUG_FORTH_WORDS 
b298						DMARK "-L1" 
b298 f5				push af  
b299 3a ad b2			ld a, (.dmark)  
b29c 32 6b ee			ld (debug_mark),a  
b29f 3a ae b2			ld a, (.dmark+1)  
b2a2 32 6c ee			ld (debug_mark+1),a  
b2a5 3a af b2			ld a, (.dmark+2)  
b2a8 32 6d ee			ld (debug_mark+2),a  
b2ab 18 03			jr .pastdmark  
b2ad ..			.dmark: db "-L1"  
b2b0 f1			.pastdmark: pop af  
b2b1			endm  
# End of macro DMARK
b2b1						CALLMONITOR 
b2b1 cd 6f ee			call debug_vector  
b2b4				endm  
# End of macro CALLMONITOR
b2b4					endif 
b2b4			 
b2b4 ed 52			sbc hl, de 
b2b6			 
b2b6			 
b2b6				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b2b6			 
b2b6 20 26				jr nz, .mloopnotdone 
b2b8			 
b2b8 e1				pop hl   ; get rid of saved I 
b2b9				FORTH_LOOP_POP     ; get rid of limit 
b2b9 cd ac 9d			call macro_forth_loop_pop 
b2bc				endm 
# End of macro FORTH_LOOP_POP
b2bc			 
b2bc				FORTH_RSP_POP     ; get rid of DO ptr 
b2bc cd 0f 9b			call macro_forth_rsp_pop 
b2bf				endm 
# End of macro FORTH_RSP_POP
b2bf			 
b2bf			if DEBUG_FORTH_WORDS 
b2bf						DMARK "-L>" 
b2bf f5				push af  
b2c0 3a d4 b2			ld a, (.dmark)  
b2c3 32 6b ee			ld (debug_mark),a  
b2c6 3a d5 b2			ld a, (.dmark+1)  
b2c9 32 6c ee			ld (debug_mark+1),a  
b2cc 3a d6 b2			ld a, (.dmark+2)  
b2cf 32 6d ee			ld (debug_mark+2),a  
b2d2 18 03			jr .pastdmark  
b2d4 ..			.dmark: db "-L>"  
b2d7 f1			.pastdmark: pop af  
b2d8			endm  
# End of macro DMARK
b2d8				CALLMONITOR 
b2d8 cd 6f ee			call debug_vector  
b2db				endm  
# End of macro CALLMONITOR
b2db			endif 
b2db			 
b2db					NEXTW 
b2db c3 f4 9e			jp macro_next 
b2de				endm 
# End of macro NEXTW
b2de				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2de			 
b2de			.mloopnotdone: 
b2de			 
b2de e1				pop hl    ; get I 
b2df 2b				dec hl 
b2e0			 
b2e0			   	; save new I 
b2e0			 
b2e0			 
b2e0					; set I counter 
b2e0			 
b2e0 22 e6 e5				ld (os_current_i), hl 
b2e3			 
b2e3					 
b2e3				FORTH_LOOP_NEXT 
b2e3 cd 6f 9d			call macro_forth_loop_next 
b2e6				endm 
# End of macro FORTH_LOOP_NEXT
b2e6			 
b2e6			 
b2e6					if DEBUG_FORTH_WORDS 
b2e6 eb						ex de,hl 
b2e7					endif 
b2e7			 
b2e7			;	; get DO ptr 
b2e7			; 
b2e7				FORTH_RSP_TOS 
b2e7 cd 05 9b			call macro_forth_rsp_tos 
b2ea				endm 
# End of macro FORTH_RSP_TOS
b2ea			 
b2ea				;push hl 
b2ea			 
b2ea				; not going to DO any more 
b2ea				; get rid of the RSP pointer as DO will add it back in 
b2ea				;FORTH_RSP_POP 
b2ea				;pop hl 
b2ea			 
b2ea			 
b2ea 22 c2 e5			ld (os_tok_ptr), hl 
b2ed					if DEBUG_FORTH_WORDS 
b2ed						DMARK "-L<" 
b2ed f5				push af  
b2ee 3a 02 b3			ld a, (.dmark)  
b2f1 32 6b ee			ld (debug_mark),a  
b2f4 3a 03 b3			ld a, (.dmark+1)  
b2f7 32 6c ee			ld (debug_mark+1),a  
b2fa 3a 04 b3			ld a, (.dmark+2)  
b2fd 32 6d ee			ld (debug_mark+2),a  
b300 18 03			jr .pastdmark  
b302 ..			.dmark: db "-L<"  
b305 f1			.pastdmark: pop af  
b306			endm  
# End of macro DMARK
b306					CALLMONITOR 
b306 cd 6f ee			call debug_vector  
b309				endm  
# End of macro CALLMONITOR
b309				endif 
b309 c3 85 9f			jp exec1 
b30c			 
b30c					 
b30c			 
b30c			 
b30c			 
b30c				NEXTW 
b30c c3 f4 9e			jp macro_next 
b30f				endm 
# End of macro NEXTW
b30f			 
b30f			 
b30f			 
b30f			 
b30f			.REPEAT: 
b30f				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b30f 71				db WORD_SYS_CORE+93             
b310 62 b3			dw .UNTIL            
b312 06				db 5 + 1 
b313 .. 00			db "REPEAT",0              
b31a				endm 
# End of macro CWHEAD
b31a			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b31a			;  push pc to rsp stack past the REPEAT 
b31a					if DEBUG_FORTH_WORDS_KEY 
b31a						DMARK "REP" 
b31a f5				push af  
b31b 3a 2f b3			ld a, (.dmark)  
b31e 32 6b ee			ld (debug_mark),a  
b321 3a 30 b3			ld a, (.dmark+1)  
b324 32 6c ee			ld (debug_mark+1),a  
b327 3a 31 b3			ld a, (.dmark+2)  
b32a 32 6d ee			ld (debug_mark+2),a  
b32d 18 03			jr .pastdmark  
b32f ..			.dmark: db "REP"  
b332 f1			.pastdmark: pop af  
b333			endm  
# End of macro DMARK
b333						CALLMONITOR 
b333 cd 6f ee			call debug_vector  
b336				endm  
# End of macro CALLMONITOR
b336					endif 
b336			 
b336 2a c2 e5				ld hl, (os_tok_ptr) 
b339 23					inc hl   ; R 
b33a 23					inc hl  ; E 
b33b 23					inc hl   ; P 
b33c 23					inc hl   ; E 
b33d 23					inc hl   ; A 
b33e 23					inc hl   ; T 
b33f 23					inc hl   ; zero 
b340					FORTH_RSP_NEXT 
b340 cd ee 9a			call macro_forth_rsp_next 
b343				endm 
# End of macro FORTH_RSP_NEXT
b343			 
b343			 
b343					if DEBUG_FORTH_WORDS 
b343						DMARK "REP" 
b343 f5				push af  
b344 3a 58 b3			ld a, (.dmark)  
b347 32 6b ee			ld (debug_mark),a  
b34a 3a 59 b3			ld a, (.dmark+1)  
b34d 32 6c ee			ld (debug_mark+1),a  
b350 3a 5a b3			ld a, (.dmark+2)  
b353 32 6d ee			ld (debug_mark+2),a  
b356 18 03			jr .pastdmark  
b358 ..			.dmark: db "REP"  
b35b f1			.pastdmark: pop af  
b35c			endm  
# End of macro DMARK
b35c						;pop bc    ; TODO BUG ?????? what is this for???? 
b35c						CALLMONITOR 
b35c cd 6f ee			call debug_vector  
b35f				endm  
# End of macro CALLMONITOR
b35f					endif 
b35f			 
b35f					NEXTW 
b35f c3 f4 9e			jp macro_next 
b362				endm 
# End of macro NEXTW
b362			;	       NEXTW 
b362			 
b362			.UNTIL: 
b362				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b362 72				db WORD_SYS_CORE+94             
b363 f9 b3			dw .ENDFLOW            
b365 06				db 5 + 1 
b366 .. 00			db "UNTIL",0              
b36c				endm 
# End of macro CWHEAD
b36c			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b36c			 
b36c				; pop tos as check 
b36c			 
b36c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b36c			 
b36c				FORTH_DSP_VALUEHL 
b36c cd 3e 9d			call macro_dsp_valuehl 
b36f				endm 
# End of macro FORTH_DSP_VALUEHL
b36f			 
b36f					if DEBUG_FORTH_WORDS_KEY 
b36f						DMARK "UNT" 
b36f f5				push af  
b370 3a 84 b3			ld a, (.dmark)  
b373 32 6b ee			ld (debug_mark),a  
b376 3a 85 b3			ld a, (.dmark+1)  
b379 32 6c ee			ld (debug_mark+1),a  
b37c 3a 86 b3			ld a, (.dmark+2)  
b37f 32 6d ee			ld (debug_mark+2),a  
b382 18 03			jr .pastdmark  
b384 ..			.dmark: db "UNT"  
b387 f1			.pastdmark: pop af  
b388			endm  
# End of macro DMARK
b388						CALLMONITOR 
b388 cd 6f ee			call debug_vector  
b38b				endm  
# End of macro CALLMONITOR
b38b					endif 
b38b			 
b38b			;	push hl 
b38b				FORTH_DSP_POP 
b38b cd f6 9d			call macro_forth_dsp_pop 
b38e				endm 
# End of macro FORTH_DSP_POP
b38e			 
b38e			;	pop hl 
b38e			 
b38e				; test if true 
b38e			 
b38e cd 04 8d			call ishlzero 
b391			;	ld a,l 
b391			;	add h 
b391			; 
b391			;	cp 0 
b391			 
b391 20 3e			jr nz, .untilnotdone 
b393			 
b393					if DEBUG_FORTH_WORDS 
b393						DMARK "UNf" 
b393 f5				push af  
b394 3a a8 b3			ld a, (.dmark)  
b397 32 6b ee			ld (debug_mark),a  
b39a 3a a9 b3			ld a, (.dmark+1)  
b39d 32 6c ee			ld (debug_mark+1),a  
b3a0 3a aa b3			ld a, (.dmark+2)  
b3a3 32 6d ee			ld (debug_mark+2),a  
b3a6 18 03			jr .pastdmark  
b3a8 ..			.dmark: db "UNf"  
b3ab f1			.pastdmark: pop af  
b3ac			endm  
# End of macro DMARK
b3ac						CALLMONITOR 
b3ac cd 6f ee			call debug_vector  
b3af				endm  
# End of macro CALLMONITOR
b3af					endif 
b3af			 
b3af			 
b3af			 
b3af				FORTH_RSP_POP     ; get rid of DO ptr 
b3af cd 0f 9b			call macro_forth_rsp_pop 
b3b2				endm 
# End of macro FORTH_RSP_POP
b3b2			 
b3b2			if DEBUG_FORTH_WORDS 
b3b2						DMARK "UN>" 
b3b2 f5				push af  
b3b3 3a c7 b3			ld a, (.dmark)  
b3b6 32 6b ee			ld (debug_mark),a  
b3b9 3a c8 b3			ld a, (.dmark+1)  
b3bc 32 6c ee			ld (debug_mark+1),a  
b3bf 3a c9 b3			ld a, (.dmark+2)  
b3c2 32 6d ee			ld (debug_mark+2),a  
b3c5 18 03			jr .pastdmark  
b3c7 ..			.dmark: db "UN>"  
b3ca f1			.pastdmark: pop af  
b3cb			endm  
# End of macro DMARK
b3cb				CALLMONITOR 
b3cb cd 6f ee			call debug_vector  
b3ce				endm  
# End of macro CALLMONITOR
b3ce			endif 
b3ce			 
b3ce					NEXTW 
b3ce c3 f4 9e			jp macro_next 
b3d1				endm 
# End of macro NEXTW
b3d1				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b3d1			 
b3d1			.untilnotdone: 
b3d1			 
b3d1			 
b3d1			;	; get DO ptr 
b3d1			; 
b3d1				FORTH_RSP_TOS 
b3d1 cd 05 9b			call macro_forth_rsp_tos 
b3d4				endm 
# End of macro FORTH_RSP_TOS
b3d4			 
b3d4				;push hl 
b3d4			 
b3d4				; not going to DO any more 
b3d4				; get rid of the RSP pointer as DO will add it back in 
b3d4				;FORTH_RSP_POP 
b3d4				;pop hl 
b3d4			 
b3d4			 
b3d4 22 c2 e5			ld (os_tok_ptr), hl 
b3d7					if DEBUG_FORTH_WORDS 
b3d7						DMARK "UN<" 
b3d7 f5				push af  
b3d8 3a ec b3			ld a, (.dmark)  
b3db 32 6b ee			ld (debug_mark),a  
b3de 3a ed b3			ld a, (.dmark+1)  
b3e1 32 6c ee			ld (debug_mark+1),a  
b3e4 3a ee b3			ld a, (.dmark+2)  
b3e7 32 6d ee			ld (debug_mark+2),a  
b3ea 18 03			jr .pastdmark  
b3ec ..			.dmark: db "UN<"  
b3ef f1			.pastdmark: pop af  
b3f0			endm  
# End of macro DMARK
b3f0					CALLMONITOR 
b3f0 cd 6f ee			call debug_vector  
b3f3				endm  
# End of macro CALLMONITOR
b3f3				endif 
b3f3 c3 85 9f			jp exec1 
b3f6			 
b3f6					 
b3f6			 
b3f6			 
b3f6					NEXTW 
b3f6 c3 f4 9e			jp macro_next 
b3f9				endm 
# End of macro NEXTW
b3f9			 
b3f9			 
b3f9			.ENDFLOW: 
b3f9			 
b3f9			; eof 
b3f9			 
# End of file forth_words_flow.asm
b3f9			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b3f9			include "forth_words_logic.asm" 
b3f9			 
b3f9			; | ## Logic Words 
b3f9			 
b3f9			.NOT: 
b3f9				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b3f9 2d				db WORD_SYS_CORE+25             
b3fa 41 b4			dw .IS            
b3fc 04				db 3 + 1 
b3fd .. 00			db "NOT",0              
b401				endm 
# End of macro CWHEAD
b401			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b401					if DEBUG_FORTH_WORDS_KEY 
b401						DMARK "NOT" 
b401 f5				push af  
b402 3a 16 b4			ld a, (.dmark)  
b405 32 6b ee			ld (debug_mark),a  
b408 3a 17 b4			ld a, (.dmark+1)  
b40b 32 6c ee			ld (debug_mark+1),a  
b40e 3a 18 b4			ld a, (.dmark+2)  
b411 32 6d ee			ld (debug_mark+2),a  
b414 18 03			jr .pastdmark  
b416 ..			.dmark: db "NOT"  
b419 f1			.pastdmark: pop af  
b41a			endm  
# End of macro DMARK
b41a						CALLMONITOR 
b41a cd 6f ee			call debug_vector  
b41d				endm  
# End of macro CALLMONITOR
b41d					endif 
b41d					FORTH_DSP 
b41d cd 04 9d			call macro_forth_dsp 
b420				endm 
# End of macro FORTH_DSP
b420 7e					ld a,(hl)	; get type of value on TOS 
b421 fe 02				cp DS_TYPE_INUM  
b423 28 03				jr z, .noti 
b425					NEXTW 
b425 c3 f4 9e			jp macro_next 
b428				endm 
# End of macro NEXTW
b428			.noti:          FORTH_DSP_VALUEHL 
b428 cd 3e 9d			call macro_dsp_valuehl 
b42b				endm 
# End of macro FORTH_DSP_VALUEHL
b42b			;		push hl 
b42b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b42b cd f6 9d			call macro_forth_dsp_pop 
b42e				endm 
# End of macro FORTH_DSP_POP
b42e			;		pop hl 
b42e 3e 00				ld a,0 
b430 bd					cp l 
b431 28 04				jr z, .not2t 
b433 2e 00				ld l, 0 
b435 18 02				jr .notip 
b437			 
b437 2e ff		.not2t:		ld l, 255 
b439			 
b439 26 00		.notip:		ld h, 0	 
b43b			 
b43b cd 47 9b				call forth_push_numhl 
b43e					NEXTW 
b43e c3 f4 9e			jp macro_next 
b441				endm 
# End of macro NEXTW
b441			 
b441			.IS: 
b441				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b441 2d				db WORD_SYS_CORE+25             
b442 67 b4			dw .LZERO            
b444 03				db 2 + 1 
b445 .. 00			db "IS",0              
b448				endm 
# End of macro CWHEAD
b448			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b448					if DEBUG_FORTH_WORDS_KEY 
b448						DMARK "IS." 
b448 f5				push af  
b449 3a 5d b4			ld a, (.dmark)  
b44c 32 6b ee			ld (debug_mark),a  
b44f 3a 5e b4			ld a, (.dmark+1)  
b452 32 6c ee			ld (debug_mark+1),a  
b455 3a 5f b4			ld a, (.dmark+2)  
b458 32 6d ee			ld (debug_mark+2),a  
b45b 18 03			jr .pastdmark  
b45d ..			.dmark: db "IS."  
b460 f1			.pastdmark: pop af  
b461			endm  
# End of macro DMARK
b461						CALLMONITOR 
b461 cd 6f ee			call debug_vector  
b464				endm  
# End of macro CALLMONITOR
b464					endif 
b464					NEXTW 
b464 c3 f4 9e			jp macro_next 
b467				endm 
# End of macro NEXTW
b467			.LZERO: 
b467				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b467 2d				db WORD_SYS_CORE+25             
b468 71 b4			dw .TZERO            
b46a 03				db 2 + 1 
b46b .. 00			db "0<",0              
b46e				endm 
# End of macro CWHEAD
b46e			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b46e					NEXTW 
b46e c3 f4 9e			jp macro_next 
b471				endm 
# End of macro NEXTW
b471			.TZERO: 
b471				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b471 2e				db WORD_SYS_CORE+26             
b472 b8 b4			dw .LESS            
b474 03				db 2 + 1 
b475 .. 00			db "0=",0              
b478				endm 
# End of macro CWHEAD
b478			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b478				; TODO add floating point number detection 
b478					;v5 FORTH_DSP_VALUE 
b478					if DEBUG_FORTH_WORDS_KEY 
b478						DMARK "0=." 
b478 f5				push af  
b479 3a 8d b4			ld a, (.dmark)  
b47c 32 6b ee			ld (debug_mark),a  
b47f 3a 8e b4			ld a, (.dmark+1)  
b482 32 6c ee			ld (debug_mark+1),a  
b485 3a 8f b4			ld a, (.dmark+2)  
b488 32 6d ee			ld (debug_mark+2),a  
b48b 18 03			jr .pastdmark  
b48d ..			.dmark: db "0=."  
b490 f1			.pastdmark: pop af  
b491			endm  
# End of macro DMARK
b491						CALLMONITOR 
b491 cd 6f ee			call debug_vector  
b494				endm  
# End of macro CALLMONITOR
b494					endif 
b494					FORTH_DSP 
b494 cd 04 9d			call macro_forth_dsp 
b497				endm 
# End of macro FORTH_DSP
b497 7e					ld a,(hl)	; get type of value on TOS 
b498 fe 02				cp DS_TYPE_INUM  
b49a 28 00				jr z, .tz_inum 
b49c			 
b49c				if FORTH_ENABLE_FLOATMATH 
b49c					jr .tz_done 
b49c			 
b49c				endif 
b49c					 
b49c			 
b49c			.tz_inum: 
b49c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b49c cd 3e 9d			call macro_dsp_valuehl 
b49f				endm 
# End of macro FORTH_DSP_VALUEHL
b49f			 
b49f			;		push hl 
b49f			 
b49f					; destroy value TOS 
b49f			 
b49f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b49f cd f6 9d			call macro_forth_dsp_pop 
b4a2				endm 
# End of macro FORTH_DSP_POP
b4a2			 
b4a2			;		pop hl 
b4a2			 
b4a2 3e 00				ld a,0 
b4a4			 
b4a4 bd					cp l 
b4a5 20 08				jr nz, .tz_notzero 
b4a7			 
b4a7 bc					cp h 
b4a8			 
b4a8 20 05				jr nz, .tz_notzero 
b4aa			 
b4aa			 
b4aa 21 01 00				ld hl, FORTH_TRUE 
b4ad 18 03				jr .tz_done 
b4af			 
b4af 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b4b2			 
b4b2					; push value back onto stack for another op etc 
b4b2			 
b4b2			.tz_done: 
b4b2 cd 47 9b				call forth_push_numhl 
b4b5			 
b4b5					NEXTW 
b4b5 c3 f4 9e			jp macro_next 
b4b8				endm 
# End of macro NEXTW
b4b8			.LESS: 
b4b8				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b4b8 2f				db WORD_SYS_CORE+27             
b4b9 21 b5			dw .GT            
b4bb 02				db 1 + 1 
b4bc .. 00			db "<",0              
b4be				endm 
# End of macro CWHEAD
b4be			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b4be				; TODO add floating point number detection 
b4be					if DEBUG_FORTH_WORDS_KEY 
b4be						DMARK "LES" 
b4be f5				push af  
b4bf 3a d3 b4			ld a, (.dmark)  
b4c2 32 6b ee			ld (debug_mark),a  
b4c5 3a d4 b4			ld a, (.dmark+1)  
b4c8 32 6c ee			ld (debug_mark+1),a  
b4cb 3a d5 b4			ld a, (.dmark+2)  
b4ce 32 6d ee			ld (debug_mark+2),a  
b4d1 18 03			jr .pastdmark  
b4d3 ..			.dmark: db "LES"  
b4d6 f1			.pastdmark: pop af  
b4d7			endm  
# End of macro DMARK
b4d7						CALLMONITOR 
b4d7 cd 6f ee			call debug_vector  
b4da				endm  
# End of macro CALLMONITOR
b4da					endif 
b4da					FORTH_DSP 
b4da cd 04 9d			call macro_forth_dsp 
b4dd				endm 
# End of macro FORTH_DSP
b4dd					;v5 FORTH_DSP_VALUE 
b4dd 7e					ld a,(hl)	; get type of value on TOS 
b4de fe 02				cp DS_TYPE_INUM  
b4e0 28 00				jr z, .less_inum 
b4e2			 
b4e2				if FORTH_ENABLE_FLOATMATH 
b4e2					jr .less_done 
b4e2			 
b4e2				endif 
b4e2					 
b4e2			 
b4e2			.less_inum: 
b4e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4e2 cd 3e 9d			call macro_dsp_valuehl 
b4e5				endm 
# End of macro FORTH_DSP_VALUEHL
b4e5			 
b4e5 e5					push hl  ; u2 
b4e6			 
b4e6					; destroy value TOS 
b4e6			 
b4e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4e6 cd f6 9d			call macro_forth_dsp_pop 
b4e9				endm 
# End of macro FORTH_DSP_POP
b4e9			 
b4e9			 
b4e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4e9 cd 3e 9d			call macro_dsp_valuehl 
b4ec				endm 
# End of macro FORTH_DSP_VALUEHL
b4ec			 
b4ec e5					push hl    ; u1 
b4ed			 
b4ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4ed cd f6 9d			call macro_forth_dsp_pop 
b4f0				endm 
# End of macro FORTH_DSP_POP
b4f0			 
b4f0			 
b4f0 b7			 or a      ;clear carry flag 
b4f1 01 00 00		 ld bc, FORTH_FALSE 
b4f4 e1			  pop hl    ; u1 
b4f5 d1			  pop de    ; u2 
b4f6 ed 52		  sbc hl,de 
b4f8 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b4fa			 
b4fa 01 01 00		 ld bc, FORTH_TRUE 
b4fd			.lscont:  
b4fd c5					push bc 
b4fe e1					pop hl 
b4ff			 
b4ff					if DEBUG_FORTH_WORDS 
b4ff						DMARK "LT1" 
b4ff f5				push af  
b500 3a 14 b5			ld a, (.dmark)  
b503 32 6b ee			ld (debug_mark),a  
b506 3a 15 b5			ld a, (.dmark+1)  
b509 32 6c ee			ld (debug_mark+1),a  
b50c 3a 16 b5			ld a, (.dmark+2)  
b50f 32 6d ee			ld (debug_mark+2),a  
b512 18 03			jr .pastdmark  
b514 ..			.dmark: db "LT1"  
b517 f1			.pastdmark: pop af  
b518			endm  
# End of macro DMARK
b518						CALLMONITOR 
b518 cd 6f ee			call debug_vector  
b51b				endm  
# End of macro CALLMONITOR
b51b					endif 
b51b cd 47 9b				call forth_push_numhl 
b51e			 
b51e					NEXTW 
b51e c3 f4 9e			jp macro_next 
b521				endm 
# End of macro NEXTW
b521			.GT: 
b521				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b521 30				db WORD_SYS_CORE+28             
b522 8a b5			dw .EQUAL            
b524 02				db 1 + 1 
b525 .. 00			db ">",0              
b527				endm 
# End of macro CWHEAD
b527			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b527				; TODO add floating point number detection 
b527					if DEBUG_FORTH_WORDS_KEY 
b527						DMARK "GRT" 
b527 f5				push af  
b528 3a 3c b5			ld a, (.dmark)  
b52b 32 6b ee			ld (debug_mark),a  
b52e 3a 3d b5			ld a, (.dmark+1)  
b531 32 6c ee			ld (debug_mark+1),a  
b534 3a 3e b5			ld a, (.dmark+2)  
b537 32 6d ee			ld (debug_mark+2),a  
b53a 18 03			jr .pastdmark  
b53c ..			.dmark: db "GRT"  
b53f f1			.pastdmark: pop af  
b540			endm  
# End of macro DMARK
b540						CALLMONITOR 
b540 cd 6f ee			call debug_vector  
b543				endm  
# End of macro CALLMONITOR
b543					endif 
b543					FORTH_DSP 
b543 cd 04 9d			call macro_forth_dsp 
b546				endm 
# End of macro FORTH_DSP
b546					;FORTH_DSP_VALUE 
b546 7e					ld a,(hl)	; get type of value on TOS 
b547 fe 02				cp DS_TYPE_INUM  
b549 28 00				jr z, .gt_inum 
b54b			 
b54b				if FORTH_ENABLE_FLOATMATH 
b54b					jr .gt_done 
b54b			 
b54b				endif 
b54b					 
b54b			 
b54b			.gt_inum: 
b54b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b54b cd 3e 9d			call macro_dsp_valuehl 
b54e				endm 
# End of macro FORTH_DSP_VALUEHL
b54e			 
b54e e5					push hl  ; u2 
b54f			 
b54f					; destroy value TOS 
b54f			 
b54f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b54f cd f6 9d			call macro_forth_dsp_pop 
b552				endm 
# End of macro FORTH_DSP_POP
b552			 
b552			 
b552					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b552 cd 3e 9d			call macro_dsp_valuehl 
b555				endm 
# End of macro FORTH_DSP_VALUEHL
b555			 
b555 e5					push hl    ; u1 
b556			 
b556					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b556 cd f6 9d			call macro_forth_dsp_pop 
b559				endm 
# End of macro FORTH_DSP_POP
b559			 
b559			 
b559 b7			 or a      ;clear carry flag 
b55a 01 00 00		 ld bc, FORTH_FALSE 
b55d e1			  pop hl    ; u1 
b55e d1			  pop de    ; u2 
b55f ed 52		  sbc hl,de 
b561 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b563			 
b563 01 01 00		 ld bc, FORTH_TRUE 
b566			.gtcont:  
b566 c5					push bc 
b567 e1					pop hl 
b568			 
b568					if DEBUG_FORTH_WORDS 
b568						DMARK "GT1" 
b568 f5				push af  
b569 3a 7d b5			ld a, (.dmark)  
b56c 32 6b ee			ld (debug_mark),a  
b56f 3a 7e b5			ld a, (.dmark+1)  
b572 32 6c ee			ld (debug_mark+1),a  
b575 3a 7f b5			ld a, (.dmark+2)  
b578 32 6d ee			ld (debug_mark+2),a  
b57b 18 03			jr .pastdmark  
b57d ..			.dmark: db "GT1"  
b580 f1			.pastdmark: pop af  
b581			endm  
# End of macro DMARK
b581						CALLMONITOR 
b581 cd 6f ee			call debug_vector  
b584				endm  
# End of macro CALLMONITOR
b584					endif 
b584 cd 47 9b				call forth_push_numhl 
b587			 
b587					NEXTW 
b587 c3 f4 9e			jp macro_next 
b58a				endm 
# End of macro NEXTW
b58a			.EQUAL: 
b58a				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b58a 31				db WORD_SYS_CORE+29             
b58b f5 b5			dw .ENDLOGIC            
b58d 02				db 1 + 1 
b58e .. 00			db "=",0              
b590				endm 
# End of macro CWHEAD
b590			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b590				; TODO add floating point number detection 
b590					if DEBUG_FORTH_WORDS_KEY 
b590						DMARK "EQ." 
b590 f5				push af  
b591 3a a5 b5			ld a, (.dmark)  
b594 32 6b ee			ld (debug_mark),a  
b597 3a a6 b5			ld a, (.dmark+1)  
b59a 32 6c ee			ld (debug_mark+1),a  
b59d 3a a7 b5			ld a, (.dmark+2)  
b5a0 32 6d ee			ld (debug_mark+2),a  
b5a3 18 03			jr .pastdmark  
b5a5 ..			.dmark: db "EQ."  
b5a8 f1			.pastdmark: pop af  
b5a9			endm  
# End of macro DMARK
b5a9						CALLMONITOR 
b5a9 cd 6f ee			call debug_vector  
b5ac				endm  
# End of macro CALLMONITOR
b5ac					endif 
b5ac					FORTH_DSP 
b5ac cd 04 9d			call macro_forth_dsp 
b5af				endm 
# End of macro FORTH_DSP
b5af					;v5 FORTH_DSP_VALUE 
b5af 7e					ld a,(hl)	; get type of value on TOS 
b5b0 fe 02				cp DS_TYPE_INUM  
b5b2 28 00				jr z, .eq_inum 
b5b4			 
b5b4				if FORTH_ENABLE_FLOATMATH 
b5b4					jr .eq_done 
b5b4			 
b5b4				endif 
b5b4					 
b5b4			 
b5b4			.eq_inum: 
b5b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5b4 cd 3e 9d			call macro_dsp_valuehl 
b5b7				endm 
# End of macro FORTH_DSP_VALUEHL
b5b7			 
b5b7 e5					push hl 
b5b8			 
b5b8					; destroy value TOS 
b5b8			 
b5b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5b8 cd f6 9d			call macro_forth_dsp_pop 
b5bb				endm 
# End of macro FORTH_DSP_POP
b5bb			 
b5bb			 
b5bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5bb cd 3e 9d			call macro_dsp_valuehl 
b5be				endm 
# End of macro FORTH_DSP_VALUEHL
b5be			 
b5be					; one value on hl get other one back 
b5be			 
b5be e5					push hl 
b5bf			 
b5bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5bf cd f6 9d			call macro_forth_dsp_pop 
b5c2				endm 
# End of macro FORTH_DSP_POP
b5c2			 
b5c2 0e 00				ld c, FORTH_FALSE 
b5c4			 
b5c4 e1					pop hl 
b5c5 d1					pop de 
b5c6			 
b5c6 7b					ld a, e 
b5c7 bd					cp l 
b5c8			 
b5c8 20 06				jr nz, .eq_done 
b5ca			 
b5ca 7a					ld a, d 
b5cb bc					cp h 
b5cc			 
b5cc 20 02				jr nz, .eq_done 
b5ce			 
b5ce 0e 01				ld c, FORTH_TRUE 
b5d0					 
b5d0			 
b5d0			 
b5d0			.eq_done: 
b5d0			 
b5d0					; TODO push value back onto stack for another op etc 
b5d0			 
b5d0 26 00				ld h, 0 
b5d2 69					ld l, c 
b5d3					if DEBUG_FORTH_WORDS 
b5d3						DMARK "EQ1" 
b5d3 f5				push af  
b5d4 3a e8 b5			ld a, (.dmark)  
b5d7 32 6b ee			ld (debug_mark),a  
b5da 3a e9 b5			ld a, (.dmark+1)  
b5dd 32 6c ee			ld (debug_mark+1),a  
b5e0 3a ea b5			ld a, (.dmark+2)  
b5e3 32 6d ee			ld (debug_mark+2),a  
b5e6 18 03			jr .pastdmark  
b5e8 ..			.dmark: db "EQ1"  
b5eb f1			.pastdmark: pop af  
b5ec			endm  
# End of macro DMARK
b5ec						CALLMONITOR 
b5ec cd 6f ee			call debug_vector  
b5ef				endm  
# End of macro CALLMONITOR
b5ef					endif 
b5ef cd 47 9b				call forth_push_numhl 
b5f2			 
b5f2					NEXTW 
b5f2 c3 f4 9e			jp macro_next 
b5f5				endm 
# End of macro NEXTW
b5f5			 
b5f5			 
b5f5			.ENDLOGIC: 
b5f5			; eof 
b5f5			 
b5f5			 
# End of file forth_words_logic.asm
b5f5			include "forth_words_maths.asm" 
b5f5			 
b5f5			; | ## Maths Words 
b5f5			 
b5f5			.PLUS:	 
b5f5				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b5f5 15				db WORD_SYS_CORE+1             
b5f6 53 b6			dw .NEG            
b5f8 02				db 1 + 1 
b5f9 .. 00			db "+",0              
b5fb				endm 
# End of macro CWHEAD
b5fb			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b5fb					if DEBUG_FORTH_WORDS_KEY 
b5fb						DMARK "PLU" 
b5fb f5				push af  
b5fc 3a 10 b6			ld a, (.dmark)  
b5ff 32 6b ee			ld (debug_mark),a  
b602 3a 11 b6			ld a, (.dmark+1)  
b605 32 6c ee			ld (debug_mark+1),a  
b608 3a 12 b6			ld a, (.dmark+2)  
b60b 32 6d ee			ld (debug_mark+2),a  
b60e 18 03			jr .pastdmark  
b610 ..			.dmark: db "PLU"  
b613 f1			.pastdmark: pop af  
b614			endm  
# End of macro DMARK
b614						CALLMONITOR 
b614 cd 6f ee			call debug_vector  
b617				endm  
# End of macro CALLMONITOR
b617					endif 
b617					; add top two values and push back result 
b617			 
b617					;for v5 FORTH_DSP_VALUE 
b617					FORTH_DSP 
b617 cd 04 9d			call macro_forth_dsp 
b61a				endm 
# End of macro FORTH_DSP
b61a 7e					ld a,(hl)	; get type of value on TOS 
b61b fe 02				cp DS_TYPE_INUM  
b61d 28 03				jr z, .dot_inum 
b61f			 
b61f					NEXTW 
b61f c3 f4 9e			jp macro_next 
b622				endm 
# End of macro NEXTW
b622			 
b622			; float maths 
b622			 
b622				if FORTH_ENABLE_FLOATMATH 
b622						inc hl      ; now at start of numeric as string 
b622			 
b622					if DEBUG_FORTH_MATHS 
b622						DMARK "ADD" 
b622				CALLMONITOR 
b622					endif 
b622			 
b622					;ld ix, hl 
b622					call CON 
b622			 
b622			 
b622					push hl 
b622					 
b622					 
b622			 
b622						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b622			 
b622					; get next number 
b622			 
b622						FORTH_DSP_VALUE 
b622			 
b622						inc hl      ; now at start of numeric as string 
b622			 
b622					;ld ix, hl 
b622					call CON 
b622			 
b622					push hl 
b622			 
b622			 
b622						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b622			 
b622						; TODO do add 
b622			 
b622						call IADD 
b622			 
b622						; TODO get result back as ascii 
b622			 
b622						; TODO push result  
b622			 
b622			 
b622			 
b622						jr .dot_done 
b622				endif 
b622			 
b622			.dot_inum: 
b622			 
b622			 
b622					if DEBUG_FORTH_DOT 
b622						DMARK "+IT" 
b622 f5				push af  
b623 3a 37 b6			ld a, (.dmark)  
b626 32 6b ee			ld (debug_mark),a  
b629 3a 38 b6			ld a, (.dmark+1)  
b62c 32 6c ee			ld (debug_mark+1),a  
b62f 3a 39 b6			ld a, (.dmark+2)  
b632 32 6d ee			ld (debug_mark+2),a  
b635 18 03			jr .pastdmark  
b637 ..			.dmark: db "+IT"  
b63a f1			.pastdmark: pop af  
b63b			endm  
# End of macro DMARK
b63b				CALLMONITOR 
b63b cd 6f ee			call debug_vector  
b63e				endm  
# End of macro CALLMONITOR
b63e					endif 
b63e			 
b63e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b63e cd 3e 9d			call macro_dsp_valuehl 
b641				endm 
# End of macro FORTH_DSP_VALUEHL
b641			 
b641				; TODO add floating point number detection 
b641			 
b641 e5					push hl 
b642			 
b642					; destroy value TOS 
b642			 
b642					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b642 cd f6 9d			call macro_forth_dsp_pop 
b645				endm 
# End of macro FORTH_DSP_POP
b645			 
b645			 
b645					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b645 cd 3e 9d			call macro_dsp_valuehl 
b648				endm 
# End of macro FORTH_DSP_VALUEHL
b648			 
b648					; one value on hl get other one back 
b648			 
b648 d1					pop de 
b649			 
b649					; do the add 
b649			 
b649 19					add hl,de 
b64a			 
b64a					; save it 
b64a			 
b64a			;		push hl	 
b64a			 
b64a					; 
b64a			 
b64a					; destroy value TOS 
b64a			 
b64a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b64a cd f6 9d			call macro_forth_dsp_pop 
b64d				endm 
# End of macro FORTH_DSP_POP
b64d			 
b64d					; TODO push value back onto stack for another op etc 
b64d			 
b64d			;		pop hl 
b64d			 
b64d			.dot_done: 
b64d cd 47 9b				call forth_push_numhl 
b650			 
b650					NEXTW 
b650 c3 f4 9e			jp macro_next 
b653				endm 
# End of macro NEXTW
b653			.NEG: 
b653			 
b653				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b653 17				db WORD_SYS_CORE+3             
b654 96 b6			dw .DIV            
b656 02				db 1 + 1 
b657 .. 00			db "-",0              
b659				endm 
# End of macro CWHEAD
b659			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b659					if DEBUG_FORTH_WORDS_KEY 
b659						DMARK "SUB" 
b659 f5				push af  
b65a 3a 6e b6			ld a, (.dmark)  
b65d 32 6b ee			ld (debug_mark),a  
b660 3a 6f b6			ld a, (.dmark+1)  
b663 32 6c ee			ld (debug_mark+1),a  
b666 3a 70 b6			ld a, (.dmark+2)  
b669 32 6d ee			ld (debug_mark+2),a  
b66c 18 03			jr .pastdmark  
b66e ..			.dmark: db "SUB"  
b671 f1			.pastdmark: pop af  
b672			endm  
# End of macro DMARK
b672						CALLMONITOR 
b672 cd 6f ee			call debug_vector  
b675				endm  
# End of macro CALLMONITOR
b675					endif 
b675			 
b675			 
b675				; TODO add floating point number detection 
b675					; v5 FORTH_DSP_VALUE 
b675					FORTH_DSP 
b675 cd 04 9d			call macro_forth_dsp 
b678				endm 
# End of macro FORTH_DSP
b678 7e					ld a,(hl)	; get type of value on TOS 
b679 fe 02				cp DS_TYPE_INUM  
b67b 28 03				jr z, .neg_inum 
b67d			 
b67d					NEXTW 
b67d c3 f4 9e			jp macro_next 
b680				endm 
# End of macro NEXTW
b680			 
b680			; float maths 
b680			 
b680				if FORTH_ENABLE_FLOATMATH 
b680					jr .neg_done 
b680			 
b680				endif 
b680					 
b680			 
b680			.neg_inum: 
b680					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b680 cd 3e 9d			call macro_dsp_valuehl 
b683				endm 
# End of macro FORTH_DSP_VALUEHL
b683			 
b683 e5					push hl 
b684			 
b684					; destroy value TOS 
b684			 
b684					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b684 cd f6 9d			call macro_forth_dsp_pop 
b687				endm 
# End of macro FORTH_DSP_POP
b687			 
b687			 
b687					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b687 cd 3e 9d			call macro_dsp_valuehl 
b68a				endm 
# End of macro FORTH_DSP_VALUEHL
b68a			 
b68a					; one value on hl get other one back 
b68a			 
b68a d1					pop de 
b68b			 
b68b					; do the sub 
b68b			;		ex de, hl 
b68b			 
b68b ed 52				sbc hl,de 
b68d			 
b68d					; save it 
b68d			 
b68d			;		push hl	 
b68d			 
b68d					; 
b68d			 
b68d					; destroy value TOS 
b68d			 
b68d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b68d cd f6 9d			call macro_forth_dsp_pop 
b690				endm 
# End of macro FORTH_DSP_POP
b690			 
b690					; TODO push value back onto stack for another op etc 
b690			 
b690			;		pop hl 
b690			 
b690 cd 47 9b				call forth_push_numhl 
b693			.neg_done: 
b693			 
b693					NEXTW 
b693 c3 f4 9e			jp macro_next 
b696				endm 
# End of macro NEXTW
b696			.DIV: 
b696				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b696 18				db WORD_SYS_CORE+4             
b697 e3 b6			dw .MUL            
b699 02				db 1 + 1 
b69a .. 00			db "/",0              
b69c				endm 
# End of macro CWHEAD
b69c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b69c					if DEBUG_FORTH_WORDS_KEY 
b69c						DMARK "DIV" 
b69c f5				push af  
b69d 3a b1 b6			ld a, (.dmark)  
b6a0 32 6b ee			ld (debug_mark),a  
b6a3 3a b2 b6			ld a, (.dmark+1)  
b6a6 32 6c ee			ld (debug_mark+1),a  
b6a9 3a b3 b6			ld a, (.dmark+2)  
b6ac 32 6d ee			ld (debug_mark+2),a  
b6af 18 03			jr .pastdmark  
b6b1 ..			.dmark: db "DIV"  
b6b4 f1			.pastdmark: pop af  
b6b5			endm  
# End of macro DMARK
b6b5						CALLMONITOR 
b6b5 cd 6f ee			call debug_vector  
b6b8				endm  
# End of macro CALLMONITOR
b6b8					endif 
b6b8				; TODO add floating point number detection 
b6b8					; v5 FORTH_DSP_VALUE 
b6b8					FORTH_DSP 
b6b8 cd 04 9d			call macro_forth_dsp 
b6bb				endm 
# End of macro FORTH_DSP
b6bb 7e					ld a,(hl)	; get type of value on TOS 
b6bc fe 02				cp DS_TYPE_INUM  
b6be 28 03				jr z, .div_inum 
b6c0			 
b6c0				if FORTH_ENABLE_FLOATMATH 
b6c0					jr .div_done 
b6c0			 
b6c0				endif 
b6c0					NEXTW 
b6c0 c3 f4 9e			jp macro_next 
b6c3				endm 
# End of macro NEXTW
b6c3			.div_inum: 
b6c3			 
b6c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6c3 cd 3e 9d			call macro_dsp_valuehl 
b6c6				endm 
# End of macro FORTH_DSP_VALUEHL
b6c6			 
b6c6 e5					push hl    ; to go to bc 
b6c7			 
b6c7					; destroy value TOS 
b6c7			 
b6c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6c7 cd f6 9d			call macro_forth_dsp_pop 
b6ca				endm 
# End of macro FORTH_DSP_POP
b6ca			 
b6ca			 
b6ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6ca cd 3e 9d			call macro_dsp_valuehl 
b6cd				endm 
# End of macro FORTH_DSP_VALUEHL
b6cd			 
b6cd					; hl to go to de 
b6cd			 
b6cd e5					push hl 
b6ce			 
b6ce c1					pop bc 
b6cf d1					pop de		 
b6d0			 
b6d0			 
b6d0					if DEBUG_FORTH_MATHS 
b6d0						DMARK "DIV" 
b6d0				CALLMONITOR 
b6d0					endif 
b6d0					; one value on hl but move to a get other one back 
b6d0			 
b6d0			        
b6d0 cd 38 8c			call Div16 
b6d3			 
b6d3			;	push af	 
b6d3 e5				push hl 
b6d4 c5				push bc 
b6d5			 
b6d5					if DEBUG_FORTH_MATHS 
b6d5						DMARK "DI1" 
b6d5				CALLMONITOR 
b6d5					endif 
b6d5			 
b6d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6d5 cd f6 9d			call macro_forth_dsp_pop 
b6d8				endm 
# End of macro FORTH_DSP_POP
b6d8			 
b6d8			 
b6d8			 
b6d8 e1					pop hl    ; result 
b6d9			 
b6d9 cd 47 9b				call forth_push_numhl 
b6dc			 
b6dc e1					pop hl    ; reminder 
b6dd			;		ld h,0 
b6dd			;		ld l,d 
b6dd			 
b6dd cd 47 9b				call forth_push_numhl 
b6e0			.div_done: 
b6e0					NEXTW 
b6e0 c3 f4 9e			jp macro_next 
b6e3				endm 
# End of macro NEXTW
b6e3			.MUL: 
b6e3				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b6e3 19				db WORD_SYS_CORE+5             
b6e4 28 b7			dw .MIN            
b6e6 02				db 1 + 1 
b6e7 .. 00			db "*",0              
b6e9				endm 
# End of macro CWHEAD
b6e9			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b6e9				; TODO add floating point number detection 
b6e9					if DEBUG_FORTH_WORDS_KEY 
b6e9						DMARK "MUL" 
b6e9 f5				push af  
b6ea 3a fe b6			ld a, (.dmark)  
b6ed 32 6b ee			ld (debug_mark),a  
b6f0 3a ff b6			ld a, (.dmark+1)  
b6f3 32 6c ee			ld (debug_mark+1),a  
b6f6 3a 00 b7			ld a, (.dmark+2)  
b6f9 32 6d ee			ld (debug_mark+2),a  
b6fc 18 03			jr .pastdmark  
b6fe ..			.dmark: db "MUL"  
b701 f1			.pastdmark: pop af  
b702			endm  
# End of macro DMARK
b702						CALLMONITOR 
b702 cd 6f ee			call debug_vector  
b705				endm  
# End of macro CALLMONITOR
b705					endif 
b705					FORTH_DSP 
b705 cd 04 9d			call macro_forth_dsp 
b708				endm 
# End of macro FORTH_DSP
b708					; v5 FORTH_DSP_VALUE 
b708 7e					ld a,(hl)	; get type of value on TOS 
b709 fe 02				cp DS_TYPE_INUM  
b70b 28 03				jr z, .mul_inum 
b70d			 
b70d				if FORTH_ENABLE_FLOATMATH 
b70d					jr .mul_done 
b70d			 
b70d				endif 
b70d			 
b70d					NEXTW 
b70d c3 f4 9e			jp macro_next 
b710				endm 
# End of macro NEXTW
b710			.mul_inum:	 
b710			 
b710					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b710 cd 3e 9d			call macro_dsp_valuehl 
b713				endm 
# End of macro FORTH_DSP_VALUEHL
b713			 
b713 e5					push hl 
b714			 
b714					; destroy value TOS 
b714			 
b714					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b714 cd f6 9d			call macro_forth_dsp_pop 
b717				endm 
# End of macro FORTH_DSP_POP
b717			 
b717			 
b717					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b717 cd 3e 9d			call macro_dsp_valuehl 
b71a				endm 
# End of macro FORTH_DSP_VALUEHL
b71a			 
b71a					; one value on hl but move to a get other one back 
b71a			 
b71a 7d					ld a, l 
b71b			 
b71b d1					pop de 
b71c			 
b71c					; do the mull 
b71c			;		ex de, hl 
b71c			 
b71c cd 5e 8c				call Mult16 
b71f					; save it 
b71f			 
b71f			;		push hl	 
b71f			 
b71f					; 
b71f			 
b71f					; destroy value TOS 
b71f			 
b71f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b71f cd f6 9d			call macro_forth_dsp_pop 
b722				endm 
# End of macro FORTH_DSP_POP
b722			 
b722					; TODO push value back onto stack for another op etc 
b722			 
b722			;		pop hl 
b722			 
b722 cd 47 9b				call forth_push_numhl 
b725			 
b725			.mul_done: 
b725					NEXTW 
b725 c3 f4 9e			jp macro_next 
b728				endm 
# End of macro NEXTW
b728			 
b728			 
b728			 
b728			 
b728			.MIN: 
b728				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b728 49				db WORD_SYS_CORE+53             
b729 a9 b7			dw .MAX            
b72b 04				db 3 + 1 
b72c .. 00			db "MIN",0              
b730				endm 
# End of macro CWHEAD
b730			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b730					if DEBUG_FORTH_WORDS_KEY 
b730						DMARK "MIN" 
b730 f5				push af  
b731 3a 45 b7			ld a, (.dmark)  
b734 32 6b ee			ld (debug_mark),a  
b737 3a 46 b7			ld a, (.dmark+1)  
b73a 32 6c ee			ld (debug_mark+1),a  
b73d 3a 47 b7			ld a, (.dmark+2)  
b740 32 6d ee			ld (debug_mark+2),a  
b743 18 03			jr .pastdmark  
b745 ..			.dmark: db "MIN"  
b748 f1			.pastdmark: pop af  
b749			endm  
# End of macro DMARK
b749						CALLMONITOR 
b749 cd 6f ee			call debug_vector  
b74c				endm  
# End of macro CALLMONITOR
b74c					endif 
b74c					; get u2 
b74c			 
b74c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b74c cd 3e 9d			call macro_dsp_valuehl 
b74f				endm 
# End of macro FORTH_DSP_VALUEHL
b74f			 
b74f e5					push hl   ; u2 
b750			 
b750					; destroy value TOS 
b750			 
b750					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b750 cd f6 9d			call macro_forth_dsp_pop 
b753				endm 
# End of macro FORTH_DSP_POP
b753			 
b753					; get u1 
b753			 
b753					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b753 cd 3e 9d			call macro_dsp_valuehl 
b756				endm 
# End of macro FORTH_DSP_VALUEHL
b756			 
b756 e5					push hl  ; u1 
b757			 
b757					; destroy value TOS 
b757			 
b757					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b757 cd f6 9d			call macro_forth_dsp_pop 
b75a				endm 
# End of macro FORTH_DSP_POP
b75a			 
b75a b7			 or a      ;clear carry flag 
b75b e1			  pop hl    ; u1 
b75c d1			  pop de    ; u2 
b75d e5				push hl   ; saved in case hl is lowest 
b75e ed 52		  sbc hl,de 
b760 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b762			 
b762 e1				pop hl 
b763					if DEBUG_FORTH_WORDS 
b763						DMARK "MIN" 
b763 f5				push af  
b764 3a 78 b7			ld a, (.dmark)  
b767 32 6b ee			ld (debug_mark),a  
b76a 3a 79 b7			ld a, (.dmark+1)  
b76d 32 6c ee			ld (debug_mark+1),a  
b770 3a 7a b7			ld a, (.dmark+2)  
b773 32 6d ee			ld (debug_mark+2),a  
b776 18 03			jr .pastdmark  
b778 ..			.dmark: db "MIN"  
b77b f1			.pastdmark: pop af  
b77c			endm  
# End of macro DMARK
b77c						CALLMONITOR 
b77c cd 6f ee			call debug_vector  
b77f				endm  
# End of macro CALLMONITOR
b77f					endif 
b77f cd 47 9b				call forth_push_numhl 
b782			 
b782				       NEXTW 
b782 c3 f4 9e			jp macro_next 
b785				endm 
# End of macro NEXTW
b785			 
b785			.mincont:  
b785 c1				pop bc   ; tidy up 
b786 eb				ex de , hl  
b787					if DEBUG_FORTH_WORDS 
b787						DMARK "MI1" 
b787 f5				push af  
b788 3a 9c b7			ld a, (.dmark)  
b78b 32 6b ee			ld (debug_mark),a  
b78e 3a 9d b7			ld a, (.dmark+1)  
b791 32 6c ee			ld (debug_mark+1),a  
b794 3a 9e b7			ld a, (.dmark+2)  
b797 32 6d ee			ld (debug_mark+2),a  
b79a 18 03			jr .pastdmark  
b79c ..			.dmark: db "MI1"  
b79f f1			.pastdmark: pop af  
b7a0			endm  
# End of macro DMARK
b7a0						CALLMONITOR 
b7a0 cd 6f ee			call debug_vector  
b7a3				endm  
# End of macro CALLMONITOR
b7a3					endif 
b7a3 cd 47 9b				call forth_push_numhl 
b7a6			 
b7a6				       NEXTW 
b7a6 c3 f4 9e			jp macro_next 
b7a9				endm 
# End of macro NEXTW
b7a9			.MAX: 
b7a9				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b7a9 4a				db WORD_SYS_CORE+54             
b7aa 2a b8			dw .RND16            
b7ac 04				db 3 + 1 
b7ad .. 00			db "MAX",0              
b7b1				endm 
# End of macro CWHEAD
b7b1			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b7b1					if DEBUG_FORTH_WORDS_KEY 
b7b1						DMARK "MAX" 
b7b1 f5				push af  
b7b2 3a c6 b7			ld a, (.dmark)  
b7b5 32 6b ee			ld (debug_mark),a  
b7b8 3a c7 b7			ld a, (.dmark+1)  
b7bb 32 6c ee			ld (debug_mark+1),a  
b7be 3a c8 b7			ld a, (.dmark+2)  
b7c1 32 6d ee			ld (debug_mark+2),a  
b7c4 18 03			jr .pastdmark  
b7c6 ..			.dmark: db "MAX"  
b7c9 f1			.pastdmark: pop af  
b7ca			endm  
# End of macro DMARK
b7ca						CALLMONITOR 
b7ca cd 6f ee			call debug_vector  
b7cd				endm  
# End of macro CALLMONITOR
b7cd					endif 
b7cd					; get u2 
b7cd			 
b7cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7cd cd 3e 9d			call macro_dsp_valuehl 
b7d0				endm 
# End of macro FORTH_DSP_VALUEHL
b7d0			 
b7d0 e5					push hl   ; u2 
b7d1			 
b7d1					; destroy value TOS 
b7d1			 
b7d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7d1 cd f6 9d			call macro_forth_dsp_pop 
b7d4				endm 
# End of macro FORTH_DSP_POP
b7d4			 
b7d4					; get u1 
b7d4			 
b7d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7d4 cd 3e 9d			call macro_dsp_valuehl 
b7d7				endm 
# End of macro FORTH_DSP_VALUEHL
b7d7			 
b7d7 e5					push hl  ; u1 
b7d8			 
b7d8					; destroy value TOS 
b7d8			 
b7d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7d8 cd f6 9d			call macro_forth_dsp_pop 
b7db				endm 
# End of macro FORTH_DSP_POP
b7db			 
b7db b7			 or a      ;clear carry flag 
b7dc e1			  pop hl    ; u1 
b7dd d1			  pop de    ; u2 
b7de e5				push hl   ; saved in case hl is lowest 
b7df ed 52		  sbc hl,de 
b7e1 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b7e3			 
b7e3 e1				pop hl 
b7e4					if DEBUG_FORTH_WORDS 
b7e4						DMARK "MAX" 
b7e4 f5				push af  
b7e5 3a f9 b7			ld a, (.dmark)  
b7e8 32 6b ee			ld (debug_mark),a  
b7eb 3a fa b7			ld a, (.dmark+1)  
b7ee 32 6c ee			ld (debug_mark+1),a  
b7f1 3a fb b7			ld a, (.dmark+2)  
b7f4 32 6d ee			ld (debug_mark+2),a  
b7f7 18 03			jr .pastdmark  
b7f9 ..			.dmark: db "MAX"  
b7fc f1			.pastdmark: pop af  
b7fd			endm  
# End of macro DMARK
b7fd						CALLMONITOR 
b7fd cd 6f ee			call debug_vector  
b800				endm  
# End of macro CALLMONITOR
b800					endif 
b800 cd 47 9b				call forth_push_numhl 
b803			 
b803				       NEXTW 
b803 c3 f4 9e			jp macro_next 
b806				endm 
# End of macro NEXTW
b806			 
b806			.maxcont:  
b806 c1				pop bc   ; tidy up 
b807 eb				ex de , hl  
b808					if DEBUG_FORTH_WORDS 
b808						DMARK "MA1" 
b808 f5				push af  
b809 3a 1d b8			ld a, (.dmark)  
b80c 32 6b ee			ld (debug_mark),a  
b80f 3a 1e b8			ld a, (.dmark+1)  
b812 32 6c ee			ld (debug_mark+1),a  
b815 3a 1f b8			ld a, (.dmark+2)  
b818 32 6d ee			ld (debug_mark+2),a  
b81b 18 03			jr .pastdmark  
b81d ..			.dmark: db "MA1"  
b820 f1			.pastdmark: pop af  
b821			endm  
# End of macro DMARK
b821						CALLMONITOR 
b821 cd 6f ee			call debug_vector  
b824				endm  
# End of macro CALLMONITOR
b824					endif 
b824 cd 47 9b				call forth_push_numhl 
b827				       NEXTW 
b827 c3 f4 9e			jp macro_next 
b82a				endm 
# End of macro NEXTW
b82a			 
b82a			.RND16: 
b82a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b82a 4e				db WORD_SYS_CORE+58             
b82b 59 b8			dw .RND8            
b82d 06				db 5 + 1 
b82e .. 00			db "RND16",0              
b834				endm 
# End of macro CWHEAD
b834			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b834					if DEBUG_FORTH_WORDS_KEY 
b834						DMARK "R16" 
b834 f5				push af  
b835 3a 49 b8			ld a, (.dmark)  
b838 32 6b ee			ld (debug_mark),a  
b83b 3a 4a b8			ld a, (.dmark+1)  
b83e 32 6c ee			ld (debug_mark+1),a  
b841 3a 4b b8			ld a, (.dmark+2)  
b844 32 6d ee			ld (debug_mark+2),a  
b847 18 03			jr .pastdmark  
b849 ..			.dmark: db "R16"  
b84c f1			.pastdmark: pop af  
b84d			endm  
# End of macro DMARK
b84d						CALLMONITOR 
b84d cd 6f ee			call debug_vector  
b850				endm  
# End of macro CALLMONITOR
b850					endif 
b850 cd 02 8c				call prng16  
b853 cd 47 9b				call forth_push_numhl 
b856				       NEXTW 
b856 c3 f4 9e			jp macro_next 
b859				endm 
# End of macro NEXTW
b859			.RND8: 
b859				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b859 60				db WORD_SYS_CORE+76             
b85a 8e b8			dw .RND            
b85c 05				db 4 + 1 
b85d .. 00			db "RND8",0              
b862				endm 
# End of macro CWHEAD
b862			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b862					if DEBUG_FORTH_WORDS_KEY 
b862						DMARK "RN8" 
b862 f5				push af  
b863 3a 77 b8			ld a, (.dmark)  
b866 32 6b ee			ld (debug_mark),a  
b869 3a 78 b8			ld a, (.dmark+1)  
b86c 32 6c ee			ld (debug_mark+1),a  
b86f 3a 79 b8			ld a, (.dmark+2)  
b872 32 6d ee			ld (debug_mark+2),a  
b875 18 03			jr .pastdmark  
b877 ..			.dmark: db "RN8"  
b87a f1			.pastdmark: pop af  
b87b			endm  
# End of macro DMARK
b87b						CALLMONITOR 
b87b cd 6f ee			call debug_vector  
b87e				endm  
# End of macro CALLMONITOR
b87e					endif 
b87e 2a a9 eb				ld hl,(xrandc) 
b881 23					inc hl 
b882 cd 1c 8c				call xrnd 
b885 6f					ld l,a	 
b886 26 00				ld h,0 
b888 cd 47 9b				call forth_push_numhl 
b88b				       NEXTW 
b88b c3 f4 9e			jp macro_next 
b88e				endm 
# End of macro NEXTW
b88e			.RND: 
b88e				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b88e 60				db WORD_SYS_CORE+76             
b88f 94 b9			dw .ENDMATHS            
b891 04				db 3 + 1 
b892 .. 00			db "RND",0              
b896				endm 
# End of macro CWHEAD
b896			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b896			 
b896					if DEBUG_FORTH_WORDS_KEY 
b896						DMARK "RND" 
b896 f5				push af  
b897 3a ab b8			ld a, (.dmark)  
b89a 32 6b ee			ld (debug_mark),a  
b89d 3a ac b8			ld a, (.dmark+1)  
b8a0 32 6c ee			ld (debug_mark+1),a  
b8a3 3a ad b8			ld a, (.dmark+2)  
b8a6 32 6d ee			ld (debug_mark+2),a  
b8a9 18 03			jr .pastdmark  
b8ab ..			.dmark: db "RND"  
b8ae f1			.pastdmark: pop af  
b8af			endm  
# End of macro DMARK
b8af						CALLMONITOR 
b8af cd 6f ee			call debug_vector  
b8b2				endm  
# End of macro CALLMONITOR
b8b2					endif 
b8b2					 
b8b2					FORTH_DSP_VALUEHL    ; upper range 
b8b2 cd 3e 9d			call macro_dsp_valuehl 
b8b5				endm 
# End of macro FORTH_DSP_VALUEHL
b8b5			 
b8b5 22 ad eb				ld (LFSRSeed), hl	 
b8b8			 
b8b8					if DEBUG_FORTH_WORDS 
b8b8						DMARK "RN1" 
b8b8 f5				push af  
b8b9 3a cd b8			ld a, (.dmark)  
b8bc 32 6b ee			ld (debug_mark),a  
b8bf 3a ce b8			ld a, (.dmark+1)  
b8c2 32 6c ee			ld (debug_mark+1),a  
b8c5 3a cf b8			ld a, (.dmark+2)  
b8c8 32 6d ee			ld (debug_mark+2),a  
b8cb 18 03			jr .pastdmark  
b8cd ..			.dmark: db "RN1"  
b8d0 f1			.pastdmark: pop af  
b8d1			endm  
# End of macro DMARK
b8d1						CALLMONITOR 
b8d1 cd 6f ee			call debug_vector  
b8d4				endm  
# End of macro CALLMONITOR
b8d4					endif 
b8d4					FORTH_DSP_POP 
b8d4 cd f6 9d			call macro_forth_dsp_pop 
b8d7				endm 
# End of macro FORTH_DSP_POP
b8d7			 
b8d7					FORTH_DSP_VALUEHL    ; low range 
b8d7 cd 3e 9d			call macro_dsp_valuehl 
b8da				endm 
# End of macro FORTH_DSP_VALUEHL
b8da			 
b8da					if DEBUG_FORTH_WORDS 
b8da						DMARK "RN2" 
b8da f5				push af  
b8db 3a ef b8			ld a, (.dmark)  
b8de 32 6b ee			ld (debug_mark),a  
b8e1 3a f0 b8			ld a, (.dmark+1)  
b8e4 32 6c ee			ld (debug_mark+1),a  
b8e7 3a f1 b8			ld a, (.dmark+2)  
b8ea 32 6d ee			ld (debug_mark+2),a  
b8ed 18 03			jr .pastdmark  
b8ef ..			.dmark: db "RN2"  
b8f2 f1			.pastdmark: pop af  
b8f3			endm  
# End of macro DMARK
b8f3						CALLMONITOR 
b8f3 cd 6f ee			call debug_vector  
b8f6				endm  
# End of macro CALLMONITOR
b8f6					endif 
b8f6 22 af eb				ld (LFSRSeed+2), hl 
b8f9			 
b8f9					FORTH_DSP_POP 
b8f9 cd f6 9d			call macro_forth_dsp_pop 
b8fc				endm 
# End of macro FORTH_DSP_POP
b8fc			 
b8fc e5					push hl 
b8fd			 
b8fd e1			.inrange:	pop hl 
b8fe cd 02 8c				call prng16  
b901					if DEBUG_FORTH_WORDS 
b901						DMARK "RN3" 
b901 f5				push af  
b902 3a 16 b9			ld a, (.dmark)  
b905 32 6b ee			ld (debug_mark),a  
b908 3a 17 b9			ld a, (.dmark+1)  
b90b 32 6c ee			ld (debug_mark+1),a  
b90e 3a 18 b9			ld a, (.dmark+2)  
b911 32 6d ee			ld (debug_mark+2),a  
b914 18 03			jr .pastdmark  
b916 ..			.dmark: db "RN3"  
b919 f1			.pastdmark: pop af  
b91a			endm  
# End of macro DMARK
b91a						CALLMONITOR 
b91a cd 6f ee			call debug_vector  
b91d				endm  
# End of macro CALLMONITOR
b91d					endif 
b91d					 
b91d					; if the range is 8bit knock out the high byte 
b91d			 
b91d ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b921			 
b921 3e 00				ld a, 0 
b923 ba					cp d  
b924 20 1e				jr nz, .hirange 
b926 26 00				ld h, 0   ; knock it down to 8bit 
b928			 
b928					if DEBUG_FORTH_WORDS 
b928						DMARK "RNk" 
b928 f5				push af  
b929 3a 3d b9			ld a, (.dmark)  
b92c 32 6b ee			ld (debug_mark),a  
b92f 3a 3e b9			ld a, (.dmark+1)  
b932 32 6c ee			ld (debug_mark+1),a  
b935 3a 3f b9			ld a, (.dmark+2)  
b938 32 6d ee			ld (debug_mark+2),a  
b93b 18 03			jr .pastdmark  
b93d ..			.dmark: db "RNk"  
b940 f1			.pastdmark: pop af  
b941			endm  
# End of macro DMARK
b941						CALLMONITOR 
b941 cd 6f ee			call debug_vector  
b944				endm  
# End of macro CALLMONITOR
b944					endif 
b944			.hirange:   
b944 e5					push hl  
b945 b7					or a  
b946 ed 52		                sbc hl, de 
b948			 
b948					;call cmp16 
b948			 
b948 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b94a e1					pop hl 
b94b e5					push hl 
b94c			 
b94c					if DEBUG_FORTH_WORDS 
b94c						DMARK "RN4" 
b94c f5				push af  
b94d 3a 61 b9			ld a, (.dmark)  
b950 32 6b ee			ld (debug_mark),a  
b953 3a 62 b9			ld a, (.dmark+1)  
b956 32 6c ee			ld (debug_mark+1),a  
b959 3a 63 b9			ld a, (.dmark+2)  
b95c 32 6d ee			ld (debug_mark+2),a  
b95f 18 03			jr .pastdmark  
b961 ..			.dmark: db "RN4"  
b964 f1			.pastdmark: pop af  
b965			endm  
# End of macro DMARK
b965						CALLMONITOR 
b965 cd 6f ee			call debug_vector  
b968				endm  
# End of macro CALLMONITOR
b968					endif 
b968 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b96c					;call cmp16 
b96c				 
b96c b7					or a  
b96d ed 52		                sbc hl, de 
b96f 38 8c				jr c, .inrange 
b971			 
b971 e1					pop hl 
b972					 
b972					if DEBUG_FORTH_WORDS 
b972						DMARK "RNd" 
b972 f5				push af  
b973 3a 87 b9			ld a, (.dmark)  
b976 32 6b ee			ld (debug_mark),a  
b979 3a 88 b9			ld a, (.dmark+1)  
b97c 32 6c ee			ld (debug_mark+1),a  
b97f 3a 89 b9			ld a, (.dmark+2)  
b982 32 6d ee			ld (debug_mark+2),a  
b985 18 03			jr .pastdmark  
b987 ..			.dmark: db "RNd"  
b98a f1			.pastdmark: pop af  
b98b			endm  
# End of macro DMARK
b98b						CALLMONITOR 
b98b cd 6f ee			call debug_vector  
b98e				endm  
# End of macro CALLMONITOR
b98e					endif 
b98e			 
b98e			 
b98e cd 47 9b				call forth_push_numhl 
b991				       NEXTW 
b991 c3 f4 9e			jp macro_next 
b994				endm 
# End of macro NEXTW
b994			 
b994			.ENDMATHS: 
b994			 
b994			; eof 
b994			 
# End of file forth_words_maths.asm
b994			include "forth_words_display.asm" 
b994			 
b994			; | ## Display Words 
b994			 
b994			.ACT: 
b994			 
b994				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b994 62				db WORD_SYS_CORE+78             
b995 e0 b9			dw .INFO            
b997 07				db 6 + 1 
b998 .. 00			db "ACTIVE",0              
b99f				endm 
# End of macro CWHEAD
b99f			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b99f			;  
b99f			; | | To display a pulsing activity indicator in a processing loop do this... 
b99f			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
b99f			 
b99f					if DEBUG_FORTH_WORDS_KEY 
b99f						DMARK "ACT" 
b99f f5				push af  
b9a0 3a b4 b9			ld a, (.dmark)  
b9a3 32 6b ee			ld (debug_mark),a  
b9a6 3a b5 b9			ld a, (.dmark+1)  
b9a9 32 6c ee			ld (debug_mark+1),a  
b9ac 3a b6 b9			ld a, (.dmark+2)  
b9af 32 6d ee			ld (debug_mark+2),a  
b9b2 18 03			jr .pastdmark  
b9b4 ..			.dmark: db "ACT"  
b9b7 f1			.pastdmark: pop af  
b9b8			endm  
# End of macro DMARK
b9b8						CALLMONITOR 
b9b8 cd 6f ee			call debug_vector  
b9bb				endm  
# End of macro CALLMONITOR
b9bb					endif 
b9bb cd 05 8a				call active 
b9be					if DEBUG_FORTH_WORDS 
b9be						DMARK "ACp" 
b9be f5				push af  
b9bf 3a d3 b9			ld a, (.dmark)  
b9c2 32 6b ee			ld (debug_mark),a  
b9c5 3a d4 b9			ld a, (.dmark+1)  
b9c8 32 6c ee			ld (debug_mark+1),a  
b9cb 3a d5 b9			ld a, (.dmark+2)  
b9ce 32 6d ee			ld (debug_mark+2),a  
b9d1 18 03			jr .pastdmark  
b9d3 ..			.dmark: db "ACp"  
b9d6 f1			.pastdmark: pop af  
b9d7			endm  
# End of macro DMARK
b9d7						CALLMONITOR 
b9d7 cd 6f ee			call debug_vector  
b9da				endm  
# End of macro CALLMONITOR
b9da					endif 
b9da cd b5 9b				call forth_push_str 
b9dd			 
b9dd					NEXTW 
b9dd c3 f4 9e			jp macro_next 
b9e0				endm 
# End of macro NEXTW
b9e0			.INFO: 
b9e0			 
b9e0				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b9e0 62				db WORD_SYS_CORE+78             
b9e1 fd b9			dw .ATP            
b9e3 05				db 4 + 1 
b9e4 .. 00			db "INFO",0              
b9e9				endm 
# End of macro CWHEAD
b9e9			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b9e9					FORTH_DSP_VALUEHL 
b9e9 cd 3e 9d			call macro_dsp_valuehl 
b9ec				endm 
# End of macro FORTH_DSP_VALUEHL
b9ec			 
b9ec					FORTH_DSP_POP 
b9ec cd f6 9d			call macro_forth_dsp_pop 
b9ef				endm 
# End of macro FORTH_DSP_POP
b9ef			 
b9ef e5					push hl 
b9f0			 
b9f0					FORTH_DSP_VALUEHL 
b9f0 cd 3e 9d			call macro_dsp_valuehl 
b9f3				endm 
# End of macro FORTH_DSP_VALUEHL
b9f3			 
b9f3					FORTH_DSP_POP 
b9f3 cd f6 9d			call macro_forth_dsp_pop 
b9f6				endm 
# End of macro FORTH_DSP_POP
b9f6			 
b9f6 d1					pop de 
b9f7			 
b9f7 cd 3f 8a				call info_panel 
b9fa			 
b9fa			 
b9fa					NEXTW 
b9fa c3 f4 9e			jp macro_next 
b9fd				endm 
# End of macro NEXTW
b9fd			.ATP: 
b9fd				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b9fd 62				db WORD_SYS_CORE+78             
b9fe 74 ba			dw .FB            
ba00 04				db 3 + 1 
ba01 .. 00			db "AT?",0              
ba05				endm 
# End of macro CWHEAD
ba05			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
ba05					if DEBUG_FORTH_WORDS_KEY 
ba05						DMARK "AT?" 
ba05 f5				push af  
ba06 3a 1a ba			ld a, (.dmark)  
ba09 32 6b ee			ld (debug_mark),a  
ba0c 3a 1b ba			ld a, (.dmark+1)  
ba0f 32 6c ee			ld (debug_mark+1),a  
ba12 3a 1c ba			ld a, (.dmark+2)  
ba15 32 6d ee			ld (debug_mark+2),a  
ba18 18 03			jr .pastdmark  
ba1a ..			.dmark: db "AT?"  
ba1d f1			.pastdmark: pop af  
ba1e			endm  
# End of macro DMARK
ba1e						CALLMONITOR 
ba1e cd 6f ee			call debug_vector  
ba21				endm  
# End of macro CALLMONITOR
ba21					endif 
ba21 3a 5e ea				ld a, (f_cursor_ptr) 
ba24			 
ba24			if DEBUG_FORTH_WORDS 
ba24				DMARK "AT?" 
ba24 f5				push af  
ba25 3a 39 ba			ld a, (.dmark)  
ba28 32 6b ee			ld (debug_mark),a  
ba2b 3a 3a ba			ld a, (.dmark+1)  
ba2e 32 6c ee			ld (debug_mark+1),a  
ba31 3a 3b ba			ld a, (.dmark+2)  
ba34 32 6d ee			ld (debug_mark+2),a  
ba37 18 03			jr .pastdmark  
ba39 ..			.dmark: db "AT?"  
ba3c f1			.pastdmark: pop af  
ba3d			endm  
# End of macro DMARK
ba3d				CALLMONITOR 
ba3d cd 6f ee			call debug_vector  
ba40				endm  
# End of macro CALLMONITOR
ba40			endif	 
ba40					; count the number of rows 
ba40			 
ba40 06 00				ld b, 0 
ba42 4f			.atpr:		ld c, a    ; save in case we go below zero 
ba43 d6 28				sub display_cols 
ba45 f2 4b ba				jp p, .atprunder 
ba48 04					inc b 
ba49 18 f7				jr .atpr 
ba4b			.atprunder:	 
ba4b			if DEBUG_FORTH_WORDS 
ba4b				DMARK "A?2" 
ba4b f5				push af  
ba4c 3a 60 ba			ld a, (.dmark)  
ba4f 32 6b ee			ld (debug_mark),a  
ba52 3a 61 ba			ld a, (.dmark+1)  
ba55 32 6c ee			ld (debug_mark+1),a  
ba58 3a 62 ba			ld a, (.dmark+2)  
ba5b 32 6d ee			ld (debug_mark+2),a  
ba5e 18 03			jr .pastdmark  
ba60 ..			.dmark: db "A?2"  
ba63 f1			.pastdmark: pop af  
ba64			endm  
# End of macro DMARK
ba64				CALLMONITOR 
ba64 cd 6f ee			call debug_vector  
ba67				endm  
# End of macro CALLMONITOR
ba67			endif	 
ba67 26 00				ld h, 0 
ba69 69					ld l, c 
ba6a cd 47 9b				call forth_push_numhl 
ba6d 68					ld l, b  
ba6e cd 47 9b				call forth_push_numhl 
ba71			 
ba71			 
ba71				NEXTW 
ba71 c3 f4 9e			jp macro_next 
ba74				endm 
# End of macro NEXTW
ba74			 
ba74			.FB: 
ba74				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
ba74 1b				db WORD_SYS_CORE+7             
ba75 c2 ba			dw .EMIT            
ba77 03				db 2 + 1 
ba78 .. 00			db "FB",0              
ba7b				endm 
# End of macro CWHEAD
ba7b			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
ba7b			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
ba7b			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
ba7b			; | | If automatic display is off then updates will not be shown until DRAW is used. 
ba7b					if DEBUG_FORTH_WORDS_KEY 
ba7b						DMARK "FB." 
ba7b f5				push af  
ba7c 3a 90 ba			ld a, (.dmark)  
ba7f 32 6b ee			ld (debug_mark),a  
ba82 3a 91 ba			ld a, (.dmark+1)  
ba85 32 6c ee			ld (debug_mark+1),a  
ba88 3a 92 ba			ld a, (.dmark+2)  
ba8b 32 6d ee			ld (debug_mark+2),a  
ba8e 18 03			jr .pastdmark  
ba90 ..			.dmark: db "FB."  
ba93 f1			.pastdmark: pop af  
ba94			endm  
# End of macro DMARK
ba94						CALLMONITOR 
ba94 cd 6f ee			call debug_vector  
ba97				endm  
# End of macro CALLMONITOR
ba97					endif 
ba97			 
ba97					FORTH_DSP_VALUEHL 
ba97 cd 3e 9d			call macro_dsp_valuehl 
ba9a				endm 
# End of macro FORTH_DSP_VALUEHL
ba9a			 
ba9a 7d					ld a, l 
ba9b fe 01				cp 1 
ba9d 20 05				jr nz, .fbn1 
ba9f 21 10 ed				ld hl, display_fb1 
baa2 18 15				jr .fbset 
baa4 fe 02		.fbn1:		cp 2 
baa6 20 05				jr nz, .fbn2 
baa8 21 ce eb				ld hl, display_fb2 
baab 18 0c				jr .fbset 
baad fe 03		.fbn2:		cp 3 
baaf 20 05				jr nz, .fbn3 
bab1 21 6f ec				ld hl, display_fb3 
bab4 18 03				jr .fbset 
bab6			.fbn3:		 ; if invalid number select first 
bab6 21 10 ed				ld hl, display_fb1 
bab9 22 cc eb		.fbset:		ld (display_fb_active), hl 
babc			 
babc					FORTH_DSP_POP 
babc cd f6 9d			call macro_forth_dsp_pop 
babf				endm 
# End of macro FORTH_DSP_POP
babf			 
babf					NEXTW 
babf c3 f4 9e			jp macro_next 
bac2				endm 
# End of macro NEXTW
bac2			 
bac2			 
bac2			.EMIT: 
bac2				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bac2 1b				db WORD_SYS_CORE+7             
bac3 13 bb			dw .DOTH            
bac5 05				db 4 + 1 
bac6 .. 00			db "EMIT",0              
bacb				endm 
# End of macro CWHEAD
bacb			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bacb					; get value off TOS and display it 
bacb			 
bacb					if DEBUG_FORTH_WORDS_KEY 
bacb						DMARK "EMT" 
bacb f5				push af  
bacc 3a e0 ba			ld a, (.dmark)  
bacf 32 6b ee			ld (debug_mark),a  
bad2 3a e1 ba			ld a, (.dmark+1)  
bad5 32 6c ee			ld (debug_mark+1),a  
bad8 3a e2 ba			ld a, (.dmark+2)  
badb 32 6d ee			ld (debug_mark+2),a  
bade 18 03			jr .pastdmark  
bae0 ..			.dmark: db "EMT"  
bae3 f1			.pastdmark: pop af  
bae4			endm  
# End of macro DMARK
bae4						CALLMONITOR 
bae4 cd 6f ee			call debug_vector  
bae7				endm  
# End of macro CALLMONITOR
bae7					endif 
bae7			 
bae7					FORTH_DSP_VALUEHL 
bae7 cd 3e 9d			call macro_dsp_valuehl 
baea				endm 
# End of macro FORTH_DSP_VALUEHL
baea			 
baea 7d					ld a,l 
baeb			 
baeb					; TODO write to display 
baeb			 
baeb 32 bf e4				ld (os_input), a 
baee 3e 00				ld a, 0 
baf0 32 c0 e4				ld (os_input+1), a 
baf3					 
baf3 3a 5e ea				ld a, (f_cursor_ptr) 
baf6 11 bf e4				ld de, os_input 
baf9 cd c1 8a				call str_at_display 
bafc			 
bafc			 
bafc 3a 3c ea				ld a,(cli_autodisplay) 
baff fe 00				cp 0 
bb01 28 03				jr z, .enoupdate 
bb03 cd d1 8a						call update_display 
bb06					.enoupdate: 
bb06			 
bb06 3a 5e ea				ld a, (f_cursor_ptr) 
bb09 3c					inc a 
bb0a 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bb0d			 
bb0d			 
bb0d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb0d cd f6 9d			call macro_forth_dsp_pop 
bb10				endm 
# End of macro FORTH_DSP_POP
bb10			  
bb10			 
bb10					NEXTW 
bb10 c3 f4 9e			jp macro_next 
bb13				endm 
# End of macro NEXTW
bb13			.DOTH: 
bb13				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bb13 1c				db WORD_SYS_CORE+8             
bb14 43 bb			dw .DOTF            
bb16 03				db 2 + 1 
bb17 .. 00			db ".-",0              
bb1a				endm 
# End of macro CWHEAD
bb1a			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bb1a					; get value off TOS and display it 
bb1a					if DEBUG_FORTH_WORDS_KEY 
bb1a						DMARK "DTD" 
bb1a f5				push af  
bb1b 3a 2f bb			ld a, (.dmark)  
bb1e 32 6b ee			ld (debug_mark),a  
bb21 3a 30 bb			ld a, (.dmark+1)  
bb24 32 6c ee			ld (debug_mark+1),a  
bb27 3a 31 bb			ld a, (.dmark+2)  
bb2a 32 6d ee			ld (debug_mark+2),a  
bb2d 18 03			jr .pastdmark  
bb2f ..			.dmark: db "DTD"  
bb32 f1			.pastdmark: pop af  
bb33			endm  
# End of macro DMARK
bb33						CALLMONITOR 
bb33 cd 6f ee			call debug_vector  
bb36				endm  
# End of macro CALLMONITOR
bb36					endif 
bb36 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bb38 3e 00			ld a, 0 
bb3a 32 3d ea			ld (cli_mvdot), a 
bb3d c3 9a bb			jp .dotgo 
bb40				NEXTW 
bb40 c3 f4 9e			jp macro_next 
bb43				endm 
# End of macro NEXTW
bb43			.DOTF: 
bb43				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bb43 1c				db WORD_SYS_CORE+8             
bb44 71 bb			dw .DOT            
bb46 03				db 2 + 1 
bb47 .. 00			db ".>",0              
bb4a				endm 
# End of macro CWHEAD
bb4a			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bb4a					; get value off TOS and display it 
bb4a			        ; TODO BUG adds extra spaces 
bb4a			        ; TODO BUG handle numerics? 
bb4a					if DEBUG_FORTH_WORDS_KEY 
bb4a						DMARK "DTC" 
bb4a f5				push af  
bb4b 3a 5f bb			ld a, (.dmark)  
bb4e 32 6b ee			ld (debug_mark),a  
bb51 3a 60 bb			ld a, (.dmark+1)  
bb54 32 6c ee			ld (debug_mark+1),a  
bb57 3a 61 bb			ld a, (.dmark+2)  
bb5a 32 6d ee			ld (debug_mark+2),a  
bb5d 18 03			jr .pastdmark  
bb5f ..			.dmark: db "DTC"  
bb62 f1			.pastdmark: pop af  
bb63			endm  
# End of macro DMARK
bb63						CALLMONITOR 
bb63 cd 6f ee			call debug_vector  
bb66				endm  
# End of macro CALLMONITOR
bb66					endif 
bb66 3e 01			ld a, 1 
bb68 32 3d ea			ld (cli_mvdot), a 
bb6b c3 9a bb			jp .dotgo 
bb6e				NEXTW 
bb6e c3 f4 9e			jp macro_next 
bb71				endm 
# End of macro NEXTW
bb71			 
bb71			.DOT: 
bb71				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bb71 1c				db WORD_SYS_CORE+8             
bb72 4d bd			dw .CLS            
bb74 02				db 1 + 1 
bb75 .. 00			db ".",0              
bb77				endm 
# End of macro CWHEAD
bb77			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
bb77					; get value off TOS and display it 
bb77			 
bb77					if DEBUG_FORTH_WORDS_KEY 
bb77						DMARK "DOT" 
bb77 f5				push af  
bb78 3a 8c bb			ld a, (.dmark)  
bb7b 32 6b ee			ld (debug_mark),a  
bb7e 3a 8d bb			ld a, (.dmark+1)  
bb81 32 6c ee			ld (debug_mark+1),a  
bb84 3a 8e bb			ld a, (.dmark+2)  
bb87 32 6d ee			ld (debug_mark+2),a  
bb8a 18 03			jr .pastdmark  
bb8c ..			.dmark: db "DOT"  
bb8f f1			.pastdmark: pop af  
bb90			endm  
# End of macro DMARK
bb90						CALLMONITOR 
bb90 cd 6f ee			call debug_vector  
bb93				endm  
# End of macro CALLMONITOR
bb93					endif 
bb93 3e 00			ld a, 0 
bb95 32 3d ea			ld (cli_mvdot), a 
bb98 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bb9a				 
bb9a			 
bb9a			.dotgo: 
bb9a			 
bb9a			; move up type to on stack for parserv5 
bb9a					FORTH_DSP 
bb9a cd 04 9d			call macro_forth_dsp 
bb9d				endm 
# End of macro FORTH_DSP
bb9d				;FORTH_DSP_VALUE  
bb9d			 
bb9d			if DEBUG_FORTH_DOT 
bb9d				DMARK "DOT" 
bb9d f5				push af  
bb9e 3a b2 bb			ld a, (.dmark)  
bba1 32 6b ee			ld (debug_mark),a  
bba4 3a b3 bb			ld a, (.dmark+1)  
bba7 32 6c ee			ld (debug_mark+1),a  
bbaa 3a b4 bb			ld a, (.dmark+2)  
bbad 32 6d ee			ld (debug_mark+2),a  
bbb0 18 03			jr .pastdmark  
bbb2 ..			.dmark: db "DOT"  
bbb5 f1			.pastdmark: pop af  
bbb6			endm  
# End of macro DMARK
bbb6				CALLMONITOR 
bbb6 cd 6f ee			call debug_vector  
bbb9				endm  
# End of macro CALLMONITOR
bbb9			endif	 
bbb9			;		.print: 
bbb9			 
bbb9 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bbba 23				inc hl   ; position to the actual value 
bbbb fe 01			cp DS_TYPE_STR 
bbbd 20 06			jr nz, .dotnum1  
bbbf			 
bbbf			; display string 
bbbf				FORTH_DSP_VALUE  
bbbf cd 27 9d			call macro_forth_dsp_value 
bbc2				endm 
# End of macro FORTH_DSP_VALUE
bbc2 eb				ex de,hl 
bbc3 18 49			jr .dotwrite 
bbc5			 
bbc5			.dotnum1: 
bbc5 fe 02			cp DS_TYPE_INUM 
bbc7 20 44			jr nz, .dotflot 
bbc9			 
bbc9			 
bbc9			; display number 
bbc9			 
bbc9			;	push hl 
bbc9			;	call clear_display 
bbc9			;	pop hl 
bbc9			 
bbc9 5e				ld e, (hl) 
bbca 23				inc hl 
bbcb 56				ld d, (hl) 
bbcc 21 c1 e2			ld hl, scratch 
bbcf			if DEBUG_FORTH_DOT 
bbcf				DMARK "DT1" 
bbcf f5				push af  
bbd0 3a e4 bb			ld a, (.dmark)  
bbd3 32 6b ee			ld (debug_mark),a  
bbd6 3a e5 bb			ld a, (.dmark+1)  
bbd9 32 6c ee			ld (debug_mark+1),a  
bbdc 3a e6 bb			ld a, (.dmark+2)  
bbdf 32 6d ee			ld (debug_mark+2),a  
bbe2 18 03			jr .pastdmark  
bbe4 ..			.dmark: db "DT1"  
bbe7 f1			.pastdmark: pop af  
bbe8			endm  
# End of macro DMARK
bbe8				CALLMONITOR 
bbe8 cd 6f ee			call debug_vector  
bbeb				endm  
# End of macro CALLMONITOR
bbeb			endif	 
bbeb			 
bbeb cd e8 90			call uitoa_16 
bbee eb				ex de,hl 
bbef			 
bbef			if DEBUG_FORTH_DOT 
bbef				DMARK "DT2" 
bbef f5				push af  
bbf0 3a 04 bc			ld a, (.dmark)  
bbf3 32 6b ee			ld (debug_mark),a  
bbf6 3a 05 bc			ld a, (.dmark+1)  
bbf9 32 6c ee			ld (debug_mark+1),a  
bbfc 3a 06 bc			ld a, (.dmark+2)  
bbff 32 6d ee			ld (debug_mark+2),a  
bc02 18 03			jr .pastdmark  
bc04 ..			.dmark: db "DT2"  
bc07 f1			.pastdmark: pop af  
bc08			endm  
# End of macro DMARK
bc08				CALLMONITOR 
bc08 cd 6f ee			call debug_vector  
bc0b				endm  
# End of macro CALLMONITOR
bc0b			endif	 
bc0b			 
bc0b			;	ld de, os_word_scratch 
bc0b 18 01			jr .dotwrite 
bc0d			 
bc0d 00			.dotflot:   nop 
bc0e			; TODO print floating point number 
bc0e			 
bc0e			.dotwrite:		 
bc0e			 
bc0e					; if c is set then set all '-' to spaces 
bc0e					; need to also take into account .>  
bc0e			 
bc0e 3e 01				ld a, 1 
bc10 b9					cp c 
bc11 20 67				jr nz, .nodashswap 
bc13			 
bc13					; DE has the string to write, working with HL 
bc13			 
bc13 06 ff				ld b, 255 
bc15 d5					push de 
bc16 e1					pop hl 
bc17			 
bc17			if DEBUG_FORTH_DOT 
bc17				DMARK "DT-" 
bc17 f5				push af  
bc18 3a 2c bc			ld a, (.dmark)  
bc1b 32 6b ee			ld (debug_mark),a  
bc1e 3a 2d bc			ld a, (.dmark+1)  
bc21 32 6c ee			ld (debug_mark+1),a  
bc24 3a 2e bc			ld a, (.dmark+2)  
bc27 32 6d ee			ld (debug_mark+2),a  
bc2a 18 03			jr .pastdmark  
bc2c ..			.dmark: db "DT-"  
bc2f f1			.pastdmark: pop af  
bc30			endm  
# End of macro DMARK
bc30				CALLMONITOR 
bc30 cd 6f ee			call debug_vector  
bc33				endm  
# End of macro CALLMONITOR
bc33			endif	 
bc33 7e			.dashscan:	ld a, (hl) 
bc34 fe 00				cp 0 
bc36 28 42				jr z, .nodashswap 
bc38 fe 2d				cp '-' 
bc3a 20 03				jr nz, .dashskip 
bc3c 3e 20				ld a, ' ' 
bc3e 77					ld (hl), a 
bc3f 23			.dashskip:	inc hl 
bc40			if DEBUG_FORTH_DOT 
bc40				DMARK "D-2" 
bc40 f5				push af  
bc41 3a 55 bc			ld a, (.dmark)  
bc44 32 6b ee			ld (debug_mark),a  
bc47 3a 56 bc			ld a, (.dmark+1)  
bc4a 32 6c ee			ld (debug_mark+1),a  
bc4d 3a 57 bc			ld a, (.dmark+2)  
bc50 32 6d ee			ld (debug_mark+2),a  
bc53 18 03			jr .pastdmark  
bc55 ..			.dmark: db "D-2"  
bc58 f1			.pastdmark: pop af  
bc59			endm  
# End of macro DMARK
bc59				CALLMONITOR 
bc59 cd 6f ee			call debug_vector  
bc5c				endm  
# End of macro CALLMONITOR
bc5c			endif	 
bc5c 10 d5				djnz .dashscan 
bc5e			 
bc5e			if DEBUG_FORTH_DOT 
bc5e				DMARK "D-1" 
bc5e f5				push af  
bc5f 3a 73 bc			ld a, (.dmark)  
bc62 32 6b ee			ld (debug_mark),a  
bc65 3a 74 bc			ld a, (.dmark+1)  
bc68 32 6c ee			ld (debug_mark+1),a  
bc6b 3a 75 bc			ld a, (.dmark+2)  
bc6e 32 6d ee			ld (debug_mark+2),a  
bc71 18 03			jr .pastdmark  
bc73 ..			.dmark: db "D-1"  
bc76 f1			.pastdmark: pop af  
bc77			endm  
# End of macro DMARK
bc77				CALLMONITOR 
bc77 cd 6f ee			call debug_vector  
bc7a				endm  
# End of macro CALLMONITOR
bc7a			endif	 
bc7a			 
bc7a			.nodashswap: 
bc7a			 
bc7a			if DEBUG_FORTH_DOT 
bc7a				DMARK "D-o" 
bc7a f5				push af  
bc7b 3a 8f bc			ld a, (.dmark)  
bc7e 32 6b ee			ld (debug_mark),a  
bc81 3a 90 bc			ld a, (.dmark+1)  
bc84 32 6c ee			ld (debug_mark+1),a  
bc87 3a 91 bc			ld a, (.dmark+2)  
bc8a 32 6d ee			ld (debug_mark+2),a  
bc8d 18 03			jr .pastdmark  
bc8f ..			.dmark: db "D-o"  
bc92 f1			.pastdmark: pop af  
bc93			endm  
# End of macro DMARK
bc93				CALLMONITOR 
bc93 cd 6f ee			call debug_vector  
bc96				endm  
# End of macro CALLMONITOR
bc96			endif	 
bc96			 
bc96 d5					push de   ; save string start in case we need to advance print 
bc97			 
bc97 3a 5e ea				ld a, (f_cursor_ptr) 
bc9a cd c1 8a				call str_at_display 
bc9d 3a 3c ea				ld a,(cli_autodisplay) 
bca0 fe 00				cp 0 
bca2 28 03				jr z, .noupdate 
bca4 cd d1 8a						call update_display 
bca7					.noupdate: 
bca7			 
bca7			 
bca7					; see if we need to advance the print position 
bca7			 
bca7 e1					pop hl   ; get back string 
bca8			;		ex de,hl 
bca8			 
bca8 3a 3d ea				ld a, (cli_mvdot) 
bcab			if DEBUG_FORTH_DOT 
bcab			;		ld e,a 
bcab				DMARK "D>1" 
bcab f5				push af  
bcac 3a c0 bc			ld a, (.dmark)  
bcaf 32 6b ee			ld (debug_mark),a  
bcb2 3a c1 bc			ld a, (.dmark+1)  
bcb5 32 6c ee			ld (debug_mark+1),a  
bcb8 3a c2 bc			ld a, (.dmark+2)  
bcbb 32 6d ee			ld (debug_mark+2),a  
bcbe 18 03			jr .pastdmark  
bcc0 ..			.dmark: db "D>1"  
bcc3 f1			.pastdmark: pop af  
bcc4			endm  
# End of macro DMARK
bcc4				CALLMONITOR 
bcc4 cd 6f ee			call debug_vector  
bcc7				endm  
# End of macro CALLMONITOR
bcc7			endif	 
bcc7 fe 00				cp 0 
bcc9 28 44				jr z, .noadv 
bccb					; yes, lets advance the print position 
bccb 3e 00				ld a, 0 
bccd cd 44 91				call strlent 
bcd0			if DEBUG_FORTH_DOT 
bcd0				DMARK "D-?" 
bcd0 f5				push af  
bcd1 3a e5 bc			ld a, (.dmark)  
bcd4 32 6b ee			ld (debug_mark),a  
bcd7 3a e6 bc			ld a, (.dmark+1)  
bcda 32 6c ee			ld (debug_mark+1),a  
bcdd 3a e7 bc			ld a, (.dmark+2)  
bce0 32 6d ee			ld (debug_mark+2),a  
bce3 18 03			jr .pastdmark  
bce5 ..			.dmark: db "D-?"  
bce8 f1			.pastdmark: pop af  
bce9			endm  
# End of macro DMARK
bce9				CALLMONITOR 
bce9 cd 6f ee			call debug_vector  
bcec				endm  
# End of macro CALLMONITOR
bcec			endif	 
bcec 3a 5e ea				ld a, (f_cursor_ptr) 
bcef 85					add a,l 
bcf0					;call addatohl 
bcf0					;ld a, l 
bcf0 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bcf3			 
bcf3			if DEBUG_FORTH_DOT 
bcf3				DMARK "D->" 
bcf3 f5				push af  
bcf4 3a 08 bd			ld a, (.dmark)  
bcf7 32 6b ee			ld (debug_mark),a  
bcfa 3a 09 bd			ld a, (.dmark+1)  
bcfd 32 6c ee			ld (debug_mark+1),a  
bd00 3a 0a bd			ld a, (.dmark+2)  
bd03 32 6d ee			ld (debug_mark+2),a  
bd06 18 03			jr .pastdmark  
bd08 ..			.dmark: db "D->"  
bd0b f1			.pastdmark: pop af  
bd0c			endm  
# End of macro DMARK
bd0c				CALLMONITOR 
bd0c cd 6f ee			call debug_vector  
bd0f				endm  
# End of macro CALLMONITOR
bd0f			endif	 
bd0f			 
bd0f			.noadv:	 
bd0f			 
bd0f					if DEBUG_FORTH_DOT_WAIT 
bd0f							call next_page_prompt 
bd0f					endif	 
bd0f			; TODO this pop off the stack causes a crash. i dont know why 
bd0f			 
bd0f			 
bd0f			if DEBUG_FORTH_DOT 
bd0f				DMARK "DTh" 
bd0f f5				push af  
bd10 3a 24 bd			ld a, (.dmark)  
bd13 32 6b ee			ld (debug_mark),a  
bd16 3a 25 bd			ld a, (.dmark+1)  
bd19 32 6c ee			ld (debug_mark+1),a  
bd1c 3a 26 bd			ld a, (.dmark+2)  
bd1f 32 6d ee			ld (debug_mark+2),a  
bd22 18 03			jr .pastdmark  
bd24 ..			.dmark: db "DTh"  
bd27 f1			.pastdmark: pop af  
bd28			endm  
# End of macro DMARK
bd28				CALLMONITOR 
bd28 cd 6f ee			call debug_vector  
bd2b				endm  
# End of macro CALLMONITOR
bd2b			endif	 
bd2b			 
bd2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd2b cd f6 9d			call macro_forth_dsp_pop 
bd2e				endm 
# End of macro FORTH_DSP_POP
bd2e			 
bd2e			if DEBUG_FORTH_DOT 
bd2e				DMARK "DTi" 
bd2e f5				push af  
bd2f 3a 43 bd			ld a, (.dmark)  
bd32 32 6b ee			ld (debug_mark),a  
bd35 3a 44 bd			ld a, (.dmark+1)  
bd38 32 6c ee			ld (debug_mark+1),a  
bd3b 3a 45 bd			ld a, (.dmark+2)  
bd3e 32 6d ee			ld (debug_mark+2),a  
bd41 18 03			jr .pastdmark  
bd43 ..			.dmark: db "DTi"  
bd46 f1			.pastdmark: pop af  
bd47			endm  
# End of macro DMARK
bd47				CALLMONITOR 
bd47 cd 6f ee			call debug_vector  
bd4a				endm  
# End of macro CALLMONITOR
bd4a			endif	 
bd4a			 
bd4a			 
bd4a					NEXTW 
bd4a c3 f4 9e			jp macro_next 
bd4d				endm 
# End of macro NEXTW
bd4d			 
bd4d			.CLS: 
bd4d				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bd4d 35				db WORD_SYS_CORE+33             
bd4e 7a bd			dw .DRAW            
bd50 04				db 3 + 1 
bd51 .. 00			db "CLS",0              
bd55				endm 
# End of macro CWHEAD
bd55			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bd55					if DEBUG_FORTH_WORDS_KEY 
bd55						DMARK "CLS" 
bd55 f5				push af  
bd56 3a 6a bd			ld a, (.dmark)  
bd59 32 6b ee			ld (debug_mark),a  
bd5c 3a 6b bd			ld a, (.dmark+1)  
bd5f 32 6c ee			ld (debug_mark+1),a  
bd62 3a 6c bd			ld a, (.dmark+2)  
bd65 32 6d ee			ld (debug_mark+2),a  
bd68 18 03			jr .pastdmark  
bd6a ..			.dmark: db "CLS"  
bd6d f1			.pastdmark: pop af  
bd6e			endm  
# End of macro DMARK
bd6e						CALLMONITOR 
bd6e cd 6f ee			call debug_vector  
bd71				endm  
# End of macro CALLMONITOR
bd71					endif 
bd71 cd ae 8a				call clear_display 
bd74 c3 88 be				jp .home		; and home cursor 
bd77					NEXTW 
bd77 c3 f4 9e			jp macro_next 
bd7a				endm 
# End of macro NEXTW
bd7a			 
bd7a			.DRAW: 
bd7a				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bd7a 36				db WORD_SYS_CORE+34             
bd7b a5 bd			dw .DUMP            
bd7d 05				db 4 + 1 
bd7e .. 00			db "DRAW",0              
bd83				endm 
# End of macro CWHEAD
bd83			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bd83					if DEBUG_FORTH_WORDS_KEY 
bd83						DMARK "DRW" 
bd83 f5				push af  
bd84 3a 98 bd			ld a, (.dmark)  
bd87 32 6b ee			ld (debug_mark),a  
bd8a 3a 99 bd			ld a, (.dmark+1)  
bd8d 32 6c ee			ld (debug_mark+1),a  
bd90 3a 9a bd			ld a, (.dmark+2)  
bd93 32 6d ee			ld (debug_mark+2),a  
bd96 18 03			jr .pastdmark  
bd98 ..			.dmark: db "DRW"  
bd9b f1			.pastdmark: pop af  
bd9c			endm  
# End of macro DMARK
bd9c						CALLMONITOR 
bd9c cd 6f ee			call debug_vector  
bd9f				endm  
# End of macro CALLMONITOR
bd9f					endif 
bd9f cd d1 8a				call update_display 
bda2					NEXTW 
bda2 c3 f4 9e			jp macro_next 
bda5				endm 
# End of macro NEXTW
bda5			 
bda5			.DUMP: 
bda5				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bda5 37				db WORD_SYS_CORE+35             
bda6 dd bd			dw .CDUMP            
bda8 05				db 4 + 1 
bda9 .. 00			db "DUMP",0              
bdae				endm 
# End of macro CWHEAD
bdae			; | DUMP ( x -- ) With address x display dump   | DONE 
bdae			; TODO pop address to use off of the stack 
bdae					if DEBUG_FORTH_WORDS_KEY 
bdae						DMARK "DUM" 
bdae f5				push af  
bdaf 3a c3 bd			ld a, (.dmark)  
bdb2 32 6b ee			ld (debug_mark),a  
bdb5 3a c4 bd			ld a, (.dmark+1)  
bdb8 32 6c ee			ld (debug_mark+1),a  
bdbb 3a c5 bd			ld a, (.dmark+2)  
bdbe 32 6d ee			ld (debug_mark+2),a  
bdc1 18 03			jr .pastdmark  
bdc3 ..			.dmark: db "DUM"  
bdc6 f1			.pastdmark: pop af  
bdc7			endm  
# End of macro DMARK
bdc7						CALLMONITOR 
bdc7 cd 6f ee			call debug_vector  
bdca				endm  
# End of macro CALLMONITOR
bdca					endif 
bdca cd ae 8a				call clear_display 
bdcd			 
bdcd					; get address 
bdcd			 
bdcd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdcd cd 3e 9d			call macro_dsp_valuehl 
bdd0				endm 
# End of macro FORTH_DSP_VALUEHL
bdd0				 
bdd0					; save it for cdump 
bdd0			 
bdd0 22 e4 e5				ld (os_cur_ptr),hl 
bdd3			 
bdd3					; destroy value TOS 
bdd3			 
bdd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdd3 cd f6 9d			call macro_forth_dsp_pop 
bdd6				endm 
# End of macro FORTH_DSP_POP
bdd6			 
bdd6 cd c7 99				call dumpcont	; skip old style of param parsing	 
bdd9 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bdda					NEXTW 
bdda c3 f4 9e			jp macro_next 
bddd				endm 
# End of macro NEXTW
bddd			.CDUMP: 
bddd				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bddd 38				db WORD_SYS_CORE+36             
bdde 0d be			dw .DAT            
bde0 06				db 5 + 1 
bde1 .. 00			db "CDUMP",0              
bde7				endm 
# End of macro CWHEAD
bde7			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bde7					if DEBUG_FORTH_WORDS_KEY 
bde7						DMARK "CDP" 
bde7 f5				push af  
bde8 3a fc bd			ld a, (.dmark)  
bdeb 32 6b ee			ld (debug_mark),a  
bdee 3a fd bd			ld a, (.dmark+1)  
bdf1 32 6c ee			ld (debug_mark+1),a  
bdf4 3a fe bd			ld a, (.dmark+2)  
bdf7 32 6d ee			ld (debug_mark+2),a  
bdfa 18 03			jr .pastdmark  
bdfc ..			.dmark: db "CDP"  
bdff f1			.pastdmark: pop af  
be00			endm  
# End of macro DMARK
be00						CALLMONITOR 
be00 cd 6f ee			call debug_vector  
be03				endm  
# End of macro CALLMONITOR
be03					endif 
be03 cd ae 8a				call clear_display 
be06 cd c7 99				call dumpcont	 
be09 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
be0a					NEXTW 
be0a c3 f4 9e			jp macro_next 
be0d				endm 
# End of macro NEXTW
be0d			 
be0d			 
be0d			 
be0d			 
be0d			.DAT: 
be0d				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
be0d 3d				db WORD_SYS_CORE+41             
be0e 63 be			dw .HOME            
be10 03				db 2 + 1 
be11 .. 00			db "AT",0              
be14				endm 
# End of macro CWHEAD
be14			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
be14					if DEBUG_FORTH_WORDS_KEY 
be14						DMARK "AT." 
be14 f5				push af  
be15 3a 29 be			ld a, (.dmark)  
be18 32 6b ee			ld (debug_mark),a  
be1b 3a 2a be			ld a, (.dmark+1)  
be1e 32 6c ee			ld (debug_mark+1),a  
be21 3a 2b be			ld a, (.dmark+2)  
be24 32 6d ee			ld (debug_mark+2),a  
be27 18 03			jr .pastdmark  
be29 ..			.dmark: db "AT."  
be2c f1			.pastdmark: pop af  
be2d			endm  
# End of macro DMARK
be2d						CALLMONITOR 
be2d cd 6f ee			call debug_vector  
be30				endm  
# End of macro CALLMONITOR
be30					endif 
be30					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be30 cd 3e 9d			call macro_dsp_valuehl 
be33				endm 
# End of macro FORTH_DSP_VALUEHL
be33			 
be33			 
be33					; TODO save cursor row 
be33 7d					ld a,l 
be34 fe 02				cp 2 
be36 20 04				jr nz, .crow3 
be38 3e 28				ld a, display_row_2 
be3a 18 12				jr .ccol1 
be3c fe 03		.crow3:		cp 3 
be3e 20 04				jr nz, .crow4 
be40 3e 50				ld a, display_row_3 
be42 18 0a				jr .ccol1 
be44 fe 04		.crow4:		cp 4 
be46 20 04				jr nz, .crow1 
be48 3e 78				ld a, display_row_4 
be4a 18 02				jr .ccol1 
be4c 3e 00		.crow1:		ld a,display_row_1 
be4e f5			.ccol1:		push af			; got row offset 
be4f 6f					ld l,a 
be50 26 00				ld h,0 
be52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be52 cd f6 9d			call macro_forth_dsp_pop 
be55				endm 
# End of macro FORTH_DSP_POP
be55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be55 cd 3e 9d			call macro_dsp_valuehl 
be58				endm 
# End of macro FORTH_DSP_VALUEHL
be58					; TODO save cursor col 
be58 f1					pop af 
be59 85					add l		; add col offset 
be5a 32 5e ea				ld (f_cursor_ptr), a 
be5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be5d cd f6 9d			call macro_forth_dsp_pop 
be60				endm 
# End of macro FORTH_DSP_POP
be60			 
be60					; calculate  
be60			 
be60					NEXTW 
be60 c3 f4 9e			jp macro_next 
be63				endm 
# End of macro NEXTW
be63			 
be63			 
be63			.HOME: 
be63				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
be63 41				db WORD_SYS_CORE+45             
be64 90 be			dw .CR            
be66 05				db 4 + 1 
be67 .. 00			db "HOME",0              
be6c				endm 
# End of macro CWHEAD
be6c			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
be6c					if DEBUG_FORTH_WORDS_KEY 
be6c						DMARK "HOM" 
be6c f5				push af  
be6d 3a 81 be			ld a, (.dmark)  
be70 32 6b ee			ld (debug_mark),a  
be73 3a 82 be			ld a, (.dmark+1)  
be76 32 6c ee			ld (debug_mark+1),a  
be79 3a 83 be			ld a, (.dmark+2)  
be7c 32 6d ee			ld (debug_mark+2),a  
be7f 18 03			jr .pastdmark  
be81 ..			.dmark: db "HOM"  
be84 f1			.pastdmark: pop af  
be85			endm  
# End of macro DMARK
be85						CALLMONITOR 
be85 cd 6f ee			call debug_vector  
be88				endm  
# End of macro CALLMONITOR
be88					endif 
be88 3e 00		.home:		ld a, 0		; and home cursor 
be8a 32 5e ea				ld (f_cursor_ptr), a 
be8d					NEXTW 
be8d c3 f4 9e			jp macro_next 
be90				endm 
# End of macro NEXTW
be90			 
be90			 
be90			.CR: 
be90				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
be90 46				db WORD_SYS_CORE+50             
be91 cb be			dw .SPACE            
be93 03				db 2 + 1 
be94 .. 00			db "CR",0              
be97				endm 
# End of macro CWHEAD
be97			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
be97					if DEBUG_FORTH_WORDS_KEY 
be97						DMARK "CR." 
be97 f5				push af  
be98 3a ac be			ld a, (.dmark)  
be9b 32 6b ee			ld (debug_mark),a  
be9e 3a ad be			ld a, (.dmark+1)  
bea1 32 6c ee			ld (debug_mark+1),a  
bea4 3a ae be			ld a, (.dmark+2)  
bea7 32 6d ee			ld (debug_mark+2),a  
beaa 18 03			jr .pastdmark  
beac ..			.dmark: db "CR."  
beaf f1			.pastdmark: pop af  
beb0			endm  
# End of macro DMARK
beb0						CALLMONITOR 
beb0 cd 6f ee			call debug_vector  
beb3				endm  
# End of macro CALLMONITOR
beb3					endif 
beb3 3e 0d				ld a, 13 
beb5 32 c1 e2				ld (scratch),a 
beb8 3e 0a				ld a, 10 
beba 32 c2 e2				ld (scratch+1),a 
bebd 3e 00				ld a, 0 
bebf 32 c3 e2				ld (scratch+2),a 
bec2 21 c1 e2				ld hl, scratch 
bec5 cd b5 9b				call forth_push_str 
bec8					 
bec8				       NEXTW 
bec8 c3 f4 9e			jp macro_next 
becb				endm 
# End of macro NEXTW
becb			.SPACE: 
becb				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
becb 46				db WORD_SYS_CORE+50             
becc 01 bf			dw .SPACES            
bece 03				db 2 + 1 
becf .. 00			db "BL",0              
bed2				endm 
# End of macro CWHEAD
bed2			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bed2					if DEBUG_FORTH_WORDS_KEY 
bed2						DMARK "BL." 
bed2 f5				push af  
bed3 3a e7 be			ld a, (.dmark)  
bed6 32 6b ee			ld (debug_mark),a  
bed9 3a e8 be			ld a, (.dmark+1)  
bedc 32 6c ee			ld (debug_mark+1),a  
bedf 3a e9 be			ld a, (.dmark+2)  
bee2 32 6d ee			ld (debug_mark+2),a  
bee5 18 03			jr .pastdmark  
bee7 ..			.dmark: db "BL."  
beea f1			.pastdmark: pop af  
beeb			endm  
# End of macro DMARK
beeb						CALLMONITOR 
beeb cd 6f ee			call debug_vector  
beee				endm  
# End of macro CALLMONITOR
beee					endif 
beee 3e 20				ld a, " " 
bef0 32 c1 e2				ld (scratch),a 
bef3 3e 00				ld a, 0 
bef5 32 c2 e2				ld (scratch+1),a 
bef8 21 c1 e2				ld hl, scratch 
befb cd b5 9b				call forth_push_str 
befe					 
befe				       NEXTW 
befe c3 f4 9e			jp macro_next 
bf01				endm 
# End of macro NEXTW
bf01			 
bf01			;.blstr: db " ", 0 
bf01			 
bf01			.SPACES: 
bf01				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bf01 47				db WORD_SYS_CORE+51             
bf02 9c bf			dw .SCROLL            
bf04 07				db 6 + 1 
bf05 .. 00			db "SPACES",0              
bf0c				endm 
# End of macro CWHEAD
bf0c			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
bf0c					if DEBUG_FORTH_WORDS_KEY 
bf0c						DMARK "SPS" 
bf0c f5				push af  
bf0d 3a 21 bf			ld a, (.dmark)  
bf10 32 6b ee			ld (debug_mark),a  
bf13 3a 22 bf			ld a, (.dmark+1)  
bf16 32 6c ee			ld (debug_mark+1),a  
bf19 3a 23 bf			ld a, (.dmark+2)  
bf1c 32 6d ee			ld (debug_mark+2),a  
bf1f 18 03			jr .pastdmark  
bf21 ..			.dmark: db "SPS"  
bf24 f1			.pastdmark: pop af  
bf25			endm  
# End of macro DMARK
bf25						CALLMONITOR 
bf25 cd 6f ee			call debug_vector  
bf28				endm  
# End of macro CALLMONITOR
bf28					endif 
bf28			 
bf28			 
bf28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf28 cd 3e 9d			call macro_dsp_valuehl 
bf2b				endm 
# End of macro FORTH_DSP_VALUEHL
bf2b			 
bf2b e5					push hl    ; u 
bf2c					if DEBUG_FORTH_WORDS 
bf2c						DMARK "SPA" 
bf2c f5				push af  
bf2d 3a 41 bf			ld a, (.dmark)  
bf30 32 6b ee			ld (debug_mark),a  
bf33 3a 42 bf			ld a, (.dmark+1)  
bf36 32 6c ee			ld (debug_mark+1),a  
bf39 3a 43 bf			ld a, (.dmark+2)  
bf3c 32 6d ee			ld (debug_mark+2),a  
bf3f 18 03			jr .pastdmark  
bf41 ..			.dmark: db "SPA"  
bf44 f1			.pastdmark: pop af  
bf45			endm  
# End of macro DMARK
bf45						CALLMONITOR 
bf45 cd 6f ee			call debug_vector  
bf48				endm  
# End of macro CALLMONITOR
bf48					endif 
bf48			 
bf48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf48 cd f6 9d			call macro_forth_dsp_pop 
bf4b				endm 
# End of macro FORTH_DSP_POP
bf4b e1					pop hl 
bf4c 0e 00				ld c, 0 
bf4e 45					ld b, l 
bf4f 21 c1 e2				ld hl, scratch  
bf52			 
bf52					if DEBUG_FORTH_WORDS 
bf52						DMARK "SP2" 
bf52 f5				push af  
bf53 3a 67 bf			ld a, (.dmark)  
bf56 32 6b ee			ld (debug_mark),a  
bf59 3a 68 bf			ld a, (.dmark+1)  
bf5c 32 6c ee			ld (debug_mark+1),a  
bf5f 3a 69 bf			ld a, (.dmark+2)  
bf62 32 6d ee			ld (debug_mark+2),a  
bf65 18 03			jr .pastdmark  
bf67 ..			.dmark: db "SP2"  
bf6a f1			.pastdmark: pop af  
bf6b			endm  
# End of macro DMARK
bf6b						CALLMONITOR 
bf6b cd 6f ee			call debug_vector  
bf6e				endm  
# End of macro CALLMONITOR
bf6e					endif 
bf6e 3e 20				ld a, ' ' 
bf70			.spaces1:	 
bf70 77					ld (hl),a 
bf71 23					inc hl 
bf72					 
bf72 10 fc				djnz .spaces1 
bf74 3e 00				ld a,0 
bf76 77					ld (hl),a 
bf77 21 c1 e2				ld hl, scratch 
bf7a					if DEBUG_FORTH_WORDS 
bf7a						DMARK "SP3" 
bf7a f5				push af  
bf7b 3a 8f bf			ld a, (.dmark)  
bf7e 32 6b ee			ld (debug_mark),a  
bf81 3a 90 bf			ld a, (.dmark+1)  
bf84 32 6c ee			ld (debug_mark+1),a  
bf87 3a 91 bf			ld a, (.dmark+2)  
bf8a 32 6d ee			ld (debug_mark+2),a  
bf8d 18 03			jr .pastdmark  
bf8f ..			.dmark: db "SP3"  
bf92 f1			.pastdmark: pop af  
bf93			endm  
# End of macro DMARK
bf93						CALLMONITOR 
bf93 cd 6f ee			call debug_vector  
bf96				endm  
# End of macro CALLMONITOR
bf96					endif 
bf96 cd b5 9b				call forth_push_str 
bf99			 
bf99				       NEXTW 
bf99 c3 f4 9e			jp macro_next 
bf9c				endm 
# End of macro NEXTW
bf9c			 
bf9c			 
bf9c			 
bf9c			.SCROLL: 
bf9c				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bf9c 53				db WORD_SYS_CORE+63             
bf9d c9 bf			dw .SCROLLD            
bf9f 07				db 6 + 1 
bfa0 .. 00			db "SCROLL",0              
bfa7				endm 
# End of macro CWHEAD
bfa7			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bfa7					if DEBUG_FORTH_WORDS_KEY 
bfa7						DMARK "SCR" 
bfa7 f5				push af  
bfa8 3a bc bf			ld a, (.dmark)  
bfab 32 6b ee			ld (debug_mark),a  
bfae 3a bd bf			ld a, (.dmark+1)  
bfb1 32 6c ee			ld (debug_mark+1),a  
bfb4 3a be bf			ld a, (.dmark+2)  
bfb7 32 6d ee			ld (debug_mark+2),a  
bfba 18 03			jr .pastdmark  
bfbc ..			.dmark: db "SCR"  
bfbf f1			.pastdmark: pop af  
bfc0			endm  
# End of macro DMARK
bfc0						CALLMONITOR 
bfc0 cd 6f ee			call debug_vector  
bfc3				endm  
# End of macro CALLMONITOR
bfc3					endif 
bfc3			 
bfc3 cd 70 8a			call scroll_up 
bfc6			;	call update_display 
bfc6			 
bfc6					NEXTW 
bfc6 c3 f4 9e			jp macro_next 
bfc9				endm 
# End of macro NEXTW
bfc9			 
bfc9			 
bfc9			 
bfc9			;		; get dir 
bfc9			; 
bfc9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfc9			; 
bfc9			;		push hl 
bfc9			; 
bfc9			;		; destroy value TOS 
bfc9			; 
bfc9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfc9			; 
bfc9			;		; get count 
bfc9			; 
bfc9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfc9			; 
bfc9			;		push hl 
bfc9			; 
bfc9			;		; destroy value TOS 
bfc9			; 
bfc9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfc9			; 
bfc9			;		; one value on hl get other one back 
bfc9			; 
bfc9			;		pop bc    ; count 
bfc9			; 
bfc9			;		pop de   ; dir 
bfc9			; 
bfc9			; 
bfc9			;		ld b, c 
bfc9			; 
bfc9			;.scrolldir:     push bc 
bfc9			;		push de 
bfc9			; 
bfc9			;		ld a, 0 
bfc9			;		cp e 
bfc9			;		jr z, .scrollup  
bfc9			;		call scroll_down 
bfc9			;		jr .scrollnext 
bfc9			;.scrollup:	call scroll_up 
bfc9			; 
bfc9			;		 
bfc9			;.scrollnext: 
bfc9			;		pop de 
bfc9			;		pop bc 
bfc9			;		djnz .scrolldir 
bfc9			; 
bfc9			; 
bfc9			; 
bfc9			; 
bfc9			; 
bfc9			;		NEXTW 
bfc9			 
bfc9			.SCROLLD: 
bfc9				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bfc9 53				db WORD_SYS_CORE+63             
bfca f7 bf			dw .ATQ            
bfcc 08				db 7 + 1 
bfcd .. 00			db "SCROLLD",0              
bfd5				endm 
# End of macro CWHEAD
bfd5			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bfd5					if DEBUG_FORTH_WORDS_KEY 
bfd5						DMARK "SCD" 
bfd5 f5				push af  
bfd6 3a ea bf			ld a, (.dmark)  
bfd9 32 6b ee			ld (debug_mark),a  
bfdc 3a eb bf			ld a, (.dmark+1)  
bfdf 32 6c ee			ld (debug_mark+1),a  
bfe2 3a ec bf			ld a, (.dmark+2)  
bfe5 32 6d ee			ld (debug_mark+2),a  
bfe8 18 03			jr .pastdmark  
bfea ..			.dmark: db "SCD"  
bfed f1			.pastdmark: pop af  
bfee			endm  
# End of macro DMARK
bfee						CALLMONITOR 
bfee cd 6f ee			call debug_vector  
bff1				endm  
# End of macro CALLMONITOR
bff1					endif 
bff1			 
bff1 cd 94 8a			call scroll_down 
bff4			;	call update_display 
bff4			 
bff4					NEXTW 
bff4 c3 f4 9e			jp macro_next 
bff7				endm 
# End of macro NEXTW
bff7			 
bff7			 
bff7			.ATQ: 
bff7				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bff7 62				db WORD_SYS_CORE+78             
bff8 55 c0			dw .AUTODSP            
bffa 04				db 3 + 1 
bffb .. 00			db "AT@",0              
bfff				endm 
# End of macro CWHEAD
bfff			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bfff					if DEBUG_FORTH_WORDS_KEY 
bfff						DMARK "ATA" 
bfff f5				push af  
c000 3a 14 c0			ld a, (.dmark)  
c003 32 6b ee			ld (debug_mark),a  
c006 3a 15 c0			ld a, (.dmark+1)  
c009 32 6c ee			ld (debug_mark+1),a  
c00c 3a 16 c0			ld a, (.dmark+2)  
c00f 32 6d ee			ld (debug_mark+2),a  
c012 18 03			jr .pastdmark  
c014 ..			.dmark: db "ATA"  
c017 f1			.pastdmark: pop af  
c018			endm  
# End of macro DMARK
c018						CALLMONITOR 
c018 cd 6f ee			call debug_vector  
c01b				endm  
# End of macro CALLMONITOR
c01b					endif 
c01b			 
c01b			 
c01b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c01b cd 3e 9d			call macro_dsp_valuehl 
c01e				endm 
# End of macro FORTH_DSP_VALUEHL
c01e			 
c01e					; TODO save cursor row 
c01e 7d					ld a,l 
c01f fe 02				cp 2 
c021 20 04				jr nz, .crow3aq 
c023 3e 28				ld a, display_row_2 
c025 18 12				jr .ccol1aq 
c027 fe 03		.crow3aq:		cp 3 
c029 20 04				jr nz, .crow4aq 
c02b 3e 50				ld a, display_row_3 
c02d 18 0a				jr .ccol1aq 
c02f fe 04		.crow4aq:		cp 4 
c031 20 04				jr nz, .crow1aq 
c033 3e 78				ld a, display_row_4 
c035 18 02				jr .ccol1aq 
c037 3e 00		.crow1aq:		ld a,display_row_1 
c039 f5			.ccol1aq:		push af			; got row offset 
c03a 6f					ld l,a 
c03b 26 00				ld h,0 
c03d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c03d cd f6 9d			call macro_forth_dsp_pop 
c040				endm 
# End of macro FORTH_DSP_POP
c040					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c040 cd 3e 9d			call macro_dsp_valuehl 
c043				endm 
# End of macro FORTH_DSP_VALUEHL
c043					; TODO save cursor col 
c043 f1					pop af 
c044 85					add l		; add col offset 
c045			 
c045					; add current frame buffer address 
c045 2a cc eb				ld hl, (display_fb_active) 
c048 cd db 8c				call addatohl 
c04b			 
c04b			 
c04b			 
c04b			 
c04b					; get char frame buffer location offset in hl 
c04b			 
c04b 7e					ld a,(hl) 
c04c 26 00				ld h, 0 
c04e 6f					ld l, a 
c04f			 
c04f cd 47 9b				call forth_push_numhl 
c052			 
c052			 
c052					NEXTW 
c052 c3 f4 9e			jp macro_next 
c055				endm 
# End of macro NEXTW
c055			 
c055			.AUTODSP: 
c055				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c055 63				db WORD_SYS_CORE+79             
c056 6b c0			dw .MENU            
c058 05				db 4 + 1 
c059 .. 00			db "ADSP",0              
c05e				endm 
# End of macro CWHEAD
c05e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c05e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c05e			 
c05e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c05e cd 3e 9d			call macro_dsp_valuehl 
c061				endm 
# End of macro FORTH_DSP_VALUEHL
c061			 
c061			;		push hl 
c061			 
c061					; destroy value TOS 
c061			 
c061					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c061 cd f6 9d			call macro_forth_dsp_pop 
c064				endm 
# End of macro FORTH_DSP_POP
c064			 
c064			;		pop hl 
c064			 
c064 7d					ld a,l 
c065 32 3c ea				ld (cli_autodisplay), a 
c068				       NEXTW 
c068 c3 f4 9e			jp macro_next 
c06b				endm 
# End of macro NEXTW
c06b			 
c06b			.MENU: 
c06b				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c06b 70				db WORD_SYS_CORE+92             
c06c 14 c1			dw .ENDDISPLAY            
c06e 05				db 4 + 1 
c06f .. 00			db "MENU",0              
c074				endm 
# End of macro CWHEAD
c074			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c074			 
c074			;		; get number of items on the stack 
c074			; 
c074				 
c074					FORTH_DSP_VALUEHL 
c074 cd 3e 9d			call macro_dsp_valuehl 
c077				endm 
# End of macro FORTH_DSP_VALUEHL
c077				 
c077					if DEBUG_FORTH_WORDS_KEY 
c077						DMARK "MNU" 
c077 f5				push af  
c078 3a 8c c0			ld a, (.dmark)  
c07b 32 6b ee			ld (debug_mark),a  
c07e 3a 8d c0			ld a, (.dmark+1)  
c081 32 6c ee			ld (debug_mark+1),a  
c084 3a 8e c0			ld a, (.dmark+2)  
c087 32 6d ee			ld (debug_mark+2),a  
c08a 18 03			jr .pastdmark  
c08c ..			.dmark: db "MNU"  
c08f f1			.pastdmark: pop af  
c090			endm  
# End of macro DMARK
c090						CALLMONITOR 
c090 cd 6f ee			call debug_vector  
c093				endm  
# End of macro CALLMONITOR
c093					endif 
c093			 
c093 45					ld b, l	 
c094 05					dec b 
c095			 
c095					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c095 cd f6 9d			call macro_forth_dsp_pop 
c098				endm 
# End of macro FORTH_DSP_POP
c098			 
c098			 
c098					; go directly through the stack to pluck out the string pointers and build an array 
c098			 
c098			;		FORTH_DSP 
c098			 
c098					; hl contains top most stack item 
c098				 
c098 11 c1 e2				ld de, scratch 
c09b			 
c09b			.mbuild: 
c09b			 
c09b					FORTH_DSP_VALUEHL 
c09b cd 3e 9d			call macro_dsp_valuehl 
c09e				endm 
# End of macro FORTH_DSP_VALUEHL
c09e			 
c09e					if DEBUG_FORTH_WORDS 
c09e						DMARK "MN3" 
c09e f5				push af  
c09f 3a b3 c0			ld a, (.dmark)  
c0a2 32 6b ee			ld (debug_mark),a  
c0a5 3a b4 c0			ld a, (.dmark+1)  
c0a8 32 6c ee			ld (debug_mark+1),a  
c0ab 3a b5 c0			ld a, (.dmark+2)  
c0ae 32 6d ee			ld (debug_mark+2),a  
c0b1 18 03			jr .pastdmark  
c0b3 ..			.dmark: db "MN3"  
c0b6 f1			.pastdmark: pop af  
c0b7			endm  
# End of macro DMARK
c0b7						CALLMONITOR 
c0b7 cd 6f ee			call debug_vector  
c0ba				endm  
# End of macro CALLMONITOR
c0ba					endif 
c0ba eb					ex de, hl 
c0bb 73					ld (hl), e 
c0bc 23					inc hl 
c0bd 72					ld (hl), d 
c0be 23					inc hl 
c0bf eb					ex de, hl 
c0c0			 
c0c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0c0 cd f6 9d			call macro_forth_dsp_pop 
c0c3				endm 
# End of macro FORTH_DSP_POP
c0c3			 
c0c3 10 d6				djnz .mbuild 
c0c5			 
c0c5					; done add term 
c0c5			 
c0c5 eb					ex de, hl 
c0c6 36 00				ld (hl), 0 
c0c8 23					inc hl 
c0c9 36 00				ld (hl), 0 
c0cb			 
c0cb				 
c0cb					 
c0cb 21 c1 e2				ld hl, scratch 
c0ce			 
c0ce					if DEBUG_FORTH_WORDS 
c0ce						DMARK "MNx" 
c0ce f5				push af  
c0cf 3a e3 c0			ld a, (.dmark)  
c0d2 32 6b ee			ld (debug_mark),a  
c0d5 3a e4 c0			ld a, (.dmark+1)  
c0d8 32 6c ee			ld (debug_mark+1),a  
c0db 3a e5 c0			ld a, (.dmark+2)  
c0de 32 6d ee			ld (debug_mark+2),a  
c0e1 18 03			jr .pastdmark  
c0e3 ..			.dmark: db "MNx"  
c0e6 f1			.pastdmark: pop af  
c0e7			endm  
# End of macro DMARK
c0e7						CALLMONITOR 
c0e7 cd 6f ee			call debug_vector  
c0ea				endm  
# End of macro CALLMONITOR
c0ea					endif 
c0ea			 
c0ea			 
c0ea			 
c0ea 3e 00				ld a, 0 
c0ec cd df 8a				call menu 
c0ef			 
c0ef			 
c0ef 6f					ld l, a 
c0f0 26 00				ld h, 0 
c0f2			 
c0f2					if DEBUG_FORTH_WORDS 
c0f2						DMARK "MNr" 
c0f2 f5				push af  
c0f3 3a 07 c1			ld a, (.dmark)  
c0f6 32 6b ee			ld (debug_mark),a  
c0f9 3a 08 c1			ld a, (.dmark+1)  
c0fc 32 6c ee			ld (debug_mark+1),a  
c0ff 3a 09 c1			ld a, (.dmark+2)  
c102 32 6d ee			ld (debug_mark+2),a  
c105 18 03			jr .pastdmark  
c107 ..			.dmark: db "MNr"  
c10a f1			.pastdmark: pop af  
c10b			endm  
# End of macro DMARK
c10b						CALLMONITOR 
c10b cd 6f ee			call debug_vector  
c10e				endm  
# End of macro CALLMONITOR
c10e					endif 
c10e			 
c10e cd 47 9b				call forth_push_numhl 
c111			 
c111			 
c111			 
c111			 
c111				       NEXTW 
c111 c3 f4 9e			jp macro_next 
c114				endm 
# End of macro NEXTW
c114			 
c114			 
c114			.ENDDISPLAY: 
c114			 
c114			; eof 
# End of file forth_words_display.asm
c114			include "forth_words_str.asm" 
c114			 
c114			; | ## String Words 
c114			 
c114			.PTR:   
c114			 
c114				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c114 48				db WORD_SYS_CORE+52             
c115 41 c1			dw .STYPE            
c117 04				db 3 + 1 
c118 .. 00			db "PTR",0              
c11c				endm 
# End of macro CWHEAD
c11c			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c11c			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c11c			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c11c			 
c11c					if DEBUG_FORTH_WORDS_KEY 
c11c						DMARK "PTR" 
c11c f5				push af  
c11d 3a 31 c1			ld a, (.dmark)  
c120 32 6b ee			ld (debug_mark),a  
c123 3a 32 c1			ld a, (.dmark+1)  
c126 32 6c ee			ld (debug_mark+1),a  
c129 3a 33 c1			ld a, (.dmark+2)  
c12c 32 6d ee			ld (debug_mark+2),a  
c12f 18 03			jr .pastdmark  
c131 ..			.dmark: db "PTR"  
c134 f1			.pastdmark: pop af  
c135			endm  
# End of macro DMARK
c135						CALLMONITOR 
c135 cd 6f ee			call debug_vector  
c138				endm  
# End of macro CALLMONITOR
c138					endif 
c138					FORTH_DSP_VALUEHL 
c138 cd 3e 9d			call macro_dsp_valuehl 
c13b				endm 
# End of macro FORTH_DSP_VALUEHL
c13b cd 47 9b				call forth_push_numhl 
c13e			 
c13e			 
c13e					NEXTW 
c13e c3 f4 9e			jp macro_next 
c141				endm 
# End of macro NEXTW
c141			.STYPE: 
c141				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c141 48				db WORD_SYS_CORE+52             
c142 90 c1			dw .UPPER            
c144 06				db 5 + 1 
c145 .. 00			db "STYPE",0              
c14b				endm 
# End of macro CWHEAD
c14b			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c14b					if DEBUG_FORTH_WORDS_KEY 
c14b						DMARK "STY" 
c14b f5				push af  
c14c 3a 60 c1			ld a, (.dmark)  
c14f 32 6b ee			ld (debug_mark),a  
c152 3a 61 c1			ld a, (.dmark+1)  
c155 32 6c ee			ld (debug_mark+1),a  
c158 3a 62 c1			ld a, (.dmark+2)  
c15b 32 6d ee			ld (debug_mark+2),a  
c15e 18 03			jr .pastdmark  
c160 ..			.dmark: db "STY"  
c163 f1			.pastdmark: pop af  
c164			endm  
# End of macro DMARK
c164						CALLMONITOR 
c164 cd 6f ee			call debug_vector  
c167				endm  
# End of macro CALLMONITOR
c167					endif 
c167					FORTH_DSP 
c167 cd 04 9d			call macro_forth_dsp 
c16a				endm 
# End of macro FORTH_DSP
c16a					;v5 FORTH_DSP_VALUE 
c16a			 
c16a 7e					ld a, (hl) 
c16b			 
c16b f5					push af 
c16c			 
c16c			; Dont destroy TOS		FORTH_DSP_POP 
c16c			 
c16c f1					pop af 
c16d			 
c16d fe 01				cp DS_TYPE_STR 
c16f 28 09				jr z, .typestr 
c171			 
c171 fe 02				cp DS_TYPE_INUM 
c173 28 0a				jr z, .typeinum 
c175			 
c175 21 8e c1				ld hl, .tna 
c178 18 0a				jr .tpush 
c17a			 
c17a 21 8a c1		.typestr:	ld hl, .tstr 
c17d 18 05				jr .tpush 
c17f 21 8c c1		.typeinum:	ld hl, .tinum 
c182 18 00				jr .tpush 
c184			 
c184			.tpush: 
c184			 
c184 cd b5 9b				call forth_push_str 
c187			 
c187					NEXTW 
c187 c3 f4 9e			jp macro_next 
c18a				endm 
# End of macro NEXTW
c18a .. 00		.tstr:	db "s",0 
c18c .. 00		.tinum:  db "i",0 
c18e .. 00		.tna:   db "?", 0 
c190			 
c190			 
c190			.UPPER: 
c190				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c190 48				db WORD_SYS_CORE+52             
c191 cb c1			dw .LOWER            
c193 06				db 5 + 1 
c194 .. 00			db "UPPER",0              
c19a				endm 
# End of macro CWHEAD
c19a			; | UPPER ( s -- s ) Upper case string s  | DONE 
c19a					if DEBUG_FORTH_WORDS_KEY 
c19a						DMARK "UPR" 
c19a f5				push af  
c19b 3a af c1			ld a, (.dmark)  
c19e 32 6b ee			ld (debug_mark),a  
c1a1 3a b0 c1			ld a, (.dmark+1)  
c1a4 32 6c ee			ld (debug_mark+1),a  
c1a7 3a b1 c1			ld a, (.dmark+2)  
c1aa 32 6d ee			ld (debug_mark+2),a  
c1ad 18 03			jr .pastdmark  
c1af ..			.dmark: db "UPR"  
c1b2 f1			.pastdmark: pop af  
c1b3			endm  
# End of macro DMARK
c1b3						CALLMONITOR 
c1b3 cd 6f ee			call debug_vector  
c1b6				endm  
# End of macro CALLMONITOR
c1b6					endif 
c1b6			 
c1b6					FORTH_DSP 
c1b6 cd 04 9d			call macro_forth_dsp 
c1b9				endm 
# End of macro FORTH_DSP
c1b9					 
c1b9			; TODO check is string type 
c1b9			 
c1b9					FORTH_DSP_VALUEHL 
c1b9 cd 3e 9d			call macro_dsp_valuehl 
c1bc				endm 
# End of macro FORTH_DSP_VALUEHL
c1bc			; get pointer to string in hl 
c1bc			 
c1bc 7e			.toup:		ld a, (hl) 
c1bd fe 00				cp 0 
c1bf 28 07				jr z, .toupdone 
c1c1			 
c1c1 cd 48 90				call to_upper 
c1c4			 
c1c4 77					ld (hl), a 
c1c5 23					inc hl 
c1c6 18 f4				jr .toup 
c1c8			 
c1c8					 
c1c8			 
c1c8			 
c1c8			; for each char convert to upper 
c1c8					 
c1c8			.toupdone: 
c1c8			 
c1c8			 
c1c8					NEXTW 
c1c8 c3 f4 9e			jp macro_next 
c1cb				endm 
# End of macro NEXTW
c1cb			.LOWER: 
c1cb				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c1cb 48				db WORD_SYS_CORE+52             
c1cc 06 c2			dw .TCASE            
c1ce 06				db 5 + 1 
c1cf .. 00			db "LOWER",0              
c1d5				endm 
# End of macro CWHEAD
c1d5			; | LOWER ( s -- s ) Lower case string s  | DONE 
c1d5					if DEBUG_FORTH_WORDS_KEY 
c1d5						DMARK "LWR" 
c1d5 f5				push af  
c1d6 3a ea c1			ld a, (.dmark)  
c1d9 32 6b ee			ld (debug_mark),a  
c1dc 3a eb c1			ld a, (.dmark+1)  
c1df 32 6c ee			ld (debug_mark+1),a  
c1e2 3a ec c1			ld a, (.dmark+2)  
c1e5 32 6d ee			ld (debug_mark+2),a  
c1e8 18 03			jr .pastdmark  
c1ea ..			.dmark: db "LWR"  
c1ed f1			.pastdmark: pop af  
c1ee			endm  
# End of macro DMARK
c1ee						CALLMONITOR 
c1ee cd 6f ee			call debug_vector  
c1f1				endm  
# End of macro CALLMONITOR
c1f1					endif 
c1f1			 
c1f1					FORTH_DSP 
c1f1 cd 04 9d			call macro_forth_dsp 
c1f4				endm 
# End of macro FORTH_DSP
c1f4					 
c1f4			; TODO check is string type 
c1f4			 
c1f4					FORTH_DSP_VALUEHL 
c1f4 cd 3e 9d			call macro_dsp_valuehl 
c1f7				endm 
# End of macro FORTH_DSP_VALUEHL
c1f7			; get pointer to string in hl 
c1f7			 
c1f7 7e			.tolow:		ld a, (hl) 
c1f8 fe 00				cp 0 
c1fa 28 07				jr z, .tolowdone 
c1fc			 
c1fc cd 51 90				call to_lower 
c1ff			 
c1ff 77					ld (hl), a 
c200 23					inc hl 
c201 18 f4				jr .tolow 
c203			 
c203					 
c203			 
c203			 
c203			; for each char convert to low 
c203					 
c203			.tolowdone: 
c203					NEXTW 
c203 c3 f4 9e			jp macro_next 
c206				endm 
# End of macro NEXTW
c206			.TCASE: 
c206				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c206 48				db WORD_SYS_CORE+52             
c207 3c c3			dw .SUBSTR            
c209 06				db 5 + 1 
c20a .. 00			db "TCASE",0              
c210				endm 
# End of macro CWHEAD
c210			; | TCASE ( s -- s ) Title case string s  | DONE 
c210					if DEBUG_FORTH_WORDS_KEY 
c210						DMARK "TCS" 
c210 f5				push af  
c211 3a 25 c2			ld a, (.dmark)  
c214 32 6b ee			ld (debug_mark),a  
c217 3a 26 c2			ld a, (.dmark+1)  
c21a 32 6c ee			ld (debug_mark+1),a  
c21d 3a 27 c2			ld a, (.dmark+2)  
c220 32 6d ee			ld (debug_mark+2),a  
c223 18 03			jr .pastdmark  
c225 ..			.dmark: db "TCS"  
c228 f1			.pastdmark: pop af  
c229			endm  
# End of macro DMARK
c229						CALLMONITOR 
c229 cd 6f ee			call debug_vector  
c22c				endm  
# End of macro CALLMONITOR
c22c					endif 
c22c			 
c22c					FORTH_DSP 
c22c cd 04 9d			call macro_forth_dsp 
c22f				endm 
# End of macro FORTH_DSP
c22f					 
c22f			; TODO check is string type 
c22f			 
c22f					FORTH_DSP_VALUEHL 
c22f cd 3e 9d			call macro_dsp_valuehl 
c232				endm 
# End of macro FORTH_DSP_VALUEHL
c232			; get pointer to string in hl 
c232			 
c232					if DEBUG_FORTH_WORDS 
c232						DMARK "TC1" 
c232 f5				push af  
c233 3a 47 c2			ld a, (.dmark)  
c236 32 6b ee			ld (debug_mark),a  
c239 3a 48 c2			ld a, (.dmark+1)  
c23c 32 6c ee			ld (debug_mark+1),a  
c23f 3a 49 c2			ld a, (.dmark+2)  
c242 32 6d ee			ld (debug_mark+2),a  
c245 18 03			jr .pastdmark  
c247 ..			.dmark: db "TC1"  
c24a f1			.pastdmark: pop af  
c24b			endm  
# End of macro DMARK
c24b						CALLMONITOR 
c24b cd 6f ee			call debug_vector  
c24e				endm  
# End of macro CALLMONITOR
c24e					endif 
c24e			 
c24e					; first time in turn to upper case first char 
c24e			 
c24e 7e					ld a, (hl) 
c24f c3 d9 c2				jp .totsiptou 
c252			 
c252			 
c252 7e			.tot:		ld a, (hl) 
c253 fe 00				cp 0 
c255 ca 1d c3				jp z, .totdone 
c258			 
c258					if DEBUG_FORTH_WORDS 
c258						DMARK "TC2" 
c258 f5				push af  
c259 3a 6d c2			ld a, (.dmark)  
c25c 32 6b ee			ld (debug_mark),a  
c25f 3a 6e c2			ld a, (.dmark+1)  
c262 32 6c ee			ld (debug_mark+1),a  
c265 3a 6f c2			ld a, (.dmark+2)  
c268 32 6d ee			ld (debug_mark+2),a  
c26b 18 03			jr .pastdmark  
c26d ..			.dmark: db "TC2"  
c270 f1			.pastdmark: pop af  
c271			endm  
# End of macro DMARK
c271						CALLMONITOR 
c271 cd 6f ee			call debug_vector  
c274				endm  
# End of macro CALLMONITOR
c274					endif 
c274					; check to see if current char is a space 
c274			 
c274 fe 20				cp ' ' 
c276 28 21				jr z, .totsp 
c278 cd 51 90				call to_lower 
c27b					if DEBUG_FORTH_WORDS 
c27b						DMARK "TC3" 
c27b f5				push af  
c27c 3a 90 c2			ld a, (.dmark)  
c27f 32 6b ee			ld (debug_mark),a  
c282 3a 91 c2			ld a, (.dmark+1)  
c285 32 6c ee			ld (debug_mark+1),a  
c288 3a 92 c2			ld a, (.dmark+2)  
c28b 32 6d ee			ld (debug_mark+2),a  
c28e 18 03			jr .pastdmark  
c290 ..			.dmark: db "TC3"  
c293 f1			.pastdmark: pop af  
c294			endm  
# End of macro DMARK
c294						CALLMONITOR 
c294 cd 6f ee			call debug_vector  
c297				endm  
# End of macro CALLMONITOR
c297					endif 
c297 18 63				jr .totnxt 
c299			 
c299			.totsp:         ; on a space, find next char which should be upper 
c299			 
c299					if DEBUG_FORTH_WORDS 
c299						DMARK "TC4" 
c299 f5				push af  
c29a 3a ae c2			ld a, (.dmark)  
c29d 32 6b ee			ld (debug_mark),a  
c2a0 3a af c2			ld a, (.dmark+1)  
c2a3 32 6c ee			ld (debug_mark+1),a  
c2a6 3a b0 c2			ld a, (.dmark+2)  
c2a9 32 6d ee			ld (debug_mark+2),a  
c2ac 18 03			jr .pastdmark  
c2ae ..			.dmark: db "TC4"  
c2b1 f1			.pastdmark: pop af  
c2b2			endm  
# End of macro DMARK
c2b2						CALLMONITOR 
c2b2 cd 6f ee			call debug_vector  
c2b5				endm  
# End of macro CALLMONITOR
c2b5					endif 
c2b5					;; 
c2b5			 
c2b5 fe 20				cp ' ' 
c2b7 20 20				jr nz, .totsiptou 
c2b9 23					inc hl 
c2ba 7e					ld a, (hl) 
c2bb					if DEBUG_FORTH_WORDS 
c2bb						DMARK "TC5" 
c2bb f5				push af  
c2bc 3a d0 c2			ld a, (.dmark)  
c2bf 32 6b ee			ld (debug_mark),a  
c2c2 3a d1 c2			ld a, (.dmark+1)  
c2c5 32 6c ee			ld (debug_mark+1),a  
c2c8 3a d2 c2			ld a, (.dmark+2)  
c2cb 32 6d ee			ld (debug_mark+2),a  
c2ce 18 03			jr .pastdmark  
c2d0 ..			.dmark: db "TC5"  
c2d3 f1			.pastdmark: pop af  
c2d4			endm  
# End of macro DMARK
c2d4						CALLMONITOR 
c2d4 cd 6f ee			call debug_vector  
c2d7				endm  
# End of macro CALLMONITOR
c2d7					endif 
c2d7 18 c0				jr .totsp 
c2d9 fe 00		.totsiptou:    cp 0 
c2db 28 40				jr z, .totdone 
c2dd					; not space and not zero term so upper case it 
c2dd cd 48 90				call to_upper 
c2e0			 
c2e0					if DEBUG_FORTH_WORDS 
c2e0						DMARK "TC6" 
c2e0 f5				push af  
c2e1 3a f5 c2			ld a, (.dmark)  
c2e4 32 6b ee			ld (debug_mark),a  
c2e7 3a f6 c2			ld a, (.dmark+1)  
c2ea 32 6c ee			ld (debug_mark+1),a  
c2ed 3a f7 c2			ld a, (.dmark+2)  
c2f0 32 6d ee			ld (debug_mark+2),a  
c2f3 18 03			jr .pastdmark  
c2f5 ..			.dmark: db "TC6"  
c2f8 f1			.pastdmark: pop af  
c2f9			endm  
# End of macro DMARK
c2f9						CALLMONITOR 
c2f9 cd 6f ee			call debug_vector  
c2fc				endm  
# End of macro CALLMONITOR
c2fc					endif 
c2fc			 
c2fc			 
c2fc			.totnxt: 
c2fc			 
c2fc 77					ld (hl), a 
c2fd 23					inc hl 
c2fe					if DEBUG_FORTH_WORDS 
c2fe						DMARK "TC7" 
c2fe f5				push af  
c2ff 3a 13 c3			ld a, (.dmark)  
c302 32 6b ee			ld (debug_mark),a  
c305 3a 14 c3			ld a, (.dmark+1)  
c308 32 6c ee			ld (debug_mark+1),a  
c30b 3a 15 c3			ld a, (.dmark+2)  
c30e 32 6d ee			ld (debug_mark+2),a  
c311 18 03			jr .pastdmark  
c313 ..			.dmark: db "TC7"  
c316 f1			.pastdmark: pop af  
c317			endm  
# End of macro DMARK
c317						CALLMONITOR 
c317 cd 6f ee			call debug_vector  
c31a				endm  
# End of macro CALLMONITOR
c31a					endif 
c31a c3 52 c2				jp .tot 
c31d			 
c31d					 
c31d			 
c31d			 
c31d			; for each char convert to low 
c31d					 
c31d			.totdone: 
c31d					if DEBUG_FORTH_WORDS 
c31d						DMARK "TCd" 
c31d f5				push af  
c31e 3a 32 c3			ld a, (.dmark)  
c321 32 6b ee			ld (debug_mark),a  
c324 3a 33 c3			ld a, (.dmark+1)  
c327 32 6c ee			ld (debug_mark+1),a  
c32a 3a 34 c3			ld a, (.dmark+2)  
c32d 32 6d ee			ld (debug_mark+2),a  
c330 18 03			jr .pastdmark  
c332 ..			.dmark: db "TCd"  
c335 f1			.pastdmark: pop af  
c336			endm  
# End of macro DMARK
c336						CALLMONITOR 
c336 cd 6f ee			call debug_vector  
c339				endm  
# End of macro CALLMONITOR
c339					endif 
c339					NEXTW 
c339 c3 f4 9e			jp macro_next 
c33c				endm 
# End of macro NEXTW
c33c			 
c33c			.SUBSTR: 
c33c				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c33c 48				db WORD_SYS_CORE+52             
c33d 9a c3			dw .LEFT            
c33f 07				db 6 + 1 
c340 .. 00			db "SUBSTR",0              
c347				endm 
# End of macro CWHEAD
c347			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c347			 
c347					if DEBUG_FORTH_WORDS_KEY 
c347						DMARK "SST" 
c347 f5				push af  
c348 3a 5c c3			ld a, (.dmark)  
c34b 32 6b ee			ld (debug_mark),a  
c34e 3a 5d c3			ld a, (.dmark+1)  
c351 32 6c ee			ld (debug_mark+1),a  
c354 3a 5e c3			ld a, (.dmark+2)  
c357 32 6d ee			ld (debug_mark+2),a  
c35a 18 03			jr .pastdmark  
c35c ..			.dmark: db "SST"  
c35f f1			.pastdmark: pop af  
c360			endm  
# End of macro DMARK
c360						CALLMONITOR 
c360 cd 6f ee			call debug_vector  
c363				endm  
# End of macro CALLMONITOR
c363					endif 
c363			; TODO check string type 
c363					FORTH_DSP_VALUEHL 
c363 cd 3e 9d			call macro_dsp_valuehl 
c366				endm 
# End of macro FORTH_DSP_VALUEHL
c366			 
c366 e5					push hl      ; string length 
c367			 
c367					FORTH_DSP_POP 
c367 cd f6 9d			call macro_forth_dsp_pop 
c36a				endm 
# End of macro FORTH_DSP_POP
c36a			 
c36a					FORTH_DSP_VALUEHL 
c36a cd 3e 9d			call macro_dsp_valuehl 
c36d				endm 
# End of macro FORTH_DSP_VALUEHL
c36d			 
c36d e5					push hl     ; start char 
c36e			 
c36e					FORTH_DSP_POP 
c36e cd f6 9d			call macro_forth_dsp_pop 
c371				endm 
# End of macro FORTH_DSP_POP
c371			 
c371			 
c371					FORTH_DSP_VALUE 
c371 cd 27 9d			call macro_forth_dsp_value 
c374				endm 
# End of macro FORTH_DSP_VALUE
c374			 
c374 d1					pop de    ; get start post offset 
c375			 
c375 19					add hl, de    ; starting offset 
c376			 
c376 c1					pop bc 
c377 c5					push bc      ; grab size of string 
c378			 
c378 e5					push hl    ; save string start  
c379			 
c379 26 00				ld h, 0 
c37b 69					ld l, c 
c37c 23					inc hl 
c37d 23					inc hl 
c37e			 
c37e cd ae 91				call malloc 
c381				if DEBUG_FORTH_MALLOC_GUARD 
c381 cc b4 cc				call z,malloc_error 
c384				endif 
c384			 
c384 eb					ex de, hl      ; save malloc area for string copy 
c385 e1					pop hl    ; get back source 
c386 c1					pop bc    ; get length of string back 
c387			 
c387 d5					push de    ; save malloc area for after we push 
c388 ed b0				ldir     ; copy substr 
c38a			 
c38a			 
c38a eb					ex de, hl 
c38b 3e 00				ld a, 0 
c38d 77					ld (hl), a   ; term substr 
c38e			 
c38e					 
c38e e1					pop hl    ; get malloc so we can push it 
c38f e5					push hl   ; save so we can free it afterwards 
c390			 
c390 cd b5 9b				call forth_push_str 
c393			 
c393 e1					pop hl 
c394 cd 78 92				call free 
c397			 
c397					 
c397					 
c397			 
c397			 
c397					NEXTW 
c397 c3 f4 9e			jp macro_next 
c39a				endm 
# End of macro NEXTW
c39a			 
c39a			.LEFT: 
c39a				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c39a 48				db WORD_SYS_CORE+52             
c39b c2 c3			dw .RIGHT            
c39d 05				db 4 + 1 
c39e .. 00			db "LEFT",0              
c3a3				endm 
# End of macro CWHEAD
c3a3			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c3a3					if DEBUG_FORTH_WORDS_KEY 
c3a3						DMARK "LEF" 
c3a3 f5				push af  
c3a4 3a b8 c3			ld a, (.dmark)  
c3a7 32 6b ee			ld (debug_mark),a  
c3aa 3a b9 c3			ld a, (.dmark+1)  
c3ad 32 6c ee			ld (debug_mark+1),a  
c3b0 3a ba c3			ld a, (.dmark+2)  
c3b3 32 6d ee			ld (debug_mark+2),a  
c3b6 18 03			jr .pastdmark  
c3b8 ..			.dmark: db "LEF"  
c3bb f1			.pastdmark: pop af  
c3bc			endm  
# End of macro DMARK
c3bc						CALLMONITOR 
c3bc cd 6f ee			call debug_vector  
c3bf				endm  
# End of macro CALLMONITOR
c3bf					endif 
c3bf			 
c3bf					NEXTW 
c3bf c3 f4 9e			jp macro_next 
c3c2				endm 
# End of macro NEXTW
c3c2			.RIGHT: 
c3c2				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c3c2 48				db WORD_SYS_CORE+52             
c3c3 eb c3			dw .STR2NUM            
c3c5 06				db 5 + 1 
c3c6 .. 00			db "RIGHT",0              
c3cc				endm 
# End of macro CWHEAD
c3cc			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c3cc					if DEBUG_FORTH_WORDS_KEY 
c3cc						DMARK "RIG" 
c3cc f5				push af  
c3cd 3a e1 c3			ld a, (.dmark)  
c3d0 32 6b ee			ld (debug_mark),a  
c3d3 3a e2 c3			ld a, (.dmark+1)  
c3d6 32 6c ee			ld (debug_mark+1),a  
c3d9 3a e3 c3			ld a, (.dmark+2)  
c3dc 32 6d ee			ld (debug_mark+2),a  
c3df 18 03			jr .pastdmark  
c3e1 ..			.dmark: db "RIG"  
c3e4 f1			.pastdmark: pop af  
c3e5			endm  
# End of macro DMARK
c3e5						CALLMONITOR 
c3e5 cd 6f ee			call debug_vector  
c3e8				endm  
# End of macro CALLMONITOR
c3e8					endif 
c3e8			 
c3e8					NEXTW 
c3e8 c3 f4 9e			jp macro_next 
c3eb				endm 
# End of macro NEXTW
c3eb			 
c3eb			 
c3eb			.STR2NUM: 
c3eb				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c3eb 48				db WORD_SYS_CORE+52             
c3ec 77 c4			dw .NUM2STR            
c3ee 08				db 7 + 1 
c3ef .. 00			db "STR2NUM",0              
c3f7				endm 
# End of macro CWHEAD
c3f7			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c3f7			 
c3f7			 
c3f7			; TODO STR type check to do 
c3f7					if DEBUG_FORTH_WORDS_KEY 
c3f7						DMARK "S2N" 
c3f7 f5				push af  
c3f8 3a 0c c4			ld a, (.dmark)  
c3fb 32 6b ee			ld (debug_mark),a  
c3fe 3a 0d c4			ld a, (.dmark+1)  
c401 32 6c ee			ld (debug_mark+1),a  
c404 3a 0e c4			ld a, (.dmark+2)  
c407 32 6d ee			ld (debug_mark+2),a  
c40a 18 03			jr .pastdmark  
c40c ..			.dmark: db "S2N"  
c40f f1			.pastdmark: pop af  
c410			endm  
# End of macro DMARK
c410						CALLMONITOR 
c410 cd 6f ee			call debug_vector  
c413				endm  
# End of macro CALLMONITOR
c413					endif 
c413			 
c413					;FORTH_DSP 
c413					FORTH_DSP_VALUE 
c413 cd 27 9d			call macro_forth_dsp_value 
c416				endm 
# End of macro FORTH_DSP_VALUE
c416					;inc hl 
c416			 
c416 eb					ex de, hl 
c417					if DEBUG_FORTH_WORDS 
c417						DMARK "S2a" 
c417 f5				push af  
c418 3a 2c c4			ld a, (.dmark)  
c41b 32 6b ee			ld (debug_mark),a  
c41e 3a 2d c4			ld a, (.dmark+1)  
c421 32 6c ee			ld (debug_mark+1),a  
c424 3a 2e c4			ld a, (.dmark+2)  
c427 32 6d ee			ld (debug_mark+2),a  
c42a 18 03			jr .pastdmark  
c42c ..			.dmark: db "S2a"  
c42f f1			.pastdmark: pop af  
c430			endm  
# End of macro DMARK
c430						CALLMONITOR 
c430 cd 6f ee			call debug_vector  
c433				endm  
# End of macro CALLMONITOR
c433					endif 
c433 cd d0 90				call string_to_uint16 
c436			 
c436					if DEBUG_FORTH_WORDS 
c436						DMARK "S2b" 
c436 f5				push af  
c437 3a 4b c4			ld a, (.dmark)  
c43a 32 6b ee			ld (debug_mark),a  
c43d 3a 4c c4			ld a, (.dmark+1)  
c440 32 6c ee			ld (debug_mark+1),a  
c443 3a 4d c4			ld a, (.dmark+2)  
c446 32 6d ee			ld (debug_mark+2),a  
c449 18 03			jr .pastdmark  
c44b ..			.dmark: db "S2b"  
c44e f1			.pastdmark: pop af  
c44f			endm  
# End of macro DMARK
c44f						CALLMONITOR 
c44f cd 6f ee			call debug_vector  
c452				endm  
# End of macro CALLMONITOR
c452					endif 
c452			;		push hl 
c452					FORTH_DSP_POP 
c452 cd f6 9d			call macro_forth_dsp_pop 
c455				endm 
# End of macro FORTH_DSP_POP
c455			;		pop hl 
c455					 
c455					if DEBUG_FORTH_WORDS 
c455						DMARK "S2b" 
c455 f5				push af  
c456 3a 6a c4			ld a, (.dmark)  
c459 32 6b ee			ld (debug_mark),a  
c45c 3a 6b c4			ld a, (.dmark+1)  
c45f 32 6c ee			ld (debug_mark+1),a  
c462 3a 6c c4			ld a, (.dmark+2)  
c465 32 6d ee			ld (debug_mark+2),a  
c468 18 03			jr .pastdmark  
c46a ..			.dmark: db "S2b"  
c46d f1			.pastdmark: pop af  
c46e			endm  
# End of macro DMARK
c46e						CALLMONITOR 
c46e cd 6f ee			call debug_vector  
c471				endm  
# End of macro CALLMONITOR
c471					endif 
c471 cd 47 9b				call forth_push_numhl	 
c474			 
c474				 
c474				       NEXTW 
c474 c3 f4 9e			jp macro_next 
c477				endm 
# End of macro NEXTW
c477			.NUM2STR: 
c477				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c477 48				db WORD_SYS_CORE+52             
c478 86 c4			dw .CONCAT            
c47a 08				db 7 + 1 
c47b .. 00			db "NUM2STR",0              
c483				endm 
# End of macro CWHEAD
c483			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c483			 
c483			;		; malloc a string to target 
c483			;		ld hl, 10     ; TODO max string size should be fine 
c483			;		call malloc 
c483			;		push hl    ; save malloc location 
c483			; 
c483			; 
c483			;; TODO check int type 
c483			;		FORTH_DSP_VALUEHL 
c483			;		ld a, l 
c483			;		call DispAToASCII   
c483			;;TODO need to chage above call to dump into string 
c483			; 
c483			; 
c483			 
c483				       NEXTW 
c483 c3 f4 9e			jp macro_next 
c486				endm 
# End of macro NEXTW
c486			 
c486			.CONCAT: 
c486				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c486 48				db WORD_SYS_CORE+52             
c487 39 c5			dw .FIND            
c489 07				db 6 + 1 
c48a .. 00			db "CONCAT",0              
c491				endm 
# End of macro CWHEAD
c491			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c491			 
c491			; TODO check string type 
c491			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c491			 
c491					if DEBUG_FORTH_WORDS_KEY 
c491						DMARK "CON" 
c491 f5				push af  
c492 3a a6 c4			ld a, (.dmark)  
c495 32 6b ee			ld (debug_mark),a  
c498 3a a7 c4			ld a, (.dmark+1)  
c49b 32 6c ee			ld (debug_mark+1),a  
c49e 3a a8 c4			ld a, (.dmark+2)  
c4a1 32 6d ee			ld (debug_mark+2),a  
c4a4 18 03			jr .pastdmark  
c4a6 ..			.dmark: db "CON"  
c4a9 f1			.pastdmark: pop af  
c4aa			endm  
# End of macro DMARK
c4aa						CALLMONITOR 
c4aa cd 6f ee			call debug_vector  
c4ad				endm  
# End of macro CALLMONITOR
c4ad					endif 
c4ad			 
c4ad			 
c4ad					FORTH_DSP_VALUE 
c4ad cd 27 9d			call macro_forth_dsp_value 
c4b0				endm 
# End of macro FORTH_DSP_VALUE
c4b0 e5					push hl   ; s2 
c4b1			 
c4b1					FORTH_DSP_POP 
c4b1 cd f6 9d			call macro_forth_dsp_pop 
c4b4				endm 
# End of macro FORTH_DSP_POP
c4b4			 
c4b4					FORTH_DSP_VALUE 
c4b4 cd 27 9d			call macro_forth_dsp_value 
c4b7				endm 
# End of macro FORTH_DSP_VALUE
c4b7			 
c4b7 e5					push hl   ; s1 
c4b8			 
c4b8					FORTH_DSP_POP 
c4b8 cd f6 9d			call macro_forth_dsp_pop 
c4bb				endm 
# End of macro FORTH_DSP_POP
c4bb					 
c4bb			 
c4bb					; copy s1 
c4bb			 
c4bb				 
c4bb					; save ptr 
c4bb e1					pop hl  
c4bc e5					push hl 
c4bd 3e 00				ld a, 0 
c4bf cd 44 91				call strlent 
c4c2					;inc hl    ; zer0 
c4c2 06 00				ld b, 0 
c4c4 4d					ld c, l 
c4c5 e1					pop hl		 
c4c6 11 c1 e2				ld de, scratch	 
c4c9					if DEBUG_FORTH_WORDS 
c4c9						DMARK "CO1" 
c4c9 f5				push af  
c4ca 3a de c4			ld a, (.dmark)  
c4cd 32 6b ee			ld (debug_mark),a  
c4d0 3a df c4			ld a, (.dmark+1)  
c4d3 32 6c ee			ld (debug_mark+1),a  
c4d6 3a e0 c4			ld a, (.dmark+2)  
c4d9 32 6d ee			ld (debug_mark+2),a  
c4dc 18 03			jr .pastdmark  
c4de ..			.dmark: db "CO1"  
c4e1 f1			.pastdmark: pop af  
c4e2			endm  
# End of macro DMARK
c4e2						CALLMONITOR 
c4e2 cd 6f ee			call debug_vector  
c4e5				endm  
# End of macro CALLMONITOR
c4e5					endif 
c4e5 ed b0				ldir 
c4e7			 
c4e7 e1					pop hl 
c4e8 e5					push hl 
c4e9 d5					push de 
c4ea			 
c4ea			 
c4ea 3e 00				ld a, 0 
c4ec cd 44 91				call strlent 
c4ef 23					inc hl    ; zer0 
c4f0 23					inc hl 
c4f1 06 00				ld b, 0 
c4f3 4d					ld c, l 
c4f4 d1					pop de 
c4f5 e1					pop hl		 
c4f6					if DEBUG_FORTH_WORDS 
c4f6						DMARK "CO2" 
c4f6 f5				push af  
c4f7 3a 0b c5			ld a, (.dmark)  
c4fa 32 6b ee			ld (debug_mark),a  
c4fd 3a 0c c5			ld a, (.dmark+1)  
c500 32 6c ee			ld (debug_mark+1),a  
c503 3a 0d c5			ld a, (.dmark+2)  
c506 32 6d ee			ld (debug_mark+2),a  
c509 18 03			jr .pastdmark  
c50b ..			.dmark: db "CO2"  
c50e f1			.pastdmark: pop af  
c50f			endm  
# End of macro DMARK
c50f						CALLMONITOR 
c50f cd 6f ee			call debug_vector  
c512				endm  
# End of macro CALLMONITOR
c512					endif 
c512 ed b0				ldir 
c514			 
c514			 
c514			 
c514 21 c1 e2				ld hl, scratch 
c517					if DEBUG_FORTH_WORDS 
c517						DMARK "CO5" 
c517 f5				push af  
c518 3a 2c c5			ld a, (.dmark)  
c51b 32 6b ee			ld (debug_mark),a  
c51e 3a 2d c5			ld a, (.dmark+1)  
c521 32 6c ee			ld (debug_mark+1),a  
c524 3a 2e c5			ld a, (.dmark+2)  
c527 32 6d ee			ld (debug_mark+2),a  
c52a 18 03			jr .pastdmark  
c52c ..			.dmark: db "CO5"  
c52f f1			.pastdmark: pop af  
c530			endm  
# End of macro DMARK
c530						CALLMONITOR 
c530 cd 6f ee			call debug_vector  
c533				endm  
# End of macro CALLMONITOR
c533					endif 
c533			 
c533 cd b5 9b				call forth_push_str 
c536			 
c536			 
c536			 
c536			 
c536				       NEXTW 
c536 c3 f4 9e			jp macro_next 
c539				endm 
# End of macro NEXTW
c539			 
c539			 
c539			.FIND: 
c539				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c539 4b				db WORD_SYS_CORE+55             
c53a f7 c5			dw .LEN            
c53c 05				db 4 + 1 
c53d .. 00			db "FIND",0              
c542				endm 
# End of macro CWHEAD
c542			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c542			 
c542					if DEBUG_FORTH_WORDS_KEY 
c542						DMARK "FND" 
c542 f5				push af  
c543 3a 57 c5			ld a, (.dmark)  
c546 32 6b ee			ld (debug_mark),a  
c549 3a 58 c5			ld a, (.dmark+1)  
c54c 32 6c ee			ld (debug_mark+1),a  
c54f 3a 59 c5			ld a, (.dmark+2)  
c552 32 6d ee			ld (debug_mark+2),a  
c555 18 03			jr .pastdmark  
c557 ..			.dmark: db "FND"  
c55a f1			.pastdmark: pop af  
c55b			endm  
# End of macro DMARK
c55b						CALLMONITOR 
c55b cd 6f ee			call debug_vector  
c55e				endm  
# End of macro CALLMONITOR
c55e					endif 
c55e			 
c55e			; TODO check string type 
c55e					FORTH_DSP_VALUE 
c55e cd 27 9d			call macro_forth_dsp_value 
c561				endm 
# End of macro FORTH_DSP_VALUE
c561			 
c561 e5					push hl    
c562 7e					ld a,(hl)    ; char to find   
c563			; TODO change char to substr 
c563			 
c563 f5					push af 
c564					 
c564			 
c564			 
c564					if DEBUG_FORTH_WORDS 
c564						DMARK "FN1" 
c564 f5				push af  
c565 3a 79 c5			ld a, (.dmark)  
c568 32 6b ee			ld (debug_mark),a  
c56b 3a 7a c5			ld a, (.dmark+1)  
c56e 32 6c ee			ld (debug_mark+1),a  
c571 3a 7b c5			ld a, (.dmark+2)  
c574 32 6d ee			ld (debug_mark+2),a  
c577 18 03			jr .pastdmark  
c579 ..			.dmark: db "FN1"  
c57c f1			.pastdmark: pop af  
c57d			endm  
# End of macro DMARK
c57d						CALLMONITOR 
c57d cd 6f ee			call debug_vector  
c580				endm  
# End of macro CALLMONITOR
c580					endif 
c580			 
c580					FORTH_DSP_POP 
c580 cd f6 9d			call macro_forth_dsp_pop 
c583				endm 
# End of macro FORTH_DSP_POP
c583			 
c583					; string to search 
c583			 
c583					FORTH_DSP_VALUE 
c583 cd 27 9d			call macro_forth_dsp_value 
c586				endm 
# End of macro FORTH_DSP_VALUE
c586			 
c586 d1					pop de  ; d is char to find  
c587			 
c587					if DEBUG_FORTH_WORDS 
c587						DMARK "FN2" 
c587 f5				push af  
c588 3a 9c c5			ld a, (.dmark)  
c58b 32 6b ee			ld (debug_mark),a  
c58e 3a 9d c5			ld a, (.dmark+1)  
c591 32 6c ee			ld (debug_mark+1),a  
c594 3a 9e c5			ld a, (.dmark+2)  
c597 32 6d ee			ld (debug_mark+2),a  
c59a 18 03			jr .pastdmark  
c59c ..			.dmark: db "FN2"  
c59f f1			.pastdmark: pop af  
c5a0			endm  
# End of macro DMARK
c5a0						CALLMONITOR 
c5a0 cd 6f ee			call debug_vector  
c5a3				endm  
# End of macro CALLMONITOR
c5a3					endif 
c5a3					 
c5a3 01 00 00				ld bc, 0 
c5a6 7e			.findchar:      ld a,(hl) 
c5a7 fe 00				cp 0   		 
c5a9 28 27				jr z, .finddone     
c5ab ba					cp d 
c5ac 28 20				jr z, .foundchar 
c5ae 03					inc bc 
c5af 23					inc hl 
c5b0					if DEBUG_FORTH_WORDS 
c5b0						DMARK "FN3" 
c5b0 f5				push af  
c5b1 3a c5 c5			ld a, (.dmark)  
c5b4 32 6b ee			ld (debug_mark),a  
c5b7 3a c6 c5			ld a, (.dmark+1)  
c5ba 32 6c ee			ld (debug_mark+1),a  
c5bd 3a c7 c5			ld a, (.dmark+2)  
c5c0 32 6d ee			ld (debug_mark+2),a  
c5c3 18 03			jr .pastdmark  
c5c5 ..			.dmark: db "FN3"  
c5c8 f1			.pastdmark: pop af  
c5c9			endm  
# End of macro DMARK
c5c9						CALLMONITOR 
c5c9 cd 6f ee			call debug_vector  
c5cc				endm  
# End of macro CALLMONITOR
c5cc					endif 
c5cc 18 d8				jr .findchar 
c5ce			 
c5ce			 
c5ce c5			.foundchar:	push bc 
c5cf e1					pop hl 
c5d0 18 03				jr .findexit 
c5d2			 
c5d2			 
c5d2							 
c5d2			 
c5d2			.finddone:     ; got to end of string with no find 
c5d2 21 00 00				ld hl, 0 
c5d5			.findexit: 
c5d5			 
c5d5					if DEBUG_FORTH_WORDS 
c5d5						DMARK "FNd" 
c5d5 f5				push af  
c5d6 3a ea c5			ld a, (.dmark)  
c5d9 32 6b ee			ld (debug_mark),a  
c5dc 3a eb c5			ld a, (.dmark+1)  
c5df 32 6c ee			ld (debug_mark+1),a  
c5e2 3a ec c5			ld a, (.dmark+2)  
c5e5 32 6d ee			ld (debug_mark+2),a  
c5e8 18 03			jr .pastdmark  
c5ea ..			.dmark: db "FNd"  
c5ed f1			.pastdmark: pop af  
c5ee			endm  
# End of macro DMARK
c5ee						CALLMONITOR 
c5ee cd 6f ee			call debug_vector  
c5f1				endm  
# End of macro CALLMONITOR
c5f1					endif 
c5f1 cd 47 9b			call forth_push_numhl 
c5f4			 
c5f4				       NEXTW 
c5f4 c3 f4 9e			jp macro_next 
c5f7				endm 
# End of macro NEXTW
c5f7			 
c5f7			.LEN: 
c5f7				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c5f7 4c				db WORD_SYS_CORE+56             
c5f8 61 c6			dw .ASC            
c5fa 06				db 5 + 1 
c5fb .. 00			db "COUNT",0              
c601				endm 
# End of macro CWHEAD
c601			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c601			 
c601					if DEBUG_FORTH_WORDS_KEY 
c601						DMARK "CNT" 
c601 f5				push af  
c602 3a 16 c6			ld a, (.dmark)  
c605 32 6b ee			ld (debug_mark),a  
c608 3a 17 c6			ld a, (.dmark+1)  
c60b 32 6c ee			ld (debug_mark+1),a  
c60e 3a 18 c6			ld a, (.dmark+2)  
c611 32 6d ee			ld (debug_mark+2),a  
c614 18 03			jr .pastdmark  
c616 ..			.dmark: db "CNT"  
c619 f1			.pastdmark: pop af  
c61a			endm  
# End of macro DMARK
c61a						CALLMONITOR 
c61a cd 6f ee			call debug_vector  
c61d				endm  
# End of macro CALLMONITOR
c61d					endif 
c61d			; TODO check string type 
c61d					FORTH_DSP_VALUE 
c61d cd 27 9d			call macro_forth_dsp_value 
c620				endm 
# End of macro FORTH_DSP_VALUE
c620			 
c620			 
c620					if DEBUG_FORTH_WORDS 
c620						DMARK "CN?" 
c620 f5				push af  
c621 3a 35 c6			ld a, (.dmark)  
c624 32 6b ee			ld (debug_mark),a  
c627 3a 36 c6			ld a, (.dmark+1)  
c62a 32 6c ee			ld (debug_mark+1),a  
c62d 3a 37 c6			ld a, (.dmark+2)  
c630 32 6d ee			ld (debug_mark+2),a  
c633 18 03			jr .pastdmark  
c635 ..			.dmark: db "CN?"  
c638 f1			.pastdmark: pop af  
c639			endm  
# End of macro DMARK
c639						CALLMONITOR 
c639 cd 6f ee			call debug_vector  
c63c				endm  
# End of macro CALLMONITOR
c63c					endif 
c63c cd 39 91				call strlenz 
c63f					if DEBUG_FORTH_WORDS 
c63f						DMARK "CNl" 
c63f f5				push af  
c640 3a 54 c6			ld a, (.dmark)  
c643 32 6b ee			ld (debug_mark),a  
c646 3a 55 c6			ld a, (.dmark+1)  
c649 32 6c ee			ld (debug_mark+1),a  
c64c 3a 56 c6			ld a, (.dmark+2)  
c64f 32 6d ee			ld (debug_mark+2),a  
c652 18 03			jr .pastdmark  
c654 ..			.dmark: db "CNl"  
c657 f1			.pastdmark: pop af  
c658			endm  
# End of macro DMARK
c658						CALLMONITOR 
c658 cd 6f ee			call debug_vector  
c65b				endm  
# End of macro CALLMONITOR
c65b					endif 
c65b			 
c65b cd 47 9b				call forth_push_numhl 
c65e			 
c65e			 
c65e			 
c65e				       NEXTW 
c65e c3 f4 9e			jp macro_next 
c661				endm 
# End of macro NEXTW
c661			.ASC: 
c661				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c661 4d				db WORD_SYS_CORE+57             
c662 cf c6			dw .CHR            
c664 04				db 3 + 1 
c665 .. 00			db "ASC",0              
c669				endm 
# End of macro CWHEAD
c669			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c669					if DEBUG_FORTH_WORDS_KEY 
c669						DMARK "ASC" 
c669 f5				push af  
c66a 3a 7e c6			ld a, (.dmark)  
c66d 32 6b ee			ld (debug_mark),a  
c670 3a 7f c6			ld a, (.dmark+1)  
c673 32 6c ee			ld (debug_mark+1),a  
c676 3a 80 c6			ld a, (.dmark+2)  
c679 32 6d ee			ld (debug_mark+2),a  
c67c 18 03			jr .pastdmark  
c67e ..			.dmark: db "ASC"  
c681 f1			.pastdmark: pop af  
c682			endm  
# End of macro DMARK
c682						CALLMONITOR 
c682 cd 6f ee			call debug_vector  
c685				endm  
# End of macro CALLMONITOR
c685					endif 
c685					FORTH_DSP_VALUE 
c685 cd 27 9d			call macro_forth_dsp_value 
c688				endm 
# End of macro FORTH_DSP_VALUE
c688					;v5 FORTH_DSP_VALUE 
c688			;		inc hl      ; now at start of numeric as string 
c688			 
c688 e5					push hl 
c689			 
c689					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c689 cd f6 9d			call macro_forth_dsp_pop 
c68c				endm 
# End of macro FORTH_DSP_POP
c68c			 
c68c e1					pop hl 
c68d			 
c68d					if DEBUG_FORTH_WORDS 
c68d						DMARK "AS1" 
c68d f5				push af  
c68e 3a a2 c6			ld a, (.dmark)  
c691 32 6b ee			ld (debug_mark),a  
c694 3a a3 c6			ld a, (.dmark+1)  
c697 32 6c ee			ld (debug_mark+1),a  
c69a 3a a4 c6			ld a, (.dmark+2)  
c69d 32 6d ee			ld (debug_mark+2),a  
c6a0 18 03			jr .pastdmark  
c6a2 ..			.dmark: db "AS1"  
c6a5 f1			.pastdmark: pop af  
c6a6			endm  
# End of macro DMARK
c6a6						CALLMONITOR 
c6a6 cd 6f ee			call debug_vector  
c6a9				endm  
# End of macro CALLMONITOR
c6a9					endif 
c6a9					; push the content of a onto the stack as a value 
c6a9			 
c6a9 7e					ld a,(hl)   ; get char 
c6aa 26 00				ld h,0 
c6ac 6f					ld l,a 
c6ad					if DEBUG_FORTH_WORDS 
c6ad						DMARK "AS2" 
c6ad f5				push af  
c6ae 3a c2 c6			ld a, (.dmark)  
c6b1 32 6b ee			ld (debug_mark),a  
c6b4 3a c3 c6			ld a, (.dmark+1)  
c6b7 32 6c ee			ld (debug_mark+1),a  
c6ba 3a c4 c6			ld a, (.dmark+2)  
c6bd 32 6d ee			ld (debug_mark+2),a  
c6c0 18 03			jr .pastdmark  
c6c2 ..			.dmark: db "AS2"  
c6c5 f1			.pastdmark: pop af  
c6c6			endm  
# End of macro DMARK
c6c6						CALLMONITOR 
c6c6 cd 6f ee			call debug_vector  
c6c9				endm  
# End of macro CALLMONITOR
c6c9					endif 
c6c9 cd 47 9b				call forth_push_numhl 
c6cc			 
c6cc				       NEXTW 
c6cc c3 f4 9e			jp macro_next 
c6cf				endm 
# End of macro NEXTW
c6cf			 
c6cf			.CHR: 
c6cf				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c6cf 4d				db WORD_SYS_CORE+57             
c6d0 0b c7			dw .ENDSTR            
c6d2 04				db 3 + 1 
c6d3 .. 00			db "CHR",0              
c6d7				endm 
# End of macro CWHEAD
c6d7			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c6d7					if DEBUG_FORTH_WORDS_KEY 
c6d7						DMARK "CHR" 
c6d7 f5				push af  
c6d8 3a ec c6			ld a, (.dmark)  
c6db 32 6b ee			ld (debug_mark),a  
c6de 3a ed c6			ld a, (.dmark+1)  
c6e1 32 6c ee			ld (debug_mark+1),a  
c6e4 3a ee c6			ld a, (.dmark+2)  
c6e7 32 6d ee			ld (debug_mark+2),a  
c6ea 18 03			jr .pastdmark  
c6ec ..			.dmark: db "CHR"  
c6ef f1			.pastdmark: pop af  
c6f0			endm  
# End of macro DMARK
c6f0						CALLMONITOR 
c6f0 cd 6f ee			call debug_vector  
c6f3				endm  
# End of macro CALLMONITOR
c6f3					endif 
c6f3					FORTH_DSP_VALUEHL 
c6f3 cd 3e 9d			call macro_dsp_valuehl 
c6f6				endm 
# End of macro FORTH_DSP_VALUEHL
c6f6			 
c6f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c6f6 cd f6 9d			call macro_forth_dsp_pop 
c6f9				endm 
# End of macro FORTH_DSP_POP
c6f9			 
c6f9					; save asci byte as a zero term string and push string 
c6f9			 
c6f9 7d					ld a,l 
c6fa 32 c1 e2				ld (scratch), a 
c6fd			 
c6fd 3e 00				ld a, 0 
c6ff 32 c2 e2				ld (scratch+1), a 
c702			 
c702 21 c1 e2				ld hl, scratch 
c705 cd b5 9b				call forth_push_str 
c708			 
c708			 
c708				       NEXTW 
c708 c3 f4 9e			jp macro_next 
c70b				endm 
# End of macro NEXTW
c70b			 
c70b			 
c70b			 
c70b			 
c70b			.ENDSTR: 
c70b			; eof 
c70b			 
# End of file forth_words_str.asm
c70b			include "forth_words_key.asm" 
c70b			 
c70b			; | ## Keyboard Words 
c70b			 
c70b			.KEY: 
c70b				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c70b 3e				db WORD_SYS_CORE+42             
c70c 3b c7			dw .WAITK            
c70e 04				db 3 + 1 
c70f .. 00			db "KEY",0              
c713				endm 
# End of macro CWHEAD
c713			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c713			 
c713					if DEBUG_FORTH_WORDS_KEY 
c713						DMARK "KEY" 
c713 f5				push af  
c714 3a 28 c7			ld a, (.dmark)  
c717 32 6b ee			ld (debug_mark),a  
c71a 3a 29 c7			ld a, (.dmark+1)  
c71d 32 6c ee			ld (debug_mark+1),a  
c720 3a 2a c7			ld a, (.dmark+2)  
c723 32 6d ee			ld (debug_mark+2),a  
c726 18 03			jr .pastdmark  
c728 ..			.dmark: db "KEY"  
c72b f1			.pastdmark: pop af  
c72c			endm  
# End of macro DMARK
c72c						CALLMONITOR 
c72c cd 6f ee			call debug_vector  
c72f				endm  
# End of macro CALLMONITOR
c72f					endif 
c72f			; TODO currently waits 
c72f cd d5 e4				call cin 
c732					;call cin_wait 
c732 6f					ld l, a 
c733 26 00				ld h, 0 
c735 cd 47 9b				call forth_push_numhl 
c738					NEXTW 
c738 c3 f4 9e			jp macro_next 
c73b				endm 
# End of macro NEXTW
c73b			.WAITK: 
c73b				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c73b 3f				db WORD_SYS_CORE+43             
c73c 6d c7			dw .ACCEPT            
c73e 06				db 5 + 1 
c73f .. 00			db "WAITK",0              
c745				endm 
# End of macro CWHEAD
c745			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c745					if DEBUG_FORTH_WORDS_KEY 
c745						DMARK "WAI" 
c745 f5				push af  
c746 3a 5a c7			ld a, (.dmark)  
c749 32 6b ee			ld (debug_mark),a  
c74c 3a 5b c7			ld a, (.dmark+1)  
c74f 32 6c ee			ld (debug_mark+1),a  
c752 3a 5c c7			ld a, (.dmark+2)  
c755 32 6d ee			ld (debug_mark+2),a  
c758 18 03			jr .pastdmark  
c75a ..			.dmark: db "WAI"  
c75d f1			.pastdmark: pop af  
c75e			endm  
# End of macro DMARK
c75e						CALLMONITOR 
c75e cd 6f ee			call debug_vector  
c761				endm  
# End of macro CALLMONITOR
c761					endif 
c761 cd cf e4				call cin_wait 
c764 6f					ld l, a 
c765 26 00				ld h, 0 
c767 cd 47 9b				call forth_push_numhl 
c76a					NEXTW 
c76a c3 f4 9e			jp macro_next 
c76d				endm 
# End of macro NEXTW
c76d			.ACCEPT: 
c76d				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c76d 40				db WORD_SYS_CORE+44             
c76e cb c7			dw .EDIT            
c770 07				db 6 + 1 
c771 .. 00			db "ACCEPT",0              
c778				endm 
# End of macro CWHEAD
c778			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c778					; TODO crashes on push 
c778					if DEBUG_FORTH_WORDS_KEY 
c778						DMARK "ACC" 
c778 f5				push af  
c779 3a 8d c7			ld a, (.dmark)  
c77c 32 6b ee			ld (debug_mark),a  
c77f 3a 8e c7			ld a, (.dmark+1)  
c782 32 6c ee			ld (debug_mark+1),a  
c785 3a 8f c7			ld a, (.dmark+2)  
c788 32 6d ee			ld (debug_mark+2),a  
c78b 18 03			jr .pastdmark  
c78d ..			.dmark: db "ACC"  
c790 f1			.pastdmark: pop af  
c791			endm  
# End of macro DMARK
c791						CALLMONITOR 
c791 cd 6f ee			call debug_vector  
c794				endm  
# End of macro CALLMONITOR
c794					endif 
c794 21 bf e4				ld hl, os_input 
c797 3e 00				ld a, 0 
c799 77					ld (hl),a 
c79a 3a 5e ea				ld a,(f_cursor_ptr) 
c79d 16 64				ld d, 100 
c79f 0e 00				ld c, 0 
c7a1 1e 28				ld e, 40 
c7a3 cd 08 8d				call input_str 
c7a6					; TODO perhaps do a type check and wrap in quotes if not a number 
c7a6 21 bf e4				ld hl, os_input 
c7a9					if DEBUG_FORTH_WORDS 
c7a9						DMARK "AC1" 
c7a9 f5				push af  
c7aa 3a be c7			ld a, (.dmark)  
c7ad 32 6b ee			ld (debug_mark),a  
c7b0 3a bf c7			ld a, (.dmark+1)  
c7b3 32 6c ee			ld (debug_mark+1),a  
c7b6 3a c0 c7			ld a, (.dmark+2)  
c7b9 32 6d ee			ld (debug_mark+2),a  
c7bc 18 03			jr .pastdmark  
c7be ..			.dmark: db "AC1"  
c7c1 f1			.pastdmark: pop af  
c7c2			endm  
# End of macro DMARK
c7c2						CALLMONITOR 
c7c2 cd 6f ee			call debug_vector  
c7c5				endm  
# End of macro CALLMONITOR
c7c5					endif 
c7c5 cd b5 9b				call forth_push_str 
c7c8					NEXTW 
c7c8 c3 f4 9e			jp macro_next 
c7cb				endm 
# End of macro NEXTW
c7cb			 
c7cb			.EDIT: 
c7cb				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c7cb 40				db WORD_SYS_CORE+44             
c7cc 6d c8			dw .DEDIT            
c7ce 05				db 4 + 1 
c7cf .. 00			db "EDIT",0              
c7d4				endm 
# End of macro CWHEAD
c7d4			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c7d4			 
c7d4					; TODO does not copy from stack 
c7d4					if DEBUG_FORTH_WORDS_KEY 
c7d4						DMARK "EDT" 
c7d4 f5				push af  
c7d5 3a e9 c7			ld a, (.dmark)  
c7d8 32 6b ee			ld (debug_mark),a  
c7db 3a ea c7			ld a, (.dmark+1)  
c7de 32 6c ee			ld (debug_mark+1),a  
c7e1 3a eb c7			ld a, (.dmark+2)  
c7e4 32 6d ee			ld (debug_mark+2),a  
c7e7 18 03			jr .pastdmark  
c7e9 ..			.dmark: db "EDT"  
c7ec f1			.pastdmark: pop af  
c7ed			endm  
# End of macro DMARK
c7ed						CALLMONITOR 
c7ed cd 6f ee			call debug_vector  
c7f0				endm  
# End of macro CALLMONITOR
c7f0					endif 
c7f0			 
c7f0					;FORTH_DSP 
c7f0					FORTH_DSP_VALUEHL 
c7f0 cd 3e 9d			call macro_dsp_valuehl 
c7f3				endm 
# End of macro FORTH_DSP_VALUEHL
c7f3			;		inc hl    ; TODO do type check 
c7f3			 
c7f3			;		call get_word_hl 
c7f3 e5					push hl 
c7f4					if DEBUG_FORTH_WORDS 
c7f4						DMARK "EDp" 
c7f4 f5				push af  
c7f5 3a 09 c8			ld a, (.dmark)  
c7f8 32 6b ee			ld (debug_mark),a  
c7fb 3a 0a c8			ld a, (.dmark+1)  
c7fe 32 6c ee			ld (debug_mark+1),a  
c801 3a 0b c8			ld a, (.dmark+2)  
c804 32 6d ee			ld (debug_mark+2),a  
c807 18 03			jr .pastdmark  
c809 ..			.dmark: db "EDp"  
c80c f1			.pastdmark: pop af  
c80d			endm  
# End of macro DMARK
c80d						CALLMONITOR 
c80d cd 6f ee			call debug_vector  
c810				endm  
# End of macro CALLMONITOR
c810					endif 
c810				;	ld a, 0 
c810 cd 39 91				call strlenz 
c813 23					inc hl 
c814			 
c814 06 00				ld b, 0 
c816 4d					ld c, l 
c817			 
c817 e1					pop hl 
c818 11 bf e4				ld de, os_input 
c81b					if DEBUG_FORTH_WORDS_KEY 
c81b						DMARK "EDc" 
c81b f5				push af  
c81c 3a 30 c8			ld a, (.dmark)  
c81f 32 6b ee			ld (debug_mark),a  
c822 3a 31 c8			ld a, (.dmark+1)  
c825 32 6c ee			ld (debug_mark+1),a  
c828 3a 32 c8			ld a, (.dmark+2)  
c82b 32 6d ee			ld (debug_mark+2),a  
c82e 18 03			jr .pastdmark  
c830 ..			.dmark: db "EDc"  
c833 f1			.pastdmark: pop af  
c834			endm  
# End of macro DMARK
c834						CALLMONITOR 
c834 cd 6f ee			call debug_vector  
c837				endm  
# End of macro CALLMONITOR
c837					endif 
c837 ed b0				ldir 
c839			 
c839			 
c839 21 bf e4				ld hl, os_input 
c83c					;ld a, 0 
c83c					;ld (hl),a 
c83c 3a 5e ea				ld a,(f_cursor_ptr) 
c83f 16 64				ld d, 100 
c841 0e 00				ld c, 0 
c843 1e 28				ld e, 40 
c845 cd 08 8d				call input_str 
c848					; TODO perhaps do a type check and wrap in quotes if not a number 
c848 21 bf e4				ld hl, os_input 
c84b					if DEBUG_FORTH_WORDS 
c84b						DMARK "ED1" 
c84b f5				push af  
c84c 3a 60 c8			ld a, (.dmark)  
c84f 32 6b ee			ld (debug_mark),a  
c852 3a 61 c8			ld a, (.dmark+1)  
c855 32 6c ee			ld (debug_mark+1),a  
c858 3a 62 c8			ld a, (.dmark+2)  
c85b 32 6d ee			ld (debug_mark+2),a  
c85e 18 03			jr .pastdmark  
c860 ..			.dmark: db "ED1"  
c863 f1			.pastdmark: pop af  
c864			endm  
# End of macro DMARK
c864						CALLMONITOR 
c864 cd 6f ee			call debug_vector  
c867				endm  
# End of macro CALLMONITOR
c867					endif 
c867 cd b5 9b				call forth_push_str 
c86a					NEXTW 
c86a c3 f4 9e			jp macro_next 
c86d				endm 
# End of macro NEXTW
c86d			 
c86d			.DEDIT: 
c86d				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c86d 40				db WORD_SYS_CORE+44             
c86e cf c8			dw .ENDKEY            
c870 06				db 5 + 1 
c871 .. 00			db "DEDIT",0              
c877				endm 
# End of macro CWHEAD
c877			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c877			 
c877					; TODO does not copy from stack 
c877					if DEBUG_FORTH_WORDS_KEY 
c877						DMARK "DED" 
c877 f5				push af  
c878 3a 8c c8			ld a, (.dmark)  
c87b 32 6b ee			ld (debug_mark),a  
c87e 3a 8d c8			ld a, (.dmark+1)  
c881 32 6c ee			ld (debug_mark+1),a  
c884 3a 8e c8			ld a, (.dmark+2)  
c887 32 6d ee			ld (debug_mark+2),a  
c88a 18 03			jr .pastdmark  
c88c ..			.dmark: db "DED"  
c88f f1			.pastdmark: pop af  
c890			endm  
# End of macro DMARK
c890						CALLMONITOR 
c890 cd 6f ee			call debug_vector  
c893				endm  
# End of macro CALLMONITOR
c893					endif 
c893			 
c893					;FORTH_DSP 
c893					FORTH_DSP_VALUEHL 
c893 cd 3e 9d			call macro_dsp_valuehl 
c896				endm 
# End of macro FORTH_DSP_VALUEHL
c896			;		inc hl    ; TODO do type check 
c896			 
c896			;		call get_word_hl 
c896 e5					push hl 
c897 e5					push hl 
c898					FORTH_DSP_POP 
c898 cd f6 9d			call macro_forth_dsp_pop 
c89b				endm 
# End of macro FORTH_DSP_POP
c89b e1					pop hl 
c89c					if DEBUG_FORTH_WORDS 
c89c						DMARK "EDp" 
c89c f5				push af  
c89d 3a b1 c8			ld a, (.dmark)  
c8a0 32 6b ee			ld (debug_mark),a  
c8a3 3a b2 c8			ld a, (.dmark+1)  
c8a6 32 6c ee			ld (debug_mark+1),a  
c8a9 3a b3 c8			ld a, (.dmark+2)  
c8ac 32 6d ee			ld (debug_mark+2),a  
c8af 18 03			jr .pastdmark  
c8b1 ..			.dmark: db "EDp"  
c8b4 f1			.pastdmark: pop af  
c8b5			endm  
# End of macro DMARK
c8b5						CALLMONITOR 
c8b5 cd 6f ee			call debug_vector  
c8b8				endm  
# End of macro CALLMONITOR
c8b8					endif 
c8b8				;	ld a, 0 
c8b8 cd 39 91				call strlenz 
c8bb 23					inc hl 
c8bc			 
c8bc 06 00				ld b, 0 
c8be 4d					ld c, l 
c8bf			 
c8bf e1					pop hl 
c8c0			 
c8c0					;ld a, 0 
c8c0					;ld (hl),a 
c8c0 3a 5e ea				ld a,(f_cursor_ptr) 
c8c3 16 64				ld d, 100 
c8c5 0e 00				ld c, 0 
c8c7 1e 28				ld e, 40 
c8c9 cd 08 8d				call input_str 
c8cc					; TODO perhaps do a type check and wrap in quotes if not a number 
c8cc					NEXTW 
c8cc c3 f4 9e			jp macro_next 
c8cf				endm 
# End of macro NEXTW
c8cf			 
c8cf			 
c8cf			.ENDKEY: 
c8cf			; eof 
c8cf			 
# End of file forth_words_key.asm
c8cf			include "forth_words_const.asm" 
c8cf			 
c8cf			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c8cf			 
c8cf			 
c8cf			.SPITIME: 
c8cf				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c8cf 77				db WORD_SYS_CORE+99             
c8d0 e4 c8			dw .VA            
c8d2 08				db 7 + 1 
c8d3 .. 00			db "SPITIME",0              
c8db				endm 
# End of macro CWHEAD
c8db			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
c8db			; 
c8db			; | | If using BANK devices then leave as is. 
c8db			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
c8db			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
c8db			 
c8db 21 64 ea				ld hl, spi_clktime  
c8de cd 47 9b				call forth_push_numhl 
c8e1			 
c8e1					NEXTW 
c8e1 c3 f4 9e			jp macro_next 
c8e4				endm 
# End of macro NEXTW
c8e4			 
c8e4			 
c8e4			.VA: 
c8e4				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c8e4 77				db WORD_SYS_CORE+99             
c8e5 f4 c8			dw .SYMBOL            
c8e7 03				db 2 + 1 
c8e8 .. 00			db "VA",0              
c8eb				endm 
# End of macro CWHEAD
c8eb			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
c8eb 21 28 ea				ld hl, cli_var_array 
c8ee cd 47 9b				call forth_push_numhl 
c8f1			 
c8f1					NEXTW 
c8f1 c3 f4 9e			jp macro_next 
c8f4				endm 
# End of macro NEXTW
c8f4			 
c8f4			.SYMBOL: 
c8f4				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c8f4 77				db WORD_SYS_CORE+99             
c8f5 fe c9			dw .ENDCONST            
c8f7 07				db 6 + 1 
c8f8 .. 00			db "SYMBOL",0              
c8ff				endm 
# End of macro CWHEAD
c8ff			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c8ff			; | 
c8ff			; | | The value is the number reference and the final address is pushed to stack 
c8ff			 
c8ff			; | | ``` 
c8ff			; | | dw sym_table 
c8ff			; | | dw nmi_vector 
c8ff			; | | dw cli_autodisplay 
c8ff			; | | dw cli_data_sp 
c8ff			; | | dw cli_data_stack 
c8ff			; | | dw cli_loop_sp 
c8ff			; | | dw cli_loop_stack 
c8ff			; | | dw cli_var_array 
c8ff			; | | dw cursor_col 
c8ff			; | | dw cursor_ptr 
c8ff			; | | ; 10 
c8ff			; | | dw cursor_row 
c8ff			; | | dw debug_mark 
c8ff			; | | dw display_fb0 
c8ff			; | | dw display_fb1 
c8ff			; | | dw display_fb2 
c8ff			; | | dw display_fb3 
c8ff			; | | dw display_fb_active 
c8ff			; | | dw execscratch 
c8ff			; | | dw f_cursor_ptr 
c8ff			; | | dw hardware_word 
c8ff			; | | ;20 
c8ff			; | | dw input_at_cursor 
c8ff			; | | dw input_at_pos 
c8ff			; | | dw input_cur_flash 
c8ff			; | | dw input_cur_onoff 
c8ff			; | | dw input_cursor 
c8ff			; | | dw input_display_size 
c8ff			; | | dw input_len 
c8ff			; | | dw input_ptr 
c8ff			; | | dw input_size 
c8ff			; | | dw input_start 
c8ff			; | | ; 30 
c8ff			; | | dw input_str 
c8ff			; | | dw input_under_cursor 
c8ff			; | | dw os_cli_cmd 
c8ff			; | | dw os_cur_ptr 
c8ff			; | | dw os_current_i 
c8ff			; | | dw os_input 
c8ff			; | | dw os_last_cmd 
c8ff			; | | dw os_last_new_uword 
c8ff			; | | dw debug_vector 
c8ff			; | | dw os_view_hl 
c8ff			; | | ;40 
c8ff			; | | dw os_word_scratch 
c8ff			; | | dw portbctl 
c8ff			; | | dw portbdata 
c8ff			; | | dw spi_cartdev 
c8ff			; | | dw spi_cartdev2 
c8ff			; | | dw spi_clktime 
c8ff			; | | dw spi_device 
c8ff			; | | dw spi_device_id 
c8ff			; | | dw spi_portbyte 
c8ff			; | | dw stackstore 
c8ff			; | | ; 50 
c8ff			; | | if STORAGE_SE 
c8ff			; | | dw storage_actl 
c8ff			; | | dw storage_adata 
c8ff			; | | else 
c8ff			; | | dw 0 
c8ff			; | | dw 0 
c8ff			; | | endif 
c8ff			; | | dw storage_append 
c8ff			; | | if STORAGE_SE 
c8ff			; | | dw storage_bctl 
c8ff			; | | else 
c8ff			; | | dw 0 
c8ff			; | | endif 
c8ff			; | | dw store_bank_active 
c8ff			; | | dw store_filecache 
c8ff			; | | dw store_longread 
c8ff			; | | dw store_openaddr 
c8ff			; | | dw store_openext 
c8ff			; | | dw store_openmaxext 
c8ff			; | | ; 60 
c8ff			; | | dw store_page 
c8ff			; | | dw store_readbuf 
c8ff			; | | dw store_readcont 
c8ff			; | | dw store_readptr 
c8ff			; | | dw store_tmpext 
c8ff			; | | dw store_tmpid 
c8ff			; | | dw store_tmppageid 
c8ff			; | | dw malloc 
c8ff			; | | dw free 
c8ff			; | | dw cin 
c8ff			; | | ; 70 
c8ff			; | | dw cin_wait 
c8ff			; | | dw forth_push_numhl 
c8ff			; | | dw forth_push_str 
c8ff			; | | ``` 
c8ff			 
c8ff					if DEBUG_FORTH_WORDS_KEY 
c8ff						DMARK "SYM" 
c8ff f5				push af  
c900 3a 14 c9			ld a, (.dmark)  
c903 32 6b ee			ld (debug_mark),a  
c906 3a 15 c9			ld a, (.dmark+1)  
c909 32 6c ee			ld (debug_mark+1),a  
c90c 3a 16 c9			ld a, (.dmark+2)  
c90f 32 6d ee			ld (debug_mark+2),a  
c912 18 03			jr .pastdmark  
c914 ..			.dmark: db "SYM"  
c917 f1			.pastdmark: pop af  
c918			endm  
# End of macro DMARK
c918						CALLMONITOR 
c918 cd 6f ee			call debug_vector  
c91b				endm  
# End of macro CALLMONITOR
c91b					endif 
c91b			 
c91b					FORTH_DSP_VALUEHL 
c91b cd 3e 9d			call macro_dsp_valuehl 
c91e				endm 
# End of macro FORTH_DSP_VALUEHL
c91e			 
c91e 7d					ld a, l     
c91f			 
c91f			 
c91f					if DEBUG_FORTH_WORDS 
c91f						DMARK "SY1" 
c91f f5				push af  
c920 3a 34 c9			ld a, (.dmark)  
c923 32 6b ee			ld (debug_mark),a  
c926 3a 35 c9			ld a, (.dmark+1)  
c929 32 6c ee			ld (debug_mark+1),a  
c92c 3a 36 c9			ld a, (.dmark+2)  
c92f 32 6d ee			ld (debug_mark+2),a  
c932 18 03			jr .pastdmark  
c934 ..			.dmark: db "SY1"  
c937 f1			.pastdmark: pop af  
c938			endm  
# End of macro DMARK
c938						CALLMONITOR 
c938 cd 6f ee			call debug_vector  
c93b				endm  
# End of macro CALLMONITOR
c93b					endif 
c93b					 
c93b f5					push af	 
c93c					FORTH_DSP_POP 
c93c cd f6 9d			call macro_forth_dsp_pop 
c93f				endm 
# End of macro FORTH_DSP_POP
c93f f1					pop af 
c940			 
c940 cb 27				sla a  
c942				 
c942					 
c942					if DEBUG_FORTH_WORDS 
c942						DMARK "SY" 
c942 f5				push af  
c943 3a 57 c9			ld a, (.dmark)  
c946 32 6b ee			ld (debug_mark),a  
c949 3a 58 c9			ld a, (.dmark+1)  
c94c 32 6c ee			ld (debug_mark+1),a  
c94f 3a 59 c9			ld a, (.dmark+2)  
c952 32 6d ee			ld (debug_mark+2),a  
c955 18 02			jr .pastdmark  
c957 ..			.dmark: db "SY"  
c959 f1			.pastdmark: pop af  
c95a			endm  
# End of macro DMARK
c95a						CALLMONITOR 
c95a cd 6f ee			call debug_vector  
c95d				endm  
# End of macro CALLMONITOR
c95d					endif 
c95d			 
c95d 21 6c c9				ld hl, sym_table 
c960 cd db 8c				call addatohl 
c963 cd 76 9e				call loadwordinhl 
c966 cd 47 9b				call forth_push_numhl 
c969			 
c969			 
c969				       NEXTW 
c969 c3 f4 9e			jp macro_next 
c96c				endm 
# End of macro NEXTW
c96c			 
c96c			sym_table: 
c96c			 
c96c			; 0 
c96c 6c c9		dw sym_table 
c96e 72 ee		dw nmi_vector 
c970 3c ea		dw cli_autodisplay 
c972 ee e9		dw cli_data_sp 
c974 28 e8		dw cli_data_stack 
c976 f0 e9		dw cli_loop_sp 
c978 2a e9		dw cli_loop_stack 
c97a 28 ea		dw cli_var_array 
c97c c5 eb		dw cursor_col 
c97e c3 eb		dw cursor_ptr 
c980			; 10 
c980 c4 eb		dw cursor_row 
c982 6b ee		dw debug_mark 
c984 b1 ed		dw display_fb0 
c986 10 ed		dw display_fb1 
c988 ce eb		dw display_fb2 
c98a 6f ec		dw display_fb3 
c98c cc eb		dw display_fb_active 
c98e c0 e3		dw execscratch 
c990 5e ea		dw f_cursor_ptr 
c992 75 ee		dw hardware_word 
c994			;20 
c994 62 ee		dw input_at_cursor 
c996 64 ee		dw input_at_pos 
c998 60 ee		dw input_cur_flash 
c99a 5f ee		dw input_cur_onoff 
c99c 55 ee		dw input_cursor 
c99e 65 ee		dw input_display_size 
c9a0 5a ee		dw input_len 
c9a2 69 ee		dw input_ptr 
c9a4 66 ee		dw input_size 
c9a6 67 ee		dw input_start 
c9a8			; 30 
c9a8 08 8d		dw input_str 
c9aa 63 ee		dw input_under_cursor 
c9ac e8 e5		dw os_cli_cmd 
c9ae e4 e5		dw os_cur_ptr 
c9b0 e6 e5		dw os_current_i 
c9b2 bf e4		dw os_input 
c9b4 e7 e6		dw os_last_cmd 
c9b6 be e5		dw os_last_new_uword 
c9b8 6f ee		dw debug_vector 
c9ba a3 e2		dw os_view_hl 
c9bc			;40 
c9bc c6 e5		dw os_word_scratch 
c9be c3 00		dw portbctl 
c9c0 c1 00		dw portbdata 
c9c2 63 ea		dw spi_cartdev 
c9c4 62 ea		dw spi_cartdev2 
c9c6 64 ea		dw spi_clktime 
c9c8 60 ea		dw spi_device 
c9ca 5f ea		dw spi_device_id 
c9cc 61 ea		dw spi_portbyte 
c9ce a7 eb		dw stackstore 
c9d0			; 50 
c9d0			if STORAGE_SE 
c9d0			dw storage_actl 
c9d0			dw storage_adata 
c9d0			else 
c9d0 00 00		dw 0 
c9d2 00 00		dw 0 
c9d4			endif 
c9d4 68 88		dw storage_append 
c9d6			if STORAGE_SE 
c9d6			dw storage_bctl 
c9d6			else 
c9d6 00 00		dw 0 
c9d8			endif 
c9d8 93 eb		dw store_bank_active 
c9da 67 ea		dw store_filecache 
c9dc 75 ea		dw store_longread 
c9de 6b ea		dw store_openaddr 
c9e0 6a ea		dw store_openext 
c9e2 69 ea		dw store_openmaxext 
c9e4			; 60 
c9e4 7a ea		dw store_page 
c9e6 76 ea		dw store_readbuf 
c9e8 6d ea		dw store_readcont 
c9ea 78 ea		dw store_readptr 
c9ec 6d ea		dw store_tmpext 
c9ee 6e ea		dw store_tmpid 
c9f0 65 ea		dw store_tmppageid 
c9f2 ae 91		dw malloc 
c9f4 78 92		dw free 
c9f6 d5 e4		dw cin 
c9f8			; 70 
c9f8 cf e4		dw cin_wait 
c9fa 47 9b		dw forth_push_numhl 
c9fc b5 9b		dw forth_push_str 
c9fe			 
c9fe			 
c9fe			.ENDCONST: 
c9fe			 
c9fe			; eof 
c9fe			 
c9fe			 
# End of file forth_words_const.asm
c9fe			 
c9fe			if STORAGE_SE 
c9fe			   	include "forth_words_storage.asm" 
c9fe			endif 
c9fe				include "forth_words_device.asm" 
c9fe			; Device related words 
c9fe			 
c9fe			; | ## Device Words 
c9fe			 
c9fe			;if SOUND_ENABLE 
c9fe			;.NOTE: 
c9fe			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c9fe			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
c9fe			;		if DEBUG_FORTH_WORDS_KEY 
c9fe			;			DMARK "NTE" 
c9fe			;			CALLMONITOR 
c9fe			;		endif 
c9fe			; 
c9fe			;	 
c9fe			; 
c9fe			;		NEXTW 
c9fe			;.AFTERSOUND: 
c9fe			;endif 
c9fe			 
c9fe			 
c9fe			USE_GPIO: equ 0 
c9fe			 
c9fe			if USE_GPIO 
c9fe			.GP1: 
c9fe				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c9fe			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
c9fe					NEXTW 
c9fe			.GP2: 
c9fe				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c9fe			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
c9fe			 
c9fe					NEXTW 
c9fe			 
c9fe			.GP3: 
c9fe				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c9fe			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
c9fe			 
c9fe					NEXTW 
c9fe			 
c9fe			.GP4: 
c9fe				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c9fe			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
c9fe			 
c9fe					NEXTW 
c9fe			.SIN: 
c9fe			 
c9fe			 
c9fe			endif 
c9fe			 
c9fe			 
c9fe				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c9fe 33				db WORD_SYS_CORE+31             
c9ff 33 ca			dw .SOUT            
ca01 03				db 2 + 1 
ca02 .. 00			db "IN",0              
ca05				endm 
# End of macro CWHEAD
ca05			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
ca05					if DEBUG_FORTH_WORDS_KEY 
ca05						DMARK "IN." 
ca05 f5				push af  
ca06 3a 1a ca			ld a, (.dmark)  
ca09 32 6b ee			ld (debug_mark),a  
ca0c 3a 1b ca			ld a, (.dmark+1)  
ca0f 32 6c ee			ld (debug_mark+1),a  
ca12 3a 1c ca			ld a, (.dmark+2)  
ca15 32 6d ee			ld (debug_mark+2),a  
ca18 18 03			jr .pastdmark  
ca1a ..			.dmark: db "IN."  
ca1d f1			.pastdmark: pop af  
ca1e			endm  
# End of macro DMARK
ca1e						CALLMONITOR 
ca1e cd 6f ee			call debug_vector  
ca21				endm  
# End of macro CALLMONITOR
ca21					endif 
ca21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca21 cd 3e 9d			call macro_dsp_valuehl 
ca24				endm 
# End of macro FORTH_DSP_VALUEHL
ca24			 
ca24 e5					push hl 
ca25			 
ca25					; destroy value TOS 
ca25			 
ca25					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca25 cd f6 9d			call macro_forth_dsp_pop 
ca28				endm 
# End of macro FORTH_DSP_POP
ca28			 
ca28					; one value on hl get other one back 
ca28			 
ca28 c1					pop bc 
ca29			 
ca29					; do the sub 
ca29			;		ex de, hl 
ca29			 
ca29 ed 68				in l,(c) 
ca2b			 
ca2b					; save it 
ca2b			 
ca2b 26 00				ld h,0 
ca2d			 
ca2d					; TODO push value back onto stack for another op etc 
ca2d			 
ca2d cd 47 9b				call forth_push_numhl 
ca30					NEXTW 
ca30 c3 f4 9e			jp macro_next 
ca33				endm 
# End of macro NEXTW
ca33			.SOUT: 
ca33				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
ca33 34				db WORD_SYS_CORE+32             
ca34 86 ca			dw .SPIO            
ca36 04				db 3 + 1 
ca37 .. 00			db "OUT",0              
ca3b				endm 
# End of macro CWHEAD
ca3b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
ca3b					if DEBUG_FORTH_WORDS_KEY 
ca3b						DMARK "OUT" 
ca3b f5				push af  
ca3c 3a 50 ca			ld a, (.dmark)  
ca3f 32 6b ee			ld (debug_mark),a  
ca42 3a 51 ca			ld a, (.dmark+1)  
ca45 32 6c ee			ld (debug_mark+1),a  
ca48 3a 52 ca			ld a, (.dmark+2)  
ca4b 32 6d ee			ld (debug_mark+2),a  
ca4e 18 03			jr .pastdmark  
ca50 ..			.dmark: db "OUT"  
ca53 f1			.pastdmark: pop af  
ca54			endm  
# End of macro DMARK
ca54						CALLMONITOR 
ca54 cd 6f ee			call debug_vector  
ca57				endm  
# End of macro CALLMONITOR
ca57					endif 
ca57			 
ca57					; get port 
ca57			 
ca57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca57 cd 3e 9d			call macro_dsp_valuehl 
ca5a				endm 
# End of macro FORTH_DSP_VALUEHL
ca5a			 
ca5a e5					push hl 
ca5b			 
ca5b					; destroy value TOS 
ca5b			 
ca5b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca5b cd f6 9d			call macro_forth_dsp_pop 
ca5e				endm 
# End of macro FORTH_DSP_POP
ca5e			 
ca5e					; get byte to send 
ca5e			 
ca5e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca5e cd 3e 9d			call macro_dsp_valuehl 
ca61				endm 
# End of macro FORTH_DSP_VALUEHL
ca61			 
ca61			;		push hl 
ca61			 
ca61					; destroy value TOS 
ca61			 
ca61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca61 cd f6 9d			call macro_forth_dsp_pop 
ca64				endm 
# End of macro FORTH_DSP_POP
ca64			 
ca64					; one value on hl get other one back 
ca64			 
ca64			;		pop hl 
ca64			 
ca64 c1					pop bc 
ca65			 
ca65					if DEBUG_FORTH_WORDS 
ca65						DMARK "OUT" 
ca65 f5				push af  
ca66 3a 7a ca			ld a, (.dmark)  
ca69 32 6b ee			ld (debug_mark),a  
ca6c 3a 7b ca			ld a, (.dmark+1)  
ca6f 32 6c ee			ld (debug_mark+1),a  
ca72 3a 7c ca			ld a, (.dmark+2)  
ca75 32 6d ee			ld (debug_mark+2),a  
ca78 18 03			jr .pastdmark  
ca7a ..			.dmark: db "OUT"  
ca7d f1			.pastdmark: pop af  
ca7e			endm  
# End of macro DMARK
ca7e						CALLMONITOR 
ca7e cd 6f ee			call debug_vector  
ca81				endm  
# End of macro CALLMONITOR
ca81					endif 
ca81			 
ca81 ed 69				out (c), l 
ca83			 
ca83					NEXTW 
ca83 c3 f4 9e			jp macro_next 
ca86				endm 
# End of macro NEXTW
ca86			 
ca86			 
ca86			.SPIO: 
ca86			 
ca86			if STORAGE_SE 
ca86				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
ca86			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
ca86			 
ca86					call spi_ce_low 
ca86			    NEXTW 
ca86			 
ca86			.SPICEH: 
ca86				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
ca86			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
ca86			 
ca86					call spi_ce_high 
ca86			    NEXTW 
ca86			 
ca86			 
ca86			.SPIOb: 
ca86			 
ca86				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
ca86			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
ca86			 
ca86					if DEBUG_FORTH_WORDS_KEY 
ca86						DMARK "SPo" 
ca86						CALLMONITOR 
ca86					endif 
ca86					; get port 
ca86			 
ca86			 
ca86					; get byte to send 
ca86			 
ca86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca86			 
ca86			;		push hl    ; u1  
ca86			 
ca86					; destroy value TOS 
ca86			 
ca86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca86			 
ca86					; one value on hl get other one back 
ca86			 
ca86			;		pop hl   ; u2 - addr 
ca86			 
ca86					; TODO Send SPI byte 
ca86			 
ca86			;		push hl 
ca86			;		call spi_ce_low 
ca86			;		pop hl 
ca86					ld a, l 
ca86					call spi_send_byte 
ca86			;		call spi_ce_high 
ca86			 
ca86					NEXTW 
ca86			 
ca86			.SPII: 
ca86				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
ca86			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
ca86					if DEBUG_FORTH_WORDS_KEY 
ca86						DMARK "SPi" 
ca86						CALLMONITOR 
ca86					endif 
ca86			 
ca86					; TODO Get SPI byte 
ca86			 
ca86					call spi_read_byte 
ca86			 
ca86					if DEBUG_FORTH_WORDS 
ca86						DMARK "Si2" 
ca86						CALLMONITOR 
ca86					endif 
ca86					ld h, 0 
ca86					ld l, a 
ca86					if DEBUG_FORTH_WORDS 
ca86						DMARK "Si3" 
ca86						CALLMONITOR 
ca86					endif 
ca86					call forth_push_numhl 
ca86			 
ca86					NEXTW 
ca86			 
ca86			 
ca86			 
ca86			.SESEL: 
ca86				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
ca86			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
ca86					if DEBUG_FORTH_WORDS_KEY 
ca86						DMARK "BNK" 
ca86						CALLMONITOR 
ca86					endif 
ca86			 
ca86					ld a, 255 
ca86					ld (spi_cartdev), a 
ca86			 
ca86					; get bank 
ca86			 
ca86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca86			 
ca86			;		push hl 
ca86			 
ca86					; destroy value TOS 
ca86			 
ca86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca86			 
ca86					; one value on hl get other one back 
ca86			 
ca86			;		pop hl 
ca86			 
ca86			 
ca86					ld c, SPI_CE_HIGH 
ca86					ld b, '0'    ; human readable bank number 
ca86			 
ca86					ld a, l 
ca86			 
ca86					if DEBUG_FORTH_WORDS 
ca86						DMARK "BNK" 
ca86						CALLMONITOR 
ca86					endif 
ca86			 
ca86					; active low 
ca86			 
ca86					cp 0 
ca86					jr z, .bset 
ca86					cp 1 
ca86					jr nz, .b2 
ca86					res 0, c 
ca86					ld b, '1'    ; human readable bank number 
ca86			.b2:		cp 2 
ca86					jr nz, .b3 
ca86					res 1, c 
ca86					ld b, '2'    ; human readable bank number 
ca86			.b3:		cp 3 
ca86					jr nz, .b4 
ca86					res 2, c 
ca86					ld b, '3'    ; human readable bank number 
ca86			.b4:		cp 4 
ca86					jr nz, .b5 
ca86					res 3, c 
ca86					ld b, '4'    ; human readable bank number 
ca86			.b5:		cp 5 
ca86					jr nz, .bset 
ca86					res 4, c 
ca86					ld b, '5'    ; human readable bank number 
ca86			 
ca86			.bset: 
ca86					ld a, c 
ca86					ld (spi_device),a 
ca86					ld a, b 
ca86					ld (spi_device_id),a 
ca86					if DEBUG_FORTH_WORDS 
ca86						DMARK "BN2" 
ca86						CALLMONITOR 
ca86					endif 
ca86			 
ca86					; set default SPI clk pulse time as disabled for BANK use 
ca86			 
ca86					ld a, 0 
ca86					ld (spi_clktime), a 
ca86			 
ca86					NEXTW 
ca86			 
ca86			.CARTDEV: 
ca86				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
ca86			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
ca86					if DEBUG_FORTH_WORDS_KEY 
ca86						DMARK "CDV" 
ca86						CALLMONITOR 
ca86					endif 
ca86			 
ca86					; disable se storage bank selection 
ca86			 
ca86					ld a, SPI_CE_HIGH		; ce high 
ca86					ld (spi_device), a 
ca86			 
ca86					; get bank 
ca86			 
ca86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca86			 
ca86			;		push hl 
ca86			 
ca86					; destroy value TOS 
ca86			 
ca86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca86			 
ca86					; one value on hl get other one back 
ca86			 
ca86			;		pop hl 
ca86			 
ca86					; active low 
ca86			 
ca86					ld c, 255 
ca86			 
ca86					ld a, l 
ca86					if DEBUG_FORTH_WORDS 
ca86						DMARK "CDV" 
ca86						CALLMONITOR 
ca86					endif 
ca86					cp 0 
ca86					jr z, .cset 
ca86					cp 1 
ca86					jr nz, .c2 
ca86					res 0, c 
ca86			.c2:		cp 2 
ca86					jr nz, .c3 
ca86					res 1, c 
ca86			.c3:		cp 3 
ca86					jr nz, .c4 
ca86					res 2, c 
ca86			.c4:		cp 4 
ca86					jr nz, .c5 
ca86					res 3, c 
ca86			.c5:		cp 5 
ca86					jr nz, .c6 
ca86					res 4, c 
ca86			.c6:		cp 6 
ca86					jr nz, .c7 
ca86					res 5, c 
ca86			.c7:		cp 7 
ca86					jr nz, .c8 
ca86					res 6, c 
ca86			.c8:		cp 8 
ca86					jr nz, .cset 
ca86					res 7, c 
ca86			.cset:		ld a, c 
ca86					ld (spi_cartdev),a 
ca86			 
ca86					if DEBUG_FORTH_WORDS 
ca86						DMARK "CD2" 
ca86						CALLMONITOR 
ca86					endif 
ca86			 
ca86					; set default SPI clk pulse time as 10ms for CARTDEV use 
ca86			 
ca86					ld a, $0a 
ca86					ld (spi_clktime), a 
ca86					NEXTW 
ca86			endif 
ca86			 
ca86			.ENDDEVICE: 
ca86			; eof 
ca86			 
# End of file forth_words_device.asm
ca86			 
ca86			; var handler 
ca86			 
ca86			 
ca86			.VARS: 
ca86				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
ca86 77				db WORD_SYS_CORE+99             
ca87 37 cb			dw .V0            
ca89 04				db 3 + 1 
ca8a .. 00			db "VAR",0              
ca8e				endm 
# End of macro CWHEAD
ca8e			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
ca8e			;| 
ca8e			;| The variable name should consist of a single letter. e.g. "a" 
ca8e			;! If a full string is passed then only the first char is looked at 
ca8e			;| Any other char could exceed bounds checks!  
ca8e			 
ca8e					if DEBUG_FORTH_WORDS_KEY 
ca8e						DMARK "VAR" 
ca8e f5				push af  
ca8f 3a a3 ca			ld a, (.dmark)  
ca92 32 6b ee			ld (debug_mark),a  
ca95 3a a4 ca			ld a, (.dmark+1)  
ca98 32 6c ee			ld (debug_mark+1),a  
ca9b 3a a5 ca			ld a, (.dmark+2)  
ca9e 32 6d ee			ld (debug_mark+2),a  
caa1 18 03			jr .pastdmark  
caa3 ..			.dmark: db "VAR"  
caa6 f1			.pastdmark: pop af  
caa7			endm  
# End of macro DMARK
caa7						CALLMONITOR 
caa7 cd 6f ee			call debug_vector  
caaa				endm  
# End of macro CALLMONITOR
caaa					endif 
caaa			 
caaa					FORTH_DSP_VALUEHL 
caaa cd 3e 9d			call macro_dsp_valuehl 
caad				endm 
# End of macro FORTH_DSP_VALUEHL
caad			 
caad 7e					ld a, (hl)    ; get first char on of the string 
caae			 
caae			 
caae					if DEBUG_FORTH_WORDS 
caae						DMARK "VR1" 
caae f5				push af  
caaf 3a c3 ca			ld a, (.dmark)  
cab2 32 6b ee			ld (debug_mark),a  
cab5 3a c4 ca			ld a, (.dmark+1)  
cab8 32 6c ee			ld (debug_mark+1),a  
cabb 3a c5 ca			ld a, (.dmark+2)  
cabe 32 6d ee			ld (debug_mark+2),a  
cac1 18 03			jr .pastdmark  
cac3 ..			.dmark: db "VR1"  
cac6 f1			.pastdmark: pop af  
cac7			endm  
# End of macro DMARK
cac7						CALLMONITOR 
cac7 cd 6f ee			call debug_vector  
caca				endm  
# End of macro CALLMONITOR
caca					endif 
caca					 
caca f5					push af	 
cacb					FORTH_DSP_POP 
cacb cd f6 9d			call macro_forth_dsp_pop 
cace				endm 
# End of macro FORTH_DSP_POP
cace f1					pop af 
cacf			 
cacf					; convert to upper 
cacf			 
cacf cd 48 90				call to_upper 
cad2					if DEBUG_FORTH_WORDS 
cad2						DMARK "Vaa" 
cad2 f5				push af  
cad3 3a e7 ca			ld a, (.dmark)  
cad6 32 6b ee			ld (debug_mark),a  
cad9 3a e8 ca			ld a, (.dmark+1)  
cadc 32 6c ee			ld (debug_mark+1),a  
cadf 3a e9 ca			ld a, (.dmark+2)  
cae2 32 6d ee			ld (debug_mark+2),a  
cae5 18 03			jr .pastdmark  
cae7 ..			.dmark: db "Vaa"  
caea f1			.pastdmark: pop af  
caeb			endm  
# End of macro DMARK
caeb						CALLMONITOR 
caeb cd 6f ee			call debug_vector  
caee				endm  
# End of macro CALLMONITOR
caee					endif 
caee 06 41				ld b, 'A' 
caf0 90					sub b			; set offset 
caf1					if DEBUG_FORTH_WORDS 
caf1						DMARK "Vbb" 
caf1 f5				push af  
caf2 3a 06 cb			ld a, (.dmark)  
caf5 32 6b ee			ld (debug_mark),a  
caf8 3a 07 cb			ld a, (.dmark+1)  
cafb 32 6c ee			ld (debug_mark+1),a  
cafe 3a 08 cb			ld a, (.dmark+2)  
cb01 32 6d ee			ld (debug_mark+2),a  
cb04 18 03			jr .pastdmark  
cb06 ..			.dmark: db "Vbb"  
cb09 f1			.pastdmark: pop af  
cb0a			endm  
# End of macro DMARK
cb0a						CALLMONITOR 
cb0a cd 6f ee			call debug_vector  
cb0d				endm  
# End of macro CALLMONITOR
cb0d					endif 
cb0d cb 27				sla a  
cb0f				 
cb0f					 
cb0f					if DEBUG_FORTH_WORDS 
cb0f						DMARK "VR2" 
cb0f f5				push af  
cb10 3a 24 cb			ld a, (.dmark)  
cb13 32 6b ee			ld (debug_mark),a  
cb16 3a 25 cb			ld a, (.dmark+1)  
cb19 32 6c ee			ld (debug_mark+1),a  
cb1c 3a 26 cb			ld a, (.dmark+2)  
cb1f 32 6d ee			ld (debug_mark+2),a  
cb22 18 03			jr .pastdmark  
cb24 ..			.dmark: db "VR2"  
cb27 f1			.pastdmark: pop af  
cb28			endm  
# End of macro DMARK
cb28						CALLMONITOR 
cb28 cd 6f ee			call debug_vector  
cb2b				endm  
# End of macro CALLMONITOR
cb2b					endif 
cb2b			 
cb2b 21 f4 e9				ld hl, cli_var_array2 
cb2e cd db 8c				call addatohl 
cb31 cd 47 9b				call forth_push_numhl 
cb34			 
cb34			 
cb34				       NEXTW 
cb34 c3 f4 9e			jp macro_next 
cb37				endm 
# End of macro NEXTW
cb37			.V0: 
cb37				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
cb37 78				db WORD_SYS_CORE+100             
cb38 4f cb			dw .V0Q            
cb3a 04				db 3 + 1 
cb3b .. 00			db "V0!",0              
cb3f				endm 
# End of macro CWHEAD
cb3f			;| V0! ( u1 -- )  Store value to v0  | DONE 
cb3f			 
cb3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb3f cd 3e 9d			call macro_dsp_valuehl 
cb42				endm 
# End of macro FORTH_DSP_VALUEHL
cb42			 
cb42 11 28 ea				ld de, cli_var_array 
cb45			 
cb45 eb					ex de, hl 
cb46 73					ld (hl), e 
cb47 23					inc hl 
cb48 72					ld (hl), d 
cb49			 
cb49					; destroy value TOS 
cb49			 
cb49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb49 cd f6 9d			call macro_forth_dsp_pop 
cb4c				endm 
# End of macro FORTH_DSP_POP
cb4c			 
cb4c				       NEXTW 
cb4c c3 f4 9e			jp macro_next 
cb4f				endm 
# End of macro NEXTW
cb4f			.V0Q: 
cb4f				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cb4f 79				db WORD_SYS_CORE+101             
cb50 60 cb			dw .V1S            
cb52 04				db 3 + 1 
cb53 .. 00			db "V0@",0              
cb57				endm 
# End of macro CWHEAD
cb57			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cb57 2a 28 ea				ld hl, (cli_var_array) 
cb5a cd 47 9b				call forth_push_numhl 
cb5d			 
cb5d				       NEXTW 
cb5d c3 f4 9e			jp macro_next 
cb60				endm 
# End of macro NEXTW
cb60			.V1S: 
cb60				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cb60 7a				db WORD_SYS_CORE+102             
cb61 78 cb			dw .V1Q            
cb63 04				db 3 + 1 
cb64 .. 00			db "V1!",0              
cb68				endm 
# End of macro CWHEAD
cb68			;| V1! ( u1 -- )  Store value to v1 | DONE 
cb68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb68 cd 3e 9d			call macro_dsp_valuehl 
cb6b				endm 
# End of macro FORTH_DSP_VALUEHL
cb6b			 
cb6b 11 2a ea				ld de, cli_var_array+2 
cb6e				 
cb6e eb					ex de, hl 
cb6f 73					ld (hl), e 
cb70 23					inc hl 
cb71 72					ld (hl), d 
cb72			 
cb72					; destroy value TOS 
cb72			 
cb72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb72 cd f6 9d			call macro_forth_dsp_pop 
cb75				endm 
# End of macro FORTH_DSP_POP
cb75				       NEXTW 
cb75 c3 f4 9e			jp macro_next 
cb78				endm 
# End of macro NEXTW
cb78			.V1Q: 
cb78				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cb78 7b				db WORD_SYS_CORE+103             
cb79 89 cb			dw .V2S            
cb7b 04				db 3 + 1 
cb7c .. 00			db "V1@",0              
cb80				endm 
# End of macro CWHEAD
cb80			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cb80 2a 2a ea				ld hl, (cli_var_array+2) 
cb83 cd 47 9b				call forth_push_numhl 
cb86				       NEXTW 
cb86 c3 f4 9e			jp macro_next 
cb89				endm 
# End of macro NEXTW
cb89			.V2S: 
cb89				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cb89 7c				db WORD_SYS_CORE+104             
cb8a a1 cb			dw .V2Q            
cb8c 04				db 3 + 1 
cb8d .. 00			db "V2!",0              
cb91				endm 
# End of macro CWHEAD
cb91			;| V2! ( u1 -- )  Store value to v2 | DONE 
cb91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb91 cd 3e 9d			call macro_dsp_valuehl 
cb94				endm 
# End of macro FORTH_DSP_VALUEHL
cb94			 
cb94 11 2c ea				ld de, cli_var_array+4 
cb97				 
cb97 eb					ex de, hl 
cb98 73					ld (hl), e 
cb99 23					inc hl 
cb9a 72					ld (hl), d 
cb9b			 
cb9b					; destroy value TOS 
cb9b			 
cb9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb9b cd f6 9d			call macro_forth_dsp_pop 
cb9e				endm 
# End of macro FORTH_DSP_POP
cb9e				       NEXTW 
cb9e c3 f4 9e			jp macro_next 
cba1				endm 
# End of macro NEXTW
cba1			.V2Q: 
cba1				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cba1 7d				db WORD_SYS_CORE+105             
cba2 b2 cb			dw .V3S            
cba4 04				db 3 + 1 
cba5 .. 00			db "V2@",0              
cba9				endm 
# End of macro CWHEAD
cba9			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cba9 2a 2c ea				ld hl, (cli_var_array+4) 
cbac cd 47 9b				call forth_push_numhl 
cbaf				       NEXTW 
cbaf c3 f4 9e			jp macro_next 
cbb2				endm 
# End of macro NEXTW
cbb2			.V3S: 
cbb2				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cbb2 7c				db WORD_SYS_CORE+104             
cbb3 ca cb			dw .V3Q            
cbb5 04				db 3 + 1 
cbb6 .. 00			db "V3!",0              
cbba				endm 
# End of macro CWHEAD
cbba			;| V3! ( u1 -- )  Store value to v3 | DONE 
cbba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbba cd 3e 9d			call macro_dsp_valuehl 
cbbd				endm 
# End of macro FORTH_DSP_VALUEHL
cbbd			 
cbbd 11 2e ea				ld de, cli_var_array+6 
cbc0				 
cbc0 eb					ex de, hl 
cbc1 73					ld (hl), e 
cbc2 23					inc hl 
cbc3 72					ld (hl), d 
cbc4			 
cbc4					; destroy value TOS 
cbc4			 
cbc4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbc4 cd f6 9d			call macro_forth_dsp_pop 
cbc7				endm 
# End of macro FORTH_DSP_POP
cbc7				       NEXTW 
cbc7 c3 f4 9e			jp macro_next 
cbca				endm 
# End of macro NEXTW
cbca			.V3Q: 
cbca				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cbca 7d				db WORD_SYS_CORE+105             
cbcb db cb			dw .END            
cbcd 04				db 3 + 1 
cbce .. 00			db "V3@",0              
cbd2				endm 
# End of macro CWHEAD
cbd2			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cbd2 2a 2e ea				ld hl, (cli_var_array+6) 
cbd5 cd 47 9b				call forth_push_numhl 
cbd8				       NEXTW 
cbd8 c3 f4 9e			jp macro_next 
cbdb				endm 
# End of macro NEXTW
cbdb			 
cbdb			 
cbdb			 
cbdb			 
cbdb			 
cbdb			; end of dict marker 
cbdb			 
cbdb 00			.END:    db WORD_SYS_END 
cbdc 00 00			dw 0 
cbde 00				db 0 
cbdf			 
cbdf			; use to jp here for user dict words to save on macro expansion  
cbdf			 
cbdf			user_dict_next: 
cbdf				NEXTW 
cbdf c3 f4 9e			jp macro_next 
cbe2				endm 
# End of macro NEXTW
cbe2			 
cbe2			 
cbe2			user_exec: 
cbe2				;    ld hl, <word code> 
cbe2				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cbe2				;    call forthexec 
cbe2				;    jp user_dict_next   (NEXT) 
cbe2			        ;    <word code bytes> 
cbe2 eb				ex de, hl 
cbe3 2a c2 e5			ld hl,(os_tok_ptr) 
cbe6				 
cbe6				FORTH_RSP_NEXT 
cbe6 cd ee 9a			call macro_forth_rsp_next 
cbe9				endm 
# End of macro FORTH_RSP_NEXT
cbe9			 
cbe9			if DEBUG_FORTH_UWORD 
cbe9						DMARK "UEX" 
cbe9 f5				push af  
cbea 3a fe cb			ld a, (.dmark)  
cbed 32 6b ee			ld (debug_mark),a  
cbf0 3a ff cb			ld a, (.dmark+1)  
cbf3 32 6c ee			ld (debug_mark+1),a  
cbf6 3a 00 cc			ld a, (.dmark+2)  
cbf9 32 6d ee			ld (debug_mark+2),a  
cbfc 18 03			jr .pastdmark  
cbfe ..			.dmark: db "UEX"  
cc01 f1			.pastdmark: pop af  
cc02			endm  
# End of macro DMARK
cc02				CALLMONITOR 
cc02 cd 6f ee			call debug_vector  
cc05				endm  
# End of macro CALLMONITOR
cc05			endif 
cc05			 
cc05			 
cc05			 
cc05 eb				ex de, hl 
cc06 22 c2 e5			ld (os_tok_ptr), hl 
cc09				 
cc09				; Don't use next - Skips the first word in uword. 
cc09			 
cc09 c3 85 9f			jp exec1 
cc0c			;	NEXT 
cc0c			 
cc0c			 
cc0c			; eof 
# End of file forth_wordsv4.asm
cc0c			endif 
cc0c			;;;;;;;;;;;;;; Debug code 
cc0c			 
cc0c			 
cc0c			;if DEBUG_FORTH_PARSE 
cc0c .. 00		.nowordfound: db "No match",0 
cc15 .. 00		.compword:	db "Comparing word ",0 
cc25 .. 00		.nextwordat:	db "Next word at",0 
cc32 .. 00		.charmatch:	db "Char match",0 
cc3d			;endif 
cc3d			if DEBUG_FORTH_JP 
cc3d			.foundword:	db "Word match. Exec..",0 
cc3d			endif 
cc3d			;if DEBUG_FORTH_PUSH 
cc3d .. 00		.enddict:	db "Dict end. Push.",0 
cc4d .. 00		.push_str:	db "Pushing string",0 
cc5c .. 00		.push_num:	db "Pushing number",0 
cc6b .. 00		.data_sp:	db "SP:",0 
cc6f .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cc81 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cc93 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cca5			;endif 
cca5			;if DEBUG_FORTH_MALLOC 
cca5 .. 00		.push_malloc:	db "Malloc address",0 
ccb4			;endif 
ccb4			 
ccb4			 
ccb4			 
ccb4			; display malloc address and current data stack pointer  
ccb4			 
ccb4			malloc_error: 
ccb4 d5				push de 
ccb5 f5				push af 
ccb6 e5				push hl 
ccb7 cd ae 8a			call clear_display 
ccba 11 da cc			ld de, .mallocerr 
ccbd 3e 00			ld a,0 
ccbf			;	ld de,os_word_scratch 
ccbf cd c1 8a			call str_at_display 
ccc2 3e 11			ld a, display_row_1+17 
ccc4 11 6b ee			ld de, debug_mark 
ccc7 cd c1 8a			call str_at_display 
ccca cd d1 8a			call update_display 
cccd				;call break_point_state 
cccd cd cf e4			call cin_wait 
ccd0			 
ccd0			;	ld a, ' ' 
ccd0			;	ld (os_view_disable), a 
ccd0 cd dd 94			call bp_on 
ccd3 e1				pop hl 
ccd4 f1				pop af 
ccd5 d1				pop de	 
ccd6				CALLMONITOR 
ccd6 cd 6f ee			call debug_vector  
ccd9				endm  
# End of macro CALLMONITOR
ccd9 c9				ret 
ccda			 
ccda .. 00		.mallocerr: 	db "Malloc Error",0 
cce7			;if DEBUG_FORTH_PUSH 
cce7			display_data_sp: 
cce7 f5				push af 
cce8			 
cce8				; see if disabled 
cce8			 
cce8			 
cce8 3a 6f ee			ld a, (debug_vector) 
cceb fe c9			cp $C9  ; RET 
cced				;ld a, (os_view_disable) 
cced				;cp '*' 
cced 28 67			jr z, .skipdsp 
ccef			 
ccef e5				push hl 
ccf0 e5				push hl 
ccf1 e5			push hl 
ccf2 cd ae 8a			call clear_display 
ccf5 e1			pop hl 
ccf6 7c				ld a,h 
ccf7 21 c6 e5			ld hl, os_word_scratch 
ccfa cd dc 8f			call hexout 
ccfd e1				pop hl 
ccfe 7d				ld a,l 
ccff 21 c8 e5			ld hl, os_word_scratch+2 
cd02 cd dc 8f			call hexout 
cd05 21 ca e5			ld hl, os_word_scratch+4 
cd08 3e 00			ld a,0 
cd0a 77				ld (hl),a 
cd0b 11 c6 e5			ld de,os_word_scratch 
cd0e 3e 28				ld a, display_row_2 
cd10 cd c1 8a				call str_at_display 
cd13 11 6f cc			ld de, .wordinhl 
cd16 3e 00			ld a, display_row_1 
cd18			 
cd18 cd c1 8a				call str_at_display 
cd1b 11 6b ee			ld de, debug_mark 
cd1e 3e 11			ld a, display_row_1+17 
cd20			 
cd20 cd c1 8a				call str_at_display 
cd23			 
cd23				; display current data stack pointer 
cd23 11 6b cc			ld de,.data_sp 
cd26 3e 30				ld a, display_row_2 + 8 
cd28 cd c1 8a				call str_at_display 
cd2b			 
cd2b 2a ee e9			ld hl,(cli_data_sp) 
cd2e e5				push hl 
cd2f 7c				ld a,h 
cd30 21 c6 e5			ld hl, os_word_scratch 
cd33 cd dc 8f			call hexout 
cd36 e1				pop hl 
cd37 7d				ld a,l 
cd38 21 c8 e5			ld hl, os_word_scratch+2 
cd3b cd dc 8f			call hexout 
cd3e 21 ca e5			ld hl, os_word_scratch+4 
cd41 3e 00			ld a,0 
cd43 77				ld (hl),a 
cd44 11 c6 e5			ld de,os_word_scratch 
cd47 3e 33				ld a, display_row_2 + 11 
cd49 cd c1 8a				call str_at_display 
cd4c			 
cd4c			 
cd4c cd d1 8a			call update_display 
cd4f cd f1 89			call delay1s 
cd52 cd f1 89			call delay1s 
cd55 e1				pop hl 
cd56			.skipdsp: 
cd56 f1				pop af 
cd57 c9				ret 
cd58			 
cd58			display_data_malloc: 
cd58			 
cd58 f5				push af 
cd59 e5				push hl 
cd5a e5				push hl 
cd5b e5			push hl 
cd5c cd ae 8a			call clear_display 
cd5f e1			pop hl 
cd60 7c				ld a,h 
cd61 21 c6 e5			ld hl, os_word_scratch 
cd64 cd dc 8f			call hexout 
cd67 e1				pop hl 
cd68 7d				ld a,l 
cd69 21 c8 e5			ld hl, os_word_scratch+2 
cd6c cd dc 8f			call hexout 
cd6f 21 ca e5			ld hl, os_word_scratch+4 
cd72 3e 00			ld a,0 
cd74 77				ld (hl),a 
cd75 11 c6 e5			ld de,os_word_scratch 
cd78 3e 28				ld a, display_row_2 
cd7a cd c1 8a				call str_at_display 
cd7d 11 a5 cc			ld de, .push_malloc 
cd80 3e 00			ld a, display_row_1 
cd82			 
cd82 cd c1 8a				call str_at_display 
cd85			 
cd85				; display current data stack pointer 
cd85 11 6b cc			ld de,.data_sp 
cd88 3e 30				ld a, display_row_2 + 8 
cd8a cd c1 8a				call str_at_display 
cd8d			 
cd8d 2a ee e9			ld hl,(cli_data_sp) 
cd90 e5				push hl 
cd91 7c				ld a,h 
cd92 21 c6 e5			ld hl, os_word_scratch 
cd95 cd dc 8f			call hexout 
cd98 e1				pop hl 
cd99 7d				ld a,l 
cd9a 21 c8 e5			ld hl, os_word_scratch+2 
cd9d cd dc 8f			call hexout 
cda0 21 ca e5			ld hl, os_word_scratch+4 
cda3 3e 00			ld a,0 
cda5 77				ld (hl),a 
cda6 11 c6 e5			ld de,os_word_scratch 
cda9 3e 33				ld a, display_row_2 + 11 
cdab cd c1 8a				call str_at_display 
cdae			 
cdae cd d1 8a			call update_display 
cdb1 cd f1 89			call delay1s 
cdb4 cd f1 89			call delay1s 
cdb7 e1				pop hl 
cdb8 f1				pop af 
cdb9 c9				ret 
cdba			;endif 
cdba			 
cdba			include "forth_autostart.asm" 
cdba			; list of commands to perform at system start up 
cdba			 
cdba			startcmds: 
cdba			;	dw test11 
cdba			;	dw test12 
cdba			;	dw test13 
cdba			;	dw test14 
cdba			;	dw test15 
cdba			;	dw test16 
cdba			;	dw test17 
cdba			;	dw ifthtest1 
cdba			;	dw ifthtest2 
cdba			;	dw ifthtest3 
cdba			;	dw mmtest1 
cdba			;	dw mmtest2 
cdba			;	dw mmtest3 
cdba			;	dw mmtest4 
cdba			;	dw mmtest5 
cdba			;	dw mmtest6 
cdba			;	dw iftest1 
cdba			;	dw iftest2 
cdba			;	dw iftest3 
cdba			;	dw looptest1 
cdba			;	dw looptest2 
cdba			;	dw test1 
cdba			;	dw test2 
cdba			;	dw test3 
cdba			;	dw test4 
cdba			;	dw game2r 
cdba			;	dw game2b1 
cdba			;	dw game2b2 
cdba			 
cdba				; start up words that are actually useful 
cdba			 
cdba			;    dw spi1 
cdba			;    dw spi2 
cdba			;    dw spi3 
cdba			;    dw spi4 
cdba			;    dw spi5 
cdba			;    dw spi6 
cdba			;    dw spi7 
cdba			; 
cdba			;    dw spi8 
cdba			;    dw spi9 
cdba			;    dw spi10 
cdba			 
cdba			; file editor 
cdba			;	dw edit1 
cdba			;	dw edit2 
cdba			;	dw edit3 
cdba			 
cdba			;	dw longread 
cdba e4 d1			dw clrstack 
cdbc 18 d2			dw type 
cdbe			;	dw stest 
cdbe 3d d2			dw strncpy 
cdc0			;	dw list 
cdc0 9e d2			dw start1 
cdc2 ae d2			dw start2 
cdc4			;	dw start3 
cdc4			;	dw start3b 
cdc4			;	dw start3c 
cdc4			 
cdc4				; (unit) testing words 
cdc4			 
cdc4			;	dw mtesta 
cdc4			;	dw mtestb 
cdc4			;	dw mtestc 
cdc4			;	dw mtestd 
cdc4			;	dw mteste 
cdc4			 
cdc4				; demo/game words 
cdc4			 
cdc4			;        dw game3w 
cdc4			;        dw game3p 
cdc4			;        dw game3sc 
cdc4			;        dw game3vsi 
cdc4			;        dw game3vs 
cdc4				 
cdc4 07 dd			dw game2b 
cdc6 75 dd			dw game2bf 
cdc8 bf dd			dw game2mba 
cdca 55 de			dw game2mbas 
cdcc 97 de			dw game2mb 
cdce			 
cdce c8 d9			dw game1 
cdd0 d9 d9			dw game1a 
cdd2 3b da			dw game1b 
cdd4 70 da			dw game1c 
cdd6 a6 da			dw game1d 
cdd8 d7 da			dw game1s 
cdda eb da			dw game1t 
cddc 00 db			dw game1f 
cdde 34 db			dw game1z 
cde0 78 db			dw game1zz 
cde2			 
cde2 e2 d7			dw test5 
cde4 1a d8			dw test6 
cde6 52 d8			dw test7 
cde8 66 d8			dw test8 
cdea 92 d8			dw test9 
cdec a8 d8			dw test10 
cdee				 
cdee 4f dc		        dw ssv5 
cdf0 33 dc		        dw ssv4 
cdf2 17 dc		        dw ssv3 
cdf4 e1 db		        dw ssv2 
cdf6 68 dc		        dw ssv1 
cdf8 b0 dc		        dw ssv1cpm 
cdfa			;	dw keyup 
cdfa			;	dw keydown 
cdfa			;	dw keyleft 
cdfa			;	dw keyright 
cdfa			;	dw 	keyf1 
cdfa			;	dw keyf2 
cdfa			;	dw keyf3 
cdfa			;	dw keyf4 
cdfa			;	dw keyf5 
cdfa			;	dw keyf6 
cdfa			;	dw keyf7 
cdfa			;	dw keyf8 
cdfa			;	dw keyf9 
cdfa			;	dw keyf10 
cdfa			;	dw keyf11 
cdfa			;	dw keyf12 
cdfa			;	dw keytab 
cdfa			;	dw keycr 
cdfa			;	dw keyhome 
cdfa			;	dw keyend 
cdfa			;	dw keybs 
cdfa 00 00			db 0, 0	 
cdfc			 
cdfc			 
cdfc			; File Editor 
cdfc			 
cdfc			; ( id - ) use 'e' to edit the displayed line 
cdfc .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
ce1d .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
ce52			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
ce52 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
ce8a			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
ce8a			 
ce8a			; SPI Net support words 
ce8a			 
ce8a			; v0! = node to send to 
ce8a			; ( str count - ) 
ce8a .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
cee3			 
cee3			; spiputc ( char node - ) 
cee3 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
cf17			; spiputc ( u node - ) 
cf17 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
cf45			 
cf45			; spigetc ( - n ) 
cf45 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
cf6e			 
cf6e			; getnode ( - n ) 
cf6e .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cf9b			 
cf9b			; ( str node - )  
cf9b .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d001			; store string ( str i - ) 
d001			 
d001			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d001 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d056			 
d056			; get string ( addr i -  )    TO FIX 
d056			 
d056 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d0ae			 
d0ae			 
d0ae			; NETCHAT (TODO) 
d0ae			; Program to allow two nodes to chat with eachother 
d0ae			; 
d0ae			; v0 - target node 
d0ae			;  
d0ae			; accept input at 0,0 
d0ae			; if input is string send spitype to target node 
d0ae			; starting at row 2,0 , while spigetchr is not zero ->  
d0ae			; 
d0ae			; 
d0ae			; TODO add paging of get request 
d0ae			 
d0ae			; ( node - ) 
d0ae .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d0cd .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d125 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d19d			 
d19d			 
d19d			; Long read of currently open file 
d19d .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d1e4			 
d1e4			; clear stack  
d1e4			 
d1e4 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d218			 
d218			; type ( addr count - ) 
d218 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d23d			 
d23d			; some direct memory words 
d23d			; strncpy ( len t f -- t ) 
d23d			 
d23d .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d29e			 
d29e .. 00		start1:     	db ": bpon $00 bp ;",0 
d2ae .. 00		start2:     	db ": bpoff $01 bp ;",0 
d2bf .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d33a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d39a			 
d39a			 
d39a			; a handy word to list items on the stack 
d39a			 
d39a .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d404			 
d404			 
d404			; test stack  
d404			; rnd8 stest 
d404			 
d404 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d47b			 
d47b			; random malloc and free cycles 
d47b			 
d47b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d530			 
d530			; fixed malloc and free cycles 
d530			 
d530 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d5d3			 
d5d3			; fixed double string push and drop cycle  
d5d3			 
d5d3 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d688			 
d688			; consistent fixed string push and drop cycle  
d688			 
d688 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d72c			 
d72c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d7e2			 
d7e2			;test1:		db ": aa 1 2 3 ;", 0 
d7e2			;test2:     	db "111 aa 888 999",0 
d7e2			;test3:     	db ": bb 77 ;",0 
d7e2			;test4:     	db "$02 $01 do i . loop bb",0 
d7e2			 
d7e2 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d81a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d852 .. 00		test7:     	db ": box hline vline ;",0 
d866 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d892 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d8a8 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d8cd .. 00		test11:     	db "hello create .",0 
d8dc .. 00		test12:     	db "hello2 create .",0 
d8ec			 
d8ec			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d8ec			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d8ec			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d8ec			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d8ec			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d8ec			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d8ec			 
d8ec			;iftest1:     	db "$0001 IF cls .",0 
d8ec			;iftest2:     	db "$0000 IF cls .",0 
d8ec			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d8ec			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d8ec			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d8ec			 
d8ec			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d8ec			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d8ec			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d8ec			 
d8ec			 
d8ec .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d910 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d940 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d965 .. 00		sound4: db ": cha $00 ; ",0 
d972 .. 00		sound5: db ": chb $20 ; ",0 
d97f .. 00		sound6: db ": chc $40 ; ",0 
d98c .. 00		sound7: db ": chd $60 ; ",0 
d999 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d9b1 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d9c8			 
d9c8			 
d9c8			 
d9c8			 
d9c8			; a small guess the number game 
d9c8			 
d9c8 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d9d9 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
da3b			 
da3b .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
da70 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
daa6 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
dad7 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
daeb .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
db00 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
db34 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
db78			 
db78			; Using 'ga' save a high score across multiple runs using external storage 
db78			 
db78 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
dbe1			 
dbe1			 
dbe1			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
dbe1			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
dbe1			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
dbe1			 
dbe1			; simple screen saver to test code memory reuse to destruction 
dbe1			 
dbe1 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
dc17 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
dc33 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dc4f .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dc68 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dcb0 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dd07			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dd07			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dd07			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dd07			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dd07			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dd07			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dd07			 
dd07			 
dd07			 
dd07			; minesweeper/battleship finding game 
dd07			; draws a game board of random ship/mine positions 
dd07			; user enters coords to see if it hits on 
dd07			; game ends when all are hit 
dd07			; when hit or miss says how many may be in the area 
dd07			 
dd07			; setup the game board and then hide it 
dd07 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dd75 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
ddbf			; prompt for where to target 
ddbf .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
de55 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
de7a			; TODO see if the entered coords hits or misses pushes char hit of miss 
de7a .. 00		game2mbht:      db ": mbckht nop ;",0 
de89 .. 00		game2mbms:      db ": mbcms nop ;",0 
de97			; TODO how many might be near by 
de97 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
df14			 
df14			; Game 3 
df14			 
df14			; Vert scroller ski game - avoid the trees! 
df14			 
df14			; v0 score (ie turns) 
df14			; v1 player pos 
df14			; v2 left wall 
df14			; v3 right wall 
df14			 
df14			; Draw side walls randomly 
df14			 
df14 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
df42			 
df42			; Draw player 
df42 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
df60			 
df60			; TODO Get Key 
df60			 
df60			; TODO Move left right 
df60			 
df60			; scroll and move walls a bit 
df60			 
df60 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
df91			 
df91			; main game loop 
df91			 
df91 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
dfbd .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
dffc			 
dffc			; key board defs 
dffc			 
dffc .. 00		keyup:       db ": keyup $05 ;",0 
e00a .. 00		keydown:       db ": keydown $0a ;",0 
e01a .. 00		keyleft:       db ": keyleft $0b ;",0 
e02a .. 00		keyright:       db ": keyright $0c ;",0 
e03b .. 00		keyf1:       db ": keyf1 $10 ;",0 
e049 .. 00		keyf2:       db ": keyf2 $11 ;",0 
e057 .. 00		keyf3:       db ": keyf3 $12 ;",0 
e065 .. 00		keyf4:       db ": keyf4 $13 ;",0 
e073 .. 00		keyf5:       db ": keyf5 $14 ;",0 
e081 .. 00		keyf6:       db ": keyf6 $15 ;",0 
e08f .. 00		keyf7:       db ": keyf7 $16 ;",0 
e09d .. 00		keyf8:       db ": keyf8 $17 ;",0 
e0ab .. 00		keyf9:       db ": keyf9 $18 ;",0 
e0b9 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e0c8 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e0d7 .. 00		keyf12:       db ": keyf12 $1b ;",0 
e0e6			 
e0e6 .. 00		keytab:       db ": keytab $09 ;",0 
e0f5 .. 00		keycr:       db ": keycr $0d ;",0 
e103 .. 00		keyhome:       db ": keyhome $0e ;",0 
e113 .. 00		keyend:       db ": keyend $0f ;",0 
e122 .. 00		keybs:       db ": keybs $08 ;",0 
e130			 
e130			   
e130			 
e130			 
e130			 
e130			; eof 
# End of file forth_autostart.asm
e130			 
e130			 
e130			 
e130			; stack over and underflow checks 
e130			 
e130			; init the words to detect the under/overflow 
e130			 
e130			chk_stk_init: 
e130				; a vague random number to check so we dont get any "lucky" hits 
e130 3e 2d			ld a, 45 
e132 6f				ld l, a 
e133 00				nop 
e134 3e 17			ld a, 23 
e136 67				ld h, a 
e137			 
e137 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
e13a			 
e13a			;	ld (chk_stund), hl	; stack points.... 
e13a 22 00 ef			ld (chk_stovr), hl 
e13d 22 ec e9			ld (chk_ret_und), hl 
e140 22 aa e9			ld (chk_ret_ovr), hl 
e143 22 28 e9			ld (chk_loop_ovr), hl 
e146 22 26 e8			ld (chk_data_ovr), hl 
e149 c9				ret 
e14a				 
e14a			check_stacks: 
e14a				; check all stack words 
e14a			 
e14a e5				push hl 
e14b d5				push de 
e14c			 
e14c			;	ld de,(chk_word) 
e14c			;	ld hl, (chk_stund)	; stack points.... 
e14c			;	if DEBUG_STK_FAULT 
e14c			;		DMARK "FAa" 
e14c			;		CALLMONITOR 
e14c			;	endif 
e14c			;	call cmp16 
e14c			;	jp z, .chk_faulta 
e14c			; 
e14c			;	ld de, sfaultsu 
e14c			;	jp .chk_fault 
e14c			 
e14c 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e14f ed 5b 9d e2		ld de,(chk_word) 
e153				if DEBUG_STK_FAULT 
e153					DMARK "FAb" 
e153					CALLMONITOR 
e153				endif 
e153 cd f9 8c			call cmp16 
e156 28 06			jr z, .chk_fault1 
e158 11 f9 e1			ld de, sfaultso 
e15b c3 ad e1			jp .chk_fault 
e15e			.chk_fault1:  
e15e 2a ec e9			ld hl, (chk_ret_und) 
e161 ed 5b 9d e2		ld de,(chk_word) 
e165				if DEBUG_STK_FAULT 
e165					DMARK "FAU" 
e165					CALLMONITOR 
e165				endif 
e165 cd f9 8c			call cmp16 
e168 ca 71 e1			jp z, .chk_fault2 
e16b 11 09 e2			ld de, sfaultru 
e16e c3 ad e1			jp .chk_fault 
e171			.chk_fault2:  
e171 2a aa e9			ld hl, (chk_ret_ovr) 
e174 ed 5b 9d e2		ld de,(chk_word) 
e178				if DEBUG_STK_FAULT 
e178					DMARK "FA1" 
e178					CALLMONITOR 
e178				endif 
e178 cd f9 8c			call cmp16 
e17b ca 84 e1			jp z, .chk_fault3 
e17e 11 17 e2			ld de, sfaultro 
e181 c3 ad e1			jp .chk_fault 
e184			.chk_fault3:  
e184 2a 28 e9			ld hl, (chk_loop_ovr) 
e187 ed 5b 9d e2		ld de,(chk_word) 
e18b				if DEBUG_STK_FAULT 
e18b					DMARK "FA2" 
e18b					CALLMONITOR 
e18b				endif 
e18b cd f9 8c			call cmp16 
e18e ca 97 e1			jp z, .chk_fault4 
e191 11 31 e2			ld de, sfaultlo 
e194 c3 ad e1			jp .chk_fault 
e197			.chk_fault4:  
e197 2a 26 e8			ld hl, (chk_data_ovr) 
e19a ed 5b 9d e2		ld de,(chk_word) 
e19e				if DEBUG_STK_FAULT 
e19e					DMARK "FA3" 
e19e					CALLMONITOR 
e19e				endif 
e19e cd f9 8c			call cmp16 
e1a1 ca aa e1			jp z, .chk_fault5 
e1a4 11 4b e2			ld de, sfaultdo 
e1a7 c3 ad e1			jp .chk_fault 
e1aa			 
e1aa			 
e1aa			.chk_fault5:  
e1aa d1				pop de 
e1ab e1				pop hl 
e1ac			 
e1ac c9				ret 
e1ad			 
e1ad cd ae 8a		.chk_fault: 	call clear_display 
e1b0 3e 28				ld a, display_row_2 
e1b2 cd c1 8a				call str_at_display 
e1b5 11 db e1				   ld de, .stackfault 
e1b8 3e 00				ld a, display_row_1 
e1ba cd c1 8a				call str_at_display 
e1bd 11 6b ee				    ld de, debug_mark 
e1c0 3e 11				ld a, display_row_1+17 
e1c2 cd c1 8a				call str_at_display 
e1c5 cd d1 8a				call update_display 
e1c8			 
e1c8				; prompt before entering montior for investigating issue 
e1c8			 
e1c8 3e 78			ld a, display_row_4 
e1ca 11 39 98			ld de, endprog 
e1cd			 
e1cd cd d1 8a			call update_display		 
e1d0			 
e1d0 cd bf 9a			call next_page_prompt 
e1d3			 
e1d3 d1				pop de 
e1d4 e1				pop hl 
e1d5 cd 8d 98				call monitor 
e1d8 c3 96 97				jp warmstart 
e1db					;jp 0 
e1db					;halt 
e1db			 
e1db			 
e1db			 
e1db .. 00		.stackfault: 	db "Stack fault:",0 
e1e8			 
e1e8 .. 00		sfaultsu: 	db	"Stack under flow",0 
e1f9 .. 00		sfaultso: 	db	"Stack over flow",0 
e209 .. 00		sfaultru:	db "RTS underflow",0 
e217 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e231 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e24b .. 00		sfaultdo:	db "DTS overflow", 0 
e258			 
e258			 
e258			fault_dsp_under: 
e258 11 6a e2			ld de, .dsp_under 
e25b c3 1a e3			jp .show_fault 
e25e			 
e25e			fault_rsp_under: 
e25e 11 78 e2			ld de, .rsp_under 
e261 c3 1a e3			jp .show_fault 
e264			fault_loop_under: 
e264 11 86 e2			ld de, .loop_under 
e267 c3 1a e3			jp .show_fault 
e26a			 
e26a .. 00		.dsp_under: db "DSP Underflow",0 
e278 .. 00		.rsp_under: db "RSP Underflow",0 
e286 .. 00		.loop_under: db "LOOP Underflow",0 
e295			 
e295			 
e295 d5			type_faultn: 	push de 
e296 e5					push hl 
e297 cd ae 8a				call clear_display 
e29a 11 c1 e2				   ld de, .typefaultn 
e29d 3e 00				ld a, display_row_1 
e29f cd c1 8a				call str_at_display 
e2a2 11 6b ee				    ld de, debug_mark 
e2a5 3e 11				ld a, display_row_1+17 
e2a7 cd c1 8a				call str_at_display 
e2aa cd d1 8a				call update_display 
e2ad			 
e2ad				; prompt before entering montior for investigating issue 
e2ad			 
e2ad 3e 78			ld a, display_row_4 
e2af 11 39 98			ld de, endprog 
e2b2			 
e2b2 cd d1 8a			call update_display		 
e2b5			 
e2b5 cd bf 9a			call next_page_prompt 
e2b8			 
e2b8 e5					push hl 
e2b9 d5					push de 
e2ba cd 8d 98				call monitor 
e2bd c3 96 97				jp warmstart 
e2c0 76					halt 
e2c1			 
e2c1			 
e2c1 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e2d8			 
e2d8 d5			type_faults: 	push de 
e2d9 e5					push hl 
e2da cd ae 8a				call clear_display 
e2dd 11 03 e3				   ld de, .typefaults 
e2e0 3e 00				ld a, display_row_1 
e2e2 cd c1 8a				call str_at_display 
e2e5 11 6b ee				    ld de, debug_mark 
e2e8 3e 11				ld a, display_row_1+17 
e2ea cd c1 8a				call str_at_display 
e2ed cd d1 8a				call update_display 
e2f0			 
e2f0				; prompt before entering montior for investigating issue 
e2f0			 
e2f0 3e 78			ld a, display_row_4 
e2f2 11 39 98			ld de, endprog 
e2f5			 
e2f5 cd d1 8a			call update_display		 
e2f8			 
e2f8 cd bf 9a			call next_page_prompt 
e2fb			 
e2fb e1					pop hl 
e2fc d1					pop de 
e2fd cd 8d 98				call monitor 
e300 c3 96 97				jp warmstart 
e303			 
e303			 
e303 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e31a			 
e31a			.show_fault: 	 
e31a d5					push de 
e31b cd ae 8a				call clear_display 
e31e d1					pop de 
e31f 3e 00				ld a, display_row_1 
e321 cd c1 8a				call str_at_display 
e324 11 6b ee				    ld de, debug_mark 
e327 3e 11				ld a, display_row_1+17 
e329 cd c1 8a				call str_at_display 
e32c cd d1 8a				call update_display 
e32f			 
e32f				; prompt before entering montior for investigating issue 
e32f			 
e32f 3e 78			ld a, display_row_4 
e331 11 39 98			ld de, endprog 
e334			 
e334 cd d1 8a			call update_display		 
e337			 
e337 cd bf 9a			call next_page_prompt 
e33a			 
e33a e1					pop hl 
e33b d1					pop de 
e33c cd 8d 98				call monitor 
e33f			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e33f			; TODO Make optional fault restart to cli or warm boot? 
e33f					;jp warmstart 
e33f c3 e0 97				jp cli 
e342 76					halt 
e343			 
e343			; handle the auto run of code from files in storage 
e343			 
e343			 
e343			include "forth_startup.asm" 
e343			; Which startup method to use? 
e343			; 
e343			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e343			; followed by loading of a list of scripts in eeprom 
e343			 
e343			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e343			; from eeprom 
e343			 
e343			; Select with define in main stubs 
e343			 
e343			if STARTUP_V1 
e343				include "forth_startupv1.asm" 
e343			; Startup script loading version 1 
e343			 
e343			; If SE storage is available first stage is to use the selected file 
e343			; then go through the eeprom list 
e343			 
e343 .. 00		sprompt1: db "Startup load...",0 
e353 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e369			 
e369			 
e369			 
e369			 
e369			forth_startup: 
e369 21 ba cd			ld hl, startcmds 
e36c 3e 00			ld a, 0 
e36e 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e371			 
e371 e5			.start1:	push hl 
e372 cd ae 8a			call clear_display 
e375 11 43 e3			ld de, sprompt1 
e378 3e 00		        ld a, display_row_1 
e37a cd c1 8a			call str_at_display 
e37d 11 53 e3			ld de, sprompt2 
e380 3e 28		        ld a, display_row_2 
e382 cd c1 8a			call str_at_display 
e385 e1				pop hl 
e386 e5				push hl 
e387 5e				ld e,(hl) 
e388 23				inc hl 
e389 56				ld d,(hl) 
e38a 3e 50		        ld a, display_row_3 
e38c cd c1 8a			call str_at_display 
e38f cd d1 8a			call update_display 
e392			 
e392			 
e392 3a e7 e6			ld a, (os_last_cmd) 
e395 fe 00			cp 0 
e397 28 05			jr z, .startprompt 
e399 cd e5 89			call delay250ms 
e39c 18 24			jr .startdo 
e39e				 
e39e				 
e39e			 
e39e			.startprompt: 
e39e			 
e39e 3e 9f			ld a,display_row_4 + display_cols - 1 
e3a0 11 bd 9a		        ld de, endprg 
e3a3 cd c1 8a			call str_at_display 
e3a6 cd d1 8a			call update_display 
e3a9 cd f1 89			call delay1s 
e3ac cd cf e4			call cin_wait 
e3af						 
e3af fe 2a			cp '*' 
e3b1 28 5e			jr z, .startupend1 
e3b3 fe 23			cp '#' 
e3b5 20 07			jr nz, .startno 
e3b7 3e 01			ld a, 1 
e3b9 32 e7 e6			ld (os_last_cmd),a 
e3bc 18 04			jr .startdo 
e3be fe 31		.startno:	cp '1' 
e3c0 28 3a			jr z,.startnxt  
e3c2			 
e3c2				; exec startup line 
e3c2			.startdo:	 
e3c2 e1				pop hl 
e3c3 e5				push hl 
e3c4				 
e3c4 5e				ld e,(hl) 
e3c5 23				inc hl 
e3c6 56				ld d,(hl) 
e3c7 eb				ex de,hl 
e3c8			 
e3c8 e5				push hl 
e3c9			 
e3c9 3e 00			ld a, 0 
e3cb				;ld a, FORTH_END_BUFFER 
e3cb cd 44 91			call strlent 
e3ce 23				inc hl   ; include zero term to copy 
e3cf 06 00			ld b,0 
e3d1 4d				ld c,l 
e3d2 e1				pop hl 
e3d3 11 c1 e2			ld de, scratch 
e3d6 ed b0			ldir 
e3d8			 
e3d8			 
e3d8 21 c1 e2			ld hl, scratch 
e3db cd 42 9f			call forthparse 
e3de cd 82 9f			call forthexec 
e3e1 cd 94 9e			call forthexec_cleanup 
e3e4			 
e3e4 3e 78			ld a, display_row_4 
e3e6 11 39 98			ld de, endprog 
e3e9			 
e3e9 cd d1 8a			call update_display		 
e3ec			 
e3ec 3a e7 e6			ld a, (os_last_cmd) 
e3ef fe 00			cp 0 
e3f1 20 09			jr nz, .startnxt 
e3f3 cd bf 9a			call next_page_prompt 
e3f6 cd ae 8a		        call clear_display 
e3f9 cd d1 8a			call update_display		 
e3fc			 
e3fc				; move onto next startup line? 
e3fc			.startnxt: 
e3fc			 
e3fc cd e5 89			call delay250ms 
e3ff e1				pop hl 
e400			 
e400 23				inc hl 
e401 23				inc hl 
e402			 
e402 e5				push hl 
e403 5e				ld e, (hl) 
e404 23				inc hl 
e405 56				ld d, (hl) 
e406 e1				pop hl 
e407				; TODO replace 0 test 
e407			 
e407 eb				ex de, hl 
e408 cd 04 8d			call ishlzero 
e40b			;	ld a,e 
e40b			;	add d 
e40b			;	cp 0    ; any left to do? 
e40b eb				ex de, hl 
e40c c2 71 e3			jp nz, .start1 
e40f 18 01			jr .startupend 
e411			 
e411 e1			.startupend1: pop hl 
e412			.startupend: 
e412			 
e412 cd ae 8a			call clear_display 
e415 cd d1 8a			call update_display 
e418 c9				ret 
e419			if STORAGE_SE 
e419			 
e419			sprompt3: db "Loading from start-up file?:",0 
e419			sprompt4: db "(Y=Any key/N=No)",0 
e419			 
e419			 
e419			forth_autoload: 
e419			 
e419				; load block 0 of store 1 
e419				 
e419				ld a, $fe      ; bit 0 clear 
e419				ld (spi_device), a 
e419			 
e419				call storage_get_block_0 
e419			 
e419				ld a, (store_page+STORE_0_AUTOFILE) 
e419			 
e419				cp 0 
e419				ret z     ; auto start not enabled 
e419			 
e419				call clear_display 
e419			 
e419				; set bank 
e419			 
e419					ld a, (store_page+STORE_0_BANKRUN) 
e419					ld (spi_device), a 
e419			 
e419				; get file id to load from and get the file name to display 
e419			 
e419					ld a, (store_page+STORE_0_FILERUN) 
e419			 
e419					ld l, 0 
e419					ld h, a 
e419					ld de, store_page 
e419			 
e419					if DEBUG_FORTH_WORDS 
e419						DMARK "ASp" 
e419						CALLMONITOR 
e419					endif 
e419					call storage_read 
e419			 
e419					if DEBUG_FORTH_WORDS 
e419						DMARK "ASr" 
e419						CALLMONITOR 
e419					endif 
e419			 
e419					call ishlzero 
e419					ret z             ; file not found 
e419			 
e419					ld a, display_row_2 + 10 
e419					ld de, store_page+3 
e419					call str_at_display 
e419				 
e419			; 
e419			 
e419				ld a, display_row_1+5 
e419				ld de, sprompt3 
e419				call str_at_display 
e419				ld a, display_row_3+15 
e419				ld de, sprompt4 
e419				call str_at_display 
e419			 
e419				call update_display 
e419			 
e419				call cin_wait 
e419				cp 'n' 
e419				ret z 
e419				cp 'N' 
e419				ret z 
e419			 
e419				call delay1s 
e419			 
e419				ld a, (store_page+2) 
e419				ld (store_openmaxext), a    ; save count of ext 
e419				ld a, 1  
e419				ld (store_openext), a    ; save count of ext 
e419			 
e419			.autof:  
e419				ld l , a 
e419				 
e419				ld a, (store_page) 
e419				ld h, a	 
e419				ld de, store_page 
e419					if DEBUG_FORTH_WORDS 
e419						DMARK "ASl" 
e419						CALLMONITOR 
e419					endif 
e419					call storage_read 
e419				call ishlzero 
e419				ret z 
e419			;	jr z, .autoend 
e419			 
e419					if DEBUG_FORTH_WORDS 
e419						DMARK "ASc" 
e419						CALLMONITOR 
e419					endif 
e419				ld de, store_page+2 
e419				ld a, display_row_4 
e419				call str_at_display 
e419			 
e419				call update_display 
e419				call delay250ms 
e419			 
e419			 
e419			 
e419				ld hl, store_page+2 
e419				call forthparse 
e419				call forthexec 
e419				call forthexec_cleanup 
e419			 
e419				 
e419				ld a, (store_openext) 
e419				inc a 
e419				ld (store_openext), a    ; save count of ext 
e419			 
e419				jr .autof 
e419			;.autofdone: 
e419			; 
e419			;		if DEBUG_FORTH_WORDS 
e419			;			DMARK "ASx" 
e419			;			CALLMONITOR 
e419			;		endif 
e419			;;	call clear_display 
e419			;	ret 
e419			 
e419			 
e419			 
e419			endif 
# End of file forth_startupv1.asm
e419			endif 
e419			if STARTUP_V2 
e419				include "forth_startupv2.asm" 
e419			endif 
e419			 
# End of file forth_startup.asm
e419			 
e419			; eof 
# End of file forth_kernel.asm
e419			;include "nascombasic.asm" 
e419			 
e419			 
e419			; find out where the code ends if loaded into RAM (for SC114) 
e419			;endofcode:  
e419			;	nop 
e419			 
e419			 
e419			; jump to nmi vector 
e419			 
e419			init_nmi: 
e419 3e c9			ld a, $c9   ; RET 
e41b 32 72 ee			ld (nmi_vector), a 
e41e c9				ret 
e41f			nmi: 
e41f e5				push hl 
e420 d5				push de 
e421 c5				push bc 
e422 f5				push af 
e423 cd 72 ee			call nmi_vector 
e426 f5				push af 
e427 c5				push bc 
e428 d5				push de 
e429 e5				push hl 
e42a ed 4d			reti 
e42c			 
e42c			 
e42c			; eof 
e42c			 
# End of file main.asm
e42c			;include "firmware_lcd_4x40.asm" 
e42c			;;include "firmware_lcd_4x20.asm" 
e42c			include "firmware_serial_display.asm" 
e42c			 
e42c			; Serial display interface for SC114 
e42c			 
e42c			 
e42c			display_row_1: equ 0 
e42c			display_row_2: equ display_row_1+display_cols 
e42c			display_row_3: equ display_row_2 + display_cols 
e42c			display_row_4: equ display_row_3 + display_cols 
e42c			 
e42c			kLCDWidth:  EQU display_cols             ;Width in characters 
e42c			kLCD_Line1: EQU 0x00  
e42c			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e42c			; E1 
e42c			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e42c			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e42c			 
e42c			lcd_init: 
e42c				; no init as handled by the SCM bios 
e42c c9				ret 
e42d			 
e42d			 
e42d			; low level functions for direct screen writes 
e42d			 
e42d			; output char at pos? 
e42d			fLCD_Str: 
e42d			        ;out (SC114_SIO_1_OUT),a 
e42d c5				push bc 
e42e 0e 02			ld c, $02 
e430 f7				rst $30 
e431 c1				pop bc 
e432 c9				ret 
e433			 
e433			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e433			fLCD_Pos: 
e433				; use ASCII escape to position 
e433			        ;out (SC114_SIO_1_OUT),a 
e433 c5				push bc 
e434 0e 02			ld c, $02 
e436 f7				rst $30 
e437 c1				pop bc 
e438			 
e438 c9				ret 
e439			 
e439			; output char at pos 
e439			fLCD_Data: 
e439			      ;  out (SC114_SIO_1_OUT),a 
e439 c5				push bc 
e43a 0e 02			ld c, $02 
e43c f7				rst $30 
e43d c1				pop bc 
e43e			 
e43e c9				ret 
e43f			 
e43f			; ascii cls  
e43f			 
e43f 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e443			 
e443			; write the frame buffer given in hl to hardware  
e443			write_display: 
e443			 
e443			API: equ 0 
e443			 
e443			if API 
e443				push bc 
e443				ld b, 4 
e443			 
e443			        ld (display_write_tmp), hl 	  
e443			 
e443				; clear and home cursor 
e443			 
e443				ld c, 6 
e443				ld de, .cls 
e443				rst $30 
e443			 
e443			 
e443			.writeln: 
e443			 
e443				ld de, (display_write_tmp) 
e443				ld c, 6 
e443				rst $30 
e443				ld c, 7 
e443				rst $30 
e443			 
e443				ld hl, (display_write_tmp) 
e443				ld de, display_cols 
e443				add hl,de 
e443				ld (display_write_tmp),hl 
e443			 
e443				djnz  .writeln 
e443			 
e443				pop bc 
e443			 
e443			 
e443				ret 
e443			endif 
e443 e5				push hl 
e444 c5				push bc 
e445 d5				push de 
e446			 
e446			;	ld c, 2 
e446			;	;ld de, .cls 
e446			;	ld a, 27 
e446			;	rst $30 
e446			;	ld c, 2 
e446			;	;ld de, .cls 
e446			;	ld a, '[' 
e446			;	rst $30 
e446			; 
e446			;	ld c, 2 
e446			;	;ld de, .cls 
e446			;	ld a, 'H' 
e446			;	rst $30 
e446			; 
e446			 
e446 0e 02			ld c, 2 
e448				;ld de, .cls 
e448 3e 1b			ld a, 27 
e44a f7				rst $30 
e44b			 
e44b			 
e44b 0e 02			ld c, 2 
e44d				;ld de, .cls 
e44d 3e 5b			ld a, '[' 
e44f f7				rst $30 
e450 0e 02			ld c, 2 
e452				;ld de, .cls 
e452 3e 32			ld a, '2' 
e454 f7				rst $30 
e455 0e 02			ld c, 2 
e457				;ld de, .cls 
e457 3e 4a			ld a, 'J' 
e459 f7				rst $30 
e45a d1				pop de 
e45b c1				pop bc 
e45c e1				pop hl 
e45d			 
e45d			 
e45d 22 c9 eb		        ld (display_write_tmp), hl 	  
e460 3e 00			ld a, kLCD_Line1 
e462			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e462 06 28			ld b, display_cols 
e464 ed 5b c9 eb		ld de, (display_write_tmp) 
e468 cd c6 e4			call write_len_string 
e46b				 
e46b			 
e46b e5			push hl 
e46c d5			push de 
e46d c5			push bc 
e46e 0e 07			ld c, 7 
e470 f7				rst $30 
e471 c1			pop bc 
e472 d1			pop de 
e473 e1			pop hl 
e474			 
e474				 
e474 2a c9 eb			ld hl, (display_write_tmp) 
e477 11 28 00			ld de, display_cols 
e47a 19				add hl,de 
e47b 22 c9 eb			ld (display_write_tmp),hl 
e47e			 
e47e				 
e47e 3e 28			ld a, kLCD_Line2 
e480			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e480 06 28			ld b, display_cols 
e482 ed 5b c9 eb		ld de, (display_write_tmp) 
e486 cd c6 e4			call write_len_string 
e489				 
e489 2a c9 eb			ld hl, (display_write_tmp) 
e48c 11 28 00			ld de, display_cols 
e48f 19				add hl,de 
e490 22 c9 eb			ld (display_write_tmp),hl 
e493			 
e493 e5			push hl 
e494 d5			push de 
e495 c5			push bc 
e496 0e 07			ld c, 7 
e498 f7				rst $30 
e499 c1			pop bc 
e49a d1			pop de 
e49b e1			pop hl 
e49c			 
e49c				 
e49c 3e 50			ld a, kLCD_Line3 
e49e			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e49e 06 28			ld b, display_cols 
e4a0 ed 5b c9 eb		ld de, (display_write_tmp) 
e4a4 cd c6 e4			call write_len_string 
e4a7				 
e4a7 2a c9 eb			ld hl, (display_write_tmp) 
e4aa 11 28 00			ld de, display_cols 
e4ad 19				add hl,de 
e4ae 22 c9 eb			ld (display_write_tmp),hl 
e4b1			 
e4b1 e5			push hl 
e4b2 d5			push de 
e4b3 c5			push bc 
e4b4 0e 07			ld c, 7 
e4b6 f7				rst $30 
e4b7 c1			pop bc 
e4b8 d1			pop de 
e4b9 e1			pop hl 
e4ba			 
e4ba				 
e4ba 3e 78			ld a, kLCD_Line4 
e4bc			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e4bc 06 28			ld b, display_cols 
e4be ed 5b c9 eb		ld de, (display_write_tmp) 
e4c2 cd c6 e4			call write_len_string 
e4c5 c9					ret 
e4c6			 
e4c6			 
e4c6				; write out a fixed length string given in b from de 
e4c6			 
e4c6 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e4c7 cd 39 e4		            CALL fLCD_Data      ;Write character to display 
e4ca 13				inc de 
e4cb 10 f9			djnz write_len_string 
e4cd c9				ret 
e4ce			 
e4ce			 
e4ce			; eof 
# End of file firmware_serial_display.asm
e4ce			;include "firmware_key_5x10.asm" 
e4ce			;;include "firmware_key_4x10.asm" 
e4ce			include "firmware_key_serial.asm" 
e4ce			; Serial keyboard interface for SC114 
e4ce			 
e4ce			key_init: 
e4ce				; no init as handled by the SCM bios 
e4ce c9				ret 
e4cf			 
e4cf			 
e4cf			cin_wait: 
e4cf			;	ld a, 0 
e4cf			;	ret 
e4cf			 
e4cf				;in a,(SC114_SIO_1_IN) 
e4cf			        ; Use SCM API to get from whatever console device we are using 
e4cf c5				push bc 
e4d0 0e 01			ld c, $01 
e4d2 f7				rst $30 
e4d3 c1				pop bc 
e4d4 c9				ret 
e4d5			 
e4d5			cin: 
e4d5			 
e4d5			 
e4d5 c5				push bc 
e4d6			 
e4d6				; any key waiting to process? 
e4d6 0e 03			ld c, $03 
e4d8 f7				rst $30 
e4d9 28 05			jr z, .cin_skip 
e4db			 
e4db				; yep, get it 
e4db			 
e4db 0e 01			ld c, $01 
e4dd f7				rst $30 
e4de c1				pop bc 
e4df c9				ret 
e4e0			.cin_skip: 
e4e0 3e 00			ld a, 0 
e4e2 c1				pop bc 
e4e3 c9				ret 
e4e4			 
e4e4			 
e4e4			 
e4e4			 
# End of file firmware_key_serial.asm
e4e4			endofcode:  
e4e4			baseram:  
e4e4 00				nop 
e4e5			 
e4e5			heap_start: equ baseram+15  ; Starting address of heap 
e4e5			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e4e5			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e4e5			;VDU:  EQU     endofcode           ; BASIC Work space 
e4e5			; eof 
e4e5			 
# End of file os_mega_sc114.asm
e4e5
