# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 40 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd d2 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd d2 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd d2 0a				call clear_display  
0023			  
0023			  
0023 cd e3 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 2c 66			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd a9 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd f5 0a			call update_display  
0032 cd 52 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd d7 0a			call fill_display  
003a cd f5 0a			call update_display  
003d cd 52 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd d7 0a			call fill_display  
0045 cd f5 0a			call update_display  
0048 cd 52 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd d7 0a			call fill_display  
0050 cd f5 0a			call update_display  
0053 cd 52 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd e5 0a			call str_at_display  
005e cd f5 0a			call update_display  
0061			  
0061			  
0061 cd 52 0a			call delay1s  
0064 cd 52 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd e5 0a			call str_at_display  
006f cd f5 0a			call update_display  
0072 cd 52 0a			call delay1s  
0075 cd 52 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 37 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 37 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd bd 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd 6a 16			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd 6a 16			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2a 06			call storage_findnextid 
035d			 
035d cd 2f 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd 6a 16			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd 6a 16			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd 6a 16			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd 6a 16			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd 6a 16			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 15 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 6a 16			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 6a 16			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 37 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 37 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 06 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 37 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 37 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 06 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 6a 16			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 6a 16			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 6a 16			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 6a 16			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2a 06			call storage_findnextid 
056e			 
056e e5				push hl 
056f			 
056f				; TODO check file not found 
056f			 
056f 11 e8 f9			ld de, store_page 
0572 cd 09 03			call storage_read_block 
0575			 
0575					if DEBUG_FORTH_WORDS 
0575						DMARK "ER1" 
0575 f5				push af  
0576 3a 8a 05			ld a, (.dmark)  
0579 32 bd fb			ld (debug_mark),a  
057c 3a 8b 05			ld a, (.dmark+1)  
057f 32 be fb			ld (debug_mark+1),a  
0582 3a 8c 05			ld a, (.dmark+2)  
0585 32 bf fb			ld (debug_mark+2),a  
0588 18 03			jr .pastdmark  
058a ..			.dmark: db "ER1"  
058d f1			.pastdmark: pop af  
058e			endm  
# End of macro DMARK
058e						CALLMONITOR 
058e cd 6a 16			call break_point_state  
0591				endm  
# End of macro CALLMONITOR
0591					endif 
0591 3a e8 f9			ld a, (store_page)	; get file id 
0594 32 e1 f9			ld (store_tmpid), a 
0597			 
0597 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059a 32 e0 f9			ld (store_tmpext), a 
059d			 
059d				; wipe file header 
059d			 
059d e1				pop hl 
059e 3e 00			ld a, 0 
05a0 32 e8 f9			ld (store_page), a 
05a3 32 e9 f9			ld (store_page+1),a 
05a6 11 e8 f9			ld de, store_page 
05a9					if DEBUG_FORTH_WORDS 
05a9						DMARK "ER2" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 bd fb			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 be fb			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 bf fb			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "ER2"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2						CALLMONITOR 
05c2 cd 6a 16			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5					endif 
05c5 cd 6e 03			call storage_write_block 
05c8			 
05c8			 
05c8				; wipe file extents 
05c8			 
05c8 3a e0 f9			ld a, (store_tmpext) 
05cb 47				ld b, a 
05cc			 
05cc			.eraext:	  
05cc c5				push bc 
05cd			 
05cd 21 40 00			ld hl, STORE_BLOCK_PHY 
05d0 3a e1 f9			ld a,(store_tmpid) 
05d3 5f				ld e, a 
05d4 50				ld d, b	 
05d5					if DEBUG_FORTH_WORDS 
05d5						DMARK "ER3" 
05d5 f5				push af  
05d6 3a ea 05			ld a, (.dmark)  
05d9 32 bd fb			ld (debug_mark),a  
05dc 3a eb 05			ld a, (.dmark+1)  
05df 32 be fb			ld (debug_mark+1),a  
05e2 3a ec 05			ld a, (.dmark+2)  
05e5 32 bf fb			ld (debug_mark+2),a  
05e8 18 03			jr .pastdmark  
05ea ..			.dmark: db "ER3"  
05ed f1			.pastdmark: pop af  
05ee			endm  
# End of macro DMARK
05ee						CALLMONITOR 
05ee cd 6a 16			call break_point_state  
05f1				endm  
# End of macro CALLMONITOR
05f1					endif 
05f1 cd 2a 06			call storage_findnextid 
05f4			 
05f4 e5				push hl 
05f5 11 e8 f9			ld de, store_page 
05f8 cd 09 03			call storage_read_block 
05fb			 
05fb				; free block	 
05fb			 
05fb 3e 00			ld a, 0 
05fd 32 e8 f9			ld (store_page), a 
0600 32 e9 f9			ld (store_page+1),a 
0603 11 e8 f9			ld de, store_page 
0606 e1				pop hl 
0607					if DEBUG_FORTH_WORDS 
0607						DMARK "ER4" 
0607 f5				push af  
0608 3a 1c 06			ld a, (.dmark)  
060b 32 bd fb			ld (debug_mark),a  
060e 3a 1d 06			ld a, (.dmark+1)  
0611 32 be fb			ld (debug_mark+1),a  
0614 3a 1e 06			ld a, (.dmark+2)  
0617 32 bf fb			ld (debug_mark+2),a  
061a 18 03			jr .pastdmark  
061c ..			.dmark: db "ER4"  
061f f1			.pastdmark: pop af  
0620			endm  
# End of macro DMARK
0620						CALLMONITOR 
0620 cd 6a 16			call break_point_state  
0623				endm  
# End of macro CALLMONITOR
0623					endif 
0623 cd 6e 03			call storage_write_block 
0626			 
0626 c1				pop bc 
0627 10 a3			djnz .eraext 
0629			 
0629 c9				ret 
062a			 
062a			 
062a			; Find Free Block 
062a			; --------------- 
062a			; 
062a			; With current bank 
062a			;  
062a			; From given starting logical block 
062a			;    Read block  
062a			;    If no file id 
062a			;         Return block id 
062a			 
062a			 
062a			; hl starting page number 
062a			; hl contains free page number or zero if no pages free 
062a			; e contains the file id to locate 
062a			; d contains the block number 
062a			 
062a			; TODO change to find file id and use zero for free block 
062a			 
062a			storage_findnextid: 
062a			 
062a				; now locate first 0 page to mark as a free block 
062a			 
062a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062c			;	ld hl, STORE_BLOCK_PHY 
062c			 
062c					if DEBUG_FORTH_WORDS 
062c					DMARK "FNI" 
062c f5				push af  
062d 3a 41 06			ld a, (.dmark)  
0630 32 bd fb			ld (debug_mark),a  
0633 3a 42 06			ld a, (.dmark+1)  
0636 32 be fb			ld (debug_mark+1),a  
0639 3a 43 06			ld a, (.dmark+2)  
063c 32 bf fb			ld (debug_mark+2),a  
063f 18 03			jr .pastdmark  
0641 ..			.dmark: db "FNI"  
0644 f1			.pastdmark: pop af  
0645			endm  
# End of macro DMARK
0645						CALLMONITOR 
0645 cd 6a 16			call break_point_state  
0648				endm  
# End of macro CALLMONITOR
0648					endif 
0648			.ff1:   	 
0648 e5					push hl 
0649 c5					push bc 
064a d5					push de 
064b cd 89 02				call se_readbyte 
064e 5f					ld e,a 
064f 23					inc hl 
0650 cd 89 02				call se_readbyte 
0653 57					ld d, a 
0654 e1					pop hl 
0655 e5					push hl 
0656 cd 24 0d				call cmp16 
0659 28 49				jr z, .fffound 
065b			 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is found? 
065e					;cp e 
065e					;ret z 
065e			 
065e 3e 40				ld a, STORE_BLOCK_PHY 
0660 cd 06 0d				call addatohl 
0663 10 e3				djnz .ff1 
0665			 
0665 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0667			.ff2:   	 
0667			 
0667 e5					push hl 
0668 c5					push bc 
0669 d5					push de 
066a cd 89 02				call se_readbyte 
066d 5f					ld e,a 
066e 23					inc hl 
066f cd 89 02				call se_readbyte 
0672 57					ld d, a 
0673			 
0673 e1					pop hl 
0674 e5					push hl 
0675 cd 24 0d				call cmp16 
0678 28 2a				jr z, .fffound 
067a			 
067a d1					pop de 
067b c1					pop bc 
067c e1					pop hl 
067d					; is found? 
067d					;cp e 
067d					;ret z 
067d			 
067d 3e 40				ld a, STORE_BLOCK_PHY 
067f cd 06 0d				call addatohl 
0682 10 e3				djnz .ff2 
0684			 
0684			 
0684					if DEBUG_FORTH_WORDS 
0684					DMARK "FN-" 
0684 f5				push af  
0685 3a 99 06			ld a, (.dmark)  
0688 32 bd fb			ld (debug_mark),a  
068b 3a 9a 06			ld a, (.dmark+1)  
068e 32 be fb			ld (debug_mark+1),a  
0691 3a 9b 06			ld a, (.dmark+2)  
0694 32 bf fb			ld (debug_mark+2),a  
0697 18 03			jr .pastdmark  
0699 ..			.dmark: db "FN-"  
069c f1			.pastdmark: pop af  
069d			endm  
# End of macro DMARK
069d					;	push af 
069d					;	ld a, 'n' 
069d					;	ld (debug_mark),a 
069d					;	pop af 
069d						CALLMONITOR 
069d cd 6a 16			call break_point_state  
06a0				endm  
# End of macro CALLMONITOR
06a0					endif 
06a0				; no free marks! 
06a0 21 00 00				ld hl, 0 
06a3 c9				ret 
06a4			.fffound: 
06a4				 
06a4			 
06a4 d1					pop de 
06a5 c1					pop bc 
06a6 e1					pop hl 
06a7					if DEBUG_FORTH_WORDS 
06a7					DMARK "FNF" 
06a7 f5				push af  
06a8 3a bc 06			ld a, (.dmark)  
06ab 32 bd fb			ld (debug_mark),a  
06ae 3a bd 06			ld a, (.dmark+1)  
06b1 32 be fb			ld (debug_mark+1),a  
06b4 3a be 06			ld a, (.dmark+2)  
06b7 32 bf fb			ld (debug_mark+2),a  
06ba 18 03			jr .pastdmark  
06bc ..			.dmark: db "FNF"  
06bf f1			.pastdmark: pop af  
06c0			endm  
# End of macro DMARK
06c0					;	push af 
06c0					;	ld a, 'n' 
06c0					;	ld (debug_mark),a 
06c0					;	pop af 
06c0						CALLMONITOR 
06c0 cd 6a 16			call break_point_state  
06c3				endm  
# End of macro CALLMONITOR
06c3					endif 
06c3 c9				ret 
06c4			 
06c4			 
06c4			 
06c4			; Free Space 
06c4			; ---------- 
06c4			; 
06c4			; With current bank 
06c4			; 
06c4			; Set block count to zero 
06c4			; Starting with first logical block 
06c4			;      Find free block  
06c4			;      If block id given, increment block count 
06c4			; 
06c4			;  
06c4			 
06c4			 
06c4			; hl contains count of free blocks 
06c4			 
06c4			storage_freeblocks: 
06c4			 
06c4				; now locate first 0 page to mark as a free block 
06c4			 
06c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c6 21 40 00			ld hl, STORE_BLOCK_PHY 
06c9 11 00 00			ld de, 0 
06cc			 
06cc			.fb1:   	 
06cc e5					push hl 
06cd c5					push bc 
06ce d5					push de 
06cf cd 89 02				call se_readbyte 
06d2 d1					pop de 
06d3 c1					pop bc 
06d4 e1					pop hl 
06d5			 
06d5					; is free? 
06d5 fe 00				cp 0 
06d7 20 01				jr nz, .ff1cont 
06d9 13					inc de 
06da			 
06da			.ff1cont: 
06da			 
06da			 
06da 3e 40				ld a, STORE_BLOCK_PHY 
06dc cd 06 0d				call addatohl 
06df 10 eb				djnz .fb1 
06e1			 
06e1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e3			.fb2:   	 
06e3 e5					push hl 
06e4 c5					push bc 
06e5 d5					push de 
06e6 cd 89 02				call se_readbyte 
06e9 d1					pop de 
06ea c1					pop bc 
06eb e1					pop hl 
06ec			 
06ec					; is free? 
06ec fe 00				cp 0 
06ee 20 01				jr nz, .ff2cont 
06f0 13					inc de 
06f1			 
06f1			.ff2cont: 
06f1			 
06f1 3e 40				ld a, STORE_BLOCK_PHY 
06f3 cd 06 0d				call addatohl 
06f6 10 eb				djnz .fb2 
06f8			 
06f8 eb				ex de, hl 
06f9 c9				ret 
06fa			 
06fa			; Get File ID 
06fa			; ----------- 
06fa			; 
06fa			; With current bank 
06fa			;  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; For each logical block 
06fa			;    Read block file id 
06fa			;      If first block of file and dont have file id 
06fa			;         if file get id and exit 
06fa			 
06fa			 
06fa			 
06fa			 
06fa			; Create File 
06fa			; ----------- 
06fa			; 
06fa			; With current bank  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; Increment file id number 
06fa			; Save Config 
06fa			; Find free block 
06fa			; Set buffer with file name and file id 
06fa			; Write buffer to free block  
06fa			 
06fa			 
06fa			; hl point to file name 
06fa			; hl returns file id 
06fa			 
06fa			; file format: 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent number 
06fa			; byte 2-> data 
06fa			 
06fa			; format for extent number 0: 
06fa			; 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent 0 
06fa			; byte 2 - extent count 
06fa			; byte 3 -> file name and meta data 
06fa			 
06fa			 
06fa			storage_create: 
06fa				if DEBUG_STORESE 
06fa					DMARK "SCR" 
06fa f5				push af  
06fb 3a 0f 07			ld a, (.dmark)  
06fe 32 bd fb			ld (debug_mark),a  
0701 3a 10 07			ld a, (.dmark+1)  
0704 32 be fb			ld (debug_mark+1),a  
0707 3a 11 07			ld a, (.dmark+2)  
070a 32 bf fb			ld (debug_mark+2),a  
070d 18 03			jr .pastdmark  
070f ..			.dmark: db "SCR"  
0712 f1			.pastdmark: pop af  
0713			endm  
# End of macro DMARK
0713					CALLMONITOR 
0713 cd 6a 16			call break_point_state  
0716				endm  
# End of macro CALLMONITOR
0716				endif 
0716			 
0716 e5				push hl		; save file name pointer 
0717			 
0717 cd ba 03			call storage_get_block_0 
071a			 
071a 3a e8 f9			ld a,(store_page)	; get current file id 
071d 3c				inc a 
071e 32 e8 f9			ld (store_page),a 
0721				 
0721 32 e1 f9			ld (store_tmpid),a			; save id 
0724			 
0724 21 00 00			ld hl, 0 
0727 11 e8 f9			ld de, store_page 
072a				if DEBUG_STORESE 
072a					DMARK "SCw" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 bd fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 be fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 bf fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCw"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd 6a 16			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 cd 6e 03			call storage_write_block	 ; save update 
0749			 
0749				if DEBUG_STORESE 
0749 11 e8 f9				ld de, store_page 
074c					DMARK "SCC" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 bd fb			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 be fb			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 bf fb			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "SCC"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765					CALLMONITOR 
0765 cd 6a 16			call break_point_state  
0768				endm  
# End of macro CALLMONITOR
0768				endif 
0768				;  
0768				 
0768 21 40 00			ld hl, STORE_BLOCK_PHY 
076b 11 00 00			ld de, 0 
076e cd 2a 06			call storage_findnextid 
0771			 
0771 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0774			 
0774				; TODO detect 0 = no spare blocks 
0774			 
0774				; hl now contains the free page to use for the file header page 
0774			 
0774				if DEBUG_STORESE 
0774				DMARK "SCF" 
0774 f5				push af  
0775 3a 89 07			ld a, (.dmark)  
0778 32 bd fb			ld (debug_mark),a  
077b 3a 8a 07			ld a, (.dmark+1)  
077e 32 be fb			ld (debug_mark+1),a  
0781 3a 8b 07			ld a, (.dmark+2)  
0784 32 bf fb			ld (debug_mark+2),a  
0787 18 03			jr .pastdmark  
0789 ..			.dmark: db "SCF"  
078c f1			.pastdmark: pop af  
078d			endm  
# End of macro DMARK
078d					CALLMONITOR 
078d cd 6a 16			call break_point_state  
0790				endm  
# End of macro CALLMONITOR
0790				endif 
0790			 
0790 22 d2 f9			ld (store_tmppageid), hl 
0793				 
0793 3a e1 f9			ld a,(store_tmpid)    ; get file id 
0796			;	ld a, (store_filecache)			; save to cache 
0796			 
0796 32 e8 f9			ld (store_page),a    ; set page id 
0799 3e 00			ld a, 0			 ; extent 0 is file header 
079b 32 e9 f9			ld (store_page+1), a   ; set file extent 
079e			 
079e 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a1			 
07a1			;	inc hl 		; init block 0 of file 
07a1			;	inc hl   		; skip file and extent id 
07a1			 ;       ld a, 0 
07a1			;	ld (hl),a 
07a1			;	ld a, (store_filecache+1)  	; save to cache 
07a1			 
07a1			;	inc hl    ; file name 
07a1				 
07a1				 
07a1 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a4				if DEBUG_STORESE 
07a4					DMARK "SCc" 
07a4 f5				push af  
07a5 3a b9 07			ld a, (.dmark)  
07a8 32 bd fb			ld (debug_mark),a  
07ab 3a ba 07			ld a, (.dmark+1)  
07ae 32 be fb			ld (debug_mark+1),a  
07b1 3a bb 07			ld a, (.dmark+2)  
07b4 32 bf fb			ld (debug_mark+2),a  
07b7 18 03			jr .pastdmark  
07b9 ..			.dmark: db "SCc"  
07bc f1			.pastdmark: pop af  
07bd			endm  
# End of macro DMARK
07bd					CALLMONITOR 
07bd cd 6a 16			call break_point_state  
07c0				endm  
# End of macro CALLMONITOR
07c0				endif 
07c0 e1				pop hl    ; get zero term string 
07c1 e5				push hl 
07c2 3e 00			ld a, 0 
07c4 cd 6f 11			call strlent 
07c7 23				inc hl   ; cover zero term 
07c8 06 00			ld b,0 
07ca 4d				ld c,l 
07cb e1				pop hl 
07cc				;ex de, hl 
07cc				if DEBUG_STORESE 
07cc					DMARK "SCa" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 bd fb			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 be fb			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 bf fb			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "SCa"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;push af 
07e5					;ld a, 'a' 
07e5					;ld (debug_mark),a 
07e5					;pop af 
07e5					CALLMONITOR 
07e5 cd 6a 16			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8				endif 
07e8 ed b0			ldir    ; copy zero term string 
07ea				if DEBUG_STORESE 
07ea					DMARK "SCA" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 bd fb			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 be fb			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 bf fb			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "SCA"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 6a 16			call break_point_state  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806			 
0806				; write file header page 
0806			 
0806 2a d2 f9			ld hl,(store_tmppageid) 
0809 11 e8 f9			ld de, store_page 
080c				if DEBUG_STORESE 
080c					DMARK "SCb" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 bd fb			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 be fb			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 bf fb			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "SCb"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					;push af 
0825					;ld a, 'b' 
0825					;ld (debug_mark),a 
0825					;pop af 
0825					CALLMONITOR 
0825 cd 6a 16			call break_point_state  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 6e 03			call storage_write_block 
082b			 
082b 3a e1 f9			ld a, (store_tmpid) 
082e 6f				ld l, a 
082f 26 00			ld h,0 
0831				if DEBUG_STORESE 
0831					DMARK "SCz" 
0831 f5				push af  
0832 3a 46 08			ld a, (.dmark)  
0835 32 bd fb			ld (debug_mark),a  
0838 3a 47 08			ld a, (.dmark+1)  
083b 32 be fb			ld (debug_mark+1),a  
083e 3a 48 08			ld a, (.dmark+2)  
0841 32 bf fb			ld (debug_mark+2),a  
0844 18 03			jr .pastdmark  
0846 ..			.dmark: db "SCz"  
0849 f1			.pastdmark: pop af  
084a			endm  
# End of macro DMARK
084a					CALLMONITOR 
084a cd 6a 16			call break_point_state  
084d				endm  
# End of macro CALLMONITOR
084d				endif 
084d c9				ret 
084e				 
084e			 
084e			 
084e			; 
084e			; Read File 
084e			; 
084e			; h - file id to locate 
084e			; l - extent to locate 
084e			; de - pointer to string to read into 
084e			; 
084e			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084e			storage_read: 
084e d5				push de 
084f			 
084f			; TODO BUG the above push is it popped before the RET Z? 
084f			 
084f			; TODO how to handle multiple part blocks 
084f			 
084f				; locate file extent to read 
084f			 
084f 5c				ld e, h 
0850 55				ld d, l 
0851 21 40 00			ld hl, STORE_BLOCK_PHY 
0854				if DEBUG_STORESE 
0854					DMARK "SRE" 
0854 f5				push af  
0855 3a 69 08			ld a, (.dmark)  
0858 32 bd fb			ld (debug_mark),a  
085b 3a 6a 08			ld a, (.dmark+1)  
085e 32 be fb			ld (debug_mark+1),a  
0861 3a 6b 08			ld a, (.dmark+2)  
0864 32 bf fb			ld (debug_mark+2),a  
0867 18 03			jr .pastdmark  
0869 ..			.dmark: db "SRE"  
086c f1			.pastdmark: pop af  
086d			endm  
# End of macro DMARK
086d					CALLMONITOR 
086d cd 6a 16			call break_point_state  
0870				endm  
# End of macro CALLMONITOR
0870				endif 
0870 cd 2a 06			call storage_findnextid 
0873			 
0873				if DEBUG_STORESE 
0873					DMARK "SRf" 
0873 f5				push af  
0874 3a 88 08			ld a, (.dmark)  
0877 32 bd fb			ld (debug_mark),a  
087a 3a 89 08			ld a, (.dmark+1)  
087d 32 be fb			ld (debug_mark+1),a  
0880 3a 8a 08			ld a, (.dmark+2)  
0883 32 bf fb			ld (debug_mark+2),a  
0886 18 03			jr .pastdmark  
0888 ..			.dmark: db "SRf"  
088b f1			.pastdmark: pop af  
088c			endm  
# End of macro DMARK
088c					CALLMONITOR 
088c cd 6a 16			call break_point_state  
088f				endm  
# End of macro CALLMONITOR
088f				endif 
088f cd 2f 0d			call ishlzero 
0892			;	ld a, l 
0892			;	add h 
0892			;	cp 0 
0892 c8				ret z			; block not found so EOF 
0893			 
0893				; hl contains page number to load 
0893 d1				pop de   ; get storage 
0894 d5				push de 
0895				if DEBUG_STORESE 
0895					DMARK "SRg" 
0895 f5				push af  
0896 3a aa 08			ld a, (.dmark)  
0899 32 bd fb			ld (debug_mark),a  
089c 3a ab 08			ld a, (.dmark+1)  
089f 32 be fb			ld (debug_mark+1),a  
08a2 3a ac 08			ld a, (.dmark+2)  
08a5 32 bf fb			ld (debug_mark+2),a  
08a8 18 03			jr .pastdmark  
08aa ..			.dmark: db "SRg"  
08ad f1			.pastdmark: pop af  
08ae			endm  
# End of macro DMARK
08ae					CALLMONITOR 
08ae cd 6a 16			call break_point_state  
08b1				endm  
# End of macro CALLMONITOR
08b1				endif 
08b1 cd 09 03			call storage_read_block 
08b4			 
08b4			 
08b4			; TODO if block has no zeros then need to read next block  
08b4			 
08b4			 
08b4					 
08b4 e1				pop hl 		 ; return start of data to show as not EOF 
08b5 23				inc hl   ; past file id 
08b6 23				inc hl   ; past ext 
08b7				if DEBUG_STORESE 
08b7					DMARK "SRe" 
08b7 f5				push af  
08b8 3a cc 08			ld a, (.dmark)  
08bb 32 bd fb			ld (debug_mark),a  
08be 3a cd 08			ld a, (.dmark+1)  
08c1 32 be fb			ld (debug_mark+1),a  
08c4 3a ce 08			ld a, (.dmark+2)  
08c7 32 bf fb			ld (debug_mark+2),a  
08ca 18 03			jr .pastdmark  
08cc ..			.dmark: db "SRe"  
08cf f1			.pastdmark: pop af  
08d0			endm  
# End of macro DMARK
08d0					CALLMONITOR 
08d0 cd 6a 16			call break_point_state  
08d3				endm  
# End of macro CALLMONITOR
08d3				endif 
08d3 c9					ret 
08d4			 
08d4			 
08d4			 
08d4			; 
08d4			; Append File 
08d4			; 
08d4			; hl - file id to locate 
08d4			; de - pointer to (multi block) string to write 
08d4			 
08d4			 
08d4			storage_append: 
08d4				; hl -  file id to append to 
08d4				; de - string to append 
08d4			 
08d4 d5				push de 
08d5				 
08d5				if DEBUG_STORESE 
08d5					DMARK "AP1" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 bd fb			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 be fb			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 bf fb			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "AP1"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 6a 16			call break_point_state  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1			 
08f1 7d				ld a, l 
08f2 32 e1 f9			ld (store_tmpid), a 
08f5			 
08f5				; get file header  
08f5			 
08f5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08f7 3a e1 f9			ld a, (store_tmpid) 
08fa 5f				ld e, a 
08fb			 
08fb 21 40 00				ld hl, STORE_BLOCK_PHY 
08fe cd 2a 06				call storage_findnextid 
0901			 
0901 22 d2 f9			ld (store_tmppageid), hl 
0904			 
0904				; TODO handle file id not found 
0904			 
0904				if DEBUG_STORESE 
0904					DMARK "AP2" 
0904 f5				push af  
0905 3a 19 09			ld a, (.dmark)  
0908 32 bd fb			ld (debug_mark),a  
090b 3a 1a 09			ld a, (.dmark+1)  
090e 32 be fb			ld (debug_mark+1),a  
0911 3a 1b 09			ld a, (.dmark+2)  
0914 32 bf fb			ld (debug_mark+2),a  
0917 18 03			jr .pastdmark  
0919 ..			.dmark: db "AP2"  
091c f1			.pastdmark: pop af  
091d			endm  
# End of macro DMARK
091d					CALLMONITOR 
091d cd 6a 16			call break_point_state  
0920				endm  
# End of macro CALLMONITOR
0920				endif 
0920			 
0920				; update file extent count 
0920			 
0920 11 e8 f9			ld de, store_page 
0923			 
0923 cd 09 03			call storage_read_block 
0926			 
0926				if DEBUG_STORESE 
0926					DMARK "AP3" 
0926 f5				push af  
0927 3a 3b 09			ld a, (.dmark)  
092a 32 bd fb			ld (debug_mark),a  
092d 3a 3c 09			ld a, (.dmark+1)  
0930 32 be fb			ld (debug_mark+1),a  
0933 3a 3d 09			ld a, (.dmark+2)  
0936 32 bf fb			ld (debug_mark+2),a  
0939 18 03			jr .pastdmark  
093b ..			.dmark: db "AP3"  
093e f1			.pastdmark: pop af  
093f			endm  
# End of macro DMARK
093f					CALLMONITOR 
093f cd 6a 16			call break_point_state  
0942				endm  
# End of macro CALLMONITOR
0942				endif 
0942			;	ld (store_tmppageid), hl 
0942			 
0942 3a ea f9			ld a, (store_page+2) 
0945 3c				inc a 
0946 32 ea f9			ld (store_page+2), a 
0949 32 e0 f9			ld (store_tmpext), a 
094c				 
094c				if DEBUG_STORESE 
094c					DMARK "AP3" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 bd fb			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 be fb			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 bf fb			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "AP3"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 6a 16			call break_point_state  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 2a d2 f9			ld hl, (store_tmppageid) 
096b 11 e8 f9			ld de, store_page 
096e cd 6e 03			call storage_write_block 
0971			 
0971				; find free block 
0971			 
0971 11 00 00			ld de, 0			 ; file extent to locate 
0974			 
0974 21 40 00				ld hl, STORE_BLOCK_PHY 
0977 cd 2a 06				call storage_findnextid 
097a			 
097a					; TODO handle no space left 
097a					 
097a 22 d2 f9				ld (store_tmppageid), hl 
097d			 
097d				if DEBUG_STORESE 
097d					DMARK "AP4" 
097d f5				push af  
097e 3a 92 09			ld a, (.dmark)  
0981 32 bd fb			ld (debug_mark),a  
0984 3a 93 09			ld a, (.dmark+1)  
0987 32 be fb			ld (debug_mark+1),a  
098a 3a 94 09			ld a, (.dmark+2)  
098d 32 bf fb			ld (debug_mark+2),a  
0990 18 03			jr .pastdmark  
0992 ..			.dmark: db "AP4"  
0995 f1			.pastdmark: pop af  
0996			endm  
# End of macro DMARK
0996					CALLMONITOR 
0996 cd 6a 16			call break_point_state  
0999				endm  
# End of macro CALLMONITOR
0999				endif 
0999					; init the buffer with zeros so we can id if the buffer is full or not 
0999			 
0999 e5					push hl 
099a c5					push bc 
099b			 
099b 21 e8 f9				ld hl, store_page 
099e 06 40				ld b, STORE_BLOCK_PHY 
09a0 3e 00				ld a, 0 
09a2 77			.zeroblock:	ld (hl), a 
09a3 23					inc hl 
09a4 10 fc				djnz .zeroblock 
09a6			 
09a6 c1					pop bc 
09a7 e1					pop hl 
09a8			 
09a8					; construct block 
09a8			 
09a8 3a e1 f9				ld a, (store_tmpid) 
09ab 32 e8 f9				ld (store_page), a   ; file id 
09ae 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09b1 32 e9 f9				ld (store_page+1), a 
09b4			 
09b4 e1					pop hl    ; get string to write 
09b5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b7 11 ea f9				ld de, store_page+2 
09ba			 
09ba				if DEBUG_STORESE 
09ba					DMARK "AP5" 
09ba f5				push af  
09bb 3a cf 09			ld a, (.dmark)  
09be 32 bd fb			ld (debug_mark),a  
09c1 3a d0 09			ld a, (.dmark+1)  
09c4 32 be fb			ld (debug_mark+1),a  
09c7 3a d1 09			ld a, (.dmark+2)  
09ca 32 bf fb			ld (debug_mark+2),a  
09cd 18 03			jr .pastdmark  
09cf ..			.dmark: db "AP5"  
09d2 f1			.pastdmark: pop af  
09d3			endm  
# End of macro DMARK
09d3					CALLMONITOR 
09d3 cd 6a 16			call break_point_state  
09d6				endm  
# End of macro CALLMONITOR
09d6				endif 
09d6			 
09d6			 
09d6			 
09d6					; fill buffer with data until end of string or full block 
09d6			 
09d6 7e			.appd:		ld a, (hl) 
09d7 12					ld (de), a 
09d8 fe 00				cp 0 
09da 28 04				jr z, .appdone 
09dc 23					inc hl 
09dd 13					inc de 
09de 10 f6				djnz .appd 
09e0			 
09e0 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e1 f5					push af   		; save last byte dumped 
09e2			 
09e2			 
09e2 2a d2 f9			ld hl, (store_tmppageid) 
09e5 11 e8 f9			ld de, store_page 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP6" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 bd fb			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 be fb			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 bf fb			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP6"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 6a 16			call break_point_state  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 cd 6e 03				call storage_write_block 
0a07			 
0a07			 
0a07				; was that a full block of data written? 
0a07				; any more to write out? 
0a07			 
0a07				; if yes then set vars and jump to start of function again 
0a07			 
0a07 f1					pop af 
0a08 d1					pop de 
0a09			 
0a09 fe 00				cp 0		 ; no, string was fully written 
0a0b c8					ret z 
0a0c			 
0a0c					; setup vars for next cycle 
0a0c			 
0a0c 3a e1 f9				ld a, (store_tmpid) 
0a0f 6f					ld l, a 
0a10 26 00				ld h, 0 
0a12			 
0a12 c3 d4 08			 	jp storage_append	 ; yes, need to write out some more 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			if DEBUG_STORECF 
0a15			storageput:	 
0a15					ret 
0a15			storageread: 
0a15					ld hl, store_page 
0a15					ld b, 200 
0a15					ld a,0 
0a15			.src:		ld (hl),a 
0a15					inc hl 
0a15					djnz .src 
0a15					 
0a15			 
0a15					ld de, 0 
0a15					ld bc, 1 
0a15					ld hl, store_page 
0a15					call cfRead 
0a15			 
0a15				call cfGetError 
0a15				ld hl,scratch 
0a15				call hexout 
0a15				ld hl, scratch+2 
0a15				ld a, 0 
0a15				ld (hl),a 
0a15				ld de, scratch 
0a15				ld a,display_row_1 
0a15				call str_at_display 
0a15				call update_display 
0a15			 
0a15					ld hl, store_page 
0a15					ld (os_cur_ptr),hl 
0a15			 
0a15					ret 
0a15			endif 
0a15			 
0a15			 
0a15			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a15			 
0a15			storage_clear_page: 
0a15 e5				push hl 
0a16 d5				push de 
0a17 c5				push bc 
0a18 21 e8 f9			ld hl, store_page 
0a1b 3e 00			ld a, 0 
0a1d 77				ld (hl), a 
0a1e			 
0a1e 11 e9 f9			ld de, store_page+1 
0a21 01 40 00			ld bc, STORE_BLOCK_PHY 
0a24			 
0a24 ed b0			ldir 
0a26				 
0a26 c1				pop bc 
0a27 d1				pop de 
0a28 e1				pop hl 
0a29 c9				ret 
0a2a			 
0a2a			; eof 
# End of file firmware_storage.asm
0a2a			  
0a2a			; support routines for above hardware abstraction layer  
0a2a			  
0a2a			include "firmware_general.asm"        ; general support functions  
0a2a			 
0a2a			; word look up 
0a2a			 
0a2a			; in 
0a2a			; a is the index 
0a2a			; hl is pointer start of array 
0a2a			; 
0a2a			; returns 
0a2a			; hl to the word 
0a2a			; 
0a2a			 
0a2a			table_lookup:  
0a2a d5					push de 
0a2b eb					ex de, hl 
0a2c			 
0a2c 6f					ld l, a 
0a2d 26 00				ld h, 0 
0a2f 29					add hl, hl 
0a30 19					add hl, de 
0a31 7e					ld a, (hl) 
0a32 23					inc hl 
0a33 66					ld h,(hl) 
0a34 6f					ld l, a 
0a35			 
0a35 d1					pop de 
0a36 c9					ret 
0a37			 
0a37			; Delay loops 
0a37			 
0a37			 
0a37			 
0a37			aDelayInMS: 
0a37 c5				push bc 
0a38 47				ld b,a 
0a39			msdelay: 
0a39 c5				push bc 
0a3a				 
0a3a			 
0a3a 01 41 00			ld bc,041h 
0a3d cd 55 0a			call delayloop 
0a40 c1				pop bc 
0a41 05				dec b 
0a42 20 f5			jr nz,msdelay 
0a44			 
0a44			;if CPU_CLOCK_8MHZ 
0a44			;msdelay8: 
0a44			;	push bc 
0a44			;	 
0a44			; 
0a44			;	ld bc,041h 
0a44			;	call delayloop 
0a44			;	pop bc 
0a44			;	dec b 
0a44			;	jr nz,msdelay8 
0a44			;endif 
0a44			 
0a44			 
0a44 c1				pop bc 
0a45 c9				ret 
0a46			 
0a46			 
0a46			delay250ms: 
0a46				;push de 
0a46 01 00 40			ld bc, 04000h 
0a49 c3 55 0a			jp delayloop 
0a4c			delay500ms: 
0a4c				;push de 
0a4c 01 00 80			ld bc, 08000h 
0a4f c3 55 0a			jp delayloop 
0a52			delay1s: 
0a52				;push bc 
0a52			   ; Clobbers A, d and e 
0a52 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a55			delayloop: 
0a55 c5			    push bc 
0a56			 
0a56			if BASE_CPM 
0a56				ld bc, CPM_DELAY_TUNE 
0a56			.cpmloop: 
0a56				push bc 
0a56			 
0a56			endif 
0a56			 
0a56			 
0a56			 
0a56			delayloopi: 
0a56			;	push bc 
0a56			;.dl: 
0a56 cb 47		    bit     0,a    	; 8 
0a58 cb 47		    bit     0,a    	; 8 
0a5a cb 47		    bit     0,a    	; 8 
0a5c e6 ff		    and     255  	; 7 
0a5e 0b			    dec     bc      	; 6 
0a5f 79			    ld      a,c     	; 4 
0a60 b0			    or      b     	; 4 
0a61 c2 56 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a64			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a64				;pop de 
0a64			;pop bc 
0a64			 
0a64			if BASE_CPM 
0a64				pop bc 
0a64				 
0a64			    dec     bc      	; 6 
0a64			    ld      a,c     	; 4 
0a64			    or      b     	; 4 
0a64			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a64				 
0a64			 
0a64			endif 
0a64			;if CPU_CLOCK_8MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64			 
0a64			;if CPU_CLOCK_10MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64 c1			    pop bc 
0a65			 
0a65 c9				ret 
0a66			 
0a66			 
0a66			 
0a66			; eof 
# End of file firmware_general.asm
0a66			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a66			; display routines that use the physical hardware abstraction layer 
0a66			 
0a66			 
0a66			; information window 
0a66			 
0a66			; pass hl with 1st string to display 
0a66			; pass de with 2nd string to display 
0a66			 
0a66			info_panel: 
0a66 e5				push hl 
0a67			 
0a67 2a 5e fa			ld hl, (display_fb_active) 
0a6a e5				push hl    ; future de destination 
0a6b 21 53 fb				ld hl, display_fb0 
0a6e 22 5e fa				ld (display_fb_active), hl 
0a71			 
0a71 cd d2 0a			call clear_display 
0a74			 
0a74			 
0a74 3e 2d			ld a, display_row_3 + 5 
0a76 cd e5 0a			call str_at_display 
0a79			 
0a79 e1				pop hl 
0a7a d1				pop de 
0a7b			 
0a7b e5				push hl 
0a7c			 
0a7c			 
0a7c 3e 19			ld a, display_row_2 + 5 
0a7e cd e5 0a			call str_at_display 
0a81			 
0a81			 
0a81 cd f5 0a			call update_display 
0a84 cd 72 1b			call next_page_prompt 
0a87 cd d2 0a			call clear_display 
0a8a			 
0a8a				 
0a8a 21 02 fb				ld hl, display_fb1 
0a8d 22 5e fa				ld (display_fb_active), hl 
0a90 cd f5 0a			call update_display 
0a93			 
0a93			 
0a93 c9				ret 
0a94			 
0a94			 
0a94			 
0a94			 
0a94			; TODO windowing? 
0a94			 
0a94			; TODO scroll line up 
0a94			 
0a94			scroll_up: 
0a94			 
0a94 e5				push hl 
0a95 d5				push de 
0a96 c5				push bc 
0a97			 
0a97				; get frame buffer  
0a97			 
0a97 2a 5e fa			ld hl, (display_fb_active) 
0a9a e5				push hl    ; future de destination 
0a9b			 
0a9b 11 14 00			ld  de, display_cols 
0a9e 19				add hl, de 
0a9f			 
0a9f d1				pop de 
0aa0			 
0aa0				;ex de, hl 
0aa0 01 4f 00			ld bc, display_fb_len -1  
0aa3			;if DEBUG_FORTH_WORDS 
0aa3			;	DMARK "SCL" 
0aa3			;	CALLMONITOR 
0aa3			;endif	 
0aa3 ed b0			ldir 
0aa5			 
0aa5				; wipe bottom row 
0aa5			 
0aa5			 
0aa5 2a 5e fa			ld hl, (display_fb_active) 
0aa8 11 50 00			ld de, display_cols*display_rows 
0aab 19				add hl, de 
0aac 06 14			ld b, display_cols 
0aae 3e 20			ld a, ' ' 
0ab0			.scwipe: 
0ab0 77				ld (hl), a 
0ab1 2b				dec hl 
0ab2 10 fc			djnz .scwipe 
0ab4			 
0ab4				;pop hl 
0ab4			 
0ab4 c1				pop bc 
0ab5 d1				pop de 
0ab6 e1				pop hl 
0ab7			 
0ab7 c9				ret 
0ab8			 
0ab8			 
0ab8			;scroll_upo: 
0ab8			;	ld de, display_row_1 
0ab8			 ;	ld hl, display_row_2 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_2 
0ab8			 ;	ld hl, display_row_3 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_3 
0ab8			 ;	ld hl, display_row_4 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			 
0ab8			; TODO clear row 4 
0ab8			 
0ab8			;	ret 
0ab8			 
0ab8				 
0ab8			scroll_down: 
0ab8			 
0ab8 e5				push hl 
0ab9 d5				push de 
0aba c5				push bc 
0abb			 
0abb				; get frame buffer  
0abb			 
0abb 2a 5e fa			ld hl, (display_fb_active) 
0abe			 
0abe 11 4f 00			ld de, display_fb_len - 1 
0ac1 19				add hl, de 
0ac2			 
0ac2 e5			push hl    ; future de destination 
0ac3			 
0ac3 11 14 00			ld  de, display_cols 
0ac6 ed 52			sbc hl, de 
0ac8			 
0ac8			 
0ac8 d1				pop de 
0ac9			 
0ac9			;	ex de, hl 
0ac9 01 4f 00			ld bc, display_fb_len -1  
0acc			 
0acc			 
0acc				 
0acc			 
0acc ed b0			ldir 
0ace			 
0ace				; wipe bottom row 
0ace			 
0ace			 
0ace			;	ld hl, (display_fb_active) 
0ace			;;	ld de, display_cols*display_rows 
0ace			;;	add hl, de 
0ace			;	ld b, display_cols 
0ace			;	ld a, ' ' 
0ace			;.scwiped: 
0ace			;	ld (hl), a 
0ace			;	dec hl 
0ace			;	djnz .scwiped 
0ace			 
0ace				;pop hl 
0ace			 
0ace c1				pop bc 
0acf d1				pop de 
0ad0 e1				pop hl 
0ad1			 
0ad1 c9				ret 
0ad2			;scroll_down: 
0ad2			;	ld de, display_row_4 
0ad2			;	ld hl, display_row_3 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_3 
0ad2			; 	ld hl, display_row_2 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_2 
0ad2			;	ld hl, display_row_1 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;;; TODO clear row 1 
0ad2			;	ret 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			; clear active frame buffer 
0ad2			 
0ad2			clear_display: 
0ad2 3e 20			ld a, ' ' 
0ad4 c3 d7 0a			jp fill_display 
0ad7			 
0ad7			; fill active frame buffer with a char in A 
0ad7			 
0ad7			fill_display: 
0ad7 06 50			ld b,display_fb_len 
0ad9 2a 5e fa			ld hl, (display_fb_active) 
0adc 77			.fd1:	ld (hl),a 
0add 23				inc hl 
0ade 10 fc			djnz .fd1 
0ae0 23				inc hl 
0ae1 3e 00			ld a,0 
0ae3 77				ld (hl),a 
0ae4			 
0ae4			 
0ae4 c9				ret 
0ae5			; Write string (DE) at pos (A) to active frame buffer 
0ae5			 
0ae5 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0ae8 06 00					ld b,0 
0aea 4f					ld c,a 
0aeb 09					add hl,bc 
0aec 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aed b7			            OR   A              ;Null terminator? 
0aee c8			            RET  Z              ;Yes, so finished 
0aef 77					ld (hl),a 
0af0 23				inc hl 
0af1 13			            INC  DE             ;Point to next character 
0af2 18 f8		            JR   .sad1     ;Repeat 
0af4 c9					ret 
0af5			 
0af5			; using current frame buffer write to physical display 
0af5			 
0af5			update_display: 
0af5 e5				push hl 
0af6 2a 5e fa			ld hl, (display_fb_active) 
0af9 cd 02 65			call write_display 
0afc e1				pop hl 
0afd c9				ret 
0afe			 
0afe			; TODO scrolling 
0afe			 
0afe			 
0afe			; move cursor right one char 
0afe			cursor_right: 
0afe			 
0afe				; TODO shift right 
0afe				; TODO if beyond max col 
0afe				; TODO       cursor_next_line 
0afe			 
0afe c9				ret 
0aff			 
0aff			 
0aff			cursor_next_line: 
0aff				; TODO first char 
0aff				; TODO line down 
0aff				; TODO if past last row 
0aff				; TODO    scroll up 
0aff			 
0aff c9				ret 
0b00			 
0b00			cursor_left: 
0b00				; TODO shift left 
0b00				; TODO if beyond left  
0b00				; TODO     cursor prev line 
0b00				 
0b00 c9				ret 
0b01			 
0b01			cursor_prev_line: 
0b01				; TODO last char 
0b01				; TODO line up 
0b01				; TODO if past first row 
0b01				; TODO   scroll down 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cout: 
0b02				; A - char 
0b02 c9				ret 
0b03			 
0b03			 
0b03			; Display a menu and allow item selection (optional toggle items) 
0b03			; 
0b03			; format: 
0b03			; hl pointer to word array with zero term for items 
0b03			; e.g.    db item1 
0b03			;         db .... 
0b03			;         db 0 
0b03			; 
0b03			; a = starting menu item  
0b03			; 
0b03			; de = pointer item toggle array   (todo) 
0b03			; 
0b03			; returns item selected in a 1-... 
0b03			; returns 0 if back button pressed 
0b03			; 
0b03			; NOTE: Uses system frame buffer to display 
0b03			; 
0b03			; LEFT, Q = go back 
0b03			; RIGHT, SPACE, CR = select 
0b03			; UP, A - Up 
0b03			; DOWN, Z - Down 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			menu: 
0b03			 
0b03					; keep array pointer 
0b03			 
0b03 22 e6 f9				ld (store_tmp1), hl 
0b06 32 e4 f9				ld (store_tmp2), a 
0b09			 
0b09					; check for key bounce 
0b09			 
0b09			if BASE_KEV 
0b09			 
0b09 cd b7 66		.mbounce:	call cin 
0b0c fe 00				cp 0 
0b0e 20 f9				jr nz, .mbounce 
0b10			endif 
0b10					; for ease use ex 
0b10			 
0b10					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b10 21 53 fb				ld hl, display_fb0 
0b13 22 5e fa				ld (display_fb_active), hl 
0b16			 
0b16 cd d2 0a		.mloop:		call clear_display 
0b19 cd f5 0a				call update_display 
0b1c			 
0b1c					; draw selection id '>' at 1 
0b1c			 
0b1c					; init start of list display 
0b1c			 
0b1c 3e 05				ld a, 5 
0b1e 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b21 3a e4 f9				ld a,( store_tmp2) 
0b24 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b27			 
0b27					 
0b27			.mitem:	 
0b27			 
0b27			 
0b27 3a e5 f9				ld a,(store_tmp2+1) 
0b2a 6f					ld l, a 
0b2b 26 00				ld h, 0 
0b2d 29					add hl, hl 
0b2e ed 5b e6 f9			ld de, (store_tmp1) 
0b32 19					add hl, de 
0b33 7e					ld a, (hl) 
0b34 23					inc hl 
0b35 66					ld h,(hl) 
0b36 6f					ld l, a 
0b37			 
0b37 cd 2f 0d				call ishlzero 
0b3a 28 1a				jr z, .mdone 
0b3c			 
0b3c eb					ex de, hl 
0b3d 3a e2 f9				ld a, (store_tmp3) 
0b40 cd e5 0a				call str_at_display 
0b43					 
0b43			 
0b43					; next item 
0b43 3a e5 f9				ld a, (store_tmp2+1) 
0b46 3c					inc a 
0b47 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b4a			 
0b4a			 		; next row 
0b4a			 
0b4a 3a e2 f9				ld a, (store_tmp3) 
0b4d c6 14				add display_cols 
0b4f 32 e2 f9				ld (store_tmp3), a 
0b52			 
0b52					; at end of screen? 
0b52			 
0b52 fe 10				cp display_rows*4 
0b54 20 d1				jr nz, .mitem 
0b56			 
0b56			 
0b56			.mdone: 
0b56 cd 2f 0d				call ishlzero 
0b59 28 08				jr z, .nodn 
0b5b			 
0b5b 3e 3c				ld a, display_row_4 
0b5d 11 dc 0b				ld de, .mdown 
0b60 cd e5 0a				call str_at_display 
0b63			 
0b63					; draw options to fill the screens with active item on line 1 
0b63					; if current option is 2 or more then display ^ in top 
0b63			 
0b63 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b66 fe 00				cp 0 
0b68 28 08				jr z, .noup 
0b6a			 
0b6a 3e 00				ld a, 0 
0b6c 11 da 0b				ld de, .mup 
0b6f cd e5 0a				call str_at_display 
0b72			 
0b72 3e 02		.noup:		ld a, 2 
0b74 11 d8 0b				ld de, .msel 
0b77 cd e5 0a				call str_at_display 
0b7a			 
0b7a					; if current option + 1 is not null then display V in bottom 
0b7a					; get key 
0b7a cd f5 0a				call update_display 
0b7d			 
0b7d			 
0b7d					; handle key 
0b7d			 
0b7d cd a6 66				call cin_wait 
0b80			 
0b80 fe 05				cp KEY_UP 
0b82 28 2b				jr z, .mgoup 
0b84 fe 61				cp 'a' 
0b86 28 27				jr z, .mgoup 
0b88 fe 0a				cp KEY_DOWN 
0b8a 28 32				jr z, .mgod 
0b8c fe 7a				cp 'z' 
0b8e 28 2e				jr z, .mgod 
0b90 fe 20				cp ' ' 
0b92 28 34				jr z, .goend 
0b94 fe 0c				cp KEY_RIGHT 
0b96 28 30				jr z, .goend 
0b98 fe 0d				cp KEY_CR 
0b9a 28 2c				jr z, .goend 
0b9c fe 71				cp 'q' 
0b9e 28 0b				jr z, .goback 
0ba0			 
0ba0 fe 0b				cp KEY_LEFT 
0ba2 28 07				jr z, .goback 
0ba4 fe 08				cp KEY_BS 
0ba6 28 03				jr z, .goback 
0ba8 c3 16 0b				jp .mloop 
0bab			 
0bab			.goback: 
0bab 3e 00			ld a, 0 
0bad 18 1d			jr .goend2 
0baf			 
0baf				; move up one 
0baf			.mgoup: 
0baf 3a e4 f9				ld a, (store_tmp2) 
0bb2 fe 00				cp 0 
0bb4 ca 16 0b				jp z, .mloop 
0bb7 3d					dec a 
0bb8 32 e4 f9				ld (store_tmp2), a 
0bbb c3 16 0b				jp .mloop 
0bbe			 
0bbe				; move down one 
0bbe			.mgod: 
0bbe 3a e4 f9				ld a, (store_tmp2) 
0bc1 3c					inc a 
0bc2 32 e4 f9				ld (store_tmp2), a 
0bc5 c3 16 0b				jp .mloop 
0bc8			 
0bc8			 
0bc8			.goend: 
0bc8					; get selected item number 
0bc8			 
0bc8 3a e4 f9				ld a, (store_tmp2) 
0bcb 3c					inc a 
0bcc			 
0bcc			.goend2: 
0bcc f5					push af 
0bcd			 
0bcd					; restore active fb 
0bcd					; TODO BUG assumes fb1 
0bcd			 
0bcd 21 02 fb				ld hl, display_fb1 
0bd0 22 5e fa				ld (display_fb_active), hl 
0bd3			 
0bd3					; restore main regs 
0bd3			 
0bd3			 
0bd3 cd f5 0a				call update_display 
0bd6			 
0bd6 f1					pop af 
0bd7			 
0bd7 c9				ret 
0bd8			 
0bd8 .. 00		.msel:   db ">",0 
0bda .. 00		.mup:   db "^",0 
0bdc .. 00		.mdown:   db "v",0 
0bde			 
0bde			 
0bde			; eof 
0bde			 
# End of file firmware_display.asm
0bde			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bde			; random number generators 
0bde			 
0bde			 
0bde			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bde			 
0bde			 
0bde			;-----> Generate a random number 
0bde			; output a=answer 0<=a<=255 
0bde			; all registers are preserved except: af 
0bde			random: 
0bde e5			        push    hl 
0bdf d5			        push    de 
0be0 2a 40 fa		        ld      hl,(randData) 
0be3 ed 5f		        ld      a,r 
0be5 57			        ld      d,a 
0be6 5e			        ld      e,(hl) 
0be7 19			        add     hl,de 
0be8 85			        add     a,l 
0be9 ac			        xor     h 
0bea 22 40 fa		        ld      (randData),hl 
0bed d1			        pop     de 
0bee e1			        pop     hl 
0bef c9			        ret 
0bf0			 
0bf0			 
0bf0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf0			 
0bf0			 
0bf0			 
0bf0			;------LFSR------ 
0bf0			;James Montelongo 
0bf0			;optimized by Spencer Putt 
0bf0			;out: 
0bf0			; a = 8 bit random number 
0bf0			RandLFSR: 
0bf0 21 46 fa		        ld hl,LFSRSeed+4 
0bf3 5e			        ld e,(hl) 
0bf4 23			        inc hl 
0bf5 56			        ld d,(hl) 
0bf6 23			        inc hl 
0bf7 4e			        ld c,(hl) 
0bf8 23			        inc hl 
0bf9 7e			        ld a,(hl) 
0bfa 47			        ld b,a 
0bfb cb 13		        rl e  
0bfd cb 12			rl d 
0bff cb 11		        rl c  
0c01 17				rla 
0c02 cb 13		        rl e  
0c04 cb 12			rl d 
0c06 cb 11		        rl c  
0c08 17				rla 
0c09 cb 13		        rl e  
0c0b cb 12			rl d 
0c0d cb 11		        rl c  
0c0f 17				rla 
0c10 67			        ld h,a 
0c11 cb 13		        rl e  
0c13 cb 12			rl d 
0c15 cb 11		        rl c  
0c17 17				rla 
0c18 a8			        xor b 
0c19 cb 13		        rl e  
0c1b cb 12			rl d 
0c1d ac			        xor h 
0c1e a9			        xor c 
0c1f aa			        xor d 
0c20 21 48 fa		        ld hl,LFSRSeed+6 
0c23 11 49 fa		        ld de,LFSRSeed+7 
0c26 01 07 00		        ld bc,7 
0c29 ed b8		        lddr 
0c2b 12			        ld (de),a 
0c2c c9			        ret 
0c2d			 
0c2d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c2d			 
0c2d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c2d			 
0c2d			 
0c2d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c2d			 
0c2d			prng16: 
0c2d			;Inputs: 
0c2d			;   (seed1) contains a 16-bit seed value 
0c2d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c2d			;Outputs: 
0c2d			;   HL is the result 
0c2d			;   BC is the result of the LCG, so not that great of quality 
0c2d			;   DE is preserved 
0c2d			;Destroys: 
0c2d			;   AF 
0c2d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c2d			;160cc 
0c2d			;26 bytes 
0c2d 2a 3a fa		    ld hl,(seed1) 
0c30 44			    ld b,h 
0c31 4d			    ld c,l 
0c32 29			    add hl,hl 
0c33 29			    add hl,hl 
0c34 2c			    inc l 
0c35 09			    add hl,bc 
0c36 22 3a fa		    ld (seed1),hl 
0c39 2a 38 fa		    ld hl,(seed2) 
0c3c 29			    add hl,hl 
0c3d 9f			    sbc a,a 
0c3e e6 2d		    and %00101101 
0c40 ad			    xor l 
0c41 6f			    ld l,a 
0c42 22 38 fa		    ld (seed2),hl 
0c45 09			    add hl,bc 
0c46 c9			    ret 
0c47			 
0c47			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c47			 
0c47			rand32: 
0c47			;Inputs: 
0c47			;   (seed1_0) holds the lower 16 bits of the first seed 
0c47			;   (seed1_1) holds the upper 16 bits of the first seed 
0c47			;   (seed2_0) holds the lower 16 bits of the second seed 
0c47			;   (seed2_1) holds the upper 16 bits of the second seed 
0c47			;   **NOTE: seed2 must be non-zero 
0c47			;Outputs: 
0c47			;   HL is the result 
0c47			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c47			;Destroys: 
0c47			;   AF 
0c47			;Tested and passes all CAcert tests 
0c47			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c47			;it has a period of 18,446,744,069,414,584,320 
0c47			;roughly 18.4 quintillion. 
0c47			;LFSR taps: 0,2,6,7  = 11000101 
0c47			;291cc 
0c47			;seed1_0=$+1 
0c47			;    ld hl,12345 
0c47			;seed1_1=$+1 
0c47			;    ld de,6789 
0c47			;    ld b,h 
0c47			;    ld c,l 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    inc l 
0c47			;    add hl,bc 
0c47			;    ld (seed1_0),hl 
0c47			;    ld hl,(seed1_1) 
0c47			;    adc hl,de 
0c47			;    ld (seed1_1),hl 
0c47			;    ex de,hl 
0c47			;seed2_0=$+1 
0c47			;    ld hl,9876 
0c47			;seed2_1=$+1 
0c47			;    ld bc,54321 
0c47			;    add hl,hl \ rl c \ rl b 
0c47			;    ld (seed2_1),bc 
0c47			;    sbc a,a 
0c47			;    and %11000101 
0c47			;    xor l 
0c47			;    ld l,a 
0c47			;    ld (seed2_0),hl 
0c47			;    ex de,hl 
0c47			;    add hl,bc 
0c47			;    ret 
0c47			; 
0c47			 
0c47			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c47			; 20 bytes, 86 cycles (excluding ret) 
0c47			 
0c47			; returns   hl = pseudorandom number 
0c47			; corrupts   a 
0c47			 
0c47			; generates 16-bit pseudorandom numbers with a period of 65535 
0c47			; using the xorshift method: 
0c47			 
0c47			; hl ^= hl << 7 
0c47			; hl ^= hl >> 9 
0c47			; hl ^= hl << 8 
0c47			 
0c47			; some alternative shift triplets which also perform well are: 
0c47			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c47			 
0c47			;  org 32768 
0c47			 
0c47			xrnd: 
0c47 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c4a 3e 00		  ld a,0 
0c4c bd			  cp l 
0c4d 20 02		  jr nz, .xrnd1 
0c4f 2e 01		  ld l, 1 
0c51			.xrnd1: 
0c51			 
0c51 7c			  ld a,h 
0c52 1f			  rra 
0c53 7d			  ld a,l 
0c54 1f			  rra 
0c55 ac			  xor h 
0c56 67			  ld h,a 
0c57 7d			  ld a,l 
0c58 1f			  rra 
0c59 7c			  ld a,h 
0c5a 1f			  rra 
0c5b ad			  xor l 
0c5c 6f			  ld l,a 
0c5d ac			  xor h 
0c5e 67			  ld h,a 
0c5f			 
0c5f 22 3e fa		  ld (xrandc),hl 
0c62			 
0c62 c9			  ret 
0c63			;  
0c63			 
0c63			 
0c63			;;;; int maths 
0c63			 
0c63			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c63			; Divide 16-bit values (with 16-bit result) 
0c63			; In: Divide BC by divider DE 
0c63			; Out: BC = result, HL = rest 
0c63			; 
0c63			Div16: 
0c63 21 00 00		    ld hl,0 
0c66 78			    ld a,b 
0c67 06 08		    ld b,8 
0c69			Div16_Loop1: 
0c69 17			    rla 
0c6a ed 6a		    adc hl,hl 
0c6c ed 52		    sbc hl,de 
0c6e 30 01		    jr nc,Div16_NoAdd1 
0c70 19			    add hl,de 
0c71			Div16_NoAdd1: 
0c71 10 f6		    djnz Div16_Loop1 
0c73 17			    rla 
0c74 2f			    cpl 
0c75 47			    ld b,a 
0c76 79			    ld a,c 
0c77 48			    ld c,b 
0c78 06 08		    ld b,8 
0c7a			Div16_Loop2: 
0c7a 17			    rla 
0c7b ed 6a		    adc hl,hl 
0c7d ed 52		    sbc hl,de 
0c7f 30 01		    jr nc,Div16_NoAdd2 
0c81 19			    add hl,de 
0c82			Div16_NoAdd2: 
0c82 10 f6		    djnz Div16_Loop2 
0c84 17			    rla 
0c85 2f			    cpl 
0c86 41			    ld b,c 
0c87 4f			    ld c,a 
0c88 c9			ret 
0c89			 
0c89			 
0c89			;http://z80-heaven.wikidot.com/math 
0c89			; 
0c89			;Inputs: 
0c89			;     DE and A are factors 
0c89			;Outputs: 
0c89			;     A is not changed 
0c89			;     B is 0 
0c89			;     C is not changed 
0c89			;     DE is not changed 
0c89			;     HL is the product 
0c89			;Time: 
0c89			;     342+6x 
0c89			; 
0c89			Mult16: 
0c89			 
0c89 06 08		     ld b,8          ;7           7 
0c8b 21 00 00		     ld hl,0         ;10         10 
0c8e 29			       add hl,hl     ;11*8       88 
0c8f 07			       rlca          ;4*8        32 
0c90 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c92 19			         add hl,de   ;--         -- 
0c93 10 f9		       djnz $-5      ;13*7+8     99 
0c95 c9			ret 
0c96			 
0c96			; 
0c96			; Square root of 16-bit value 
0c96			; In:  HL = value 
0c96			; Out:  D = result (rounded down) 
0c96			; 
0c96			;Sqr16: 
0c96			;    ld de,#0040 
0c96			;    ld a,l 
0c96			;    ld l,h 
0c96			;    ld h,d 
0c96			;    or a 
0c96			;    ld b,8 
0c96			;Sqr16_Loop: 
0c96			;    sbc hl,de 
0c96			;    jr nc,Sqr16_Skip 
0c96			;    add hl,de 
0c96			;Sqr16_Skip: 
0c96			;    ccf 
0c96			;    rl d 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    djnz Sqr16_Loop 
0c96			;    ret 
0c96			; 
0c96			; 
0c96			; Divide 8-bit values 
0c96			; In: Divide E by divider C 
0c96			; Out: A = result, B = rest 
0c96			; 
0c96			Div8: 
0c96 af			    xor a 
0c97 06 08		    ld b,8 
0c99			Div8_Loop: 
0c99 cb 13		    rl e 
0c9b 17			    rla 
0c9c 91			    sub c 
0c9d 30 01		    jr nc,Div8_NoAdd 
0c9f 81			    add a,c 
0ca0			Div8_NoAdd: 
0ca0 10 f7		    djnz Div8_Loop 
0ca2 47			    ld b,a 
0ca3 7b			    ld a,e 
0ca4 17			    rla 
0ca5 2f			    cpl 
0ca6 c9			    ret 
0ca7			 
0ca7			; 
0ca7			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ca7			; In: Multiply A with DE 
0ca7			; Out: HL = result 
0ca7			; 
0ca7			Mult12U: 
0ca7 2e 00		    ld l,0 
0ca9 87			    add a,a 
0caa 30 01		    jr nc,Mult12U_NoAdd0 
0cac 19			    add hl,de 
0cad			Mult12U_NoAdd0: 
0cad 29			    add hl,hl 
0cae 87			    add a,a 
0caf 30 01		    jr nc,Mult12U_NoAdd1 
0cb1 19			    add hl,de 
0cb2			Mult12U_NoAdd1: 
0cb2 29			    add hl,hl 
0cb3 87			    add a,a 
0cb4 30 01		    jr nc,Mult12U_NoAdd2 
0cb6 19			    add hl,de 
0cb7			Mult12U_NoAdd2: 
0cb7 29			    add hl,hl 
0cb8 87			    add a,a 
0cb9 30 01		    jr nc,Mult12U_NoAdd3 
0cbb 19			    add hl,de 
0cbc			Mult12U_NoAdd3: 
0cbc 29			    add hl,hl 
0cbd 87			    add a,a 
0cbe 30 01		    jr nc,Mult12U_NoAdd4 
0cc0 19			    add hl,de 
0cc1			Mult12U_NoAdd4: 
0cc1 29			    add hl,hl 
0cc2 87			    add a,a 
0cc3 30 01		    jr nc,Mult12U_NoAdd5 
0cc5 19			    add hl,de 
0cc6			Mult12U_NoAdd5: 
0cc6 29			    add hl,hl 
0cc7 87			    add a,a 
0cc8 30 01		    jr nc,Mult12U_NoAdd6 
0cca 19			    add hl,de 
0ccb			Mult12U_NoAdd6: 
0ccb 29			    add hl,hl 
0ccc 87			    add a,a 
0ccd d0			    ret nc 
0cce 19			    add hl,de 
0ccf c9			    ret 
0cd0			 
0cd0			; 
0cd0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd0			; In: Multiply A with DE 
0cd0			;      Put lowest value in A for most efficient calculation 
0cd0			; Out: HL = result 
0cd0			; 
0cd0			Mult12R: 
0cd0 21 00 00		    ld hl,0 
0cd3			Mult12R_Loop: 
0cd3 cb 3f		    srl a 
0cd5 30 01		    jr nc,Mult12R_NoAdd 
0cd7 19			    add hl,de 
0cd8			Mult12R_NoAdd: 
0cd8 cb 23		    sla e 
0cda cb 12		    rl d 
0cdc b7			    or a 
0cdd c2 d3 0c		    jp nz,Mult12R_Loop 
0ce0 c9			    ret 
0ce1			 
0ce1			; 
0ce1			; Multiply 16-bit values (with 32-bit result) 
0ce1			; In: Multiply BC with DE 
0ce1			; Out: BCHL = result 
0ce1			; 
0ce1			Mult32: 
0ce1 79			    ld a,c 
0ce2 48			    ld c,b 
0ce3 21 00 00		    ld hl,0 
0ce6 06 10		    ld b,16 
0ce8			Mult32_Loop: 
0ce8 29			    add hl,hl 
0ce9 17			    rla 
0cea cb 11		    rl c 
0cec 30 07		    jr nc,Mult32_NoAdd 
0cee 19			    add hl,de 
0cef ce 00		    adc a,0 
0cf1 d2 f5 0c		    jp nc,Mult32_NoAdd 
0cf4 0c			    inc c 
0cf5			Mult32_NoAdd: 
0cf5 10 f1		    djnz Mult32_Loop 
0cf7 41			    ld b,c 
0cf8 4f			    ld c,a 
0cf9 c9			    ret 
0cfa			 
0cfa			 
0cfa			 
0cfa			; 
0cfa			; Multiply 8-bit values 
0cfa			; In:  Multiply H with E 
0cfa			; Out: HL = result 
0cfa			; 
0cfa			Mult8: 
0cfa 16 00		    ld d,0 
0cfc 6a			    ld l,d 
0cfd 06 08		    ld b,8 
0cff			Mult8_Loop: 
0cff 29			    add hl,hl 
0d00 30 01		    jr nc,Mult8_NoAdd 
0d02 19			    add hl,de 
0d03			Mult8_NoAdd: 
0d03 10 fa		    djnz Mult8_Loop 
0d05 c9			    ret 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			;;http://z80-heaven.wikidot.com/math 
0d06			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d06			; 
0d06			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d06			;     ld a,16        ;7 
0d06			;     ld hl,0        ;10 
0d06			;     jp $+5         ;10 
0d06			;.DivLoop: 
0d06			;       add hl,bc    ;-- 
0d06			;       dec a        ;64 
0d06			;       jr z,.DivLoopEnd        ;86 
0d06			; 
0d06			;       sla e        ;128 
0d06			;       rl d         ;128 
0d06			;       adc hl,hl    ;240 
0d06			;       sbc hl,bc    ;240 
0d06			;       jr nc,.DivLoop ;23|21 
0d06			;       inc e        ;-- 
0d06			;       jp .DivLoop+1 
0d06			; 
0d06			;.DivLoopEnd: 
0d06			 
0d06			;HL_Div_C: 
0d06			;Inputs: 
0d06			;     HL is the numerator 
0d06			;     C is the denominator 
0d06			;Outputs: 
0d06			;     A is the remainder 
0d06			;     B is 0 
0d06			;     C is not changed 
0d06			;     DE is not changed 
0d06			;     HL is the quotient 
0d06			; 
0d06			;       ld b,16 
0d06			;       xor a 
0d06			;         add hl,hl 
0d06			;         rla 
0d06			;         cp c 
0d06			;         jr c,$+4 
0d06			;           inc l 
0d06			;           sub c 
0d06			;         djnz $-7 
0d06			 
0d06			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d06			 
0d06			addatohl: 
0d06 85			    add   a, l    ; A = A+L 
0d07 6f			    ld    l, a    ; L = A+L 
0d08 8c			    adc   a, h    ; A = A+L+H+carry 
0d09 95			    sub   l       ; A = H+carry 
0d0a 67			    ld    h, a    ; H = H+carry 
0d0b c9			ret 
0d0c			 
0d0c			addatode: 
0d0c 83			    add   a, e    ; A = A+L 
0d0d 5f			    ld    e, a    ; L = A+L 
0d0e 8a			    adc   a, d    ; A = A+L+H+carry 
0d0f 93			    sub   e       ; A = H+carry 
0d10 57			    ld    d, a    ; H = H+carry 
0d11 c9			ret 
0d12			 
0d12			 
0d12			addatobc: 
0d12 81			    add   a, c    ; A = A+L 
0d13 4f			    ld    c, a    ; L = A+L 
0d14 88			    adc   a, b    ; A = A+L+H+carry 
0d15 91			    sub   c       ; A = H+carry 
0d16 47			    ld    b, a    ; H = H+carry 
0d17 c9			ret 
0d18			 
0d18			subafromhl: 
0d18			   ; If A=0 do nothing 
0d18			    ; Otherwise flip A's sign. Since 
0d18			    ; the upper byte becomes -1, also 
0d18			    ; substract 1 from H. 
0d18 ed 44		    neg 
0d1a ca 23 0d		    jp    z, Skip 
0d1d 25			    dec   h 
0d1e			     
0d1e			    ; Now add the low byte as usual 
0d1e			    ; Two's complement takes care of 
0d1e			    ; ensuring the result is correct 
0d1e 85			    add   a, l 
0d1f 6f			    ld    l, a 
0d20 8c			    adc   a, h 
0d21 95			    sub   l 
0d22 67			    ld    h, a 
0d23			Skip: 
0d23 c9				ret 
0d24			 
0d24			 
0d24			; compare hl and de 
0d24			; returns:  
0d24			; if hl = de, z=1, s=0, c0=0 
0d24			; if hl > de, z=0, s=0, c=0 
0d24			; if hl < de, z=0, s=1, c=1 
0d24			cmp16:	 
0d24 b7				or a 
0d25 ed 52			sbc hl,de 
0d27 e0				ret po 
0d28 7c				ld a,h 
0d29 1f				rra 
0d2a ee 40			xor 01000000B 
0d2c 37				scf 
0d2d 8f				adc a,a 
0d2e c9				ret 
0d2f			 
0d2f			 
0d2f			; test if hl contains zero   - A is destroyed 
0d2f			 
0d2f			ishlzero:    
0d2f b7				or a     ; reset flags 
0d30 7c				ld a, h 
0d31 b5				or l        	 
0d32			 
0d32 c9				ret 
0d33			 
0d33			 
0d33			 
0d33			 
0d33			if FORTH_ENABLE_FLOATMATH 
0d33			;include "float/bbcmath.z80" 
0d33			include "float/lpfpcalc.asm" 
0d33			endif 
0d33			 
0d33			 
0d33			; eof 
0d33			 
# End of file firmware_maths.asm
0d33			include "firmware_strings.asm"   ; string handling  
0d33			 
0d33			 
0d33			; TODO string len 
0d33			; input text string, end on cr with zero term 
0d33			; a offset into frame buffer to start prompt 
0d33			; d is max length 
0d33			; e is display size TODO 
0d33			; c is current cursor position 
0d33			; hl is ptr to where string will be stored 
0d33			 
0d33			 
0d33			; TODO check limit of buffer for new inserts 
0d33			; TODO check insert does not push beyond buffer 
0d33			; TODO scroll in a limited display area 
0d33			; TODO scroll whole screen on page wrap 
0d33			 
0d33			 
0d33			; TODO handle KEY_PREVWORD 
0d33			; TODO handle KEY_NEXTWORD 
0d33			; TODO handle KEY_HOME 
0d33			; TODO handle KEY_END 
0d33			; TODO use LCD cursor? 
0d33			 
0d33 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d36 81					add c 
0d37 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3a 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d3d 79					ld a, c 
0d3e cd 06 0d				call addatohl 
0d41 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d44 7a					ld a,d 
0d45 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d48 79					ld a, c 
0d49 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d4c 7b					ld a,e 
0d4d 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d50					 
0d50					 
0d50			 
0d50			;		ld a,(input_ptr) 
0d50			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d50			 
0d50			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d50					; init cursor shape if not set by the cin routines 
0d50 21 56 fa				ld hl, cursor_shape 
0d53 3e ff				ld a, 255 
0d55 77					ld (hl), a 
0d56 23					inc hl 
0d57 3e 00				ld a, 0 
0d59 77					ld (hl), a 
0d5a			 
0d5a 3e 0f				ld a, CUR_BLINK_RATE 
0d5c 32 b2 fb				ld (input_cur_flash), a 
0d5f 3e 01				ld a, 1 
0d61 32 b1 fb				ld (input_cur_onoff),a 
0d64			 
0d64			;	if DEBUG_INPUT 
0d64			;		push af 
0d64			;		ld a, 'I' 
0d64			;		ld (debug_mark),a 
0d64			;		pop af 
0d64			;		CALLMONITOR 
0d64			;	endif 
0d64			.is1:		; main entry loop 
0d64			 
0d64			 
0d64			 
0d64					; pause 1ms 
0d64			 
0d64 3e 01				ld a, 1 
0d66 cd 37 0a				call aDelayInMS 
0d69			 
0d69					; dec flash counter 
0d69 3a b2 fb				ld a, (input_cur_flash) 
0d6c 3d					dec a 
0d6d 32 b2 fb				ld (input_cur_flash), a 
0d70 fe 00				cp 0 
0d72 20 0d				jr nz, .nochgstate 
0d74			 
0d74			 
0d74					; change state 
0d74 3a b1 fb				ld a,(input_cur_onoff) 
0d77 ed 44				neg 
0d79 32 b1 fb				ld (input_cur_onoff),a 
0d7c			 
0d7c			 
0d7c					; reset on change of state 
0d7c 3e 0f				ld a, CUR_BLINK_RATE 
0d7e 32 b2 fb				ld (input_cur_flash), a 
0d81			 
0d81			.nochgstate: 
0d81					 
0d81					 
0d81			 
0d81					; display cursor  
0d81			 
0d81			;		ld hl, (input_start) 
0d81			;		ld a, (input_cursor) 
0d81			;		call addatohl 
0d81			 
0d81					; get char under cursor and replace with cursor 
0d81 2a bb fb		ld hl, (input_ptr) 
0d84			;		ld a, (hl) 
0d84			;		ld (input_under_cursor),a 
0d84			;		ld a, '_' 
0d84			;		ld (hl), a 
0d84			 
0d84					; display string 
0d84			 
0d84 ed 5b b9 fb			ld de, (input_start) 
0d88 3a b6 fb				ld a, (input_at_pos) 
0d8b cd e5 0a				call str_at_display 
0d8e			;	        call update_display 
0d8e			 
0d8e					; find place to put the cursor 
0d8e			;		add h 
0d8e			;		ld l, display_row_1 
0d8e			;		sub l 
0d8e			; (input_at_pos) 
0d8e					;ld c, a 
0d8e			;		ld a, (input_cursor) 
0d8e			;		ld l, (input_at_pos) 
0d8e			;		;ld b, h 
0d8e			;		add l 
0d8e			;		ld (input_at_cursor),a 
0d8e					;ld l,h 
0d8e			 
0d8e			;		ld h, 0 
0d8e			;		ld l,(input_at_pos) 
0d8e			;		ld a, (input_cursor) 
0d8e			;		call addatohl 
0d8e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d8e			;		call subafromhl 
0d8e			;		ld a,l 
0d8e			;		ld (input_at_cursor), a 
0d8e			 
0d8e				if DEBUG_INPUT 
0d8e					ld a, (hardware_diag) 
0d8e					cp 0 
0d8e					jr z, .skip_input_diag 
0d8e			 
0d8e					ld a,(input_at_pos) 
0d8e					ld hl, LFSRSeed 
0d8e					call hexout 
0d8e					ld a, (input_cursor) 
0d8e					ld hl, LFSRSeed+2 
0d8e					call hexout 
0d8e					ld a,(input_at_cursor) 
0d8e					ld hl, LFSRSeed+4 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_onoff) 
0d8e					ld hl, LFSRSeed+6 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_flash) 
0d8e					ld hl, LFSRSeed+8 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_len) 
0d8e					ld hl, LFSRSeed+10 
0d8e					call hexout 
0d8e					ld hl, LFSRSeed+12 
0d8e					ld a, 0 
0d8e					ld (hl),a 
0d8e					ld a, display_row_4 
0d8e					ld de, LFSRSeed 
0d8e					call str_at_display 
0d8e					.skip_input_diag: 
0d8e				endif 
0d8e			 
0d8e					; decide on if we are showing the cursor this time round 
0d8e			 
0d8e 3a b1 fb				ld a, (input_cur_onoff) 
0d91 fe ff				cp 255 
0d93 28 13				jr z, .skipcur 
0d95			 
0d95			 
0d95 3a b4 fb				ld a,(input_at_cursor) 
0d98 11 56 fa				ld de, cursor_shape 
0d9b cd e5 0a				call str_at_display 
0d9e			 
0d9e					; save length of current input string 
0d9e 2a b9 fb				ld hl, (input_start) 
0da1 cd 64 11				call strlenz 
0da4 7d					ld a,l 
0da5 32 ac fb				ld (input_len),a 
0da8			 
0da8			.skipcur: 
0da8			 
0da8 cd f5 0a			        call update_display 
0dab					 
0dab			 
0dab			 
0dab					; wait 
0dab				 
0dab					; TODO loop without wait to flash the cursor and char under cursor	 
0dab cd b7 66				call cin    ; _wait 
0dae			 
0dae fe 00				cp 0 
0db0 ca 64 0d				jp z, .is1 
0db3			 
0db3					; get ptr to char to input into 
0db3			 
0db3 4f					ld c,a 
0db4 2a b9 fb				ld hl, (input_start) 
0db7 3a a7 fb				ld a, (input_cursor) 
0dba cd 06 0d				call addatohl 
0dbd 22 bb fb				ld (input_ptr), hl 
0dc0 79					ld a,c 
0dc1			 
0dc1					; replace char under cursor 
0dc1			 
0dc1			;		ld hl, (input_ptr) 
0dc1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc1			;		ld (hl), a 
0dc1			 
0dc1			;	if DEBUG_INPUT 
0dc1			;		push af 
0dc1			;		ld a, 'i' 
0dc1			;		ld (debug_mark),a 
0dc1			;		pop af 
0dc1			;		CALLMONITOR 
0dc1			;	endif 
0dc1 fe 0e				cp KEY_HOME 
0dc3 20 0e				jr nz, .iske 
0dc5			 
0dc5 3a b6 fb				ld a, (input_at_pos) 
0dc8 32 b4 fb				ld (input_at_cursor),a 
0dcb 3e 00				ld a, 0 
0dcd 32 a7 fb				ld (input_cursor), a 
0dd0 c3 64 0d				jp .is1 
0dd3					 
0dd3 fe 0f		.iske:		cp KEY_END 
0dd5 20 03				jr nz, .isknw 
0dd7 c3 64 0d				jp .is1 
0dda			 
0dda fe 06		.isknw:		cp KEY_NEXTWORD 
0ddc 20 1b				jr nz, .iskpw 
0dde			 
0dde 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0de1 7e					ld a,(hl)	 
0de2 fe 00				cp 0 
0de4 ca 64 0d				jp z, .is1    ; end of string 
0de7 fe 20				cp ' ' 
0de9 ca 64 0d				jp z, .is1    ; end of word 
0dec 23					inc hl 
0ded 22 bb fb				ld (input_ptr), hl 
0df0 3a b4 fb				ld a, (input_at_cursor) 
0df3 3c					inc a 
0df4 32 b4 fb				ld (input_at_cursor), a 
0df7 18 e5				jr .isknwm 
0df9			 
0df9 fe 07		.iskpw:		cp KEY_PREVWORD 
0dfb 20 1b				jr nz, .iskl 
0dfd			.iskpwm:	 
0dfd 2a bb fb				ld hl, (input_ptr) 
0e00 7e					ld a,(hl)	 
0e01 fe 00				cp 0  
0e03 ca 64 0d				jp z, .is1    ; end of string 
0e06 fe 20				cp ' ' 
0e08 ca 64 0d				jp z, .is1    ; end of word 
0e0b 2b					dec hl 
0e0c 22 bb fb				ld (input_ptr), hl 
0e0f 3a b4 fb				ld a, (input_at_cursor) 
0e12 3d					dec a 
0e13 32 b4 fb				ld (input_at_cursor), a 
0e16 18 e5				jr .iskpwm 
0e18			 
0e18			 
0e18 fe 0b		.iskl:		cp KEY_LEFT 
0e1a 20 27				jr nz, .isk1 
0e1c			 
0e1c 3a a7 fb				ld a, (input_cursor) 
0e1f			 
0e1f fe 00				cp 0 
0e21 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0e24			 
0e24 3d					dec  a 		; TODO check underflow 
0e25 32 a7 fb				ld (input_cursor), a 
0e28			 
0e28 2a bb fb				ld hl, (input_ptr) 
0e2b 2b					dec hl 
0e2c 22 bb fb				ld (input_ptr), hl 
0e2f					 
0e2f 3a b4 fb				ld a, (input_at_cursor) 
0e32 3d					dec a 
0e33 32 b4 fb				ld (input_at_cursor), a 
0e36			 
0e36 3e 01				ld a, 1		; show cursor moving 
0e38 32 b1 fb				ld (input_cur_onoff),a 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 b2 fb				ld (input_cur_flash), a 
0e40			 
0e40 c3 64 0d				jp .is1 
0e43			 
0e43 fe 0c		.isk1:		cp KEY_RIGHT 
0e45 20 2a				jr nz, .isk2 
0e47			 
0e47 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4a 5f					ld e,a 
0e4b 3a a7 fb				ld a, (input_cursor) 
0e4e bb					cp e 
0e4f ca 64 0d				jp z, .is1		; at the end of string so dont go right 
0e52			 
0e52 3c					inc  a 		; TODO check overflow 
0e53 32 a7 fb				ld (input_cursor), a 
0e56			 
0e56 3a b4 fb				ld a, (input_at_cursor) 
0e59 3c					inc a 
0e5a 32 b4 fb				ld (input_at_cursor), a 
0e5d			 
0e5d 2a bb fb				ld hl, (input_ptr) 
0e60 23					inc hl 
0e61 22 bb fb				ld (input_ptr), hl 
0e64			 
0e64 3e 01				ld a, 1		; show cursor moving 
0e66 32 b1 fb				ld (input_cur_onoff),a 
0e69 3e 0f				ld a, CUR_BLINK_RATE 
0e6b 32 b2 fb				ld (input_cur_flash), a 
0e6e			 
0e6e c3 64 0d				jp .is1 
0e71			 
0e71 fe 05		.isk2:		cp KEY_UP 
0e73			 
0e73 20 26				jr nz, .isk3 
0e75			 
0e75					; swap last command with the current on 
0e75			 
0e75					; move cursor to start of string 
0e75 2a b9 fb				ld hl, (input_start) 
0e78 22 bb fb				ld (input_ptr), hl 
0e7b			 
0e7b 3a b6 fb				ld a, (input_at_pos) 
0e7e 32 b4 fb				ld (input_at_cursor), a 
0e81			 
0e81 3e 00				ld a, 0 
0e83 32 a7 fb				ld (input_cursor), a 
0e86					 
0e86					; swap input and last command buffers 
0e86			 
0e86 21 ca f2				ld hl, os_cli_cmd 
0e89 11 c9 f3				ld de, os_last_cmd 
0e8c 06 ff				ld b, 255 
0e8e 7e			.swap1:		ld a, (hl) 
0e8f 4f					ld c,a 
0e90 1a					ld a, (de) 
0e91 77					ld (hl), a 
0e92 79					ld a,c 
0e93 12					ld (de),a 
0e94 23					inc hl 
0e95 13					inc de 
0e96 10 f6				djnz .swap1 
0e98			 
0e98			 
0e98			 
0e98			 
0e98			 
0e98 c3 64 0d				jp .is1 
0e9b			 
0e9b fe 08		.isk3:		cp KEY_BS 
0e9d 20 3c				jr nz, .isk4 
0e9f			 
0e9f 3a a7 fb				ld a, (input_cursor) 
0ea2			 
0ea2 fe 00				cp 0 
0ea4 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0ea7			 
0ea7 3d					dec  a 		; TODO check underflow 
0ea8 32 a7 fb				ld (input_cursor), a 
0eab			 
0eab					; hl is source 
0eab					; de needs to be source - 1 
0eab			 
0eab			;		ld a, 0 
0eab			;		dec hl 
0eab			;		ld (hl), a 
0eab			 
0eab 2a bb fb				ld hl, (input_ptr) 
0eae 2b					dec hl 
0eaf 22 bb fb				ld (input_ptr), hl 
0eb2			 
0eb2					; shift all data 
0eb2			 
0eb2 e5					push hl 
0eb3 23					inc hl 
0eb4 d1					pop de 
0eb5 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eb8 4f					ld c,a 
0eb9 06 00				ld b,0 
0ebb ed b0				ldir  
0ebd			 
0ebd			 
0ebd			 
0ebd			 
0ebd 3a b4 fb				ld a, (input_at_cursor) 
0ec0 3d					dec a 
0ec1 32 b4 fb				ld (input_at_cursor), a 
0ec4			 
0ec4			 
0ec4 3e 01				ld a, 1		; show cursor moving 
0ec6 32 b1 fb				ld (input_cur_onoff),a 
0ec9 3e 0f				ld a, CUR_BLINK_RATE 
0ecb 32 b2 fb				ld (input_cur_flash), a 
0ece			 
0ece					; remove char 
0ece 3a b4 fb				ld a, (input_at_cursor) 
0ed1 3c					inc a 
0ed2 11 5c 0f				ld de,.iblank 
0ed5 cd e5 0a				call str_at_display 
0ed8			 
0ed8 c3 64 0d				jp .is1 
0edb			 
0edb fe 0d		.isk4:		cp KEY_CR 
0edd 28 6c				jr z, .endinput 
0edf			 
0edf					; else add the key press to the end 
0edf			 
0edf 4f					ld c, a			; save key pressed 
0ee0			 
0ee0 7e					ld a,(hl)		; get what is currently under char 
0ee1			 
0ee1 fe 00				cp 0			; we are at the end of the string 
0ee3 20 2f				jr nz, .onchar 
0ee5					 
0ee5					; add a char to the end of the string 
0ee5				 
0ee5 71					ld (hl),c 
0ee6 23					inc hl 
0ee7			;		ld a,' ' 
0ee7			;		ld (hl),a 
0ee7			;		inc hl 
0ee7 3e 00				ld a,0 
0ee9 77					ld (hl),a 
0eea 2b					dec hl 
0eeb			 
0eeb 3a a7 fb				ld a, (input_cursor) 
0eee 3c					inc a				; TODO check max string length and scroll  
0eef 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0ef2							 
0ef2 3a b4 fb				ld a, (input_at_cursor) 
0ef5 3c					inc a 
0ef6 32 b4 fb				ld (input_at_cursor), a 
0ef9			 
0ef9 2a bb fb				ld hl, (input_ptr) 
0efc 23					inc hl 
0efd 22 bb fb				ld (input_ptr), hl 
0f00			 
0f00 2a bb fb				ld hl, (input_ptr) 
0f03 23					inc hl 
0f04 22 bb fb				ld (input_ptr), hl 
0f07			;	if DEBUG_INPUT 
0f07			;		push af 
0f07			;		ld a, '+' 
0f07			;		ld (debug_mark),a 
0f07			;		pop af 
0f07			;		CALLMONITOR 
0f07			;	endif 
0f07 3e 01				ld a, 1		; show cursor moving 
0f09 32 b1 fb				ld (input_cur_onoff),a 
0f0c 3e 0f				ld a, CUR_BLINK_RATE 
0f0e 32 b2 fb				ld (input_cur_flash), a 
0f11 c3 64 0d				jp .is1 
0f14					 
0f14			 
0f14			 
0f14					; if on a char then insert 
0f14			.onchar: 
0f14			 
0f14					; TODO over flow check: make sure insert does not blow out buffer 
0f14			 
0f14					; need to do some maths to use lddr 
0f14			 
0f14 e5					push hl   ; save char pos 
0f15 c5					push bc 
0f16			 
0f16 2a b9 fb				ld hl, (input_start) 
0f19 3a ac fb				ld a, (input_len) 
0f1c cd 06 0d				call addatohl  		; end of string 
0f1f 23					inc hl 
0f20 23					inc hl		; past zero term 
0f21 e5					push hl 
0f22 23					inc hl 
0f23 e5					push hl  
0f24			 
0f24								; start and end of lddr set, now how much to move? 
0f24			 
0f24							 
0f24 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f27 47					ld b,a 
0f28 3a ac fb				ld a,(input_len) 
0f2b 5f					ld e,a 
0f2c 90					sub b 
0f2d 3c					inc a		;?? 
0f2e 3c					inc a		;?? 
0f2f 3c					inc a		;?? 
0f30			 
0f30 06 00				ld b,0 
0f32 4f					ld c,a 
0f33			 
0f33				if DEBUG_INPUT 
0f33					push af 
0f33					ld a, 'i' 
0f33					ld (debug_mark),a 
0f33					pop af 
0f33			;		CALLMONITOR 
0f33				endif 
0f33 d1					pop de 
0f34 e1					pop hl 
0f35				if DEBUG_INPUT 
0f35					push af 
0f35					ld a, 'I' 
0f35					ld (debug_mark),a 
0f35					pop af 
0f35			;		CALLMONITOR 
0f35				endif 
0f35 ed b8				lddr 
0f37				 
0f37			 
0f37			 
0f37					; TODO have a key for insert/overwrite mode???? 
0f37 c1					pop bc 
0f38 e1					pop hl 
0f39 71					ld (hl), c		; otherwise overwrite current char 
0f3a					 
0f3a			 
0f3a			 
0f3a			 
0f3a 3a a7 fb				ld a, (input_cursor) 
0f3d 3c					inc  a 		; TODO check overflow 
0f3e 32 a7 fb				ld (input_cursor), a 
0f41			 
0f41 3a b4 fb				ld a, (input_at_cursor) 
0f44 3c					inc a 
0f45 32 b4 fb				ld (input_at_cursor), a 
0f48			 
0f48 c3 64 0d				jp .is1 
0f4b			 
0f4b			.endinput:	; TODO look for end of string 
0f4b			 
0f4b					; add trailing space for end of token 
0f4b			 
0f4b 2a b9 fb				ld hl, (input_start) 
0f4e 3a ac fb				ld a,(input_len) 
0f51 cd 06 0d				call addatohl 
0f54 3e 20				ld a, ' ' 
0f56 77					ld (hl),a 
0f57					; TODO eof of parse marker 
0f57			 
0f57 23					inc hl 
0f58 3e 00				ld a, 0 
0f5a 77					ld (hl),a 
0f5b			 
0f5b			 
0f5b c9					ret 
0f5c			 
0f5c .. 00		.iblank: db " ",0 
0f5e			 
0f5e			 
0f5e 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f61 22 b9 fb				ld (input_start), hl 
0f64 3e 01				ld a,1			; add cursor 
0f66 77					ld (hl),a 
0f67 23					inc hl 
0f68 3e 00				ld a,0 
0f6a 77					ld (hl),a 
0f6b 22 bb fb				ld (input_ptr), hl 
0f6e 7a					ld a,d 
0f6f 32 b8 fb				ld (input_size), a 
0f72 3e 00				ld a,0 
0f74 32 a7 fb				ld (input_cursor),a 
0f77			.instr1:	 
0f77			 
0f77					; TODO do block cursor 
0f77					; TODO switch cursor depending on the modifer key 
0f77			 
0f77					; update cursor shape change on key hold 
0f77			 
0f77 2a bb fb				ld hl, (input_ptr) 
0f7a 2b					dec hl 
0f7b 3a 56 fa				ld a,(cursor_shape) 
0f7e 77					ld (hl), a 
0f7f			 
0f7f					; display entered text 
0f7f 3a b6 fb				ld a,(input_at_pos) 
0f82 cd d5 65		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f85 ed 5b b9 fb	            	LD   de, (input_start) 
0f89 cd dd 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8c			 
0f8c cd b7 66				call cin 
0f8f fe 00				cp 0 
0f91 28 e4				jr z, .instr1 
0f93			 
0f93					; proecess keyboard controls first 
0f93			 
0f93 2a bb fb				ld hl,(input_ptr) 
0f96			 
0f96 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f98 28 5a				jr z, .instrcr 
0f9a			 
0f9a fe 08				cp KEY_BS 	; back space 
0f9c 20 0f				jr nz, .instr2 
0f9e					; process back space 
0f9e			 
0f9e					; TODO stop back space if at start of string 
0f9e 2b					dec hl 
0f9f 2b					dec hl ; to over write cursor 
0fa0 3a 56 fa				ld a,(cursor_shape) 
0fa3					;ld a,0 
0fa3 77					ld (hl),a 
0fa4 23					inc hl 
0fa5 3e 20				ld a," " 
0fa7 77					ld (hl),a 
0fa8 22 bb fb				ld (input_ptr),hl 
0fab					 
0fab			 
0fab 18 ca				jr .instr1 
0fad			 
0fad fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0faf 20 06				jr nz, .instr3 
0fb1 2b					dec hl 
0fb2 22 bb fb				ld (input_ptr),hl 
0fb5 18 c0				jr .instr1 
0fb7				 
0fb7 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fb9 20 06				jr nz, .instr4 
0fbb 23					inc hl 
0fbc 22 bb fb				ld (input_ptr),hl 
0fbf 18 b6				jr .instr1 
0fc1			 
0fc1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc3 20 06				jr nz, .instr5 
0fc5 2b					dec hl 
0fc6 22 bb fb				ld (input_ptr),hl 
0fc9 18 ac				jr .instr1 
0fcb			 
0fcb fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fcd 20 06				jr nz, .instr6 
0fcf 2b					dec hl 
0fd0 22 bb fb				ld (input_ptr),hl 
0fd3 18 a2				jr .instr1 
0fd5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fd7 20 0b				jr nz, .instrnew 
0fd9			 
0fd9 21 a3 ef			ld hl, scratch 
0fdc 11 c9 f3			ld de, os_last_cmd 
0fdf cd fd 0f			call strcpy 
0fe2 18 93				jr .instr1 
0fe4			 
0fe4			 
0fe4			.instrnew:	; no special key pressed to see if we have room to store it 
0fe4			 
0fe4					; TODO do string size test 
0fe4			 
0fe4 2b					dec hl ; to over write cursor 
0fe5 77					ld (hl),a 
0fe6 23					inc hl 
0fe7 3a 56 fa				ld a,(cursor_shape) 
0fea 77					ld (hl),a 
0feb 23					inc hl 
0fec 3e 00				ld a,0 
0fee 77					ld (hl),a 
0fef			 
0fef 22 bb fb				ld (input_ptr),hl 
0ff2					 
0ff2 18 83				jr .instr1 
0ff4 2b			.instrcr:	dec hl		; remove cursor 
0ff5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ff7 77					ld (hl),a 
0ff8 23					inc hl 
0ff9 3e 00				ld a,0 
0ffb 77					ld (hl),a 
0ffc			 
0ffc			 
0ffc					; if at end of line scroll up    
0ffc					; TODO detecting only end of line 4 for scroll up  
0ffc			 
0ffc					;ld   
0ffc			 
0ffc c9					ret 
0ffd			 
0ffd			 
0ffd			; strcpy hl = dest, de source 
0ffd			 
0ffd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ffe b7			            OR   A              ;Null terminator? 
0fff c8			            RET  Z              ;Yes, so finished 
1000 1a					ld a,(de) 
1001 77					ld (hl),a 
1002 13			            INC  DE             ;Point to next character 
1003 23					inc hl 
1004 18 f7		            JR   strcpy       ;Repeat 
1006 c9					ret 
1007			 
1007			 
1007			; TODO string_at  
1007			; pass string which starts with lcd offset address and then null term string 
1007			 
1007			; TODO string to dec 
1007			; TODO string to hex 
1007			; TODO byte to string hex 
1007			; TODO byte to string dec 
1007			 
1007			 
1007			 
1007			; from z80uartmonitor 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1007			; pass hl for where to put the text 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007 c5			hexout:	PUSH BC 
1008 f5					PUSH AF 
1009 47					LD B, A 
100a					; Upper nybble 
100a cb 3f				SRL A 
100c cb 3f				SRL A 
100e cb 3f				SRL A 
1010 cb 3f				SRL A 
1012 cd 22 10				CALL tohex 
1015 77					ld (hl),a 
1016 23					inc hl	 
1017					 
1017					; Lower nybble 
1017 78					LD A, B 
1018 e6 0f				AND 0FH 
101a cd 22 10				CALL tohex 
101d 77					ld (hl),a 
101e 23					inc hl	 
101f					 
101f f1					POP AF 
1020 c1					POP BC 
1021 c9					RET 
1022					 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			tohex: 
1022 e5					PUSH HL 
1023 d5					PUSH DE 
1024 16 00				LD D, 0 
1026 5f					LD E, A 
1027 21 2f 10				LD HL, .DATA 
102a 19					ADD HL, DE 
102b 7e					LD A, (HL) 
102c d1					POP DE 
102d e1					POP HL 
102e c9					RET 
102f			 
102f			.DATA: 
102f 30					DEFB	30h	; 0 
1030 31					DEFB	31h	; 1 
1031 32					DEFB	32h	; 2 
1032 33					DEFB	33h	; 3 
1033 34					DEFB	34h	; 4 
1034 35					DEFB	35h	; 5 
1035 36					DEFB	36h	; 6 
1036 37					DEFB	37h	; 7 
1037 38					DEFB	38h	; 8 
1038 39					DEFB	39h	; 9 
1039 41					DEFB	41h	; A 
103a 42					DEFB	42h	; B 
103b 43					DEFB	43h	; C 
103c 44					DEFB	44h	; D 
103d 45					DEFB	45h	; E 
103e 46					DEFB	46h	; F 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
103f			;;    subtract $30, if result > 9 then subtract $7 more 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			atohex: 
103f d6 30				SUB $30 
1041 fe 0a				CP 10 
1043 f8					RET M		; If result negative it was 0-9 so we're done 
1044 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1046 c9					RET		 
1047			 
1047			 
1047			 
1047			 
1047			; Get 2 ASCII characters as hex byte from pointer in hl 
1047			 
1047			BYTERD: 
1047 16 00			LD	D,00h		;Set up 
1049 cd 51 10			CALL	HEXCON		;Get byte and convert to hex 
104c 87				ADD	A,A		;First nibble so 
104d 87				ADD	A,A		;multiply by 16 
104e 87				ADD	A,A		; 
104f 87				ADD	A,A		; 
1050 57				LD	D,A		;Save hi nibble in D 
1051			HEXCON: 
1051 7e				ld a, (hl)		;Get next chr 
1052 23				inc hl 
1053 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1055 fe 0a			CP	00Ah		;Is it 0-9 ? 
1057 38 02			JR	C,NALPHA	;If so miss next bit 
1059 d6 07			SUB	007h		;Else convert alpha 
105b			NALPHA: 
105b b2				OR	D		;Add hi nibble back 
105c c9				RET			; 
105d			 
105d			 
105d			; 
105d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
105d			; Since the routines get_byte and therefore get_nibble are called, only valid 
105d			; characters (0-9a-f) are accepted. 
105d			; 
105d			;get_word        push    af 
105d			;                call    get_byte        ; Get the upper byte 
105d			;                ld      h, a 
105d			;                call    get_byte        ; Get the lower byte 
105d			;                ld      l, a 
105d			;                pop     af 
105d			;                ret 
105d			; 
105d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
105d			; the routine get_nibble is used only valid characters are accepted - the  
105d			; input routine only accepts characters 0-9a-f. 
105d			; 
105d c5			get_byte:        push    bc              ; Save contents of B (and C) 
105e 7e					ld a,(hl) 
105f 23					inc hl 
1060 cd 85 10		                call    nibble2val      ; Get upper nibble 
1063 cb 07		                rlc     a 
1065 cb 07		                rlc     a 
1067 cb 07		                rlc     a 
1069 cb 07		                rlc     a 
106b 47			                ld      b, a            ; Save upper four bits 
106c 7e					ld a,(hl) 
106d cd 85 10		                call    nibble2val      ; Get lower nibble 
1070 b0			                or      b               ; Combine both nibbles 
1071 c1			                pop     bc              ; Restore B (and C) 
1072 c9			                ret 
1073			; 
1073			; Get a hexadecimal digit from the serial line. This routine blocks until 
1073			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1073			; to the serial line interface. The lower 4 bits of A contain the value of  
1073			; that particular digit. 
1073			; 
1073			;get_nibble      ld a,(hl)           ; Read a character 
1073			;                call    to_upper        ; Convert to upper case 
1073			;                call    is_hex          ; Was it a hex digit? 
1073			;                jr      nc, get_nibble  ; No, get another character 
1073			 ;               call    nibble2val      ; Convert nibble to value 
1073			 ;               call    print_nibble 
1073			 ;               ret 
1073			; 
1073			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1073			; A valid hexadecimal digit is denoted by a set C flag. 
1073			; 
1073			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1073			;                ret     nc              ; Yes 
1073			;                cp      '0'             ; Less than '0'? 
1073			;                jr      nc, is_hex_1    ; No, continue 
1073			;                ccf                     ; Complement carry (i.e. clear it) 
1073			;                ret 
1073			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1073			;                ret     c               ; Yes 
1073			;                cp      'A'             ; Less than 'A'? 
1073			;                jr      nc, is_hex_2    ; No, continue 
1073			;                ccf                     ; Yes - clear carry and return 
1073			;                ret 
1073			;is_hex_2        scf                     ; Set carry 
1073			;                ret 
1073			; 
1073			; Convert a single character contained in A to upper case: 
1073			; 
1073 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1075 d8			                ret     c 
1076 fe 7b		                cp      'z' + 1         ; > 'z'? 
1078 d0			                ret     nc              ; Nothing to do, either 
1079 e6 5f		                and     $5f             ; Convert to upper case 
107b c9			                ret 
107c			 
107c			 
107c			to_lower: 
107c			 
107c			   ; if char is in [A-Z] make it lower case 
107c			 
107c			   ; enter : a = char 
107c			   ; exit  : a = lower case char 
107c			   ; uses  : af 
107c			 
107c fe 41		   cp 'A' 
107e d8			   ret c 
107f			    
107f fe 5b		   cp 'Z'+1 
1081 d0			   ret nc 
1082			    
1082 f6 20		   or $20 
1084 c9			   ret 
1085			 
1085			; 
1085			; Expects a hexadecimal digit (upper case!) in A and returns the 
1085			; corresponding value in A. 
1085			; 
1085 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1087 38 02		                jr      c, nibble2val_1 ; Yes 
1089 d6 07		                sub     7               ; Adjust for A-F 
108b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
108d e6 0f		                and     $f              ; Only return lower 4 bits 
108f c9			                ret 
1090			; 
1090			; Print_nibble prints a single hex nibble which is contained in the lower  
1090			; four bits of A: 
1090			; 
1090			;print_nibble    push    af              ; We won't destroy the contents of A 
1090			;                and     $f              ; Just in case... 
1090			;                add     a, '0'             ; If we have a digit we are done here. 
1090			;                cp      '9' + 1         ; Is the result > 9? 
1090			;                jr      c, print_nibble_1 
1090			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1090			;print_nibble_1  call    putc            ; Print the nibble and 
1090			;                pop     af              ; restore the original value of A 
1090			;                ret 
1090			;; 
1090			;; Send a CR/LF pair: 
1090			; 
1090			;crlf            push    af 
1090			;                ld      a, cr 
1090			;                call    putc 
1090			;                ld      a, lf 
1090			;                call    putc 
1090			;                pop     af 
1090			;                ret 
1090			; 
1090			; Print_word prints the four hex digits of a word to the serial line. The  
1090			; word is expected to be in HL. 
1090			; 
1090			;print_word      push    hl 
1090			;                push    af 
1090			;                ld      a, h 
1090			;                call    print_byte 
1090			;                ld      a, l 
1090			;                call    print_byte 
1090			;                pop     af 
1090			;                pop     hl 
1090			;                ret 
1090			; 
1090			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1090			; The byte to be printed is expected to be in A. 
1090			; 
1090			;print_byte      push    af              ; Save the contents of the registers 
1090			;                push    bc 
1090			;                ld      b, a 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                call    print_nibble    ; Print high nibble 
1090			;                ld      a, b 
1090			;                call    print_nibble    ; Print low nibble 
1090			;                pop     bc              ; Restore original register contents 
1090			;                pop     af 
1090			;                ret 
1090			 
1090			 
1090			 
1090			 
1090			 
1090			fourehexhl:  
1090 7e				ld a,(hl) 
1091 cd 3f 10			call atohex 
1094 cb 3f				SRL A 
1096 cb 3f				SRL A 
1098 cb 3f				SRL A 
109a cb 3f				SRL A 
109c 47				ld b, a 
109d 23				inc hl 
109e 7e				ld a,(hl) 
109f 23				inc hl 
10a0 cd 3f 10			call atohex 
10a3 80				add b 
10a4 57				ld d,a 
10a5 7e				ld a,(hl) 
10a6 cd 3f 10			call atohex 
10a9 cb 3f				SRL A 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 47				ld b, a 
10b2 23				inc hl 
10b3 7e				ld a,(hl) 
10b4 23				inc hl 
10b5 cd 3f 10			call atohex 
10b8 80				add b 
10b9 5f				ld e, a 
10ba d5				push de 
10bb e1				pop hl 
10bc c9				ret 
10bd			 
10bd			; pass hl. returns z set if the byte at hl is a digit 
10bd			;isdigithl:  
10bd			;	push bc 
10bd			;	ld a,(hl) 
10bd			;	cp ':' 
10bd			;	jr nc, .isdf 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .isdf		; < 
10bd			; 
10bd			;	; TODO find a better way to set z 
10bd			; 
10bd			;	ld b,a 
10bd			;	cp b 
10bd			;	pop bc 
10bd			;	ret 
10bd			; 
10bd			;.isdf:	; not digit so clear z 
10bd			; 
10bd			;	; TODO find a better way to unset z 
10bd			; 
10bd			;	ld b,a 
10bd			;	inc b 
10bd			;	cp b 
10bd			; 
10bd			;	pop bc 
10bd			;	ret 
10bd				 
10bd				 
10bd			 
10bd			 
10bd			; pass hl as the four byte address to load 
10bd			 
10bd			get_word_hl:  
10bd e5				push hl 
10be cd 5d 10			call get_byte 
10c1				 
10c1 47				ld b, a 
10c2			 
10c2 e1				pop hl 
10c3 23				inc hl 
10c4 23				inc hl 
10c5			 
10c5			; TODO not able to handle a-f  
10c5 7e				ld a,(hl) 
10c6			;	;cp ':' 
10c6			;	cp 'g' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp 'G' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp '0' 
10c6			;	jr c, .single_byte_hl		; < 
10c6			 
10c6				;call isdigithl 
10c6 fe 00			cp 0 
10c8 28 06			jr z, .single_byte_hl 
10ca			 
10ca			.getwhln:   ; hex word so get next byte 
10ca			 
10ca cd 5d 10			call get_byte 
10cd 6f				ld l, a 
10ce 60				ld h,b 
10cf c9				ret 
10d0 68			.single_byte_hl:   ld l,b 
10d1 26 00				ld h,0 
10d3 c9					ret 
10d4			 
10d4			 
10d4			 
10d4			 
10d4 21 11 19			ld hl,asc+1 
10d7			;	ld a, (hl) 
10d7			;	call nibble2val 
10d7 cd 5d 10			call get_byte 
10da			 
10da			;	call fourehexhl 
10da 32 d7 ef			ld (scratch+52),a 
10dd				 
10dd 21 d5 ef			ld hl,scratch+50 
10e0 22 c6 f2			ld (os_cur_ptr),hl 
10e3			 
10e3 c9				ret 
10e4			 
10e4			 
10e4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e4			 
10e4			; Decimal Unsigned Version 
10e4			 
10e4			;Number in a to decimal ASCII 
10e4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e4			;Example: display a=56 as "056" 
10e4			;input: a = number 
10e4			;Output: a=0,value of a in the screen 
10e4			;destroys af,bc (don't know about hl and de) 
10e4			DispAToASCII: 
10e4 0e 9c			ld	c,-100 
10e6 cd f0 10			call	.Na1 
10e9 0e f6			ld	c,-10 
10eb cd f0 10			call	.Na1 
10ee 0e ff			ld	c,-1 
10f0 06 2f		.Na1:	ld	b,'0'-1 
10f2 04			.Na2:	inc	b 
10f3 81				add	a,c 
10f4 38 fc			jr	c,.Na2 
10f6 91				sub	c		;works as add 100/10/1 
10f7 f5				push af		;safer than ld c,a 
10f8 78				ld	a,b		;char is in b 
10f9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f9 f1				pop af		;safer than ld a,c 
10fa c9				ret 
10fb			 
10fb			; Decimal Signed Version 
10fb			 
10fb			; DispA 
10fb			; -------------------------------------------------------------- 
10fb			; Converts a signed integer value to a zero-terminated ASCII 
10fb			; string representative of that value (using radix 10). 
10fb			; -------------------------------------------------------------- 
10fb			; INPUTS: 
10fb			;     HL     Value to convert (two's complement integer). 
10fb			;     DE     Base address of string destination. (pointer). 
10fb			; -------------------------------------------------------------- 
10fb			; OUTPUTS: 
10fb			;     None 
10fb			; -------------------------------------------------------------- 
10fb			; REGISTERS/MEMORY DESTROYED 
10fb			; AF HL 
10fb			; -------------------------------------------------------------- 
10fb			 
10fb			;DispHLToASCII: 
10fb			;   push    de 
10fb			;   push    bc 
10fb			; 
10fb			;; Detect sign of HL. 
10fb			;    bit    7, h 
10fb			;    jr     z, ._DoConvert 
10fb			; 
10fb			;; HL is negative. Output '-' to string and negate HL. 
10fb			;    ld     a, '-' 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			; 
10fb			;; Negate HL (using two's complement) 
10fb			;    xor    a 
10fb			;    sub    l 
10fb			;    ld     l, a 
10fb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fb			;    sbc    a, h 
10fb			;    ld     h, a 
10fb			; 
10fb			;; Convert HL to digit characters 
10fb			;._DoConvert: 
10fb			;    ld     b, 0     ; B will count character length of number 
10fb			;-   ld     a, 10 
10fb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fb			;    push   af 
10fb			;    inc    b 
10fb			;    ld     a, h 
10fb			;    or     l 
10fb			;    jr     nz, - 
10fb			; 
10fb			;; Retrieve digits from stack 
10fb			;-   pop    af 
10fb			;    or     $30 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			;    djnz   - 
10fb			; 
10fb			;; Terminate string with NULL 
10fb			;    xor    a 
10fb			;    ld     (de), a 
10fb			; 
10fb			;    pop    bc 
10fb			;    pop    de 
10fb			;    ret 
10fb			 
10fb			;Comments 
10fb			; 
10fb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fb			;    Note that the output string will not be fixed-width. 
10fb			; 
10fb			;Example Usage 
10fb			; 
10fb			;    ld    hl, -1004 
10fb			;    ld    de, OP1 
10fb			;    call  DispA 
10fb			;    ld    hl, OP1 
10fb			;    syscall  PutS 
10fb			 
10fb			 
10fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fb			 
10fb			 
10fb			;Converts an ASCII string to an unsigned 16-bit integer 
10fb			;Quits when it reaches a non-decimal digit 
10fb			 
10fb			string_to_uint16: 
10fb			atoui_16: 
10fb			;Input: 
10fb			;     DE points to the string 
10fb			;Outputs: 
10fb			;     HL is the result 
10fb			;     A is the 8-bit value of the number 
10fb			;     DE points to the byte after the number 
10fb			;Destroys: 
10fb			;     BC 
10fb			;       if the string is non-empty, BC is HL/10 
10fb			;Size:  24 bytes 
10fb			;Speed: 42+d(104+{0,9}) 
10fb			;       d is the number of digits in the number 
10fb			;       max is 640 cycles for a 5 digit number 
10fb			;Assuming no leading zeros: 
10fb			;1 digit:  146cc 
10fb			;2 digit:  250cc 
10fb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fb			;avg: 544.81158447265625cc (544+13297/16384) 
10fb			;=============================================================== 
10fb 21 00 00		  ld hl,0 
10fe			.u16a: 
10fe 1a			  ld a,(de) 
10ff d6 30		  sub 30h 
1101 fe 0a		  cp 10 
1103 d0			  ret nc 
1104 13			  inc de 
1105 44			  ld b,h 
1106 4d			  ld c,l 
1107 29			  add hl,hl 
1108 29			  add hl,hl 
1109 09			  add hl,bc 
110a 29			  add hl,hl 
110b 85			  add a,l 
110c 6f			  ld l,a 
110d 30 ef		  jr nc,.u16a 
110f 24			  inc h 
1110 c3 fe 10		  jp .u16a 
1113			 
1113			 
1113			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1113			 
1113			;written by Zeda 
1113			;Converts a 16-bit unsigned integer to an ASCII string. 
1113			 
1113			uitoa_16: 
1113			;Input: 
1113			;   DE is the number to convert 
1113			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1113			;Output: 
1113			;   HL points to the null-terminated ASCII string 
1113			;      NOTE: This isn't necessarily the same as the input HL. 
1113 d5			  push de 
1114 c5			  push bc 
1115 f5			  push af 
1116 eb			  ex de,hl 
1117			 
1117 01 f0 d8		  ld bc,-10000 
111a 3e 2f		  ld a,'0'-1 
111c 3c			  inc a 
111d 09			  add hl,bc  
111e 38 fc		   jr c,$-2 
1120 12			  ld (de),a 
1121 13			  inc de 
1122			 
1122 01 e8 03		  ld bc,1000 
1125 3e 3a		  ld a,'9'+1 
1127 3d			  dec a  
1128 09			  add hl,bc  
1129 30 fc		   jr nc,$-2 
112b 12			  ld (de),a 
112c 13			  inc de 
112d			 
112d 01 9c ff		  ld bc,-100 
1130 3e 2f		  ld a,'0'-1 
1132 3c			  inc a  
1133 09			  add hl,bc  
1134 38 fc		   jr c,$-2 
1136 12			  ld (de),a 
1137 13			  inc de 
1138			 
1138 7d			  ld a,l 
1139 26 3a		  ld h,'9'+1 
113b 25			  dec h  
113c c6 0a		  add a,10  
113e 30 fb		   jr nc,$-3 
1140 c6 30		  add a,'0' 
1142 eb			  ex de,hl 
1143 72			  ld (hl),d 
1144 23			  inc hl 
1145 77			  ld (hl),a 
1146 23			  inc hl 
1147 36 00		  ld (hl),0 
1149			 
1149			;Now strip the leading zeros 
1149 0e fa		  ld c,-6 
114b 09			  add hl,bc 
114c 3e 30		  ld a,'0' 
114e 23			  inc hl  
114f be			  cp (hl)  
1150 28 fc		  jr z,$-2 
1152			 
1152			;Make sure that the string is non-empty! 
1152 7e			  ld a,(hl) 
1153 b7			  or a 
1154 20 01		  jr nz,.atoub 
1156 2b			  dec hl 
1157			.atoub: 
1157			 
1157 f1			  pop af 
1158 c1			  pop bc 
1159 d1			  pop de 
115a c9			  ret 
115b			 
115b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115b			 
115b			toUpper: 
115b			;A is the char. 
115b			;If A is a lowercase letter, this sets it to the matching uppercase 
115b			;18cc or 30cc or 41cc 
115b			;avg: 26.75cc 
115b fe 61		  cp 'a' 
115d d8			  ret c 
115e fe 7b		  cp 'z'+1 
1160 d0			  ret nc 
1161 d6 20		  sub 'a'-'A' 
1163 c9			  ret 
1164			 
1164			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1164			 
1164			; String Length 
1164			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1164			 
1164			; Get the length of the null-terminated string starting at $8000 hl 
1164			;    LD     HL, $8000 
1164			 
1164			strlenz: 
1164			 
1164 af			    XOR    A               ; Zero is the value we are looking for. 
1165 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1166 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1167			                           ; 65, 536 bytes (the entire addressable memory space). 
1167 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1169			 
1169			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1169 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116a 6f			    LD     L, A             ; number of bytes 
116b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116d 2b			    DEC    HL              ; Compensate for null. 
116e c9				ret 
116f			 
116f			; Get the length of the A terminated string starting at $8000 hl 
116f			;    LD     HL, $8000 
116f			 
116f			strlent: 
116f			 
116f			                  ; A is the value we are looking for. 
116f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1171 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1173			                           ; 65, 536 bytes (the entire addressable memory space). 
1173 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1175			 
1175			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1175 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1177 2e 00		    LD     L, 0             ; number of bytes 
1179 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117b 2b			    DEC    HL              ; Compensate for null. 
117c c9				ret 
117d			 
117d			 
117d			;Comparing Strings 
117d			 
117d			;IN    HL     Address of string1. 
117d			;      DE     Address of string2. 
117d			 
117d			; doc given but wrong??? 
117d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
117d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
117d			; tested 
117d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
117d			 
117d			strcmp_old: 
117d e5			    PUSH   HL 
117e d5			    PUSH   DE 
117f			 
117f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1180 be			    CP     (HL)            ; (want to minimize work). 
1181 38 01		    JR     C, Str1IsBigger 
1183 7e			    LD     A, (HL) 
1184			 
1184			Str1IsBigger: 
1184 4f			    LD     C, A             ; Put length in BC 
1185 06 00		    LD     B, 0 
1187 13			    INC    DE              ; Increment pointers to meat of string. 
1188 23			    INC    HL 
1189			 
1189			CmpLoop: 
1189 1a			    LD     A, (DE)          ; Compare bytes. 
118a ed a1		    CPI 
118c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
118e 13			    INC    DE              ; Update pointer. 
118f ea 89 11		    JP     PE, CmpLoop 
1192			 
1192 d1			    POP    DE 
1193 e1			    POP    HL 
1194 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1195 be			    CP     (HL) 
1196 c9			    RET 
1197			 
1197			NoMatch: 
1197 2b			    DEC    HL 
1198 be			    CP     (HL)            ; Compare again to affect carry. 
1199 d1			    POP    DE 
119a e1			    POP    HL 
119b c9			    RET 
119c			 
119c			;; test strmp 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr z, .z1 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z1: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr z, .z2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr c, .c1 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c1: 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr c, .c2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;	NEXTW 
119c			;.str1:   db "string1",0 
119c			;.str2:   db "string2",0 
119c			 
119c			; only care about direct match or not 
119c			; hl and de strings 
119c			; zero set if the same 
119c			 
119c			strcmp: 
119c 1a				ld a, (de) 
119d be				cp (hl) 
119e 28 02			jr z, .ssame 
11a0 b7				or a 
11a1 c9				ret 
11a2			 
11a2			.ssame:  
11a2 fe 00			cp 0 
11a4 c8				ret z 
11a5			 
11a5 23				inc hl 
11a6 13				inc de 
11a7 18 f3			jr strcmp 
11a9				 
11a9				 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			; eof 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
# End of file firmware_strings.asm
11a9			include "firmware_memory.asm"   ; malloc and free  
11a9			 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			.mallocsize: db "Wants malloc >256",0 
11a9			.mallocasize: db "MALLOC gives >256",0 
11a9			.malloczero: db "MALLOC gives zero",0 
11a9			 
11a9			malloc_guard_zerolen: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9				ld de, 0 
11a9			        call cmp16 
11a9				jr nz, .lowalloz 
11a9			 
11a9				push hl 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .malloczero 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9			.lowalloz: 
11a9			 
11a9			 
11a9				pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_entry: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowalloc 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocsize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdone 
11a9			.lowalloc: 
11a9			 
11a9			 
11a9				pop hl 
11a9			.lowdone:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_exit: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowallocx 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocasize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdonex 
11a9			.lowallocx: 
11a9			 
11a9				pop hl 
11a9			.lowdonex:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			endif 
11a9			 
11a9			if MALLOC_2 
11a9			; Z80 Malloc and Free Functions 
11a9			 
11a9			; Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc: 
11a9				 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_entry 
11a9			endif 
11a9			 
11a9			 
11a9			 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "mal" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of size into A 
11a9			    or h               ; Check if size is zero 
11a9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a9			 
11a9			    ; Allocate memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma1" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    call malloc_internal ; Call internal malloc function 
11a9			    pop af             ; Restore AF register 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret                ; Return 
11a9			 
11a9			; Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free: 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of pointer into A 
11a9			    or h               ; Check if pointer is NULL 
11a9			    jp z, free_exit    ; If pointer is NULL, exit 
11a9			 
11a9			    ; Free memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9			    call free_internal  ; Call internal free function 
11a9			    pop af             ; Restore AF register 
11a9			    ret                ; Return 
11a9			 
11a9			; Internal Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc_internal: 
11a9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to requested size 
11a9			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			 
11a9			    ; Search for free memory block 
11a9			    ld de, (heap_end)  ; Load end of heap into DE 
11a9			    ld bc, 0           ; Initialize counter 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			malloc_search_loop: 
11a9			    ; Check if current block is free 
11a9			    ld a, (hl)         ; Load current block's status (free or used) 
11a9			    cp 0               ; Compare with zero (free) 
11a9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a9			 
11a9			    ; Check if current block is large enough 
11a9			    ld a, (hl+1)       ; Load high byte of block size 
11a9			    cp l               ; Compare with low byte of requested size 
11a9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a9			 
11a9			    ld a, (hl+2)       ; Load low byte of block size 
11a9			    cp h               ; Compare with high byte of requested size 
11a9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a9			 
11a9			    ; Mark block as used 
11a9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a9			 
11a9			    ; Calculate remaining space in block 
11a9			    ld bc, 0           ; Clear BC 
11a9			    add hl, bc         ; Increment HL to point to start of data block 
11a9			    add hl, de         ; HL = HL + DE (total size) 
11a9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to start of data block 
11a9			 
11a9			    ; Save pointer to allocated block in HL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma5" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			malloc_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3           ; Size of management overhead 
11a9			    add hl, bc         ; Move to the next block 
11a9			    inc de             ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e            ; Load low byte of heap end address 
11a9			    cp (hl)            ; Compare with low byte of current address 
11a9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a9			    ld a, d            ; Load high byte of heap end address 
11a9			    cp 0               ; Check if it's zero (end of memory) 
11a9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, allocation failed 
11a9			    xor a              ; Set result to NULL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma6" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			malloc_exit: 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma7" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			; Internal Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free_internal: 
11a9			    ld de, (heap_start) ; Load start of heap into DE 
11a9			    ld bc, 0            ; Initialize counter 
11a9			 
11a9			free_search_loop: 
11a9			    ; Check if current block contains the pointer 
11a9			    ld a, l             ; Load low byte of pointer 
11a9			    cp (hl+1)           ; Compare with high byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			    ld a, h             ; Load high byte of pointer 
11a9			    cp (hl+2)           ; Compare with low byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			 
11a9			    ; Mark block as free 
11a9			    ld (hl), 0          ; Set status byte to indicate free block 
11a9			    ret                 ; Return 
11a9			 
11a9			free_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3            ; Size of management overhead 
11a9			    add hl, bc          ; Move to the next block 
11a9			    inc de              ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e             ; Load low byte of heap end address 
11a9			    cp (hl)             ; Compare with low byte of current address 
11a9			    jr nz, free_search_loop  ; If not equal, continue searching 
11a9			    ld a, d             ; Load high byte of heap end address 
11a9			    cp 0                ; Check if it's zero (end of memory) 
11a9			    jr nz, free_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, pointer is not found in heap 
11a9			    ret 
11a9			 
11a9			free_exit: 
11a9			    ret                 ; Return 
11a9			 
11a9			; Define heap start and end addresses 
11a9			;heap_start:    .dw 0xC000   ; Start of heap 
11a9			;heap_end:      .dw 0xE000   ; End of heap 
11a9			 
11a9			endif 
11a9			 
11a9			 
11a9			if MALLOC_1 
11a9			 
11a9			 
11a9			 
11a9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a9			 
11a9			;moved to firmware.asm 
11a9			;heap_start        .equ  0x9000      ; Starting address of heap 
11a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a9			 
11a9			;      .org 0 
11a9			;      jp    main 
11a9			 
11a9			 
11a9			;      .org  0x100 
11a9			;main: 
11a9			;      ld    HL, 0x8100 
11a9			;      ld    SP, HL 
11a9			; 
11a9			;      call  heap_init 
11a9			; 
11a9			;      ; Make some allocations 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9004 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9014 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9024 
11a9			; 
11a9			;      ; Free some allocations 
11a9			;      ld    HL, 0x9014 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9004 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9024 
11a9			;      call  free 
11a9			; 
11a9			; 
11a9			;      halt 
11a9			 
11a9			 
11a9			;------------------------------------------------------------------------------ 
11a9			;     heap_init                                                               : 
11a9			;                                                                             : 
11a9			; Description                                                                 : 
11a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a9			;                                                                             : 
11a9			;     The heap is maintained as a linked list, starting with an initial       : 
11a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a9			;     the first free block in the heap. Each block then points to the next    : 
11a9			;     free block within the heap, and the free list ends at the first block   : 
11a9			;     with a null pointer to the next free block.                             : 
11a9			;                                                                             : 
11a9			; Parameters                                                                  : 
11a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a9			;     address of the heap and its size are required, along with a memory      : 
11a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a9			;     principally stores a pointer to the first free block in the heap.       : 
11a9			;                                                                             : 
11a9			; Returns                                                                     : 
11a9			;     Nothing                                                                 : 
11a9			;------------------------------------------------------------------------------ 
11a9			heap_init: 
11a9 e5			      push  HL 
11aa			 
11aa			      ; Initialise free list struct 
11aa 21 0e 80		      ld    HL, heap_start 
11ad 22 0a 80		      ld    (free_list), HL 
11b0 21 00 00		      ld    HL, 0 
11b3 22 0c 80		      ld    (free_list+2), HL 
11b6			 
11b6			      ; Insert first free block at bottom of heap, consumes entire heap 
11b6 21 0a 80		      ld    HL, heap_start+heap_size-4 
11b9 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bc 21 fc ff		      ld    HL, heap_size-4 
11bf 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c2			 
11c2			      ; Insert end of free list block at top of heap - two null words will 
11c2			      ; terminate the free list 
11c2 21 00 00		      ld    HL, 0 
11c5 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11c8 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11cb			 
11cb e1			      pop   HL 
11cc			 
11cc c9			      ret 
11cd			 
11cd			 
11cd			;------------------------------------------------------------------------------ 
11cd			;     malloc                                                                  : 
11cd			;                                                                             : 
11cd			; Description                                                                 : 
11cd			;     Allocates the wanted space from the heap and returns the address of the : 
11cd			;     first useable byte of the allocation.                                   : 
11cd			;                                                                             : 
11cd			;     Allocations can happen in one of two ways:                              : 
11cd			;                                                                             : 
11cd			;     1. A free block may be found which is the exact size wanted. In this    : 
11cd			;        case the block is removed from the free list and retuedn to the      : 
11cd			;        caller.                                                              : 
11cd			;     2. A free block may be found which is larger than the size wanted. In   : 
11cd			;        this case, the larger block is split into two. The first portion of  : 
11cd			;        this block will become the requested space by the malloc call and    : 
11cd			;        is returned to the caller. The second portion becomes a new free     : 
11cd			;        block, and the free list is adjusted to maintain continuity via this : 
11cd			;        newly created block.                                                 : 
11cd			;                                                                             : 
11cd			;     malloc does not set any initial value in the allocated space, the       : 
11cd			;     caller is required to do this as required.                              : 
11cd			;                                                                             : 
11cd			;     This implementation of malloc uses the stack exclusively, and is        : 
11cd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cd			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cd			;     to avoid the use of malloc inside ISRs in general.                      : 
11cd			;                                                                             : 
11cd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cd			;                                                                             : 
11cd			; Parameters                                                                  : 
11cd			;     HL  Number of bytes wanted                                              : 
11cd			;                                                                             : 
11cd			; Returns                                                                     : 
11cd			;     HL  Address of the first useable byte of the allocation                 : 
11cd			;                                                                             : 
11cd			; Flags                                                                       : 
11cd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cd			;                                                                             : 
11cd			; Stack frame                                                                 : 
11cd			;       |             |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     BC      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     DE      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     IX      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |  prev_free  |                                                       : 
11cd			;   +4  +-------------+                                                       : 
11cd			;       |  this_free  |                                                       : 
11cd			;   +2  +-------------+                                                       : 
11cd			;       |  next_free  |                                                       : 
11cd			;   +0  +-------------+                                                       : 
11cd			;       |             |                                                       : 
11cd			;                                                                             : 
11cd			;------------------------------------------------------------------------------ 
11cd			 
11cd			 
11cd			;malloc: 
11cd			; 
11cd			;	SAVESP ON 1 
11cd			; 
11cd			;	call malloc_code 
11cd			; 
11cd			;	CHECKSP ON 1 
11cd			;	ret 
11cd			 
11cd			 
11cd			malloc: 
11cd c5			      push  BC 
11ce d5			      push  DE 
11cf dd e5		      push  IX 
11d1			if DEBUG_FORTH_MALLOC_HIGH 
11d1			call malloc_guard_entry 
11d1			endif 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "mal" 
11d1						CALLMONITOR 
11d1					endif 
11d1 7c			      ld    A, H                    ; Exit if no space requested 
11d2 b5			      or    L 
11d3 ca 92 12		      jp    Z, malloc_early_exit 
11d6			 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			; 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			 
11d6			 
11d6			 
11d6			 
11d6					if DEBUG_FORTH_MALLOC 
11d6						DMARK "maA" 
11d6						CALLMONITOR 
11d6					endif 
11d6			      ; Set up stack frame 
11d6 eb			      ex    DE, HL 
11d7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11da 39			      add   HL, SP 
11db f9			      ld    SP, HL 
11dc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e0 dd 39		      add   IX, SP 
11e2			 
11e2			      ; Setup initial state 
11e2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e5 19			      add   HL, DE 
11e6			 
11e6 44			      ld    B, H                    ; Move want to BC 
11e7 4d			      ld    C, L 
11e8			 
11e8 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11eb dd 75 04		      ld    (IX+4), L 
11ee dd 74 05		      ld    (IX+5), H 
11f1			 
11f1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 dd 73 02		      ld    (IX+2), E 
11f7 dd 72 03		      ld    (IX+3), D 
11fa eb			      ex    DE, HL                  ; this_free ptr into HL 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "maB" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Loop through free block list to find some space 
11fb			malloc_find_space: 
11fb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fc 23			      inc   HL 
11fd 56			      ld    D, (HL) 
11fe			 
11fe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11ff b3			      or    E 
1200 ca 8c 12		      jp    Z, malloc_no_space 
1203			 
1203 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1206 dd 72 01		      ld    (IX+1), D 
1209			 
1209			      ; Does this block have enough space to make the allocation? 
1209 23			      inc   HL                      ; Load free block size into DE 
120a 5e			      ld    E, (HL) 
120b 23			      inc   HL 
120c 56			      ld    D, (HL) 
120d			 
120d eb			      ex    DE, HL                  ; Check size of block against want 
120e b7			      or    A                       ; Ensure carry flag clear 
120f ed 42		      sbc   HL, BC 
1211 e5			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212 ca 61 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1217			 
1217			      ; this_free block is not big enough, setup ptrs to test next free block 
1217 e1			      pop   HL                      ; Discard previous result 
1218			 
1218 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121b dd 66 03		      ld    H, (IX+3) 
121e dd 75 04		      ld    (IX+4), L 
1221 dd 74 05		      ld    (IX+5), H 
1224			 
1224 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1227 dd 66 01		      ld    H, (IX+1) 
122a dd 75 02		      ld    (IX+2), L 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MA>" 
1230						CALLMONITOR 
1230					endif 
1230 18 c9		      jr    malloc_find_space 
1232			 
1232			      ; split a bigger block into two - requested size and remaining size 
1232			malloc_alloc_split: 
1232					if DEBUG_FORTH_MALLOC 
1232						DMARK "MAs" 
1232						CALLMONITOR 
1232					endif 
1232 eb			      ex    DE, HL                  ; Calculate address of new free block 
1233 2b			      dec   HL 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 09			      add   HL, BC 
1237			 
1237			      ; Create a new block and point it at next_free 
1237 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123a dd 56 01		      ld    D, (IX+1) 
123d			 
123d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240 d1			      pop   DE                      ; Store size of new block into new block 
1241 23			      inc   HL 
1242 73			      ld    (HL), E 
1243 23			      inc   HL 
1244 72			      ld    (HL), D 
1245			 
1245			      ; Update this_free ptr to point to new block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248			 
1248 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124b dd 56 03		      ld    D, (IX+3) 
124e			 
124e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1251 dd 74 03		      ld    (IX+3), H 
1254			 
1254			      ; Modify this_free block to be allocation 
1254 eb			      ex    DE, HL 
1255 af			      xor   A                       ; Null the next block ptr of allocated block 
1256 77			      ld    (HL), A 
1257 23			      inc   HL 
1258 77			      ld    (HL), A 
1259			 
1259 23			      inc   HL                      ; Store want size into allocated block 
125a 71			      ld    (HL), C 
125b 23			      inc   HL 
125c 70			      ld    (HL), B 
125d 23			      inc   HL 
125e e5			      push  HL                      ; Address of allocation to return 
125f			 
125f 18 19		      jr    malloc_update_links 
1261			 
1261			malloc_alloc_fit: 
1261 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1262			 
1262					if DEBUG_FORTH_MALLOC 
1262						DMARK "MAf" 
1262						CALLMONITOR 
1262					endif 
1262			      ; Modify this_free block to be allocation 
1262 eb			      ex    DE, HL 
1263 2b			      dec   HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266			 
1266 af			      xor   A                       ; Null the next block ptr of allocated block 
1267 77			      ld    (HL), A 
1268 23			      inc   HL 
1269 77			      ld    (HL), A 
126a			 
126a 23			      inc   HL                      ; Store address of allocation to return 
126b 23			      inc   HL 
126c 23			      inc   HL 
126d e5			      push  HL 
126e			 
126e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1271 dd 66 01		      ld    H, (IX+1) 
1274			 
1274 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1277 dd 74 03		      ld    (IX+3), H 
127a			 
127a			 
127a			malloc_update_links: 
127a			      ; Update prev_free ptr to point to this_free 
127a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127d dd 66 05		      ld    H, (IX+5) 
1280			 
1280 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1283 dd 56 03		      ld    D, (IX+3) 
1286			 
1286 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1287 23			      inc   HL 
1288 72			      ld    (HL), D 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "Mul" 
1289						CALLMONITOR 
1289					endif 
1289			      ; Clear the Z flag to indicate successful allocation 
1289 7a			      ld    A, D 
128a b3			      or    E 
128b			 
128b d1			      pop   DE                      ; Address of allocation 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "MAu" 
128c						CALLMONITOR 
128c					endif 
128c			 
128c			malloc_no_space: 
128c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128f 39			      add   HL, SP 
1290 f9			      ld    SP, HL 
1291			 
1291 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAN" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_early_exit: 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAx" 
1292						CALLMONITOR 
1292					endif 
1292 dd e1		      pop   IX 
1294 d1			      pop   DE 
1295 c1			      pop   BC 
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296 c9			      ret 
1297			 
1297			 
1297			;------------------------------------------------------------------------------ 
1297			;     free                                                                    : 
1297			;                                                                             : 
1297			; Description                                                                 : 
1297			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1297			;     returned by malloc, otherwise the behaviour is undefined.               : 
1297			;                                                                             : 
1297			;     Where possible, directly adjacent free blocks will be merged together   : 
1297			;     into larger blocks to help ensure that the heap does not become         : 
1297			;     excessively fragmented.                                                 : 
1297			;                                                                             : 
1297			;     free does not clear or set any other value into the freed space, and    : 
1297			;     therefore its contents may be visible through subsequent malloc's. The  : 
1297			;     caller should clear the freed space as required.                        : 
1297			;                                                                             : 
1297			;     This implementation of free uses the stack exclusively, and is          : 
1297			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1297			;     advisable to disable interrupts before calling free, and recommended    : 
1297			;     to avoid the use of free inside ISRs in general.                        : 
1297			;                                                                             : 
1297			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1297			;                                                                             : 
1297			; Parameters                                                                  : 
1297			;     HL  Pointer to address of first byte of allocation to be freed          : 
1297			;                                                                             : 
1297			; Returns                                                                     : 
1297			;     Nothing                                                                 : 
1297			;                                                                             : 
1297			; Stack frame                                                                 : 
1297			;       |             |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     BC      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     DE      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     IX      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |  prev_free  |                                                       : 
1297			;   +2  +-------------+                                                       : 
1297			;       |  next_free  |                                                       : 
1297			;   +0  +-------------+                                                       : 
1297			;       |             |                                                       : 
1297			;                                                                             : 
1297			;------------------------------------------------------------------------------ 
1297			free: 
1297 c5			      push  BC 
1298 d5			      push  DE 
1299 dd e5		      push  IX 
129b			 
129b 7c			      ld    A, H                    ; Exit if ptr is null 
129c b5			      or    L 
129d ca 61 13		      jp    Z, free_early_exit 
12a0			 
12a0			      ; Set up stack frame 
12a0 eb			      ex    DE, HL 
12a1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12aa dd 39		      add   IX, SP 
12ac			 
12ac			      ; The address in HL points to the start of the useable allocated space, 
12ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ac			      ; address of the block itself. 
12ac eb			      ex    DE, HL 
12ad 11 fc ff		      ld    DE, -4 
12b0 19			      add   HL, DE 
12b1			 
12b1			      ; An allocated block must have a null next block pointer in it 
12b1 7e			      ld    A, (HL) 
12b2 23			      inc   HL 
12b3 b6			      or    (HL) 
12b4 c2 5c 13		      jp    NZ, free_done 
12b7			 
12b7 2b			      dec   HL 
12b8			 
12b8 44			      ld    B, H                    ; Copy HL to BC 
12b9 4d			      ld    C, L 
12ba			 
12ba			      ; Loop through the free list to find the first block with an address 
12ba			      ; higher than the block being freed 
12ba 21 0a 80		      ld    HL, free_list 
12bd			 
12bd			free_find_higher_block: 
12bd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 2b			      dec   HL 
12c1			 
12c1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c4 dd 72 01		      ld    (IX+1), D 
12c7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12ca dd 74 03		      ld    (IX+3), H 
12cd			 
12cd 78			      ld    A, B                    ; Check if DE is greater than BC 
12ce ba			      cp    D                       ; Compare MSB first 
12cf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d1 30 04		      jr    NC, free_find_higher_block_skip 
12d3 79			      ld    A, C 
12d4 bb			      cp    E                       ; Then compare LSB 
12d5 38 08		      jr    C, free_found_higher_block 
12d7			 
12d7			free_find_higher_block_skip: 
12d7 7a			      ld    A, D                    ; Reached the end of the free list? 
12d8 b3			      or    E 
12d9 ca 5c 13		      jp    Z, free_done 
12dc			 
12dc eb			      ex    DE, HL 
12dd			 
12dd 18 de		      jr    free_find_higher_block 
12df			 
12df			free_found_higher_block: 
12df			      ; Insert freed block between prev and next free blocks 
12df 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e0 23			      inc   HL 
12e1 70			      ld    (HL), B 
12e2			 
12e2 60			      ld    H, B                    ; Point freed block at next free block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7			      ; Check if the freed block is adjacent to the next free block 
12e7 23			      inc   HL                      ; Load size of freed block into HL 
12e8 5e			      ld    E, (HL) 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb eb			      ex    DE, HL 
12ec			 
12ec 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ed			 
12ed dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f0 dd 56 01		      ld    D, (IX+1) 
12f3			 
12f3 b7			      or    A                       ; Clear the carry flag 
12f4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f8			 
12f8			      ; Freed block is adjacent to next, merge into one bigger block 
12f8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f9 5e			      ld    E, (HL) 
12fa 23			      inc   HL 
12fb 56			      ld    D, (HL) 
12fc e5			      push  HL                      ; Save ptr to next block for later 
12fd			 
12fd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fe 69			      ld    L, C 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore ptr to next block 
1303 23			      inc   HL                      ; Load size of next block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save next block size for later 
1308			 
1308 60			      ld    H, B                    ; Load size of freed block into HL 
1309 69			      ld    L, C 
130a 23			      inc   HL 
130b 23			      inc   HL 
130c 5e			      ld    E, (HL) 
130d 23			      inc   HL 
130e 56			      ld    D, (HL) 
130f eb			      ex    DE, HL 
1310			 
1310 d1			      pop   DE                      ; Restore size of next block 
1311 19			      add   HL, DE                  ; Add sizes of both blocks 
1312 eb			      ex    DE, HL 
1313			 
1313 60			      ld    H, B                    ; Store new bigger size into freed block 
1314 69			      ld    L, C 
1315 23			      inc   HL 
1316 23			      inc   HL 
1317 73			      ld    (HL), E 
1318 23			      inc   HL 
1319 72			      ld    (HL), D 
131a			 
131a			free_check_adjacent_to_prev: 
131a			      ; Check if the freed block is adjacent to the prev free block 
131a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131d dd 66 03		      ld    H, (IX+3) 
1320			 
1320 23			      inc   HL                      ; Size of prev free block into DE 
1321 23			      inc   HL 
1322 5e			      ld    E, (HL) 
1323 23			      inc   HL 
1324 56			      ld    D, (HL) 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 19			      add   HL, DE                  ; Add prev block addr and size 
1329			 
1329 b7			      or    A                       ; Clear the carry flag 
132a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132c 20 2e		      jr    NZ, free_done 
132e			 
132e			      ; Freed block is adjacent to prev, merge into one bigger block 
132e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132f 69			      ld    L, C 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333 e5			      push  HL                      ; Save freed block ptr for later 
1334			 
1334 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1337 dd 66 03		      ld    H, (IX+3) 
133a 73			      ld    (HL), E 
133b 23			      inc   HL 
133c 72			      ld    (HL), D 
133d			 
133d e1			      pop   HL                      ; Restore freed block ptr 
133e 23			      inc   HL                      ; Load size of freed block into DE 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342 d5			      push  DE                      ; Save freed block size for later 
1343			 
1343 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1346 dd 66 03		      ld    H, (IX+3) 
1349 23			      inc   HL 
134a 23			      inc   HL 
134b 5e			      ld    E, (HL) 
134c 23			      inc   HL 
134d 56			      ld    D, (HL) 
134e			 
134e e1			      pop   HL                      ; Add sizes of both blocks 
134f 19			      add   HL, DE 
1350 eb			      ex    DE, HL 
1351			 
1351 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1354 dd 66 03		      ld    H, (IX+3) 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 73			      ld    (HL), E 
135a 23			      inc   HL 
135b 72			      ld    (HL), D 
135c			 
135c			free_done: 
135c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135f 39			      add   HL, SP 
1360 f9			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361 dd e1		      pop   IX 
1363 d1			      pop   DE 
1364 c1			      pop   BC 
1365			 
1365 c9			      ret 
1366			 
1366			; moved to firmware.asm 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			;                  .dw   0 
1366			 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_3 
1366			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1366			;heap_start        .equ  0x9000      ; Starting address of heap 
1366			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1366			; 
1366			 ;     .org 0 
1366			  ;    jp    main 
1366			; 
1366			; 
1366			 ;     .org  0x100 
1366			;main: 
1366			 ;     ld    HL, 0x8100 
1366			  ;    ld    SP, HL 
1366			; 
1366			;      call  heap_init 
1366			 
1366			      ; Make some allocations 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9004 
1366			; 
1366			 ;     ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9014 
1366			 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9024 
1366			 
1366			      ; Free some allocations 
1366			;      ld    HL, 0x9014 
1366			;      call  free 
1366			 
1366			;      ld    HL, 0x9004 
1366			;      call  free 
1366			; 
1366			;      ld    HL, 0x9024 
1366			;      call  free 
1366			 
1366			 
1366			 ;     halt 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     heap_init                                                               : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Initialise the heap and make it ready for malloc and free operations.   : 
1366			;                                                                             : 
1366			;     The heap is maintained as a linked list, starting with an initial       : 
1366			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1366			;     the first free block in the heap. Each block then points to the next    : 
1366			;     free block within the heap, and the free list ends at the first block   : 
1366			;     with a null pointer to the next free block.                             : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     Inputs are compile-time only. Two defines which specify the starting    : 
1366			;     address of the heap and its size are required, along with a memory      : 
1366			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1366			;     principally stores a pointer to the first free block in the heap.       : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;------------------------------------------------------------------------------ 
1366			heap_init: 
1366			      push  HL 
1366			 
1366			      ; Initialise free list struct 
1366			      ld    HL, heap_start 
1366			      ld    (free_list), HL 
1366			      ld    HL, 0 
1366			      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366			      ld    HL, heap_start+heap_size-4 
1366			      ld    (heap_start), HL        ; Next block (end of free list) 
1366			      ld    HL, heap_size-4 
1366			      ld    (heap_start+2), HL      ; Block size 
1366			 
1366			      ; Insert end of free list block at top of heap - two null words will 
1366			      ; terminate the free list 
1366			      ld    HL, 0 
1366			      ld    (heap_start+heap_size-2), HL 
1366			      ld    (heap_start+heap_size-4), HL 
1366			 
1366			      pop   HL 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     malloc                                                                  : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Allocates the wanted space from the heap and returns the address of the : 
1366			;     first useable byte of the allocation.                                   : 
1366			;                                                                             : 
1366			;     Allocations can happen in one of two ways:                              : 
1366			;                                                                             : 
1366			;     1. A free block may be found which is the exact size wanted. In this    : 
1366			;        case the block is removed from the free list and retuedn to the      : 
1366			;        caller.                                                              : 
1366			;     2. A free block may be found which is larger than the size wanted. In   : 
1366			;        this case, the larger block is split into two. The first portion of  : 
1366			;        this block will become the requested space by the malloc call and    : 
1366			;        is returned to the caller. The second portion becomes a new free     : 
1366			;        block, and the free list is adjusted to maintain continuity via this : 
1366			;        newly created block.                                                 : 
1366			;                                                                             : 
1366			;     malloc does not set any initial value in the allocated space, the       : 
1366			;     caller is required to do this as required.                              : 
1366			;                                                                             : 
1366			;     This implementation of malloc uses the stack exclusively, and is        : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling malloc, and recommended  : 
1366			;     to avoid the use of malloc inside ISRs in general.                      : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Number of bytes wanted                                              : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     HL  Address of the first useable byte of the allocation                 : 
1366			;                                                                             : 
1366			; Flags                                                                       : 
1366			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +4  +-------------+                                                       : 
1366			;       |  this_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			malloc: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if no space requested 
1366			      or    L 
1366			      jp    Z, malloc_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; Setup initial state 
1366			      ld    HL, 4                   ; want must also include space used by block struct 
1366			      add   HL, DE 
1366			 
1366			      ld    B, H                    ; Move want to BC 
1366			      ld    C, L 
1366			 
1366			      ld    HL, free_list           ; Store prev_free ptr to stack 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    E, (HL)                 ; Store this_free ptr to stack 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ld    (IX+2), E 
1366			      ld    (IX+3), D 
1366			      ex    DE, HL                  ; this_free ptr into HL 
1366			 
1366			      ; Loop through free block list to find some space 
1366			malloc_find_space: 
1366			      ld    E, (HL)                 ; Load next_free ptr into DE 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1366			      or    E 
1366			      jp    Z, malloc_no_space 
1366			 
1366			      ld    (IX+0), E               ; Store next_free ptr to stack 
1366			      ld    (IX+1), D 
1366			 
1366			      ; Does this block have enough space to make the allocation? 
1366			      inc   HL                      ; Load free block size into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ex    DE, HL                  ; Check size of block against want 
1366			      or    A                       ; Ensure carry flag clear 
1366			      sbc   HL, BC 
1366			      push  HL                      ; Store the result for later (new block size) 
1366			 
1366			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1366			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1366			 
1366			      ; this_free block is not big enough, setup ptrs to test next free block 
1366			      pop   HL                      ; Discard previous result 
1366			 
1366			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1366			      ld    H, (IX+3) 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1366			      ld    H, (IX+1) 
1366			      ld    (IX+2), L 
1366			      ld    (IX+3), H 
1366			 
1366			      jr    malloc_find_space 
1366			 
1366			      ; split a bigger block into two - requested size and remaining size 
1366			malloc_alloc_split: 
1366			      ex    DE, HL                  ; Calculate address of new free block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      add   HL, BC 
1366			 
1366			      ; Create a new block and point it at next_free 
1366			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      ld    (HL), E                 ; Store next_free ptr into new block 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   DE                      ; Store size of new block into new block 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Update this_free ptr to point to new block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1366			      ld    (IX+3), H 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store want size into allocated block 
1366			      ld    (HL), C 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			      inc   HL 
1366			      push  HL                      ; Address of allocation to return 
1366			 
1366			      jr    malloc_update_links 
1366			 
1366			malloc_alloc_fit: 
1366			      pop   HL                      ; Dont need new block size, want is exact fit 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store address of allocation to return 
1366			      inc   HL 
1366			      inc   HL 
1366			      push  HL 
1366			 
1366			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1366			      ld    L, (IX+0)               ; next_free to HL 
1366			      ld    H, (IX+1) 
1366			 
1366			      ld    (IX+2), L               ; HL to this_free 
1366			      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366			      ld    L, (IX+4)               ; prev_free ptr to HL 
1366			      ld    H, (IX+5) 
1366			 
1366			      ld    E, (IX+2)               ; this_free ptr to DE 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (HL), E                 ; this_free ptr into prev_free 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Clear the Z flag to indicate successful allocation 
1366			      ld    A, D 
1366			      or    E 
1366			 
1366			      pop   DE                      ; Address of allocation 
1366			 
1366			malloc_no_space: 
1366			      ld    HL, 6                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			      ex    DE, HL                  ; Alloc addr into HL for return 
1366			 
1366			malloc_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     free                                                                    : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1366			;     returned by malloc, otherwise the behaviour is undefined.               : 
1366			;                                                                             : 
1366			;     Where possible, directly adjacent free blocks will be merged together   : 
1366			;     into larger blocks to help ensure that the heap does not become         : 
1366			;     excessively fragmented.                                                 : 
1366			;                                                                             : 
1366			;     free does not clear or set any other value into the freed space, and    : 
1366			;     therefore its contents may be visible through subsequent malloc's. The  : 
1366			;     caller should clear the freed space as required.                        : 
1366			;                                                                             : 
1366			;     This implementation of free uses the stack exclusively, and is          : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling free, and recommended    : 
1366			;     to avoid the use of free inside ISRs in general.                        : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Pointer to address of first byte of allocation to be freed          : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			free: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if ptr is null 
1366			      or    L 
1366			      jp    Z, free_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; The address in HL points to the start of the useable allocated space, 
1366			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1366			      ; address of the block itself. 
1366			      ex    DE, HL 
1366			      ld    DE, -4 
1366			      add   HL, DE 
1366			 
1366			      ; An allocated block must have a null next block pointer in it 
1366			      ld    A, (HL) 
1366			      inc   HL 
1366			      or    (HL) 
1366			      jp    NZ, free_done 
1366			 
1366			      dec   HL 
1366			 
1366			      ld    B, H                    ; Copy HL to BC 
1366			      ld    C, L 
1366			 
1366			      ; Loop through the free list to find the first block with an address 
1366			      ; higher than the block being freed 
1366			      ld    HL, free_list 
1366			 
1366			free_find_higher_block: 
1366			      ld    E, (HL)                 ; Load next ptr from free block 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			 
1366			      ld    (IX+0), E               ; Save ptr to next free block 
1366			      ld    (IX+1), D 
1366			      ld    (IX+2), L               ; Save ptr to prev free block 
1366			      ld    (IX+3), H 
1366			 
1366			      ld    A, B                    ; Check if DE is greater than BC 
1366			      cp    D                       ; Compare MSB first 
1366			      jr    Z, $+4                  ; MSB the same, compare LSB 
1366			      jr    NC, free_find_higher_block_skip 
1366			      ld    A, C 
1366			      cp    E                       ; Then compare LSB 
1366			      jr    C, free_found_higher_block 
1366			 
1366			free_find_higher_block_skip: 
1366			      ld    A, D                    ; Reached the end of the free list? 
1366			      or    E 
1366			      jp    Z, free_done 
1366			 
1366			      ex    DE, HL 
1366			 
1366			      jr    free_find_higher_block 
1366			 
1366			free_found_higher_block: 
1366			      ; Insert freed block between prev and next free blocks 
1366			      ld    (HL), C                 ; Point prev free block to freed block 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			 
1366			      ld    H, B                    ; Point freed block at next free block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Check if the freed block is adjacent to the next free block 
1366			      inc   HL                      ; Load size of freed block into HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      add   HL, BC                  ; Add addr of freed block and its size 
1366			 
1366			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_check_adjacent_to_prev 
1366			 
1366			      ; Freed block is adjacent to next, merge into one bigger block 
1366			      ex    DE, HL                  ; Load next ptr from next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save ptr to next block for later 
1366			 
1366			      ld    H, B                    ; Store ptr from next block into freed block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore ptr to next block 
1366			      inc   HL                      ; Load size of next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save next block size for later 
1366			 
1366			      ld    H, B                    ; Load size of freed block into HL 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      pop   DE                      ; Restore size of next block 
1366			      add   HL, DE                  ; Add sizes of both blocks 
1366			      ex    DE, HL 
1366			 
1366			      ld    H, B                    ; Store new bigger size into freed block 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_check_adjacent_to_prev: 
1366			      ; Check if the freed block is adjacent to the prev free block 
1366			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1366			      ld    H, (IX+3) 
1366			 
1366			      inc   HL                      ; Size of prev free block into DE 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      add   HL, DE                  ; Add prev block addr and size 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_done 
1366			 
1366			      ; Freed block is adjacent to prev, merge into one bigger block 
1366			      ld    H, B                    ; Load next ptr from freed block into DE 
1366			      ld    L, C 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save freed block ptr for later 
1366			 
1366			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1366			      ld    H, (IX+3) 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore freed block ptr 
1366			      inc   HL                      ; Load size of freed block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save freed block size for later 
1366			 
1366			      ld    L, (IX+2)               ; Load size of prev block into DE 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      pop   HL                      ; Add sizes of both blocks 
1366			      add   HL, DE 
1366			      ex    DE, HL 
1366			 
1366			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_done: 
1366			      ld    HL, 4                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			free_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;      .org 0x8000 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			 ;                 .dw   0 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_4 
1366			 
1366			; My memory allocation code. Very very simple.... 
1366			; allocate space under 250 chars 
1366			 
1366			heap_init: 
1366				; init start of heap as zero 
1366				;  
1366			 
1366				ld hl, heap_start 
1366				ld a, 0 
1366				ld (hl), a      ; empty block 
1366				inc hl 
1366				ld a, 0 
1366				ld (hl), a      ; length of block 
1366				; write end of list 
1366				inc hl 
1366				ld a,(hl) 
1366				inc hl 
1366				ld a,(hl) 
1366				 
1366			 
1366				; init some malloc vars 
1366			 
1366				ld hl, 0 
1366				ld (free_list), hl       ; store last malloc location 
1366			 
1366				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1366				ld a, 0 
1366				ld (hl), a 
1366			 
1366			 
1366				ld hl, heap_start 
1366				;  
1366				  
1366				ret 
1366			 
1366			 
1366			;    free block marker 
1366			;    requested size  
1366			;    pointer to next block 
1366			;    .... 
1366			;    next block marker 
1366			 
1366			 
1366			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1366			; 
1366			 
1366			 
1366			malloc:  
1366				push de 
1366				push bc 
1366				push af 
1366			 
1366				; hl space required 
1366				 
1366				ld c, l    ; hold space   (TODO only a max of 255) 
1366			 
1366			;	inc c     ; TODO BUG need to fix memory leak on push str 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			 
1366			 
1366			 
1366				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1366			 
1366				ld a, (free_list+3) 
1366				cp 0 
1366				jr z, .contheap 
1366			 
1366				ld hl, (free_list)     ; get last alloc 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mrs" 
1366						CALLMONITOR 
1366					endif 
1366				jr .startalloc 
1366			 
1366			.contheap: 
1366				ld hl, heap_start 
1366			 
1366			.startalloc: 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mym" 
1366						CALLMONITOR 
1366					endif 
1366			.findblock: 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmf" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366				ld a,(hl)  
1366				; if byte is zero then clear to use 
1366			 
1366				cp 0 
1366				jr z, .foundemptyblock 
1366			 
1366				; if byte is not clear 
1366				;     then byte is offset to next block 
1366			 
1366				inc hl 
1366				ld a, (hl) ; get size 
1366			.nextblock:	inc hl 
1366					ld e, (hl) 
1366					inc hl 
1366					ld d, (hl) 
1366					ex de, hl 
1366			;	inc hl  ; move past the store space 
1366			;	inc hl  ; move past zero index  
1366			 
1366				; TODO detect no more space 
1366			 
1366				push hl 
1366				ld de, heap_end 
1366				call cmp16 
1366				pop hl 
1366				jr nc, .nospace 
1366			 
1366				jr .findblock 
1366			 
1366			.nospace: ld hl, 0 
1366				jp .exit 
1366			 
1366			 
1366			.foundemptyblock:	 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mme" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; TODO has block enough space if reusing??? 
1366			 
1366				;  
1366			 
1366			; see if this block has been previously used 
1366				inc hl 
1366				ld a, (hl) 
1366				dec hl 
1366				cp 0 
1366				jr z, .newblock 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meR" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; no reusing previously allocated block 
1366			 
1366			; is it smaller than previously used? 
1366				 
1366				inc hl    ; move to size 
1366				ld a, c 
1366				sub (hl)        ; we want c < (hl) 
1366				dec hl    ; move back to marker 
1366			        jr z, .findblock 
1366			 
1366				; update with the new size which should be lower 
1366			 
1366			        ;inc  hl   ; negate next move. move back to size  
1366			 
1366			.newblock: 
1366				; need to be at marker here 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			 
1366				ld a, c 
1366			 
1366				ld (free_list+3), a	 ; flag resume from last malloc  
1366				ld (free_list), hl    ; save out last location 
1366			 
1366			 
1366				;inc a     ; space for length byte 
1366				ld (hl), a     ; save block in use marker 
1366			 
1366				inc hl   ; move to space marker 
1366				ld (hl), a    ; save new space 
1366			 
1366				inc hl   ; move to start of allocated area 
1366				 
1366			;	push hl     ; save where we are - 1  
1366			 
1366			;	inc hl  ; move past zero index  
1366				; skip space to set down new marker 
1366			 
1366				; provide some extra space for now 
1366			 
1366				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1366				inc a 
1366				inc a 
1366			 
1366				push hl   ; save where we are in the node block 
1366			 
1366				call addatohl 
1366			 
1366				; write linked list point 
1366			 
1366				pop de     ; get our node position 
1366				ex de, hl 
1366			 
1366				ld (hl), e 
1366				inc hl 
1366				ld (hl), d 
1366			 
1366				inc hl 
1366			 
1366				; now at start of allocated data so save pointer 
1366			 
1366				push hl 
1366			 
1366				; jump to position of next node and setup empty header in DE 
1366			 
1366				ex de, hl 
1366			 
1366			;	inc hl ; move past end of block 
1366			 
1366				ld a, 0 
1366				ld (hl), a   ; empty marker 
1366				inc hl 
1366				ld (hl), a   ; size 
1366				inc hl  
1366				ld (hl), a   ; ptr 
1366				inc hl 
1366				ld (hl), a   ; ptr 
1366			 
1366			 
1366				pop hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmr" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			.exit: 
1366				pop af 
1366				pop bc 
1366				pop de  
1366				ret 
1366			 
1366			 
1366			 
1366			 
1366			free:  
1366				push hl 
1366				push af 
1366				; get address in hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "fre" 
1366						CALLMONITOR 
1366					endif 
1366				; data is at hl - move to block count 
1366				dec hl 
1366				dec hl    ; get past pointer 
1366				dec hl 
1366			 
1366				ld a, (hl)    ; need this for a validation check 
1366			 
1366				dec hl    ; move to block marker 
1366			 
1366				; now check that the block count and block marker are the same  
1366			        ; this checks that we are on a malloc node and not random memory 
1366			        ; OK a faint chance this could be a problem but rare - famous last words! 
1366			 
1366				ld c, a 
1366				ld a, (hl)    
1366			 
1366				cp c 
1366				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1366			 
1366				; yes good chance we are on a malloc node 
1366			 
1366				ld a, 0      
1366				ld (hl), a   ; mark as free 
1366			 
1366				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1366			 
1366			.freeignore:  
1366			 
1366				pop af 
1366				pop hl 
1366			 
1366				ret 
1366			 
1366			 
1366			 
1366			endif 
1366			 
1366			; eof 
# End of file firmware_memory.asm
1366			  
1366			; device C  
1366			if SOUND_ENABLE  
1366				include "firmware_sound.asm"  
1366			endif  
1366			  
1366			include "firmware_diags.asm"  
1366			; Hardware diags menu 
1366			 
1366			 
1366			config: 
1366			 
1366 3e 00			ld a, 0 
1368 21 8c 13			ld hl, .configmn 
136b cd 03 0b			call menu 
136e			 
136e fe 00			cp 0 
1370 c8				ret z 
1371			 
1371 fe 01			cp 1 
1373 cc 51 14			call z, .savetostore 
1376			 
1376 fe 02			cp 2 
1378 cc 12 14			call z, .selautoload 
137b fe 03			cp 3 
137d cc 4f 14			call z, .selbank 
1380 fe 05			cp 5 
1382 cc 2c 15			call z, .debug_tog 
1385 fe 06			cp 6 
1387 cc 52 15			call z, hardware_diags 
138a			 
138a 18 da			jr config 
138c			 
138c			.configmn: 
138c 9a 13			dw .c3 
138e b6 13			dw .c2 
1390 cb 13			dw .c2b 
1392 df 13			dw .c4 
1394 e8 13			dw .m4 
1396 03 14			dw .c1 
1398 00 00			dw 0 
139a				 
139a			 
139a .. 00		.c3: db "Add User Dictionary To File",0 
13b6 .. 00		.c2: db "Select Autoload File",0 
13cb .. 00		.c2b: db "Select Storage Bank",0 
13df .. 00		.c4: db "Settings",0 
13e8 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1403 .. 00		.c1: db "Hardware Diags",0 
1412			 
1412			; Select auto start 
1412			 
1412			.selautoload: 
1412			 
1412				 
1412				if STORAGE_SE 
1412			 
1412 cd 76 14				call config_dir 
1415 21 a3 ef			        ld hl, scratch 
1418 3e 00				ld a, 0 
141a cd 03 0b				call menu 
141d			 
141d					; locate menu option 
141d			 
141d 21 a3 ef				ld hl, scratch 
1420 cd 2a 0a				call table_lookup 
1423			 
1423					; with the pointer to the menu it, the byte following the zero term is the file id 
1423			 
1423 3e 00				ld a, 0 
1425 01 32 00				ld bc, 50   ; max of bytes to look at 
1428 ed b1				cpir  
142a			 
142a 23					inc hl 
142b			 
142b 7e					ld a, (hl)   ; file id 
142c					 
142c				        ; save bank and file ids 
142c			 
142c f5					push af 
142d			 
142d			; TODO need to save to block 0 on bank 1	 
142d			 
142d cd ba 03				call storage_get_block_0 
1430			 
1430 f1					pop af 
1431			 
1431 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
1434					 
1434					; save bank id 
1434			 
1434 3a ce f9				ld a,(spi_device) 
1437 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
143a			 
143a					; enable auto run of store file 
143a			 
143a 3e 01				ld a, 1 
143c 32 09 fa				ld (store_page+STORE_0_AUTOFILE),a 
143f			 
143f					; save buffer 
143f			 
143f 21 00 00				ld hl, 0 
1442 11 e8 f9				ld de, store_page 
1445 cd 6e 03			call storage_write_block	 ; save update 
1448			  
1448			 
1448			 
1448			 
1448 21 a3 ef				ld hl, scratch 
144b cd 63 14				call config_fdir 
144e			 
144e			 
144e				endif 
144e c9				ret 
144f			 
144f			 
144f			 
144f			; Select storage bank 
144f			 
144f			.selbank: 
144f			 
144f				if STORAGE_SE 
144f				endif 
144f				 
144f c9				ret 
1450			 
1450			if STORAGE_SE 
1450			 
1450			.config_ldir:   
1450				; Load storage bank labels into menu array 
1450			 
1450				 
1450			 
1450			 
1450 c9				ret 
1451			 
1451			 
1451			endif 
1451			 
1451			 
1451			; Save user words to storage 
1451			 
1451			.savetostore: 
1451			 
1451				if STORAGE_SE 
1451			 
1451 cd 76 14				call config_dir 
1454 21 a3 ef			        ld hl, scratch 
1457 3e 00				ld a, 0 
1459 cd 03 0b				call menu 
145c					 
145c 21 a3 ef				ld hl, scratch 
145f cd 63 14				call config_fdir 
1462			 
1462			 
1462				endif 
1462			 
1462 c9				ret 
1463			 
1463			 
1463			 
1463			if STORAGE_SE 
1463			 
1463			config_fdir: 
1463				; using the scratch dir go through and release the memory allocated for each string 
1463				 
1463 21 a3 ef			ld hl, scratch 
1466 5e			.cfdir:	ld e,(hl) 
1467 23				inc hl 
1468 56				ld d,(hl) 
1469 23				inc hl 
146a			 
146a eb				ex de, hl 
146b cd 2f 0d			call ishlzero 
146e c8				ret z     ; return on null pointer 
146f cd 97 12			call free 
1472 eb				ex de, hl 
1473 18 f1			jr .cfdir 
1475			 
1475			 
1475 c9				ret 
1476			 
1476			 
1476			config_dir: 
1476			 
1476				; for the config menus that need to build a directory of storage call this routine 
1476				; it will construct a menu in scratch to pass to menu 
1476			 
1476				; open storage device 
1476			 
1476				; execute DIR to build a list of files and their ids into scratch in menu format 
1476				; once the menu has finished then will need to call config_fdir to release the strings 
1476				 
1476				; c = number items 
1476			 
1476				 
1476 cd ba 03			call storage_get_block_0 
1479			 
1479 21 e8 f9			ld hl, store_page     ; get current id count 
147c 46				ld b, (hl) 
147d 0e 00			ld c, 0    ; count of files   
147f			 
147f			 
147f 21 a3 ef			ld hl, scratch 
1482 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1485			 
1485				; check for empty drive 
1485			 
1485 3e 00			ld a, 0 
1487 b8				cp b 
1488 ca 22 15			jp z, .dirdone 
148b			 
148b				 
148b					if DEBUG_FORTH_WORDS 
148b						DMARK "Cdc" 
148b f5				push af  
148c 3a a0 14			ld a, (.dmark)  
148f 32 bd fb			ld (debug_mark),a  
1492 3a a1 14			ld a, (.dmark+1)  
1495 32 be fb			ld (debug_mark+1),a  
1498 3a a2 14			ld a, (.dmark+2)  
149b 32 bf fb			ld (debug_mark+2),a  
149e 18 03			jr .pastdmark  
14a0 ..			.dmark: db "Cdc"  
14a3 f1			.pastdmark: pop af  
14a4			endm  
# End of macro DMARK
14a4						CALLMONITOR 
14a4 cd 6a 16			call break_point_state  
14a7				endm  
# End of macro CALLMONITOR
14a7					endif 
14a7			 
14a7			 
14a7			.diritem:	 
14a7 c5				push bc 
14a8				; for each of the current ids do a search for them and if found push to stack 
14a8			 
14a8 21 40 00				ld hl, STORE_BLOCK_PHY 
14ab 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
14ad 58					ld e,b 
14ae			 
14ae cd 2a 06				call storage_findnextid 
14b1			 
14b1			 
14b1					; if found hl will be non zero 
14b1			 
14b1 cd 2f 0d				call ishlzero 
14b4 28 69				jr z, .dirnotfound 
14b6			 
14b6					; increase count 
14b6			 
14b6 c1					pop bc	 
14b7 0c					inc c 
14b8 c5					push bc 
14b9					 
14b9			 
14b9					; get file header and push the file name 
14b9			 
14b9 11 e8 f9				ld de, store_page 
14bc cd 09 03				call storage_read_block 
14bf			 
14bf					; push file id to stack 
14bf				 
14bf 3a e8 f9				ld a, (store_page) 
14c2 26 00				ld h, 0 
14c4 6f					ld l, a 
14c5			 
14c5					;call forth_push_numhl 
14c5					; TODO store id 
14c5			 
14c5 e5					push hl 
14c6			 
14c6					; push extent count to stack  
14c6				 
14c6 21 eb f9				ld hl, store_page+3 
14c9			 
14c9					; get file name length 
14c9			 
14c9 cd 64 11				call strlenz   
14cc			 
14cc 23					inc hl   ; cover zero term 
14cd 23					inc hl  ; stick the id at the end of the area 
14ce			 
14ce e5					push hl 
14cf c1					pop bc    ; move length to bc 
14d0			 
14d0 cd cd 11				call malloc 
14d3			 
14d3					; TODO save malloc area to scratch 
14d3			 
14d3 eb					ex de, hl 
14d4 2a e4 f9				ld hl, (store_tmp2) 
14d7 73					ld (hl), e 
14d8 23					inc hl 
14d9 72					ld (hl), d 
14da 23					inc hl 
14db 22 e4 f9				ld (store_tmp2), hl 
14de			 
14de					 
14de			 
14de					;pop hl   ; get source 
14de			;		ex de, hl    ; swap aronund	 
14de			 
14de 21 eb f9				ld hl, store_page+3 
14e1					if DEBUG_FORTH_WORDS 
14e1						DMARK "CFd" 
14e1 f5				push af  
14e2 3a f6 14			ld a, (.dmark)  
14e5 32 bd fb			ld (debug_mark),a  
14e8 3a f7 14			ld a, (.dmark+1)  
14eb 32 be fb			ld (debug_mark+1),a  
14ee 3a f8 14			ld a, (.dmark+2)  
14f1 32 bf fb			ld (debug_mark+2),a  
14f4 18 03			jr .pastdmark  
14f6 ..			.dmark: db "CFd"  
14f9 f1			.pastdmark: pop af  
14fa			endm  
# End of macro DMARK
14fa						CALLMONITOR 
14fa cd 6a 16			call break_point_state  
14fd				endm  
# End of macro CALLMONITOR
14fd					endif 
14fd ed b0				ldir 
14ff			 
14ff					; de is past string, move back one and store id 
14ff					 
14ff 1b					dec de 
1500			 
1500					; store file id 
1500			 
1500 e1					pop hl 
1501 eb					ex de,hl 
1502 73					ld (hl), e 
1503			 
1503					if DEBUG_FORTH_WORDS 
1503						DMARK "Cdi" 
1503 f5				push af  
1504 3a 18 15			ld a, (.dmark)  
1507 32 bd fb			ld (debug_mark),a  
150a 3a 19 15			ld a, (.dmark+1)  
150d 32 be fb			ld (debug_mark+1),a  
1510 3a 1a 15			ld a, (.dmark+2)  
1513 32 bf fb			ld (debug_mark+2),a  
1516 18 03			jr .pastdmark  
1518 ..			.dmark: db "Cdi"  
151b f1			.pastdmark: pop af  
151c			endm  
# End of macro DMARK
151c						CALLMONITOR 
151c cd 6a 16			call break_point_state  
151f				endm  
# End of macro CALLMONITOR
151f					endif 
151f					 
151f			.dirnotfound: 
151f c1					pop bc     
1520 10 85				djnz .diritem 
1522				 
1522			.dirdone:	 
1522			 
1522 3e 00				ld a, 0 
1524 2a e4 f9				ld hl, (store_tmp2) 
1527 77					ld (hl), a 
1528 23					inc hl 
1529 77					ld (hl), a 
152a 23					inc hl 
152b					; push a count of the dir items found 
152b			 
152b			;		ld h, 0 
152b			;		ld l, c 
152b			 
152b c9				ret 
152c			 
152c			endif 
152c			 
152c			 
152c			; Settings 
152c			; Run  
152c			 
152c			 
152c			 
152c			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
152c			;;hd_menu2:   db "        2: Editor",0   
152c			;hd_menu2:   db "        2: Editor       6: Menu",0   
152c			;hd_menu3:   db "        3: Storage",0 
152c			;hd_menu4:   db "0=quit  4: Debug",0 
152c			;hd_don:     db "ON",0 
152c			;hd_doff:     db "OFF",0 
152c			; 
152c			; 
152c			; 
152c			;hardware_diags_old:       
152c			; 
152c			;.diagmenu: 
152c			;	call clear_display 
152c			;	ld a, display_row_1 
152c			;	ld de, hd_menu1 
152c			;	call str_at_display 
152c			; 
152c			;	ld a, display_row_2 
152c			;	ld de, hd_menu2 
152c			;	call str_at_display 
152c			; 
152c			;	ld a, display_row_3 
152c			;	ld de, hd_menu3 
152c			;	call str_at_display 
152c			; 
152c			;	ld a,  display_row_4 
152c			;	ld de, hd_menu4 
152c			;	call str_at_display 
152c			; 
152c			;	; display debug state 
152c			; 
152c			;	ld de, hd_don 
152c			;	ld a, (os_view_disable) 
152c			;	cp 0 
152c			;	jr z, .distog 
152c			;	ld de, hd_doff 
152c			;.distog: ld a, display_row_4+17 
152c			;	call str_at_display 
152c			; 
152c			;	call update_display 
152c			; 
152c			;	call cin_wait 
152c			; 
152c			; 
152c			; 
152c			;	cp '4' 
152c			;	jr nz, .diagn1 
152c			; 
152c			;	; debug toggle 
152c			; 
152c			;	ld a, (os_view_disable) 
152c			;	ld b, '*' 
152c			;	cp 0 
152c			;	jr z, .debtog 
152c			;	ld b, 0 
152c			;.debtog:	 
152c			;	ld a,b 
152c			;	ld (os_view_disable),a 
152c			; 
152c			;.diagn1: cp '0' 
152c			;	 ret z 
152c			; 
152c			;;	cp '1' 
152c			;;       jp z, matrix	 
152c			;;   TODO keyboard matrix test 
152c			; 
152c			;	cp '2' 
152c			;	jp z, .diagedit 
152c			; 
152c			;;	cp '6' 
152c			;;	jp z, .menutest 
152c			;;if ENABLE_BASIC 
152c			;;	cp '6' 
152c			;;	jp z, basic 
152c			;;endif 
152c			 ; 
152c			;	jp .diagmenu 
152c			; 
152c			; 
152c			;	ret 
152c			 
152c			 
152c			.debug_tog: 
152c 21 73 15			ld hl, .menudebug 
152f				 
152f 3a 94 ef			ld a, (os_view_disable) 
1532 fe 2a			cp '*' 
1534 20 04			jr nz,.tdon  
1536 3e 01			ld a, 1 
1538 18 02			jr .tog1 
153a 3e 00		.tdon: ld a, 0 
153c			 
153c			.tog1: 
153c cd 03 0b			call menu 
153f fe 00			cp 0 
1541 c8				ret z 
1542 fe 01			cp 1    ; disable debug 
1544 28 04			jr z, .dtog0 
1546 3e 2a			ld a, '*' 
1548 18 02			jr .dtogset 
154a 3e 00		.dtog0: ld a, 0 
154c 32 94 ef		.dtogset:  ld (os_view_disable), a 
154f c3 2c 15			jp .debug_tog 
1552			 
1552			 
1552			hardware_diags:       
1552			 
1552			.diagm: 
1552 21 65 15			ld hl, .menuitems 
1555 3e 00			ld a, 0 
1557 cd 03 0b			call menu 
155a			 
155a fe 00		         cp 0 
155c c8				 ret z 
155d			 
155d fe 02			cp 2 
155f ca be 15			jp z, .diagedit 
1562			 
1562			;	cp '6' 
1562			;	jp z, .menutest 
1562			;if ENABLE_BASIC 
1562			;	cp '6' 
1562			;	jp z, basic 
1562			;endif 
1562			  
1562 c3 52 15			jp .diagm 
1565			 
1565				 
1565 79 15		.menuitems:   	dw .m1 
1567 84 15				dw .m2 
1569 8b 15				dw .m3 
156b 93 15				dw .m5 
156d 99 15				dw .m5a 
156f a2 15				dw .m5b 
1571 00 00				dw 0 
1573			 
1573			.menudebug: 
1573 ab 15				dw .m6 
1575 b4 15				dw .m7 
1577 00 00				dw 0 
1579			 
1579 .. 00		.m1:   db "Key Matrix",0 
1584 .. 00		.m2:   db "Editor",0 
158b .. 00		.m3:   db "Storage",0 
1593 .. 00		.m5:   db "Sound",0 
1599 .. 00		.m5a:  db "RAM Test",0 
15a2 .. 00		.m5b:  db "LCD Test",0 
15ab			 
15ab .. 00		.m6:   db "Debug ON",0 
15b4 .. 00		.m7:   db "Debug OFF",0 
15be			 
15be			; debug editor 
15be			 
15be			.diagedit: 
15be			 
15be 21 a3 ef			ld hl, scratch 
15c1			;	ld bc, 250 
15c1			;	ldir 
15c1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
15c1 3e 00			ld a, 0 
15c3 77				ld (hl), a 
15c4 23				inc hl 
15c5 77				ld (hl), a 
15c6 23				inc hl 
15c7 77				ld (hl), a 
15c8			 
15c8 cd d2 0a		        call clear_display 
15cb cd f5 0a			call update_display 
15ce 3e 01			ld a, 1 
15d0 32 c3 fb			ld (hardware_diag), a 
15d3			.diloop: 
15d3 3e 00			ld a, display_row_1 
15d5 0e 00			ld c, 0 
15d7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
15d9 1e 28			ld e, 40 
15db			 
15db 21 a3 ef			ld hl, scratch	 
15de cd 33 0d			call input_str 
15e1			 
15e1 3e 14			ld a, display_row_2 
15e3 11 a3 ef			ld de, scratch 
15e6 cd e5 0a			call str_at_display 
15e9 cd f5 0a			call update_display 
15ec			 
15ec c3 d3 15			jp .diloop 
15ef			 
15ef			 
15ef			; pass word in hl 
15ef			; a has display location 
15ef			display_word_at: 
15ef f5				push af 
15f0 e5				push hl 
15f1 7c				ld a,h 
15f2 21 a8 f2			ld hl, os_word_scratch 
15f5 cd 07 10			call hexout 
15f8 e1				pop hl 
15f9 7d				ld a,l 
15fa 21 aa f2			ld hl, os_word_scratch+2 
15fd cd 07 10			call hexout 
1600 21 ac f2			ld hl, os_word_scratch+4 
1603 3e 00			ld a,0 
1605 77				ld (hl),a 
1606 11 a8 f2			ld de,os_word_scratch 
1609 f1				pop af 
160a cd e5 0a				call str_at_display 
160d c9				ret 
160e			 
160e			display_ptr_state: 
160e			 
160e				; to restore afterwards 
160e			 
160e d5				push de 
160f c5				push bc 
1610 e5				push hl 
1611 f5				push af 
1612			 
1612				; for use in here 
1612			 
1612			;	push bc 
1612			;	push de 
1612			;	push hl 
1612			;	push af 
1612			 
1612 cd d2 0a			call clear_display 
1615			 
1615 11 e8 17			ld de, .ptrstate 
1618 3e 00			ld a, display_row_1 
161a cd e5 0a			call str_at_display 
161d			 
161d				; display debug step 
161d			 
161d			 
161d 11 bd fb			ld de, debug_mark 
1620 3e 12			ld a, display_row_1+display_cols-2 
1622 cd e5 0a			call str_at_display 
1625			 
1625				; display a 
1625 11 f2 17			ld de, .ptrcliptr 
1628 3e 14			ld a, display_row_2 
162a cd e5 0a			call str_at_display 
162d			 
162d f1				pop af 
162e 2a ae f9			ld hl,(cli_ptr) 
1631 3e 1c			ld a, display_row_2+8 
1633 cd ef 15			call display_word_at 
1636			 
1636			 
1636				; display hl 
1636			 
1636			 
1636 11 fa 17			ld de, .ptrclioptr 
1639 3e 1e			ld a, display_row_2+10 
163b cd e5 0a			call str_at_display 
163e			; 
163e			;	pop hl 
163e 3e 21			ld a, display_row_2+13 
1640 2a ac f9			ld hl,(cli_origptr) 
1643 cd ef 15			call display_word_at 
1646			; 
1646			;	 
1646			;	; display de 
1646			 
1646			;	ld de, .regstatede 
1646			;	ld a, display_row_3 
1646			;	call str_at_display 
1646			 
1646			;	pop de 
1646			;	ld h,d 
1646			;	ld l, e 
1646			;	ld a, display_row_3+3 
1646			;	call display_word_at 
1646			 
1646			 
1646				; display bc 
1646			 
1646			;	ld de, .regstatebc 
1646			;	ld a, display_row_3+10 
1646			;	call str_at_display 
1646			 
1646			;	pop bc 
1646			;	ld h,b 
1646			;	ld l, c 
1646			;	ld a, display_row_3+13 
1646			;	call display_word_at 
1646			 
1646			 
1646				; display dsp 
1646			 
1646			;	ld de, .regstatedsp 
1646			;	ld a, display_row_4 
1646			;	call str_at_display 
1646			 
1646				 
1646			;	ld hl,(cli_data_sp) 
1646			;	ld a, display_row_4+4 
1646			;	call display_word_at 
1646			 
1646				; display rsp 
1646			 
1646 11 29 18			ld de, .regstatersp 
1649 3e 46			ld a, display_row_4+10 
164b cd e5 0a			call str_at_display 
164e			 
164e				 
164e 2a 94 f9			ld hl,(cli_ret_sp) 
1651 3e 4a			ld a, display_row_4+14 
1653 cd ef 15			call display_word_at 
1656			 
1656 cd f5 0a			call update_display 
1659			 
1659 cd 52 0a			call delay1s 
165c cd 52 0a			call delay1s 
165f cd 52 0a			call delay1s 
1662			 
1662			 
1662 cd 72 1b			call next_page_prompt 
1665			 
1665				; restore  
1665			 
1665 f1				pop af 
1666 e1				pop hl 
1667 c1				pop bc 
1668 d1				pop de 
1669 c9				ret 
166a			 
166a			break_point_state: 
166a f5				push af 
166b			 
166b				; see if disabled 
166b			 
166b 3a 94 ef			ld a, (os_view_disable) 
166e fe 2a			cp '*' 
1670 20 02			jr nz, .bpsgo 
1672 f1				pop af 
1673 c9				ret 
1674			 
1674			.bpsgo: 
1674 f1				pop af 
1675 f5				push af 
1676 22 90 ef			ld (os_view_hl), hl 
1679 ed 53 8e ef		ld (os_view_de), de 
167d ed 43 8c ef		ld (os_view_bc), bc 
1681 e5				push hl 
1682 6f				ld l, a 
1683 26 00			ld h, 0 
1685 22 92 ef			ld (os_view_af),hl 
1688			 
1688 21 53 fb				ld hl, display_fb0 
168b 22 5e fa				ld (display_fb_active), hl 
168e e1				pop hl	 
168f			 
168f 3e 31			ld a, '1' 
1691 fe 2a		.bps1:  cp '*' 
1693 20 03			jr nz, .bps1b 
1695 32 94 ef			ld (os_view_disable),a 
1698 fe 31		.bps1b:  cp '1' 
169a 20 14			jr nz, .bps2 
169c			 
169c				; display reg 
169c			 
169c				 
169c			 
169c 3a 92 ef			ld a, (os_view_af) 
169f 2a 90 ef			ld hl, (os_view_hl) 
16a2 ed 5b 8e ef		ld de, (os_view_de) 
16a6 ed 4b 8c ef		ld bc, (os_view_bc) 
16aa cd 44 17			call display_reg_state 
16ad c3 30 17			jp .bpschk 
16b0			 
16b0 fe 32		.bps2:  cp '2' 
16b2 20 08			jr nz, .bps3 
16b4				 
16b4				; display hl 
16b4 2a 90 ef			ld hl, (os_view_hl) 
16b7 cd 2e 18			call display_dump_at_hl 
16ba			 
16ba 18 74			jr .bpschk 
16bc			 
16bc fe 33		.bps3:  cp '3' 
16be 20 08			jr nz, .bps4 
16c0			 
16c0			        ; display de 
16c0 2a 8e ef			ld hl, (os_view_de) 
16c3 cd 2e 18			call display_dump_at_hl 
16c6			 
16c6 18 68			jr .bpschk 
16c8 fe 34		.bps4:  cp '4' 
16ca 20 08			jr nz, .bps5 
16cc			 
16cc			        ; display bc 
16cc 2a 8c ef			ld hl, (os_view_bc) 
16cf cd 2e 18			call display_dump_at_hl 
16d2			 
16d2 18 5c			jr .bpschk 
16d4 fe 35		.bps5:  cp '5' 
16d6 20 08		        jr nz, .bps7 
16d8			 
16d8				; display cur ptr 
16d8 2a ae f9			ld hl, (cli_ptr) 
16db cd 2e 18			call display_dump_at_hl 
16de			 
16de 18 50			jr .bpschk 
16e0 fe 36		.bps7:  cp '6' 
16e2 20 08			jr nz, .bps8b 
16e4				 
16e4				; display cur orig ptr 
16e4 2a ac f9			ld hl, (cli_origptr) 
16e7 cd 2e 18			call display_dump_at_hl 
16ea 18 44			jr .bpschk 
16ec fe 37		.bps8b:  cp '7' 
16ee 20 08			jr nz, .bps9 
16f0				 
16f0				; display dsp 
16f0 2a 90 f9			ld hl, (cli_data_sp) 
16f3 cd 2e 18			call display_dump_at_hl 
16f6			 
16f6 18 38			jr .bpschk 
16f8 fe 39		.bps9:  cp '9' 
16fa 20 05			jr nz, .bps8c 
16fc				 
16fc				; display SP 
16fc			;	ld hl, sp 
16fc cd 2e 18			call display_dump_at_hl 
16ff			 
16ff 18 2f			jr .bpschk 
1701 fe 38		.bps8c:  cp '8' 
1703 20 08			jr nz, .bps8d 
1705				 
1705				; display rsp 
1705 2a 94 f9			ld hl, (cli_ret_sp) 
1708 cd 2e 18			call display_dump_at_hl 
170b			 
170b 18 23			jr .bpschk 
170d fe 23		.bps8d:  cp '#'     ; access monitor sub system 
170f 20 05			jr nz, .bps8 
1711 cd 68 19			call monitor 
1714			 
1714 18 1a			jr .bpschk 
1716 fe 30		.bps8:  cp '0' 
1718 20 16			jr nz, .bpschk 
171a			 
171a 21 02 fb				ld hl, display_fb1 
171d 22 5e fa				ld (display_fb_active), hl 
1720 cd f5 0a				call update_display 
1723			 
1723				;ld a, (os_view_af) 
1723 2a 90 ef			ld hl, (os_view_hl) 
1726 ed 5b 8e ef		ld de, (os_view_de) 
172a ed 4b 8c ef		ld bc, (os_view_bc) 
172e f1				pop af 
172f c9				ret 
1730			 
1730			.bpschk:   
1730 cd 52 0a			call delay1s 
1733 3e 4f		ld a,display_row_4 + display_cols - 1 
1735 11 70 1b		        ld de, endprg 
1738 cd e5 0a			call str_at_display 
173b cd f5 0a			call update_display 
173e cd a6 66			call cin_wait 
1741			 
1741 c3 91 16			jp .bps1 
1744			 
1744			 
1744			display_reg_state: 
1744			 
1744				; to restore afterwards 
1744			 
1744 d5				push de 
1745 c5				push bc 
1746 e5				push hl 
1747 f5				push af 
1748			 
1748				; for use in here 
1748			 
1748 c5				push bc 
1749 d5				push de 
174a e5				push hl 
174b f5				push af 
174c			 
174c cd d2 0a			call clear_display 
174f			 
174f 11 04 18			ld de, .regstate 
1752 3e 00			ld a, display_row_1 
1754 cd e5 0a			call str_at_display 
1757			 
1757				; display debug step 
1757			 
1757			 
1757 11 bd fb			ld de, debug_mark 
175a 3e 11			ld a, display_row_1+display_cols-3 
175c cd e5 0a			call str_at_display 
175f			 
175f				; display a 
175f 11 20 18			ld de, .regstatea 
1762 3e 14			ld a, display_row_2 
1764 cd e5 0a			call str_at_display 
1767			 
1767 e1				pop hl 
1768			;	ld h,0 
1768			;	ld l, a 
1768 3e 17			ld a, display_row_2+3 
176a cd ef 15			call display_word_at 
176d			 
176d			 
176d				; display hl 
176d			 
176d			 
176d 11 14 18			ld de, .regstatehl 
1770 3e 1e			ld a, display_row_2+10 
1772 cd e5 0a			call str_at_display 
1775			 
1775 e1				pop hl 
1776 3e 21			ld a, display_row_2+13 
1778 cd ef 15			call display_word_at 
177b			 
177b				 
177b				; display de 
177b			 
177b 11 18 18			ld de, .regstatede 
177e 3e 28			ld a, display_row_3 
1780 cd e5 0a			call str_at_display 
1783			 
1783 e1				pop hl 
1784			;	ld h,d 
1784			;	ld l, e 
1784 3e 2b			ld a, display_row_3+3 
1786 cd ef 15			call display_word_at 
1789			 
1789			 
1789				; display bc 
1789			 
1789 11 1c 18			ld de, .regstatebc 
178c 3e 32			ld a, display_row_3+10 
178e cd e5 0a			call str_at_display 
1791			 
1791 e1				pop hl 
1792			;	ld h,b 
1792			;	ld l, c 
1792 3e 35			ld a, display_row_3+13 
1794 cd ef 15			call display_word_at 
1797			 
1797			 
1797				; display dsp 
1797			 
1797 11 24 18			ld de, .regstatedsp 
179a 3e 3c			ld a, display_row_4 
179c cd e5 0a			call str_at_display 
179f			 
179f				 
179f 2a 90 f9			ld hl,(cli_data_sp) 
17a2 3e 40			ld a, display_row_4+4 
17a4 cd ef 15			call display_word_at 
17a7			 
17a7				; display rsp 
17a7			 
17a7 11 29 18			ld de, .regstatersp 
17aa 3e 46			ld a, display_row_4+10 
17ac cd e5 0a			call str_at_display 
17af			 
17af				 
17af 2a 94 f9			ld hl,(cli_ret_sp) 
17b2 3e 4a			ld a, display_row_4+14 
17b4 cd ef 15			call display_word_at 
17b7			 
17b7 cd f5 0a			call update_display 
17ba			 
17ba			;	call delay1s 
17ba			;	call delay1s 
17ba			;	call delay1s 
17ba			 
17ba			 
17ba			;	call next_page_prompt 
17ba			 
17ba				; restore  
17ba			 
17ba f1				pop af 
17bb e1				pop hl 
17bc c1				pop bc 
17bd d1				pop de 
17be c9				ret 
17bf			 
17bf .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
17d3 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
17e8 .. 00		.ptrstate:	db "Ptr State",0 
17f2 .. 00		.ptrcliptr:     db "cli_ptr",0 
17fa .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1804 .. 00		.regstate:	db "Reg State (1/0)",0 
1814 .. 00		.regstatehl:	db "HL:",0 
1818 .. 00		.regstatede:	db "DE:",0 
181c .. 00		.regstatebc:	db "BC:",0 
1820 .. 00		.regstatea:	db "A :",0 
1824 .. 00		.regstatedsp:	db "DSP:",0 
1829 .. 00		.regstatersp:	db "RSP:",0 
182e			 
182e			display_dump_at_hl: 
182e e5				push hl 
182f d5				push de 
1830 c5				push bc 
1831 f5				push af 
1832			 
1832 22 c6 f2			ld (os_cur_ptr),hl	 
1835 cd d2 0a			call clear_display 
1838 cd 7a 1a			call dumpcont 
183b			;	call delay1s 
183b			;	call next_page_prompt 
183b			 
183b			 
183b f1				pop af 
183c c1				pop bc 
183d d1				pop de 
183e e1				pop hl 
183f c9				ret 
1840			 
1840			;if ENABLE_BASIC 
1840			;	include "nascombasic.asm" 
1840			;	basic: 
1840			;	include "forth/FORTH.ASM" 
1840			;endif 
1840			 
1840			; eof 
1840			 
1840			 
# End of file firmware_diags.asm
1840			  
1840			  
1840			  
1840			  
1840			; eof  
1840			  
# End of file firmware.asm
1840			 
1840			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1840			;if BASE_KEV  
1840			;baseram: equ 08000h 
1840			;endif 
1840			 
1840			;if BASE_SC114 
1840			;baseram:     equ    endofcode 
1840			;endif 
1840			 
1840			 
1840			; start system 
1840			 
1840			coldstart: 
1840				; set sp 
1840				; di/ei 
1840			 
1840 f3				di 
1841 31 fd ff			ld sp, tos 
1844			;	ei 
1844			 
1844			 
1844				; disable breakpoint by default 
1844			 
1844 3e 2a			ld a,'*' 
1846 32 94 ef			ld (os_view_disable),a 
1849			 
1849				; init hardware 
1849			 
1849				; init keyboard and screen hardware 
1849			 
1849 cd 03 00			call hardware_init 
184c			 
184c			 
184c				; detect if any keys are held down to enable breakpoints at start up 
184c			 
184c cd b7 66			call cin  
184f fe 00			cp 0 
1851 28 03			jr z, .nokeys 
1853			 
1853				;call hardware_diags 
1853 cd 66 13			call config 
1856			 
1856			;	ld de, .bpen 
1856			;	ld a, display_row_4 
1856			;	call str_at_display 
1856			;	call update_display 
1856			; 
1856			;	ld a,0 
1856			;	ld (os_view_disable),a 
1856			; 
1856			;.bpwait: 
1856			;	call cin 
1856			;	cp 0 
1856			;	jr z, .bpwait 
1856			;	jr .nokeys 
1856			; 
1856			; 
1856			;.bpen:  db "Break points enabled!",0 
1856			 
1856			 
1856			 
1856			 
1856			 
1856			 
1856			.nokeys: 
1856			 
1856			 
1856				 
1856			 
1856			;jp  testkey 
1856			 
1856			;call storage_get_block_0 
1856			; 
1856			;ld hl, 0 
1856			;ld de, store_page 
1856			;call storage_read_block 
1856			 
1856				 
1856			;ld hl, 10 
1856			;ld de, store_page 
1856			;call storage_read_block 
1856			 
1856			 
1856			 
1856			 
1856			 
1856			;stop:	nop 
1856			;	jp stop 
1856			 
1856			 
1856			 
1856			main: 
1856 cd d2 0a			call clear_display 
1859 cd f5 0a			call update_display 
185c			 
185c			 
185c			 
185c			;	call testlcd 
185c			 
185c			 
185c			 
185c cd 38 1f			call forth_init 
185f			 
185f			 
185f			warmstart: 
185f cd 0e 1f			call forth_warmstart 
1862			 
1862				; run startup word load 
1862			        ; TODO prevent this running at warmstart after crash  
1862			 
1862				if STARTUP_ENABLE 
1862 cd c6 61				call forth_startup 
1865			 
1865					if STORAGE_SE 
1865 cd a5 64					call forth_autoload 
1868					endif 
1868			 
1868				endif 
1868			 
1868				; show free memory after boot 
1868 11 02 19			ld de, freeram 
186b 3e 00			ld a, display_row_1 
186d cd e5 0a			call str_at_display 
1870			 
1870			; Or use heap_size word???? 
1870 21 89 ef			ld hl, heap_end 
1873 11 0e 80			ld de, heap_start 
1876 ed 52			sbc hl, de 
1878 e5				push hl 
1879 7c				ld a,h	         	 
187a 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
187d cd 07 10			call hexout 
1880 e1			   	pop hl 
1881			 
1881 7d				ld a,l 
1882 21 aa f2			ld hl, os_word_scratch+2 
1885 cd 07 10			call hexout 
1888 21 ac f2			ld hl, os_word_scratch+4 
188b 3e 00			ld a, 0 
188d 77				ld (hl),a 
188e 11 a8 f2			ld de, os_word_scratch 
1891 3e 0d			ld a, display_row_1 + 13 
1893 cd e5 0a			call str_at_display 
1896 cd f5 0a			call update_display 
1899			 
1899			 
1899				;call demo 
1899			 
1899			 
1899				; init scratch input area for cli commands 
1899			 
1899 21 ca f2			ld hl, os_cli_cmd 
189c 3e 00			ld a,0 
189e 77				ld (hl),a 
189f 23				inc hl 
18a0 77				ld (hl),a 
18a1			 
18a1 3e 00			ld a,0 
18a3 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18a6			 
18a6 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18a9 32 c7 f2			ld (os_cur_ptr+1),a	 
18ac			 
18ac 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18af 32 a9 f2			ld (os_word_scratch+1),a	 
18b2				 
18b2			 
18b2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18b2 21 ca f2			ld hl, os_cli_cmd 
18b5			 
18b5 3e 00			ld a, 0		 ; init cli input 
18b7 77				ld (hl), a 
18b8 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18ba			cli: 
18ba				; show cli prompt 
18ba				;push af 
18ba				;ld a, 0 
18ba				;ld de, prompt 
18ba				;call str_at_display 
18ba			 
18ba				;call update_display 
18ba				;pop af 
18ba				;inc a 
18ba				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18ba 0e 00			ld c, 0 
18bc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18be 1e 28			ld e, 40 
18c0			 
18c0 21 ca f2			ld hl, os_cli_cmd 
18c3			 
18c3				STACKFRAME OFF $fefe $9f9f 
18c3				if DEBUG_STACK_IMB 
18c3					if OFF 
18c3						exx 
18c3						ld de, $fefe 
18c3						ld a, d 
18c3						ld hl, curframe 
18c3						call hexout 
18c3						ld a, e 
18c3						ld hl, curframe+2 
18c3						call hexout 
18c3						ld hl, $fefe 
18c3						push hl 
18c3						ld hl, $9f9f 
18c3						push hl 
18c3						exx 
18c3					endif 
18c3				endif 
18c3			endm 
# End of macro STACKFRAME
18c3			 
18c3 cd 33 0d			call input_str 
18c6			 
18c6				STACKFRAMECHK OFF $fefe $9f9f 
18c6				if DEBUG_STACK_IMB 
18c6					if OFF 
18c6						exx 
18c6						ld hl, $9f9f 
18c6						pop de   ; $9f9f 
18c6						call cmp16 
18c6						jr nz, .spnosame 
18c6						ld hl, $fefe 
18c6						pop de   ; $fefe 
18c6						call cmp16 
18c6						jr z, .spfrsame 
18c6						.spnosame: call showsperror 
18c6						.spfrsame: nop 
18c6						exx 
18c6					endif 
18c6				endif 
18c6			endm 
# End of macro STACKFRAMECHK
18c6			 
18c6				; copy input to last command 
18c6			 
18c6 21 ca f2			ld hl, os_cli_cmd 
18c9 11 c9 f3			ld de, os_last_cmd 
18cc 01 ff 00			ld bc, 255 
18cf ed b0			ldir 
18d1			 
18d1				; wipe current buffer 
18d1			 
18d1			;	ld a, 0 
18d1			;	ld hl, os_cli_cmd 
18d1			;	ld de, os_cli_cmd+1 
18d1			;	ld bc, 254 
18d1			;	ldir 
18d1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18d1			;	call strcpy 
18d1			;	ld a, 0 
18d1			;	ld (hl), a 
18d1			;	inc hl 
18d1			;	ld (hl), a 
18d1			;	inc hl 
18d1			;	ld (hl), a 
18d1			 
18d1				; switch frame buffer to program  
18d1			 
18d1 21 02 fb				ld hl, display_fb1 
18d4 22 5e fa				ld (display_fb_active), hl 
18d7			 
18d7			;	nop 
18d7				STACKFRAME ON $fbfe $8f9f 
18d7				if DEBUG_STACK_IMB 
18d7					if ON 
18d7						exx 
18d7						ld de, $fbfe 
18d7						ld a, d 
18d7						ld hl, curframe 
18d7						call hexout 
18d7						ld a, e 
18d7						ld hl, curframe+2 
18d7						call hexout 
18d7						ld hl, $fbfe 
18d7						push hl 
18d7						ld hl, $8f9f 
18d7						push hl 
18d7						exx 
18d7					endif 
18d7				endif 
18d7			endm 
# End of macro STACKFRAME
18d7				; first time into the parser so pass over the current scratch pad 
18d7 21 ca f2			ld hl,os_cli_cmd 
18da				; tokenise the entered statement(s) in HL 
18da cd b1 1f			call forthparse 
18dd			        ; exec forth statements in top of return stack 
18dd cd f1 1f			call forthexec 
18e0				;call forthexec_cleanup 
18e0			;	call parsenext 
18e0			 
18e0				STACKFRAMECHK ON $fbfe $8f9f 
18e0				if DEBUG_STACK_IMB 
18e0					if ON 
18e0						exx 
18e0						ld hl, $8f9f 
18e0						pop de   ; $8f9f 
18e0						call cmp16 
18e0						jr nz, .spnosame 
18e0						ld hl, $fbfe 
18e0						pop de   ; $fbfe 
18e0						call cmp16 
18e0						jr z, .spfrsame 
18e0						.spnosame: call showsperror 
18e0						.spfrsame: nop 
18e0						exx 
18e0					endif 
18e0				endif 
18e0			endm 
# End of macro STACKFRAMECHK
18e0				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
18e0			 
18e0 3e 3c			ld a, display_row_4 
18e2 11 14 19			ld de, endprog 
18e5			 
18e5 cd f5 0a			call update_display		 
18e8			 
18e8 cd 72 1b			call next_page_prompt 
18eb			 
18eb				; switch frame buffer to cli 
18eb			 
18eb 21 53 fb				ld hl, display_fb0 
18ee 22 5e fa				ld (display_fb_active), hl 
18f1			 
18f1			 
18f1 cd d2 0a		        call clear_display 
18f4 cd f5 0a			call update_display		 
18f7			 
18f7 21 ca f2			ld hl, os_cli_cmd 
18fa			 
18fa 3e 00			ld a, 0		 ; init cli input 
18fc 77				ld (hl), a 
18fd			 
18fd				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
18fd			 
18fd				; now on last line 
18fd			 
18fd				; TODO scroll screen up 
18fd			 
18fd				; TODO instead just clear screen and place at top of screen 
18fd			 
18fd			;	ld a, 0 
18fd			;	ld (f_cursor_ptr),a 
18fd			 
18fd				;call clear_display 
18fd				;call update_display 
18fd			 
18fd				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18fd 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18ff c3 ba 18			jp cli 
1902			 
1902 .. 00		freeram: db "Free bytes: $",0 
1910 ..			asc: db "1A2F" 
1914 .. 00		endprog: db "End prog...",0 
1920			 
1920			testenter2:   
1920 21 d5 ef			ld hl,scratch+50 
1923 22 c6 f2			ld (os_cur_ptr),hl 
1926 c3 ba 18			jp cli 
1929			 
1929			testenter:  
1929			 
1929 21 10 19			ld hl,asc 
192c			;	ld a,(hl) 
192c			;	call nibble2val 
192c cd 5d 10			call get_byte 
192f			 
192f			 
192f			;	ld a,(hl) 
192f			;	call atohex 
192f			 
192f			;	call fourehexhl 
192f 32 d5 ef			ld (scratch+50),a 
1932			 
1932			 
1932			 
1932 21 12 19			ld hl,asc+2 
1935			;	ld a, (hl) 
1935			;	call nibble2val 
1935 cd 5d 10			call get_byte 
1938			 
1938			;	call fourehexhl 
1938 32 d7 ef			ld (scratch+52),a 
193b				 
193b 21 d5 ef			ld hl,scratch+50 
193e 22 c6 f2			ld (os_cur_ptr),hl 
1941 c3 ba 18			jp cli 
1944			 
1944			enter:	 
1944 3a a7 ef			ld a,(scratch+4) 
1947 fe 00			cp 0 
1949 28 0c			jr z, .entercont 
194b				; no, not a null term line so has an address to work out.... 
194b			 
194b 21 a5 ef			ld hl,scratch+2 
194e cd bd 10			call get_word_hl 
1951			 
1951 22 c6 f2			ld (os_cur_ptr),hl	 
1954 c3 ba 18			jp cli 
1957			 
1957			 
1957			.entercont:  
1957			 
1957 21 a5 ef			ld hl, scratch+2 
195a cd 5d 10			call get_byte 
195d			 
195d 2a c6 f2		   	ld hl,(os_cur_ptr) 
1960 77					ld (hl),a 
1961 23					inc hl 
1962 22 c6 f2				ld (os_cur_ptr),hl 
1965				 
1965			; get byte  
1965			 
1965			 
1965 c3 ba 18			jp cli 
1968			 
1968			 
1968			; basic monitor support 
1968			 
1968			monitor: 
1968				;  
1968 cd d2 0a			call clear_display 
196b 3e 00			ld a, 0 
196d 11 b5 19			ld de, .monprompt 
1970 cd e5 0a			call str_at_display 
1973 cd f5 0a			call update_display 
1976			 
1976				; get a monitor command 
1976			 
1976 0e 00			ld c, 0     ; entry at top left 
1978 16 64			ld d, 100   ; max buffer size 
197a 1e 0f			ld e, 15    ; input scroll area 
197c 3e 00			ld a, 0     ; init string 
197e 21 a1 f1			ld hl, os_input 
1981 77				ld (hl), a 
1982 23				inc hl 
1983 77				ld (hl), a 
1984 21 a1 f1			ld hl, os_input 
1987 3e 01			ld a, 1     ; init string 
1989 cd 33 0d			call input_str 
198c			 
198c cd d2 0a		        call clear_display 
198f cd f5 0a			call update_display		 
1992			 
1992 3a a1 f1			ld a, (os_input) 
1995 cd 5b 11			call toUpper 
1998 fe 48		        cp 'H' 
199a 28 6f		        jr z, .monhelp 
199c fe 44			cp 'D'		; dump 
199e ca 2c 1a			jp z, .mondump	 
19a1 fe 43			cp 'C'		; dump 
19a3 ca 46 1a			jp z, .moncdump	 
19a6 fe 4d			cp 'M'		; dump 
19a8 ca b7 19			jp z, .moneditstart 
19ab fe 55			cp 'U'		; dump 
19ad 28 14			jr z, .monedit	 
19af fe 51			cp 'Q'		; dump 
19b1 c8				ret z	 
19b2			 
19b2			 
19b2				; TODO "S" to access symbol by name and not need the address 
19b2				; TODO "F" to find a string in memory 
19b2			 
19b2 c3 68 19			jp monitor 
19b5			 
19b5 .. 00		.monprompt: db ">", 0 
19b7			 
19b7			.moneditstart: 
19b7				; get starting address 
19b7			 
19b7 21 a3 f1			ld hl,os_input+2 
19ba cd bd 10			call get_word_hl 
19bd			 
19bd 22 c6 f2			ld (os_cur_ptr),hl	 
19c0			 
19c0 c3 68 19			jp monitor 
19c3			 
19c3			.monedit: 
19c3				; get byte to load 
19c3			 
19c3 21 a3 f1			ld hl,os_input+2 
19c6 cd 5d 10			call get_byte 
19c9			 
19c9				; get address to update 
19c9 2a c6 f2			ld hl, (os_cur_ptr) 
19cc			 
19cc				; update byte 
19cc			 
19cc 77				ld (hl), a 
19cd			 
19cd				; move to next address and save it 
19cd			 
19cd 23				inc hl 
19ce 22 c6 f2			ld (os_cur_ptr),hl	 
19d1			 
19d1 c3 68 19			jp monitor 
19d4			 
19d4			 
19d4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
19e8 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a04 .. 00		.monhelptext3:  db "Q-Quit",0 
1a0b			        
1a0b			.monhelp: 
1a0b 3e 00			ld a, display_row_1 
1a0d 11 d4 19		        ld de, .monhelptext1 
1a10			 
1a10 cd e5 0a			call str_at_display 
1a13 3e 14			ld a, display_row_2 
1a15 11 e8 19		        ld de, .monhelptext2 
1a18					 
1a18 cd e5 0a			call str_at_display 
1a1b 3e 28			ld a, display_row_3 
1a1d 11 04 1a		        ld de, .monhelptext3 
1a20					 
1a20 cd e5 0a			call str_at_display 
1a23 cd f5 0a			call update_display		 
1a26			 
1a26 cd 72 1b			call next_page_prompt 
1a29 c3 68 19			jp monitor 
1a2c			 
1a2c			.mondump:    
1a2c 21 a3 f1			ld hl,os_input+2 
1a2f cd bd 10			call get_word_hl 
1a32			 
1a32 22 c6 f2			ld (os_cur_ptr),hl	 
1a35 cd 7a 1a			call dumpcont 
1a38 3e 3c			ld a, display_row_4 
1a3a 11 14 19			ld de, endprog 
1a3d			 
1a3d cd f5 0a			call update_display		 
1a40			 
1a40 cd 72 1b			call next_page_prompt 
1a43 c3 68 19			jp monitor 
1a46			.moncdump: 
1a46 cd 7a 1a			call dumpcont 
1a49 3e 3c			ld a, display_row_4 
1a4b 11 14 19			ld de, endprog 
1a4e			 
1a4e cd f5 0a			call update_display		 
1a51			 
1a51 cd 72 1b			call next_page_prompt 
1a54 c3 68 19			jp monitor 
1a57			 
1a57			 
1a57			; TODO symbol access  
1a57			 
1a57			.symbols:     ;; A list of symbols that can be called up  
1a57 53 fb			dw display_fb0 
1a59 .. 00			db "fb0",0  
1a5d e8 f9		     	dw store_page 
1a5f .. 00			db "store_page",0 
1a6a			 
1a6a			 
1a6a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a6a			 
1a6a 3a a4 ef			ld a,(scratch+1) 
1a6d fe 00			cp 0 
1a6f 28 09			jr z, dumpcont 
1a71			 
1a71				; no, not a null term line so has an address to work out.... 
1a71			 
1a71 21 a5 ef			ld hl,scratch+2 
1a74 cd bd 10			call get_word_hl 
1a77			 
1a77 22 c6 f2			ld (os_cur_ptr),hl	 
1a7a			 
1a7a			 
1a7a			 
1a7a			dumpcont: 
1a7a			 
1a7a				; dump bytes at ptr 
1a7a			 
1a7a			 
1a7a 3e 00			ld a, display_row_1 
1a7c 2a 5e fa			ld hl, (display_fb_active) 
1a7f cd 06 0d			call addatohl 
1a82 cd aa 1a			call .dumpbyterow 
1a85			 
1a85 3e 14			ld a, display_row_2 
1a87 2a 5e fa			ld hl, (display_fb_active) 
1a8a cd 06 0d			call addatohl 
1a8d cd aa 1a			call .dumpbyterow 
1a90			 
1a90			 
1a90 3e 28			ld a, display_row_3 
1a92 2a 5e fa			ld hl, (display_fb_active) 
1a95 cd 06 0d			call addatohl 
1a98 cd aa 1a			call .dumpbyterow 
1a9b			 
1a9b 3e 3c			ld a, display_row_4 
1a9d 2a 5e fa			ld hl, (display_fb_active) 
1aa0 cd 06 0d			call addatohl 
1aa3 cd aa 1a			call .dumpbyterow 
1aa6			 
1aa6 cd f5 0a			call update_display 
1aa9			;		jp cli 
1aa9 c9				ret 
1aaa			 
1aaa			.dumpbyterow: 
1aaa			 
1aaa				;push af 
1aaa			 
1aaa e5				push hl 
1aab			 
1aab				; calc where to poke the ascii 
1aab			if display_cols == 20 
1aab 3e 10			ld a, 16 
1aad			else 
1aad				ld a, 31 
1aad			endif 
1aad			 
1aad cd 06 0d			call addatohl 
1ab0 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1ab3			 
1ab3			 
1ab3			; display decoding address 
1ab3 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ab6			 
1ab6 7c				ld a,h 
1ab7 e1				pop hl 
1ab8 e5				push hl 
1ab9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ab9 cd 07 10			call hexout 
1abc 2a c6 f2		   	ld hl,(os_cur_ptr) 
1abf			 
1abf 7d				ld a,l 
1ac0 e1				pop hl 
1ac1 23				inc hl 
1ac2 23				inc hl 
1ac3 e5				push hl 
1ac4			;	ld hl, os_word_scratch+2 
1ac4 cd 07 10			call hexout 
1ac7 e1				pop hl 
1ac8 23				inc hl 
1ac9 23				inc hl 
1aca				;ld hl, os_word_scratch+4 
1aca 3e 3a			ld a, ':' 
1acc 77				ld (hl),a 
1acd 23				inc hl 
1ace				;ld a, 0 
1ace				;ld (hl),a 
1ace				;ld de, os_word_scratch 
1ace				;pop af 
1ace				;push af 
1ace			;		ld a, display_row_2 
1ace			;		call str_at_display 
1ace			;		call update_display 
1ace			 
1ace			 
1ace			;pop af 
1ace			;	add 5 
1ace			 
1ace			if display_cols == 20 
1ace 06 04			ld b, 4 
1ad0			else 
1ad0				ld b, 8 
1ad0			endif	 
1ad0			 
1ad0			.dumpbyte: 
1ad0 c5				push bc 
1ad1 e5				push hl 
1ad2			 
1ad2			 
1ad2 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ad5 7e					ld a,(hl) 
1ad6			 
1ad6					; poke the ascii to display 
1ad6 2a a8 f2				ld hl,(os_word_scratch) 
1ad9 77					ld (hl),a 
1ada 23					inc hl 
1adb 22 a8 f2				ld (os_word_scratch),hl 
1ade			 
1ade					 
1ade			 
1ade			 
1ade e1					pop hl 
1adf e5					push hl 
1ae0			 
1ae0 cd 07 10				call hexout 
1ae3			 
1ae3					 
1ae3 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ae6 23				inc hl 
1ae7 22 c6 f2		   	ld (os_cur_ptr),hl 
1aea			 
1aea e1					pop hl 
1aeb 23					inc hl 
1aec 23					inc hl 
1aed 23					inc hl 
1aee			 
1aee			 
1aee			 
1aee					;ld a,0 
1aee					;ld (os_word_scratch+2),a 
1aee					;pop af 
1aee					;push af 
1aee			 
1aee					;ld de, os_word_scratch 
1aee					;call str_at_display 
1aee			;		call update_display 
1aee			;		pop af 
1aee c1					pop bc 
1aef c6 03				add 3 
1af1 10 dd			djnz .dumpbyte 
1af3			 
1af3				 
1af3			 
1af3 c9				ret 
1af4			 
1af4			jump:	 
1af4			 
1af4 21 a5 ef			ld hl,scratch+2 
1af7 cd bd 10			call get_word_hl 
1afa				;ld hl,(scratch+2) 
1afa				;call fourehexhl 
1afa			 
1afa 22 c6 f2			ld (os_cur_ptr),hl	 
1afd			 
1afd e9				jp (hl) 
1afe			 
1afe			 
1afe			 
1afe			; TODO implement a basic monitor mode to start with 
1afe			 
1afe			 
1afe			 
1afe			 
1afe			 
1afe			 
1afe			 
1afe			 
1afe			 
1afe			; testing and demo code during development 
1afe			 
1afe			 
1afe .. 00		str1: db "Enter some text...",0 
1b11 .. 00		clear: db "                    ",0 
1b26			 
1b26			demo: 
1b26			 
1b26			 
1b26			 
1b26			;	call update_display 
1b26			 
1b26				; init scratch input area for testing 
1b26 21 a3 ef			ld hl, scratch	 
1b29 3e 00			ld a,0 
1b2b 77				ld (hl),a 
1b2c			 
1b2c			 
1b2c 3e 14		            LD   A, display_row_2 
1b2e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b2e 11 fe 1a		            LD   DE, str1 
1b31 cd e5 0a			call str_at_display 
1b34			 
1b34			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b34			cloop:	 
1b34 3e 28		            LD   A, display_row_3 
1b36			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b36 11 11 1b		            LD   DE, clear 
1b39			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b39 cd e5 0a				call str_at_display 
1b3c 3e 3c			ld a, display_row_4 
1b3e 11 6e 1b			ld de, prompt 
1b41			 
1b41 cd e5 0a				call str_at_display 
1b44 cd f5 0a			call update_display 
1b47			 
1b47 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b49 16 0a			ld d, 10 
1b4b 21 a3 ef			ld hl, scratch	 
1b4e cd 33 0d			call input_str 
1b51			 
1b51			;	call clear_display 
1b51			;'	call update_display 
1b51			 
1b51 3e 00		            LD   A, display_row_1 
1b53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b53 11 11 1b		            LD   DE, clear 
1b56 cd e5 0a				call str_at_display 
1b59			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b59 3e 00		            LD   A, display_row_1 
1b5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b5b 11 a3 ef		            LD   DE, scratch 
1b5e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b5e cd e5 0a				call str_at_display 
1b61 cd f5 0a			call update_display 
1b64			 
1b64 3e 00				ld a,0 
1b66 21 a3 ef			ld hl, scratch 
1b69 77				ld (hl),a 
1b6a			 
1b6a 00				nop 
1b6b c3 34 1b			jp cloop 
1b6e			 
1b6e			 
1b6e			 
1b6e			; OS Prompt 
1b6e			 
1b6e .. 00		prompt: db ">",0 
1b70 .. 00		endprg: db "?",0 
1b72			 
1b72			 
1b72			; handy next page prompt 
1b72			next_page_prompt: 
1b72 e5				push hl 
1b73 d5				push de 
1b74 f5				push af 
1b75 c5				push bc 
1b76			 
1b76 3e 4f			ld a,display_row_4 + display_cols - 1 
1b78 11 70 1b		        ld de, endprg 
1b7b cd e5 0a			call str_at_display 
1b7e cd f5 0a			call update_display 
1b81 cd a6 66			call cin_wait 
1b84 c1				pop bc 
1b85 f1				pop af 
1b86 d1				pop de 
1b87 e1				pop hl 
1b88			 
1b88			 
1b88 c9				ret 
1b89			 
1b89			 
1b89			; forth parser 
1b89			 
1b89			; My forth kernel 
1b89			include "forth_kernel.asm" 
1b89			; 
1b89			; kernel to the forth OS 
1b89			 
1b89			DS_TYPE_STR: equ 1     ; string type 
1b89			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b89			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b89			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b89			 
1b89			FORTH_PARSEV1: equ 0 
1b89			FORTH_PARSEV2: equ 0 
1b89			FORTH_PARSEV3: equ 0 
1b89			FORTH_PARSEV4: equ 0 
1b89			FORTH_PARSEV5: equ 1 
1b89			 
1b89			;if FORTH_PARSEV5 
1b89			;	FORTH_END_BUFFER: equ 0 
1b89			;else 
1b89			FORTH_END_BUFFER: equ 127 
1b89			;endif 
1b89			 
1b89			FORTH_TRUE: equ 1 
1b89			FORTH_FALSE: equ 0 
1b89			 
1b89			if FORTH_PARSEV4 
1b89			include "forth_stackops.asm" 
1b89			endif 
1b89			 
1b89			if FORTH_PARSEV5 
1b89			include "forth_stackopsv5.asm" 
1b89			 
1b89			; Stack operations for v5 parser on wards 
1b89			; * DATA stack 
1b89			; * LOOP stack 
1b89			; * RETURN stack 
1b89			 
1b89			 
1b89			 
1b89			FORTH_CHK_DSP_UNDER: macro 
1b89				push hl 
1b89				push de 
1b89				ld hl,(cli_data_sp) 
1b89				ld de, cli_data_stack 
1b89				call cmp16 
1b89				jp c, fault_dsp_under 
1b89				pop de 
1b89				pop hl 
1b89				endm 
1b89			 
1b89			 
1b89			FORTH_CHK_RSP_UNDER: macro 
1b89				push hl 
1b89				push de 
1b89				ld hl,(cli_ret_sp) 
1b89				ld de, cli_ret_stack 
1b89				call cmp16 
1b89				jp c, fault_rsp_under 
1b89				pop de 
1b89				pop hl 
1b89				endm 
1b89			 
1b89			FORTH_CHK_LOOP_UNDER: macro 
1b89				push hl 
1b89				push de 
1b89				ld hl,(cli_loop_sp) 
1b89				ld de, cli_loop_stack 
1b89				call cmp16 
1b89				jp c, fault_loop_under 
1b89				pop de 
1b89				pop hl 
1b89				endm 
1b89			 
1b89			FORTH_ERR_TOS_NOTSTR: macro 
1b89				; TOSO might need more for checks when used 
1b89				push af 
1b89				ld a,(hl) 
1b89				cp DS_TYPE_STR 
1b89				jp nz, type_faultn   
1b89				pop af 
1b89				endm 
1b89			 
1b89			FORTH_ERR_TOS_NOTNUM: macro 
1b89				push af 
1b89				ld a,(hl) 
1b89				cp DS_TYPE_INUM 
1b89				jp nz, type_faultn   
1b89				pop af 
1b89				endm 
1b89			 
1b89			 
1b89			; increase data stack pointer and save hl to it 
1b89				 
1b89			FORTH_DSP_NEXT: macro 
1b89				call macro_forth_dsp_next 
1b89				endm 
1b89			 
1b89			 
1b89			macro_forth_dsp_next: 
1b89				if DEBUG_FORTH_STACK_GUARD 
1b89 cd 90 62				call check_stacks 
1b8c				endif 
1b8c e5				push hl 
1b8d d5				push de 
1b8e eb				ex de,hl 
1b8f 2a 90 f9			ld hl,(cli_data_sp) 
1b92 23				inc hl 
1b93 23				inc hl 
1b94			 
1b94			; PARSEV5 
1b94 23				inc hl 
1b95 22 90 f9			ld (cli_data_sp),hl 
1b98 73				ld (hl), e 
1b99 23				inc hl 
1b9a 72				ld (hl), d 
1b9b d1				pop de 
1b9c e1				pop hl 
1b9d				if DEBUG_FORTH_STACK_GUARD 
1b9d cd 90 62				call check_stacks 
1ba0				endif 
1ba0 c9				ret 
1ba1			 
1ba1			 
1ba1			; increase ret stack pointer and save hl to it 
1ba1				 
1ba1			FORTH_RSP_NEXT: macro 
1ba1				call macro_forth_rsp_next 
1ba1				endm 
1ba1			 
1ba1			macro_forth_rsp_next: 
1ba1				if DEBUG_FORTH_STACK_GUARD 
1ba1 cd 90 62				call check_stacks 
1ba4				endif 
1ba4 e5				push hl 
1ba5 d5				push de 
1ba6 eb				ex de,hl 
1ba7 2a 94 f9			ld hl,(cli_ret_sp) 
1baa 23				inc hl 
1bab 23				inc hl 
1bac 22 94 f9			ld (cli_ret_sp),hl 
1baf 73				ld (hl), e 
1bb0 23				inc hl 
1bb1 72				ld (hl), d 
1bb2 d1				pop de 
1bb3 e1				pop hl 
1bb4				if DEBUG_FORTH_STACK_GUARD 
1bb4 cd 90 62				call check_stacks 
1bb7				endif 
1bb7 c9				ret 
1bb8			 
1bb8			; get current ret stack pointer and save to hl  
1bb8				 
1bb8			FORTH_RSP_TOS: macro 
1bb8				call macro_forth_rsp_tos 
1bb8				endm 
1bb8			 
1bb8			macro_forth_rsp_tos: 
1bb8				;push de 
1bb8 2a 94 f9			ld hl,(cli_ret_sp) 
1bbb cd f3 1b			call loadhlptrtohl 
1bbe				;ld e, (hl) 
1bbe				;inc hl 
1bbe				;ld d, (hl) 
1bbe				;ex de, hl 
1bbe					if DEBUG_FORTH_WORDS 
1bbe			;			DMARK "RST" 
1bbe						CALLMONITOR 
1bbe cd 6a 16			call break_point_state  
1bc1				endm  
# End of macro CALLMONITOR
1bc1					endif 
1bc1				;pop de 
1bc1 c9				ret 
1bc2			 
1bc2			; pop ret stack pointer 
1bc2				 
1bc2			FORTH_RSP_POP: macro 
1bc2				call macro_forth_rsp_pop 
1bc2				endm 
1bc2			 
1bc2			 
1bc2			macro_forth_rsp_pop: 
1bc2				if DEBUG_FORTH_STACK_GUARD 
1bc2			;		DMARK "RPP" 
1bc2 cd 90 62				call check_stacks 
1bc5					FORTH_CHK_RSP_UNDER 
1bc5 e5				push hl 
1bc6 d5				push de 
1bc7 2a 94 f9			ld hl,(cli_ret_sp) 
1bca 11 0e f9			ld de, cli_ret_stack 
1bcd cd 24 0d			call cmp16 
1bd0 da a4 63			jp c, fault_rsp_under 
1bd3 d1				pop de 
1bd4 e1				pop hl 
1bd5				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bd5				endif 
1bd5 e5				push hl 
1bd6 2a 94 f9			ld hl,(cli_ret_sp) 
1bd9			 
1bd9			 
1bd9				if FORTH_ENABLE_FREE 
1bd9			 
1bd9					; get pointer 
1bd9			 
1bd9					push de 
1bd9					push hl 
1bd9			 
1bd9					ld e, (hl) 
1bd9					inc hl 
1bd9					ld d, (hl) 
1bd9			 
1bd9					ex de, hl 
1bd9					call free 
1bd9			 
1bd9					pop hl 
1bd9					pop de 
1bd9			 
1bd9			 
1bd9				endif 
1bd9			 
1bd9			 
1bd9 2b				dec hl 
1bda 2b				dec hl 
1bdb 22 94 f9			ld (cli_ret_sp), hl 
1bde				; do stack underflow checks 
1bde e1				pop hl 
1bdf				if DEBUG_FORTH_STACK_GUARD 
1bdf cd 90 62				call check_stacks 
1be2					FORTH_CHK_RSP_UNDER 
1be2 e5				push hl 
1be3 d5				push de 
1be4 2a 94 f9			ld hl,(cli_ret_sp) 
1be7 11 0e f9			ld de, cli_ret_stack 
1bea cd 24 0d			call cmp16 
1bed da a4 63			jp c, fault_rsp_under 
1bf0 d1				pop de 
1bf1 e1				pop hl 
1bf2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bf2				endif 
1bf2 c9				ret 
1bf3			 
1bf3			 
1bf3			 
1bf3			; routine to load word pointed to by hl into hl 
1bf3			 
1bf3			loadhlptrtohl: 
1bf3			 
1bf3 d5				push de 
1bf4 5e				ld e, (hl) 
1bf5 23				inc hl 
1bf6 56				ld d, (hl) 
1bf7 eb				ex de, hl 
1bf8 d1				pop de 
1bf9			 
1bf9 c9				ret 
1bfa			 
1bfa			 
1bfa			 
1bfa			 
1bfa			 
1bfa			; push a number held in HL onto the data stack 
1bfa			; entry point for pushing a value when already in hl used in function above 
1bfa			 
1bfa			forth_push_numhl: 
1bfa			 
1bfa e5				push hl    ; save value to push 
1bfb			 
1bfb			if DEBUG_FORTH_PUSH 
1bfb				; see if disabled 
1bfb			 
1bfb			 
1bfb f5				push af 
1bfc 3a 94 ef			ld a, (os_view_disable) 
1bff fe 2a			cp '*' 
1c01 28 34			jr z, .pskip2 
1c03 e5				push hl 
1c04 e5			push hl 
1c05 cd d2 0a			call clear_display 
1c08 e1			pop hl 
1c09 7c				ld a,h 
1c0a 21 a8 f2			ld hl, os_word_scratch 
1c0d cd 07 10			call hexout 
1c10 e1				pop hl 
1c11 7d				ld a,l 
1c12 21 aa f2			ld hl, os_word_scratch+2 
1c15 cd 07 10			call hexout 
1c18			 
1c18 21 ac f2			ld hl, os_word_scratch+4 
1c1b 3e 00			ld a,0 
1c1d 77				ld (hl),a 
1c1e 11 a8 f2			ld de,os_word_scratch 
1c21 3e 14				ld a, display_row_2 
1c23 cd e5 0a				call str_at_display 
1c26 11 9e 51			ld de, .push_num 
1c29 3e 00			ld a, display_row_1 
1c2b			 
1c2b cd e5 0a				call str_at_display 
1c2e			 
1c2e			 
1c2e cd f5 0a			call update_display 
1c31 cd 52 0a			call delay1s 
1c34 cd 52 0a			call delay1s 
1c37			.pskip2:  
1c37			 
1c37 f1				pop af 
1c38			endif	 
1c38			 
1c38			 
1c38				FORTH_DSP_NEXT 
1c38 cd 89 1b			call macro_forth_dsp_next 
1c3b				endm 
# End of macro FORTH_DSP_NEXT
1c3b			 
1c3b 2a 90 f9			ld hl, (cli_data_sp) 
1c3e			 
1c3e				; save item type 
1c3e 3e 02			ld a,  DS_TYPE_INUM 
1c40 77				ld (hl), a 
1c41 23				inc hl 
1c42			 
1c42				; get word off stack 
1c42 d1				pop de 
1c43 7b				ld a,e 
1c44 77				ld (hl), a 
1c45 23				inc hl 
1c46 7a				ld a,d 
1c47 77				ld (hl), a 
1c48			 
1c48			if DEBUG_FORTH_PUSH 
1c48 2b				dec hl 
1c49 2b				dec hl 
1c4a 2b				dec hl 
1c4b						DMARK "PH5" 
1c4b f5				push af  
1c4c 3a 60 1c			ld a, (.dmark)  
1c4f 32 bd fb			ld (debug_mark),a  
1c52 3a 61 1c			ld a, (.dmark+1)  
1c55 32 be fb			ld (debug_mark+1),a  
1c58 3a 62 1c			ld a, (.dmark+2)  
1c5b 32 bf fb			ld (debug_mark+2),a  
1c5e 18 03			jr .pastdmark  
1c60 ..			.dmark: db "PH5"  
1c63 f1			.pastdmark: pop af  
1c64			endm  
# End of macro DMARK
1c64				CALLMONITOR 
1c64 cd 6a 16			call break_point_state  
1c67				endm  
# End of macro CALLMONITOR
1c67			endif	 
1c67			 
1c67 c9				ret 
1c68			 
1c68			 
1c68			; Push a string to stack pointed to by hl 
1c68			 
1c68			forth_push_str: 
1c68			 
1c68			if DEBUG_FORTH_PUSH 
1c68						DMARK "PSQ" 
1c68 f5				push af  
1c69 3a 7d 1c			ld a, (.dmark)  
1c6c 32 bd fb			ld (debug_mark),a  
1c6f 3a 7e 1c			ld a, (.dmark+1)  
1c72 32 be fb			ld (debug_mark+1),a  
1c75 3a 7f 1c			ld a, (.dmark+2)  
1c78 32 bf fb			ld (debug_mark+2),a  
1c7b 18 03			jr .pastdmark  
1c7d ..			.dmark: db "PSQ"  
1c80 f1			.pastdmark: pop af  
1c81			endm  
# End of macro DMARK
1c81				CALLMONITOR 
1c81 cd 6a 16			call break_point_state  
1c84				endm  
# End of macro CALLMONITOR
1c84			endif	 
1c84			    
1c84 e5				push hl 
1c85 e5				push hl 
1c86			 
1c86			;	ld a, 0   ; find end of string 
1c86 cd 64 11			call strlenz 
1c89			if DEBUG_FORTH_PUSH 
1c89						DMARK "PQ2" 
1c89 f5				push af  
1c8a 3a 9e 1c			ld a, (.dmark)  
1c8d 32 bd fb			ld (debug_mark),a  
1c90 3a 9f 1c			ld a, (.dmark+1)  
1c93 32 be fb			ld (debug_mark+1),a  
1c96 3a a0 1c			ld a, (.dmark+2)  
1c99 32 bf fb			ld (debug_mark+2),a  
1c9c 18 03			jr .pastdmark  
1c9e ..			.dmark: db "PQ2"  
1ca1 f1			.pastdmark: pop af  
1ca2			endm  
# End of macro DMARK
1ca2				CALLMONITOR 
1ca2 cd 6a 16			call break_point_state  
1ca5				endm  
# End of macro CALLMONITOR
1ca5			endif	 
1ca5 eb				ex de, hl 
1ca6 e1				pop hl   ; get ptr to start of string 
1ca7			if DEBUG_FORTH_PUSH 
1ca7						DMARK "PQ3" 
1ca7 f5				push af  
1ca8 3a bc 1c			ld a, (.dmark)  
1cab 32 bd fb			ld (debug_mark),a  
1cae 3a bd 1c			ld a, (.dmark+1)  
1cb1 32 be fb			ld (debug_mark+1),a  
1cb4 3a be 1c			ld a, (.dmark+2)  
1cb7 32 bf fb			ld (debug_mark+2),a  
1cba 18 03			jr .pastdmark  
1cbc ..			.dmark: db "PQ3"  
1cbf f1			.pastdmark: pop af  
1cc0			endm  
# End of macro DMARK
1cc0				CALLMONITOR 
1cc0 cd 6a 16			call break_point_state  
1cc3				endm  
# End of macro CALLMONITOR
1cc3			endif	 
1cc3 19				add hl,de 
1cc4			if DEBUG_FORTH_PUSH 
1cc4						DMARK "PQE" 
1cc4 f5				push af  
1cc5 3a d9 1c			ld a, (.dmark)  
1cc8 32 bd fb			ld (debug_mark),a  
1ccb 3a da 1c			ld a, (.dmark+1)  
1cce 32 be fb			ld (debug_mark+1),a  
1cd1 3a db 1c			ld a, (.dmark+2)  
1cd4 32 bf fb			ld (debug_mark+2),a  
1cd7 18 03			jr .pastdmark  
1cd9 ..			.dmark: db "PQE"  
1cdc f1			.pastdmark: pop af  
1cdd			endm  
# End of macro DMARK
1cdd				CALLMONITOR 
1cdd cd 6a 16			call break_point_state  
1ce0				endm  
# End of macro CALLMONITOR
1ce0			endif	 
1ce0			 
1ce0 2b				dec hl    ; see if there is an optional trailing double quote 
1ce1 7e				ld a,(hl) 
1ce2 fe 22			cp '"' 
1ce4 20 03			jr nz, .strnoq 
1ce6 3e 00			ld a, 0      ; get rid of double quote 
1ce8 77				ld (hl), a 
1ce9 23			.strnoq: inc hl 
1cea			 
1cea 3e 00			ld a, 0 
1cec 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ced			 
1ced 13				inc de ; add one for the type string 
1cee 13				inc de ; add one for null term??? 
1cef			 
1cef				; tos is get string pointer again 
1cef				; de contains space to allocate 
1cef				 
1cef d5				push de 
1cf0			 
1cf0 eb				ex de, hl 
1cf1			 
1cf1				;push af 
1cf1			 
1cf1			if DEBUG_FORTH_PUSH 
1cf1						DMARK "PHm" 
1cf1 f5				push af  
1cf2 3a 06 1d			ld a, (.dmark)  
1cf5 32 bd fb			ld (debug_mark),a  
1cf8 3a 07 1d			ld a, (.dmark+1)  
1cfb 32 be fb			ld (debug_mark+1),a  
1cfe 3a 08 1d			ld a, (.dmark+2)  
1d01 32 bf fb			ld (debug_mark+2),a  
1d04 18 03			jr .pastdmark  
1d06 ..			.dmark: db "PHm"  
1d09 f1			.pastdmark: pop af  
1d0a			endm  
# End of macro DMARK
1d0a				CALLMONITOR 
1d0a cd 6a 16			call break_point_state  
1d0d				endm  
# End of macro CALLMONITOR
1d0d			endif	 
1d0d cd cd 11			call malloc	; on ret hl now contains allocated memory 
1d10				if DEBUG_FORTH_MALLOC_GUARD 
1d10 cc f6 51				call z,malloc_error 
1d13				endif 
1d13			 
1d13				 
1d13 c1				pop bc    ; get length 
1d14 d1				pop de   ;  get string start    
1d15			 
1d15				; hl has destination from malloc 
1d15			 
1d15 eb				ex de, hl    ; prep for ldir 
1d16			 
1d16 d5				push de   ; save malloc area for DSP later 
1d17				;push hl   ; save malloc area for DSP later 
1d17			 
1d17			if DEBUG_FORTH_PUSH 
1d17						DMARK "PHc" 
1d17 f5				push af  
1d18 3a 2c 1d			ld a, (.dmark)  
1d1b 32 bd fb			ld (debug_mark),a  
1d1e 3a 2d 1d			ld a, (.dmark+1)  
1d21 32 be fb			ld (debug_mark+1),a  
1d24 3a 2e 1d			ld a, (.dmark+2)  
1d27 32 bf fb			ld (debug_mark+2),a  
1d2a 18 03			jr .pastdmark  
1d2c ..			.dmark: db "PHc"  
1d2f f1			.pastdmark: pop af  
1d30			endm  
# End of macro DMARK
1d30				CALLMONITOR 
1d30 cd 6a 16			call break_point_state  
1d33				endm  
# End of macro CALLMONITOR
1d33			endif	 
1d33			 
1d33			 
1d33 ed b0			ldir 
1d35			 
1d35			 
1d35				; push malloc to data stack     macro?????  
1d35			 
1d35				FORTH_DSP_NEXT 
1d35 cd 89 1b			call macro_forth_dsp_next 
1d38				endm 
# End of macro FORTH_DSP_NEXT
1d38			 
1d38				; save value and type 
1d38			 
1d38 2a 90 f9			ld hl, (cli_data_sp) 
1d3b			 
1d3b				; save item type 
1d3b 3e 01			ld a,  DS_TYPE_STR 
1d3d 77				ld (hl), a 
1d3e 23				inc hl 
1d3f			 
1d3f				; get malloc word off stack 
1d3f d1				pop de 
1d40 73				ld (hl), e 
1d41 23				inc hl 
1d42 72				ld (hl), d 
1d43			 
1d43			 
1d43			 
1d43			if DEBUG_FORTH_PUSH 
1d43 2a 90 f9			ld hl, (cli_data_sp) 
1d46						DMARK "PHS" 
1d46 f5				push af  
1d47 3a 5b 1d			ld a, (.dmark)  
1d4a 32 bd fb			ld (debug_mark),a  
1d4d 3a 5c 1d			ld a, (.dmark+1)  
1d50 32 be fb			ld (debug_mark+1),a  
1d53 3a 5d 1d			ld a, (.dmark+2)  
1d56 32 bf fb			ld (debug_mark+2),a  
1d59 18 03			jr .pastdmark  
1d5b ..			.dmark: db "PHS"  
1d5e f1			.pastdmark: pop af  
1d5f			endm  
# End of macro DMARK
1d5f				CALLMONITOR 
1d5f cd 6a 16			call break_point_state  
1d62				endm  
# End of macro CALLMONITOR
1d62			;	ex de,hl 
1d62			endif	 
1d62				; in case of spaces, skip the ptr past the copied string 
1d62				;pop af 
1d62				;ld (cli_origptr),hl 
1d62			 
1d62 c9				ret 
1d63			 
1d63			 
1d63			 
1d63			; TODO ascii push input onto stack given hl to start of input 
1d63			 
1d63			; identify type 
1d63			; if starts with a " then a string 
1d63			; otherwise it is a number 
1d63			;  
1d63			; if a string 
1d63			;     scan for ending " to get length of string to malloc for + 1 
1d63			;     malloc 
1d63			;     put pointer to string on stack first byte flags as string 
1d63			; 
1d63			; else a number 
1d63			;    look for number format identifier 
1d63			;    $xx hex 
1d63			;    %xxxxx bin 
1d63			;    xxxxx decimal 
1d63			;    convert number to 16bit word.  
1d63			;    malloc word + 1 with flag to identiy as num 
1d63			;    put pointer to number on stack 
1d63			;   
1d63			;  
1d63			  
1d63			forth_apush: 
1d63				; kernel push 
1d63			 
1d63			if DEBUG_FORTH_PUSH 
1d63						DMARK "PSH" 
1d63 f5				push af  
1d64 3a 78 1d			ld a, (.dmark)  
1d67 32 bd fb			ld (debug_mark),a  
1d6a 3a 79 1d			ld a, (.dmark+1)  
1d6d 32 be fb			ld (debug_mark+1),a  
1d70 3a 7a 1d			ld a, (.dmark+2)  
1d73 32 bf fb			ld (debug_mark+2),a  
1d76 18 03			jr .pastdmark  
1d78 ..			.dmark: db "PSH"  
1d7b f1			.pastdmark: pop af  
1d7c			endm  
# End of macro DMARK
1d7c				CALLMONITOR 
1d7c cd 6a 16			call break_point_state  
1d7f				endm  
# End of macro CALLMONITOR
1d7f			endif	 
1d7f				; identify input type 
1d7f			 
1d7f 7e				ld a,(hl) 
1d80 fe 22			cp '"' 
1d82 28 0a			jr z, .fapstr 
1d84 fe 24			cp '$' 
1d86 ca ae 1d			jp z, .faphex 
1d89 fe 25			cp '%' 
1d8b ca 96 1d			jp z, .fapbin 
1d8e			;	cp 'b' 
1d8e			;	jp z, .fabin 
1d8e				; else decimal 
1d8e			 
1d8e				; TODO do decimal conversion 
1d8e				; decimal is stored as a 16bit word 
1d8e			 
1d8e				; by default everything is a string if type is not detected 
1d8e			.fapstr: ; 
1d8e fe 22			cp '"' 
1d90 20 01			jr nz, .strnoqu 
1d92 23				inc hl 
1d93			.strnoqu: 
1d93 c3 68 1c			jp forth_push_str 
1d96			 
1d96			 
1d96			 
1d96			.fapbin:    ; push a binary string.  
1d96 11 00 00			ld de, 0   ; hold a 16bit value 
1d99			 
1d99 23			.fapbinshift:	inc hl  
1d9a 7e				ld a,(hl) 
1d9b fe 00			cp 0     ; done scanning  
1d9d 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d9f			 
1d9f				; left shift de 
1d9f eb				ex de, hl	 
1da0 29				add hl, hl 
1da1			 
1da1				; is 1 
1da1 fe 31			cp '1' 
1da3 20 02			jr nz, .binzero 
1da5 cb 4d			bit 1, l 
1da7			.binzero: 
1da7 eb				ex de, hl	 ; save current de 
1da8 18 ef			jr .fapbinshift 
1daa			 
1daa			.fapbdone: 
1daa eb				ex de, hl 
1dab c3 fa 1b			jp forth_push_numhl 
1dae			 
1dae			 
1dae			.faphex:   ; hex is always stored as a 16bit word 
1dae				; skip number prefix 
1dae 23				inc hl 
1daf				; turn ascii into number 
1daf cd bd 10			call get_word_hl	; ret 16bit word in hl 
1db2			 
1db2 c3 fa 1b			jp forth_push_numhl 
1db5			 
1db5 00				 nop 
1db6			 
1db6			.fabin:   ; TODO bin conversion 
1db6			 
1db6			 
1db6 c9				ret 
1db7			 
1db7			 
1db7			; get either a string ptr or a 16bit word from the data stack 
1db7			 
1db7			FORTH_DSP: macro 
1db7				call macro_forth_dsp 
1db7				endm 
1db7			 
1db7			macro_forth_dsp: 
1db7				; data stack pointer points to current word on tos 
1db7			 
1db7 2a 90 f9			ld hl,(cli_data_sp) 
1dba			 
1dba				if DEBUG_FORTH_PUSH 
1dba						DMARK "DSP" 
1dba f5				push af  
1dbb 3a cf 1d			ld a, (.dmark)  
1dbe 32 bd fb			ld (debug_mark),a  
1dc1 3a d0 1d			ld a, (.dmark+1)  
1dc4 32 be fb			ld (debug_mark+1),a  
1dc7 3a d1 1d			ld a, (.dmark+2)  
1dca 32 bf fb			ld (debug_mark+2),a  
1dcd 18 03			jr .pastdmark  
1dcf ..			.dmark: db "DSP"  
1dd2 f1			.pastdmark: pop af  
1dd3			endm  
# End of macro DMARK
1dd3			 
1dd3 cd 2b 52				call display_data_sp 
1dd6				;call break_point_state 
1dd6				;rst 030h 
1dd6				CALLMONITOR 
1dd6 cd 6a 16			call break_point_state  
1dd9				endm  
# End of macro CALLMONITOR
1dd9				endif 
1dd9			 
1dd9 c9				ret 
1dda			 
1dda			; return hl to start of value on stack 
1dda			 
1dda			FORTH_DSP_VALUE: macro 
1dda				call macro_forth_dsp_value 
1dda				endm 
1dda			 
1dda			macro_forth_dsp_value: 
1dda			 
1dda				FORTH_DSP 
1dda cd b7 1d			call macro_forth_dsp 
1ddd				endm 
# End of macro FORTH_DSP
1ddd			 
1ddd d5				push de 
1dde			 
1dde 23				inc hl ; skip type 
1ddf			 
1ddf 5e				ld e, (hl) 
1de0 23				inc hl 
1de1 56				ld d, (hl) 
1de2 eb				ex de,hl  
1de3			 
1de3 d1				pop de 
1de4			 
1de4 c9				ret 
1de5			 
1de5			; return hl to start of value to second item on stack 
1de5			 
1de5			FORTH_DSP_VALUEM1: macro 
1de5				call macro_forth_dsp_value_m1 
1de5				endm 
1de5			 
1de5			macro_forth_dsp_value_m1: 
1de5			 
1de5				FORTH_DSP 
1de5 cd b7 1d			call macro_forth_dsp 
1de8				endm 
# End of macro FORTH_DSP
1de8			 
1de8 2b				dec hl 
1de9 2b				dec hl 
1dea			;	dec hl 
1dea			 
1dea d5				push de 
1deb			 
1deb 5e				ld e, (hl) 
1dec 23				inc hl 
1ded 56				ld d, (hl) 
1dee eb				ex de,hl  
1def			 
1def d1				pop de 
1df0			 
1df0 c9				ret 
1df1			 
1df1				 
1df1			 
1df1			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1df1			 
1df1			FORTH_DSP_POP: macro 
1df1				call macro_forth_dsp_pop 
1df1				endm 
1df1			 
1df1			 
1df1			; get the tos data type 
1df1			 
1df1			FORTH_DSP_TYPE:   macro 
1df1			 
1df1				;FORTH_DSP_VALUE 
1df1				FORTH_DSP 
1df1				 
1df1				; hl points to value 
1df1				; check type 
1df1			 
1df1				ld a,(hl) 
1df1			 
1df1				endm 
1df1			 
1df1			; load the tos value into hl 
1df1			 
1df1			 
1df1			FORTH_DSP_VALUEHL:  macro 
1df1				call macro_dsp_valuehl 
1df1				endm 
1df1			 
1df1			 
1df1			 
1df1			macro_dsp_valuehl: 
1df1				FORTH_DSP_VALUE 
1df1 cd da 1d			call macro_forth_dsp_value 
1df4				endm 
# End of macro FORTH_DSP_VALUE
1df4			 
1df4				;FORTH_ERR_TOS_NOTNUM 
1df4			 
1df4				;inc hl   ; skip type id 
1df4			 
1df4			;	push de 
1df4			; 
1df4			;	ld e, (hl) 
1df4			;	inc hl 
1df4			;	ld d, (hl) 
1df4			;	ex de,hl  
1df4			 
1df4			;	pop de 
1df4			 
1df4				if DEBUG_FORTH_PUSH 
1df4						DMARK "DVL" 
1df4 f5				push af  
1df5 3a 09 1e			ld a, (.dmark)  
1df8 32 bd fb			ld (debug_mark),a  
1dfb 3a 0a 1e			ld a, (.dmark+1)  
1dfe 32 be fb			ld (debug_mark+1),a  
1e01 3a 0b 1e			ld a, (.dmark+2)  
1e04 32 bf fb			ld (debug_mark+2),a  
1e07 18 03			jr .pastdmark  
1e09 ..			.dmark: db "DVL"  
1e0c f1			.pastdmark: pop af  
1e0d			endm  
# End of macro DMARK
1e0d				CALLMONITOR 
1e0d cd 6a 16			call break_point_state  
1e10				endm  
# End of macro CALLMONITOR
1e10				endif 
1e10 c9				ret 
1e11			 
1e11			forth_apushstrhl:      
1e11				; push of string requires use of cli_origptr 
1e11				; bodge use 
1e11			 
1e11				; get current cli_origptr, save, update with temp pointer  
1e11 ed 5b ac f9		ld de, (cli_origptr) 
1e15 22 ac f9			ld (cli_origptr), hl 
1e18 d5				push de 
1e19 cd 63 1d			call forth_apush 
1e1c d1				pop de 
1e1d ed 53 ac f9		ld (cli_origptr), de 
1e21 c9			        ret	 
1e22			 
1e22			 
1e22			; increase loop stack pointer and save hl to it 
1e22				 
1e22			FORTH_LOOP_NEXT: macro 
1e22				call macro_forth_loop_next 
1e22				;nop 
1e22				endm 
1e22			 
1e22			macro_forth_loop_next: 
1e22				if DEBUG_FORTH_STACK_GUARD 
1e22 cd 90 62				call check_stacks 
1e25				endif 
1e25 e5				push hl 
1e26 d5				push de 
1e27 eb				ex de,hl 
1e28 2a 92 f9			ld hl,(cli_loop_sp) 
1e2b 23				inc hl 
1e2c 23				inc hl 
1e2d					if DEBUG_FORTH_WORDS 
1e2d						DMARK "LNX" 
1e2d f5				push af  
1e2e 3a 42 1e			ld a, (.dmark)  
1e31 32 bd fb			ld (debug_mark),a  
1e34 3a 43 1e			ld a, (.dmark+1)  
1e37 32 be fb			ld (debug_mark+1),a  
1e3a 3a 44 1e			ld a, (.dmark+2)  
1e3d 32 bf fb			ld (debug_mark+2),a  
1e40 18 03			jr .pastdmark  
1e42 ..			.dmark: db "LNX"  
1e45 f1			.pastdmark: pop af  
1e46			endm  
# End of macro DMARK
1e46						CALLMONITOR 
1e46 cd 6a 16			call break_point_state  
1e49				endm  
# End of macro CALLMONITOR
1e49					endif 
1e49 22 92 f9			ld (cli_loop_sp),hl 
1e4c 73				ld (hl), e 
1e4d 23				inc hl 
1e4e 72				ld (hl), d 
1e4f d1				pop de    ; been reversed so save a swap on restore 
1e50 e1				pop hl 
1e51				if DEBUG_FORTH_STACK_GUARD 
1e51 cd 90 62				call check_stacks 
1e54				endif 
1e54 c9				ret 
1e55			 
1e55			; get current ret stack pointer and save to hl  
1e55				 
1e55			FORTH_LOOP_TOS: macro 
1e55				call macro_forth_loop_tos 
1e55				endm 
1e55			 
1e55			macro_forth_loop_tos: 
1e55 d5				push de 
1e56 2a 92 f9			ld hl,(cli_loop_sp) 
1e59 5e				ld e, (hl) 
1e5a 23				inc hl 
1e5b 56				ld d, (hl) 
1e5c eb				ex de, hl 
1e5d d1				pop de 
1e5e c9				ret 
1e5f			 
1e5f			; pop loop stack pointer 
1e5f				 
1e5f			FORTH_LOOP_POP: macro 
1e5f				call macro_forth_loop_pop 
1e5f				endm 
1e5f			 
1e5f			 
1e5f			macro_forth_loop_pop: 
1e5f				if DEBUG_FORTH_STACK_GUARD 
1e5f					DMARK "LPP" 
1e5f f5				push af  
1e60 3a 74 1e			ld a, (.dmark)  
1e63 32 bd fb			ld (debug_mark),a  
1e66 3a 75 1e			ld a, (.dmark+1)  
1e69 32 be fb			ld (debug_mark+1),a  
1e6c 3a 76 1e			ld a, (.dmark+2)  
1e6f 32 bf fb			ld (debug_mark+2),a  
1e72 18 03			jr .pastdmark  
1e74 ..			.dmark: db "LPP"  
1e77 f1			.pastdmark: pop af  
1e78			endm  
# End of macro DMARK
1e78 cd 90 62				call check_stacks 
1e7b					FORTH_CHK_LOOP_UNDER 
1e7b e5				push hl 
1e7c d5				push de 
1e7d 2a 92 f9			ld hl,(cli_loop_sp) 
1e80 11 0c f7			ld de, cli_loop_stack 
1e83 cd 24 0d			call cmp16 
1e86 da aa 63			jp c, fault_loop_under 
1e89 d1				pop de 
1e8a e1				pop hl 
1e8b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e8b				endif 
1e8b e5				push hl 
1e8c 2a 92 f9			ld hl,(cli_loop_sp) 
1e8f 2b				dec hl 
1e90 2b				dec hl 
1e91 22 92 f9			ld (cli_loop_sp), hl 
1e94				; TODO do stack underflow checks 
1e94 e1				pop hl 
1e95				if DEBUG_FORTH_STACK_GUARD 
1e95 cd 90 62				call check_stacks 
1e98					FORTH_CHK_LOOP_UNDER 
1e98 e5				push hl 
1e99 d5				push de 
1e9a 2a 92 f9			ld hl,(cli_loop_sp) 
1e9d 11 0c f7			ld de, cli_loop_stack 
1ea0 cd 24 0d			call cmp16 
1ea3 da aa 63			jp c, fault_loop_under 
1ea6 d1				pop de 
1ea7 e1				pop hl 
1ea8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ea8				endif 
1ea8 c9				ret 
1ea9			 
1ea9			macro_forth_dsp_pop: 
1ea9			 
1ea9 e5				push hl 
1eaa			 
1eaa				; release malloc data 
1eaa			 
1eaa				if DEBUG_FORTH_STACK_GUARD 
1eaa cd 90 62				call check_stacks 
1ead					FORTH_CHK_DSP_UNDER 
1ead e5				push hl 
1eae d5				push de 
1eaf 2a 90 f9			ld hl,(cli_data_sp) 
1eb2 11 0a f5			ld de, cli_data_stack 
1eb5 cd 24 0d			call cmp16 
1eb8 da 9e 63			jp c, fault_dsp_under 
1ebb d1				pop de 
1ebc e1				pop hl 
1ebd				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ebd				endif 
1ebd				;ld hl,(cli_data_sp) 
1ebd			if DEBUG_FORTH_DOT 
1ebd				DMARK "DPP" 
1ebd				CALLMONITOR 
1ebd			endif	 
1ebd			 
1ebd			 
1ebd			if FORTH_ENABLE_DSPPOPFREE 
1ebd			 
1ebd				FORTH_DSP 
1ebd cd b7 1d			call macro_forth_dsp 
1ec0				endm 
# End of macro FORTH_DSP
1ec0			 
1ec0 7e				ld a, (hl) 
1ec1 fe 01			cp DS_TYPE_STR 
1ec3 20 07			jr nz, .skippopfree 
1ec5			 
1ec5				FORTH_DSP_VALUEHL 
1ec5 cd f1 1d			call macro_dsp_valuehl 
1ec8				endm 
# End of macro FORTH_DSP_VALUEHL
1ec8 00				nop 
1ec9			if DEBUG_FORTH_DOT 
1ec9				DMARK "DPf" 
1ec9				CALLMONITOR 
1ec9			endif	 
1ec9 cd 97 12			call free 
1ecc			.skippopfree: 
1ecc				 
1ecc			 
1ecc			endif 
1ecc			 
1ecc			if DEBUG_FORTH_DOT_KEY 
1ecc				DMARK "DP2" 
1ecc				CALLMONITOR 
1ecc			endif	 
1ecc			 
1ecc				; move pointer down 
1ecc			 
1ecc 2a 90 f9			ld hl,(cli_data_sp) 
1ecf 2b				dec hl 
1ed0 2b				dec hl 
1ed1			; PARSEV5 
1ed1 2b				dec hl 
1ed2 22 90 f9			ld (cli_data_sp), hl 
1ed5			 
1ed5				if DEBUG_FORTH_STACK_GUARD 
1ed5 cd 90 62				call check_stacks 
1ed8					FORTH_CHK_DSP_UNDER 
1ed8 e5				push hl 
1ed9 d5				push de 
1eda 2a 90 f9			ld hl,(cli_data_sp) 
1edd 11 0a f5			ld de, cli_data_stack 
1ee0 cd 24 0d			call cmp16 
1ee3 da 9e 63			jp c, fault_dsp_under 
1ee6 d1				pop de 
1ee7 e1				pop hl 
1ee8				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ee8				endif 
1ee8			 
1ee8 e1				pop hl 
1ee9			 
1ee9 c9				ret 
1eea			 
1eea			getwordathl: 
1eea				; hl points to an address 
1eea				; load hl with the word at that address 
1eea			 
1eea d5				push de 
1eeb			 
1eeb 5e				ld e, (hl) 
1eec 23				inc hl 
1eed 56				ld d, (hl) 
1eee eb				ex de, hl 
1eef			 
1eef d1				pop de 
1ef0 c9				ret 
1ef1			 
1ef1			 
1ef1			 
1ef1			 
1ef1			 
1ef1			; eof 
1ef1			 
# End of file forth_stackopsv5.asm
1ef1			endif 
1ef1			 
1ef1			user_word_eol:  
1ef1				; hl contains the pointer to where to create a linked list item from the end 
1ef1				; of the user dict to continue on at the system word dict 
1ef1				 
1ef1				; poke the stub of the word list linked list to repoint to rom words 
1ef1			 
1ef1				; stub format 
1ef1				; db   word id 
1ef1				; dw    link to next word 
1ef1			        ; db char length of token 
1ef1				; db string + 0 term 
1ef1				; db exec code....  
1ef1			 
1ef1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ef3 77				ld (hl), a		; word id 
1ef4 23				inc hl 
1ef5			 
1ef5 11 bb 20			ld de, sysdict 
1ef8 73				ld (hl), e		; next word link ie system dict 
1ef9 23				inc hl 
1efa 72				ld (hl), d		; next word link ie system dict 
1efb 23				inc hl	 
1efc			 
1efc			;	ld (hl), sysdict		; next word link ie system dict 
1efc			;	inc hl 
1efc			;	inc hl 
1efc			 
1efc			;	inc hl 
1efc			;	inc hl 
1efc			 
1efc 3e 02			ld a, 2			; word length is 0 
1efe 77				ld (hl), a	 
1eff 23				inc hl 
1f00			 
1f00 3e 7e			ld a, '~'			; word length is 0 
1f02 77				ld (hl), a	 
1f03 23				inc hl 
1f04 3e 00			ld a, 0			; save empty word 
1f06 77				ld (hl), a 
1f07			 
1f07 c9				ret 
1f08			 
1f08				 
1f08			 
1f08			forthexec_cleanup: 
1f08				FORTH_RSP_POP 
1f08 cd c2 1b			call macro_forth_rsp_pop 
1f0b				endm 
# End of macro FORTH_RSP_POP
1f0b c9				ret 
1f0c			 
1f0c			forth_call_hl: 
1f0c				; taking hl 
1f0c e5				push hl 
1f0d c9				ret 
1f0e			 
1f0e			; this is called to reset Forth system but keep existing uwords etc 
1f0e			 
1f0e			forth_warmstart: 
1f0e				; setup stack over/under flow checks 
1f0e				if DEBUG_FORTH_STACK_GUARD 
1f0e cd 76 62				call chk_stk_init 
1f11				endif 
1f11			 
1f11				; init stack pointers  - * these stacks go upwards *  
1f11 21 0e f9			ld hl, cli_ret_stack 
1f14 22 94 f9			ld (cli_ret_sp), hl	 
1f17				; set bottom of stack 
1f17 3e 00			ld a,0 
1f19 77				ld (hl),a 
1f1a 23				inc hl 
1f1b 77				ld (hl),a 
1f1c			 
1f1c 21 0a f5			ld hl, cli_data_stack 
1f1f 22 90 f9			ld (cli_data_sp), hl	 
1f22				; set bottom of stack 
1f22 3e 00			ld a,0 
1f24 77				ld (hl),a 
1f25 23				inc hl 
1f26 77				ld (hl),a 
1f27			 
1f27 21 0c f7			ld hl, cli_loop_stack 
1f2a 22 92 f9			ld (cli_loop_sp), hl	 
1f2d				; set bottom of stack 
1f2d 3e 00			ld a,0 
1f2f 77				ld (hl),a 
1f30 23				inc hl 
1f31 77				ld (hl),a 
1f32			 
1f32				; init extent of current open file 
1f32			 
1f32 3e 00			ld a, 0 
1f34 32 df f9			ld (store_openext), a 
1f37			 
1f37 c9				ret 
1f38			 
1f38			 
1f38			; Cold Start - this is called to setup the whole Forth system 
1f38			 
1f38			forth_init: 
1f38			 
1f38				; setup stack over/under flow checks 
1f38			 
1f38			;	if DEBUG_FORTH_STACK_GUARD 
1f38			;		call chk_stk_init 
1f38			;	endif 
1f38			 
1f38				; enable auto display updates (slow.....) 
1f38			 
1f38 3e 01			ld a, 1 
1f3a 32 aa f9			ld (cli_autodisplay), a 
1f3d			 
1f3d			 
1f3d			 
1f3d				; show start up screen 
1f3d			 
1f3d cd d2 0a			call clear_display 
1f40			 
1f40 3e 00			ld a,0 
1f42 32 cc f9			ld (f_cursor_ptr), a 
1f45			 
1f45				; set start of word list in start of ram - for use when creating user words 
1f45			 
1f45 21 00 80			ld hl, baseram 
1f48 22 a0 f2			ld (os_last_new_uword), hl 
1f4b cd f1 1e			call user_word_eol 
1f4e				 
1f4e			;		call display_data_sp 
1f4e			;		call next_page_prompt 
1f4e			 
1f4e			 
1f4e			 
1f4e			 
1f4e c9				ret 
1f4f			 
1f4f .. 00		.bootforth: db " Forth Kernel Init ",0 
1f63			 
1f63			; TODO push to stack 
1f63			 
1f63			;  
1f63			 
1f63			if FORTH_PARSEV2 
1f63			 
1f63			 
1f63				include "forth_parserv2.asm" 
1f63			 
1f63			endif 
1f63			 
1f63			 
1f63			; parse cli version 1 
1f63			 
1f63			if FORTH_PARSEV1 
1f63			 
1f63			 
1f63			 
1f63			      include "forth_parserv1.asm" 
1f63			endif 
1f63				 
1f63			if FORTH_PARSEV3 
1f63			 
1f63			 
1f63			 
1f63			      include "forth_parserv3.asm" 
1f63				include "forth_wordsv3.asm" 
1f63			endif 
1f63			 
1f63			if FORTH_PARSEV4 
1f63			 
1f63			 
1f63			 
1f63			      include "forth_parserv4.asm" 
1f63				include "forth_wordsv4.asm" 
1f63			endif 
1f63			 
1f63			if FORTH_PARSEV5 
1f63			 
1f63			 
1f63			 
1f63			      include "forth_parserv5.asm" 
1f63			 
1f63			 
1f63			; A better parser without using malloc and string copies all over the place.  
1f63			; Exec in situ should be faster 
1f63			 
1f63			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f63			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f63			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f63			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f63			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f63			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f63			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f63			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f63			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f63			 
1f63			; Core word preamble macro 
1f63			 
1f63			CWHEAD:   macro nxtword opcode lit len opflags 
1f63				db WORD_SYS_CORE+opcode             
1f63				; internal op code number 
1f63				dw nxtword            
1f63				; link to next dict word block 
1f63				db len + 1 
1f63				; literal length of dict word inc zero term 
1f63				db lit,0              
1f63				; literal dict word 
1f63			        ; TODO db opflags        
1f63				endm 
1f63			 
1f63			 
1f63			NEXTW: macro  
1f63				jp macro_next 
1f63				endm 
1f63			 
1f63			macro_next: 
1f63			if DEBUG_FORTH_PARSE_KEY 
1f63				DMARK "NXT" 
1f63				CALLMONITOR 
1f63			endif	 
1f63			;	inc hl  ; skip token null term  
1f63 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f67 ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f6b 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f6e			if DEBUG_FORTH_PARSE_KEY 
1f6e				DMARK "}AA" 
1f6e				CALLMONITOR 
1f6e			endif	 
1f6e c3 71 20			jp execnext 
1f71				;jp exec1 
1f71			       
1f71			 
1f71			 
1f71			; Another go at the parser to compile  
1f71			 
1f71			 
1f71			; TODO rework parser to change all of the string words to byte tokens 
1f71			; TODO do a search for  
1f71			 
1f71			; TODO first run normal parser to zero term sections 
1f71			; TODO for each word do a token look up to get the op code 
1f71			; TODO need some means to flag to the exec that this is a byte code form    
1f71			 
1f71			 
1f71			forthcompile: 
1f71			 
1f71			; 
1f71			; line parse: 
1f71			;       parse raw input buffer 
1f71			;       tokenise the words 
1f71			;       malloc new copy (for looping etc) 
1f71			;       copy to malloc + current pc in line to start of string and add line term 
1f71			;       save on new rsp 
1f71			; 
1f71			 
1f71			; hl to point to the line to tokenise 
1f71			 
1f71			;	push hl 
1f71 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1f74			 
1f74			;	ld a,0		; string term on input 
1f74			;	call strlent 
1f74			 
1f74			;	ld (os_tok_len), hl	 ; save string length 
1f74			 
1f74			;if DEBUG_FORTH_TOK 
1f74			;	ex de,hl		 
1f74			;endif 
1f74			 
1f74			;	pop hl 		; get back string pointer 
1f74			 
1f74			if DEBUG_FORTH_TOK 
1f74						DMARK "TOc" 
1f74				CALLMONITOR 
1f74			endif 
1f74 7e			.cptoken2:    ld a,(hl) 
1f75 23				inc hl 
1f76 fe 7f			cp FORTH_END_BUFFER 
1f78 28 29			jr z, .cptokendone2 
1f7a fe 00			cp 0 
1f7c 28 25			jr z, .cptokendone2 
1f7e fe 22			cp '"' 
1f80 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f82 fe 20			cp ' ' 
1f84 20 ee			jr nz,  .cptoken2 
1f86			 
1f86			; TODO consume comments held between ( and ) 
1f86			 
1f86				; we have a space so change to zero term for dict match later 
1f86 2b				dec hl 
1f87 3e 00			ld a,0 
1f89 77				ld (hl), a 
1f8a 23				inc hl 
1f8b 18 e7			jr .cptoken2 
1f8d				 
1f8d			 
1f8d			.cptokenstr2: 
1f8d				; skip all white space until either eol (because forgot to term) or end double quote 
1f8d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f8d				;inc hl ; skip current double quote 
1f8d 7e				ld a,(hl) 
1f8e 23				inc hl 
1f8f fe 22			cp '"' 
1f91 28 e1			jr z, .cptoken2 
1f93 fe 7f			cp FORTH_END_BUFFER 
1f95 28 0c			jr z, .cptokendone2 
1f97 fe 00			cp 0 
1f99 28 08			jr z, .cptokendone2 
1f9b fe 20			cp ' ' 
1f9d 28 02			jr z, .cptmp2 
1f9f 18 ec			jr .cptokenstr2 
1fa1			 
1fa1			.cptmp2:	; we have a space so change to zero term for dict match later 
1fa1				;dec hl 
1fa1				;ld a,"-"	; TODO remove this when working 
1fa1				;ld (hl), a 
1fa1				;inc hl 
1fa1 18 ea			jr .cptokenstr2 
1fa3			 
1fa3			.cptokendone2: 
1fa3				;inc hl 
1fa3 3e 7f			ld a, FORTH_END_BUFFER 
1fa5 77				ld (hl),a 
1fa6 23				inc hl 
1fa7 3e 21			ld a, '!' 
1fa9 77				ld (hl),a 
1faa			 
1faa 2a a4 f2			ld hl,(os_tok_ptr) 
1fad			         
1fad			if DEBUG_FORTH_TOK 
1fad						DMARK "Tc1" 
1fad				CALLMONITOR 
1fad			endif 
1fad			 
1fad				; push exec string to top of return stack 
1fad				FORTH_RSP_NEXT 
1fad cd a1 1b			call macro_forth_rsp_next 
1fb0				endm 
# End of macro FORTH_RSP_NEXT
1fb0 c9				ret 
1fb1			 
1fb1			; Another go at the parser need to simplify the process 
1fb1			 
1fb1			forthparse: 
1fb1			 
1fb1			; 
1fb1			; line parse: 
1fb1			;       parse raw input buffer 
1fb1			;       tokenise the words 
1fb1			;       malloc new copy (for looping etc) 
1fb1			;       copy to malloc + current pc in line to start of string and add line term 
1fb1			;       save on new rsp 
1fb1			; 
1fb1			 
1fb1			; hl to point to the line to tokenise 
1fb1			 
1fb1			;	push hl 
1fb1 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1fb4			 
1fb4			;	ld a,0		; string term on input 
1fb4			;	call strlent 
1fb4			 
1fb4			;	ld (os_tok_len), hl	 ; save string length 
1fb4			 
1fb4			;if DEBUG_FORTH_TOK 
1fb4			;	ex de,hl		 
1fb4			;endif 
1fb4			 
1fb4			;	pop hl 		; get back string pointer 
1fb4			 
1fb4			if DEBUG_FORTH_TOK 
1fb4						DMARK "TOK" 
1fb4				CALLMONITOR 
1fb4			endif 
1fb4 7e			.ptoken2:    ld a,(hl) 
1fb5 23				inc hl 
1fb6 fe 7f			cp FORTH_END_BUFFER 
1fb8 28 29			jr z, .ptokendone2 
1fba fe 00			cp 0 
1fbc 28 25			jr z, .ptokendone2 
1fbe fe 22			cp '"' 
1fc0 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fc2 fe 20			cp ' ' 
1fc4 20 ee			jr nz,  .ptoken2 
1fc6			 
1fc6			; TODO consume comments held between ( and ) 
1fc6			 
1fc6				; we have a space so change to zero term for dict match later 
1fc6 2b				dec hl 
1fc7 3e 00			ld a,0 
1fc9 77				ld (hl), a 
1fca 23				inc hl 
1fcb 18 e7			jr .ptoken2 
1fcd				 
1fcd			 
1fcd			.ptokenstr2: 
1fcd				; skip all white space until either eol (because forgot to term) or end double quote 
1fcd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fcd				;inc hl ; skip current double quote 
1fcd 7e				ld a,(hl) 
1fce 23				inc hl 
1fcf fe 22			cp '"' 
1fd1 28 e1			jr z, .ptoken2 
1fd3 fe 7f			cp FORTH_END_BUFFER 
1fd5 28 0c			jr z, .ptokendone2 
1fd7 fe 00			cp 0 
1fd9 28 08			jr z, .ptokendone2 
1fdb fe 20			cp ' ' 
1fdd 28 02			jr z, .ptmp2 
1fdf 18 ec			jr .ptokenstr2 
1fe1			 
1fe1			.ptmp2:	; we have a space so change to zero term for dict match later 
1fe1				;dec hl 
1fe1				;ld a,"-"	; TODO remove this when working 
1fe1				;ld (hl), a 
1fe1				;inc hl 
1fe1 18 ea			jr .ptokenstr2 
1fe3			 
1fe3			.ptokendone2: 
1fe3				;inc hl 
1fe3 3e 7f			ld a, FORTH_END_BUFFER 
1fe5 77				ld (hl),a 
1fe6 23				inc hl 
1fe7 3e 21			ld a, '!' 
1fe9 77				ld (hl),a 
1fea			 
1fea 2a a4 f2			ld hl,(os_tok_ptr) 
1fed			         
1fed			if DEBUG_FORTH_TOK 
1fed						DMARK "TK1" 
1fed				CALLMONITOR 
1fed			endif 
1fed			 
1fed				; push exec string to top of return stack 
1fed				FORTH_RSP_NEXT 
1fed cd a1 1b			call macro_forth_rsp_next 
1ff0				endm 
# End of macro FORTH_RSP_NEXT
1ff0 c9				ret 
1ff1			 
1ff1			; 
1ff1			;	; malloc size + buffer pointer + if is loop flag 
1ff1			;	ld hl,(os_tok_len) 		 ; get string length 
1ff1			; 
1ff1			;	ld a,l 
1ff1			; 
1ff1			;	cp 0			; we dont want to use a null string 
1ff1			;	ret z 
1ff1			; 
1ff1			;;	add 3    ; prefix malloc with buffer for current word ptr 
1ff1			; 
1ff1			;	add 5     ; TODO when certain not over writing memory remove 
1ff1			; 
1ff1			;		 
1ff1			; 
1ff1			;if DEBUG_FORTH_TOK 
1ff1			;			DMARK "TKE" 
1ff1			;	CALLMONITOR 
1ff1			;endif 
1ff1			; 
1ff1			;	ld l,a 
1ff1			;	ld h,0 
1ff1			;;	push hl   ; save required space for the copy later 
1ff1			;	call malloc 
1ff1			;if DEBUG_FORTH_TOK 
1ff1			;			DMARK "TKM" 
1ff1			;	CALLMONITOR 
1ff1			;endif 
1ff1			;	if DEBUG_FORTH_MALLOC_GUARD 
1ff1			;		push af 
1ff1			;		call ishlzero 
1ff1			;;		ld a, l 
1ff1			;;		add h 
1ff1			;;		cp 0 
1ff1			;		pop af 
1ff1			;		 
1ff1			;		call z,malloc_error 
1ff1			;	endif 
1ff1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1ff1			; 
1ff1			; 
1ff1			;if DEBUG_FORTH_TOK 
1ff1			;			DMARK "TKR" 
1ff1			;	CALLMONITOR 
1ff1			;endif 
1ff1			; 
1ff1			;	FORTH_RSP_NEXT 
1ff1			; 
1ff1			;	;inc hl	 ; go past current buffer pointer 
1ff1			;	;inc hl 
1ff1			;	;inc hl   ; and past if loop flag 
1ff1			;		; TODO Need to set flag  
1ff1			; 
1ff1			;	 
1ff1			;	 
1ff1			;	ex de,hl	; malloc is dest 
1ff1			;	ld hl, (os_tok_len) 
1ff1			;;	pop bc 
1ff1			;	ld c, l                
1ff1			;	ld b,0 
1ff1			;	ld hl, (os_tok_ptr) 
1ff1			; 
1ff1			;if DEBUG_FORTH_TOK 
1ff1			;			DMARK "TKT" 
1ff1			;	CALLMONITOR 
1ff1			;endif 
1ff1			; 
1ff1			;	; do str cpy 
1ff1			; 
1ff1			;	ldir      ; copy byte in hl to de 
1ff1			; 
1ff1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1ff1			; 
1ff1			;if DEBUG_FORTH_TOK 
1ff1			; 
1ff1			;			DMARK "TKY" 
1ff1			;	CALLMONITOR 
1ff1			;endif 
1ff1			;	;ld a,0 
1ff1			;	;ld a,FORTH_END_BUFFER 
1ff1			;	ex de, hl 
1ff1			;	;dec hl			 ; go back over the space delim at the end of word 
1ff1			;	;ld (hl),a 
1ff1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1ff1			;	ld a,FORTH_END_BUFFER 
1ff1			;	ld (hl),a 
1ff1			;	inc hl 
1ff1			;	ld a,FORTH_END_BUFFER 
1ff1			;	ld (hl),a 
1ff1			; 
1ff1			;	; init the malloc area data 
1ff1			;	; set pc for in current area 
1ff1			;	;ld hl, (os_tok_malloc) 
1ff1			;	;inc hl 
1ff1			;	;inc hl 
1ff1			;	;inc hl 
1ff1			;	;ex de,hl 
1ff1			;	;ld hl, (os_tok_malloc) 
1ff1			;	;ld (hl),e 
1ff1			;	;inc hl 
1ff1			;	;ld (hl),d 
1ff1			; 
1ff1			; 
1ff1			;	ld hl,(os_tok_malloc) 
1ff1			;if DEBUG_FORTH_PARSE_KEY 
1ff1			;			DMARK "TKU" 
1ff1			;	CALLMONITOR 
1ff1			;endif 
1ff1			; 
1ff1			;	ret 
1ff1			 
1ff1			forthexec: 
1ff1			 
1ff1			; line exec: 
1ff1			; forth parser 
1ff1			 
1ff1			; 
1ff1			;       get current exec line on rsp 
1ff1			 
1ff1				FORTH_RSP_TOS 
1ff1 cd b8 1b			call macro_forth_rsp_tos 
1ff4				endm 
# End of macro FORTH_RSP_TOS
1ff4			 
1ff4			;       restore current pc - hl points to malloc of data 
1ff4			 
1ff4				;ld e, (hl) 
1ff4				;inc hl 
1ff4				;ld d, (hl) 
1ff4				;ex de,hl 
1ff4			 
1ff4			 
1ff4			exec1: 
1ff4 22 a4 f2			ld (os_tok_ptr), hl 
1ff7			 
1ff7				; copy our PC to working vars  
1ff7 22 ae f9			ld (cli_ptr), hl 
1ffa 22 ac f9			ld (cli_origptr), hl 
1ffd			 
1ffd 7e				ld a,(hl) 
1ffe fe 7f			cp FORTH_END_BUFFER 
2000 c8				ret z 
2001			 
2001				; skip any nulls 
2001			 
2001 fe 00			cp 0 
2003 20 03			jr nz, .execword 
2005 23				inc hl 
2006 18 ec			jr exec1 
2008			 
2008			 
2008			.execword: 
2008			 
2008			 
2008			 
2008			if DEBUG_FORTH_PARSE_KEY 
2008						DMARK "KYQ" 
2008				CALLMONITOR 
2008			endif 
2008			;       while at start of word: 
2008			; get start of dict (in user area first) 
2008			 
2008 21 00 80		ld hl, baseram 
200b			;ld hl, sysdict 
200b 22 b0 f9		ld (cli_nextword),hl 
200e			;           match word at pc 
200e			;           exec word 
200e			;           or push to dsp 
200e			;           forward to next token 
200e			;           if line term pop rsp and exit 
200e			;        
200e			 
200e			if DEBUG_FORTH_PARSE_KEY 
200e						DMARK "KYq" 
200e				CALLMONITOR 
200e			endif 
200e			 
200e			; 
200e			; word comp 
200e			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
200e			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
200e			;    move to start of word  
200e			;    compare word to cli_token 
200e			 
200e			.execpnword:	; HL at start of a word in the dictionary to check 
200e			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
200e			;	ld (cli_ptr), hl 
200e			 
200e 2a b0 f9			ld hl,(cli_nextword) 
2011			 
2011 cd b4 20			call forth_tok_next 
2014			; tok next start here 
2014			;	; TODO skip compiled symbol for now 
2014			;	inc hl 
2014			; 
2014			;	; save pointer to next word 
2014			; 
2014			;	; hl now points to the address of the next word pointer  
2014			;	ld e, (hl) 
2014			;	inc hl 
2014			;	ld d, (hl) 
2014			;	inc l 
2014			; 
2014			;	ex de,hl 
2014			;if DEBUG_FORTH_PARSE_NEXTWORD 
2014			;	push bc 
2014			;	ld bc, (cli_nextword) 
2014			;			DMARK "NXW" 
2014			;	CALLMONITOR 
2014			;	pop bc 
2014			;endif 
2014			; tok next end here 
2014 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2017 eb				ex de, hl 
2018			 
2018			 
2018				; save the pointer of the current token - 1 to check against 
2018				 
2018 22 b4 f9			ld (cli_token), hl   
201b				; TODO maybe remove below save if no debug 
201b				; save token string ptr for any debug later 
201b 23				inc hl  
201c 22 b6 f9			ld (cli_origtoken), hl 
201f 2b				dec hl 
2020				; save pointer to the start of the next dictionay word 
2020 7e				ld a,(hl)   ; get string length 
2021 47				ld b,a 
2022			.execpnwordinc:  
2022 23				inc hl 
2023 10 fd			djnz .execpnwordinc 
2025 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
2028			 
2028				; now check the word token against the string being parsed 
2028			 
2028 2a b4 f9			ld hl,(cli_token) 
202b 23				inc hl     ; skip string length (use zero term instead to end) 
202c 22 b4 f9			ld (cli_token), hl 
202f			 
202f			if DEBUG_FORTH_PARSE_KEY 
202f						DMARK "KY2" 
202f			endif 
202f			if DEBUG_FORTH_PARSE_EXEC 
202f				; see if disabled 
202f			 
202f				ld a, (os_view_disable) 
202f				cp '*' 
202f				jr z, .skip 
202f			 
202f				push hl 
202f				push hl 
202f				call clear_display 
202f				ld de, .compword 
202f				ld a, display_row_1 
202f				call str_at_display 
202f				pop de 
202f				ld a, display_row_2 
202f				call str_at_display 
202f				ld hl,(cli_ptr) 
202f				ld a,(hl) 
202f			        ld hl, os_word_scratch 
202f				ld (hl),a 
202f				ld a,0 
202f				inc hl 
202f				ld (hl),a 	 
202f				ld de, os_word_scratch 
202f				ld a, display_row_2+10 
202f				call str_at_display 
202f				call update_display 
202f				ld a, 100 
202f				call aDelayInMS 
202f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
202f				call delay250ms 
202f				endif 
202f				pop hl 
202f			.skip:  
202f			endif	 
202f			.execpnchar:    ; compare char between token and string to parse 
202f			 
202f			if DEBUG_FORTH_PARSE_KEY 
202f						DMARK "Ky3" 
202f			endif 
202f			if DEBUG_FORTH_PARSE_EXEC 
202f				; see if disabled 
202f			 
202f				ld a, (os_view_disable) 
202f				cp '*' 
202f				jr z, .skip2 
202f			 
202f			;	call clear_display 
202f			ld hl,(cli_token) 
202f			ld a,(hl) 
202f			ld (os_word_scratch),a 
202f				ld hl,(cli_ptr) 
202f			ld a,(hl) 
202f				ld (os_word_scratch+1),a 
202f				ld a,0 
202f				ld (os_word_scratch+2),a 
202f				ld de,os_word_scratch 
202f				ld a,display_row_4 
202f				call str_at_display 
202f				call update_display 
202f			.skip2:  
202f			endif 
202f 2a b4 f9			ld hl,(cli_token) 
2032 7e				ld a, (hl)	 ; char in word token 
2033 23				inc hl 		; move to next char 
2034 22 b4 f9			ld (cli_token), hl ; and save it 
2037 47				ld b,a 
2038			 
2038 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
203b 7e				ld a,(hl) 
203c 23				inc hl 
203d 22 ae f9			ld (cli_ptr), hl		; move to next char 
2040 cd 5b 11			call toUpper 		; make sure the input string matches case 
2043			 
2043			if DEBUG_FORTH_PARSE 
2043			endif 
2043			 
2043				; input stream end of token is a space so get rid of it 
2043			 
2043			;	cp ' ' 
2043			;	jr nz, .pnskipspace 
2043			; 
2043			;	ld a, 0		; make same term as word token term 
2043			; 
2043			;.pnskipspace: 
2043			 
2043			if DEBUG_FORTH_PARSE_KEY 
2043						DMARK "KY7" 
2043			endif 
2043 b8				cp b 
2044 c2 5a 20			jp nz, .execpnskipword	 ; no match so move to next word 
2047				 
2047			;    if same 
2047			;       scan for string terms 0 for token and 32 for input 
2047			 
2047				 
2047			if DEBUG_FORTH_PARSE_KEY 
2047						DMARK "KY8" 
2047			endif 
2047			 
2047 80				add b			 
2048 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
204a							; TODO need to make sure last word in zero term string is accounted for 
204a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
204c			 
204c			 
204c				; at end of both strings so both are exact match 
204c			 
204c			;       skip ptr for next word 
204c			 
204c 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
204f 23				inc hl			 ; at next char 
2050 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
2053 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2056				 
2056				 
2056			if DEBUG_FORTH_PARSE_KEY 
2056						DMARK "KY3" 
2056			endif 
2056			 
2056			 
2056			 
2056			;       exec code block 
2056			if DEBUG_FORTH_JP 
2056				call clear_display 
2056				call update_display 
2056				call delay1s 
2056				ld hl, (cli_execword)     ; save for next check if no match on this word 
2056				ld a,h 
2056				ld hl, os_word_scratch 
2056				call hexout 
2056				ld hl, (cli_execword)     ; save for next check if no match on this word 
2056				ld a,l 
2056				ld hl, os_word_scratch+2 
2056				call hexout 
2056				ld hl, os_word_scratch+4 
2056				ld a,0 
2056				ld (hl),a 
2056				ld de,os_word_scratch 
2056				call str_at_display 
2056					ld a, display_row_2 
2056					call str_at_display 
2056				ld de, (cli_origtoken) 
2056				ld a, display_row_1+10 
2056					call str_at_display 
2056			 
2056				ld a,display_row_1 
2056				ld de, .foundword 
2056				ld a, display_row_3 
2056				call str_at_display 
2056				call update_display 
2056				call delay1s 
2056				call delay1s 
2056				call delay1s 
2056			endif 
2056			 
2056			if DEBUG_FORTH_PARSE_KEY 
2056						DMARK "KYj" 
2056			endif 
2056				; TODO save the word pointer in this exec 
2056			 
2056 2a b2 f9			ld hl,(cli_execword) 
2059 e9				jp (hl) 
205a			 
205a			 
205a			;    if not same 
205a			;	scan for zero term 
205a			;	get ptr for next word 
205a			;	goto word comp 
205a			 
205a			.execpnskipword:	; get pointer to next word 
205a 2a b0 f9			ld hl,(cli_nextword) 
205d			 
205d 7e				ld a,(hl) 
205e fe 00			cp WORD_SYS_END 
2060			;	cp 0 
2060 28 09			jr z, .execendofdict			 ; at end of words 
2062			 
2062			if DEBUG_FORTH_PARSE_KEY 
2062						DMARK "KY4" 
2062			endif 
2062			if DEBUG_FORTH_PARSE_EXEC 
2062			 
2062				; see if disabled 
2062			 
2062				ld a, (os_view_disable) 
2062				cp '*' 
2062				jr z, .noskip 
2062			 
2062			 
2062				ld de, .nowordfound 
2062				ld a, display_row_3 
2062				call str_at_display 
2062				call update_display 
2062				ld a, 100 
2062				call aDelayInMS 
2062				 
2062				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2062					call delay250ms 
2062				endif 
2062			.noskip:  
2062			 
2062			endif	 
2062			 
2062 2a ac f9			ld hl,(cli_origptr) 
2065 22 ae f9			ld (cli_ptr),hl 
2068			 
2068			if DEBUG_FORTH_PARSE_KEY 
2068						DMARK "KY5" 
2068			endif 
2068 c3 0e 20			jp .execpnword			; else go to next word 
206b			 
206b			.execendofdict:  
206b			 
206b			if DEBUG_FORTH_PARSE_KEY 
206b						DMARK "KYe" 
206b			endif 
206b			if DEBUG_FORTH_PARSE_EXEC 
206b				; see if disabled 
206b			 
206b				ld a, (os_view_disable) 
206b				cp '*' 
206b				jr z, .ispskip 
206b			 
206b				call clear_display 
206b				call update_display 
206b				call delay1s 
206b				ld de, (cli_origptr) 
206b				ld a, display_row_1 
206b				call str_at_display 
206b				 
206b				ld de, .enddict 
206b				ld a, display_row_3 
206b				call str_at_display 
206b				call update_display 
206b				ld a, 100 
206b				call aDelayInMS 
206b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
206b				call delay1s 
206b				call delay1s 
206b				call delay1s 
206b				endif 
206b			.ispskip:  
206b				 
206b			endif	 
206b			 
206b			 
206b			 
206b				; if the word is not a keyword then must be a literal so push it to stack 
206b			 
206b			; push token to stack to end of word 
206b			 
206b				STACKFRAME ON $1efe $2f9f 
206b				if DEBUG_STACK_IMB 
206b					if ON 
206b						exx 
206b						ld de, $1efe 
206b						ld a, d 
206b						ld hl, curframe 
206b						call hexout 
206b						ld a, e 
206b						ld hl, curframe+2 
206b						call hexout 
206b						ld hl, $1efe 
206b						push hl 
206b						ld hl, $2f9f 
206b						push hl 
206b						exx 
206b					endif 
206b				endif 
206b			endm 
# End of macro STACKFRAME
206b			 
206b 2a a4 f2		ld hl,(os_tok_ptr) 
206e cd 63 1d		call forth_apush 
2071			 
2071				STACKFRAMECHK ON $1efe $2f9f 
2071				if DEBUG_STACK_IMB 
2071					if ON 
2071						exx 
2071						ld hl, $2f9f 
2071						pop de   ; $2f9f 
2071						call cmp16 
2071						jr nz, .spnosame 
2071						ld hl, $1efe 
2071						pop de   ; $1efe 
2071						call cmp16 
2071						jr z, .spfrsame 
2071						.spnosame: call showsperror 
2071						.spfrsame: nop 
2071						exx 
2071					endif 
2071				endif 
2071			endm 
# End of macro STACKFRAMECHK
2071			 
2071			execnext: 
2071			 
2071			if DEBUG_FORTH_PARSE_KEY 
2071						DMARK "KY>" 
2071			endif 
2071			; move past token to next word 
2071			 
2071 2a a4 f2		ld hl, (os_tok_ptr) 
2074 3e 00		ld a, 0 
2076 01 ff 00		ld bc, 255     ; input buffer size 
2079 ed b1		cpir 
207b			 
207b			if DEBUG_FORTH_PARSE_KEY 
207b						DMARK "KY!" 
207b				CALLMONITOR 
207b			endif	 
207b			; TODO this might place hl on the null, so will need to forward on??? 
207b			;inc hl   ; see if this gets onto the next item 
207b			 
207b			 
207b			; TODO pass a pointer to the buffer to push 
207b			; TODO call function to push 
207b			 
207b			; look for end of input 
207b			 
207b			;inc hl 
207b			;ld a,(hl) 
207b			;cp FORTH_END_BUFFER 
207b			;ret z 
207b			 
207b			 
207b c3 f4 1f		jp exec1 
207e			 
207e			 
207e			 
207e			 
207e			 
207e			 
207e			 
207e			 
207e			 
207e			findnexttok: 
207e			 
207e				; hl is pointer to move 
207e				; de is the token to locate 
207e			 
207e					if DEBUG_FORTH 
207e						DMARK "NTK" 
207e						CALLMONITOR 
207e					endif 
207e d5				push de 
207f			 
207f			.fnt1:	 
207f				; find first char of token to locate 
207f			 
207f 1a				ld a, (de) 
2080 4f				ld c,a 
2081 7e				ld a,(hl) 
2082 cd 5b 11			call toUpper 
2085					if DEBUG_FORTH 
2085						DMARK "NT1" 
2085						CALLMONITOR 
2085					endif 
2085 b9				cp c 
2086			 
2086 28 03			jr z, .fnt2cmpmorefirst	 
2088			 
2088				; first char not found move to next char 
2088			 
2088 23				inc hl 
2089 18 f4			jr .fnt1 
208b			 
208b			.fnt2cmpmorefirst:	 
208b				; first char of token found.  
208b			 
208b e5				push hl     ; save start of token just in case it is the right one 
208c d9				exx 
208d e1				pop hl        ; save it to hl' 
208e d9				exx 
208f			 
208f			 
208f			.fnt2cmpmore:	 
208f				; compare the rest 
208f				 
208f 23				inc hl 
2090 13				inc de 
2091				 
2091 1a				ld a, (de) 
2092 4f				ld c,a 
2093 7e				ld a,(hl) 
2094 cd 5b 11			call toUpper 
2097			 
2097					if DEBUG_FORTH 
2097						DMARK "NT2" 
2097						CALLMONITOR 
2097					endif 
2097				; c has the token to find char 
2097				; a has the mem to scan char 
2097			 
2097 b9				cp c 
2098 28 04			jr z,.fntmatch1 
209a			 
209a				; they are not the same 
209a			 
209a					if DEBUG_FORTH 
209a						DMARK "NT3" 
209a						CALLMONITOR 
209a					endif 
209a d1				pop de	; reset de token to look for 
209b d5				push de 
209c 18 e1			jr .fnt1 
209e				 
209e			.fntmatch1: 
209e			 
209e				; is the same char a null which means we might have a full hit? 
209e					if DEBUG_FORTH 
209e						DMARK "NT4" 
209e						CALLMONITOR 
209e					endif 
209e			 
209e fe 00			cp 0 
20a0 28 0b			jr z, .fntmatchyes 
20a2			 
20a2				; are we at the end of the token to find? 
20a2			 
20a2					if DEBUG_FORTH 
20a2						DMARK "NT5" 
20a2						CALLMONITOR 
20a2					endif 
20a2 3e 00			ld a, 0 
20a4 b9				cp c 
20a5			 
20a5 c2 8f 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20a8			 
20a8					if DEBUG_FORTH 
20a8						DMARK "NT6" 
20a8						CALLMONITOR 
20a8					endif 
20a8				; token to find is exhusted but no match to stream 
20a8			 
20a8				; restore tok pointer and continue on 
20a8 d1				pop de 
20a9 d5				push de 
20aa c3 7f 20			jp .fnt1 
20ad			 
20ad			 
20ad			.fntmatchyes: 
20ad			 
20ad				; hl now contains the end of the found token 
20ad			 
20ad				; get rid of saved token pointer to find 
20ad			 
20ad d1				pop de 
20ae			 
20ae					if DEBUG_FORTH 
20ae						DMARK "NT9" 
20ae						CALLMONITOR 
20ae					endif 
20ae			 
20ae				; hl will be on the null term so forward on 
20ae			 
20ae				; get back the saved start of the token 
20ae			 
20ae d9				exx 
20af e5				push hl     ; save start of token just in case it is the right one 
20b0 d9				exx 
20b1 e1				pop hl        ; save it to hl 
20b2			 
20b2 c9				ret 
20b3			 
20b3			 
20b3			; LIST needs to find a specific token   
20b3			; FORGET needs to find a spefici token 
20b3			 
20b3			; SAVE needs to find all tokens by flag 
20b3			; WORDS just needs to scan through all  by flag 
20b3			; UWORDS needs to scan through all by flag 
20b3			 
20b3			 
20b3			; given hl as pointer to start of dict look up string 
20b3			; return hl as pointer to start of word block 
20b3			; or 0 if not found 
20b3			 
20b3			forth_find_tok: 
20b3 c9				ret 
20b4			 
20b4			; given hl as pointer to dict structure 
20b4			; move to the next dict block structure 
20b4			 
20b4			forth_tok_next: 
20b4				; hl now points to the address of the next word pointer  
20b4				; TODO skip compiled symbol for now 
20b4			;	push de 
20b4 23				inc hl 
20b5 5e				ld e, (hl) 
20b6 23				inc hl 
20b7 56				ld d, (hl) 
20b8 23				inc hl 
20b9			 
20b9 eb				ex de,hl 
20ba			if DEBUG_FORTH_PARSE_NEXTWORD 
20ba				push bc 
20ba				ld bc, (cli_nextword) 
20ba						DMARK "NXW" 
20ba				CALLMONITOR 
20ba				pop bc 
20ba			endif 
20ba			;	pop de	 
20ba c9				ret 
20bb			 
20bb			 
20bb			 
20bb			; eof 
# End of file forth_parserv5.asm
20bb				include "forth_wordsv4.asm" 
20bb			 
20bb			; the core word dictionary v4 
20bb			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20bb			 
20bb			; this is a linked list for each of the system words used 
20bb			; user defined words will follow the same format but will be in ram 
20bb			 
20bb			 
20bb			; 
20bb			; 
20bb			; define linked list: 
20bb			; 
20bb			; 1. compiled byte op code 
20bb			; 2. len of text word 
20bb			; 3. text word 
20bb			; 4. ptr to next dictionary word 
20bb			; 5. asm, calls etc for the word 
20bb			; 
20bb			;  if 1 == 0 then last word in dict  
20bb			;   
20bb			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20bb			;  
20bb			;  
20bb			; create basic standard set of words 
20bb			; 
20bb			;  
20bb			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20bb			; 2DUP 2DROP 2SWAP  
20bb			; @ C@ - get byte  
20bb			; ! C! - store byte 
20bb			; 0< true if less than zero 
20bb			; 0= true if zero 
20bb			; < >  
20bb			; = true if same 
20bb			; variables 
20bb			 
20bb			 
20bb			; Hardware specific words I may need 
20bb			; 
20bb			; IN OUT  
20bb			; calls to key util functions 
20bb			; calls to hardward abstraction stuff 
20bb			; easy control of frame buffers and lcd i/o 
20bb			; keyboard  
20bb			 
20bb			 
20bb			;DICT: macro 
20bb			; op_code, len, word, next 
20bb			;    word: 
20bb			;    db op_code 
20bb			;    ds word zero term 
20bb			;    dw next 
20bb			;    endm 
20bb			 
20bb			 
20bb			 
20bb			 
20bb			; op code 1 is a flag for user define words which are to be handled differently 
20bb			 
20bb			 
20bb			; 
20bb			; 
20bb			;    TODO on entry to a word this should be the expected environment 
20bb			;    hl - tos value if number then held, if string this is the ptr 
20bb			;    de -  
20bb			 
20bb			 
20bb			; opcode ranges 
20bb			; 0 - end of word dict 
20bb			; 255 - user define words 
20bb			 
20bb			sysdict: 
20bb			include "forth_opcodes.asm" 
20bb			; op codes for forth keywords 
20bb			; free to use code 0  
20bb				OPCODE_HEAP: equ  1 
20bb				OPCODE_EXEC: equ 2 
20bb				OPCODE_DUP: equ 3 
20bb				OPCODE_SWAP: equ 4 
20bb				OPCODE_COLN: equ 5 
20bb				OPCODE_SCOLN: equ 6 
20bb				OPCODE_DROP: equ 7 
20bb				OPCODE_DUP2: equ 8 
20bb				OPCODE_DROP2: equ 9 
20bb				OPCODE_SWAP2: equ 10 
20bb				OPCODE_AT: equ 11 
20bb				OPCODE_CAT: equ 12 
20bb				OPCODE_BANG: equ 13 
20bb				OPCODE_CBANG: equ 14 
20bb				OPCODE_SCALL: equ 15 
20bb				OPCODE_DEPTH: equ 16 
20bb				OPCODE_OVER: equ 17 
20bb				OPCODE_PAUSE: equ 18 
20bb				OPCODE_PAUSES: equ 19 
20bb				OPCODE_ROT: equ 20 
20bb			;free to reuse	OPCODE_WORDS: equ 21 
20bb			        OPCODE_NOT: equ 21 
20bb				OPCODE_UWORDS: equ 22 
20bb				OPCODE_BP: equ 23 
20bb				OPCODE_MONITOR: equ 24  
20bb				OPCODE_MALLOC: equ 25 
20bb				OPCODE_FREE: equ 26 
20bb				OPCODE_LIST: equ 27 
20bb				OPCODE_FORGET: equ 28 
20bb				OPCODE_NOP: equ 29 
20bb				OPCODE_COMO: equ 30 
20bb				OPCODE_COMC: equ 31 
20bb			;free to reuse	OPCODE_ENDCORE: equ 32 
20bb				OPCODE_AFTERSOUND: equ 33 
20bb				OPCODE_GP2: equ 34 
20bb				OPCODE_GP3: equ 35 
20bb				OPCODE_GP4: equ 36 
20bb				OPCODE_SIN: equ 37 
20bb				OPCODE_SOUT: equ 38 
20bb				OPCODE_SPIO: equ 39 
20bb				OPCODE_SPICEH: equ 40 
20bb				OPCODE_SPIOb: equ 41 
20bb				OPCODE_SPII: equ 42 
20bb				OPCODE_SESEL: equ 43 
20bb				OPCODE_CARTDEV: equ 44 
20bb			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20bb				OPCODE_FB: equ 46 
20bb				OPCODE_EMIT: equ 47 
20bb				OPCODE_DOTH: equ 48 
20bb				OPCODE_DOTF: equ 49 
20bb				OPCODE_DOT: equ 50 
20bb				OPCODE_CLS: equ 51 
20bb				OPCODE_DRAW: equ 52 
20bb				OPCODE_DUMP: equ 53 
20bb				OPCODE_CDUMP: equ 54 
20bb				OPCODE_DAT: equ 55 
20bb				OPCODE_HOME: equ 56 
20bb				OPCODE_SPACE: equ 57 
20bb				OPCODE_SPACES: equ 58 
20bb				OPCODE_SCROLL: equ 59 
20bb				OPCODE_ATQ: equ 60 
20bb				OPCODE_AUTODSP: equ 61 
20bb				OPCODE_MENU: equ 62 
20bb			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20bb				OPCODE_THEN: equ 64 
20bb				OPCODE_ELSE: equ 65 
20bb				OPCODE_DO: equ 66 
20bb				OPCODE_LOOP: equ 67 
20bb				OPCODE_I: equ 68 
20bb				OPCODE_DLOOP: equ 69  
20bb				OPCODE_REPEAT: equ 70  
20bb				OPCODE_UNTIL: equ 71 
20bb				OPCODE_ENDFLOW: equ 72 
20bb				OPCODE_WAITK: equ 73 
20bb				OPCODE_ACCEPT: equ 74 
20bb				OPCODE_EDIT: equ 75 
20bb			;free to reuse	OPCODE_ENDKEY: equ 76 
20bb				OPCODE_LZERO: equ 77 
20bb				OPCODE_TZERO: equ 78 
20bb				OPCODE_LESS: equ 79 
20bb				OPCODE_GT: equ 80 
20bb				OPCODE_EQUAL: equ 81  
20bb			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20bb				OPCODE_NEG: equ 83 
20bb				OPCODE_DIV: equ 84 
20bb				OPCODE_MUL: equ 85 
20bb				OPCODE_MIN: equ 86 
20bb				OPCODE_MAX: equ 87 
20bb				OPCODE_RND16: equ 88 
20bb				OPCODE_RND8: equ 89 
20bb				OPCODE_RND: equ 90 
20bb			;free to reuse	OPCODE_ENDMATHS: equ 91  
20bb				OPCODE_BYNAME: equ 92 
20bb				OPCODE_DIR: equ 93 
20bb				OPCODE_SAVE: equ 94 
20bb				OPCODE_LOAD: equ 95 
20bb				OPCODE_BSAVE: equ 96 
20bb				OPCODE_BLOAD: equ 97 
20bb				OPCODE_SEO: equ 98  
20bb				OPCODE_SEI: equ 99 
20bb				OPCODE_SFREE: equ 100 
20bb				OPCODE_SIZE: equ 101 
20bb				OPCODE_CREATE: equ 102 
20bb				OPCODE_APPEND: equ 103 
20bb				OPCODE_SDEL: equ 104 
20bb				OPCODE_OPEN: equ 105 
20bb				OPCODE_READ: equ 106 
20bb				OPCODE_EOF: equ 106 
20bb				OPCODE_FORMAT: equ 107 
20bb				OPCODE_LABEL: equ 108 
20bb				OPCODE_LABELS: equ 109 
20bb			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20bb				OPCODE_UPPER: equ 111 
20bb				OPCODE_LOWER: equ 112 
20bb				OPCODE_SUBSTR: equ 113 
20bb				OPCODE_LEFT: equ 114 
20bb				OPCODE_RIGHT: equ 115 
20bb				OPCODE_STR2NUM: equ 116 
20bb				OPCODE_NUM2STR: equ 117 
20bb				OPCODE_CONCAT: equ 118 
20bb				OPCODE_FIND: equ 119 
20bb				OPCODE_LEN: equ 120 
20bb				OPCODE_CHAR: equ 121 
20bb			; free to reuse	OPCODE_STRLEN: equ 122 
20bb			; free to reuse	OPCODE_ENDSTR: equ 123 
20bb				OPCODE_V0S: equ 124 
20bb				OPCODE_V0Q: equ 125 
20bb				OPCODE_V1S: equ 126 
20bb				OPCODE_V1Q: equ 127 
20bb				OPCODE_V2S: equ 128 
20bb				OPCODE_V2Q: equ 129 
20bb				OPCODE_V3S: equ 130 
20bb				OPCODE_V3Q: equ 131 
20bb			;free to reuse	OPCODE_END: equ 132 
20bb				OPCODE_ZDUP: equ 133 
20bb			 
20bb			; eof 
# End of file forth_opcodes.asm
20bb			 
20bb			include "forth_words_core.asm" 
20bb			 
20bb			; | ## Core Words 
20bb			 
20bb			;if MALLOC_4 
20bb			 
20bb			.HEAP: 
20bb				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20bb 15				db WORD_SYS_CORE+OPCODE_HEAP             
20bc fa 20			dw .EXEC            
20be 05				db 4 + 1 
20bf .. 00			db "HEAP",0              
20c4				endm 
# End of macro CWHEAD
20c4			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20c4			; | | u1 - Current number of bytes in the heap 
20c4			; | | u2 - Remaining bytes left on the heap 
20c4			; | |  
20c4			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20c4			 
20c4			 
20c4					if DEBUG_FORTH_WORDS_KEY 
20c4						DMARK "HEP" 
20c4 f5				push af  
20c5 3a d9 20			ld a, (.dmark)  
20c8 32 bd fb			ld (debug_mark),a  
20cb 3a da 20			ld a, (.dmark+1)  
20ce 32 be fb			ld (debug_mark+1),a  
20d1 3a db 20			ld a, (.dmark+2)  
20d4 32 bf fb			ld (debug_mark+2),a  
20d7 18 03			jr .pastdmark  
20d9 ..			.dmark: db "HEP"  
20dc f1			.pastdmark: pop af  
20dd			endm  
# End of macro DMARK
20dd						CALLMONITOR 
20dd cd 6a 16			call break_point_state  
20e0				endm  
# End of macro CALLMONITOR
20e0					endif 
20e0 2a 0a 80				ld hl, (free_list )      
20e3 11 0e 80				ld de, heap_start 
20e6			 
20e6 ed 52				sbc hl, de  
20e8			 
20e8 cd fa 1b				call forth_push_numhl 
20eb			 
20eb			 
20eb ed 5b 0a 80			ld de, (free_list )      
20ef 21 89 ef				ld hl, heap_end 
20f2			 
20f2 ed 52				sbc hl, de 
20f4			 
20f4 cd fa 1b				call forth_push_numhl 
20f7					 
20f7			 
20f7					 
20f7			 
20f7			 
20f7			 
20f7					NEXTW 
20f7 c3 63 1f			jp macro_next 
20fa				endm 
# End of macro NEXTW
20fa			;endif 
20fa			 
20fa			.EXEC: 
20fa				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20fa 16				db WORD_SYS_CORE+OPCODE_EXEC             
20fb 96 21			dw .STKEXEC            
20fd 05				db 4 + 1 
20fe .. 00			db "EXEC",0              
2103				endm 
# End of macro CWHEAD
2103			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
2103			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2103			; | | 
2103			; | |   
2103				STACKFRAME OFF $5efe $5f9f 
2103				if DEBUG_STACK_IMB 
2103					if OFF 
2103						exx 
2103						ld de, $5efe 
2103						ld a, d 
2103						ld hl, curframe 
2103						call hexout 
2103						ld a, e 
2103						ld hl, curframe+2 
2103						call hexout 
2103						ld hl, $5efe 
2103						push hl 
2103						ld hl, $5f9f 
2103						push hl 
2103						exx 
2103					endif 
2103				endif 
2103			endm 
# End of macro STACKFRAME
2103			 
2103					if DEBUG_FORTH_WORDS_KEY 
2103						DMARK "EXE" 
2103 f5				push af  
2104 3a 18 21			ld a, (.dmark)  
2107 32 bd fb			ld (debug_mark),a  
210a 3a 19 21			ld a, (.dmark+1)  
210d 32 be fb			ld (debug_mark+1),a  
2110 3a 1a 21			ld a, (.dmark+2)  
2113 32 bf fb			ld (debug_mark+2),a  
2116 18 03			jr .pastdmark  
2118 ..			.dmark: db "EXE"  
211b f1			.pastdmark: pop af  
211c			endm  
# End of macro DMARK
211c						CALLMONITOR 
211c cd 6a 16			call break_point_state  
211f				endm  
# End of macro CALLMONITOR
211f					endif 
211f			 
211f				FORTH_DSP_VALUEHL 
211f cd f1 1d			call macro_dsp_valuehl 
2122				endm 
# End of macro FORTH_DSP_VALUEHL
2122			 
2122				FORTH_DSP_POP 
2122 cd a9 1e			call macro_forth_dsp_pop 
2125				endm 
# End of macro FORTH_DSP_POP
2125			 
2125					if DEBUG_FORTH_WORDS 
2125						DMARK "EX1" 
2125 f5				push af  
2126 3a 3a 21			ld a, (.dmark)  
2129 32 bd fb			ld (debug_mark),a  
212c 3a 3b 21			ld a, (.dmark+1)  
212f 32 be fb			ld (debug_mark+1),a  
2132 3a 3c 21			ld a, (.dmark+2)  
2135 32 bf fb			ld (debug_mark+2),a  
2138 18 03			jr .pastdmark  
213a ..			.dmark: db "EX1"  
213d f1			.pastdmark: pop af  
213e			endm  
# End of macro DMARK
213e						CALLMONITOR 
213e cd 6a 16			call break_point_state  
2141				endm  
# End of macro CALLMONITOR
2141					endif 
2141			;	ld e,(hl) 
2141			;	inc hl 
2141			;	ld d,(hl) 
2141			;	ex de,hl 
2141			 
2141			;		if DEBUG_FORTH_WORDS 
2141			;			DMARK "EX2" 
2141			;			CALLMONITOR 
2141			;		endif 
2141 e5				push hl 
2142			 
2142				;ld a, 0 
2142				;ld a, FORTH_END_BUFFER 
2142 cd 64 11			call strlenz 
2145 23				inc hl   ; include zero term to copy 
2146 23				inc hl   ; include term 
2147 23				inc hl   ; include term 
2148 06 00			ld b,0 
214a 4d				ld c,l 
214b e1				pop hl 
214c 11 a2 f0			ld de, execscratch 
214f					if DEBUG_FORTH_WORDS 
214f						DMARK "EX3" 
214f f5				push af  
2150 3a 64 21			ld a, (.dmark)  
2153 32 bd fb			ld (debug_mark),a  
2156 3a 65 21			ld a, (.dmark+1)  
2159 32 be fb			ld (debug_mark+1),a  
215c 3a 66 21			ld a, (.dmark+2)  
215f 32 bf fb			ld (debug_mark+2),a  
2162 18 03			jr .pastdmark  
2164 ..			.dmark: db "EX3"  
2167 f1			.pastdmark: pop af  
2168			endm  
# End of macro DMARK
2168						CALLMONITOR 
2168 cd 6a 16			call break_point_state  
216b				endm  
# End of macro CALLMONITOR
216b					endif 
216b ed b0			ldir 
216d			 
216d			 
216d 21 a2 f0			ld hl, execscratch 
2170			 
2170					if DEBUG_FORTH_WORDS 
2170						DMARK "EXe" 
2170 f5				push af  
2171 3a 85 21			ld a, (.dmark)  
2174 32 bd fb			ld (debug_mark),a  
2177 3a 86 21			ld a, (.dmark+1)  
217a 32 be fb			ld (debug_mark+1),a  
217d 3a 87 21			ld a, (.dmark+2)  
2180 32 bf fb			ld (debug_mark+2),a  
2183 18 03			jr .pastdmark  
2185 ..			.dmark: db "EXe"  
2188 f1			.pastdmark: pop af  
2189			endm  
# End of macro DMARK
2189						CALLMONITOR 
2189 cd 6a 16			call break_point_state  
218c				endm  
# End of macro CALLMONITOR
218c					endif 
218c			 
218c cd b1 1f			call forthparse 
218f cd f1 1f			call forthexec 
2192			;	call forthexec_cleanup 
2192			;	call forthparse 
2192			;	call forthexec 
2192			 
2192				STACKFRAMECHK OFF $5efe $5f9f 
2192				if DEBUG_STACK_IMB 
2192					if OFF 
2192						exx 
2192						ld hl, $5f9f 
2192						pop de   ; $5f9f 
2192						call cmp16 
2192						jr nz, .spnosame 
2192						ld hl, $5efe 
2192						pop de   ; $5efe 
2192						call cmp16 
2192						jr z, .spfrsame 
2192						.spnosame: call showsperror 
2192						.spfrsame: nop 
2192						exx 
2192					endif 
2192				endif 
2192			endm 
# End of macro STACKFRAMECHK
2192			 
2192				; an immediate word so no need to process any more words 
2192 c9				ret 
2193				NEXTW 
2193 c3 63 1f			jp macro_next 
2196				endm 
# End of macro NEXTW
2196			 
2196			; dead code - old version  
2196			;	FORTH_RSP_NEXT 
2196			 
2196			;  
2196			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2196			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2196			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2196			;	push hl 
2196			;	push de 
2196			;	push bc 
2196			; 
2196			; 
2196			;		if DEBUG_FORTH_WORDS_KEY 
2196			;			DMARK "EXR" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			; 
2196			; 
2196			;	;v5 FORTH_DSP_VALUE 
2196			;	FORTH_DSP_VALUEHL 
2196			; 
2196			;	; TODO do string type checks 
2196			; 
2196			;;v5	inc hl   ; skip type 
2196			; 
2196			;	push hl  ; source code  
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX1" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	ld a, 0 
2196			;	call strlent 
2196			; 
2196			;	inc hl 
2196			;	inc hl 
2196			;	inc hl 
2196			;	inc hl 
2196			; 
2196			;	push hl    ; size 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX2" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	call malloc 
2196			; 
2196			;	ex de, hl    ; de now contains malloc area 
2196			;	pop bc   	; get byte count 
2196			;	pop hl      ; get string to copy 
2196			; 
2196			;	push de     ; save malloc for free later 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX3" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	ldir       ; duplicate string 
2196			; 
2196			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2196			;	 
2196			;	; TODO fix the parse would be better than this...  
2196			;	ex de, hl 
2196			;	dec hl 
2196			;	ld a, 0 
2196			;	ld (hl), a 
2196			;	dec hl 
2196			;	ld a, ' ' 
2196			;	ld (hl), a 
2196			;	dec hl 
2196			;	ld (hl), a 
2196			; 
2196			;	dec hl 
2196			;	ld (hl), a 
2196			; 
2196			; 
2196			;	FORTH_DSP_POP  
2196			; 
2196			;	pop hl     
2196			;	push hl    ; save malloc area 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX4" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			;	call forthparse 
2196			;	call forthexec 
2196			;	 
2196			;	pop hl 
2196			;	if DEBUG_FORTH_WORDS 
2196			;		DMARK "EX5" 
2196			;		CALLMONITOR 
2196			;	endif 
2196			; 
2196			;	if FORTH_ENABLE_FREE 
2196			;	call free 
2196			;	endif 
2196			; 
2196			;	if DEBUG_FORTH_WORDS 
2196			;		DMARK "EX6" 
2196			;		CALLMONITOR 
2196			;	endif 
2196			; 
2196			;	pop bc 
2196			;	pop de 
2196			;	pop hl 
2196			;;	FORTH_RSP_POP	  
2196			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2196			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2196			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2196			; 
2196			;	if DEBUG_FORTH_WORDS 
2196			;		DMARK "EX7" 
2196			;		CALLMONITOR 
2196			;	endif 
2196			;	NEXTW 
2196			 
2196			.STKEXEC: 
2196				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2196 3f				db WORD_SYS_CORE+43             
2197 de 22			dw .ZDUP            
2199 08				db 7 + 1 
219a .. 00			db "STKEXEC",0              
21a2				endm 
# End of macro CWHEAD
21a2			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
21a2			 
21a2			 
21a2					if DEBUG_FORTH_WORDS_KEY 
21a2						DMARK "STX" 
21a2 f5				push af  
21a3 3a b7 21			ld a, (.dmark)  
21a6 32 bd fb			ld (debug_mark),a  
21a9 3a b8 21			ld a, (.dmark+1)  
21ac 32 be fb			ld (debug_mark+1),a  
21af 3a b9 21			ld a, (.dmark+2)  
21b2 32 bf fb			ld (debug_mark+2),a  
21b5 18 03			jr .pastdmark  
21b7 ..			.dmark: db "STX"  
21ba f1			.pastdmark: pop af  
21bb			endm  
# End of macro DMARK
21bb						CALLMONITOR 
21bb cd 6a 16			call break_point_state  
21be				endm  
# End of macro CALLMONITOR
21be					endif 
21be			 
21be				FORTH_DSP_VALUEHL 
21be cd f1 1d			call macro_dsp_valuehl 
21c1				endm 
# End of macro FORTH_DSP_VALUEHL
21c1			 
21c1 22 e6 f9			ld (store_tmp1), hl    ; count 
21c4			 
21c4				FORTH_DSP_POP 
21c4 cd a9 1e			call macro_forth_dsp_pop 
21c7				endm 
# End of macro FORTH_DSP_POP
21c7			.stkexec1: 
21c7 2a e6 f9			ld hl, (store_tmp1)   ; count 
21ca 3e 00			ld a, 0 
21cc bd				cp l 
21cd c8				ret z 
21ce			 
21ce 2b				dec hl 
21cf 22 e6 f9			ld (store_tmp1), hl    ; count 
21d2				 
21d2				FORTH_DSP_VALUEHL 
21d2 cd f1 1d			call macro_dsp_valuehl 
21d5				endm 
# End of macro FORTH_DSP_VALUEHL
21d5 e5				push hl 
21d6				 
21d6					if DEBUG_FORTH_WORDS 
21d6						DMARK "EXp" 
21d6 f5				push af  
21d7 3a eb 21			ld a, (.dmark)  
21da 32 bd fb			ld (debug_mark),a  
21dd 3a ec 21			ld a, (.dmark+1)  
21e0 32 be fb			ld (debug_mark+1),a  
21e3 3a ed 21			ld a, (.dmark+2)  
21e6 32 bf fb			ld (debug_mark+2),a  
21e9 18 03			jr .pastdmark  
21eb ..			.dmark: db "EXp"  
21ee f1			.pastdmark: pop af  
21ef			endm  
# End of macro DMARK
21ef						CALLMONITOR 
21ef cd 6a 16			call break_point_state  
21f2				endm  
# End of macro CALLMONITOR
21f2					endif 
21f2				FORTH_DSP_POP 
21f2 cd a9 1e			call macro_forth_dsp_pop 
21f5				endm 
# End of macro FORTH_DSP_POP
21f5			 
21f5 cd 64 11			call strlenz 
21f8 23				inc hl   ; include zero term to copy 
21f9 23				inc hl   ; include zero term to copy 
21fa 23				inc hl   ; include zero term to copy 
21fb 06 00			ld b,0 
21fd 4d				ld c,l 
21fe e1				pop hl 
21ff 11 a2 f0			ld de, execscratch 
2202					if DEBUG_FORTH_WORDS 
2202						DMARK "EX3" 
2202 f5				push af  
2203 3a 17 22			ld a, (.dmark)  
2206 32 bd fb			ld (debug_mark),a  
2209 3a 18 22			ld a, (.dmark+1)  
220c 32 be fb			ld (debug_mark+1),a  
220f 3a 19 22			ld a, (.dmark+2)  
2212 32 bf fb			ld (debug_mark+2),a  
2215 18 03			jr .pastdmark  
2217 ..			.dmark: db "EX3"  
221a f1			.pastdmark: pop af  
221b			endm  
# End of macro DMARK
221b						CALLMONITOR 
221b cd 6a 16			call break_point_state  
221e				endm  
# End of macro CALLMONITOR
221e					endif 
221e ed b0			ldir 
2220			 
2220			 
2220 21 a2 f0			ld hl, execscratch 
2223			 
2223					if DEBUG_FORTH_WORDS 
2223						DMARK "EXP" 
2223 f5				push af  
2224 3a 38 22			ld a, (.dmark)  
2227 32 bd fb			ld (debug_mark),a  
222a 3a 39 22			ld a, (.dmark+1)  
222d 32 be fb			ld (debug_mark+1),a  
2230 3a 3a 22			ld a, (.dmark+2)  
2233 32 bf fb			ld (debug_mark+2),a  
2236 18 03			jr .pastdmark  
2238 ..			.dmark: db "EXP"  
223b f1			.pastdmark: pop af  
223c			endm  
# End of macro DMARK
223c						CALLMONITOR 
223c cd 6a 16			call break_point_state  
223f				endm  
# End of macro CALLMONITOR
223f					endif 
223f			 
223f cd b1 1f			call forthparse 
2242 21 a2 f0			ld hl, execscratch 
2245					if DEBUG_FORTH_WORDS 
2245						DMARK "EXx" 
2245 f5				push af  
2246 3a 5a 22			ld a, (.dmark)  
2249 32 bd fb			ld (debug_mark),a  
224c 3a 5b 22			ld a, (.dmark+1)  
224f 32 be fb			ld (debug_mark+1),a  
2252 3a 5c 22			ld a, (.dmark+2)  
2255 32 bf fb			ld (debug_mark+2),a  
2258 18 03			jr .pastdmark  
225a ..			.dmark: db "EXx"  
225d f1			.pastdmark: pop af  
225e			endm  
# End of macro DMARK
225e						CALLMONITOR 
225e cd 6a 16			call break_point_state  
2261				endm  
# End of macro CALLMONITOR
2261					endif 
2261 cd f1 1f			call forthexec 
2264			 
2264 c3 c7 21			jp .stkexec1 
2267			 
2267 c9				ret 
2268			 
2268			 
2268			.DUP: 
2268				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2268 17				db WORD_SYS_CORE+OPCODE_DUP             
2269 de 22			dw .ZDUP            
226b 04				db 3 + 1 
226c .. 00			db "DUP",0              
2270				endm 
# End of macro CWHEAD
2270			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2270			 
2270					if DEBUG_FORTH_WORDS_KEY 
2270						DMARK "DUP" 
2270 f5				push af  
2271 3a 85 22			ld a, (.dmark)  
2274 32 bd fb			ld (debug_mark),a  
2277 3a 86 22			ld a, (.dmark+1)  
227a 32 be fb			ld (debug_mark+1),a  
227d 3a 87 22			ld a, (.dmark+2)  
2280 32 bf fb			ld (debug_mark+2),a  
2283 18 03			jr .pastdmark  
2285 ..			.dmark: db "DUP"  
2288 f1			.pastdmark: pop af  
2289			endm  
# End of macro DMARK
2289						CALLMONITOR 
2289 cd 6a 16			call break_point_state  
228c				endm  
# End of macro CALLMONITOR
228c					endif 
228c			 
228c					FORTH_DSP 
228c cd b7 1d			call macro_forth_dsp 
228f				endm 
# End of macro FORTH_DSP
228f			 
228f 7e					ld a, (HL) 
2290 fe 01				cp DS_TYPE_STR 
2292 20 25				jr nz, .dupinum 
2294			 
2294					; push another string 
2294			 
2294					FORTH_DSP_VALUEHL     		 
2294 cd f1 1d			call macro_dsp_valuehl 
2297				endm 
# End of macro FORTH_DSP_VALUEHL
2297			 
2297				if DEBUG_FORTH_WORDS 
2297					DMARK "DUs" 
2297 f5				push af  
2298 3a ac 22			ld a, (.dmark)  
229b 32 bd fb			ld (debug_mark),a  
229e 3a ad 22			ld a, (.dmark+1)  
22a1 32 be fb			ld (debug_mark+1),a  
22a4 3a ae 22			ld a, (.dmark+2)  
22a7 32 bf fb			ld (debug_mark+2),a  
22aa 18 03			jr .pastdmark  
22ac ..			.dmark: db "DUs"  
22af f1			.pastdmark: pop af  
22b0			endm  
# End of macro DMARK
22b0					CALLMONITOR 
22b0 cd 6a 16			call break_point_state  
22b3				endm  
# End of macro CALLMONITOR
22b3				endif 
22b3 cd 68 1c				call forth_push_str 
22b6			 
22b6					NEXTW 
22b6 c3 63 1f			jp macro_next 
22b9				endm 
# End of macro NEXTW
22b9			 
22b9			 
22b9			.dupinum: 
22b9					 
22b9			 
22b9			 
22b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22b9 cd f1 1d			call macro_dsp_valuehl 
22bc				endm 
# End of macro FORTH_DSP_VALUEHL
22bc			 
22bc				; TODO add floating point number detection 
22bc			 
22bc				if DEBUG_FORTH_WORDS 
22bc					DMARK "DUi" 
22bc f5				push af  
22bd 3a d1 22			ld a, (.dmark)  
22c0 32 bd fb			ld (debug_mark),a  
22c3 3a d2 22			ld a, (.dmark+1)  
22c6 32 be fb			ld (debug_mark+1),a  
22c9 3a d3 22			ld a, (.dmark+2)  
22cc 32 bf fb			ld (debug_mark+2),a  
22cf 18 03			jr .pastdmark  
22d1 ..			.dmark: db "DUi"  
22d4 f1			.pastdmark: pop af  
22d5			endm  
# End of macro DMARK
22d5					CALLMONITOR 
22d5 cd 6a 16			call break_point_state  
22d8				endm  
# End of macro CALLMONITOR
22d8				endif 
22d8			 
22d8 cd fa 1b				call forth_push_numhl 
22db					NEXTW 
22db c3 63 1f			jp macro_next 
22de				endm 
# End of macro NEXTW
22de			.ZDUP: 
22de				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
22de 99				db WORD_SYS_CORE+OPCODE_ZDUP             
22df 16 23			dw .SWAP            
22e1 05				db 4 + 1 
22e2 .. 00			db "?DUP",0              
22e7				endm 
# End of macro CWHEAD
22e7			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
22e7			 
22e7					if DEBUG_FORTH_WORDS_KEY 
22e7						DMARK "qDU" 
22e7 f5				push af  
22e8 3a fc 22			ld a, (.dmark)  
22eb 32 bd fb			ld (debug_mark),a  
22ee 3a fd 22			ld a, (.dmark+1)  
22f1 32 be fb			ld (debug_mark+1),a  
22f4 3a fe 22			ld a, (.dmark+2)  
22f7 32 bf fb			ld (debug_mark+2),a  
22fa 18 03			jr .pastdmark  
22fc ..			.dmark: db "qDU"  
22ff f1			.pastdmark: pop af  
2300			endm  
# End of macro DMARK
2300						CALLMONITOR 
2300 cd 6a 16			call break_point_state  
2303				endm  
# End of macro CALLMONITOR
2303					endif 
2303					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2303 cd f1 1d			call macro_dsp_valuehl 
2306				endm 
# End of macro FORTH_DSP_VALUEHL
2306			 
2306 e5					push hl 
2307			 
2307					; is it a zero? 
2307			 
2307 3e 00				ld a, 0 
2309 84					add h 
230a 85					add l 
230b			 
230b e1					pop hl 
230c			 
230c fe 00				cp 0 
230e 28 03				jr z, .dup2orig 
2310			 
2310			 
2310 cd fa 1b				call forth_push_numhl 
2313			 
2313			 
2313				; TODO add floating point number detection 
2313			 
2313			.dup2orig: 
2313			 
2313					NEXTW 
2313 c3 63 1f			jp macro_next 
2316				endm 
# End of macro NEXTW
2316			.SWAP: 
2316				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2316 18				db WORD_SYS_CORE+OPCODE_SWAP             
2317 55 23			dw .COLN            
2319 05				db 4 + 1 
231a .. 00			db "SWAP",0              
231f				endm 
# End of macro CWHEAD
231f			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
231f					if DEBUG_FORTH_WORDS_KEY 
231f						DMARK "SWP" 
231f f5				push af  
2320 3a 34 23			ld a, (.dmark)  
2323 32 bd fb			ld (debug_mark),a  
2326 3a 35 23			ld a, (.dmark+1)  
2329 32 be fb			ld (debug_mark+1),a  
232c 3a 36 23			ld a, (.dmark+2)  
232f 32 bf fb			ld (debug_mark+2),a  
2332 18 03			jr .pastdmark  
2334 ..			.dmark: db "SWP"  
2337 f1			.pastdmark: pop af  
2338			endm  
# End of macro DMARK
2338						CALLMONITOR 
2338 cd 6a 16			call break_point_state  
233b				endm  
# End of macro CALLMONITOR
233b					endif 
233b			 
233b					FORTH_DSP_VALUEHL 
233b cd f1 1d			call macro_dsp_valuehl 
233e				endm 
# End of macro FORTH_DSP_VALUEHL
233e e5					push hl     ; w2 
233f			 
233f					FORTH_DSP_POP 
233f cd a9 1e			call macro_forth_dsp_pop 
2342				endm 
# End of macro FORTH_DSP_POP
2342			 
2342					FORTH_DSP_VALUEHL 
2342 cd f1 1d			call macro_dsp_valuehl 
2345				endm 
# End of macro FORTH_DSP_VALUEHL
2345			 
2345					FORTH_DSP_POP 
2345 cd a9 1e			call macro_forth_dsp_pop 
2348				endm 
# End of macro FORTH_DSP_POP
2348			 
2348 d1					pop de     ; w2	, hl = w1 
2349			 
2349 eb					ex de, hl 
234a d5					push de 
234b			 
234b cd fa 1b				call forth_push_numhl 
234e			 
234e e1					pop hl 
234f			 
234f cd fa 1b				call forth_push_numhl 
2352					 
2352			 
2352					NEXTW 
2352 c3 63 1f			jp macro_next 
2355				endm 
# End of macro NEXTW
2355			.COLN: 
2355				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2355 19				db WORD_SYS_CORE+OPCODE_COLN             
2356 e1 24			dw .SCOLN            
2358 02				db 1 + 1 
2359 .. 00			db ":",0              
235b				endm 
# End of macro CWHEAD
235b			; | : ( -- )         Create new word | DONE 
235b			 
235b					if DEBUG_FORTH_WORDS_KEY 
235b						DMARK "CLN" 
235b f5				push af  
235c 3a 70 23			ld a, (.dmark)  
235f 32 bd fb			ld (debug_mark),a  
2362 3a 71 23			ld a, (.dmark+1)  
2365 32 be fb			ld (debug_mark+1),a  
2368 3a 72 23			ld a, (.dmark+2)  
236b 32 bf fb			ld (debug_mark+2),a  
236e 18 03			jr .pastdmark  
2370 ..			.dmark: db "CLN"  
2373 f1			.pastdmark: pop af  
2374			endm  
# End of macro DMARK
2374						CALLMONITOR 
2374 cd 6a 16			call break_point_state  
2377				endm  
# End of macro CALLMONITOR
2377					endif 
2377				STACKFRAME OFF $8efe $989f 
2377				if DEBUG_STACK_IMB 
2377					if OFF 
2377						exx 
2377						ld de, $8efe 
2377						ld a, d 
2377						ld hl, curframe 
2377						call hexout 
2377						ld a, e 
2377						ld hl, curframe+2 
2377						call hexout 
2377						ld hl, $8efe 
2377						push hl 
2377						ld hl, $989f 
2377						push hl 
2377						exx 
2377					endif 
2377				endif 
2377			endm 
# End of macro STACKFRAME
2377				; get parser buffer length  of new word 
2377			 
2377				 
2377			 
2377					; move tok past this to start of name defintition 
2377					; TODO get word to define 
2377					; TODO Move past word token 
2377					; TODO get length of string up to the ';' 
2377			 
2377 2a a4 f2			ld hl, (os_tok_ptr) 
237a 23				inc hl 
237b 23				inc hl 
237c			 
237c 3e 3b			ld a, ';' 
237e cd 6f 11			call strlent 
2381			 
2381 7d				ld a,l 
2382 32 9f ef			ld (os_new_parse_len), a 
2385			 
2385			 
2385			if DEBUG_FORTH_UWORD 
2385 ed 5b a4 f2		ld de, (os_tok_ptr) 
2389						DMARK ":01" 
2389 f5				push af  
238a 3a 9e 23			ld a, (.dmark)  
238d 32 bd fb			ld (debug_mark),a  
2390 3a 9f 23			ld a, (.dmark+1)  
2393 32 be fb			ld (debug_mark+1),a  
2396 3a a0 23			ld a, (.dmark+2)  
2399 32 bf fb			ld (debug_mark+2),a  
239c 18 03			jr .pastdmark  
239e ..			.dmark: db ":01"  
23a1 f1			.pastdmark: pop af  
23a2			endm  
# End of macro DMARK
23a2				CALLMONITOR 
23a2 cd 6a 16			call break_point_state  
23a5				endm  
# End of macro CALLMONITOR
23a5			endif 
23a5			 
23a5			; 
23a5			;  new word memory layout: 
23a5			;  
23a5			;    : adg 6666 ;  
23a5			; 
23a5			;    db   1     ; user defined word  
23a5 23				inc hl    
23a6			;    dw   sysdict 
23a6 23				inc hl 
23a7 23				inc hl 
23a8			;    db <word len>+1 (for null) 
23a8 23				inc hl 
23a9			;    db .... <word> 
23a9			; 
23a9			 
23a9 23				inc hl    ; some extras for the word preamble before the above 
23aa 23				inc hl 
23ab 23				inc hl 
23ac 23				inc hl 
23ad 23				inc hl 
23ae 23				inc hl 
23af 23				inc hl  
23b0 23				inc hl 
23b1 23				inc hl 
23b2 23				inc hl 
23b3 23				inc hl 
23b4 23				inc hl 
23b5 23				inc hl 
23b6 23				inc hl     ; TODO how many do we really need?     maybe only 6 
23b7			;       exec word buffer 
23b7			;	<ptr word>   
23b7 23				inc hl 
23b8 23				inc hl 
23b9			;       <word list><null term> 7F final term 
23b9			 
23b9			 
23b9			if DEBUG_FORTH_UWORD 
23b9						DMARK ":02" 
23b9 f5				push af  
23ba 3a ce 23			ld a, (.dmark)  
23bd 32 bd fb			ld (debug_mark),a  
23c0 3a cf 23			ld a, (.dmark+1)  
23c3 32 be fb			ld (debug_mark+1),a  
23c6 3a d0 23			ld a, (.dmark+2)  
23c9 32 bf fb			ld (debug_mark+2),a  
23cc 18 03			jr .pastdmark  
23ce ..			.dmark: db ":02"  
23d1 f1			.pastdmark: pop af  
23d2			endm  
# End of macro DMARK
23d2				CALLMONITOR 
23d2 cd 6a 16			call break_point_state  
23d5				endm  
# End of macro CALLMONITOR
23d5			endif 
23d5			 
23d5				 
23d5					; malloc the size 
23d5			 
23d5 cd cd 11				call malloc 
23d8 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
23db			 
23db			;    db   1     ; user defined word  
23db 3e 01				ld a, WORD_SYS_UWORD  
23dd 77					ld (hl), a 
23de				 
23de 23				inc hl    
23df			;    dw   sysdict 
23df 11 bb 20			ld de, sysdict       ; continue on with the scan to the system dict 
23e2 73				ld (hl), e 
23e3 23				inc hl 
23e4 72				ld (hl), d 
23e5 23				inc hl 
23e6			 
23e6			 
23e6			;    Setup dict word 
23e6			 
23e6 23				inc hl 
23e7 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
23ea			 
23ea				; 1. get length of dict word 
23ea			 
23ea			 
23ea 2a a4 f2			ld hl, (os_tok_ptr) 
23ed 23				inc hl 
23ee 23				inc hl    ; position to start of dict word 
23ef 3e 00			ld a, 0 
23f1 cd 6f 11			call strlent 
23f4			 
23f4			 
23f4 23				inc hl    ; to include null??? 
23f5			 
23f5				; write length of dict word 
23f5			 
23f5 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23f9 1b				dec de 
23fa eb				ex de, hl 
23fb 73				ld (hl), e 
23fc eb				ex de, hl 
23fd			 
23fd				 
23fd			 
23fd				; copy  
23fd 4d				ld c, l 
23fe 06 00			ld b, 0 
2400 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2404 2a a4 f2			ld hl, (os_tok_ptr) 
2407 23				inc hl 
2408 23				inc hl    ; position to start of dict word 
2409				 
2409			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2409				 
2409				; TODO need to convert word to upper case 
2409			 
2409			ucasetok:	 
2409 7e				ld a,(hl) 
240a cd 5b 11			call toUpper 
240d 77				ld (hl),a 
240e ed a0			ldi 
2410 f2 09 24		 	jp p, ucasetok 
2413			 
2413			 
2413			 
2413				; de now points to start of where the word body code should be placed 
2413 ed 53 9b ef		ld (os_new_work_ptr), de 
2417				; hl now points to the words to throw at forthexec which needs to be copied 
2417 22 99 ef			ld (os_new_src_ptr), hl 
241a			 
241a				; TODO add 'call to forthexec' 
241a			 
241a			if DEBUG_FORTH_UWORD 
241a c5				push bc 
241b ed 4b a1 ef		ld bc, (os_new_malloc) 
241f						DMARK ":0x" 
241f f5				push af  
2420 3a 34 24			ld a, (.dmark)  
2423 32 bd fb			ld (debug_mark),a  
2426 3a 35 24			ld a, (.dmark+1)  
2429 32 be fb			ld (debug_mark+1),a  
242c 3a 36 24			ld a, (.dmark+2)  
242f 32 bf fb			ld (debug_mark+2),a  
2432 18 03			jr .pastdmark  
2434 ..			.dmark: db ":0x"  
2437 f1			.pastdmark: pop af  
2438			endm  
# End of macro DMARK
2438				CALLMONITOR 
2438 cd 6a 16			call break_point_state  
243b				endm  
# End of macro CALLMONITOR
243b c1				pop bc 
243c			endif 
243c			 
243c			 
243c				; create word preamble which should be: 
243c			 
243c			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
243c			 
243c				;    ld hl, <word code> 
243c				;    jp user_exec 
243c			        ;    <word code bytes> 
243c			 
243c			 
243c			;	inc de     ; TODO ??? or are we already past the word's null 
243c eb				ex de, hl 
243d			 
243d 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
243f			 
243f 23				inc hl 
2440 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2443 23				inc hl 
2444			 
2444 23				inc hl 
2445 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2447			 
2447 01 24 51			ld bc, user_exec 
244a 23				inc hl 
244b 71				ld (hl), c     ; poke address of user_exec 
244c 23				inc hl 
244d 70				ld (hl), b     
244e			 ; 
244e			;	inc hl 
244e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
244e			; 
244e			; 
244e			;	ld bc, macro_forth_rsp_next 
244e			;	inc hl 
244e			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
244e			;	inc hl 
244e			;	ld (hl), b     
244e			 ; 
244e			;	inc hl 
244e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
244e			; 
244e			; 
244e			;	inc hl 
244e			;	ld bc, forthexec 
244e			;	ld (hl), c     ; poke address of forthexec 
244e			;	inc hl 
244e			;	ld (hl), b      
244e			; 
244e			;	inc hl 
244e			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
244e			; 
244e			;	ld bc, user_dict_next 
244e			;	inc hl 
244e			;	ld (hl), c     ; poke address of forthexec 
244e			;	inc hl 
244e			;	ld (hl), b      
244e			 
244e				; hl is now where we need to copy the word byte data to save this 
244e			 
244e 23				inc hl 
244f 22 97 ef			ld (os_new_exec), hl 
2452				 
2452				; copy definition 
2452			 
2452 eb				ex de, hl 
2453			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2453			;	inc de    ; skip the PC for this parse 
2453 3a 9f ef			ld a, (os_new_parse_len) 
2456 4f				ld c, a 
2457 06 00			ld b, 0 
2459 ed b0			ldir		 ; copy defintion 
245b			 
245b			 
245b				; poke the address of where the new word bytes live for forthexec 
245b			 
245b 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
245e			 
245e ed 5b 97 ef		ld de, (os_new_exec)      
2462				 
2462 73				ld (hl), e 
2463 23				inc hl 
2464 72				ld (hl), d 
2465			 
2465					; TODO copy last user dict word next link to this word 
2465					; TODO update last user dict word to point to this word 
2465			; 
2465			; hl f923 de 812a ; bc 811a 
2465			 
2465			if DEBUG_FORTH_UWORD 
2465 c5				push bc 
2466 ed 4b a1 ef		ld bc, (os_new_malloc) 
246a						DMARK ":0A" 
246a f5				push af  
246b 3a 7f 24			ld a, (.dmark)  
246e 32 bd fb			ld (debug_mark),a  
2471 3a 80 24			ld a, (.dmark+1)  
2474 32 be fb			ld (debug_mark+1),a  
2477 3a 81 24			ld a, (.dmark+2)  
247a 32 bf fb			ld (debug_mark+2),a  
247d 18 03			jr .pastdmark  
247f ..			.dmark: db ":0A"  
2482 f1			.pastdmark: pop af  
2483			endm  
# End of macro DMARK
2483				CALLMONITOR 
2483 cd 6a 16			call break_point_state  
2486				endm  
# End of macro CALLMONITOR
2486 c1				pop bc 
2487			endif 
2487			if DEBUG_FORTH_UWORD 
2487 c5				push bc 
2488 ed 4b a1 ef		ld bc, (os_new_malloc) 
248c 03				inc bc 
248d 03				inc bc 
248e 03				inc bc 
248f 03				inc bc 
2490 03				inc bc 
2491 03				inc bc 
2492 03				inc bc 
2493 03				inc bc 
2494			 
2494						DMARK ":0B" 
2494 f5				push af  
2495 3a a9 24			ld a, (.dmark)  
2498 32 bd fb			ld (debug_mark),a  
249b 3a aa 24			ld a, (.dmark+1)  
249e 32 be fb			ld (debug_mark+1),a  
24a1 3a ab 24			ld a, (.dmark+2)  
24a4 32 bf fb			ld (debug_mark+2),a  
24a7 18 03			jr .pastdmark  
24a9 ..			.dmark: db ":0B"  
24ac f1			.pastdmark: pop af  
24ad			endm  
# End of macro DMARK
24ad				CALLMONITOR 
24ad cd 6a 16			call break_point_state  
24b0				endm  
# End of macro CALLMONITOR
24b0 c1				pop bc 
24b1			endif 
24b1			 
24b1			; update word dict linked list for new word 
24b1			 
24b1			 
24b1 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
24b4 23			inc hl     ; move to next work linked list ptr 
24b5			 
24b5 ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
24b9 73			ld (hl), e 
24ba 23			inc hl 
24bb 72			ld (hl), d 
24bc			 
24bc			if DEBUG_FORTH_UWORD 
24bc ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
24c0			endif 
24c0			 
24c0 ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
24c4			 
24c4			 
24c4			if DEBUG_FORTH_UWORD 
24c4						DMARK ":0+" 
24c4 f5				push af  
24c5 3a d9 24			ld a, (.dmark)  
24c8 32 bd fb			ld (debug_mark),a  
24cb 3a da 24			ld a, (.dmark+1)  
24ce 32 be fb			ld (debug_mark+1),a  
24d1 3a db 24			ld a, (.dmark+2)  
24d4 32 bf fb			ld (debug_mark+2),a  
24d7 18 03			jr .pastdmark  
24d9 ..			.dmark: db ":0+"  
24dc f1			.pastdmark: pop af  
24dd			endm  
# End of macro DMARK
24dd				CALLMONITOR 
24dd cd 6a 16			call break_point_state  
24e0				endm  
# End of macro CALLMONITOR
24e0			endif 
24e0			 
24e0				STACKFRAMECHK OFF $8efe $989f 
24e0				if DEBUG_STACK_IMB 
24e0					if OFF 
24e0						exx 
24e0						ld hl, $989f 
24e0						pop de   ; $989f 
24e0						call cmp16 
24e0						jr nz, .spnosame 
24e0						ld hl, $8efe 
24e0						pop de   ; $8efe 
24e0						call cmp16 
24e0						jr z, .spfrsame 
24e0						.spnosame: call showsperror 
24e0						.spfrsame: nop 
24e0						exx 
24e0					endif 
24e0				endif 
24e0			endm 
# End of macro STACKFRAMECHK
24e0			 
24e0 c9			ret    ; dont process any remaining parser tokens as they form new word 
24e1			 
24e1			 
24e1			 
24e1			 
24e1			;		NEXT 
24e1			.SCOLN: 
24e1			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
24e1 06				db OPCODE_SCOLN 
24e2 2d 25			dw .DROP 
24e4 02				db 2 
24e5 .. 00			db ";",0           
24e7			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
24e7					if DEBUG_FORTH_WORDS_KEY 
24e7						DMARK "SCN" 
24e7 f5				push af  
24e8 3a fc 24			ld a, (.dmark)  
24eb 32 bd fb			ld (debug_mark),a  
24ee 3a fd 24			ld a, (.dmark+1)  
24f1 32 be fb			ld (debug_mark+1),a  
24f4 3a fe 24			ld a, (.dmark+2)  
24f7 32 bf fb			ld (debug_mark+2),a  
24fa 18 03			jr .pastdmark  
24fc ..			.dmark: db "SCN"  
24ff f1			.pastdmark: pop af  
2500			endm  
# End of macro DMARK
2500						CALLMONITOR 
2500 cd 6a 16			call break_point_state  
2503				endm  
# End of macro CALLMONITOR
2503					endif 
2503					FORTH_RSP_TOS 
2503 cd b8 1b			call macro_forth_rsp_tos 
2506				endm 
# End of macro FORTH_RSP_TOS
2506 e5					push hl 
2507					FORTH_RSP_POP 
2507 cd c2 1b			call macro_forth_rsp_pop 
250a				endm 
# End of macro FORTH_RSP_POP
250a e1					pop hl 
250b			;		ex de,hl 
250b 22 a4 f2				ld (os_tok_ptr),hl 
250e			 
250e			if DEBUG_FORTH_UWORD 
250e						DMARK "SCL" 
250e f5				push af  
250f 3a 23 25			ld a, (.dmark)  
2512 32 bd fb			ld (debug_mark),a  
2515 3a 24 25			ld a, (.dmark+1)  
2518 32 be fb			ld (debug_mark+1),a  
251b 3a 25 25			ld a, (.dmark+2)  
251e 32 bf fb			ld (debug_mark+2),a  
2521 18 03			jr .pastdmark  
2523 ..			.dmark: db "SCL"  
2526 f1			.pastdmark: pop af  
2527			endm  
# End of macro DMARK
2527				CALLMONITOR 
2527 cd 6a 16			call break_point_state  
252a				endm  
# End of macro CALLMONITOR
252a			endif 
252a					NEXTW 
252a c3 63 1f			jp macro_next 
252d				endm 
# End of macro NEXTW
252d			 
252d			.DROP: 
252d				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
252d 1b				db WORD_SYS_CORE+OPCODE_DROP             
252e 58 25			dw .DUP2            
2530 05				db 4 + 1 
2531 .. 00			db "DROP",0              
2536				endm 
# End of macro CWHEAD
2536			; | DROP ( w -- )   drop the TOS item   | DONE 
2536					if DEBUG_FORTH_WORDS_KEY 
2536						DMARK "DRP" 
2536 f5				push af  
2537 3a 4b 25			ld a, (.dmark)  
253a 32 bd fb			ld (debug_mark),a  
253d 3a 4c 25			ld a, (.dmark+1)  
2540 32 be fb			ld (debug_mark+1),a  
2543 3a 4d 25			ld a, (.dmark+2)  
2546 32 bf fb			ld (debug_mark+2),a  
2549 18 03			jr .pastdmark  
254b ..			.dmark: db "DRP"  
254e f1			.pastdmark: pop af  
254f			endm  
# End of macro DMARK
254f						CALLMONITOR 
254f cd 6a 16			call break_point_state  
2552				endm  
# End of macro CALLMONITOR
2552					endif 
2552					FORTH_DSP_POP 
2552 cd a9 1e			call macro_forth_dsp_pop 
2555				endm 
# End of macro FORTH_DSP_POP
2555					NEXTW 
2555 c3 63 1f			jp macro_next 
2558				endm 
# End of macro NEXTW
2558			.DUP2: 
2558				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2558 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2559 9d 25			dw .DROP2            
255b 05				db 4 + 1 
255c .. 00			db "2DUP",0              
2561				endm 
# End of macro CWHEAD
2561			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2561					if DEBUG_FORTH_WORDS_KEY 
2561						DMARK "2DU" 
2561 f5				push af  
2562 3a 76 25			ld a, (.dmark)  
2565 32 bd fb			ld (debug_mark),a  
2568 3a 77 25			ld a, (.dmark+1)  
256b 32 be fb			ld (debug_mark+1),a  
256e 3a 78 25			ld a, (.dmark+2)  
2571 32 bf fb			ld (debug_mark+2),a  
2574 18 03			jr .pastdmark  
2576 ..			.dmark: db "2DU"  
2579 f1			.pastdmark: pop af  
257a			endm  
# End of macro DMARK
257a						CALLMONITOR 
257a cd 6a 16			call break_point_state  
257d				endm  
# End of macro CALLMONITOR
257d					endif 
257d					FORTH_DSP_VALUEHL 
257d cd f1 1d			call macro_dsp_valuehl 
2580				endm 
# End of macro FORTH_DSP_VALUEHL
2580 e5					push hl      ; 2 
2581			 
2581					FORTH_DSP_POP 
2581 cd a9 1e			call macro_forth_dsp_pop 
2584				endm 
# End of macro FORTH_DSP_POP
2584					 
2584					FORTH_DSP_VALUEHL 
2584 cd f1 1d			call macro_dsp_valuehl 
2587				endm 
# End of macro FORTH_DSP_VALUEHL
2587			;		push hl      ; 1 
2587			 
2587					FORTH_DSP_POP 
2587 cd a9 1e			call macro_forth_dsp_pop 
258a				endm 
# End of macro FORTH_DSP_POP
258a			 
258a			;		pop hl       ; 1 
258a d1					pop de       ; 2 
258b			 
258b cd fa 1b				call forth_push_numhl 
258e eb					ex de, hl 
258f cd fa 1b				call forth_push_numhl 
2592			 
2592					 
2592 eb					ex de, hl 
2593			 
2593 cd fa 1b				call forth_push_numhl 
2596 eb					ex de, hl 
2597 cd fa 1b				call forth_push_numhl 
259a			 
259a			 
259a					NEXTW 
259a c3 63 1f			jp macro_next 
259d				endm 
# End of macro NEXTW
259d			.DROP2: 
259d				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
259d 1d				db WORD_SYS_CORE+OPCODE_DROP2             
259e cc 25			dw .SWAP2            
25a0 06				db 5 + 1 
25a1 .. 00			db "2DROP",0              
25a7				endm 
# End of macro CWHEAD
25a7			; | 2DROP ( w w -- )    Double drop | DONE 
25a7					if DEBUG_FORTH_WORDS_KEY 
25a7						DMARK "2DR" 
25a7 f5				push af  
25a8 3a bc 25			ld a, (.dmark)  
25ab 32 bd fb			ld (debug_mark),a  
25ae 3a bd 25			ld a, (.dmark+1)  
25b1 32 be fb			ld (debug_mark+1),a  
25b4 3a be 25			ld a, (.dmark+2)  
25b7 32 bf fb			ld (debug_mark+2),a  
25ba 18 03			jr .pastdmark  
25bc ..			.dmark: db "2DR"  
25bf f1			.pastdmark: pop af  
25c0			endm  
# End of macro DMARK
25c0						CALLMONITOR 
25c0 cd 6a 16			call break_point_state  
25c3				endm  
# End of macro CALLMONITOR
25c3					endif 
25c3					FORTH_DSP_POP 
25c3 cd a9 1e			call macro_forth_dsp_pop 
25c6				endm 
# End of macro FORTH_DSP_POP
25c6					FORTH_DSP_POP 
25c6 cd a9 1e			call macro_forth_dsp_pop 
25c9				endm 
# End of macro FORTH_DSP_POP
25c9					NEXTW 
25c9 c3 63 1f			jp macro_next 
25cc				endm 
# End of macro NEXTW
25cc			.SWAP2: 
25cc				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
25cc 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
25cd f5 25			dw .AT            
25cf 06				db 5 + 1 
25d0 .. 00			db "2SWAP",0              
25d6				endm 
# End of macro CWHEAD
25d6			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
25d6					if DEBUG_FORTH_WORDS_KEY 
25d6						DMARK "2SW" 
25d6 f5				push af  
25d7 3a eb 25			ld a, (.dmark)  
25da 32 bd fb			ld (debug_mark),a  
25dd 3a ec 25			ld a, (.dmark+1)  
25e0 32 be fb			ld (debug_mark+1),a  
25e3 3a ed 25			ld a, (.dmark+2)  
25e6 32 bf fb			ld (debug_mark+2),a  
25e9 18 03			jr .pastdmark  
25eb ..			.dmark: db "2SW"  
25ee f1			.pastdmark: pop af  
25ef			endm  
# End of macro DMARK
25ef						CALLMONITOR 
25ef cd 6a 16			call break_point_state  
25f2				endm  
# End of macro CALLMONITOR
25f2					endif 
25f2					NEXTW 
25f2 c3 63 1f			jp macro_next 
25f5				endm 
# End of macro NEXTW
25f5			.AT: 
25f5				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
25f5 1f				db WORD_SYS_CORE+OPCODE_AT             
25f6 27 26			dw .CAT            
25f8 02				db 1 + 1 
25f9 .. 00			db "@",0              
25fb				endm 
# End of macro CWHEAD
25fb			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
25fb			 
25fb					if DEBUG_FORTH_WORDS_KEY 
25fb						DMARK "AT." 
25fb f5				push af  
25fc 3a 10 26			ld a, (.dmark)  
25ff 32 bd fb			ld (debug_mark),a  
2602 3a 11 26			ld a, (.dmark+1)  
2605 32 be fb			ld (debug_mark+1),a  
2608 3a 12 26			ld a, (.dmark+2)  
260b 32 bf fb			ld (debug_mark+2),a  
260e 18 03			jr .pastdmark  
2610 ..			.dmark: db "AT."  
2613 f1			.pastdmark: pop af  
2614			endm  
# End of macro DMARK
2614						CALLMONITOR 
2614 cd 6a 16			call break_point_state  
2617				endm  
# End of macro CALLMONITOR
2617					endif 
2617			.getbyteat:	 
2617					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2617 cd f1 1d			call macro_dsp_valuehl 
261a				endm 
# End of macro FORTH_DSP_VALUEHL
261a					 
261a			;		push hl 
261a				 
261a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261a cd a9 1e			call macro_forth_dsp_pop 
261d				endm 
# End of macro FORTH_DSP_POP
261d			 
261d			;		pop hl 
261d			 
261d 7e					ld a, (hl) 
261e			 
261e 6f					ld l, a 
261f 26 00				ld h, 0 
2621 cd fa 1b				call forth_push_numhl 
2624			 
2624					NEXTW 
2624 c3 63 1f			jp macro_next 
2627				endm 
# End of macro NEXTW
2627			.CAT: 
2627				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2627 20				db WORD_SYS_CORE+OPCODE_CAT             
2628 50 26			dw .BANG            
262a 03				db 2 + 1 
262b .. 00			db "C@",0              
262e				endm 
# End of macro CWHEAD
262e			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
262e					if DEBUG_FORTH_WORDS_KEY 
262e						DMARK "CAA" 
262e f5				push af  
262f 3a 43 26			ld a, (.dmark)  
2632 32 bd fb			ld (debug_mark),a  
2635 3a 44 26			ld a, (.dmark+1)  
2638 32 be fb			ld (debug_mark+1),a  
263b 3a 45 26			ld a, (.dmark+2)  
263e 32 bf fb			ld (debug_mark+2),a  
2641 18 03			jr .pastdmark  
2643 ..			.dmark: db "CAA"  
2646 f1			.pastdmark: pop af  
2647			endm  
# End of macro DMARK
2647						CALLMONITOR 
2647 cd 6a 16			call break_point_state  
264a				endm  
# End of macro CALLMONITOR
264a					endif 
264a c3 17 26				jp .getbyteat 
264d					NEXTW 
264d c3 63 1f			jp macro_next 
2650				endm 
# End of macro NEXTW
2650			.BANG: 
2650				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2650 21				db WORD_SYS_CORE+OPCODE_BANG             
2651 86 26			dw .CBANG            
2653 02				db 1 + 1 
2654 .. 00			db "!",0              
2656				endm 
# End of macro CWHEAD
2656			; | ! ( x w -- ) Store x at address w      | DONE 
2656					if DEBUG_FORTH_WORDS_KEY 
2656						DMARK "BNG" 
2656 f5				push af  
2657 3a 6b 26			ld a, (.dmark)  
265a 32 bd fb			ld (debug_mark),a  
265d 3a 6c 26			ld a, (.dmark+1)  
2660 32 be fb			ld (debug_mark+1),a  
2663 3a 6d 26			ld a, (.dmark+2)  
2666 32 bf fb			ld (debug_mark+2),a  
2669 18 03			jr .pastdmark  
266b ..			.dmark: db "BNG"  
266e f1			.pastdmark: pop af  
266f			endm  
# End of macro DMARK
266f						CALLMONITOR 
266f cd 6a 16			call break_point_state  
2672				endm  
# End of macro CALLMONITOR
2672					endif 
2672			 
2672			.storebyteat:		 
2672					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2672 cd f1 1d			call macro_dsp_valuehl 
2675				endm 
# End of macro FORTH_DSP_VALUEHL
2675					 
2675 e5					push hl 
2676				 
2676					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2676 cd a9 1e			call macro_forth_dsp_pop 
2679				endm 
# End of macro FORTH_DSP_POP
2679			 
2679					; get byte to poke 
2679			 
2679					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2679 cd f1 1d			call macro_dsp_valuehl 
267c				endm 
# End of macro FORTH_DSP_VALUEHL
267c e5					push hl 
267d			 
267d			 
267d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
267d cd a9 1e			call macro_forth_dsp_pop 
2680				endm 
# End of macro FORTH_DSP_POP
2680			 
2680			 
2680 d1					pop de 
2681 e1					pop hl 
2682			 
2682 73					ld (hl),e 
2683			 
2683			 
2683					NEXTW 
2683 c3 63 1f			jp macro_next 
2686				endm 
# End of macro NEXTW
2686			.CBANG: 
2686				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2686 22				db WORD_SYS_CORE+OPCODE_CBANG             
2687 af 26			dw .SCALL            
2689 03				db 2 + 1 
268a .. 00			db "C!",0              
268d				endm 
# End of macro CWHEAD
268d			; | C!  ( x w -- ) Store x at address w  | DONE 
268d					if DEBUG_FORTH_WORDS_KEY 
268d						DMARK "CBA" 
268d f5				push af  
268e 3a a2 26			ld a, (.dmark)  
2691 32 bd fb			ld (debug_mark),a  
2694 3a a3 26			ld a, (.dmark+1)  
2697 32 be fb			ld (debug_mark+1),a  
269a 3a a4 26			ld a, (.dmark+2)  
269d 32 bf fb			ld (debug_mark+2),a  
26a0 18 03			jr .pastdmark  
26a2 ..			.dmark: db "CBA"  
26a5 f1			.pastdmark: pop af  
26a6			endm  
# End of macro DMARK
26a6						CALLMONITOR 
26a6 cd 6a 16			call break_point_state  
26a9				endm  
# End of macro CALLMONITOR
26a9					endif 
26a9 c3 72 26				jp .storebyteat 
26ac					NEXTW 
26ac c3 63 1f			jp macro_next 
26af				endm 
# End of macro NEXTW
26af			.SCALL: 
26af				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
26af 23				db WORD_SYS_CORE+OPCODE_SCALL             
26b0 e3 26			dw .DEPTH            
26b2 05				db 4 + 1 
26b3 .. 00			db "CALL",0              
26b8				endm 
# End of macro CWHEAD
26b8			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
26b8					if DEBUG_FORTH_WORDS_KEY 
26b8						DMARK "CLL" 
26b8 f5				push af  
26b9 3a cd 26			ld a, (.dmark)  
26bc 32 bd fb			ld (debug_mark),a  
26bf 3a ce 26			ld a, (.dmark+1)  
26c2 32 be fb			ld (debug_mark+1),a  
26c5 3a cf 26			ld a, (.dmark+2)  
26c8 32 bf fb			ld (debug_mark+2),a  
26cb 18 03			jr .pastdmark  
26cd ..			.dmark: db "CLL"  
26d0 f1			.pastdmark: pop af  
26d1			endm  
# End of macro DMARK
26d1						CALLMONITOR 
26d1 cd 6a 16			call break_point_state  
26d4				endm  
# End of macro CALLMONITOR
26d4					endif 
26d4			 
26d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d4 cd f1 1d			call macro_dsp_valuehl 
26d7				endm 
# End of macro FORTH_DSP_VALUEHL
26d7			 
26d7			;		push hl 
26d7			 
26d7					; destroy value TOS 
26d7			 
26d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26d7 cd a9 1e			call macro_forth_dsp_pop 
26da				endm 
# End of macro FORTH_DSP_POP
26da			 
26da						 
26da			;		pop hl 
26da			 
26da					; how to do a call with hl???? save SP? 
26da cd 0c 1f				call forth_call_hl 
26dd			 
26dd			 
26dd					; TODO push value back onto stack for another op etc 
26dd			 
26dd cd fa 1b				call forth_push_numhl 
26e0					NEXTW 
26e0 c3 63 1f			jp macro_next 
26e3				endm 
# End of macro NEXTW
26e3			.DEPTH: 
26e3				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
26e3 24				db WORD_SYS_CORE+OPCODE_DEPTH             
26e4 20 27			dw .OVER            
26e6 06				db 5 + 1 
26e7 .. 00			db "DEPTH",0              
26ed				endm 
# End of macro CWHEAD
26ed			; | DEPTH ( -- u ) Push count of stack | DONE 
26ed					; take current TOS and remove from base value div by two to get count 
26ed					if DEBUG_FORTH_WORDS_KEY 
26ed						DMARK "DEP" 
26ed f5				push af  
26ee 3a 02 27			ld a, (.dmark)  
26f1 32 bd fb			ld (debug_mark),a  
26f4 3a 03 27			ld a, (.dmark+1)  
26f7 32 be fb			ld (debug_mark+1),a  
26fa 3a 04 27			ld a, (.dmark+2)  
26fd 32 bf fb			ld (debug_mark+2),a  
2700 18 03			jr .pastdmark  
2702 ..			.dmark: db "DEP"  
2705 f1			.pastdmark: pop af  
2706			endm  
# End of macro DMARK
2706						CALLMONITOR 
2706 cd 6a 16			call break_point_state  
2709				endm  
# End of macro CALLMONITOR
2709					endif 
2709			 
2709			 
2709 2a 90 f9			ld hl, (cli_data_sp) 
270c 11 0a f5			ld de, cli_data_stack 
270f ed 52			sbc hl,de 
2711				 
2711				; div by size of stack item 
2711			 
2711 5d				ld e,l 
2712 0e 03			ld c, 3 
2714 cd 96 0c			call Div8 
2717			 
2717 6f				ld l,a 
2718 26 00			ld h,0 
271a			 
271a				;srl h 
271a				;rr l 
271a			 
271a cd fa 1b				call forth_push_numhl 
271d					NEXTW 
271d c3 63 1f			jp macro_next 
2720				endm 
# End of macro NEXTW
2720			.OVER: 
2720				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2720 42				db WORD_SYS_CORE+46             
2721 67 27			dw .PAUSE            
2723 05				db 4 + 1 
2724 .. 00			db "OVER",0              
2729				endm 
# End of macro CWHEAD
2729			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2729					if DEBUG_FORTH_WORDS_KEY 
2729						DMARK "OVR" 
2729 f5				push af  
272a 3a 3e 27			ld a, (.dmark)  
272d 32 bd fb			ld (debug_mark),a  
2730 3a 3f 27			ld a, (.dmark+1)  
2733 32 be fb			ld (debug_mark+1),a  
2736 3a 40 27			ld a, (.dmark+2)  
2739 32 bf fb			ld (debug_mark+2),a  
273c 18 03			jr .pastdmark  
273e ..			.dmark: db "OVR"  
2741 f1			.pastdmark: pop af  
2742			endm  
# End of macro DMARK
2742						CALLMONITOR 
2742 cd 6a 16			call break_point_state  
2745				endm  
# End of macro CALLMONITOR
2745					endif 
2745			 
2745					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2745 cd f1 1d			call macro_dsp_valuehl 
2748				endm 
# End of macro FORTH_DSP_VALUEHL
2748 e5					push hl    ; n2 
2749					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2749 cd a9 1e			call macro_forth_dsp_pop 
274c				endm 
# End of macro FORTH_DSP_POP
274c			 
274c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
274c cd f1 1d			call macro_dsp_valuehl 
274f				endm 
# End of macro FORTH_DSP_VALUEHL
274f e5					push hl    ; n1 
2750					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2750 cd a9 1e			call macro_forth_dsp_pop 
2753				endm 
# End of macro FORTH_DSP_POP
2753			 
2753 d1					pop de     ; n1 
2754 e1					pop hl     ; n2 
2755			 
2755 d5					push de 
2756 e5					push hl 
2757 d5					push de 
2758			 
2758					; push back  
2758			 
2758 e1					pop hl 
2759 cd fa 1b				call forth_push_numhl 
275c e1					pop hl 
275d cd fa 1b				call forth_push_numhl 
2760 e1					pop hl 
2761 cd fa 1b				call forth_push_numhl 
2764					NEXTW 
2764 c3 63 1f			jp macro_next 
2767				endm 
# End of macro NEXTW
2767			 
2767			.PAUSE: 
2767				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2767 43				db WORD_SYS_CORE+47             
2768 9c 27			dw .PAUSES            
276a 08				db 7 + 1 
276b .. 00			db "PAUSEMS",0              
2773				endm 
# End of macro CWHEAD
2773			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2773					if DEBUG_FORTH_WORDS_KEY 
2773						DMARK "PMS" 
2773 f5				push af  
2774 3a 88 27			ld a, (.dmark)  
2777 32 bd fb			ld (debug_mark),a  
277a 3a 89 27			ld a, (.dmark+1)  
277d 32 be fb			ld (debug_mark+1),a  
2780 3a 8a 27			ld a, (.dmark+2)  
2783 32 bf fb			ld (debug_mark+2),a  
2786 18 03			jr .pastdmark  
2788 ..			.dmark: db "PMS"  
278b f1			.pastdmark: pop af  
278c			endm  
# End of macro DMARK
278c						CALLMONITOR 
278c cd 6a 16			call break_point_state  
278f				endm  
# End of macro CALLMONITOR
278f					endif 
278f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
278f cd f1 1d			call macro_dsp_valuehl 
2792				endm 
# End of macro FORTH_DSP_VALUEHL
2792			;		push hl    ; n2 
2792					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2792 cd a9 1e			call macro_forth_dsp_pop 
2795				endm 
# End of macro FORTH_DSP_POP
2795			;		pop hl 
2795			 
2795 7d					ld a, l 
2796 cd 37 0a				call aDelayInMS 
2799				       NEXTW 
2799 c3 63 1f			jp macro_next 
279c				endm 
# End of macro NEXTW
279c			.PAUSES:  
279c				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
279c 44				db WORD_SYS_CORE+48             
279d 0b 28			dw .ROT            
279f 06				db 5 + 1 
27a0 .. 00			db "PAUSE",0              
27a6				endm 
# End of macro CWHEAD
27a6			; | PAUSE ( n -- )  Pause for n seconds | DONE 
27a6					if DEBUG_FORTH_WORDS_KEY 
27a6						DMARK "PAU" 
27a6 f5				push af  
27a7 3a bb 27			ld a, (.dmark)  
27aa 32 bd fb			ld (debug_mark),a  
27ad 3a bc 27			ld a, (.dmark+1)  
27b0 32 be fb			ld (debug_mark+1),a  
27b3 3a bd 27			ld a, (.dmark+2)  
27b6 32 bf fb			ld (debug_mark+2),a  
27b9 18 03			jr .pastdmark  
27bb ..			.dmark: db "PAU"  
27be f1			.pastdmark: pop af  
27bf			endm  
# End of macro DMARK
27bf						CALLMONITOR 
27bf cd 6a 16			call break_point_state  
27c2				endm  
# End of macro CALLMONITOR
27c2					endif 
27c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c2 cd f1 1d			call macro_dsp_valuehl 
27c5				endm 
# End of macro FORTH_DSP_VALUEHL
27c5			;		push hl    ; n2 
27c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c5 cd a9 1e			call macro_forth_dsp_pop 
27c8				endm 
# End of macro FORTH_DSP_POP
27c8			;		pop hl 
27c8 45					ld b, l 
27c9					if DEBUG_FORTH_WORDS 
27c9						DMARK "PAU" 
27c9 f5				push af  
27ca 3a de 27			ld a, (.dmark)  
27cd 32 bd fb			ld (debug_mark),a  
27d0 3a df 27			ld a, (.dmark+1)  
27d3 32 be fb			ld (debug_mark+1),a  
27d6 3a e0 27			ld a, (.dmark+2)  
27d9 32 bf fb			ld (debug_mark+2),a  
27dc 18 03			jr .pastdmark  
27de ..			.dmark: db "PAU"  
27e1 f1			.pastdmark: pop af  
27e2			endm  
# End of macro DMARK
27e2						CALLMONITOR 
27e2 cd 6a 16			call break_point_state  
27e5				endm  
# End of macro CALLMONITOR
27e5					endif 
27e5 c5			.pauses1:	push bc 
27e6 cd 52 0a				call delay1s 
27e9 c1					pop bc 
27ea					if DEBUG_FORTH_WORDS 
27ea						DMARK "PA1" 
27ea f5				push af  
27eb 3a ff 27			ld a, (.dmark)  
27ee 32 bd fb			ld (debug_mark),a  
27f1 3a 00 28			ld a, (.dmark+1)  
27f4 32 be fb			ld (debug_mark+1),a  
27f7 3a 01 28			ld a, (.dmark+2)  
27fa 32 bf fb			ld (debug_mark+2),a  
27fd 18 03			jr .pastdmark  
27ff ..			.dmark: db "PA1"  
2802 f1			.pastdmark: pop af  
2803			endm  
# End of macro DMARK
2803						CALLMONITOR 
2803 cd 6a 16			call break_point_state  
2806				endm  
# End of macro CALLMONITOR
2806					endif 
2806 10 dd				djnz .pauses1 
2808			 
2808				       NEXTW 
2808 c3 63 1f			jp macro_next 
280b				endm 
# End of macro NEXTW
280b			.ROT: 
280b				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
280b 45				db WORD_SYS_CORE+49             
280c 59 28			dw .UWORDS            
280e 04				db 3 + 1 
280f .. 00			db "ROT",0              
2813				endm 
# End of macro CWHEAD
2813			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2813					if DEBUG_FORTH_WORDS_KEY 
2813						DMARK "ROT" 
2813 f5				push af  
2814 3a 28 28			ld a, (.dmark)  
2817 32 bd fb			ld (debug_mark),a  
281a 3a 29 28			ld a, (.dmark+1)  
281d 32 be fb			ld (debug_mark+1),a  
2820 3a 2a 28			ld a, (.dmark+2)  
2823 32 bf fb			ld (debug_mark+2),a  
2826 18 03			jr .pastdmark  
2828 ..			.dmark: db "ROT"  
282b f1			.pastdmark: pop af  
282c			endm  
# End of macro DMARK
282c						CALLMONITOR 
282c cd 6a 16			call break_point_state  
282f				endm  
# End of macro CALLMONITOR
282f					endif 
282f			 
282f					FORTH_DSP_VALUEHL 
282f cd f1 1d			call macro_dsp_valuehl 
2832				endm 
# End of macro FORTH_DSP_VALUEHL
2832 e5					push hl    ; u3  
2833			 
2833					FORTH_DSP_POP 
2833 cd a9 1e			call macro_forth_dsp_pop 
2836				endm 
# End of macro FORTH_DSP_POP
2836			   
2836					FORTH_DSP_VALUEHL 
2836 cd f1 1d			call macro_dsp_valuehl 
2839				endm 
# End of macro FORTH_DSP_VALUEHL
2839 e5					push hl     ; u2 
283a			 
283a					FORTH_DSP_POP 
283a cd a9 1e			call macro_forth_dsp_pop 
283d				endm 
# End of macro FORTH_DSP_POP
283d			 
283d					FORTH_DSP_VALUEHL 
283d cd f1 1d			call macro_dsp_valuehl 
2840				endm 
# End of macro FORTH_DSP_VALUEHL
2840 e5					push hl     ; u1 
2841			 
2841					FORTH_DSP_POP 
2841 cd a9 1e			call macro_forth_dsp_pop 
2844				endm 
# End of macro FORTH_DSP_POP
2844			 
2844 c1					pop bc      ; u1 
2845 e1					pop hl      ; u2 
2846 d1					pop de      ; u3 
2847			 
2847			 
2847 c5					push bc 
2848 d5					push de 
2849 e5					push hl 
284a			 
284a			 
284a e1					pop hl 
284b cd fa 1b				call forth_push_numhl 
284e			 
284e e1					pop hl 
284f cd fa 1b				call forth_push_numhl 
2852			 
2852 e1					pop hl 
2853 cd fa 1b				call forth_push_numhl 
2856					 
2856			 
2856			 
2856			 
2856			 
2856			 
2856				       NEXTW 
2856 c3 63 1f			jp macro_next 
2859				endm 
# End of macro NEXTW
2859			 
2859			.UWORDS: 
2859				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2859 50				db WORD_SYS_CORE+60             
285a 1b 29			dw .BP            
285c 07				db 6 + 1 
285d .. 00			db "UWORDS",0              
2864				endm 
# End of macro CWHEAD
2864			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2864			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2864			; | | Following the count are the individual words. 
2864			; | | 
2864			; | | e.g. UWORDS 
2864			; | | BOX DIRLIST 2 
2864			; | |  
2864			; | | Can be used to save the words to storage via: 
2864			; | | UWORDS $01 DO $01 APPEND LOOP 
2864				if DEBUG_FORTH_WORDS_KEY 
2864					DMARK "UWR" 
2864 f5				push af  
2865 3a 79 28			ld a, (.dmark)  
2868 32 bd fb			ld (debug_mark),a  
286b 3a 7a 28			ld a, (.dmark+1)  
286e 32 be fb			ld (debug_mark+1),a  
2871 3a 7b 28			ld a, (.dmark+2)  
2874 32 bf fb			ld (debug_mark+2),a  
2877 18 03			jr .pastdmark  
2879 ..			.dmark: db "UWR"  
287c f1			.pastdmark: pop af  
287d			endm  
# End of macro DMARK
287d					CALLMONITOR 
287d cd 6a 16			call break_point_state  
2880				endm  
# End of macro CALLMONITOR
2880				endif 
2880 21 00 80				ld hl, baseram 
2883					;ld hl, baseusermem 
2883 01 00 00				ld bc, 0    ; start a counter 
2886			 
2886				; skip dict stub 
2886			 
2886 cd b4 20				call forth_tok_next 
2889			 
2889			 
2889			; while we have words to look for 
2889			 
2889 7e			.douscan:	ld a, (hl)      
288a				if DEBUG_FORTH_WORDS 
288a					DMARK "UWs" 
288a f5				push af  
288b 3a 9f 28			ld a, (.dmark)  
288e 32 bd fb			ld (debug_mark),a  
2891 3a a0 28			ld a, (.dmark+1)  
2894 32 be fb			ld (debug_mark+1),a  
2897 3a a1 28			ld a, (.dmark+2)  
289a 32 bf fb			ld (debug_mark+2),a  
289d 18 03			jr .pastdmark  
289f ..			.dmark: db "UWs"  
28a2 f1			.pastdmark: pop af  
28a3			endm  
# End of macro DMARK
28a3					CALLMONITOR 
28a3 cd 6a 16			call break_point_state  
28a6				endm  
# End of macro CALLMONITOR
28a6				endif 
28a6 fe 00				cp WORD_SYS_END 
28a8 28 4d				jr z, .udone 
28aa fe 01				cp WORD_SYS_UWORD 
28ac 20 44				jr nz, .nuword 
28ae			 
28ae				if DEBUG_FORTH_WORDS 
28ae					DMARK "UWu" 
28ae f5				push af  
28af 3a c3 28			ld a, (.dmark)  
28b2 32 bd fb			ld (debug_mark),a  
28b5 3a c4 28			ld a, (.dmark+1)  
28b8 32 be fb			ld (debug_mark+1),a  
28bb 3a c5 28			ld a, (.dmark+2)  
28be 32 bf fb			ld (debug_mark+2),a  
28c1 18 03			jr .pastdmark  
28c3 ..			.dmark: db "UWu"  
28c6 f1			.pastdmark: pop af  
28c7			endm  
# End of macro DMARK
28c7					CALLMONITOR 
28c7 cd 6a 16			call break_point_state  
28ca				endm  
# End of macro CALLMONITOR
28ca				endif 
28ca					; we have a uword so push its name to the stack 
28ca			 
28ca e5				   	push hl  ; save so we can move to next dict block 
28cb			 
28cb					; skip opcode 
28cb 23					inc hl  
28cc					; skip next ptr 
28cc 23					inc hl  
28cd 23					inc hl 
28ce					; skip len 
28ce 23					inc hl 
28cf				if DEBUG_FORTH_WORDS 
28cf					DMARK "UWt" 
28cf f5				push af  
28d0 3a e4 28			ld a, (.dmark)  
28d3 32 bd fb			ld (debug_mark),a  
28d6 3a e5 28			ld a, (.dmark+1)  
28d9 32 be fb			ld (debug_mark+1),a  
28dc 3a e6 28			ld a, (.dmark+2)  
28df 32 bf fb			ld (debug_mark+2),a  
28e2 18 03			jr .pastdmark  
28e4 ..			.dmark: db "UWt"  
28e7 f1			.pastdmark: pop af  
28e8			endm  
# End of macro DMARK
28e8					CALLMONITOR 
28e8 cd 6a 16			call break_point_state  
28eb				endm  
# End of macro CALLMONITOR
28eb				endif 
28eb 03					inc bc 
28ec			 
28ec c5					push bc 
28ed cd 68 1c				call forth_push_str 
28f0 c1					pop bc 
28f1			 
28f1 e1					pop hl 	 
28f2			 
28f2 cd b4 20		.nuword:	call forth_tok_next 
28f5 18 92				jr .douscan  
28f7			 
28f7			.udone:		 ; push count of uwords found 
28f7 c5					push bc 
28f8 e1					pop hl 
28f9			 
28f9				if DEBUG_FORTH_WORDS 
28f9					DMARK "UWc" 
28f9 f5				push af  
28fa 3a 0e 29			ld a, (.dmark)  
28fd 32 bd fb			ld (debug_mark),a  
2900 3a 0f 29			ld a, (.dmark+1)  
2903 32 be fb			ld (debug_mark+1),a  
2906 3a 10 29			ld a, (.dmark+2)  
2909 32 bf fb			ld (debug_mark+2),a  
290c 18 03			jr .pastdmark  
290e ..			.dmark: db "UWc"  
2911 f1			.pastdmark: pop af  
2912			endm  
# End of macro DMARK
2912					CALLMONITOR 
2912 cd 6a 16			call break_point_state  
2915				endm  
# End of macro CALLMONITOR
2915				endif 
2915 cd fa 1b				call forth_push_numhl 
2918			 
2918			 
2918				       NEXTW 
2918 c3 63 1f			jp macro_next 
291b				endm 
# End of macro NEXTW
291b			 
291b			.BP: 
291b				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
291b 54				db WORD_SYS_CORE+64             
291c 51 29			dw .MONITOR            
291e 03				db 2 + 1 
291f .. 00			db "BP",0              
2922				endm 
# End of macro CWHEAD
2922			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2922			; | | $00 Will enable the break points within specific code paths 
2922			; | | $01 Will disable break points 
2922			; | |  
2922			; | | By default break points are off. Either the above can be used to enable them 
2922			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2922			; | | and on release of the pressed key a message will be disaplayed to notify 
2922			; | | that break points are enabled. Pressing any key will then continue boot process. 
2922					; get byte count 
2922					if DEBUG_FORTH_WORDS_KEY 
2922						DMARK "BP." 
2922 f5				push af  
2923 3a 37 29			ld a, (.dmark)  
2926 32 bd fb			ld (debug_mark),a  
2929 3a 38 29			ld a, (.dmark+1)  
292c 32 be fb			ld (debug_mark+1),a  
292f 3a 39 29			ld a, (.dmark+2)  
2932 32 bf fb			ld (debug_mark+2),a  
2935 18 03			jr .pastdmark  
2937 ..			.dmark: db "BP."  
293a f1			.pastdmark: pop af  
293b			endm  
# End of macro DMARK
293b						CALLMONITOR 
293b cd 6a 16			call break_point_state  
293e				endm  
# End of macro CALLMONITOR
293e					endif 
293e			 
293e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
293e cd f1 1d			call macro_dsp_valuehl 
2941				endm 
# End of macro FORTH_DSP_VALUEHL
2941			 
2941			;		push hl 
2941			 
2941					; destroy value TOS 
2941			 
2941					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2941 cd a9 1e			call macro_forth_dsp_pop 
2944				endm 
# End of macro FORTH_DSP_POP
2944			 
2944			;		pop hl 
2944			 
2944 3e 00				ld a,0 
2946 bd					cp l 
2947 28 02				jr z, .bpset 
2949 3e 2a				ld a, '*' 
294b			 
294b 32 94 ef		.bpset:		ld (os_view_disable), a 
294e			 
294e			 
294e					NEXTW 
294e c3 63 1f			jp macro_next 
2951				endm 
# End of macro NEXTW
2951			 
2951			 
2951			.MONITOR: 
2951				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2951 55				db WORD_SYS_CORE+65             
2952 84 29			dw .MALLOC            
2954 08				db 7 + 1 
2955 .. 00			db "MONITOR",0              
295d				endm 
# End of macro CWHEAD
295d			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
295d			; | | At start the current various registers will be displayed with contents. 
295d			; | | Top right corner will show the most recent debug marker seen. 
295d			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
295d			; | | and the return stack pointer (RSP). 
295d			; | | Pressing: 
295d			; | |    1 - Initial screen 
295d			; | |    2 - Display a data dump of HL 
295d			; | |    3 - Display a data dump of DE 
295d			; | |    4 - Display a data dump of BC 
295d			; | |    5 - Display a data dump of HL 
295d			; | |    6 - Display a data dump of DSP 
295d			; | |    7 - Display a data dump of RSP 
295d			; | |    8 - Display a data dump of what is at DSP 
295d			; | |    9 - Display a data dump of what is at RSP 
295d			; | |    0 - Exit monitor and continue running. This will also enable break points 
295d			; | |    * - Disable break points 
295d			; | |    # - Enter traditional monitor mode 
295d			; | | 
295d			; | | Monitor Mode 
295d			; | | ------------ 
295d			; | | A prompt of '>' will be shown for various commands: 
295d			; | |    D xxxx - Display a data dump starting from hex address xxxx 
295d			; | |    C - Continue display a data dump from the last set address 
295d			; | |    M xxxx - Set start of memory edit at address xx 
295d			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
295d			; | |    Q - Return to previous 
295d					if DEBUG_FORTH_WORDS_KEY 
295d						DMARK "MON" 
295d f5				push af  
295e 3a 72 29			ld a, (.dmark)  
2961 32 bd fb			ld (debug_mark),a  
2964 3a 73 29			ld a, (.dmark+1)  
2967 32 be fb			ld (debug_mark+1),a  
296a 3a 74 29			ld a, (.dmark+2)  
296d 32 bf fb			ld (debug_mark+2),a  
2970 18 03			jr .pastdmark  
2972 ..			.dmark: db "MON"  
2975 f1			.pastdmark: pop af  
2976			endm  
# End of macro DMARK
2976						CALLMONITOR 
2976 cd 6a 16			call break_point_state  
2979				endm  
# End of macro CALLMONITOR
2979					endif 
2979 3e 00				ld a, 0 
297b 32 94 ef				ld (os_view_disable), a 
297e			 
297e					CALLMONITOR 
297e cd 6a 16			call break_point_state  
2981				endm  
# End of macro CALLMONITOR
2981			 
2981			;	call monitor 
2981			 
2981					NEXTW 
2981 c3 63 1f			jp macro_next 
2984				endm 
# End of macro NEXTW
2984			 
2984			 
2984			.MALLOC: 
2984				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2984 56				db WORD_SYS_CORE+66             
2985 ad 29			dw .MALLOC2            
2987 06				db 5 + 1 
2988 .. 00			db "ALLOT",0              
298e				endm 
# End of macro CWHEAD
298e			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
298e					if DEBUG_FORTH_WORDS_KEY 
298e						DMARK "ALL" 
298e f5				push af  
298f 3a a3 29			ld a, (.dmark)  
2992 32 bd fb			ld (debug_mark),a  
2995 3a a4 29			ld a, (.dmark+1)  
2998 32 be fb			ld (debug_mark+1),a  
299b 3a a5 29			ld a, (.dmark+2)  
299e 32 bf fb			ld (debug_mark+2),a  
29a1 18 03			jr .pastdmark  
29a3 ..			.dmark: db "ALL"  
29a6 f1			.pastdmark: pop af  
29a7			endm  
# End of macro DMARK
29a7						CALLMONITOR 
29a7 cd 6a 16			call break_point_state  
29aa				endm  
# End of macro CALLMONITOR
29aa					endif 
29aa c3 d4 29				jp .mallocc 
29ad			.MALLOC2: 
29ad				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
29ad 56				db WORD_SYS_CORE+66             
29ae eb 29			dw .FREE            
29b0 07				db 6 + 1 
29b1 .. 00			db "MALLOC",0              
29b8				endm 
# End of macro CWHEAD
29b8			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29b8					; get byte count 
29b8					if DEBUG_FORTH_WORDS_KEY 
29b8						DMARK "MAL" 
29b8 f5				push af  
29b9 3a cd 29			ld a, (.dmark)  
29bc 32 bd fb			ld (debug_mark),a  
29bf 3a ce 29			ld a, (.dmark+1)  
29c2 32 be fb			ld (debug_mark+1),a  
29c5 3a cf 29			ld a, (.dmark+2)  
29c8 32 bf fb			ld (debug_mark+2),a  
29cb 18 03			jr .pastdmark  
29cd ..			.dmark: db "MAL"  
29d0 f1			.pastdmark: pop af  
29d1			endm  
# End of macro DMARK
29d1						CALLMONITOR 
29d1 cd 6a 16			call break_point_state  
29d4				endm  
# End of macro CALLMONITOR
29d4					endif 
29d4			.mallocc: 
29d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d4 cd f1 1d			call macro_dsp_valuehl 
29d7				endm 
# End of macro FORTH_DSP_VALUEHL
29d7			 
29d7			;		push hl 
29d7			 
29d7					; destroy value TOS 
29d7			 
29d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d7 cd a9 1e			call macro_forth_dsp_pop 
29da				endm 
# End of macro FORTH_DSP_POP
29da			 
29da			;		pop hl 
29da cd cd 11				call malloc 
29dd				if DEBUG_FORTH_MALLOC_GUARD 
29dd f5					push af 
29de cd 2f 0d				call ishlzero 
29e1			;		ld a, l 
29e1			;		add h 
29e1			;		cp 0 
29e1 f1					pop af 
29e2					 
29e2 cc f6 51				call z,malloc_error 
29e5				endif 
29e5			 
29e5 cd fa 1b				call forth_push_numhl 
29e8					NEXTW 
29e8 c3 63 1f			jp macro_next 
29eb				endm 
# End of macro NEXTW
29eb			 
29eb			.FREE: 
29eb				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
29eb 57				db WORD_SYS_CORE+67             
29ec 1c 2a			dw .LIST            
29ee 05				db 4 + 1 
29ef .. 00			db "FREE",0              
29f4				endm 
# End of macro CWHEAD
29f4			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
29f4					if DEBUG_FORTH_WORDS_KEY 
29f4						DMARK "FRE" 
29f4 f5				push af  
29f5 3a 09 2a			ld a, (.dmark)  
29f8 32 bd fb			ld (debug_mark),a  
29fb 3a 0a 2a			ld a, (.dmark+1)  
29fe 32 be fb			ld (debug_mark+1),a  
2a01 3a 0b 2a			ld a, (.dmark+2)  
2a04 32 bf fb			ld (debug_mark+2),a  
2a07 18 03			jr .pastdmark  
2a09 ..			.dmark: db "FRE"  
2a0c f1			.pastdmark: pop af  
2a0d			endm  
# End of macro DMARK
2a0d						CALLMONITOR 
2a0d cd 6a 16			call break_point_state  
2a10				endm  
# End of macro CALLMONITOR
2a10					endif 
2a10					; get address 
2a10			 
2a10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a10 cd f1 1d			call macro_dsp_valuehl 
2a13				endm 
# End of macro FORTH_DSP_VALUEHL
2a13			 
2a13			;		push hl 
2a13			 
2a13					; destroy value TOS 
2a13			 
2a13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a13 cd a9 1e			call macro_forth_dsp_pop 
2a16				endm 
# End of macro FORTH_DSP_POP
2a16			 
2a16			;		pop hl 
2a16			if FORTH_ENABLE_MALLOCFREE 
2a16 cd 97 12				call free 
2a19			endif 
2a19					NEXTW 
2a19 c3 63 1f			jp macro_next 
2a1c				endm 
# End of macro NEXTW
2a1c			.LIST: 
2a1c				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a1c 5c				db WORD_SYS_CORE+72             
2a1d df 2b			dw .FORGET            
2a1f 05				db 4 + 1 
2a20 .. 00			db "LIST",0              
2a25				endm 
# End of macro CWHEAD
2a25			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a25			; | | The quoted word must be in upper case. 
2a25				if DEBUG_FORTH_WORDS_KEY 
2a25					DMARK "LST" 
2a25 f5				push af  
2a26 3a 3a 2a			ld a, (.dmark)  
2a29 32 bd fb			ld (debug_mark),a  
2a2c 3a 3b 2a			ld a, (.dmark+1)  
2a2f 32 be fb			ld (debug_mark+1),a  
2a32 3a 3c 2a			ld a, (.dmark+2)  
2a35 32 bf fb			ld (debug_mark+2),a  
2a38 18 03			jr .pastdmark  
2a3a ..			.dmark: db "LST"  
2a3d f1			.pastdmark: pop af  
2a3e			endm  
# End of macro DMARK
2a3e					CALLMONITOR 
2a3e cd 6a 16			call break_point_state  
2a41				endm  
# End of macro CALLMONITOR
2a41				endif 
2a41			 
2a41					FORTH_DSP_VALUEHL 
2a41 cd f1 1d			call macro_dsp_valuehl 
2a44				endm 
# End of macro FORTH_DSP_VALUEHL
2a44			 
2a44 e5					push hl 
2a45 c1					pop bc 
2a46			 
2a46			; Start format of scratch string 
2a46			 
2a46 21 a3 ef				ld hl, scratch 
2a49			 
2a49 3e 3a				ld a, ':' 
2a4b 77					ld (hl),a 
2a4c 23					inc hl 
2a4d 3e 20				ld a, ' ' 
2a4f 77					ld (hl), a 
2a50			 
2a50					; Get ptr to the word we need to look up 
2a50			 
2a50			;		FORTH_DSP_VALUEHL 
2a50					;v5 FORTH_DSP_VALUE 
2a50				; TODO type check 
2a50			;		inc hl    ; Skip type check  
2a50			;		push hl 
2a50			;		ex de, hl    ; put into DE 
2a50			 
2a50			 
2a50 21 00 80				ld hl, baseram 
2a53					;ld hl, baseusermem 
2a53			 
2a53 e5			push hl   ; sacreifical push 
2a54			 
2a54			.ldouscanm: 
2a54 e1				pop hl 
2a55			.ldouscan: 
2a55				if DEBUG_FORTH_WORDS 
2a55					DMARK "LSs" 
2a55 f5				push af  
2a56 3a 6a 2a			ld a, (.dmark)  
2a59 32 bd fb			ld (debug_mark),a  
2a5c 3a 6b 2a			ld a, (.dmark+1)  
2a5f 32 be fb			ld (debug_mark+1),a  
2a62 3a 6c 2a			ld a, (.dmark+2)  
2a65 32 bf fb			ld (debug_mark+2),a  
2a68 18 03			jr .pastdmark  
2a6a ..			.dmark: db "LSs"  
2a6d f1			.pastdmark: pop af  
2a6e			endm  
# End of macro DMARK
2a6e					CALLMONITOR 
2a6e cd 6a 16			call break_point_state  
2a71				endm  
# End of macro CALLMONITOR
2a71				endif 
2a71				; skip dict stub 
2a71 cd b4 20				call forth_tok_next 
2a74			 
2a74			 
2a74			; while we have words to look for 
2a74			 
2a74 7e				ld a, (hl)      
2a75				if DEBUG_FORTH_WORDS 
2a75					DMARK "LSk" 
2a75 f5				push af  
2a76 3a 8a 2a			ld a, (.dmark)  
2a79 32 bd fb			ld (debug_mark),a  
2a7c 3a 8b 2a			ld a, (.dmark+1)  
2a7f 32 be fb			ld (debug_mark+1),a  
2a82 3a 8c 2a			ld a, (.dmark+2)  
2a85 32 bf fb			ld (debug_mark+2),a  
2a88 18 03			jr .pastdmark  
2a8a ..			.dmark: db "LSk"  
2a8d f1			.pastdmark: pop af  
2a8e			endm  
# End of macro DMARK
2a8e					CALLMONITOR 
2a8e cd 6a 16			call break_point_state  
2a91				endm  
# End of macro CALLMONITOR
2a91				endif 
2a91 fe 00				cp WORD_SYS_END 
2a93 ca c6 2b				jp z, .lunotfound 
2a96 fe 01				cp WORD_SYS_UWORD 
2a98 c2 55 2a				jp nz, .ldouscan 
2a9b			 
2a9b				if DEBUG_FORTH_WORDS 
2a9b					DMARK "LSu" 
2a9b f5				push af  
2a9c 3a b0 2a			ld a, (.dmark)  
2a9f 32 bd fb			ld (debug_mark),a  
2aa2 3a b1 2a			ld a, (.dmark+1)  
2aa5 32 be fb			ld (debug_mark+1),a  
2aa8 3a b2 2a			ld a, (.dmark+2)  
2aab 32 bf fb			ld (debug_mark+2),a  
2aae 18 03			jr .pastdmark  
2ab0 ..			.dmark: db "LSu"  
2ab3 f1			.pastdmark: pop af  
2ab4			endm  
# End of macro DMARK
2ab4					CALLMONITOR 
2ab4 cd 6a 16			call break_point_state  
2ab7				endm  
# End of macro CALLMONITOR
2ab7				endif 
2ab7			 
2ab7					; found a uword but is it the one we want... 
2ab7			 
2ab7 c5					push bc     ; uword to find is on bc 
2ab8 d1					pop de 
2ab9			 
2ab9 e5					push hl  ; to save the ptr 
2aba			 
2aba					; skip opcode 
2aba 23					inc hl  
2abb					; skip next ptr 
2abb 23					inc hl  
2abc 23					inc hl 
2abd					; skip len 
2abd 23					inc hl 
2abe			 
2abe				if DEBUG_FORTH_WORDS 
2abe					DMARK "LSc" 
2abe f5				push af  
2abf 3a d3 2a			ld a, (.dmark)  
2ac2 32 bd fb			ld (debug_mark),a  
2ac5 3a d4 2a			ld a, (.dmark+1)  
2ac8 32 be fb			ld (debug_mark+1),a  
2acb 3a d5 2a			ld a, (.dmark+2)  
2ace 32 bf fb			ld (debug_mark+2),a  
2ad1 18 03			jr .pastdmark  
2ad3 ..			.dmark: db "LSc"  
2ad6 f1			.pastdmark: pop af  
2ad7			endm  
# End of macro DMARK
2ad7					CALLMONITOR 
2ad7 cd 6a 16			call break_point_state  
2ada				endm  
# End of macro CALLMONITOR
2ada				endif 
2ada cd 9c 11				call strcmp 
2add c2 54 2a				jp nz, .ldouscanm 
2ae0				 
2ae0			 
2ae0			 
2ae0					; we have a uword so push its name to the stack 
2ae0			 
2ae0			;	   	push hl  ; save so we can move to next dict block 
2ae0 e1			pop hl 
2ae1			 
2ae1				if DEBUG_FORTH_WORDS 
2ae1					DMARK "LSm" 
2ae1 f5				push af  
2ae2 3a f6 2a			ld a, (.dmark)  
2ae5 32 bd fb			ld (debug_mark),a  
2ae8 3a f7 2a			ld a, (.dmark+1)  
2aeb 32 be fb			ld (debug_mark+1),a  
2aee 3a f8 2a			ld a, (.dmark+2)  
2af1 32 bf fb			ld (debug_mark+2),a  
2af4 18 03			jr .pastdmark  
2af6 ..			.dmark: db "LSm"  
2af9 f1			.pastdmark: pop af  
2afa			endm  
# End of macro DMARK
2afa					CALLMONITOR 
2afa cd 6a 16			call break_point_state  
2afd				endm  
# End of macro CALLMONITOR
2afd				endif 
2afd			 
2afd					; skip opcode 
2afd 23					inc hl  
2afe					; skip next ptr 
2afe 23					inc hl  
2aff 23					inc hl 
2b00					; skip len 
2b00 7e					ld a, (hl)   ; save length to add 
2b01				if DEBUG_FORTH_WORDS 
2b01					DMARK "LS2" 
2b01 f5				push af  
2b02 3a 16 2b			ld a, (.dmark)  
2b05 32 bd fb			ld (debug_mark),a  
2b08 3a 17 2b			ld a, (.dmark+1)  
2b0b 32 be fb			ld (debug_mark+1),a  
2b0e 3a 18 2b			ld a, (.dmark+2)  
2b11 32 bf fb			ld (debug_mark+2),a  
2b14 18 03			jr .pastdmark  
2b16 ..			.dmark: db "LS2"  
2b19 f1			.pastdmark: pop af  
2b1a			endm  
# End of macro DMARK
2b1a					CALLMONITOR 
2b1a cd 6a 16			call break_point_state  
2b1d				endm  
# End of macro CALLMONITOR
2b1d				endif 
2b1d			 
2b1d					; save this location 
2b1d				 
2b1d e5					push hl 
2b1e			 
2b1e 23					inc hl 
2b1f 11 a5 ef				ld de, scratch+2 
2b22 4f					ld c, a 
2b23 06 00				ld b, 0 
2b25			 
2b25				if DEBUG_FORTH_WORDS 
2b25					DMARK "LSn" 
2b25 f5				push af  
2b26 3a 3a 2b			ld a, (.dmark)  
2b29 32 bd fb			ld (debug_mark),a  
2b2c 3a 3b 2b			ld a, (.dmark+1)  
2b2f 32 be fb			ld (debug_mark+1),a  
2b32 3a 3c 2b			ld a, (.dmark+2)  
2b35 32 bf fb			ld (debug_mark+2),a  
2b38 18 03			jr .pastdmark  
2b3a ..			.dmark: db "LSn"  
2b3d f1			.pastdmark: pop af  
2b3e			endm  
# End of macro DMARK
2b3e					CALLMONITOR 
2b3e cd 6a 16			call break_point_state  
2b41				endm  
# End of macro CALLMONITOR
2b41				endif 
2b41			 
2b41					; copy uword name to scratch 
2b41			 
2b41 ed b0				ldir 
2b43			 
2b43 1b					dec de 
2b44 3e 20				ld a, ' '    ; change null to space 
2b46 12					ld (de), a 
2b47			 
2b47 13					inc de 
2b48			 
2b48 d5					push de 
2b49 c1					pop bc     ; move scratch pointer to end of word name and save it 
2b4a			 
2b4a e1					pop hl 
2b4b 7e					ld a, (hl) 
2b4c					;inc hl 
2b4c					; skip word string 
2b4c cd 06 0d				call addatohl 
2b4f			 
2b4f 23					inc hl 
2b50			 
2b50				if DEBUG_FORTH_WORDS 
2b50					DMARK "LS3" 
2b50 f5				push af  
2b51 3a 65 2b			ld a, (.dmark)  
2b54 32 bd fb			ld (debug_mark),a  
2b57 3a 66 2b			ld a, (.dmark+1)  
2b5a 32 be fb			ld (debug_mark+1),a  
2b5d 3a 67 2b			ld a, (.dmark+2)  
2b60 32 bf fb			ld (debug_mark+2),a  
2b63 18 03			jr .pastdmark  
2b65 ..			.dmark: db "LS3"  
2b68 f1			.pastdmark: pop af  
2b69			endm  
# End of macro DMARK
2b69					CALLMONITOR 
2b69 cd 6a 16			call break_point_state  
2b6c				endm  
# End of macro CALLMONITOR
2b6c				endif 
2b6c					; should now be at the start of the machine code to setup the eval of the uword 
2b6c					; now locate the ptr to the string defintion 
2b6c			 
2b6c					; skip ld hl, 
2b6c					; then load the ptr 
2b6c			 
2b6c 23					inc hl 
2b6d 5e					ld e, (hl) 
2b6e 23					inc hl 
2b6f 56					ld d, (hl) 
2b70 eb					ex de, hl 
2b71			 
2b71			 
2b71				if DEBUG_FORTH_WORDS 
2b71					DMARK "LSt" 
2b71 f5				push af  
2b72 3a 86 2b			ld a, (.dmark)  
2b75 32 bd fb			ld (debug_mark),a  
2b78 3a 87 2b			ld a, (.dmark+1)  
2b7b 32 be fb			ld (debug_mark+1),a  
2b7e 3a 88 2b			ld a, (.dmark+2)  
2b81 32 bf fb			ld (debug_mark+2),a  
2b84 18 03			jr .pastdmark  
2b86 ..			.dmark: db "LSt"  
2b89 f1			.pastdmark: pop af  
2b8a			endm  
# End of macro DMARK
2b8a					CALLMONITOR 
2b8a cd 6a 16			call break_point_state  
2b8d				endm  
# End of macro CALLMONITOR
2b8d				endif 
2b8d			 
2b8d			; cant push right now due to tokenised strings  
2b8d			 
2b8d			; get the destination of where to copy this definition to. 
2b8d			 
2b8d c5					push bc 
2b8e d1					pop de 
2b8f			 
2b8f 7e			.listl:         ld a,(hl) 
2b90 fe 00				cp 0 
2b92 28 09				jr z, .lreplsp     ; replace zero with space 
2b94 fe 7f				cp FORTH_END_BUFFER 
2b96 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b98				 
2b98					; just copy this char as is then 
2b98			 
2b98 12					ld (de), a 
2b99			 
2b99 23			.listnxt:	inc hl 
2b9a 13					inc de 
2b9b 18 f2				jr .listl 
2b9d			 
2b9d 3e 20		.lreplsp:	ld a,' ' 
2b9f 12					ld (de), a 
2ba0 18 f7				jr .listnxt 
2ba2			 
2ba2			; close up uword def 
2ba2			 
2ba2			.listdone: 
2ba2 3e 00				ld a, 0 
2ba4 12					ld (de), a 
2ba5			 
2ba5			; now have def so clean up and push to stack 
2ba5			 
2ba5 21 a3 ef				ld hl, scratch 
2ba8				if DEBUG_FORTH_WORDS 
2ba8					DMARK "Ltp" 
2ba8 f5				push af  
2ba9 3a bd 2b			ld a, (.dmark)  
2bac 32 bd fb			ld (debug_mark),a  
2baf 3a be 2b			ld a, (.dmark+1)  
2bb2 32 be fb			ld (debug_mark+1),a  
2bb5 3a bf 2b			ld a, (.dmark+2)  
2bb8 32 bf fb			ld (debug_mark+2),a  
2bbb 18 03			jr .pastdmark  
2bbd ..			.dmark: db "Ltp"  
2bc0 f1			.pastdmark: pop af  
2bc1			endm  
# End of macro DMARK
2bc1					CALLMONITOR 
2bc1 cd 6a 16			call break_point_state  
2bc4				endm  
# End of macro CALLMONITOR
2bc4				endif 
2bc4			 
2bc4 18 06			jr .listpush 
2bc6			 
2bc6			;.lnuword:	pop hl 
2bc6			;		call forth_tok_next 
2bc6			;		jp .ldouscan  
2bc6			 
2bc6			.lunotfound:		  
2bc6			 
2bc6			 
2bc6					 
2bc6					FORTH_DSP_POP 
2bc6 cd a9 1e			call macro_forth_dsp_pop 
2bc9				endm 
# End of macro FORTH_DSP_POP
2bc9 21 d2 2b				ld hl, .luno 
2bcc						 
2bcc			 
2bcc			.listpush: 
2bcc cd 68 1c				call forth_push_str 
2bcf			 
2bcf			 
2bcf			 
2bcf					NEXTW 
2bcf c3 63 1f			jp macro_next 
2bd2				endm 
# End of macro NEXTW
2bd2			 
2bd2 .. 00		.luno:    db "Not found",0 
2bdc			 
2bdc			 
2bdc			 
2bdc			 
2bdc			 
2bdc			;		push hl   ; save pointer to start of uword def string 
2bdc			; 
2bdc			;; look for FORTH_EOL_LINE 
2bdc			;		ld a, FORTH_END_BUFFER 
2bdc			;		call strlent 
2bdc			; 
2bdc			;		inc hl		 ; space for coln def 
2bdc			;		inc hl 
2bdc			;		inc hl          ; space for terms 
2bdc			;		inc hl 
2bdc			; 
2bdc			;		ld a, 20   ; TODO get actual length 
2bdc			;		call addatohl    ; include a random amount of room for the uword name 
2bdc			; 
2bdc			;		 
2bdc			;	if DEBUG_FORTH_WORDS 
2bdc			;		DMARK "Lt1" 
2bdc			;		CALLMONITOR 
2bdc			;	endif 
2bdc			;		 
2bdc			; 
2bdc			;; malloc space for the string because we cant change it 
2bdc			; 
2bdc			;		call malloc 
2bdc			;	if DEBUG_FORTH_MALLOC_GUARD 
2bdc			;		push af 
2bdc			;		call ishlzero 
2bdc			;		pop af 
2bdc			;		 
2bdc			;		call z,malloc_error 
2bdc			;	endif 
2bdc			; 
2bdc			;	if DEBUG_FORTH_WORDS 
2bdc			;		DMARK "Lt2" 
2bdc			;		CALLMONITOR 
2bdc			;	endif 
2bdc			;		pop de 
2bdc			;		push hl    ; push the malloc to release later 
2bdc			;		push hl   ;  push back a copy for the later stack push 
2bdc			;		 
2bdc			;; copy the string swapping out the zero terms for spaces 
2bdc			; 
2bdc			;		; de has our source 
2bdc			;		; hl has our dest 
2bdc			; 
2bdc			;; add the coln def 
2bdc			; 
2bdc			;		ld a, ':' 
2bdc			;		ld (hl), a 
2bdc			;		inc hl 
2bdc			;		ld a, ' ' 
2bdc			;		ld (hl), a 
2bdc			;		inc hl 
2bdc			; 
2bdc			;; add the uname word 
2bdc			;		push de   ; save our string for now 
2bdc			;		ex de, hl 
2bdc			; 
2bdc			;		FORTH_DSP_VALUE 
2bdc			;		;v5 FORTH_DSP_VALUE 
2bdc			; 
2bdc			;		inc hl   ; skip type but we know by now this is OK 
2bdc			; 
2bdc			;.luword:	ld a,(hl) 
2bdc			;		cp 0 
2bdc			;		jr z, .luword2 
2bdc			;		ld (de), a 
2bdc			;		inc de 
2bdc			;		inc hl 
2bdc			;		jr .luword 
2bdc			; 
2bdc			;.luword2:	ld a, ' ' 
2bdc			;		ld (de), a 
2bdc			;;		inc hl 
2bdc			;;		inc de 
2bdc			;;		ld (de), a 
2bdc			;;		inc hl 
2bdc			;		inc de 
2bdc			; 
2bdc			;		ex de, hl 
2bdc			;		pop de 
2bdc			;		 
2bdc			;		 
2bdc			; 
2bdc			;; detoken that string and copy it 
2bdc			; 
2bdc			;	if DEBUG_FORTH_WORDS 
2bdc			;		DMARK "Lt2" 
2bdc			;		CALLMONITOR 
2bdc			;	endif 
2bdc			;.ldetok:	ld a, (de) 
2bdc			;		cp FORTH_END_BUFFER 
2bdc			;		jr z, .ldetokend 
2bdc			;		; swap out any zero term for space 
2bdc			;		cp 0 
2bdc			;		jr nz, .ldetoknext 
2bdc			;		ld a, ' ' 
2bdc			; 
2bdc			;	if DEBUG_FORTH_WORDS 
2bdc			;		DMARK "LtS" 
2bdc			;		CALLMONITOR 
2bdc			;	endif 
2bdc			;.ldetoknext:	ld (hl), a 
2bdc			;		inc de 
2bdc			;		inc hl 
2bdc			;		jr .ldetok 
2bdc			; 
2bdc			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2bdc			;		ld (hl), a  
2bdc			; 
2bdc			;; free that temp malloc 
2bdc			; 
2bdc			;		pop hl    
2bdc			; 
2bdc			;	if DEBUG_FORTH_WORDS 
2bdc			;		DMARK "Lt4" 
2bdc			;		CALLMONITOR 
2bdc			;	endif 
2bdc			;		call forth_apushstrhl 
2bdc			; 
2bdc			;		; get rid of temp malloc area 
2bdc			; 
2bdc			;		pop hl 
2bdc			;		call free 
2bdc			; 
2bdc			;		jr .ludone 
2bdc			; 
2bdc			;.lnuword:	pop hl 
2bdc			;		call forth_tok_next 
2bdc			;		jp .ldouscan  
2bdc			; 
2bdc			;.ludone:		 pop hl 
2bdc			; 
2bdc					NEXTW 
2bdc c3 63 1f			jp macro_next 
2bdf				endm 
# End of macro NEXTW
2bdf			 
2bdf			.FORGET: 
2bdf				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2bdf 5d				db WORD_SYS_CORE+73             
2be0 58 2c			dw .NOP            
2be2 07				db 6 + 1 
2be3 .. 00			db "FORGET",0              
2bea				endm 
# End of macro CWHEAD
2bea			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2bea			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2bea			; | |  
2bea			; | | e.g. "MORE" forget 
2bea					if DEBUG_FORTH_WORDS_KEY 
2bea						DMARK "FRG" 
2bea f5				push af  
2beb 3a ff 2b			ld a, (.dmark)  
2bee 32 bd fb			ld (debug_mark),a  
2bf1 3a 00 2c			ld a, (.dmark+1)  
2bf4 32 be fb			ld (debug_mark+1),a  
2bf7 3a 01 2c			ld a, (.dmark+2)  
2bfa 32 bf fb			ld (debug_mark+2),a  
2bfd 18 03			jr .pastdmark  
2bff ..			.dmark: db "FRG"  
2c02 f1			.pastdmark: pop af  
2c03			endm  
# End of macro DMARK
2c03						CALLMONITOR 
2c03 cd 6a 16			call break_point_state  
2c06				endm  
# End of macro CALLMONITOR
2c06					endif 
2c06			 
2c06				; find uword 
2c06			        ; update start of word with "_" 
2c06				; replace uword with deleted flag 
2c06			 
2c06			 
2c06			;	if DEBUG_FORTH_WORDS 
2c06			;		DMARK "FOG" 
2c06			;		CALLMONITOR 
2c06			;	endif 
2c06			 
2c06			 
2c06					; Get ptr to the word we need to look up 
2c06			 
2c06					FORTH_DSP_VALUEHL 
2c06 cd f1 1d			call macro_dsp_valuehl 
2c09				endm 
# End of macro FORTH_DSP_VALUEHL
2c09					;v5 FORTH_DSP_VALUE 
2c09				; TODO type check 
2c09			;		inc hl    ; Skip type check  
2c09 e5					push hl 
2c0a c1					pop bc 
2c0b			;		ex de, hl    ; put into DE 
2c0b			 
2c0b			 
2c0b 21 00 80				ld hl, baseram 
2c0e					;ld hl, baseusermem 
2c0e			 
2c0e				; skip dict stub 
2c0e			;	call forth_tok_next 
2c0e e5			push hl   ; sacreifical push 
2c0f			 
2c0f			.fldouscanm: 
2c0f e1				pop hl 
2c10			.fldouscan: 
2c10			;	if DEBUG_FORTH_WORDS 
2c10			;		DMARK "LSs" 
2c10			;		CALLMONITOR 
2c10			;	endif 
2c10				; skip dict stub 
2c10 cd b4 20				call forth_tok_next 
2c13			 
2c13			 
2c13			; while we have words to look for 
2c13			 
2c13 7e				ld a, (hl)      
2c14			;	if DEBUG_FORTH_WORDS 
2c14			;		DMARK "LSk" 
2c14			;		CALLMONITOR 
2c14			;	endif 
2c14 fe 00				cp WORD_SYS_END 
2c16 ca 52 2c				jp z, .flunotfound 
2c19 fe 01				cp WORD_SYS_UWORD 
2c1b c2 10 2c				jp nz, .fldouscan 
2c1e			 
2c1e			;	if DEBUG_FORTH_WORDS 
2c1e			;		DMARK "LSu" 
2c1e			;		CALLMONITOR 
2c1e			;	endif 
2c1e			 
2c1e					; found a uword but is it the one we want... 
2c1e			 
2c1e c5					push bc     ; uword to find is on bc 
2c1f d1					pop de 
2c20			 
2c20 e5					push hl  ; to save the ptr 
2c21			 
2c21					; skip opcode 
2c21 23					inc hl  
2c22					; skip next ptr 
2c22 23					inc hl  
2c23 23					inc hl 
2c24					; skip len 
2c24 23					inc hl 
2c25			 
2c25			;	if DEBUG_FORTH_WORDS 
2c25			;		DMARK "LSc" 
2c25			;		CALLMONITOR 
2c25			;	endif 
2c25 cd 9c 11				call strcmp 
2c28 c2 0f 2c				jp nz, .fldouscanm 
2c2b			; 
2c2b			; 
2c2b			;; while we have words to look for 
2c2b			; 
2c2b			;.fdouscan:	ld a, (hl)      
2c2b			;	if DEBUG_FORTH_WORDS 
2c2b			;		DMARK "LSs" 
2c2b			;		CALLMONITOR 
2c2b			;	endif 
2c2b			;		cp WORD_SYS_END 
2c2b			;		jp z, .fudone 
2c2b			;		cp WORD_SYS_UWORD 
2c2b			;		jp nz, .fnuword 
2c2b			; 
2c2b			;	if DEBUG_FORTH_WORDS 
2c2b			;		DMARK "FGu" 
2c2b			;		CALLMONITOR 
2c2b			;	endif 
2c2b			; 
2c2b			;		; found a uword but is it the one we want... 
2c2b			; 
2c2b			; 
2c2b			;	        pop de   ; get back the dsp name 
2c2b			;		push de 
2c2b			; 
2c2b			;		push hl  ; to save the ptr 
2c2b			; 
2c2b			;		; skip opcode 
2c2b			;		inc hl  
2c2b			;		; skip next ptr 
2c2b			;		inc hl  
2c2b			;		inc hl 
2c2b			;		; skip len 
2c2b			;		inc hl 
2c2b			; 
2c2b			;	if DEBUG_FORTH_WORDS 
2c2b			;		DMARK "FGc" 
2c2b			;		CALLMONITOR 
2c2b			;	endif 
2c2b			;		call strcmp 
2c2b			;		jp nz, .fnuword 
2c2b			 
2c2b			 
2c2b e1			pop hl 
2c2c			 
2c2c				 
2c2c				if DEBUG_FORTH_WORDS 
2c2c					DMARK "FGm" 
2c2c f5				push af  
2c2d 3a 41 2c			ld a, (.dmark)  
2c30 32 bd fb			ld (debug_mark),a  
2c33 3a 42 2c			ld a, (.dmark+1)  
2c36 32 be fb			ld (debug_mark+1),a  
2c39 3a 43 2c			ld a, (.dmark+2)  
2c3c 32 bf fb			ld (debug_mark+2),a  
2c3f 18 03			jr .pastdmark  
2c41 ..			.dmark: db "FGm"  
2c44 f1			.pastdmark: pop af  
2c45			endm  
# End of macro DMARK
2c45					CALLMONITOR 
2c45 cd 6a 16			call break_point_state  
2c48				endm  
# End of macro CALLMONITOR
2c48				endif 
2c48			 
2c48			 
2c48			 
2c48					; we have a uword so push its name to the stack 
2c48			 
2c48			;	   	push hl  ; save so we can move to next dict block 
2c48			;pop hl 
2c48			 
2c48					; update opcode to deleted 
2c48 3e 03				ld a, WORD_SYS_DELETED 
2c4a 77					ld (hl), a 
2c4b			 
2c4b 23					inc hl  
2c4c					; skip next ptr 
2c4c 23					inc hl  
2c4d 23					inc hl 
2c4e					; skip len 
2c4e 23					inc hl 
2c4f			 
2c4f					; TODO change parser to skip deleted words but for now mark it out 
2c4f 3e 5f				ld a, "_" 
2c51 77					ld  (hl),a 
2c52			 
2c52			;		jr .fudone 
2c52			; 
2c52			;.fnuword:	pop hl 
2c52			;		call forth_tok_next 
2c52			;		jp .fdouscan  
2c52			 
2c52			.flunotfound:		  
2c52			 
2c52			 
2c52					 
2c52					FORTH_DSP_POP 
2c52 cd a9 1e			call macro_forth_dsp_pop 
2c55				endm 
# End of macro FORTH_DSP_POP
2c55			;		ld hl, .luno 
2c55			;.fudone:		 pop hl 
2c55					NEXTW 
2c55 c3 63 1f			jp macro_next 
2c58				endm 
# End of macro NEXTW
2c58			.NOP: 
2c58				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c58 61				db WORD_SYS_CORE+77             
2c59 7f 2c			dw .COMO            
2c5b 04				db 3 + 1 
2c5c .. 00			db "NOP",0              
2c60				endm 
# End of macro CWHEAD
2c60			; | NOP (  --  ) Do nothing | DONE 
2c60					if DEBUG_FORTH_WORDS_KEY 
2c60						DMARK "NOP" 
2c60 f5				push af  
2c61 3a 75 2c			ld a, (.dmark)  
2c64 32 bd fb			ld (debug_mark),a  
2c67 3a 76 2c			ld a, (.dmark+1)  
2c6a 32 be fb			ld (debug_mark+1),a  
2c6d 3a 77 2c			ld a, (.dmark+2)  
2c70 32 bf fb			ld (debug_mark+2),a  
2c73 18 03			jr .pastdmark  
2c75 ..			.dmark: db "NOP"  
2c78 f1			.pastdmark: pop af  
2c79			endm  
# End of macro DMARK
2c79						CALLMONITOR 
2c79 cd 6a 16			call break_point_state  
2c7c				endm  
# End of macro CALLMONITOR
2c7c					endif 
2c7c				       NEXTW 
2c7c c3 63 1f			jp macro_next 
2c7f				endm 
# End of macro NEXTW
2c7f			.COMO: 
2c7f				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c7f 6e				db WORD_SYS_CORE+90             
2c80 d1 2c			dw .COMC            
2c82 02				db 1 + 1 
2c83 .. 00			db "(",0              
2c85				endm 
# End of macro CWHEAD
2c85			; | ( ( -- )  Start of comment | DONE 
2c85			 
2c85			 
2c85 2a a4 f2				ld hl, ( os_tok_ptr) 
2c88 11 cc 2c			ld de, .closepar 
2c8b					 
2c8b					if DEBUG_FORTH_WORDS 
2c8b						DMARK ").." 
2c8b f5				push af  
2c8c 3a a0 2c			ld a, (.dmark)  
2c8f 32 bd fb			ld (debug_mark),a  
2c92 3a a1 2c			ld a, (.dmark+1)  
2c95 32 be fb			ld (debug_mark+1),a  
2c98 3a a2 2c			ld a, (.dmark+2)  
2c9b 32 bf fb			ld (debug_mark+2),a  
2c9e 18 03			jr .pastdmark  
2ca0 ..			.dmark: db ").."  
2ca3 f1			.pastdmark: pop af  
2ca4			endm  
# End of macro DMARK
2ca4						CALLMONITOR 
2ca4 cd 6a 16			call break_point_state  
2ca7				endm  
# End of macro CALLMONITOR
2ca7					endif 
2ca7 cd 7e 20			call findnexttok  
2caa			 
2caa					if DEBUG_FORTH_WORDS 
2caa						DMARK "IF5" 
2caa f5				push af  
2cab 3a bf 2c			ld a, (.dmark)  
2cae 32 bd fb			ld (debug_mark),a  
2cb1 3a c0 2c			ld a, (.dmark+1)  
2cb4 32 be fb			ld (debug_mark+1),a  
2cb7 3a c1 2c			ld a, (.dmark+2)  
2cba 32 bf fb			ld (debug_mark+2),a  
2cbd 18 03			jr .pastdmark  
2cbf ..			.dmark: db "IF5"  
2cc2 f1			.pastdmark: pop af  
2cc3			endm  
# End of macro DMARK
2cc3						CALLMONITOR 
2cc3 cd 6a 16			call break_point_state  
2cc6				endm  
# End of macro CALLMONITOR
2cc6					endif 
2cc6				; replace below with ) exec using tok_ptr 
2cc6 22 a4 f2			ld (os_tok_ptr), hl 
2cc9 c3 f4 1f			jp exec1 
2ccc			 
2ccc .. 00			.closepar:   db ")",0 
2cce			 
2cce				       NEXTW 
2cce c3 63 1f			jp macro_next 
2cd1				endm 
# End of macro NEXTW
2cd1			.COMC: 
2cd1				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2cd1 6f				db WORD_SYS_CORE+91             
2cd2 da 2c			dw .SCRATCH            
2cd4 02				db 1 + 1 
2cd5 .. 00			db ")",0              
2cd7				endm 
# End of macro CWHEAD
2cd7			; | ) ( -- )  End of comment |  DONE  
2cd7				       NEXTW 
2cd7 c3 63 1f			jp macro_next 
2cda				endm 
# End of macro NEXTW
2cda			 
2cda			.SCRATCH: 
2cda				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2cda 6f				db WORD_SYS_CORE+91             
2cdb 15 2d			dw .INC            
2cdd 08				db 7 + 1 
2cde .. 00			db "SCRATCH",0              
2ce6				endm 
# End of macro CWHEAD
2ce6			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ce6			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ce6			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ce6			; | |  
2ce6			; | | e.g.    : score $00 scratch ; 
2ce6			; | |  
2ce6			; | | $00 score ! 
2ce6			; | | $01 score +! 
2ce6			; | |  
2ce6			; | | e.g.   : varword $0a scratch ;  
2ce6			; | | 
2ce6			; | | $8000 varword ! 
2ce6					if DEBUG_FORTH_WORDS_KEY 
2ce6						DMARK "SCR" 
2ce6 f5				push af  
2ce7 3a fb 2c			ld a, (.dmark)  
2cea 32 bd fb			ld (debug_mark),a  
2ced 3a fc 2c			ld a, (.dmark+1)  
2cf0 32 be fb			ld (debug_mark+1),a  
2cf3 3a fd 2c			ld a, (.dmark+2)  
2cf6 32 bf fb			ld (debug_mark+2),a  
2cf9 18 03			jr .pastdmark  
2cfb ..			.dmark: db "SCR"  
2cfe f1			.pastdmark: pop af  
2cff			endm  
# End of macro DMARK
2cff						CALLMONITOR 
2cff cd 6a 16			call break_point_state  
2d02				endm  
# End of macro CALLMONITOR
2d02					endif 
2d02			 
2d02					FORTH_DSP_VALUEHL 
2d02 cd f1 1d			call macro_dsp_valuehl 
2d05				endm 
# End of macro FORTH_DSP_VALUEHL
2d05				 
2d05					FORTH_DSP_POP 
2d05 cd a9 1e			call macro_forth_dsp_pop 
2d08				endm 
# End of macro FORTH_DSP_POP
2d08			 
2d08 7d					ld a, l 
2d09 21 c8 f4				ld hl, os_var_array 
2d0c cd 06 0d				call addatohl 
2d0f			 
2d0f cd fa 1b				call forth_push_numhl 
2d12			 
2d12				       NEXTW 
2d12 c3 63 1f			jp macro_next 
2d15				endm 
# End of macro NEXTW
2d15			 
2d15			.INC: 
2d15				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2d15 6f				db WORD_SYS_CORE+91             
2d16 69 2d			dw .DEC            
2d18 03				db 2 + 1 
2d19 .. 00			db "+!",0              
2d1c				endm 
# End of macro CWHEAD
2d1c			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2d1c					if DEBUG_FORTH_WORDS_KEY 
2d1c						DMARK "+s_" 
2d1c f5				push af  
2d1d 3a 31 2d			ld a, (.dmark)  
2d20 32 bd fb			ld (debug_mark),a  
2d23 3a 32 2d			ld a, (.dmark+1)  
2d26 32 be fb			ld (debug_mark+1),a  
2d29 3a 33 2d			ld a, (.dmark+2)  
2d2c 32 bf fb			ld (debug_mark+2),a  
2d2f 18 03			jr .pastdmark  
2d31 ..			.dmark: db "+s_"  
2d34 f1			.pastdmark: pop af  
2d35			endm  
# End of macro DMARK
2d35						CALLMONITOR 
2d35 cd 6a 16			call break_point_state  
2d38				endm  
# End of macro CALLMONITOR
2d38					endif 
2d38			 
2d38					FORTH_DSP_VALUEHL 
2d38 cd f1 1d			call macro_dsp_valuehl 
2d3b				endm 
# End of macro FORTH_DSP_VALUEHL
2d3b			 
2d3b e5					push hl   ; save address 
2d3c			 
2d3c					FORTH_DSP_POP 
2d3c cd a9 1e			call macro_forth_dsp_pop 
2d3f				endm 
# End of macro FORTH_DSP_POP
2d3f			 
2d3f					FORTH_DSP_VALUEHL 
2d3f cd f1 1d			call macro_dsp_valuehl 
2d42				endm 
# End of macro FORTH_DSP_VALUEHL
2d42			 
2d42					FORTH_DSP_POP 
2d42 cd a9 1e			call macro_forth_dsp_pop 
2d45				endm 
# End of macro FORTH_DSP_POP
2d45			 
2d45					; hl contains value to add to byte at a 
2d45				 
2d45 eb					ex de, hl 
2d46			 
2d46 e1					pop hl 
2d47			 
2d47					if DEBUG_FORTH_WORDS 
2d47						DMARK "INC" 
2d47 f5				push af  
2d48 3a 5c 2d			ld a, (.dmark)  
2d4b 32 bd fb			ld (debug_mark),a  
2d4e 3a 5d 2d			ld a, (.dmark+1)  
2d51 32 be fb			ld (debug_mark+1),a  
2d54 3a 5e 2d			ld a, (.dmark+2)  
2d57 32 bf fb			ld (debug_mark+2),a  
2d5a 18 03			jr .pastdmark  
2d5c ..			.dmark: db "INC"  
2d5f f1			.pastdmark: pop af  
2d60			endm  
# End of macro DMARK
2d60						CALLMONITOR 
2d60 cd 6a 16			call break_point_state  
2d63				endm  
# End of macro CALLMONITOR
2d63					endif 
2d63			 
2d63 7e					ld a,(hl) 
2d64 83					add e 
2d65 77					ld (hl),a 
2d66			 
2d66			 
2d66			 
2d66				       NEXTW 
2d66 c3 63 1f			jp macro_next 
2d69				endm 
# End of macro NEXTW
2d69			 
2d69			.DEC: 
2d69				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d69 6f				db WORD_SYS_CORE+91             
2d6a ba 2d			dw .INC2            
2d6c 03				db 2 + 1 
2d6d .. 00			db "-!",0              
2d70				endm 
# End of macro CWHEAD
2d70			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d70					if DEBUG_FORTH_WORDS_KEY 
2d70						DMARK "-s_" 
2d70 f5				push af  
2d71 3a 85 2d			ld a, (.dmark)  
2d74 32 bd fb			ld (debug_mark),a  
2d77 3a 86 2d			ld a, (.dmark+1)  
2d7a 32 be fb			ld (debug_mark+1),a  
2d7d 3a 87 2d			ld a, (.dmark+2)  
2d80 32 bf fb			ld (debug_mark+2),a  
2d83 18 03			jr .pastdmark  
2d85 ..			.dmark: db "-s_"  
2d88 f1			.pastdmark: pop af  
2d89			endm  
# End of macro DMARK
2d89						CALLMONITOR 
2d89 cd 6a 16			call break_point_state  
2d8c				endm  
# End of macro CALLMONITOR
2d8c					endif 
2d8c			 
2d8c					FORTH_DSP_VALUEHL 
2d8c cd f1 1d			call macro_dsp_valuehl 
2d8f				endm 
# End of macro FORTH_DSP_VALUEHL
2d8f			 
2d8f e5					push hl   ; save address 
2d90			 
2d90					FORTH_DSP_POP 
2d90 cd a9 1e			call macro_forth_dsp_pop 
2d93				endm 
# End of macro FORTH_DSP_POP
2d93			 
2d93					FORTH_DSP_VALUEHL 
2d93 cd f1 1d			call macro_dsp_valuehl 
2d96				endm 
# End of macro FORTH_DSP_VALUEHL
2d96			 
2d96					; hl contains value to add to byte at a 
2d96				 
2d96 eb					ex de, hl 
2d97			 
2d97 e1					pop hl 
2d98			 
2d98					if DEBUG_FORTH_WORDS 
2d98						DMARK "DEC" 
2d98 f5				push af  
2d99 3a ad 2d			ld a, (.dmark)  
2d9c 32 bd fb			ld (debug_mark),a  
2d9f 3a ae 2d			ld a, (.dmark+1)  
2da2 32 be fb			ld (debug_mark+1),a  
2da5 3a af 2d			ld a, (.dmark+2)  
2da8 32 bf fb			ld (debug_mark+2),a  
2dab 18 03			jr .pastdmark  
2dad ..			.dmark: db "DEC"  
2db0 f1			.pastdmark: pop af  
2db1			endm  
# End of macro DMARK
2db1						CALLMONITOR 
2db1 cd 6a 16			call break_point_state  
2db4				endm  
# End of macro CALLMONITOR
2db4					endif 
2db4			 
2db4 7e					ld a,(hl) 
2db5 93					sub e 
2db6 77					ld (hl),a 
2db7			 
2db7			 
2db7			 
2db7				       NEXTW 
2db7 c3 63 1f			jp macro_next 
2dba				endm 
# End of macro NEXTW
2dba			 
2dba			.INC2: 
2dba				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2dba 6f				db WORD_SYS_CORE+91             
2dbb 64 2e			dw .DEC2            
2dbd 04				db 3 + 1 
2dbe .. 00			db "+2!",0              
2dc2				endm 
# End of macro CWHEAD
2dc2			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2dc2			 
2dc2					if DEBUG_FORTH_WORDS_KEY 
2dc2						DMARK "+2s" 
2dc2 f5				push af  
2dc3 3a d7 2d			ld a, (.dmark)  
2dc6 32 bd fb			ld (debug_mark),a  
2dc9 3a d8 2d			ld a, (.dmark+1)  
2dcc 32 be fb			ld (debug_mark+1),a  
2dcf 3a d9 2d			ld a, (.dmark+2)  
2dd2 32 bf fb			ld (debug_mark+2),a  
2dd5 18 03			jr .pastdmark  
2dd7 ..			.dmark: db "+2s"  
2dda f1			.pastdmark: pop af  
2ddb			endm  
# End of macro DMARK
2ddb						CALLMONITOR 
2ddb cd 6a 16			call break_point_state  
2dde				endm  
# End of macro CALLMONITOR
2dde					endif 
2dde			 
2dde					; Address 
2dde			 
2dde					FORTH_DSP_VALUEHL 
2dde cd f1 1d			call macro_dsp_valuehl 
2de1				endm 
# End of macro FORTH_DSP_VALUEHL
2de1			 
2de1 e5					push hl    ; save address 
2de2			 
2de2					; load content into de 
2de2			 
2de2 5e					ld e,(hl) 
2de3 23					inc hl 
2de4 56					ld d, (hl) 
2de5			 
2de5					if DEBUG_FORTH_WORDS 
2de5						DMARK "+2a" 
2de5 f5				push af  
2de6 3a fa 2d			ld a, (.dmark)  
2de9 32 bd fb			ld (debug_mark),a  
2dec 3a fb 2d			ld a, (.dmark+1)  
2def 32 be fb			ld (debug_mark+1),a  
2df2 3a fc 2d			ld a, (.dmark+2)  
2df5 32 bf fb			ld (debug_mark+2),a  
2df8 18 03			jr .pastdmark  
2dfa ..			.dmark: db "+2a"  
2dfd f1			.pastdmark: pop af  
2dfe			endm  
# End of macro DMARK
2dfe						CALLMONITOR 
2dfe cd 6a 16			call break_point_state  
2e01				endm  
# End of macro CALLMONITOR
2e01					endif 
2e01			 
2e01					FORTH_DSP_POP 
2e01 cd a9 1e			call macro_forth_dsp_pop 
2e04				endm 
# End of macro FORTH_DSP_POP
2e04			 
2e04					; Get value to add 
2e04			 
2e04					FORTH_DSP_VALUE 
2e04 cd da 1d			call macro_forth_dsp_value 
2e07				endm 
# End of macro FORTH_DSP_VALUE
2e07			 
2e07					if DEBUG_FORTH_WORDS 
2e07						DMARK "+2v" 
2e07 f5				push af  
2e08 3a 1c 2e			ld a, (.dmark)  
2e0b 32 bd fb			ld (debug_mark),a  
2e0e 3a 1d 2e			ld a, (.dmark+1)  
2e11 32 be fb			ld (debug_mark+1),a  
2e14 3a 1e 2e			ld a, (.dmark+2)  
2e17 32 bf fb			ld (debug_mark+2),a  
2e1a 18 03			jr .pastdmark  
2e1c ..			.dmark: db "+2v"  
2e1f f1			.pastdmark: pop af  
2e20			endm  
# End of macro DMARK
2e20						CALLMONITOR 
2e20 cd 6a 16			call break_point_state  
2e23				endm  
# End of macro CALLMONITOR
2e23					endif 
2e23			 
2e23 19					add hl, de 
2e24			 
2e24					if DEBUG_FORTH_WORDS 
2e24						DMARK "+2+" 
2e24 f5				push af  
2e25 3a 39 2e			ld a, (.dmark)  
2e28 32 bd fb			ld (debug_mark),a  
2e2b 3a 3a 2e			ld a, (.dmark+1)  
2e2e 32 be fb			ld (debug_mark+1),a  
2e31 3a 3b 2e			ld a, (.dmark+2)  
2e34 32 bf fb			ld (debug_mark+2),a  
2e37 18 03			jr .pastdmark  
2e39 ..			.dmark: db "+2+"  
2e3c f1			.pastdmark: pop af  
2e3d			endm  
# End of macro DMARK
2e3d						CALLMONITOR 
2e3d cd 6a 16			call break_point_state  
2e40				endm  
# End of macro CALLMONITOR
2e40					endif 
2e40			 
2e40					; move result to de 
2e40			 
2e40 eb					ex de, hl 
2e41			 
2e41					; Address 
2e41			 
2e41 e1					pop hl 
2e42			 
2e42					; save it back 
2e42			 
2e42 73					ld (hl), e 
2e43 23					inc hl 
2e44 72					ld (hl), d 
2e45			 
2e45					if DEBUG_FORTH_WORDS 
2e45						DMARK "+2e" 
2e45 f5				push af  
2e46 3a 5a 2e			ld a, (.dmark)  
2e49 32 bd fb			ld (debug_mark),a  
2e4c 3a 5b 2e			ld a, (.dmark+1)  
2e4f 32 be fb			ld (debug_mark+1),a  
2e52 3a 5c 2e			ld a, (.dmark+2)  
2e55 32 bf fb			ld (debug_mark+2),a  
2e58 18 03			jr .pastdmark  
2e5a ..			.dmark: db "+2e"  
2e5d f1			.pastdmark: pop af  
2e5e			endm  
# End of macro DMARK
2e5e						CALLMONITOR 
2e5e cd 6a 16			call break_point_state  
2e61				endm  
# End of macro CALLMONITOR
2e61					endif 
2e61			 
2e61			 
2e61			 
2e61			 
2e61			 
2e61				       NEXTW 
2e61 c3 63 1f			jp macro_next 
2e64				endm 
# End of macro NEXTW
2e64			 
2e64			.DEC2: 
2e64				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e64 6f				db WORD_SYS_CORE+91             
2e65 10 2f			dw .GET2            
2e67 04				db 3 + 1 
2e68 .. 00			db "-2!",0              
2e6c				endm 
# End of macro CWHEAD
2e6c			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e6c			 
2e6c			 
2e6c					if DEBUG_FORTH_WORDS_KEY 
2e6c						DMARK "-2s" 
2e6c f5				push af  
2e6d 3a 81 2e			ld a, (.dmark)  
2e70 32 bd fb			ld (debug_mark),a  
2e73 3a 82 2e			ld a, (.dmark+1)  
2e76 32 be fb			ld (debug_mark+1),a  
2e79 3a 83 2e			ld a, (.dmark+2)  
2e7c 32 bf fb			ld (debug_mark+2),a  
2e7f 18 03			jr .pastdmark  
2e81 ..			.dmark: db "-2s"  
2e84 f1			.pastdmark: pop af  
2e85			endm  
# End of macro DMARK
2e85						CALLMONITOR 
2e85 cd 6a 16			call break_point_state  
2e88				endm  
# End of macro CALLMONITOR
2e88					endif 
2e88			 
2e88					; Address 
2e88			 
2e88					FORTH_DSP_VALUEHL 
2e88 cd f1 1d			call macro_dsp_valuehl 
2e8b				endm 
# End of macro FORTH_DSP_VALUEHL
2e8b			 
2e8b e5					push hl    ; save address 
2e8c			 
2e8c					; load content into de 
2e8c			 
2e8c 5e					ld e,(hl) 
2e8d 23					inc hl 
2e8e 56					ld d, (hl) 
2e8f			 
2e8f					if DEBUG_FORTH_WORDS 
2e8f						DMARK "-2a" 
2e8f f5				push af  
2e90 3a a4 2e			ld a, (.dmark)  
2e93 32 bd fb			ld (debug_mark),a  
2e96 3a a5 2e			ld a, (.dmark+1)  
2e99 32 be fb			ld (debug_mark+1),a  
2e9c 3a a6 2e			ld a, (.dmark+2)  
2e9f 32 bf fb			ld (debug_mark+2),a  
2ea2 18 03			jr .pastdmark  
2ea4 ..			.dmark: db "-2a"  
2ea7 f1			.pastdmark: pop af  
2ea8			endm  
# End of macro DMARK
2ea8						CALLMONITOR 
2ea8 cd 6a 16			call break_point_state  
2eab				endm  
# End of macro CALLMONITOR
2eab					endif 
2eab			 
2eab					FORTH_DSP_POP 
2eab cd a9 1e			call macro_forth_dsp_pop 
2eae				endm 
# End of macro FORTH_DSP_POP
2eae			 
2eae					; Get value to remove 
2eae			 
2eae					FORTH_DSP_VALUE 
2eae cd da 1d			call macro_forth_dsp_value 
2eb1				endm 
# End of macro FORTH_DSP_VALUE
2eb1			 
2eb1					if DEBUG_FORTH_WORDS 
2eb1						DMARK "-2v" 
2eb1 f5				push af  
2eb2 3a c6 2e			ld a, (.dmark)  
2eb5 32 bd fb			ld (debug_mark),a  
2eb8 3a c7 2e			ld a, (.dmark+1)  
2ebb 32 be fb			ld (debug_mark+1),a  
2ebe 3a c8 2e			ld a, (.dmark+2)  
2ec1 32 bf fb			ld (debug_mark+2),a  
2ec4 18 03			jr .pastdmark  
2ec6 ..			.dmark: db "-2v"  
2ec9 f1			.pastdmark: pop af  
2eca			endm  
# End of macro DMARK
2eca						CALLMONITOR 
2eca cd 6a 16			call break_point_state  
2ecd				endm  
# End of macro CALLMONITOR
2ecd					endif 
2ecd			 
2ecd eb					ex de, hl 
2ece ed 52				sbc hl, de 
2ed0			 
2ed0					if DEBUG_FORTH_WORDS 
2ed0						DMARK "-2d" 
2ed0 f5				push af  
2ed1 3a e5 2e			ld a, (.dmark)  
2ed4 32 bd fb			ld (debug_mark),a  
2ed7 3a e6 2e			ld a, (.dmark+1)  
2eda 32 be fb			ld (debug_mark+1),a  
2edd 3a e7 2e			ld a, (.dmark+2)  
2ee0 32 bf fb			ld (debug_mark+2),a  
2ee3 18 03			jr .pastdmark  
2ee5 ..			.dmark: db "-2d"  
2ee8 f1			.pastdmark: pop af  
2ee9			endm  
# End of macro DMARK
2ee9						CALLMONITOR 
2ee9 cd 6a 16			call break_point_state  
2eec				endm  
# End of macro CALLMONITOR
2eec					endif 
2eec			 
2eec					; move result to de 
2eec			 
2eec eb					ex de, hl 
2eed			 
2eed					; Address 
2eed			 
2eed e1					pop hl 
2eee			 
2eee					; save it back 
2eee			 
2eee 73					ld (hl), e 
2eef 23					inc hl 
2ef0 72					ld (hl), d 
2ef1			 
2ef1					if DEBUG_FORTH_WORDS 
2ef1						DMARK "-2e" 
2ef1 f5				push af  
2ef2 3a 06 2f			ld a, (.dmark)  
2ef5 32 bd fb			ld (debug_mark),a  
2ef8 3a 07 2f			ld a, (.dmark+1)  
2efb 32 be fb			ld (debug_mark+1),a  
2efe 3a 08 2f			ld a, (.dmark+2)  
2f01 32 bf fb			ld (debug_mark+2),a  
2f04 18 03			jr .pastdmark  
2f06 ..			.dmark: db "-2e"  
2f09 f1			.pastdmark: pop af  
2f0a			endm  
# End of macro DMARK
2f0a						CALLMONITOR 
2f0a cd 6a 16			call break_point_state  
2f0d				endm  
# End of macro CALLMONITOR
2f0d					endif 
2f0d			 
2f0d			 
2f0d			 
2f0d			 
2f0d			 
2f0d				       NEXTW 
2f0d c3 63 1f			jp macro_next 
2f10				endm 
# End of macro NEXTW
2f10			.GET2: 
2f10				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2f10 6f				db WORD_SYS_CORE+91             
2f11 40 2f			dw .BANG2            
2f13 03				db 2 + 1 
2f14 .. 00			db "2@",0              
2f17				endm 
# End of macro CWHEAD
2f17			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2f17					if DEBUG_FORTH_WORDS_KEY 
2f17						DMARK "2A_" 
2f17 f5				push af  
2f18 3a 2c 2f			ld a, (.dmark)  
2f1b 32 bd fb			ld (debug_mark),a  
2f1e 3a 2d 2f			ld a, (.dmark+1)  
2f21 32 be fb			ld (debug_mark+1),a  
2f24 3a 2e 2f			ld a, (.dmark+2)  
2f27 32 bf fb			ld (debug_mark+2),a  
2f2a 18 03			jr .pastdmark  
2f2c ..			.dmark: db "2A_"  
2f2f f1			.pastdmark: pop af  
2f30			endm  
# End of macro DMARK
2f30						CALLMONITOR 
2f30 cd 6a 16			call break_point_state  
2f33				endm  
# End of macro CALLMONITOR
2f33					endif 
2f33			 
2f33					FORTH_DSP_VALUEHL 
2f33 cd f1 1d			call macro_dsp_valuehl 
2f36				endm 
# End of macro FORTH_DSP_VALUEHL
2f36			 
2f36 5e					ld e, (hl) 
2f37 23					inc hl 
2f38 56					ld d, (hl) 
2f39			 
2f39 eb					ex de, hl 
2f3a			 
2f3a cd fa 1b				call forth_push_numhl 
2f3d			 
2f3d				       NEXTW 
2f3d c3 63 1f			jp macro_next 
2f40				endm 
# End of macro NEXTW
2f40			.BANG2: 
2f40				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2f40 6f				db WORD_SYS_CORE+91             
2f41 78 2f			dw .CONFIG            
2f43 03				db 2 + 1 
2f44 .. 00			db "2!",0              
2f47				endm 
# End of macro CWHEAD
2f47			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f47					if DEBUG_FORTH_WORDS_KEY 
2f47						DMARK "2S_" 
2f47 f5				push af  
2f48 3a 5c 2f			ld a, (.dmark)  
2f4b 32 bd fb			ld (debug_mark),a  
2f4e 3a 5d 2f			ld a, (.dmark+1)  
2f51 32 be fb			ld (debug_mark+1),a  
2f54 3a 5e 2f			ld a, (.dmark+2)  
2f57 32 bf fb			ld (debug_mark+2),a  
2f5a 18 03			jr .pastdmark  
2f5c ..			.dmark: db "2S_"  
2f5f f1			.pastdmark: pop af  
2f60			endm  
# End of macro DMARK
2f60						CALLMONITOR 
2f60 cd 6a 16			call break_point_state  
2f63				endm  
# End of macro CALLMONITOR
2f63					endif 
2f63			 
2f63					FORTH_DSP_VALUEHL 
2f63 cd f1 1d			call macro_dsp_valuehl 
2f66				endm 
# End of macro FORTH_DSP_VALUEHL
2f66			 
2f66 e5					push hl   ; save address 
2f67			 
2f67			 
2f67					FORTH_DSP_POP 
2f67 cd a9 1e			call macro_forth_dsp_pop 
2f6a				endm 
# End of macro FORTH_DSP_POP
2f6a			 
2f6a					 
2f6a					FORTH_DSP_VALUEHL 
2f6a cd f1 1d			call macro_dsp_valuehl 
2f6d				endm 
# End of macro FORTH_DSP_VALUEHL
2f6d			 
2f6d					FORTH_DSP_POP 
2f6d cd a9 1e			call macro_forth_dsp_pop 
2f70				endm 
# End of macro FORTH_DSP_POP
2f70			 
2f70 eb					ex de, hl    ; value now in de 
2f71			 
2f71 e1					pop hl 
2f72			 
2f72 73					ld (hl), e 
2f73			 
2f73 23					inc hl 
2f74			 
2f74 72					ld (hl), d 
2f75			 
2f75			 
2f75				       NEXTW 
2f75 c3 63 1f			jp macro_next 
2f78				endm 
# End of macro NEXTW
2f78			.CONFIG: 
2f78				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f78 6f				db WORD_SYS_CORE+91             
2f79 89 2f			dw .ENDCORE            
2f7b 07				db 6 + 1 
2f7c .. 00			db "CONFIG",0              
2f83				endm 
# End of macro CWHEAD
2f83			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2f83			 
2f83 cd 66 13				call config 
2f86					NEXTW 
2f86 c3 63 1f			jp macro_next 
2f89				endm 
# End of macro NEXTW
2f89			.ENDCORE: 
2f89			 
2f89			; eof 
2f89			 
2f89			 
# End of file forth_words_core.asm
2f89			include "forth_words_flow.asm" 
2f89			 
2f89			; | ## Program Flow Words 
2f89			 
2f89			.IF: 
2f89				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f89 1e				db WORD_SYS_CORE+10             
2f8a 7e 30			dw .THEN            
2f8c 03				db 2 + 1 
2f8d .. 00			db "IF",0              
2f90				endm 
# End of macro CWHEAD
2f90			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f90			; 
2f90					if DEBUG_FORTH_WORDS_KEY 
2f90						DMARK "IF." 
2f90 f5				push af  
2f91 3a a5 2f			ld a, (.dmark)  
2f94 32 bd fb			ld (debug_mark),a  
2f97 3a a6 2f			ld a, (.dmark+1)  
2f9a 32 be fb			ld (debug_mark+1),a  
2f9d 3a a7 2f			ld a, (.dmark+2)  
2fa0 32 bf fb			ld (debug_mark+2),a  
2fa3 18 03			jr .pastdmark  
2fa5 ..			.dmark: db "IF."  
2fa8 f1			.pastdmark: pop af  
2fa9			endm  
# End of macro DMARK
2fa9						CALLMONITOR 
2fa9 cd 6a 16			call break_point_state  
2fac				endm  
# End of macro CALLMONITOR
2fac					endif 
2fac			; eval TOS 
2fac			 
2fac				FORTH_DSP_VALUEHL 
2fac cd f1 1d			call macro_dsp_valuehl 
2faf				endm 
# End of macro FORTH_DSP_VALUEHL
2faf			 
2faf			;	push hl 
2faf				FORTH_DSP_POP 
2faf cd a9 1e			call macro_forth_dsp_pop 
2fb2				endm 
# End of macro FORTH_DSP_POP
2fb2			;	pop hl 
2fb2			 
2fb2					if DEBUG_FORTH_WORDS 
2fb2						DMARK "IF1" 
2fb2 f5				push af  
2fb3 3a c7 2f			ld a, (.dmark)  
2fb6 32 bd fb			ld (debug_mark),a  
2fb9 3a c8 2f			ld a, (.dmark+1)  
2fbc 32 be fb			ld (debug_mark+1),a  
2fbf 3a c9 2f			ld a, (.dmark+2)  
2fc2 32 bf fb			ld (debug_mark+2),a  
2fc5 18 03			jr .pastdmark  
2fc7 ..			.dmark: db "IF1"  
2fca f1			.pastdmark: pop af  
2fcb			endm  
# End of macro DMARK
2fcb						CALLMONITOR 
2fcb cd 6a 16			call break_point_state  
2fce				endm  
# End of macro CALLMONITOR
2fce					endif 
2fce b7				or a        ; clear carry flag 
2fcf 11 00 00			ld de, 0 
2fd2 eb				ex de,hl 
2fd3 ed 52			sbc hl, de 
2fd5 c2 5f 30			jp nz, .iftrue 
2fd8			 
2fd8					if DEBUG_FORTH_WORDS 
2fd8						DMARK "IF2" 
2fd8 f5				push af  
2fd9 3a ed 2f			ld a, (.dmark)  
2fdc 32 bd fb			ld (debug_mark),a  
2fdf 3a ee 2f			ld a, (.dmark+1)  
2fe2 32 be fb			ld (debug_mark+1),a  
2fe5 3a ef 2f			ld a, (.dmark+2)  
2fe8 32 bf fb			ld (debug_mark+2),a  
2feb 18 03			jr .pastdmark  
2fed ..			.dmark: db "IF2"  
2ff0 f1			.pastdmark: pop af  
2ff1			endm  
# End of macro DMARK
2ff1						CALLMONITOR 
2ff1 cd 6a 16			call break_point_state  
2ff4				endm  
# End of macro CALLMONITOR
2ff4					endif 
2ff4			 
2ff4			; if not true then skip to THEN 
2ff4			 
2ff4				; TODO get tok_ptr 
2ff4				; TODO consume toks until we get to THEN 
2ff4			 
2ff4 2a a4 f2			ld hl, (os_tok_ptr) 
2ff7					if DEBUG_FORTH_WORDS 
2ff7						DMARK "IF3" 
2ff7 f5				push af  
2ff8 3a 0c 30			ld a, (.dmark)  
2ffb 32 bd fb			ld (debug_mark),a  
2ffe 3a 0d 30			ld a, (.dmark+1)  
3001 32 be fb			ld (debug_mark+1),a  
3004 3a 0e 30			ld a, (.dmark+2)  
3007 32 bf fb			ld (debug_mark+2),a  
300a 18 03			jr .pastdmark  
300c ..			.dmark: db "IF3"  
300f f1			.pastdmark: pop af  
3010			endm  
# End of macro DMARK
3010						CALLMONITOR 
3010 cd 6a 16			call break_point_state  
3013				endm  
# End of macro CALLMONITOR
3013						 
3013					endif 
3013 11 5a 30			ld de, .ifthen 
3016					if DEBUG_FORTH_WORDS 
3016						DMARK "IF4" 
3016 f5				push af  
3017 3a 2b 30			ld a, (.dmark)  
301a 32 bd fb			ld (debug_mark),a  
301d 3a 2c 30			ld a, (.dmark+1)  
3020 32 be fb			ld (debug_mark+1),a  
3023 3a 2d 30			ld a, (.dmark+2)  
3026 32 bf fb			ld (debug_mark+2),a  
3029 18 03			jr .pastdmark  
302b ..			.dmark: db "IF4"  
302e f1			.pastdmark: pop af  
302f			endm  
# End of macro DMARK
302f						CALLMONITOR 
302f cd 6a 16			call break_point_state  
3032				endm  
# End of macro CALLMONITOR
3032					endif 
3032 cd 7e 20			call findnexttok  
3035			 
3035					if DEBUG_FORTH_WORDS 
3035						DMARK "IF5" 
3035 f5				push af  
3036 3a 4a 30			ld a, (.dmark)  
3039 32 bd fb			ld (debug_mark),a  
303c 3a 4b 30			ld a, (.dmark+1)  
303f 32 be fb			ld (debug_mark+1),a  
3042 3a 4c 30			ld a, (.dmark+2)  
3045 32 bf fb			ld (debug_mark+2),a  
3048 18 03			jr .pastdmark  
304a ..			.dmark: db "IF5"  
304d f1			.pastdmark: pop af  
304e			endm  
# End of macro DMARK
304e						CALLMONITOR 
304e cd 6a 16			call break_point_state  
3051				endm  
# End of macro CALLMONITOR
3051					endif 
3051				; TODO replace below with ; exec using tok_ptr 
3051 22 a4 f2			ld (os_tok_ptr), hl 
3054 c3 f4 1f			jp exec1 
3057				NEXTW 
3057 c3 63 1f			jp macro_next 
305a				endm 
# End of macro NEXTW
305a			 
305a .. 00		.ifthen:  db "THEN",0 
305f			 
305f			.iftrue:		 
305f				; Exec next words normally 
305f			 
305f				; if true then exec following IF as normal 
305f					if DEBUG_FORTH_WORDS 
305f						DMARK "IFT" 
305f f5				push af  
3060 3a 74 30			ld a, (.dmark)  
3063 32 bd fb			ld (debug_mark),a  
3066 3a 75 30			ld a, (.dmark+1)  
3069 32 be fb			ld (debug_mark+1),a  
306c 3a 76 30			ld a, (.dmark+2)  
306f 32 bf fb			ld (debug_mark+2),a  
3072 18 03			jr .pastdmark  
3074 ..			.dmark: db "IFT"  
3077 f1			.pastdmark: pop af  
3078			endm  
# End of macro DMARK
3078						CALLMONITOR 
3078 cd 6a 16			call break_point_state  
307b				endm  
# End of macro CALLMONITOR
307b					endif 
307b			 
307b					NEXTW 
307b c3 63 1f			jp macro_next 
307e				endm 
# End of macro NEXTW
307e			.THEN: 
307e				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
307e 1f				db WORD_SYS_CORE+11             
307f a6 30			dw .ELSE            
3081 05				db 4 + 1 
3082 .. 00			db "THEN",0              
3087				endm 
# End of macro CWHEAD
3087			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3087					if DEBUG_FORTH_WORDS_KEY 
3087						DMARK "THN" 
3087 f5				push af  
3088 3a 9c 30			ld a, (.dmark)  
308b 32 bd fb			ld (debug_mark),a  
308e 3a 9d 30			ld a, (.dmark+1)  
3091 32 be fb			ld (debug_mark+1),a  
3094 3a 9e 30			ld a, (.dmark+2)  
3097 32 bf fb			ld (debug_mark+2),a  
309a 18 03			jr .pastdmark  
309c ..			.dmark: db "THN"  
309f f1			.pastdmark: pop af  
30a0			endm  
# End of macro DMARK
30a0						CALLMONITOR 
30a0 cd 6a 16			call break_point_state  
30a3				endm  
# End of macro CALLMONITOR
30a3					endif 
30a3					NEXTW 
30a3 c3 63 1f			jp macro_next 
30a6				endm 
# End of macro NEXTW
30a6			.ELSE: 
30a6				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
30a6 20				db WORD_SYS_CORE+12             
30a7 ce 30			dw .DO            
30a9 03				db 2 + 1 
30aa .. 00			db "ELSE",0              
30af				endm 
# End of macro CWHEAD
30af			; | ELSE ( -- ) Not supported - does nothing | TODO 
30af			 
30af					if DEBUG_FORTH_WORDS_KEY 
30af						DMARK "ELS" 
30af f5				push af  
30b0 3a c4 30			ld a, (.dmark)  
30b3 32 bd fb			ld (debug_mark),a  
30b6 3a c5 30			ld a, (.dmark+1)  
30b9 32 be fb			ld (debug_mark+1),a  
30bc 3a c6 30			ld a, (.dmark+2)  
30bf 32 bf fb			ld (debug_mark+2),a  
30c2 18 03			jr .pastdmark  
30c4 ..			.dmark: db "ELS"  
30c7 f1			.pastdmark: pop af  
30c8			endm  
# End of macro DMARK
30c8						CALLMONITOR 
30c8 cd 6a 16			call break_point_state  
30cb				endm  
# End of macro CALLMONITOR
30cb					endif 
30cb			 
30cb			 
30cb					NEXTW 
30cb c3 63 1f			jp macro_next 
30ce				endm 
# End of macro NEXTW
30ce			.DO: 
30ce				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30ce 21				db WORD_SYS_CORE+13             
30cf f5 31			dw .LOOP            
30d1 03				db 2 + 1 
30d2 .. 00			db "DO",0              
30d5				endm 
# End of macro CWHEAD
30d5			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30d5			 
30d5					if DEBUG_FORTH_WORDS_KEY 
30d5						DMARK "DO." 
30d5 f5				push af  
30d6 3a ea 30			ld a, (.dmark)  
30d9 32 bd fb			ld (debug_mark),a  
30dc 3a eb 30			ld a, (.dmark+1)  
30df 32 be fb			ld (debug_mark+1),a  
30e2 3a ec 30			ld a, (.dmark+2)  
30e5 32 bf fb			ld (debug_mark+2),a  
30e8 18 03			jr .pastdmark  
30ea ..			.dmark: db "DO."  
30ed f1			.pastdmark: pop af  
30ee			endm  
# End of macro DMARK
30ee						CALLMONITOR 
30ee cd 6a 16			call break_point_state  
30f1				endm  
# End of macro CALLMONITOR
30f1					endif 
30f1			;  push pc to rsp stack past the DO 
30f1			 
30f1 2a a4 f2				ld hl, (os_tok_ptr) 
30f4 23					inc hl   ; D 
30f5 23					inc hl  ; O 
30f6 23					inc hl   ; null 
30f7					if DEBUG_FORTH_WORDS 
30f7						DMARK "DO2" 
30f7 f5				push af  
30f8 3a 0c 31			ld a, (.dmark)  
30fb 32 bd fb			ld (debug_mark),a  
30fe 3a 0d 31			ld a, (.dmark+1)  
3101 32 be fb			ld (debug_mark+1),a  
3104 3a 0e 31			ld a, (.dmark+2)  
3107 32 bf fb			ld (debug_mark+2),a  
310a 18 03			jr .pastdmark  
310c ..			.dmark: db "DO2"  
310f f1			.pastdmark: pop af  
3110			endm  
# End of macro DMARK
3110						CALLMONITOR 
3110 cd 6a 16			call break_point_state  
3113				endm  
# End of macro CALLMONITOR
3113					endif 
3113					FORTH_RSP_NEXT 
3113 cd a1 1b			call macro_forth_rsp_next 
3116				endm 
# End of macro FORTH_RSP_NEXT
3116					if DEBUG_FORTH_WORDS 
3116						DMARK "DO3" 
3116 f5				push af  
3117 3a 2b 31			ld a, (.dmark)  
311a 32 bd fb			ld (debug_mark),a  
311d 3a 2c 31			ld a, (.dmark+1)  
3120 32 be fb			ld (debug_mark+1),a  
3123 3a 2d 31			ld a, (.dmark+2)  
3126 32 bf fb			ld (debug_mark+2),a  
3129 18 03			jr .pastdmark  
312b ..			.dmark: db "DO3"  
312e f1			.pastdmark: pop af  
312f			endm  
# End of macro DMARK
312f						CALLMONITOR 
312f cd 6a 16			call break_point_state  
3132				endm  
# End of macro CALLMONITOR
3132					endif 
3132			 
3132					;if DEBUG_FORTH_WORDS 
3132				;		push hl 
3132			;		endif  
3132			 
3132			; get counters from data stack 
3132			 
3132			 
3132					FORTH_DSP_VALUEHL 
3132 cd f1 1d			call macro_dsp_valuehl 
3135				endm 
# End of macro FORTH_DSP_VALUEHL
3135 e5					push hl		 ; hl now has starting counter which needs to be tos 
3136			 
3136					if DEBUG_FORTH_WORDS 
3136						DMARK "DO4" 
3136 f5				push af  
3137 3a 4b 31			ld a, (.dmark)  
313a 32 bd fb			ld (debug_mark),a  
313d 3a 4c 31			ld a, (.dmark+1)  
3140 32 be fb			ld (debug_mark+1),a  
3143 3a 4d 31			ld a, (.dmark+2)  
3146 32 bf fb			ld (debug_mark+2),a  
3149 18 03			jr .pastdmark  
314b ..			.dmark: db "DO4"  
314e f1			.pastdmark: pop af  
314f			endm  
# End of macro DMARK
314f						CALLMONITOR 
314f cd 6a 16			call break_point_state  
3152				endm  
# End of macro CALLMONITOR
3152					endif 
3152					FORTH_DSP_POP 
3152 cd a9 1e			call macro_forth_dsp_pop 
3155				endm 
# End of macro FORTH_DSP_POP
3155			 
3155					if DEBUG_FORTH_WORDS 
3155						DMARK "DO5" 
3155 f5				push af  
3156 3a 6a 31			ld a, (.dmark)  
3159 32 bd fb			ld (debug_mark),a  
315c 3a 6b 31			ld a, (.dmark+1)  
315f 32 be fb			ld (debug_mark+1),a  
3162 3a 6c 31			ld a, (.dmark+2)  
3165 32 bf fb			ld (debug_mark+2),a  
3168 18 03			jr .pastdmark  
316a ..			.dmark: db "DO5"  
316d f1			.pastdmark: pop af  
316e			endm  
# End of macro DMARK
316e						CALLMONITOR 
316e cd 6a 16			call break_point_state  
3171				endm  
# End of macro CALLMONITOR
3171					endif 
3171			 
3171					FORTH_DSP_VALUEHL 
3171 cd f1 1d			call macro_dsp_valuehl 
3174				endm 
# End of macro FORTH_DSP_VALUEHL
3174			;		push hl		 ; hl now has starting limit counter 
3174			 
3174					if DEBUG_FORTH_WORDS 
3174						DMARK "DO6" 
3174 f5				push af  
3175 3a 89 31			ld a, (.dmark)  
3178 32 bd fb			ld (debug_mark),a  
317b 3a 8a 31			ld a, (.dmark+1)  
317e 32 be fb			ld (debug_mark+1),a  
3181 3a 8b 31			ld a, (.dmark+2)  
3184 32 bf fb			ld (debug_mark+2),a  
3187 18 03			jr .pastdmark  
3189 ..			.dmark: db "DO6"  
318c f1			.pastdmark: pop af  
318d			endm  
# End of macro DMARK
318d						CALLMONITOR 
318d cd 6a 16			call break_point_state  
3190				endm  
# End of macro CALLMONITOR
3190					endif 
3190					FORTH_DSP_POP 
3190 cd a9 1e			call macro_forth_dsp_pop 
3193				endm 
# End of macro FORTH_DSP_POP
3193			 
3193			; put counters on the loop stack 
3193			 
3193			;		pop hl			 ; limit counter 
3193 d1					pop de			; start counter 
3194			 
3194					; push limit counter 
3194			 
3194					if DEBUG_FORTH_WORDS 
3194						DMARK "DO7" 
3194 f5				push af  
3195 3a a9 31			ld a, (.dmark)  
3198 32 bd fb			ld (debug_mark),a  
319b 3a aa 31			ld a, (.dmark+1)  
319e 32 be fb			ld (debug_mark+1),a  
31a1 3a ab 31			ld a, (.dmark+2)  
31a4 32 bf fb			ld (debug_mark+2),a  
31a7 18 03			jr .pastdmark  
31a9 ..			.dmark: db "DO7"  
31ac f1			.pastdmark: pop af  
31ad			endm  
# End of macro DMARK
31ad						CALLMONITOR 
31ad cd 6a 16			call break_point_state  
31b0				endm  
# End of macro CALLMONITOR
31b0					endif 
31b0					FORTH_LOOP_NEXT 
31b0 cd 22 1e			call macro_forth_loop_next 
31b3				endm 
# End of macro FORTH_LOOP_NEXT
31b3			 
31b3					; push start counter 
31b3			 
31b3 eb					ex de, hl 
31b4					if DEBUG_FORTH_WORDS 
31b4						DMARK "DO7" 
31b4 f5				push af  
31b5 3a c9 31			ld a, (.dmark)  
31b8 32 bd fb			ld (debug_mark),a  
31bb 3a ca 31			ld a, (.dmark+1)  
31be 32 be fb			ld (debug_mark+1),a  
31c1 3a cb 31			ld a, (.dmark+2)  
31c4 32 bf fb			ld (debug_mark+2),a  
31c7 18 03			jr .pastdmark  
31c9 ..			.dmark: db "DO7"  
31cc f1			.pastdmark: pop af  
31cd			endm  
# End of macro DMARK
31cd						CALLMONITOR 
31cd cd 6a 16			call break_point_state  
31d0				endm  
# End of macro CALLMONITOR
31d0					endif 
31d0					FORTH_LOOP_NEXT 
31d0 cd 22 1e			call macro_forth_loop_next 
31d3				endm 
# End of macro FORTH_LOOP_NEXT
31d3			 
31d3			 
31d3					; init first round of I counter 
31d3			 
31d3 22 c8 f2				ld (os_current_i), hl 
31d6			 
31d6					if DEBUG_FORTH_WORDS 
31d6						DMARK "DO8" 
31d6 f5				push af  
31d7 3a eb 31			ld a, (.dmark)  
31da 32 bd fb			ld (debug_mark),a  
31dd 3a ec 31			ld a, (.dmark+1)  
31e0 32 be fb			ld (debug_mark+1),a  
31e3 3a ed 31			ld a, (.dmark+2)  
31e6 32 bf fb			ld (debug_mark+2),a  
31e9 18 03			jr .pastdmark  
31eb ..			.dmark: db "DO8"  
31ee f1			.pastdmark: pop af  
31ef			endm  
# End of macro DMARK
31ef						CALLMONITOR 
31ef cd 6a 16			call break_point_state  
31f2				endm  
# End of macro CALLMONITOR
31f2					endif 
31f2			 
31f2					NEXTW 
31f2 c3 63 1f			jp macro_next 
31f5				endm 
# End of macro NEXTW
31f5			.LOOP: 
31f5				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31f5 22				db WORD_SYS_CORE+14             
31f6 0d 33			dw .I            
31f8 05				db 4 + 1 
31f9 .. 00			db "LOOP",0              
31fe				endm 
# End of macro CWHEAD
31fe			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31fe			 
31fe				; pop tos as current loop count to hl 
31fe			 
31fe				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31fe			 
31fe				FORTH_LOOP_TOS 
31fe cd 55 1e			call macro_forth_loop_tos 
3201				endm 
# End of macro FORTH_LOOP_TOS
3201 e5				push hl 
3202			 
3202					if DEBUG_FORTH_WORDS_KEY 
3202						DMARK "LOP" 
3202 f5				push af  
3203 3a 17 32			ld a, (.dmark)  
3206 32 bd fb			ld (debug_mark),a  
3209 3a 18 32			ld a, (.dmark+1)  
320c 32 be fb			ld (debug_mark+1),a  
320f 3a 19 32			ld a, (.dmark+2)  
3212 32 bf fb			ld (debug_mark+2),a  
3215 18 03			jr .pastdmark  
3217 ..			.dmark: db "LOP"  
321a f1			.pastdmark: pop af  
321b			endm  
# End of macro DMARK
321b						CALLMONITOR 
321b cd 6a 16			call break_point_state  
321e				endm  
# End of macro CALLMONITOR
321e					endif 
321e				; next item on the stack is the limit. get it 
321e			 
321e			 
321e				FORTH_LOOP_POP 
321e cd 5f 1e			call macro_forth_loop_pop 
3221				endm 
# End of macro FORTH_LOOP_POP
3221			 
3221				FORTH_LOOP_TOS 
3221 cd 55 1e			call macro_forth_loop_tos 
3224				endm 
# End of macro FORTH_LOOP_TOS
3224			 
3224 d1				pop de		 ; de = i, hl = limit 
3225			 
3225					if DEBUG_FORTH_WORDS 
3225						DMARK "LP1" 
3225 f5				push af  
3226 3a 3a 32			ld a, (.dmark)  
3229 32 bd fb			ld (debug_mark),a  
322c 3a 3b 32			ld a, (.dmark+1)  
322f 32 be fb			ld (debug_mark+1),a  
3232 3a 3c 32			ld a, (.dmark+2)  
3235 32 bf fb			ld (debug_mark+2),a  
3238 18 03			jr .pastdmark  
323a ..			.dmark: db "LP1"  
323d f1			.pastdmark: pop af  
323e			endm  
# End of macro DMARK
323e						CALLMONITOR 
323e cd 6a 16			call break_point_state  
3241				endm  
# End of macro CALLMONITOR
3241					endif 
3241			 
3241				; go back to previous word 
3241			 
3241 d5				push de    ; save I for inc later 
3242			 
3242			 
3242				; get limit 
3242				;  is I at limit? 
3242			 
3242			 
3242					if DEBUG_FORTH_WORDS 
3242						DMARK "LP1" 
3242 f5				push af  
3243 3a 57 32			ld a, (.dmark)  
3246 32 bd fb			ld (debug_mark),a  
3249 3a 58 32			ld a, (.dmark+1)  
324c 32 be fb			ld (debug_mark+1),a  
324f 3a 59 32			ld a, (.dmark+2)  
3252 32 bf fb			ld (debug_mark+2),a  
3255 18 03			jr .pastdmark  
3257 ..			.dmark: db "LP1"  
325a f1			.pastdmark: pop af  
325b			endm  
# End of macro DMARK
325b						CALLMONITOR 
325b cd 6a 16			call break_point_state  
325e				endm  
# End of macro CALLMONITOR
325e					endif 
325e			 
325e ed 52			sbc hl, de 
3260			 
3260			 
3260				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3260			 
3260 20 26				jr nz, .loopnotdone 
3262			 
3262 e1				pop hl   ; get rid of saved I 
3263				FORTH_LOOP_POP     ; get rid of limit 
3263 cd 5f 1e			call macro_forth_loop_pop 
3266				endm 
# End of macro FORTH_LOOP_POP
3266			 
3266				FORTH_RSP_POP     ; get rid of DO ptr 
3266 cd c2 1b			call macro_forth_rsp_pop 
3269				endm 
# End of macro FORTH_RSP_POP
3269			 
3269			if DEBUG_FORTH_WORDS 
3269						DMARK "LP>" 
3269 f5				push af  
326a 3a 7e 32			ld a, (.dmark)  
326d 32 bd fb			ld (debug_mark),a  
3270 3a 7f 32			ld a, (.dmark+1)  
3273 32 be fb			ld (debug_mark+1),a  
3276 3a 80 32			ld a, (.dmark+2)  
3279 32 bf fb			ld (debug_mark+2),a  
327c 18 03			jr .pastdmark  
327e ..			.dmark: db "LP>"  
3281 f1			.pastdmark: pop af  
3282			endm  
# End of macro DMARK
3282				CALLMONITOR 
3282 cd 6a 16			call break_point_state  
3285				endm  
# End of macro CALLMONITOR
3285			endif 
3285			 
3285					NEXTW 
3285 c3 63 1f			jp macro_next 
3288				endm 
# End of macro NEXTW
3288				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3288			 
3288			.loopnotdone: 
3288			 
3288 e1				pop hl    ; get I 
3289 23				inc hl 
328a			 
328a			   	; save new I 
328a			 
328a			 
328a					; set I counter 
328a			 
328a 22 c8 f2				ld (os_current_i), hl 
328d			 
328d					if DEBUG_FORTH_WORDS 
328d						DMARK "LPN" 
328d f5				push af  
328e 3a a2 32			ld a, (.dmark)  
3291 32 bd fb			ld (debug_mark),a  
3294 3a a3 32			ld a, (.dmark+1)  
3297 32 be fb			ld (debug_mark+1),a  
329a 3a a4 32			ld a, (.dmark+2)  
329d 32 bf fb			ld (debug_mark+2),a  
32a0 18 03			jr .pastdmark  
32a2 ..			.dmark: db "LPN"  
32a5 f1			.pastdmark: pop af  
32a6			endm  
# End of macro DMARK
32a6					CALLMONITOR 
32a6 cd 6a 16			call break_point_state  
32a9				endm  
# End of macro CALLMONITOR
32a9					endif 
32a9					 
32a9				FORTH_LOOP_NEXT 
32a9 cd 22 1e			call macro_forth_loop_next 
32ac				endm 
# End of macro FORTH_LOOP_NEXT
32ac			 
32ac			 
32ac					if DEBUG_FORTH_WORDS 
32ac eb						ex de,hl 
32ad					endif 
32ad			 
32ad			;	; get DO ptr 
32ad			; 
32ad					if DEBUG_FORTH_WORDS 
32ad						DMARK "LP7" 
32ad f5				push af  
32ae 3a c2 32			ld a, (.dmark)  
32b1 32 bd fb			ld (debug_mark),a  
32b4 3a c3 32			ld a, (.dmark+1)  
32b7 32 be fb			ld (debug_mark+1),a  
32ba 3a c4 32			ld a, (.dmark+2)  
32bd 32 bf fb			ld (debug_mark+2),a  
32c0 18 03			jr .pastdmark  
32c2 ..			.dmark: db "LP7"  
32c5 f1			.pastdmark: pop af  
32c6			endm  
# End of macro DMARK
32c6					CALLMONITOR 
32c6 cd 6a 16			call break_point_state  
32c9				endm  
# End of macro CALLMONITOR
32c9					endif 
32c9				FORTH_RSP_TOS 
32c9 cd b8 1b			call macro_forth_rsp_tos 
32cc				endm 
# End of macro FORTH_RSP_TOS
32cc			 
32cc					if DEBUG_FORTH_WORDS 
32cc						DMARK "LP8" 
32cc f5				push af  
32cd 3a e1 32			ld a, (.dmark)  
32d0 32 bd fb			ld (debug_mark),a  
32d3 3a e2 32			ld a, (.dmark+1)  
32d6 32 be fb			ld (debug_mark+1),a  
32d9 3a e3 32			ld a, (.dmark+2)  
32dc 32 bf fb			ld (debug_mark+2),a  
32df 18 03			jr .pastdmark  
32e1 ..			.dmark: db "LP8"  
32e4 f1			.pastdmark: pop af  
32e5			endm  
# End of macro DMARK
32e5					CALLMONITOR 
32e5 cd 6a 16			call break_point_state  
32e8				endm  
# End of macro CALLMONITOR
32e8					endif 
32e8				;push hl 
32e8			 
32e8				; not going to DO any more 
32e8				; get rid of the RSP pointer as DO will add it back in 
32e8				;FORTH_RSP_POP 
32e8				;pop hl 
32e8			 
32e8				;ld hl,(cli_ret_sp) 
32e8				;ld e, (hl) 
32e8				;inc hl 
32e8				;ld d, (hl) 
32e8				;ex de,hl 
32e8 22 a4 f2			ld (os_tok_ptr), hl 
32eb					if DEBUG_FORTH_WORDS 
32eb						DMARK "LP<" 
32eb f5				push af  
32ec 3a 00 33			ld a, (.dmark)  
32ef 32 bd fb			ld (debug_mark),a  
32f2 3a 01 33			ld a, (.dmark+1)  
32f5 32 be fb			ld (debug_mark+1),a  
32f8 3a 02 33			ld a, (.dmark+2)  
32fb 32 bf fb			ld (debug_mark+2),a  
32fe 18 03			jr .pastdmark  
3300 ..			.dmark: db "LP<"  
3303 f1			.pastdmark: pop af  
3304			endm  
# End of macro DMARK
3304					CALLMONITOR 
3304 cd 6a 16			call break_point_state  
3307				endm  
# End of macro CALLMONITOR
3307				endif 
3307 c3 f4 1f			jp exec1 
330a			 
330a					 
330a			 
330a			 
330a					NEXTW 
330a c3 63 1f			jp macro_next 
330d				endm 
# End of macro NEXTW
330d			.I:  
330d			 
330d				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
330d 5e				db WORD_SYS_CORE+74             
330e 38 33			dw .DLOOP            
3310 02				db 1 + 1 
3311 .. 00			db "I",0              
3313				endm 
# End of macro CWHEAD
3313			; | I ( -- ) Current loop counter | DONE 
3313					if DEBUG_FORTH_WORDS_KEY 
3313						DMARK "I.." 
3313 f5				push af  
3314 3a 28 33			ld a, (.dmark)  
3317 32 bd fb			ld (debug_mark),a  
331a 3a 29 33			ld a, (.dmark+1)  
331d 32 be fb			ld (debug_mark+1),a  
3320 3a 2a 33			ld a, (.dmark+2)  
3323 32 bf fb			ld (debug_mark+2),a  
3326 18 03			jr .pastdmark  
3328 ..			.dmark: db "I.."  
332b f1			.pastdmark: pop af  
332c			endm  
# End of macro DMARK
332c						CALLMONITOR 
332c cd 6a 16			call break_point_state  
332f				endm  
# End of macro CALLMONITOR
332f					endif 
332f			 
332f 2a c8 f2				ld hl,(os_current_i) 
3332 cd fa 1b				call forth_push_numhl 
3335			 
3335					NEXTW 
3335 c3 63 1f			jp macro_next 
3338				endm 
# End of macro NEXTW
3338			.DLOOP: 
3338				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3338 5f				db WORD_SYS_CORE+75             
3339 19 34			dw .REPEAT            
333b 06				db 5 + 1 
333c .. 00			db "-LOOP",0              
3342				endm 
# End of macro CWHEAD
3342			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3342				; pop tos as current loop count to hl 
3342					if DEBUG_FORTH_WORDS_KEY 
3342						DMARK "-LP" 
3342 f5				push af  
3343 3a 57 33			ld a, (.dmark)  
3346 32 bd fb			ld (debug_mark),a  
3349 3a 58 33			ld a, (.dmark+1)  
334c 32 be fb			ld (debug_mark+1),a  
334f 3a 59 33			ld a, (.dmark+2)  
3352 32 bf fb			ld (debug_mark+2),a  
3355 18 03			jr .pastdmark  
3357 ..			.dmark: db "-LP"  
335a f1			.pastdmark: pop af  
335b			endm  
# End of macro DMARK
335b						CALLMONITOR 
335b cd 6a 16			call break_point_state  
335e				endm  
# End of macro CALLMONITOR
335e					endif 
335e			 
335e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
335e			 
335e				FORTH_LOOP_TOS 
335e cd 55 1e			call macro_forth_loop_tos 
3361				endm 
# End of macro FORTH_LOOP_TOS
3361 e5				push hl 
3362			 
3362					if DEBUG_FORTH_WORDS 
3362						DMARK "-LP" 
3362 f5				push af  
3363 3a 77 33			ld a, (.dmark)  
3366 32 bd fb			ld (debug_mark),a  
3369 3a 78 33			ld a, (.dmark+1)  
336c 32 be fb			ld (debug_mark+1),a  
336f 3a 79 33			ld a, (.dmark+2)  
3372 32 bf fb			ld (debug_mark+2),a  
3375 18 03			jr .pastdmark  
3377 ..			.dmark: db "-LP"  
337a f1			.pastdmark: pop af  
337b			endm  
# End of macro DMARK
337b						CALLMONITOR 
337b cd 6a 16			call break_point_state  
337e				endm  
# End of macro CALLMONITOR
337e					endif 
337e				; next item on the stack is the limit. get it 
337e			 
337e			 
337e				FORTH_LOOP_POP 
337e cd 5f 1e			call macro_forth_loop_pop 
3381				endm 
# End of macro FORTH_LOOP_POP
3381			 
3381				FORTH_LOOP_TOS 
3381 cd 55 1e			call macro_forth_loop_tos 
3384				endm 
# End of macro FORTH_LOOP_TOS
3384			 
3384 d1				pop de		 ; de = i, hl = limit 
3385			 
3385					if DEBUG_FORTH_WORDS 
3385						DMARK "-L1" 
3385 f5				push af  
3386 3a 9a 33			ld a, (.dmark)  
3389 32 bd fb			ld (debug_mark),a  
338c 3a 9b 33			ld a, (.dmark+1)  
338f 32 be fb			ld (debug_mark+1),a  
3392 3a 9c 33			ld a, (.dmark+2)  
3395 32 bf fb			ld (debug_mark+2),a  
3398 18 03			jr .pastdmark  
339a ..			.dmark: db "-L1"  
339d f1			.pastdmark: pop af  
339e			endm  
# End of macro DMARK
339e						CALLMONITOR 
339e cd 6a 16			call break_point_state  
33a1				endm  
# End of macro CALLMONITOR
33a1					endif 
33a1			 
33a1				; go back to previous word 
33a1			 
33a1 d5				push de    ; save I for inc later 
33a2			 
33a2			 
33a2				; get limit 
33a2				;  is I at limit? 
33a2			 
33a2			 
33a2					if DEBUG_FORTH_WORDS 
33a2						DMARK "-L1" 
33a2 f5				push af  
33a3 3a b7 33			ld a, (.dmark)  
33a6 32 bd fb			ld (debug_mark),a  
33a9 3a b8 33			ld a, (.dmark+1)  
33ac 32 be fb			ld (debug_mark+1),a  
33af 3a b9 33			ld a, (.dmark+2)  
33b2 32 bf fb			ld (debug_mark+2),a  
33b5 18 03			jr .pastdmark  
33b7 ..			.dmark: db "-L1"  
33ba f1			.pastdmark: pop af  
33bb			endm  
# End of macro DMARK
33bb						CALLMONITOR 
33bb cd 6a 16			call break_point_state  
33be				endm  
# End of macro CALLMONITOR
33be					endif 
33be			 
33be ed 52			sbc hl, de 
33c0			 
33c0			 
33c0				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33c0			 
33c0 20 26				jr nz, .mloopnotdone 
33c2			 
33c2 e1				pop hl   ; get rid of saved I 
33c3				FORTH_LOOP_POP     ; get rid of limit 
33c3 cd 5f 1e			call macro_forth_loop_pop 
33c6				endm 
# End of macro FORTH_LOOP_POP
33c6			 
33c6				FORTH_RSP_POP     ; get rid of DO ptr 
33c6 cd c2 1b			call macro_forth_rsp_pop 
33c9				endm 
# End of macro FORTH_RSP_POP
33c9			 
33c9			if DEBUG_FORTH_WORDS 
33c9						DMARK "-L>" 
33c9 f5				push af  
33ca 3a de 33			ld a, (.dmark)  
33cd 32 bd fb			ld (debug_mark),a  
33d0 3a df 33			ld a, (.dmark+1)  
33d3 32 be fb			ld (debug_mark+1),a  
33d6 3a e0 33			ld a, (.dmark+2)  
33d9 32 bf fb			ld (debug_mark+2),a  
33dc 18 03			jr .pastdmark  
33de ..			.dmark: db "-L>"  
33e1 f1			.pastdmark: pop af  
33e2			endm  
# End of macro DMARK
33e2				CALLMONITOR 
33e2 cd 6a 16			call break_point_state  
33e5				endm  
# End of macro CALLMONITOR
33e5			endif 
33e5			 
33e5					NEXTW 
33e5 c3 63 1f			jp macro_next 
33e8				endm 
# End of macro NEXTW
33e8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33e8			 
33e8			.mloopnotdone: 
33e8			 
33e8 e1				pop hl    ; get I 
33e9 2b				dec hl 
33ea			 
33ea			   	; save new I 
33ea			 
33ea			 
33ea					; set I counter 
33ea			 
33ea 22 c8 f2				ld (os_current_i), hl 
33ed			 
33ed					 
33ed				FORTH_LOOP_NEXT 
33ed cd 22 1e			call macro_forth_loop_next 
33f0				endm 
# End of macro FORTH_LOOP_NEXT
33f0			 
33f0			 
33f0					if DEBUG_FORTH_WORDS 
33f0 eb						ex de,hl 
33f1					endif 
33f1			 
33f1			;	; get DO ptr 
33f1			; 
33f1				FORTH_RSP_TOS 
33f1 cd b8 1b			call macro_forth_rsp_tos 
33f4				endm 
# End of macro FORTH_RSP_TOS
33f4			 
33f4				;push hl 
33f4			 
33f4				; not going to DO any more 
33f4				; get rid of the RSP pointer as DO will add it back in 
33f4				;FORTH_RSP_POP 
33f4				;pop hl 
33f4			 
33f4			 
33f4 22 a4 f2			ld (os_tok_ptr), hl 
33f7					if DEBUG_FORTH_WORDS 
33f7						DMARK "-L<" 
33f7 f5				push af  
33f8 3a 0c 34			ld a, (.dmark)  
33fb 32 bd fb			ld (debug_mark),a  
33fe 3a 0d 34			ld a, (.dmark+1)  
3401 32 be fb			ld (debug_mark+1),a  
3404 3a 0e 34			ld a, (.dmark+2)  
3407 32 bf fb			ld (debug_mark+2),a  
340a 18 03			jr .pastdmark  
340c ..			.dmark: db "-L<"  
340f f1			.pastdmark: pop af  
3410			endm  
# End of macro DMARK
3410					CALLMONITOR 
3410 cd 6a 16			call break_point_state  
3413				endm  
# End of macro CALLMONITOR
3413				endif 
3413 c3 f4 1f			jp exec1 
3416			 
3416					 
3416			 
3416			 
3416			 
3416				NEXTW 
3416 c3 63 1f			jp macro_next 
3419				endm 
# End of macro NEXTW
3419			 
3419			 
3419			 
3419			 
3419			.REPEAT: 
3419				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3419 71				db WORD_SYS_CORE+93             
341a 6c 34			dw .UNTIL            
341c 06				db 5 + 1 
341d .. 00			db "REPEAT",0              
3424				endm 
# End of macro CWHEAD
3424			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3424			;  push pc to rsp stack past the REPEAT 
3424					if DEBUG_FORTH_WORDS_KEY 
3424						DMARK "REP" 
3424 f5				push af  
3425 3a 39 34			ld a, (.dmark)  
3428 32 bd fb			ld (debug_mark),a  
342b 3a 3a 34			ld a, (.dmark+1)  
342e 32 be fb			ld (debug_mark+1),a  
3431 3a 3b 34			ld a, (.dmark+2)  
3434 32 bf fb			ld (debug_mark+2),a  
3437 18 03			jr .pastdmark  
3439 ..			.dmark: db "REP"  
343c f1			.pastdmark: pop af  
343d			endm  
# End of macro DMARK
343d						CALLMONITOR 
343d cd 6a 16			call break_point_state  
3440				endm  
# End of macro CALLMONITOR
3440					endif 
3440			 
3440 2a a4 f2				ld hl, (os_tok_ptr) 
3443 23					inc hl   ; R 
3444 23					inc hl  ; E 
3445 23					inc hl   ; P 
3446 23					inc hl   ; E 
3447 23					inc hl   ; A 
3448 23					inc hl   ; T 
3449 23					inc hl   ; zero 
344a					FORTH_RSP_NEXT 
344a cd a1 1b			call macro_forth_rsp_next 
344d				endm 
# End of macro FORTH_RSP_NEXT
344d			 
344d			 
344d					if DEBUG_FORTH_WORDS 
344d						DMARK "REP" 
344d f5				push af  
344e 3a 62 34			ld a, (.dmark)  
3451 32 bd fb			ld (debug_mark),a  
3454 3a 63 34			ld a, (.dmark+1)  
3457 32 be fb			ld (debug_mark+1),a  
345a 3a 64 34			ld a, (.dmark+2)  
345d 32 bf fb			ld (debug_mark+2),a  
3460 18 03			jr .pastdmark  
3462 ..			.dmark: db "REP"  
3465 f1			.pastdmark: pop af  
3466			endm  
# End of macro DMARK
3466						;pop bc    ; TODO BUG ?????? what is this for???? 
3466						CALLMONITOR 
3466 cd 6a 16			call break_point_state  
3469				endm  
# End of macro CALLMONITOR
3469					endif 
3469			 
3469					NEXTW 
3469 c3 63 1f			jp macro_next 
346c				endm 
# End of macro NEXTW
346c			;	       NEXTW 
346c			 
346c			.UNTIL: 
346c				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
346c 72				db WORD_SYS_CORE+94             
346d 03 35			dw .ENDFLOW            
346f 06				db 5 + 1 
3470 .. 00			db "UNTIL",0              
3476				endm 
# End of macro CWHEAD
3476			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3476			 
3476				; pop tos as check 
3476			 
3476				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3476			 
3476				FORTH_DSP_VALUEHL 
3476 cd f1 1d			call macro_dsp_valuehl 
3479				endm 
# End of macro FORTH_DSP_VALUEHL
3479			 
3479					if DEBUG_FORTH_WORDS_KEY 
3479						DMARK "UNT" 
3479 f5				push af  
347a 3a 8e 34			ld a, (.dmark)  
347d 32 bd fb			ld (debug_mark),a  
3480 3a 8f 34			ld a, (.dmark+1)  
3483 32 be fb			ld (debug_mark+1),a  
3486 3a 90 34			ld a, (.dmark+2)  
3489 32 bf fb			ld (debug_mark+2),a  
348c 18 03			jr .pastdmark  
348e ..			.dmark: db "UNT"  
3491 f1			.pastdmark: pop af  
3492			endm  
# End of macro DMARK
3492						CALLMONITOR 
3492 cd 6a 16			call break_point_state  
3495				endm  
# End of macro CALLMONITOR
3495					endif 
3495			 
3495			;	push hl 
3495				FORTH_DSP_POP 
3495 cd a9 1e			call macro_forth_dsp_pop 
3498				endm 
# End of macro FORTH_DSP_POP
3498			 
3498			;	pop hl 
3498			 
3498				; test if true 
3498			 
3498 cd 2f 0d			call ishlzero 
349b			;	ld a,l 
349b			;	add h 
349b			; 
349b			;	cp 0 
349b			 
349b 20 3e			jr nz, .untilnotdone 
349d			 
349d					if DEBUG_FORTH_WORDS 
349d						DMARK "UNf" 
349d f5				push af  
349e 3a b2 34			ld a, (.dmark)  
34a1 32 bd fb			ld (debug_mark),a  
34a4 3a b3 34			ld a, (.dmark+1)  
34a7 32 be fb			ld (debug_mark+1),a  
34aa 3a b4 34			ld a, (.dmark+2)  
34ad 32 bf fb			ld (debug_mark+2),a  
34b0 18 03			jr .pastdmark  
34b2 ..			.dmark: db "UNf"  
34b5 f1			.pastdmark: pop af  
34b6			endm  
# End of macro DMARK
34b6						CALLMONITOR 
34b6 cd 6a 16			call break_point_state  
34b9				endm  
# End of macro CALLMONITOR
34b9					endif 
34b9			 
34b9			 
34b9			 
34b9				FORTH_RSP_POP     ; get rid of DO ptr 
34b9 cd c2 1b			call macro_forth_rsp_pop 
34bc				endm 
# End of macro FORTH_RSP_POP
34bc			 
34bc			if DEBUG_FORTH_WORDS 
34bc						DMARK "UN>" 
34bc f5				push af  
34bd 3a d1 34			ld a, (.dmark)  
34c0 32 bd fb			ld (debug_mark),a  
34c3 3a d2 34			ld a, (.dmark+1)  
34c6 32 be fb			ld (debug_mark+1),a  
34c9 3a d3 34			ld a, (.dmark+2)  
34cc 32 bf fb			ld (debug_mark+2),a  
34cf 18 03			jr .pastdmark  
34d1 ..			.dmark: db "UN>"  
34d4 f1			.pastdmark: pop af  
34d5			endm  
# End of macro DMARK
34d5				CALLMONITOR 
34d5 cd 6a 16			call break_point_state  
34d8				endm  
# End of macro CALLMONITOR
34d8			endif 
34d8			 
34d8					NEXTW 
34d8 c3 63 1f			jp macro_next 
34db				endm 
# End of macro NEXTW
34db				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34db			 
34db			.untilnotdone: 
34db			 
34db			 
34db			;	; get DO ptr 
34db			; 
34db				FORTH_RSP_TOS 
34db cd b8 1b			call macro_forth_rsp_tos 
34de				endm 
# End of macro FORTH_RSP_TOS
34de			 
34de				;push hl 
34de			 
34de				; not going to DO any more 
34de				; get rid of the RSP pointer as DO will add it back in 
34de				;FORTH_RSP_POP 
34de				;pop hl 
34de			 
34de			 
34de 22 a4 f2			ld (os_tok_ptr), hl 
34e1					if DEBUG_FORTH_WORDS 
34e1						DMARK "UN<" 
34e1 f5				push af  
34e2 3a f6 34			ld a, (.dmark)  
34e5 32 bd fb			ld (debug_mark),a  
34e8 3a f7 34			ld a, (.dmark+1)  
34eb 32 be fb			ld (debug_mark+1),a  
34ee 3a f8 34			ld a, (.dmark+2)  
34f1 32 bf fb			ld (debug_mark+2),a  
34f4 18 03			jr .pastdmark  
34f6 ..			.dmark: db "UN<"  
34f9 f1			.pastdmark: pop af  
34fa			endm  
# End of macro DMARK
34fa					CALLMONITOR 
34fa cd 6a 16			call break_point_state  
34fd				endm  
# End of macro CALLMONITOR
34fd				endif 
34fd c3 f4 1f			jp exec1 
3500			 
3500					 
3500			 
3500			 
3500					NEXTW 
3500 c3 63 1f			jp macro_next 
3503				endm 
# End of macro NEXTW
3503			 
3503			 
3503			.ENDFLOW: 
3503			 
3503			; eof 
3503			 
# End of file forth_words_flow.asm
3503			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3503			include "forth_words_logic.asm" 
3503			 
3503			; | ## Logic Words 
3503			 
3503			.NOT: 
3503				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3503 2d				db WORD_SYS_CORE+25             
3504 4b 35			dw .IS            
3506 04				db 3 + 1 
3507 .. 00			db "NOT",0              
350b				endm 
# End of macro CWHEAD
350b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
350b					if DEBUG_FORTH_WORDS_KEY 
350b						DMARK "NOT" 
350b f5				push af  
350c 3a 20 35			ld a, (.dmark)  
350f 32 bd fb			ld (debug_mark),a  
3512 3a 21 35			ld a, (.dmark+1)  
3515 32 be fb			ld (debug_mark+1),a  
3518 3a 22 35			ld a, (.dmark+2)  
351b 32 bf fb			ld (debug_mark+2),a  
351e 18 03			jr .pastdmark  
3520 ..			.dmark: db "NOT"  
3523 f1			.pastdmark: pop af  
3524			endm  
# End of macro DMARK
3524						CALLMONITOR 
3524 cd 6a 16			call break_point_state  
3527				endm  
# End of macro CALLMONITOR
3527					endif 
3527					FORTH_DSP 
3527 cd b7 1d			call macro_forth_dsp 
352a				endm 
# End of macro FORTH_DSP
352a 7e					ld a,(hl)	; get type of value on TOS 
352b fe 02				cp DS_TYPE_INUM  
352d 28 03				jr z, .noti 
352f					NEXTW 
352f c3 63 1f			jp macro_next 
3532				endm 
# End of macro NEXTW
3532			.noti:          FORTH_DSP_VALUEHL 
3532 cd f1 1d			call macro_dsp_valuehl 
3535				endm 
# End of macro FORTH_DSP_VALUEHL
3535			;		push hl 
3535					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3535 cd a9 1e			call macro_forth_dsp_pop 
3538				endm 
# End of macro FORTH_DSP_POP
3538			;		pop hl 
3538 3e 00				ld a,0 
353a bd					cp l 
353b 28 04				jr z, .not2t 
353d 2e 00				ld l, 0 
353f 18 02				jr .notip 
3541			 
3541 2e ff		.not2t:		ld l, 255 
3543			 
3543 26 00		.notip:		ld h, 0	 
3545			 
3545 cd fa 1b				call forth_push_numhl 
3548					NEXTW 
3548 c3 63 1f			jp macro_next 
354b				endm 
# End of macro NEXTW
354b			 
354b			.IS: 
354b				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
354b 2d				db WORD_SYS_CORE+25             
354c 71 35			dw .LZERO            
354e 03				db 2 + 1 
354f .. 00			db "IS",0              
3552				endm 
# End of macro CWHEAD
3552			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3552					if DEBUG_FORTH_WORDS_KEY 
3552						DMARK "IS." 
3552 f5				push af  
3553 3a 67 35			ld a, (.dmark)  
3556 32 bd fb			ld (debug_mark),a  
3559 3a 68 35			ld a, (.dmark+1)  
355c 32 be fb			ld (debug_mark+1),a  
355f 3a 69 35			ld a, (.dmark+2)  
3562 32 bf fb			ld (debug_mark+2),a  
3565 18 03			jr .pastdmark  
3567 ..			.dmark: db "IS."  
356a f1			.pastdmark: pop af  
356b			endm  
# End of macro DMARK
356b						CALLMONITOR 
356b cd 6a 16			call break_point_state  
356e				endm  
# End of macro CALLMONITOR
356e					endif 
356e					NEXTW 
356e c3 63 1f			jp macro_next 
3571				endm 
# End of macro NEXTW
3571			.LZERO: 
3571				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3571 2d				db WORD_SYS_CORE+25             
3572 7b 35			dw .TZERO            
3574 03				db 2 + 1 
3575 .. 00			db "0<",0              
3578				endm 
# End of macro CWHEAD
3578			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3578					NEXTW 
3578 c3 63 1f			jp macro_next 
357b				endm 
# End of macro NEXTW
357b			.TZERO: 
357b				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
357b 2e				db WORD_SYS_CORE+26             
357c c2 35			dw .LESS            
357e 03				db 2 + 1 
357f .. 00			db "0=",0              
3582				endm 
# End of macro CWHEAD
3582			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3582				; TODO add floating point number detection 
3582					;v5 FORTH_DSP_VALUE 
3582					if DEBUG_FORTH_WORDS_KEY 
3582						DMARK "0=." 
3582 f5				push af  
3583 3a 97 35			ld a, (.dmark)  
3586 32 bd fb			ld (debug_mark),a  
3589 3a 98 35			ld a, (.dmark+1)  
358c 32 be fb			ld (debug_mark+1),a  
358f 3a 99 35			ld a, (.dmark+2)  
3592 32 bf fb			ld (debug_mark+2),a  
3595 18 03			jr .pastdmark  
3597 ..			.dmark: db "0=."  
359a f1			.pastdmark: pop af  
359b			endm  
# End of macro DMARK
359b						CALLMONITOR 
359b cd 6a 16			call break_point_state  
359e				endm  
# End of macro CALLMONITOR
359e					endif 
359e					FORTH_DSP 
359e cd b7 1d			call macro_forth_dsp 
35a1				endm 
# End of macro FORTH_DSP
35a1 7e					ld a,(hl)	; get type of value on TOS 
35a2 fe 02				cp DS_TYPE_INUM  
35a4 28 00				jr z, .tz_inum 
35a6			 
35a6				if FORTH_ENABLE_FLOATMATH 
35a6					jr .tz_done 
35a6			 
35a6				endif 
35a6					 
35a6			 
35a6			.tz_inum: 
35a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a6 cd f1 1d			call macro_dsp_valuehl 
35a9				endm 
# End of macro FORTH_DSP_VALUEHL
35a9			 
35a9			;		push hl 
35a9			 
35a9					; destroy value TOS 
35a9			 
35a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a9 cd a9 1e			call macro_forth_dsp_pop 
35ac				endm 
# End of macro FORTH_DSP_POP
35ac			 
35ac			;		pop hl 
35ac			 
35ac 3e 00				ld a,0 
35ae			 
35ae bd					cp l 
35af 20 08				jr nz, .tz_notzero 
35b1			 
35b1 bc					cp h 
35b2			 
35b2 20 05				jr nz, .tz_notzero 
35b4			 
35b4			 
35b4 21 01 00				ld hl, FORTH_TRUE 
35b7 18 03				jr .tz_done 
35b9			 
35b9 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35bc			 
35bc					; push value back onto stack for another op etc 
35bc			 
35bc			.tz_done: 
35bc cd fa 1b				call forth_push_numhl 
35bf			 
35bf					NEXTW 
35bf c3 63 1f			jp macro_next 
35c2				endm 
# End of macro NEXTW
35c2			.LESS: 
35c2				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35c2 2f				db WORD_SYS_CORE+27             
35c3 2b 36			dw .GT            
35c5 02				db 1 + 1 
35c6 .. 00			db "<",0              
35c8				endm 
# End of macro CWHEAD
35c8			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35c8				; TODO add floating point number detection 
35c8					if DEBUG_FORTH_WORDS_KEY 
35c8						DMARK "LES" 
35c8 f5				push af  
35c9 3a dd 35			ld a, (.dmark)  
35cc 32 bd fb			ld (debug_mark),a  
35cf 3a de 35			ld a, (.dmark+1)  
35d2 32 be fb			ld (debug_mark+1),a  
35d5 3a df 35			ld a, (.dmark+2)  
35d8 32 bf fb			ld (debug_mark+2),a  
35db 18 03			jr .pastdmark  
35dd ..			.dmark: db "LES"  
35e0 f1			.pastdmark: pop af  
35e1			endm  
# End of macro DMARK
35e1						CALLMONITOR 
35e1 cd 6a 16			call break_point_state  
35e4				endm  
# End of macro CALLMONITOR
35e4					endif 
35e4					FORTH_DSP 
35e4 cd b7 1d			call macro_forth_dsp 
35e7				endm 
# End of macro FORTH_DSP
35e7					;v5 FORTH_DSP_VALUE 
35e7 7e					ld a,(hl)	; get type of value on TOS 
35e8 fe 02				cp DS_TYPE_INUM  
35ea 28 00				jr z, .less_inum 
35ec			 
35ec				if FORTH_ENABLE_FLOATMATH 
35ec					jr .less_done 
35ec			 
35ec				endif 
35ec					 
35ec			 
35ec			.less_inum: 
35ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ec cd f1 1d			call macro_dsp_valuehl 
35ef				endm 
# End of macro FORTH_DSP_VALUEHL
35ef			 
35ef e5					push hl  ; u2 
35f0			 
35f0					; destroy value TOS 
35f0			 
35f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f0 cd a9 1e			call macro_forth_dsp_pop 
35f3				endm 
# End of macro FORTH_DSP_POP
35f3			 
35f3			 
35f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35f3 cd f1 1d			call macro_dsp_valuehl 
35f6				endm 
# End of macro FORTH_DSP_VALUEHL
35f6			 
35f6 e5					push hl    ; u1 
35f7			 
35f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f7 cd a9 1e			call macro_forth_dsp_pop 
35fa				endm 
# End of macro FORTH_DSP_POP
35fa			 
35fa			 
35fa b7			 or a      ;clear carry flag 
35fb 01 00 00		 ld bc, FORTH_FALSE 
35fe e1			  pop hl    ; u1 
35ff d1			  pop de    ; u2 
3600 ed 52		  sbc hl,de 
3602 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3604			 
3604 01 01 00		 ld bc, FORTH_TRUE 
3607			.lscont:  
3607 c5					push bc 
3608 e1					pop hl 
3609			 
3609					if DEBUG_FORTH_WORDS 
3609						DMARK "LT1" 
3609 f5				push af  
360a 3a 1e 36			ld a, (.dmark)  
360d 32 bd fb			ld (debug_mark),a  
3610 3a 1f 36			ld a, (.dmark+1)  
3613 32 be fb			ld (debug_mark+1),a  
3616 3a 20 36			ld a, (.dmark+2)  
3619 32 bf fb			ld (debug_mark+2),a  
361c 18 03			jr .pastdmark  
361e ..			.dmark: db "LT1"  
3621 f1			.pastdmark: pop af  
3622			endm  
# End of macro DMARK
3622						CALLMONITOR 
3622 cd 6a 16			call break_point_state  
3625				endm  
# End of macro CALLMONITOR
3625					endif 
3625 cd fa 1b				call forth_push_numhl 
3628			 
3628					NEXTW 
3628 c3 63 1f			jp macro_next 
362b				endm 
# End of macro NEXTW
362b			.GT: 
362b				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
362b 30				db WORD_SYS_CORE+28             
362c 94 36			dw .EQUAL            
362e 02				db 1 + 1 
362f .. 00			db ">",0              
3631				endm 
# End of macro CWHEAD
3631			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3631				; TODO add floating point number detection 
3631					if DEBUG_FORTH_WORDS_KEY 
3631						DMARK "GRT" 
3631 f5				push af  
3632 3a 46 36			ld a, (.dmark)  
3635 32 bd fb			ld (debug_mark),a  
3638 3a 47 36			ld a, (.dmark+1)  
363b 32 be fb			ld (debug_mark+1),a  
363e 3a 48 36			ld a, (.dmark+2)  
3641 32 bf fb			ld (debug_mark+2),a  
3644 18 03			jr .pastdmark  
3646 ..			.dmark: db "GRT"  
3649 f1			.pastdmark: pop af  
364a			endm  
# End of macro DMARK
364a						CALLMONITOR 
364a cd 6a 16			call break_point_state  
364d				endm  
# End of macro CALLMONITOR
364d					endif 
364d					FORTH_DSP 
364d cd b7 1d			call macro_forth_dsp 
3650				endm 
# End of macro FORTH_DSP
3650					;FORTH_DSP_VALUE 
3650 7e					ld a,(hl)	; get type of value on TOS 
3651 fe 02				cp DS_TYPE_INUM  
3653 28 00				jr z, .gt_inum 
3655			 
3655				if FORTH_ENABLE_FLOATMATH 
3655					jr .gt_done 
3655			 
3655				endif 
3655					 
3655			 
3655			.gt_inum: 
3655					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3655 cd f1 1d			call macro_dsp_valuehl 
3658				endm 
# End of macro FORTH_DSP_VALUEHL
3658			 
3658 e5					push hl  ; u2 
3659			 
3659					; destroy value TOS 
3659			 
3659					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3659 cd a9 1e			call macro_forth_dsp_pop 
365c				endm 
# End of macro FORTH_DSP_POP
365c			 
365c			 
365c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365c cd f1 1d			call macro_dsp_valuehl 
365f				endm 
# End of macro FORTH_DSP_VALUEHL
365f			 
365f e5					push hl    ; u1 
3660			 
3660					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3660 cd a9 1e			call macro_forth_dsp_pop 
3663				endm 
# End of macro FORTH_DSP_POP
3663			 
3663			 
3663 b7			 or a      ;clear carry flag 
3664 01 00 00		 ld bc, FORTH_FALSE 
3667 e1			  pop hl    ; u1 
3668 d1			  pop de    ; u2 
3669 ed 52		  sbc hl,de 
366b 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
366d			 
366d 01 01 00		 ld bc, FORTH_TRUE 
3670			.gtcont:  
3670 c5					push bc 
3671 e1					pop hl 
3672			 
3672					if DEBUG_FORTH_WORDS 
3672						DMARK "GT1" 
3672 f5				push af  
3673 3a 87 36			ld a, (.dmark)  
3676 32 bd fb			ld (debug_mark),a  
3679 3a 88 36			ld a, (.dmark+1)  
367c 32 be fb			ld (debug_mark+1),a  
367f 3a 89 36			ld a, (.dmark+2)  
3682 32 bf fb			ld (debug_mark+2),a  
3685 18 03			jr .pastdmark  
3687 ..			.dmark: db "GT1"  
368a f1			.pastdmark: pop af  
368b			endm  
# End of macro DMARK
368b						CALLMONITOR 
368b cd 6a 16			call break_point_state  
368e				endm  
# End of macro CALLMONITOR
368e					endif 
368e cd fa 1b				call forth_push_numhl 
3691			 
3691					NEXTW 
3691 c3 63 1f			jp macro_next 
3694				endm 
# End of macro NEXTW
3694			.EQUAL: 
3694				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3694 31				db WORD_SYS_CORE+29             
3695 ff 36			dw .ENDLOGIC            
3697 02				db 1 + 1 
3698 .. 00			db "=",0              
369a				endm 
# End of macro CWHEAD
369a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
369a				; TODO add floating point number detection 
369a					if DEBUG_FORTH_WORDS_KEY 
369a						DMARK "EQ." 
369a f5				push af  
369b 3a af 36			ld a, (.dmark)  
369e 32 bd fb			ld (debug_mark),a  
36a1 3a b0 36			ld a, (.dmark+1)  
36a4 32 be fb			ld (debug_mark+1),a  
36a7 3a b1 36			ld a, (.dmark+2)  
36aa 32 bf fb			ld (debug_mark+2),a  
36ad 18 03			jr .pastdmark  
36af ..			.dmark: db "EQ."  
36b2 f1			.pastdmark: pop af  
36b3			endm  
# End of macro DMARK
36b3						CALLMONITOR 
36b3 cd 6a 16			call break_point_state  
36b6				endm  
# End of macro CALLMONITOR
36b6					endif 
36b6					FORTH_DSP 
36b6 cd b7 1d			call macro_forth_dsp 
36b9				endm 
# End of macro FORTH_DSP
36b9					;v5 FORTH_DSP_VALUE 
36b9 7e					ld a,(hl)	; get type of value on TOS 
36ba fe 02				cp DS_TYPE_INUM  
36bc 28 00				jr z, .eq_inum 
36be			 
36be				if FORTH_ENABLE_FLOATMATH 
36be					jr .eq_done 
36be			 
36be				endif 
36be					 
36be			 
36be			.eq_inum: 
36be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36be cd f1 1d			call macro_dsp_valuehl 
36c1				endm 
# End of macro FORTH_DSP_VALUEHL
36c1			 
36c1 e5					push hl 
36c2			 
36c2					; destroy value TOS 
36c2			 
36c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c2 cd a9 1e			call macro_forth_dsp_pop 
36c5				endm 
# End of macro FORTH_DSP_POP
36c5			 
36c5			 
36c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c5 cd f1 1d			call macro_dsp_valuehl 
36c8				endm 
# End of macro FORTH_DSP_VALUEHL
36c8			 
36c8					; one value on hl get other one back 
36c8			 
36c8 e5					push hl 
36c9			 
36c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c9 cd a9 1e			call macro_forth_dsp_pop 
36cc				endm 
# End of macro FORTH_DSP_POP
36cc			 
36cc 0e 00				ld c, FORTH_FALSE 
36ce			 
36ce e1					pop hl 
36cf d1					pop de 
36d0			 
36d0 7b					ld a, e 
36d1 bd					cp l 
36d2			 
36d2 20 06				jr nz, .eq_done 
36d4			 
36d4 7a					ld a, d 
36d5 bc					cp h 
36d6			 
36d6 20 02				jr nz, .eq_done 
36d8			 
36d8 0e 01				ld c, FORTH_TRUE 
36da					 
36da			 
36da			 
36da			.eq_done: 
36da			 
36da					; TODO push value back onto stack for another op etc 
36da			 
36da 26 00				ld h, 0 
36dc 69					ld l, c 
36dd					if DEBUG_FORTH_WORDS 
36dd						DMARK "EQ1" 
36dd f5				push af  
36de 3a f2 36			ld a, (.dmark)  
36e1 32 bd fb			ld (debug_mark),a  
36e4 3a f3 36			ld a, (.dmark+1)  
36e7 32 be fb			ld (debug_mark+1),a  
36ea 3a f4 36			ld a, (.dmark+2)  
36ed 32 bf fb			ld (debug_mark+2),a  
36f0 18 03			jr .pastdmark  
36f2 ..			.dmark: db "EQ1"  
36f5 f1			.pastdmark: pop af  
36f6			endm  
# End of macro DMARK
36f6						CALLMONITOR 
36f6 cd 6a 16			call break_point_state  
36f9				endm  
# End of macro CALLMONITOR
36f9					endif 
36f9 cd fa 1b				call forth_push_numhl 
36fc			 
36fc					NEXTW 
36fc c3 63 1f			jp macro_next 
36ff				endm 
# End of macro NEXTW
36ff			 
36ff			 
36ff			.ENDLOGIC: 
36ff			; eof 
36ff			 
36ff			 
# End of file forth_words_logic.asm
36ff			include "forth_words_maths.asm" 
36ff			 
36ff			; | ## Maths Words 
36ff			 
36ff			.PLUS:	 
36ff				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36ff 15				db WORD_SYS_CORE+1             
3700 41 37			dw .NEG            
3702 02				db 1 + 1 
3703 .. 00			db "+",0              
3705				endm 
# End of macro CWHEAD
3705			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3705					if DEBUG_FORTH_WORDS_KEY 
3705						DMARK "PLU" 
3705 f5				push af  
3706 3a 1a 37			ld a, (.dmark)  
3709 32 bd fb			ld (debug_mark),a  
370c 3a 1b 37			ld a, (.dmark+1)  
370f 32 be fb			ld (debug_mark+1),a  
3712 3a 1c 37			ld a, (.dmark+2)  
3715 32 bf fb			ld (debug_mark+2),a  
3718 18 03			jr .pastdmark  
371a ..			.dmark: db "PLU"  
371d f1			.pastdmark: pop af  
371e			endm  
# End of macro DMARK
371e						CALLMONITOR 
371e cd 6a 16			call break_point_state  
3721				endm  
# End of macro CALLMONITOR
3721					endif 
3721					; add top two values and push back result 
3721			 
3721					;for v5 FORTH_DSP_VALUE 
3721					FORTH_DSP 
3721 cd b7 1d			call macro_forth_dsp 
3724				endm 
# End of macro FORTH_DSP
3724 7e					ld a,(hl)	; get type of value on TOS 
3725 fe 02				cp DS_TYPE_INUM  
3727 28 03				jr z, .dot_inum 
3729			 
3729					NEXTW 
3729 c3 63 1f			jp macro_next 
372c				endm 
# End of macro NEXTW
372c			 
372c			; float maths 
372c			 
372c				if FORTH_ENABLE_FLOATMATH 
372c						inc hl      ; now at start of numeric as string 
372c			 
372c					if DEBUG_FORTH_MATHS 
372c						DMARK "ADD" 
372c				CALLMONITOR 
372c					endif 
372c			 
372c					;ld ix, hl 
372c					call CON 
372c			 
372c			 
372c					push hl 
372c					 
372c					 
372c			 
372c						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
372c			 
372c					; get next number 
372c			 
372c						FORTH_DSP_VALUE 
372c			 
372c						inc hl      ; now at start of numeric as string 
372c			 
372c					;ld ix, hl 
372c					call CON 
372c			 
372c					push hl 
372c			 
372c			 
372c						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372c			 
372c						; TODO do add 
372c			 
372c						call IADD 
372c			 
372c						; TODO get result back as ascii 
372c			 
372c						; TODO push result  
372c			 
372c			 
372c			 
372c						jr .dot_done 
372c				endif 
372c			 
372c			.dot_inum: 
372c			 
372c			 
372c					if DEBUG_FORTH_DOT 
372c						DMARK "+IT" 
372c				CALLMONITOR 
372c					endif 
372c			 
372c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372c cd f1 1d			call macro_dsp_valuehl 
372f				endm 
# End of macro FORTH_DSP_VALUEHL
372f			 
372f				; TODO add floating point number detection 
372f			 
372f e5					push hl 
3730			 
3730					; destroy value TOS 
3730			 
3730					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3730 cd a9 1e			call macro_forth_dsp_pop 
3733				endm 
# End of macro FORTH_DSP_POP
3733			 
3733			 
3733					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3733 cd f1 1d			call macro_dsp_valuehl 
3736				endm 
# End of macro FORTH_DSP_VALUEHL
3736			 
3736					; one value on hl get other one back 
3736			 
3736 d1					pop de 
3737			 
3737					; do the add 
3737			 
3737 19					add hl,de 
3738			 
3738					; save it 
3738			 
3738			;		push hl	 
3738			 
3738					; 
3738			 
3738					; destroy value TOS 
3738			 
3738					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3738 cd a9 1e			call macro_forth_dsp_pop 
373b				endm 
# End of macro FORTH_DSP_POP
373b			 
373b					; TODO push value back onto stack for another op etc 
373b			 
373b			;		pop hl 
373b			 
373b			.dot_done: 
373b cd fa 1b				call forth_push_numhl 
373e			 
373e					NEXTW 
373e c3 63 1f			jp macro_next 
3741				endm 
# End of macro NEXTW
3741			.NEG: 
3741			 
3741				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3741 17				db WORD_SYS_CORE+3             
3742 84 37			dw .DIV            
3744 02				db 1 + 1 
3745 .. 00			db "-",0              
3747				endm 
# End of macro CWHEAD
3747			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3747					if DEBUG_FORTH_WORDS_KEY 
3747						DMARK "SUB" 
3747 f5				push af  
3748 3a 5c 37			ld a, (.dmark)  
374b 32 bd fb			ld (debug_mark),a  
374e 3a 5d 37			ld a, (.dmark+1)  
3751 32 be fb			ld (debug_mark+1),a  
3754 3a 5e 37			ld a, (.dmark+2)  
3757 32 bf fb			ld (debug_mark+2),a  
375a 18 03			jr .pastdmark  
375c ..			.dmark: db "SUB"  
375f f1			.pastdmark: pop af  
3760			endm  
# End of macro DMARK
3760						CALLMONITOR 
3760 cd 6a 16			call break_point_state  
3763				endm  
# End of macro CALLMONITOR
3763					endif 
3763			 
3763			 
3763				; TODO add floating point number detection 
3763					; v5 FORTH_DSP_VALUE 
3763					FORTH_DSP 
3763 cd b7 1d			call macro_forth_dsp 
3766				endm 
# End of macro FORTH_DSP
3766 7e					ld a,(hl)	; get type of value on TOS 
3767 fe 02				cp DS_TYPE_INUM  
3769 28 03				jr z, .neg_inum 
376b			 
376b					NEXTW 
376b c3 63 1f			jp macro_next 
376e				endm 
# End of macro NEXTW
376e			 
376e			; float maths 
376e			 
376e				if FORTH_ENABLE_FLOATMATH 
376e					jr .neg_done 
376e			 
376e				endif 
376e					 
376e			 
376e			.neg_inum: 
376e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376e cd f1 1d			call macro_dsp_valuehl 
3771				endm 
# End of macro FORTH_DSP_VALUEHL
3771			 
3771 e5					push hl 
3772			 
3772					; destroy value TOS 
3772			 
3772					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3772 cd a9 1e			call macro_forth_dsp_pop 
3775				endm 
# End of macro FORTH_DSP_POP
3775			 
3775			 
3775					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3775 cd f1 1d			call macro_dsp_valuehl 
3778				endm 
# End of macro FORTH_DSP_VALUEHL
3778			 
3778					; one value on hl get other one back 
3778			 
3778 d1					pop de 
3779			 
3779					; do the sub 
3779			;		ex de, hl 
3779			 
3779 ed 52				sbc hl,de 
377b			 
377b					; save it 
377b			 
377b			;		push hl	 
377b			 
377b					; 
377b			 
377b					; destroy value TOS 
377b			 
377b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377b cd a9 1e			call macro_forth_dsp_pop 
377e				endm 
# End of macro FORTH_DSP_POP
377e			 
377e					; TODO push value back onto stack for another op etc 
377e			 
377e			;		pop hl 
377e			 
377e cd fa 1b				call forth_push_numhl 
3781			.neg_done: 
3781			 
3781					NEXTW 
3781 c3 63 1f			jp macro_next 
3784				endm 
# End of macro NEXTW
3784			.DIV: 
3784				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3784 18				db WORD_SYS_CORE+4             
3785 d1 37			dw .MUL            
3787 02				db 1 + 1 
3788 .. 00			db "/",0              
378a				endm 
# End of macro CWHEAD
378a			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
378a					if DEBUG_FORTH_WORDS_KEY 
378a						DMARK "DIV" 
378a f5				push af  
378b 3a 9f 37			ld a, (.dmark)  
378e 32 bd fb			ld (debug_mark),a  
3791 3a a0 37			ld a, (.dmark+1)  
3794 32 be fb			ld (debug_mark+1),a  
3797 3a a1 37			ld a, (.dmark+2)  
379a 32 bf fb			ld (debug_mark+2),a  
379d 18 03			jr .pastdmark  
379f ..			.dmark: db "DIV"  
37a2 f1			.pastdmark: pop af  
37a3			endm  
# End of macro DMARK
37a3						CALLMONITOR 
37a3 cd 6a 16			call break_point_state  
37a6				endm  
# End of macro CALLMONITOR
37a6					endif 
37a6				; TODO add floating point number detection 
37a6					; v5 FORTH_DSP_VALUE 
37a6					FORTH_DSP 
37a6 cd b7 1d			call macro_forth_dsp 
37a9				endm 
# End of macro FORTH_DSP
37a9 7e					ld a,(hl)	; get type of value on TOS 
37aa fe 02				cp DS_TYPE_INUM  
37ac 28 03				jr z, .div_inum 
37ae			 
37ae				if FORTH_ENABLE_FLOATMATH 
37ae					jr .div_done 
37ae			 
37ae				endif 
37ae					NEXTW 
37ae c3 63 1f			jp macro_next 
37b1				endm 
# End of macro NEXTW
37b1			.div_inum: 
37b1			 
37b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b1 cd f1 1d			call macro_dsp_valuehl 
37b4				endm 
# End of macro FORTH_DSP_VALUEHL
37b4			 
37b4 e5					push hl    ; to go to bc 
37b5			 
37b5					; destroy value TOS 
37b5			 
37b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b5 cd a9 1e			call macro_forth_dsp_pop 
37b8				endm 
# End of macro FORTH_DSP_POP
37b8			 
37b8			 
37b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b8 cd f1 1d			call macro_dsp_valuehl 
37bb				endm 
# End of macro FORTH_DSP_VALUEHL
37bb			 
37bb					; hl to go to de 
37bb			 
37bb e5					push hl 
37bc			 
37bc c1					pop bc 
37bd d1					pop de		 
37be			 
37be			 
37be					if DEBUG_FORTH_MATHS 
37be						DMARK "DIV" 
37be				CALLMONITOR 
37be					endif 
37be					; one value on hl but move to a get other one back 
37be			 
37be			        
37be cd 63 0c			call Div16 
37c1			 
37c1			;	push af	 
37c1 e5				push hl 
37c2 c5				push bc 
37c3			 
37c3					if DEBUG_FORTH_MATHS 
37c3						DMARK "DI1" 
37c3				CALLMONITOR 
37c3					endif 
37c3			 
37c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c3 cd a9 1e			call macro_forth_dsp_pop 
37c6				endm 
# End of macro FORTH_DSP_POP
37c6			 
37c6			 
37c6			 
37c6 e1					pop hl    ; result 
37c7			 
37c7 cd fa 1b				call forth_push_numhl 
37ca			 
37ca e1					pop hl    ; reminder 
37cb			;		ld h,0 
37cb			;		ld l,d 
37cb			 
37cb cd fa 1b				call forth_push_numhl 
37ce			.div_done: 
37ce					NEXTW 
37ce c3 63 1f			jp macro_next 
37d1				endm 
# End of macro NEXTW
37d1			.MUL: 
37d1				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37d1 19				db WORD_SYS_CORE+5             
37d2 16 38			dw .MIN            
37d4 02				db 1 + 1 
37d5 .. 00			db "*",0              
37d7				endm 
# End of macro CWHEAD
37d7			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37d7				; TODO add floating point number detection 
37d7					if DEBUG_FORTH_WORDS_KEY 
37d7						DMARK "MUL" 
37d7 f5				push af  
37d8 3a ec 37			ld a, (.dmark)  
37db 32 bd fb			ld (debug_mark),a  
37de 3a ed 37			ld a, (.dmark+1)  
37e1 32 be fb			ld (debug_mark+1),a  
37e4 3a ee 37			ld a, (.dmark+2)  
37e7 32 bf fb			ld (debug_mark+2),a  
37ea 18 03			jr .pastdmark  
37ec ..			.dmark: db "MUL"  
37ef f1			.pastdmark: pop af  
37f0			endm  
# End of macro DMARK
37f0						CALLMONITOR 
37f0 cd 6a 16			call break_point_state  
37f3				endm  
# End of macro CALLMONITOR
37f3					endif 
37f3					FORTH_DSP 
37f3 cd b7 1d			call macro_forth_dsp 
37f6				endm 
# End of macro FORTH_DSP
37f6					; v5 FORTH_DSP_VALUE 
37f6 7e					ld a,(hl)	; get type of value on TOS 
37f7 fe 02				cp DS_TYPE_INUM  
37f9 28 03				jr z, .mul_inum 
37fb			 
37fb				if FORTH_ENABLE_FLOATMATH 
37fb					jr .mul_done 
37fb			 
37fb				endif 
37fb			 
37fb					NEXTW 
37fb c3 63 1f			jp macro_next 
37fe				endm 
# End of macro NEXTW
37fe			.mul_inum:	 
37fe			 
37fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fe cd f1 1d			call macro_dsp_valuehl 
3801				endm 
# End of macro FORTH_DSP_VALUEHL
3801			 
3801 e5					push hl 
3802			 
3802					; destroy value TOS 
3802			 
3802					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3802 cd a9 1e			call macro_forth_dsp_pop 
3805				endm 
# End of macro FORTH_DSP_POP
3805			 
3805			 
3805					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3805 cd f1 1d			call macro_dsp_valuehl 
3808				endm 
# End of macro FORTH_DSP_VALUEHL
3808			 
3808					; one value on hl but move to a get other one back 
3808			 
3808 7d					ld a, l 
3809			 
3809 d1					pop de 
380a			 
380a					; do the mull 
380a			;		ex de, hl 
380a			 
380a cd 89 0c				call Mult16 
380d					; save it 
380d			 
380d			;		push hl	 
380d			 
380d					; 
380d			 
380d					; destroy value TOS 
380d			 
380d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380d cd a9 1e			call macro_forth_dsp_pop 
3810				endm 
# End of macro FORTH_DSP_POP
3810			 
3810					; TODO push value back onto stack for another op etc 
3810			 
3810			;		pop hl 
3810			 
3810 cd fa 1b				call forth_push_numhl 
3813			 
3813			.mul_done: 
3813					NEXTW 
3813 c3 63 1f			jp macro_next 
3816				endm 
# End of macro NEXTW
3816			 
3816			 
3816			 
3816			 
3816			.MIN: 
3816				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3816 49				db WORD_SYS_CORE+53             
3817 97 38			dw .MAX            
3819 04				db 3 + 1 
381a .. 00			db "MIN",0              
381e				endm 
# End of macro CWHEAD
381e			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
381e					if DEBUG_FORTH_WORDS_KEY 
381e						DMARK "MIN" 
381e f5				push af  
381f 3a 33 38			ld a, (.dmark)  
3822 32 bd fb			ld (debug_mark),a  
3825 3a 34 38			ld a, (.dmark+1)  
3828 32 be fb			ld (debug_mark+1),a  
382b 3a 35 38			ld a, (.dmark+2)  
382e 32 bf fb			ld (debug_mark+2),a  
3831 18 03			jr .pastdmark  
3833 ..			.dmark: db "MIN"  
3836 f1			.pastdmark: pop af  
3837			endm  
# End of macro DMARK
3837						CALLMONITOR 
3837 cd 6a 16			call break_point_state  
383a				endm  
# End of macro CALLMONITOR
383a					endif 
383a					; get u2 
383a			 
383a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383a cd f1 1d			call macro_dsp_valuehl 
383d				endm 
# End of macro FORTH_DSP_VALUEHL
383d			 
383d e5					push hl   ; u2 
383e			 
383e					; destroy value TOS 
383e			 
383e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383e cd a9 1e			call macro_forth_dsp_pop 
3841				endm 
# End of macro FORTH_DSP_POP
3841			 
3841					; get u1 
3841			 
3841					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3841 cd f1 1d			call macro_dsp_valuehl 
3844				endm 
# End of macro FORTH_DSP_VALUEHL
3844			 
3844 e5					push hl  ; u1 
3845			 
3845					; destroy value TOS 
3845			 
3845					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3845 cd a9 1e			call macro_forth_dsp_pop 
3848				endm 
# End of macro FORTH_DSP_POP
3848			 
3848 b7			 or a      ;clear carry flag 
3849 e1			  pop hl    ; u1 
384a d1			  pop de    ; u2 
384b e5				push hl   ; saved in case hl is lowest 
384c ed 52		  sbc hl,de 
384e 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3850			 
3850 e1				pop hl 
3851					if DEBUG_FORTH_WORDS 
3851						DMARK "MIN" 
3851 f5				push af  
3852 3a 66 38			ld a, (.dmark)  
3855 32 bd fb			ld (debug_mark),a  
3858 3a 67 38			ld a, (.dmark+1)  
385b 32 be fb			ld (debug_mark+1),a  
385e 3a 68 38			ld a, (.dmark+2)  
3861 32 bf fb			ld (debug_mark+2),a  
3864 18 03			jr .pastdmark  
3866 ..			.dmark: db "MIN"  
3869 f1			.pastdmark: pop af  
386a			endm  
# End of macro DMARK
386a						CALLMONITOR 
386a cd 6a 16			call break_point_state  
386d				endm  
# End of macro CALLMONITOR
386d					endif 
386d cd fa 1b				call forth_push_numhl 
3870			 
3870				       NEXTW 
3870 c3 63 1f			jp macro_next 
3873				endm 
# End of macro NEXTW
3873			 
3873			.mincont:  
3873 c1				pop bc   ; tidy up 
3874 eb				ex de , hl  
3875					if DEBUG_FORTH_WORDS 
3875						DMARK "MI1" 
3875 f5				push af  
3876 3a 8a 38			ld a, (.dmark)  
3879 32 bd fb			ld (debug_mark),a  
387c 3a 8b 38			ld a, (.dmark+1)  
387f 32 be fb			ld (debug_mark+1),a  
3882 3a 8c 38			ld a, (.dmark+2)  
3885 32 bf fb			ld (debug_mark+2),a  
3888 18 03			jr .pastdmark  
388a ..			.dmark: db "MI1"  
388d f1			.pastdmark: pop af  
388e			endm  
# End of macro DMARK
388e						CALLMONITOR 
388e cd 6a 16			call break_point_state  
3891				endm  
# End of macro CALLMONITOR
3891					endif 
3891 cd fa 1b				call forth_push_numhl 
3894			 
3894				       NEXTW 
3894 c3 63 1f			jp macro_next 
3897				endm 
# End of macro NEXTW
3897			.MAX: 
3897				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3897 4a				db WORD_SYS_CORE+54             
3898 18 39			dw .RND16            
389a 04				db 3 + 1 
389b .. 00			db "MAX",0              
389f				endm 
# End of macro CWHEAD
389f			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
389f					if DEBUG_FORTH_WORDS_KEY 
389f						DMARK "MAX" 
389f f5				push af  
38a0 3a b4 38			ld a, (.dmark)  
38a3 32 bd fb			ld (debug_mark),a  
38a6 3a b5 38			ld a, (.dmark+1)  
38a9 32 be fb			ld (debug_mark+1),a  
38ac 3a b6 38			ld a, (.dmark+2)  
38af 32 bf fb			ld (debug_mark+2),a  
38b2 18 03			jr .pastdmark  
38b4 ..			.dmark: db "MAX"  
38b7 f1			.pastdmark: pop af  
38b8			endm  
# End of macro DMARK
38b8						CALLMONITOR 
38b8 cd 6a 16			call break_point_state  
38bb				endm  
# End of macro CALLMONITOR
38bb					endif 
38bb					; get u2 
38bb			 
38bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38bb cd f1 1d			call macro_dsp_valuehl 
38be				endm 
# End of macro FORTH_DSP_VALUEHL
38be			 
38be e5					push hl   ; u2 
38bf			 
38bf					; destroy value TOS 
38bf			 
38bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38bf cd a9 1e			call macro_forth_dsp_pop 
38c2				endm 
# End of macro FORTH_DSP_POP
38c2			 
38c2					; get u1 
38c2			 
38c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c2 cd f1 1d			call macro_dsp_valuehl 
38c5				endm 
# End of macro FORTH_DSP_VALUEHL
38c5			 
38c5 e5					push hl  ; u1 
38c6			 
38c6					; destroy value TOS 
38c6			 
38c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c6 cd a9 1e			call macro_forth_dsp_pop 
38c9				endm 
# End of macro FORTH_DSP_POP
38c9			 
38c9 b7			 or a      ;clear carry flag 
38ca e1			  pop hl    ; u1 
38cb d1			  pop de    ; u2 
38cc e5				push hl   ; saved in case hl is lowest 
38cd ed 52		  sbc hl,de 
38cf 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38d1			 
38d1 e1				pop hl 
38d2					if DEBUG_FORTH_WORDS 
38d2						DMARK "MAX" 
38d2 f5				push af  
38d3 3a e7 38			ld a, (.dmark)  
38d6 32 bd fb			ld (debug_mark),a  
38d9 3a e8 38			ld a, (.dmark+1)  
38dc 32 be fb			ld (debug_mark+1),a  
38df 3a e9 38			ld a, (.dmark+2)  
38e2 32 bf fb			ld (debug_mark+2),a  
38e5 18 03			jr .pastdmark  
38e7 ..			.dmark: db "MAX"  
38ea f1			.pastdmark: pop af  
38eb			endm  
# End of macro DMARK
38eb						CALLMONITOR 
38eb cd 6a 16			call break_point_state  
38ee				endm  
# End of macro CALLMONITOR
38ee					endif 
38ee cd fa 1b				call forth_push_numhl 
38f1			 
38f1				       NEXTW 
38f1 c3 63 1f			jp macro_next 
38f4				endm 
# End of macro NEXTW
38f4			 
38f4			.maxcont:  
38f4 c1				pop bc   ; tidy up 
38f5 eb				ex de , hl  
38f6					if DEBUG_FORTH_WORDS 
38f6						DMARK "MA1" 
38f6 f5				push af  
38f7 3a 0b 39			ld a, (.dmark)  
38fa 32 bd fb			ld (debug_mark),a  
38fd 3a 0c 39			ld a, (.dmark+1)  
3900 32 be fb			ld (debug_mark+1),a  
3903 3a 0d 39			ld a, (.dmark+2)  
3906 32 bf fb			ld (debug_mark+2),a  
3909 18 03			jr .pastdmark  
390b ..			.dmark: db "MA1"  
390e f1			.pastdmark: pop af  
390f			endm  
# End of macro DMARK
390f						CALLMONITOR 
390f cd 6a 16			call break_point_state  
3912				endm  
# End of macro CALLMONITOR
3912					endif 
3912 cd fa 1b				call forth_push_numhl 
3915				       NEXTW 
3915 c3 63 1f			jp macro_next 
3918				endm 
# End of macro NEXTW
3918			 
3918			.RND16: 
3918				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3918 4e				db WORD_SYS_CORE+58             
3919 47 39			dw .RND8            
391b 06				db 5 + 1 
391c .. 00			db "RND16",0              
3922				endm 
# End of macro CWHEAD
3922			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3922					if DEBUG_FORTH_WORDS_KEY 
3922						DMARK "R16" 
3922 f5				push af  
3923 3a 37 39			ld a, (.dmark)  
3926 32 bd fb			ld (debug_mark),a  
3929 3a 38 39			ld a, (.dmark+1)  
392c 32 be fb			ld (debug_mark+1),a  
392f 3a 39 39			ld a, (.dmark+2)  
3932 32 bf fb			ld (debug_mark+2),a  
3935 18 03			jr .pastdmark  
3937 ..			.dmark: db "R16"  
393a f1			.pastdmark: pop af  
393b			endm  
# End of macro DMARK
393b						CALLMONITOR 
393b cd 6a 16			call break_point_state  
393e				endm  
# End of macro CALLMONITOR
393e					endif 
393e cd 2d 0c				call prng16  
3941 cd fa 1b				call forth_push_numhl 
3944				       NEXTW 
3944 c3 63 1f			jp macro_next 
3947				endm 
# End of macro NEXTW
3947			.RND8: 
3947				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3947 60				db WORD_SYS_CORE+76             
3948 7c 39			dw .RND            
394a 05				db 4 + 1 
394b .. 00			db "RND8",0              
3950				endm 
# End of macro CWHEAD
3950			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3950					if DEBUG_FORTH_WORDS_KEY 
3950						DMARK "RN8" 
3950 f5				push af  
3951 3a 65 39			ld a, (.dmark)  
3954 32 bd fb			ld (debug_mark),a  
3957 3a 66 39			ld a, (.dmark+1)  
395a 32 be fb			ld (debug_mark+1),a  
395d 3a 67 39			ld a, (.dmark+2)  
3960 32 bf fb			ld (debug_mark+2),a  
3963 18 03			jr .pastdmark  
3965 ..			.dmark: db "RN8"  
3968 f1			.pastdmark: pop af  
3969			endm  
# End of macro DMARK
3969						CALLMONITOR 
3969 cd 6a 16			call break_point_state  
396c				endm  
# End of macro CALLMONITOR
396c					endif 
396c 2a 3e fa				ld hl,(xrandc) 
396f 23					inc hl 
3970 cd 47 0c				call xrnd 
3973 6f					ld l,a	 
3974 26 00				ld h,0 
3976 cd fa 1b				call forth_push_numhl 
3979				       NEXTW 
3979 c3 63 1f			jp macro_next 
397c				endm 
# End of macro NEXTW
397c			.RND: 
397c				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
397c 60				db WORD_SYS_CORE+76             
397d 82 3a			dw .ENDMATHS            
397f 04				db 3 + 1 
3980 .. 00			db "RND",0              
3984				endm 
# End of macro CWHEAD
3984			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3984			 
3984					if DEBUG_FORTH_WORDS_KEY 
3984						DMARK "RND" 
3984 f5				push af  
3985 3a 99 39			ld a, (.dmark)  
3988 32 bd fb			ld (debug_mark),a  
398b 3a 9a 39			ld a, (.dmark+1)  
398e 32 be fb			ld (debug_mark+1),a  
3991 3a 9b 39			ld a, (.dmark+2)  
3994 32 bf fb			ld (debug_mark+2),a  
3997 18 03			jr .pastdmark  
3999 ..			.dmark: db "RND"  
399c f1			.pastdmark: pop af  
399d			endm  
# End of macro DMARK
399d						CALLMONITOR 
399d cd 6a 16			call break_point_state  
39a0				endm  
# End of macro CALLMONITOR
39a0					endif 
39a0					 
39a0					FORTH_DSP_VALUEHL    ; upper range 
39a0 cd f1 1d			call macro_dsp_valuehl 
39a3				endm 
# End of macro FORTH_DSP_VALUEHL
39a3			 
39a3 22 42 fa				ld (LFSRSeed), hl	 
39a6			 
39a6					if DEBUG_FORTH_WORDS 
39a6						DMARK "RN1" 
39a6 f5				push af  
39a7 3a bb 39			ld a, (.dmark)  
39aa 32 bd fb			ld (debug_mark),a  
39ad 3a bc 39			ld a, (.dmark+1)  
39b0 32 be fb			ld (debug_mark+1),a  
39b3 3a bd 39			ld a, (.dmark+2)  
39b6 32 bf fb			ld (debug_mark+2),a  
39b9 18 03			jr .pastdmark  
39bb ..			.dmark: db "RN1"  
39be f1			.pastdmark: pop af  
39bf			endm  
# End of macro DMARK
39bf						CALLMONITOR 
39bf cd 6a 16			call break_point_state  
39c2				endm  
# End of macro CALLMONITOR
39c2					endif 
39c2					FORTH_DSP_POP 
39c2 cd a9 1e			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5					FORTH_DSP_VALUEHL    ; low range 
39c5 cd f1 1d			call macro_dsp_valuehl 
39c8				endm 
# End of macro FORTH_DSP_VALUEHL
39c8			 
39c8					if DEBUG_FORTH_WORDS 
39c8						DMARK "RN2" 
39c8 f5				push af  
39c9 3a dd 39			ld a, (.dmark)  
39cc 32 bd fb			ld (debug_mark),a  
39cf 3a de 39			ld a, (.dmark+1)  
39d2 32 be fb			ld (debug_mark+1),a  
39d5 3a df 39			ld a, (.dmark+2)  
39d8 32 bf fb			ld (debug_mark+2),a  
39db 18 03			jr .pastdmark  
39dd ..			.dmark: db "RN2"  
39e0 f1			.pastdmark: pop af  
39e1			endm  
# End of macro DMARK
39e1						CALLMONITOR 
39e1 cd 6a 16			call break_point_state  
39e4				endm  
# End of macro CALLMONITOR
39e4					endif 
39e4 22 44 fa				ld (LFSRSeed+2), hl 
39e7			 
39e7					FORTH_DSP_POP 
39e7 cd a9 1e			call macro_forth_dsp_pop 
39ea				endm 
# End of macro FORTH_DSP_POP
39ea			 
39ea e5					push hl 
39eb			 
39eb e1			.inrange:	pop hl 
39ec cd 2d 0c				call prng16  
39ef					if DEBUG_FORTH_WORDS 
39ef						DMARK "RN3" 
39ef f5				push af  
39f0 3a 04 3a			ld a, (.dmark)  
39f3 32 bd fb			ld (debug_mark),a  
39f6 3a 05 3a			ld a, (.dmark+1)  
39f9 32 be fb			ld (debug_mark+1),a  
39fc 3a 06 3a			ld a, (.dmark+2)  
39ff 32 bf fb			ld (debug_mark+2),a  
3a02 18 03			jr .pastdmark  
3a04 ..			.dmark: db "RN3"  
3a07 f1			.pastdmark: pop af  
3a08			endm  
# End of macro DMARK
3a08						CALLMONITOR 
3a08 cd 6a 16			call break_point_state  
3a0b				endm  
# End of macro CALLMONITOR
3a0b					endif 
3a0b					 
3a0b					; if the range is 8bit knock out the high byte 
3a0b			 
3a0b ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
3a0f			 
3a0f 3e 00				ld a, 0 
3a11 ba					cp d  
3a12 20 1e				jr nz, .hirange 
3a14 26 00				ld h, 0   ; knock it down to 8bit 
3a16			 
3a16					if DEBUG_FORTH_WORDS 
3a16						DMARK "RNk" 
3a16 f5				push af  
3a17 3a 2b 3a			ld a, (.dmark)  
3a1a 32 bd fb			ld (debug_mark),a  
3a1d 3a 2c 3a			ld a, (.dmark+1)  
3a20 32 be fb			ld (debug_mark+1),a  
3a23 3a 2d 3a			ld a, (.dmark+2)  
3a26 32 bf fb			ld (debug_mark+2),a  
3a29 18 03			jr .pastdmark  
3a2b ..			.dmark: db "RNk"  
3a2e f1			.pastdmark: pop af  
3a2f			endm  
# End of macro DMARK
3a2f						CALLMONITOR 
3a2f cd 6a 16			call break_point_state  
3a32				endm  
# End of macro CALLMONITOR
3a32					endif 
3a32			.hirange:   
3a32 e5					push hl  
3a33 b7					or a  
3a34 ed 52		                sbc hl, de 
3a36			 
3a36					;call cmp16 
3a36			 
3a36 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a38 e1					pop hl 
3a39 e5					push hl 
3a3a			 
3a3a					if DEBUG_FORTH_WORDS 
3a3a						DMARK "RN4" 
3a3a f5				push af  
3a3b 3a 4f 3a			ld a, (.dmark)  
3a3e 32 bd fb			ld (debug_mark),a  
3a41 3a 50 3a			ld a, (.dmark+1)  
3a44 32 be fb			ld (debug_mark+1),a  
3a47 3a 51 3a			ld a, (.dmark+2)  
3a4a 32 bf fb			ld (debug_mark+2),a  
3a4d 18 03			jr .pastdmark  
3a4f ..			.dmark: db "RN4"  
3a52 f1			.pastdmark: pop af  
3a53			endm  
# End of macro DMARK
3a53						CALLMONITOR 
3a53 cd 6a 16			call break_point_state  
3a56				endm  
# End of macro CALLMONITOR
3a56					endif 
3a56 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
3a5a					;call cmp16 
3a5a				 
3a5a b7					or a  
3a5b ed 52		                sbc hl, de 
3a5d 38 8c				jr c, .inrange 
3a5f			 
3a5f e1					pop hl 
3a60					 
3a60					if DEBUG_FORTH_WORDS 
3a60						DMARK "RNd" 
3a60 f5				push af  
3a61 3a 75 3a			ld a, (.dmark)  
3a64 32 bd fb			ld (debug_mark),a  
3a67 3a 76 3a			ld a, (.dmark+1)  
3a6a 32 be fb			ld (debug_mark+1),a  
3a6d 3a 77 3a			ld a, (.dmark+2)  
3a70 32 bf fb			ld (debug_mark+2),a  
3a73 18 03			jr .pastdmark  
3a75 ..			.dmark: db "RNd"  
3a78 f1			.pastdmark: pop af  
3a79			endm  
# End of macro DMARK
3a79						CALLMONITOR 
3a79 cd 6a 16			call break_point_state  
3a7c				endm  
# End of macro CALLMONITOR
3a7c					endif 
3a7c			 
3a7c			 
3a7c cd fa 1b				call forth_push_numhl 
3a7f				       NEXTW 
3a7f c3 63 1f			jp macro_next 
3a82				endm 
# End of macro NEXTW
3a82			 
3a82			.ENDMATHS: 
3a82			 
3a82			; eof 
3a82			 
# End of file forth_words_maths.asm
3a82			include "forth_words_display.asm" 
3a82			 
3a82			; | ## Display Words 
3a82			 
3a82			.ATP: 
3a82				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a82 62				db WORD_SYS_CORE+78             
3a83 f9 3a			dw .FB            
3a85 04				db 3 + 1 
3a86 .. 00			db "AT?",0              
3a8a				endm 
# End of macro CWHEAD
3a8a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a8a					if DEBUG_FORTH_WORDS_KEY 
3a8a						DMARK "AT?" 
3a8a f5				push af  
3a8b 3a 9f 3a			ld a, (.dmark)  
3a8e 32 bd fb			ld (debug_mark),a  
3a91 3a a0 3a			ld a, (.dmark+1)  
3a94 32 be fb			ld (debug_mark+1),a  
3a97 3a a1 3a			ld a, (.dmark+2)  
3a9a 32 bf fb			ld (debug_mark+2),a  
3a9d 18 03			jr .pastdmark  
3a9f ..			.dmark: db "AT?"  
3aa2 f1			.pastdmark: pop af  
3aa3			endm  
# End of macro DMARK
3aa3						CALLMONITOR 
3aa3 cd 6a 16			call break_point_state  
3aa6				endm  
# End of macro CALLMONITOR
3aa6					endif 
3aa6 3a cc f9				ld a, (f_cursor_ptr) 
3aa9			 
3aa9			if DEBUG_FORTH_WORDS 
3aa9				DMARK "AT?" 
3aa9 f5				push af  
3aaa 3a be 3a			ld a, (.dmark)  
3aad 32 bd fb			ld (debug_mark),a  
3ab0 3a bf 3a			ld a, (.dmark+1)  
3ab3 32 be fb			ld (debug_mark+1),a  
3ab6 3a c0 3a			ld a, (.dmark+2)  
3ab9 32 bf fb			ld (debug_mark+2),a  
3abc 18 03			jr .pastdmark  
3abe ..			.dmark: db "AT?"  
3ac1 f1			.pastdmark: pop af  
3ac2			endm  
# End of macro DMARK
3ac2				CALLMONITOR 
3ac2 cd 6a 16			call break_point_state  
3ac5				endm  
# End of macro CALLMONITOR
3ac5			endif	 
3ac5					; count the number of rows 
3ac5			 
3ac5 06 00				ld b, 0 
3ac7 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ac8 d6 14				sub display_cols 
3aca f2 d0 3a				jp p, .atprunder 
3acd 04					inc b 
3ace 18 f7				jr .atpr 
3ad0			.atprunder:	 
3ad0			if DEBUG_FORTH_WORDS 
3ad0				DMARK "A?2" 
3ad0 f5				push af  
3ad1 3a e5 3a			ld a, (.dmark)  
3ad4 32 bd fb			ld (debug_mark),a  
3ad7 3a e6 3a			ld a, (.dmark+1)  
3ada 32 be fb			ld (debug_mark+1),a  
3add 3a e7 3a			ld a, (.dmark+2)  
3ae0 32 bf fb			ld (debug_mark+2),a  
3ae3 18 03			jr .pastdmark  
3ae5 ..			.dmark: db "A?2"  
3ae8 f1			.pastdmark: pop af  
3ae9			endm  
# End of macro DMARK
3ae9				CALLMONITOR 
3ae9 cd 6a 16			call break_point_state  
3aec				endm  
# End of macro CALLMONITOR
3aec			endif	 
3aec 26 00				ld h, 0 
3aee 69					ld l, c 
3aef cd fa 1b				call forth_push_numhl 
3af2 68					ld l, b  
3af3 cd fa 1b				call forth_push_numhl 
3af6			 
3af6			 
3af6				NEXTW 
3af6 c3 63 1f			jp macro_next 
3af9				endm 
# End of macro NEXTW
3af9			 
3af9			.FB: 
3af9				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3af9 1b				db WORD_SYS_CORE+7             
3afa 47 3b			dw .EMIT            
3afc 03				db 2 + 1 
3afd .. 00			db "FB",0              
3b00				endm 
# End of macro CWHEAD
3b00			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b00			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b00			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b00			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b00					if DEBUG_FORTH_WORDS_KEY 
3b00						DMARK "FB." 
3b00 f5				push af  
3b01 3a 15 3b			ld a, (.dmark)  
3b04 32 bd fb			ld (debug_mark),a  
3b07 3a 16 3b			ld a, (.dmark+1)  
3b0a 32 be fb			ld (debug_mark+1),a  
3b0d 3a 17 3b			ld a, (.dmark+2)  
3b10 32 bf fb			ld (debug_mark+2),a  
3b13 18 03			jr .pastdmark  
3b15 ..			.dmark: db "FB."  
3b18 f1			.pastdmark: pop af  
3b19			endm  
# End of macro DMARK
3b19						CALLMONITOR 
3b19 cd 6a 16			call break_point_state  
3b1c				endm  
# End of macro CALLMONITOR
3b1c					endif 
3b1c			 
3b1c					FORTH_DSP_VALUEHL 
3b1c cd f1 1d			call macro_dsp_valuehl 
3b1f				endm 
# End of macro FORTH_DSP_VALUEHL
3b1f			 
3b1f 7d					ld a, l 
3b20 fe 01				cp 1 
3b22 20 05				jr nz, .fbn1 
3b24 21 02 fb				ld hl, display_fb1 
3b27 18 15				jr .fbset 
3b29 fe 02		.fbn1:		cp 2 
3b2b 20 05				jr nz, .fbn2 
3b2d 21 60 fa				ld hl, display_fb2 
3b30 18 0c				jr .fbset 
3b32 fe 03		.fbn2:		cp 3 
3b34 20 05				jr nz, .fbn3 
3b36 21 b1 fa				ld hl, display_fb3 
3b39 18 03				jr .fbset 
3b3b			.fbn3:		 ; if invalid number select first 
3b3b 21 02 fb				ld hl, display_fb1 
3b3e 22 5e fa		.fbset:		ld (display_fb_active), hl 
3b41			 
3b41					FORTH_DSP_POP 
3b41 cd a9 1e			call macro_forth_dsp_pop 
3b44				endm 
# End of macro FORTH_DSP_POP
3b44			 
3b44					NEXTW 
3b44 c3 63 1f			jp macro_next 
3b47				endm 
# End of macro NEXTW
3b47			 
3b47			 
3b47			.EMIT: 
3b47				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b47 1b				db WORD_SYS_CORE+7             
3b48 98 3b			dw .DOTH            
3b4a 05				db 4 + 1 
3b4b .. 00			db "EMIT",0              
3b50				endm 
# End of macro CWHEAD
3b50			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b50					; get value off TOS and display it 
3b50			 
3b50					if DEBUG_FORTH_WORDS_KEY 
3b50						DMARK "EMT" 
3b50 f5				push af  
3b51 3a 65 3b			ld a, (.dmark)  
3b54 32 bd fb			ld (debug_mark),a  
3b57 3a 66 3b			ld a, (.dmark+1)  
3b5a 32 be fb			ld (debug_mark+1),a  
3b5d 3a 67 3b			ld a, (.dmark+2)  
3b60 32 bf fb			ld (debug_mark+2),a  
3b63 18 03			jr .pastdmark  
3b65 ..			.dmark: db "EMT"  
3b68 f1			.pastdmark: pop af  
3b69			endm  
# End of macro DMARK
3b69						CALLMONITOR 
3b69 cd 6a 16			call break_point_state  
3b6c				endm  
# End of macro CALLMONITOR
3b6c					endif 
3b6c			 
3b6c					FORTH_DSP_VALUEHL 
3b6c cd f1 1d			call macro_dsp_valuehl 
3b6f				endm 
# End of macro FORTH_DSP_VALUEHL
3b6f			 
3b6f 7d					ld a,l 
3b70			 
3b70					; TODO write to display 
3b70			 
3b70 32 a1 f1				ld (os_input), a 
3b73 3e 00				ld a, 0 
3b75 32 a2 f1				ld (os_input+1), a 
3b78					 
3b78 3a cc f9				ld a, (f_cursor_ptr) 
3b7b 11 a1 f1				ld de, os_input 
3b7e cd e5 0a				call str_at_display 
3b81			 
3b81			 
3b81 3a aa f9				ld a,(cli_autodisplay) 
3b84 fe 00				cp 0 
3b86 28 03				jr z, .enoupdate 
3b88 cd f5 0a						call update_display 
3b8b					.enoupdate: 
3b8b			 
3b8b 3a cc f9				ld a, (f_cursor_ptr) 
3b8e 3c					inc a 
3b8f 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3b92			 
3b92			 
3b92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b92 cd a9 1e			call macro_forth_dsp_pop 
3b95				endm 
# End of macro FORTH_DSP_POP
3b95			  
3b95			 
3b95					NEXTW 
3b95 c3 63 1f			jp macro_next 
3b98				endm 
# End of macro NEXTW
3b98			.DOTH: 
3b98				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b98 1c				db WORD_SYS_CORE+8             
3b99 c8 3b			dw .DOTF            
3b9b 03				db 2 + 1 
3b9c .. 00			db ".-",0              
3b9f				endm 
# End of macro CWHEAD
3b9f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b9f					; get value off TOS and display it 
3b9f					if DEBUG_FORTH_WORDS_KEY 
3b9f						DMARK "DTD" 
3b9f f5				push af  
3ba0 3a b4 3b			ld a, (.dmark)  
3ba3 32 bd fb			ld (debug_mark),a  
3ba6 3a b5 3b			ld a, (.dmark+1)  
3ba9 32 be fb			ld (debug_mark+1),a  
3bac 3a b6 3b			ld a, (.dmark+2)  
3baf 32 bf fb			ld (debug_mark+2),a  
3bb2 18 03			jr .pastdmark  
3bb4 ..			.dmark: db "DTD"  
3bb7 f1			.pastdmark: pop af  
3bb8			endm  
# End of macro DMARK
3bb8						CALLMONITOR 
3bb8 cd 6a 16			call break_point_state  
3bbb				endm  
# End of macro CALLMONITOR
3bbb					endif 
3bbb 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bbd 3e 00			ld a, 0 
3bbf 32 ab f9			ld (cli_mvdot), a 
3bc2 c3 1f 3c			jp .dotgo 
3bc5				NEXTW 
3bc5 c3 63 1f			jp macro_next 
3bc8				endm 
# End of macro NEXTW
3bc8			.DOTF: 
3bc8				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bc8 1c				db WORD_SYS_CORE+8             
3bc9 f6 3b			dw .DOT            
3bcb 03				db 2 + 1 
3bcc .. 00			db ".>",0              
3bcf				endm 
# End of macro CWHEAD
3bcf			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bcf					; get value off TOS and display it 
3bcf			        ; TODO BUG adds extra spaces 
3bcf			        ; TODO BUG handle numerics? 
3bcf					if DEBUG_FORTH_WORDS_KEY 
3bcf						DMARK "DTC" 
3bcf f5				push af  
3bd0 3a e4 3b			ld a, (.dmark)  
3bd3 32 bd fb			ld (debug_mark),a  
3bd6 3a e5 3b			ld a, (.dmark+1)  
3bd9 32 be fb			ld (debug_mark+1),a  
3bdc 3a e6 3b			ld a, (.dmark+2)  
3bdf 32 bf fb			ld (debug_mark+2),a  
3be2 18 03			jr .pastdmark  
3be4 ..			.dmark: db "DTC"  
3be7 f1			.pastdmark: pop af  
3be8			endm  
# End of macro DMARK
3be8						CALLMONITOR 
3be8 cd 6a 16			call break_point_state  
3beb				endm  
# End of macro CALLMONITOR
3beb					endif 
3beb 3e 01			ld a, 1 
3bed 32 ab f9			ld (cli_mvdot), a 
3bf0 c3 1f 3c			jp .dotgo 
3bf3				NEXTW 
3bf3 c3 63 1f			jp macro_next 
3bf6				endm 
# End of macro NEXTW
3bf6			 
3bf6			.DOT: 
3bf6				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bf6 1c				db WORD_SYS_CORE+8             
3bf7 82 3c			dw .CLS            
3bf9 02				db 1 + 1 
3bfa .. 00			db ".",0              
3bfc				endm 
# End of macro CWHEAD
3bfc			        ; | . ( u -- ) Display TOS | DONE 
3bfc					; get value off TOS and display it 
3bfc			 
3bfc					if DEBUG_FORTH_WORDS_KEY 
3bfc						DMARK "DOT" 
3bfc f5				push af  
3bfd 3a 11 3c			ld a, (.dmark)  
3c00 32 bd fb			ld (debug_mark),a  
3c03 3a 12 3c			ld a, (.dmark+1)  
3c06 32 be fb			ld (debug_mark+1),a  
3c09 3a 13 3c			ld a, (.dmark+2)  
3c0c 32 bf fb			ld (debug_mark+2),a  
3c0f 18 03			jr .pastdmark  
3c11 ..			.dmark: db "DOT"  
3c14 f1			.pastdmark: pop af  
3c15			endm  
# End of macro DMARK
3c15						CALLMONITOR 
3c15 cd 6a 16			call break_point_state  
3c18				endm  
# End of macro CALLMONITOR
3c18					endif 
3c18 3e 00			ld a, 0 
3c1a 32 ab f9			ld (cli_mvdot), a 
3c1d 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c1f				 
3c1f			 
3c1f			.dotgo: 
3c1f			 
3c1f			; move up type to on stack for parserv5 
3c1f					FORTH_DSP 
3c1f cd b7 1d			call macro_forth_dsp 
3c22				endm 
# End of macro FORTH_DSP
3c22				;FORTH_DSP_VALUE  
3c22			 
3c22			if DEBUG_FORTH_DOT 
3c22				DMARK "DOT" 
3c22				CALLMONITOR 
3c22			endif	 
3c22			;		.print: 
3c22			 
3c22 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c23 23				inc hl   ; position to the actual value 
3c24 fe 01			cp DS_TYPE_STR 
3c26 20 06			jr nz, .dotnum1  
3c28			 
3c28			; display string 
3c28				FORTH_DSP_VALUE  
3c28 cd da 1d			call macro_forth_dsp_value 
3c2b				endm 
# End of macro FORTH_DSP_VALUE
3c2b eb				ex de,hl 
3c2c 18 11			jr .dotwrite 
3c2e			 
3c2e			.dotnum1: 
3c2e fe 02			cp DS_TYPE_INUM 
3c30 20 0c			jr nz, .dotflot 
3c32			 
3c32			 
3c32			; display number 
3c32			 
3c32			;	push hl 
3c32			;	call clear_display 
3c32			;	pop hl 
3c32			 
3c32 5e				ld e, (hl) 
3c33 23				inc hl 
3c34 56				ld d, (hl) 
3c35 21 a3 ef			ld hl, scratch 
3c38			if DEBUG_FORTH_DOT 
3c38				DMARK "DT1" 
3c38				CALLMONITOR 
3c38			endif	 
3c38			 
3c38 cd 13 11			call uitoa_16 
3c3b eb				ex de,hl 
3c3c			 
3c3c			if DEBUG_FORTH_DOT 
3c3c				DMARK "DT2" 
3c3c				CALLMONITOR 
3c3c			endif	 
3c3c			 
3c3c			;	ld de, os_word_scratch 
3c3c 18 01			jr .dotwrite 
3c3e			 
3c3e 00			.dotflot:   nop 
3c3f			; TODO print floating point number 
3c3f			 
3c3f			.dotwrite:		 
3c3f			 
3c3f					; if c is set then set all '-' to spaces 
3c3f					; need to also take into account .>  
3c3f			 
3c3f 3e 01				ld a, 1 
3c41 b9					cp c 
3c42 20 13				jr nz, .nodashswap 
3c44			 
3c44					; DE has the string to write, working with HL 
3c44			 
3c44 06 ff				ld b, 255 
3c46 d5					push de 
3c47 e1					pop hl 
3c48			 
3c48			if DEBUG_FORTH_DOT 
3c48				DMARK "DT-" 
3c48				CALLMONITOR 
3c48			endif	 
3c48 7e			.dashscan:	ld a, (hl) 
3c49 fe 00				cp 0 
3c4b 28 0a				jr z, .nodashswap 
3c4d fe 2d				cp '-' 
3c4f 20 03				jr nz, .dashskip 
3c51 3e 20				ld a, ' ' 
3c53 77					ld (hl), a 
3c54 23			.dashskip:	inc hl 
3c55			if DEBUG_FORTH_DOT 
3c55				DMARK "D-2" 
3c55				CALLMONITOR 
3c55			endif	 
3c55 10 f1				djnz .dashscan 
3c57			 
3c57			if DEBUG_FORTH_DOT 
3c57				DMARK "D-1" 
3c57				CALLMONITOR 
3c57			endif	 
3c57			 
3c57			.nodashswap: 
3c57			 
3c57 e5					push hl   ; save string start in case we need to advance print 
3c58			 
3c58 3a cc f9				ld a, (f_cursor_ptr) 
3c5b cd e5 0a				call str_at_display 
3c5e 3a aa f9				ld a,(cli_autodisplay) 
3c61 fe 00				cp 0 
3c63 28 03				jr z, .noupdate 
3c65 cd f5 0a						call update_display 
3c68					.noupdate: 
3c68			 
3c68			 
3c68					; see if we need to advance the print position 
3c68			 
3c68 e1					pop hl   ; get back string 
3c69			 
3c69 3a ab f9				ld a, (cli_mvdot) 
3c6c			if DEBUG_FORTH_DOT 
3c6c					ld e,a 
3c6c				DMARK "D>1" 
3c6c				CALLMONITOR 
3c6c			endif	 
3c6c fe 00				cp 0 
3c6e 28 0c				jr z, .noadv 
3c70					; yes, lets advance the print position 
3c70 3e 00				ld a, 0 
3c72 cd 6f 11				call strlent 
3c75 3a cc f9				ld a, (f_cursor_ptr) 
3c78 85					add a,l 
3c79					;call addatohl 
3c79					;ld a, l 
3c79 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3c7c			 
3c7c			if DEBUG_FORTH_DOT 
3c7c				DMARK "D->" 
3c7c				CALLMONITOR 
3c7c			endif	 
3c7c			 
3c7c			.noadv:	 
3c7c			 
3c7c					if DEBUG_FORTH_DOT_WAIT 
3c7c							call next_page_prompt 
3c7c					endif	 
3c7c			; TODO this pop off the stack causes a crash. i dont know why 
3c7c			 
3c7c			 
3c7c			if DEBUG_FORTH_DOT 
3c7c				DMARK "DTh" 
3c7c				CALLMONITOR 
3c7c			endif	 
3c7c			 
3c7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7c cd a9 1e			call macro_forth_dsp_pop 
3c7f				endm 
# End of macro FORTH_DSP_POP
3c7f			 
3c7f			if DEBUG_FORTH_DOT 
3c7f				DMARK "DTi" 
3c7f				CALLMONITOR 
3c7f			endif	 
3c7f			 
3c7f			 
3c7f					NEXTW 
3c7f c3 63 1f			jp macro_next 
3c82				endm 
# End of macro NEXTW
3c82			 
3c82			.CLS: 
3c82				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c82 35				db WORD_SYS_CORE+33             
3c83 af 3c			dw .DRAW            
3c85 04				db 3 + 1 
3c86 .. 00			db "CLS",0              
3c8a				endm 
# End of macro CWHEAD
3c8a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c8a					if DEBUG_FORTH_WORDS_KEY 
3c8a						DMARK "CLS" 
3c8a f5				push af  
3c8b 3a 9f 3c			ld a, (.dmark)  
3c8e 32 bd fb			ld (debug_mark),a  
3c91 3a a0 3c			ld a, (.dmark+1)  
3c94 32 be fb			ld (debug_mark+1),a  
3c97 3a a1 3c			ld a, (.dmark+2)  
3c9a 32 bf fb			ld (debug_mark+2),a  
3c9d 18 03			jr .pastdmark  
3c9f ..			.dmark: db "CLS"  
3ca2 f1			.pastdmark: pop af  
3ca3			endm  
# End of macro DMARK
3ca3						CALLMONITOR 
3ca3 cd 6a 16			call break_point_state  
3ca6				endm  
# End of macro CALLMONITOR
3ca6					endif 
3ca6 cd d2 0a				call clear_display 
3ca9 c3 bd 3d				jp .home		; and home cursor 
3cac					NEXTW 
3cac c3 63 1f			jp macro_next 
3caf				endm 
# End of macro NEXTW
3caf			 
3caf			.DRAW: 
3caf				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3caf 36				db WORD_SYS_CORE+34             
3cb0 da 3c			dw .DUMP            
3cb2 05				db 4 + 1 
3cb3 .. 00			db "DRAW",0              
3cb8				endm 
# End of macro CWHEAD
3cb8			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3cb8					if DEBUG_FORTH_WORDS_KEY 
3cb8						DMARK "DRW" 
3cb8 f5				push af  
3cb9 3a cd 3c			ld a, (.dmark)  
3cbc 32 bd fb			ld (debug_mark),a  
3cbf 3a ce 3c			ld a, (.dmark+1)  
3cc2 32 be fb			ld (debug_mark+1),a  
3cc5 3a cf 3c			ld a, (.dmark+2)  
3cc8 32 bf fb			ld (debug_mark+2),a  
3ccb 18 03			jr .pastdmark  
3ccd ..			.dmark: db "DRW"  
3cd0 f1			.pastdmark: pop af  
3cd1			endm  
# End of macro DMARK
3cd1						CALLMONITOR 
3cd1 cd 6a 16			call break_point_state  
3cd4				endm  
# End of macro CALLMONITOR
3cd4					endif 
3cd4 cd f5 0a				call update_display 
3cd7					NEXTW 
3cd7 c3 63 1f			jp macro_next 
3cda				endm 
# End of macro NEXTW
3cda			 
3cda			.DUMP: 
3cda				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3cda 37				db WORD_SYS_CORE+35             
3cdb 12 3d			dw .CDUMP            
3cdd 05				db 4 + 1 
3cde .. 00			db "DUMP",0              
3ce3				endm 
# End of macro CWHEAD
3ce3			; | DUMP ( x -- ) With address x display dump   | DONE 
3ce3			; TODO pop address to use off of the stack 
3ce3					if DEBUG_FORTH_WORDS_KEY 
3ce3						DMARK "DUM" 
3ce3 f5				push af  
3ce4 3a f8 3c			ld a, (.dmark)  
3ce7 32 bd fb			ld (debug_mark),a  
3cea 3a f9 3c			ld a, (.dmark+1)  
3ced 32 be fb			ld (debug_mark+1),a  
3cf0 3a fa 3c			ld a, (.dmark+2)  
3cf3 32 bf fb			ld (debug_mark+2),a  
3cf6 18 03			jr .pastdmark  
3cf8 ..			.dmark: db "DUM"  
3cfb f1			.pastdmark: pop af  
3cfc			endm  
# End of macro DMARK
3cfc						CALLMONITOR 
3cfc cd 6a 16			call break_point_state  
3cff				endm  
# End of macro CALLMONITOR
3cff					endif 
3cff cd d2 0a				call clear_display 
3d02			 
3d02					; get address 
3d02			 
3d02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d02 cd f1 1d			call macro_dsp_valuehl 
3d05				endm 
# End of macro FORTH_DSP_VALUEHL
3d05				 
3d05					; save it for cdump 
3d05			 
3d05 22 c6 f2				ld (os_cur_ptr),hl 
3d08			 
3d08					; destroy value TOS 
3d08			 
3d08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d08 cd a9 1e			call macro_forth_dsp_pop 
3d0b				endm 
# End of macro FORTH_DSP_POP
3d0b			 
3d0b cd 7a 1a				call dumpcont	; skip old style of param parsing	 
3d0e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3d0f					NEXTW 
3d0f c3 63 1f			jp macro_next 
3d12				endm 
# End of macro NEXTW
3d12			.CDUMP: 
3d12				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3d12 38				db WORD_SYS_CORE+36             
3d13 42 3d			dw .DAT            
3d15 06				db 5 + 1 
3d16 .. 00			db "CDUMP",0              
3d1c				endm 
# End of macro CWHEAD
3d1c			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d1c					if DEBUG_FORTH_WORDS_KEY 
3d1c						DMARK "CDP" 
3d1c f5				push af  
3d1d 3a 31 3d			ld a, (.dmark)  
3d20 32 bd fb			ld (debug_mark),a  
3d23 3a 32 3d			ld a, (.dmark+1)  
3d26 32 be fb			ld (debug_mark+1),a  
3d29 3a 33 3d			ld a, (.dmark+2)  
3d2c 32 bf fb			ld (debug_mark+2),a  
3d2f 18 03			jr .pastdmark  
3d31 ..			.dmark: db "CDP"  
3d34 f1			.pastdmark: pop af  
3d35			endm  
# End of macro DMARK
3d35						CALLMONITOR 
3d35 cd 6a 16			call break_point_state  
3d38				endm  
# End of macro CALLMONITOR
3d38					endif 
3d38 cd d2 0a				call clear_display 
3d3b cd 7a 1a				call dumpcont	 
3d3e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d3f					NEXTW 
3d3f c3 63 1f			jp macro_next 
3d42				endm 
# End of macro NEXTW
3d42			 
3d42			 
3d42			 
3d42			 
3d42			.DAT: 
3d42				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d42 3d				db WORD_SYS_CORE+41             
3d43 98 3d			dw .HOME            
3d45 03				db 2 + 1 
3d46 .. 00			db "AT",0              
3d49				endm 
# End of macro CWHEAD
3d49			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d49					if DEBUG_FORTH_WORDS_KEY 
3d49						DMARK "AT." 
3d49 f5				push af  
3d4a 3a 5e 3d			ld a, (.dmark)  
3d4d 32 bd fb			ld (debug_mark),a  
3d50 3a 5f 3d			ld a, (.dmark+1)  
3d53 32 be fb			ld (debug_mark+1),a  
3d56 3a 60 3d			ld a, (.dmark+2)  
3d59 32 bf fb			ld (debug_mark+2),a  
3d5c 18 03			jr .pastdmark  
3d5e ..			.dmark: db "AT."  
3d61 f1			.pastdmark: pop af  
3d62			endm  
# End of macro DMARK
3d62						CALLMONITOR 
3d62 cd 6a 16			call break_point_state  
3d65				endm  
# End of macro CALLMONITOR
3d65					endif 
3d65					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d65 cd f1 1d			call macro_dsp_valuehl 
3d68				endm 
# End of macro FORTH_DSP_VALUEHL
3d68			 
3d68			 
3d68					; TODO save cursor row 
3d68 7d					ld a,l 
3d69 fe 02				cp 2 
3d6b 20 04				jr nz, .crow3 
3d6d 3e 14				ld a, display_row_2 
3d6f 18 12				jr .ccol1 
3d71 fe 03		.crow3:		cp 3 
3d73 20 04				jr nz, .crow4 
3d75 3e 28				ld a, display_row_3 
3d77 18 0a				jr .ccol1 
3d79 fe 04		.crow4:		cp 4 
3d7b 20 04				jr nz, .crow1 
3d7d 3e 3c				ld a, display_row_4 
3d7f 18 02				jr .ccol1 
3d81 3e 00		.crow1:		ld a,display_row_1 
3d83 f5			.ccol1:		push af			; got row offset 
3d84 6f					ld l,a 
3d85 26 00				ld h,0 
3d87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d87 cd a9 1e			call macro_forth_dsp_pop 
3d8a				endm 
# End of macro FORTH_DSP_POP
3d8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8a cd f1 1d			call macro_dsp_valuehl 
3d8d				endm 
# End of macro FORTH_DSP_VALUEHL
3d8d					; TODO save cursor col 
3d8d f1					pop af 
3d8e 85					add l		; add col offset 
3d8f 32 cc f9				ld (f_cursor_ptr), a 
3d92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d92 cd a9 1e			call macro_forth_dsp_pop 
3d95				endm 
# End of macro FORTH_DSP_POP
3d95			 
3d95					; calculate  
3d95			 
3d95					NEXTW 
3d95 c3 63 1f			jp macro_next 
3d98				endm 
# End of macro NEXTW
3d98			 
3d98			 
3d98			.HOME: 
3d98				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d98 41				db WORD_SYS_CORE+45             
3d99 c5 3d			dw .SPACE            
3d9b 05				db 4 + 1 
3d9c .. 00			db "HOME",0              
3da1				endm 
# End of macro CWHEAD
3da1			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3da1					if DEBUG_FORTH_WORDS_KEY 
3da1						DMARK "HOM" 
3da1 f5				push af  
3da2 3a b6 3d			ld a, (.dmark)  
3da5 32 bd fb			ld (debug_mark),a  
3da8 3a b7 3d			ld a, (.dmark+1)  
3dab 32 be fb			ld (debug_mark+1),a  
3dae 3a b8 3d			ld a, (.dmark+2)  
3db1 32 bf fb			ld (debug_mark+2),a  
3db4 18 03			jr .pastdmark  
3db6 ..			.dmark: db "HOM"  
3db9 f1			.pastdmark: pop af  
3dba			endm  
# End of macro DMARK
3dba						CALLMONITOR 
3dba cd 6a 16			call break_point_state  
3dbd				endm  
# End of macro CALLMONITOR
3dbd					endif 
3dbd 3e 00		.home:		ld a, 0		; and home cursor 
3dbf 32 cc f9				ld (f_cursor_ptr), a 
3dc2					NEXTW 
3dc2 c3 63 1f			jp macro_next 
3dc5				endm 
# End of macro NEXTW
3dc5			 
3dc5			 
3dc5			.SPACE: 
3dc5				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3dc5 46				db WORD_SYS_CORE+50             
3dc6 f3 3d			dw .SPACES            
3dc8 03				db 2 + 1 
3dc9 .. 00			db "BL",0              
3dcc				endm 
# End of macro CWHEAD
3dcc			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3dcc					if DEBUG_FORTH_WORDS_KEY 
3dcc						DMARK "BL." 
3dcc f5				push af  
3dcd 3a e1 3d			ld a, (.dmark)  
3dd0 32 bd fb			ld (debug_mark),a  
3dd3 3a e2 3d			ld a, (.dmark+1)  
3dd6 32 be fb			ld (debug_mark+1),a  
3dd9 3a e3 3d			ld a, (.dmark+2)  
3ddc 32 bf fb			ld (debug_mark+2),a  
3ddf 18 03			jr .pastdmark  
3de1 ..			.dmark: db "BL."  
3de4 f1			.pastdmark: pop af  
3de5			endm  
# End of macro DMARK
3de5						CALLMONITOR 
3de5 cd 6a 16			call break_point_state  
3de8				endm  
# End of macro CALLMONITOR
3de8					endif 
3de8 21 f1 3d				ld hl, .blstr 
3deb cd 68 1c				call forth_push_str 
3dee					 
3dee				       NEXTW 
3dee c3 63 1f			jp macro_next 
3df1				endm 
# End of macro NEXTW
3df1			 
3df1 .. 00		.blstr: db " ", 0 
3df3			 
3df3			.SPACES: 
3df3				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3df3 47				db WORD_SYS_CORE+51             
3df4 8e 3e			dw .SCROLL            
3df6 07				db 6 + 1 
3df7 .. 00			db "SPACES",0              
3dfe				endm 
# End of macro CWHEAD
3dfe			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3dfe					if DEBUG_FORTH_WORDS_KEY 
3dfe						DMARK "SPS" 
3dfe f5				push af  
3dff 3a 13 3e			ld a, (.dmark)  
3e02 32 bd fb			ld (debug_mark),a  
3e05 3a 14 3e			ld a, (.dmark+1)  
3e08 32 be fb			ld (debug_mark+1),a  
3e0b 3a 15 3e			ld a, (.dmark+2)  
3e0e 32 bf fb			ld (debug_mark+2),a  
3e11 18 03			jr .pastdmark  
3e13 ..			.dmark: db "SPS"  
3e16 f1			.pastdmark: pop af  
3e17			endm  
# End of macro DMARK
3e17						CALLMONITOR 
3e17 cd 6a 16			call break_point_state  
3e1a				endm  
# End of macro CALLMONITOR
3e1a					endif 
3e1a			 
3e1a			 
3e1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e1a cd f1 1d			call macro_dsp_valuehl 
3e1d				endm 
# End of macro FORTH_DSP_VALUEHL
3e1d			 
3e1d			;		push hl    ; u 
3e1d					if DEBUG_FORTH_WORDS 
3e1d						DMARK "SPA" 
3e1d f5				push af  
3e1e 3a 32 3e			ld a, (.dmark)  
3e21 32 bd fb			ld (debug_mark),a  
3e24 3a 33 3e			ld a, (.dmark+1)  
3e27 32 be fb			ld (debug_mark+1),a  
3e2a 3a 34 3e			ld a, (.dmark+2)  
3e2d 32 bf fb			ld (debug_mark+2),a  
3e30 18 03			jr .pastdmark  
3e32 ..			.dmark: db "SPA"  
3e35 f1			.pastdmark: pop af  
3e36			endm  
# End of macro DMARK
3e36						CALLMONITOR 
3e36 cd 6a 16			call break_point_state  
3e39				endm  
# End of macro CALLMONITOR
3e39					endif 
3e39			 
3e39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e39 cd a9 1e			call macro_forth_dsp_pop 
3e3c				endm 
# End of macro FORTH_DSP_POP
3e3c			;		pop hl 
3e3c 4d					ld c, l 
3e3d 06 00				ld b, 0 
3e3f 21 a3 ef				ld hl, scratch  
3e42			 
3e42					if DEBUG_FORTH_WORDS 
3e42						DMARK "SP2" 
3e42 f5				push af  
3e43 3a 57 3e			ld a, (.dmark)  
3e46 32 bd fb			ld (debug_mark),a  
3e49 3a 58 3e			ld a, (.dmark+1)  
3e4c 32 be fb			ld (debug_mark+1),a  
3e4f 3a 59 3e			ld a, (.dmark+2)  
3e52 32 bf fb			ld (debug_mark+2),a  
3e55 18 03			jr .pastdmark  
3e57 ..			.dmark: db "SP2"  
3e5a f1			.pastdmark: pop af  
3e5b			endm  
# End of macro DMARK
3e5b						CALLMONITOR 
3e5b cd 6a 16			call break_point_state  
3e5e				endm  
# End of macro CALLMONITOR
3e5e					endif 
3e5e 3e 20				ld a, ' ' 
3e60 c5			.spaces1:	push bc 
3e61 77					ld (hl),a 
3e62 23					inc hl 
3e63 c1					pop bc 
3e64 10 fa				djnz .spaces1 
3e66 3e 00				ld a,0 
3e68 77					ld (hl),a 
3e69 21 a3 ef				ld hl, scratch 
3e6c					if DEBUG_FORTH_WORDS 
3e6c						DMARK "SP3" 
3e6c f5				push af  
3e6d 3a 81 3e			ld a, (.dmark)  
3e70 32 bd fb			ld (debug_mark),a  
3e73 3a 82 3e			ld a, (.dmark+1)  
3e76 32 be fb			ld (debug_mark+1),a  
3e79 3a 83 3e			ld a, (.dmark+2)  
3e7c 32 bf fb			ld (debug_mark+2),a  
3e7f 18 03			jr .pastdmark  
3e81 ..			.dmark: db "SP3"  
3e84 f1			.pastdmark: pop af  
3e85			endm  
# End of macro DMARK
3e85						CALLMONITOR 
3e85 cd 6a 16			call break_point_state  
3e88				endm  
# End of macro CALLMONITOR
3e88					endif 
3e88 cd 63 1d				call forth_apush 
3e8b			 
3e8b				       NEXTW 
3e8b c3 63 1f			jp macro_next 
3e8e				endm 
# End of macro NEXTW
3e8e			 
3e8e			 
3e8e			 
3e8e			.SCROLL: 
3e8e				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e8e 53				db WORD_SYS_CORE+63             
3e8f bb 3e			dw .SCROLLD            
3e91 07				db 6 + 1 
3e92 .. 00			db "SCROLL",0              
3e99				endm 
# End of macro CWHEAD
3e99			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e99					if DEBUG_FORTH_WORDS_KEY 
3e99						DMARK "SCR" 
3e99 f5				push af  
3e9a 3a ae 3e			ld a, (.dmark)  
3e9d 32 bd fb			ld (debug_mark),a  
3ea0 3a af 3e			ld a, (.dmark+1)  
3ea3 32 be fb			ld (debug_mark+1),a  
3ea6 3a b0 3e			ld a, (.dmark+2)  
3ea9 32 bf fb			ld (debug_mark+2),a  
3eac 18 03			jr .pastdmark  
3eae ..			.dmark: db "SCR"  
3eb1 f1			.pastdmark: pop af  
3eb2			endm  
# End of macro DMARK
3eb2						CALLMONITOR 
3eb2 cd 6a 16			call break_point_state  
3eb5				endm  
# End of macro CALLMONITOR
3eb5					endif 
3eb5			 
3eb5 cd 94 0a			call scroll_up 
3eb8			;	call update_display 
3eb8			 
3eb8					NEXTW 
3eb8 c3 63 1f			jp macro_next 
3ebb				endm 
# End of macro NEXTW
3ebb			 
3ebb			 
3ebb			 
3ebb			;		; get dir 
3ebb			; 
3ebb			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ebb			; 
3ebb			;		push hl 
3ebb			; 
3ebb			;		; destroy value TOS 
3ebb			; 
3ebb			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ebb			; 
3ebb			;		; get count 
3ebb			; 
3ebb			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ebb			; 
3ebb			;		push hl 
3ebb			; 
3ebb			;		; destroy value TOS 
3ebb			; 
3ebb			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ebb			; 
3ebb			;		; one value on hl get other one back 
3ebb			; 
3ebb			;		pop bc    ; count 
3ebb			; 
3ebb			;		pop de   ; dir 
3ebb			; 
3ebb			; 
3ebb			;		ld b, c 
3ebb			; 
3ebb			;.scrolldir:     push bc 
3ebb			;		push de 
3ebb			; 
3ebb			;		ld a, 0 
3ebb			;		cp e 
3ebb			;		jr z, .scrollup  
3ebb			;		call scroll_down 
3ebb			;		jr .scrollnext 
3ebb			;.scrollup:	call scroll_up 
3ebb			; 
3ebb			;		 
3ebb			;.scrollnext: 
3ebb			;		pop de 
3ebb			;		pop bc 
3ebb			;		djnz .scrolldir 
3ebb			; 
3ebb			; 
3ebb			; 
3ebb			; 
3ebb			; 
3ebb			;		NEXTW 
3ebb			 
3ebb			.SCROLLD: 
3ebb				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ebb 53				db WORD_SYS_CORE+63             
3ebc e9 3e			dw .ATQ            
3ebe 08				db 7 + 1 
3ebf .. 00			db "SCROLLD",0              
3ec7				endm 
# End of macro CWHEAD
3ec7			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ec7					if DEBUG_FORTH_WORDS_KEY 
3ec7						DMARK "SCD" 
3ec7 f5				push af  
3ec8 3a dc 3e			ld a, (.dmark)  
3ecb 32 bd fb			ld (debug_mark),a  
3ece 3a dd 3e			ld a, (.dmark+1)  
3ed1 32 be fb			ld (debug_mark+1),a  
3ed4 3a de 3e			ld a, (.dmark+2)  
3ed7 32 bf fb			ld (debug_mark+2),a  
3eda 18 03			jr .pastdmark  
3edc ..			.dmark: db "SCD"  
3edf f1			.pastdmark: pop af  
3ee0			endm  
# End of macro DMARK
3ee0						CALLMONITOR 
3ee0 cd 6a 16			call break_point_state  
3ee3				endm  
# End of macro CALLMONITOR
3ee3					endif 
3ee3			 
3ee3 cd b8 0a			call scroll_down 
3ee6			;	call update_display 
3ee6			 
3ee6					NEXTW 
3ee6 c3 63 1f			jp macro_next 
3ee9				endm 
# End of macro NEXTW
3ee9			 
3ee9			 
3ee9			.ATQ: 
3ee9				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ee9 62				db WORD_SYS_CORE+78             
3eea 47 3f			dw .AUTODSP            
3eec 04				db 3 + 1 
3eed .. 00			db "AT@",0              
3ef1				endm 
# End of macro CWHEAD
3ef1			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ef1					if DEBUG_FORTH_WORDS_KEY 
3ef1						DMARK "ATA" 
3ef1 f5				push af  
3ef2 3a 06 3f			ld a, (.dmark)  
3ef5 32 bd fb			ld (debug_mark),a  
3ef8 3a 07 3f			ld a, (.dmark+1)  
3efb 32 be fb			ld (debug_mark+1),a  
3efe 3a 08 3f			ld a, (.dmark+2)  
3f01 32 bf fb			ld (debug_mark+2),a  
3f04 18 03			jr .pastdmark  
3f06 ..			.dmark: db "ATA"  
3f09 f1			.pastdmark: pop af  
3f0a			endm  
# End of macro DMARK
3f0a						CALLMONITOR 
3f0a cd 6a 16			call break_point_state  
3f0d				endm  
# End of macro CALLMONITOR
3f0d					endif 
3f0d			 
3f0d			 
3f0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f0d cd f1 1d			call macro_dsp_valuehl 
3f10				endm 
# End of macro FORTH_DSP_VALUEHL
3f10			 
3f10					; TODO save cursor row 
3f10 7d					ld a,l 
3f11 fe 02				cp 2 
3f13 20 04				jr nz, .crow3aq 
3f15 3e 14				ld a, display_row_2 
3f17 18 12				jr .ccol1aq 
3f19 fe 03		.crow3aq:		cp 3 
3f1b 20 04				jr nz, .crow4aq 
3f1d 3e 28				ld a, display_row_3 
3f1f 18 0a				jr .ccol1aq 
3f21 fe 04		.crow4aq:		cp 4 
3f23 20 04				jr nz, .crow1aq 
3f25 3e 3c				ld a, display_row_4 
3f27 18 02				jr .ccol1aq 
3f29 3e 00		.crow1aq:		ld a,display_row_1 
3f2b f5			.ccol1aq:		push af			; got row offset 
3f2c 6f					ld l,a 
3f2d 26 00				ld h,0 
3f2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f2f cd a9 1e			call macro_forth_dsp_pop 
3f32				endm 
# End of macro FORTH_DSP_POP
3f32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f32 cd f1 1d			call macro_dsp_valuehl 
3f35				endm 
# End of macro FORTH_DSP_VALUEHL
3f35					; TODO save cursor col 
3f35 f1					pop af 
3f36 85					add l		; add col offset 
3f37			 
3f37					; add current frame buffer address 
3f37 2a 5e fa				ld hl, (display_fb_active) 
3f3a cd 06 0d				call addatohl 
3f3d			 
3f3d			 
3f3d			 
3f3d			 
3f3d					; get char frame buffer location offset in hl 
3f3d			 
3f3d 7e					ld a,(hl) 
3f3e 26 00				ld h, 0 
3f40 6f					ld l, a 
3f41			 
3f41 cd fa 1b				call forth_push_numhl 
3f44			 
3f44			 
3f44					NEXTW 
3f44 c3 63 1f			jp macro_next 
3f47				endm 
# End of macro NEXTW
3f47			 
3f47			.AUTODSP: 
3f47				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f47 63				db WORD_SYS_CORE+79             
3f48 5d 3f			dw .MENU            
3f4a 05				db 4 + 1 
3f4b .. 00			db "ADSP",0              
3f50				endm 
# End of macro CWHEAD
3f50			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f50			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f50			 
3f50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f50 cd f1 1d			call macro_dsp_valuehl 
3f53				endm 
# End of macro FORTH_DSP_VALUEHL
3f53			 
3f53			;		push hl 
3f53			 
3f53					; destroy value TOS 
3f53			 
3f53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f53 cd a9 1e			call macro_forth_dsp_pop 
3f56				endm 
# End of macro FORTH_DSP_POP
3f56			 
3f56			;		pop hl 
3f56			 
3f56 7d					ld a,l 
3f57 32 aa f9				ld (cli_autodisplay), a 
3f5a				       NEXTW 
3f5a c3 63 1f			jp macro_next 
3f5d				endm 
# End of macro NEXTW
3f5d			 
3f5d			.MENU: 
3f5d				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f5d 70				db WORD_SYS_CORE+92             
3f5e 06 40			dw .ENDDISPLAY            
3f60 05				db 4 + 1 
3f61 .. 00			db "MENU",0              
3f66				endm 
# End of macro CWHEAD
3f66			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f66			 
3f66			;		; get number of items on the stack 
3f66			; 
3f66				 
3f66					FORTH_DSP_VALUEHL 
3f66 cd f1 1d			call macro_dsp_valuehl 
3f69				endm 
# End of macro FORTH_DSP_VALUEHL
3f69				 
3f69					if DEBUG_FORTH_WORDS_KEY 
3f69						DMARK "MNU" 
3f69 f5				push af  
3f6a 3a 7e 3f			ld a, (.dmark)  
3f6d 32 bd fb			ld (debug_mark),a  
3f70 3a 7f 3f			ld a, (.dmark+1)  
3f73 32 be fb			ld (debug_mark+1),a  
3f76 3a 80 3f			ld a, (.dmark+2)  
3f79 32 bf fb			ld (debug_mark+2),a  
3f7c 18 03			jr .pastdmark  
3f7e ..			.dmark: db "MNU"  
3f81 f1			.pastdmark: pop af  
3f82			endm  
# End of macro DMARK
3f82						CALLMONITOR 
3f82 cd 6a 16			call break_point_state  
3f85				endm  
# End of macro CALLMONITOR
3f85					endif 
3f85			 
3f85 45					ld b, l	 
3f86 05					dec b 
3f87			 
3f87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f87 cd a9 1e			call macro_forth_dsp_pop 
3f8a				endm 
# End of macro FORTH_DSP_POP
3f8a			 
3f8a			 
3f8a					; go directly through the stack to pluck out the string pointers and build an array 
3f8a			 
3f8a			;		FORTH_DSP 
3f8a			 
3f8a					; hl contains top most stack item 
3f8a				 
3f8a 11 a3 ef				ld de, scratch 
3f8d			 
3f8d			.mbuild: 
3f8d			 
3f8d					FORTH_DSP_VALUEHL 
3f8d cd f1 1d			call macro_dsp_valuehl 
3f90				endm 
# End of macro FORTH_DSP_VALUEHL
3f90			 
3f90					if DEBUG_FORTH_WORDS 
3f90						DMARK "MN3" 
3f90 f5				push af  
3f91 3a a5 3f			ld a, (.dmark)  
3f94 32 bd fb			ld (debug_mark),a  
3f97 3a a6 3f			ld a, (.dmark+1)  
3f9a 32 be fb			ld (debug_mark+1),a  
3f9d 3a a7 3f			ld a, (.dmark+2)  
3fa0 32 bf fb			ld (debug_mark+2),a  
3fa3 18 03			jr .pastdmark  
3fa5 ..			.dmark: db "MN3"  
3fa8 f1			.pastdmark: pop af  
3fa9			endm  
# End of macro DMARK
3fa9						CALLMONITOR 
3fa9 cd 6a 16			call break_point_state  
3fac				endm  
# End of macro CALLMONITOR
3fac					endif 
3fac eb					ex de, hl 
3fad 73					ld (hl), e 
3fae 23					inc hl 
3faf 72					ld (hl), d 
3fb0 23					inc hl 
3fb1 eb					ex de, hl 
3fb2			 
3fb2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fb2 cd a9 1e			call macro_forth_dsp_pop 
3fb5				endm 
# End of macro FORTH_DSP_POP
3fb5			 
3fb5 10 d6				djnz .mbuild 
3fb7			 
3fb7					; done add term 
3fb7			 
3fb7 eb					ex de, hl 
3fb8 36 00				ld (hl), 0 
3fba 23					inc hl 
3fbb 36 00				ld (hl), 0 
3fbd			 
3fbd				 
3fbd					 
3fbd 21 a3 ef				ld hl, scratch 
3fc0			 
3fc0					if DEBUG_FORTH_WORDS 
3fc0						DMARK "MNx" 
3fc0 f5				push af  
3fc1 3a d5 3f			ld a, (.dmark)  
3fc4 32 bd fb			ld (debug_mark),a  
3fc7 3a d6 3f			ld a, (.dmark+1)  
3fca 32 be fb			ld (debug_mark+1),a  
3fcd 3a d7 3f			ld a, (.dmark+2)  
3fd0 32 bf fb			ld (debug_mark+2),a  
3fd3 18 03			jr .pastdmark  
3fd5 ..			.dmark: db "MNx"  
3fd8 f1			.pastdmark: pop af  
3fd9			endm  
# End of macro DMARK
3fd9						CALLMONITOR 
3fd9 cd 6a 16			call break_point_state  
3fdc				endm  
# End of macro CALLMONITOR
3fdc					endif 
3fdc			 
3fdc			 
3fdc			 
3fdc 3e 00				ld a, 0 
3fde cd 03 0b				call menu 
3fe1			 
3fe1			 
3fe1 6f					ld l, a 
3fe2 26 00				ld h, 0 
3fe4			 
3fe4					if DEBUG_FORTH_WORDS 
3fe4						DMARK "MNr" 
3fe4 f5				push af  
3fe5 3a f9 3f			ld a, (.dmark)  
3fe8 32 bd fb			ld (debug_mark),a  
3feb 3a fa 3f			ld a, (.dmark+1)  
3fee 32 be fb			ld (debug_mark+1),a  
3ff1 3a fb 3f			ld a, (.dmark+2)  
3ff4 32 bf fb			ld (debug_mark+2),a  
3ff7 18 03			jr .pastdmark  
3ff9 ..			.dmark: db "MNr"  
3ffc f1			.pastdmark: pop af  
3ffd			endm  
# End of macro DMARK
3ffd						CALLMONITOR 
3ffd cd 6a 16			call break_point_state  
4000				endm  
# End of macro CALLMONITOR
4000					endif 
4000			 
4000 cd fa 1b				call forth_push_numhl 
4003			 
4003			 
4003			 
4003			 
4003				       NEXTW 
4003 c3 63 1f			jp macro_next 
4006				endm 
# End of macro NEXTW
4006			 
4006			 
4006			.ENDDISPLAY: 
4006			 
4006			; eof 
# End of file forth_words_display.asm
4006			include "forth_words_str.asm" 
4006			 
4006			; | ## String Words 
4006			 
4006			.PTR:   
4006			 
4006				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4006 48				db WORD_SYS_CORE+52             
4007 33 40			dw .STYPE            
4009 04				db 3 + 1 
400a .. 00			db "PTR",0              
400e				endm 
# End of macro CWHEAD
400e			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
400e			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
400e			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
400e			 
400e					if DEBUG_FORTH_WORDS_KEY 
400e						DMARK "PTR" 
400e f5				push af  
400f 3a 23 40			ld a, (.dmark)  
4012 32 bd fb			ld (debug_mark),a  
4015 3a 24 40			ld a, (.dmark+1)  
4018 32 be fb			ld (debug_mark+1),a  
401b 3a 25 40			ld a, (.dmark+2)  
401e 32 bf fb			ld (debug_mark+2),a  
4021 18 03			jr .pastdmark  
4023 ..			.dmark: db "PTR"  
4026 f1			.pastdmark: pop af  
4027			endm  
# End of macro DMARK
4027						CALLMONITOR 
4027 cd 6a 16			call break_point_state  
402a				endm  
# End of macro CALLMONITOR
402a					endif 
402a					FORTH_DSP_VALUEHL 
402a cd f1 1d			call macro_dsp_valuehl 
402d				endm 
# End of macro FORTH_DSP_VALUEHL
402d cd fa 1b				call forth_push_numhl 
4030			 
4030			 
4030					NEXTW 
4030 c3 63 1f			jp macro_next 
4033				endm 
# End of macro NEXTW
4033			.STYPE: 
4033				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4033 48				db WORD_SYS_CORE+52             
4034 82 40			dw .UPPER            
4036 06				db 5 + 1 
4037 .. 00			db "STYPE",0              
403d				endm 
# End of macro CWHEAD
403d			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
403d					if DEBUG_FORTH_WORDS_KEY 
403d						DMARK "STY" 
403d f5				push af  
403e 3a 52 40			ld a, (.dmark)  
4041 32 bd fb			ld (debug_mark),a  
4044 3a 53 40			ld a, (.dmark+1)  
4047 32 be fb			ld (debug_mark+1),a  
404a 3a 54 40			ld a, (.dmark+2)  
404d 32 bf fb			ld (debug_mark+2),a  
4050 18 03			jr .pastdmark  
4052 ..			.dmark: db "STY"  
4055 f1			.pastdmark: pop af  
4056			endm  
# End of macro DMARK
4056						CALLMONITOR 
4056 cd 6a 16			call break_point_state  
4059				endm  
# End of macro CALLMONITOR
4059					endif 
4059					FORTH_DSP 
4059 cd b7 1d			call macro_forth_dsp 
405c				endm 
# End of macro FORTH_DSP
405c					;v5 FORTH_DSP_VALUE 
405c			 
405c 7e					ld a, (hl) 
405d			 
405d f5					push af 
405e			 
405e			; Dont destroy TOS		FORTH_DSP_POP 
405e			 
405e f1					pop af 
405f			 
405f fe 01				cp DS_TYPE_STR 
4061 28 09				jr z, .typestr 
4063			 
4063 fe 02				cp DS_TYPE_INUM 
4065 28 0a				jr z, .typeinum 
4067			 
4067 21 80 40				ld hl, .tna 
406a 18 0a				jr .tpush 
406c			 
406c 21 7c 40		.typestr:	ld hl, .tstr 
406f 18 05				jr .tpush 
4071 21 7e 40		.typeinum:	ld hl, .tinum 
4074 18 00				jr .tpush 
4076			 
4076			.tpush: 
4076			 
4076 cd 68 1c				call forth_push_str 
4079			 
4079					NEXTW 
4079 c3 63 1f			jp macro_next 
407c				endm 
# End of macro NEXTW
407c .. 00		.tstr:	db "s",0 
407e .. 00		.tinum:  db "i",0 
4080 .. 00		.tna:   db "?", 0 
4082			 
4082			 
4082			.UPPER: 
4082				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4082 48				db WORD_SYS_CORE+52             
4083 bd 40			dw .LOWER            
4085 06				db 5 + 1 
4086 .. 00			db "UPPER",0              
408c				endm 
# End of macro CWHEAD
408c			; | UPPER ( s -- s ) Upper case string s  | DONE 
408c					if DEBUG_FORTH_WORDS_KEY 
408c						DMARK "UPR" 
408c f5				push af  
408d 3a a1 40			ld a, (.dmark)  
4090 32 bd fb			ld (debug_mark),a  
4093 3a a2 40			ld a, (.dmark+1)  
4096 32 be fb			ld (debug_mark+1),a  
4099 3a a3 40			ld a, (.dmark+2)  
409c 32 bf fb			ld (debug_mark+2),a  
409f 18 03			jr .pastdmark  
40a1 ..			.dmark: db "UPR"  
40a4 f1			.pastdmark: pop af  
40a5			endm  
# End of macro DMARK
40a5						CALLMONITOR 
40a5 cd 6a 16			call break_point_state  
40a8				endm  
# End of macro CALLMONITOR
40a8					endif 
40a8			 
40a8					FORTH_DSP 
40a8 cd b7 1d			call macro_forth_dsp 
40ab				endm 
# End of macro FORTH_DSP
40ab					 
40ab			; TODO check is string type 
40ab			 
40ab					FORTH_DSP_VALUEHL 
40ab cd f1 1d			call macro_dsp_valuehl 
40ae				endm 
# End of macro FORTH_DSP_VALUEHL
40ae			; get pointer to string in hl 
40ae			 
40ae 7e			.toup:		ld a, (hl) 
40af fe 00				cp 0 
40b1 28 07				jr z, .toupdone 
40b3			 
40b3 cd 73 10				call to_upper 
40b6			 
40b6 77					ld (hl), a 
40b7 23					inc hl 
40b8 18 f4				jr .toup 
40ba			 
40ba					 
40ba			 
40ba			 
40ba			; for each char convert to upper 
40ba					 
40ba			.toupdone: 
40ba			 
40ba			 
40ba					NEXTW 
40ba c3 63 1f			jp macro_next 
40bd				endm 
# End of macro NEXTW
40bd			.LOWER: 
40bd				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
40bd 48				db WORD_SYS_CORE+52             
40be f8 40			dw .TCASE            
40c0 06				db 5 + 1 
40c1 .. 00			db "LOWER",0              
40c7				endm 
# End of macro CWHEAD
40c7			; | LOWER ( s -- s ) Lower case string s  | DONE 
40c7					if DEBUG_FORTH_WORDS_KEY 
40c7						DMARK "LWR" 
40c7 f5				push af  
40c8 3a dc 40			ld a, (.dmark)  
40cb 32 bd fb			ld (debug_mark),a  
40ce 3a dd 40			ld a, (.dmark+1)  
40d1 32 be fb			ld (debug_mark+1),a  
40d4 3a de 40			ld a, (.dmark+2)  
40d7 32 bf fb			ld (debug_mark+2),a  
40da 18 03			jr .pastdmark  
40dc ..			.dmark: db "LWR"  
40df f1			.pastdmark: pop af  
40e0			endm  
# End of macro DMARK
40e0						CALLMONITOR 
40e0 cd 6a 16			call break_point_state  
40e3				endm  
# End of macro CALLMONITOR
40e3					endif 
40e3			 
40e3					FORTH_DSP 
40e3 cd b7 1d			call macro_forth_dsp 
40e6				endm 
# End of macro FORTH_DSP
40e6					 
40e6			; TODO check is string type 
40e6			 
40e6					FORTH_DSP_VALUEHL 
40e6 cd f1 1d			call macro_dsp_valuehl 
40e9				endm 
# End of macro FORTH_DSP_VALUEHL
40e9			; get pointer to string in hl 
40e9			 
40e9 7e			.tolow:		ld a, (hl) 
40ea fe 00				cp 0 
40ec 28 07				jr z, .tolowdone 
40ee			 
40ee cd 7c 10				call to_lower 
40f1			 
40f1 77					ld (hl), a 
40f2 23					inc hl 
40f3 18 f4				jr .tolow 
40f5			 
40f5					 
40f5			 
40f5			 
40f5			; for each char convert to low 
40f5					 
40f5			.tolowdone: 
40f5					NEXTW 
40f5 c3 63 1f			jp macro_next 
40f8				endm 
# End of macro NEXTW
40f8			.TCASE: 
40f8				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40f8 48				db WORD_SYS_CORE+52             
40f9 2e 42			dw .SUBSTR            
40fb 06				db 5 + 1 
40fc .. 00			db "TCASE",0              
4102				endm 
# End of macro CWHEAD
4102			; | TCASE ( s -- s ) Title case string s  | DONE 
4102					if DEBUG_FORTH_WORDS_KEY 
4102						DMARK "TCS" 
4102 f5				push af  
4103 3a 17 41			ld a, (.dmark)  
4106 32 bd fb			ld (debug_mark),a  
4109 3a 18 41			ld a, (.dmark+1)  
410c 32 be fb			ld (debug_mark+1),a  
410f 3a 19 41			ld a, (.dmark+2)  
4112 32 bf fb			ld (debug_mark+2),a  
4115 18 03			jr .pastdmark  
4117 ..			.dmark: db "TCS"  
411a f1			.pastdmark: pop af  
411b			endm  
# End of macro DMARK
411b						CALLMONITOR 
411b cd 6a 16			call break_point_state  
411e				endm  
# End of macro CALLMONITOR
411e					endif 
411e			 
411e					FORTH_DSP 
411e cd b7 1d			call macro_forth_dsp 
4121				endm 
# End of macro FORTH_DSP
4121					 
4121			; TODO check is string type 
4121			 
4121					FORTH_DSP_VALUEHL 
4121 cd f1 1d			call macro_dsp_valuehl 
4124				endm 
# End of macro FORTH_DSP_VALUEHL
4124			; get pointer to string in hl 
4124			 
4124					if DEBUG_FORTH_WORDS 
4124						DMARK "TC1" 
4124 f5				push af  
4125 3a 39 41			ld a, (.dmark)  
4128 32 bd fb			ld (debug_mark),a  
412b 3a 3a 41			ld a, (.dmark+1)  
412e 32 be fb			ld (debug_mark+1),a  
4131 3a 3b 41			ld a, (.dmark+2)  
4134 32 bf fb			ld (debug_mark+2),a  
4137 18 03			jr .pastdmark  
4139 ..			.dmark: db "TC1"  
413c f1			.pastdmark: pop af  
413d			endm  
# End of macro DMARK
413d						CALLMONITOR 
413d cd 6a 16			call break_point_state  
4140				endm  
# End of macro CALLMONITOR
4140					endif 
4140			 
4140					; first time in turn to upper case first char 
4140			 
4140 7e					ld a, (hl) 
4141 c3 cb 41				jp .totsiptou 
4144			 
4144			 
4144 7e			.tot:		ld a, (hl) 
4145 fe 00				cp 0 
4147 ca 0f 42				jp z, .totdone 
414a			 
414a					if DEBUG_FORTH_WORDS 
414a						DMARK "TC2" 
414a f5				push af  
414b 3a 5f 41			ld a, (.dmark)  
414e 32 bd fb			ld (debug_mark),a  
4151 3a 60 41			ld a, (.dmark+1)  
4154 32 be fb			ld (debug_mark+1),a  
4157 3a 61 41			ld a, (.dmark+2)  
415a 32 bf fb			ld (debug_mark+2),a  
415d 18 03			jr .pastdmark  
415f ..			.dmark: db "TC2"  
4162 f1			.pastdmark: pop af  
4163			endm  
# End of macro DMARK
4163						CALLMONITOR 
4163 cd 6a 16			call break_point_state  
4166				endm  
# End of macro CALLMONITOR
4166					endif 
4166					; check to see if current char is a space 
4166			 
4166 fe 20				cp ' ' 
4168 28 21				jr z, .totsp 
416a cd 7c 10				call to_lower 
416d					if DEBUG_FORTH_WORDS 
416d						DMARK "TC3" 
416d f5				push af  
416e 3a 82 41			ld a, (.dmark)  
4171 32 bd fb			ld (debug_mark),a  
4174 3a 83 41			ld a, (.dmark+1)  
4177 32 be fb			ld (debug_mark+1),a  
417a 3a 84 41			ld a, (.dmark+2)  
417d 32 bf fb			ld (debug_mark+2),a  
4180 18 03			jr .pastdmark  
4182 ..			.dmark: db "TC3"  
4185 f1			.pastdmark: pop af  
4186			endm  
# End of macro DMARK
4186						CALLMONITOR 
4186 cd 6a 16			call break_point_state  
4189				endm  
# End of macro CALLMONITOR
4189					endif 
4189 18 63				jr .totnxt 
418b			 
418b			.totsp:         ; on a space, find next char which should be upper 
418b			 
418b					if DEBUG_FORTH_WORDS 
418b						DMARK "TC4" 
418b f5				push af  
418c 3a a0 41			ld a, (.dmark)  
418f 32 bd fb			ld (debug_mark),a  
4192 3a a1 41			ld a, (.dmark+1)  
4195 32 be fb			ld (debug_mark+1),a  
4198 3a a2 41			ld a, (.dmark+2)  
419b 32 bf fb			ld (debug_mark+2),a  
419e 18 03			jr .pastdmark  
41a0 ..			.dmark: db "TC4"  
41a3 f1			.pastdmark: pop af  
41a4			endm  
# End of macro DMARK
41a4						CALLMONITOR 
41a4 cd 6a 16			call break_point_state  
41a7				endm  
# End of macro CALLMONITOR
41a7					endif 
41a7					;; 
41a7			 
41a7 fe 20				cp ' ' 
41a9 20 20				jr nz, .totsiptou 
41ab 23					inc hl 
41ac 7e					ld a, (hl) 
41ad					if DEBUG_FORTH_WORDS 
41ad						DMARK "TC5" 
41ad f5				push af  
41ae 3a c2 41			ld a, (.dmark)  
41b1 32 bd fb			ld (debug_mark),a  
41b4 3a c3 41			ld a, (.dmark+1)  
41b7 32 be fb			ld (debug_mark+1),a  
41ba 3a c4 41			ld a, (.dmark+2)  
41bd 32 bf fb			ld (debug_mark+2),a  
41c0 18 03			jr .pastdmark  
41c2 ..			.dmark: db "TC5"  
41c5 f1			.pastdmark: pop af  
41c6			endm  
# End of macro DMARK
41c6						CALLMONITOR 
41c6 cd 6a 16			call break_point_state  
41c9				endm  
# End of macro CALLMONITOR
41c9					endif 
41c9 18 c0				jr .totsp 
41cb fe 00		.totsiptou:    cp 0 
41cd 28 40				jr z, .totdone 
41cf					; not space and not zero term so upper case it 
41cf cd 73 10				call to_upper 
41d2			 
41d2					if DEBUG_FORTH_WORDS 
41d2						DMARK "TC6" 
41d2 f5				push af  
41d3 3a e7 41			ld a, (.dmark)  
41d6 32 bd fb			ld (debug_mark),a  
41d9 3a e8 41			ld a, (.dmark+1)  
41dc 32 be fb			ld (debug_mark+1),a  
41df 3a e9 41			ld a, (.dmark+2)  
41e2 32 bf fb			ld (debug_mark+2),a  
41e5 18 03			jr .pastdmark  
41e7 ..			.dmark: db "TC6"  
41ea f1			.pastdmark: pop af  
41eb			endm  
# End of macro DMARK
41eb						CALLMONITOR 
41eb cd 6a 16			call break_point_state  
41ee				endm  
# End of macro CALLMONITOR
41ee					endif 
41ee			 
41ee			 
41ee			.totnxt: 
41ee			 
41ee 77					ld (hl), a 
41ef 23					inc hl 
41f0					if DEBUG_FORTH_WORDS 
41f0						DMARK "TC7" 
41f0 f5				push af  
41f1 3a 05 42			ld a, (.dmark)  
41f4 32 bd fb			ld (debug_mark),a  
41f7 3a 06 42			ld a, (.dmark+1)  
41fa 32 be fb			ld (debug_mark+1),a  
41fd 3a 07 42			ld a, (.dmark+2)  
4200 32 bf fb			ld (debug_mark+2),a  
4203 18 03			jr .pastdmark  
4205 ..			.dmark: db "TC7"  
4208 f1			.pastdmark: pop af  
4209			endm  
# End of macro DMARK
4209						CALLMONITOR 
4209 cd 6a 16			call break_point_state  
420c				endm  
# End of macro CALLMONITOR
420c					endif 
420c c3 44 41				jp .tot 
420f			 
420f					 
420f			 
420f			 
420f			; for each char convert to low 
420f					 
420f			.totdone: 
420f					if DEBUG_FORTH_WORDS 
420f						DMARK "TCd" 
420f f5				push af  
4210 3a 24 42			ld a, (.dmark)  
4213 32 bd fb			ld (debug_mark),a  
4216 3a 25 42			ld a, (.dmark+1)  
4219 32 be fb			ld (debug_mark+1),a  
421c 3a 26 42			ld a, (.dmark+2)  
421f 32 bf fb			ld (debug_mark+2),a  
4222 18 03			jr .pastdmark  
4224 ..			.dmark: db "TCd"  
4227 f1			.pastdmark: pop af  
4228			endm  
# End of macro DMARK
4228						CALLMONITOR 
4228 cd 6a 16			call break_point_state  
422b				endm  
# End of macro CALLMONITOR
422b					endif 
422b					NEXTW 
422b c3 63 1f			jp macro_next 
422e				endm 
# End of macro NEXTW
422e			 
422e			.SUBSTR: 
422e				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
422e 48				db WORD_SYS_CORE+52             
422f 8c 42			dw .LEFT            
4231 07				db 6 + 1 
4232 .. 00			db "SUBSTR",0              
4239				endm 
# End of macro CWHEAD
4239			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4239			 
4239					if DEBUG_FORTH_WORDS_KEY 
4239						DMARK "SST" 
4239 f5				push af  
423a 3a 4e 42			ld a, (.dmark)  
423d 32 bd fb			ld (debug_mark),a  
4240 3a 4f 42			ld a, (.dmark+1)  
4243 32 be fb			ld (debug_mark+1),a  
4246 3a 50 42			ld a, (.dmark+2)  
4249 32 bf fb			ld (debug_mark+2),a  
424c 18 03			jr .pastdmark  
424e ..			.dmark: db "SST"  
4251 f1			.pastdmark: pop af  
4252			endm  
# End of macro DMARK
4252						CALLMONITOR 
4252 cd 6a 16			call break_point_state  
4255				endm  
# End of macro CALLMONITOR
4255					endif 
4255			; TODO check string type 
4255					FORTH_DSP_VALUEHL 
4255 cd f1 1d			call macro_dsp_valuehl 
4258				endm 
# End of macro FORTH_DSP_VALUEHL
4258			 
4258 e5					push hl      ; string length 
4259			 
4259					FORTH_DSP_POP 
4259 cd a9 1e			call macro_forth_dsp_pop 
425c				endm 
# End of macro FORTH_DSP_POP
425c			 
425c					FORTH_DSP_VALUEHL 
425c cd f1 1d			call macro_dsp_valuehl 
425f				endm 
# End of macro FORTH_DSP_VALUEHL
425f			 
425f e5					push hl     ; start char 
4260			 
4260					FORTH_DSP_POP 
4260 cd a9 1e			call macro_forth_dsp_pop 
4263				endm 
# End of macro FORTH_DSP_POP
4263			 
4263			 
4263					FORTH_DSP_VALUE 
4263 cd da 1d			call macro_forth_dsp_value 
4266				endm 
# End of macro FORTH_DSP_VALUE
4266			 
4266 d1					pop de    ; get start post offset 
4267			 
4267 19					add hl, de    ; starting offset 
4268			 
4268 c1					pop bc 
4269 c5					push bc      ; grab size of string 
426a			 
426a e5					push hl    ; save string start  
426b			 
426b 26 00				ld h, 0 
426d 69					ld l, c 
426e 23					inc hl 
426f 23					inc hl 
4270			 
4270 cd cd 11				call malloc 
4273				if DEBUG_FORTH_MALLOC_GUARD 
4273 cc f6 51				call z,malloc_error 
4276				endif 
4276			 
4276 eb					ex de, hl      ; save malloc area for string copy 
4277 e1					pop hl    ; get back source 
4278 c1					pop bc    ; get length of string back 
4279			 
4279 d5					push de    ; save malloc area for after we push 
427a ed b0				ldir     ; copy substr 
427c			 
427c			 
427c eb					ex de, hl 
427d 3e 00				ld a, 0 
427f 77					ld (hl), a   ; term substr 
4280			 
4280					 
4280 e1					pop hl    ; get malloc so we can push it 
4281 e5					push hl   ; save so we can free it afterwards 
4282			 
4282 cd 68 1c				call forth_push_str 
4285			 
4285 e1					pop hl 
4286 cd 97 12				call free 
4289			 
4289					 
4289					 
4289			 
4289			 
4289					NEXTW 
4289 c3 63 1f			jp macro_next 
428c				endm 
# End of macro NEXTW
428c			 
428c			.LEFT: 
428c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
428c 48				db WORD_SYS_CORE+52             
428d b4 42			dw .RIGHT            
428f 05				db 4 + 1 
4290 .. 00			db "LEFT",0              
4295				endm 
# End of macro CWHEAD
4295			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4295					if DEBUG_FORTH_WORDS_KEY 
4295						DMARK "LEF" 
4295 f5				push af  
4296 3a aa 42			ld a, (.dmark)  
4299 32 bd fb			ld (debug_mark),a  
429c 3a ab 42			ld a, (.dmark+1)  
429f 32 be fb			ld (debug_mark+1),a  
42a2 3a ac 42			ld a, (.dmark+2)  
42a5 32 bf fb			ld (debug_mark+2),a  
42a8 18 03			jr .pastdmark  
42aa ..			.dmark: db "LEF"  
42ad f1			.pastdmark: pop af  
42ae			endm  
# End of macro DMARK
42ae						CALLMONITOR 
42ae cd 6a 16			call break_point_state  
42b1				endm  
# End of macro CALLMONITOR
42b1					endif 
42b1			 
42b1					NEXTW 
42b1 c3 63 1f			jp macro_next 
42b4				endm 
# End of macro NEXTW
42b4			.RIGHT: 
42b4				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
42b4 48				db WORD_SYS_CORE+52             
42b5 dd 42			dw .STR2NUM            
42b7 06				db 5 + 1 
42b8 .. 00			db "RIGHT",0              
42be				endm 
# End of macro CWHEAD
42be			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
42be					if DEBUG_FORTH_WORDS_KEY 
42be						DMARK "RIG" 
42be f5				push af  
42bf 3a d3 42			ld a, (.dmark)  
42c2 32 bd fb			ld (debug_mark),a  
42c5 3a d4 42			ld a, (.dmark+1)  
42c8 32 be fb			ld (debug_mark+1),a  
42cb 3a d5 42			ld a, (.dmark+2)  
42ce 32 bf fb			ld (debug_mark+2),a  
42d1 18 03			jr .pastdmark  
42d3 ..			.dmark: db "RIG"  
42d6 f1			.pastdmark: pop af  
42d7			endm  
# End of macro DMARK
42d7						CALLMONITOR 
42d7 cd 6a 16			call break_point_state  
42da				endm  
# End of macro CALLMONITOR
42da					endif 
42da			 
42da					NEXTW 
42da c3 63 1f			jp macro_next 
42dd				endm 
# End of macro NEXTW
42dd			 
42dd			 
42dd			.STR2NUM: 
42dd				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
42dd 48				db WORD_SYS_CORE+52             
42de 69 43			dw .NUM2STR            
42e0 08				db 7 + 1 
42e1 .. 00			db "STR2NUM",0              
42e9				endm 
# End of macro CWHEAD
42e9			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42e9			 
42e9			 
42e9			; TODO STR type check to do 
42e9					if DEBUG_FORTH_WORDS_KEY 
42e9						DMARK "S2N" 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 bd fb			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 be fb			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 bf fb			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "S2N"  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302						CALLMONITOR 
4302 cd 6a 16			call break_point_state  
4305				endm  
# End of macro CALLMONITOR
4305					endif 
4305			 
4305					;FORTH_DSP 
4305					FORTH_DSP_VALUE 
4305 cd da 1d			call macro_forth_dsp_value 
4308				endm 
# End of macro FORTH_DSP_VALUE
4308					;inc hl 
4308			 
4308 eb					ex de, hl 
4309					if DEBUG_FORTH_WORDS 
4309						DMARK "S2a" 
4309 f5				push af  
430a 3a 1e 43			ld a, (.dmark)  
430d 32 bd fb			ld (debug_mark),a  
4310 3a 1f 43			ld a, (.dmark+1)  
4313 32 be fb			ld (debug_mark+1),a  
4316 3a 20 43			ld a, (.dmark+2)  
4319 32 bf fb			ld (debug_mark+2),a  
431c 18 03			jr .pastdmark  
431e ..			.dmark: db "S2a"  
4321 f1			.pastdmark: pop af  
4322			endm  
# End of macro DMARK
4322						CALLMONITOR 
4322 cd 6a 16			call break_point_state  
4325				endm  
# End of macro CALLMONITOR
4325					endif 
4325 cd fb 10				call string_to_uint16 
4328			 
4328					if DEBUG_FORTH_WORDS 
4328						DMARK "S2b" 
4328 f5				push af  
4329 3a 3d 43			ld a, (.dmark)  
432c 32 bd fb			ld (debug_mark),a  
432f 3a 3e 43			ld a, (.dmark+1)  
4332 32 be fb			ld (debug_mark+1),a  
4335 3a 3f 43			ld a, (.dmark+2)  
4338 32 bf fb			ld (debug_mark+2),a  
433b 18 03			jr .pastdmark  
433d ..			.dmark: db "S2b"  
4340 f1			.pastdmark: pop af  
4341			endm  
# End of macro DMARK
4341						CALLMONITOR 
4341 cd 6a 16			call break_point_state  
4344				endm  
# End of macro CALLMONITOR
4344					endif 
4344			;		push hl 
4344					FORTH_DSP_POP 
4344 cd a9 1e			call macro_forth_dsp_pop 
4347				endm 
# End of macro FORTH_DSP_POP
4347			;		pop hl 
4347					 
4347					if DEBUG_FORTH_WORDS 
4347						DMARK "S2b" 
4347 f5				push af  
4348 3a 5c 43			ld a, (.dmark)  
434b 32 bd fb			ld (debug_mark),a  
434e 3a 5d 43			ld a, (.dmark+1)  
4351 32 be fb			ld (debug_mark+1),a  
4354 3a 5e 43			ld a, (.dmark+2)  
4357 32 bf fb			ld (debug_mark+2),a  
435a 18 03			jr .pastdmark  
435c ..			.dmark: db "S2b"  
435f f1			.pastdmark: pop af  
4360			endm  
# End of macro DMARK
4360						CALLMONITOR 
4360 cd 6a 16			call break_point_state  
4363				endm  
# End of macro CALLMONITOR
4363					endif 
4363 cd fa 1b				call forth_push_numhl	 
4366			 
4366				 
4366				       NEXTW 
4366 c3 63 1f			jp macro_next 
4369				endm 
# End of macro NEXTW
4369			.NUM2STR: 
4369				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4369 48				db WORD_SYS_CORE+52             
436a 78 43			dw .CONCAT            
436c 08				db 7 + 1 
436d .. 00			db "NUM2STR",0              
4375				endm 
# End of macro CWHEAD
4375			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4375			 
4375			;		; malloc a string to target 
4375			;		ld hl, 10     ; TODO max string size should be fine 
4375			;		call malloc 
4375			;		push hl    ; save malloc location 
4375			; 
4375			; 
4375			;; TODO check int type 
4375			;		FORTH_DSP_VALUEHL 
4375			;		ld a, l 
4375			;		call DispAToASCII   
4375			;;TODO need to chage above call to dump into string 
4375			; 
4375			; 
4375			 
4375				       NEXTW 
4375 c3 63 1f			jp macro_next 
4378				endm 
# End of macro NEXTW
4378			 
4378			.CONCAT: 
4378				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4378 48				db WORD_SYS_CORE+52             
4379 2b 44			dw .FIND            
437b 07				db 6 + 1 
437c .. 00			db "CONCAT",0              
4383				endm 
# End of macro CWHEAD
4383			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4383			 
4383			; TODO check string type 
4383			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4383			 
4383					if DEBUG_FORTH_WORDS_KEY 
4383						DMARK "CON" 
4383 f5				push af  
4384 3a 98 43			ld a, (.dmark)  
4387 32 bd fb			ld (debug_mark),a  
438a 3a 99 43			ld a, (.dmark+1)  
438d 32 be fb			ld (debug_mark+1),a  
4390 3a 9a 43			ld a, (.dmark+2)  
4393 32 bf fb			ld (debug_mark+2),a  
4396 18 03			jr .pastdmark  
4398 ..			.dmark: db "CON"  
439b f1			.pastdmark: pop af  
439c			endm  
# End of macro DMARK
439c						CALLMONITOR 
439c cd 6a 16			call break_point_state  
439f				endm  
# End of macro CALLMONITOR
439f					endif 
439f			 
439f			 
439f					FORTH_DSP_VALUE 
439f cd da 1d			call macro_forth_dsp_value 
43a2				endm 
# End of macro FORTH_DSP_VALUE
43a2 e5					push hl   ; s2 
43a3			 
43a3					FORTH_DSP_POP 
43a3 cd a9 1e			call macro_forth_dsp_pop 
43a6				endm 
# End of macro FORTH_DSP_POP
43a6			 
43a6					FORTH_DSP_VALUE 
43a6 cd da 1d			call macro_forth_dsp_value 
43a9				endm 
# End of macro FORTH_DSP_VALUE
43a9			 
43a9 e5					push hl   ; s1 
43aa			 
43aa					FORTH_DSP_POP 
43aa cd a9 1e			call macro_forth_dsp_pop 
43ad				endm 
# End of macro FORTH_DSP_POP
43ad					 
43ad			 
43ad					; copy s1 
43ad			 
43ad				 
43ad					; save ptr 
43ad e1					pop hl  
43ae e5					push hl 
43af 3e 00				ld a, 0 
43b1 cd 6f 11				call strlent 
43b4					;inc hl    ; zer0 
43b4 06 00				ld b, 0 
43b6 4d					ld c, l 
43b7 e1					pop hl		 
43b8 11 a3 ef				ld de, scratch	 
43bb					if DEBUG_FORTH_WORDS 
43bb						DMARK "CO1" 
43bb f5				push af  
43bc 3a d0 43			ld a, (.dmark)  
43bf 32 bd fb			ld (debug_mark),a  
43c2 3a d1 43			ld a, (.dmark+1)  
43c5 32 be fb			ld (debug_mark+1),a  
43c8 3a d2 43			ld a, (.dmark+2)  
43cb 32 bf fb			ld (debug_mark+2),a  
43ce 18 03			jr .pastdmark  
43d0 ..			.dmark: db "CO1"  
43d3 f1			.pastdmark: pop af  
43d4			endm  
# End of macro DMARK
43d4						CALLMONITOR 
43d4 cd 6a 16			call break_point_state  
43d7				endm  
# End of macro CALLMONITOR
43d7					endif 
43d7 ed b0				ldir 
43d9			 
43d9 e1					pop hl 
43da e5					push hl 
43db d5					push de 
43dc			 
43dc			 
43dc 3e 00				ld a, 0 
43de cd 6f 11				call strlent 
43e1 23					inc hl    ; zer0 
43e2 23					inc hl 
43e3 06 00				ld b, 0 
43e5 4d					ld c, l 
43e6 d1					pop de 
43e7 e1					pop hl		 
43e8					if DEBUG_FORTH_WORDS 
43e8						DMARK "CO2" 
43e8 f5				push af  
43e9 3a fd 43			ld a, (.dmark)  
43ec 32 bd fb			ld (debug_mark),a  
43ef 3a fe 43			ld a, (.dmark+1)  
43f2 32 be fb			ld (debug_mark+1),a  
43f5 3a ff 43			ld a, (.dmark+2)  
43f8 32 bf fb			ld (debug_mark+2),a  
43fb 18 03			jr .pastdmark  
43fd ..			.dmark: db "CO2"  
4400 f1			.pastdmark: pop af  
4401			endm  
# End of macro DMARK
4401						CALLMONITOR 
4401 cd 6a 16			call break_point_state  
4404				endm  
# End of macro CALLMONITOR
4404					endif 
4404 ed b0				ldir 
4406			 
4406			 
4406			 
4406 21 a3 ef				ld hl, scratch 
4409					if DEBUG_FORTH_WORDS 
4409						DMARK "CO5" 
4409 f5				push af  
440a 3a 1e 44			ld a, (.dmark)  
440d 32 bd fb			ld (debug_mark),a  
4410 3a 1f 44			ld a, (.dmark+1)  
4413 32 be fb			ld (debug_mark+1),a  
4416 3a 20 44			ld a, (.dmark+2)  
4419 32 bf fb			ld (debug_mark+2),a  
441c 18 03			jr .pastdmark  
441e ..			.dmark: db "CO5"  
4421 f1			.pastdmark: pop af  
4422			endm  
# End of macro DMARK
4422						CALLMONITOR 
4422 cd 6a 16			call break_point_state  
4425				endm  
# End of macro CALLMONITOR
4425					endif 
4425			 
4425 cd 68 1c				call forth_push_str 
4428			 
4428			 
4428			 
4428			 
4428				       NEXTW 
4428 c3 63 1f			jp macro_next 
442b				endm 
# End of macro NEXTW
442b			 
442b			 
442b			.FIND: 
442b				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
442b 4b				db WORD_SYS_CORE+55             
442c e9 44			dw .LEN            
442e 05				db 4 + 1 
442f .. 00			db "FIND",0              
4434				endm 
# End of macro CWHEAD
4434			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4434			 
4434					if DEBUG_FORTH_WORDS_KEY 
4434						DMARK "FND" 
4434 f5				push af  
4435 3a 49 44			ld a, (.dmark)  
4438 32 bd fb			ld (debug_mark),a  
443b 3a 4a 44			ld a, (.dmark+1)  
443e 32 be fb			ld (debug_mark+1),a  
4441 3a 4b 44			ld a, (.dmark+2)  
4444 32 bf fb			ld (debug_mark+2),a  
4447 18 03			jr .pastdmark  
4449 ..			.dmark: db "FND"  
444c f1			.pastdmark: pop af  
444d			endm  
# End of macro DMARK
444d						CALLMONITOR 
444d cd 6a 16			call break_point_state  
4450				endm  
# End of macro CALLMONITOR
4450					endif 
4450			 
4450			; TODO check string type 
4450					FORTH_DSP_VALUE 
4450 cd da 1d			call macro_forth_dsp_value 
4453				endm 
# End of macro FORTH_DSP_VALUE
4453			 
4453 e5					push hl    
4454 7e					ld a,(hl)    ; char to find   
4455			; TODO change char to substr 
4455			 
4455 f5					push af 
4456					 
4456			 
4456			 
4456					if DEBUG_FORTH_WORDS 
4456						DMARK "FN1" 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 bd fb			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 be fb			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 bf fb			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "FN1"  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f						CALLMONITOR 
446f cd 6a 16			call break_point_state  
4472				endm  
# End of macro CALLMONITOR
4472					endif 
4472			 
4472					FORTH_DSP_POP 
4472 cd a9 1e			call macro_forth_dsp_pop 
4475				endm 
# End of macro FORTH_DSP_POP
4475			 
4475					; string to search 
4475			 
4475					FORTH_DSP_VALUE 
4475 cd da 1d			call macro_forth_dsp_value 
4478				endm 
# End of macro FORTH_DSP_VALUE
4478			 
4478 d1					pop de  ; d is char to find  
4479			 
4479					if DEBUG_FORTH_WORDS 
4479						DMARK "FN2" 
4479 f5				push af  
447a 3a 8e 44			ld a, (.dmark)  
447d 32 bd fb			ld (debug_mark),a  
4480 3a 8f 44			ld a, (.dmark+1)  
4483 32 be fb			ld (debug_mark+1),a  
4486 3a 90 44			ld a, (.dmark+2)  
4489 32 bf fb			ld (debug_mark+2),a  
448c 18 03			jr .pastdmark  
448e ..			.dmark: db "FN2"  
4491 f1			.pastdmark: pop af  
4492			endm  
# End of macro DMARK
4492						CALLMONITOR 
4492 cd 6a 16			call break_point_state  
4495				endm  
# End of macro CALLMONITOR
4495					endif 
4495					 
4495 01 00 00				ld bc, 0 
4498 7e			.findchar:      ld a,(hl) 
4499 fe 00				cp 0   		 
449b 28 27				jr z, .finddone     
449d ba					cp d 
449e 28 20				jr z, .foundchar 
44a0 03					inc bc 
44a1 23					inc hl 
44a2					if DEBUG_FORTH_WORDS 
44a2						DMARK "FN3" 
44a2 f5				push af  
44a3 3a b7 44			ld a, (.dmark)  
44a6 32 bd fb			ld (debug_mark),a  
44a9 3a b8 44			ld a, (.dmark+1)  
44ac 32 be fb			ld (debug_mark+1),a  
44af 3a b9 44			ld a, (.dmark+2)  
44b2 32 bf fb			ld (debug_mark+2),a  
44b5 18 03			jr .pastdmark  
44b7 ..			.dmark: db "FN3"  
44ba f1			.pastdmark: pop af  
44bb			endm  
# End of macro DMARK
44bb						CALLMONITOR 
44bb cd 6a 16			call break_point_state  
44be				endm  
# End of macro CALLMONITOR
44be					endif 
44be 18 d8				jr .findchar 
44c0			 
44c0			 
44c0 c5			.foundchar:	push bc 
44c1 e1					pop hl 
44c2 18 03				jr .findexit 
44c4			 
44c4			 
44c4							 
44c4			 
44c4			.finddone:     ; got to end of string with no find 
44c4 21 00 00				ld hl, 0 
44c7			.findexit: 
44c7			 
44c7					if DEBUG_FORTH_WORDS 
44c7						DMARK "FNd" 
44c7 f5				push af  
44c8 3a dc 44			ld a, (.dmark)  
44cb 32 bd fb			ld (debug_mark),a  
44ce 3a dd 44			ld a, (.dmark+1)  
44d1 32 be fb			ld (debug_mark+1),a  
44d4 3a de 44			ld a, (.dmark+2)  
44d7 32 bf fb			ld (debug_mark+2),a  
44da 18 03			jr .pastdmark  
44dc ..			.dmark: db "FNd"  
44df f1			.pastdmark: pop af  
44e0			endm  
# End of macro DMARK
44e0						CALLMONITOR 
44e0 cd 6a 16			call break_point_state  
44e3				endm  
# End of macro CALLMONITOR
44e3					endif 
44e3 cd fa 1b			call forth_push_numhl 
44e6			 
44e6				       NEXTW 
44e6 c3 63 1f			jp macro_next 
44e9				endm 
# End of macro NEXTW
44e9			 
44e9			.LEN: 
44e9				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44e9 4c				db WORD_SYS_CORE+56             
44ea 1e 45			dw .CHAR            
44ec 06				db 5 + 1 
44ed .. 00			db "COUNT",0              
44f3				endm 
# End of macro CWHEAD
44f3			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44f3			 
44f3					if DEBUG_FORTH_WORDS_KEY 
44f3						DMARK "CNT" 
44f3 f5				push af  
44f4 3a 08 45			ld a, (.dmark)  
44f7 32 bd fb			ld (debug_mark),a  
44fa 3a 09 45			ld a, (.dmark+1)  
44fd 32 be fb			ld (debug_mark+1),a  
4500 3a 0a 45			ld a, (.dmark+2)  
4503 32 bf fb			ld (debug_mark+2),a  
4506 18 03			jr .pastdmark  
4508 ..			.dmark: db "CNT"  
450b f1			.pastdmark: pop af  
450c			endm  
# End of macro DMARK
450c						CALLMONITOR 
450c cd 6a 16			call break_point_state  
450f				endm  
# End of macro CALLMONITOR
450f					endif 
450f			; TODO check string type 
450f					FORTH_DSP 
450f cd b7 1d			call macro_forth_dsp 
4512				endm 
# End of macro FORTH_DSP
4512					;v5FORTH_DSP_VALUE 
4512			 
4512 23					inc hl 
4513			 
4513 3e 00				ld a, 0 
4515 cd 6f 11				call strlent 
4518			 
4518 cd fa 1b				call forth_push_numhl 
451b			 
451b			 
451b			 
451b				       NEXTW 
451b c3 63 1f			jp macro_next 
451e				endm 
# End of macro NEXTW
451e			.CHAR: 
451e				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
451e 4d				db WORD_SYS_CORE+57             
451f 54 45			dw .ENDSTR            
4521 05				db 4 + 1 
4522 .. 00			db "CHAR",0              
4527				endm 
# End of macro CWHEAD
4527			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4527					if DEBUG_FORTH_WORDS_KEY 
4527						DMARK "CHR" 
4527 f5				push af  
4528 3a 3c 45			ld a, (.dmark)  
452b 32 bd fb			ld (debug_mark),a  
452e 3a 3d 45			ld a, (.dmark+1)  
4531 32 be fb			ld (debug_mark+1),a  
4534 3a 3e 45			ld a, (.dmark+2)  
4537 32 bf fb			ld (debug_mark+2),a  
453a 18 03			jr .pastdmark  
453c ..			.dmark: db "CHR"  
453f f1			.pastdmark: pop af  
4540			endm  
# End of macro DMARK
4540						CALLMONITOR 
4540 cd 6a 16			call break_point_state  
4543				endm  
# End of macro CALLMONITOR
4543					endif 
4543					FORTH_DSP 
4543 cd b7 1d			call macro_forth_dsp 
4546				endm 
# End of macro FORTH_DSP
4546					;v5 FORTH_DSP_VALUE 
4546 23					inc hl      ; now at start of numeric as string 
4547			 
4547			;		push hl 
4547			 
4547					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4547 cd a9 1e			call macro_forth_dsp_pop 
454a				endm 
# End of macro FORTH_DSP_POP
454a			 
454a			;		pop hl 
454a			 
454a					; push the content of a onto the stack as a value 
454a			 
454a 7e					ld a,(hl)   ; get char 
454b 26 00				ld h,0 
454d 6f					ld l,a 
454e cd fa 1b				call forth_push_numhl 
4551			 
4551				       NEXTW 
4551 c3 63 1f			jp macro_next 
4554				endm 
# End of macro NEXTW
4554			 
4554			 
4554			 
4554			 
4554			.ENDSTR: 
4554			; eof 
4554			 
# End of file forth_words_str.asm
4554			include "forth_words_key.asm" 
4554			 
4554			; | ## Keyboard Words 
4554			 
4554			.KEY: 
4554				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4554 3e				db WORD_SYS_CORE+42             
4555 84 45			dw .WAITK            
4557 04				db 3 + 1 
4558 .. 00			db "KEY",0              
455c				endm 
# End of macro CWHEAD
455c			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
455c			 
455c					if DEBUG_FORTH_WORDS_KEY 
455c						DMARK "KEY" 
455c f5				push af  
455d 3a 71 45			ld a, (.dmark)  
4560 32 bd fb			ld (debug_mark),a  
4563 3a 72 45			ld a, (.dmark+1)  
4566 32 be fb			ld (debug_mark+1),a  
4569 3a 73 45			ld a, (.dmark+2)  
456c 32 bf fb			ld (debug_mark+2),a  
456f 18 03			jr .pastdmark  
4571 ..			.dmark: db "KEY"  
4574 f1			.pastdmark: pop af  
4575			endm  
# End of macro DMARK
4575						CALLMONITOR 
4575 cd 6a 16			call break_point_state  
4578				endm  
# End of macro CALLMONITOR
4578					endif 
4578			; TODO currently waits 
4578 cd b7 66				call cin 
457b					;call cin_wait 
457b 6f					ld l, a 
457c 26 00				ld h, 0 
457e cd fa 1b				call forth_push_numhl 
4581					NEXTW 
4581 c3 63 1f			jp macro_next 
4584				endm 
# End of macro NEXTW
4584			.WAITK: 
4584				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4584 3f				db WORD_SYS_CORE+43             
4585 b6 45			dw .ACCEPT            
4587 06				db 5 + 1 
4588 .. 00			db "WAITK",0              
458e				endm 
# End of macro CWHEAD
458e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
458e					if DEBUG_FORTH_WORDS_KEY 
458e						DMARK "WAI" 
458e f5				push af  
458f 3a a3 45			ld a, (.dmark)  
4592 32 bd fb			ld (debug_mark),a  
4595 3a a4 45			ld a, (.dmark+1)  
4598 32 be fb			ld (debug_mark+1),a  
459b 3a a5 45			ld a, (.dmark+2)  
459e 32 bf fb			ld (debug_mark+2),a  
45a1 18 03			jr .pastdmark  
45a3 ..			.dmark: db "WAI"  
45a6 f1			.pastdmark: pop af  
45a7			endm  
# End of macro DMARK
45a7						CALLMONITOR 
45a7 cd 6a 16			call break_point_state  
45aa				endm  
# End of macro CALLMONITOR
45aa					endif 
45aa cd a6 66				call cin_wait 
45ad 6f					ld l, a 
45ae 26 00				ld h, 0 
45b0 cd fa 1b				call forth_push_numhl 
45b3					NEXTW 
45b3 c3 63 1f			jp macro_next 
45b6				endm 
# End of macro NEXTW
45b6			.ACCEPT: 
45b6				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
45b6 40				db WORD_SYS_CORE+44             
45b7 14 46			dw .EDIT            
45b9 07				db 6 + 1 
45ba .. 00			db "ACCEPT",0              
45c1				endm 
# End of macro CWHEAD
45c1			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
45c1					; TODO crashes on push 
45c1					if DEBUG_FORTH_WORDS_KEY 
45c1						DMARK "ACC" 
45c1 f5				push af  
45c2 3a d6 45			ld a, (.dmark)  
45c5 32 bd fb			ld (debug_mark),a  
45c8 3a d7 45			ld a, (.dmark+1)  
45cb 32 be fb			ld (debug_mark+1),a  
45ce 3a d8 45			ld a, (.dmark+2)  
45d1 32 bf fb			ld (debug_mark+2),a  
45d4 18 03			jr .pastdmark  
45d6 ..			.dmark: db "ACC"  
45d9 f1			.pastdmark: pop af  
45da			endm  
# End of macro DMARK
45da						CALLMONITOR 
45da cd 6a 16			call break_point_state  
45dd				endm  
# End of macro CALLMONITOR
45dd					endif 
45dd 21 a1 f1				ld hl, os_input 
45e0 3e 00				ld a, 0 
45e2 77					ld (hl),a 
45e3 3a cc f9				ld a,(f_cursor_ptr) 
45e6 16 64				ld d, 100 
45e8 0e 00				ld c, 0 
45ea 1e 28				ld e, 40 
45ec cd 33 0d				call input_str 
45ef					; TODO perhaps do a type check and wrap in quotes if not a number 
45ef 21 a1 f1				ld hl, os_input 
45f2					if DEBUG_FORTH_WORDS 
45f2						DMARK "AC1" 
45f2 f5				push af  
45f3 3a 07 46			ld a, (.dmark)  
45f6 32 bd fb			ld (debug_mark),a  
45f9 3a 08 46			ld a, (.dmark+1)  
45fc 32 be fb			ld (debug_mark+1),a  
45ff 3a 09 46			ld a, (.dmark+2)  
4602 32 bf fb			ld (debug_mark+2),a  
4605 18 03			jr .pastdmark  
4607 ..			.dmark: db "AC1"  
460a f1			.pastdmark: pop af  
460b			endm  
# End of macro DMARK
460b						CALLMONITOR 
460b cd 6a 16			call break_point_state  
460e				endm  
# End of macro CALLMONITOR
460e					endif 
460e cd 68 1c				call forth_push_str 
4611					NEXTW 
4611 c3 63 1f			jp macro_next 
4614				endm 
# End of macro NEXTW
4614			 
4614			.EDIT: 
4614				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4614 40				db WORD_SYS_CORE+44             
4615 9d 46			dw .ENDKEY            
4617 05				db 4 + 1 
4618 .. 00			db "EDIT",0              
461d				endm 
# End of macro CWHEAD
461d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
461d			 
461d					; TODO does not copy from stack 
461d					if DEBUG_FORTH_WORDS_KEY 
461d						DMARK "EDT" 
461d f5				push af  
461e 3a 32 46			ld a, (.dmark)  
4621 32 bd fb			ld (debug_mark),a  
4624 3a 33 46			ld a, (.dmark+1)  
4627 32 be fb			ld (debug_mark+1),a  
462a 3a 34 46			ld a, (.dmark+2)  
462d 32 bf fb			ld (debug_mark+2),a  
4630 18 03			jr .pastdmark  
4632 ..			.dmark: db "EDT"  
4635 f1			.pastdmark: pop af  
4636			endm  
# End of macro DMARK
4636						CALLMONITOR 
4636 cd 6a 16			call break_point_state  
4639				endm  
# End of macro CALLMONITOR
4639					endif 
4639			 
4639					FORTH_DSP 
4639 cd b7 1d			call macro_forth_dsp 
463c				endm 
# End of macro FORTH_DSP
463c					;v5 FORTH_DSP_VALUE 
463c 23					inc hl    ; TODO do type check 
463d			 
463d e5					push hl 
463e 3e 00				ld a, 0 
4640 cd 6f 11				call strlent 
4643 23					inc hl 
4644			 
4644 06 00				ld b, 0 
4646 4d					ld c, l 
4647			 
4647 e1					pop hl 
4648 11 a1 f1				ld de, os_input 
464b					if DEBUG_FORTH_WORDS_KEY 
464b						DMARK "EDc" 
464b f5				push af  
464c 3a 60 46			ld a, (.dmark)  
464f 32 bd fb			ld (debug_mark),a  
4652 3a 61 46			ld a, (.dmark+1)  
4655 32 be fb			ld (debug_mark+1),a  
4658 3a 62 46			ld a, (.dmark+2)  
465b 32 bf fb			ld (debug_mark+2),a  
465e 18 03			jr .pastdmark  
4660 ..			.dmark: db "EDc"  
4663 f1			.pastdmark: pop af  
4664			endm  
# End of macro DMARK
4664						CALLMONITOR 
4664 cd 6a 16			call break_point_state  
4667				endm  
# End of macro CALLMONITOR
4667					endif 
4667 ed b0				ldir 
4669			 
4669			 
4669 21 a1 f1				ld hl, os_input 
466c					;ld a, 0 
466c					;ld (hl),a 
466c 3a cc f9				ld a,(f_cursor_ptr) 
466f 16 64				ld d, 100 
4671 0e 00				ld c, 0 
4673 1e 28				ld e, 40 
4675 cd 33 0d				call input_str 
4678					; TODO perhaps do a type check and wrap in quotes if not a number 
4678 21 a1 f1				ld hl, os_input 
467b					if DEBUG_FORTH_WORDS 
467b						DMARK "ED1" 
467b f5				push af  
467c 3a 90 46			ld a, (.dmark)  
467f 32 bd fb			ld (debug_mark),a  
4682 3a 91 46			ld a, (.dmark+1)  
4685 32 be fb			ld (debug_mark+1),a  
4688 3a 92 46			ld a, (.dmark+2)  
468b 32 bf fb			ld (debug_mark+2),a  
468e 18 03			jr .pastdmark  
4690 ..			.dmark: db "ED1"  
4693 f1			.pastdmark: pop af  
4694			endm  
# End of macro DMARK
4694						CALLMONITOR 
4694 cd 6a 16			call break_point_state  
4697				endm  
# End of macro CALLMONITOR
4697					endif 
4697 cd 68 1c				call forth_push_str 
469a					NEXTW 
469a c3 63 1f			jp macro_next 
469d				endm 
# End of macro NEXTW
469d			 
469d			 
469d			 
469d			.ENDKEY: 
469d			; eof 
469d			 
# End of file forth_words_key.asm
469d			 
469d			if STORAGE_SE 
469d			   	include "forth_words_storage.asm" 
469d			 
469d			; | ## Fixed Storage Words 
469d			 
469d			 
469d			.BREAD: 
469d			  
469d				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
469d 3a				db WORD_SYS_CORE+38             
469e 16 47			dw .BWRITE            
46a0 06				db 5 + 1 
46a1 .. 00			db "BREAD",0              
46a7				endm 
# End of macro CWHEAD
46a7			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
46a7				 
46a7					if DEBUG_FORTH_WORDS_KEY 
46a7						DMARK "BRD" 
46a7 f5				push af  
46a8 3a bc 46			ld a, (.dmark)  
46ab 32 bd fb			ld (debug_mark),a  
46ae 3a bd 46			ld a, (.dmark+1)  
46b1 32 be fb			ld (debug_mark+1),a  
46b4 3a be 46			ld a, (.dmark+2)  
46b7 32 bf fb			ld (debug_mark+2),a  
46ba 18 03			jr .pastdmark  
46bc ..			.dmark: db "BRD"  
46bf f1			.pastdmark: pop af  
46c0			endm  
# End of macro DMARK
46c0						CALLMONITOR 
46c0 cd 6a 16			call break_point_state  
46c3				endm  
# End of macro CALLMONITOR
46c3					endif 
46c3			 
46c3				FORTH_DSP_VALUEHL 
46c3 cd f1 1d			call macro_dsp_valuehl 
46c6				endm 
# End of macro FORTH_DSP_VALUEHL
46c6			 
46c6				FORTH_DSP_POP 
46c6 cd a9 1e			call macro_forth_dsp_pop 
46c9				endm 
# End of macro FORTH_DSP_POP
46c9			 
46c9				; calc block address 
46c9			 
46c9 eb				ex de, hl 
46ca 3e 40			ld a, STORE_BLOCK_PHY 
46cc cd 89 0c			call Mult16 
46cf			 
46cf			 
46cf 11 e8 f9			ld de, store_page 
46d2			 
46d2					if DEBUG_FORTH_WORDS 
46d2						DMARK "BR1" 
46d2 f5				push af  
46d3 3a e7 46			ld a, (.dmark)  
46d6 32 bd fb			ld (debug_mark),a  
46d9 3a e8 46			ld a, (.dmark+1)  
46dc 32 be fb			ld (debug_mark+1),a  
46df 3a e9 46			ld a, (.dmark+2)  
46e2 32 bf fb			ld (debug_mark+2),a  
46e5 18 03			jr .pastdmark  
46e7 ..			.dmark: db "BR1"  
46ea f1			.pastdmark: pop af  
46eb			endm  
# End of macro DMARK
46eb						CALLMONITOR 
46eb cd 6a 16			call break_point_state  
46ee				endm  
# End of macro CALLMONITOR
46ee					endif 
46ee			 
46ee cd 09 03			call storage_read_block 
46f1			 
46f1 21 ea f9		        ld hl, store_page+2 
46f4					if DEBUG_FORTH_WORDS 
46f4						DMARK "BR2" 
46f4 f5				push af  
46f5 3a 09 47			ld a, (.dmark)  
46f8 32 bd fb			ld (debug_mark),a  
46fb 3a 0a 47			ld a, (.dmark+1)  
46fe 32 be fb			ld (debug_mark+1),a  
4701 3a 0b 47			ld a, (.dmark+2)  
4704 32 bf fb			ld (debug_mark+2),a  
4707 18 03			jr .pastdmark  
4709 ..			.dmark: db "BR2"  
470c f1			.pastdmark: pop af  
470d			endm  
# End of macro DMARK
470d						CALLMONITOR 
470d cd 6a 16			call break_point_state  
4710				endm  
# End of macro CALLMONITOR
4710					endif 
4710 cd 68 1c			call forth_push_str 
4713			 
4713			 
4713					NEXTW 
4713 c3 63 1f			jp macro_next 
4716				endm 
# End of macro NEXTW
4716			.BWRITE: 
4716				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4716 3a				db WORD_SYS_CORE+38             
4717 ab 47			dw .BUPD            
4719 07				db 6 + 1 
471a .. 00			db "BWRITE",0              
4721				endm 
# End of macro CWHEAD
4721			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
4721			 
4721					if DEBUG_FORTH_WORDS_KEY 
4721						DMARK "BWR" 
4721 f5				push af  
4722 3a 36 47			ld a, (.dmark)  
4725 32 bd fb			ld (debug_mark),a  
4728 3a 37 47			ld a, (.dmark+1)  
472b 32 be fb			ld (debug_mark+1),a  
472e 3a 38 47			ld a, (.dmark+2)  
4731 32 bf fb			ld (debug_mark+2),a  
4734 18 03			jr .pastdmark  
4736 ..			.dmark: db "BWR"  
4739 f1			.pastdmark: pop af  
473a			endm  
# End of macro DMARK
473a						CALLMONITOR 
473a cd 6a 16			call break_point_state  
473d				endm  
# End of macro CALLMONITOR
473d					endif 
473d			 
473d				FORTH_DSP_VALUEHL 
473d cd f1 1d			call macro_dsp_valuehl 
4740				endm 
# End of macro FORTH_DSP_VALUEHL
4740			 
4740				; calc block address 
4740			 
4740 eb				ex de, hl 
4741 3e 40			ld a, STORE_BLOCK_PHY 
4743 cd 89 0c			call Mult16 
4746			 
4746 e5				push hl         ; address 
4747			 
4747				FORTH_DSP_POP 
4747 cd a9 1e			call macro_forth_dsp_pop 
474a				endm 
# End of macro FORTH_DSP_POP
474a			 
474a				FORTH_DSP_VALUEHL 
474a cd f1 1d			call macro_dsp_valuehl 
474d				endm 
# End of macro FORTH_DSP_VALUEHL
474d			 
474d				FORTH_DSP_POP 
474d cd a9 1e			call macro_forth_dsp_pop 
4750				endm 
# End of macro FORTH_DSP_POP
4750			 
4750 cd 15 0a			call storage_clear_page 
4753			 
4753				; copy string to store page 
4753			 
4753 e5				push hl     ; save string address 
4754			 
4754 3e 00			ld a, 0 
4756 cd 6f 11			call strlent 
4759			 
4759 23				inc hl 
475a			 
475a 4d				ld c, l 
475b 06 00			ld b, 0 
475d			 
475d e1				pop hl 
475e 11 ea f9			ld de, store_page + 2 
4761					if DEBUG_FORTH_WORDS 
4761						DMARK "BW1" 
4761 f5				push af  
4762 3a 76 47			ld a, (.dmark)  
4765 32 bd fb			ld (debug_mark),a  
4768 3a 77 47			ld a, (.dmark+1)  
476b 32 be fb			ld (debug_mark+1),a  
476e 3a 78 47			ld a, (.dmark+2)  
4771 32 bf fb			ld (debug_mark+2),a  
4774 18 03			jr .pastdmark  
4776 ..			.dmark: db "BW1"  
4779 f1			.pastdmark: pop af  
477a			endm  
# End of macro DMARK
477a						CALLMONITOR 
477a cd 6a 16			call break_point_state  
477d				endm  
# End of macro CALLMONITOR
477d					endif 
477d ed b0			ldir 
477f			 
477f			 
477f				; poke the start of the block with flags to prevent high level file ops hitting the block 
477f			 
477f 21 ff ff			ld hl, $ffff 
4782			 
4782 22 e8 f9			ld (store_page), hl	 
4785				 
4785 e1				pop hl    ; get address 
4786 11 e8 f9			ld de, store_page 
4789			 
4789					if DEBUG_FORTH_WORDS 
4789						DMARK "BW2" 
4789 f5				push af  
478a 3a 9e 47			ld a, (.dmark)  
478d 32 bd fb			ld (debug_mark),a  
4790 3a 9f 47			ld a, (.dmark+1)  
4793 32 be fb			ld (debug_mark+1),a  
4796 3a a0 47			ld a, (.dmark+2)  
4799 32 bf fb			ld (debug_mark+2),a  
479c 18 03			jr .pastdmark  
479e ..			.dmark: db "BW2"  
47a1 f1			.pastdmark: pop af  
47a2			endm  
# End of macro DMARK
47a2						CALLMONITOR 
47a2 cd 6a 16			call break_point_state  
47a5				endm  
# End of macro CALLMONITOR
47a5					endif 
47a5			 
47a5 cd 6e 03			call storage_write_block 
47a8			 
47a8					NEXTW 
47a8 c3 63 1f			jp macro_next 
47ab				endm 
# End of macro NEXTW
47ab			 
47ab			.BUPD: 
47ab				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47ab 3a				db WORD_SYS_CORE+38             
47ac 01 48			dw .BYID            
47ae 05				db 4 + 1 
47af .. 00			db "BUPD",0              
47b4				endm 
# End of macro CWHEAD
47b4			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47b4			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47b4			; | | or completely different file system structure. 
47b4			 
47b4					if DEBUG_FORTH_WORDS_KEY 
47b4						DMARK "BUD" 
47b4 f5				push af  
47b5 3a c9 47			ld a, (.dmark)  
47b8 32 bd fb			ld (debug_mark),a  
47bb 3a ca 47			ld a, (.dmark+1)  
47be 32 be fb			ld (debug_mark+1),a  
47c1 3a cb 47			ld a, (.dmark+2)  
47c4 32 bf fb			ld (debug_mark+2),a  
47c7 18 03			jr .pastdmark  
47c9 ..			.dmark: db "BUD"  
47cc f1			.pastdmark: pop af  
47cd			endm  
# End of macro DMARK
47cd						CALLMONITOR 
47cd cd 6a 16			call break_point_state  
47d0				endm  
# End of macro CALLMONITOR
47d0					endif 
47d0			 
47d0				FORTH_DSP_VALUEHL 
47d0 cd f1 1d			call macro_dsp_valuehl 
47d3				endm 
# End of macro FORTH_DSP_VALUEHL
47d3			 
47d3				; calc block address 
47d3			 
47d3 eb				ex de, hl 
47d4 3e 40			ld a, STORE_BLOCK_PHY 
47d6 cd 89 0c			call Mult16 
47d9			 
47d9				FORTH_DSP_POP 
47d9 cd a9 1e			call macro_forth_dsp_pop 
47dc				endm 
# End of macro FORTH_DSP_POP
47dc			 
47dc			 
47dc 11 e8 f9			ld de, store_page 
47df			 
47df					if DEBUG_FORTH_WORDS 
47df						DMARK "BUe" 
47df f5				push af  
47e0 3a f4 47			ld a, (.dmark)  
47e3 32 bd fb			ld (debug_mark),a  
47e6 3a f5 47			ld a, (.dmark+1)  
47e9 32 be fb			ld (debug_mark+1),a  
47ec 3a f6 47			ld a, (.dmark+2)  
47ef 32 bf fb			ld (debug_mark+2),a  
47f2 18 03			jr .pastdmark  
47f4 ..			.dmark: db "BUe"  
47f7 f1			.pastdmark: pop af  
47f8			endm  
# End of macro DMARK
47f8						CALLMONITOR 
47f8 cd 6a 16			call break_point_state  
47fb				endm  
# End of macro CALLMONITOR
47fb					endif 
47fb			 
47fb cd 6e 03			call storage_write_block 
47fe			 
47fe					NEXTW 
47fe c3 63 1f			jp macro_next 
4801				endm 
# End of macro NEXTW
4801			 
4801			.BYID: 
4801			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4801			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4801			; 
4801			;		 
4801			;		if DEBUG_FORTH_WORDS_KEY 
4801			;			DMARK "BYID" 
4801			;			CALLMONITOR 
4801			;		endif 
4801			; 
4801			;		; get direct address 
4801			; 
4801			;		FORTH_DSP_VALUEHL 
4801			; 
4801			;		FORTH_DSP_POP 
4801			; 
4801			;	; calc block address 
4801			; 
4801			;	ex de, hl 
4801			;	ld a, STORE_BLOCK_PHY 
4801			;	call Mult16 
4801			;	;	do BREAD with number as param 
4801			;	; push the file name	 
4801			;	ld de, store_page 
4801			;	call storage_read_block 
4801			 ;       ld hl, store_page+2 
4801			; 
4801			; 
4801			;		NEXTW 
4801			;.BYNAME: 
4801			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4801			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
4801			;		NEXTW 
4801			; 
4801			.DIR: 
4801				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4801 3a				db WORD_SYS_CORE+38             
4802 05 49			dw .SAVE            
4804 04				db 3 + 1 
4805 .. 00			db "DIR",0              
4809				endm 
# End of macro CWHEAD
4809			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4809			 
4809					if DEBUG_FORTH_WORDS_KEY 
4809						DMARK "DIR" 
4809 f5				push af  
480a 3a 1e 48			ld a, (.dmark)  
480d 32 bd fb			ld (debug_mark),a  
4810 3a 1f 48			ld a, (.dmark+1)  
4813 32 be fb			ld (debug_mark+1),a  
4816 3a 20 48			ld a, (.dmark+2)  
4819 32 bf fb			ld (debug_mark+2),a  
481c 18 03			jr .pastdmark  
481e ..			.dmark: db "DIR"  
4821 f1			.pastdmark: pop af  
4822			endm  
# End of macro DMARK
4822						CALLMONITOR 
4822 cd 6a 16			call break_point_state  
4825				endm  
# End of macro CALLMONITOR
4825					endif 
4825 cd ba 03			call storage_get_block_0 
4828			 
4828 21 e8 f9			ld hl, store_page     ; get current id count 
482b 46				ld b, (hl) 
482c 0e 00			ld c, 0    ; count of files   
482e					if DEBUG_FORTH_WORDS 
482e						DMARK "DI1" 
482e f5				push af  
482f 3a 43 48			ld a, (.dmark)  
4832 32 bd fb			ld (debug_mark),a  
4835 3a 44 48			ld a, (.dmark+1)  
4838 32 be fb			ld (debug_mark+1),a  
483b 3a 45 48			ld a, (.dmark+2)  
483e 32 bf fb			ld (debug_mark+2),a  
4841 18 03			jr .pastdmark  
4843 ..			.dmark: db "DI1"  
4846 f1			.pastdmark: pop af  
4847			endm  
# End of macro DMARK
4847						CALLMONITOR 
4847 cd 6a 16			call break_point_state  
484a				endm  
# End of macro CALLMONITOR
484a					endif 
484a			 
484a				; check for empty drive 
484a			 
484a 3e 00			ld a, 0 
484c b8				cp b 
484d ca bb 48			jp z, .dirdone 
4850			 
4850				; for each of the current ids do a search for them and if found push to stack 
4850			 
4850 c5			.diritem:	push bc 
4851 21 40 00				ld hl, STORE_BLOCK_PHY 
4854 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4856 58					ld e,b 
4857			 
4857			;		if DEBUG_FORTH_WORDS 
4857			;			DMARK "DI2" 
4857			;			CALLMONITOR 
4857			;		endif 
4857			 
4857 cd 2a 06				call storage_findnextid 
485a			 
485a			;		if DEBUG_FORTH_WORDS 
485a			;			DMARK "DI3" 
485a			;			CALLMONITOR 
485a			;		endif 
485a			 
485a					; if found hl will be non zero 
485a			 
485a cd 2f 0d				call ishlzero 
485d			;		ld a, l 
485d			;		add h 
485d			; 
485d			;		cp 0 
485d 28 59				jr z, .dirnotfound 
485f			 
485f					; increase count 
485f			 
485f c1					pop bc	 
4860 0c					inc c 
4861 c5					push bc 
4862					 
4862			 
4862					; get file header and push the file name 
4862			 
4862 11 e8 f9				ld de, store_page 
4865 cd 09 03				call storage_read_block 
4868			 
4868					; push file id to stack 
4868				 
4868 3a e8 f9				ld a, (store_page) 
486b 26 00				ld h, 0 
486d 6f					ld l, a 
486e cd fa 1b				call forth_push_numhl 
4871			 
4871					; push extent count to stack  
4871				 
4871 3a ea f9				ld a, (store_page+2) 
4874 26 00				ld h, 0 
4876 6f					ld l, a 
4877 cd fa 1b				call forth_push_numhl 
487a			 
487a					; push file name 
487a			 
487a 21 eb f9				ld hl, store_page+3 
487d					if DEBUG_FORTH_WORDS 
487d						DMARK "DI5" 
487d f5				push af  
487e 3a 92 48			ld a, (.dmark)  
4881 32 bd fb			ld (debug_mark),a  
4884 3a 93 48			ld a, (.dmark+1)  
4887 32 be fb			ld (debug_mark+1),a  
488a 3a 94 48			ld a, (.dmark+2)  
488d 32 bf fb			ld (debug_mark+2),a  
4890 18 03			jr .pastdmark  
4892 ..			.dmark: db "DI5"  
4895 f1			.pastdmark: pop af  
4896			endm  
# End of macro DMARK
4896						CALLMONITOR 
4896 cd 6a 16			call break_point_state  
4899				endm  
# End of macro CALLMONITOR
4899					endif 
4899 cd 68 1c				call forth_push_str 
489c					if DEBUG_FORTH_WORDS 
489c						DMARK "DI6" 
489c f5				push af  
489d 3a b1 48			ld a, (.dmark)  
48a0 32 bd fb			ld (debug_mark),a  
48a3 3a b2 48			ld a, (.dmark+1)  
48a6 32 be fb			ld (debug_mark+1),a  
48a9 3a b3 48			ld a, (.dmark+2)  
48ac 32 bf fb			ld (debug_mark+2),a  
48af 18 03			jr .pastdmark  
48b1 ..			.dmark: db "DI6"  
48b4 f1			.pastdmark: pop af  
48b5			endm  
# End of macro DMARK
48b5						CALLMONITOR 
48b5 cd 6a 16			call break_point_state  
48b8				endm  
# End of macro CALLMONITOR
48b8					endif 
48b8			.dirnotfound: 
48b8 c1					pop bc     
48b9 10 95				djnz .diritem 
48bb				 
48bb			.dirdone:	 
48bb					if DEBUG_FORTH_WORDS 
48bb						DMARK "DI7" 
48bb f5				push af  
48bc 3a d0 48			ld a, (.dmark)  
48bf 32 bd fb			ld (debug_mark),a  
48c2 3a d1 48			ld a, (.dmark+1)  
48c5 32 be fb			ld (debug_mark+1),a  
48c8 3a d2 48			ld a, (.dmark+2)  
48cb 32 bf fb			ld (debug_mark+2),a  
48ce 18 03			jr .pastdmark  
48d0 ..			.dmark: db "DI7"  
48d3 f1			.pastdmark: pop af  
48d4			endm  
# End of macro DMARK
48d4						CALLMONITOR 
48d4 cd 6a 16			call break_point_state  
48d7				endm  
# End of macro CALLMONITOR
48d7					endif 
48d7			 
48d7					; push a count of the dir items found 
48d7			 
48d7 26 00				ld h, 0 
48d9 69					ld l, c 
48da cd fa 1b				call forth_push_numhl 
48dd			 
48dd					; push the bank label 
48dd			 
48dd cd ba 03				call storage_get_block_0 
48e0			 
48e0				 
48e0 21 eb f9		 		ld hl, store_page+3 
48e3			 
48e3					if DEBUG_FORTH_WORDS 
48e3						DMARK "DI8" 
48e3 f5				push af  
48e4 3a f8 48			ld a, (.dmark)  
48e7 32 bd fb			ld (debug_mark),a  
48ea 3a f9 48			ld a, (.dmark+1)  
48ed 32 be fb			ld (debug_mark+1),a  
48f0 3a fa 48			ld a, (.dmark+2)  
48f3 32 bf fb			ld (debug_mark+2),a  
48f6 18 03			jr .pastdmark  
48f8 ..			.dmark: db "DI8"  
48fb f1			.pastdmark: pop af  
48fc			endm  
# End of macro DMARK
48fc						CALLMONITOR 
48fc cd 6a 16			call break_point_state  
48ff				endm  
# End of macro CALLMONITOR
48ff					endif 
48ff cd 68 1c				call forth_push_str 
4902			 
4902			 
4902				 
4902					NEXTW 
4902 c3 63 1f			jp macro_next 
4905				endm 
# End of macro NEXTW
4905			.SAVE: 
4905			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4905			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4905			;		NEXTW 
4905			;.LOAD: 
4905			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4905			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4905			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4905			;; > > The LOAD command can not be used in any user words or compound lines. 
4905			; 
4905			;		; store_openext use it. If zero it is EOF 
4905			; 
4905			;		; read block from current stream id 
4905			;		; if the block does not contain zero term keep reading blocks until zero found 
4905			;		; push the block to stack 
4905			;		; save the block id to stream 
4905			; 
4905			; 
4905			;		FORTH_DSP_VALUEHL 
4905			; 
4905			;;		push hl 
4905			; 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LOA" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			;		FORTH_DSP_POP 
4905			; 
4905			;;		pop hl 
4905			; 
4905			;		ld h, l 
4905			;		ld l, 0 
4905			; 
4905			;		push hl     ; stack holds current file id and extent to work with 
4905			; 
4905			; 
4905			;		ld de, store_page      ; get block zero of file 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LO0" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			;		call storage_read 
4905			; 
4905			;		ld a, (store_page+2)    ; max extents for this file 
4905			;		ld  (store_openmaxext),a   ; get our limit 
4905			; 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LOE" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			; 
4905			;; TODO dont know why max extents are not present 
4905			;;		cp 0 
4905			;;		jp z, .loadeof     ; dont read past eof 
4905			; 
4905			;;		ld a, 1   ; start from the head of the file 
4905			; 
4905			;.loadline:	pop hl 
4905			;		inc hl 
4905			;		ld  a, (store_openmaxext)   ; get our limit 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LOx" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			;		inc a 
4905			;		cp l 
4905			;		jp z, .loadeof 
4905			;		push hl    ; save current extent 
4905			; 
4905			;		ld de, store_page 
4905			; 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LO1" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			;		call storage_read 
4905			; 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LO2" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			;	call ishlzero 
4905			;	ld a, l 
4905			;	add h 
4905			;	cp 0 
4905			;	jr z, .loadeof 
4905			; 
4905			;	; not eof so hl should point to data to exec 
4905			; 
4905			;	; will need to add the FORTH_END_BUFFER flag 
4905			 ; 
4905			;	ld hl, store_page+2 
4905			;	ld bc, 255 
4905			;	ld a, 0 
4905			;	cpir 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LOt" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			;	dec hl 
4905			;	ld a, ' ' 
4905			;	ld (hl), a 
4905			;	inc hl 
4905			;	ld (hl), a 
4905			;	inc hl 
4905			;	ld (hl), a 
4905			;	inc hl 
4905			;	ld a, FORTH_END_BUFFER 
4905			;	ld (hl), a 
4905			; 
4905			;	; TODO handle more than a single block read 
4905			; 
4905			; 
4905			;	ld hl, store_page+2 
4905			; 
4905			;	ld (os_tok_ptr), hl 
4905			; 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LO3" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			; 
4905			;	call forthparse 
4905			;	call forthexec 
4905			;	call forthexec_cleanup 
4905			; 
4905			;	; go to next extent 
4905			; 
4905			;	; get next block  or mark as eof 
4905			;	jp .loadline 
4905			; 
4905			; 
4905			; 
4905			;	       NEXTW 
4905			;.loadeof:	ld a, 0 
4905			;		ld (store_openext), a 
4905			; 
4905			;	if DEBUG_STORESE 
4905			;		DMARK "LOF" 
4905			;		CALLMONITOR 
4905			;	endif 
4905			;		ret 
4905			;		;NEXTW 
4905			;.BSAVE:   
4905			; 
4905			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4905			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4905			;		NEXTW 
4905			;.BLOAD: 
4905			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4905			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4905			;		NEXTW 
4905			;;;; counter gap 
4905			 
4905			 
4905			.SEO: 
4905				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4905 64				db WORD_SYS_CORE+80             
4906 24 49			dw .SEI            
4908 04				db 3 + 1 
4909 .. 00			db "SEO",0              
490d				endm 
# End of macro CWHEAD
490d			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
490d			 
490d					; get port 
490d			 
490d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
490d cd f1 1d			call macro_dsp_valuehl 
4910				endm 
# End of macro FORTH_DSP_VALUEHL
4910			 
4910 e5					push hl    ; u2 - byte 
4911			 
4911					; destroy value TOS 
4911			 
4911					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4911 cd a9 1e			call macro_forth_dsp_pop 
4914				endm 
# End of macro FORTH_DSP_POP
4914			 
4914					; get byte to send 
4914			 
4914					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4914 cd f1 1d			call macro_dsp_valuehl 
4917				endm 
# End of macro FORTH_DSP_VALUEHL
4917			 
4917 e5					push hl    ; u1 - addr 
4918			 
4918					; destroy value TOS 
4918			 
4918					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4918 cd a9 1e			call macro_forth_dsp_pop 
491b				endm 
# End of macro FORTH_DSP_POP
491b			 
491b					; one value on hl get other one back 
491b			 
491b d1					pop de   ; u1 - byte 
491c			 
491c e1					pop hl   ; u2 - addr 
491d			 
491d					; TODO Send SPI byte 
491d			 
491d			 
491d 7b					ld a, e 
491e cd e7 01				call se_writebyte 
4921			 
4921					 
4921			 
4921					NEXTW 
4921 c3 63 1f			jp macro_next 
4924				endm 
# End of macro NEXTW
4924			 
4924			.SEI: 
4924				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4924 65				db WORD_SYS_CORE+81             
4925 3e 49			dw .SFREE            
4927 04				db 3 + 1 
4928 .. 00			db "SEI",0              
492c				endm 
# End of macro CWHEAD
492c			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
492c			 
492c					; get port 
492c			 
492c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
492c cd f1 1d			call macro_dsp_valuehl 
492f				endm 
# End of macro FORTH_DSP_VALUEHL
492f			 
492f			;		push hl 
492f			 
492f					; destroy value TOS 
492f			 
492f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
492f cd a9 1e			call macro_forth_dsp_pop 
4932				endm 
# End of macro FORTH_DSP_POP
4932			 
4932					; one value on hl get other one back 
4932			 
4932			;		pop hl 
4932			 
4932			 
4932					; TODO Get SPI byte 
4932			 
4932 cd 89 02				call se_readbyte 
4935			 
4935 26 00				ld h, 0 
4937 6f					ld l, a 
4938 cd fa 1b				call forth_push_numhl 
493b			 
493b					NEXTW 
493b c3 63 1f			jp macro_next 
493e				endm 
# End of macro NEXTW
493e			 
493e			.SFREE: 
493e				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
493e 67				db WORD_SYS_CORE+83             
493f 6d 49			dw .SIZE            
4941 06				db 5 + 1 
4942 .. 00			db "FFREE",0              
4948				endm 
# End of macro CWHEAD
4948			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4948					if DEBUG_FORTH_WORDS_KEY 
4948						DMARK "FFR" 
4948 f5				push af  
4949 3a 5d 49			ld a, (.dmark)  
494c 32 bd fb			ld (debug_mark),a  
494f 3a 5e 49			ld a, (.dmark+1)  
4952 32 be fb			ld (debug_mark+1),a  
4955 3a 5f 49			ld a, (.dmark+2)  
4958 32 bf fb			ld (debug_mark+2),a  
495b 18 03			jr .pastdmark  
495d ..			.dmark: db "FFR"  
4960 f1			.pastdmark: pop af  
4961			endm  
# End of macro DMARK
4961						CALLMONITOR 
4961 cd 6a 16			call break_point_state  
4964				endm  
# End of macro CALLMONITOR
4964					endif 
4964			 
4964 cd c4 06				call storage_freeblocks 
4967			 
4967 cd fa 1b				call forth_push_numhl 
496a			 
496a				       NEXTW 
496a c3 63 1f			jp macro_next 
496d				endm 
# End of macro NEXTW
496d			.SIZE: 
496d				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
496d 67				db WORD_SYS_CORE+83             
496e a1 49			dw .CREATE            
4970 05				db 4 + 1 
4971 .. 00			db "SIZE",0              
4976				endm 
# End of macro CWHEAD
4976			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4976					if DEBUG_FORTH_WORDS_KEY 
4976						DMARK "SIZ" 
4976 f5				push af  
4977 3a 8b 49			ld a, (.dmark)  
497a 32 bd fb			ld (debug_mark),a  
497d 3a 8c 49			ld a, (.dmark+1)  
4980 32 be fb			ld (debug_mark+1),a  
4983 3a 8d 49			ld a, (.dmark+2)  
4986 32 bf fb			ld (debug_mark+2),a  
4989 18 03			jr .pastdmark  
498b ..			.dmark: db "SIZ"  
498e f1			.pastdmark: pop af  
498f			endm  
# End of macro DMARK
498f						CALLMONITOR 
498f cd 6a 16			call break_point_state  
4992				endm  
# End of macro CALLMONITOR
4992					endif 
4992			 
4992					FORTH_DSP_VALUEHL 
4992 cd f1 1d			call macro_dsp_valuehl 
4995				endm 
# End of macro FORTH_DSP_VALUEHL
4995			;		push hl 
4995					FORTH_DSP_POP 
4995 cd a9 1e			call macro_forth_dsp_pop 
4998				endm 
# End of macro FORTH_DSP_POP
4998			;		pop hl 
4998 cd 38 03				call storage_file_size 
499b			 
499b cd fa 1b				call forth_push_numhl 
499e			  
499e			 
499e				       NEXTW 
499e c3 63 1f			jp macro_next 
49a1				endm 
# End of macro NEXTW
49a1			 
49a1			.CREATE: 
49a1				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
49a1 68				db WORD_SYS_CORE+84             
49a2 0f 4a			dw .APPEND            
49a4 07				db 6 + 1 
49a5 .. 00			db "CREATE",0              
49ac				endm 
# End of macro CWHEAD
49ac			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49ac			; | | e.g.  
49ac			; | | TestProgram CREATE 
49ac			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49ac			; | |  
49ac			; | | Max file IDs are 255. 
49ac			; | |  
49ac					 
49ac					if DEBUG_FORTH_WORDS_KEY 
49ac						DMARK "CRT" 
49ac f5				push af  
49ad 3a c1 49			ld a, (.dmark)  
49b0 32 bd fb			ld (debug_mark),a  
49b3 3a c2 49			ld a, (.dmark+1)  
49b6 32 be fb			ld (debug_mark+1),a  
49b9 3a c3 49			ld a, (.dmark+2)  
49bc 32 bf fb			ld (debug_mark+2),a  
49bf 18 03			jr .pastdmark  
49c1 ..			.dmark: db "CRT"  
49c4 f1			.pastdmark: pop af  
49c5			endm  
# End of macro DMARK
49c5						CALLMONITOR 
49c5 cd 6a 16			call break_point_state  
49c8				endm  
# End of macro CALLMONITOR
49c8					endif 
49c8			;		call storage_get_block_0 
49c8			 
49c8					; TODO pop hl 
49c8			 
49c8					;v5 FORTH_DSP_VALUE 
49c8					FORTH_DSP_VALUE 
49c8 cd da 1d			call macro_forth_dsp_value 
49cb				endm 
# End of macro FORTH_DSP_VALUE
49cb			 
49cb				if DEBUG_STORESE 
49cb					DMARK "CR1" 
49cb f5				push af  
49cc 3a e0 49			ld a, (.dmark)  
49cf 32 bd fb			ld (debug_mark),a  
49d2 3a e1 49			ld a, (.dmark+1)  
49d5 32 be fb			ld (debug_mark+1),a  
49d8 3a e2 49			ld a, (.dmark+2)  
49db 32 bf fb			ld (debug_mark+2),a  
49de 18 03			jr .pastdmark  
49e0 ..			.dmark: db "CR1"  
49e3 f1			.pastdmark: pop af  
49e4			endm  
# End of macro DMARK
49e4					CALLMONITOR 
49e4 cd 6a 16			call break_point_state  
49e7				endm  
# End of macro CALLMONITOR
49e7				endif 
49e7			;		push hl 
49e7			;		FORTH_DSP_POP 
49e7			;		pop hl 
49e7			 
49e7			;		inc hl   ; move past the type marker 
49e7			 
49e7 cd fa 06				call storage_create 
49ea			 
49ea				if DEBUG_STORESE 
49ea					DMARK "CT1" 
49ea f5				push af  
49eb 3a ff 49			ld a, (.dmark)  
49ee 32 bd fb			ld (debug_mark),a  
49f1 3a 00 4a			ld a, (.dmark+1)  
49f4 32 be fb			ld (debug_mark+1),a  
49f7 3a 01 4a			ld a, (.dmark+2)  
49fa 32 bf fb			ld (debug_mark+2),a  
49fd 18 03			jr .pastdmark  
49ff ..			.dmark: db "CT1"  
4a02 f1			.pastdmark: pop af  
4a03			endm  
# End of macro DMARK
4a03					CALLMONITOR 
4a03 cd 6a 16			call break_point_state  
4a06				endm  
# End of macro CALLMONITOR
4a06				endif 
4a06			;		push hl 
4a06					FORTH_DSP_POP 
4a06 cd a9 1e			call macro_forth_dsp_pop 
4a09				endm 
# End of macro FORTH_DSP_POP
4a09			;		pop hl 
4a09					; push file id to stack 
4a09 cd fa 1b				call forth_push_numhl 
4a0c			 
4a0c			 
4a0c			 
4a0c				       NEXTW 
4a0c c3 63 1f			jp macro_next 
4a0f				endm 
# End of macro NEXTW
4a0f			 
4a0f			.APPEND: 
4a0f				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a0f 69				db WORD_SYS_CORE+85             
4a10 a0 4a			dw .SDEL            
4a12 07				db 6 + 1 
4a13 .. 00			db "APPEND",0              
4a1a				endm 
# End of macro CWHEAD
4a1a			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a1a			; | | e.g. 
4a1a			; | | Test CREATE      -> $01 
4a1a			; | | "A string to add to file" $01 APPEND 
4a1a			; | |  
4a1a			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a1a					if DEBUG_FORTH_WORDS_KEY 
4a1a						DMARK "APP" 
4a1a f5				push af  
4a1b 3a 2f 4a			ld a, (.dmark)  
4a1e 32 bd fb			ld (debug_mark),a  
4a21 3a 30 4a			ld a, (.dmark+1)  
4a24 32 be fb			ld (debug_mark+1),a  
4a27 3a 31 4a			ld a, (.dmark+2)  
4a2a 32 bf fb			ld (debug_mark+2),a  
4a2d 18 03			jr .pastdmark  
4a2f ..			.dmark: db "APP"  
4a32 f1			.pastdmark: pop af  
4a33			endm  
# End of macro DMARK
4a33						CALLMONITOR 
4a33 cd 6a 16			call break_point_state  
4a36				endm  
# End of macro CALLMONITOR
4a36					endif 
4a36			 
4a36					FORTH_DSP_VALUEHL 
4a36 cd f1 1d			call macro_dsp_valuehl 
4a39				endm 
# End of macro FORTH_DSP_VALUEHL
4a39 e5					push hl 	; save file id 
4a3a			 
4a3a				if DEBUG_STORESE 
4a3a					DMARK "AP1" 
4a3a f5				push af  
4a3b 3a 4f 4a			ld a, (.dmark)  
4a3e 32 bd fb			ld (debug_mark),a  
4a41 3a 50 4a			ld a, (.dmark+1)  
4a44 32 be fb			ld (debug_mark+1),a  
4a47 3a 51 4a			ld a, (.dmark+2)  
4a4a 32 bf fb			ld (debug_mark+2),a  
4a4d 18 03			jr .pastdmark  
4a4f ..			.dmark: db "AP1"  
4a52 f1			.pastdmark: pop af  
4a53			endm  
# End of macro DMARK
4a53					CALLMONITOR 
4a53 cd 6a 16			call break_point_state  
4a56				endm  
# End of macro CALLMONITOR
4a56				endif 
4a56					FORTH_DSP_POP 
4a56 cd a9 1e			call macro_forth_dsp_pop 
4a59				endm 
# End of macro FORTH_DSP_POP
4a59			 
4a59					FORTH_DSP_VALUEHL 
4a59 cd f1 1d			call macro_dsp_valuehl 
4a5c				endm 
# End of macro FORTH_DSP_VALUEHL
4a5c					;v5 FORTH_DSP_VALUE 
4a5c e5					push hl 	; save ptr to string to save 
4a5d			 
4a5d				if DEBUG_STORESE 
4a5d					DMARK "AP1" 
4a5d f5				push af  
4a5e 3a 72 4a			ld a, (.dmark)  
4a61 32 bd fb			ld (debug_mark),a  
4a64 3a 73 4a			ld a, (.dmark+1)  
4a67 32 be fb			ld (debug_mark+1),a  
4a6a 3a 74 4a			ld a, (.dmark+2)  
4a6d 32 bf fb			ld (debug_mark+2),a  
4a70 18 03			jr .pastdmark  
4a72 ..			.dmark: db "AP1"  
4a75 f1			.pastdmark: pop af  
4a76			endm  
# End of macro DMARK
4a76					CALLMONITOR 
4a76 cd 6a 16			call break_point_state  
4a79				endm  
# End of macro CALLMONITOR
4a79				endif 
4a79					FORTH_DSP_POP 
4a79 cd a9 1e			call macro_forth_dsp_pop 
4a7c				endm 
# End of macro FORTH_DSP_POP
4a7c			 
4a7c d1					pop de 
4a7d e1					pop hl 
4a7e				if DEBUG_STORESE 
4a7e					DMARK "AP2" 
4a7e f5				push af  
4a7f 3a 93 4a			ld a, (.dmark)  
4a82 32 bd fb			ld (debug_mark),a  
4a85 3a 94 4a			ld a, (.dmark+1)  
4a88 32 be fb			ld (debug_mark+1),a  
4a8b 3a 95 4a			ld a, (.dmark+2)  
4a8e 32 bf fb			ld (debug_mark+2),a  
4a91 18 03			jr .pastdmark  
4a93 ..			.dmark: db "AP2"  
4a96 f1			.pastdmark: pop af  
4a97			endm  
# End of macro DMARK
4a97					CALLMONITOR 
4a97 cd 6a 16			call break_point_state  
4a9a				endm  
# End of macro CALLMONITOR
4a9a				endif 
4a9a					;inc de ; skip var type indicator 
4a9a			 
4a9a					; TODO how to append numerics???? 
4a9a			 
4a9a cd d4 08				call storage_append		 
4a9d			 
4a9d				       NEXTW 
4a9d c3 63 1f			jp macro_next 
4aa0				endm 
# End of macro NEXTW
4aa0			.SDEL: 
4aa0				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4aa0 6a				db WORD_SYS_CORE+86             
4aa1 ec 4a			dw .OPEN            
4aa3 05				db 4 + 1 
4aa4 .. 00			db "ERA",0              
4aa8				endm 
# End of macro CWHEAD
4aa8			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4aa8					FORTH_DSP_VALUEHL 
4aa8 cd f1 1d			call macro_dsp_valuehl 
4aab				endm 
# End of macro FORTH_DSP_VALUEHL
4aab			;		push hl 	; save file id 
4aab			 
4aab					if DEBUG_FORTH_WORDS_KEY 
4aab						DMARK "ERA" 
4aab f5				push af  
4aac 3a c0 4a			ld a, (.dmark)  
4aaf 32 bd fb			ld (debug_mark),a  
4ab2 3a c1 4a			ld a, (.dmark+1)  
4ab5 32 be fb			ld (debug_mark+1),a  
4ab8 3a c2 4a			ld a, (.dmark+2)  
4abb 32 bf fb			ld (debug_mark+2),a  
4abe 18 03			jr .pastdmark  
4ac0 ..			.dmark: db "ERA"  
4ac3 f1			.pastdmark: pop af  
4ac4			endm  
# End of macro DMARK
4ac4						CALLMONITOR 
4ac4 cd 6a 16			call break_point_state  
4ac7				endm  
# End of macro CALLMONITOR
4ac7					endif 
4ac7				if DEBUG_STORESE 
4ac7					DMARK "ER1" 
4ac7 f5				push af  
4ac8 3a dc 4a			ld a, (.dmark)  
4acb 32 bd fb			ld (debug_mark),a  
4ace 3a dd 4a			ld a, (.dmark+1)  
4ad1 32 be fb			ld (debug_mark+1),a  
4ad4 3a de 4a			ld a, (.dmark+2)  
4ad7 32 bf fb			ld (debug_mark+2),a  
4ada 18 03			jr .pastdmark  
4adc ..			.dmark: db "ER1"  
4adf f1			.pastdmark: pop af  
4ae0			endm  
# End of macro DMARK
4ae0					CALLMONITOR 
4ae0 cd 6a 16			call break_point_state  
4ae3				endm  
# End of macro CALLMONITOR
4ae3				endif 
4ae3					FORTH_DSP_POP 
4ae3 cd a9 1e			call macro_forth_dsp_pop 
4ae6				endm 
# End of macro FORTH_DSP_POP
4ae6			 
4ae6			;		pop hl 
4ae6			 
4ae6 cd 49 05				call storage_erase 
4ae9				       NEXTW 
4ae9 c3 63 1f			jp macro_next 
4aec				endm 
# End of macro NEXTW
4aec			 
4aec			.OPEN: 
4aec				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4aec 6b				db WORD_SYS_CORE+87             
4aed 73 4b			dw .READ            
4aef 05				db 4 + 1 
4af0 .. 00			db "OPEN",0              
4af5				endm 
# End of macro CWHEAD
4af5			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4af5			; | | e.g. 
4af5			; | | $01 OPEN $01 DO $01 READ . LOOP 
4af5			 
4af5					if DEBUG_FORTH_WORDS_KEY 
4af5						DMARK "OPN" 
4af5 f5				push af  
4af6 3a 0a 4b			ld a, (.dmark)  
4af9 32 bd fb			ld (debug_mark),a  
4afc 3a 0b 4b			ld a, (.dmark+1)  
4aff 32 be fb			ld (debug_mark+1),a  
4b02 3a 0c 4b			ld a, (.dmark+2)  
4b05 32 bf fb			ld (debug_mark+2),a  
4b08 18 03			jr .pastdmark  
4b0a ..			.dmark: db "OPN"  
4b0d f1			.pastdmark: pop af  
4b0e			endm  
# End of macro DMARK
4b0e						CALLMONITOR 
4b0e cd 6a 16			call break_point_state  
4b11				endm  
# End of macro CALLMONITOR
4b11					endif 
4b11					; TODO handle multiple file opens 
4b11			 
4b11 3e 01			       	ld a, 1 
4b13 32 df f9				ld (store_openext), a 
4b16			 
4b16					; get max extents for this file 
4b16				 
4b16								 
4b16					FORTH_DSP_VALUEHL 
4b16 cd f1 1d			call macro_dsp_valuehl 
4b19				endm 
# End of macro FORTH_DSP_VALUEHL
4b19			 
4b19 65					ld h, l 
4b1a 2e 00				ld l, 0 
4b1c			 
4b1c				if DEBUG_STORESE 
4b1c					DMARK "OPN" 
4b1c f5				push af  
4b1d 3a 31 4b			ld a, (.dmark)  
4b20 32 bd fb			ld (debug_mark),a  
4b23 3a 32 4b			ld a, (.dmark+1)  
4b26 32 be fb			ld (debug_mark+1),a  
4b29 3a 33 4b			ld a, (.dmark+2)  
4b2c 32 bf fb			ld (debug_mark+2),a  
4b2f 18 03			jr .pastdmark  
4b31 ..			.dmark: db "OPN"  
4b34 f1			.pastdmark: pop af  
4b35			endm  
# End of macro DMARK
4b35					CALLMONITOR 
4b35 cd 6a 16			call break_point_state  
4b38				endm  
# End of macro CALLMONITOR
4b38				endif 
4b38			;		push hl 
4b38					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b38 cd a9 1e			call macro_forth_dsp_pop 
4b3b				endm 
# End of macro FORTH_DSP_POP
4b3b			;		pop hl 
4b3b						 
4b3b 11 e8 f9				ld de, store_page      ; get block zero of file 
4b3e cd 4e 08				call storage_read 
4b41			 
4b41			 
4b41 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4b44 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4b47					 
4b47				if DEBUG_STORESE 
4b47					DMARK "OPx" 
4b47 f5				push af  
4b48 3a 5c 4b			ld a, (.dmark)  
4b4b 32 bd fb			ld (debug_mark),a  
4b4e 3a 5d 4b			ld a, (.dmark+1)  
4b51 32 be fb			ld (debug_mark+1),a  
4b54 3a 5e 4b			ld a, (.dmark+2)  
4b57 32 bf fb			ld (debug_mark+2),a  
4b5a 18 03			jr .pastdmark  
4b5c ..			.dmark: db "OPx"  
4b5f f1			.pastdmark: pop af  
4b60			endm  
# End of macro DMARK
4b60					CALLMONITOR 
4b60 cd 6a 16			call break_point_state  
4b63				endm  
# End of macro CALLMONITOR
4b63				endif 
4b63 fe 00				cp 0 
4b65 20 03				jr nz, .skipopeneof 
4b67					; have opened an empty file 
4b67					 
4b67 32 df f9				ld (store_openext), a 
4b6a			 
4b6a			.skipopeneof: 
4b6a			 
4b6a 6f					ld l, a 
4b6b 26 00				ld h, 0 
4b6d cd fa 1b				call forth_push_numhl 
4b70			 
4b70			 
4b70				       NEXTW 
4b70 c3 63 1f			jp macro_next 
4b73				endm 
# End of macro NEXTW
4b73			.READ: 
4b73				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b73 6c				db WORD_SYS_CORE+88             
4b74 ba 4c			dw .EOF            
4b76 05				db 4 + 1 
4b77 .. 00			db "READ",0              
4b7c				endm 
# End of macro CWHEAD
4b7c			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b7c			; | | e.g. 
4b7c			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b7c			 
4b7c					if DEBUG_FORTH_WORDS_KEY 
4b7c						DMARK "REA" 
4b7c f5				push af  
4b7d 3a 91 4b			ld a, (.dmark)  
4b80 32 bd fb			ld (debug_mark),a  
4b83 3a 92 4b			ld a, (.dmark+1)  
4b86 32 be fb			ld (debug_mark+1),a  
4b89 3a 93 4b			ld a, (.dmark+2)  
4b8c 32 bf fb			ld (debug_mark+2),a  
4b8f 18 03			jr .pastdmark  
4b91 ..			.dmark: db "REA"  
4b94 f1			.pastdmark: pop af  
4b95			endm  
# End of macro DMARK
4b95						CALLMONITOR 
4b95 cd 6a 16			call break_point_state  
4b98				endm  
# End of macro CALLMONITOR
4b98					endif 
4b98					; store_openext use it. If zero it is EOF 
4b98			 
4b98					; read block from current stream id 
4b98					; if the block does not contain zero term keep reading blocks until zero found 
4b98					; push the block to stack 
4b98					; save the block id to stream 
4b98			 
4b98			 
4b98					FORTH_DSP_VALUEHL 
4b98 cd f1 1d			call macro_dsp_valuehl 
4b9b				endm 
# End of macro FORTH_DSP_VALUEHL
4b9b			 
4b9b			;		push hl 
4b9b			 
4b9b				if DEBUG_STORESE 
4b9b					DMARK "REA" 
4b9b f5				push af  
4b9c 3a b0 4b			ld a, (.dmark)  
4b9f 32 bd fb			ld (debug_mark),a  
4ba2 3a b1 4b			ld a, (.dmark+1)  
4ba5 32 be fb			ld (debug_mark+1),a  
4ba8 3a b2 4b			ld a, (.dmark+2)  
4bab 32 bf fb			ld (debug_mark+2),a  
4bae 18 03			jr .pastdmark  
4bb0 ..			.dmark: db "REA"  
4bb3 f1			.pastdmark: pop af  
4bb4			endm  
# End of macro DMARK
4bb4					CALLMONITOR 
4bb4 cd 6a 16			call break_point_state  
4bb7				endm  
# End of macro CALLMONITOR
4bb7				endif 
4bb7					FORTH_DSP_POP 
4bb7 cd a9 1e			call macro_forth_dsp_pop 
4bba				endm 
# End of macro FORTH_DSP_POP
4bba			 
4bba			;		pop hl 
4bba				 
4bba 65					ld h,l 
4bbb			 
4bbb 3a df f9				ld a, (store_openext) 
4bbe 6f					ld l, a 
4bbf					 
4bbf fe 00				cp 0 
4bc1 ca 8c 4c				jp z, .ateof     ; dont read past eof 
4bc4			 
4bc4			 
4bc4 11 e8 f9				ld de, store_page 
4bc7				if DEBUG_STORESE 
4bc7					DMARK "RE1" 
4bc7 f5				push af  
4bc8 3a dc 4b			ld a, (.dmark)  
4bcb 32 bd fb			ld (debug_mark),a  
4bce 3a dd 4b			ld a, (.dmark+1)  
4bd1 32 be fb			ld (debug_mark+1),a  
4bd4 3a de 4b			ld a, (.dmark+2)  
4bd7 32 bf fb			ld (debug_mark+2),a  
4bda 18 03			jr .pastdmark  
4bdc ..			.dmark: db "RE1"  
4bdf f1			.pastdmark: pop af  
4be0			endm  
# End of macro DMARK
4be0					CALLMONITOR 
4be0 cd 6a 16			call break_point_state  
4be3				endm  
# End of macro CALLMONITOR
4be3				endif 
4be3 cd 4e 08				call storage_read 
4be6			 
4be6				if DEBUG_STORESE 
4be6					DMARK "RE2" 
4be6 f5				push af  
4be7 3a fb 4b			ld a, (.dmark)  
4bea 32 bd fb			ld (debug_mark),a  
4bed 3a fc 4b			ld a, (.dmark+1)  
4bf0 32 be fb			ld (debug_mark+1),a  
4bf3 3a fd 4b			ld a, (.dmark+2)  
4bf6 32 bf fb			ld (debug_mark+2),a  
4bf9 18 03			jr .pastdmark  
4bfb ..			.dmark: db "RE2"  
4bfe f1			.pastdmark: pop af  
4bff			endm  
# End of macro DMARK
4bff					CALLMONITOR 
4bff cd 6a 16			call break_point_state  
4c02				endm  
# End of macro CALLMONITOR
4c02				endif 
4c02 cd 2f 0d			call ishlzero 
4c05			;	ld a, l 
4c05			;	add h 
4c05			;	cp 0 
4c05 ca 92 4c			jp z, .readeof 
4c08			 
4c08				; not eof so hl should point to data to push to stack 
4c08			 
4c08				if DEBUG_STORESE 
4c08					DMARK "RE3" 
4c08 f5				push af  
4c09 3a 1d 4c			ld a, (.dmark)  
4c0c 32 bd fb			ld (debug_mark),a  
4c0f 3a 1e 4c			ld a, (.dmark+1)  
4c12 32 be fb			ld (debug_mark+1),a  
4c15 3a 1f 4c			ld a, (.dmark+2)  
4c18 32 bf fb			ld (debug_mark+2),a  
4c1b 18 03			jr .pastdmark  
4c1d ..			.dmark: db "RE3"  
4c20 f1			.pastdmark: pop af  
4c21			endm  
# End of macro DMARK
4c21					CALLMONITOR 
4c21 cd 6a 16			call break_point_state  
4c24				endm  
# End of macro CALLMONITOR
4c24				endif 
4c24 cd 68 1c			call forth_push_str 
4c27			 
4c27				if DEBUG_STORESE 
4c27					DMARK "RE4" 
4c27 f5				push af  
4c28 3a 3c 4c			ld a, (.dmark)  
4c2b 32 bd fb			ld (debug_mark),a  
4c2e 3a 3d 4c			ld a, (.dmark+1)  
4c31 32 be fb			ld (debug_mark+1),a  
4c34 3a 3e 4c			ld a, (.dmark+2)  
4c37 32 bf fb			ld (debug_mark+2),a  
4c3a 18 03			jr .pastdmark  
4c3c ..			.dmark: db "RE4"  
4c3f f1			.pastdmark: pop af  
4c40			endm  
# End of macro DMARK
4c40					CALLMONITOR 
4c40 cd 6a 16			call break_point_state  
4c43				endm  
# End of macro CALLMONITOR
4c43				endif 
4c43				; get next block  or mark as eof 
4c43			 
4c43 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4c46 4f				ld c, a	 
4c47 3a df f9			ld a, (store_openext) 
4c4a			 
4c4a				if DEBUG_STORESE 
4c4a					DMARK "RE5" 
4c4a f5				push af  
4c4b 3a 5f 4c			ld a, (.dmark)  
4c4e 32 bd fb			ld (debug_mark),a  
4c51 3a 60 4c			ld a, (.dmark+1)  
4c54 32 be fb			ld (debug_mark+1),a  
4c57 3a 61 4c			ld a, (.dmark+2)  
4c5a 32 bf fb			ld (debug_mark+2),a  
4c5d 18 03			jr .pastdmark  
4c5f ..			.dmark: db "RE5"  
4c62 f1			.pastdmark: pop af  
4c63			endm  
# End of macro DMARK
4c63					CALLMONITOR 
4c63 cd 6a 16			call break_point_state  
4c66				endm  
# End of macro CALLMONITOR
4c66				endif 
4c66 b9				cp c 
4c67 28 29			jr z, .readeof     ; at last extent 
4c69			 
4c69 3c					inc a 
4c6a 32 df f9				ld (store_openext), a 
4c6d			 
4c6d				if DEBUG_STORESE 
4c6d					DMARK "RE6" 
4c6d f5				push af  
4c6e 3a 82 4c			ld a, (.dmark)  
4c71 32 bd fb			ld (debug_mark),a  
4c74 3a 83 4c			ld a, (.dmark+1)  
4c77 32 be fb			ld (debug_mark+1),a  
4c7a 3a 84 4c			ld a, (.dmark+2)  
4c7d 32 bf fb			ld (debug_mark+2),a  
4c80 18 03			jr .pastdmark  
4c82 ..			.dmark: db "RE6"  
4c85 f1			.pastdmark: pop af  
4c86			endm  
# End of macro DMARK
4c86					CALLMONITOR 
4c86 cd 6a 16			call break_point_state  
4c89				endm  
# End of macro CALLMONITOR
4c89				endif 
4c89			 
4c89			 
4c89				       NEXTW 
4c89 c3 63 1f			jp macro_next 
4c8c				endm 
# End of macro NEXTW
4c8c			.ateof: 
4c8c 21 b6 4c				ld hl, .showeof 
4c8f cd 68 1c				call forth_push_str 
4c92 3e 00		.readeof:	ld a, 0 
4c94 32 df f9				ld (store_openext), a 
4c97			 
4c97					 
4c97				if DEBUG_STORESE 
4c97					DMARK "REF" 
4c97 f5				push af  
4c98 3a ac 4c			ld a, (.dmark)  
4c9b 32 bd fb			ld (debug_mark),a  
4c9e 3a ad 4c			ld a, (.dmark+1)  
4ca1 32 be fb			ld (debug_mark+1),a  
4ca4 3a ae 4c			ld a, (.dmark+2)  
4ca7 32 bf fb			ld (debug_mark+2),a  
4caa 18 03			jr .pastdmark  
4cac ..			.dmark: db "REF"  
4caf f1			.pastdmark: pop af  
4cb0			endm  
# End of macro DMARK
4cb0					CALLMONITOR 
4cb0 cd 6a 16			call break_point_state  
4cb3				endm  
# End of macro CALLMONITOR
4cb3				endif 
4cb3				       NEXTW 
4cb3 c3 63 1f			jp macro_next 
4cb6				endm 
# End of macro NEXTW
4cb6			 
4cb6 .. 00		.showeof:   db "eof", 0 
4cba			 
4cba			 
4cba			.EOF: 
4cba				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4cba 6d				db WORD_SYS_CORE+89             
4cbb fb 4c			dw .FORMAT            
4cbd 04				db 3 + 1 
4cbe .. 00			db "EOF",0              
4cc2				endm 
# End of macro CWHEAD
4cc2			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4cc2			; | | e.g. 
4cc2			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4cc2					; TODO if current block id for stream is zero then push true else false 
4cc2			 
4cc2					if DEBUG_FORTH_WORDS_KEY 
4cc2						DMARK "EOF" 
4cc2 f5				push af  
4cc3 3a d7 4c			ld a, (.dmark)  
4cc6 32 bd fb			ld (debug_mark),a  
4cc9 3a d8 4c			ld a, (.dmark+1)  
4ccc 32 be fb			ld (debug_mark+1),a  
4ccf 3a d9 4c			ld a, (.dmark+2)  
4cd2 32 bf fb			ld (debug_mark+2),a  
4cd5 18 03			jr .pastdmark  
4cd7 ..			.dmark: db "EOF"  
4cda f1			.pastdmark: pop af  
4cdb			endm  
# End of macro DMARK
4cdb						CALLMONITOR 
4cdb cd 6a 16			call break_point_state  
4cde				endm  
# End of macro CALLMONITOR
4cde					endif 
4cde			 
4cde					; TODO handlue multiple file streams 
4cde			 
4cde					FORTH_DSP_POP     ; for now just get rid of stream id 
4cde cd a9 1e			call macro_forth_dsp_pop 
4ce1				endm 
# End of macro FORTH_DSP_POP
4ce1			 
4ce1 2e 01				ld l, 1 
4ce3 3a de f9				ld a, (store_openmaxext) 
4ce6 fe 00				cp 0 
4ce8 28 09				jr  z, .eofdone   ; empty file 
4cea 3a df f9				ld a, (store_openext) 
4ced fe 00				cp 0 
4cef 28 02				jr  z, .eofdone 
4cf1 2e 00				ld l, 0 
4cf3 26 00		.eofdone:	ld h, 0 
4cf5 cd fa 1b				call forth_push_numhl 
4cf8			 
4cf8			 
4cf8				       NEXTW 
4cf8 c3 63 1f			jp macro_next 
4cfb				endm 
# End of macro NEXTW
4cfb			 
4cfb			.FORMAT: 
4cfb				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4cfb 6d				db WORD_SYS_CORE+89             
4cfc 4c 4d			dw .LABEL            
4cfe 07				db 6 + 1 
4cff .. 00			db "FORMAT",0              
4d06				endm 
# End of macro CWHEAD
4d06			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d06					; TODO if current block id for stream is zero then push true else false 
4d06				 
4d06				if DEBUG_STORESE 
4d06					DMARK "FOR" 
4d06 f5				push af  
4d07 3a 1b 4d			ld a, (.dmark)  
4d0a 32 bd fb			ld (debug_mark),a  
4d0d 3a 1c 4d			ld a, (.dmark+1)  
4d10 32 be fb			ld (debug_mark+1),a  
4d13 3a 1d 4d			ld a, (.dmark+2)  
4d16 32 bf fb			ld (debug_mark+2),a  
4d19 18 03			jr .pastdmark  
4d1b ..			.dmark: db "FOR"  
4d1e f1			.pastdmark: pop af  
4d1f			endm  
# End of macro DMARK
4d1f					CALLMONITOR 
4d1f cd 6a 16			call break_point_state  
4d22				endm  
# End of macro CALLMONITOR
4d22				endif 
4d22					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d22			 
4d22 21 01 00				ld hl, 1 
4d25 3e 00				ld a, 0 
4d27 cd e7 01				call se_writebyte 
4d2a			 
4d2a				if DEBUG_STORESE 
4d2a					DMARK "FO0" 
4d2a f5				push af  
4d2b 3a 3f 4d			ld a, (.dmark)  
4d2e 32 bd fb			ld (debug_mark),a  
4d31 3a 40 4d			ld a, (.dmark+1)  
4d34 32 be fb			ld (debug_mark+1),a  
4d37 3a 41 4d			ld a, (.dmark+2)  
4d3a 32 bf fb			ld (debug_mark+2),a  
4d3d 18 03			jr .pastdmark  
4d3f ..			.dmark: db "FO0"  
4d42 f1			.pastdmark: pop af  
4d43			endm  
# End of macro DMARK
4d43					CALLMONITOR 
4d43 cd 6a 16			call break_point_state  
4d46				endm  
# End of macro CALLMONITOR
4d46				endif 
4d46					; force bank init 
4d46			 
4d46 cd ba 03				call storage_get_block_0 
4d49					 
4d49				       NEXTW 
4d49 c3 63 1f			jp macro_next 
4d4c				endm 
# End of macro NEXTW
4d4c			.LABEL: 
4d4c				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d4c 6d				db WORD_SYS_CORE+89             
4d4d 9a 4d			dw .STOREPAGE            
4d4f 06				db 5 + 1 
4d50 .. 00			db "LABEL",0              
4d56				endm 
# End of macro CWHEAD
4d56			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d56					; TODO test to see if bank is selected 
4d56				 
4d56					if DEBUG_FORTH_WORDS_KEY 
4d56						DMARK "LBL" 
4d56 f5				push af  
4d57 3a 6b 4d			ld a, (.dmark)  
4d5a 32 bd fb			ld (debug_mark),a  
4d5d 3a 6c 4d			ld a, (.dmark+1)  
4d60 32 be fb			ld (debug_mark+1),a  
4d63 3a 6d 4d			ld a, (.dmark+2)  
4d66 32 bf fb			ld (debug_mark+2),a  
4d69 18 03			jr .pastdmark  
4d6b ..			.dmark: db "LBL"  
4d6e f1			.pastdmark: pop af  
4d6f			endm  
# End of macro DMARK
4d6f						CALLMONITOR 
4d6f cd 6a 16			call break_point_state  
4d72				endm  
# End of macro CALLMONITOR
4d72					endif 
4d72			;	if DEBUG_STORESE 
4d72			;		DMARK "LBL" 
4d72			;		CALLMONITOR 
4d72			;	endif 
4d72					FORTH_DSP_VALUEHL 
4d72 cd f1 1d			call macro_dsp_valuehl 
4d75				endm 
# End of macro FORTH_DSP_VALUEHL
4d75					;v5FORTH_DSP_VALUE 
4d75					 
4d75			;		push hl 
4d75					FORTH_DSP_POP 
4d75 cd a9 1e			call macro_forth_dsp_pop 
4d78				endm 
# End of macro FORTH_DSP_POP
4d78			;		pop hl 
4d78			 
4d78			;v5		inc hl   ; move past the type marker 
4d78			 
4d78				if DEBUG_STORESE 
4d78					DMARK "LBl" 
4d78 f5				push af  
4d79 3a 8d 4d			ld a, (.dmark)  
4d7c 32 bd fb			ld (debug_mark),a  
4d7f 3a 8e 4d			ld a, (.dmark+1)  
4d82 32 be fb			ld (debug_mark+1),a  
4d85 3a 8f 4d			ld a, (.dmark+2)  
4d88 32 bf fb			ld (debug_mark+2),a  
4d8b 18 03			jr .pastdmark  
4d8d ..			.dmark: db "LBl"  
4d90 f1			.pastdmark: pop af  
4d91			endm  
# End of macro DMARK
4d91					CALLMONITOR 
4d91 cd 6a 16			call break_point_state  
4d94				endm  
# End of macro CALLMONITOR
4d94				endif 
4d94 cd de 04				call storage_label 
4d97			 
4d97				       NEXTW 
4d97 c3 63 1f			jp macro_next 
4d9a				endm 
# End of macro NEXTW
4d9a			.STOREPAGE: 
4d9a				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d9a 6d				db WORD_SYS_CORE+89             
4d9b cd 4d			dw .LABELS            
4d9d 0a				db 9 + 1 
4d9e .. 00			db "STOREPAGE",0              
4da8				endm 
# End of macro CWHEAD
4da8			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4da8					; TODO test to see if bank is selected 
4da8				 
4da8					if DEBUG_FORTH_WORDS_KEY 
4da8						DMARK "STP" 
4da8 f5				push af  
4da9 3a bd 4d			ld a, (.dmark)  
4dac 32 bd fb			ld (debug_mark),a  
4daf 3a be 4d			ld a, (.dmark+1)  
4db2 32 be fb			ld (debug_mark+1),a  
4db5 3a bf 4d			ld a, (.dmark+2)  
4db8 32 bf fb			ld (debug_mark+2),a  
4dbb 18 03			jr .pastdmark  
4dbd ..			.dmark: db "STP"  
4dc0 f1			.pastdmark: pop af  
4dc1			endm  
# End of macro DMARK
4dc1						CALLMONITOR 
4dc1 cd 6a 16			call break_point_state  
4dc4				endm  
# End of macro CALLMONITOR
4dc4					endif 
4dc4			;	if DEBUG_STORESE 
4dc4			;		DMARK "STP" 
4dc4			;		CALLMONITOR 
4dc4			;	endif 
4dc4			 
4dc4 21 e8 f9			ld hl, store_page 
4dc7 cd fa 1b			call forth_push_numhl 
4dca			 
4dca			 
4dca				       NEXTW 
4dca c3 63 1f			jp macro_next 
4dcd				endm 
# End of macro NEXTW
4dcd			.LABELS: 
4dcd				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4dcd 6d				db WORD_SYS_CORE+89             
4dce 57 4e			dw .ENDSTORAGE            
4dd0 07				db 6 + 1 
4dd1 .. 00			db "LABELS",0              
4dd8				endm 
# End of macro CWHEAD
4dd8			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dd8					;  
4dd8			 
4dd8					; save the current device selected to restore afterwards 
4dd8				 
4dd8 3a ce f9				ld a, (spi_device) 
4ddb f5					push af 
4ddc			 
4ddc			 
4ddc					; run through each of the banks 
4ddc			 
4ddc 21 01 00				ld hl, 1 
4ddf cd fa 1b				call forth_push_numhl 
4de2 3e ff				ld a, SPI_CE_HIGH 
4de4 cb 87				res SPI_CE0, a 
4de6 32 ce f9				ld (spi_device), a 
4de9 cd ba 03				call storage_get_block_0 
4dec 21 eb f9				ld hl, store_page+3 
4def cd 68 1c				call forth_push_str 
4df2			 
4df2					 
4df2 21 02 00				ld hl, 2 
4df5 cd fa 1b				call forth_push_numhl 
4df8 3e ff				ld a, SPI_CE_HIGH 
4dfa cb 8f				res SPI_CE1, a 
4dfc 32 ce f9				ld (spi_device), a 
4dff cd ba 03				call storage_get_block_0 
4e02 21 eb f9				ld hl, store_page+3 
4e05 cd 68 1c				call forth_push_str 
4e08			 
4e08					 
4e08 21 03 00				ld hl, 3 
4e0b cd fa 1b				call forth_push_numhl 
4e0e 3e ff				ld a, SPI_CE_HIGH 
4e10 cb 97				res SPI_CE2, a 
4e12 32 ce f9				ld (spi_device), a 
4e15 cd ba 03				call storage_get_block_0 
4e18 21 eb f9				ld hl, store_page+3 
4e1b cd 68 1c				call forth_push_str 
4e1e			 
4e1e			 
4e1e 21 04 00				ld hl, 4 
4e21 cd fa 1b				call forth_push_numhl 
4e24 3e ff				ld a, SPI_CE_HIGH 
4e26 cb 9f				res SPI_CE3, a 
4e28 32 ce f9				ld (spi_device), a 
4e2b cd ba 03				call storage_get_block_0 
4e2e 21 eb f9				ld hl, store_page+3 
4e31 cd 68 1c				call forth_push_str 
4e34			 
4e34					 
4e34			 
4e34 21 05 00				ld hl, 5 
4e37 cd fa 1b				call forth_push_numhl 
4e3a 3e ff				ld a, SPI_CE_HIGH 
4e3c cb a7				res SPI_CE4, a 
4e3e 32 ce f9				ld (spi_device), a 
4e41 cd ba 03				call storage_get_block_0 
4e44 21 eb f9				ld hl, store_page+3 
4e47 cd 68 1c				call forth_push_str 
4e4a			 
4e4a					 
4e4a					; push fixed count of storage devices (on board) for now 
4e4a			 
4e4a 21 05 00				ld hl, 5 
4e4d cd fa 1b				call forth_push_numhl 
4e50			 
4e50					; restore selected device  
4e50				 
4e50 f1					pop af 
4e51 32 ce f9				ld (spi_device), a 
4e54			 
4e54				       NEXTW 
4e54 c3 63 1f			jp macro_next 
4e57				endm 
# End of macro NEXTW
4e57			 
4e57			.ENDSTORAGE: 
4e57			; eof 
# End of file forth_words_storage.asm
4e57			endif 
4e57				include "forth_words_device.asm" 
4e57			; Device related words 
4e57			 
4e57			; | ## Device Words 
4e57			 
4e57			if SOUND_ENABLE 
4e57			.NOTE: 
4e57				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e57			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e57					if DEBUG_FORTH_WORDS_KEY 
4e57						DMARK "NTE" 
4e57						CALLMONITOR 
4e57					endif 
4e57			 
4e57				 
4e57			 
4e57					NEXTW 
4e57			.AFTERSOUND: 
4e57			endif 
4e57			 
4e57			 
4e57			USE_GPIO: equ 0 
4e57			 
4e57			if USE_GPIO 
4e57			.GP1: 
4e57				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e57			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e57					NEXTW 
4e57			.GP2: 
4e57				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e57			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e57			 
4e57					NEXTW 
4e57			 
4e57			.GP3: 
4e57				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e57			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e57			 
4e57					NEXTW 
4e57			 
4e57			.GP4: 
4e57				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e57			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e57			 
4e57					NEXTW 
4e57			.SIN: 
4e57			 
4e57			 
4e57			endif 
4e57			 
4e57			 
4e57				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e57 33				db WORD_SYS_CORE+31             
4e58 8c 4e			dw .SOUT            
4e5a 03				db 2 + 1 
4e5b .. 00			db "IN",0              
4e5e				endm 
# End of macro CWHEAD
4e5e			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e5e					if DEBUG_FORTH_WORDS_KEY 
4e5e						DMARK "IN." 
4e5e f5				push af  
4e5f 3a 73 4e			ld a, (.dmark)  
4e62 32 bd fb			ld (debug_mark),a  
4e65 3a 74 4e			ld a, (.dmark+1)  
4e68 32 be fb			ld (debug_mark+1),a  
4e6b 3a 75 4e			ld a, (.dmark+2)  
4e6e 32 bf fb			ld (debug_mark+2),a  
4e71 18 03			jr .pastdmark  
4e73 ..			.dmark: db "IN."  
4e76 f1			.pastdmark: pop af  
4e77			endm  
# End of macro DMARK
4e77						CALLMONITOR 
4e77 cd 6a 16			call break_point_state  
4e7a				endm  
# End of macro CALLMONITOR
4e7a					endif 
4e7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e7a cd f1 1d			call macro_dsp_valuehl 
4e7d				endm 
# End of macro FORTH_DSP_VALUEHL
4e7d			 
4e7d e5					push hl 
4e7e			 
4e7e					; destroy value TOS 
4e7e			 
4e7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e7e cd a9 1e			call macro_forth_dsp_pop 
4e81				endm 
# End of macro FORTH_DSP_POP
4e81			 
4e81					; one value on hl get other one back 
4e81			 
4e81 c1					pop bc 
4e82			 
4e82					; do the sub 
4e82			;		ex de, hl 
4e82			 
4e82 ed 68				in l,(c) 
4e84			 
4e84					; save it 
4e84			 
4e84 26 00				ld h,0 
4e86			 
4e86					; TODO push value back onto stack for another op etc 
4e86			 
4e86 cd fa 1b				call forth_push_numhl 
4e89					NEXTW 
4e89 c3 63 1f			jp macro_next 
4e8c				endm 
# End of macro NEXTW
4e8c			.SOUT: 
4e8c				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e8c 34				db WORD_SYS_CORE+32             
4e8d df 4e			dw .SPIO            
4e8f 04				db 3 + 1 
4e90 .. 00			db "OUT",0              
4e94				endm 
# End of macro CWHEAD
4e94			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e94					if DEBUG_FORTH_WORDS_KEY 
4e94						DMARK "OUT" 
4e94 f5				push af  
4e95 3a a9 4e			ld a, (.dmark)  
4e98 32 bd fb			ld (debug_mark),a  
4e9b 3a aa 4e			ld a, (.dmark+1)  
4e9e 32 be fb			ld (debug_mark+1),a  
4ea1 3a ab 4e			ld a, (.dmark+2)  
4ea4 32 bf fb			ld (debug_mark+2),a  
4ea7 18 03			jr .pastdmark  
4ea9 ..			.dmark: db "OUT"  
4eac f1			.pastdmark: pop af  
4ead			endm  
# End of macro DMARK
4ead						CALLMONITOR 
4ead cd 6a 16			call break_point_state  
4eb0				endm  
# End of macro CALLMONITOR
4eb0					endif 
4eb0			 
4eb0					; get port 
4eb0			 
4eb0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb0 cd f1 1d			call macro_dsp_valuehl 
4eb3				endm 
# End of macro FORTH_DSP_VALUEHL
4eb3			 
4eb3 e5					push hl 
4eb4			 
4eb4					; destroy value TOS 
4eb4			 
4eb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eb4 cd a9 1e			call macro_forth_dsp_pop 
4eb7				endm 
# End of macro FORTH_DSP_POP
4eb7			 
4eb7					; get byte to send 
4eb7			 
4eb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb7 cd f1 1d			call macro_dsp_valuehl 
4eba				endm 
# End of macro FORTH_DSP_VALUEHL
4eba			 
4eba			;		push hl 
4eba			 
4eba					; destroy value TOS 
4eba			 
4eba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eba cd a9 1e			call macro_forth_dsp_pop 
4ebd				endm 
# End of macro FORTH_DSP_POP
4ebd			 
4ebd					; one value on hl get other one back 
4ebd			 
4ebd			;		pop hl 
4ebd			 
4ebd c1					pop bc 
4ebe			 
4ebe					if DEBUG_FORTH_WORDS 
4ebe						DMARK "OUT" 
4ebe f5				push af  
4ebf 3a d3 4e			ld a, (.dmark)  
4ec2 32 bd fb			ld (debug_mark),a  
4ec5 3a d4 4e			ld a, (.dmark+1)  
4ec8 32 be fb			ld (debug_mark+1),a  
4ecb 3a d5 4e			ld a, (.dmark+2)  
4ece 32 bf fb			ld (debug_mark+2),a  
4ed1 18 03			jr .pastdmark  
4ed3 ..			.dmark: db "OUT"  
4ed6 f1			.pastdmark: pop af  
4ed7			endm  
# End of macro DMARK
4ed7						CALLMONITOR 
4ed7 cd 6a 16			call break_point_state  
4eda				endm  
# End of macro CALLMONITOR
4eda					endif 
4eda			 
4eda ed 69				out (c), l 
4edc			 
4edc					NEXTW 
4edc c3 63 1f			jp macro_next 
4edf				endm 
# End of macro NEXTW
4edf			 
4edf			 
4edf			.SPIO: 
4edf			 
4edf			if STORAGE_SE 
4edf				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4edf 51				db WORD_SYS_CORE+61             
4ee0 f0 4e			dw .SPICEH            
4ee2 07				db 6 + 1 
4ee3 .. 00			db "SPICEL",0              
4eea				endm 
# End of macro CWHEAD
4eea			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4eea			 
4eea cd 95 01				call spi_ce_low 
4eed			    NEXTW 
4eed c3 63 1f			jp macro_next 
4ef0				endm 
# End of macro NEXTW
4ef0			 
4ef0			.SPICEH: 
4ef0				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ef0 51				db WORD_SYS_CORE+61             
4ef1 01 4f			dw .SPIOb            
4ef3 07				db 6 + 1 
4ef4 .. 00			db "SPICEH",0              
4efb				endm 
# End of macro CWHEAD
4efb			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4efb			 
4efb cd 84 01				call spi_ce_high 
4efe			    NEXTW 
4efe c3 63 1f			jp macro_next 
4f01				endm 
# End of macro NEXTW
4f01			 
4f01			 
4f01			.SPIOb: 
4f01			 
4f01				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f01 51				db WORD_SYS_CORE+61             
4f02 17 4f			dw .SPII            
4f04 05				db 4 + 1 
4f05 .. 00			db "SPIO",0              
4f0a				endm 
# End of macro CWHEAD
4f0a			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f0a			 
4f0a					; get port 
4f0a			 
4f0a			 
4f0a					; get byte to send 
4f0a			 
4f0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f0a cd f1 1d			call macro_dsp_valuehl 
4f0d				endm 
# End of macro FORTH_DSP_VALUEHL
4f0d			 
4f0d			;		push hl    ; u1  
4f0d			 
4f0d					; destroy value TOS 
4f0d			 
4f0d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f0d cd a9 1e			call macro_forth_dsp_pop 
4f10				endm 
# End of macro FORTH_DSP_POP
4f10			 
4f10					; one value on hl get other one back 
4f10			 
4f10			;		pop hl   ; u2 - addr 
4f10			 
4f10					; TODO Send SPI byte 
4f10			 
4f10 7d					ld a, l 
4f11 cd b9 00				call spi_send_byte 
4f14			 
4f14					NEXTW 
4f14 c3 63 1f			jp macro_next 
4f17				endm 
# End of macro NEXTW
4f17			 
4f17			.SPII: 
4f17				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f17 52				db WORD_SYS_CORE+62             
4f18 2c 4f			dw .SESEL            
4f1a 06				db 5 + 1 
4f1b .. 00			db "SPII",0              
4f20				endm 
# End of macro CWHEAD
4f20			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f20			 
4f20					; TODO Get SPI byte 
4f20			 
4f20 cd da 00				call spi_read_byte 
4f23			 
4f23 26 00				ld h, 0 
4f25 6f					ld l, a 
4f26 cd fa 1b				call forth_push_numhl 
4f29			 
4f29					NEXTW 
4f29 c3 63 1f			jp macro_next 
4f2c				endm 
# End of macro NEXTW
4f2c			 
4f2c			 
4f2c			 
4f2c			.SESEL: 
4f2c				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f2c 66				db WORD_SYS_CORE+82             
4f2d d0 4f			dw .CARTDEV            
4f2f 05				db 4 + 1 
4f30 .. 00			db "BANK",0              
4f35				endm 
# End of macro CWHEAD
4f35			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f35					if DEBUG_FORTH_WORDS_KEY 
4f35						DMARK "BNK" 
4f35 f5				push af  
4f36 3a 4a 4f			ld a, (.dmark)  
4f39 32 bd fb			ld (debug_mark),a  
4f3c 3a 4b 4f			ld a, (.dmark+1)  
4f3f 32 be fb			ld (debug_mark+1),a  
4f42 3a 4c 4f			ld a, (.dmark+2)  
4f45 32 bf fb			ld (debug_mark+2),a  
4f48 18 03			jr .pastdmark  
4f4a ..			.dmark: db "BNK"  
4f4d f1			.pastdmark: pop af  
4f4e			endm  
# End of macro DMARK
4f4e						CALLMONITOR 
4f4e cd 6a 16			call break_point_state  
4f51				endm  
# End of macro CALLMONITOR
4f51					endif 
4f51			 
4f51 3e ff				ld a, 255 
4f53 32 d1 f9				ld (spi_cartdev), a 
4f56			 
4f56					; get bank 
4f56			 
4f56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f56 cd f1 1d			call macro_dsp_valuehl 
4f59				endm 
# End of macro FORTH_DSP_VALUEHL
4f59			 
4f59			;		push hl 
4f59			 
4f59					; destroy value TOS 
4f59			 
4f59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f59 cd a9 1e			call macro_forth_dsp_pop 
4f5c				endm 
# End of macro FORTH_DSP_POP
4f5c			 
4f5c					; one value on hl get other one back 
4f5c			 
4f5c			;		pop hl 
4f5c			 
4f5c			 
4f5c 0e ff				ld c, SPI_CE_HIGH 
4f5e 06 30				ld b, '0'    ; human readable bank number 
4f60			 
4f60 7d					ld a, l 
4f61			 
4f61					if DEBUG_FORTH_WORDS 
4f61						DMARK "BNK" 
4f61 f5				push af  
4f62 3a 76 4f			ld a, (.dmark)  
4f65 32 bd fb			ld (debug_mark),a  
4f68 3a 77 4f			ld a, (.dmark+1)  
4f6b 32 be fb			ld (debug_mark+1),a  
4f6e 3a 78 4f			ld a, (.dmark+2)  
4f71 32 bf fb			ld (debug_mark+2),a  
4f74 18 03			jr .pastdmark  
4f76 ..			.dmark: db "BNK"  
4f79 f1			.pastdmark: pop af  
4f7a			endm  
# End of macro DMARK
4f7a						CALLMONITOR 
4f7a cd 6a 16			call break_point_state  
4f7d				endm  
# End of macro CALLMONITOR
4f7d					endif 
4f7d			 
4f7d					; active low 
4f7d			 
4f7d fe 00				cp 0 
4f7f 28 28				jr z, .bset 
4f81 fe 01				cp 1 
4f83 20 04				jr nz, .b2 
4f85 cb 81				res 0, c 
4f87 06 31				ld b, '1'    ; human readable bank number 
4f89 fe 02		.b2:		cp 2 
4f8b 20 04				jr nz, .b3 
4f8d cb 89				res 1, c 
4f8f 06 32				ld b, '2'    ; human readable bank number 
4f91 fe 03		.b3:		cp 3 
4f93 20 04				jr nz, .b4 
4f95 cb 91				res 2, c 
4f97 06 33				ld b, '3'    ; human readable bank number 
4f99 fe 04		.b4:		cp 4 
4f9b 20 04				jr nz, .b5 
4f9d cb 99				res 3, c 
4f9f 06 34				ld b, '4'    ; human readable bank number 
4fa1 fe 05		.b5:		cp 5 
4fa3 20 04				jr nz, .bset 
4fa5 cb a1				res 4, c 
4fa7 06 35				ld b, '5'    ; human readable bank number 
4fa9			 
4fa9			.bset: 
4fa9 79					ld a, c 
4faa 32 ce f9				ld (spi_device),a 
4fad 78					ld a, b 
4fae 32 cd f9				ld (spi_device_id),a 
4fb1					if DEBUG_FORTH_WORDS 
4fb1						DMARK "BN2" 
4fb1 f5				push af  
4fb2 3a c6 4f			ld a, (.dmark)  
4fb5 32 bd fb			ld (debug_mark),a  
4fb8 3a c7 4f			ld a, (.dmark+1)  
4fbb 32 be fb			ld (debug_mark+1),a  
4fbe 3a c8 4f			ld a, (.dmark+2)  
4fc1 32 bf fb			ld (debug_mark+2),a  
4fc4 18 03			jr .pastdmark  
4fc6 ..			.dmark: db "BN2"  
4fc9 f1			.pastdmark: pop af  
4fca			endm  
# End of macro DMARK
4fca						CALLMONITOR 
4fca cd 6a 16			call break_point_state  
4fcd				endm  
# End of macro CALLMONITOR
4fcd					endif 
4fcd			 
4fcd					NEXTW 
4fcd c3 63 1f			jp macro_next 
4fd0				endm 
# End of macro NEXTW
4fd0			 
4fd0			.CARTDEV: 
4fd0				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fd0 66				db WORD_SYS_CORE+82             
4fd1 79 50			dw .ENDDEVICE            
4fd3 08				db 7 + 1 
4fd4 .. 00			db "CARTDEV",0              
4fdc				endm 
# End of macro CWHEAD
4fdc			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fdc					if DEBUG_FORTH_WORDS_KEY 
4fdc						DMARK "CDV" 
4fdc f5				push af  
4fdd 3a f1 4f			ld a, (.dmark)  
4fe0 32 bd fb			ld (debug_mark),a  
4fe3 3a f2 4f			ld a, (.dmark+1)  
4fe6 32 be fb			ld (debug_mark+1),a  
4fe9 3a f3 4f			ld a, (.dmark+2)  
4fec 32 bf fb			ld (debug_mark+2),a  
4fef 18 03			jr .pastdmark  
4ff1 ..			.dmark: db "CDV"  
4ff4 f1			.pastdmark: pop af  
4ff5			endm  
# End of macro DMARK
4ff5						CALLMONITOR 
4ff5 cd 6a 16			call break_point_state  
4ff8				endm  
# End of macro CALLMONITOR
4ff8					endif 
4ff8			 
4ff8					; disable se storage bank selection 
4ff8			 
4ff8 3e ff				ld a, SPI_CE_HIGH		; ce high 
4ffa 32 ce f9				ld (spi_device), a 
4ffd			 
4ffd					; get bank 
4ffd			 
4ffd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ffd cd f1 1d			call macro_dsp_valuehl 
5000				endm 
# End of macro FORTH_DSP_VALUEHL
5000			 
5000			;		push hl 
5000			 
5000					; destroy value TOS 
5000			 
5000					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5000 cd a9 1e			call macro_forth_dsp_pop 
5003				endm 
# End of macro FORTH_DSP_POP
5003			 
5003					; one value on hl get other one back 
5003			 
5003			;		pop hl 
5003			 
5003					; active low 
5003			 
5003 0e ff				ld c, 255 
5005			 
5005 7d					ld a, l 
5006					if DEBUG_FORTH_WORDS 
5006						DMARK "CDV" 
5006 f5				push af  
5007 3a 1b 50			ld a, (.dmark)  
500a 32 bd fb			ld (debug_mark),a  
500d 3a 1c 50			ld a, (.dmark+1)  
5010 32 be fb			ld (debug_mark+1),a  
5013 3a 1d 50			ld a, (.dmark+2)  
5016 32 bf fb			ld (debug_mark+2),a  
5019 18 03			jr .pastdmark  
501b ..			.dmark: db "CDV"  
501e f1			.pastdmark: pop af  
501f			endm  
# End of macro DMARK
501f						CALLMONITOR 
501f cd 6a 16			call break_point_state  
5022				endm  
# End of macro CALLMONITOR
5022					endif 
5022 fe 00				cp 0 
5024 28 30				jr z, .cset 
5026 fe 01				cp 1 
5028 20 02				jr nz, .c2 
502a cb 81				res 0, c 
502c fe 02		.c2:		cp 2 
502e 20 02				jr nz, .c3 
5030 cb 89				res 1, c 
5032 fe 03		.c3:		cp 3 
5034 20 02				jr nz, .c4 
5036 cb 91				res 2, c 
5038 fe 04		.c4:		cp 4 
503a 20 02				jr nz, .c5 
503c cb 99				res 3, c 
503e fe 05		.c5:		cp 5 
5040 20 02				jr nz, .c6 
5042 cb a1				res 4, c 
5044 fe 06		.c6:		cp 6 
5046 20 02				jr nz, .c7 
5048 cb a9				res 5, c 
504a fe 07		.c7:		cp 7 
504c 20 02				jr nz, .c8 
504e cb b1				res 6, c 
5050 fe 08		.c8:		cp 8 
5052 20 02				jr nz, .cset 
5054 cb b9				res 7, c 
5056 79			.cset:		ld a, c 
5057 32 d1 f9				ld (spi_cartdev),a 
505a			 
505a					if DEBUG_FORTH_WORDS 
505a						DMARK "CD2" 
505a f5				push af  
505b 3a 6f 50			ld a, (.dmark)  
505e 32 bd fb			ld (debug_mark),a  
5061 3a 70 50			ld a, (.dmark+1)  
5064 32 be fb			ld (debug_mark+1),a  
5067 3a 71 50			ld a, (.dmark+2)  
506a 32 bf fb			ld (debug_mark+2),a  
506d 18 03			jr .pastdmark  
506f ..			.dmark: db "CD2"  
5072 f1			.pastdmark: pop af  
5073			endm  
# End of macro DMARK
5073						CALLMONITOR 
5073 cd 6a 16			call break_point_state  
5076				endm  
# End of macro CALLMONITOR
5076					endif 
5076					NEXTW 
5076 c3 63 1f			jp macro_next 
5079				endm 
# End of macro NEXTW
5079			endif 
5079			 
5079			.ENDDEVICE: 
5079			; eof 
5079			 
# End of file forth_words_device.asm
5079			 
5079			; var handler 
5079			 
5079			 
5079			.VARS: 
5079				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5079 78				db WORD_SYS_CORE+100             
507a 91 50			dw .V0Q            
507c 04				db 3 + 1 
507d .. 00			db "V0!",0              
5081				endm 
# End of macro CWHEAD
5081			;| V0! ( u1 -- )  Store value to v0  | DONE 
5081			 
5081					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5081 cd f1 1d			call macro_dsp_valuehl 
5084				endm 
# End of macro FORTH_DSP_VALUEHL
5084			 
5084 11 96 f9				ld de, cli_var_array 
5087			 
5087 eb					ex de, hl 
5088 73					ld (hl), e 
5089 23					inc hl 
508a 72					ld (hl), d 
508b			 
508b					; destroy value TOS 
508b			 
508b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
508b cd a9 1e			call macro_forth_dsp_pop 
508e				endm 
# End of macro FORTH_DSP_POP
508e			 
508e				       NEXTW 
508e c3 63 1f			jp macro_next 
5091				endm 
# End of macro NEXTW
5091			.V0Q: 
5091				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5091 79				db WORD_SYS_CORE+101             
5092 a2 50			dw .V1S            
5094 04				db 3 + 1 
5095 .. 00			db "V0@",0              
5099				endm 
# End of macro CWHEAD
5099			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5099 2a 96 f9				ld hl, (cli_var_array) 
509c cd fa 1b				call forth_push_numhl 
509f			 
509f				       NEXTW 
509f c3 63 1f			jp macro_next 
50a2				endm 
# End of macro NEXTW
50a2			.V1S: 
50a2				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
50a2 7a				db WORD_SYS_CORE+102             
50a3 ba 50			dw .V1Q            
50a5 04				db 3 + 1 
50a6 .. 00			db "V1!",0              
50aa				endm 
# End of macro CWHEAD
50aa			;| V1! ( u1 -- )  Store value to v1 | DONE 
50aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50aa cd f1 1d			call macro_dsp_valuehl 
50ad				endm 
# End of macro FORTH_DSP_VALUEHL
50ad			 
50ad 11 98 f9				ld de, cli_var_array+2 
50b0				 
50b0 eb					ex de, hl 
50b1 73					ld (hl), e 
50b2 23					inc hl 
50b3 72					ld (hl), d 
50b4			 
50b4					; destroy value TOS 
50b4			 
50b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b4 cd a9 1e			call macro_forth_dsp_pop 
50b7				endm 
# End of macro FORTH_DSP_POP
50b7				       NEXTW 
50b7 c3 63 1f			jp macro_next 
50ba				endm 
# End of macro NEXTW
50ba			.V1Q: 
50ba				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50ba 7b				db WORD_SYS_CORE+103             
50bb cb 50			dw .V2S            
50bd 04				db 3 + 1 
50be .. 00			db "V1@",0              
50c2				endm 
# End of macro CWHEAD
50c2			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50c2 2a 98 f9				ld hl, (cli_var_array+2) 
50c5 cd fa 1b				call forth_push_numhl 
50c8				       NEXTW 
50c8 c3 63 1f			jp macro_next 
50cb				endm 
# End of macro NEXTW
50cb			.V2S: 
50cb				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50cb 7c				db WORD_SYS_CORE+104             
50cc e3 50			dw .V2Q            
50ce 04				db 3 + 1 
50cf .. 00			db "V2!",0              
50d3				endm 
# End of macro CWHEAD
50d3			;| V2! ( u1 -- )  Store value to v2 | DONE 
50d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d3 cd f1 1d			call macro_dsp_valuehl 
50d6				endm 
# End of macro FORTH_DSP_VALUEHL
50d6			 
50d6 11 9a f9				ld de, cli_var_array+4 
50d9				 
50d9 eb					ex de, hl 
50da 73					ld (hl), e 
50db 23					inc hl 
50dc 72					ld (hl), d 
50dd			 
50dd					; destroy value TOS 
50dd			 
50dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50dd cd a9 1e			call macro_forth_dsp_pop 
50e0				endm 
# End of macro FORTH_DSP_POP
50e0				       NEXTW 
50e0 c3 63 1f			jp macro_next 
50e3				endm 
# End of macro NEXTW
50e3			.V2Q: 
50e3				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50e3 7d				db WORD_SYS_CORE+105             
50e4 f4 50			dw .V3S            
50e6 04				db 3 + 1 
50e7 .. 00			db "V2@",0              
50eb				endm 
# End of macro CWHEAD
50eb			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50eb 2a 9a f9				ld hl, (cli_var_array+4) 
50ee cd fa 1b				call forth_push_numhl 
50f1				       NEXTW 
50f1 c3 63 1f			jp macro_next 
50f4				endm 
# End of macro NEXTW
50f4			.V3S: 
50f4				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50f4 7c				db WORD_SYS_CORE+104             
50f5 0c 51			dw .V3Q            
50f7 04				db 3 + 1 
50f8 .. 00			db "V3!",0              
50fc				endm 
# End of macro CWHEAD
50fc			;| V3! ( u1 -- )  Store value to v3 | DONE 
50fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50fc cd f1 1d			call macro_dsp_valuehl 
50ff				endm 
# End of macro FORTH_DSP_VALUEHL
50ff			 
50ff 11 9c f9				ld de, cli_var_array+6 
5102				 
5102 eb					ex de, hl 
5103 73					ld (hl), e 
5104 23					inc hl 
5105 72					ld (hl), d 
5106			 
5106					; destroy value TOS 
5106			 
5106					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5106 cd a9 1e			call macro_forth_dsp_pop 
5109				endm 
# End of macro FORTH_DSP_POP
5109				       NEXTW 
5109 c3 63 1f			jp macro_next 
510c				endm 
# End of macro NEXTW
510c			.V3Q: 
510c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
510c 7d				db WORD_SYS_CORE+105             
510d 1d 51			dw .END            
510f 04				db 3 + 1 
5110 .. 00			db "V3@",0              
5114				endm 
# End of macro CWHEAD
5114			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5114 2a 9c f9				ld hl, (cli_var_array+6) 
5117 cd fa 1b				call forth_push_numhl 
511a				       NEXTW 
511a c3 63 1f			jp macro_next 
511d				endm 
# End of macro NEXTW
511d			 
511d			 
511d			 
511d			 
511d			 
511d			; end of dict marker 
511d			 
511d 00			.END:    db WORD_SYS_END 
511e 00 00			dw 0 
5120 00				db 0 
5121			 
5121			; use to jp here for user dict words to save on macro expansion  
5121			 
5121			user_dict_next: 
5121				NEXTW 
5121 c3 63 1f			jp macro_next 
5124				endm 
# End of macro NEXTW
5124			 
5124			 
5124			user_exec: 
5124				;    ld hl, <word code> 
5124				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5124				;    call forthexec 
5124				;    jp user_dict_next   (NEXT) 
5124			        ;    <word code bytes> 
5124 eb				ex de, hl 
5125 2a a4 f2			ld hl,(os_tok_ptr) 
5128				 
5128				FORTH_RSP_NEXT 
5128 cd a1 1b			call macro_forth_rsp_next 
512b				endm 
# End of macro FORTH_RSP_NEXT
512b			 
512b			if DEBUG_FORTH_UWORD 
512b						DMARK "UEX" 
512b f5				push af  
512c 3a 40 51			ld a, (.dmark)  
512f 32 bd fb			ld (debug_mark),a  
5132 3a 41 51			ld a, (.dmark+1)  
5135 32 be fb			ld (debug_mark+1),a  
5138 3a 42 51			ld a, (.dmark+2)  
513b 32 bf fb			ld (debug_mark+2),a  
513e 18 03			jr .pastdmark  
5140 ..			.dmark: db "UEX"  
5143 f1			.pastdmark: pop af  
5144			endm  
# End of macro DMARK
5144				CALLMONITOR 
5144 cd 6a 16			call break_point_state  
5147				endm  
# End of macro CALLMONITOR
5147			endif 
5147			 
5147			 
5147			 
5147 eb				ex de, hl 
5148 22 a4 f2			ld (os_tok_ptr), hl 
514b				 
514b				; Don't use next - Skips the first word in uword. 
514b			 
514b c3 f4 1f			jp exec1 
514e			;	NEXT 
514e			 
514e			 
514e			; eof 
# End of file forth_wordsv4.asm
514e			endif 
514e			;;;;;;;;;;;;;; Debug code 
514e			 
514e			 
514e			;if DEBUG_FORTH_PARSE 
514e .. 00		.nowordfound: db "No match",0 
5157 .. 00		.compword:	db "Comparing word ",0 
5167 .. 00		.nextwordat:	db "Next word at",0 
5174 .. 00		.charmatch:	db "Char match",0 
517f			;endif 
517f			if DEBUG_FORTH_JP 
517f			.foundword:	db "Word match. Exec..",0 
517f			endif 
517f			;if DEBUG_FORTH_PUSH 
517f .. 00		.enddict:	db "Dict end. Push.",0 
518f .. 00		.push_str:	db "Pushing string",0 
519e .. 00		.push_num:	db "Pushing number",0 
51ad .. 00		.data_sp:	db "SP:",0 
51b1 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51c3 .. 00		.wordinde:	db "Word in DE (3/0):",0 
51d5 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51e7			;endif 
51e7			;if DEBUG_FORTH_MALLOC 
51e7 .. 00		.push_malloc:	db "Malloc address",0 
51f6			;endif 
51f6			 
51f6			 
51f6			 
51f6			; display malloc address and current data stack pointer  
51f6			 
51f6			malloc_error: 
51f6 d5				push de 
51f7 f5				push af 
51f8 e5				push hl 
51f9 cd d2 0a			call clear_display 
51fc 11 1e 52			ld de, .mallocerr 
51ff 3e 00			ld a,0 
5201			;	ld de,os_word_scratch 
5201 cd e5 0a			call str_at_display 
5204 3e 11			ld a, display_row_1+17 
5206 11 bd fb			ld de, debug_mark 
5209 cd e5 0a			call str_at_display 
520c cd f5 0a			call update_display 
520f				;call break_point_state 
520f cd a6 66			call cin_wait 
5212			 
5212 3e 20			ld a, ' ' 
5214 32 94 ef			ld (os_view_disable), a 
5217 e1				pop hl 
5218 f1				pop af 
5219 d1				pop de	 
521a				CALLMONITOR 
521a cd 6a 16			call break_point_state  
521d				endm  
# End of macro CALLMONITOR
521d c9				ret 
521e			 
521e .. 00		.mallocerr: 	db "Malloc Error",0 
522b			;if DEBUG_FORTH_PUSH 
522b			display_data_sp: 
522b f5				push af 
522c			 
522c				; see if disabled 
522c			 
522c 3a 94 ef			ld a, (os_view_disable) 
522f fe 2a			cp '*' 
5231 28 67			jr z, .skipdsp 
5233			 
5233 e5				push hl 
5234 e5				push hl 
5235 e5			push hl 
5236 cd d2 0a			call clear_display 
5239 e1			pop hl 
523a 7c				ld a,h 
523b 21 a8 f2			ld hl, os_word_scratch 
523e cd 07 10			call hexout 
5241 e1				pop hl 
5242 7d				ld a,l 
5243 21 aa f2			ld hl, os_word_scratch+2 
5246 cd 07 10			call hexout 
5249 21 ac f2			ld hl, os_word_scratch+4 
524c 3e 00			ld a,0 
524e 77				ld (hl),a 
524f 11 a8 f2			ld de,os_word_scratch 
5252 3e 14				ld a, display_row_2 
5254 cd e5 0a				call str_at_display 
5257 11 b1 51			ld de, .wordinhl 
525a 3e 00			ld a, display_row_1 
525c			 
525c cd e5 0a				call str_at_display 
525f 11 bd fb			ld de, debug_mark 
5262 3e 11			ld a, display_row_1+17 
5264			 
5264 cd e5 0a				call str_at_display 
5267			 
5267				; display current data stack pointer 
5267 11 ad 51			ld de,.data_sp 
526a 3e 1c				ld a, display_row_2 + 8 
526c cd e5 0a				call str_at_display 
526f			 
526f 2a 90 f9			ld hl,(cli_data_sp) 
5272 e5				push hl 
5273 7c				ld a,h 
5274 21 a8 f2			ld hl, os_word_scratch 
5277 cd 07 10			call hexout 
527a e1				pop hl 
527b 7d				ld a,l 
527c 21 aa f2			ld hl, os_word_scratch+2 
527f cd 07 10			call hexout 
5282 21 ac f2			ld hl, os_word_scratch+4 
5285 3e 00			ld a,0 
5287 77				ld (hl),a 
5288 11 a8 f2			ld de,os_word_scratch 
528b 3e 1f				ld a, display_row_2 + 11 
528d cd e5 0a				call str_at_display 
5290			 
5290			 
5290 cd f5 0a			call update_display 
5293 cd 52 0a			call delay1s 
5296 cd 52 0a			call delay1s 
5299 e1				pop hl 
529a			.skipdsp: 
529a f1				pop af 
529b c9				ret 
529c			 
529c			display_data_malloc: 
529c			 
529c f5				push af 
529d e5				push hl 
529e e5				push hl 
529f e5			push hl 
52a0 cd d2 0a			call clear_display 
52a3 e1			pop hl 
52a4 7c				ld a,h 
52a5 21 a8 f2			ld hl, os_word_scratch 
52a8 cd 07 10			call hexout 
52ab e1				pop hl 
52ac 7d				ld a,l 
52ad 21 aa f2			ld hl, os_word_scratch+2 
52b0 cd 07 10			call hexout 
52b3 21 ac f2			ld hl, os_word_scratch+4 
52b6 3e 00			ld a,0 
52b8 77				ld (hl),a 
52b9 11 a8 f2			ld de,os_word_scratch 
52bc 3e 14				ld a, display_row_2 
52be cd e5 0a				call str_at_display 
52c1 11 e7 51			ld de, .push_malloc 
52c4 3e 00			ld a, display_row_1 
52c6			 
52c6 cd e5 0a				call str_at_display 
52c9			 
52c9				; display current data stack pointer 
52c9 11 ad 51			ld de,.data_sp 
52cc 3e 1c				ld a, display_row_2 + 8 
52ce cd e5 0a				call str_at_display 
52d1			 
52d1 2a 90 f9			ld hl,(cli_data_sp) 
52d4 e5				push hl 
52d5 7c				ld a,h 
52d6 21 a8 f2			ld hl, os_word_scratch 
52d9 cd 07 10			call hexout 
52dc e1				pop hl 
52dd 7d				ld a,l 
52de 21 aa f2			ld hl, os_word_scratch+2 
52e1 cd 07 10			call hexout 
52e4 21 ac f2			ld hl, os_word_scratch+4 
52e7 3e 00			ld a,0 
52e9 77				ld (hl),a 
52ea 11 a8 f2			ld de,os_word_scratch 
52ed 3e 1f				ld a, display_row_2 + 11 
52ef cd e5 0a				call str_at_display 
52f2			 
52f2 cd f5 0a			call update_display 
52f5 cd 52 0a			call delay1s 
52f8 cd 52 0a			call delay1s 
52fb e1				pop hl 
52fc f1				pop af 
52fd c9				ret 
52fe			;endif 
52fe			 
52fe			include "forth_autostart.asm" 
52fe			; list of commands to perform at system start up 
52fe			 
52fe			startcmds: 
52fe			;	dw test11 
52fe			;	dw test12 
52fe			;	dw test13 
52fe			;	dw test14 
52fe			;	dw test15 
52fe			;	dw test16 
52fe			;	dw test17 
52fe			;	dw ifthtest1 
52fe			;	dw ifthtest2 
52fe			;	dw ifthtest3 
52fe			;	dw mmtest1 
52fe			;	dw mmtest2 
52fe			;	dw mmtest3 
52fe			;	dw mmtest4 
52fe			;	dw mmtest5 
52fe			;	dw mmtest6 
52fe			;	dw iftest1 
52fe			;	dw iftest2 
52fe			;	dw iftest3 
52fe			;	dw looptest1 
52fe			;	dw looptest2 
52fe			;	dw test1 
52fe			;	dw test2 
52fe			;	dw test3 
52fe			;	dw test4 
52fe			;	dw game2r 
52fe			;	dw game2b1 
52fe			;	dw game2b2 
52fe			 
52fe				; start up words that are actually useful 
52fe			 
52fe 5c 53			dw clrstack 
5300 8f 53			dw type 
5302 50 55			dw stest 
5304 b3 53			dw strncpy 
5306 f1 54			dw list 
5308 14 54			dw start1 
530a 26 54			dw start2 
530c			;	dw start3 
530c 39 54			dw start3b 
530e 91 54			dw start3c 
5310			 
5310				; (unit) testing words 
5310			 
5310 c7 55			dw mtesta 
5312 7c 56			dw mtestb 
5314 1f 57			dw mtestc 
5316 d4 57			dw mtestd 
5318 78 58			dw mteste 
531a			 
531a				; demo/game words 
531a			 
531a 84 5f		        dw game3w 
531c b2 5f		        dw game3p 
531e d0 5f		        dw game3sc 
5320 01 60		        dw game3vsi 
5322 2d 60		        dw game3vs 
5324				 
5324 77 5d			dw game2b 
5326 e5 5d			dw game2bf 
5328 2f 5e			dw game2mba 
532a c5 5e			dw game2mbas 
532c 07 5f			dw game2mb 
532e			 
532e 38 5a			dw game1 
5330 49 5a			dw game1a 
5332 ab 5a			dw game1b 
5334 e0 5a			dw game1c 
5336 16 5b			dw game1d 
5338 47 5b			dw game1s 
533a 5b 5b			dw game1t 
533c 70 5b			dw game1f 
533e a4 5b			dw game1z 
5340 e8 5b			dw game1zz 
5342			 
5342 2e 59			dw test5 
5344 66 59			dw test6 
5346 9e 59			dw test7 
5348 b2 59			dw test8 
534a de 59			dw test9 
534c f4 59			dw test10 
534e				 
534e bf 5c		        dw ssv5 
5350 a3 5c		        dw ssv4 
5352 87 5c		        dw ssv3 
5354 51 5c		        dw ssv2 
5356 d8 5c		        dw ssv1 
5358 20 5d		        dw ssv1cpm 
535a			;	dw keyup 
535a			;	dw keydown 
535a			;	dw keyleft 
535a			;	dw keyright 
535a			;	dw 	keyf1 
535a			;	dw keyf2 
535a			;	dw keyf3 
535a			;	dw keyf4 
535a			;	dw keyf5 
535a			;	dw keyf6 
535a			;	dw keyf7 
535a			;	dw keyf8 
535a			;	dw keyf9 
535a			;	dw keyf10 
535a			;	dw keyf11 
535a			;	dw keyf12 
535a			;	dw keytab 
535a			;	dw keycr 
535a			;	dw keyhome 
535a			;	dw keyend 
535a			;	dw keybs 
535a 00 00			db 0, 0	 
535c			 
535c			 
535c			; clear stack  
535c			 
535c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
538f			 
538f			; type ( addr count - ) 
538f .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
53b3			 
53b3			; some direct memory words 
53b3			; strncpy ( len t f -- t ) 
53b3			 
53b3 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5414			 
5414 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5426 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5439			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5439 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5491 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54f1			 
54f1			 
54f1			; a handy word to list items on the stack 
54f1			 
54f1 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5550			 
5550			 
5550			; test stack  
5550			; rnd8 stest 
5550			 
5550 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55c7			 
55c7			; random malloc and free cycles 
55c7			 
55c7 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
567c			 
567c			; fixed malloc and free cycles 
567c			 
567c .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
571f			 
571f			; fixed double string push and drop cycle  
571f			 
571f .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57d4			 
57d4			; consistent fixed string push and drop cycle  
57d4			 
57d4 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5878			 
5878 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
592e			 
592e			;test1:		db ": aa 1 2 3 ;", 0 
592e			;test2:     	db "111 aa 888 999",0 
592e			;test3:     	db ": bb 77 ;",0 
592e			;test4:     	db "$02 $01 do i . loop bb",0 
592e			 
592e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5966 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
599e .. 00		test7:     	db ": box hline vline ;",0 
59b2 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59de .. 00		test9:     	db ": sw $01 adsp world ;",0 
59f4 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a19 .. 00		test11:     	db "hello create .",0 
5a28 .. 00		test12:     	db "hello2 create .",0 
5a38			 
5a38			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a38			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a38			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a38			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a38			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a38			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a38			 
5a38			;iftest1:     	db "$0001 IF cls .",0 
5a38			;iftest2:     	db "$0000 IF cls .",0 
5a38			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a38			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a38			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a38			 
5a38			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a38			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a38			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a38			 
5a38			 
5a38			 
5a38			; a small guess the number game 
5a38			 
5a38 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a49 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5aab			 
5aab .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ae0 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b16 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b47 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b5b .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b70 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ba4 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5be8			 
5be8			; Using 'ga' save a high score across multiple runs using external storage 
5be8			 
5be8 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c51			 
5c51			 
5c51			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c51			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c51			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c51			 
5c51			; simple screen saver to test code memory reuse to destruction 
5c51			 
5c51 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c87 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5ca3 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cbf .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cd8 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d20 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d77			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d77			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d77			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d77			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d77			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d77			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d77			 
5d77			 
5d77			 
5d77			; minesweeper/battleship finding game 
5d77			; draws a game board of random ship/mine positions 
5d77			; user enters coords to see if it hits on 
5d77			; game ends when all are hit 
5d77			; when hit or miss says how many may be in the area 
5d77			 
5d77			; setup the game board and then hide it 
5d77 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5de5 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e2f			; prompt for where to target 
5e2f .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ec5 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5eea			; TODO see if the entered coords hits or misses pushes char hit of miss 
5eea .. 00		game2mbht:      db ": mbckht nop ;",0 
5ef9 .. 00		game2mbms:      db ": mbcms nop ;",0 
5f07			; TODO how many might be near by 
5f07 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f84			 
5f84			; Game 3 
5f84			 
5f84			; Vert scroller ski game - avoid the trees! 
5f84			 
5f84			; v0 score (ie turns) 
5f84			; v1 player pos 
5f84			; v2 left wall 
5f84			; v3 right wall 
5f84			 
5f84			; Draw side walls randomly 
5f84			 
5f84 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fb2			 
5fb2			; Draw player 
5fb2 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fd0			 
5fd0			; TODO Get Key 
5fd0			 
5fd0			; TODO Move left right 
5fd0			 
5fd0			; scroll and move walls a bit 
5fd0			 
5fd0 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6001			 
6001			; main game loop 
6001			 
6001 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
602d .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
606c			 
606c			; key board defs 
606c			 
606c .. 00		keyup:       db ": keyup $05 ;",0 
607a .. 00		keydown:       db ": keydown $0a ;",0 
608a .. 00		keyleft:       db ": keyleft $0b ;",0 
609a .. 00		keyright:       db ": keyright $0c ;",0 
60ab .. 00		keyf1:       db ": keyf1 $10 ;",0 
60b9 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60c7 .. 00		keyf3:       db ": keyf3 $12 ;",0 
60d5 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60e3 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60f1 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60ff .. 00		keyf7:       db ": keyf7 $16 ;",0 
610d .. 00		keyf8:       db ": keyf8 $17 ;",0 
611b .. 00		keyf9:       db ": keyf9 $18 ;",0 
6129 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6138 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6147 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6156			 
6156 .. 00		keytab:       db ": keytab $09 ;",0 
6165 .. 00		keycr:       db ": keycr $0d ;",0 
6173 .. 00		keyhome:       db ": keyhome $0e ;",0 
6183 .. 00		keyend:       db ": keyend $0f ;",0 
6192 .. 00		keybs:       db ": keybs $08 ;",0 
61a0			 
61a0			   
61a0			 
61a0			 
61a0			 
61a0			; eof 
# End of file forth_autostart.asm
61a0			 
61a0 .. 00		sprompt1: db "Startup load...",0 
61b0 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61c6			 
61c6			 
61c6			 
61c6			 
61c6			forth_startup: 
61c6 21 fe 52			ld hl, startcmds 
61c9 3e 00			ld a, 0 
61cb 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61ce			 
61ce e5			.start1:	push hl 
61cf cd d2 0a			call clear_display 
61d2 11 a0 61			ld de, sprompt1 
61d5 3e 00		        ld a, display_row_1 
61d7 cd e5 0a			call str_at_display 
61da 11 b0 61			ld de, sprompt2 
61dd 3e 14		        ld a, display_row_2 
61df cd e5 0a			call str_at_display 
61e2 e1				pop hl 
61e3 e5				push hl 
61e4 5e				ld e,(hl) 
61e5 23				inc hl 
61e6 56				ld d,(hl) 
61e7 3e 28		        ld a, display_row_3 
61e9 cd e5 0a			call str_at_display 
61ec cd f5 0a			call update_display 
61ef			 
61ef			 
61ef 3a c9 f3			ld a, (os_last_cmd) 
61f2 fe 00			cp 0 
61f4 28 05			jr z, .startprompt 
61f6 cd 46 0a			call delay250ms 
61f9 18 24			jr .startdo 
61fb				 
61fb				 
61fb			 
61fb			.startprompt: 
61fb			 
61fb 3e 4f			ld a,display_row_4 + display_cols - 1 
61fd 11 70 1b		        ld de, endprg 
6200 cd e5 0a			call str_at_display 
6203 cd f5 0a			call update_display 
6206 cd 52 0a			call delay1s 
6209 cd a6 66			call cin_wait 
620c						 
620c fe 2a			cp '*' 
620e 28 5e			jr z, .startupend1 
6210 fe 23			cp '#' 
6212 20 07			jr nz, .startno 
6214 3e 01			ld a, 1 
6216 32 c9 f3			ld (os_last_cmd),a 
6219 18 04			jr .startdo 
621b fe 31		.startno:	cp '1' 
621d 28 3a			jr z,.startnxt  
621f			 
621f				; exec startup line 
621f			.startdo:	 
621f e1				pop hl 
6220 e5				push hl 
6221				 
6221 5e				ld e,(hl) 
6222 23				inc hl 
6223 56				ld d,(hl) 
6224 eb				ex de,hl 
6225			 
6225 e5				push hl 
6226			 
6226 3e 00			ld a, 0 
6228				;ld a, FORTH_END_BUFFER 
6228 cd 6f 11			call strlent 
622b 23				inc hl   ; include zero term to copy 
622c 06 00			ld b,0 
622e 4d				ld c,l 
622f e1				pop hl 
6230 11 a3 ef			ld de, scratch 
6233 ed b0			ldir 
6235			 
6235			 
6235 21 a3 ef			ld hl, scratch 
6238 cd b1 1f			call forthparse 
623b cd f1 1f			call forthexec 
623e cd 08 1f			call forthexec_cleanup 
6241			 
6241 3e 3c			ld a, display_row_4 
6243 11 14 19			ld de, endprog 
6246			 
6246 cd f5 0a			call update_display		 
6249			 
6249 3a c9 f3			ld a, (os_last_cmd) 
624c fe 00			cp 0 
624e 20 09			jr nz, .startnxt 
6250 cd 72 1b			call next_page_prompt 
6253 cd d2 0a		        call clear_display 
6256 cd f5 0a			call update_display		 
6259			 
6259				; move onto next startup line? 
6259			.startnxt: 
6259			 
6259 cd 46 0a			call delay250ms 
625c e1				pop hl 
625d			 
625d 23				inc hl 
625e 23				inc hl 
625f			 
625f e5				push hl 
6260 5e				ld e, (hl) 
6261 23				inc hl 
6262 56				ld d, (hl) 
6263 e1				pop hl 
6264				; TODO replace 0 test 
6264			 
6264 eb				ex de, hl 
6265 cd 2f 0d			call ishlzero 
6268			;	ld a,e 
6268			;	add d 
6268			;	cp 0    ; any left to do? 
6268 eb				ex de, hl 
6269 c2 ce 61			jp nz, .start1 
626c 18 01			jr .startupend 
626e			 
626e e1			.startupend1: pop hl 
626f			.startupend: 
626f			 
626f cd d2 0a			call clear_display 
6272 cd f5 0a			call update_display 
6275 c9				ret 
6276			 
6276			 
6276			; stack over and underflow checks 
6276			 
6276			; init the words to detect the under/overflow 
6276			 
6276			chk_stk_init: 
6276				; a vague random number to check so we dont get any "lucky" hits 
6276 3e 2d			ld a, 45 
6278 6f				ld l, a 
6279 00				nop 
627a 3e 17			ld a, 23 
627c 67				ld h, a 
627d			 
627d 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
6280			 
6280			;	ld (chk_stund), hl	; stack points.... 
6280 22 fd fb			ld (chk_stovr), hl 
6283 22 8e f9			ld (chk_ret_und), hl 
6286 22 0c f9			ld (chk_ret_ovr), hl 
6289 22 0a f7			ld (chk_loop_ovr), hl 
628c 22 08 f5			ld (chk_data_ovr), hl 
628f c9				ret 
6290				 
6290			check_stacks: 
6290				; check all stack words 
6290			 
6290 e5				push hl 
6291 d5				push de 
6292			 
6292			;	ld de,(chk_word) 
6292			;	ld hl, (chk_stund)	; stack points.... 
6292			;	if DEBUG_STK_FAULT 
6292			;		DMARK "FAa" 
6292			;		CALLMONITOR 
6292			;	endif 
6292			;	call cmp16 
6292			;	jp z, .chk_faulta 
6292			; 
6292			;	ld de, sfaultsu 
6292			;	jp .chk_fault 
6292			 
6292 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6295 ed 5b 8a ef		ld de,(chk_word) 
6299				if DEBUG_STK_FAULT 
6299					DMARK "FAb" 
6299					CALLMONITOR 
6299				endif 
6299 cd 24 0d			call cmp16 
629c 28 06			jr z, .chk_fault1 
629e 11 3f 63			ld de, sfaultso 
62a1 c3 f3 62			jp .chk_fault 
62a4			.chk_fault1:  
62a4 2a 8e f9			ld hl, (chk_ret_und) 
62a7 ed 5b 8a ef		ld de,(chk_word) 
62ab				if DEBUG_STK_FAULT 
62ab					DMARK "FAU" 
62ab					CALLMONITOR 
62ab				endif 
62ab cd 24 0d			call cmp16 
62ae ca b7 62			jp z, .chk_fault2 
62b1 11 4f 63			ld de, sfaultru 
62b4 c3 f3 62			jp .chk_fault 
62b7			.chk_fault2:  
62b7 2a 0c f9			ld hl, (chk_ret_ovr) 
62ba ed 5b 8a ef		ld de,(chk_word) 
62be				if DEBUG_STK_FAULT 
62be					DMARK "FA1" 
62be					CALLMONITOR 
62be				endif 
62be cd 24 0d			call cmp16 
62c1 ca ca 62			jp z, .chk_fault3 
62c4 11 5d 63			ld de, sfaultro 
62c7 c3 f3 62			jp .chk_fault 
62ca			.chk_fault3:  
62ca 2a 0a f7			ld hl, (chk_loop_ovr) 
62cd ed 5b 8a ef		ld de,(chk_word) 
62d1				if DEBUG_STK_FAULT 
62d1					DMARK "FA2" 
62d1					CALLMONITOR 
62d1				endif 
62d1 cd 24 0d			call cmp16 
62d4 ca dd 62			jp z, .chk_fault4 
62d7 11 77 63			ld de, sfaultlo 
62da c3 f3 62			jp .chk_fault 
62dd			.chk_fault4:  
62dd 2a 08 f5			ld hl, (chk_data_ovr) 
62e0 ed 5b 8a ef		ld de,(chk_word) 
62e4				if DEBUG_STK_FAULT 
62e4					DMARK "FA3" 
62e4					CALLMONITOR 
62e4				endif 
62e4 cd 24 0d			call cmp16 
62e7 ca f0 62			jp z, .chk_fault5 
62ea 11 91 63			ld de, sfaultdo 
62ed c3 f3 62			jp .chk_fault 
62f0			 
62f0			 
62f0			.chk_fault5:  
62f0 d1				pop de 
62f1 e1				pop hl 
62f2			 
62f2 c9				ret 
62f3			 
62f3 cd d2 0a		.chk_fault: 	call clear_display 
62f6 3e 14				ld a, display_row_2 
62f8 cd e5 0a				call str_at_display 
62fb 11 21 63				   ld de, .stackfault 
62fe 3e 00				ld a, display_row_1 
6300 cd e5 0a				call str_at_display 
6303 11 bd fb				    ld de, debug_mark 
6306 3e 11				ld a, display_row_1+17 
6308 cd e5 0a				call str_at_display 
630b cd f5 0a				call update_display 
630e			 
630e				; prompt before entering montior for investigating issue 
630e			 
630e 3e 3c			ld a, display_row_4 
6310 11 14 19			ld de, endprog 
6313			 
6313 cd f5 0a			call update_display		 
6316			 
6316 cd 72 1b			call next_page_prompt 
6319			 
6319 d1				pop de 
631a e1				pop hl 
631b cd 68 19				call monitor 
631e c3 5f 18				jp warmstart 
6321					;jp 0 
6321					;halt 
6321			 
6321			 
6321			 
6321 .. 00		.stackfault: 	db "Stack fault:",0 
632e			 
632e .. 00		sfaultsu: 	db	"Stack under flow",0 
633f .. 00		sfaultso: 	db	"Stack over flow",0 
634f .. 00		sfaultru:	db "RTS underflow",0 
635d .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6377 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6391 .. 00		sfaultdo:	db "DTS overflow", 0 
639e			 
639e			 
639e			fault_dsp_under: 
639e 11 b0 63			ld de, .dsp_under 
63a1 c3 60 64			jp .show_fault 
63a4			 
63a4			fault_rsp_under: 
63a4 11 be 63			ld de, .rsp_under 
63a7 c3 60 64			jp .show_fault 
63aa			fault_loop_under: 
63aa 11 cc 63			ld de, .loop_under 
63ad c3 60 64			jp .show_fault 
63b0			 
63b0 .. 00		.dsp_under: db "DSP Underflow",0 
63be .. 00		.rsp_under: db "RSP Underflow",0 
63cc .. 00		.loop_under: db "LOOP Underflow",0 
63db			 
63db			 
63db d5			type_faultn: 	push de 
63dc e5					push hl 
63dd cd d2 0a				call clear_display 
63e0 11 07 64				   ld de, .typefaultn 
63e3 3e 00				ld a, display_row_1 
63e5 cd e5 0a				call str_at_display 
63e8 11 bd fb				    ld de, debug_mark 
63eb 3e 11				ld a, display_row_1+17 
63ed cd e5 0a				call str_at_display 
63f0 cd f5 0a				call update_display 
63f3			 
63f3				; prompt before entering montior for investigating issue 
63f3			 
63f3 3e 3c			ld a, display_row_4 
63f5 11 14 19			ld de, endprog 
63f8			 
63f8 cd f5 0a			call update_display		 
63fb			 
63fb cd 72 1b			call next_page_prompt 
63fe			 
63fe e5					push hl 
63ff d5					push de 
6400 cd 68 19				call monitor 
6403 c3 5f 18				jp warmstart 
6406 76					halt 
6407			 
6407			 
6407 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
641e			 
641e d5			type_faults: 	push de 
641f e5					push hl 
6420 cd d2 0a				call clear_display 
6423 11 49 64				   ld de, .typefaults 
6426 3e 00				ld a, display_row_1 
6428 cd e5 0a				call str_at_display 
642b 11 bd fb				    ld de, debug_mark 
642e 3e 11				ld a, display_row_1+17 
6430 cd e5 0a				call str_at_display 
6433 cd f5 0a				call update_display 
6436			 
6436				; prompt before entering montior for investigating issue 
6436			 
6436 3e 3c			ld a, display_row_4 
6438 11 14 19			ld de, endprog 
643b			 
643b cd f5 0a			call update_display		 
643e			 
643e cd 72 1b			call next_page_prompt 
6441			 
6441 e1					pop hl 
6442 d1					pop de 
6443 cd 68 19				call monitor 
6446 c3 5f 18				jp warmstart 
6449			 
6449			 
6449 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6460			 
6460			.show_fault: 	 
6460 d5					push de 
6461 cd d2 0a				call clear_display 
6464 d1					pop de 
6465 3e 00				ld a, display_row_1 
6467 cd e5 0a				call str_at_display 
646a 11 bd fb				    ld de, debug_mark 
646d 3e 11				ld a, display_row_1+17 
646f cd e5 0a				call str_at_display 
6472 cd f5 0a				call update_display 
6475			 
6475				; prompt before entering montior for investigating issue 
6475			 
6475 3e 3c			ld a, display_row_4 
6477 11 14 19			ld de, endprog 
647a			 
647a cd f5 0a			call update_display		 
647d			 
647d cd 72 1b			call next_page_prompt 
6480			 
6480 e1					pop hl 
6481 d1					pop de 
6482 cd 68 19				call monitor 
6485			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6485			; TODO Make optional fault restart to cli or warm boot? 
6485					;jp warmstart 
6485 c3 ba 18				jp cli 
6488 76					halt 
6489			 
6489			; handle the auto run of code from files in storage 
6489			 
6489			 
6489			if STORAGE_SE 
6489			 
6489 .. 00		sprompt3: db "Loading from start-up file:",0 
64a5			 
64a5			 
64a5			forth_autoload: 
64a5			 
64a5				; load block 0 of store 1 
64a5				 
64a5 3e fe			ld a, $fe      ; bit 0 clear 
64a7 32 ce f9			ld (spi_device), a 
64aa			 
64aa cd ba 03			call storage_get_block_0 
64ad			 
64ad 3a 09 fa			ld a, (store_page+STORE_0_AUTOFILE) 
64b0			 
64b0 fe 00			cp 0 
64b2 c8				ret z     ; auto start not enabled 
64b3			 
64b3 cd d2 0a			call clear_display 
64b6			 
64b6				; set bank 
64b6			 
64b6 3a 0b fa				ld a, (store_page+STORE_0_BANKRUN) 
64b9 32 ce f9				ld (spi_device), a 
64bc			 
64bc				; get file id to load from and get the file name to display 
64bc			 
64bc 3a 09 fa				ld a, (store_page+STORE_0_AUTOFILE) 
64bf			 
64bf 2e 00				ld l, 0 
64c1 67					ld h, a 
64c2 11 e8 f9				ld de, store_page 
64c5			 
64c5 cd 4e 08				call storage_read 
64c8			 
64c8 cd 2f 0d				call ishlzero 
64cb c8					ret z             ; file not found 
64cc			 
64cc 3e 32				ld a, display_row_3 + 10 
64ce 11 eb f9				ld de, store_page+3 
64d1 cd e5 0a				call str_at_display 
64d4				 
64d4			; 
64d4			 
64d4 3e 19			ld a, display_row_2+5 
64d6 11 89 64			ld de, sprompt3 
64d9 cd e5 0a			call str_at_display 
64dc			 
64dc cd f5 0a			call update_display 
64df			 
64df			 
64df cd 52 0a			call delay1s 
64e2			 
64e2 c9				ret 
64e3			 
64e3			 
64e3			 
64e3			endif 
64e3			 
64e3			 
64e3			; eof 
# End of file forth_kernel.asm
64e3			;include "nascombasic.asm" 
64e3			 
64e3			 
64e3			; find out where the code ends if loaded into RAM (for SC114) 
64e3			;endofcode:  
64e3			;	nop 
64e3			 
64e3			 
64e3			; eof 
64e3			 
# End of file main.asm
64e3			include "firmware_lcd_4x20.asm" 
64e3			; **********************************************************************  
64e3			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
64e3			; **********************************************************************  
64e3			;  
64e3			; **  Written as a Small Computer Monitor App  
64e3			; **  www.scc.me.uk  
64e3			;  
64e3			; History  
64e3			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
64e3			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
64e3			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
64e3			;  
64e3			; **********************************************************************  
64e3			;  
64e3			; This program is an example of one of the methods of interfacing an   
64e3			; alphanumeric LCD module.   
64e3			;  
64e3			; In this example the display is connected to either a Z80 PIO or a   
64e3			; simple 8-bit output port.   
64e3			;  
64e3			; This interfacing method uses 4-bit data mode and uses time delays  
64e3			; rather than polling the display's ready status. As a result the   
64e3			; interface only requires 6 simple output lines:  
64e3			;   Output bit 0 = not used  
64e3			;   Output bit 1 = not used  
64e3			;   Output bit 2 = RS         High = data, Low = instruction  
64e3			;   Output bit 3 = E          Active high  
64e3			;   Output bit 4 = DB4  
64e3			;   Output bit 5 = DB5  
64e3			;   Output bit 6 = DB6  
64e3			;   Output bit 7 = DB7  
64e3			; Display's R/W is connected to 0v so it is always in write mode  
64e3			;  
64e3			; This set up should work with any system supporting the RC2014 bus  
64e3			  
64e3			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
64e3			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
64e3			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
64e3			;  
64e3			; **********************************************************************  
64e3			  
64e3			; **********************************************************************  
64e3			; **  Constants  
64e3			; **********************************************************************  
64e3			; LCD constants required by LCD support module  
64e3			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
64e3			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
64e3			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
64e3			kLCDWidth:  EQU display_cols             ;Width in characters  
64e3			  
64e3			; **********************************************************************  
64e3			; **  Code library usage  
64e3			; **********************************************************************  
64e3			  
64e3			; send character to current cursor position  
64e3			; wraps and/or scrolls screen automatically  
64e3			  
64e3			  
64e3			lcd_init:  
64e3			  
64e3			; SCMonAPI functions used  
64e3			  
64e3			; Alphanumeric LCD functions used  
64e3			; no need to specify specific functions for this module  
64e3			  
64e3 3e cf		            LD   A, 11001111b  
64e5 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
64e7 3e 00		            LD   A, 00000000b  
64e9 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
64eb			  
64eb			; Initialise alphanumeric LCD module  
64eb cd 64 65		            CALL fLCD_Init      ;Initialise LCD module  
64ee			  
64ee c9				ret  
64ef			  
64ef			;  
64ef			;;  
64ef			; lcd functions  
64ef			;  
64ef			;  
64ef			  
64ef			; what is at cursor position   
64ef			  
64ef			;get_cursor:	ld de, (cursor_row)   ;  row + col  
64ef			;		call curptr  
64ef			;		ret  
64ef			  
64ef			  
64ef			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
64ef			  
64ef			curptr:  
64ef c5				push bc  
64f0 21 53 fb			ld hl, display_fb0  
64f3			cpr:	  
64f3				; loop for cursor whole row  
64f3 0e 14			ld c, display_cols  
64f5 23			cpr1:	inc hl  
64f6 0d				dec c  
64f7 20 fc			jr nz, cpr1  
64f9 05				dec b  
64fa 20 f7			jr nz, cpr  
64fc			  
64fc				; add col	  
64fc			  
64fc 23			cpr2:	inc hl  
64fd 1d				dec e  
64fe 20 fc			jr nz, cpr2  
6500			  
6500 c1				pop bc  
6501 c9				ret  
6502				  
6502			  
6502			  
6502			  
6502			  
6502			; write the frame buffer given in hl to hardware   
6502 22 5b fa		write_display: ld (display_write_tmp), hl 	   
6505 3e 00			ld a, kLCD_Line1  
6507 cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
650a 06 14			ld b, display_cols  
650c ed 5b 5b fa		ld de, (display_write_tmp)  
6510 cd 5c 65			call write_len_string  
6513				  
6513				  
6513 2a 5b fa			ld hl, (display_write_tmp)  
6516 11 14 00			ld de, display_cols  
6519 19				add hl,de  
651a 22 5b fa			ld (display_write_tmp),hl  
651d			  
651d				  
651d 3e 40			ld a, kLCD_Line2  
651f cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6522 06 14			ld b, display_cols  
6524 ed 5b 5b fa		ld de, (display_write_tmp)  
6528 cd 5c 65			call write_len_string  
652b				  
652b 2a 5b fa			ld hl, (display_write_tmp)  
652e 11 14 00			ld de, display_cols  
6531 19				add hl,de  
6532 22 5b fa			ld (display_write_tmp),hl  
6535			  
6535				  
6535 3e 14			ld a, kLCD_Line3  
6537 cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
653a 06 14			ld b, display_cols  
653c ed 5b 5b fa		ld de, (display_write_tmp)  
6540 cd 5c 65			call write_len_string  
6543				  
6543 2a 5b fa			ld hl, (display_write_tmp)  
6546 11 14 00			ld de, display_cols  
6549 19				add hl,de  
654a 22 5b fa			ld (display_write_tmp),hl  
654d			  
654d				  
654d 3e 54			ld a, kLCD_Line4  
654f cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6552 06 14			ld b, display_cols  
6554 ed 5b 5b fa		ld de, (display_write_tmp)  
6558 cd 5c 65			call write_len_string  
655b c9					ret  
655c				  
655c				; write out a fixed length string given in b from de  
655c			  
655c 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
655d cd ae 65		            CALL fLCD_Data      ;Write character to display  
6560 13				inc de  
6561 10 f9			djnz write_len_string  
6563 c9				ret  
6564			  
6564			; Some other things to do  
6564			;            LD   A, kLCD_Clear ;Display clear  
6564			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6564			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6564			;            LD   A, kLCD_On     ;Display on with no cursor  
6564			;            ;LD   A, kLCD_Off   ;Display off  
6564			;            CALL fLCD_Inst      ;Send instruction to display  
6564			;  
6564			;  
6564			;            halt  
6564			;  
6564			;  
6564			;MsgHello:   DB  "Hello World!",0  
6564			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6564			  
6564			; Custom characters 5 pixels wide by 8 pixels high  
6564			; Up to 8 custom characters can be defined  
6564			;BitMaps:      
6564			;; Character 0x00 = Battery icon  
6564			;            DB  01110b  
6564			;            DB  11011b  
6564			;            DB  10001b  
6564			;            DB  10001b  
6564			;            DB  11111b  
6564			;            DB  11111b  
6564			;            DB  11111b  
6564			;            DB  11111b  
6564			;; Character 0x01 = Bluetooth icon  
6564			;            DB  01100b  
6564			;            DB  01010b  
6564			;            DB  11100b  
6564			;            DB  01000b  
6564			;            DB  11100b  
6564			;            DB  01010b  
6564			;            DB  01100b  
6564			;            DB  00000b  
6564			;  
6564			  
6564			  
6564			; **********************************************************************  
6564			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6564			; **********************************************************************  
6564			;  
6564			; **  Written as a Small Computer Monitor App   
6564			; **  Version 0.1 SCC 2018-05-16  
6564			; **  www.scc.me.uk  
6564			;  
6564			; **********************************************************************  
6564			;  
6564			; This module provides support for alphanumeric LCD modules using with  
6564			; *  HD44780 (or compatible) controller  
6564			; *  5 x 7 pixel fonts  
6564			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6564			; *  Interface via six digital outputs to the display (see below)  
6564			;  
6564			; LCD module pinout:  
6564			;   1  Vss   0v supply  
6564			;   2  Vdd   5v supply  
6564			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6564			;   4  RS    High = data, Low = instruction  
6564			;   5  R/W   High = Read, Low = Write  
6564			;   6  E     Enable signal (active high)  
6564			;   7  DB0   Data bit 0  
6564			;   8  DB1   Data bit 1  
6564			;   9  DB2   Data bit 2  
6564			;  10  DB3   Data bit 3  
6564			;  11  DB4   Data bit 4  
6564			;  12  DB5   Data bit 5  
6564			;  13  DB6   Data bit 6  
6564			;  14  DB7   Data bit 7  
6564			;  15  A     Backlight anode (+)  
6564			;  16  K     Backlight cathode (-)  
6564			;  
6564			; This interfacing method uses 4-bit data mode and uses time delays  
6564			; rather than polling the display's ready status. As a result the   
6564			; interface only requires 6 simple output lines:  
6564			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6564			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6564			;   LCD DB4 = Microcomputer output port bit 4  
6564			;   LCD DB5 = Microcomputer output port bit 5  
6564			;   LCD DB6 = Microcomputer output port bit 6  
6564			;   LCD DB7 = Microcomputer output port bit 7  
6564			; Display's R/W is connected to 0v so it is always in write mode  
6564			; All 6 connections must be on the same port address <kLCDPrt>  
6564			; This method also allows a decent length of cable from micro to LCD  
6564			;  
6564			; **********************************************************************  
6564			;  
6564			; To include the code for any given function provided by this module,   
6564			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6564			; the parent source file.  
6564			; For example:  #REQUIRES   uHexPrefix  
6564			;  
6564			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6564			; in the parent source file.  
6564			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6564			;  
6564			; These are the function names provided by this module:  
6564			; fLCD_Init                     ;Initialise LCD  
6564			; fLCD_Inst                     ;Send instruction to LCD  
6564			; fLCD_Data                     ;Send data byte to LCD  
6564			; fLCD_Pos                      ;Position cursor  
6564			; fLCD_Str                      ;Display string  
6564			; fLCD_Def                      ;Define custom character  
6564			;  
6564			; **********************************************************************  
6564			;  
6564			; Requires SCMonAPI.asm to also be included in the project  
6564			;  
6564			  
6564			  
6564			; **********************************************************************  
6564			; **  Constants  
6564			; **********************************************************************  
6564			  
6564			; Constants that must be defined externally  
6564			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6564			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6564			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6564			;kLCDWidth: EQU 20             ;Width in characters  
6564			  
6564			; general line offsets in any frame buffer  
6564			  
6564			  
6564			display_row_1: equ 0  
6564			display_row_2: equ display_row_1+display_cols  
6564			display_row_3: equ display_row_2 + display_cols  
6564			display_row_4: equ display_row_3 + display_cols  
6564			;display_row_4_eol:   
6564			  
6564			  
6564			; Cursor position values for the start of each line  
6564			kLCD_Line1: EQU 0x00   
6564			kLCD_Line2: EQU 0x40    
6564			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6564			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6564			  
6564			; Instructions to send as A register to fLCD_Inst  
6564			kLCD_Clear: EQU 00000001b     ;LCD clear  
6564			kLCD_Off:   EQU 00001000b     ;LCD off  
6564			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6564			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6564			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6564			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6564			  
6564			; Constants used by this code module  
6564			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6564			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6564			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6564			  
6564			  
6564			  
6564			; **********************************************************************  
6564			; **  LCD support functions  
6564			; **********************************************************************  
6564			  
6564			; Initialise alphanumeric LCD module  
6564			; LCD control register codes:  
6564			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6564			;   N    0 = 1-line mode       1 = 2-line mode  
6564			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6564			;   D    0 = Display off       1 = Display on  
6564			;   C    0 = Cursor off        1 = Cursor on  
6564			;   B    0 = Blinking off      1 = Blinking on  
6564			;   ID   0 = Decrement mode    1 = Increment mode  
6564			;   SH   0 = Entire shift off  1 = Entire shift on  
6564 3e 28		fLCD_Init:  LD   A, 40  
6566 cd 1b 66		            CALL LCDDelay       ;Delay 40ms after power up  
6569			; For reliable reset set 8-bit mode - 3 times  
6569 cd 05 66		            CALL WrFn8bit       ;Function = 8-bit mode  
656c cd 05 66		            CALL WrFn8bit       ;Function = 8-bit mode  
656f cd 05 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6572			; Set 4-bit mode  
6572 cd 01 66		            CALL WrFn4bit       ;Function = 4-bit mode  
6575 cd 19 66		            CALL LCDDelay1      ;Delay 37 us or more  
6578			; Function set  
6578 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
657a cd 8d 65		            CALL fLCD_Inst      ;2 line, display on  
657d			; Display On/Off control  
657d 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
657f cd 8d 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6582			; Display Clear  
6582 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6584 cd 8d 65		            CALL fLCD_Inst      ;Clear display  
6587			; Entry mode  
6587 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6589 cd 8d 65		            CALL fLCD_Inst      ;Increment mode, shift off  
658c			; Display module now initialised  
658c c9			            RET  
658d			; ok to here  
658d			  
658d			; Write instruction to LCD  
658d			;   On entry: A = Instruction byte to be written  
658d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
658d f5			fLCD_Inst:  PUSH AF  
658e f5			            PUSH AF  
658f cd a1 65		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6592 f1			            POP  AF  
6593 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6594 17			            RLA  
6595 17			            RLA  
6596 17			            RLA  
6597 cd a1 65		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
659a 3e 02		            LD   A, 2  
659c cd 1b 66		            CALL LCDDelay       ;Delay 2 ms to complete   
659f f1			            POP  AF  
65a0 c9			            RET  
65a1 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
65a3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65a5 cb df		            SET  kLCDBitE, A  
65a7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65a9 cb 9f		            RES  kLCDBitE, A  
65ab d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65ad c9			            RET  
65ae			  
65ae			  
65ae			; Write data to LCD  
65ae			;   On entry: A = Data byte to be written  
65ae			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65ae f5			fLCD_Data:  PUSH AF  
65af f5			            PUSH AF  
65b0 cd c2 65		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
65b3 f1			            POP  AF  
65b4 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
65b5 17			            RLA  
65b6 17			            RLA  
65b7 17			            RLA  
65b8 cd c2 65		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
65bb 3e 96		            LD   A, 150  
65bd 3d			Wait:      DEC  A              ;Wait a while to allow data   
65be 20 fd		            JR   NZ, Wait      ;  write to complete  
65c0 f1			            POP  AF  
65c1 c9			            RET  
65c2 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
65c4 cb d7		            SET  kLCDBitRS, A  
65c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65c8 cb df		            SET  kLCDBitE, A  
65ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
65cc cb 9f		            RES  kLCDBitE, A  
65ce d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65d0 cb 97		            RES  kLCDBitRS, A  
65d2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65d4 c9			            RET  
65d5			  
65d5			  
65d5			; Position cursor to specified location  
65d5			;   On entry: A = Cursor position  
65d5			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65d5 f5			fLCD_Pos:   PUSH AF  
65d6 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
65d8 cd 8d 65		            CALL fLCD_Inst      ;Write instruction to LCD  
65db f1			            POP  AF  
65dc c9			            RET  
65dd			  
65dd			  
65dd			; Output text string to LCD  
65dd			;   On entry: DE = Pointer to null terminated text string  
65dd			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
65dd 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
65de b7			            OR   A              ;Null terminator?  
65df c8			            RET  Z              ;Yes, so finished  
65e0 cd ae 65		            CALL fLCD_Data      ;Write character to display  
65e3 13			            INC  DE             ;Point to next character  
65e4 18 f7		            JR   fLCD_Str       ;Repeat  
65e6 c9					ret  
65e7			  
65e7			; Define custom character  
65e7			;   On entry: A = Character number (0 to 7)  
65e7			;             DE = Pointer to character bitmap data  
65e7			;   On exit:  A = Next character number  
65e7			;             DE = Next location following bitmap  
65e7			;             BC HL IX IY I AF' BC' DE' HL' preserved  
65e7			; Character is   
65e7 c5			fLCD_Def:   PUSH BC  
65e8 f5			            PUSH AF  
65e9 07			            RLCA                ;Calculate location  
65ea 07			            RLCA                ;  for bitmap data  
65eb 07			            RLCA                ;  = 8 x CharacterNumber  
65ec f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
65ee cd 8d 65		            CALL fLCD_Inst      ;Write instruction to LCD  
65f1 06 00		            LD   B, 0  
65f3 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
65f4 cd ae 65		            CALL fLCD_Data      ;Write byte to display  
65f7 13			            INC  DE             ;Point to next byte  
65f8 04			            INC  B              ;Count bytes  
65f9 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
65fb 28 f6		            JR   Z, Loop       ;No, so repeat  
65fd f1			            POP  AF  
65fe 3c			            INC  A              ;Increment character number  
65ff c1			            POP  BC  
6600 c9			            RET  
6601			  
6601			  
6601			; **********************************************************************  
6601			; **  Private functions  
6601			; **********************************************************************  
6601			  
6601			; Write function to LCD  
6601			;   On entry: A = Function byte to be written  
6601			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6601 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6603 18 02		            JR   WrFunc  
6605 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6607 f5			WrFunc:     PUSH AF  
6608 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
660a cb df		            SET  kLCDBitE, A  
660c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
660e cb 9f		            RES  kLCDBitE, A  
6610 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6612 3e 05		            LD   A, 5  
6614 cd 1b 66		            CALL LCDDelay       ;Delay 5 ms to complete  
6617 f1			            POP  AF  
6618 c9			            RET  
6619			  
6619			  
6619			; Delay in milliseconds  
6619			;   On entry: A = Number of milliseconds delay  
6619			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6619 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
661b d5			LCDDelay:   PUSH DE  
661c 5f			            LD   E, A           ;Delay by 'A' ms  
661d 16 00		            LD   D, 0  
661f cd 37 0a		            CALL aDelayInMS  
6622 d1			            POP  DE  
6623 c9			            RET  
6624			  
6624			  
6624			  
6624			  
6624			; eof  
6624			  
# End of file firmware_lcd_4x20.asm
6624			include "firmware_key_4x4.asm" 
6624			  
6624			  
6624			; bit mask for each scan column and row for teing the matrix  
6624			  
6624			; out   
6624 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
6628			; in  
6628 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
662c			  
662c			; row/col to character map  
662c			  
662c			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
662c			;    
662c			  
662c			; physical key matrix map to face of key  
662c			  
662c			  
662c			;      	1	2	3	A  
662c			;   	abc”	def&	ghi$	s1  
662c			;			  
662c			;	4	5	6	B  
662c			; 	jkl,	mno.	pqr:	s2  
662c			;			  
662c			; 	7	8	9	C  
662c			;	stu;	vwx@	yz?!	s3  
662c			;			  
662c			; 	*	0	#	D  
662c			; 	shift lck '	Space < >	Enter ( )	s4  
662c			;       tab bs 		  
662c			  
662c			  
662c			  
662c			  
662c			key_init:  
662c			  
662c			; SCMonAPI functions used  
662c			  
662c			; Alphanumeric LCD functions used  
662c			; no need to specify specific functions for this module  
662c			  
662c			  
662c 3e cf		            LD   A, 11001111b  
662e d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6630			;            LD   A, 00000000b  
6630 3e 0f		            LD   A, 00001111b  
6632 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6634			  
6634			  
6634				; TODO Configure cursor shapes  
6634			  
6634				; Load cursor shapes   
6634 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6636 11 46 66		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6639 06 02		            LD   B, 2           ;Number of characters to define  
663b cd e7 65		.DefLoop:   CALL fLCD_Def       ;Define custom character  
663e 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6640			  
6640 3e 01				ld a, 1  
6642 32 56 fa			ld (cursor_shape),a  
6645 c9				ret  
6646			  
6646			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6646			; Up to 8 custom characters can be defined  
6646			.cursor_shapes:      
6646			;; Character 0x00 = Normal  
6646 1f			            DB  11111b  
6647 1f			            DB  11111b  
6648 1f			            DB  11111b  
6649 1f			            DB  11111b  
664a 1f			            DB  11111b  
664b 1f			            DB  11111b  
664c 1f			            DB  11111b  
664d 1f			            DB  11111b  
664e			;; Character 0x01 = Modifier  
664e 1f			            DB  11111b  
664f 1b			            DB  11011b  
6650 1b			            DB  11011b  
6651 1b			            DB  11011b  
6652 1b			            DB  11011b  
6653 1f			            DB  11111b  
6654 1b			            DB  11011b  
6655 1f			            DB  11111b  
6656			  
6656			  
6656			  
6656			  
6656			; Display custom character 0  
6656			;            LD   A, kLCD_Line1+14  
6656			;            CALL fLCD_Pos       ;Position cursor to location in A  
6656			;            LD   A, 0  
6656			;            CALL fLCD_Data      ;Write character in A at cursor  
6656			  
6656			; Display custom character 1  
6656			;            LD   A, kLCD_Line2+14  
6656			;            CALL fLCD_Pos      ;Position cursor to location in A  
6656			;            LD   A, 1  
6656			;            CALL fLCD_Data     ;Write character in A at cursor  
6656			  
6656			; keyboard scanning   
6656			  
6656			  
6656			; key_rows: equ 4  
6656			; key_cols: equ 4  
6656			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6656			  
6656			; key_scanr: equ key_row_bitmask  
6656			; key_scanc: equ key_col_bitmask  
6656			  
6656			; key_char_map: equ key_map  
6656			  
6656			  
6656			  
6656			; character in from keyboard  
6656			  
6656 ..			.matrix_to_char: db "D#0*C987B654A321"  
6666			  
6666			  
6666			; map the physical key to a char dependant on state  
6666			  
6666			.key_map_fa:   
6666			  
6666 ..					db 'D'  
6667 0d					db KEY_CR    ; cr  
6668 ..					db ' '  
6669 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
666a ..					db 'C'  
666b ..					db 'y'  
666c ..					db 'v'  
666d ..					db 's'  
666e ..					db 'B'  
666f ..					db 'p'  
6670 ..					db 'm'  
6671 ..					db 'j'  
6672 ..					db 'A'  
6673 ..					db 'g'  
6674 ..					db 'd'  
6675 ..					db 'a'  
6676			  
6676			.key_map_fb:  
6676			  
6676 ..					db 'A'  
6677 ..					db '+'   
6678 ..					db '<'  
6679 ..					db  "'"    
667a			  
667a ..					db 'A'  
667b ..					db 'z'  
667c ..					db 'w'  
667d ..					db 't'  
667e ..					db 'A'  
667f ..					db 'q'  
6680 ..					db 'n'  
6681 ..					db 'k'  
6682 ..					db 'A'  
6683 ..					db 'h'  
6684 ..					db 'e'  
6685 ..			 		db 'b'  
6686			  
6686			.key_map_fc:   
6686			  
6686			  
6686 ..					db 'A'  
6687 ..					db '-'   
6688 ..					db '>'  
6689 ..					db  '='   	  
668a ..					db 'A'  
668b ..					db '?'  
668c ..					db 'x'  
668d ..					db 'u'  
668e ..					db 'A'  
668f ..					db 'r'  
6690 ..					db 'o'  
6691 ..					db 'l'  
6692 ..					db 'A'  
6693 ..					db 'i'  
6694 ..					db 'f'  
6695 ..					db 'c'  
6696			  
6696				  
6696			.key_map_fd:  
6696			  
6696 ..					db 'A'  
6697 ..					db '/'   
6698 ..					db '%'   
6699 08					db KEY_BS  ; back space  
669a ..					db 'A'  
669b ..					db '!'  
669c ..					db '@'  
669d ..					db ';'  
669e ..					db 'A'  
669f ..					db ':'  
66a0 ..					db '.'  
66a1 ..					db ','  
66a2 ..					db 'A'  
66a3 ..					db '$'  
66a4 ..					db '&'  
66a5 ..				 	db '"'  
66a6			  
66a6					  
66a6				  
66a6			  
66a6			; add cin and cin_wait  
66a6			  
66a6 cd b7 66		cin_wait: 	call cin  
66a9 fe 00			cp 0  
66ab 28 f9			jr z, cin_wait   ; block until key press  
66ad			  
66ad f5				push af   ; save key pressed  
66ae			  
66ae cd b7 66		.cin_wait1:	call cin  
66b1 fe 00			cp 0  
66b3 20 f9			jr nz, .cin_wait1  	; wait for key release  
66b5			  
66b5 f1				pop af   ; get key  
66b6 c9				ret  
66b7			  
66b7			  
66b7 cd c8 66		cin: 	call .mtoc  
66ba			  
66ba				; no key held  
66ba fe 00			cp 0  
66bc c8				ret z  
66bd			  
66bd				; stop key bounce  
66bd			  
66bd			;	ld (key_held),a		 ; save it  
66bd 47				ld b, a  
66be			  
66be c5			.cina1:	push bc  
66bf cd c8 66			call .mtoc  
66c2 c1				pop bc  
66c3 b8				cp b  
66c4 28 f8			jr z, .cina1  
66c6 78				ld a,b		  
66c7 c9				ret  
66c8			  
66c8			; detect keyboard modifier key press and apply new overlay to the face key held  
66c8			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
66c8			  
66c8			;.cin_map_modifier:   
66c8			;	ld a, (hl)  
66c8			;	and 255  
66c8			;	ret NZ		; modifier key not flagged  
66c8			;  
66c8			;	; get key face  
66c8			;  
66c8			;	ld b,(key_face_held)  
66c8			;  
66c8			;	ld b, key_cols * key_rows  
66c8			;  
66c8			;	push de  
66c8			;	pop hl  
66c8			;  
66c8			;.mmod1: ld a,(hl)   ; get map test  
66c8			;	cp b  
66c8			;	jr z, .mmod2  
66c8			;  
66c8			;  
66c8			;  
66c8			;.mmod2: inc hl    ;   
66c8			;  
66c8			;	  
66c8			;  
66c8			;	  
66c8			;  
66c8			;	ld hl,key_actual_pressed  
66c8			;	ld (hl),a,  
66c8			;	ret  
66c8			  
66c8				  
66c8			  
66c8			; map matrix key held to char on face of key  
66c8			  
66c8			.mtoc:  
66c8			  
66c8			  
66c8				; TODO optimise the code....  
66c8			  
66c8			; scan keyboard row 1  
66c8 3e 80			ld a, 128  
66ca 21 d3 fb			ld hl, keyscan_table  
66cd cd af 67			call .rowscan  
66d0			  
66d0				   
66d0			  
66d0 3e 40			ld a, 64  
66d2 21 d7 fb			ld hl, keyscan_table+key_cols  
66d5 cd af 67			call .rowscan  
66d8			  
66d8			  
66d8			  
66d8			  
66d8 3e 20			ld a, 32  
66da 21 db fb			ld hl, keyscan_table+(key_cols*2)  
66dd cd af 67			call .rowscan  
66e0			  
66e0			  
66e0			  
66e0 3e 10			ld a, 16  
66e2 21 df fb			ld hl, keyscan_table+(key_cols*3)  
66e5 cd af 67			call .rowscan  
66e8			  
66e8			  
66e8				; flag if key D is held down and remove from reporting  
66e8 01 96 66			ld bc, .key_map_fd    
66eb 21 d3 fb			ld hl, keyscan_table  
66ee 11 c5 fb			ld de, key_fd  
66f1 cd 41 67			call .key_shift_hold  
66f4 fe ff			cp 255  
66f6 28 33			jr z, .cinmap  
66f8				; flag if key C is held down and remove from reporting  
66f8 01 86 66			ld bc, .key_map_fc    
66fb 21 d7 fb			ld hl, keyscan_table+key_cols  
66fe 11 c6 fb			ld de, key_fc  
6701 cd 41 67			call .key_shift_hold  
6704 fe ff			cp 255  
6706 28 23			jr z, .cinmap  
6708				; flag if key B is held down and remove from reporting  
6708 01 76 66			ld bc, .key_map_fb    
670b 21 db fb			ld hl, keyscan_table+(key_cols*2)  
670e 11 c7 fb			ld de, key_fb  
6711 cd 41 67			call .key_shift_hold  
6714 fe ff			cp 255  
6716 28 13			jr z, .cinmap  
6718				; flag if key A is held down and remove from reporting  
6718 01 66 66			ld bc, .key_map_fa    
671b 21 df fb			ld hl, keyscan_table+(key_cols*3)  
671e 11 c8 fb			ld de, key_fa  
6721 cd 41 67			call .key_shift_hold  
6724 fe ff			cp 255  
6726 28 03			jr z, .cinmap  
6728			  
6728 11 56 66			ld de, .matrix_to_char  
672b			  
672b			  
672b			.cinmap:   
672b				if DEBUG_KEY  
672b			            LD   A, kLCD_Line4  
672b			            CALL fLCD_Pos       ;Position cursor to location in A  
672b					push de  
672b			            LD   DE, keyscan_table  
672b			            CALL fLCD_Str       ;Display string pointed to by DE  
672b					pop de  
672b				endif  
672b			  
672b				; scan key matrix table for any held key  
672b			  
672b				; de holds either the default matrix or one selected above  
672b			  
672b 21 d3 fb			ld hl, keyscan_table  
672e 06 10			ld b,key_cols*key_rows  
6730			  
6730 7e			.cin1:	ld a,(hl)  
6731 fe 23			cp '#'  
6733 28 08			jr z, .cinhit  
6735 23				inc hl  
6736 13				inc de  
6737 05				dec b  
6738 20 f6			jr nz, .cin1  
673a				; no key found held  
673a 3e 00			ld a,0  
673c c9				ret  
673d d5			.cinhit: push de  
673e e1				pop hl  
673f 7e				ld a,(hl)  
6740 c9				ret  
6741			  
6741			; flag a control key is held   
6741			; hl is key pin, de is flag indicator  
6741			  
6741			.key_shift_hold:  
6741 c5				push bc  
6742 3e 01			ld a, 1  
6744 32 56 fa			ld (cursor_shape),a  
6747 06 00			ld b, 0  
6749 7e				ld a, (hl)  
674a fe 2e			cp '.'  
674c 28 0a			jr z, .key_shift1  
674e 06 ff			ld b, 255  
6750 3e 2b			ld a, '+'    ; hide key from later scans  
6752 77				ld (hl),a  
6753 3e 02			ld a, 2  
6755 32 56 fa			ld (cursor_shape),a  
6758			.key_shift1:  
6758				; write flag indicator  
6758 78				ld a,b  
6759 12				ld (de),a  
675a			  
675a d1				pop de    ; de now holds the key map ptr  
675b c9				ret  
675c			  
675c				  
675c				  
675c			  
675c			  
675c			  
675c			  
675c			  
675c			  
675c			  
675c			  
675c			  
675c			  
675c c9				ret  
675d			  
675d			;	push hl  
675d			;	push de  
675d			;	push bc  
675d			;	call keyscan  
675d			;	; map key matrix to ascii value of key face  
675d			;  
675d			;	ld hl, key_face_map  
675d			;	ld de, keyscan_table  
675d			;  
675d			;	; get how many keys to look at  
675d			;	ld b, keyscan_table_len  
675d			;	  
675d			;  
675d			;	; at this stage fall out on first key hit  
675d			;	; TODO handle multiple key press  
675d			;  
675d			;map1:	ld a,(hl)  
675d			;	cp '#'  
675d			;	jr z, keyhit  
675d			;	inc hl  
675d			;	inc de  
675d			;	dec b  
675d			;	jr nz, map1  
675d			;nohit:	ld a, 0  
675d			;	jr keydone  
675d			;keyhit: push de  
675d			;	pop hl  
675d			;	ld a,(hl)  
675d			;keydone:  
675d			;	push bc  
675d			;	push de  
675d			; 	push hl  
675d			;	ret   
675d			;  
675d			  
675d			  
675d			  
675d			  
675d			; scan physical key matrix  
675d			  
675d			  
675d			;keyscan:  
675d			;  
675d			;; for each key_row use keyscanr bit mask for out  
675d			;; then read in for keyscanc bitmask  
675d			;; save result of row scan to keyscantable  
675d			;  
675d			;; scan keyboard row 1  
675d			;  
675d			;	ld b, key_rows  
675d			;	ld hl, key_scanr  
675d			;	ld de, keyscan_table  
675d			;  
675d			;rowloop:  
675d			;  
675d			;	ld a,(hl)		; out bit mask to energise keyboard row  
675d			;	call rowscan  
675d			;	inc hl  
675d			;	dec b  
675d			;	jr nz, rowloop  
675d			;  
675d			;	ret  
675d			;  
675d			;  
675d			;; pass a out bitmask, b row number  
675d			;arowscan:   
675d			;	push bc  
675d			;  
675d			;	ld d, b  
675d			;  
675d			;	; calculate buffer location for this row  
675d			;  
675d			;	ld hl, keyscan_table	  
675d			;kbufr:  ld e, key_cols  
675d			;kbufc:	inc hl  
675d			;	dec e  
675d			;	jr nz, kbufc  
675d			;	dec d  
675d			;	jr nz, kbufr  
675d			;  
675d			;	; energise row and read columns  
675d			;  
675d			;	out (portbdata),a  
675d			;	in a,(portbdata)  
675d			;	ld c,a  
675d			;  
675d			;  
675d			;	; save buffer loc  
675d			;  
675d			;	ld (keybufptr), hl  
675d			;  
675d			;	ld hl, key_scanc  
675d			;	ld d, key_cols  
675d			;  
675d			;	; for each column check each bit mask  
675d			;  
675d			;colloop:  
675d			;	  
675d			;  
675d			;	; reset flags for the row   
675d			;  
675d			;	ld b,'.'  
675d			;	and (hl)  
675d			;	jr z, maskskip  
675d			;	ld b,'#'  
675d			;maskskip:  
675d			;	; save  key state  
675d			;	push hl  
675d			;	ld hl, (keybufptr)  
675d			;	ld (hl), b  
675d			;	inc hl  
675d			;	ld (keybufptr), hl  
675d			;  
675d			;	; move to next bit mask  
675d			;	pop hl  
675d			;	inc hl  
675d			;  
675d			;	dec d  
675d			;	jr nz, colloop  
675d			;  
675d			;	ret  
675d			;  
675d			;  
675d			;;  
675d			; lcd functions  
675d			;  
675d			;  
675d			  
675d			;if DEBUG_KEY_MATRIX  
675d			  
675d			; test function to display hardware view of matrix state  
675d			  
675d			matrix:  
675d			  
675d			  
675d			  
675d			; scan keyboard row 1  
675d 3e 80			ld a, 128  
675f 21 f8 fb			ld hl, keyscan_table_row1  
6762 cd af 67			call .rowscan  
6765			  
6765 3e 40			ld a, 64  
6767 21 f3 fb			ld hl, keyscan_table_row2  
676a cd af 67			call .rowscan  
676d			  
676d 3e 20			ld a, 32  
676f 21 ee fb			ld hl, keyscan_table_row3  
6772 cd af 67			call .rowscan  
6775			  
6775 3e 10			ld a, 16  
6777 21 e9 fb			ld hl, keyscan_table_row4  
677a cd af 67			call .rowscan  
677d			  
677d			; Display text on first line  
677d 3e 00		            LD   A, kLCD_Line1  
677f cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6782 11 f8 fb		            LD   DE, keyscan_table_row1  
6785			            ;LD   DE, MsgHello  
6785 cd dd 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6788			  
6788			; Display text on second line  
6788 3e 40		            LD   A, kLCD_Line2  
678a cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
678d 11 f3 fb		            LD   DE, keyscan_table_row2  
6790 cd dd 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6793 3e 14		            LD   A, kLCD_Line3  
6795 cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6798 11 ee fb		            LD   DE, keyscan_table_row3  
679b cd dd 65		            CALL fLCD_Str       ;Display string pointed to by DE  
679e 3e 54		            LD   A, kLCD_Line4  
67a0 cd d5 65		            CALL fLCD_Pos       ;Position cursor to location in A  
67a3 11 e9 fb		            LD   DE, keyscan_table_row4  
67a6 cd dd 65		            CALL fLCD_Str       ;Display string pointed to by DE  
67a9			  
67a9 cd 46 0a			call delay250ms  
67ac c3 5d 67			jp matrix  
67af			  
67af			; pass de as row display flags  
67af			.rowscan:   
67af d3 c1			out (portbdata),a  
67b1 db c1			in a,(portbdata)  
67b3 4f				ld c,a  
67b4				; reset flags for the row   
67b4 06 2e			ld b,'.'  
67b6 e6 01			and 1  
67b8 28 02			jr z, .p1on  
67ba 06 23			ld b,'#'  
67bc			.p1on:  
67bc 70				ld (hl), b  
67bd 23				inc hl  
67be			  
67be 06 2e			ld b,'.'  
67c0 79				ld a,c  
67c1 e6 02			and 2  
67c3			;	bit 0,a  
67c3 28 02			jr z, .p2on  
67c5 06 23			ld b,'#'  
67c7			.p2on:  
67c7 70				ld (hl), b  
67c8 23				inc hl  
67c9			;  
67c9 06 2e			ld b,'.'  
67cb 79				ld a,c  
67cc e6 04			and 4  
67ce			;;	bit 0,a  
67ce 28 02			jr z, .p3on  
67d0 06 23			ld b,'#'  
67d2			.p3on:  
67d2 70				ld (hl), b  
67d3 23				inc hl  
67d4			;;  
67d4 06 2e			ld b,'.'  
67d6			;;	bit 0,a  
67d6 79				ld a,c  
67d7 e6 08			and 8  
67d9 28 02			jr z, .p4on  
67db 06 23			ld b,'#'  
67dd			.p4on:  
67dd 70				ld (hl), b  
67de 23				inc hl  
67df			  
67df			; zero term  
67df 06 00			ld b,0  
67e1 70				ld (hl), b  
67e2			  
67e2 c9			.rscandone: ret  
67e3			  
67e3			  
67e3			  
67e3			;endif  
67e3			  
67e3			  
67e3			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
67e3
