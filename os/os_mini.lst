# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 21 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 offsets for settings  
0003			  
0003			; if set then skip prompt for start up and accept all  
0003			  
0003			STORE_0_QUICKSTART: equ $25  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0003			  
0003			hardware_config: equ key_face_held - 10  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_config - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003				  
0003			  
0003					;ld a, 0  
0003					;ld (hardware_diag), a  
0003			  
0003					; clear all the buffers  
0003			  
0003 21 f9 fa				ld hl, display_fb1  
0006 22 55 fa				ld (display_fb_active), hl  
0009			  
0009 cd cd 0a				call clear_display  
000c			  
000c 21 57 fa				ld hl, display_fb2  
000f 22 55 fa				ld (display_fb_active), hl  
0012			  
0012 cd cd 0a				call clear_display  
0015			  
0015					; init primary frame buffer area  
0015 21 4a fb				ld hl, display_fb0  
0018 22 55 fa				ld (display_fb_active), hl  
001b			  
001b cd cd 0a				call clear_display  
001e			  
001e			  
001e cd 99 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0021			  
0021 cd e2 66			call key_init  
0024 cd 9f 01			call storage_init  
0027			  
0027				; setup malloc functions  
0027			  
0027				if MALLOC_1  
0027 cd a4 11				call  heap_init  
002a				endif  
002a				if MALLOC_4  
002a					call  heap_init  
002a				endif  
002a			  
002a				; init sound hardware if present  
002a			  
002a				if SOUND_ENABLE  
002a					call sound_init  
002a				endif  
002a			  
002a				; lcd test sequence  
002a					  
002a cd f0 0a			call update_display  
002d cd 4a 0a			call delay1s  
0030 3e 2b			ld a,'+'  
0032 cd d2 0a			call fill_display  
0035 cd f0 0a			call update_display  
0038 cd 4a 0a			call delay1s  
003b 3e 2a			ld a,'*'  
003d cd d2 0a			call fill_display  
0040 cd f0 0a			call update_display  
0043 cd 4a 0a			call delay1s  
0046 3e 2d			ld a,'-'  
0048 cd d2 0a			call fill_display  
004b cd f0 0a			call update_display  
004e cd 4a 0a			call delay1s  
0051			  
0051			; boot splash screen  
0051			if display_cols == 20	  
0051 3e 00		        ld a, display_row_1    
0053			else  
0053			        ld a, display_row_1 +10   
0053			endif  
0053 11 54 18			ld de, prom_bootmsg  
0056 cd e0 0a			call str_at_display  
0059 cd f0 0a			call update_display  
005c			  
005c			  
005c cd 4a 0a			call delay1s  
005f cd 4a 0a			call delay1s  
0062			if display_cols == 20	  
0062 3e 2a		            LD   A, display_row_3+2  
0064			else  
0064			            LD   A, display_row_3+12  
0064			endif  
0064 11 69 18			ld de, prom_bootmsg1  
0067 cd e0 0a			call str_at_display  
006a cd f0 0a			call update_display  
006d cd 4a 0a			call delay1s  
0070 cd 4a 0a			call delay1s  
0073			  
0073			;	ld a, display_row_4+3  
0073			;	ld de, bootmsg2  
0073			;	call str_at_display  
0073			;	call update_display  
0073			;	call delay1s  
0073			;	call delay1s  
0073			  
0073			; debug mark setup  
0073			  
0073 3e 5f		ld a, '_'  
0075 32 b4 fb		ld (debug_mark),a  
0078 32 b5 fb		ld (debug_mark+1),a  
007b 32 b6 fb		ld (debug_mark+2),a  
007e 3e 00		ld a,0  
0080 32 b7 fb		ld (debug_mark+3),a  
0083			  
0083 c9					ret  
0084			  
0084			  
0084			;bootmsg2:	db "Firmware v0.1",0  
0084			  
0084			; a 4x20 lcd  
0084			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
0084			  
0084			;if display_cols == 20  
0084			;	include "firmware_lcd_4x20.asm"  
0084			;endif  
0084			  
0084			;if display_cols == 40  
0084			;	include "firmware_lcd_4x40.asm"  
0084			;endif  
0084			  
0084			;  
0084			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
0084			; TODO abstract the bit bang video out interface for dual display  
0084			; TODO wire video out to tx pin on rc2014 bus  
0084			  
0084			; must supply cin, and cin_wait for low level hardware abstraction   
0084			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
0084			; test scancode  
0084			  
0084			;;;;;  
0084			;;;  
0084			; Moved out to mini and maxi versions  
0084			;  
0084			; include "firmware_key_4x4.asm"  
0084			; using existing 4 wire x 4 resistor array for input  
0084			;include "firmware_key_4x10.asm"  
0084			; need to mod the board for 5 rows due to resistor array  
0084			;include "firmware_key_5x10.asm"  
0084			  
0084			; storage hardware interface  
0084			  
0084			; use microchip serial eeprom for storage  
0084			  
0084			  
0084			if STORAGE_SE  
0084				include "firmware_spi.asm"  
0084			; my spi protocol (used by storage) 
0084			 
0084			; SPI pins 
0084			 
0084			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
0084			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
0084			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
0084			 
0084			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
0084			; chip pin 4 gnd 
0084			 
0084			 
0084			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
0084			SPI_CE1: equ 1      ;    port a1 pin 14  
0084			SPI_CE2: equ 2      ;    port a2 pin pin 13 
0084			SPI_CE3: equ 3      ; port    a3 pin pin 12 
0084			SPI_CE4: equ 4      ; port a4     pin 10 
0084			 
0084			; active low AND masks 
0084			 
0084			;SPI_CE0_MASK: equ    255-1 
0084			;SPI_CE1_MASK: equ   255-2 
0084			;SPI_CE2_MASK: equ   255-4 
0084			;SPI_CE3_MASK: equ   255-8 
0084			;SPI_CE4_MASK: equ   255-16 
0084			SPI_CE_HIGH:  equ 255 
0084			 
0084			 
0084			 
0084			 
0084			; TODO store port id for spi device ie dev c 
0084			; TODO store pin for SO 
0084			; TODO store pin for SI 
0084			; TODO store pin for SCLK 
0084			 
0084			; 
0084			 
0084			; ensure that spi bus is in a stable state with default pins  
0084			 
0084			se_stable_spi:   
0084			 
0084				 ; set DI high, CE high , SCLK low 
0084				;ld a, SPI_DI | SPI_CE0 
0084 3e 07			ld a, SPI_DI  
0086 cd 5a 01			call spi_ce_high 
0089 d3 80			 out (storage_adata),a 
008b 32 c6 f9			ld (spi_portbyte),a 
008e			 
008e				if DEBUG_SPI 
008e					push hl 
008e					ld l, a 
008e					DMARK "SPI" 
008e					CALLMONITOR 
008e					pop hl 
008e				endif 
008e c9				ret 
008f			 
008f			; byte to send in a 
008f			 
008f			spi_send_byte: 
008f				; save byte to send for bit mask shift out 
008f 4f			        ld c,a 
0090 3a c6 f9			ld a,(spi_portbyte) 
0093				  
0093				; clock out	each bit of the byte msb first 
0093			 
0093 06 08			ld b, 8 
0095			.ssb1: 
0095				; clear so bit  
0095 cb bf			res SPI_DI, a 
0097 cb 11			rl c 
0099				; if bit 7 is set then carry is set 
0099 30 02			jr nc, .ssb2 
009b cb ff			set SPI_DI,a 
009d			.ssb2:  ; output bit to ensure it is stable 
009d d3 80			out (storage_adata),a 
009f 00				nop 
00a0				; clock bit high 
00a0 cb ef			set SPI_SCLK,a 
00a2 d3 80			out (storage_adata),a 
00a4 00				nop 
00a5				; then low 
00a5 cb af			res SPI_SCLK,a 
00a7 d3 80			out (storage_adata),a 
00a9 00				nop 
00aa 10 e9			djnz .ssb1 
00ac			 
00ac 32 c6 f9			ld (spi_portbyte),a 
00af c9				ret 
00b0			 
00b0			; TODO low level get byte into A on spi 
00b0			 
00b0			spi_read_byte:  
00b0			 
00b0				; save byte to send for bit mask shift out 
00b0 0e 00		    ld c,0 
00b2 3a c6 f9			ld a,(spi_portbyte) 
00b5				  
00b5				; clock out	each bit of the byte msb first 
00b5			 
00b5			 
00b5				; clock bit high 
00b5 cb ef			set SPI_SCLK,a 
00b7 d3 80			out (storage_adata),a 
00b9 00				nop 
00ba			 
00ba			    ; read DO  
00ba			 
00ba cb f9		    set 7,c 
00bc db 80			in a,(storage_adata) 
00be cb 77		    bit SPI_DO,a 
00c0 20 02		    jr nz, .b7 
00c2 cb b9		    res 7,c 
00c4			.b7: 
00c4				; then low 
00c4 cb af			res SPI_SCLK,a 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9			     
00c9			 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce			 
00ce			    ; read DO  
00ce			 
00ce cb f1		    set 6,c 
00d0 db 80			in a,(storage_adata) 
00d2 cb 77		    bit SPI_DO,a 
00d4 20 02		    jr nz, .b6 
00d6 cb b1		    res 6,c 
00d8			.b6: 
00d8				; then low 
00d8 cb af			res SPI_SCLK,a 
00da d3 80			out (storage_adata),a 
00dc 00				nop 
00dd			 
00dd				; clock bit high 
00dd cb ef			set SPI_SCLK,a 
00df d3 80			out (storage_adata),a 
00e1 00				nop 
00e2			 
00e2			 
00e2			    ; read DO  
00e2			 
00e2 cb e9		    set 5,c 
00e4 db 80			in a,(storage_adata) 
00e6 cb 77		    bit SPI_DO,a 
00e8 20 02		    jr nz, .b5 
00ea cb a9		    res 5,c 
00ec			.b5: 
00ec				; then low 
00ec cb af			res SPI_SCLK,a 
00ee d3 80			out (storage_adata),a 
00f0 00				nop 
00f1				; clock bit high 
00f1 cb ef			set SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			 
00f6			    ; read DO  
00f6			 
00f6 cb e1		    set 4,c 
00f8 db 80			in a,(storage_adata) 
00fa cb 77		    bit SPI_DO,a 
00fc 20 02		    jr nz, .b4 
00fe cb a1		    res 4,c 
0100			.b4: 
0100				; then low 
0100 cb af			res SPI_SCLK,a 
0102 d3 80			out (storage_adata),a 
0104 00				nop 
0105				; clock bit high 
0105 cb ef			set SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a			    ; read DO  
010a			 
010a cb d9		    set 3,c 
010c db 80			in a,(storage_adata) 
010e cb 77		    bit SPI_DO,a 
0110 20 02		    jr nz, .b3 
0112 cb 99		    res 3,c 
0114			.b3: 
0114				; then low 
0114 cb af			res SPI_SCLK,a 
0116 d3 80			out (storage_adata),a 
0118 00				nop 
0119				; clock bit high 
0119 cb ef			set SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e			 
011e			    ; read DO  
011e			 
011e cb d1		    set 2,c 
0120 db 80			in a,(storage_adata) 
0122 cb 77		    bit SPI_DO,a 
0124 20 02		    jr nz, .b2 
0126 cb 91		    res 2,c 
0128			.b2: 
0128				; then low 
0128 cb af			res SPI_SCLK,a 
012a d3 80			out (storage_adata),a 
012c 00				nop 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132			 
0132			    ; read DO  
0132			 
0132 cb c9		    set 1,c 
0134 db 80			in a,(storage_adata) 
0136 cb 77		    bit SPI_DO,a 
0138 20 02		    jr nz, .b1 
013a cb 89		    res 1,c 
013c			.b1: 
013c				; then low 
013c cb af			res SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141				; clock bit high 
0141 cb ef			set SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146			 
0146			    ; read DO  
0146			 
0146 cb c1		    set 0,c 
0148 db 80			in a,(storage_adata) 
014a cb 77		    bit SPI_DO,a 
014c 20 02		    jr nz, .b0 
014e cb 81		    res 0,c 
0150			.b0: 
0150				; then low 
0150 cb af			res SPI_SCLK,a 
0152 d3 80			out (storage_adata),a 
0154 00				nop 
0155			 
0155			 
0155 32 c6 f9			ld (spi_portbyte),a 
0158			 
0158			    ; return byte 
0158 79			    ld a,c 
0159			 
0159			 
0159 c9				ret 
015a			 
015a			 
015a			 
015a			spi_ce_high: 
015a			 
015a				if DEBUG_SPI_HARD_CE0 
015a			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
015a					ret 
015a			 
015a				endif 
015a			 
015a			 
015a f5				push af 
015b			 
015b				; send direct ce to port b 
015b 3e ff			ld a, 255 
015d d3 81			out (storage_bdata), a 
015f			 
015f f1				pop af 
0160			 
0160				; for port a that shares with spi lines AND the mask 
0160			  
0160				if DEBUG_SPI 
0160					push hl 
0160					ld h, a 
0160				endif 
0160			;	ld c, SPI_CE_HIGH 
0160			;	and c 
0160 cb c7			set SPI_CE0, a 
0162 cb cf			set SPI_CE1, a 
0164 cb d7			set SPI_CE2, a 
0166 cb df			set SPI_CE3, a 
0168 cb e7			set SPI_CE4, a 
016a			 
016a				if DEBUG_SPI 
016a					ld l, a 
016a					DMARK "CEh" 
016a					CALLMONITOR 
016a					pop hl 
016a				endif 
016a c9				ret 
016b			 
016b			 
016b			spi_ce_low: 
016b			 
016b				if DEBUG_SPI_HARD_CE0 
016b			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
016b					ret 
016b			 
016b				endif 
016b			 
016b c5				push bc 
016c f5				push af 
016d			 
016d				; send direct ce to port b 
016d 3a c8 f9			ld a, (spi_cartdev) 
0170 d3 81			out (storage_bdata), a 
0172			 
0172			 
0172			 
0172				; for port a that shares with spi lines AND the mask 
0172			 
0172 3a c5 f9			ld a, (spi_device)  
0175 4f				ld c, a 
0176			 
0176 f1				pop af 
0177			 
0177				; detect CEx 
0177			 
0177				if DEBUG_SPI 
0177					push hl 
0177					ld h, a 
0177				endif 
0177			 
0177 cb 41			bit SPI_CE0, c 
0179 20 04			jr nz, .cel1 
017b cb 87			res SPI_CE0, a 
017d 18 1e			jr .celn 
017f			.cel1: 
017f cb 49			bit SPI_CE1, c 
0181 20 04			jr nz, .cel2 
0183 cb 8f			res SPI_CE1, a 
0185 18 16			jr .celn 
0187			.cel2: 
0187 cb 51			bit SPI_CE2, c 
0189 20 04			jr nz, .cel3 
018b cb 97			res SPI_CE2, a 
018d 18 0e			jr .celn 
018f			.cel3: 
018f cb 59			bit SPI_CE3, c 
0191 20 04			jr nz, .cel4 
0193 cb 9f			res SPI_CE3, a 
0195 18 06			jr .celn 
0197			.cel4: 
0197 cb 61			bit SPI_CE4, c 
0199 20 02			jr nz, .celn 
019b cb a7			res SPI_CE4, a 
019d			.celn: 
019d			 
019d			 
019d			 
019d			;	add c 
019d			 
019d				if DEBUG_SPI 
019d					ld l, a 
019d					DMARK "CEl" 
019d					CALLMONITOR 
019d					pop hl 
019d				endif 
019d c1				pop bc 
019e c9				ret 
019f			 
019f			 
019f			 
019f			; eof 
019f			 
019f			 
019f			 
019f			 
019f			 
# End of file firmware_spi.asm
019f				include "firmware_seeprom.asm"  
019f			; 
019f			; persisent storage interface via microchip serial eeprom 
019f			 
019f			; port a pio 2 
019f			; pa 7 - si 
019f			; pa 6 - sclk  
019f			; pa 5 - so 
019f			; pa 4 - cs 
019f			; pa 3 - cs 
019f			; pa 2 - cs 
019f			; pa 1 - cs 
019f			; pa 0 - cs 
019f			; 
019f			; TODO get block 
019f			; TODO save block 
019f			; TODO load file 
019f			; TODO save file 
019f			; TODO get dir  
019f			 
019f			;  
019f			storage_adata: equ Device_C    ; device c port a - onboard storage 
019f			storage_actl: equ Device_C+2     ; device c port a 
019f			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
019f			storage_bctl: equ Device_C+3     ; device c port b 
019f			 
019f			 
019f			; TODO move these to hardware driver file 
019f			 
019f			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
019f			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
019f			; storage bank file system format 
019f			; 
019f			; first page of bank: 
019f			; 	addr 0 - status check 
019f			;       addr 1 - write protect flag 
019f			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
019f			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
019f			;         TODO see if scanning whole of for available next file id is fast enough 
019f			;	addr 4 > zero term string of bank label 
019f			; 
019f			;        
019f			;  
019f			; first page of any file: 
019f			;      byte 0 - file id  
019f			;      byte 1-17 - fixed file name  
019f			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
019f			; 
019f			; other pages of any file: 
019f			;      byte 0 - file id 
019f			;      byte 1> - file data 
019f			; 
019f			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
019f			;  
019f			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
019f			 
019f			 
019f			;storage_so_bit: 5 
019f			;storage_si_bit: 7 
019f			;storage_sclk_bit: 6 
019f			  
019f			 
019f			; init storage pio 
019f			 
019f			storage_init: 
019f			 
019f 3e cf		            LD   A, 11001111b 
01a1 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01a3 3e 00		            LD   A, 00000000b 
01a5 cb f7			set SPI_DO,a 
01a7			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01a7 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01a9			 
01a9 3e cf		            LD   A, 11001111b 
01ab d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01ad 3e 00		            LD   A, 00000000b 
01af d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01b1			 
01b1				; set all external spi devices off 
01b1 3e 00			ld a, 0 
01b3 32 c5 f9			ld (spi_device), a 
01b6 32 c8 f9			ld (spi_cartdev), a 
01b9			 
01b9					; ensure the spi bus is in a default stable state 
01b9 cd 84 00				call se_stable_spi 
01bc			 
01bc			; TODO scan spi bus and gather which storage banks are present 
01bc			 
01bc			; populate store_bank_active  
01bc			; for each ce line activate and attempt to write first byte of bank and read back 
01bc			; if zero is returned then bank is empty 
01bc			;   
01bc			; 
01bc			 
01bc					; init file extent cache to save on slow reads 
01bc			 
01bc			;	ld hl, store_filecache 
01bc			;	ld de, 0 
01bc			;	ld hl,(de)	 
01bc			 
01bc			 
01bc c9			    ret 
01bd			 
01bd			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01bd			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01bd			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01bd			 
01bd			; INSTRUCTION SET 
01bd			; READ 0000 0011 Read data from memory array beginning at selected address 
01bd			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01bd			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01bd			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01bd			; RDSR 0000 0101 Read STATUS register 
01bd			; WRSR 0000 0001 Write STATUS register 
01bd			; PE 0100 0010 Page Erase – erase one page in memory array 
01bd			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01bd			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01bd			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01bd			 
01bd			; TODO send byte steam for page without setting the address for every single byte 
01bd			; TODO read byte  
01bd			 
01bd			; byte in a 
01bd			; address in hl  
01bd			se_writebyte: 
01bd			        
01bd			    ;   ld c, a 
01bd f5			        push af 
01be e5			        push hl 
01bf			 
01bf			    ; initi write mode 
01bf			    ; 
01bf			    ;CS low 
01bf			 
01bf 3a c6 f9		       ld a,(spi_portbyte) 
01c2 cd 6b 01			call spi_ce_low 
01c5			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c5 d3 80		       out (storage_adata),a 
01c7 32 c6 f9		       ld (spi_portbyte), a 
01ca			 
01ca			    ;clock out wren instruction 
01ca			 
01ca 3e 06		    ld a, store_wren_ins 
01cc cd 8f 00		    call spi_send_byte  
01cf			 
01cf			    ;cs high to enable write latch 
01cf			 
01cf 3a c6 f9		       ld a,(spi_portbyte) 
01d2 cd 5a 01			call spi_ce_high 
01d5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01d5 d3 80		       out (storage_adata),a 
01d7 32 c6 f9		       ld (spi_portbyte), a 
01da			 
01da 00				nop 
01db			    ; 
01db			    ; intial write data 
01db			    ; 
01db			    ; cs low 
01db			     
01db 3a c6 f9		       ld a,(spi_portbyte) 
01de cd 6b 01			call spi_ce_low 
01e1			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e1 d3 80		       out (storage_adata),a 
01e3 32 c6 f9		       ld (spi_portbyte), a 
01e6			 
01e6			    ; clock out write instruction 
01e6			     
01e6 3e 02		    ld a, store_write_ins  
01e8 cd 8f 00		    call spi_send_byte  
01eb			 
01eb			    ; clock out address (depending on address size) 
01eb			     
01eb e1			    pop hl 
01ec 7c			    ld a,h    ; address out msb first 
01ed cd 8f 00		    call spi_send_byte  
01f0 7d			    ld a,l 
01f1 cd 8f 00		    call spi_send_byte  
01f4			 
01f4			    ; clock out byte(s) for page 
01f4			 
01f4 f1			    pop af 
01f5 cd 8f 00		    call spi_send_byte  
01f8			 
01f8			    ; end write with ce high 
01f8 3a c6 f9		       ld a,(spi_portbyte) 
01fb			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
01fb cd 5a 01			call spi_ce_high 
01fe d3 80		       out (storage_adata),a 
0200 32 c6 f9		       ld (spi_portbyte), a 
0203			 
0203				; pause for internal write cycle 
0203 3e 0a			ld a, 10 
0205 cd 2f 0a			call aDelayInMS 
0208 c9			    ret 
0209			 
0209			; buffer to write in de 
0209			; address in hl  
0209			se_writepage: 
0209			        
0209			    ;   ld c, a 
0209 d5				push de 
020a e5			        push hl 
020b			 
020b			    ; initi write mode 
020b			    ; 
020b			    ;CS low 
020b			 
020b 3a c6 f9		       ld a,(spi_portbyte) 
020e cd 6b 01			call spi_ce_low 
0211			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211 d3 80		       out (storage_adata),a 
0213 32 c6 f9		       ld (spi_portbyte), a 
0216			 
0216			    ;clock out wren instruction 
0216			 
0216 3e 06		    ld a, store_wren_ins 
0218 cd 8f 00		    call spi_send_byte  
021b			 
021b			    ;cs high to enable write latch 
021b			 
021b 3a c6 f9		       ld a,(spi_portbyte) 
021e cd 5a 01			call spi_ce_high 
0221			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0221 d3 80		       out (storage_adata),a 
0223 32 c6 f9		       ld (spi_portbyte), a 
0226			 
0226 00				nop 
0227			    ; 
0227			    ; intial write data 
0227			    ; 
0227			    ; cs low 
0227			     
0227 3a c6 f9		       ld a,(spi_portbyte) 
022a			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022a cd 6b 01			call spi_ce_low 
022d d3 80		       out (storage_adata),a 
022f 32 c6 f9		       ld (spi_portbyte), a 
0232			 
0232			    ; clock out write instruction 
0232			     
0232 3e 02		    ld a, store_write_ins  
0234 cd 8f 00		    call spi_send_byte  
0237			 
0237			    ; clock out address (depending on address size) 
0237			     
0237 e1			    pop hl 
0238 7c			    ld a,h    ; address out msb first 
0239 cd 8f 00		    call spi_send_byte  
023c 7d			    ld a,l 
023d cd 8f 00		    call spi_send_byte  
0240			 
0240			    ; clock out byte(s) for page 
0240			 
0240 e1				pop hl 
0241 06 40			ld b, STORE_BLOCK_PHY 
0243			.bytewrite: 
0243			 
0243 7e				ld a,(hl) 
0244 e5			    push hl 
0245 c5				push bc 
0246 cd 8f 00		    call spi_send_byte  
0249 c1				pop bc 
024a e1				pop hl 
024b			 
024b			    ; end write with ce high 
024b 3a c6 f9		       ld a,(spi_portbyte) 
024e cd 5a 01			call spi_ce_high 
0251			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0251 d3 80		       out (storage_adata),a 
0253 32 c6 f9		       ld (spi_portbyte), a 
0256			 
0256 23				inc hl 
0257 10 ea			djnz .bytewrite 
0259			 
0259				; pause for internal write cycle 
0259 3e 64			ld a, 100 
025b cd 2f 0a			call aDelayInMS 
025e c9			    ret 
025f			; returns byte in a 
025f			; address in hl  
025f			se_readbyte: 
025f d5				push de 
0260 c5				push bc 
0261			 
0261			    ;   ld c, a 
0261 e5			        push hl 
0262			 
0262			    ; initi write mode 
0262			    ; 
0262			    ;CS low 
0262			 
0262 3a c6 f9		       ld a,(spi_portbyte) 
0265 cd 6b 01			call spi_ce_low 
0268			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0268 d3 80		       out (storage_adata),a 
026a 32 c6 f9		       ld (spi_portbyte), a 
026d			 
026d			    ;clock out wren instruction 
026d			 
026d 3e 03		    ld a, store_read_ins 
026f cd 8f 00		    call spi_send_byte  
0272			 
0272			 
0272			    ; clock out address (depending on address size) 
0272			     
0272 e1			    pop hl 
0273 7c			    ld a,h    ; address out msb first 
0274 cd 8f 00		    call spi_send_byte  
0277 7d			    ld a,l 
0278 cd 8f 00		    call spi_send_byte  
027b			 
027b			    ; clock in byte(s) for page 
027b			 
027b cd b0 00		    call spi_read_byte  
027e f5				push af 
027f			 
027f			    ; end write with ce high 
027f 3a c6 f9		       ld a,(spi_portbyte) 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0282 cd 5a 01			call spi_ce_high 
0285 d3 80		       out (storage_adata),a 
0287 32 c6 f9		       ld (spi_portbyte), a 
028a			 
028a f1				pop af 
028b			 
028b c1				pop bc 
028c d1				pop de 
028d			 
028d c9			    ret 
028e			 
028e			if DEBUG_STORESE 
028e			 
028e			storageput:  
028e			 
028e			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
028e			 
028e 21 9c ef			ld hl,scratch+2 
0291 cd b8 10			call get_word_hl 
0294			 
0294				; stuff it here for the moment as it will be overwritten later anyway 
0294			 
0294 22 bd f2			ld (os_cur_ptr),hl	 
0297			 
0297			 
0297			; get pointer to start of string 
0297			 
0297 21 a1 ef			ld hl, scratch+7 
029a			 
029a			; loop writing char of string to eeprom 
029a			 
029a 7e			.writestr:	ld a,(hl) 
029b fe 00				cp 0 
029d 28 12				jr z, .wsdone		; done writing 
029f e5					push hl 
02a0 2a bd f2				ld hl,(os_cur_ptr) 
02a3 cd bd 01				call se_writebyte 
02a6			 
02a6 2a bd f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02a9 23					inc hl 
02aa 22 bd f2				ld (os_cur_ptr),hl 
02ad			 
02ad					; restore string pointer and get next char 
02ad			 
02ad e1					pop hl 
02ae 23					inc hl 
02af 18 e9				jr .writestr 
02b1			 
02b1			 
02b1			 
02b1			.wsdone: 
02b1			 
02b1			 
02b1			; when done load first page into a buffer  
02b1			 
02b1 21 00 80				ld hl,08000h		; start in ram 
02b4 22 bd f2				ld (os_cur_ptr),hl 
02b7 21 00 00				ld hl, 0		 ; start of page 
02ba 22 c2 ef				ld (scratch+40),hl	; hang on to it 
02bd			 
02bd 06 80				ld b, 128		; actually get more then one page 
02bf c5			.wsload:	push bc 
02c0 2a c2 ef				ld hl,(scratch+40) 
02c3 e5					push hl 
02c4 cd 5f 02				call se_readbyte 
02c7			 
02c7					; a now as the byte 
02c7			 
02c7 2a bd f2				ld hl,(os_cur_ptr) 
02ca 77					ld (hl),a 
02cb					; inc next buffer area 
02cb 23					inc hl 
02cc 22 bd f2				ld (os_cur_ptr),hl 
02cf			 
02cf					; get eeprom position, inc and save for next round 
02cf e1					pop hl		 
02d0 23					inc hl 
02d1 22 c2 ef				ld (scratch+40),hl 
02d4 c1					pop bc 
02d5 10 e8				djnz .wsload 
02d7			 
02d7			; set 'd' pointer to start of buffer 
02d7			 
02d7 21 00 80				ld hl,08000h 
02da 22 bd f2				ld (os_cur_ptr),hl 
02dd			 
02dd			 
02dd c9			ret 
02de			 
02de			 
02de c9			storageread: ret 
02df			 
02df			 
02df			 
02df			 
02df			 
02df			 
02df			endif 
02df			 
02df			 
02df			 
# End of file firmware_seeprom.asm
02df			else  
02df			   ; create some stubs for the labels  
02df			se_readbyte: ret  
02df			se_writebyte: ret  
02df			storage_init: ret  
02df			  
02df			endif  
02df			  
02df			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02df			;include "firmware_cf.asm"  
02df			  
02df			; load up high level storage hardward abstractions  
02df			include "firmware_storage.asm"  
02df			 
02df			; persisent storage hardware abstraction layer  
02df			 
02df			 
02df			 
02df			; Block 0 on storage is a config state 
02df			 
02df			 
02df			 
02df			; TODO add read phy block and write phy block functions 
02df			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02df			 
02df			; Abstraction layer  
02df			 
02df			; Logocial block size is same size as physical size - using tape concept 
02df			 
02df			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02df			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02df			 
02df			 
02df			 
02df			; Filesystem layout (Logical layout) 
02df			; 
02df			; Block 0 - Bank config  
02df			; 
02df			;      Byte - 0 file id counter 
02df			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02df			;      Byte - 3-20 zero terminated bank label 
02df			; 
02df			; Block 1 > File storage 
02df			; 
02df			;      Byte 0 file id    - block 0 file details 
02df			;      Byte 1 block id - block 0 is file  
02df			;            Byte 2-15 - File name 
02df			; 
02df			;       - to end of block data 
02df			; 
02df			 
02df			 
02df			; Read Block 
02df			; ---------- 
02df			; 
02df			; With current bank 
02df			;  
02df			; Get block number to read 
02df			; Load physical blocks starting at start block into buffer 
02df			 
02df			; de points to buffer to use 
02df			; hl holds logical block number  
02df			 
02df			storage_read_block: 
02df			 
02df				; TODO bank selection 
02df			 
02df				; for each of the physical blocks read it into the buffer 
02df 06 40			ld b, STORE_BLOCK_PHY 
02e1			 
02e1				if DEBUG_STORESE 
02e1 d5					push de 
02e2				endif 
02e2				 
02e2			.rl1:    
02e2			 
02e2				; read physical block at hl into de 
02e2			        ; increment hl and de to next read position on exit 
02e2			 
02e2 e5				push hl 
02e3 d5				push de	 
02e4 c5				push bc 
02e5			;	if DEBUG_STORESE 
02e5			;		push af 
02e5			;		ld a, 'R' 
02e5			;		ld (debug_mark),a 
02e5			;		pop af 
02e5			;		CALLMONITOR 
02e5			;	endif 
02e5 cd 5f 02			call se_readbyte 
02e8			;	if DEBUG_STORESE 
02e8			;		ld a,(spi_portbyte) 
02e8			;		ld l, a 
02e8			;		push af 
02e8			;		ld a, '1' 
02e8			;		ld (debug_mark),a 
02e8			;		pop af 
02e8			;		CALLMONITOR 
02e8			;	endif 
02e8 c1				pop bc 
02e9 d1				pop de 
02ea e1				pop hl 
02eb 12				ld (de),a 
02ec 23				inc hl 
02ed 13				inc de 
02ee			 
02ee			;	if DEBUG_STORESE 
02ee			;		push af 
02ee			;		ld a, 'r' 
02ee			;		ld (debug_mark),a 
02ee			;		pop af 
02ee			;		CALLMONITOR 
02ee			;	endif 
02ee			 
02ee 10 f2			djnz .rl1 
02f0			 
02f0				if DEBUG_STORESE 
02f0					DMARK "SRB" 
02f0 f5				push af  
02f1 3a 05 03			ld a, (.dmark)  
02f4 32 b4 fb			ld (debug_mark),a  
02f7 3a 06 03			ld a, (.dmark+1)  
02fa 32 b5 fb			ld (debug_mark+1),a  
02fd 3a 07 03			ld a, (.dmark+2)  
0300 32 b6 fb			ld (debug_mark+2),a  
0303 18 03			jr .pastdmark  
0305 ..			.dmark: db "SRB"  
0308 f1			.pastdmark: pop af  
0309			endm  
# End of macro DMARK
0309 d1					pop de 
030a			; 
030a			;		push af 
030a			;		ld a, 'R' 
030a			;		ld (debug_mark),a 
030a			;		pop af 
030a					CALLMONITOR 
030a cd 7e 16			call break_point_state  
030d				endm  
# End of macro CALLMONITOR
030d				endif 
030d c9				ret	 
030e				 
030e			 
030e			; File Size 
030e			; --------- 
030e			; 
030e			;   hl file id 
030e			; 
030e			;  returns in hl the number of blocks 
030e			 
030e			storage_file_size: 
030e 5d				ld e, l 
030f 16 00			ld d, 0 
0311 21 40 00			ld hl, STORE_BLOCK_PHY 
0314					if DEBUG_FORTH_WORDS 
0314						DMARK "SIZ" 
0314 f5				push af  
0315 3a 29 03			ld a, (.dmark)  
0318 32 b4 fb			ld (debug_mark),a  
031b 3a 2a 03			ld a, (.dmark+1)  
031e 32 b5 fb			ld (debug_mark+1),a  
0321 3a 2b 03			ld a, (.dmark+2)  
0324 32 b6 fb			ld (debug_mark+2),a  
0327 18 03			jr .pastdmark  
0329 ..			.dmark: db "SIZ"  
032c f1			.pastdmark: pop af  
032d			endm  
# End of macro DMARK
032d						CALLMONITOR 
032d cd 7e 16			call break_point_state  
0330				endm  
# End of macro CALLMONITOR
0330					endif 
0330 cd 12 06			call storage_findnextid 
0333			 
0333 cd 2a 0d			call ishlzero 
0336			;	ld a, l 
0336			;	add h 
0336			;	cp 0 
0336 c8				ret z			; block not found so EOF 
0337			 
0337 11 df f9			ld de, store_page 
033a cd df 02			call storage_read_block 
033d			 
033d 3a e1 f9			ld a, (store_page+2)	 ; get extent count 
0340 6f				ld l, a 
0341 26 00			ld h, 0 
0343 c9			 	ret 
0344			 
0344			 
0344			; Write Block 
0344			; ----------- 
0344			; 
0344			; With current bank 
0344			;  
0344			; Get block number to write 
0344			; Write physical blocks starting at start block from buffer 
0344			  
0344			storage_write_block: 
0344				; TODO bank selection 
0344			 
0344				; for each of the physical blocks read it into the buffer 
0344 06 40			ld b, STORE_BLOCK_PHY 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SWB" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 b4 fb			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 b5 fb			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 b6 fb			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SWB"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f			 
035f					;push af 
035f					;ld a, 'W' 
035f					;ld (debug_mark),a 
035f					;pop af 
035f					CALLMONITOR 
035f cd 7e 16			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362			 
0362			; might not be working 
0362			;	call se_writepage 
0362			 
0362			;	ret 
0362			; 
0362			 
0362			 
0362			 
0362			.wl1:    
0362			 
0362				; read physical block at hl into de 
0362			        ; increment hl and de to next read position on exit 
0362			 
0362 e5				push hl 
0363 d5				push de	 
0364 c5				push bc 
0365 1a				ld a,(de) 
0366				;if DEBUG_STORESE 
0366			;		push af 
0366			;		ld a, 'W' 
0366			;		ld (debug_mark),a 
0366			;		pop af 
0366			;		CALLMONITOR 
0366			;	endif 
0366 cd bd 01			call se_writebyte 
0369			;	call delay250ms 
0369 00				nop 
036a 00				nop 
036b 00				nop 
036c			;	if DEBUG_STORESE 
036c			;		push af 
036c			;		ld a, 'w' 
036c			;		ld (debug_mark),a 
036c			;		pop af 
036c			;		CALLMONITOR 
036c			;	endif 
036c c1				pop bc 
036d d1				pop de 
036e e1				pop hl 
036f 23				inc hl 
0370 13				inc de 
0371			 
0371			 
0371 10 ef			djnz .wl1 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SW2" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 b4 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 b5 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 b6 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SW2"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 7e 16			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f c9				ret	 
0390			 
0390			; Init bank 
0390			; --------- 
0390			; 
0390			; With current bank 
0390			; 
0390			; Setup block 0 config 
0390			;     Set 0 file id counter 
0390			;     Set formatted byte pattern 
0390			;     Zero out bank label 
0390			;      
0390			; For every logical block write 0-1 byte as null 
0390			 
0390			storage_get_block_0: 
0390			 
0390				; TODO check presence 
0390			 
0390				; get block 0 config 
0390			 
0390 21 00 00			ld hl, 0 
0393 11 df f9			ld de, store_page 
0396 cd df 02			call storage_read_block 
0399			 
0399				if DEBUG_STORESE 
0399					DMARK "SB0" 
0399 f5				push af  
039a 3a ae 03			ld a, (.dmark)  
039d 32 b4 fb			ld (debug_mark),a  
03a0 3a af 03			ld a, (.dmark+1)  
03a3 32 b5 fb			ld (debug_mark+1),a  
03a6 3a b0 03			ld a, (.dmark+2)  
03a9 32 b6 fb			ld (debug_mark+2),a  
03ac 18 03			jr .pastdmark  
03ae ..			.dmark: db "SB0"  
03b1 f1			.pastdmark: pop af  
03b2			endm  
# End of macro DMARK
03b2 11 df f9				ld de, store_page 
03b5			;		push af 
03b5			;		ld a, 'i' 
03b5			;		ld (debug_mark),a 
03b5			;		pop af 
03b5					CALLMONITOR 
03b5 cd 7e 16			call break_point_state  
03b8				endm  
# End of macro CALLMONITOR
03b8				endif 
03b8			 
03b8				; is this area formatted? 
03b8			 
03b8			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03b8 2a e0 f9			ld hl, (store_page+1) 
03bb 3e 80			ld a,0x80 
03bd bd				cp l 
03be 20 22			jr nz, .ininotformatted 
03c0				; do a double check 
03c0 3e 27			ld a, 0x27 
03c2 bc				cp h 
03c3 20 1d			jr nz, .ininotformatted 
03c5			 
03c5				; formatted then 
03c5			 
03c5				if DEBUG_STORESE 
03c5					DMARK "SB1" 
03c5 f5				push af  
03c6 3a da 03			ld a, (.dmark)  
03c9 32 b4 fb			ld (debug_mark),a  
03cc 3a db 03			ld a, (.dmark+1)  
03cf 32 b5 fb			ld (debug_mark+1),a  
03d2 3a dc 03			ld a, (.dmark+2)  
03d5 32 b6 fb			ld (debug_mark+2),a  
03d8 18 03			jr .pastdmark  
03da ..			.dmark: db "SB1"  
03dd f1			.pastdmark: pop af  
03de			endm  
# End of macro DMARK
03de					;push af 
03de					;ld a, 'I' 
03de					;ld (debug_mark),a 
03de					;pop af 
03de					CALLMONITOR 
03de cd 7e 16			call break_point_state  
03e1				endm  
# End of macro CALLMONITOR
03e1				endif 
03e1 c9				ret 
03e2			 
03e2			.ininotformatted: 
03e2				; bank not formatted so poke various bits to make sure 
03e2			 
03e2				if DEBUG_STORESE 
03e2					DMARK "SB2" 
03e2 f5				push af  
03e3 3a f7 03			ld a, (.dmark)  
03e6 32 b4 fb			ld (debug_mark),a  
03e9 3a f8 03			ld a, (.dmark+1)  
03ec 32 b5 fb			ld (debug_mark+1),a  
03ef 3a f9 03			ld a, (.dmark+2)  
03f2 32 b6 fb			ld (debug_mark+2),a  
03f5 18 03			jr .pastdmark  
03f7 ..			.dmark: db "SB2"  
03fa f1			.pastdmark: pop af  
03fb			endm  
# End of macro DMARK
03fb					;push af 
03fb					;ld a, 'f' 
03fb					;ld (debug_mark),a 
03fb					;pop af 
03fb					CALLMONITOR 
03fb cd 7e 16			call break_point_state  
03fe				endm  
# End of macro CALLMONITOR
03fe				endif 
03fe			 
03fe cd 0d 0a			call storage_clear_page 
0401			 
0401 21 df f9			ld hl, store_page 
0404 3e 00			ld a, 0 
0406				 
0406 77				ld (hl),a   ; reset file counter 
0407			 
0407 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
040a 22 e0 f9		 	ld (store_page+1), hl	 
040d			 
040d				; set default label 
040d			 
040d 21 a9 04			ld hl, .defaultbanklabl 
0410 11 e2 f9		 	ld de, store_page+3 
0413 01 0f 00			ld bc, 15 
0416 ed b0			ldir 
0418			 
0418				; Append the current bank id 
0418 21 eb f9			ld hl, store_page+3+9 
041b 3a c4 f9			ld a, (spi_device_id) 
041e 77				ld (hl), a 
041f			 
041f				; save default page 0 
041f			 
041f 21 00 00			ld hl, 0 
0422 11 df f9			ld de, store_page 
0425				if DEBUG_STORESE 
0425					DMARK "SB3" 
0425 f5				push af  
0426 3a 3a 04			ld a, (.dmark)  
0429 32 b4 fb			ld (debug_mark),a  
042c 3a 3b 04			ld a, (.dmark+1)  
042f 32 b5 fb			ld (debug_mark+1),a  
0432 3a 3c 04			ld a, (.dmark+2)  
0435 32 b6 fb			ld (debug_mark+2),a  
0438 18 03			jr .pastdmark  
043a ..			.dmark: db "SB3"  
043d f1			.pastdmark: pop af  
043e			endm  
# End of macro DMARK
043e			;		push af 
043e			;		ld a, 'F' 
043e			;		ld (debug_mark),a 
043e			;		pop af 
043e					CALLMONITOR 
043e cd 7e 16			call break_point_state  
0441				endm  
# End of macro CALLMONITOR
0441				endif 
0441 cd 44 03			call storage_write_block 
0444				if DEBUG_STORESE 
0444					DMARK "SB4" 
0444 f5				push af  
0445 3a 59 04			ld a, (.dmark)  
0448 32 b4 fb			ld (debug_mark),a  
044b 3a 5a 04			ld a, (.dmark+1)  
044e 32 b5 fb			ld (debug_mark+1),a  
0451 3a 5b 04			ld a, (.dmark+2)  
0454 32 b6 fb			ld (debug_mark+2),a  
0457 18 03			jr .pastdmark  
0459 ..			.dmark: db "SB4"  
045c f1			.pastdmark: pop af  
045d			endm  
# End of macro DMARK
045d			;		push af 
045d			;		ld a, '>' 
045d			;		ld (debug_mark),a 
045d			;		pop af 
045d					CALLMONITOR 
045d cd 7e 16			call break_point_state  
0460				endm  
# End of macro CALLMONITOR
0460				endif 
0460			 
0460 00				nop 
0461 00				nop 
0462 00				nop 
0463			 
0463				; now set 0 in every page to mark as a free block 
0463			 
0463 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0465 21 40 00			ld hl, STORE_BLOCK_PHY 
0468			 
0468 3e 00		.setmark1:   	ld a,0 
046a e5					push hl 
046b c5					push bc 
046c cd bd 01				call se_writebyte 
046f 3e 0a			ld a, 10 
0471 cd 2f 0a			call aDelayInMS 
0474 23				inc hl 
0475 cd bd 01				call se_writebyte 
0478 3e 0a			ld a, 10 
047a cd 2f 0a			call aDelayInMS 
047d 2b				dec hl 
047e c1					pop bc 
047f e1					pop hl 
0480 3e 40				ld a, STORE_BLOCK_PHY 
0482 cd 01 0d				call addatohl 
0485 10 e1				djnz .setmark1 
0487			 
0487 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0489 3e 00		.setmark2:   	ld a,0 
048b e5					push hl 
048c c5					push bc 
048d cd bd 01				call se_writebyte 
0490 3e 0a			ld a, 10 
0492 cd 2f 0a			call aDelayInMS 
0495 23				inc hl 
0496 cd bd 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 2f 0a			call aDelayInMS 
049e 2b				dec hl 
049f c1					pop bc 
04a0 e1					pop hl 
04a1 3e 40				ld a, STORE_BLOCK_PHY 
04a3 cd 01 0d				call addatohl 
04a6 10 e1				djnz .setmark2 
04a8			 
04a8					 
04a8			 
04a8			 
04a8 c9				ret 
04a9			 
04a9			 
04a9			 
04a9			 
04a9 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04b4			 
04b4			 
04b4			 
04b4			; Label Bank 
04b4			; ---------- 
04b4			; 
04b4			; With current bank 
04b4			; Read block 0 
04b4			; Set label 
04b4			; Write block 0 
04b4			 
04b4			; label str pointer in hl 
04b4			 
04b4			storage_label:     
04b4			 
04b4				if DEBUG_STORESE 
04b4					DMARK "LBL" 
04b4 f5				push af  
04b5 3a c9 04			ld a, (.dmark)  
04b8 32 b4 fb			ld (debug_mark),a  
04bb 3a ca 04			ld a, (.dmark+1)  
04be 32 b5 fb			ld (debug_mark+1),a  
04c1 3a cb 04			ld a, (.dmark+2)  
04c4 32 b6 fb			ld (debug_mark+2),a  
04c7 18 03			jr .pastdmark  
04c9 ..			.dmark: db "LBL"  
04cc f1			.pastdmark: pop af  
04cd			endm  
# End of macro DMARK
04cd					CALLMONITOR 
04cd cd 7e 16			call break_point_state  
04d0				endm  
# End of macro CALLMONITOR
04d0				endif 
04d0			 
04d0 e5				push hl 
04d1			 
04d1 cd 90 03			call storage_get_block_0 
04d4			 
04d4				; set default label 
04d4			 
04d4 e1				pop hl 
04d5			 
04d5 11 e2 f9		 	ld de, store_page+3 
04d8 01 0f 00			ld bc, 15 
04db				if DEBUG_STORESE 
04db					DMARK "LB3" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 b4 fb			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 b5 fb			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 b6 fb			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "LB3"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4					CALLMONITOR 
04f4 cd 7e 16			call break_point_state  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7 ed b0			ldir 
04f9				; save default page 0 
04f9			 
04f9 21 00 00			ld hl, 0 
04fc 11 df f9			ld de, store_page 
04ff				if DEBUG_STORESE 
04ff					DMARK "LBW" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 b4 fb			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 b5 fb			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 b6 fb			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "LBW"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518					CALLMONITOR 
0518 cd 7e 16			call break_point_state  
051b				endm  
# End of macro CALLMONITOR
051b				endif 
051b cd 44 03			call storage_write_block 
051e			 
051e c9				ret 
051f			 
051f			 
051f			 
051f			; Read Block 0 - Config 
051f			; --------------------- 
051f			; 
051f			; With current bank 
051f			; Call presence test 
051f			;    If not present format/init bank  
051f			; Read block 0  
051f			;  
051f			 
051f			 
051f			; Dir 
051f			; --- 
051f			; 
051f			; With current bank 
051f			; Load Block 0 Config 
051f			; Get max file id number 
051f			; For each logical block 
051f			;    Read block read byte 2 
051f			;      if first block of file 
051f			;         Display file name 
051f			;         Display type flags for file 
051f			;        
051f			 
051f			; moving to words as this requires stack control 
051f			 
051f			 
051f			; Delete File 
051f			; ----------- 
051f			; 
051f			; With current bank 
051f			; 
051f			; Load Block 0 Config 
051f			; Get max file id number 
051f			; For each logical block 
051f			;    Read block file id 
051f			;      If first block of file and dont have file id 
051f			;         if file to delete 
051f			;         Save file id 
051f			;         Null file id 
051f			;         Write this block back 
051f			;      If file id is one saved 
051f			;         Null file id 
051f			;         Write this block back 
051f			 
051f			 
051f			.se_done: 
051f e1				pop hl 
0520 c9				ret 
0521			 
0521			storage_erase: 
0521			 
0521				; hl contains the file id 
0521			 
0521 5d				ld e, l 
0522 16 00			ld d, 0 
0524 21 40 00			ld hl, STORE_BLOCK_PHY 
0527					if DEBUG_FORTH_WORDS 
0527						DMARK "ERA" 
0527 f5				push af  
0528 3a 3c 05			ld a, (.dmark)  
052b 32 b4 fb			ld (debug_mark),a  
052e 3a 3d 05			ld a, (.dmark+1)  
0531 32 b5 fb			ld (debug_mark+1),a  
0534 3a 3e 05			ld a, (.dmark+2)  
0537 32 b6 fb			ld (debug_mark+2),a  
053a 18 03			jr .pastdmark  
053c ..			.dmark: db "ERA"  
053f f1			.pastdmark: pop af  
0540			endm  
# End of macro DMARK
0540						CALLMONITOR 
0540 cd 7e 16			call break_point_state  
0543				endm  
# End of macro CALLMONITOR
0543					endif 
0543 cd 12 06			call storage_findnextid 
0546 cd 2a 0d			call ishlzero 
0549 c8				ret z 
054a			 
054a e5				push hl 
054b			 
054b				; TODO check file not found 
054b			 
054b 11 df f9			ld de, store_page 
054e cd df 02			call storage_read_block 
0551			 
0551 cd 2a 0d			call ishlzero 
0554 ca 1f 05			jp z,.se_done 
0557			 
0557					if DEBUG_FORTH_WORDS 
0557						DMARK "ER1" 
0557 f5				push af  
0558 3a 6c 05			ld a, (.dmark)  
055b 32 b4 fb			ld (debug_mark),a  
055e 3a 6d 05			ld a, (.dmark+1)  
0561 32 b5 fb			ld (debug_mark+1),a  
0564 3a 6e 05			ld a, (.dmark+2)  
0567 32 b6 fb			ld (debug_mark+2),a  
056a 18 03			jr .pastdmark  
056c ..			.dmark: db "ER1"  
056f f1			.pastdmark: pop af  
0570			endm  
# End of macro DMARK
0570						CALLMONITOR 
0570 cd 7e 16			call break_point_state  
0573				endm  
# End of macro CALLMONITOR
0573					endif 
0573 3a df f9			ld a, (store_page)	; get file id 
0576 32 d8 f9			ld (store_tmpid), a 
0579			 
0579 3a e1 f9			ld a, (store_page+2)    ; get count of extends 
057c 32 d7 f9			ld (store_tmpext), a 
057f			 
057f				; wipe file header 
057f			 
057f e1				pop hl 
0580 3e 00			ld a, 0 
0582 32 df f9			ld (store_page), a 
0585 32 e0 f9			ld (store_page+1),a 
0588 11 df f9			ld de, store_page 
058b					if DEBUG_FORTH_WORDS 
058b						DMARK "ER2" 
058b f5				push af  
058c 3a a0 05			ld a, (.dmark)  
058f 32 b4 fb			ld (debug_mark),a  
0592 3a a1 05			ld a, (.dmark+1)  
0595 32 b5 fb			ld (debug_mark+1),a  
0598 3a a2 05			ld a, (.dmark+2)  
059b 32 b6 fb			ld (debug_mark+2),a  
059e 18 03			jr .pastdmark  
05a0 ..			.dmark: db "ER2"  
05a3 f1			.pastdmark: pop af  
05a4			endm  
# End of macro DMARK
05a4						CALLMONITOR 
05a4 cd 7e 16			call break_point_state  
05a7				endm  
# End of macro CALLMONITOR
05a7					endif 
05a7 cd 44 03			call storage_write_block 
05aa			 
05aa			 
05aa				; wipe file extents 
05aa			 
05aa 3a d7 f9			ld a, (store_tmpext) 
05ad 47				ld b, a 
05ae			 
05ae			.eraext:	  
05ae c5				push bc 
05af			 
05af 21 40 00			ld hl, STORE_BLOCK_PHY 
05b2 3a d8 f9			ld a,(store_tmpid) 
05b5 5f				ld e, a 
05b6 50				ld d, b	 
05b7					if DEBUG_FORTH_WORDS 
05b7						DMARK "ER3" 
05b7 f5				push af  
05b8 3a cc 05			ld a, (.dmark)  
05bb 32 b4 fb			ld (debug_mark),a  
05be 3a cd 05			ld a, (.dmark+1)  
05c1 32 b5 fb			ld (debug_mark+1),a  
05c4 3a ce 05			ld a, (.dmark+2)  
05c7 32 b6 fb			ld (debug_mark+2),a  
05ca 18 03			jr .pastdmark  
05cc ..			.dmark: db "ER3"  
05cf f1			.pastdmark: pop af  
05d0			endm  
# End of macro DMARK
05d0						CALLMONITOR 
05d0 cd 7e 16			call break_point_state  
05d3				endm  
# End of macro CALLMONITOR
05d3					endif 
05d3 cd 12 06			call storage_findnextid 
05d6 cd 2a 0d			call ishlzero 
05d9 ca 1f 05			jp z,.se_done 
05dc			 
05dc e5				push hl 
05dd 11 df f9			ld de, store_page 
05e0 cd df 02			call storage_read_block 
05e3			 
05e3				; free block	 
05e3			 
05e3 3e 00			ld a, 0 
05e5 32 df f9			ld (store_page), a 
05e8 32 e0 f9			ld (store_page+1),a 
05eb 11 df f9			ld de, store_page 
05ee e1				pop hl 
05ef					if DEBUG_FORTH_WORDS 
05ef						DMARK "ER4" 
05ef f5				push af  
05f0 3a 04 06			ld a, (.dmark)  
05f3 32 b4 fb			ld (debug_mark),a  
05f6 3a 05 06			ld a, (.dmark+1)  
05f9 32 b5 fb			ld (debug_mark+1),a  
05fc 3a 06 06			ld a, (.dmark+2)  
05ff 32 b6 fb			ld (debug_mark+2),a  
0602 18 03			jr .pastdmark  
0604 ..			.dmark: db "ER4"  
0607 f1			.pastdmark: pop af  
0608			endm  
# End of macro DMARK
0608						CALLMONITOR 
0608 cd 7e 16			call break_point_state  
060b				endm  
# End of macro CALLMONITOR
060b					endif 
060b cd 44 03			call storage_write_block 
060e			 
060e c1				pop bc 
060f 10 9d			djnz .eraext 
0611			 
0611 c9				ret 
0612			 
0612			 
0612			; Find Free Block 
0612			; --------------- 
0612			; 
0612			; With current bank 
0612			;  
0612			; From given starting logical block 
0612			;    Read block  
0612			;    If no file id 
0612			;         Return block id 
0612			 
0612			 
0612			; hl starting page number 
0612			; hl contains free page number or zero if no pages free 
0612			; e contains the file id to locate 
0612			; d contains the block number 
0612			 
0612			; TODO change to find file id and use zero for free block 
0612			 
0612			storage_findnextid: 
0612			 
0612				; now locate first 0 page to mark as a free block 
0612			 
0612 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0614			;	ld hl, STORE_BLOCK_PHY 
0614			 
0614					if DEBUG_FORTH_WORDS 
0614					DMARK "FNI" 
0614 f5				push af  
0615 3a 29 06			ld a, (.dmark)  
0618 32 b4 fb			ld (debug_mark),a  
061b 3a 2a 06			ld a, (.dmark+1)  
061e 32 b5 fb			ld (debug_mark+1),a  
0621 3a 2b 06			ld a, (.dmark+2)  
0624 32 b6 fb			ld (debug_mark+2),a  
0627 18 03			jr .pastdmark  
0629 ..			.dmark: db "FNI"  
062c f1			.pastdmark: pop af  
062d			endm  
# End of macro DMARK
062d						CALLMONITOR 
062d cd 7e 16			call break_point_state  
0630				endm  
# End of macro CALLMONITOR
0630					endif 
0630			.ff1:   	 
0630 e5					push hl 
0631 c5					push bc 
0632 d5					push de 
0633 cd 5f 02				call se_readbyte 
0636 5f					ld e,a 
0637 23					inc hl 
0638 cd 5f 02				call se_readbyte 
063b 57					ld d, a 
063c e1					pop hl 
063d e5					push hl 
063e cd 1f 0d				call cmp16 
0641 28 49				jr z, .fffound 
0643			 
0643 d1					pop de 
0644 c1					pop bc 
0645 e1					pop hl 
0646			 
0646					; is found? 
0646					;cp e 
0646					;ret z 
0646			 
0646 3e 40				ld a, STORE_BLOCK_PHY 
0648 cd 01 0d				call addatohl 
064b 10 e3				djnz .ff1 
064d			 
064d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
064f			.ff2:   	 
064f			 
064f e5					push hl 
0650 c5					push bc 
0651 d5					push de 
0652 cd 5f 02				call se_readbyte 
0655 5f					ld e,a 
0656 23					inc hl 
0657 cd 5f 02				call se_readbyte 
065a 57					ld d, a 
065b			 
065b e1					pop hl 
065c e5					push hl 
065d cd 1f 0d				call cmp16 
0660 28 2a				jr z, .fffound 
0662			 
0662 d1					pop de 
0663 c1					pop bc 
0664 e1					pop hl 
0665					; is found? 
0665					;cp e 
0665					;ret z 
0665			 
0665 3e 40				ld a, STORE_BLOCK_PHY 
0667 cd 01 0d				call addatohl 
066a 10 e3				djnz .ff2 
066c			 
066c			 
066c					if DEBUG_FORTH_WORDS 
066c					DMARK "FN-" 
066c f5				push af  
066d 3a 81 06			ld a, (.dmark)  
0670 32 b4 fb			ld (debug_mark),a  
0673 3a 82 06			ld a, (.dmark+1)  
0676 32 b5 fb			ld (debug_mark+1),a  
0679 3a 83 06			ld a, (.dmark+2)  
067c 32 b6 fb			ld (debug_mark+2),a  
067f 18 03			jr .pastdmark  
0681 ..			.dmark: db "FN-"  
0684 f1			.pastdmark: pop af  
0685			endm  
# End of macro DMARK
0685					;	push af 
0685					;	ld a, 'n' 
0685					;	ld (debug_mark),a 
0685					;	pop af 
0685						CALLMONITOR 
0685 cd 7e 16			call break_point_state  
0688				endm  
# End of macro CALLMONITOR
0688					endif 
0688				; no free marks! 
0688 21 00 00				ld hl, 0 
068b c9				ret 
068c			.fffound: 
068c				 
068c			 
068c d1					pop de 
068d c1					pop bc 
068e e1					pop hl 
068f					if DEBUG_FORTH_WORDS 
068f					DMARK "FNF" 
068f f5				push af  
0690 3a a4 06			ld a, (.dmark)  
0693 32 b4 fb			ld (debug_mark),a  
0696 3a a5 06			ld a, (.dmark+1)  
0699 32 b5 fb			ld (debug_mark+1),a  
069c 3a a6 06			ld a, (.dmark+2)  
069f 32 b6 fb			ld (debug_mark+2),a  
06a2 18 03			jr .pastdmark  
06a4 ..			.dmark: db "FNF"  
06a7 f1			.pastdmark: pop af  
06a8			endm  
# End of macro DMARK
06a8					;	push af 
06a8					;	ld a, 'n' 
06a8					;	ld (debug_mark),a 
06a8					;	pop af 
06a8						CALLMONITOR 
06a8 cd 7e 16			call break_point_state  
06ab				endm  
# End of macro CALLMONITOR
06ab					endif 
06ab c9				ret 
06ac			 
06ac			 
06ac			 
06ac			; Free Space 
06ac			; ---------- 
06ac			; 
06ac			; With current bank 
06ac			; 
06ac			; Set block count to zero 
06ac			; Starting with first logical block 
06ac			;      Find free block  
06ac			;      If block id given, increment block count 
06ac			; 
06ac			;  
06ac			 
06ac			 
06ac			; hl contains count of free blocks 
06ac			 
06ac			storage_freeblocks: 
06ac			 
06ac				; now locate first 0 page to mark as a free block 
06ac			 
06ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06ae 21 40 00			ld hl, STORE_BLOCK_PHY 
06b1 11 00 00			ld de, 0 
06b4			 
06b4			.fb1:   	 
06b4 e5					push hl 
06b5 c5					push bc 
06b6 d5					push de 
06b7 cd 5f 02				call se_readbyte 
06ba d1					pop de 
06bb c1					pop bc 
06bc e1					pop hl 
06bd			 
06bd					; is free? 
06bd fe 00				cp 0 
06bf 20 01				jr nz, .ff1cont 
06c1 13					inc de 
06c2			 
06c2			.ff1cont: 
06c2			 
06c2			 
06c2 3e 40				ld a, STORE_BLOCK_PHY 
06c4 cd 01 0d				call addatohl 
06c7 10 eb				djnz .fb1 
06c9			 
06c9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06cb			.fb2:   	 
06cb e5					push hl 
06cc c5					push bc 
06cd d5					push de 
06ce cd 5f 02				call se_readbyte 
06d1 d1					pop de 
06d2 c1					pop bc 
06d3 e1					pop hl 
06d4			 
06d4					; is free? 
06d4 fe 00				cp 0 
06d6 20 01				jr nz, .ff2cont 
06d8 13					inc de 
06d9			 
06d9			.ff2cont: 
06d9			 
06d9 3e 40				ld a, STORE_BLOCK_PHY 
06db cd 01 0d				call addatohl 
06de 10 eb				djnz .fb2 
06e0			 
06e0 eb				ex de, hl 
06e1 c9				ret 
06e2			 
06e2			; Get File ID 
06e2			; ----------- 
06e2			; 
06e2			; With current bank 
06e2			;  
06e2			; Load Block 0 Config 
06e2			; Get max file id number 
06e2			; For each logical block 
06e2			;    Read block file id 
06e2			;      If first block of file and dont have file id 
06e2			;         if file get id and exit 
06e2			 
06e2			 
06e2			 
06e2			 
06e2			; Create File 
06e2			; ----------- 
06e2			; 
06e2			; With current bank  
06e2			; Load Block 0 Config 
06e2			; Get max file id number 
06e2			; Increment file id number 
06e2			; Save Config 
06e2			; Find free block 
06e2			; Set buffer with file name and file id 
06e2			; Write buffer to free block  
06e2			 
06e2			 
06e2			; hl point to file name 
06e2			; hl returns file id 
06e2			 
06e2			; file format: 
06e2			; byte 0 - file id 
06e2			; byte 1 - extent number 
06e2			; byte 2-> data 
06e2			 
06e2			; format for extent number 0: 
06e2			; 
06e2			; byte 0 - file id 
06e2			; byte 1 - extent 0 
06e2			; byte 2 - extent count 
06e2			; byte 3 -> file name and meta data 
06e2			 
06e2			 
06e2			storage_create: 
06e2				if DEBUG_STORESE 
06e2					DMARK "SCR" 
06e2 f5				push af  
06e3 3a f7 06			ld a, (.dmark)  
06e6 32 b4 fb			ld (debug_mark),a  
06e9 3a f8 06			ld a, (.dmark+1)  
06ec 32 b5 fb			ld (debug_mark+1),a  
06ef 3a f9 06			ld a, (.dmark+2)  
06f2 32 b6 fb			ld (debug_mark+2),a  
06f5 18 03			jr .pastdmark  
06f7 ..			.dmark: db "SCR"  
06fa f1			.pastdmark: pop af  
06fb			endm  
# End of macro DMARK
06fb					CALLMONITOR 
06fb cd 7e 16			call break_point_state  
06fe				endm  
# End of macro CALLMONITOR
06fe				endif 
06fe			 
06fe e5				push hl		; save file name pointer 
06ff			 
06ff cd 90 03			call storage_get_block_0 
0702			 
0702 3a df f9			ld a,(store_page)	; get current file id 
0705 3c				inc a 
0706 32 df f9			ld (store_page),a 
0709				 
0709 32 d8 f9			ld (store_tmpid),a			; save id 
070c			 
070c 21 00 00			ld hl, 0 
070f 11 df f9			ld de, store_page 
0712				if DEBUG_STORESE 
0712					DMARK "SCw" 
0712 f5				push af  
0713 3a 27 07			ld a, (.dmark)  
0716 32 b4 fb			ld (debug_mark),a  
0719 3a 28 07			ld a, (.dmark+1)  
071c 32 b5 fb			ld (debug_mark+1),a  
071f 3a 29 07			ld a, (.dmark+2)  
0722 32 b6 fb			ld (debug_mark+2),a  
0725 18 03			jr .pastdmark  
0727 ..			.dmark: db "SCw"  
072a f1			.pastdmark: pop af  
072b			endm  
# End of macro DMARK
072b					CALLMONITOR 
072b cd 7e 16			call break_point_state  
072e				endm  
# End of macro CALLMONITOR
072e				endif 
072e cd 44 03			call storage_write_block	 ; save update 
0731			 
0731				if DEBUG_STORESE 
0731 11 df f9				ld de, store_page 
0734					DMARK "SCC" 
0734 f5				push af  
0735 3a 49 07			ld a, (.dmark)  
0738 32 b4 fb			ld (debug_mark),a  
073b 3a 4a 07			ld a, (.dmark+1)  
073e 32 b5 fb			ld (debug_mark+1),a  
0741 3a 4b 07			ld a, (.dmark+2)  
0744 32 b6 fb			ld (debug_mark+2),a  
0747 18 03			jr .pastdmark  
0749 ..			.dmark: db "SCC"  
074c f1			.pastdmark: pop af  
074d			endm  
# End of macro DMARK
074d					CALLMONITOR 
074d cd 7e 16			call break_point_state  
0750				endm  
# End of macro CALLMONITOR
0750				endif 
0750				;  
0750				 
0750 21 40 00			ld hl, STORE_BLOCK_PHY 
0753 11 00 00			ld de, 0 
0756 cd 12 06			call storage_findnextid 
0759			 
0759 22 c9 f9			ld (store_tmppageid), hl    ; save page to use  
075c			 
075c				; TODO detect 0 = no spare blocks 
075c			 
075c				; hl now contains the free page to use for the file header page 
075c			 
075c				if DEBUG_STORESE 
075c				DMARK "SCF" 
075c f5				push af  
075d 3a 71 07			ld a, (.dmark)  
0760 32 b4 fb			ld (debug_mark),a  
0763 3a 72 07			ld a, (.dmark+1)  
0766 32 b5 fb			ld (debug_mark+1),a  
0769 3a 73 07			ld a, (.dmark+2)  
076c 32 b6 fb			ld (debug_mark+2),a  
076f 18 03			jr .pastdmark  
0771 ..			.dmark: db "SCF"  
0774 f1			.pastdmark: pop af  
0775			endm  
# End of macro DMARK
0775					CALLMONITOR 
0775 cd 7e 16			call break_point_state  
0778				endm  
# End of macro CALLMONITOR
0778				endif 
0778			 
0778 22 c9 f9			ld (store_tmppageid), hl 
077b				 
077b 3a d8 f9			ld a,(store_tmpid)    ; get file id 
077e			;	ld a, (store_filecache)			; save to cache 
077e			 
077e 32 df f9			ld (store_page),a    ; set page id 
0781 3e 00			ld a, 0			 ; extent 0 is file header 
0783 32 e0 f9			ld (store_page+1), a   ; set file extent 
0786			 
0786 32 e1 f9			ld (store_page+2), a   ; extent count for the file 
0789			 
0789			;	inc hl 		; init block 0 of file 
0789			;	inc hl   		; skip file and extent id 
0789			 ;       ld a, 0 
0789			;	ld (hl),a 
0789			;	ld a, (store_filecache+1)  	; save to cache 
0789			 
0789			;	inc hl    ; file name 
0789				 
0789				 
0789 11 e2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
078c				if DEBUG_STORESE 
078c					DMARK "SCc" 
078c f5				push af  
078d 3a a1 07			ld a, (.dmark)  
0790 32 b4 fb			ld (debug_mark),a  
0793 3a a2 07			ld a, (.dmark+1)  
0796 32 b5 fb			ld (debug_mark+1),a  
0799 3a a3 07			ld a, (.dmark+2)  
079c 32 b6 fb			ld (debug_mark+2),a  
079f 18 03			jr .pastdmark  
07a1 ..			.dmark: db "SCc"  
07a4 f1			.pastdmark: pop af  
07a5			endm  
# End of macro DMARK
07a5					CALLMONITOR 
07a5 cd 7e 16			call break_point_state  
07a8				endm  
# End of macro CALLMONITOR
07a8				endif 
07a8 e1				pop hl    ; get zero term string 
07a9 e5				push hl 
07aa 3e 00			ld a, 0 
07ac cd 6a 11			call strlent 
07af 23				inc hl   ; cover zero term 
07b0 06 00			ld b,0 
07b2 4d				ld c,l 
07b3 e1				pop hl 
07b4				;ex de, hl 
07b4				if DEBUG_STORESE 
07b4					DMARK "SCa" 
07b4 f5				push af  
07b5 3a c9 07			ld a, (.dmark)  
07b8 32 b4 fb			ld (debug_mark),a  
07bb 3a ca 07			ld a, (.dmark+1)  
07be 32 b5 fb			ld (debug_mark+1),a  
07c1 3a cb 07			ld a, (.dmark+2)  
07c4 32 b6 fb			ld (debug_mark+2),a  
07c7 18 03			jr .pastdmark  
07c9 ..			.dmark: db "SCa"  
07cc f1			.pastdmark: pop af  
07cd			endm  
# End of macro DMARK
07cd					;push af 
07cd					;ld a, 'a' 
07cd					;ld (debug_mark),a 
07cd					;pop af 
07cd					CALLMONITOR 
07cd cd 7e 16			call break_point_state  
07d0				endm  
# End of macro CALLMONITOR
07d0				endif 
07d0 ed b0			ldir    ; copy zero term string 
07d2				if DEBUG_STORESE 
07d2					DMARK "SCA" 
07d2 f5				push af  
07d3 3a e7 07			ld a, (.dmark)  
07d6 32 b4 fb			ld (debug_mark),a  
07d9 3a e8 07			ld a, (.dmark+1)  
07dc 32 b5 fb			ld (debug_mark+1),a  
07df 3a e9 07			ld a, (.dmark+2)  
07e2 32 b6 fb			ld (debug_mark+2),a  
07e5 18 03			jr .pastdmark  
07e7 ..			.dmark: db "SCA"  
07ea f1			.pastdmark: pop af  
07eb			endm  
# End of macro DMARK
07eb					CALLMONITOR 
07eb cd 7e 16			call break_point_state  
07ee				endm  
# End of macro CALLMONITOR
07ee				endif 
07ee			 
07ee				; write file header page 
07ee			 
07ee 2a c9 f9			ld hl,(store_tmppageid) 
07f1 11 df f9			ld de, store_page 
07f4				if DEBUG_STORESE 
07f4					DMARK "SCb" 
07f4 f5				push af  
07f5 3a 09 08			ld a, (.dmark)  
07f8 32 b4 fb			ld (debug_mark),a  
07fb 3a 0a 08			ld a, (.dmark+1)  
07fe 32 b5 fb			ld (debug_mark+1),a  
0801 3a 0b 08			ld a, (.dmark+2)  
0804 32 b6 fb			ld (debug_mark+2),a  
0807 18 03			jr .pastdmark  
0809 ..			.dmark: db "SCb"  
080c f1			.pastdmark: pop af  
080d			endm  
# End of macro DMARK
080d					;push af 
080d					;ld a, 'b' 
080d					;ld (debug_mark),a 
080d					;pop af 
080d					CALLMONITOR 
080d cd 7e 16			call break_point_state  
0810				endm  
# End of macro CALLMONITOR
0810				endif 
0810 cd 44 03			call storage_write_block 
0813			 
0813 3a d8 f9			ld a, (store_tmpid) 
0816 6f				ld l, a 
0817 26 00			ld h,0 
0819				if DEBUG_STORESE 
0819					DMARK "SCz" 
0819 f5				push af  
081a 3a 2e 08			ld a, (.dmark)  
081d 32 b4 fb			ld (debug_mark),a  
0820 3a 2f 08			ld a, (.dmark+1)  
0823 32 b5 fb			ld (debug_mark+1),a  
0826 3a 30 08			ld a, (.dmark+2)  
0829 32 b6 fb			ld (debug_mark+2),a  
082c 18 03			jr .pastdmark  
082e ..			.dmark: db "SCz"  
0831 f1			.pastdmark: pop af  
0832			endm  
# End of macro DMARK
0832					CALLMONITOR 
0832 cd 7e 16			call break_point_state  
0835				endm  
# End of macro CALLMONITOR
0835				endif 
0835 c9				ret 
0836				 
0836			 
0836			 
0836			; 
0836			; Read File 
0836			; 
0836			; h - file id to locate 
0836			; l - extent to locate 
0836			; de - pointer to string to read into 
0836			; 
0836			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0836			 
0836			.sr_fail: 
0836 d1				pop de 
0837 c9				ret 
0838			 
0838			storage_read: 
0838 d5				push de 
0839			 
0839			; TODO BUG the above push is it popped before the RET Z? 
0839			 
0839			; TODO how to handle multiple part blocks 
0839			 
0839				; locate file extent to read 
0839			 
0839 5c				ld e, h 
083a 55				ld d, l 
083b 21 40 00			ld hl, STORE_BLOCK_PHY 
083e				if DEBUG_STORESE 
083e					DMARK "SRE" 
083e f5				push af  
083f 3a 53 08			ld a, (.dmark)  
0842 32 b4 fb			ld (debug_mark),a  
0845 3a 54 08			ld a, (.dmark+1)  
0848 32 b5 fb			ld (debug_mark+1),a  
084b 3a 55 08			ld a, (.dmark+2)  
084e 32 b6 fb			ld (debug_mark+2),a  
0851 18 03			jr .pastdmark  
0853 ..			.dmark: db "SRE"  
0856 f1			.pastdmark: pop af  
0857			endm  
# End of macro DMARK
0857					CALLMONITOR 
0857 cd 7e 16			call break_point_state  
085a				endm  
# End of macro CALLMONITOR
085a				endif 
085a cd 12 06			call storage_findnextid 
085d			 
085d				if DEBUG_STORESE 
085d					DMARK "SRf" 
085d f5				push af  
085e 3a 72 08			ld a, (.dmark)  
0861 32 b4 fb			ld (debug_mark),a  
0864 3a 73 08			ld a, (.dmark+1)  
0867 32 b5 fb			ld (debug_mark+1),a  
086a 3a 74 08			ld a, (.dmark+2)  
086d 32 b6 fb			ld (debug_mark+2),a  
0870 18 03			jr .pastdmark  
0872 ..			.dmark: db "SRf"  
0875 f1			.pastdmark: pop af  
0876			endm  
# End of macro DMARK
0876					CALLMONITOR 
0876 cd 7e 16			call break_point_state  
0879				endm  
# End of macro CALLMONITOR
0879				endif 
0879 cd 2a 0d			call ishlzero 
087c			;	ld a, l 
087c			;	add h 
087c			;	cp 0 
087c 28 b8			jr z,.sr_fail			; block not found so EOF 
087e			 
087e				; hl contains page number to load 
087e d1				pop de   ; get storage 
087f d5				push de 
0880				if DEBUG_STORESE 
0880					DMARK "SRg" 
0880 f5				push af  
0881 3a 95 08			ld a, (.dmark)  
0884 32 b4 fb			ld (debug_mark),a  
0887 3a 96 08			ld a, (.dmark+1)  
088a 32 b5 fb			ld (debug_mark+1),a  
088d 3a 97 08			ld a, (.dmark+2)  
0890 32 b6 fb			ld (debug_mark+2),a  
0893 18 03			jr .pastdmark  
0895 ..			.dmark: db "SRg"  
0898 f1			.pastdmark: pop af  
0899			endm  
# End of macro DMARK
0899					CALLMONITOR 
0899 cd 7e 16			call break_point_state  
089c				endm  
# End of macro CALLMONITOR
089c				endif 
089c cd df 02			call storage_read_block 
089f			 
089f			 
089f			; TODO if block has no zeros then need to read next block  
089f			 
089f			 
089f					 
089f e1				pop hl 		 ; return start of data to show as not EOF 
08a0 23				inc hl   ; past file id 
08a1 23				inc hl   ; past ext 
08a2				if DEBUG_STORESE 
08a2					DMARK "SRe" 
08a2 f5				push af  
08a3 3a b7 08			ld a, (.dmark)  
08a6 32 b4 fb			ld (debug_mark),a  
08a9 3a b8 08			ld a, (.dmark+1)  
08ac 32 b5 fb			ld (debug_mark+1),a  
08af 3a b9 08			ld a, (.dmark+2)  
08b2 32 b6 fb			ld (debug_mark+2),a  
08b5 18 03			jr .pastdmark  
08b7 ..			.dmark: db "SRe"  
08ba f1			.pastdmark: pop af  
08bb			endm  
# End of macro DMARK
08bb					CALLMONITOR 
08bb cd 7e 16			call break_point_state  
08be				endm  
# End of macro CALLMONITOR
08be				endif 
08be c9					ret 
08bf			 
08bf			 
08bf			 
08bf			; 
08bf			; Append File 
08bf			; 
08bf			; hl - file id to locate 
08bf			; de - pointer to (multi block) string to write 
08bf			 
08bf			.sa_notfound: 
08bf d1				pop de 
08c0 c9				ret 
08c1			 
08c1			 
08c1			storage_append: 
08c1				; hl -  file id to append to 
08c1				; de - string to append 
08c1			 
08c1 d5				push de 
08c2				 
08c2				if DEBUG_STORESE 
08c2					DMARK "AP1" 
08c2 f5				push af  
08c3 3a d7 08			ld a, (.dmark)  
08c6 32 b4 fb			ld (debug_mark),a  
08c9 3a d8 08			ld a, (.dmark+1)  
08cc 32 b5 fb			ld (debug_mark+1),a  
08cf 3a d9 08			ld a, (.dmark+2)  
08d2 32 b6 fb			ld (debug_mark+2),a  
08d5 18 03			jr .pastdmark  
08d7 ..			.dmark: db "AP1"  
08da f1			.pastdmark: pop af  
08db			endm  
# End of macro DMARK
08db					CALLMONITOR 
08db cd 7e 16			call break_point_state  
08de				endm  
# End of macro CALLMONITOR
08de				endif 
08de			 
08de 7d				ld a, l 
08df 32 d8 f9			ld (store_tmpid), a 
08e2			 
08e2				; get file header  
08e2			 
08e2 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08e4 3a d8 f9			ld a, (store_tmpid) 
08e7 5f				ld e, a 
08e8			 
08e8 21 40 00				ld hl, STORE_BLOCK_PHY 
08eb cd 12 06				call storage_findnextid 
08ee			 
08ee cd 2a 0d			call ishlzero 
08f1 28 cc			jr z, .sa_notfound 
08f3			 
08f3 22 c9 f9			ld (store_tmppageid), hl 
08f6			 
08f6				; TODO handle file id not found 
08f6			 
08f6				if DEBUG_STORESE 
08f6					DMARK "AP2" 
08f6 f5				push af  
08f7 3a 0b 09			ld a, (.dmark)  
08fa 32 b4 fb			ld (debug_mark),a  
08fd 3a 0c 09			ld a, (.dmark+1)  
0900 32 b5 fb			ld (debug_mark+1),a  
0903 3a 0d 09			ld a, (.dmark+2)  
0906 32 b6 fb			ld (debug_mark+2),a  
0909 18 03			jr .pastdmark  
090b ..			.dmark: db "AP2"  
090e f1			.pastdmark: pop af  
090f			endm  
# End of macro DMARK
090f					CALLMONITOR 
090f cd 7e 16			call break_point_state  
0912				endm  
# End of macro CALLMONITOR
0912				endif 
0912			 
0912				; update file extent count 
0912			 
0912 11 df f9			ld de, store_page 
0915			 
0915 cd df 02			call storage_read_block 
0918			 
0918				if DEBUG_STORESE 
0918					DMARK "AP3" 
0918 f5				push af  
0919 3a 2d 09			ld a, (.dmark)  
091c 32 b4 fb			ld (debug_mark),a  
091f 3a 2e 09			ld a, (.dmark+1)  
0922 32 b5 fb			ld (debug_mark+1),a  
0925 3a 2f 09			ld a, (.dmark+2)  
0928 32 b6 fb			ld (debug_mark+2),a  
092b 18 03			jr .pastdmark  
092d ..			.dmark: db "AP3"  
0930 f1			.pastdmark: pop af  
0931			endm  
# End of macro DMARK
0931					CALLMONITOR 
0931 cd 7e 16			call break_point_state  
0934				endm  
# End of macro CALLMONITOR
0934				endif 
0934			;	ld (store_tmppageid), hl 
0934			 
0934 3a e1 f9			ld a, (store_page+2) 
0937 3c				inc a 
0938 32 e1 f9			ld (store_page+2), a 
093b 32 d7 f9			ld (store_tmpext), a 
093e				 
093e				if DEBUG_STORESE 
093e					DMARK "AP3" 
093e f5				push af  
093f 3a 53 09			ld a, (.dmark)  
0942 32 b4 fb			ld (debug_mark),a  
0945 3a 54 09			ld a, (.dmark+1)  
0948 32 b5 fb			ld (debug_mark+1),a  
094b 3a 55 09			ld a, (.dmark+2)  
094e 32 b6 fb			ld (debug_mark+2),a  
0951 18 03			jr .pastdmark  
0953 ..			.dmark: db "AP3"  
0956 f1			.pastdmark: pop af  
0957			endm  
# End of macro DMARK
0957					CALLMONITOR 
0957 cd 7e 16			call break_point_state  
095a				endm  
# End of macro CALLMONITOR
095a				endif 
095a 2a c9 f9			ld hl, (store_tmppageid) 
095d 11 df f9			ld de, store_page 
0960 cd 44 03			call storage_write_block 
0963			 
0963				; find free block 
0963			 
0963 11 00 00			ld de, 0			 ; file extent to locate 
0966			 
0966 21 40 00				ld hl, STORE_BLOCK_PHY 
0969 cd 12 06				call storage_findnextid 
096c cd 2a 0d			call ishlzero 
096f ca bf 08			jp z, .sa_notfound 
0972			 
0972					; TODO handle no space left 
0972					 
0972 22 c9 f9				ld (store_tmppageid), hl 
0975			 
0975				if DEBUG_STORESE 
0975					DMARK "AP4" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 b4 fb			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 b5 fb			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 b6 fb			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "AP4"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 7e 16			call break_point_state  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991					; init the buffer with zeros so we can id if the buffer is full or not 
0991			 
0991 e5					push hl 
0992 c5					push bc 
0993			 
0993 21 df f9				ld hl, store_page 
0996 06 40				ld b, STORE_BLOCK_PHY 
0998 3e 00				ld a, 0 
099a 77			.zeroblock:	ld (hl), a 
099b 23					inc hl 
099c 10 fc				djnz .zeroblock 
099e			 
099e c1					pop bc 
099f e1					pop hl 
09a0			 
09a0					; construct block 
09a0			 
09a0 3a d8 f9				ld a, (store_tmpid) 
09a3 32 df f9				ld (store_page), a   ; file id 
09a6 3a d7 f9				ld a, (store_tmpext)   ; extent for this block 
09a9 32 e0 f9				ld (store_page+1), a 
09ac			 
09ac e1					pop hl    ; get string to write 
09ad 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09af 11 e1 f9				ld de, store_page+2 
09b2			 
09b2				if DEBUG_STORESE 
09b2					DMARK "AP5" 
09b2 f5				push af  
09b3 3a c7 09			ld a, (.dmark)  
09b6 32 b4 fb			ld (debug_mark),a  
09b9 3a c8 09			ld a, (.dmark+1)  
09bc 32 b5 fb			ld (debug_mark+1),a  
09bf 3a c9 09			ld a, (.dmark+2)  
09c2 32 b6 fb			ld (debug_mark+2),a  
09c5 18 03			jr .pastdmark  
09c7 ..			.dmark: db "AP5"  
09ca f1			.pastdmark: pop af  
09cb			endm  
# End of macro DMARK
09cb					CALLMONITOR 
09cb cd 7e 16			call break_point_state  
09ce				endm  
# End of macro CALLMONITOR
09ce				endif 
09ce			 
09ce			 
09ce			 
09ce					; fill buffer with data until end of string or full block 
09ce			 
09ce 7e			.appd:		ld a, (hl) 
09cf 12					ld (de), a 
09d0 fe 00				cp 0 
09d2 28 04				jr z, .appdone 
09d4 23					inc hl 
09d5 13					inc de 
09d6 10 f6				djnz .appd 
09d8			 
09d8 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d9 f5					push af   		; save last byte dumped 
09da			 
09da			 
09da 2a c9 f9			ld hl, (store_tmppageid) 
09dd 11 df f9			ld de, store_page 
09e0				if DEBUG_STORESE 
09e0					DMARK "AP6" 
09e0 f5				push af  
09e1 3a f5 09			ld a, (.dmark)  
09e4 32 b4 fb			ld (debug_mark),a  
09e7 3a f6 09			ld a, (.dmark+1)  
09ea 32 b5 fb			ld (debug_mark+1),a  
09ed 3a f7 09			ld a, (.dmark+2)  
09f0 32 b6 fb			ld (debug_mark+2),a  
09f3 18 03			jr .pastdmark  
09f5 ..			.dmark: db "AP6"  
09f8 f1			.pastdmark: pop af  
09f9			endm  
# End of macro DMARK
09f9					CALLMONITOR 
09f9 cd 7e 16			call break_point_state  
09fc				endm  
# End of macro CALLMONITOR
09fc				endif 
09fc cd 44 03				call storage_write_block 
09ff			 
09ff			 
09ff				; was that a full block of data written? 
09ff				; any more to write out? 
09ff			 
09ff				; if yes then set vars and jump to start of function again 
09ff			 
09ff f1					pop af 
0a00 d1					pop de 
0a01			 
0a01 fe 00				cp 0		 ; no, string was fully written 
0a03 c8					ret z 
0a04			 
0a04					; setup vars for next cycle 
0a04			 
0a04 3a d8 f9				ld a, (store_tmpid) 
0a07 6f					ld l, a 
0a08 26 00				ld h, 0 
0a0a			 
0a0a c3 c1 08			 	jp storage_append	 ; yes, need to write out some more 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			if DEBUG_STORECF 
0a0d			storageput:	 
0a0d					ret 
0a0d			storageread: 
0a0d					ld hl, store_page 
0a0d					ld b, 200 
0a0d					ld a,0 
0a0d			.src:		ld (hl),a 
0a0d					inc hl 
0a0d					djnz .src 
0a0d					 
0a0d			 
0a0d					ld de, 0 
0a0d					ld bc, 1 
0a0d					ld hl, store_page 
0a0d					call cfRead 
0a0d			 
0a0d				call cfGetError 
0a0d				ld hl,scratch 
0a0d				call hexout 
0a0d				ld hl, scratch+2 
0a0d				ld a, 0 
0a0d				ld (hl),a 
0a0d				ld de, scratch 
0a0d				ld a,display_row_1 
0a0d				call str_at_display 
0a0d				call update_display 
0a0d			 
0a0d					ld hl, store_page 
0a0d					ld (os_cur_ptr),hl 
0a0d			 
0a0d					ret 
0a0d			endif 
0a0d			 
0a0d			 
0a0d			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0d			 
0a0d			storage_clear_page: 
0a0d e5				push hl 
0a0e d5				push de 
0a0f c5				push bc 
0a10 21 df f9			ld hl, store_page 
0a13 3e 00			ld a, 0 
0a15 77				ld (hl), a 
0a16			 
0a16 11 e0 f9			ld de, store_page+1 
0a19 01 40 00			ld bc, STORE_BLOCK_PHY 
0a1c			 
0a1c ed b0			ldir 
0a1e				 
0a1e c1				pop bc 
0a1f d1				pop de 
0a20 e1				pop hl 
0a21 c9				ret 
0a22			 
0a22			; eof 
# End of file firmware_storage.asm
0a22			  
0a22			; support routines for above hardware abstraction layer  
0a22			  
0a22			include "firmware_general.asm"        ; general support functions  
0a22			 
0a22			; word look up 
0a22			 
0a22			; in 
0a22			; a is the index 
0a22			; hl is pointer start of array 
0a22			; 
0a22			; returns 
0a22			; hl to the word 
0a22			; 
0a22			 
0a22			table_lookup:  
0a22 d5					push de 
0a23 eb					ex de, hl 
0a24			 
0a24 6f					ld l, a 
0a25 26 00				ld h, 0 
0a27 29					add hl, hl 
0a28 19					add hl, de 
0a29 7e					ld a, (hl) 
0a2a 23					inc hl 
0a2b 66					ld h,(hl) 
0a2c 6f					ld l, a 
0a2d			 
0a2d d1					pop de 
0a2e c9					ret 
0a2f			 
0a2f			; Delay loops 
0a2f			 
0a2f			 
0a2f			 
0a2f			aDelayInMS: 
0a2f c5				push bc 
0a30 47				ld b,a 
0a31			msdelay: 
0a31 c5				push bc 
0a32				 
0a32			 
0a32 01 41 00			ld bc,041h 
0a35 cd 4d 0a			call delayloop 
0a38 c1				pop bc 
0a39 05				dec b 
0a3a 20 f5			jr nz,msdelay 
0a3c			 
0a3c			;if CPU_CLOCK_8MHZ 
0a3c			;msdelay8: 
0a3c			;	push bc 
0a3c			;	 
0a3c			; 
0a3c			;	ld bc,041h 
0a3c			;	call delayloop 
0a3c			;	pop bc 
0a3c			;	dec b 
0a3c			;	jr nz,msdelay8 
0a3c			;endif 
0a3c			 
0a3c			 
0a3c c1				pop bc 
0a3d c9				ret 
0a3e			 
0a3e			 
0a3e			delay250ms: 
0a3e				;push de 
0a3e 01 00 40			ld bc, 04000h 
0a41 c3 4d 0a			jp delayloop 
0a44			delay500ms: 
0a44				;push de 
0a44 01 00 80			ld bc, 08000h 
0a47 c3 4d 0a			jp delayloop 
0a4a			delay1s: 
0a4a				;push bc 
0a4a			   ; Clobbers A, d and e 
0a4a 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a4d			delayloop: 
0a4d c5			    push bc 
0a4e			 
0a4e			if BASE_CPM 
0a4e				ld bc, CPM_DELAY_TUNE 
0a4e			.cpmloop: 
0a4e				push bc 
0a4e			 
0a4e			endif 
0a4e			 
0a4e			 
0a4e			 
0a4e			delayloopi: 
0a4e			;	push bc 
0a4e			;.dl: 
0a4e cb 47		    bit     0,a    	; 8 
0a50 cb 47		    bit     0,a    	; 8 
0a52 cb 47		    bit     0,a    	; 8 
0a54 e6 ff		    and     255  	; 7 
0a56 0b			    dec     bc      	; 6 
0a57 79			    ld      a,c     	; 4 
0a58 b0			    or      b     	; 4 
0a59 c2 4e 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a5c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a5c				;pop de 
0a5c			;pop bc 
0a5c			 
0a5c			if BASE_CPM 
0a5c				pop bc 
0a5c				 
0a5c			    dec     bc      	; 6 
0a5c			    ld      a,c     	; 4 
0a5c			    or      b     	; 4 
0a5c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a5c				 
0a5c			 
0a5c			endif 
0a5c			;if CPU_CLOCK_8MHZ 
0a5c			;    pop bc 
0a5c			;    push bc 
0a5c			;.dl8: 
0a5c			;    bit     0,a    	; 8 
0a5c			;    bit     0,a    	; 8 
0a5c			;    bit     0,a    	; 8 
0a5c			;    and     255  	; 7 
0a5c			;    dec     bc      	; 6 
0a5c			;    ld      a,c     	; 4 
0a5c			;    or      b     	; 4 
0a5c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a5c			;endif 
0a5c			 
0a5c			;if CPU_CLOCK_10MHZ 
0a5c			;    pop bc 
0a5c			;    push bc 
0a5c			;.dl8: 
0a5c			;    bit     0,a    	; 8 
0a5c			;    bit     0,a    	; 8 
0a5c			;    bit     0,a    	; 8 
0a5c			;    and     255  	; 7 
0a5c			;    dec     bc      	; 6 
0a5c			;    ld      a,c     	; 4 
0a5c			;    or      b     	; 4 
0a5c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a5c			;endif 
0a5c c1			    pop bc 
0a5d			 
0a5d c9				ret 
0a5e			 
0a5e			 
0a5e			 
0a5e			; eof 
# End of file firmware_general.asm
0a5e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a5e			; display routines that use the physical hardware abstraction layer 
0a5e			 
0a5e			 
0a5e			; information window 
0a5e			 
0a5e			; pass hl with 1st string to display 
0a5e			; pass de with 2nd string to display 
0a5e			 
0a5e			info_panel: 
0a5e e5				push hl 
0a5f			 
0a5f 2a 55 fa			ld hl, (display_fb_active) 
0a62 e5				push hl    ; future de destination 
0a63 21 4a fb				ld hl, display_fb0 
0a66 22 55 fa				ld (display_fb_active), hl 
0a69			 
0a69			;	call clear_display 
0a69			 
0a69				if BASE_CPM 
0a69				ld a, '.' 
0a69				else 
0a69 3e a5			ld a, 165 
0a6b				endif 
0a6b cd d2 0a			call fill_display 
0a6e			 
0a6e			 
0a6e 3e 2d			ld a, display_row_3 + 5 
0a70 cd e0 0a			call str_at_display 
0a73			 
0a73 e1				pop hl 
0a74 d1				pop de 
0a75			 
0a75 e5				push hl 
0a76			 
0a76			 
0a76 3e 19			ld a, display_row_2 + 5 
0a78 cd e0 0a			call str_at_display 
0a7b			 
0a7b			 
0a7b cd f0 0a			call update_display 
0a7e cd 53 1c			call next_page_prompt 
0a81 cd cd 0a			call clear_display 
0a84			 
0a84				 
0a84 21 f9 fa				ld hl, display_fb1 
0a87 22 55 fa				ld (display_fb_active), hl 
0a8a cd f0 0a			call update_display 
0a8d			 
0a8d e1				pop hl 
0a8e			 
0a8e c9				ret 
0a8f			 
0a8f			 
0a8f			 
0a8f			 
0a8f			; TODO windowing? 
0a8f			 
0a8f			; TODO scroll line up 
0a8f			 
0a8f			scroll_up: 
0a8f			 
0a8f e5				push hl 
0a90 d5				push de 
0a91 c5				push bc 
0a92			 
0a92				; get frame buffer  
0a92			 
0a92 2a 55 fa			ld hl, (display_fb_active) 
0a95 e5				push hl    ; future de destination 
0a96			 
0a96 11 14 00			ld  de, display_cols 
0a99 19				add hl, de 
0a9a			 
0a9a d1				pop de 
0a9b			 
0a9b				;ex de, hl 
0a9b 01 4f 00			ld bc, display_fb_len -1  
0a9e			;if DEBUG_FORTH_WORDS 
0a9e			;	DMARK "SCL" 
0a9e			;	CALLMONITOR 
0a9e			;endif	 
0a9e ed b0			ldir 
0aa0			 
0aa0				; wipe bottom row 
0aa0			 
0aa0			 
0aa0 2a 55 fa			ld hl, (display_fb_active) 
0aa3 11 50 00			ld de, display_cols*display_rows 
0aa6 19				add hl, de 
0aa7 06 14			ld b, display_cols 
0aa9 3e 20			ld a, ' ' 
0aab			.scwipe: 
0aab 77				ld (hl), a 
0aac 2b				dec hl 
0aad 10 fc			djnz .scwipe 
0aaf			 
0aaf				;pop hl 
0aaf			 
0aaf c1				pop bc 
0ab0 d1				pop de 
0ab1 e1				pop hl 
0ab2			 
0ab2 c9				ret 
0ab3			 
0ab3			 
0ab3			;scroll_upo: 
0ab3			;	ld de, display_row_1 
0ab3			 ;	ld hl, display_row_2 
0ab3			;	ld bc, display_cols 
0ab3			;	ldir 
0ab3			;	ld de, display_row_2 
0ab3			 ;	ld hl, display_row_3 
0ab3			;	ld bc, display_cols 
0ab3			;	ldir 
0ab3			;	ld de, display_row_3 
0ab3			 ;	ld hl, display_row_4 
0ab3			;	ld bc, display_cols 
0ab3			;	ldir 
0ab3			 
0ab3			; TODO clear row 4 
0ab3			 
0ab3			;	ret 
0ab3			 
0ab3				 
0ab3			scroll_down: 
0ab3			 
0ab3 e5				push hl 
0ab4 d5				push de 
0ab5 c5				push bc 
0ab6			 
0ab6				; get frame buffer  
0ab6			 
0ab6 2a 55 fa			ld hl, (display_fb_active) 
0ab9			 
0ab9 11 4f 00			ld de, display_fb_len - 1 
0abc 19				add hl, de 
0abd			 
0abd e5			push hl    ; future de destination 
0abe			 
0abe 11 14 00			ld  de, display_cols 
0ac1 ed 52			sbc hl, de 
0ac3			 
0ac3			 
0ac3 d1				pop de 
0ac4			 
0ac4			;	ex de, hl 
0ac4 01 4f 00			ld bc, display_fb_len -1  
0ac7			 
0ac7			 
0ac7				 
0ac7			 
0ac7 ed b0			ldir 
0ac9			 
0ac9				; wipe bottom row 
0ac9			 
0ac9			 
0ac9			;	ld hl, (display_fb_active) 
0ac9			;;	ld de, display_cols*display_rows 
0ac9			;;	add hl, de 
0ac9			;	ld b, display_cols 
0ac9			;	ld a, ' ' 
0ac9			;.scwiped: 
0ac9			;	ld (hl), a 
0ac9			;	dec hl 
0ac9			;	djnz .scwiped 
0ac9			 
0ac9				;pop hl 
0ac9			 
0ac9 c1				pop bc 
0aca d1				pop de 
0acb e1				pop hl 
0acc			 
0acc c9				ret 
0acd			;scroll_down: 
0acd			;	ld de, display_row_4 
0acd			;	ld hl, display_row_3 
0acd			;	ld bc, display_cols 
0acd			;	ldir 
0acd			;	ld de, display_row_3 
0acd			; 	ld hl, display_row_2 
0acd			;	ld bc, display_cols 
0acd			;	ldir 
0acd			;	ld de, display_row_2 
0acd			;	ld hl, display_row_1 
0acd			;	ld bc, display_cols 
0acd			;	ldir 
0acd			;;; TODO clear row 1 
0acd			;	ret 
0acd			 
0acd			 
0acd			 
0acd			 
0acd			 
0acd			; clear active frame buffer 
0acd			 
0acd			clear_display: 
0acd 3e 20			ld a, ' ' 
0acf c3 d2 0a			jp fill_display 
0ad2			 
0ad2			; fill active frame buffer with a char in A 
0ad2			 
0ad2			fill_display: 
0ad2 06 50			ld b,display_fb_len 
0ad4 2a 55 fa			ld hl, (display_fb_active) 
0ad7 77			.fd1:	ld (hl),a 
0ad8 23				inc hl 
0ad9 10 fc			djnz .fd1 
0adb 23				inc hl 
0adc 3e 00			ld a,0 
0ade 77				ld (hl),a 
0adf			 
0adf			 
0adf c9				ret 
0ae0			; Write string (DE) at pos (A) to active frame buffer 
0ae0			 
0ae0 2a 55 fa		str_at_display:    ld hl,(display_fb_active) 
0ae3 06 00					ld b,0 
0ae5 4f					ld c,a 
0ae6 09					add hl,bc 
0ae7 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ae8 b7			            OR   A              ;Null terminator? 
0ae9 c8			            RET  Z              ;Yes, so finished 
0aea 77					ld (hl),a 
0aeb 23				inc hl 
0aec 13			            INC  DE             ;Point to next character 
0aed 18 f8		            JR   .sad1     ;Repeat 
0aef c9					ret 
0af0			 
0af0			; using current frame buffer write to physical display 
0af0			 
0af0			update_display: 
0af0 e5				push hl 
0af1 2a 55 fa			ld hl, (display_fb_active) 
0af4 cd b8 65			call write_display 
0af7 e1				pop hl 
0af8 c9				ret 
0af9			 
0af9			; TODO scrolling 
0af9			 
0af9			 
0af9			; move cursor right one char 
0af9			cursor_right: 
0af9			 
0af9				; TODO shift right 
0af9				; TODO if beyond max col 
0af9				; TODO       cursor_next_line 
0af9			 
0af9 c9				ret 
0afa			 
0afa			 
0afa			cursor_next_line: 
0afa				; TODO first char 
0afa				; TODO line down 
0afa				; TODO if past last row 
0afa				; TODO    scroll up 
0afa			 
0afa c9				ret 
0afb			 
0afb			cursor_left: 
0afb				; TODO shift left 
0afb				; TODO if beyond left  
0afb				; TODO     cursor prev line 
0afb				 
0afb c9				ret 
0afc			 
0afc			cursor_prev_line: 
0afc				; TODO last char 
0afc				; TODO line up 
0afc				; TODO if past first row 
0afc				; TODO   scroll down 
0afc			 
0afc c9				ret 
0afd			 
0afd			 
0afd			cout: 
0afd				; A - char 
0afd c9				ret 
0afe			 
0afe			 
0afe			; Display a menu and allow item selection (optional toggle items) 
0afe			; 
0afe			; format: 
0afe			; hl pointer to word array with zero term for items 
0afe			; e.g.    db item1 
0afe			;         db .... 
0afe			;         db 0 
0afe			; 
0afe			; a = starting menu item  
0afe			; 
0afe			; de = pointer item toggle array   (todo) 
0afe			; 
0afe			; returns item selected in a 1-... 
0afe			; returns 0 if back button pressed 
0afe			; 
0afe			; NOTE: Uses system frame buffer to display 
0afe			; 
0afe			; LEFT, Q = go back 
0afe			; RIGHT, SPACE, CR = select 
0afe			; UP, A - Up 
0afe			; DOWN, Z - Down 
0afe			 
0afe			 
0afe			 
0afe			 
0afe			 
0afe			menu: 
0afe			 
0afe					; keep array pointer 
0afe			 
0afe 22 dd f9				ld (store_tmp1), hl 
0b01 32 db f9				ld (store_tmp2), a 
0b04			 
0b04					; check for key bounce 
0b04			 
0b04			if BASE_KEV 
0b04			 
0b04 cd 6d 67		.mbounce:	call cin 
0b07 fe 00				cp 0 
0b09 20 f9				jr nz, .mbounce 
0b0b			endif 
0b0b					; for ease use ex 
0b0b			 
0b0b					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b0b 21 4a fb				ld hl, display_fb0 
0b0e 22 55 fa				ld (display_fb_active), hl 
0b11			 
0b11 cd cd 0a		.mloop:		call clear_display 
0b14 cd f0 0a				call update_display 
0b17			 
0b17					; draw selection id '>' at 1 
0b17			 
0b17					; init start of list display 
0b17			 
0b17 3e 05				ld a, 5 
0b19 32 d9 f9				ld (store_tmp3), a   ; display row count 
0b1c 3a db f9				ld a,( store_tmp2) 
0b1f 32 dc f9				ld (store_tmp2+1), a   ; display item count 
0b22			 
0b22					 
0b22			.mitem:	 
0b22			 
0b22			 
0b22 3a dc f9				ld a,(store_tmp2+1) 
0b25 6f					ld l, a 
0b26 26 00				ld h, 0 
0b28 29					add hl, hl 
0b29 ed 5b dd f9			ld de, (store_tmp1) 
0b2d 19					add hl, de 
0b2e 7e					ld a, (hl) 
0b2f 23					inc hl 
0b30 66					ld h,(hl) 
0b31 6f					ld l, a 
0b32			 
0b32 cd 2a 0d				call ishlzero 
0b35 28 1a				jr z, .mdone 
0b37			 
0b37 eb					ex de, hl 
0b38 3a d9 f9				ld a, (store_tmp3) 
0b3b cd e0 0a				call str_at_display 
0b3e					 
0b3e			 
0b3e					; next item 
0b3e 3a dc f9				ld a, (store_tmp2+1) 
0b41 3c					inc a 
0b42 32 dc f9				ld (store_tmp2+1), a   ; display item count 
0b45			 
0b45			 		; next row 
0b45			 
0b45 3a d9 f9				ld a, (store_tmp3) 
0b48 c6 14				add display_cols 
0b4a 32 d9 f9				ld (store_tmp3), a 
0b4d			 
0b4d					; at end of screen? 
0b4d			 
0b4d fe 10				cp display_rows*4 
0b4f 20 d1				jr nz, .mitem 
0b51			 
0b51			 
0b51			.mdone: 
0b51 cd 2a 0d				call ishlzero 
0b54 28 08				jr z, .nodn 
0b56			 
0b56 3e 3c				ld a, display_row_4 
0b58 11 d7 0b				ld de, .mdown 
0b5b cd e0 0a				call str_at_display 
0b5e			 
0b5e					; draw options to fill the screens with active item on line 1 
0b5e					; if current option is 2 or more then display ^ in top 
0b5e			 
0b5e 3a db f9		.nodn:		ld a, (store_tmp2) 
0b61 fe 00				cp 0 
0b63 28 08				jr z, .noup 
0b65			 
0b65 3e 00				ld a, 0 
0b67 11 d5 0b				ld de, .mup 
0b6a cd e0 0a				call str_at_display 
0b6d			 
0b6d 3e 02		.noup:		ld a, 2 
0b6f 11 d3 0b				ld de, .msel 
0b72 cd e0 0a				call str_at_display 
0b75			 
0b75					; if current option + 1 is not null then display V in bottom 
0b75					; get key 
0b75 cd f0 0a				call update_display 
0b78			 
0b78			 
0b78					; handle key 
0b78			 
0b78 cd 5c 67				call cin_wait 
0b7b			 
0b7b fe 05				cp KEY_UP 
0b7d 28 2b				jr z, .mgoup 
0b7f fe 61				cp 'a' 
0b81 28 27				jr z, .mgoup 
0b83 fe 0a				cp KEY_DOWN 
0b85 28 32				jr z, .mgod 
0b87 fe 7a				cp 'z' 
0b89 28 2e				jr z, .mgod 
0b8b fe 20				cp ' ' 
0b8d 28 34				jr z, .goend 
0b8f fe 0c				cp KEY_RIGHT 
0b91 28 30				jr z, .goend 
0b93 fe 0d				cp KEY_CR 
0b95 28 2c				jr z, .goend 
0b97 fe 71				cp 'q' 
0b99 28 0b				jr z, .goback 
0b9b			 
0b9b fe 0b				cp KEY_LEFT 
0b9d 28 07				jr z, .goback 
0b9f fe 08				cp KEY_BS 
0ba1 28 03				jr z, .goback 
0ba3 c3 11 0b				jp .mloop 
0ba6			 
0ba6			.goback: 
0ba6 3e 00			ld a, 0 
0ba8 18 1d			jr .goend2 
0baa			 
0baa				; move up one 
0baa			.mgoup: 
0baa 3a db f9				ld a, (store_tmp2) 
0bad fe 00				cp 0 
0baf ca 11 0b				jp z, .mloop 
0bb2 3d					dec a 
0bb3 32 db f9				ld (store_tmp2), a 
0bb6 c3 11 0b				jp .mloop 
0bb9			 
0bb9				; move down one 
0bb9			.mgod: 
0bb9 3a db f9				ld a, (store_tmp2) 
0bbc 3c					inc a 
0bbd 32 db f9				ld (store_tmp2), a 
0bc0 c3 11 0b				jp .mloop 
0bc3			 
0bc3			 
0bc3			.goend: 
0bc3					; get selected item number 
0bc3			 
0bc3 3a db f9				ld a, (store_tmp2) 
0bc6 3c					inc a 
0bc7			 
0bc7			.goend2: 
0bc7 f5					push af 
0bc8			 
0bc8					; restore active fb 
0bc8					; TODO BUG assumes fb1 
0bc8			 
0bc8 21 f9 fa				ld hl, display_fb1 
0bcb 22 55 fa				ld (display_fb_active), hl 
0bce			 
0bce					; restore main regs 
0bce			 
0bce			 
0bce cd f0 0a				call update_display 
0bd1			 
0bd1 f1					pop af 
0bd2			 
0bd2 c9				ret 
0bd3			 
0bd3 .. 00		.msel:   db ">",0 
0bd5 .. 00		.mup:   db "^",0 
0bd7 .. 00		.mdown:   db "v",0 
0bd9			 
0bd9			 
0bd9			; eof 
0bd9			 
# End of file firmware_display.asm
0bd9			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bd9			; random number generators 
0bd9			 
0bd9			 
0bd9			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bd9			 
0bd9			 
0bd9			;-----> Generate a random number 
0bd9			; output a=answer 0<=a<=255 
0bd9			; all registers are preserved except: af 
0bd9			random: 
0bd9 e5			        push    hl 
0bda d5			        push    de 
0bdb 2a 37 fa		        ld      hl,(randData) 
0bde ed 5f		        ld      a,r 
0be0 57			        ld      d,a 
0be1 5e			        ld      e,(hl) 
0be2 19			        add     hl,de 
0be3 85			        add     a,l 
0be4 ac			        xor     h 
0be5 22 37 fa		        ld      (randData),hl 
0be8 d1			        pop     de 
0be9 e1			        pop     hl 
0bea c9			        ret 
0beb			 
0beb			 
0beb			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0beb			 
0beb			 
0beb			 
0beb			;------LFSR------ 
0beb			;James Montelongo 
0beb			;optimized by Spencer Putt 
0beb			;out: 
0beb			; a = 8 bit random number 
0beb			RandLFSR: 
0beb 21 3d fa		        ld hl,LFSRSeed+4 
0bee 5e			        ld e,(hl) 
0bef 23			        inc hl 
0bf0 56			        ld d,(hl) 
0bf1 23			        inc hl 
0bf2 4e			        ld c,(hl) 
0bf3 23			        inc hl 
0bf4 7e			        ld a,(hl) 
0bf5 47			        ld b,a 
0bf6 cb 13		        rl e  
0bf8 cb 12			rl d 
0bfa cb 11		        rl c  
0bfc 17				rla 
0bfd cb 13		        rl e  
0bff cb 12			rl d 
0c01 cb 11		        rl c  
0c03 17				rla 
0c04 cb 13		        rl e  
0c06 cb 12			rl d 
0c08 cb 11		        rl c  
0c0a 17				rla 
0c0b 67			        ld h,a 
0c0c cb 13		        rl e  
0c0e cb 12			rl d 
0c10 cb 11		        rl c  
0c12 17				rla 
0c13 a8			        xor b 
0c14 cb 13		        rl e  
0c16 cb 12			rl d 
0c18 ac			        xor h 
0c19 a9			        xor c 
0c1a aa			        xor d 
0c1b 21 3f fa		        ld hl,LFSRSeed+6 
0c1e 11 40 fa		        ld de,LFSRSeed+7 
0c21 01 07 00		        ld bc,7 
0c24 ed b8		        lddr 
0c26 12			        ld (de),a 
0c27 c9			        ret 
0c28			 
0c28			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c28			 
0c28			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c28			 
0c28			 
0c28			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c28			 
0c28			prng16: 
0c28			;Inputs: 
0c28			;   (seed1) contains a 16-bit seed value 
0c28			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c28			;Outputs: 
0c28			;   HL is the result 
0c28			;   BC is the result of the LCG, so not that great of quality 
0c28			;   DE is preserved 
0c28			;Destroys: 
0c28			;   AF 
0c28			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c28			;160cc 
0c28			;26 bytes 
0c28 2a 31 fa		    ld hl,(seed1) 
0c2b 44			    ld b,h 
0c2c 4d			    ld c,l 
0c2d 29			    add hl,hl 
0c2e 29			    add hl,hl 
0c2f 2c			    inc l 
0c30 09			    add hl,bc 
0c31 22 31 fa		    ld (seed1),hl 
0c34 2a 2f fa		    ld hl,(seed2) 
0c37 29			    add hl,hl 
0c38 9f			    sbc a,a 
0c39 e6 2d		    and %00101101 
0c3b ad			    xor l 
0c3c 6f			    ld l,a 
0c3d 22 2f fa		    ld (seed2),hl 
0c40 09			    add hl,bc 
0c41 c9			    ret 
0c42			 
0c42			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c42			 
0c42			rand32: 
0c42			;Inputs: 
0c42			;   (seed1_0) holds the lower 16 bits of the first seed 
0c42			;   (seed1_1) holds the upper 16 bits of the first seed 
0c42			;   (seed2_0) holds the lower 16 bits of the second seed 
0c42			;   (seed2_1) holds the upper 16 bits of the second seed 
0c42			;   **NOTE: seed2 must be non-zero 
0c42			;Outputs: 
0c42			;   HL is the result 
0c42			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c42			;Destroys: 
0c42			;   AF 
0c42			;Tested and passes all CAcert tests 
0c42			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c42			;it has a period of 18,446,744,069,414,584,320 
0c42			;roughly 18.4 quintillion. 
0c42			;LFSR taps: 0,2,6,7  = 11000101 
0c42			;291cc 
0c42			;seed1_0=$+1 
0c42			;    ld hl,12345 
0c42			;seed1_1=$+1 
0c42			;    ld de,6789 
0c42			;    ld b,h 
0c42			;    ld c,l 
0c42			;    add hl,hl \ rl e \ rl d 
0c42			;    add hl,hl \ rl e \ rl d 
0c42			;    inc l 
0c42			;    add hl,bc 
0c42			;    ld (seed1_0),hl 
0c42			;    ld hl,(seed1_1) 
0c42			;    adc hl,de 
0c42			;    ld (seed1_1),hl 
0c42			;    ex de,hl 
0c42			;seed2_0=$+1 
0c42			;    ld hl,9876 
0c42			;seed2_1=$+1 
0c42			;    ld bc,54321 
0c42			;    add hl,hl \ rl c \ rl b 
0c42			;    ld (seed2_1),bc 
0c42			;    sbc a,a 
0c42			;    and %11000101 
0c42			;    xor l 
0c42			;    ld l,a 
0c42			;    ld (seed2_0),hl 
0c42			;    ex de,hl 
0c42			;    add hl,bc 
0c42			;    ret 
0c42			; 
0c42			 
0c42			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c42			; 20 bytes, 86 cycles (excluding ret) 
0c42			 
0c42			; returns   hl = pseudorandom number 
0c42			; corrupts   a 
0c42			 
0c42			; generates 16-bit pseudorandom numbers with a period of 65535 
0c42			; using the xorshift method: 
0c42			 
0c42			; hl ^= hl << 7 
0c42			; hl ^= hl >> 9 
0c42			; hl ^= hl << 8 
0c42			 
0c42			; some alternative shift triplets which also perform well are: 
0c42			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c42			 
0c42			;  org 32768 
0c42			 
0c42			xrnd: 
0c42 2a 35 fa		  ld hl,(xrandc)       ; seed must not be 0 
0c45 3e 00		  ld a,0 
0c47 bd			  cp l 
0c48 20 02		  jr nz, .xrnd1 
0c4a 2e 01		  ld l, 1 
0c4c			.xrnd1: 
0c4c			 
0c4c 7c			  ld a,h 
0c4d 1f			  rra 
0c4e 7d			  ld a,l 
0c4f 1f			  rra 
0c50 ac			  xor h 
0c51 67			  ld h,a 
0c52 7d			  ld a,l 
0c53 1f			  rra 
0c54 7c			  ld a,h 
0c55 1f			  rra 
0c56 ad			  xor l 
0c57 6f			  ld l,a 
0c58 ac			  xor h 
0c59 67			  ld h,a 
0c5a			 
0c5a 22 35 fa		  ld (xrandc),hl 
0c5d			 
0c5d c9			  ret 
0c5e			;  
0c5e			 
0c5e			 
0c5e			;;;; int maths 
0c5e			 
0c5e			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c5e			; Divide 16-bit values (with 16-bit result) 
0c5e			; In: Divide BC by divider DE 
0c5e			; Out: BC = result, HL = rest 
0c5e			; 
0c5e			Div16: 
0c5e 21 00 00		    ld hl,0 
0c61 78			    ld a,b 
0c62 06 08		    ld b,8 
0c64			Div16_Loop1: 
0c64 17			    rla 
0c65 ed 6a		    adc hl,hl 
0c67 ed 52		    sbc hl,de 
0c69 30 01		    jr nc,Div16_NoAdd1 
0c6b 19			    add hl,de 
0c6c			Div16_NoAdd1: 
0c6c 10 f6		    djnz Div16_Loop1 
0c6e 17			    rla 
0c6f 2f			    cpl 
0c70 47			    ld b,a 
0c71 79			    ld a,c 
0c72 48			    ld c,b 
0c73 06 08		    ld b,8 
0c75			Div16_Loop2: 
0c75 17			    rla 
0c76 ed 6a		    adc hl,hl 
0c78 ed 52		    sbc hl,de 
0c7a 30 01		    jr nc,Div16_NoAdd2 
0c7c 19			    add hl,de 
0c7d			Div16_NoAdd2: 
0c7d 10 f6		    djnz Div16_Loop2 
0c7f 17			    rla 
0c80 2f			    cpl 
0c81 41			    ld b,c 
0c82 4f			    ld c,a 
0c83 c9			ret 
0c84			 
0c84			 
0c84			;http://z80-heaven.wikidot.com/math 
0c84			; 
0c84			;Inputs: 
0c84			;     DE and A are factors 
0c84			;Outputs: 
0c84			;     A is not changed 
0c84			;     B is 0 
0c84			;     C is not changed 
0c84			;     DE is not changed 
0c84			;     HL is the product 
0c84			;Time: 
0c84			;     342+6x 
0c84			; 
0c84			Mult16: 
0c84			 
0c84 06 08		     ld b,8          ;7           7 
0c86 21 00 00		     ld hl,0         ;10         10 
0c89 29			       add hl,hl     ;11*8       88 
0c8a 07			       rlca          ;4*8        32 
0c8b 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c8d 19			         add hl,de   ;--         -- 
0c8e 10 f9		       djnz $-5      ;13*7+8     99 
0c90 c9			ret 
0c91			 
0c91			; 
0c91			; Square root of 16-bit value 
0c91			; In:  HL = value 
0c91			; Out:  D = result (rounded down) 
0c91			; 
0c91			;Sqr16: 
0c91			;    ld de,#0040 
0c91			;    ld a,l 
0c91			;    ld l,h 
0c91			;    ld h,d 
0c91			;    or a 
0c91			;    ld b,8 
0c91			;Sqr16_Loop: 
0c91			;    sbc hl,de 
0c91			;    jr nc,Sqr16_Skip 
0c91			;    add hl,de 
0c91			;Sqr16_Skip: 
0c91			;    ccf 
0c91			;    rl d 
0c91			;    add a,a 
0c91			;    adc hl,hl 
0c91			;    add a,a 
0c91			;    adc hl,hl 
0c91			;    djnz Sqr16_Loop 
0c91			;    ret 
0c91			; 
0c91			; 
0c91			; Divide 8-bit values 
0c91			; In: Divide E by divider C 
0c91			; Out: A = result, B = rest 
0c91			; 
0c91			Div8: 
0c91 af			    xor a 
0c92 06 08		    ld b,8 
0c94			Div8_Loop: 
0c94 cb 13		    rl e 
0c96 17			    rla 
0c97 91			    sub c 
0c98 30 01		    jr nc,Div8_NoAdd 
0c9a 81			    add a,c 
0c9b			Div8_NoAdd: 
0c9b 10 f7		    djnz Div8_Loop 
0c9d 47			    ld b,a 
0c9e 7b			    ld a,e 
0c9f 17			    rla 
0ca0 2f			    cpl 
0ca1 c9			    ret 
0ca2			 
0ca2			; 
0ca2			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ca2			; In: Multiply A with DE 
0ca2			; Out: HL = result 
0ca2			; 
0ca2			Mult12U: 
0ca2 2e 00		    ld l,0 
0ca4 87			    add a,a 
0ca5 30 01		    jr nc,Mult12U_NoAdd0 
0ca7 19			    add hl,de 
0ca8			Mult12U_NoAdd0: 
0ca8 29			    add hl,hl 
0ca9 87			    add a,a 
0caa 30 01		    jr nc,Mult12U_NoAdd1 
0cac 19			    add hl,de 
0cad			Mult12U_NoAdd1: 
0cad 29			    add hl,hl 
0cae 87			    add a,a 
0caf 30 01		    jr nc,Mult12U_NoAdd2 
0cb1 19			    add hl,de 
0cb2			Mult12U_NoAdd2: 
0cb2 29			    add hl,hl 
0cb3 87			    add a,a 
0cb4 30 01		    jr nc,Mult12U_NoAdd3 
0cb6 19			    add hl,de 
0cb7			Mult12U_NoAdd3: 
0cb7 29			    add hl,hl 
0cb8 87			    add a,a 
0cb9 30 01		    jr nc,Mult12U_NoAdd4 
0cbb 19			    add hl,de 
0cbc			Mult12U_NoAdd4: 
0cbc 29			    add hl,hl 
0cbd 87			    add a,a 
0cbe 30 01		    jr nc,Mult12U_NoAdd5 
0cc0 19			    add hl,de 
0cc1			Mult12U_NoAdd5: 
0cc1 29			    add hl,hl 
0cc2 87			    add a,a 
0cc3 30 01		    jr nc,Mult12U_NoAdd6 
0cc5 19			    add hl,de 
0cc6			Mult12U_NoAdd6: 
0cc6 29			    add hl,hl 
0cc7 87			    add a,a 
0cc8 d0			    ret nc 
0cc9 19			    add hl,de 
0cca c9			    ret 
0ccb			 
0ccb			; 
0ccb			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ccb			; In: Multiply A with DE 
0ccb			;      Put lowest value in A for most efficient calculation 
0ccb			; Out: HL = result 
0ccb			; 
0ccb			Mult12R: 
0ccb 21 00 00		    ld hl,0 
0cce			Mult12R_Loop: 
0cce cb 3f		    srl a 
0cd0 30 01		    jr nc,Mult12R_NoAdd 
0cd2 19			    add hl,de 
0cd3			Mult12R_NoAdd: 
0cd3 cb 23		    sla e 
0cd5 cb 12		    rl d 
0cd7 b7			    or a 
0cd8 c2 ce 0c		    jp nz,Mult12R_Loop 
0cdb c9			    ret 
0cdc			 
0cdc			; 
0cdc			; Multiply 16-bit values (with 32-bit result) 
0cdc			; In: Multiply BC with DE 
0cdc			; Out: BCHL = result 
0cdc			; 
0cdc			Mult32: 
0cdc 79			    ld a,c 
0cdd 48			    ld c,b 
0cde 21 00 00		    ld hl,0 
0ce1 06 10		    ld b,16 
0ce3			Mult32_Loop: 
0ce3 29			    add hl,hl 
0ce4 17			    rla 
0ce5 cb 11		    rl c 
0ce7 30 07		    jr nc,Mult32_NoAdd 
0ce9 19			    add hl,de 
0cea ce 00		    adc a,0 
0cec d2 f0 0c		    jp nc,Mult32_NoAdd 
0cef 0c			    inc c 
0cf0			Mult32_NoAdd: 
0cf0 10 f1		    djnz Mult32_Loop 
0cf2 41			    ld b,c 
0cf3 4f			    ld c,a 
0cf4 c9			    ret 
0cf5			 
0cf5			 
0cf5			 
0cf5			; 
0cf5			; Multiply 8-bit values 
0cf5			; In:  Multiply H with E 
0cf5			; Out: HL = result 
0cf5			; 
0cf5			Mult8: 
0cf5 16 00		    ld d,0 
0cf7 6a			    ld l,d 
0cf8 06 08		    ld b,8 
0cfa			Mult8_Loop: 
0cfa 29			    add hl,hl 
0cfb 30 01		    jr nc,Mult8_NoAdd 
0cfd 19			    add hl,de 
0cfe			Mult8_NoAdd: 
0cfe 10 fa		    djnz Mult8_Loop 
0d00 c9			    ret 
0d01			 
0d01			 
0d01			 
0d01			 
0d01			 
0d01			 
0d01			 
0d01			 
0d01			;;http://z80-heaven.wikidot.com/math 
0d01			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d01			; 
0d01			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d01			;     ld a,16        ;7 
0d01			;     ld hl,0        ;10 
0d01			;     jp $+5         ;10 
0d01			;.DivLoop: 
0d01			;       add hl,bc    ;-- 
0d01			;       dec a        ;64 
0d01			;       jr z,.DivLoopEnd        ;86 
0d01			; 
0d01			;       sla e        ;128 
0d01			;       rl d         ;128 
0d01			;       adc hl,hl    ;240 
0d01			;       sbc hl,bc    ;240 
0d01			;       jr nc,.DivLoop ;23|21 
0d01			;       inc e        ;-- 
0d01			;       jp .DivLoop+1 
0d01			; 
0d01			;.DivLoopEnd: 
0d01			 
0d01			;HL_Div_C: 
0d01			;Inputs: 
0d01			;     HL is the numerator 
0d01			;     C is the denominator 
0d01			;Outputs: 
0d01			;     A is the remainder 
0d01			;     B is 0 
0d01			;     C is not changed 
0d01			;     DE is not changed 
0d01			;     HL is the quotient 
0d01			; 
0d01			;       ld b,16 
0d01			;       xor a 
0d01			;         add hl,hl 
0d01			;         rla 
0d01			;         cp c 
0d01			;         jr c,$+4 
0d01			;           inc l 
0d01			;           sub c 
0d01			;         djnz $-7 
0d01			 
0d01			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d01			 
0d01			addatohl: 
0d01 85			    add   a, l    ; A = A+L 
0d02 6f			    ld    l, a    ; L = A+L 
0d03 8c			    adc   a, h    ; A = A+L+H+carry 
0d04 95			    sub   l       ; A = H+carry 
0d05 67			    ld    h, a    ; H = H+carry 
0d06 c9			ret 
0d07			 
0d07			addatode: 
0d07 83			    add   a, e    ; A = A+L 
0d08 5f			    ld    e, a    ; L = A+L 
0d09 8a			    adc   a, d    ; A = A+L+H+carry 
0d0a 93			    sub   e       ; A = H+carry 
0d0b 57			    ld    d, a    ; H = H+carry 
0d0c c9			ret 
0d0d			 
0d0d			 
0d0d			addatobc: 
0d0d 81			    add   a, c    ; A = A+L 
0d0e 4f			    ld    c, a    ; L = A+L 
0d0f 88			    adc   a, b    ; A = A+L+H+carry 
0d10 91			    sub   c       ; A = H+carry 
0d11 47			    ld    b, a    ; H = H+carry 
0d12 c9			ret 
0d13			 
0d13			subafromhl: 
0d13			   ; If A=0 do nothing 
0d13			    ; Otherwise flip A's sign. Since 
0d13			    ; the upper byte becomes -1, also 
0d13			    ; substract 1 from H. 
0d13 ed 44		    neg 
0d15 ca 1e 0d		    jp    z, Skip 
0d18 25			    dec   h 
0d19			     
0d19			    ; Now add the low byte as usual 
0d19			    ; Two's complement takes care of 
0d19			    ; ensuring the result is correct 
0d19 85			    add   a, l 
0d1a 6f			    ld    l, a 
0d1b 8c			    adc   a, h 
0d1c 95			    sub   l 
0d1d 67			    ld    h, a 
0d1e			Skip: 
0d1e c9				ret 
0d1f			 
0d1f			 
0d1f			; compare hl and de 
0d1f			; returns:  
0d1f			; if hl = de, z=1, s=0, c0=0 
0d1f			; if hl > de, z=0, s=0, c=0 
0d1f			; if hl < de, z=0, s=1, c=1 
0d1f			cmp16:	 
0d1f b7				or a 
0d20 ed 52			sbc hl,de 
0d22 e0				ret po 
0d23 7c				ld a,h 
0d24 1f				rra 
0d25 ee 40			xor 01000000B 
0d27 37				scf 
0d28 8f				adc a,a 
0d29 c9				ret 
0d2a			 
0d2a			 
0d2a			; test if hl contains zero   - A is destroyed 
0d2a			 
0d2a			ishlzero:    
0d2a b7				or a     ; reset flags 
0d2b 7c				ld a, h 
0d2c b5				or l        	 
0d2d			 
0d2d c9				ret 
0d2e			 
0d2e			 
0d2e			 
0d2e			 
0d2e			if FORTH_ENABLE_FLOATMATH 
0d2e			;include "float/bbcmath.z80" 
0d2e			include "float/lpfpcalc.asm" 
0d2e			endif 
0d2e			 
0d2e			 
0d2e			; eof 
0d2e			 
# End of file firmware_maths.asm
0d2e			include "firmware_strings.asm"   ; string handling  
0d2e			 
0d2e			 
0d2e			; TODO string len 
0d2e			; input text string, end on cr with zero term 
0d2e			; a offset into frame buffer to start prompt 
0d2e			; d is max length 
0d2e			; e is display size TODO 
0d2e			; c is current cursor position 
0d2e			; hl is ptr to where string will be stored 
0d2e			 
0d2e			 
0d2e			; TODO check limit of buffer for new inserts 
0d2e			; TODO check insert does not push beyond buffer 
0d2e			; TODO scroll in a limited display area 
0d2e			; TODO scroll whole screen on page wrap 
0d2e			 
0d2e			 
0d2e			; TODO handle KEY_PREVWORD 
0d2e			; TODO handle KEY_NEXTWORD 
0d2e			; TODO handle KEY_HOME 
0d2e			; TODO handle KEY_END 
0d2e			; TODO use LCD cursor? 
0d2e			 
0d2e 32 ad fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d31 81					add c 
0d32 32 ab fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d35 22 b0 fb				ld (input_start), hl     ; save ptr to buffer 
0d38 79					ld a, c 
0d39 cd 01 0d				call addatohl 
0d3c 22 b2 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d3f 7a					ld a,d 
0d40 32 af fb			        ld (input_size), a       ; save length of input area 
0d43 79					ld a, c 
0d44 32 9e fb				ld (input_cursor),a      ; init cursor start position  
0d47 7b					ld a,e 
0d48 32 ae fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d4b					 
0d4b					 
0d4b			 
0d4b			;		ld a,(input_ptr) 
0d4b			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d4b			 
0d4b			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d4b					; init cursor shape if not set by the cin routines 
0d4b 21 4d fa				ld hl, cursor_shape 
0d4e 3e ff				ld a, 255 
0d50 77					ld (hl), a 
0d51 23					inc hl 
0d52 3e 00				ld a, 0 
0d54 77					ld (hl), a 
0d55			 
0d55 3e 0f				ld a, CUR_BLINK_RATE 
0d57 32 a9 fb				ld (input_cur_flash), a 
0d5a 3e 01				ld a, 1 
0d5c 32 a8 fb				ld (input_cur_onoff),a 
0d5f			 
0d5f			;	if DEBUG_INPUT 
0d5f			;		push af 
0d5f			;		ld a, 'I' 
0d5f			;		ld (debug_mark),a 
0d5f			;		pop af 
0d5f			;		CALLMONITOR 
0d5f			;	endif 
0d5f			.is1:		; main entry loop 
0d5f			 
0d5f			 
0d5f			 
0d5f					; pause 1ms 
0d5f			 
0d5f 3e 01				ld a, 1 
0d61 cd 2f 0a				call aDelayInMS 
0d64			 
0d64					; dec flash counter 
0d64 3a a9 fb				ld a, (input_cur_flash) 
0d67 3d					dec a 
0d68 32 a9 fb				ld (input_cur_flash), a 
0d6b fe 00				cp 0 
0d6d 20 0d				jr nz, .nochgstate 
0d6f			 
0d6f			 
0d6f					; change state 
0d6f 3a a8 fb				ld a,(input_cur_onoff) 
0d72 ed 44				neg 
0d74 32 a8 fb				ld (input_cur_onoff),a 
0d77			 
0d77			 
0d77					; reset on change of state 
0d77 3e 0f				ld a, CUR_BLINK_RATE 
0d79 32 a9 fb				ld (input_cur_flash), a 
0d7c			 
0d7c			.nochgstate: 
0d7c					 
0d7c					 
0d7c			 
0d7c					; display cursor  
0d7c			 
0d7c			;		ld hl, (input_start) 
0d7c			;		ld a, (input_cursor) 
0d7c			;		call addatohl 
0d7c			 
0d7c					; get char under cursor and replace with cursor 
0d7c 2a b2 fb		ld hl, (input_ptr) 
0d7f			;		ld a, (hl) 
0d7f			;		ld (input_under_cursor),a 
0d7f			;		ld a, '_' 
0d7f			;		ld (hl), a 
0d7f			 
0d7f					; display string 
0d7f			 
0d7f ed 5b b0 fb			ld de, (input_start) 
0d83 3a ad fb				ld a, (input_at_pos) 
0d86 cd e0 0a				call str_at_display 
0d89			;	        call update_display 
0d89			 
0d89					; find place to put the cursor 
0d89			;		add h 
0d89			;		ld l, display_row_1 
0d89			;		sub l 
0d89			; (input_at_pos) 
0d89					;ld c, a 
0d89			;		ld a, (input_cursor) 
0d89			;		ld l, (input_at_pos) 
0d89			;		;ld b, h 
0d89			;		add l 
0d89			;		ld (input_at_cursor),a 
0d89					;ld l,h 
0d89			 
0d89			;		ld h, 0 
0d89			;		ld l,(input_at_pos) 
0d89			;		ld a, (input_cursor) 
0d89			;		call addatohl 
0d89			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d89			;		call subafromhl 
0d89			;		ld a,l 
0d89			;		ld (input_at_cursor), a 
0d89			 
0d89				if DEBUG_INPUT 
0d89					ld a, (hardware_diag) 
0d89					cp 0 
0d89					jr z, .skip_input_diag 
0d89			 
0d89					ld a,(input_at_pos) 
0d89					ld hl, LFSRSeed 
0d89					call hexout 
0d89					ld a, (input_cursor) 
0d89					ld hl, LFSRSeed+2 
0d89					call hexout 
0d89					ld a,(input_at_cursor) 
0d89					ld hl, LFSRSeed+4 
0d89					call hexout 
0d89			 
0d89					ld a,(input_cur_onoff) 
0d89					ld hl, LFSRSeed+6 
0d89					call hexout 
0d89			 
0d89					ld a,(input_cur_flash) 
0d89					ld hl, LFSRSeed+8 
0d89					call hexout 
0d89			 
0d89					ld a,(input_len) 
0d89					ld hl, LFSRSeed+10 
0d89					call hexout 
0d89					ld hl, LFSRSeed+12 
0d89					ld a, 0 
0d89					ld (hl),a 
0d89					ld a, display_row_4 
0d89					ld de, LFSRSeed 
0d89					call str_at_display 
0d89					.skip_input_diag: 
0d89				endif 
0d89			 
0d89					; decide on if we are showing the cursor this time round 
0d89			 
0d89 3a a8 fb				ld a, (input_cur_onoff) 
0d8c fe ff				cp 255 
0d8e 28 13				jr z, .skipcur 
0d90			 
0d90			 
0d90 3a ab fb				ld a,(input_at_cursor) 
0d93 11 4d fa				ld de, cursor_shape 
0d96 cd e0 0a				call str_at_display 
0d99			 
0d99					; save length of current input string 
0d99 2a b0 fb				ld hl, (input_start) 
0d9c cd 5f 11				call strlenz 
0d9f 7d					ld a,l 
0da0 32 a3 fb				ld (input_len),a 
0da3			 
0da3			.skipcur: 
0da3			 
0da3 cd f0 0a			        call update_display 
0da6					 
0da6			 
0da6			 
0da6					; wait 
0da6				 
0da6					; TODO loop without wait to flash the cursor and char under cursor	 
0da6 cd 6d 67				call cin    ; _wait 
0da9			 
0da9 fe 00				cp 0 
0dab ca 5f 0d				jp z, .is1 
0dae			 
0dae					; get ptr to char to input into 
0dae			 
0dae 4f					ld c,a 
0daf 2a b0 fb				ld hl, (input_start) 
0db2 3a 9e fb				ld a, (input_cursor) 
0db5 cd 01 0d				call addatohl 
0db8 22 b2 fb				ld (input_ptr), hl 
0dbb 79					ld a,c 
0dbc			 
0dbc					; replace char under cursor 
0dbc			 
0dbc			;		ld hl, (input_ptr) 
0dbc			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dbc			;		ld (hl), a 
0dbc			 
0dbc			;	if DEBUG_INPUT 
0dbc			;		push af 
0dbc			;		ld a, 'i' 
0dbc			;		ld (debug_mark),a 
0dbc			;		pop af 
0dbc			;		CALLMONITOR 
0dbc			;	endif 
0dbc fe 0e				cp KEY_HOME 
0dbe 20 0e				jr nz, .iske 
0dc0			 
0dc0 3a ad fb				ld a, (input_at_pos) 
0dc3 32 ab fb				ld (input_at_cursor),a 
0dc6 3e 00				ld a, 0 
0dc8 32 9e fb				ld (input_cursor), a 
0dcb c3 5f 0d				jp .is1 
0dce					 
0dce fe 0f		.iske:		cp KEY_END 
0dd0 20 03				jr nz, .isknw 
0dd2 c3 5f 0d				jp .is1 
0dd5			 
0dd5 fe 06		.isknw:		cp KEY_NEXTWORD 
0dd7 20 1b				jr nz, .iskpw 
0dd9			 
0dd9 2a b2 fb		.isknwm:	ld hl, (input_ptr) 
0ddc 7e					ld a,(hl)	 
0ddd fe 00				cp 0 
0ddf ca 5f 0d				jp z, .is1    ; end of string 
0de2 fe 20				cp ' ' 
0de4 ca 5f 0d				jp z, .is1    ; end of word 
0de7 23					inc hl 
0de8 22 b2 fb				ld (input_ptr), hl 
0deb 3a ab fb				ld a, (input_at_cursor) 
0dee 3c					inc a 
0def 32 ab fb				ld (input_at_cursor), a 
0df2 18 e5				jr .isknwm 
0df4			 
0df4 fe 07		.iskpw:		cp KEY_PREVWORD 
0df6 20 1b				jr nz, .iskl 
0df8			.iskpwm:	 
0df8 2a b2 fb				ld hl, (input_ptr) 
0dfb 7e					ld a,(hl)	 
0dfc fe 00				cp 0  
0dfe ca 5f 0d				jp z, .is1    ; end of string 
0e01 fe 20				cp ' ' 
0e03 ca 5f 0d				jp z, .is1    ; end of word 
0e06 2b					dec hl 
0e07 22 b2 fb				ld (input_ptr), hl 
0e0a 3a ab fb				ld a, (input_at_cursor) 
0e0d 3d					dec a 
0e0e 32 ab fb				ld (input_at_cursor), a 
0e11 18 e5				jr .iskpwm 
0e13			 
0e13			 
0e13 fe 0b		.iskl:		cp KEY_LEFT 
0e15 20 27				jr nz, .isk1 
0e17			 
0e17 3a 9e fb				ld a, (input_cursor) 
0e1a			 
0e1a fe 00				cp 0 
0e1c ca 5f 0d				jp z, .is1 		; at start of line to ignore  
0e1f			 
0e1f 3d					dec  a 		; TODO check underflow 
0e20 32 9e fb				ld (input_cursor), a 
0e23			 
0e23 2a b2 fb				ld hl, (input_ptr) 
0e26 2b					dec hl 
0e27 22 b2 fb				ld (input_ptr), hl 
0e2a					 
0e2a 3a ab fb				ld a, (input_at_cursor) 
0e2d 3d					dec a 
0e2e 32 ab fb				ld (input_at_cursor), a 
0e31			 
0e31 3e 01				ld a, 1		; show cursor moving 
0e33 32 a8 fb				ld (input_cur_onoff),a 
0e36 3e 0f				ld a, CUR_BLINK_RATE 
0e38 32 a9 fb				ld (input_cur_flash), a 
0e3b			 
0e3b c3 5f 0d				jp .is1 
0e3e			 
0e3e fe 0c		.isk1:		cp KEY_RIGHT 
0e40 20 2a				jr nz, .isk2 
0e42			 
0e42 3a a3 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e45 5f					ld e,a 
0e46 3a 9e fb				ld a, (input_cursor) 
0e49 bb					cp e 
0e4a ca 5f 0d				jp z, .is1		; at the end of string so dont go right 
0e4d			 
0e4d 3c					inc  a 		; TODO check overflow 
0e4e 32 9e fb				ld (input_cursor), a 
0e51			 
0e51 3a ab fb				ld a, (input_at_cursor) 
0e54 3c					inc a 
0e55 32 ab fb				ld (input_at_cursor), a 
0e58			 
0e58 2a b2 fb				ld hl, (input_ptr) 
0e5b 23					inc hl 
0e5c 22 b2 fb				ld (input_ptr), hl 
0e5f			 
0e5f 3e 01				ld a, 1		; show cursor moving 
0e61 32 a8 fb				ld (input_cur_onoff),a 
0e64 3e 0f				ld a, CUR_BLINK_RATE 
0e66 32 a9 fb				ld (input_cur_flash), a 
0e69			 
0e69 c3 5f 0d				jp .is1 
0e6c			 
0e6c fe 05		.isk2:		cp KEY_UP 
0e6e			 
0e6e 20 26				jr nz, .isk3 
0e70			 
0e70					; swap last command with the current on 
0e70			 
0e70					; move cursor to start of string 
0e70 2a b0 fb				ld hl, (input_start) 
0e73 22 b2 fb				ld (input_ptr), hl 
0e76			 
0e76 3a ad fb				ld a, (input_at_pos) 
0e79 32 ab fb				ld (input_at_cursor), a 
0e7c			 
0e7c 3e 00				ld a, 0 
0e7e 32 9e fb				ld (input_cursor), a 
0e81					 
0e81					; swap input and last command buffers 
0e81			 
0e81 21 c1 f2				ld hl, os_cli_cmd 
0e84 11 c0 f3				ld de, os_last_cmd 
0e87 06 ff				ld b, 255 
0e89 7e			.swap1:		ld a, (hl) 
0e8a 4f					ld c,a 
0e8b 1a					ld a, (de) 
0e8c 77					ld (hl), a 
0e8d 79					ld a,c 
0e8e 12					ld (de),a 
0e8f 23					inc hl 
0e90 13					inc de 
0e91 10 f6				djnz .swap1 
0e93			 
0e93			 
0e93			 
0e93			 
0e93			 
0e93 c3 5f 0d				jp .is1 
0e96			 
0e96 fe 08		.isk3:		cp KEY_BS 
0e98 20 3c				jr nz, .isk4 
0e9a			 
0e9a 3a 9e fb				ld a, (input_cursor) 
0e9d			 
0e9d fe 00				cp 0 
0e9f ca 5f 0d				jp z, .is1 		; at start of line to ignore  
0ea2			 
0ea2 3d					dec  a 		; TODO check underflow 
0ea3 32 9e fb				ld (input_cursor), a 
0ea6			 
0ea6					; hl is source 
0ea6					; de needs to be source - 1 
0ea6			 
0ea6			;		ld a, 0 
0ea6			;		dec hl 
0ea6			;		ld (hl), a 
0ea6			 
0ea6 2a b2 fb				ld hl, (input_ptr) 
0ea9 2b					dec hl 
0eaa 22 b2 fb				ld (input_ptr), hl 
0ead			 
0ead					; shift all data 
0ead			 
0ead e5					push hl 
0eae 23					inc hl 
0eaf d1					pop de 
0eb0 3a a3 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eb3 4f					ld c,a 
0eb4 06 00				ld b,0 
0eb6 ed b0				ldir  
0eb8			 
0eb8			 
0eb8			 
0eb8			 
0eb8 3a ab fb				ld a, (input_at_cursor) 
0ebb 3d					dec a 
0ebc 32 ab fb				ld (input_at_cursor), a 
0ebf			 
0ebf			 
0ebf 3e 01				ld a, 1		; show cursor moving 
0ec1 32 a8 fb				ld (input_cur_onoff),a 
0ec4 3e 0f				ld a, CUR_BLINK_RATE 
0ec6 32 a9 fb				ld (input_cur_flash), a 
0ec9			 
0ec9					; remove char 
0ec9 3a ab fb				ld a, (input_at_cursor) 
0ecc 3c					inc a 
0ecd 11 57 0f				ld de,.iblank 
0ed0 cd e0 0a				call str_at_display 
0ed3			 
0ed3 c3 5f 0d				jp .is1 
0ed6			 
0ed6 fe 0d		.isk4:		cp KEY_CR 
0ed8 28 6c				jr z, .endinput 
0eda			 
0eda					; else add the key press to the end 
0eda			 
0eda 4f					ld c, a			; save key pressed 
0edb			 
0edb 7e					ld a,(hl)		; get what is currently under char 
0edc			 
0edc fe 00				cp 0			; we are at the end of the string 
0ede 20 2f				jr nz, .onchar 
0ee0					 
0ee0					; add a char to the end of the string 
0ee0				 
0ee0 71					ld (hl),c 
0ee1 23					inc hl 
0ee2			;		ld a,' ' 
0ee2			;		ld (hl),a 
0ee2			;		inc hl 
0ee2 3e 00				ld a,0 
0ee4 77					ld (hl),a 
0ee5 2b					dec hl 
0ee6			 
0ee6 3a 9e fb				ld a, (input_cursor) 
0ee9 3c					inc a				; TODO check max string length and scroll  
0eea 32 9e fb				ld (input_cursor), a		; inc cursor pos 
0eed							 
0eed 3a ab fb				ld a, (input_at_cursor) 
0ef0 3c					inc a 
0ef1 32 ab fb				ld (input_at_cursor), a 
0ef4			 
0ef4 2a b2 fb				ld hl, (input_ptr) 
0ef7 23					inc hl 
0ef8 22 b2 fb				ld (input_ptr), hl 
0efb			 
0efb 2a b2 fb				ld hl, (input_ptr) 
0efe 23					inc hl 
0eff 22 b2 fb				ld (input_ptr), hl 
0f02			;	if DEBUG_INPUT 
0f02			;		push af 
0f02			;		ld a, '+' 
0f02			;		ld (debug_mark),a 
0f02			;		pop af 
0f02			;		CALLMONITOR 
0f02			;	endif 
0f02 3e 01				ld a, 1		; show cursor moving 
0f04 32 a8 fb				ld (input_cur_onoff),a 
0f07 3e 0f				ld a, CUR_BLINK_RATE 
0f09 32 a9 fb				ld (input_cur_flash), a 
0f0c c3 5f 0d				jp .is1 
0f0f					 
0f0f			 
0f0f			 
0f0f					; if on a char then insert 
0f0f			.onchar: 
0f0f			 
0f0f					; TODO over flow check: make sure insert does not blow out buffer 
0f0f			 
0f0f					; need to do some maths to use lddr 
0f0f			 
0f0f e5					push hl   ; save char pos 
0f10 c5					push bc 
0f11			 
0f11 2a b0 fb				ld hl, (input_start) 
0f14 3a a3 fb				ld a, (input_len) 
0f17 cd 01 0d				call addatohl  		; end of string 
0f1a 23					inc hl 
0f1b 23					inc hl		; past zero term 
0f1c e5					push hl 
0f1d 23					inc hl 
0f1e e5					push hl  
0f1f			 
0f1f								; start and end of lddr set, now how much to move? 
0f1f			 
0f1f							 
0f1f 3a 9e fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f22 47					ld b,a 
0f23 3a a3 fb				ld a,(input_len) 
0f26 5f					ld e,a 
0f27 90					sub b 
0f28 3c					inc a		;?? 
0f29 3c					inc a		;?? 
0f2a 3c					inc a		;?? 
0f2b			 
0f2b 06 00				ld b,0 
0f2d 4f					ld c,a 
0f2e			 
0f2e				if DEBUG_INPUT 
0f2e					push af 
0f2e					ld a, 'i' 
0f2e					ld (debug_mark),a 
0f2e					pop af 
0f2e			;		CALLMONITOR 
0f2e				endif 
0f2e d1					pop de 
0f2f e1					pop hl 
0f30				if DEBUG_INPUT 
0f30					push af 
0f30					ld a, 'I' 
0f30					ld (debug_mark),a 
0f30					pop af 
0f30			;		CALLMONITOR 
0f30				endif 
0f30 ed b8				lddr 
0f32				 
0f32			 
0f32			 
0f32					; TODO have a key for insert/overwrite mode???? 
0f32 c1					pop bc 
0f33 e1					pop hl 
0f34 71					ld (hl), c		; otherwise overwrite current char 
0f35					 
0f35			 
0f35			 
0f35			 
0f35 3a 9e fb				ld a, (input_cursor) 
0f38 3c					inc  a 		; TODO check overflow 
0f39 32 9e fb				ld (input_cursor), a 
0f3c			 
0f3c 3a ab fb				ld a, (input_at_cursor) 
0f3f 3c					inc a 
0f40 32 ab fb				ld (input_at_cursor), a 
0f43			 
0f43 c3 5f 0d				jp .is1 
0f46			 
0f46			.endinput:	; TODO look for end of string 
0f46			 
0f46					; add trailing space for end of token 
0f46			 
0f46 2a b0 fb				ld hl, (input_start) 
0f49 3a a3 fb				ld a,(input_len) 
0f4c cd 01 0d				call addatohl 
0f4f 3e 20				ld a, ' ' 
0f51 77					ld (hl),a 
0f52					; TODO eof of parse marker 
0f52			 
0f52 23					inc hl 
0f53 3e 00				ld a, 0 
0f55 77					ld (hl),a 
0f56			 
0f56			 
0f56 c9					ret 
0f57			 
0f57 .. 00		.iblank: db " ",0 
0f59			 
0f59			 
0f59 32 ad fb		input_str_prev:	ld (input_at_pos), a 
0f5c 22 b0 fb				ld (input_start), hl 
0f5f 3e 01				ld a,1			; add cursor 
0f61 77					ld (hl),a 
0f62 23					inc hl 
0f63 3e 00				ld a,0 
0f65 77					ld (hl),a 
0f66 22 b2 fb				ld (input_ptr), hl 
0f69 7a					ld a,d 
0f6a 32 af fb				ld (input_size), a 
0f6d 3e 00				ld a,0 
0f6f 32 9e fb				ld (input_cursor),a 
0f72			.instr1:	 
0f72			 
0f72					; TODO do block cursor 
0f72					; TODO switch cursor depending on the modifer key 
0f72			 
0f72					; update cursor shape change on key hold 
0f72			 
0f72 2a b2 fb				ld hl, (input_ptr) 
0f75 2b					dec hl 
0f76 3a 4d fa				ld a,(cursor_shape) 
0f79 77					ld (hl), a 
0f7a			 
0f7a					; display entered text 
0f7a 3a ad fb				ld a,(input_at_pos) 
0f7d cd 8b 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f80 ed 5b b0 fb	            	LD   de, (input_start) 
0f84 cd 93 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f87			 
0f87 cd 6d 67				call cin 
0f8a fe 00				cp 0 
0f8c 28 e4				jr z, .instr1 
0f8e			 
0f8e					; proecess keyboard controls first 
0f8e			 
0f8e 2a b2 fb				ld hl,(input_ptr) 
0f91			 
0f91 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f93 28 5a				jr z, .instrcr 
0f95			 
0f95 fe 08				cp KEY_BS 	; back space 
0f97 20 0f				jr nz, .instr2 
0f99					; process back space 
0f99			 
0f99					; TODO stop back space if at start of string 
0f99 2b					dec hl 
0f9a 2b					dec hl ; to over write cursor 
0f9b 3a 4d fa				ld a,(cursor_shape) 
0f9e					;ld a,0 
0f9e 77					ld (hl),a 
0f9f 23					inc hl 
0fa0 3e 20				ld a," " 
0fa2 77					ld (hl),a 
0fa3 22 b2 fb				ld (input_ptr),hl 
0fa6					 
0fa6			 
0fa6 18 ca				jr .instr1 
0fa8			 
0fa8 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0faa 20 06				jr nz, .instr3 
0fac 2b					dec hl 
0fad 22 b2 fb				ld (input_ptr),hl 
0fb0 18 c0				jr .instr1 
0fb2				 
0fb2 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fb4 20 06				jr nz, .instr4 
0fb6 23					inc hl 
0fb7 22 b2 fb				ld (input_ptr),hl 
0fba 18 b6				jr .instr1 
0fbc			 
0fbc fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fbe 20 06				jr nz, .instr5 
0fc0 2b					dec hl 
0fc1 22 b2 fb				ld (input_ptr),hl 
0fc4 18 ac				jr .instr1 
0fc6			 
0fc6 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fc8 20 06				jr nz, .instr6 
0fca 2b					dec hl 
0fcb 22 b2 fb				ld (input_ptr),hl 
0fce 18 a2				jr .instr1 
0fd0 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fd2 20 0b				jr nz, .instrnew 
0fd4			 
0fd4 21 9a ef			ld hl, scratch 
0fd7 11 c0 f3			ld de, os_last_cmd 
0fda cd f8 0f			call strcpy 
0fdd 18 93				jr .instr1 
0fdf			 
0fdf			 
0fdf			.instrnew:	; no special key pressed to see if we have room to store it 
0fdf			 
0fdf					; TODO do string size test 
0fdf			 
0fdf 2b					dec hl ; to over write cursor 
0fe0 77					ld (hl),a 
0fe1 23					inc hl 
0fe2 3a 4d fa				ld a,(cursor_shape) 
0fe5 77					ld (hl),a 
0fe6 23					inc hl 
0fe7 3e 00				ld a,0 
0fe9 77					ld (hl),a 
0fea			 
0fea 22 b2 fb				ld (input_ptr),hl 
0fed					 
0fed 18 83				jr .instr1 
0fef 2b			.instrcr:	dec hl		; remove cursor 
0ff0 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ff2 77					ld (hl),a 
0ff3 23					inc hl 
0ff4 3e 00				ld a,0 
0ff6 77					ld (hl),a 
0ff7			 
0ff7			 
0ff7					; if at end of line scroll up    
0ff7					; TODO detecting only end of line 4 for scroll up  
0ff7			 
0ff7					;ld   
0ff7			 
0ff7 c9					ret 
0ff8			 
0ff8			 
0ff8			; strcpy hl = dest, de source 
0ff8			 
0ff8 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff9 b7			            OR   A              ;Null terminator? 
0ffa c8			            RET  Z              ;Yes, so finished 
0ffb 1a					ld a,(de) 
0ffc 77					ld (hl),a 
0ffd 13			            INC  DE             ;Point to next character 
0ffe 23					inc hl 
0fff 18 f7		            JR   strcpy       ;Repeat 
1001 c9					ret 
1002			 
1002			 
1002			; TODO string_at  
1002			; pass string which starts with lcd offset address and then null term string 
1002			 
1002			; TODO string to dec 
1002			; TODO string to hex 
1002			; TODO byte to string hex 
1002			; TODO byte to string dec 
1002			 
1002			 
1002			 
1002			; from z80uartmonitor 
1002			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1002			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1002			; pass hl for where to put the text 
1002			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1002 c5			hexout:	PUSH BC 
1003 f5					PUSH AF 
1004 47					LD B, A 
1005					; Upper nybble 
1005 cb 3f				SRL A 
1007 cb 3f				SRL A 
1009 cb 3f				SRL A 
100b cb 3f				SRL A 
100d cd 1d 10				CALL tohex 
1010 77					ld (hl),a 
1011 23					inc hl	 
1012					 
1012					; Lower nybble 
1012 78					LD A, B 
1013 e6 0f				AND 0FH 
1015 cd 1d 10				CALL tohex 
1018 77					ld (hl),a 
1019 23					inc hl	 
101a					 
101a f1					POP AF 
101b c1					POP BC 
101c c9					RET 
101d					 
101d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101d			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
101d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101d			tohex: 
101d e5					PUSH HL 
101e d5					PUSH DE 
101f 16 00				LD D, 0 
1021 5f					LD E, A 
1022 21 2a 10				LD HL, .DATA 
1025 19					ADD HL, DE 
1026 7e					LD A, (HL) 
1027 d1					POP DE 
1028 e1					POP HL 
1029 c9					RET 
102a			 
102a			.DATA: 
102a 30					DEFB	30h	; 0 
102b 31					DEFB	31h	; 1 
102c 32					DEFB	32h	; 2 
102d 33					DEFB	33h	; 3 
102e 34					DEFB	34h	; 4 
102f 35					DEFB	35h	; 5 
1030 36					DEFB	36h	; 6 
1031 37					DEFB	37h	; 7 
1032 38					DEFB	38h	; 8 
1033 39					DEFB	39h	; 9 
1034 41					DEFB	41h	; A 
1035 42					DEFB	42h	; B 
1036 43					DEFB	43h	; C 
1037 44					DEFB	44h	; D 
1038 45					DEFB	45h	; E 
1039 46					DEFB	46h	; F 
103a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103a			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
103a			;;    subtract $30, if result > 9 then subtract $7 more 
103a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103a			atohex: 
103a d6 30				SUB $30 
103c fe 0a				CP 10 
103e f8					RET M		; If result negative it was 0-9 so we're done 
103f d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1041 c9					RET		 
1042			 
1042			 
1042			 
1042			 
1042			; Get 2 ASCII characters as hex byte from pointer in hl 
1042			 
1042			BYTERD: 
1042 16 00			LD	D,00h		;Set up 
1044 cd 4c 10			CALL	HEXCON		;Get byte and convert to hex 
1047 87				ADD	A,A		;First nibble so 
1048 87				ADD	A,A		;multiply by 16 
1049 87				ADD	A,A		; 
104a 87				ADD	A,A		; 
104b 57				LD	D,A		;Save hi nibble in D 
104c			HEXCON: 
104c 7e				ld a, (hl)		;Get next chr 
104d 23				inc hl 
104e d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1050 fe 0a			CP	00Ah		;Is it 0-9 ? 
1052 38 02			JR	C,NALPHA	;If so miss next bit 
1054 d6 07			SUB	007h		;Else convert alpha 
1056			NALPHA: 
1056 b2				OR	D		;Add hi nibble back 
1057 c9				RET			; 
1058			 
1058			 
1058			; 
1058			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1058			; Since the routines get_byte and therefore get_nibble are called, only valid 
1058			; characters (0-9a-f) are accepted. 
1058			; 
1058			;get_word        push    af 
1058			;                call    get_byte        ; Get the upper byte 
1058			;                ld      h, a 
1058			;                call    get_byte        ; Get the lower byte 
1058			;                ld      l, a 
1058			;                pop     af 
1058			;                ret 
1058			; 
1058			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1058			; the routine get_nibble is used only valid characters are accepted - the  
1058			; input routine only accepts characters 0-9a-f. 
1058			; 
1058 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1059 7e					ld a,(hl) 
105a 23					inc hl 
105b cd 80 10		                call    nibble2val      ; Get upper nibble 
105e cb 07		                rlc     a 
1060 cb 07		                rlc     a 
1062 cb 07		                rlc     a 
1064 cb 07		                rlc     a 
1066 47			                ld      b, a            ; Save upper four bits 
1067 7e					ld a,(hl) 
1068 cd 80 10		                call    nibble2val      ; Get lower nibble 
106b b0			                or      b               ; Combine both nibbles 
106c c1			                pop     bc              ; Restore B (and C) 
106d c9			                ret 
106e			; 
106e			; Get a hexadecimal digit from the serial line. This routine blocks until 
106e			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
106e			; to the serial line interface. The lower 4 bits of A contain the value of  
106e			; that particular digit. 
106e			; 
106e			;get_nibble      ld a,(hl)           ; Read a character 
106e			;                call    to_upper        ; Convert to upper case 
106e			;                call    is_hex          ; Was it a hex digit? 
106e			;                jr      nc, get_nibble  ; No, get another character 
106e			 ;               call    nibble2val      ; Convert nibble to value 
106e			 ;               call    print_nibble 
106e			 ;               ret 
106e			; 
106e			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
106e			; A valid hexadecimal digit is denoted by a set C flag. 
106e			; 
106e			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
106e			;                ret     nc              ; Yes 
106e			;                cp      '0'             ; Less than '0'? 
106e			;                jr      nc, is_hex_1    ; No, continue 
106e			;                ccf                     ; Complement carry (i.e. clear it) 
106e			;                ret 
106e			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
106e			;                ret     c               ; Yes 
106e			;                cp      'A'             ; Less than 'A'? 
106e			;                jr      nc, is_hex_2    ; No, continue 
106e			;                ccf                     ; Yes - clear carry and return 
106e			;                ret 
106e			;is_hex_2        scf                     ; Set carry 
106e			;                ret 
106e			; 
106e			; Convert a single character contained in A to upper case: 
106e			; 
106e fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1070 d8			                ret     c 
1071 fe 7b		                cp      'z' + 1         ; > 'z'? 
1073 d0			                ret     nc              ; Nothing to do, either 
1074 e6 5f		                and     $5f             ; Convert to upper case 
1076 c9			                ret 
1077			 
1077			 
1077			to_lower: 
1077			 
1077			   ; if char is in [A-Z] make it lower case 
1077			 
1077			   ; enter : a = char 
1077			   ; exit  : a = lower case char 
1077			   ; uses  : af 
1077			 
1077 fe 41		   cp 'A' 
1079 d8			   ret c 
107a			    
107a fe 5b		   cp 'Z'+1 
107c d0			   ret nc 
107d			    
107d f6 20		   or $20 
107f c9			   ret 
1080			 
1080			; 
1080			; Expects a hexadecimal digit (upper case!) in A and returns the 
1080			; corresponding value in A. 
1080			; 
1080 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1082 38 02		                jr      c, nibble2val_1 ; Yes 
1084 d6 07		                sub     7               ; Adjust for A-F 
1086 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1088 e6 0f		                and     $f              ; Only return lower 4 bits 
108a c9			                ret 
108b			; 
108b			; Print_nibble prints a single hex nibble which is contained in the lower  
108b			; four bits of A: 
108b			; 
108b			;print_nibble    push    af              ; We won't destroy the contents of A 
108b			;                and     $f              ; Just in case... 
108b			;                add     a, '0'             ; If we have a digit we are done here. 
108b			;                cp      '9' + 1         ; Is the result > 9? 
108b			;                jr      c, print_nibble_1 
108b			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
108b			;print_nibble_1  call    putc            ; Print the nibble and 
108b			;                pop     af              ; restore the original value of A 
108b			;                ret 
108b			;; 
108b			;; Send a CR/LF pair: 
108b			; 
108b			;crlf            push    af 
108b			;                ld      a, cr 
108b			;                call    putc 
108b			;                ld      a, lf 
108b			;                call    putc 
108b			;                pop     af 
108b			;                ret 
108b			; 
108b			; Print_word prints the four hex digits of a word to the serial line. The  
108b			; word is expected to be in HL. 
108b			; 
108b			;print_word      push    hl 
108b			;                push    af 
108b			;                ld      a, h 
108b			;                call    print_byte 
108b			;                ld      a, l 
108b			;                call    print_byte 
108b			;                pop     af 
108b			;                pop     hl 
108b			;                ret 
108b			; 
108b			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
108b			; The byte to be printed is expected to be in A. 
108b			; 
108b			;print_byte      push    af              ; Save the contents of the registers 
108b			;                push    bc 
108b			;                ld      b, a 
108b			;                rrca 
108b			;                rrca 
108b			;                rrca 
108b			;                rrca 
108b			;                call    print_nibble    ; Print high nibble 
108b			;                ld      a, b 
108b			;                call    print_nibble    ; Print low nibble 
108b			;                pop     bc              ; Restore original register contents 
108b			;                pop     af 
108b			;                ret 
108b			 
108b			 
108b			 
108b			 
108b			 
108b			fourehexhl:  
108b 7e				ld a,(hl) 
108c cd 3a 10			call atohex 
108f cb 3f				SRL A 
1091 cb 3f				SRL A 
1093 cb 3f				SRL A 
1095 cb 3f				SRL A 
1097 47				ld b, a 
1098 23				inc hl 
1099 7e				ld a,(hl) 
109a 23				inc hl 
109b cd 3a 10			call atohex 
109e 80				add b 
109f 57				ld d,a 
10a0 7e				ld a,(hl) 
10a1 cd 3a 10			call atohex 
10a4 cb 3f				SRL A 
10a6 cb 3f				SRL A 
10a8 cb 3f				SRL A 
10aa cb 3f				SRL A 
10ac 47				ld b, a 
10ad 23				inc hl 
10ae 7e				ld a,(hl) 
10af 23				inc hl 
10b0 cd 3a 10			call atohex 
10b3 80				add b 
10b4 5f				ld e, a 
10b5 d5				push de 
10b6 e1				pop hl 
10b7 c9				ret 
10b8			 
10b8			; pass hl. returns z set if the byte at hl is a digit 
10b8			;isdigithl:  
10b8			;	push bc 
10b8			;	ld a,(hl) 
10b8			;	cp ':' 
10b8			;	jr nc, .isdf 		; > 
10b8			;	cp '0' 
10b8			;	jr c, .isdf		; < 
10b8			; 
10b8			;	; TODO find a better way to set z 
10b8			; 
10b8			;	ld b,a 
10b8			;	cp b 
10b8			;	pop bc 
10b8			;	ret 
10b8			; 
10b8			;.isdf:	; not digit so clear z 
10b8			; 
10b8			;	; TODO find a better way to unset z 
10b8			; 
10b8			;	ld b,a 
10b8			;	inc b 
10b8			;	cp b 
10b8			; 
10b8			;	pop bc 
10b8			;	ret 
10b8				 
10b8				 
10b8			 
10b8			 
10b8			; pass hl as the four byte address to load 
10b8			 
10b8			get_word_hl:  
10b8 e5				push hl 
10b9 cd 58 10			call get_byte 
10bc				 
10bc 47				ld b, a 
10bd			 
10bd e1				pop hl 
10be 23				inc hl 
10bf 23				inc hl 
10c0			 
10c0			; TODO not able to handle a-f  
10c0 7e				ld a,(hl) 
10c1			;	;cp ':' 
10c1			;	cp 'g' 
10c1			;	jr nc, .single_byte_hl 		; > 
10c1			;	cp 'G' 
10c1			;	jr nc, .single_byte_hl 		; > 
10c1			;	cp '0' 
10c1			;	jr c, .single_byte_hl		; < 
10c1			 
10c1				;call isdigithl 
10c1 fe 00			cp 0 
10c3 28 06			jr z, .single_byte_hl 
10c5			 
10c5			.getwhln:   ; hex word so get next byte 
10c5			 
10c5 cd 58 10			call get_byte 
10c8 6f				ld l, a 
10c9 60				ld h,b 
10ca c9				ret 
10cb 68			.single_byte_hl:   ld l,b 
10cc 26 00				ld h,0 
10ce c9					ret 
10cf			 
10cf			 
10cf			 
10cf			 
10cf 21 f2 19			ld hl,asc+1 
10d2			;	ld a, (hl) 
10d2			;	call nibble2val 
10d2 cd 58 10			call get_byte 
10d5			 
10d5			;	call fourehexhl 
10d5 32 ce ef			ld (scratch+52),a 
10d8				 
10d8 21 cc ef			ld hl,scratch+50 
10db 22 bd f2			ld (os_cur_ptr),hl 
10de			 
10de c9				ret 
10df			 
10df			 
10df			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10df			 
10df			; Decimal Unsigned Version 
10df			 
10df			;Number in a to decimal ASCII 
10df			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10df			;Example: display a=56 as "056" 
10df			;input: a = number 
10df			;Output: a=0,value of a in the screen 
10df			;destroys af,bc (don't know about hl and de) 
10df			DispAToASCII: 
10df 0e 9c			ld	c,-100 
10e1 cd eb 10			call	.Na1 
10e4 0e f6			ld	c,-10 
10e6 cd eb 10			call	.Na1 
10e9 0e ff			ld	c,-1 
10eb 06 2f		.Na1:	ld	b,'0'-1 
10ed 04			.Na2:	inc	b 
10ee 81				add	a,c 
10ef 38 fc			jr	c,.Na2 
10f1 91				sub	c		;works as add 100/10/1 
10f2 f5				push af		;safer than ld c,a 
10f3 78				ld	a,b		;char is in b 
10f4			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f4 f1				pop af		;safer than ld a,c 
10f5 c9				ret 
10f6			 
10f6			; Decimal Signed Version 
10f6			 
10f6			; DispA 
10f6			; -------------------------------------------------------------- 
10f6			; Converts a signed integer value to a zero-terminated ASCII 
10f6			; string representative of that value (using radix 10). 
10f6			; -------------------------------------------------------------- 
10f6			; INPUTS: 
10f6			;     HL     Value to convert (two's complement integer). 
10f6			;     DE     Base address of string destination. (pointer). 
10f6			; -------------------------------------------------------------- 
10f6			; OUTPUTS: 
10f6			;     None 
10f6			; -------------------------------------------------------------- 
10f6			; REGISTERS/MEMORY DESTROYED 
10f6			; AF HL 
10f6			; -------------------------------------------------------------- 
10f6			 
10f6			;DispHLToASCII: 
10f6			;   push    de 
10f6			;   push    bc 
10f6			; 
10f6			;; Detect sign of HL. 
10f6			;    bit    7, h 
10f6			;    jr     z, ._DoConvert 
10f6			; 
10f6			;; HL is negative. Output '-' to string and negate HL. 
10f6			;    ld     a, '-' 
10f6			;    ld     (de), a 
10f6			;    inc    de 
10f6			; 
10f6			;; Negate HL (using two's complement) 
10f6			;    xor    a 
10f6			;    sub    l 
10f6			;    ld     l, a 
10f6			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10f6			;    sbc    a, h 
10f6			;    ld     h, a 
10f6			; 
10f6			;; Convert HL to digit characters 
10f6			;._DoConvert: 
10f6			;    ld     b, 0     ; B will count character length of number 
10f6			;-   ld     a, 10 
10f6			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10f6			;    push   af 
10f6			;    inc    b 
10f6			;    ld     a, h 
10f6			;    or     l 
10f6			;    jr     nz, - 
10f6			; 
10f6			;; Retrieve digits from stack 
10f6			;-   pop    af 
10f6			;    or     $30 
10f6			;    ld     (de), a 
10f6			;    inc    de 
10f6			;    djnz   - 
10f6			; 
10f6			;; Terminate string with NULL 
10f6			;    xor    a 
10f6			;    ld     (de), a 
10f6			; 
10f6			;    pop    bc 
10f6			;    pop    de 
10f6			;    ret 
10f6			 
10f6			;Comments 
10f6			; 
10f6			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10f6			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10f6			;    Note that the output string will not be fixed-width. 
10f6			; 
10f6			;Example Usage 
10f6			; 
10f6			;    ld    hl, -1004 
10f6			;    ld    de, OP1 
10f6			;    call  DispA 
10f6			;    ld    hl, OP1 
10f6			;    syscall  PutS 
10f6			 
10f6			 
10f6			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10f6			 
10f6			 
10f6			;Converts an ASCII string to an unsigned 16-bit integer 
10f6			;Quits when it reaches a non-decimal digit 
10f6			 
10f6			string_to_uint16: 
10f6			atoui_16: 
10f6			;Input: 
10f6			;     DE points to the string 
10f6			;Outputs: 
10f6			;     HL is the result 
10f6			;     A is the 8-bit value of the number 
10f6			;     DE points to the byte after the number 
10f6			;Destroys: 
10f6			;     BC 
10f6			;       if the string is non-empty, BC is HL/10 
10f6			;Size:  24 bytes 
10f6			;Speed: 42+d(104+{0,9}) 
10f6			;       d is the number of digits in the number 
10f6			;       max is 640 cycles for a 5 digit number 
10f6			;Assuming no leading zeros: 
10f6			;1 digit:  146cc 
10f6			;2 digit:  250cc 
10f6			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10f6			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10f6			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10f6			;avg: 544.81158447265625cc (544+13297/16384) 
10f6			;=============================================================== 
10f6 21 00 00		  ld hl,0 
10f9			.u16a: 
10f9 1a			  ld a,(de) 
10fa d6 30		  sub 30h 
10fc fe 0a		  cp 10 
10fe d0			  ret nc 
10ff 13			  inc de 
1100 44			  ld b,h 
1101 4d			  ld c,l 
1102 29			  add hl,hl 
1103 29			  add hl,hl 
1104 09			  add hl,bc 
1105 29			  add hl,hl 
1106 85			  add a,l 
1107 6f			  ld l,a 
1108 30 ef		  jr nc,.u16a 
110a 24			  inc h 
110b c3 f9 10		  jp .u16a 
110e			 
110e			 
110e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
110e			 
110e			;written by Zeda 
110e			;Converts a 16-bit unsigned integer to an ASCII string. 
110e			 
110e			uitoa_16: 
110e			;Input: 
110e			;   DE is the number to convert 
110e			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
110e			;Output: 
110e			;   HL points to the null-terminated ASCII string 
110e			;      NOTE: This isn't necessarily the same as the input HL. 
110e d5			  push de 
110f c5			  push bc 
1110 f5			  push af 
1111 eb			  ex de,hl 
1112			 
1112 01 f0 d8		  ld bc,-10000 
1115 3e 2f		  ld a,'0'-1 
1117 3c			  inc a 
1118 09			  add hl,bc  
1119 38 fc		   jr c,$-2 
111b 12			  ld (de),a 
111c 13			  inc de 
111d			 
111d 01 e8 03		  ld bc,1000 
1120 3e 3a		  ld a,'9'+1 
1122 3d			  dec a  
1123 09			  add hl,bc  
1124 30 fc		   jr nc,$-2 
1126 12			  ld (de),a 
1127 13			  inc de 
1128			 
1128 01 9c ff		  ld bc,-100 
112b 3e 2f		  ld a,'0'-1 
112d 3c			  inc a  
112e 09			  add hl,bc  
112f 38 fc		   jr c,$-2 
1131 12			  ld (de),a 
1132 13			  inc de 
1133			 
1133 7d			  ld a,l 
1134 26 3a		  ld h,'9'+1 
1136 25			  dec h  
1137 c6 0a		  add a,10  
1139 30 fb		   jr nc,$-3 
113b c6 30		  add a,'0' 
113d eb			  ex de,hl 
113e 72			  ld (hl),d 
113f 23			  inc hl 
1140 77			  ld (hl),a 
1141 23			  inc hl 
1142 36 00		  ld (hl),0 
1144			 
1144			;Now strip the leading zeros 
1144 0e fa		  ld c,-6 
1146 09			  add hl,bc 
1147 3e 30		  ld a,'0' 
1149 23			  inc hl  
114a be			  cp (hl)  
114b 28 fc		  jr z,$-2 
114d			 
114d			;Make sure that the string is non-empty! 
114d 7e			  ld a,(hl) 
114e b7			  or a 
114f 20 01		  jr nz,.atoub 
1151 2b			  dec hl 
1152			.atoub: 
1152			 
1152 f1			  pop af 
1153 c1			  pop bc 
1154 d1			  pop de 
1155 c9			  ret 
1156			 
1156			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1156			 
1156			toUpper: 
1156			;A is the char. 
1156			;If A is a lowercase letter, this sets it to the matching uppercase 
1156			;18cc or 30cc or 41cc 
1156			;avg: 26.75cc 
1156 fe 61		  cp 'a' 
1158 d8			  ret c 
1159 fe 7b		  cp 'z'+1 
115b d0			  ret nc 
115c d6 20		  sub 'a'-'A' 
115e c9			  ret 
115f			 
115f			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
115f			 
115f			; String Length 
115f			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
115f			 
115f			; Get the length of the null-terminated string starting at $8000 hl 
115f			;    LD     HL, $8000 
115f			 
115f			strlenz: 
115f			 
115f af			    XOR    A               ; Zero is the value we are looking for. 
1160 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1161 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1162			                           ; 65, 536 bytes (the entire addressable memory space). 
1162 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1164			 
1164			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1164 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1165 6f			    LD     L, A             ; number of bytes 
1166 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1168 2b			    DEC    HL              ; Compensate for null. 
1169 c9				ret 
116a			 
116a			; Get the length of the A terminated string starting at $8000 hl 
116a			;    LD     HL, $8000 
116a			 
116a			strlent: 
116a			 
116a			                  ; A is the value we are looking for. 
116a 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
116c 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
116e			                           ; 65, 536 bytes (the entire addressable memory space). 
116e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1170			 
1170			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1170 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1172 2e 00		    LD     L, 0             ; number of bytes 
1174 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1176 2b			    DEC    HL              ; Compensate for null. 
1177 c9				ret 
1178			 
1178			 
1178			;Comparing Strings 
1178			 
1178			;IN    HL     Address of string1. 
1178			;      DE     Address of string2. 
1178			 
1178			; doc given but wrong??? 
1178			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1178			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1178			; tested 
1178			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1178			 
1178			strcmp_old: 
1178 e5			    PUSH   HL 
1179 d5			    PUSH   DE 
117a			 
117a 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
117b be			    CP     (HL)            ; (want to minimize work). 
117c 38 01		    JR     C, Str1IsBigger 
117e 7e			    LD     A, (HL) 
117f			 
117f			Str1IsBigger: 
117f 4f			    LD     C, A             ; Put length in BC 
1180 06 00		    LD     B, 0 
1182 13			    INC    DE              ; Increment pointers to meat of string. 
1183 23			    INC    HL 
1184			 
1184			CmpLoop: 
1184 1a			    LD     A, (DE)          ; Compare bytes. 
1185 ed a1		    CPI 
1187 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1189 13			    INC    DE              ; Update pointer. 
118a ea 84 11		    JP     PE, CmpLoop 
118d			 
118d d1			    POP    DE 
118e e1			    POP    HL 
118f 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1190 be			    CP     (HL) 
1191 c9			    RET 
1192			 
1192			NoMatch: 
1192 2b			    DEC    HL 
1193 be			    CP     (HL)            ; Compare again to affect carry. 
1194 d1			    POP    DE 
1195 e1			    POP    HL 
1196 c9			    RET 
1197			 
1197			;; test strmp 
1197			; 
1197			;ld de, .str1 
1197			;ld hl, .str2 
1197			;call strcmp 
1197			;jr z, .z1 
1197			;;this 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "NZ1" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			;.z1: 
1197			; 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "ZZ1" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			; 
1197			;ld de, .str1 
1197			;ld hl, .str1 
1197			;call strcmp 
1197			;jr z, .z2 
1197			;;this 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "NZ2" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			;.z2: 
1197			; 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "ZZ2" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			; 
1197			;ld de, .str1 
1197			;ld hl, .str2 
1197			;call strcmp 
1197			;jr c, .c1 
1197			; 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "Nc1" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			;.c1: 
1197			;;this 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "cc1" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			; 
1197			;ld de, .str1 
1197			;ld hl, .str1 
1197			;call strcmp 
1197			;jr c, .c2 
1197			;;this 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "Nc2" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			;.c2: 
1197			; 
1197			;	if DEBUG_FORTH_WORDS 
1197			;		DMARK "cc2" 
1197			;		CALLMONITOR 
1197			;	endif 
1197			;	NEXTW 
1197			;.str1:   db "string1",0 
1197			;.str2:   db "string2",0 
1197			 
1197			; only care about direct match or not 
1197			; hl and de strings 
1197			; zero set if the same 
1197			 
1197			strcmp: 
1197 1a				ld a, (de) 
1198 be				cp (hl) 
1199 28 02			jr z, .ssame 
119b b7				or a 
119c c9				ret 
119d			 
119d			.ssame:  
119d fe 00			cp 0 
119f c8				ret z 
11a0			 
11a0 23				inc hl 
11a1 13				inc de 
11a2 18 f3			jr strcmp 
11a4				 
11a4				 
11a4			 
11a4			 
11a4			 
11a4			 
11a4			; eof 
11a4			 
11a4			 
11a4			 
11a4			 
11a4			 
11a4			 
# End of file firmware_strings.asm
11a4			include "firmware_memory.asm"   ; malloc and free  
11a4			 
11a4			if DEBUG_FORTH_MALLOC_HIGH 
11a4			.mallocsize: db "Wants malloc >256",0 
11a4			.mallocasize: db "MALLOC gives >256",0 
11a4			.malloczero: db "MALLOC gives zero",0 
11a4			 
11a4			malloc_guard_zerolen: 
11a4				push hl 
11a4				push de 
11a4				push af 
11a4			 
11a4				ld de, 0 
11a4			        call cmp16 
11a4				jr nz, .lowalloz 
11a4			 
11a4				push hl 
11a4				push de 
11a4					ld hl, display_fb0 
11a4					ld (display_fb_active), hl 
11a4				call clear_display 
11a4				ld a, 0 
11a4				ld de, .malloczero 
11a4				call str_at_display 
11a4				call update_display 
11a4				call delay1s 
11a4				call delay1s 
11a4				ld a, 0 
11a4				ld (os_view_disable), a 
11a4			 
11a4				pop de 
11a4				pop hl 
11a4			 
11a4				 
11a4			 
11a4				CALLMONITOR 
11a4			.lowalloz: 
11a4			 
11a4			 
11a4				pop af 
11a4				pop de 
11a4				pop hl 
11a4			ret 
11a4			 
11a4			malloc_guard_entry: 
11a4				push hl 
11a4				push de 
11a4				push af 
11a4			 
11a4			 	or a      ;clear carry flag 
11a4				push hl 
11a4				ld de, 255 
11a4				sbc hl, de 
11a4				jr c, .lowalloc 
11a4			 
11a4				push de 
11a4					ld hl, display_fb0 
11a4					ld (display_fb_active), hl 
11a4				call clear_display 
11a4				ld a, 0 
11a4				ld de, .mallocsize 
11a4				call str_at_display 
11a4				call update_display 
11a4				call delay1s 
11a4				call delay1s 
11a4				ld a, 0 
11a4				ld (os_view_disable), a 
11a4			 
11a4				pop de 
11a4				pop hl 
11a4			 
11a4				 
11a4			 
11a4				CALLMONITOR 
11a4				jr .lowdone 
11a4			.lowalloc: 
11a4			 
11a4			 
11a4				pop hl 
11a4			.lowdone:	pop af 
11a4				pop de 
11a4				pop hl 
11a4			ret 
11a4			 
11a4			malloc_guard_exit: 
11a4				push hl 
11a4				push de 
11a4				push af 
11a4			 
11a4			 	or a      ;clear carry flag 
11a4				push hl 
11a4				ld de, 255 
11a4				sbc hl, de 
11a4				jr c, .lowallocx 
11a4			 
11a4				push de 
11a4					ld hl, display_fb0 
11a4					ld (display_fb_active), hl 
11a4				call clear_display 
11a4				ld a, 0 
11a4				ld de, .mallocasize 
11a4				call str_at_display 
11a4				call update_display 
11a4				call delay1s 
11a4				call delay1s 
11a4				ld a, 0 
11a4				ld (os_view_disable), a 
11a4				pop de 
11a4				pop hl 
11a4			 
11a4				CALLMONITOR 
11a4				jr .lowdonex 
11a4			.lowallocx: 
11a4			 
11a4				pop hl 
11a4			.lowdonex:	pop af 
11a4				pop de 
11a4				pop hl 
11a4			ret 
11a4			endif 
11a4			 
11a4			if MALLOC_2 
11a4			; Z80 Malloc and Free Functions 
11a4			 
11a4			; Malloc Function: 
11a4			; Input: 
11a4			;   HL: Size of block to allocate 
11a4			; Output: 
11a4			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a4			 
11a4			malloc: 
11a4				 
11a4			if DEBUG_FORTH_MALLOC_HIGH 
11a4			call malloc_guard_entry 
11a4			endif 
11a4			 
11a4			 
11a4			 
11a4			 
11a4					if DEBUG_FORTH_MALLOC 
11a4						DMARK "mal" 
11a4						CALLMONITOR 
11a4					endif 
11a4			    push af            ; Save AF register 
11a4			    ld a, l            ; Load low byte of size into A 
11a4			    or h               ; Check if size is zero 
11a4			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a4			 
11a4			    ; Allocate memory 
11a4			    ld hl, (heap_start) ; Load start of heap into HL 
11a4					if DEBUG_FORTH_MALLOC 
11a4						DMARK "ma1" 
11a4						CALLMONITOR 
11a4					endif 
11a4			    call malloc_internal ; Call internal malloc function 
11a4			    pop af             ; Restore AF register 
11a4			if DEBUG_FORTH_MALLOC_HIGH 
11a4			call malloc_guard_exit 
11a4			call malloc_guard_zerolen 
11a4			endif 
11a4			    ret                ; Return 
11a4			 
11a4			; Free Function: 
11a4			; Input: 
11a4			;   HL: Pointer to memory block to free 
11a4			; Output: 
11a4			;   None 
11a4			 
11a4			free: 
11a4			    push af            ; Save AF register 
11a4			    ld a, l            ; Load low byte of pointer into A 
11a4			    or h               ; Check if pointer is NULL 
11a4			    jp z, free_exit    ; If pointer is NULL, exit 
11a4			 
11a4			    ; Free memory 
11a4			    ld hl, (heap_start) ; Load start of heap into HL 
11a4			    call free_internal  ; Call internal free function 
11a4			    pop af             ; Restore AF register 
11a4			    ret                ; Return 
11a4			 
11a4			; Internal Malloc Function: 
11a4			; Input: 
11a4			;   HL: Size of block to allocate 
11a4			; Output: 
11a4			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a4			 
11a4			malloc_internal: 
11a4			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a4			    add hl, bc         ; Add management overhead to requested size 
11a4			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a4					if DEBUG_FORTH_MALLOC 
11a4						DMARK "ma2" 
11a4						CALLMONITOR 
11a4					endif 
11a4			 
11a4			    ; Search for free memory block 
11a4			    ld de, (heap_end)  ; Load end of heap into DE 
11a4			    ld bc, 0           ; Initialize counter 
11a4			 
11a4					if DEBUG_FORTH_MALLOC 
11a4						DMARK "ma2" 
11a4						CALLMONITOR 
11a4					endif 
11a4			malloc_search_loop: 
11a4			    ; Check if current block is free 
11a4			    ld a, (hl)         ; Load current block's status (free or used) 
11a4			    cp 0               ; Compare with zero (free) 
11a4			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a4			 
11a4			    ; Check if current block is large enough 
11a4			    ld a, (hl+1)       ; Load high byte of block size 
11a4			    cp l               ; Compare with low byte of requested size 
11a4			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a4			 
11a4			    ld a, (hl+2)       ; Load low byte of block size 
11a4			    cp h               ; Compare with high byte of requested size 
11a4			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a4			 
11a4			    ; Mark block as used 
11a4			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a4			 
11a4			    ; Calculate remaining space in block 
11a4			    ld bc, 0           ; Clear BC 
11a4			    add hl, bc         ; Increment HL to point to start of data block 
11a4			    add hl, de         ; HL = HL + DE (total size) 
11a4			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a4			    add hl, bc         ; Add management overhead to start of data block 
11a4			 
11a4			    ; Save pointer to allocated block in HL 
11a4			if DEBUG_FORTH_MALLOC_HIGH 
11a4						DMARK "ma5" 
11a4			call malloc_guard_exit 
11a4			call malloc_guard_zerolen 
11a4			endif 
11a4			    ret 
11a4			 
11a4			malloc_skip_block_check: 
11a4			    ; Move to the next block 
11a4			    ld bc, 3           ; Size of management overhead 
11a4			    add hl, bc         ; Move to the next block 
11a4			    inc de             ; Increment counter 
11a4			 
11a4			    ; Check if we have reached the end of heap 
11a4			    ld a, e            ; Load low byte of heap end address 
11a4			    cp (hl)            ; Compare with low byte of current address 
11a4			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a4			    ld a, d            ; Load high byte of heap end address 
11a4			    cp 0               ; Check if it's zero (end of memory) 
11a4			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a4			 
11a4			    ; If we reached here, allocation failed 
11a4			    xor a              ; Set result to NULL 
11a4			if DEBUG_FORTH_MALLOC_HIGH 
11a4						DMARK "ma6" 
11a4			call malloc_guard_exit 
11a4			call malloc_guard_zerolen 
11a4			endif 
11a4			    ret 
11a4			malloc_exit: 
11a4			if DEBUG_FORTH_MALLOC_HIGH 
11a4						DMARK "ma7" 
11a4			call malloc_guard_exit 
11a4			call malloc_guard_zerolen 
11a4			endif 
11a4			    ret 
11a4			 
11a4			; Internal Free Function: 
11a4			; Input: 
11a4			;   HL: Pointer to memory block to free 
11a4			; Output: 
11a4			;   None 
11a4			 
11a4			free_internal: 
11a4			    ld de, (heap_start) ; Load start of heap into DE 
11a4			    ld bc, 0            ; Initialize counter 
11a4			 
11a4			free_search_loop: 
11a4			    ; Check if current block contains the pointer 
11a4			    ld a, l             ; Load low byte of pointer 
11a4			    cp (hl+1)           ; Compare with high byte of current block's address 
11a4			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a4			    ld a, h             ; Load high byte of pointer 
11a4			    cp (hl+2)           ; Compare with low byte of current block's address 
11a4			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a4			 
11a4			    ; Mark block as free 
11a4			    ld (hl), 0          ; Set status byte to indicate free block 
11a4			    ret                 ; Return 
11a4			 
11a4			free_skip_block_check: 
11a4			    ; Move to the next block 
11a4			    ld bc, 3            ; Size of management overhead 
11a4			    add hl, bc          ; Move to the next block 
11a4			    inc de              ; Increment counter 
11a4			 
11a4			    ; Check if we have reached the end of heap 
11a4			    ld a, e             ; Load low byte of heap end address 
11a4			    cp (hl)             ; Compare with low byte of current address 
11a4			    jr nz, free_search_loop  ; If not equal, continue searching 
11a4			    ld a, d             ; Load high byte of heap end address 
11a4			    cp 0                ; Check if it's zero (end of memory) 
11a4			    jr nz, free_search_loop  ; If not zero, continue searching 
11a4			 
11a4			    ; If we reached here, pointer is not found in heap 
11a4			    ret 
11a4			 
11a4			free_exit: 
11a4			    ret                 ; Return 
11a4			 
11a4			; Define heap start and end addresses 
11a4			;heap_start:    .dw 0xC000   ; Start of heap 
11a4			;heap_end:      .dw 0xE000   ; End of heap 
11a4			 
11a4			endif 
11a4			 
11a4			 
11a4			if MALLOC_1 
11a4			 
11a4			 
11a4			 
11a4			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a4			 
11a4			;moved to firmware.asm 
11a4			;heap_start        .equ  0x9000      ; Starting address of heap 
11a4			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a4			 
11a4			;      .org 0 
11a4			;      jp    main 
11a4			 
11a4			 
11a4			;      .org  0x100 
11a4			;main: 
11a4			;      ld    HL, 0x8100 
11a4			;      ld    SP, HL 
11a4			; 
11a4			;      call  heap_init 
11a4			; 
11a4			;      ; Make some allocations 
11a4			;      ld    HL, 12 
11a4			;      call  malloc            ; Allocates 0x9004 
11a4			; 
11a4			;      ld    HL, 12 
11a4			;      call  malloc            ; Allocates 0x9014 
11a4			; 
11a4			;      ld    HL, 12 
11a4			;      call  malloc            ; Allocates 0x9024 
11a4			; 
11a4			;      ; Free some allocations 
11a4			;      ld    HL, 0x9014 
11a4			;      call  free 
11a4			; 
11a4			;      ld    HL, 0x9004 
11a4			;      call  free 
11a4			; 
11a4			;      ld    HL, 0x9024 
11a4			;      call  free 
11a4			; 
11a4			; 
11a4			;      halt 
11a4			 
11a4			 
11a4			;------------------------------------------------------------------------------ 
11a4			;     heap_init                                                               : 
11a4			;                                                                             : 
11a4			; Description                                                                 : 
11a4			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a4			;                                                                             : 
11a4			;     The heap is maintained as a linked list, starting with an initial       : 
11a4			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a4			;     the first free block in the heap. Each block then points to the next    : 
11a4			;     free block within the heap, and the free list ends at the first block   : 
11a4			;     with a null pointer to the next free block.                             : 
11a4			;                                                                             : 
11a4			; Parameters                                                                  : 
11a4			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a4			;     address of the heap and its size are required, along with a memory      : 
11a4			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a4			;     principally stores a pointer to the first free block in the heap.       : 
11a4			;                                                                             : 
11a4			; Returns                                                                     : 
11a4			;     Nothing                                                                 : 
11a4			;------------------------------------------------------------------------------ 
11a4			heap_init: 
11a4 e5			      push  HL 
11a5			 
11a5			      ; Initialise free list struct 
11a5 21 0e 80		      ld    HL, heap_start 
11a8 22 0a 80		      ld    (free_list), HL 
11ab 21 00 00		      ld    HL, 0 
11ae 22 0c 80		      ld    (free_list+2), HL 
11b1			 
11b1			      ; Insert first free block at bottom of heap, consumes entire heap 
11b1 21 0a 80		      ld    HL, heap_start+heap_size-4 
11b4 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11b7 21 fc ff		      ld    HL, heap_size-4 
11ba 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11bd			 
11bd			      ; Insert end of free list block at top of heap - two null words will 
11bd			      ; terminate the free list 
11bd 21 00 00		      ld    HL, 0 
11c0 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11c3 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11c6			 
11c6 e1			      pop   HL 
11c7			 
11c7 c9			      ret 
11c8			 
11c8			 
11c8			;------------------------------------------------------------------------------ 
11c8			;     malloc                                                                  : 
11c8			;                                                                             : 
11c8			; Description                                                                 : 
11c8			;     Allocates the wanted space from the heap and returns the address of the : 
11c8			;     first useable byte of the allocation.                                   : 
11c8			;                                                                             : 
11c8			;     Allocations can happen in one of two ways:                              : 
11c8			;                                                                             : 
11c8			;     1. A free block may be found which is the exact size wanted. In this    : 
11c8			;        case the block is removed from the free list and retuedn to the      : 
11c8			;        caller.                                                              : 
11c8			;     2. A free block may be found which is larger than the size wanted. In   : 
11c8			;        this case, the larger block is split into two. The first portion of  : 
11c8			;        this block will become the requested space by the malloc call and    : 
11c8			;        is returned to the caller. The second portion becomes a new free     : 
11c8			;        block, and the free list is adjusted to maintain continuity via this : 
11c8			;        newly created block.                                                 : 
11c8			;                                                                             : 
11c8			;     malloc does not set any initial value in the allocated space, the       : 
11c8			;     caller is required to do this as required.                              : 
11c8			;                                                                             : 
11c8			;     This implementation of malloc uses the stack exclusively, and is        : 
11c8			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11c8			;     advisable to disable interrupts before calling malloc, and recommended  : 
11c8			;     to avoid the use of malloc inside ISRs in general.                      : 
11c8			;                                                                             : 
11c8			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11c8			;                                                                             : 
11c8			; Parameters                                                                  : 
11c8			;     HL  Number of bytes wanted                                              : 
11c8			;                                                                             : 
11c8			; Returns                                                                     : 
11c8			;     HL  Address of the first useable byte of the allocation                 : 
11c8			;                                                                             : 
11c8			; Flags                                                                       : 
11c8			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11c8			;                                                                             : 
11c8			; Stack frame                                                                 : 
11c8			;       |             |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     BC      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     DE      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     IX      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |  prev_free  |                                                       : 
11c8			;   +4  +-------------+                                                       : 
11c8			;       |  this_free  |                                                       : 
11c8			;   +2  +-------------+                                                       : 
11c8			;       |  next_free  |                                                       : 
11c8			;   +0  +-------------+                                                       : 
11c8			;       |             |                                                       : 
11c8			;                                                                             : 
11c8			;------------------------------------------------------------------------------ 
11c8			 
11c8			 
11c8			;malloc: 
11c8			; 
11c8			;	SAVESP ON 1 
11c8			; 
11c8			;	call malloc_code 
11c8			; 
11c8			;	CHECKSP ON 1 
11c8			;	ret 
11c8			 
11c8			 
11c8			malloc: 
11c8 c5			      push  BC 
11c9 d5			      push  DE 
11ca dd e5		      push  IX 
11cc			if DEBUG_FORTH_MALLOC_HIGH 
11cc			call malloc_guard_entry 
11cc			endif 
11cc			 
11cc					if DEBUG_FORTH_MALLOC 
11cc						DMARK "mal" 
11cc						CALLMONITOR 
11cc					endif 
11cc 7c			      ld    A, H                    ; Exit if no space requested 
11cd b5			      or    L 
11ce ca 8d 12		      jp    Z, malloc_early_exit 
11d1			 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			; 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			;inc hl 
11d1			 
11d1			 
11d1			 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "maA" 
11d1						CALLMONITOR 
11d1					endif 
11d1			      ; Set up stack frame 
11d1 eb			      ex    DE, HL 
11d2 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11d5 39			      add   HL, SP 
11d6 f9			      ld    SP, HL 
11d7 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11db dd 39		      add   IX, SP 
11dd			 
11dd			      ; Setup initial state 
11dd 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e0 19			      add   HL, DE 
11e1			 
11e1 44			      ld    B, H                    ; Move want to BC 
11e2 4d			      ld    C, L 
11e3			 
11e3 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11e6 dd 75 04		      ld    (IX+4), L 
11e9 dd 74 05		      ld    (IX+5), H 
11ec			 
11ec 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11ed 23			      inc   HL 
11ee 56			      ld    D, (HL) 
11ef dd 73 02		      ld    (IX+2), E 
11f2 dd 72 03		      ld    (IX+3), D 
11f5 eb			      ex    DE, HL                  ; this_free ptr into HL 
11f6			 
11f6					if DEBUG_FORTH_MALLOC 
11f6						DMARK "maB" 
11f6						CALLMONITOR 
11f6					endif 
11f6			      ; Loop through free block list to find some space 
11f6			malloc_find_space: 
11f6 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11f7 23			      inc   HL 
11f8 56			      ld    D, (HL) 
11f9			 
11f9 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11fa b3			      or    E 
11fb ca 87 12		      jp    Z, malloc_no_space 
11fe			 
11fe dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1201 dd 72 01		      ld    (IX+1), D 
1204			 
1204			      ; Does this block have enough space to make the allocation? 
1204 23			      inc   HL                      ; Load free block size into DE 
1205 5e			      ld    E, (HL) 
1206 23			      inc   HL 
1207 56			      ld    D, (HL) 
1208			 
1208 eb			      ex    DE, HL                  ; Check size of block against want 
1209 b7			      or    A                       ; Ensure carry flag clear 
120a ed 42		      sbc   HL, BC 
120c e5			      push  HL                      ; Store the result for later (new block size) 
120d			 
120d ca 5c 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1210 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1212			 
1212			      ; this_free block is not big enough, setup ptrs to test next free block 
1212 e1			      pop   HL                      ; Discard previous result 
1213			 
1213 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1216 dd 66 03		      ld    H, (IX+3) 
1219 dd 75 04		      ld    (IX+4), L 
121c dd 74 05		      ld    (IX+5), H 
121f			 
121f dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1222 dd 66 01		      ld    H, (IX+1) 
1225 dd 75 02		      ld    (IX+2), L 
1228 dd 74 03		      ld    (IX+3), H 
122b			 
122b					if DEBUG_FORTH_MALLOC 
122b						DMARK "MA>" 
122b						CALLMONITOR 
122b					endif 
122b 18 c9		      jr    malloc_find_space 
122d			 
122d			      ; split a bigger block into two - requested size and remaining size 
122d			malloc_alloc_split: 
122d					if DEBUG_FORTH_MALLOC 
122d						DMARK "MAs" 
122d						CALLMONITOR 
122d					endif 
122d eb			      ex    DE, HL                  ; Calculate address of new free block 
122e 2b			      dec   HL 
122f 2b			      dec   HL 
1230 2b			      dec   HL 
1231 09			      add   HL, BC 
1232			 
1232			      ; Create a new block and point it at next_free 
1232 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1235 dd 56 01		      ld    D, (IX+1) 
1238			 
1238 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1239 23			      inc   HL 
123a 72			      ld    (HL), D 
123b			 
123b d1			      pop   DE                      ; Store size of new block into new block 
123c 23			      inc   HL 
123d 73			      ld    (HL), E 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240			      ; Update this_free ptr to point to new block 
1240 2b			      dec   HL 
1241 2b			      dec   HL 
1242 2b			      dec   HL 
1243			 
1243 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1246 dd 56 03		      ld    D, (IX+3) 
1249			 
1249 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
124c dd 74 03		      ld    (IX+3), H 
124f			 
124f			      ; Modify this_free block to be allocation 
124f eb			      ex    DE, HL 
1250 af			      xor   A                       ; Null the next block ptr of allocated block 
1251 77			      ld    (HL), A 
1252 23			      inc   HL 
1253 77			      ld    (HL), A 
1254			 
1254 23			      inc   HL                      ; Store want size into allocated block 
1255 71			      ld    (HL), C 
1256 23			      inc   HL 
1257 70			      ld    (HL), B 
1258 23			      inc   HL 
1259 e5			      push  HL                      ; Address of allocation to return 
125a			 
125a 18 19		      jr    malloc_update_links 
125c			 
125c			malloc_alloc_fit: 
125c e1			      pop   HL                      ; Dont need new block size, want is exact fit 
125d			 
125d					if DEBUG_FORTH_MALLOC 
125d						DMARK "MAf" 
125d						CALLMONITOR 
125d					endif 
125d			      ; Modify this_free block to be allocation 
125d eb			      ex    DE, HL 
125e 2b			      dec   HL 
125f 2b			      dec   HL 
1260 2b			      dec   HL 
1261			 
1261 af			      xor   A                       ; Null the next block ptr of allocated block 
1262 77			      ld    (HL), A 
1263 23			      inc   HL 
1264 77			      ld    (HL), A 
1265			 
1265 23			      inc   HL                      ; Store address of allocation to return 
1266 23			      inc   HL 
1267 23			      inc   HL 
1268 e5			      push  HL 
1269			 
1269			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1269 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
126c dd 66 01		      ld    H, (IX+1) 
126f			 
126f dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1272 dd 74 03		      ld    (IX+3), H 
1275			 
1275			 
1275			malloc_update_links: 
1275			      ; Update prev_free ptr to point to this_free 
1275 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1278 dd 66 05		      ld    H, (IX+5) 
127b			 
127b dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
127e dd 56 03		      ld    D, (IX+3) 
1281			 
1281 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1282 23			      inc   HL 
1283 72			      ld    (HL), D 
1284			 
1284					if DEBUG_FORTH_MALLOC 
1284						DMARK "Mul" 
1284						CALLMONITOR 
1284					endif 
1284			      ; Clear the Z flag to indicate successful allocation 
1284 7a			      ld    A, D 
1285 b3			      or    E 
1286			 
1286 d1			      pop   DE                      ; Address of allocation 
1287					if DEBUG_FORTH_MALLOC 
1287						DMARK "MAu" 
1287						CALLMONITOR 
1287					endif 
1287			 
1287			malloc_no_space: 
1287 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128a 39			      add   HL, SP 
128b f9			      ld    SP, HL 
128c			 
128c eb			      ex    DE, HL                  ; Alloc addr into HL for return 
128d					if DEBUG_FORTH_MALLOC 
128d						DMARK "MAN" 
128d						CALLMONITOR 
128d					endif 
128d			 
128d			malloc_early_exit: 
128d					if DEBUG_FORTH_MALLOC 
128d						DMARK "MAx" 
128d						CALLMONITOR 
128d					endif 
128d dd e1		      pop   IX 
128f d1			      pop   DE 
1290 c1			      pop   BC 
1291			 
1291			if DEBUG_FORTH_MALLOC_HIGH 
1291			call malloc_guard_exit 
1291			call malloc_guard_zerolen 
1291			endif 
1291 c9			      ret 
1292			 
1292			 
1292			;------------------------------------------------------------------------------ 
1292			;     free                                                                    : 
1292			;                                                                             : 
1292			; Description                                                                 : 
1292			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1292			;     returned by malloc, otherwise the behaviour is undefined.               : 
1292			;                                                                             : 
1292			;     Where possible, directly adjacent free blocks will be merged together   : 
1292			;     into larger blocks to help ensure that the heap does not become         : 
1292			;     excessively fragmented.                                                 : 
1292			;                                                                             : 
1292			;     free does not clear or set any other value into the freed space, and    : 
1292			;     therefore its contents may be visible through subsequent malloc's. The  : 
1292			;     caller should clear the freed space as required.                        : 
1292			;                                                                             : 
1292			;     This implementation of free uses the stack exclusively, and is          : 
1292			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1292			;     advisable to disable interrupts before calling free, and recommended    : 
1292			;     to avoid the use of free inside ISRs in general.                        : 
1292			;                                                                             : 
1292			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1292			;                                                                             : 
1292			; Parameters                                                                  : 
1292			;     HL  Pointer to address of first byte of allocation to be freed          : 
1292			;                                                                             : 
1292			; Returns                                                                     : 
1292			;     Nothing                                                                 : 
1292			;                                                                             : 
1292			; Stack frame                                                                 : 
1292			;       |             |                                                       : 
1292			;       +-------------+                                                       : 
1292			;       |     BC      |                                                       : 
1292			;       +-------------+                                                       : 
1292			;       |     DE      |                                                       : 
1292			;       +-------------+                                                       : 
1292			;       |     IX      |                                                       : 
1292			;       +-------------+                                                       : 
1292			;       |  prev_free  |                                                       : 
1292			;   +2  +-------------+                                                       : 
1292			;       |  next_free  |                                                       : 
1292			;   +0  +-------------+                                                       : 
1292			;       |             |                                                       : 
1292			;                                                                             : 
1292			;------------------------------------------------------------------------------ 
1292			free: 
1292 c5			      push  BC 
1293 d5			      push  DE 
1294 dd e5		      push  IX 
1296			 
1296 7c			      ld    A, H                    ; Exit if ptr is null 
1297 b5			      or    L 
1298 ca 5c 13		      jp    Z, free_early_exit 
129b			 
129b			      ; Set up stack frame 
129b eb			      ex    DE, HL 
129c 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
129f 39			      add   HL, SP 
12a0 f9			      ld    SP, HL 
12a1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12a5 dd 39		      add   IX, SP 
12a7			 
12a7			      ; The address in HL points to the start of the useable allocated space, 
12a7			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12a7			      ; address of the block itself. 
12a7 eb			      ex    DE, HL 
12a8 11 fc ff		      ld    DE, -4 
12ab 19			      add   HL, DE 
12ac			 
12ac			      ; An allocated block must have a null next block pointer in it 
12ac 7e			      ld    A, (HL) 
12ad 23			      inc   HL 
12ae b6			      or    (HL) 
12af c2 57 13		      jp    NZ, free_done 
12b2			 
12b2 2b			      dec   HL 
12b3			 
12b3 44			      ld    B, H                    ; Copy HL to BC 
12b4 4d			      ld    C, L 
12b5			 
12b5			      ; Loop through the free list to find the first block with an address 
12b5			      ; higher than the block being freed 
12b5 21 0a 80		      ld    HL, free_list 
12b8			 
12b8			free_find_higher_block: 
12b8 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12b9 23			      inc   HL 
12ba 56			      ld    D, (HL) 
12bb 2b			      dec   HL 
12bc			 
12bc dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12bf dd 72 01		      ld    (IX+1), D 
12c2 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12c5 dd 74 03		      ld    (IX+3), H 
12c8			 
12c8 78			      ld    A, B                    ; Check if DE is greater than BC 
12c9 ba			      cp    D                       ; Compare MSB first 
12ca 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12cc 30 04		      jr    NC, free_find_higher_block_skip 
12ce 79			      ld    A, C 
12cf bb			      cp    E                       ; Then compare LSB 
12d0 38 08		      jr    C, free_found_higher_block 
12d2			 
12d2			free_find_higher_block_skip: 
12d2 7a			      ld    A, D                    ; Reached the end of the free list? 
12d3 b3			      or    E 
12d4 ca 57 13		      jp    Z, free_done 
12d7			 
12d7 eb			      ex    DE, HL 
12d8			 
12d8 18 de		      jr    free_find_higher_block 
12da			 
12da			free_found_higher_block: 
12da			      ; Insert freed block between prev and next free blocks 
12da 71			      ld    (HL), C                 ; Point prev free block to freed block 
12db 23			      inc   HL 
12dc 70			      ld    (HL), B 
12dd			 
12dd 60			      ld    H, B                    ; Point freed block at next free block 
12de 69			      ld    L, C 
12df 73			      ld    (HL), E 
12e0 23			      inc   HL 
12e1 72			      ld    (HL), D 
12e2			 
12e2			      ; Check if the freed block is adjacent to the next free block 
12e2 23			      inc   HL                      ; Load size of freed block into HL 
12e3 5e			      ld    E, (HL) 
12e4 23			      inc   HL 
12e5 56			      ld    D, (HL) 
12e6 eb			      ex    DE, HL 
12e7			 
12e7 09			      add   HL, BC                  ; Add addr of freed block and its size 
12e8			 
12e8 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12eb dd 56 01		      ld    D, (IX+1) 
12ee			 
12ee b7			      or    A                       ; Clear the carry flag 
12ef ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f1 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f3			 
12f3			      ; Freed block is adjacent to next, merge into one bigger block 
12f3 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f4 5e			      ld    E, (HL) 
12f5 23			      inc   HL 
12f6 56			      ld    D, (HL) 
12f7 e5			      push  HL                      ; Save ptr to next block for later 
12f8			 
12f8 60			      ld    H, B                    ; Store ptr from next block into freed block 
12f9 69			      ld    L, C 
12fa 73			      ld    (HL), E 
12fb 23			      inc   HL 
12fc 72			      ld    (HL), D 
12fd			 
12fd e1			      pop   HL                      ; Restore ptr to next block 
12fe 23			      inc   HL                      ; Load size of next block into DE 
12ff 5e			      ld    E, (HL) 
1300 23			      inc   HL 
1301 56			      ld    D, (HL) 
1302 d5			      push  DE                      ; Save next block size for later 
1303			 
1303 60			      ld    H, B                    ; Load size of freed block into HL 
1304 69			      ld    L, C 
1305 23			      inc   HL 
1306 23			      inc   HL 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a eb			      ex    DE, HL 
130b			 
130b d1			      pop   DE                      ; Restore size of next block 
130c 19			      add   HL, DE                  ; Add sizes of both blocks 
130d eb			      ex    DE, HL 
130e			 
130e 60			      ld    H, B                    ; Store new bigger size into freed block 
130f 69			      ld    L, C 
1310 23			      inc   HL 
1311 23			      inc   HL 
1312 73			      ld    (HL), E 
1313 23			      inc   HL 
1314 72			      ld    (HL), D 
1315			 
1315			free_check_adjacent_to_prev: 
1315			      ; Check if the freed block is adjacent to the prev free block 
1315 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1318 dd 66 03		      ld    H, (IX+3) 
131b			 
131b 23			      inc   HL                      ; Size of prev free block into DE 
131c 23			      inc   HL 
131d 5e			      ld    E, (HL) 
131e 23			      inc   HL 
131f 56			      ld    D, (HL) 
1320 2b			      dec   HL 
1321 2b			      dec   HL 
1322 2b			      dec   HL 
1323			 
1323 19			      add   HL, DE                  ; Add prev block addr and size 
1324			 
1324 b7			      or    A                       ; Clear the carry flag 
1325 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1327 20 2e		      jr    NZ, free_done 
1329			 
1329			      ; Freed block is adjacent to prev, merge into one bigger block 
1329 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132a 69			      ld    L, C 
132b 5e			      ld    E, (HL) 
132c 23			      inc   HL 
132d 56			      ld    D, (HL) 
132e e5			      push  HL                      ; Save freed block ptr for later 
132f			 
132f dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1332 dd 66 03		      ld    H, (IX+3) 
1335 73			      ld    (HL), E 
1336 23			      inc   HL 
1337 72			      ld    (HL), D 
1338			 
1338 e1			      pop   HL                      ; Restore freed block ptr 
1339 23			      inc   HL                      ; Load size of freed block into DE 
133a 5e			      ld    E, (HL) 
133b 23			      inc   HL 
133c 56			      ld    D, (HL) 
133d d5			      push  DE                      ; Save freed block size for later 
133e			 
133e dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1341 dd 66 03		      ld    H, (IX+3) 
1344 23			      inc   HL 
1345 23			      inc   HL 
1346 5e			      ld    E, (HL) 
1347 23			      inc   HL 
1348 56			      ld    D, (HL) 
1349			 
1349 e1			      pop   HL                      ; Add sizes of both blocks 
134a 19			      add   HL, DE 
134b eb			      ex    DE, HL 
134c			 
134c dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
134f dd 66 03		      ld    H, (IX+3) 
1352 23			      inc   HL 
1353 23			      inc   HL 
1354 73			      ld    (HL), E 
1355 23			      inc   HL 
1356 72			      ld    (HL), D 
1357			 
1357			free_done: 
1357 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135a 39			      add   HL, SP 
135b f9			      ld    SP, HL 
135c			 
135c			free_early_exit: 
135c dd e1		      pop   IX 
135e d1			      pop   DE 
135f c1			      pop   BC 
1360			 
1360 c9			      ret 
1361			 
1361			; moved to firmware.asm 
1361			; 
1361			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1361			;                  .dw   0 
1361			 
1361			 
1361			endif 
1361			 
1361			 
1361			if MALLOC_3 
1361			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1361			;heap_start        .equ  0x9000      ; Starting address of heap 
1361			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1361			; 
1361			 ;     .org 0 
1361			  ;    jp    main 
1361			; 
1361			; 
1361			 ;     .org  0x100 
1361			;main: 
1361			 ;     ld    HL, 0x8100 
1361			  ;    ld    SP, HL 
1361			; 
1361			;      call  heap_init 
1361			 
1361			      ; Make some allocations 
1361			;      ld    HL, 12 
1361			;      call  malloc            ; Allocates 0x9004 
1361			; 
1361			 ;     ld    HL, 12 
1361			;      call  malloc            ; Allocates 0x9014 
1361			 
1361			;      ld    HL, 12 
1361			;      call  malloc            ; Allocates 0x9024 
1361			 
1361			      ; Free some allocations 
1361			;      ld    HL, 0x9014 
1361			;      call  free 
1361			 
1361			;      ld    HL, 0x9004 
1361			;      call  free 
1361			; 
1361			;      ld    HL, 0x9024 
1361			;      call  free 
1361			 
1361			 
1361			 ;     halt 
1361			 
1361			 
1361			;------------------------------------------------------------------------------ 
1361			;     heap_init                                                               : 
1361			;                                                                             : 
1361			; Description                                                                 : 
1361			;     Initialise the heap and make it ready for malloc and free operations.   : 
1361			;                                                                             : 
1361			;     The heap is maintained as a linked list, starting with an initial       : 
1361			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1361			;     the first free block in the heap. Each block then points to the next    : 
1361			;     free block within the heap, and the free list ends at the first block   : 
1361			;     with a null pointer to the next free block.                             : 
1361			;                                                                             : 
1361			; Parameters                                                                  : 
1361			;     Inputs are compile-time only. Two defines which specify the starting    : 
1361			;     address of the heap and its size are required, along with a memory      : 
1361			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1361			;     principally stores a pointer to the first free block in the heap.       : 
1361			;                                                                             : 
1361			; Returns                                                                     : 
1361			;     Nothing                                                                 : 
1361			;------------------------------------------------------------------------------ 
1361			heap_init: 
1361			      push  HL 
1361			 
1361			      ; Initialise free list struct 
1361			      ld    HL, heap_start 
1361			      ld    (free_list), HL 
1361			      ld    HL, 0 
1361			      ld    (free_list+2), HL 
1361			 
1361			      ; Insert first free block at bottom of heap, consumes entire heap 
1361			      ld    HL, heap_start+heap_size-4 
1361			      ld    (heap_start), HL        ; Next block (end of free list) 
1361			      ld    HL, heap_size-4 
1361			      ld    (heap_start+2), HL      ; Block size 
1361			 
1361			      ; Insert end of free list block at top of heap - two null words will 
1361			      ; terminate the free list 
1361			      ld    HL, 0 
1361			      ld    (heap_start+heap_size-2), HL 
1361			      ld    (heap_start+heap_size-4), HL 
1361			 
1361			      pop   HL 
1361			 
1361			      ret 
1361			 
1361			 
1361			;------------------------------------------------------------------------------ 
1361			;     malloc                                                                  : 
1361			;                                                                             : 
1361			; Description                                                                 : 
1361			;     Allocates the wanted space from the heap and returns the address of the : 
1361			;     first useable byte of the allocation.                                   : 
1361			;                                                                             : 
1361			;     Allocations can happen in one of two ways:                              : 
1361			;                                                                             : 
1361			;     1. A free block may be found which is the exact size wanted. In this    : 
1361			;        case the block is removed from the free list and retuedn to the      : 
1361			;        caller.                                                              : 
1361			;     2. A free block may be found which is larger than the size wanted. In   : 
1361			;        this case, the larger block is split into two. The first portion of  : 
1361			;        this block will become the requested space by the malloc call and    : 
1361			;        is returned to the caller. The second portion becomes a new free     : 
1361			;        block, and the free list is adjusted to maintain continuity via this : 
1361			;        newly created block.                                                 : 
1361			;                                                                             : 
1361			;     malloc does not set any initial value in the allocated space, the       : 
1361			;     caller is required to do this as required.                              : 
1361			;                                                                             : 
1361			;     This implementation of malloc uses the stack exclusively, and is        : 
1361			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1361			;     advisable to disable interrupts before calling malloc, and recommended  : 
1361			;     to avoid the use of malloc inside ISRs in general.                      : 
1361			;                                                                             : 
1361			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1361			;                                                                             : 
1361			; Parameters                                                                  : 
1361			;     HL  Number of bytes wanted                                              : 
1361			;                                                                             : 
1361			; Returns                                                                     : 
1361			;     HL  Address of the first useable byte of the allocation                 : 
1361			;                                                                             : 
1361			; Flags                                                                       : 
1361			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1361			;                                                                             : 
1361			; Stack frame                                                                 : 
1361			;       |             |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |     BC      |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |     DE      |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |     IX      |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |  prev_free  |                                                       : 
1361			;   +4  +-------------+                                                       : 
1361			;       |  this_free  |                                                       : 
1361			;   +2  +-------------+                                                       : 
1361			;       |  next_free  |                                                       : 
1361			;   +0  +-------------+                                                       : 
1361			;       |             |                                                       : 
1361			;                                                                             : 
1361			;------------------------------------------------------------------------------ 
1361			malloc: 
1361			      push  BC 
1361			      push  DE 
1361			      push  IX 
1361			 
1361			      ld    A, H                    ; Exit if no space requested 
1361			      or    L 
1361			      jp    Z, malloc_early_exit 
1361			 
1361			      ; Set up stack frame 
1361			      ex    DE, HL 
1361			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1361			      add   HL, SP 
1361			      ld    SP, HL 
1361			      ld    IX, 0                   ; Use IX as a frame pointer 
1361			      add   IX, SP 
1361			 
1361			      ; Setup initial state 
1361			      ld    HL, 4                   ; want must also include space used by block struct 
1361			      add   HL, DE 
1361			 
1361			      ld    B, H                    ; Move want to BC 
1361			      ld    C, L 
1361			 
1361			      ld    HL, free_list           ; Store prev_free ptr to stack 
1361			      ld    (IX+4), L 
1361			      ld    (IX+5), H 
1361			 
1361			      ld    E, (HL)                 ; Store this_free ptr to stack 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      ld    (IX+2), E 
1361			      ld    (IX+3), D 
1361			      ex    DE, HL                  ; this_free ptr into HL 
1361			 
1361			      ; Loop through free block list to find some space 
1361			malloc_find_space: 
1361			      ld    E, (HL)                 ; Load next_free ptr into DE 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			 
1361			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1361			      or    E 
1361			      jp    Z, malloc_no_space 
1361			 
1361			      ld    (IX+0), E               ; Store next_free ptr to stack 
1361			      ld    (IX+1), D 
1361			 
1361			      ; Does this block have enough space to make the allocation? 
1361			      inc   HL                      ; Load free block size into DE 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			 
1361			      ex    DE, HL                  ; Check size of block against want 
1361			      or    A                       ; Ensure carry flag clear 
1361			      sbc   HL, BC 
1361			      push  HL                      ; Store the result for later (new block size) 
1361			 
1361			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1361			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1361			 
1361			      ; this_free block is not big enough, setup ptrs to test next free block 
1361			      pop   HL                      ; Discard previous result 
1361			 
1361			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1361			      ld    H, (IX+3) 
1361			      ld    (IX+4), L 
1361			      ld    (IX+5), H 
1361			 
1361			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1361			      ld    H, (IX+1) 
1361			      ld    (IX+2), L 
1361			      ld    (IX+3), H 
1361			 
1361			      jr    malloc_find_space 
1361			 
1361			      ; split a bigger block into two - requested size and remaining size 
1361			malloc_alloc_split: 
1361			      ex    DE, HL                  ; Calculate address of new free block 
1361			      dec   HL 
1361			      dec   HL 
1361			      dec   HL 
1361			      add   HL, BC 
1361			 
1361			      ; Create a new block and point it at next_free 
1361			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1361			      ld    D, (IX+1) 
1361			 
1361			      ld    (HL), E                 ; Store next_free ptr into new block 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			      pop   DE                      ; Store size of new block into new block 
1361			      inc   HL 
1361			      ld    (HL), E 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			      ; Update this_free ptr to point to new block 
1361			      dec   HL 
1361			      dec   HL 
1361			      dec   HL 
1361			 
1361			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1361			      ld    D, (IX+3) 
1361			 
1361			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1361			      ld    (IX+3), H 
1361			 
1361			      ; Modify this_free block to be allocation 
1361			      ex    DE, HL 
1361			      xor   A                       ; Null the next block ptr of allocated block 
1361			      ld    (HL), A 
1361			      inc   HL 
1361			      ld    (HL), A 
1361			 
1361			      inc   HL                      ; Store want size into allocated block 
1361			      ld    (HL), C 
1361			      inc   HL 
1361			      ld    (HL), B 
1361			      inc   HL 
1361			      push  HL                      ; Address of allocation to return 
1361			 
1361			      jr    malloc_update_links 
1361			 
1361			malloc_alloc_fit: 
1361			      pop   HL                      ; Dont need new block size, want is exact fit 
1361			 
1361			      ; Modify this_free block to be allocation 
1361			      ex    DE, HL 
1361			      dec   HL 
1361			      dec   HL 
1361			      dec   HL 
1361			 
1361			      xor   A                       ; Null the next block ptr of allocated block 
1361			      ld    (HL), A 
1361			      inc   HL 
1361			      ld    (HL), A 
1361			 
1361			      inc   HL                      ; Store address of allocation to return 
1361			      inc   HL 
1361			      inc   HL 
1361			      push  HL 
1361			 
1361			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1361			      ld    L, (IX+0)               ; next_free to HL 
1361			      ld    H, (IX+1) 
1361			 
1361			      ld    (IX+2), L               ; HL to this_free 
1361			      ld    (IX+3), H 
1361			 
1361			 
1361			malloc_update_links: 
1361			      ; Update prev_free ptr to point to this_free 
1361			      ld    L, (IX+4)               ; prev_free ptr to HL 
1361			      ld    H, (IX+5) 
1361			 
1361			      ld    E, (IX+2)               ; this_free ptr to DE 
1361			      ld    D, (IX+3) 
1361			 
1361			      ld    (HL), E                 ; this_free ptr into prev_free 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			      ; Clear the Z flag to indicate successful allocation 
1361			      ld    A, D 
1361			      or    E 
1361			 
1361			      pop   DE                      ; Address of allocation 
1361			 
1361			malloc_no_space: 
1361			      ld    HL, 6                   ; Clean up stack frame 
1361			      add   HL, SP 
1361			      ld    SP, HL 
1361			 
1361			      ex    DE, HL                  ; Alloc addr into HL for return 
1361			 
1361			malloc_early_exit: 
1361			      pop   IX 
1361			      pop   DE 
1361			      pop   BC 
1361			 
1361			      ret 
1361			 
1361			 
1361			;------------------------------------------------------------------------------ 
1361			;     free                                                                    : 
1361			;                                                                             : 
1361			; Description                                                                 : 
1361			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1361			;     returned by malloc, otherwise the behaviour is undefined.               : 
1361			;                                                                             : 
1361			;     Where possible, directly adjacent free blocks will be merged together   : 
1361			;     into larger blocks to help ensure that the heap does not become         : 
1361			;     excessively fragmented.                                                 : 
1361			;                                                                             : 
1361			;     free does not clear or set any other value into the freed space, and    : 
1361			;     therefore its contents may be visible through subsequent malloc's. The  : 
1361			;     caller should clear the freed space as required.                        : 
1361			;                                                                             : 
1361			;     This implementation of free uses the stack exclusively, and is          : 
1361			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1361			;     advisable to disable interrupts before calling free, and recommended    : 
1361			;     to avoid the use of free inside ISRs in general.                        : 
1361			;                                                                             : 
1361			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1361			;                                                                             : 
1361			; Parameters                                                                  : 
1361			;     HL  Pointer to address of first byte of allocation to be freed          : 
1361			;                                                                             : 
1361			; Returns                                                                     : 
1361			;     Nothing                                                                 : 
1361			;                                                                             : 
1361			; Stack frame                                                                 : 
1361			;       |             |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |     BC      |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |     DE      |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |     IX      |                                                       : 
1361			;       +-------------+                                                       : 
1361			;       |  prev_free  |                                                       : 
1361			;   +2  +-------------+                                                       : 
1361			;       |  next_free  |                                                       : 
1361			;   +0  +-------------+                                                       : 
1361			;       |             |                                                       : 
1361			;                                                                             : 
1361			;------------------------------------------------------------------------------ 
1361			free: 
1361			      push  BC 
1361			      push  DE 
1361			      push  IX 
1361			 
1361			      ld    A, H                    ; Exit if ptr is null 
1361			      or    L 
1361			      jp    Z, free_early_exit 
1361			 
1361			      ; Set up stack frame 
1361			      ex    DE, HL 
1361			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1361			      add   HL, SP 
1361			      ld    SP, HL 
1361			      ld    IX, 0                   ; Use IX as a frame pointer 
1361			      add   IX, SP 
1361			 
1361			      ; The address in HL points to the start of the useable allocated space, 
1361			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1361			      ; address of the block itself. 
1361			      ex    DE, HL 
1361			      ld    DE, -4 
1361			      add   HL, DE 
1361			 
1361			      ; An allocated block must have a null next block pointer in it 
1361			      ld    A, (HL) 
1361			      inc   HL 
1361			      or    (HL) 
1361			      jp    NZ, free_done 
1361			 
1361			      dec   HL 
1361			 
1361			      ld    B, H                    ; Copy HL to BC 
1361			      ld    C, L 
1361			 
1361			      ; Loop through the free list to find the first block with an address 
1361			      ; higher than the block being freed 
1361			      ld    HL, free_list 
1361			 
1361			free_find_higher_block: 
1361			      ld    E, (HL)                 ; Load next ptr from free block 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      dec   HL 
1361			 
1361			      ld    (IX+0), E               ; Save ptr to next free block 
1361			      ld    (IX+1), D 
1361			      ld    (IX+2), L               ; Save ptr to prev free block 
1361			      ld    (IX+3), H 
1361			 
1361			      ld    A, B                    ; Check if DE is greater than BC 
1361			      cp    D                       ; Compare MSB first 
1361			      jr    Z, $+4                  ; MSB the same, compare LSB 
1361			      jr    NC, free_find_higher_block_skip 
1361			      ld    A, C 
1361			      cp    E                       ; Then compare LSB 
1361			      jr    C, free_found_higher_block 
1361			 
1361			free_find_higher_block_skip: 
1361			      ld    A, D                    ; Reached the end of the free list? 
1361			      or    E 
1361			      jp    Z, free_done 
1361			 
1361			      ex    DE, HL 
1361			 
1361			      jr    free_find_higher_block 
1361			 
1361			free_found_higher_block: 
1361			      ; Insert freed block between prev and next free blocks 
1361			      ld    (HL), C                 ; Point prev free block to freed block 
1361			      inc   HL 
1361			      ld    (HL), B 
1361			 
1361			      ld    H, B                    ; Point freed block at next free block 
1361			      ld    L, C 
1361			      ld    (HL), E 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			      ; Check if the freed block is adjacent to the next free block 
1361			      inc   HL                      ; Load size of freed block into HL 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      ex    DE, HL 
1361			 
1361			      add   HL, BC                  ; Add addr of freed block and its size 
1361			 
1361			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1361			      ld    D, (IX+1) 
1361			 
1361			      or    A                       ; Clear the carry flag 
1361			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1361			      jr    NZ, free_check_adjacent_to_prev 
1361			 
1361			      ; Freed block is adjacent to next, merge into one bigger block 
1361			      ex    DE, HL                  ; Load next ptr from next block into DE 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      push  HL                      ; Save ptr to next block for later 
1361			 
1361			      ld    H, B                    ; Store ptr from next block into freed block 
1361			      ld    L, C 
1361			      ld    (HL), E 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			      pop   HL                      ; Restore ptr to next block 
1361			      inc   HL                      ; Load size of next block into DE 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      push  DE                      ; Save next block size for later 
1361			 
1361			      ld    H, B                    ; Load size of freed block into HL 
1361			      ld    L, C 
1361			      inc   HL 
1361			      inc   HL 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      ex    DE, HL 
1361			 
1361			      pop   DE                      ; Restore size of next block 
1361			      add   HL, DE                  ; Add sizes of both blocks 
1361			      ex    DE, HL 
1361			 
1361			      ld    H, B                    ; Store new bigger size into freed block 
1361			      ld    L, C 
1361			      inc   HL 
1361			      inc   HL 
1361			      ld    (HL), E 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			free_check_adjacent_to_prev: 
1361			      ; Check if the freed block is adjacent to the prev free block 
1361			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1361			      ld    H, (IX+3) 
1361			 
1361			      inc   HL                      ; Size of prev free block into DE 
1361			      inc   HL 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      dec   HL 
1361			      dec   HL 
1361			      dec   HL 
1361			 
1361			      add   HL, DE                  ; Add prev block addr and size 
1361			 
1361			      or    A                       ; Clear the carry flag 
1361			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1361			      jr    NZ, free_done 
1361			 
1361			      ; Freed block is adjacent to prev, merge into one bigger block 
1361			      ld    H, B                    ; Load next ptr from freed block into DE 
1361			      ld    L, C 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      push  HL                      ; Save freed block ptr for later 
1361			 
1361			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1361			      ld    H, (IX+3) 
1361			      ld    (HL), E 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			      pop   HL                      ; Restore freed block ptr 
1361			      inc   HL                      ; Load size of freed block into DE 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			      push  DE                      ; Save freed block size for later 
1361			 
1361			      ld    L, (IX+2)               ; Load size of prev block into DE 
1361			      ld    H, (IX+3) 
1361			      inc   HL 
1361			      inc   HL 
1361			      ld    E, (HL) 
1361			      inc   HL 
1361			      ld    D, (HL) 
1361			 
1361			      pop   HL                      ; Add sizes of both blocks 
1361			      add   HL, DE 
1361			      ex    DE, HL 
1361			 
1361			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1361			      ld    H, (IX+3) 
1361			      inc   HL 
1361			      inc   HL 
1361			      ld    (HL), E 
1361			      inc   HL 
1361			      ld    (HL), D 
1361			 
1361			free_done: 
1361			      ld    HL, 4                   ; Clean up stack frame 
1361			      add   HL, SP 
1361			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361			      pop   IX 
1361			      pop   DE 
1361			      pop   BC 
1361			 
1361			      ret 
1361			 
1361			 
1361			;      .org 0x8000 
1361			; 
1361			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1361			 ;                 .dw   0 
1361			 
1361			endif 
1361			 
1361			 
1361			if MALLOC_4 
1361			 
1361			; My memory allocation code. Very very simple.... 
1361			; allocate space under 250 chars 
1361			 
1361			heap_init: 
1361				; init start of heap as zero 
1361				;  
1361			 
1361				ld hl, heap_start 
1361				ld a, 0 
1361				ld (hl), a      ; empty block 
1361				inc hl 
1361				ld a, 0 
1361				ld (hl), a      ; length of block 
1361				; write end of list 
1361				inc hl 
1361				ld a,(hl) 
1361				inc hl 
1361				ld a,(hl) 
1361				 
1361			 
1361				; init some malloc vars 
1361			 
1361				ld hl, 0 
1361				ld (free_list), hl       ; store last malloc location 
1361			 
1361				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1361				ld a, 0 
1361				ld (hl), a 
1361			 
1361			 
1361				ld hl, heap_start 
1361				;  
1361				  
1361				ret 
1361			 
1361			 
1361			;    free block marker 
1361			;    requested size  
1361			;    pointer to next block 
1361			;    .... 
1361			;    next block marker 
1361			 
1361			 
1361			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1361			; 
1361			 
1361			 
1361			malloc:  
1361				push de 
1361				push bc 
1361				push af 
1361			 
1361				; hl space required 
1361				 
1361				ld c, l    ; hold space   (TODO only a max of 255) 
1361			 
1361			;	inc c     ; TODO BUG need to fix memory leak on push str 
1361			;	inc c 
1361			;	inc c 
1361			;	inc c 
1361			;	inc c 
1361			;	inc c 
1361			;	inc c 
1361			 
1361			 
1361			 
1361				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1361			 
1361				ld a, (free_list+3) 
1361				cp 0 
1361				jr z, .contheap 
1361			 
1361				ld hl, (free_list)     ; get last alloc 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "mrs" 
1361						CALLMONITOR 
1361					endif 
1361				jr .startalloc 
1361			 
1361			.contheap: 
1361				ld hl, heap_start 
1361			 
1361			.startalloc: 
1361			 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "mym" 
1361						CALLMONITOR 
1361					endif 
1361			.findblock: 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "mmf" 
1361						CALLMONITOR 
1361					endif 
1361			 
1361				ld a,(hl)  
1361				; if byte is zero then clear to use 
1361			 
1361				cp 0 
1361				jr z, .foundemptyblock 
1361			 
1361				; if byte is not clear 
1361				;     then byte is offset to next block 
1361			 
1361				inc hl 
1361				ld a, (hl) ; get size 
1361			.nextblock:	inc hl 
1361					ld e, (hl) 
1361					inc hl 
1361					ld d, (hl) 
1361					ex de, hl 
1361			;	inc hl  ; move past the store space 
1361			;	inc hl  ; move past zero index  
1361			 
1361				; TODO detect no more space 
1361			 
1361				push hl 
1361				ld de, heap_end 
1361				call cmp16 
1361				pop hl 
1361				jr nc, .nospace 
1361			 
1361				jr .findblock 
1361			 
1361			.nospace: ld hl, 0 
1361				jp .exit 
1361			 
1361			 
1361			.foundemptyblock:	 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "mme" 
1361						CALLMONITOR 
1361					endif 
1361			 
1361			; TODO has block enough space if reusing??? 
1361			 
1361				;  
1361			 
1361			; see if this block has been previously used 
1361				inc hl 
1361				ld a, (hl) 
1361				dec hl 
1361				cp 0 
1361				jr z, .newblock 
1361			 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "meR" 
1361						CALLMONITOR 
1361					endif 
1361			 
1361			; no reusing previously allocated block 
1361			 
1361			; is it smaller than previously used? 
1361				 
1361				inc hl    ; move to size 
1361				ld a, c 
1361				sub (hl)        ; we want c < (hl) 
1361				dec hl    ; move back to marker 
1361			        jr z, .findblock 
1361			 
1361				; update with the new size which should be lower 
1361			 
1361			        ;inc  hl   ; negate next move. move back to size  
1361			 
1361			.newblock: 
1361				; need to be at marker here 
1361			 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "meN" 
1361						CALLMONITOR 
1361					endif 
1361			 
1361			 
1361				ld a, c 
1361			 
1361				ld (free_list+3), a	 ; flag resume from last malloc  
1361				ld (free_list), hl    ; save out last location 
1361			 
1361			 
1361				;inc a     ; space for length byte 
1361				ld (hl), a     ; save block in use marker 
1361			 
1361				inc hl   ; move to space marker 
1361				ld (hl), a    ; save new space 
1361			 
1361				inc hl   ; move to start of allocated area 
1361				 
1361			;	push hl     ; save where we are - 1  
1361			 
1361			;	inc hl  ; move past zero index  
1361				; skip space to set down new marker 
1361			 
1361				; provide some extra space for now 
1361			 
1361				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1361				inc a 
1361				inc a 
1361			 
1361				push hl   ; save where we are in the node block 
1361			 
1361				call addatohl 
1361			 
1361				; write linked list point 
1361			 
1361				pop de     ; get our node position 
1361				ex de, hl 
1361			 
1361				ld (hl), e 
1361				inc hl 
1361				ld (hl), d 
1361			 
1361				inc hl 
1361			 
1361				; now at start of allocated data so save pointer 
1361			 
1361				push hl 
1361			 
1361				; jump to position of next node and setup empty header in DE 
1361			 
1361				ex de, hl 
1361			 
1361			;	inc hl ; move past end of block 
1361			 
1361				ld a, 0 
1361				ld (hl), a   ; empty marker 
1361				inc hl 
1361				ld (hl), a   ; size 
1361				inc hl  
1361				ld (hl), a   ; ptr 
1361				inc hl 
1361				ld (hl), a   ; ptr 
1361			 
1361			 
1361				pop hl 
1361			 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "mmr" 
1361						CALLMONITOR 
1361					endif 
1361			 
1361			.exit: 
1361				pop af 
1361				pop bc 
1361				pop de  
1361				ret 
1361			 
1361			 
1361			 
1361			 
1361			free:  
1361				push hl 
1361				push af 
1361				; get address in hl 
1361			 
1361					if DEBUG_FORTH_MALLOC_INT 
1361						DMARK "fre" 
1361						CALLMONITOR 
1361					endif 
1361				; data is at hl - move to block count 
1361				dec hl 
1361				dec hl    ; get past pointer 
1361				dec hl 
1361			 
1361				ld a, (hl)    ; need this for a validation check 
1361			 
1361				dec hl    ; move to block marker 
1361			 
1361				; now check that the block count and block marker are the same  
1361			        ; this checks that we are on a malloc node and not random memory 
1361			        ; OK a faint chance this could be a problem but rare - famous last words! 
1361			 
1361				ld c, a 
1361				ld a, (hl)    
1361			 
1361				cp c 
1361				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1361			 
1361				; yes good chance we are on a malloc node 
1361			 
1361				ld a, 0      
1361				ld (hl), a   ; mark as free 
1361			 
1361				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1361			 
1361			.freeignore:  
1361			 
1361				pop af 
1361				pop hl 
1361			 
1361				ret 
1361			 
1361			 
1361			 
1361			endif 
1361			 
1361			; eof 
# End of file firmware_memory.asm
1361			  
1361			; device C  
1361			if SOUND_ENABLE  
1361				include "firmware_sound.asm"  
1361			endif  
1361			  
1361			include "firmware_diags.asm"  
1361			; Hardware diags menu 
1361			 
1361			 
1361			config: 
1361			 
1361 3e 00			ld a, 0 
1363 21 91 13			ld hl, .configmn 
1366 cd fe 0a			call menu 
1369			 
1369 fe 00			cp 0 
136b c8				ret z 
136c			 
136c fe 01			cp 1 
136e cc 6a 14			call z, .savetostore 
1371			 
1371 fe 02			cp 2 
1373 cc b8 13			call z, .selautoload 
1376 fe 03			cp 3 
1378 cc a1 13			call z, .disautoload 
137b fe 04			cp 4 
137d cc 68 14			call z, .selbank 
1380 fe 05			cp 5 
1382 cc 45 15			call z, .debug_tog 
1385 fe 06			cp 6 
1387 cc 88 16			call z, .bpsgo 
138a fe 07			cp 7 
138c cc 6b 15			call z, hardware_diags 
138f			 
138f 18 d0			jr config 
1391			 
1391			.configmn: 
1391 79 18			dw prom_c3 
1393 90 18			dw prom_c2 
1395 a5 18			dw prom_c2a 
1397 bb 18			dw prom_c2b 
1399			;	dw prom_c4 
1399 d8 18			dw prom_m4 
139b f3 18			dw prom_m4b 
139d fb 18			dw prom_c1 
139f 00 00			dw 0 
13a1				 
13a1			 
13a1			 
13a1			 
13a1			.disautoload: 
13a1				if STORAGE_SE 
13a1 3e fe			ld a, $fe      ; bit 0 clear 
13a3 32 c5 f9			ld (spi_device), a 
13a6			 
13a6 cd 90 03			call storage_get_block_0 
13a9			 
13a9 3e 00			ld a, 0 
13ab 32 00 fa			ld (store_page+STORE_0_AUTOFILE), a 
13ae			 
13ae 21 00 00				ld hl, 0 
13b1 11 df f9				ld de, store_page 
13b4 cd 44 03			call storage_write_block	 ; save update 
13b7				else 
13b7			 
13b7				ld hl, prom_notav 
13b7				ld de, prom_empty 
13b7				call info_panel 
13b7				endif 
13b7			 
13b7			 
13b7 c9				ret 
13b8			 
13b8			 
13b8			 
13b8			; Select auto start 
13b8			 
13b8			.selautoload: 
13b8			 
13b8				 
13b8				if STORAGE_SE 
13b8			 
13b8 cd 8f 14				call config_dir 
13bb 21 9a ef			        ld hl, scratch 
13be 3e 00				ld a, 0 
13c0 cd fe 0a				call menu 
13c3			 
13c3 fe 00				cp 0 
13c5 c8					ret z 
13c6			 
13c6 3d					dec a 
13c7			 
13c7			 
13c7					; locate menu option 
13c7			 
13c7 21 9a ef				ld hl, scratch 
13ca cd 22 0a				call table_lookup 
13cd			 
13cd					if DEBUG_FORTH_WORDS 
13cd						DMARK "ALl" 
13cd f5				push af  
13ce 3a e2 13			ld a, (.dmark)  
13d1 32 b4 fb			ld (debug_mark),a  
13d4 3a e3 13			ld a, (.dmark+1)  
13d7 32 b5 fb			ld (debug_mark+1),a  
13da 3a e4 13			ld a, (.dmark+2)  
13dd 32 b6 fb			ld (debug_mark+2),a  
13e0 18 03			jr .pastdmark  
13e2 ..			.dmark: db "ALl"  
13e5 f1			.pastdmark: pop af  
13e6			endm  
# End of macro DMARK
13e6						CALLMONITOR 
13e6 cd 7e 16			call break_point_state  
13e9				endm  
# End of macro CALLMONITOR
13e9					endif 
13e9					; with the pointer to the menu it, the byte following the zero term is the file id 
13e9			 
13e9 3e 00				ld a, 0 
13eb 01 32 00				ld bc, 50   ; max of bytes to look at 
13ee ed b1				cpir  
13f0			 
13f0					if DEBUG_FORTH_WORDS 
13f0						DMARK "ALb" 
13f0 f5				push af  
13f1 3a 05 14			ld a, (.dmark)  
13f4 32 b4 fb			ld (debug_mark),a  
13f7 3a 06 14			ld a, (.dmark+1)  
13fa 32 b5 fb			ld (debug_mark+1),a  
13fd 3a 07 14			ld a, (.dmark+2)  
1400 32 b6 fb			ld (debug_mark+2),a  
1403 18 03			jr .pastdmark  
1405 ..			.dmark: db "ALb"  
1408 f1			.pastdmark: pop af  
1409			endm  
# End of macro DMARK
1409						CALLMONITOR 
1409 cd 7e 16			call break_point_state  
140c				endm  
# End of macro CALLMONITOR
140c					endif 
140c					;inc hl 
140c			 
140c 7e					ld a, (hl)   ; file id 
140d					 
140d				        ; save bank and file ids 
140d			 
140d f5					push af 
140e			 
140e			; TODO need to save to block 0 on bank 1	 
140e			 
140e cd 90 03				call storage_get_block_0 
1411			 
1411					if DEBUG_FORTH_WORDS 
1411						DMARK "AL0" 
1411 f5				push af  
1412 3a 26 14			ld a, (.dmark)  
1415 32 b4 fb			ld (debug_mark),a  
1418 3a 27 14			ld a, (.dmark+1)  
141b 32 b5 fb			ld (debug_mark+1),a  
141e 3a 28 14			ld a, (.dmark+2)  
1421 32 b6 fb			ld (debug_mark+2),a  
1424 18 03			jr .pastdmark  
1426 ..			.dmark: db "AL0"  
1429 f1			.pastdmark: pop af  
142a			endm  
# End of macro DMARK
142a						CALLMONITOR 
142a cd 7e 16			call break_point_state  
142d				endm  
# End of macro CALLMONITOR
142d					endif 
142d f1					pop af 
142e			 
142e 32 03 fa				ld (store_page+STORE_0_FILERUN),a 
1431					 
1431					; save bank id 
1431			 
1431 3a c5 f9				ld a,(spi_device) 
1434 32 02 fa				ld (store_page+STORE_0_BANKRUN),a 
1437			 
1437					; enable auto run of store file 
1437			 
1437 3e 01				ld a, 1 
1439 32 00 fa				ld (store_page+STORE_0_AUTOFILE),a 
143c			 
143c					; save buffer 
143c			 
143c 21 00 00				ld hl, 0 
143f 11 df f9				ld de, store_page 
1442					if DEBUG_FORTH_WORDS 
1442						DMARK "ALw" 
1442 f5				push af  
1443 3a 57 14			ld a, (.dmark)  
1446 32 b4 fb			ld (debug_mark),a  
1449 3a 58 14			ld a, (.dmark+1)  
144c 32 b5 fb			ld (debug_mark+1),a  
144f 3a 59 14			ld a, (.dmark+2)  
1452 32 b6 fb			ld (debug_mark+2),a  
1455 18 03			jr .pastdmark  
1457 ..			.dmark: db "ALw"  
145a f1			.pastdmark: pop af  
145b			endm  
# End of macro DMARK
145b						CALLMONITOR 
145b cd 7e 16			call break_point_state  
145e				endm  
# End of macro CALLMONITOR
145e					endif 
145e cd 44 03			call storage_write_block	 ; save update 
1461			  
1461			 
1461			 
1461			 
1461 21 9a ef				ld hl, scratch 
1464 cd 7c 14				call config_fdir 
1467			 
1467				else 
1467			 
1467				ld hl, prom_notav 
1467				ld de, prom_empty 
1467				call info_panel 
1467			 
1467				endif 
1467 c9				ret 
1468			 
1468			 
1468			 
1468			; Select storage bank 
1468			 
1468			.selbank: 
1468			 
1468				if STORAGE_SE 
1468				else 
1468			 
1468				ld hl, prom_notav 
1468				ld de, prom_empty 
1468				call info_panel 
1468				endif 
1468				 
1468 c9				ret 
1469			 
1469			if STORAGE_SE 
1469			 
1469			.config_ldir:   
1469				; Load storage bank labels into menu array 
1469			 
1469				 
1469			 
1469			 
1469 c9				ret 
146a			 
146a			 
146a			endif 
146a			 
146a			 
146a			; Save user words to storage 
146a			 
146a			.savetostore: 
146a			 
146a				if STORAGE_SE 
146a			 
146a cd 8f 14				call config_dir 
146d 21 9a ef			        ld hl, scratch 
1470 3e 00				ld a, 0 
1472 cd fe 0a				call menu 
1475					 
1475 21 9a ef				ld hl, scratch 
1478 cd 7c 14				call config_fdir 
147b			 
147b				else 
147b			 
147b				ld hl, prom_notav 
147b				ld de, prom_empty 
147b				call info_panel 
147b			 
147b				endif 
147b			 
147b c9				ret 
147c			 
147c			 
147c			 
147c			if STORAGE_SE 
147c			 
147c			config_fdir: 
147c				; using the scratch dir go through and release the memory allocated for each string 
147c				 
147c 21 9a ef			ld hl, scratch 
147f 5e			.cfdir:	ld e,(hl) 
1480 23				inc hl 
1481 56				ld d,(hl) 
1482 23				inc hl 
1483			 
1483 eb				ex de, hl 
1484 cd 2a 0d			call ishlzero 
1487 c8				ret z     ; return on null pointer 
1488 cd 92 12			call free 
148b eb				ex de, hl 
148c 18 f1			jr .cfdir 
148e			 
148e			 
148e c9				ret 
148f			 
148f			 
148f			config_dir: 
148f			 
148f				; for the config menus that need to build a directory of storage call this routine 
148f				; it will construct a menu in scratch to pass to menu 
148f			 
148f				; open storage device 
148f			 
148f				; execute DIR to build a list of files and their ids into scratch in menu format 
148f				; once the menu has finished then will need to call config_fdir to release the strings 
148f				 
148f				; c = number items 
148f			 
148f				 
148f cd 90 03			call storage_get_block_0 
1492			 
1492 21 df f9			ld hl, store_page     ; get current id count 
1495 46				ld b, (hl) 
1496 0e 00			ld c, 0    ; count of files   
1498			 
1498			 
1498 21 9a ef			ld hl, scratch 
149b 22 db f9			ld (store_tmp2), hl    ; location to poke strings 
149e			 
149e				; check for empty drive 
149e			 
149e 3e 00			ld a, 0 
14a0 b8				cp b 
14a1 ca 3b 15			jp z, .dirdone 
14a4			 
14a4				 
14a4					if DEBUG_FORTH_WORDS 
14a4						DMARK "Cdc" 
14a4 f5				push af  
14a5 3a b9 14			ld a, (.dmark)  
14a8 32 b4 fb			ld (debug_mark),a  
14ab 3a ba 14			ld a, (.dmark+1)  
14ae 32 b5 fb			ld (debug_mark+1),a  
14b1 3a bb 14			ld a, (.dmark+2)  
14b4 32 b6 fb			ld (debug_mark+2),a  
14b7 18 03			jr .pastdmark  
14b9 ..			.dmark: db "Cdc"  
14bc f1			.pastdmark: pop af  
14bd			endm  
# End of macro DMARK
14bd						CALLMONITOR 
14bd cd 7e 16			call break_point_state  
14c0				endm  
# End of macro CALLMONITOR
14c0					endif 
14c0			 
14c0			 
14c0			.diritem:	 
14c0 c5				push bc 
14c1				; for each of the current ids do a search for them and if found push to stack 
14c1			 
14c1 21 40 00				ld hl, STORE_BLOCK_PHY 
14c4 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
14c6 58					ld e,b 
14c7			 
14c7 cd 12 06				call storage_findnextid 
14ca			 
14ca			 
14ca					; if found hl will be non zero 
14ca			 
14ca cd 2a 0d				call ishlzero 
14cd 28 69				jr z, .dirnotfound 
14cf			 
14cf					; increase count 
14cf			 
14cf c1					pop bc	 
14d0 0c					inc c 
14d1 c5					push bc 
14d2					 
14d2			 
14d2					; get file header and push the file name 
14d2			 
14d2 11 df f9				ld de, store_page 
14d5 cd df 02				call storage_read_block 
14d8			 
14d8					; push file id to stack 
14d8				 
14d8 3a df f9				ld a, (store_page) 
14db 26 00				ld h, 0 
14dd 6f					ld l, a 
14de			 
14de					;call forth_push_numhl 
14de					; TODO store id 
14de			 
14de e5					push hl 
14df			 
14df					; push extent count to stack  
14df				 
14df 21 e2 f9				ld hl, store_page+3 
14e2			 
14e2					; get file name length 
14e2			 
14e2 cd 5f 11				call strlenz   
14e5			 
14e5 23					inc hl   ; cover zero term 
14e6 23					inc hl  ; stick the id at the end of the area 
14e7			 
14e7 e5					push hl 
14e8 c1					pop bc    ; move length to bc 
14e9			 
14e9 cd c8 11				call malloc 
14ec			 
14ec					; TODO save malloc area to scratch 
14ec			 
14ec eb					ex de, hl 
14ed 2a db f9				ld hl, (store_tmp2) 
14f0 73					ld (hl), e 
14f1 23					inc hl 
14f2 72					ld (hl), d 
14f3 23					inc hl 
14f4 22 db f9				ld (store_tmp2), hl 
14f7			 
14f7					 
14f7			 
14f7					;pop hl   ; get source 
14f7			;		ex de, hl    ; swap aronund	 
14f7			 
14f7 21 e2 f9				ld hl, store_page+3 
14fa					if DEBUG_FORTH_WORDS 
14fa						DMARK "CFd" 
14fa f5				push af  
14fb 3a 0f 15			ld a, (.dmark)  
14fe 32 b4 fb			ld (debug_mark),a  
1501 3a 10 15			ld a, (.dmark+1)  
1504 32 b5 fb			ld (debug_mark+1),a  
1507 3a 11 15			ld a, (.dmark+2)  
150a 32 b6 fb			ld (debug_mark+2),a  
150d 18 03			jr .pastdmark  
150f ..			.dmark: db "CFd"  
1512 f1			.pastdmark: pop af  
1513			endm  
# End of macro DMARK
1513						CALLMONITOR 
1513 cd 7e 16			call break_point_state  
1516				endm  
# End of macro CALLMONITOR
1516					endif 
1516 ed b0				ldir 
1518			 
1518					; de is past string, move back one and store id 
1518					 
1518 1b					dec de 
1519			 
1519					; store file id 
1519			 
1519 e1					pop hl 
151a eb					ex de,hl 
151b 73					ld (hl), e 
151c			 
151c					if DEBUG_FORTH_WORDS 
151c						DMARK "Cdi" 
151c f5				push af  
151d 3a 31 15			ld a, (.dmark)  
1520 32 b4 fb			ld (debug_mark),a  
1523 3a 32 15			ld a, (.dmark+1)  
1526 32 b5 fb			ld (debug_mark+1),a  
1529 3a 33 15			ld a, (.dmark+2)  
152c 32 b6 fb			ld (debug_mark+2),a  
152f 18 03			jr .pastdmark  
1531 ..			.dmark: db "Cdi"  
1534 f1			.pastdmark: pop af  
1535			endm  
# End of macro DMARK
1535						CALLMONITOR 
1535 cd 7e 16			call break_point_state  
1538				endm  
# End of macro CALLMONITOR
1538					endif 
1538					 
1538			.dirnotfound: 
1538 c1					pop bc     
1539 10 85				djnz .diritem 
153b				 
153b			.dirdone:	 
153b			 
153b 3e 00				ld a, 0 
153d 2a db f9				ld hl, (store_tmp2) 
1540 77					ld (hl), a 
1541 23					inc hl 
1542 77					ld (hl), a 
1543 23					inc hl 
1544					; push a count of the dir items found 
1544			 
1544			;		ld h, 0 
1544			;		ld l, c 
1544			 
1544 c9				ret 
1545			 
1545			endif 
1545			 
1545			 
1545			; Settings 
1545			; Run  
1545			 
1545			 
1545			 
1545			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1545			;;hd_menu2:   db "        2: Editor",0   
1545			;hd_menu2:   db "        2: Editor       6: Menu",0   
1545			;hd_menu3:   db "        3: Storage",0 
1545			;hd_menu4:   db "0=quit  4: Debug",0 
1545			;hd_don:     db "ON",0 
1545			;hd_doff:     db "OFF",0 
1545			; 
1545			; 
1545			; 
1545			;hardware_diags_old:       
1545			; 
1545			;.diagmenu: 
1545			;	call clear_display 
1545			;	ld a, display_row_1 
1545			;	ld de, hd_menu1 
1545			;	call str_at_display 
1545			; 
1545			;	ld a, display_row_2 
1545			;	ld de, hd_menu2 
1545			;	call str_at_display 
1545			; 
1545			;	ld a, display_row_3 
1545			;	ld de, hd_menu3 
1545			;	call str_at_display 
1545			; 
1545			;	ld a,  display_row_4 
1545			;	ld de, hd_menu4 
1545			;	call str_at_display 
1545			; 
1545			;	; display debug state 
1545			; 
1545			;	ld de, hd_don 
1545			;	ld a, (os_view_disable) 
1545			;	cp 0 
1545			;	jr z, .distog 
1545			;	ld de, hd_doff 
1545			;.distog: ld a, display_row_4+17 
1545			;	call str_at_display 
1545			; 
1545			;	call update_display 
1545			; 
1545			;	call cin_wait 
1545			; 
1545			; 
1545			; 
1545			;	cp '4' 
1545			;	jr nz, .diagn1 
1545			; 
1545			;	; debug toggle 
1545			; 
1545			;	ld a, (os_view_disable) 
1545			;	ld b, '*' 
1545			;	cp 0 
1545			;	jr z, .debtog 
1545			;	ld b, 0 
1545			;.debtog:	 
1545			;	ld a,b 
1545			;	ld (os_view_disable),a 
1545			; 
1545			;.diagn1: cp '0' 
1545			;	 ret z 
1545			; 
1545			;;	cp '1' 
1545			;;       jp z, matrix	 
1545			;;   TODO keyboard matrix test 
1545			; 
1545			;	cp '2' 
1545			;	jp z, .diagedit 
1545			; 
1545			;;	cp '6' 
1545			;;	jp z, .menutest 
1545			;;if ENABLE_BASIC 
1545			;;	cp '6' 
1545			;;	jp z, basic 
1545			;;endif 
1545			 ; 
1545			;	jp .diagmenu 
1545			; 
1545			; 
1545			;	ret 
1545			 
1545			 
1545			.debug_tog: 
1545 21 8c 15			ld hl, .menudebug 
1548				 
1548 3a 8b ef			ld a, (os_view_disable) 
154b fe 2a			cp '*' 
154d 20 04			jr nz,.tdon  
154f 3e 01			ld a, 1 
1551 18 02			jr .tog1 
1553 3e 00		.tdon: ld a, 0 
1555			 
1555			.tog1: 
1555 cd fe 0a			call menu 
1558 fe 00			cp 0 
155a c8				ret z 
155b fe 01			cp 1    ; disable debug 
155d 28 04			jr z, .dtog0 
155f 3e 2a			ld a, '*' 
1561 18 02			jr .dtogset 
1563 3e 00		.dtog0: ld a, 0 
1565 32 8b ef		.dtogset:  ld (os_view_disable), a 
1568 c3 45 15			jp .debug_tog 
156b			 
156b			 
156b			hardware_diags:       
156b			 
156b			.diagm: 
156b 21 7e 15			ld hl, .menuitems 
156e 3e 00			ld a, 0 
1570 cd fe 0a			call menu 
1573			 
1573 fe 00		         cp 0 
1575 c8				 ret z 
1576			 
1576 fe 02			cp 2 
1578 ca d7 15			jp z, .diagedit 
157b			 
157b			;	cp '6' 
157b			;	jp z, .menutest 
157b			;if ENABLE_BASIC 
157b			;	cp '6' 
157b			;	jp z, basic 
157b			;endif 
157b			  
157b c3 6b 15			jp .diagm 
157e			 
157e				 
157e 92 15		.menuitems:   	dw .m1 
1580 9d 15				dw .m2 
1582 a4 15				dw .m3 
1584 ac 15				dw .m5 
1586 b2 15				dw .m5a 
1588 bb 15				dw .m5b 
158a 00 00				dw 0 
158c			 
158c			.menudebug: 
158c c4 15				dw .m6 
158e cd 15				dw .m7 
1590 00 00				dw 0 
1592			 
1592 .. 00		.m1:   db "Key Matrix",0 
159d .. 00		.m2:   db "Editor",0 
15a4 .. 00		.m3:   db "Storage",0 
15ac .. 00		.m5:   db "Sound",0 
15b2 .. 00		.m5a:  db "RAM Test",0 
15bb .. 00		.m5b:  db "LCD Test",0 
15c4			 
15c4 .. 00		.m6:   db "Debug ON",0 
15cd .. 00		.m7:   db "Debug OFF",0 
15d7			 
15d7			; debug editor 
15d7			 
15d7			.diagedit: 
15d7			 
15d7 21 9a ef			ld hl, scratch 
15da			;	ld bc, 250 
15da			;	ldir 
15da				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
15da 3e 00			ld a, 0 
15dc 77				ld (hl), a 
15dd 23				inc hl 
15de 77				ld (hl), a 
15df 23				inc hl 
15e0 77				ld (hl), a 
15e1			 
15e1 cd cd 0a		        call clear_display 
15e4 cd f0 0a			call update_display 
15e7				;ld a, 1 
15e7				;ld (hardware_diag), a 
15e7			.diloop: 
15e7 3e 00			ld a, display_row_1 
15e9 0e 00			ld c, 0 
15eb 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
15ed 1e 28			ld e, 40 
15ef			 
15ef 21 9a ef			ld hl, scratch	 
15f2 cd 2e 0d			call input_str 
15f5			 
15f5 3e 14			ld a, display_row_2 
15f7 11 9a ef			ld de, scratch 
15fa cd e0 0a			call str_at_display 
15fd cd f0 0a			call update_display 
1600			 
1600 c3 e7 15			jp .diloop 
1603			 
1603			 
1603			; pass word in hl 
1603			; a has display location 
1603			display_word_at: 
1603 f5				push af 
1604 e5				push hl 
1605 7c				ld a,h 
1606 21 9f f2			ld hl, os_word_scratch 
1609 cd 02 10			call hexout 
160c e1				pop hl 
160d 7d				ld a,l 
160e 21 a1 f2			ld hl, os_word_scratch+2 
1611 cd 02 10			call hexout 
1614 21 a3 f2			ld hl, os_word_scratch+4 
1617 3e 00			ld a,0 
1619 77				ld (hl),a 
161a 11 9f f2			ld de,os_word_scratch 
161d f1				pop af 
161e cd e0 0a				call str_at_display 
1621 c9				ret 
1622			 
1622			display_ptr_state: 
1622			 
1622				; to restore afterwards 
1622			 
1622 d5				push de 
1623 c5				push bc 
1624 e5				push hl 
1625 f5				push af 
1626			 
1626				; for use in here 
1626			 
1626			;	push bc 
1626			;	push de 
1626			;	push hl 
1626			;	push af 
1626			 
1626 cd cd 0a			call clear_display 
1629			 
1629 11 fc 17			ld de, .ptrstate 
162c 3e 00			ld a, display_row_1 
162e cd e0 0a			call str_at_display 
1631			 
1631				; display debug step 
1631			 
1631			 
1631 11 b4 fb			ld de, debug_mark 
1634 3e 12			ld a, display_row_1+display_cols-2 
1636 cd e0 0a			call str_at_display 
1639			 
1639				; display a 
1639 11 06 18			ld de, .ptrcliptr 
163c 3e 14			ld a, display_row_2 
163e cd e0 0a			call str_at_display 
1641			 
1641 f1				pop af 
1642 2a a5 f9			ld hl,(cli_ptr) 
1645 3e 1c			ld a, display_row_2+8 
1647 cd 03 16			call display_word_at 
164a			 
164a			 
164a				; display hl 
164a			 
164a			 
164a 11 0e 18			ld de, .ptrclioptr 
164d 3e 1e			ld a, display_row_2+10 
164f cd e0 0a			call str_at_display 
1652			; 
1652			;	pop hl 
1652 3e 21			ld a, display_row_2+13 
1654 2a a3 f9			ld hl,(cli_origptr) 
1657 cd 03 16			call display_word_at 
165a			; 
165a			;	 
165a			;	; display de 
165a			 
165a			;	ld de, .regstatede 
165a			;	ld a, display_row_3 
165a			;	call str_at_display 
165a			 
165a			;	pop de 
165a			;	ld h,d 
165a			;	ld l, e 
165a			;	ld a, display_row_3+3 
165a			;	call display_word_at 
165a			 
165a			 
165a				; display bc 
165a			 
165a			;	ld de, .regstatebc 
165a			;	ld a, display_row_3+10 
165a			;	call str_at_display 
165a			 
165a			;	pop bc 
165a			;	ld h,b 
165a			;	ld l, c 
165a			;	ld a, display_row_3+13 
165a			;	call display_word_at 
165a			 
165a			 
165a				; display dsp 
165a			 
165a			;	ld de, .regstatedsp 
165a			;	ld a, display_row_4 
165a			;	call str_at_display 
165a			 
165a				 
165a			;	ld hl,(cli_data_sp) 
165a			;	ld a, display_row_4+4 
165a			;	call display_word_at 
165a			 
165a				; display rsp 
165a			 
165a 11 3d 18			ld de, .regstatersp 
165d 3e 46			ld a, display_row_4+10 
165f cd e0 0a			call str_at_display 
1662			 
1662				 
1662 2a 8b f9			ld hl,(cli_ret_sp) 
1665 3e 4a			ld a, display_row_4+14 
1667 cd 03 16			call display_word_at 
166a			 
166a cd f0 0a			call update_display 
166d			 
166d cd 4a 0a			call delay1s 
1670 cd 4a 0a			call delay1s 
1673 cd 4a 0a			call delay1s 
1676			 
1676			 
1676 cd 53 1c			call next_page_prompt 
1679			 
1679				; restore  
1679			 
1679 f1				pop af 
167a e1				pop hl 
167b c1				pop bc 
167c d1				pop de 
167d c9				ret 
167e			 
167e			break_point_state: 
167e f5				push af 
167f			 
167f				; see if disabled 
167f			 
167f 3a 8b ef			ld a, (os_view_disable) 
1682 fe 2a			cp '*' 
1684 20 02			jr nz, .bpsgo 
1686 f1				pop af 
1687 c9				ret 
1688			 
1688			.bpsgo: 
1688 f1				pop af 
1689 f5				push af 
168a 22 87 ef			ld (os_view_hl), hl 
168d ed 53 85 ef		ld (os_view_de), de 
1691 ed 43 83 ef		ld (os_view_bc), bc 
1695 e5				push hl 
1696 6f				ld l, a 
1697 26 00			ld h, 0 
1699 22 89 ef			ld (os_view_af),hl 
169c			 
169c 21 4a fb				ld hl, display_fb0 
169f 22 55 fa				ld (display_fb_active), hl 
16a2 e1				pop hl	 
16a3			 
16a3 3e 31			ld a, '1' 
16a5 fe 2a		.bps1:  cp '*' 
16a7 20 03			jr nz, .bps1b 
16a9 32 8b ef			ld (os_view_disable),a 
16ac fe 31		.bps1b:  cp '1' 
16ae 20 14			jr nz, .bps2 
16b0			 
16b0				; display reg 
16b0			 
16b0				 
16b0			 
16b0 3a 89 ef			ld a, (os_view_af) 
16b3 2a 87 ef			ld hl, (os_view_hl) 
16b6 ed 5b 85 ef		ld de, (os_view_de) 
16ba ed 4b 83 ef		ld bc, (os_view_bc) 
16be cd 58 17			call display_reg_state 
16c1 c3 44 17			jp .bpschk 
16c4			 
16c4 fe 32		.bps2:  cp '2' 
16c6 20 08			jr nz, .bps3 
16c8				 
16c8				; display hl 
16c8 2a 87 ef			ld hl, (os_view_hl) 
16cb cd 42 18			call display_dump_at_hl 
16ce			 
16ce 18 74			jr .bpschk 
16d0			 
16d0 fe 33		.bps3:  cp '3' 
16d2 20 08			jr nz, .bps4 
16d4			 
16d4			        ; display de 
16d4 2a 85 ef			ld hl, (os_view_de) 
16d7 cd 42 18			call display_dump_at_hl 
16da			 
16da 18 68			jr .bpschk 
16dc fe 34		.bps4:  cp '4' 
16de 20 08			jr nz, .bps5 
16e0			 
16e0			        ; display bc 
16e0 2a 83 ef			ld hl, (os_view_bc) 
16e3 cd 42 18			call display_dump_at_hl 
16e6			 
16e6 18 5c			jr .bpschk 
16e8 fe 35		.bps5:  cp '5' 
16ea 20 08		        jr nz, .bps7 
16ec			 
16ec				; display cur ptr 
16ec 2a a5 f9			ld hl, (cli_ptr) 
16ef cd 42 18			call display_dump_at_hl 
16f2			 
16f2 18 50			jr .bpschk 
16f4 fe 36		.bps7:  cp '6' 
16f6 20 08			jr nz, .bps8b 
16f8				 
16f8				; display cur orig ptr 
16f8 2a a3 f9			ld hl, (cli_origptr) 
16fb cd 42 18			call display_dump_at_hl 
16fe 18 44			jr .bpschk 
1700 fe 37		.bps8b:  cp '7' 
1702 20 08			jr nz, .bps9 
1704				 
1704				; display dsp 
1704 2a 87 f9			ld hl, (cli_data_sp) 
1707 cd 42 18			call display_dump_at_hl 
170a			 
170a 18 38			jr .bpschk 
170c fe 39		.bps9:  cp '9' 
170e 20 05			jr nz, .bps8c 
1710				 
1710				; display SP 
1710			;	ld hl, sp 
1710 cd 42 18			call display_dump_at_hl 
1713			 
1713 18 2f			jr .bpschk 
1715 fe 38		.bps8c:  cp '8' 
1717 20 08			jr nz, .bps8d 
1719				 
1719				; display rsp 
1719 2a 8b f9			ld hl, (cli_ret_sp) 
171c cd 42 18			call display_dump_at_hl 
171f			 
171f 18 23			jr .bpschk 
1721 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1723 20 05			jr nz, .bps8 
1725 cd 49 1a			call monitor 
1728			 
1728 18 1a			jr .bpschk 
172a fe 30		.bps8:  cp '0' 
172c 20 16			jr nz, .bpschk 
172e			 
172e 21 f9 fa				ld hl, display_fb1 
1731 22 55 fa				ld (display_fb_active), hl 
1734 cd f0 0a				call update_display 
1737			 
1737				;ld a, (os_view_af) 
1737 2a 87 ef			ld hl, (os_view_hl) 
173a ed 5b 85 ef		ld de, (os_view_de) 
173e ed 4b 83 ef		ld bc, (os_view_bc) 
1742 f1				pop af 
1743 c9				ret 
1744			 
1744			.bpschk:   
1744 cd 4a 0a			call delay1s 
1747 3e 4f		ld a,display_row_4 + display_cols - 1 
1749 11 51 1c		        ld de, endprg 
174c cd e0 0a			call str_at_display 
174f cd f0 0a			call update_display 
1752 cd 5c 67			call cin_wait 
1755			 
1755 c3 a5 16			jp .bps1 
1758			 
1758			 
1758			display_reg_state: 
1758			 
1758				; to restore afterwards 
1758			 
1758 d5				push de 
1759 c5				push bc 
175a e5				push hl 
175b f5				push af 
175c			 
175c				; for use in here 
175c			 
175c c5				push bc 
175d d5				push de 
175e e5				push hl 
175f f5				push af 
1760			 
1760 cd cd 0a			call clear_display 
1763			 
1763 11 18 18			ld de, .regstate 
1766 3e 00			ld a, display_row_1 
1768 cd e0 0a			call str_at_display 
176b			 
176b				; display debug step 
176b			 
176b			 
176b 11 b4 fb			ld de, debug_mark 
176e 3e 11			ld a, display_row_1+display_cols-3 
1770 cd e0 0a			call str_at_display 
1773			 
1773				; display a 
1773 11 34 18			ld de, .regstatea 
1776 3e 14			ld a, display_row_2 
1778 cd e0 0a			call str_at_display 
177b			 
177b e1				pop hl 
177c			;	ld h,0 
177c			;	ld l, a 
177c 3e 17			ld a, display_row_2+3 
177e cd 03 16			call display_word_at 
1781			 
1781			 
1781				; display hl 
1781			 
1781			 
1781 11 28 18			ld de, .regstatehl 
1784 3e 1e			ld a, display_row_2+10 
1786 cd e0 0a			call str_at_display 
1789			 
1789 e1				pop hl 
178a 3e 21			ld a, display_row_2+13 
178c cd 03 16			call display_word_at 
178f			 
178f				 
178f				; display de 
178f			 
178f 11 2c 18			ld de, .regstatede 
1792 3e 28			ld a, display_row_3 
1794 cd e0 0a			call str_at_display 
1797			 
1797 e1				pop hl 
1798			;	ld h,d 
1798			;	ld l, e 
1798 3e 2b			ld a, display_row_3+3 
179a cd 03 16			call display_word_at 
179d			 
179d			 
179d				; display bc 
179d			 
179d 11 30 18			ld de, .regstatebc 
17a0 3e 32			ld a, display_row_3+10 
17a2 cd e0 0a			call str_at_display 
17a5			 
17a5 e1				pop hl 
17a6			;	ld h,b 
17a6			;	ld l, c 
17a6 3e 35			ld a, display_row_3+13 
17a8 cd 03 16			call display_word_at 
17ab			 
17ab			 
17ab				; display dsp 
17ab			 
17ab 11 38 18			ld de, .regstatedsp 
17ae 3e 3c			ld a, display_row_4 
17b0 cd e0 0a			call str_at_display 
17b3			 
17b3				 
17b3 2a 87 f9			ld hl,(cli_data_sp) 
17b6 3e 40			ld a, display_row_4+4 
17b8 cd 03 16			call display_word_at 
17bb			 
17bb				; display rsp 
17bb			 
17bb 11 3d 18			ld de, .regstatersp 
17be 3e 46			ld a, display_row_4+10 
17c0 cd e0 0a			call str_at_display 
17c3			 
17c3				 
17c3 2a 8b f9			ld hl,(cli_ret_sp) 
17c6 3e 4a			ld a, display_row_4+14 
17c8 cd 03 16			call display_word_at 
17cb			 
17cb cd f0 0a			call update_display 
17ce			 
17ce			;	call delay1s 
17ce			;	call delay1s 
17ce			;	call delay1s 
17ce			 
17ce			 
17ce			;	call next_page_prompt 
17ce			 
17ce				; restore  
17ce			 
17ce f1				pop af 
17cf e1				pop hl 
17d0 c1				pop bc 
17d1 d1				pop de 
17d2 c9				ret 
17d3			 
17d3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
17e7 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
17fc .. 00		.ptrstate:	db "Ptr State",0 
1806 .. 00		.ptrcliptr:     db "cli_ptr",0 
180e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1818 .. 00		.regstate:	db "Reg State (1/0)",0 
1828 .. 00		.regstatehl:	db "HL:",0 
182c .. 00		.regstatede:	db "DE:",0 
1830 .. 00		.regstatebc:	db "BC:",0 
1834 .. 00		.regstatea:	db "A :",0 
1838 .. 00		.regstatedsp:	db "DSP:",0 
183d .. 00		.regstatersp:	db "RSP:",0 
1842			 
1842			display_dump_at_hl: 
1842 e5				push hl 
1843 d5				push de 
1844 c5				push bc 
1845 f5				push af 
1846			 
1846 22 bd f2			ld (os_cur_ptr),hl	 
1849 cd cd 0a			call clear_display 
184c cd 5b 1b			call dumpcont 
184f			;	call delay1s 
184f			;	call next_page_prompt 
184f			 
184f			 
184f f1				pop af 
1850 c1				pop bc 
1851 d1				pop de 
1852 e1				pop hl 
1853 c9				ret 
1854			 
1854			;if ENABLE_BASIC 
1854			;	include "nascombasic.asm" 
1854			;	basic: 
1854			;	include "forth/FORTH.ASM" 
1854			;endif 
1854			 
1854			; eof 
1854			 
1854			 
# End of file firmware_diags.asm
1854			  
1854			include "firmware_prompts.asm"  
1854			; Prompts  
1854			 
1854			; boot messages 
1854			 
1854 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.5",0 
1869 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1879			 
1879			 
1879			; config menus 
1879			 
1879 .. 00		prom_c3: db "Add Dictionary To File",0 
1890 .. 00		prom_c2: db "Select Autoload File",0 
18a5 .. 00		prom_c2a: db "Disable Autoload File", 0 
18bb .. 00		prom_c2b: db "Select Storage Bank",0 
18cf .. 00		prom_c4: db "Settings",0 
18d8 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
18f3 .. 00		prom_m4b:   db "Monitor",0 
18fb .. 00		prom_c1: db "Hardware Diags",0 
190a			 
190a			 
190a .. 00		prom_notav:    db "Feature not available",0 
1920 .. 00		prom_empty:    db "",0 
1921			 
1921			; eof 
1921			 
# End of file firmware_prompts.asm
1921			  
1921			  
1921			; eof  
1921			  
# End of file firmware.asm
1921			 
1921			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1921			;if BASE_KEV  
1921			;baseram: equ 08000h 
1921			;endif 
1921			 
1921			;if BASE_SC114 
1921			;baseram:     equ    endofcode 
1921			;endif 
1921			 
1921			 
1921			; start system 
1921			 
1921			coldstart: 
1921				; set sp 
1921				; di/ei 
1921			 
1921 f3				di 
1922 31 fd ff			ld sp, tos 
1925			;	ei 
1925			 
1925			 
1925				; disable breakpoint by default 
1925			 
1925 3e 2a			ld a,'*' 
1927 32 8b ef			ld (os_view_disable),a 
192a			 
192a				; init hardware 
192a			 
192a				; init keyboard and screen hardware 
192a			 
192a cd 03 00			call hardware_init 
192d			 
192d			 
192d				; detect if any keys are held down to enable breakpoints at start up 
192d			 
192d cd 6d 67			call cin  
1930 fe 00			cp 0 
1932 28 03			jr z, .nokeys 
1934			 
1934				;call hardware_diags 
1934 cd 61 13			call config 
1937			 
1937			;	ld de, .bpen 
1937			;	ld a, display_row_4 
1937			;	call str_at_display 
1937			;	call update_display 
1937			; 
1937			;	ld a,0 
1937			;	ld (os_view_disable),a 
1937			; 
1937			;.bpwait: 
1937			;	call cin 
1937			;	cp 0 
1937			;	jr z, .bpwait 
1937			;	jr .nokeys 
1937			; 
1937			; 
1937			;.bpen:  db "Break points enabled!",0 
1937			 
1937			 
1937			 
1937			 
1937			 
1937			 
1937			.nokeys: 
1937			 
1937			 
1937				 
1937			 
1937			;jp  testkey 
1937			 
1937			;call storage_get_block_0 
1937			; 
1937			;ld hl, 0 
1937			;ld de, store_page 
1937			;call storage_read_block 
1937			 
1937				 
1937			;ld hl, 10 
1937			;ld de, store_page 
1937			;call storage_read_block 
1937			 
1937			 
1937			 
1937			 
1937			 
1937			;stop:	nop 
1937			;	jp stop 
1937			 
1937			 
1937			 
1937			main: 
1937 cd cd 0a			call clear_display 
193a cd f0 0a			call update_display 
193d			 
193d			 
193d			 
193d			;	call testlcd 
193d			 
193d			 
193d			 
193d cd 19 20			call forth_init 
1940			 
1940			 
1940			warmstart: 
1940 cd ef 1f			call forth_warmstart 
1943			 
1943				; run startup word load 
1943			        ; TODO prevent this running at warmstart after crash  
1943			 
1943				if STARTUP_ENABLE 
1943					if STORAGE_SE 
1943 cd 9e 64					call forth_autoload 
1946					endif 
1946 cd ad 61				call forth_startup 
1949			 
1949			 
1949				endif 
1949			 
1949				; show free memory after boot 
1949 11 e3 19			ld de, freeram 
194c 3e 00			ld a, display_row_1 
194e cd e0 0a			call str_at_display 
1951			 
1951			; Or use heap_size word???? 
1951 21 80 ef			ld hl, heap_end 
1954 11 0e 80			ld de, heap_start 
1957 ed 52			sbc hl, de 
1959 e5				push hl 
195a 7c				ld a,h	         	 
195b 21 9f f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
195e cd 02 10			call hexout 
1961 e1			   	pop hl 
1962			 
1962 7d				ld a,l 
1963 21 a1 f2			ld hl, os_word_scratch+2 
1966 cd 02 10			call hexout 
1969 21 a3 f2			ld hl, os_word_scratch+4 
196c 3e 00			ld a, 0 
196e 77				ld (hl),a 
196f 11 9f f2			ld de, os_word_scratch 
1972 3e 0d			ld a, display_row_1 + 13 
1974 cd e0 0a			call str_at_display 
1977 cd f0 0a			call update_display 
197a			 
197a			 
197a				;call demo 
197a			 
197a			 
197a				; init scratch input area for cli commands 
197a			 
197a 21 c1 f2			ld hl, os_cli_cmd 
197d 3e 00			ld a,0 
197f 77				ld (hl),a 
1980 23				inc hl 
1981 77				ld (hl),a 
1982			 
1982 3e 00			ld a,0 
1984 32 c0 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1987			 
1987 32 bd f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
198a 32 be f2			ld (os_cur_ptr+1),a	 
198d			 
198d 32 9f f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1990 32 a0 f2			ld (os_word_scratch+1),a	 
1993				 
1993			 
1993				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1993 21 c1 f2			ld hl, os_cli_cmd 
1996			 
1996 3e 00			ld a, 0		 ; init cli input 
1998 77				ld (hl), a 
1999 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
199b			cli: 
199b				; show cli prompt 
199b				;push af 
199b				;ld a, 0 
199b				;ld de, prompt 
199b				;call str_at_display 
199b			 
199b				;call update_display 
199b				;pop af 
199b				;inc a 
199b				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
199b 0e 00			ld c, 0 
199d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
199f 1e 28			ld e, 40 
19a1			 
19a1 21 c1 f2			ld hl, os_cli_cmd 
19a4			 
19a4				STACKFRAME OFF $fefe $9f9f 
19a4				if DEBUG_STACK_IMB 
19a4					if OFF 
19a4						exx 
19a4						ld de, $fefe 
19a4						ld a, d 
19a4						ld hl, curframe 
19a4						call hexout 
19a4						ld a, e 
19a4						ld hl, curframe+2 
19a4						call hexout 
19a4						ld hl, $fefe 
19a4						push hl 
19a4						ld hl, $9f9f 
19a4						push hl 
19a4						exx 
19a4					endif 
19a4				endif 
19a4			endm 
# End of macro STACKFRAME
19a4			 
19a4 cd 2e 0d			call input_str 
19a7			 
19a7				STACKFRAMECHK OFF $fefe $9f9f 
19a7				if DEBUG_STACK_IMB 
19a7					if OFF 
19a7						exx 
19a7						ld hl, $9f9f 
19a7						pop de   ; $9f9f 
19a7						call cmp16 
19a7						jr nz, .spnosame 
19a7						ld hl, $fefe 
19a7						pop de   ; $fefe 
19a7						call cmp16 
19a7						jr z, .spfrsame 
19a7						.spnosame: call showsperror 
19a7						.spfrsame: nop 
19a7						exx 
19a7					endif 
19a7				endif 
19a7			endm 
# End of macro STACKFRAMECHK
19a7			 
19a7				; copy input to last command 
19a7			 
19a7 21 c1 f2			ld hl, os_cli_cmd 
19aa 11 c0 f3			ld de, os_last_cmd 
19ad 01 ff 00			ld bc, 255 
19b0 ed b0			ldir 
19b2			 
19b2				; wipe current buffer 
19b2			 
19b2			;	ld a, 0 
19b2			;	ld hl, os_cli_cmd 
19b2			;	ld de, os_cli_cmd+1 
19b2			;	ld bc, 254 
19b2			;	ldir 
19b2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19b2			;	call strcpy 
19b2			;	ld a, 0 
19b2			;	ld (hl), a 
19b2			;	inc hl 
19b2			;	ld (hl), a 
19b2			;	inc hl 
19b2			;	ld (hl), a 
19b2			 
19b2				; switch frame buffer to program  
19b2			 
19b2 21 f9 fa				ld hl, display_fb1 
19b5 22 55 fa				ld (display_fb_active), hl 
19b8			 
19b8			;	nop 
19b8				STACKFRAME ON $fbfe $8f9f 
19b8				if DEBUG_STACK_IMB 
19b8					if ON 
19b8						exx 
19b8						ld de, $fbfe 
19b8						ld a, d 
19b8						ld hl, curframe 
19b8						call hexout 
19b8						ld a, e 
19b8						ld hl, curframe+2 
19b8						call hexout 
19b8						ld hl, $fbfe 
19b8						push hl 
19b8						ld hl, $8f9f 
19b8						push hl 
19b8						exx 
19b8					endif 
19b8				endif 
19b8			endm 
# End of macro STACKFRAME
19b8				; first time into the parser so pass over the current scratch pad 
19b8 21 c1 f2			ld hl,os_cli_cmd 
19bb				; tokenise the entered statement(s) in HL 
19bb cd 92 20			call forthparse 
19be			        ; exec forth statements in top of return stack 
19be cd d2 20			call forthexec 
19c1				;call forthexec_cleanup 
19c1			;	call parsenext 
19c1			 
19c1				STACKFRAMECHK ON $fbfe $8f9f 
19c1				if DEBUG_STACK_IMB 
19c1					if ON 
19c1						exx 
19c1						ld hl, $8f9f 
19c1						pop de   ; $8f9f 
19c1						call cmp16 
19c1						jr nz, .spnosame 
19c1						ld hl, $fbfe 
19c1						pop de   ; $fbfe 
19c1						call cmp16 
19c1						jr z, .spfrsame 
19c1						.spnosame: call showsperror 
19c1						.spfrsame: nop 
19c1						exx 
19c1					endif 
19c1				endif 
19c1			endm 
# End of macro STACKFRAMECHK
19c1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19c1			 
19c1 3e 3c			ld a, display_row_4 
19c3 11 f5 19			ld de, endprog 
19c6			 
19c6 cd f0 0a			call update_display		 
19c9			 
19c9 cd 53 1c			call next_page_prompt 
19cc			 
19cc				; switch frame buffer to cli 
19cc			 
19cc 21 4a fb				ld hl, display_fb0 
19cf 22 55 fa				ld (display_fb_active), hl 
19d2			 
19d2			 
19d2 cd cd 0a		        call clear_display 
19d5 cd f0 0a			call update_display		 
19d8			 
19d8 21 c1 f2			ld hl, os_cli_cmd 
19db			 
19db 3e 00			ld a, 0		 ; init cli input 
19dd 77				ld (hl), a 
19de			 
19de				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19de			 
19de				; now on last line 
19de			 
19de				; TODO scroll screen up 
19de			 
19de				; TODO instead just clear screen and place at top of screen 
19de			 
19de			;	ld a, 0 
19de			;	ld (f_cursor_ptr),a 
19de			 
19de				;call clear_display 
19de				;call update_display 
19de			 
19de				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19de 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19e0 c3 9b 19			jp cli 
19e3			 
19e3 .. 00		freeram: db "Free bytes: $",0 
19f1 ..			asc: db "1A2F" 
19f5 .. 00		endprog: db "End prog...",0 
1a01			 
1a01			testenter2:   
1a01 21 cc ef			ld hl,scratch+50 
1a04 22 bd f2			ld (os_cur_ptr),hl 
1a07 c3 9b 19			jp cli 
1a0a			 
1a0a			testenter:  
1a0a			 
1a0a 21 f1 19			ld hl,asc 
1a0d			;	ld a,(hl) 
1a0d			;	call nibble2val 
1a0d cd 58 10			call get_byte 
1a10			 
1a10			 
1a10			;	ld a,(hl) 
1a10			;	call atohex 
1a10			 
1a10			;	call fourehexhl 
1a10 32 cc ef			ld (scratch+50),a 
1a13			 
1a13			 
1a13			 
1a13 21 f3 19			ld hl,asc+2 
1a16			;	ld a, (hl) 
1a16			;	call nibble2val 
1a16 cd 58 10			call get_byte 
1a19			 
1a19			;	call fourehexhl 
1a19 32 ce ef			ld (scratch+52),a 
1a1c				 
1a1c 21 cc ef			ld hl,scratch+50 
1a1f 22 bd f2			ld (os_cur_ptr),hl 
1a22 c3 9b 19			jp cli 
1a25			 
1a25			enter:	 
1a25 3a 9e ef			ld a,(scratch+4) 
1a28 fe 00			cp 0 
1a2a 28 0c			jr z, .entercont 
1a2c				; no, not a null term line so has an address to work out.... 
1a2c			 
1a2c 21 9c ef			ld hl,scratch+2 
1a2f cd b8 10			call get_word_hl 
1a32			 
1a32 22 bd f2			ld (os_cur_ptr),hl	 
1a35 c3 9b 19			jp cli 
1a38			 
1a38			 
1a38			.entercont:  
1a38			 
1a38 21 9c ef			ld hl, scratch+2 
1a3b cd 58 10			call get_byte 
1a3e			 
1a3e 2a bd f2		   	ld hl,(os_cur_ptr) 
1a41 77					ld (hl),a 
1a42 23					inc hl 
1a43 22 bd f2				ld (os_cur_ptr),hl 
1a46				 
1a46			; get byte  
1a46			 
1a46			 
1a46 c3 9b 19			jp cli 
1a49			 
1a49			 
1a49			; basic monitor support 
1a49			 
1a49			monitor: 
1a49				;  
1a49 cd cd 0a			call clear_display 
1a4c 3e 00			ld a, 0 
1a4e 11 96 1a			ld de, .monprompt 
1a51 cd e0 0a			call str_at_display 
1a54 cd f0 0a			call update_display 
1a57			 
1a57				; get a monitor command 
1a57			 
1a57 0e 00			ld c, 0     ; entry at top left 
1a59 16 64			ld d, 100   ; max buffer size 
1a5b 1e 0f			ld e, 15    ; input scroll area 
1a5d 3e 00			ld a, 0     ; init string 
1a5f 21 98 f1			ld hl, os_input 
1a62 77				ld (hl), a 
1a63 23				inc hl 
1a64 77				ld (hl), a 
1a65 21 98 f1			ld hl, os_input 
1a68 3e 01			ld a, 1     ; init string 
1a6a cd 2e 0d			call input_str 
1a6d			 
1a6d cd cd 0a		        call clear_display 
1a70 cd f0 0a			call update_display		 
1a73			 
1a73 3a 98 f1			ld a, (os_input) 
1a76 cd 56 11			call toUpper 
1a79 fe 48		        cp 'H' 
1a7b 28 6f		        jr z, .monhelp 
1a7d fe 44			cp 'D'		; dump 
1a7f ca 0d 1b			jp z, .mondump	 
1a82 fe 43			cp 'C'		; dump 
1a84 ca 27 1b			jp z, .moncdump	 
1a87 fe 4d			cp 'M'		; dump 
1a89 ca 98 1a			jp z, .moneditstart 
1a8c fe 55			cp 'U'		; dump 
1a8e 28 14			jr z, .monedit	 
1a90 fe 51			cp 'Q'		; dump 
1a92 c8				ret z	 
1a93			 
1a93			 
1a93				; TODO "S" to access symbol by name and not need the address 
1a93				; TODO "F" to find a string in memory 
1a93			 
1a93 c3 49 1a			jp monitor 
1a96			 
1a96 .. 00		.monprompt: db ">", 0 
1a98			 
1a98			.moneditstart: 
1a98				; get starting address 
1a98			 
1a98 21 9a f1			ld hl,os_input+2 
1a9b cd b8 10			call get_word_hl 
1a9e			 
1a9e 22 bd f2			ld (os_cur_ptr),hl	 
1aa1			 
1aa1 c3 49 1a			jp monitor 
1aa4			 
1aa4			.monedit: 
1aa4				; get byte to load 
1aa4			 
1aa4 21 9a f1			ld hl,os_input+2 
1aa7 cd 58 10			call get_byte 
1aaa			 
1aaa				; get address to update 
1aaa 2a bd f2			ld hl, (os_cur_ptr) 
1aad			 
1aad				; update byte 
1aad			 
1aad 77				ld (hl), a 
1aae			 
1aae				; move to next address and save it 
1aae			 
1aae 23				inc hl 
1aaf 22 bd f2			ld (os_cur_ptr),hl	 
1ab2			 
1ab2 c3 49 1a			jp monitor 
1ab5			 
1ab5			 
1ab5 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ac9 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ae5 .. 00		.monhelptext3:  db "Q-Quit",0 
1aec			        
1aec			.monhelp: 
1aec 3e 00			ld a, display_row_1 
1aee 11 b5 1a		        ld de, .monhelptext1 
1af1			 
1af1 cd e0 0a			call str_at_display 
1af4 3e 14			ld a, display_row_2 
1af6 11 c9 1a		        ld de, .monhelptext2 
1af9					 
1af9 cd e0 0a			call str_at_display 
1afc 3e 28			ld a, display_row_3 
1afe 11 e5 1a		        ld de, .monhelptext3 
1b01					 
1b01 cd e0 0a			call str_at_display 
1b04 cd f0 0a			call update_display		 
1b07			 
1b07 cd 53 1c			call next_page_prompt 
1b0a c3 49 1a			jp monitor 
1b0d			 
1b0d			.mondump:    
1b0d 21 9a f1			ld hl,os_input+2 
1b10 cd b8 10			call get_word_hl 
1b13			 
1b13 22 bd f2			ld (os_cur_ptr),hl	 
1b16 cd 5b 1b			call dumpcont 
1b19 3e 3c			ld a, display_row_4 
1b1b 11 f5 19			ld de, endprog 
1b1e			 
1b1e cd f0 0a			call update_display		 
1b21			 
1b21 cd 53 1c			call next_page_prompt 
1b24 c3 49 1a			jp monitor 
1b27			.moncdump: 
1b27 cd 5b 1b			call dumpcont 
1b2a 3e 3c			ld a, display_row_4 
1b2c 11 f5 19			ld de, endprog 
1b2f			 
1b2f cd f0 0a			call update_display		 
1b32			 
1b32 cd 53 1c			call next_page_prompt 
1b35 c3 49 1a			jp monitor 
1b38			 
1b38			 
1b38			; TODO symbol access  
1b38			 
1b38			.symbols:     ;; A list of symbols that can be called up  
1b38 4a fb			dw display_fb0 
1b3a .. 00			db "fb0",0  
1b3e df f9		     	dw store_page 
1b40 .. 00			db "store_page",0 
1b4b			 
1b4b			 
1b4b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b4b			 
1b4b 3a 9b ef			ld a,(scratch+1) 
1b4e fe 00			cp 0 
1b50 28 09			jr z, dumpcont 
1b52			 
1b52				; no, not a null term line so has an address to work out.... 
1b52			 
1b52 21 9c ef			ld hl,scratch+2 
1b55 cd b8 10			call get_word_hl 
1b58			 
1b58 22 bd f2			ld (os_cur_ptr),hl	 
1b5b			 
1b5b			 
1b5b			 
1b5b			dumpcont: 
1b5b			 
1b5b				; dump bytes at ptr 
1b5b			 
1b5b			 
1b5b 3e 00			ld a, display_row_1 
1b5d 2a 55 fa			ld hl, (display_fb_active) 
1b60 cd 01 0d			call addatohl 
1b63 cd 8b 1b			call .dumpbyterow 
1b66			 
1b66 3e 14			ld a, display_row_2 
1b68 2a 55 fa			ld hl, (display_fb_active) 
1b6b cd 01 0d			call addatohl 
1b6e cd 8b 1b			call .dumpbyterow 
1b71			 
1b71			 
1b71 3e 28			ld a, display_row_3 
1b73 2a 55 fa			ld hl, (display_fb_active) 
1b76 cd 01 0d			call addatohl 
1b79 cd 8b 1b			call .dumpbyterow 
1b7c			 
1b7c 3e 3c			ld a, display_row_4 
1b7e 2a 55 fa			ld hl, (display_fb_active) 
1b81 cd 01 0d			call addatohl 
1b84 cd 8b 1b			call .dumpbyterow 
1b87			 
1b87 cd f0 0a			call update_display 
1b8a			;		jp cli 
1b8a c9				ret 
1b8b			 
1b8b			.dumpbyterow: 
1b8b			 
1b8b				;push af 
1b8b			 
1b8b e5				push hl 
1b8c			 
1b8c				; calc where to poke the ascii 
1b8c			if display_cols == 20 
1b8c 3e 10			ld a, 16 
1b8e			else 
1b8e				ld a, 31 
1b8e			endif 
1b8e			 
1b8e cd 01 0d			call addatohl 
1b91 22 9f f2			ld (os_word_scratch),hl  		; save pos for later 
1b94			 
1b94			 
1b94			; display decoding address 
1b94 2a bd f2		   	ld hl,(os_cur_ptr) 
1b97			 
1b97 7c				ld a,h 
1b98 e1				pop hl 
1b99 e5				push hl 
1b9a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b9a cd 02 10			call hexout 
1b9d 2a bd f2		   	ld hl,(os_cur_ptr) 
1ba0			 
1ba0 7d				ld a,l 
1ba1 e1				pop hl 
1ba2 23				inc hl 
1ba3 23				inc hl 
1ba4 e5				push hl 
1ba5			;	ld hl, os_word_scratch+2 
1ba5 cd 02 10			call hexout 
1ba8 e1				pop hl 
1ba9 23				inc hl 
1baa 23				inc hl 
1bab				;ld hl, os_word_scratch+4 
1bab 3e 3a			ld a, ':' 
1bad 77				ld (hl),a 
1bae 23				inc hl 
1baf				;ld a, 0 
1baf				;ld (hl),a 
1baf				;ld de, os_word_scratch 
1baf				;pop af 
1baf				;push af 
1baf			;		ld a, display_row_2 
1baf			;		call str_at_display 
1baf			;		call update_display 
1baf			 
1baf			 
1baf			;pop af 
1baf			;	add 5 
1baf			 
1baf			if display_cols == 20 
1baf 06 04			ld b, 4 
1bb1			else 
1bb1				ld b, 8 
1bb1			endif	 
1bb1			 
1bb1			.dumpbyte: 
1bb1 c5				push bc 
1bb2 e5				push hl 
1bb3			 
1bb3			 
1bb3 2a bd f2		   	ld hl,(os_cur_ptr) 
1bb6 7e					ld a,(hl) 
1bb7			 
1bb7					; poke the ascii to display 
1bb7 2a 9f f2				ld hl,(os_word_scratch) 
1bba 77					ld (hl),a 
1bbb 23					inc hl 
1bbc 22 9f f2				ld (os_word_scratch),hl 
1bbf			 
1bbf					 
1bbf			 
1bbf			 
1bbf e1					pop hl 
1bc0 e5					push hl 
1bc1			 
1bc1 cd 02 10				call hexout 
1bc4			 
1bc4					 
1bc4 2a bd f2		   	ld hl,(os_cur_ptr) 
1bc7 23				inc hl 
1bc8 22 bd f2		   	ld (os_cur_ptr),hl 
1bcb			 
1bcb e1					pop hl 
1bcc 23					inc hl 
1bcd 23					inc hl 
1bce 23					inc hl 
1bcf			 
1bcf			 
1bcf			 
1bcf					;ld a,0 
1bcf					;ld (os_word_scratch+2),a 
1bcf					;pop af 
1bcf					;push af 
1bcf			 
1bcf					;ld de, os_word_scratch 
1bcf					;call str_at_display 
1bcf			;		call update_display 
1bcf			;		pop af 
1bcf c1					pop bc 
1bd0 c6 03				add 3 
1bd2 10 dd			djnz .dumpbyte 
1bd4			 
1bd4				 
1bd4			 
1bd4 c9				ret 
1bd5			 
1bd5			jump:	 
1bd5			 
1bd5 21 9c ef			ld hl,scratch+2 
1bd8 cd b8 10			call get_word_hl 
1bdb				;ld hl,(scratch+2) 
1bdb				;call fourehexhl 
1bdb			 
1bdb 22 bd f2			ld (os_cur_ptr),hl	 
1bde			 
1bde e9				jp (hl) 
1bdf			 
1bdf			 
1bdf			 
1bdf			; TODO implement a basic monitor mode to start with 
1bdf			 
1bdf			 
1bdf			 
1bdf			 
1bdf			 
1bdf			 
1bdf			 
1bdf			 
1bdf			 
1bdf			; testing and demo code during development 
1bdf			 
1bdf			 
1bdf .. 00		str1: db "Enter some text...",0 
1bf2 .. 00		clear: db "                    ",0 
1c07			 
1c07			demo: 
1c07			 
1c07			 
1c07			 
1c07			;	call update_display 
1c07			 
1c07				; init scratch input area for testing 
1c07 21 9a ef			ld hl, scratch	 
1c0a 3e 00			ld a,0 
1c0c 77				ld (hl),a 
1c0d			 
1c0d			 
1c0d 3e 14		            LD   A, display_row_2 
1c0f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c0f 11 df 1b		            LD   DE, str1 
1c12 cd e0 0a			call str_at_display 
1c15			 
1c15			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c15			cloop:	 
1c15 3e 28		            LD   A, display_row_3 
1c17			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c17 11 f2 1b		            LD   DE, clear 
1c1a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c1a cd e0 0a				call str_at_display 
1c1d 3e 3c			ld a, display_row_4 
1c1f 11 4f 1c			ld de, prompt 
1c22			 
1c22 cd e0 0a				call str_at_display 
1c25 cd f0 0a			call update_display 
1c28			 
1c28 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c2a 16 0a			ld d, 10 
1c2c 21 9a ef			ld hl, scratch	 
1c2f cd 2e 0d			call input_str 
1c32			 
1c32			;	call clear_display 
1c32			;'	call update_display 
1c32			 
1c32 3e 00		            LD   A, display_row_1 
1c34			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c34 11 f2 1b		            LD   DE, clear 
1c37 cd e0 0a				call str_at_display 
1c3a			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c3a 3e 00		            LD   A, display_row_1 
1c3c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c3c 11 9a ef		            LD   DE, scratch 
1c3f			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c3f cd e0 0a				call str_at_display 
1c42 cd f0 0a			call update_display 
1c45			 
1c45 3e 00				ld a,0 
1c47 21 9a ef			ld hl, scratch 
1c4a 77				ld (hl),a 
1c4b			 
1c4b 00				nop 
1c4c c3 15 1c			jp cloop 
1c4f			 
1c4f			 
1c4f			 
1c4f			; OS Prompt 
1c4f			 
1c4f .. 00		prompt: db ">",0 
1c51 .. 00		endprg: db "?",0 
1c53			 
1c53			 
1c53			; handy next page prompt 
1c53			next_page_prompt: 
1c53 e5				push hl 
1c54 d5				push de 
1c55 f5				push af 
1c56 c5				push bc 
1c57			 
1c57 3e 4f			ld a,display_row_4 + display_cols - 1 
1c59 11 51 1c		        ld de, endprg 
1c5c cd e0 0a			call str_at_display 
1c5f cd f0 0a			call update_display 
1c62 cd 5c 67			call cin_wait 
1c65 c1				pop bc 
1c66 f1				pop af 
1c67 d1				pop de 
1c68 e1				pop hl 
1c69			 
1c69			 
1c69 c9				ret 
1c6a			 
1c6a			 
1c6a			; forth parser 
1c6a			 
1c6a			; My forth kernel 
1c6a			include "forth_kernel.asm" 
1c6a			; 
1c6a			; kernel to the forth OS 
1c6a			 
1c6a			DS_TYPE_STR: equ 1     ; string type 
1c6a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c6a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c6a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c6a			 
1c6a			FORTH_PARSEV1: equ 0 
1c6a			FORTH_PARSEV2: equ 0 
1c6a			FORTH_PARSEV3: equ 0 
1c6a			FORTH_PARSEV4: equ 0 
1c6a			FORTH_PARSEV5: equ 1 
1c6a			 
1c6a			;if FORTH_PARSEV5 
1c6a			;	FORTH_END_BUFFER: equ 0 
1c6a			;else 
1c6a			FORTH_END_BUFFER: equ 127 
1c6a			;endif 
1c6a			 
1c6a			FORTH_TRUE: equ 1 
1c6a			FORTH_FALSE: equ 0 
1c6a			 
1c6a			if FORTH_PARSEV4 
1c6a			include "forth_stackops.asm" 
1c6a			endif 
1c6a			 
1c6a			if FORTH_PARSEV5 
1c6a			include "forth_stackopsv5.asm" 
1c6a			 
1c6a			; Stack operations for v5 parser on wards 
1c6a			; * DATA stack 
1c6a			; * LOOP stack 
1c6a			; * RETURN stack 
1c6a			 
1c6a			 
1c6a			 
1c6a			FORTH_CHK_DSP_UNDER: macro 
1c6a				push hl 
1c6a				push de 
1c6a				ld hl,(cli_data_sp) 
1c6a				ld de, cli_data_stack 
1c6a				call cmp16 
1c6a				jp c, fault_dsp_under 
1c6a				pop de 
1c6a				pop hl 
1c6a				endm 
1c6a			 
1c6a			 
1c6a			FORTH_CHK_RSP_UNDER: macro 
1c6a				push hl 
1c6a				push de 
1c6a				ld hl,(cli_ret_sp) 
1c6a				ld de, cli_ret_stack 
1c6a				call cmp16 
1c6a				jp c, fault_rsp_under 
1c6a				pop de 
1c6a				pop hl 
1c6a				endm 
1c6a			 
1c6a			FORTH_CHK_LOOP_UNDER: macro 
1c6a				push hl 
1c6a				push de 
1c6a				ld hl,(cli_loop_sp) 
1c6a				ld de, cli_loop_stack 
1c6a				call cmp16 
1c6a				jp c, fault_loop_under 
1c6a				pop de 
1c6a				pop hl 
1c6a				endm 
1c6a			 
1c6a			FORTH_ERR_TOS_NOTSTR: macro 
1c6a				; TOSO might need more for checks when used 
1c6a				push af 
1c6a				ld a,(hl) 
1c6a				cp DS_TYPE_STR 
1c6a				jp nz, type_faultn   
1c6a				pop af 
1c6a				endm 
1c6a			 
1c6a			FORTH_ERR_TOS_NOTNUM: macro 
1c6a				push af 
1c6a				ld a,(hl) 
1c6a				cp DS_TYPE_INUM 
1c6a				jp nz, type_faultn   
1c6a				pop af 
1c6a				endm 
1c6a			 
1c6a			 
1c6a			; increase data stack pointer and save hl to it 
1c6a				 
1c6a			FORTH_DSP_NEXT: macro 
1c6a				call macro_forth_dsp_next 
1c6a				endm 
1c6a			 
1c6a			 
1c6a			macro_forth_dsp_next: 
1c6a				if DEBUG_FORTH_STACK_GUARD 
1c6a cd 77 62				call check_stacks 
1c6d				endif 
1c6d e5				push hl 
1c6e d5				push de 
1c6f eb				ex de,hl 
1c70 2a 87 f9			ld hl,(cli_data_sp) 
1c73 23				inc hl 
1c74 23				inc hl 
1c75			 
1c75			; PARSEV5 
1c75 23				inc hl 
1c76 22 87 f9			ld (cli_data_sp),hl 
1c79 73				ld (hl), e 
1c7a 23				inc hl 
1c7b 72				ld (hl), d 
1c7c d1				pop de 
1c7d e1				pop hl 
1c7e				if DEBUG_FORTH_STACK_GUARD 
1c7e cd 77 62				call check_stacks 
1c81				endif 
1c81 c9				ret 
1c82			 
1c82			 
1c82			; increase ret stack pointer and save hl to it 
1c82				 
1c82			FORTH_RSP_NEXT: macro 
1c82				call macro_forth_rsp_next 
1c82				endm 
1c82			 
1c82			macro_forth_rsp_next: 
1c82				if DEBUG_FORTH_STACK_GUARD 
1c82 cd 77 62				call check_stacks 
1c85				endif 
1c85 e5				push hl 
1c86 d5				push de 
1c87 eb				ex de,hl 
1c88 2a 8b f9			ld hl,(cli_ret_sp) 
1c8b 23				inc hl 
1c8c 23				inc hl 
1c8d 22 8b f9			ld (cli_ret_sp),hl 
1c90 73				ld (hl), e 
1c91 23				inc hl 
1c92 72				ld (hl), d 
1c93 d1				pop de 
1c94 e1				pop hl 
1c95				if DEBUG_FORTH_STACK_GUARD 
1c95 cd 77 62				call check_stacks 
1c98				endif 
1c98 c9				ret 
1c99			 
1c99			; get current ret stack pointer and save to hl  
1c99				 
1c99			FORTH_RSP_TOS: macro 
1c99				call macro_forth_rsp_tos 
1c99				endm 
1c99			 
1c99			macro_forth_rsp_tos: 
1c99				;push de 
1c99 2a 8b f9			ld hl,(cli_ret_sp) 
1c9c cd d4 1c			call loadhlptrtohl 
1c9f				;ld e, (hl) 
1c9f				;inc hl 
1c9f				;ld d, (hl) 
1c9f				;ex de, hl 
1c9f					if DEBUG_FORTH_WORDS 
1c9f			;			DMARK "RST" 
1c9f						CALLMONITOR 
1c9f cd 7e 16			call break_point_state  
1ca2				endm  
# End of macro CALLMONITOR
1ca2					endif 
1ca2				;pop de 
1ca2 c9				ret 
1ca3			 
1ca3			; pop ret stack pointer 
1ca3				 
1ca3			FORTH_RSP_POP: macro 
1ca3				call macro_forth_rsp_pop 
1ca3				endm 
1ca3			 
1ca3			 
1ca3			macro_forth_rsp_pop: 
1ca3				if DEBUG_FORTH_STACK_GUARD 
1ca3			;		DMARK "RPP" 
1ca3 cd 77 62				call check_stacks 
1ca6					FORTH_CHK_RSP_UNDER 
1ca6 e5				push hl 
1ca7 d5				push de 
1ca8 2a 8b f9			ld hl,(cli_ret_sp) 
1cab 11 05 f9			ld de, cli_ret_stack 
1cae cd 1f 0d			call cmp16 
1cb1 da 8b 63			jp c, fault_rsp_under 
1cb4 d1				pop de 
1cb5 e1				pop hl 
1cb6				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cb6				endif 
1cb6 e5				push hl 
1cb7 2a 8b f9			ld hl,(cli_ret_sp) 
1cba			 
1cba			 
1cba				if FORTH_ENABLE_FREE 
1cba			 
1cba					; get pointer 
1cba			 
1cba					push de 
1cba					push hl 
1cba			 
1cba					ld e, (hl) 
1cba					inc hl 
1cba					ld d, (hl) 
1cba			 
1cba					ex de, hl 
1cba					call free 
1cba			 
1cba					pop hl 
1cba					pop de 
1cba			 
1cba			 
1cba				endif 
1cba			 
1cba			 
1cba 2b				dec hl 
1cbb 2b				dec hl 
1cbc 22 8b f9			ld (cli_ret_sp), hl 
1cbf				; do stack underflow checks 
1cbf e1				pop hl 
1cc0				if DEBUG_FORTH_STACK_GUARD 
1cc0 cd 77 62				call check_stacks 
1cc3					FORTH_CHK_RSP_UNDER 
1cc3 e5				push hl 
1cc4 d5				push de 
1cc5 2a 8b f9			ld hl,(cli_ret_sp) 
1cc8 11 05 f9			ld de, cli_ret_stack 
1ccb cd 1f 0d			call cmp16 
1cce da 8b 63			jp c, fault_rsp_under 
1cd1 d1				pop de 
1cd2 e1				pop hl 
1cd3				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cd3				endif 
1cd3 c9				ret 
1cd4			 
1cd4			 
1cd4			 
1cd4			; routine to load word pointed to by hl into hl 
1cd4			 
1cd4			loadhlptrtohl: 
1cd4			 
1cd4 d5				push de 
1cd5 5e				ld e, (hl) 
1cd6 23				inc hl 
1cd7 56				ld d, (hl) 
1cd8 eb				ex de, hl 
1cd9 d1				pop de 
1cda			 
1cda c9				ret 
1cdb			 
1cdb			 
1cdb			 
1cdb			 
1cdb			 
1cdb			; push a number held in HL onto the data stack 
1cdb			; entry point for pushing a value when already in hl used in function above 
1cdb			 
1cdb			forth_push_numhl: 
1cdb			 
1cdb e5				push hl    ; save value to push 
1cdc			 
1cdc			if DEBUG_FORTH_PUSH 
1cdc				; see if disabled 
1cdc			 
1cdc			 
1cdc f5				push af 
1cdd 3a 8b ef			ld a, (os_view_disable) 
1ce0 fe 2a			cp '*' 
1ce2 28 34			jr z, .pskip2 
1ce4 e5				push hl 
1ce5 e5			push hl 
1ce6 cd cd 0a			call clear_display 
1ce9 e1			pop hl 
1cea 7c				ld a,h 
1ceb 21 9f f2			ld hl, os_word_scratch 
1cee cd 02 10			call hexout 
1cf1 e1				pop hl 
1cf2 7d				ld a,l 
1cf3 21 a1 f2			ld hl, os_word_scratch+2 
1cf6 cd 02 10			call hexout 
1cf9			 
1cf9 21 a3 f2			ld hl, os_word_scratch+4 
1cfc 3e 00			ld a,0 
1cfe 77				ld (hl),a 
1cff 11 9f f2			ld de,os_word_scratch 
1d02 3e 14				ld a, display_row_2 
1d04 cd e0 0a				call str_at_display 
1d07 11 85 51			ld de, .push_num 
1d0a 3e 00			ld a, display_row_1 
1d0c			 
1d0c cd e0 0a				call str_at_display 
1d0f			 
1d0f			 
1d0f cd f0 0a			call update_display 
1d12 cd 4a 0a			call delay1s 
1d15 cd 4a 0a			call delay1s 
1d18			.pskip2:  
1d18			 
1d18 f1				pop af 
1d19			endif	 
1d19			 
1d19			 
1d19				FORTH_DSP_NEXT 
1d19 cd 6a 1c			call macro_forth_dsp_next 
1d1c				endm 
# End of macro FORTH_DSP_NEXT
1d1c			 
1d1c 2a 87 f9			ld hl, (cli_data_sp) 
1d1f			 
1d1f				; save item type 
1d1f 3e 02			ld a,  DS_TYPE_INUM 
1d21 77				ld (hl), a 
1d22 23				inc hl 
1d23			 
1d23				; get word off stack 
1d23 d1				pop de 
1d24 7b				ld a,e 
1d25 77				ld (hl), a 
1d26 23				inc hl 
1d27 7a				ld a,d 
1d28 77				ld (hl), a 
1d29			 
1d29			if DEBUG_FORTH_PUSH 
1d29 2b				dec hl 
1d2a 2b				dec hl 
1d2b 2b				dec hl 
1d2c						DMARK "PH5" 
1d2c f5				push af  
1d2d 3a 41 1d			ld a, (.dmark)  
1d30 32 b4 fb			ld (debug_mark),a  
1d33 3a 42 1d			ld a, (.dmark+1)  
1d36 32 b5 fb			ld (debug_mark+1),a  
1d39 3a 43 1d			ld a, (.dmark+2)  
1d3c 32 b6 fb			ld (debug_mark+2),a  
1d3f 18 03			jr .pastdmark  
1d41 ..			.dmark: db "PH5"  
1d44 f1			.pastdmark: pop af  
1d45			endm  
# End of macro DMARK
1d45				CALLMONITOR 
1d45 cd 7e 16			call break_point_state  
1d48				endm  
# End of macro CALLMONITOR
1d48			endif	 
1d48			 
1d48 c9				ret 
1d49			 
1d49			 
1d49			; Push a string to stack pointed to by hl 
1d49			 
1d49			forth_push_str: 
1d49			 
1d49			if DEBUG_FORTH_PUSH 
1d49						DMARK "PSQ" 
1d49 f5				push af  
1d4a 3a 5e 1d			ld a, (.dmark)  
1d4d 32 b4 fb			ld (debug_mark),a  
1d50 3a 5f 1d			ld a, (.dmark+1)  
1d53 32 b5 fb			ld (debug_mark+1),a  
1d56 3a 60 1d			ld a, (.dmark+2)  
1d59 32 b6 fb			ld (debug_mark+2),a  
1d5c 18 03			jr .pastdmark  
1d5e ..			.dmark: db "PSQ"  
1d61 f1			.pastdmark: pop af  
1d62			endm  
# End of macro DMARK
1d62				CALLMONITOR 
1d62 cd 7e 16			call break_point_state  
1d65				endm  
# End of macro CALLMONITOR
1d65			endif	 
1d65			    
1d65 e5				push hl 
1d66 e5				push hl 
1d67			 
1d67			;	ld a, 0   ; find end of string 
1d67 cd 5f 11			call strlenz 
1d6a			if DEBUG_FORTH_PUSH 
1d6a						DMARK "PQ2" 
1d6a f5				push af  
1d6b 3a 7f 1d			ld a, (.dmark)  
1d6e 32 b4 fb			ld (debug_mark),a  
1d71 3a 80 1d			ld a, (.dmark+1)  
1d74 32 b5 fb			ld (debug_mark+1),a  
1d77 3a 81 1d			ld a, (.dmark+2)  
1d7a 32 b6 fb			ld (debug_mark+2),a  
1d7d 18 03			jr .pastdmark  
1d7f ..			.dmark: db "PQ2"  
1d82 f1			.pastdmark: pop af  
1d83			endm  
# End of macro DMARK
1d83				CALLMONITOR 
1d83 cd 7e 16			call break_point_state  
1d86				endm  
# End of macro CALLMONITOR
1d86			endif	 
1d86 eb				ex de, hl 
1d87 e1				pop hl   ; get ptr to start of string 
1d88			if DEBUG_FORTH_PUSH 
1d88						DMARK "PQ3" 
1d88 f5				push af  
1d89 3a 9d 1d			ld a, (.dmark)  
1d8c 32 b4 fb			ld (debug_mark),a  
1d8f 3a 9e 1d			ld a, (.dmark+1)  
1d92 32 b5 fb			ld (debug_mark+1),a  
1d95 3a 9f 1d			ld a, (.dmark+2)  
1d98 32 b6 fb			ld (debug_mark+2),a  
1d9b 18 03			jr .pastdmark  
1d9d ..			.dmark: db "PQ3"  
1da0 f1			.pastdmark: pop af  
1da1			endm  
# End of macro DMARK
1da1				CALLMONITOR 
1da1 cd 7e 16			call break_point_state  
1da4				endm  
# End of macro CALLMONITOR
1da4			endif	 
1da4 19				add hl,de 
1da5			if DEBUG_FORTH_PUSH 
1da5						DMARK "PQE" 
1da5 f5				push af  
1da6 3a ba 1d			ld a, (.dmark)  
1da9 32 b4 fb			ld (debug_mark),a  
1dac 3a bb 1d			ld a, (.dmark+1)  
1daf 32 b5 fb			ld (debug_mark+1),a  
1db2 3a bc 1d			ld a, (.dmark+2)  
1db5 32 b6 fb			ld (debug_mark+2),a  
1db8 18 03			jr .pastdmark  
1dba ..			.dmark: db "PQE"  
1dbd f1			.pastdmark: pop af  
1dbe			endm  
# End of macro DMARK
1dbe				CALLMONITOR 
1dbe cd 7e 16			call break_point_state  
1dc1				endm  
# End of macro CALLMONITOR
1dc1			endif	 
1dc1			 
1dc1 2b				dec hl    ; see if there is an optional trailing double quote 
1dc2 7e				ld a,(hl) 
1dc3 fe 22			cp '"' 
1dc5 20 03			jr nz, .strnoq 
1dc7 3e 00			ld a, 0      ; get rid of double quote 
1dc9 77				ld (hl), a 
1dca 23			.strnoq: inc hl 
1dcb			 
1dcb 3e 00			ld a, 0 
1dcd 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1dce			 
1dce 13				inc de ; add one for the type string 
1dcf 13				inc de ; add one for null term??? 
1dd0			 
1dd0				; tos is get string pointer again 
1dd0				; de contains space to allocate 
1dd0				 
1dd0 d5				push de 
1dd1			 
1dd1 eb				ex de, hl 
1dd2			 
1dd2				;push af 
1dd2			 
1dd2			if DEBUG_FORTH_PUSH 
1dd2						DMARK "PHm" 
1dd2 f5				push af  
1dd3 3a e7 1d			ld a, (.dmark)  
1dd6 32 b4 fb			ld (debug_mark),a  
1dd9 3a e8 1d			ld a, (.dmark+1)  
1ddc 32 b5 fb			ld (debug_mark+1),a  
1ddf 3a e9 1d			ld a, (.dmark+2)  
1de2 32 b6 fb			ld (debug_mark+2),a  
1de5 18 03			jr .pastdmark  
1de7 ..			.dmark: db "PHm"  
1dea f1			.pastdmark: pop af  
1deb			endm  
# End of macro DMARK
1deb				CALLMONITOR 
1deb cd 7e 16			call break_point_state  
1dee				endm  
# End of macro CALLMONITOR
1dee			endif	 
1dee cd c8 11			call malloc	; on ret hl now contains allocated memory 
1df1				if DEBUG_FORTH_MALLOC_GUARD 
1df1 cc dd 51				call z,malloc_error 
1df4				endif 
1df4			 
1df4				 
1df4 c1				pop bc    ; get length 
1df5 d1				pop de   ;  get string start    
1df6			 
1df6				; hl has destination from malloc 
1df6			 
1df6 eb				ex de, hl    ; prep for ldir 
1df7			 
1df7 d5				push de   ; save malloc area for DSP later 
1df8				;push hl   ; save malloc area for DSP later 
1df8			 
1df8			if DEBUG_FORTH_PUSH 
1df8						DMARK "PHc" 
1df8 f5				push af  
1df9 3a 0d 1e			ld a, (.dmark)  
1dfc 32 b4 fb			ld (debug_mark),a  
1dff 3a 0e 1e			ld a, (.dmark+1)  
1e02 32 b5 fb			ld (debug_mark+1),a  
1e05 3a 0f 1e			ld a, (.dmark+2)  
1e08 32 b6 fb			ld (debug_mark+2),a  
1e0b 18 03			jr .pastdmark  
1e0d ..			.dmark: db "PHc"  
1e10 f1			.pastdmark: pop af  
1e11			endm  
# End of macro DMARK
1e11				CALLMONITOR 
1e11 cd 7e 16			call break_point_state  
1e14				endm  
# End of macro CALLMONITOR
1e14			endif	 
1e14			 
1e14			 
1e14 ed b0			ldir 
1e16			 
1e16			 
1e16				; push malloc to data stack     macro?????  
1e16			 
1e16				FORTH_DSP_NEXT 
1e16 cd 6a 1c			call macro_forth_dsp_next 
1e19				endm 
# End of macro FORTH_DSP_NEXT
1e19			 
1e19				; save value and type 
1e19			 
1e19 2a 87 f9			ld hl, (cli_data_sp) 
1e1c			 
1e1c				; save item type 
1e1c 3e 01			ld a,  DS_TYPE_STR 
1e1e 77				ld (hl), a 
1e1f 23				inc hl 
1e20			 
1e20				; get malloc word off stack 
1e20 d1				pop de 
1e21 73				ld (hl), e 
1e22 23				inc hl 
1e23 72				ld (hl), d 
1e24			 
1e24			 
1e24			 
1e24			if DEBUG_FORTH_PUSH 
1e24 2a 87 f9			ld hl, (cli_data_sp) 
1e27						DMARK "PHS" 
1e27 f5				push af  
1e28 3a 3c 1e			ld a, (.dmark)  
1e2b 32 b4 fb			ld (debug_mark),a  
1e2e 3a 3d 1e			ld a, (.dmark+1)  
1e31 32 b5 fb			ld (debug_mark+1),a  
1e34 3a 3e 1e			ld a, (.dmark+2)  
1e37 32 b6 fb			ld (debug_mark+2),a  
1e3a 18 03			jr .pastdmark  
1e3c ..			.dmark: db "PHS"  
1e3f f1			.pastdmark: pop af  
1e40			endm  
# End of macro DMARK
1e40				CALLMONITOR 
1e40 cd 7e 16			call break_point_state  
1e43				endm  
# End of macro CALLMONITOR
1e43			;	ex de,hl 
1e43			endif	 
1e43				; in case of spaces, skip the ptr past the copied string 
1e43				;pop af 
1e43				;ld (cli_origptr),hl 
1e43			 
1e43 c9				ret 
1e44			 
1e44			 
1e44			 
1e44			; TODO ascii push input onto stack given hl to start of input 
1e44			 
1e44			; identify type 
1e44			; if starts with a " then a string 
1e44			; otherwise it is a number 
1e44			;  
1e44			; if a string 
1e44			;     scan for ending " to get length of string to malloc for + 1 
1e44			;     malloc 
1e44			;     put pointer to string on stack first byte flags as string 
1e44			; 
1e44			; else a number 
1e44			;    look for number format identifier 
1e44			;    $xx hex 
1e44			;    %xxxxx bin 
1e44			;    xxxxx decimal 
1e44			;    convert number to 16bit word.  
1e44			;    malloc word + 1 with flag to identiy as num 
1e44			;    put pointer to number on stack 
1e44			;   
1e44			;  
1e44			  
1e44			forth_apush: 
1e44				; kernel push 
1e44			 
1e44			if DEBUG_FORTH_PUSH 
1e44						DMARK "PSH" 
1e44 f5				push af  
1e45 3a 59 1e			ld a, (.dmark)  
1e48 32 b4 fb			ld (debug_mark),a  
1e4b 3a 5a 1e			ld a, (.dmark+1)  
1e4e 32 b5 fb			ld (debug_mark+1),a  
1e51 3a 5b 1e			ld a, (.dmark+2)  
1e54 32 b6 fb			ld (debug_mark+2),a  
1e57 18 03			jr .pastdmark  
1e59 ..			.dmark: db "PSH"  
1e5c f1			.pastdmark: pop af  
1e5d			endm  
# End of macro DMARK
1e5d				CALLMONITOR 
1e5d cd 7e 16			call break_point_state  
1e60				endm  
# End of macro CALLMONITOR
1e60			endif	 
1e60				; identify input type 
1e60			 
1e60 7e				ld a,(hl) 
1e61 fe 22			cp '"' 
1e63 28 0a			jr z, .fapstr 
1e65 fe 24			cp '$' 
1e67 ca 8f 1e			jp z, .faphex 
1e6a fe 25			cp '%' 
1e6c ca 77 1e			jp z, .fapbin 
1e6f			;	cp 'b' 
1e6f			;	jp z, .fabin 
1e6f				; else decimal 
1e6f			 
1e6f				; TODO do decimal conversion 
1e6f				; decimal is stored as a 16bit word 
1e6f			 
1e6f				; by default everything is a string if type is not detected 
1e6f			.fapstr: ; 
1e6f fe 22			cp '"' 
1e71 20 01			jr nz, .strnoqu 
1e73 23				inc hl 
1e74			.strnoqu: 
1e74 c3 49 1d			jp forth_push_str 
1e77			 
1e77			 
1e77			 
1e77			.fapbin:    ; push a binary string.  
1e77 11 00 00			ld de, 0   ; hold a 16bit value 
1e7a			 
1e7a 23			.fapbinshift:	inc hl  
1e7b 7e				ld a,(hl) 
1e7c fe 00			cp 0     ; done scanning  
1e7e 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e80			 
1e80				; left shift de 
1e80 eb				ex de, hl	 
1e81 29				add hl, hl 
1e82			 
1e82				; is 1 
1e82 fe 31			cp '1' 
1e84 20 02			jr nz, .binzero 
1e86 cb 4d			bit 1, l 
1e88			.binzero: 
1e88 eb				ex de, hl	 ; save current de 
1e89 18 ef			jr .fapbinshift 
1e8b			 
1e8b			.fapbdone: 
1e8b eb				ex de, hl 
1e8c c3 db 1c			jp forth_push_numhl 
1e8f			 
1e8f			 
1e8f			.faphex:   ; hex is always stored as a 16bit word 
1e8f				; skip number prefix 
1e8f 23				inc hl 
1e90				; turn ascii into number 
1e90 cd b8 10			call get_word_hl	; ret 16bit word in hl 
1e93			 
1e93 c3 db 1c			jp forth_push_numhl 
1e96			 
1e96 00				 nop 
1e97			 
1e97			.fabin:   ; TODO bin conversion 
1e97			 
1e97			 
1e97 c9				ret 
1e98			 
1e98			 
1e98			; get either a string ptr or a 16bit word from the data stack 
1e98			 
1e98			FORTH_DSP: macro 
1e98				call macro_forth_dsp 
1e98				endm 
1e98			 
1e98			macro_forth_dsp: 
1e98				; data stack pointer points to current word on tos 
1e98			 
1e98 2a 87 f9			ld hl,(cli_data_sp) 
1e9b			 
1e9b				if DEBUG_FORTH_PUSH 
1e9b						DMARK "DSP" 
1e9b f5				push af  
1e9c 3a b0 1e			ld a, (.dmark)  
1e9f 32 b4 fb			ld (debug_mark),a  
1ea2 3a b1 1e			ld a, (.dmark+1)  
1ea5 32 b5 fb			ld (debug_mark+1),a  
1ea8 3a b2 1e			ld a, (.dmark+2)  
1eab 32 b6 fb			ld (debug_mark+2),a  
1eae 18 03			jr .pastdmark  
1eb0 ..			.dmark: db "DSP"  
1eb3 f1			.pastdmark: pop af  
1eb4			endm  
# End of macro DMARK
1eb4			 
1eb4 cd 12 52				call display_data_sp 
1eb7				;call break_point_state 
1eb7				;rst 030h 
1eb7				CALLMONITOR 
1eb7 cd 7e 16			call break_point_state  
1eba				endm  
# End of macro CALLMONITOR
1eba				endif 
1eba			 
1eba c9				ret 
1ebb			 
1ebb			; return hl to start of value on stack 
1ebb			 
1ebb			FORTH_DSP_VALUE: macro 
1ebb				call macro_forth_dsp_value 
1ebb				endm 
1ebb			 
1ebb			macro_forth_dsp_value: 
1ebb			 
1ebb				FORTH_DSP 
1ebb cd 98 1e			call macro_forth_dsp 
1ebe				endm 
# End of macro FORTH_DSP
1ebe			 
1ebe d5				push de 
1ebf			 
1ebf 23				inc hl ; skip type 
1ec0			 
1ec0 5e				ld e, (hl) 
1ec1 23				inc hl 
1ec2 56				ld d, (hl) 
1ec3 eb				ex de,hl  
1ec4			 
1ec4 d1				pop de 
1ec5			 
1ec5 c9				ret 
1ec6			 
1ec6			; return hl to start of value to second item on stack 
1ec6			 
1ec6			FORTH_DSP_VALUEM1: macro 
1ec6				call macro_forth_dsp_value_m1 
1ec6				endm 
1ec6			 
1ec6			macro_forth_dsp_value_m1: 
1ec6			 
1ec6				FORTH_DSP 
1ec6 cd 98 1e			call macro_forth_dsp 
1ec9				endm 
# End of macro FORTH_DSP
1ec9			 
1ec9 2b				dec hl 
1eca 2b				dec hl 
1ecb			;	dec hl 
1ecb			 
1ecb d5				push de 
1ecc			 
1ecc 5e				ld e, (hl) 
1ecd 23				inc hl 
1ece 56				ld d, (hl) 
1ecf eb				ex de,hl  
1ed0			 
1ed0 d1				pop de 
1ed1			 
1ed1 c9				ret 
1ed2			 
1ed2				 
1ed2			 
1ed2			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ed2			 
1ed2			FORTH_DSP_POP: macro 
1ed2				call macro_forth_dsp_pop 
1ed2				endm 
1ed2			 
1ed2			 
1ed2			; get the tos data type 
1ed2			 
1ed2			FORTH_DSP_TYPE:   macro 
1ed2			 
1ed2				;FORTH_DSP_VALUE 
1ed2				FORTH_DSP 
1ed2				 
1ed2				; hl points to value 
1ed2				; check type 
1ed2			 
1ed2				ld a,(hl) 
1ed2			 
1ed2				endm 
1ed2			 
1ed2			; load the tos value into hl 
1ed2			 
1ed2			 
1ed2			FORTH_DSP_VALUEHL:  macro 
1ed2				call macro_dsp_valuehl 
1ed2				endm 
1ed2			 
1ed2			 
1ed2			 
1ed2			macro_dsp_valuehl: 
1ed2				FORTH_DSP_VALUE 
1ed2 cd bb 1e			call macro_forth_dsp_value 
1ed5				endm 
# End of macro FORTH_DSP_VALUE
1ed5			 
1ed5				;FORTH_ERR_TOS_NOTNUM 
1ed5			 
1ed5				;inc hl   ; skip type id 
1ed5			 
1ed5			;	push de 
1ed5			; 
1ed5			;	ld e, (hl) 
1ed5			;	inc hl 
1ed5			;	ld d, (hl) 
1ed5			;	ex de,hl  
1ed5			 
1ed5			;	pop de 
1ed5			 
1ed5				if DEBUG_FORTH_PUSH 
1ed5						DMARK "DVL" 
1ed5 f5				push af  
1ed6 3a ea 1e			ld a, (.dmark)  
1ed9 32 b4 fb			ld (debug_mark),a  
1edc 3a eb 1e			ld a, (.dmark+1)  
1edf 32 b5 fb			ld (debug_mark+1),a  
1ee2 3a ec 1e			ld a, (.dmark+2)  
1ee5 32 b6 fb			ld (debug_mark+2),a  
1ee8 18 03			jr .pastdmark  
1eea ..			.dmark: db "DVL"  
1eed f1			.pastdmark: pop af  
1eee			endm  
# End of macro DMARK
1eee				CALLMONITOR 
1eee cd 7e 16			call break_point_state  
1ef1				endm  
# End of macro CALLMONITOR
1ef1				endif 
1ef1 c9				ret 
1ef2			 
1ef2			forth_apushstrhl:      
1ef2				; push of string requires use of cli_origptr 
1ef2				; bodge use 
1ef2			 
1ef2				; get current cli_origptr, save, update with temp pointer  
1ef2 ed 5b a3 f9		ld de, (cli_origptr) 
1ef6 22 a3 f9			ld (cli_origptr), hl 
1ef9 d5				push de 
1efa cd 44 1e			call forth_apush 
1efd d1				pop de 
1efe ed 53 a3 f9		ld (cli_origptr), de 
1f02 c9			        ret	 
1f03			 
1f03			 
1f03			; increase loop stack pointer and save hl to it 
1f03				 
1f03			FORTH_LOOP_NEXT: macro 
1f03				call macro_forth_loop_next 
1f03				;nop 
1f03				endm 
1f03			 
1f03			macro_forth_loop_next: 
1f03				if DEBUG_FORTH_STACK_GUARD 
1f03 cd 77 62				call check_stacks 
1f06				endif 
1f06 e5				push hl 
1f07 d5				push de 
1f08 eb				ex de,hl 
1f09 2a 89 f9			ld hl,(cli_loop_sp) 
1f0c 23				inc hl 
1f0d 23				inc hl 
1f0e					if DEBUG_FORTH_WORDS 
1f0e						DMARK "LNX" 
1f0e f5				push af  
1f0f 3a 23 1f			ld a, (.dmark)  
1f12 32 b4 fb			ld (debug_mark),a  
1f15 3a 24 1f			ld a, (.dmark+1)  
1f18 32 b5 fb			ld (debug_mark+1),a  
1f1b 3a 25 1f			ld a, (.dmark+2)  
1f1e 32 b6 fb			ld (debug_mark+2),a  
1f21 18 03			jr .pastdmark  
1f23 ..			.dmark: db "LNX"  
1f26 f1			.pastdmark: pop af  
1f27			endm  
# End of macro DMARK
1f27						CALLMONITOR 
1f27 cd 7e 16			call break_point_state  
1f2a				endm  
# End of macro CALLMONITOR
1f2a					endif 
1f2a 22 89 f9			ld (cli_loop_sp),hl 
1f2d 73				ld (hl), e 
1f2e 23				inc hl 
1f2f 72				ld (hl), d 
1f30 d1				pop de    ; been reversed so save a swap on restore 
1f31 e1				pop hl 
1f32				if DEBUG_FORTH_STACK_GUARD 
1f32 cd 77 62				call check_stacks 
1f35				endif 
1f35 c9				ret 
1f36			 
1f36			; get current ret stack pointer and save to hl  
1f36				 
1f36			FORTH_LOOP_TOS: macro 
1f36				call macro_forth_loop_tos 
1f36				endm 
1f36			 
1f36			macro_forth_loop_tos: 
1f36 d5				push de 
1f37 2a 89 f9			ld hl,(cli_loop_sp) 
1f3a 5e				ld e, (hl) 
1f3b 23				inc hl 
1f3c 56				ld d, (hl) 
1f3d eb				ex de, hl 
1f3e d1				pop de 
1f3f c9				ret 
1f40			 
1f40			; pop loop stack pointer 
1f40				 
1f40			FORTH_LOOP_POP: macro 
1f40				call macro_forth_loop_pop 
1f40				endm 
1f40			 
1f40			 
1f40			macro_forth_loop_pop: 
1f40				if DEBUG_FORTH_STACK_GUARD 
1f40					DMARK "LPP" 
1f40 f5				push af  
1f41 3a 55 1f			ld a, (.dmark)  
1f44 32 b4 fb			ld (debug_mark),a  
1f47 3a 56 1f			ld a, (.dmark+1)  
1f4a 32 b5 fb			ld (debug_mark+1),a  
1f4d 3a 57 1f			ld a, (.dmark+2)  
1f50 32 b6 fb			ld (debug_mark+2),a  
1f53 18 03			jr .pastdmark  
1f55 ..			.dmark: db "LPP"  
1f58 f1			.pastdmark: pop af  
1f59			endm  
# End of macro DMARK
1f59 cd 77 62				call check_stacks 
1f5c					FORTH_CHK_LOOP_UNDER 
1f5c e5				push hl 
1f5d d5				push de 
1f5e 2a 89 f9			ld hl,(cli_loop_sp) 
1f61 11 03 f7			ld de, cli_loop_stack 
1f64 cd 1f 0d			call cmp16 
1f67 da 91 63			jp c, fault_loop_under 
1f6a d1				pop de 
1f6b e1				pop hl 
1f6c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f6c				endif 
1f6c e5				push hl 
1f6d 2a 89 f9			ld hl,(cli_loop_sp) 
1f70 2b				dec hl 
1f71 2b				dec hl 
1f72 22 89 f9			ld (cli_loop_sp), hl 
1f75				; TODO do stack underflow checks 
1f75 e1				pop hl 
1f76				if DEBUG_FORTH_STACK_GUARD 
1f76 cd 77 62				call check_stacks 
1f79					FORTH_CHK_LOOP_UNDER 
1f79 e5				push hl 
1f7a d5				push de 
1f7b 2a 89 f9			ld hl,(cli_loop_sp) 
1f7e 11 03 f7			ld de, cli_loop_stack 
1f81 cd 1f 0d			call cmp16 
1f84 da 91 63			jp c, fault_loop_under 
1f87 d1				pop de 
1f88 e1				pop hl 
1f89				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f89				endif 
1f89 c9				ret 
1f8a			 
1f8a			macro_forth_dsp_pop: 
1f8a			 
1f8a e5				push hl 
1f8b			 
1f8b				; release malloc data 
1f8b			 
1f8b				if DEBUG_FORTH_STACK_GUARD 
1f8b cd 77 62				call check_stacks 
1f8e					FORTH_CHK_DSP_UNDER 
1f8e e5				push hl 
1f8f d5				push de 
1f90 2a 87 f9			ld hl,(cli_data_sp) 
1f93 11 01 f5			ld de, cli_data_stack 
1f96 cd 1f 0d			call cmp16 
1f99 da 85 63			jp c, fault_dsp_under 
1f9c d1				pop de 
1f9d e1				pop hl 
1f9e				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f9e				endif 
1f9e				;ld hl,(cli_data_sp) 
1f9e			if DEBUG_FORTH_DOT 
1f9e				DMARK "DPP" 
1f9e				CALLMONITOR 
1f9e			endif	 
1f9e			 
1f9e			 
1f9e			if FORTH_ENABLE_DSPPOPFREE 
1f9e			 
1f9e				FORTH_DSP 
1f9e cd 98 1e			call macro_forth_dsp 
1fa1				endm 
# End of macro FORTH_DSP
1fa1			 
1fa1 7e				ld a, (hl) 
1fa2 fe 01			cp DS_TYPE_STR 
1fa4 20 07			jr nz, .skippopfree 
1fa6			 
1fa6				FORTH_DSP_VALUEHL 
1fa6 cd d2 1e			call macro_dsp_valuehl 
1fa9				endm 
# End of macro FORTH_DSP_VALUEHL
1fa9 00				nop 
1faa			if DEBUG_FORTH_DOT 
1faa				DMARK "DPf" 
1faa				CALLMONITOR 
1faa			endif	 
1faa cd 92 12			call free 
1fad			.skippopfree: 
1fad				 
1fad			 
1fad			endif 
1fad			 
1fad			if DEBUG_FORTH_DOT_KEY 
1fad				DMARK "DP2" 
1fad				CALLMONITOR 
1fad			endif	 
1fad			 
1fad				; move pointer down 
1fad			 
1fad 2a 87 f9			ld hl,(cli_data_sp) 
1fb0 2b				dec hl 
1fb1 2b				dec hl 
1fb2			; PARSEV5 
1fb2 2b				dec hl 
1fb3 22 87 f9			ld (cli_data_sp), hl 
1fb6			 
1fb6				if DEBUG_FORTH_STACK_GUARD 
1fb6 cd 77 62				call check_stacks 
1fb9					FORTH_CHK_DSP_UNDER 
1fb9 e5				push hl 
1fba d5				push de 
1fbb 2a 87 f9			ld hl,(cli_data_sp) 
1fbe 11 01 f5			ld de, cli_data_stack 
1fc1 cd 1f 0d			call cmp16 
1fc4 da 85 63			jp c, fault_dsp_under 
1fc7 d1				pop de 
1fc8 e1				pop hl 
1fc9				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fc9				endif 
1fc9			 
1fc9 e1				pop hl 
1fca			 
1fca c9				ret 
1fcb			 
1fcb			getwordathl: 
1fcb				; hl points to an address 
1fcb				; load hl with the word at that address 
1fcb			 
1fcb d5				push de 
1fcc			 
1fcc 5e				ld e, (hl) 
1fcd 23				inc hl 
1fce 56				ld d, (hl) 
1fcf eb				ex de, hl 
1fd0			 
1fd0 d1				pop de 
1fd1 c9				ret 
1fd2			 
1fd2			 
1fd2			 
1fd2			 
1fd2			 
1fd2			; eof 
1fd2			 
# End of file forth_stackopsv5.asm
1fd2			endif 
1fd2			 
1fd2			user_word_eol:  
1fd2				; hl contains the pointer to where to create a linked list item from the end 
1fd2				; of the user dict to continue on at the system word dict 
1fd2				 
1fd2				; poke the stub of the word list linked list to repoint to rom words 
1fd2			 
1fd2				; stub format 
1fd2				; db   word id 
1fd2				; dw    link to next word 
1fd2			        ; db char length of token 
1fd2				; db string + 0 term 
1fd2				; db exec code....  
1fd2			 
1fd2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fd4 77				ld (hl), a		; word id 
1fd5 23				inc hl 
1fd6			 
1fd6 11 9c 21			ld de, sysdict 
1fd9 73				ld (hl), e		; next word link ie system dict 
1fda 23				inc hl 
1fdb 72				ld (hl), d		; next word link ie system dict 
1fdc 23				inc hl	 
1fdd			 
1fdd			;	ld (hl), sysdict		; next word link ie system dict 
1fdd			;	inc hl 
1fdd			;	inc hl 
1fdd			 
1fdd			;	inc hl 
1fdd			;	inc hl 
1fdd			 
1fdd 3e 02			ld a, 2			; word length is 0 
1fdf 77				ld (hl), a	 
1fe0 23				inc hl 
1fe1			 
1fe1 3e 7e			ld a, '~'			; word length is 0 
1fe3 77				ld (hl), a	 
1fe4 23				inc hl 
1fe5 3e 00			ld a, 0			; save empty word 
1fe7 77				ld (hl), a 
1fe8			 
1fe8 c9				ret 
1fe9			 
1fe9				 
1fe9			 
1fe9			forthexec_cleanup: 
1fe9				FORTH_RSP_POP 
1fe9 cd a3 1c			call macro_forth_rsp_pop 
1fec				endm 
# End of macro FORTH_RSP_POP
1fec c9				ret 
1fed			 
1fed			forth_call_hl: 
1fed				; taking hl 
1fed e5				push hl 
1fee c9				ret 
1fef			 
1fef			; this is called to reset Forth system but keep existing uwords etc 
1fef			 
1fef			forth_warmstart: 
1fef				; setup stack over/under flow checks 
1fef				if DEBUG_FORTH_STACK_GUARD 
1fef cd 5d 62				call chk_stk_init 
1ff2				endif 
1ff2			 
1ff2				; init stack pointers  - * these stacks go upwards *  
1ff2 21 05 f9			ld hl, cli_ret_stack 
1ff5 22 8b f9			ld (cli_ret_sp), hl	 
1ff8				; set bottom of stack 
1ff8 3e 00			ld a,0 
1ffa 77				ld (hl),a 
1ffb 23				inc hl 
1ffc 77				ld (hl),a 
1ffd			 
1ffd 21 01 f5			ld hl, cli_data_stack 
2000 22 87 f9			ld (cli_data_sp), hl	 
2003				; set bottom of stack 
2003 3e 00			ld a,0 
2005 77				ld (hl),a 
2006 23				inc hl 
2007 77				ld (hl),a 
2008			 
2008 21 03 f7			ld hl, cli_loop_stack 
200b 22 89 f9			ld (cli_loop_sp), hl	 
200e				; set bottom of stack 
200e 3e 00			ld a,0 
2010 77				ld (hl),a 
2011 23				inc hl 
2012 77				ld (hl),a 
2013			 
2013				; init extent of current open file 
2013			 
2013 3e 00			ld a, 0 
2015 32 d6 f9			ld (store_openext), a 
2018			 
2018 c9				ret 
2019			 
2019			 
2019			; Cold Start - this is called to setup the whole Forth system 
2019			 
2019			forth_init: 
2019			 
2019				; setup stack over/under flow checks 
2019			 
2019			;	if DEBUG_FORTH_STACK_GUARD 
2019			;		call chk_stk_init 
2019			;	endif 
2019			 
2019				; enable auto display updates (slow.....) 
2019			 
2019 3e 01			ld a, 1 
201b 32 a1 f9			ld (cli_autodisplay), a 
201e			 
201e			 
201e			 
201e				; show start up screen 
201e			 
201e cd cd 0a			call clear_display 
2021			 
2021 3e 00			ld a,0 
2023 32 c3 f9			ld (f_cursor_ptr), a 
2026			 
2026				; set start of word list in start of ram - for use when creating user words 
2026			 
2026 21 00 80			ld hl, baseram 
2029 22 97 f2			ld (os_last_new_uword), hl 
202c cd d2 1f			call user_word_eol 
202f				 
202f			;		call display_data_sp 
202f			;		call next_page_prompt 
202f			 
202f			 
202f			 
202f			 
202f c9				ret 
2030			 
2030 .. 00		.bootforth: db " Forth Kernel Init ",0 
2044			 
2044			; TODO push to stack 
2044			 
2044			;  
2044			 
2044			if FORTH_PARSEV2 
2044			 
2044			 
2044				include "forth_parserv2.asm" 
2044			 
2044			endif 
2044			 
2044			 
2044			; parse cli version 1 
2044			 
2044			if FORTH_PARSEV1 
2044			 
2044			 
2044			 
2044			      include "forth_parserv1.asm" 
2044			endif 
2044				 
2044			if FORTH_PARSEV3 
2044			 
2044			 
2044			 
2044			      include "forth_parserv3.asm" 
2044				include "forth_wordsv3.asm" 
2044			endif 
2044			 
2044			if FORTH_PARSEV4 
2044			 
2044			 
2044			 
2044			      include "forth_parserv4.asm" 
2044				include "forth_wordsv4.asm" 
2044			endif 
2044			 
2044			if FORTH_PARSEV5 
2044			 
2044			 
2044			 
2044			      include "forth_parserv5.asm" 
2044			 
2044			 
2044			; A better parser without using malloc and string copies all over the place.  
2044			; Exec in situ should be faster 
2044			 
2044			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2044			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2044			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2044			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2044			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2044			WORD_SYS_END: equ 0   ; Opcode for all user words 
2044			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2044			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2044			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2044			 
2044			; Core word preamble macro 
2044			 
2044			CWHEAD:   macro nxtword opcode lit len opflags 
2044				db WORD_SYS_CORE+opcode             
2044				; internal op code number 
2044				dw nxtword            
2044				; link to next dict word block 
2044				db len + 1 
2044				; literal length of dict word inc zero term 
2044				db lit,0              
2044				; literal dict word 
2044			        ; TODO db opflags        
2044				endm 
2044			 
2044			 
2044			NEXTW: macro  
2044				jp macro_next 
2044				endm 
2044			 
2044			macro_next: 
2044			if DEBUG_FORTH_PARSE_KEY 
2044				DMARK "NXT" 
2044				CALLMONITOR 
2044			endif	 
2044			;	inc hl  ; skip token null term  
2044 ed 4b a5 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2048 ed 5b a3 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
204c 2a 9b f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
204f			if DEBUG_FORTH_PARSE_KEY 
204f				DMARK "}AA" 
204f				CALLMONITOR 
204f			endif	 
204f c3 52 21			jp execnext 
2052				;jp exec1 
2052			       
2052			 
2052			 
2052			; Another go at the parser to compile  
2052			 
2052			 
2052			; TODO rework parser to change all of the string words to byte tokens 
2052			; TODO do a search for  
2052			 
2052			; TODO first run normal parser to zero term sections 
2052			; TODO for each word do a token look up to get the op code 
2052			; TODO need some means to flag to the exec that this is a byte code form    
2052			 
2052			 
2052			forthcompile: 
2052			 
2052			; 
2052			; line parse: 
2052			;       parse raw input buffer 
2052			;       tokenise the words 
2052			;       malloc new copy (for looping etc) 
2052			;       copy to malloc + current pc in line to start of string and add line term 
2052			;       save on new rsp 
2052			; 
2052			 
2052			; hl to point to the line to tokenise 
2052			 
2052			;	push hl 
2052 22 9b f2			ld (os_tok_ptr), hl  ; save ptr to string 
2055			 
2055			;	ld a,0		; string term on input 
2055			;	call strlent 
2055			 
2055			;	ld (os_tok_len), hl	 ; save string length 
2055			 
2055			;if DEBUG_FORTH_TOK 
2055			;	ex de,hl		 
2055			;endif 
2055			 
2055			;	pop hl 		; get back string pointer 
2055			 
2055			if DEBUG_FORTH_TOK 
2055						DMARK "TOc" 
2055				CALLMONITOR 
2055			endif 
2055 7e			.cptoken2:    ld a,(hl) 
2056 23				inc hl 
2057 fe 7f			cp FORTH_END_BUFFER 
2059 28 29			jr z, .cptokendone2 
205b fe 00			cp 0 
205d 28 25			jr z, .cptokendone2 
205f fe 22			cp '"' 
2061 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2063 fe 20			cp ' ' 
2065 20 ee			jr nz,  .cptoken2 
2067			 
2067			; TODO consume comments held between ( and ) 
2067			 
2067				; we have a space so change to zero term for dict match later 
2067 2b				dec hl 
2068 3e 00			ld a,0 
206a 77				ld (hl), a 
206b 23				inc hl 
206c 18 e7			jr .cptoken2 
206e				 
206e			 
206e			.cptokenstr2: 
206e				; skip all white space until either eol (because forgot to term) or end double quote 
206e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
206e				;inc hl ; skip current double quote 
206e 7e				ld a,(hl) 
206f 23				inc hl 
2070 fe 22			cp '"' 
2072 28 e1			jr z, .cptoken2 
2074 fe 7f			cp FORTH_END_BUFFER 
2076 28 0c			jr z, .cptokendone2 
2078 fe 00			cp 0 
207a 28 08			jr z, .cptokendone2 
207c fe 20			cp ' ' 
207e 28 02			jr z, .cptmp2 
2080 18 ec			jr .cptokenstr2 
2082			 
2082			.cptmp2:	; we have a space so change to zero term for dict match later 
2082				;dec hl 
2082				;ld a,"-"	; TODO remove this when working 
2082				;ld (hl), a 
2082				;inc hl 
2082 18 ea			jr .cptokenstr2 
2084			 
2084			.cptokendone2: 
2084				;inc hl 
2084 3e 7f			ld a, FORTH_END_BUFFER 
2086 77				ld (hl),a 
2087 23				inc hl 
2088 3e 21			ld a, '!' 
208a 77				ld (hl),a 
208b			 
208b 2a 9b f2			ld hl,(os_tok_ptr) 
208e			         
208e			if DEBUG_FORTH_TOK 
208e						DMARK "Tc1" 
208e				CALLMONITOR 
208e			endif 
208e			 
208e				; push exec string to top of return stack 
208e				FORTH_RSP_NEXT 
208e cd 82 1c			call macro_forth_rsp_next 
2091				endm 
# End of macro FORTH_RSP_NEXT
2091 c9				ret 
2092			 
2092			; Another go at the parser need to simplify the process 
2092			 
2092			forthparse: 
2092			 
2092			; 
2092			; line parse: 
2092			;       parse raw input buffer 
2092			;       tokenise the words 
2092			;       malloc new copy (for looping etc) 
2092			;       copy to malloc + current pc in line to start of string and add line term 
2092			;       save on new rsp 
2092			; 
2092			 
2092			; hl to point to the line to tokenise 
2092			 
2092			;	push hl 
2092 22 9b f2			ld (os_tok_ptr), hl  ; save ptr to string 
2095			 
2095			;	ld a,0		; string term on input 
2095			;	call strlent 
2095			 
2095			;	ld (os_tok_len), hl	 ; save string length 
2095			 
2095			;if DEBUG_FORTH_TOK 
2095			;	ex de,hl		 
2095			;endif 
2095			 
2095			;	pop hl 		; get back string pointer 
2095			 
2095			if DEBUG_FORTH_TOK 
2095						DMARK "TOK" 
2095				CALLMONITOR 
2095			endif 
2095 7e			.ptoken2:    ld a,(hl) 
2096 23				inc hl 
2097 fe 7f			cp FORTH_END_BUFFER 
2099 28 29			jr z, .ptokendone2 
209b fe 00			cp 0 
209d 28 25			jr z, .ptokendone2 
209f fe 22			cp '"' 
20a1 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
20a3 fe 20			cp ' ' 
20a5 20 ee			jr nz,  .ptoken2 
20a7			 
20a7			; TODO consume comments held between ( and ) 
20a7			 
20a7				; we have a space so change to zero term for dict match later 
20a7 2b				dec hl 
20a8 3e 00			ld a,0 
20aa 77				ld (hl), a 
20ab 23				inc hl 
20ac 18 e7			jr .ptoken2 
20ae				 
20ae			 
20ae			.ptokenstr2: 
20ae				; skip all white space until either eol (because forgot to term) or end double quote 
20ae			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20ae				;inc hl ; skip current double quote 
20ae 7e				ld a,(hl) 
20af 23				inc hl 
20b0 fe 22			cp '"' 
20b2 28 e1			jr z, .ptoken2 
20b4 fe 7f			cp FORTH_END_BUFFER 
20b6 28 0c			jr z, .ptokendone2 
20b8 fe 00			cp 0 
20ba 28 08			jr z, .ptokendone2 
20bc fe 20			cp ' ' 
20be 28 02			jr z, .ptmp2 
20c0 18 ec			jr .ptokenstr2 
20c2			 
20c2			.ptmp2:	; we have a space so change to zero term for dict match later 
20c2				;dec hl 
20c2				;ld a,"-"	; TODO remove this when working 
20c2				;ld (hl), a 
20c2				;inc hl 
20c2 18 ea			jr .ptokenstr2 
20c4			 
20c4			.ptokendone2: 
20c4				;inc hl 
20c4 3e 7f			ld a, FORTH_END_BUFFER 
20c6 77				ld (hl),a 
20c7 23				inc hl 
20c8 3e 21			ld a, '!' 
20ca 77				ld (hl),a 
20cb			 
20cb 2a 9b f2			ld hl,(os_tok_ptr) 
20ce			         
20ce			if DEBUG_FORTH_TOK 
20ce						DMARK "TK1" 
20ce				CALLMONITOR 
20ce			endif 
20ce			 
20ce				; push exec string to top of return stack 
20ce				FORTH_RSP_NEXT 
20ce cd 82 1c			call macro_forth_rsp_next 
20d1				endm 
# End of macro FORTH_RSP_NEXT
20d1 c9				ret 
20d2			 
20d2			; 
20d2			;	; malloc size + buffer pointer + if is loop flag 
20d2			;	ld hl,(os_tok_len) 		 ; get string length 
20d2			; 
20d2			;	ld a,l 
20d2			; 
20d2			;	cp 0			; we dont want to use a null string 
20d2			;	ret z 
20d2			; 
20d2			;;	add 3    ; prefix malloc with buffer for current word ptr 
20d2			; 
20d2			;	add 5     ; TODO when certain not over writing memory remove 
20d2			; 
20d2			;		 
20d2			; 
20d2			;if DEBUG_FORTH_TOK 
20d2			;			DMARK "TKE" 
20d2			;	CALLMONITOR 
20d2			;endif 
20d2			; 
20d2			;	ld l,a 
20d2			;	ld h,0 
20d2			;;	push hl   ; save required space for the copy later 
20d2			;	call malloc 
20d2			;if DEBUG_FORTH_TOK 
20d2			;			DMARK "TKM" 
20d2			;	CALLMONITOR 
20d2			;endif 
20d2			;	if DEBUG_FORTH_MALLOC_GUARD 
20d2			;		push af 
20d2			;		call ishlzero 
20d2			;;		ld a, l 
20d2			;;		add h 
20d2			;;		cp 0 
20d2			;		pop af 
20d2			;		 
20d2			;		call z,malloc_error 
20d2			;	endif 
20d2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20d2			; 
20d2			; 
20d2			;if DEBUG_FORTH_TOK 
20d2			;			DMARK "TKR" 
20d2			;	CALLMONITOR 
20d2			;endif 
20d2			; 
20d2			;	FORTH_RSP_NEXT 
20d2			; 
20d2			;	;inc hl	 ; go past current buffer pointer 
20d2			;	;inc hl 
20d2			;	;inc hl   ; and past if loop flag 
20d2			;		; TODO Need to set flag  
20d2			; 
20d2			;	 
20d2			;	 
20d2			;	ex de,hl	; malloc is dest 
20d2			;	ld hl, (os_tok_len) 
20d2			;;	pop bc 
20d2			;	ld c, l                
20d2			;	ld b,0 
20d2			;	ld hl, (os_tok_ptr) 
20d2			; 
20d2			;if DEBUG_FORTH_TOK 
20d2			;			DMARK "TKT" 
20d2			;	CALLMONITOR 
20d2			;endif 
20d2			; 
20d2			;	; do str cpy 
20d2			; 
20d2			;	ldir      ; copy byte in hl to de 
20d2			; 
20d2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20d2			; 
20d2			;if DEBUG_FORTH_TOK 
20d2			; 
20d2			;			DMARK "TKY" 
20d2			;	CALLMONITOR 
20d2			;endif 
20d2			;	;ld a,0 
20d2			;	;ld a,FORTH_END_BUFFER 
20d2			;	ex de, hl 
20d2			;	;dec hl			 ; go back over the space delim at the end of word 
20d2			;	;ld (hl),a 
20d2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20d2			;	ld a,FORTH_END_BUFFER 
20d2			;	ld (hl),a 
20d2			;	inc hl 
20d2			;	ld a,FORTH_END_BUFFER 
20d2			;	ld (hl),a 
20d2			; 
20d2			;	; init the malloc area data 
20d2			;	; set pc for in current area 
20d2			;	;ld hl, (os_tok_malloc) 
20d2			;	;inc hl 
20d2			;	;inc hl 
20d2			;	;inc hl 
20d2			;	;ex de,hl 
20d2			;	;ld hl, (os_tok_malloc) 
20d2			;	;ld (hl),e 
20d2			;	;inc hl 
20d2			;	;ld (hl),d 
20d2			; 
20d2			; 
20d2			;	ld hl,(os_tok_malloc) 
20d2			;if DEBUG_FORTH_PARSE_KEY 
20d2			;			DMARK "TKU" 
20d2			;	CALLMONITOR 
20d2			;endif 
20d2			; 
20d2			;	ret 
20d2			 
20d2			forthexec: 
20d2			 
20d2			; line exec: 
20d2			; forth parser 
20d2			 
20d2			; 
20d2			;       get current exec line on rsp 
20d2			 
20d2				FORTH_RSP_TOS 
20d2 cd 99 1c			call macro_forth_rsp_tos 
20d5				endm 
# End of macro FORTH_RSP_TOS
20d5			 
20d5			;       restore current pc - hl points to malloc of data 
20d5			 
20d5				;ld e, (hl) 
20d5				;inc hl 
20d5				;ld d, (hl) 
20d5				;ex de,hl 
20d5			 
20d5			 
20d5			exec1: 
20d5 22 9b f2			ld (os_tok_ptr), hl 
20d8			 
20d8				; copy our PC to working vars  
20d8 22 a5 f9			ld (cli_ptr), hl 
20db 22 a3 f9			ld (cli_origptr), hl 
20de			 
20de 7e				ld a,(hl) 
20df fe 7f			cp FORTH_END_BUFFER 
20e1 c8				ret z 
20e2			 
20e2				; skip any nulls 
20e2			 
20e2 fe 00			cp 0 
20e4 20 03			jr nz, .execword 
20e6 23				inc hl 
20e7 18 ec			jr exec1 
20e9			 
20e9			 
20e9			.execword: 
20e9			 
20e9			 
20e9			 
20e9			if DEBUG_FORTH_PARSE_KEY 
20e9						DMARK "KYQ" 
20e9				CALLMONITOR 
20e9			endif 
20e9			;       while at start of word: 
20e9			; get start of dict (in user area first) 
20e9			 
20e9 21 00 80		ld hl, baseram 
20ec			;ld hl, sysdict 
20ec 22 a7 f9		ld (cli_nextword),hl 
20ef			;           match word at pc 
20ef			;           exec word 
20ef			;           or push to dsp 
20ef			;           forward to next token 
20ef			;           if line term pop rsp and exit 
20ef			;        
20ef			 
20ef			if DEBUG_FORTH_PARSE_KEY 
20ef						DMARK "KYq" 
20ef				CALLMONITOR 
20ef			endif 
20ef			 
20ef			; 
20ef			; word comp 
20ef			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20ef			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20ef			;    move to start of word  
20ef			;    compare word to cli_token 
20ef			 
20ef			.execpnword:	; HL at start of a word in the dictionary to check 
20ef			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20ef			;	ld (cli_ptr), hl 
20ef			 
20ef 2a a7 f9			ld hl,(cli_nextword) 
20f2			 
20f2 cd 95 21			call forth_tok_next 
20f5			; tok next start here 
20f5			;	; TODO skip compiled symbol for now 
20f5			;	inc hl 
20f5			; 
20f5			;	; save pointer to next word 
20f5			; 
20f5			;	; hl now points to the address of the next word pointer  
20f5			;	ld e, (hl) 
20f5			;	inc hl 
20f5			;	ld d, (hl) 
20f5			;	inc l 
20f5			; 
20f5			;	ex de,hl 
20f5			;if DEBUG_FORTH_PARSE_NEXTWORD 
20f5			;	push bc 
20f5			;	ld bc, (cli_nextword) 
20f5			;			DMARK "NXW" 
20f5			;	CALLMONITOR 
20f5			;	pop bc 
20f5			;endif 
20f5			; tok next end here 
20f5 22 a7 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
20f8 eb				ex de, hl 
20f9			 
20f9			 
20f9				; save the pointer of the current token - 1 to check against 
20f9				 
20f9 22 ab f9			ld (cli_token), hl   
20fc				; TODO maybe remove below save if no debug 
20fc				; save token string ptr for any debug later 
20fc 23				inc hl  
20fd 22 ad f9			ld (cli_origtoken), hl 
2100 2b				dec hl 
2101				; save pointer to the start of the next dictionay word 
2101 7e				ld a,(hl)   ; get string length 
2102 47				ld b,a 
2103			.execpnwordinc:  
2103 23				inc hl 
2104 10 fd			djnz .execpnwordinc 
2106 22 a9 f9			ld (cli_execword), hl      ; save start of this words code 
2109			 
2109				; now check the word token against the string being parsed 
2109			 
2109 2a ab f9			ld hl,(cli_token) 
210c 23				inc hl     ; skip string length (use zero term instead to end) 
210d 22 ab f9			ld (cli_token), hl 
2110			 
2110			if DEBUG_FORTH_PARSE_KEY 
2110						DMARK "KY2" 
2110			endif 
2110			if DEBUG_FORTH_PARSE_EXEC 
2110				; see if disabled 
2110			 
2110				ld a, (os_view_disable) 
2110				cp '*' 
2110				jr z, .skip 
2110			 
2110				push hl 
2110				push hl 
2110				call clear_display 
2110				ld de, .compword 
2110				ld a, display_row_1 
2110				call str_at_display 
2110				pop de 
2110				ld a, display_row_2 
2110				call str_at_display 
2110				ld hl,(cli_ptr) 
2110				ld a,(hl) 
2110			        ld hl, os_word_scratch 
2110				ld (hl),a 
2110				ld a,0 
2110				inc hl 
2110				ld (hl),a 	 
2110				ld de, os_word_scratch 
2110				ld a, display_row_2+10 
2110				call str_at_display 
2110				call update_display 
2110				ld a, 100 
2110				call aDelayInMS 
2110				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2110				call delay250ms 
2110				endif 
2110				pop hl 
2110			.skip:  
2110			endif	 
2110			.execpnchar:    ; compare char between token and string to parse 
2110			 
2110			if DEBUG_FORTH_PARSE_KEY 
2110						DMARK "Ky3" 
2110			endif 
2110			if DEBUG_FORTH_PARSE_EXEC 
2110				; see if disabled 
2110			 
2110				ld a, (os_view_disable) 
2110				cp '*' 
2110				jr z, .skip2 
2110			 
2110			;	call clear_display 
2110			ld hl,(cli_token) 
2110			ld a,(hl) 
2110			ld (os_word_scratch),a 
2110				ld hl,(cli_ptr) 
2110			ld a,(hl) 
2110				ld (os_word_scratch+1),a 
2110				ld a,0 
2110				ld (os_word_scratch+2),a 
2110				ld de,os_word_scratch 
2110				ld a,display_row_4 
2110				call str_at_display 
2110				call update_display 
2110			.skip2:  
2110			endif 
2110 2a ab f9			ld hl,(cli_token) 
2113 7e				ld a, (hl)	 ; char in word token 
2114 23				inc hl 		; move to next char 
2115 22 ab f9			ld (cli_token), hl ; and save it 
2118 47				ld b,a 
2119			 
2119 2a a5 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
211c 7e				ld a,(hl) 
211d 23				inc hl 
211e 22 a5 f9			ld (cli_ptr), hl		; move to next char 
2121 cd 56 11			call toUpper 		; make sure the input string matches case 
2124			 
2124			if DEBUG_FORTH_PARSE 
2124			endif 
2124			 
2124				; input stream end of token is a space so get rid of it 
2124			 
2124			;	cp ' ' 
2124			;	jr nz, .pnskipspace 
2124			; 
2124			;	ld a, 0		; make same term as word token term 
2124			; 
2124			;.pnskipspace: 
2124			 
2124			if DEBUG_FORTH_PARSE_KEY 
2124						DMARK "KY7" 
2124			endif 
2124 b8				cp b 
2125 c2 3b 21			jp nz, .execpnskipword	 ; no match so move to next word 
2128				 
2128			;    if same 
2128			;       scan for string terms 0 for token and 32 for input 
2128			 
2128				 
2128			if DEBUG_FORTH_PARSE_KEY 
2128						DMARK "KY8" 
2128			endif 
2128			 
2128 80				add b			 
2129 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
212b							; TODO need to make sure last word in zero term string is accounted for 
212b 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
212d			 
212d			 
212d				; at end of both strings so both are exact match 
212d			 
212d			;       skip ptr for next word 
212d			 
212d 2a a5 f9			ld hl,(cli_ptr) 	; at input string term 
2130 23				inc hl			 ; at next char 
2131 22 a5 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2134 22 a3 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2137				 
2137				 
2137			if DEBUG_FORTH_PARSE_KEY 
2137						DMARK "KY3" 
2137			endif 
2137			 
2137			 
2137			 
2137			;       exec code block 
2137			if DEBUG_FORTH_JP 
2137				call clear_display 
2137				call update_display 
2137				call delay1s 
2137				ld hl, (cli_execword)     ; save for next check if no match on this word 
2137				ld a,h 
2137				ld hl, os_word_scratch 
2137				call hexout 
2137				ld hl, (cli_execword)     ; save for next check if no match on this word 
2137				ld a,l 
2137				ld hl, os_word_scratch+2 
2137				call hexout 
2137				ld hl, os_word_scratch+4 
2137				ld a,0 
2137				ld (hl),a 
2137				ld de,os_word_scratch 
2137				call str_at_display 
2137					ld a, display_row_2 
2137					call str_at_display 
2137				ld de, (cli_origtoken) 
2137				ld a, display_row_1+10 
2137					call str_at_display 
2137			 
2137				ld a,display_row_1 
2137				ld de, .foundword 
2137				ld a, display_row_3 
2137				call str_at_display 
2137				call update_display 
2137				call delay1s 
2137				call delay1s 
2137				call delay1s 
2137			endif 
2137			 
2137			if DEBUG_FORTH_PARSE_KEY 
2137						DMARK "KYj" 
2137			endif 
2137				; TODO save the word pointer in this exec 
2137			 
2137 2a a9 f9			ld hl,(cli_execword) 
213a e9				jp (hl) 
213b			 
213b			 
213b			;    if not same 
213b			;	scan for zero term 
213b			;	get ptr for next word 
213b			;	goto word comp 
213b			 
213b			.execpnskipword:	; get pointer to next word 
213b 2a a7 f9			ld hl,(cli_nextword) 
213e			 
213e 7e				ld a,(hl) 
213f fe 00			cp WORD_SYS_END 
2141			;	cp 0 
2141 28 09			jr z, .execendofdict			 ; at end of words 
2143			 
2143			if DEBUG_FORTH_PARSE_KEY 
2143						DMARK "KY4" 
2143			endif 
2143			if DEBUG_FORTH_PARSE_EXEC 
2143			 
2143				; see if disabled 
2143			 
2143				ld a, (os_view_disable) 
2143				cp '*' 
2143				jr z, .noskip 
2143			 
2143			 
2143				ld de, .nowordfound 
2143				ld a, display_row_3 
2143				call str_at_display 
2143				call update_display 
2143				ld a, 100 
2143				call aDelayInMS 
2143				 
2143				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2143					call delay250ms 
2143				endif 
2143			.noskip:  
2143			 
2143			endif	 
2143			 
2143 2a a3 f9			ld hl,(cli_origptr) 
2146 22 a5 f9			ld (cli_ptr),hl 
2149			 
2149			if DEBUG_FORTH_PARSE_KEY 
2149						DMARK "KY5" 
2149			endif 
2149 c3 ef 20			jp .execpnword			; else go to next word 
214c			 
214c			.execendofdict:  
214c			 
214c			if DEBUG_FORTH_PARSE_KEY 
214c						DMARK "KYe" 
214c			endif 
214c			if DEBUG_FORTH_PARSE_EXEC 
214c				; see if disabled 
214c			 
214c				ld a, (os_view_disable) 
214c				cp '*' 
214c				jr z, .ispskip 
214c			 
214c				call clear_display 
214c				call update_display 
214c				call delay1s 
214c				ld de, (cli_origptr) 
214c				ld a, display_row_1 
214c				call str_at_display 
214c				 
214c				ld de, .enddict 
214c				ld a, display_row_3 
214c				call str_at_display 
214c				call update_display 
214c				ld a, 100 
214c				call aDelayInMS 
214c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
214c				call delay1s 
214c				call delay1s 
214c				call delay1s 
214c				endif 
214c			.ispskip:  
214c				 
214c			endif	 
214c			 
214c			 
214c			 
214c				; if the word is not a keyword then must be a literal so push it to stack 
214c			 
214c			; push token to stack to end of word 
214c			 
214c				STACKFRAME ON $1efe $2f9f 
214c				if DEBUG_STACK_IMB 
214c					if ON 
214c						exx 
214c						ld de, $1efe 
214c						ld a, d 
214c						ld hl, curframe 
214c						call hexout 
214c						ld a, e 
214c						ld hl, curframe+2 
214c						call hexout 
214c						ld hl, $1efe 
214c						push hl 
214c						ld hl, $2f9f 
214c						push hl 
214c						exx 
214c					endif 
214c				endif 
214c			endm 
# End of macro STACKFRAME
214c			 
214c 2a 9b f2		ld hl,(os_tok_ptr) 
214f cd 44 1e		call forth_apush 
2152			 
2152				STACKFRAMECHK ON $1efe $2f9f 
2152				if DEBUG_STACK_IMB 
2152					if ON 
2152						exx 
2152						ld hl, $2f9f 
2152						pop de   ; $2f9f 
2152						call cmp16 
2152						jr nz, .spnosame 
2152						ld hl, $1efe 
2152						pop de   ; $1efe 
2152						call cmp16 
2152						jr z, .spfrsame 
2152						.spnosame: call showsperror 
2152						.spfrsame: nop 
2152						exx 
2152					endif 
2152				endif 
2152			endm 
# End of macro STACKFRAMECHK
2152			 
2152			execnext: 
2152			 
2152			if DEBUG_FORTH_PARSE_KEY 
2152						DMARK "KY>" 
2152			endif 
2152			; move past token to next word 
2152			 
2152 2a 9b f2		ld hl, (os_tok_ptr) 
2155 3e 00		ld a, 0 
2157 01 ff 00		ld bc, 255     ; input buffer size 
215a ed b1		cpir 
215c			 
215c			if DEBUG_FORTH_PARSE_KEY 
215c						DMARK "KY!" 
215c				CALLMONITOR 
215c			endif	 
215c			; TODO this might place hl on the null, so will need to forward on??? 
215c			;inc hl   ; see if this gets onto the next item 
215c			 
215c			 
215c			; TODO pass a pointer to the buffer to push 
215c			; TODO call function to push 
215c			 
215c			; look for end of input 
215c			 
215c			;inc hl 
215c			;ld a,(hl) 
215c			;cp FORTH_END_BUFFER 
215c			;ret z 
215c			 
215c			 
215c c3 d5 20		jp exec1 
215f			 
215f			 
215f			 
215f			 
215f			 
215f			 
215f			 
215f			 
215f			 
215f			findnexttok: 
215f			 
215f				; hl is pointer to move 
215f				; de is the token to locate 
215f			 
215f					if DEBUG_FORTH 
215f						DMARK "NTK" 
215f						CALLMONITOR 
215f					endif 
215f d5				push de 
2160			 
2160			.fnt1:	 
2160				; find first char of token to locate 
2160			 
2160 1a				ld a, (de) 
2161 4f				ld c,a 
2162 7e				ld a,(hl) 
2163 cd 56 11			call toUpper 
2166					if DEBUG_FORTH 
2166						DMARK "NT1" 
2166						CALLMONITOR 
2166					endif 
2166 b9				cp c 
2167			 
2167 28 03			jr z, .fnt2cmpmorefirst	 
2169			 
2169				; first char not found move to next char 
2169			 
2169 23				inc hl 
216a 18 f4			jr .fnt1 
216c			 
216c			.fnt2cmpmorefirst:	 
216c				; first char of token found.  
216c			 
216c e5				push hl     ; save start of token just in case it is the right one 
216d d9				exx 
216e e1				pop hl        ; save it to hl' 
216f d9				exx 
2170			 
2170			 
2170			.fnt2cmpmore:	 
2170				; compare the rest 
2170				 
2170 23				inc hl 
2171 13				inc de 
2172				 
2172 1a				ld a, (de) 
2173 4f				ld c,a 
2174 7e				ld a,(hl) 
2175 cd 56 11			call toUpper 
2178			 
2178					if DEBUG_FORTH 
2178						DMARK "NT2" 
2178						CALLMONITOR 
2178					endif 
2178				; c has the token to find char 
2178				; a has the mem to scan char 
2178			 
2178 b9				cp c 
2179 28 04			jr z,.fntmatch1 
217b			 
217b				; they are not the same 
217b			 
217b					if DEBUG_FORTH 
217b						DMARK "NT3" 
217b						CALLMONITOR 
217b					endif 
217b d1				pop de	; reset de token to look for 
217c d5				push de 
217d 18 e1			jr .fnt1 
217f				 
217f			.fntmatch1: 
217f			 
217f				; is the same char a null which means we might have a full hit? 
217f					if DEBUG_FORTH 
217f						DMARK "NT4" 
217f						CALLMONITOR 
217f					endif 
217f			 
217f fe 00			cp 0 
2181 28 0b			jr z, .fntmatchyes 
2183			 
2183				; are we at the end of the token to find? 
2183			 
2183					if DEBUG_FORTH 
2183						DMARK "NT5" 
2183						CALLMONITOR 
2183					endif 
2183 3e 00			ld a, 0 
2185 b9				cp c 
2186			 
2186 c2 70 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2189			 
2189					if DEBUG_FORTH 
2189						DMARK "NT6" 
2189						CALLMONITOR 
2189					endif 
2189				; token to find is exhusted but no match to stream 
2189			 
2189				; restore tok pointer and continue on 
2189 d1				pop de 
218a d5				push de 
218b c3 60 21			jp .fnt1 
218e			 
218e			 
218e			.fntmatchyes: 
218e			 
218e				; hl now contains the end of the found token 
218e			 
218e				; get rid of saved token pointer to find 
218e			 
218e d1				pop de 
218f			 
218f					if DEBUG_FORTH 
218f						DMARK "NT9" 
218f						CALLMONITOR 
218f					endif 
218f			 
218f				; hl will be on the null term so forward on 
218f			 
218f				; get back the saved start of the token 
218f			 
218f d9				exx 
2190 e5				push hl     ; save start of token just in case it is the right one 
2191 d9				exx 
2192 e1				pop hl        ; save it to hl 
2193			 
2193 c9				ret 
2194			 
2194			 
2194			; LIST needs to find a specific token   
2194			; FORGET needs to find a spefici token 
2194			 
2194			; SAVE needs to find all tokens by flag 
2194			; WORDS just needs to scan through all  by flag 
2194			; UWORDS needs to scan through all by flag 
2194			 
2194			 
2194			; given hl as pointer to start of dict look up string 
2194			; return hl as pointer to start of word block 
2194			; or 0 if not found 
2194			 
2194			forth_find_tok: 
2194 c9				ret 
2195			 
2195			; given hl as pointer to dict structure 
2195			; move to the next dict block structure 
2195			 
2195			forth_tok_next: 
2195				; hl now points to the address of the next word pointer  
2195				; TODO skip compiled symbol for now 
2195			;	push de 
2195 23				inc hl 
2196 5e				ld e, (hl) 
2197 23				inc hl 
2198 56				ld d, (hl) 
2199 23				inc hl 
219a			 
219a eb				ex de,hl 
219b			if DEBUG_FORTH_PARSE_NEXTWORD 
219b				push bc 
219b				ld bc, (cli_nextword) 
219b						DMARK "NXW" 
219b				CALLMONITOR 
219b				pop bc 
219b			endif 
219b			;	pop de	 
219b c9				ret 
219c			 
219c			 
219c			 
219c			; eof 
# End of file forth_parserv5.asm
219c				include "forth_wordsv4.asm" 
219c			 
219c			; the core word dictionary v4 
219c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
219c			 
219c			; this is a linked list for each of the system words used 
219c			; user defined words will follow the same format but will be in ram 
219c			 
219c			 
219c			; 
219c			; 
219c			; define linked list: 
219c			; 
219c			; 1. compiled byte op code 
219c			; 2. len of text word 
219c			; 3. text word 
219c			; 4. ptr to next dictionary word 
219c			; 5. asm, calls etc for the word 
219c			; 
219c			;  if 1 == 0 then last word in dict  
219c			;   
219c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
219c			;  
219c			;  
219c			; create basic standard set of words 
219c			; 
219c			;  
219c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
219c			; 2DUP 2DROP 2SWAP  
219c			; @ C@ - get byte  
219c			; ! C! - store byte 
219c			; 0< true if less than zero 
219c			; 0= true if zero 
219c			; < >  
219c			; = true if same 
219c			; variables 
219c			 
219c			 
219c			; Hardware specific words I may need 
219c			; 
219c			; IN OUT  
219c			; calls to key util functions 
219c			; calls to hardward abstraction stuff 
219c			; easy control of frame buffers and lcd i/o 
219c			; keyboard  
219c			 
219c			 
219c			;DICT: macro 
219c			; op_code, len, word, next 
219c			;    word: 
219c			;    db op_code 
219c			;    ds word zero term 
219c			;    dw next 
219c			;    endm 
219c			 
219c			 
219c			 
219c			 
219c			; op code 1 is a flag for user define words which are to be handled differently 
219c			 
219c			 
219c			; 
219c			; 
219c			;    TODO on entry to a word this should be the expected environment 
219c			;    hl - tos value if number then held, if string this is the ptr 
219c			;    de -  
219c			 
219c			 
219c			; opcode ranges 
219c			; 0 - end of word dict 
219c			; 255 - user define words 
219c			 
219c			sysdict: 
219c			include "forth_opcodes.asm" 
219c			; op codes for forth keywords 
219c			; free to use code 0  
219c				OPCODE_HEAP: equ  1 
219c				OPCODE_EXEC: equ 2 
219c				OPCODE_DUP: equ 3 
219c				OPCODE_SWAP: equ 4 
219c				OPCODE_COLN: equ 5 
219c				OPCODE_SCOLN: equ 6 
219c				OPCODE_DROP: equ 7 
219c				OPCODE_DUP2: equ 8 
219c				OPCODE_DROP2: equ 9 
219c				OPCODE_SWAP2: equ 10 
219c				OPCODE_AT: equ 11 
219c				OPCODE_CAT: equ 12 
219c				OPCODE_BANG: equ 13 
219c				OPCODE_CBANG: equ 14 
219c				OPCODE_SCALL: equ 15 
219c				OPCODE_DEPTH: equ 16 
219c				OPCODE_OVER: equ 17 
219c				OPCODE_PAUSE: equ 18 
219c				OPCODE_PAUSES: equ 19 
219c				OPCODE_ROT: equ 20 
219c			;free to reuse	OPCODE_WORDS: equ 21 
219c			        OPCODE_NOT: equ 21 
219c				OPCODE_UWORDS: equ 22 
219c				OPCODE_BP: equ 23 
219c				OPCODE_MONITOR: equ 24  
219c				OPCODE_MALLOC: equ 25 
219c				OPCODE_FREE: equ 26 
219c				OPCODE_LIST: equ 27 
219c				OPCODE_FORGET: equ 28 
219c				OPCODE_NOP: equ 29 
219c				OPCODE_COMO: equ 30 
219c				OPCODE_COMC: equ 31 
219c			;free to reuse	OPCODE_ENDCORE: equ 32 
219c				OPCODE_AFTERSOUND: equ 33 
219c				OPCODE_GP2: equ 34 
219c				OPCODE_GP3: equ 35 
219c				OPCODE_GP4: equ 36 
219c				OPCODE_SIN: equ 37 
219c				OPCODE_SOUT: equ 38 
219c				OPCODE_SPIO: equ 39 
219c				OPCODE_SPICEH: equ 40 
219c				OPCODE_SPIOb: equ 41 
219c				OPCODE_SPII: equ 42 
219c				OPCODE_SESEL: equ 43 
219c				OPCODE_CARTDEV: equ 44 
219c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
219c				OPCODE_FB: equ 46 
219c				OPCODE_EMIT: equ 47 
219c				OPCODE_DOTH: equ 48 
219c				OPCODE_DOTF: equ 49 
219c				OPCODE_DOT: equ 50 
219c				OPCODE_CLS: equ 51 
219c				OPCODE_DRAW: equ 52 
219c				OPCODE_DUMP: equ 53 
219c				OPCODE_CDUMP: equ 54 
219c				OPCODE_DAT: equ 55 
219c				OPCODE_HOME: equ 56 
219c				OPCODE_SPACE: equ 57 
219c				OPCODE_SPACES: equ 58 
219c				OPCODE_SCROLL: equ 59 
219c				OPCODE_ATQ: equ 60 
219c				OPCODE_AUTODSP: equ 61 
219c				OPCODE_MENU: equ 62 
219c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
219c				OPCODE_THEN: equ 64 
219c				OPCODE_ELSE: equ 65 
219c				OPCODE_DO: equ 66 
219c				OPCODE_LOOP: equ 67 
219c				OPCODE_I: equ 68 
219c				OPCODE_DLOOP: equ 69  
219c				OPCODE_REPEAT: equ 70  
219c				OPCODE_UNTIL: equ 71 
219c				OPCODE_ENDFLOW: equ 72 
219c				OPCODE_WAITK: equ 73 
219c				OPCODE_ACCEPT: equ 74 
219c				OPCODE_EDIT: equ 75 
219c			;free to reuse	OPCODE_ENDKEY: equ 76 
219c				OPCODE_LZERO: equ 77 
219c				OPCODE_TZERO: equ 78 
219c				OPCODE_LESS: equ 79 
219c				OPCODE_GT: equ 80 
219c				OPCODE_EQUAL: equ 81  
219c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
219c				OPCODE_NEG: equ 83 
219c				OPCODE_DIV: equ 84 
219c				OPCODE_MUL: equ 85 
219c				OPCODE_MIN: equ 86 
219c				OPCODE_MAX: equ 87 
219c				OPCODE_RND16: equ 88 
219c				OPCODE_RND8: equ 89 
219c				OPCODE_RND: equ 90 
219c			;free to reuse	OPCODE_ENDMATHS: equ 91  
219c				OPCODE_BYNAME: equ 92 
219c				OPCODE_DIR: equ 93 
219c				OPCODE_SAVE: equ 94 
219c				OPCODE_LOAD: equ 95 
219c				OPCODE_BSAVE: equ 96 
219c				OPCODE_BLOAD: equ 97 
219c				OPCODE_SEO: equ 98  
219c				OPCODE_SEI: equ 99 
219c				OPCODE_SFREE: equ 100 
219c				OPCODE_SIZE: equ 101 
219c				OPCODE_CREATE: equ 102 
219c				OPCODE_APPEND: equ 103 
219c				OPCODE_SDEL: equ 104 
219c				OPCODE_OPEN: equ 105 
219c				OPCODE_READ: equ 106 
219c				OPCODE_EOF: equ 106 
219c				OPCODE_FORMAT: equ 107 
219c				OPCODE_LABEL: equ 108 
219c				OPCODE_LABELS: equ 109 
219c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
219c				OPCODE_UPPER: equ 111 
219c				OPCODE_LOWER: equ 112 
219c				OPCODE_SUBSTR: equ 113 
219c				OPCODE_LEFT: equ 114 
219c				OPCODE_RIGHT: equ 115 
219c				OPCODE_STR2NUM: equ 116 
219c				OPCODE_NUM2STR: equ 117 
219c				OPCODE_CONCAT: equ 118 
219c				OPCODE_FIND: equ 119 
219c				OPCODE_LEN: equ 120 
219c				OPCODE_CHAR: equ 121 
219c			; free to reuse	OPCODE_STRLEN: equ 122 
219c			; free to reuse	OPCODE_ENDSTR: equ 123 
219c				OPCODE_V0S: equ 124 
219c				OPCODE_V0Q: equ 125 
219c				OPCODE_V1S: equ 126 
219c				OPCODE_V1Q: equ 127 
219c				OPCODE_V2S: equ 128 
219c				OPCODE_V2Q: equ 129 
219c				OPCODE_V3S: equ 130 
219c				OPCODE_V3Q: equ 131 
219c			;free to reuse	OPCODE_END: equ 132 
219c				OPCODE_ZDUP: equ 133 
219c			 
219c			; eof 
# End of file forth_opcodes.asm
219c			 
219c			include "forth_words_core.asm" 
219c			 
219c			; | ## Core Words 
219c			 
219c			;if MALLOC_4 
219c			 
219c			.HEAP: 
219c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
219c 15				db WORD_SYS_CORE+OPCODE_HEAP             
219d db 21			dw .EXEC            
219f 05				db 4 + 1 
21a0 .. 00			db "HEAP",0              
21a5				endm 
# End of macro CWHEAD
21a5			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21a5			; | | u1 - Current number of bytes in the heap 
21a5			; | | u2 - Remaining bytes left on the heap 
21a5			; | |  
21a5			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21a5			 
21a5			 
21a5					if DEBUG_FORTH_WORDS_KEY 
21a5						DMARK "HEP" 
21a5 f5				push af  
21a6 3a ba 21			ld a, (.dmark)  
21a9 32 b4 fb			ld (debug_mark),a  
21ac 3a bb 21			ld a, (.dmark+1)  
21af 32 b5 fb			ld (debug_mark+1),a  
21b2 3a bc 21			ld a, (.dmark+2)  
21b5 32 b6 fb			ld (debug_mark+2),a  
21b8 18 03			jr .pastdmark  
21ba ..			.dmark: db "HEP"  
21bd f1			.pastdmark: pop af  
21be			endm  
# End of macro DMARK
21be						CALLMONITOR 
21be cd 7e 16			call break_point_state  
21c1				endm  
# End of macro CALLMONITOR
21c1					endif 
21c1 2a 0a 80				ld hl, (free_list )      
21c4 11 0e 80				ld de, heap_start 
21c7			 
21c7 ed 52				sbc hl, de  
21c9			 
21c9 cd db 1c				call forth_push_numhl 
21cc			 
21cc			 
21cc ed 5b 0a 80			ld de, (free_list )      
21d0 21 80 ef				ld hl, heap_end 
21d3			 
21d3 ed 52				sbc hl, de 
21d5			 
21d5 cd db 1c				call forth_push_numhl 
21d8					 
21d8			 
21d8					 
21d8			 
21d8			 
21d8			 
21d8					NEXTW 
21d8 c3 44 20			jp macro_next 
21db				endm 
# End of macro NEXTW
21db			;endif 
21db			 
21db			.EXEC: 
21db			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21db			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21db			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21db			;; > > 
21db			;; > >   
21db			;	STACKFRAME OFF $5efe $5f9f 
21db			; 
21db			;		if DEBUG_FORTH_WORDS_KEY 
21db			;			DMARK "EXE" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			; 
21db			;	FORTH_DSP_VALUEHL 
21db			; 
21db			;	FORTH_DSP_POP 
21db			; 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EX1" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;;	ld e,(hl) 
21db			;;	inc hl 
21db			;;	ld d,(hl) 
21db			;;	ex de,hl 
21db			; 
21db			;;		if DEBUG_FORTH_WORDS 
21db			;;			DMARK "EX2" 
21db			;;			CALLMONITOR 
21db			;;		endif 
21db			;	push hl 
21db			; 
21db			;	;ld a, 0 
21db			;	;ld a, FORTH_END_BUFFER 
21db			;	call strlenz 
21db			;	inc hl   ; include zero term to copy 
21db			;	inc hl   ; include term 
21db			;	inc hl   ; include term 
21db			;	ld b,0 
21db			;	ld c,l 
21db			;	pop hl 
21db			;	ld de, execscratch 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EX3" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;	ldir 
21db			; 
21db			; 
21db			;	ld hl, execscratch 
21db			; 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EXe" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			; 
21db			;	call forthparse 
21db			;	call forthexec 
21db			;;	call forthexec_cleanup 
21db			;;	call forthparse 
21db			;;	call forthexec 
21db			; 
21db			;	STACKFRAMECHK OFF $5efe $5f9f 
21db			; 
21db			;	; an immediate word so no need to process any more words 
21db			;	ret 
21db			;	NEXTW 
21db			 
21db			; dead code - old version  
21db			;	FORTH_RSP_NEXT 
21db			 
21db			;  
21db			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21db			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21db			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21db			;	push hl 
21db			;	push de 
21db			;	push bc 
21db			; 
21db			; 
21db			;		if DEBUG_FORTH_WORDS_KEY 
21db			;			DMARK "EXR" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			; 
21db			; 
21db			; 
21db			;	;v5 FORTH_DSP_VALUE 
21db			;	FORTH_DSP_VALUEHL 
21db			; 
21db			;	; TODO do string type checks 
21db			; 
21db			;;v5	inc hl   ; skip type 
21db			; 
21db			;	push hl  ; source code  
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EX1" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;	ld a, 0 
21db			;	call strlent 
21db			; 
21db			;	inc hl 
21db			;	inc hl 
21db			;	inc hl 
21db			;	inc hl 
21db			; 
21db			;	push hl    ; size 
21db			; 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EX2" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;	call malloc 
21db			; 
21db			;	ex de, hl    ; de now contains malloc area 
21db			;	pop bc   	; get byte count 
21db			;	pop hl      ; get string to copy 
21db			; 
21db			;	push de     ; save malloc for free later 
21db			; 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EX3" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;	ldir       ; duplicate string 
21db			; 
21db			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21db			;	 
21db			;	; TODO fix the parse would be better than this...  
21db			;	ex de, hl 
21db			;	dec hl 
21db			;	ld a, 0 
21db			;	ld (hl), a 
21db			;	dec hl 
21db			;	ld a, ' ' 
21db			;	ld (hl), a 
21db			;	dec hl 
21db			;	ld (hl), a 
21db			; 
21db			;	dec hl 
21db			;	ld (hl), a 
21db			; 
21db			; 
21db			;	FORTH_DSP_POP  
21db			; 
21db			;	pop hl     
21db			;	push hl    ; save malloc area 
21db			; 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EX4" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			; 
21db			;	call forthparse 
21db			;	call forthexec 
21db			;	 
21db			;	pop hl 
21db			;	if DEBUG_FORTH_WORDS 
21db			;		DMARK "EX5" 
21db			;		CALLMONITOR 
21db			;	endif 
21db			; 
21db			;	if FORTH_ENABLE_FREE 
21db			;	call free 
21db			;	endif 
21db			; 
21db			;	if DEBUG_FORTH_WORDS 
21db			;		DMARK "EX6" 
21db			;		CALLMONITOR 
21db			;	endif 
21db			; 
21db			;	pop bc 
21db			;	pop de 
21db			;	pop hl 
21db			;;	FORTH_RSP_POP	  
21db			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21db			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21db			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21db			; 
21db			;	if DEBUG_FORTH_WORDS 
21db			;		DMARK "EX7" 
21db			;		CALLMONITOR 
21db			;	endif 
21db			;	NEXTW 
21db			 
21db			;.STKEXEC: 
21db			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21db			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21db			; 
21db			; 
21db			;		if DEBUG_FORTH_WORDS_KEY 
21db			;			DMARK "STX" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			; 
21db			;	FORTH_DSP_VALUEHL 
21db			; 
21db			;	ld (store_tmp1), hl    ; count 
21db			; 
21db			;	FORTH_DSP_POP 
21db			;.stkexec1: 
21db			;	ld hl, (store_tmp1)   ; count 
21db			;	ld a, 0 
21db			;	cp l 
21db			;	ret z 
21db			; 
21db			;	dec hl 
21db			;	ld (store_tmp1), hl    ; count 
21db			;	 
21db			;	FORTH_DSP_VALUEHL 
21db			;	push hl 
21db			;	 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EXp" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;	FORTH_DSP_POP 
21db			; 
21db			;	call strlenz 
21db			;	inc hl   ; include zero term to copy 
21db			;	inc hl   ; include zero term to copy 
21db			;	inc hl   ; include zero term to copy 
21db			;	ld b,0 
21db			;	ld c,l 
21db			;	pop hl 
21db			;	ld de, execscratch 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EX3" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;	ldir 
21db			; 
21db			; 
21db			;	ld hl, execscratch 
21db			; 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EXP" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			; 
21db			;	call forthparse 
21db			;	ld hl, execscratch 
21db			;		if DEBUG_FORTH_WORDS 
21db			;			DMARK "EXx" 
21db			;			CALLMONITOR 
21db			;		endif 
21db			;	call forthexec 
21db			; 
21db			;	jp .stkexec1 
21db			; 
21db			;	ret 
21db			 
21db			 
21db			.DUP: 
21db				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21db 17				db WORD_SYS_CORE+OPCODE_DUP             
21dc 51 22			dw .ZDUP            
21de 04				db 3 + 1 
21df .. 00			db "DUP",0              
21e3				endm 
# End of macro CWHEAD
21e3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21e3			 
21e3					if DEBUG_FORTH_WORDS_KEY 
21e3						DMARK "DUP" 
21e3 f5				push af  
21e4 3a f8 21			ld a, (.dmark)  
21e7 32 b4 fb			ld (debug_mark),a  
21ea 3a f9 21			ld a, (.dmark+1)  
21ed 32 b5 fb			ld (debug_mark+1),a  
21f0 3a fa 21			ld a, (.dmark+2)  
21f3 32 b6 fb			ld (debug_mark+2),a  
21f6 18 03			jr .pastdmark  
21f8 ..			.dmark: db "DUP"  
21fb f1			.pastdmark: pop af  
21fc			endm  
# End of macro DMARK
21fc						CALLMONITOR 
21fc cd 7e 16			call break_point_state  
21ff				endm  
# End of macro CALLMONITOR
21ff					endif 
21ff			 
21ff					FORTH_DSP 
21ff cd 98 1e			call macro_forth_dsp 
2202				endm 
# End of macro FORTH_DSP
2202			 
2202 7e					ld a, (HL) 
2203 fe 01				cp DS_TYPE_STR 
2205 20 25				jr nz, .dupinum 
2207			 
2207					; push another string 
2207			 
2207					FORTH_DSP_VALUEHL     		 
2207 cd d2 1e			call macro_dsp_valuehl 
220a				endm 
# End of macro FORTH_DSP_VALUEHL
220a			 
220a				if DEBUG_FORTH_WORDS 
220a					DMARK "DUs" 
220a f5				push af  
220b 3a 1f 22			ld a, (.dmark)  
220e 32 b4 fb			ld (debug_mark),a  
2211 3a 20 22			ld a, (.dmark+1)  
2214 32 b5 fb			ld (debug_mark+1),a  
2217 3a 21 22			ld a, (.dmark+2)  
221a 32 b6 fb			ld (debug_mark+2),a  
221d 18 03			jr .pastdmark  
221f ..			.dmark: db "DUs"  
2222 f1			.pastdmark: pop af  
2223			endm  
# End of macro DMARK
2223					CALLMONITOR 
2223 cd 7e 16			call break_point_state  
2226				endm  
# End of macro CALLMONITOR
2226				endif 
2226 cd 49 1d				call forth_push_str 
2229			 
2229					NEXTW 
2229 c3 44 20			jp macro_next 
222c				endm 
# End of macro NEXTW
222c			 
222c			 
222c			.dupinum: 
222c					 
222c			 
222c			 
222c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
222c cd d2 1e			call macro_dsp_valuehl 
222f				endm 
# End of macro FORTH_DSP_VALUEHL
222f			 
222f				; TODO add floating point number detection 
222f			 
222f				if DEBUG_FORTH_WORDS 
222f					DMARK "DUi" 
222f f5				push af  
2230 3a 44 22			ld a, (.dmark)  
2233 32 b4 fb			ld (debug_mark),a  
2236 3a 45 22			ld a, (.dmark+1)  
2239 32 b5 fb			ld (debug_mark+1),a  
223c 3a 46 22			ld a, (.dmark+2)  
223f 32 b6 fb			ld (debug_mark+2),a  
2242 18 03			jr .pastdmark  
2244 ..			.dmark: db "DUi"  
2247 f1			.pastdmark: pop af  
2248			endm  
# End of macro DMARK
2248					CALLMONITOR 
2248 cd 7e 16			call break_point_state  
224b				endm  
# End of macro CALLMONITOR
224b				endif 
224b			 
224b cd db 1c				call forth_push_numhl 
224e					NEXTW 
224e c3 44 20			jp macro_next 
2251				endm 
# End of macro NEXTW
2251			.ZDUP: 
2251				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2251 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2252 89 22			dw .SWAP            
2254 05				db 4 + 1 
2255 .. 00			db "?DUP",0              
225a				endm 
# End of macro CWHEAD
225a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
225a			 
225a					if DEBUG_FORTH_WORDS_KEY 
225a						DMARK "qDU" 
225a f5				push af  
225b 3a 6f 22			ld a, (.dmark)  
225e 32 b4 fb			ld (debug_mark),a  
2261 3a 70 22			ld a, (.dmark+1)  
2264 32 b5 fb			ld (debug_mark+1),a  
2267 3a 71 22			ld a, (.dmark+2)  
226a 32 b6 fb			ld (debug_mark+2),a  
226d 18 03			jr .pastdmark  
226f ..			.dmark: db "qDU"  
2272 f1			.pastdmark: pop af  
2273			endm  
# End of macro DMARK
2273						CALLMONITOR 
2273 cd 7e 16			call break_point_state  
2276				endm  
# End of macro CALLMONITOR
2276					endif 
2276					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2276 cd d2 1e			call macro_dsp_valuehl 
2279				endm 
# End of macro FORTH_DSP_VALUEHL
2279			 
2279 e5					push hl 
227a			 
227a					; is it a zero? 
227a			 
227a 3e 00				ld a, 0 
227c 84					add h 
227d 85					add l 
227e			 
227e e1					pop hl 
227f			 
227f fe 00				cp 0 
2281 28 03				jr z, .dup2orig 
2283			 
2283			 
2283 cd db 1c				call forth_push_numhl 
2286			 
2286			 
2286				; TODO add floating point number detection 
2286			 
2286			.dup2orig: 
2286			 
2286					NEXTW 
2286 c3 44 20			jp macro_next 
2289				endm 
# End of macro NEXTW
2289			.SWAP: 
2289				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2289 18				db WORD_SYS_CORE+OPCODE_SWAP             
228a c8 22			dw .COLN            
228c 05				db 4 + 1 
228d .. 00			db "SWAP",0              
2292				endm 
# End of macro CWHEAD
2292			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2292					if DEBUG_FORTH_WORDS_KEY 
2292						DMARK "SWP" 
2292 f5				push af  
2293 3a a7 22			ld a, (.dmark)  
2296 32 b4 fb			ld (debug_mark),a  
2299 3a a8 22			ld a, (.dmark+1)  
229c 32 b5 fb			ld (debug_mark+1),a  
229f 3a a9 22			ld a, (.dmark+2)  
22a2 32 b6 fb			ld (debug_mark+2),a  
22a5 18 03			jr .pastdmark  
22a7 ..			.dmark: db "SWP"  
22aa f1			.pastdmark: pop af  
22ab			endm  
# End of macro DMARK
22ab						CALLMONITOR 
22ab cd 7e 16			call break_point_state  
22ae				endm  
# End of macro CALLMONITOR
22ae					endif 
22ae			 
22ae					FORTH_DSP_VALUEHL 
22ae cd d2 1e			call macro_dsp_valuehl 
22b1				endm 
# End of macro FORTH_DSP_VALUEHL
22b1 e5					push hl     ; w2 
22b2			 
22b2					FORTH_DSP_POP 
22b2 cd 8a 1f			call macro_forth_dsp_pop 
22b5				endm 
# End of macro FORTH_DSP_POP
22b5			 
22b5					FORTH_DSP_VALUEHL 
22b5 cd d2 1e			call macro_dsp_valuehl 
22b8				endm 
# End of macro FORTH_DSP_VALUEHL
22b8			 
22b8					FORTH_DSP_POP 
22b8 cd 8a 1f			call macro_forth_dsp_pop 
22bb				endm 
# End of macro FORTH_DSP_POP
22bb			 
22bb d1					pop de     ; w2	, hl = w1 
22bc			 
22bc eb					ex de, hl 
22bd d5					push de 
22be			 
22be cd db 1c				call forth_push_numhl 
22c1			 
22c1 e1					pop hl 
22c2			 
22c2 cd db 1c				call forth_push_numhl 
22c5					 
22c5			 
22c5					NEXTW 
22c5 c3 44 20			jp macro_next 
22c8				endm 
# End of macro NEXTW
22c8			.COLN: 
22c8				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22c8 19				db WORD_SYS_CORE+OPCODE_COLN             
22c9 54 24			dw .SCOLN            
22cb 02				db 1 + 1 
22cc .. 00			db ":",0              
22ce				endm 
# End of macro CWHEAD
22ce			; | : ( -- )         Create new word | DONE 
22ce			 
22ce					if DEBUG_FORTH_WORDS_KEY 
22ce						DMARK "CLN" 
22ce f5				push af  
22cf 3a e3 22			ld a, (.dmark)  
22d2 32 b4 fb			ld (debug_mark),a  
22d5 3a e4 22			ld a, (.dmark+1)  
22d8 32 b5 fb			ld (debug_mark+1),a  
22db 3a e5 22			ld a, (.dmark+2)  
22de 32 b6 fb			ld (debug_mark+2),a  
22e1 18 03			jr .pastdmark  
22e3 ..			.dmark: db "CLN"  
22e6 f1			.pastdmark: pop af  
22e7			endm  
# End of macro DMARK
22e7						CALLMONITOR 
22e7 cd 7e 16			call break_point_state  
22ea				endm  
# End of macro CALLMONITOR
22ea					endif 
22ea				STACKFRAME OFF $8efe $989f 
22ea				if DEBUG_STACK_IMB 
22ea					if OFF 
22ea						exx 
22ea						ld de, $8efe 
22ea						ld a, d 
22ea						ld hl, curframe 
22ea						call hexout 
22ea						ld a, e 
22ea						ld hl, curframe+2 
22ea						call hexout 
22ea						ld hl, $8efe 
22ea						push hl 
22ea						ld hl, $989f 
22ea						push hl 
22ea						exx 
22ea					endif 
22ea				endif 
22ea			endm 
# End of macro STACKFRAME
22ea				; get parser buffer length  of new word 
22ea			 
22ea				 
22ea			 
22ea					; move tok past this to start of name defintition 
22ea					; TODO get word to define 
22ea					; TODO Move past word token 
22ea					; TODO get length of string up to the ';' 
22ea			 
22ea 2a 9b f2			ld hl, (os_tok_ptr) 
22ed 23				inc hl 
22ee 23				inc hl 
22ef			 
22ef 3e 3b			ld a, ';' 
22f1 cd 6a 11			call strlent 
22f4			 
22f4 7d				ld a,l 
22f5 32 96 ef			ld (os_new_parse_len), a 
22f8			 
22f8			 
22f8			if DEBUG_FORTH_UWORD 
22f8 ed 5b 9b f2		ld de, (os_tok_ptr) 
22fc						DMARK ":01" 
22fc f5				push af  
22fd 3a 11 23			ld a, (.dmark)  
2300 32 b4 fb			ld (debug_mark),a  
2303 3a 12 23			ld a, (.dmark+1)  
2306 32 b5 fb			ld (debug_mark+1),a  
2309 3a 13 23			ld a, (.dmark+2)  
230c 32 b6 fb			ld (debug_mark+2),a  
230f 18 03			jr .pastdmark  
2311 ..			.dmark: db ":01"  
2314 f1			.pastdmark: pop af  
2315			endm  
# End of macro DMARK
2315				CALLMONITOR 
2315 cd 7e 16			call break_point_state  
2318				endm  
# End of macro CALLMONITOR
2318			endif 
2318			 
2318			; 
2318			;  new word memory layout: 
2318			;  
2318			;    : adg 6666 ;  
2318			; 
2318			;    db   1     ; user defined word  
2318 23				inc hl    
2319			;    dw   sysdict 
2319 23				inc hl 
231a 23				inc hl 
231b			;    db <word len>+1 (for null) 
231b 23				inc hl 
231c			;    db .... <word> 
231c			; 
231c			 
231c 23				inc hl    ; some extras for the word preamble before the above 
231d 23				inc hl 
231e 23				inc hl 
231f 23				inc hl 
2320 23				inc hl 
2321 23				inc hl 
2322 23				inc hl  
2323 23				inc hl 
2324 23				inc hl 
2325 23				inc hl 
2326 23				inc hl 
2327 23				inc hl 
2328 23				inc hl 
2329 23				inc hl     ; TODO how many do we really need?     maybe only 6 
232a			;       exec word buffer 
232a			;	<ptr word>   
232a 23				inc hl 
232b 23				inc hl 
232c			;       <word list><null term> 7F final term 
232c			 
232c			 
232c			if DEBUG_FORTH_UWORD 
232c						DMARK ":02" 
232c f5				push af  
232d 3a 41 23			ld a, (.dmark)  
2330 32 b4 fb			ld (debug_mark),a  
2333 3a 42 23			ld a, (.dmark+1)  
2336 32 b5 fb			ld (debug_mark+1),a  
2339 3a 43 23			ld a, (.dmark+2)  
233c 32 b6 fb			ld (debug_mark+2),a  
233f 18 03			jr .pastdmark  
2341 ..			.dmark: db ":02"  
2344 f1			.pastdmark: pop af  
2345			endm  
# End of macro DMARK
2345				CALLMONITOR 
2345 cd 7e 16			call break_point_state  
2348				endm  
# End of macro CALLMONITOR
2348			endif 
2348			 
2348				 
2348					; malloc the size 
2348			 
2348 cd c8 11				call malloc 
234b 22 98 ef				ld (os_new_malloc), hl     ; save malloc start 
234e			 
234e			;    db   1     ; user defined word  
234e 3e 01				ld a, WORD_SYS_UWORD  
2350 77					ld (hl), a 
2351				 
2351 23				inc hl    
2352			;    dw   sysdict 
2352 11 9c 21			ld de, sysdict       ; continue on with the scan to the system dict 
2355 73				ld (hl), e 
2356 23				inc hl 
2357 72				ld (hl), d 
2358 23				inc hl 
2359			 
2359			 
2359			;    Setup dict word 
2359			 
2359 23				inc hl 
235a 22 92 ef			ld (os_new_work_ptr), hl     ; save start of dict word  
235d			 
235d				; 1. get length of dict word 
235d			 
235d			 
235d 2a 9b f2			ld hl, (os_tok_ptr) 
2360 23				inc hl 
2361 23				inc hl    ; position to start of dict word 
2362 3e 00			ld a, 0 
2364 cd 6a 11			call strlent 
2367			 
2367			 
2367 23				inc hl    ; to include null??? 
2368			 
2368				; write length of dict word 
2368			 
2368 ed 5b 92 ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
236c 1b				dec de 
236d eb				ex de, hl 
236e 73				ld (hl), e 
236f eb				ex de, hl 
2370			 
2370				 
2370			 
2370				; copy  
2370 4d				ld c, l 
2371 06 00			ld b, 0 
2373 ed 5b 92 ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2377 2a 9b f2			ld hl, (os_tok_ptr) 
237a 23				inc hl 
237b 23				inc hl    ; position to start of dict word 
237c				 
237c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
237c				 
237c				; TODO need to convert word to upper case 
237c			 
237c			ucasetok:	 
237c 7e				ld a,(hl) 
237d cd 56 11			call toUpper 
2380 77				ld (hl),a 
2381 ed a0			ldi 
2383 f2 7c 23		 	jp p, ucasetok 
2386			 
2386			 
2386			 
2386				; de now points to start of where the word body code should be placed 
2386 ed 53 92 ef		ld (os_new_work_ptr), de 
238a				; hl now points to the words to throw at forthexec which needs to be copied 
238a 22 90 ef			ld (os_new_src_ptr), hl 
238d			 
238d				; TODO add 'call to forthexec' 
238d			 
238d			if DEBUG_FORTH_UWORD 
238d c5				push bc 
238e ed 4b 98 ef		ld bc, (os_new_malloc) 
2392						DMARK ":0x" 
2392 f5				push af  
2393 3a a7 23			ld a, (.dmark)  
2396 32 b4 fb			ld (debug_mark),a  
2399 3a a8 23			ld a, (.dmark+1)  
239c 32 b5 fb			ld (debug_mark+1),a  
239f 3a a9 23			ld a, (.dmark+2)  
23a2 32 b6 fb			ld (debug_mark+2),a  
23a5 18 03			jr .pastdmark  
23a7 ..			.dmark: db ":0x"  
23aa f1			.pastdmark: pop af  
23ab			endm  
# End of macro DMARK
23ab				CALLMONITOR 
23ab cd 7e 16			call break_point_state  
23ae				endm  
# End of macro CALLMONITOR
23ae c1				pop bc 
23af			endif 
23af			 
23af			 
23af				; create word preamble which should be: 
23af			 
23af			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23af			 
23af				;    ld hl, <word code> 
23af				;    jp user_exec 
23af			        ;    <word code bytes> 
23af			 
23af			 
23af			;	inc de     ; TODO ??? or are we already past the word's null 
23af eb				ex de, hl 
23b0			 
23b0 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23b2			 
23b2 23				inc hl 
23b3 22 8c ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23b6 23				inc hl 
23b7			 
23b7 23				inc hl 
23b8 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23ba			 
23ba 01 0b 51			ld bc, user_exec 
23bd 23				inc hl 
23be 71				ld (hl), c     ; poke address of user_exec 
23bf 23				inc hl 
23c0 70				ld (hl), b     
23c1			 ; 
23c1			;	inc hl 
23c1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23c1			; 
23c1			; 
23c1			;	ld bc, macro_forth_rsp_next 
23c1			;	inc hl 
23c1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23c1			;	inc hl 
23c1			;	ld (hl), b     
23c1			 ; 
23c1			;	inc hl 
23c1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23c1			; 
23c1			; 
23c1			;	inc hl 
23c1			;	ld bc, forthexec 
23c1			;	ld (hl), c     ; poke address of forthexec 
23c1			;	inc hl 
23c1			;	ld (hl), b      
23c1			; 
23c1			;	inc hl 
23c1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23c1			; 
23c1			;	ld bc, user_dict_next 
23c1			;	inc hl 
23c1			;	ld (hl), c     ; poke address of forthexec 
23c1			;	inc hl 
23c1			;	ld (hl), b      
23c1			 
23c1				; hl is now where we need to copy the word byte data to save this 
23c1			 
23c1 23				inc hl 
23c2 22 8e ef			ld (os_new_exec), hl 
23c5				 
23c5				; copy definition 
23c5			 
23c5 eb				ex de, hl 
23c6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23c6			;	inc de    ; skip the PC for this parse 
23c6 3a 96 ef			ld a, (os_new_parse_len) 
23c9 4f				ld c, a 
23ca 06 00			ld b, 0 
23cc ed b0			ldir		 ; copy defintion 
23ce			 
23ce			 
23ce				; poke the address of where the new word bytes live for forthexec 
23ce			 
23ce 2a 8c ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23d1			 
23d1 ed 5b 8e ef		ld de, (os_new_exec)      
23d5				 
23d5 73				ld (hl), e 
23d6 23				inc hl 
23d7 72				ld (hl), d 
23d8			 
23d8					; TODO copy last user dict word next link to this word 
23d8					; TODO update last user dict word to point to this word 
23d8			; 
23d8			; hl f923 de 812a ; bc 811a 
23d8			 
23d8			if DEBUG_FORTH_UWORD 
23d8 c5				push bc 
23d9 ed 4b 98 ef		ld bc, (os_new_malloc) 
23dd						DMARK ":0A" 
23dd f5				push af  
23de 3a f2 23			ld a, (.dmark)  
23e1 32 b4 fb			ld (debug_mark),a  
23e4 3a f3 23			ld a, (.dmark+1)  
23e7 32 b5 fb			ld (debug_mark+1),a  
23ea 3a f4 23			ld a, (.dmark+2)  
23ed 32 b6 fb			ld (debug_mark+2),a  
23f0 18 03			jr .pastdmark  
23f2 ..			.dmark: db ":0A"  
23f5 f1			.pastdmark: pop af  
23f6			endm  
# End of macro DMARK
23f6				CALLMONITOR 
23f6 cd 7e 16			call break_point_state  
23f9				endm  
# End of macro CALLMONITOR
23f9 c1				pop bc 
23fa			endif 
23fa			if DEBUG_FORTH_UWORD 
23fa c5				push bc 
23fb ed 4b 98 ef		ld bc, (os_new_malloc) 
23ff 03				inc bc 
2400 03				inc bc 
2401 03				inc bc 
2402 03				inc bc 
2403 03				inc bc 
2404 03				inc bc 
2405 03				inc bc 
2406 03				inc bc 
2407			 
2407						DMARK ":0B" 
2407 f5				push af  
2408 3a 1c 24			ld a, (.dmark)  
240b 32 b4 fb			ld (debug_mark),a  
240e 3a 1d 24			ld a, (.dmark+1)  
2411 32 b5 fb			ld (debug_mark+1),a  
2414 3a 1e 24			ld a, (.dmark+2)  
2417 32 b6 fb			ld (debug_mark+2),a  
241a 18 03			jr .pastdmark  
241c ..			.dmark: db ":0B"  
241f f1			.pastdmark: pop af  
2420			endm  
# End of macro DMARK
2420				CALLMONITOR 
2420 cd 7e 16			call break_point_state  
2423				endm  
# End of macro CALLMONITOR
2423 c1				pop bc 
2424			endif 
2424			 
2424			; update word dict linked list for new word 
2424			 
2424			 
2424 2a 97 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2427 23			inc hl     ; move to next work linked list ptr 
2428			 
2428 ed 5b 98 ef	ld de, (os_new_malloc)		 ; new next word 
242c 73			ld (hl), e 
242d 23			inc hl 
242e 72			ld (hl), d 
242f			 
242f			if DEBUG_FORTH_UWORD 
242f ed 4b 97 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2433			endif 
2433			 
2433 ed 53 97 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
2437			 
2437			 
2437			if DEBUG_FORTH_UWORD 
2437						DMARK ":0+" 
2437 f5				push af  
2438 3a 4c 24			ld a, (.dmark)  
243b 32 b4 fb			ld (debug_mark),a  
243e 3a 4d 24			ld a, (.dmark+1)  
2441 32 b5 fb			ld (debug_mark+1),a  
2444 3a 4e 24			ld a, (.dmark+2)  
2447 32 b6 fb			ld (debug_mark+2),a  
244a 18 03			jr .pastdmark  
244c ..			.dmark: db ":0+"  
244f f1			.pastdmark: pop af  
2450			endm  
# End of macro DMARK
2450				CALLMONITOR 
2450 cd 7e 16			call break_point_state  
2453				endm  
# End of macro CALLMONITOR
2453			endif 
2453			 
2453				STACKFRAMECHK OFF $8efe $989f 
2453				if DEBUG_STACK_IMB 
2453					if OFF 
2453						exx 
2453						ld hl, $989f 
2453						pop de   ; $989f 
2453						call cmp16 
2453						jr nz, .spnosame 
2453						ld hl, $8efe 
2453						pop de   ; $8efe 
2453						call cmp16 
2453						jr z, .spfrsame 
2453						.spnosame: call showsperror 
2453						.spfrsame: nop 
2453						exx 
2453					endif 
2453				endif 
2453			endm 
# End of macro STACKFRAMECHK
2453			 
2453 c9			ret    ; dont process any remaining parser tokens as they form new word 
2454			 
2454			 
2454			 
2454			 
2454			;		NEXT 
2454			.SCOLN: 
2454			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2454 06				db OPCODE_SCOLN 
2455 a0 24			dw .DROP 
2457 02				db 2 
2458 .. 00			db ";",0           
245a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
245a					if DEBUG_FORTH_WORDS_KEY 
245a						DMARK "SCN" 
245a f5				push af  
245b 3a 6f 24			ld a, (.dmark)  
245e 32 b4 fb			ld (debug_mark),a  
2461 3a 70 24			ld a, (.dmark+1)  
2464 32 b5 fb			ld (debug_mark+1),a  
2467 3a 71 24			ld a, (.dmark+2)  
246a 32 b6 fb			ld (debug_mark+2),a  
246d 18 03			jr .pastdmark  
246f ..			.dmark: db "SCN"  
2472 f1			.pastdmark: pop af  
2473			endm  
# End of macro DMARK
2473						CALLMONITOR 
2473 cd 7e 16			call break_point_state  
2476				endm  
# End of macro CALLMONITOR
2476					endif 
2476					FORTH_RSP_TOS 
2476 cd 99 1c			call macro_forth_rsp_tos 
2479				endm 
# End of macro FORTH_RSP_TOS
2479 e5					push hl 
247a					FORTH_RSP_POP 
247a cd a3 1c			call macro_forth_rsp_pop 
247d				endm 
# End of macro FORTH_RSP_POP
247d e1					pop hl 
247e			;		ex de,hl 
247e 22 9b f2				ld (os_tok_ptr),hl 
2481			 
2481			if DEBUG_FORTH_UWORD 
2481						DMARK "SCL" 
2481 f5				push af  
2482 3a 96 24			ld a, (.dmark)  
2485 32 b4 fb			ld (debug_mark),a  
2488 3a 97 24			ld a, (.dmark+1)  
248b 32 b5 fb			ld (debug_mark+1),a  
248e 3a 98 24			ld a, (.dmark+2)  
2491 32 b6 fb			ld (debug_mark+2),a  
2494 18 03			jr .pastdmark  
2496 ..			.dmark: db "SCL"  
2499 f1			.pastdmark: pop af  
249a			endm  
# End of macro DMARK
249a				CALLMONITOR 
249a cd 7e 16			call break_point_state  
249d				endm  
# End of macro CALLMONITOR
249d			endif 
249d					NEXTW 
249d c3 44 20			jp macro_next 
24a0				endm 
# End of macro NEXTW
24a0			 
24a0			.DROP: 
24a0				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24a0 1b				db WORD_SYS_CORE+OPCODE_DROP             
24a1 cb 24			dw .DUP2            
24a3 05				db 4 + 1 
24a4 .. 00			db "DROP",0              
24a9				endm 
# End of macro CWHEAD
24a9			; | DROP ( w -- )   drop the TOS item   | DONE 
24a9					if DEBUG_FORTH_WORDS_KEY 
24a9						DMARK "DRP" 
24a9 f5				push af  
24aa 3a be 24			ld a, (.dmark)  
24ad 32 b4 fb			ld (debug_mark),a  
24b0 3a bf 24			ld a, (.dmark+1)  
24b3 32 b5 fb			ld (debug_mark+1),a  
24b6 3a c0 24			ld a, (.dmark+2)  
24b9 32 b6 fb			ld (debug_mark+2),a  
24bc 18 03			jr .pastdmark  
24be ..			.dmark: db "DRP"  
24c1 f1			.pastdmark: pop af  
24c2			endm  
# End of macro DMARK
24c2						CALLMONITOR 
24c2 cd 7e 16			call break_point_state  
24c5				endm  
# End of macro CALLMONITOR
24c5					endif 
24c5					FORTH_DSP_POP 
24c5 cd 8a 1f			call macro_forth_dsp_pop 
24c8				endm 
# End of macro FORTH_DSP_POP
24c8					NEXTW 
24c8 c3 44 20			jp macro_next 
24cb				endm 
# End of macro NEXTW
24cb			.DUP2: 
24cb				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24cb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24cc 10 25			dw .DROP2            
24ce 05				db 4 + 1 
24cf .. 00			db "2DUP",0              
24d4				endm 
# End of macro CWHEAD
24d4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24d4					if DEBUG_FORTH_WORDS_KEY 
24d4						DMARK "2DU" 
24d4 f5				push af  
24d5 3a e9 24			ld a, (.dmark)  
24d8 32 b4 fb			ld (debug_mark),a  
24db 3a ea 24			ld a, (.dmark+1)  
24de 32 b5 fb			ld (debug_mark+1),a  
24e1 3a eb 24			ld a, (.dmark+2)  
24e4 32 b6 fb			ld (debug_mark+2),a  
24e7 18 03			jr .pastdmark  
24e9 ..			.dmark: db "2DU"  
24ec f1			.pastdmark: pop af  
24ed			endm  
# End of macro DMARK
24ed						CALLMONITOR 
24ed cd 7e 16			call break_point_state  
24f0				endm  
# End of macro CALLMONITOR
24f0					endif 
24f0					FORTH_DSP_VALUEHL 
24f0 cd d2 1e			call macro_dsp_valuehl 
24f3				endm 
# End of macro FORTH_DSP_VALUEHL
24f3 e5					push hl      ; 2 
24f4			 
24f4					FORTH_DSP_POP 
24f4 cd 8a 1f			call macro_forth_dsp_pop 
24f7				endm 
# End of macro FORTH_DSP_POP
24f7					 
24f7					FORTH_DSP_VALUEHL 
24f7 cd d2 1e			call macro_dsp_valuehl 
24fa				endm 
# End of macro FORTH_DSP_VALUEHL
24fa			;		push hl      ; 1 
24fa			 
24fa					FORTH_DSP_POP 
24fa cd 8a 1f			call macro_forth_dsp_pop 
24fd				endm 
# End of macro FORTH_DSP_POP
24fd			 
24fd			;		pop hl       ; 1 
24fd d1					pop de       ; 2 
24fe			 
24fe cd db 1c				call forth_push_numhl 
2501 eb					ex de, hl 
2502 cd db 1c				call forth_push_numhl 
2505			 
2505					 
2505 eb					ex de, hl 
2506			 
2506 cd db 1c				call forth_push_numhl 
2509 eb					ex de, hl 
250a cd db 1c				call forth_push_numhl 
250d			 
250d			 
250d					NEXTW 
250d c3 44 20			jp macro_next 
2510				endm 
# End of macro NEXTW
2510			.DROP2: 
2510				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2510 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2511 3f 25			dw .SWAP2            
2513 06				db 5 + 1 
2514 .. 00			db "2DROP",0              
251a				endm 
# End of macro CWHEAD
251a			; | 2DROP ( w w -- )    Double drop | DONE 
251a					if DEBUG_FORTH_WORDS_KEY 
251a						DMARK "2DR" 
251a f5				push af  
251b 3a 2f 25			ld a, (.dmark)  
251e 32 b4 fb			ld (debug_mark),a  
2521 3a 30 25			ld a, (.dmark+1)  
2524 32 b5 fb			ld (debug_mark+1),a  
2527 3a 31 25			ld a, (.dmark+2)  
252a 32 b6 fb			ld (debug_mark+2),a  
252d 18 03			jr .pastdmark  
252f ..			.dmark: db "2DR"  
2532 f1			.pastdmark: pop af  
2533			endm  
# End of macro DMARK
2533						CALLMONITOR 
2533 cd 7e 16			call break_point_state  
2536				endm  
# End of macro CALLMONITOR
2536					endif 
2536					FORTH_DSP_POP 
2536 cd 8a 1f			call macro_forth_dsp_pop 
2539				endm 
# End of macro FORTH_DSP_POP
2539					FORTH_DSP_POP 
2539 cd 8a 1f			call macro_forth_dsp_pop 
253c				endm 
# End of macro FORTH_DSP_POP
253c					NEXTW 
253c c3 44 20			jp macro_next 
253f				endm 
# End of macro NEXTW
253f			.SWAP2: 
253f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
253f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2540 68 25			dw .AT            
2542 06				db 5 + 1 
2543 .. 00			db "2SWAP",0              
2549				endm 
# End of macro CWHEAD
2549			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2549					if DEBUG_FORTH_WORDS_KEY 
2549						DMARK "2SW" 
2549 f5				push af  
254a 3a 5e 25			ld a, (.dmark)  
254d 32 b4 fb			ld (debug_mark),a  
2550 3a 5f 25			ld a, (.dmark+1)  
2553 32 b5 fb			ld (debug_mark+1),a  
2556 3a 60 25			ld a, (.dmark+2)  
2559 32 b6 fb			ld (debug_mark+2),a  
255c 18 03			jr .pastdmark  
255e ..			.dmark: db "2SW"  
2561 f1			.pastdmark: pop af  
2562			endm  
# End of macro DMARK
2562						CALLMONITOR 
2562 cd 7e 16			call break_point_state  
2565				endm  
# End of macro CALLMONITOR
2565					endif 
2565					NEXTW 
2565 c3 44 20			jp macro_next 
2568				endm 
# End of macro NEXTW
2568			.AT: 
2568				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2568 1f				db WORD_SYS_CORE+OPCODE_AT             
2569 9a 25			dw .CAT            
256b 02				db 1 + 1 
256c .. 00			db "@",0              
256e				endm 
# End of macro CWHEAD
256e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
256e			 
256e					if DEBUG_FORTH_WORDS_KEY 
256e						DMARK "AT." 
256e f5				push af  
256f 3a 83 25			ld a, (.dmark)  
2572 32 b4 fb			ld (debug_mark),a  
2575 3a 84 25			ld a, (.dmark+1)  
2578 32 b5 fb			ld (debug_mark+1),a  
257b 3a 85 25			ld a, (.dmark+2)  
257e 32 b6 fb			ld (debug_mark+2),a  
2581 18 03			jr .pastdmark  
2583 ..			.dmark: db "AT."  
2586 f1			.pastdmark: pop af  
2587			endm  
# End of macro DMARK
2587						CALLMONITOR 
2587 cd 7e 16			call break_point_state  
258a				endm  
# End of macro CALLMONITOR
258a					endif 
258a			.getbyteat:	 
258a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
258a cd d2 1e			call macro_dsp_valuehl 
258d				endm 
# End of macro FORTH_DSP_VALUEHL
258d					 
258d			;		push hl 
258d				 
258d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
258d cd 8a 1f			call macro_forth_dsp_pop 
2590				endm 
# End of macro FORTH_DSP_POP
2590			 
2590			;		pop hl 
2590			 
2590 7e					ld a, (hl) 
2591			 
2591 6f					ld l, a 
2592 26 00				ld h, 0 
2594 cd db 1c				call forth_push_numhl 
2597			 
2597					NEXTW 
2597 c3 44 20			jp macro_next 
259a				endm 
# End of macro NEXTW
259a			.CAT: 
259a				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
259a 20				db WORD_SYS_CORE+OPCODE_CAT             
259b c3 25			dw .BANG            
259d 03				db 2 + 1 
259e .. 00			db "C@",0              
25a1				endm 
# End of macro CWHEAD
25a1			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25a1					if DEBUG_FORTH_WORDS_KEY 
25a1						DMARK "CAA" 
25a1 f5				push af  
25a2 3a b6 25			ld a, (.dmark)  
25a5 32 b4 fb			ld (debug_mark),a  
25a8 3a b7 25			ld a, (.dmark+1)  
25ab 32 b5 fb			ld (debug_mark+1),a  
25ae 3a b8 25			ld a, (.dmark+2)  
25b1 32 b6 fb			ld (debug_mark+2),a  
25b4 18 03			jr .pastdmark  
25b6 ..			.dmark: db "CAA"  
25b9 f1			.pastdmark: pop af  
25ba			endm  
# End of macro DMARK
25ba						CALLMONITOR 
25ba cd 7e 16			call break_point_state  
25bd				endm  
# End of macro CALLMONITOR
25bd					endif 
25bd c3 8a 25				jp .getbyteat 
25c0					NEXTW 
25c0 c3 44 20			jp macro_next 
25c3				endm 
# End of macro NEXTW
25c3			.BANG: 
25c3				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25c3 21				db WORD_SYS_CORE+OPCODE_BANG             
25c4 f9 25			dw .CBANG            
25c6 02				db 1 + 1 
25c7 .. 00			db "!",0              
25c9				endm 
# End of macro CWHEAD
25c9			; | ! ( x w -- ) Store x at address w      | DONE 
25c9					if DEBUG_FORTH_WORDS_KEY 
25c9						DMARK "BNG" 
25c9 f5				push af  
25ca 3a de 25			ld a, (.dmark)  
25cd 32 b4 fb			ld (debug_mark),a  
25d0 3a df 25			ld a, (.dmark+1)  
25d3 32 b5 fb			ld (debug_mark+1),a  
25d6 3a e0 25			ld a, (.dmark+2)  
25d9 32 b6 fb			ld (debug_mark+2),a  
25dc 18 03			jr .pastdmark  
25de ..			.dmark: db "BNG"  
25e1 f1			.pastdmark: pop af  
25e2			endm  
# End of macro DMARK
25e2						CALLMONITOR 
25e2 cd 7e 16			call break_point_state  
25e5				endm  
# End of macro CALLMONITOR
25e5					endif 
25e5			 
25e5			.storebyteat:		 
25e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25e5 cd d2 1e			call macro_dsp_valuehl 
25e8				endm 
# End of macro FORTH_DSP_VALUEHL
25e8					 
25e8 e5					push hl 
25e9				 
25e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25e9 cd 8a 1f			call macro_forth_dsp_pop 
25ec				endm 
# End of macro FORTH_DSP_POP
25ec			 
25ec					; get byte to poke 
25ec			 
25ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ec cd d2 1e			call macro_dsp_valuehl 
25ef				endm 
# End of macro FORTH_DSP_VALUEHL
25ef e5					push hl 
25f0			 
25f0			 
25f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f0 cd 8a 1f			call macro_forth_dsp_pop 
25f3				endm 
# End of macro FORTH_DSP_POP
25f3			 
25f3			 
25f3 d1					pop de 
25f4 e1					pop hl 
25f5			 
25f5 73					ld (hl),e 
25f6			 
25f6			 
25f6					NEXTW 
25f6 c3 44 20			jp macro_next 
25f9				endm 
# End of macro NEXTW
25f9			.CBANG: 
25f9				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25f9 22				db WORD_SYS_CORE+OPCODE_CBANG             
25fa 22 26			dw .SCALL            
25fc 03				db 2 + 1 
25fd .. 00			db "C!",0              
2600				endm 
# End of macro CWHEAD
2600			; | C!  ( x w -- ) Store x at address w  | DONE 
2600					if DEBUG_FORTH_WORDS_KEY 
2600						DMARK "CBA" 
2600 f5				push af  
2601 3a 15 26			ld a, (.dmark)  
2604 32 b4 fb			ld (debug_mark),a  
2607 3a 16 26			ld a, (.dmark+1)  
260a 32 b5 fb			ld (debug_mark+1),a  
260d 3a 17 26			ld a, (.dmark+2)  
2610 32 b6 fb			ld (debug_mark+2),a  
2613 18 03			jr .pastdmark  
2615 ..			.dmark: db "CBA"  
2618 f1			.pastdmark: pop af  
2619			endm  
# End of macro DMARK
2619						CALLMONITOR 
2619 cd 7e 16			call break_point_state  
261c				endm  
# End of macro CALLMONITOR
261c					endif 
261c c3 e5 25				jp .storebyteat 
261f					NEXTW 
261f c3 44 20			jp macro_next 
2622				endm 
# End of macro NEXTW
2622			.SCALL: 
2622				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2622 23				db WORD_SYS_CORE+OPCODE_SCALL             
2623 56 26			dw .DEPTH            
2625 05				db 4 + 1 
2626 .. 00			db "CALL",0              
262b				endm 
# End of macro CWHEAD
262b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
262b					if DEBUG_FORTH_WORDS_KEY 
262b						DMARK "CLL" 
262b f5				push af  
262c 3a 40 26			ld a, (.dmark)  
262f 32 b4 fb			ld (debug_mark),a  
2632 3a 41 26			ld a, (.dmark+1)  
2635 32 b5 fb			ld (debug_mark+1),a  
2638 3a 42 26			ld a, (.dmark+2)  
263b 32 b6 fb			ld (debug_mark+2),a  
263e 18 03			jr .pastdmark  
2640 ..			.dmark: db "CLL"  
2643 f1			.pastdmark: pop af  
2644			endm  
# End of macro DMARK
2644						CALLMONITOR 
2644 cd 7e 16			call break_point_state  
2647				endm  
# End of macro CALLMONITOR
2647					endif 
2647			 
2647					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2647 cd d2 1e			call macro_dsp_valuehl 
264a				endm 
# End of macro FORTH_DSP_VALUEHL
264a			 
264a			;		push hl 
264a			 
264a					; destroy value TOS 
264a			 
264a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
264a cd 8a 1f			call macro_forth_dsp_pop 
264d				endm 
# End of macro FORTH_DSP_POP
264d			 
264d						 
264d			;		pop hl 
264d			 
264d					; how to do a call with hl???? save SP? 
264d cd ed 1f				call forth_call_hl 
2650			 
2650			 
2650					; TODO push value back onto stack for another op etc 
2650			 
2650 cd db 1c				call forth_push_numhl 
2653					NEXTW 
2653 c3 44 20			jp macro_next 
2656				endm 
# End of macro NEXTW
2656			.DEPTH: 
2656				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2656 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2657 93 26			dw .OVER            
2659 06				db 5 + 1 
265a .. 00			db "DEPTH",0              
2660				endm 
# End of macro CWHEAD
2660			; | DEPTH ( -- u ) Push count of stack | DONE 
2660					; take current TOS and remove from base value div by two to get count 
2660					if DEBUG_FORTH_WORDS_KEY 
2660						DMARK "DEP" 
2660 f5				push af  
2661 3a 75 26			ld a, (.dmark)  
2664 32 b4 fb			ld (debug_mark),a  
2667 3a 76 26			ld a, (.dmark+1)  
266a 32 b5 fb			ld (debug_mark+1),a  
266d 3a 77 26			ld a, (.dmark+2)  
2670 32 b6 fb			ld (debug_mark+2),a  
2673 18 03			jr .pastdmark  
2675 ..			.dmark: db "DEP"  
2678 f1			.pastdmark: pop af  
2679			endm  
# End of macro DMARK
2679						CALLMONITOR 
2679 cd 7e 16			call break_point_state  
267c				endm  
# End of macro CALLMONITOR
267c					endif 
267c			 
267c			 
267c 2a 87 f9			ld hl, (cli_data_sp) 
267f 11 01 f5			ld de, cli_data_stack 
2682 ed 52			sbc hl,de 
2684				 
2684				; div by size of stack item 
2684			 
2684 5d				ld e,l 
2685 0e 03			ld c, 3 
2687 cd 91 0c			call Div8 
268a			 
268a 6f				ld l,a 
268b 26 00			ld h,0 
268d			 
268d				;srl h 
268d				;rr l 
268d			 
268d cd db 1c				call forth_push_numhl 
2690					NEXTW 
2690 c3 44 20			jp macro_next 
2693				endm 
# End of macro NEXTW
2693			.OVER: 
2693				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2693 42				db WORD_SYS_CORE+46             
2694 da 26			dw .PAUSE            
2696 05				db 4 + 1 
2697 .. 00			db "OVER",0              
269c				endm 
# End of macro CWHEAD
269c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
269c					if DEBUG_FORTH_WORDS_KEY 
269c						DMARK "OVR" 
269c f5				push af  
269d 3a b1 26			ld a, (.dmark)  
26a0 32 b4 fb			ld (debug_mark),a  
26a3 3a b2 26			ld a, (.dmark+1)  
26a6 32 b5 fb			ld (debug_mark+1),a  
26a9 3a b3 26			ld a, (.dmark+2)  
26ac 32 b6 fb			ld (debug_mark+2),a  
26af 18 03			jr .pastdmark  
26b1 ..			.dmark: db "OVR"  
26b4 f1			.pastdmark: pop af  
26b5			endm  
# End of macro DMARK
26b5						CALLMONITOR 
26b5 cd 7e 16			call break_point_state  
26b8				endm  
# End of macro CALLMONITOR
26b8					endif 
26b8			 
26b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b8 cd d2 1e			call macro_dsp_valuehl 
26bb				endm 
# End of macro FORTH_DSP_VALUEHL
26bb e5					push hl    ; n2 
26bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26bc cd 8a 1f			call macro_forth_dsp_pop 
26bf				endm 
# End of macro FORTH_DSP_POP
26bf			 
26bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bf cd d2 1e			call macro_dsp_valuehl 
26c2				endm 
# End of macro FORTH_DSP_VALUEHL
26c2 e5					push hl    ; n1 
26c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c3 cd 8a 1f			call macro_forth_dsp_pop 
26c6				endm 
# End of macro FORTH_DSP_POP
26c6			 
26c6 d1					pop de     ; n1 
26c7 e1					pop hl     ; n2 
26c8			 
26c8 d5					push de 
26c9 e5					push hl 
26ca d5					push de 
26cb			 
26cb					; push back  
26cb			 
26cb e1					pop hl 
26cc cd db 1c				call forth_push_numhl 
26cf e1					pop hl 
26d0 cd db 1c				call forth_push_numhl 
26d3 e1					pop hl 
26d4 cd db 1c				call forth_push_numhl 
26d7					NEXTW 
26d7 c3 44 20			jp macro_next 
26da				endm 
# End of macro NEXTW
26da			 
26da			.PAUSE: 
26da				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26da 43				db WORD_SYS_CORE+47             
26db 0f 27			dw .PAUSES            
26dd 08				db 7 + 1 
26de .. 00			db "PAUSEMS",0              
26e6				endm 
# End of macro CWHEAD
26e6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26e6					if DEBUG_FORTH_WORDS_KEY 
26e6						DMARK "PMS" 
26e6 f5				push af  
26e7 3a fb 26			ld a, (.dmark)  
26ea 32 b4 fb			ld (debug_mark),a  
26ed 3a fc 26			ld a, (.dmark+1)  
26f0 32 b5 fb			ld (debug_mark+1),a  
26f3 3a fd 26			ld a, (.dmark+2)  
26f6 32 b6 fb			ld (debug_mark+2),a  
26f9 18 03			jr .pastdmark  
26fb ..			.dmark: db "PMS"  
26fe f1			.pastdmark: pop af  
26ff			endm  
# End of macro DMARK
26ff						CALLMONITOR 
26ff cd 7e 16			call break_point_state  
2702				endm  
# End of macro CALLMONITOR
2702					endif 
2702					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2702 cd d2 1e			call macro_dsp_valuehl 
2705				endm 
# End of macro FORTH_DSP_VALUEHL
2705			;		push hl    ; n2 
2705					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2705 cd 8a 1f			call macro_forth_dsp_pop 
2708				endm 
# End of macro FORTH_DSP_POP
2708			;		pop hl 
2708			 
2708 7d					ld a, l 
2709 cd 2f 0a				call aDelayInMS 
270c				       NEXTW 
270c c3 44 20			jp macro_next 
270f				endm 
# End of macro NEXTW
270f			.PAUSES:  
270f				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
270f 44				db WORD_SYS_CORE+48             
2710 7e 27			dw .ROT            
2712 06				db 5 + 1 
2713 .. 00			db "PAUSE",0              
2719				endm 
# End of macro CWHEAD
2719			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2719					if DEBUG_FORTH_WORDS_KEY 
2719						DMARK "PAU" 
2719 f5				push af  
271a 3a 2e 27			ld a, (.dmark)  
271d 32 b4 fb			ld (debug_mark),a  
2720 3a 2f 27			ld a, (.dmark+1)  
2723 32 b5 fb			ld (debug_mark+1),a  
2726 3a 30 27			ld a, (.dmark+2)  
2729 32 b6 fb			ld (debug_mark+2),a  
272c 18 03			jr .pastdmark  
272e ..			.dmark: db "PAU"  
2731 f1			.pastdmark: pop af  
2732			endm  
# End of macro DMARK
2732						CALLMONITOR 
2732 cd 7e 16			call break_point_state  
2735				endm  
# End of macro CALLMONITOR
2735					endif 
2735					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2735 cd d2 1e			call macro_dsp_valuehl 
2738				endm 
# End of macro FORTH_DSP_VALUEHL
2738			;		push hl    ; n2 
2738					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2738 cd 8a 1f			call macro_forth_dsp_pop 
273b				endm 
# End of macro FORTH_DSP_POP
273b			;		pop hl 
273b 45					ld b, l 
273c					if DEBUG_FORTH_WORDS 
273c						DMARK "PAU" 
273c f5				push af  
273d 3a 51 27			ld a, (.dmark)  
2740 32 b4 fb			ld (debug_mark),a  
2743 3a 52 27			ld a, (.dmark+1)  
2746 32 b5 fb			ld (debug_mark+1),a  
2749 3a 53 27			ld a, (.dmark+2)  
274c 32 b6 fb			ld (debug_mark+2),a  
274f 18 03			jr .pastdmark  
2751 ..			.dmark: db "PAU"  
2754 f1			.pastdmark: pop af  
2755			endm  
# End of macro DMARK
2755						CALLMONITOR 
2755 cd 7e 16			call break_point_state  
2758				endm  
# End of macro CALLMONITOR
2758					endif 
2758 c5			.pauses1:	push bc 
2759 cd 4a 0a				call delay1s 
275c c1					pop bc 
275d					if DEBUG_FORTH_WORDS 
275d						DMARK "PA1" 
275d f5				push af  
275e 3a 72 27			ld a, (.dmark)  
2761 32 b4 fb			ld (debug_mark),a  
2764 3a 73 27			ld a, (.dmark+1)  
2767 32 b5 fb			ld (debug_mark+1),a  
276a 3a 74 27			ld a, (.dmark+2)  
276d 32 b6 fb			ld (debug_mark+2),a  
2770 18 03			jr .pastdmark  
2772 ..			.dmark: db "PA1"  
2775 f1			.pastdmark: pop af  
2776			endm  
# End of macro DMARK
2776						CALLMONITOR 
2776 cd 7e 16			call break_point_state  
2779				endm  
# End of macro CALLMONITOR
2779					endif 
2779 10 dd				djnz .pauses1 
277b			 
277b				       NEXTW 
277b c3 44 20			jp macro_next 
277e				endm 
# End of macro NEXTW
277e			.ROT: 
277e				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
277e 45				db WORD_SYS_CORE+49             
277f cc 27			dw .UWORDS            
2781 04				db 3 + 1 
2782 .. 00			db "ROT",0              
2786				endm 
# End of macro CWHEAD
2786			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2786					if DEBUG_FORTH_WORDS_KEY 
2786						DMARK "ROT" 
2786 f5				push af  
2787 3a 9b 27			ld a, (.dmark)  
278a 32 b4 fb			ld (debug_mark),a  
278d 3a 9c 27			ld a, (.dmark+1)  
2790 32 b5 fb			ld (debug_mark+1),a  
2793 3a 9d 27			ld a, (.dmark+2)  
2796 32 b6 fb			ld (debug_mark+2),a  
2799 18 03			jr .pastdmark  
279b ..			.dmark: db "ROT"  
279e f1			.pastdmark: pop af  
279f			endm  
# End of macro DMARK
279f						CALLMONITOR 
279f cd 7e 16			call break_point_state  
27a2				endm  
# End of macro CALLMONITOR
27a2					endif 
27a2			 
27a2					FORTH_DSP_VALUEHL 
27a2 cd d2 1e			call macro_dsp_valuehl 
27a5				endm 
# End of macro FORTH_DSP_VALUEHL
27a5 e5					push hl    ; u3  
27a6			 
27a6					FORTH_DSP_POP 
27a6 cd 8a 1f			call macro_forth_dsp_pop 
27a9				endm 
# End of macro FORTH_DSP_POP
27a9			   
27a9					FORTH_DSP_VALUEHL 
27a9 cd d2 1e			call macro_dsp_valuehl 
27ac				endm 
# End of macro FORTH_DSP_VALUEHL
27ac e5					push hl     ; u2 
27ad			 
27ad					FORTH_DSP_POP 
27ad cd 8a 1f			call macro_forth_dsp_pop 
27b0				endm 
# End of macro FORTH_DSP_POP
27b0			 
27b0					FORTH_DSP_VALUEHL 
27b0 cd d2 1e			call macro_dsp_valuehl 
27b3				endm 
# End of macro FORTH_DSP_VALUEHL
27b3 e5					push hl     ; u1 
27b4			 
27b4					FORTH_DSP_POP 
27b4 cd 8a 1f			call macro_forth_dsp_pop 
27b7				endm 
# End of macro FORTH_DSP_POP
27b7			 
27b7 c1					pop bc      ; u1 
27b8 e1					pop hl      ; u2 
27b9 d1					pop de      ; u3 
27ba			 
27ba			 
27ba c5					push bc 
27bb d5					push de 
27bc e5					push hl 
27bd			 
27bd			 
27bd e1					pop hl 
27be cd db 1c				call forth_push_numhl 
27c1			 
27c1 e1					pop hl 
27c2 cd db 1c				call forth_push_numhl 
27c5			 
27c5 e1					pop hl 
27c6 cd db 1c				call forth_push_numhl 
27c9					 
27c9			 
27c9			 
27c9			 
27c9			 
27c9			 
27c9				       NEXTW 
27c9 c3 44 20			jp macro_next 
27cc				endm 
# End of macro NEXTW
27cc			 
27cc			.UWORDS: 
27cc				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27cc 50				db WORD_SYS_CORE+60             
27cd 8e 28			dw .BP            
27cf 07				db 6 + 1 
27d0 .. 00			db "UWORDS",0              
27d7				endm 
# End of macro CWHEAD
27d7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27d7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27d7			; | | Following the count are the individual words. 
27d7			; | | 
27d7			; | | e.g. UWORDS 
27d7			; | | BOX DIRLIST 2 
27d7			; | |  
27d7			; | | Can be used to save the words to storage via: 
27d7			; | | UWORDS $01 DO $01 APPEND LOOP 
27d7				if DEBUG_FORTH_WORDS_KEY 
27d7					DMARK "UWR" 
27d7 f5				push af  
27d8 3a ec 27			ld a, (.dmark)  
27db 32 b4 fb			ld (debug_mark),a  
27de 3a ed 27			ld a, (.dmark+1)  
27e1 32 b5 fb			ld (debug_mark+1),a  
27e4 3a ee 27			ld a, (.dmark+2)  
27e7 32 b6 fb			ld (debug_mark+2),a  
27ea 18 03			jr .pastdmark  
27ec ..			.dmark: db "UWR"  
27ef f1			.pastdmark: pop af  
27f0			endm  
# End of macro DMARK
27f0					CALLMONITOR 
27f0 cd 7e 16			call break_point_state  
27f3				endm  
# End of macro CALLMONITOR
27f3				endif 
27f3 21 00 80				ld hl, baseram 
27f6					;ld hl, baseusermem 
27f6 01 00 00				ld bc, 0    ; start a counter 
27f9			 
27f9				; skip dict stub 
27f9			 
27f9 cd 95 21				call forth_tok_next 
27fc			 
27fc			 
27fc			; while we have words to look for 
27fc			 
27fc 7e			.douscan:	ld a, (hl)      
27fd				if DEBUG_FORTH_WORDS 
27fd					DMARK "UWs" 
27fd f5				push af  
27fe 3a 12 28			ld a, (.dmark)  
2801 32 b4 fb			ld (debug_mark),a  
2804 3a 13 28			ld a, (.dmark+1)  
2807 32 b5 fb			ld (debug_mark+1),a  
280a 3a 14 28			ld a, (.dmark+2)  
280d 32 b6 fb			ld (debug_mark+2),a  
2810 18 03			jr .pastdmark  
2812 ..			.dmark: db "UWs"  
2815 f1			.pastdmark: pop af  
2816			endm  
# End of macro DMARK
2816					CALLMONITOR 
2816 cd 7e 16			call break_point_state  
2819				endm  
# End of macro CALLMONITOR
2819				endif 
2819 fe 00				cp WORD_SYS_END 
281b 28 4d				jr z, .udone 
281d fe 01				cp WORD_SYS_UWORD 
281f 20 44				jr nz, .nuword 
2821			 
2821				if DEBUG_FORTH_WORDS 
2821					DMARK "UWu" 
2821 f5				push af  
2822 3a 36 28			ld a, (.dmark)  
2825 32 b4 fb			ld (debug_mark),a  
2828 3a 37 28			ld a, (.dmark+1)  
282b 32 b5 fb			ld (debug_mark+1),a  
282e 3a 38 28			ld a, (.dmark+2)  
2831 32 b6 fb			ld (debug_mark+2),a  
2834 18 03			jr .pastdmark  
2836 ..			.dmark: db "UWu"  
2839 f1			.pastdmark: pop af  
283a			endm  
# End of macro DMARK
283a					CALLMONITOR 
283a cd 7e 16			call break_point_state  
283d				endm  
# End of macro CALLMONITOR
283d				endif 
283d					; we have a uword so push its name to the stack 
283d			 
283d e5				   	push hl  ; save so we can move to next dict block 
283e			 
283e					; skip opcode 
283e 23					inc hl  
283f					; skip next ptr 
283f 23					inc hl  
2840 23					inc hl 
2841					; skip len 
2841 23					inc hl 
2842				if DEBUG_FORTH_WORDS 
2842					DMARK "UWt" 
2842 f5				push af  
2843 3a 57 28			ld a, (.dmark)  
2846 32 b4 fb			ld (debug_mark),a  
2849 3a 58 28			ld a, (.dmark+1)  
284c 32 b5 fb			ld (debug_mark+1),a  
284f 3a 59 28			ld a, (.dmark+2)  
2852 32 b6 fb			ld (debug_mark+2),a  
2855 18 03			jr .pastdmark  
2857 ..			.dmark: db "UWt"  
285a f1			.pastdmark: pop af  
285b			endm  
# End of macro DMARK
285b					CALLMONITOR 
285b cd 7e 16			call break_point_state  
285e				endm  
# End of macro CALLMONITOR
285e				endif 
285e 03					inc bc 
285f			 
285f c5					push bc 
2860 cd 49 1d				call forth_push_str 
2863 c1					pop bc 
2864			 
2864 e1					pop hl 	 
2865			 
2865 cd 95 21		.nuword:	call forth_tok_next 
2868 18 92				jr .douscan  
286a			 
286a			.udone:		 ; push count of uwords found 
286a c5					push bc 
286b e1					pop hl 
286c			 
286c				if DEBUG_FORTH_WORDS 
286c					DMARK "UWc" 
286c f5				push af  
286d 3a 81 28			ld a, (.dmark)  
2870 32 b4 fb			ld (debug_mark),a  
2873 3a 82 28			ld a, (.dmark+1)  
2876 32 b5 fb			ld (debug_mark+1),a  
2879 3a 83 28			ld a, (.dmark+2)  
287c 32 b6 fb			ld (debug_mark+2),a  
287f 18 03			jr .pastdmark  
2881 ..			.dmark: db "UWc"  
2884 f1			.pastdmark: pop af  
2885			endm  
# End of macro DMARK
2885					CALLMONITOR 
2885 cd 7e 16			call break_point_state  
2888				endm  
# End of macro CALLMONITOR
2888				endif 
2888 cd db 1c				call forth_push_numhl 
288b			 
288b			 
288b				       NEXTW 
288b c3 44 20			jp macro_next 
288e				endm 
# End of macro NEXTW
288e			 
288e			.BP: 
288e				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
288e 54				db WORD_SYS_CORE+64             
288f c4 28			dw .MONITOR            
2891 03				db 2 + 1 
2892 .. 00			db "BP",0              
2895				endm 
# End of macro CWHEAD
2895			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2895			; | | $00 Will enable the break points within specific code paths 
2895			; | | $01 Will disable break points 
2895			; | |  
2895			; | | By default break points are off. Either the above can be used to enable them 
2895			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2895			; | | and on release of the pressed key a message will be disaplayed to notify 
2895			; | | that break points are enabled. Pressing any key will then continue boot process. 
2895					; get byte count 
2895					if DEBUG_FORTH_WORDS_KEY 
2895						DMARK "BP." 
2895 f5				push af  
2896 3a aa 28			ld a, (.dmark)  
2899 32 b4 fb			ld (debug_mark),a  
289c 3a ab 28			ld a, (.dmark+1)  
289f 32 b5 fb			ld (debug_mark+1),a  
28a2 3a ac 28			ld a, (.dmark+2)  
28a5 32 b6 fb			ld (debug_mark+2),a  
28a8 18 03			jr .pastdmark  
28aa ..			.dmark: db "BP."  
28ad f1			.pastdmark: pop af  
28ae			endm  
# End of macro DMARK
28ae						CALLMONITOR 
28ae cd 7e 16			call break_point_state  
28b1				endm  
# End of macro CALLMONITOR
28b1					endif 
28b1			 
28b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28b1 cd d2 1e			call macro_dsp_valuehl 
28b4				endm 
# End of macro FORTH_DSP_VALUEHL
28b4			 
28b4			;		push hl 
28b4			 
28b4					; destroy value TOS 
28b4			 
28b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b4 cd 8a 1f			call macro_forth_dsp_pop 
28b7				endm 
# End of macro FORTH_DSP_POP
28b7			 
28b7			;		pop hl 
28b7			 
28b7 3e 00				ld a,0 
28b9 bd					cp l 
28ba 28 02				jr z, .bpset 
28bc 3e 2a				ld a, '*' 
28be			 
28be 32 8b ef		.bpset:		ld (os_view_disable), a 
28c1			 
28c1			 
28c1					NEXTW 
28c1 c3 44 20			jp macro_next 
28c4				endm 
# End of macro NEXTW
28c4			 
28c4			 
28c4			.MONITOR: 
28c4				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28c4 55				db WORD_SYS_CORE+65             
28c5 f7 28			dw .MALLOC            
28c7 08				db 7 + 1 
28c8 .. 00			db "MONITOR",0              
28d0				endm 
# End of macro CWHEAD
28d0			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28d0			; | | At start the current various registers will be displayed with contents. 
28d0			; | | Top right corner will show the most recent debug marker seen. 
28d0			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28d0			; | | and the return stack pointer (RSP). 
28d0			; | | Pressing: 
28d0			; | |    1 - Initial screen 
28d0			; | |    2 - Display a data dump of HL 
28d0			; | |    3 - Display a data dump of DE 
28d0			; | |    4 - Display a data dump of BC 
28d0			; | |    5 - Display a data dump of HL 
28d0			; | |    6 - Display a data dump of DSP 
28d0			; | |    7 - Display a data dump of RSP 
28d0			; | |    8 - Display a data dump of what is at DSP 
28d0			; | |    9 - Display a data dump of what is at RSP 
28d0			; | |    0 - Exit monitor and continue running. This will also enable break points 
28d0			; | |    * - Disable break points 
28d0			; | |    # - Enter traditional monitor mode 
28d0			; | | 
28d0			; | | Monitor Mode 
28d0			; | | ------------ 
28d0			; | | A prompt of '>' will be shown for various commands: 
28d0			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28d0			; | |    C - Continue display a data dump from the last set address 
28d0			; | |    M xxxx - Set start of memory edit at address xx 
28d0			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28d0			; | |    Q - Return to previous 
28d0					if DEBUG_FORTH_WORDS_KEY 
28d0						DMARK "MON" 
28d0 f5				push af  
28d1 3a e5 28			ld a, (.dmark)  
28d4 32 b4 fb			ld (debug_mark),a  
28d7 3a e6 28			ld a, (.dmark+1)  
28da 32 b5 fb			ld (debug_mark+1),a  
28dd 3a e7 28			ld a, (.dmark+2)  
28e0 32 b6 fb			ld (debug_mark+2),a  
28e3 18 03			jr .pastdmark  
28e5 ..			.dmark: db "MON"  
28e8 f1			.pastdmark: pop af  
28e9			endm  
# End of macro DMARK
28e9						CALLMONITOR 
28e9 cd 7e 16			call break_point_state  
28ec				endm  
# End of macro CALLMONITOR
28ec					endif 
28ec 3e 00				ld a, 0 
28ee 32 8b ef				ld (os_view_disable), a 
28f1			 
28f1					CALLMONITOR 
28f1 cd 7e 16			call break_point_state  
28f4				endm  
# End of macro CALLMONITOR
28f4			 
28f4			;	call monitor 
28f4			 
28f4					NEXTW 
28f4 c3 44 20			jp macro_next 
28f7				endm 
# End of macro NEXTW
28f7			 
28f7			 
28f7			.MALLOC: 
28f7				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28f7 56				db WORD_SYS_CORE+66             
28f8 20 29			dw .MALLOC2            
28fa 06				db 5 + 1 
28fb .. 00			db "ALLOT",0              
2901				endm 
# End of macro CWHEAD
2901			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2901					if DEBUG_FORTH_WORDS_KEY 
2901						DMARK "ALL" 
2901 f5				push af  
2902 3a 16 29			ld a, (.dmark)  
2905 32 b4 fb			ld (debug_mark),a  
2908 3a 17 29			ld a, (.dmark+1)  
290b 32 b5 fb			ld (debug_mark+1),a  
290e 3a 18 29			ld a, (.dmark+2)  
2911 32 b6 fb			ld (debug_mark+2),a  
2914 18 03			jr .pastdmark  
2916 ..			.dmark: db "ALL"  
2919 f1			.pastdmark: pop af  
291a			endm  
# End of macro DMARK
291a						CALLMONITOR 
291a cd 7e 16			call break_point_state  
291d				endm  
# End of macro CALLMONITOR
291d					endif 
291d c3 47 29				jp .mallocc 
2920			.MALLOC2: 
2920				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2920 56				db WORD_SYS_CORE+66             
2921 5e 29			dw .FREE            
2923 07				db 6 + 1 
2924 .. 00			db "MALLOC",0              
292b				endm 
# End of macro CWHEAD
292b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
292b					; get byte count 
292b					if DEBUG_FORTH_WORDS_KEY 
292b						DMARK "MAL" 
292b f5				push af  
292c 3a 40 29			ld a, (.dmark)  
292f 32 b4 fb			ld (debug_mark),a  
2932 3a 41 29			ld a, (.dmark+1)  
2935 32 b5 fb			ld (debug_mark+1),a  
2938 3a 42 29			ld a, (.dmark+2)  
293b 32 b6 fb			ld (debug_mark+2),a  
293e 18 03			jr .pastdmark  
2940 ..			.dmark: db "MAL"  
2943 f1			.pastdmark: pop af  
2944			endm  
# End of macro DMARK
2944						CALLMONITOR 
2944 cd 7e 16			call break_point_state  
2947				endm  
# End of macro CALLMONITOR
2947					endif 
2947			.mallocc: 
2947					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2947 cd d2 1e			call macro_dsp_valuehl 
294a				endm 
# End of macro FORTH_DSP_VALUEHL
294a			 
294a			;		push hl 
294a			 
294a					; destroy value TOS 
294a			 
294a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
294a cd 8a 1f			call macro_forth_dsp_pop 
294d				endm 
# End of macro FORTH_DSP_POP
294d			 
294d			;		pop hl 
294d cd c8 11				call malloc 
2950				if DEBUG_FORTH_MALLOC_GUARD 
2950 f5					push af 
2951 cd 2a 0d				call ishlzero 
2954			;		ld a, l 
2954			;		add h 
2954			;		cp 0 
2954 f1					pop af 
2955					 
2955 cc dd 51				call z,malloc_error 
2958				endif 
2958			 
2958 cd db 1c				call forth_push_numhl 
295b					NEXTW 
295b c3 44 20			jp macro_next 
295e				endm 
# End of macro NEXTW
295e			 
295e			.FREE: 
295e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
295e 57				db WORD_SYS_CORE+67             
295f 8f 29			dw .LIST            
2961 05				db 4 + 1 
2962 .. 00			db "FREE",0              
2967				endm 
# End of macro CWHEAD
2967			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2967					if DEBUG_FORTH_WORDS_KEY 
2967						DMARK "FRE" 
2967 f5				push af  
2968 3a 7c 29			ld a, (.dmark)  
296b 32 b4 fb			ld (debug_mark),a  
296e 3a 7d 29			ld a, (.dmark+1)  
2971 32 b5 fb			ld (debug_mark+1),a  
2974 3a 7e 29			ld a, (.dmark+2)  
2977 32 b6 fb			ld (debug_mark+2),a  
297a 18 03			jr .pastdmark  
297c ..			.dmark: db "FRE"  
297f f1			.pastdmark: pop af  
2980			endm  
# End of macro DMARK
2980						CALLMONITOR 
2980 cd 7e 16			call break_point_state  
2983				endm  
# End of macro CALLMONITOR
2983					endif 
2983					; get address 
2983			 
2983					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2983 cd d2 1e			call macro_dsp_valuehl 
2986				endm 
# End of macro FORTH_DSP_VALUEHL
2986			 
2986			;		push hl 
2986			 
2986					; destroy value TOS 
2986			 
2986					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2986 cd 8a 1f			call macro_forth_dsp_pop 
2989				endm 
# End of macro FORTH_DSP_POP
2989			 
2989			;		pop hl 
2989			if FORTH_ENABLE_MALLOCFREE 
2989 cd 92 12				call free 
298c			endif 
298c					NEXTW 
298c c3 44 20			jp macro_next 
298f				endm 
# End of macro NEXTW
298f			.LIST: 
298f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
298f 5c				db WORD_SYS_CORE+72             
2990 7d 2b			dw .FORGET            
2992 05				db 4 + 1 
2993 .. 00			db "LIST",0              
2998				endm 
# End of macro CWHEAD
2998			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2998			; | | The quoted word must be in upper case. 
2998				if DEBUG_FORTH_WORDS_KEY 
2998					DMARK "LST" 
2998 f5				push af  
2999 3a ad 29			ld a, (.dmark)  
299c 32 b4 fb			ld (debug_mark),a  
299f 3a ae 29			ld a, (.dmark+1)  
29a2 32 b5 fb			ld (debug_mark+1),a  
29a5 3a af 29			ld a, (.dmark+2)  
29a8 32 b6 fb			ld (debug_mark+2),a  
29ab 18 03			jr .pastdmark  
29ad ..			.dmark: db "LST"  
29b0 f1			.pastdmark: pop af  
29b1			endm  
# End of macro DMARK
29b1					CALLMONITOR 
29b1 cd 7e 16			call break_point_state  
29b4				endm  
# End of macro CALLMONITOR
29b4				endif 
29b4			 
29b4					FORTH_DSP_VALUEHL 
29b4 cd d2 1e			call macro_dsp_valuehl 
29b7				endm 
# End of macro FORTH_DSP_VALUEHL
29b7			 
29b7 e5					push hl 
29b8					FORTH_DSP_POP 
29b8 cd 8a 1f			call macro_forth_dsp_pop 
29bb				endm 
# End of macro FORTH_DSP_POP
29bb c1					pop bc 
29bc			 
29bc			; Start format of scratch string 
29bc			 
29bc 21 9a ef				ld hl, scratch 
29bf			 
29bf 3e 3a				ld a, ':' 
29c1 77					ld (hl),a 
29c2 23					inc hl 
29c3 3e 20				ld a, ' ' 
29c5 77					ld (hl), a 
29c6			 
29c6					; Get ptr to the word we need to look up 
29c6			 
29c6			;		FORTH_DSP_VALUEHL 
29c6					;v5 FORTH_DSP_VALUE 
29c6				; TODO type check 
29c6			;		inc hl    ; Skip type check  
29c6			;		push hl 
29c6			;		ex de, hl    ; put into DE 
29c6			 
29c6			 
29c6 21 00 80				ld hl, baseram 
29c9					;ld hl, baseusermem 
29c9			 
29c9 e5			push hl   ; sacreifical push 
29ca			 
29ca			.ldouscanm: 
29ca e1				pop hl 
29cb			.ldouscan: 
29cb				if DEBUG_FORTH_WORDS 
29cb					DMARK "LSs" 
29cb f5				push af  
29cc 3a e0 29			ld a, (.dmark)  
29cf 32 b4 fb			ld (debug_mark),a  
29d2 3a e1 29			ld a, (.dmark+1)  
29d5 32 b5 fb			ld (debug_mark+1),a  
29d8 3a e2 29			ld a, (.dmark+2)  
29db 32 b6 fb			ld (debug_mark+2),a  
29de 18 03			jr .pastdmark  
29e0 ..			.dmark: db "LSs"  
29e3 f1			.pastdmark: pop af  
29e4			endm  
# End of macro DMARK
29e4					CALLMONITOR 
29e4 cd 7e 16			call break_point_state  
29e7				endm  
# End of macro CALLMONITOR
29e7				endif 
29e7				; skip dict stub 
29e7 cd 95 21				call forth_tok_next 
29ea			 
29ea			 
29ea			; while we have words to look for 
29ea			 
29ea 7e				ld a, (hl)      
29eb				if DEBUG_FORTH_WORDS 
29eb					DMARK "LSk" 
29eb f5				push af  
29ec 3a 00 2a			ld a, (.dmark)  
29ef 32 b4 fb			ld (debug_mark),a  
29f2 3a 01 2a			ld a, (.dmark+1)  
29f5 32 b5 fb			ld (debug_mark+1),a  
29f8 3a 02 2a			ld a, (.dmark+2)  
29fb 32 b6 fb			ld (debug_mark+2),a  
29fe 18 03			jr .pastdmark  
2a00 ..			.dmark: db "LSk"  
2a03 f1			.pastdmark: pop af  
2a04			endm  
# End of macro DMARK
2a04					CALLMONITOR 
2a04 cd 7e 16			call break_point_state  
2a07				endm  
# End of macro CALLMONITOR
2a07				endif 
2a07					;cp WORD_SYS_END 
2a07					;jp z, .lunotfound 
2a07			 
2a07					; if we hit non uwords then gone too far 
2a07 fe 01				cp WORD_SYS_UWORD 
2a09 c2 39 2b				jp nz, .lunotfound 
2a0c			 
2a0c				if DEBUG_FORTH_WORDS 
2a0c					DMARK "LSu" 
2a0c f5				push af  
2a0d 3a 21 2a			ld a, (.dmark)  
2a10 32 b4 fb			ld (debug_mark),a  
2a13 3a 22 2a			ld a, (.dmark+1)  
2a16 32 b5 fb			ld (debug_mark+1),a  
2a19 3a 23 2a			ld a, (.dmark+2)  
2a1c 32 b6 fb			ld (debug_mark+2),a  
2a1f 18 03			jr .pastdmark  
2a21 ..			.dmark: db "LSu"  
2a24 f1			.pastdmark: pop af  
2a25			endm  
# End of macro DMARK
2a25					CALLMONITOR 
2a25 cd 7e 16			call break_point_state  
2a28				endm  
# End of macro CALLMONITOR
2a28				endif 
2a28			 
2a28					; found a uword but is it the one we want... 
2a28			 
2a28 c5					push bc     ; uword to find is on bc 
2a29 d1					pop de 
2a2a			 
2a2a e5					push hl  ; to save the ptr 
2a2b			 
2a2b					; skip opcode 
2a2b 23					inc hl  
2a2c					; skip next ptr 
2a2c 23					inc hl  
2a2d 23					inc hl 
2a2e					; skip len 
2a2e 23					inc hl 
2a2f			 
2a2f				if DEBUG_FORTH_WORDS 
2a2f					DMARK "LSc" 
2a2f f5				push af  
2a30 3a 44 2a			ld a, (.dmark)  
2a33 32 b4 fb			ld (debug_mark),a  
2a36 3a 45 2a			ld a, (.dmark+1)  
2a39 32 b5 fb			ld (debug_mark+1),a  
2a3c 3a 46 2a			ld a, (.dmark+2)  
2a3f 32 b6 fb			ld (debug_mark+2),a  
2a42 18 03			jr .pastdmark  
2a44 ..			.dmark: db "LSc"  
2a47 f1			.pastdmark: pop af  
2a48			endm  
# End of macro DMARK
2a48					CALLMONITOR 
2a48 cd 7e 16			call break_point_state  
2a4b				endm  
# End of macro CALLMONITOR
2a4b				endif 
2a4b cd 97 11				call strcmp 
2a4e c2 ca 29				jp nz, .ldouscanm 
2a51				 
2a51			 
2a51			 
2a51					; we have a uword so push its name to the stack 
2a51			 
2a51			;	   	push hl  ; save so we can move to next dict block 
2a51 e1			pop hl 
2a52			 
2a52				if DEBUG_FORTH_WORDS 
2a52					DMARK "LSm" 
2a52 f5				push af  
2a53 3a 67 2a			ld a, (.dmark)  
2a56 32 b4 fb			ld (debug_mark),a  
2a59 3a 68 2a			ld a, (.dmark+1)  
2a5c 32 b5 fb			ld (debug_mark+1),a  
2a5f 3a 69 2a			ld a, (.dmark+2)  
2a62 32 b6 fb			ld (debug_mark+2),a  
2a65 18 03			jr .pastdmark  
2a67 ..			.dmark: db "LSm"  
2a6a f1			.pastdmark: pop af  
2a6b			endm  
# End of macro DMARK
2a6b					CALLMONITOR 
2a6b cd 7e 16			call break_point_state  
2a6e				endm  
# End of macro CALLMONITOR
2a6e				endif 
2a6e			 
2a6e					; skip opcode 
2a6e 23					inc hl  
2a6f					; skip next ptr 
2a6f 23					inc hl  
2a70 23					inc hl 
2a71					; skip len 
2a71 7e					ld a, (hl)   ; save length to add 
2a72				if DEBUG_FORTH_WORDS 
2a72					DMARK "LS2" 
2a72 f5				push af  
2a73 3a 87 2a			ld a, (.dmark)  
2a76 32 b4 fb			ld (debug_mark),a  
2a79 3a 88 2a			ld a, (.dmark+1)  
2a7c 32 b5 fb			ld (debug_mark+1),a  
2a7f 3a 89 2a			ld a, (.dmark+2)  
2a82 32 b6 fb			ld (debug_mark+2),a  
2a85 18 03			jr .pastdmark  
2a87 ..			.dmark: db "LS2"  
2a8a f1			.pastdmark: pop af  
2a8b			endm  
# End of macro DMARK
2a8b					CALLMONITOR 
2a8b cd 7e 16			call break_point_state  
2a8e				endm  
# End of macro CALLMONITOR
2a8e				endif 
2a8e			 
2a8e					; save this location 
2a8e				 
2a8e e5					push hl 
2a8f			 
2a8f 23					inc hl 
2a90 11 9c ef				ld de, scratch+2 
2a93 4f					ld c, a 
2a94 06 00				ld b, 0 
2a96			 
2a96				if DEBUG_FORTH_WORDS 
2a96					DMARK "LSn" 
2a96 f5				push af  
2a97 3a ab 2a			ld a, (.dmark)  
2a9a 32 b4 fb			ld (debug_mark),a  
2a9d 3a ac 2a			ld a, (.dmark+1)  
2aa0 32 b5 fb			ld (debug_mark+1),a  
2aa3 3a ad 2a			ld a, (.dmark+2)  
2aa6 32 b6 fb			ld (debug_mark+2),a  
2aa9 18 03			jr .pastdmark  
2aab ..			.dmark: db "LSn"  
2aae f1			.pastdmark: pop af  
2aaf			endm  
# End of macro DMARK
2aaf					CALLMONITOR 
2aaf cd 7e 16			call break_point_state  
2ab2				endm  
# End of macro CALLMONITOR
2ab2				endif 
2ab2			 
2ab2					; copy uword name to scratch 
2ab2			 
2ab2 ed b0				ldir 
2ab4			 
2ab4 1b					dec de 
2ab5 3e 20				ld a, ' '    ; change null to space 
2ab7 12					ld (de), a 
2ab8			 
2ab8 13					inc de 
2ab9			 
2ab9 d5					push de 
2aba c1					pop bc     ; move scratch pointer to end of word name and save it 
2abb			 
2abb e1					pop hl 
2abc 7e					ld a, (hl) 
2abd					;inc hl 
2abd					; skip word string 
2abd cd 01 0d				call addatohl 
2ac0			 
2ac0 23					inc hl 
2ac1			 
2ac1				if DEBUG_FORTH_WORDS 
2ac1					DMARK "LS3" 
2ac1 f5				push af  
2ac2 3a d6 2a			ld a, (.dmark)  
2ac5 32 b4 fb			ld (debug_mark),a  
2ac8 3a d7 2a			ld a, (.dmark+1)  
2acb 32 b5 fb			ld (debug_mark+1),a  
2ace 3a d8 2a			ld a, (.dmark+2)  
2ad1 32 b6 fb			ld (debug_mark+2),a  
2ad4 18 03			jr .pastdmark  
2ad6 ..			.dmark: db "LS3"  
2ad9 f1			.pastdmark: pop af  
2ada			endm  
# End of macro DMARK
2ada					CALLMONITOR 
2ada cd 7e 16			call break_point_state  
2add				endm  
# End of macro CALLMONITOR
2add				endif 
2add					; should now be at the start of the machine code to setup the eval of the uword 
2add					; now locate the ptr to the string defintion 
2add			 
2add					; skip ld hl, 
2add					; then load the ptr 
2add			; TODO use get from hl ptr 
2add 23					inc hl 
2ade 5e					ld e, (hl) 
2adf 23					inc hl 
2ae0 56					ld d, (hl) 
2ae1 eb					ex de, hl 
2ae2			 
2ae2			 
2ae2				if DEBUG_FORTH_WORDS 
2ae2					DMARK "LSt" 
2ae2 f5				push af  
2ae3 3a f7 2a			ld a, (.dmark)  
2ae6 32 b4 fb			ld (debug_mark),a  
2ae9 3a f8 2a			ld a, (.dmark+1)  
2aec 32 b5 fb			ld (debug_mark+1),a  
2aef 3a f9 2a			ld a, (.dmark+2)  
2af2 32 b6 fb			ld (debug_mark+2),a  
2af5 18 03			jr .pastdmark  
2af7 ..			.dmark: db "LSt"  
2afa f1			.pastdmark: pop af  
2afb			endm  
# End of macro DMARK
2afb					CALLMONITOR 
2afb cd 7e 16			call break_point_state  
2afe				endm  
# End of macro CALLMONITOR
2afe				endif 
2afe			 
2afe			; cant push right now due to tokenised strings  
2afe			 
2afe			; get the destination of where to copy this definition to. 
2afe			 
2afe c5					push bc 
2aff d1					pop de 
2b00			 
2b00 7e			.listl:         ld a,(hl) 
2b01 fe 00				cp 0 
2b03 28 09				jr z, .lreplsp     ; replace zero with space 
2b05					;cp FORTH_END_BUFFER 
2b05 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2b07 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b09				 
2b09					; just copy this char as is then 
2b09			 
2b09 12					ld (de), a 
2b0a			 
2b0a 23			.listnxt:	inc hl 
2b0b 13					inc de 
2b0c 18 f2				jr .listl 
2b0e			 
2b0e 3e 20		.lreplsp:	ld a,' ' 
2b10 12					ld (de), a 
2b11 18 f7				jr .listnxt 
2b13			 
2b13			; close up uword def 
2b13			 
2b13			.listdone: 
2b13 12					ld (de), a 
2b14 13					inc de 
2b15 3e 00				ld a, 0 
2b17 12					ld (de), a 
2b18			 
2b18			; now have def so clean up and push to stack 
2b18			 
2b18 21 9a ef				ld hl, scratch 
2b1b				if DEBUG_FORTH_WORDS 
2b1b					DMARK "Ltp" 
2b1b f5				push af  
2b1c 3a 30 2b			ld a, (.dmark)  
2b1f 32 b4 fb			ld (debug_mark),a  
2b22 3a 31 2b			ld a, (.dmark+1)  
2b25 32 b5 fb			ld (debug_mark+1),a  
2b28 3a 32 2b			ld a, (.dmark+2)  
2b2b 32 b6 fb			ld (debug_mark+2),a  
2b2e 18 03			jr .pastdmark  
2b30 ..			.dmark: db "Ltp"  
2b33 f1			.pastdmark: pop af  
2b34			endm  
# End of macro DMARK
2b34					CALLMONITOR 
2b34 cd 7e 16			call break_point_state  
2b37				endm  
# End of macro CALLMONITOR
2b37				endif 
2b37			 
2b37 18 1f			jr .listpush 
2b39			 
2b39			;.lnuword:	pop hl 
2b39			;		call forth_tok_next 
2b39			;		jp .ldouscan  
2b39			 
2b39			.lunotfound:		  
2b39			 
2b39				if DEBUG_FORTH_WORDS 
2b39					DMARK "LSn" 
2b39 f5				push af  
2b3a 3a 4e 2b			ld a, (.dmark)  
2b3d 32 b4 fb			ld (debug_mark),a  
2b40 3a 4f 2b			ld a, (.dmark+1)  
2b43 32 b5 fb			ld (debug_mark+1),a  
2b46 3a 50 2b			ld a, (.dmark+2)  
2b49 32 b6 fb			ld (debug_mark+2),a  
2b4c 18 03			jr .pastdmark  
2b4e ..			.dmark: db "LSn"  
2b51 f1			.pastdmark: pop af  
2b52			endm  
# End of macro DMARK
2b52					CALLMONITOR 
2b52 cd 7e 16			call break_point_state  
2b55				endm  
# End of macro CALLMONITOR
2b55				endif 
2b55			 
2b55					 
2b55			;		FORTH_DSP_POP 
2b55			;		ld hl, .luno 
2b55			 
2b55					NEXTW			 
2b55 c3 44 20			jp macro_next 
2b58				endm 
# End of macro NEXTW
2b58			 
2b58			.listpush: 
2b58				if DEBUG_FORTH_WORDS 
2b58					DMARK "LS>" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 b4 fb			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 b5 fb			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 b6 fb			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "LS>"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71					CALLMONITOR 
2b71 cd 7e 16			call break_point_state  
2b74				endm  
# End of macro CALLMONITOR
2b74				endif 
2b74 cd 49 1d				call forth_push_str 
2b77			 
2b77			 
2b77			 
2b77					NEXTW 
2b77 c3 44 20			jp macro_next 
2b7a				endm 
# End of macro NEXTW
2b7a			 
2b7a			;.luno:    db "Word not found",0 
2b7a			 
2b7a			 
2b7a			 
2b7a			 
2b7a			 
2b7a			;		push hl   ; save pointer to start of uword def string 
2b7a			; 
2b7a			;; look for FORTH_EOL_LINE 
2b7a			;		ld a, FORTH_END_BUFFER 
2b7a			;		call strlent 
2b7a			; 
2b7a			;		inc hl		 ; space for coln def 
2b7a			;		inc hl 
2b7a			;		inc hl          ; space for terms 
2b7a			;		inc hl 
2b7a			; 
2b7a			;		ld a, 20   ; TODO get actual length 
2b7a			;		call addatohl    ; include a random amount of room for the uword name 
2b7a			; 
2b7a			;		 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "Lt1" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;		 
2b7a			; 
2b7a			;; malloc space for the string because we cant change it 
2b7a			; 
2b7a			;		call malloc 
2b7a			;	if DEBUG_FORTH_MALLOC_GUARD 
2b7a			;		push af 
2b7a			;		call ishlzero 
2b7a			;		pop af 
2b7a			;		 
2b7a			;		call z,malloc_error 
2b7a			;	endif 
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "Lt2" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;		pop de 
2b7a			;		push hl    ; push the malloc to release later 
2b7a			;		push hl   ;  push back a copy for the later stack push 
2b7a			;		 
2b7a			;; copy the string swapping out the zero terms for spaces 
2b7a			; 
2b7a			;		; de has our source 
2b7a			;		; hl has our dest 
2b7a			; 
2b7a			;; add the coln def 
2b7a			; 
2b7a			;		ld a, ':' 
2b7a			;		ld (hl), a 
2b7a			;		inc hl 
2b7a			;		ld a, ' ' 
2b7a			;		ld (hl), a 
2b7a			;		inc hl 
2b7a			; 
2b7a			;; add the uname word 
2b7a			;		push de   ; save our string for now 
2b7a			;		ex de, hl 
2b7a			; 
2b7a			;		FORTH_DSP_VALUE 
2b7a			;		;v5 FORTH_DSP_VALUE 
2b7a			; 
2b7a			;		inc hl   ; skip type but we know by now this is OK 
2b7a			; 
2b7a			;.luword:	ld a,(hl) 
2b7a			;		cp 0 
2b7a			;		jr z, .luword2 
2b7a			;		ld (de), a 
2b7a			;		inc de 
2b7a			;		inc hl 
2b7a			;		jr .luword 
2b7a			; 
2b7a			;.luword2:	ld a, ' ' 
2b7a			;		ld (de), a 
2b7a			;;		inc hl 
2b7a			;;		inc de 
2b7a			;;		ld (de), a 
2b7a			;;		inc hl 
2b7a			;		inc de 
2b7a			; 
2b7a			;		ex de, hl 
2b7a			;		pop de 
2b7a			;		 
2b7a			;		 
2b7a			; 
2b7a			;; detoken that string and copy it 
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "Lt2" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;.ldetok:	ld a, (de) 
2b7a			;		cp FORTH_END_BUFFER 
2b7a			;		jr z, .ldetokend 
2b7a			;		; swap out any zero term for space 
2b7a			;		cp 0 
2b7a			;		jr nz, .ldetoknext 
2b7a			;		ld a, ' ' 
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "LtS" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;.ldetoknext:	ld (hl), a 
2b7a			;		inc de 
2b7a			;		inc hl 
2b7a			;		jr .ldetok 
2b7a			; 
2b7a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b7a			;		ld (hl), a  
2b7a			; 
2b7a			;; free that temp malloc 
2b7a			; 
2b7a			;		pop hl    
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "Lt4" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;		call forth_apushstrhl 
2b7a			; 
2b7a			;		; get rid of temp malloc area 
2b7a			; 
2b7a			;		pop hl 
2b7a			;		call free 
2b7a			; 
2b7a			;		jr .ludone 
2b7a			; 
2b7a			;.lnuword:	pop hl 
2b7a			;		call forth_tok_next 
2b7a			;		jp .ldouscan  
2b7a			; 
2b7a			;.ludone:		 pop hl 
2b7a			; 
2b7a					NEXTW 
2b7a c3 44 20			jp macro_next 
2b7d				endm 
# End of macro NEXTW
2b7d			 
2b7d			.FORGET: 
2b7d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b7d 5d				db WORD_SYS_CORE+73             
2b7e f6 2b			dw .NOP            
2b80 07				db 6 + 1 
2b81 .. 00			db "FORGET",0              
2b88				endm 
# End of macro CWHEAD
2b88			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b88			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b88			; | |  
2b88			; | | e.g. "MORE" forget 
2b88					if DEBUG_FORTH_WORDS_KEY 
2b88						DMARK "FRG" 
2b88 f5				push af  
2b89 3a 9d 2b			ld a, (.dmark)  
2b8c 32 b4 fb			ld (debug_mark),a  
2b8f 3a 9e 2b			ld a, (.dmark+1)  
2b92 32 b5 fb			ld (debug_mark+1),a  
2b95 3a 9f 2b			ld a, (.dmark+2)  
2b98 32 b6 fb			ld (debug_mark+2),a  
2b9b 18 03			jr .pastdmark  
2b9d ..			.dmark: db "FRG"  
2ba0 f1			.pastdmark: pop af  
2ba1			endm  
# End of macro DMARK
2ba1						CALLMONITOR 
2ba1 cd 7e 16			call break_point_state  
2ba4				endm  
# End of macro CALLMONITOR
2ba4					endif 
2ba4			 
2ba4				; find uword 
2ba4			        ; update start of word with "_" 
2ba4				; replace uword with deleted flag 
2ba4			 
2ba4			 
2ba4			;	if DEBUG_FORTH_WORDS 
2ba4			;		DMARK "FOG" 
2ba4			;		CALLMONITOR 
2ba4			;	endif 
2ba4			 
2ba4			 
2ba4					; Get ptr to the word we need to look up 
2ba4			 
2ba4					FORTH_DSP_VALUEHL 
2ba4 cd d2 1e			call macro_dsp_valuehl 
2ba7				endm 
# End of macro FORTH_DSP_VALUEHL
2ba7					;v5 FORTH_DSP_VALUE 
2ba7				; TODO type check 
2ba7			;		inc hl    ; Skip type check  
2ba7 e5					push hl 
2ba8 c1					pop bc 
2ba9			;		ex de, hl    ; put into DE 
2ba9			 
2ba9			 
2ba9 21 00 80				ld hl, baseram 
2bac					;ld hl, baseusermem 
2bac			 
2bac				; skip dict stub 
2bac			;	call forth_tok_next 
2bac e5			push hl   ; sacreifical push 
2bad			 
2bad			.fldouscanm: 
2bad e1				pop hl 
2bae			.fldouscan: 
2bae			;	if DEBUG_FORTH_WORDS 
2bae			;		DMARK "LSs" 
2bae			;		CALLMONITOR 
2bae			;	endif 
2bae				; skip dict stub 
2bae cd 95 21				call forth_tok_next 
2bb1			 
2bb1			 
2bb1			; while we have words to look for 
2bb1			 
2bb1 7e				ld a, (hl)      
2bb2			;	if DEBUG_FORTH_WORDS 
2bb2			;		DMARK "LSk" 
2bb2			;		CALLMONITOR 
2bb2			;	endif 
2bb2 fe 00				cp WORD_SYS_END 
2bb4 ca f0 2b				jp z, .flunotfound 
2bb7 fe 01				cp WORD_SYS_UWORD 
2bb9 c2 ae 2b				jp nz, .fldouscan 
2bbc			 
2bbc			;	if DEBUG_FORTH_WORDS 
2bbc			;		DMARK "LSu" 
2bbc			;		CALLMONITOR 
2bbc			;	endif 
2bbc			 
2bbc					; found a uword but is it the one we want... 
2bbc			 
2bbc c5					push bc     ; uword to find is on bc 
2bbd d1					pop de 
2bbe			 
2bbe e5					push hl  ; to save the ptr 
2bbf			 
2bbf					; skip opcode 
2bbf 23					inc hl  
2bc0					; skip next ptr 
2bc0 23					inc hl  
2bc1 23					inc hl 
2bc2					; skip len 
2bc2 23					inc hl 
2bc3			 
2bc3			;	if DEBUG_FORTH_WORDS 
2bc3			;		DMARK "LSc" 
2bc3			;		CALLMONITOR 
2bc3			;	endif 
2bc3 cd 97 11				call strcmp 
2bc6 c2 ad 2b				jp nz, .fldouscanm 
2bc9			; 
2bc9			; 
2bc9			;; while we have words to look for 
2bc9			; 
2bc9			;.fdouscan:	ld a, (hl)      
2bc9			;	if DEBUG_FORTH_WORDS 
2bc9			;		DMARK "LSs" 
2bc9			;		CALLMONITOR 
2bc9			;	endif 
2bc9			;		cp WORD_SYS_END 
2bc9			;		jp z, .fudone 
2bc9			;		cp WORD_SYS_UWORD 
2bc9			;		jp nz, .fnuword 
2bc9			; 
2bc9			;	if DEBUG_FORTH_WORDS 
2bc9			;		DMARK "FGu" 
2bc9			;		CALLMONITOR 
2bc9			;	endif 
2bc9			; 
2bc9			;		; found a uword but is it the one we want... 
2bc9			; 
2bc9			; 
2bc9			;	        pop de   ; get back the dsp name 
2bc9			;		push de 
2bc9			; 
2bc9			;		push hl  ; to save the ptr 
2bc9			; 
2bc9			;		; skip opcode 
2bc9			;		inc hl  
2bc9			;		; skip next ptr 
2bc9			;		inc hl  
2bc9			;		inc hl 
2bc9			;		; skip len 
2bc9			;		inc hl 
2bc9			; 
2bc9			;	if DEBUG_FORTH_WORDS 
2bc9			;		DMARK "FGc" 
2bc9			;		CALLMONITOR 
2bc9			;	endif 
2bc9			;		call strcmp 
2bc9			;		jp nz, .fnuword 
2bc9			 
2bc9			 
2bc9 e1			pop hl 
2bca			 
2bca				 
2bca				if DEBUG_FORTH_WORDS 
2bca					DMARK "FGm" 
2bca f5				push af  
2bcb 3a df 2b			ld a, (.dmark)  
2bce 32 b4 fb			ld (debug_mark),a  
2bd1 3a e0 2b			ld a, (.dmark+1)  
2bd4 32 b5 fb			ld (debug_mark+1),a  
2bd7 3a e1 2b			ld a, (.dmark+2)  
2bda 32 b6 fb			ld (debug_mark+2),a  
2bdd 18 03			jr .pastdmark  
2bdf ..			.dmark: db "FGm"  
2be2 f1			.pastdmark: pop af  
2be3			endm  
# End of macro DMARK
2be3					CALLMONITOR 
2be3 cd 7e 16			call break_point_state  
2be6				endm  
# End of macro CALLMONITOR
2be6				endif 
2be6			 
2be6			 
2be6			 
2be6					; we have a uword so push its name to the stack 
2be6			 
2be6			;	   	push hl  ; save so we can move to next dict block 
2be6			;pop hl 
2be6			 
2be6					; update opcode to deleted 
2be6 3e 03				ld a, WORD_SYS_DELETED 
2be8 77					ld (hl), a 
2be9			 
2be9 23					inc hl  
2bea					; skip next ptr 
2bea 23					inc hl  
2beb 23					inc hl 
2bec					; skip len 
2bec 23					inc hl 
2bed			 
2bed					; TODO change parser to skip deleted words but for now mark it out 
2bed 3e 5f				ld a, "_" 
2bef 77					ld  (hl),a 
2bf0			 
2bf0			;		jr .fudone 
2bf0			; 
2bf0			;.fnuword:	pop hl 
2bf0			;		call forth_tok_next 
2bf0			;		jp .fdouscan  
2bf0			 
2bf0			.flunotfound:		  
2bf0			 
2bf0			 
2bf0					 
2bf0					FORTH_DSP_POP 
2bf0 cd 8a 1f			call macro_forth_dsp_pop 
2bf3				endm 
# End of macro FORTH_DSP_POP
2bf3			;		ld hl, .luno 
2bf3			;.fudone:		 pop hl 
2bf3					NEXTW 
2bf3 c3 44 20			jp macro_next 
2bf6				endm 
# End of macro NEXTW
2bf6			.NOP: 
2bf6				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bf6 61				db WORD_SYS_CORE+77             
2bf7 1d 2c			dw .COMO            
2bf9 04				db 3 + 1 
2bfa .. 00			db "NOP",0              
2bfe				endm 
# End of macro CWHEAD
2bfe			; | NOP (  --  ) Do nothing | DONE 
2bfe					if DEBUG_FORTH_WORDS_KEY 
2bfe						DMARK "NOP" 
2bfe f5				push af  
2bff 3a 13 2c			ld a, (.dmark)  
2c02 32 b4 fb			ld (debug_mark),a  
2c05 3a 14 2c			ld a, (.dmark+1)  
2c08 32 b5 fb			ld (debug_mark+1),a  
2c0b 3a 15 2c			ld a, (.dmark+2)  
2c0e 32 b6 fb			ld (debug_mark+2),a  
2c11 18 03			jr .pastdmark  
2c13 ..			.dmark: db "NOP"  
2c16 f1			.pastdmark: pop af  
2c17			endm  
# End of macro DMARK
2c17						CALLMONITOR 
2c17 cd 7e 16			call break_point_state  
2c1a				endm  
# End of macro CALLMONITOR
2c1a					endif 
2c1a				       NEXTW 
2c1a c3 44 20			jp macro_next 
2c1d				endm 
# End of macro NEXTW
2c1d			.COMO: 
2c1d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c1d 6e				db WORD_SYS_CORE+90             
2c1e 6f 2c			dw .COMC            
2c20 02				db 1 + 1 
2c21 .. 00			db "(",0              
2c23				endm 
# End of macro CWHEAD
2c23			; | ( ( -- )  Start of comment | DONE 
2c23			 
2c23			 
2c23 2a 9b f2				ld hl, ( os_tok_ptr) 
2c26 11 6a 2c			ld de, .closepar 
2c29					 
2c29					if DEBUG_FORTH_WORDS 
2c29						DMARK ").." 
2c29 f5				push af  
2c2a 3a 3e 2c			ld a, (.dmark)  
2c2d 32 b4 fb			ld (debug_mark),a  
2c30 3a 3f 2c			ld a, (.dmark+1)  
2c33 32 b5 fb			ld (debug_mark+1),a  
2c36 3a 40 2c			ld a, (.dmark+2)  
2c39 32 b6 fb			ld (debug_mark+2),a  
2c3c 18 03			jr .pastdmark  
2c3e ..			.dmark: db ").."  
2c41 f1			.pastdmark: pop af  
2c42			endm  
# End of macro DMARK
2c42						CALLMONITOR 
2c42 cd 7e 16			call break_point_state  
2c45				endm  
# End of macro CALLMONITOR
2c45					endif 
2c45 cd 5f 21			call findnexttok  
2c48			 
2c48					if DEBUG_FORTH_WORDS 
2c48						DMARK "IF5" 
2c48 f5				push af  
2c49 3a 5d 2c			ld a, (.dmark)  
2c4c 32 b4 fb			ld (debug_mark),a  
2c4f 3a 5e 2c			ld a, (.dmark+1)  
2c52 32 b5 fb			ld (debug_mark+1),a  
2c55 3a 5f 2c			ld a, (.dmark+2)  
2c58 32 b6 fb			ld (debug_mark+2),a  
2c5b 18 03			jr .pastdmark  
2c5d ..			.dmark: db "IF5"  
2c60 f1			.pastdmark: pop af  
2c61			endm  
# End of macro DMARK
2c61						CALLMONITOR 
2c61 cd 7e 16			call break_point_state  
2c64				endm  
# End of macro CALLMONITOR
2c64					endif 
2c64				; replace below with ) exec using tok_ptr 
2c64 22 9b f2			ld (os_tok_ptr), hl 
2c67 c3 d5 20			jp exec1 
2c6a			 
2c6a .. 00			.closepar:   db ")",0 
2c6c			 
2c6c				       NEXTW 
2c6c c3 44 20			jp macro_next 
2c6f				endm 
# End of macro NEXTW
2c6f			.COMC: 
2c6f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c6f 6f				db WORD_SYS_CORE+91             
2c70 78 2c			dw .SCRATCH            
2c72 02				db 1 + 1 
2c73 .. 00			db ")",0              
2c75				endm 
# End of macro CWHEAD
2c75			; | ) ( -- )  End of comment |  DONE  
2c75				       NEXTW 
2c75 c3 44 20			jp macro_next 
2c78				endm 
# End of macro NEXTW
2c78			 
2c78			.SCRATCH: 
2c78				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c78 6f				db WORD_SYS_CORE+91             
2c79 b3 2c			dw .INC            
2c7b 08				db 7 + 1 
2c7c .. 00			db "SCRATCH",0              
2c84				endm 
# End of macro CWHEAD
2c84			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c84			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c84			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c84			; | |  
2c84			; | | e.g.    : score $00 scratch ; 
2c84			; | |  
2c84			; | | $00 score ! 
2c84			; | | $01 score +! 
2c84			; | |  
2c84			; | | e.g.   : varword $0a scratch ;  
2c84			; | | 
2c84			; | | $8000 varword ! 
2c84					if DEBUG_FORTH_WORDS_KEY 
2c84						DMARK "SCR" 
2c84 f5				push af  
2c85 3a 99 2c			ld a, (.dmark)  
2c88 32 b4 fb			ld (debug_mark),a  
2c8b 3a 9a 2c			ld a, (.dmark+1)  
2c8e 32 b5 fb			ld (debug_mark+1),a  
2c91 3a 9b 2c			ld a, (.dmark+2)  
2c94 32 b6 fb			ld (debug_mark+2),a  
2c97 18 03			jr .pastdmark  
2c99 ..			.dmark: db "SCR"  
2c9c f1			.pastdmark: pop af  
2c9d			endm  
# End of macro DMARK
2c9d						CALLMONITOR 
2c9d cd 7e 16			call break_point_state  
2ca0				endm  
# End of macro CALLMONITOR
2ca0					endif 
2ca0			 
2ca0					FORTH_DSP_VALUEHL 
2ca0 cd d2 1e			call macro_dsp_valuehl 
2ca3				endm 
# End of macro FORTH_DSP_VALUEHL
2ca3				 
2ca3					FORTH_DSP_POP 
2ca3 cd 8a 1f			call macro_forth_dsp_pop 
2ca6				endm 
# End of macro FORTH_DSP_POP
2ca6			 
2ca6 7d					ld a, l 
2ca7 21 bf f4				ld hl, os_var_array 
2caa cd 01 0d				call addatohl 
2cad			 
2cad cd db 1c				call forth_push_numhl 
2cb0			 
2cb0				       NEXTW 
2cb0 c3 44 20			jp macro_next 
2cb3				endm 
# End of macro NEXTW
2cb3			 
2cb3			.INC: 
2cb3				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2cb3 6f				db WORD_SYS_CORE+91             
2cb4 07 2d			dw .DEC            
2cb6 03				db 2 + 1 
2cb7 .. 00			db "+!",0              
2cba				endm 
# End of macro CWHEAD
2cba			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2cba					if DEBUG_FORTH_WORDS_KEY 
2cba						DMARK "+s_" 
2cba f5				push af  
2cbb 3a cf 2c			ld a, (.dmark)  
2cbe 32 b4 fb			ld (debug_mark),a  
2cc1 3a d0 2c			ld a, (.dmark+1)  
2cc4 32 b5 fb			ld (debug_mark+1),a  
2cc7 3a d1 2c			ld a, (.dmark+2)  
2cca 32 b6 fb			ld (debug_mark+2),a  
2ccd 18 03			jr .pastdmark  
2ccf ..			.dmark: db "+s_"  
2cd2 f1			.pastdmark: pop af  
2cd3			endm  
# End of macro DMARK
2cd3						CALLMONITOR 
2cd3 cd 7e 16			call break_point_state  
2cd6				endm  
# End of macro CALLMONITOR
2cd6					endif 
2cd6			 
2cd6					FORTH_DSP_VALUEHL 
2cd6 cd d2 1e			call macro_dsp_valuehl 
2cd9				endm 
# End of macro FORTH_DSP_VALUEHL
2cd9			 
2cd9 e5					push hl   ; save address 
2cda			 
2cda					FORTH_DSP_POP 
2cda cd 8a 1f			call macro_forth_dsp_pop 
2cdd				endm 
# End of macro FORTH_DSP_POP
2cdd			 
2cdd					FORTH_DSP_VALUEHL 
2cdd cd d2 1e			call macro_dsp_valuehl 
2ce0				endm 
# End of macro FORTH_DSP_VALUEHL
2ce0			 
2ce0					FORTH_DSP_POP 
2ce0 cd 8a 1f			call macro_forth_dsp_pop 
2ce3				endm 
# End of macro FORTH_DSP_POP
2ce3			 
2ce3					; hl contains value to add to byte at a 
2ce3				 
2ce3 eb					ex de, hl 
2ce4			 
2ce4 e1					pop hl 
2ce5			 
2ce5					if DEBUG_FORTH_WORDS 
2ce5						DMARK "INC" 
2ce5 f5				push af  
2ce6 3a fa 2c			ld a, (.dmark)  
2ce9 32 b4 fb			ld (debug_mark),a  
2cec 3a fb 2c			ld a, (.dmark+1)  
2cef 32 b5 fb			ld (debug_mark+1),a  
2cf2 3a fc 2c			ld a, (.dmark+2)  
2cf5 32 b6 fb			ld (debug_mark+2),a  
2cf8 18 03			jr .pastdmark  
2cfa ..			.dmark: db "INC"  
2cfd f1			.pastdmark: pop af  
2cfe			endm  
# End of macro DMARK
2cfe						CALLMONITOR 
2cfe cd 7e 16			call break_point_state  
2d01				endm  
# End of macro CALLMONITOR
2d01					endif 
2d01			 
2d01 7e					ld a,(hl) 
2d02 83					add e 
2d03 77					ld (hl),a 
2d04			 
2d04			 
2d04			 
2d04				       NEXTW 
2d04 c3 44 20			jp macro_next 
2d07				endm 
# End of macro NEXTW
2d07			 
2d07			.DEC: 
2d07				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d07 6f				db WORD_SYS_CORE+91             
2d08 58 2d			dw .INC2            
2d0a 03				db 2 + 1 
2d0b .. 00			db "-!",0              
2d0e				endm 
# End of macro CWHEAD
2d0e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d0e					if DEBUG_FORTH_WORDS_KEY 
2d0e						DMARK "-s_" 
2d0e f5				push af  
2d0f 3a 23 2d			ld a, (.dmark)  
2d12 32 b4 fb			ld (debug_mark),a  
2d15 3a 24 2d			ld a, (.dmark+1)  
2d18 32 b5 fb			ld (debug_mark+1),a  
2d1b 3a 25 2d			ld a, (.dmark+2)  
2d1e 32 b6 fb			ld (debug_mark+2),a  
2d21 18 03			jr .pastdmark  
2d23 ..			.dmark: db "-s_"  
2d26 f1			.pastdmark: pop af  
2d27			endm  
# End of macro DMARK
2d27						CALLMONITOR 
2d27 cd 7e 16			call break_point_state  
2d2a				endm  
# End of macro CALLMONITOR
2d2a					endif 
2d2a			 
2d2a					FORTH_DSP_VALUEHL 
2d2a cd d2 1e			call macro_dsp_valuehl 
2d2d				endm 
# End of macro FORTH_DSP_VALUEHL
2d2d			 
2d2d e5					push hl   ; save address 
2d2e			 
2d2e					FORTH_DSP_POP 
2d2e cd 8a 1f			call macro_forth_dsp_pop 
2d31				endm 
# End of macro FORTH_DSP_POP
2d31			 
2d31					FORTH_DSP_VALUEHL 
2d31 cd d2 1e			call macro_dsp_valuehl 
2d34				endm 
# End of macro FORTH_DSP_VALUEHL
2d34			 
2d34					; hl contains value to add to byte at a 
2d34				 
2d34 eb					ex de, hl 
2d35			 
2d35 e1					pop hl 
2d36			 
2d36					if DEBUG_FORTH_WORDS 
2d36						DMARK "DEC" 
2d36 f5				push af  
2d37 3a 4b 2d			ld a, (.dmark)  
2d3a 32 b4 fb			ld (debug_mark),a  
2d3d 3a 4c 2d			ld a, (.dmark+1)  
2d40 32 b5 fb			ld (debug_mark+1),a  
2d43 3a 4d 2d			ld a, (.dmark+2)  
2d46 32 b6 fb			ld (debug_mark+2),a  
2d49 18 03			jr .pastdmark  
2d4b ..			.dmark: db "DEC"  
2d4e f1			.pastdmark: pop af  
2d4f			endm  
# End of macro DMARK
2d4f						CALLMONITOR 
2d4f cd 7e 16			call break_point_state  
2d52				endm  
# End of macro CALLMONITOR
2d52					endif 
2d52			 
2d52 7e					ld a,(hl) 
2d53 93					sub e 
2d54 77					ld (hl),a 
2d55			 
2d55			 
2d55			 
2d55				       NEXTW 
2d55 c3 44 20			jp macro_next 
2d58				endm 
# End of macro NEXTW
2d58			 
2d58			.INC2: 
2d58				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d58 6f				db WORD_SYS_CORE+91             
2d59 02 2e			dw .DEC2            
2d5b 04				db 3 + 1 
2d5c .. 00			db "+2!",0              
2d60				endm 
# End of macro CWHEAD
2d60			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d60			 
2d60					if DEBUG_FORTH_WORDS_KEY 
2d60						DMARK "+2s" 
2d60 f5				push af  
2d61 3a 75 2d			ld a, (.dmark)  
2d64 32 b4 fb			ld (debug_mark),a  
2d67 3a 76 2d			ld a, (.dmark+1)  
2d6a 32 b5 fb			ld (debug_mark+1),a  
2d6d 3a 77 2d			ld a, (.dmark+2)  
2d70 32 b6 fb			ld (debug_mark+2),a  
2d73 18 03			jr .pastdmark  
2d75 ..			.dmark: db "+2s"  
2d78 f1			.pastdmark: pop af  
2d79			endm  
# End of macro DMARK
2d79						CALLMONITOR 
2d79 cd 7e 16			call break_point_state  
2d7c				endm  
# End of macro CALLMONITOR
2d7c					endif 
2d7c			 
2d7c					; Address 
2d7c			 
2d7c					FORTH_DSP_VALUEHL 
2d7c cd d2 1e			call macro_dsp_valuehl 
2d7f				endm 
# End of macro FORTH_DSP_VALUEHL
2d7f			 
2d7f e5					push hl    ; save address 
2d80			 
2d80					; load content into de 
2d80			 
2d80 5e					ld e,(hl) 
2d81 23					inc hl 
2d82 56					ld d, (hl) 
2d83			 
2d83					if DEBUG_FORTH_WORDS 
2d83						DMARK "+2a" 
2d83 f5				push af  
2d84 3a 98 2d			ld a, (.dmark)  
2d87 32 b4 fb			ld (debug_mark),a  
2d8a 3a 99 2d			ld a, (.dmark+1)  
2d8d 32 b5 fb			ld (debug_mark+1),a  
2d90 3a 9a 2d			ld a, (.dmark+2)  
2d93 32 b6 fb			ld (debug_mark+2),a  
2d96 18 03			jr .pastdmark  
2d98 ..			.dmark: db "+2a"  
2d9b f1			.pastdmark: pop af  
2d9c			endm  
# End of macro DMARK
2d9c						CALLMONITOR 
2d9c cd 7e 16			call break_point_state  
2d9f				endm  
# End of macro CALLMONITOR
2d9f					endif 
2d9f			 
2d9f					FORTH_DSP_POP 
2d9f cd 8a 1f			call macro_forth_dsp_pop 
2da2				endm 
# End of macro FORTH_DSP_POP
2da2			 
2da2					; Get value to add 
2da2			 
2da2					FORTH_DSP_VALUE 
2da2 cd bb 1e			call macro_forth_dsp_value 
2da5				endm 
# End of macro FORTH_DSP_VALUE
2da5			 
2da5					if DEBUG_FORTH_WORDS 
2da5						DMARK "+2v" 
2da5 f5				push af  
2da6 3a ba 2d			ld a, (.dmark)  
2da9 32 b4 fb			ld (debug_mark),a  
2dac 3a bb 2d			ld a, (.dmark+1)  
2daf 32 b5 fb			ld (debug_mark+1),a  
2db2 3a bc 2d			ld a, (.dmark+2)  
2db5 32 b6 fb			ld (debug_mark+2),a  
2db8 18 03			jr .pastdmark  
2dba ..			.dmark: db "+2v"  
2dbd f1			.pastdmark: pop af  
2dbe			endm  
# End of macro DMARK
2dbe						CALLMONITOR 
2dbe cd 7e 16			call break_point_state  
2dc1				endm  
# End of macro CALLMONITOR
2dc1					endif 
2dc1			 
2dc1 19					add hl, de 
2dc2			 
2dc2					if DEBUG_FORTH_WORDS 
2dc2						DMARK "+2+" 
2dc2 f5				push af  
2dc3 3a d7 2d			ld a, (.dmark)  
2dc6 32 b4 fb			ld (debug_mark),a  
2dc9 3a d8 2d			ld a, (.dmark+1)  
2dcc 32 b5 fb			ld (debug_mark+1),a  
2dcf 3a d9 2d			ld a, (.dmark+2)  
2dd2 32 b6 fb			ld (debug_mark+2),a  
2dd5 18 03			jr .pastdmark  
2dd7 ..			.dmark: db "+2+"  
2dda f1			.pastdmark: pop af  
2ddb			endm  
# End of macro DMARK
2ddb						CALLMONITOR 
2ddb cd 7e 16			call break_point_state  
2dde				endm  
# End of macro CALLMONITOR
2dde					endif 
2dde			 
2dde					; move result to de 
2dde			 
2dde eb					ex de, hl 
2ddf			 
2ddf					; Address 
2ddf			 
2ddf e1					pop hl 
2de0			 
2de0					; save it back 
2de0			 
2de0 73					ld (hl), e 
2de1 23					inc hl 
2de2 72					ld (hl), d 
2de3			 
2de3					if DEBUG_FORTH_WORDS 
2de3						DMARK "+2e" 
2de3 f5				push af  
2de4 3a f8 2d			ld a, (.dmark)  
2de7 32 b4 fb			ld (debug_mark),a  
2dea 3a f9 2d			ld a, (.dmark+1)  
2ded 32 b5 fb			ld (debug_mark+1),a  
2df0 3a fa 2d			ld a, (.dmark+2)  
2df3 32 b6 fb			ld (debug_mark+2),a  
2df6 18 03			jr .pastdmark  
2df8 ..			.dmark: db "+2e"  
2dfb f1			.pastdmark: pop af  
2dfc			endm  
# End of macro DMARK
2dfc						CALLMONITOR 
2dfc cd 7e 16			call break_point_state  
2dff				endm  
# End of macro CALLMONITOR
2dff					endif 
2dff			 
2dff			 
2dff			 
2dff			 
2dff			 
2dff				       NEXTW 
2dff c3 44 20			jp macro_next 
2e02				endm 
# End of macro NEXTW
2e02			 
2e02			.DEC2: 
2e02				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e02 6f				db WORD_SYS_CORE+91             
2e03 ae 2e			dw .GET2            
2e05 04				db 3 + 1 
2e06 .. 00			db "-2!",0              
2e0a				endm 
# End of macro CWHEAD
2e0a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e0a			 
2e0a			 
2e0a					if DEBUG_FORTH_WORDS_KEY 
2e0a						DMARK "-2s" 
2e0a f5				push af  
2e0b 3a 1f 2e			ld a, (.dmark)  
2e0e 32 b4 fb			ld (debug_mark),a  
2e11 3a 20 2e			ld a, (.dmark+1)  
2e14 32 b5 fb			ld (debug_mark+1),a  
2e17 3a 21 2e			ld a, (.dmark+2)  
2e1a 32 b6 fb			ld (debug_mark+2),a  
2e1d 18 03			jr .pastdmark  
2e1f ..			.dmark: db "-2s"  
2e22 f1			.pastdmark: pop af  
2e23			endm  
# End of macro DMARK
2e23						CALLMONITOR 
2e23 cd 7e 16			call break_point_state  
2e26				endm  
# End of macro CALLMONITOR
2e26					endif 
2e26			 
2e26					; Address 
2e26			 
2e26					FORTH_DSP_VALUEHL 
2e26 cd d2 1e			call macro_dsp_valuehl 
2e29				endm 
# End of macro FORTH_DSP_VALUEHL
2e29			 
2e29 e5					push hl    ; save address 
2e2a			 
2e2a					; load content into de 
2e2a			 
2e2a 5e					ld e,(hl) 
2e2b 23					inc hl 
2e2c 56					ld d, (hl) 
2e2d			 
2e2d					if DEBUG_FORTH_WORDS 
2e2d						DMARK "-2a" 
2e2d f5				push af  
2e2e 3a 42 2e			ld a, (.dmark)  
2e31 32 b4 fb			ld (debug_mark),a  
2e34 3a 43 2e			ld a, (.dmark+1)  
2e37 32 b5 fb			ld (debug_mark+1),a  
2e3a 3a 44 2e			ld a, (.dmark+2)  
2e3d 32 b6 fb			ld (debug_mark+2),a  
2e40 18 03			jr .pastdmark  
2e42 ..			.dmark: db "-2a"  
2e45 f1			.pastdmark: pop af  
2e46			endm  
# End of macro DMARK
2e46						CALLMONITOR 
2e46 cd 7e 16			call break_point_state  
2e49				endm  
# End of macro CALLMONITOR
2e49					endif 
2e49			 
2e49					FORTH_DSP_POP 
2e49 cd 8a 1f			call macro_forth_dsp_pop 
2e4c				endm 
# End of macro FORTH_DSP_POP
2e4c			 
2e4c					; Get value to remove 
2e4c			 
2e4c					FORTH_DSP_VALUE 
2e4c cd bb 1e			call macro_forth_dsp_value 
2e4f				endm 
# End of macro FORTH_DSP_VALUE
2e4f			 
2e4f					if DEBUG_FORTH_WORDS 
2e4f						DMARK "-2v" 
2e4f f5				push af  
2e50 3a 64 2e			ld a, (.dmark)  
2e53 32 b4 fb			ld (debug_mark),a  
2e56 3a 65 2e			ld a, (.dmark+1)  
2e59 32 b5 fb			ld (debug_mark+1),a  
2e5c 3a 66 2e			ld a, (.dmark+2)  
2e5f 32 b6 fb			ld (debug_mark+2),a  
2e62 18 03			jr .pastdmark  
2e64 ..			.dmark: db "-2v"  
2e67 f1			.pastdmark: pop af  
2e68			endm  
# End of macro DMARK
2e68						CALLMONITOR 
2e68 cd 7e 16			call break_point_state  
2e6b				endm  
# End of macro CALLMONITOR
2e6b					endif 
2e6b			 
2e6b eb					ex de, hl 
2e6c ed 52				sbc hl, de 
2e6e			 
2e6e					if DEBUG_FORTH_WORDS 
2e6e						DMARK "-2d" 
2e6e f5				push af  
2e6f 3a 83 2e			ld a, (.dmark)  
2e72 32 b4 fb			ld (debug_mark),a  
2e75 3a 84 2e			ld a, (.dmark+1)  
2e78 32 b5 fb			ld (debug_mark+1),a  
2e7b 3a 85 2e			ld a, (.dmark+2)  
2e7e 32 b6 fb			ld (debug_mark+2),a  
2e81 18 03			jr .pastdmark  
2e83 ..			.dmark: db "-2d"  
2e86 f1			.pastdmark: pop af  
2e87			endm  
# End of macro DMARK
2e87						CALLMONITOR 
2e87 cd 7e 16			call break_point_state  
2e8a				endm  
# End of macro CALLMONITOR
2e8a					endif 
2e8a			 
2e8a					; move result to de 
2e8a			 
2e8a eb					ex de, hl 
2e8b			 
2e8b					; Address 
2e8b			 
2e8b e1					pop hl 
2e8c			 
2e8c					; save it back 
2e8c			 
2e8c 73					ld (hl), e 
2e8d 23					inc hl 
2e8e 72					ld (hl), d 
2e8f			 
2e8f					if DEBUG_FORTH_WORDS 
2e8f						DMARK "-2e" 
2e8f f5				push af  
2e90 3a a4 2e			ld a, (.dmark)  
2e93 32 b4 fb			ld (debug_mark),a  
2e96 3a a5 2e			ld a, (.dmark+1)  
2e99 32 b5 fb			ld (debug_mark+1),a  
2e9c 3a a6 2e			ld a, (.dmark+2)  
2e9f 32 b6 fb			ld (debug_mark+2),a  
2ea2 18 03			jr .pastdmark  
2ea4 ..			.dmark: db "-2e"  
2ea7 f1			.pastdmark: pop af  
2ea8			endm  
# End of macro DMARK
2ea8						CALLMONITOR 
2ea8 cd 7e 16			call break_point_state  
2eab				endm  
# End of macro CALLMONITOR
2eab					endif 
2eab			 
2eab			 
2eab			 
2eab			 
2eab			 
2eab				       NEXTW 
2eab c3 44 20			jp macro_next 
2eae				endm 
# End of macro NEXTW
2eae			.GET2: 
2eae				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2eae 6f				db WORD_SYS_CORE+91             
2eaf de 2e			dw .BANG2            
2eb1 03				db 2 + 1 
2eb2 .. 00			db "2@",0              
2eb5				endm 
# End of macro CWHEAD
2eb5			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2eb5					if DEBUG_FORTH_WORDS_KEY 
2eb5						DMARK "2A_" 
2eb5 f5				push af  
2eb6 3a ca 2e			ld a, (.dmark)  
2eb9 32 b4 fb			ld (debug_mark),a  
2ebc 3a cb 2e			ld a, (.dmark+1)  
2ebf 32 b5 fb			ld (debug_mark+1),a  
2ec2 3a cc 2e			ld a, (.dmark+2)  
2ec5 32 b6 fb			ld (debug_mark+2),a  
2ec8 18 03			jr .pastdmark  
2eca ..			.dmark: db "2A_"  
2ecd f1			.pastdmark: pop af  
2ece			endm  
# End of macro DMARK
2ece						CALLMONITOR 
2ece cd 7e 16			call break_point_state  
2ed1				endm  
# End of macro CALLMONITOR
2ed1					endif 
2ed1			 
2ed1					FORTH_DSP_VALUEHL 
2ed1 cd d2 1e			call macro_dsp_valuehl 
2ed4				endm 
# End of macro FORTH_DSP_VALUEHL
2ed4			 
2ed4 5e					ld e, (hl) 
2ed5 23					inc hl 
2ed6 56					ld d, (hl) 
2ed7			 
2ed7 eb					ex de, hl 
2ed8			 
2ed8 cd db 1c				call forth_push_numhl 
2edb			 
2edb				       NEXTW 
2edb c3 44 20			jp macro_next 
2ede				endm 
# End of macro NEXTW
2ede			.BANG2: 
2ede				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ede 6f				db WORD_SYS_CORE+91             
2edf 16 2f			dw .CONFIG            
2ee1 03				db 2 + 1 
2ee2 .. 00			db "2!",0              
2ee5				endm 
# End of macro CWHEAD
2ee5			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ee5					if DEBUG_FORTH_WORDS_KEY 
2ee5						DMARK "2S_" 
2ee5 f5				push af  
2ee6 3a fa 2e			ld a, (.dmark)  
2ee9 32 b4 fb			ld (debug_mark),a  
2eec 3a fb 2e			ld a, (.dmark+1)  
2eef 32 b5 fb			ld (debug_mark+1),a  
2ef2 3a fc 2e			ld a, (.dmark+2)  
2ef5 32 b6 fb			ld (debug_mark+2),a  
2ef8 18 03			jr .pastdmark  
2efa ..			.dmark: db "2S_"  
2efd f1			.pastdmark: pop af  
2efe			endm  
# End of macro DMARK
2efe						CALLMONITOR 
2efe cd 7e 16			call break_point_state  
2f01				endm  
# End of macro CALLMONITOR
2f01					endif 
2f01			 
2f01					FORTH_DSP_VALUEHL 
2f01 cd d2 1e			call macro_dsp_valuehl 
2f04				endm 
# End of macro FORTH_DSP_VALUEHL
2f04			 
2f04 e5					push hl   ; save address 
2f05			 
2f05			 
2f05					FORTH_DSP_POP 
2f05 cd 8a 1f			call macro_forth_dsp_pop 
2f08				endm 
# End of macro FORTH_DSP_POP
2f08			 
2f08					 
2f08					FORTH_DSP_VALUEHL 
2f08 cd d2 1e			call macro_dsp_valuehl 
2f0b				endm 
# End of macro FORTH_DSP_VALUEHL
2f0b			 
2f0b					FORTH_DSP_POP 
2f0b cd 8a 1f			call macro_forth_dsp_pop 
2f0e				endm 
# End of macro FORTH_DSP_POP
2f0e			 
2f0e eb					ex de, hl    ; value now in de 
2f0f			 
2f0f e1					pop hl 
2f10			 
2f10 73					ld (hl), e 
2f11			 
2f11 23					inc hl 
2f12			 
2f12 72					ld (hl), d 
2f13			 
2f13			 
2f13				       NEXTW 
2f13 c3 44 20			jp macro_next 
2f16				endm 
# End of macro NEXTW
2f16			.CONFIG: 
2f16				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f16 6f				db WORD_SYS_CORE+91             
2f17 27 2f			dw .ENDCORE            
2f19 07				db 6 + 1 
2f1a .. 00			db "CONFIG",0              
2f21				endm 
# End of macro CWHEAD
2f21			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f21			 
2f21 cd 61 13				call config 
2f24					NEXTW 
2f24 c3 44 20			jp macro_next 
2f27				endm 
# End of macro NEXTW
2f27			.ENDCORE: 
2f27			 
2f27			; eof 
2f27			 
2f27			 
# End of file forth_words_core.asm
2f27			include "forth_words_flow.asm" 
2f27			 
2f27			; | ## Program Flow Words 
2f27			 
2f27			.IF: 
2f27				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f27 1e				db WORD_SYS_CORE+10             
2f28 1c 30			dw .THEN            
2f2a 03				db 2 + 1 
2f2b .. 00			db "IF",0              
2f2e				endm 
# End of macro CWHEAD
2f2e			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f2e			; 
2f2e					if DEBUG_FORTH_WORDS_KEY 
2f2e						DMARK "IF." 
2f2e f5				push af  
2f2f 3a 43 2f			ld a, (.dmark)  
2f32 32 b4 fb			ld (debug_mark),a  
2f35 3a 44 2f			ld a, (.dmark+1)  
2f38 32 b5 fb			ld (debug_mark+1),a  
2f3b 3a 45 2f			ld a, (.dmark+2)  
2f3e 32 b6 fb			ld (debug_mark+2),a  
2f41 18 03			jr .pastdmark  
2f43 ..			.dmark: db "IF."  
2f46 f1			.pastdmark: pop af  
2f47			endm  
# End of macro DMARK
2f47						CALLMONITOR 
2f47 cd 7e 16			call break_point_state  
2f4a				endm  
# End of macro CALLMONITOR
2f4a					endif 
2f4a			; eval TOS 
2f4a			 
2f4a				FORTH_DSP_VALUEHL 
2f4a cd d2 1e			call macro_dsp_valuehl 
2f4d				endm 
# End of macro FORTH_DSP_VALUEHL
2f4d			 
2f4d			;	push hl 
2f4d				FORTH_DSP_POP 
2f4d cd 8a 1f			call macro_forth_dsp_pop 
2f50				endm 
# End of macro FORTH_DSP_POP
2f50			;	pop hl 
2f50			 
2f50					if DEBUG_FORTH_WORDS 
2f50						DMARK "IF1" 
2f50 f5				push af  
2f51 3a 65 2f			ld a, (.dmark)  
2f54 32 b4 fb			ld (debug_mark),a  
2f57 3a 66 2f			ld a, (.dmark+1)  
2f5a 32 b5 fb			ld (debug_mark+1),a  
2f5d 3a 67 2f			ld a, (.dmark+2)  
2f60 32 b6 fb			ld (debug_mark+2),a  
2f63 18 03			jr .pastdmark  
2f65 ..			.dmark: db "IF1"  
2f68 f1			.pastdmark: pop af  
2f69			endm  
# End of macro DMARK
2f69						CALLMONITOR 
2f69 cd 7e 16			call break_point_state  
2f6c				endm  
# End of macro CALLMONITOR
2f6c					endif 
2f6c b7				or a        ; clear carry flag 
2f6d 11 00 00			ld de, 0 
2f70 eb				ex de,hl 
2f71 ed 52			sbc hl, de 
2f73 c2 fd 2f			jp nz, .iftrue 
2f76			 
2f76					if DEBUG_FORTH_WORDS 
2f76						DMARK "IF2" 
2f76 f5				push af  
2f77 3a 8b 2f			ld a, (.dmark)  
2f7a 32 b4 fb			ld (debug_mark),a  
2f7d 3a 8c 2f			ld a, (.dmark+1)  
2f80 32 b5 fb			ld (debug_mark+1),a  
2f83 3a 8d 2f			ld a, (.dmark+2)  
2f86 32 b6 fb			ld (debug_mark+2),a  
2f89 18 03			jr .pastdmark  
2f8b ..			.dmark: db "IF2"  
2f8e f1			.pastdmark: pop af  
2f8f			endm  
# End of macro DMARK
2f8f						CALLMONITOR 
2f8f cd 7e 16			call break_point_state  
2f92				endm  
# End of macro CALLMONITOR
2f92					endif 
2f92			 
2f92			; if not true then skip to THEN 
2f92			 
2f92				; TODO get tok_ptr 
2f92				; TODO consume toks until we get to THEN 
2f92			 
2f92 2a 9b f2			ld hl, (os_tok_ptr) 
2f95					if DEBUG_FORTH_WORDS 
2f95						DMARK "IF3" 
2f95 f5				push af  
2f96 3a aa 2f			ld a, (.dmark)  
2f99 32 b4 fb			ld (debug_mark),a  
2f9c 3a ab 2f			ld a, (.dmark+1)  
2f9f 32 b5 fb			ld (debug_mark+1),a  
2fa2 3a ac 2f			ld a, (.dmark+2)  
2fa5 32 b6 fb			ld (debug_mark+2),a  
2fa8 18 03			jr .pastdmark  
2faa ..			.dmark: db "IF3"  
2fad f1			.pastdmark: pop af  
2fae			endm  
# End of macro DMARK
2fae						CALLMONITOR 
2fae cd 7e 16			call break_point_state  
2fb1				endm  
# End of macro CALLMONITOR
2fb1						 
2fb1					endif 
2fb1 11 f8 2f			ld de, .ifthen 
2fb4					if DEBUG_FORTH_WORDS 
2fb4						DMARK "IF4" 
2fb4 f5				push af  
2fb5 3a c9 2f			ld a, (.dmark)  
2fb8 32 b4 fb			ld (debug_mark),a  
2fbb 3a ca 2f			ld a, (.dmark+1)  
2fbe 32 b5 fb			ld (debug_mark+1),a  
2fc1 3a cb 2f			ld a, (.dmark+2)  
2fc4 32 b6 fb			ld (debug_mark+2),a  
2fc7 18 03			jr .pastdmark  
2fc9 ..			.dmark: db "IF4"  
2fcc f1			.pastdmark: pop af  
2fcd			endm  
# End of macro DMARK
2fcd						CALLMONITOR 
2fcd cd 7e 16			call break_point_state  
2fd0				endm  
# End of macro CALLMONITOR
2fd0					endif 
2fd0 cd 5f 21			call findnexttok  
2fd3			 
2fd3					if DEBUG_FORTH_WORDS 
2fd3						DMARK "IF5" 
2fd3 f5				push af  
2fd4 3a e8 2f			ld a, (.dmark)  
2fd7 32 b4 fb			ld (debug_mark),a  
2fda 3a e9 2f			ld a, (.dmark+1)  
2fdd 32 b5 fb			ld (debug_mark+1),a  
2fe0 3a ea 2f			ld a, (.dmark+2)  
2fe3 32 b6 fb			ld (debug_mark+2),a  
2fe6 18 03			jr .pastdmark  
2fe8 ..			.dmark: db "IF5"  
2feb f1			.pastdmark: pop af  
2fec			endm  
# End of macro DMARK
2fec						CALLMONITOR 
2fec cd 7e 16			call break_point_state  
2fef				endm  
# End of macro CALLMONITOR
2fef					endif 
2fef				; TODO replace below with ; exec using tok_ptr 
2fef 22 9b f2			ld (os_tok_ptr), hl 
2ff2 c3 d5 20			jp exec1 
2ff5				NEXTW 
2ff5 c3 44 20			jp macro_next 
2ff8				endm 
# End of macro NEXTW
2ff8			 
2ff8 .. 00		.ifthen:  db "THEN",0 
2ffd			 
2ffd			.iftrue:		 
2ffd				; Exec next words normally 
2ffd			 
2ffd				; if true then exec following IF as normal 
2ffd					if DEBUG_FORTH_WORDS 
2ffd						DMARK "IFT" 
2ffd f5				push af  
2ffe 3a 12 30			ld a, (.dmark)  
3001 32 b4 fb			ld (debug_mark),a  
3004 3a 13 30			ld a, (.dmark+1)  
3007 32 b5 fb			ld (debug_mark+1),a  
300a 3a 14 30			ld a, (.dmark+2)  
300d 32 b6 fb			ld (debug_mark+2),a  
3010 18 03			jr .pastdmark  
3012 ..			.dmark: db "IFT"  
3015 f1			.pastdmark: pop af  
3016			endm  
# End of macro DMARK
3016						CALLMONITOR 
3016 cd 7e 16			call break_point_state  
3019				endm  
# End of macro CALLMONITOR
3019					endif 
3019			 
3019					NEXTW 
3019 c3 44 20			jp macro_next 
301c				endm 
# End of macro NEXTW
301c			.THEN: 
301c				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
301c 1f				db WORD_SYS_CORE+11             
301d 44 30			dw .ELSE            
301f 05				db 4 + 1 
3020 .. 00			db "THEN",0              
3025				endm 
# End of macro CWHEAD
3025			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3025					if DEBUG_FORTH_WORDS_KEY 
3025						DMARK "THN" 
3025 f5				push af  
3026 3a 3a 30			ld a, (.dmark)  
3029 32 b4 fb			ld (debug_mark),a  
302c 3a 3b 30			ld a, (.dmark+1)  
302f 32 b5 fb			ld (debug_mark+1),a  
3032 3a 3c 30			ld a, (.dmark+2)  
3035 32 b6 fb			ld (debug_mark+2),a  
3038 18 03			jr .pastdmark  
303a ..			.dmark: db "THN"  
303d f1			.pastdmark: pop af  
303e			endm  
# End of macro DMARK
303e						CALLMONITOR 
303e cd 7e 16			call break_point_state  
3041				endm  
# End of macro CALLMONITOR
3041					endif 
3041					NEXTW 
3041 c3 44 20			jp macro_next 
3044				endm 
# End of macro NEXTW
3044			.ELSE: 
3044				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3044 20				db WORD_SYS_CORE+12             
3045 6c 30			dw .DO            
3047 03				db 2 + 1 
3048 .. 00			db "ELSE",0              
304d				endm 
# End of macro CWHEAD
304d			; | ELSE ( -- ) Not supported - does nothing | TODO 
304d			 
304d					if DEBUG_FORTH_WORDS_KEY 
304d						DMARK "ELS" 
304d f5				push af  
304e 3a 62 30			ld a, (.dmark)  
3051 32 b4 fb			ld (debug_mark),a  
3054 3a 63 30			ld a, (.dmark+1)  
3057 32 b5 fb			ld (debug_mark+1),a  
305a 3a 64 30			ld a, (.dmark+2)  
305d 32 b6 fb			ld (debug_mark+2),a  
3060 18 03			jr .pastdmark  
3062 ..			.dmark: db "ELS"  
3065 f1			.pastdmark: pop af  
3066			endm  
# End of macro DMARK
3066						CALLMONITOR 
3066 cd 7e 16			call break_point_state  
3069				endm  
# End of macro CALLMONITOR
3069					endif 
3069			 
3069			 
3069					NEXTW 
3069 c3 44 20			jp macro_next 
306c				endm 
# End of macro NEXTW
306c			.DO: 
306c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
306c 21				db WORD_SYS_CORE+13             
306d 93 31			dw .LOOP            
306f 03				db 2 + 1 
3070 .. 00			db "DO",0              
3073				endm 
# End of macro CWHEAD
3073			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3073			 
3073					if DEBUG_FORTH_WORDS_KEY 
3073						DMARK "DO." 
3073 f5				push af  
3074 3a 88 30			ld a, (.dmark)  
3077 32 b4 fb			ld (debug_mark),a  
307a 3a 89 30			ld a, (.dmark+1)  
307d 32 b5 fb			ld (debug_mark+1),a  
3080 3a 8a 30			ld a, (.dmark+2)  
3083 32 b6 fb			ld (debug_mark+2),a  
3086 18 03			jr .pastdmark  
3088 ..			.dmark: db "DO."  
308b f1			.pastdmark: pop af  
308c			endm  
# End of macro DMARK
308c						CALLMONITOR 
308c cd 7e 16			call break_point_state  
308f				endm  
# End of macro CALLMONITOR
308f					endif 
308f			;  push pc to rsp stack past the DO 
308f			 
308f 2a 9b f2				ld hl, (os_tok_ptr) 
3092 23					inc hl   ; D 
3093 23					inc hl  ; O 
3094 23					inc hl   ; null 
3095					if DEBUG_FORTH_WORDS 
3095						DMARK "DO2" 
3095 f5				push af  
3096 3a aa 30			ld a, (.dmark)  
3099 32 b4 fb			ld (debug_mark),a  
309c 3a ab 30			ld a, (.dmark+1)  
309f 32 b5 fb			ld (debug_mark+1),a  
30a2 3a ac 30			ld a, (.dmark+2)  
30a5 32 b6 fb			ld (debug_mark+2),a  
30a8 18 03			jr .pastdmark  
30aa ..			.dmark: db "DO2"  
30ad f1			.pastdmark: pop af  
30ae			endm  
# End of macro DMARK
30ae						CALLMONITOR 
30ae cd 7e 16			call break_point_state  
30b1				endm  
# End of macro CALLMONITOR
30b1					endif 
30b1					FORTH_RSP_NEXT 
30b1 cd 82 1c			call macro_forth_rsp_next 
30b4				endm 
# End of macro FORTH_RSP_NEXT
30b4					if DEBUG_FORTH_WORDS 
30b4						DMARK "DO3" 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 b4 fb			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 b5 fb			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 b6 fb			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "DO3"  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd						CALLMONITOR 
30cd cd 7e 16			call break_point_state  
30d0				endm  
# End of macro CALLMONITOR
30d0					endif 
30d0			 
30d0					;if DEBUG_FORTH_WORDS 
30d0				;		push hl 
30d0			;		endif  
30d0			 
30d0			; get counters from data stack 
30d0			 
30d0			 
30d0					FORTH_DSP_VALUEHL 
30d0 cd d2 1e			call macro_dsp_valuehl 
30d3				endm 
# End of macro FORTH_DSP_VALUEHL
30d3 e5					push hl		 ; hl now has starting counter which needs to be tos 
30d4			 
30d4					if DEBUG_FORTH_WORDS 
30d4						DMARK "DO4" 
30d4 f5				push af  
30d5 3a e9 30			ld a, (.dmark)  
30d8 32 b4 fb			ld (debug_mark),a  
30db 3a ea 30			ld a, (.dmark+1)  
30de 32 b5 fb			ld (debug_mark+1),a  
30e1 3a eb 30			ld a, (.dmark+2)  
30e4 32 b6 fb			ld (debug_mark+2),a  
30e7 18 03			jr .pastdmark  
30e9 ..			.dmark: db "DO4"  
30ec f1			.pastdmark: pop af  
30ed			endm  
# End of macro DMARK
30ed						CALLMONITOR 
30ed cd 7e 16			call break_point_state  
30f0				endm  
# End of macro CALLMONITOR
30f0					endif 
30f0					FORTH_DSP_POP 
30f0 cd 8a 1f			call macro_forth_dsp_pop 
30f3				endm 
# End of macro FORTH_DSP_POP
30f3			 
30f3					if DEBUG_FORTH_WORDS 
30f3						DMARK "DO5" 
30f3 f5				push af  
30f4 3a 08 31			ld a, (.dmark)  
30f7 32 b4 fb			ld (debug_mark),a  
30fa 3a 09 31			ld a, (.dmark+1)  
30fd 32 b5 fb			ld (debug_mark+1),a  
3100 3a 0a 31			ld a, (.dmark+2)  
3103 32 b6 fb			ld (debug_mark+2),a  
3106 18 03			jr .pastdmark  
3108 ..			.dmark: db "DO5"  
310b f1			.pastdmark: pop af  
310c			endm  
# End of macro DMARK
310c						CALLMONITOR 
310c cd 7e 16			call break_point_state  
310f				endm  
# End of macro CALLMONITOR
310f					endif 
310f			 
310f					FORTH_DSP_VALUEHL 
310f cd d2 1e			call macro_dsp_valuehl 
3112				endm 
# End of macro FORTH_DSP_VALUEHL
3112			;		push hl		 ; hl now has starting limit counter 
3112			 
3112					if DEBUG_FORTH_WORDS 
3112						DMARK "DO6" 
3112 f5				push af  
3113 3a 27 31			ld a, (.dmark)  
3116 32 b4 fb			ld (debug_mark),a  
3119 3a 28 31			ld a, (.dmark+1)  
311c 32 b5 fb			ld (debug_mark+1),a  
311f 3a 29 31			ld a, (.dmark+2)  
3122 32 b6 fb			ld (debug_mark+2),a  
3125 18 03			jr .pastdmark  
3127 ..			.dmark: db "DO6"  
312a f1			.pastdmark: pop af  
312b			endm  
# End of macro DMARK
312b						CALLMONITOR 
312b cd 7e 16			call break_point_state  
312e				endm  
# End of macro CALLMONITOR
312e					endif 
312e					FORTH_DSP_POP 
312e cd 8a 1f			call macro_forth_dsp_pop 
3131				endm 
# End of macro FORTH_DSP_POP
3131			 
3131			; put counters on the loop stack 
3131			 
3131			;		pop hl			 ; limit counter 
3131 d1					pop de			; start counter 
3132			 
3132					; push limit counter 
3132			 
3132					if DEBUG_FORTH_WORDS 
3132						DMARK "DO7" 
3132 f5				push af  
3133 3a 47 31			ld a, (.dmark)  
3136 32 b4 fb			ld (debug_mark),a  
3139 3a 48 31			ld a, (.dmark+1)  
313c 32 b5 fb			ld (debug_mark+1),a  
313f 3a 49 31			ld a, (.dmark+2)  
3142 32 b6 fb			ld (debug_mark+2),a  
3145 18 03			jr .pastdmark  
3147 ..			.dmark: db "DO7"  
314a f1			.pastdmark: pop af  
314b			endm  
# End of macro DMARK
314b						CALLMONITOR 
314b cd 7e 16			call break_point_state  
314e				endm  
# End of macro CALLMONITOR
314e					endif 
314e					FORTH_LOOP_NEXT 
314e cd 03 1f			call macro_forth_loop_next 
3151				endm 
# End of macro FORTH_LOOP_NEXT
3151			 
3151					; push start counter 
3151			 
3151 eb					ex de, hl 
3152					if DEBUG_FORTH_WORDS 
3152						DMARK "DO7" 
3152 f5				push af  
3153 3a 67 31			ld a, (.dmark)  
3156 32 b4 fb			ld (debug_mark),a  
3159 3a 68 31			ld a, (.dmark+1)  
315c 32 b5 fb			ld (debug_mark+1),a  
315f 3a 69 31			ld a, (.dmark+2)  
3162 32 b6 fb			ld (debug_mark+2),a  
3165 18 03			jr .pastdmark  
3167 ..			.dmark: db "DO7"  
316a f1			.pastdmark: pop af  
316b			endm  
# End of macro DMARK
316b						CALLMONITOR 
316b cd 7e 16			call break_point_state  
316e				endm  
# End of macro CALLMONITOR
316e					endif 
316e					FORTH_LOOP_NEXT 
316e cd 03 1f			call macro_forth_loop_next 
3171				endm 
# End of macro FORTH_LOOP_NEXT
3171			 
3171			 
3171					; init first round of I counter 
3171			 
3171 22 bf f2				ld (os_current_i), hl 
3174			 
3174					if DEBUG_FORTH_WORDS 
3174						DMARK "DO8" 
3174 f5				push af  
3175 3a 89 31			ld a, (.dmark)  
3178 32 b4 fb			ld (debug_mark),a  
317b 3a 8a 31			ld a, (.dmark+1)  
317e 32 b5 fb			ld (debug_mark+1),a  
3181 3a 8b 31			ld a, (.dmark+2)  
3184 32 b6 fb			ld (debug_mark+2),a  
3187 18 03			jr .pastdmark  
3189 ..			.dmark: db "DO8"  
318c f1			.pastdmark: pop af  
318d			endm  
# End of macro DMARK
318d						CALLMONITOR 
318d cd 7e 16			call break_point_state  
3190				endm  
# End of macro CALLMONITOR
3190					endif 
3190			 
3190					NEXTW 
3190 c3 44 20			jp macro_next 
3193				endm 
# End of macro NEXTW
3193			.LOOP: 
3193				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3193 22				db WORD_SYS_CORE+14             
3194 ab 32			dw .I            
3196 05				db 4 + 1 
3197 .. 00			db "LOOP",0              
319c				endm 
# End of macro CWHEAD
319c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
319c			 
319c				; pop tos as current loop count to hl 
319c			 
319c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
319c			 
319c				FORTH_LOOP_TOS 
319c cd 36 1f			call macro_forth_loop_tos 
319f				endm 
# End of macro FORTH_LOOP_TOS
319f e5				push hl 
31a0			 
31a0					if DEBUG_FORTH_WORDS_KEY 
31a0						DMARK "LOP" 
31a0 f5				push af  
31a1 3a b5 31			ld a, (.dmark)  
31a4 32 b4 fb			ld (debug_mark),a  
31a7 3a b6 31			ld a, (.dmark+1)  
31aa 32 b5 fb			ld (debug_mark+1),a  
31ad 3a b7 31			ld a, (.dmark+2)  
31b0 32 b6 fb			ld (debug_mark+2),a  
31b3 18 03			jr .pastdmark  
31b5 ..			.dmark: db "LOP"  
31b8 f1			.pastdmark: pop af  
31b9			endm  
# End of macro DMARK
31b9						CALLMONITOR 
31b9 cd 7e 16			call break_point_state  
31bc				endm  
# End of macro CALLMONITOR
31bc					endif 
31bc				; next item on the stack is the limit. get it 
31bc			 
31bc			 
31bc				FORTH_LOOP_POP 
31bc cd 40 1f			call macro_forth_loop_pop 
31bf				endm 
# End of macro FORTH_LOOP_POP
31bf			 
31bf				FORTH_LOOP_TOS 
31bf cd 36 1f			call macro_forth_loop_tos 
31c2				endm 
# End of macro FORTH_LOOP_TOS
31c2			 
31c2 d1				pop de		 ; de = i, hl = limit 
31c3			 
31c3					if DEBUG_FORTH_WORDS 
31c3						DMARK "LP1" 
31c3 f5				push af  
31c4 3a d8 31			ld a, (.dmark)  
31c7 32 b4 fb			ld (debug_mark),a  
31ca 3a d9 31			ld a, (.dmark+1)  
31cd 32 b5 fb			ld (debug_mark+1),a  
31d0 3a da 31			ld a, (.dmark+2)  
31d3 32 b6 fb			ld (debug_mark+2),a  
31d6 18 03			jr .pastdmark  
31d8 ..			.dmark: db "LP1"  
31db f1			.pastdmark: pop af  
31dc			endm  
# End of macro DMARK
31dc						CALLMONITOR 
31dc cd 7e 16			call break_point_state  
31df				endm  
# End of macro CALLMONITOR
31df					endif 
31df			 
31df				; go back to previous word 
31df			 
31df d5				push de    ; save I for inc later 
31e0			 
31e0			 
31e0				; get limit 
31e0				;  is I at limit? 
31e0			 
31e0			 
31e0					if DEBUG_FORTH_WORDS 
31e0						DMARK "LP1" 
31e0 f5				push af  
31e1 3a f5 31			ld a, (.dmark)  
31e4 32 b4 fb			ld (debug_mark),a  
31e7 3a f6 31			ld a, (.dmark+1)  
31ea 32 b5 fb			ld (debug_mark+1),a  
31ed 3a f7 31			ld a, (.dmark+2)  
31f0 32 b6 fb			ld (debug_mark+2),a  
31f3 18 03			jr .pastdmark  
31f5 ..			.dmark: db "LP1"  
31f8 f1			.pastdmark: pop af  
31f9			endm  
# End of macro DMARK
31f9						CALLMONITOR 
31f9 cd 7e 16			call break_point_state  
31fc				endm  
# End of macro CALLMONITOR
31fc					endif 
31fc			 
31fc ed 52			sbc hl, de 
31fe			 
31fe			 
31fe				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31fe			 
31fe 20 26				jr nz, .loopnotdone 
3200			 
3200 e1				pop hl   ; get rid of saved I 
3201				FORTH_LOOP_POP     ; get rid of limit 
3201 cd 40 1f			call macro_forth_loop_pop 
3204				endm 
# End of macro FORTH_LOOP_POP
3204			 
3204				FORTH_RSP_POP     ; get rid of DO ptr 
3204 cd a3 1c			call macro_forth_rsp_pop 
3207				endm 
# End of macro FORTH_RSP_POP
3207			 
3207			if DEBUG_FORTH_WORDS 
3207						DMARK "LP>" 
3207 f5				push af  
3208 3a 1c 32			ld a, (.dmark)  
320b 32 b4 fb			ld (debug_mark),a  
320e 3a 1d 32			ld a, (.dmark+1)  
3211 32 b5 fb			ld (debug_mark+1),a  
3214 3a 1e 32			ld a, (.dmark+2)  
3217 32 b6 fb			ld (debug_mark+2),a  
321a 18 03			jr .pastdmark  
321c ..			.dmark: db "LP>"  
321f f1			.pastdmark: pop af  
3220			endm  
# End of macro DMARK
3220				CALLMONITOR 
3220 cd 7e 16			call break_point_state  
3223				endm  
# End of macro CALLMONITOR
3223			endif 
3223			 
3223					NEXTW 
3223 c3 44 20			jp macro_next 
3226				endm 
# End of macro NEXTW
3226				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3226			 
3226			.loopnotdone: 
3226			 
3226 e1				pop hl    ; get I 
3227 23				inc hl 
3228			 
3228			   	; save new I 
3228			 
3228			 
3228					; set I counter 
3228			 
3228 22 bf f2				ld (os_current_i), hl 
322b			 
322b					if DEBUG_FORTH_WORDS 
322b						DMARK "LPN" 
322b f5				push af  
322c 3a 40 32			ld a, (.dmark)  
322f 32 b4 fb			ld (debug_mark),a  
3232 3a 41 32			ld a, (.dmark+1)  
3235 32 b5 fb			ld (debug_mark+1),a  
3238 3a 42 32			ld a, (.dmark+2)  
323b 32 b6 fb			ld (debug_mark+2),a  
323e 18 03			jr .pastdmark  
3240 ..			.dmark: db "LPN"  
3243 f1			.pastdmark: pop af  
3244			endm  
# End of macro DMARK
3244					CALLMONITOR 
3244 cd 7e 16			call break_point_state  
3247				endm  
# End of macro CALLMONITOR
3247					endif 
3247					 
3247				FORTH_LOOP_NEXT 
3247 cd 03 1f			call macro_forth_loop_next 
324a				endm 
# End of macro FORTH_LOOP_NEXT
324a			 
324a			 
324a					if DEBUG_FORTH_WORDS 
324a eb						ex de,hl 
324b					endif 
324b			 
324b			;	; get DO ptr 
324b			; 
324b					if DEBUG_FORTH_WORDS 
324b						DMARK "LP7" 
324b f5				push af  
324c 3a 60 32			ld a, (.dmark)  
324f 32 b4 fb			ld (debug_mark),a  
3252 3a 61 32			ld a, (.dmark+1)  
3255 32 b5 fb			ld (debug_mark+1),a  
3258 3a 62 32			ld a, (.dmark+2)  
325b 32 b6 fb			ld (debug_mark+2),a  
325e 18 03			jr .pastdmark  
3260 ..			.dmark: db "LP7"  
3263 f1			.pastdmark: pop af  
3264			endm  
# End of macro DMARK
3264					CALLMONITOR 
3264 cd 7e 16			call break_point_state  
3267				endm  
# End of macro CALLMONITOR
3267					endif 
3267				FORTH_RSP_TOS 
3267 cd 99 1c			call macro_forth_rsp_tos 
326a				endm 
# End of macro FORTH_RSP_TOS
326a			 
326a					if DEBUG_FORTH_WORDS 
326a						DMARK "LP8" 
326a f5				push af  
326b 3a 7f 32			ld a, (.dmark)  
326e 32 b4 fb			ld (debug_mark),a  
3271 3a 80 32			ld a, (.dmark+1)  
3274 32 b5 fb			ld (debug_mark+1),a  
3277 3a 81 32			ld a, (.dmark+2)  
327a 32 b6 fb			ld (debug_mark+2),a  
327d 18 03			jr .pastdmark  
327f ..			.dmark: db "LP8"  
3282 f1			.pastdmark: pop af  
3283			endm  
# End of macro DMARK
3283					CALLMONITOR 
3283 cd 7e 16			call break_point_state  
3286				endm  
# End of macro CALLMONITOR
3286					endif 
3286				;push hl 
3286			 
3286				; not going to DO any more 
3286				; get rid of the RSP pointer as DO will add it back in 
3286				;FORTH_RSP_POP 
3286				;pop hl 
3286			 
3286				;ld hl,(cli_ret_sp) 
3286				;ld e, (hl) 
3286				;inc hl 
3286				;ld d, (hl) 
3286				;ex de,hl 
3286 22 9b f2			ld (os_tok_ptr), hl 
3289					if DEBUG_FORTH_WORDS 
3289						DMARK "LP<" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 b4 fb			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 b5 fb			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 b6 fb			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "LP<"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2					CALLMONITOR 
32a2 cd 7e 16			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5				endif 
32a5 c3 d5 20			jp exec1 
32a8			 
32a8					 
32a8			 
32a8			 
32a8					NEXTW 
32a8 c3 44 20			jp macro_next 
32ab				endm 
# End of macro NEXTW
32ab			.I:  
32ab			 
32ab				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32ab 5e				db WORD_SYS_CORE+74             
32ac d6 32			dw .DLOOP            
32ae 02				db 1 + 1 
32af .. 00			db "I",0              
32b1				endm 
# End of macro CWHEAD
32b1			; | I ( -- ) Current loop counter | DONE 
32b1					if DEBUG_FORTH_WORDS_KEY 
32b1						DMARK "I.." 
32b1 f5				push af  
32b2 3a c6 32			ld a, (.dmark)  
32b5 32 b4 fb			ld (debug_mark),a  
32b8 3a c7 32			ld a, (.dmark+1)  
32bb 32 b5 fb			ld (debug_mark+1),a  
32be 3a c8 32			ld a, (.dmark+2)  
32c1 32 b6 fb			ld (debug_mark+2),a  
32c4 18 03			jr .pastdmark  
32c6 ..			.dmark: db "I.."  
32c9 f1			.pastdmark: pop af  
32ca			endm  
# End of macro DMARK
32ca						CALLMONITOR 
32ca cd 7e 16			call break_point_state  
32cd				endm  
# End of macro CALLMONITOR
32cd					endif 
32cd			 
32cd 2a bf f2				ld hl,(os_current_i) 
32d0 cd db 1c				call forth_push_numhl 
32d3			 
32d3					NEXTW 
32d3 c3 44 20			jp macro_next 
32d6				endm 
# End of macro NEXTW
32d6			.DLOOP: 
32d6				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32d6 5f				db WORD_SYS_CORE+75             
32d7 b7 33			dw .REPEAT            
32d9 06				db 5 + 1 
32da .. 00			db "-LOOP",0              
32e0				endm 
# End of macro CWHEAD
32e0			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32e0				; pop tos as current loop count to hl 
32e0					if DEBUG_FORTH_WORDS_KEY 
32e0						DMARK "-LP" 
32e0 f5				push af  
32e1 3a f5 32			ld a, (.dmark)  
32e4 32 b4 fb			ld (debug_mark),a  
32e7 3a f6 32			ld a, (.dmark+1)  
32ea 32 b5 fb			ld (debug_mark+1),a  
32ed 3a f7 32			ld a, (.dmark+2)  
32f0 32 b6 fb			ld (debug_mark+2),a  
32f3 18 03			jr .pastdmark  
32f5 ..			.dmark: db "-LP"  
32f8 f1			.pastdmark: pop af  
32f9			endm  
# End of macro DMARK
32f9						CALLMONITOR 
32f9 cd 7e 16			call break_point_state  
32fc				endm  
# End of macro CALLMONITOR
32fc					endif 
32fc			 
32fc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32fc			 
32fc				FORTH_LOOP_TOS 
32fc cd 36 1f			call macro_forth_loop_tos 
32ff				endm 
# End of macro FORTH_LOOP_TOS
32ff e5				push hl 
3300			 
3300					if DEBUG_FORTH_WORDS 
3300						DMARK "-LP" 
3300 f5				push af  
3301 3a 15 33			ld a, (.dmark)  
3304 32 b4 fb			ld (debug_mark),a  
3307 3a 16 33			ld a, (.dmark+1)  
330a 32 b5 fb			ld (debug_mark+1),a  
330d 3a 17 33			ld a, (.dmark+2)  
3310 32 b6 fb			ld (debug_mark+2),a  
3313 18 03			jr .pastdmark  
3315 ..			.dmark: db "-LP"  
3318 f1			.pastdmark: pop af  
3319			endm  
# End of macro DMARK
3319						CALLMONITOR 
3319 cd 7e 16			call break_point_state  
331c				endm  
# End of macro CALLMONITOR
331c					endif 
331c				; next item on the stack is the limit. get it 
331c			 
331c			 
331c				FORTH_LOOP_POP 
331c cd 40 1f			call macro_forth_loop_pop 
331f				endm 
# End of macro FORTH_LOOP_POP
331f			 
331f				FORTH_LOOP_TOS 
331f cd 36 1f			call macro_forth_loop_tos 
3322				endm 
# End of macro FORTH_LOOP_TOS
3322			 
3322 d1				pop de		 ; de = i, hl = limit 
3323			 
3323					if DEBUG_FORTH_WORDS 
3323						DMARK "-L1" 
3323 f5				push af  
3324 3a 38 33			ld a, (.dmark)  
3327 32 b4 fb			ld (debug_mark),a  
332a 3a 39 33			ld a, (.dmark+1)  
332d 32 b5 fb			ld (debug_mark+1),a  
3330 3a 3a 33			ld a, (.dmark+2)  
3333 32 b6 fb			ld (debug_mark+2),a  
3336 18 03			jr .pastdmark  
3338 ..			.dmark: db "-L1"  
333b f1			.pastdmark: pop af  
333c			endm  
# End of macro DMARK
333c						CALLMONITOR 
333c cd 7e 16			call break_point_state  
333f				endm  
# End of macro CALLMONITOR
333f					endif 
333f			 
333f				; go back to previous word 
333f			 
333f d5				push de    ; save I for inc later 
3340			 
3340			 
3340				; get limit 
3340				;  is I at limit? 
3340			 
3340			 
3340					if DEBUG_FORTH_WORDS 
3340						DMARK "-L1" 
3340 f5				push af  
3341 3a 55 33			ld a, (.dmark)  
3344 32 b4 fb			ld (debug_mark),a  
3347 3a 56 33			ld a, (.dmark+1)  
334a 32 b5 fb			ld (debug_mark+1),a  
334d 3a 57 33			ld a, (.dmark+2)  
3350 32 b6 fb			ld (debug_mark+2),a  
3353 18 03			jr .pastdmark  
3355 ..			.dmark: db "-L1"  
3358 f1			.pastdmark: pop af  
3359			endm  
# End of macro DMARK
3359						CALLMONITOR 
3359 cd 7e 16			call break_point_state  
335c				endm  
# End of macro CALLMONITOR
335c					endif 
335c			 
335c ed 52			sbc hl, de 
335e			 
335e			 
335e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
335e			 
335e 20 26				jr nz, .mloopnotdone 
3360			 
3360 e1				pop hl   ; get rid of saved I 
3361				FORTH_LOOP_POP     ; get rid of limit 
3361 cd 40 1f			call macro_forth_loop_pop 
3364				endm 
# End of macro FORTH_LOOP_POP
3364			 
3364				FORTH_RSP_POP     ; get rid of DO ptr 
3364 cd a3 1c			call macro_forth_rsp_pop 
3367				endm 
# End of macro FORTH_RSP_POP
3367			 
3367			if DEBUG_FORTH_WORDS 
3367						DMARK "-L>" 
3367 f5				push af  
3368 3a 7c 33			ld a, (.dmark)  
336b 32 b4 fb			ld (debug_mark),a  
336e 3a 7d 33			ld a, (.dmark+1)  
3371 32 b5 fb			ld (debug_mark+1),a  
3374 3a 7e 33			ld a, (.dmark+2)  
3377 32 b6 fb			ld (debug_mark+2),a  
337a 18 03			jr .pastdmark  
337c ..			.dmark: db "-L>"  
337f f1			.pastdmark: pop af  
3380			endm  
# End of macro DMARK
3380				CALLMONITOR 
3380 cd 7e 16			call break_point_state  
3383				endm  
# End of macro CALLMONITOR
3383			endif 
3383			 
3383					NEXTW 
3383 c3 44 20			jp macro_next 
3386				endm 
# End of macro NEXTW
3386				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3386			 
3386			.mloopnotdone: 
3386			 
3386 e1				pop hl    ; get I 
3387 2b				dec hl 
3388			 
3388			   	; save new I 
3388			 
3388			 
3388					; set I counter 
3388			 
3388 22 bf f2				ld (os_current_i), hl 
338b			 
338b					 
338b				FORTH_LOOP_NEXT 
338b cd 03 1f			call macro_forth_loop_next 
338e				endm 
# End of macro FORTH_LOOP_NEXT
338e			 
338e			 
338e					if DEBUG_FORTH_WORDS 
338e eb						ex de,hl 
338f					endif 
338f			 
338f			;	; get DO ptr 
338f			; 
338f				FORTH_RSP_TOS 
338f cd 99 1c			call macro_forth_rsp_tos 
3392				endm 
# End of macro FORTH_RSP_TOS
3392			 
3392				;push hl 
3392			 
3392				; not going to DO any more 
3392				; get rid of the RSP pointer as DO will add it back in 
3392				;FORTH_RSP_POP 
3392				;pop hl 
3392			 
3392			 
3392 22 9b f2			ld (os_tok_ptr), hl 
3395					if DEBUG_FORTH_WORDS 
3395						DMARK "-L<" 
3395 f5				push af  
3396 3a aa 33			ld a, (.dmark)  
3399 32 b4 fb			ld (debug_mark),a  
339c 3a ab 33			ld a, (.dmark+1)  
339f 32 b5 fb			ld (debug_mark+1),a  
33a2 3a ac 33			ld a, (.dmark+2)  
33a5 32 b6 fb			ld (debug_mark+2),a  
33a8 18 03			jr .pastdmark  
33aa ..			.dmark: db "-L<"  
33ad f1			.pastdmark: pop af  
33ae			endm  
# End of macro DMARK
33ae					CALLMONITOR 
33ae cd 7e 16			call break_point_state  
33b1				endm  
# End of macro CALLMONITOR
33b1				endif 
33b1 c3 d5 20			jp exec1 
33b4			 
33b4					 
33b4			 
33b4			 
33b4			 
33b4				NEXTW 
33b4 c3 44 20			jp macro_next 
33b7				endm 
# End of macro NEXTW
33b7			 
33b7			 
33b7			 
33b7			 
33b7			.REPEAT: 
33b7				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33b7 71				db WORD_SYS_CORE+93             
33b8 0a 34			dw .UNTIL            
33ba 06				db 5 + 1 
33bb .. 00			db "REPEAT",0              
33c2				endm 
# End of macro CWHEAD
33c2			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33c2			;  push pc to rsp stack past the REPEAT 
33c2					if DEBUG_FORTH_WORDS_KEY 
33c2						DMARK "REP" 
33c2 f5				push af  
33c3 3a d7 33			ld a, (.dmark)  
33c6 32 b4 fb			ld (debug_mark),a  
33c9 3a d8 33			ld a, (.dmark+1)  
33cc 32 b5 fb			ld (debug_mark+1),a  
33cf 3a d9 33			ld a, (.dmark+2)  
33d2 32 b6 fb			ld (debug_mark+2),a  
33d5 18 03			jr .pastdmark  
33d7 ..			.dmark: db "REP"  
33da f1			.pastdmark: pop af  
33db			endm  
# End of macro DMARK
33db						CALLMONITOR 
33db cd 7e 16			call break_point_state  
33de				endm  
# End of macro CALLMONITOR
33de					endif 
33de			 
33de 2a 9b f2				ld hl, (os_tok_ptr) 
33e1 23					inc hl   ; R 
33e2 23					inc hl  ; E 
33e3 23					inc hl   ; P 
33e4 23					inc hl   ; E 
33e5 23					inc hl   ; A 
33e6 23					inc hl   ; T 
33e7 23					inc hl   ; zero 
33e8					FORTH_RSP_NEXT 
33e8 cd 82 1c			call macro_forth_rsp_next 
33eb				endm 
# End of macro FORTH_RSP_NEXT
33eb			 
33eb			 
33eb					if DEBUG_FORTH_WORDS 
33eb						DMARK "REP" 
33eb f5				push af  
33ec 3a 00 34			ld a, (.dmark)  
33ef 32 b4 fb			ld (debug_mark),a  
33f2 3a 01 34			ld a, (.dmark+1)  
33f5 32 b5 fb			ld (debug_mark+1),a  
33f8 3a 02 34			ld a, (.dmark+2)  
33fb 32 b6 fb			ld (debug_mark+2),a  
33fe 18 03			jr .pastdmark  
3400 ..			.dmark: db "REP"  
3403 f1			.pastdmark: pop af  
3404			endm  
# End of macro DMARK
3404						;pop bc    ; TODO BUG ?????? what is this for???? 
3404						CALLMONITOR 
3404 cd 7e 16			call break_point_state  
3407				endm  
# End of macro CALLMONITOR
3407					endif 
3407			 
3407					NEXTW 
3407 c3 44 20			jp macro_next 
340a				endm 
# End of macro NEXTW
340a			;	       NEXTW 
340a			 
340a			.UNTIL: 
340a				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
340a 72				db WORD_SYS_CORE+94             
340b a1 34			dw .ENDFLOW            
340d 06				db 5 + 1 
340e .. 00			db "UNTIL",0              
3414				endm 
# End of macro CWHEAD
3414			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3414			 
3414				; pop tos as check 
3414			 
3414				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3414			 
3414				FORTH_DSP_VALUEHL 
3414 cd d2 1e			call macro_dsp_valuehl 
3417				endm 
# End of macro FORTH_DSP_VALUEHL
3417			 
3417					if DEBUG_FORTH_WORDS_KEY 
3417						DMARK "UNT" 
3417 f5				push af  
3418 3a 2c 34			ld a, (.dmark)  
341b 32 b4 fb			ld (debug_mark),a  
341e 3a 2d 34			ld a, (.dmark+1)  
3421 32 b5 fb			ld (debug_mark+1),a  
3424 3a 2e 34			ld a, (.dmark+2)  
3427 32 b6 fb			ld (debug_mark+2),a  
342a 18 03			jr .pastdmark  
342c ..			.dmark: db "UNT"  
342f f1			.pastdmark: pop af  
3430			endm  
# End of macro DMARK
3430						CALLMONITOR 
3430 cd 7e 16			call break_point_state  
3433				endm  
# End of macro CALLMONITOR
3433					endif 
3433			 
3433			;	push hl 
3433				FORTH_DSP_POP 
3433 cd 8a 1f			call macro_forth_dsp_pop 
3436				endm 
# End of macro FORTH_DSP_POP
3436			 
3436			;	pop hl 
3436			 
3436				; test if true 
3436			 
3436 cd 2a 0d			call ishlzero 
3439			;	ld a,l 
3439			;	add h 
3439			; 
3439			;	cp 0 
3439			 
3439 20 3e			jr nz, .untilnotdone 
343b			 
343b					if DEBUG_FORTH_WORDS 
343b						DMARK "UNf" 
343b f5				push af  
343c 3a 50 34			ld a, (.dmark)  
343f 32 b4 fb			ld (debug_mark),a  
3442 3a 51 34			ld a, (.dmark+1)  
3445 32 b5 fb			ld (debug_mark+1),a  
3448 3a 52 34			ld a, (.dmark+2)  
344b 32 b6 fb			ld (debug_mark+2),a  
344e 18 03			jr .pastdmark  
3450 ..			.dmark: db "UNf"  
3453 f1			.pastdmark: pop af  
3454			endm  
# End of macro DMARK
3454						CALLMONITOR 
3454 cd 7e 16			call break_point_state  
3457				endm  
# End of macro CALLMONITOR
3457					endif 
3457			 
3457			 
3457			 
3457				FORTH_RSP_POP     ; get rid of DO ptr 
3457 cd a3 1c			call macro_forth_rsp_pop 
345a				endm 
# End of macro FORTH_RSP_POP
345a			 
345a			if DEBUG_FORTH_WORDS 
345a						DMARK "UN>" 
345a f5				push af  
345b 3a 6f 34			ld a, (.dmark)  
345e 32 b4 fb			ld (debug_mark),a  
3461 3a 70 34			ld a, (.dmark+1)  
3464 32 b5 fb			ld (debug_mark+1),a  
3467 3a 71 34			ld a, (.dmark+2)  
346a 32 b6 fb			ld (debug_mark+2),a  
346d 18 03			jr .pastdmark  
346f ..			.dmark: db "UN>"  
3472 f1			.pastdmark: pop af  
3473			endm  
# End of macro DMARK
3473				CALLMONITOR 
3473 cd 7e 16			call break_point_state  
3476				endm  
# End of macro CALLMONITOR
3476			endif 
3476			 
3476					NEXTW 
3476 c3 44 20			jp macro_next 
3479				endm 
# End of macro NEXTW
3479				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3479			 
3479			.untilnotdone: 
3479			 
3479			 
3479			;	; get DO ptr 
3479			; 
3479				FORTH_RSP_TOS 
3479 cd 99 1c			call macro_forth_rsp_tos 
347c				endm 
# End of macro FORTH_RSP_TOS
347c			 
347c				;push hl 
347c			 
347c				; not going to DO any more 
347c				; get rid of the RSP pointer as DO will add it back in 
347c				;FORTH_RSP_POP 
347c				;pop hl 
347c			 
347c			 
347c 22 9b f2			ld (os_tok_ptr), hl 
347f					if DEBUG_FORTH_WORDS 
347f						DMARK "UN<" 
347f f5				push af  
3480 3a 94 34			ld a, (.dmark)  
3483 32 b4 fb			ld (debug_mark),a  
3486 3a 95 34			ld a, (.dmark+1)  
3489 32 b5 fb			ld (debug_mark+1),a  
348c 3a 96 34			ld a, (.dmark+2)  
348f 32 b6 fb			ld (debug_mark+2),a  
3492 18 03			jr .pastdmark  
3494 ..			.dmark: db "UN<"  
3497 f1			.pastdmark: pop af  
3498			endm  
# End of macro DMARK
3498					CALLMONITOR 
3498 cd 7e 16			call break_point_state  
349b				endm  
# End of macro CALLMONITOR
349b				endif 
349b c3 d5 20			jp exec1 
349e			 
349e					 
349e			 
349e			 
349e					NEXTW 
349e c3 44 20			jp macro_next 
34a1				endm 
# End of macro NEXTW
34a1			 
34a1			 
34a1			.ENDFLOW: 
34a1			 
34a1			; eof 
34a1			 
# End of file forth_words_flow.asm
34a1			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34a1			include "forth_words_logic.asm" 
34a1			 
34a1			; | ## Logic Words 
34a1			 
34a1			.NOT: 
34a1				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34a1 2d				db WORD_SYS_CORE+25             
34a2 e9 34			dw .IS            
34a4 04				db 3 + 1 
34a5 .. 00			db "NOT",0              
34a9				endm 
# End of macro CWHEAD
34a9			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34a9					if DEBUG_FORTH_WORDS_KEY 
34a9						DMARK "NOT" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 b4 fb			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 b5 fb			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 b6 fb			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "NOT"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd 7e 16			call break_point_state  
34c5				endm  
# End of macro CALLMONITOR
34c5					endif 
34c5					FORTH_DSP 
34c5 cd 98 1e			call macro_forth_dsp 
34c8				endm 
# End of macro FORTH_DSP
34c8 7e					ld a,(hl)	; get type of value on TOS 
34c9 fe 02				cp DS_TYPE_INUM  
34cb 28 03				jr z, .noti 
34cd					NEXTW 
34cd c3 44 20			jp macro_next 
34d0				endm 
# End of macro NEXTW
34d0			.noti:          FORTH_DSP_VALUEHL 
34d0 cd d2 1e			call macro_dsp_valuehl 
34d3				endm 
# End of macro FORTH_DSP_VALUEHL
34d3			;		push hl 
34d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d3 cd 8a 1f			call macro_forth_dsp_pop 
34d6				endm 
# End of macro FORTH_DSP_POP
34d6			;		pop hl 
34d6 3e 00				ld a,0 
34d8 bd					cp l 
34d9 28 04				jr z, .not2t 
34db 2e 00				ld l, 0 
34dd 18 02				jr .notip 
34df			 
34df 2e ff		.not2t:		ld l, 255 
34e1			 
34e1 26 00		.notip:		ld h, 0	 
34e3			 
34e3 cd db 1c				call forth_push_numhl 
34e6					NEXTW 
34e6 c3 44 20			jp macro_next 
34e9				endm 
# End of macro NEXTW
34e9			 
34e9			.IS: 
34e9				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34e9 2d				db WORD_SYS_CORE+25             
34ea 0f 35			dw .LZERO            
34ec 03				db 2 + 1 
34ed .. 00			db "IS",0              
34f0				endm 
# End of macro CWHEAD
34f0			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34f0					if DEBUG_FORTH_WORDS_KEY 
34f0						DMARK "IS." 
34f0 f5				push af  
34f1 3a 05 35			ld a, (.dmark)  
34f4 32 b4 fb			ld (debug_mark),a  
34f7 3a 06 35			ld a, (.dmark+1)  
34fa 32 b5 fb			ld (debug_mark+1),a  
34fd 3a 07 35			ld a, (.dmark+2)  
3500 32 b6 fb			ld (debug_mark+2),a  
3503 18 03			jr .pastdmark  
3505 ..			.dmark: db "IS."  
3508 f1			.pastdmark: pop af  
3509			endm  
# End of macro DMARK
3509						CALLMONITOR 
3509 cd 7e 16			call break_point_state  
350c				endm  
# End of macro CALLMONITOR
350c					endif 
350c					NEXTW 
350c c3 44 20			jp macro_next 
350f				endm 
# End of macro NEXTW
350f			.LZERO: 
350f				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
350f 2d				db WORD_SYS_CORE+25             
3510 19 35			dw .TZERO            
3512 03				db 2 + 1 
3513 .. 00			db "0<",0              
3516				endm 
# End of macro CWHEAD
3516			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3516					NEXTW 
3516 c3 44 20			jp macro_next 
3519				endm 
# End of macro NEXTW
3519			.TZERO: 
3519				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3519 2e				db WORD_SYS_CORE+26             
351a 60 35			dw .LESS            
351c 03				db 2 + 1 
351d .. 00			db "0=",0              
3520				endm 
# End of macro CWHEAD
3520			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3520				; TODO add floating point number detection 
3520					;v5 FORTH_DSP_VALUE 
3520					if DEBUG_FORTH_WORDS_KEY 
3520						DMARK "0=." 
3520 f5				push af  
3521 3a 35 35			ld a, (.dmark)  
3524 32 b4 fb			ld (debug_mark),a  
3527 3a 36 35			ld a, (.dmark+1)  
352a 32 b5 fb			ld (debug_mark+1),a  
352d 3a 37 35			ld a, (.dmark+2)  
3530 32 b6 fb			ld (debug_mark+2),a  
3533 18 03			jr .pastdmark  
3535 ..			.dmark: db "0=."  
3538 f1			.pastdmark: pop af  
3539			endm  
# End of macro DMARK
3539						CALLMONITOR 
3539 cd 7e 16			call break_point_state  
353c				endm  
# End of macro CALLMONITOR
353c					endif 
353c					FORTH_DSP 
353c cd 98 1e			call macro_forth_dsp 
353f				endm 
# End of macro FORTH_DSP
353f 7e					ld a,(hl)	; get type of value on TOS 
3540 fe 02				cp DS_TYPE_INUM  
3542 28 00				jr z, .tz_inum 
3544			 
3544				if FORTH_ENABLE_FLOATMATH 
3544					jr .tz_done 
3544			 
3544				endif 
3544					 
3544			 
3544			.tz_inum: 
3544					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3544 cd d2 1e			call macro_dsp_valuehl 
3547				endm 
# End of macro FORTH_DSP_VALUEHL
3547			 
3547			;		push hl 
3547			 
3547					; destroy value TOS 
3547			 
3547					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3547 cd 8a 1f			call macro_forth_dsp_pop 
354a				endm 
# End of macro FORTH_DSP_POP
354a			 
354a			;		pop hl 
354a			 
354a 3e 00				ld a,0 
354c			 
354c bd					cp l 
354d 20 08				jr nz, .tz_notzero 
354f			 
354f bc					cp h 
3550			 
3550 20 05				jr nz, .tz_notzero 
3552			 
3552			 
3552 21 01 00				ld hl, FORTH_TRUE 
3555 18 03				jr .tz_done 
3557			 
3557 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
355a			 
355a					; push value back onto stack for another op etc 
355a			 
355a			.tz_done: 
355a cd db 1c				call forth_push_numhl 
355d			 
355d					NEXTW 
355d c3 44 20			jp macro_next 
3560				endm 
# End of macro NEXTW
3560			.LESS: 
3560				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3560 2f				db WORD_SYS_CORE+27             
3561 c9 35			dw .GT            
3563 02				db 1 + 1 
3564 .. 00			db "<",0              
3566				endm 
# End of macro CWHEAD
3566			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3566				; TODO add floating point number detection 
3566					if DEBUG_FORTH_WORDS_KEY 
3566						DMARK "LES" 
3566 f5				push af  
3567 3a 7b 35			ld a, (.dmark)  
356a 32 b4 fb			ld (debug_mark),a  
356d 3a 7c 35			ld a, (.dmark+1)  
3570 32 b5 fb			ld (debug_mark+1),a  
3573 3a 7d 35			ld a, (.dmark+2)  
3576 32 b6 fb			ld (debug_mark+2),a  
3579 18 03			jr .pastdmark  
357b ..			.dmark: db "LES"  
357e f1			.pastdmark: pop af  
357f			endm  
# End of macro DMARK
357f						CALLMONITOR 
357f cd 7e 16			call break_point_state  
3582				endm  
# End of macro CALLMONITOR
3582					endif 
3582					FORTH_DSP 
3582 cd 98 1e			call macro_forth_dsp 
3585				endm 
# End of macro FORTH_DSP
3585					;v5 FORTH_DSP_VALUE 
3585 7e					ld a,(hl)	; get type of value on TOS 
3586 fe 02				cp DS_TYPE_INUM  
3588 28 00				jr z, .less_inum 
358a			 
358a				if FORTH_ENABLE_FLOATMATH 
358a					jr .less_done 
358a			 
358a				endif 
358a					 
358a			 
358a			.less_inum: 
358a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
358a cd d2 1e			call macro_dsp_valuehl 
358d				endm 
# End of macro FORTH_DSP_VALUEHL
358d			 
358d e5					push hl  ; u2 
358e			 
358e					; destroy value TOS 
358e			 
358e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
358e cd 8a 1f			call macro_forth_dsp_pop 
3591				endm 
# End of macro FORTH_DSP_POP
3591			 
3591			 
3591					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3591 cd d2 1e			call macro_dsp_valuehl 
3594				endm 
# End of macro FORTH_DSP_VALUEHL
3594			 
3594 e5					push hl    ; u1 
3595			 
3595					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3595 cd 8a 1f			call macro_forth_dsp_pop 
3598				endm 
# End of macro FORTH_DSP_POP
3598			 
3598			 
3598 b7			 or a      ;clear carry flag 
3599 01 00 00		 ld bc, FORTH_FALSE 
359c e1			  pop hl    ; u1 
359d d1			  pop de    ; u2 
359e ed 52		  sbc hl,de 
35a0 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35a2			 
35a2 01 01 00		 ld bc, FORTH_TRUE 
35a5			.lscont:  
35a5 c5					push bc 
35a6 e1					pop hl 
35a7			 
35a7					if DEBUG_FORTH_WORDS 
35a7						DMARK "LT1" 
35a7 f5				push af  
35a8 3a bc 35			ld a, (.dmark)  
35ab 32 b4 fb			ld (debug_mark),a  
35ae 3a bd 35			ld a, (.dmark+1)  
35b1 32 b5 fb			ld (debug_mark+1),a  
35b4 3a be 35			ld a, (.dmark+2)  
35b7 32 b6 fb			ld (debug_mark+2),a  
35ba 18 03			jr .pastdmark  
35bc ..			.dmark: db "LT1"  
35bf f1			.pastdmark: pop af  
35c0			endm  
# End of macro DMARK
35c0						CALLMONITOR 
35c0 cd 7e 16			call break_point_state  
35c3				endm  
# End of macro CALLMONITOR
35c3					endif 
35c3 cd db 1c				call forth_push_numhl 
35c6			 
35c6					NEXTW 
35c6 c3 44 20			jp macro_next 
35c9				endm 
# End of macro NEXTW
35c9			.GT: 
35c9				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35c9 30				db WORD_SYS_CORE+28             
35ca 32 36			dw .EQUAL            
35cc 02				db 1 + 1 
35cd .. 00			db ">",0              
35cf				endm 
# End of macro CWHEAD
35cf			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35cf				; TODO add floating point number detection 
35cf					if DEBUG_FORTH_WORDS_KEY 
35cf						DMARK "GRT" 
35cf f5				push af  
35d0 3a e4 35			ld a, (.dmark)  
35d3 32 b4 fb			ld (debug_mark),a  
35d6 3a e5 35			ld a, (.dmark+1)  
35d9 32 b5 fb			ld (debug_mark+1),a  
35dc 3a e6 35			ld a, (.dmark+2)  
35df 32 b6 fb			ld (debug_mark+2),a  
35e2 18 03			jr .pastdmark  
35e4 ..			.dmark: db "GRT"  
35e7 f1			.pastdmark: pop af  
35e8			endm  
# End of macro DMARK
35e8						CALLMONITOR 
35e8 cd 7e 16			call break_point_state  
35eb				endm  
# End of macro CALLMONITOR
35eb					endif 
35eb					FORTH_DSP 
35eb cd 98 1e			call macro_forth_dsp 
35ee				endm 
# End of macro FORTH_DSP
35ee					;FORTH_DSP_VALUE 
35ee 7e					ld a,(hl)	; get type of value on TOS 
35ef fe 02				cp DS_TYPE_INUM  
35f1 28 00				jr z, .gt_inum 
35f3			 
35f3				if FORTH_ENABLE_FLOATMATH 
35f3					jr .gt_done 
35f3			 
35f3				endif 
35f3					 
35f3			 
35f3			.gt_inum: 
35f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35f3 cd d2 1e			call macro_dsp_valuehl 
35f6				endm 
# End of macro FORTH_DSP_VALUEHL
35f6			 
35f6 e5					push hl  ; u2 
35f7			 
35f7					; destroy value TOS 
35f7			 
35f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f7 cd 8a 1f			call macro_forth_dsp_pop 
35fa				endm 
# End of macro FORTH_DSP_POP
35fa			 
35fa			 
35fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35fa cd d2 1e			call macro_dsp_valuehl 
35fd				endm 
# End of macro FORTH_DSP_VALUEHL
35fd			 
35fd e5					push hl    ; u1 
35fe			 
35fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35fe cd 8a 1f			call macro_forth_dsp_pop 
3601				endm 
# End of macro FORTH_DSP_POP
3601			 
3601			 
3601 b7			 or a      ;clear carry flag 
3602 01 00 00		 ld bc, FORTH_FALSE 
3605 e1			  pop hl    ; u1 
3606 d1			  pop de    ; u2 
3607 ed 52		  sbc hl,de 
3609 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
360b			 
360b 01 01 00		 ld bc, FORTH_TRUE 
360e			.gtcont:  
360e c5					push bc 
360f e1					pop hl 
3610			 
3610					if DEBUG_FORTH_WORDS 
3610						DMARK "GT1" 
3610 f5				push af  
3611 3a 25 36			ld a, (.dmark)  
3614 32 b4 fb			ld (debug_mark),a  
3617 3a 26 36			ld a, (.dmark+1)  
361a 32 b5 fb			ld (debug_mark+1),a  
361d 3a 27 36			ld a, (.dmark+2)  
3620 32 b6 fb			ld (debug_mark+2),a  
3623 18 03			jr .pastdmark  
3625 ..			.dmark: db "GT1"  
3628 f1			.pastdmark: pop af  
3629			endm  
# End of macro DMARK
3629						CALLMONITOR 
3629 cd 7e 16			call break_point_state  
362c				endm  
# End of macro CALLMONITOR
362c					endif 
362c cd db 1c				call forth_push_numhl 
362f			 
362f					NEXTW 
362f c3 44 20			jp macro_next 
3632				endm 
# End of macro NEXTW
3632			.EQUAL: 
3632				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3632 31				db WORD_SYS_CORE+29             
3633 9d 36			dw .ENDLOGIC            
3635 02				db 1 + 1 
3636 .. 00			db "=",0              
3638				endm 
# End of macro CWHEAD
3638			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3638				; TODO add floating point number detection 
3638					if DEBUG_FORTH_WORDS_KEY 
3638						DMARK "EQ." 
3638 f5				push af  
3639 3a 4d 36			ld a, (.dmark)  
363c 32 b4 fb			ld (debug_mark),a  
363f 3a 4e 36			ld a, (.dmark+1)  
3642 32 b5 fb			ld (debug_mark+1),a  
3645 3a 4f 36			ld a, (.dmark+2)  
3648 32 b6 fb			ld (debug_mark+2),a  
364b 18 03			jr .pastdmark  
364d ..			.dmark: db "EQ."  
3650 f1			.pastdmark: pop af  
3651			endm  
# End of macro DMARK
3651						CALLMONITOR 
3651 cd 7e 16			call break_point_state  
3654				endm  
# End of macro CALLMONITOR
3654					endif 
3654					FORTH_DSP 
3654 cd 98 1e			call macro_forth_dsp 
3657				endm 
# End of macro FORTH_DSP
3657					;v5 FORTH_DSP_VALUE 
3657 7e					ld a,(hl)	; get type of value on TOS 
3658 fe 02				cp DS_TYPE_INUM  
365a 28 00				jr z, .eq_inum 
365c			 
365c				if FORTH_ENABLE_FLOATMATH 
365c					jr .eq_done 
365c			 
365c				endif 
365c					 
365c			 
365c			.eq_inum: 
365c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365c cd d2 1e			call macro_dsp_valuehl 
365f				endm 
# End of macro FORTH_DSP_VALUEHL
365f			 
365f e5					push hl 
3660			 
3660					; destroy value TOS 
3660			 
3660					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3660 cd 8a 1f			call macro_forth_dsp_pop 
3663				endm 
# End of macro FORTH_DSP_POP
3663			 
3663			 
3663					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3663 cd d2 1e			call macro_dsp_valuehl 
3666				endm 
# End of macro FORTH_DSP_VALUEHL
3666			 
3666					; one value on hl get other one back 
3666			 
3666 e5					push hl 
3667			 
3667					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3667 cd 8a 1f			call macro_forth_dsp_pop 
366a				endm 
# End of macro FORTH_DSP_POP
366a			 
366a 0e 00				ld c, FORTH_FALSE 
366c			 
366c e1					pop hl 
366d d1					pop de 
366e			 
366e 7b					ld a, e 
366f bd					cp l 
3670			 
3670 20 06				jr nz, .eq_done 
3672			 
3672 7a					ld a, d 
3673 bc					cp h 
3674			 
3674 20 02				jr nz, .eq_done 
3676			 
3676 0e 01				ld c, FORTH_TRUE 
3678					 
3678			 
3678			 
3678			.eq_done: 
3678			 
3678					; TODO push value back onto stack for another op etc 
3678			 
3678 26 00				ld h, 0 
367a 69					ld l, c 
367b					if DEBUG_FORTH_WORDS 
367b						DMARK "EQ1" 
367b f5				push af  
367c 3a 90 36			ld a, (.dmark)  
367f 32 b4 fb			ld (debug_mark),a  
3682 3a 91 36			ld a, (.dmark+1)  
3685 32 b5 fb			ld (debug_mark+1),a  
3688 3a 92 36			ld a, (.dmark+2)  
368b 32 b6 fb			ld (debug_mark+2),a  
368e 18 03			jr .pastdmark  
3690 ..			.dmark: db "EQ1"  
3693 f1			.pastdmark: pop af  
3694			endm  
# End of macro DMARK
3694						CALLMONITOR 
3694 cd 7e 16			call break_point_state  
3697				endm  
# End of macro CALLMONITOR
3697					endif 
3697 cd db 1c				call forth_push_numhl 
369a			 
369a					NEXTW 
369a c3 44 20			jp macro_next 
369d				endm 
# End of macro NEXTW
369d			 
369d			 
369d			.ENDLOGIC: 
369d			; eof 
369d			 
369d			 
# End of file forth_words_logic.asm
369d			include "forth_words_maths.asm" 
369d			 
369d			; | ## Maths Words 
369d			 
369d			.PLUS:	 
369d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
369d 15				db WORD_SYS_CORE+1             
369e df 36			dw .NEG            
36a0 02				db 1 + 1 
36a1 .. 00			db "+",0              
36a3				endm 
# End of macro CWHEAD
36a3			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36a3					if DEBUG_FORTH_WORDS_KEY 
36a3						DMARK "PLU" 
36a3 f5				push af  
36a4 3a b8 36			ld a, (.dmark)  
36a7 32 b4 fb			ld (debug_mark),a  
36aa 3a b9 36			ld a, (.dmark+1)  
36ad 32 b5 fb			ld (debug_mark+1),a  
36b0 3a ba 36			ld a, (.dmark+2)  
36b3 32 b6 fb			ld (debug_mark+2),a  
36b6 18 03			jr .pastdmark  
36b8 ..			.dmark: db "PLU"  
36bb f1			.pastdmark: pop af  
36bc			endm  
# End of macro DMARK
36bc						CALLMONITOR 
36bc cd 7e 16			call break_point_state  
36bf				endm  
# End of macro CALLMONITOR
36bf					endif 
36bf					; add top two values and push back result 
36bf			 
36bf					;for v5 FORTH_DSP_VALUE 
36bf					FORTH_DSP 
36bf cd 98 1e			call macro_forth_dsp 
36c2				endm 
# End of macro FORTH_DSP
36c2 7e					ld a,(hl)	; get type of value on TOS 
36c3 fe 02				cp DS_TYPE_INUM  
36c5 28 03				jr z, .dot_inum 
36c7			 
36c7					NEXTW 
36c7 c3 44 20			jp macro_next 
36ca				endm 
# End of macro NEXTW
36ca			 
36ca			; float maths 
36ca			 
36ca				if FORTH_ENABLE_FLOATMATH 
36ca						inc hl      ; now at start of numeric as string 
36ca			 
36ca					if DEBUG_FORTH_MATHS 
36ca						DMARK "ADD" 
36ca				CALLMONITOR 
36ca					endif 
36ca			 
36ca					;ld ix, hl 
36ca					call CON 
36ca			 
36ca			 
36ca					push hl 
36ca					 
36ca					 
36ca			 
36ca						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36ca			 
36ca					; get next number 
36ca			 
36ca						FORTH_DSP_VALUE 
36ca			 
36ca						inc hl      ; now at start of numeric as string 
36ca			 
36ca					;ld ix, hl 
36ca					call CON 
36ca			 
36ca					push hl 
36ca			 
36ca			 
36ca						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ca			 
36ca						; TODO do add 
36ca			 
36ca						call IADD 
36ca			 
36ca						; TODO get result back as ascii 
36ca			 
36ca						; TODO push result  
36ca			 
36ca			 
36ca			 
36ca						jr .dot_done 
36ca				endif 
36ca			 
36ca			.dot_inum: 
36ca			 
36ca			 
36ca					if DEBUG_FORTH_DOT 
36ca						DMARK "+IT" 
36ca				CALLMONITOR 
36ca					endif 
36ca			 
36ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ca cd d2 1e			call macro_dsp_valuehl 
36cd				endm 
# End of macro FORTH_DSP_VALUEHL
36cd			 
36cd				; TODO add floating point number detection 
36cd			 
36cd e5					push hl 
36ce			 
36ce					; destroy value TOS 
36ce			 
36ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ce cd 8a 1f			call macro_forth_dsp_pop 
36d1				endm 
# End of macro FORTH_DSP_POP
36d1			 
36d1			 
36d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36d1 cd d2 1e			call macro_dsp_valuehl 
36d4				endm 
# End of macro FORTH_DSP_VALUEHL
36d4			 
36d4					; one value on hl get other one back 
36d4			 
36d4 d1					pop de 
36d5			 
36d5					; do the add 
36d5			 
36d5 19					add hl,de 
36d6			 
36d6					; save it 
36d6			 
36d6			;		push hl	 
36d6			 
36d6					; 
36d6			 
36d6					; destroy value TOS 
36d6			 
36d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d6 cd 8a 1f			call macro_forth_dsp_pop 
36d9				endm 
# End of macro FORTH_DSP_POP
36d9			 
36d9					; TODO push value back onto stack for another op etc 
36d9			 
36d9			;		pop hl 
36d9			 
36d9			.dot_done: 
36d9 cd db 1c				call forth_push_numhl 
36dc			 
36dc					NEXTW 
36dc c3 44 20			jp macro_next 
36df				endm 
# End of macro NEXTW
36df			.NEG: 
36df			 
36df				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36df 17				db WORD_SYS_CORE+3             
36e0 22 37			dw .DIV            
36e2 02				db 1 + 1 
36e3 .. 00			db "-",0              
36e5				endm 
# End of macro CWHEAD
36e5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36e5					if DEBUG_FORTH_WORDS_KEY 
36e5						DMARK "SUB" 
36e5 f5				push af  
36e6 3a fa 36			ld a, (.dmark)  
36e9 32 b4 fb			ld (debug_mark),a  
36ec 3a fb 36			ld a, (.dmark+1)  
36ef 32 b5 fb			ld (debug_mark+1),a  
36f2 3a fc 36			ld a, (.dmark+2)  
36f5 32 b6 fb			ld (debug_mark+2),a  
36f8 18 03			jr .pastdmark  
36fa ..			.dmark: db "SUB"  
36fd f1			.pastdmark: pop af  
36fe			endm  
# End of macro DMARK
36fe						CALLMONITOR 
36fe cd 7e 16			call break_point_state  
3701				endm  
# End of macro CALLMONITOR
3701					endif 
3701			 
3701			 
3701				; TODO add floating point number detection 
3701					; v5 FORTH_DSP_VALUE 
3701					FORTH_DSP 
3701 cd 98 1e			call macro_forth_dsp 
3704				endm 
# End of macro FORTH_DSP
3704 7e					ld a,(hl)	; get type of value on TOS 
3705 fe 02				cp DS_TYPE_INUM  
3707 28 03				jr z, .neg_inum 
3709			 
3709					NEXTW 
3709 c3 44 20			jp macro_next 
370c				endm 
# End of macro NEXTW
370c			 
370c			; float maths 
370c			 
370c				if FORTH_ENABLE_FLOATMATH 
370c					jr .neg_done 
370c			 
370c				endif 
370c					 
370c			 
370c			.neg_inum: 
370c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370c cd d2 1e			call macro_dsp_valuehl 
370f				endm 
# End of macro FORTH_DSP_VALUEHL
370f			 
370f e5					push hl 
3710			 
3710					; destroy value TOS 
3710			 
3710					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3710 cd 8a 1f			call macro_forth_dsp_pop 
3713				endm 
# End of macro FORTH_DSP_POP
3713			 
3713			 
3713					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3713 cd d2 1e			call macro_dsp_valuehl 
3716				endm 
# End of macro FORTH_DSP_VALUEHL
3716			 
3716					; one value on hl get other one back 
3716			 
3716 d1					pop de 
3717			 
3717					; do the sub 
3717			;		ex de, hl 
3717			 
3717 ed 52				sbc hl,de 
3719			 
3719					; save it 
3719			 
3719			;		push hl	 
3719			 
3719					; 
3719			 
3719					; destroy value TOS 
3719			 
3719					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3719 cd 8a 1f			call macro_forth_dsp_pop 
371c				endm 
# End of macro FORTH_DSP_POP
371c			 
371c					; TODO push value back onto stack for another op etc 
371c			 
371c			;		pop hl 
371c			 
371c cd db 1c				call forth_push_numhl 
371f			.neg_done: 
371f			 
371f					NEXTW 
371f c3 44 20			jp macro_next 
3722				endm 
# End of macro NEXTW
3722			.DIV: 
3722				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3722 18				db WORD_SYS_CORE+4             
3723 6f 37			dw .MUL            
3725 02				db 1 + 1 
3726 .. 00			db "/",0              
3728				endm 
# End of macro CWHEAD
3728			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3728					if DEBUG_FORTH_WORDS_KEY 
3728						DMARK "DIV" 
3728 f5				push af  
3729 3a 3d 37			ld a, (.dmark)  
372c 32 b4 fb			ld (debug_mark),a  
372f 3a 3e 37			ld a, (.dmark+1)  
3732 32 b5 fb			ld (debug_mark+1),a  
3735 3a 3f 37			ld a, (.dmark+2)  
3738 32 b6 fb			ld (debug_mark+2),a  
373b 18 03			jr .pastdmark  
373d ..			.dmark: db "DIV"  
3740 f1			.pastdmark: pop af  
3741			endm  
# End of macro DMARK
3741						CALLMONITOR 
3741 cd 7e 16			call break_point_state  
3744				endm  
# End of macro CALLMONITOR
3744					endif 
3744				; TODO add floating point number detection 
3744					; v5 FORTH_DSP_VALUE 
3744					FORTH_DSP 
3744 cd 98 1e			call macro_forth_dsp 
3747				endm 
# End of macro FORTH_DSP
3747 7e					ld a,(hl)	; get type of value on TOS 
3748 fe 02				cp DS_TYPE_INUM  
374a 28 03				jr z, .div_inum 
374c			 
374c				if FORTH_ENABLE_FLOATMATH 
374c					jr .div_done 
374c			 
374c				endif 
374c					NEXTW 
374c c3 44 20			jp macro_next 
374f				endm 
# End of macro NEXTW
374f			.div_inum: 
374f			 
374f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
374f cd d2 1e			call macro_dsp_valuehl 
3752				endm 
# End of macro FORTH_DSP_VALUEHL
3752			 
3752 e5					push hl    ; to go to bc 
3753			 
3753					; destroy value TOS 
3753			 
3753					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3753 cd 8a 1f			call macro_forth_dsp_pop 
3756				endm 
# End of macro FORTH_DSP_POP
3756			 
3756			 
3756					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3756 cd d2 1e			call macro_dsp_valuehl 
3759				endm 
# End of macro FORTH_DSP_VALUEHL
3759			 
3759					; hl to go to de 
3759			 
3759 e5					push hl 
375a			 
375a c1					pop bc 
375b d1					pop de		 
375c			 
375c			 
375c					if DEBUG_FORTH_MATHS 
375c						DMARK "DIV" 
375c				CALLMONITOR 
375c					endif 
375c					; one value on hl but move to a get other one back 
375c			 
375c			        
375c cd 5e 0c			call Div16 
375f			 
375f			;	push af	 
375f e5				push hl 
3760 c5				push bc 
3761			 
3761					if DEBUG_FORTH_MATHS 
3761						DMARK "DI1" 
3761				CALLMONITOR 
3761					endif 
3761			 
3761					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3761 cd 8a 1f			call macro_forth_dsp_pop 
3764				endm 
# End of macro FORTH_DSP_POP
3764			 
3764			 
3764			 
3764 e1					pop hl    ; result 
3765			 
3765 cd db 1c				call forth_push_numhl 
3768			 
3768 e1					pop hl    ; reminder 
3769			;		ld h,0 
3769			;		ld l,d 
3769			 
3769 cd db 1c				call forth_push_numhl 
376c			.div_done: 
376c					NEXTW 
376c c3 44 20			jp macro_next 
376f				endm 
# End of macro NEXTW
376f			.MUL: 
376f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
376f 19				db WORD_SYS_CORE+5             
3770 b4 37			dw .MIN            
3772 02				db 1 + 1 
3773 .. 00			db "*",0              
3775				endm 
# End of macro CWHEAD
3775			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3775				; TODO add floating point number detection 
3775					if DEBUG_FORTH_WORDS_KEY 
3775						DMARK "MUL" 
3775 f5				push af  
3776 3a 8a 37			ld a, (.dmark)  
3779 32 b4 fb			ld (debug_mark),a  
377c 3a 8b 37			ld a, (.dmark+1)  
377f 32 b5 fb			ld (debug_mark+1),a  
3782 3a 8c 37			ld a, (.dmark+2)  
3785 32 b6 fb			ld (debug_mark+2),a  
3788 18 03			jr .pastdmark  
378a ..			.dmark: db "MUL"  
378d f1			.pastdmark: pop af  
378e			endm  
# End of macro DMARK
378e						CALLMONITOR 
378e cd 7e 16			call break_point_state  
3791				endm  
# End of macro CALLMONITOR
3791					endif 
3791					FORTH_DSP 
3791 cd 98 1e			call macro_forth_dsp 
3794				endm 
# End of macro FORTH_DSP
3794					; v5 FORTH_DSP_VALUE 
3794 7e					ld a,(hl)	; get type of value on TOS 
3795 fe 02				cp DS_TYPE_INUM  
3797 28 03				jr z, .mul_inum 
3799			 
3799				if FORTH_ENABLE_FLOATMATH 
3799					jr .mul_done 
3799			 
3799				endif 
3799			 
3799					NEXTW 
3799 c3 44 20			jp macro_next 
379c				endm 
# End of macro NEXTW
379c			.mul_inum:	 
379c			 
379c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379c cd d2 1e			call macro_dsp_valuehl 
379f				endm 
# End of macro FORTH_DSP_VALUEHL
379f			 
379f e5					push hl 
37a0			 
37a0					; destroy value TOS 
37a0			 
37a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a0 cd 8a 1f			call macro_forth_dsp_pop 
37a3				endm 
# End of macro FORTH_DSP_POP
37a3			 
37a3			 
37a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a3 cd d2 1e			call macro_dsp_valuehl 
37a6				endm 
# End of macro FORTH_DSP_VALUEHL
37a6			 
37a6					; one value on hl but move to a get other one back 
37a6			 
37a6 7d					ld a, l 
37a7			 
37a7 d1					pop de 
37a8			 
37a8					; do the mull 
37a8			;		ex de, hl 
37a8			 
37a8 cd 84 0c				call Mult16 
37ab					; save it 
37ab			 
37ab			;		push hl	 
37ab			 
37ab					; 
37ab			 
37ab					; destroy value TOS 
37ab			 
37ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ab cd 8a 1f			call macro_forth_dsp_pop 
37ae				endm 
# End of macro FORTH_DSP_POP
37ae			 
37ae					; TODO push value back onto stack for another op etc 
37ae			 
37ae			;		pop hl 
37ae			 
37ae cd db 1c				call forth_push_numhl 
37b1			 
37b1			.mul_done: 
37b1					NEXTW 
37b1 c3 44 20			jp macro_next 
37b4				endm 
# End of macro NEXTW
37b4			 
37b4			 
37b4			 
37b4			 
37b4			.MIN: 
37b4				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37b4 49				db WORD_SYS_CORE+53             
37b5 35 38			dw .MAX            
37b7 04				db 3 + 1 
37b8 .. 00			db "MIN",0              
37bc				endm 
# End of macro CWHEAD
37bc			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37bc					if DEBUG_FORTH_WORDS_KEY 
37bc						DMARK "MIN" 
37bc f5				push af  
37bd 3a d1 37			ld a, (.dmark)  
37c0 32 b4 fb			ld (debug_mark),a  
37c3 3a d2 37			ld a, (.dmark+1)  
37c6 32 b5 fb			ld (debug_mark+1),a  
37c9 3a d3 37			ld a, (.dmark+2)  
37cc 32 b6 fb			ld (debug_mark+2),a  
37cf 18 03			jr .pastdmark  
37d1 ..			.dmark: db "MIN"  
37d4 f1			.pastdmark: pop af  
37d5			endm  
# End of macro DMARK
37d5						CALLMONITOR 
37d5 cd 7e 16			call break_point_state  
37d8				endm  
# End of macro CALLMONITOR
37d8					endif 
37d8					; get u2 
37d8			 
37d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d8 cd d2 1e			call macro_dsp_valuehl 
37db				endm 
# End of macro FORTH_DSP_VALUEHL
37db			 
37db e5					push hl   ; u2 
37dc			 
37dc					; destroy value TOS 
37dc			 
37dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37dc cd 8a 1f			call macro_forth_dsp_pop 
37df				endm 
# End of macro FORTH_DSP_POP
37df			 
37df					; get u1 
37df			 
37df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37df cd d2 1e			call macro_dsp_valuehl 
37e2				endm 
# End of macro FORTH_DSP_VALUEHL
37e2			 
37e2 e5					push hl  ; u1 
37e3			 
37e3					; destroy value TOS 
37e3			 
37e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e3 cd 8a 1f			call macro_forth_dsp_pop 
37e6				endm 
# End of macro FORTH_DSP_POP
37e6			 
37e6 b7			 or a      ;clear carry flag 
37e7 e1			  pop hl    ; u1 
37e8 d1			  pop de    ; u2 
37e9 e5				push hl   ; saved in case hl is lowest 
37ea ed 52		  sbc hl,de 
37ec 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37ee			 
37ee e1				pop hl 
37ef					if DEBUG_FORTH_WORDS 
37ef						DMARK "MIN" 
37ef f5				push af  
37f0 3a 04 38			ld a, (.dmark)  
37f3 32 b4 fb			ld (debug_mark),a  
37f6 3a 05 38			ld a, (.dmark+1)  
37f9 32 b5 fb			ld (debug_mark+1),a  
37fc 3a 06 38			ld a, (.dmark+2)  
37ff 32 b6 fb			ld (debug_mark+2),a  
3802 18 03			jr .pastdmark  
3804 ..			.dmark: db "MIN"  
3807 f1			.pastdmark: pop af  
3808			endm  
# End of macro DMARK
3808						CALLMONITOR 
3808 cd 7e 16			call break_point_state  
380b				endm  
# End of macro CALLMONITOR
380b					endif 
380b cd db 1c				call forth_push_numhl 
380e			 
380e				       NEXTW 
380e c3 44 20			jp macro_next 
3811				endm 
# End of macro NEXTW
3811			 
3811			.mincont:  
3811 c1				pop bc   ; tidy up 
3812 eb				ex de , hl  
3813					if DEBUG_FORTH_WORDS 
3813						DMARK "MI1" 
3813 f5				push af  
3814 3a 28 38			ld a, (.dmark)  
3817 32 b4 fb			ld (debug_mark),a  
381a 3a 29 38			ld a, (.dmark+1)  
381d 32 b5 fb			ld (debug_mark+1),a  
3820 3a 2a 38			ld a, (.dmark+2)  
3823 32 b6 fb			ld (debug_mark+2),a  
3826 18 03			jr .pastdmark  
3828 ..			.dmark: db "MI1"  
382b f1			.pastdmark: pop af  
382c			endm  
# End of macro DMARK
382c						CALLMONITOR 
382c cd 7e 16			call break_point_state  
382f				endm  
# End of macro CALLMONITOR
382f					endif 
382f cd db 1c				call forth_push_numhl 
3832			 
3832				       NEXTW 
3832 c3 44 20			jp macro_next 
3835				endm 
# End of macro NEXTW
3835			.MAX: 
3835				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3835 4a				db WORD_SYS_CORE+54             
3836 b6 38			dw .RND16            
3838 04				db 3 + 1 
3839 .. 00			db "MAX",0              
383d				endm 
# End of macro CWHEAD
383d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
383d					if DEBUG_FORTH_WORDS_KEY 
383d						DMARK "MAX" 
383d f5				push af  
383e 3a 52 38			ld a, (.dmark)  
3841 32 b4 fb			ld (debug_mark),a  
3844 3a 53 38			ld a, (.dmark+1)  
3847 32 b5 fb			ld (debug_mark+1),a  
384a 3a 54 38			ld a, (.dmark+2)  
384d 32 b6 fb			ld (debug_mark+2),a  
3850 18 03			jr .pastdmark  
3852 ..			.dmark: db "MAX"  
3855 f1			.pastdmark: pop af  
3856			endm  
# End of macro DMARK
3856						CALLMONITOR 
3856 cd 7e 16			call break_point_state  
3859				endm  
# End of macro CALLMONITOR
3859					endif 
3859					; get u2 
3859			 
3859					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3859 cd d2 1e			call macro_dsp_valuehl 
385c				endm 
# End of macro FORTH_DSP_VALUEHL
385c			 
385c e5					push hl   ; u2 
385d			 
385d					; destroy value TOS 
385d			 
385d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385d cd 8a 1f			call macro_forth_dsp_pop 
3860				endm 
# End of macro FORTH_DSP_POP
3860			 
3860					; get u1 
3860			 
3860					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3860 cd d2 1e			call macro_dsp_valuehl 
3863				endm 
# End of macro FORTH_DSP_VALUEHL
3863			 
3863 e5					push hl  ; u1 
3864			 
3864					; destroy value TOS 
3864			 
3864					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3864 cd 8a 1f			call macro_forth_dsp_pop 
3867				endm 
# End of macro FORTH_DSP_POP
3867			 
3867 b7			 or a      ;clear carry flag 
3868 e1			  pop hl    ; u1 
3869 d1			  pop de    ; u2 
386a e5				push hl   ; saved in case hl is lowest 
386b ed 52		  sbc hl,de 
386d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
386f			 
386f e1				pop hl 
3870					if DEBUG_FORTH_WORDS 
3870						DMARK "MAX" 
3870 f5				push af  
3871 3a 85 38			ld a, (.dmark)  
3874 32 b4 fb			ld (debug_mark),a  
3877 3a 86 38			ld a, (.dmark+1)  
387a 32 b5 fb			ld (debug_mark+1),a  
387d 3a 87 38			ld a, (.dmark+2)  
3880 32 b6 fb			ld (debug_mark+2),a  
3883 18 03			jr .pastdmark  
3885 ..			.dmark: db "MAX"  
3888 f1			.pastdmark: pop af  
3889			endm  
# End of macro DMARK
3889						CALLMONITOR 
3889 cd 7e 16			call break_point_state  
388c				endm  
# End of macro CALLMONITOR
388c					endif 
388c cd db 1c				call forth_push_numhl 
388f			 
388f				       NEXTW 
388f c3 44 20			jp macro_next 
3892				endm 
# End of macro NEXTW
3892			 
3892			.maxcont:  
3892 c1				pop bc   ; tidy up 
3893 eb				ex de , hl  
3894					if DEBUG_FORTH_WORDS 
3894						DMARK "MA1" 
3894 f5				push af  
3895 3a a9 38			ld a, (.dmark)  
3898 32 b4 fb			ld (debug_mark),a  
389b 3a aa 38			ld a, (.dmark+1)  
389e 32 b5 fb			ld (debug_mark+1),a  
38a1 3a ab 38			ld a, (.dmark+2)  
38a4 32 b6 fb			ld (debug_mark+2),a  
38a7 18 03			jr .pastdmark  
38a9 ..			.dmark: db "MA1"  
38ac f1			.pastdmark: pop af  
38ad			endm  
# End of macro DMARK
38ad						CALLMONITOR 
38ad cd 7e 16			call break_point_state  
38b0				endm  
# End of macro CALLMONITOR
38b0					endif 
38b0 cd db 1c				call forth_push_numhl 
38b3				       NEXTW 
38b3 c3 44 20			jp macro_next 
38b6				endm 
# End of macro NEXTW
38b6			 
38b6			.RND16: 
38b6				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38b6 4e				db WORD_SYS_CORE+58             
38b7 e5 38			dw .RND8            
38b9 06				db 5 + 1 
38ba .. 00			db "RND16",0              
38c0				endm 
# End of macro CWHEAD
38c0			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38c0					if DEBUG_FORTH_WORDS_KEY 
38c0						DMARK "R16" 
38c0 f5				push af  
38c1 3a d5 38			ld a, (.dmark)  
38c4 32 b4 fb			ld (debug_mark),a  
38c7 3a d6 38			ld a, (.dmark+1)  
38ca 32 b5 fb			ld (debug_mark+1),a  
38cd 3a d7 38			ld a, (.dmark+2)  
38d0 32 b6 fb			ld (debug_mark+2),a  
38d3 18 03			jr .pastdmark  
38d5 ..			.dmark: db "R16"  
38d8 f1			.pastdmark: pop af  
38d9			endm  
# End of macro DMARK
38d9						CALLMONITOR 
38d9 cd 7e 16			call break_point_state  
38dc				endm  
# End of macro CALLMONITOR
38dc					endif 
38dc cd 28 0c				call prng16  
38df cd db 1c				call forth_push_numhl 
38e2				       NEXTW 
38e2 c3 44 20			jp macro_next 
38e5				endm 
# End of macro NEXTW
38e5			.RND8: 
38e5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38e5 60				db WORD_SYS_CORE+76             
38e6 1a 39			dw .RND            
38e8 05				db 4 + 1 
38e9 .. 00			db "RND8",0              
38ee				endm 
# End of macro CWHEAD
38ee			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38ee					if DEBUG_FORTH_WORDS_KEY 
38ee						DMARK "RN8" 
38ee f5				push af  
38ef 3a 03 39			ld a, (.dmark)  
38f2 32 b4 fb			ld (debug_mark),a  
38f5 3a 04 39			ld a, (.dmark+1)  
38f8 32 b5 fb			ld (debug_mark+1),a  
38fb 3a 05 39			ld a, (.dmark+2)  
38fe 32 b6 fb			ld (debug_mark+2),a  
3901 18 03			jr .pastdmark  
3903 ..			.dmark: db "RN8"  
3906 f1			.pastdmark: pop af  
3907			endm  
# End of macro DMARK
3907						CALLMONITOR 
3907 cd 7e 16			call break_point_state  
390a				endm  
# End of macro CALLMONITOR
390a					endif 
390a 2a 35 fa				ld hl,(xrandc) 
390d 23					inc hl 
390e cd 42 0c				call xrnd 
3911 6f					ld l,a	 
3912 26 00				ld h,0 
3914 cd db 1c				call forth_push_numhl 
3917				       NEXTW 
3917 c3 44 20			jp macro_next 
391a				endm 
# End of macro NEXTW
391a			.RND: 
391a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
391a 60				db WORD_SYS_CORE+76             
391b 20 3a			dw .ENDMATHS            
391d 04				db 3 + 1 
391e .. 00			db "RND",0              
3922				endm 
# End of macro CWHEAD
3922			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3922			 
3922					if DEBUG_FORTH_WORDS_KEY 
3922						DMARK "RND" 
3922 f5				push af  
3923 3a 37 39			ld a, (.dmark)  
3926 32 b4 fb			ld (debug_mark),a  
3929 3a 38 39			ld a, (.dmark+1)  
392c 32 b5 fb			ld (debug_mark+1),a  
392f 3a 39 39			ld a, (.dmark+2)  
3932 32 b6 fb			ld (debug_mark+2),a  
3935 18 03			jr .pastdmark  
3937 ..			.dmark: db "RND"  
393a f1			.pastdmark: pop af  
393b			endm  
# End of macro DMARK
393b						CALLMONITOR 
393b cd 7e 16			call break_point_state  
393e				endm  
# End of macro CALLMONITOR
393e					endif 
393e					 
393e					FORTH_DSP_VALUEHL    ; upper range 
393e cd d2 1e			call macro_dsp_valuehl 
3941				endm 
# End of macro FORTH_DSP_VALUEHL
3941			 
3941 22 39 fa				ld (LFSRSeed), hl	 
3944			 
3944					if DEBUG_FORTH_WORDS 
3944						DMARK "RN1" 
3944 f5				push af  
3945 3a 59 39			ld a, (.dmark)  
3948 32 b4 fb			ld (debug_mark),a  
394b 3a 5a 39			ld a, (.dmark+1)  
394e 32 b5 fb			ld (debug_mark+1),a  
3951 3a 5b 39			ld a, (.dmark+2)  
3954 32 b6 fb			ld (debug_mark+2),a  
3957 18 03			jr .pastdmark  
3959 ..			.dmark: db "RN1"  
395c f1			.pastdmark: pop af  
395d			endm  
# End of macro DMARK
395d						CALLMONITOR 
395d cd 7e 16			call break_point_state  
3960				endm  
# End of macro CALLMONITOR
3960					endif 
3960					FORTH_DSP_POP 
3960 cd 8a 1f			call macro_forth_dsp_pop 
3963				endm 
# End of macro FORTH_DSP_POP
3963			 
3963					FORTH_DSP_VALUEHL    ; low range 
3963 cd d2 1e			call macro_dsp_valuehl 
3966				endm 
# End of macro FORTH_DSP_VALUEHL
3966			 
3966					if DEBUG_FORTH_WORDS 
3966						DMARK "RN2" 
3966 f5				push af  
3967 3a 7b 39			ld a, (.dmark)  
396a 32 b4 fb			ld (debug_mark),a  
396d 3a 7c 39			ld a, (.dmark+1)  
3970 32 b5 fb			ld (debug_mark+1),a  
3973 3a 7d 39			ld a, (.dmark+2)  
3976 32 b6 fb			ld (debug_mark+2),a  
3979 18 03			jr .pastdmark  
397b ..			.dmark: db "RN2"  
397e f1			.pastdmark: pop af  
397f			endm  
# End of macro DMARK
397f						CALLMONITOR 
397f cd 7e 16			call break_point_state  
3982				endm  
# End of macro CALLMONITOR
3982					endif 
3982 22 3b fa				ld (LFSRSeed+2), hl 
3985			 
3985					FORTH_DSP_POP 
3985 cd 8a 1f			call macro_forth_dsp_pop 
3988				endm 
# End of macro FORTH_DSP_POP
3988			 
3988 e5					push hl 
3989			 
3989 e1			.inrange:	pop hl 
398a cd 28 0c				call prng16  
398d					if DEBUG_FORTH_WORDS 
398d						DMARK "RN3" 
398d f5				push af  
398e 3a a2 39			ld a, (.dmark)  
3991 32 b4 fb			ld (debug_mark),a  
3994 3a a3 39			ld a, (.dmark+1)  
3997 32 b5 fb			ld (debug_mark+1),a  
399a 3a a4 39			ld a, (.dmark+2)  
399d 32 b6 fb			ld (debug_mark+2),a  
39a0 18 03			jr .pastdmark  
39a2 ..			.dmark: db "RN3"  
39a5 f1			.pastdmark: pop af  
39a6			endm  
# End of macro DMARK
39a6						CALLMONITOR 
39a6 cd 7e 16			call break_point_state  
39a9				endm  
# End of macro CALLMONITOR
39a9					endif 
39a9					 
39a9					; if the range is 8bit knock out the high byte 
39a9			 
39a9 ed 5b 39 fa			ld de, (LFSRSeed)     ; check high level 
39ad			 
39ad 3e 00				ld a, 0 
39af ba					cp d  
39b0 20 1e				jr nz, .hirange 
39b2 26 00				ld h, 0   ; knock it down to 8bit 
39b4			 
39b4					if DEBUG_FORTH_WORDS 
39b4						DMARK "RNk" 
39b4 f5				push af  
39b5 3a c9 39			ld a, (.dmark)  
39b8 32 b4 fb			ld (debug_mark),a  
39bb 3a ca 39			ld a, (.dmark+1)  
39be 32 b5 fb			ld (debug_mark+1),a  
39c1 3a cb 39			ld a, (.dmark+2)  
39c4 32 b6 fb			ld (debug_mark+2),a  
39c7 18 03			jr .pastdmark  
39c9 ..			.dmark: db "RNk"  
39cc f1			.pastdmark: pop af  
39cd			endm  
# End of macro DMARK
39cd						CALLMONITOR 
39cd cd 7e 16			call break_point_state  
39d0				endm  
# End of macro CALLMONITOR
39d0					endif 
39d0			.hirange:   
39d0 e5					push hl  
39d1 b7					or a  
39d2 ed 52		                sbc hl, de 
39d4			 
39d4					;call cmp16 
39d4			 
39d4 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39d6 e1					pop hl 
39d7 e5					push hl 
39d8			 
39d8					if DEBUG_FORTH_WORDS 
39d8						DMARK "RN4" 
39d8 f5				push af  
39d9 3a ed 39			ld a, (.dmark)  
39dc 32 b4 fb			ld (debug_mark),a  
39df 3a ee 39			ld a, (.dmark+1)  
39e2 32 b5 fb			ld (debug_mark+1),a  
39e5 3a ef 39			ld a, (.dmark+2)  
39e8 32 b6 fb			ld (debug_mark+2),a  
39eb 18 03			jr .pastdmark  
39ed ..			.dmark: db "RN4"  
39f0 f1			.pastdmark: pop af  
39f1			endm  
# End of macro DMARK
39f1						CALLMONITOR 
39f1 cd 7e 16			call break_point_state  
39f4				endm  
# End of macro CALLMONITOR
39f4					endif 
39f4 ed 5b 3b fa			ld de, (LFSRSeed+2)   ; check low range 
39f8					;call cmp16 
39f8				 
39f8 b7					or a  
39f9 ed 52		                sbc hl, de 
39fb 38 8c				jr c, .inrange 
39fd			 
39fd e1					pop hl 
39fe					 
39fe					if DEBUG_FORTH_WORDS 
39fe						DMARK "RNd" 
39fe f5				push af  
39ff 3a 13 3a			ld a, (.dmark)  
3a02 32 b4 fb			ld (debug_mark),a  
3a05 3a 14 3a			ld a, (.dmark+1)  
3a08 32 b5 fb			ld (debug_mark+1),a  
3a0b 3a 15 3a			ld a, (.dmark+2)  
3a0e 32 b6 fb			ld (debug_mark+2),a  
3a11 18 03			jr .pastdmark  
3a13 ..			.dmark: db "RNd"  
3a16 f1			.pastdmark: pop af  
3a17			endm  
# End of macro DMARK
3a17						CALLMONITOR 
3a17 cd 7e 16			call break_point_state  
3a1a				endm  
# End of macro CALLMONITOR
3a1a					endif 
3a1a			 
3a1a			 
3a1a cd db 1c				call forth_push_numhl 
3a1d				       NEXTW 
3a1d c3 44 20			jp macro_next 
3a20				endm 
# End of macro NEXTW
3a20			 
3a20			.ENDMATHS: 
3a20			 
3a20			; eof 
3a20			 
# End of file forth_words_maths.asm
3a20			include "forth_words_display.asm" 
3a20			 
3a20			; | ## Display Words 
3a20			 
3a20			.INFO: 
3a20			 
3a20				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a20 62				db WORD_SYS_CORE+78             
3a21 3d 3a			dw .ATP            
3a23 05				db 4 + 1 
3a24 .. 00			db "INFO",0              
3a29				endm 
# End of macro CWHEAD
3a29			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a29					FORTH_DSP_VALUEHL 
3a29 cd d2 1e			call macro_dsp_valuehl 
3a2c				endm 
# End of macro FORTH_DSP_VALUEHL
3a2c			 
3a2c					FORTH_DSP_POP 
3a2c cd 8a 1f			call macro_forth_dsp_pop 
3a2f				endm 
# End of macro FORTH_DSP_POP
3a2f			 
3a2f e5					push hl 
3a30			 
3a30					FORTH_DSP_VALUEHL 
3a30 cd d2 1e			call macro_dsp_valuehl 
3a33				endm 
# End of macro FORTH_DSP_VALUEHL
3a33			 
3a33					FORTH_DSP_POP 
3a33 cd 8a 1f			call macro_forth_dsp_pop 
3a36				endm 
# End of macro FORTH_DSP_POP
3a36			 
3a36 d1					pop de 
3a37			 
3a37 cd 5e 0a				call info_panel 
3a3a			 
3a3a			 
3a3a					NEXTW 
3a3a c3 44 20			jp macro_next 
3a3d				endm 
# End of macro NEXTW
3a3d			.ATP: 
3a3d				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a3d 62				db WORD_SYS_CORE+78             
3a3e b4 3a			dw .FB            
3a40 04				db 3 + 1 
3a41 .. 00			db "AT?",0              
3a45				endm 
# End of macro CWHEAD
3a45			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a45					if DEBUG_FORTH_WORDS_KEY 
3a45						DMARK "AT?" 
3a45 f5				push af  
3a46 3a 5a 3a			ld a, (.dmark)  
3a49 32 b4 fb			ld (debug_mark),a  
3a4c 3a 5b 3a			ld a, (.dmark+1)  
3a4f 32 b5 fb			ld (debug_mark+1),a  
3a52 3a 5c 3a			ld a, (.dmark+2)  
3a55 32 b6 fb			ld (debug_mark+2),a  
3a58 18 03			jr .pastdmark  
3a5a ..			.dmark: db "AT?"  
3a5d f1			.pastdmark: pop af  
3a5e			endm  
# End of macro DMARK
3a5e						CALLMONITOR 
3a5e cd 7e 16			call break_point_state  
3a61				endm  
# End of macro CALLMONITOR
3a61					endif 
3a61 3a c3 f9				ld a, (f_cursor_ptr) 
3a64			 
3a64			if DEBUG_FORTH_WORDS 
3a64				DMARK "AT?" 
3a64 f5				push af  
3a65 3a 79 3a			ld a, (.dmark)  
3a68 32 b4 fb			ld (debug_mark),a  
3a6b 3a 7a 3a			ld a, (.dmark+1)  
3a6e 32 b5 fb			ld (debug_mark+1),a  
3a71 3a 7b 3a			ld a, (.dmark+2)  
3a74 32 b6 fb			ld (debug_mark+2),a  
3a77 18 03			jr .pastdmark  
3a79 ..			.dmark: db "AT?"  
3a7c f1			.pastdmark: pop af  
3a7d			endm  
# End of macro DMARK
3a7d				CALLMONITOR 
3a7d cd 7e 16			call break_point_state  
3a80				endm  
# End of macro CALLMONITOR
3a80			endif	 
3a80					; count the number of rows 
3a80			 
3a80 06 00				ld b, 0 
3a82 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a83 d6 14				sub display_cols 
3a85 f2 8b 3a				jp p, .atprunder 
3a88 04					inc b 
3a89 18 f7				jr .atpr 
3a8b			.atprunder:	 
3a8b			if DEBUG_FORTH_WORDS 
3a8b				DMARK "A?2" 
3a8b f5				push af  
3a8c 3a a0 3a			ld a, (.dmark)  
3a8f 32 b4 fb			ld (debug_mark),a  
3a92 3a a1 3a			ld a, (.dmark+1)  
3a95 32 b5 fb			ld (debug_mark+1),a  
3a98 3a a2 3a			ld a, (.dmark+2)  
3a9b 32 b6 fb			ld (debug_mark+2),a  
3a9e 18 03			jr .pastdmark  
3aa0 ..			.dmark: db "A?2"  
3aa3 f1			.pastdmark: pop af  
3aa4			endm  
# End of macro DMARK
3aa4				CALLMONITOR 
3aa4 cd 7e 16			call break_point_state  
3aa7				endm  
# End of macro CALLMONITOR
3aa7			endif	 
3aa7 26 00				ld h, 0 
3aa9 69					ld l, c 
3aaa cd db 1c				call forth_push_numhl 
3aad 68					ld l, b  
3aae cd db 1c				call forth_push_numhl 
3ab1			 
3ab1			 
3ab1				NEXTW 
3ab1 c3 44 20			jp macro_next 
3ab4				endm 
# End of macro NEXTW
3ab4			 
3ab4			.FB: 
3ab4				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ab4 1b				db WORD_SYS_CORE+7             
3ab5 02 3b			dw .EMIT            
3ab7 03				db 2 + 1 
3ab8 .. 00			db "FB",0              
3abb				endm 
# End of macro CWHEAD
3abb			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3abb			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3abb			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3abb			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3abb					if DEBUG_FORTH_WORDS_KEY 
3abb						DMARK "FB." 
3abb f5				push af  
3abc 3a d0 3a			ld a, (.dmark)  
3abf 32 b4 fb			ld (debug_mark),a  
3ac2 3a d1 3a			ld a, (.dmark+1)  
3ac5 32 b5 fb			ld (debug_mark+1),a  
3ac8 3a d2 3a			ld a, (.dmark+2)  
3acb 32 b6 fb			ld (debug_mark+2),a  
3ace 18 03			jr .pastdmark  
3ad0 ..			.dmark: db "FB."  
3ad3 f1			.pastdmark: pop af  
3ad4			endm  
# End of macro DMARK
3ad4						CALLMONITOR 
3ad4 cd 7e 16			call break_point_state  
3ad7				endm  
# End of macro CALLMONITOR
3ad7					endif 
3ad7			 
3ad7					FORTH_DSP_VALUEHL 
3ad7 cd d2 1e			call macro_dsp_valuehl 
3ada				endm 
# End of macro FORTH_DSP_VALUEHL
3ada			 
3ada 7d					ld a, l 
3adb fe 01				cp 1 
3add 20 05				jr nz, .fbn1 
3adf 21 f9 fa				ld hl, display_fb1 
3ae2 18 15				jr .fbset 
3ae4 fe 02		.fbn1:		cp 2 
3ae6 20 05				jr nz, .fbn2 
3ae8 21 57 fa				ld hl, display_fb2 
3aeb 18 0c				jr .fbset 
3aed fe 03		.fbn2:		cp 3 
3aef 20 05				jr nz, .fbn3 
3af1 21 a8 fa				ld hl, display_fb3 
3af4 18 03				jr .fbset 
3af6			.fbn3:		 ; if invalid number select first 
3af6 21 f9 fa				ld hl, display_fb1 
3af9 22 55 fa		.fbset:		ld (display_fb_active), hl 
3afc			 
3afc					FORTH_DSP_POP 
3afc cd 8a 1f			call macro_forth_dsp_pop 
3aff				endm 
# End of macro FORTH_DSP_POP
3aff			 
3aff					NEXTW 
3aff c3 44 20			jp macro_next 
3b02				endm 
# End of macro NEXTW
3b02			 
3b02			 
3b02			.EMIT: 
3b02				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b02 1b				db WORD_SYS_CORE+7             
3b03 53 3b			dw .DOTH            
3b05 05				db 4 + 1 
3b06 .. 00			db "EMIT",0              
3b0b				endm 
# End of macro CWHEAD
3b0b			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b0b					; get value off TOS and display it 
3b0b			 
3b0b					if DEBUG_FORTH_WORDS_KEY 
3b0b						DMARK "EMT" 
3b0b f5				push af  
3b0c 3a 20 3b			ld a, (.dmark)  
3b0f 32 b4 fb			ld (debug_mark),a  
3b12 3a 21 3b			ld a, (.dmark+1)  
3b15 32 b5 fb			ld (debug_mark+1),a  
3b18 3a 22 3b			ld a, (.dmark+2)  
3b1b 32 b6 fb			ld (debug_mark+2),a  
3b1e 18 03			jr .pastdmark  
3b20 ..			.dmark: db "EMT"  
3b23 f1			.pastdmark: pop af  
3b24			endm  
# End of macro DMARK
3b24						CALLMONITOR 
3b24 cd 7e 16			call break_point_state  
3b27				endm  
# End of macro CALLMONITOR
3b27					endif 
3b27			 
3b27					FORTH_DSP_VALUEHL 
3b27 cd d2 1e			call macro_dsp_valuehl 
3b2a				endm 
# End of macro FORTH_DSP_VALUEHL
3b2a			 
3b2a 7d					ld a,l 
3b2b			 
3b2b					; TODO write to display 
3b2b			 
3b2b 32 98 f1				ld (os_input), a 
3b2e 3e 00				ld a, 0 
3b30 32 99 f1				ld (os_input+1), a 
3b33					 
3b33 3a c3 f9				ld a, (f_cursor_ptr) 
3b36 11 98 f1				ld de, os_input 
3b39 cd e0 0a				call str_at_display 
3b3c			 
3b3c			 
3b3c 3a a1 f9				ld a,(cli_autodisplay) 
3b3f fe 00				cp 0 
3b41 28 03				jr z, .enoupdate 
3b43 cd f0 0a						call update_display 
3b46					.enoupdate: 
3b46			 
3b46 3a c3 f9				ld a, (f_cursor_ptr) 
3b49 3c					inc a 
3b4a 32 c3 f9				ld (f_cursor_ptr), a   ; save new pos 
3b4d			 
3b4d			 
3b4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4d cd 8a 1f			call macro_forth_dsp_pop 
3b50				endm 
# End of macro FORTH_DSP_POP
3b50			  
3b50			 
3b50					NEXTW 
3b50 c3 44 20			jp macro_next 
3b53				endm 
# End of macro NEXTW
3b53			.DOTH: 
3b53				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b53 1c				db WORD_SYS_CORE+8             
3b54 83 3b			dw .DOTF            
3b56 03				db 2 + 1 
3b57 .. 00			db ".-",0              
3b5a				endm 
# End of macro CWHEAD
3b5a			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b5a					; get value off TOS and display it 
3b5a					if DEBUG_FORTH_WORDS_KEY 
3b5a						DMARK "DTD" 
3b5a f5				push af  
3b5b 3a 6f 3b			ld a, (.dmark)  
3b5e 32 b4 fb			ld (debug_mark),a  
3b61 3a 70 3b			ld a, (.dmark+1)  
3b64 32 b5 fb			ld (debug_mark+1),a  
3b67 3a 71 3b			ld a, (.dmark+2)  
3b6a 32 b6 fb			ld (debug_mark+2),a  
3b6d 18 03			jr .pastdmark  
3b6f ..			.dmark: db "DTD"  
3b72 f1			.pastdmark: pop af  
3b73			endm  
# End of macro DMARK
3b73						CALLMONITOR 
3b73 cd 7e 16			call break_point_state  
3b76				endm  
# End of macro CALLMONITOR
3b76					endif 
3b76 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b78 3e 00			ld a, 0 
3b7a 32 a2 f9			ld (cli_mvdot), a 
3b7d c3 da 3b			jp .dotgo 
3b80				NEXTW 
3b80 c3 44 20			jp macro_next 
3b83				endm 
# End of macro NEXTW
3b83			.DOTF: 
3b83				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b83 1c				db WORD_SYS_CORE+8             
3b84 b1 3b			dw .DOT            
3b86 03				db 2 + 1 
3b87 .. 00			db ".>",0              
3b8a				endm 
# End of macro CWHEAD
3b8a			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b8a					; get value off TOS and display it 
3b8a			        ; TODO BUG adds extra spaces 
3b8a			        ; TODO BUG handle numerics? 
3b8a					if DEBUG_FORTH_WORDS_KEY 
3b8a						DMARK "DTC" 
3b8a f5				push af  
3b8b 3a 9f 3b			ld a, (.dmark)  
3b8e 32 b4 fb			ld (debug_mark),a  
3b91 3a a0 3b			ld a, (.dmark+1)  
3b94 32 b5 fb			ld (debug_mark+1),a  
3b97 3a a1 3b			ld a, (.dmark+2)  
3b9a 32 b6 fb			ld (debug_mark+2),a  
3b9d 18 03			jr .pastdmark  
3b9f ..			.dmark: db "DTC"  
3ba2 f1			.pastdmark: pop af  
3ba3			endm  
# End of macro DMARK
3ba3						CALLMONITOR 
3ba3 cd 7e 16			call break_point_state  
3ba6				endm  
# End of macro CALLMONITOR
3ba6					endif 
3ba6 3e 01			ld a, 1 
3ba8 32 a2 f9			ld (cli_mvdot), a 
3bab c3 da 3b			jp .dotgo 
3bae				NEXTW 
3bae c3 44 20			jp macro_next 
3bb1				endm 
# End of macro NEXTW
3bb1			 
3bb1			.DOT: 
3bb1				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bb1 1c				db WORD_SYS_CORE+8             
3bb2 3d 3c			dw .CLS            
3bb4 02				db 1 + 1 
3bb5 .. 00			db ".",0              
3bb7				endm 
# End of macro CWHEAD
3bb7			        ; | . ( u -- ) Display TOS | DONE 
3bb7					; get value off TOS and display it 
3bb7			 
3bb7					if DEBUG_FORTH_WORDS_KEY 
3bb7						DMARK "DOT" 
3bb7 f5				push af  
3bb8 3a cc 3b			ld a, (.dmark)  
3bbb 32 b4 fb			ld (debug_mark),a  
3bbe 3a cd 3b			ld a, (.dmark+1)  
3bc1 32 b5 fb			ld (debug_mark+1),a  
3bc4 3a ce 3b			ld a, (.dmark+2)  
3bc7 32 b6 fb			ld (debug_mark+2),a  
3bca 18 03			jr .pastdmark  
3bcc ..			.dmark: db "DOT"  
3bcf f1			.pastdmark: pop af  
3bd0			endm  
# End of macro DMARK
3bd0						CALLMONITOR 
3bd0 cd 7e 16			call break_point_state  
3bd3				endm  
# End of macro CALLMONITOR
3bd3					endif 
3bd3 3e 00			ld a, 0 
3bd5 32 a2 f9			ld (cli_mvdot), a 
3bd8 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bda				 
3bda			 
3bda			.dotgo: 
3bda			 
3bda			; move up type to on stack for parserv5 
3bda					FORTH_DSP 
3bda cd 98 1e			call macro_forth_dsp 
3bdd				endm 
# End of macro FORTH_DSP
3bdd				;FORTH_DSP_VALUE  
3bdd			 
3bdd			if DEBUG_FORTH_DOT 
3bdd				DMARK "DOT" 
3bdd				CALLMONITOR 
3bdd			endif	 
3bdd			;		.print: 
3bdd			 
3bdd 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bde 23				inc hl   ; position to the actual value 
3bdf fe 01			cp DS_TYPE_STR 
3be1 20 06			jr nz, .dotnum1  
3be3			 
3be3			; display string 
3be3				FORTH_DSP_VALUE  
3be3 cd bb 1e			call macro_forth_dsp_value 
3be6				endm 
# End of macro FORTH_DSP_VALUE
3be6 eb				ex de,hl 
3be7 18 11			jr .dotwrite 
3be9			 
3be9			.dotnum1: 
3be9 fe 02			cp DS_TYPE_INUM 
3beb 20 0c			jr nz, .dotflot 
3bed			 
3bed			 
3bed			; display number 
3bed			 
3bed			;	push hl 
3bed			;	call clear_display 
3bed			;	pop hl 
3bed			 
3bed 5e				ld e, (hl) 
3bee 23				inc hl 
3bef 56				ld d, (hl) 
3bf0 21 9a ef			ld hl, scratch 
3bf3			if DEBUG_FORTH_DOT 
3bf3				DMARK "DT1" 
3bf3				CALLMONITOR 
3bf3			endif	 
3bf3			 
3bf3 cd 0e 11			call uitoa_16 
3bf6 eb				ex de,hl 
3bf7			 
3bf7			if DEBUG_FORTH_DOT 
3bf7				DMARK "DT2" 
3bf7				CALLMONITOR 
3bf7			endif	 
3bf7			 
3bf7			;	ld de, os_word_scratch 
3bf7 18 01			jr .dotwrite 
3bf9			 
3bf9 00			.dotflot:   nop 
3bfa			; TODO print floating point number 
3bfa			 
3bfa			.dotwrite:		 
3bfa			 
3bfa					; if c is set then set all '-' to spaces 
3bfa					; need to also take into account .>  
3bfa			 
3bfa 3e 01				ld a, 1 
3bfc b9					cp c 
3bfd 20 13				jr nz, .nodashswap 
3bff			 
3bff					; DE has the string to write, working with HL 
3bff			 
3bff 06 ff				ld b, 255 
3c01 d5					push de 
3c02 e1					pop hl 
3c03			 
3c03			if DEBUG_FORTH_DOT 
3c03				DMARK "DT-" 
3c03				CALLMONITOR 
3c03			endif	 
3c03 7e			.dashscan:	ld a, (hl) 
3c04 fe 00				cp 0 
3c06 28 0a				jr z, .nodashswap 
3c08 fe 2d				cp '-' 
3c0a 20 03				jr nz, .dashskip 
3c0c 3e 20				ld a, ' ' 
3c0e 77					ld (hl), a 
3c0f 23			.dashskip:	inc hl 
3c10			if DEBUG_FORTH_DOT 
3c10				DMARK "D-2" 
3c10				CALLMONITOR 
3c10			endif	 
3c10 10 f1				djnz .dashscan 
3c12			 
3c12			if DEBUG_FORTH_DOT 
3c12				DMARK "D-1" 
3c12				CALLMONITOR 
3c12			endif	 
3c12			 
3c12			.nodashswap: 
3c12			 
3c12 e5					push hl   ; save string start in case we need to advance print 
3c13			 
3c13 3a c3 f9				ld a, (f_cursor_ptr) 
3c16 cd e0 0a				call str_at_display 
3c19 3a a1 f9				ld a,(cli_autodisplay) 
3c1c fe 00				cp 0 
3c1e 28 03				jr z, .noupdate 
3c20 cd f0 0a						call update_display 
3c23					.noupdate: 
3c23			 
3c23			 
3c23					; see if we need to advance the print position 
3c23			 
3c23 e1					pop hl   ; get back string 
3c24			 
3c24 3a a2 f9				ld a, (cli_mvdot) 
3c27			if DEBUG_FORTH_DOT 
3c27					ld e,a 
3c27				DMARK "D>1" 
3c27				CALLMONITOR 
3c27			endif	 
3c27 fe 00				cp 0 
3c29 28 0c				jr z, .noadv 
3c2b					; yes, lets advance the print position 
3c2b 3e 00				ld a, 0 
3c2d cd 6a 11				call strlent 
3c30 3a c3 f9				ld a, (f_cursor_ptr) 
3c33 85					add a,l 
3c34					;call addatohl 
3c34					;ld a, l 
3c34 32 c3 f9				ld (f_cursor_ptr), a   ; save new pos 
3c37			 
3c37			if DEBUG_FORTH_DOT 
3c37				DMARK "D->" 
3c37				CALLMONITOR 
3c37			endif	 
3c37			 
3c37			.noadv:	 
3c37			 
3c37					if DEBUG_FORTH_DOT_WAIT 
3c37							call next_page_prompt 
3c37					endif	 
3c37			; TODO this pop off the stack causes a crash. i dont know why 
3c37			 
3c37			 
3c37			if DEBUG_FORTH_DOT 
3c37				DMARK "DTh" 
3c37				CALLMONITOR 
3c37			endif	 
3c37			 
3c37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c37 cd 8a 1f			call macro_forth_dsp_pop 
3c3a				endm 
# End of macro FORTH_DSP_POP
3c3a			 
3c3a			if DEBUG_FORTH_DOT 
3c3a				DMARK "DTi" 
3c3a				CALLMONITOR 
3c3a			endif	 
3c3a			 
3c3a			 
3c3a					NEXTW 
3c3a c3 44 20			jp macro_next 
3c3d				endm 
# End of macro NEXTW
3c3d			 
3c3d			.CLS: 
3c3d				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c3d 35				db WORD_SYS_CORE+33             
3c3e 6a 3c			dw .DRAW            
3c40 04				db 3 + 1 
3c41 .. 00			db "CLS",0              
3c45				endm 
# End of macro CWHEAD
3c45			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c45					if DEBUG_FORTH_WORDS_KEY 
3c45						DMARK "CLS" 
3c45 f5				push af  
3c46 3a 5a 3c			ld a, (.dmark)  
3c49 32 b4 fb			ld (debug_mark),a  
3c4c 3a 5b 3c			ld a, (.dmark+1)  
3c4f 32 b5 fb			ld (debug_mark+1),a  
3c52 3a 5c 3c			ld a, (.dmark+2)  
3c55 32 b6 fb			ld (debug_mark+2),a  
3c58 18 03			jr .pastdmark  
3c5a ..			.dmark: db "CLS"  
3c5d f1			.pastdmark: pop af  
3c5e			endm  
# End of macro DMARK
3c5e						CALLMONITOR 
3c5e cd 7e 16			call break_point_state  
3c61				endm  
# End of macro CALLMONITOR
3c61					endif 
3c61 cd cd 0a				call clear_display 
3c64 c3 78 3d				jp .home		; and home cursor 
3c67					NEXTW 
3c67 c3 44 20			jp macro_next 
3c6a				endm 
# End of macro NEXTW
3c6a			 
3c6a			.DRAW: 
3c6a				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c6a 36				db WORD_SYS_CORE+34             
3c6b 95 3c			dw .DUMP            
3c6d 05				db 4 + 1 
3c6e .. 00			db "DRAW",0              
3c73				endm 
# End of macro CWHEAD
3c73			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c73					if DEBUG_FORTH_WORDS_KEY 
3c73						DMARK "DRW" 
3c73 f5				push af  
3c74 3a 88 3c			ld a, (.dmark)  
3c77 32 b4 fb			ld (debug_mark),a  
3c7a 3a 89 3c			ld a, (.dmark+1)  
3c7d 32 b5 fb			ld (debug_mark+1),a  
3c80 3a 8a 3c			ld a, (.dmark+2)  
3c83 32 b6 fb			ld (debug_mark+2),a  
3c86 18 03			jr .pastdmark  
3c88 ..			.dmark: db "DRW"  
3c8b f1			.pastdmark: pop af  
3c8c			endm  
# End of macro DMARK
3c8c						CALLMONITOR 
3c8c cd 7e 16			call break_point_state  
3c8f				endm  
# End of macro CALLMONITOR
3c8f					endif 
3c8f cd f0 0a				call update_display 
3c92					NEXTW 
3c92 c3 44 20			jp macro_next 
3c95				endm 
# End of macro NEXTW
3c95			 
3c95			.DUMP: 
3c95				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c95 37				db WORD_SYS_CORE+35             
3c96 cd 3c			dw .CDUMP            
3c98 05				db 4 + 1 
3c99 .. 00			db "DUMP",0              
3c9e				endm 
# End of macro CWHEAD
3c9e			; | DUMP ( x -- ) With address x display dump   | DONE 
3c9e			; TODO pop address to use off of the stack 
3c9e					if DEBUG_FORTH_WORDS_KEY 
3c9e						DMARK "DUM" 
3c9e f5				push af  
3c9f 3a b3 3c			ld a, (.dmark)  
3ca2 32 b4 fb			ld (debug_mark),a  
3ca5 3a b4 3c			ld a, (.dmark+1)  
3ca8 32 b5 fb			ld (debug_mark+1),a  
3cab 3a b5 3c			ld a, (.dmark+2)  
3cae 32 b6 fb			ld (debug_mark+2),a  
3cb1 18 03			jr .pastdmark  
3cb3 ..			.dmark: db "DUM"  
3cb6 f1			.pastdmark: pop af  
3cb7			endm  
# End of macro DMARK
3cb7						CALLMONITOR 
3cb7 cd 7e 16			call break_point_state  
3cba				endm  
# End of macro CALLMONITOR
3cba					endif 
3cba cd cd 0a				call clear_display 
3cbd			 
3cbd					; get address 
3cbd			 
3cbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cbd cd d2 1e			call macro_dsp_valuehl 
3cc0				endm 
# End of macro FORTH_DSP_VALUEHL
3cc0				 
3cc0					; save it for cdump 
3cc0			 
3cc0 22 bd f2				ld (os_cur_ptr),hl 
3cc3			 
3cc3					; destroy value TOS 
3cc3			 
3cc3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc3 cd 8a 1f			call macro_forth_dsp_pop 
3cc6				endm 
# End of macro FORTH_DSP_POP
3cc6			 
3cc6 cd 5b 1b				call dumpcont	; skip old style of param parsing	 
3cc9 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3cca					NEXTW 
3cca c3 44 20			jp macro_next 
3ccd				endm 
# End of macro NEXTW
3ccd			.CDUMP: 
3ccd				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ccd 38				db WORD_SYS_CORE+36             
3cce fd 3c			dw .DAT            
3cd0 06				db 5 + 1 
3cd1 .. 00			db "CDUMP",0              
3cd7				endm 
# End of macro CWHEAD
3cd7			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3cd7					if DEBUG_FORTH_WORDS_KEY 
3cd7						DMARK "CDP" 
3cd7 f5				push af  
3cd8 3a ec 3c			ld a, (.dmark)  
3cdb 32 b4 fb			ld (debug_mark),a  
3cde 3a ed 3c			ld a, (.dmark+1)  
3ce1 32 b5 fb			ld (debug_mark+1),a  
3ce4 3a ee 3c			ld a, (.dmark+2)  
3ce7 32 b6 fb			ld (debug_mark+2),a  
3cea 18 03			jr .pastdmark  
3cec ..			.dmark: db "CDP"  
3cef f1			.pastdmark: pop af  
3cf0			endm  
# End of macro DMARK
3cf0						CALLMONITOR 
3cf0 cd 7e 16			call break_point_state  
3cf3				endm  
# End of macro CALLMONITOR
3cf3					endif 
3cf3 cd cd 0a				call clear_display 
3cf6 cd 5b 1b				call dumpcont	 
3cf9 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cfa					NEXTW 
3cfa c3 44 20			jp macro_next 
3cfd				endm 
# End of macro NEXTW
3cfd			 
3cfd			 
3cfd			 
3cfd			 
3cfd			.DAT: 
3cfd				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cfd 3d				db WORD_SYS_CORE+41             
3cfe 53 3d			dw .HOME            
3d00 03				db 2 + 1 
3d01 .. 00			db "AT",0              
3d04				endm 
# End of macro CWHEAD
3d04			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d04					if DEBUG_FORTH_WORDS_KEY 
3d04						DMARK "AT." 
3d04 f5				push af  
3d05 3a 19 3d			ld a, (.dmark)  
3d08 32 b4 fb			ld (debug_mark),a  
3d0b 3a 1a 3d			ld a, (.dmark+1)  
3d0e 32 b5 fb			ld (debug_mark+1),a  
3d11 3a 1b 3d			ld a, (.dmark+2)  
3d14 32 b6 fb			ld (debug_mark+2),a  
3d17 18 03			jr .pastdmark  
3d19 ..			.dmark: db "AT."  
3d1c f1			.pastdmark: pop af  
3d1d			endm  
# End of macro DMARK
3d1d						CALLMONITOR 
3d1d cd 7e 16			call break_point_state  
3d20				endm  
# End of macro CALLMONITOR
3d20					endif 
3d20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d20 cd d2 1e			call macro_dsp_valuehl 
3d23				endm 
# End of macro FORTH_DSP_VALUEHL
3d23			 
3d23			 
3d23					; TODO save cursor row 
3d23 7d					ld a,l 
3d24 fe 02				cp 2 
3d26 20 04				jr nz, .crow3 
3d28 3e 14				ld a, display_row_2 
3d2a 18 12				jr .ccol1 
3d2c fe 03		.crow3:		cp 3 
3d2e 20 04				jr nz, .crow4 
3d30 3e 28				ld a, display_row_3 
3d32 18 0a				jr .ccol1 
3d34 fe 04		.crow4:		cp 4 
3d36 20 04				jr nz, .crow1 
3d38 3e 3c				ld a, display_row_4 
3d3a 18 02				jr .ccol1 
3d3c 3e 00		.crow1:		ld a,display_row_1 
3d3e f5			.ccol1:		push af			; got row offset 
3d3f 6f					ld l,a 
3d40 26 00				ld h,0 
3d42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d42 cd 8a 1f			call macro_forth_dsp_pop 
3d45				endm 
# End of macro FORTH_DSP_POP
3d45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d45 cd d2 1e			call macro_dsp_valuehl 
3d48				endm 
# End of macro FORTH_DSP_VALUEHL
3d48					; TODO save cursor col 
3d48 f1					pop af 
3d49 85					add l		; add col offset 
3d4a 32 c3 f9				ld (f_cursor_ptr), a 
3d4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d4d cd 8a 1f			call macro_forth_dsp_pop 
3d50				endm 
# End of macro FORTH_DSP_POP
3d50			 
3d50					; calculate  
3d50			 
3d50					NEXTW 
3d50 c3 44 20			jp macro_next 
3d53				endm 
# End of macro NEXTW
3d53			 
3d53			 
3d53			.HOME: 
3d53				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d53 41				db WORD_SYS_CORE+45             
3d54 80 3d			dw .SPACE            
3d56 05				db 4 + 1 
3d57 .. 00			db "HOME",0              
3d5c				endm 
# End of macro CWHEAD
3d5c			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d5c					if DEBUG_FORTH_WORDS_KEY 
3d5c						DMARK "HOM" 
3d5c f5				push af  
3d5d 3a 71 3d			ld a, (.dmark)  
3d60 32 b4 fb			ld (debug_mark),a  
3d63 3a 72 3d			ld a, (.dmark+1)  
3d66 32 b5 fb			ld (debug_mark+1),a  
3d69 3a 73 3d			ld a, (.dmark+2)  
3d6c 32 b6 fb			ld (debug_mark+2),a  
3d6f 18 03			jr .pastdmark  
3d71 ..			.dmark: db "HOM"  
3d74 f1			.pastdmark: pop af  
3d75			endm  
# End of macro DMARK
3d75						CALLMONITOR 
3d75 cd 7e 16			call break_point_state  
3d78				endm  
# End of macro CALLMONITOR
3d78					endif 
3d78 3e 00		.home:		ld a, 0		; and home cursor 
3d7a 32 c3 f9				ld (f_cursor_ptr), a 
3d7d					NEXTW 
3d7d c3 44 20			jp macro_next 
3d80				endm 
# End of macro NEXTW
3d80			 
3d80			 
3d80			.SPACE: 
3d80				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d80 46				db WORD_SYS_CORE+50             
3d81 ae 3d			dw .SPACES            
3d83 03				db 2 + 1 
3d84 .. 00			db "BL",0              
3d87				endm 
# End of macro CWHEAD
3d87			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d87					if DEBUG_FORTH_WORDS_KEY 
3d87						DMARK "BL." 
3d87 f5				push af  
3d88 3a 9c 3d			ld a, (.dmark)  
3d8b 32 b4 fb			ld (debug_mark),a  
3d8e 3a 9d 3d			ld a, (.dmark+1)  
3d91 32 b5 fb			ld (debug_mark+1),a  
3d94 3a 9e 3d			ld a, (.dmark+2)  
3d97 32 b6 fb			ld (debug_mark+2),a  
3d9a 18 03			jr .pastdmark  
3d9c ..			.dmark: db "BL."  
3d9f f1			.pastdmark: pop af  
3da0			endm  
# End of macro DMARK
3da0						CALLMONITOR 
3da0 cd 7e 16			call break_point_state  
3da3				endm  
# End of macro CALLMONITOR
3da3					endif 
3da3 21 ac 3d				ld hl, .blstr 
3da6 cd 49 1d				call forth_push_str 
3da9					 
3da9				       NEXTW 
3da9 c3 44 20			jp macro_next 
3dac				endm 
# End of macro NEXTW
3dac			 
3dac .. 00		.blstr: db " ", 0 
3dae			 
3dae			.SPACES: 
3dae				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3dae 47				db WORD_SYS_CORE+51             
3daf 49 3e			dw .SCROLL            
3db1 07				db 6 + 1 
3db2 .. 00			db "SPACES",0              
3db9				endm 
# End of macro CWHEAD
3db9			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3db9					if DEBUG_FORTH_WORDS_KEY 
3db9						DMARK "SPS" 
3db9 f5				push af  
3dba 3a ce 3d			ld a, (.dmark)  
3dbd 32 b4 fb			ld (debug_mark),a  
3dc0 3a cf 3d			ld a, (.dmark+1)  
3dc3 32 b5 fb			ld (debug_mark+1),a  
3dc6 3a d0 3d			ld a, (.dmark+2)  
3dc9 32 b6 fb			ld (debug_mark+2),a  
3dcc 18 03			jr .pastdmark  
3dce ..			.dmark: db "SPS"  
3dd1 f1			.pastdmark: pop af  
3dd2			endm  
# End of macro DMARK
3dd2						CALLMONITOR 
3dd2 cd 7e 16			call break_point_state  
3dd5				endm  
# End of macro CALLMONITOR
3dd5					endif 
3dd5			 
3dd5			 
3dd5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dd5 cd d2 1e			call macro_dsp_valuehl 
3dd8				endm 
# End of macro FORTH_DSP_VALUEHL
3dd8			 
3dd8			;		push hl    ; u 
3dd8					if DEBUG_FORTH_WORDS 
3dd8						DMARK "SPA" 
3dd8 f5				push af  
3dd9 3a ed 3d			ld a, (.dmark)  
3ddc 32 b4 fb			ld (debug_mark),a  
3ddf 3a ee 3d			ld a, (.dmark+1)  
3de2 32 b5 fb			ld (debug_mark+1),a  
3de5 3a ef 3d			ld a, (.dmark+2)  
3de8 32 b6 fb			ld (debug_mark+2),a  
3deb 18 03			jr .pastdmark  
3ded ..			.dmark: db "SPA"  
3df0 f1			.pastdmark: pop af  
3df1			endm  
# End of macro DMARK
3df1						CALLMONITOR 
3df1 cd 7e 16			call break_point_state  
3df4				endm  
# End of macro CALLMONITOR
3df4					endif 
3df4			 
3df4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df4 cd 8a 1f			call macro_forth_dsp_pop 
3df7				endm 
# End of macro FORTH_DSP_POP
3df7			;		pop hl 
3df7 4d					ld c, l 
3df8 06 00				ld b, 0 
3dfa 21 9a ef				ld hl, scratch  
3dfd			 
3dfd					if DEBUG_FORTH_WORDS 
3dfd						DMARK "SP2" 
3dfd f5				push af  
3dfe 3a 12 3e			ld a, (.dmark)  
3e01 32 b4 fb			ld (debug_mark),a  
3e04 3a 13 3e			ld a, (.dmark+1)  
3e07 32 b5 fb			ld (debug_mark+1),a  
3e0a 3a 14 3e			ld a, (.dmark+2)  
3e0d 32 b6 fb			ld (debug_mark+2),a  
3e10 18 03			jr .pastdmark  
3e12 ..			.dmark: db "SP2"  
3e15 f1			.pastdmark: pop af  
3e16			endm  
# End of macro DMARK
3e16						CALLMONITOR 
3e16 cd 7e 16			call break_point_state  
3e19				endm  
# End of macro CALLMONITOR
3e19					endif 
3e19 3e 20				ld a, ' ' 
3e1b c5			.spaces1:	push bc 
3e1c 77					ld (hl),a 
3e1d 23					inc hl 
3e1e c1					pop bc 
3e1f 10 fa				djnz .spaces1 
3e21 3e 00				ld a,0 
3e23 77					ld (hl),a 
3e24 21 9a ef				ld hl, scratch 
3e27					if DEBUG_FORTH_WORDS 
3e27						DMARK "SP3" 
3e27 f5				push af  
3e28 3a 3c 3e			ld a, (.dmark)  
3e2b 32 b4 fb			ld (debug_mark),a  
3e2e 3a 3d 3e			ld a, (.dmark+1)  
3e31 32 b5 fb			ld (debug_mark+1),a  
3e34 3a 3e 3e			ld a, (.dmark+2)  
3e37 32 b6 fb			ld (debug_mark+2),a  
3e3a 18 03			jr .pastdmark  
3e3c ..			.dmark: db "SP3"  
3e3f f1			.pastdmark: pop af  
3e40			endm  
# End of macro DMARK
3e40						CALLMONITOR 
3e40 cd 7e 16			call break_point_state  
3e43				endm  
# End of macro CALLMONITOR
3e43					endif 
3e43 cd 44 1e				call forth_apush 
3e46			 
3e46				       NEXTW 
3e46 c3 44 20			jp macro_next 
3e49				endm 
# End of macro NEXTW
3e49			 
3e49			 
3e49			 
3e49			.SCROLL: 
3e49				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e49 53				db WORD_SYS_CORE+63             
3e4a 76 3e			dw .SCROLLD            
3e4c 07				db 6 + 1 
3e4d .. 00			db "SCROLL",0              
3e54				endm 
# End of macro CWHEAD
3e54			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e54					if DEBUG_FORTH_WORDS_KEY 
3e54						DMARK "SCR" 
3e54 f5				push af  
3e55 3a 69 3e			ld a, (.dmark)  
3e58 32 b4 fb			ld (debug_mark),a  
3e5b 3a 6a 3e			ld a, (.dmark+1)  
3e5e 32 b5 fb			ld (debug_mark+1),a  
3e61 3a 6b 3e			ld a, (.dmark+2)  
3e64 32 b6 fb			ld (debug_mark+2),a  
3e67 18 03			jr .pastdmark  
3e69 ..			.dmark: db "SCR"  
3e6c f1			.pastdmark: pop af  
3e6d			endm  
# End of macro DMARK
3e6d						CALLMONITOR 
3e6d cd 7e 16			call break_point_state  
3e70				endm  
# End of macro CALLMONITOR
3e70					endif 
3e70			 
3e70 cd 8f 0a			call scroll_up 
3e73			;	call update_display 
3e73			 
3e73					NEXTW 
3e73 c3 44 20			jp macro_next 
3e76				endm 
# End of macro NEXTW
3e76			 
3e76			 
3e76			 
3e76			;		; get dir 
3e76			; 
3e76			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e76			; 
3e76			;		push hl 
3e76			; 
3e76			;		; destroy value TOS 
3e76			; 
3e76			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e76			; 
3e76			;		; get count 
3e76			; 
3e76			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e76			; 
3e76			;		push hl 
3e76			; 
3e76			;		; destroy value TOS 
3e76			; 
3e76			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e76			; 
3e76			;		; one value on hl get other one back 
3e76			; 
3e76			;		pop bc    ; count 
3e76			; 
3e76			;		pop de   ; dir 
3e76			; 
3e76			; 
3e76			;		ld b, c 
3e76			; 
3e76			;.scrolldir:     push bc 
3e76			;		push de 
3e76			; 
3e76			;		ld a, 0 
3e76			;		cp e 
3e76			;		jr z, .scrollup  
3e76			;		call scroll_down 
3e76			;		jr .scrollnext 
3e76			;.scrollup:	call scroll_up 
3e76			; 
3e76			;		 
3e76			;.scrollnext: 
3e76			;		pop de 
3e76			;		pop bc 
3e76			;		djnz .scrolldir 
3e76			; 
3e76			; 
3e76			; 
3e76			; 
3e76			; 
3e76			;		NEXTW 
3e76			 
3e76			.SCROLLD: 
3e76				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e76 53				db WORD_SYS_CORE+63             
3e77 a4 3e			dw .ATQ            
3e79 08				db 7 + 1 
3e7a .. 00			db "SCROLLD",0              
3e82				endm 
# End of macro CWHEAD
3e82			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e82					if DEBUG_FORTH_WORDS_KEY 
3e82						DMARK "SCD" 
3e82 f5				push af  
3e83 3a 97 3e			ld a, (.dmark)  
3e86 32 b4 fb			ld (debug_mark),a  
3e89 3a 98 3e			ld a, (.dmark+1)  
3e8c 32 b5 fb			ld (debug_mark+1),a  
3e8f 3a 99 3e			ld a, (.dmark+2)  
3e92 32 b6 fb			ld (debug_mark+2),a  
3e95 18 03			jr .pastdmark  
3e97 ..			.dmark: db "SCD"  
3e9a f1			.pastdmark: pop af  
3e9b			endm  
# End of macro DMARK
3e9b						CALLMONITOR 
3e9b cd 7e 16			call break_point_state  
3e9e				endm  
# End of macro CALLMONITOR
3e9e					endif 
3e9e			 
3e9e cd b3 0a			call scroll_down 
3ea1			;	call update_display 
3ea1			 
3ea1					NEXTW 
3ea1 c3 44 20			jp macro_next 
3ea4				endm 
# End of macro NEXTW
3ea4			 
3ea4			 
3ea4			.ATQ: 
3ea4				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ea4 62				db WORD_SYS_CORE+78             
3ea5 02 3f			dw .AUTODSP            
3ea7 04				db 3 + 1 
3ea8 .. 00			db "AT@",0              
3eac				endm 
# End of macro CWHEAD
3eac			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3eac					if DEBUG_FORTH_WORDS_KEY 
3eac						DMARK "ATA" 
3eac f5				push af  
3ead 3a c1 3e			ld a, (.dmark)  
3eb0 32 b4 fb			ld (debug_mark),a  
3eb3 3a c2 3e			ld a, (.dmark+1)  
3eb6 32 b5 fb			ld (debug_mark+1),a  
3eb9 3a c3 3e			ld a, (.dmark+2)  
3ebc 32 b6 fb			ld (debug_mark+2),a  
3ebf 18 03			jr .pastdmark  
3ec1 ..			.dmark: db "ATA"  
3ec4 f1			.pastdmark: pop af  
3ec5			endm  
# End of macro DMARK
3ec5						CALLMONITOR 
3ec5 cd 7e 16			call break_point_state  
3ec8				endm  
# End of macro CALLMONITOR
3ec8					endif 
3ec8			 
3ec8			 
3ec8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec8 cd d2 1e			call macro_dsp_valuehl 
3ecb				endm 
# End of macro FORTH_DSP_VALUEHL
3ecb			 
3ecb					; TODO save cursor row 
3ecb 7d					ld a,l 
3ecc fe 02				cp 2 
3ece 20 04				jr nz, .crow3aq 
3ed0 3e 14				ld a, display_row_2 
3ed2 18 12				jr .ccol1aq 
3ed4 fe 03		.crow3aq:		cp 3 
3ed6 20 04				jr nz, .crow4aq 
3ed8 3e 28				ld a, display_row_3 
3eda 18 0a				jr .ccol1aq 
3edc fe 04		.crow4aq:		cp 4 
3ede 20 04				jr nz, .crow1aq 
3ee0 3e 3c				ld a, display_row_4 
3ee2 18 02				jr .ccol1aq 
3ee4 3e 00		.crow1aq:		ld a,display_row_1 
3ee6 f5			.ccol1aq:		push af			; got row offset 
3ee7 6f					ld l,a 
3ee8 26 00				ld h,0 
3eea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eea cd 8a 1f			call macro_forth_dsp_pop 
3eed				endm 
# End of macro FORTH_DSP_POP
3eed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eed cd d2 1e			call macro_dsp_valuehl 
3ef0				endm 
# End of macro FORTH_DSP_VALUEHL
3ef0					; TODO save cursor col 
3ef0 f1					pop af 
3ef1 85					add l		; add col offset 
3ef2			 
3ef2					; add current frame buffer address 
3ef2 2a 55 fa				ld hl, (display_fb_active) 
3ef5 cd 01 0d				call addatohl 
3ef8			 
3ef8			 
3ef8			 
3ef8			 
3ef8					; get char frame buffer location offset in hl 
3ef8			 
3ef8 7e					ld a,(hl) 
3ef9 26 00				ld h, 0 
3efb 6f					ld l, a 
3efc			 
3efc cd db 1c				call forth_push_numhl 
3eff			 
3eff			 
3eff					NEXTW 
3eff c3 44 20			jp macro_next 
3f02				endm 
# End of macro NEXTW
3f02			 
3f02			.AUTODSP: 
3f02				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f02 63				db WORD_SYS_CORE+79             
3f03 18 3f			dw .MENU            
3f05 05				db 4 + 1 
3f06 .. 00			db "ADSP",0              
3f0b				endm 
# End of macro CWHEAD
3f0b			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f0b			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f0b			 
3f0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f0b cd d2 1e			call macro_dsp_valuehl 
3f0e				endm 
# End of macro FORTH_DSP_VALUEHL
3f0e			 
3f0e			;		push hl 
3f0e			 
3f0e					; destroy value TOS 
3f0e			 
3f0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0e cd 8a 1f			call macro_forth_dsp_pop 
3f11				endm 
# End of macro FORTH_DSP_POP
3f11			 
3f11			;		pop hl 
3f11			 
3f11 7d					ld a,l 
3f12 32 a1 f9				ld (cli_autodisplay), a 
3f15				       NEXTW 
3f15 c3 44 20			jp macro_next 
3f18				endm 
# End of macro NEXTW
3f18			 
3f18			.MENU: 
3f18				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f18 70				db WORD_SYS_CORE+92             
3f19 c1 3f			dw .ENDDISPLAY            
3f1b 05				db 4 + 1 
3f1c .. 00			db "MENU",0              
3f21				endm 
# End of macro CWHEAD
3f21			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f21			 
3f21			;		; get number of items on the stack 
3f21			; 
3f21				 
3f21					FORTH_DSP_VALUEHL 
3f21 cd d2 1e			call macro_dsp_valuehl 
3f24				endm 
# End of macro FORTH_DSP_VALUEHL
3f24				 
3f24					if DEBUG_FORTH_WORDS_KEY 
3f24						DMARK "MNU" 
3f24 f5				push af  
3f25 3a 39 3f			ld a, (.dmark)  
3f28 32 b4 fb			ld (debug_mark),a  
3f2b 3a 3a 3f			ld a, (.dmark+1)  
3f2e 32 b5 fb			ld (debug_mark+1),a  
3f31 3a 3b 3f			ld a, (.dmark+2)  
3f34 32 b6 fb			ld (debug_mark+2),a  
3f37 18 03			jr .pastdmark  
3f39 ..			.dmark: db "MNU"  
3f3c f1			.pastdmark: pop af  
3f3d			endm  
# End of macro DMARK
3f3d						CALLMONITOR 
3f3d cd 7e 16			call break_point_state  
3f40				endm  
# End of macro CALLMONITOR
3f40					endif 
3f40			 
3f40 45					ld b, l	 
3f41 05					dec b 
3f42			 
3f42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f42 cd 8a 1f			call macro_forth_dsp_pop 
3f45				endm 
# End of macro FORTH_DSP_POP
3f45			 
3f45			 
3f45					; go directly through the stack to pluck out the string pointers and build an array 
3f45			 
3f45			;		FORTH_DSP 
3f45			 
3f45					; hl contains top most stack item 
3f45				 
3f45 11 9a ef				ld de, scratch 
3f48			 
3f48			.mbuild: 
3f48			 
3f48					FORTH_DSP_VALUEHL 
3f48 cd d2 1e			call macro_dsp_valuehl 
3f4b				endm 
# End of macro FORTH_DSP_VALUEHL
3f4b			 
3f4b					if DEBUG_FORTH_WORDS 
3f4b						DMARK "MN3" 
3f4b f5				push af  
3f4c 3a 60 3f			ld a, (.dmark)  
3f4f 32 b4 fb			ld (debug_mark),a  
3f52 3a 61 3f			ld a, (.dmark+1)  
3f55 32 b5 fb			ld (debug_mark+1),a  
3f58 3a 62 3f			ld a, (.dmark+2)  
3f5b 32 b6 fb			ld (debug_mark+2),a  
3f5e 18 03			jr .pastdmark  
3f60 ..			.dmark: db "MN3"  
3f63 f1			.pastdmark: pop af  
3f64			endm  
# End of macro DMARK
3f64						CALLMONITOR 
3f64 cd 7e 16			call break_point_state  
3f67				endm  
# End of macro CALLMONITOR
3f67					endif 
3f67 eb					ex de, hl 
3f68 73					ld (hl), e 
3f69 23					inc hl 
3f6a 72					ld (hl), d 
3f6b 23					inc hl 
3f6c eb					ex de, hl 
3f6d			 
3f6d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f6d cd 8a 1f			call macro_forth_dsp_pop 
3f70				endm 
# End of macro FORTH_DSP_POP
3f70			 
3f70 10 d6				djnz .mbuild 
3f72			 
3f72					; done add term 
3f72			 
3f72 eb					ex de, hl 
3f73 36 00				ld (hl), 0 
3f75 23					inc hl 
3f76 36 00				ld (hl), 0 
3f78			 
3f78				 
3f78					 
3f78 21 9a ef				ld hl, scratch 
3f7b			 
3f7b					if DEBUG_FORTH_WORDS 
3f7b						DMARK "MNx" 
3f7b f5				push af  
3f7c 3a 90 3f			ld a, (.dmark)  
3f7f 32 b4 fb			ld (debug_mark),a  
3f82 3a 91 3f			ld a, (.dmark+1)  
3f85 32 b5 fb			ld (debug_mark+1),a  
3f88 3a 92 3f			ld a, (.dmark+2)  
3f8b 32 b6 fb			ld (debug_mark+2),a  
3f8e 18 03			jr .pastdmark  
3f90 ..			.dmark: db "MNx"  
3f93 f1			.pastdmark: pop af  
3f94			endm  
# End of macro DMARK
3f94						CALLMONITOR 
3f94 cd 7e 16			call break_point_state  
3f97				endm  
# End of macro CALLMONITOR
3f97					endif 
3f97			 
3f97			 
3f97			 
3f97 3e 00				ld a, 0 
3f99 cd fe 0a				call menu 
3f9c			 
3f9c			 
3f9c 6f					ld l, a 
3f9d 26 00				ld h, 0 
3f9f			 
3f9f					if DEBUG_FORTH_WORDS 
3f9f						DMARK "MNr" 
3f9f f5				push af  
3fa0 3a b4 3f			ld a, (.dmark)  
3fa3 32 b4 fb			ld (debug_mark),a  
3fa6 3a b5 3f			ld a, (.dmark+1)  
3fa9 32 b5 fb			ld (debug_mark+1),a  
3fac 3a b6 3f			ld a, (.dmark+2)  
3faf 32 b6 fb			ld (debug_mark+2),a  
3fb2 18 03			jr .pastdmark  
3fb4 ..			.dmark: db "MNr"  
3fb7 f1			.pastdmark: pop af  
3fb8			endm  
# End of macro DMARK
3fb8						CALLMONITOR 
3fb8 cd 7e 16			call break_point_state  
3fbb				endm  
# End of macro CALLMONITOR
3fbb					endif 
3fbb			 
3fbb cd db 1c				call forth_push_numhl 
3fbe			 
3fbe			 
3fbe			 
3fbe			 
3fbe				       NEXTW 
3fbe c3 44 20			jp macro_next 
3fc1				endm 
# End of macro NEXTW
3fc1			 
3fc1			 
3fc1			.ENDDISPLAY: 
3fc1			 
3fc1			; eof 
# End of file forth_words_display.asm
3fc1			include "forth_words_str.asm" 
3fc1			 
3fc1			; | ## String Words 
3fc1			 
3fc1			.PTR:   
3fc1			 
3fc1				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fc1 48				db WORD_SYS_CORE+52             
3fc2 ee 3f			dw .STYPE            
3fc4 04				db 3 + 1 
3fc5 .. 00			db "PTR",0              
3fc9				endm 
# End of macro CWHEAD
3fc9			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3fc9			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3fc9			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3fc9			 
3fc9					if DEBUG_FORTH_WORDS_KEY 
3fc9						DMARK "PTR" 
3fc9 f5				push af  
3fca 3a de 3f			ld a, (.dmark)  
3fcd 32 b4 fb			ld (debug_mark),a  
3fd0 3a df 3f			ld a, (.dmark+1)  
3fd3 32 b5 fb			ld (debug_mark+1),a  
3fd6 3a e0 3f			ld a, (.dmark+2)  
3fd9 32 b6 fb			ld (debug_mark+2),a  
3fdc 18 03			jr .pastdmark  
3fde ..			.dmark: db "PTR"  
3fe1 f1			.pastdmark: pop af  
3fe2			endm  
# End of macro DMARK
3fe2						CALLMONITOR 
3fe2 cd 7e 16			call break_point_state  
3fe5				endm  
# End of macro CALLMONITOR
3fe5					endif 
3fe5					FORTH_DSP_VALUEHL 
3fe5 cd d2 1e			call macro_dsp_valuehl 
3fe8				endm 
# End of macro FORTH_DSP_VALUEHL
3fe8 cd db 1c				call forth_push_numhl 
3feb			 
3feb			 
3feb					NEXTW 
3feb c3 44 20			jp macro_next 
3fee				endm 
# End of macro NEXTW
3fee			.STYPE: 
3fee				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fee 48				db WORD_SYS_CORE+52             
3fef 3d 40			dw .UPPER            
3ff1 06				db 5 + 1 
3ff2 .. 00			db "STYPE",0              
3ff8				endm 
# End of macro CWHEAD
3ff8			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3ff8					if DEBUG_FORTH_WORDS_KEY 
3ff8						DMARK "STY" 
3ff8 f5				push af  
3ff9 3a 0d 40			ld a, (.dmark)  
3ffc 32 b4 fb			ld (debug_mark),a  
3fff 3a 0e 40			ld a, (.dmark+1)  
4002 32 b5 fb			ld (debug_mark+1),a  
4005 3a 0f 40			ld a, (.dmark+2)  
4008 32 b6 fb			ld (debug_mark+2),a  
400b 18 03			jr .pastdmark  
400d ..			.dmark: db "STY"  
4010 f1			.pastdmark: pop af  
4011			endm  
# End of macro DMARK
4011						CALLMONITOR 
4011 cd 7e 16			call break_point_state  
4014				endm  
# End of macro CALLMONITOR
4014					endif 
4014					FORTH_DSP 
4014 cd 98 1e			call macro_forth_dsp 
4017				endm 
# End of macro FORTH_DSP
4017					;v5 FORTH_DSP_VALUE 
4017			 
4017 7e					ld a, (hl) 
4018			 
4018 f5					push af 
4019			 
4019			; Dont destroy TOS		FORTH_DSP_POP 
4019			 
4019 f1					pop af 
401a			 
401a fe 01				cp DS_TYPE_STR 
401c 28 09				jr z, .typestr 
401e			 
401e fe 02				cp DS_TYPE_INUM 
4020 28 0a				jr z, .typeinum 
4022			 
4022 21 3b 40				ld hl, .tna 
4025 18 0a				jr .tpush 
4027			 
4027 21 37 40		.typestr:	ld hl, .tstr 
402a 18 05				jr .tpush 
402c 21 39 40		.typeinum:	ld hl, .tinum 
402f 18 00				jr .tpush 
4031			 
4031			.tpush: 
4031			 
4031 cd 49 1d				call forth_push_str 
4034			 
4034					NEXTW 
4034 c3 44 20			jp macro_next 
4037				endm 
# End of macro NEXTW
4037 .. 00		.tstr:	db "s",0 
4039 .. 00		.tinum:  db "i",0 
403b .. 00		.tna:   db "?", 0 
403d			 
403d			 
403d			.UPPER: 
403d				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
403d 48				db WORD_SYS_CORE+52             
403e 78 40			dw .LOWER            
4040 06				db 5 + 1 
4041 .. 00			db "UPPER",0              
4047				endm 
# End of macro CWHEAD
4047			; | UPPER ( s -- s ) Upper case string s  | DONE 
4047					if DEBUG_FORTH_WORDS_KEY 
4047						DMARK "UPR" 
4047 f5				push af  
4048 3a 5c 40			ld a, (.dmark)  
404b 32 b4 fb			ld (debug_mark),a  
404e 3a 5d 40			ld a, (.dmark+1)  
4051 32 b5 fb			ld (debug_mark+1),a  
4054 3a 5e 40			ld a, (.dmark+2)  
4057 32 b6 fb			ld (debug_mark+2),a  
405a 18 03			jr .pastdmark  
405c ..			.dmark: db "UPR"  
405f f1			.pastdmark: pop af  
4060			endm  
# End of macro DMARK
4060						CALLMONITOR 
4060 cd 7e 16			call break_point_state  
4063				endm  
# End of macro CALLMONITOR
4063					endif 
4063			 
4063					FORTH_DSP 
4063 cd 98 1e			call macro_forth_dsp 
4066				endm 
# End of macro FORTH_DSP
4066					 
4066			; TODO check is string type 
4066			 
4066					FORTH_DSP_VALUEHL 
4066 cd d2 1e			call macro_dsp_valuehl 
4069				endm 
# End of macro FORTH_DSP_VALUEHL
4069			; get pointer to string in hl 
4069			 
4069 7e			.toup:		ld a, (hl) 
406a fe 00				cp 0 
406c 28 07				jr z, .toupdone 
406e			 
406e cd 6e 10				call to_upper 
4071			 
4071 77					ld (hl), a 
4072 23					inc hl 
4073 18 f4				jr .toup 
4075			 
4075					 
4075			 
4075			 
4075			; for each char convert to upper 
4075					 
4075			.toupdone: 
4075			 
4075			 
4075					NEXTW 
4075 c3 44 20			jp macro_next 
4078				endm 
# End of macro NEXTW
4078			.LOWER: 
4078				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4078 48				db WORD_SYS_CORE+52             
4079 b3 40			dw .TCASE            
407b 06				db 5 + 1 
407c .. 00			db "LOWER",0              
4082				endm 
# End of macro CWHEAD
4082			; | LOWER ( s -- s ) Lower case string s  | DONE 
4082					if DEBUG_FORTH_WORDS_KEY 
4082						DMARK "LWR" 
4082 f5				push af  
4083 3a 97 40			ld a, (.dmark)  
4086 32 b4 fb			ld (debug_mark),a  
4089 3a 98 40			ld a, (.dmark+1)  
408c 32 b5 fb			ld (debug_mark+1),a  
408f 3a 99 40			ld a, (.dmark+2)  
4092 32 b6 fb			ld (debug_mark+2),a  
4095 18 03			jr .pastdmark  
4097 ..			.dmark: db "LWR"  
409a f1			.pastdmark: pop af  
409b			endm  
# End of macro DMARK
409b						CALLMONITOR 
409b cd 7e 16			call break_point_state  
409e				endm  
# End of macro CALLMONITOR
409e					endif 
409e			 
409e					FORTH_DSP 
409e cd 98 1e			call macro_forth_dsp 
40a1				endm 
# End of macro FORTH_DSP
40a1					 
40a1			; TODO check is string type 
40a1			 
40a1					FORTH_DSP_VALUEHL 
40a1 cd d2 1e			call macro_dsp_valuehl 
40a4				endm 
# End of macro FORTH_DSP_VALUEHL
40a4			; get pointer to string in hl 
40a4			 
40a4 7e			.tolow:		ld a, (hl) 
40a5 fe 00				cp 0 
40a7 28 07				jr z, .tolowdone 
40a9			 
40a9 cd 77 10				call to_lower 
40ac			 
40ac 77					ld (hl), a 
40ad 23					inc hl 
40ae 18 f4				jr .tolow 
40b0			 
40b0					 
40b0			 
40b0			 
40b0			; for each char convert to low 
40b0					 
40b0			.tolowdone: 
40b0					NEXTW 
40b0 c3 44 20			jp macro_next 
40b3				endm 
# End of macro NEXTW
40b3			.TCASE: 
40b3				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40b3 48				db WORD_SYS_CORE+52             
40b4 e9 41			dw .SUBSTR            
40b6 06				db 5 + 1 
40b7 .. 00			db "TCASE",0              
40bd				endm 
# End of macro CWHEAD
40bd			; | TCASE ( s -- s ) Title case string s  | DONE 
40bd					if DEBUG_FORTH_WORDS_KEY 
40bd						DMARK "TCS" 
40bd f5				push af  
40be 3a d2 40			ld a, (.dmark)  
40c1 32 b4 fb			ld (debug_mark),a  
40c4 3a d3 40			ld a, (.dmark+1)  
40c7 32 b5 fb			ld (debug_mark+1),a  
40ca 3a d4 40			ld a, (.dmark+2)  
40cd 32 b6 fb			ld (debug_mark+2),a  
40d0 18 03			jr .pastdmark  
40d2 ..			.dmark: db "TCS"  
40d5 f1			.pastdmark: pop af  
40d6			endm  
# End of macro DMARK
40d6						CALLMONITOR 
40d6 cd 7e 16			call break_point_state  
40d9				endm  
# End of macro CALLMONITOR
40d9					endif 
40d9			 
40d9					FORTH_DSP 
40d9 cd 98 1e			call macro_forth_dsp 
40dc				endm 
# End of macro FORTH_DSP
40dc					 
40dc			; TODO check is string type 
40dc			 
40dc					FORTH_DSP_VALUEHL 
40dc cd d2 1e			call macro_dsp_valuehl 
40df				endm 
# End of macro FORTH_DSP_VALUEHL
40df			; get pointer to string in hl 
40df			 
40df					if DEBUG_FORTH_WORDS 
40df						DMARK "TC1" 
40df f5				push af  
40e0 3a f4 40			ld a, (.dmark)  
40e3 32 b4 fb			ld (debug_mark),a  
40e6 3a f5 40			ld a, (.dmark+1)  
40e9 32 b5 fb			ld (debug_mark+1),a  
40ec 3a f6 40			ld a, (.dmark+2)  
40ef 32 b6 fb			ld (debug_mark+2),a  
40f2 18 03			jr .pastdmark  
40f4 ..			.dmark: db "TC1"  
40f7 f1			.pastdmark: pop af  
40f8			endm  
# End of macro DMARK
40f8						CALLMONITOR 
40f8 cd 7e 16			call break_point_state  
40fb				endm  
# End of macro CALLMONITOR
40fb					endif 
40fb			 
40fb					; first time in turn to upper case first char 
40fb			 
40fb 7e					ld a, (hl) 
40fc c3 86 41				jp .totsiptou 
40ff			 
40ff			 
40ff 7e			.tot:		ld a, (hl) 
4100 fe 00				cp 0 
4102 ca ca 41				jp z, .totdone 
4105			 
4105					if DEBUG_FORTH_WORDS 
4105						DMARK "TC2" 
4105 f5				push af  
4106 3a 1a 41			ld a, (.dmark)  
4109 32 b4 fb			ld (debug_mark),a  
410c 3a 1b 41			ld a, (.dmark+1)  
410f 32 b5 fb			ld (debug_mark+1),a  
4112 3a 1c 41			ld a, (.dmark+2)  
4115 32 b6 fb			ld (debug_mark+2),a  
4118 18 03			jr .pastdmark  
411a ..			.dmark: db "TC2"  
411d f1			.pastdmark: pop af  
411e			endm  
# End of macro DMARK
411e						CALLMONITOR 
411e cd 7e 16			call break_point_state  
4121				endm  
# End of macro CALLMONITOR
4121					endif 
4121					; check to see if current char is a space 
4121			 
4121 fe 20				cp ' ' 
4123 28 21				jr z, .totsp 
4125 cd 77 10				call to_lower 
4128					if DEBUG_FORTH_WORDS 
4128						DMARK "TC3" 
4128 f5				push af  
4129 3a 3d 41			ld a, (.dmark)  
412c 32 b4 fb			ld (debug_mark),a  
412f 3a 3e 41			ld a, (.dmark+1)  
4132 32 b5 fb			ld (debug_mark+1),a  
4135 3a 3f 41			ld a, (.dmark+2)  
4138 32 b6 fb			ld (debug_mark+2),a  
413b 18 03			jr .pastdmark  
413d ..			.dmark: db "TC3"  
4140 f1			.pastdmark: pop af  
4141			endm  
# End of macro DMARK
4141						CALLMONITOR 
4141 cd 7e 16			call break_point_state  
4144				endm  
# End of macro CALLMONITOR
4144					endif 
4144 18 63				jr .totnxt 
4146			 
4146			.totsp:         ; on a space, find next char which should be upper 
4146			 
4146					if DEBUG_FORTH_WORDS 
4146						DMARK "TC4" 
4146 f5				push af  
4147 3a 5b 41			ld a, (.dmark)  
414a 32 b4 fb			ld (debug_mark),a  
414d 3a 5c 41			ld a, (.dmark+1)  
4150 32 b5 fb			ld (debug_mark+1),a  
4153 3a 5d 41			ld a, (.dmark+2)  
4156 32 b6 fb			ld (debug_mark+2),a  
4159 18 03			jr .pastdmark  
415b ..			.dmark: db "TC4"  
415e f1			.pastdmark: pop af  
415f			endm  
# End of macro DMARK
415f						CALLMONITOR 
415f cd 7e 16			call break_point_state  
4162				endm  
# End of macro CALLMONITOR
4162					endif 
4162					;; 
4162			 
4162 fe 20				cp ' ' 
4164 20 20				jr nz, .totsiptou 
4166 23					inc hl 
4167 7e					ld a, (hl) 
4168					if DEBUG_FORTH_WORDS 
4168						DMARK "TC5" 
4168 f5				push af  
4169 3a 7d 41			ld a, (.dmark)  
416c 32 b4 fb			ld (debug_mark),a  
416f 3a 7e 41			ld a, (.dmark+1)  
4172 32 b5 fb			ld (debug_mark+1),a  
4175 3a 7f 41			ld a, (.dmark+2)  
4178 32 b6 fb			ld (debug_mark+2),a  
417b 18 03			jr .pastdmark  
417d ..			.dmark: db "TC5"  
4180 f1			.pastdmark: pop af  
4181			endm  
# End of macro DMARK
4181						CALLMONITOR 
4181 cd 7e 16			call break_point_state  
4184				endm  
# End of macro CALLMONITOR
4184					endif 
4184 18 c0				jr .totsp 
4186 fe 00		.totsiptou:    cp 0 
4188 28 40				jr z, .totdone 
418a					; not space and not zero term so upper case it 
418a cd 6e 10				call to_upper 
418d			 
418d					if DEBUG_FORTH_WORDS 
418d						DMARK "TC6" 
418d f5				push af  
418e 3a a2 41			ld a, (.dmark)  
4191 32 b4 fb			ld (debug_mark),a  
4194 3a a3 41			ld a, (.dmark+1)  
4197 32 b5 fb			ld (debug_mark+1),a  
419a 3a a4 41			ld a, (.dmark+2)  
419d 32 b6 fb			ld (debug_mark+2),a  
41a0 18 03			jr .pastdmark  
41a2 ..			.dmark: db "TC6"  
41a5 f1			.pastdmark: pop af  
41a6			endm  
# End of macro DMARK
41a6						CALLMONITOR 
41a6 cd 7e 16			call break_point_state  
41a9				endm  
# End of macro CALLMONITOR
41a9					endif 
41a9			 
41a9			 
41a9			.totnxt: 
41a9			 
41a9 77					ld (hl), a 
41aa 23					inc hl 
41ab					if DEBUG_FORTH_WORDS 
41ab						DMARK "TC7" 
41ab f5				push af  
41ac 3a c0 41			ld a, (.dmark)  
41af 32 b4 fb			ld (debug_mark),a  
41b2 3a c1 41			ld a, (.dmark+1)  
41b5 32 b5 fb			ld (debug_mark+1),a  
41b8 3a c2 41			ld a, (.dmark+2)  
41bb 32 b6 fb			ld (debug_mark+2),a  
41be 18 03			jr .pastdmark  
41c0 ..			.dmark: db "TC7"  
41c3 f1			.pastdmark: pop af  
41c4			endm  
# End of macro DMARK
41c4						CALLMONITOR 
41c4 cd 7e 16			call break_point_state  
41c7				endm  
# End of macro CALLMONITOR
41c7					endif 
41c7 c3 ff 40				jp .tot 
41ca			 
41ca					 
41ca			 
41ca			 
41ca			; for each char convert to low 
41ca					 
41ca			.totdone: 
41ca					if DEBUG_FORTH_WORDS 
41ca						DMARK "TCd" 
41ca f5				push af  
41cb 3a df 41			ld a, (.dmark)  
41ce 32 b4 fb			ld (debug_mark),a  
41d1 3a e0 41			ld a, (.dmark+1)  
41d4 32 b5 fb			ld (debug_mark+1),a  
41d7 3a e1 41			ld a, (.dmark+2)  
41da 32 b6 fb			ld (debug_mark+2),a  
41dd 18 03			jr .pastdmark  
41df ..			.dmark: db "TCd"  
41e2 f1			.pastdmark: pop af  
41e3			endm  
# End of macro DMARK
41e3						CALLMONITOR 
41e3 cd 7e 16			call break_point_state  
41e6				endm  
# End of macro CALLMONITOR
41e6					endif 
41e6					NEXTW 
41e6 c3 44 20			jp macro_next 
41e9				endm 
# End of macro NEXTW
41e9			 
41e9			.SUBSTR: 
41e9				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41e9 48				db WORD_SYS_CORE+52             
41ea 47 42			dw .LEFT            
41ec 07				db 6 + 1 
41ed .. 00			db "SUBSTR",0              
41f4				endm 
# End of macro CWHEAD
41f4			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41f4			 
41f4					if DEBUG_FORTH_WORDS_KEY 
41f4						DMARK "SST" 
41f4 f5				push af  
41f5 3a 09 42			ld a, (.dmark)  
41f8 32 b4 fb			ld (debug_mark),a  
41fb 3a 0a 42			ld a, (.dmark+1)  
41fe 32 b5 fb			ld (debug_mark+1),a  
4201 3a 0b 42			ld a, (.dmark+2)  
4204 32 b6 fb			ld (debug_mark+2),a  
4207 18 03			jr .pastdmark  
4209 ..			.dmark: db "SST"  
420c f1			.pastdmark: pop af  
420d			endm  
# End of macro DMARK
420d						CALLMONITOR 
420d cd 7e 16			call break_point_state  
4210				endm  
# End of macro CALLMONITOR
4210					endif 
4210			; TODO check string type 
4210					FORTH_DSP_VALUEHL 
4210 cd d2 1e			call macro_dsp_valuehl 
4213				endm 
# End of macro FORTH_DSP_VALUEHL
4213			 
4213 e5					push hl      ; string length 
4214			 
4214					FORTH_DSP_POP 
4214 cd 8a 1f			call macro_forth_dsp_pop 
4217				endm 
# End of macro FORTH_DSP_POP
4217			 
4217					FORTH_DSP_VALUEHL 
4217 cd d2 1e			call macro_dsp_valuehl 
421a				endm 
# End of macro FORTH_DSP_VALUEHL
421a			 
421a e5					push hl     ; start char 
421b			 
421b					FORTH_DSP_POP 
421b cd 8a 1f			call macro_forth_dsp_pop 
421e				endm 
# End of macro FORTH_DSP_POP
421e			 
421e			 
421e					FORTH_DSP_VALUE 
421e cd bb 1e			call macro_forth_dsp_value 
4221				endm 
# End of macro FORTH_DSP_VALUE
4221			 
4221 d1					pop de    ; get start post offset 
4222			 
4222 19					add hl, de    ; starting offset 
4223			 
4223 c1					pop bc 
4224 c5					push bc      ; grab size of string 
4225			 
4225 e5					push hl    ; save string start  
4226			 
4226 26 00				ld h, 0 
4228 69					ld l, c 
4229 23					inc hl 
422a 23					inc hl 
422b			 
422b cd c8 11				call malloc 
422e				if DEBUG_FORTH_MALLOC_GUARD 
422e cc dd 51				call z,malloc_error 
4231				endif 
4231			 
4231 eb					ex de, hl      ; save malloc area for string copy 
4232 e1					pop hl    ; get back source 
4233 c1					pop bc    ; get length of string back 
4234			 
4234 d5					push de    ; save malloc area for after we push 
4235 ed b0				ldir     ; copy substr 
4237			 
4237			 
4237 eb					ex de, hl 
4238 3e 00				ld a, 0 
423a 77					ld (hl), a   ; term substr 
423b			 
423b					 
423b e1					pop hl    ; get malloc so we can push it 
423c e5					push hl   ; save so we can free it afterwards 
423d			 
423d cd 49 1d				call forth_push_str 
4240			 
4240 e1					pop hl 
4241 cd 92 12				call free 
4244			 
4244					 
4244					 
4244			 
4244			 
4244					NEXTW 
4244 c3 44 20			jp macro_next 
4247				endm 
# End of macro NEXTW
4247			 
4247			.LEFT: 
4247				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4247 48				db WORD_SYS_CORE+52             
4248 6f 42			dw .RIGHT            
424a 05				db 4 + 1 
424b .. 00			db "LEFT",0              
4250				endm 
# End of macro CWHEAD
4250			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4250					if DEBUG_FORTH_WORDS_KEY 
4250						DMARK "LEF" 
4250 f5				push af  
4251 3a 65 42			ld a, (.dmark)  
4254 32 b4 fb			ld (debug_mark),a  
4257 3a 66 42			ld a, (.dmark+1)  
425a 32 b5 fb			ld (debug_mark+1),a  
425d 3a 67 42			ld a, (.dmark+2)  
4260 32 b6 fb			ld (debug_mark+2),a  
4263 18 03			jr .pastdmark  
4265 ..			.dmark: db "LEF"  
4268 f1			.pastdmark: pop af  
4269			endm  
# End of macro DMARK
4269						CALLMONITOR 
4269 cd 7e 16			call break_point_state  
426c				endm  
# End of macro CALLMONITOR
426c					endif 
426c			 
426c					NEXTW 
426c c3 44 20			jp macro_next 
426f				endm 
# End of macro NEXTW
426f			.RIGHT: 
426f				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
426f 48				db WORD_SYS_CORE+52             
4270 98 42			dw .STR2NUM            
4272 06				db 5 + 1 
4273 .. 00			db "RIGHT",0              
4279				endm 
# End of macro CWHEAD
4279			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4279					if DEBUG_FORTH_WORDS_KEY 
4279						DMARK "RIG" 
4279 f5				push af  
427a 3a 8e 42			ld a, (.dmark)  
427d 32 b4 fb			ld (debug_mark),a  
4280 3a 8f 42			ld a, (.dmark+1)  
4283 32 b5 fb			ld (debug_mark+1),a  
4286 3a 90 42			ld a, (.dmark+2)  
4289 32 b6 fb			ld (debug_mark+2),a  
428c 18 03			jr .pastdmark  
428e ..			.dmark: db "RIG"  
4291 f1			.pastdmark: pop af  
4292			endm  
# End of macro DMARK
4292						CALLMONITOR 
4292 cd 7e 16			call break_point_state  
4295				endm  
# End of macro CALLMONITOR
4295					endif 
4295			 
4295					NEXTW 
4295 c3 44 20			jp macro_next 
4298				endm 
# End of macro NEXTW
4298			 
4298			 
4298			.STR2NUM: 
4298				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4298 48				db WORD_SYS_CORE+52             
4299 24 43			dw .NUM2STR            
429b 08				db 7 + 1 
429c .. 00			db "STR2NUM",0              
42a4				endm 
# End of macro CWHEAD
42a4			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42a4			 
42a4			 
42a4			; TODO STR type check to do 
42a4					if DEBUG_FORTH_WORDS_KEY 
42a4						DMARK "S2N" 
42a4 f5				push af  
42a5 3a b9 42			ld a, (.dmark)  
42a8 32 b4 fb			ld (debug_mark),a  
42ab 3a ba 42			ld a, (.dmark+1)  
42ae 32 b5 fb			ld (debug_mark+1),a  
42b1 3a bb 42			ld a, (.dmark+2)  
42b4 32 b6 fb			ld (debug_mark+2),a  
42b7 18 03			jr .pastdmark  
42b9 ..			.dmark: db "S2N"  
42bc f1			.pastdmark: pop af  
42bd			endm  
# End of macro DMARK
42bd						CALLMONITOR 
42bd cd 7e 16			call break_point_state  
42c0				endm  
# End of macro CALLMONITOR
42c0					endif 
42c0			 
42c0					;FORTH_DSP 
42c0					FORTH_DSP_VALUE 
42c0 cd bb 1e			call macro_forth_dsp_value 
42c3				endm 
# End of macro FORTH_DSP_VALUE
42c3					;inc hl 
42c3			 
42c3 eb					ex de, hl 
42c4					if DEBUG_FORTH_WORDS 
42c4						DMARK "S2a" 
42c4 f5				push af  
42c5 3a d9 42			ld a, (.dmark)  
42c8 32 b4 fb			ld (debug_mark),a  
42cb 3a da 42			ld a, (.dmark+1)  
42ce 32 b5 fb			ld (debug_mark+1),a  
42d1 3a db 42			ld a, (.dmark+2)  
42d4 32 b6 fb			ld (debug_mark+2),a  
42d7 18 03			jr .pastdmark  
42d9 ..			.dmark: db "S2a"  
42dc f1			.pastdmark: pop af  
42dd			endm  
# End of macro DMARK
42dd						CALLMONITOR 
42dd cd 7e 16			call break_point_state  
42e0				endm  
# End of macro CALLMONITOR
42e0					endif 
42e0 cd f6 10				call string_to_uint16 
42e3			 
42e3					if DEBUG_FORTH_WORDS 
42e3						DMARK "S2b" 
42e3 f5				push af  
42e4 3a f8 42			ld a, (.dmark)  
42e7 32 b4 fb			ld (debug_mark),a  
42ea 3a f9 42			ld a, (.dmark+1)  
42ed 32 b5 fb			ld (debug_mark+1),a  
42f0 3a fa 42			ld a, (.dmark+2)  
42f3 32 b6 fb			ld (debug_mark+2),a  
42f6 18 03			jr .pastdmark  
42f8 ..			.dmark: db "S2b"  
42fb f1			.pastdmark: pop af  
42fc			endm  
# End of macro DMARK
42fc						CALLMONITOR 
42fc cd 7e 16			call break_point_state  
42ff				endm  
# End of macro CALLMONITOR
42ff					endif 
42ff			;		push hl 
42ff					FORTH_DSP_POP 
42ff cd 8a 1f			call macro_forth_dsp_pop 
4302				endm 
# End of macro FORTH_DSP_POP
4302			;		pop hl 
4302					 
4302					if DEBUG_FORTH_WORDS 
4302						DMARK "S2b" 
4302 f5				push af  
4303 3a 17 43			ld a, (.dmark)  
4306 32 b4 fb			ld (debug_mark),a  
4309 3a 18 43			ld a, (.dmark+1)  
430c 32 b5 fb			ld (debug_mark+1),a  
430f 3a 19 43			ld a, (.dmark+2)  
4312 32 b6 fb			ld (debug_mark+2),a  
4315 18 03			jr .pastdmark  
4317 ..			.dmark: db "S2b"  
431a f1			.pastdmark: pop af  
431b			endm  
# End of macro DMARK
431b						CALLMONITOR 
431b cd 7e 16			call break_point_state  
431e				endm  
# End of macro CALLMONITOR
431e					endif 
431e cd db 1c				call forth_push_numhl	 
4321			 
4321				 
4321				       NEXTW 
4321 c3 44 20			jp macro_next 
4324				endm 
# End of macro NEXTW
4324			.NUM2STR: 
4324				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4324 48				db WORD_SYS_CORE+52             
4325 33 43			dw .CONCAT            
4327 08				db 7 + 1 
4328 .. 00			db "NUM2STR",0              
4330				endm 
# End of macro CWHEAD
4330			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4330			 
4330			;		; malloc a string to target 
4330			;		ld hl, 10     ; TODO max string size should be fine 
4330			;		call malloc 
4330			;		push hl    ; save malloc location 
4330			; 
4330			; 
4330			;; TODO check int type 
4330			;		FORTH_DSP_VALUEHL 
4330			;		ld a, l 
4330			;		call DispAToASCII   
4330			;;TODO need to chage above call to dump into string 
4330			; 
4330			; 
4330			 
4330				       NEXTW 
4330 c3 44 20			jp macro_next 
4333				endm 
# End of macro NEXTW
4333			 
4333			.CONCAT: 
4333				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4333 48				db WORD_SYS_CORE+52             
4334 e6 43			dw .FIND            
4336 07				db 6 + 1 
4337 .. 00			db "CONCAT",0              
433e				endm 
# End of macro CWHEAD
433e			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
433e			 
433e			; TODO check string type 
433e			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
433e			 
433e					if DEBUG_FORTH_WORDS_KEY 
433e						DMARK "CON" 
433e f5				push af  
433f 3a 53 43			ld a, (.dmark)  
4342 32 b4 fb			ld (debug_mark),a  
4345 3a 54 43			ld a, (.dmark+1)  
4348 32 b5 fb			ld (debug_mark+1),a  
434b 3a 55 43			ld a, (.dmark+2)  
434e 32 b6 fb			ld (debug_mark+2),a  
4351 18 03			jr .pastdmark  
4353 ..			.dmark: db "CON"  
4356 f1			.pastdmark: pop af  
4357			endm  
# End of macro DMARK
4357						CALLMONITOR 
4357 cd 7e 16			call break_point_state  
435a				endm  
# End of macro CALLMONITOR
435a					endif 
435a			 
435a			 
435a					FORTH_DSP_VALUE 
435a cd bb 1e			call macro_forth_dsp_value 
435d				endm 
# End of macro FORTH_DSP_VALUE
435d e5					push hl   ; s2 
435e			 
435e					FORTH_DSP_POP 
435e cd 8a 1f			call macro_forth_dsp_pop 
4361				endm 
# End of macro FORTH_DSP_POP
4361			 
4361					FORTH_DSP_VALUE 
4361 cd bb 1e			call macro_forth_dsp_value 
4364				endm 
# End of macro FORTH_DSP_VALUE
4364			 
4364 e5					push hl   ; s1 
4365			 
4365					FORTH_DSP_POP 
4365 cd 8a 1f			call macro_forth_dsp_pop 
4368				endm 
# End of macro FORTH_DSP_POP
4368					 
4368			 
4368					; copy s1 
4368			 
4368				 
4368					; save ptr 
4368 e1					pop hl  
4369 e5					push hl 
436a 3e 00				ld a, 0 
436c cd 6a 11				call strlent 
436f					;inc hl    ; zer0 
436f 06 00				ld b, 0 
4371 4d					ld c, l 
4372 e1					pop hl		 
4373 11 9a ef				ld de, scratch	 
4376					if DEBUG_FORTH_WORDS 
4376						DMARK "CO1" 
4376 f5				push af  
4377 3a 8b 43			ld a, (.dmark)  
437a 32 b4 fb			ld (debug_mark),a  
437d 3a 8c 43			ld a, (.dmark+1)  
4380 32 b5 fb			ld (debug_mark+1),a  
4383 3a 8d 43			ld a, (.dmark+2)  
4386 32 b6 fb			ld (debug_mark+2),a  
4389 18 03			jr .pastdmark  
438b ..			.dmark: db "CO1"  
438e f1			.pastdmark: pop af  
438f			endm  
# End of macro DMARK
438f						CALLMONITOR 
438f cd 7e 16			call break_point_state  
4392				endm  
# End of macro CALLMONITOR
4392					endif 
4392 ed b0				ldir 
4394			 
4394 e1					pop hl 
4395 e5					push hl 
4396 d5					push de 
4397			 
4397			 
4397 3e 00				ld a, 0 
4399 cd 6a 11				call strlent 
439c 23					inc hl    ; zer0 
439d 23					inc hl 
439e 06 00				ld b, 0 
43a0 4d					ld c, l 
43a1 d1					pop de 
43a2 e1					pop hl		 
43a3					if DEBUG_FORTH_WORDS 
43a3						DMARK "CO2" 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 b4 fb			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 b5 fb			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 b6 fb			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "CO2"  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc						CALLMONITOR 
43bc cd 7e 16			call break_point_state  
43bf				endm  
# End of macro CALLMONITOR
43bf					endif 
43bf ed b0				ldir 
43c1			 
43c1			 
43c1			 
43c1 21 9a ef				ld hl, scratch 
43c4					if DEBUG_FORTH_WORDS 
43c4						DMARK "CO5" 
43c4 f5				push af  
43c5 3a d9 43			ld a, (.dmark)  
43c8 32 b4 fb			ld (debug_mark),a  
43cb 3a da 43			ld a, (.dmark+1)  
43ce 32 b5 fb			ld (debug_mark+1),a  
43d1 3a db 43			ld a, (.dmark+2)  
43d4 32 b6 fb			ld (debug_mark+2),a  
43d7 18 03			jr .pastdmark  
43d9 ..			.dmark: db "CO5"  
43dc f1			.pastdmark: pop af  
43dd			endm  
# End of macro DMARK
43dd						CALLMONITOR 
43dd cd 7e 16			call break_point_state  
43e0				endm  
# End of macro CALLMONITOR
43e0					endif 
43e0			 
43e0 cd 49 1d				call forth_push_str 
43e3			 
43e3			 
43e3			 
43e3			 
43e3				       NEXTW 
43e3 c3 44 20			jp macro_next 
43e6				endm 
# End of macro NEXTW
43e6			 
43e6			 
43e6			.FIND: 
43e6				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43e6 4b				db WORD_SYS_CORE+55             
43e7 a4 44			dw .LEN            
43e9 05				db 4 + 1 
43ea .. 00			db "FIND",0              
43ef				endm 
# End of macro CWHEAD
43ef			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43ef			 
43ef					if DEBUG_FORTH_WORDS_KEY 
43ef						DMARK "FND" 
43ef f5				push af  
43f0 3a 04 44			ld a, (.dmark)  
43f3 32 b4 fb			ld (debug_mark),a  
43f6 3a 05 44			ld a, (.dmark+1)  
43f9 32 b5 fb			ld (debug_mark+1),a  
43fc 3a 06 44			ld a, (.dmark+2)  
43ff 32 b6 fb			ld (debug_mark+2),a  
4402 18 03			jr .pastdmark  
4404 ..			.dmark: db "FND"  
4407 f1			.pastdmark: pop af  
4408			endm  
# End of macro DMARK
4408						CALLMONITOR 
4408 cd 7e 16			call break_point_state  
440b				endm  
# End of macro CALLMONITOR
440b					endif 
440b			 
440b			; TODO check string type 
440b					FORTH_DSP_VALUE 
440b cd bb 1e			call macro_forth_dsp_value 
440e				endm 
# End of macro FORTH_DSP_VALUE
440e			 
440e e5					push hl    
440f 7e					ld a,(hl)    ; char to find   
4410			; TODO change char to substr 
4410			 
4410 f5					push af 
4411					 
4411			 
4411			 
4411					if DEBUG_FORTH_WORDS 
4411						DMARK "FN1" 
4411 f5				push af  
4412 3a 26 44			ld a, (.dmark)  
4415 32 b4 fb			ld (debug_mark),a  
4418 3a 27 44			ld a, (.dmark+1)  
441b 32 b5 fb			ld (debug_mark+1),a  
441e 3a 28 44			ld a, (.dmark+2)  
4421 32 b6 fb			ld (debug_mark+2),a  
4424 18 03			jr .pastdmark  
4426 ..			.dmark: db "FN1"  
4429 f1			.pastdmark: pop af  
442a			endm  
# End of macro DMARK
442a						CALLMONITOR 
442a cd 7e 16			call break_point_state  
442d				endm  
# End of macro CALLMONITOR
442d					endif 
442d			 
442d					FORTH_DSP_POP 
442d cd 8a 1f			call macro_forth_dsp_pop 
4430				endm 
# End of macro FORTH_DSP_POP
4430			 
4430					; string to search 
4430			 
4430					FORTH_DSP_VALUE 
4430 cd bb 1e			call macro_forth_dsp_value 
4433				endm 
# End of macro FORTH_DSP_VALUE
4433			 
4433 d1					pop de  ; d is char to find  
4434			 
4434					if DEBUG_FORTH_WORDS 
4434						DMARK "FN2" 
4434 f5				push af  
4435 3a 49 44			ld a, (.dmark)  
4438 32 b4 fb			ld (debug_mark),a  
443b 3a 4a 44			ld a, (.dmark+1)  
443e 32 b5 fb			ld (debug_mark+1),a  
4441 3a 4b 44			ld a, (.dmark+2)  
4444 32 b6 fb			ld (debug_mark+2),a  
4447 18 03			jr .pastdmark  
4449 ..			.dmark: db "FN2"  
444c f1			.pastdmark: pop af  
444d			endm  
# End of macro DMARK
444d						CALLMONITOR 
444d cd 7e 16			call break_point_state  
4450				endm  
# End of macro CALLMONITOR
4450					endif 
4450					 
4450 01 00 00				ld bc, 0 
4453 7e			.findchar:      ld a,(hl) 
4454 fe 00				cp 0   		 
4456 28 27				jr z, .finddone     
4458 ba					cp d 
4459 28 20				jr z, .foundchar 
445b 03					inc bc 
445c 23					inc hl 
445d					if DEBUG_FORTH_WORDS 
445d						DMARK "FN3" 
445d f5				push af  
445e 3a 72 44			ld a, (.dmark)  
4461 32 b4 fb			ld (debug_mark),a  
4464 3a 73 44			ld a, (.dmark+1)  
4467 32 b5 fb			ld (debug_mark+1),a  
446a 3a 74 44			ld a, (.dmark+2)  
446d 32 b6 fb			ld (debug_mark+2),a  
4470 18 03			jr .pastdmark  
4472 ..			.dmark: db "FN3"  
4475 f1			.pastdmark: pop af  
4476			endm  
# End of macro DMARK
4476						CALLMONITOR 
4476 cd 7e 16			call break_point_state  
4479				endm  
# End of macro CALLMONITOR
4479					endif 
4479 18 d8				jr .findchar 
447b			 
447b			 
447b c5			.foundchar:	push bc 
447c e1					pop hl 
447d 18 03				jr .findexit 
447f			 
447f			 
447f							 
447f			 
447f			.finddone:     ; got to end of string with no find 
447f 21 00 00				ld hl, 0 
4482			.findexit: 
4482			 
4482					if DEBUG_FORTH_WORDS 
4482						DMARK "FNd" 
4482 f5				push af  
4483 3a 97 44			ld a, (.dmark)  
4486 32 b4 fb			ld (debug_mark),a  
4489 3a 98 44			ld a, (.dmark+1)  
448c 32 b5 fb			ld (debug_mark+1),a  
448f 3a 99 44			ld a, (.dmark+2)  
4492 32 b6 fb			ld (debug_mark+2),a  
4495 18 03			jr .pastdmark  
4497 ..			.dmark: db "FNd"  
449a f1			.pastdmark: pop af  
449b			endm  
# End of macro DMARK
449b						CALLMONITOR 
449b cd 7e 16			call break_point_state  
449e				endm  
# End of macro CALLMONITOR
449e					endif 
449e cd db 1c			call forth_push_numhl 
44a1			 
44a1				       NEXTW 
44a1 c3 44 20			jp macro_next 
44a4				endm 
# End of macro NEXTW
44a4			 
44a4			.LEN: 
44a4				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44a4 4c				db WORD_SYS_CORE+56             
44a5 d9 44			dw .CHAR            
44a7 06				db 5 + 1 
44a8 .. 00			db "COUNT",0              
44ae				endm 
# End of macro CWHEAD
44ae			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44ae			 
44ae					if DEBUG_FORTH_WORDS_KEY 
44ae						DMARK "CNT" 
44ae f5				push af  
44af 3a c3 44			ld a, (.dmark)  
44b2 32 b4 fb			ld (debug_mark),a  
44b5 3a c4 44			ld a, (.dmark+1)  
44b8 32 b5 fb			ld (debug_mark+1),a  
44bb 3a c5 44			ld a, (.dmark+2)  
44be 32 b6 fb			ld (debug_mark+2),a  
44c1 18 03			jr .pastdmark  
44c3 ..			.dmark: db "CNT"  
44c6 f1			.pastdmark: pop af  
44c7			endm  
# End of macro DMARK
44c7						CALLMONITOR 
44c7 cd 7e 16			call break_point_state  
44ca				endm  
# End of macro CALLMONITOR
44ca					endif 
44ca			; TODO check string type 
44ca					FORTH_DSP 
44ca cd 98 1e			call macro_forth_dsp 
44cd				endm 
# End of macro FORTH_DSP
44cd					;v5FORTH_DSP_VALUE 
44cd			 
44cd 23					inc hl 
44ce			 
44ce 3e 00				ld a, 0 
44d0 cd 6a 11				call strlent 
44d3			 
44d3 cd db 1c				call forth_push_numhl 
44d6			 
44d6			 
44d6			 
44d6				       NEXTW 
44d6 c3 44 20			jp macro_next 
44d9				endm 
# End of macro NEXTW
44d9			.CHAR: 
44d9				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
44d9 4d				db WORD_SYS_CORE+57             
44da 0f 45			dw .ENDSTR            
44dc 05				db 4 + 1 
44dd .. 00			db "CHAR",0              
44e2				endm 
# End of macro CWHEAD
44e2			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
44e2					if DEBUG_FORTH_WORDS_KEY 
44e2						DMARK "CHR" 
44e2 f5				push af  
44e3 3a f7 44			ld a, (.dmark)  
44e6 32 b4 fb			ld (debug_mark),a  
44e9 3a f8 44			ld a, (.dmark+1)  
44ec 32 b5 fb			ld (debug_mark+1),a  
44ef 3a f9 44			ld a, (.dmark+2)  
44f2 32 b6 fb			ld (debug_mark+2),a  
44f5 18 03			jr .pastdmark  
44f7 ..			.dmark: db "CHR"  
44fa f1			.pastdmark: pop af  
44fb			endm  
# End of macro DMARK
44fb						CALLMONITOR 
44fb cd 7e 16			call break_point_state  
44fe				endm  
# End of macro CALLMONITOR
44fe					endif 
44fe					FORTH_DSP 
44fe cd 98 1e			call macro_forth_dsp 
4501				endm 
# End of macro FORTH_DSP
4501					;v5 FORTH_DSP_VALUE 
4501 23					inc hl      ; now at start of numeric as string 
4502			 
4502			;		push hl 
4502			 
4502					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4502 cd 8a 1f			call macro_forth_dsp_pop 
4505				endm 
# End of macro FORTH_DSP_POP
4505			 
4505			;		pop hl 
4505			 
4505					; push the content of a onto the stack as a value 
4505			 
4505 7e					ld a,(hl)   ; get char 
4506 26 00				ld h,0 
4508 6f					ld l,a 
4509 cd db 1c				call forth_push_numhl 
450c			 
450c				       NEXTW 
450c c3 44 20			jp macro_next 
450f				endm 
# End of macro NEXTW
450f			 
450f			 
450f			 
450f			 
450f			.ENDSTR: 
450f			; eof 
450f			 
# End of file forth_words_str.asm
450f			include "forth_words_key.asm" 
450f			 
450f			; | ## Keyboard Words 
450f			 
450f			.KEY: 
450f				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
450f 3e				db WORD_SYS_CORE+42             
4510 3f 45			dw .WAITK            
4512 04				db 3 + 1 
4513 .. 00			db "KEY",0              
4517				endm 
# End of macro CWHEAD
4517			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4517			 
4517					if DEBUG_FORTH_WORDS_KEY 
4517						DMARK "KEY" 
4517 f5				push af  
4518 3a 2c 45			ld a, (.dmark)  
451b 32 b4 fb			ld (debug_mark),a  
451e 3a 2d 45			ld a, (.dmark+1)  
4521 32 b5 fb			ld (debug_mark+1),a  
4524 3a 2e 45			ld a, (.dmark+2)  
4527 32 b6 fb			ld (debug_mark+2),a  
452a 18 03			jr .pastdmark  
452c ..			.dmark: db "KEY"  
452f f1			.pastdmark: pop af  
4530			endm  
# End of macro DMARK
4530						CALLMONITOR 
4530 cd 7e 16			call break_point_state  
4533				endm  
# End of macro CALLMONITOR
4533					endif 
4533			; TODO currently waits 
4533 cd 6d 67				call cin 
4536					;call cin_wait 
4536 6f					ld l, a 
4537 26 00				ld h, 0 
4539 cd db 1c				call forth_push_numhl 
453c					NEXTW 
453c c3 44 20			jp macro_next 
453f				endm 
# End of macro NEXTW
453f			.WAITK: 
453f				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
453f 3f				db WORD_SYS_CORE+43             
4540 71 45			dw .ACCEPT            
4542 06				db 5 + 1 
4543 .. 00			db "WAITK",0              
4549				endm 
# End of macro CWHEAD
4549			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4549					if DEBUG_FORTH_WORDS_KEY 
4549						DMARK "WAI" 
4549 f5				push af  
454a 3a 5e 45			ld a, (.dmark)  
454d 32 b4 fb			ld (debug_mark),a  
4550 3a 5f 45			ld a, (.dmark+1)  
4553 32 b5 fb			ld (debug_mark+1),a  
4556 3a 60 45			ld a, (.dmark+2)  
4559 32 b6 fb			ld (debug_mark+2),a  
455c 18 03			jr .pastdmark  
455e ..			.dmark: db "WAI"  
4561 f1			.pastdmark: pop af  
4562			endm  
# End of macro DMARK
4562						CALLMONITOR 
4562 cd 7e 16			call break_point_state  
4565				endm  
# End of macro CALLMONITOR
4565					endif 
4565 cd 5c 67				call cin_wait 
4568 6f					ld l, a 
4569 26 00				ld h, 0 
456b cd db 1c				call forth_push_numhl 
456e					NEXTW 
456e c3 44 20			jp macro_next 
4571				endm 
# End of macro NEXTW
4571			.ACCEPT: 
4571				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4571 40				db WORD_SYS_CORE+44             
4572 cf 45			dw .EDIT            
4574 07				db 6 + 1 
4575 .. 00			db "ACCEPT",0              
457c				endm 
# End of macro CWHEAD
457c			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
457c					; TODO crashes on push 
457c					if DEBUG_FORTH_WORDS_KEY 
457c						DMARK "ACC" 
457c f5				push af  
457d 3a 91 45			ld a, (.dmark)  
4580 32 b4 fb			ld (debug_mark),a  
4583 3a 92 45			ld a, (.dmark+1)  
4586 32 b5 fb			ld (debug_mark+1),a  
4589 3a 93 45			ld a, (.dmark+2)  
458c 32 b6 fb			ld (debug_mark+2),a  
458f 18 03			jr .pastdmark  
4591 ..			.dmark: db "ACC"  
4594 f1			.pastdmark: pop af  
4595			endm  
# End of macro DMARK
4595						CALLMONITOR 
4595 cd 7e 16			call break_point_state  
4598				endm  
# End of macro CALLMONITOR
4598					endif 
4598 21 98 f1				ld hl, os_input 
459b 3e 00				ld a, 0 
459d 77					ld (hl),a 
459e 3a c3 f9				ld a,(f_cursor_ptr) 
45a1 16 64				ld d, 100 
45a3 0e 00				ld c, 0 
45a5 1e 28				ld e, 40 
45a7 cd 2e 0d				call input_str 
45aa					; TODO perhaps do a type check and wrap in quotes if not a number 
45aa 21 98 f1				ld hl, os_input 
45ad					if DEBUG_FORTH_WORDS 
45ad						DMARK "AC1" 
45ad f5				push af  
45ae 3a c2 45			ld a, (.dmark)  
45b1 32 b4 fb			ld (debug_mark),a  
45b4 3a c3 45			ld a, (.dmark+1)  
45b7 32 b5 fb			ld (debug_mark+1),a  
45ba 3a c4 45			ld a, (.dmark+2)  
45bd 32 b6 fb			ld (debug_mark+2),a  
45c0 18 03			jr .pastdmark  
45c2 ..			.dmark: db "AC1"  
45c5 f1			.pastdmark: pop af  
45c6			endm  
# End of macro DMARK
45c6						CALLMONITOR 
45c6 cd 7e 16			call break_point_state  
45c9				endm  
# End of macro CALLMONITOR
45c9					endif 
45c9 cd 49 1d				call forth_push_str 
45cc					NEXTW 
45cc c3 44 20			jp macro_next 
45cf				endm 
# End of macro NEXTW
45cf			 
45cf			.EDIT: 
45cf				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45cf 40				db WORD_SYS_CORE+44             
45d0 71 46			dw .ENDKEY            
45d2 05				db 4 + 1 
45d3 .. 00			db "EDIT",0              
45d8				endm 
# End of macro CWHEAD
45d8			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
45d8			 
45d8					; TODO does not copy from stack 
45d8					if DEBUG_FORTH_WORDS_KEY 
45d8						DMARK "EDT" 
45d8 f5				push af  
45d9 3a ed 45			ld a, (.dmark)  
45dc 32 b4 fb			ld (debug_mark),a  
45df 3a ee 45			ld a, (.dmark+1)  
45e2 32 b5 fb			ld (debug_mark+1),a  
45e5 3a ef 45			ld a, (.dmark+2)  
45e8 32 b6 fb			ld (debug_mark+2),a  
45eb 18 03			jr .pastdmark  
45ed ..			.dmark: db "EDT"  
45f0 f1			.pastdmark: pop af  
45f1			endm  
# End of macro DMARK
45f1						CALLMONITOR 
45f1 cd 7e 16			call break_point_state  
45f4				endm  
# End of macro CALLMONITOR
45f4					endif 
45f4			 
45f4					;FORTH_DSP 
45f4					FORTH_DSP_VALUEHL 
45f4 cd d2 1e			call macro_dsp_valuehl 
45f7				endm 
# End of macro FORTH_DSP_VALUEHL
45f7			;		inc hl    ; TODO do type check 
45f7			 
45f7			;		call get_word_hl 
45f7 e5					push hl 
45f8					if DEBUG_FORTH_WORDS 
45f8						DMARK "EDp" 
45f8 f5				push af  
45f9 3a 0d 46			ld a, (.dmark)  
45fc 32 b4 fb			ld (debug_mark),a  
45ff 3a 0e 46			ld a, (.dmark+1)  
4602 32 b5 fb			ld (debug_mark+1),a  
4605 3a 0f 46			ld a, (.dmark+2)  
4608 32 b6 fb			ld (debug_mark+2),a  
460b 18 03			jr .pastdmark  
460d ..			.dmark: db "EDp"  
4610 f1			.pastdmark: pop af  
4611			endm  
# End of macro DMARK
4611						CALLMONITOR 
4611 cd 7e 16			call break_point_state  
4614				endm  
# End of macro CALLMONITOR
4614					endif 
4614				;	ld a, 0 
4614 cd 5f 11				call strlenz 
4617 23					inc hl 
4618			 
4618 06 00				ld b, 0 
461a 4d					ld c, l 
461b			 
461b e1					pop hl 
461c 11 98 f1				ld de, os_input 
461f					if DEBUG_FORTH_WORDS_KEY 
461f						DMARK "EDc" 
461f f5				push af  
4620 3a 34 46			ld a, (.dmark)  
4623 32 b4 fb			ld (debug_mark),a  
4626 3a 35 46			ld a, (.dmark+1)  
4629 32 b5 fb			ld (debug_mark+1),a  
462c 3a 36 46			ld a, (.dmark+2)  
462f 32 b6 fb			ld (debug_mark+2),a  
4632 18 03			jr .pastdmark  
4634 ..			.dmark: db "EDc"  
4637 f1			.pastdmark: pop af  
4638			endm  
# End of macro DMARK
4638						CALLMONITOR 
4638 cd 7e 16			call break_point_state  
463b				endm  
# End of macro CALLMONITOR
463b					endif 
463b ed b0				ldir 
463d			 
463d			 
463d 21 98 f1				ld hl, os_input 
4640					;ld a, 0 
4640					;ld (hl),a 
4640 3a c3 f9				ld a,(f_cursor_ptr) 
4643 16 64				ld d, 100 
4645 0e 00				ld c, 0 
4647 1e 28				ld e, 40 
4649 cd 2e 0d				call input_str 
464c					; TODO perhaps do a type check and wrap in quotes if not a number 
464c 21 98 f1				ld hl, os_input 
464f					if DEBUG_FORTH_WORDS 
464f						DMARK "ED1" 
464f f5				push af  
4650 3a 64 46			ld a, (.dmark)  
4653 32 b4 fb			ld (debug_mark),a  
4656 3a 65 46			ld a, (.dmark+1)  
4659 32 b5 fb			ld (debug_mark+1),a  
465c 3a 66 46			ld a, (.dmark+2)  
465f 32 b6 fb			ld (debug_mark+2),a  
4662 18 03			jr .pastdmark  
4664 ..			.dmark: db "ED1"  
4667 f1			.pastdmark: pop af  
4668			endm  
# End of macro DMARK
4668						CALLMONITOR 
4668 cd 7e 16			call break_point_state  
466b				endm  
# End of macro CALLMONITOR
466b					endif 
466b cd 49 1d				call forth_push_str 
466e					NEXTW 
466e c3 44 20			jp macro_next 
4671				endm 
# End of macro NEXTW
4671			 
4671			 
4671			 
4671			.ENDKEY: 
4671			; eof 
4671			 
# End of file forth_words_key.asm
4671			 
4671			if STORAGE_SE 
4671			   	include "forth_words_storage.asm" 
4671			 
4671			; | ## Fixed Storage Words 
4671			 
4671			 
4671			.BREAD: 
4671			  
4671				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4671 3a				db WORD_SYS_CORE+38             
4672 f4 46			dw .BWRITE            
4674 06				db 5 + 1 
4675 .. 00			db "BREAD",0              
467b				endm 
# End of macro CWHEAD
467b			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
467b				 
467b					if DEBUG_FORTH_WORDS_KEY 
467b						DMARK "BRD" 
467b f5				push af  
467c 3a 90 46			ld a, (.dmark)  
467f 32 b4 fb			ld (debug_mark),a  
4682 3a 91 46			ld a, (.dmark+1)  
4685 32 b5 fb			ld (debug_mark+1),a  
4688 3a 92 46			ld a, (.dmark+2)  
468b 32 b6 fb			ld (debug_mark+2),a  
468e 18 03			jr .pastdmark  
4690 ..			.dmark: db "BRD"  
4693 f1			.pastdmark: pop af  
4694			endm  
# End of macro DMARK
4694						CALLMONITOR 
4694 cd 7e 16			call break_point_state  
4697				endm  
# End of macro CALLMONITOR
4697					endif 
4697			 
4697				FORTH_DSP_VALUEHL 
4697 cd d2 1e			call macro_dsp_valuehl 
469a				endm 
# End of macro FORTH_DSP_VALUEHL
469a			 
469a				FORTH_DSP_POP 
469a cd 8a 1f			call macro_forth_dsp_pop 
469d				endm 
# End of macro FORTH_DSP_POP
469d			 
469d				; calc block address 
469d			 
469d eb				ex de, hl 
469e 3e 40			ld a, STORE_BLOCK_PHY 
46a0 cd 84 0c			call Mult16 
46a3			 
46a3			 
46a3 11 df f9			ld de, store_page 
46a6			 
46a6					if DEBUG_FORTH_WORDS 
46a6						DMARK "BR1" 
46a6 f5				push af  
46a7 3a bb 46			ld a, (.dmark)  
46aa 32 b4 fb			ld (debug_mark),a  
46ad 3a bc 46			ld a, (.dmark+1)  
46b0 32 b5 fb			ld (debug_mark+1),a  
46b3 3a bd 46			ld a, (.dmark+2)  
46b6 32 b6 fb			ld (debug_mark+2),a  
46b9 18 03			jr .pastdmark  
46bb ..			.dmark: db "BR1"  
46be f1			.pastdmark: pop af  
46bf			endm  
# End of macro DMARK
46bf						CALLMONITOR 
46bf cd 7e 16			call break_point_state  
46c2				endm  
# End of macro CALLMONITOR
46c2					endif 
46c2			 
46c2 cd df 02			call storage_read_block 
46c5			 
46c5 cd 2a 0d			call ishlzero 
46c8 20 05			jr nz, .brfound 
46ca			 
46ca cd db 1c			call forth_push_numhl 
46cd 18 22			jr .brdone 
46cf			 
46cf			 
46cf			.brfound: 
46cf 21 e1 f9		        ld hl, store_page+2 
46d2			 
46d2					if DEBUG_FORTH_WORDS 
46d2						DMARK "BR2" 
46d2 f5				push af  
46d3 3a e7 46			ld a, (.dmark)  
46d6 32 b4 fb			ld (debug_mark),a  
46d9 3a e8 46			ld a, (.dmark+1)  
46dc 32 b5 fb			ld (debug_mark+1),a  
46df 3a e9 46			ld a, (.dmark+2)  
46e2 32 b6 fb			ld (debug_mark+2),a  
46e5 18 03			jr .pastdmark  
46e7 ..			.dmark: db "BR2"  
46ea f1			.pastdmark: pop af  
46eb			endm  
# End of macro DMARK
46eb						CALLMONITOR 
46eb cd 7e 16			call break_point_state  
46ee				endm  
# End of macro CALLMONITOR
46ee					endif 
46ee			 
46ee cd 49 1d			call forth_push_str 
46f1			 
46f1			 
46f1			.brdone: 
46f1			 
46f1					NEXTW 
46f1 c3 44 20			jp macro_next 
46f4				endm 
# End of macro NEXTW
46f4			.BWRITE: 
46f4				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
46f4 3a				db WORD_SYS_CORE+38             
46f5 89 47			dw .BUPD            
46f7 07				db 6 + 1 
46f8 .. 00			db "BWRITE",0              
46ff				endm 
# End of macro CWHEAD
46ff			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
46ff			 
46ff					if DEBUG_FORTH_WORDS_KEY 
46ff						DMARK "BWR" 
46ff f5				push af  
4700 3a 14 47			ld a, (.dmark)  
4703 32 b4 fb			ld (debug_mark),a  
4706 3a 15 47			ld a, (.dmark+1)  
4709 32 b5 fb			ld (debug_mark+1),a  
470c 3a 16 47			ld a, (.dmark+2)  
470f 32 b6 fb			ld (debug_mark+2),a  
4712 18 03			jr .pastdmark  
4714 ..			.dmark: db "BWR"  
4717 f1			.pastdmark: pop af  
4718			endm  
# End of macro DMARK
4718						CALLMONITOR 
4718 cd 7e 16			call break_point_state  
471b				endm  
# End of macro CALLMONITOR
471b					endif 
471b			 
471b				FORTH_DSP_VALUEHL 
471b cd d2 1e			call macro_dsp_valuehl 
471e				endm 
# End of macro FORTH_DSP_VALUEHL
471e			 
471e				; calc block address 
471e			 
471e eb				ex de, hl 
471f 3e 40			ld a, STORE_BLOCK_PHY 
4721 cd 84 0c			call Mult16 
4724			 
4724 e5				push hl         ; address 
4725			 
4725				FORTH_DSP_POP 
4725 cd 8a 1f			call macro_forth_dsp_pop 
4728				endm 
# End of macro FORTH_DSP_POP
4728			 
4728				FORTH_DSP_VALUEHL 
4728 cd d2 1e			call macro_dsp_valuehl 
472b				endm 
# End of macro FORTH_DSP_VALUEHL
472b			 
472b				FORTH_DSP_POP 
472b cd 8a 1f			call macro_forth_dsp_pop 
472e				endm 
# End of macro FORTH_DSP_POP
472e			 
472e cd 0d 0a			call storage_clear_page 
4731			 
4731				; copy string to store page 
4731			 
4731 e5				push hl     ; save string address 
4732			 
4732 3e 00			ld a, 0 
4734 cd 6a 11			call strlent 
4737			 
4737 23				inc hl 
4738			 
4738 4d				ld c, l 
4739 06 00			ld b, 0 
473b			 
473b e1				pop hl 
473c 11 e1 f9			ld de, store_page + 2 
473f					if DEBUG_FORTH_WORDS 
473f						DMARK "BW1" 
473f f5				push af  
4740 3a 54 47			ld a, (.dmark)  
4743 32 b4 fb			ld (debug_mark),a  
4746 3a 55 47			ld a, (.dmark+1)  
4749 32 b5 fb			ld (debug_mark+1),a  
474c 3a 56 47			ld a, (.dmark+2)  
474f 32 b6 fb			ld (debug_mark+2),a  
4752 18 03			jr .pastdmark  
4754 ..			.dmark: db "BW1"  
4757 f1			.pastdmark: pop af  
4758			endm  
# End of macro DMARK
4758						CALLMONITOR 
4758 cd 7e 16			call break_point_state  
475b				endm  
# End of macro CALLMONITOR
475b					endif 
475b ed b0			ldir 
475d			 
475d			 
475d				; poke the start of the block with flags to prevent high level file ops hitting the block 
475d			 
475d 21 ff ff			ld hl, $ffff 
4760			 
4760 22 df f9			ld (store_page), hl	 
4763				 
4763 e1				pop hl    ; get address 
4764 11 df f9			ld de, store_page 
4767			 
4767					if DEBUG_FORTH_WORDS 
4767						DMARK "BW2" 
4767 f5				push af  
4768 3a 7c 47			ld a, (.dmark)  
476b 32 b4 fb			ld (debug_mark),a  
476e 3a 7d 47			ld a, (.dmark+1)  
4771 32 b5 fb			ld (debug_mark+1),a  
4774 3a 7e 47			ld a, (.dmark+2)  
4777 32 b6 fb			ld (debug_mark+2),a  
477a 18 03			jr .pastdmark  
477c ..			.dmark: db "BW2"  
477f f1			.pastdmark: pop af  
4780			endm  
# End of macro DMARK
4780						CALLMONITOR 
4780 cd 7e 16			call break_point_state  
4783				endm  
# End of macro CALLMONITOR
4783					endif 
4783			 
4783 cd 44 03			call storage_write_block 
4786			 
4786					NEXTW 
4786 c3 44 20			jp macro_next 
4789				endm 
# End of macro NEXTW
4789			 
4789			.BUPD: 
4789				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4789 3a				db WORD_SYS_CORE+38             
478a df 47			dw .BYID            
478c 05				db 4 + 1 
478d .. 00			db "BUPD",0              
4792				endm 
# End of macro CWHEAD
4792			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4792			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4792			; | | or completely different file system structure. 
4792			 
4792					if DEBUG_FORTH_WORDS_KEY 
4792						DMARK "BUD" 
4792 f5				push af  
4793 3a a7 47			ld a, (.dmark)  
4796 32 b4 fb			ld (debug_mark),a  
4799 3a a8 47			ld a, (.dmark+1)  
479c 32 b5 fb			ld (debug_mark+1),a  
479f 3a a9 47			ld a, (.dmark+2)  
47a2 32 b6 fb			ld (debug_mark+2),a  
47a5 18 03			jr .pastdmark  
47a7 ..			.dmark: db "BUD"  
47aa f1			.pastdmark: pop af  
47ab			endm  
# End of macro DMARK
47ab						CALLMONITOR 
47ab cd 7e 16			call break_point_state  
47ae				endm  
# End of macro CALLMONITOR
47ae					endif 
47ae			 
47ae				FORTH_DSP_VALUEHL 
47ae cd d2 1e			call macro_dsp_valuehl 
47b1				endm 
# End of macro FORTH_DSP_VALUEHL
47b1			 
47b1				; calc block address 
47b1			 
47b1 eb				ex de, hl 
47b2 3e 40			ld a, STORE_BLOCK_PHY 
47b4 cd 84 0c			call Mult16 
47b7			 
47b7				FORTH_DSP_POP 
47b7 cd 8a 1f			call macro_forth_dsp_pop 
47ba				endm 
# End of macro FORTH_DSP_POP
47ba			 
47ba			 
47ba 11 df f9			ld de, store_page 
47bd			 
47bd					if DEBUG_FORTH_WORDS 
47bd						DMARK "BUe" 
47bd f5				push af  
47be 3a d2 47			ld a, (.dmark)  
47c1 32 b4 fb			ld (debug_mark),a  
47c4 3a d3 47			ld a, (.dmark+1)  
47c7 32 b5 fb			ld (debug_mark+1),a  
47ca 3a d4 47			ld a, (.dmark+2)  
47cd 32 b6 fb			ld (debug_mark+2),a  
47d0 18 03			jr .pastdmark  
47d2 ..			.dmark: db "BUe"  
47d5 f1			.pastdmark: pop af  
47d6			endm  
# End of macro DMARK
47d6						CALLMONITOR 
47d6 cd 7e 16			call break_point_state  
47d9				endm  
# End of macro CALLMONITOR
47d9					endif 
47d9			 
47d9 cd 44 03			call storage_write_block 
47dc			 
47dc					NEXTW 
47dc c3 44 20			jp macro_next 
47df				endm 
# End of macro NEXTW
47df			 
47df			.BYID: 
47df			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47df			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47df			; 
47df			;		 
47df			;		if DEBUG_FORTH_WORDS_KEY 
47df			;			DMARK "BYID" 
47df			;			CALLMONITOR 
47df			;		endif 
47df			; 
47df			;		; get direct address 
47df			; 
47df			;		FORTH_DSP_VALUEHL 
47df			; 
47df			;		FORTH_DSP_POP 
47df			; 
47df			;	; calc block address 
47df			; 
47df			;	ex de, hl 
47df			;	ld a, STORE_BLOCK_PHY 
47df			;	call Mult16 
47df			;	;	do BREAD with number as param 
47df			;	; push the file name	 
47df			;	ld de, store_page 
47df			;	call storage_read_block 
47df			 ;       ld hl, store_page+2 
47df			; 
47df			; 
47df			;		NEXTW 
47df			;.BYNAME: 
47df			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47df			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47df			;		NEXTW 
47df			; 
47df			.DIR: 
47df				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47df 3a				db WORD_SYS_CORE+38             
47e0 e3 48			dw .SAVE            
47e2 04				db 3 + 1 
47e3 .. 00			db "DIR",0              
47e7				endm 
# End of macro CWHEAD
47e7			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
47e7			 
47e7					if DEBUG_FORTH_WORDS_KEY 
47e7						DMARK "DIR" 
47e7 f5				push af  
47e8 3a fc 47			ld a, (.dmark)  
47eb 32 b4 fb			ld (debug_mark),a  
47ee 3a fd 47			ld a, (.dmark+1)  
47f1 32 b5 fb			ld (debug_mark+1),a  
47f4 3a fe 47			ld a, (.dmark+2)  
47f7 32 b6 fb			ld (debug_mark+2),a  
47fa 18 03			jr .pastdmark  
47fc ..			.dmark: db "DIR"  
47ff f1			.pastdmark: pop af  
4800			endm  
# End of macro DMARK
4800						CALLMONITOR 
4800 cd 7e 16			call break_point_state  
4803				endm  
# End of macro CALLMONITOR
4803					endif 
4803 cd 90 03			call storage_get_block_0 
4806			 
4806 21 df f9			ld hl, store_page     ; get current id count 
4809 46				ld b, (hl) 
480a 0e 00			ld c, 0    ; count of files   
480c					if DEBUG_FORTH_WORDS 
480c						DMARK "DI1" 
480c f5				push af  
480d 3a 21 48			ld a, (.dmark)  
4810 32 b4 fb			ld (debug_mark),a  
4813 3a 22 48			ld a, (.dmark+1)  
4816 32 b5 fb			ld (debug_mark+1),a  
4819 3a 23 48			ld a, (.dmark+2)  
481c 32 b6 fb			ld (debug_mark+2),a  
481f 18 03			jr .pastdmark  
4821 ..			.dmark: db "DI1"  
4824 f1			.pastdmark: pop af  
4825			endm  
# End of macro DMARK
4825						CALLMONITOR 
4825 cd 7e 16			call break_point_state  
4828				endm  
# End of macro CALLMONITOR
4828					endif 
4828			 
4828				; check for empty drive 
4828			 
4828 3e 00			ld a, 0 
482a b8				cp b 
482b ca 99 48			jp z, .dirdone 
482e			 
482e				; for each of the current ids do a search for them and if found push to stack 
482e			 
482e c5			.diritem:	push bc 
482f 21 40 00				ld hl, STORE_BLOCK_PHY 
4832 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4834 58					ld e,b 
4835			 
4835			;		if DEBUG_FORTH_WORDS 
4835			;			DMARK "DI2" 
4835			;			CALLMONITOR 
4835			;		endif 
4835			 
4835 cd 12 06				call storage_findnextid 
4838			 
4838			;		if DEBUG_FORTH_WORDS 
4838			;			DMARK "DI3" 
4838			;			CALLMONITOR 
4838			;		endif 
4838			 
4838					; if found hl will be non zero 
4838			 
4838 cd 2a 0d				call ishlzero 
483b			;		ld a, l 
483b			;		add h 
483b			; 
483b			;		cp 0 
483b 28 59				jr z, .dirnotfound 
483d			 
483d					; increase count 
483d			 
483d c1					pop bc	 
483e 0c					inc c 
483f c5					push bc 
4840					 
4840			 
4840					; get file header and push the file name 
4840			 
4840 11 df f9				ld de, store_page 
4843 cd df 02				call storage_read_block 
4846			 
4846					; push file id to stack 
4846				 
4846 3a df f9				ld a, (store_page) 
4849 26 00				ld h, 0 
484b 6f					ld l, a 
484c cd db 1c				call forth_push_numhl 
484f			 
484f					; push extent count to stack  
484f				 
484f 3a e1 f9				ld a, (store_page+2) 
4852 26 00				ld h, 0 
4854 6f					ld l, a 
4855 cd db 1c				call forth_push_numhl 
4858			 
4858					; push file name 
4858			 
4858 21 e2 f9				ld hl, store_page+3 
485b					if DEBUG_FORTH_WORDS 
485b						DMARK "DI5" 
485b f5				push af  
485c 3a 70 48			ld a, (.dmark)  
485f 32 b4 fb			ld (debug_mark),a  
4862 3a 71 48			ld a, (.dmark+1)  
4865 32 b5 fb			ld (debug_mark+1),a  
4868 3a 72 48			ld a, (.dmark+2)  
486b 32 b6 fb			ld (debug_mark+2),a  
486e 18 03			jr .pastdmark  
4870 ..			.dmark: db "DI5"  
4873 f1			.pastdmark: pop af  
4874			endm  
# End of macro DMARK
4874						CALLMONITOR 
4874 cd 7e 16			call break_point_state  
4877				endm  
# End of macro CALLMONITOR
4877					endif 
4877 cd 49 1d				call forth_push_str 
487a					if DEBUG_FORTH_WORDS 
487a						DMARK "DI6" 
487a f5				push af  
487b 3a 8f 48			ld a, (.dmark)  
487e 32 b4 fb			ld (debug_mark),a  
4881 3a 90 48			ld a, (.dmark+1)  
4884 32 b5 fb			ld (debug_mark+1),a  
4887 3a 91 48			ld a, (.dmark+2)  
488a 32 b6 fb			ld (debug_mark+2),a  
488d 18 03			jr .pastdmark  
488f ..			.dmark: db "DI6"  
4892 f1			.pastdmark: pop af  
4893			endm  
# End of macro DMARK
4893						CALLMONITOR 
4893 cd 7e 16			call break_point_state  
4896				endm  
# End of macro CALLMONITOR
4896					endif 
4896			.dirnotfound: 
4896 c1					pop bc     
4897 10 95				djnz .diritem 
4899				 
4899			.dirdone:	 
4899					if DEBUG_FORTH_WORDS 
4899						DMARK "DI7" 
4899 f5				push af  
489a 3a ae 48			ld a, (.dmark)  
489d 32 b4 fb			ld (debug_mark),a  
48a0 3a af 48			ld a, (.dmark+1)  
48a3 32 b5 fb			ld (debug_mark+1),a  
48a6 3a b0 48			ld a, (.dmark+2)  
48a9 32 b6 fb			ld (debug_mark+2),a  
48ac 18 03			jr .pastdmark  
48ae ..			.dmark: db "DI7"  
48b1 f1			.pastdmark: pop af  
48b2			endm  
# End of macro DMARK
48b2						CALLMONITOR 
48b2 cd 7e 16			call break_point_state  
48b5				endm  
# End of macro CALLMONITOR
48b5					endif 
48b5			 
48b5					; push a count of the dir items found 
48b5			 
48b5 26 00				ld h, 0 
48b7 69					ld l, c 
48b8 cd db 1c				call forth_push_numhl 
48bb			 
48bb					; push the bank label 
48bb			 
48bb cd 90 03				call storage_get_block_0 
48be			 
48be				 
48be 21 e2 f9		 		ld hl, store_page+3 
48c1			 
48c1					if DEBUG_FORTH_WORDS 
48c1						DMARK "DI8" 
48c1 f5				push af  
48c2 3a d6 48			ld a, (.dmark)  
48c5 32 b4 fb			ld (debug_mark),a  
48c8 3a d7 48			ld a, (.dmark+1)  
48cb 32 b5 fb			ld (debug_mark+1),a  
48ce 3a d8 48			ld a, (.dmark+2)  
48d1 32 b6 fb			ld (debug_mark+2),a  
48d4 18 03			jr .pastdmark  
48d6 ..			.dmark: db "DI8"  
48d9 f1			.pastdmark: pop af  
48da			endm  
# End of macro DMARK
48da						CALLMONITOR 
48da cd 7e 16			call break_point_state  
48dd				endm  
# End of macro CALLMONITOR
48dd					endif 
48dd cd 49 1d				call forth_push_str 
48e0			 
48e0			 
48e0				 
48e0					NEXTW 
48e0 c3 44 20			jp macro_next 
48e3				endm 
# End of macro NEXTW
48e3			.SAVE: 
48e3			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
48e3			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
48e3			;		NEXTW 
48e3			;.LOAD: 
48e3			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
48e3			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
48e3			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
48e3			;; > > The LOAD command can not be used in any user words or compound lines. 
48e3			; 
48e3			;		; store_openext use it. If zero it is EOF 
48e3			; 
48e3			;		; read block from current stream id 
48e3			;		; if the block does not contain zero term keep reading blocks until zero found 
48e3			;		; push the block to stack 
48e3			;		; save the block id to stream 
48e3			; 
48e3			; 
48e3			;		FORTH_DSP_VALUEHL 
48e3			; 
48e3			;;		push hl 
48e3			; 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LOA" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			;		FORTH_DSP_POP 
48e3			; 
48e3			;;		pop hl 
48e3			; 
48e3			;		ld h, l 
48e3			;		ld l, 0 
48e3			; 
48e3			;		push hl     ; stack holds current file id and extent to work with 
48e3			; 
48e3			; 
48e3			;		ld de, store_page      ; get block zero of file 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LO0" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			;		call storage_read 
48e3			; 
48e3			;		ld a, (store_page+2)    ; max extents for this file 
48e3			;		ld  (store_openmaxext),a   ; get our limit 
48e3			; 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LOE" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			; 
48e3			;; TODO dont know why max extents are not present 
48e3			;;		cp 0 
48e3			;;		jp z, .loadeof     ; dont read past eof 
48e3			; 
48e3			;;		ld a, 1   ; start from the head of the file 
48e3			; 
48e3			;.loadline:	pop hl 
48e3			;		inc hl 
48e3			;		ld  a, (store_openmaxext)   ; get our limit 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LOx" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			;		inc a 
48e3			;		cp l 
48e3			;		jp z, .loadeof 
48e3			;		push hl    ; save current extent 
48e3			; 
48e3			;		ld de, store_page 
48e3			; 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LO1" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			;		call storage_read 
48e3			; 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LO2" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			;	call ishlzero 
48e3			;	ld a, l 
48e3			;	add h 
48e3			;	cp 0 
48e3			;	jr z, .loadeof 
48e3			; 
48e3			;	; not eof so hl should point to data to exec 
48e3			; 
48e3			;	; will need to add the FORTH_END_BUFFER flag 
48e3			 ; 
48e3			;	ld hl, store_page+2 
48e3			;	ld bc, 255 
48e3			;	ld a, 0 
48e3			;	cpir 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LOt" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			;	dec hl 
48e3			;	ld a, ' ' 
48e3			;	ld (hl), a 
48e3			;	inc hl 
48e3			;	ld (hl), a 
48e3			;	inc hl 
48e3			;	ld (hl), a 
48e3			;	inc hl 
48e3			;	ld a, FORTH_END_BUFFER 
48e3			;	ld (hl), a 
48e3			; 
48e3			;	; TODO handle more than a single block read 
48e3			; 
48e3			; 
48e3			;	ld hl, store_page+2 
48e3			; 
48e3			;	ld (os_tok_ptr), hl 
48e3			; 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LO3" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			; 
48e3			;	call forthparse 
48e3			;	call forthexec 
48e3			;	call forthexec_cleanup 
48e3			; 
48e3			;	; go to next extent 
48e3			; 
48e3			;	; get next block  or mark as eof 
48e3			;	jp .loadline 
48e3			; 
48e3			; 
48e3			; 
48e3			;	       NEXTW 
48e3			;.loadeof:	ld a, 0 
48e3			;		ld (store_openext), a 
48e3			; 
48e3			;	if DEBUG_STORESE 
48e3			;		DMARK "LOF" 
48e3			;		CALLMONITOR 
48e3			;	endif 
48e3			;		ret 
48e3			;		;NEXTW 
48e3			;.BSAVE:   
48e3			; 
48e3			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
48e3			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
48e3			;		NEXTW 
48e3			;.BLOAD: 
48e3			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
48e3			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
48e3			;		NEXTW 
48e3			;;;; counter gap 
48e3			 
48e3			 
48e3			.SEO: 
48e3				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
48e3 64				db WORD_SYS_CORE+80             
48e4 02 49			dw .SEI            
48e6 04				db 3 + 1 
48e7 .. 00			db "SEO",0              
48eb				endm 
# End of macro CWHEAD
48eb			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
48eb			 
48eb					; get port 
48eb			 
48eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48eb cd d2 1e			call macro_dsp_valuehl 
48ee				endm 
# End of macro FORTH_DSP_VALUEHL
48ee			 
48ee e5					push hl    ; u2 - byte 
48ef			 
48ef					; destroy value TOS 
48ef			 
48ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48ef cd 8a 1f			call macro_forth_dsp_pop 
48f2				endm 
# End of macro FORTH_DSP_POP
48f2			 
48f2					; get byte to send 
48f2			 
48f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48f2 cd d2 1e			call macro_dsp_valuehl 
48f5				endm 
# End of macro FORTH_DSP_VALUEHL
48f5			 
48f5 e5					push hl    ; u1 - addr 
48f6			 
48f6					; destroy value TOS 
48f6			 
48f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48f6 cd 8a 1f			call macro_forth_dsp_pop 
48f9				endm 
# End of macro FORTH_DSP_POP
48f9			 
48f9					; one value on hl get other one back 
48f9			 
48f9 d1					pop de   ; u1 - byte 
48fa			 
48fa e1					pop hl   ; u2 - addr 
48fb			 
48fb					; TODO Send SPI byte 
48fb			 
48fb			 
48fb 7b					ld a, e 
48fc cd bd 01				call se_writebyte 
48ff			 
48ff					 
48ff			 
48ff					NEXTW 
48ff c3 44 20			jp macro_next 
4902				endm 
# End of macro NEXTW
4902			 
4902			.SEI: 
4902				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4902 65				db WORD_SYS_CORE+81             
4903 1c 49			dw .SFREE            
4905 04				db 3 + 1 
4906 .. 00			db "SEI",0              
490a				endm 
# End of macro CWHEAD
490a			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
490a			 
490a					; get port 
490a			 
490a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
490a cd d2 1e			call macro_dsp_valuehl 
490d				endm 
# End of macro FORTH_DSP_VALUEHL
490d			 
490d			;		push hl 
490d			 
490d					; destroy value TOS 
490d			 
490d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
490d cd 8a 1f			call macro_forth_dsp_pop 
4910				endm 
# End of macro FORTH_DSP_POP
4910			 
4910					; one value on hl get other one back 
4910			 
4910			;		pop hl 
4910			 
4910			 
4910					; TODO Get SPI byte 
4910			 
4910 cd 5f 02				call se_readbyte 
4913			 
4913 26 00				ld h, 0 
4915 6f					ld l, a 
4916 cd db 1c				call forth_push_numhl 
4919			 
4919					NEXTW 
4919 c3 44 20			jp macro_next 
491c				endm 
# End of macro NEXTW
491c			 
491c			.SFREE: 
491c				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
491c 67				db WORD_SYS_CORE+83             
491d 4b 49			dw .SIZE            
491f 06				db 5 + 1 
4920 .. 00			db "FFREE",0              
4926				endm 
# End of macro CWHEAD
4926			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4926					if DEBUG_FORTH_WORDS_KEY 
4926						DMARK "FFR" 
4926 f5				push af  
4927 3a 3b 49			ld a, (.dmark)  
492a 32 b4 fb			ld (debug_mark),a  
492d 3a 3c 49			ld a, (.dmark+1)  
4930 32 b5 fb			ld (debug_mark+1),a  
4933 3a 3d 49			ld a, (.dmark+2)  
4936 32 b6 fb			ld (debug_mark+2),a  
4939 18 03			jr .pastdmark  
493b ..			.dmark: db "FFR"  
493e f1			.pastdmark: pop af  
493f			endm  
# End of macro DMARK
493f						CALLMONITOR 
493f cd 7e 16			call break_point_state  
4942				endm  
# End of macro CALLMONITOR
4942					endif 
4942			 
4942 cd ac 06				call storage_freeblocks 
4945			 
4945 cd db 1c				call forth_push_numhl 
4948			 
4948				       NEXTW 
4948 c3 44 20			jp macro_next 
494b				endm 
# End of macro NEXTW
494b			.SIZE: 
494b				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
494b 67				db WORD_SYS_CORE+83             
494c 7f 49			dw .CREATE            
494e 05				db 4 + 1 
494f .. 00			db "SIZE",0              
4954				endm 
# End of macro CWHEAD
4954			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4954					if DEBUG_FORTH_WORDS_KEY 
4954						DMARK "SIZ" 
4954 f5				push af  
4955 3a 69 49			ld a, (.dmark)  
4958 32 b4 fb			ld (debug_mark),a  
495b 3a 6a 49			ld a, (.dmark+1)  
495e 32 b5 fb			ld (debug_mark+1),a  
4961 3a 6b 49			ld a, (.dmark+2)  
4964 32 b6 fb			ld (debug_mark+2),a  
4967 18 03			jr .pastdmark  
4969 ..			.dmark: db "SIZ"  
496c f1			.pastdmark: pop af  
496d			endm  
# End of macro DMARK
496d						CALLMONITOR 
496d cd 7e 16			call break_point_state  
4970				endm  
# End of macro CALLMONITOR
4970					endif 
4970			 
4970					FORTH_DSP_VALUEHL 
4970 cd d2 1e			call macro_dsp_valuehl 
4973				endm 
# End of macro FORTH_DSP_VALUEHL
4973			;		push hl 
4973					FORTH_DSP_POP 
4973 cd 8a 1f			call macro_forth_dsp_pop 
4976				endm 
# End of macro FORTH_DSP_POP
4976			;		pop hl 
4976 cd 0e 03				call storage_file_size 
4979			 
4979 cd db 1c				call forth_push_numhl 
497c			  
497c			 
497c				       NEXTW 
497c c3 44 20			jp macro_next 
497f				endm 
# End of macro NEXTW
497f			 
497f			.CREATE: 
497f				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
497f 68				db WORD_SYS_CORE+84             
4980 ed 49			dw .APPEND            
4982 07				db 6 + 1 
4983 .. 00			db "CREATE",0              
498a				endm 
# End of macro CWHEAD
498a			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
498a			; | | e.g.  
498a			; | | TestProgram CREATE 
498a			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
498a			; | |  
498a			; | | Max file IDs are 255. 
498a			; | |  
498a					 
498a					if DEBUG_FORTH_WORDS_KEY 
498a						DMARK "CRT" 
498a f5				push af  
498b 3a 9f 49			ld a, (.dmark)  
498e 32 b4 fb			ld (debug_mark),a  
4991 3a a0 49			ld a, (.dmark+1)  
4994 32 b5 fb			ld (debug_mark+1),a  
4997 3a a1 49			ld a, (.dmark+2)  
499a 32 b6 fb			ld (debug_mark+2),a  
499d 18 03			jr .pastdmark  
499f ..			.dmark: db "CRT"  
49a2 f1			.pastdmark: pop af  
49a3			endm  
# End of macro DMARK
49a3						CALLMONITOR 
49a3 cd 7e 16			call break_point_state  
49a6				endm  
# End of macro CALLMONITOR
49a6					endif 
49a6			;		call storage_get_block_0 
49a6			 
49a6					; TODO pop hl 
49a6			 
49a6					;v5 FORTH_DSP_VALUE 
49a6					FORTH_DSP_VALUE 
49a6 cd bb 1e			call macro_forth_dsp_value 
49a9				endm 
# End of macro FORTH_DSP_VALUE
49a9			 
49a9				if DEBUG_STORESE 
49a9					DMARK "CR1" 
49a9 f5				push af  
49aa 3a be 49			ld a, (.dmark)  
49ad 32 b4 fb			ld (debug_mark),a  
49b0 3a bf 49			ld a, (.dmark+1)  
49b3 32 b5 fb			ld (debug_mark+1),a  
49b6 3a c0 49			ld a, (.dmark+2)  
49b9 32 b6 fb			ld (debug_mark+2),a  
49bc 18 03			jr .pastdmark  
49be ..			.dmark: db "CR1"  
49c1 f1			.pastdmark: pop af  
49c2			endm  
# End of macro DMARK
49c2					CALLMONITOR 
49c2 cd 7e 16			call break_point_state  
49c5				endm  
# End of macro CALLMONITOR
49c5				endif 
49c5			;		push hl 
49c5			;		FORTH_DSP_POP 
49c5			;		pop hl 
49c5			 
49c5			;		inc hl   ; move past the type marker 
49c5			 
49c5 cd e2 06				call storage_create 
49c8			 
49c8				if DEBUG_STORESE 
49c8					DMARK "CT1" 
49c8 f5				push af  
49c9 3a dd 49			ld a, (.dmark)  
49cc 32 b4 fb			ld (debug_mark),a  
49cf 3a de 49			ld a, (.dmark+1)  
49d2 32 b5 fb			ld (debug_mark+1),a  
49d5 3a df 49			ld a, (.dmark+2)  
49d8 32 b6 fb			ld (debug_mark+2),a  
49db 18 03			jr .pastdmark  
49dd ..			.dmark: db "CT1"  
49e0 f1			.pastdmark: pop af  
49e1			endm  
# End of macro DMARK
49e1					CALLMONITOR 
49e1 cd 7e 16			call break_point_state  
49e4				endm  
# End of macro CALLMONITOR
49e4				endif 
49e4			;		push hl 
49e4					FORTH_DSP_POP 
49e4 cd 8a 1f			call macro_forth_dsp_pop 
49e7				endm 
# End of macro FORTH_DSP_POP
49e7			;		pop hl 
49e7					; push file id to stack 
49e7 cd db 1c				call forth_push_numhl 
49ea			 
49ea			 
49ea			 
49ea				       NEXTW 
49ea c3 44 20			jp macro_next 
49ed				endm 
# End of macro NEXTW
49ed			 
49ed			.APPEND: 
49ed				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
49ed 69				db WORD_SYS_CORE+85             
49ee 7e 4a			dw .SDEL            
49f0 07				db 6 + 1 
49f1 .. 00			db "APPEND",0              
49f8				endm 
# End of macro CWHEAD
49f8			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
49f8			; | | e.g. 
49f8			; | | Test CREATE      -> $01 
49f8			; | | "A string to add to file" $01 APPEND 
49f8			; | |  
49f8			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
49f8					if DEBUG_FORTH_WORDS_KEY 
49f8						DMARK "APP" 
49f8 f5				push af  
49f9 3a 0d 4a			ld a, (.dmark)  
49fc 32 b4 fb			ld (debug_mark),a  
49ff 3a 0e 4a			ld a, (.dmark+1)  
4a02 32 b5 fb			ld (debug_mark+1),a  
4a05 3a 0f 4a			ld a, (.dmark+2)  
4a08 32 b6 fb			ld (debug_mark+2),a  
4a0b 18 03			jr .pastdmark  
4a0d ..			.dmark: db "APP"  
4a10 f1			.pastdmark: pop af  
4a11			endm  
# End of macro DMARK
4a11						CALLMONITOR 
4a11 cd 7e 16			call break_point_state  
4a14				endm  
# End of macro CALLMONITOR
4a14					endif 
4a14			 
4a14					FORTH_DSP_VALUEHL 
4a14 cd d2 1e			call macro_dsp_valuehl 
4a17				endm 
# End of macro FORTH_DSP_VALUEHL
4a17 e5					push hl 	; save file id 
4a18			 
4a18				if DEBUG_STORESE 
4a18					DMARK "AP1" 
4a18 f5				push af  
4a19 3a 2d 4a			ld a, (.dmark)  
4a1c 32 b4 fb			ld (debug_mark),a  
4a1f 3a 2e 4a			ld a, (.dmark+1)  
4a22 32 b5 fb			ld (debug_mark+1),a  
4a25 3a 2f 4a			ld a, (.dmark+2)  
4a28 32 b6 fb			ld (debug_mark+2),a  
4a2b 18 03			jr .pastdmark  
4a2d ..			.dmark: db "AP1"  
4a30 f1			.pastdmark: pop af  
4a31			endm  
# End of macro DMARK
4a31					CALLMONITOR 
4a31 cd 7e 16			call break_point_state  
4a34				endm  
# End of macro CALLMONITOR
4a34				endif 
4a34					FORTH_DSP_POP 
4a34 cd 8a 1f			call macro_forth_dsp_pop 
4a37				endm 
# End of macro FORTH_DSP_POP
4a37			 
4a37					FORTH_DSP_VALUEHL 
4a37 cd d2 1e			call macro_dsp_valuehl 
4a3a				endm 
# End of macro FORTH_DSP_VALUEHL
4a3a					;v5 FORTH_DSP_VALUE 
4a3a e5					push hl 	; save ptr to string to save 
4a3b			 
4a3b				if DEBUG_STORESE 
4a3b					DMARK "AP1" 
4a3b f5				push af  
4a3c 3a 50 4a			ld a, (.dmark)  
4a3f 32 b4 fb			ld (debug_mark),a  
4a42 3a 51 4a			ld a, (.dmark+1)  
4a45 32 b5 fb			ld (debug_mark+1),a  
4a48 3a 52 4a			ld a, (.dmark+2)  
4a4b 32 b6 fb			ld (debug_mark+2),a  
4a4e 18 03			jr .pastdmark  
4a50 ..			.dmark: db "AP1"  
4a53 f1			.pastdmark: pop af  
4a54			endm  
# End of macro DMARK
4a54					CALLMONITOR 
4a54 cd 7e 16			call break_point_state  
4a57				endm  
# End of macro CALLMONITOR
4a57				endif 
4a57					FORTH_DSP_POP 
4a57 cd 8a 1f			call macro_forth_dsp_pop 
4a5a				endm 
# End of macro FORTH_DSP_POP
4a5a			 
4a5a d1					pop de 
4a5b e1					pop hl 
4a5c				if DEBUG_STORESE 
4a5c					DMARK "AP2" 
4a5c f5				push af  
4a5d 3a 71 4a			ld a, (.dmark)  
4a60 32 b4 fb			ld (debug_mark),a  
4a63 3a 72 4a			ld a, (.dmark+1)  
4a66 32 b5 fb			ld (debug_mark+1),a  
4a69 3a 73 4a			ld a, (.dmark+2)  
4a6c 32 b6 fb			ld (debug_mark+2),a  
4a6f 18 03			jr .pastdmark  
4a71 ..			.dmark: db "AP2"  
4a74 f1			.pastdmark: pop af  
4a75			endm  
# End of macro DMARK
4a75					CALLMONITOR 
4a75 cd 7e 16			call break_point_state  
4a78				endm  
# End of macro CALLMONITOR
4a78				endif 
4a78					;inc de ; skip var type indicator 
4a78			 
4a78					; TODO how to append numerics???? 
4a78			 
4a78 cd c1 08				call storage_append		 
4a7b			 
4a7b				       NEXTW 
4a7b c3 44 20			jp macro_next 
4a7e				endm 
# End of macro NEXTW
4a7e			.SDEL: 
4a7e				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a7e 6a				db WORD_SYS_CORE+86             
4a7f ca 4a			dw .OPEN            
4a81 05				db 4 + 1 
4a82 .. 00			db "ERA",0              
4a86				endm 
# End of macro CWHEAD
4a86			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a86					FORTH_DSP_VALUEHL 
4a86 cd d2 1e			call macro_dsp_valuehl 
4a89				endm 
# End of macro FORTH_DSP_VALUEHL
4a89			;		push hl 	; save file id 
4a89			 
4a89					if DEBUG_FORTH_WORDS_KEY 
4a89						DMARK "ERA" 
4a89 f5				push af  
4a8a 3a 9e 4a			ld a, (.dmark)  
4a8d 32 b4 fb			ld (debug_mark),a  
4a90 3a 9f 4a			ld a, (.dmark+1)  
4a93 32 b5 fb			ld (debug_mark+1),a  
4a96 3a a0 4a			ld a, (.dmark+2)  
4a99 32 b6 fb			ld (debug_mark+2),a  
4a9c 18 03			jr .pastdmark  
4a9e ..			.dmark: db "ERA"  
4aa1 f1			.pastdmark: pop af  
4aa2			endm  
# End of macro DMARK
4aa2						CALLMONITOR 
4aa2 cd 7e 16			call break_point_state  
4aa5				endm  
# End of macro CALLMONITOR
4aa5					endif 
4aa5				if DEBUG_STORESE 
4aa5					DMARK "ER1" 
4aa5 f5				push af  
4aa6 3a ba 4a			ld a, (.dmark)  
4aa9 32 b4 fb			ld (debug_mark),a  
4aac 3a bb 4a			ld a, (.dmark+1)  
4aaf 32 b5 fb			ld (debug_mark+1),a  
4ab2 3a bc 4a			ld a, (.dmark+2)  
4ab5 32 b6 fb			ld (debug_mark+2),a  
4ab8 18 03			jr .pastdmark  
4aba ..			.dmark: db "ER1"  
4abd f1			.pastdmark: pop af  
4abe			endm  
# End of macro DMARK
4abe					CALLMONITOR 
4abe cd 7e 16			call break_point_state  
4ac1				endm  
# End of macro CALLMONITOR
4ac1				endif 
4ac1					FORTH_DSP_POP 
4ac1 cd 8a 1f			call macro_forth_dsp_pop 
4ac4				endm 
# End of macro FORTH_DSP_POP
4ac4			 
4ac4			;		pop hl 
4ac4			 
4ac4 cd 21 05				call storage_erase 
4ac7				       NEXTW 
4ac7 c3 44 20			jp macro_next 
4aca				endm 
# End of macro NEXTW
4aca			 
4aca			.OPEN: 
4aca				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4aca 6b				db WORD_SYS_CORE+87             
4acb 5a 4b			dw .READ            
4acd 05				db 4 + 1 
4ace .. 00			db "OPEN",0              
4ad3				endm 
# End of macro CWHEAD
4ad3			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4ad3			; | | e.g. 
4ad3			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ad3			; | | 
4ad3			; | | Will return with 255 blocks if the file does not exist 
4ad3			 
4ad3					if DEBUG_FORTH_WORDS_KEY 
4ad3						DMARK "OPN" 
4ad3 f5				push af  
4ad4 3a e8 4a			ld a, (.dmark)  
4ad7 32 b4 fb			ld (debug_mark),a  
4ada 3a e9 4a			ld a, (.dmark+1)  
4add 32 b5 fb			ld (debug_mark+1),a  
4ae0 3a ea 4a			ld a, (.dmark+2)  
4ae3 32 b6 fb			ld (debug_mark+2),a  
4ae6 18 03			jr .pastdmark  
4ae8 ..			.dmark: db "OPN"  
4aeb f1			.pastdmark: pop af  
4aec			endm  
# End of macro DMARK
4aec						CALLMONITOR 
4aec cd 7e 16			call break_point_state  
4aef				endm  
# End of macro CALLMONITOR
4aef					endif 
4aef					; TODO handle multiple file opens 
4aef			 
4aef 3e 01			       	ld a, 1 
4af1 32 d6 f9				ld (store_openext), a 
4af4			 
4af4					; get max extents for this file 
4af4				 
4af4								 
4af4					FORTH_DSP_VALUEHL 
4af4 cd d2 1e			call macro_dsp_valuehl 
4af7				endm 
# End of macro FORTH_DSP_VALUEHL
4af7			 
4af7 65					ld h, l 
4af8 2e 00				ld l, 0 
4afa			 
4afa				if DEBUG_STORESE 
4afa					DMARK "OPN" 
4afa f5				push af  
4afb 3a 0f 4b			ld a, (.dmark)  
4afe 32 b4 fb			ld (debug_mark),a  
4b01 3a 10 4b			ld a, (.dmark+1)  
4b04 32 b5 fb			ld (debug_mark+1),a  
4b07 3a 11 4b			ld a, (.dmark+2)  
4b0a 32 b6 fb			ld (debug_mark+2),a  
4b0d 18 03			jr .pastdmark  
4b0f ..			.dmark: db "OPN"  
4b12 f1			.pastdmark: pop af  
4b13			endm  
# End of macro DMARK
4b13					CALLMONITOR 
4b13 cd 7e 16			call break_point_state  
4b16				endm  
# End of macro CALLMONITOR
4b16				endif 
4b16			;		push hl 
4b16					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b16 cd 8a 1f			call macro_forth_dsp_pop 
4b19				endm 
# End of macro FORTH_DSP_POP
4b19			;		pop hl 
4b19						 
4b19 11 df f9				ld de, store_page      ; get block zero of file 
4b1c cd 38 08				call storage_read 
4b1f cd 2a 0d			call ishlzero 
4b22 20 04			jr nz, .opfound 
4b24			 
4b24				; file does not exist so indicate with 255 extents in use 
4b24			 
4b24 3e ff			ld a, 255 
4b26 18 29			jr .skipopeneof 
4b28			 
4b28			 
4b28			.opfound: 
4b28			 
4b28			 
4b28 3a e1 f9				ld a, (store_page+2)    ; max extents for this file 
4b2b 32 d5 f9				ld  (store_openmaxext), a   ; get our limit and push 
4b2e					 
4b2e				if DEBUG_STORESE 
4b2e					DMARK "OPx" 
4b2e f5				push af  
4b2f 3a 43 4b			ld a, (.dmark)  
4b32 32 b4 fb			ld (debug_mark),a  
4b35 3a 44 4b			ld a, (.dmark+1)  
4b38 32 b5 fb			ld (debug_mark+1),a  
4b3b 3a 45 4b			ld a, (.dmark+2)  
4b3e 32 b6 fb			ld (debug_mark+2),a  
4b41 18 03			jr .pastdmark  
4b43 ..			.dmark: db "OPx"  
4b46 f1			.pastdmark: pop af  
4b47			endm  
# End of macro DMARK
4b47					CALLMONITOR 
4b47 cd 7e 16			call break_point_state  
4b4a				endm  
# End of macro CALLMONITOR
4b4a				endif 
4b4a fe 00				cp 0 
4b4c 20 03				jr nz, .skipopeneof 
4b4e					; have opened an empty file 
4b4e					 
4b4e 32 d6 f9				ld (store_openext), a 
4b51			 
4b51			.skipopeneof: 
4b51			 
4b51 6f					ld l, a 
4b52 26 00				ld h, 0 
4b54 cd db 1c				call forth_push_numhl 
4b57			 
4b57			 
4b57				       NEXTW 
4b57 c3 44 20			jp macro_next 
4b5a				endm 
# End of macro NEXTW
4b5a			.READ: 
4b5a				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b5a 6c				db WORD_SYS_CORE+88             
4b5b a1 4c			dw .EOF            
4b5d 05				db 4 + 1 
4b5e .. 00			db "READ",0              
4b63				endm 
# End of macro CWHEAD
4b63			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b63			; | | e.g. 
4b63			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b63			 
4b63					if DEBUG_FORTH_WORDS_KEY 
4b63						DMARK "REA" 
4b63 f5				push af  
4b64 3a 78 4b			ld a, (.dmark)  
4b67 32 b4 fb			ld (debug_mark),a  
4b6a 3a 79 4b			ld a, (.dmark+1)  
4b6d 32 b5 fb			ld (debug_mark+1),a  
4b70 3a 7a 4b			ld a, (.dmark+2)  
4b73 32 b6 fb			ld (debug_mark+2),a  
4b76 18 03			jr .pastdmark  
4b78 ..			.dmark: db "REA"  
4b7b f1			.pastdmark: pop af  
4b7c			endm  
# End of macro DMARK
4b7c						CALLMONITOR 
4b7c cd 7e 16			call break_point_state  
4b7f				endm  
# End of macro CALLMONITOR
4b7f					endif 
4b7f					; store_openext use it. If zero it is EOF 
4b7f			 
4b7f					; read block from current stream id 
4b7f					; if the block does not contain zero term keep reading blocks until zero found 
4b7f					; push the block to stack 
4b7f					; save the block id to stream 
4b7f			 
4b7f			 
4b7f					FORTH_DSP_VALUEHL 
4b7f cd d2 1e			call macro_dsp_valuehl 
4b82				endm 
# End of macro FORTH_DSP_VALUEHL
4b82			 
4b82			;		push hl 
4b82			 
4b82				if DEBUG_STORESE 
4b82					DMARK "REA" 
4b82 f5				push af  
4b83 3a 97 4b			ld a, (.dmark)  
4b86 32 b4 fb			ld (debug_mark),a  
4b89 3a 98 4b			ld a, (.dmark+1)  
4b8c 32 b5 fb			ld (debug_mark+1),a  
4b8f 3a 99 4b			ld a, (.dmark+2)  
4b92 32 b6 fb			ld (debug_mark+2),a  
4b95 18 03			jr .pastdmark  
4b97 ..			.dmark: db "REA"  
4b9a f1			.pastdmark: pop af  
4b9b			endm  
# End of macro DMARK
4b9b					CALLMONITOR 
4b9b cd 7e 16			call break_point_state  
4b9e				endm  
# End of macro CALLMONITOR
4b9e				endif 
4b9e					FORTH_DSP_POP 
4b9e cd 8a 1f			call macro_forth_dsp_pop 
4ba1				endm 
# End of macro FORTH_DSP_POP
4ba1			 
4ba1			;		pop hl 
4ba1				 
4ba1 65					ld h,l 
4ba2			 
4ba2 3a d6 f9				ld a, (store_openext) 
4ba5 6f					ld l, a 
4ba6					 
4ba6 fe 00				cp 0 
4ba8 ca 73 4c				jp z, .ateof     ; dont read past eof 
4bab			 
4bab			 
4bab 11 df f9				ld de, store_page 
4bae				if DEBUG_STORESE 
4bae					DMARK "RE1" 
4bae f5				push af  
4baf 3a c3 4b			ld a, (.dmark)  
4bb2 32 b4 fb			ld (debug_mark),a  
4bb5 3a c4 4b			ld a, (.dmark+1)  
4bb8 32 b5 fb			ld (debug_mark+1),a  
4bbb 3a c5 4b			ld a, (.dmark+2)  
4bbe 32 b6 fb			ld (debug_mark+2),a  
4bc1 18 03			jr .pastdmark  
4bc3 ..			.dmark: db "RE1"  
4bc6 f1			.pastdmark: pop af  
4bc7			endm  
# End of macro DMARK
4bc7					CALLMONITOR 
4bc7 cd 7e 16			call break_point_state  
4bca				endm  
# End of macro CALLMONITOR
4bca				endif 
4bca cd 38 08				call storage_read 
4bcd			 
4bcd				if DEBUG_STORESE 
4bcd					DMARK "RE2" 
4bcd f5				push af  
4bce 3a e2 4b			ld a, (.dmark)  
4bd1 32 b4 fb			ld (debug_mark),a  
4bd4 3a e3 4b			ld a, (.dmark+1)  
4bd7 32 b5 fb			ld (debug_mark+1),a  
4bda 3a e4 4b			ld a, (.dmark+2)  
4bdd 32 b6 fb			ld (debug_mark+2),a  
4be0 18 03			jr .pastdmark  
4be2 ..			.dmark: db "RE2"  
4be5 f1			.pastdmark: pop af  
4be6			endm  
# End of macro DMARK
4be6					CALLMONITOR 
4be6 cd 7e 16			call break_point_state  
4be9				endm  
# End of macro CALLMONITOR
4be9				endif 
4be9 cd 2a 0d			call ishlzero 
4bec			;	ld a, l 
4bec			;	add h 
4bec			;	cp 0 
4bec ca 79 4c			jp z, .readeof 
4bef			 
4bef				; not eof so hl should point to data to push to stack 
4bef			 
4bef				if DEBUG_STORESE 
4bef					DMARK "RE3" 
4bef f5				push af  
4bf0 3a 04 4c			ld a, (.dmark)  
4bf3 32 b4 fb			ld (debug_mark),a  
4bf6 3a 05 4c			ld a, (.dmark+1)  
4bf9 32 b5 fb			ld (debug_mark+1),a  
4bfc 3a 06 4c			ld a, (.dmark+2)  
4bff 32 b6 fb			ld (debug_mark+2),a  
4c02 18 03			jr .pastdmark  
4c04 ..			.dmark: db "RE3"  
4c07 f1			.pastdmark: pop af  
4c08			endm  
# End of macro DMARK
4c08					CALLMONITOR 
4c08 cd 7e 16			call break_point_state  
4c0b				endm  
# End of macro CALLMONITOR
4c0b				endif 
4c0b cd 49 1d			call forth_push_str 
4c0e			 
4c0e				if DEBUG_STORESE 
4c0e					DMARK "RE4" 
4c0e f5				push af  
4c0f 3a 23 4c			ld a, (.dmark)  
4c12 32 b4 fb			ld (debug_mark),a  
4c15 3a 24 4c			ld a, (.dmark+1)  
4c18 32 b5 fb			ld (debug_mark+1),a  
4c1b 3a 25 4c			ld a, (.dmark+2)  
4c1e 32 b6 fb			ld (debug_mark+2),a  
4c21 18 03			jr .pastdmark  
4c23 ..			.dmark: db "RE4"  
4c26 f1			.pastdmark: pop af  
4c27			endm  
# End of macro DMARK
4c27					CALLMONITOR 
4c27 cd 7e 16			call break_point_state  
4c2a				endm  
# End of macro CALLMONITOR
4c2a				endif 
4c2a				; get next block  or mark as eof 
4c2a			 
4c2a 3a d5 f9			ld a, (store_openmaxext)   ; get our limit 
4c2d 4f				ld c, a	 
4c2e 3a d6 f9			ld a, (store_openext) 
4c31			 
4c31				if DEBUG_STORESE 
4c31					DMARK "RE5" 
4c31 f5				push af  
4c32 3a 46 4c			ld a, (.dmark)  
4c35 32 b4 fb			ld (debug_mark),a  
4c38 3a 47 4c			ld a, (.dmark+1)  
4c3b 32 b5 fb			ld (debug_mark+1),a  
4c3e 3a 48 4c			ld a, (.dmark+2)  
4c41 32 b6 fb			ld (debug_mark+2),a  
4c44 18 03			jr .pastdmark  
4c46 ..			.dmark: db "RE5"  
4c49 f1			.pastdmark: pop af  
4c4a			endm  
# End of macro DMARK
4c4a					CALLMONITOR 
4c4a cd 7e 16			call break_point_state  
4c4d				endm  
# End of macro CALLMONITOR
4c4d				endif 
4c4d b9				cp c 
4c4e 28 29			jr z, .readeof     ; at last extent 
4c50			 
4c50 3c					inc a 
4c51 32 d6 f9				ld (store_openext), a 
4c54			 
4c54				if DEBUG_STORESE 
4c54					DMARK "RE6" 
4c54 f5				push af  
4c55 3a 69 4c			ld a, (.dmark)  
4c58 32 b4 fb			ld (debug_mark),a  
4c5b 3a 6a 4c			ld a, (.dmark+1)  
4c5e 32 b5 fb			ld (debug_mark+1),a  
4c61 3a 6b 4c			ld a, (.dmark+2)  
4c64 32 b6 fb			ld (debug_mark+2),a  
4c67 18 03			jr .pastdmark  
4c69 ..			.dmark: db "RE6"  
4c6c f1			.pastdmark: pop af  
4c6d			endm  
# End of macro DMARK
4c6d					CALLMONITOR 
4c6d cd 7e 16			call break_point_state  
4c70				endm  
# End of macro CALLMONITOR
4c70				endif 
4c70			 
4c70			 
4c70				       NEXTW 
4c70 c3 44 20			jp macro_next 
4c73				endm 
# End of macro NEXTW
4c73			.ateof: 
4c73 21 9d 4c				ld hl, .showeof 
4c76 cd 49 1d				call forth_push_str 
4c79 3e 00		.readeof:	ld a, 0 
4c7b 32 d6 f9				ld (store_openext), a 
4c7e			 
4c7e					 
4c7e				if DEBUG_STORESE 
4c7e					DMARK "REF" 
4c7e f5				push af  
4c7f 3a 93 4c			ld a, (.dmark)  
4c82 32 b4 fb			ld (debug_mark),a  
4c85 3a 94 4c			ld a, (.dmark+1)  
4c88 32 b5 fb			ld (debug_mark+1),a  
4c8b 3a 95 4c			ld a, (.dmark+2)  
4c8e 32 b6 fb			ld (debug_mark+2),a  
4c91 18 03			jr .pastdmark  
4c93 ..			.dmark: db "REF"  
4c96 f1			.pastdmark: pop af  
4c97			endm  
# End of macro DMARK
4c97					CALLMONITOR 
4c97 cd 7e 16			call break_point_state  
4c9a				endm  
# End of macro CALLMONITOR
4c9a				endif 
4c9a				       NEXTW 
4c9a c3 44 20			jp macro_next 
4c9d				endm 
# End of macro NEXTW
4c9d			 
4c9d .. 00		.showeof:   db "eof", 0 
4ca1			 
4ca1			 
4ca1			.EOF: 
4ca1				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4ca1 6d				db WORD_SYS_CORE+89             
4ca2 e2 4c			dw .FORMAT            
4ca4 04				db 3 + 1 
4ca5 .. 00			db "EOF",0              
4ca9				endm 
# End of macro CWHEAD
4ca9			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4ca9			; | | e.g. 
4ca9			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4ca9					; TODO if current block id for stream is zero then push true else false 
4ca9			 
4ca9					if DEBUG_FORTH_WORDS_KEY 
4ca9						DMARK "EOF" 
4ca9 f5				push af  
4caa 3a be 4c			ld a, (.dmark)  
4cad 32 b4 fb			ld (debug_mark),a  
4cb0 3a bf 4c			ld a, (.dmark+1)  
4cb3 32 b5 fb			ld (debug_mark+1),a  
4cb6 3a c0 4c			ld a, (.dmark+2)  
4cb9 32 b6 fb			ld (debug_mark+2),a  
4cbc 18 03			jr .pastdmark  
4cbe ..			.dmark: db "EOF"  
4cc1 f1			.pastdmark: pop af  
4cc2			endm  
# End of macro DMARK
4cc2						CALLMONITOR 
4cc2 cd 7e 16			call break_point_state  
4cc5				endm  
# End of macro CALLMONITOR
4cc5					endif 
4cc5			 
4cc5					; TODO handlue multiple file streams 
4cc5			 
4cc5					FORTH_DSP_POP     ; for now just get rid of stream id 
4cc5 cd 8a 1f			call macro_forth_dsp_pop 
4cc8				endm 
# End of macro FORTH_DSP_POP
4cc8			 
4cc8 2e 01				ld l, 1 
4cca 3a d5 f9				ld a, (store_openmaxext) 
4ccd fe 00				cp 0 
4ccf 28 09				jr  z, .eofdone   ; empty file 
4cd1 3a d6 f9				ld a, (store_openext) 
4cd4 fe 00				cp 0 
4cd6 28 02				jr  z, .eofdone 
4cd8 2e 00				ld l, 0 
4cda 26 00		.eofdone:	ld h, 0 
4cdc cd db 1c				call forth_push_numhl 
4cdf			 
4cdf			 
4cdf				       NEXTW 
4cdf c3 44 20			jp macro_next 
4ce2				endm 
# End of macro NEXTW
4ce2			 
4ce2			.FORMAT: 
4ce2				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4ce2 6d				db WORD_SYS_CORE+89             
4ce3 33 4d			dw .LABEL            
4ce5 07				db 6 + 1 
4ce6 .. 00			db "FORMAT",0              
4ced				endm 
# End of macro CWHEAD
4ced			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4ced					; TODO if current block id for stream is zero then push true else false 
4ced				 
4ced				if DEBUG_STORESE 
4ced					DMARK "FOR" 
4ced f5				push af  
4cee 3a 02 4d			ld a, (.dmark)  
4cf1 32 b4 fb			ld (debug_mark),a  
4cf4 3a 03 4d			ld a, (.dmark+1)  
4cf7 32 b5 fb			ld (debug_mark+1),a  
4cfa 3a 04 4d			ld a, (.dmark+2)  
4cfd 32 b6 fb			ld (debug_mark+2),a  
4d00 18 03			jr .pastdmark  
4d02 ..			.dmark: db "FOR"  
4d05 f1			.pastdmark: pop af  
4d06			endm  
# End of macro DMARK
4d06					CALLMONITOR 
4d06 cd 7e 16			call break_point_state  
4d09				endm  
# End of macro CALLMONITOR
4d09				endif 
4d09					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d09			 
4d09 21 01 00				ld hl, 1 
4d0c 3e 00				ld a, 0 
4d0e cd bd 01				call se_writebyte 
4d11			 
4d11				if DEBUG_STORESE 
4d11					DMARK "FO0" 
4d11 f5				push af  
4d12 3a 26 4d			ld a, (.dmark)  
4d15 32 b4 fb			ld (debug_mark),a  
4d18 3a 27 4d			ld a, (.dmark+1)  
4d1b 32 b5 fb			ld (debug_mark+1),a  
4d1e 3a 28 4d			ld a, (.dmark+2)  
4d21 32 b6 fb			ld (debug_mark+2),a  
4d24 18 03			jr .pastdmark  
4d26 ..			.dmark: db "FO0"  
4d29 f1			.pastdmark: pop af  
4d2a			endm  
# End of macro DMARK
4d2a					CALLMONITOR 
4d2a cd 7e 16			call break_point_state  
4d2d				endm  
# End of macro CALLMONITOR
4d2d				endif 
4d2d					; force bank init 
4d2d			 
4d2d cd 90 03				call storage_get_block_0 
4d30					 
4d30				       NEXTW 
4d30 c3 44 20			jp macro_next 
4d33				endm 
# End of macro NEXTW
4d33			.LABEL: 
4d33				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d33 6d				db WORD_SYS_CORE+89             
4d34 81 4d			dw .STOREPAGE            
4d36 06				db 5 + 1 
4d37 .. 00			db "LABEL",0              
4d3d				endm 
# End of macro CWHEAD
4d3d			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d3d					; TODO test to see if bank is selected 
4d3d				 
4d3d					if DEBUG_FORTH_WORDS_KEY 
4d3d						DMARK "LBL" 
4d3d f5				push af  
4d3e 3a 52 4d			ld a, (.dmark)  
4d41 32 b4 fb			ld (debug_mark),a  
4d44 3a 53 4d			ld a, (.dmark+1)  
4d47 32 b5 fb			ld (debug_mark+1),a  
4d4a 3a 54 4d			ld a, (.dmark+2)  
4d4d 32 b6 fb			ld (debug_mark+2),a  
4d50 18 03			jr .pastdmark  
4d52 ..			.dmark: db "LBL"  
4d55 f1			.pastdmark: pop af  
4d56			endm  
# End of macro DMARK
4d56						CALLMONITOR 
4d56 cd 7e 16			call break_point_state  
4d59				endm  
# End of macro CALLMONITOR
4d59					endif 
4d59			;	if DEBUG_STORESE 
4d59			;		DMARK "LBL" 
4d59			;		CALLMONITOR 
4d59			;	endif 
4d59					FORTH_DSP_VALUEHL 
4d59 cd d2 1e			call macro_dsp_valuehl 
4d5c				endm 
# End of macro FORTH_DSP_VALUEHL
4d5c					;v5FORTH_DSP_VALUE 
4d5c					 
4d5c			;		push hl 
4d5c					FORTH_DSP_POP 
4d5c cd 8a 1f			call macro_forth_dsp_pop 
4d5f				endm 
# End of macro FORTH_DSP_POP
4d5f			;		pop hl 
4d5f			 
4d5f			;v5		inc hl   ; move past the type marker 
4d5f			 
4d5f				if DEBUG_STORESE 
4d5f					DMARK "LBl" 
4d5f f5				push af  
4d60 3a 74 4d			ld a, (.dmark)  
4d63 32 b4 fb			ld (debug_mark),a  
4d66 3a 75 4d			ld a, (.dmark+1)  
4d69 32 b5 fb			ld (debug_mark+1),a  
4d6c 3a 76 4d			ld a, (.dmark+2)  
4d6f 32 b6 fb			ld (debug_mark+2),a  
4d72 18 03			jr .pastdmark  
4d74 ..			.dmark: db "LBl"  
4d77 f1			.pastdmark: pop af  
4d78			endm  
# End of macro DMARK
4d78					CALLMONITOR 
4d78 cd 7e 16			call break_point_state  
4d7b				endm  
# End of macro CALLMONITOR
4d7b				endif 
4d7b cd b4 04				call storage_label 
4d7e			 
4d7e				       NEXTW 
4d7e c3 44 20			jp macro_next 
4d81				endm 
# End of macro NEXTW
4d81			.STOREPAGE: 
4d81				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d81 6d				db WORD_SYS_CORE+89             
4d82 b4 4d			dw .LABELS            
4d84 0a				db 9 + 1 
4d85 .. 00			db "STOREPAGE",0              
4d8f				endm 
# End of macro CWHEAD
4d8f			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d8f					; TODO test to see if bank is selected 
4d8f				 
4d8f					if DEBUG_FORTH_WORDS_KEY 
4d8f						DMARK "STP" 
4d8f f5				push af  
4d90 3a a4 4d			ld a, (.dmark)  
4d93 32 b4 fb			ld (debug_mark),a  
4d96 3a a5 4d			ld a, (.dmark+1)  
4d99 32 b5 fb			ld (debug_mark+1),a  
4d9c 3a a6 4d			ld a, (.dmark+2)  
4d9f 32 b6 fb			ld (debug_mark+2),a  
4da2 18 03			jr .pastdmark  
4da4 ..			.dmark: db "STP"  
4da7 f1			.pastdmark: pop af  
4da8			endm  
# End of macro DMARK
4da8						CALLMONITOR 
4da8 cd 7e 16			call break_point_state  
4dab				endm  
# End of macro CALLMONITOR
4dab					endif 
4dab			;	if DEBUG_STORESE 
4dab			;		DMARK "STP" 
4dab			;		CALLMONITOR 
4dab			;	endif 
4dab			 
4dab 21 df f9			ld hl, store_page 
4dae cd db 1c			call forth_push_numhl 
4db1			 
4db1			 
4db1				       NEXTW 
4db1 c3 44 20			jp macro_next 
4db4				endm 
# End of macro NEXTW
4db4			.LABELS: 
4db4				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4db4 6d				db WORD_SYS_CORE+89             
4db5 3e 4e			dw .ENDSTORAGE            
4db7 07				db 6 + 1 
4db8 .. 00			db "LABELS",0              
4dbf				endm 
# End of macro CWHEAD
4dbf			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dbf					;  
4dbf			 
4dbf					; save the current device selected to restore afterwards 
4dbf				 
4dbf 3a c5 f9				ld a, (spi_device) 
4dc2 f5					push af 
4dc3			 
4dc3			 
4dc3					; run through each of the banks 
4dc3			 
4dc3 21 01 00				ld hl, 1 
4dc6 cd db 1c				call forth_push_numhl 
4dc9 3e ff				ld a, SPI_CE_HIGH 
4dcb cb 87				res SPI_CE0, a 
4dcd 32 c5 f9				ld (spi_device), a 
4dd0 cd 90 03				call storage_get_block_0 
4dd3 21 e2 f9				ld hl, store_page+3 
4dd6 cd 49 1d				call forth_push_str 
4dd9			 
4dd9					 
4dd9 21 02 00				ld hl, 2 
4ddc cd db 1c				call forth_push_numhl 
4ddf 3e ff				ld a, SPI_CE_HIGH 
4de1 cb 8f				res SPI_CE1, a 
4de3 32 c5 f9				ld (spi_device), a 
4de6 cd 90 03				call storage_get_block_0 
4de9 21 e2 f9				ld hl, store_page+3 
4dec cd 49 1d				call forth_push_str 
4def			 
4def					 
4def 21 03 00				ld hl, 3 
4df2 cd db 1c				call forth_push_numhl 
4df5 3e ff				ld a, SPI_CE_HIGH 
4df7 cb 97				res SPI_CE2, a 
4df9 32 c5 f9				ld (spi_device), a 
4dfc cd 90 03				call storage_get_block_0 
4dff 21 e2 f9				ld hl, store_page+3 
4e02 cd 49 1d				call forth_push_str 
4e05			 
4e05			 
4e05 21 04 00				ld hl, 4 
4e08 cd db 1c				call forth_push_numhl 
4e0b 3e ff				ld a, SPI_CE_HIGH 
4e0d cb 9f				res SPI_CE3, a 
4e0f 32 c5 f9				ld (spi_device), a 
4e12 cd 90 03				call storage_get_block_0 
4e15 21 e2 f9				ld hl, store_page+3 
4e18 cd 49 1d				call forth_push_str 
4e1b			 
4e1b					 
4e1b			 
4e1b 21 05 00				ld hl, 5 
4e1e cd db 1c				call forth_push_numhl 
4e21 3e ff				ld a, SPI_CE_HIGH 
4e23 cb a7				res SPI_CE4, a 
4e25 32 c5 f9				ld (spi_device), a 
4e28 cd 90 03				call storage_get_block_0 
4e2b 21 e2 f9				ld hl, store_page+3 
4e2e cd 49 1d				call forth_push_str 
4e31			 
4e31					 
4e31					; push fixed count of storage devices (on board) for now 
4e31			 
4e31 21 05 00				ld hl, 5 
4e34 cd db 1c				call forth_push_numhl 
4e37			 
4e37					; restore selected device  
4e37				 
4e37 f1					pop af 
4e38 32 c5 f9				ld (spi_device), a 
4e3b			 
4e3b				       NEXTW 
4e3b c3 44 20			jp macro_next 
4e3e				endm 
# End of macro NEXTW
4e3e			 
4e3e			.ENDSTORAGE: 
4e3e			; eof 
# End of file forth_words_storage.asm
4e3e			endif 
4e3e				include "forth_words_device.asm" 
4e3e			; Device related words 
4e3e			 
4e3e			; | ## Device Words 
4e3e			 
4e3e			if SOUND_ENABLE 
4e3e			.NOTE: 
4e3e				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e3e			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e3e					if DEBUG_FORTH_WORDS_KEY 
4e3e						DMARK "NTE" 
4e3e						CALLMONITOR 
4e3e					endif 
4e3e			 
4e3e				 
4e3e			 
4e3e					NEXTW 
4e3e			.AFTERSOUND: 
4e3e			endif 
4e3e			 
4e3e			 
4e3e			USE_GPIO: equ 0 
4e3e			 
4e3e			if USE_GPIO 
4e3e			.GP1: 
4e3e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e3e			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e3e					NEXTW 
4e3e			.GP2: 
4e3e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e3e			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e3e			 
4e3e					NEXTW 
4e3e			 
4e3e			.GP3: 
4e3e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e3e			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e3e			 
4e3e					NEXTW 
4e3e			 
4e3e			.GP4: 
4e3e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e3e			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e3e			 
4e3e					NEXTW 
4e3e			.SIN: 
4e3e			 
4e3e			 
4e3e			endif 
4e3e			 
4e3e			 
4e3e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e3e 33				db WORD_SYS_CORE+31             
4e3f 73 4e			dw .SOUT            
4e41 03				db 2 + 1 
4e42 .. 00			db "IN",0              
4e45				endm 
# End of macro CWHEAD
4e45			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e45					if DEBUG_FORTH_WORDS_KEY 
4e45						DMARK "IN." 
4e45 f5				push af  
4e46 3a 5a 4e			ld a, (.dmark)  
4e49 32 b4 fb			ld (debug_mark),a  
4e4c 3a 5b 4e			ld a, (.dmark+1)  
4e4f 32 b5 fb			ld (debug_mark+1),a  
4e52 3a 5c 4e			ld a, (.dmark+2)  
4e55 32 b6 fb			ld (debug_mark+2),a  
4e58 18 03			jr .pastdmark  
4e5a ..			.dmark: db "IN."  
4e5d f1			.pastdmark: pop af  
4e5e			endm  
# End of macro DMARK
4e5e						CALLMONITOR 
4e5e cd 7e 16			call break_point_state  
4e61				endm  
# End of macro CALLMONITOR
4e61					endif 
4e61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e61 cd d2 1e			call macro_dsp_valuehl 
4e64				endm 
# End of macro FORTH_DSP_VALUEHL
4e64			 
4e64 e5					push hl 
4e65			 
4e65					; destroy value TOS 
4e65			 
4e65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e65 cd 8a 1f			call macro_forth_dsp_pop 
4e68				endm 
# End of macro FORTH_DSP_POP
4e68			 
4e68					; one value on hl get other one back 
4e68			 
4e68 c1					pop bc 
4e69			 
4e69					; do the sub 
4e69			;		ex de, hl 
4e69			 
4e69 ed 68				in l,(c) 
4e6b			 
4e6b					; save it 
4e6b			 
4e6b 26 00				ld h,0 
4e6d			 
4e6d					; TODO push value back onto stack for another op etc 
4e6d			 
4e6d cd db 1c				call forth_push_numhl 
4e70					NEXTW 
4e70 c3 44 20			jp macro_next 
4e73				endm 
# End of macro NEXTW
4e73			.SOUT: 
4e73				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e73 34				db WORD_SYS_CORE+32             
4e74 c6 4e			dw .SPIO            
4e76 04				db 3 + 1 
4e77 .. 00			db "OUT",0              
4e7b				endm 
# End of macro CWHEAD
4e7b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e7b					if DEBUG_FORTH_WORDS_KEY 
4e7b						DMARK "OUT" 
4e7b f5				push af  
4e7c 3a 90 4e			ld a, (.dmark)  
4e7f 32 b4 fb			ld (debug_mark),a  
4e82 3a 91 4e			ld a, (.dmark+1)  
4e85 32 b5 fb			ld (debug_mark+1),a  
4e88 3a 92 4e			ld a, (.dmark+2)  
4e8b 32 b6 fb			ld (debug_mark+2),a  
4e8e 18 03			jr .pastdmark  
4e90 ..			.dmark: db "OUT"  
4e93 f1			.pastdmark: pop af  
4e94			endm  
# End of macro DMARK
4e94						CALLMONITOR 
4e94 cd 7e 16			call break_point_state  
4e97				endm  
# End of macro CALLMONITOR
4e97					endif 
4e97			 
4e97					; get port 
4e97			 
4e97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e97 cd d2 1e			call macro_dsp_valuehl 
4e9a				endm 
# End of macro FORTH_DSP_VALUEHL
4e9a			 
4e9a e5					push hl 
4e9b			 
4e9b					; destroy value TOS 
4e9b			 
4e9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e9b cd 8a 1f			call macro_forth_dsp_pop 
4e9e				endm 
# End of macro FORTH_DSP_POP
4e9e			 
4e9e					; get byte to send 
4e9e			 
4e9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e9e cd d2 1e			call macro_dsp_valuehl 
4ea1				endm 
# End of macro FORTH_DSP_VALUEHL
4ea1			 
4ea1			;		push hl 
4ea1			 
4ea1					; destroy value TOS 
4ea1			 
4ea1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ea1 cd 8a 1f			call macro_forth_dsp_pop 
4ea4				endm 
# End of macro FORTH_DSP_POP
4ea4			 
4ea4					; one value on hl get other one back 
4ea4			 
4ea4			;		pop hl 
4ea4			 
4ea4 c1					pop bc 
4ea5			 
4ea5					if DEBUG_FORTH_WORDS 
4ea5						DMARK "OUT" 
4ea5 f5				push af  
4ea6 3a ba 4e			ld a, (.dmark)  
4ea9 32 b4 fb			ld (debug_mark),a  
4eac 3a bb 4e			ld a, (.dmark+1)  
4eaf 32 b5 fb			ld (debug_mark+1),a  
4eb2 3a bc 4e			ld a, (.dmark+2)  
4eb5 32 b6 fb			ld (debug_mark+2),a  
4eb8 18 03			jr .pastdmark  
4eba ..			.dmark: db "OUT"  
4ebd f1			.pastdmark: pop af  
4ebe			endm  
# End of macro DMARK
4ebe						CALLMONITOR 
4ebe cd 7e 16			call break_point_state  
4ec1				endm  
# End of macro CALLMONITOR
4ec1					endif 
4ec1			 
4ec1 ed 69				out (c), l 
4ec3			 
4ec3					NEXTW 
4ec3 c3 44 20			jp macro_next 
4ec6				endm 
# End of macro NEXTW
4ec6			 
4ec6			 
4ec6			.SPIO: 
4ec6			 
4ec6			if STORAGE_SE 
4ec6				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ec6 51				db WORD_SYS_CORE+61             
4ec7 d7 4e			dw .SPICEH            
4ec9 07				db 6 + 1 
4eca .. 00			db "SPICEL",0              
4ed1				endm 
# End of macro CWHEAD
4ed1			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ed1			 
4ed1 cd 6b 01				call spi_ce_low 
4ed4			    NEXTW 
4ed4 c3 44 20			jp macro_next 
4ed7				endm 
# End of macro NEXTW
4ed7			 
4ed7			.SPICEH: 
4ed7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ed7 51				db WORD_SYS_CORE+61             
4ed8 e8 4e			dw .SPIOb            
4eda 07				db 6 + 1 
4edb .. 00			db "SPICEH",0              
4ee2				endm 
# End of macro CWHEAD
4ee2			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ee2			 
4ee2 cd 5a 01				call spi_ce_high 
4ee5			    NEXTW 
4ee5 c3 44 20			jp macro_next 
4ee8				endm 
# End of macro NEXTW
4ee8			 
4ee8			 
4ee8			.SPIOb: 
4ee8			 
4ee8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ee8 51				db WORD_SYS_CORE+61             
4ee9 fe 4e			dw .SPII            
4eeb 05				db 4 + 1 
4eec .. 00			db "SPIO",0              
4ef1				endm 
# End of macro CWHEAD
4ef1			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ef1			 
4ef1					; get port 
4ef1			 
4ef1			 
4ef1					; get byte to send 
4ef1			 
4ef1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ef1 cd d2 1e			call macro_dsp_valuehl 
4ef4				endm 
# End of macro FORTH_DSP_VALUEHL
4ef4			 
4ef4			;		push hl    ; u1  
4ef4			 
4ef4					; destroy value TOS 
4ef4			 
4ef4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ef4 cd 8a 1f			call macro_forth_dsp_pop 
4ef7				endm 
# End of macro FORTH_DSP_POP
4ef7			 
4ef7					; one value on hl get other one back 
4ef7			 
4ef7			;		pop hl   ; u2 - addr 
4ef7			 
4ef7					; TODO Send SPI byte 
4ef7			 
4ef7 7d					ld a, l 
4ef8 cd 8f 00				call spi_send_byte 
4efb			 
4efb					NEXTW 
4efb c3 44 20			jp macro_next 
4efe				endm 
# End of macro NEXTW
4efe			 
4efe			.SPII: 
4efe				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4efe 52				db WORD_SYS_CORE+62             
4eff 13 4f			dw .SESEL            
4f01 06				db 5 + 1 
4f02 .. 00			db "SPII",0              
4f07				endm 
# End of macro CWHEAD
4f07			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f07			 
4f07					; TODO Get SPI byte 
4f07			 
4f07 cd b0 00				call spi_read_byte 
4f0a			 
4f0a 26 00				ld h, 0 
4f0c 6f					ld l, a 
4f0d cd db 1c				call forth_push_numhl 
4f10			 
4f10					NEXTW 
4f10 c3 44 20			jp macro_next 
4f13				endm 
# End of macro NEXTW
4f13			 
4f13			 
4f13			 
4f13			.SESEL: 
4f13				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f13 66				db WORD_SYS_CORE+82             
4f14 b7 4f			dw .CARTDEV            
4f16 05				db 4 + 1 
4f17 .. 00			db "BANK",0              
4f1c				endm 
# End of macro CWHEAD
4f1c			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f1c					if DEBUG_FORTH_WORDS_KEY 
4f1c						DMARK "BNK" 
4f1c f5				push af  
4f1d 3a 31 4f			ld a, (.dmark)  
4f20 32 b4 fb			ld (debug_mark),a  
4f23 3a 32 4f			ld a, (.dmark+1)  
4f26 32 b5 fb			ld (debug_mark+1),a  
4f29 3a 33 4f			ld a, (.dmark+2)  
4f2c 32 b6 fb			ld (debug_mark+2),a  
4f2f 18 03			jr .pastdmark  
4f31 ..			.dmark: db "BNK"  
4f34 f1			.pastdmark: pop af  
4f35			endm  
# End of macro DMARK
4f35						CALLMONITOR 
4f35 cd 7e 16			call break_point_state  
4f38				endm  
# End of macro CALLMONITOR
4f38					endif 
4f38			 
4f38 3e ff				ld a, 255 
4f3a 32 c8 f9				ld (spi_cartdev), a 
4f3d			 
4f3d					; get bank 
4f3d			 
4f3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f3d cd d2 1e			call macro_dsp_valuehl 
4f40				endm 
# End of macro FORTH_DSP_VALUEHL
4f40			 
4f40			;		push hl 
4f40			 
4f40					; destroy value TOS 
4f40			 
4f40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f40 cd 8a 1f			call macro_forth_dsp_pop 
4f43				endm 
# End of macro FORTH_DSP_POP
4f43			 
4f43					; one value on hl get other one back 
4f43			 
4f43			;		pop hl 
4f43			 
4f43			 
4f43 0e ff				ld c, SPI_CE_HIGH 
4f45 06 30				ld b, '0'    ; human readable bank number 
4f47			 
4f47 7d					ld a, l 
4f48			 
4f48					if DEBUG_FORTH_WORDS 
4f48						DMARK "BNK" 
4f48 f5				push af  
4f49 3a 5d 4f			ld a, (.dmark)  
4f4c 32 b4 fb			ld (debug_mark),a  
4f4f 3a 5e 4f			ld a, (.dmark+1)  
4f52 32 b5 fb			ld (debug_mark+1),a  
4f55 3a 5f 4f			ld a, (.dmark+2)  
4f58 32 b6 fb			ld (debug_mark+2),a  
4f5b 18 03			jr .pastdmark  
4f5d ..			.dmark: db "BNK"  
4f60 f1			.pastdmark: pop af  
4f61			endm  
# End of macro DMARK
4f61						CALLMONITOR 
4f61 cd 7e 16			call break_point_state  
4f64				endm  
# End of macro CALLMONITOR
4f64					endif 
4f64			 
4f64					; active low 
4f64			 
4f64 fe 00				cp 0 
4f66 28 28				jr z, .bset 
4f68 fe 01				cp 1 
4f6a 20 04				jr nz, .b2 
4f6c cb 81				res 0, c 
4f6e 06 31				ld b, '1'    ; human readable bank number 
4f70 fe 02		.b2:		cp 2 
4f72 20 04				jr nz, .b3 
4f74 cb 89				res 1, c 
4f76 06 32				ld b, '2'    ; human readable bank number 
4f78 fe 03		.b3:		cp 3 
4f7a 20 04				jr nz, .b4 
4f7c cb 91				res 2, c 
4f7e 06 33				ld b, '3'    ; human readable bank number 
4f80 fe 04		.b4:		cp 4 
4f82 20 04				jr nz, .b5 
4f84 cb 99				res 3, c 
4f86 06 34				ld b, '4'    ; human readable bank number 
4f88 fe 05		.b5:		cp 5 
4f8a 20 04				jr nz, .bset 
4f8c cb a1				res 4, c 
4f8e 06 35				ld b, '5'    ; human readable bank number 
4f90			 
4f90			.bset: 
4f90 79					ld a, c 
4f91 32 c5 f9				ld (spi_device),a 
4f94 78					ld a, b 
4f95 32 c4 f9				ld (spi_device_id),a 
4f98					if DEBUG_FORTH_WORDS 
4f98						DMARK "BN2" 
4f98 f5				push af  
4f99 3a ad 4f			ld a, (.dmark)  
4f9c 32 b4 fb			ld (debug_mark),a  
4f9f 3a ae 4f			ld a, (.dmark+1)  
4fa2 32 b5 fb			ld (debug_mark+1),a  
4fa5 3a af 4f			ld a, (.dmark+2)  
4fa8 32 b6 fb			ld (debug_mark+2),a  
4fab 18 03			jr .pastdmark  
4fad ..			.dmark: db "BN2"  
4fb0 f1			.pastdmark: pop af  
4fb1			endm  
# End of macro DMARK
4fb1						CALLMONITOR 
4fb1 cd 7e 16			call break_point_state  
4fb4				endm  
# End of macro CALLMONITOR
4fb4					endif 
4fb4			 
4fb4					NEXTW 
4fb4 c3 44 20			jp macro_next 
4fb7				endm 
# End of macro NEXTW
4fb7			 
4fb7			.CARTDEV: 
4fb7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fb7 66				db WORD_SYS_CORE+82             
4fb8 60 50			dw .ENDDEVICE            
4fba 08				db 7 + 1 
4fbb .. 00			db "CARTDEV",0              
4fc3				endm 
# End of macro CWHEAD
4fc3			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fc3					if DEBUG_FORTH_WORDS_KEY 
4fc3						DMARK "CDV" 
4fc3 f5				push af  
4fc4 3a d8 4f			ld a, (.dmark)  
4fc7 32 b4 fb			ld (debug_mark),a  
4fca 3a d9 4f			ld a, (.dmark+1)  
4fcd 32 b5 fb			ld (debug_mark+1),a  
4fd0 3a da 4f			ld a, (.dmark+2)  
4fd3 32 b6 fb			ld (debug_mark+2),a  
4fd6 18 03			jr .pastdmark  
4fd8 ..			.dmark: db "CDV"  
4fdb f1			.pastdmark: pop af  
4fdc			endm  
# End of macro DMARK
4fdc						CALLMONITOR 
4fdc cd 7e 16			call break_point_state  
4fdf				endm  
# End of macro CALLMONITOR
4fdf					endif 
4fdf			 
4fdf					; disable se storage bank selection 
4fdf			 
4fdf 3e ff				ld a, SPI_CE_HIGH		; ce high 
4fe1 32 c5 f9				ld (spi_device), a 
4fe4			 
4fe4					; get bank 
4fe4			 
4fe4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fe4 cd d2 1e			call macro_dsp_valuehl 
4fe7				endm 
# End of macro FORTH_DSP_VALUEHL
4fe7			 
4fe7			;		push hl 
4fe7			 
4fe7					; destroy value TOS 
4fe7			 
4fe7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fe7 cd 8a 1f			call macro_forth_dsp_pop 
4fea				endm 
# End of macro FORTH_DSP_POP
4fea			 
4fea					; one value on hl get other one back 
4fea			 
4fea			;		pop hl 
4fea			 
4fea					; active low 
4fea			 
4fea 0e ff				ld c, 255 
4fec			 
4fec 7d					ld a, l 
4fed					if DEBUG_FORTH_WORDS 
4fed						DMARK "CDV" 
4fed f5				push af  
4fee 3a 02 50			ld a, (.dmark)  
4ff1 32 b4 fb			ld (debug_mark),a  
4ff4 3a 03 50			ld a, (.dmark+1)  
4ff7 32 b5 fb			ld (debug_mark+1),a  
4ffa 3a 04 50			ld a, (.dmark+2)  
4ffd 32 b6 fb			ld (debug_mark+2),a  
5000 18 03			jr .pastdmark  
5002 ..			.dmark: db "CDV"  
5005 f1			.pastdmark: pop af  
5006			endm  
# End of macro DMARK
5006						CALLMONITOR 
5006 cd 7e 16			call break_point_state  
5009				endm  
# End of macro CALLMONITOR
5009					endif 
5009 fe 00				cp 0 
500b 28 30				jr z, .cset 
500d fe 01				cp 1 
500f 20 02				jr nz, .c2 
5011 cb 81				res 0, c 
5013 fe 02		.c2:		cp 2 
5015 20 02				jr nz, .c3 
5017 cb 89				res 1, c 
5019 fe 03		.c3:		cp 3 
501b 20 02				jr nz, .c4 
501d cb 91				res 2, c 
501f fe 04		.c4:		cp 4 
5021 20 02				jr nz, .c5 
5023 cb 99				res 3, c 
5025 fe 05		.c5:		cp 5 
5027 20 02				jr nz, .c6 
5029 cb a1				res 4, c 
502b fe 06		.c6:		cp 6 
502d 20 02				jr nz, .c7 
502f cb a9				res 5, c 
5031 fe 07		.c7:		cp 7 
5033 20 02				jr nz, .c8 
5035 cb b1				res 6, c 
5037 fe 08		.c8:		cp 8 
5039 20 02				jr nz, .cset 
503b cb b9				res 7, c 
503d 79			.cset:		ld a, c 
503e 32 c8 f9				ld (spi_cartdev),a 
5041			 
5041					if DEBUG_FORTH_WORDS 
5041						DMARK "CD2" 
5041 f5				push af  
5042 3a 56 50			ld a, (.dmark)  
5045 32 b4 fb			ld (debug_mark),a  
5048 3a 57 50			ld a, (.dmark+1)  
504b 32 b5 fb			ld (debug_mark+1),a  
504e 3a 58 50			ld a, (.dmark+2)  
5051 32 b6 fb			ld (debug_mark+2),a  
5054 18 03			jr .pastdmark  
5056 ..			.dmark: db "CD2"  
5059 f1			.pastdmark: pop af  
505a			endm  
# End of macro DMARK
505a						CALLMONITOR 
505a cd 7e 16			call break_point_state  
505d				endm  
# End of macro CALLMONITOR
505d					endif 
505d					NEXTW 
505d c3 44 20			jp macro_next 
5060				endm 
# End of macro NEXTW
5060			endif 
5060			 
5060			.ENDDEVICE: 
5060			; eof 
5060			 
# End of file forth_words_device.asm
5060			 
5060			; var handler 
5060			 
5060			 
5060			.VARS: 
5060				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5060 78				db WORD_SYS_CORE+100             
5061 78 50			dw .V0Q            
5063 04				db 3 + 1 
5064 .. 00			db "V0!",0              
5068				endm 
# End of macro CWHEAD
5068			;| V0! ( u1 -- )  Store value to v0  | DONE 
5068			 
5068					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5068 cd d2 1e			call macro_dsp_valuehl 
506b				endm 
# End of macro FORTH_DSP_VALUEHL
506b			 
506b 11 8d f9				ld de, cli_var_array 
506e			 
506e eb					ex de, hl 
506f 73					ld (hl), e 
5070 23					inc hl 
5071 72					ld (hl), d 
5072			 
5072					; destroy value TOS 
5072			 
5072					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5072 cd 8a 1f			call macro_forth_dsp_pop 
5075				endm 
# End of macro FORTH_DSP_POP
5075			 
5075				       NEXTW 
5075 c3 44 20			jp macro_next 
5078				endm 
# End of macro NEXTW
5078			.V0Q: 
5078				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5078 79				db WORD_SYS_CORE+101             
5079 89 50			dw .V1S            
507b 04				db 3 + 1 
507c .. 00			db "V0@",0              
5080				endm 
# End of macro CWHEAD
5080			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5080 2a 8d f9				ld hl, (cli_var_array) 
5083 cd db 1c				call forth_push_numhl 
5086			 
5086				       NEXTW 
5086 c3 44 20			jp macro_next 
5089				endm 
# End of macro NEXTW
5089			.V1S: 
5089				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5089 7a				db WORD_SYS_CORE+102             
508a a1 50			dw .V1Q            
508c 04				db 3 + 1 
508d .. 00			db "V1!",0              
5091				endm 
# End of macro CWHEAD
5091			;| V1! ( u1 -- )  Store value to v1 | DONE 
5091					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5091 cd d2 1e			call macro_dsp_valuehl 
5094				endm 
# End of macro FORTH_DSP_VALUEHL
5094			 
5094 11 8f f9				ld de, cli_var_array+2 
5097				 
5097 eb					ex de, hl 
5098 73					ld (hl), e 
5099 23					inc hl 
509a 72					ld (hl), d 
509b			 
509b					; destroy value TOS 
509b			 
509b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
509b cd 8a 1f			call macro_forth_dsp_pop 
509e				endm 
# End of macro FORTH_DSP_POP
509e				       NEXTW 
509e c3 44 20			jp macro_next 
50a1				endm 
# End of macro NEXTW
50a1			.V1Q: 
50a1				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50a1 7b				db WORD_SYS_CORE+103             
50a2 b2 50			dw .V2S            
50a4 04				db 3 + 1 
50a5 .. 00			db "V1@",0              
50a9				endm 
# End of macro CWHEAD
50a9			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50a9 2a 8f f9				ld hl, (cli_var_array+2) 
50ac cd db 1c				call forth_push_numhl 
50af				       NEXTW 
50af c3 44 20			jp macro_next 
50b2				endm 
# End of macro NEXTW
50b2			.V2S: 
50b2				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50b2 7c				db WORD_SYS_CORE+104             
50b3 ca 50			dw .V2Q            
50b5 04				db 3 + 1 
50b6 .. 00			db "V2!",0              
50ba				endm 
# End of macro CWHEAD
50ba			;| V2! ( u1 -- )  Store value to v2 | DONE 
50ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ba cd d2 1e			call macro_dsp_valuehl 
50bd				endm 
# End of macro FORTH_DSP_VALUEHL
50bd			 
50bd 11 91 f9				ld de, cli_var_array+4 
50c0				 
50c0 eb					ex de, hl 
50c1 73					ld (hl), e 
50c2 23					inc hl 
50c3 72					ld (hl), d 
50c4			 
50c4					; destroy value TOS 
50c4			 
50c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50c4 cd 8a 1f			call macro_forth_dsp_pop 
50c7				endm 
# End of macro FORTH_DSP_POP
50c7				       NEXTW 
50c7 c3 44 20			jp macro_next 
50ca				endm 
# End of macro NEXTW
50ca			.V2Q: 
50ca				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50ca 7d				db WORD_SYS_CORE+105             
50cb db 50			dw .V3S            
50cd 04				db 3 + 1 
50ce .. 00			db "V2@",0              
50d2				endm 
# End of macro CWHEAD
50d2			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50d2 2a 91 f9				ld hl, (cli_var_array+4) 
50d5 cd db 1c				call forth_push_numhl 
50d8				       NEXTW 
50d8 c3 44 20			jp macro_next 
50db				endm 
# End of macro NEXTW
50db			.V3S: 
50db				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50db 7c				db WORD_SYS_CORE+104             
50dc f3 50			dw .V3Q            
50de 04				db 3 + 1 
50df .. 00			db "V3!",0              
50e3				endm 
# End of macro CWHEAD
50e3			;| V3! ( u1 -- )  Store value to v3 | DONE 
50e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50e3 cd d2 1e			call macro_dsp_valuehl 
50e6				endm 
# End of macro FORTH_DSP_VALUEHL
50e6			 
50e6 11 93 f9				ld de, cli_var_array+6 
50e9				 
50e9 eb					ex de, hl 
50ea 73					ld (hl), e 
50eb 23					inc hl 
50ec 72					ld (hl), d 
50ed			 
50ed					; destroy value TOS 
50ed			 
50ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50ed cd 8a 1f			call macro_forth_dsp_pop 
50f0				endm 
# End of macro FORTH_DSP_POP
50f0				       NEXTW 
50f0 c3 44 20			jp macro_next 
50f3				endm 
# End of macro NEXTW
50f3			.V3Q: 
50f3				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
50f3 7d				db WORD_SYS_CORE+105             
50f4 04 51			dw .END            
50f6 04				db 3 + 1 
50f7 .. 00			db "V3@",0              
50fb				endm 
# End of macro CWHEAD
50fb			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
50fb 2a 93 f9				ld hl, (cli_var_array+6) 
50fe cd db 1c				call forth_push_numhl 
5101				       NEXTW 
5101 c3 44 20			jp macro_next 
5104				endm 
# End of macro NEXTW
5104			 
5104			 
5104			 
5104			 
5104			 
5104			; end of dict marker 
5104			 
5104 00			.END:    db WORD_SYS_END 
5105 00 00			dw 0 
5107 00				db 0 
5108			 
5108			; use to jp here for user dict words to save on macro expansion  
5108			 
5108			user_dict_next: 
5108				NEXTW 
5108 c3 44 20			jp macro_next 
510b				endm 
# End of macro NEXTW
510b			 
510b			 
510b			user_exec: 
510b				;    ld hl, <word code> 
510b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
510b				;    call forthexec 
510b				;    jp user_dict_next   (NEXT) 
510b			        ;    <word code bytes> 
510b eb				ex de, hl 
510c 2a 9b f2			ld hl,(os_tok_ptr) 
510f				 
510f				FORTH_RSP_NEXT 
510f cd 82 1c			call macro_forth_rsp_next 
5112				endm 
# End of macro FORTH_RSP_NEXT
5112			 
5112			if DEBUG_FORTH_UWORD 
5112						DMARK "UEX" 
5112 f5				push af  
5113 3a 27 51			ld a, (.dmark)  
5116 32 b4 fb			ld (debug_mark),a  
5119 3a 28 51			ld a, (.dmark+1)  
511c 32 b5 fb			ld (debug_mark+1),a  
511f 3a 29 51			ld a, (.dmark+2)  
5122 32 b6 fb			ld (debug_mark+2),a  
5125 18 03			jr .pastdmark  
5127 ..			.dmark: db "UEX"  
512a f1			.pastdmark: pop af  
512b			endm  
# End of macro DMARK
512b				CALLMONITOR 
512b cd 7e 16			call break_point_state  
512e				endm  
# End of macro CALLMONITOR
512e			endif 
512e			 
512e			 
512e			 
512e eb				ex de, hl 
512f 22 9b f2			ld (os_tok_ptr), hl 
5132				 
5132				; Don't use next - Skips the first word in uword. 
5132			 
5132 c3 d5 20			jp exec1 
5135			;	NEXT 
5135			 
5135			 
5135			; eof 
# End of file forth_wordsv4.asm
5135			endif 
5135			;;;;;;;;;;;;;; Debug code 
5135			 
5135			 
5135			;if DEBUG_FORTH_PARSE 
5135 .. 00		.nowordfound: db "No match",0 
513e .. 00		.compword:	db "Comparing word ",0 
514e .. 00		.nextwordat:	db "Next word at",0 
515b .. 00		.charmatch:	db "Char match",0 
5166			;endif 
5166			if DEBUG_FORTH_JP 
5166			.foundword:	db "Word match. Exec..",0 
5166			endif 
5166			;if DEBUG_FORTH_PUSH 
5166 .. 00		.enddict:	db "Dict end. Push.",0 
5176 .. 00		.push_str:	db "Pushing string",0 
5185 .. 00		.push_num:	db "Pushing number",0 
5194 .. 00		.data_sp:	db "SP:",0 
5198 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51aa .. 00		.wordinde:	db "Word in DE (3/0):",0 
51bc .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51ce			;endif 
51ce			;if DEBUG_FORTH_MALLOC 
51ce .. 00		.push_malloc:	db "Malloc address",0 
51dd			;endif 
51dd			 
51dd			 
51dd			 
51dd			; display malloc address and current data stack pointer  
51dd			 
51dd			malloc_error: 
51dd d5				push de 
51de f5				push af 
51df e5				push hl 
51e0 cd cd 0a			call clear_display 
51e3 11 05 52			ld de, .mallocerr 
51e6 3e 00			ld a,0 
51e8			;	ld de,os_word_scratch 
51e8 cd e0 0a			call str_at_display 
51eb 3e 11			ld a, display_row_1+17 
51ed 11 b4 fb			ld de, debug_mark 
51f0 cd e0 0a			call str_at_display 
51f3 cd f0 0a			call update_display 
51f6				;call break_point_state 
51f6 cd 5c 67			call cin_wait 
51f9			 
51f9 3e 20			ld a, ' ' 
51fb 32 8b ef			ld (os_view_disable), a 
51fe e1				pop hl 
51ff f1				pop af 
5200 d1				pop de	 
5201				CALLMONITOR 
5201 cd 7e 16			call break_point_state  
5204				endm  
# End of macro CALLMONITOR
5204 c9				ret 
5205			 
5205 .. 00		.mallocerr: 	db "Malloc Error",0 
5212			;if DEBUG_FORTH_PUSH 
5212			display_data_sp: 
5212 f5				push af 
5213			 
5213				; see if disabled 
5213			 
5213 3a 8b ef			ld a, (os_view_disable) 
5216 fe 2a			cp '*' 
5218 28 67			jr z, .skipdsp 
521a			 
521a e5				push hl 
521b e5				push hl 
521c e5			push hl 
521d cd cd 0a			call clear_display 
5220 e1			pop hl 
5221 7c				ld a,h 
5222 21 9f f2			ld hl, os_word_scratch 
5225 cd 02 10			call hexout 
5228 e1				pop hl 
5229 7d				ld a,l 
522a 21 a1 f2			ld hl, os_word_scratch+2 
522d cd 02 10			call hexout 
5230 21 a3 f2			ld hl, os_word_scratch+4 
5233 3e 00			ld a,0 
5235 77				ld (hl),a 
5236 11 9f f2			ld de,os_word_scratch 
5239 3e 14				ld a, display_row_2 
523b cd e0 0a				call str_at_display 
523e 11 98 51			ld de, .wordinhl 
5241 3e 00			ld a, display_row_1 
5243			 
5243 cd e0 0a				call str_at_display 
5246 11 b4 fb			ld de, debug_mark 
5249 3e 11			ld a, display_row_1+17 
524b			 
524b cd e0 0a				call str_at_display 
524e			 
524e				; display current data stack pointer 
524e 11 94 51			ld de,.data_sp 
5251 3e 1c				ld a, display_row_2 + 8 
5253 cd e0 0a				call str_at_display 
5256			 
5256 2a 87 f9			ld hl,(cli_data_sp) 
5259 e5				push hl 
525a 7c				ld a,h 
525b 21 9f f2			ld hl, os_word_scratch 
525e cd 02 10			call hexout 
5261 e1				pop hl 
5262 7d				ld a,l 
5263 21 a1 f2			ld hl, os_word_scratch+2 
5266 cd 02 10			call hexout 
5269 21 a3 f2			ld hl, os_word_scratch+4 
526c 3e 00			ld a,0 
526e 77				ld (hl),a 
526f 11 9f f2			ld de,os_word_scratch 
5272 3e 1f				ld a, display_row_2 + 11 
5274 cd e0 0a				call str_at_display 
5277			 
5277			 
5277 cd f0 0a			call update_display 
527a cd 4a 0a			call delay1s 
527d cd 4a 0a			call delay1s 
5280 e1				pop hl 
5281			.skipdsp: 
5281 f1				pop af 
5282 c9				ret 
5283			 
5283			display_data_malloc: 
5283			 
5283 f5				push af 
5284 e5				push hl 
5285 e5				push hl 
5286 e5			push hl 
5287 cd cd 0a			call clear_display 
528a e1			pop hl 
528b 7c				ld a,h 
528c 21 9f f2			ld hl, os_word_scratch 
528f cd 02 10			call hexout 
5292 e1				pop hl 
5293 7d				ld a,l 
5294 21 a1 f2			ld hl, os_word_scratch+2 
5297 cd 02 10			call hexout 
529a 21 a3 f2			ld hl, os_word_scratch+4 
529d 3e 00			ld a,0 
529f 77				ld (hl),a 
52a0 11 9f f2			ld de,os_word_scratch 
52a3 3e 14				ld a, display_row_2 
52a5 cd e0 0a				call str_at_display 
52a8 11 ce 51			ld de, .push_malloc 
52ab 3e 00			ld a, display_row_1 
52ad			 
52ad cd e0 0a				call str_at_display 
52b0			 
52b0				; display current data stack pointer 
52b0 11 94 51			ld de,.data_sp 
52b3 3e 1c				ld a, display_row_2 + 8 
52b5 cd e0 0a				call str_at_display 
52b8			 
52b8 2a 87 f9			ld hl,(cli_data_sp) 
52bb e5				push hl 
52bc 7c				ld a,h 
52bd 21 9f f2			ld hl, os_word_scratch 
52c0 cd 02 10			call hexout 
52c3 e1				pop hl 
52c4 7d				ld a,l 
52c5 21 a1 f2			ld hl, os_word_scratch+2 
52c8 cd 02 10			call hexout 
52cb 21 a3 f2			ld hl, os_word_scratch+4 
52ce 3e 00			ld a,0 
52d0 77				ld (hl),a 
52d1 11 9f f2			ld de,os_word_scratch 
52d4 3e 1f				ld a, display_row_2 + 11 
52d6 cd e0 0a				call str_at_display 
52d9			 
52d9 cd f0 0a			call update_display 
52dc cd 4a 0a			call delay1s 
52df cd 4a 0a			call delay1s 
52e2 e1				pop hl 
52e3 f1				pop af 
52e4 c9				ret 
52e5			;endif 
52e5			 
52e5			include "forth_autostart.asm" 
52e5			; list of commands to perform at system start up 
52e5			 
52e5			startcmds: 
52e5			;	dw test11 
52e5			;	dw test12 
52e5			;	dw test13 
52e5			;	dw test14 
52e5			;	dw test15 
52e5			;	dw test16 
52e5			;	dw test17 
52e5			;	dw ifthtest1 
52e5			;	dw ifthtest2 
52e5			;	dw ifthtest3 
52e5			;	dw mmtest1 
52e5			;	dw mmtest2 
52e5			;	dw mmtest3 
52e5			;	dw mmtest4 
52e5			;	dw mmtest5 
52e5			;	dw mmtest6 
52e5			;	dw iftest1 
52e5			;	dw iftest2 
52e5			;	dw iftest3 
52e5			;	dw looptest1 
52e5			;	dw looptest2 
52e5			;	dw test1 
52e5			;	dw test2 
52e5			;	dw test3 
52e5			;	dw test4 
52e5			;	dw game2r 
52e5			;	dw game2b1 
52e5			;	dw game2b2 
52e5			 
52e5				; start up words that are actually useful 
52e5			 
52e5 43 53			dw clrstack 
52e7 76 53			dw type 
52e9 37 55			dw stest 
52eb 9a 53			dw strncpy 
52ed d8 54			dw list 
52ef fb 53			dw start1 
52f1 0d 54			dw start2 
52f3			;	dw start3 
52f3 20 54			dw start3b 
52f5 78 54			dw start3c 
52f7			 
52f7				; (unit) testing words 
52f7			 
52f7 ae 55			dw mtesta 
52f9 63 56			dw mtestb 
52fb 06 57			dw mtestc 
52fd bb 57			dw mtestd 
52ff 5f 58			dw mteste 
5301			 
5301				; demo/game words 
5301			 
5301 6b 5f		        dw game3w 
5303 99 5f		        dw game3p 
5305 b7 5f		        dw game3sc 
5307 e8 5f		        dw game3vsi 
5309 14 60		        dw game3vs 
530b				 
530b 5e 5d			dw game2b 
530d cc 5d			dw game2bf 
530f 16 5e			dw game2mba 
5311 ac 5e			dw game2mbas 
5313 ee 5e			dw game2mb 
5315			 
5315 1f 5a			dw game1 
5317 30 5a			dw game1a 
5319 92 5a			dw game1b 
531b c7 5a			dw game1c 
531d fd 5a			dw game1d 
531f 2e 5b			dw game1s 
5321 42 5b			dw game1t 
5323 57 5b			dw game1f 
5325 8b 5b			dw game1z 
5327 cf 5b			dw game1zz 
5329			 
5329 15 59			dw test5 
532b 4d 59			dw test6 
532d 85 59			dw test7 
532f 99 59			dw test8 
5331 c5 59			dw test9 
5333 db 59			dw test10 
5335				 
5335 a6 5c		        dw ssv5 
5337 8a 5c		        dw ssv4 
5339 6e 5c		        dw ssv3 
533b 38 5c		        dw ssv2 
533d bf 5c		        dw ssv1 
533f 07 5d		        dw ssv1cpm 
5341			;	dw keyup 
5341			;	dw keydown 
5341			;	dw keyleft 
5341			;	dw keyright 
5341			;	dw 	keyf1 
5341			;	dw keyf2 
5341			;	dw keyf3 
5341			;	dw keyf4 
5341			;	dw keyf5 
5341			;	dw keyf6 
5341			;	dw keyf7 
5341			;	dw keyf8 
5341			;	dw keyf9 
5341			;	dw keyf10 
5341			;	dw keyf11 
5341			;	dw keyf12 
5341			;	dw keytab 
5341			;	dw keycr 
5341			;	dw keyhome 
5341			;	dw keyend 
5341			;	dw keybs 
5341 00 00			db 0, 0	 
5343			 
5343			 
5343			; clear stack  
5343			 
5343 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5376			 
5376			; type ( addr count - ) 
5376 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
539a			 
539a			; some direct memory words 
539a			; strncpy ( len t f -- t ) 
539a			 
539a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53fb			 
53fb .. 00		start1:     	db ": bpon $0000 bp ;",0 
540d .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5420			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5420 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5478 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54d8			 
54d8			 
54d8			; a handy word to list items on the stack 
54d8			 
54d8 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5537			 
5537			 
5537			; test stack  
5537			; rnd8 stest 
5537			 
5537 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55ae			 
55ae			; random malloc and free cycles 
55ae			 
55ae .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5663			 
5663			; fixed malloc and free cycles 
5663			 
5663 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5706			 
5706			; fixed double string push and drop cycle  
5706			 
5706 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57bb			 
57bb			; consistent fixed string push and drop cycle  
57bb			 
57bb .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
585f			 
585f .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5915			 
5915			;test1:		db ": aa 1 2 3 ;", 0 
5915			;test2:     	db "111 aa 888 999",0 
5915			;test3:     	db ": bb 77 ;",0 
5915			;test4:     	db "$02 $01 do i . loop bb",0 
5915			 
5915 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
594d .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5985 .. 00		test7:     	db ": box hline vline ;",0 
5999 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59c5 .. 00		test9:     	db ": sw $01 adsp world ;",0 
59db .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a00 .. 00		test11:     	db "hello create .",0 
5a0f .. 00		test12:     	db "hello2 create .",0 
5a1f			 
5a1f			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a1f			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a1f			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a1f			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a1f			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a1f			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a1f			 
5a1f			;iftest1:     	db "$0001 IF cls .",0 
5a1f			;iftest2:     	db "$0000 IF cls .",0 
5a1f			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a1f			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a1f			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a1f			 
5a1f			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a1f			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a1f			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a1f			 
5a1f			 
5a1f			 
5a1f			; a small guess the number game 
5a1f			 
5a1f .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a30 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a92			 
5a92 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ac7 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5afd .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b2e .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b42 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b57 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b8b .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bcf			 
5bcf			; Using 'ga' save a high score across multiple runs using external storage 
5bcf			 
5bcf .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c38			 
5c38			 
5c38			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c38			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c38			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c38			 
5c38			; simple screen saver to test code memory reuse to destruction 
5c38			 
5c38 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c6e .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c8a .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ca6 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cbf .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d07 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d5e			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d5e			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d5e			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d5e			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d5e			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d5e			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d5e			 
5d5e			 
5d5e			 
5d5e			; minesweeper/battleship finding game 
5d5e			; draws a game board of random ship/mine positions 
5d5e			; user enters coords to see if it hits on 
5d5e			; game ends when all are hit 
5d5e			; when hit or miss says how many may be in the area 
5d5e			 
5d5e			; setup the game board and then hide it 
5d5e .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dcc .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e16			; prompt for where to target 
5e16 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5eac .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ed1			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ed1 .. 00		game2mbht:      db ": mbckht nop ;",0 
5ee0 .. 00		game2mbms:      db ": mbcms nop ;",0 
5eee			; TODO how many might be near by 
5eee .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f6b			 
5f6b			; Game 3 
5f6b			 
5f6b			; Vert scroller ski game - avoid the trees! 
5f6b			 
5f6b			; v0 score (ie turns) 
5f6b			; v1 player pos 
5f6b			; v2 left wall 
5f6b			; v3 right wall 
5f6b			 
5f6b			; Draw side walls randomly 
5f6b			 
5f6b .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f99			 
5f99			; Draw player 
5f99 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fb7			 
5fb7			; TODO Get Key 
5fb7			 
5fb7			; TODO Move left right 
5fb7			 
5fb7			; scroll and move walls a bit 
5fb7			 
5fb7 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fe8			 
5fe8			; main game loop 
5fe8			 
5fe8 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6014 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6053			 
6053			; key board defs 
6053			 
6053 .. 00		keyup:       db ": keyup $05 ;",0 
6061 .. 00		keydown:       db ": keydown $0a ;",0 
6071 .. 00		keyleft:       db ": keyleft $0b ;",0 
6081 .. 00		keyright:       db ": keyright $0c ;",0 
6092 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60a0 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60ae .. 00		keyf3:       db ": keyf3 $12 ;",0 
60bc .. 00		keyf4:       db ": keyf4 $13 ;",0 
60ca .. 00		keyf5:       db ": keyf5 $14 ;",0 
60d8 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60e6 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60f4 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6102 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6110 .. 00		keyf10:       db ": keyf10 $19 ;",0 
611f .. 00		keyf11:       db ": keyf11 $1a ;",0 
612e .. 00		keyf12:       db ": keyf12 $1b ;",0 
613d			 
613d .. 00		keytab:       db ": keytab $09 ;",0 
614c .. 00		keycr:       db ": keycr $0d ;",0 
615a .. 00		keyhome:       db ": keyhome $0e ;",0 
616a .. 00		keyend:       db ": keyend $0f ;",0 
6179 .. 00		keybs:       db ": keybs $08 ;",0 
6187			 
6187			   
6187			 
6187			 
6187			 
6187			; eof 
# End of file forth_autostart.asm
6187			 
6187 .. 00		sprompt1: db "Startup load...",0 
6197 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61ad			 
61ad			 
61ad			 
61ad			 
61ad			forth_startup: 
61ad 21 e5 52			ld hl, startcmds 
61b0 3e 00			ld a, 0 
61b2 32 c0 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61b5			 
61b5 e5			.start1:	push hl 
61b6 cd cd 0a			call clear_display 
61b9 11 87 61			ld de, sprompt1 
61bc 3e 00		        ld a, display_row_1 
61be cd e0 0a			call str_at_display 
61c1 11 97 61			ld de, sprompt2 
61c4 3e 14		        ld a, display_row_2 
61c6 cd e0 0a			call str_at_display 
61c9 e1				pop hl 
61ca e5				push hl 
61cb 5e				ld e,(hl) 
61cc 23				inc hl 
61cd 56				ld d,(hl) 
61ce 3e 28		        ld a, display_row_3 
61d0 cd e0 0a			call str_at_display 
61d3 cd f0 0a			call update_display 
61d6			 
61d6			 
61d6 3a c0 f3			ld a, (os_last_cmd) 
61d9 fe 00			cp 0 
61db 28 05			jr z, .startprompt 
61dd cd 3e 0a			call delay250ms 
61e0 18 24			jr .startdo 
61e2				 
61e2				 
61e2			 
61e2			.startprompt: 
61e2			 
61e2 3e 4f			ld a,display_row_4 + display_cols - 1 
61e4 11 51 1c		        ld de, endprg 
61e7 cd e0 0a			call str_at_display 
61ea cd f0 0a			call update_display 
61ed cd 4a 0a			call delay1s 
61f0 cd 5c 67			call cin_wait 
61f3						 
61f3 fe 2a			cp '*' 
61f5 28 5e			jr z, .startupend1 
61f7 fe 23			cp '#' 
61f9 20 07			jr nz, .startno 
61fb 3e 01			ld a, 1 
61fd 32 c0 f3			ld (os_last_cmd),a 
6200 18 04			jr .startdo 
6202 fe 31		.startno:	cp '1' 
6204 28 3a			jr z,.startnxt  
6206			 
6206				; exec startup line 
6206			.startdo:	 
6206 e1				pop hl 
6207 e5				push hl 
6208				 
6208 5e				ld e,(hl) 
6209 23				inc hl 
620a 56				ld d,(hl) 
620b eb				ex de,hl 
620c			 
620c e5				push hl 
620d			 
620d 3e 00			ld a, 0 
620f				;ld a, FORTH_END_BUFFER 
620f cd 6a 11			call strlent 
6212 23				inc hl   ; include zero term to copy 
6213 06 00			ld b,0 
6215 4d				ld c,l 
6216 e1				pop hl 
6217 11 9a ef			ld de, scratch 
621a ed b0			ldir 
621c			 
621c			 
621c 21 9a ef			ld hl, scratch 
621f cd 92 20			call forthparse 
6222 cd d2 20			call forthexec 
6225 cd e9 1f			call forthexec_cleanup 
6228			 
6228 3e 3c			ld a, display_row_4 
622a 11 f5 19			ld de, endprog 
622d			 
622d cd f0 0a			call update_display		 
6230			 
6230 3a c0 f3			ld a, (os_last_cmd) 
6233 fe 00			cp 0 
6235 20 09			jr nz, .startnxt 
6237 cd 53 1c			call next_page_prompt 
623a cd cd 0a		        call clear_display 
623d cd f0 0a			call update_display		 
6240			 
6240				; move onto next startup line? 
6240			.startnxt: 
6240			 
6240 cd 3e 0a			call delay250ms 
6243 e1				pop hl 
6244			 
6244 23				inc hl 
6245 23				inc hl 
6246			 
6246 e5				push hl 
6247 5e				ld e, (hl) 
6248 23				inc hl 
6249 56				ld d, (hl) 
624a e1				pop hl 
624b				; TODO replace 0 test 
624b			 
624b eb				ex de, hl 
624c cd 2a 0d			call ishlzero 
624f			;	ld a,e 
624f			;	add d 
624f			;	cp 0    ; any left to do? 
624f eb				ex de, hl 
6250 c2 b5 61			jp nz, .start1 
6253 18 01			jr .startupend 
6255			 
6255 e1			.startupend1: pop hl 
6256			.startupend: 
6256			 
6256 cd cd 0a			call clear_display 
6259 cd f0 0a			call update_display 
625c c9				ret 
625d			 
625d			 
625d			; stack over and underflow checks 
625d			 
625d			; init the words to detect the under/overflow 
625d			 
625d			chk_stk_init: 
625d				; a vague random number to check so we dont get any "lucky" hits 
625d 3e 2d			ld a, 45 
625f 6f				ld l, a 
6260 00				nop 
6261 3e 17			ld a, 23 
6263 67				ld h, a 
6264			 
6264 22 81 ef			ld (chk_word), hl     ; the word we need to check against 
6267			 
6267			;	ld (chk_stund), hl	; stack points.... 
6267 22 fd fb			ld (chk_stovr), hl 
626a 22 85 f9			ld (chk_ret_und), hl 
626d 22 03 f9			ld (chk_ret_ovr), hl 
6270 22 01 f7			ld (chk_loop_ovr), hl 
6273 22 ff f4			ld (chk_data_ovr), hl 
6276 c9				ret 
6277				 
6277			check_stacks: 
6277				; check all stack words 
6277			 
6277 e5				push hl 
6278 d5				push de 
6279			 
6279			;	ld de,(chk_word) 
6279			;	ld hl, (chk_stund)	; stack points.... 
6279			;	if DEBUG_STK_FAULT 
6279			;		DMARK "FAa" 
6279			;		CALLMONITOR 
6279			;	endif 
6279			;	call cmp16 
6279			;	jp z, .chk_faulta 
6279			; 
6279			;	ld de, sfaultsu 
6279			;	jp .chk_fault 
6279			 
6279 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
627c ed 5b 81 ef		ld de,(chk_word) 
6280				if DEBUG_STK_FAULT 
6280					DMARK "FAb" 
6280					CALLMONITOR 
6280				endif 
6280 cd 1f 0d			call cmp16 
6283 28 06			jr z, .chk_fault1 
6285 11 26 63			ld de, sfaultso 
6288 c3 da 62			jp .chk_fault 
628b			.chk_fault1:  
628b 2a 85 f9			ld hl, (chk_ret_und) 
628e ed 5b 81 ef		ld de,(chk_word) 
6292				if DEBUG_STK_FAULT 
6292					DMARK "FAU" 
6292					CALLMONITOR 
6292				endif 
6292 cd 1f 0d			call cmp16 
6295 ca 9e 62			jp z, .chk_fault2 
6298 11 36 63			ld de, sfaultru 
629b c3 da 62			jp .chk_fault 
629e			.chk_fault2:  
629e 2a 03 f9			ld hl, (chk_ret_ovr) 
62a1 ed 5b 81 ef		ld de,(chk_word) 
62a5				if DEBUG_STK_FAULT 
62a5					DMARK "FA1" 
62a5					CALLMONITOR 
62a5				endif 
62a5 cd 1f 0d			call cmp16 
62a8 ca b1 62			jp z, .chk_fault3 
62ab 11 44 63			ld de, sfaultro 
62ae c3 da 62			jp .chk_fault 
62b1			.chk_fault3:  
62b1 2a 01 f7			ld hl, (chk_loop_ovr) 
62b4 ed 5b 81 ef		ld de,(chk_word) 
62b8				if DEBUG_STK_FAULT 
62b8					DMARK "FA2" 
62b8					CALLMONITOR 
62b8				endif 
62b8 cd 1f 0d			call cmp16 
62bb ca c4 62			jp z, .chk_fault4 
62be 11 5e 63			ld de, sfaultlo 
62c1 c3 da 62			jp .chk_fault 
62c4			.chk_fault4:  
62c4 2a ff f4			ld hl, (chk_data_ovr) 
62c7 ed 5b 81 ef		ld de,(chk_word) 
62cb				if DEBUG_STK_FAULT 
62cb					DMARK "FA3" 
62cb					CALLMONITOR 
62cb				endif 
62cb cd 1f 0d			call cmp16 
62ce ca d7 62			jp z, .chk_fault5 
62d1 11 78 63			ld de, sfaultdo 
62d4 c3 da 62			jp .chk_fault 
62d7			 
62d7			 
62d7			.chk_fault5:  
62d7 d1				pop de 
62d8 e1				pop hl 
62d9			 
62d9 c9				ret 
62da			 
62da cd cd 0a		.chk_fault: 	call clear_display 
62dd 3e 14				ld a, display_row_2 
62df cd e0 0a				call str_at_display 
62e2 11 08 63				   ld de, .stackfault 
62e5 3e 00				ld a, display_row_1 
62e7 cd e0 0a				call str_at_display 
62ea 11 b4 fb				    ld de, debug_mark 
62ed 3e 11				ld a, display_row_1+17 
62ef cd e0 0a				call str_at_display 
62f2 cd f0 0a				call update_display 
62f5			 
62f5				; prompt before entering montior for investigating issue 
62f5			 
62f5 3e 3c			ld a, display_row_4 
62f7 11 f5 19			ld de, endprog 
62fa			 
62fa cd f0 0a			call update_display		 
62fd			 
62fd cd 53 1c			call next_page_prompt 
6300			 
6300 d1				pop de 
6301 e1				pop hl 
6302 cd 49 1a				call monitor 
6305 c3 40 19				jp warmstart 
6308					;jp 0 
6308					;halt 
6308			 
6308			 
6308			 
6308 .. 00		.stackfault: 	db "Stack fault:",0 
6315			 
6315 .. 00		sfaultsu: 	db	"Stack under flow",0 
6326 .. 00		sfaultso: 	db	"Stack over flow",0 
6336 .. 00		sfaultru:	db "RTS underflow",0 
6344 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
635e .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6378 .. 00		sfaultdo:	db "DTS overflow", 0 
6385			 
6385			 
6385			fault_dsp_under: 
6385 11 97 63			ld de, .dsp_under 
6388 c3 47 64			jp .show_fault 
638b			 
638b			fault_rsp_under: 
638b 11 a5 63			ld de, .rsp_under 
638e c3 47 64			jp .show_fault 
6391			fault_loop_under: 
6391 11 b3 63			ld de, .loop_under 
6394 c3 47 64			jp .show_fault 
6397			 
6397 .. 00		.dsp_under: db "DSP Underflow",0 
63a5 .. 00		.rsp_under: db "RSP Underflow",0 
63b3 .. 00		.loop_under: db "LOOP Underflow",0 
63c2			 
63c2			 
63c2 d5			type_faultn: 	push de 
63c3 e5					push hl 
63c4 cd cd 0a				call clear_display 
63c7 11 ee 63				   ld de, .typefaultn 
63ca 3e 00				ld a, display_row_1 
63cc cd e0 0a				call str_at_display 
63cf 11 b4 fb				    ld de, debug_mark 
63d2 3e 11				ld a, display_row_1+17 
63d4 cd e0 0a				call str_at_display 
63d7 cd f0 0a				call update_display 
63da			 
63da				; prompt before entering montior for investigating issue 
63da			 
63da 3e 3c			ld a, display_row_4 
63dc 11 f5 19			ld de, endprog 
63df			 
63df cd f0 0a			call update_display		 
63e2			 
63e2 cd 53 1c			call next_page_prompt 
63e5			 
63e5 e5					push hl 
63e6 d5					push de 
63e7 cd 49 1a				call monitor 
63ea c3 40 19				jp warmstart 
63ed 76					halt 
63ee			 
63ee			 
63ee .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6405			 
6405 d5			type_faults: 	push de 
6406 e5					push hl 
6407 cd cd 0a				call clear_display 
640a 11 30 64				   ld de, .typefaults 
640d 3e 00				ld a, display_row_1 
640f cd e0 0a				call str_at_display 
6412 11 b4 fb				    ld de, debug_mark 
6415 3e 11				ld a, display_row_1+17 
6417 cd e0 0a				call str_at_display 
641a cd f0 0a				call update_display 
641d			 
641d				; prompt before entering montior for investigating issue 
641d			 
641d 3e 3c			ld a, display_row_4 
641f 11 f5 19			ld de, endprog 
6422			 
6422 cd f0 0a			call update_display		 
6425			 
6425 cd 53 1c			call next_page_prompt 
6428			 
6428 e1					pop hl 
6429 d1					pop de 
642a cd 49 1a				call monitor 
642d c3 40 19				jp warmstart 
6430			 
6430			 
6430 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6447			 
6447			.show_fault: 	 
6447 d5					push de 
6448 cd cd 0a				call clear_display 
644b d1					pop de 
644c 3e 00				ld a, display_row_1 
644e cd e0 0a				call str_at_display 
6451 11 b4 fb				    ld de, debug_mark 
6454 3e 11				ld a, display_row_1+17 
6456 cd e0 0a				call str_at_display 
6459 cd f0 0a				call update_display 
645c			 
645c				; prompt before entering montior for investigating issue 
645c			 
645c 3e 3c			ld a, display_row_4 
645e 11 f5 19			ld de, endprog 
6461			 
6461 cd f0 0a			call update_display		 
6464			 
6464 cd 53 1c			call next_page_prompt 
6467			 
6467 e1					pop hl 
6468 d1					pop de 
6469 cd 49 1a				call monitor 
646c			; do a dump to cli and not warmstart so we preserve all of the uwords.  
646c			; TODO Make optional fault restart to cli or warm boot? 
646c					;jp warmstart 
646c c3 9b 19				jp cli 
646f 76					halt 
6470			 
6470			; handle the auto run of code from files in storage 
6470			 
6470			 
6470			if STORAGE_SE 
6470			 
6470 .. 00		sprompt3: db "Loading from start-up file?:",0 
648d .. 00		sprompt4: db "(Y=Any key/N=No)",0 
649e			 
649e			 
649e			forth_autoload: 
649e			 
649e				; load block 0 of store 1 
649e				 
649e 3e fe			ld a, $fe      ; bit 0 clear 
64a0 32 c5 f9			ld (spi_device), a 
64a3			 
64a3 cd 90 03			call storage_get_block_0 
64a6			 
64a6 3a 00 fa			ld a, (store_page+STORE_0_AUTOFILE) 
64a9			 
64a9 fe 00			cp 0 
64ab c8				ret z     ; auto start not enabled 
64ac			 
64ac cd cd 0a			call clear_display 
64af			 
64af				; set bank 
64af			 
64af 3a 02 fa				ld a, (store_page+STORE_0_BANKRUN) 
64b2 32 c5 f9				ld (spi_device), a 
64b5			 
64b5				; get file id to load from and get the file name to display 
64b5			 
64b5 3a 03 fa				ld a, (store_page+STORE_0_FILERUN) 
64b8			 
64b8 2e 00				ld l, 0 
64ba 67					ld h, a 
64bb 11 df f9				ld de, store_page 
64be			 
64be					if DEBUG_FORTH_WORDS 
64be						DMARK "ASp" 
64be f5				push af  
64bf 3a d3 64			ld a, (.dmark)  
64c2 32 b4 fb			ld (debug_mark),a  
64c5 3a d4 64			ld a, (.dmark+1)  
64c8 32 b5 fb			ld (debug_mark+1),a  
64cb 3a d5 64			ld a, (.dmark+2)  
64ce 32 b6 fb			ld (debug_mark+2),a  
64d1 18 03			jr .pastdmark  
64d3 ..			.dmark: db "ASp"  
64d6 f1			.pastdmark: pop af  
64d7			endm  
# End of macro DMARK
64d7						CALLMONITOR 
64d7 cd 7e 16			call break_point_state  
64da				endm  
# End of macro CALLMONITOR
64da					endif 
64da cd 38 08				call storage_read 
64dd			 
64dd					if DEBUG_FORTH_WORDS 
64dd						DMARK "ASr" 
64dd f5				push af  
64de 3a f2 64			ld a, (.dmark)  
64e1 32 b4 fb			ld (debug_mark),a  
64e4 3a f3 64			ld a, (.dmark+1)  
64e7 32 b5 fb			ld (debug_mark+1),a  
64ea 3a f4 64			ld a, (.dmark+2)  
64ed 32 b6 fb			ld (debug_mark+2),a  
64f0 18 03			jr .pastdmark  
64f2 ..			.dmark: db "ASr"  
64f5 f1			.pastdmark: pop af  
64f6			endm  
# End of macro DMARK
64f6						CALLMONITOR 
64f6 cd 7e 16			call break_point_state  
64f9				endm  
# End of macro CALLMONITOR
64f9					endif 
64f9			 
64f9 cd 2a 0d				call ishlzero 
64fc c8					ret z             ; file not found 
64fd			 
64fd 3e 1e				ld a, display_row_2 + 10 
64ff 11 e2 f9				ld de, store_page+3 
6502 cd e0 0a				call str_at_display 
6505				 
6505			; 
6505			 
6505 3e 05			ld a, display_row_1+5 
6507 11 70 64			ld de, sprompt3 
650a cd e0 0a			call str_at_display 
650d 3e 37			ld a, display_row_3+15 
650f 11 8d 64			ld de, sprompt4 
6512 cd e0 0a			call str_at_display 
6515			 
6515 cd f0 0a			call update_display 
6518			 
6518 cd 5c 67			call cin_wait 
651b fe 6e			cp 'n' 
651d c8				ret z 
651e fe 4e			cp 'N' 
6520 c8				ret z 
6521			 
6521 cd 4a 0a			call delay1s 
6524			 
6524 3a e1 f9			ld a, (store_page+2) 
6527 32 d5 f9			ld (store_openmaxext), a    ; save count of ext 
652a 3e 01			ld a, 1  
652c 32 d6 f9			ld (store_openext), a    ; save count of ext 
652f			 
652f			.autof:  
652f 6f				ld l , a 
6530				 
6530 3a df f9			ld a, (store_page) 
6533 67				ld h, a	 
6534 11 df f9			ld de, store_page 
6537					if DEBUG_FORTH_WORDS 
6537						DMARK "ASl" 
6537 f5				push af  
6538 3a 4c 65			ld a, (.dmark)  
653b 32 b4 fb			ld (debug_mark),a  
653e 3a 4d 65			ld a, (.dmark+1)  
6541 32 b5 fb			ld (debug_mark+1),a  
6544 3a 4e 65			ld a, (.dmark+2)  
6547 32 b6 fb			ld (debug_mark+2),a  
654a 18 03			jr .pastdmark  
654c ..			.dmark: db "ASl"  
654f f1			.pastdmark: pop af  
6550			endm  
# End of macro DMARK
6550						CALLMONITOR 
6550 cd 7e 16			call break_point_state  
6553				endm  
# End of macro CALLMONITOR
6553					endif 
6553 cd 38 08				call storage_read 
6556 cd 2a 0d			call ishlzero 
6559 c8				ret z 
655a			;	jr z, .autoend 
655a			 
655a					if DEBUG_FORTH_WORDS 
655a						DMARK "ASc" 
655a f5				push af  
655b 3a 6f 65			ld a, (.dmark)  
655e 32 b4 fb			ld (debug_mark),a  
6561 3a 70 65			ld a, (.dmark+1)  
6564 32 b5 fb			ld (debug_mark+1),a  
6567 3a 71 65			ld a, (.dmark+2)  
656a 32 b6 fb			ld (debug_mark+2),a  
656d 18 03			jr .pastdmark  
656f ..			.dmark: db "ASc"  
6572 f1			.pastdmark: pop af  
6573			endm  
# End of macro DMARK
6573						CALLMONITOR 
6573 cd 7e 16			call break_point_state  
6576				endm  
# End of macro CALLMONITOR
6576					endif 
6576 11 e1 f9			ld de, store_page+2 
6579 3e 3c			ld a, display_row_4 
657b cd e0 0a			call str_at_display 
657e			 
657e cd f0 0a			call update_display 
6581 cd 3e 0a			call delay250ms 
6584			 
6584			 
6584			 
6584 21 e1 f9			ld hl, store_page+2 
6587 cd 92 20			call forthparse 
658a cd d2 20			call forthexec 
658d cd e9 1f			call forthexec_cleanup 
6590			 
6590				 
6590 3a d6 f9			ld a, (store_openext) 
6593 3c				inc a 
6594 32 d6 f9			ld (store_openext), a    ; save count of ext 
6597			 
6597 18 96			jr .autof 
6599			;.autofdone: 
6599			; 
6599			;		if DEBUG_FORTH_WORDS 
6599			;			DMARK "ASx" 
6599			;			CALLMONITOR 
6599			;		endif 
6599			;;	call clear_display 
6599			;	ret 
6599			 
6599			 
6599			 
6599			endif 
6599			 
6599			 
6599			; eof 
# End of file forth_kernel.asm
6599			;include "nascombasic.asm" 
6599			 
6599			 
6599			; find out where the code ends if loaded into RAM (for SC114) 
6599			;endofcode:  
6599			;	nop 
6599			 
6599			 
6599			; eof 
6599			 
# End of file main.asm
6599			include "firmware_lcd_4x20.asm" 
6599			; **********************************************************************  
6599			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6599			; **********************************************************************  
6599			;  
6599			; **  Written as a Small Computer Monitor App  
6599			; **  www.scc.me.uk  
6599			;  
6599			; History  
6599			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6599			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6599			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6599			;  
6599			; **********************************************************************  
6599			;  
6599			; This program is an example of one of the methods of interfacing an   
6599			; alphanumeric LCD module.   
6599			;  
6599			; In this example the display is connected to either a Z80 PIO or a   
6599			; simple 8-bit output port.   
6599			;  
6599			; This interfacing method uses 4-bit data mode and uses time delays  
6599			; rather than polling the display's ready status. As a result the   
6599			; interface only requires 6 simple output lines:  
6599			;   Output bit 0 = not used  
6599			;   Output bit 1 = not used  
6599			;   Output bit 2 = RS         High = data, Low = instruction  
6599			;   Output bit 3 = E          Active high  
6599			;   Output bit 4 = DB4  
6599			;   Output bit 5 = DB5  
6599			;   Output bit 6 = DB6  
6599			;   Output bit 7 = DB7  
6599			; Display's R/W is connected to 0v so it is always in write mode  
6599			;  
6599			; This set up should work with any system supporting the RC2014 bus  
6599			  
6599			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6599			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6599			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6599			;  
6599			; **********************************************************************  
6599			  
6599			; **********************************************************************  
6599			; **  Constants  
6599			; **********************************************************************  
6599			; LCD constants required by LCD support module  
6599			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6599			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6599			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6599			kLCDWidth:  EQU display_cols             ;Width in characters  
6599			  
6599			; **********************************************************************  
6599			; **  Code library usage  
6599			; **********************************************************************  
6599			  
6599			; send character to current cursor position  
6599			; wraps and/or scrolls screen automatically  
6599			  
6599			  
6599			lcd_init:  
6599			  
6599			; SCMonAPI functions used  
6599			  
6599			; Alphanumeric LCD functions used  
6599			; no need to specify specific functions for this module  
6599			  
6599 3e cf		            LD   A, 11001111b  
659b d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
659d 3e 00		            LD   A, 00000000b  
659f d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
65a1			  
65a1			; Initialise alphanumeric LCD module  
65a1 cd 1a 66		            CALL fLCD_Init      ;Initialise LCD module  
65a4			  
65a4 c9				ret  
65a5			  
65a5			;  
65a5			;;  
65a5			; lcd functions  
65a5			;  
65a5			;  
65a5			  
65a5			; what is at cursor position   
65a5			  
65a5			;get_cursor:	ld de, (cursor_row)   ;  row + col  
65a5			;		call curptr  
65a5			;		ret  
65a5			  
65a5			  
65a5			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
65a5			  
65a5			curptr:  
65a5 c5				push bc  
65a6 21 4a fb			ld hl, display_fb0  
65a9			cpr:	  
65a9				; loop for cursor whole row  
65a9 0e 14			ld c, display_cols  
65ab 23			cpr1:	inc hl  
65ac 0d				dec c  
65ad 20 fc			jr nz, cpr1  
65af 05				dec b  
65b0 20 f7			jr nz, cpr  
65b2			  
65b2				; add col	  
65b2			  
65b2 23			cpr2:	inc hl  
65b3 1d				dec e  
65b4 20 fc			jr nz, cpr2  
65b6			  
65b6 c1				pop bc  
65b7 c9				ret  
65b8				  
65b8			  
65b8			  
65b8			  
65b8			  
65b8			; write the frame buffer given in hl to hardware   
65b8 22 52 fa		write_display: ld (display_write_tmp), hl 	   
65bb 3e 00			ld a, kLCD_Line1  
65bd cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65c0 06 14			ld b, display_cols  
65c2 ed 5b 52 fa		ld de, (display_write_tmp)  
65c6 cd 12 66			call write_len_string  
65c9				  
65c9				  
65c9 2a 52 fa			ld hl, (display_write_tmp)  
65cc 11 14 00			ld de, display_cols  
65cf 19				add hl,de  
65d0 22 52 fa			ld (display_write_tmp),hl  
65d3			  
65d3				  
65d3 3e 40			ld a, kLCD_Line2  
65d5 cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65d8 06 14			ld b, display_cols  
65da ed 5b 52 fa		ld de, (display_write_tmp)  
65de cd 12 66			call write_len_string  
65e1				  
65e1 2a 52 fa			ld hl, (display_write_tmp)  
65e4 11 14 00			ld de, display_cols  
65e7 19				add hl,de  
65e8 22 52 fa			ld (display_write_tmp),hl  
65eb			  
65eb				  
65eb 3e 14			ld a, kLCD_Line3  
65ed cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65f0 06 14			ld b, display_cols  
65f2 ed 5b 52 fa		ld de, (display_write_tmp)  
65f6 cd 12 66			call write_len_string  
65f9				  
65f9 2a 52 fa			ld hl, (display_write_tmp)  
65fc 11 14 00			ld de, display_cols  
65ff 19				add hl,de  
6600 22 52 fa			ld (display_write_tmp),hl  
6603			  
6603				  
6603 3e 54			ld a, kLCD_Line4  
6605 cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6608 06 14			ld b, display_cols  
660a ed 5b 52 fa		ld de, (display_write_tmp)  
660e cd 12 66			call write_len_string  
6611 c9					ret  
6612				  
6612				; write out a fixed length string given in b from de  
6612			  
6612 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6613 cd 64 66		            CALL fLCD_Data      ;Write character to display  
6616 13				inc de  
6617 10 f9			djnz write_len_string  
6619 c9				ret  
661a			  
661a			; Some other things to do  
661a			;            LD   A, kLCD_Clear ;Display clear  
661a			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
661a			;            LD   A, kLCD_Under ;Display on with underscore cursor  
661a			;            LD   A, kLCD_On     ;Display on with no cursor  
661a			;            ;LD   A, kLCD_Off   ;Display off  
661a			;            CALL fLCD_Inst      ;Send instruction to display  
661a			;  
661a			;  
661a			;            halt  
661a			;  
661a			;  
661a			;MsgHello:   DB  "Hello World!",0  
661a			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
661a			  
661a			; Custom characters 5 pixels wide by 8 pixels high  
661a			; Up to 8 custom characters can be defined  
661a			;BitMaps:      
661a			;; Character 0x00 = Battery icon  
661a			;            DB  01110b  
661a			;            DB  11011b  
661a			;            DB  10001b  
661a			;            DB  10001b  
661a			;            DB  11111b  
661a			;            DB  11111b  
661a			;            DB  11111b  
661a			;            DB  11111b  
661a			;; Character 0x01 = Bluetooth icon  
661a			;            DB  01100b  
661a			;            DB  01010b  
661a			;            DB  11100b  
661a			;            DB  01000b  
661a			;            DB  11100b  
661a			;            DB  01010b  
661a			;            DB  01100b  
661a			;            DB  00000b  
661a			;  
661a			  
661a			  
661a			; **********************************************************************  
661a			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
661a			; **********************************************************************  
661a			;  
661a			; **  Written as a Small Computer Monitor App   
661a			; **  Version 0.1 SCC 2018-05-16  
661a			; **  www.scc.me.uk  
661a			;  
661a			; **********************************************************************  
661a			;  
661a			; This module provides support for alphanumeric LCD modules using with  
661a			; *  HD44780 (or compatible) controller  
661a			; *  5 x 7 pixel fonts  
661a			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
661a			; *  Interface via six digital outputs to the display (see below)  
661a			;  
661a			; LCD module pinout:  
661a			;   1  Vss   0v supply  
661a			;   2  Vdd   5v supply  
661a			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
661a			;   4  RS    High = data, Low = instruction  
661a			;   5  R/W   High = Read, Low = Write  
661a			;   6  E     Enable signal (active high)  
661a			;   7  DB0   Data bit 0  
661a			;   8  DB1   Data bit 1  
661a			;   9  DB2   Data bit 2  
661a			;  10  DB3   Data bit 3  
661a			;  11  DB4   Data bit 4  
661a			;  12  DB5   Data bit 5  
661a			;  13  DB6   Data bit 6  
661a			;  14  DB7   Data bit 7  
661a			;  15  A     Backlight anode (+)  
661a			;  16  K     Backlight cathode (-)  
661a			;  
661a			; This interfacing method uses 4-bit data mode and uses time delays  
661a			; rather than polling the display's ready status. As a result the   
661a			; interface only requires 6 simple output lines:  
661a			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
661a			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
661a			;   LCD DB4 = Microcomputer output port bit 4  
661a			;   LCD DB5 = Microcomputer output port bit 5  
661a			;   LCD DB6 = Microcomputer output port bit 6  
661a			;   LCD DB7 = Microcomputer output port bit 7  
661a			; Display's R/W is connected to 0v so it is always in write mode  
661a			; All 6 connections must be on the same port address <kLCDPrt>  
661a			; This method also allows a decent length of cable from micro to LCD  
661a			;  
661a			; **********************************************************************  
661a			;  
661a			; To include the code for any given function provided by this module,   
661a			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
661a			; the parent source file.  
661a			; For example:  #REQUIRES   uHexPrefix  
661a			;  
661a			; Also #INCLUDE this file at some point after the #REQUIRES statements  
661a			; in the parent source file.  
661a			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
661a			;  
661a			; These are the function names provided by this module:  
661a			; fLCD_Init                     ;Initialise LCD  
661a			; fLCD_Inst                     ;Send instruction to LCD  
661a			; fLCD_Data                     ;Send data byte to LCD  
661a			; fLCD_Pos                      ;Position cursor  
661a			; fLCD_Str                      ;Display string  
661a			; fLCD_Def                      ;Define custom character  
661a			;  
661a			; **********************************************************************  
661a			;  
661a			; Requires SCMonAPI.asm to also be included in the project  
661a			;  
661a			  
661a			  
661a			; **********************************************************************  
661a			; **  Constants  
661a			; **********************************************************************  
661a			  
661a			; Constants that must be defined externally  
661a			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
661a			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
661a			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
661a			;kLCDWidth: EQU 20             ;Width in characters  
661a			  
661a			; general line offsets in any frame buffer  
661a			  
661a			  
661a			display_row_1: equ 0  
661a			display_row_2: equ display_row_1+display_cols  
661a			display_row_3: equ display_row_2 + display_cols  
661a			display_row_4: equ display_row_3 + display_cols  
661a			;display_row_4_eol:   
661a			  
661a			  
661a			; Cursor position values for the start of each line  
661a			kLCD_Line1: EQU 0x00   
661a			kLCD_Line2: EQU 0x40    
661a			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
661a			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
661a			  
661a			; Instructions to send as A register to fLCD_Inst  
661a			kLCD_Clear: EQU 00000001b     ;LCD clear  
661a			kLCD_Off:   EQU 00001000b     ;LCD off  
661a			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
661a			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
661a			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
661a			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
661a			  
661a			; Constants used by this code module  
661a			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
661a			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
661a			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
661a			  
661a			  
661a			  
661a			; **********************************************************************  
661a			; **  LCD support functions  
661a			; **********************************************************************  
661a			  
661a			; Initialise alphanumeric LCD module  
661a			; LCD control register codes:  
661a			;   DL   0 = 4-bit mode        1 = 8-bit mode  
661a			;   N    0 = 1-line mode       1 = 2-line mode  
661a			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
661a			;   D    0 = Display off       1 = Display on  
661a			;   C    0 = Cursor off        1 = Cursor on  
661a			;   B    0 = Blinking off      1 = Blinking on  
661a			;   ID   0 = Decrement mode    1 = Increment mode  
661a			;   SH   0 = Entire shift off  1 = Entire shift on  
661a 3e 28		fLCD_Init:  LD   A, 40  
661c cd d1 66		            CALL LCDDelay       ;Delay 40ms after power up  
661f			; For reliable reset set 8-bit mode - 3 times  
661f cd bb 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6622 cd bb 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6625 cd bb 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6628			; Set 4-bit mode  
6628 cd b7 66		            CALL WrFn4bit       ;Function = 4-bit mode  
662b cd cf 66		            CALL LCDDelay1      ;Delay 37 us or more  
662e			; Function set  
662e 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6630 cd 43 66		            CALL fLCD_Inst      ;2 line, display on  
6633			; Display On/Off control  
6633 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6635 cd 43 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6638			; Display Clear  
6638 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
663a cd 43 66		            CALL fLCD_Inst      ;Clear display  
663d			; Entry mode  
663d 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
663f cd 43 66		            CALL fLCD_Inst      ;Increment mode, shift off  
6642			; Display module now initialised  
6642 c9			            RET  
6643			; ok to here  
6643			  
6643			; Write instruction to LCD  
6643			;   On entry: A = Instruction byte to be written  
6643			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6643 f5			fLCD_Inst:  PUSH AF  
6644 f5			            PUSH AF  
6645 cd 57 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6648 f1			            POP  AF  
6649 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
664a 17			            RLA  
664b 17			            RLA  
664c 17			            RLA  
664d cd 57 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6650 3e 02		            LD   A, 2  
6652 cd d1 66		            CALL LCDDelay       ;Delay 2 ms to complete   
6655 f1			            POP  AF  
6656 c9			            RET  
6657 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6659 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
665b cb df		            SET  kLCDBitE, A  
665d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
665f cb 9f		            RES  kLCDBitE, A  
6661 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6663 c9			            RET  
6664			  
6664			  
6664			; Write data to LCD  
6664			;   On entry: A = Data byte to be written  
6664			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6664 f5			fLCD_Data:  PUSH AF  
6665 f5			            PUSH AF  
6666 cd 78 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6669 f1			            POP  AF  
666a 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
666b 17			            RLA  
666c 17			            RLA  
666d 17			            RLA  
666e cd 78 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6671 3e 96		            LD   A, 150  
6673 3d			Wait:      DEC  A              ;Wait a while to allow data   
6674 20 fd		            JR   NZ, Wait      ;  write to complete  
6676 f1			            POP  AF  
6677 c9			            RET  
6678 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
667a cb d7		            SET  kLCDBitRS, A  
667c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
667e cb df		            SET  kLCDBitE, A  
6680 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6682 cb 9f		            RES  kLCDBitE, A  
6684 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6686 cb 97		            RES  kLCDBitRS, A  
6688 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
668a c9			            RET  
668b			  
668b			  
668b			; Position cursor to specified location  
668b			;   On entry: A = Cursor position  
668b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
668b f5			fLCD_Pos:   PUSH AF  
668c f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
668e cd 43 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6691 f1			            POP  AF  
6692 c9			            RET  
6693			  
6693			  
6693			; Output text string to LCD  
6693			;   On entry: DE = Pointer to null terminated text string  
6693			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6693 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6694 b7			            OR   A              ;Null terminator?  
6695 c8			            RET  Z              ;Yes, so finished  
6696 cd 64 66		            CALL fLCD_Data      ;Write character to display  
6699 13			            INC  DE             ;Point to next character  
669a 18 f7		            JR   fLCD_Str       ;Repeat  
669c c9					ret  
669d			  
669d			; Define custom character  
669d			;   On entry: A = Character number (0 to 7)  
669d			;             DE = Pointer to character bitmap data  
669d			;   On exit:  A = Next character number  
669d			;             DE = Next location following bitmap  
669d			;             BC HL IX IY I AF' BC' DE' HL' preserved  
669d			; Character is   
669d c5			fLCD_Def:   PUSH BC  
669e f5			            PUSH AF  
669f 07			            RLCA                ;Calculate location  
66a0 07			            RLCA                ;  for bitmap data  
66a1 07			            RLCA                ;  = 8 x CharacterNumber  
66a2 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
66a4 cd 43 66		            CALL fLCD_Inst      ;Write instruction to LCD  
66a7 06 00		            LD   B, 0  
66a9 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
66aa cd 64 66		            CALL fLCD_Data      ;Write byte to display  
66ad 13			            INC  DE             ;Point to next byte  
66ae 04			            INC  B              ;Count bytes  
66af cb 58		            BIT  3, B           ;Finish all 8 bytes?  
66b1 28 f6		            JR   Z, Loop       ;No, so repeat  
66b3 f1			            POP  AF  
66b4 3c			            INC  A              ;Increment character number  
66b5 c1			            POP  BC  
66b6 c9			            RET  
66b7			  
66b7			  
66b7			; **********************************************************************  
66b7			; **  Private functions  
66b7			; **********************************************************************  
66b7			  
66b7			; Write function to LCD  
66b7			;   On entry: A = Function byte to be written  
66b7			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66b7 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
66b9 18 02		            JR   WrFunc  
66bb 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
66bd f5			WrFunc:     PUSH AF  
66be d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66c0 cb df		            SET  kLCDBitE, A  
66c2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66c4 cb 9f		            RES  kLCDBitE, A  
66c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66c8 3e 05		            LD   A, 5  
66ca cd d1 66		            CALL LCDDelay       ;Delay 5 ms to complete  
66cd f1			            POP  AF  
66ce c9			            RET  
66cf			  
66cf			  
66cf			; Delay in milliseconds  
66cf			;   On entry: A = Number of milliseconds delay  
66cf			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66cf 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
66d1 d5			LCDDelay:   PUSH DE  
66d2 5f			            LD   E, A           ;Delay by 'A' ms  
66d3 16 00		            LD   D, 0  
66d5 cd 2f 0a		            CALL aDelayInMS  
66d8 d1			            POP  DE  
66d9 c9			            RET  
66da			  
66da			  
66da			  
66da			  
66da			; eof  
66da			  
# End of file firmware_lcd_4x20.asm
66da			include "firmware_key_4x4.asm" 
66da			  
66da			  
66da			; bit mask for each scan column and row for teing the matrix  
66da			  
66da			; out   
66da 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
66de			; in  
66de 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
66e2			  
66e2			; row/col to character map  
66e2			  
66e2			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
66e2			;    
66e2			  
66e2			; physical key matrix map to face of key  
66e2			  
66e2			  
66e2			;      	1	2	3	A  
66e2			;   	abc”	def&	ghi$	s1  
66e2			;			  
66e2			;	4	5	6	B  
66e2			; 	jkl,	mno.	pqr:	s2  
66e2			;			  
66e2			; 	7	8	9	C  
66e2			;	stu;	vwx@	yz?!	s3  
66e2			;			  
66e2			; 	*	0	#	D  
66e2			; 	shift lck '	Space < >	Enter ( )	s4  
66e2			;       tab bs 		  
66e2			  
66e2			  
66e2			  
66e2			  
66e2			key_init:  
66e2			  
66e2			; SCMonAPI functions used  
66e2			  
66e2			; Alphanumeric LCD functions used  
66e2			; no need to specify specific functions for this module  
66e2			  
66e2			  
66e2 3e cf		            LD   A, 11001111b  
66e4 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
66e6			;            LD   A, 00000000b  
66e6 3e 0f		            LD   A, 00001111b  
66e8 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
66ea			  
66ea			  
66ea				; TODO Configure cursor shapes  
66ea			  
66ea				; Load cursor shapes   
66ea 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
66ec 11 fc 66		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
66ef 06 02		            LD   B, 2           ;Number of characters to define  
66f1 cd 9d 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
66f4 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
66f6			  
66f6 3e 01				ld a, 1  
66f8 32 4d fa			ld (cursor_shape),a  
66fb c9				ret  
66fc			  
66fc			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
66fc			; Up to 8 custom characters can be defined  
66fc			.cursor_shapes:      
66fc			;; Character 0x00 = Normal  
66fc 1f			            DB  11111b  
66fd 1f			            DB  11111b  
66fe 1f			            DB  11111b  
66ff 1f			            DB  11111b  
6700 1f			            DB  11111b  
6701 1f			            DB  11111b  
6702 1f			            DB  11111b  
6703 1f			            DB  11111b  
6704			;; Character 0x01 = Modifier  
6704 1f			            DB  11111b  
6705 1b			            DB  11011b  
6706 1b			            DB  11011b  
6707 1b			            DB  11011b  
6708 1b			            DB  11011b  
6709 1f			            DB  11111b  
670a 1b			            DB  11011b  
670b 1f			            DB  11111b  
670c			  
670c			  
670c			  
670c			  
670c			; Display custom character 0  
670c			;            LD   A, kLCD_Line1+14  
670c			;            CALL fLCD_Pos       ;Position cursor to location in A  
670c			;            LD   A, 0  
670c			;            CALL fLCD_Data      ;Write character in A at cursor  
670c			  
670c			; Display custom character 1  
670c			;            LD   A, kLCD_Line2+14  
670c			;            CALL fLCD_Pos      ;Position cursor to location in A  
670c			;            LD   A, 1  
670c			;            CALL fLCD_Data     ;Write character in A at cursor  
670c			  
670c			; keyboard scanning   
670c			  
670c			  
670c			; key_rows: equ 4  
670c			; key_cols: equ 4  
670c			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
670c			  
670c			; key_scanr: equ key_row_bitmask  
670c			; key_scanc: equ key_col_bitmask  
670c			  
670c			; key_char_map: equ key_map  
670c			  
670c			  
670c			  
670c			; character in from keyboard  
670c			  
670c ..			.matrix_to_char: db "D#0*C987B654A321"  
671c			  
671c			  
671c			; map the physical key to a char dependant on state  
671c			  
671c			.key_map_fa:   
671c			  
671c ..					db 'D'  
671d 0d					db KEY_CR    ; cr  
671e ..					db ' '  
671f 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6720 ..					db 'C'  
6721 ..					db 'y'  
6722 ..					db 'v'  
6723 ..					db 's'  
6724 ..					db 'B'  
6725 ..					db 'p'  
6726 ..					db 'm'  
6727 ..					db 'j'  
6728 ..					db 'A'  
6729 ..					db 'g'  
672a ..					db 'd'  
672b ..					db 'a'  
672c			  
672c			.key_map_fb:  
672c			  
672c ..					db 'A'  
672d ..					db '+'   
672e ..					db '<'  
672f ..					db  "'"    
6730			  
6730 ..					db 'A'  
6731 ..					db 'z'  
6732 ..					db 'w'  
6733 ..					db 't'  
6734 ..					db 'A'  
6735 ..					db 'q'  
6736 ..					db 'n'  
6737 ..					db 'k'  
6738 ..					db 'A'  
6739 ..					db 'h'  
673a ..					db 'e'  
673b ..			 		db 'b'  
673c			  
673c			.key_map_fc:   
673c			  
673c			  
673c ..					db 'A'  
673d ..					db '-'   
673e ..					db '>'  
673f ..					db  '='   	  
6740 ..					db 'A'  
6741 ..					db '?'  
6742 ..					db 'x'  
6743 ..					db 'u'  
6744 ..					db 'A'  
6745 ..					db 'r'  
6746 ..					db 'o'  
6747 ..					db 'l'  
6748 ..					db 'A'  
6749 ..					db 'i'  
674a ..					db 'f'  
674b ..					db 'c'  
674c			  
674c				  
674c			.key_map_fd:  
674c			  
674c ..					db 'A'  
674d ..					db '/'   
674e ..					db '%'   
674f 08					db KEY_BS  ; back space  
6750 ..					db 'A'  
6751 ..					db '!'  
6752 ..					db '@'  
6753 ..					db ';'  
6754 ..					db 'A'  
6755 ..					db ':'  
6756 ..					db '.'  
6757 ..					db ','  
6758 ..					db 'A'  
6759 ..					db '$'  
675a ..					db '&'  
675b ..				 	db '"'  
675c			  
675c					  
675c				  
675c			  
675c			; add cin and cin_wait  
675c			  
675c cd 6d 67		cin_wait: 	call cin  
675f fe 00			cp 0  
6761 28 f9			jr z, cin_wait   ; block until key press  
6763			  
6763 f5				push af   ; save key pressed  
6764			  
6764 cd 6d 67		.cin_wait1:	call cin  
6767 fe 00			cp 0  
6769 20 f9			jr nz, .cin_wait1  	; wait for key release  
676b			  
676b f1				pop af   ; get key  
676c c9				ret  
676d			  
676d			  
676d cd 7e 67		cin: 	call .mtoc  
6770			  
6770				; no key held  
6770 fe 00			cp 0  
6772 c8				ret z  
6773			  
6773				; stop key bounce  
6773			  
6773			;	ld (key_held),a		 ; save it  
6773 47				ld b, a  
6774			  
6774 c5			.cina1:	push bc  
6775 cd 7e 67			call .mtoc  
6778 c1				pop bc  
6779 b8				cp b  
677a 28 f8			jr z, .cina1  
677c 78				ld a,b		  
677d c9				ret  
677e			  
677e			; detect keyboard modifier key press and apply new overlay to the face key held  
677e			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
677e			  
677e			;.cin_map_modifier:   
677e			;	ld a, (hl)  
677e			;	and 255  
677e			;	ret NZ		; modifier key not flagged  
677e			;  
677e			;	; get key face  
677e			;  
677e			;	ld b,(key_face_held)  
677e			;  
677e			;	ld b, key_cols * key_rows  
677e			;  
677e			;	push de  
677e			;	pop hl  
677e			;  
677e			;.mmod1: ld a,(hl)   ; get map test  
677e			;	cp b  
677e			;	jr z, .mmod2  
677e			;  
677e			;  
677e			;  
677e			;.mmod2: inc hl    ;   
677e			;  
677e			;	  
677e			;  
677e			;	  
677e			;  
677e			;	ld hl,key_actual_pressed  
677e			;	ld (hl),a,  
677e			;	ret  
677e			  
677e				  
677e			  
677e			; map matrix key held to char on face of key  
677e			  
677e			.mtoc:  
677e			  
677e			  
677e				; TODO optimise the code....  
677e			  
677e			; scan keyboard row 1  
677e 3e 80			ld a, 128  
6780 21 d3 fb			ld hl, keyscan_table  
6783 cd 65 68			call .rowscan  
6786			  
6786				   
6786			  
6786 3e 40			ld a, 64  
6788 21 d7 fb			ld hl, keyscan_table+key_cols  
678b cd 65 68			call .rowscan  
678e			  
678e			  
678e			  
678e			  
678e 3e 20			ld a, 32  
6790 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6793 cd 65 68			call .rowscan  
6796			  
6796			  
6796			  
6796 3e 10			ld a, 16  
6798 21 df fb			ld hl, keyscan_table+(key_cols*3)  
679b cd 65 68			call .rowscan  
679e			  
679e			  
679e				; flag if key D is held down and remove from reporting  
679e 01 4c 67			ld bc, .key_map_fd    
67a1 21 d3 fb			ld hl, keyscan_table  
67a4 11 c5 fb			ld de, key_fd  
67a7 cd f7 67			call .key_shift_hold  
67aa fe ff			cp 255  
67ac 28 33			jr z, .cinmap  
67ae				; flag if key C is held down and remove from reporting  
67ae 01 3c 67			ld bc, .key_map_fc    
67b1 21 d7 fb			ld hl, keyscan_table+key_cols  
67b4 11 c6 fb			ld de, key_fc  
67b7 cd f7 67			call .key_shift_hold  
67ba fe ff			cp 255  
67bc 28 23			jr z, .cinmap  
67be				; flag if key B is held down and remove from reporting  
67be 01 2c 67			ld bc, .key_map_fb    
67c1 21 db fb			ld hl, keyscan_table+(key_cols*2)  
67c4 11 c7 fb			ld de, key_fb  
67c7 cd f7 67			call .key_shift_hold  
67ca fe ff			cp 255  
67cc 28 13			jr z, .cinmap  
67ce				; flag if key A is held down and remove from reporting  
67ce 01 1c 67			ld bc, .key_map_fa    
67d1 21 df fb			ld hl, keyscan_table+(key_cols*3)  
67d4 11 c8 fb			ld de, key_fa  
67d7 cd f7 67			call .key_shift_hold  
67da fe ff			cp 255  
67dc 28 03			jr z, .cinmap  
67de			  
67de 11 0c 67			ld de, .matrix_to_char  
67e1			  
67e1			  
67e1			.cinmap:   
67e1				if DEBUG_KEY  
67e1			            LD   A, kLCD_Line4  
67e1			            CALL fLCD_Pos       ;Position cursor to location in A  
67e1					push de  
67e1			            LD   DE, keyscan_table  
67e1			            CALL fLCD_Str       ;Display string pointed to by DE  
67e1					pop de  
67e1				endif  
67e1			  
67e1				; scan key matrix table for any held key  
67e1			  
67e1				; de holds either the default matrix or one selected above  
67e1			  
67e1 21 d3 fb			ld hl, keyscan_table  
67e4 06 10			ld b,key_cols*key_rows  
67e6			  
67e6 7e			.cin1:	ld a,(hl)  
67e7 fe 23			cp '#'  
67e9 28 08			jr z, .cinhit  
67eb 23				inc hl  
67ec 13				inc de  
67ed 05				dec b  
67ee 20 f6			jr nz, .cin1  
67f0				; no key found held  
67f0 3e 00			ld a,0  
67f2 c9				ret  
67f3 d5			.cinhit: push de  
67f4 e1				pop hl  
67f5 7e				ld a,(hl)  
67f6 c9				ret  
67f7			  
67f7			; flag a control key is held   
67f7			; hl is key pin, de is flag indicator  
67f7			  
67f7			.key_shift_hold:  
67f7 c5				push bc  
67f8 3e 01			ld a, 1  
67fa 32 4d fa			ld (cursor_shape),a  
67fd 06 00			ld b, 0  
67ff 7e				ld a, (hl)  
6800 fe 2e			cp '.'  
6802 28 0a			jr z, .key_shift1  
6804 06 ff			ld b, 255  
6806 3e 2b			ld a, '+'    ; hide key from later scans  
6808 77				ld (hl),a  
6809 3e 02			ld a, 2  
680b 32 4d fa			ld (cursor_shape),a  
680e			.key_shift1:  
680e				; write flag indicator  
680e 78				ld a,b  
680f 12				ld (de),a  
6810			  
6810 d1				pop de    ; de now holds the key map ptr  
6811 c9				ret  
6812			  
6812				  
6812				  
6812			  
6812			  
6812			  
6812			  
6812			  
6812			  
6812			  
6812			  
6812			  
6812			  
6812 c9				ret  
6813			  
6813			;	push hl  
6813			;	push de  
6813			;	push bc  
6813			;	call keyscan  
6813			;	; map key matrix to ascii value of key face  
6813			;  
6813			;	ld hl, key_face_map  
6813			;	ld de, keyscan_table  
6813			;  
6813			;	; get how many keys to look at  
6813			;	ld b, keyscan_table_len  
6813			;	  
6813			;  
6813			;	; at this stage fall out on first key hit  
6813			;	; TODO handle multiple key press  
6813			;  
6813			;map1:	ld a,(hl)  
6813			;	cp '#'  
6813			;	jr z, keyhit  
6813			;	inc hl  
6813			;	inc de  
6813			;	dec b  
6813			;	jr nz, map1  
6813			;nohit:	ld a, 0  
6813			;	jr keydone  
6813			;keyhit: push de  
6813			;	pop hl  
6813			;	ld a,(hl)  
6813			;keydone:  
6813			;	push bc  
6813			;	push de  
6813			; 	push hl  
6813			;	ret   
6813			;  
6813			  
6813			  
6813			  
6813			  
6813			; scan physical key matrix  
6813			  
6813			  
6813			;keyscan:  
6813			;  
6813			;; for each key_row use keyscanr bit mask for out  
6813			;; then read in for keyscanc bitmask  
6813			;; save result of row scan to keyscantable  
6813			;  
6813			;; scan keyboard row 1  
6813			;  
6813			;	ld b, key_rows  
6813			;	ld hl, key_scanr  
6813			;	ld de, keyscan_table  
6813			;  
6813			;rowloop:  
6813			;  
6813			;	ld a,(hl)		; out bit mask to energise keyboard row  
6813			;	call rowscan  
6813			;	inc hl  
6813			;	dec b  
6813			;	jr nz, rowloop  
6813			;  
6813			;	ret  
6813			;  
6813			;  
6813			;; pass a out bitmask, b row number  
6813			;arowscan:   
6813			;	push bc  
6813			;  
6813			;	ld d, b  
6813			;  
6813			;	; calculate buffer location for this row  
6813			;  
6813			;	ld hl, keyscan_table	  
6813			;kbufr:  ld e, key_cols  
6813			;kbufc:	inc hl  
6813			;	dec e  
6813			;	jr nz, kbufc  
6813			;	dec d  
6813			;	jr nz, kbufr  
6813			;  
6813			;	; energise row and read columns  
6813			;  
6813			;	out (portbdata),a  
6813			;	in a,(portbdata)  
6813			;	ld c,a  
6813			;  
6813			;  
6813			;	; save buffer loc  
6813			;  
6813			;	ld (keybufptr), hl  
6813			;  
6813			;	ld hl, key_scanc  
6813			;	ld d, key_cols  
6813			;  
6813			;	; for each column check each bit mask  
6813			;  
6813			;colloop:  
6813			;	  
6813			;  
6813			;	; reset flags for the row   
6813			;  
6813			;	ld b,'.'  
6813			;	and (hl)  
6813			;	jr z, maskskip  
6813			;	ld b,'#'  
6813			;maskskip:  
6813			;	; save  key state  
6813			;	push hl  
6813			;	ld hl, (keybufptr)  
6813			;	ld (hl), b  
6813			;	inc hl  
6813			;	ld (keybufptr), hl  
6813			;  
6813			;	; move to next bit mask  
6813			;	pop hl  
6813			;	inc hl  
6813			;  
6813			;	dec d  
6813			;	jr nz, colloop  
6813			;  
6813			;	ret  
6813			;  
6813			;  
6813			;;  
6813			; lcd functions  
6813			;  
6813			;  
6813			  
6813			;if DEBUG_KEY_MATRIX  
6813			  
6813			; test function to display hardware view of matrix state  
6813			  
6813			matrix:  
6813			  
6813			  
6813			  
6813			; scan keyboard row 1  
6813 3e 80			ld a, 128  
6815 21 f8 fb			ld hl, keyscan_table_row1  
6818 cd 65 68			call .rowscan  
681b			  
681b 3e 40			ld a, 64  
681d 21 f3 fb			ld hl, keyscan_table_row2  
6820 cd 65 68			call .rowscan  
6823			  
6823 3e 20			ld a, 32  
6825 21 ee fb			ld hl, keyscan_table_row3  
6828 cd 65 68			call .rowscan  
682b			  
682b 3e 10			ld a, 16  
682d 21 e9 fb			ld hl, keyscan_table_row4  
6830 cd 65 68			call .rowscan  
6833			  
6833			; Display text on first line  
6833 3e 00		            LD   A, kLCD_Line1  
6835 cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6838 11 f8 fb		            LD   DE, keyscan_table_row1  
683b			            ;LD   DE, MsgHello  
683b cd 93 66		            CALL fLCD_Str       ;Display string pointed to by DE  
683e			  
683e			; Display text on second line  
683e 3e 40		            LD   A, kLCD_Line2  
6840 cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6843 11 f3 fb		            LD   DE, keyscan_table_row2  
6846 cd 93 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6849 3e 14		            LD   A, kLCD_Line3  
684b cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
684e 11 ee fb		            LD   DE, keyscan_table_row3  
6851 cd 93 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6854 3e 54		            LD   A, kLCD_Line4  
6856 cd 8b 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6859 11 e9 fb		            LD   DE, keyscan_table_row4  
685c cd 93 66		            CALL fLCD_Str       ;Display string pointed to by DE  
685f			  
685f cd 3e 0a			call delay250ms  
6862 c3 13 68			jp matrix  
6865			  
6865			; pass de as row display flags  
6865			.rowscan:   
6865 d3 c1			out (portbdata),a  
6867 db c1			in a,(portbdata)  
6869 4f				ld c,a  
686a				; reset flags for the row   
686a 06 2e			ld b,'.'  
686c e6 01			and 1  
686e 28 02			jr z, .p1on  
6870 06 23			ld b,'#'  
6872			.p1on:  
6872 70				ld (hl), b  
6873 23				inc hl  
6874			  
6874 06 2e			ld b,'.'  
6876 79				ld a,c  
6877 e6 02			and 2  
6879			;	bit 0,a  
6879 28 02			jr z, .p2on  
687b 06 23			ld b,'#'  
687d			.p2on:  
687d 70				ld (hl), b  
687e 23				inc hl  
687f			;  
687f 06 2e			ld b,'.'  
6881 79				ld a,c  
6882 e6 04			and 4  
6884			;;	bit 0,a  
6884 28 02			jr z, .p3on  
6886 06 23			ld b,'#'  
6888			.p3on:  
6888 70				ld (hl), b  
6889 23				inc hl  
688a			;;  
688a 06 2e			ld b,'.'  
688c			;;	bit 0,a  
688c 79				ld a,c  
688d e6 08			and 8  
688f 28 02			jr z, .p4on  
6891 06 23			ld b,'#'  
6893			.p4on:  
6893 70				ld (hl), b  
6894 23				inc hl  
6895			  
6895			; zero term  
6895 06 00			ld b,0  
6897 70				ld (hl), b  
6898			  
6898 c9			.rscandone: ret  
6899			  
6899			  
6899			  
6899			;endif  
6899			  
6899			  
6899			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6899
