# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 fa 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 256  
0003			  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 128  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 128  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 128  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 offsets for settings  
0003			  
0003			; if set then skip prompt for start up and accept all  
0003			  
0003			STORE_0_QUICKSTART: equ $25  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0003			  
0003			hardware_config: equ key_face_held - 10  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_config - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003				  
0003			  
0003					;ld a, 0  
0003					;ld (hardware_diag), a  
0003			  
0003					; clear all the buffers  
0003			  
0003 21 f9 fd				ld hl, display_fb1  
0006 22 55 fd				ld (display_fb_active), hl  
0009			  
0009 cd a6 0b				call clear_display  
000c			  
000c 21 57 fd				ld hl, display_fb2  
000f 22 55 fd				ld (display_fb_active), hl  
0012			  
0012 cd a6 0b				call clear_display  
0015			  
0015					; init primary frame buffer area  
0015 21 4a fe				ld hl, display_fb0  
0018 22 55 fd				ld (display_fb_active), hl  
001b			  
001b cd a6 0b				call clear_display  
001e			  
001e			  
001e cd 5e 67				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0021			  
0021 cd a7 68			call key_init  
0024 cd 9f 01			call storage_init  
0027			  
0027				; setup malloc functions  
0027			  
0027				if MALLOC_1  
0027 cd 7d 12				call  heap_init  
002a				endif  
002a				if MALLOC_4  
002a					call  heap_init  
002a				endif  
002a			  
002a				; init sound hardware if present  
002a			  
002a				if SOUND_ENABLE  
002a					call sound_init  
002a				endif  
002a			  
002a				; lcd test sequence  
002a					  
002a cd c9 0b			call update_display  
002d cd 23 0b			call delay1s  
0030 3e 2b			ld a,'+'  
0032 cd ab 0b			call fill_display  
0035 cd c9 0b			call update_display  
0038 cd 23 0b			call delay1s  
003b 3e 2a			ld a,'*'  
003d cd ab 0b			call fill_display  
0040 cd c9 0b			call update_display  
0043 cd 23 0b			call delay1s  
0046 3e 2d			ld a,'-'  
0048 cd ab 0b			call fill_display  
004b cd c9 0b			call update_display  
004e cd 23 0b			call delay1s  
0051			  
0051			; boot splash screen  
0051			if display_cols == 20	  
0051 3e 00		        ld a, display_row_1    
0053			else  
0053			        ld a, display_row_1 +10   
0053			endif  
0053 11 2d 19			ld de, prom_bootmsg  
0056 cd b9 0b			call str_at_display  
0059 cd c9 0b			call update_display  
005c			  
005c			  
005c cd 23 0b			call delay1s  
005f cd 23 0b			call delay1s  
0062			if display_cols == 20	  
0062 3e 2a		            LD   A, display_row_3+2  
0064			else  
0064			            LD   A, display_row_3+12  
0064			endif  
0064 11 42 19			ld de, prom_bootmsg1  
0067 cd b9 0b			call str_at_display  
006a cd c9 0b			call update_display  
006d cd 23 0b			call delay1s  
0070 cd 23 0b			call delay1s  
0073			  
0073			;	ld a, display_row_4+3  
0073			;	ld de, bootmsg2  
0073			;	call str_at_display  
0073			;	call update_display  
0073			;	call delay1s  
0073			;	call delay1s  
0073			  
0073			; debug mark setup  
0073			  
0073 3e 5f		ld a, '_'  
0075 32 b4 fe		ld (debug_mark),a  
0078 32 b5 fe		ld (debug_mark+1),a  
007b 32 b6 fe		ld (debug_mark+2),a  
007e 3e 00		ld a,0  
0080 32 b7 fe		ld (debug_mark+3),a  
0083			  
0083 c9					ret  
0084			  
0084			  
0084			;bootmsg2:	db "Firmware v0.1",0  
0084			  
0084			; a 4x20 lcd  
0084			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
0084			  
0084			;if display_cols == 20  
0084			;	include "firmware_lcd_4x20.asm"  
0084			;endif  
0084			  
0084			;if display_cols == 40  
0084			;	include "firmware_lcd_4x40.asm"  
0084			;endif  
0084			  
0084			;  
0084			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
0084			; TODO abstract the bit bang video out interface for dual display  
0084			; TODO wire video out to tx pin on rc2014 bus  
0084			  
0084			; must supply cin, and cin_wait for low level hardware abstraction   
0084			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
0084			; test scancode  
0084			  
0084			;;;;;  
0084			;;;  
0084			; Moved out to mini and maxi versions  
0084			;  
0084			; include "firmware_key_4x4.asm"  
0084			; using existing 4 wire x 4 resistor array for input  
0084			;include "firmware_key_4x10.asm"  
0084			; need to mod the board for 5 rows due to resistor array  
0084			;include "firmware_key_5x10.asm"  
0084			  
0084			; storage hardware interface  
0084			  
0084			; use microchip serial eeprom for storage  
0084			  
0084			  
0084			if STORAGE_SE  
0084				include "firmware_spi.asm"  
0084			; my spi protocol (used by storage) 
0084			 
0084			; SPI pins 
0084			 
0084			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
0084			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
0084			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
0084			 
0084			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
0084			; chip pin 4 gnd 
0084			 
0084			 
0084			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
0084			SPI_CE1: equ 1      ;    port a1 pin 14  
0084			SPI_CE2: equ 2      ;    port a2 pin pin 13 
0084			SPI_CE3: equ 3      ; port    a3 pin pin 12 
0084			SPI_CE4: equ 4      ; port a4     pin 10 
0084			 
0084			; active low AND masks 
0084			 
0084			;SPI_CE0_MASK: equ    255-1 
0084			;SPI_CE1_MASK: equ   255-2 
0084			;SPI_CE2_MASK: equ   255-4 
0084			;SPI_CE3_MASK: equ   255-8 
0084			;SPI_CE4_MASK: equ   255-16 
0084			SPI_CE_HIGH:  equ 255 
0084			 
0084			 
0084			 
0084			 
0084			; TODO store port id for spi device ie dev c 
0084			; TODO store pin for SO 
0084			; TODO store pin for SI 
0084			; TODO store pin for SCLK 
0084			 
0084			; 
0084			 
0084			; ensure that spi bus is in a stable state with default pins  
0084			 
0084			se_stable_spi:   
0084			 
0084				 ; set DI high, CE high , SCLK low 
0084				;ld a, SPI_DI | SPI_CE0 
0084 3e 07			ld a, SPI_DI  
0086 cd 5a 01			call spi_ce_high 
0089 d3 80			 out (storage_adata),a 
008b 32 c6 fc			ld (spi_portbyte),a 
008e			 
008e				if DEBUG_SPI 
008e					push hl 
008e					ld l, a 
008e					DMARK "SPI" 
008e					CALLMONITOR 
008e					pop hl 
008e				endif 
008e c9				ret 
008f			 
008f			; byte to send in a 
008f			 
008f			spi_send_byte: 
008f				; save byte to send for bit mask shift out 
008f 4f			        ld c,a 
0090 3a c6 fc			ld a,(spi_portbyte) 
0093				  
0093				; clock out	each bit of the byte msb first 
0093			 
0093 06 08			ld b, 8 
0095			.ssb1: 
0095				; clear so bit  
0095 cb bf			res SPI_DI, a 
0097 cb 11			rl c 
0099				; if bit 7 is set then carry is set 
0099 30 02			jr nc, .ssb2 
009b cb ff			set SPI_DI,a 
009d			.ssb2:  ; output bit to ensure it is stable 
009d d3 80			out (storage_adata),a 
009f 00				nop 
00a0				; clock bit high 
00a0 cb ef			set SPI_SCLK,a 
00a2 d3 80			out (storage_adata),a 
00a4 00				nop 
00a5				; then low 
00a5 cb af			res SPI_SCLK,a 
00a7 d3 80			out (storage_adata),a 
00a9 00				nop 
00aa 10 e9			djnz .ssb1 
00ac			 
00ac 32 c6 fc			ld (spi_portbyte),a 
00af c9				ret 
00b0			 
00b0			; TODO low level get byte into A on spi 
00b0			 
00b0			spi_read_byte:  
00b0			 
00b0				; save byte to send for bit mask shift out 
00b0 0e 00		    ld c,0 
00b2 3a c6 fc			ld a,(spi_portbyte) 
00b5				  
00b5				; clock out	each bit of the byte msb first 
00b5			 
00b5			 
00b5				; clock bit high 
00b5 cb ef			set SPI_SCLK,a 
00b7 d3 80			out (storage_adata),a 
00b9 00				nop 
00ba			 
00ba			    ; read DO  
00ba			 
00ba cb f9		    set 7,c 
00bc db 80			in a,(storage_adata) 
00be cb 77		    bit SPI_DO,a 
00c0 20 02		    jr nz, .b7 
00c2 cb b9		    res 7,c 
00c4			.b7: 
00c4				; then low 
00c4 cb af			res SPI_SCLK,a 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9			     
00c9			 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce			 
00ce			    ; read DO  
00ce			 
00ce cb f1		    set 6,c 
00d0 db 80			in a,(storage_adata) 
00d2 cb 77		    bit SPI_DO,a 
00d4 20 02		    jr nz, .b6 
00d6 cb b1		    res 6,c 
00d8			.b6: 
00d8				; then low 
00d8 cb af			res SPI_SCLK,a 
00da d3 80			out (storage_adata),a 
00dc 00				nop 
00dd			 
00dd				; clock bit high 
00dd cb ef			set SPI_SCLK,a 
00df d3 80			out (storage_adata),a 
00e1 00				nop 
00e2			 
00e2			 
00e2			    ; read DO  
00e2			 
00e2 cb e9		    set 5,c 
00e4 db 80			in a,(storage_adata) 
00e6 cb 77		    bit SPI_DO,a 
00e8 20 02		    jr nz, .b5 
00ea cb a9		    res 5,c 
00ec			.b5: 
00ec				; then low 
00ec cb af			res SPI_SCLK,a 
00ee d3 80			out (storage_adata),a 
00f0 00				nop 
00f1				; clock bit high 
00f1 cb ef			set SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			 
00f6			    ; read DO  
00f6			 
00f6 cb e1		    set 4,c 
00f8 db 80			in a,(storage_adata) 
00fa cb 77		    bit SPI_DO,a 
00fc 20 02		    jr nz, .b4 
00fe cb a1		    res 4,c 
0100			.b4: 
0100				; then low 
0100 cb af			res SPI_SCLK,a 
0102 d3 80			out (storage_adata),a 
0104 00				nop 
0105				; clock bit high 
0105 cb ef			set SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a			    ; read DO  
010a			 
010a cb d9		    set 3,c 
010c db 80			in a,(storage_adata) 
010e cb 77		    bit SPI_DO,a 
0110 20 02		    jr nz, .b3 
0112 cb 99		    res 3,c 
0114			.b3: 
0114				; then low 
0114 cb af			res SPI_SCLK,a 
0116 d3 80			out (storage_adata),a 
0118 00				nop 
0119				; clock bit high 
0119 cb ef			set SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e			 
011e			    ; read DO  
011e			 
011e cb d1		    set 2,c 
0120 db 80			in a,(storage_adata) 
0122 cb 77		    bit SPI_DO,a 
0124 20 02		    jr nz, .b2 
0126 cb 91		    res 2,c 
0128			.b2: 
0128				; then low 
0128 cb af			res SPI_SCLK,a 
012a d3 80			out (storage_adata),a 
012c 00				nop 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132			 
0132			    ; read DO  
0132			 
0132 cb c9		    set 1,c 
0134 db 80			in a,(storage_adata) 
0136 cb 77		    bit SPI_DO,a 
0138 20 02		    jr nz, .b1 
013a cb 89		    res 1,c 
013c			.b1: 
013c				; then low 
013c cb af			res SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141				; clock bit high 
0141 cb ef			set SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146			 
0146			    ; read DO  
0146			 
0146 cb c1		    set 0,c 
0148 db 80			in a,(storage_adata) 
014a cb 77		    bit SPI_DO,a 
014c 20 02		    jr nz, .b0 
014e cb 81		    res 0,c 
0150			.b0: 
0150				; then low 
0150 cb af			res SPI_SCLK,a 
0152 d3 80			out (storage_adata),a 
0154 00				nop 
0155			 
0155			 
0155 32 c6 fc			ld (spi_portbyte),a 
0158			 
0158			    ; return byte 
0158 79			    ld a,c 
0159			 
0159			 
0159 c9				ret 
015a			 
015a			 
015a			 
015a			spi_ce_high: 
015a			 
015a				if DEBUG_SPI_HARD_CE0 
015a			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
015a					ret 
015a			 
015a				endif 
015a			 
015a			 
015a f5				push af 
015b			 
015b				; send direct ce to port b 
015b 3e ff			ld a, 255 
015d d3 81			out (storage_bdata), a 
015f			 
015f f1				pop af 
0160			 
0160				; for port a that shares with spi lines AND the mask 
0160			  
0160				if DEBUG_SPI 
0160					push hl 
0160					ld h, a 
0160				endif 
0160			;	ld c, SPI_CE_HIGH 
0160			;	and c 
0160 cb c7			set SPI_CE0, a 
0162 cb cf			set SPI_CE1, a 
0164 cb d7			set SPI_CE2, a 
0166 cb df			set SPI_CE3, a 
0168 cb e7			set SPI_CE4, a 
016a			 
016a				if DEBUG_SPI 
016a					ld l, a 
016a					DMARK "CEh" 
016a					CALLMONITOR 
016a					pop hl 
016a				endif 
016a c9				ret 
016b			 
016b			 
016b			spi_ce_low: 
016b			 
016b				if DEBUG_SPI_HARD_CE0 
016b			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
016b					ret 
016b			 
016b				endif 
016b			 
016b c5				push bc 
016c f5				push af 
016d			 
016d				; send direct ce to port b 
016d 3a c8 fc			ld a, (spi_cartdev) 
0170 d3 81			out (storage_bdata), a 
0172			 
0172			 
0172			 
0172				; for port a that shares with spi lines AND the mask 
0172			 
0172 3a c5 fc			ld a, (spi_device)  
0175 4f				ld c, a 
0176			 
0176 f1				pop af 
0177			 
0177				; detect CEx 
0177			 
0177				if DEBUG_SPI 
0177					push hl 
0177					ld h, a 
0177				endif 
0177			 
0177 cb 41			bit SPI_CE0, c 
0179 20 04			jr nz, .cel1 
017b cb 87			res SPI_CE0, a 
017d 18 1e			jr .celn 
017f			.cel1: 
017f cb 49			bit SPI_CE1, c 
0181 20 04			jr nz, .cel2 
0183 cb 8f			res SPI_CE1, a 
0185 18 16			jr .celn 
0187			.cel2: 
0187 cb 51			bit SPI_CE2, c 
0189 20 04			jr nz, .cel3 
018b cb 97			res SPI_CE2, a 
018d 18 0e			jr .celn 
018f			.cel3: 
018f cb 59			bit SPI_CE3, c 
0191 20 04			jr nz, .cel4 
0193 cb 9f			res SPI_CE3, a 
0195 18 06			jr .celn 
0197			.cel4: 
0197 cb 61			bit SPI_CE4, c 
0199 20 02			jr nz, .celn 
019b cb a7			res SPI_CE4, a 
019d			.celn: 
019d			 
019d			 
019d			 
019d			;	add c 
019d			 
019d				if DEBUG_SPI 
019d					ld l, a 
019d					DMARK "CEl" 
019d					CALLMONITOR 
019d					pop hl 
019d				endif 
019d c1				pop bc 
019e c9				ret 
019f			 
019f			 
019f			 
019f			; eof 
019f			 
019f			 
019f			 
019f			 
019f			 
# End of file firmware_spi.asm
019f				include "firmware_seeprom.asm"  
019f			; 
019f			; persisent storage interface via microchip serial eeprom 
019f			 
019f			; port a pio 2 
019f			; pa 7 - si 
019f			; pa 6 - sclk  
019f			; pa 5 - so 
019f			; pa 4 - cs 
019f			; pa 3 - cs 
019f			; pa 2 - cs 
019f			; pa 1 - cs 
019f			; pa 0 - cs 
019f			; 
019f			; TODO get block 
019f			; TODO save block 
019f			; TODO load file 
019f			; TODO save file 
019f			; TODO get dir  
019f			 
019f			;  
019f			storage_adata: equ Device_C    ; device c port a - onboard storage 
019f			storage_actl: equ Device_C+2     ; device c port a 
019f			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
019f			storage_bctl: equ Device_C+3     ; device c port b 
019f			 
019f			 
019f			; TODO move these to hardware driver file 
019f			 
019f			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
019f			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
019f			; storage bank file system format 
019f			; 
019f			; first page of bank: 
019f			; 	addr 0 - status check 
019f			;       addr 1 - write protect flag 
019f			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
019f			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
019f			;         TODO see if scanning whole of for available next file id is fast enough 
019f			;	addr 4 > zero term string of bank label 
019f			; 
019f			;        
019f			;  
019f			; first page of any file: 
019f			;      byte 0 - file id  
019f			;      byte 1-17 - fixed file name  
019f			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
019f			; 
019f			; other pages of any file: 
019f			;      byte 0 - file id 
019f			;      byte 1> - file data 
019f			; 
019f			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
019f			;  
019f			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
019f			 
019f			 
019f			;storage_so_bit: 5 
019f			;storage_si_bit: 7 
019f			;storage_sclk_bit: 6 
019f			  
019f			 
019f			; init storage pio 
019f			 
019f			storage_init: 
019f			 
019f 3e cf		            LD   A, 11001111b 
01a1 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01a3 3e 00		            LD   A, 00000000b 
01a5 cb f7			set SPI_DO,a 
01a7			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01a7 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01a9			 
01a9 3e cf		            LD   A, 11001111b 
01ab d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01ad 3e 00		            LD   A, 00000000b 
01af d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01b1			 
01b1				; set all external spi devices off 
01b1 3e 00			ld a, 0 
01b3 32 c5 fc			ld (spi_device), a 
01b6 32 c8 fc			ld (spi_cartdev), a 
01b9			 
01b9					; ensure the spi bus is in a default stable state 
01b9 cd 84 00				call se_stable_spi 
01bc			 
01bc			; TODO scan spi bus and gather which storage banks are present 
01bc			 
01bc			; populate store_bank_active  
01bc			; for each ce line activate and attempt to write first byte of bank and read back 
01bc			; if zero is returned then bank is empty 
01bc			;   
01bc			; 
01bc			 
01bc					; init file extent cache to save on slow reads 
01bc			 
01bc			;	ld hl, store_filecache 
01bc			;	ld de, 0 
01bc			;	ld hl,(de)	 
01bc			 
01bc			 
01bc c9			    ret 
01bd			 
01bd			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01bd			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01bd			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01bd			 
01bd			; INSTRUCTION SET 
01bd			; READ 0000 0011 Read data from memory array beginning at selected address 
01bd			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01bd			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01bd			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01bd			; RDSR 0000 0101 Read STATUS register 
01bd			; WRSR 0000 0001 Write STATUS register 
01bd			; PE 0100 0010 Page Erase – erase one page in memory array 
01bd			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01bd			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01bd			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01bd			 
01bd			; TODO send byte steam for page without setting the address for every single byte 
01bd			; TODO read byte  
01bd			 
01bd			; byte in a 
01bd			; address in hl  
01bd			se_writebyte: 
01bd			        
01bd			    ;   ld c, a 
01bd f5			        push af 
01be e5			        push hl 
01bf			 
01bf			    ; initi write mode 
01bf			    ; 
01bf			    ;CS low 
01bf			 
01bf 3a c6 fc		       ld a,(spi_portbyte) 
01c2 cd 6b 01			call spi_ce_low 
01c5			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c5 d3 80		       out (storage_adata),a 
01c7 32 c6 fc		       ld (spi_portbyte), a 
01ca			 
01ca			    ;clock out wren instruction 
01ca			 
01ca 3e 06		    ld a, store_wren_ins 
01cc cd 8f 00		    call spi_send_byte  
01cf			 
01cf			    ;cs high to enable write latch 
01cf			 
01cf 3a c6 fc		       ld a,(spi_portbyte) 
01d2 cd 5a 01			call spi_ce_high 
01d5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01d5 d3 80		       out (storage_adata),a 
01d7 32 c6 fc		       ld (spi_portbyte), a 
01da			 
01da 00				nop 
01db			    ; 
01db			    ; intial write data 
01db			    ; 
01db			    ; cs low 
01db			     
01db 3a c6 fc		       ld a,(spi_portbyte) 
01de cd 6b 01			call spi_ce_low 
01e1			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e1 d3 80		       out (storage_adata),a 
01e3 32 c6 fc		       ld (spi_portbyte), a 
01e6			 
01e6			    ; clock out write instruction 
01e6			     
01e6 3e 02		    ld a, store_write_ins  
01e8 cd 8f 00		    call spi_send_byte  
01eb			 
01eb			    ; clock out address (depending on address size) 
01eb			     
01eb e1			    pop hl 
01ec 7c			    ld a,h    ; address out msb first 
01ed cd 8f 00		    call spi_send_byte  
01f0 7d			    ld a,l 
01f1 cd 8f 00		    call spi_send_byte  
01f4			 
01f4			    ; clock out byte(s) for page 
01f4			 
01f4 f1			    pop af 
01f5 cd 8f 00		    call spi_send_byte  
01f8			 
01f8			    ; end write with ce high 
01f8 3a c6 fc		       ld a,(spi_portbyte) 
01fb			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
01fb cd 5a 01			call spi_ce_high 
01fe d3 80		       out (storage_adata),a 
0200 32 c6 fc		       ld (spi_portbyte), a 
0203			 
0203				; pause for internal write cycle 
0203 3e 0a			ld a, 10 
0205 cd 08 0b			call aDelayInMS 
0208 c9			    ret 
0209			 
0209			; buffer to write in de 
0209			; address in hl  
0209			se_writepage: 
0209			        
0209			    ;   ld c, a 
0209 d5				push de 
020a e5			        push hl 
020b			 
020b			    ; initi write mode 
020b			    ; 
020b			    ;CS low 
020b			 
020b 3a c6 fc		       ld a,(spi_portbyte) 
020e cd 6b 01			call spi_ce_low 
0211			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211 d3 80		       out (storage_adata),a 
0213 32 c6 fc		       ld (spi_portbyte), a 
0216			 
0216			    ;clock out wren instruction 
0216			 
0216 3e 06		    ld a, store_wren_ins 
0218 cd 8f 00		    call spi_send_byte  
021b			 
021b			    ;cs high to enable write latch 
021b			 
021b 3a c6 fc		       ld a,(spi_portbyte) 
021e cd 5a 01			call spi_ce_high 
0221			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0221 d3 80		       out (storage_adata),a 
0223 32 c6 fc		       ld (spi_portbyte), a 
0226			 
0226 00				nop 
0227			    ; 
0227			    ; intial write data 
0227			    ; 
0227			    ; cs low 
0227			     
0227 3a c6 fc		       ld a,(spi_portbyte) 
022a			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022a cd 6b 01			call spi_ce_low 
022d d3 80		       out (storage_adata),a 
022f 32 c6 fc		       ld (spi_portbyte), a 
0232			 
0232			    ; clock out write instruction 
0232			     
0232 3e 02		    ld a, store_write_ins  
0234 cd 8f 00		    call spi_send_byte  
0237			 
0237			    ; clock out address (depending on address size) 
0237			     
0237 e1			    pop hl 
0238 7c			    ld a,h    ; address out msb first 
0239 cd 8f 00		    call spi_send_byte  
023c 7d			    ld a,l 
023d cd 8f 00		    call spi_send_byte  
0240			 
0240			    ; clock out byte(s) for page 
0240			 
0240 e1				pop hl 
0241 06 40			ld b, STORE_BLOCK_PHY 
0243			.bytewrite: 
0243			 
0243 7e				ld a,(hl) 
0244 e5			    push hl 
0245 c5				push bc 
0246 cd 8f 00		    call spi_send_byte  
0249 c1				pop bc 
024a e1				pop hl 
024b			 
024b			    ; end write with ce high 
024b 3a c6 fc		       ld a,(spi_portbyte) 
024e cd 5a 01			call spi_ce_high 
0251			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0251 d3 80		       out (storage_adata),a 
0253 32 c6 fc		       ld (spi_portbyte), a 
0256			 
0256 23				inc hl 
0257 10 ea			djnz .bytewrite 
0259			 
0259				; pause for internal write cycle 
0259 3e 64			ld a, 100 
025b cd 08 0b			call aDelayInMS 
025e c9			    ret 
025f			; returns byte in a 
025f			; address in hl  
025f			se_readbyte: 
025f d5				push de 
0260 c5				push bc 
0261			 
0261			    ;   ld c, a 
0261 e5			        push hl 
0262			 
0262			    ; initi write mode 
0262			    ; 
0262			    ;CS low 
0262			 
0262 3a c6 fc		       ld a,(spi_portbyte) 
0265 cd 6b 01			call spi_ce_low 
0268			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0268 d3 80		       out (storage_adata),a 
026a 32 c6 fc		       ld (spi_portbyte), a 
026d			 
026d			    ;clock out wren instruction 
026d			 
026d 3e 03		    ld a, store_read_ins 
026f cd 8f 00		    call spi_send_byte  
0272			 
0272			 
0272			    ; clock out address (depending on address size) 
0272			     
0272 e1			    pop hl 
0273 7c			    ld a,h    ; address out msb first 
0274 cd 8f 00		    call spi_send_byte  
0277 7d			    ld a,l 
0278 cd 8f 00		    call spi_send_byte  
027b			 
027b			    ; clock in byte(s) for page 
027b			 
027b cd b0 00		    call spi_read_byte  
027e f5				push af 
027f			 
027f			    ; end write with ce high 
027f 3a c6 fc		       ld a,(spi_portbyte) 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0282 cd 5a 01			call spi_ce_high 
0285 d3 80		       out (storage_adata),a 
0287 32 c6 fc		       ld (spi_portbyte), a 
028a			 
028a f1				pop af 
028b			 
028b c1				pop bc 
028c d1				pop de 
028d			 
028d c9			    ret 
028e			 
028e			if DEBUG_STORESE 
028e			 
028e			storageput:  
028e			 
028e			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
028e			 
028e 21 5c f4			ld hl,scratch+2 
0291 cd 91 11			call get_word_hl 
0294			 
0294				; stuff it here for the moment as it will be overwritten later anyway 
0294			 
0294 22 7d f7			ld (os_cur_ptr),hl	 
0297			 
0297			 
0297			; get pointer to start of string 
0297			 
0297 21 61 f4			ld hl, scratch+7 
029a			 
029a			; loop writing char of string to eeprom 
029a			 
029a 7e			.writestr:	ld a,(hl) 
029b fe 00				cp 0 
029d 28 12				jr z, .wsdone		; done writing 
029f e5					push hl 
02a0 2a 7d f7				ld hl,(os_cur_ptr) 
02a3 cd bd 01				call se_writebyte 
02a6			 
02a6 2a 7d f7				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02a9 23					inc hl 
02aa 22 7d f7				ld (os_cur_ptr),hl 
02ad			 
02ad					; restore string pointer and get next char 
02ad			 
02ad e1					pop hl 
02ae 23					inc hl 
02af 18 e9				jr .writestr 
02b1			 
02b1			 
02b1			 
02b1			.wsdone: 
02b1			 
02b1			 
02b1			; when done load first page into a buffer  
02b1			 
02b1 21 00 80				ld hl,08000h		; start in ram 
02b4 22 7d f7				ld (os_cur_ptr),hl 
02b7 21 00 00				ld hl, 0		 ; start of page 
02ba 22 82 f4				ld (scratch+40),hl	; hang on to it 
02bd			 
02bd 06 80				ld b, 128		; actually get more then one page 
02bf c5			.wsload:	push bc 
02c0 2a 82 f4				ld hl,(scratch+40) 
02c3 e5					push hl 
02c4 cd 5f 02				call se_readbyte 
02c7			 
02c7					; a now as the byte 
02c7			 
02c7 2a 7d f7				ld hl,(os_cur_ptr) 
02ca 77					ld (hl),a 
02cb					; inc next buffer area 
02cb 23					inc hl 
02cc 22 7d f7				ld (os_cur_ptr),hl 
02cf			 
02cf					; get eeprom position, inc and save for next round 
02cf e1					pop hl		 
02d0 23					inc hl 
02d1 22 82 f4				ld (scratch+40),hl 
02d4 c1					pop bc 
02d5 10 e8				djnz .wsload 
02d7			 
02d7			; set 'd' pointer to start of buffer 
02d7			 
02d7 21 00 80				ld hl,08000h 
02da 22 7d f7				ld (os_cur_ptr),hl 
02dd			 
02dd			 
02dd c9			ret 
02de			 
02de			 
02de c9			storageread: ret 
02df			 
02df			 
02df			 
02df			 
02df			 
02df			 
02df			endif 
02df			 
02df			 
02df			 
# End of file firmware_seeprom.asm
02df			else  
02df			   ; create some stubs for the labels  
02df			se_readbyte: ret  
02df			se_writebyte: ret  
02df			storage_init: ret  
02df			  
02df			endif  
02df			  
02df			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02df			;include "firmware_cf.asm"  
02df			  
02df			; load up high level storage hardward abstractions  
02df			include "firmware_storage.asm"  
02df			 
02df			; persisent storage hardware abstraction layer  
02df			 
02df			 
02df			 
02df			; Block 0 on storage is a config state 
02df			 
02df			 
02df			 
02df			; TODO add read phy block and write phy block functions 
02df			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02df			 
02df			; Abstraction layer  
02df			 
02df			; Logocial block size is same size as physical size - using tape concept 
02df			 
02df			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02df			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02df			 
02df			 
02df			 
02df			; Filesystem layout (Logical layout) 
02df			; 
02df			; Block 0 - Bank config  
02df			; 
02df			;      Byte - 0 file id counter 
02df			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02df			;      Byte - 3-20 zero terminated bank label 
02df			; 
02df			; Block 1 > File storage 
02df			; 
02df			;      Byte 0 file id    - block 0 file details 
02df			;      Byte 1 block id - block 0 is file  
02df			;            Byte 2-15 - File name 
02df			; 
02df			;       - to end of block data 
02df			; 
02df			 
02df			; Get ID for the file named in pointer held HL 
02df			; Returns ID in HL = 255 if no file found 
02df			 
02df			storage_getid: 
02df			 
02df 22 dd fc			ld (store_tmp1), hl 
02e2			 
02e2				if DEBUG_STORESE 
02e2					DMARK "SGI" 
02e2 f5				push af  
02e3 3a f7 02			ld a, (.dmark)  
02e6 32 b4 fe			ld (debug_mark),a  
02e9 3a f8 02			ld a, (.dmark+1)  
02ec 32 b5 fe			ld (debug_mark+1),a  
02ef 3a f9 02			ld a, (.dmark+2)  
02f2 32 b6 fe			ld (debug_mark+2),a  
02f5 18 03			jr .pastdmark  
02f7 ..			.dmark: db "SGI"  
02fa f1			.pastdmark: pop af  
02fb			endm  
# End of macro DMARK
02fb					CALLMONITOR 
02fb cd 57 17			call break_point_state  
02fe				endm  
# End of macro CALLMONITOR
02fe				endif 
02fe				; get block 0 and set counter for number of files to scan 
02fe			 
02fe cd 69 04			call storage_get_block_0 
0301			 
0301 3a df fc			ld a, (store_page) 
0304 47				ld b, a 
0305			 
0305				; get extent 0 of each file id 
0305			 
0305				if DEBUG_STORESE 
0305					DMARK "SGc" 
0305 f5				push af  
0306 3a 1a 03			ld a, (.dmark)  
0309 32 b4 fe			ld (debug_mark),a  
030c 3a 1b 03			ld a, (.dmark+1)  
030f 32 b5 fe			ld (debug_mark+1),a  
0312 3a 1c 03			ld a, (.dmark+2)  
0315 32 b6 fe			ld (debug_mark+2),a  
0318 18 03			jr .pastdmark  
031a ..			.dmark: db "SGc"  
031d f1			.pastdmark: pop af  
031e			endm  
# End of macro DMARK
031e					CALLMONITOR 
031e cd 57 17			call break_point_state  
0321				endm  
# End of macro CALLMONITOR
0321				endif 
0321 60			.getloop:	ld h, b 
0322 2e 00				ld l, 0 
0324 c5					push bc 
0325			 
0325 11 df fc				ld de, store_page 
0328				if DEBUG_STORESE 
0328					DMARK "SGr" 
0328 f5				push af  
0329 3a 3d 03			ld a, (.dmark)  
032c 32 b4 fe			ld (debug_mark),a  
032f 3a 3e 03			ld a, (.dmark+1)  
0332 32 b5 fe			ld (debug_mark+1),a  
0335 3a 3f 03			ld a, (.dmark+2)  
0338 32 b6 fe			ld (debug_mark+2),a  
033b 18 03			jr .pastdmark  
033d ..			.dmark: db "SGr"  
0340 f1			.pastdmark: pop af  
0341			endm  
# End of macro DMARK
0341					CALLMONITOR 
0341 cd 57 17			call break_point_state  
0344				endm  
# End of macro CALLMONITOR
0344				endif 
0344 cd 11 09				call storage_read 
0347 cd 03 0e				call ishlzero 
034a 28 2d				jr z, .gap 
034c					 
034c					; have a file name read. Is it one we want. 
034c			 
034c 2a dd fc				ld hl, (store_tmp1) 
034f 11 e2 fc				ld de, store_page+3   ; file name 
0352			 
0352				if DEBUG_STORESE 
0352					DMARK "SGc" 
0352 f5				push af  
0353 3a 67 03			ld a, (.dmark)  
0356 32 b4 fe			ld (debug_mark),a  
0359 3a 68 03			ld a, (.dmark+1)  
035c 32 b5 fe			ld (debug_mark+1),a  
035f 3a 69 03			ld a, (.dmark+2)  
0362 32 b6 fe			ld (debug_mark+2),a  
0365 18 03			jr .pastdmark  
0367 ..			.dmark: db "SGc"  
036a f1			.pastdmark: pop af  
036b			endm  
# End of macro DMARK
036b					CALLMONITOR 
036b cd 57 17			call break_point_state  
036e				endm  
# End of macro CALLMONITOR
036e				endif 
036e cd 70 12				call strcmp 
0371 20 06				jr nz, .gap   ; not this one 
0373			 
0373 c1				        pop bc 
0374			 
0374 26 00				ld h, 0 
0376 68					ld l, b 
0377 18 22				jr .getdone 
0379						 
0379			 
0379			 
0379			 
0379			.gap: 
0379				if DEBUG_STORESE 
0379					DMARK "SGg" 
0379 f5				push af  
037a 3a 8e 03			ld a, (.dmark)  
037d 32 b4 fe			ld (debug_mark),a  
0380 3a 8f 03			ld a, (.dmark+1)  
0383 32 b5 fe			ld (debug_mark+1),a  
0386 3a 90 03			ld a, (.dmark+2)  
0389 32 b6 fe			ld (debug_mark+2),a  
038c 18 03			jr .pastdmark  
038e ..			.dmark: db "SGg"  
0391 f1			.pastdmark: pop af  
0392			endm  
# End of macro DMARK
0392					CALLMONITOR 
0392 cd 57 17			call break_point_state  
0395				endm  
# End of macro CALLMONITOR
0395				endif 
0395			 
0395 c1					pop bc 
0396 10 89				djnz .getloop 
0398 21 ff 00				ld hl, 255 
039b			.getdone: 
039b			 
039b				if DEBUG_STORESE 
039b					DMARK "SGe" 
039b f5				push af  
039c 3a b0 03			ld a, (.dmark)  
039f 32 b4 fe			ld (debug_mark),a  
03a2 3a b1 03			ld a, (.dmark+1)  
03a5 32 b5 fe			ld (debug_mark+1),a  
03a8 3a b2 03			ld a, (.dmark+2)  
03ab 32 b6 fe			ld (debug_mark+2),a  
03ae 18 03			jr .pastdmark  
03b0 ..			.dmark: db "SGe"  
03b3 f1			.pastdmark: pop af  
03b4			endm  
# End of macro DMARK
03b4					CALLMONITOR 
03b4 cd 57 17			call break_point_state  
03b7				endm  
# End of macro CALLMONITOR
03b7				endif 
03b7			 
03b7 c9				ret 
03b8			 
03b8			 
03b8			 
03b8			 
03b8			 
03b8			 
03b8			 
03b8			 
03b8			; Read Block 
03b8			; ---------- 
03b8			; 
03b8			; With current bank 
03b8			;  
03b8			; Get block number to read 
03b8			; Load physical blocks starting at start block into buffer 
03b8			 
03b8			; de points to buffer to use 
03b8			; hl holds logical block number  
03b8			 
03b8			storage_read_block: 
03b8			 
03b8				; TODO bank selection 
03b8			 
03b8				; for each of the physical blocks read it into the buffer 
03b8 06 40			ld b, STORE_BLOCK_PHY 
03ba			 
03ba				if DEBUG_STORESE 
03ba d5					push de 
03bb				endif 
03bb				 
03bb			.rl1:    
03bb			 
03bb				; read physical block at hl into de 
03bb			        ; increment hl and de to next read position on exit 
03bb			 
03bb e5				push hl 
03bc d5				push de	 
03bd c5				push bc 
03be			;	if DEBUG_STORESE 
03be			;		push af 
03be			;		ld a, 'R' 
03be			;		ld (debug_mark),a 
03be			;		pop af 
03be			;		CALLMONITOR 
03be			;	endif 
03be cd 5f 02			call se_readbyte 
03c1			;	if DEBUG_STORESE 
03c1			;		ld a,(spi_portbyte) 
03c1			;		ld l, a 
03c1			;		push af 
03c1			;		ld a, '1' 
03c1			;		ld (debug_mark),a 
03c1			;		pop af 
03c1			;		CALLMONITOR 
03c1			;	endif 
03c1 c1				pop bc 
03c2 d1				pop de 
03c3 e1				pop hl 
03c4 12				ld (de),a 
03c5 23				inc hl 
03c6 13				inc de 
03c7			 
03c7			;	if DEBUG_STORESE 
03c7			;		push af 
03c7			;		ld a, 'r' 
03c7			;		ld (debug_mark),a 
03c7			;		pop af 
03c7			;		CALLMONITOR 
03c7			;	endif 
03c7			 
03c7 10 f2			djnz .rl1 
03c9			 
03c9				if DEBUG_STORESE 
03c9					DMARK "SRB" 
03c9 f5				push af  
03ca 3a de 03			ld a, (.dmark)  
03cd 32 b4 fe			ld (debug_mark),a  
03d0 3a df 03			ld a, (.dmark+1)  
03d3 32 b5 fe			ld (debug_mark+1),a  
03d6 3a e0 03			ld a, (.dmark+2)  
03d9 32 b6 fe			ld (debug_mark+2),a  
03dc 18 03			jr .pastdmark  
03de ..			.dmark: db "SRB"  
03e1 f1			.pastdmark: pop af  
03e2			endm  
# End of macro DMARK
03e2 d1					pop de 
03e3			; 
03e3			;		push af 
03e3			;		ld a, 'R' 
03e3			;		ld (debug_mark),a 
03e3			;		pop af 
03e3					CALLMONITOR 
03e3 cd 57 17			call break_point_state  
03e6				endm  
# End of macro CALLMONITOR
03e6				endif 
03e6 c9				ret	 
03e7				 
03e7			 
03e7			; File Size 
03e7			; --------- 
03e7			; 
03e7			;   hl file id 
03e7			; 
03e7			;  returns in hl the number of blocks 
03e7			 
03e7			storage_file_size: 
03e7 5d				ld e, l 
03e8 16 00			ld d, 0 
03ea 21 40 00			ld hl, STORE_BLOCK_PHY 
03ed					if DEBUG_FORTH_WORDS 
03ed						DMARK "SIZ" 
03ed f5				push af  
03ee 3a 02 04			ld a, (.dmark)  
03f1 32 b4 fe			ld (debug_mark),a  
03f4 3a 03 04			ld a, (.dmark+1)  
03f7 32 b5 fe			ld (debug_mark+1),a  
03fa 3a 04 04			ld a, (.dmark+2)  
03fd 32 b6 fe			ld (debug_mark+2),a  
0400 18 03			jr .pastdmark  
0402 ..			.dmark: db "SIZ"  
0405 f1			.pastdmark: pop af  
0406			endm  
# End of macro DMARK
0406						CALLMONITOR 
0406 cd 57 17			call break_point_state  
0409				endm  
# End of macro CALLMONITOR
0409					endif 
0409 cd eb 06			call storage_findnextid 
040c			 
040c cd 03 0e			call ishlzero 
040f			;	ld a, l 
040f			;	add h 
040f			;	cp 0 
040f c8				ret z			; block not found so EOF 
0410			 
0410 11 df fc			ld de, store_page 
0413 cd b8 03			call storage_read_block 
0416			 
0416 3a e1 fc			ld a, (store_page+2)	 ; get extent count 
0419 6f				ld l, a 
041a 26 00			ld h, 0 
041c c9			 	ret 
041d			 
041d			 
041d			; Write Block 
041d			; ----------- 
041d			; 
041d			; With current bank 
041d			;  
041d			; Get block number to write 
041d			; Write physical blocks starting at start block from buffer 
041d			  
041d			storage_write_block: 
041d				; TODO bank selection 
041d			 
041d				; for each of the physical blocks read it into the buffer 
041d 06 40			ld b, STORE_BLOCK_PHY 
041f			 
041f				if DEBUG_STORESE 
041f					DMARK "SWB" 
041f f5				push af  
0420 3a 34 04			ld a, (.dmark)  
0423 32 b4 fe			ld (debug_mark),a  
0426 3a 35 04			ld a, (.dmark+1)  
0429 32 b5 fe			ld (debug_mark+1),a  
042c 3a 36 04			ld a, (.dmark+2)  
042f 32 b6 fe			ld (debug_mark+2),a  
0432 18 03			jr .pastdmark  
0434 ..			.dmark: db "SWB"  
0437 f1			.pastdmark: pop af  
0438			endm  
# End of macro DMARK
0438			 
0438					;push af 
0438					;ld a, 'W' 
0438					;ld (debug_mark),a 
0438					;pop af 
0438					CALLMONITOR 
0438 cd 57 17			call break_point_state  
043b				endm  
# End of macro CALLMONITOR
043b				endif 
043b			 
043b			; might not be working 
043b			;	call se_writepage 
043b			 
043b			;	ret 
043b			; 
043b			 
043b			 
043b			 
043b			.wl1:    
043b			 
043b				; read physical block at hl into de 
043b			        ; increment hl and de to next read position on exit 
043b			 
043b e5				push hl 
043c d5				push de	 
043d c5				push bc 
043e 1a				ld a,(de) 
043f				;if DEBUG_STORESE 
043f			;		push af 
043f			;		ld a, 'W' 
043f			;		ld (debug_mark),a 
043f			;		pop af 
043f			;		CALLMONITOR 
043f			;	endif 
043f cd bd 01			call se_writebyte 
0442			;	call delay250ms 
0442 00				nop 
0443 00				nop 
0444 00				nop 
0445			;	if DEBUG_STORESE 
0445			;		push af 
0445			;		ld a, 'w' 
0445			;		ld (debug_mark),a 
0445			;		pop af 
0445			;		CALLMONITOR 
0445			;	endif 
0445 c1				pop bc 
0446 d1				pop de 
0447 e1				pop hl 
0448 23				inc hl 
0449 13				inc de 
044a			 
044a			 
044a 10 ef			djnz .wl1 
044c			 
044c				if DEBUG_STORESE 
044c					DMARK "SW2" 
044c f5				push af  
044d 3a 61 04			ld a, (.dmark)  
0450 32 b4 fe			ld (debug_mark),a  
0453 3a 62 04			ld a, (.dmark+1)  
0456 32 b5 fe			ld (debug_mark+1),a  
0459 3a 63 04			ld a, (.dmark+2)  
045c 32 b6 fe			ld (debug_mark+2),a  
045f 18 03			jr .pastdmark  
0461 ..			.dmark: db "SW2"  
0464 f1			.pastdmark: pop af  
0465			endm  
# End of macro DMARK
0465			 
0465					;push af 
0465					;ld a, 'W' 
0465					;ld (debug_mark),a 
0465					;pop af 
0465					CALLMONITOR 
0465 cd 57 17			call break_point_state  
0468				endm  
# End of macro CALLMONITOR
0468				endif 
0468 c9				ret	 
0469			 
0469			; Init bank 
0469			; --------- 
0469			; 
0469			; With current bank 
0469			; 
0469			; Setup block 0 config 
0469			;     Set 0 file id counter 
0469			;     Set formatted byte pattern 
0469			;     Zero out bank label 
0469			;      
0469			; For every logical block write 0-1 byte as null 
0469			 
0469			storage_get_block_0: 
0469			 
0469				; TODO check presence 
0469			 
0469				; get block 0 config 
0469			 
0469 21 00 00			ld hl, 0 
046c 11 df fc			ld de, store_page 
046f cd b8 03			call storage_read_block 
0472			 
0472				if DEBUG_STORESE 
0472					DMARK "SB0" 
0472 f5				push af  
0473 3a 87 04			ld a, (.dmark)  
0476 32 b4 fe			ld (debug_mark),a  
0479 3a 88 04			ld a, (.dmark+1)  
047c 32 b5 fe			ld (debug_mark+1),a  
047f 3a 89 04			ld a, (.dmark+2)  
0482 32 b6 fe			ld (debug_mark+2),a  
0485 18 03			jr .pastdmark  
0487 ..			.dmark: db "SB0"  
048a f1			.pastdmark: pop af  
048b			endm  
# End of macro DMARK
048b 11 df fc				ld de, store_page 
048e			;		push af 
048e			;		ld a, 'i' 
048e			;		ld (debug_mark),a 
048e			;		pop af 
048e					CALLMONITOR 
048e cd 57 17			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491			 
0491				; is this area formatted? 
0491			 
0491			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0491 2a e0 fc			ld hl, (store_page+1) 
0494 3e 80			ld a,0x80 
0496 bd				cp l 
0497 20 22			jr nz, .ininotformatted 
0499				; do a double check 
0499 3e 27			ld a, 0x27 
049b bc				cp h 
049c 20 1d			jr nz, .ininotformatted 
049e			 
049e				; formatted then 
049e			 
049e				if DEBUG_STORESE 
049e					DMARK "SB1" 
049e f5				push af  
049f 3a b3 04			ld a, (.dmark)  
04a2 32 b4 fe			ld (debug_mark),a  
04a5 3a b4 04			ld a, (.dmark+1)  
04a8 32 b5 fe			ld (debug_mark+1),a  
04ab 3a b5 04			ld a, (.dmark+2)  
04ae 32 b6 fe			ld (debug_mark+2),a  
04b1 18 03			jr .pastdmark  
04b3 ..			.dmark: db "SB1"  
04b6 f1			.pastdmark: pop af  
04b7			endm  
# End of macro DMARK
04b7					;push af 
04b7					;ld a, 'I' 
04b7					;ld (debug_mark),a 
04b7					;pop af 
04b7					CALLMONITOR 
04b7 cd 57 17			call break_point_state  
04ba				endm  
# End of macro CALLMONITOR
04ba				endif 
04ba c9				ret 
04bb			 
04bb			.ininotformatted: 
04bb				; bank not formatted so poke various bits to make sure 
04bb			 
04bb				if DEBUG_STORESE 
04bb					DMARK "SB2" 
04bb f5				push af  
04bc 3a d0 04			ld a, (.dmark)  
04bf 32 b4 fe			ld (debug_mark),a  
04c2 3a d1 04			ld a, (.dmark+1)  
04c5 32 b5 fe			ld (debug_mark+1),a  
04c8 3a d2 04			ld a, (.dmark+2)  
04cb 32 b6 fe			ld (debug_mark+2),a  
04ce 18 03			jr .pastdmark  
04d0 ..			.dmark: db "SB2"  
04d3 f1			.pastdmark: pop af  
04d4			endm  
# End of macro DMARK
04d4					;push af 
04d4					;ld a, 'f' 
04d4					;ld (debug_mark),a 
04d4					;pop af 
04d4					CALLMONITOR 
04d4 cd 57 17			call break_point_state  
04d7				endm  
# End of macro CALLMONITOR
04d7				endif 
04d7			 
04d7 cd e6 0a			call storage_clear_page 
04da			 
04da 21 df fc			ld hl, store_page 
04dd 3e 00			ld a, 0 
04df				 
04df 77				ld (hl),a   ; reset file counter 
04e0			 
04e0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04e3 22 e0 fc		 	ld (store_page+1), hl	 
04e6			 
04e6				; set default label 
04e6			 
04e6 21 82 05			ld hl, .defaultbanklabl 
04e9 11 e2 fc		 	ld de, store_page+3 
04ec 01 0f 00			ld bc, 15 
04ef ed b0			ldir 
04f1			 
04f1				; Append the current bank id 
04f1 21 eb fc			ld hl, store_page+3+9 
04f4 3a c4 fc			ld a, (spi_device_id) 
04f7 77				ld (hl), a 
04f8			 
04f8				; save default page 0 
04f8			 
04f8 21 00 00			ld hl, 0 
04fb 11 df fc			ld de, store_page 
04fe				if DEBUG_STORESE 
04fe					DMARK "SB3" 
04fe f5				push af  
04ff 3a 13 05			ld a, (.dmark)  
0502 32 b4 fe			ld (debug_mark),a  
0505 3a 14 05			ld a, (.dmark+1)  
0508 32 b5 fe			ld (debug_mark+1),a  
050b 3a 15 05			ld a, (.dmark+2)  
050e 32 b6 fe			ld (debug_mark+2),a  
0511 18 03			jr .pastdmark  
0513 ..			.dmark: db "SB3"  
0516 f1			.pastdmark: pop af  
0517			endm  
# End of macro DMARK
0517			;		push af 
0517			;		ld a, 'F' 
0517			;		ld (debug_mark),a 
0517			;		pop af 
0517					CALLMONITOR 
0517 cd 57 17			call break_point_state  
051a				endm  
# End of macro CALLMONITOR
051a				endif 
051a cd 1d 04			call storage_write_block 
051d				if DEBUG_STORESE 
051d					DMARK "SB4" 
051d f5				push af  
051e 3a 32 05			ld a, (.dmark)  
0521 32 b4 fe			ld (debug_mark),a  
0524 3a 33 05			ld a, (.dmark+1)  
0527 32 b5 fe			ld (debug_mark+1),a  
052a 3a 34 05			ld a, (.dmark+2)  
052d 32 b6 fe			ld (debug_mark+2),a  
0530 18 03			jr .pastdmark  
0532 ..			.dmark: db "SB4"  
0535 f1			.pastdmark: pop af  
0536			endm  
# End of macro DMARK
0536			;		push af 
0536			;		ld a, '>' 
0536			;		ld (debug_mark),a 
0536			;		pop af 
0536					CALLMONITOR 
0536 cd 57 17			call break_point_state  
0539				endm  
# End of macro CALLMONITOR
0539				endif 
0539			 
0539 00				nop 
053a 00				nop 
053b 00				nop 
053c			 
053c				; now set 0 in every page to mark as a free block 
053c			 
053c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
053e 21 40 00			ld hl, STORE_BLOCK_PHY 
0541			 
0541 3e 00		.setmark1:   	ld a,0 
0543 e5					push hl 
0544 c5					push bc 
0545 cd bd 01				call se_writebyte 
0548 3e 0a			ld a, 10 
054a cd 08 0b			call aDelayInMS 
054d 23				inc hl 
054e cd bd 01				call se_writebyte 
0551 3e 0a			ld a, 10 
0553 cd 08 0b			call aDelayInMS 
0556 2b				dec hl 
0557 c1					pop bc 
0558 e1					pop hl 
0559 3e 40				ld a, STORE_BLOCK_PHY 
055b cd da 0d				call addatohl 
055e 10 e1				djnz .setmark1 
0560			 
0560 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0562 3e 00		.setmark2:   	ld a,0 
0564 e5					push hl 
0565 c5					push bc 
0566 cd bd 01				call se_writebyte 
0569 3e 0a			ld a, 10 
056b cd 08 0b			call aDelayInMS 
056e 23				inc hl 
056f cd bd 01				call se_writebyte 
0572 3e 0a			ld a, 10 
0574 cd 08 0b			call aDelayInMS 
0577 2b				dec hl 
0578 c1					pop bc 
0579 e1					pop hl 
057a 3e 40				ld a, STORE_BLOCK_PHY 
057c cd da 0d				call addatohl 
057f 10 e1				djnz .setmark2 
0581			 
0581					 
0581			 
0581			 
0581 c9				ret 
0582			 
0582			 
0582			 
0582			 
0582 .. 00		.defaultbanklabl:   db "BankLabel_",0 
058d			 
058d			 
058d			 
058d			; Label Bank 
058d			; ---------- 
058d			; 
058d			; With current bank 
058d			; Read block 0 
058d			; Set label 
058d			; Write block 0 
058d			 
058d			; label str pointer in hl 
058d			 
058d			storage_label:     
058d			 
058d				if DEBUG_STORESE 
058d					DMARK "LBL" 
058d f5				push af  
058e 3a a2 05			ld a, (.dmark)  
0591 32 b4 fe			ld (debug_mark),a  
0594 3a a3 05			ld a, (.dmark+1)  
0597 32 b5 fe			ld (debug_mark+1),a  
059a 3a a4 05			ld a, (.dmark+2)  
059d 32 b6 fe			ld (debug_mark+2),a  
05a0 18 03			jr .pastdmark  
05a2 ..			.dmark: db "LBL"  
05a5 f1			.pastdmark: pop af  
05a6			endm  
# End of macro DMARK
05a6					CALLMONITOR 
05a6 cd 57 17			call break_point_state  
05a9				endm  
# End of macro CALLMONITOR
05a9				endif 
05a9			 
05a9 e5				push hl 
05aa			 
05aa cd 69 04			call storage_get_block_0 
05ad			 
05ad				; set default label 
05ad			 
05ad e1				pop hl 
05ae			 
05ae 11 e2 fc		 	ld de, store_page+3 
05b1 01 0f 00			ld bc, 15 
05b4				if DEBUG_STORESE 
05b4					DMARK "LB3" 
05b4 f5				push af  
05b5 3a c9 05			ld a, (.dmark)  
05b8 32 b4 fe			ld (debug_mark),a  
05bb 3a ca 05			ld a, (.dmark+1)  
05be 32 b5 fe			ld (debug_mark+1),a  
05c1 3a cb 05			ld a, (.dmark+2)  
05c4 32 b6 fe			ld (debug_mark+2),a  
05c7 18 03			jr .pastdmark  
05c9 ..			.dmark: db "LB3"  
05cc f1			.pastdmark: pop af  
05cd			endm  
# End of macro DMARK
05cd					CALLMONITOR 
05cd cd 57 17			call break_point_state  
05d0				endm  
# End of macro CALLMONITOR
05d0				endif 
05d0 ed b0			ldir 
05d2				; save default page 0 
05d2			 
05d2 21 00 00			ld hl, 0 
05d5 11 df fc			ld de, store_page 
05d8				if DEBUG_STORESE 
05d8					DMARK "LBW" 
05d8 f5				push af  
05d9 3a ed 05			ld a, (.dmark)  
05dc 32 b4 fe			ld (debug_mark),a  
05df 3a ee 05			ld a, (.dmark+1)  
05e2 32 b5 fe			ld (debug_mark+1),a  
05e5 3a ef 05			ld a, (.dmark+2)  
05e8 32 b6 fe			ld (debug_mark+2),a  
05eb 18 03			jr .pastdmark  
05ed ..			.dmark: db "LBW"  
05f0 f1			.pastdmark: pop af  
05f1			endm  
# End of macro DMARK
05f1					CALLMONITOR 
05f1 cd 57 17			call break_point_state  
05f4				endm  
# End of macro CALLMONITOR
05f4				endif 
05f4 cd 1d 04			call storage_write_block 
05f7			 
05f7 c9				ret 
05f8			 
05f8			 
05f8			 
05f8			; Read Block 0 - Config 
05f8			; --------------------- 
05f8			; 
05f8			; With current bank 
05f8			; Call presence test 
05f8			;    If not present format/init bank  
05f8			; Read block 0  
05f8			;  
05f8			 
05f8			 
05f8			; Dir 
05f8			; --- 
05f8			; 
05f8			; With current bank 
05f8			; Load Block 0 Config 
05f8			; Get max file id number 
05f8			; For each logical block 
05f8			;    Read block read byte 2 
05f8			;      if first block of file 
05f8			;         Display file name 
05f8			;         Display type flags for file 
05f8			;        
05f8			 
05f8			; moving to words as this requires stack control 
05f8			 
05f8			 
05f8			; Delete File 
05f8			; ----------- 
05f8			; 
05f8			; With current bank 
05f8			; 
05f8			; Load Block 0 Config 
05f8			; Get max file id number 
05f8			; For each logical block 
05f8			;    Read block file id 
05f8			;      If first block of file and dont have file id 
05f8			;         if file to delete 
05f8			;         Save file id 
05f8			;         Null file id 
05f8			;         Write this block back 
05f8			;      If file id is one saved 
05f8			;         Null file id 
05f8			;         Write this block back 
05f8			 
05f8			 
05f8			.se_done: 
05f8 e1				pop hl 
05f9 c9				ret 
05fa			 
05fa			storage_erase: 
05fa			 
05fa				; hl contains the file id 
05fa			 
05fa 5d				ld e, l 
05fb 16 00			ld d, 0 
05fd 21 40 00			ld hl, STORE_BLOCK_PHY 
0600					if DEBUG_FORTH_WORDS 
0600						DMARK "ERA" 
0600 f5				push af  
0601 3a 15 06			ld a, (.dmark)  
0604 32 b4 fe			ld (debug_mark),a  
0607 3a 16 06			ld a, (.dmark+1)  
060a 32 b5 fe			ld (debug_mark+1),a  
060d 3a 17 06			ld a, (.dmark+2)  
0610 32 b6 fe			ld (debug_mark+2),a  
0613 18 03			jr .pastdmark  
0615 ..			.dmark: db "ERA"  
0618 f1			.pastdmark: pop af  
0619			endm  
# End of macro DMARK
0619						CALLMONITOR 
0619 cd 57 17			call break_point_state  
061c				endm  
# End of macro CALLMONITOR
061c					endif 
061c cd eb 06			call storage_findnextid 
061f cd 03 0e			call ishlzero 
0622 c8				ret z 
0623			 
0623 e5				push hl 
0624			 
0624				; TODO check file not found 
0624			 
0624 11 df fc			ld de, store_page 
0627 cd b8 03			call storage_read_block 
062a			 
062a cd 03 0e			call ishlzero 
062d ca f8 05			jp z,.se_done 
0630			 
0630					if DEBUG_FORTH_WORDS 
0630						DMARK "ER1" 
0630 f5				push af  
0631 3a 45 06			ld a, (.dmark)  
0634 32 b4 fe			ld (debug_mark),a  
0637 3a 46 06			ld a, (.dmark+1)  
063a 32 b5 fe			ld (debug_mark+1),a  
063d 3a 47 06			ld a, (.dmark+2)  
0640 32 b6 fe			ld (debug_mark+2),a  
0643 18 03			jr .pastdmark  
0645 ..			.dmark: db "ER1"  
0648 f1			.pastdmark: pop af  
0649			endm  
# End of macro DMARK
0649						CALLMONITOR 
0649 cd 57 17			call break_point_state  
064c				endm  
# End of macro CALLMONITOR
064c					endif 
064c 3a df fc			ld a, (store_page)	; get file id 
064f 32 d8 fc			ld (store_tmpid), a 
0652			 
0652 3a e1 fc			ld a, (store_page+2)    ; get count of extends 
0655 32 d7 fc			ld (store_tmpext), a 
0658			 
0658				; wipe file header 
0658			 
0658 e1				pop hl 
0659 3e 00			ld a, 0 
065b 32 df fc			ld (store_page), a 
065e 32 e0 fc			ld (store_page+1),a 
0661 11 df fc			ld de, store_page 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ER2" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 b4 fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 b5 fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 b6 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ER2"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd 57 17			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 1d 04			call storage_write_block 
0683			 
0683			 
0683				; wipe file extents 
0683			 
0683 3a d7 fc			ld a, (store_tmpext) 
0686 47				ld b, a 
0687			 
0687			.eraext:	  
0687 c5				push bc 
0688			 
0688 21 40 00			ld hl, STORE_BLOCK_PHY 
068b 3a d8 fc			ld a,(store_tmpid) 
068e 5f				ld e, a 
068f 50				ld d, b	 
0690					if DEBUG_FORTH_WORDS 
0690						DMARK "ER3" 
0690 f5				push af  
0691 3a a5 06			ld a, (.dmark)  
0694 32 b4 fe			ld (debug_mark),a  
0697 3a a6 06			ld a, (.dmark+1)  
069a 32 b5 fe			ld (debug_mark+1),a  
069d 3a a7 06			ld a, (.dmark+2)  
06a0 32 b6 fe			ld (debug_mark+2),a  
06a3 18 03			jr .pastdmark  
06a5 ..			.dmark: db "ER3"  
06a8 f1			.pastdmark: pop af  
06a9			endm  
# End of macro DMARK
06a9						CALLMONITOR 
06a9 cd 57 17			call break_point_state  
06ac				endm  
# End of macro CALLMONITOR
06ac					endif 
06ac cd eb 06			call storage_findnextid 
06af cd 03 0e			call ishlzero 
06b2 ca f8 05			jp z,.se_done 
06b5			 
06b5 e5				push hl 
06b6 11 df fc			ld de, store_page 
06b9 cd b8 03			call storage_read_block 
06bc			 
06bc				; free block	 
06bc			 
06bc 3e 00			ld a, 0 
06be 32 df fc			ld (store_page), a 
06c1 32 e0 fc			ld (store_page+1),a 
06c4 11 df fc			ld de, store_page 
06c7 e1				pop hl 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER4" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 b4 fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 b5 fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 b6 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER4"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd 57 17			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 1d 04			call storage_write_block 
06e7			 
06e7 c1				pop bc 
06e8 10 9d			djnz .eraext 
06ea			 
06ea c9				ret 
06eb			 
06eb			 
06eb			; Find Free Block 
06eb			; --------------- 
06eb			; 
06eb			; With current bank 
06eb			;  
06eb			; From given starting logical block 
06eb			;    Read block  
06eb			;    If no file id 
06eb			;         Return block id 
06eb			 
06eb			 
06eb			; hl starting page number 
06eb			; hl contains free page number or zero if no pages free 
06eb			; e contains the file id to locate 
06eb			; d contains the block number 
06eb			 
06eb			; TODO change to find file id and use zero for free block 
06eb			 
06eb			storage_findnextid: 
06eb			 
06eb				; now locate first 0 page to mark as a free block 
06eb			 
06eb 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06ed			;	ld hl, STORE_BLOCK_PHY 
06ed			 
06ed					if DEBUG_FORTH_WORDS 
06ed					DMARK "FNI" 
06ed f5				push af  
06ee 3a 02 07			ld a, (.dmark)  
06f1 32 b4 fe			ld (debug_mark),a  
06f4 3a 03 07			ld a, (.dmark+1)  
06f7 32 b5 fe			ld (debug_mark+1),a  
06fa 3a 04 07			ld a, (.dmark+2)  
06fd 32 b6 fe			ld (debug_mark+2),a  
0700 18 03			jr .pastdmark  
0702 ..			.dmark: db "FNI"  
0705 f1			.pastdmark: pop af  
0706			endm  
# End of macro DMARK
0706						CALLMONITOR 
0706 cd 57 17			call break_point_state  
0709				endm  
# End of macro CALLMONITOR
0709					endif 
0709			.ff1:   	 
0709 e5					push hl 
070a c5					push bc 
070b d5					push de 
070c cd 5f 02				call se_readbyte 
070f 5f					ld e,a 
0710 23					inc hl 
0711 cd 5f 02				call se_readbyte 
0714 57					ld d, a 
0715 e1					pop hl 
0716 e5					push hl 
0717 cd f8 0d				call cmp16 
071a 28 49				jr z, .fffound 
071c			 
071c d1					pop de 
071d c1					pop bc 
071e e1					pop hl 
071f			 
071f					; is found? 
071f					;cp e 
071f					;ret z 
071f			 
071f 3e 40				ld a, STORE_BLOCK_PHY 
0721 cd da 0d				call addatohl 
0724 10 e3				djnz .ff1 
0726			 
0726 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0728			.ff2:   	 
0728			 
0728 e5					push hl 
0729 c5					push bc 
072a d5					push de 
072b cd 5f 02				call se_readbyte 
072e 5f					ld e,a 
072f 23					inc hl 
0730 cd 5f 02				call se_readbyte 
0733 57					ld d, a 
0734			 
0734 e1					pop hl 
0735 e5					push hl 
0736 cd f8 0d				call cmp16 
0739 28 2a				jr z, .fffound 
073b			 
073b d1					pop de 
073c c1					pop bc 
073d e1					pop hl 
073e					; is found? 
073e					;cp e 
073e					;ret z 
073e			 
073e 3e 40				ld a, STORE_BLOCK_PHY 
0740 cd da 0d				call addatohl 
0743 10 e3				djnz .ff2 
0745			 
0745			 
0745					if DEBUG_FORTH_WORDS 
0745					DMARK "FN-" 
0745 f5				push af  
0746 3a 5a 07			ld a, (.dmark)  
0749 32 b4 fe			ld (debug_mark),a  
074c 3a 5b 07			ld a, (.dmark+1)  
074f 32 b5 fe			ld (debug_mark+1),a  
0752 3a 5c 07			ld a, (.dmark+2)  
0755 32 b6 fe			ld (debug_mark+2),a  
0758 18 03			jr .pastdmark  
075a ..			.dmark: db "FN-"  
075d f1			.pastdmark: pop af  
075e			endm  
# End of macro DMARK
075e					;	push af 
075e					;	ld a, 'n' 
075e					;	ld (debug_mark),a 
075e					;	pop af 
075e						CALLMONITOR 
075e cd 57 17			call break_point_state  
0761				endm  
# End of macro CALLMONITOR
0761					endif 
0761				; no free marks! 
0761 21 00 00				ld hl, 0 
0764 c9				ret 
0765			.fffound: 
0765				 
0765			 
0765 d1					pop de 
0766 c1					pop bc 
0767 e1					pop hl 
0768					if DEBUG_FORTH_WORDS 
0768					DMARK "FNF" 
0768 f5				push af  
0769 3a 7d 07			ld a, (.dmark)  
076c 32 b4 fe			ld (debug_mark),a  
076f 3a 7e 07			ld a, (.dmark+1)  
0772 32 b5 fe			ld (debug_mark+1),a  
0775 3a 7f 07			ld a, (.dmark+2)  
0778 32 b6 fe			ld (debug_mark+2),a  
077b 18 03			jr .pastdmark  
077d ..			.dmark: db "FNF"  
0780 f1			.pastdmark: pop af  
0781			endm  
# End of macro DMARK
0781					;	push af 
0781					;	ld a, 'n' 
0781					;	ld (debug_mark),a 
0781					;	pop af 
0781						CALLMONITOR 
0781 cd 57 17			call break_point_state  
0784				endm  
# End of macro CALLMONITOR
0784					endif 
0784 c9				ret 
0785			 
0785			 
0785			 
0785			; Free Space 
0785			; ---------- 
0785			; 
0785			; With current bank 
0785			; 
0785			; Set block count to zero 
0785			; Starting with first logical block 
0785			;      Find free block  
0785			;      If block id given, increment block count 
0785			; 
0785			;  
0785			 
0785			 
0785			; hl contains count of free blocks 
0785			 
0785			storage_freeblocks: 
0785			 
0785				; now locate first 0 page to mark as a free block 
0785			 
0785 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0787 21 40 00			ld hl, STORE_BLOCK_PHY 
078a 11 00 00			ld de, 0 
078d			 
078d			.fb1:   	 
078d e5					push hl 
078e c5					push bc 
078f d5					push de 
0790 cd 5f 02				call se_readbyte 
0793 d1					pop de 
0794 c1					pop bc 
0795 e1					pop hl 
0796			 
0796					; is free? 
0796 fe 00				cp 0 
0798 20 01				jr nz, .ff1cont 
079a 13					inc de 
079b			 
079b			.ff1cont: 
079b			 
079b			 
079b 3e 40				ld a, STORE_BLOCK_PHY 
079d cd da 0d				call addatohl 
07a0 10 eb				djnz .fb1 
07a2			 
07a2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a4			.fb2:   	 
07a4 e5					push hl 
07a5 c5					push bc 
07a6 d5					push de 
07a7 cd 5f 02				call se_readbyte 
07aa d1					pop de 
07ab c1					pop bc 
07ac e1					pop hl 
07ad			 
07ad					; is free? 
07ad fe 00				cp 0 
07af 20 01				jr nz, .ff2cont 
07b1 13					inc de 
07b2			 
07b2			.ff2cont: 
07b2			 
07b2 3e 40				ld a, STORE_BLOCK_PHY 
07b4 cd da 0d				call addatohl 
07b7 10 eb				djnz .fb2 
07b9			 
07b9 eb				ex de, hl 
07ba c9				ret 
07bb			 
07bb			; Get File ID 
07bb			; ----------- 
07bb			; 
07bb			; With current bank 
07bb			;  
07bb			; Load Block 0 Config 
07bb			; Get max file id number 
07bb			; For each logical block 
07bb			;    Read block file id 
07bb			;      If first block of file and dont have file id 
07bb			;         if file get id and exit 
07bb			 
07bb			 
07bb			 
07bb			 
07bb			; Create File 
07bb			; ----------- 
07bb			; 
07bb			; With current bank  
07bb			; Load Block 0 Config 
07bb			; Get max file id number 
07bb			; Increment file id number 
07bb			; Save Config 
07bb			; Find free block 
07bb			; Set buffer with file name and file id 
07bb			; Write buffer to free block  
07bb			 
07bb			 
07bb			; hl point to file name 
07bb			; hl returns file id 
07bb			 
07bb			; file format: 
07bb			; byte 0 - file id 
07bb			; byte 1 - extent number 
07bb			; byte 2-> data 
07bb			 
07bb			; format for extent number 0: 
07bb			; 
07bb			; byte 0 - file id 
07bb			; byte 1 - extent 0 
07bb			; byte 2 - extent count 
07bb			; byte 3 -> file name and meta data 
07bb			 
07bb			 
07bb			storage_create: 
07bb				if DEBUG_STORESE 
07bb					DMARK "SCR" 
07bb f5				push af  
07bc 3a d0 07			ld a, (.dmark)  
07bf 32 b4 fe			ld (debug_mark),a  
07c2 3a d1 07			ld a, (.dmark+1)  
07c5 32 b5 fe			ld (debug_mark+1),a  
07c8 3a d2 07			ld a, (.dmark+2)  
07cb 32 b6 fe			ld (debug_mark+2),a  
07ce 18 03			jr .pastdmark  
07d0 ..			.dmark: db "SCR"  
07d3 f1			.pastdmark: pop af  
07d4			endm  
# End of macro DMARK
07d4					CALLMONITOR 
07d4 cd 57 17			call break_point_state  
07d7				endm  
# End of macro CALLMONITOR
07d7				endif 
07d7			 
07d7 e5				push hl		; save file name pointer 
07d8			 
07d8 cd 69 04			call storage_get_block_0 
07db			 
07db 3a df fc			ld a,(store_page)	; get current file id 
07de 3c				inc a 
07df 32 df fc			ld (store_page),a 
07e2				 
07e2 32 d8 fc			ld (store_tmpid),a			; save id 
07e5			 
07e5 21 00 00			ld hl, 0 
07e8 11 df fc			ld de, store_page 
07eb				if DEBUG_STORESE 
07eb					DMARK "SCw" 
07eb f5				push af  
07ec 3a 00 08			ld a, (.dmark)  
07ef 32 b4 fe			ld (debug_mark),a  
07f2 3a 01 08			ld a, (.dmark+1)  
07f5 32 b5 fe			ld (debug_mark+1),a  
07f8 3a 02 08			ld a, (.dmark+2)  
07fb 32 b6 fe			ld (debug_mark+2),a  
07fe 18 03			jr .pastdmark  
0800 ..			.dmark: db "SCw"  
0803 f1			.pastdmark: pop af  
0804			endm  
# End of macro DMARK
0804					CALLMONITOR 
0804 cd 57 17			call break_point_state  
0807				endm  
# End of macro CALLMONITOR
0807				endif 
0807 cd 1d 04			call storage_write_block	 ; save update 
080a			 
080a				if DEBUG_STORESE 
080a 11 df fc				ld de, store_page 
080d					DMARK "SCC" 
080d f5				push af  
080e 3a 22 08			ld a, (.dmark)  
0811 32 b4 fe			ld (debug_mark),a  
0814 3a 23 08			ld a, (.dmark+1)  
0817 32 b5 fe			ld (debug_mark+1),a  
081a 3a 24 08			ld a, (.dmark+2)  
081d 32 b6 fe			ld (debug_mark+2),a  
0820 18 03			jr .pastdmark  
0822 ..			.dmark: db "SCC"  
0825 f1			.pastdmark: pop af  
0826			endm  
# End of macro DMARK
0826					CALLMONITOR 
0826 cd 57 17			call break_point_state  
0829				endm  
# End of macro CALLMONITOR
0829				endif 
0829				;  
0829				 
0829 21 40 00			ld hl, STORE_BLOCK_PHY 
082c 11 00 00			ld de, 0 
082f cd eb 06			call storage_findnextid 
0832			 
0832 22 c9 fc			ld (store_tmppageid), hl    ; save page to use  
0835			 
0835				; TODO detect 0 = no spare blocks 
0835			 
0835				; hl now contains the free page to use for the file header page 
0835			 
0835				if DEBUG_STORESE 
0835				DMARK "SCF" 
0835 f5				push af  
0836 3a 4a 08			ld a, (.dmark)  
0839 32 b4 fe			ld (debug_mark),a  
083c 3a 4b 08			ld a, (.dmark+1)  
083f 32 b5 fe			ld (debug_mark+1),a  
0842 3a 4c 08			ld a, (.dmark+2)  
0845 32 b6 fe			ld (debug_mark+2),a  
0848 18 03			jr .pastdmark  
084a ..			.dmark: db "SCF"  
084d f1			.pastdmark: pop af  
084e			endm  
# End of macro DMARK
084e					CALLMONITOR 
084e cd 57 17			call break_point_state  
0851				endm  
# End of macro CALLMONITOR
0851				endif 
0851			 
0851 22 c9 fc			ld (store_tmppageid), hl 
0854				 
0854 3a d8 fc			ld a,(store_tmpid)    ; get file id 
0857			;	ld a, (store_filecache)			; save to cache 
0857			 
0857 32 df fc			ld (store_page),a    ; set page id 
085a 3e 00			ld a, 0			 ; extent 0 is file header 
085c 32 e0 fc			ld (store_page+1), a   ; set file extent 
085f			 
085f 32 e1 fc			ld (store_page+2), a   ; extent count for the file 
0862			 
0862			;	inc hl 		; init block 0 of file 
0862			;	inc hl   		; skip file and extent id 
0862			 ;       ld a, 0 
0862			;	ld (hl),a 
0862			;	ld a, (store_filecache+1)  	; save to cache 
0862			 
0862			;	inc hl    ; file name 
0862				 
0862				 
0862 11 e2 fc			ld de, store_page+3    ; get buffer for term string to use as file name 
0865				if DEBUG_STORESE 
0865					DMARK "SCc" 
0865 f5				push af  
0866 3a 7a 08			ld a, (.dmark)  
0869 32 b4 fe			ld (debug_mark),a  
086c 3a 7b 08			ld a, (.dmark+1)  
086f 32 b5 fe			ld (debug_mark+1),a  
0872 3a 7c 08			ld a, (.dmark+2)  
0875 32 b6 fe			ld (debug_mark+2),a  
0878 18 03			jr .pastdmark  
087a ..			.dmark: db "SCc"  
087d f1			.pastdmark: pop af  
087e			endm  
# End of macro DMARK
087e					CALLMONITOR 
087e cd 57 17			call break_point_state  
0881				endm  
# End of macro CALLMONITOR
0881				endif 
0881 e1				pop hl    ; get zero term string 
0882 e5				push hl 
0883 3e 00			ld a, 0 
0885 cd 43 12			call strlent 
0888 23				inc hl   ; cover zero term 
0889 06 00			ld b,0 
088b 4d				ld c,l 
088c e1				pop hl 
088d				;ex de, hl 
088d				if DEBUG_STORESE 
088d					DMARK "SCa" 
088d f5				push af  
088e 3a a2 08			ld a, (.dmark)  
0891 32 b4 fe			ld (debug_mark),a  
0894 3a a3 08			ld a, (.dmark+1)  
0897 32 b5 fe			ld (debug_mark+1),a  
089a 3a a4 08			ld a, (.dmark+2)  
089d 32 b6 fe			ld (debug_mark+2),a  
08a0 18 03			jr .pastdmark  
08a2 ..			.dmark: db "SCa"  
08a5 f1			.pastdmark: pop af  
08a6			endm  
# End of macro DMARK
08a6					;push af 
08a6					;ld a, 'a' 
08a6					;ld (debug_mark),a 
08a6					;pop af 
08a6					CALLMONITOR 
08a6 cd 57 17			call break_point_state  
08a9				endm  
# End of macro CALLMONITOR
08a9				endif 
08a9 ed b0			ldir    ; copy zero term string 
08ab				if DEBUG_STORESE 
08ab					DMARK "SCA" 
08ab f5				push af  
08ac 3a c0 08			ld a, (.dmark)  
08af 32 b4 fe			ld (debug_mark),a  
08b2 3a c1 08			ld a, (.dmark+1)  
08b5 32 b5 fe			ld (debug_mark+1),a  
08b8 3a c2 08			ld a, (.dmark+2)  
08bb 32 b6 fe			ld (debug_mark+2),a  
08be 18 03			jr .pastdmark  
08c0 ..			.dmark: db "SCA"  
08c3 f1			.pastdmark: pop af  
08c4			endm  
# End of macro DMARK
08c4					CALLMONITOR 
08c4 cd 57 17			call break_point_state  
08c7				endm  
# End of macro CALLMONITOR
08c7				endif 
08c7			 
08c7				; write file header page 
08c7			 
08c7 2a c9 fc			ld hl,(store_tmppageid) 
08ca 11 df fc			ld de, store_page 
08cd				if DEBUG_STORESE 
08cd					DMARK "SCb" 
08cd f5				push af  
08ce 3a e2 08			ld a, (.dmark)  
08d1 32 b4 fe			ld (debug_mark),a  
08d4 3a e3 08			ld a, (.dmark+1)  
08d7 32 b5 fe			ld (debug_mark+1),a  
08da 3a e4 08			ld a, (.dmark+2)  
08dd 32 b6 fe			ld (debug_mark+2),a  
08e0 18 03			jr .pastdmark  
08e2 ..			.dmark: db "SCb"  
08e5 f1			.pastdmark: pop af  
08e6			endm  
# End of macro DMARK
08e6					;push af 
08e6					;ld a, 'b' 
08e6					;ld (debug_mark),a 
08e6					;pop af 
08e6					CALLMONITOR 
08e6 cd 57 17			call break_point_state  
08e9				endm  
# End of macro CALLMONITOR
08e9				endif 
08e9 cd 1d 04			call storage_write_block 
08ec			 
08ec 3a d8 fc			ld a, (store_tmpid) 
08ef 6f				ld l, a 
08f0 26 00			ld h,0 
08f2				if DEBUG_STORESE 
08f2					DMARK "SCz" 
08f2 f5				push af  
08f3 3a 07 09			ld a, (.dmark)  
08f6 32 b4 fe			ld (debug_mark),a  
08f9 3a 08 09			ld a, (.dmark+1)  
08fc 32 b5 fe			ld (debug_mark+1),a  
08ff 3a 09 09			ld a, (.dmark+2)  
0902 32 b6 fe			ld (debug_mark+2),a  
0905 18 03			jr .pastdmark  
0907 ..			.dmark: db "SCz"  
090a f1			.pastdmark: pop af  
090b			endm  
# End of macro DMARK
090b					CALLMONITOR 
090b cd 57 17			call break_point_state  
090e				endm  
# End of macro CALLMONITOR
090e				endif 
090e c9				ret 
090f				 
090f			 
090f			 
090f			; 
090f			; Read File 
090f			; 
090f			; h - file id to locate 
090f			; l - extent to locate 
090f			; de - pointer to string to read into 
090f			; 
090f			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
090f			 
090f			.sr_fail: 
090f d1				pop de 
0910 c9				ret 
0911			 
0911			storage_read: 
0911 d5				push de 
0912			 
0912			; TODO BUG the above push is it popped before the RET Z? 
0912			 
0912			; TODO how to handle multiple part blocks 
0912			 
0912				; locate file extent to read 
0912			 
0912 5c				ld e, h 
0913 55				ld d, l 
0914 21 40 00			ld hl, STORE_BLOCK_PHY 
0917				if DEBUG_STORESE 
0917					DMARK "SRE" 
0917 f5				push af  
0918 3a 2c 09			ld a, (.dmark)  
091b 32 b4 fe			ld (debug_mark),a  
091e 3a 2d 09			ld a, (.dmark+1)  
0921 32 b5 fe			ld (debug_mark+1),a  
0924 3a 2e 09			ld a, (.dmark+2)  
0927 32 b6 fe			ld (debug_mark+2),a  
092a 18 03			jr .pastdmark  
092c ..			.dmark: db "SRE"  
092f f1			.pastdmark: pop af  
0930			endm  
# End of macro DMARK
0930					CALLMONITOR 
0930 cd 57 17			call break_point_state  
0933				endm  
# End of macro CALLMONITOR
0933				endif 
0933 cd eb 06			call storage_findnextid 
0936			 
0936				if DEBUG_STORESE 
0936					DMARK "SRf" 
0936 f5				push af  
0937 3a 4b 09			ld a, (.dmark)  
093a 32 b4 fe			ld (debug_mark),a  
093d 3a 4c 09			ld a, (.dmark+1)  
0940 32 b5 fe			ld (debug_mark+1),a  
0943 3a 4d 09			ld a, (.dmark+2)  
0946 32 b6 fe			ld (debug_mark+2),a  
0949 18 03			jr .pastdmark  
094b ..			.dmark: db "SRf"  
094e f1			.pastdmark: pop af  
094f			endm  
# End of macro DMARK
094f					CALLMONITOR 
094f cd 57 17			call break_point_state  
0952				endm  
# End of macro CALLMONITOR
0952				endif 
0952 cd 03 0e			call ishlzero 
0955			;	ld a, l 
0955			;	add h 
0955			;	cp 0 
0955 28 b8			jr z,.sr_fail			; block not found so EOF 
0957			 
0957				; hl contains page number to load 
0957 d1				pop de   ; get storage 
0958 d5				push de 
0959				if DEBUG_STORESE 
0959					DMARK "SRg" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 b4 fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 b5 fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 b6 fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "SRg"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd 57 17			call break_point_state  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975 cd b8 03			call storage_read_block 
0978			 
0978			 
0978			; TODO if block has no zeros then need to read next block  
0978			 
0978			 
0978					 
0978 e1				pop hl 		 ; return start of data to show as not EOF 
0979 23				inc hl   ; past file id 
097a 23				inc hl   ; past ext 
097b				if DEBUG_STORESE 
097b					DMARK "SRe" 
097b f5				push af  
097c 3a 90 09			ld a, (.dmark)  
097f 32 b4 fe			ld (debug_mark),a  
0982 3a 91 09			ld a, (.dmark+1)  
0985 32 b5 fe			ld (debug_mark+1),a  
0988 3a 92 09			ld a, (.dmark+2)  
098b 32 b6 fe			ld (debug_mark+2),a  
098e 18 03			jr .pastdmark  
0990 ..			.dmark: db "SRe"  
0993 f1			.pastdmark: pop af  
0994			endm  
# End of macro DMARK
0994					CALLMONITOR 
0994 cd 57 17			call break_point_state  
0997				endm  
# End of macro CALLMONITOR
0997				endif 
0997 c9					ret 
0998			 
0998			 
0998			 
0998			; 
0998			; Append File 
0998			; 
0998			; hl - file id to locate 
0998			; de - pointer to (multi block) string to write 
0998			 
0998			.sa_notfound: 
0998 d1				pop de 
0999 c9				ret 
099a			 
099a			 
099a			storage_append: 
099a				; hl -  file id to append to 
099a				; de - string to append 
099a			 
099a d5				push de 
099b				 
099b				if DEBUG_STORESE 
099b					DMARK "AP1" 
099b f5				push af  
099c 3a b0 09			ld a, (.dmark)  
099f 32 b4 fe			ld (debug_mark),a  
09a2 3a b1 09			ld a, (.dmark+1)  
09a5 32 b5 fe			ld (debug_mark+1),a  
09a8 3a b2 09			ld a, (.dmark+2)  
09ab 32 b6 fe			ld (debug_mark+2),a  
09ae 18 03			jr .pastdmark  
09b0 ..			.dmark: db "AP1"  
09b3 f1			.pastdmark: pop af  
09b4			endm  
# End of macro DMARK
09b4					CALLMONITOR 
09b4 cd 57 17			call break_point_state  
09b7				endm  
# End of macro CALLMONITOR
09b7				endif 
09b7			 
09b7 7d				ld a, l 
09b8 32 d8 fc			ld (store_tmpid), a 
09bb			 
09bb				; get file header  
09bb			 
09bb 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
09bd 3a d8 fc			ld a, (store_tmpid) 
09c0 5f				ld e, a 
09c1			 
09c1 21 40 00				ld hl, STORE_BLOCK_PHY 
09c4 cd eb 06				call storage_findnextid 
09c7			 
09c7 cd 03 0e			call ishlzero 
09ca 28 cc			jr z, .sa_notfound 
09cc			 
09cc 22 c9 fc			ld (store_tmppageid), hl 
09cf			 
09cf				; TODO handle file id not found 
09cf			 
09cf				if DEBUG_STORESE 
09cf					DMARK "AP2" 
09cf f5				push af  
09d0 3a e4 09			ld a, (.dmark)  
09d3 32 b4 fe			ld (debug_mark),a  
09d6 3a e5 09			ld a, (.dmark+1)  
09d9 32 b5 fe			ld (debug_mark+1),a  
09dc 3a e6 09			ld a, (.dmark+2)  
09df 32 b6 fe			ld (debug_mark+2),a  
09e2 18 03			jr .pastdmark  
09e4 ..			.dmark: db "AP2"  
09e7 f1			.pastdmark: pop af  
09e8			endm  
# End of macro DMARK
09e8					CALLMONITOR 
09e8 cd 57 17			call break_point_state  
09eb				endm  
# End of macro CALLMONITOR
09eb				endif 
09eb			 
09eb				; update file extent count 
09eb			 
09eb 11 df fc			ld de, store_page 
09ee			 
09ee cd b8 03			call storage_read_block 
09f1			 
09f1				if DEBUG_STORESE 
09f1					DMARK "AP3" 
09f1 f5				push af  
09f2 3a 06 0a			ld a, (.dmark)  
09f5 32 b4 fe			ld (debug_mark),a  
09f8 3a 07 0a			ld a, (.dmark+1)  
09fb 32 b5 fe			ld (debug_mark+1),a  
09fe 3a 08 0a			ld a, (.dmark+2)  
0a01 32 b6 fe			ld (debug_mark+2),a  
0a04 18 03			jr .pastdmark  
0a06 ..			.dmark: db "AP3"  
0a09 f1			.pastdmark: pop af  
0a0a			endm  
# End of macro DMARK
0a0a					CALLMONITOR 
0a0a cd 57 17			call break_point_state  
0a0d				endm  
# End of macro CALLMONITOR
0a0d				endif 
0a0d			;	ld (store_tmppageid), hl 
0a0d			 
0a0d 3a e1 fc			ld a, (store_page+2) 
0a10 3c				inc a 
0a11 32 e1 fc			ld (store_page+2), a 
0a14 32 d7 fc			ld (store_tmpext), a 
0a17				 
0a17				if DEBUG_STORESE 
0a17					DMARK "AP3" 
0a17 f5				push af  
0a18 3a 2c 0a			ld a, (.dmark)  
0a1b 32 b4 fe			ld (debug_mark),a  
0a1e 3a 2d 0a			ld a, (.dmark+1)  
0a21 32 b5 fe			ld (debug_mark+1),a  
0a24 3a 2e 0a			ld a, (.dmark+2)  
0a27 32 b6 fe			ld (debug_mark+2),a  
0a2a 18 03			jr .pastdmark  
0a2c ..			.dmark: db "AP3"  
0a2f f1			.pastdmark: pop af  
0a30			endm  
# End of macro DMARK
0a30					CALLMONITOR 
0a30 cd 57 17			call break_point_state  
0a33				endm  
# End of macro CALLMONITOR
0a33				endif 
0a33 2a c9 fc			ld hl, (store_tmppageid) 
0a36 11 df fc			ld de, store_page 
0a39 cd 1d 04			call storage_write_block 
0a3c			 
0a3c				; find free block 
0a3c			 
0a3c 11 00 00			ld de, 0			 ; file extent to locate 
0a3f			 
0a3f 21 40 00				ld hl, STORE_BLOCK_PHY 
0a42 cd eb 06				call storage_findnextid 
0a45 cd 03 0e			call ishlzero 
0a48 ca 98 09			jp z, .sa_notfound 
0a4b			 
0a4b					; TODO handle no space left 
0a4b					 
0a4b 22 c9 fc				ld (store_tmppageid), hl 
0a4e			 
0a4e				if DEBUG_STORESE 
0a4e					DMARK "AP4" 
0a4e f5				push af  
0a4f 3a 63 0a			ld a, (.dmark)  
0a52 32 b4 fe			ld (debug_mark),a  
0a55 3a 64 0a			ld a, (.dmark+1)  
0a58 32 b5 fe			ld (debug_mark+1),a  
0a5b 3a 65 0a			ld a, (.dmark+2)  
0a5e 32 b6 fe			ld (debug_mark+2),a  
0a61 18 03			jr .pastdmark  
0a63 ..			.dmark: db "AP4"  
0a66 f1			.pastdmark: pop af  
0a67			endm  
# End of macro DMARK
0a67					CALLMONITOR 
0a67 cd 57 17			call break_point_state  
0a6a				endm  
# End of macro CALLMONITOR
0a6a				endif 
0a6a					; init the buffer with zeros so we can id if the buffer is full or not 
0a6a			 
0a6a e5					push hl 
0a6b c5					push bc 
0a6c			 
0a6c 21 df fc				ld hl, store_page 
0a6f 06 40				ld b, STORE_BLOCK_PHY 
0a71 3e 00				ld a, 0 
0a73 77			.zeroblock:	ld (hl), a 
0a74 23					inc hl 
0a75 10 fc				djnz .zeroblock 
0a77			 
0a77 c1					pop bc 
0a78 e1					pop hl 
0a79			 
0a79					; construct block 
0a79			 
0a79 3a d8 fc				ld a, (store_tmpid) 
0a7c 32 df fc				ld (store_page), a   ; file id 
0a7f 3a d7 fc				ld a, (store_tmpext)   ; extent for this block 
0a82 32 e0 fc				ld (store_page+1), a 
0a85			 
0a85 e1					pop hl    ; get string to write 
0a86 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a88 11 e1 fc				ld de, store_page+2 
0a8b			 
0a8b				if DEBUG_STORESE 
0a8b					DMARK "AP5" 
0a8b f5				push af  
0a8c 3a a0 0a			ld a, (.dmark)  
0a8f 32 b4 fe			ld (debug_mark),a  
0a92 3a a1 0a			ld a, (.dmark+1)  
0a95 32 b5 fe			ld (debug_mark+1),a  
0a98 3a a2 0a			ld a, (.dmark+2)  
0a9b 32 b6 fe			ld (debug_mark+2),a  
0a9e 18 03			jr .pastdmark  
0aa0 ..			.dmark: db "AP5"  
0aa3 f1			.pastdmark: pop af  
0aa4			endm  
# End of macro DMARK
0aa4					CALLMONITOR 
0aa4 cd 57 17			call break_point_state  
0aa7				endm  
# End of macro CALLMONITOR
0aa7				endif 
0aa7			 
0aa7			 
0aa7			 
0aa7					; fill buffer with data until end of string or full block 
0aa7			 
0aa7 7e			.appd:		ld a, (hl) 
0aa8 12					ld (de), a 
0aa9 fe 00				cp 0 
0aab 28 04				jr z, .appdone 
0aad 23					inc hl 
0aae 13					inc de 
0aaf 10 f6				djnz .appd 
0ab1			 
0ab1 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0ab2 f5					push af   		; save last byte dumped 
0ab3			 
0ab3			 
0ab3 2a c9 fc			ld hl, (store_tmppageid) 
0ab6 11 df fc			ld de, store_page 
0ab9				if DEBUG_STORESE 
0ab9					DMARK "AP6" 
0ab9 f5				push af  
0aba 3a ce 0a			ld a, (.dmark)  
0abd 32 b4 fe			ld (debug_mark),a  
0ac0 3a cf 0a			ld a, (.dmark+1)  
0ac3 32 b5 fe			ld (debug_mark+1),a  
0ac6 3a d0 0a			ld a, (.dmark+2)  
0ac9 32 b6 fe			ld (debug_mark+2),a  
0acc 18 03			jr .pastdmark  
0ace ..			.dmark: db "AP6"  
0ad1 f1			.pastdmark: pop af  
0ad2			endm  
# End of macro DMARK
0ad2					CALLMONITOR 
0ad2 cd 57 17			call break_point_state  
0ad5				endm  
# End of macro CALLMONITOR
0ad5				endif 
0ad5 cd 1d 04				call storage_write_block 
0ad8			 
0ad8			 
0ad8				; was that a full block of data written? 
0ad8				; any more to write out? 
0ad8			 
0ad8				; if yes then set vars and jump to start of function again 
0ad8			 
0ad8 f1					pop af 
0ad9 d1					pop de 
0ada			 
0ada fe 00				cp 0		 ; no, string was fully written 
0adc c8					ret z 
0add			 
0add					; setup vars for next cycle 
0add			 
0add 3a d8 fc				ld a, (store_tmpid) 
0ae0 6f					ld l, a 
0ae1 26 00				ld h, 0 
0ae3			 
0ae3 c3 9a 09			 	jp storage_append	 ; yes, need to write out some more 
0ae6			 
0ae6			 
0ae6			 
0ae6			 
0ae6			 
0ae6			 
0ae6			 
0ae6			if DEBUG_STORECF 
0ae6			storageput:	 
0ae6					ret 
0ae6			storageread: 
0ae6					ld hl, store_page 
0ae6					ld b, 200 
0ae6					ld a,0 
0ae6			.src:		ld (hl),a 
0ae6					inc hl 
0ae6					djnz .src 
0ae6					 
0ae6			 
0ae6					ld de, 0 
0ae6					ld bc, 1 
0ae6					ld hl, store_page 
0ae6					call cfRead 
0ae6			 
0ae6				call cfGetError 
0ae6				ld hl,scratch 
0ae6				call hexout 
0ae6				ld hl, scratch+2 
0ae6				ld a, 0 
0ae6				ld (hl),a 
0ae6				ld de, scratch 
0ae6				ld a,display_row_1 
0ae6				call str_at_display 
0ae6				call update_display 
0ae6			 
0ae6					ld hl, store_page 
0ae6					ld (os_cur_ptr),hl 
0ae6			 
0ae6					ret 
0ae6			endif 
0ae6			 
0ae6			 
0ae6			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ae6			 
0ae6			storage_clear_page: 
0ae6 e5				push hl 
0ae7 d5				push de 
0ae8 c5				push bc 
0ae9 21 df fc			ld hl, store_page 
0aec 3e 00			ld a, 0 
0aee 77				ld (hl), a 
0aef			 
0aef 11 e0 fc			ld de, store_page+1 
0af2 01 40 00			ld bc, STORE_BLOCK_PHY 
0af5			 
0af5 ed b0			ldir 
0af7				 
0af7 c1				pop bc 
0af8 d1				pop de 
0af9 e1				pop hl 
0afa c9				ret 
0afb			 
0afb			; eof 
# End of file firmware_storage.asm
0afb			  
0afb			; support routines for above hardware abstraction layer  
0afb			  
0afb			include "firmware_general.asm"        ; general support functions  
0afb			 
0afb			; word look up 
0afb			 
0afb			; in 
0afb			; a is the index 
0afb			; hl is pointer start of array 
0afb			; 
0afb			; returns 
0afb			; hl to the word 
0afb			; 
0afb			 
0afb			table_lookup:  
0afb d5					push de 
0afc eb					ex de, hl 
0afd			 
0afd 6f					ld l, a 
0afe 26 00				ld h, 0 
0b00 29					add hl, hl 
0b01 19					add hl, de 
0b02 7e					ld a, (hl) 
0b03 23					inc hl 
0b04 66					ld h,(hl) 
0b05 6f					ld l, a 
0b06			 
0b06 d1					pop de 
0b07 c9					ret 
0b08			 
0b08			; Delay loops 
0b08			 
0b08			 
0b08			 
0b08			aDelayInMS: 
0b08 c5				push bc 
0b09 47				ld b,a 
0b0a			msdelay: 
0b0a c5				push bc 
0b0b				 
0b0b			 
0b0b 01 41 00			ld bc,041h 
0b0e cd 26 0b			call delayloop 
0b11 c1				pop bc 
0b12 05				dec b 
0b13 20 f5			jr nz,msdelay 
0b15			 
0b15			;if CPU_CLOCK_8MHZ 
0b15			;msdelay8: 
0b15			;	push bc 
0b15			;	 
0b15			; 
0b15			;	ld bc,041h 
0b15			;	call delayloop 
0b15			;	pop bc 
0b15			;	dec b 
0b15			;	jr nz,msdelay8 
0b15			;endif 
0b15			 
0b15			 
0b15 c1				pop bc 
0b16 c9				ret 
0b17			 
0b17			 
0b17			delay250ms: 
0b17				;push de 
0b17 01 00 40			ld bc, 04000h 
0b1a c3 26 0b			jp delayloop 
0b1d			delay500ms: 
0b1d				;push de 
0b1d 01 00 80			ld bc, 08000h 
0b20 c3 26 0b			jp delayloop 
0b23			delay1s: 
0b23				;push bc 
0b23			   ; Clobbers A, d and e 
0b23 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b26			delayloop: 
0b26 c5			    push bc 
0b27			 
0b27			if BASE_CPM 
0b27				ld bc, CPM_DELAY_TUNE 
0b27			.cpmloop: 
0b27				push bc 
0b27			 
0b27			endif 
0b27			 
0b27			 
0b27			 
0b27			delayloopi: 
0b27			;	push bc 
0b27			;.dl: 
0b27 cb 47		    bit     0,a    	; 8 
0b29 cb 47		    bit     0,a    	; 8 
0b2b cb 47		    bit     0,a    	; 8 
0b2d e6 ff		    and     255  	; 7 
0b2f 0b			    dec     bc      	; 6 
0b30 79			    ld      a,c     	; 4 
0b31 b0			    or      b     	; 4 
0b32 c2 27 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b35			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b35				;pop de 
0b35			;pop bc 
0b35			 
0b35			if BASE_CPM 
0b35				pop bc 
0b35				 
0b35			    dec     bc      	; 6 
0b35			    ld      a,c     	; 4 
0b35			    or      b     	; 4 
0b35			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b35				 
0b35			 
0b35			endif 
0b35			;if CPU_CLOCK_8MHZ 
0b35			;    pop bc 
0b35			;    push bc 
0b35			;.dl8: 
0b35			;    bit     0,a    	; 8 
0b35			;    bit     0,a    	; 8 
0b35			;    bit     0,a    	; 8 
0b35			;    and     255  	; 7 
0b35			;    dec     bc      	; 6 
0b35			;    ld      a,c     	; 4 
0b35			;    or      b     	; 4 
0b35			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b35			;endif 
0b35			 
0b35			;if CPU_CLOCK_10MHZ 
0b35			;    pop bc 
0b35			;    push bc 
0b35			;.dl8: 
0b35			;    bit     0,a    	; 8 
0b35			;    bit     0,a    	; 8 
0b35			;    bit     0,a    	; 8 
0b35			;    and     255  	; 7 
0b35			;    dec     bc      	; 6 
0b35			;    ld      a,c     	; 4 
0b35			;    or      b     	; 4 
0b35			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b35			;endif 
0b35 c1			    pop bc 
0b36			 
0b36 c9				ret 
0b37			 
0b37			 
0b37			 
0b37			; eof 
# End of file firmware_general.asm
0b37			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b37			; display routines that use the physical hardware abstraction layer 
0b37			 
0b37			 
0b37			; information window 
0b37			 
0b37			; pass hl with 1st string to display 
0b37			; pass de with 2nd string to display 
0b37			 
0b37			info_panel: 
0b37 e5				push hl 
0b38			 
0b38 2a 55 fd			ld hl, (display_fb_active) 
0b3b e5				push hl    ; future de destination 
0b3c 21 4a fe				ld hl, display_fb0 
0b3f 22 55 fd				ld (display_fb_active), hl 
0b42			 
0b42			;	call clear_display 
0b42			 
0b42				if BASE_CPM 
0b42				ld a, '.' 
0b42				else 
0b42 3e a5			ld a, 165 
0b44				endif 
0b44 cd ab 0b			call fill_display 
0b47			 
0b47			 
0b47 3e 2d			ld a, display_row_3 + 5 
0b49 cd b9 0b			call str_at_display 
0b4c			 
0b4c e1				pop hl 
0b4d d1				pop de 
0b4e			 
0b4e e5				push hl 
0b4f			 
0b4f			 
0b4f 3e 19			ld a, display_row_2 + 5 
0b51 cd b9 0b			call str_at_display 
0b54			 
0b54			 
0b54 cd c9 0b			call update_display 
0b57 cd 2c 1d			call next_page_prompt 
0b5a cd a6 0b			call clear_display 
0b5d			 
0b5d				 
0b5d 21 f9 fd				ld hl, display_fb1 
0b60 22 55 fd				ld (display_fb_active), hl 
0b63 cd c9 0b			call update_display 
0b66			 
0b66 e1				pop hl 
0b67			 
0b67 c9				ret 
0b68			 
0b68			 
0b68			 
0b68			 
0b68			; TODO windowing? 
0b68			 
0b68			; TODO scroll line up 
0b68			 
0b68			scroll_up: 
0b68			 
0b68 e5				push hl 
0b69 d5				push de 
0b6a c5				push bc 
0b6b			 
0b6b				; get frame buffer  
0b6b			 
0b6b 2a 55 fd			ld hl, (display_fb_active) 
0b6e e5				push hl    ; future de destination 
0b6f			 
0b6f 11 14 00			ld  de, display_cols 
0b72 19				add hl, de 
0b73			 
0b73 d1				pop de 
0b74			 
0b74				;ex de, hl 
0b74 01 4f 00			ld bc, display_fb_len -1  
0b77			;if DEBUG_FORTH_WORDS 
0b77			;	DMARK "SCL" 
0b77			;	CALLMONITOR 
0b77			;endif	 
0b77 ed b0			ldir 
0b79			 
0b79				; wipe bottom row 
0b79			 
0b79			 
0b79 2a 55 fd			ld hl, (display_fb_active) 
0b7c 11 50 00			ld de, display_cols*display_rows 
0b7f 19				add hl, de 
0b80 06 14			ld b, display_cols 
0b82 3e 20			ld a, ' ' 
0b84			.scwipe: 
0b84 77				ld (hl), a 
0b85 2b				dec hl 
0b86 10 fc			djnz .scwipe 
0b88			 
0b88				;pop hl 
0b88			 
0b88 c1				pop bc 
0b89 d1				pop de 
0b8a e1				pop hl 
0b8b			 
0b8b c9				ret 
0b8c			 
0b8c			 
0b8c			;scroll_upo: 
0b8c			;	ld de, display_row_1 
0b8c			 ;	ld hl, display_row_2 
0b8c			;	ld bc, display_cols 
0b8c			;	ldir 
0b8c			;	ld de, display_row_2 
0b8c			 ;	ld hl, display_row_3 
0b8c			;	ld bc, display_cols 
0b8c			;	ldir 
0b8c			;	ld de, display_row_3 
0b8c			 ;	ld hl, display_row_4 
0b8c			;	ld bc, display_cols 
0b8c			;	ldir 
0b8c			 
0b8c			; TODO clear row 4 
0b8c			 
0b8c			;	ret 
0b8c			 
0b8c				 
0b8c			scroll_down: 
0b8c			 
0b8c e5				push hl 
0b8d d5				push de 
0b8e c5				push bc 
0b8f			 
0b8f				; get frame buffer  
0b8f			 
0b8f 2a 55 fd			ld hl, (display_fb_active) 
0b92			 
0b92 11 4f 00			ld de, display_fb_len - 1 
0b95 19				add hl, de 
0b96			 
0b96 e5			push hl    ; future de destination 
0b97			 
0b97 11 14 00			ld  de, display_cols 
0b9a ed 52			sbc hl, de 
0b9c			 
0b9c			 
0b9c d1				pop de 
0b9d			 
0b9d			;	ex de, hl 
0b9d 01 4f 00			ld bc, display_fb_len -1  
0ba0			 
0ba0			 
0ba0				 
0ba0			 
0ba0 ed b0			ldir 
0ba2			 
0ba2				; wipe bottom row 
0ba2			 
0ba2			 
0ba2			;	ld hl, (display_fb_active) 
0ba2			;;	ld de, display_cols*display_rows 
0ba2			;;	add hl, de 
0ba2			;	ld b, display_cols 
0ba2			;	ld a, ' ' 
0ba2			;.scwiped: 
0ba2			;	ld (hl), a 
0ba2			;	dec hl 
0ba2			;	djnz .scwiped 
0ba2			 
0ba2				;pop hl 
0ba2			 
0ba2 c1				pop bc 
0ba3 d1				pop de 
0ba4 e1				pop hl 
0ba5			 
0ba5 c9				ret 
0ba6			;scroll_down: 
0ba6			;	ld de, display_row_4 
0ba6			;	ld hl, display_row_3 
0ba6			;	ld bc, display_cols 
0ba6			;	ldir 
0ba6			;	ld de, display_row_3 
0ba6			; 	ld hl, display_row_2 
0ba6			;	ld bc, display_cols 
0ba6			;	ldir 
0ba6			;	ld de, display_row_2 
0ba6			;	ld hl, display_row_1 
0ba6			;	ld bc, display_cols 
0ba6			;	ldir 
0ba6			;;; TODO clear row 1 
0ba6			;	ret 
0ba6			 
0ba6			 
0ba6			 
0ba6			 
0ba6			 
0ba6			; clear active frame buffer 
0ba6			 
0ba6			clear_display: 
0ba6 3e 20			ld a, ' ' 
0ba8 c3 ab 0b			jp fill_display 
0bab			 
0bab			; fill active frame buffer with a char in A 
0bab			 
0bab			fill_display: 
0bab 06 50			ld b,display_fb_len 
0bad 2a 55 fd			ld hl, (display_fb_active) 
0bb0 77			.fd1:	ld (hl),a 
0bb1 23				inc hl 
0bb2 10 fc			djnz .fd1 
0bb4 23				inc hl 
0bb5 3e 00			ld a,0 
0bb7 77				ld (hl),a 
0bb8			 
0bb8			 
0bb8 c9				ret 
0bb9			; Write string (DE) at pos (A) to active frame buffer 
0bb9			 
0bb9 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0bbc 06 00					ld b,0 
0bbe 4f					ld c,a 
0bbf 09					add hl,bc 
0bc0 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bc1 b7			            OR   A              ;Null terminator? 
0bc2 c8			            RET  Z              ;Yes, so finished 
0bc3 77					ld (hl),a 
0bc4 23				inc hl 
0bc5 13			            INC  DE             ;Point to next character 
0bc6 18 f8		            JR   .sad1     ;Repeat 
0bc8 c9					ret 
0bc9			 
0bc9			; using current frame buffer write to physical display 
0bc9			 
0bc9			update_display: 
0bc9 e5				push hl 
0bca 2a 55 fd			ld hl, (display_fb_active) 
0bcd cd 7d 67			call write_display 
0bd0 e1				pop hl 
0bd1 c9				ret 
0bd2			 
0bd2			; TODO scrolling 
0bd2			 
0bd2			 
0bd2			; move cursor right one char 
0bd2			cursor_right: 
0bd2			 
0bd2				; TODO shift right 
0bd2				; TODO if beyond max col 
0bd2				; TODO       cursor_next_line 
0bd2			 
0bd2 c9				ret 
0bd3			 
0bd3			 
0bd3			cursor_next_line: 
0bd3				; TODO first char 
0bd3				; TODO line down 
0bd3				; TODO if past last row 
0bd3				; TODO    scroll up 
0bd3			 
0bd3 c9				ret 
0bd4			 
0bd4			cursor_left: 
0bd4				; TODO shift left 
0bd4				; TODO if beyond left  
0bd4				; TODO     cursor prev line 
0bd4				 
0bd4 c9				ret 
0bd5			 
0bd5			cursor_prev_line: 
0bd5				; TODO last char 
0bd5				; TODO line up 
0bd5				; TODO if past first row 
0bd5				; TODO   scroll down 
0bd5			 
0bd5 c9				ret 
0bd6			 
0bd6			 
0bd6			cout: 
0bd6				; A - char 
0bd6 c9				ret 
0bd7			 
0bd7			 
0bd7			; Display a menu and allow item selection (optional toggle items) 
0bd7			; 
0bd7			; format: 
0bd7			; hl pointer to word array with zero term for items 
0bd7			; e.g.    db item1 
0bd7			;         db .... 
0bd7			;         db 0 
0bd7			; 
0bd7			; a = starting menu item  
0bd7			; 
0bd7			; de = pointer item toggle array   (todo) 
0bd7			; 
0bd7			; returns item selected in a 1-... 
0bd7			; returns 0 if back button pressed 
0bd7			; 
0bd7			; NOTE: Uses system frame buffer to display 
0bd7			; 
0bd7			; LEFT, Q = go back 
0bd7			; RIGHT, SPACE, CR = select 
0bd7			; UP, A - Up 
0bd7			; DOWN, Z - Down 
0bd7			 
0bd7			 
0bd7			 
0bd7			 
0bd7			 
0bd7			menu: 
0bd7			 
0bd7					; keep array pointer 
0bd7			 
0bd7 22 dd fc				ld (store_tmp1), hl 
0bda 32 db fc				ld (store_tmp2), a 
0bdd			 
0bdd					; check for key bounce 
0bdd			 
0bdd			if BASE_KEV 
0bdd			 
0bdd cd 32 69		.mbounce:	call cin 
0be0 fe 00				cp 0 
0be2 20 f9				jr nz, .mbounce 
0be4			endif 
0be4					; for ease use ex 
0be4			 
0be4					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0be4 21 4a fe				ld hl, display_fb0 
0be7 22 55 fd				ld (display_fb_active), hl 
0bea			 
0bea cd a6 0b		.mloop:		call clear_display 
0bed cd c9 0b				call update_display 
0bf0			 
0bf0					; draw selection id '>' at 1 
0bf0			 
0bf0					; init start of list display 
0bf0			 
0bf0 3e 05				ld a, 5 
0bf2 32 d9 fc				ld (store_tmp3), a   ; display row count 
0bf5 3a db fc				ld a,( store_tmp2) 
0bf8 32 dc fc				ld (store_tmp2+1), a   ; display item count 
0bfb			 
0bfb					 
0bfb			.mitem:	 
0bfb			 
0bfb			 
0bfb 3a dc fc				ld a,(store_tmp2+1) 
0bfe 6f					ld l, a 
0bff 26 00				ld h, 0 
0c01 29					add hl, hl 
0c02 ed 5b dd fc			ld de, (store_tmp1) 
0c06 19					add hl, de 
0c07 7e					ld a, (hl) 
0c08 23					inc hl 
0c09 66					ld h,(hl) 
0c0a 6f					ld l, a 
0c0b			 
0c0b cd 03 0e				call ishlzero 
0c0e 28 1a				jr z, .mdone 
0c10			 
0c10 eb					ex de, hl 
0c11 3a d9 fc				ld a, (store_tmp3) 
0c14 cd b9 0b				call str_at_display 
0c17					 
0c17			 
0c17					; next item 
0c17 3a dc fc				ld a, (store_tmp2+1) 
0c1a 3c					inc a 
0c1b 32 dc fc				ld (store_tmp2+1), a   ; display item count 
0c1e			 
0c1e			 		; next row 
0c1e			 
0c1e 3a d9 fc				ld a, (store_tmp3) 
0c21 c6 14				add display_cols 
0c23 32 d9 fc				ld (store_tmp3), a 
0c26			 
0c26					; at end of screen? 
0c26			 
0c26 fe 10				cp display_rows*4 
0c28 20 d1				jr nz, .mitem 
0c2a			 
0c2a			 
0c2a			.mdone: 
0c2a cd 03 0e				call ishlzero 
0c2d 28 08				jr z, .nodn 
0c2f			 
0c2f 3e 3c				ld a, display_row_4 
0c31 11 b0 0c				ld de, .mdown 
0c34 cd b9 0b				call str_at_display 
0c37			 
0c37					; draw options to fill the screens with active item on line 1 
0c37					; if current option is 2 or more then display ^ in top 
0c37			 
0c37 3a db fc		.nodn:		ld a, (store_tmp2) 
0c3a fe 00				cp 0 
0c3c 28 08				jr z, .noup 
0c3e			 
0c3e 3e 00				ld a, 0 
0c40 11 ae 0c				ld de, .mup 
0c43 cd b9 0b				call str_at_display 
0c46			 
0c46 3e 02		.noup:		ld a, 2 
0c48 11 ac 0c				ld de, .msel 
0c4b cd b9 0b				call str_at_display 
0c4e			 
0c4e					; if current option + 1 is not null then display V in bottom 
0c4e					; get key 
0c4e cd c9 0b				call update_display 
0c51			 
0c51			 
0c51					; handle key 
0c51			 
0c51 cd 21 69				call cin_wait 
0c54			 
0c54 fe 05				cp KEY_UP 
0c56 28 2b				jr z, .mgoup 
0c58 fe 61				cp 'a' 
0c5a 28 27				jr z, .mgoup 
0c5c fe 0a				cp KEY_DOWN 
0c5e 28 32				jr z, .mgod 
0c60 fe 7a				cp 'z' 
0c62 28 2e				jr z, .mgod 
0c64 fe 20				cp ' ' 
0c66 28 34				jr z, .goend 
0c68 fe 0c				cp KEY_RIGHT 
0c6a 28 30				jr z, .goend 
0c6c fe 0d				cp KEY_CR 
0c6e 28 2c				jr z, .goend 
0c70 fe 71				cp 'q' 
0c72 28 0b				jr z, .goback 
0c74			 
0c74 fe 0b				cp KEY_LEFT 
0c76 28 07				jr z, .goback 
0c78 fe 08				cp KEY_BS 
0c7a 28 03				jr z, .goback 
0c7c c3 ea 0b				jp .mloop 
0c7f			 
0c7f			.goback: 
0c7f 3e 00			ld a, 0 
0c81 18 1d			jr .goend2 
0c83			 
0c83				; move up one 
0c83			.mgoup: 
0c83 3a db fc				ld a, (store_tmp2) 
0c86 fe 00				cp 0 
0c88 ca ea 0b				jp z, .mloop 
0c8b 3d					dec a 
0c8c 32 db fc				ld (store_tmp2), a 
0c8f c3 ea 0b				jp .mloop 
0c92			 
0c92				; move down one 
0c92			.mgod: 
0c92 3a db fc				ld a, (store_tmp2) 
0c95 3c					inc a 
0c96 32 db fc				ld (store_tmp2), a 
0c99 c3 ea 0b				jp .mloop 
0c9c			 
0c9c			 
0c9c			.goend: 
0c9c					; get selected item number 
0c9c			 
0c9c 3a db fc				ld a, (store_tmp2) 
0c9f 3c					inc a 
0ca0			 
0ca0			.goend2: 
0ca0 f5					push af 
0ca1			 
0ca1					; restore active fb 
0ca1					; TODO BUG assumes fb1 
0ca1			 
0ca1 21 f9 fd				ld hl, display_fb1 
0ca4 22 55 fd				ld (display_fb_active), hl 
0ca7			 
0ca7					; restore main regs 
0ca7			 
0ca7			 
0ca7 cd c9 0b				call update_display 
0caa			 
0caa f1					pop af 
0cab			 
0cab c9				ret 
0cac			 
0cac .. 00		.msel:   db ">",0 
0cae .. 00		.mup:   db "^",0 
0cb0 .. 00		.mdown:   db "v",0 
0cb2			 
0cb2			 
0cb2			; eof 
0cb2			 
# End of file firmware_display.asm
0cb2			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cb2			; random number generators 
0cb2			 
0cb2			 
0cb2			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cb2			 
0cb2			 
0cb2			;-----> Generate a random number 
0cb2			; output a=answer 0<=a<=255 
0cb2			; all registers are preserved except: af 
0cb2			random: 
0cb2 e5			        push    hl 
0cb3 d5			        push    de 
0cb4 2a 37 fd		        ld      hl,(randData) 
0cb7 ed 5f		        ld      a,r 
0cb9 57			        ld      d,a 
0cba 5e			        ld      e,(hl) 
0cbb 19			        add     hl,de 
0cbc 85			        add     a,l 
0cbd ac			        xor     h 
0cbe 22 37 fd		        ld      (randData),hl 
0cc1 d1			        pop     de 
0cc2 e1			        pop     hl 
0cc3 c9			        ret 
0cc4			 
0cc4			 
0cc4			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cc4			 
0cc4			 
0cc4			 
0cc4			;------LFSR------ 
0cc4			;James Montelongo 
0cc4			;optimized by Spencer Putt 
0cc4			;out: 
0cc4			; a = 8 bit random number 
0cc4			RandLFSR: 
0cc4 21 3d fd		        ld hl,LFSRSeed+4 
0cc7 5e			        ld e,(hl) 
0cc8 23			        inc hl 
0cc9 56			        ld d,(hl) 
0cca 23			        inc hl 
0ccb 4e			        ld c,(hl) 
0ccc 23			        inc hl 
0ccd 7e			        ld a,(hl) 
0cce 47			        ld b,a 
0ccf cb 13		        rl e  
0cd1 cb 12			rl d 
0cd3 cb 11		        rl c  
0cd5 17				rla 
0cd6 cb 13		        rl e  
0cd8 cb 12			rl d 
0cda cb 11		        rl c  
0cdc 17				rla 
0cdd cb 13		        rl e  
0cdf cb 12			rl d 
0ce1 cb 11		        rl c  
0ce3 17				rla 
0ce4 67			        ld h,a 
0ce5 cb 13		        rl e  
0ce7 cb 12			rl d 
0ce9 cb 11		        rl c  
0ceb 17				rla 
0cec a8			        xor b 
0ced cb 13		        rl e  
0cef cb 12			rl d 
0cf1 ac			        xor h 
0cf2 a9			        xor c 
0cf3 aa			        xor d 
0cf4 21 3f fd		        ld hl,LFSRSeed+6 
0cf7 11 40 fd		        ld de,LFSRSeed+7 
0cfa 01 07 00		        ld bc,7 
0cfd ed b8		        lddr 
0cff 12			        ld (de),a 
0d00 c9			        ret 
0d01			 
0d01			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d01			 
0d01			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d01			 
0d01			 
0d01			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d01			 
0d01			prng16: 
0d01			;Inputs: 
0d01			;   (seed1) contains a 16-bit seed value 
0d01			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d01			;Outputs: 
0d01			;   HL is the result 
0d01			;   BC is the result of the LCG, so not that great of quality 
0d01			;   DE is preserved 
0d01			;Destroys: 
0d01			;   AF 
0d01			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d01			;160cc 
0d01			;26 bytes 
0d01 2a 31 fd		    ld hl,(seed1) 
0d04 44			    ld b,h 
0d05 4d			    ld c,l 
0d06 29			    add hl,hl 
0d07 29			    add hl,hl 
0d08 2c			    inc l 
0d09 09			    add hl,bc 
0d0a 22 31 fd		    ld (seed1),hl 
0d0d 2a 2f fd		    ld hl,(seed2) 
0d10 29			    add hl,hl 
0d11 9f			    sbc a,a 
0d12 e6 2d		    and %00101101 
0d14 ad			    xor l 
0d15 6f			    ld l,a 
0d16 22 2f fd		    ld (seed2),hl 
0d19 09			    add hl,bc 
0d1a c9			    ret 
0d1b			 
0d1b			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d1b			 
0d1b			rand32: 
0d1b			;Inputs: 
0d1b			;   (seed1_0) holds the lower 16 bits of the first seed 
0d1b			;   (seed1_1) holds the upper 16 bits of the first seed 
0d1b			;   (seed2_0) holds the lower 16 bits of the second seed 
0d1b			;   (seed2_1) holds the upper 16 bits of the second seed 
0d1b			;   **NOTE: seed2 must be non-zero 
0d1b			;Outputs: 
0d1b			;   HL is the result 
0d1b			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d1b			;Destroys: 
0d1b			;   AF 
0d1b			;Tested and passes all CAcert tests 
0d1b			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d1b			;it has a period of 18,446,744,069,414,584,320 
0d1b			;roughly 18.4 quintillion. 
0d1b			;LFSR taps: 0,2,6,7  = 11000101 
0d1b			;291cc 
0d1b			;seed1_0=$+1 
0d1b			;    ld hl,12345 
0d1b			;seed1_1=$+1 
0d1b			;    ld de,6789 
0d1b			;    ld b,h 
0d1b			;    ld c,l 
0d1b			;    add hl,hl \ rl e \ rl d 
0d1b			;    add hl,hl \ rl e \ rl d 
0d1b			;    inc l 
0d1b			;    add hl,bc 
0d1b			;    ld (seed1_0),hl 
0d1b			;    ld hl,(seed1_1) 
0d1b			;    adc hl,de 
0d1b			;    ld (seed1_1),hl 
0d1b			;    ex de,hl 
0d1b			;seed2_0=$+1 
0d1b			;    ld hl,9876 
0d1b			;seed2_1=$+1 
0d1b			;    ld bc,54321 
0d1b			;    add hl,hl \ rl c \ rl b 
0d1b			;    ld (seed2_1),bc 
0d1b			;    sbc a,a 
0d1b			;    and %11000101 
0d1b			;    xor l 
0d1b			;    ld l,a 
0d1b			;    ld (seed2_0),hl 
0d1b			;    ex de,hl 
0d1b			;    add hl,bc 
0d1b			;    ret 
0d1b			; 
0d1b			 
0d1b			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d1b			; 20 bytes, 86 cycles (excluding ret) 
0d1b			 
0d1b			; returns   hl = pseudorandom number 
0d1b			; corrupts   a 
0d1b			 
0d1b			; generates 16-bit pseudorandom numbers with a period of 65535 
0d1b			; using the xorshift method: 
0d1b			 
0d1b			; hl ^= hl << 7 
0d1b			; hl ^= hl >> 9 
0d1b			; hl ^= hl << 8 
0d1b			 
0d1b			; some alternative shift triplets which also perform well are: 
0d1b			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d1b			 
0d1b			;  org 32768 
0d1b			 
0d1b			xrnd: 
0d1b 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0d1e 3e 00		  ld a,0 
0d20 bd			  cp l 
0d21 20 02		  jr nz, .xrnd1 
0d23 2e 01		  ld l, 1 
0d25			.xrnd1: 
0d25			 
0d25 7c			  ld a,h 
0d26 1f			  rra 
0d27 7d			  ld a,l 
0d28 1f			  rra 
0d29 ac			  xor h 
0d2a 67			  ld h,a 
0d2b 7d			  ld a,l 
0d2c 1f			  rra 
0d2d 7c			  ld a,h 
0d2e 1f			  rra 
0d2f ad			  xor l 
0d30 6f			  ld l,a 
0d31 ac			  xor h 
0d32 67			  ld h,a 
0d33			 
0d33 22 35 fd		  ld (xrandc),hl 
0d36			 
0d36 c9			  ret 
0d37			;  
0d37			 
0d37			 
0d37			;;;; int maths 
0d37			 
0d37			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d37			; Divide 16-bit values (with 16-bit result) 
0d37			; In: Divide BC by divider DE 
0d37			; Out: BC = result, HL = rest 
0d37			; 
0d37			Div16: 
0d37 21 00 00		    ld hl,0 
0d3a 78			    ld a,b 
0d3b 06 08		    ld b,8 
0d3d			Div16_Loop1: 
0d3d 17			    rla 
0d3e ed 6a		    adc hl,hl 
0d40 ed 52		    sbc hl,de 
0d42 30 01		    jr nc,Div16_NoAdd1 
0d44 19			    add hl,de 
0d45			Div16_NoAdd1: 
0d45 10 f6		    djnz Div16_Loop1 
0d47 17			    rla 
0d48 2f			    cpl 
0d49 47			    ld b,a 
0d4a 79			    ld a,c 
0d4b 48			    ld c,b 
0d4c 06 08		    ld b,8 
0d4e			Div16_Loop2: 
0d4e 17			    rla 
0d4f ed 6a		    adc hl,hl 
0d51 ed 52		    sbc hl,de 
0d53 30 01		    jr nc,Div16_NoAdd2 
0d55 19			    add hl,de 
0d56			Div16_NoAdd2: 
0d56 10 f6		    djnz Div16_Loop2 
0d58 17			    rla 
0d59 2f			    cpl 
0d5a 41			    ld b,c 
0d5b 4f			    ld c,a 
0d5c c9			ret 
0d5d			 
0d5d			 
0d5d			;http://z80-heaven.wikidot.com/math 
0d5d			; 
0d5d			;Inputs: 
0d5d			;     DE and A are factors 
0d5d			;Outputs: 
0d5d			;     A is not changed 
0d5d			;     B is 0 
0d5d			;     C is not changed 
0d5d			;     DE is not changed 
0d5d			;     HL is the product 
0d5d			;Time: 
0d5d			;     342+6x 
0d5d			; 
0d5d			Mult16: 
0d5d			 
0d5d 06 08		     ld b,8          ;7           7 
0d5f 21 00 00		     ld hl,0         ;10         10 
0d62 29			       add hl,hl     ;11*8       88 
0d63 07			       rlca          ;4*8        32 
0d64 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d66 19			         add hl,de   ;--         -- 
0d67 10 f9		       djnz $-5      ;13*7+8     99 
0d69 c9			ret 
0d6a			 
0d6a			; 
0d6a			; Square root of 16-bit value 
0d6a			; In:  HL = value 
0d6a			; Out:  D = result (rounded down) 
0d6a			; 
0d6a			;Sqr16: 
0d6a			;    ld de,#0040 
0d6a			;    ld a,l 
0d6a			;    ld l,h 
0d6a			;    ld h,d 
0d6a			;    or a 
0d6a			;    ld b,8 
0d6a			;Sqr16_Loop: 
0d6a			;    sbc hl,de 
0d6a			;    jr nc,Sqr16_Skip 
0d6a			;    add hl,de 
0d6a			;Sqr16_Skip: 
0d6a			;    ccf 
0d6a			;    rl d 
0d6a			;    add a,a 
0d6a			;    adc hl,hl 
0d6a			;    add a,a 
0d6a			;    adc hl,hl 
0d6a			;    djnz Sqr16_Loop 
0d6a			;    ret 
0d6a			; 
0d6a			; 
0d6a			; Divide 8-bit values 
0d6a			; In: Divide E by divider C 
0d6a			; Out: A = result, B = rest 
0d6a			; 
0d6a			Div8: 
0d6a af			    xor a 
0d6b 06 08		    ld b,8 
0d6d			Div8_Loop: 
0d6d cb 13		    rl e 
0d6f 17			    rla 
0d70 91			    sub c 
0d71 30 01		    jr nc,Div8_NoAdd 
0d73 81			    add a,c 
0d74			Div8_NoAdd: 
0d74 10 f7		    djnz Div8_Loop 
0d76 47			    ld b,a 
0d77 7b			    ld a,e 
0d78 17			    rla 
0d79 2f			    cpl 
0d7a c9			    ret 
0d7b			 
0d7b			; 
0d7b			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d7b			; In: Multiply A with DE 
0d7b			; Out: HL = result 
0d7b			; 
0d7b			Mult12U: 
0d7b 2e 00		    ld l,0 
0d7d 87			    add a,a 
0d7e 30 01		    jr nc,Mult12U_NoAdd0 
0d80 19			    add hl,de 
0d81			Mult12U_NoAdd0: 
0d81 29			    add hl,hl 
0d82 87			    add a,a 
0d83 30 01		    jr nc,Mult12U_NoAdd1 
0d85 19			    add hl,de 
0d86			Mult12U_NoAdd1: 
0d86 29			    add hl,hl 
0d87 87			    add a,a 
0d88 30 01		    jr nc,Mult12U_NoAdd2 
0d8a 19			    add hl,de 
0d8b			Mult12U_NoAdd2: 
0d8b 29			    add hl,hl 
0d8c 87			    add a,a 
0d8d 30 01		    jr nc,Mult12U_NoAdd3 
0d8f 19			    add hl,de 
0d90			Mult12U_NoAdd3: 
0d90 29			    add hl,hl 
0d91 87			    add a,a 
0d92 30 01		    jr nc,Mult12U_NoAdd4 
0d94 19			    add hl,de 
0d95			Mult12U_NoAdd4: 
0d95 29			    add hl,hl 
0d96 87			    add a,a 
0d97 30 01		    jr nc,Mult12U_NoAdd5 
0d99 19			    add hl,de 
0d9a			Mult12U_NoAdd5: 
0d9a 29			    add hl,hl 
0d9b 87			    add a,a 
0d9c 30 01		    jr nc,Mult12U_NoAdd6 
0d9e 19			    add hl,de 
0d9f			Mult12U_NoAdd6: 
0d9f 29			    add hl,hl 
0da0 87			    add a,a 
0da1 d0			    ret nc 
0da2 19			    add hl,de 
0da3 c9			    ret 
0da4			 
0da4			; 
0da4			; Multiply 8-bit value with a 16-bit value (right rotating) 
0da4			; In: Multiply A with DE 
0da4			;      Put lowest value in A for most efficient calculation 
0da4			; Out: HL = result 
0da4			; 
0da4			Mult12R: 
0da4 21 00 00		    ld hl,0 
0da7			Mult12R_Loop: 
0da7 cb 3f		    srl a 
0da9 30 01		    jr nc,Mult12R_NoAdd 
0dab 19			    add hl,de 
0dac			Mult12R_NoAdd: 
0dac cb 23		    sla e 
0dae cb 12		    rl d 
0db0 b7			    or a 
0db1 c2 a7 0d		    jp nz,Mult12R_Loop 
0db4 c9			    ret 
0db5			 
0db5			; 
0db5			; Multiply 16-bit values (with 32-bit result) 
0db5			; In: Multiply BC with DE 
0db5			; Out: BCHL = result 
0db5			; 
0db5			Mult32: 
0db5 79			    ld a,c 
0db6 48			    ld c,b 
0db7 21 00 00		    ld hl,0 
0dba 06 10		    ld b,16 
0dbc			Mult32_Loop: 
0dbc 29			    add hl,hl 
0dbd 17			    rla 
0dbe cb 11		    rl c 
0dc0 30 07		    jr nc,Mult32_NoAdd 
0dc2 19			    add hl,de 
0dc3 ce 00		    adc a,0 
0dc5 d2 c9 0d		    jp nc,Mult32_NoAdd 
0dc8 0c			    inc c 
0dc9			Mult32_NoAdd: 
0dc9 10 f1		    djnz Mult32_Loop 
0dcb 41			    ld b,c 
0dcc 4f			    ld c,a 
0dcd c9			    ret 
0dce			 
0dce			 
0dce			 
0dce			; 
0dce			; Multiply 8-bit values 
0dce			; In:  Multiply H with E 
0dce			; Out: HL = result 
0dce			; 
0dce			Mult8: 
0dce 16 00		    ld d,0 
0dd0 6a			    ld l,d 
0dd1 06 08		    ld b,8 
0dd3			Mult8_Loop: 
0dd3 29			    add hl,hl 
0dd4 30 01		    jr nc,Mult8_NoAdd 
0dd6 19			    add hl,de 
0dd7			Mult8_NoAdd: 
0dd7 10 fa		    djnz Mult8_Loop 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			;;http://z80-heaven.wikidot.com/math 
0dda			;;This divides DE by BC, storing the result in DE, remainder in HL 
0dda			; 
0dda			;DE_Div_BC:          ;1281-2x, x is at most 16 
0dda			;     ld a,16        ;7 
0dda			;     ld hl,0        ;10 
0dda			;     jp $+5         ;10 
0dda			;.DivLoop: 
0dda			;       add hl,bc    ;-- 
0dda			;       dec a        ;64 
0dda			;       jr z,.DivLoopEnd        ;86 
0dda			; 
0dda			;       sla e        ;128 
0dda			;       rl d         ;128 
0dda			;       adc hl,hl    ;240 
0dda			;       sbc hl,bc    ;240 
0dda			;       jr nc,.DivLoop ;23|21 
0dda			;       inc e        ;-- 
0dda			;       jp .DivLoop+1 
0dda			; 
0dda			;.DivLoopEnd: 
0dda			 
0dda			;HL_Div_C: 
0dda			;Inputs: 
0dda			;     HL is the numerator 
0dda			;     C is the denominator 
0dda			;Outputs: 
0dda			;     A is the remainder 
0dda			;     B is 0 
0dda			;     C is not changed 
0dda			;     DE is not changed 
0dda			;     HL is the quotient 
0dda			; 
0dda			;       ld b,16 
0dda			;       xor a 
0dda			;         add hl,hl 
0dda			;         rla 
0dda			;         cp c 
0dda			;         jr c,$+4 
0dda			;           inc l 
0dda			;           sub c 
0dda			;         djnz $-7 
0dda			 
0dda			; https://plutiedev.com/z80-add-8bit-to-16bit 
0dda			 
0dda			addatohl: 
0dda 85			    add   a, l    ; A = A+L 
0ddb 6f			    ld    l, a    ; L = A+L 
0ddc 8c			    adc   a, h    ; A = A+L+H+carry 
0ddd 95			    sub   l       ; A = H+carry 
0dde 67			    ld    h, a    ; H = H+carry 
0ddf c9			ret 
0de0			 
0de0			addatode: 
0de0 83			    add   a, e    ; A = A+L 
0de1 5f			    ld    e, a    ; L = A+L 
0de2 8a			    adc   a, d    ; A = A+L+H+carry 
0de3 93			    sub   e       ; A = H+carry 
0de4 57			    ld    d, a    ; H = H+carry 
0de5 c9			ret 
0de6			 
0de6			 
0de6			addatobc: 
0de6 81			    add   a, c    ; A = A+L 
0de7 4f			    ld    c, a    ; L = A+L 
0de8 88			    adc   a, b    ; A = A+L+H+carry 
0de9 91			    sub   c       ; A = H+carry 
0dea 47			    ld    b, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			subafromhl: 
0dec			   ; If A=0 do nothing 
0dec			    ; Otherwise flip A's sign. Since 
0dec			    ; the upper byte becomes -1, also 
0dec			    ; substract 1 from H. 
0dec ed 44		    neg 
0dee ca f7 0d		    jp    z, Skip 
0df1 25			    dec   h 
0df2			     
0df2			    ; Now add the low byte as usual 
0df2			    ; Two's complement takes care of 
0df2			    ; ensuring the result is correct 
0df2 85			    add   a, l 
0df3 6f			    ld    l, a 
0df4 8c			    adc   a, h 
0df5 95			    sub   l 
0df6 67			    ld    h, a 
0df7			Skip: 
0df7 c9				ret 
0df8			 
0df8			 
0df8			; compare hl and de 
0df8			; returns:  
0df8			; if hl = de, z=1, s=0, c0=0 
0df8			; if hl > de, z=0, s=0, c=0 
0df8			; if hl < de, z=0, s=1, c=1 
0df8			cmp16:	 
0df8 b7				or a 
0df9 ed 52			sbc hl,de 
0dfb e0				ret po 
0dfc 7c				ld a,h 
0dfd 1f				rra 
0dfe ee 40			xor 01000000B 
0e00 37				scf 
0e01 8f				adc a,a 
0e02 c9				ret 
0e03			 
0e03			 
0e03			; test if hl contains zero   - A is destroyed 
0e03			 
0e03			ishlzero:    
0e03 b7				or a     ; reset flags 
0e04 7c				ld a, h 
0e05 b5				or l        	 
0e06			 
0e06 c9				ret 
0e07			 
0e07			 
0e07			 
0e07			 
0e07			if FORTH_ENABLE_FLOATMATH 
0e07			;include "float/bbcmath.z80" 
0e07			include "float/lpfpcalc.asm" 
0e07			endif 
0e07			 
0e07			 
0e07			; eof 
0e07			 
# End of file firmware_maths.asm
0e07			include "firmware_strings.asm"   ; string handling  
0e07			 
0e07			 
0e07			; TODO string len 
0e07			; input text string, end on cr with zero term 
0e07			; a offset into frame buffer to start prompt 
0e07			; d is max length 
0e07			; e is display size TODO 
0e07			; c is current cursor position 
0e07			; hl is ptr to where string will be stored 
0e07			 
0e07			 
0e07			; TODO check limit of buffer for new inserts 
0e07			; TODO check insert does not push beyond buffer 
0e07			; TODO scroll in a limited display area 
0e07			; TODO scroll whole screen on page wrap 
0e07			 
0e07			 
0e07			; TODO handle KEY_PREVWORD 
0e07			; TODO handle KEY_NEXTWORD 
0e07			; TODO handle KEY_HOME 
0e07			; TODO handle KEY_END 
0e07			; TODO use LCD cursor? 
0e07			 
0e07 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e0a 81					add c 
0e0b 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0e0e 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0e11 79					ld a, c 
0e12 cd da 0d				call addatohl 
0e15 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e18 7a					ld a,d 
0e19 32 af fe			        ld (input_size), a       ; save length of input area 
0e1c 79					ld a, c 
0e1d 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0e20 7b					ld a,e 
0e21 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e24					 
0e24					 
0e24			 
0e24			;		ld a,(input_ptr) 
0e24			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e24			 
0e24			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e24					; init cursor shape if not set by the cin routines 
0e24 21 4d fd				ld hl, cursor_shape 
0e27 3e ff				ld a, 255 
0e29 77					ld (hl), a 
0e2a 23					inc hl 
0e2b 3e 00				ld a, 0 
0e2d 77					ld (hl), a 
0e2e			 
0e2e 3e 0f				ld a, CUR_BLINK_RATE 
0e30 32 a9 fe				ld (input_cur_flash), a 
0e33 3e 01				ld a, 1 
0e35 32 a8 fe				ld (input_cur_onoff),a 
0e38			 
0e38			;	if DEBUG_INPUT 
0e38			;		push af 
0e38			;		ld a, 'I' 
0e38			;		ld (debug_mark),a 
0e38			;		pop af 
0e38			;		CALLMONITOR 
0e38			;	endif 
0e38			.is1:		; main entry loop 
0e38			 
0e38			 
0e38			 
0e38					; pause 1ms 
0e38			 
0e38 3e 01				ld a, 1 
0e3a cd 08 0b				call aDelayInMS 
0e3d			 
0e3d					; dec flash counter 
0e3d 3a a9 fe				ld a, (input_cur_flash) 
0e40 3d					dec a 
0e41 32 a9 fe				ld (input_cur_flash), a 
0e44 fe 00				cp 0 
0e46 20 0d				jr nz, .nochgstate 
0e48			 
0e48			 
0e48					; change state 
0e48 3a a8 fe				ld a,(input_cur_onoff) 
0e4b ed 44				neg 
0e4d 32 a8 fe				ld (input_cur_onoff),a 
0e50			 
0e50			 
0e50					; reset on change of state 
0e50 3e 0f				ld a, CUR_BLINK_RATE 
0e52 32 a9 fe				ld (input_cur_flash), a 
0e55			 
0e55			.nochgstate: 
0e55					 
0e55					 
0e55			 
0e55					; display cursor  
0e55			 
0e55			;		ld hl, (input_start) 
0e55			;		ld a, (input_cursor) 
0e55			;		call addatohl 
0e55			 
0e55					; get char under cursor and replace with cursor 
0e55 2a b2 fe		ld hl, (input_ptr) 
0e58			;		ld a, (hl) 
0e58			;		ld (input_under_cursor),a 
0e58			;		ld a, '_' 
0e58			;		ld (hl), a 
0e58			 
0e58					; display string 
0e58			 
0e58 ed 5b b0 fe			ld de, (input_start) 
0e5c 3a ad fe				ld a, (input_at_pos) 
0e5f cd b9 0b				call str_at_display 
0e62			;	        call update_display 
0e62			 
0e62					; find place to put the cursor 
0e62			;		add h 
0e62			;		ld l, display_row_1 
0e62			;		sub l 
0e62			; (input_at_pos) 
0e62					;ld c, a 
0e62			;		ld a, (input_cursor) 
0e62			;		ld l, (input_at_pos) 
0e62			;		;ld b, h 
0e62			;		add l 
0e62			;		ld (input_at_cursor),a 
0e62					;ld l,h 
0e62			 
0e62			;		ld h, 0 
0e62			;		ld l,(input_at_pos) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e62			;		call subafromhl 
0e62			;		ld a,l 
0e62			;		ld (input_at_cursor), a 
0e62			 
0e62				if DEBUG_INPUT 
0e62					ld a, (hardware_diag) 
0e62					cp 0 
0e62					jr z, .skip_input_diag 
0e62			 
0e62					ld a,(input_at_pos) 
0e62					ld hl, LFSRSeed 
0e62					call hexout 
0e62					ld a, (input_cursor) 
0e62					ld hl, LFSRSeed+2 
0e62					call hexout 
0e62					ld a,(input_at_cursor) 
0e62					ld hl, LFSRSeed+4 
0e62					call hexout 
0e62			 
0e62					ld a,(input_cur_onoff) 
0e62					ld hl, LFSRSeed+6 
0e62					call hexout 
0e62			 
0e62					ld a,(input_cur_flash) 
0e62					ld hl, LFSRSeed+8 
0e62					call hexout 
0e62			 
0e62					ld a,(input_len) 
0e62					ld hl, LFSRSeed+10 
0e62					call hexout 
0e62					ld hl, LFSRSeed+12 
0e62					ld a, 0 
0e62					ld (hl),a 
0e62					ld a, display_row_4 
0e62					ld de, LFSRSeed 
0e62					call str_at_display 
0e62					.skip_input_diag: 
0e62				endif 
0e62			 
0e62					; decide on if we are showing the cursor this time round 
0e62			 
0e62 3a a8 fe				ld a, (input_cur_onoff) 
0e65 fe ff				cp 255 
0e67 28 13				jr z, .skipcur 
0e69			 
0e69			 
0e69 3a ab fe				ld a,(input_at_cursor) 
0e6c 11 4d fd				ld de, cursor_shape 
0e6f cd b9 0b				call str_at_display 
0e72			 
0e72					; save length of current input string 
0e72 2a b0 fe				ld hl, (input_start) 
0e75 cd 38 12				call strlenz 
0e78 7d					ld a,l 
0e79 32 a3 fe				ld (input_len),a 
0e7c			 
0e7c			.skipcur: 
0e7c			 
0e7c cd c9 0b			        call update_display 
0e7f					 
0e7f			 
0e7f			 
0e7f					; wait 
0e7f				 
0e7f					; TODO loop without wait to flash the cursor and char under cursor	 
0e7f cd 32 69				call cin    ; _wait 
0e82			 
0e82 fe 00				cp 0 
0e84 ca 38 0e				jp z, .is1 
0e87			 
0e87					; get ptr to char to input into 
0e87			 
0e87 4f					ld c,a 
0e88 2a b0 fe				ld hl, (input_start) 
0e8b 3a 9e fe				ld a, (input_cursor) 
0e8e cd da 0d				call addatohl 
0e91 22 b2 fe				ld (input_ptr), hl 
0e94 79					ld a,c 
0e95			 
0e95					; replace char under cursor 
0e95			 
0e95			;		ld hl, (input_ptr) 
0e95			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0e95			;		ld (hl), a 
0e95			 
0e95			;	if DEBUG_INPUT 
0e95			;		push af 
0e95			;		ld a, 'i' 
0e95			;		ld (debug_mark),a 
0e95			;		pop af 
0e95			;		CALLMONITOR 
0e95			;	endif 
0e95 fe 0e				cp KEY_HOME 
0e97 20 0e				jr nz, .iske 
0e99			 
0e99 3a ad fe				ld a, (input_at_pos) 
0e9c 32 ab fe				ld (input_at_cursor),a 
0e9f 3e 00				ld a, 0 
0ea1 32 9e fe				ld (input_cursor), a 
0ea4 c3 38 0e				jp .is1 
0ea7					 
0ea7 fe 0f		.iske:		cp KEY_END 
0ea9 20 03				jr nz, .isknw 
0eab c3 38 0e				jp .is1 
0eae			 
0eae fe 06		.isknw:		cp KEY_NEXTWORD 
0eb0 20 1b				jr nz, .iskpw 
0eb2			 
0eb2 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
0eb5 7e					ld a,(hl)	 
0eb6 fe 00				cp 0 
0eb8 ca 38 0e				jp z, .is1    ; end of string 
0ebb fe 20				cp ' ' 
0ebd ca 38 0e				jp z, .is1    ; end of word 
0ec0 23					inc hl 
0ec1 22 b2 fe				ld (input_ptr), hl 
0ec4 3a ab fe				ld a, (input_at_cursor) 
0ec7 3c					inc a 
0ec8 32 ab fe				ld (input_at_cursor), a 
0ecb 18 e5				jr .isknwm 
0ecd			 
0ecd fe 07		.iskpw:		cp KEY_PREVWORD 
0ecf 20 1b				jr nz, .iskl 
0ed1			.iskpwm:	 
0ed1 2a b2 fe				ld hl, (input_ptr) 
0ed4 7e					ld a,(hl)	 
0ed5 fe 00				cp 0  
0ed7 ca 38 0e				jp z, .is1    ; end of string 
0eda fe 20				cp ' ' 
0edc ca 38 0e				jp z, .is1    ; end of word 
0edf 2b					dec hl 
0ee0 22 b2 fe				ld (input_ptr), hl 
0ee3 3a ab fe				ld a, (input_at_cursor) 
0ee6 3d					dec a 
0ee7 32 ab fe				ld (input_at_cursor), a 
0eea 18 e5				jr .iskpwm 
0eec			 
0eec			 
0eec fe 0b		.iskl:		cp KEY_LEFT 
0eee 20 27				jr nz, .isk1 
0ef0			 
0ef0 3a 9e fe				ld a, (input_cursor) 
0ef3			 
0ef3 fe 00				cp 0 
0ef5 ca 38 0e				jp z, .is1 		; at start of line to ignore  
0ef8			 
0ef8 3d					dec  a 		; TODO check underflow 
0ef9 32 9e fe				ld (input_cursor), a 
0efc			 
0efc 2a b2 fe				ld hl, (input_ptr) 
0eff 2b					dec hl 
0f00 22 b2 fe				ld (input_ptr), hl 
0f03					 
0f03 3a ab fe				ld a, (input_at_cursor) 
0f06 3d					dec a 
0f07 32 ab fe				ld (input_at_cursor), a 
0f0a			 
0f0a 3e 01				ld a, 1		; show cursor moving 
0f0c 32 a8 fe				ld (input_cur_onoff),a 
0f0f 3e 0f				ld a, CUR_BLINK_RATE 
0f11 32 a9 fe				ld (input_cur_flash), a 
0f14			 
0f14 c3 38 0e				jp .is1 
0f17			 
0f17 fe 0c		.isk1:		cp KEY_RIGHT 
0f19 20 2a				jr nz, .isk2 
0f1b			 
0f1b 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f1e 5f					ld e,a 
0f1f 3a 9e fe				ld a, (input_cursor) 
0f22 bb					cp e 
0f23 ca 38 0e				jp z, .is1		; at the end of string so dont go right 
0f26			 
0f26 3c					inc  a 		; TODO check overflow 
0f27 32 9e fe				ld (input_cursor), a 
0f2a			 
0f2a 3a ab fe				ld a, (input_at_cursor) 
0f2d 3c					inc a 
0f2e 32 ab fe				ld (input_at_cursor), a 
0f31			 
0f31 2a b2 fe				ld hl, (input_ptr) 
0f34 23					inc hl 
0f35 22 b2 fe				ld (input_ptr), hl 
0f38			 
0f38 3e 01				ld a, 1		; show cursor moving 
0f3a 32 a8 fe				ld (input_cur_onoff),a 
0f3d 3e 0f				ld a, CUR_BLINK_RATE 
0f3f 32 a9 fe				ld (input_cur_flash), a 
0f42			 
0f42 c3 38 0e				jp .is1 
0f45			 
0f45 fe 05		.isk2:		cp KEY_UP 
0f47			 
0f47 20 26				jr nz, .isk3 
0f49			 
0f49					; swap last command with the current on 
0f49			 
0f49					; move cursor to start of string 
0f49 2a b0 fe				ld hl, (input_start) 
0f4c 22 b2 fe				ld (input_ptr), hl 
0f4f			 
0f4f 3a ad fe				ld a, (input_at_pos) 
0f52 32 ab fe				ld (input_at_cursor), a 
0f55			 
0f55 3e 00				ld a, 0 
0f57 32 9e fe				ld (input_cursor), a 
0f5a					 
0f5a					; swap input and last command buffers 
0f5a			 
0f5a 21 81 f7				ld hl, os_cli_cmd 
0f5d 11 80 f8				ld de, os_last_cmd 
0f60 06 ff				ld b, 255 
0f62 7e			.swap1:		ld a, (hl) 
0f63 4f					ld c,a 
0f64 1a					ld a, (de) 
0f65 77					ld (hl), a 
0f66 79					ld a,c 
0f67 12					ld (de),a 
0f68 23					inc hl 
0f69 13					inc de 
0f6a 10 f6				djnz .swap1 
0f6c			 
0f6c			 
0f6c			 
0f6c			 
0f6c			 
0f6c c3 38 0e				jp .is1 
0f6f			 
0f6f fe 08		.isk3:		cp KEY_BS 
0f71 20 3c				jr nz, .isk4 
0f73			 
0f73 3a 9e fe				ld a, (input_cursor) 
0f76			 
0f76 fe 00				cp 0 
0f78 ca 38 0e				jp z, .is1 		; at start of line to ignore  
0f7b			 
0f7b 3d					dec  a 		; TODO check underflow 
0f7c 32 9e fe				ld (input_cursor), a 
0f7f			 
0f7f					; hl is source 
0f7f					; de needs to be source - 1 
0f7f			 
0f7f			;		ld a, 0 
0f7f			;		dec hl 
0f7f			;		ld (hl), a 
0f7f			 
0f7f 2a b2 fe				ld hl, (input_ptr) 
0f82 2b					dec hl 
0f83 22 b2 fe				ld (input_ptr), hl 
0f86			 
0f86					; shift all data 
0f86			 
0f86 e5					push hl 
0f87 23					inc hl 
0f88 d1					pop de 
0f89 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f8c 4f					ld c,a 
0f8d 06 00				ld b,0 
0f8f ed b0				ldir  
0f91			 
0f91			 
0f91			 
0f91			 
0f91 3a ab fe				ld a, (input_at_cursor) 
0f94 3d					dec a 
0f95 32 ab fe				ld (input_at_cursor), a 
0f98			 
0f98			 
0f98 3e 01				ld a, 1		; show cursor moving 
0f9a 32 a8 fe				ld (input_cur_onoff),a 
0f9d 3e 0f				ld a, CUR_BLINK_RATE 
0f9f 32 a9 fe				ld (input_cur_flash), a 
0fa2			 
0fa2					; remove char 
0fa2 3a ab fe				ld a, (input_at_cursor) 
0fa5 3c					inc a 
0fa6 11 30 10				ld de,.iblank 
0fa9 cd b9 0b				call str_at_display 
0fac			 
0fac c3 38 0e				jp .is1 
0faf			 
0faf fe 0d		.isk4:		cp KEY_CR 
0fb1 28 6c				jr z, .endinput 
0fb3			 
0fb3					; else add the key press to the end 
0fb3			 
0fb3 4f					ld c, a			; save key pressed 
0fb4			 
0fb4 7e					ld a,(hl)		; get what is currently under char 
0fb5			 
0fb5 fe 00				cp 0			; we are at the end of the string 
0fb7 20 2f				jr nz, .onchar 
0fb9					 
0fb9					; add a char to the end of the string 
0fb9				 
0fb9 71					ld (hl),c 
0fba 23					inc hl 
0fbb			;		ld a,' ' 
0fbb			;		ld (hl),a 
0fbb			;		inc hl 
0fbb 3e 00				ld a,0 
0fbd 77					ld (hl),a 
0fbe 2b					dec hl 
0fbf			 
0fbf 3a 9e fe				ld a, (input_cursor) 
0fc2 3c					inc a				; TODO check max string length and scroll  
0fc3 32 9e fe				ld (input_cursor), a		; inc cursor pos 
0fc6							 
0fc6 3a ab fe				ld a, (input_at_cursor) 
0fc9 3c					inc a 
0fca 32 ab fe				ld (input_at_cursor), a 
0fcd			 
0fcd 2a b2 fe				ld hl, (input_ptr) 
0fd0 23					inc hl 
0fd1 22 b2 fe				ld (input_ptr), hl 
0fd4			 
0fd4 2a b2 fe				ld hl, (input_ptr) 
0fd7 23					inc hl 
0fd8 22 b2 fe				ld (input_ptr), hl 
0fdb			;	if DEBUG_INPUT 
0fdb			;		push af 
0fdb			;		ld a, '+' 
0fdb			;		ld (debug_mark),a 
0fdb			;		pop af 
0fdb			;		CALLMONITOR 
0fdb			;	endif 
0fdb 3e 01				ld a, 1		; show cursor moving 
0fdd 32 a8 fe				ld (input_cur_onoff),a 
0fe0 3e 0f				ld a, CUR_BLINK_RATE 
0fe2 32 a9 fe				ld (input_cur_flash), a 
0fe5 c3 38 0e				jp .is1 
0fe8					 
0fe8			 
0fe8			 
0fe8					; if on a char then insert 
0fe8			.onchar: 
0fe8			 
0fe8					; TODO over flow check: make sure insert does not blow out buffer 
0fe8			 
0fe8					; need to do some maths to use lddr 
0fe8			 
0fe8 e5					push hl   ; save char pos 
0fe9 c5					push bc 
0fea			 
0fea 2a b0 fe				ld hl, (input_start) 
0fed 3a a3 fe				ld a, (input_len) 
0ff0 cd da 0d				call addatohl  		; end of string 
0ff3 23					inc hl 
0ff4 23					inc hl		; past zero term 
0ff5 e5					push hl 
0ff6 23					inc hl 
0ff7 e5					push hl  
0ff8			 
0ff8								; start and end of lddr set, now how much to move? 
0ff8			 
0ff8							 
0ff8 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ffb 47					ld b,a 
0ffc 3a a3 fe				ld a,(input_len) 
0fff 5f					ld e,a 
1000 90					sub b 
1001 3c					inc a		;?? 
1002 3c					inc a		;?? 
1003 3c					inc a		;?? 
1004			 
1004 06 00				ld b,0 
1006 4f					ld c,a 
1007			 
1007				if DEBUG_INPUT 
1007					push af 
1007					ld a, 'i' 
1007					ld (debug_mark),a 
1007					pop af 
1007			;		CALLMONITOR 
1007				endif 
1007 d1					pop de 
1008 e1					pop hl 
1009				if DEBUG_INPUT 
1009					push af 
1009					ld a, 'I' 
1009					ld (debug_mark),a 
1009					pop af 
1009			;		CALLMONITOR 
1009				endif 
1009 ed b8				lddr 
100b				 
100b			 
100b			 
100b					; TODO have a key for insert/overwrite mode???? 
100b c1					pop bc 
100c e1					pop hl 
100d 71					ld (hl), c		; otherwise overwrite current char 
100e					 
100e			 
100e			 
100e			 
100e 3a 9e fe				ld a, (input_cursor) 
1011 3c					inc  a 		; TODO check overflow 
1012 32 9e fe				ld (input_cursor), a 
1015			 
1015 3a ab fe				ld a, (input_at_cursor) 
1018 3c					inc a 
1019 32 ab fe				ld (input_at_cursor), a 
101c			 
101c c3 38 0e				jp .is1 
101f			 
101f			.endinput:	; TODO look for end of string 
101f			 
101f					; add trailing space for end of token 
101f			 
101f 2a b0 fe				ld hl, (input_start) 
1022 3a a3 fe				ld a,(input_len) 
1025 cd da 0d				call addatohl 
1028 3e 20				ld a, ' ' 
102a 77					ld (hl),a 
102b					; TODO eof of parse marker 
102b			 
102b 23					inc hl 
102c 3e 00				ld a, 0 
102e 77					ld (hl),a 
102f			 
102f			 
102f c9					ret 
1030			 
1030 .. 00		.iblank: db " ",0 
1032			 
1032			 
1032 32 ad fe		input_str_prev:	ld (input_at_pos), a 
1035 22 b0 fe				ld (input_start), hl 
1038 3e 01				ld a,1			; add cursor 
103a 77					ld (hl),a 
103b 23					inc hl 
103c 3e 00				ld a,0 
103e 77					ld (hl),a 
103f 22 b2 fe				ld (input_ptr), hl 
1042 7a					ld a,d 
1043 32 af fe				ld (input_size), a 
1046 3e 00				ld a,0 
1048 32 9e fe				ld (input_cursor),a 
104b			.instr1:	 
104b			 
104b					; TODO do block cursor 
104b					; TODO switch cursor depending on the modifer key 
104b			 
104b					; update cursor shape change on key hold 
104b			 
104b 2a b2 fe				ld hl, (input_ptr) 
104e 2b					dec hl 
104f 3a 4d fd				ld a,(cursor_shape) 
1052 77					ld (hl), a 
1053			 
1053					; display entered text 
1053 3a ad fe				ld a,(input_at_pos) 
1056 cd 50 68		            	CALL fLCD_Pos       ;Position cursor to location in A 
1059 ed 5b b0 fe	            	LD   de, (input_start) 
105d cd 58 68		            	CALL fLCD_Str       ;Display string pointed to by DE 
1060			 
1060 cd 32 69				call cin 
1063 fe 00				cp 0 
1065 28 e4				jr z, .instr1 
1067			 
1067					; proecess keyboard controls first 
1067			 
1067 2a b2 fe				ld hl,(input_ptr) 
106a			 
106a fe 0d				cp KEY_CR	 ; pressing enter ends input 
106c 28 5a				jr z, .instrcr 
106e			 
106e fe 08				cp KEY_BS 	; back space 
1070 20 0f				jr nz, .instr2 
1072					; process back space 
1072			 
1072					; TODO stop back space if at start of string 
1072 2b					dec hl 
1073 2b					dec hl ; to over write cursor 
1074 3a 4d fd				ld a,(cursor_shape) 
1077					;ld a,0 
1077 77					ld (hl),a 
1078 23					inc hl 
1079 3e 20				ld a," " 
107b 77					ld (hl),a 
107c 22 b2 fe				ld (input_ptr),hl 
107f					 
107f			 
107f 18 ca				jr .instr1 
1081			 
1081 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1083 20 06				jr nz, .instr3 
1085 2b					dec hl 
1086 22 b2 fe				ld (input_ptr),hl 
1089 18 c0				jr .instr1 
108b				 
108b fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
108d 20 06				jr nz, .instr4 
108f 23					inc hl 
1090 22 b2 fe				ld (input_ptr),hl 
1093 18 b6				jr .instr1 
1095			 
1095 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1097 20 06				jr nz, .instr5 
1099 2b					dec hl 
109a 22 b2 fe				ld (input_ptr),hl 
109d 18 ac				jr .instr1 
109f			 
109f fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10a1 20 06				jr nz, .instr6 
10a3 2b					dec hl 
10a4 22 b2 fe				ld (input_ptr),hl 
10a7 18 a2				jr .instr1 
10a9 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10ab 20 0b				jr nz, .instrnew 
10ad			 
10ad 21 5a f4			ld hl, scratch 
10b0 11 80 f8			ld de, os_last_cmd 
10b3 cd d1 10			call strcpy 
10b6 18 93				jr .instr1 
10b8			 
10b8			 
10b8			.instrnew:	; no special key pressed to see if we have room to store it 
10b8			 
10b8					; TODO do string size test 
10b8			 
10b8 2b					dec hl ; to over write cursor 
10b9 77					ld (hl),a 
10ba 23					inc hl 
10bb 3a 4d fd				ld a,(cursor_shape) 
10be 77					ld (hl),a 
10bf 23					inc hl 
10c0 3e 00				ld a,0 
10c2 77					ld (hl),a 
10c3			 
10c3 22 b2 fe				ld (input_ptr),hl 
10c6					 
10c6 18 83				jr .instr1 
10c8 2b			.instrcr:	dec hl		; remove cursor 
10c9 3e 20				ld a,' '	; TODO add a trailing space for safety 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0			 
10d0					; if at end of line scroll up    
10d0					; TODO detecting only end of line 4 for scroll up  
10d0			 
10d0					;ld   
10d0			 
10d0 c9					ret 
10d1			 
10d1			 
10d1			; strcpy hl = dest, de source 
10d1			 
10d1 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10d2 b7			            OR   A              ;Null terminator? 
10d3 c8			            RET  Z              ;Yes, so finished 
10d4 1a					ld a,(de) 
10d5 77					ld (hl),a 
10d6 13			            INC  DE             ;Point to next character 
10d7 23					inc hl 
10d8 18 f7		            JR   strcpy       ;Repeat 
10da c9					ret 
10db			 
10db			 
10db			; TODO string_at  
10db			; pass string which starts with lcd offset address and then null term string 
10db			 
10db			; TODO string to dec 
10db			; TODO string to hex 
10db			; TODO byte to string hex 
10db			; TODO byte to string dec 
10db			 
10db			 
10db			 
10db			; from z80uartmonitor 
10db			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10db			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10db			; pass hl for where to put the text 
10db			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10db c5			hexout:	PUSH BC 
10dc f5					PUSH AF 
10dd 47					LD B, A 
10de					; Upper nybble 
10de cb 3f				SRL A 
10e0 cb 3f				SRL A 
10e2 cb 3f				SRL A 
10e4 cb 3f				SRL A 
10e6 cd f6 10				CALL tohex 
10e9 77					ld (hl),a 
10ea 23					inc hl	 
10eb					 
10eb					; Lower nybble 
10eb 78					LD A, B 
10ec e6 0f				AND 0FH 
10ee cd f6 10				CALL tohex 
10f1 77					ld (hl),a 
10f2 23					inc hl	 
10f3					 
10f3 f1					POP AF 
10f4 c1					POP BC 
10f5 c9					RET 
10f6					 
10f6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f6			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
10f6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f6			tohex: 
10f6 e5					PUSH HL 
10f7 d5					PUSH DE 
10f8 16 00				LD D, 0 
10fa 5f					LD E, A 
10fb 21 03 11				LD HL, .DATA 
10fe 19					ADD HL, DE 
10ff 7e					LD A, (HL) 
1100 d1					POP DE 
1101 e1					POP HL 
1102 c9					RET 
1103			 
1103			.DATA: 
1103 30					DEFB	30h	; 0 
1104 31					DEFB	31h	; 1 
1105 32					DEFB	32h	; 2 
1106 33					DEFB	33h	; 3 
1107 34					DEFB	34h	; 4 
1108 35					DEFB	35h	; 5 
1109 36					DEFB	36h	; 6 
110a 37					DEFB	37h	; 7 
110b 38					DEFB	38h	; 8 
110c 39					DEFB	39h	; 9 
110d 41					DEFB	41h	; A 
110e 42					DEFB	42h	; B 
110f 43					DEFB	43h	; C 
1110 44					DEFB	44h	; D 
1111 45					DEFB	45h	; E 
1112 46					DEFB	46h	; F 
1113			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1113			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1113			;;    subtract $30, if result > 9 then subtract $7 more 
1113			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1113			atohex: 
1113 d6 30				SUB $30 
1115 fe 0a				CP 10 
1117 f8					RET M		; If result negative it was 0-9 so we're done 
1118 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
111a c9					RET		 
111b			 
111b			 
111b			 
111b			 
111b			; Get 2 ASCII characters as hex byte from pointer in hl 
111b			 
111b			BYTERD: 
111b 16 00			LD	D,00h		;Set up 
111d cd 25 11			CALL	HEXCON		;Get byte and convert to hex 
1120 87				ADD	A,A		;First nibble so 
1121 87				ADD	A,A		;multiply by 16 
1122 87				ADD	A,A		; 
1123 87				ADD	A,A		; 
1124 57				LD	D,A		;Save hi nibble in D 
1125			HEXCON: 
1125 7e				ld a, (hl)		;Get next chr 
1126 23				inc hl 
1127 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1129 fe 0a			CP	00Ah		;Is it 0-9 ? 
112b 38 02			JR	C,NALPHA	;If so miss next bit 
112d d6 07			SUB	007h		;Else convert alpha 
112f			NALPHA: 
112f b2				OR	D		;Add hi nibble back 
1130 c9				RET			; 
1131			 
1131			 
1131			; 
1131			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1131			; Since the routines get_byte and therefore get_nibble are called, only valid 
1131			; characters (0-9a-f) are accepted. 
1131			; 
1131			;get_word        push    af 
1131			;                call    get_byte        ; Get the upper byte 
1131			;                ld      h, a 
1131			;                call    get_byte        ; Get the lower byte 
1131			;                ld      l, a 
1131			;                pop     af 
1131			;                ret 
1131			; 
1131			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1131			; the routine get_nibble is used only valid characters are accepted - the  
1131			; input routine only accepts characters 0-9a-f. 
1131			; 
1131 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1132 7e					ld a,(hl) 
1133 23					inc hl 
1134 cd 59 11		                call    nibble2val      ; Get upper nibble 
1137 cb 07		                rlc     a 
1139 cb 07		                rlc     a 
113b cb 07		                rlc     a 
113d cb 07		                rlc     a 
113f 47			                ld      b, a            ; Save upper four bits 
1140 7e					ld a,(hl) 
1141 cd 59 11		                call    nibble2val      ; Get lower nibble 
1144 b0			                or      b               ; Combine both nibbles 
1145 c1			                pop     bc              ; Restore B (and C) 
1146 c9			                ret 
1147			; 
1147			; Get a hexadecimal digit from the serial line. This routine blocks until 
1147			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1147			; to the serial line interface. The lower 4 bits of A contain the value of  
1147			; that particular digit. 
1147			; 
1147			;get_nibble      ld a,(hl)           ; Read a character 
1147			;                call    to_upper        ; Convert to upper case 
1147			;                call    is_hex          ; Was it a hex digit? 
1147			;                jr      nc, get_nibble  ; No, get another character 
1147			 ;               call    nibble2val      ; Convert nibble to value 
1147			 ;               call    print_nibble 
1147			 ;               ret 
1147			; 
1147			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1147			; A valid hexadecimal digit is denoted by a set C flag. 
1147			; 
1147			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1147			;                ret     nc              ; Yes 
1147			;                cp      '0'             ; Less than '0'? 
1147			;                jr      nc, is_hex_1    ; No, continue 
1147			;                ccf                     ; Complement carry (i.e. clear it) 
1147			;                ret 
1147			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1147			;                ret     c               ; Yes 
1147			;                cp      'A'             ; Less than 'A'? 
1147			;                jr      nc, is_hex_2    ; No, continue 
1147			;                ccf                     ; Yes - clear carry and return 
1147			;                ret 
1147			;is_hex_2        scf                     ; Set carry 
1147			;                ret 
1147			; 
1147			; Convert a single character contained in A to upper case: 
1147			; 
1147 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1149 d8			                ret     c 
114a fe 7b		                cp      'z' + 1         ; > 'z'? 
114c d0			                ret     nc              ; Nothing to do, either 
114d e6 5f		                and     $5f             ; Convert to upper case 
114f c9			                ret 
1150			 
1150			 
1150			to_lower: 
1150			 
1150			   ; if char is in [A-Z] make it lower case 
1150			 
1150			   ; enter : a = char 
1150			   ; exit  : a = lower case char 
1150			   ; uses  : af 
1150			 
1150 fe 41		   cp 'A' 
1152 d8			   ret c 
1153			    
1153 fe 5b		   cp 'Z'+1 
1155 d0			   ret nc 
1156			    
1156 f6 20		   or $20 
1158 c9			   ret 
1159			 
1159			; 
1159			; Expects a hexadecimal digit (upper case!) in A and returns the 
1159			; corresponding value in A. 
1159			; 
1159 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
115b 38 02		                jr      c, nibble2val_1 ; Yes 
115d d6 07		                sub     7               ; Adjust for A-F 
115f d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1161 e6 0f		                and     $f              ; Only return lower 4 bits 
1163 c9			                ret 
1164			; 
1164			; Print_nibble prints a single hex nibble which is contained in the lower  
1164			; four bits of A: 
1164			; 
1164			;print_nibble    push    af              ; We won't destroy the contents of A 
1164			;                and     $f              ; Just in case... 
1164			;                add     a, '0'             ; If we have a digit we are done here. 
1164			;                cp      '9' + 1         ; Is the result > 9? 
1164			;                jr      c, print_nibble_1 
1164			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1164			;print_nibble_1  call    putc            ; Print the nibble and 
1164			;                pop     af              ; restore the original value of A 
1164			;                ret 
1164			;; 
1164			;; Send a CR/LF pair: 
1164			; 
1164			;crlf            push    af 
1164			;                ld      a, cr 
1164			;                call    putc 
1164			;                ld      a, lf 
1164			;                call    putc 
1164			;                pop     af 
1164			;                ret 
1164			; 
1164			; Print_word prints the four hex digits of a word to the serial line. The  
1164			; word is expected to be in HL. 
1164			; 
1164			;print_word      push    hl 
1164			;                push    af 
1164			;                ld      a, h 
1164			;                call    print_byte 
1164			;                ld      a, l 
1164			;                call    print_byte 
1164			;                pop     af 
1164			;                pop     hl 
1164			;                ret 
1164			; 
1164			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1164			; The byte to be printed is expected to be in A. 
1164			; 
1164			;print_byte      push    af              ; Save the contents of the registers 
1164			;                push    bc 
1164			;                ld      b, a 
1164			;                rrca 
1164			;                rrca 
1164			;                rrca 
1164			;                rrca 
1164			;                call    print_nibble    ; Print high nibble 
1164			;                ld      a, b 
1164			;                call    print_nibble    ; Print low nibble 
1164			;                pop     bc              ; Restore original register contents 
1164			;                pop     af 
1164			;                ret 
1164			 
1164			 
1164			 
1164			 
1164			 
1164			fourehexhl:  
1164 7e				ld a,(hl) 
1165 cd 13 11			call atohex 
1168 cb 3f				SRL A 
116a cb 3f				SRL A 
116c cb 3f				SRL A 
116e cb 3f				SRL A 
1170 47				ld b, a 
1171 23				inc hl 
1172 7e				ld a,(hl) 
1173 23				inc hl 
1174 cd 13 11			call atohex 
1177 80				add b 
1178 57				ld d,a 
1179 7e				ld a,(hl) 
117a cd 13 11			call atohex 
117d cb 3f				SRL A 
117f cb 3f				SRL A 
1181 cb 3f				SRL A 
1183 cb 3f				SRL A 
1185 47				ld b, a 
1186 23				inc hl 
1187 7e				ld a,(hl) 
1188 23				inc hl 
1189 cd 13 11			call atohex 
118c 80				add b 
118d 5f				ld e, a 
118e d5				push de 
118f e1				pop hl 
1190 c9				ret 
1191			 
1191			; pass hl. returns z set if the byte at hl is a digit 
1191			;isdigithl:  
1191			;	push bc 
1191			;	ld a,(hl) 
1191			;	cp ':' 
1191			;	jr nc, .isdf 		; > 
1191			;	cp '0' 
1191			;	jr c, .isdf		; < 
1191			; 
1191			;	; TODO find a better way to set z 
1191			; 
1191			;	ld b,a 
1191			;	cp b 
1191			;	pop bc 
1191			;	ret 
1191			; 
1191			;.isdf:	; not digit so clear z 
1191			; 
1191			;	; TODO find a better way to unset z 
1191			; 
1191			;	ld b,a 
1191			;	inc b 
1191			;	cp b 
1191			; 
1191			;	pop bc 
1191			;	ret 
1191				 
1191				 
1191			 
1191			 
1191			; pass hl as the four byte address to load 
1191			 
1191			get_word_hl:  
1191 e5				push hl 
1192 cd 31 11			call get_byte 
1195				 
1195 47				ld b, a 
1196			 
1196 e1				pop hl 
1197 23				inc hl 
1198 23				inc hl 
1199			 
1199			; TODO not able to handle a-f  
1199 7e				ld a,(hl) 
119a			;	;cp ':' 
119a			;	cp 'g' 
119a			;	jr nc, .single_byte_hl 		; > 
119a			;	cp 'G' 
119a			;	jr nc, .single_byte_hl 		; > 
119a			;	cp '0' 
119a			;	jr c, .single_byte_hl		; < 
119a			 
119a				;call isdigithl 
119a fe 00			cp 0 
119c 28 06			jr z, .single_byte_hl 
119e			 
119e			.getwhln:   ; hex word so get next byte 
119e			 
119e cd 31 11			call get_byte 
11a1 6f				ld l, a 
11a2 60				ld h,b 
11a3 c9				ret 
11a4 68			.single_byte_hl:   ld l,b 
11a5 26 00				ld h,0 
11a7 c9					ret 
11a8			 
11a8			 
11a8			 
11a8			 
11a8 21 cb 1a			ld hl,asc+1 
11ab			;	ld a, (hl) 
11ab			;	call nibble2val 
11ab cd 31 11			call get_byte 
11ae			 
11ae			;	call fourehexhl 
11ae 32 8e f4			ld (scratch+52),a 
11b1				 
11b1 21 8c f4			ld hl,scratch+50 
11b4 22 7d f7			ld (os_cur_ptr),hl 
11b7			 
11b7 c9				ret 
11b8			 
11b8			 
11b8			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11b8			 
11b8			; Decimal Unsigned Version 
11b8			 
11b8			;Number in a to decimal ASCII 
11b8			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11b8			;Example: display a=56 as "056" 
11b8			;input: a = number 
11b8			;Output: a=0,value of a in the screen 
11b8			;destroys af,bc (don't know about hl and de) 
11b8			DispAToASCII: 
11b8 0e 9c			ld	c,-100 
11ba cd c4 11			call	.Na1 
11bd 0e f6			ld	c,-10 
11bf cd c4 11			call	.Na1 
11c2 0e ff			ld	c,-1 
11c4 06 2f		.Na1:	ld	b,'0'-1 
11c6 04			.Na2:	inc	b 
11c7 81				add	a,c 
11c8 38 fc			jr	c,.Na2 
11ca 91				sub	c		;works as add 100/10/1 
11cb f5				push af		;safer than ld c,a 
11cc 78				ld	a,b		;char is in b 
11cd			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11cd f1				pop af		;safer than ld a,c 
11ce c9				ret 
11cf			 
11cf			; Decimal Signed Version 
11cf			 
11cf			; DispA 
11cf			; -------------------------------------------------------------- 
11cf			; Converts a signed integer value to a zero-terminated ASCII 
11cf			; string representative of that value (using radix 10). 
11cf			; -------------------------------------------------------------- 
11cf			; INPUTS: 
11cf			;     HL     Value to convert (two's complement integer). 
11cf			;     DE     Base address of string destination. (pointer). 
11cf			; -------------------------------------------------------------- 
11cf			; OUTPUTS: 
11cf			;     None 
11cf			; -------------------------------------------------------------- 
11cf			; REGISTERS/MEMORY DESTROYED 
11cf			; AF HL 
11cf			; -------------------------------------------------------------- 
11cf			 
11cf			;DispHLToASCII: 
11cf			;   push    de 
11cf			;   push    bc 
11cf			; 
11cf			;; Detect sign of HL. 
11cf			;    bit    7, h 
11cf			;    jr     z, ._DoConvert 
11cf			; 
11cf			;; HL is negative. Output '-' to string and negate HL. 
11cf			;    ld     a, '-' 
11cf			;    ld     (de), a 
11cf			;    inc    de 
11cf			; 
11cf			;; Negate HL (using two's complement) 
11cf			;    xor    a 
11cf			;    sub    l 
11cf			;    ld     l, a 
11cf			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11cf			;    sbc    a, h 
11cf			;    ld     h, a 
11cf			; 
11cf			;; Convert HL to digit characters 
11cf			;._DoConvert: 
11cf			;    ld     b, 0     ; B will count character length of number 
11cf			;-   ld     a, 10 
11cf			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11cf			;    push   af 
11cf			;    inc    b 
11cf			;    ld     a, h 
11cf			;    or     l 
11cf			;    jr     nz, - 
11cf			; 
11cf			;; Retrieve digits from stack 
11cf			;-   pop    af 
11cf			;    or     $30 
11cf			;    ld     (de), a 
11cf			;    inc    de 
11cf			;    djnz   - 
11cf			; 
11cf			;; Terminate string with NULL 
11cf			;    xor    a 
11cf			;    ld     (de), a 
11cf			; 
11cf			;    pop    bc 
11cf			;    pop    de 
11cf			;    ret 
11cf			 
11cf			;Comments 
11cf			; 
11cf			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11cf			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11cf			;    Note that the output string will not be fixed-width. 
11cf			; 
11cf			;Example Usage 
11cf			; 
11cf			;    ld    hl, -1004 
11cf			;    ld    de, OP1 
11cf			;    call  DispA 
11cf			;    ld    hl, OP1 
11cf			;    syscall  PutS 
11cf			 
11cf			 
11cf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11cf			 
11cf			 
11cf			;Converts an ASCII string to an unsigned 16-bit integer 
11cf			;Quits when it reaches a non-decimal digit 
11cf			 
11cf			string_to_uint16: 
11cf			atoui_16: 
11cf			;Input: 
11cf			;     DE points to the string 
11cf			;Outputs: 
11cf			;     HL is the result 
11cf			;     A is the 8-bit value of the number 
11cf			;     DE points to the byte after the number 
11cf			;Destroys: 
11cf			;     BC 
11cf			;       if the string is non-empty, BC is HL/10 
11cf			;Size:  24 bytes 
11cf			;Speed: 42+d(104+{0,9}) 
11cf			;       d is the number of digits in the number 
11cf			;       max is 640 cycles for a 5 digit number 
11cf			;Assuming no leading zeros: 
11cf			;1 digit:  146cc 
11cf			;2 digit:  250cc 
11cf			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11cf			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11cf			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11cf			;avg: 544.81158447265625cc (544+13297/16384) 
11cf			;=============================================================== 
11cf 21 00 00		  ld hl,0 
11d2			.u16a: 
11d2 1a			  ld a,(de) 
11d3 d6 30		  sub 30h 
11d5 fe 0a		  cp 10 
11d7 d0			  ret nc 
11d8 13			  inc de 
11d9 44			  ld b,h 
11da 4d			  ld c,l 
11db 29			  add hl,hl 
11dc 29			  add hl,hl 
11dd 09			  add hl,bc 
11de 29			  add hl,hl 
11df 85			  add a,l 
11e0 6f			  ld l,a 
11e1 30 ef		  jr nc,.u16a 
11e3 24			  inc h 
11e4 c3 d2 11		  jp .u16a 
11e7			 
11e7			 
11e7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11e7			 
11e7			;written by Zeda 
11e7			;Converts a 16-bit unsigned integer to an ASCII string. 
11e7			 
11e7			uitoa_16: 
11e7			;Input: 
11e7			;   DE is the number to convert 
11e7			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11e7			;Output: 
11e7			;   HL points to the null-terminated ASCII string 
11e7			;      NOTE: This isn't necessarily the same as the input HL. 
11e7 d5			  push de 
11e8 c5			  push bc 
11e9 f5			  push af 
11ea eb			  ex de,hl 
11eb			 
11eb 01 f0 d8		  ld bc,-10000 
11ee 3e 2f		  ld a,'0'-1 
11f0 3c			  inc a 
11f1 09			  add hl,bc  
11f2 38 fc		   jr c,$-2 
11f4 12			  ld (de),a 
11f5 13			  inc de 
11f6			 
11f6 01 e8 03		  ld bc,1000 
11f9 3e 3a		  ld a,'9'+1 
11fb 3d			  dec a  
11fc 09			  add hl,bc  
11fd 30 fc		   jr nc,$-2 
11ff 12			  ld (de),a 
1200 13			  inc de 
1201			 
1201 01 9c ff		  ld bc,-100 
1204 3e 2f		  ld a,'0'-1 
1206 3c			  inc a  
1207 09			  add hl,bc  
1208 38 fc		   jr c,$-2 
120a 12			  ld (de),a 
120b 13			  inc de 
120c			 
120c 7d			  ld a,l 
120d 26 3a		  ld h,'9'+1 
120f 25			  dec h  
1210 c6 0a		  add a,10  
1212 30 fb		   jr nc,$-3 
1214 c6 30		  add a,'0' 
1216 eb			  ex de,hl 
1217 72			  ld (hl),d 
1218 23			  inc hl 
1219 77			  ld (hl),a 
121a 23			  inc hl 
121b 36 00		  ld (hl),0 
121d			 
121d			;Now strip the leading zeros 
121d 0e fa		  ld c,-6 
121f 09			  add hl,bc 
1220 3e 30		  ld a,'0' 
1222 23			  inc hl  
1223 be			  cp (hl)  
1224 28 fc		  jr z,$-2 
1226			 
1226			;Make sure that the string is non-empty! 
1226 7e			  ld a,(hl) 
1227 b7			  or a 
1228 20 01		  jr nz,.atoub 
122a 2b			  dec hl 
122b			.atoub: 
122b			 
122b f1			  pop af 
122c c1			  pop bc 
122d d1			  pop de 
122e c9			  ret 
122f			 
122f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
122f			 
122f			toUpper: 
122f			;A is the char. 
122f			;If A is a lowercase letter, this sets it to the matching uppercase 
122f			;18cc or 30cc or 41cc 
122f			;avg: 26.75cc 
122f fe 61		  cp 'a' 
1231 d8			  ret c 
1232 fe 7b		  cp 'z'+1 
1234 d0			  ret nc 
1235 d6 20		  sub 'a'-'A' 
1237 c9			  ret 
1238			 
1238			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1238			 
1238			; String Length 
1238			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1238			 
1238			; Get the length of the null-terminated string starting at $8000 hl 
1238			;    LD     HL, $8000 
1238			 
1238			strlenz: 
1238			 
1238 af			    XOR    A               ; Zero is the value we are looking for. 
1239 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
123a 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
123b			                           ; 65, 536 bytes (the entire addressable memory space). 
123b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
123d			 
123d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
123d 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
123e 6f			    LD     L, A             ; number of bytes 
123f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1241 2b			    DEC    HL              ; Compensate for null. 
1242 c9				ret 
1243			 
1243			; Get the length of the A terminated string starting at $8000 hl 
1243			;    LD     HL, $8000 
1243			 
1243			strlent: 
1243			 
1243			                  ; A is the value we are looking for. 
1243 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1245 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1247			                           ; 65, 536 bytes (the entire addressable memory space). 
1247 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1249			 
1249			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1249 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
124b 2e 00		    LD     L, 0             ; number of bytes 
124d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124f 2b			    DEC    HL              ; Compensate for null. 
1250 c9				ret 
1251			 
1251			 
1251			;Comparing Strings 
1251			 
1251			;IN    HL     Address of string1. 
1251			;      DE     Address of string2. 
1251			 
1251			; doc given but wrong??? 
1251			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1251			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1251			; tested 
1251			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1251			 
1251			strcmp_old: 
1251 e5			    PUSH   HL 
1252 d5			    PUSH   DE 
1253			 
1253 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1254 be			    CP     (HL)            ; (want to minimize work). 
1255 38 01		    JR     C, Str1IsBigger 
1257 7e			    LD     A, (HL) 
1258			 
1258			Str1IsBigger: 
1258 4f			    LD     C, A             ; Put length in BC 
1259 06 00		    LD     B, 0 
125b 13			    INC    DE              ; Increment pointers to meat of string. 
125c 23			    INC    HL 
125d			 
125d			CmpLoop: 
125d 1a			    LD     A, (DE)          ; Compare bytes. 
125e ed a1		    CPI 
1260 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1262 13			    INC    DE              ; Update pointer. 
1263 ea 5d 12		    JP     PE, CmpLoop 
1266			 
1266 d1			    POP    DE 
1267 e1			    POP    HL 
1268 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1269 be			    CP     (HL) 
126a c9			    RET 
126b			 
126b			NoMatch: 
126b 2b			    DEC    HL 
126c be			    CP     (HL)            ; Compare again to affect carry. 
126d d1			    POP    DE 
126e e1			    POP    HL 
126f c9			    RET 
1270			 
1270			;; test strmp 
1270			; 
1270			;ld de, .str1 
1270			;ld hl, .str2 
1270			;call strcmp 
1270			;jr z, .z1 
1270			;;this 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "NZ1" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			;.z1: 
1270			; 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "ZZ1" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			; 
1270			;ld de, .str1 
1270			;ld hl, .str1 
1270			;call strcmp 
1270			;jr z, .z2 
1270			;;this 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "NZ2" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			;.z2: 
1270			; 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "ZZ2" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			; 
1270			;ld de, .str1 
1270			;ld hl, .str2 
1270			;call strcmp 
1270			;jr c, .c1 
1270			; 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "Nc1" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			;.c1: 
1270			;;this 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "cc1" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			; 
1270			;ld de, .str1 
1270			;ld hl, .str1 
1270			;call strcmp 
1270			;jr c, .c2 
1270			;;this 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "Nc2" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			;.c2: 
1270			; 
1270			;	if DEBUG_FORTH_WORDS 
1270			;		DMARK "cc2" 
1270			;		CALLMONITOR 
1270			;	endif 
1270			;	NEXTW 
1270			;.str1:   db "string1",0 
1270			;.str2:   db "string2",0 
1270			 
1270			; only care about direct match or not 
1270			; hl and de strings 
1270			; zero set if the same 
1270			 
1270			strcmp: 
1270 1a				ld a, (de) 
1271 be				cp (hl) 
1272 28 02			jr z, .ssame 
1274 b7				or a 
1275 c9				ret 
1276			 
1276			.ssame:  
1276 fe 00			cp 0 
1278 c8				ret z 
1279			 
1279 23				inc hl 
127a 13				inc de 
127b 18 f3			jr strcmp 
127d				 
127d				 
127d			 
127d			 
127d			 
127d			 
127d			; eof 
127d			 
127d			 
127d			 
127d			 
127d			 
127d			 
# End of file firmware_strings.asm
127d			include "firmware_memory.asm"   ; malloc and free  
127d			 
127d			if DEBUG_FORTH_MALLOC_HIGH 
127d			.mallocsize: db "Wants malloc >256",0 
127d			.mallocasize: db "MALLOC gives >256",0 
127d			.malloczero: db "MALLOC gives zero",0 
127d			 
127d			malloc_guard_zerolen: 
127d				push hl 
127d				push de 
127d				push af 
127d			 
127d				ld de, 0 
127d			        call cmp16 
127d				jr nz, .lowalloz 
127d			 
127d				push hl 
127d				push de 
127d					ld hl, display_fb0 
127d					ld (display_fb_active), hl 
127d				call clear_display 
127d				ld a, 0 
127d				ld de, .malloczero 
127d				call str_at_display 
127d				call update_display 
127d				call delay1s 
127d				call delay1s 
127d				ld a, 0 
127d				ld (os_view_disable), a 
127d			 
127d				pop de 
127d				pop hl 
127d			 
127d				 
127d			 
127d				CALLMONITOR 
127d			.lowalloz: 
127d			 
127d			 
127d				pop af 
127d				pop de 
127d				pop hl 
127d			ret 
127d			 
127d			malloc_guard_entry: 
127d				push hl 
127d				push de 
127d				push af 
127d			 
127d			 	or a      ;clear carry flag 
127d				push hl 
127d				ld de, 255 
127d				sbc hl, de 
127d				jr c, .lowalloc 
127d			 
127d				push de 
127d					ld hl, display_fb0 
127d					ld (display_fb_active), hl 
127d				call clear_display 
127d				ld a, 0 
127d				ld de, .mallocsize 
127d				call str_at_display 
127d				call update_display 
127d				call delay1s 
127d				call delay1s 
127d				ld a, 0 
127d				ld (os_view_disable), a 
127d			 
127d				pop de 
127d				pop hl 
127d			 
127d				 
127d			 
127d				CALLMONITOR 
127d				jr .lowdone 
127d			.lowalloc: 
127d			 
127d			 
127d				pop hl 
127d			.lowdone:	pop af 
127d				pop de 
127d				pop hl 
127d			ret 
127d			 
127d			malloc_guard_exit: 
127d				push hl 
127d				push de 
127d				push af 
127d			 
127d			 	or a      ;clear carry flag 
127d				push hl 
127d				ld de, 255 
127d				sbc hl, de 
127d				jr c, .lowallocx 
127d			 
127d				push de 
127d					ld hl, display_fb0 
127d					ld (display_fb_active), hl 
127d				call clear_display 
127d				ld a, 0 
127d				ld de, .mallocasize 
127d				call str_at_display 
127d				call update_display 
127d				call delay1s 
127d				call delay1s 
127d				ld a, 0 
127d				ld (os_view_disable), a 
127d				pop de 
127d				pop hl 
127d			 
127d				CALLMONITOR 
127d				jr .lowdonex 
127d			.lowallocx: 
127d			 
127d				pop hl 
127d			.lowdonex:	pop af 
127d				pop de 
127d				pop hl 
127d			ret 
127d			endif 
127d			 
127d			if MALLOC_2 
127d			; Z80 Malloc and Free Functions 
127d			 
127d			; Malloc Function: 
127d			; Input: 
127d			;   HL: Size of block to allocate 
127d			; Output: 
127d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
127d			 
127d			malloc: 
127d				 
127d			if DEBUG_FORTH_MALLOC_HIGH 
127d			call malloc_guard_entry 
127d			endif 
127d			 
127d			 
127d			 
127d			 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "mal" 
127d						CALLMONITOR 
127d					endif 
127d			    push af            ; Save AF register 
127d			    ld a, l            ; Load low byte of size into A 
127d			    or h               ; Check if size is zero 
127d			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
127d			 
127d			    ; Allocate memory 
127d			    ld hl, (heap_start) ; Load start of heap into HL 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "ma1" 
127d						CALLMONITOR 
127d					endif 
127d			    call malloc_internal ; Call internal malloc function 
127d			    pop af             ; Restore AF register 
127d			if DEBUG_FORTH_MALLOC_HIGH 
127d			call malloc_guard_exit 
127d			call malloc_guard_zerolen 
127d			endif 
127d			    ret                ; Return 
127d			 
127d			; Free Function: 
127d			; Input: 
127d			;   HL: Pointer to memory block to free 
127d			; Output: 
127d			;   None 
127d			 
127d			free: 
127d			    push af            ; Save AF register 
127d			    ld a, l            ; Load low byte of pointer into A 
127d			    or h               ; Check if pointer is NULL 
127d			    jp z, free_exit    ; If pointer is NULL, exit 
127d			 
127d			    ; Free memory 
127d			    ld hl, (heap_start) ; Load start of heap into HL 
127d			    call free_internal  ; Call internal free function 
127d			    pop af             ; Restore AF register 
127d			    ret                ; Return 
127d			 
127d			; Internal Malloc Function: 
127d			; Input: 
127d			;   HL: Size of block to allocate 
127d			; Output: 
127d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
127d			 
127d			malloc_internal: 
127d			    ld bc, 2           ; Number of bytes to allocate for management overhead 
127d			    add hl, bc         ; Add management overhead to requested size 
127d			    ex de, hl          ; Save total size in DE, and keep it in HL 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "ma2" 
127d						CALLMONITOR 
127d					endif 
127d			 
127d			    ; Search for free memory block 
127d			    ld de, (heap_end)  ; Load end of heap into DE 
127d			    ld bc, 0           ; Initialize counter 
127d			 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "ma2" 
127d						CALLMONITOR 
127d					endif 
127d			malloc_search_loop: 
127d			    ; Check if current block is free 
127d			    ld a, (hl)         ; Load current block's status (free or used) 
127d			    cp 0               ; Compare with zero (free) 
127d			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
127d			 
127d			    ; Check if current block is large enough 
127d			    ld a, (hl+1)       ; Load high byte of block size 
127d			    cp l               ; Compare with low byte of requested size 
127d			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
127d			 
127d			    ld a, (hl+2)       ; Load low byte of block size 
127d			    cp h               ; Compare with high byte of requested size 
127d			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
127d			 
127d			    ; Mark block as used 
127d			    ld (hl), 0xFF      ; Set status byte to indicate used block 
127d			 
127d			    ; Calculate remaining space in block 
127d			    ld bc, 0           ; Clear BC 
127d			    add hl, bc         ; Increment HL to point to start of data block 
127d			    add hl, de         ; HL = HL + DE (total size) 
127d			    ld bc, 1           ; Number of bytes to allocate for management overhead 
127d			    add hl, bc         ; Add management overhead to start of data block 
127d			 
127d			    ; Save pointer to allocated block in HL 
127d			if DEBUG_FORTH_MALLOC_HIGH 
127d						DMARK "ma5" 
127d			call malloc_guard_exit 
127d			call malloc_guard_zerolen 
127d			endif 
127d			    ret 
127d			 
127d			malloc_skip_block_check: 
127d			    ; Move to the next block 
127d			    ld bc, 3           ; Size of management overhead 
127d			    add hl, bc         ; Move to the next block 
127d			    inc de             ; Increment counter 
127d			 
127d			    ; Check if we have reached the end of heap 
127d			    ld a, e            ; Load low byte of heap end address 
127d			    cp (hl)            ; Compare with low byte of current address 
127d			    jr nz, malloc_search_loop  ; If not equal, continue searching 
127d			    ld a, d            ; Load high byte of heap end address 
127d			    cp 0               ; Check if it's zero (end of memory) 
127d			    jr nz, malloc_search_loop  ; If not zero, continue searching 
127d			 
127d			    ; If we reached here, allocation failed 
127d			    xor a              ; Set result to NULL 
127d			if DEBUG_FORTH_MALLOC_HIGH 
127d						DMARK "ma6" 
127d			call malloc_guard_exit 
127d			call malloc_guard_zerolen 
127d			endif 
127d			    ret 
127d			malloc_exit: 
127d			if DEBUG_FORTH_MALLOC_HIGH 
127d						DMARK "ma7" 
127d			call malloc_guard_exit 
127d			call malloc_guard_zerolen 
127d			endif 
127d			    ret 
127d			 
127d			; Internal Free Function: 
127d			; Input: 
127d			;   HL: Pointer to memory block to free 
127d			; Output: 
127d			;   None 
127d			 
127d			free_internal: 
127d			    ld de, (heap_start) ; Load start of heap into DE 
127d			    ld bc, 0            ; Initialize counter 
127d			 
127d			free_search_loop: 
127d			    ; Check if current block contains the pointer 
127d			    ld a, l             ; Load low byte of pointer 
127d			    cp (hl+1)           ; Compare with high byte of current block's address 
127d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
127d			    ld a, h             ; Load high byte of pointer 
127d			    cp (hl+2)           ; Compare with low byte of current block's address 
127d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
127d			 
127d			    ; Mark block as free 
127d			    ld (hl), 0          ; Set status byte to indicate free block 
127d			    ret                 ; Return 
127d			 
127d			free_skip_block_check: 
127d			    ; Move to the next block 
127d			    ld bc, 3            ; Size of management overhead 
127d			    add hl, bc          ; Move to the next block 
127d			    inc de              ; Increment counter 
127d			 
127d			    ; Check if we have reached the end of heap 
127d			    ld a, e             ; Load low byte of heap end address 
127d			    cp (hl)             ; Compare with low byte of current address 
127d			    jr nz, free_search_loop  ; If not equal, continue searching 
127d			    ld a, d             ; Load high byte of heap end address 
127d			    cp 0                ; Check if it's zero (end of memory) 
127d			    jr nz, free_search_loop  ; If not zero, continue searching 
127d			 
127d			    ; If we reached here, pointer is not found in heap 
127d			    ret 
127d			 
127d			free_exit: 
127d			    ret                 ; Return 
127d			 
127d			; Define heap start and end addresses 
127d			;heap_start:    .dw 0xC000   ; Start of heap 
127d			;heap_end:      .dw 0xE000   ; End of heap 
127d			 
127d			endif 
127d			 
127d			 
127d			if MALLOC_1 
127d			 
127d			 
127d			 
127d			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
127d			 
127d			;moved to firmware.asm 
127d			;heap_start        .equ  0x9000      ; Starting address of heap 
127d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
127d			 
127d			;      .org 0 
127d			;      jp    main 
127d			 
127d			 
127d			;      .org  0x100 
127d			;main: 
127d			;      ld    HL, 0x8100 
127d			;      ld    SP, HL 
127d			; 
127d			;      call  heap_init 
127d			; 
127d			;      ; Make some allocations 
127d			;      ld    HL, 12 
127d			;      call  malloc            ; Allocates 0x9004 
127d			; 
127d			;      ld    HL, 12 
127d			;      call  malloc            ; Allocates 0x9014 
127d			; 
127d			;      ld    HL, 12 
127d			;      call  malloc            ; Allocates 0x9024 
127d			; 
127d			;      ; Free some allocations 
127d			;      ld    HL, 0x9014 
127d			;      call  free 
127d			; 
127d			;      ld    HL, 0x9004 
127d			;      call  free 
127d			; 
127d			;      ld    HL, 0x9024 
127d			;      call  free 
127d			; 
127d			; 
127d			;      halt 
127d			 
127d			 
127d			;------------------------------------------------------------------------------ 
127d			;     heap_init                                                               : 
127d			;                                                                             : 
127d			; Description                                                                 : 
127d			;     Initialise the heap and make it ready for malloc and free operations.   : 
127d			;                                                                             : 
127d			;     The heap is maintained as a linked list, starting with an initial       : 
127d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
127d			;     the first free block in the heap. Each block then points to the next    : 
127d			;     free block within the heap, and the free list ends at the first block   : 
127d			;     with a null pointer to the next free block.                             : 
127d			;                                                                             : 
127d			; Parameters                                                                  : 
127d			;     Inputs are compile-time only. Two defines which specify the starting    : 
127d			;     address of the heap and its size are required, along with a memory      : 
127d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
127d			;     principally stores a pointer to the first free block in the heap.       : 
127d			;                                                                             : 
127d			; Returns                                                                     : 
127d			;     Nothing                                                                 : 
127d			;------------------------------------------------------------------------------ 
127d			heap_init: 
127d e5			      push  HL 
127e			 
127e			      ; Initialise free list struct 
127e 21 0e 80		      ld    HL, heap_start 
1281 22 0a 80		      ld    (free_list), HL 
1284 21 00 00		      ld    HL, 0 
1287 22 0c 80		      ld    (free_list+2), HL 
128a			 
128a			      ; Insert first free block at bottom of heap, consumes entire heap 
128a 21 0a 80		      ld    HL, heap_start+heap_size-4 
128d 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1290 21 fc ff		      ld    HL, heap_size-4 
1293 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1296			 
1296			      ; Insert end of free list block at top of heap - two null words will 
1296			      ; terminate the free list 
1296 21 00 00		      ld    HL, 0 
1299 22 0c 80		      ld    (heap_start+heap_size-2), HL 
129c 22 0a 80		      ld    (heap_start+heap_size-4), HL 
129f			 
129f e1			      pop   HL 
12a0			 
12a0 c9			      ret 
12a1			 
12a1			 
12a1			;------------------------------------------------------------------------------ 
12a1			;     malloc                                                                  : 
12a1			;                                                                             : 
12a1			; Description                                                                 : 
12a1			;     Allocates the wanted space from the heap and returns the address of the : 
12a1			;     first useable byte of the allocation.                                   : 
12a1			;                                                                             : 
12a1			;     Allocations can happen in one of two ways:                              : 
12a1			;                                                                             : 
12a1			;     1. A free block may be found which is the exact size wanted. In this    : 
12a1			;        case the block is removed from the free list and retuedn to the      : 
12a1			;        caller.                                                              : 
12a1			;     2. A free block may be found which is larger than the size wanted. In   : 
12a1			;        this case, the larger block is split into two. The first portion of  : 
12a1			;        this block will become the requested space by the malloc call and    : 
12a1			;        is returned to the caller. The second portion becomes a new free     : 
12a1			;        block, and the free list is adjusted to maintain continuity via this : 
12a1			;        newly created block.                                                 : 
12a1			;                                                                             : 
12a1			;     malloc does not set any initial value in the allocated space, the       : 
12a1			;     caller is required to do this as required.                              : 
12a1			;                                                                             : 
12a1			;     This implementation of malloc uses the stack exclusively, and is        : 
12a1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12a1			;     advisable to disable interrupts before calling malloc, and recommended  : 
12a1			;     to avoid the use of malloc inside ISRs in general.                      : 
12a1			;                                                                             : 
12a1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12a1			;                                                                             : 
12a1			; Parameters                                                                  : 
12a1			;     HL  Number of bytes wanted                                              : 
12a1			;                                                                             : 
12a1			; Returns                                                                     : 
12a1			;     HL  Address of the first useable byte of the allocation                 : 
12a1			;                                                                             : 
12a1			; Flags                                                                       : 
12a1			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12a1			;                                                                             : 
12a1			; Stack frame                                                                 : 
12a1			;       |             |                                                       : 
12a1			;       +-------------+                                                       : 
12a1			;       |     BC      |                                                       : 
12a1			;       +-------------+                                                       : 
12a1			;       |     DE      |                                                       : 
12a1			;       +-------------+                                                       : 
12a1			;       |     IX      |                                                       : 
12a1			;       +-------------+                                                       : 
12a1			;       |  prev_free  |                                                       : 
12a1			;   +4  +-------------+                                                       : 
12a1			;       |  this_free  |                                                       : 
12a1			;   +2  +-------------+                                                       : 
12a1			;       |  next_free  |                                                       : 
12a1			;   +0  +-------------+                                                       : 
12a1			;       |             |                                                       : 
12a1			;                                                                             : 
12a1			;------------------------------------------------------------------------------ 
12a1			 
12a1			 
12a1			;malloc: 
12a1			; 
12a1			;	SAVESP ON 1 
12a1			; 
12a1			;	call malloc_code 
12a1			; 
12a1			;	CHECKSP ON 1 
12a1			;	ret 
12a1			 
12a1			 
12a1			malloc: 
12a1 c5			      push  BC 
12a2 d5			      push  DE 
12a3 dd e5		      push  IX 
12a5			if DEBUG_FORTH_MALLOC_HIGH 
12a5			call malloc_guard_entry 
12a5			endif 
12a5			 
12a5					if DEBUG_FORTH_MALLOC 
12a5						DMARK "mal" 
12a5						CALLMONITOR 
12a5					endif 
12a5 7c			      ld    A, H                    ; Exit if no space requested 
12a6 b5			      or    L 
12a7 ca 66 13		      jp    Z, malloc_early_exit 
12aa			 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			; 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			;inc hl 
12aa			 
12aa			 
12aa			 
12aa			 
12aa					if DEBUG_FORTH_MALLOC 
12aa						DMARK "maA" 
12aa						CALLMONITOR 
12aa					endif 
12aa			      ; Set up stack frame 
12aa eb			      ex    DE, HL 
12ab 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12ae 39			      add   HL, SP 
12af f9			      ld    SP, HL 
12b0 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12b4 dd 39		      add   IX, SP 
12b6			 
12b6			      ; Setup initial state 
12b6 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12b9 19			      add   HL, DE 
12ba			 
12ba 44			      ld    B, H                    ; Move want to BC 
12bb 4d			      ld    C, L 
12bc			 
12bc 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
12bf dd 75 04		      ld    (IX+4), L 
12c2 dd 74 05		      ld    (IX+5), H 
12c5			 
12c5 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12c6 23			      inc   HL 
12c7 56			      ld    D, (HL) 
12c8 dd 73 02		      ld    (IX+2), E 
12cb dd 72 03		      ld    (IX+3), D 
12ce eb			      ex    DE, HL                  ; this_free ptr into HL 
12cf			 
12cf					if DEBUG_FORTH_MALLOC 
12cf						DMARK "maB" 
12cf						CALLMONITOR 
12cf					endif 
12cf			      ; Loop through free block list to find some space 
12cf			malloc_find_space: 
12cf 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12d0 23			      inc   HL 
12d1 56			      ld    D, (HL) 
12d2			 
12d2 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12d3 b3			      or    E 
12d4 ca 60 13		      jp    Z, malloc_no_space 
12d7			 
12d7 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12da dd 72 01		      ld    (IX+1), D 
12dd			 
12dd			      ; Does this block have enough space to make the allocation? 
12dd 23			      inc   HL                      ; Load free block size into DE 
12de 5e			      ld    E, (HL) 
12df 23			      inc   HL 
12e0 56			      ld    D, (HL) 
12e1			 
12e1 eb			      ex    DE, HL                  ; Check size of block against want 
12e2 b7			      or    A                       ; Ensure carry flag clear 
12e3 ed 42		      sbc   HL, BC 
12e5 e5			      push  HL                      ; Store the result for later (new block size) 
12e6			 
12e6 ca 35 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12e9 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12eb			 
12eb			      ; this_free block is not big enough, setup ptrs to test next free block 
12eb e1			      pop   HL                      ; Discard previous result 
12ec			 
12ec dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12ef dd 66 03		      ld    H, (IX+3) 
12f2 dd 75 04		      ld    (IX+4), L 
12f5 dd 74 05		      ld    (IX+5), H 
12f8			 
12f8 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12fb dd 66 01		      ld    H, (IX+1) 
12fe dd 75 02		      ld    (IX+2), L 
1301 dd 74 03		      ld    (IX+3), H 
1304			 
1304					if DEBUG_FORTH_MALLOC 
1304						DMARK "MA>" 
1304						CALLMONITOR 
1304					endif 
1304 18 c9		      jr    malloc_find_space 
1306			 
1306			      ; split a bigger block into two - requested size and remaining size 
1306			malloc_alloc_split: 
1306					if DEBUG_FORTH_MALLOC 
1306						DMARK "MAs" 
1306						CALLMONITOR 
1306					endif 
1306 eb			      ex    DE, HL                  ; Calculate address of new free block 
1307 2b			      dec   HL 
1308 2b			      dec   HL 
1309 2b			      dec   HL 
130a 09			      add   HL, BC 
130b			 
130b			      ; Create a new block and point it at next_free 
130b dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
130e dd 56 01		      ld    D, (IX+1) 
1311			 
1311 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1312 23			      inc   HL 
1313 72			      ld    (HL), D 
1314			 
1314 d1			      pop   DE                      ; Store size of new block into new block 
1315 23			      inc   HL 
1316 73			      ld    (HL), E 
1317 23			      inc   HL 
1318 72			      ld    (HL), D 
1319			 
1319			      ; Update this_free ptr to point to new block 
1319 2b			      dec   HL 
131a 2b			      dec   HL 
131b 2b			      dec   HL 
131c			 
131c dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
131f dd 56 03		      ld    D, (IX+3) 
1322			 
1322 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1325 dd 74 03		      ld    (IX+3), H 
1328			 
1328			      ; Modify this_free block to be allocation 
1328 eb			      ex    DE, HL 
1329 af			      xor   A                       ; Null the next block ptr of allocated block 
132a 77			      ld    (HL), A 
132b 23			      inc   HL 
132c 77			      ld    (HL), A 
132d			 
132d 23			      inc   HL                      ; Store want size into allocated block 
132e 71			      ld    (HL), C 
132f 23			      inc   HL 
1330 70			      ld    (HL), B 
1331 23			      inc   HL 
1332 e5			      push  HL                      ; Address of allocation to return 
1333			 
1333 18 19		      jr    malloc_update_links 
1335			 
1335			malloc_alloc_fit: 
1335 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1336			 
1336					if DEBUG_FORTH_MALLOC 
1336						DMARK "MAf" 
1336						CALLMONITOR 
1336					endif 
1336			      ; Modify this_free block to be allocation 
1336 eb			      ex    DE, HL 
1337 2b			      dec   HL 
1338 2b			      dec   HL 
1339 2b			      dec   HL 
133a			 
133a af			      xor   A                       ; Null the next block ptr of allocated block 
133b 77			      ld    (HL), A 
133c 23			      inc   HL 
133d 77			      ld    (HL), A 
133e			 
133e 23			      inc   HL                      ; Store address of allocation to return 
133f 23			      inc   HL 
1340 23			      inc   HL 
1341 e5			      push  HL 
1342			 
1342			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1342 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1345 dd 66 01		      ld    H, (IX+1) 
1348			 
1348 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
134b dd 74 03		      ld    (IX+3), H 
134e			 
134e			 
134e			malloc_update_links: 
134e			      ; Update prev_free ptr to point to this_free 
134e dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1351 dd 66 05		      ld    H, (IX+5) 
1354			 
1354 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1357 dd 56 03		      ld    D, (IX+3) 
135a			 
135a 73			      ld    (HL), E                 ; this_free ptr into prev_free 
135b 23			      inc   HL 
135c 72			      ld    (HL), D 
135d			 
135d					if DEBUG_FORTH_MALLOC 
135d						DMARK "Mul" 
135d						CALLMONITOR 
135d					endif 
135d			      ; Clear the Z flag to indicate successful allocation 
135d 7a			      ld    A, D 
135e b3			      or    E 
135f			 
135f d1			      pop   DE                      ; Address of allocation 
1360					if DEBUG_FORTH_MALLOC 
1360						DMARK "MAu" 
1360						CALLMONITOR 
1360					endif 
1360			 
1360			malloc_no_space: 
1360 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1363 39			      add   HL, SP 
1364 f9			      ld    SP, HL 
1365			 
1365 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1366					if DEBUG_FORTH_MALLOC 
1366						DMARK "MAN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			malloc_early_exit: 
1366					if DEBUG_FORTH_MALLOC 
1366						DMARK "MAx" 
1366						CALLMONITOR 
1366					endif 
1366 dd e1		      pop   IX 
1368 d1			      pop   DE 
1369 c1			      pop   BC 
136a			 
136a			if DEBUG_FORTH_MALLOC_HIGH 
136a			call malloc_guard_exit 
136a			call malloc_guard_zerolen 
136a			endif 
136a c9			      ret 
136b			 
136b			 
136b			;------------------------------------------------------------------------------ 
136b			;     free                                                                    : 
136b			;                                                                             : 
136b			; Description                                                                 : 
136b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
136b			;     returned by malloc, otherwise the behaviour is undefined.               : 
136b			;                                                                             : 
136b			;     Where possible, directly adjacent free blocks will be merged together   : 
136b			;     into larger blocks to help ensure that the heap does not become         : 
136b			;     excessively fragmented.                                                 : 
136b			;                                                                             : 
136b			;     free does not clear or set any other value into the freed space, and    : 
136b			;     therefore its contents may be visible through subsequent malloc's. The  : 
136b			;     caller should clear the freed space as required.                        : 
136b			;                                                                             : 
136b			;     This implementation of free uses the stack exclusively, and is          : 
136b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
136b			;     advisable to disable interrupts before calling free, and recommended    : 
136b			;     to avoid the use of free inside ISRs in general.                        : 
136b			;                                                                             : 
136b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
136b			;                                                                             : 
136b			; Parameters                                                                  : 
136b			;     HL  Pointer to address of first byte of allocation to be freed          : 
136b			;                                                                             : 
136b			; Returns                                                                     : 
136b			;     Nothing                                                                 : 
136b			;                                                                             : 
136b			; Stack frame                                                                 : 
136b			;       |             |                                                       : 
136b			;       +-------------+                                                       : 
136b			;       |     BC      |                                                       : 
136b			;       +-------------+                                                       : 
136b			;       |     DE      |                                                       : 
136b			;       +-------------+                                                       : 
136b			;       |     IX      |                                                       : 
136b			;       +-------------+                                                       : 
136b			;       |  prev_free  |                                                       : 
136b			;   +2  +-------------+                                                       : 
136b			;       |  next_free  |                                                       : 
136b			;   +0  +-------------+                                                       : 
136b			;       |             |                                                       : 
136b			;                                                                             : 
136b			;------------------------------------------------------------------------------ 
136b			free: 
136b c5			      push  BC 
136c d5			      push  DE 
136d dd e5		      push  IX 
136f			 
136f 7c			      ld    A, H                    ; Exit if ptr is null 
1370 b5			      or    L 
1371 ca 35 14		      jp    Z, free_early_exit 
1374			 
1374			      ; Set up stack frame 
1374 eb			      ex    DE, HL 
1375 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1378 39			      add   HL, SP 
1379 f9			      ld    SP, HL 
137a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
137e dd 39		      add   IX, SP 
1380			 
1380			      ; The address in HL points to the start of the useable allocated space, 
1380			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1380			      ; address of the block itself. 
1380 eb			      ex    DE, HL 
1381 11 fc ff		      ld    DE, -4 
1384 19			      add   HL, DE 
1385			 
1385			      ; An allocated block must have a null next block pointer in it 
1385 7e			      ld    A, (HL) 
1386 23			      inc   HL 
1387 b6			      or    (HL) 
1388 c2 30 14		      jp    NZ, free_done 
138b			 
138b 2b			      dec   HL 
138c			 
138c 44			      ld    B, H                    ; Copy HL to BC 
138d 4d			      ld    C, L 
138e			 
138e			      ; Loop through the free list to find the first block with an address 
138e			      ; higher than the block being freed 
138e 21 0a 80		      ld    HL, free_list 
1391			 
1391			free_find_higher_block: 
1391 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1392 23			      inc   HL 
1393 56			      ld    D, (HL) 
1394 2b			      dec   HL 
1395			 
1395 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1398 dd 72 01		      ld    (IX+1), D 
139b dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
139e dd 74 03		      ld    (IX+3), H 
13a1			 
13a1 78			      ld    A, B                    ; Check if DE is greater than BC 
13a2 ba			      cp    D                       ; Compare MSB first 
13a3 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13a5 30 04		      jr    NC, free_find_higher_block_skip 
13a7 79			      ld    A, C 
13a8 bb			      cp    E                       ; Then compare LSB 
13a9 38 08		      jr    C, free_found_higher_block 
13ab			 
13ab			free_find_higher_block_skip: 
13ab 7a			      ld    A, D                    ; Reached the end of the free list? 
13ac b3			      or    E 
13ad ca 30 14		      jp    Z, free_done 
13b0			 
13b0 eb			      ex    DE, HL 
13b1			 
13b1 18 de		      jr    free_find_higher_block 
13b3			 
13b3			free_found_higher_block: 
13b3			      ; Insert freed block between prev and next free blocks 
13b3 71			      ld    (HL), C                 ; Point prev free block to freed block 
13b4 23			      inc   HL 
13b5 70			      ld    (HL), B 
13b6			 
13b6 60			      ld    H, B                    ; Point freed block at next free block 
13b7 69			      ld    L, C 
13b8 73			      ld    (HL), E 
13b9 23			      inc   HL 
13ba 72			      ld    (HL), D 
13bb			 
13bb			      ; Check if the freed block is adjacent to the next free block 
13bb 23			      inc   HL                      ; Load size of freed block into HL 
13bc 5e			      ld    E, (HL) 
13bd 23			      inc   HL 
13be 56			      ld    D, (HL) 
13bf eb			      ex    DE, HL 
13c0			 
13c0 09			      add   HL, BC                  ; Add addr of freed block and its size 
13c1			 
13c1 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13c4 dd 56 01		      ld    D, (IX+1) 
13c7			 
13c7 b7			      or    A                       ; Clear the carry flag 
13c8 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13ca 20 22		      jr    NZ, free_check_adjacent_to_prev 
13cc			 
13cc			      ; Freed block is adjacent to next, merge into one bigger block 
13cc eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13cd 5e			      ld    E, (HL) 
13ce 23			      inc   HL 
13cf 56			      ld    D, (HL) 
13d0 e5			      push  HL                      ; Save ptr to next block for later 
13d1			 
13d1 60			      ld    H, B                    ; Store ptr from next block into freed block 
13d2 69			      ld    L, C 
13d3 73			      ld    (HL), E 
13d4 23			      inc   HL 
13d5 72			      ld    (HL), D 
13d6			 
13d6 e1			      pop   HL                      ; Restore ptr to next block 
13d7 23			      inc   HL                      ; Load size of next block into DE 
13d8 5e			      ld    E, (HL) 
13d9 23			      inc   HL 
13da 56			      ld    D, (HL) 
13db d5			      push  DE                      ; Save next block size for later 
13dc			 
13dc 60			      ld    H, B                    ; Load size of freed block into HL 
13dd 69			      ld    L, C 
13de 23			      inc   HL 
13df 23			      inc   HL 
13e0 5e			      ld    E, (HL) 
13e1 23			      inc   HL 
13e2 56			      ld    D, (HL) 
13e3 eb			      ex    DE, HL 
13e4			 
13e4 d1			      pop   DE                      ; Restore size of next block 
13e5 19			      add   HL, DE                  ; Add sizes of both blocks 
13e6 eb			      ex    DE, HL 
13e7			 
13e7 60			      ld    H, B                    ; Store new bigger size into freed block 
13e8 69			      ld    L, C 
13e9 23			      inc   HL 
13ea 23			      inc   HL 
13eb 73			      ld    (HL), E 
13ec 23			      inc   HL 
13ed 72			      ld    (HL), D 
13ee			 
13ee			free_check_adjacent_to_prev: 
13ee			      ; Check if the freed block is adjacent to the prev free block 
13ee dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13f1 dd 66 03		      ld    H, (IX+3) 
13f4			 
13f4 23			      inc   HL                      ; Size of prev free block into DE 
13f5 23			      inc   HL 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9 2b			      dec   HL 
13fa 2b			      dec   HL 
13fb 2b			      dec   HL 
13fc			 
13fc 19			      add   HL, DE                  ; Add prev block addr and size 
13fd			 
13fd b7			      or    A                       ; Clear the carry flag 
13fe ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1400 20 2e		      jr    NZ, free_done 
1402			 
1402			      ; Freed block is adjacent to prev, merge into one bigger block 
1402 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1403 69			      ld    L, C 
1404 5e			      ld    E, (HL) 
1405 23			      inc   HL 
1406 56			      ld    D, (HL) 
1407 e5			      push  HL                      ; Save freed block ptr for later 
1408			 
1408 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
140b dd 66 03		      ld    H, (IX+3) 
140e 73			      ld    (HL), E 
140f 23			      inc   HL 
1410 72			      ld    (HL), D 
1411			 
1411 e1			      pop   HL                      ; Restore freed block ptr 
1412 23			      inc   HL                      ; Load size of freed block into DE 
1413 5e			      ld    E, (HL) 
1414 23			      inc   HL 
1415 56			      ld    D, (HL) 
1416 d5			      push  DE                      ; Save freed block size for later 
1417			 
1417 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
141a dd 66 03		      ld    H, (IX+3) 
141d 23			      inc   HL 
141e 23			      inc   HL 
141f 5e			      ld    E, (HL) 
1420 23			      inc   HL 
1421 56			      ld    D, (HL) 
1422			 
1422 e1			      pop   HL                      ; Add sizes of both blocks 
1423 19			      add   HL, DE 
1424 eb			      ex    DE, HL 
1425			 
1425 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1428 dd 66 03		      ld    H, (IX+3) 
142b 23			      inc   HL 
142c 23			      inc   HL 
142d 73			      ld    (HL), E 
142e 23			      inc   HL 
142f 72			      ld    (HL), D 
1430			 
1430			free_done: 
1430 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1433 39			      add   HL, SP 
1434 f9			      ld    SP, HL 
1435			 
1435			free_early_exit: 
1435 dd e1		      pop   IX 
1437 d1			      pop   DE 
1438 c1			      pop   BC 
1439			 
1439 c9			      ret 
143a			 
143a			; moved to firmware.asm 
143a			; 
143a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
143a			;                  .dw   0 
143a			 
143a			 
143a			endif 
143a			 
143a			 
143a			if MALLOC_3 
143a			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
143a			;heap_start        .equ  0x9000      ; Starting address of heap 
143a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
143a			; 
143a			 ;     .org 0 
143a			  ;    jp    main 
143a			; 
143a			; 
143a			 ;     .org  0x100 
143a			;main: 
143a			 ;     ld    HL, 0x8100 
143a			  ;    ld    SP, HL 
143a			; 
143a			;      call  heap_init 
143a			 
143a			      ; Make some allocations 
143a			;      ld    HL, 12 
143a			;      call  malloc            ; Allocates 0x9004 
143a			; 
143a			 ;     ld    HL, 12 
143a			;      call  malloc            ; Allocates 0x9014 
143a			 
143a			;      ld    HL, 12 
143a			;      call  malloc            ; Allocates 0x9024 
143a			 
143a			      ; Free some allocations 
143a			;      ld    HL, 0x9014 
143a			;      call  free 
143a			 
143a			;      ld    HL, 0x9004 
143a			;      call  free 
143a			; 
143a			;      ld    HL, 0x9024 
143a			;      call  free 
143a			 
143a			 
143a			 ;     halt 
143a			 
143a			 
143a			;------------------------------------------------------------------------------ 
143a			;     heap_init                                                               : 
143a			;                                                                             : 
143a			; Description                                                                 : 
143a			;     Initialise the heap and make it ready for malloc and free operations.   : 
143a			;                                                                             : 
143a			;     The heap is maintained as a linked list, starting with an initial       : 
143a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
143a			;     the first free block in the heap. Each block then points to the next    : 
143a			;     free block within the heap, and the free list ends at the first block   : 
143a			;     with a null pointer to the next free block.                             : 
143a			;                                                                             : 
143a			; Parameters                                                                  : 
143a			;     Inputs are compile-time only. Two defines which specify the starting    : 
143a			;     address of the heap and its size are required, along with a memory      : 
143a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
143a			;     principally stores a pointer to the first free block in the heap.       : 
143a			;                                                                             : 
143a			; Returns                                                                     : 
143a			;     Nothing                                                                 : 
143a			;------------------------------------------------------------------------------ 
143a			heap_init: 
143a			      push  HL 
143a			 
143a			      ; Initialise free list struct 
143a			      ld    HL, heap_start 
143a			      ld    (free_list), HL 
143a			      ld    HL, 0 
143a			      ld    (free_list+2), HL 
143a			 
143a			      ; Insert first free block at bottom of heap, consumes entire heap 
143a			      ld    HL, heap_start+heap_size-4 
143a			      ld    (heap_start), HL        ; Next block (end of free list) 
143a			      ld    HL, heap_size-4 
143a			      ld    (heap_start+2), HL      ; Block size 
143a			 
143a			      ; Insert end of free list block at top of heap - two null words will 
143a			      ; terminate the free list 
143a			      ld    HL, 0 
143a			      ld    (heap_start+heap_size-2), HL 
143a			      ld    (heap_start+heap_size-4), HL 
143a			 
143a			      pop   HL 
143a			 
143a			      ret 
143a			 
143a			 
143a			;------------------------------------------------------------------------------ 
143a			;     malloc                                                                  : 
143a			;                                                                             : 
143a			; Description                                                                 : 
143a			;     Allocates the wanted space from the heap and returns the address of the : 
143a			;     first useable byte of the allocation.                                   : 
143a			;                                                                             : 
143a			;     Allocations can happen in one of two ways:                              : 
143a			;                                                                             : 
143a			;     1. A free block may be found which is the exact size wanted. In this    : 
143a			;        case the block is removed from the free list and retuedn to the      : 
143a			;        caller.                                                              : 
143a			;     2. A free block may be found which is larger than the size wanted. In   : 
143a			;        this case, the larger block is split into two. The first portion of  : 
143a			;        this block will become the requested space by the malloc call and    : 
143a			;        is returned to the caller. The second portion becomes a new free     : 
143a			;        block, and the free list is adjusted to maintain continuity via this : 
143a			;        newly created block.                                                 : 
143a			;                                                                             : 
143a			;     malloc does not set any initial value in the allocated space, the       : 
143a			;     caller is required to do this as required.                              : 
143a			;                                                                             : 
143a			;     This implementation of malloc uses the stack exclusively, and is        : 
143a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
143a			;     advisable to disable interrupts before calling malloc, and recommended  : 
143a			;     to avoid the use of malloc inside ISRs in general.                      : 
143a			;                                                                             : 
143a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
143a			;                                                                             : 
143a			; Parameters                                                                  : 
143a			;     HL  Number of bytes wanted                                              : 
143a			;                                                                             : 
143a			; Returns                                                                     : 
143a			;     HL  Address of the first useable byte of the allocation                 : 
143a			;                                                                             : 
143a			; Flags                                                                       : 
143a			;     Z   Set if the allocation did not succeed, clear otherwise              : 
143a			;                                                                             : 
143a			; Stack frame                                                                 : 
143a			;       |             |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |     BC      |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |     DE      |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |     IX      |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |  prev_free  |                                                       : 
143a			;   +4  +-------------+                                                       : 
143a			;       |  this_free  |                                                       : 
143a			;   +2  +-------------+                                                       : 
143a			;       |  next_free  |                                                       : 
143a			;   +0  +-------------+                                                       : 
143a			;       |             |                                                       : 
143a			;                                                                             : 
143a			;------------------------------------------------------------------------------ 
143a			malloc: 
143a			      push  BC 
143a			      push  DE 
143a			      push  IX 
143a			 
143a			      ld    A, H                    ; Exit if no space requested 
143a			      or    L 
143a			      jp    Z, malloc_early_exit 
143a			 
143a			      ; Set up stack frame 
143a			      ex    DE, HL 
143a			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
143a			      add   HL, SP 
143a			      ld    SP, HL 
143a			      ld    IX, 0                   ; Use IX as a frame pointer 
143a			      add   IX, SP 
143a			 
143a			      ; Setup initial state 
143a			      ld    HL, 4                   ; want must also include space used by block struct 
143a			      add   HL, DE 
143a			 
143a			      ld    B, H                    ; Move want to BC 
143a			      ld    C, L 
143a			 
143a			      ld    HL, free_list           ; Store prev_free ptr to stack 
143a			      ld    (IX+4), L 
143a			      ld    (IX+5), H 
143a			 
143a			      ld    E, (HL)                 ; Store this_free ptr to stack 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      ld    (IX+2), E 
143a			      ld    (IX+3), D 
143a			      ex    DE, HL                  ; this_free ptr into HL 
143a			 
143a			      ; Loop through free block list to find some space 
143a			malloc_find_space: 
143a			      ld    E, (HL)                 ; Load next_free ptr into DE 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			 
143a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
143a			      or    E 
143a			      jp    Z, malloc_no_space 
143a			 
143a			      ld    (IX+0), E               ; Store next_free ptr to stack 
143a			      ld    (IX+1), D 
143a			 
143a			      ; Does this block have enough space to make the allocation? 
143a			      inc   HL                      ; Load free block size into DE 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			 
143a			      ex    DE, HL                  ; Check size of block against want 
143a			      or    A                       ; Ensure carry flag clear 
143a			      sbc   HL, BC 
143a			      push  HL                      ; Store the result for later (new block size) 
143a			 
143a			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
143a			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
143a			 
143a			      ; this_free block is not big enough, setup ptrs to test next free block 
143a			      pop   HL                      ; Discard previous result 
143a			 
143a			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
143a			      ld    H, (IX+3) 
143a			      ld    (IX+4), L 
143a			      ld    (IX+5), H 
143a			 
143a			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
143a			      ld    H, (IX+1) 
143a			      ld    (IX+2), L 
143a			      ld    (IX+3), H 
143a			 
143a			      jr    malloc_find_space 
143a			 
143a			      ; split a bigger block into two - requested size and remaining size 
143a			malloc_alloc_split: 
143a			      ex    DE, HL                  ; Calculate address of new free block 
143a			      dec   HL 
143a			      dec   HL 
143a			      dec   HL 
143a			      add   HL, BC 
143a			 
143a			      ; Create a new block and point it at next_free 
143a			      ld    E, (IX+0)               ; Load next_free ptr into DE 
143a			      ld    D, (IX+1) 
143a			 
143a			      ld    (HL), E                 ; Store next_free ptr into new block 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			      pop   DE                      ; Store size of new block into new block 
143a			      inc   HL 
143a			      ld    (HL), E 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			      ; Update this_free ptr to point to new block 
143a			      dec   HL 
143a			      dec   HL 
143a			      dec   HL 
143a			 
143a			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
143a			      ld    D, (IX+3) 
143a			 
143a			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143a			      ld    (IX+3), H 
143a			 
143a			      ; Modify this_free block to be allocation 
143a			      ex    DE, HL 
143a			      xor   A                       ; Null the next block ptr of allocated block 
143a			      ld    (HL), A 
143a			      inc   HL 
143a			      ld    (HL), A 
143a			 
143a			      inc   HL                      ; Store want size into allocated block 
143a			      ld    (HL), C 
143a			      inc   HL 
143a			      ld    (HL), B 
143a			      inc   HL 
143a			      push  HL                      ; Address of allocation to return 
143a			 
143a			      jr    malloc_update_links 
143a			 
143a			malloc_alloc_fit: 
143a			      pop   HL                      ; Dont need new block size, want is exact fit 
143a			 
143a			      ; Modify this_free block to be allocation 
143a			      ex    DE, HL 
143a			      dec   HL 
143a			      dec   HL 
143a			      dec   HL 
143a			 
143a			      xor   A                       ; Null the next block ptr of allocated block 
143a			      ld    (HL), A 
143a			      inc   HL 
143a			      ld    (HL), A 
143a			 
143a			      inc   HL                      ; Store address of allocation to return 
143a			      inc   HL 
143a			      inc   HL 
143a			      push  HL 
143a			 
143a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
143a			      ld    L, (IX+0)               ; next_free to HL 
143a			      ld    H, (IX+1) 
143a			 
143a			      ld    (IX+2), L               ; HL to this_free 
143a			      ld    (IX+3), H 
143a			 
143a			 
143a			malloc_update_links: 
143a			      ; Update prev_free ptr to point to this_free 
143a			      ld    L, (IX+4)               ; prev_free ptr to HL 
143a			      ld    H, (IX+5) 
143a			 
143a			      ld    E, (IX+2)               ; this_free ptr to DE 
143a			      ld    D, (IX+3) 
143a			 
143a			      ld    (HL), E                 ; this_free ptr into prev_free 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			      ; Clear the Z flag to indicate successful allocation 
143a			      ld    A, D 
143a			      or    E 
143a			 
143a			      pop   DE                      ; Address of allocation 
143a			 
143a			malloc_no_space: 
143a			      ld    HL, 6                   ; Clean up stack frame 
143a			      add   HL, SP 
143a			      ld    SP, HL 
143a			 
143a			      ex    DE, HL                  ; Alloc addr into HL for return 
143a			 
143a			malloc_early_exit: 
143a			      pop   IX 
143a			      pop   DE 
143a			      pop   BC 
143a			 
143a			      ret 
143a			 
143a			 
143a			;------------------------------------------------------------------------------ 
143a			;     free                                                                    : 
143a			;                                                                             : 
143a			; Description                                                                 : 
143a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
143a			;     returned by malloc, otherwise the behaviour is undefined.               : 
143a			;                                                                             : 
143a			;     Where possible, directly adjacent free blocks will be merged together   : 
143a			;     into larger blocks to help ensure that the heap does not become         : 
143a			;     excessively fragmented.                                                 : 
143a			;                                                                             : 
143a			;     free does not clear or set any other value into the freed space, and    : 
143a			;     therefore its contents may be visible through subsequent malloc's. The  : 
143a			;     caller should clear the freed space as required.                        : 
143a			;                                                                             : 
143a			;     This implementation of free uses the stack exclusively, and is          : 
143a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
143a			;     advisable to disable interrupts before calling free, and recommended    : 
143a			;     to avoid the use of free inside ISRs in general.                        : 
143a			;                                                                             : 
143a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
143a			;                                                                             : 
143a			; Parameters                                                                  : 
143a			;     HL  Pointer to address of first byte of allocation to be freed          : 
143a			;                                                                             : 
143a			; Returns                                                                     : 
143a			;     Nothing                                                                 : 
143a			;                                                                             : 
143a			; Stack frame                                                                 : 
143a			;       |             |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |     BC      |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |     DE      |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |     IX      |                                                       : 
143a			;       +-------------+                                                       : 
143a			;       |  prev_free  |                                                       : 
143a			;   +2  +-------------+                                                       : 
143a			;       |  next_free  |                                                       : 
143a			;   +0  +-------------+                                                       : 
143a			;       |             |                                                       : 
143a			;                                                                             : 
143a			;------------------------------------------------------------------------------ 
143a			free: 
143a			      push  BC 
143a			      push  DE 
143a			      push  IX 
143a			 
143a			      ld    A, H                    ; Exit if ptr is null 
143a			      or    L 
143a			      jp    Z, free_early_exit 
143a			 
143a			      ; Set up stack frame 
143a			      ex    DE, HL 
143a			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
143a			      add   HL, SP 
143a			      ld    SP, HL 
143a			      ld    IX, 0                   ; Use IX as a frame pointer 
143a			      add   IX, SP 
143a			 
143a			      ; The address in HL points to the start of the useable allocated space, 
143a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
143a			      ; address of the block itself. 
143a			      ex    DE, HL 
143a			      ld    DE, -4 
143a			      add   HL, DE 
143a			 
143a			      ; An allocated block must have a null next block pointer in it 
143a			      ld    A, (HL) 
143a			      inc   HL 
143a			      or    (HL) 
143a			      jp    NZ, free_done 
143a			 
143a			      dec   HL 
143a			 
143a			      ld    B, H                    ; Copy HL to BC 
143a			      ld    C, L 
143a			 
143a			      ; Loop through the free list to find the first block with an address 
143a			      ; higher than the block being freed 
143a			      ld    HL, free_list 
143a			 
143a			free_find_higher_block: 
143a			      ld    E, (HL)                 ; Load next ptr from free block 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      dec   HL 
143a			 
143a			      ld    (IX+0), E               ; Save ptr to next free block 
143a			      ld    (IX+1), D 
143a			      ld    (IX+2), L               ; Save ptr to prev free block 
143a			      ld    (IX+3), H 
143a			 
143a			      ld    A, B                    ; Check if DE is greater than BC 
143a			      cp    D                       ; Compare MSB first 
143a			      jr    Z, $+4                  ; MSB the same, compare LSB 
143a			      jr    NC, free_find_higher_block_skip 
143a			      ld    A, C 
143a			      cp    E                       ; Then compare LSB 
143a			      jr    C, free_found_higher_block 
143a			 
143a			free_find_higher_block_skip: 
143a			      ld    A, D                    ; Reached the end of the free list? 
143a			      or    E 
143a			      jp    Z, free_done 
143a			 
143a			      ex    DE, HL 
143a			 
143a			      jr    free_find_higher_block 
143a			 
143a			free_found_higher_block: 
143a			      ; Insert freed block between prev and next free blocks 
143a			      ld    (HL), C                 ; Point prev free block to freed block 
143a			      inc   HL 
143a			      ld    (HL), B 
143a			 
143a			      ld    H, B                    ; Point freed block at next free block 
143a			      ld    L, C 
143a			      ld    (HL), E 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			      ; Check if the freed block is adjacent to the next free block 
143a			      inc   HL                      ; Load size of freed block into HL 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      ex    DE, HL 
143a			 
143a			      add   HL, BC                  ; Add addr of freed block and its size 
143a			 
143a			      ld    E, (IX+0)               ; Load addr of next free block into DE 
143a			      ld    D, (IX+1) 
143a			 
143a			      or    A                       ; Clear the carry flag 
143a			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
143a			      jr    NZ, free_check_adjacent_to_prev 
143a			 
143a			      ; Freed block is adjacent to next, merge into one bigger block 
143a			      ex    DE, HL                  ; Load next ptr from next block into DE 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      push  HL                      ; Save ptr to next block for later 
143a			 
143a			      ld    H, B                    ; Store ptr from next block into freed block 
143a			      ld    L, C 
143a			      ld    (HL), E 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			      pop   HL                      ; Restore ptr to next block 
143a			      inc   HL                      ; Load size of next block into DE 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      push  DE                      ; Save next block size for later 
143a			 
143a			      ld    H, B                    ; Load size of freed block into HL 
143a			      ld    L, C 
143a			      inc   HL 
143a			      inc   HL 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      ex    DE, HL 
143a			 
143a			      pop   DE                      ; Restore size of next block 
143a			      add   HL, DE                  ; Add sizes of both blocks 
143a			      ex    DE, HL 
143a			 
143a			      ld    H, B                    ; Store new bigger size into freed block 
143a			      ld    L, C 
143a			      inc   HL 
143a			      inc   HL 
143a			      ld    (HL), E 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			free_check_adjacent_to_prev: 
143a			      ; Check if the freed block is adjacent to the prev free block 
143a			      ld    L, (IX+2)               ; Prev free block ptr into HL 
143a			      ld    H, (IX+3) 
143a			 
143a			      inc   HL                      ; Size of prev free block into DE 
143a			      inc   HL 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      dec   HL 
143a			      dec   HL 
143a			      dec   HL 
143a			 
143a			      add   HL, DE                  ; Add prev block addr and size 
143a			 
143a			      or    A                       ; Clear the carry flag 
143a			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
143a			      jr    NZ, free_done 
143a			 
143a			      ; Freed block is adjacent to prev, merge into one bigger block 
143a			      ld    H, B                    ; Load next ptr from freed block into DE 
143a			      ld    L, C 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      push  HL                      ; Save freed block ptr for later 
143a			 
143a			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
143a			      ld    H, (IX+3) 
143a			      ld    (HL), E 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			      pop   HL                      ; Restore freed block ptr 
143a			      inc   HL                      ; Load size of freed block into DE 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			      push  DE                      ; Save freed block size for later 
143a			 
143a			      ld    L, (IX+2)               ; Load size of prev block into DE 
143a			      ld    H, (IX+3) 
143a			      inc   HL 
143a			      inc   HL 
143a			      ld    E, (HL) 
143a			      inc   HL 
143a			      ld    D, (HL) 
143a			 
143a			      pop   HL                      ; Add sizes of both blocks 
143a			      add   HL, DE 
143a			      ex    DE, HL 
143a			 
143a			      ld    L, (IX+2)               ; Store new bigger size into prev block 
143a			      ld    H, (IX+3) 
143a			      inc   HL 
143a			      inc   HL 
143a			      ld    (HL), E 
143a			      inc   HL 
143a			      ld    (HL), D 
143a			 
143a			free_done: 
143a			      ld    HL, 4                   ; Clean up stack frame 
143a			      add   HL, SP 
143a			      ld    SP, HL 
143a			 
143a			free_early_exit: 
143a			      pop   IX 
143a			      pop   DE 
143a			      pop   BC 
143a			 
143a			      ret 
143a			 
143a			 
143a			;      .org 0x8000 
143a			; 
143a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
143a			 ;                 .dw   0 
143a			 
143a			endif 
143a			 
143a			 
143a			if MALLOC_4 
143a			 
143a			; My memory allocation code. Very very simple.... 
143a			; allocate space under 250 chars 
143a			 
143a			heap_init: 
143a				; init start of heap as zero 
143a				;  
143a			 
143a				ld hl, heap_start 
143a				ld a, 0 
143a				ld (hl), a      ; empty block 
143a				inc hl 
143a				ld a, 0 
143a				ld (hl), a      ; length of block 
143a				; write end of list 
143a				inc hl 
143a				ld a,(hl) 
143a				inc hl 
143a				ld a,(hl) 
143a				 
143a			 
143a				; init some malloc vars 
143a			 
143a				ld hl, 0 
143a				ld (free_list), hl       ; store last malloc location 
143a			 
143a				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
143a				ld a, 0 
143a				ld (hl), a 
143a			 
143a			 
143a				ld hl, heap_start 
143a				;  
143a				  
143a				ret 
143a			 
143a			 
143a			;    free block marker 
143a			;    requested size  
143a			;    pointer to next block 
143a			;    .... 
143a			;    next block marker 
143a			 
143a			 
143a			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
143a			; 
143a			 
143a			 
143a			malloc:  
143a				push de 
143a				push bc 
143a				push af 
143a			 
143a				; hl space required 
143a				 
143a				ld c, l    ; hold space   (TODO only a max of 255) 
143a			 
143a			;	inc c     ; TODO BUG need to fix memory leak on push str 
143a			;	inc c 
143a			;	inc c 
143a			;	inc c 
143a			;	inc c 
143a			;	inc c 
143a			;	inc c 
143a			 
143a			 
143a			 
143a				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
143a			 
143a				ld a, (free_list+3) 
143a				cp 0 
143a				jr z, .contheap 
143a			 
143a				ld hl, (free_list)     ; get last alloc 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "mrs" 
143a						CALLMONITOR 
143a					endif 
143a				jr .startalloc 
143a			 
143a			.contheap: 
143a				ld hl, heap_start 
143a			 
143a			.startalloc: 
143a			 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "mym" 
143a						CALLMONITOR 
143a					endif 
143a			.findblock: 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "mmf" 
143a						CALLMONITOR 
143a					endif 
143a			 
143a				ld a,(hl)  
143a				; if byte is zero then clear to use 
143a			 
143a				cp 0 
143a				jr z, .foundemptyblock 
143a			 
143a				; if byte is not clear 
143a				;     then byte is offset to next block 
143a			 
143a				inc hl 
143a				ld a, (hl) ; get size 
143a			.nextblock:	inc hl 
143a					ld e, (hl) 
143a					inc hl 
143a					ld d, (hl) 
143a					ex de, hl 
143a			;	inc hl  ; move past the store space 
143a			;	inc hl  ; move past zero index  
143a			 
143a				; TODO detect no more space 
143a			 
143a				push hl 
143a				ld de, heap_end 
143a				call cmp16 
143a				pop hl 
143a				jr nc, .nospace 
143a			 
143a				jr .findblock 
143a			 
143a			.nospace: ld hl, 0 
143a				jp .exit 
143a			 
143a			 
143a			.foundemptyblock:	 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "mme" 
143a						CALLMONITOR 
143a					endif 
143a			 
143a			; TODO has block enough space if reusing??? 
143a			 
143a				;  
143a			 
143a			; see if this block has been previously used 
143a				inc hl 
143a				ld a, (hl) 
143a				dec hl 
143a				cp 0 
143a				jr z, .newblock 
143a			 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "meR" 
143a						CALLMONITOR 
143a					endif 
143a			 
143a			; no reusing previously allocated block 
143a			 
143a			; is it smaller than previously used? 
143a				 
143a				inc hl    ; move to size 
143a				ld a, c 
143a				sub (hl)        ; we want c < (hl) 
143a				dec hl    ; move back to marker 
143a			        jr z, .findblock 
143a			 
143a				; update with the new size which should be lower 
143a			 
143a			        ;inc  hl   ; negate next move. move back to size  
143a			 
143a			.newblock: 
143a				; need to be at marker here 
143a			 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "meN" 
143a						CALLMONITOR 
143a					endif 
143a			 
143a			 
143a				ld a, c 
143a			 
143a				ld (free_list+3), a	 ; flag resume from last malloc  
143a				ld (free_list), hl    ; save out last location 
143a			 
143a			 
143a				;inc a     ; space for length byte 
143a				ld (hl), a     ; save block in use marker 
143a			 
143a				inc hl   ; move to space marker 
143a				ld (hl), a    ; save new space 
143a			 
143a				inc hl   ; move to start of allocated area 
143a				 
143a			;	push hl     ; save where we are - 1  
143a			 
143a			;	inc hl  ; move past zero index  
143a				; skip space to set down new marker 
143a			 
143a				; provide some extra space for now 
143a			 
143a				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
143a				inc a 
143a				inc a 
143a			 
143a				push hl   ; save where we are in the node block 
143a			 
143a				call addatohl 
143a			 
143a				; write linked list point 
143a			 
143a				pop de     ; get our node position 
143a				ex de, hl 
143a			 
143a				ld (hl), e 
143a				inc hl 
143a				ld (hl), d 
143a			 
143a				inc hl 
143a			 
143a				; now at start of allocated data so save pointer 
143a			 
143a				push hl 
143a			 
143a				; jump to position of next node and setup empty header in DE 
143a			 
143a				ex de, hl 
143a			 
143a			;	inc hl ; move past end of block 
143a			 
143a				ld a, 0 
143a				ld (hl), a   ; empty marker 
143a				inc hl 
143a				ld (hl), a   ; size 
143a				inc hl  
143a				ld (hl), a   ; ptr 
143a				inc hl 
143a				ld (hl), a   ; ptr 
143a			 
143a			 
143a				pop hl 
143a			 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "mmr" 
143a						CALLMONITOR 
143a					endif 
143a			 
143a			.exit: 
143a				pop af 
143a				pop bc 
143a				pop de  
143a				ret 
143a			 
143a			 
143a			 
143a			 
143a			free:  
143a				push hl 
143a				push af 
143a				; get address in hl 
143a			 
143a					if DEBUG_FORTH_MALLOC_INT 
143a						DMARK "fre" 
143a						CALLMONITOR 
143a					endif 
143a				; data is at hl - move to block count 
143a				dec hl 
143a				dec hl    ; get past pointer 
143a				dec hl 
143a			 
143a				ld a, (hl)    ; need this for a validation check 
143a			 
143a				dec hl    ; move to block marker 
143a			 
143a				; now check that the block count and block marker are the same  
143a			        ; this checks that we are on a malloc node and not random memory 
143a			        ; OK a faint chance this could be a problem but rare - famous last words! 
143a			 
143a				ld c, a 
143a				ld a, (hl)    
143a			 
143a				cp c 
143a				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
143a			 
143a				; yes good chance we are on a malloc node 
143a			 
143a				ld a, 0      
143a				ld (hl), a   ; mark as free 
143a			 
143a				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
143a			 
143a			.freeignore:  
143a			 
143a				pop af 
143a				pop hl 
143a			 
143a				ret 
143a			 
143a			 
143a			 
143a			endif 
143a			 
143a			; eof 
# End of file firmware_memory.asm
143a			  
143a			; device C  
143a			if SOUND_ENABLE  
143a				include "firmware_sound.asm"  
143a			endif  
143a			  
143a			include "firmware_diags.asm"  
143a			; Hardware diags menu 
143a			 
143a			 
143a			config: 
143a			 
143a 3e 00			ld a, 0 
143c 21 6a 14			ld hl, .configmn 
143f cd d7 0b			call menu 
1442			 
1442 fe 00			cp 0 
1444 c8				ret z 
1445			 
1445 fe 01			cp 1 
1447 cc 43 15			call z, .savetostore 
144a			 
144a fe 02			cp 2 
144c cc 91 14			call z, .selautoload 
144f fe 03			cp 3 
1451 cc 7a 14			call z, .disautoload 
1454 fe 04			cp 4 
1456 cc 41 15			call z, .selbank 
1459 fe 05			cp 5 
145b cc 1e 16			call z, .debug_tog 
145e fe 06			cp 6 
1460 cc 61 17			call z, .bpsgo 
1463 fe 07			cp 7 
1465 cc 44 16			call z, hardware_diags 
1468			 
1468 18 d0			jr config 
146a			 
146a			.configmn: 
146a 52 19			dw prom_c3 
146c 69 19			dw prom_c2 
146e 7e 19			dw prom_c2a 
1470 94 19			dw prom_c2b 
1472			;	dw prom_c4 
1472 b1 19			dw prom_m4 
1474 cc 19			dw prom_m4b 
1476 d4 19			dw prom_c1 
1478 00 00			dw 0 
147a				 
147a			 
147a			 
147a			 
147a			.disautoload: 
147a				if STORAGE_SE 
147a 3e fe			ld a, $fe      ; bit 0 clear 
147c 32 c5 fc			ld (spi_device), a 
147f			 
147f cd 69 04			call storage_get_block_0 
1482			 
1482 3e 00			ld a, 0 
1484 32 00 fd			ld (store_page+STORE_0_AUTOFILE), a 
1487			 
1487 21 00 00				ld hl, 0 
148a 11 df fc				ld de, store_page 
148d cd 1d 04			call storage_write_block	 ; save update 
1490				else 
1490			 
1490				ld hl, prom_notav 
1490				ld de, prom_empty 
1490				call info_panel 
1490				endif 
1490			 
1490			 
1490 c9				ret 
1491			 
1491			 
1491			 
1491			; Select auto start 
1491			 
1491			.selautoload: 
1491			 
1491				 
1491				if STORAGE_SE 
1491			 
1491 cd 68 15				call config_dir 
1494 21 5a f4			        ld hl, scratch 
1497 3e 00				ld a, 0 
1499 cd d7 0b				call menu 
149c			 
149c fe 00				cp 0 
149e c8					ret z 
149f			 
149f 3d					dec a 
14a0			 
14a0			 
14a0					; locate menu option 
14a0			 
14a0 21 5a f4				ld hl, scratch 
14a3 cd fb 0a				call table_lookup 
14a6			 
14a6					if DEBUG_FORTH_WORDS 
14a6						DMARK "ALl" 
14a6 f5				push af  
14a7 3a bb 14			ld a, (.dmark)  
14aa 32 b4 fe			ld (debug_mark),a  
14ad 3a bc 14			ld a, (.dmark+1)  
14b0 32 b5 fe			ld (debug_mark+1),a  
14b3 3a bd 14			ld a, (.dmark+2)  
14b6 32 b6 fe			ld (debug_mark+2),a  
14b9 18 03			jr .pastdmark  
14bb ..			.dmark: db "ALl"  
14be f1			.pastdmark: pop af  
14bf			endm  
# End of macro DMARK
14bf						CALLMONITOR 
14bf cd 57 17			call break_point_state  
14c2				endm  
# End of macro CALLMONITOR
14c2					endif 
14c2					; with the pointer to the menu it, the byte following the zero term is the file id 
14c2			 
14c2 3e 00				ld a, 0 
14c4 01 32 00				ld bc, 50   ; max of bytes to look at 
14c7 ed b1				cpir  
14c9			 
14c9					if DEBUG_FORTH_WORDS 
14c9						DMARK "ALb" 
14c9 f5				push af  
14ca 3a de 14			ld a, (.dmark)  
14cd 32 b4 fe			ld (debug_mark),a  
14d0 3a df 14			ld a, (.dmark+1)  
14d3 32 b5 fe			ld (debug_mark+1),a  
14d6 3a e0 14			ld a, (.dmark+2)  
14d9 32 b6 fe			ld (debug_mark+2),a  
14dc 18 03			jr .pastdmark  
14de ..			.dmark: db "ALb"  
14e1 f1			.pastdmark: pop af  
14e2			endm  
# End of macro DMARK
14e2						CALLMONITOR 
14e2 cd 57 17			call break_point_state  
14e5				endm  
# End of macro CALLMONITOR
14e5					endif 
14e5					;inc hl 
14e5			 
14e5 7e					ld a, (hl)   ; file id 
14e6					 
14e6				        ; save bank and file ids 
14e6			 
14e6 f5					push af 
14e7			 
14e7			; TODO need to save to block 0 on bank 1	 
14e7			 
14e7 cd 69 04				call storage_get_block_0 
14ea			 
14ea					if DEBUG_FORTH_WORDS 
14ea						DMARK "AL0" 
14ea f5				push af  
14eb 3a ff 14			ld a, (.dmark)  
14ee 32 b4 fe			ld (debug_mark),a  
14f1 3a 00 15			ld a, (.dmark+1)  
14f4 32 b5 fe			ld (debug_mark+1),a  
14f7 3a 01 15			ld a, (.dmark+2)  
14fa 32 b6 fe			ld (debug_mark+2),a  
14fd 18 03			jr .pastdmark  
14ff ..			.dmark: db "AL0"  
1502 f1			.pastdmark: pop af  
1503			endm  
# End of macro DMARK
1503						CALLMONITOR 
1503 cd 57 17			call break_point_state  
1506				endm  
# End of macro CALLMONITOR
1506					endif 
1506 f1					pop af 
1507			 
1507 32 03 fd				ld (store_page+STORE_0_FILERUN),a 
150a					 
150a					; save bank id 
150a			 
150a 3a c5 fc				ld a,(spi_device) 
150d 32 02 fd				ld (store_page+STORE_0_BANKRUN),a 
1510			 
1510					; enable auto run of store file 
1510			 
1510 3e 01				ld a, 1 
1512 32 00 fd				ld (store_page+STORE_0_AUTOFILE),a 
1515			 
1515					; save buffer 
1515			 
1515 21 00 00				ld hl, 0 
1518 11 df fc				ld de, store_page 
151b					if DEBUG_FORTH_WORDS 
151b						DMARK "ALw" 
151b f5				push af  
151c 3a 30 15			ld a, (.dmark)  
151f 32 b4 fe			ld (debug_mark),a  
1522 3a 31 15			ld a, (.dmark+1)  
1525 32 b5 fe			ld (debug_mark+1),a  
1528 3a 32 15			ld a, (.dmark+2)  
152b 32 b6 fe			ld (debug_mark+2),a  
152e 18 03			jr .pastdmark  
1530 ..			.dmark: db "ALw"  
1533 f1			.pastdmark: pop af  
1534			endm  
# End of macro DMARK
1534						CALLMONITOR 
1534 cd 57 17			call break_point_state  
1537				endm  
# End of macro CALLMONITOR
1537					endif 
1537 cd 1d 04			call storage_write_block	 ; save update 
153a			  
153a			 
153a			 
153a			 
153a 21 5a f4				ld hl, scratch 
153d cd 55 15				call config_fdir 
1540			 
1540				else 
1540			 
1540				ld hl, prom_notav 
1540				ld de, prom_empty 
1540				call info_panel 
1540			 
1540				endif 
1540 c9				ret 
1541			 
1541			 
1541			 
1541			; Select storage bank 
1541			 
1541			.selbank: 
1541			 
1541				if STORAGE_SE 
1541				else 
1541			 
1541				ld hl, prom_notav 
1541				ld de, prom_empty 
1541				call info_panel 
1541				endif 
1541				 
1541 c9				ret 
1542			 
1542			if STORAGE_SE 
1542			 
1542			.config_ldir:   
1542				; Load storage bank labels into menu array 
1542			 
1542				 
1542			 
1542			 
1542 c9				ret 
1543			 
1543			 
1543			endif 
1543			 
1543			 
1543			; Save user words to storage 
1543			 
1543			.savetostore: 
1543			 
1543				if STORAGE_SE 
1543			 
1543 cd 68 15				call config_dir 
1546 21 5a f4			        ld hl, scratch 
1549 3e 00				ld a, 0 
154b cd d7 0b				call menu 
154e					 
154e 21 5a f4				ld hl, scratch 
1551 cd 55 15				call config_fdir 
1554			 
1554				else 
1554			 
1554				ld hl, prom_notav 
1554				ld de, prom_empty 
1554				call info_panel 
1554			 
1554				endif 
1554			 
1554 c9				ret 
1555			 
1555			 
1555			 
1555			if STORAGE_SE 
1555			 
1555			config_fdir: 
1555				; using the scratch dir go through and release the memory allocated for each string 
1555				 
1555 21 5a f4			ld hl, scratch 
1558 5e			.cfdir:	ld e,(hl) 
1559 23				inc hl 
155a 56				ld d,(hl) 
155b 23				inc hl 
155c			 
155c eb				ex de, hl 
155d cd 03 0e			call ishlzero 
1560 c8				ret z     ; return on null pointer 
1561 cd 6b 13			call free 
1564 eb				ex de, hl 
1565 18 f1			jr .cfdir 
1567			 
1567			 
1567 c9				ret 
1568			 
1568			 
1568			config_dir: 
1568			 
1568				; for the config menus that need to build a directory of storage call this routine 
1568				; it will construct a menu in scratch to pass to menu 
1568			 
1568				; open storage device 
1568			 
1568				; execute DIR to build a list of files and their ids into scratch in menu format 
1568				; once the menu has finished then will need to call config_fdir to release the strings 
1568				 
1568				; c = number items 
1568			 
1568				 
1568 cd 69 04			call storage_get_block_0 
156b			 
156b 21 df fc			ld hl, store_page     ; get current id count 
156e 46				ld b, (hl) 
156f 0e 00			ld c, 0    ; count of files   
1571			 
1571			 
1571 21 5a f4			ld hl, scratch 
1574 22 db fc			ld (store_tmp2), hl    ; location to poke strings 
1577			 
1577				; check for empty drive 
1577			 
1577 3e 00			ld a, 0 
1579 b8				cp b 
157a ca 14 16			jp z, .dirdone 
157d			 
157d				 
157d					if DEBUG_FORTH_WORDS 
157d						DMARK "Cdc" 
157d f5				push af  
157e 3a 92 15			ld a, (.dmark)  
1581 32 b4 fe			ld (debug_mark),a  
1584 3a 93 15			ld a, (.dmark+1)  
1587 32 b5 fe			ld (debug_mark+1),a  
158a 3a 94 15			ld a, (.dmark+2)  
158d 32 b6 fe			ld (debug_mark+2),a  
1590 18 03			jr .pastdmark  
1592 ..			.dmark: db "Cdc"  
1595 f1			.pastdmark: pop af  
1596			endm  
# End of macro DMARK
1596						CALLMONITOR 
1596 cd 57 17			call break_point_state  
1599				endm  
# End of macro CALLMONITOR
1599					endif 
1599			 
1599			 
1599			.diritem:	 
1599 c5				push bc 
159a				; for each of the current ids do a search for them and if found push to stack 
159a			 
159a 21 40 00				ld hl, STORE_BLOCK_PHY 
159d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
159f 58					ld e,b 
15a0			 
15a0 cd eb 06				call storage_findnextid 
15a3			 
15a3			 
15a3					; if found hl will be non zero 
15a3			 
15a3 cd 03 0e				call ishlzero 
15a6 28 69				jr z, .dirnotfound 
15a8			 
15a8					; increase count 
15a8			 
15a8 c1					pop bc	 
15a9 0c					inc c 
15aa c5					push bc 
15ab					 
15ab			 
15ab					; get file header and push the file name 
15ab			 
15ab 11 df fc				ld de, store_page 
15ae cd b8 03				call storage_read_block 
15b1			 
15b1					; push file id to stack 
15b1				 
15b1 3a df fc				ld a, (store_page) 
15b4 26 00				ld h, 0 
15b6 6f					ld l, a 
15b7			 
15b7					;call forth_push_numhl 
15b7					; TODO store id 
15b7			 
15b7 e5					push hl 
15b8			 
15b8					; push extent count to stack  
15b8				 
15b8 21 e2 fc				ld hl, store_page+3 
15bb			 
15bb					; get file name length 
15bb			 
15bb cd 38 12				call strlenz   
15be			 
15be 23					inc hl   ; cover zero term 
15bf 23					inc hl  ; stick the id at the end of the area 
15c0			 
15c0 e5					push hl 
15c1 c1					pop bc    ; move length to bc 
15c2			 
15c2 cd a1 12				call malloc 
15c5			 
15c5					; TODO save malloc area to scratch 
15c5			 
15c5 eb					ex de, hl 
15c6 2a db fc				ld hl, (store_tmp2) 
15c9 73					ld (hl), e 
15ca 23					inc hl 
15cb 72					ld (hl), d 
15cc 23					inc hl 
15cd 22 db fc				ld (store_tmp2), hl 
15d0			 
15d0					 
15d0			 
15d0					;pop hl   ; get source 
15d0			;		ex de, hl    ; swap aronund	 
15d0			 
15d0 21 e2 fc				ld hl, store_page+3 
15d3					if DEBUG_FORTH_WORDS 
15d3						DMARK "CFd" 
15d3 f5				push af  
15d4 3a e8 15			ld a, (.dmark)  
15d7 32 b4 fe			ld (debug_mark),a  
15da 3a e9 15			ld a, (.dmark+1)  
15dd 32 b5 fe			ld (debug_mark+1),a  
15e0 3a ea 15			ld a, (.dmark+2)  
15e3 32 b6 fe			ld (debug_mark+2),a  
15e6 18 03			jr .pastdmark  
15e8 ..			.dmark: db "CFd"  
15eb f1			.pastdmark: pop af  
15ec			endm  
# End of macro DMARK
15ec						CALLMONITOR 
15ec cd 57 17			call break_point_state  
15ef				endm  
# End of macro CALLMONITOR
15ef					endif 
15ef ed b0				ldir 
15f1			 
15f1					; de is past string, move back one and store id 
15f1					 
15f1 1b					dec de 
15f2			 
15f2					; store file id 
15f2			 
15f2 e1					pop hl 
15f3 eb					ex de,hl 
15f4 73					ld (hl), e 
15f5			 
15f5					if DEBUG_FORTH_WORDS 
15f5						DMARK "Cdi" 
15f5 f5				push af  
15f6 3a 0a 16			ld a, (.dmark)  
15f9 32 b4 fe			ld (debug_mark),a  
15fc 3a 0b 16			ld a, (.dmark+1)  
15ff 32 b5 fe			ld (debug_mark+1),a  
1602 3a 0c 16			ld a, (.dmark+2)  
1605 32 b6 fe			ld (debug_mark+2),a  
1608 18 03			jr .pastdmark  
160a ..			.dmark: db "Cdi"  
160d f1			.pastdmark: pop af  
160e			endm  
# End of macro DMARK
160e						CALLMONITOR 
160e cd 57 17			call break_point_state  
1611				endm  
# End of macro CALLMONITOR
1611					endif 
1611					 
1611			.dirnotfound: 
1611 c1					pop bc     
1612 10 85				djnz .diritem 
1614				 
1614			.dirdone:	 
1614			 
1614 3e 00				ld a, 0 
1616 2a db fc				ld hl, (store_tmp2) 
1619 77					ld (hl), a 
161a 23					inc hl 
161b 77					ld (hl), a 
161c 23					inc hl 
161d					; push a count of the dir items found 
161d			 
161d			;		ld h, 0 
161d			;		ld l, c 
161d			 
161d c9				ret 
161e			 
161e			endif 
161e			 
161e			 
161e			; Settings 
161e			; Run  
161e			 
161e			 
161e			 
161e			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
161e			;;hd_menu2:   db "        2: Editor",0   
161e			;hd_menu2:   db "        2: Editor       6: Menu",0   
161e			;hd_menu3:   db "        3: Storage",0 
161e			;hd_menu4:   db "0=quit  4: Debug",0 
161e			;hd_don:     db "ON",0 
161e			;hd_doff:     db "OFF",0 
161e			; 
161e			; 
161e			; 
161e			;hardware_diags_old:       
161e			; 
161e			;.diagmenu: 
161e			;	call clear_display 
161e			;	ld a, display_row_1 
161e			;	ld de, hd_menu1 
161e			;	call str_at_display 
161e			; 
161e			;	ld a, display_row_2 
161e			;	ld de, hd_menu2 
161e			;	call str_at_display 
161e			; 
161e			;	ld a, display_row_3 
161e			;	ld de, hd_menu3 
161e			;	call str_at_display 
161e			; 
161e			;	ld a,  display_row_4 
161e			;	ld de, hd_menu4 
161e			;	call str_at_display 
161e			; 
161e			;	; display debug state 
161e			; 
161e			;	ld de, hd_don 
161e			;	ld a, (os_view_disable) 
161e			;	cp 0 
161e			;	jr z, .distog 
161e			;	ld de, hd_doff 
161e			;.distog: ld a, display_row_4+17 
161e			;	call str_at_display 
161e			; 
161e			;	call update_display 
161e			; 
161e			;	call cin_wait 
161e			; 
161e			; 
161e			; 
161e			;	cp '4' 
161e			;	jr nz, .diagn1 
161e			; 
161e			;	; debug toggle 
161e			; 
161e			;	ld a, (os_view_disable) 
161e			;	ld b, '*' 
161e			;	cp 0 
161e			;	jr z, .debtog 
161e			;	ld b, 0 
161e			;.debtog:	 
161e			;	ld a,b 
161e			;	ld (os_view_disable),a 
161e			; 
161e			;.diagn1: cp '0' 
161e			;	 ret z 
161e			; 
161e			;;	cp '1' 
161e			;;       jp z, matrix	 
161e			;;   TODO keyboard matrix test 
161e			; 
161e			;	cp '2' 
161e			;	jp z, .diagedit 
161e			; 
161e			;;	cp '6' 
161e			;;	jp z, .menutest 
161e			;;if ENABLE_BASIC 
161e			;;	cp '6' 
161e			;;	jp z, basic 
161e			;;endif 
161e			 ; 
161e			;	jp .diagmenu 
161e			; 
161e			; 
161e			;	ret 
161e			 
161e			 
161e			.debug_tog: 
161e 21 65 16			ld hl, .menudebug 
1621				 
1621 3a 4b f4			ld a, (os_view_disable) 
1624 fe 2a			cp '*' 
1626 20 04			jr nz,.tdon  
1628 3e 01			ld a, 1 
162a 18 02			jr .tog1 
162c 3e 00		.tdon: ld a, 0 
162e			 
162e			.tog1: 
162e cd d7 0b			call menu 
1631 fe 00			cp 0 
1633 c8				ret z 
1634 fe 01			cp 1    ; disable debug 
1636 28 04			jr z, .dtog0 
1638 3e 2a			ld a, '*' 
163a 18 02			jr .dtogset 
163c 3e 00		.dtog0: ld a, 0 
163e 32 4b f4		.dtogset:  ld (os_view_disable), a 
1641 c3 1e 16			jp .debug_tog 
1644			 
1644			 
1644			hardware_diags:       
1644			 
1644			.diagm: 
1644 21 57 16			ld hl, .menuitems 
1647 3e 00			ld a, 0 
1649 cd d7 0b			call menu 
164c			 
164c fe 00		         cp 0 
164e c8				 ret z 
164f			 
164f fe 02			cp 2 
1651 ca b0 16			jp z, .diagedit 
1654			 
1654			;	cp '6' 
1654			;	jp z, .menutest 
1654			;if ENABLE_BASIC 
1654			;	cp '6' 
1654			;	jp z, basic 
1654			;endif 
1654			  
1654 c3 44 16			jp .diagm 
1657			 
1657				 
1657 6b 16		.menuitems:   	dw .m1 
1659 76 16				dw .m2 
165b 7d 16				dw .m3 
165d 85 16				dw .m5 
165f 8b 16				dw .m5a 
1661 94 16				dw .m5b 
1663 00 00				dw 0 
1665			 
1665			.menudebug: 
1665 9d 16				dw .m6 
1667 a6 16				dw .m7 
1669 00 00				dw 0 
166b			 
166b .. 00		.m1:   db "Key Matrix",0 
1676 .. 00		.m2:   db "Editor",0 
167d .. 00		.m3:   db "Storage",0 
1685 .. 00		.m5:   db "Sound",0 
168b .. 00		.m5a:  db "RAM Test",0 
1694 .. 00		.m5b:  db "LCD Test",0 
169d			 
169d .. 00		.m6:   db "Debug ON",0 
16a6 .. 00		.m7:   db "Debug OFF",0 
16b0			 
16b0			; debug editor 
16b0			 
16b0			.diagedit: 
16b0			 
16b0 21 5a f4			ld hl, scratch 
16b3			;	ld bc, 250 
16b3			;	ldir 
16b3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16b3 3e 00			ld a, 0 
16b5 77				ld (hl), a 
16b6 23				inc hl 
16b7 77				ld (hl), a 
16b8 23				inc hl 
16b9 77				ld (hl), a 
16ba			 
16ba cd a6 0b		        call clear_display 
16bd cd c9 0b			call update_display 
16c0				;ld a, 1 
16c0				;ld (hardware_diag), a 
16c0			.diloop: 
16c0 3e 00			ld a, display_row_1 
16c2 0e 00			ld c, 0 
16c4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16c6 1e 28			ld e, 40 
16c8			 
16c8 21 5a f4			ld hl, scratch	 
16cb cd 07 0e			call input_str 
16ce			 
16ce 3e 14			ld a, display_row_2 
16d0 11 5a f4			ld de, scratch 
16d3 cd b9 0b			call str_at_display 
16d6 cd c9 0b			call update_display 
16d9			 
16d9 c3 c0 16			jp .diloop 
16dc			 
16dc			 
16dc			; pass word in hl 
16dc			; a has display location 
16dc			display_word_at: 
16dc f5				push af 
16dd e5				push hl 
16de 7c				ld a,h 
16df 21 5f f7			ld hl, os_word_scratch 
16e2 cd db 10			call hexout 
16e5 e1				pop hl 
16e6 7d				ld a,l 
16e7 21 61 f7			ld hl, os_word_scratch+2 
16ea cd db 10			call hexout 
16ed 21 63 f7			ld hl, os_word_scratch+4 
16f0 3e 00			ld a,0 
16f2 77				ld (hl),a 
16f3 11 5f f7			ld de,os_word_scratch 
16f6 f1				pop af 
16f7 cd b9 0b				call str_at_display 
16fa c9				ret 
16fb			 
16fb			display_ptr_state: 
16fb			 
16fb				; to restore afterwards 
16fb			 
16fb d5				push de 
16fc c5				push bc 
16fd e5				push hl 
16fe f5				push af 
16ff			 
16ff				; for use in here 
16ff			 
16ff			;	push bc 
16ff			;	push de 
16ff			;	push hl 
16ff			;	push af 
16ff			 
16ff cd a6 0b			call clear_display 
1702			 
1702 11 d5 18			ld de, .ptrstate 
1705 3e 00			ld a, display_row_1 
1707 cd b9 0b			call str_at_display 
170a			 
170a				; display debug step 
170a			 
170a			 
170a 11 b4 fe			ld de, debug_mark 
170d 3e 12			ld a, display_row_1+display_cols-2 
170f cd b9 0b			call str_at_display 
1712			 
1712				; display a 
1712 11 df 18			ld de, .ptrcliptr 
1715 3e 14			ld a, display_row_2 
1717 cd b9 0b			call str_at_display 
171a			 
171a f1				pop af 
171b 2a a5 fc			ld hl,(cli_ptr) 
171e 3e 1c			ld a, display_row_2+8 
1720 cd dc 16			call display_word_at 
1723			 
1723			 
1723				; display hl 
1723			 
1723			 
1723 11 e7 18			ld de, .ptrclioptr 
1726 3e 1e			ld a, display_row_2+10 
1728 cd b9 0b			call str_at_display 
172b			; 
172b			;	pop hl 
172b 3e 21			ld a, display_row_2+13 
172d 2a a3 fc			ld hl,(cli_origptr) 
1730 cd dc 16			call display_word_at 
1733			; 
1733			;	 
1733			;	; display de 
1733			 
1733			;	ld de, .regstatede 
1733			;	ld a, display_row_3 
1733			;	call str_at_display 
1733			 
1733			;	pop de 
1733			;	ld h,d 
1733			;	ld l, e 
1733			;	ld a, display_row_3+3 
1733			;	call display_word_at 
1733			 
1733			 
1733				; display bc 
1733			 
1733			;	ld de, .regstatebc 
1733			;	ld a, display_row_3+10 
1733			;	call str_at_display 
1733			 
1733			;	pop bc 
1733			;	ld h,b 
1733			;	ld l, c 
1733			;	ld a, display_row_3+13 
1733			;	call display_word_at 
1733			 
1733			 
1733				; display dsp 
1733			 
1733			;	ld de, .regstatedsp 
1733			;	ld a, display_row_4 
1733			;	call str_at_display 
1733			 
1733				 
1733			;	ld hl,(cli_data_sp) 
1733			;	ld a, display_row_4+4 
1733			;	call display_word_at 
1733			 
1733				; display rsp 
1733			 
1733 11 16 19			ld de, .regstatersp 
1736 3e 46			ld a, display_row_4+10 
1738 cd b9 0b			call str_at_display 
173b			 
173b				 
173b 2a 8b fc			ld hl,(cli_ret_sp) 
173e 3e 4a			ld a, display_row_4+14 
1740 cd dc 16			call display_word_at 
1743			 
1743 cd c9 0b			call update_display 
1746			 
1746 cd 23 0b			call delay1s 
1749 cd 23 0b			call delay1s 
174c cd 23 0b			call delay1s 
174f			 
174f			 
174f cd 2c 1d			call next_page_prompt 
1752			 
1752				; restore  
1752			 
1752 f1				pop af 
1753 e1				pop hl 
1754 c1				pop bc 
1755 d1				pop de 
1756 c9				ret 
1757			 
1757			break_point_state: 
1757 f5				push af 
1758			 
1758				; see if disabled 
1758			 
1758 3a 4b f4			ld a, (os_view_disable) 
175b fe 2a			cp '*' 
175d 20 02			jr nz, .bpsgo 
175f f1				pop af 
1760 c9				ret 
1761			 
1761			.bpsgo: 
1761 f1				pop af 
1762 f5				push af 
1763 22 47 f4			ld (os_view_hl), hl 
1766 ed 53 45 f4		ld (os_view_de), de 
176a ed 43 43 f4		ld (os_view_bc), bc 
176e e5				push hl 
176f 6f				ld l, a 
1770 26 00			ld h, 0 
1772 22 49 f4			ld (os_view_af),hl 
1775			 
1775 21 4a fe				ld hl, display_fb0 
1778 22 55 fd				ld (display_fb_active), hl 
177b e1				pop hl	 
177c			 
177c 3e 31			ld a, '1' 
177e fe 2a		.bps1:  cp '*' 
1780 20 03			jr nz, .bps1b 
1782 32 4b f4			ld (os_view_disable),a 
1785 fe 31		.bps1b:  cp '1' 
1787 20 14			jr nz, .bps2 
1789			 
1789				; display reg 
1789			 
1789				 
1789			 
1789 3a 49 f4			ld a, (os_view_af) 
178c 2a 47 f4			ld hl, (os_view_hl) 
178f ed 5b 45 f4		ld de, (os_view_de) 
1793 ed 4b 43 f4		ld bc, (os_view_bc) 
1797 cd 31 18			call display_reg_state 
179a c3 1d 18			jp .bpschk 
179d			 
179d fe 32		.bps2:  cp '2' 
179f 20 08			jr nz, .bps3 
17a1				 
17a1				; display hl 
17a1 2a 47 f4			ld hl, (os_view_hl) 
17a4 cd 1b 19			call display_dump_at_hl 
17a7			 
17a7 18 74			jr .bpschk 
17a9			 
17a9 fe 33		.bps3:  cp '3' 
17ab 20 08			jr nz, .bps4 
17ad			 
17ad			        ; display de 
17ad 2a 45 f4			ld hl, (os_view_de) 
17b0 cd 1b 19			call display_dump_at_hl 
17b3			 
17b3 18 68			jr .bpschk 
17b5 fe 34		.bps4:  cp '4' 
17b7 20 08			jr nz, .bps5 
17b9			 
17b9			        ; display bc 
17b9 2a 43 f4			ld hl, (os_view_bc) 
17bc cd 1b 19			call display_dump_at_hl 
17bf			 
17bf 18 5c			jr .bpschk 
17c1 fe 35		.bps5:  cp '5' 
17c3 20 08		        jr nz, .bps7 
17c5			 
17c5				; display cur ptr 
17c5 2a a5 fc			ld hl, (cli_ptr) 
17c8 cd 1b 19			call display_dump_at_hl 
17cb			 
17cb 18 50			jr .bpschk 
17cd fe 36		.bps7:  cp '6' 
17cf 20 08			jr nz, .bps8b 
17d1				 
17d1				; display cur orig ptr 
17d1 2a a3 fc			ld hl, (cli_origptr) 
17d4 cd 1b 19			call display_dump_at_hl 
17d7 18 44			jr .bpschk 
17d9 fe 37		.bps8b:  cp '7' 
17db 20 08			jr nz, .bps9 
17dd				 
17dd				; display dsp 
17dd 2a 87 fc			ld hl, (cli_data_sp) 
17e0 cd 1b 19			call display_dump_at_hl 
17e3			 
17e3 18 38			jr .bpschk 
17e5 fe 39		.bps9:  cp '9' 
17e7 20 05			jr nz, .bps8c 
17e9				 
17e9				; display SP 
17e9			;	ld hl, sp 
17e9 cd 1b 19			call display_dump_at_hl 
17ec			 
17ec 18 2f			jr .bpschk 
17ee fe 38		.bps8c:  cp '8' 
17f0 20 08			jr nz, .bps8d 
17f2				 
17f2				; display rsp 
17f2 2a 8b fc			ld hl, (cli_ret_sp) 
17f5 cd 1b 19			call display_dump_at_hl 
17f8			 
17f8 18 23			jr .bpschk 
17fa fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17fc 20 05			jr nz, .bps8 
17fe cd 22 1b			call monitor 
1801			 
1801 18 1a			jr .bpschk 
1803 fe 30		.bps8:  cp '0' 
1805 20 16			jr nz, .bpschk 
1807			 
1807 21 f9 fd				ld hl, display_fb1 
180a 22 55 fd				ld (display_fb_active), hl 
180d cd c9 0b				call update_display 
1810			 
1810				;ld a, (os_view_af) 
1810 2a 47 f4			ld hl, (os_view_hl) 
1813 ed 5b 45 f4		ld de, (os_view_de) 
1817 ed 4b 43 f4		ld bc, (os_view_bc) 
181b f1				pop af 
181c c9				ret 
181d			 
181d			.bpschk:   
181d cd 23 0b			call delay1s 
1820 3e 4f		ld a,display_row_4 + display_cols - 1 
1822 11 2a 1d		        ld de, endprg 
1825 cd b9 0b			call str_at_display 
1828 cd c9 0b			call update_display 
182b cd 21 69			call cin_wait 
182e			 
182e c3 7e 17			jp .bps1 
1831			 
1831			 
1831			display_reg_state: 
1831			 
1831				; to restore afterwards 
1831			 
1831 d5				push de 
1832 c5				push bc 
1833 e5				push hl 
1834 f5				push af 
1835			 
1835				; for use in here 
1835			 
1835 c5				push bc 
1836 d5				push de 
1837 e5				push hl 
1838 f5				push af 
1839			 
1839 cd a6 0b			call clear_display 
183c			 
183c 11 f1 18			ld de, .regstate 
183f 3e 00			ld a, display_row_1 
1841 cd b9 0b			call str_at_display 
1844			 
1844				; display debug step 
1844			 
1844			 
1844 11 b4 fe			ld de, debug_mark 
1847 3e 11			ld a, display_row_1+display_cols-3 
1849 cd b9 0b			call str_at_display 
184c			 
184c				; display a 
184c 11 0d 19			ld de, .regstatea 
184f 3e 14			ld a, display_row_2 
1851 cd b9 0b			call str_at_display 
1854			 
1854 e1				pop hl 
1855			;	ld h,0 
1855			;	ld l, a 
1855 3e 17			ld a, display_row_2+3 
1857 cd dc 16			call display_word_at 
185a			 
185a			 
185a				; display hl 
185a			 
185a			 
185a 11 01 19			ld de, .regstatehl 
185d 3e 1e			ld a, display_row_2+10 
185f cd b9 0b			call str_at_display 
1862			 
1862 e1				pop hl 
1863 3e 21			ld a, display_row_2+13 
1865 cd dc 16			call display_word_at 
1868			 
1868				 
1868				; display de 
1868			 
1868 11 05 19			ld de, .regstatede 
186b 3e 28			ld a, display_row_3 
186d cd b9 0b			call str_at_display 
1870			 
1870 e1				pop hl 
1871			;	ld h,d 
1871			;	ld l, e 
1871 3e 2b			ld a, display_row_3+3 
1873 cd dc 16			call display_word_at 
1876			 
1876			 
1876				; display bc 
1876			 
1876 11 09 19			ld de, .regstatebc 
1879 3e 32			ld a, display_row_3+10 
187b cd b9 0b			call str_at_display 
187e			 
187e e1				pop hl 
187f			;	ld h,b 
187f			;	ld l, c 
187f 3e 35			ld a, display_row_3+13 
1881 cd dc 16			call display_word_at 
1884			 
1884			 
1884				; display dsp 
1884			 
1884 11 11 19			ld de, .regstatedsp 
1887 3e 3c			ld a, display_row_4 
1889 cd b9 0b			call str_at_display 
188c			 
188c				 
188c 2a 87 fc			ld hl,(cli_data_sp) 
188f 3e 40			ld a, display_row_4+4 
1891 cd dc 16			call display_word_at 
1894			 
1894				; display rsp 
1894			 
1894 11 16 19			ld de, .regstatersp 
1897 3e 46			ld a, display_row_4+10 
1899 cd b9 0b			call str_at_display 
189c			 
189c				 
189c 2a 8b fc			ld hl,(cli_ret_sp) 
189f 3e 4a			ld a, display_row_4+14 
18a1 cd dc 16			call display_word_at 
18a4			 
18a4 cd c9 0b			call update_display 
18a7			 
18a7			;	call delay1s 
18a7			;	call delay1s 
18a7			;	call delay1s 
18a7			 
18a7			 
18a7			;	call next_page_prompt 
18a7			 
18a7				; restore  
18a7			 
18a7 f1				pop af 
18a8 e1				pop hl 
18a9 c1				pop bc 
18aa d1				pop de 
18ab c9				ret 
18ac			 
18ac .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18c0 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18d5 .. 00		.ptrstate:	db "Ptr State",0 
18df .. 00		.ptrcliptr:     db "cli_ptr",0 
18e7 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18f1 .. 00		.regstate:	db "Reg State (1/0)",0 
1901 .. 00		.regstatehl:	db "HL:",0 
1905 .. 00		.regstatede:	db "DE:",0 
1909 .. 00		.regstatebc:	db "BC:",0 
190d .. 00		.regstatea:	db "A :",0 
1911 .. 00		.regstatedsp:	db "DSP:",0 
1916 .. 00		.regstatersp:	db "RSP:",0 
191b			 
191b			display_dump_at_hl: 
191b e5				push hl 
191c d5				push de 
191d c5				push bc 
191e f5				push af 
191f			 
191f 22 7d f7			ld (os_cur_ptr),hl	 
1922 cd a6 0b			call clear_display 
1925 cd 34 1c			call dumpcont 
1928			;	call delay1s 
1928			;	call next_page_prompt 
1928			 
1928			 
1928 f1				pop af 
1929 c1				pop bc 
192a d1				pop de 
192b e1				pop hl 
192c c9				ret 
192d			 
192d			;if ENABLE_BASIC 
192d			;	include "nascombasic.asm" 
192d			;	basic: 
192d			;	include "forth/FORTH.ASM" 
192d			;endif 
192d			 
192d			; eof 
192d			 
192d			 
# End of file firmware_diags.asm
192d			  
192d			include "firmware_prompts.asm"  
192d			; Prompts  
192d			 
192d			; boot messages 
192d			 
192d .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1942 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1952			 
1952			 
1952			; config menus 
1952			 
1952 .. 00		prom_c3: db "Add Dictionary To File",0 
1969 .. 00		prom_c2: db "Select Autoload File",0 
197e .. 00		prom_c2a: db "Disable Autoload File", 0 
1994 .. 00		prom_c2b: db "Select Storage Bank",0 
19a8 .. 00		prom_c4: db "Settings",0 
19b1 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
19cc .. 00		prom_m4b:   db "Monitor",0 
19d4 .. 00		prom_c1: db "Hardware Diags",0 
19e3			 
19e3			 
19e3 .. 00		prom_notav:    db "Feature not available",0 
19f9 .. 00		prom_empty:    db "",0 
19fa			 
19fa			; eof 
19fa			 
# End of file firmware_prompts.asm
19fa			  
19fa			  
19fa			; eof  
19fa			  
# End of file firmware.asm
19fa			 
19fa			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
19fa			;if BASE_KEV  
19fa			;baseram: equ 08000h 
19fa			;endif 
19fa			 
19fa			;if BASE_SC114 
19fa			;baseram:     equ    endofcode 
19fa			;endif 
19fa			 
19fa			 
19fa			; start system 
19fa			 
19fa			coldstart: 
19fa				; set sp 
19fa				; di/ei 
19fa			 
19fa f3				di 
19fb 31 fd ff			ld sp, tos 
19fe			;	ei 
19fe			 
19fe			 
19fe				; disable breakpoint by default 
19fe			 
19fe 3e 2a			ld a,'*' 
1a00 32 4b f4			ld (os_view_disable),a 
1a03			 
1a03				; init hardware 
1a03			 
1a03				; init keyboard and screen hardware 
1a03			 
1a03 cd 03 00			call hardware_init 
1a06			 
1a06			 
1a06				; detect if any keys are held down to enable breakpoints at start up 
1a06			 
1a06 cd 32 69			call cin  
1a09 fe 00			cp 0 
1a0b 28 03			jr z, .nokeys 
1a0d			 
1a0d				;call hardware_diags 
1a0d cd 3a 14			call config 
1a10			 
1a10			;	ld de, .bpen 
1a10			;	ld a, display_row_4 
1a10			;	call str_at_display 
1a10			;	call update_display 
1a10			; 
1a10			;	ld a,0 
1a10			;	ld (os_view_disable),a 
1a10			; 
1a10			;.bpwait: 
1a10			;	call cin 
1a10			;	cp 0 
1a10			;	jr z, .bpwait 
1a10			;	jr .nokeys 
1a10			; 
1a10			; 
1a10			;.bpen:  db "Break points enabled!",0 
1a10			 
1a10			 
1a10			 
1a10			 
1a10			 
1a10			 
1a10			.nokeys: 
1a10			 
1a10			 
1a10				 
1a10			 
1a10			;jp  testkey 
1a10			 
1a10			;call storage_get_block_0 
1a10			; 
1a10			;ld hl, 0 
1a10			;ld de, store_page 
1a10			;call storage_read_block 
1a10			 
1a10				 
1a10			;ld hl, 10 
1a10			;ld de, store_page 
1a10			;call storage_read_block 
1a10			 
1a10			 
1a10			 
1a10			 
1a10			 
1a10			;stop:	nop 
1a10			;	jp stop 
1a10			 
1a10			 
1a10			 
1a10			main: 
1a10 cd a6 0b			call clear_display 
1a13 cd c9 0b			call update_display 
1a16			 
1a16			 
1a16			 
1a16			;	call testlcd 
1a16			 
1a16			 
1a16			 
1a16 cd f2 20			call forth_init 
1a19			 
1a19			 
1a19			warmstart: 
1a19 cd c8 20			call forth_warmstart 
1a1c			 
1a1c				; run startup word load 
1a1c			        ; TODO prevent this running at warmstart after crash  
1a1c			 
1a1c				if STARTUP_ENABLE 
1a1c					if STORAGE_SE 
1a1c cd 63 66					call forth_autoload 
1a1f					endif 
1a1f cd 72 63				call forth_startup 
1a22			 
1a22			 
1a22				endif 
1a22			 
1a22				; show free memory after boot 
1a22 11 bc 1a			ld de, freeram 
1a25 3e 00			ld a, display_row_1 
1a27 cd b9 0b			call str_at_display 
1a2a			 
1a2a			; Or use heap_size word???? 
1a2a 21 40 f4			ld hl, heap_end 
1a2d 11 0e 80			ld de, heap_start 
1a30 ed 52			sbc hl, de 
1a32 e5				push hl 
1a33 7c				ld a,h	         	 
1a34 21 5f f7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a37 cd db 10			call hexout 
1a3a e1			   	pop hl 
1a3b			 
1a3b 7d				ld a,l 
1a3c 21 61 f7			ld hl, os_word_scratch+2 
1a3f cd db 10			call hexout 
1a42 21 63 f7			ld hl, os_word_scratch+4 
1a45 3e 00			ld a, 0 
1a47 77				ld (hl),a 
1a48 11 5f f7			ld de, os_word_scratch 
1a4b 3e 0d			ld a, display_row_1 + 13 
1a4d cd b9 0b			call str_at_display 
1a50 cd c9 0b			call update_display 
1a53			 
1a53			 
1a53				;call demo 
1a53			 
1a53			 
1a53				; init scratch input area for cli commands 
1a53			 
1a53 21 81 f7			ld hl, os_cli_cmd 
1a56 3e 00			ld a,0 
1a58 77				ld (hl),a 
1a59 23				inc hl 
1a5a 77				ld (hl),a 
1a5b			 
1a5b 3e 00			ld a,0 
1a5d 32 80 f8			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1a60			 
1a60 32 7d f7			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1a63 32 7e f7			ld (os_cur_ptr+1),a	 
1a66			 
1a66 32 5f f7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1a69 32 60 f7			ld (os_word_scratch+1),a	 
1a6c				 
1a6c			 
1a6c				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a6c 21 81 f7			ld hl, os_cli_cmd 
1a6f			 
1a6f 3e 00			ld a, 0		 ; init cli input 
1a71 77				ld (hl), a 
1a72 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a74			cli: 
1a74				; show cli prompt 
1a74				;push af 
1a74				;ld a, 0 
1a74				;ld de, prompt 
1a74				;call str_at_display 
1a74			 
1a74				;call update_display 
1a74				;pop af 
1a74				;inc a 
1a74				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a74 0e 00			ld c, 0 
1a76 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1a78 1e 28			ld e, 40 
1a7a			 
1a7a 21 81 f7			ld hl, os_cli_cmd 
1a7d			 
1a7d				STACKFRAME OFF $fefe $9f9f 
1a7d				if DEBUG_STACK_IMB 
1a7d					if OFF 
1a7d						exx 
1a7d						ld de, $fefe 
1a7d						ld a, d 
1a7d						ld hl, curframe 
1a7d						call hexout 
1a7d						ld a, e 
1a7d						ld hl, curframe+2 
1a7d						call hexout 
1a7d						ld hl, $fefe 
1a7d						push hl 
1a7d						ld hl, $9f9f 
1a7d						push hl 
1a7d						exx 
1a7d					endif 
1a7d				endif 
1a7d			endm 
# End of macro STACKFRAME
1a7d			 
1a7d cd 07 0e			call input_str 
1a80			 
1a80				STACKFRAMECHK OFF $fefe $9f9f 
1a80				if DEBUG_STACK_IMB 
1a80					if OFF 
1a80						exx 
1a80						ld hl, $9f9f 
1a80						pop de   ; $9f9f 
1a80						call cmp16 
1a80						jr nz, .spnosame 
1a80						ld hl, $fefe 
1a80						pop de   ; $fefe 
1a80						call cmp16 
1a80						jr z, .spfrsame 
1a80						.spnosame: call showsperror 
1a80						.spfrsame: nop 
1a80						exx 
1a80					endif 
1a80				endif 
1a80			endm 
# End of macro STACKFRAMECHK
1a80			 
1a80				; copy input to last command 
1a80			 
1a80 21 81 f7			ld hl, os_cli_cmd 
1a83 11 80 f8			ld de, os_last_cmd 
1a86 01 ff 00			ld bc, 255 
1a89 ed b0			ldir 
1a8b			 
1a8b				; wipe current buffer 
1a8b			 
1a8b			;	ld a, 0 
1a8b			;	ld hl, os_cli_cmd 
1a8b			;	ld de, os_cli_cmd+1 
1a8b			;	ld bc, 254 
1a8b			;	ldir 
1a8b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1a8b			;	call strcpy 
1a8b			;	ld a, 0 
1a8b			;	ld (hl), a 
1a8b			;	inc hl 
1a8b			;	ld (hl), a 
1a8b			;	inc hl 
1a8b			;	ld (hl), a 
1a8b			 
1a8b				; switch frame buffer to program  
1a8b			 
1a8b 21 f9 fd				ld hl, display_fb1 
1a8e 22 55 fd				ld (display_fb_active), hl 
1a91			 
1a91			;	nop 
1a91				STACKFRAME ON $fbfe $8f9f 
1a91				if DEBUG_STACK_IMB 
1a91					if ON 
1a91						exx 
1a91						ld de, $fbfe 
1a91						ld a, d 
1a91						ld hl, curframe 
1a91						call hexout 
1a91						ld a, e 
1a91						ld hl, curframe+2 
1a91						call hexout 
1a91						ld hl, $fbfe 
1a91						push hl 
1a91						ld hl, $8f9f 
1a91						push hl 
1a91						exx 
1a91					endif 
1a91				endif 
1a91			endm 
# End of macro STACKFRAME
1a91				; first time into the parser so pass over the current scratch pad 
1a91 21 81 f7			ld hl,os_cli_cmd 
1a94				; tokenise the entered statement(s) in HL 
1a94 cd 6b 21			call forthparse 
1a97			        ; exec forth statements in top of return stack 
1a97 cd ab 21			call forthexec 
1a9a				;call forthexec_cleanup 
1a9a			;	call parsenext 
1a9a			 
1a9a				STACKFRAMECHK ON $fbfe $8f9f 
1a9a				if DEBUG_STACK_IMB 
1a9a					if ON 
1a9a						exx 
1a9a						ld hl, $8f9f 
1a9a						pop de   ; $8f9f 
1a9a						call cmp16 
1a9a						jr nz, .spnosame 
1a9a						ld hl, $fbfe 
1a9a						pop de   ; $fbfe 
1a9a						call cmp16 
1a9a						jr z, .spfrsame 
1a9a						.spnosame: call showsperror 
1a9a						.spfrsame: nop 
1a9a						exx 
1a9a					endif 
1a9a				endif 
1a9a			endm 
# End of macro STACKFRAMECHK
1a9a				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1a9a			 
1a9a 3e 3c			ld a, display_row_4 
1a9c 11 ce 1a			ld de, endprog 
1a9f			 
1a9f cd c9 0b			call update_display		 
1aa2			 
1aa2 cd 2c 1d			call next_page_prompt 
1aa5			 
1aa5				; switch frame buffer to cli 
1aa5			 
1aa5 21 4a fe				ld hl, display_fb0 
1aa8 22 55 fd				ld (display_fb_active), hl 
1aab			 
1aab			 
1aab cd a6 0b		        call clear_display 
1aae cd c9 0b			call update_display		 
1ab1			 
1ab1 21 81 f7			ld hl, os_cli_cmd 
1ab4			 
1ab4 3e 00			ld a, 0		 ; init cli input 
1ab6 77				ld (hl), a 
1ab7			 
1ab7				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1ab7			 
1ab7				; now on last line 
1ab7			 
1ab7				; TODO scroll screen up 
1ab7			 
1ab7				; TODO instead just clear screen and place at top of screen 
1ab7			 
1ab7			;	ld a, 0 
1ab7			;	ld (f_cursor_ptr),a 
1ab7			 
1ab7				;call clear_display 
1ab7				;call update_display 
1ab7			 
1ab7				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ab7 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ab9 c3 74 1a			jp cli 
1abc			 
1abc .. 00		freeram: db "Free bytes: $",0 
1aca ..			asc: db "1A2F" 
1ace .. 00		endprog: db "End prog...",0 
1ada			 
1ada			testenter2:   
1ada 21 8c f4			ld hl,scratch+50 
1add 22 7d f7			ld (os_cur_ptr),hl 
1ae0 c3 74 1a			jp cli 
1ae3			 
1ae3			testenter:  
1ae3			 
1ae3 21 ca 1a			ld hl,asc 
1ae6			;	ld a,(hl) 
1ae6			;	call nibble2val 
1ae6 cd 31 11			call get_byte 
1ae9			 
1ae9			 
1ae9			;	ld a,(hl) 
1ae9			;	call atohex 
1ae9			 
1ae9			;	call fourehexhl 
1ae9 32 8c f4			ld (scratch+50),a 
1aec			 
1aec			 
1aec			 
1aec 21 cc 1a			ld hl,asc+2 
1aef			;	ld a, (hl) 
1aef			;	call nibble2val 
1aef cd 31 11			call get_byte 
1af2			 
1af2			;	call fourehexhl 
1af2 32 8e f4			ld (scratch+52),a 
1af5				 
1af5 21 8c f4			ld hl,scratch+50 
1af8 22 7d f7			ld (os_cur_ptr),hl 
1afb c3 74 1a			jp cli 
1afe			 
1afe			enter:	 
1afe 3a 5e f4			ld a,(scratch+4) 
1b01 fe 00			cp 0 
1b03 28 0c			jr z, .entercont 
1b05				; no, not a null term line so has an address to work out.... 
1b05			 
1b05 21 5c f4			ld hl,scratch+2 
1b08 cd 91 11			call get_word_hl 
1b0b			 
1b0b 22 7d f7			ld (os_cur_ptr),hl	 
1b0e c3 74 1a			jp cli 
1b11			 
1b11			 
1b11			.entercont:  
1b11			 
1b11 21 5c f4			ld hl, scratch+2 
1b14 cd 31 11			call get_byte 
1b17			 
1b17 2a 7d f7		   	ld hl,(os_cur_ptr) 
1b1a 77					ld (hl),a 
1b1b 23					inc hl 
1b1c 22 7d f7				ld (os_cur_ptr),hl 
1b1f				 
1b1f			; get byte  
1b1f			 
1b1f			 
1b1f c3 74 1a			jp cli 
1b22			 
1b22			 
1b22			; basic monitor support 
1b22			 
1b22			monitor: 
1b22				;  
1b22 cd a6 0b			call clear_display 
1b25 3e 00			ld a, 0 
1b27 11 6f 1b			ld de, .monprompt 
1b2a cd b9 0b			call str_at_display 
1b2d cd c9 0b			call update_display 
1b30			 
1b30				; get a monitor command 
1b30			 
1b30 0e 00			ld c, 0     ; entry at top left 
1b32 16 64			ld d, 100   ; max buffer size 
1b34 1e 0f			ld e, 15    ; input scroll area 
1b36 3e 00			ld a, 0     ; init string 
1b38 21 58 f6			ld hl, os_input 
1b3b 77				ld (hl), a 
1b3c 23				inc hl 
1b3d 77				ld (hl), a 
1b3e 21 58 f6			ld hl, os_input 
1b41 3e 01			ld a, 1     ; init string 
1b43 cd 07 0e			call input_str 
1b46			 
1b46 cd a6 0b		        call clear_display 
1b49 cd c9 0b			call update_display		 
1b4c			 
1b4c 3a 58 f6			ld a, (os_input) 
1b4f cd 2f 12			call toUpper 
1b52 fe 48		        cp 'H' 
1b54 28 6f		        jr z, .monhelp 
1b56 fe 44			cp 'D'		; dump 
1b58 ca e6 1b			jp z, .mondump	 
1b5b fe 43			cp 'C'		; dump 
1b5d ca 00 1c			jp z, .moncdump	 
1b60 fe 4d			cp 'M'		; dump 
1b62 ca 71 1b			jp z, .moneditstart 
1b65 fe 55			cp 'U'		; dump 
1b67 28 14			jr z, .monedit	 
1b69 fe 51			cp 'Q'		; dump 
1b6b c8				ret z	 
1b6c			 
1b6c			 
1b6c				; TODO "S" to access symbol by name and not need the address 
1b6c				; TODO "F" to find a string in memory 
1b6c			 
1b6c c3 22 1b			jp monitor 
1b6f			 
1b6f .. 00		.monprompt: db ">", 0 
1b71			 
1b71			.moneditstart: 
1b71				; get starting address 
1b71			 
1b71 21 5a f6			ld hl,os_input+2 
1b74 cd 91 11			call get_word_hl 
1b77			 
1b77 22 7d f7			ld (os_cur_ptr),hl	 
1b7a			 
1b7a c3 22 1b			jp monitor 
1b7d			 
1b7d			.monedit: 
1b7d				; get byte to load 
1b7d			 
1b7d 21 5a f6			ld hl,os_input+2 
1b80 cd 31 11			call get_byte 
1b83			 
1b83				; get address to update 
1b83 2a 7d f7			ld hl, (os_cur_ptr) 
1b86			 
1b86				; update byte 
1b86			 
1b86 77				ld (hl), a 
1b87			 
1b87				; move to next address and save it 
1b87			 
1b87 23				inc hl 
1b88 22 7d f7			ld (os_cur_ptr),hl	 
1b8b			 
1b8b c3 22 1b			jp monitor 
1b8e			 
1b8e			 
1b8e .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ba2 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1bbe .. 00		.monhelptext3:  db "Q-Quit",0 
1bc5			        
1bc5			.monhelp: 
1bc5 3e 00			ld a, display_row_1 
1bc7 11 8e 1b		        ld de, .monhelptext1 
1bca			 
1bca cd b9 0b			call str_at_display 
1bcd 3e 14			ld a, display_row_2 
1bcf 11 a2 1b		        ld de, .monhelptext2 
1bd2					 
1bd2 cd b9 0b			call str_at_display 
1bd5 3e 28			ld a, display_row_3 
1bd7 11 be 1b		        ld de, .monhelptext3 
1bda					 
1bda cd b9 0b			call str_at_display 
1bdd cd c9 0b			call update_display		 
1be0			 
1be0 cd 2c 1d			call next_page_prompt 
1be3 c3 22 1b			jp monitor 
1be6			 
1be6			.mondump:    
1be6 21 5a f6			ld hl,os_input+2 
1be9 cd 91 11			call get_word_hl 
1bec			 
1bec 22 7d f7			ld (os_cur_ptr),hl	 
1bef cd 34 1c			call dumpcont 
1bf2 3e 3c			ld a, display_row_4 
1bf4 11 ce 1a			ld de, endprog 
1bf7			 
1bf7 cd c9 0b			call update_display		 
1bfa			 
1bfa cd 2c 1d			call next_page_prompt 
1bfd c3 22 1b			jp monitor 
1c00			.moncdump: 
1c00 cd 34 1c			call dumpcont 
1c03 3e 3c			ld a, display_row_4 
1c05 11 ce 1a			ld de, endprog 
1c08			 
1c08 cd c9 0b			call update_display		 
1c0b			 
1c0b cd 2c 1d			call next_page_prompt 
1c0e c3 22 1b			jp monitor 
1c11			 
1c11			 
1c11			; TODO symbol access  
1c11			 
1c11			.symbols:     ;; A list of symbols that can be called up  
1c11 4a fe			dw display_fb0 
1c13 .. 00			db "fb0",0  
1c17 df fc		     	dw store_page 
1c19 .. 00			db "store_page",0 
1c24			 
1c24			 
1c24			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1c24			 
1c24 3a 5b f4			ld a,(scratch+1) 
1c27 fe 00			cp 0 
1c29 28 09			jr z, dumpcont 
1c2b			 
1c2b				; no, not a null term line so has an address to work out.... 
1c2b			 
1c2b 21 5c f4			ld hl,scratch+2 
1c2e cd 91 11			call get_word_hl 
1c31			 
1c31 22 7d f7			ld (os_cur_ptr),hl	 
1c34			 
1c34			 
1c34			 
1c34			dumpcont: 
1c34			 
1c34				; dump bytes at ptr 
1c34			 
1c34			 
1c34 3e 00			ld a, display_row_1 
1c36 2a 55 fd			ld hl, (display_fb_active) 
1c39 cd da 0d			call addatohl 
1c3c cd 64 1c			call .dumpbyterow 
1c3f			 
1c3f 3e 14			ld a, display_row_2 
1c41 2a 55 fd			ld hl, (display_fb_active) 
1c44 cd da 0d			call addatohl 
1c47 cd 64 1c			call .dumpbyterow 
1c4a			 
1c4a			 
1c4a 3e 28			ld a, display_row_3 
1c4c 2a 55 fd			ld hl, (display_fb_active) 
1c4f cd da 0d			call addatohl 
1c52 cd 64 1c			call .dumpbyterow 
1c55			 
1c55 3e 3c			ld a, display_row_4 
1c57 2a 55 fd			ld hl, (display_fb_active) 
1c5a cd da 0d			call addatohl 
1c5d cd 64 1c			call .dumpbyterow 
1c60			 
1c60 cd c9 0b			call update_display 
1c63			;		jp cli 
1c63 c9				ret 
1c64			 
1c64			.dumpbyterow: 
1c64			 
1c64				;push af 
1c64			 
1c64 e5				push hl 
1c65			 
1c65				; calc where to poke the ascii 
1c65			if display_cols == 20 
1c65 3e 10			ld a, 16 
1c67			else 
1c67				ld a, 31 
1c67			endif 
1c67			 
1c67 cd da 0d			call addatohl 
1c6a 22 5f f7			ld (os_word_scratch),hl  		; save pos for later 
1c6d			 
1c6d			 
1c6d			; display decoding address 
1c6d 2a 7d f7		   	ld hl,(os_cur_ptr) 
1c70			 
1c70 7c				ld a,h 
1c71 e1				pop hl 
1c72 e5				push hl 
1c73			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c73 cd db 10			call hexout 
1c76 2a 7d f7		   	ld hl,(os_cur_ptr) 
1c79			 
1c79 7d				ld a,l 
1c7a e1				pop hl 
1c7b 23				inc hl 
1c7c 23				inc hl 
1c7d e5				push hl 
1c7e			;	ld hl, os_word_scratch+2 
1c7e cd db 10			call hexout 
1c81 e1				pop hl 
1c82 23				inc hl 
1c83 23				inc hl 
1c84				;ld hl, os_word_scratch+4 
1c84 3e 3a			ld a, ':' 
1c86 77				ld (hl),a 
1c87 23				inc hl 
1c88				;ld a, 0 
1c88				;ld (hl),a 
1c88				;ld de, os_word_scratch 
1c88				;pop af 
1c88				;push af 
1c88			;		ld a, display_row_2 
1c88			;		call str_at_display 
1c88			;		call update_display 
1c88			 
1c88			 
1c88			;pop af 
1c88			;	add 5 
1c88			 
1c88			if display_cols == 20 
1c88 06 04			ld b, 4 
1c8a			else 
1c8a				ld b, 8 
1c8a			endif	 
1c8a			 
1c8a			.dumpbyte: 
1c8a c5				push bc 
1c8b e5				push hl 
1c8c			 
1c8c			 
1c8c 2a 7d f7		   	ld hl,(os_cur_ptr) 
1c8f 7e					ld a,(hl) 
1c90			 
1c90					; poke the ascii to display 
1c90 2a 5f f7				ld hl,(os_word_scratch) 
1c93 77					ld (hl),a 
1c94 23					inc hl 
1c95 22 5f f7				ld (os_word_scratch),hl 
1c98			 
1c98					 
1c98			 
1c98			 
1c98 e1					pop hl 
1c99 e5					push hl 
1c9a			 
1c9a cd db 10				call hexout 
1c9d			 
1c9d					 
1c9d 2a 7d f7		   	ld hl,(os_cur_ptr) 
1ca0 23				inc hl 
1ca1 22 7d f7		   	ld (os_cur_ptr),hl 
1ca4			 
1ca4 e1					pop hl 
1ca5 23					inc hl 
1ca6 23					inc hl 
1ca7 23					inc hl 
1ca8			 
1ca8			 
1ca8			 
1ca8					;ld a,0 
1ca8					;ld (os_word_scratch+2),a 
1ca8					;pop af 
1ca8					;push af 
1ca8			 
1ca8					;ld de, os_word_scratch 
1ca8					;call str_at_display 
1ca8			;		call update_display 
1ca8			;		pop af 
1ca8 c1					pop bc 
1ca9 c6 03				add 3 
1cab 10 dd			djnz .dumpbyte 
1cad			 
1cad				 
1cad			 
1cad c9				ret 
1cae			 
1cae			jump:	 
1cae			 
1cae 21 5c f4			ld hl,scratch+2 
1cb1 cd 91 11			call get_word_hl 
1cb4				;ld hl,(scratch+2) 
1cb4				;call fourehexhl 
1cb4			 
1cb4 22 7d f7			ld (os_cur_ptr),hl	 
1cb7			 
1cb7 e9				jp (hl) 
1cb8			 
1cb8			 
1cb8			 
1cb8			; TODO implement a basic monitor mode to start with 
1cb8			 
1cb8			 
1cb8			 
1cb8			 
1cb8			 
1cb8			 
1cb8			 
1cb8			 
1cb8			 
1cb8			; testing and demo code during development 
1cb8			 
1cb8			 
1cb8 .. 00		str1: db "Enter some text...",0 
1ccb .. 00		clear: db "                    ",0 
1ce0			 
1ce0			demo: 
1ce0			 
1ce0			 
1ce0			 
1ce0			;	call update_display 
1ce0			 
1ce0				; init scratch input area for testing 
1ce0 21 5a f4			ld hl, scratch	 
1ce3 3e 00			ld a,0 
1ce5 77				ld (hl),a 
1ce6			 
1ce6			 
1ce6 3e 14		            LD   A, display_row_2 
1ce8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ce8 11 b8 1c		            LD   DE, str1 
1ceb cd b9 0b			call str_at_display 
1cee			 
1cee			;            CALL fLCD_Str       ;Display string pointed to by DE 
1cee			cloop:	 
1cee 3e 28		            LD   A, display_row_3 
1cf0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1cf0 11 cb 1c		            LD   DE, clear 
1cf3			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1cf3 cd b9 0b				call str_at_display 
1cf6 3e 3c			ld a, display_row_4 
1cf8 11 28 1d			ld de, prompt 
1cfb			 
1cfb cd b9 0b				call str_at_display 
1cfe cd c9 0b			call update_display 
1d01			 
1d01 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d03 16 0a			ld d, 10 
1d05 21 5a f4			ld hl, scratch	 
1d08 cd 07 0e			call input_str 
1d0b			 
1d0b			;	call clear_display 
1d0b			;'	call update_display 
1d0b			 
1d0b 3e 00		            LD   A, display_row_1 
1d0d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d0d 11 cb 1c		            LD   DE, clear 
1d10 cd b9 0b				call str_at_display 
1d13			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d13 3e 00		            LD   A, display_row_1 
1d15			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d15 11 5a f4		            LD   DE, scratch 
1d18			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d18 cd b9 0b				call str_at_display 
1d1b cd c9 0b			call update_display 
1d1e			 
1d1e 3e 00				ld a,0 
1d20 21 5a f4			ld hl, scratch 
1d23 77				ld (hl),a 
1d24			 
1d24 00				nop 
1d25 c3 ee 1c			jp cloop 
1d28			 
1d28			 
1d28			 
1d28			; OS Prompt 
1d28			 
1d28 .. 00		prompt: db ">",0 
1d2a .. 00		endprg: db "?",0 
1d2c			 
1d2c			 
1d2c			; handy next page prompt 
1d2c			next_page_prompt: 
1d2c e5				push hl 
1d2d d5				push de 
1d2e f5				push af 
1d2f c5				push bc 
1d30			 
1d30 3e 4f			ld a,display_row_4 + display_cols - 1 
1d32 11 2a 1d		        ld de, endprg 
1d35 cd b9 0b			call str_at_display 
1d38 cd c9 0b			call update_display 
1d3b cd 21 69			call cin_wait 
1d3e c1				pop bc 
1d3f f1				pop af 
1d40 d1				pop de 
1d41 e1				pop hl 
1d42			 
1d42			 
1d42 c9				ret 
1d43			 
1d43			 
1d43			; forth parser 
1d43			 
1d43			; My forth kernel 
1d43			include "forth_kernel.asm" 
1d43			; 
1d43			; kernel to the forth OS 
1d43			 
1d43			DS_TYPE_STR: equ 1     ; string type 
1d43			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1d43			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1d43			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1d43			 
1d43			FORTH_PARSEV1: equ 0 
1d43			FORTH_PARSEV2: equ 0 
1d43			FORTH_PARSEV3: equ 0 
1d43			FORTH_PARSEV4: equ 0 
1d43			FORTH_PARSEV5: equ 1 
1d43			 
1d43			;if FORTH_PARSEV5 
1d43			;	FORTH_END_BUFFER: equ 0 
1d43			;else 
1d43			FORTH_END_BUFFER: equ 127 
1d43			;endif 
1d43			 
1d43			FORTH_TRUE: equ 1 
1d43			FORTH_FALSE: equ 0 
1d43			 
1d43			if FORTH_PARSEV4 
1d43			include "forth_stackops.asm" 
1d43			endif 
1d43			 
1d43			if FORTH_PARSEV5 
1d43			include "forth_stackopsv5.asm" 
1d43			 
1d43			; Stack operations for v5 parser on wards 
1d43			; * DATA stack 
1d43			; * LOOP stack 
1d43			; * RETURN stack 
1d43			 
1d43			 
1d43			 
1d43			FORTH_CHK_DSP_UNDER: macro 
1d43				push hl 
1d43				push de 
1d43				ld hl,(cli_data_sp) 
1d43				ld de, cli_data_stack 
1d43				call cmp16 
1d43				jp c, fault_dsp_under 
1d43				pop de 
1d43				pop hl 
1d43				endm 
1d43			 
1d43			 
1d43			FORTH_CHK_RSP_UNDER: macro 
1d43				push hl 
1d43				push de 
1d43				ld hl,(cli_ret_sp) 
1d43				ld de, cli_ret_stack 
1d43				call cmp16 
1d43				jp c, fault_rsp_under 
1d43				pop de 
1d43				pop hl 
1d43				endm 
1d43			 
1d43			FORTH_CHK_LOOP_UNDER: macro 
1d43				push hl 
1d43				push de 
1d43				ld hl,(cli_loop_sp) 
1d43				ld de, cli_loop_stack 
1d43				call cmp16 
1d43				jp c, fault_loop_under 
1d43				pop de 
1d43				pop hl 
1d43				endm 
1d43			 
1d43			FORTH_ERR_TOS_NOTSTR: macro 
1d43				; TOSO might need more for checks when used 
1d43				push af 
1d43				ld a,(hl) 
1d43				cp DS_TYPE_STR 
1d43				jp nz, type_faultn   
1d43				pop af 
1d43				endm 
1d43			 
1d43			FORTH_ERR_TOS_NOTNUM: macro 
1d43				push af 
1d43				ld a,(hl) 
1d43				cp DS_TYPE_INUM 
1d43				jp nz, type_faultn   
1d43				pop af 
1d43				endm 
1d43			 
1d43			 
1d43			; increase data stack pointer and save hl to it 
1d43				 
1d43			FORTH_DSP_NEXT: macro 
1d43				call macro_forth_dsp_next 
1d43				endm 
1d43			 
1d43			 
1d43			macro_forth_dsp_next: 
1d43				if DEBUG_FORTH_STACK_GUARD 
1d43 cd 3c 64				call check_stacks 
1d46				endif 
1d46 e5				push hl 
1d47 d5				push de 
1d48 eb				ex de,hl 
1d49 2a 87 fc			ld hl,(cli_data_sp) 
1d4c 23				inc hl 
1d4d 23				inc hl 
1d4e			 
1d4e			; PARSEV5 
1d4e 23				inc hl 
1d4f 22 87 fc			ld (cli_data_sp),hl 
1d52 73				ld (hl), e 
1d53 23				inc hl 
1d54 72				ld (hl), d 
1d55 d1				pop de 
1d56 e1				pop hl 
1d57				if DEBUG_FORTH_STACK_GUARD 
1d57 cd 3c 64				call check_stacks 
1d5a				endif 
1d5a c9				ret 
1d5b			 
1d5b			 
1d5b			; increase ret stack pointer and save hl to it 
1d5b				 
1d5b			FORTH_RSP_NEXT: macro 
1d5b				call macro_forth_rsp_next 
1d5b				endm 
1d5b			 
1d5b			macro_forth_rsp_next: 
1d5b				if DEBUG_FORTH_STACK_GUARD 
1d5b cd 3c 64				call check_stacks 
1d5e				endif 
1d5e e5				push hl 
1d5f d5				push de 
1d60 eb				ex de,hl 
1d61 2a 8b fc			ld hl,(cli_ret_sp) 
1d64 23				inc hl 
1d65 23				inc hl 
1d66 22 8b fc			ld (cli_ret_sp),hl 
1d69 73				ld (hl), e 
1d6a 23				inc hl 
1d6b 72				ld (hl), d 
1d6c d1				pop de 
1d6d e1				pop hl 
1d6e				if DEBUG_FORTH_STACK_GUARD 
1d6e cd 3c 64				call check_stacks 
1d71				endif 
1d71 c9				ret 
1d72			 
1d72			; get current ret stack pointer and save to hl  
1d72				 
1d72			FORTH_RSP_TOS: macro 
1d72				call macro_forth_rsp_tos 
1d72				endm 
1d72			 
1d72			macro_forth_rsp_tos: 
1d72				;push de 
1d72 2a 8b fc			ld hl,(cli_ret_sp) 
1d75 cd ad 1d			call loadhlptrtohl 
1d78				;ld e, (hl) 
1d78				;inc hl 
1d78				;ld d, (hl) 
1d78				;ex de, hl 
1d78					if DEBUG_FORTH_WORDS 
1d78			;			DMARK "RST" 
1d78						CALLMONITOR 
1d78 cd 57 17			call break_point_state  
1d7b				endm  
# End of macro CALLMONITOR
1d7b					endif 
1d7b				;pop de 
1d7b c9				ret 
1d7c			 
1d7c			; pop ret stack pointer 
1d7c				 
1d7c			FORTH_RSP_POP: macro 
1d7c				call macro_forth_rsp_pop 
1d7c				endm 
1d7c			 
1d7c			 
1d7c			macro_forth_rsp_pop: 
1d7c				if DEBUG_FORTH_STACK_GUARD 
1d7c			;		DMARK "RPP" 
1d7c cd 3c 64				call check_stacks 
1d7f					FORTH_CHK_RSP_UNDER 
1d7f e5				push hl 
1d80 d5				push de 
1d81 2a 8b fc			ld hl,(cli_ret_sp) 
1d84 11 45 fc			ld de, cli_ret_stack 
1d87 cd f8 0d			call cmp16 
1d8a da 50 65			jp c, fault_rsp_under 
1d8d d1				pop de 
1d8e e1				pop hl 
1d8f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1d8f				endif 
1d8f e5				push hl 
1d90 2a 8b fc			ld hl,(cli_ret_sp) 
1d93			 
1d93			 
1d93				if FORTH_ENABLE_FREE 
1d93			 
1d93					; get pointer 
1d93			 
1d93					push de 
1d93					push hl 
1d93			 
1d93					ld e, (hl) 
1d93					inc hl 
1d93					ld d, (hl) 
1d93			 
1d93					ex de, hl 
1d93					call free 
1d93			 
1d93					pop hl 
1d93					pop de 
1d93			 
1d93			 
1d93				endif 
1d93			 
1d93			 
1d93 2b				dec hl 
1d94 2b				dec hl 
1d95 22 8b fc			ld (cli_ret_sp), hl 
1d98				; do stack underflow checks 
1d98 e1				pop hl 
1d99				if DEBUG_FORTH_STACK_GUARD 
1d99 cd 3c 64				call check_stacks 
1d9c					FORTH_CHK_RSP_UNDER 
1d9c e5				push hl 
1d9d d5				push de 
1d9e 2a 8b fc			ld hl,(cli_ret_sp) 
1da1 11 45 fc			ld de, cli_ret_stack 
1da4 cd f8 0d			call cmp16 
1da7 da 50 65			jp c, fault_rsp_under 
1daa d1				pop de 
1dab e1				pop hl 
1dac				endm 
# End of macro FORTH_CHK_RSP_UNDER
1dac				endif 
1dac c9				ret 
1dad			 
1dad			 
1dad			 
1dad			; routine to load word pointed to by hl into hl 
1dad			 
1dad			loadhlptrtohl: 
1dad			 
1dad d5				push de 
1dae 5e				ld e, (hl) 
1daf 23				inc hl 
1db0 56				ld d, (hl) 
1db1 eb				ex de, hl 
1db2 d1				pop de 
1db3			 
1db3 c9				ret 
1db4			 
1db4			 
1db4			 
1db4			 
1db4			 
1db4			; push a number held in HL onto the data stack 
1db4			; entry point for pushing a value when already in hl used in function above 
1db4			 
1db4			forth_push_numhl: 
1db4			 
1db4 e5				push hl    ; save value to push 
1db5			 
1db5			if DEBUG_FORTH_PUSH 
1db5				; see if disabled 
1db5			 
1db5			 
1db5 f5				push af 
1db6 3a 4b f4			ld a, (os_view_disable) 
1db9 fe 2a			cp '*' 
1dbb 28 34			jr z, .pskip2 
1dbd e5				push hl 
1dbe e5			push hl 
1dbf cd a6 0b			call clear_display 
1dc2 e1			pop hl 
1dc3 7c				ld a,h 
1dc4 21 5f f7			ld hl, os_word_scratch 
1dc7 cd db 10			call hexout 
1dca e1				pop hl 
1dcb 7d				ld a,l 
1dcc 21 61 f7			ld hl, os_word_scratch+2 
1dcf cd db 10			call hexout 
1dd2			 
1dd2 21 63 f7			ld hl, os_word_scratch+4 
1dd5 3e 00			ld a,0 
1dd7 77				ld (hl),a 
1dd8 11 5f f7			ld de,os_word_scratch 
1ddb 3e 14				ld a, display_row_2 
1ddd cd b9 0b				call str_at_display 
1de0 11 1b 53			ld de, .push_num 
1de3 3e 00			ld a, display_row_1 
1de5			 
1de5 cd b9 0b				call str_at_display 
1de8			 
1de8			 
1de8 cd c9 0b			call update_display 
1deb cd 23 0b			call delay1s 
1dee cd 23 0b			call delay1s 
1df1			.pskip2:  
1df1			 
1df1 f1				pop af 
1df2			endif	 
1df2			 
1df2			 
1df2				FORTH_DSP_NEXT 
1df2 cd 43 1d			call macro_forth_dsp_next 
1df5				endm 
# End of macro FORTH_DSP_NEXT
1df5			 
1df5 2a 87 fc			ld hl, (cli_data_sp) 
1df8			 
1df8				; save item type 
1df8 3e 02			ld a,  DS_TYPE_INUM 
1dfa 77				ld (hl), a 
1dfb 23				inc hl 
1dfc			 
1dfc				; get word off stack 
1dfc d1				pop de 
1dfd 7b				ld a,e 
1dfe 77				ld (hl), a 
1dff 23				inc hl 
1e00 7a				ld a,d 
1e01 77				ld (hl), a 
1e02			 
1e02			if DEBUG_FORTH_PUSH 
1e02 2b				dec hl 
1e03 2b				dec hl 
1e04 2b				dec hl 
1e05						DMARK "PH5" 
1e05 f5				push af  
1e06 3a 1a 1e			ld a, (.dmark)  
1e09 32 b4 fe			ld (debug_mark),a  
1e0c 3a 1b 1e			ld a, (.dmark+1)  
1e0f 32 b5 fe			ld (debug_mark+1),a  
1e12 3a 1c 1e			ld a, (.dmark+2)  
1e15 32 b6 fe			ld (debug_mark+2),a  
1e18 18 03			jr .pastdmark  
1e1a ..			.dmark: db "PH5"  
1e1d f1			.pastdmark: pop af  
1e1e			endm  
# End of macro DMARK
1e1e				CALLMONITOR 
1e1e cd 57 17			call break_point_state  
1e21				endm  
# End of macro CALLMONITOR
1e21			endif	 
1e21			 
1e21 c9				ret 
1e22			 
1e22			 
1e22			; Push a string to stack pointed to by hl 
1e22			 
1e22			forth_push_str: 
1e22			 
1e22			if DEBUG_FORTH_PUSH 
1e22						DMARK "PSQ" 
1e22 f5				push af  
1e23 3a 37 1e			ld a, (.dmark)  
1e26 32 b4 fe			ld (debug_mark),a  
1e29 3a 38 1e			ld a, (.dmark+1)  
1e2c 32 b5 fe			ld (debug_mark+1),a  
1e2f 3a 39 1e			ld a, (.dmark+2)  
1e32 32 b6 fe			ld (debug_mark+2),a  
1e35 18 03			jr .pastdmark  
1e37 ..			.dmark: db "PSQ"  
1e3a f1			.pastdmark: pop af  
1e3b			endm  
# End of macro DMARK
1e3b				CALLMONITOR 
1e3b cd 57 17			call break_point_state  
1e3e				endm  
# End of macro CALLMONITOR
1e3e			endif	 
1e3e			    
1e3e e5				push hl 
1e3f e5				push hl 
1e40			 
1e40			;	ld a, 0   ; find end of string 
1e40 cd 38 12			call strlenz 
1e43			if DEBUG_FORTH_PUSH 
1e43						DMARK "PQ2" 
1e43 f5				push af  
1e44 3a 58 1e			ld a, (.dmark)  
1e47 32 b4 fe			ld (debug_mark),a  
1e4a 3a 59 1e			ld a, (.dmark+1)  
1e4d 32 b5 fe			ld (debug_mark+1),a  
1e50 3a 5a 1e			ld a, (.dmark+2)  
1e53 32 b6 fe			ld (debug_mark+2),a  
1e56 18 03			jr .pastdmark  
1e58 ..			.dmark: db "PQ2"  
1e5b f1			.pastdmark: pop af  
1e5c			endm  
# End of macro DMARK
1e5c				CALLMONITOR 
1e5c cd 57 17			call break_point_state  
1e5f				endm  
# End of macro CALLMONITOR
1e5f			endif	 
1e5f eb				ex de, hl 
1e60 e1				pop hl   ; get ptr to start of string 
1e61			if DEBUG_FORTH_PUSH 
1e61						DMARK "PQ3" 
1e61 f5				push af  
1e62 3a 76 1e			ld a, (.dmark)  
1e65 32 b4 fe			ld (debug_mark),a  
1e68 3a 77 1e			ld a, (.dmark+1)  
1e6b 32 b5 fe			ld (debug_mark+1),a  
1e6e 3a 78 1e			ld a, (.dmark+2)  
1e71 32 b6 fe			ld (debug_mark+2),a  
1e74 18 03			jr .pastdmark  
1e76 ..			.dmark: db "PQ3"  
1e79 f1			.pastdmark: pop af  
1e7a			endm  
# End of macro DMARK
1e7a				CALLMONITOR 
1e7a cd 57 17			call break_point_state  
1e7d				endm  
# End of macro CALLMONITOR
1e7d			endif	 
1e7d 19				add hl,de 
1e7e			if DEBUG_FORTH_PUSH 
1e7e						DMARK "PQE" 
1e7e f5				push af  
1e7f 3a 93 1e			ld a, (.dmark)  
1e82 32 b4 fe			ld (debug_mark),a  
1e85 3a 94 1e			ld a, (.dmark+1)  
1e88 32 b5 fe			ld (debug_mark+1),a  
1e8b 3a 95 1e			ld a, (.dmark+2)  
1e8e 32 b6 fe			ld (debug_mark+2),a  
1e91 18 03			jr .pastdmark  
1e93 ..			.dmark: db "PQE"  
1e96 f1			.pastdmark: pop af  
1e97			endm  
# End of macro DMARK
1e97				CALLMONITOR 
1e97 cd 57 17			call break_point_state  
1e9a				endm  
# End of macro CALLMONITOR
1e9a			endif	 
1e9a			 
1e9a 2b				dec hl    ; see if there is an optional trailing double quote 
1e9b 7e				ld a,(hl) 
1e9c fe 22			cp '"' 
1e9e 20 03			jr nz, .strnoq 
1ea0 3e 00			ld a, 0      ; get rid of double quote 
1ea2 77				ld (hl), a 
1ea3 23			.strnoq: inc hl 
1ea4			 
1ea4 3e 00			ld a, 0 
1ea6 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ea7			 
1ea7 13				inc de ; add one for the type string 
1ea8 13				inc de ; add one for null term??? 
1ea9			 
1ea9				; tos is get string pointer again 
1ea9				; de contains space to allocate 
1ea9				 
1ea9 d5				push de 
1eaa			 
1eaa eb				ex de, hl 
1eab			 
1eab				;push af 
1eab			 
1eab			if DEBUG_FORTH_PUSH 
1eab						DMARK "PHm" 
1eab f5				push af  
1eac 3a c0 1e			ld a, (.dmark)  
1eaf 32 b4 fe			ld (debug_mark),a  
1eb2 3a c1 1e			ld a, (.dmark+1)  
1eb5 32 b5 fe			ld (debug_mark+1),a  
1eb8 3a c2 1e			ld a, (.dmark+2)  
1ebb 32 b6 fe			ld (debug_mark+2),a  
1ebe 18 03			jr .pastdmark  
1ec0 ..			.dmark: db "PHm"  
1ec3 f1			.pastdmark: pop af  
1ec4			endm  
# End of macro DMARK
1ec4				CALLMONITOR 
1ec4 cd 57 17			call break_point_state  
1ec7				endm  
# End of macro CALLMONITOR
1ec7			endif	 
1ec7 cd a1 12			call malloc	; on ret hl now contains allocated memory 
1eca				if DEBUG_FORTH_MALLOC_GUARD 
1eca cc 73 53				call z,malloc_error 
1ecd				endif 
1ecd			 
1ecd				 
1ecd c1				pop bc    ; get length 
1ece d1				pop de   ;  get string start    
1ecf			 
1ecf				; hl has destination from malloc 
1ecf			 
1ecf eb				ex de, hl    ; prep for ldir 
1ed0			 
1ed0 d5				push de   ; save malloc area for DSP later 
1ed1				;push hl   ; save malloc area for DSP later 
1ed1			 
1ed1			if DEBUG_FORTH_PUSH 
1ed1						DMARK "PHc" 
1ed1 f5				push af  
1ed2 3a e6 1e			ld a, (.dmark)  
1ed5 32 b4 fe			ld (debug_mark),a  
1ed8 3a e7 1e			ld a, (.dmark+1)  
1edb 32 b5 fe			ld (debug_mark+1),a  
1ede 3a e8 1e			ld a, (.dmark+2)  
1ee1 32 b6 fe			ld (debug_mark+2),a  
1ee4 18 03			jr .pastdmark  
1ee6 ..			.dmark: db "PHc"  
1ee9 f1			.pastdmark: pop af  
1eea			endm  
# End of macro DMARK
1eea				CALLMONITOR 
1eea cd 57 17			call break_point_state  
1eed				endm  
# End of macro CALLMONITOR
1eed			endif	 
1eed			 
1eed			 
1eed ed b0			ldir 
1eef			 
1eef			 
1eef				; push malloc to data stack     macro?????  
1eef			 
1eef				FORTH_DSP_NEXT 
1eef cd 43 1d			call macro_forth_dsp_next 
1ef2				endm 
# End of macro FORTH_DSP_NEXT
1ef2			 
1ef2				; save value and type 
1ef2			 
1ef2 2a 87 fc			ld hl, (cli_data_sp) 
1ef5			 
1ef5				; save item type 
1ef5 3e 01			ld a,  DS_TYPE_STR 
1ef7 77				ld (hl), a 
1ef8 23				inc hl 
1ef9			 
1ef9				; get malloc word off stack 
1ef9 d1				pop de 
1efa 73				ld (hl), e 
1efb 23				inc hl 
1efc 72				ld (hl), d 
1efd			 
1efd			 
1efd			 
1efd			if DEBUG_FORTH_PUSH 
1efd 2a 87 fc			ld hl, (cli_data_sp) 
1f00						DMARK "PHS" 
1f00 f5				push af  
1f01 3a 15 1f			ld a, (.dmark)  
1f04 32 b4 fe			ld (debug_mark),a  
1f07 3a 16 1f			ld a, (.dmark+1)  
1f0a 32 b5 fe			ld (debug_mark+1),a  
1f0d 3a 17 1f			ld a, (.dmark+2)  
1f10 32 b6 fe			ld (debug_mark+2),a  
1f13 18 03			jr .pastdmark  
1f15 ..			.dmark: db "PHS"  
1f18 f1			.pastdmark: pop af  
1f19			endm  
# End of macro DMARK
1f19				CALLMONITOR 
1f19 cd 57 17			call break_point_state  
1f1c				endm  
# End of macro CALLMONITOR
1f1c			;	ex de,hl 
1f1c			endif	 
1f1c				; in case of spaces, skip the ptr past the copied string 
1f1c				;pop af 
1f1c				;ld (cli_origptr),hl 
1f1c			 
1f1c c9				ret 
1f1d			 
1f1d			 
1f1d			 
1f1d			; TODO ascii push input onto stack given hl to start of input 
1f1d			 
1f1d			; identify type 
1f1d			; if starts with a " then a string 
1f1d			; otherwise it is a number 
1f1d			;  
1f1d			; if a string 
1f1d			;     scan for ending " to get length of string to malloc for + 1 
1f1d			;     malloc 
1f1d			;     put pointer to string on stack first byte flags as string 
1f1d			; 
1f1d			; else a number 
1f1d			;    look for number format identifier 
1f1d			;    $xx hex 
1f1d			;    %xxxxx bin 
1f1d			;    xxxxx decimal 
1f1d			;    convert number to 16bit word.  
1f1d			;    malloc word + 1 with flag to identiy as num 
1f1d			;    put pointer to number on stack 
1f1d			;   
1f1d			;  
1f1d			  
1f1d			forth_apush: 
1f1d				; kernel push 
1f1d			 
1f1d			if DEBUG_FORTH_PUSH 
1f1d						DMARK "PSH" 
1f1d f5				push af  
1f1e 3a 32 1f			ld a, (.dmark)  
1f21 32 b4 fe			ld (debug_mark),a  
1f24 3a 33 1f			ld a, (.dmark+1)  
1f27 32 b5 fe			ld (debug_mark+1),a  
1f2a 3a 34 1f			ld a, (.dmark+2)  
1f2d 32 b6 fe			ld (debug_mark+2),a  
1f30 18 03			jr .pastdmark  
1f32 ..			.dmark: db "PSH"  
1f35 f1			.pastdmark: pop af  
1f36			endm  
# End of macro DMARK
1f36				CALLMONITOR 
1f36 cd 57 17			call break_point_state  
1f39				endm  
# End of macro CALLMONITOR
1f39			endif	 
1f39				; identify input type 
1f39			 
1f39 7e				ld a,(hl) 
1f3a fe 22			cp '"' 
1f3c 28 0a			jr z, .fapstr 
1f3e fe 24			cp '$' 
1f40 ca 68 1f			jp z, .faphex 
1f43 fe 25			cp '%' 
1f45 ca 50 1f			jp z, .fapbin 
1f48			;	cp 'b' 
1f48			;	jp z, .fabin 
1f48				; else decimal 
1f48			 
1f48				; TODO do decimal conversion 
1f48				; decimal is stored as a 16bit word 
1f48			 
1f48				; by default everything is a string if type is not detected 
1f48			.fapstr: ; 
1f48 fe 22			cp '"' 
1f4a 20 01			jr nz, .strnoqu 
1f4c 23				inc hl 
1f4d			.strnoqu: 
1f4d c3 22 1e			jp forth_push_str 
1f50			 
1f50			 
1f50			 
1f50			.fapbin:    ; push a binary string.  
1f50 11 00 00			ld de, 0   ; hold a 16bit value 
1f53			 
1f53 23			.fapbinshift:	inc hl  
1f54 7e				ld a,(hl) 
1f55 fe 00			cp 0     ; done scanning  
1f57 28 0b			jr z, .fapbdone  	; got it in HL so push  
1f59			 
1f59				; left shift de 
1f59 eb				ex de, hl	 
1f5a 29				add hl, hl 
1f5b			 
1f5b				; is 1 
1f5b fe 31			cp '1' 
1f5d 20 02			jr nz, .binzero 
1f5f cb 4d			bit 1, l 
1f61			.binzero: 
1f61 eb				ex de, hl	 ; save current de 
1f62 18 ef			jr .fapbinshift 
1f64			 
1f64			.fapbdone: 
1f64 eb				ex de, hl 
1f65 c3 b4 1d			jp forth_push_numhl 
1f68			 
1f68			 
1f68			.faphex:   ; hex is always stored as a 16bit word 
1f68				; skip number prefix 
1f68 23				inc hl 
1f69				; turn ascii into number 
1f69 cd 91 11			call get_word_hl	; ret 16bit word in hl 
1f6c			 
1f6c c3 b4 1d			jp forth_push_numhl 
1f6f			 
1f6f 00				 nop 
1f70			 
1f70			.fabin:   ; TODO bin conversion 
1f70			 
1f70			 
1f70 c9				ret 
1f71			 
1f71			 
1f71			; get either a string ptr or a 16bit word from the data stack 
1f71			 
1f71			FORTH_DSP: macro 
1f71				call macro_forth_dsp 
1f71				endm 
1f71			 
1f71			macro_forth_dsp: 
1f71				; data stack pointer points to current word on tos 
1f71			 
1f71 2a 87 fc			ld hl,(cli_data_sp) 
1f74			 
1f74				if DEBUG_FORTH_PUSH 
1f74						DMARK "DSP" 
1f74 f5				push af  
1f75 3a 89 1f			ld a, (.dmark)  
1f78 32 b4 fe			ld (debug_mark),a  
1f7b 3a 8a 1f			ld a, (.dmark+1)  
1f7e 32 b5 fe			ld (debug_mark+1),a  
1f81 3a 8b 1f			ld a, (.dmark+2)  
1f84 32 b6 fe			ld (debug_mark+2),a  
1f87 18 03			jr .pastdmark  
1f89 ..			.dmark: db "DSP"  
1f8c f1			.pastdmark: pop af  
1f8d			endm  
# End of macro DMARK
1f8d			 
1f8d cd a8 53				call display_data_sp 
1f90				;call break_point_state 
1f90				;rst 030h 
1f90				CALLMONITOR 
1f90 cd 57 17			call break_point_state  
1f93				endm  
# End of macro CALLMONITOR
1f93				endif 
1f93			 
1f93 c9				ret 
1f94			 
1f94			; return hl to start of value on stack 
1f94			 
1f94			FORTH_DSP_VALUE: macro 
1f94				call macro_forth_dsp_value 
1f94				endm 
1f94			 
1f94			macro_forth_dsp_value: 
1f94			 
1f94				FORTH_DSP 
1f94 cd 71 1f			call macro_forth_dsp 
1f97				endm 
# End of macro FORTH_DSP
1f97			 
1f97 d5				push de 
1f98			 
1f98 23				inc hl ; skip type 
1f99			 
1f99 5e				ld e, (hl) 
1f9a 23				inc hl 
1f9b 56				ld d, (hl) 
1f9c eb				ex de,hl  
1f9d			 
1f9d d1				pop de 
1f9e			 
1f9e c9				ret 
1f9f			 
1f9f			; return hl to start of value to second item on stack 
1f9f			 
1f9f			FORTH_DSP_VALUEM1: macro 
1f9f				call macro_forth_dsp_value_m1 
1f9f				endm 
1f9f			 
1f9f			macro_forth_dsp_value_m1: 
1f9f			 
1f9f				FORTH_DSP 
1f9f cd 71 1f			call macro_forth_dsp 
1fa2				endm 
# End of macro FORTH_DSP
1fa2			 
1fa2 2b				dec hl 
1fa3 2b				dec hl 
1fa4			;	dec hl 
1fa4			 
1fa4 d5				push de 
1fa5			 
1fa5 5e				ld e, (hl) 
1fa6 23				inc hl 
1fa7 56				ld d, (hl) 
1fa8 eb				ex de,hl  
1fa9			 
1fa9 d1				pop de 
1faa			 
1faa c9				ret 
1fab			 
1fab				 
1fab			 
1fab			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1fab			 
1fab			FORTH_DSP_POP: macro 
1fab				call macro_forth_dsp_pop 
1fab				endm 
1fab			 
1fab			 
1fab			; get the tos data type 
1fab			 
1fab			FORTH_DSP_TYPE:   macro 
1fab			 
1fab				;FORTH_DSP_VALUE 
1fab				FORTH_DSP 
1fab				 
1fab				; hl points to value 
1fab				; check type 
1fab			 
1fab				ld a,(hl) 
1fab			 
1fab				endm 
1fab			 
1fab			; load the tos value into hl 
1fab			 
1fab			 
1fab			FORTH_DSP_VALUEHL:  macro 
1fab				call macro_dsp_valuehl 
1fab				endm 
1fab			 
1fab			 
1fab			 
1fab			macro_dsp_valuehl: 
1fab				FORTH_DSP_VALUE 
1fab cd 94 1f			call macro_forth_dsp_value 
1fae				endm 
# End of macro FORTH_DSP_VALUE
1fae			 
1fae				;FORTH_ERR_TOS_NOTNUM 
1fae			 
1fae				;inc hl   ; skip type id 
1fae			 
1fae			;	push de 
1fae			; 
1fae			;	ld e, (hl) 
1fae			;	inc hl 
1fae			;	ld d, (hl) 
1fae			;	ex de,hl  
1fae			 
1fae			;	pop de 
1fae			 
1fae				if DEBUG_FORTH_PUSH 
1fae						DMARK "DVL" 
1fae f5				push af  
1faf 3a c3 1f			ld a, (.dmark)  
1fb2 32 b4 fe			ld (debug_mark),a  
1fb5 3a c4 1f			ld a, (.dmark+1)  
1fb8 32 b5 fe			ld (debug_mark+1),a  
1fbb 3a c5 1f			ld a, (.dmark+2)  
1fbe 32 b6 fe			ld (debug_mark+2),a  
1fc1 18 03			jr .pastdmark  
1fc3 ..			.dmark: db "DVL"  
1fc6 f1			.pastdmark: pop af  
1fc7			endm  
# End of macro DMARK
1fc7				CALLMONITOR 
1fc7 cd 57 17			call break_point_state  
1fca				endm  
# End of macro CALLMONITOR
1fca				endif 
1fca c9				ret 
1fcb			 
1fcb			forth_apushstrhl:      
1fcb				; push of string requires use of cli_origptr 
1fcb				; bodge use 
1fcb			 
1fcb				; get current cli_origptr, save, update with temp pointer  
1fcb ed 5b a3 fc		ld de, (cli_origptr) 
1fcf 22 a3 fc			ld (cli_origptr), hl 
1fd2 d5				push de 
1fd3 cd 1d 1f			call forth_apush 
1fd6 d1				pop de 
1fd7 ed 53 a3 fc		ld (cli_origptr), de 
1fdb c9			        ret	 
1fdc			 
1fdc			 
1fdc			; increase loop stack pointer and save hl to it 
1fdc				 
1fdc			FORTH_LOOP_NEXT: macro 
1fdc				call macro_forth_loop_next 
1fdc				;nop 
1fdc				endm 
1fdc			 
1fdc			macro_forth_loop_next: 
1fdc				if DEBUG_FORTH_STACK_GUARD 
1fdc cd 3c 64				call check_stacks 
1fdf				endif 
1fdf e5				push hl 
1fe0 d5				push de 
1fe1 eb				ex de,hl 
1fe2 2a 89 fc			ld hl,(cli_loop_sp) 
1fe5 23				inc hl 
1fe6 23				inc hl 
1fe7					if DEBUG_FORTH_WORDS 
1fe7						DMARK "LNX" 
1fe7 f5				push af  
1fe8 3a fc 1f			ld a, (.dmark)  
1feb 32 b4 fe			ld (debug_mark),a  
1fee 3a fd 1f			ld a, (.dmark+1)  
1ff1 32 b5 fe			ld (debug_mark+1),a  
1ff4 3a fe 1f			ld a, (.dmark+2)  
1ff7 32 b6 fe			ld (debug_mark+2),a  
1ffa 18 03			jr .pastdmark  
1ffc ..			.dmark: db "LNX"  
1fff f1			.pastdmark: pop af  
2000			endm  
# End of macro DMARK
2000						CALLMONITOR 
2000 cd 57 17			call break_point_state  
2003				endm  
# End of macro CALLMONITOR
2003					endif 
2003 22 89 fc			ld (cli_loop_sp),hl 
2006 73				ld (hl), e 
2007 23				inc hl 
2008 72				ld (hl), d 
2009 d1				pop de    ; been reversed so save a swap on restore 
200a e1				pop hl 
200b				if DEBUG_FORTH_STACK_GUARD 
200b cd 3c 64				call check_stacks 
200e				endif 
200e c9				ret 
200f			 
200f			; get current ret stack pointer and save to hl  
200f				 
200f			FORTH_LOOP_TOS: macro 
200f				call macro_forth_loop_tos 
200f				endm 
200f			 
200f			macro_forth_loop_tos: 
200f d5				push de 
2010 2a 89 fc			ld hl,(cli_loop_sp) 
2013 5e				ld e, (hl) 
2014 23				inc hl 
2015 56				ld d, (hl) 
2016 eb				ex de, hl 
2017 d1				pop de 
2018 c9				ret 
2019			 
2019			; pop loop stack pointer 
2019				 
2019			FORTH_LOOP_POP: macro 
2019				call macro_forth_loop_pop 
2019				endm 
2019			 
2019			 
2019			macro_forth_loop_pop: 
2019				if DEBUG_FORTH_STACK_GUARD 
2019					DMARK "LPP" 
2019 f5				push af  
201a 3a 2e 20			ld a, (.dmark)  
201d 32 b4 fe			ld (debug_mark),a  
2020 3a 2f 20			ld a, (.dmark+1)  
2023 32 b5 fe			ld (debug_mark+1),a  
2026 3a 30 20			ld a, (.dmark+2)  
2029 32 b6 fe			ld (debug_mark+2),a  
202c 18 03			jr .pastdmark  
202e ..			.dmark: db "LPP"  
2031 f1			.pastdmark: pop af  
2032			endm  
# End of macro DMARK
2032 cd 3c 64				call check_stacks 
2035					FORTH_CHK_LOOP_UNDER 
2035 e5				push hl 
2036 d5				push de 
2037 2a 89 fc			ld hl,(cli_loop_sp) 
203a 11 c3 fb			ld de, cli_loop_stack 
203d cd f8 0d			call cmp16 
2040 da 56 65			jp c, fault_loop_under 
2043 d1				pop de 
2044 e1				pop hl 
2045				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2045				endif 
2045 e5				push hl 
2046 2a 89 fc			ld hl,(cli_loop_sp) 
2049 2b				dec hl 
204a 2b				dec hl 
204b 22 89 fc			ld (cli_loop_sp), hl 
204e				; TODO do stack underflow checks 
204e e1				pop hl 
204f				if DEBUG_FORTH_STACK_GUARD 
204f cd 3c 64				call check_stacks 
2052					FORTH_CHK_LOOP_UNDER 
2052 e5				push hl 
2053 d5				push de 
2054 2a 89 fc			ld hl,(cli_loop_sp) 
2057 11 c3 fb			ld de, cli_loop_stack 
205a cd f8 0d			call cmp16 
205d da 56 65			jp c, fault_loop_under 
2060 d1				pop de 
2061 e1				pop hl 
2062				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2062				endif 
2062 c9				ret 
2063			 
2063			macro_forth_dsp_pop: 
2063			 
2063 e5				push hl 
2064			 
2064				; release malloc data 
2064			 
2064				if DEBUG_FORTH_STACK_GUARD 
2064 cd 3c 64				call check_stacks 
2067					FORTH_CHK_DSP_UNDER 
2067 e5				push hl 
2068 d5				push de 
2069 2a 87 fc			ld hl,(cli_data_sp) 
206c 11 c1 f9			ld de, cli_data_stack 
206f cd f8 0d			call cmp16 
2072 da 4a 65			jp c, fault_dsp_under 
2075 d1				pop de 
2076 e1				pop hl 
2077				endm 
# End of macro FORTH_CHK_DSP_UNDER
2077				endif 
2077				;ld hl,(cli_data_sp) 
2077			if DEBUG_FORTH_DOT 
2077				DMARK "DPP" 
2077				CALLMONITOR 
2077			endif	 
2077			 
2077			 
2077			if FORTH_ENABLE_DSPPOPFREE 
2077			 
2077				FORTH_DSP 
2077 cd 71 1f			call macro_forth_dsp 
207a				endm 
# End of macro FORTH_DSP
207a			 
207a 7e				ld a, (hl) 
207b fe 01			cp DS_TYPE_STR 
207d 20 07			jr nz, .skippopfree 
207f			 
207f				FORTH_DSP_VALUEHL 
207f cd ab 1f			call macro_dsp_valuehl 
2082				endm 
# End of macro FORTH_DSP_VALUEHL
2082 00				nop 
2083			if DEBUG_FORTH_DOT 
2083				DMARK "DPf" 
2083				CALLMONITOR 
2083			endif	 
2083 cd 6b 13			call free 
2086			.skippopfree: 
2086				 
2086			 
2086			endif 
2086			 
2086			if DEBUG_FORTH_DOT_KEY 
2086				DMARK "DP2" 
2086				CALLMONITOR 
2086			endif	 
2086			 
2086				; move pointer down 
2086			 
2086 2a 87 fc			ld hl,(cli_data_sp) 
2089 2b				dec hl 
208a 2b				dec hl 
208b			; PARSEV5 
208b 2b				dec hl 
208c 22 87 fc			ld (cli_data_sp), hl 
208f			 
208f				if DEBUG_FORTH_STACK_GUARD 
208f cd 3c 64				call check_stacks 
2092					FORTH_CHK_DSP_UNDER 
2092 e5				push hl 
2093 d5				push de 
2094 2a 87 fc			ld hl,(cli_data_sp) 
2097 11 c1 f9			ld de, cli_data_stack 
209a cd f8 0d			call cmp16 
209d da 4a 65			jp c, fault_dsp_under 
20a0 d1				pop de 
20a1 e1				pop hl 
20a2				endm 
# End of macro FORTH_CHK_DSP_UNDER
20a2				endif 
20a2			 
20a2 e1				pop hl 
20a3			 
20a3 c9				ret 
20a4			 
20a4			getwordathl: 
20a4				; hl points to an address 
20a4				; load hl with the word at that address 
20a4			 
20a4 d5				push de 
20a5			 
20a5 5e				ld e, (hl) 
20a6 23				inc hl 
20a7 56				ld d, (hl) 
20a8 eb				ex de, hl 
20a9			 
20a9 d1				pop de 
20aa c9				ret 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			; eof 
20ab			 
# End of file forth_stackopsv5.asm
20ab			endif 
20ab			 
20ab			user_word_eol:  
20ab				; hl contains the pointer to where to create a linked list item from the end 
20ab				; of the user dict to continue on at the system word dict 
20ab				 
20ab				; poke the stub of the word list linked list to repoint to rom words 
20ab			 
20ab				; stub format 
20ab				; db   word id 
20ab				; dw    link to next word 
20ab			        ; db char length of token 
20ab				; db string + 0 term 
20ab				; db exec code....  
20ab			 
20ab 3e 00			ld a, WORD_SYS_ROOT     ; root word 
20ad 77				ld (hl), a		; word id 
20ae 23				inc hl 
20af			 
20af 11 75 22			ld de, sysdict 
20b2 73				ld (hl), e		; next word link ie system dict 
20b3 23				inc hl 
20b4 72				ld (hl), d		; next word link ie system dict 
20b5 23				inc hl	 
20b6			 
20b6			;	ld (hl), sysdict		; next word link ie system dict 
20b6			;	inc hl 
20b6			;	inc hl 
20b6			 
20b6			;	inc hl 
20b6			;	inc hl 
20b6			 
20b6 3e 02			ld a, 2			; word length is 0 
20b8 77				ld (hl), a	 
20b9 23				inc hl 
20ba			 
20ba 3e 7e			ld a, '~'			; word length is 0 
20bc 77				ld (hl), a	 
20bd 23				inc hl 
20be 3e 00			ld a, 0			; save empty word 
20c0 77				ld (hl), a 
20c1			 
20c1 c9				ret 
20c2			 
20c2				 
20c2			 
20c2			forthexec_cleanup: 
20c2				FORTH_RSP_POP 
20c2 cd 7c 1d			call macro_forth_rsp_pop 
20c5				endm 
# End of macro FORTH_RSP_POP
20c5 c9				ret 
20c6			 
20c6			forth_call_hl: 
20c6				; taking hl 
20c6 e5				push hl 
20c7 c9				ret 
20c8			 
20c8			; this is called to reset Forth system but keep existing uwords etc 
20c8			 
20c8			forth_warmstart: 
20c8				; setup stack over/under flow checks 
20c8				if DEBUG_FORTH_STACK_GUARD 
20c8 cd 22 64				call chk_stk_init 
20cb				endif 
20cb			 
20cb				; init stack pointers  - * these stacks go upwards *  
20cb 21 45 fc			ld hl, cli_ret_stack 
20ce 22 8b fc			ld (cli_ret_sp), hl	 
20d1				; set bottom of stack 
20d1 3e 00			ld a,0 
20d3 77				ld (hl),a 
20d4 23				inc hl 
20d5 77				ld (hl),a 
20d6			 
20d6 21 c1 f9			ld hl, cli_data_stack 
20d9 22 87 fc			ld (cli_data_sp), hl	 
20dc				; set bottom of stack 
20dc 3e 00			ld a,0 
20de 77				ld (hl),a 
20df 23				inc hl 
20e0 77				ld (hl),a 
20e1			 
20e1 21 c3 fb			ld hl, cli_loop_stack 
20e4 22 89 fc			ld (cli_loop_sp), hl	 
20e7				; set bottom of stack 
20e7 3e 00			ld a,0 
20e9 77				ld (hl),a 
20ea 23				inc hl 
20eb 77				ld (hl),a 
20ec			 
20ec				; init extent of current open file 
20ec			 
20ec 3e 00			ld a, 0 
20ee 32 d6 fc			ld (store_openext), a 
20f1			 
20f1 c9				ret 
20f2			 
20f2			 
20f2			; Cold Start - this is called to setup the whole Forth system 
20f2			 
20f2			forth_init: 
20f2			 
20f2				; setup stack over/under flow checks 
20f2			 
20f2			;	if DEBUG_FORTH_STACK_GUARD 
20f2			;		call chk_stk_init 
20f2			;	endif 
20f2			 
20f2				; enable auto display updates (slow.....) 
20f2			 
20f2 3e 01			ld a, 1 
20f4 32 a1 fc			ld (cli_autodisplay), a 
20f7			 
20f7			 
20f7			 
20f7				; show start up screen 
20f7			 
20f7 cd a6 0b			call clear_display 
20fa			 
20fa 3e 00			ld a,0 
20fc 32 c3 fc			ld (f_cursor_ptr), a 
20ff			 
20ff				; set start of word list in start of ram - for use when creating user words 
20ff			 
20ff 21 00 80			ld hl, baseram 
2102 22 57 f7			ld (os_last_new_uword), hl 
2105 cd ab 20			call user_word_eol 
2108				 
2108			;		call display_data_sp 
2108			;		call next_page_prompt 
2108			 
2108			 
2108			 
2108			 
2108 c9				ret 
2109			 
2109 .. 00		.bootforth: db " Forth Kernel Init ",0 
211d			 
211d			; TODO push to stack 
211d			 
211d			;  
211d			 
211d			if FORTH_PARSEV2 
211d			 
211d			 
211d				include "forth_parserv2.asm" 
211d			 
211d			endif 
211d			 
211d			 
211d			; parse cli version 1 
211d			 
211d			if FORTH_PARSEV1 
211d			 
211d			 
211d			 
211d			      include "forth_parserv1.asm" 
211d			endif 
211d				 
211d			if FORTH_PARSEV3 
211d			 
211d			 
211d			 
211d			      include "forth_parserv3.asm" 
211d				include "forth_wordsv3.asm" 
211d			endif 
211d			 
211d			if FORTH_PARSEV4 
211d			 
211d			 
211d			 
211d			      include "forth_parserv4.asm" 
211d				include "forth_wordsv4.asm" 
211d			endif 
211d			 
211d			if FORTH_PARSEV5 
211d			 
211d			 
211d			 
211d			      include "forth_parserv5.asm" 
211d			 
211d			 
211d			; A better parser without using malloc and string copies all over the place.  
211d			; Exec in situ should be faster 
211d			 
211d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
211d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
211d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
211d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
211d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
211d			WORD_SYS_END: equ 0   ; Opcode for all user words 
211d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
211d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
211d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
211d			 
211d			; Core word preamble macro 
211d			 
211d			CWHEAD:   macro nxtword opcode lit len opflags 
211d				db WORD_SYS_CORE+opcode             
211d				; internal op code number 
211d				dw nxtword            
211d				; link to next dict word block 
211d				db len + 1 
211d				; literal length of dict word inc zero term 
211d				db lit,0              
211d				; literal dict word 
211d			        ; TODO db opflags        
211d				endm 
211d			 
211d			 
211d			NEXTW: macro  
211d				jp macro_next 
211d				endm 
211d			 
211d			macro_next: 
211d			if DEBUG_FORTH_PARSE_KEY 
211d				DMARK "NXT" 
211d				CALLMONITOR 
211d			endif	 
211d			;	inc hl  ; skip token null term  
211d ed 4b a5 fc		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2121 ed 5b a3 fc		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2125 2a 5b f7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2128			if DEBUG_FORTH_PARSE_KEY 
2128				DMARK "}AA" 
2128				CALLMONITOR 
2128			endif	 
2128 c3 2b 22			jp execnext 
212b				;jp exec1 
212b			       
212b			 
212b			 
212b			; Another go at the parser to compile  
212b			 
212b			 
212b			; TODO rework parser to change all of the string words to byte tokens 
212b			; TODO do a search for  
212b			 
212b			; TODO first run normal parser to zero term sections 
212b			; TODO for each word do a token look up to get the op code 
212b			; TODO need some means to flag to the exec that this is a byte code form    
212b			 
212b			 
212b			forthcompile: 
212b			 
212b			; 
212b			; line parse: 
212b			;       parse raw input buffer 
212b			;       tokenise the words 
212b			;       malloc new copy (for looping etc) 
212b			;       copy to malloc + current pc in line to start of string and add line term 
212b			;       save on new rsp 
212b			; 
212b			 
212b			; hl to point to the line to tokenise 
212b			 
212b			;	push hl 
212b 22 5b f7			ld (os_tok_ptr), hl  ; save ptr to string 
212e			 
212e			;	ld a,0		; string term on input 
212e			;	call strlent 
212e			 
212e			;	ld (os_tok_len), hl	 ; save string length 
212e			 
212e			;if DEBUG_FORTH_TOK 
212e			;	ex de,hl		 
212e			;endif 
212e			 
212e			;	pop hl 		; get back string pointer 
212e			 
212e			if DEBUG_FORTH_TOK 
212e						DMARK "TOc" 
212e				CALLMONITOR 
212e			endif 
212e 7e			.cptoken2:    ld a,(hl) 
212f 23				inc hl 
2130 fe 7f			cp FORTH_END_BUFFER 
2132 28 29			jr z, .cptokendone2 
2134 fe 00			cp 0 
2136 28 25			jr z, .cptokendone2 
2138 fe 22			cp '"' 
213a 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
213c fe 20			cp ' ' 
213e 20 ee			jr nz,  .cptoken2 
2140			 
2140			; TODO consume comments held between ( and ) 
2140			 
2140				; we have a space so change to zero term for dict match later 
2140 2b				dec hl 
2141 3e 00			ld a,0 
2143 77				ld (hl), a 
2144 23				inc hl 
2145 18 e7			jr .cptoken2 
2147				 
2147			 
2147			.cptokenstr2: 
2147				; skip all white space until either eol (because forgot to term) or end double quote 
2147			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2147				;inc hl ; skip current double quote 
2147 7e				ld a,(hl) 
2148 23				inc hl 
2149 fe 22			cp '"' 
214b 28 e1			jr z, .cptoken2 
214d fe 7f			cp FORTH_END_BUFFER 
214f 28 0c			jr z, .cptokendone2 
2151 fe 00			cp 0 
2153 28 08			jr z, .cptokendone2 
2155 fe 20			cp ' ' 
2157 28 02			jr z, .cptmp2 
2159 18 ec			jr .cptokenstr2 
215b			 
215b			.cptmp2:	; we have a space so change to zero term for dict match later 
215b				;dec hl 
215b				;ld a,"-"	; TODO remove this when working 
215b				;ld (hl), a 
215b				;inc hl 
215b 18 ea			jr .cptokenstr2 
215d			 
215d			.cptokendone2: 
215d				;inc hl 
215d 3e 7f			ld a, FORTH_END_BUFFER 
215f 77				ld (hl),a 
2160 23				inc hl 
2161 3e 21			ld a, '!' 
2163 77				ld (hl),a 
2164			 
2164 2a 5b f7			ld hl,(os_tok_ptr) 
2167			         
2167			if DEBUG_FORTH_TOK 
2167						DMARK "Tc1" 
2167				CALLMONITOR 
2167			endif 
2167			 
2167				; push exec string to top of return stack 
2167				FORTH_RSP_NEXT 
2167 cd 5b 1d			call macro_forth_rsp_next 
216a				endm 
# End of macro FORTH_RSP_NEXT
216a c9				ret 
216b			 
216b			; Another go at the parser need to simplify the process 
216b			 
216b			forthparse: 
216b			 
216b			; 
216b			; line parse: 
216b			;       parse raw input buffer 
216b			;       tokenise the words 
216b			;       malloc new copy (for looping etc) 
216b			;       copy to malloc + current pc in line to start of string and add line term 
216b			;       save on new rsp 
216b			; 
216b			 
216b			; hl to point to the line to tokenise 
216b			 
216b			;	push hl 
216b 22 5b f7			ld (os_tok_ptr), hl  ; save ptr to string 
216e			 
216e			;	ld a,0		; string term on input 
216e			;	call strlent 
216e			 
216e			;	ld (os_tok_len), hl	 ; save string length 
216e			 
216e			;if DEBUG_FORTH_TOK 
216e			;	ex de,hl		 
216e			;endif 
216e			 
216e			;	pop hl 		; get back string pointer 
216e			 
216e			if DEBUG_FORTH_TOK 
216e						DMARK "TOK" 
216e				CALLMONITOR 
216e			endif 
216e 7e			.ptoken2:    ld a,(hl) 
216f 23				inc hl 
2170 fe 7f			cp FORTH_END_BUFFER 
2172 28 29			jr z, .ptokendone2 
2174 fe 00			cp 0 
2176 28 25			jr z, .ptokendone2 
2178 fe 22			cp '"' 
217a 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
217c fe 20			cp ' ' 
217e 20 ee			jr nz,  .ptoken2 
2180			 
2180			; TODO consume comments held between ( and ) 
2180			 
2180				; we have a space so change to zero term for dict match later 
2180 2b				dec hl 
2181 3e 00			ld a,0 
2183 77				ld (hl), a 
2184 23				inc hl 
2185 18 e7			jr .ptoken2 
2187				 
2187			 
2187			.ptokenstr2: 
2187				; skip all white space until either eol (because forgot to term) or end double quote 
2187			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2187				;inc hl ; skip current double quote 
2187 7e				ld a,(hl) 
2188 23				inc hl 
2189 fe 22			cp '"' 
218b 28 e1			jr z, .ptoken2 
218d fe 7f			cp FORTH_END_BUFFER 
218f 28 0c			jr z, .ptokendone2 
2191 fe 00			cp 0 
2193 28 08			jr z, .ptokendone2 
2195 fe 20			cp ' ' 
2197 28 02			jr z, .ptmp2 
2199 18 ec			jr .ptokenstr2 
219b			 
219b			.ptmp2:	; we have a space so change to zero term for dict match later 
219b				;dec hl 
219b				;ld a,"-"	; TODO remove this when working 
219b				;ld (hl), a 
219b				;inc hl 
219b 18 ea			jr .ptokenstr2 
219d			 
219d			.ptokendone2: 
219d				;inc hl 
219d 3e 7f			ld a, FORTH_END_BUFFER 
219f 77				ld (hl),a 
21a0 23				inc hl 
21a1 3e 21			ld a, '!' 
21a3 77				ld (hl),a 
21a4			 
21a4 2a 5b f7			ld hl,(os_tok_ptr) 
21a7			         
21a7			if DEBUG_FORTH_TOK 
21a7						DMARK "TK1" 
21a7				CALLMONITOR 
21a7			endif 
21a7			 
21a7				; push exec string to top of return stack 
21a7				FORTH_RSP_NEXT 
21a7 cd 5b 1d			call macro_forth_rsp_next 
21aa				endm 
# End of macro FORTH_RSP_NEXT
21aa c9				ret 
21ab			 
21ab			; 
21ab			;	; malloc size + buffer pointer + if is loop flag 
21ab			;	ld hl,(os_tok_len) 		 ; get string length 
21ab			; 
21ab			;	ld a,l 
21ab			; 
21ab			;	cp 0			; we dont want to use a null string 
21ab			;	ret z 
21ab			; 
21ab			;;	add 3    ; prefix malloc with buffer for current word ptr 
21ab			; 
21ab			;	add 5     ; TODO when certain not over writing memory remove 
21ab			; 
21ab			;		 
21ab			; 
21ab			;if DEBUG_FORTH_TOK 
21ab			;			DMARK "TKE" 
21ab			;	CALLMONITOR 
21ab			;endif 
21ab			; 
21ab			;	ld l,a 
21ab			;	ld h,0 
21ab			;;	push hl   ; save required space for the copy later 
21ab			;	call malloc 
21ab			;if DEBUG_FORTH_TOK 
21ab			;			DMARK "TKM" 
21ab			;	CALLMONITOR 
21ab			;endif 
21ab			;	if DEBUG_FORTH_MALLOC_GUARD 
21ab			;		push af 
21ab			;		call ishlzero 
21ab			;;		ld a, l 
21ab			;;		add h 
21ab			;;		cp 0 
21ab			;		pop af 
21ab			;		 
21ab			;		call z,malloc_error 
21ab			;	endif 
21ab			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
21ab			; 
21ab			; 
21ab			;if DEBUG_FORTH_TOK 
21ab			;			DMARK "TKR" 
21ab			;	CALLMONITOR 
21ab			;endif 
21ab			; 
21ab			;	FORTH_RSP_NEXT 
21ab			; 
21ab			;	;inc hl	 ; go past current buffer pointer 
21ab			;	;inc hl 
21ab			;	;inc hl   ; and past if loop flag 
21ab			;		; TODO Need to set flag  
21ab			; 
21ab			;	 
21ab			;	 
21ab			;	ex de,hl	; malloc is dest 
21ab			;	ld hl, (os_tok_len) 
21ab			;;	pop bc 
21ab			;	ld c, l                
21ab			;	ld b,0 
21ab			;	ld hl, (os_tok_ptr) 
21ab			; 
21ab			;if DEBUG_FORTH_TOK 
21ab			;			DMARK "TKT" 
21ab			;	CALLMONITOR 
21ab			;endif 
21ab			; 
21ab			;	; do str cpy 
21ab			; 
21ab			;	ldir      ; copy byte in hl to de 
21ab			; 
21ab			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
21ab			; 
21ab			;if DEBUG_FORTH_TOK 
21ab			; 
21ab			;			DMARK "TKY" 
21ab			;	CALLMONITOR 
21ab			;endif 
21ab			;	;ld a,0 
21ab			;	;ld a,FORTH_END_BUFFER 
21ab			;	ex de, hl 
21ab			;	;dec hl			 ; go back over the space delim at the end of word 
21ab			;	;ld (hl),a 
21ab			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
21ab			;	ld a,FORTH_END_BUFFER 
21ab			;	ld (hl),a 
21ab			;	inc hl 
21ab			;	ld a,FORTH_END_BUFFER 
21ab			;	ld (hl),a 
21ab			; 
21ab			;	; init the malloc area data 
21ab			;	; set pc for in current area 
21ab			;	;ld hl, (os_tok_malloc) 
21ab			;	;inc hl 
21ab			;	;inc hl 
21ab			;	;inc hl 
21ab			;	;ex de,hl 
21ab			;	;ld hl, (os_tok_malloc) 
21ab			;	;ld (hl),e 
21ab			;	;inc hl 
21ab			;	;ld (hl),d 
21ab			; 
21ab			; 
21ab			;	ld hl,(os_tok_malloc) 
21ab			;if DEBUG_FORTH_PARSE_KEY 
21ab			;			DMARK "TKU" 
21ab			;	CALLMONITOR 
21ab			;endif 
21ab			; 
21ab			;	ret 
21ab			 
21ab			forthexec: 
21ab			 
21ab			; line exec: 
21ab			; forth parser 
21ab			 
21ab			; 
21ab			;       get current exec line on rsp 
21ab			 
21ab				FORTH_RSP_TOS 
21ab cd 72 1d			call macro_forth_rsp_tos 
21ae				endm 
# End of macro FORTH_RSP_TOS
21ae			 
21ae			;       restore current pc - hl points to malloc of data 
21ae			 
21ae				;ld e, (hl) 
21ae				;inc hl 
21ae				;ld d, (hl) 
21ae				;ex de,hl 
21ae			 
21ae			 
21ae			exec1: 
21ae 22 5b f7			ld (os_tok_ptr), hl 
21b1			 
21b1				; copy our PC to working vars  
21b1 22 a5 fc			ld (cli_ptr), hl 
21b4 22 a3 fc			ld (cli_origptr), hl 
21b7			 
21b7 7e				ld a,(hl) 
21b8 fe 7f			cp FORTH_END_BUFFER 
21ba c8				ret z 
21bb			 
21bb				; skip any nulls 
21bb			 
21bb fe 00			cp 0 
21bd 20 03			jr nz, .execword 
21bf 23				inc hl 
21c0 18 ec			jr exec1 
21c2			 
21c2			 
21c2			.execword: 
21c2			 
21c2			 
21c2			 
21c2			if DEBUG_FORTH_PARSE_KEY 
21c2						DMARK "KYQ" 
21c2				CALLMONITOR 
21c2			endif 
21c2			;       while at start of word: 
21c2			; get start of dict (in user area first) 
21c2			 
21c2 21 00 80		ld hl, baseram 
21c5			;ld hl, sysdict 
21c5 22 a7 fc		ld (cli_nextword),hl 
21c8			;           match word at pc 
21c8			;           exec word 
21c8			;           or push to dsp 
21c8			;           forward to next token 
21c8			;           if line term pop rsp and exit 
21c8			;        
21c8			 
21c8			if DEBUG_FORTH_PARSE_KEY 
21c8						DMARK "KYq" 
21c8				CALLMONITOR 
21c8			endif 
21c8			 
21c8			; 
21c8			; word comp 
21c8			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
21c8			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
21c8			;    move to start of word  
21c8			;    compare word to cli_token 
21c8			 
21c8			.execpnword:	; HL at start of a word in the dictionary to check 
21c8			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
21c8			;	ld (cli_ptr), hl 
21c8			 
21c8 2a a7 fc			ld hl,(cli_nextword) 
21cb			 
21cb cd 6e 22			call forth_tok_next 
21ce			; tok next start here 
21ce			;	; TODO skip compiled symbol for now 
21ce			;	inc hl 
21ce			; 
21ce			;	; save pointer to next word 
21ce			; 
21ce			;	; hl now points to the address of the next word pointer  
21ce			;	ld e, (hl) 
21ce			;	inc hl 
21ce			;	ld d, (hl) 
21ce			;	inc l 
21ce			; 
21ce			;	ex de,hl 
21ce			;if DEBUG_FORTH_PARSE_NEXTWORD 
21ce			;	push bc 
21ce			;	ld bc, (cli_nextword) 
21ce			;			DMARK "NXW" 
21ce			;	CALLMONITOR 
21ce			;	pop bc 
21ce			;endif 
21ce			; tok next end here 
21ce 22 a7 fc			ld (cli_nextword), hl     ; save for next check if no match on this word 
21d1 eb				ex de, hl 
21d2			 
21d2			 
21d2				; save the pointer of the current token - 1 to check against 
21d2				 
21d2 22 ab fc			ld (cli_token), hl   
21d5				; TODO maybe remove below save if no debug 
21d5				; save token string ptr for any debug later 
21d5 23				inc hl  
21d6 22 ad fc			ld (cli_origtoken), hl 
21d9 2b				dec hl 
21da				; save pointer to the start of the next dictionay word 
21da 7e				ld a,(hl)   ; get string length 
21db 47				ld b,a 
21dc			.execpnwordinc:  
21dc 23				inc hl 
21dd 10 fd			djnz .execpnwordinc 
21df 22 a9 fc			ld (cli_execword), hl      ; save start of this words code 
21e2			 
21e2				; now check the word token against the string being parsed 
21e2			 
21e2 2a ab fc			ld hl,(cli_token) 
21e5 23				inc hl     ; skip string length (use zero term instead to end) 
21e6 22 ab fc			ld (cli_token), hl 
21e9			 
21e9			if DEBUG_FORTH_PARSE_KEY 
21e9						DMARK "KY2" 
21e9			endif 
21e9			if DEBUG_FORTH_PARSE_EXEC 
21e9				; see if disabled 
21e9			 
21e9				ld a, (os_view_disable) 
21e9				cp '*' 
21e9				jr z, .skip 
21e9			 
21e9				push hl 
21e9				push hl 
21e9				call clear_display 
21e9				ld de, .compword 
21e9				ld a, display_row_1 
21e9				call str_at_display 
21e9				pop de 
21e9				ld a, display_row_2 
21e9				call str_at_display 
21e9				ld hl,(cli_ptr) 
21e9				ld a,(hl) 
21e9			        ld hl, os_word_scratch 
21e9				ld (hl),a 
21e9				ld a,0 
21e9				inc hl 
21e9				ld (hl),a 	 
21e9				ld de, os_word_scratch 
21e9				ld a, display_row_2+10 
21e9				call str_at_display 
21e9				call update_display 
21e9				ld a, 100 
21e9				call aDelayInMS 
21e9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
21e9				call delay250ms 
21e9				endif 
21e9				pop hl 
21e9			.skip:  
21e9			endif	 
21e9			.execpnchar:    ; compare char between token and string to parse 
21e9			 
21e9			if DEBUG_FORTH_PARSE_KEY 
21e9						DMARK "Ky3" 
21e9			endif 
21e9			if DEBUG_FORTH_PARSE_EXEC 
21e9				; see if disabled 
21e9			 
21e9				ld a, (os_view_disable) 
21e9				cp '*' 
21e9				jr z, .skip2 
21e9			 
21e9			;	call clear_display 
21e9			ld hl,(cli_token) 
21e9			ld a,(hl) 
21e9			ld (os_word_scratch),a 
21e9				ld hl,(cli_ptr) 
21e9			ld a,(hl) 
21e9				ld (os_word_scratch+1),a 
21e9				ld a,0 
21e9				ld (os_word_scratch+2),a 
21e9				ld de,os_word_scratch 
21e9				ld a,display_row_4 
21e9				call str_at_display 
21e9				call update_display 
21e9			.skip2:  
21e9			endif 
21e9 2a ab fc			ld hl,(cli_token) 
21ec 7e				ld a, (hl)	 ; char in word token 
21ed 23				inc hl 		; move to next char 
21ee 22 ab fc			ld (cli_token), hl ; and save it 
21f1 47				ld b,a 
21f2			 
21f2 2a a5 fc			ld hl,(cli_ptr) ;	get the char from the string to parse 
21f5 7e				ld a,(hl) 
21f6 23				inc hl 
21f7 22 a5 fc			ld (cli_ptr), hl		; move to next char 
21fa cd 2f 12			call toUpper 		; make sure the input string matches case 
21fd			 
21fd			if DEBUG_FORTH_PARSE 
21fd			endif 
21fd			 
21fd				; input stream end of token is a space so get rid of it 
21fd			 
21fd			;	cp ' ' 
21fd			;	jr nz, .pnskipspace 
21fd			; 
21fd			;	ld a, 0		; make same term as word token term 
21fd			; 
21fd			;.pnskipspace: 
21fd			 
21fd			if DEBUG_FORTH_PARSE_KEY 
21fd						DMARK "KY7" 
21fd			endif 
21fd b8				cp b 
21fe c2 14 22			jp nz, .execpnskipword	 ; no match so move to next word 
2201				 
2201			;    if same 
2201			;       scan for string terms 0 for token and 32 for input 
2201			 
2201				 
2201			if DEBUG_FORTH_PARSE_KEY 
2201						DMARK "KY8" 
2201			endif 
2201			 
2201 80				add b			 
2202 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2204							; TODO need to make sure last word in zero term string is accounted for 
2204 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2206			 
2206			 
2206				; at end of both strings so both are exact match 
2206			 
2206			;       skip ptr for next word 
2206			 
2206 2a a5 fc			ld hl,(cli_ptr) 	; at input string term 
2209 23				inc hl			 ; at next char 
220a 22 a5 fc			ld (cli_ptr), hl     ; save for next round of the parser 
220d 22 a3 fc			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2210				 
2210				 
2210			if DEBUG_FORTH_PARSE_KEY 
2210						DMARK "KY3" 
2210			endif 
2210			 
2210			 
2210			 
2210			;       exec code block 
2210			if DEBUG_FORTH_JP 
2210				call clear_display 
2210				call update_display 
2210				call delay1s 
2210				ld hl, (cli_execword)     ; save for next check if no match on this word 
2210				ld a,h 
2210				ld hl, os_word_scratch 
2210				call hexout 
2210				ld hl, (cli_execword)     ; save for next check if no match on this word 
2210				ld a,l 
2210				ld hl, os_word_scratch+2 
2210				call hexout 
2210				ld hl, os_word_scratch+4 
2210				ld a,0 
2210				ld (hl),a 
2210				ld de,os_word_scratch 
2210				call str_at_display 
2210					ld a, display_row_2 
2210					call str_at_display 
2210				ld de, (cli_origtoken) 
2210				ld a, display_row_1+10 
2210					call str_at_display 
2210			 
2210				ld a,display_row_1 
2210				ld de, .foundword 
2210				ld a, display_row_3 
2210				call str_at_display 
2210				call update_display 
2210				call delay1s 
2210				call delay1s 
2210				call delay1s 
2210			endif 
2210			 
2210			if DEBUG_FORTH_PARSE_KEY 
2210						DMARK "KYj" 
2210			endif 
2210				; TODO save the word pointer in this exec 
2210			 
2210 2a a9 fc			ld hl,(cli_execword) 
2213 e9				jp (hl) 
2214			 
2214			 
2214			;    if not same 
2214			;	scan for zero term 
2214			;	get ptr for next word 
2214			;	goto word comp 
2214			 
2214			.execpnskipword:	; get pointer to next word 
2214 2a a7 fc			ld hl,(cli_nextword) 
2217			 
2217 7e				ld a,(hl) 
2218 fe 00			cp WORD_SYS_END 
221a			;	cp 0 
221a 28 09			jr z, .execendofdict			 ; at end of words 
221c			 
221c			if DEBUG_FORTH_PARSE_KEY 
221c						DMARK "KY4" 
221c			endif 
221c			if DEBUG_FORTH_PARSE_EXEC 
221c			 
221c				; see if disabled 
221c			 
221c				ld a, (os_view_disable) 
221c				cp '*' 
221c				jr z, .noskip 
221c			 
221c			 
221c				ld de, .nowordfound 
221c				ld a, display_row_3 
221c				call str_at_display 
221c				call update_display 
221c				ld a, 100 
221c				call aDelayInMS 
221c				 
221c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
221c					call delay250ms 
221c				endif 
221c			.noskip:  
221c			 
221c			endif	 
221c			 
221c 2a a3 fc			ld hl,(cli_origptr) 
221f 22 a5 fc			ld (cli_ptr),hl 
2222			 
2222			if DEBUG_FORTH_PARSE_KEY 
2222						DMARK "KY5" 
2222			endif 
2222 c3 c8 21			jp .execpnword			; else go to next word 
2225			 
2225			.execendofdict:  
2225			 
2225			if DEBUG_FORTH_PARSE_KEY 
2225						DMARK "KYe" 
2225			endif 
2225			if DEBUG_FORTH_PARSE_EXEC 
2225				; see if disabled 
2225			 
2225				ld a, (os_view_disable) 
2225				cp '*' 
2225				jr z, .ispskip 
2225			 
2225				call clear_display 
2225				call update_display 
2225				call delay1s 
2225				ld de, (cli_origptr) 
2225				ld a, display_row_1 
2225				call str_at_display 
2225				 
2225				ld de, .enddict 
2225				ld a, display_row_3 
2225				call str_at_display 
2225				call update_display 
2225				ld a, 100 
2225				call aDelayInMS 
2225				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2225				call delay1s 
2225				call delay1s 
2225				call delay1s 
2225				endif 
2225			.ispskip:  
2225				 
2225			endif	 
2225			 
2225			 
2225			 
2225				; if the word is not a keyword then must be a literal so push it to stack 
2225			 
2225			; push token to stack to end of word 
2225			 
2225				STACKFRAME ON $1efe $2f9f 
2225				if DEBUG_STACK_IMB 
2225					if ON 
2225						exx 
2225						ld de, $1efe 
2225						ld a, d 
2225						ld hl, curframe 
2225						call hexout 
2225						ld a, e 
2225						ld hl, curframe+2 
2225						call hexout 
2225						ld hl, $1efe 
2225						push hl 
2225						ld hl, $2f9f 
2225						push hl 
2225						exx 
2225					endif 
2225				endif 
2225			endm 
# End of macro STACKFRAME
2225			 
2225 2a 5b f7		ld hl,(os_tok_ptr) 
2228 cd 1d 1f		call forth_apush 
222b			 
222b				STACKFRAMECHK ON $1efe $2f9f 
222b				if DEBUG_STACK_IMB 
222b					if ON 
222b						exx 
222b						ld hl, $2f9f 
222b						pop de   ; $2f9f 
222b						call cmp16 
222b						jr nz, .spnosame 
222b						ld hl, $1efe 
222b						pop de   ; $1efe 
222b						call cmp16 
222b						jr z, .spfrsame 
222b						.spnosame: call showsperror 
222b						.spfrsame: nop 
222b						exx 
222b					endif 
222b				endif 
222b			endm 
# End of macro STACKFRAMECHK
222b			 
222b			execnext: 
222b			 
222b			if DEBUG_FORTH_PARSE_KEY 
222b						DMARK "KY>" 
222b			endif 
222b			; move past token to next word 
222b			 
222b 2a 5b f7		ld hl, (os_tok_ptr) 
222e 3e 00		ld a, 0 
2230 01 ff 00		ld bc, 255     ; input buffer size 
2233 ed b1		cpir 
2235			 
2235			if DEBUG_FORTH_PARSE_KEY 
2235						DMARK "KY!" 
2235				CALLMONITOR 
2235			endif	 
2235			; TODO this might place hl on the null, so will need to forward on??? 
2235			;inc hl   ; see if this gets onto the next item 
2235			 
2235			 
2235			; TODO pass a pointer to the buffer to push 
2235			; TODO call function to push 
2235			 
2235			; look for end of input 
2235			 
2235			;inc hl 
2235			;ld a,(hl) 
2235			;cp FORTH_END_BUFFER 
2235			;ret z 
2235			 
2235			 
2235 c3 ae 21		jp exec1 
2238			 
2238			 
2238			 
2238			 
2238			 
2238			 
2238			 
2238			 
2238			 
2238			findnexttok: 
2238			 
2238				; hl is pointer to move 
2238				; de is the token to locate 
2238			 
2238					if DEBUG_FORTH 
2238						DMARK "NTK" 
2238						CALLMONITOR 
2238					endif 
2238 d5				push de 
2239			 
2239			.fnt1:	 
2239				; find first char of token to locate 
2239			 
2239 1a				ld a, (de) 
223a 4f				ld c,a 
223b 7e				ld a,(hl) 
223c cd 2f 12			call toUpper 
223f					if DEBUG_FORTH 
223f						DMARK "NT1" 
223f						CALLMONITOR 
223f					endif 
223f b9				cp c 
2240			 
2240 28 03			jr z, .fnt2cmpmorefirst	 
2242			 
2242				; first char not found move to next char 
2242			 
2242 23				inc hl 
2243 18 f4			jr .fnt1 
2245			 
2245			.fnt2cmpmorefirst:	 
2245				; first char of token found.  
2245			 
2245 e5				push hl     ; save start of token just in case it is the right one 
2246 d9				exx 
2247 e1				pop hl        ; save it to hl' 
2248 d9				exx 
2249			 
2249			 
2249			.fnt2cmpmore:	 
2249				; compare the rest 
2249				 
2249 23				inc hl 
224a 13				inc de 
224b				 
224b 1a				ld a, (de) 
224c 4f				ld c,a 
224d 7e				ld a,(hl) 
224e cd 2f 12			call toUpper 
2251			 
2251					if DEBUG_FORTH 
2251						DMARK "NT2" 
2251						CALLMONITOR 
2251					endif 
2251				; c has the token to find char 
2251				; a has the mem to scan char 
2251			 
2251 b9				cp c 
2252 28 04			jr z,.fntmatch1 
2254			 
2254				; they are not the same 
2254			 
2254					if DEBUG_FORTH 
2254						DMARK "NT3" 
2254						CALLMONITOR 
2254					endif 
2254 d1				pop de	; reset de token to look for 
2255 d5				push de 
2256 18 e1			jr .fnt1 
2258				 
2258			.fntmatch1: 
2258			 
2258				; is the same char a null which means we might have a full hit? 
2258					if DEBUG_FORTH 
2258						DMARK "NT4" 
2258						CALLMONITOR 
2258					endif 
2258			 
2258 fe 00			cp 0 
225a 28 0b			jr z, .fntmatchyes 
225c			 
225c				; are we at the end of the token to find? 
225c			 
225c					if DEBUG_FORTH 
225c						DMARK "NT5" 
225c						CALLMONITOR 
225c					endif 
225c 3e 00			ld a, 0 
225e b9				cp c 
225f			 
225f c2 49 22			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2262			 
2262					if DEBUG_FORTH 
2262						DMARK "NT6" 
2262						CALLMONITOR 
2262					endif 
2262				; token to find is exhusted but no match to stream 
2262			 
2262				; restore tok pointer and continue on 
2262 d1				pop de 
2263 d5				push de 
2264 c3 39 22			jp .fnt1 
2267			 
2267			 
2267			.fntmatchyes: 
2267			 
2267				; hl now contains the end of the found token 
2267			 
2267				; get rid of saved token pointer to find 
2267			 
2267 d1				pop de 
2268			 
2268					if DEBUG_FORTH 
2268						DMARK "NT9" 
2268						CALLMONITOR 
2268					endif 
2268			 
2268				; hl will be on the null term so forward on 
2268			 
2268				; get back the saved start of the token 
2268			 
2268 d9				exx 
2269 e5				push hl     ; save start of token just in case it is the right one 
226a d9				exx 
226b e1				pop hl        ; save it to hl 
226c			 
226c c9				ret 
226d			 
226d			 
226d			; LIST needs to find a specific token   
226d			; FORGET needs to find a spefici token 
226d			 
226d			; SAVE needs to find all tokens by flag 
226d			; WORDS just needs to scan through all  by flag 
226d			; UWORDS needs to scan through all by flag 
226d			 
226d			 
226d			; given hl as pointer to start of dict look up string 
226d			; return hl as pointer to start of word block 
226d			; or 0 if not found 
226d			 
226d			forth_find_tok: 
226d c9				ret 
226e			 
226e			; given hl as pointer to dict structure 
226e			; move to the next dict block structure 
226e			 
226e			forth_tok_next: 
226e				; hl now points to the address of the next word pointer  
226e				; TODO skip compiled symbol for now 
226e			;	push de 
226e 23				inc hl 
226f 5e				ld e, (hl) 
2270 23				inc hl 
2271 56				ld d, (hl) 
2272 23				inc hl 
2273			 
2273 eb				ex de,hl 
2274			if DEBUG_FORTH_PARSE_NEXTWORD 
2274				push bc 
2274				ld bc, (cli_nextword) 
2274						DMARK "NXW" 
2274				CALLMONITOR 
2274				pop bc 
2274			endif 
2274			;	pop de	 
2274 c9				ret 
2275			 
2275			 
2275			 
2275			; eof 
# End of file forth_parserv5.asm
2275				include "forth_wordsv4.asm" 
2275			 
2275			; the core word dictionary v4 
2275			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2275			 
2275			; this is a linked list for each of the system words used 
2275			; user defined words will follow the same format but will be in ram 
2275			 
2275			 
2275			; 
2275			; 
2275			; define linked list: 
2275			; 
2275			; 1. compiled byte op code 
2275			; 2. len of text word 
2275			; 3. text word 
2275			; 4. ptr to next dictionary word 
2275			; 5. asm, calls etc for the word 
2275			; 
2275			;  if 1 == 0 then last word in dict  
2275			;   
2275			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2275			;  
2275			;  
2275			; create basic standard set of words 
2275			; 
2275			;  
2275			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2275			; 2DUP 2DROP 2SWAP  
2275			; @ C@ - get byte  
2275			; ! C! - store byte 
2275			; 0< true if less than zero 
2275			; 0= true if zero 
2275			; < >  
2275			; = true if same 
2275			; variables 
2275			 
2275			 
2275			; Hardware specific words I may need 
2275			; 
2275			; IN OUT  
2275			; calls to key util functions 
2275			; calls to hardward abstraction stuff 
2275			; easy control of frame buffers and lcd i/o 
2275			; keyboard  
2275			 
2275			 
2275			;DICT: macro 
2275			; op_code, len, word, next 
2275			;    word: 
2275			;    db op_code 
2275			;    ds word zero term 
2275			;    dw next 
2275			;    endm 
2275			 
2275			 
2275			 
2275			 
2275			; op code 1 is a flag for user define words which are to be handled differently 
2275			 
2275			 
2275			; 
2275			; 
2275			;    TODO on entry to a word this should be the expected environment 
2275			;    hl - tos value if number then held, if string this is the ptr 
2275			;    de -  
2275			 
2275			 
2275			; opcode ranges 
2275			; 0 - end of word dict 
2275			; 255 - user define words 
2275			 
2275			sysdict: 
2275			include "forth_opcodes.asm" 
2275			; op codes for forth keywords 
2275			; free to use code 0  
2275				OPCODE_HEAP: equ  1 
2275				OPCODE_EXEC: equ 2 
2275				OPCODE_DUP: equ 3 
2275				OPCODE_SWAP: equ 4 
2275				OPCODE_COLN: equ 5 
2275				OPCODE_SCOLN: equ 6 
2275				OPCODE_DROP: equ 7 
2275				OPCODE_DUP2: equ 8 
2275				OPCODE_DROP2: equ 9 
2275				OPCODE_SWAP2: equ 10 
2275				OPCODE_AT: equ 11 
2275				OPCODE_CAT: equ 12 
2275				OPCODE_BANG: equ 13 
2275				OPCODE_CBANG: equ 14 
2275				OPCODE_SCALL: equ 15 
2275				OPCODE_DEPTH: equ 16 
2275				OPCODE_OVER: equ 17 
2275				OPCODE_PAUSE: equ 18 
2275				OPCODE_PAUSES: equ 19 
2275				OPCODE_ROT: equ 20 
2275			;free to reuse	OPCODE_WORDS: equ 21 
2275			        OPCODE_NOT: equ 21 
2275				OPCODE_UWORDS: equ 22 
2275				OPCODE_BP: equ 23 
2275				OPCODE_MONITOR: equ 24  
2275				OPCODE_MALLOC: equ 25 
2275				OPCODE_FREE: equ 26 
2275				OPCODE_LIST: equ 27 
2275				OPCODE_FORGET: equ 28 
2275				OPCODE_NOP: equ 29 
2275				OPCODE_COMO: equ 30 
2275				OPCODE_COMC: equ 31 
2275			;free to reuse	OPCODE_ENDCORE: equ 32 
2275				OPCODE_AFTERSOUND: equ 33 
2275				OPCODE_GP2: equ 34 
2275				OPCODE_GP3: equ 35 
2275				OPCODE_GP4: equ 36 
2275				OPCODE_SIN: equ 37 
2275				OPCODE_SOUT: equ 38 
2275				OPCODE_SPIO: equ 39 
2275				OPCODE_SPICEH: equ 40 
2275				OPCODE_SPIOb: equ 41 
2275				OPCODE_SPII: equ 42 
2275				OPCODE_SESEL: equ 43 
2275				OPCODE_CARTDEV: equ 44 
2275			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2275				OPCODE_FB: equ 46 
2275				OPCODE_EMIT: equ 47 
2275				OPCODE_DOTH: equ 48 
2275				OPCODE_DOTF: equ 49 
2275				OPCODE_DOT: equ 50 
2275				OPCODE_CLS: equ 51 
2275				OPCODE_DRAW: equ 52 
2275				OPCODE_DUMP: equ 53 
2275				OPCODE_CDUMP: equ 54 
2275				OPCODE_DAT: equ 55 
2275				OPCODE_HOME: equ 56 
2275				OPCODE_SPACE: equ 57 
2275				OPCODE_SPACES: equ 58 
2275				OPCODE_SCROLL: equ 59 
2275				OPCODE_ATQ: equ 60 
2275				OPCODE_AUTODSP: equ 61 
2275				OPCODE_MENU: equ 62 
2275			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2275				OPCODE_THEN: equ 64 
2275				OPCODE_ELSE: equ 65 
2275				OPCODE_DO: equ 66 
2275				OPCODE_LOOP: equ 67 
2275				OPCODE_I: equ 68 
2275				OPCODE_DLOOP: equ 69  
2275				OPCODE_REPEAT: equ 70  
2275				OPCODE_UNTIL: equ 71 
2275				OPCODE_ENDFLOW: equ 72 
2275				OPCODE_WAITK: equ 73 
2275				OPCODE_ACCEPT: equ 74 
2275				OPCODE_EDIT: equ 75 
2275			;free to reuse	OPCODE_ENDKEY: equ 76 
2275				OPCODE_LZERO: equ 77 
2275				OPCODE_TZERO: equ 78 
2275				OPCODE_LESS: equ 79 
2275				OPCODE_GT: equ 80 
2275				OPCODE_EQUAL: equ 81  
2275			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2275				OPCODE_NEG: equ 83 
2275				OPCODE_DIV: equ 84 
2275				OPCODE_MUL: equ 85 
2275				OPCODE_MIN: equ 86 
2275				OPCODE_MAX: equ 87 
2275				OPCODE_RND16: equ 88 
2275				OPCODE_RND8: equ 89 
2275				OPCODE_RND: equ 90 
2275			;free to reuse	OPCODE_ENDMATHS: equ 91  
2275				OPCODE_BYNAME: equ 92 
2275				OPCODE_DIR: equ 93 
2275				OPCODE_SAVE: equ 94 
2275				OPCODE_LOAD: equ 95 
2275				OPCODE_BSAVE: equ 96 
2275				OPCODE_BLOAD: equ 97 
2275				OPCODE_SEO: equ 98  
2275				OPCODE_SEI: equ 99 
2275				OPCODE_SFREE: equ 100 
2275				OPCODE_SIZE: equ 101 
2275				OPCODE_CREATE: equ 102 
2275				OPCODE_APPEND: equ 103 
2275				OPCODE_SDEL: equ 104 
2275				OPCODE_OPEN: equ 105 
2275				OPCODE_READ: equ 106 
2275				OPCODE_EOF: equ 106 
2275				OPCODE_FORMAT: equ 107 
2275				OPCODE_LABEL: equ 108 
2275				OPCODE_LABELS: equ 109 
2275			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2275				OPCODE_UPPER: equ 111 
2275				OPCODE_LOWER: equ 112 
2275				OPCODE_SUBSTR: equ 113 
2275				OPCODE_LEFT: equ 114 
2275				OPCODE_RIGHT: equ 115 
2275				OPCODE_STR2NUM: equ 116 
2275				OPCODE_NUM2STR: equ 117 
2275				OPCODE_CONCAT: equ 118 
2275				OPCODE_FIND: equ 119 
2275				OPCODE_LEN: equ 120 
2275				OPCODE_CHAR: equ 121 
2275			; free to reuse	OPCODE_STRLEN: equ 122 
2275			; free to reuse	OPCODE_ENDSTR: equ 123 
2275				OPCODE_V0S: equ 124 
2275				OPCODE_V0Q: equ 125 
2275				OPCODE_V1S: equ 126 
2275				OPCODE_V1Q: equ 127 
2275				OPCODE_V2S: equ 128 
2275				OPCODE_V2Q: equ 129 
2275				OPCODE_V3S: equ 130 
2275				OPCODE_V3Q: equ 131 
2275			;free to reuse	OPCODE_END: equ 132 
2275				OPCODE_ZDUP: equ 133 
2275			 
2275			; eof 
# End of file forth_opcodes.asm
2275			 
2275			include "forth_words_core.asm" 
2275			 
2275			; | ## Core Words 
2275			 
2275			;if MALLOC_4 
2275			 
2275			.HEAP: 
2275				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2275 15				db WORD_SYS_CORE+OPCODE_HEAP             
2276 b4 22			dw .EXEC            
2278 05				db 4 + 1 
2279 .. 00			db "HEAP",0              
227e				endm 
# End of macro CWHEAD
227e			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
227e			; | | u1 - Current number of bytes in the heap 
227e			; | | u2 - Remaining bytes left on the heap 
227e			; | |  
227e			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
227e			 
227e			 
227e					if DEBUG_FORTH_WORDS_KEY 
227e						DMARK "HEP" 
227e f5				push af  
227f 3a 93 22			ld a, (.dmark)  
2282 32 b4 fe			ld (debug_mark),a  
2285 3a 94 22			ld a, (.dmark+1)  
2288 32 b5 fe			ld (debug_mark+1),a  
228b 3a 95 22			ld a, (.dmark+2)  
228e 32 b6 fe			ld (debug_mark+2),a  
2291 18 03			jr .pastdmark  
2293 ..			.dmark: db "HEP"  
2296 f1			.pastdmark: pop af  
2297			endm  
# End of macro DMARK
2297						CALLMONITOR 
2297 cd 57 17			call break_point_state  
229a				endm  
# End of macro CALLMONITOR
229a					endif 
229a 2a 0a 80				ld hl, (free_list )      
229d 11 0e 80				ld de, heap_start 
22a0			 
22a0 ed 52				sbc hl, de  
22a2			 
22a2 cd b4 1d				call forth_push_numhl 
22a5			 
22a5			 
22a5 ed 5b 0a 80			ld de, (free_list )      
22a9 21 40 f4				ld hl, heap_end 
22ac			 
22ac ed 52				sbc hl, de 
22ae			 
22ae cd b4 1d				call forth_push_numhl 
22b1					 
22b1			 
22b1					 
22b1			 
22b1			 
22b1			 
22b1					NEXTW 
22b1 c3 1d 21			jp macro_next 
22b4				endm 
# End of macro NEXTW
22b4			;endif 
22b4			 
22b4			.EXEC: 
22b4			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
22b4			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
22b4			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
22b4			;; > > 
22b4			;; > >   
22b4			;	STACKFRAME OFF $5efe $5f9f 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS_KEY 
22b4			;			DMARK "EXE" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			; 
22b4			;	FORTH_DSP_VALUEHL 
22b4			; 
22b4			;	FORTH_DSP_POP 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EX1" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;;	ld e,(hl) 
22b4			;;	inc hl 
22b4			;;	ld d,(hl) 
22b4			;;	ex de,hl 
22b4			; 
22b4			;;		if DEBUG_FORTH_WORDS 
22b4			;;			DMARK "EX2" 
22b4			;;			CALLMONITOR 
22b4			;;		endif 
22b4			;	push hl 
22b4			; 
22b4			;	;ld a, 0 
22b4			;	;ld a, FORTH_END_BUFFER 
22b4			;	call strlenz 
22b4			;	inc hl   ; include zero term to copy 
22b4			;	inc hl   ; include term 
22b4			;	inc hl   ; include term 
22b4			;	ld b,0 
22b4			;	ld c,l 
22b4			;	pop hl 
22b4			;	ld de, execscratch 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EX3" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;	ldir 
22b4			; 
22b4			; 
22b4			;	ld hl, execscratch 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EXe" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			; 
22b4			;	call forthparse 
22b4			;	call forthexec 
22b4			;;	call forthexec_cleanup 
22b4			;;	call forthparse 
22b4			;;	call forthexec 
22b4			; 
22b4			;	STACKFRAMECHK OFF $5efe $5f9f 
22b4			; 
22b4			;	; an immediate word so no need to process any more words 
22b4			;	ret 
22b4			;	NEXTW 
22b4			 
22b4			; dead code - old version  
22b4			;	FORTH_RSP_NEXT 
22b4			 
22b4			;  
22b4			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22b4			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22b4			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22b4			;	push hl 
22b4			;	push de 
22b4			;	push bc 
22b4			; 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS_KEY 
22b4			;			DMARK "EXR" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			; 
22b4			; 
22b4			; 
22b4			;	;v5 FORTH_DSP_VALUE 
22b4			;	FORTH_DSP_VALUEHL 
22b4			; 
22b4			;	; TODO do string type checks 
22b4			; 
22b4			;;v5	inc hl   ; skip type 
22b4			; 
22b4			;	push hl  ; source code  
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EX1" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;	ld a, 0 
22b4			;	call strlent 
22b4			; 
22b4			;	inc hl 
22b4			;	inc hl 
22b4			;	inc hl 
22b4			;	inc hl 
22b4			; 
22b4			;	push hl    ; size 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EX2" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;	call malloc 
22b4			; 
22b4			;	ex de, hl    ; de now contains malloc area 
22b4			;	pop bc   	; get byte count 
22b4			;	pop hl      ; get string to copy 
22b4			; 
22b4			;	push de     ; save malloc for free later 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EX3" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;	ldir       ; duplicate string 
22b4			; 
22b4			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
22b4			;	 
22b4			;	; TODO fix the parse would be better than this...  
22b4			;	ex de, hl 
22b4			;	dec hl 
22b4			;	ld a, 0 
22b4			;	ld (hl), a 
22b4			;	dec hl 
22b4			;	ld a, ' ' 
22b4			;	ld (hl), a 
22b4			;	dec hl 
22b4			;	ld (hl), a 
22b4			; 
22b4			;	dec hl 
22b4			;	ld (hl), a 
22b4			; 
22b4			; 
22b4			;	FORTH_DSP_POP  
22b4			; 
22b4			;	pop hl     
22b4			;	push hl    ; save malloc area 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EX4" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			; 
22b4			;	call forthparse 
22b4			;	call forthexec 
22b4			;	 
22b4			;	pop hl 
22b4			;	if DEBUG_FORTH_WORDS 
22b4			;		DMARK "EX5" 
22b4			;		CALLMONITOR 
22b4			;	endif 
22b4			; 
22b4			;	if FORTH_ENABLE_FREE 
22b4			;	call free 
22b4			;	endif 
22b4			; 
22b4			;	if DEBUG_FORTH_WORDS 
22b4			;		DMARK "EX6" 
22b4			;		CALLMONITOR 
22b4			;	endif 
22b4			; 
22b4			;	pop bc 
22b4			;	pop de 
22b4			;	pop hl 
22b4			;;	FORTH_RSP_POP	  
22b4			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
22b4			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
22b4			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
22b4			; 
22b4			;	if DEBUG_FORTH_WORDS 
22b4			;		DMARK "EX7" 
22b4			;		CALLMONITOR 
22b4			;	endif 
22b4			;	NEXTW 
22b4			 
22b4			;.STKEXEC: 
22b4			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
22b4			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
22b4			; 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS_KEY 
22b4			;			DMARK "STX" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			; 
22b4			;	FORTH_DSP_VALUEHL 
22b4			; 
22b4			;	ld (store_tmp1), hl    ; count 
22b4			; 
22b4			;	FORTH_DSP_POP 
22b4			;.stkexec1: 
22b4			;	ld hl, (store_tmp1)   ; count 
22b4			;	ld a, 0 
22b4			;	cp l 
22b4			;	ret z 
22b4			; 
22b4			;	dec hl 
22b4			;	ld (store_tmp1), hl    ; count 
22b4			;	 
22b4			;	FORTH_DSP_VALUEHL 
22b4			;	push hl 
22b4			;	 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EXp" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;	FORTH_DSP_POP 
22b4			; 
22b4			;	call strlenz 
22b4			;	inc hl   ; include zero term to copy 
22b4			;	inc hl   ; include zero term to copy 
22b4			;	inc hl   ; include zero term to copy 
22b4			;	ld b,0 
22b4			;	ld c,l 
22b4			;	pop hl 
22b4			;	ld de, execscratch 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EX3" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;	ldir 
22b4			; 
22b4			; 
22b4			;	ld hl, execscratch 
22b4			; 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EXP" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			; 
22b4			;	call forthparse 
22b4			;	ld hl, execscratch 
22b4			;		if DEBUG_FORTH_WORDS 
22b4			;			DMARK "EXx" 
22b4			;			CALLMONITOR 
22b4			;		endif 
22b4			;	call forthexec 
22b4			; 
22b4			;	jp .stkexec1 
22b4			; 
22b4			;	ret 
22b4			 
22b4			 
22b4			.DUP: 
22b4				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
22b4 17				db WORD_SYS_CORE+OPCODE_DUP             
22b5 2a 23			dw .ZDUP            
22b7 04				db 3 + 1 
22b8 .. 00			db "DUP",0              
22bc				endm 
# End of macro CWHEAD
22bc			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
22bc			 
22bc					if DEBUG_FORTH_WORDS_KEY 
22bc						DMARK "DUP" 
22bc f5				push af  
22bd 3a d1 22			ld a, (.dmark)  
22c0 32 b4 fe			ld (debug_mark),a  
22c3 3a d2 22			ld a, (.dmark+1)  
22c6 32 b5 fe			ld (debug_mark+1),a  
22c9 3a d3 22			ld a, (.dmark+2)  
22cc 32 b6 fe			ld (debug_mark+2),a  
22cf 18 03			jr .pastdmark  
22d1 ..			.dmark: db "DUP"  
22d4 f1			.pastdmark: pop af  
22d5			endm  
# End of macro DMARK
22d5						CALLMONITOR 
22d5 cd 57 17			call break_point_state  
22d8				endm  
# End of macro CALLMONITOR
22d8					endif 
22d8			 
22d8					FORTH_DSP 
22d8 cd 71 1f			call macro_forth_dsp 
22db				endm 
# End of macro FORTH_DSP
22db			 
22db 7e					ld a, (HL) 
22dc fe 01				cp DS_TYPE_STR 
22de 20 25				jr nz, .dupinum 
22e0			 
22e0					; push another string 
22e0			 
22e0					FORTH_DSP_VALUEHL     		 
22e0 cd ab 1f			call macro_dsp_valuehl 
22e3				endm 
# End of macro FORTH_DSP_VALUEHL
22e3			 
22e3				if DEBUG_FORTH_WORDS 
22e3					DMARK "DUs" 
22e3 f5				push af  
22e4 3a f8 22			ld a, (.dmark)  
22e7 32 b4 fe			ld (debug_mark),a  
22ea 3a f9 22			ld a, (.dmark+1)  
22ed 32 b5 fe			ld (debug_mark+1),a  
22f0 3a fa 22			ld a, (.dmark+2)  
22f3 32 b6 fe			ld (debug_mark+2),a  
22f6 18 03			jr .pastdmark  
22f8 ..			.dmark: db "DUs"  
22fb f1			.pastdmark: pop af  
22fc			endm  
# End of macro DMARK
22fc					CALLMONITOR 
22fc cd 57 17			call break_point_state  
22ff				endm  
# End of macro CALLMONITOR
22ff				endif 
22ff cd 22 1e				call forth_push_str 
2302			 
2302					NEXTW 
2302 c3 1d 21			jp macro_next 
2305				endm 
# End of macro NEXTW
2305			 
2305			 
2305			.dupinum: 
2305					 
2305			 
2305			 
2305					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2305 cd ab 1f			call macro_dsp_valuehl 
2308				endm 
# End of macro FORTH_DSP_VALUEHL
2308			 
2308				; TODO add floating point number detection 
2308			 
2308				if DEBUG_FORTH_WORDS 
2308					DMARK "DUi" 
2308 f5				push af  
2309 3a 1d 23			ld a, (.dmark)  
230c 32 b4 fe			ld (debug_mark),a  
230f 3a 1e 23			ld a, (.dmark+1)  
2312 32 b5 fe			ld (debug_mark+1),a  
2315 3a 1f 23			ld a, (.dmark+2)  
2318 32 b6 fe			ld (debug_mark+2),a  
231b 18 03			jr .pastdmark  
231d ..			.dmark: db "DUi"  
2320 f1			.pastdmark: pop af  
2321			endm  
# End of macro DMARK
2321					CALLMONITOR 
2321 cd 57 17			call break_point_state  
2324				endm  
# End of macro CALLMONITOR
2324				endif 
2324			 
2324 cd b4 1d				call forth_push_numhl 
2327					NEXTW 
2327 c3 1d 21			jp macro_next 
232a				endm 
# End of macro NEXTW
232a			.ZDUP: 
232a				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
232a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
232b 62 23			dw .SWAP            
232d 05				db 4 + 1 
232e .. 00			db "?DUP",0              
2333				endm 
# End of macro CWHEAD
2333			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2333			 
2333					if DEBUG_FORTH_WORDS_KEY 
2333						DMARK "qDU" 
2333 f5				push af  
2334 3a 48 23			ld a, (.dmark)  
2337 32 b4 fe			ld (debug_mark),a  
233a 3a 49 23			ld a, (.dmark+1)  
233d 32 b5 fe			ld (debug_mark+1),a  
2340 3a 4a 23			ld a, (.dmark+2)  
2343 32 b6 fe			ld (debug_mark+2),a  
2346 18 03			jr .pastdmark  
2348 ..			.dmark: db "qDU"  
234b f1			.pastdmark: pop af  
234c			endm  
# End of macro DMARK
234c						CALLMONITOR 
234c cd 57 17			call break_point_state  
234f				endm  
# End of macro CALLMONITOR
234f					endif 
234f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
234f cd ab 1f			call macro_dsp_valuehl 
2352				endm 
# End of macro FORTH_DSP_VALUEHL
2352			 
2352 e5					push hl 
2353			 
2353					; is it a zero? 
2353			 
2353 3e 00				ld a, 0 
2355 84					add h 
2356 85					add l 
2357			 
2357 e1					pop hl 
2358			 
2358 fe 00				cp 0 
235a 28 03				jr z, .dup2orig 
235c			 
235c			 
235c cd b4 1d				call forth_push_numhl 
235f			 
235f			 
235f				; TODO add floating point number detection 
235f			 
235f			.dup2orig: 
235f			 
235f					NEXTW 
235f c3 1d 21			jp macro_next 
2362				endm 
# End of macro NEXTW
2362			.SWAP: 
2362				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2362 18				db WORD_SYS_CORE+OPCODE_SWAP             
2363 a1 23			dw .COLN            
2365 05				db 4 + 1 
2366 .. 00			db "SWAP",0              
236b				endm 
# End of macro CWHEAD
236b			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
236b					if DEBUG_FORTH_WORDS_KEY 
236b						DMARK "SWP" 
236b f5				push af  
236c 3a 80 23			ld a, (.dmark)  
236f 32 b4 fe			ld (debug_mark),a  
2372 3a 81 23			ld a, (.dmark+1)  
2375 32 b5 fe			ld (debug_mark+1),a  
2378 3a 82 23			ld a, (.dmark+2)  
237b 32 b6 fe			ld (debug_mark+2),a  
237e 18 03			jr .pastdmark  
2380 ..			.dmark: db "SWP"  
2383 f1			.pastdmark: pop af  
2384			endm  
# End of macro DMARK
2384						CALLMONITOR 
2384 cd 57 17			call break_point_state  
2387				endm  
# End of macro CALLMONITOR
2387					endif 
2387			 
2387					FORTH_DSP_VALUEHL 
2387 cd ab 1f			call macro_dsp_valuehl 
238a				endm 
# End of macro FORTH_DSP_VALUEHL
238a e5					push hl     ; w2 
238b			 
238b					FORTH_DSP_POP 
238b cd 63 20			call macro_forth_dsp_pop 
238e				endm 
# End of macro FORTH_DSP_POP
238e			 
238e					FORTH_DSP_VALUEHL 
238e cd ab 1f			call macro_dsp_valuehl 
2391				endm 
# End of macro FORTH_DSP_VALUEHL
2391			 
2391					FORTH_DSP_POP 
2391 cd 63 20			call macro_forth_dsp_pop 
2394				endm 
# End of macro FORTH_DSP_POP
2394			 
2394 d1					pop de     ; w2	, hl = w1 
2395			 
2395 eb					ex de, hl 
2396 d5					push de 
2397			 
2397 cd b4 1d				call forth_push_numhl 
239a			 
239a e1					pop hl 
239b			 
239b cd b4 1d				call forth_push_numhl 
239e					 
239e			 
239e					NEXTW 
239e c3 1d 21			jp macro_next 
23a1				endm 
# End of macro NEXTW
23a1			.COLN: 
23a1				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
23a1 19				db WORD_SYS_CORE+OPCODE_COLN             
23a2 2d 25			dw .SCOLN            
23a4 02				db 1 + 1 
23a5 .. 00			db ":",0              
23a7				endm 
# End of macro CWHEAD
23a7			; | : ( -- )         Create new word | DONE 
23a7			 
23a7					if DEBUG_FORTH_WORDS_KEY 
23a7						DMARK "CLN" 
23a7 f5				push af  
23a8 3a bc 23			ld a, (.dmark)  
23ab 32 b4 fe			ld (debug_mark),a  
23ae 3a bd 23			ld a, (.dmark+1)  
23b1 32 b5 fe			ld (debug_mark+1),a  
23b4 3a be 23			ld a, (.dmark+2)  
23b7 32 b6 fe			ld (debug_mark+2),a  
23ba 18 03			jr .pastdmark  
23bc ..			.dmark: db "CLN"  
23bf f1			.pastdmark: pop af  
23c0			endm  
# End of macro DMARK
23c0						CALLMONITOR 
23c0 cd 57 17			call break_point_state  
23c3				endm  
# End of macro CALLMONITOR
23c3					endif 
23c3				STACKFRAME OFF $8efe $989f 
23c3				if DEBUG_STACK_IMB 
23c3					if OFF 
23c3						exx 
23c3						ld de, $8efe 
23c3						ld a, d 
23c3						ld hl, curframe 
23c3						call hexout 
23c3						ld a, e 
23c3						ld hl, curframe+2 
23c3						call hexout 
23c3						ld hl, $8efe 
23c3						push hl 
23c3						ld hl, $989f 
23c3						push hl 
23c3						exx 
23c3					endif 
23c3				endif 
23c3			endm 
# End of macro STACKFRAME
23c3				; get parser buffer length  of new word 
23c3			 
23c3				 
23c3			 
23c3					; move tok past this to start of name defintition 
23c3					; TODO get word to define 
23c3					; TODO Move past word token 
23c3					; TODO get length of string up to the ';' 
23c3			 
23c3 2a 5b f7			ld hl, (os_tok_ptr) 
23c6 23				inc hl 
23c7 23				inc hl 
23c8			 
23c8 3e 3b			ld a, ';' 
23ca cd 43 12			call strlent 
23cd			 
23cd 7d				ld a,l 
23ce 32 56 f4			ld (os_new_parse_len), a 
23d1			 
23d1			 
23d1			if DEBUG_FORTH_UWORD 
23d1 ed 5b 5b f7		ld de, (os_tok_ptr) 
23d5						DMARK ":01" 
23d5 f5				push af  
23d6 3a ea 23			ld a, (.dmark)  
23d9 32 b4 fe			ld (debug_mark),a  
23dc 3a eb 23			ld a, (.dmark+1)  
23df 32 b5 fe			ld (debug_mark+1),a  
23e2 3a ec 23			ld a, (.dmark+2)  
23e5 32 b6 fe			ld (debug_mark+2),a  
23e8 18 03			jr .pastdmark  
23ea ..			.dmark: db ":01"  
23ed f1			.pastdmark: pop af  
23ee			endm  
# End of macro DMARK
23ee				CALLMONITOR 
23ee cd 57 17			call break_point_state  
23f1				endm  
# End of macro CALLMONITOR
23f1			endif 
23f1			 
23f1			; 
23f1			;  new word memory layout: 
23f1			;  
23f1			;    : adg 6666 ;  
23f1			; 
23f1			;    db   1     ; user defined word  
23f1 23				inc hl    
23f2			;    dw   sysdict 
23f2 23				inc hl 
23f3 23				inc hl 
23f4			;    db <word len>+1 (for null) 
23f4 23				inc hl 
23f5			;    db .... <word> 
23f5			; 
23f5			 
23f5 23				inc hl    ; some extras for the word preamble before the above 
23f6 23				inc hl 
23f7 23				inc hl 
23f8 23				inc hl 
23f9 23				inc hl 
23fa 23				inc hl 
23fb 23				inc hl  
23fc 23				inc hl 
23fd 23				inc hl 
23fe 23				inc hl 
23ff 23				inc hl 
2400 23				inc hl 
2401 23				inc hl 
2402 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2403			;       exec word buffer 
2403			;	<ptr word>   
2403 23				inc hl 
2404 23				inc hl 
2405			;       <word list><null term> 7F final term 
2405			 
2405			 
2405			if DEBUG_FORTH_UWORD 
2405						DMARK ":02" 
2405 f5				push af  
2406 3a 1a 24			ld a, (.dmark)  
2409 32 b4 fe			ld (debug_mark),a  
240c 3a 1b 24			ld a, (.dmark+1)  
240f 32 b5 fe			ld (debug_mark+1),a  
2412 3a 1c 24			ld a, (.dmark+2)  
2415 32 b6 fe			ld (debug_mark+2),a  
2418 18 03			jr .pastdmark  
241a ..			.dmark: db ":02"  
241d f1			.pastdmark: pop af  
241e			endm  
# End of macro DMARK
241e				CALLMONITOR 
241e cd 57 17			call break_point_state  
2421				endm  
# End of macro CALLMONITOR
2421			endif 
2421			 
2421				 
2421					; malloc the size 
2421			 
2421 cd a1 12				call malloc 
2424 22 58 f4				ld (os_new_malloc), hl     ; save malloc start 
2427			 
2427			;    db   1     ; user defined word  
2427 3e 01				ld a, WORD_SYS_UWORD  
2429 77					ld (hl), a 
242a				 
242a 23				inc hl    
242b			;    dw   sysdict 
242b 11 75 22			ld de, sysdict       ; continue on with the scan to the system dict 
242e 73				ld (hl), e 
242f 23				inc hl 
2430 72				ld (hl), d 
2431 23				inc hl 
2432			 
2432			 
2432			;    Setup dict word 
2432			 
2432 23				inc hl 
2433 22 52 f4			ld (os_new_work_ptr), hl     ; save start of dict word  
2436			 
2436				; 1. get length of dict word 
2436			 
2436			 
2436 2a 5b f7			ld hl, (os_tok_ptr) 
2439 23				inc hl 
243a 23				inc hl    ; position to start of dict word 
243b 3e 00			ld a, 0 
243d cd 43 12			call strlent 
2440			 
2440			 
2440 23				inc hl    ; to include null??? 
2441			 
2441				; write length of dict word 
2441			 
2441 ed 5b 52 f4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2445 1b				dec de 
2446 eb				ex de, hl 
2447 73				ld (hl), e 
2448 eb				ex de, hl 
2449			 
2449				 
2449			 
2449				; copy  
2449 4d				ld c, l 
244a 06 00			ld b, 0 
244c ed 5b 52 f4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2450 2a 5b f7			ld hl, (os_tok_ptr) 
2453 23				inc hl 
2454 23				inc hl    ; position to start of dict word 
2455				 
2455			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2455				 
2455				; TODO need to convert word to upper case 
2455			 
2455			ucasetok:	 
2455 7e				ld a,(hl) 
2456 cd 2f 12			call toUpper 
2459 77				ld (hl),a 
245a ed a0			ldi 
245c f2 55 24		 	jp p, ucasetok 
245f			 
245f			 
245f			 
245f				; de now points to start of where the word body code should be placed 
245f ed 53 52 f4		ld (os_new_work_ptr), de 
2463				; hl now points to the words to throw at forthexec which needs to be copied 
2463 22 50 f4			ld (os_new_src_ptr), hl 
2466			 
2466				; TODO add 'call to forthexec' 
2466			 
2466			if DEBUG_FORTH_UWORD 
2466 c5				push bc 
2467 ed 4b 58 f4		ld bc, (os_new_malloc) 
246b						DMARK ":0x" 
246b f5				push af  
246c 3a 80 24			ld a, (.dmark)  
246f 32 b4 fe			ld (debug_mark),a  
2472 3a 81 24			ld a, (.dmark+1)  
2475 32 b5 fe			ld (debug_mark+1),a  
2478 3a 82 24			ld a, (.dmark+2)  
247b 32 b6 fe			ld (debug_mark+2),a  
247e 18 03			jr .pastdmark  
2480 ..			.dmark: db ":0x"  
2483 f1			.pastdmark: pop af  
2484			endm  
# End of macro DMARK
2484				CALLMONITOR 
2484 cd 57 17			call break_point_state  
2487				endm  
# End of macro CALLMONITOR
2487 c1				pop bc 
2488			endif 
2488			 
2488			 
2488				; create word preamble which should be: 
2488			 
2488			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2488			 
2488				;    ld hl, <word code> 
2488				;    jp user_exec 
2488			        ;    <word code bytes> 
2488			 
2488			 
2488			;	inc de     ; TODO ??? or are we already past the word's null 
2488 eb				ex de, hl 
2489			 
2489 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
248b			 
248b 23				inc hl 
248c 22 4c f4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
248f 23				inc hl 
2490			 
2490 23				inc hl 
2491 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2493			 
2493 01 a1 52			ld bc, user_exec 
2496 23				inc hl 
2497 71				ld (hl), c     ; poke address of user_exec 
2498 23				inc hl 
2499 70				ld (hl), b     
249a			 ; 
249a			;	inc hl 
249a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
249a			; 
249a			; 
249a			;	ld bc, macro_forth_rsp_next 
249a			;	inc hl 
249a			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
249a			;	inc hl 
249a			;	ld (hl), b     
249a			 ; 
249a			;	inc hl 
249a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
249a			; 
249a			; 
249a			;	inc hl 
249a			;	ld bc, forthexec 
249a			;	ld (hl), c     ; poke address of forthexec 
249a			;	inc hl 
249a			;	ld (hl), b      
249a			; 
249a			;	inc hl 
249a			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
249a			; 
249a			;	ld bc, user_dict_next 
249a			;	inc hl 
249a			;	ld (hl), c     ; poke address of forthexec 
249a			;	inc hl 
249a			;	ld (hl), b      
249a			 
249a				; hl is now where we need to copy the word byte data to save this 
249a			 
249a 23				inc hl 
249b 22 4e f4			ld (os_new_exec), hl 
249e				 
249e				; copy definition 
249e			 
249e eb				ex de, hl 
249f			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
249f			;	inc de    ; skip the PC for this parse 
249f 3a 56 f4			ld a, (os_new_parse_len) 
24a2 4f				ld c, a 
24a3 06 00			ld b, 0 
24a5 ed b0			ldir		 ; copy defintion 
24a7			 
24a7			 
24a7				; poke the address of where the new word bytes live for forthexec 
24a7			 
24a7 2a 4c f4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
24aa			 
24aa ed 5b 4e f4		ld de, (os_new_exec)      
24ae				 
24ae 73				ld (hl), e 
24af 23				inc hl 
24b0 72				ld (hl), d 
24b1			 
24b1					; TODO copy last user dict word next link to this word 
24b1					; TODO update last user dict word to point to this word 
24b1			; 
24b1			; hl f923 de 812a ; bc 811a 
24b1			 
24b1			if DEBUG_FORTH_UWORD 
24b1 c5				push bc 
24b2 ed 4b 58 f4		ld bc, (os_new_malloc) 
24b6						DMARK ":0A" 
24b6 f5				push af  
24b7 3a cb 24			ld a, (.dmark)  
24ba 32 b4 fe			ld (debug_mark),a  
24bd 3a cc 24			ld a, (.dmark+1)  
24c0 32 b5 fe			ld (debug_mark+1),a  
24c3 3a cd 24			ld a, (.dmark+2)  
24c6 32 b6 fe			ld (debug_mark+2),a  
24c9 18 03			jr .pastdmark  
24cb ..			.dmark: db ":0A"  
24ce f1			.pastdmark: pop af  
24cf			endm  
# End of macro DMARK
24cf				CALLMONITOR 
24cf cd 57 17			call break_point_state  
24d2				endm  
# End of macro CALLMONITOR
24d2 c1				pop bc 
24d3			endif 
24d3			if DEBUG_FORTH_UWORD 
24d3 c5				push bc 
24d4 ed 4b 58 f4		ld bc, (os_new_malloc) 
24d8 03				inc bc 
24d9 03				inc bc 
24da 03				inc bc 
24db 03				inc bc 
24dc 03				inc bc 
24dd 03				inc bc 
24de 03				inc bc 
24df 03				inc bc 
24e0			 
24e0						DMARK ":0B" 
24e0 f5				push af  
24e1 3a f5 24			ld a, (.dmark)  
24e4 32 b4 fe			ld (debug_mark),a  
24e7 3a f6 24			ld a, (.dmark+1)  
24ea 32 b5 fe			ld (debug_mark+1),a  
24ed 3a f7 24			ld a, (.dmark+2)  
24f0 32 b6 fe			ld (debug_mark+2),a  
24f3 18 03			jr .pastdmark  
24f5 ..			.dmark: db ":0B"  
24f8 f1			.pastdmark: pop af  
24f9			endm  
# End of macro DMARK
24f9				CALLMONITOR 
24f9 cd 57 17			call break_point_state  
24fc				endm  
# End of macro CALLMONITOR
24fc c1				pop bc 
24fd			endif 
24fd			 
24fd			; update word dict linked list for new word 
24fd			 
24fd			 
24fd 2a 57 f7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2500 23			inc hl     ; move to next work linked list ptr 
2501			 
2501 ed 5b 58 f4	ld de, (os_new_malloc)		 ; new next word 
2505 73			ld (hl), e 
2506 23			inc hl 
2507 72			ld (hl), d 
2508			 
2508			if DEBUG_FORTH_UWORD 
2508 ed 4b 57 f7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
250c			endif 
250c			 
250c ed 53 57 f7	ld (os_last_new_uword), de      ; update last new uword ptr 
2510			 
2510			 
2510			if DEBUG_FORTH_UWORD 
2510						DMARK ":0+" 
2510 f5				push af  
2511 3a 25 25			ld a, (.dmark)  
2514 32 b4 fe			ld (debug_mark),a  
2517 3a 26 25			ld a, (.dmark+1)  
251a 32 b5 fe			ld (debug_mark+1),a  
251d 3a 27 25			ld a, (.dmark+2)  
2520 32 b6 fe			ld (debug_mark+2),a  
2523 18 03			jr .pastdmark  
2525 ..			.dmark: db ":0+"  
2528 f1			.pastdmark: pop af  
2529			endm  
# End of macro DMARK
2529				CALLMONITOR 
2529 cd 57 17			call break_point_state  
252c				endm  
# End of macro CALLMONITOR
252c			endif 
252c			 
252c				STACKFRAMECHK OFF $8efe $989f 
252c				if DEBUG_STACK_IMB 
252c					if OFF 
252c						exx 
252c						ld hl, $989f 
252c						pop de   ; $989f 
252c						call cmp16 
252c						jr nz, .spnosame 
252c						ld hl, $8efe 
252c						pop de   ; $8efe 
252c						call cmp16 
252c						jr z, .spfrsame 
252c						.spnosame: call showsperror 
252c						.spfrsame: nop 
252c						exx 
252c					endif 
252c				endif 
252c			endm 
# End of macro STACKFRAMECHK
252c			 
252c c9			ret    ; dont process any remaining parser tokens as they form new word 
252d			 
252d			 
252d			 
252d			 
252d			;		NEXT 
252d			.SCOLN: 
252d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
252d 06				db OPCODE_SCOLN 
252e 79 25			dw .DROP 
2530 02				db 2 
2531 .. 00			db ";",0           
2533			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2533					if DEBUG_FORTH_WORDS_KEY 
2533						DMARK "SCN" 
2533 f5				push af  
2534 3a 48 25			ld a, (.dmark)  
2537 32 b4 fe			ld (debug_mark),a  
253a 3a 49 25			ld a, (.dmark+1)  
253d 32 b5 fe			ld (debug_mark+1),a  
2540 3a 4a 25			ld a, (.dmark+2)  
2543 32 b6 fe			ld (debug_mark+2),a  
2546 18 03			jr .pastdmark  
2548 ..			.dmark: db "SCN"  
254b f1			.pastdmark: pop af  
254c			endm  
# End of macro DMARK
254c						CALLMONITOR 
254c cd 57 17			call break_point_state  
254f				endm  
# End of macro CALLMONITOR
254f					endif 
254f					FORTH_RSP_TOS 
254f cd 72 1d			call macro_forth_rsp_tos 
2552				endm 
# End of macro FORTH_RSP_TOS
2552 e5					push hl 
2553					FORTH_RSP_POP 
2553 cd 7c 1d			call macro_forth_rsp_pop 
2556				endm 
# End of macro FORTH_RSP_POP
2556 e1					pop hl 
2557			;		ex de,hl 
2557 22 5b f7				ld (os_tok_ptr),hl 
255a			 
255a			if DEBUG_FORTH_UWORD 
255a						DMARK "SCL" 
255a f5				push af  
255b 3a 6f 25			ld a, (.dmark)  
255e 32 b4 fe			ld (debug_mark),a  
2561 3a 70 25			ld a, (.dmark+1)  
2564 32 b5 fe			ld (debug_mark+1),a  
2567 3a 71 25			ld a, (.dmark+2)  
256a 32 b6 fe			ld (debug_mark+2),a  
256d 18 03			jr .pastdmark  
256f ..			.dmark: db "SCL"  
2572 f1			.pastdmark: pop af  
2573			endm  
# End of macro DMARK
2573				CALLMONITOR 
2573 cd 57 17			call break_point_state  
2576				endm  
# End of macro CALLMONITOR
2576			endif 
2576					NEXTW 
2576 c3 1d 21			jp macro_next 
2579				endm 
# End of macro NEXTW
2579			 
2579			.DROP: 
2579				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2579 1b				db WORD_SYS_CORE+OPCODE_DROP             
257a a4 25			dw .DUP2            
257c 05				db 4 + 1 
257d .. 00			db "DROP",0              
2582				endm 
# End of macro CWHEAD
2582			; | DROP ( w -- )   drop the TOS item   | DONE 
2582					if DEBUG_FORTH_WORDS_KEY 
2582						DMARK "DRP" 
2582 f5				push af  
2583 3a 97 25			ld a, (.dmark)  
2586 32 b4 fe			ld (debug_mark),a  
2589 3a 98 25			ld a, (.dmark+1)  
258c 32 b5 fe			ld (debug_mark+1),a  
258f 3a 99 25			ld a, (.dmark+2)  
2592 32 b6 fe			ld (debug_mark+2),a  
2595 18 03			jr .pastdmark  
2597 ..			.dmark: db "DRP"  
259a f1			.pastdmark: pop af  
259b			endm  
# End of macro DMARK
259b						CALLMONITOR 
259b cd 57 17			call break_point_state  
259e				endm  
# End of macro CALLMONITOR
259e					endif 
259e					FORTH_DSP_POP 
259e cd 63 20			call macro_forth_dsp_pop 
25a1				endm 
# End of macro FORTH_DSP_POP
25a1					NEXTW 
25a1 c3 1d 21			jp macro_next 
25a4				endm 
# End of macro NEXTW
25a4			.DUP2: 
25a4				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
25a4 1c				db WORD_SYS_CORE+OPCODE_DUP2             
25a5 e9 25			dw .DROP2            
25a7 05				db 4 + 1 
25a8 .. 00			db "2DUP",0              
25ad				endm 
# End of macro CWHEAD
25ad			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
25ad					if DEBUG_FORTH_WORDS_KEY 
25ad						DMARK "2DU" 
25ad f5				push af  
25ae 3a c2 25			ld a, (.dmark)  
25b1 32 b4 fe			ld (debug_mark),a  
25b4 3a c3 25			ld a, (.dmark+1)  
25b7 32 b5 fe			ld (debug_mark+1),a  
25ba 3a c4 25			ld a, (.dmark+2)  
25bd 32 b6 fe			ld (debug_mark+2),a  
25c0 18 03			jr .pastdmark  
25c2 ..			.dmark: db "2DU"  
25c5 f1			.pastdmark: pop af  
25c6			endm  
# End of macro DMARK
25c6						CALLMONITOR 
25c6 cd 57 17			call break_point_state  
25c9				endm  
# End of macro CALLMONITOR
25c9					endif 
25c9					FORTH_DSP_VALUEHL 
25c9 cd ab 1f			call macro_dsp_valuehl 
25cc				endm 
# End of macro FORTH_DSP_VALUEHL
25cc e5					push hl      ; 2 
25cd			 
25cd					FORTH_DSP_POP 
25cd cd 63 20			call macro_forth_dsp_pop 
25d0				endm 
# End of macro FORTH_DSP_POP
25d0					 
25d0					FORTH_DSP_VALUEHL 
25d0 cd ab 1f			call macro_dsp_valuehl 
25d3				endm 
# End of macro FORTH_DSP_VALUEHL
25d3			;		push hl      ; 1 
25d3			 
25d3					FORTH_DSP_POP 
25d3 cd 63 20			call macro_forth_dsp_pop 
25d6				endm 
# End of macro FORTH_DSP_POP
25d6			 
25d6			;		pop hl       ; 1 
25d6 d1					pop de       ; 2 
25d7			 
25d7 cd b4 1d				call forth_push_numhl 
25da eb					ex de, hl 
25db cd b4 1d				call forth_push_numhl 
25de			 
25de					 
25de eb					ex de, hl 
25df			 
25df cd b4 1d				call forth_push_numhl 
25e2 eb					ex de, hl 
25e3 cd b4 1d				call forth_push_numhl 
25e6			 
25e6			 
25e6					NEXTW 
25e6 c3 1d 21			jp macro_next 
25e9				endm 
# End of macro NEXTW
25e9			.DROP2: 
25e9				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
25e9 1d				db WORD_SYS_CORE+OPCODE_DROP2             
25ea 18 26			dw .SWAP2            
25ec 06				db 5 + 1 
25ed .. 00			db "2DROP",0              
25f3				endm 
# End of macro CWHEAD
25f3			; | 2DROP ( w w -- )    Double drop | DONE 
25f3					if DEBUG_FORTH_WORDS_KEY 
25f3						DMARK "2DR" 
25f3 f5				push af  
25f4 3a 08 26			ld a, (.dmark)  
25f7 32 b4 fe			ld (debug_mark),a  
25fa 3a 09 26			ld a, (.dmark+1)  
25fd 32 b5 fe			ld (debug_mark+1),a  
2600 3a 0a 26			ld a, (.dmark+2)  
2603 32 b6 fe			ld (debug_mark+2),a  
2606 18 03			jr .pastdmark  
2608 ..			.dmark: db "2DR"  
260b f1			.pastdmark: pop af  
260c			endm  
# End of macro DMARK
260c						CALLMONITOR 
260c cd 57 17			call break_point_state  
260f				endm  
# End of macro CALLMONITOR
260f					endif 
260f					FORTH_DSP_POP 
260f cd 63 20			call macro_forth_dsp_pop 
2612				endm 
# End of macro FORTH_DSP_POP
2612					FORTH_DSP_POP 
2612 cd 63 20			call macro_forth_dsp_pop 
2615				endm 
# End of macro FORTH_DSP_POP
2615					NEXTW 
2615 c3 1d 21			jp macro_next 
2618				endm 
# End of macro NEXTW
2618			.SWAP2: 
2618				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2618 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2619 41 26			dw .AT            
261b 06				db 5 + 1 
261c .. 00			db "2SWAP",0              
2622				endm 
# End of macro CWHEAD
2622			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2622					if DEBUG_FORTH_WORDS_KEY 
2622						DMARK "2SW" 
2622 f5				push af  
2623 3a 37 26			ld a, (.dmark)  
2626 32 b4 fe			ld (debug_mark),a  
2629 3a 38 26			ld a, (.dmark+1)  
262c 32 b5 fe			ld (debug_mark+1),a  
262f 3a 39 26			ld a, (.dmark+2)  
2632 32 b6 fe			ld (debug_mark+2),a  
2635 18 03			jr .pastdmark  
2637 ..			.dmark: db "2SW"  
263a f1			.pastdmark: pop af  
263b			endm  
# End of macro DMARK
263b						CALLMONITOR 
263b cd 57 17			call break_point_state  
263e				endm  
# End of macro CALLMONITOR
263e					endif 
263e					NEXTW 
263e c3 1d 21			jp macro_next 
2641				endm 
# End of macro NEXTW
2641			.AT: 
2641				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2641 1f				db WORD_SYS_CORE+OPCODE_AT             
2642 73 26			dw .CAT            
2644 02				db 1 + 1 
2645 .. 00			db "@",0              
2647				endm 
# End of macro CWHEAD
2647			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2647			 
2647					if DEBUG_FORTH_WORDS_KEY 
2647						DMARK "AT." 
2647 f5				push af  
2648 3a 5c 26			ld a, (.dmark)  
264b 32 b4 fe			ld (debug_mark),a  
264e 3a 5d 26			ld a, (.dmark+1)  
2651 32 b5 fe			ld (debug_mark+1),a  
2654 3a 5e 26			ld a, (.dmark+2)  
2657 32 b6 fe			ld (debug_mark+2),a  
265a 18 03			jr .pastdmark  
265c ..			.dmark: db "AT."  
265f f1			.pastdmark: pop af  
2660			endm  
# End of macro DMARK
2660						CALLMONITOR 
2660 cd 57 17			call break_point_state  
2663				endm  
# End of macro CALLMONITOR
2663					endif 
2663			.getbyteat:	 
2663					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2663 cd ab 1f			call macro_dsp_valuehl 
2666				endm 
# End of macro FORTH_DSP_VALUEHL
2666					 
2666			;		push hl 
2666				 
2666					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2666 cd 63 20			call macro_forth_dsp_pop 
2669				endm 
# End of macro FORTH_DSP_POP
2669			 
2669			;		pop hl 
2669			 
2669 7e					ld a, (hl) 
266a			 
266a 6f					ld l, a 
266b 26 00				ld h, 0 
266d cd b4 1d				call forth_push_numhl 
2670			 
2670					NEXTW 
2670 c3 1d 21			jp macro_next 
2673				endm 
# End of macro NEXTW
2673			.CAT: 
2673				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2673 20				db WORD_SYS_CORE+OPCODE_CAT             
2674 9c 26			dw .BANG            
2676 03				db 2 + 1 
2677 .. 00			db "C@",0              
267a				endm 
# End of macro CWHEAD
267a			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
267a					if DEBUG_FORTH_WORDS_KEY 
267a						DMARK "CAA" 
267a f5				push af  
267b 3a 8f 26			ld a, (.dmark)  
267e 32 b4 fe			ld (debug_mark),a  
2681 3a 90 26			ld a, (.dmark+1)  
2684 32 b5 fe			ld (debug_mark+1),a  
2687 3a 91 26			ld a, (.dmark+2)  
268a 32 b6 fe			ld (debug_mark+2),a  
268d 18 03			jr .pastdmark  
268f ..			.dmark: db "CAA"  
2692 f1			.pastdmark: pop af  
2693			endm  
# End of macro DMARK
2693						CALLMONITOR 
2693 cd 57 17			call break_point_state  
2696				endm  
# End of macro CALLMONITOR
2696					endif 
2696 c3 63 26				jp .getbyteat 
2699					NEXTW 
2699 c3 1d 21			jp macro_next 
269c				endm 
# End of macro NEXTW
269c			.BANG: 
269c				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
269c 21				db WORD_SYS_CORE+OPCODE_BANG             
269d d2 26			dw .CBANG            
269f 02				db 1 + 1 
26a0 .. 00			db "!",0              
26a2				endm 
# End of macro CWHEAD
26a2			; | ! ( x w -- ) Store x at address w      | DONE 
26a2					if DEBUG_FORTH_WORDS_KEY 
26a2						DMARK "BNG" 
26a2 f5				push af  
26a3 3a b7 26			ld a, (.dmark)  
26a6 32 b4 fe			ld (debug_mark),a  
26a9 3a b8 26			ld a, (.dmark+1)  
26ac 32 b5 fe			ld (debug_mark+1),a  
26af 3a b9 26			ld a, (.dmark+2)  
26b2 32 b6 fe			ld (debug_mark+2),a  
26b5 18 03			jr .pastdmark  
26b7 ..			.dmark: db "BNG"  
26ba f1			.pastdmark: pop af  
26bb			endm  
# End of macro DMARK
26bb						CALLMONITOR 
26bb cd 57 17			call break_point_state  
26be				endm  
# End of macro CALLMONITOR
26be					endif 
26be			 
26be			.storebyteat:		 
26be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26be cd ab 1f			call macro_dsp_valuehl 
26c1				endm 
# End of macro FORTH_DSP_VALUEHL
26c1					 
26c1 e5					push hl 
26c2				 
26c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c2 cd 63 20			call macro_forth_dsp_pop 
26c5				endm 
# End of macro FORTH_DSP_POP
26c5			 
26c5					; get byte to poke 
26c5			 
26c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c5 cd ab 1f			call macro_dsp_valuehl 
26c8				endm 
# End of macro FORTH_DSP_VALUEHL
26c8 e5					push hl 
26c9			 
26c9			 
26c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c9 cd 63 20			call macro_forth_dsp_pop 
26cc				endm 
# End of macro FORTH_DSP_POP
26cc			 
26cc			 
26cc d1					pop de 
26cd e1					pop hl 
26ce			 
26ce 73					ld (hl),e 
26cf			 
26cf			 
26cf					NEXTW 
26cf c3 1d 21			jp macro_next 
26d2				endm 
# End of macro NEXTW
26d2			.CBANG: 
26d2				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
26d2 22				db WORD_SYS_CORE+OPCODE_CBANG             
26d3 fb 26			dw .SCALL            
26d5 03				db 2 + 1 
26d6 .. 00			db "C!",0              
26d9				endm 
# End of macro CWHEAD
26d9			; | C!  ( x w -- ) Store x at address w  | DONE 
26d9					if DEBUG_FORTH_WORDS_KEY 
26d9						DMARK "CBA" 
26d9 f5				push af  
26da 3a ee 26			ld a, (.dmark)  
26dd 32 b4 fe			ld (debug_mark),a  
26e0 3a ef 26			ld a, (.dmark+1)  
26e3 32 b5 fe			ld (debug_mark+1),a  
26e6 3a f0 26			ld a, (.dmark+2)  
26e9 32 b6 fe			ld (debug_mark+2),a  
26ec 18 03			jr .pastdmark  
26ee ..			.dmark: db "CBA"  
26f1 f1			.pastdmark: pop af  
26f2			endm  
# End of macro DMARK
26f2						CALLMONITOR 
26f2 cd 57 17			call break_point_state  
26f5				endm  
# End of macro CALLMONITOR
26f5					endif 
26f5 c3 be 26				jp .storebyteat 
26f8					NEXTW 
26f8 c3 1d 21			jp macro_next 
26fb				endm 
# End of macro NEXTW
26fb			.SCALL: 
26fb				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
26fb 23				db WORD_SYS_CORE+OPCODE_SCALL             
26fc 2f 27			dw .DEPTH            
26fe 05				db 4 + 1 
26ff .. 00			db "CALL",0              
2704				endm 
# End of macro CWHEAD
2704			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2704					if DEBUG_FORTH_WORDS_KEY 
2704						DMARK "CLL" 
2704 f5				push af  
2705 3a 19 27			ld a, (.dmark)  
2708 32 b4 fe			ld (debug_mark),a  
270b 3a 1a 27			ld a, (.dmark+1)  
270e 32 b5 fe			ld (debug_mark+1),a  
2711 3a 1b 27			ld a, (.dmark+2)  
2714 32 b6 fe			ld (debug_mark+2),a  
2717 18 03			jr .pastdmark  
2719 ..			.dmark: db "CLL"  
271c f1			.pastdmark: pop af  
271d			endm  
# End of macro DMARK
271d						CALLMONITOR 
271d cd 57 17			call break_point_state  
2720				endm  
# End of macro CALLMONITOR
2720					endif 
2720			 
2720					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2720 cd ab 1f			call macro_dsp_valuehl 
2723				endm 
# End of macro FORTH_DSP_VALUEHL
2723			 
2723			;		push hl 
2723			 
2723					; destroy value TOS 
2723			 
2723					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2723 cd 63 20			call macro_forth_dsp_pop 
2726				endm 
# End of macro FORTH_DSP_POP
2726			 
2726						 
2726			;		pop hl 
2726			 
2726					; how to do a call with hl???? save SP? 
2726 cd c6 20				call forth_call_hl 
2729			 
2729			 
2729					; TODO push value back onto stack for another op etc 
2729			 
2729 cd b4 1d				call forth_push_numhl 
272c					NEXTW 
272c c3 1d 21			jp macro_next 
272f				endm 
# End of macro NEXTW
272f			.DEPTH: 
272f				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
272f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2730 6c 27			dw .OVER            
2732 06				db 5 + 1 
2733 .. 00			db "DEPTH",0              
2739				endm 
# End of macro CWHEAD
2739			; | DEPTH ( -- u ) Push count of stack | DONE 
2739					; take current TOS and remove from base value div by two to get count 
2739					if DEBUG_FORTH_WORDS_KEY 
2739						DMARK "DEP" 
2739 f5				push af  
273a 3a 4e 27			ld a, (.dmark)  
273d 32 b4 fe			ld (debug_mark),a  
2740 3a 4f 27			ld a, (.dmark+1)  
2743 32 b5 fe			ld (debug_mark+1),a  
2746 3a 50 27			ld a, (.dmark+2)  
2749 32 b6 fe			ld (debug_mark+2),a  
274c 18 03			jr .pastdmark  
274e ..			.dmark: db "DEP"  
2751 f1			.pastdmark: pop af  
2752			endm  
# End of macro DMARK
2752						CALLMONITOR 
2752 cd 57 17			call break_point_state  
2755				endm  
# End of macro CALLMONITOR
2755					endif 
2755			 
2755			 
2755 2a 87 fc			ld hl, (cli_data_sp) 
2758 11 c1 f9			ld de, cli_data_stack 
275b ed 52			sbc hl,de 
275d				 
275d				; div by size of stack item 
275d			 
275d 5d				ld e,l 
275e 0e 03			ld c, 3 
2760 cd 6a 0d			call Div8 
2763			 
2763 6f				ld l,a 
2764 26 00			ld h,0 
2766			 
2766				;srl h 
2766				;rr l 
2766			 
2766 cd b4 1d				call forth_push_numhl 
2769					NEXTW 
2769 c3 1d 21			jp macro_next 
276c				endm 
# End of macro NEXTW
276c			.OVER: 
276c				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
276c 42				db WORD_SYS_CORE+46             
276d b3 27			dw .PAUSE            
276f 05				db 4 + 1 
2770 .. 00			db "OVER",0              
2775				endm 
# End of macro CWHEAD
2775			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2775					if DEBUG_FORTH_WORDS_KEY 
2775						DMARK "OVR" 
2775 f5				push af  
2776 3a 8a 27			ld a, (.dmark)  
2779 32 b4 fe			ld (debug_mark),a  
277c 3a 8b 27			ld a, (.dmark+1)  
277f 32 b5 fe			ld (debug_mark+1),a  
2782 3a 8c 27			ld a, (.dmark+2)  
2785 32 b6 fe			ld (debug_mark+2),a  
2788 18 03			jr .pastdmark  
278a ..			.dmark: db "OVR"  
278d f1			.pastdmark: pop af  
278e			endm  
# End of macro DMARK
278e						CALLMONITOR 
278e cd 57 17			call break_point_state  
2791				endm  
# End of macro CALLMONITOR
2791					endif 
2791			 
2791					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2791 cd ab 1f			call macro_dsp_valuehl 
2794				endm 
# End of macro FORTH_DSP_VALUEHL
2794 e5					push hl    ; n2 
2795					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2795 cd 63 20			call macro_forth_dsp_pop 
2798				endm 
# End of macro FORTH_DSP_POP
2798			 
2798					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2798 cd ab 1f			call macro_dsp_valuehl 
279b				endm 
# End of macro FORTH_DSP_VALUEHL
279b e5					push hl    ; n1 
279c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
279c cd 63 20			call macro_forth_dsp_pop 
279f				endm 
# End of macro FORTH_DSP_POP
279f			 
279f d1					pop de     ; n1 
27a0 e1					pop hl     ; n2 
27a1			 
27a1 d5					push de 
27a2 e5					push hl 
27a3 d5					push de 
27a4			 
27a4					; push back  
27a4			 
27a4 e1					pop hl 
27a5 cd b4 1d				call forth_push_numhl 
27a8 e1					pop hl 
27a9 cd b4 1d				call forth_push_numhl 
27ac e1					pop hl 
27ad cd b4 1d				call forth_push_numhl 
27b0					NEXTW 
27b0 c3 1d 21			jp macro_next 
27b3				endm 
# End of macro NEXTW
27b3			 
27b3			.PAUSE: 
27b3				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
27b3 43				db WORD_SYS_CORE+47             
27b4 e8 27			dw .PAUSES            
27b6 08				db 7 + 1 
27b7 .. 00			db "PAUSEMS",0              
27bf				endm 
# End of macro CWHEAD
27bf			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
27bf					if DEBUG_FORTH_WORDS_KEY 
27bf						DMARK "PMS" 
27bf f5				push af  
27c0 3a d4 27			ld a, (.dmark)  
27c3 32 b4 fe			ld (debug_mark),a  
27c6 3a d5 27			ld a, (.dmark+1)  
27c9 32 b5 fe			ld (debug_mark+1),a  
27cc 3a d6 27			ld a, (.dmark+2)  
27cf 32 b6 fe			ld (debug_mark+2),a  
27d2 18 03			jr .pastdmark  
27d4 ..			.dmark: db "PMS"  
27d7 f1			.pastdmark: pop af  
27d8			endm  
# End of macro DMARK
27d8						CALLMONITOR 
27d8 cd 57 17			call break_point_state  
27db				endm  
# End of macro CALLMONITOR
27db					endif 
27db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27db cd ab 1f			call macro_dsp_valuehl 
27de				endm 
# End of macro FORTH_DSP_VALUEHL
27de			;		push hl    ; n2 
27de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27de cd 63 20			call macro_forth_dsp_pop 
27e1				endm 
# End of macro FORTH_DSP_POP
27e1			;		pop hl 
27e1			 
27e1 7d					ld a, l 
27e2 cd 08 0b				call aDelayInMS 
27e5				       NEXTW 
27e5 c3 1d 21			jp macro_next 
27e8				endm 
# End of macro NEXTW
27e8			.PAUSES:  
27e8				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
27e8 44				db WORD_SYS_CORE+48             
27e9 57 28			dw .ROT            
27eb 06				db 5 + 1 
27ec .. 00			db "PAUSE",0              
27f2				endm 
# End of macro CWHEAD
27f2			; | PAUSE ( n -- )  Pause for n seconds | DONE 
27f2					if DEBUG_FORTH_WORDS_KEY 
27f2						DMARK "PAU" 
27f2 f5				push af  
27f3 3a 07 28			ld a, (.dmark)  
27f6 32 b4 fe			ld (debug_mark),a  
27f9 3a 08 28			ld a, (.dmark+1)  
27fc 32 b5 fe			ld (debug_mark+1),a  
27ff 3a 09 28			ld a, (.dmark+2)  
2802 32 b6 fe			ld (debug_mark+2),a  
2805 18 03			jr .pastdmark  
2807 ..			.dmark: db "PAU"  
280a f1			.pastdmark: pop af  
280b			endm  
# End of macro DMARK
280b						CALLMONITOR 
280b cd 57 17			call break_point_state  
280e				endm  
# End of macro CALLMONITOR
280e					endif 
280e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
280e cd ab 1f			call macro_dsp_valuehl 
2811				endm 
# End of macro FORTH_DSP_VALUEHL
2811			;		push hl    ; n2 
2811					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2811 cd 63 20			call macro_forth_dsp_pop 
2814				endm 
# End of macro FORTH_DSP_POP
2814			;		pop hl 
2814 45					ld b, l 
2815					if DEBUG_FORTH_WORDS 
2815						DMARK "PAU" 
2815 f5				push af  
2816 3a 2a 28			ld a, (.dmark)  
2819 32 b4 fe			ld (debug_mark),a  
281c 3a 2b 28			ld a, (.dmark+1)  
281f 32 b5 fe			ld (debug_mark+1),a  
2822 3a 2c 28			ld a, (.dmark+2)  
2825 32 b6 fe			ld (debug_mark+2),a  
2828 18 03			jr .pastdmark  
282a ..			.dmark: db "PAU"  
282d f1			.pastdmark: pop af  
282e			endm  
# End of macro DMARK
282e						CALLMONITOR 
282e cd 57 17			call break_point_state  
2831				endm  
# End of macro CALLMONITOR
2831					endif 
2831 c5			.pauses1:	push bc 
2832 cd 23 0b				call delay1s 
2835 c1					pop bc 
2836					if DEBUG_FORTH_WORDS 
2836						DMARK "PA1" 
2836 f5				push af  
2837 3a 4b 28			ld a, (.dmark)  
283a 32 b4 fe			ld (debug_mark),a  
283d 3a 4c 28			ld a, (.dmark+1)  
2840 32 b5 fe			ld (debug_mark+1),a  
2843 3a 4d 28			ld a, (.dmark+2)  
2846 32 b6 fe			ld (debug_mark+2),a  
2849 18 03			jr .pastdmark  
284b ..			.dmark: db "PA1"  
284e f1			.pastdmark: pop af  
284f			endm  
# End of macro DMARK
284f						CALLMONITOR 
284f cd 57 17			call break_point_state  
2852				endm  
# End of macro CALLMONITOR
2852					endif 
2852 10 dd				djnz .pauses1 
2854			 
2854				       NEXTW 
2854 c3 1d 21			jp macro_next 
2857				endm 
# End of macro NEXTW
2857			.ROT: 
2857				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2857 45				db WORD_SYS_CORE+49             
2858 a5 28			dw .UWORDS            
285a 04				db 3 + 1 
285b .. 00			db "ROT",0              
285f				endm 
# End of macro CWHEAD
285f			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
285f					if DEBUG_FORTH_WORDS_KEY 
285f						DMARK "ROT" 
285f f5				push af  
2860 3a 74 28			ld a, (.dmark)  
2863 32 b4 fe			ld (debug_mark),a  
2866 3a 75 28			ld a, (.dmark+1)  
2869 32 b5 fe			ld (debug_mark+1),a  
286c 3a 76 28			ld a, (.dmark+2)  
286f 32 b6 fe			ld (debug_mark+2),a  
2872 18 03			jr .pastdmark  
2874 ..			.dmark: db "ROT"  
2877 f1			.pastdmark: pop af  
2878			endm  
# End of macro DMARK
2878						CALLMONITOR 
2878 cd 57 17			call break_point_state  
287b				endm  
# End of macro CALLMONITOR
287b					endif 
287b			 
287b					FORTH_DSP_VALUEHL 
287b cd ab 1f			call macro_dsp_valuehl 
287e				endm 
# End of macro FORTH_DSP_VALUEHL
287e e5					push hl    ; u3  
287f			 
287f					FORTH_DSP_POP 
287f cd 63 20			call macro_forth_dsp_pop 
2882				endm 
# End of macro FORTH_DSP_POP
2882			   
2882					FORTH_DSP_VALUEHL 
2882 cd ab 1f			call macro_dsp_valuehl 
2885				endm 
# End of macro FORTH_DSP_VALUEHL
2885 e5					push hl     ; u2 
2886			 
2886					FORTH_DSP_POP 
2886 cd 63 20			call macro_forth_dsp_pop 
2889				endm 
# End of macro FORTH_DSP_POP
2889			 
2889					FORTH_DSP_VALUEHL 
2889 cd ab 1f			call macro_dsp_valuehl 
288c				endm 
# End of macro FORTH_DSP_VALUEHL
288c e5					push hl     ; u1 
288d			 
288d					FORTH_DSP_POP 
288d cd 63 20			call macro_forth_dsp_pop 
2890				endm 
# End of macro FORTH_DSP_POP
2890			 
2890 c1					pop bc      ; u1 
2891 e1					pop hl      ; u2 
2892 d1					pop de      ; u3 
2893			 
2893			 
2893 c5					push bc 
2894 d5					push de 
2895 e5					push hl 
2896			 
2896			 
2896 e1					pop hl 
2897 cd b4 1d				call forth_push_numhl 
289a			 
289a e1					pop hl 
289b cd b4 1d				call forth_push_numhl 
289e			 
289e e1					pop hl 
289f cd b4 1d				call forth_push_numhl 
28a2					 
28a2			 
28a2			 
28a2			 
28a2			 
28a2			 
28a2				       NEXTW 
28a2 c3 1d 21			jp macro_next 
28a5				endm 
# End of macro NEXTW
28a5			 
28a5			.UWORDS: 
28a5				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
28a5 50				db WORD_SYS_CORE+60             
28a6 67 29			dw .BP            
28a8 07				db 6 + 1 
28a9 .. 00			db "UWORDS",0              
28b0				endm 
# End of macro CWHEAD
28b0			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
28b0			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
28b0			; | | Following the count are the individual words. 
28b0			; | | 
28b0			; | | e.g. UWORDS 
28b0			; | | BOX DIRLIST 2 
28b0			; | |  
28b0			; | | Can be used to save the words to storage via: 
28b0			; | | UWORDS $01 DO $01 APPEND LOOP 
28b0				if DEBUG_FORTH_WORDS_KEY 
28b0					DMARK "UWR" 
28b0 f5				push af  
28b1 3a c5 28			ld a, (.dmark)  
28b4 32 b4 fe			ld (debug_mark),a  
28b7 3a c6 28			ld a, (.dmark+1)  
28ba 32 b5 fe			ld (debug_mark+1),a  
28bd 3a c7 28			ld a, (.dmark+2)  
28c0 32 b6 fe			ld (debug_mark+2),a  
28c3 18 03			jr .pastdmark  
28c5 ..			.dmark: db "UWR"  
28c8 f1			.pastdmark: pop af  
28c9			endm  
# End of macro DMARK
28c9					CALLMONITOR 
28c9 cd 57 17			call break_point_state  
28cc				endm  
# End of macro CALLMONITOR
28cc				endif 
28cc 21 00 80				ld hl, baseram 
28cf					;ld hl, baseusermem 
28cf 01 00 00				ld bc, 0    ; start a counter 
28d2			 
28d2				; skip dict stub 
28d2			 
28d2 cd 6e 22				call forth_tok_next 
28d5			 
28d5			 
28d5			; while we have words to look for 
28d5			 
28d5 7e			.douscan:	ld a, (hl)      
28d6				if DEBUG_FORTH_WORDS 
28d6					DMARK "UWs" 
28d6 f5				push af  
28d7 3a eb 28			ld a, (.dmark)  
28da 32 b4 fe			ld (debug_mark),a  
28dd 3a ec 28			ld a, (.dmark+1)  
28e0 32 b5 fe			ld (debug_mark+1),a  
28e3 3a ed 28			ld a, (.dmark+2)  
28e6 32 b6 fe			ld (debug_mark+2),a  
28e9 18 03			jr .pastdmark  
28eb ..			.dmark: db "UWs"  
28ee f1			.pastdmark: pop af  
28ef			endm  
# End of macro DMARK
28ef					CALLMONITOR 
28ef cd 57 17			call break_point_state  
28f2				endm  
# End of macro CALLMONITOR
28f2				endif 
28f2 fe 00				cp WORD_SYS_END 
28f4 28 4d				jr z, .udone 
28f6 fe 01				cp WORD_SYS_UWORD 
28f8 20 44				jr nz, .nuword 
28fa			 
28fa				if DEBUG_FORTH_WORDS 
28fa					DMARK "UWu" 
28fa f5				push af  
28fb 3a 0f 29			ld a, (.dmark)  
28fe 32 b4 fe			ld (debug_mark),a  
2901 3a 10 29			ld a, (.dmark+1)  
2904 32 b5 fe			ld (debug_mark+1),a  
2907 3a 11 29			ld a, (.dmark+2)  
290a 32 b6 fe			ld (debug_mark+2),a  
290d 18 03			jr .pastdmark  
290f ..			.dmark: db "UWu"  
2912 f1			.pastdmark: pop af  
2913			endm  
# End of macro DMARK
2913					CALLMONITOR 
2913 cd 57 17			call break_point_state  
2916				endm  
# End of macro CALLMONITOR
2916				endif 
2916					; we have a uword so push its name to the stack 
2916			 
2916 e5				   	push hl  ; save so we can move to next dict block 
2917			 
2917					; skip opcode 
2917 23					inc hl  
2918					; skip next ptr 
2918 23					inc hl  
2919 23					inc hl 
291a					; skip len 
291a 23					inc hl 
291b				if DEBUG_FORTH_WORDS 
291b					DMARK "UWt" 
291b f5				push af  
291c 3a 30 29			ld a, (.dmark)  
291f 32 b4 fe			ld (debug_mark),a  
2922 3a 31 29			ld a, (.dmark+1)  
2925 32 b5 fe			ld (debug_mark+1),a  
2928 3a 32 29			ld a, (.dmark+2)  
292b 32 b6 fe			ld (debug_mark+2),a  
292e 18 03			jr .pastdmark  
2930 ..			.dmark: db "UWt"  
2933 f1			.pastdmark: pop af  
2934			endm  
# End of macro DMARK
2934					CALLMONITOR 
2934 cd 57 17			call break_point_state  
2937				endm  
# End of macro CALLMONITOR
2937				endif 
2937 03					inc bc 
2938			 
2938 c5					push bc 
2939 cd 22 1e				call forth_push_str 
293c c1					pop bc 
293d			 
293d e1					pop hl 	 
293e			 
293e cd 6e 22		.nuword:	call forth_tok_next 
2941 18 92				jr .douscan  
2943			 
2943			.udone:		 ; push count of uwords found 
2943 c5					push bc 
2944 e1					pop hl 
2945			 
2945				if DEBUG_FORTH_WORDS 
2945					DMARK "UWc" 
2945 f5				push af  
2946 3a 5a 29			ld a, (.dmark)  
2949 32 b4 fe			ld (debug_mark),a  
294c 3a 5b 29			ld a, (.dmark+1)  
294f 32 b5 fe			ld (debug_mark+1),a  
2952 3a 5c 29			ld a, (.dmark+2)  
2955 32 b6 fe			ld (debug_mark+2),a  
2958 18 03			jr .pastdmark  
295a ..			.dmark: db "UWc"  
295d f1			.pastdmark: pop af  
295e			endm  
# End of macro DMARK
295e					CALLMONITOR 
295e cd 57 17			call break_point_state  
2961				endm  
# End of macro CALLMONITOR
2961				endif 
2961 cd b4 1d				call forth_push_numhl 
2964			 
2964			 
2964				       NEXTW 
2964 c3 1d 21			jp macro_next 
2967				endm 
# End of macro NEXTW
2967			 
2967			.BP: 
2967				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2967 54				db WORD_SYS_CORE+64             
2968 9d 29			dw .MONITOR            
296a 03				db 2 + 1 
296b .. 00			db "BP",0              
296e				endm 
# End of macro CWHEAD
296e			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
296e			; | | $00 Will enable the break points within specific code paths 
296e			; | | $01 Will disable break points 
296e			; | |  
296e			; | | By default break points are off. Either the above can be used to enable them 
296e			; | | or if a key is held down during start up the spashscreen will appear to freeze 
296e			; | | and on release of the pressed key a message will be disaplayed to notify 
296e			; | | that break points are enabled. Pressing any key will then continue boot process. 
296e					; get byte count 
296e					if DEBUG_FORTH_WORDS_KEY 
296e						DMARK "BP." 
296e f5				push af  
296f 3a 83 29			ld a, (.dmark)  
2972 32 b4 fe			ld (debug_mark),a  
2975 3a 84 29			ld a, (.dmark+1)  
2978 32 b5 fe			ld (debug_mark+1),a  
297b 3a 85 29			ld a, (.dmark+2)  
297e 32 b6 fe			ld (debug_mark+2),a  
2981 18 03			jr .pastdmark  
2983 ..			.dmark: db "BP."  
2986 f1			.pastdmark: pop af  
2987			endm  
# End of macro DMARK
2987						CALLMONITOR 
2987 cd 57 17			call break_point_state  
298a				endm  
# End of macro CALLMONITOR
298a					endif 
298a			 
298a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
298a cd ab 1f			call macro_dsp_valuehl 
298d				endm 
# End of macro FORTH_DSP_VALUEHL
298d			 
298d			;		push hl 
298d			 
298d					; destroy value TOS 
298d			 
298d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
298d cd 63 20			call macro_forth_dsp_pop 
2990				endm 
# End of macro FORTH_DSP_POP
2990			 
2990			;		pop hl 
2990			 
2990 3e 00				ld a,0 
2992 bd					cp l 
2993 28 02				jr z, .bpset 
2995 3e 2a				ld a, '*' 
2997			 
2997 32 4b f4		.bpset:		ld (os_view_disable), a 
299a			 
299a			 
299a					NEXTW 
299a c3 1d 21			jp macro_next 
299d				endm 
# End of macro NEXTW
299d			 
299d			 
299d			.MONITOR: 
299d				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
299d 55				db WORD_SYS_CORE+65             
299e d0 29			dw .MALLOC            
29a0 08				db 7 + 1 
29a1 .. 00			db "MONITOR",0              
29a9				endm 
# End of macro CWHEAD
29a9			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
29a9			; | | At start the current various registers will be displayed with contents. 
29a9			; | | Top right corner will show the most recent debug marker seen. 
29a9			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
29a9			; | | and the return stack pointer (RSP). 
29a9			; | | Pressing: 
29a9			; | |    1 - Initial screen 
29a9			; | |    2 - Display a data dump of HL 
29a9			; | |    3 - Display a data dump of DE 
29a9			; | |    4 - Display a data dump of BC 
29a9			; | |    5 - Display a data dump of HL 
29a9			; | |    6 - Display a data dump of DSP 
29a9			; | |    7 - Display a data dump of RSP 
29a9			; | |    8 - Display a data dump of what is at DSP 
29a9			; | |    9 - Display a data dump of what is at RSP 
29a9			; | |    0 - Exit monitor and continue running. This will also enable break points 
29a9			; | |    * - Disable break points 
29a9			; | |    # - Enter traditional monitor mode 
29a9			; | | 
29a9			; | | Monitor Mode 
29a9			; | | ------------ 
29a9			; | | A prompt of '>' will be shown for various commands: 
29a9			; | |    D xxxx - Display a data dump starting from hex address xxxx 
29a9			; | |    C - Continue display a data dump from the last set address 
29a9			; | |    M xxxx - Set start of memory edit at address xx 
29a9			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
29a9			; | |    Q - Return to previous 
29a9					if DEBUG_FORTH_WORDS_KEY 
29a9						DMARK "MON" 
29a9 f5				push af  
29aa 3a be 29			ld a, (.dmark)  
29ad 32 b4 fe			ld (debug_mark),a  
29b0 3a bf 29			ld a, (.dmark+1)  
29b3 32 b5 fe			ld (debug_mark+1),a  
29b6 3a c0 29			ld a, (.dmark+2)  
29b9 32 b6 fe			ld (debug_mark+2),a  
29bc 18 03			jr .pastdmark  
29be ..			.dmark: db "MON"  
29c1 f1			.pastdmark: pop af  
29c2			endm  
# End of macro DMARK
29c2						CALLMONITOR 
29c2 cd 57 17			call break_point_state  
29c5				endm  
# End of macro CALLMONITOR
29c5					endif 
29c5 3e 00				ld a, 0 
29c7 32 4b f4				ld (os_view_disable), a 
29ca			 
29ca					CALLMONITOR 
29ca cd 57 17			call break_point_state  
29cd				endm  
# End of macro CALLMONITOR
29cd			 
29cd			;	call monitor 
29cd			 
29cd					NEXTW 
29cd c3 1d 21			jp macro_next 
29d0				endm 
# End of macro NEXTW
29d0			 
29d0			 
29d0			.MALLOC: 
29d0				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
29d0 56				db WORD_SYS_CORE+66             
29d1 f9 29			dw .MALLOC2            
29d3 06				db 5 + 1 
29d4 .. 00			db "ALLOT",0              
29da				endm 
# End of macro CWHEAD
29da			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29da					if DEBUG_FORTH_WORDS_KEY 
29da						DMARK "ALL" 
29da f5				push af  
29db 3a ef 29			ld a, (.dmark)  
29de 32 b4 fe			ld (debug_mark),a  
29e1 3a f0 29			ld a, (.dmark+1)  
29e4 32 b5 fe			ld (debug_mark+1),a  
29e7 3a f1 29			ld a, (.dmark+2)  
29ea 32 b6 fe			ld (debug_mark+2),a  
29ed 18 03			jr .pastdmark  
29ef ..			.dmark: db "ALL"  
29f2 f1			.pastdmark: pop af  
29f3			endm  
# End of macro DMARK
29f3						CALLMONITOR 
29f3 cd 57 17			call break_point_state  
29f6				endm  
# End of macro CALLMONITOR
29f6					endif 
29f6 c3 20 2a				jp .mallocc 
29f9			.MALLOC2: 
29f9				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
29f9 56				db WORD_SYS_CORE+66             
29fa 37 2a			dw .FREE            
29fc 07				db 6 + 1 
29fd .. 00			db "MALLOC",0              
2a04				endm 
# End of macro CWHEAD
2a04			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a04					; get byte count 
2a04					if DEBUG_FORTH_WORDS_KEY 
2a04						DMARK "MAL" 
2a04 f5				push af  
2a05 3a 19 2a			ld a, (.dmark)  
2a08 32 b4 fe			ld (debug_mark),a  
2a0b 3a 1a 2a			ld a, (.dmark+1)  
2a0e 32 b5 fe			ld (debug_mark+1),a  
2a11 3a 1b 2a			ld a, (.dmark+2)  
2a14 32 b6 fe			ld (debug_mark+2),a  
2a17 18 03			jr .pastdmark  
2a19 ..			.dmark: db "MAL"  
2a1c f1			.pastdmark: pop af  
2a1d			endm  
# End of macro DMARK
2a1d						CALLMONITOR 
2a1d cd 57 17			call break_point_state  
2a20				endm  
# End of macro CALLMONITOR
2a20					endif 
2a20			.mallocc: 
2a20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a20 cd ab 1f			call macro_dsp_valuehl 
2a23				endm 
# End of macro FORTH_DSP_VALUEHL
2a23			 
2a23			;		push hl 
2a23			 
2a23					; destroy value TOS 
2a23			 
2a23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a23 cd 63 20			call macro_forth_dsp_pop 
2a26				endm 
# End of macro FORTH_DSP_POP
2a26			 
2a26			;		pop hl 
2a26 cd a1 12				call malloc 
2a29				if DEBUG_FORTH_MALLOC_GUARD 
2a29 f5					push af 
2a2a cd 03 0e				call ishlzero 
2a2d			;		ld a, l 
2a2d			;		add h 
2a2d			;		cp 0 
2a2d f1					pop af 
2a2e					 
2a2e cc 73 53				call z,malloc_error 
2a31				endif 
2a31			 
2a31 cd b4 1d				call forth_push_numhl 
2a34					NEXTW 
2a34 c3 1d 21			jp macro_next 
2a37				endm 
# End of macro NEXTW
2a37			 
2a37			.FREE: 
2a37				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a37 57				db WORD_SYS_CORE+67             
2a38 68 2a			dw .LIST            
2a3a 05				db 4 + 1 
2a3b .. 00			db "FREE",0              
2a40				endm 
# End of macro CWHEAD
2a40			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a40					if DEBUG_FORTH_WORDS_KEY 
2a40						DMARK "FRE" 
2a40 f5				push af  
2a41 3a 55 2a			ld a, (.dmark)  
2a44 32 b4 fe			ld (debug_mark),a  
2a47 3a 56 2a			ld a, (.dmark+1)  
2a4a 32 b5 fe			ld (debug_mark+1),a  
2a4d 3a 57 2a			ld a, (.dmark+2)  
2a50 32 b6 fe			ld (debug_mark+2),a  
2a53 18 03			jr .pastdmark  
2a55 ..			.dmark: db "FRE"  
2a58 f1			.pastdmark: pop af  
2a59			endm  
# End of macro DMARK
2a59						CALLMONITOR 
2a59 cd 57 17			call break_point_state  
2a5c				endm  
# End of macro CALLMONITOR
2a5c					endif 
2a5c					; get address 
2a5c			 
2a5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a5c cd ab 1f			call macro_dsp_valuehl 
2a5f				endm 
# End of macro FORTH_DSP_VALUEHL
2a5f			 
2a5f			;		push hl 
2a5f			 
2a5f					; destroy value TOS 
2a5f			 
2a5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a5f cd 63 20			call macro_forth_dsp_pop 
2a62				endm 
# End of macro FORTH_DSP_POP
2a62			 
2a62			;		pop hl 
2a62			if FORTH_ENABLE_MALLOCFREE 
2a62 cd 6b 13				call free 
2a65			endif 
2a65					NEXTW 
2a65 c3 1d 21			jp macro_next 
2a68				endm 
# End of macro NEXTW
2a68			.LIST: 
2a68				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a68 5c				db WORD_SYS_CORE+72             
2a69 56 2c			dw .FORGET            
2a6b 05				db 4 + 1 
2a6c .. 00			db "LIST",0              
2a71				endm 
# End of macro CWHEAD
2a71			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a71			; | | The quoted word must be in upper case. 
2a71				if DEBUG_FORTH_WORDS_KEY 
2a71					DMARK "LST" 
2a71 f5				push af  
2a72 3a 86 2a			ld a, (.dmark)  
2a75 32 b4 fe			ld (debug_mark),a  
2a78 3a 87 2a			ld a, (.dmark+1)  
2a7b 32 b5 fe			ld (debug_mark+1),a  
2a7e 3a 88 2a			ld a, (.dmark+2)  
2a81 32 b6 fe			ld (debug_mark+2),a  
2a84 18 03			jr .pastdmark  
2a86 ..			.dmark: db "LST"  
2a89 f1			.pastdmark: pop af  
2a8a			endm  
# End of macro DMARK
2a8a					CALLMONITOR 
2a8a cd 57 17			call break_point_state  
2a8d				endm  
# End of macro CALLMONITOR
2a8d				endif 
2a8d			 
2a8d					FORTH_DSP_VALUEHL 
2a8d cd ab 1f			call macro_dsp_valuehl 
2a90				endm 
# End of macro FORTH_DSP_VALUEHL
2a90			 
2a90 e5					push hl 
2a91					FORTH_DSP_POP 
2a91 cd 63 20			call macro_forth_dsp_pop 
2a94				endm 
# End of macro FORTH_DSP_POP
2a94 c1					pop bc 
2a95			 
2a95			; Start format of scratch string 
2a95			 
2a95 21 5a f4				ld hl, scratch 
2a98			 
2a98 3e 3a				ld a, ':' 
2a9a 77					ld (hl),a 
2a9b 23					inc hl 
2a9c 3e 20				ld a, ' ' 
2a9e 77					ld (hl), a 
2a9f			 
2a9f					; Get ptr to the word we need to look up 
2a9f			 
2a9f			;		FORTH_DSP_VALUEHL 
2a9f					;v5 FORTH_DSP_VALUE 
2a9f				; TODO type check 
2a9f			;		inc hl    ; Skip type check  
2a9f			;		push hl 
2a9f			;		ex de, hl    ; put into DE 
2a9f			 
2a9f			 
2a9f 21 00 80				ld hl, baseram 
2aa2					;ld hl, baseusermem 
2aa2			 
2aa2 e5			push hl   ; sacreifical push 
2aa3			 
2aa3			.ldouscanm: 
2aa3 e1				pop hl 
2aa4			.ldouscan: 
2aa4				if DEBUG_FORTH_WORDS 
2aa4					DMARK "LSs" 
2aa4 f5				push af  
2aa5 3a b9 2a			ld a, (.dmark)  
2aa8 32 b4 fe			ld (debug_mark),a  
2aab 3a ba 2a			ld a, (.dmark+1)  
2aae 32 b5 fe			ld (debug_mark+1),a  
2ab1 3a bb 2a			ld a, (.dmark+2)  
2ab4 32 b6 fe			ld (debug_mark+2),a  
2ab7 18 03			jr .pastdmark  
2ab9 ..			.dmark: db "LSs"  
2abc f1			.pastdmark: pop af  
2abd			endm  
# End of macro DMARK
2abd					CALLMONITOR 
2abd cd 57 17			call break_point_state  
2ac0				endm  
# End of macro CALLMONITOR
2ac0				endif 
2ac0				; skip dict stub 
2ac0 cd 6e 22				call forth_tok_next 
2ac3			 
2ac3			 
2ac3			; while we have words to look for 
2ac3			 
2ac3 7e				ld a, (hl)      
2ac4				if DEBUG_FORTH_WORDS 
2ac4					DMARK "LSk" 
2ac4 f5				push af  
2ac5 3a d9 2a			ld a, (.dmark)  
2ac8 32 b4 fe			ld (debug_mark),a  
2acb 3a da 2a			ld a, (.dmark+1)  
2ace 32 b5 fe			ld (debug_mark+1),a  
2ad1 3a db 2a			ld a, (.dmark+2)  
2ad4 32 b6 fe			ld (debug_mark+2),a  
2ad7 18 03			jr .pastdmark  
2ad9 ..			.dmark: db "LSk"  
2adc f1			.pastdmark: pop af  
2add			endm  
# End of macro DMARK
2add					CALLMONITOR 
2add cd 57 17			call break_point_state  
2ae0				endm  
# End of macro CALLMONITOR
2ae0				endif 
2ae0					;cp WORD_SYS_END 
2ae0					;jp z, .lunotfound 
2ae0			 
2ae0					; if we hit non uwords then gone too far 
2ae0 fe 01				cp WORD_SYS_UWORD 
2ae2 c2 12 2c				jp nz, .lunotfound 
2ae5			 
2ae5				if DEBUG_FORTH_WORDS 
2ae5					DMARK "LSu" 
2ae5 f5				push af  
2ae6 3a fa 2a			ld a, (.dmark)  
2ae9 32 b4 fe			ld (debug_mark),a  
2aec 3a fb 2a			ld a, (.dmark+1)  
2aef 32 b5 fe			ld (debug_mark+1),a  
2af2 3a fc 2a			ld a, (.dmark+2)  
2af5 32 b6 fe			ld (debug_mark+2),a  
2af8 18 03			jr .pastdmark  
2afa ..			.dmark: db "LSu"  
2afd f1			.pastdmark: pop af  
2afe			endm  
# End of macro DMARK
2afe					CALLMONITOR 
2afe cd 57 17			call break_point_state  
2b01				endm  
# End of macro CALLMONITOR
2b01				endif 
2b01			 
2b01					; found a uword but is it the one we want... 
2b01			 
2b01 c5					push bc     ; uword to find is on bc 
2b02 d1					pop de 
2b03			 
2b03 e5					push hl  ; to save the ptr 
2b04			 
2b04					; skip opcode 
2b04 23					inc hl  
2b05					; skip next ptr 
2b05 23					inc hl  
2b06 23					inc hl 
2b07					; skip len 
2b07 23					inc hl 
2b08			 
2b08				if DEBUG_FORTH_WORDS 
2b08					DMARK "LSc" 
2b08 f5				push af  
2b09 3a 1d 2b			ld a, (.dmark)  
2b0c 32 b4 fe			ld (debug_mark),a  
2b0f 3a 1e 2b			ld a, (.dmark+1)  
2b12 32 b5 fe			ld (debug_mark+1),a  
2b15 3a 1f 2b			ld a, (.dmark+2)  
2b18 32 b6 fe			ld (debug_mark+2),a  
2b1b 18 03			jr .pastdmark  
2b1d ..			.dmark: db "LSc"  
2b20 f1			.pastdmark: pop af  
2b21			endm  
# End of macro DMARK
2b21					CALLMONITOR 
2b21 cd 57 17			call break_point_state  
2b24				endm  
# End of macro CALLMONITOR
2b24				endif 
2b24 cd 70 12				call strcmp 
2b27 c2 a3 2a				jp nz, .ldouscanm 
2b2a				 
2b2a			 
2b2a			 
2b2a					; we have a uword so push its name to the stack 
2b2a			 
2b2a			;	   	push hl  ; save so we can move to next dict block 
2b2a e1			pop hl 
2b2b			 
2b2b				if DEBUG_FORTH_WORDS 
2b2b					DMARK "LSm" 
2b2b f5				push af  
2b2c 3a 40 2b			ld a, (.dmark)  
2b2f 32 b4 fe			ld (debug_mark),a  
2b32 3a 41 2b			ld a, (.dmark+1)  
2b35 32 b5 fe			ld (debug_mark+1),a  
2b38 3a 42 2b			ld a, (.dmark+2)  
2b3b 32 b6 fe			ld (debug_mark+2),a  
2b3e 18 03			jr .pastdmark  
2b40 ..			.dmark: db "LSm"  
2b43 f1			.pastdmark: pop af  
2b44			endm  
# End of macro DMARK
2b44					CALLMONITOR 
2b44 cd 57 17			call break_point_state  
2b47				endm  
# End of macro CALLMONITOR
2b47				endif 
2b47			 
2b47					; skip opcode 
2b47 23					inc hl  
2b48					; skip next ptr 
2b48 23					inc hl  
2b49 23					inc hl 
2b4a					; skip len 
2b4a 7e					ld a, (hl)   ; save length to add 
2b4b				if DEBUG_FORTH_WORDS 
2b4b					DMARK "LS2" 
2b4b f5				push af  
2b4c 3a 60 2b			ld a, (.dmark)  
2b4f 32 b4 fe			ld (debug_mark),a  
2b52 3a 61 2b			ld a, (.dmark+1)  
2b55 32 b5 fe			ld (debug_mark+1),a  
2b58 3a 62 2b			ld a, (.dmark+2)  
2b5b 32 b6 fe			ld (debug_mark+2),a  
2b5e 18 03			jr .pastdmark  
2b60 ..			.dmark: db "LS2"  
2b63 f1			.pastdmark: pop af  
2b64			endm  
# End of macro DMARK
2b64					CALLMONITOR 
2b64 cd 57 17			call break_point_state  
2b67				endm  
# End of macro CALLMONITOR
2b67				endif 
2b67			 
2b67					; save this location 
2b67				 
2b67 e5					push hl 
2b68			 
2b68 23					inc hl 
2b69 11 5c f4				ld de, scratch+2 
2b6c 4f					ld c, a 
2b6d 06 00				ld b, 0 
2b6f			 
2b6f				if DEBUG_FORTH_WORDS 
2b6f					DMARK "LSn" 
2b6f f5				push af  
2b70 3a 84 2b			ld a, (.dmark)  
2b73 32 b4 fe			ld (debug_mark),a  
2b76 3a 85 2b			ld a, (.dmark+1)  
2b79 32 b5 fe			ld (debug_mark+1),a  
2b7c 3a 86 2b			ld a, (.dmark+2)  
2b7f 32 b6 fe			ld (debug_mark+2),a  
2b82 18 03			jr .pastdmark  
2b84 ..			.dmark: db "LSn"  
2b87 f1			.pastdmark: pop af  
2b88			endm  
# End of macro DMARK
2b88					CALLMONITOR 
2b88 cd 57 17			call break_point_state  
2b8b				endm  
# End of macro CALLMONITOR
2b8b				endif 
2b8b			 
2b8b					; copy uword name to scratch 
2b8b			 
2b8b ed b0				ldir 
2b8d			 
2b8d 1b					dec de 
2b8e 3e 20				ld a, ' '    ; change null to space 
2b90 12					ld (de), a 
2b91			 
2b91 13					inc de 
2b92			 
2b92 d5					push de 
2b93 c1					pop bc     ; move scratch pointer to end of word name and save it 
2b94			 
2b94 e1					pop hl 
2b95 7e					ld a, (hl) 
2b96					;inc hl 
2b96					; skip word string 
2b96 cd da 0d				call addatohl 
2b99			 
2b99 23					inc hl 
2b9a			 
2b9a				if DEBUG_FORTH_WORDS 
2b9a					DMARK "LS3" 
2b9a f5				push af  
2b9b 3a af 2b			ld a, (.dmark)  
2b9e 32 b4 fe			ld (debug_mark),a  
2ba1 3a b0 2b			ld a, (.dmark+1)  
2ba4 32 b5 fe			ld (debug_mark+1),a  
2ba7 3a b1 2b			ld a, (.dmark+2)  
2baa 32 b6 fe			ld (debug_mark+2),a  
2bad 18 03			jr .pastdmark  
2baf ..			.dmark: db "LS3"  
2bb2 f1			.pastdmark: pop af  
2bb3			endm  
# End of macro DMARK
2bb3					CALLMONITOR 
2bb3 cd 57 17			call break_point_state  
2bb6				endm  
# End of macro CALLMONITOR
2bb6				endif 
2bb6					; should now be at the start of the machine code to setup the eval of the uword 
2bb6					; now locate the ptr to the string defintion 
2bb6			 
2bb6					; skip ld hl, 
2bb6					; then load the ptr 
2bb6			; TODO use get from hl ptr 
2bb6 23					inc hl 
2bb7 5e					ld e, (hl) 
2bb8 23					inc hl 
2bb9 56					ld d, (hl) 
2bba eb					ex de, hl 
2bbb			 
2bbb			 
2bbb				if DEBUG_FORTH_WORDS 
2bbb					DMARK "LSt" 
2bbb f5				push af  
2bbc 3a d0 2b			ld a, (.dmark)  
2bbf 32 b4 fe			ld (debug_mark),a  
2bc2 3a d1 2b			ld a, (.dmark+1)  
2bc5 32 b5 fe			ld (debug_mark+1),a  
2bc8 3a d2 2b			ld a, (.dmark+2)  
2bcb 32 b6 fe			ld (debug_mark+2),a  
2bce 18 03			jr .pastdmark  
2bd0 ..			.dmark: db "LSt"  
2bd3 f1			.pastdmark: pop af  
2bd4			endm  
# End of macro DMARK
2bd4					CALLMONITOR 
2bd4 cd 57 17			call break_point_state  
2bd7				endm  
# End of macro CALLMONITOR
2bd7				endif 
2bd7			 
2bd7			; cant push right now due to tokenised strings  
2bd7			 
2bd7			; get the destination of where to copy this definition to. 
2bd7			 
2bd7 c5					push bc 
2bd8 d1					pop de 
2bd9			 
2bd9 7e			.listl:         ld a,(hl) 
2bda fe 00				cp 0 
2bdc 28 09				jr z, .lreplsp     ; replace zero with space 
2bde					;cp FORTH_END_BUFFER 
2bde fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2be0 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2be2				 
2be2					; just copy this char as is then 
2be2			 
2be2 12					ld (de), a 
2be3			 
2be3 23			.listnxt:	inc hl 
2be4 13					inc de 
2be5 18 f2				jr .listl 
2be7			 
2be7 3e 20		.lreplsp:	ld a,' ' 
2be9 12					ld (de), a 
2bea 18 f7				jr .listnxt 
2bec			 
2bec			; close up uword def 
2bec			 
2bec			.listdone: 
2bec 12					ld (de), a 
2bed 13					inc de 
2bee 3e 00				ld a, 0 
2bf0 12					ld (de), a 
2bf1			 
2bf1			; now have def so clean up and push to stack 
2bf1			 
2bf1 21 5a f4				ld hl, scratch 
2bf4				if DEBUG_FORTH_WORDS 
2bf4					DMARK "Ltp" 
2bf4 f5				push af  
2bf5 3a 09 2c			ld a, (.dmark)  
2bf8 32 b4 fe			ld (debug_mark),a  
2bfb 3a 0a 2c			ld a, (.dmark+1)  
2bfe 32 b5 fe			ld (debug_mark+1),a  
2c01 3a 0b 2c			ld a, (.dmark+2)  
2c04 32 b6 fe			ld (debug_mark+2),a  
2c07 18 03			jr .pastdmark  
2c09 ..			.dmark: db "Ltp"  
2c0c f1			.pastdmark: pop af  
2c0d			endm  
# End of macro DMARK
2c0d					CALLMONITOR 
2c0d cd 57 17			call break_point_state  
2c10				endm  
# End of macro CALLMONITOR
2c10				endif 
2c10			 
2c10 18 1f			jr .listpush 
2c12			 
2c12			;.lnuword:	pop hl 
2c12			;		call forth_tok_next 
2c12			;		jp .ldouscan  
2c12			 
2c12			.lunotfound:		  
2c12			 
2c12				if DEBUG_FORTH_WORDS 
2c12					DMARK "LSn" 
2c12 f5				push af  
2c13 3a 27 2c			ld a, (.dmark)  
2c16 32 b4 fe			ld (debug_mark),a  
2c19 3a 28 2c			ld a, (.dmark+1)  
2c1c 32 b5 fe			ld (debug_mark+1),a  
2c1f 3a 29 2c			ld a, (.dmark+2)  
2c22 32 b6 fe			ld (debug_mark+2),a  
2c25 18 03			jr .pastdmark  
2c27 ..			.dmark: db "LSn"  
2c2a f1			.pastdmark: pop af  
2c2b			endm  
# End of macro DMARK
2c2b					CALLMONITOR 
2c2b cd 57 17			call break_point_state  
2c2e				endm  
# End of macro CALLMONITOR
2c2e				endif 
2c2e			 
2c2e					 
2c2e			;		FORTH_DSP_POP 
2c2e			;		ld hl, .luno 
2c2e			 
2c2e					NEXTW			 
2c2e c3 1d 21			jp macro_next 
2c31				endm 
# End of macro NEXTW
2c31			 
2c31			.listpush: 
2c31				if DEBUG_FORTH_WORDS 
2c31					DMARK "LS>" 
2c31 f5				push af  
2c32 3a 46 2c			ld a, (.dmark)  
2c35 32 b4 fe			ld (debug_mark),a  
2c38 3a 47 2c			ld a, (.dmark+1)  
2c3b 32 b5 fe			ld (debug_mark+1),a  
2c3e 3a 48 2c			ld a, (.dmark+2)  
2c41 32 b6 fe			ld (debug_mark+2),a  
2c44 18 03			jr .pastdmark  
2c46 ..			.dmark: db "LS>"  
2c49 f1			.pastdmark: pop af  
2c4a			endm  
# End of macro DMARK
2c4a					CALLMONITOR 
2c4a cd 57 17			call break_point_state  
2c4d				endm  
# End of macro CALLMONITOR
2c4d				endif 
2c4d cd 22 1e				call forth_push_str 
2c50			 
2c50			 
2c50			 
2c50					NEXTW 
2c50 c3 1d 21			jp macro_next 
2c53				endm 
# End of macro NEXTW
2c53			 
2c53			;.luno:    db "Word not found",0 
2c53			 
2c53			 
2c53			 
2c53			 
2c53			 
2c53			;		push hl   ; save pointer to start of uword def string 
2c53			; 
2c53			;; look for FORTH_EOL_LINE 
2c53			;		ld a, FORTH_END_BUFFER 
2c53			;		call strlent 
2c53			; 
2c53			;		inc hl		 ; space for coln def 
2c53			;		inc hl 
2c53			;		inc hl          ; space for terms 
2c53			;		inc hl 
2c53			; 
2c53			;		ld a, 20   ; TODO get actual length 
2c53			;		call addatohl    ; include a random amount of room for the uword name 
2c53			; 
2c53			;		 
2c53			;	if DEBUG_FORTH_WORDS 
2c53			;		DMARK "Lt1" 
2c53			;		CALLMONITOR 
2c53			;	endif 
2c53			;		 
2c53			; 
2c53			;; malloc space for the string because we cant change it 
2c53			; 
2c53			;		call malloc 
2c53			;	if DEBUG_FORTH_MALLOC_GUARD 
2c53			;		push af 
2c53			;		call ishlzero 
2c53			;		pop af 
2c53			;		 
2c53			;		call z,malloc_error 
2c53			;	endif 
2c53			; 
2c53			;	if DEBUG_FORTH_WORDS 
2c53			;		DMARK "Lt2" 
2c53			;		CALLMONITOR 
2c53			;	endif 
2c53			;		pop de 
2c53			;		push hl    ; push the malloc to release later 
2c53			;		push hl   ;  push back a copy for the later stack push 
2c53			;		 
2c53			;; copy the string swapping out the zero terms for spaces 
2c53			; 
2c53			;		; de has our source 
2c53			;		; hl has our dest 
2c53			; 
2c53			;; add the coln def 
2c53			; 
2c53			;		ld a, ':' 
2c53			;		ld (hl), a 
2c53			;		inc hl 
2c53			;		ld a, ' ' 
2c53			;		ld (hl), a 
2c53			;		inc hl 
2c53			; 
2c53			;; add the uname word 
2c53			;		push de   ; save our string for now 
2c53			;		ex de, hl 
2c53			; 
2c53			;		FORTH_DSP_VALUE 
2c53			;		;v5 FORTH_DSP_VALUE 
2c53			; 
2c53			;		inc hl   ; skip type but we know by now this is OK 
2c53			; 
2c53			;.luword:	ld a,(hl) 
2c53			;		cp 0 
2c53			;		jr z, .luword2 
2c53			;		ld (de), a 
2c53			;		inc de 
2c53			;		inc hl 
2c53			;		jr .luword 
2c53			; 
2c53			;.luword2:	ld a, ' ' 
2c53			;		ld (de), a 
2c53			;;		inc hl 
2c53			;;		inc de 
2c53			;;		ld (de), a 
2c53			;;		inc hl 
2c53			;		inc de 
2c53			; 
2c53			;		ex de, hl 
2c53			;		pop de 
2c53			;		 
2c53			;		 
2c53			; 
2c53			;; detoken that string and copy it 
2c53			; 
2c53			;	if DEBUG_FORTH_WORDS 
2c53			;		DMARK "Lt2" 
2c53			;		CALLMONITOR 
2c53			;	endif 
2c53			;.ldetok:	ld a, (de) 
2c53			;		cp FORTH_END_BUFFER 
2c53			;		jr z, .ldetokend 
2c53			;		; swap out any zero term for space 
2c53			;		cp 0 
2c53			;		jr nz, .ldetoknext 
2c53			;		ld a, ' ' 
2c53			; 
2c53			;	if DEBUG_FORTH_WORDS 
2c53			;		DMARK "LtS" 
2c53			;		CALLMONITOR 
2c53			;	endif 
2c53			;.ldetoknext:	ld (hl), a 
2c53			;		inc de 
2c53			;		inc hl 
2c53			;		jr .ldetok 
2c53			; 
2c53			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c53			;		ld (hl), a  
2c53			; 
2c53			;; free that temp malloc 
2c53			; 
2c53			;		pop hl    
2c53			; 
2c53			;	if DEBUG_FORTH_WORDS 
2c53			;		DMARK "Lt4" 
2c53			;		CALLMONITOR 
2c53			;	endif 
2c53			;		call forth_apushstrhl 
2c53			; 
2c53			;		; get rid of temp malloc area 
2c53			; 
2c53			;		pop hl 
2c53			;		call free 
2c53			; 
2c53			;		jr .ludone 
2c53			; 
2c53			;.lnuword:	pop hl 
2c53			;		call forth_tok_next 
2c53			;		jp .ldouscan  
2c53			; 
2c53			;.ludone:		 pop hl 
2c53			; 
2c53					NEXTW 
2c53 c3 1d 21			jp macro_next 
2c56				endm 
# End of macro NEXTW
2c56			 
2c56			.FORGET: 
2c56				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c56 5d				db WORD_SYS_CORE+73             
2c57 cf 2c			dw .NOP            
2c59 07				db 6 + 1 
2c5a .. 00			db "FORGET",0              
2c61				endm 
# End of macro CWHEAD
2c61			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2c61			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2c61			; | |  
2c61			; | | e.g. "MORE" forget 
2c61					if DEBUG_FORTH_WORDS_KEY 
2c61						DMARK "FRG" 
2c61 f5				push af  
2c62 3a 76 2c			ld a, (.dmark)  
2c65 32 b4 fe			ld (debug_mark),a  
2c68 3a 77 2c			ld a, (.dmark+1)  
2c6b 32 b5 fe			ld (debug_mark+1),a  
2c6e 3a 78 2c			ld a, (.dmark+2)  
2c71 32 b6 fe			ld (debug_mark+2),a  
2c74 18 03			jr .pastdmark  
2c76 ..			.dmark: db "FRG"  
2c79 f1			.pastdmark: pop af  
2c7a			endm  
# End of macro DMARK
2c7a						CALLMONITOR 
2c7a cd 57 17			call break_point_state  
2c7d				endm  
# End of macro CALLMONITOR
2c7d					endif 
2c7d			 
2c7d				; find uword 
2c7d			        ; update start of word with "_" 
2c7d				; replace uword with deleted flag 
2c7d			 
2c7d			 
2c7d			;	if DEBUG_FORTH_WORDS 
2c7d			;		DMARK "FOG" 
2c7d			;		CALLMONITOR 
2c7d			;	endif 
2c7d			 
2c7d			 
2c7d					; Get ptr to the word we need to look up 
2c7d			 
2c7d					FORTH_DSP_VALUEHL 
2c7d cd ab 1f			call macro_dsp_valuehl 
2c80				endm 
# End of macro FORTH_DSP_VALUEHL
2c80					;v5 FORTH_DSP_VALUE 
2c80				; TODO type check 
2c80			;		inc hl    ; Skip type check  
2c80 e5					push hl 
2c81 c1					pop bc 
2c82			;		ex de, hl    ; put into DE 
2c82			 
2c82			 
2c82 21 00 80				ld hl, baseram 
2c85					;ld hl, baseusermem 
2c85			 
2c85				; skip dict stub 
2c85			;	call forth_tok_next 
2c85 e5			push hl   ; sacreifical push 
2c86			 
2c86			.fldouscanm: 
2c86 e1				pop hl 
2c87			.fldouscan: 
2c87			;	if DEBUG_FORTH_WORDS 
2c87			;		DMARK "LSs" 
2c87			;		CALLMONITOR 
2c87			;	endif 
2c87				; skip dict stub 
2c87 cd 6e 22				call forth_tok_next 
2c8a			 
2c8a			 
2c8a			; while we have words to look for 
2c8a			 
2c8a 7e				ld a, (hl)      
2c8b			;	if DEBUG_FORTH_WORDS 
2c8b			;		DMARK "LSk" 
2c8b			;		CALLMONITOR 
2c8b			;	endif 
2c8b fe 00				cp WORD_SYS_END 
2c8d ca c9 2c				jp z, .flunotfound 
2c90 fe 01				cp WORD_SYS_UWORD 
2c92 c2 87 2c				jp nz, .fldouscan 
2c95			 
2c95			;	if DEBUG_FORTH_WORDS 
2c95			;		DMARK "LSu" 
2c95			;		CALLMONITOR 
2c95			;	endif 
2c95			 
2c95					; found a uword but is it the one we want... 
2c95			 
2c95 c5					push bc     ; uword to find is on bc 
2c96 d1					pop de 
2c97			 
2c97 e5					push hl  ; to save the ptr 
2c98			 
2c98					; skip opcode 
2c98 23					inc hl  
2c99					; skip next ptr 
2c99 23					inc hl  
2c9a 23					inc hl 
2c9b					; skip len 
2c9b 23					inc hl 
2c9c			 
2c9c			;	if DEBUG_FORTH_WORDS 
2c9c			;		DMARK "LSc" 
2c9c			;		CALLMONITOR 
2c9c			;	endif 
2c9c cd 70 12				call strcmp 
2c9f c2 86 2c				jp nz, .fldouscanm 
2ca2			; 
2ca2			; 
2ca2			;; while we have words to look for 
2ca2			; 
2ca2			;.fdouscan:	ld a, (hl)      
2ca2			;	if DEBUG_FORTH_WORDS 
2ca2			;		DMARK "LSs" 
2ca2			;		CALLMONITOR 
2ca2			;	endif 
2ca2			;		cp WORD_SYS_END 
2ca2			;		jp z, .fudone 
2ca2			;		cp WORD_SYS_UWORD 
2ca2			;		jp nz, .fnuword 
2ca2			; 
2ca2			;	if DEBUG_FORTH_WORDS 
2ca2			;		DMARK "FGu" 
2ca2			;		CALLMONITOR 
2ca2			;	endif 
2ca2			; 
2ca2			;		; found a uword but is it the one we want... 
2ca2			; 
2ca2			; 
2ca2			;	        pop de   ; get back the dsp name 
2ca2			;		push de 
2ca2			; 
2ca2			;		push hl  ; to save the ptr 
2ca2			; 
2ca2			;		; skip opcode 
2ca2			;		inc hl  
2ca2			;		; skip next ptr 
2ca2			;		inc hl  
2ca2			;		inc hl 
2ca2			;		; skip len 
2ca2			;		inc hl 
2ca2			; 
2ca2			;	if DEBUG_FORTH_WORDS 
2ca2			;		DMARK "FGc" 
2ca2			;		CALLMONITOR 
2ca2			;	endif 
2ca2			;		call strcmp 
2ca2			;		jp nz, .fnuword 
2ca2			 
2ca2			 
2ca2 e1			pop hl 
2ca3			 
2ca3				 
2ca3				if DEBUG_FORTH_WORDS 
2ca3					DMARK "FGm" 
2ca3 f5				push af  
2ca4 3a b8 2c			ld a, (.dmark)  
2ca7 32 b4 fe			ld (debug_mark),a  
2caa 3a b9 2c			ld a, (.dmark+1)  
2cad 32 b5 fe			ld (debug_mark+1),a  
2cb0 3a ba 2c			ld a, (.dmark+2)  
2cb3 32 b6 fe			ld (debug_mark+2),a  
2cb6 18 03			jr .pastdmark  
2cb8 ..			.dmark: db "FGm"  
2cbb f1			.pastdmark: pop af  
2cbc			endm  
# End of macro DMARK
2cbc					CALLMONITOR 
2cbc cd 57 17			call break_point_state  
2cbf				endm  
# End of macro CALLMONITOR
2cbf				endif 
2cbf			 
2cbf			 
2cbf			 
2cbf					; we have a uword so push its name to the stack 
2cbf			 
2cbf			;	   	push hl  ; save so we can move to next dict block 
2cbf			;pop hl 
2cbf			 
2cbf					; update opcode to deleted 
2cbf 3e 03				ld a, WORD_SYS_DELETED 
2cc1 77					ld (hl), a 
2cc2			 
2cc2 23					inc hl  
2cc3					; skip next ptr 
2cc3 23					inc hl  
2cc4 23					inc hl 
2cc5					; skip len 
2cc5 23					inc hl 
2cc6			 
2cc6					; TODO change parser to skip deleted words but for now mark it out 
2cc6 3e 5f				ld a, "_" 
2cc8 77					ld  (hl),a 
2cc9			 
2cc9			;		jr .fudone 
2cc9			; 
2cc9			;.fnuword:	pop hl 
2cc9			;		call forth_tok_next 
2cc9			;		jp .fdouscan  
2cc9			 
2cc9			.flunotfound:		  
2cc9			 
2cc9			 
2cc9					 
2cc9					FORTH_DSP_POP 
2cc9 cd 63 20			call macro_forth_dsp_pop 
2ccc				endm 
# End of macro FORTH_DSP_POP
2ccc			;		ld hl, .luno 
2ccc			;.fudone:		 pop hl 
2ccc					NEXTW 
2ccc c3 1d 21			jp macro_next 
2ccf				endm 
# End of macro NEXTW
2ccf			.NOP: 
2ccf				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ccf 61				db WORD_SYS_CORE+77             
2cd0 f6 2c			dw .COMO            
2cd2 04				db 3 + 1 
2cd3 .. 00			db "NOP",0              
2cd7				endm 
# End of macro CWHEAD
2cd7			; | NOP (  --  ) Do nothing | DONE 
2cd7					if DEBUG_FORTH_WORDS_KEY 
2cd7						DMARK "NOP" 
2cd7 f5				push af  
2cd8 3a ec 2c			ld a, (.dmark)  
2cdb 32 b4 fe			ld (debug_mark),a  
2cde 3a ed 2c			ld a, (.dmark+1)  
2ce1 32 b5 fe			ld (debug_mark+1),a  
2ce4 3a ee 2c			ld a, (.dmark+2)  
2ce7 32 b6 fe			ld (debug_mark+2),a  
2cea 18 03			jr .pastdmark  
2cec ..			.dmark: db "NOP"  
2cef f1			.pastdmark: pop af  
2cf0			endm  
# End of macro DMARK
2cf0						CALLMONITOR 
2cf0 cd 57 17			call break_point_state  
2cf3				endm  
# End of macro CALLMONITOR
2cf3					endif 
2cf3				       NEXTW 
2cf3 c3 1d 21			jp macro_next 
2cf6				endm 
# End of macro NEXTW
2cf6			.COMO: 
2cf6				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2cf6 6e				db WORD_SYS_CORE+90             
2cf7 48 2d			dw .COMC            
2cf9 02				db 1 + 1 
2cfa .. 00			db "(",0              
2cfc				endm 
# End of macro CWHEAD
2cfc			; | ( ( -- )  Start of comment | DONE 
2cfc			 
2cfc			 
2cfc 2a 5b f7				ld hl, ( os_tok_ptr) 
2cff 11 43 2d			ld de, .closepar 
2d02					 
2d02					if DEBUG_FORTH_WORDS 
2d02						DMARK ").." 
2d02 f5				push af  
2d03 3a 17 2d			ld a, (.dmark)  
2d06 32 b4 fe			ld (debug_mark),a  
2d09 3a 18 2d			ld a, (.dmark+1)  
2d0c 32 b5 fe			ld (debug_mark+1),a  
2d0f 3a 19 2d			ld a, (.dmark+2)  
2d12 32 b6 fe			ld (debug_mark+2),a  
2d15 18 03			jr .pastdmark  
2d17 ..			.dmark: db ").."  
2d1a f1			.pastdmark: pop af  
2d1b			endm  
# End of macro DMARK
2d1b						CALLMONITOR 
2d1b cd 57 17			call break_point_state  
2d1e				endm  
# End of macro CALLMONITOR
2d1e					endif 
2d1e cd 38 22			call findnexttok  
2d21			 
2d21					if DEBUG_FORTH_WORDS 
2d21						DMARK "IF5" 
2d21 f5				push af  
2d22 3a 36 2d			ld a, (.dmark)  
2d25 32 b4 fe			ld (debug_mark),a  
2d28 3a 37 2d			ld a, (.dmark+1)  
2d2b 32 b5 fe			ld (debug_mark+1),a  
2d2e 3a 38 2d			ld a, (.dmark+2)  
2d31 32 b6 fe			ld (debug_mark+2),a  
2d34 18 03			jr .pastdmark  
2d36 ..			.dmark: db "IF5"  
2d39 f1			.pastdmark: pop af  
2d3a			endm  
# End of macro DMARK
2d3a						CALLMONITOR 
2d3a cd 57 17			call break_point_state  
2d3d				endm  
# End of macro CALLMONITOR
2d3d					endif 
2d3d				; replace below with ) exec using tok_ptr 
2d3d 22 5b f7			ld (os_tok_ptr), hl 
2d40 c3 ae 21			jp exec1 
2d43			 
2d43 .. 00			.closepar:   db ")",0 
2d45			 
2d45				       NEXTW 
2d45 c3 1d 21			jp macro_next 
2d48				endm 
# End of macro NEXTW
2d48			.COMC: 
2d48				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2d48 6f				db WORD_SYS_CORE+91             
2d49 51 2d			dw .SCRATCH            
2d4b 02				db 1 + 1 
2d4c .. 00			db ")",0              
2d4e				endm 
# End of macro CWHEAD
2d4e			; | ) ( -- )  End of comment |  DONE  
2d4e				       NEXTW 
2d4e c3 1d 21			jp macro_next 
2d51				endm 
# End of macro NEXTW
2d51			 
2d51			.SCRATCH: 
2d51				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2d51 6f				db WORD_SYS_CORE+91             
2d52 8c 2d			dw .INC            
2d54 08				db 7 + 1 
2d55 .. 00			db "SCRATCH",0              
2d5d				endm 
# End of macro CWHEAD
2d5d			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2d5d			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2d5d			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2d5d			; | |  
2d5d			; | | e.g.    : score $00 scratch ; 
2d5d			; | |  
2d5d			; | | $00 score ! 
2d5d			; | | $01 score +! 
2d5d			; | |  
2d5d			; | | e.g.   : varword $0a scratch ;  
2d5d			; | | 
2d5d			; | | $8000 varword ! 
2d5d					if DEBUG_FORTH_WORDS_KEY 
2d5d						DMARK "SCR" 
2d5d f5				push af  
2d5e 3a 72 2d			ld a, (.dmark)  
2d61 32 b4 fe			ld (debug_mark),a  
2d64 3a 73 2d			ld a, (.dmark+1)  
2d67 32 b5 fe			ld (debug_mark+1),a  
2d6a 3a 74 2d			ld a, (.dmark+2)  
2d6d 32 b6 fe			ld (debug_mark+2),a  
2d70 18 03			jr .pastdmark  
2d72 ..			.dmark: db "SCR"  
2d75 f1			.pastdmark: pop af  
2d76			endm  
# End of macro DMARK
2d76						CALLMONITOR 
2d76 cd 57 17			call break_point_state  
2d79				endm  
# End of macro CALLMONITOR
2d79					endif 
2d79			 
2d79					FORTH_DSP_VALUEHL 
2d79 cd ab 1f			call macro_dsp_valuehl 
2d7c				endm 
# End of macro FORTH_DSP_VALUEHL
2d7c				 
2d7c					FORTH_DSP_POP 
2d7c cd 63 20			call macro_forth_dsp_pop 
2d7f				endm 
# End of macro FORTH_DSP_POP
2d7f			 
2d7f 7d					ld a, l 
2d80 21 7f f9				ld hl, os_var_array 
2d83 cd da 0d				call addatohl 
2d86			 
2d86 cd b4 1d				call forth_push_numhl 
2d89			 
2d89				       NEXTW 
2d89 c3 1d 21			jp macro_next 
2d8c				endm 
# End of macro NEXTW
2d8c			 
2d8c			.INC: 
2d8c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2d8c 6f				db WORD_SYS_CORE+91             
2d8d e0 2d			dw .DEC            
2d8f 03				db 2 + 1 
2d90 .. 00			db "+!",0              
2d93				endm 
# End of macro CWHEAD
2d93			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2d93					if DEBUG_FORTH_WORDS_KEY 
2d93						DMARK "+s_" 
2d93 f5				push af  
2d94 3a a8 2d			ld a, (.dmark)  
2d97 32 b4 fe			ld (debug_mark),a  
2d9a 3a a9 2d			ld a, (.dmark+1)  
2d9d 32 b5 fe			ld (debug_mark+1),a  
2da0 3a aa 2d			ld a, (.dmark+2)  
2da3 32 b6 fe			ld (debug_mark+2),a  
2da6 18 03			jr .pastdmark  
2da8 ..			.dmark: db "+s_"  
2dab f1			.pastdmark: pop af  
2dac			endm  
# End of macro DMARK
2dac						CALLMONITOR 
2dac cd 57 17			call break_point_state  
2daf				endm  
# End of macro CALLMONITOR
2daf					endif 
2daf			 
2daf					FORTH_DSP_VALUEHL 
2daf cd ab 1f			call macro_dsp_valuehl 
2db2				endm 
# End of macro FORTH_DSP_VALUEHL
2db2			 
2db2 e5					push hl   ; save address 
2db3			 
2db3					FORTH_DSP_POP 
2db3 cd 63 20			call macro_forth_dsp_pop 
2db6				endm 
# End of macro FORTH_DSP_POP
2db6			 
2db6					FORTH_DSP_VALUEHL 
2db6 cd ab 1f			call macro_dsp_valuehl 
2db9				endm 
# End of macro FORTH_DSP_VALUEHL
2db9			 
2db9					FORTH_DSP_POP 
2db9 cd 63 20			call macro_forth_dsp_pop 
2dbc				endm 
# End of macro FORTH_DSP_POP
2dbc			 
2dbc					; hl contains value to add to byte at a 
2dbc				 
2dbc eb					ex de, hl 
2dbd			 
2dbd e1					pop hl 
2dbe			 
2dbe					if DEBUG_FORTH_WORDS 
2dbe						DMARK "INC" 
2dbe f5				push af  
2dbf 3a d3 2d			ld a, (.dmark)  
2dc2 32 b4 fe			ld (debug_mark),a  
2dc5 3a d4 2d			ld a, (.dmark+1)  
2dc8 32 b5 fe			ld (debug_mark+1),a  
2dcb 3a d5 2d			ld a, (.dmark+2)  
2dce 32 b6 fe			ld (debug_mark+2),a  
2dd1 18 03			jr .pastdmark  
2dd3 ..			.dmark: db "INC"  
2dd6 f1			.pastdmark: pop af  
2dd7			endm  
# End of macro DMARK
2dd7						CALLMONITOR 
2dd7 cd 57 17			call break_point_state  
2dda				endm  
# End of macro CALLMONITOR
2dda					endif 
2dda			 
2dda 7e					ld a,(hl) 
2ddb 83					add e 
2ddc 77					ld (hl),a 
2ddd			 
2ddd			 
2ddd			 
2ddd				       NEXTW 
2ddd c3 1d 21			jp macro_next 
2de0				endm 
# End of macro NEXTW
2de0			 
2de0			.DEC: 
2de0				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2de0 6f				db WORD_SYS_CORE+91             
2de1 31 2e			dw .INC2            
2de3 03				db 2 + 1 
2de4 .. 00			db "-!",0              
2de7				endm 
# End of macro CWHEAD
2de7			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2de7					if DEBUG_FORTH_WORDS_KEY 
2de7						DMARK "-s_" 
2de7 f5				push af  
2de8 3a fc 2d			ld a, (.dmark)  
2deb 32 b4 fe			ld (debug_mark),a  
2dee 3a fd 2d			ld a, (.dmark+1)  
2df1 32 b5 fe			ld (debug_mark+1),a  
2df4 3a fe 2d			ld a, (.dmark+2)  
2df7 32 b6 fe			ld (debug_mark+2),a  
2dfa 18 03			jr .pastdmark  
2dfc ..			.dmark: db "-s_"  
2dff f1			.pastdmark: pop af  
2e00			endm  
# End of macro DMARK
2e00						CALLMONITOR 
2e00 cd 57 17			call break_point_state  
2e03				endm  
# End of macro CALLMONITOR
2e03					endif 
2e03			 
2e03					FORTH_DSP_VALUEHL 
2e03 cd ab 1f			call macro_dsp_valuehl 
2e06				endm 
# End of macro FORTH_DSP_VALUEHL
2e06			 
2e06 e5					push hl   ; save address 
2e07			 
2e07					FORTH_DSP_POP 
2e07 cd 63 20			call macro_forth_dsp_pop 
2e0a				endm 
# End of macro FORTH_DSP_POP
2e0a			 
2e0a					FORTH_DSP_VALUEHL 
2e0a cd ab 1f			call macro_dsp_valuehl 
2e0d				endm 
# End of macro FORTH_DSP_VALUEHL
2e0d			 
2e0d					; hl contains value to add to byte at a 
2e0d				 
2e0d eb					ex de, hl 
2e0e			 
2e0e e1					pop hl 
2e0f			 
2e0f					if DEBUG_FORTH_WORDS 
2e0f						DMARK "DEC" 
2e0f f5				push af  
2e10 3a 24 2e			ld a, (.dmark)  
2e13 32 b4 fe			ld (debug_mark),a  
2e16 3a 25 2e			ld a, (.dmark+1)  
2e19 32 b5 fe			ld (debug_mark+1),a  
2e1c 3a 26 2e			ld a, (.dmark+2)  
2e1f 32 b6 fe			ld (debug_mark+2),a  
2e22 18 03			jr .pastdmark  
2e24 ..			.dmark: db "DEC"  
2e27 f1			.pastdmark: pop af  
2e28			endm  
# End of macro DMARK
2e28						CALLMONITOR 
2e28 cd 57 17			call break_point_state  
2e2b				endm  
# End of macro CALLMONITOR
2e2b					endif 
2e2b			 
2e2b 7e					ld a,(hl) 
2e2c 93					sub e 
2e2d 77					ld (hl),a 
2e2e			 
2e2e			 
2e2e			 
2e2e				       NEXTW 
2e2e c3 1d 21			jp macro_next 
2e31				endm 
# End of macro NEXTW
2e31			 
2e31			.INC2: 
2e31				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2e31 6f				db WORD_SYS_CORE+91             
2e32 db 2e			dw .DEC2            
2e34 04				db 3 + 1 
2e35 .. 00			db "+2!",0              
2e39				endm 
# End of macro CWHEAD
2e39			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2e39			 
2e39					if DEBUG_FORTH_WORDS_KEY 
2e39						DMARK "+2s" 
2e39 f5				push af  
2e3a 3a 4e 2e			ld a, (.dmark)  
2e3d 32 b4 fe			ld (debug_mark),a  
2e40 3a 4f 2e			ld a, (.dmark+1)  
2e43 32 b5 fe			ld (debug_mark+1),a  
2e46 3a 50 2e			ld a, (.dmark+2)  
2e49 32 b6 fe			ld (debug_mark+2),a  
2e4c 18 03			jr .pastdmark  
2e4e ..			.dmark: db "+2s"  
2e51 f1			.pastdmark: pop af  
2e52			endm  
# End of macro DMARK
2e52						CALLMONITOR 
2e52 cd 57 17			call break_point_state  
2e55				endm  
# End of macro CALLMONITOR
2e55					endif 
2e55			 
2e55					; Address 
2e55			 
2e55					FORTH_DSP_VALUEHL 
2e55 cd ab 1f			call macro_dsp_valuehl 
2e58				endm 
# End of macro FORTH_DSP_VALUEHL
2e58			 
2e58 e5					push hl    ; save address 
2e59			 
2e59					; load content into de 
2e59			 
2e59 5e					ld e,(hl) 
2e5a 23					inc hl 
2e5b 56					ld d, (hl) 
2e5c			 
2e5c					if DEBUG_FORTH_WORDS 
2e5c						DMARK "+2a" 
2e5c f5				push af  
2e5d 3a 71 2e			ld a, (.dmark)  
2e60 32 b4 fe			ld (debug_mark),a  
2e63 3a 72 2e			ld a, (.dmark+1)  
2e66 32 b5 fe			ld (debug_mark+1),a  
2e69 3a 73 2e			ld a, (.dmark+2)  
2e6c 32 b6 fe			ld (debug_mark+2),a  
2e6f 18 03			jr .pastdmark  
2e71 ..			.dmark: db "+2a"  
2e74 f1			.pastdmark: pop af  
2e75			endm  
# End of macro DMARK
2e75						CALLMONITOR 
2e75 cd 57 17			call break_point_state  
2e78				endm  
# End of macro CALLMONITOR
2e78					endif 
2e78			 
2e78					FORTH_DSP_POP 
2e78 cd 63 20			call macro_forth_dsp_pop 
2e7b				endm 
# End of macro FORTH_DSP_POP
2e7b			 
2e7b					; Get value to add 
2e7b			 
2e7b					FORTH_DSP_VALUE 
2e7b cd 94 1f			call macro_forth_dsp_value 
2e7e				endm 
# End of macro FORTH_DSP_VALUE
2e7e			 
2e7e					if DEBUG_FORTH_WORDS 
2e7e						DMARK "+2v" 
2e7e f5				push af  
2e7f 3a 93 2e			ld a, (.dmark)  
2e82 32 b4 fe			ld (debug_mark),a  
2e85 3a 94 2e			ld a, (.dmark+1)  
2e88 32 b5 fe			ld (debug_mark+1),a  
2e8b 3a 95 2e			ld a, (.dmark+2)  
2e8e 32 b6 fe			ld (debug_mark+2),a  
2e91 18 03			jr .pastdmark  
2e93 ..			.dmark: db "+2v"  
2e96 f1			.pastdmark: pop af  
2e97			endm  
# End of macro DMARK
2e97						CALLMONITOR 
2e97 cd 57 17			call break_point_state  
2e9a				endm  
# End of macro CALLMONITOR
2e9a					endif 
2e9a			 
2e9a 19					add hl, de 
2e9b			 
2e9b					if DEBUG_FORTH_WORDS 
2e9b						DMARK "+2+" 
2e9b f5				push af  
2e9c 3a b0 2e			ld a, (.dmark)  
2e9f 32 b4 fe			ld (debug_mark),a  
2ea2 3a b1 2e			ld a, (.dmark+1)  
2ea5 32 b5 fe			ld (debug_mark+1),a  
2ea8 3a b2 2e			ld a, (.dmark+2)  
2eab 32 b6 fe			ld (debug_mark+2),a  
2eae 18 03			jr .pastdmark  
2eb0 ..			.dmark: db "+2+"  
2eb3 f1			.pastdmark: pop af  
2eb4			endm  
# End of macro DMARK
2eb4						CALLMONITOR 
2eb4 cd 57 17			call break_point_state  
2eb7				endm  
# End of macro CALLMONITOR
2eb7					endif 
2eb7			 
2eb7					; move result to de 
2eb7			 
2eb7 eb					ex de, hl 
2eb8			 
2eb8					; Address 
2eb8			 
2eb8 e1					pop hl 
2eb9			 
2eb9					; save it back 
2eb9			 
2eb9 73					ld (hl), e 
2eba 23					inc hl 
2ebb 72					ld (hl), d 
2ebc			 
2ebc					if DEBUG_FORTH_WORDS 
2ebc						DMARK "+2e" 
2ebc f5				push af  
2ebd 3a d1 2e			ld a, (.dmark)  
2ec0 32 b4 fe			ld (debug_mark),a  
2ec3 3a d2 2e			ld a, (.dmark+1)  
2ec6 32 b5 fe			ld (debug_mark+1),a  
2ec9 3a d3 2e			ld a, (.dmark+2)  
2ecc 32 b6 fe			ld (debug_mark+2),a  
2ecf 18 03			jr .pastdmark  
2ed1 ..			.dmark: db "+2e"  
2ed4 f1			.pastdmark: pop af  
2ed5			endm  
# End of macro DMARK
2ed5						CALLMONITOR 
2ed5 cd 57 17			call break_point_state  
2ed8				endm  
# End of macro CALLMONITOR
2ed8					endif 
2ed8			 
2ed8			 
2ed8			 
2ed8			 
2ed8			 
2ed8				       NEXTW 
2ed8 c3 1d 21			jp macro_next 
2edb				endm 
# End of macro NEXTW
2edb			 
2edb			.DEC2: 
2edb				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2edb 6f				db WORD_SYS_CORE+91             
2edc 87 2f			dw .GET2            
2ede 04				db 3 + 1 
2edf .. 00			db "-2!",0              
2ee3				endm 
# End of macro CWHEAD
2ee3			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2ee3			 
2ee3			 
2ee3					if DEBUG_FORTH_WORDS_KEY 
2ee3						DMARK "-2s" 
2ee3 f5				push af  
2ee4 3a f8 2e			ld a, (.dmark)  
2ee7 32 b4 fe			ld (debug_mark),a  
2eea 3a f9 2e			ld a, (.dmark+1)  
2eed 32 b5 fe			ld (debug_mark+1),a  
2ef0 3a fa 2e			ld a, (.dmark+2)  
2ef3 32 b6 fe			ld (debug_mark+2),a  
2ef6 18 03			jr .pastdmark  
2ef8 ..			.dmark: db "-2s"  
2efb f1			.pastdmark: pop af  
2efc			endm  
# End of macro DMARK
2efc						CALLMONITOR 
2efc cd 57 17			call break_point_state  
2eff				endm  
# End of macro CALLMONITOR
2eff					endif 
2eff			 
2eff					; Address 
2eff			 
2eff					FORTH_DSP_VALUEHL 
2eff cd ab 1f			call macro_dsp_valuehl 
2f02				endm 
# End of macro FORTH_DSP_VALUEHL
2f02			 
2f02 e5					push hl    ; save address 
2f03			 
2f03					; load content into de 
2f03			 
2f03 5e					ld e,(hl) 
2f04 23					inc hl 
2f05 56					ld d, (hl) 
2f06			 
2f06					if DEBUG_FORTH_WORDS 
2f06						DMARK "-2a" 
2f06 f5				push af  
2f07 3a 1b 2f			ld a, (.dmark)  
2f0a 32 b4 fe			ld (debug_mark),a  
2f0d 3a 1c 2f			ld a, (.dmark+1)  
2f10 32 b5 fe			ld (debug_mark+1),a  
2f13 3a 1d 2f			ld a, (.dmark+2)  
2f16 32 b6 fe			ld (debug_mark+2),a  
2f19 18 03			jr .pastdmark  
2f1b ..			.dmark: db "-2a"  
2f1e f1			.pastdmark: pop af  
2f1f			endm  
# End of macro DMARK
2f1f						CALLMONITOR 
2f1f cd 57 17			call break_point_state  
2f22				endm  
# End of macro CALLMONITOR
2f22					endif 
2f22			 
2f22					FORTH_DSP_POP 
2f22 cd 63 20			call macro_forth_dsp_pop 
2f25				endm 
# End of macro FORTH_DSP_POP
2f25			 
2f25					; Get value to remove 
2f25			 
2f25					FORTH_DSP_VALUE 
2f25 cd 94 1f			call macro_forth_dsp_value 
2f28				endm 
# End of macro FORTH_DSP_VALUE
2f28			 
2f28					if DEBUG_FORTH_WORDS 
2f28						DMARK "-2v" 
2f28 f5				push af  
2f29 3a 3d 2f			ld a, (.dmark)  
2f2c 32 b4 fe			ld (debug_mark),a  
2f2f 3a 3e 2f			ld a, (.dmark+1)  
2f32 32 b5 fe			ld (debug_mark+1),a  
2f35 3a 3f 2f			ld a, (.dmark+2)  
2f38 32 b6 fe			ld (debug_mark+2),a  
2f3b 18 03			jr .pastdmark  
2f3d ..			.dmark: db "-2v"  
2f40 f1			.pastdmark: pop af  
2f41			endm  
# End of macro DMARK
2f41						CALLMONITOR 
2f41 cd 57 17			call break_point_state  
2f44				endm  
# End of macro CALLMONITOR
2f44					endif 
2f44			 
2f44 eb					ex de, hl 
2f45 ed 52				sbc hl, de 
2f47			 
2f47					if DEBUG_FORTH_WORDS 
2f47						DMARK "-2d" 
2f47 f5				push af  
2f48 3a 5c 2f			ld a, (.dmark)  
2f4b 32 b4 fe			ld (debug_mark),a  
2f4e 3a 5d 2f			ld a, (.dmark+1)  
2f51 32 b5 fe			ld (debug_mark+1),a  
2f54 3a 5e 2f			ld a, (.dmark+2)  
2f57 32 b6 fe			ld (debug_mark+2),a  
2f5a 18 03			jr .pastdmark  
2f5c ..			.dmark: db "-2d"  
2f5f f1			.pastdmark: pop af  
2f60			endm  
# End of macro DMARK
2f60						CALLMONITOR 
2f60 cd 57 17			call break_point_state  
2f63				endm  
# End of macro CALLMONITOR
2f63					endif 
2f63			 
2f63					; move result to de 
2f63			 
2f63 eb					ex de, hl 
2f64			 
2f64					; Address 
2f64			 
2f64 e1					pop hl 
2f65			 
2f65					; save it back 
2f65			 
2f65 73					ld (hl), e 
2f66 23					inc hl 
2f67 72					ld (hl), d 
2f68			 
2f68					if DEBUG_FORTH_WORDS 
2f68						DMARK "-2e" 
2f68 f5				push af  
2f69 3a 7d 2f			ld a, (.dmark)  
2f6c 32 b4 fe			ld (debug_mark),a  
2f6f 3a 7e 2f			ld a, (.dmark+1)  
2f72 32 b5 fe			ld (debug_mark+1),a  
2f75 3a 7f 2f			ld a, (.dmark+2)  
2f78 32 b6 fe			ld (debug_mark+2),a  
2f7b 18 03			jr .pastdmark  
2f7d ..			.dmark: db "-2e"  
2f80 f1			.pastdmark: pop af  
2f81			endm  
# End of macro DMARK
2f81						CALLMONITOR 
2f81 cd 57 17			call break_point_state  
2f84				endm  
# End of macro CALLMONITOR
2f84					endif 
2f84			 
2f84			 
2f84			 
2f84			 
2f84			 
2f84				       NEXTW 
2f84 c3 1d 21			jp macro_next 
2f87				endm 
# End of macro NEXTW
2f87			.GET2: 
2f87				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2f87 6f				db WORD_SYS_CORE+91             
2f88 b7 2f			dw .BANG2            
2f8a 03				db 2 + 1 
2f8b .. 00			db "2@",0              
2f8e				endm 
# End of macro CWHEAD
2f8e			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2f8e					if DEBUG_FORTH_WORDS_KEY 
2f8e						DMARK "2A_" 
2f8e f5				push af  
2f8f 3a a3 2f			ld a, (.dmark)  
2f92 32 b4 fe			ld (debug_mark),a  
2f95 3a a4 2f			ld a, (.dmark+1)  
2f98 32 b5 fe			ld (debug_mark+1),a  
2f9b 3a a5 2f			ld a, (.dmark+2)  
2f9e 32 b6 fe			ld (debug_mark+2),a  
2fa1 18 03			jr .pastdmark  
2fa3 ..			.dmark: db "2A_"  
2fa6 f1			.pastdmark: pop af  
2fa7			endm  
# End of macro DMARK
2fa7						CALLMONITOR 
2fa7 cd 57 17			call break_point_state  
2faa				endm  
# End of macro CALLMONITOR
2faa					endif 
2faa			 
2faa					FORTH_DSP_VALUEHL 
2faa cd ab 1f			call macro_dsp_valuehl 
2fad				endm 
# End of macro FORTH_DSP_VALUEHL
2fad			 
2fad 5e					ld e, (hl) 
2fae 23					inc hl 
2faf 56					ld d, (hl) 
2fb0			 
2fb0 eb					ex de, hl 
2fb1			 
2fb1 cd b4 1d				call forth_push_numhl 
2fb4			 
2fb4				       NEXTW 
2fb4 c3 1d 21			jp macro_next 
2fb7				endm 
# End of macro NEXTW
2fb7			.BANG2: 
2fb7				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2fb7 6f				db WORD_SYS_CORE+91             
2fb8 ef 2f			dw .CONFIG            
2fba 03				db 2 + 1 
2fbb .. 00			db "2!",0              
2fbe				endm 
# End of macro CWHEAD
2fbe			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2fbe					if DEBUG_FORTH_WORDS_KEY 
2fbe						DMARK "2S_" 
2fbe f5				push af  
2fbf 3a d3 2f			ld a, (.dmark)  
2fc2 32 b4 fe			ld (debug_mark),a  
2fc5 3a d4 2f			ld a, (.dmark+1)  
2fc8 32 b5 fe			ld (debug_mark+1),a  
2fcb 3a d5 2f			ld a, (.dmark+2)  
2fce 32 b6 fe			ld (debug_mark+2),a  
2fd1 18 03			jr .pastdmark  
2fd3 ..			.dmark: db "2S_"  
2fd6 f1			.pastdmark: pop af  
2fd7			endm  
# End of macro DMARK
2fd7						CALLMONITOR 
2fd7 cd 57 17			call break_point_state  
2fda				endm  
# End of macro CALLMONITOR
2fda					endif 
2fda			 
2fda					FORTH_DSP_VALUEHL 
2fda cd ab 1f			call macro_dsp_valuehl 
2fdd				endm 
# End of macro FORTH_DSP_VALUEHL
2fdd			 
2fdd e5					push hl   ; save address 
2fde			 
2fde			 
2fde					FORTH_DSP_POP 
2fde cd 63 20			call macro_forth_dsp_pop 
2fe1				endm 
# End of macro FORTH_DSP_POP
2fe1			 
2fe1					 
2fe1					FORTH_DSP_VALUEHL 
2fe1 cd ab 1f			call macro_dsp_valuehl 
2fe4				endm 
# End of macro FORTH_DSP_VALUEHL
2fe4			 
2fe4					FORTH_DSP_POP 
2fe4 cd 63 20			call macro_forth_dsp_pop 
2fe7				endm 
# End of macro FORTH_DSP_POP
2fe7			 
2fe7 eb					ex de, hl    ; value now in de 
2fe8			 
2fe8 e1					pop hl 
2fe9			 
2fe9 73					ld (hl), e 
2fea			 
2fea 23					inc hl 
2feb			 
2feb 72					ld (hl), d 
2fec			 
2fec			 
2fec				       NEXTW 
2fec c3 1d 21			jp macro_next 
2fef				endm 
# End of macro NEXTW
2fef			.CONFIG: 
2fef				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2fef 6f				db WORD_SYS_CORE+91             
2ff0 00 30			dw .ENDCORE            
2ff2 07				db 6 + 1 
2ff3 .. 00			db "CONFIG",0              
2ffa				endm 
# End of macro CWHEAD
2ffa			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ffa			 
2ffa cd 3a 14				call config 
2ffd					NEXTW 
2ffd c3 1d 21			jp macro_next 
3000				endm 
# End of macro NEXTW
3000			.ENDCORE: 
3000			 
3000			; eof 
3000			 
3000			 
# End of file forth_words_core.asm
3000			include "forth_words_flow.asm" 
3000			 
3000			; | ## Program Flow Words 
3000			 
3000			.IF: 
3000				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3000 1e				db WORD_SYS_CORE+10             
3001 f5 30			dw .THEN            
3003 03				db 2 + 1 
3004 .. 00			db "IF",0              
3007				endm 
# End of macro CWHEAD
3007			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3007			; 
3007					if DEBUG_FORTH_WORDS_KEY 
3007						DMARK "IF." 
3007 f5				push af  
3008 3a 1c 30			ld a, (.dmark)  
300b 32 b4 fe			ld (debug_mark),a  
300e 3a 1d 30			ld a, (.dmark+1)  
3011 32 b5 fe			ld (debug_mark+1),a  
3014 3a 1e 30			ld a, (.dmark+2)  
3017 32 b6 fe			ld (debug_mark+2),a  
301a 18 03			jr .pastdmark  
301c ..			.dmark: db "IF."  
301f f1			.pastdmark: pop af  
3020			endm  
# End of macro DMARK
3020						CALLMONITOR 
3020 cd 57 17			call break_point_state  
3023				endm  
# End of macro CALLMONITOR
3023					endif 
3023			; eval TOS 
3023			 
3023				FORTH_DSP_VALUEHL 
3023 cd ab 1f			call macro_dsp_valuehl 
3026				endm 
# End of macro FORTH_DSP_VALUEHL
3026			 
3026			;	push hl 
3026				FORTH_DSP_POP 
3026 cd 63 20			call macro_forth_dsp_pop 
3029				endm 
# End of macro FORTH_DSP_POP
3029			;	pop hl 
3029			 
3029					if DEBUG_FORTH_WORDS 
3029						DMARK "IF1" 
3029 f5				push af  
302a 3a 3e 30			ld a, (.dmark)  
302d 32 b4 fe			ld (debug_mark),a  
3030 3a 3f 30			ld a, (.dmark+1)  
3033 32 b5 fe			ld (debug_mark+1),a  
3036 3a 40 30			ld a, (.dmark+2)  
3039 32 b6 fe			ld (debug_mark+2),a  
303c 18 03			jr .pastdmark  
303e ..			.dmark: db "IF1"  
3041 f1			.pastdmark: pop af  
3042			endm  
# End of macro DMARK
3042						CALLMONITOR 
3042 cd 57 17			call break_point_state  
3045				endm  
# End of macro CALLMONITOR
3045					endif 
3045 b7				or a        ; clear carry flag 
3046 11 00 00			ld de, 0 
3049 eb				ex de,hl 
304a ed 52			sbc hl, de 
304c c2 d6 30			jp nz, .iftrue 
304f			 
304f					if DEBUG_FORTH_WORDS 
304f						DMARK "IF2" 
304f f5				push af  
3050 3a 64 30			ld a, (.dmark)  
3053 32 b4 fe			ld (debug_mark),a  
3056 3a 65 30			ld a, (.dmark+1)  
3059 32 b5 fe			ld (debug_mark+1),a  
305c 3a 66 30			ld a, (.dmark+2)  
305f 32 b6 fe			ld (debug_mark+2),a  
3062 18 03			jr .pastdmark  
3064 ..			.dmark: db "IF2"  
3067 f1			.pastdmark: pop af  
3068			endm  
# End of macro DMARK
3068						CALLMONITOR 
3068 cd 57 17			call break_point_state  
306b				endm  
# End of macro CALLMONITOR
306b					endif 
306b			 
306b			; if not true then skip to THEN 
306b			 
306b				; TODO get tok_ptr 
306b				; TODO consume toks until we get to THEN 
306b			 
306b 2a 5b f7			ld hl, (os_tok_ptr) 
306e					if DEBUG_FORTH_WORDS 
306e						DMARK "IF3" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 b4 fe			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 b5 fe			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 b6 fe			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "IF3"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd 57 17			call break_point_state  
308a				endm  
# End of macro CALLMONITOR
308a						 
308a					endif 
308a 11 d1 30			ld de, .ifthen 
308d					if DEBUG_FORTH_WORDS 
308d						DMARK "IF4" 
308d f5				push af  
308e 3a a2 30			ld a, (.dmark)  
3091 32 b4 fe			ld (debug_mark),a  
3094 3a a3 30			ld a, (.dmark+1)  
3097 32 b5 fe			ld (debug_mark+1),a  
309a 3a a4 30			ld a, (.dmark+2)  
309d 32 b6 fe			ld (debug_mark+2),a  
30a0 18 03			jr .pastdmark  
30a2 ..			.dmark: db "IF4"  
30a5 f1			.pastdmark: pop af  
30a6			endm  
# End of macro DMARK
30a6						CALLMONITOR 
30a6 cd 57 17			call break_point_state  
30a9				endm  
# End of macro CALLMONITOR
30a9					endif 
30a9 cd 38 22			call findnexttok  
30ac			 
30ac					if DEBUG_FORTH_WORDS 
30ac						DMARK "IF5" 
30ac f5				push af  
30ad 3a c1 30			ld a, (.dmark)  
30b0 32 b4 fe			ld (debug_mark),a  
30b3 3a c2 30			ld a, (.dmark+1)  
30b6 32 b5 fe			ld (debug_mark+1),a  
30b9 3a c3 30			ld a, (.dmark+2)  
30bc 32 b6 fe			ld (debug_mark+2),a  
30bf 18 03			jr .pastdmark  
30c1 ..			.dmark: db "IF5"  
30c4 f1			.pastdmark: pop af  
30c5			endm  
# End of macro DMARK
30c5						CALLMONITOR 
30c5 cd 57 17			call break_point_state  
30c8				endm  
# End of macro CALLMONITOR
30c8					endif 
30c8				; TODO replace below with ; exec using tok_ptr 
30c8 22 5b f7			ld (os_tok_ptr), hl 
30cb c3 ae 21			jp exec1 
30ce				NEXTW 
30ce c3 1d 21			jp macro_next 
30d1				endm 
# End of macro NEXTW
30d1			 
30d1 .. 00		.ifthen:  db "THEN",0 
30d6			 
30d6			.iftrue:		 
30d6				; Exec next words normally 
30d6			 
30d6				; if true then exec following IF as normal 
30d6					if DEBUG_FORTH_WORDS 
30d6						DMARK "IFT" 
30d6 f5				push af  
30d7 3a eb 30			ld a, (.dmark)  
30da 32 b4 fe			ld (debug_mark),a  
30dd 3a ec 30			ld a, (.dmark+1)  
30e0 32 b5 fe			ld (debug_mark+1),a  
30e3 3a ed 30			ld a, (.dmark+2)  
30e6 32 b6 fe			ld (debug_mark+2),a  
30e9 18 03			jr .pastdmark  
30eb ..			.dmark: db "IFT"  
30ee f1			.pastdmark: pop af  
30ef			endm  
# End of macro DMARK
30ef						CALLMONITOR 
30ef cd 57 17			call break_point_state  
30f2				endm  
# End of macro CALLMONITOR
30f2					endif 
30f2			 
30f2					NEXTW 
30f2 c3 1d 21			jp macro_next 
30f5				endm 
# End of macro NEXTW
30f5			.THEN: 
30f5				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
30f5 1f				db WORD_SYS_CORE+11             
30f6 1d 31			dw .ELSE            
30f8 05				db 4 + 1 
30f9 .. 00			db "THEN",0              
30fe				endm 
# End of macro CWHEAD
30fe			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
30fe					if DEBUG_FORTH_WORDS_KEY 
30fe						DMARK "THN" 
30fe f5				push af  
30ff 3a 13 31			ld a, (.dmark)  
3102 32 b4 fe			ld (debug_mark),a  
3105 3a 14 31			ld a, (.dmark+1)  
3108 32 b5 fe			ld (debug_mark+1),a  
310b 3a 15 31			ld a, (.dmark+2)  
310e 32 b6 fe			ld (debug_mark+2),a  
3111 18 03			jr .pastdmark  
3113 ..			.dmark: db "THN"  
3116 f1			.pastdmark: pop af  
3117			endm  
# End of macro DMARK
3117						CALLMONITOR 
3117 cd 57 17			call break_point_state  
311a				endm  
# End of macro CALLMONITOR
311a					endif 
311a					NEXTW 
311a c3 1d 21			jp macro_next 
311d				endm 
# End of macro NEXTW
311d			.ELSE: 
311d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
311d 20				db WORD_SYS_CORE+12             
311e 45 31			dw .DO            
3120 03				db 2 + 1 
3121 .. 00			db "ELSE",0              
3126				endm 
# End of macro CWHEAD
3126			; | ELSE ( -- ) Not supported - does nothing | TODO 
3126			 
3126					if DEBUG_FORTH_WORDS_KEY 
3126						DMARK "ELS" 
3126 f5				push af  
3127 3a 3b 31			ld a, (.dmark)  
312a 32 b4 fe			ld (debug_mark),a  
312d 3a 3c 31			ld a, (.dmark+1)  
3130 32 b5 fe			ld (debug_mark+1),a  
3133 3a 3d 31			ld a, (.dmark+2)  
3136 32 b6 fe			ld (debug_mark+2),a  
3139 18 03			jr .pastdmark  
313b ..			.dmark: db "ELS"  
313e f1			.pastdmark: pop af  
313f			endm  
# End of macro DMARK
313f						CALLMONITOR 
313f cd 57 17			call break_point_state  
3142				endm  
# End of macro CALLMONITOR
3142					endif 
3142			 
3142			 
3142					NEXTW 
3142 c3 1d 21			jp macro_next 
3145				endm 
# End of macro NEXTW
3145			.DO: 
3145				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3145 21				db WORD_SYS_CORE+13             
3146 6c 32			dw .LOOP            
3148 03				db 2 + 1 
3149 .. 00			db "DO",0              
314c				endm 
# End of macro CWHEAD
314c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
314c			 
314c					if DEBUG_FORTH_WORDS_KEY 
314c						DMARK "DO." 
314c f5				push af  
314d 3a 61 31			ld a, (.dmark)  
3150 32 b4 fe			ld (debug_mark),a  
3153 3a 62 31			ld a, (.dmark+1)  
3156 32 b5 fe			ld (debug_mark+1),a  
3159 3a 63 31			ld a, (.dmark+2)  
315c 32 b6 fe			ld (debug_mark+2),a  
315f 18 03			jr .pastdmark  
3161 ..			.dmark: db "DO."  
3164 f1			.pastdmark: pop af  
3165			endm  
# End of macro DMARK
3165						CALLMONITOR 
3165 cd 57 17			call break_point_state  
3168				endm  
# End of macro CALLMONITOR
3168					endif 
3168			;  push pc to rsp stack past the DO 
3168			 
3168 2a 5b f7				ld hl, (os_tok_ptr) 
316b 23					inc hl   ; D 
316c 23					inc hl  ; O 
316d 23					inc hl   ; null 
316e					if DEBUG_FORTH_WORDS 
316e						DMARK "DO2" 
316e f5				push af  
316f 3a 83 31			ld a, (.dmark)  
3172 32 b4 fe			ld (debug_mark),a  
3175 3a 84 31			ld a, (.dmark+1)  
3178 32 b5 fe			ld (debug_mark+1),a  
317b 3a 85 31			ld a, (.dmark+2)  
317e 32 b6 fe			ld (debug_mark+2),a  
3181 18 03			jr .pastdmark  
3183 ..			.dmark: db "DO2"  
3186 f1			.pastdmark: pop af  
3187			endm  
# End of macro DMARK
3187						CALLMONITOR 
3187 cd 57 17			call break_point_state  
318a				endm  
# End of macro CALLMONITOR
318a					endif 
318a					FORTH_RSP_NEXT 
318a cd 5b 1d			call macro_forth_rsp_next 
318d				endm 
# End of macro FORTH_RSP_NEXT
318d					if DEBUG_FORTH_WORDS 
318d						DMARK "DO3" 
318d f5				push af  
318e 3a a2 31			ld a, (.dmark)  
3191 32 b4 fe			ld (debug_mark),a  
3194 3a a3 31			ld a, (.dmark+1)  
3197 32 b5 fe			ld (debug_mark+1),a  
319a 3a a4 31			ld a, (.dmark+2)  
319d 32 b6 fe			ld (debug_mark+2),a  
31a0 18 03			jr .pastdmark  
31a2 ..			.dmark: db "DO3"  
31a5 f1			.pastdmark: pop af  
31a6			endm  
# End of macro DMARK
31a6						CALLMONITOR 
31a6 cd 57 17			call break_point_state  
31a9				endm  
# End of macro CALLMONITOR
31a9					endif 
31a9			 
31a9					;if DEBUG_FORTH_WORDS 
31a9				;		push hl 
31a9			;		endif  
31a9			 
31a9			; get counters from data stack 
31a9			 
31a9			 
31a9					FORTH_DSP_VALUEHL 
31a9 cd ab 1f			call macro_dsp_valuehl 
31ac				endm 
# End of macro FORTH_DSP_VALUEHL
31ac e5					push hl		 ; hl now has starting counter which needs to be tos 
31ad			 
31ad					if DEBUG_FORTH_WORDS 
31ad						DMARK "DO4" 
31ad f5				push af  
31ae 3a c2 31			ld a, (.dmark)  
31b1 32 b4 fe			ld (debug_mark),a  
31b4 3a c3 31			ld a, (.dmark+1)  
31b7 32 b5 fe			ld (debug_mark+1),a  
31ba 3a c4 31			ld a, (.dmark+2)  
31bd 32 b6 fe			ld (debug_mark+2),a  
31c0 18 03			jr .pastdmark  
31c2 ..			.dmark: db "DO4"  
31c5 f1			.pastdmark: pop af  
31c6			endm  
# End of macro DMARK
31c6						CALLMONITOR 
31c6 cd 57 17			call break_point_state  
31c9				endm  
# End of macro CALLMONITOR
31c9					endif 
31c9					FORTH_DSP_POP 
31c9 cd 63 20			call macro_forth_dsp_pop 
31cc				endm 
# End of macro FORTH_DSP_POP
31cc			 
31cc					if DEBUG_FORTH_WORDS 
31cc						DMARK "DO5" 
31cc f5				push af  
31cd 3a e1 31			ld a, (.dmark)  
31d0 32 b4 fe			ld (debug_mark),a  
31d3 3a e2 31			ld a, (.dmark+1)  
31d6 32 b5 fe			ld (debug_mark+1),a  
31d9 3a e3 31			ld a, (.dmark+2)  
31dc 32 b6 fe			ld (debug_mark+2),a  
31df 18 03			jr .pastdmark  
31e1 ..			.dmark: db "DO5"  
31e4 f1			.pastdmark: pop af  
31e5			endm  
# End of macro DMARK
31e5						CALLMONITOR 
31e5 cd 57 17			call break_point_state  
31e8				endm  
# End of macro CALLMONITOR
31e8					endif 
31e8			 
31e8					FORTH_DSP_VALUEHL 
31e8 cd ab 1f			call macro_dsp_valuehl 
31eb				endm 
# End of macro FORTH_DSP_VALUEHL
31eb			;		push hl		 ; hl now has starting limit counter 
31eb			 
31eb					if DEBUG_FORTH_WORDS 
31eb						DMARK "DO6" 
31eb f5				push af  
31ec 3a 00 32			ld a, (.dmark)  
31ef 32 b4 fe			ld (debug_mark),a  
31f2 3a 01 32			ld a, (.dmark+1)  
31f5 32 b5 fe			ld (debug_mark+1),a  
31f8 3a 02 32			ld a, (.dmark+2)  
31fb 32 b6 fe			ld (debug_mark+2),a  
31fe 18 03			jr .pastdmark  
3200 ..			.dmark: db "DO6"  
3203 f1			.pastdmark: pop af  
3204			endm  
# End of macro DMARK
3204						CALLMONITOR 
3204 cd 57 17			call break_point_state  
3207				endm  
# End of macro CALLMONITOR
3207					endif 
3207					FORTH_DSP_POP 
3207 cd 63 20			call macro_forth_dsp_pop 
320a				endm 
# End of macro FORTH_DSP_POP
320a			 
320a			; put counters on the loop stack 
320a			 
320a			;		pop hl			 ; limit counter 
320a d1					pop de			; start counter 
320b			 
320b					; push limit counter 
320b			 
320b					if DEBUG_FORTH_WORDS 
320b						DMARK "DO7" 
320b f5				push af  
320c 3a 20 32			ld a, (.dmark)  
320f 32 b4 fe			ld (debug_mark),a  
3212 3a 21 32			ld a, (.dmark+1)  
3215 32 b5 fe			ld (debug_mark+1),a  
3218 3a 22 32			ld a, (.dmark+2)  
321b 32 b6 fe			ld (debug_mark+2),a  
321e 18 03			jr .pastdmark  
3220 ..			.dmark: db "DO7"  
3223 f1			.pastdmark: pop af  
3224			endm  
# End of macro DMARK
3224						CALLMONITOR 
3224 cd 57 17			call break_point_state  
3227				endm  
# End of macro CALLMONITOR
3227					endif 
3227					FORTH_LOOP_NEXT 
3227 cd dc 1f			call macro_forth_loop_next 
322a				endm 
# End of macro FORTH_LOOP_NEXT
322a			 
322a					; push start counter 
322a			 
322a eb					ex de, hl 
322b					if DEBUG_FORTH_WORDS 
322b						DMARK "DO7" 
322b f5				push af  
322c 3a 40 32			ld a, (.dmark)  
322f 32 b4 fe			ld (debug_mark),a  
3232 3a 41 32			ld a, (.dmark+1)  
3235 32 b5 fe			ld (debug_mark+1),a  
3238 3a 42 32			ld a, (.dmark+2)  
323b 32 b6 fe			ld (debug_mark+2),a  
323e 18 03			jr .pastdmark  
3240 ..			.dmark: db "DO7"  
3243 f1			.pastdmark: pop af  
3244			endm  
# End of macro DMARK
3244						CALLMONITOR 
3244 cd 57 17			call break_point_state  
3247				endm  
# End of macro CALLMONITOR
3247					endif 
3247					FORTH_LOOP_NEXT 
3247 cd dc 1f			call macro_forth_loop_next 
324a				endm 
# End of macro FORTH_LOOP_NEXT
324a			 
324a			 
324a					; init first round of I counter 
324a			 
324a 22 7f f7				ld (os_current_i), hl 
324d			 
324d					if DEBUG_FORTH_WORDS 
324d						DMARK "DO8" 
324d f5				push af  
324e 3a 62 32			ld a, (.dmark)  
3251 32 b4 fe			ld (debug_mark),a  
3254 3a 63 32			ld a, (.dmark+1)  
3257 32 b5 fe			ld (debug_mark+1),a  
325a 3a 64 32			ld a, (.dmark+2)  
325d 32 b6 fe			ld (debug_mark+2),a  
3260 18 03			jr .pastdmark  
3262 ..			.dmark: db "DO8"  
3265 f1			.pastdmark: pop af  
3266			endm  
# End of macro DMARK
3266						CALLMONITOR 
3266 cd 57 17			call break_point_state  
3269				endm  
# End of macro CALLMONITOR
3269					endif 
3269			 
3269					NEXTW 
3269 c3 1d 21			jp macro_next 
326c				endm 
# End of macro NEXTW
326c			.LOOP: 
326c				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
326c 22				db WORD_SYS_CORE+14             
326d 84 33			dw .I            
326f 05				db 4 + 1 
3270 .. 00			db "LOOP",0              
3275				endm 
# End of macro CWHEAD
3275			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3275			 
3275				; pop tos as current loop count to hl 
3275			 
3275				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3275			 
3275				FORTH_LOOP_TOS 
3275 cd 0f 20			call macro_forth_loop_tos 
3278				endm 
# End of macro FORTH_LOOP_TOS
3278 e5				push hl 
3279			 
3279					if DEBUG_FORTH_WORDS_KEY 
3279						DMARK "LOP" 
3279 f5				push af  
327a 3a 8e 32			ld a, (.dmark)  
327d 32 b4 fe			ld (debug_mark),a  
3280 3a 8f 32			ld a, (.dmark+1)  
3283 32 b5 fe			ld (debug_mark+1),a  
3286 3a 90 32			ld a, (.dmark+2)  
3289 32 b6 fe			ld (debug_mark+2),a  
328c 18 03			jr .pastdmark  
328e ..			.dmark: db "LOP"  
3291 f1			.pastdmark: pop af  
3292			endm  
# End of macro DMARK
3292						CALLMONITOR 
3292 cd 57 17			call break_point_state  
3295				endm  
# End of macro CALLMONITOR
3295					endif 
3295				; next item on the stack is the limit. get it 
3295			 
3295			 
3295				FORTH_LOOP_POP 
3295 cd 19 20			call macro_forth_loop_pop 
3298				endm 
# End of macro FORTH_LOOP_POP
3298			 
3298				FORTH_LOOP_TOS 
3298 cd 0f 20			call macro_forth_loop_tos 
329b				endm 
# End of macro FORTH_LOOP_TOS
329b			 
329b d1				pop de		 ; de = i, hl = limit 
329c			 
329c					if DEBUG_FORTH_WORDS 
329c						DMARK "LP1" 
329c f5				push af  
329d 3a b1 32			ld a, (.dmark)  
32a0 32 b4 fe			ld (debug_mark),a  
32a3 3a b2 32			ld a, (.dmark+1)  
32a6 32 b5 fe			ld (debug_mark+1),a  
32a9 3a b3 32			ld a, (.dmark+2)  
32ac 32 b6 fe			ld (debug_mark+2),a  
32af 18 03			jr .pastdmark  
32b1 ..			.dmark: db "LP1"  
32b4 f1			.pastdmark: pop af  
32b5			endm  
# End of macro DMARK
32b5						CALLMONITOR 
32b5 cd 57 17			call break_point_state  
32b8				endm  
# End of macro CALLMONITOR
32b8					endif 
32b8			 
32b8				; go back to previous word 
32b8			 
32b8 d5				push de    ; save I for inc later 
32b9			 
32b9			 
32b9				; get limit 
32b9				;  is I at limit? 
32b9			 
32b9			 
32b9					if DEBUG_FORTH_WORDS 
32b9						DMARK "LP1" 
32b9 f5				push af  
32ba 3a ce 32			ld a, (.dmark)  
32bd 32 b4 fe			ld (debug_mark),a  
32c0 3a cf 32			ld a, (.dmark+1)  
32c3 32 b5 fe			ld (debug_mark+1),a  
32c6 3a d0 32			ld a, (.dmark+2)  
32c9 32 b6 fe			ld (debug_mark+2),a  
32cc 18 03			jr .pastdmark  
32ce ..			.dmark: db "LP1"  
32d1 f1			.pastdmark: pop af  
32d2			endm  
# End of macro DMARK
32d2						CALLMONITOR 
32d2 cd 57 17			call break_point_state  
32d5				endm  
# End of macro CALLMONITOR
32d5					endif 
32d5			 
32d5 ed 52			sbc hl, de 
32d7			 
32d7			 
32d7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32d7			 
32d7 20 26				jr nz, .loopnotdone 
32d9			 
32d9 e1				pop hl   ; get rid of saved I 
32da				FORTH_LOOP_POP     ; get rid of limit 
32da cd 19 20			call macro_forth_loop_pop 
32dd				endm 
# End of macro FORTH_LOOP_POP
32dd			 
32dd				FORTH_RSP_POP     ; get rid of DO ptr 
32dd cd 7c 1d			call macro_forth_rsp_pop 
32e0				endm 
# End of macro FORTH_RSP_POP
32e0			 
32e0			if DEBUG_FORTH_WORDS 
32e0						DMARK "LP>" 
32e0 f5				push af  
32e1 3a f5 32			ld a, (.dmark)  
32e4 32 b4 fe			ld (debug_mark),a  
32e7 3a f6 32			ld a, (.dmark+1)  
32ea 32 b5 fe			ld (debug_mark+1),a  
32ed 3a f7 32			ld a, (.dmark+2)  
32f0 32 b6 fe			ld (debug_mark+2),a  
32f3 18 03			jr .pastdmark  
32f5 ..			.dmark: db "LP>"  
32f8 f1			.pastdmark: pop af  
32f9			endm  
# End of macro DMARK
32f9				CALLMONITOR 
32f9 cd 57 17			call break_point_state  
32fc				endm  
# End of macro CALLMONITOR
32fc			endif 
32fc			 
32fc					NEXTW 
32fc c3 1d 21			jp macro_next 
32ff				endm 
# End of macro NEXTW
32ff				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
32ff			 
32ff			.loopnotdone: 
32ff			 
32ff e1				pop hl    ; get I 
3300 23				inc hl 
3301			 
3301			   	; save new I 
3301			 
3301			 
3301					; set I counter 
3301			 
3301 22 7f f7				ld (os_current_i), hl 
3304			 
3304					if DEBUG_FORTH_WORDS 
3304						DMARK "LPN" 
3304 f5				push af  
3305 3a 19 33			ld a, (.dmark)  
3308 32 b4 fe			ld (debug_mark),a  
330b 3a 1a 33			ld a, (.dmark+1)  
330e 32 b5 fe			ld (debug_mark+1),a  
3311 3a 1b 33			ld a, (.dmark+2)  
3314 32 b6 fe			ld (debug_mark+2),a  
3317 18 03			jr .pastdmark  
3319 ..			.dmark: db "LPN"  
331c f1			.pastdmark: pop af  
331d			endm  
# End of macro DMARK
331d					CALLMONITOR 
331d cd 57 17			call break_point_state  
3320				endm  
# End of macro CALLMONITOR
3320					endif 
3320					 
3320				FORTH_LOOP_NEXT 
3320 cd dc 1f			call macro_forth_loop_next 
3323				endm 
# End of macro FORTH_LOOP_NEXT
3323			 
3323			 
3323					if DEBUG_FORTH_WORDS 
3323 eb						ex de,hl 
3324					endif 
3324			 
3324			;	; get DO ptr 
3324			; 
3324					if DEBUG_FORTH_WORDS 
3324						DMARK "LP7" 
3324 f5				push af  
3325 3a 39 33			ld a, (.dmark)  
3328 32 b4 fe			ld (debug_mark),a  
332b 3a 3a 33			ld a, (.dmark+1)  
332e 32 b5 fe			ld (debug_mark+1),a  
3331 3a 3b 33			ld a, (.dmark+2)  
3334 32 b6 fe			ld (debug_mark+2),a  
3337 18 03			jr .pastdmark  
3339 ..			.dmark: db "LP7"  
333c f1			.pastdmark: pop af  
333d			endm  
# End of macro DMARK
333d					CALLMONITOR 
333d cd 57 17			call break_point_state  
3340				endm  
# End of macro CALLMONITOR
3340					endif 
3340				FORTH_RSP_TOS 
3340 cd 72 1d			call macro_forth_rsp_tos 
3343				endm 
# End of macro FORTH_RSP_TOS
3343			 
3343					if DEBUG_FORTH_WORDS 
3343						DMARK "LP8" 
3343 f5				push af  
3344 3a 58 33			ld a, (.dmark)  
3347 32 b4 fe			ld (debug_mark),a  
334a 3a 59 33			ld a, (.dmark+1)  
334d 32 b5 fe			ld (debug_mark+1),a  
3350 3a 5a 33			ld a, (.dmark+2)  
3353 32 b6 fe			ld (debug_mark+2),a  
3356 18 03			jr .pastdmark  
3358 ..			.dmark: db "LP8"  
335b f1			.pastdmark: pop af  
335c			endm  
# End of macro DMARK
335c					CALLMONITOR 
335c cd 57 17			call break_point_state  
335f				endm  
# End of macro CALLMONITOR
335f					endif 
335f				;push hl 
335f			 
335f				; not going to DO any more 
335f				; get rid of the RSP pointer as DO will add it back in 
335f				;FORTH_RSP_POP 
335f				;pop hl 
335f			 
335f				;ld hl,(cli_ret_sp) 
335f				;ld e, (hl) 
335f				;inc hl 
335f				;ld d, (hl) 
335f				;ex de,hl 
335f 22 5b f7			ld (os_tok_ptr), hl 
3362					if DEBUG_FORTH_WORDS 
3362						DMARK "LP<" 
3362 f5				push af  
3363 3a 77 33			ld a, (.dmark)  
3366 32 b4 fe			ld (debug_mark),a  
3369 3a 78 33			ld a, (.dmark+1)  
336c 32 b5 fe			ld (debug_mark+1),a  
336f 3a 79 33			ld a, (.dmark+2)  
3372 32 b6 fe			ld (debug_mark+2),a  
3375 18 03			jr .pastdmark  
3377 ..			.dmark: db "LP<"  
337a f1			.pastdmark: pop af  
337b			endm  
# End of macro DMARK
337b					CALLMONITOR 
337b cd 57 17			call break_point_state  
337e				endm  
# End of macro CALLMONITOR
337e				endif 
337e c3 ae 21			jp exec1 
3381			 
3381					 
3381			 
3381			 
3381					NEXTW 
3381 c3 1d 21			jp macro_next 
3384				endm 
# End of macro NEXTW
3384			.I:  
3384			 
3384				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3384 5e				db WORD_SYS_CORE+74             
3385 af 33			dw .DLOOP            
3387 02				db 1 + 1 
3388 .. 00			db "I",0              
338a				endm 
# End of macro CWHEAD
338a			; | I ( -- ) Current loop counter | DONE 
338a					if DEBUG_FORTH_WORDS_KEY 
338a						DMARK "I.." 
338a f5				push af  
338b 3a 9f 33			ld a, (.dmark)  
338e 32 b4 fe			ld (debug_mark),a  
3391 3a a0 33			ld a, (.dmark+1)  
3394 32 b5 fe			ld (debug_mark+1),a  
3397 3a a1 33			ld a, (.dmark+2)  
339a 32 b6 fe			ld (debug_mark+2),a  
339d 18 03			jr .pastdmark  
339f ..			.dmark: db "I.."  
33a2 f1			.pastdmark: pop af  
33a3			endm  
# End of macro DMARK
33a3						CALLMONITOR 
33a3 cd 57 17			call break_point_state  
33a6				endm  
# End of macro CALLMONITOR
33a6					endif 
33a6			 
33a6 2a 7f f7				ld hl,(os_current_i) 
33a9 cd b4 1d				call forth_push_numhl 
33ac			 
33ac					NEXTW 
33ac c3 1d 21			jp macro_next 
33af				endm 
# End of macro NEXTW
33af			.DLOOP: 
33af				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
33af 5f				db WORD_SYS_CORE+75             
33b0 90 34			dw .REPEAT            
33b2 06				db 5 + 1 
33b3 .. 00			db "-LOOP",0              
33b9				endm 
# End of macro CWHEAD
33b9			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
33b9				; pop tos as current loop count to hl 
33b9					if DEBUG_FORTH_WORDS_KEY 
33b9						DMARK "-LP" 
33b9 f5				push af  
33ba 3a ce 33			ld a, (.dmark)  
33bd 32 b4 fe			ld (debug_mark),a  
33c0 3a cf 33			ld a, (.dmark+1)  
33c3 32 b5 fe			ld (debug_mark+1),a  
33c6 3a d0 33			ld a, (.dmark+2)  
33c9 32 b6 fe			ld (debug_mark+2),a  
33cc 18 03			jr .pastdmark  
33ce ..			.dmark: db "-LP"  
33d1 f1			.pastdmark: pop af  
33d2			endm  
# End of macro DMARK
33d2						CALLMONITOR 
33d2 cd 57 17			call break_point_state  
33d5				endm  
# End of macro CALLMONITOR
33d5					endif 
33d5			 
33d5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33d5			 
33d5				FORTH_LOOP_TOS 
33d5 cd 0f 20			call macro_forth_loop_tos 
33d8				endm 
# End of macro FORTH_LOOP_TOS
33d8 e5				push hl 
33d9			 
33d9					if DEBUG_FORTH_WORDS 
33d9						DMARK "-LP" 
33d9 f5				push af  
33da 3a ee 33			ld a, (.dmark)  
33dd 32 b4 fe			ld (debug_mark),a  
33e0 3a ef 33			ld a, (.dmark+1)  
33e3 32 b5 fe			ld (debug_mark+1),a  
33e6 3a f0 33			ld a, (.dmark+2)  
33e9 32 b6 fe			ld (debug_mark+2),a  
33ec 18 03			jr .pastdmark  
33ee ..			.dmark: db "-LP"  
33f1 f1			.pastdmark: pop af  
33f2			endm  
# End of macro DMARK
33f2						CALLMONITOR 
33f2 cd 57 17			call break_point_state  
33f5				endm  
# End of macro CALLMONITOR
33f5					endif 
33f5				; next item on the stack is the limit. get it 
33f5			 
33f5			 
33f5				FORTH_LOOP_POP 
33f5 cd 19 20			call macro_forth_loop_pop 
33f8				endm 
# End of macro FORTH_LOOP_POP
33f8			 
33f8				FORTH_LOOP_TOS 
33f8 cd 0f 20			call macro_forth_loop_tos 
33fb				endm 
# End of macro FORTH_LOOP_TOS
33fb			 
33fb d1				pop de		 ; de = i, hl = limit 
33fc			 
33fc					if DEBUG_FORTH_WORDS 
33fc						DMARK "-L1" 
33fc f5				push af  
33fd 3a 11 34			ld a, (.dmark)  
3400 32 b4 fe			ld (debug_mark),a  
3403 3a 12 34			ld a, (.dmark+1)  
3406 32 b5 fe			ld (debug_mark+1),a  
3409 3a 13 34			ld a, (.dmark+2)  
340c 32 b6 fe			ld (debug_mark+2),a  
340f 18 03			jr .pastdmark  
3411 ..			.dmark: db "-L1"  
3414 f1			.pastdmark: pop af  
3415			endm  
# End of macro DMARK
3415						CALLMONITOR 
3415 cd 57 17			call break_point_state  
3418				endm  
# End of macro CALLMONITOR
3418					endif 
3418			 
3418				; go back to previous word 
3418			 
3418 d5				push de    ; save I for inc later 
3419			 
3419			 
3419				; get limit 
3419				;  is I at limit? 
3419			 
3419			 
3419					if DEBUG_FORTH_WORDS 
3419						DMARK "-L1" 
3419 f5				push af  
341a 3a 2e 34			ld a, (.dmark)  
341d 32 b4 fe			ld (debug_mark),a  
3420 3a 2f 34			ld a, (.dmark+1)  
3423 32 b5 fe			ld (debug_mark+1),a  
3426 3a 30 34			ld a, (.dmark+2)  
3429 32 b6 fe			ld (debug_mark+2),a  
342c 18 03			jr .pastdmark  
342e ..			.dmark: db "-L1"  
3431 f1			.pastdmark: pop af  
3432			endm  
# End of macro DMARK
3432						CALLMONITOR 
3432 cd 57 17			call break_point_state  
3435				endm  
# End of macro CALLMONITOR
3435					endif 
3435			 
3435 ed 52			sbc hl, de 
3437			 
3437			 
3437				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3437			 
3437 20 26				jr nz, .mloopnotdone 
3439			 
3439 e1				pop hl   ; get rid of saved I 
343a				FORTH_LOOP_POP     ; get rid of limit 
343a cd 19 20			call macro_forth_loop_pop 
343d				endm 
# End of macro FORTH_LOOP_POP
343d			 
343d				FORTH_RSP_POP     ; get rid of DO ptr 
343d cd 7c 1d			call macro_forth_rsp_pop 
3440				endm 
# End of macro FORTH_RSP_POP
3440			 
3440			if DEBUG_FORTH_WORDS 
3440						DMARK "-L>" 
3440 f5				push af  
3441 3a 55 34			ld a, (.dmark)  
3444 32 b4 fe			ld (debug_mark),a  
3447 3a 56 34			ld a, (.dmark+1)  
344a 32 b5 fe			ld (debug_mark+1),a  
344d 3a 57 34			ld a, (.dmark+2)  
3450 32 b6 fe			ld (debug_mark+2),a  
3453 18 03			jr .pastdmark  
3455 ..			.dmark: db "-L>"  
3458 f1			.pastdmark: pop af  
3459			endm  
# End of macro DMARK
3459				CALLMONITOR 
3459 cd 57 17			call break_point_state  
345c				endm  
# End of macro CALLMONITOR
345c			endif 
345c			 
345c					NEXTW 
345c c3 1d 21			jp macro_next 
345f				endm 
# End of macro NEXTW
345f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
345f			 
345f			.mloopnotdone: 
345f			 
345f e1				pop hl    ; get I 
3460 2b				dec hl 
3461			 
3461			   	; save new I 
3461			 
3461			 
3461					; set I counter 
3461			 
3461 22 7f f7				ld (os_current_i), hl 
3464			 
3464					 
3464				FORTH_LOOP_NEXT 
3464 cd dc 1f			call macro_forth_loop_next 
3467				endm 
# End of macro FORTH_LOOP_NEXT
3467			 
3467			 
3467					if DEBUG_FORTH_WORDS 
3467 eb						ex de,hl 
3468					endif 
3468			 
3468			;	; get DO ptr 
3468			; 
3468				FORTH_RSP_TOS 
3468 cd 72 1d			call macro_forth_rsp_tos 
346b				endm 
# End of macro FORTH_RSP_TOS
346b			 
346b				;push hl 
346b			 
346b				; not going to DO any more 
346b				; get rid of the RSP pointer as DO will add it back in 
346b				;FORTH_RSP_POP 
346b				;pop hl 
346b			 
346b			 
346b 22 5b f7			ld (os_tok_ptr), hl 
346e					if DEBUG_FORTH_WORDS 
346e						DMARK "-L<" 
346e f5				push af  
346f 3a 83 34			ld a, (.dmark)  
3472 32 b4 fe			ld (debug_mark),a  
3475 3a 84 34			ld a, (.dmark+1)  
3478 32 b5 fe			ld (debug_mark+1),a  
347b 3a 85 34			ld a, (.dmark+2)  
347e 32 b6 fe			ld (debug_mark+2),a  
3481 18 03			jr .pastdmark  
3483 ..			.dmark: db "-L<"  
3486 f1			.pastdmark: pop af  
3487			endm  
# End of macro DMARK
3487					CALLMONITOR 
3487 cd 57 17			call break_point_state  
348a				endm  
# End of macro CALLMONITOR
348a				endif 
348a c3 ae 21			jp exec1 
348d			 
348d					 
348d			 
348d			 
348d			 
348d				NEXTW 
348d c3 1d 21			jp macro_next 
3490				endm 
# End of macro NEXTW
3490			 
3490			 
3490			 
3490			 
3490			.REPEAT: 
3490				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3490 71				db WORD_SYS_CORE+93             
3491 e3 34			dw .UNTIL            
3493 06				db 5 + 1 
3494 .. 00			db "REPEAT",0              
349b				endm 
# End of macro CWHEAD
349b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
349b			;  push pc to rsp stack past the REPEAT 
349b					if DEBUG_FORTH_WORDS_KEY 
349b						DMARK "REP" 
349b f5				push af  
349c 3a b0 34			ld a, (.dmark)  
349f 32 b4 fe			ld (debug_mark),a  
34a2 3a b1 34			ld a, (.dmark+1)  
34a5 32 b5 fe			ld (debug_mark+1),a  
34a8 3a b2 34			ld a, (.dmark+2)  
34ab 32 b6 fe			ld (debug_mark+2),a  
34ae 18 03			jr .pastdmark  
34b0 ..			.dmark: db "REP"  
34b3 f1			.pastdmark: pop af  
34b4			endm  
# End of macro DMARK
34b4						CALLMONITOR 
34b4 cd 57 17			call break_point_state  
34b7				endm  
# End of macro CALLMONITOR
34b7					endif 
34b7			 
34b7 2a 5b f7				ld hl, (os_tok_ptr) 
34ba 23					inc hl   ; R 
34bb 23					inc hl  ; E 
34bc 23					inc hl   ; P 
34bd 23					inc hl   ; E 
34be 23					inc hl   ; A 
34bf 23					inc hl   ; T 
34c0 23					inc hl   ; zero 
34c1					FORTH_RSP_NEXT 
34c1 cd 5b 1d			call macro_forth_rsp_next 
34c4				endm 
# End of macro FORTH_RSP_NEXT
34c4			 
34c4			 
34c4					if DEBUG_FORTH_WORDS 
34c4						DMARK "REP" 
34c4 f5				push af  
34c5 3a d9 34			ld a, (.dmark)  
34c8 32 b4 fe			ld (debug_mark),a  
34cb 3a da 34			ld a, (.dmark+1)  
34ce 32 b5 fe			ld (debug_mark+1),a  
34d1 3a db 34			ld a, (.dmark+2)  
34d4 32 b6 fe			ld (debug_mark+2),a  
34d7 18 03			jr .pastdmark  
34d9 ..			.dmark: db "REP"  
34dc f1			.pastdmark: pop af  
34dd			endm  
# End of macro DMARK
34dd						;pop bc    ; TODO BUG ?????? what is this for???? 
34dd						CALLMONITOR 
34dd cd 57 17			call break_point_state  
34e0				endm  
# End of macro CALLMONITOR
34e0					endif 
34e0			 
34e0					NEXTW 
34e0 c3 1d 21			jp macro_next 
34e3				endm 
# End of macro NEXTW
34e3			;	       NEXTW 
34e3			 
34e3			.UNTIL: 
34e3				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
34e3 72				db WORD_SYS_CORE+94             
34e4 7a 35			dw .ENDFLOW            
34e6 06				db 5 + 1 
34e7 .. 00			db "UNTIL",0              
34ed				endm 
# End of macro CWHEAD
34ed			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
34ed			 
34ed				; pop tos as check 
34ed			 
34ed				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
34ed			 
34ed				FORTH_DSP_VALUEHL 
34ed cd ab 1f			call macro_dsp_valuehl 
34f0				endm 
# End of macro FORTH_DSP_VALUEHL
34f0			 
34f0					if DEBUG_FORTH_WORDS_KEY 
34f0						DMARK "UNT" 
34f0 f5				push af  
34f1 3a 05 35			ld a, (.dmark)  
34f4 32 b4 fe			ld (debug_mark),a  
34f7 3a 06 35			ld a, (.dmark+1)  
34fa 32 b5 fe			ld (debug_mark+1),a  
34fd 3a 07 35			ld a, (.dmark+2)  
3500 32 b6 fe			ld (debug_mark+2),a  
3503 18 03			jr .pastdmark  
3505 ..			.dmark: db "UNT"  
3508 f1			.pastdmark: pop af  
3509			endm  
# End of macro DMARK
3509						CALLMONITOR 
3509 cd 57 17			call break_point_state  
350c				endm  
# End of macro CALLMONITOR
350c					endif 
350c			 
350c			;	push hl 
350c				FORTH_DSP_POP 
350c cd 63 20			call macro_forth_dsp_pop 
350f				endm 
# End of macro FORTH_DSP_POP
350f			 
350f			;	pop hl 
350f			 
350f				; test if true 
350f			 
350f cd 03 0e			call ishlzero 
3512			;	ld a,l 
3512			;	add h 
3512			; 
3512			;	cp 0 
3512			 
3512 20 3e			jr nz, .untilnotdone 
3514			 
3514					if DEBUG_FORTH_WORDS 
3514						DMARK "UNf" 
3514 f5				push af  
3515 3a 29 35			ld a, (.dmark)  
3518 32 b4 fe			ld (debug_mark),a  
351b 3a 2a 35			ld a, (.dmark+1)  
351e 32 b5 fe			ld (debug_mark+1),a  
3521 3a 2b 35			ld a, (.dmark+2)  
3524 32 b6 fe			ld (debug_mark+2),a  
3527 18 03			jr .pastdmark  
3529 ..			.dmark: db "UNf"  
352c f1			.pastdmark: pop af  
352d			endm  
# End of macro DMARK
352d						CALLMONITOR 
352d cd 57 17			call break_point_state  
3530				endm  
# End of macro CALLMONITOR
3530					endif 
3530			 
3530			 
3530			 
3530				FORTH_RSP_POP     ; get rid of DO ptr 
3530 cd 7c 1d			call macro_forth_rsp_pop 
3533				endm 
# End of macro FORTH_RSP_POP
3533			 
3533			if DEBUG_FORTH_WORDS 
3533						DMARK "UN>" 
3533 f5				push af  
3534 3a 48 35			ld a, (.dmark)  
3537 32 b4 fe			ld (debug_mark),a  
353a 3a 49 35			ld a, (.dmark+1)  
353d 32 b5 fe			ld (debug_mark+1),a  
3540 3a 4a 35			ld a, (.dmark+2)  
3543 32 b6 fe			ld (debug_mark+2),a  
3546 18 03			jr .pastdmark  
3548 ..			.dmark: db "UN>"  
354b f1			.pastdmark: pop af  
354c			endm  
# End of macro DMARK
354c				CALLMONITOR 
354c cd 57 17			call break_point_state  
354f				endm  
# End of macro CALLMONITOR
354f			endif 
354f			 
354f					NEXTW 
354f c3 1d 21			jp macro_next 
3552				endm 
# End of macro NEXTW
3552				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3552			 
3552			.untilnotdone: 
3552			 
3552			 
3552			;	; get DO ptr 
3552			; 
3552				FORTH_RSP_TOS 
3552 cd 72 1d			call macro_forth_rsp_tos 
3555				endm 
# End of macro FORTH_RSP_TOS
3555			 
3555				;push hl 
3555			 
3555				; not going to DO any more 
3555				; get rid of the RSP pointer as DO will add it back in 
3555				;FORTH_RSP_POP 
3555				;pop hl 
3555			 
3555			 
3555 22 5b f7			ld (os_tok_ptr), hl 
3558					if DEBUG_FORTH_WORDS 
3558						DMARK "UN<" 
3558 f5				push af  
3559 3a 6d 35			ld a, (.dmark)  
355c 32 b4 fe			ld (debug_mark),a  
355f 3a 6e 35			ld a, (.dmark+1)  
3562 32 b5 fe			ld (debug_mark+1),a  
3565 3a 6f 35			ld a, (.dmark+2)  
3568 32 b6 fe			ld (debug_mark+2),a  
356b 18 03			jr .pastdmark  
356d ..			.dmark: db "UN<"  
3570 f1			.pastdmark: pop af  
3571			endm  
# End of macro DMARK
3571					CALLMONITOR 
3571 cd 57 17			call break_point_state  
3574				endm  
# End of macro CALLMONITOR
3574				endif 
3574 c3 ae 21			jp exec1 
3577			 
3577					 
3577			 
3577			 
3577					NEXTW 
3577 c3 1d 21			jp macro_next 
357a				endm 
# End of macro NEXTW
357a			 
357a			 
357a			.ENDFLOW: 
357a			 
357a			; eof 
357a			 
# End of file forth_words_flow.asm
357a			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
357a			include "forth_words_logic.asm" 
357a			 
357a			; | ## Logic Words 
357a			 
357a			.NOT: 
357a				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
357a 2d				db WORD_SYS_CORE+25             
357b c2 35			dw .IS            
357d 04				db 3 + 1 
357e .. 00			db "NOT",0              
3582				endm 
# End of macro CWHEAD
3582			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3582					if DEBUG_FORTH_WORDS_KEY 
3582						DMARK "NOT" 
3582 f5				push af  
3583 3a 97 35			ld a, (.dmark)  
3586 32 b4 fe			ld (debug_mark),a  
3589 3a 98 35			ld a, (.dmark+1)  
358c 32 b5 fe			ld (debug_mark+1),a  
358f 3a 99 35			ld a, (.dmark+2)  
3592 32 b6 fe			ld (debug_mark+2),a  
3595 18 03			jr .pastdmark  
3597 ..			.dmark: db "NOT"  
359a f1			.pastdmark: pop af  
359b			endm  
# End of macro DMARK
359b						CALLMONITOR 
359b cd 57 17			call break_point_state  
359e				endm  
# End of macro CALLMONITOR
359e					endif 
359e					FORTH_DSP 
359e cd 71 1f			call macro_forth_dsp 
35a1				endm 
# End of macro FORTH_DSP
35a1 7e					ld a,(hl)	; get type of value on TOS 
35a2 fe 02				cp DS_TYPE_INUM  
35a4 28 03				jr z, .noti 
35a6					NEXTW 
35a6 c3 1d 21			jp macro_next 
35a9				endm 
# End of macro NEXTW
35a9			.noti:          FORTH_DSP_VALUEHL 
35a9 cd ab 1f			call macro_dsp_valuehl 
35ac				endm 
# End of macro FORTH_DSP_VALUEHL
35ac			;		push hl 
35ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ac cd 63 20			call macro_forth_dsp_pop 
35af				endm 
# End of macro FORTH_DSP_POP
35af			;		pop hl 
35af 3e 00				ld a,0 
35b1 bd					cp l 
35b2 28 04				jr z, .not2t 
35b4 2e 00				ld l, 0 
35b6 18 02				jr .notip 
35b8			 
35b8 2e ff		.not2t:		ld l, 255 
35ba			 
35ba 26 00		.notip:		ld h, 0	 
35bc			 
35bc cd b4 1d				call forth_push_numhl 
35bf					NEXTW 
35bf c3 1d 21			jp macro_next 
35c2				endm 
# End of macro NEXTW
35c2			 
35c2			.IS: 
35c2				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
35c2 2d				db WORD_SYS_CORE+25             
35c3 e8 35			dw .LZERO            
35c5 03				db 2 + 1 
35c6 .. 00			db "IS",0              
35c9				endm 
# End of macro CWHEAD
35c9			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
35c9					if DEBUG_FORTH_WORDS_KEY 
35c9						DMARK "IS." 
35c9 f5				push af  
35ca 3a de 35			ld a, (.dmark)  
35cd 32 b4 fe			ld (debug_mark),a  
35d0 3a df 35			ld a, (.dmark+1)  
35d3 32 b5 fe			ld (debug_mark+1),a  
35d6 3a e0 35			ld a, (.dmark+2)  
35d9 32 b6 fe			ld (debug_mark+2),a  
35dc 18 03			jr .pastdmark  
35de ..			.dmark: db "IS."  
35e1 f1			.pastdmark: pop af  
35e2			endm  
# End of macro DMARK
35e2						CALLMONITOR 
35e2 cd 57 17			call break_point_state  
35e5				endm  
# End of macro CALLMONITOR
35e5					endif 
35e5					NEXTW 
35e5 c3 1d 21			jp macro_next 
35e8				endm 
# End of macro NEXTW
35e8			.LZERO: 
35e8				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
35e8 2d				db WORD_SYS_CORE+25             
35e9 f2 35			dw .TZERO            
35eb 03				db 2 + 1 
35ec .. 00			db "0<",0              
35ef				endm 
# End of macro CWHEAD
35ef			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
35ef					NEXTW 
35ef c3 1d 21			jp macro_next 
35f2				endm 
# End of macro NEXTW
35f2			.TZERO: 
35f2				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
35f2 2e				db WORD_SYS_CORE+26             
35f3 39 36			dw .LESS            
35f5 03				db 2 + 1 
35f6 .. 00			db "0=",0              
35f9				endm 
# End of macro CWHEAD
35f9			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
35f9				; TODO add floating point number detection 
35f9					;v5 FORTH_DSP_VALUE 
35f9					if DEBUG_FORTH_WORDS_KEY 
35f9						DMARK "0=." 
35f9 f5				push af  
35fa 3a 0e 36			ld a, (.dmark)  
35fd 32 b4 fe			ld (debug_mark),a  
3600 3a 0f 36			ld a, (.dmark+1)  
3603 32 b5 fe			ld (debug_mark+1),a  
3606 3a 10 36			ld a, (.dmark+2)  
3609 32 b6 fe			ld (debug_mark+2),a  
360c 18 03			jr .pastdmark  
360e ..			.dmark: db "0=."  
3611 f1			.pastdmark: pop af  
3612			endm  
# End of macro DMARK
3612						CALLMONITOR 
3612 cd 57 17			call break_point_state  
3615				endm  
# End of macro CALLMONITOR
3615					endif 
3615					FORTH_DSP 
3615 cd 71 1f			call macro_forth_dsp 
3618				endm 
# End of macro FORTH_DSP
3618 7e					ld a,(hl)	; get type of value on TOS 
3619 fe 02				cp DS_TYPE_INUM  
361b 28 00				jr z, .tz_inum 
361d			 
361d				if FORTH_ENABLE_FLOATMATH 
361d					jr .tz_done 
361d			 
361d				endif 
361d					 
361d			 
361d			.tz_inum: 
361d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361d cd ab 1f			call macro_dsp_valuehl 
3620				endm 
# End of macro FORTH_DSP_VALUEHL
3620			 
3620			;		push hl 
3620			 
3620					; destroy value TOS 
3620			 
3620					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3620 cd 63 20			call macro_forth_dsp_pop 
3623				endm 
# End of macro FORTH_DSP_POP
3623			 
3623			;		pop hl 
3623			 
3623 3e 00				ld a,0 
3625			 
3625 bd					cp l 
3626 20 08				jr nz, .tz_notzero 
3628			 
3628 bc					cp h 
3629			 
3629 20 05				jr nz, .tz_notzero 
362b			 
362b			 
362b 21 01 00				ld hl, FORTH_TRUE 
362e 18 03				jr .tz_done 
3630			 
3630 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3633			 
3633					; push value back onto stack for another op etc 
3633			 
3633			.tz_done: 
3633 cd b4 1d				call forth_push_numhl 
3636			 
3636					NEXTW 
3636 c3 1d 21			jp macro_next 
3639				endm 
# End of macro NEXTW
3639			.LESS: 
3639				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3639 2f				db WORD_SYS_CORE+27             
363a a2 36			dw .GT            
363c 02				db 1 + 1 
363d .. 00			db "<",0              
363f				endm 
# End of macro CWHEAD
363f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
363f				; TODO add floating point number detection 
363f					if DEBUG_FORTH_WORDS_KEY 
363f						DMARK "LES" 
363f f5				push af  
3640 3a 54 36			ld a, (.dmark)  
3643 32 b4 fe			ld (debug_mark),a  
3646 3a 55 36			ld a, (.dmark+1)  
3649 32 b5 fe			ld (debug_mark+1),a  
364c 3a 56 36			ld a, (.dmark+2)  
364f 32 b6 fe			ld (debug_mark+2),a  
3652 18 03			jr .pastdmark  
3654 ..			.dmark: db "LES"  
3657 f1			.pastdmark: pop af  
3658			endm  
# End of macro DMARK
3658						CALLMONITOR 
3658 cd 57 17			call break_point_state  
365b				endm  
# End of macro CALLMONITOR
365b					endif 
365b					FORTH_DSP 
365b cd 71 1f			call macro_forth_dsp 
365e				endm 
# End of macro FORTH_DSP
365e					;v5 FORTH_DSP_VALUE 
365e 7e					ld a,(hl)	; get type of value on TOS 
365f fe 02				cp DS_TYPE_INUM  
3661 28 00				jr z, .less_inum 
3663			 
3663				if FORTH_ENABLE_FLOATMATH 
3663					jr .less_done 
3663			 
3663				endif 
3663					 
3663			 
3663			.less_inum: 
3663					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3663 cd ab 1f			call macro_dsp_valuehl 
3666				endm 
# End of macro FORTH_DSP_VALUEHL
3666			 
3666 e5					push hl  ; u2 
3667			 
3667					; destroy value TOS 
3667			 
3667					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3667 cd 63 20			call macro_forth_dsp_pop 
366a				endm 
# End of macro FORTH_DSP_POP
366a			 
366a			 
366a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366a cd ab 1f			call macro_dsp_valuehl 
366d				endm 
# End of macro FORTH_DSP_VALUEHL
366d			 
366d e5					push hl    ; u1 
366e			 
366e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
366e cd 63 20			call macro_forth_dsp_pop 
3671				endm 
# End of macro FORTH_DSP_POP
3671			 
3671			 
3671 b7			 or a      ;clear carry flag 
3672 01 00 00		 ld bc, FORTH_FALSE 
3675 e1			  pop hl    ; u1 
3676 d1			  pop de    ; u2 
3677 ed 52		  sbc hl,de 
3679 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
367b			 
367b 01 01 00		 ld bc, FORTH_TRUE 
367e			.lscont:  
367e c5					push bc 
367f e1					pop hl 
3680			 
3680					if DEBUG_FORTH_WORDS 
3680						DMARK "LT1" 
3680 f5				push af  
3681 3a 95 36			ld a, (.dmark)  
3684 32 b4 fe			ld (debug_mark),a  
3687 3a 96 36			ld a, (.dmark+1)  
368a 32 b5 fe			ld (debug_mark+1),a  
368d 3a 97 36			ld a, (.dmark+2)  
3690 32 b6 fe			ld (debug_mark+2),a  
3693 18 03			jr .pastdmark  
3695 ..			.dmark: db "LT1"  
3698 f1			.pastdmark: pop af  
3699			endm  
# End of macro DMARK
3699						CALLMONITOR 
3699 cd 57 17			call break_point_state  
369c				endm  
# End of macro CALLMONITOR
369c					endif 
369c cd b4 1d				call forth_push_numhl 
369f			 
369f					NEXTW 
369f c3 1d 21			jp macro_next 
36a2				endm 
# End of macro NEXTW
36a2			.GT: 
36a2				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
36a2 30				db WORD_SYS_CORE+28             
36a3 0b 37			dw .EQUAL            
36a5 02				db 1 + 1 
36a6 .. 00			db ">",0              
36a8				endm 
# End of macro CWHEAD
36a8			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
36a8				; TODO add floating point number detection 
36a8					if DEBUG_FORTH_WORDS_KEY 
36a8						DMARK "GRT" 
36a8 f5				push af  
36a9 3a bd 36			ld a, (.dmark)  
36ac 32 b4 fe			ld (debug_mark),a  
36af 3a be 36			ld a, (.dmark+1)  
36b2 32 b5 fe			ld (debug_mark+1),a  
36b5 3a bf 36			ld a, (.dmark+2)  
36b8 32 b6 fe			ld (debug_mark+2),a  
36bb 18 03			jr .pastdmark  
36bd ..			.dmark: db "GRT"  
36c0 f1			.pastdmark: pop af  
36c1			endm  
# End of macro DMARK
36c1						CALLMONITOR 
36c1 cd 57 17			call break_point_state  
36c4				endm  
# End of macro CALLMONITOR
36c4					endif 
36c4					FORTH_DSP 
36c4 cd 71 1f			call macro_forth_dsp 
36c7				endm 
# End of macro FORTH_DSP
36c7					;FORTH_DSP_VALUE 
36c7 7e					ld a,(hl)	; get type of value on TOS 
36c8 fe 02				cp DS_TYPE_INUM  
36ca 28 00				jr z, .gt_inum 
36cc			 
36cc				if FORTH_ENABLE_FLOATMATH 
36cc					jr .gt_done 
36cc			 
36cc				endif 
36cc					 
36cc			 
36cc			.gt_inum: 
36cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36cc cd ab 1f			call macro_dsp_valuehl 
36cf				endm 
# End of macro FORTH_DSP_VALUEHL
36cf			 
36cf e5					push hl  ; u2 
36d0			 
36d0					; destroy value TOS 
36d0			 
36d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d0 cd 63 20			call macro_forth_dsp_pop 
36d3				endm 
# End of macro FORTH_DSP_POP
36d3			 
36d3			 
36d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36d3 cd ab 1f			call macro_dsp_valuehl 
36d6				endm 
# End of macro FORTH_DSP_VALUEHL
36d6			 
36d6 e5					push hl    ; u1 
36d7			 
36d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d7 cd 63 20			call macro_forth_dsp_pop 
36da				endm 
# End of macro FORTH_DSP_POP
36da			 
36da			 
36da b7			 or a      ;clear carry flag 
36db 01 00 00		 ld bc, FORTH_FALSE 
36de e1			  pop hl    ; u1 
36df d1			  pop de    ; u2 
36e0 ed 52		  sbc hl,de 
36e2 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
36e4			 
36e4 01 01 00		 ld bc, FORTH_TRUE 
36e7			.gtcont:  
36e7 c5					push bc 
36e8 e1					pop hl 
36e9			 
36e9					if DEBUG_FORTH_WORDS 
36e9						DMARK "GT1" 
36e9 f5				push af  
36ea 3a fe 36			ld a, (.dmark)  
36ed 32 b4 fe			ld (debug_mark),a  
36f0 3a ff 36			ld a, (.dmark+1)  
36f3 32 b5 fe			ld (debug_mark+1),a  
36f6 3a 00 37			ld a, (.dmark+2)  
36f9 32 b6 fe			ld (debug_mark+2),a  
36fc 18 03			jr .pastdmark  
36fe ..			.dmark: db "GT1"  
3701 f1			.pastdmark: pop af  
3702			endm  
# End of macro DMARK
3702						CALLMONITOR 
3702 cd 57 17			call break_point_state  
3705				endm  
# End of macro CALLMONITOR
3705					endif 
3705 cd b4 1d				call forth_push_numhl 
3708			 
3708					NEXTW 
3708 c3 1d 21			jp macro_next 
370b				endm 
# End of macro NEXTW
370b			.EQUAL: 
370b				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
370b 31				db WORD_SYS_CORE+29             
370c 76 37			dw .ENDLOGIC            
370e 02				db 1 + 1 
370f .. 00			db "=",0              
3711				endm 
# End of macro CWHEAD
3711			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3711				; TODO add floating point number detection 
3711					if DEBUG_FORTH_WORDS_KEY 
3711						DMARK "EQ." 
3711 f5				push af  
3712 3a 26 37			ld a, (.dmark)  
3715 32 b4 fe			ld (debug_mark),a  
3718 3a 27 37			ld a, (.dmark+1)  
371b 32 b5 fe			ld (debug_mark+1),a  
371e 3a 28 37			ld a, (.dmark+2)  
3721 32 b6 fe			ld (debug_mark+2),a  
3724 18 03			jr .pastdmark  
3726 ..			.dmark: db "EQ."  
3729 f1			.pastdmark: pop af  
372a			endm  
# End of macro DMARK
372a						CALLMONITOR 
372a cd 57 17			call break_point_state  
372d				endm  
# End of macro CALLMONITOR
372d					endif 
372d					FORTH_DSP 
372d cd 71 1f			call macro_forth_dsp 
3730				endm 
# End of macro FORTH_DSP
3730					;v5 FORTH_DSP_VALUE 
3730 7e					ld a,(hl)	; get type of value on TOS 
3731 fe 02				cp DS_TYPE_INUM  
3733 28 00				jr z, .eq_inum 
3735			 
3735				if FORTH_ENABLE_FLOATMATH 
3735					jr .eq_done 
3735			 
3735				endif 
3735					 
3735			 
3735			.eq_inum: 
3735					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3735 cd ab 1f			call macro_dsp_valuehl 
3738				endm 
# End of macro FORTH_DSP_VALUEHL
3738			 
3738 e5					push hl 
3739			 
3739					; destroy value TOS 
3739			 
3739					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3739 cd 63 20			call macro_forth_dsp_pop 
373c				endm 
# End of macro FORTH_DSP_POP
373c			 
373c			 
373c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
373c cd ab 1f			call macro_dsp_valuehl 
373f				endm 
# End of macro FORTH_DSP_VALUEHL
373f			 
373f					; one value on hl get other one back 
373f			 
373f e5					push hl 
3740			 
3740					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3740 cd 63 20			call macro_forth_dsp_pop 
3743				endm 
# End of macro FORTH_DSP_POP
3743			 
3743 0e 00				ld c, FORTH_FALSE 
3745			 
3745 e1					pop hl 
3746 d1					pop de 
3747			 
3747 7b					ld a, e 
3748 bd					cp l 
3749			 
3749 20 06				jr nz, .eq_done 
374b			 
374b 7a					ld a, d 
374c bc					cp h 
374d			 
374d 20 02				jr nz, .eq_done 
374f			 
374f 0e 01				ld c, FORTH_TRUE 
3751					 
3751			 
3751			 
3751			.eq_done: 
3751			 
3751					; TODO push value back onto stack for another op etc 
3751			 
3751 26 00				ld h, 0 
3753 69					ld l, c 
3754					if DEBUG_FORTH_WORDS 
3754						DMARK "EQ1" 
3754 f5				push af  
3755 3a 69 37			ld a, (.dmark)  
3758 32 b4 fe			ld (debug_mark),a  
375b 3a 6a 37			ld a, (.dmark+1)  
375e 32 b5 fe			ld (debug_mark+1),a  
3761 3a 6b 37			ld a, (.dmark+2)  
3764 32 b6 fe			ld (debug_mark+2),a  
3767 18 03			jr .pastdmark  
3769 ..			.dmark: db "EQ1"  
376c f1			.pastdmark: pop af  
376d			endm  
# End of macro DMARK
376d						CALLMONITOR 
376d cd 57 17			call break_point_state  
3770				endm  
# End of macro CALLMONITOR
3770					endif 
3770 cd b4 1d				call forth_push_numhl 
3773			 
3773					NEXTW 
3773 c3 1d 21			jp macro_next 
3776				endm 
# End of macro NEXTW
3776			 
3776			 
3776			.ENDLOGIC: 
3776			; eof 
3776			 
3776			 
# End of file forth_words_logic.asm
3776			include "forth_words_maths.asm" 
3776			 
3776			; | ## Maths Words 
3776			 
3776			.PLUS:	 
3776				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3776 15				db WORD_SYS_CORE+1             
3777 b8 37			dw .NEG            
3779 02				db 1 + 1 
377a .. 00			db "+",0              
377c				endm 
# End of macro CWHEAD
377c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
377c					if DEBUG_FORTH_WORDS_KEY 
377c						DMARK "PLU" 
377c f5				push af  
377d 3a 91 37			ld a, (.dmark)  
3780 32 b4 fe			ld (debug_mark),a  
3783 3a 92 37			ld a, (.dmark+1)  
3786 32 b5 fe			ld (debug_mark+1),a  
3789 3a 93 37			ld a, (.dmark+2)  
378c 32 b6 fe			ld (debug_mark+2),a  
378f 18 03			jr .pastdmark  
3791 ..			.dmark: db "PLU"  
3794 f1			.pastdmark: pop af  
3795			endm  
# End of macro DMARK
3795						CALLMONITOR 
3795 cd 57 17			call break_point_state  
3798				endm  
# End of macro CALLMONITOR
3798					endif 
3798					; add top two values and push back result 
3798			 
3798					;for v5 FORTH_DSP_VALUE 
3798					FORTH_DSP 
3798 cd 71 1f			call macro_forth_dsp 
379b				endm 
# End of macro FORTH_DSP
379b 7e					ld a,(hl)	; get type of value on TOS 
379c fe 02				cp DS_TYPE_INUM  
379e 28 03				jr z, .dot_inum 
37a0			 
37a0					NEXTW 
37a0 c3 1d 21			jp macro_next 
37a3				endm 
# End of macro NEXTW
37a3			 
37a3			; float maths 
37a3			 
37a3				if FORTH_ENABLE_FLOATMATH 
37a3						inc hl      ; now at start of numeric as string 
37a3			 
37a3					if DEBUG_FORTH_MATHS 
37a3						DMARK "ADD" 
37a3				CALLMONITOR 
37a3					endif 
37a3			 
37a3					;ld ix, hl 
37a3					call CON 
37a3			 
37a3			 
37a3					push hl 
37a3					 
37a3					 
37a3			 
37a3						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
37a3			 
37a3					; get next number 
37a3			 
37a3						FORTH_DSP_VALUE 
37a3			 
37a3						inc hl      ; now at start of numeric as string 
37a3			 
37a3					;ld ix, hl 
37a3					call CON 
37a3			 
37a3					push hl 
37a3			 
37a3			 
37a3						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a3			 
37a3						; TODO do add 
37a3			 
37a3						call IADD 
37a3			 
37a3						; TODO get result back as ascii 
37a3			 
37a3						; TODO push result  
37a3			 
37a3			 
37a3			 
37a3						jr .dot_done 
37a3				endif 
37a3			 
37a3			.dot_inum: 
37a3			 
37a3			 
37a3					if DEBUG_FORTH_DOT 
37a3						DMARK "+IT" 
37a3				CALLMONITOR 
37a3					endif 
37a3			 
37a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a3 cd ab 1f			call macro_dsp_valuehl 
37a6				endm 
# End of macro FORTH_DSP_VALUEHL
37a6			 
37a6				; TODO add floating point number detection 
37a6			 
37a6 e5					push hl 
37a7			 
37a7					; destroy value TOS 
37a7			 
37a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a7 cd 63 20			call macro_forth_dsp_pop 
37aa				endm 
# End of macro FORTH_DSP_POP
37aa			 
37aa			 
37aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37aa cd ab 1f			call macro_dsp_valuehl 
37ad				endm 
# End of macro FORTH_DSP_VALUEHL
37ad			 
37ad					; one value on hl get other one back 
37ad			 
37ad d1					pop de 
37ae			 
37ae					; do the add 
37ae			 
37ae 19					add hl,de 
37af			 
37af					; save it 
37af			 
37af			;		push hl	 
37af			 
37af					; 
37af			 
37af					; destroy value TOS 
37af			 
37af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37af cd 63 20			call macro_forth_dsp_pop 
37b2				endm 
# End of macro FORTH_DSP_POP
37b2			 
37b2					; TODO push value back onto stack for another op etc 
37b2			 
37b2			;		pop hl 
37b2			 
37b2			.dot_done: 
37b2 cd b4 1d				call forth_push_numhl 
37b5			 
37b5					NEXTW 
37b5 c3 1d 21			jp macro_next 
37b8				endm 
# End of macro NEXTW
37b8			.NEG: 
37b8			 
37b8				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
37b8 17				db WORD_SYS_CORE+3             
37b9 fb 37			dw .DIV            
37bb 02				db 1 + 1 
37bc .. 00			db "-",0              
37be				endm 
# End of macro CWHEAD
37be			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
37be					if DEBUG_FORTH_WORDS_KEY 
37be						DMARK "SUB" 
37be f5				push af  
37bf 3a d3 37			ld a, (.dmark)  
37c2 32 b4 fe			ld (debug_mark),a  
37c5 3a d4 37			ld a, (.dmark+1)  
37c8 32 b5 fe			ld (debug_mark+1),a  
37cb 3a d5 37			ld a, (.dmark+2)  
37ce 32 b6 fe			ld (debug_mark+2),a  
37d1 18 03			jr .pastdmark  
37d3 ..			.dmark: db "SUB"  
37d6 f1			.pastdmark: pop af  
37d7			endm  
# End of macro DMARK
37d7						CALLMONITOR 
37d7 cd 57 17			call break_point_state  
37da				endm  
# End of macro CALLMONITOR
37da					endif 
37da			 
37da			 
37da				; TODO add floating point number detection 
37da					; v5 FORTH_DSP_VALUE 
37da					FORTH_DSP 
37da cd 71 1f			call macro_forth_dsp 
37dd				endm 
# End of macro FORTH_DSP
37dd 7e					ld a,(hl)	; get type of value on TOS 
37de fe 02				cp DS_TYPE_INUM  
37e0 28 03				jr z, .neg_inum 
37e2			 
37e2					NEXTW 
37e2 c3 1d 21			jp macro_next 
37e5				endm 
# End of macro NEXTW
37e5			 
37e5			; float maths 
37e5			 
37e5				if FORTH_ENABLE_FLOATMATH 
37e5					jr .neg_done 
37e5			 
37e5				endif 
37e5					 
37e5			 
37e5			.neg_inum: 
37e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e5 cd ab 1f			call macro_dsp_valuehl 
37e8				endm 
# End of macro FORTH_DSP_VALUEHL
37e8			 
37e8 e5					push hl 
37e9			 
37e9					; destroy value TOS 
37e9			 
37e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e9 cd 63 20			call macro_forth_dsp_pop 
37ec				endm 
# End of macro FORTH_DSP_POP
37ec			 
37ec			 
37ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ec cd ab 1f			call macro_dsp_valuehl 
37ef				endm 
# End of macro FORTH_DSP_VALUEHL
37ef			 
37ef					; one value on hl get other one back 
37ef			 
37ef d1					pop de 
37f0			 
37f0					; do the sub 
37f0			;		ex de, hl 
37f0			 
37f0 ed 52				sbc hl,de 
37f2			 
37f2					; save it 
37f2			 
37f2			;		push hl	 
37f2			 
37f2					; 
37f2			 
37f2					; destroy value TOS 
37f2			 
37f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f2 cd 63 20			call macro_forth_dsp_pop 
37f5				endm 
# End of macro FORTH_DSP_POP
37f5			 
37f5					; TODO push value back onto stack for another op etc 
37f5			 
37f5			;		pop hl 
37f5			 
37f5 cd b4 1d				call forth_push_numhl 
37f8			.neg_done: 
37f8			 
37f8					NEXTW 
37f8 c3 1d 21			jp macro_next 
37fb				endm 
# End of macro NEXTW
37fb			.DIV: 
37fb				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
37fb 18				db WORD_SYS_CORE+4             
37fc 48 38			dw .MUL            
37fe 02				db 1 + 1 
37ff .. 00			db "/",0              
3801				endm 
# End of macro CWHEAD
3801			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3801					if DEBUG_FORTH_WORDS_KEY 
3801						DMARK "DIV" 
3801 f5				push af  
3802 3a 16 38			ld a, (.dmark)  
3805 32 b4 fe			ld (debug_mark),a  
3808 3a 17 38			ld a, (.dmark+1)  
380b 32 b5 fe			ld (debug_mark+1),a  
380e 3a 18 38			ld a, (.dmark+2)  
3811 32 b6 fe			ld (debug_mark+2),a  
3814 18 03			jr .pastdmark  
3816 ..			.dmark: db "DIV"  
3819 f1			.pastdmark: pop af  
381a			endm  
# End of macro DMARK
381a						CALLMONITOR 
381a cd 57 17			call break_point_state  
381d				endm  
# End of macro CALLMONITOR
381d					endif 
381d				; TODO add floating point number detection 
381d					; v5 FORTH_DSP_VALUE 
381d					FORTH_DSP 
381d cd 71 1f			call macro_forth_dsp 
3820				endm 
# End of macro FORTH_DSP
3820 7e					ld a,(hl)	; get type of value on TOS 
3821 fe 02				cp DS_TYPE_INUM  
3823 28 03				jr z, .div_inum 
3825			 
3825				if FORTH_ENABLE_FLOATMATH 
3825					jr .div_done 
3825			 
3825				endif 
3825					NEXTW 
3825 c3 1d 21			jp macro_next 
3828				endm 
# End of macro NEXTW
3828			.div_inum: 
3828			 
3828					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3828 cd ab 1f			call macro_dsp_valuehl 
382b				endm 
# End of macro FORTH_DSP_VALUEHL
382b			 
382b e5					push hl    ; to go to bc 
382c			 
382c					; destroy value TOS 
382c			 
382c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
382c cd 63 20			call macro_forth_dsp_pop 
382f				endm 
# End of macro FORTH_DSP_POP
382f			 
382f			 
382f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
382f cd ab 1f			call macro_dsp_valuehl 
3832				endm 
# End of macro FORTH_DSP_VALUEHL
3832			 
3832					; hl to go to de 
3832			 
3832 e5					push hl 
3833			 
3833 c1					pop bc 
3834 d1					pop de		 
3835			 
3835			 
3835					if DEBUG_FORTH_MATHS 
3835						DMARK "DIV" 
3835				CALLMONITOR 
3835					endif 
3835					; one value on hl but move to a get other one back 
3835			 
3835			        
3835 cd 37 0d			call Div16 
3838			 
3838			;	push af	 
3838 e5				push hl 
3839 c5				push bc 
383a			 
383a					if DEBUG_FORTH_MATHS 
383a						DMARK "DI1" 
383a				CALLMONITOR 
383a					endif 
383a			 
383a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383a cd 63 20			call macro_forth_dsp_pop 
383d				endm 
# End of macro FORTH_DSP_POP
383d			 
383d			 
383d			 
383d e1					pop hl    ; result 
383e			 
383e cd b4 1d				call forth_push_numhl 
3841			 
3841 e1					pop hl    ; reminder 
3842			;		ld h,0 
3842			;		ld l,d 
3842			 
3842 cd b4 1d				call forth_push_numhl 
3845			.div_done: 
3845					NEXTW 
3845 c3 1d 21			jp macro_next 
3848				endm 
# End of macro NEXTW
3848			.MUL: 
3848				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3848 19				db WORD_SYS_CORE+5             
3849 8d 38			dw .MIN            
384b 02				db 1 + 1 
384c .. 00			db "*",0              
384e				endm 
# End of macro CWHEAD
384e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
384e				; TODO add floating point number detection 
384e					if DEBUG_FORTH_WORDS_KEY 
384e						DMARK "MUL" 
384e f5				push af  
384f 3a 63 38			ld a, (.dmark)  
3852 32 b4 fe			ld (debug_mark),a  
3855 3a 64 38			ld a, (.dmark+1)  
3858 32 b5 fe			ld (debug_mark+1),a  
385b 3a 65 38			ld a, (.dmark+2)  
385e 32 b6 fe			ld (debug_mark+2),a  
3861 18 03			jr .pastdmark  
3863 ..			.dmark: db "MUL"  
3866 f1			.pastdmark: pop af  
3867			endm  
# End of macro DMARK
3867						CALLMONITOR 
3867 cd 57 17			call break_point_state  
386a				endm  
# End of macro CALLMONITOR
386a					endif 
386a					FORTH_DSP 
386a cd 71 1f			call macro_forth_dsp 
386d				endm 
# End of macro FORTH_DSP
386d					; v5 FORTH_DSP_VALUE 
386d 7e					ld a,(hl)	; get type of value on TOS 
386e fe 02				cp DS_TYPE_INUM  
3870 28 03				jr z, .mul_inum 
3872			 
3872				if FORTH_ENABLE_FLOATMATH 
3872					jr .mul_done 
3872			 
3872				endif 
3872			 
3872					NEXTW 
3872 c3 1d 21			jp macro_next 
3875				endm 
# End of macro NEXTW
3875			.mul_inum:	 
3875			 
3875					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3875 cd ab 1f			call macro_dsp_valuehl 
3878				endm 
# End of macro FORTH_DSP_VALUEHL
3878			 
3878 e5					push hl 
3879			 
3879					; destroy value TOS 
3879			 
3879					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3879 cd 63 20			call macro_forth_dsp_pop 
387c				endm 
# End of macro FORTH_DSP_POP
387c			 
387c			 
387c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
387c cd ab 1f			call macro_dsp_valuehl 
387f				endm 
# End of macro FORTH_DSP_VALUEHL
387f			 
387f					; one value on hl but move to a get other one back 
387f			 
387f 7d					ld a, l 
3880			 
3880 d1					pop de 
3881			 
3881					; do the mull 
3881			;		ex de, hl 
3881			 
3881 cd 5d 0d				call Mult16 
3884					; save it 
3884			 
3884			;		push hl	 
3884			 
3884					; 
3884			 
3884					; destroy value TOS 
3884			 
3884					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3884 cd 63 20			call macro_forth_dsp_pop 
3887				endm 
# End of macro FORTH_DSP_POP
3887			 
3887					; TODO push value back onto stack for another op etc 
3887			 
3887			;		pop hl 
3887			 
3887 cd b4 1d				call forth_push_numhl 
388a			 
388a			.mul_done: 
388a					NEXTW 
388a c3 1d 21			jp macro_next 
388d				endm 
# End of macro NEXTW
388d			 
388d			 
388d			 
388d			 
388d			.MIN: 
388d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
388d 49				db WORD_SYS_CORE+53             
388e 0e 39			dw .MAX            
3890 04				db 3 + 1 
3891 .. 00			db "MIN",0              
3895				endm 
# End of macro CWHEAD
3895			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3895					if DEBUG_FORTH_WORDS_KEY 
3895						DMARK "MIN" 
3895 f5				push af  
3896 3a aa 38			ld a, (.dmark)  
3899 32 b4 fe			ld (debug_mark),a  
389c 3a ab 38			ld a, (.dmark+1)  
389f 32 b5 fe			ld (debug_mark+1),a  
38a2 3a ac 38			ld a, (.dmark+2)  
38a5 32 b6 fe			ld (debug_mark+2),a  
38a8 18 03			jr .pastdmark  
38aa ..			.dmark: db "MIN"  
38ad f1			.pastdmark: pop af  
38ae			endm  
# End of macro DMARK
38ae						CALLMONITOR 
38ae cd 57 17			call break_point_state  
38b1				endm  
# End of macro CALLMONITOR
38b1					endif 
38b1					; get u2 
38b1			 
38b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b1 cd ab 1f			call macro_dsp_valuehl 
38b4				endm 
# End of macro FORTH_DSP_VALUEHL
38b4			 
38b4 e5					push hl   ; u2 
38b5			 
38b5					; destroy value TOS 
38b5			 
38b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b5 cd 63 20			call macro_forth_dsp_pop 
38b8				endm 
# End of macro FORTH_DSP_POP
38b8			 
38b8					; get u1 
38b8			 
38b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b8 cd ab 1f			call macro_dsp_valuehl 
38bb				endm 
# End of macro FORTH_DSP_VALUEHL
38bb			 
38bb e5					push hl  ; u1 
38bc			 
38bc					; destroy value TOS 
38bc			 
38bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38bc cd 63 20			call macro_forth_dsp_pop 
38bf				endm 
# End of macro FORTH_DSP_POP
38bf			 
38bf b7			 or a      ;clear carry flag 
38c0 e1			  pop hl    ; u1 
38c1 d1			  pop de    ; u2 
38c2 e5				push hl   ; saved in case hl is lowest 
38c3 ed 52		  sbc hl,de 
38c5 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
38c7			 
38c7 e1				pop hl 
38c8					if DEBUG_FORTH_WORDS 
38c8						DMARK "MIN" 
38c8 f5				push af  
38c9 3a dd 38			ld a, (.dmark)  
38cc 32 b4 fe			ld (debug_mark),a  
38cf 3a de 38			ld a, (.dmark+1)  
38d2 32 b5 fe			ld (debug_mark+1),a  
38d5 3a df 38			ld a, (.dmark+2)  
38d8 32 b6 fe			ld (debug_mark+2),a  
38db 18 03			jr .pastdmark  
38dd ..			.dmark: db "MIN"  
38e0 f1			.pastdmark: pop af  
38e1			endm  
# End of macro DMARK
38e1						CALLMONITOR 
38e1 cd 57 17			call break_point_state  
38e4				endm  
# End of macro CALLMONITOR
38e4					endif 
38e4 cd b4 1d				call forth_push_numhl 
38e7			 
38e7				       NEXTW 
38e7 c3 1d 21			jp macro_next 
38ea				endm 
# End of macro NEXTW
38ea			 
38ea			.mincont:  
38ea c1				pop bc   ; tidy up 
38eb eb				ex de , hl  
38ec					if DEBUG_FORTH_WORDS 
38ec						DMARK "MI1" 
38ec f5				push af  
38ed 3a 01 39			ld a, (.dmark)  
38f0 32 b4 fe			ld (debug_mark),a  
38f3 3a 02 39			ld a, (.dmark+1)  
38f6 32 b5 fe			ld (debug_mark+1),a  
38f9 3a 03 39			ld a, (.dmark+2)  
38fc 32 b6 fe			ld (debug_mark+2),a  
38ff 18 03			jr .pastdmark  
3901 ..			.dmark: db "MI1"  
3904 f1			.pastdmark: pop af  
3905			endm  
# End of macro DMARK
3905						CALLMONITOR 
3905 cd 57 17			call break_point_state  
3908				endm  
# End of macro CALLMONITOR
3908					endif 
3908 cd b4 1d				call forth_push_numhl 
390b			 
390b				       NEXTW 
390b c3 1d 21			jp macro_next 
390e				endm 
# End of macro NEXTW
390e			.MAX: 
390e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
390e 4a				db WORD_SYS_CORE+54             
390f 8f 39			dw .RND16            
3911 04				db 3 + 1 
3912 .. 00			db "MAX",0              
3916				endm 
# End of macro CWHEAD
3916			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3916					if DEBUG_FORTH_WORDS_KEY 
3916						DMARK "MAX" 
3916 f5				push af  
3917 3a 2b 39			ld a, (.dmark)  
391a 32 b4 fe			ld (debug_mark),a  
391d 3a 2c 39			ld a, (.dmark+1)  
3920 32 b5 fe			ld (debug_mark+1),a  
3923 3a 2d 39			ld a, (.dmark+2)  
3926 32 b6 fe			ld (debug_mark+2),a  
3929 18 03			jr .pastdmark  
392b ..			.dmark: db "MAX"  
392e f1			.pastdmark: pop af  
392f			endm  
# End of macro DMARK
392f						CALLMONITOR 
392f cd 57 17			call break_point_state  
3932				endm  
# End of macro CALLMONITOR
3932					endif 
3932					; get u2 
3932			 
3932					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3932 cd ab 1f			call macro_dsp_valuehl 
3935				endm 
# End of macro FORTH_DSP_VALUEHL
3935			 
3935 e5					push hl   ; u2 
3936			 
3936					; destroy value TOS 
3936			 
3936					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3936 cd 63 20			call macro_forth_dsp_pop 
3939				endm 
# End of macro FORTH_DSP_POP
3939			 
3939					; get u1 
3939			 
3939					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3939 cd ab 1f			call macro_dsp_valuehl 
393c				endm 
# End of macro FORTH_DSP_VALUEHL
393c			 
393c e5					push hl  ; u1 
393d			 
393d					; destroy value TOS 
393d			 
393d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
393d cd 63 20			call macro_forth_dsp_pop 
3940				endm 
# End of macro FORTH_DSP_POP
3940			 
3940 b7			 or a      ;clear carry flag 
3941 e1			  pop hl    ; u1 
3942 d1			  pop de    ; u2 
3943 e5				push hl   ; saved in case hl is lowest 
3944 ed 52		  sbc hl,de 
3946 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3948			 
3948 e1				pop hl 
3949					if DEBUG_FORTH_WORDS 
3949						DMARK "MAX" 
3949 f5				push af  
394a 3a 5e 39			ld a, (.dmark)  
394d 32 b4 fe			ld (debug_mark),a  
3950 3a 5f 39			ld a, (.dmark+1)  
3953 32 b5 fe			ld (debug_mark+1),a  
3956 3a 60 39			ld a, (.dmark+2)  
3959 32 b6 fe			ld (debug_mark+2),a  
395c 18 03			jr .pastdmark  
395e ..			.dmark: db "MAX"  
3961 f1			.pastdmark: pop af  
3962			endm  
# End of macro DMARK
3962						CALLMONITOR 
3962 cd 57 17			call break_point_state  
3965				endm  
# End of macro CALLMONITOR
3965					endif 
3965 cd b4 1d				call forth_push_numhl 
3968			 
3968				       NEXTW 
3968 c3 1d 21			jp macro_next 
396b				endm 
# End of macro NEXTW
396b			 
396b			.maxcont:  
396b c1				pop bc   ; tidy up 
396c eb				ex de , hl  
396d					if DEBUG_FORTH_WORDS 
396d						DMARK "MA1" 
396d f5				push af  
396e 3a 82 39			ld a, (.dmark)  
3971 32 b4 fe			ld (debug_mark),a  
3974 3a 83 39			ld a, (.dmark+1)  
3977 32 b5 fe			ld (debug_mark+1),a  
397a 3a 84 39			ld a, (.dmark+2)  
397d 32 b6 fe			ld (debug_mark+2),a  
3980 18 03			jr .pastdmark  
3982 ..			.dmark: db "MA1"  
3985 f1			.pastdmark: pop af  
3986			endm  
# End of macro DMARK
3986						CALLMONITOR 
3986 cd 57 17			call break_point_state  
3989				endm  
# End of macro CALLMONITOR
3989					endif 
3989 cd b4 1d				call forth_push_numhl 
398c				       NEXTW 
398c c3 1d 21			jp macro_next 
398f				endm 
# End of macro NEXTW
398f			 
398f			.RND16: 
398f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
398f 4e				db WORD_SYS_CORE+58             
3990 be 39			dw .RND8            
3992 06				db 5 + 1 
3993 .. 00			db "RND16",0              
3999				endm 
# End of macro CWHEAD
3999			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3999					if DEBUG_FORTH_WORDS_KEY 
3999						DMARK "R16" 
3999 f5				push af  
399a 3a ae 39			ld a, (.dmark)  
399d 32 b4 fe			ld (debug_mark),a  
39a0 3a af 39			ld a, (.dmark+1)  
39a3 32 b5 fe			ld (debug_mark+1),a  
39a6 3a b0 39			ld a, (.dmark+2)  
39a9 32 b6 fe			ld (debug_mark+2),a  
39ac 18 03			jr .pastdmark  
39ae ..			.dmark: db "R16"  
39b1 f1			.pastdmark: pop af  
39b2			endm  
# End of macro DMARK
39b2						CALLMONITOR 
39b2 cd 57 17			call break_point_state  
39b5				endm  
# End of macro CALLMONITOR
39b5					endif 
39b5 cd 01 0d				call prng16  
39b8 cd b4 1d				call forth_push_numhl 
39bb				       NEXTW 
39bb c3 1d 21			jp macro_next 
39be				endm 
# End of macro NEXTW
39be			.RND8: 
39be				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
39be 60				db WORD_SYS_CORE+76             
39bf f3 39			dw .RND            
39c1 05				db 4 + 1 
39c2 .. 00			db "RND8",0              
39c7				endm 
# End of macro CWHEAD
39c7			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
39c7					if DEBUG_FORTH_WORDS_KEY 
39c7						DMARK "RN8" 
39c7 f5				push af  
39c8 3a dc 39			ld a, (.dmark)  
39cb 32 b4 fe			ld (debug_mark),a  
39ce 3a dd 39			ld a, (.dmark+1)  
39d1 32 b5 fe			ld (debug_mark+1),a  
39d4 3a de 39			ld a, (.dmark+2)  
39d7 32 b6 fe			ld (debug_mark+2),a  
39da 18 03			jr .pastdmark  
39dc ..			.dmark: db "RN8"  
39df f1			.pastdmark: pop af  
39e0			endm  
# End of macro DMARK
39e0						CALLMONITOR 
39e0 cd 57 17			call break_point_state  
39e3				endm  
# End of macro CALLMONITOR
39e3					endif 
39e3 2a 35 fd				ld hl,(xrandc) 
39e6 23					inc hl 
39e7 cd 1b 0d				call xrnd 
39ea 6f					ld l,a	 
39eb 26 00				ld h,0 
39ed cd b4 1d				call forth_push_numhl 
39f0				       NEXTW 
39f0 c3 1d 21			jp macro_next 
39f3				endm 
# End of macro NEXTW
39f3			.RND: 
39f3				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
39f3 60				db WORD_SYS_CORE+76             
39f4 f9 3a			dw .ENDMATHS            
39f6 04				db 3 + 1 
39f7 .. 00			db "RND",0              
39fb				endm 
# End of macro CWHEAD
39fb			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
39fb			 
39fb					if DEBUG_FORTH_WORDS_KEY 
39fb						DMARK "RND" 
39fb f5				push af  
39fc 3a 10 3a			ld a, (.dmark)  
39ff 32 b4 fe			ld (debug_mark),a  
3a02 3a 11 3a			ld a, (.dmark+1)  
3a05 32 b5 fe			ld (debug_mark+1),a  
3a08 3a 12 3a			ld a, (.dmark+2)  
3a0b 32 b6 fe			ld (debug_mark+2),a  
3a0e 18 03			jr .pastdmark  
3a10 ..			.dmark: db "RND"  
3a13 f1			.pastdmark: pop af  
3a14			endm  
# End of macro DMARK
3a14						CALLMONITOR 
3a14 cd 57 17			call break_point_state  
3a17				endm  
# End of macro CALLMONITOR
3a17					endif 
3a17					 
3a17					FORTH_DSP_VALUEHL    ; upper range 
3a17 cd ab 1f			call macro_dsp_valuehl 
3a1a				endm 
# End of macro FORTH_DSP_VALUEHL
3a1a			 
3a1a 22 39 fd				ld (LFSRSeed), hl	 
3a1d			 
3a1d					if DEBUG_FORTH_WORDS 
3a1d						DMARK "RN1" 
3a1d f5				push af  
3a1e 3a 32 3a			ld a, (.dmark)  
3a21 32 b4 fe			ld (debug_mark),a  
3a24 3a 33 3a			ld a, (.dmark+1)  
3a27 32 b5 fe			ld (debug_mark+1),a  
3a2a 3a 34 3a			ld a, (.dmark+2)  
3a2d 32 b6 fe			ld (debug_mark+2),a  
3a30 18 03			jr .pastdmark  
3a32 ..			.dmark: db "RN1"  
3a35 f1			.pastdmark: pop af  
3a36			endm  
# End of macro DMARK
3a36						CALLMONITOR 
3a36 cd 57 17			call break_point_state  
3a39				endm  
# End of macro CALLMONITOR
3a39					endif 
3a39					FORTH_DSP_POP 
3a39 cd 63 20			call macro_forth_dsp_pop 
3a3c				endm 
# End of macro FORTH_DSP_POP
3a3c			 
3a3c					FORTH_DSP_VALUEHL    ; low range 
3a3c cd ab 1f			call macro_dsp_valuehl 
3a3f				endm 
# End of macro FORTH_DSP_VALUEHL
3a3f			 
3a3f					if DEBUG_FORTH_WORDS 
3a3f						DMARK "RN2" 
3a3f f5				push af  
3a40 3a 54 3a			ld a, (.dmark)  
3a43 32 b4 fe			ld (debug_mark),a  
3a46 3a 55 3a			ld a, (.dmark+1)  
3a49 32 b5 fe			ld (debug_mark+1),a  
3a4c 3a 56 3a			ld a, (.dmark+2)  
3a4f 32 b6 fe			ld (debug_mark+2),a  
3a52 18 03			jr .pastdmark  
3a54 ..			.dmark: db "RN2"  
3a57 f1			.pastdmark: pop af  
3a58			endm  
# End of macro DMARK
3a58						CALLMONITOR 
3a58 cd 57 17			call break_point_state  
3a5b				endm  
# End of macro CALLMONITOR
3a5b					endif 
3a5b 22 3b fd				ld (LFSRSeed+2), hl 
3a5e			 
3a5e					FORTH_DSP_POP 
3a5e cd 63 20			call macro_forth_dsp_pop 
3a61				endm 
# End of macro FORTH_DSP_POP
3a61			 
3a61 e5					push hl 
3a62			 
3a62 e1			.inrange:	pop hl 
3a63 cd 01 0d				call prng16  
3a66					if DEBUG_FORTH_WORDS 
3a66						DMARK "RN3" 
3a66 f5				push af  
3a67 3a 7b 3a			ld a, (.dmark)  
3a6a 32 b4 fe			ld (debug_mark),a  
3a6d 3a 7c 3a			ld a, (.dmark+1)  
3a70 32 b5 fe			ld (debug_mark+1),a  
3a73 3a 7d 3a			ld a, (.dmark+2)  
3a76 32 b6 fe			ld (debug_mark+2),a  
3a79 18 03			jr .pastdmark  
3a7b ..			.dmark: db "RN3"  
3a7e f1			.pastdmark: pop af  
3a7f			endm  
# End of macro DMARK
3a7f						CALLMONITOR 
3a7f cd 57 17			call break_point_state  
3a82				endm  
# End of macro CALLMONITOR
3a82					endif 
3a82					 
3a82					; if the range is 8bit knock out the high byte 
3a82			 
3a82 ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3a86			 
3a86 3e 00				ld a, 0 
3a88 ba					cp d  
3a89 20 1e				jr nz, .hirange 
3a8b 26 00				ld h, 0   ; knock it down to 8bit 
3a8d			 
3a8d					if DEBUG_FORTH_WORDS 
3a8d						DMARK "RNk" 
3a8d f5				push af  
3a8e 3a a2 3a			ld a, (.dmark)  
3a91 32 b4 fe			ld (debug_mark),a  
3a94 3a a3 3a			ld a, (.dmark+1)  
3a97 32 b5 fe			ld (debug_mark+1),a  
3a9a 3a a4 3a			ld a, (.dmark+2)  
3a9d 32 b6 fe			ld (debug_mark+2),a  
3aa0 18 03			jr .pastdmark  
3aa2 ..			.dmark: db "RNk"  
3aa5 f1			.pastdmark: pop af  
3aa6			endm  
# End of macro DMARK
3aa6						CALLMONITOR 
3aa6 cd 57 17			call break_point_state  
3aa9				endm  
# End of macro CALLMONITOR
3aa9					endif 
3aa9			.hirange:   
3aa9 e5					push hl  
3aaa b7					or a  
3aab ed 52		                sbc hl, de 
3aad			 
3aad					;call cmp16 
3aad			 
3aad 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3aaf e1					pop hl 
3ab0 e5					push hl 
3ab1			 
3ab1					if DEBUG_FORTH_WORDS 
3ab1						DMARK "RN4" 
3ab1 f5				push af  
3ab2 3a c6 3a			ld a, (.dmark)  
3ab5 32 b4 fe			ld (debug_mark),a  
3ab8 3a c7 3a			ld a, (.dmark+1)  
3abb 32 b5 fe			ld (debug_mark+1),a  
3abe 3a c8 3a			ld a, (.dmark+2)  
3ac1 32 b6 fe			ld (debug_mark+2),a  
3ac4 18 03			jr .pastdmark  
3ac6 ..			.dmark: db "RN4"  
3ac9 f1			.pastdmark: pop af  
3aca			endm  
# End of macro DMARK
3aca						CALLMONITOR 
3aca cd 57 17			call break_point_state  
3acd				endm  
# End of macro CALLMONITOR
3acd					endif 
3acd ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3ad1					;call cmp16 
3ad1				 
3ad1 b7					or a  
3ad2 ed 52		                sbc hl, de 
3ad4 38 8c				jr c, .inrange 
3ad6			 
3ad6 e1					pop hl 
3ad7					 
3ad7					if DEBUG_FORTH_WORDS 
3ad7						DMARK "RNd" 
3ad7 f5				push af  
3ad8 3a ec 3a			ld a, (.dmark)  
3adb 32 b4 fe			ld (debug_mark),a  
3ade 3a ed 3a			ld a, (.dmark+1)  
3ae1 32 b5 fe			ld (debug_mark+1),a  
3ae4 3a ee 3a			ld a, (.dmark+2)  
3ae7 32 b6 fe			ld (debug_mark+2),a  
3aea 18 03			jr .pastdmark  
3aec ..			.dmark: db "RNd"  
3aef f1			.pastdmark: pop af  
3af0			endm  
# End of macro DMARK
3af0						CALLMONITOR 
3af0 cd 57 17			call break_point_state  
3af3				endm  
# End of macro CALLMONITOR
3af3					endif 
3af3			 
3af3			 
3af3 cd b4 1d				call forth_push_numhl 
3af6				       NEXTW 
3af6 c3 1d 21			jp macro_next 
3af9				endm 
# End of macro NEXTW
3af9			 
3af9			.ENDMATHS: 
3af9			 
3af9			; eof 
3af9			 
# End of file forth_words_maths.asm
3af9			include "forth_words_display.asm" 
3af9			 
3af9			; | ## Display Words 
3af9			 
3af9			.INFO: 
3af9			 
3af9				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3af9 62				db WORD_SYS_CORE+78             
3afa 16 3b			dw .ATP            
3afc 05				db 4 + 1 
3afd .. 00			db "INFO",0              
3b02				endm 
# End of macro CWHEAD
3b02			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3b02					FORTH_DSP_VALUEHL 
3b02 cd ab 1f			call macro_dsp_valuehl 
3b05				endm 
# End of macro FORTH_DSP_VALUEHL
3b05			 
3b05					FORTH_DSP_POP 
3b05 cd 63 20			call macro_forth_dsp_pop 
3b08				endm 
# End of macro FORTH_DSP_POP
3b08			 
3b08 e5					push hl 
3b09			 
3b09					FORTH_DSP_VALUEHL 
3b09 cd ab 1f			call macro_dsp_valuehl 
3b0c				endm 
# End of macro FORTH_DSP_VALUEHL
3b0c			 
3b0c					FORTH_DSP_POP 
3b0c cd 63 20			call macro_forth_dsp_pop 
3b0f				endm 
# End of macro FORTH_DSP_POP
3b0f			 
3b0f d1					pop de 
3b10			 
3b10 cd 37 0b				call info_panel 
3b13			 
3b13			 
3b13					NEXTW 
3b13 c3 1d 21			jp macro_next 
3b16				endm 
# End of macro NEXTW
3b16			.ATP: 
3b16				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b16 62				db WORD_SYS_CORE+78             
3b17 8d 3b			dw .FB            
3b19 04				db 3 + 1 
3b1a .. 00			db "AT?",0              
3b1e				endm 
# End of macro CWHEAD
3b1e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b1e					if DEBUG_FORTH_WORDS_KEY 
3b1e						DMARK "AT?" 
3b1e f5				push af  
3b1f 3a 33 3b			ld a, (.dmark)  
3b22 32 b4 fe			ld (debug_mark),a  
3b25 3a 34 3b			ld a, (.dmark+1)  
3b28 32 b5 fe			ld (debug_mark+1),a  
3b2b 3a 35 3b			ld a, (.dmark+2)  
3b2e 32 b6 fe			ld (debug_mark+2),a  
3b31 18 03			jr .pastdmark  
3b33 ..			.dmark: db "AT?"  
3b36 f1			.pastdmark: pop af  
3b37			endm  
# End of macro DMARK
3b37						CALLMONITOR 
3b37 cd 57 17			call break_point_state  
3b3a				endm  
# End of macro CALLMONITOR
3b3a					endif 
3b3a 3a c3 fc				ld a, (f_cursor_ptr) 
3b3d			 
3b3d			if DEBUG_FORTH_WORDS 
3b3d				DMARK "AT?" 
3b3d f5				push af  
3b3e 3a 52 3b			ld a, (.dmark)  
3b41 32 b4 fe			ld (debug_mark),a  
3b44 3a 53 3b			ld a, (.dmark+1)  
3b47 32 b5 fe			ld (debug_mark+1),a  
3b4a 3a 54 3b			ld a, (.dmark+2)  
3b4d 32 b6 fe			ld (debug_mark+2),a  
3b50 18 03			jr .pastdmark  
3b52 ..			.dmark: db "AT?"  
3b55 f1			.pastdmark: pop af  
3b56			endm  
# End of macro DMARK
3b56				CALLMONITOR 
3b56 cd 57 17			call break_point_state  
3b59				endm  
# End of macro CALLMONITOR
3b59			endif	 
3b59					; count the number of rows 
3b59			 
3b59 06 00				ld b, 0 
3b5b 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b5c d6 14				sub display_cols 
3b5e f2 64 3b				jp p, .atprunder 
3b61 04					inc b 
3b62 18 f7				jr .atpr 
3b64			.atprunder:	 
3b64			if DEBUG_FORTH_WORDS 
3b64				DMARK "A?2" 
3b64 f5				push af  
3b65 3a 79 3b			ld a, (.dmark)  
3b68 32 b4 fe			ld (debug_mark),a  
3b6b 3a 7a 3b			ld a, (.dmark+1)  
3b6e 32 b5 fe			ld (debug_mark+1),a  
3b71 3a 7b 3b			ld a, (.dmark+2)  
3b74 32 b6 fe			ld (debug_mark+2),a  
3b77 18 03			jr .pastdmark  
3b79 ..			.dmark: db "A?2"  
3b7c f1			.pastdmark: pop af  
3b7d			endm  
# End of macro DMARK
3b7d				CALLMONITOR 
3b7d cd 57 17			call break_point_state  
3b80				endm  
# End of macro CALLMONITOR
3b80			endif	 
3b80 26 00				ld h, 0 
3b82 69					ld l, c 
3b83 cd b4 1d				call forth_push_numhl 
3b86 68					ld l, b  
3b87 cd b4 1d				call forth_push_numhl 
3b8a			 
3b8a			 
3b8a				NEXTW 
3b8a c3 1d 21			jp macro_next 
3b8d				endm 
# End of macro NEXTW
3b8d			 
3b8d			.FB: 
3b8d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b8d 1b				db WORD_SYS_CORE+7             
3b8e db 3b			dw .EMIT            
3b90 03				db 2 + 1 
3b91 .. 00			db "FB",0              
3b94				endm 
# End of macro CWHEAD
3b94			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b94			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b94			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b94			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b94					if DEBUG_FORTH_WORDS_KEY 
3b94						DMARK "FB." 
3b94 f5				push af  
3b95 3a a9 3b			ld a, (.dmark)  
3b98 32 b4 fe			ld (debug_mark),a  
3b9b 3a aa 3b			ld a, (.dmark+1)  
3b9e 32 b5 fe			ld (debug_mark+1),a  
3ba1 3a ab 3b			ld a, (.dmark+2)  
3ba4 32 b6 fe			ld (debug_mark+2),a  
3ba7 18 03			jr .pastdmark  
3ba9 ..			.dmark: db "FB."  
3bac f1			.pastdmark: pop af  
3bad			endm  
# End of macro DMARK
3bad						CALLMONITOR 
3bad cd 57 17			call break_point_state  
3bb0				endm  
# End of macro CALLMONITOR
3bb0					endif 
3bb0			 
3bb0					FORTH_DSP_VALUEHL 
3bb0 cd ab 1f			call macro_dsp_valuehl 
3bb3				endm 
# End of macro FORTH_DSP_VALUEHL
3bb3			 
3bb3 7d					ld a, l 
3bb4 fe 01				cp 1 
3bb6 20 05				jr nz, .fbn1 
3bb8 21 f9 fd				ld hl, display_fb1 
3bbb 18 15				jr .fbset 
3bbd fe 02		.fbn1:		cp 2 
3bbf 20 05				jr nz, .fbn2 
3bc1 21 57 fd				ld hl, display_fb2 
3bc4 18 0c				jr .fbset 
3bc6 fe 03		.fbn2:		cp 3 
3bc8 20 05				jr nz, .fbn3 
3bca 21 a8 fd				ld hl, display_fb3 
3bcd 18 03				jr .fbset 
3bcf			.fbn3:		 ; if invalid number select first 
3bcf 21 f9 fd				ld hl, display_fb1 
3bd2 22 55 fd		.fbset:		ld (display_fb_active), hl 
3bd5			 
3bd5					FORTH_DSP_POP 
3bd5 cd 63 20			call macro_forth_dsp_pop 
3bd8				endm 
# End of macro FORTH_DSP_POP
3bd8			 
3bd8					NEXTW 
3bd8 c3 1d 21			jp macro_next 
3bdb				endm 
# End of macro NEXTW
3bdb			 
3bdb			 
3bdb			.EMIT: 
3bdb				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3bdb 1b				db WORD_SYS_CORE+7             
3bdc 2c 3c			dw .DOTH            
3bde 05				db 4 + 1 
3bdf .. 00			db "EMIT",0              
3be4				endm 
# End of macro CWHEAD
3be4			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3be4					; get value off TOS and display it 
3be4			 
3be4					if DEBUG_FORTH_WORDS_KEY 
3be4						DMARK "EMT" 
3be4 f5				push af  
3be5 3a f9 3b			ld a, (.dmark)  
3be8 32 b4 fe			ld (debug_mark),a  
3beb 3a fa 3b			ld a, (.dmark+1)  
3bee 32 b5 fe			ld (debug_mark+1),a  
3bf1 3a fb 3b			ld a, (.dmark+2)  
3bf4 32 b6 fe			ld (debug_mark+2),a  
3bf7 18 03			jr .pastdmark  
3bf9 ..			.dmark: db "EMT"  
3bfc f1			.pastdmark: pop af  
3bfd			endm  
# End of macro DMARK
3bfd						CALLMONITOR 
3bfd cd 57 17			call break_point_state  
3c00				endm  
# End of macro CALLMONITOR
3c00					endif 
3c00			 
3c00					FORTH_DSP_VALUEHL 
3c00 cd ab 1f			call macro_dsp_valuehl 
3c03				endm 
# End of macro FORTH_DSP_VALUEHL
3c03			 
3c03 7d					ld a,l 
3c04			 
3c04					; TODO write to display 
3c04			 
3c04 32 58 f6				ld (os_input), a 
3c07 3e 00				ld a, 0 
3c09 32 59 f6				ld (os_input+1), a 
3c0c					 
3c0c 3a c3 fc				ld a, (f_cursor_ptr) 
3c0f 11 58 f6				ld de, os_input 
3c12 cd b9 0b				call str_at_display 
3c15			 
3c15			 
3c15 3a a1 fc				ld a,(cli_autodisplay) 
3c18 fe 00				cp 0 
3c1a 28 03				jr z, .enoupdate 
3c1c cd c9 0b						call update_display 
3c1f					.enoupdate: 
3c1f			 
3c1f 3a c3 fc				ld a, (f_cursor_ptr) 
3c22 3c					inc a 
3c23 32 c3 fc				ld (f_cursor_ptr), a   ; save new pos 
3c26			 
3c26			 
3c26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c26 cd 63 20			call macro_forth_dsp_pop 
3c29				endm 
# End of macro FORTH_DSP_POP
3c29			  
3c29			 
3c29					NEXTW 
3c29 c3 1d 21			jp macro_next 
3c2c				endm 
# End of macro NEXTW
3c2c			.DOTH: 
3c2c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c2c 1c				db WORD_SYS_CORE+8             
3c2d 5c 3c			dw .DOTF            
3c2f 03				db 2 + 1 
3c30 .. 00			db ".-",0              
3c33				endm 
# End of macro CWHEAD
3c33			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c33					; get value off TOS and display it 
3c33					if DEBUG_FORTH_WORDS_KEY 
3c33						DMARK "DTD" 
3c33 f5				push af  
3c34 3a 48 3c			ld a, (.dmark)  
3c37 32 b4 fe			ld (debug_mark),a  
3c3a 3a 49 3c			ld a, (.dmark+1)  
3c3d 32 b5 fe			ld (debug_mark+1),a  
3c40 3a 4a 3c			ld a, (.dmark+2)  
3c43 32 b6 fe			ld (debug_mark+2),a  
3c46 18 03			jr .pastdmark  
3c48 ..			.dmark: db "DTD"  
3c4b f1			.pastdmark: pop af  
3c4c			endm  
# End of macro DMARK
3c4c						CALLMONITOR 
3c4c cd 57 17			call break_point_state  
3c4f				endm  
# End of macro CALLMONITOR
3c4f					endif 
3c4f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c51 3e 00			ld a, 0 
3c53 32 a2 fc			ld (cli_mvdot), a 
3c56 c3 b3 3c			jp .dotgo 
3c59				NEXTW 
3c59 c3 1d 21			jp macro_next 
3c5c				endm 
# End of macro NEXTW
3c5c			.DOTF: 
3c5c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c5c 1c				db WORD_SYS_CORE+8             
3c5d 8a 3c			dw .DOT            
3c5f 03				db 2 + 1 
3c60 .. 00			db ".>",0              
3c63				endm 
# End of macro CWHEAD
3c63			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c63					; get value off TOS and display it 
3c63			        ; TODO BUG adds extra spaces 
3c63			        ; TODO BUG handle numerics? 
3c63					if DEBUG_FORTH_WORDS_KEY 
3c63						DMARK "DTC" 
3c63 f5				push af  
3c64 3a 78 3c			ld a, (.dmark)  
3c67 32 b4 fe			ld (debug_mark),a  
3c6a 3a 79 3c			ld a, (.dmark+1)  
3c6d 32 b5 fe			ld (debug_mark+1),a  
3c70 3a 7a 3c			ld a, (.dmark+2)  
3c73 32 b6 fe			ld (debug_mark+2),a  
3c76 18 03			jr .pastdmark  
3c78 ..			.dmark: db "DTC"  
3c7b f1			.pastdmark: pop af  
3c7c			endm  
# End of macro DMARK
3c7c						CALLMONITOR 
3c7c cd 57 17			call break_point_state  
3c7f				endm  
# End of macro CALLMONITOR
3c7f					endif 
3c7f 3e 01			ld a, 1 
3c81 32 a2 fc			ld (cli_mvdot), a 
3c84 c3 b3 3c			jp .dotgo 
3c87				NEXTW 
3c87 c3 1d 21			jp macro_next 
3c8a				endm 
# End of macro NEXTW
3c8a			 
3c8a			.DOT: 
3c8a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c8a 1c				db WORD_SYS_CORE+8             
3c8b 16 3d			dw .CLS            
3c8d 02				db 1 + 1 
3c8e .. 00			db ".",0              
3c90				endm 
# End of macro CWHEAD
3c90			        ; | . ( u -- ) Display TOS | DONE 
3c90					; get value off TOS and display it 
3c90			 
3c90					if DEBUG_FORTH_WORDS_KEY 
3c90						DMARK "DOT" 
3c90 f5				push af  
3c91 3a a5 3c			ld a, (.dmark)  
3c94 32 b4 fe			ld (debug_mark),a  
3c97 3a a6 3c			ld a, (.dmark+1)  
3c9a 32 b5 fe			ld (debug_mark+1),a  
3c9d 3a a7 3c			ld a, (.dmark+2)  
3ca0 32 b6 fe			ld (debug_mark+2),a  
3ca3 18 03			jr .pastdmark  
3ca5 ..			.dmark: db "DOT"  
3ca8 f1			.pastdmark: pop af  
3ca9			endm  
# End of macro DMARK
3ca9						CALLMONITOR 
3ca9 cd 57 17			call break_point_state  
3cac				endm  
# End of macro CALLMONITOR
3cac					endif 
3cac 3e 00			ld a, 0 
3cae 32 a2 fc			ld (cli_mvdot), a 
3cb1 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3cb3				 
3cb3			 
3cb3			.dotgo: 
3cb3			 
3cb3			; move up type to on stack for parserv5 
3cb3					FORTH_DSP 
3cb3 cd 71 1f			call macro_forth_dsp 
3cb6				endm 
# End of macro FORTH_DSP
3cb6				;FORTH_DSP_VALUE  
3cb6			 
3cb6			if DEBUG_FORTH_DOT 
3cb6				DMARK "DOT" 
3cb6				CALLMONITOR 
3cb6			endif	 
3cb6			;		.print: 
3cb6			 
3cb6 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3cb7 23				inc hl   ; position to the actual value 
3cb8 fe 01			cp DS_TYPE_STR 
3cba 20 06			jr nz, .dotnum1  
3cbc			 
3cbc			; display string 
3cbc				FORTH_DSP_VALUE  
3cbc cd 94 1f			call macro_forth_dsp_value 
3cbf				endm 
# End of macro FORTH_DSP_VALUE
3cbf eb				ex de,hl 
3cc0 18 11			jr .dotwrite 
3cc2			 
3cc2			.dotnum1: 
3cc2 fe 02			cp DS_TYPE_INUM 
3cc4 20 0c			jr nz, .dotflot 
3cc6			 
3cc6			 
3cc6			; display number 
3cc6			 
3cc6			;	push hl 
3cc6			;	call clear_display 
3cc6			;	pop hl 
3cc6			 
3cc6 5e				ld e, (hl) 
3cc7 23				inc hl 
3cc8 56				ld d, (hl) 
3cc9 21 5a f4			ld hl, scratch 
3ccc			if DEBUG_FORTH_DOT 
3ccc				DMARK "DT1" 
3ccc				CALLMONITOR 
3ccc			endif	 
3ccc			 
3ccc cd e7 11			call uitoa_16 
3ccf eb				ex de,hl 
3cd0			 
3cd0			if DEBUG_FORTH_DOT 
3cd0				DMARK "DT2" 
3cd0				CALLMONITOR 
3cd0			endif	 
3cd0			 
3cd0			;	ld de, os_word_scratch 
3cd0 18 01			jr .dotwrite 
3cd2			 
3cd2 00			.dotflot:   nop 
3cd3			; TODO print floating point number 
3cd3			 
3cd3			.dotwrite:		 
3cd3			 
3cd3					; if c is set then set all '-' to spaces 
3cd3					; need to also take into account .>  
3cd3			 
3cd3 3e 01				ld a, 1 
3cd5 b9					cp c 
3cd6 20 13				jr nz, .nodashswap 
3cd8			 
3cd8					; DE has the string to write, working with HL 
3cd8			 
3cd8 06 ff				ld b, 255 
3cda d5					push de 
3cdb e1					pop hl 
3cdc			 
3cdc			if DEBUG_FORTH_DOT 
3cdc				DMARK "DT-" 
3cdc				CALLMONITOR 
3cdc			endif	 
3cdc 7e			.dashscan:	ld a, (hl) 
3cdd fe 00				cp 0 
3cdf 28 0a				jr z, .nodashswap 
3ce1 fe 2d				cp '-' 
3ce3 20 03				jr nz, .dashskip 
3ce5 3e 20				ld a, ' ' 
3ce7 77					ld (hl), a 
3ce8 23			.dashskip:	inc hl 
3ce9			if DEBUG_FORTH_DOT 
3ce9				DMARK "D-2" 
3ce9				CALLMONITOR 
3ce9			endif	 
3ce9 10 f1				djnz .dashscan 
3ceb			 
3ceb			if DEBUG_FORTH_DOT 
3ceb				DMARK "D-1" 
3ceb				CALLMONITOR 
3ceb			endif	 
3ceb			 
3ceb			.nodashswap: 
3ceb			 
3ceb e5					push hl   ; save string start in case we need to advance print 
3cec			 
3cec 3a c3 fc				ld a, (f_cursor_ptr) 
3cef cd b9 0b				call str_at_display 
3cf2 3a a1 fc				ld a,(cli_autodisplay) 
3cf5 fe 00				cp 0 
3cf7 28 03				jr z, .noupdate 
3cf9 cd c9 0b						call update_display 
3cfc					.noupdate: 
3cfc			 
3cfc			 
3cfc					; see if we need to advance the print position 
3cfc			 
3cfc e1					pop hl   ; get back string 
3cfd			 
3cfd 3a a2 fc				ld a, (cli_mvdot) 
3d00			if DEBUG_FORTH_DOT 
3d00					ld e,a 
3d00				DMARK "D>1" 
3d00				CALLMONITOR 
3d00			endif	 
3d00 fe 00				cp 0 
3d02 28 0c				jr z, .noadv 
3d04					; yes, lets advance the print position 
3d04 3e 00				ld a, 0 
3d06 cd 43 12				call strlent 
3d09 3a c3 fc				ld a, (f_cursor_ptr) 
3d0c 85					add a,l 
3d0d					;call addatohl 
3d0d					;ld a, l 
3d0d 32 c3 fc				ld (f_cursor_ptr), a   ; save new pos 
3d10			 
3d10			if DEBUG_FORTH_DOT 
3d10				DMARK "D->" 
3d10				CALLMONITOR 
3d10			endif	 
3d10			 
3d10			.noadv:	 
3d10			 
3d10					if DEBUG_FORTH_DOT_WAIT 
3d10							call next_page_prompt 
3d10					endif	 
3d10			; TODO this pop off the stack causes a crash. i dont know why 
3d10			 
3d10			 
3d10			if DEBUG_FORTH_DOT 
3d10				DMARK "DTh" 
3d10				CALLMONITOR 
3d10			endif	 
3d10			 
3d10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d10 cd 63 20			call macro_forth_dsp_pop 
3d13				endm 
# End of macro FORTH_DSP_POP
3d13			 
3d13			if DEBUG_FORTH_DOT 
3d13				DMARK "DTi" 
3d13				CALLMONITOR 
3d13			endif	 
3d13			 
3d13			 
3d13					NEXTW 
3d13 c3 1d 21			jp macro_next 
3d16				endm 
# End of macro NEXTW
3d16			 
3d16			.CLS: 
3d16				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d16 35				db WORD_SYS_CORE+33             
3d17 43 3d			dw .DRAW            
3d19 04				db 3 + 1 
3d1a .. 00			db "CLS",0              
3d1e				endm 
# End of macro CWHEAD
3d1e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d1e					if DEBUG_FORTH_WORDS_KEY 
3d1e						DMARK "CLS" 
3d1e f5				push af  
3d1f 3a 33 3d			ld a, (.dmark)  
3d22 32 b4 fe			ld (debug_mark),a  
3d25 3a 34 3d			ld a, (.dmark+1)  
3d28 32 b5 fe			ld (debug_mark+1),a  
3d2b 3a 35 3d			ld a, (.dmark+2)  
3d2e 32 b6 fe			ld (debug_mark+2),a  
3d31 18 03			jr .pastdmark  
3d33 ..			.dmark: db "CLS"  
3d36 f1			.pastdmark: pop af  
3d37			endm  
# End of macro DMARK
3d37						CALLMONITOR 
3d37 cd 57 17			call break_point_state  
3d3a				endm  
# End of macro CALLMONITOR
3d3a					endif 
3d3a cd a6 0b				call clear_display 
3d3d c3 51 3e				jp .home		; and home cursor 
3d40					NEXTW 
3d40 c3 1d 21			jp macro_next 
3d43				endm 
# End of macro NEXTW
3d43			 
3d43			.DRAW: 
3d43				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d43 36				db WORD_SYS_CORE+34             
3d44 6e 3d			dw .DUMP            
3d46 05				db 4 + 1 
3d47 .. 00			db "DRAW",0              
3d4c				endm 
# End of macro CWHEAD
3d4c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3d4c					if DEBUG_FORTH_WORDS_KEY 
3d4c						DMARK "DRW" 
3d4c f5				push af  
3d4d 3a 61 3d			ld a, (.dmark)  
3d50 32 b4 fe			ld (debug_mark),a  
3d53 3a 62 3d			ld a, (.dmark+1)  
3d56 32 b5 fe			ld (debug_mark+1),a  
3d59 3a 63 3d			ld a, (.dmark+2)  
3d5c 32 b6 fe			ld (debug_mark+2),a  
3d5f 18 03			jr .pastdmark  
3d61 ..			.dmark: db "DRW"  
3d64 f1			.pastdmark: pop af  
3d65			endm  
# End of macro DMARK
3d65						CALLMONITOR 
3d65 cd 57 17			call break_point_state  
3d68				endm  
# End of macro CALLMONITOR
3d68					endif 
3d68 cd c9 0b				call update_display 
3d6b					NEXTW 
3d6b c3 1d 21			jp macro_next 
3d6e				endm 
# End of macro NEXTW
3d6e			 
3d6e			.DUMP: 
3d6e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d6e 37				db WORD_SYS_CORE+35             
3d6f a6 3d			dw .CDUMP            
3d71 05				db 4 + 1 
3d72 .. 00			db "DUMP",0              
3d77				endm 
# End of macro CWHEAD
3d77			; | DUMP ( x -- ) With address x display dump   | DONE 
3d77			; TODO pop address to use off of the stack 
3d77					if DEBUG_FORTH_WORDS_KEY 
3d77						DMARK "DUM" 
3d77 f5				push af  
3d78 3a 8c 3d			ld a, (.dmark)  
3d7b 32 b4 fe			ld (debug_mark),a  
3d7e 3a 8d 3d			ld a, (.dmark+1)  
3d81 32 b5 fe			ld (debug_mark+1),a  
3d84 3a 8e 3d			ld a, (.dmark+2)  
3d87 32 b6 fe			ld (debug_mark+2),a  
3d8a 18 03			jr .pastdmark  
3d8c ..			.dmark: db "DUM"  
3d8f f1			.pastdmark: pop af  
3d90			endm  
# End of macro DMARK
3d90						CALLMONITOR 
3d90 cd 57 17			call break_point_state  
3d93				endm  
# End of macro CALLMONITOR
3d93					endif 
3d93 cd a6 0b				call clear_display 
3d96			 
3d96					; get address 
3d96			 
3d96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d96 cd ab 1f			call macro_dsp_valuehl 
3d99				endm 
# End of macro FORTH_DSP_VALUEHL
3d99				 
3d99					; save it for cdump 
3d99			 
3d99 22 7d f7				ld (os_cur_ptr),hl 
3d9c			 
3d9c					; destroy value TOS 
3d9c			 
3d9c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d9c cd 63 20			call macro_forth_dsp_pop 
3d9f				endm 
# End of macro FORTH_DSP_POP
3d9f			 
3d9f cd 34 1c				call dumpcont	; skip old style of param parsing	 
3da2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3da3					NEXTW 
3da3 c3 1d 21			jp macro_next 
3da6				endm 
# End of macro NEXTW
3da6			.CDUMP: 
3da6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3da6 38				db WORD_SYS_CORE+36             
3da7 d6 3d			dw .DAT            
3da9 06				db 5 + 1 
3daa .. 00			db "CDUMP",0              
3db0				endm 
# End of macro CWHEAD
3db0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3db0					if DEBUG_FORTH_WORDS_KEY 
3db0						DMARK "CDP" 
3db0 f5				push af  
3db1 3a c5 3d			ld a, (.dmark)  
3db4 32 b4 fe			ld (debug_mark),a  
3db7 3a c6 3d			ld a, (.dmark+1)  
3dba 32 b5 fe			ld (debug_mark+1),a  
3dbd 3a c7 3d			ld a, (.dmark+2)  
3dc0 32 b6 fe			ld (debug_mark+2),a  
3dc3 18 03			jr .pastdmark  
3dc5 ..			.dmark: db "CDP"  
3dc8 f1			.pastdmark: pop af  
3dc9			endm  
# End of macro DMARK
3dc9						CALLMONITOR 
3dc9 cd 57 17			call break_point_state  
3dcc				endm  
# End of macro CALLMONITOR
3dcc					endif 
3dcc cd a6 0b				call clear_display 
3dcf cd 34 1c				call dumpcont	 
3dd2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3dd3					NEXTW 
3dd3 c3 1d 21			jp macro_next 
3dd6				endm 
# End of macro NEXTW
3dd6			 
3dd6			 
3dd6			 
3dd6			 
3dd6			.DAT: 
3dd6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3dd6 3d				db WORD_SYS_CORE+41             
3dd7 2c 3e			dw .HOME            
3dd9 03				db 2 + 1 
3dda .. 00			db "AT",0              
3ddd				endm 
# End of macro CWHEAD
3ddd			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3ddd					if DEBUG_FORTH_WORDS_KEY 
3ddd						DMARK "AT." 
3ddd f5				push af  
3dde 3a f2 3d			ld a, (.dmark)  
3de1 32 b4 fe			ld (debug_mark),a  
3de4 3a f3 3d			ld a, (.dmark+1)  
3de7 32 b5 fe			ld (debug_mark+1),a  
3dea 3a f4 3d			ld a, (.dmark+2)  
3ded 32 b6 fe			ld (debug_mark+2),a  
3df0 18 03			jr .pastdmark  
3df2 ..			.dmark: db "AT."  
3df5 f1			.pastdmark: pop af  
3df6			endm  
# End of macro DMARK
3df6						CALLMONITOR 
3df6 cd 57 17			call break_point_state  
3df9				endm  
# End of macro CALLMONITOR
3df9					endif 
3df9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3df9 cd ab 1f			call macro_dsp_valuehl 
3dfc				endm 
# End of macro FORTH_DSP_VALUEHL
3dfc			 
3dfc			 
3dfc					; TODO save cursor row 
3dfc 7d					ld a,l 
3dfd fe 02				cp 2 
3dff 20 04				jr nz, .crow3 
3e01 3e 14				ld a, display_row_2 
3e03 18 12				jr .ccol1 
3e05 fe 03		.crow3:		cp 3 
3e07 20 04				jr nz, .crow4 
3e09 3e 28				ld a, display_row_3 
3e0b 18 0a				jr .ccol1 
3e0d fe 04		.crow4:		cp 4 
3e0f 20 04				jr nz, .crow1 
3e11 3e 3c				ld a, display_row_4 
3e13 18 02				jr .ccol1 
3e15 3e 00		.crow1:		ld a,display_row_1 
3e17 f5			.ccol1:		push af			; got row offset 
3e18 6f					ld l,a 
3e19 26 00				ld h,0 
3e1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e1b cd 63 20			call macro_forth_dsp_pop 
3e1e				endm 
# End of macro FORTH_DSP_POP
3e1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e1e cd ab 1f			call macro_dsp_valuehl 
3e21				endm 
# End of macro FORTH_DSP_VALUEHL
3e21					; TODO save cursor col 
3e21 f1					pop af 
3e22 85					add l		; add col offset 
3e23 32 c3 fc				ld (f_cursor_ptr), a 
3e26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e26 cd 63 20			call macro_forth_dsp_pop 
3e29				endm 
# End of macro FORTH_DSP_POP
3e29			 
3e29					; calculate  
3e29			 
3e29					NEXTW 
3e29 c3 1d 21			jp macro_next 
3e2c				endm 
# End of macro NEXTW
3e2c			 
3e2c			 
3e2c			.HOME: 
3e2c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e2c 41				db WORD_SYS_CORE+45             
3e2d 59 3e			dw .SPACE            
3e2f 05				db 4 + 1 
3e30 .. 00			db "HOME",0              
3e35				endm 
# End of macro CWHEAD
3e35			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e35					if DEBUG_FORTH_WORDS_KEY 
3e35						DMARK "HOM" 
3e35 f5				push af  
3e36 3a 4a 3e			ld a, (.dmark)  
3e39 32 b4 fe			ld (debug_mark),a  
3e3c 3a 4b 3e			ld a, (.dmark+1)  
3e3f 32 b5 fe			ld (debug_mark+1),a  
3e42 3a 4c 3e			ld a, (.dmark+2)  
3e45 32 b6 fe			ld (debug_mark+2),a  
3e48 18 03			jr .pastdmark  
3e4a ..			.dmark: db "HOM"  
3e4d f1			.pastdmark: pop af  
3e4e			endm  
# End of macro DMARK
3e4e						CALLMONITOR 
3e4e cd 57 17			call break_point_state  
3e51				endm  
# End of macro CALLMONITOR
3e51					endif 
3e51 3e 00		.home:		ld a, 0		; and home cursor 
3e53 32 c3 fc				ld (f_cursor_ptr), a 
3e56					NEXTW 
3e56 c3 1d 21			jp macro_next 
3e59				endm 
# End of macro NEXTW
3e59			 
3e59			 
3e59			.SPACE: 
3e59				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3e59 46				db WORD_SYS_CORE+50             
3e5a 87 3e			dw .SPACES            
3e5c 03				db 2 + 1 
3e5d .. 00			db "BL",0              
3e60				endm 
# End of macro CWHEAD
3e60			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3e60					if DEBUG_FORTH_WORDS_KEY 
3e60						DMARK "BL." 
3e60 f5				push af  
3e61 3a 75 3e			ld a, (.dmark)  
3e64 32 b4 fe			ld (debug_mark),a  
3e67 3a 76 3e			ld a, (.dmark+1)  
3e6a 32 b5 fe			ld (debug_mark+1),a  
3e6d 3a 77 3e			ld a, (.dmark+2)  
3e70 32 b6 fe			ld (debug_mark+2),a  
3e73 18 03			jr .pastdmark  
3e75 ..			.dmark: db "BL."  
3e78 f1			.pastdmark: pop af  
3e79			endm  
# End of macro DMARK
3e79						CALLMONITOR 
3e79 cd 57 17			call break_point_state  
3e7c				endm  
# End of macro CALLMONITOR
3e7c					endif 
3e7c 21 85 3e				ld hl, .blstr 
3e7f cd 22 1e				call forth_push_str 
3e82					 
3e82				       NEXTW 
3e82 c3 1d 21			jp macro_next 
3e85				endm 
# End of macro NEXTW
3e85			 
3e85 .. 00		.blstr: db " ", 0 
3e87			 
3e87			.SPACES: 
3e87				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3e87 47				db WORD_SYS_CORE+51             
3e88 22 3f			dw .SCROLL            
3e8a 07				db 6 + 1 
3e8b .. 00			db "SPACES",0              
3e92				endm 
# End of macro CWHEAD
3e92			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3e92					if DEBUG_FORTH_WORDS_KEY 
3e92						DMARK "SPS" 
3e92 f5				push af  
3e93 3a a7 3e			ld a, (.dmark)  
3e96 32 b4 fe			ld (debug_mark),a  
3e99 3a a8 3e			ld a, (.dmark+1)  
3e9c 32 b5 fe			ld (debug_mark+1),a  
3e9f 3a a9 3e			ld a, (.dmark+2)  
3ea2 32 b6 fe			ld (debug_mark+2),a  
3ea5 18 03			jr .pastdmark  
3ea7 ..			.dmark: db "SPS"  
3eaa f1			.pastdmark: pop af  
3eab			endm  
# End of macro DMARK
3eab						CALLMONITOR 
3eab cd 57 17			call break_point_state  
3eae				endm  
# End of macro CALLMONITOR
3eae					endif 
3eae			 
3eae			 
3eae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eae cd ab 1f			call macro_dsp_valuehl 
3eb1				endm 
# End of macro FORTH_DSP_VALUEHL
3eb1			 
3eb1			;		push hl    ; u 
3eb1					if DEBUG_FORTH_WORDS 
3eb1						DMARK "SPA" 
3eb1 f5				push af  
3eb2 3a c6 3e			ld a, (.dmark)  
3eb5 32 b4 fe			ld (debug_mark),a  
3eb8 3a c7 3e			ld a, (.dmark+1)  
3ebb 32 b5 fe			ld (debug_mark+1),a  
3ebe 3a c8 3e			ld a, (.dmark+2)  
3ec1 32 b6 fe			ld (debug_mark+2),a  
3ec4 18 03			jr .pastdmark  
3ec6 ..			.dmark: db "SPA"  
3ec9 f1			.pastdmark: pop af  
3eca			endm  
# End of macro DMARK
3eca						CALLMONITOR 
3eca cd 57 17			call break_point_state  
3ecd				endm  
# End of macro CALLMONITOR
3ecd					endif 
3ecd			 
3ecd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ecd cd 63 20			call macro_forth_dsp_pop 
3ed0				endm 
# End of macro FORTH_DSP_POP
3ed0			;		pop hl 
3ed0 4d					ld c, l 
3ed1 06 00				ld b, 0 
3ed3 21 5a f4				ld hl, scratch  
3ed6			 
3ed6					if DEBUG_FORTH_WORDS 
3ed6						DMARK "SP2" 
3ed6 f5				push af  
3ed7 3a eb 3e			ld a, (.dmark)  
3eda 32 b4 fe			ld (debug_mark),a  
3edd 3a ec 3e			ld a, (.dmark+1)  
3ee0 32 b5 fe			ld (debug_mark+1),a  
3ee3 3a ed 3e			ld a, (.dmark+2)  
3ee6 32 b6 fe			ld (debug_mark+2),a  
3ee9 18 03			jr .pastdmark  
3eeb ..			.dmark: db "SP2"  
3eee f1			.pastdmark: pop af  
3eef			endm  
# End of macro DMARK
3eef						CALLMONITOR 
3eef cd 57 17			call break_point_state  
3ef2				endm  
# End of macro CALLMONITOR
3ef2					endif 
3ef2 3e 20				ld a, ' ' 
3ef4 c5			.spaces1:	push bc 
3ef5 77					ld (hl),a 
3ef6 23					inc hl 
3ef7 c1					pop bc 
3ef8 10 fa				djnz .spaces1 
3efa 3e 00				ld a,0 
3efc 77					ld (hl),a 
3efd 21 5a f4				ld hl, scratch 
3f00					if DEBUG_FORTH_WORDS 
3f00						DMARK "SP3" 
3f00 f5				push af  
3f01 3a 15 3f			ld a, (.dmark)  
3f04 32 b4 fe			ld (debug_mark),a  
3f07 3a 16 3f			ld a, (.dmark+1)  
3f0a 32 b5 fe			ld (debug_mark+1),a  
3f0d 3a 17 3f			ld a, (.dmark+2)  
3f10 32 b6 fe			ld (debug_mark+2),a  
3f13 18 03			jr .pastdmark  
3f15 ..			.dmark: db "SP3"  
3f18 f1			.pastdmark: pop af  
3f19			endm  
# End of macro DMARK
3f19						CALLMONITOR 
3f19 cd 57 17			call break_point_state  
3f1c				endm  
# End of macro CALLMONITOR
3f1c					endif 
3f1c cd 1d 1f				call forth_apush 
3f1f			 
3f1f				       NEXTW 
3f1f c3 1d 21			jp macro_next 
3f22				endm 
# End of macro NEXTW
3f22			 
3f22			 
3f22			 
3f22			.SCROLL: 
3f22				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f22 53				db WORD_SYS_CORE+63             
3f23 4f 3f			dw .SCROLLD            
3f25 07				db 6 + 1 
3f26 .. 00			db "SCROLL",0              
3f2d				endm 
# End of macro CWHEAD
3f2d			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f2d					if DEBUG_FORTH_WORDS_KEY 
3f2d						DMARK "SCR" 
3f2d f5				push af  
3f2e 3a 42 3f			ld a, (.dmark)  
3f31 32 b4 fe			ld (debug_mark),a  
3f34 3a 43 3f			ld a, (.dmark+1)  
3f37 32 b5 fe			ld (debug_mark+1),a  
3f3a 3a 44 3f			ld a, (.dmark+2)  
3f3d 32 b6 fe			ld (debug_mark+2),a  
3f40 18 03			jr .pastdmark  
3f42 ..			.dmark: db "SCR"  
3f45 f1			.pastdmark: pop af  
3f46			endm  
# End of macro DMARK
3f46						CALLMONITOR 
3f46 cd 57 17			call break_point_state  
3f49				endm  
# End of macro CALLMONITOR
3f49					endif 
3f49			 
3f49 cd 68 0b			call scroll_up 
3f4c			;	call update_display 
3f4c			 
3f4c					NEXTW 
3f4c c3 1d 21			jp macro_next 
3f4f				endm 
# End of macro NEXTW
3f4f			 
3f4f			 
3f4f			 
3f4f			;		; get dir 
3f4f			; 
3f4f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f4f			; 
3f4f			;		push hl 
3f4f			; 
3f4f			;		; destroy value TOS 
3f4f			; 
3f4f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f4f			; 
3f4f			;		; get count 
3f4f			; 
3f4f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f4f			; 
3f4f			;		push hl 
3f4f			; 
3f4f			;		; destroy value TOS 
3f4f			; 
3f4f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f4f			; 
3f4f			;		; one value on hl get other one back 
3f4f			; 
3f4f			;		pop bc    ; count 
3f4f			; 
3f4f			;		pop de   ; dir 
3f4f			; 
3f4f			; 
3f4f			;		ld b, c 
3f4f			; 
3f4f			;.scrolldir:     push bc 
3f4f			;		push de 
3f4f			; 
3f4f			;		ld a, 0 
3f4f			;		cp e 
3f4f			;		jr z, .scrollup  
3f4f			;		call scroll_down 
3f4f			;		jr .scrollnext 
3f4f			;.scrollup:	call scroll_up 
3f4f			; 
3f4f			;		 
3f4f			;.scrollnext: 
3f4f			;		pop de 
3f4f			;		pop bc 
3f4f			;		djnz .scrolldir 
3f4f			; 
3f4f			; 
3f4f			; 
3f4f			; 
3f4f			; 
3f4f			;		NEXTW 
3f4f			 
3f4f			.SCROLLD: 
3f4f				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3f4f 53				db WORD_SYS_CORE+63             
3f50 7d 3f			dw .ATQ            
3f52 08				db 7 + 1 
3f53 .. 00			db "SCROLLD",0              
3f5b				endm 
# End of macro CWHEAD
3f5b			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3f5b					if DEBUG_FORTH_WORDS_KEY 
3f5b						DMARK "SCD" 
3f5b f5				push af  
3f5c 3a 70 3f			ld a, (.dmark)  
3f5f 32 b4 fe			ld (debug_mark),a  
3f62 3a 71 3f			ld a, (.dmark+1)  
3f65 32 b5 fe			ld (debug_mark+1),a  
3f68 3a 72 3f			ld a, (.dmark+2)  
3f6b 32 b6 fe			ld (debug_mark+2),a  
3f6e 18 03			jr .pastdmark  
3f70 ..			.dmark: db "SCD"  
3f73 f1			.pastdmark: pop af  
3f74			endm  
# End of macro DMARK
3f74						CALLMONITOR 
3f74 cd 57 17			call break_point_state  
3f77				endm  
# End of macro CALLMONITOR
3f77					endif 
3f77			 
3f77 cd 8c 0b			call scroll_down 
3f7a			;	call update_display 
3f7a			 
3f7a					NEXTW 
3f7a c3 1d 21			jp macro_next 
3f7d				endm 
# End of macro NEXTW
3f7d			 
3f7d			 
3f7d			.ATQ: 
3f7d				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3f7d 62				db WORD_SYS_CORE+78             
3f7e db 3f			dw .AUTODSP            
3f80 04				db 3 + 1 
3f81 .. 00			db "AT@",0              
3f85				endm 
# End of macro CWHEAD
3f85			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3f85					if DEBUG_FORTH_WORDS_KEY 
3f85						DMARK "ATA" 
3f85 f5				push af  
3f86 3a 9a 3f			ld a, (.dmark)  
3f89 32 b4 fe			ld (debug_mark),a  
3f8c 3a 9b 3f			ld a, (.dmark+1)  
3f8f 32 b5 fe			ld (debug_mark+1),a  
3f92 3a 9c 3f			ld a, (.dmark+2)  
3f95 32 b6 fe			ld (debug_mark+2),a  
3f98 18 03			jr .pastdmark  
3f9a ..			.dmark: db "ATA"  
3f9d f1			.pastdmark: pop af  
3f9e			endm  
# End of macro DMARK
3f9e						CALLMONITOR 
3f9e cd 57 17			call break_point_state  
3fa1				endm  
# End of macro CALLMONITOR
3fa1					endif 
3fa1			 
3fa1			 
3fa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa1 cd ab 1f			call macro_dsp_valuehl 
3fa4				endm 
# End of macro FORTH_DSP_VALUEHL
3fa4			 
3fa4					; TODO save cursor row 
3fa4 7d					ld a,l 
3fa5 fe 02				cp 2 
3fa7 20 04				jr nz, .crow3aq 
3fa9 3e 14				ld a, display_row_2 
3fab 18 12				jr .ccol1aq 
3fad fe 03		.crow3aq:		cp 3 
3faf 20 04				jr nz, .crow4aq 
3fb1 3e 28				ld a, display_row_3 
3fb3 18 0a				jr .ccol1aq 
3fb5 fe 04		.crow4aq:		cp 4 
3fb7 20 04				jr nz, .crow1aq 
3fb9 3e 3c				ld a, display_row_4 
3fbb 18 02				jr .ccol1aq 
3fbd 3e 00		.crow1aq:		ld a,display_row_1 
3fbf f5			.ccol1aq:		push af			; got row offset 
3fc0 6f					ld l,a 
3fc1 26 00				ld h,0 
3fc3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fc3 cd 63 20			call macro_forth_dsp_pop 
3fc6				endm 
# End of macro FORTH_DSP_POP
3fc6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fc6 cd ab 1f			call macro_dsp_valuehl 
3fc9				endm 
# End of macro FORTH_DSP_VALUEHL
3fc9					; TODO save cursor col 
3fc9 f1					pop af 
3fca 85					add l		; add col offset 
3fcb			 
3fcb					; add current frame buffer address 
3fcb 2a 55 fd				ld hl, (display_fb_active) 
3fce cd da 0d				call addatohl 
3fd1			 
3fd1			 
3fd1			 
3fd1			 
3fd1					; get char frame buffer location offset in hl 
3fd1			 
3fd1 7e					ld a,(hl) 
3fd2 26 00				ld h, 0 
3fd4 6f					ld l, a 
3fd5			 
3fd5 cd b4 1d				call forth_push_numhl 
3fd8			 
3fd8			 
3fd8					NEXTW 
3fd8 c3 1d 21			jp macro_next 
3fdb				endm 
# End of macro NEXTW
3fdb			 
3fdb			.AUTODSP: 
3fdb				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3fdb 63				db WORD_SYS_CORE+79             
3fdc f1 3f			dw .MENU            
3fde 05				db 4 + 1 
3fdf .. 00			db "ADSP",0              
3fe4				endm 
# End of macro CWHEAD
3fe4			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3fe4			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3fe4			 
3fe4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fe4 cd ab 1f			call macro_dsp_valuehl 
3fe7				endm 
# End of macro FORTH_DSP_VALUEHL
3fe7			 
3fe7			;		push hl 
3fe7			 
3fe7					; destroy value TOS 
3fe7			 
3fe7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe7 cd 63 20			call macro_forth_dsp_pop 
3fea				endm 
# End of macro FORTH_DSP_POP
3fea			 
3fea			;		pop hl 
3fea			 
3fea 7d					ld a,l 
3feb 32 a1 fc				ld (cli_autodisplay), a 
3fee				       NEXTW 
3fee c3 1d 21			jp macro_next 
3ff1				endm 
# End of macro NEXTW
3ff1			 
3ff1			.MENU: 
3ff1				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3ff1 70				db WORD_SYS_CORE+92             
3ff2 9a 40			dw .ENDDISPLAY            
3ff4 05				db 4 + 1 
3ff5 .. 00			db "MENU",0              
3ffa				endm 
# End of macro CWHEAD
3ffa			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3ffa			 
3ffa			;		; get number of items on the stack 
3ffa			; 
3ffa				 
3ffa					FORTH_DSP_VALUEHL 
3ffa cd ab 1f			call macro_dsp_valuehl 
3ffd				endm 
# End of macro FORTH_DSP_VALUEHL
3ffd				 
3ffd					if DEBUG_FORTH_WORDS_KEY 
3ffd						DMARK "MNU" 
3ffd f5				push af  
3ffe 3a 12 40			ld a, (.dmark)  
4001 32 b4 fe			ld (debug_mark),a  
4004 3a 13 40			ld a, (.dmark+1)  
4007 32 b5 fe			ld (debug_mark+1),a  
400a 3a 14 40			ld a, (.dmark+2)  
400d 32 b6 fe			ld (debug_mark+2),a  
4010 18 03			jr .pastdmark  
4012 ..			.dmark: db "MNU"  
4015 f1			.pastdmark: pop af  
4016			endm  
# End of macro DMARK
4016						CALLMONITOR 
4016 cd 57 17			call break_point_state  
4019				endm  
# End of macro CALLMONITOR
4019					endif 
4019			 
4019 45					ld b, l	 
401a 05					dec b 
401b			 
401b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
401b cd 63 20			call macro_forth_dsp_pop 
401e				endm 
# End of macro FORTH_DSP_POP
401e			 
401e			 
401e					; go directly through the stack to pluck out the string pointers and build an array 
401e			 
401e			;		FORTH_DSP 
401e			 
401e					; hl contains top most stack item 
401e				 
401e 11 5a f4				ld de, scratch 
4021			 
4021			.mbuild: 
4021			 
4021					FORTH_DSP_VALUEHL 
4021 cd ab 1f			call macro_dsp_valuehl 
4024				endm 
# End of macro FORTH_DSP_VALUEHL
4024			 
4024					if DEBUG_FORTH_WORDS 
4024						DMARK "MN3" 
4024 f5				push af  
4025 3a 39 40			ld a, (.dmark)  
4028 32 b4 fe			ld (debug_mark),a  
402b 3a 3a 40			ld a, (.dmark+1)  
402e 32 b5 fe			ld (debug_mark+1),a  
4031 3a 3b 40			ld a, (.dmark+2)  
4034 32 b6 fe			ld (debug_mark+2),a  
4037 18 03			jr .pastdmark  
4039 ..			.dmark: db "MN3"  
403c f1			.pastdmark: pop af  
403d			endm  
# End of macro DMARK
403d						CALLMONITOR 
403d cd 57 17			call break_point_state  
4040				endm  
# End of macro CALLMONITOR
4040					endif 
4040 eb					ex de, hl 
4041 73					ld (hl), e 
4042 23					inc hl 
4043 72					ld (hl), d 
4044 23					inc hl 
4045 eb					ex de, hl 
4046			 
4046					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4046 cd 63 20			call macro_forth_dsp_pop 
4049				endm 
# End of macro FORTH_DSP_POP
4049			 
4049 10 d6				djnz .mbuild 
404b			 
404b					; done add term 
404b			 
404b eb					ex de, hl 
404c 36 00				ld (hl), 0 
404e 23					inc hl 
404f 36 00				ld (hl), 0 
4051			 
4051				 
4051					 
4051 21 5a f4				ld hl, scratch 
4054			 
4054					if DEBUG_FORTH_WORDS 
4054						DMARK "MNx" 
4054 f5				push af  
4055 3a 69 40			ld a, (.dmark)  
4058 32 b4 fe			ld (debug_mark),a  
405b 3a 6a 40			ld a, (.dmark+1)  
405e 32 b5 fe			ld (debug_mark+1),a  
4061 3a 6b 40			ld a, (.dmark+2)  
4064 32 b6 fe			ld (debug_mark+2),a  
4067 18 03			jr .pastdmark  
4069 ..			.dmark: db "MNx"  
406c f1			.pastdmark: pop af  
406d			endm  
# End of macro DMARK
406d						CALLMONITOR 
406d cd 57 17			call break_point_state  
4070				endm  
# End of macro CALLMONITOR
4070					endif 
4070			 
4070			 
4070			 
4070 3e 00				ld a, 0 
4072 cd d7 0b				call menu 
4075			 
4075			 
4075 6f					ld l, a 
4076 26 00				ld h, 0 
4078			 
4078					if DEBUG_FORTH_WORDS 
4078						DMARK "MNr" 
4078 f5				push af  
4079 3a 8d 40			ld a, (.dmark)  
407c 32 b4 fe			ld (debug_mark),a  
407f 3a 8e 40			ld a, (.dmark+1)  
4082 32 b5 fe			ld (debug_mark+1),a  
4085 3a 8f 40			ld a, (.dmark+2)  
4088 32 b6 fe			ld (debug_mark+2),a  
408b 18 03			jr .pastdmark  
408d ..			.dmark: db "MNr"  
4090 f1			.pastdmark: pop af  
4091			endm  
# End of macro DMARK
4091						CALLMONITOR 
4091 cd 57 17			call break_point_state  
4094				endm  
# End of macro CALLMONITOR
4094					endif 
4094			 
4094 cd b4 1d				call forth_push_numhl 
4097			 
4097			 
4097			 
4097			 
4097				       NEXTW 
4097 c3 1d 21			jp macro_next 
409a				endm 
# End of macro NEXTW
409a			 
409a			 
409a			.ENDDISPLAY: 
409a			 
409a			; eof 
# End of file forth_words_display.asm
409a			include "forth_words_str.asm" 
409a			 
409a			; | ## String Words 
409a			 
409a			.PTR:   
409a			 
409a				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
409a 48				db WORD_SYS_CORE+52             
409b c7 40			dw .STYPE            
409d 04				db 3 + 1 
409e .. 00			db "PTR",0              
40a2				endm 
# End of macro CWHEAD
40a2			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
40a2			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
40a2			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
40a2			 
40a2					if DEBUG_FORTH_WORDS_KEY 
40a2						DMARK "PTR" 
40a2 f5				push af  
40a3 3a b7 40			ld a, (.dmark)  
40a6 32 b4 fe			ld (debug_mark),a  
40a9 3a b8 40			ld a, (.dmark+1)  
40ac 32 b5 fe			ld (debug_mark+1),a  
40af 3a b9 40			ld a, (.dmark+2)  
40b2 32 b6 fe			ld (debug_mark+2),a  
40b5 18 03			jr .pastdmark  
40b7 ..			.dmark: db "PTR"  
40ba f1			.pastdmark: pop af  
40bb			endm  
# End of macro DMARK
40bb						CALLMONITOR 
40bb cd 57 17			call break_point_state  
40be				endm  
# End of macro CALLMONITOR
40be					endif 
40be					FORTH_DSP_VALUEHL 
40be cd ab 1f			call macro_dsp_valuehl 
40c1				endm 
# End of macro FORTH_DSP_VALUEHL
40c1 cd b4 1d				call forth_push_numhl 
40c4			 
40c4			 
40c4					NEXTW 
40c4 c3 1d 21			jp macro_next 
40c7				endm 
# End of macro NEXTW
40c7			.STYPE: 
40c7				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
40c7 48				db WORD_SYS_CORE+52             
40c8 16 41			dw .UPPER            
40ca 06				db 5 + 1 
40cb .. 00			db "STYPE",0              
40d1				endm 
# End of macro CWHEAD
40d1			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
40d1					if DEBUG_FORTH_WORDS_KEY 
40d1						DMARK "STY" 
40d1 f5				push af  
40d2 3a e6 40			ld a, (.dmark)  
40d5 32 b4 fe			ld (debug_mark),a  
40d8 3a e7 40			ld a, (.dmark+1)  
40db 32 b5 fe			ld (debug_mark+1),a  
40de 3a e8 40			ld a, (.dmark+2)  
40e1 32 b6 fe			ld (debug_mark+2),a  
40e4 18 03			jr .pastdmark  
40e6 ..			.dmark: db "STY"  
40e9 f1			.pastdmark: pop af  
40ea			endm  
# End of macro DMARK
40ea						CALLMONITOR 
40ea cd 57 17			call break_point_state  
40ed				endm  
# End of macro CALLMONITOR
40ed					endif 
40ed					FORTH_DSP 
40ed cd 71 1f			call macro_forth_dsp 
40f0				endm 
# End of macro FORTH_DSP
40f0					;v5 FORTH_DSP_VALUE 
40f0			 
40f0 7e					ld a, (hl) 
40f1			 
40f1 f5					push af 
40f2			 
40f2			; Dont destroy TOS		FORTH_DSP_POP 
40f2			 
40f2 f1					pop af 
40f3			 
40f3 fe 01				cp DS_TYPE_STR 
40f5 28 09				jr z, .typestr 
40f7			 
40f7 fe 02				cp DS_TYPE_INUM 
40f9 28 0a				jr z, .typeinum 
40fb			 
40fb 21 14 41				ld hl, .tna 
40fe 18 0a				jr .tpush 
4100			 
4100 21 10 41		.typestr:	ld hl, .tstr 
4103 18 05				jr .tpush 
4105 21 12 41		.typeinum:	ld hl, .tinum 
4108 18 00				jr .tpush 
410a			 
410a			.tpush: 
410a			 
410a cd 22 1e				call forth_push_str 
410d			 
410d					NEXTW 
410d c3 1d 21			jp macro_next 
4110				endm 
# End of macro NEXTW
4110 .. 00		.tstr:	db "s",0 
4112 .. 00		.tinum:  db "i",0 
4114 .. 00		.tna:   db "?", 0 
4116			 
4116			 
4116			.UPPER: 
4116				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4116 48				db WORD_SYS_CORE+52             
4117 51 41			dw .LOWER            
4119 06				db 5 + 1 
411a .. 00			db "UPPER",0              
4120				endm 
# End of macro CWHEAD
4120			; | UPPER ( s -- s ) Upper case string s  | DONE 
4120					if DEBUG_FORTH_WORDS_KEY 
4120						DMARK "UPR" 
4120 f5				push af  
4121 3a 35 41			ld a, (.dmark)  
4124 32 b4 fe			ld (debug_mark),a  
4127 3a 36 41			ld a, (.dmark+1)  
412a 32 b5 fe			ld (debug_mark+1),a  
412d 3a 37 41			ld a, (.dmark+2)  
4130 32 b6 fe			ld (debug_mark+2),a  
4133 18 03			jr .pastdmark  
4135 ..			.dmark: db "UPR"  
4138 f1			.pastdmark: pop af  
4139			endm  
# End of macro DMARK
4139						CALLMONITOR 
4139 cd 57 17			call break_point_state  
413c				endm  
# End of macro CALLMONITOR
413c					endif 
413c			 
413c					FORTH_DSP 
413c cd 71 1f			call macro_forth_dsp 
413f				endm 
# End of macro FORTH_DSP
413f					 
413f			; TODO check is string type 
413f			 
413f					FORTH_DSP_VALUEHL 
413f cd ab 1f			call macro_dsp_valuehl 
4142				endm 
# End of macro FORTH_DSP_VALUEHL
4142			; get pointer to string in hl 
4142			 
4142 7e			.toup:		ld a, (hl) 
4143 fe 00				cp 0 
4145 28 07				jr z, .toupdone 
4147			 
4147 cd 47 11				call to_upper 
414a			 
414a 77					ld (hl), a 
414b 23					inc hl 
414c 18 f4				jr .toup 
414e			 
414e					 
414e			 
414e			 
414e			; for each char convert to upper 
414e					 
414e			.toupdone: 
414e			 
414e			 
414e					NEXTW 
414e c3 1d 21			jp macro_next 
4151				endm 
# End of macro NEXTW
4151			.LOWER: 
4151				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4151 48				db WORD_SYS_CORE+52             
4152 8c 41			dw .TCASE            
4154 06				db 5 + 1 
4155 .. 00			db "LOWER",0              
415b				endm 
# End of macro CWHEAD
415b			; | LOWER ( s -- s ) Lower case string s  | DONE 
415b					if DEBUG_FORTH_WORDS_KEY 
415b						DMARK "LWR" 
415b f5				push af  
415c 3a 70 41			ld a, (.dmark)  
415f 32 b4 fe			ld (debug_mark),a  
4162 3a 71 41			ld a, (.dmark+1)  
4165 32 b5 fe			ld (debug_mark+1),a  
4168 3a 72 41			ld a, (.dmark+2)  
416b 32 b6 fe			ld (debug_mark+2),a  
416e 18 03			jr .pastdmark  
4170 ..			.dmark: db "LWR"  
4173 f1			.pastdmark: pop af  
4174			endm  
# End of macro DMARK
4174						CALLMONITOR 
4174 cd 57 17			call break_point_state  
4177				endm  
# End of macro CALLMONITOR
4177					endif 
4177			 
4177					FORTH_DSP 
4177 cd 71 1f			call macro_forth_dsp 
417a				endm 
# End of macro FORTH_DSP
417a					 
417a			; TODO check is string type 
417a			 
417a					FORTH_DSP_VALUEHL 
417a cd ab 1f			call macro_dsp_valuehl 
417d				endm 
# End of macro FORTH_DSP_VALUEHL
417d			; get pointer to string in hl 
417d			 
417d 7e			.tolow:		ld a, (hl) 
417e fe 00				cp 0 
4180 28 07				jr z, .tolowdone 
4182			 
4182 cd 50 11				call to_lower 
4185			 
4185 77					ld (hl), a 
4186 23					inc hl 
4187 18 f4				jr .tolow 
4189			 
4189					 
4189			 
4189			 
4189			; for each char convert to low 
4189					 
4189			.tolowdone: 
4189					NEXTW 
4189 c3 1d 21			jp macro_next 
418c				endm 
# End of macro NEXTW
418c			.TCASE: 
418c				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
418c 48				db WORD_SYS_CORE+52             
418d c2 42			dw .SUBSTR            
418f 06				db 5 + 1 
4190 .. 00			db "TCASE",0              
4196				endm 
# End of macro CWHEAD
4196			; | TCASE ( s -- s ) Title case string s  | DONE 
4196					if DEBUG_FORTH_WORDS_KEY 
4196						DMARK "TCS" 
4196 f5				push af  
4197 3a ab 41			ld a, (.dmark)  
419a 32 b4 fe			ld (debug_mark),a  
419d 3a ac 41			ld a, (.dmark+1)  
41a0 32 b5 fe			ld (debug_mark+1),a  
41a3 3a ad 41			ld a, (.dmark+2)  
41a6 32 b6 fe			ld (debug_mark+2),a  
41a9 18 03			jr .pastdmark  
41ab ..			.dmark: db "TCS"  
41ae f1			.pastdmark: pop af  
41af			endm  
# End of macro DMARK
41af						CALLMONITOR 
41af cd 57 17			call break_point_state  
41b2				endm  
# End of macro CALLMONITOR
41b2					endif 
41b2			 
41b2					FORTH_DSP 
41b2 cd 71 1f			call macro_forth_dsp 
41b5				endm 
# End of macro FORTH_DSP
41b5					 
41b5			; TODO check is string type 
41b5			 
41b5					FORTH_DSP_VALUEHL 
41b5 cd ab 1f			call macro_dsp_valuehl 
41b8				endm 
# End of macro FORTH_DSP_VALUEHL
41b8			; get pointer to string in hl 
41b8			 
41b8					if DEBUG_FORTH_WORDS 
41b8						DMARK "TC1" 
41b8 f5				push af  
41b9 3a cd 41			ld a, (.dmark)  
41bc 32 b4 fe			ld (debug_mark),a  
41bf 3a ce 41			ld a, (.dmark+1)  
41c2 32 b5 fe			ld (debug_mark+1),a  
41c5 3a cf 41			ld a, (.dmark+2)  
41c8 32 b6 fe			ld (debug_mark+2),a  
41cb 18 03			jr .pastdmark  
41cd ..			.dmark: db "TC1"  
41d0 f1			.pastdmark: pop af  
41d1			endm  
# End of macro DMARK
41d1						CALLMONITOR 
41d1 cd 57 17			call break_point_state  
41d4				endm  
# End of macro CALLMONITOR
41d4					endif 
41d4			 
41d4					; first time in turn to upper case first char 
41d4			 
41d4 7e					ld a, (hl) 
41d5 c3 5f 42				jp .totsiptou 
41d8			 
41d8			 
41d8 7e			.tot:		ld a, (hl) 
41d9 fe 00				cp 0 
41db ca a3 42				jp z, .totdone 
41de			 
41de					if DEBUG_FORTH_WORDS 
41de						DMARK "TC2" 
41de f5				push af  
41df 3a f3 41			ld a, (.dmark)  
41e2 32 b4 fe			ld (debug_mark),a  
41e5 3a f4 41			ld a, (.dmark+1)  
41e8 32 b5 fe			ld (debug_mark+1),a  
41eb 3a f5 41			ld a, (.dmark+2)  
41ee 32 b6 fe			ld (debug_mark+2),a  
41f1 18 03			jr .pastdmark  
41f3 ..			.dmark: db "TC2"  
41f6 f1			.pastdmark: pop af  
41f7			endm  
# End of macro DMARK
41f7						CALLMONITOR 
41f7 cd 57 17			call break_point_state  
41fa				endm  
# End of macro CALLMONITOR
41fa					endif 
41fa					; check to see if current char is a space 
41fa			 
41fa fe 20				cp ' ' 
41fc 28 21				jr z, .totsp 
41fe cd 50 11				call to_lower 
4201					if DEBUG_FORTH_WORDS 
4201						DMARK "TC3" 
4201 f5				push af  
4202 3a 16 42			ld a, (.dmark)  
4205 32 b4 fe			ld (debug_mark),a  
4208 3a 17 42			ld a, (.dmark+1)  
420b 32 b5 fe			ld (debug_mark+1),a  
420e 3a 18 42			ld a, (.dmark+2)  
4211 32 b6 fe			ld (debug_mark+2),a  
4214 18 03			jr .pastdmark  
4216 ..			.dmark: db "TC3"  
4219 f1			.pastdmark: pop af  
421a			endm  
# End of macro DMARK
421a						CALLMONITOR 
421a cd 57 17			call break_point_state  
421d				endm  
# End of macro CALLMONITOR
421d					endif 
421d 18 63				jr .totnxt 
421f			 
421f			.totsp:         ; on a space, find next char which should be upper 
421f			 
421f					if DEBUG_FORTH_WORDS 
421f						DMARK "TC4" 
421f f5				push af  
4220 3a 34 42			ld a, (.dmark)  
4223 32 b4 fe			ld (debug_mark),a  
4226 3a 35 42			ld a, (.dmark+1)  
4229 32 b5 fe			ld (debug_mark+1),a  
422c 3a 36 42			ld a, (.dmark+2)  
422f 32 b6 fe			ld (debug_mark+2),a  
4232 18 03			jr .pastdmark  
4234 ..			.dmark: db "TC4"  
4237 f1			.pastdmark: pop af  
4238			endm  
# End of macro DMARK
4238						CALLMONITOR 
4238 cd 57 17			call break_point_state  
423b				endm  
# End of macro CALLMONITOR
423b					endif 
423b					;; 
423b			 
423b fe 20				cp ' ' 
423d 20 20				jr nz, .totsiptou 
423f 23					inc hl 
4240 7e					ld a, (hl) 
4241					if DEBUG_FORTH_WORDS 
4241						DMARK "TC5" 
4241 f5				push af  
4242 3a 56 42			ld a, (.dmark)  
4245 32 b4 fe			ld (debug_mark),a  
4248 3a 57 42			ld a, (.dmark+1)  
424b 32 b5 fe			ld (debug_mark+1),a  
424e 3a 58 42			ld a, (.dmark+2)  
4251 32 b6 fe			ld (debug_mark+2),a  
4254 18 03			jr .pastdmark  
4256 ..			.dmark: db "TC5"  
4259 f1			.pastdmark: pop af  
425a			endm  
# End of macro DMARK
425a						CALLMONITOR 
425a cd 57 17			call break_point_state  
425d				endm  
# End of macro CALLMONITOR
425d					endif 
425d 18 c0				jr .totsp 
425f fe 00		.totsiptou:    cp 0 
4261 28 40				jr z, .totdone 
4263					; not space and not zero term so upper case it 
4263 cd 47 11				call to_upper 
4266			 
4266					if DEBUG_FORTH_WORDS 
4266						DMARK "TC6" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 b4 fe			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 b5 fe			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 b6 fe			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "TC6"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f						CALLMONITOR 
427f cd 57 17			call break_point_state  
4282				endm  
# End of macro CALLMONITOR
4282					endif 
4282			 
4282			 
4282			.totnxt: 
4282			 
4282 77					ld (hl), a 
4283 23					inc hl 
4284					if DEBUG_FORTH_WORDS 
4284						DMARK "TC7" 
4284 f5				push af  
4285 3a 99 42			ld a, (.dmark)  
4288 32 b4 fe			ld (debug_mark),a  
428b 3a 9a 42			ld a, (.dmark+1)  
428e 32 b5 fe			ld (debug_mark+1),a  
4291 3a 9b 42			ld a, (.dmark+2)  
4294 32 b6 fe			ld (debug_mark+2),a  
4297 18 03			jr .pastdmark  
4299 ..			.dmark: db "TC7"  
429c f1			.pastdmark: pop af  
429d			endm  
# End of macro DMARK
429d						CALLMONITOR 
429d cd 57 17			call break_point_state  
42a0				endm  
# End of macro CALLMONITOR
42a0					endif 
42a0 c3 d8 41				jp .tot 
42a3			 
42a3					 
42a3			 
42a3			 
42a3			; for each char convert to low 
42a3					 
42a3			.totdone: 
42a3					if DEBUG_FORTH_WORDS 
42a3						DMARK "TCd" 
42a3 f5				push af  
42a4 3a b8 42			ld a, (.dmark)  
42a7 32 b4 fe			ld (debug_mark),a  
42aa 3a b9 42			ld a, (.dmark+1)  
42ad 32 b5 fe			ld (debug_mark+1),a  
42b0 3a ba 42			ld a, (.dmark+2)  
42b3 32 b6 fe			ld (debug_mark+2),a  
42b6 18 03			jr .pastdmark  
42b8 ..			.dmark: db "TCd"  
42bb f1			.pastdmark: pop af  
42bc			endm  
# End of macro DMARK
42bc						CALLMONITOR 
42bc cd 57 17			call break_point_state  
42bf				endm  
# End of macro CALLMONITOR
42bf					endif 
42bf					NEXTW 
42bf c3 1d 21			jp macro_next 
42c2				endm 
# End of macro NEXTW
42c2			 
42c2			.SUBSTR: 
42c2				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
42c2 48				db WORD_SYS_CORE+52             
42c3 20 43			dw .LEFT            
42c5 07				db 6 + 1 
42c6 .. 00			db "SUBSTR",0              
42cd				endm 
# End of macro CWHEAD
42cd			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
42cd			 
42cd					if DEBUG_FORTH_WORDS_KEY 
42cd						DMARK "SST" 
42cd f5				push af  
42ce 3a e2 42			ld a, (.dmark)  
42d1 32 b4 fe			ld (debug_mark),a  
42d4 3a e3 42			ld a, (.dmark+1)  
42d7 32 b5 fe			ld (debug_mark+1),a  
42da 3a e4 42			ld a, (.dmark+2)  
42dd 32 b6 fe			ld (debug_mark+2),a  
42e0 18 03			jr .pastdmark  
42e2 ..			.dmark: db "SST"  
42e5 f1			.pastdmark: pop af  
42e6			endm  
# End of macro DMARK
42e6						CALLMONITOR 
42e6 cd 57 17			call break_point_state  
42e9				endm  
# End of macro CALLMONITOR
42e9					endif 
42e9			; TODO check string type 
42e9					FORTH_DSP_VALUEHL 
42e9 cd ab 1f			call macro_dsp_valuehl 
42ec				endm 
# End of macro FORTH_DSP_VALUEHL
42ec			 
42ec e5					push hl      ; string length 
42ed			 
42ed					FORTH_DSP_POP 
42ed cd 63 20			call macro_forth_dsp_pop 
42f0				endm 
# End of macro FORTH_DSP_POP
42f0			 
42f0					FORTH_DSP_VALUEHL 
42f0 cd ab 1f			call macro_dsp_valuehl 
42f3				endm 
# End of macro FORTH_DSP_VALUEHL
42f3			 
42f3 e5					push hl     ; start char 
42f4			 
42f4					FORTH_DSP_POP 
42f4 cd 63 20			call macro_forth_dsp_pop 
42f7				endm 
# End of macro FORTH_DSP_POP
42f7			 
42f7			 
42f7					FORTH_DSP_VALUE 
42f7 cd 94 1f			call macro_forth_dsp_value 
42fa				endm 
# End of macro FORTH_DSP_VALUE
42fa			 
42fa d1					pop de    ; get start post offset 
42fb			 
42fb 19					add hl, de    ; starting offset 
42fc			 
42fc c1					pop bc 
42fd c5					push bc      ; grab size of string 
42fe			 
42fe e5					push hl    ; save string start  
42ff			 
42ff 26 00				ld h, 0 
4301 69					ld l, c 
4302 23					inc hl 
4303 23					inc hl 
4304			 
4304 cd a1 12				call malloc 
4307				if DEBUG_FORTH_MALLOC_GUARD 
4307 cc 73 53				call z,malloc_error 
430a				endif 
430a			 
430a eb					ex de, hl      ; save malloc area for string copy 
430b e1					pop hl    ; get back source 
430c c1					pop bc    ; get length of string back 
430d			 
430d d5					push de    ; save malloc area for after we push 
430e ed b0				ldir     ; copy substr 
4310			 
4310			 
4310 eb					ex de, hl 
4311 3e 00				ld a, 0 
4313 77					ld (hl), a   ; term substr 
4314			 
4314					 
4314 e1					pop hl    ; get malloc so we can push it 
4315 e5					push hl   ; save so we can free it afterwards 
4316			 
4316 cd 22 1e				call forth_push_str 
4319			 
4319 e1					pop hl 
431a cd 6b 13				call free 
431d			 
431d					 
431d					 
431d			 
431d			 
431d					NEXTW 
431d c3 1d 21			jp macro_next 
4320				endm 
# End of macro NEXTW
4320			 
4320			.LEFT: 
4320				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4320 48				db WORD_SYS_CORE+52             
4321 48 43			dw .RIGHT            
4323 05				db 4 + 1 
4324 .. 00			db "LEFT",0              
4329				endm 
# End of macro CWHEAD
4329			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4329					if DEBUG_FORTH_WORDS_KEY 
4329						DMARK "LEF" 
4329 f5				push af  
432a 3a 3e 43			ld a, (.dmark)  
432d 32 b4 fe			ld (debug_mark),a  
4330 3a 3f 43			ld a, (.dmark+1)  
4333 32 b5 fe			ld (debug_mark+1),a  
4336 3a 40 43			ld a, (.dmark+2)  
4339 32 b6 fe			ld (debug_mark+2),a  
433c 18 03			jr .pastdmark  
433e ..			.dmark: db "LEF"  
4341 f1			.pastdmark: pop af  
4342			endm  
# End of macro DMARK
4342						CALLMONITOR 
4342 cd 57 17			call break_point_state  
4345				endm  
# End of macro CALLMONITOR
4345					endif 
4345			 
4345					NEXTW 
4345 c3 1d 21			jp macro_next 
4348				endm 
# End of macro NEXTW
4348			.RIGHT: 
4348				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4348 48				db WORD_SYS_CORE+52             
4349 71 43			dw .STR2NUM            
434b 06				db 5 + 1 
434c .. 00			db "RIGHT",0              
4352				endm 
# End of macro CWHEAD
4352			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4352					if DEBUG_FORTH_WORDS_KEY 
4352						DMARK "RIG" 
4352 f5				push af  
4353 3a 67 43			ld a, (.dmark)  
4356 32 b4 fe			ld (debug_mark),a  
4359 3a 68 43			ld a, (.dmark+1)  
435c 32 b5 fe			ld (debug_mark+1),a  
435f 3a 69 43			ld a, (.dmark+2)  
4362 32 b6 fe			ld (debug_mark+2),a  
4365 18 03			jr .pastdmark  
4367 ..			.dmark: db "RIG"  
436a f1			.pastdmark: pop af  
436b			endm  
# End of macro DMARK
436b						CALLMONITOR 
436b cd 57 17			call break_point_state  
436e				endm  
# End of macro CALLMONITOR
436e					endif 
436e			 
436e					NEXTW 
436e c3 1d 21			jp macro_next 
4371				endm 
# End of macro NEXTW
4371			 
4371			 
4371			.STR2NUM: 
4371				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4371 48				db WORD_SYS_CORE+52             
4372 fd 43			dw .NUM2STR            
4374 08				db 7 + 1 
4375 .. 00			db "STR2NUM",0              
437d				endm 
# End of macro CWHEAD
437d			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
437d			 
437d			 
437d			; TODO STR type check to do 
437d					if DEBUG_FORTH_WORDS_KEY 
437d						DMARK "S2N" 
437d f5				push af  
437e 3a 92 43			ld a, (.dmark)  
4381 32 b4 fe			ld (debug_mark),a  
4384 3a 93 43			ld a, (.dmark+1)  
4387 32 b5 fe			ld (debug_mark+1),a  
438a 3a 94 43			ld a, (.dmark+2)  
438d 32 b6 fe			ld (debug_mark+2),a  
4390 18 03			jr .pastdmark  
4392 ..			.dmark: db "S2N"  
4395 f1			.pastdmark: pop af  
4396			endm  
# End of macro DMARK
4396						CALLMONITOR 
4396 cd 57 17			call break_point_state  
4399				endm  
# End of macro CALLMONITOR
4399					endif 
4399			 
4399					;FORTH_DSP 
4399					FORTH_DSP_VALUE 
4399 cd 94 1f			call macro_forth_dsp_value 
439c				endm 
# End of macro FORTH_DSP_VALUE
439c					;inc hl 
439c			 
439c eb					ex de, hl 
439d					if DEBUG_FORTH_WORDS 
439d						DMARK "S2a" 
439d f5				push af  
439e 3a b2 43			ld a, (.dmark)  
43a1 32 b4 fe			ld (debug_mark),a  
43a4 3a b3 43			ld a, (.dmark+1)  
43a7 32 b5 fe			ld (debug_mark+1),a  
43aa 3a b4 43			ld a, (.dmark+2)  
43ad 32 b6 fe			ld (debug_mark+2),a  
43b0 18 03			jr .pastdmark  
43b2 ..			.dmark: db "S2a"  
43b5 f1			.pastdmark: pop af  
43b6			endm  
# End of macro DMARK
43b6						CALLMONITOR 
43b6 cd 57 17			call break_point_state  
43b9				endm  
# End of macro CALLMONITOR
43b9					endif 
43b9 cd cf 11				call string_to_uint16 
43bc			 
43bc					if DEBUG_FORTH_WORDS 
43bc						DMARK "S2b" 
43bc f5				push af  
43bd 3a d1 43			ld a, (.dmark)  
43c0 32 b4 fe			ld (debug_mark),a  
43c3 3a d2 43			ld a, (.dmark+1)  
43c6 32 b5 fe			ld (debug_mark+1),a  
43c9 3a d3 43			ld a, (.dmark+2)  
43cc 32 b6 fe			ld (debug_mark+2),a  
43cf 18 03			jr .pastdmark  
43d1 ..			.dmark: db "S2b"  
43d4 f1			.pastdmark: pop af  
43d5			endm  
# End of macro DMARK
43d5						CALLMONITOR 
43d5 cd 57 17			call break_point_state  
43d8				endm  
# End of macro CALLMONITOR
43d8					endif 
43d8			;		push hl 
43d8					FORTH_DSP_POP 
43d8 cd 63 20			call macro_forth_dsp_pop 
43db				endm 
# End of macro FORTH_DSP_POP
43db			;		pop hl 
43db					 
43db					if DEBUG_FORTH_WORDS 
43db						DMARK "S2b" 
43db f5				push af  
43dc 3a f0 43			ld a, (.dmark)  
43df 32 b4 fe			ld (debug_mark),a  
43e2 3a f1 43			ld a, (.dmark+1)  
43e5 32 b5 fe			ld (debug_mark+1),a  
43e8 3a f2 43			ld a, (.dmark+2)  
43eb 32 b6 fe			ld (debug_mark+2),a  
43ee 18 03			jr .pastdmark  
43f0 ..			.dmark: db "S2b"  
43f3 f1			.pastdmark: pop af  
43f4			endm  
# End of macro DMARK
43f4						CALLMONITOR 
43f4 cd 57 17			call break_point_state  
43f7				endm  
# End of macro CALLMONITOR
43f7					endif 
43f7 cd b4 1d				call forth_push_numhl	 
43fa			 
43fa				 
43fa				       NEXTW 
43fa c3 1d 21			jp macro_next 
43fd				endm 
# End of macro NEXTW
43fd			.NUM2STR: 
43fd				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
43fd 48				db WORD_SYS_CORE+52             
43fe 0c 44			dw .CONCAT            
4400 08				db 7 + 1 
4401 .. 00			db "NUM2STR",0              
4409				endm 
# End of macro CWHEAD
4409			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4409			 
4409			;		; malloc a string to target 
4409			;		ld hl, 10     ; TODO max string size should be fine 
4409			;		call malloc 
4409			;		push hl    ; save malloc location 
4409			; 
4409			; 
4409			;; TODO check int type 
4409			;		FORTH_DSP_VALUEHL 
4409			;		ld a, l 
4409			;		call DispAToASCII   
4409			;;TODO need to chage above call to dump into string 
4409			; 
4409			; 
4409			 
4409				       NEXTW 
4409 c3 1d 21			jp macro_next 
440c				endm 
# End of macro NEXTW
440c			 
440c			.CONCAT: 
440c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
440c 48				db WORD_SYS_CORE+52             
440d bf 44			dw .FIND            
440f 07				db 6 + 1 
4410 .. 00			db "CONCAT",0              
4417				endm 
# End of macro CWHEAD
4417			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4417			 
4417			; TODO check string type 
4417			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4417			 
4417					if DEBUG_FORTH_WORDS_KEY 
4417						DMARK "CON" 
4417 f5				push af  
4418 3a 2c 44			ld a, (.dmark)  
441b 32 b4 fe			ld (debug_mark),a  
441e 3a 2d 44			ld a, (.dmark+1)  
4421 32 b5 fe			ld (debug_mark+1),a  
4424 3a 2e 44			ld a, (.dmark+2)  
4427 32 b6 fe			ld (debug_mark+2),a  
442a 18 03			jr .pastdmark  
442c ..			.dmark: db "CON"  
442f f1			.pastdmark: pop af  
4430			endm  
# End of macro DMARK
4430						CALLMONITOR 
4430 cd 57 17			call break_point_state  
4433				endm  
# End of macro CALLMONITOR
4433					endif 
4433			 
4433			 
4433					FORTH_DSP_VALUE 
4433 cd 94 1f			call macro_forth_dsp_value 
4436				endm 
# End of macro FORTH_DSP_VALUE
4436 e5					push hl   ; s2 
4437			 
4437					FORTH_DSP_POP 
4437 cd 63 20			call macro_forth_dsp_pop 
443a				endm 
# End of macro FORTH_DSP_POP
443a			 
443a					FORTH_DSP_VALUE 
443a cd 94 1f			call macro_forth_dsp_value 
443d				endm 
# End of macro FORTH_DSP_VALUE
443d			 
443d e5					push hl   ; s1 
443e			 
443e					FORTH_DSP_POP 
443e cd 63 20			call macro_forth_dsp_pop 
4441				endm 
# End of macro FORTH_DSP_POP
4441					 
4441			 
4441					; copy s1 
4441			 
4441				 
4441					; save ptr 
4441 e1					pop hl  
4442 e5					push hl 
4443 3e 00				ld a, 0 
4445 cd 43 12				call strlent 
4448					;inc hl    ; zer0 
4448 06 00				ld b, 0 
444a 4d					ld c, l 
444b e1					pop hl		 
444c 11 5a f4				ld de, scratch	 
444f					if DEBUG_FORTH_WORDS 
444f						DMARK "CO1" 
444f f5				push af  
4450 3a 64 44			ld a, (.dmark)  
4453 32 b4 fe			ld (debug_mark),a  
4456 3a 65 44			ld a, (.dmark+1)  
4459 32 b5 fe			ld (debug_mark+1),a  
445c 3a 66 44			ld a, (.dmark+2)  
445f 32 b6 fe			ld (debug_mark+2),a  
4462 18 03			jr .pastdmark  
4464 ..			.dmark: db "CO1"  
4467 f1			.pastdmark: pop af  
4468			endm  
# End of macro DMARK
4468						CALLMONITOR 
4468 cd 57 17			call break_point_state  
446b				endm  
# End of macro CALLMONITOR
446b					endif 
446b ed b0				ldir 
446d			 
446d e1					pop hl 
446e e5					push hl 
446f d5					push de 
4470			 
4470			 
4470 3e 00				ld a, 0 
4472 cd 43 12				call strlent 
4475 23					inc hl    ; zer0 
4476 23					inc hl 
4477 06 00				ld b, 0 
4479 4d					ld c, l 
447a d1					pop de 
447b e1					pop hl		 
447c					if DEBUG_FORTH_WORDS 
447c						DMARK "CO2" 
447c f5				push af  
447d 3a 91 44			ld a, (.dmark)  
4480 32 b4 fe			ld (debug_mark),a  
4483 3a 92 44			ld a, (.dmark+1)  
4486 32 b5 fe			ld (debug_mark+1),a  
4489 3a 93 44			ld a, (.dmark+2)  
448c 32 b6 fe			ld (debug_mark+2),a  
448f 18 03			jr .pastdmark  
4491 ..			.dmark: db "CO2"  
4494 f1			.pastdmark: pop af  
4495			endm  
# End of macro DMARK
4495						CALLMONITOR 
4495 cd 57 17			call break_point_state  
4498				endm  
# End of macro CALLMONITOR
4498					endif 
4498 ed b0				ldir 
449a			 
449a			 
449a			 
449a 21 5a f4				ld hl, scratch 
449d					if DEBUG_FORTH_WORDS 
449d						DMARK "CO5" 
449d f5				push af  
449e 3a b2 44			ld a, (.dmark)  
44a1 32 b4 fe			ld (debug_mark),a  
44a4 3a b3 44			ld a, (.dmark+1)  
44a7 32 b5 fe			ld (debug_mark+1),a  
44aa 3a b4 44			ld a, (.dmark+2)  
44ad 32 b6 fe			ld (debug_mark+2),a  
44b0 18 03			jr .pastdmark  
44b2 ..			.dmark: db "CO5"  
44b5 f1			.pastdmark: pop af  
44b6			endm  
# End of macro DMARK
44b6						CALLMONITOR 
44b6 cd 57 17			call break_point_state  
44b9				endm  
# End of macro CALLMONITOR
44b9					endif 
44b9			 
44b9 cd 22 1e				call forth_push_str 
44bc			 
44bc			 
44bc			 
44bc			 
44bc				       NEXTW 
44bc c3 1d 21			jp macro_next 
44bf				endm 
# End of macro NEXTW
44bf			 
44bf			 
44bf			.FIND: 
44bf				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
44bf 4b				db WORD_SYS_CORE+55             
44c0 7d 45			dw .LEN            
44c2 05				db 4 + 1 
44c3 .. 00			db "FIND",0              
44c8				endm 
# End of macro CWHEAD
44c8			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
44c8			 
44c8					if DEBUG_FORTH_WORDS_KEY 
44c8						DMARK "FND" 
44c8 f5				push af  
44c9 3a dd 44			ld a, (.dmark)  
44cc 32 b4 fe			ld (debug_mark),a  
44cf 3a de 44			ld a, (.dmark+1)  
44d2 32 b5 fe			ld (debug_mark+1),a  
44d5 3a df 44			ld a, (.dmark+2)  
44d8 32 b6 fe			ld (debug_mark+2),a  
44db 18 03			jr .pastdmark  
44dd ..			.dmark: db "FND"  
44e0 f1			.pastdmark: pop af  
44e1			endm  
# End of macro DMARK
44e1						CALLMONITOR 
44e1 cd 57 17			call break_point_state  
44e4				endm  
# End of macro CALLMONITOR
44e4					endif 
44e4			 
44e4			; TODO check string type 
44e4					FORTH_DSP_VALUE 
44e4 cd 94 1f			call macro_forth_dsp_value 
44e7				endm 
# End of macro FORTH_DSP_VALUE
44e7			 
44e7 e5					push hl    
44e8 7e					ld a,(hl)    ; char to find   
44e9			; TODO change char to substr 
44e9			 
44e9 f5					push af 
44ea					 
44ea			 
44ea			 
44ea					if DEBUG_FORTH_WORDS 
44ea						DMARK "FN1" 
44ea f5				push af  
44eb 3a ff 44			ld a, (.dmark)  
44ee 32 b4 fe			ld (debug_mark),a  
44f1 3a 00 45			ld a, (.dmark+1)  
44f4 32 b5 fe			ld (debug_mark+1),a  
44f7 3a 01 45			ld a, (.dmark+2)  
44fa 32 b6 fe			ld (debug_mark+2),a  
44fd 18 03			jr .pastdmark  
44ff ..			.dmark: db "FN1"  
4502 f1			.pastdmark: pop af  
4503			endm  
# End of macro DMARK
4503						CALLMONITOR 
4503 cd 57 17			call break_point_state  
4506				endm  
# End of macro CALLMONITOR
4506					endif 
4506			 
4506					FORTH_DSP_POP 
4506 cd 63 20			call macro_forth_dsp_pop 
4509				endm 
# End of macro FORTH_DSP_POP
4509			 
4509					; string to search 
4509			 
4509					FORTH_DSP_VALUE 
4509 cd 94 1f			call macro_forth_dsp_value 
450c				endm 
# End of macro FORTH_DSP_VALUE
450c			 
450c d1					pop de  ; d is char to find  
450d			 
450d					if DEBUG_FORTH_WORDS 
450d						DMARK "FN2" 
450d f5				push af  
450e 3a 22 45			ld a, (.dmark)  
4511 32 b4 fe			ld (debug_mark),a  
4514 3a 23 45			ld a, (.dmark+1)  
4517 32 b5 fe			ld (debug_mark+1),a  
451a 3a 24 45			ld a, (.dmark+2)  
451d 32 b6 fe			ld (debug_mark+2),a  
4520 18 03			jr .pastdmark  
4522 ..			.dmark: db "FN2"  
4525 f1			.pastdmark: pop af  
4526			endm  
# End of macro DMARK
4526						CALLMONITOR 
4526 cd 57 17			call break_point_state  
4529				endm  
# End of macro CALLMONITOR
4529					endif 
4529					 
4529 01 00 00				ld bc, 0 
452c 7e			.findchar:      ld a,(hl) 
452d fe 00				cp 0   		 
452f 28 27				jr z, .finddone     
4531 ba					cp d 
4532 28 20				jr z, .foundchar 
4534 03					inc bc 
4535 23					inc hl 
4536					if DEBUG_FORTH_WORDS 
4536						DMARK "FN3" 
4536 f5				push af  
4537 3a 4b 45			ld a, (.dmark)  
453a 32 b4 fe			ld (debug_mark),a  
453d 3a 4c 45			ld a, (.dmark+1)  
4540 32 b5 fe			ld (debug_mark+1),a  
4543 3a 4d 45			ld a, (.dmark+2)  
4546 32 b6 fe			ld (debug_mark+2),a  
4549 18 03			jr .pastdmark  
454b ..			.dmark: db "FN3"  
454e f1			.pastdmark: pop af  
454f			endm  
# End of macro DMARK
454f						CALLMONITOR 
454f cd 57 17			call break_point_state  
4552				endm  
# End of macro CALLMONITOR
4552					endif 
4552 18 d8				jr .findchar 
4554			 
4554			 
4554 c5			.foundchar:	push bc 
4555 e1					pop hl 
4556 18 03				jr .findexit 
4558			 
4558			 
4558							 
4558			 
4558			.finddone:     ; got to end of string with no find 
4558 21 00 00				ld hl, 0 
455b			.findexit: 
455b			 
455b					if DEBUG_FORTH_WORDS 
455b						DMARK "FNd" 
455b f5				push af  
455c 3a 70 45			ld a, (.dmark)  
455f 32 b4 fe			ld (debug_mark),a  
4562 3a 71 45			ld a, (.dmark+1)  
4565 32 b5 fe			ld (debug_mark+1),a  
4568 3a 72 45			ld a, (.dmark+2)  
456b 32 b6 fe			ld (debug_mark+2),a  
456e 18 03			jr .pastdmark  
4570 ..			.dmark: db "FNd"  
4573 f1			.pastdmark: pop af  
4574			endm  
# End of macro DMARK
4574						CALLMONITOR 
4574 cd 57 17			call break_point_state  
4577				endm  
# End of macro CALLMONITOR
4577					endif 
4577 cd b4 1d			call forth_push_numhl 
457a			 
457a				       NEXTW 
457a c3 1d 21			jp macro_next 
457d				endm 
# End of macro NEXTW
457d			 
457d			.LEN: 
457d				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
457d 4c				db WORD_SYS_CORE+56             
457e b2 45			dw .CHAR            
4580 06				db 5 + 1 
4581 .. 00			db "COUNT",0              
4587				endm 
# End of macro CWHEAD
4587			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4587			 
4587					if DEBUG_FORTH_WORDS_KEY 
4587						DMARK "CNT" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 b4 fe			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 b5 fe			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 b6 fe			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "CNT"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0						CALLMONITOR 
45a0 cd 57 17			call break_point_state  
45a3				endm  
# End of macro CALLMONITOR
45a3					endif 
45a3			; TODO check string type 
45a3					FORTH_DSP 
45a3 cd 71 1f			call macro_forth_dsp 
45a6				endm 
# End of macro FORTH_DSP
45a6					;v5FORTH_DSP_VALUE 
45a6			 
45a6 23					inc hl 
45a7			 
45a7 3e 00				ld a, 0 
45a9 cd 43 12				call strlent 
45ac			 
45ac cd b4 1d				call forth_push_numhl 
45af			 
45af			 
45af			 
45af				       NEXTW 
45af c3 1d 21			jp macro_next 
45b2				endm 
# End of macro NEXTW
45b2			.CHAR: 
45b2				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
45b2 4d				db WORD_SYS_CORE+57             
45b3 e8 45			dw .ENDSTR            
45b5 05				db 4 + 1 
45b6 .. 00			db "CHAR",0              
45bb				endm 
# End of macro CWHEAD
45bb			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
45bb					if DEBUG_FORTH_WORDS_KEY 
45bb						DMARK "CHR" 
45bb f5				push af  
45bc 3a d0 45			ld a, (.dmark)  
45bf 32 b4 fe			ld (debug_mark),a  
45c2 3a d1 45			ld a, (.dmark+1)  
45c5 32 b5 fe			ld (debug_mark+1),a  
45c8 3a d2 45			ld a, (.dmark+2)  
45cb 32 b6 fe			ld (debug_mark+2),a  
45ce 18 03			jr .pastdmark  
45d0 ..			.dmark: db "CHR"  
45d3 f1			.pastdmark: pop af  
45d4			endm  
# End of macro DMARK
45d4						CALLMONITOR 
45d4 cd 57 17			call break_point_state  
45d7				endm  
# End of macro CALLMONITOR
45d7					endif 
45d7					FORTH_DSP 
45d7 cd 71 1f			call macro_forth_dsp 
45da				endm 
# End of macro FORTH_DSP
45da					;v5 FORTH_DSP_VALUE 
45da 23					inc hl      ; now at start of numeric as string 
45db			 
45db			;		push hl 
45db			 
45db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45db cd 63 20			call macro_forth_dsp_pop 
45de				endm 
# End of macro FORTH_DSP_POP
45de			 
45de			;		pop hl 
45de			 
45de					; push the content of a onto the stack as a value 
45de			 
45de 7e					ld a,(hl)   ; get char 
45df 26 00				ld h,0 
45e1 6f					ld l,a 
45e2 cd b4 1d				call forth_push_numhl 
45e5			 
45e5				       NEXTW 
45e5 c3 1d 21			jp macro_next 
45e8				endm 
# End of macro NEXTW
45e8			 
45e8			 
45e8			 
45e8			 
45e8			.ENDSTR: 
45e8			; eof 
45e8			 
# End of file forth_words_str.asm
45e8			include "forth_words_key.asm" 
45e8			 
45e8			; | ## Keyboard Words 
45e8			 
45e8			.KEY: 
45e8				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
45e8 3e				db WORD_SYS_CORE+42             
45e9 18 46			dw .WAITK            
45eb 04				db 3 + 1 
45ec .. 00			db "KEY",0              
45f0				endm 
# End of macro CWHEAD
45f0			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
45f0			 
45f0					if DEBUG_FORTH_WORDS_KEY 
45f0						DMARK "KEY" 
45f0 f5				push af  
45f1 3a 05 46			ld a, (.dmark)  
45f4 32 b4 fe			ld (debug_mark),a  
45f7 3a 06 46			ld a, (.dmark+1)  
45fa 32 b5 fe			ld (debug_mark+1),a  
45fd 3a 07 46			ld a, (.dmark+2)  
4600 32 b6 fe			ld (debug_mark+2),a  
4603 18 03			jr .pastdmark  
4605 ..			.dmark: db "KEY"  
4608 f1			.pastdmark: pop af  
4609			endm  
# End of macro DMARK
4609						CALLMONITOR 
4609 cd 57 17			call break_point_state  
460c				endm  
# End of macro CALLMONITOR
460c					endif 
460c			; TODO currently waits 
460c cd 32 69				call cin 
460f					;call cin_wait 
460f 6f					ld l, a 
4610 26 00				ld h, 0 
4612 cd b4 1d				call forth_push_numhl 
4615					NEXTW 
4615 c3 1d 21			jp macro_next 
4618				endm 
# End of macro NEXTW
4618			.WAITK: 
4618				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4618 3f				db WORD_SYS_CORE+43             
4619 4a 46			dw .ACCEPT            
461b 06				db 5 + 1 
461c .. 00			db "WAITK",0              
4622				endm 
# End of macro CWHEAD
4622			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4622					if DEBUG_FORTH_WORDS_KEY 
4622						DMARK "WAI" 
4622 f5				push af  
4623 3a 37 46			ld a, (.dmark)  
4626 32 b4 fe			ld (debug_mark),a  
4629 3a 38 46			ld a, (.dmark+1)  
462c 32 b5 fe			ld (debug_mark+1),a  
462f 3a 39 46			ld a, (.dmark+2)  
4632 32 b6 fe			ld (debug_mark+2),a  
4635 18 03			jr .pastdmark  
4637 ..			.dmark: db "WAI"  
463a f1			.pastdmark: pop af  
463b			endm  
# End of macro DMARK
463b						CALLMONITOR 
463b cd 57 17			call break_point_state  
463e				endm  
# End of macro CALLMONITOR
463e					endif 
463e cd 21 69				call cin_wait 
4641 6f					ld l, a 
4642 26 00				ld h, 0 
4644 cd b4 1d				call forth_push_numhl 
4647					NEXTW 
4647 c3 1d 21			jp macro_next 
464a				endm 
# End of macro NEXTW
464a			.ACCEPT: 
464a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
464a 40				db WORD_SYS_CORE+44             
464b a8 46			dw .EDIT            
464d 07				db 6 + 1 
464e .. 00			db "ACCEPT",0              
4655				endm 
# End of macro CWHEAD
4655			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4655					; TODO crashes on push 
4655					if DEBUG_FORTH_WORDS_KEY 
4655						DMARK "ACC" 
4655 f5				push af  
4656 3a 6a 46			ld a, (.dmark)  
4659 32 b4 fe			ld (debug_mark),a  
465c 3a 6b 46			ld a, (.dmark+1)  
465f 32 b5 fe			ld (debug_mark+1),a  
4662 3a 6c 46			ld a, (.dmark+2)  
4665 32 b6 fe			ld (debug_mark+2),a  
4668 18 03			jr .pastdmark  
466a ..			.dmark: db "ACC"  
466d f1			.pastdmark: pop af  
466e			endm  
# End of macro DMARK
466e						CALLMONITOR 
466e cd 57 17			call break_point_state  
4671				endm  
# End of macro CALLMONITOR
4671					endif 
4671 21 58 f6				ld hl, os_input 
4674 3e 00				ld a, 0 
4676 77					ld (hl),a 
4677 3a c3 fc				ld a,(f_cursor_ptr) 
467a 16 64				ld d, 100 
467c 0e 00				ld c, 0 
467e 1e 28				ld e, 40 
4680 cd 07 0e				call input_str 
4683					; TODO perhaps do a type check and wrap in quotes if not a number 
4683 21 58 f6				ld hl, os_input 
4686					if DEBUG_FORTH_WORDS 
4686						DMARK "AC1" 
4686 f5				push af  
4687 3a 9b 46			ld a, (.dmark)  
468a 32 b4 fe			ld (debug_mark),a  
468d 3a 9c 46			ld a, (.dmark+1)  
4690 32 b5 fe			ld (debug_mark+1),a  
4693 3a 9d 46			ld a, (.dmark+2)  
4696 32 b6 fe			ld (debug_mark+2),a  
4699 18 03			jr .pastdmark  
469b ..			.dmark: db "AC1"  
469e f1			.pastdmark: pop af  
469f			endm  
# End of macro DMARK
469f						CALLMONITOR 
469f cd 57 17			call break_point_state  
46a2				endm  
# End of macro CALLMONITOR
46a2					endif 
46a2 cd 22 1e				call forth_push_str 
46a5					NEXTW 
46a5 c3 1d 21			jp macro_next 
46a8				endm 
# End of macro NEXTW
46a8			 
46a8			.EDIT: 
46a8				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
46a8 40				db WORD_SYS_CORE+44             
46a9 4a 47			dw .ENDKEY            
46ab 05				db 4 + 1 
46ac .. 00			db "EDIT",0              
46b1				endm 
# End of macro CWHEAD
46b1			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
46b1			 
46b1					; TODO does not copy from stack 
46b1					if DEBUG_FORTH_WORDS_KEY 
46b1						DMARK "EDT" 
46b1 f5				push af  
46b2 3a c6 46			ld a, (.dmark)  
46b5 32 b4 fe			ld (debug_mark),a  
46b8 3a c7 46			ld a, (.dmark+1)  
46bb 32 b5 fe			ld (debug_mark+1),a  
46be 3a c8 46			ld a, (.dmark+2)  
46c1 32 b6 fe			ld (debug_mark+2),a  
46c4 18 03			jr .pastdmark  
46c6 ..			.dmark: db "EDT"  
46c9 f1			.pastdmark: pop af  
46ca			endm  
# End of macro DMARK
46ca						CALLMONITOR 
46ca cd 57 17			call break_point_state  
46cd				endm  
# End of macro CALLMONITOR
46cd					endif 
46cd			 
46cd					;FORTH_DSP 
46cd					FORTH_DSP_VALUEHL 
46cd cd ab 1f			call macro_dsp_valuehl 
46d0				endm 
# End of macro FORTH_DSP_VALUEHL
46d0			;		inc hl    ; TODO do type check 
46d0			 
46d0			;		call get_word_hl 
46d0 e5					push hl 
46d1					if DEBUG_FORTH_WORDS 
46d1						DMARK "EDp" 
46d1 f5				push af  
46d2 3a e6 46			ld a, (.dmark)  
46d5 32 b4 fe			ld (debug_mark),a  
46d8 3a e7 46			ld a, (.dmark+1)  
46db 32 b5 fe			ld (debug_mark+1),a  
46de 3a e8 46			ld a, (.dmark+2)  
46e1 32 b6 fe			ld (debug_mark+2),a  
46e4 18 03			jr .pastdmark  
46e6 ..			.dmark: db "EDp"  
46e9 f1			.pastdmark: pop af  
46ea			endm  
# End of macro DMARK
46ea						CALLMONITOR 
46ea cd 57 17			call break_point_state  
46ed				endm  
# End of macro CALLMONITOR
46ed					endif 
46ed				;	ld a, 0 
46ed cd 38 12				call strlenz 
46f0 23					inc hl 
46f1			 
46f1 06 00				ld b, 0 
46f3 4d					ld c, l 
46f4			 
46f4 e1					pop hl 
46f5 11 58 f6				ld de, os_input 
46f8					if DEBUG_FORTH_WORDS_KEY 
46f8						DMARK "EDc" 
46f8 f5				push af  
46f9 3a 0d 47			ld a, (.dmark)  
46fc 32 b4 fe			ld (debug_mark),a  
46ff 3a 0e 47			ld a, (.dmark+1)  
4702 32 b5 fe			ld (debug_mark+1),a  
4705 3a 0f 47			ld a, (.dmark+2)  
4708 32 b6 fe			ld (debug_mark+2),a  
470b 18 03			jr .pastdmark  
470d ..			.dmark: db "EDc"  
4710 f1			.pastdmark: pop af  
4711			endm  
# End of macro DMARK
4711						CALLMONITOR 
4711 cd 57 17			call break_point_state  
4714				endm  
# End of macro CALLMONITOR
4714					endif 
4714 ed b0				ldir 
4716			 
4716			 
4716 21 58 f6				ld hl, os_input 
4719					;ld a, 0 
4719					;ld (hl),a 
4719 3a c3 fc				ld a,(f_cursor_ptr) 
471c 16 64				ld d, 100 
471e 0e 00				ld c, 0 
4720 1e 28				ld e, 40 
4722 cd 07 0e				call input_str 
4725					; TODO perhaps do a type check and wrap in quotes if not a number 
4725 21 58 f6				ld hl, os_input 
4728					if DEBUG_FORTH_WORDS 
4728						DMARK "ED1" 
4728 f5				push af  
4729 3a 3d 47			ld a, (.dmark)  
472c 32 b4 fe			ld (debug_mark),a  
472f 3a 3e 47			ld a, (.dmark+1)  
4732 32 b5 fe			ld (debug_mark+1),a  
4735 3a 3f 47			ld a, (.dmark+2)  
4738 32 b6 fe			ld (debug_mark+2),a  
473b 18 03			jr .pastdmark  
473d ..			.dmark: db "ED1"  
4740 f1			.pastdmark: pop af  
4741			endm  
# End of macro DMARK
4741						CALLMONITOR 
4741 cd 57 17			call break_point_state  
4744				endm  
# End of macro CALLMONITOR
4744					endif 
4744 cd 22 1e				call forth_push_str 
4747					NEXTW 
4747 c3 1d 21			jp macro_next 
474a				endm 
# End of macro NEXTW
474a			 
474a			 
474a			 
474a			.ENDKEY: 
474a			; eof 
474a			 
# End of file forth_words_key.asm
474a			 
474a			if STORAGE_SE 
474a			   	include "forth_words_storage.asm" 
474a			 
474a			; | ## Fixed Storage Words 
474a			 
474a			.RECORD: 
474a			  
474a				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
474a 3a				db WORD_SYS_CORE+38             
474b ee 47			dw .BREAD            
474d 07				db 6 + 1 
474e .. 00			db "RECORD",0              
4755				endm 
# End of macro CWHEAD
4755			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4755			 
4755					if DEBUG_FORTH_WORDS_KEY 
4755						DMARK "REC" 
4755 f5				push af  
4756 3a 6a 47			ld a, (.dmark)  
4759 32 b4 fe			ld (debug_mark),a  
475c 3a 6b 47			ld a, (.dmark+1)  
475f 32 b5 fe			ld (debug_mark+1),a  
4762 3a 6c 47			ld a, (.dmark+2)  
4765 32 b6 fe			ld (debug_mark+2),a  
4768 18 03			jr .pastdmark  
476a ..			.dmark: db "REC"  
476d f1			.pastdmark: pop af  
476e			endm  
# End of macro DMARK
476e						CALLMONITOR 
476e cd 57 17			call break_point_state  
4771				endm  
# End of macro CALLMONITOR
4771					endif 
4771			 
4771					FORTH_DSP_VALUEHL 
4771 cd ab 1f			call macro_dsp_valuehl 
4774				endm 
# End of macro FORTH_DSP_VALUEHL
4774			 
4774 e5					push hl    ; id 
4775			 
4775					FORTH_DSP_POP 
4775 cd 63 20			call macro_forth_dsp_pop 
4778				endm 
# End of macro FORTH_DSP_POP
4778			 
4778					FORTH_DSP_VALUEHL 
4778 cd ab 1f			call macro_dsp_valuehl 
477b				endm 
# End of macro FORTH_DSP_VALUEHL
477b			 
477b					FORTH_DSP_POP 
477b cd 63 20			call macro_forth_dsp_pop 
477e				endm 
# End of macro FORTH_DSP_POP
477e			 
477e d1					pop de     ; get file id 
477f			 
477f					; e = file id 
477f					; l = file extent 
477f			 
477f			 
477f					; construct request to access file extent 
477f			 
477f			;		ld a, e 
477f 63					ld h, e 
4780					 
4780					 
4780					 
4780			 
4780					; e has id 
4780			 
4780 11 df fc			ld de, store_page 
4783					if DEBUG_FORTH_WORDS 
4783						DMARK "REr" 
4783 f5				push af  
4784 3a 98 47			ld a, (.dmark)  
4787 32 b4 fe			ld (debug_mark),a  
478a 3a 99 47			ld a, (.dmark+1)  
478d 32 b5 fe			ld (debug_mark+1),a  
4790 3a 9a 47			ld a, (.dmark+2)  
4793 32 b6 fe			ld (debug_mark+2),a  
4796 18 03			jr .pastdmark  
4798 ..			.dmark: db "REr"  
479b f1			.pastdmark: pop af  
479c			endm  
# End of macro DMARK
479c						CALLMONITOR 
479c cd 57 17			call break_point_state  
479f				endm  
# End of macro CALLMONITOR
479f					endif 
479f cd 11 09				call storage_read 
47a2 cd 03 0e			call ishlzero 
47a5 28 22			jr z, .recnotfound 
47a7			 
47a7			 
47a7					if DEBUG_FORTH_WORDS 
47a7						DMARK "REe" 
47a7 f5				push af  
47a8 3a bc 47			ld a, (.dmark)  
47ab 32 b4 fe			ld (debug_mark),a  
47ae 3a bd 47			ld a, (.dmark+1)  
47b1 32 b5 fe			ld (debug_mark+1),a  
47b4 3a be 47			ld a, (.dmark+2)  
47b7 32 b6 fe			ld (debug_mark+2),a  
47ba 18 03			jr .pastdmark  
47bc ..			.dmark: db "REe"  
47bf f1			.pastdmark: pop af  
47c0			endm  
# End of macro DMARK
47c0						CALLMONITOR 
47c0 cd 57 17			call break_point_state  
47c3				endm  
# End of macro CALLMONITOR
47c3					endif 
47c3 cd 22 1e			call forth_push_str 
47c6			 
47c6					NEXTW 
47c6 c3 1d 21			jp macro_next 
47c9				endm 
# End of macro NEXTW
47c9			 
47c9			.recnotfound: 
47c9					if DEBUG_FORTH_WORDS 
47c9						DMARK "REf" 
47c9 f5				push af  
47ca 3a de 47			ld a, (.dmark)  
47cd 32 b4 fe			ld (debug_mark),a  
47d0 3a df 47			ld a, (.dmark+1)  
47d3 32 b5 fe			ld (debug_mark+1),a  
47d6 3a e0 47			ld a, (.dmark+2)  
47d9 32 b6 fe			ld (debug_mark+2),a  
47dc 18 03			jr .pastdmark  
47de ..			.dmark: db "REf"  
47e1 f1			.pastdmark: pop af  
47e2			endm  
# End of macro DMARK
47e2						CALLMONITOR 
47e2 cd 57 17			call break_point_state  
47e5				endm  
# End of macro CALLMONITOR
47e5					endif 
47e5 21 ff 00			ld hl, 255 
47e8 cd b4 1d			call forth_push_numhl 
47eb				NEXTW 
47eb c3 1d 21			jp macro_next 
47ee				endm 
# End of macro NEXTW
47ee			 
47ee			 
47ee			.BREAD: 
47ee			  
47ee				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
47ee 3a				db WORD_SYS_CORE+38             
47ef 71 48			dw .BWRITE            
47f1 06				db 5 + 1 
47f2 .. 00			db "BREAD",0              
47f8				endm 
# End of macro CWHEAD
47f8			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
47f8				 
47f8					if DEBUG_FORTH_WORDS_KEY 
47f8						DMARK "BRD" 
47f8 f5				push af  
47f9 3a 0d 48			ld a, (.dmark)  
47fc 32 b4 fe			ld (debug_mark),a  
47ff 3a 0e 48			ld a, (.dmark+1)  
4802 32 b5 fe			ld (debug_mark+1),a  
4805 3a 0f 48			ld a, (.dmark+2)  
4808 32 b6 fe			ld (debug_mark+2),a  
480b 18 03			jr .pastdmark  
480d ..			.dmark: db "BRD"  
4810 f1			.pastdmark: pop af  
4811			endm  
# End of macro DMARK
4811						CALLMONITOR 
4811 cd 57 17			call break_point_state  
4814				endm  
# End of macro CALLMONITOR
4814					endif 
4814			 
4814				FORTH_DSP_VALUEHL 
4814 cd ab 1f			call macro_dsp_valuehl 
4817				endm 
# End of macro FORTH_DSP_VALUEHL
4817			 
4817				FORTH_DSP_POP 
4817 cd 63 20			call macro_forth_dsp_pop 
481a				endm 
# End of macro FORTH_DSP_POP
481a			 
481a				; calc block address 
481a			 
481a eb				ex de, hl 
481b 3e 40			ld a, STORE_BLOCK_PHY 
481d cd 5d 0d			call Mult16 
4820			 
4820			 
4820 11 df fc			ld de, store_page 
4823			 
4823					if DEBUG_FORTH_WORDS 
4823						DMARK "BR1" 
4823 f5				push af  
4824 3a 38 48			ld a, (.dmark)  
4827 32 b4 fe			ld (debug_mark),a  
482a 3a 39 48			ld a, (.dmark+1)  
482d 32 b5 fe			ld (debug_mark+1),a  
4830 3a 3a 48			ld a, (.dmark+2)  
4833 32 b6 fe			ld (debug_mark+2),a  
4836 18 03			jr .pastdmark  
4838 ..			.dmark: db "BR1"  
483b f1			.pastdmark: pop af  
483c			endm  
# End of macro DMARK
483c						CALLMONITOR 
483c cd 57 17			call break_point_state  
483f				endm  
# End of macro CALLMONITOR
483f					endif 
483f			 
483f cd b8 03			call storage_read_block 
4842			 
4842 cd 03 0e			call ishlzero 
4845 20 05			jr nz, .brfound 
4847			 
4847 cd b4 1d			call forth_push_numhl 
484a 18 22			jr .brdone 
484c			 
484c			 
484c			.brfound: 
484c 21 e1 fc		        ld hl, store_page+2 
484f			 
484f					if DEBUG_FORTH_WORDS 
484f						DMARK "BR2" 
484f f5				push af  
4850 3a 64 48			ld a, (.dmark)  
4853 32 b4 fe			ld (debug_mark),a  
4856 3a 65 48			ld a, (.dmark+1)  
4859 32 b5 fe			ld (debug_mark+1),a  
485c 3a 66 48			ld a, (.dmark+2)  
485f 32 b6 fe			ld (debug_mark+2),a  
4862 18 03			jr .pastdmark  
4864 ..			.dmark: db "BR2"  
4867 f1			.pastdmark: pop af  
4868			endm  
# End of macro DMARK
4868						CALLMONITOR 
4868 cd 57 17			call break_point_state  
486b				endm  
# End of macro CALLMONITOR
486b					endif 
486b			 
486b cd 22 1e			call forth_push_str 
486e			 
486e			 
486e			.brdone: 
486e			 
486e					NEXTW 
486e c3 1d 21			jp macro_next 
4871				endm 
# End of macro NEXTW
4871			.BWRITE: 
4871				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4871 3a				db WORD_SYS_CORE+38             
4872 06 49			dw .BUPD            
4874 07				db 6 + 1 
4875 .. 00			db "BWRITE",0              
487c				endm 
# End of macro CWHEAD
487c			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
487c			 
487c					if DEBUG_FORTH_WORDS_KEY 
487c						DMARK "BWR" 
487c f5				push af  
487d 3a 91 48			ld a, (.dmark)  
4880 32 b4 fe			ld (debug_mark),a  
4883 3a 92 48			ld a, (.dmark+1)  
4886 32 b5 fe			ld (debug_mark+1),a  
4889 3a 93 48			ld a, (.dmark+2)  
488c 32 b6 fe			ld (debug_mark+2),a  
488f 18 03			jr .pastdmark  
4891 ..			.dmark: db "BWR"  
4894 f1			.pastdmark: pop af  
4895			endm  
# End of macro DMARK
4895						CALLMONITOR 
4895 cd 57 17			call break_point_state  
4898				endm  
# End of macro CALLMONITOR
4898					endif 
4898			 
4898				FORTH_DSP_VALUEHL 
4898 cd ab 1f			call macro_dsp_valuehl 
489b				endm 
# End of macro FORTH_DSP_VALUEHL
489b			 
489b				; calc block address 
489b			 
489b eb				ex de, hl 
489c 3e 40			ld a, STORE_BLOCK_PHY 
489e cd 5d 0d			call Mult16 
48a1			 
48a1 e5				push hl         ; address 
48a2			 
48a2				FORTH_DSP_POP 
48a2 cd 63 20			call macro_forth_dsp_pop 
48a5				endm 
# End of macro FORTH_DSP_POP
48a5			 
48a5				FORTH_DSP_VALUEHL 
48a5 cd ab 1f			call macro_dsp_valuehl 
48a8				endm 
# End of macro FORTH_DSP_VALUEHL
48a8			 
48a8				FORTH_DSP_POP 
48a8 cd 63 20			call macro_forth_dsp_pop 
48ab				endm 
# End of macro FORTH_DSP_POP
48ab			 
48ab cd e6 0a			call storage_clear_page 
48ae			 
48ae				; copy string to store page 
48ae			 
48ae e5				push hl     ; save string address 
48af			 
48af 3e 00			ld a, 0 
48b1 cd 43 12			call strlent 
48b4			 
48b4 23				inc hl 
48b5			 
48b5 4d				ld c, l 
48b6 06 00			ld b, 0 
48b8			 
48b8 e1				pop hl 
48b9 11 e1 fc			ld de, store_page + 2 
48bc					if DEBUG_FORTH_WORDS 
48bc						DMARK "BW1" 
48bc f5				push af  
48bd 3a d1 48			ld a, (.dmark)  
48c0 32 b4 fe			ld (debug_mark),a  
48c3 3a d2 48			ld a, (.dmark+1)  
48c6 32 b5 fe			ld (debug_mark+1),a  
48c9 3a d3 48			ld a, (.dmark+2)  
48cc 32 b6 fe			ld (debug_mark+2),a  
48cf 18 03			jr .pastdmark  
48d1 ..			.dmark: db "BW1"  
48d4 f1			.pastdmark: pop af  
48d5			endm  
# End of macro DMARK
48d5						CALLMONITOR 
48d5 cd 57 17			call break_point_state  
48d8				endm  
# End of macro CALLMONITOR
48d8					endif 
48d8 ed b0			ldir 
48da			 
48da			 
48da				; poke the start of the block with flags to prevent high level file ops hitting the block 
48da			 
48da 21 ff ff			ld hl, $ffff 
48dd			 
48dd 22 df fc			ld (store_page), hl	 
48e0				 
48e0 e1				pop hl    ; get address 
48e1 11 df fc			ld de, store_page 
48e4			 
48e4					if DEBUG_FORTH_WORDS 
48e4						DMARK "BW2" 
48e4 f5				push af  
48e5 3a f9 48			ld a, (.dmark)  
48e8 32 b4 fe			ld (debug_mark),a  
48eb 3a fa 48			ld a, (.dmark+1)  
48ee 32 b5 fe			ld (debug_mark+1),a  
48f1 3a fb 48			ld a, (.dmark+2)  
48f4 32 b6 fe			ld (debug_mark+2),a  
48f7 18 03			jr .pastdmark  
48f9 ..			.dmark: db "BW2"  
48fc f1			.pastdmark: pop af  
48fd			endm  
# End of macro DMARK
48fd						CALLMONITOR 
48fd cd 57 17			call break_point_state  
4900				endm  
# End of macro CALLMONITOR
4900					endif 
4900			 
4900 cd 1d 04			call storage_write_block 
4903			 
4903					NEXTW 
4903 c3 1d 21			jp macro_next 
4906				endm 
# End of macro NEXTW
4906			 
4906			.BUPD: 
4906				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4906 3a				db WORD_SYS_CORE+38             
4907 5c 49			dw .BYID            
4909 05				db 4 + 1 
490a .. 00			db "BUPD",0              
490f				endm 
# End of macro CWHEAD
490f			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
490f			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
490f			; | | or completely different file system structure. 
490f			 
490f					if DEBUG_FORTH_WORDS_KEY 
490f						DMARK "BUD" 
490f f5				push af  
4910 3a 24 49			ld a, (.dmark)  
4913 32 b4 fe			ld (debug_mark),a  
4916 3a 25 49			ld a, (.dmark+1)  
4919 32 b5 fe			ld (debug_mark+1),a  
491c 3a 26 49			ld a, (.dmark+2)  
491f 32 b6 fe			ld (debug_mark+2),a  
4922 18 03			jr .pastdmark  
4924 ..			.dmark: db "BUD"  
4927 f1			.pastdmark: pop af  
4928			endm  
# End of macro DMARK
4928						CALLMONITOR 
4928 cd 57 17			call break_point_state  
492b				endm  
# End of macro CALLMONITOR
492b					endif 
492b			 
492b				FORTH_DSP_VALUEHL 
492b cd ab 1f			call macro_dsp_valuehl 
492e				endm 
# End of macro FORTH_DSP_VALUEHL
492e			 
492e				; calc block address 
492e			 
492e eb				ex de, hl 
492f 3e 40			ld a, STORE_BLOCK_PHY 
4931 cd 5d 0d			call Mult16 
4934			 
4934				FORTH_DSP_POP 
4934 cd 63 20			call macro_forth_dsp_pop 
4937				endm 
# End of macro FORTH_DSP_POP
4937			 
4937			 
4937 11 df fc			ld de, store_page 
493a			 
493a					if DEBUG_FORTH_WORDS 
493a						DMARK "BUe" 
493a f5				push af  
493b 3a 4f 49			ld a, (.dmark)  
493e 32 b4 fe			ld (debug_mark),a  
4941 3a 50 49			ld a, (.dmark+1)  
4944 32 b5 fe			ld (debug_mark+1),a  
4947 3a 51 49			ld a, (.dmark+2)  
494a 32 b6 fe			ld (debug_mark+2),a  
494d 18 03			jr .pastdmark  
494f ..			.dmark: db "BUe"  
4952 f1			.pastdmark: pop af  
4953			endm  
# End of macro DMARK
4953						CALLMONITOR 
4953 cd 57 17			call break_point_state  
4956				endm  
# End of macro CALLMONITOR
4956					endif 
4956			 
4956 cd 1d 04			call storage_write_block 
4959			 
4959					NEXTW 
4959 c3 1d 21			jp macro_next 
495c				endm 
# End of macro NEXTW
495c			 
495c			.BYID: 
495c			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
495c			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
495c			; 
495c			;		 
495c			;		if DEBUG_FORTH_WORDS_KEY 
495c			;			DMARK "BYID" 
495c			;			CALLMONITOR 
495c			;		endif 
495c			; 
495c			;		; get direct address 
495c			; 
495c			;		FORTH_DSP_VALUEHL 
495c			; 
495c			;		FORTH_DSP_POP 
495c			; 
495c			;	; calc block address 
495c			; 
495c			;	ex de, hl 
495c			;	ld a, STORE_BLOCK_PHY 
495c			;	call Mult16 
495c			;	;	do BREAD with number as param 
495c			;	; push the file name	 
495c			;	ld de, store_page 
495c			;	call storage_read_block 
495c			 ;       ld hl, store_page+2 
495c			; 
495c			; 
495c			;		NEXTW 
495c			;.BYNAME: 
495c				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
495c 3a				db WORD_SYS_CORE+38             
495d 75 49			dw .DIR            
495f 06				db 5 + 1 
4960 .. 00			db "GETID",0              
4966				endm 
# End of macro CWHEAD
4966			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4966			 
4966					; get pointer to file name to seek 
4966			 
4966					FORTH_DSP_VALUEHL 
4966 cd ab 1f			call macro_dsp_valuehl 
4969				endm 
# End of macro FORTH_DSP_VALUEHL
4969			 
4969			 
4969 cd df 02				call storage_getid  
496c			 
496c					FORTH_DSP_POP 
496c cd 63 20			call macro_forth_dsp_pop 
496f				endm 
# End of macro FORTH_DSP_POP
496f			 
496f cd b4 1d				call forth_push_numhl 
4972			 
4972					NEXTW 
4972 c3 1d 21			jp macro_next 
4975				endm 
# End of macro NEXTW
4975			; 
4975			.DIR: 
4975				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4975 3a				db WORD_SYS_CORE+38             
4976 79 4a			dw .SAVE            
4978 04				db 3 + 1 
4979 .. 00			db "DIR",0              
497d				endm 
# End of macro CWHEAD
497d			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
497d			 
497d					if DEBUG_FORTH_WORDS_KEY 
497d						DMARK "DIR" 
497d f5				push af  
497e 3a 92 49			ld a, (.dmark)  
4981 32 b4 fe			ld (debug_mark),a  
4984 3a 93 49			ld a, (.dmark+1)  
4987 32 b5 fe			ld (debug_mark+1),a  
498a 3a 94 49			ld a, (.dmark+2)  
498d 32 b6 fe			ld (debug_mark+2),a  
4990 18 03			jr .pastdmark  
4992 ..			.dmark: db "DIR"  
4995 f1			.pastdmark: pop af  
4996			endm  
# End of macro DMARK
4996						CALLMONITOR 
4996 cd 57 17			call break_point_state  
4999				endm  
# End of macro CALLMONITOR
4999					endif 
4999 cd 69 04			call storage_get_block_0 
499c			 
499c 21 df fc			ld hl, store_page     ; get current id count 
499f 46				ld b, (hl) 
49a0 0e 00			ld c, 0    ; count of files   
49a2					if DEBUG_FORTH_WORDS 
49a2						DMARK "DI1" 
49a2 f5				push af  
49a3 3a b7 49			ld a, (.dmark)  
49a6 32 b4 fe			ld (debug_mark),a  
49a9 3a b8 49			ld a, (.dmark+1)  
49ac 32 b5 fe			ld (debug_mark+1),a  
49af 3a b9 49			ld a, (.dmark+2)  
49b2 32 b6 fe			ld (debug_mark+2),a  
49b5 18 03			jr .pastdmark  
49b7 ..			.dmark: db "DI1"  
49ba f1			.pastdmark: pop af  
49bb			endm  
# End of macro DMARK
49bb						CALLMONITOR 
49bb cd 57 17			call break_point_state  
49be				endm  
# End of macro CALLMONITOR
49be					endif 
49be			 
49be				; check for empty drive 
49be			 
49be 3e 00			ld a, 0 
49c0 b8				cp b 
49c1 ca 2f 4a			jp z, .dirdone 
49c4			 
49c4				; for each of the current ids do a search for them and if found push to stack 
49c4			 
49c4 c5			.diritem:	push bc 
49c5 21 40 00				ld hl, STORE_BLOCK_PHY 
49c8 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
49ca 58					ld e,b 
49cb			 
49cb			;		if DEBUG_FORTH_WORDS 
49cb			;			DMARK "DI2" 
49cb			;			CALLMONITOR 
49cb			;		endif 
49cb			 
49cb cd eb 06				call storage_findnextid 
49ce			 
49ce			;		if DEBUG_FORTH_WORDS 
49ce			;			DMARK "DI3" 
49ce			;			CALLMONITOR 
49ce			;		endif 
49ce			 
49ce					; if found hl will be non zero 
49ce			 
49ce cd 03 0e				call ishlzero 
49d1			;		ld a, l 
49d1			;		add h 
49d1			; 
49d1			;		cp 0 
49d1 28 59				jr z, .dirnotfound 
49d3			 
49d3					; increase count 
49d3			 
49d3 c1					pop bc	 
49d4 0c					inc c 
49d5 c5					push bc 
49d6					 
49d6			 
49d6					; get file header and push the file name 
49d6			 
49d6 11 df fc				ld de, store_page 
49d9 cd b8 03				call storage_read_block 
49dc			 
49dc					; push file id to stack 
49dc				 
49dc 3a df fc				ld a, (store_page) 
49df 26 00				ld h, 0 
49e1 6f					ld l, a 
49e2 cd b4 1d				call forth_push_numhl 
49e5			 
49e5					; push extent count to stack  
49e5				 
49e5 3a e1 fc				ld a, (store_page+2) 
49e8 26 00				ld h, 0 
49ea 6f					ld l, a 
49eb cd b4 1d				call forth_push_numhl 
49ee			 
49ee					; push file name 
49ee			 
49ee 21 e2 fc				ld hl, store_page+3 
49f1					if DEBUG_FORTH_WORDS 
49f1						DMARK "DI5" 
49f1 f5				push af  
49f2 3a 06 4a			ld a, (.dmark)  
49f5 32 b4 fe			ld (debug_mark),a  
49f8 3a 07 4a			ld a, (.dmark+1)  
49fb 32 b5 fe			ld (debug_mark+1),a  
49fe 3a 08 4a			ld a, (.dmark+2)  
4a01 32 b6 fe			ld (debug_mark+2),a  
4a04 18 03			jr .pastdmark  
4a06 ..			.dmark: db "DI5"  
4a09 f1			.pastdmark: pop af  
4a0a			endm  
# End of macro DMARK
4a0a						CALLMONITOR 
4a0a cd 57 17			call break_point_state  
4a0d				endm  
# End of macro CALLMONITOR
4a0d					endif 
4a0d cd 22 1e				call forth_push_str 
4a10					if DEBUG_FORTH_WORDS 
4a10						DMARK "DI6" 
4a10 f5				push af  
4a11 3a 25 4a			ld a, (.dmark)  
4a14 32 b4 fe			ld (debug_mark),a  
4a17 3a 26 4a			ld a, (.dmark+1)  
4a1a 32 b5 fe			ld (debug_mark+1),a  
4a1d 3a 27 4a			ld a, (.dmark+2)  
4a20 32 b6 fe			ld (debug_mark+2),a  
4a23 18 03			jr .pastdmark  
4a25 ..			.dmark: db "DI6"  
4a28 f1			.pastdmark: pop af  
4a29			endm  
# End of macro DMARK
4a29						CALLMONITOR 
4a29 cd 57 17			call break_point_state  
4a2c				endm  
# End of macro CALLMONITOR
4a2c					endif 
4a2c			.dirnotfound: 
4a2c c1					pop bc     
4a2d 10 95				djnz .diritem 
4a2f				 
4a2f			.dirdone:	 
4a2f					if DEBUG_FORTH_WORDS 
4a2f						DMARK "DI7" 
4a2f f5				push af  
4a30 3a 44 4a			ld a, (.dmark)  
4a33 32 b4 fe			ld (debug_mark),a  
4a36 3a 45 4a			ld a, (.dmark+1)  
4a39 32 b5 fe			ld (debug_mark+1),a  
4a3c 3a 46 4a			ld a, (.dmark+2)  
4a3f 32 b6 fe			ld (debug_mark+2),a  
4a42 18 03			jr .pastdmark  
4a44 ..			.dmark: db "DI7"  
4a47 f1			.pastdmark: pop af  
4a48			endm  
# End of macro DMARK
4a48						CALLMONITOR 
4a48 cd 57 17			call break_point_state  
4a4b				endm  
# End of macro CALLMONITOR
4a4b					endif 
4a4b			 
4a4b					; push a count of the dir items found 
4a4b			 
4a4b 26 00				ld h, 0 
4a4d 69					ld l, c 
4a4e cd b4 1d				call forth_push_numhl 
4a51			 
4a51					; push the bank label 
4a51			 
4a51 cd 69 04				call storage_get_block_0 
4a54			 
4a54				 
4a54 21 e2 fc		 		ld hl, store_page+3 
4a57			 
4a57					if DEBUG_FORTH_WORDS 
4a57						DMARK "DI8" 
4a57 f5				push af  
4a58 3a 6c 4a			ld a, (.dmark)  
4a5b 32 b4 fe			ld (debug_mark),a  
4a5e 3a 6d 4a			ld a, (.dmark+1)  
4a61 32 b5 fe			ld (debug_mark+1),a  
4a64 3a 6e 4a			ld a, (.dmark+2)  
4a67 32 b6 fe			ld (debug_mark+2),a  
4a6a 18 03			jr .pastdmark  
4a6c ..			.dmark: db "DI8"  
4a6f f1			.pastdmark: pop af  
4a70			endm  
# End of macro DMARK
4a70						CALLMONITOR 
4a70 cd 57 17			call break_point_state  
4a73				endm  
# End of macro CALLMONITOR
4a73					endif 
4a73 cd 22 1e				call forth_push_str 
4a76			 
4a76			 
4a76				 
4a76					NEXTW 
4a76 c3 1d 21			jp macro_next 
4a79				endm 
# End of macro NEXTW
4a79			.SAVE: 
4a79			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4a79			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4a79			;		NEXTW 
4a79			;.LOAD: 
4a79			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4a79			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4a79			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4a79			;; > > The LOAD command can not be used in any user words or compound lines. 
4a79			; 
4a79			;		; store_openext use it. If zero it is EOF 
4a79			; 
4a79			;		; read block from current stream id 
4a79			;		; if the block does not contain zero term keep reading blocks until zero found 
4a79			;		; push the block to stack 
4a79			;		; save the block id to stream 
4a79			; 
4a79			; 
4a79			;		FORTH_DSP_VALUEHL 
4a79			; 
4a79			;;		push hl 
4a79			; 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LOA" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			;		FORTH_DSP_POP 
4a79			; 
4a79			;;		pop hl 
4a79			; 
4a79			;		ld h, l 
4a79			;		ld l, 0 
4a79			; 
4a79			;		push hl     ; stack holds current file id and extent to work with 
4a79			; 
4a79			; 
4a79			;		ld de, store_page      ; get block zero of file 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LO0" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			;		call storage_read 
4a79			; 
4a79			;		ld a, (store_page+2)    ; max extents for this file 
4a79			;		ld  (store_openmaxext),a   ; get our limit 
4a79			; 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LOE" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			; 
4a79			;; TODO dont know why max extents are not present 
4a79			;;		cp 0 
4a79			;;		jp z, .loadeof     ; dont read past eof 
4a79			; 
4a79			;;		ld a, 1   ; start from the head of the file 
4a79			; 
4a79			;.loadline:	pop hl 
4a79			;		inc hl 
4a79			;		ld  a, (store_openmaxext)   ; get our limit 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LOx" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			;		inc a 
4a79			;		cp l 
4a79			;		jp z, .loadeof 
4a79			;		push hl    ; save current extent 
4a79			; 
4a79			;		ld de, store_page 
4a79			; 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LO1" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			;		call storage_read 
4a79			; 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LO2" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			;	call ishlzero 
4a79			;	ld a, l 
4a79			;	add h 
4a79			;	cp 0 
4a79			;	jr z, .loadeof 
4a79			; 
4a79			;	; not eof so hl should point to data to exec 
4a79			; 
4a79			;	; will need to add the FORTH_END_BUFFER flag 
4a79			 ; 
4a79			;	ld hl, store_page+2 
4a79			;	ld bc, 255 
4a79			;	ld a, 0 
4a79			;	cpir 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LOt" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			;	dec hl 
4a79			;	ld a, ' ' 
4a79			;	ld (hl), a 
4a79			;	inc hl 
4a79			;	ld (hl), a 
4a79			;	inc hl 
4a79			;	ld (hl), a 
4a79			;	inc hl 
4a79			;	ld a, FORTH_END_BUFFER 
4a79			;	ld (hl), a 
4a79			; 
4a79			;	; TODO handle more than a single block read 
4a79			; 
4a79			; 
4a79			;	ld hl, store_page+2 
4a79			; 
4a79			;	ld (os_tok_ptr), hl 
4a79			; 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LO3" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			; 
4a79			;	call forthparse 
4a79			;	call forthexec 
4a79			;	call forthexec_cleanup 
4a79			; 
4a79			;	; go to next extent 
4a79			; 
4a79			;	; get next block  or mark as eof 
4a79			;	jp .loadline 
4a79			; 
4a79			; 
4a79			; 
4a79			;	       NEXTW 
4a79			;.loadeof:	ld a, 0 
4a79			;		ld (store_openext), a 
4a79			; 
4a79			;	if DEBUG_STORESE 
4a79			;		DMARK "LOF" 
4a79			;		CALLMONITOR 
4a79			;	endif 
4a79			;		ret 
4a79			;		;NEXTW 
4a79			;.BSAVE:   
4a79			; 
4a79			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4a79			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4a79			;		NEXTW 
4a79			;.BLOAD: 
4a79			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4a79			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4a79			;		NEXTW 
4a79			;;;; counter gap 
4a79			 
4a79			 
4a79			.SEO: 
4a79				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4a79 64				db WORD_SYS_CORE+80             
4a7a 98 4a			dw .SEI            
4a7c 04				db 3 + 1 
4a7d .. 00			db "SEO",0              
4a81				endm 
# End of macro CWHEAD
4a81			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4a81			 
4a81					; get port 
4a81			 
4a81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a81 cd ab 1f			call macro_dsp_valuehl 
4a84				endm 
# End of macro FORTH_DSP_VALUEHL
4a84			 
4a84 e5					push hl    ; u2 - byte 
4a85			 
4a85					; destroy value TOS 
4a85			 
4a85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a85 cd 63 20			call macro_forth_dsp_pop 
4a88				endm 
# End of macro FORTH_DSP_POP
4a88			 
4a88					; get byte to send 
4a88			 
4a88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a88 cd ab 1f			call macro_dsp_valuehl 
4a8b				endm 
# End of macro FORTH_DSP_VALUEHL
4a8b			 
4a8b e5					push hl    ; u1 - addr 
4a8c			 
4a8c					; destroy value TOS 
4a8c			 
4a8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a8c cd 63 20			call macro_forth_dsp_pop 
4a8f				endm 
# End of macro FORTH_DSP_POP
4a8f			 
4a8f					; one value on hl get other one back 
4a8f			 
4a8f d1					pop de   ; u1 - byte 
4a90			 
4a90 e1					pop hl   ; u2 - addr 
4a91			 
4a91					; TODO Send SPI byte 
4a91			 
4a91			 
4a91 7b					ld a, e 
4a92 cd bd 01				call se_writebyte 
4a95			 
4a95					 
4a95			 
4a95					NEXTW 
4a95 c3 1d 21			jp macro_next 
4a98				endm 
# End of macro NEXTW
4a98			 
4a98			.SEI: 
4a98				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4a98 65				db WORD_SYS_CORE+81             
4a99 b2 4a			dw .SFREE            
4a9b 04				db 3 + 1 
4a9c .. 00			db "SEI",0              
4aa0				endm 
# End of macro CWHEAD
4aa0			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4aa0			 
4aa0					; get port 
4aa0			 
4aa0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aa0 cd ab 1f			call macro_dsp_valuehl 
4aa3				endm 
# End of macro FORTH_DSP_VALUEHL
4aa3			 
4aa3			;		push hl 
4aa3			 
4aa3					; destroy value TOS 
4aa3			 
4aa3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa3 cd 63 20			call macro_forth_dsp_pop 
4aa6				endm 
# End of macro FORTH_DSP_POP
4aa6			 
4aa6					; one value on hl get other one back 
4aa6			 
4aa6			;		pop hl 
4aa6			 
4aa6			 
4aa6					; TODO Get SPI byte 
4aa6			 
4aa6 cd 5f 02				call se_readbyte 
4aa9			 
4aa9 26 00				ld h, 0 
4aab 6f					ld l, a 
4aac cd b4 1d				call forth_push_numhl 
4aaf			 
4aaf					NEXTW 
4aaf c3 1d 21			jp macro_next 
4ab2				endm 
# End of macro NEXTW
4ab2			 
4ab2			.SFREE: 
4ab2				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4ab2 67				db WORD_SYS_CORE+83             
4ab3 e1 4a			dw .SIZE            
4ab5 06				db 5 + 1 
4ab6 .. 00			db "FFREE",0              
4abc				endm 
# End of macro CWHEAD
4abc			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4abc					if DEBUG_FORTH_WORDS_KEY 
4abc						DMARK "FFR" 
4abc f5				push af  
4abd 3a d1 4a			ld a, (.dmark)  
4ac0 32 b4 fe			ld (debug_mark),a  
4ac3 3a d2 4a			ld a, (.dmark+1)  
4ac6 32 b5 fe			ld (debug_mark+1),a  
4ac9 3a d3 4a			ld a, (.dmark+2)  
4acc 32 b6 fe			ld (debug_mark+2),a  
4acf 18 03			jr .pastdmark  
4ad1 ..			.dmark: db "FFR"  
4ad4 f1			.pastdmark: pop af  
4ad5			endm  
# End of macro DMARK
4ad5						CALLMONITOR 
4ad5 cd 57 17			call break_point_state  
4ad8				endm  
# End of macro CALLMONITOR
4ad8					endif 
4ad8			 
4ad8 cd 85 07				call storage_freeblocks 
4adb			 
4adb cd b4 1d				call forth_push_numhl 
4ade			 
4ade				       NEXTW 
4ade c3 1d 21			jp macro_next 
4ae1				endm 
# End of macro NEXTW
4ae1			.SIZE: 
4ae1				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4ae1 67				db WORD_SYS_CORE+83             
4ae2 15 4b			dw .CREATE            
4ae4 05				db 4 + 1 
4ae5 .. 00			db "SIZE",0              
4aea				endm 
# End of macro CWHEAD
4aea			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4aea					if DEBUG_FORTH_WORDS_KEY 
4aea						DMARK "SIZ" 
4aea f5				push af  
4aeb 3a ff 4a			ld a, (.dmark)  
4aee 32 b4 fe			ld (debug_mark),a  
4af1 3a 00 4b			ld a, (.dmark+1)  
4af4 32 b5 fe			ld (debug_mark+1),a  
4af7 3a 01 4b			ld a, (.dmark+2)  
4afa 32 b6 fe			ld (debug_mark+2),a  
4afd 18 03			jr .pastdmark  
4aff ..			.dmark: db "SIZ"  
4b02 f1			.pastdmark: pop af  
4b03			endm  
# End of macro DMARK
4b03						CALLMONITOR 
4b03 cd 57 17			call break_point_state  
4b06				endm  
# End of macro CALLMONITOR
4b06					endif 
4b06			 
4b06					FORTH_DSP_VALUEHL 
4b06 cd ab 1f			call macro_dsp_valuehl 
4b09				endm 
# End of macro FORTH_DSP_VALUEHL
4b09			;		push hl 
4b09					FORTH_DSP_POP 
4b09 cd 63 20			call macro_forth_dsp_pop 
4b0c				endm 
# End of macro FORTH_DSP_POP
4b0c			;		pop hl 
4b0c cd e7 03				call storage_file_size 
4b0f			 
4b0f cd b4 1d				call forth_push_numhl 
4b12			  
4b12			 
4b12				       NEXTW 
4b12 c3 1d 21			jp macro_next 
4b15				endm 
# End of macro NEXTW
4b15			 
4b15			.CREATE: 
4b15				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4b15 68				db WORD_SYS_CORE+84             
4b16 83 4b			dw .APPEND            
4b18 07				db 6 + 1 
4b19 .. 00			db "CREATE",0              
4b20				endm 
# End of macro CWHEAD
4b20			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4b20			; | | e.g.  
4b20			; | | TestProgram CREATE 
4b20			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4b20			; | |  
4b20			; | | Max file IDs are 255. 
4b20			; | |  
4b20					 
4b20					if DEBUG_FORTH_WORDS_KEY 
4b20						DMARK "CRT" 
4b20 f5				push af  
4b21 3a 35 4b			ld a, (.dmark)  
4b24 32 b4 fe			ld (debug_mark),a  
4b27 3a 36 4b			ld a, (.dmark+1)  
4b2a 32 b5 fe			ld (debug_mark+1),a  
4b2d 3a 37 4b			ld a, (.dmark+2)  
4b30 32 b6 fe			ld (debug_mark+2),a  
4b33 18 03			jr .pastdmark  
4b35 ..			.dmark: db "CRT"  
4b38 f1			.pastdmark: pop af  
4b39			endm  
# End of macro DMARK
4b39						CALLMONITOR 
4b39 cd 57 17			call break_point_state  
4b3c				endm  
# End of macro CALLMONITOR
4b3c					endif 
4b3c			;		call storage_get_block_0 
4b3c			 
4b3c					; TODO pop hl 
4b3c			 
4b3c					;v5 FORTH_DSP_VALUE 
4b3c					FORTH_DSP_VALUE 
4b3c cd 94 1f			call macro_forth_dsp_value 
4b3f				endm 
# End of macro FORTH_DSP_VALUE
4b3f			 
4b3f				if DEBUG_STORESE 
4b3f					DMARK "CR1" 
4b3f f5				push af  
4b40 3a 54 4b			ld a, (.dmark)  
4b43 32 b4 fe			ld (debug_mark),a  
4b46 3a 55 4b			ld a, (.dmark+1)  
4b49 32 b5 fe			ld (debug_mark+1),a  
4b4c 3a 56 4b			ld a, (.dmark+2)  
4b4f 32 b6 fe			ld (debug_mark+2),a  
4b52 18 03			jr .pastdmark  
4b54 ..			.dmark: db "CR1"  
4b57 f1			.pastdmark: pop af  
4b58			endm  
# End of macro DMARK
4b58					CALLMONITOR 
4b58 cd 57 17			call break_point_state  
4b5b				endm  
# End of macro CALLMONITOR
4b5b				endif 
4b5b			;		push hl 
4b5b			;		FORTH_DSP_POP 
4b5b			;		pop hl 
4b5b			 
4b5b			;		inc hl   ; move past the type marker 
4b5b			 
4b5b cd bb 07				call storage_create 
4b5e			 
4b5e				if DEBUG_STORESE 
4b5e					DMARK "CT1" 
4b5e f5				push af  
4b5f 3a 73 4b			ld a, (.dmark)  
4b62 32 b4 fe			ld (debug_mark),a  
4b65 3a 74 4b			ld a, (.dmark+1)  
4b68 32 b5 fe			ld (debug_mark+1),a  
4b6b 3a 75 4b			ld a, (.dmark+2)  
4b6e 32 b6 fe			ld (debug_mark+2),a  
4b71 18 03			jr .pastdmark  
4b73 ..			.dmark: db "CT1"  
4b76 f1			.pastdmark: pop af  
4b77			endm  
# End of macro DMARK
4b77					CALLMONITOR 
4b77 cd 57 17			call break_point_state  
4b7a				endm  
# End of macro CALLMONITOR
4b7a				endif 
4b7a			;		push hl 
4b7a					FORTH_DSP_POP 
4b7a cd 63 20			call macro_forth_dsp_pop 
4b7d				endm 
# End of macro FORTH_DSP_POP
4b7d			;		pop hl 
4b7d					; push file id to stack 
4b7d cd b4 1d				call forth_push_numhl 
4b80			 
4b80			 
4b80			 
4b80				       NEXTW 
4b80 c3 1d 21			jp macro_next 
4b83				endm 
# End of macro NEXTW
4b83			 
4b83			.APPEND: 
4b83				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4b83 69				db WORD_SYS_CORE+85             
4b84 14 4c			dw .SDEL            
4b86 07				db 6 + 1 
4b87 .. 00			db "APPEND",0              
4b8e				endm 
# End of macro CWHEAD
4b8e			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4b8e			; | | e.g. 
4b8e			; | | Test CREATE      -> $01 
4b8e			; | | "A string to add to file" $01 APPEND 
4b8e			; | |  
4b8e			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4b8e					if DEBUG_FORTH_WORDS_KEY 
4b8e						DMARK "APP" 
4b8e f5				push af  
4b8f 3a a3 4b			ld a, (.dmark)  
4b92 32 b4 fe			ld (debug_mark),a  
4b95 3a a4 4b			ld a, (.dmark+1)  
4b98 32 b5 fe			ld (debug_mark+1),a  
4b9b 3a a5 4b			ld a, (.dmark+2)  
4b9e 32 b6 fe			ld (debug_mark+2),a  
4ba1 18 03			jr .pastdmark  
4ba3 ..			.dmark: db "APP"  
4ba6 f1			.pastdmark: pop af  
4ba7			endm  
# End of macro DMARK
4ba7						CALLMONITOR 
4ba7 cd 57 17			call break_point_state  
4baa				endm  
# End of macro CALLMONITOR
4baa					endif 
4baa			 
4baa					FORTH_DSP_VALUEHL 
4baa cd ab 1f			call macro_dsp_valuehl 
4bad				endm 
# End of macro FORTH_DSP_VALUEHL
4bad e5					push hl 	; save file id 
4bae			 
4bae				if DEBUG_STORESE 
4bae					DMARK "AP1" 
4bae f5				push af  
4baf 3a c3 4b			ld a, (.dmark)  
4bb2 32 b4 fe			ld (debug_mark),a  
4bb5 3a c4 4b			ld a, (.dmark+1)  
4bb8 32 b5 fe			ld (debug_mark+1),a  
4bbb 3a c5 4b			ld a, (.dmark+2)  
4bbe 32 b6 fe			ld (debug_mark+2),a  
4bc1 18 03			jr .pastdmark  
4bc3 ..			.dmark: db "AP1"  
4bc6 f1			.pastdmark: pop af  
4bc7			endm  
# End of macro DMARK
4bc7					CALLMONITOR 
4bc7 cd 57 17			call break_point_state  
4bca				endm  
# End of macro CALLMONITOR
4bca				endif 
4bca					FORTH_DSP_POP 
4bca cd 63 20			call macro_forth_dsp_pop 
4bcd				endm 
# End of macro FORTH_DSP_POP
4bcd			 
4bcd					FORTH_DSP_VALUEHL 
4bcd cd ab 1f			call macro_dsp_valuehl 
4bd0				endm 
# End of macro FORTH_DSP_VALUEHL
4bd0					;v5 FORTH_DSP_VALUE 
4bd0 e5					push hl 	; save ptr to string to save 
4bd1			 
4bd1				if DEBUG_STORESE 
4bd1					DMARK "AP1" 
4bd1 f5				push af  
4bd2 3a e6 4b			ld a, (.dmark)  
4bd5 32 b4 fe			ld (debug_mark),a  
4bd8 3a e7 4b			ld a, (.dmark+1)  
4bdb 32 b5 fe			ld (debug_mark+1),a  
4bde 3a e8 4b			ld a, (.dmark+2)  
4be1 32 b6 fe			ld (debug_mark+2),a  
4be4 18 03			jr .pastdmark  
4be6 ..			.dmark: db "AP1"  
4be9 f1			.pastdmark: pop af  
4bea			endm  
# End of macro DMARK
4bea					CALLMONITOR 
4bea cd 57 17			call break_point_state  
4bed				endm  
# End of macro CALLMONITOR
4bed				endif 
4bed					FORTH_DSP_POP 
4bed cd 63 20			call macro_forth_dsp_pop 
4bf0				endm 
# End of macro FORTH_DSP_POP
4bf0			 
4bf0 d1					pop de 
4bf1 e1					pop hl 
4bf2				if DEBUG_STORESE 
4bf2					DMARK "AP2" 
4bf2 f5				push af  
4bf3 3a 07 4c			ld a, (.dmark)  
4bf6 32 b4 fe			ld (debug_mark),a  
4bf9 3a 08 4c			ld a, (.dmark+1)  
4bfc 32 b5 fe			ld (debug_mark+1),a  
4bff 3a 09 4c			ld a, (.dmark+2)  
4c02 32 b6 fe			ld (debug_mark+2),a  
4c05 18 03			jr .pastdmark  
4c07 ..			.dmark: db "AP2"  
4c0a f1			.pastdmark: pop af  
4c0b			endm  
# End of macro DMARK
4c0b					CALLMONITOR 
4c0b cd 57 17			call break_point_state  
4c0e				endm  
# End of macro CALLMONITOR
4c0e				endif 
4c0e					;inc de ; skip var type indicator 
4c0e			 
4c0e					; TODO how to append numerics???? 
4c0e			 
4c0e cd 9a 09				call storage_append		 
4c11			 
4c11				       NEXTW 
4c11 c3 1d 21			jp macro_next 
4c14				endm 
# End of macro NEXTW
4c14			.SDEL: 
4c14				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4c14 6a				db WORD_SYS_CORE+86             
4c15 60 4c			dw .OPEN            
4c17 05				db 4 + 1 
4c18 .. 00			db "ERA",0              
4c1c				endm 
# End of macro CWHEAD
4c1c			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4c1c					FORTH_DSP_VALUEHL 
4c1c cd ab 1f			call macro_dsp_valuehl 
4c1f				endm 
# End of macro FORTH_DSP_VALUEHL
4c1f			;		push hl 	; save file id 
4c1f			 
4c1f					if DEBUG_FORTH_WORDS_KEY 
4c1f						DMARK "ERA" 
4c1f f5				push af  
4c20 3a 34 4c			ld a, (.dmark)  
4c23 32 b4 fe			ld (debug_mark),a  
4c26 3a 35 4c			ld a, (.dmark+1)  
4c29 32 b5 fe			ld (debug_mark+1),a  
4c2c 3a 36 4c			ld a, (.dmark+2)  
4c2f 32 b6 fe			ld (debug_mark+2),a  
4c32 18 03			jr .pastdmark  
4c34 ..			.dmark: db "ERA"  
4c37 f1			.pastdmark: pop af  
4c38			endm  
# End of macro DMARK
4c38						CALLMONITOR 
4c38 cd 57 17			call break_point_state  
4c3b				endm  
# End of macro CALLMONITOR
4c3b					endif 
4c3b				if DEBUG_STORESE 
4c3b					DMARK "ER1" 
4c3b f5				push af  
4c3c 3a 50 4c			ld a, (.dmark)  
4c3f 32 b4 fe			ld (debug_mark),a  
4c42 3a 51 4c			ld a, (.dmark+1)  
4c45 32 b5 fe			ld (debug_mark+1),a  
4c48 3a 52 4c			ld a, (.dmark+2)  
4c4b 32 b6 fe			ld (debug_mark+2),a  
4c4e 18 03			jr .pastdmark  
4c50 ..			.dmark: db "ER1"  
4c53 f1			.pastdmark: pop af  
4c54			endm  
# End of macro DMARK
4c54					CALLMONITOR 
4c54 cd 57 17			call break_point_state  
4c57				endm  
# End of macro CALLMONITOR
4c57				endif 
4c57					FORTH_DSP_POP 
4c57 cd 63 20			call macro_forth_dsp_pop 
4c5a				endm 
# End of macro FORTH_DSP_POP
4c5a			 
4c5a			;		pop hl 
4c5a			 
4c5a cd fa 05				call storage_erase 
4c5d				       NEXTW 
4c5d c3 1d 21			jp macro_next 
4c60				endm 
# End of macro NEXTW
4c60			 
4c60			.OPEN: 
4c60				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4c60 6b				db WORD_SYS_CORE+87             
4c61 f0 4c			dw .READ            
4c63 05				db 4 + 1 
4c64 .. 00			db "OPEN",0              
4c69				endm 
# End of macro CWHEAD
4c69			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4c69			; | | e.g. 
4c69			; | | $01 OPEN $01 DO $01 READ . LOOP 
4c69			; | | 
4c69			; | | Will return with 255 blocks if the file does not exist 
4c69			 
4c69					if DEBUG_FORTH_WORDS_KEY 
4c69						DMARK "OPN" 
4c69 f5				push af  
4c6a 3a 7e 4c			ld a, (.dmark)  
4c6d 32 b4 fe			ld (debug_mark),a  
4c70 3a 7f 4c			ld a, (.dmark+1)  
4c73 32 b5 fe			ld (debug_mark+1),a  
4c76 3a 80 4c			ld a, (.dmark+2)  
4c79 32 b6 fe			ld (debug_mark+2),a  
4c7c 18 03			jr .pastdmark  
4c7e ..			.dmark: db "OPN"  
4c81 f1			.pastdmark: pop af  
4c82			endm  
# End of macro DMARK
4c82						CALLMONITOR 
4c82 cd 57 17			call break_point_state  
4c85				endm  
# End of macro CALLMONITOR
4c85					endif 
4c85					; TODO handle multiple file opens 
4c85			 
4c85 3e 01			       	ld a, 1 
4c87 32 d6 fc				ld (store_openext), a 
4c8a			 
4c8a					; get max extents for this file 
4c8a				 
4c8a								 
4c8a					FORTH_DSP_VALUEHL 
4c8a cd ab 1f			call macro_dsp_valuehl 
4c8d				endm 
# End of macro FORTH_DSP_VALUEHL
4c8d			 
4c8d 65					ld h, l 
4c8e 2e 00				ld l, 0 
4c90			 
4c90				if DEBUG_STORESE 
4c90					DMARK "OPN" 
4c90 f5				push af  
4c91 3a a5 4c			ld a, (.dmark)  
4c94 32 b4 fe			ld (debug_mark),a  
4c97 3a a6 4c			ld a, (.dmark+1)  
4c9a 32 b5 fe			ld (debug_mark+1),a  
4c9d 3a a7 4c			ld a, (.dmark+2)  
4ca0 32 b6 fe			ld (debug_mark+2),a  
4ca3 18 03			jr .pastdmark  
4ca5 ..			.dmark: db "OPN"  
4ca8 f1			.pastdmark: pop af  
4ca9			endm  
# End of macro DMARK
4ca9					CALLMONITOR 
4ca9 cd 57 17			call break_point_state  
4cac				endm  
# End of macro CALLMONITOR
4cac				endif 
4cac			;		push hl 
4cac					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4cac cd 63 20			call macro_forth_dsp_pop 
4caf				endm 
# End of macro FORTH_DSP_POP
4caf			;		pop hl 
4caf						 
4caf 11 df fc				ld de, store_page      ; get block zero of file 
4cb2 cd 11 09				call storage_read 
4cb5 cd 03 0e			call ishlzero 
4cb8 20 04			jr nz, .opfound 
4cba			 
4cba				; file does not exist so indicate with 255 extents in use 
4cba			 
4cba 3e ff			ld a, 255 
4cbc 18 29			jr .skipopeneof 
4cbe			 
4cbe			 
4cbe			.opfound: 
4cbe			 
4cbe			 
4cbe 3a e1 fc				ld a, (store_page+2)    ; max extents for this file 
4cc1 32 d5 fc				ld  (store_openmaxext), a   ; get our limit and push 
4cc4					 
4cc4				if DEBUG_STORESE 
4cc4					DMARK "OPx" 
4cc4 f5				push af  
4cc5 3a d9 4c			ld a, (.dmark)  
4cc8 32 b4 fe			ld (debug_mark),a  
4ccb 3a da 4c			ld a, (.dmark+1)  
4cce 32 b5 fe			ld (debug_mark+1),a  
4cd1 3a db 4c			ld a, (.dmark+2)  
4cd4 32 b6 fe			ld (debug_mark+2),a  
4cd7 18 03			jr .pastdmark  
4cd9 ..			.dmark: db "OPx"  
4cdc f1			.pastdmark: pop af  
4cdd			endm  
# End of macro DMARK
4cdd					CALLMONITOR 
4cdd cd 57 17			call break_point_state  
4ce0				endm  
# End of macro CALLMONITOR
4ce0				endif 
4ce0 fe 00				cp 0 
4ce2 20 03				jr nz, .skipopeneof 
4ce4					; have opened an empty file 
4ce4					 
4ce4 32 d6 fc				ld (store_openext), a 
4ce7			 
4ce7			.skipopeneof: 
4ce7			 
4ce7 6f					ld l, a 
4ce8 26 00				ld h, 0 
4cea cd b4 1d				call forth_push_numhl 
4ced			 
4ced			 
4ced				       NEXTW 
4ced c3 1d 21			jp macro_next 
4cf0				endm 
# End of macro NEXTW
4cf0			.READ: 
4cf0				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4cf0 6c				db WORD_SYS_CORE+88             
4cf1 37 4e			dw .EOF            
4cf3 05				db 4 + 1 
4cf4 .. 00			db "READ",0              
4cf9				endm 
# End of macro CWHEAD
4cf9			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4cf9			; | | e.g. 
4cf9			; | | $01 OPEN $01 DO $01 READ . LOOP 
4cf9			 
4cf9					if DEBUG_FORTH_WORDS_KEY 
4cf9						DMARK "REA" 
4cf9 f5				push af  
4cfa 3a 0e 4d			ld a, (.dmark)  
4cfd 32 b4 fe			ld (debug_mark),a  
4d00 3a 0f 4d			ld a, (.dmark+1)  
4d03 32 b5 fe			ld (debug_mark+1),a  
4d06 3a 10 4d			ld a, (.dmark+2)  
4d09 32 b6 fe			ld (debug_mark+2),a  
4d0c 18 03			jr .pastdmark  
4d0e ..			.dmark: db "REA"  
4d11 f1			.pastdmark: pop af  
4d12			endm  
# End of macro DMARK
4d12						CALLMONITOR 
4d12 cd 57 17			call break_point_state  
4d15				endm  
# End of macro CALLMONITOR
4d15					endif 
4d15					; store_openext use it. If zero it is EOF 
4d15			 
4d15					; read block from current stream id 
4d15					; if the block does not contain zero term keep reading blocks until zero found 
4d15					; push the block to stack 
4d15					; save the block id to stream 
4d15			 
4d15			 
4d15					FORTH_DSP_VALUEHL 
4d15 cd ab 1f			call macro_dsp_valuehl 
4d18				endm 
# End of macro FORTH_DSP_VALUEHL
4d18			 
4d18			;		push hl 
4d18			 
4d18				if DEBUG_STORESE 
4d18					DMARK "REA" 
4d18 f5				push af  
4d19 3a 2d 4d			ld a, (.dmark)  
4d1c 32 b4 fe			ld (debug_mark),a  
4d1f 3a 2e 4d			ld a, (.dmark+1)  
4d22 32 b5 fe			ld (debug_mark+1),a  
4d25 3a 2f 4d			ld a, (.dmark+2)  
4d28 32 b6 fe			ld (debug_mark+2),a  
4d2b 18 03			jr .pastdmark  
4d2d ..			.dmark: db "REA"  
4d30 f1			.pastdmark: pop af  
4d31			endm  
# End of macro DMARK
4d31					CALLMONITOR 
4d31 cd 57 17			call break_point_state  
4d34				endm  
# End of macro CALLMONITOR
4d34				endif 
4d34					FORTH_DSP_POP 
4d34 cd 63 20			call macro_forth_dsp_pop 
4d37				endm 
# End of macro FORTH_DSP_POP
4d37			 
4d37			;		pop hl 
4d37				 
4d37 65					ld h,l 
4d38			 
4d38 3a d6 fc				ld a, (store_openext) 
4d3b 6f					ld l, a 
4d3c					 
4d3c fe 00				cp 0 
4d3e ca 09 4e				jp z, .ateof     ; dont read past eof 
4d41			 
4d41			 
4d41 11 df fc				ld de, store_page 
4d44				if DEBUG_STORESE 
4d44					DMARK "RE1" 
4d44 f5				push af  
4d45 3a 59 4d			ld a, (.dmark)  
4d48 32 b4 fe			ld (debug_mark),a  
4d4b 3a 5a 4d			ld a, (.dmark+1)  
4d4e 32 b5 fe			ld (debug_mark+1),a  
4d51 3a 5b 4d			ld a, (.dmark+2)  
4d54 32 b6 fe			ld (debug_mark+2),a  
4d57 18 03			jr .pastdmark  
4d59 ..			.dmark: db "RE1"  
4d5c f1			.pastdmark: pop af  
4d5d			endm  
# End of macro DMARK
4d5d					CALLMONITOR 
4d5d cd 57 17			call break_point_state  
4d60				endm  
# End of macro CALLMONITOR
4d60				endif 
4d60 cd 11 09				call storage_read 
4d63			 
4d63				if DEBUG_STORESE 
4d63					DMARK "RE2" 
4d63 f5				push af  
4d64 3a 78 4d			ld a, (.dmark)  
4d67 32 b4 fe			ld (debug_mark),a  
4d6a 3a 79 4d			ld a, (.dmark+1)  
4d6d 32 b5 fe			ld (debug_mark+1),a  
4d70 3a 7a 4d			ld a, (.dmark+2)  
4d73 32 b6 fe			ld (debug_mark+2),a  
4d76 18 03			jr .pastdmark  
4d78 ..			.dmark: db "RE2"  
4d7b f1			.pastdmark: pop af  
4d7c			endm  
# End of macro DMARK
4d7c					CALLMONITOR 
4d7c cd 57 17			call break_point_state  
4d7f				endm  
# End of macro CALLMONITOR
4d7f				endif 
4d7f cd 03 0e			call ishlzero 
4d82			;	ld a, l 
4d82			;	add h 
4d82			;	cp 0 
4d82 ca 0f 4e			jp z, .readeof 
4d85			 
4d85				; not eof so hl should point to data to push to stack 
4d85			 
4d85				if DEBUG_STORESE 
4d85					DMARK "RE3" 
4d85 f5				push af  
4d86 3a 9a 4d			ld a, (.dmark)  
4d89 32 b4 fe			ld (debug_mark),a  
4d8c 3a 9b 4d			ld a, (.dmark+1)  
4d8f 32 b5 fe			ld (debug_mark+1),a  
4d92 3a 9c 4d			ld a, (.dmark+2)  
4d95 32 b6 fe			ld (debug_mark+2),a  
4d98 18 03			jr .pastdmark  
4d9a ..			.dmark: db "RE3"  
4d9d f1			.pastdmark: pop af  
4d9e			endm  
# End of macro DMARK
4d9e					CALLMONITOR 
4d9e cd 57 17			call break_point_state  
4da1				endm  
# End of macro CALLMONITOR
4da1				endif 
4da1 cd 22 1e			call forth_push_str 
4da4			 
4da4				if DEBUG_STORESE 
4da4					DMARK "RE4" 
4da4 f5				push af  
4da5 3a b9 4d			ld a, (.dmark)  
4da8 32 b4 fe			ld (debug_mark),a  
4dab 3a ba 4d			ld a, (.dmark+1)  
4dae 32 b5 fe			ld (debug_mark+1),a  
4db1 3a bb 4d			ld a, (.dmark+2)  
4db4 32 b6 fe			ld (debug_mark+2),a  
4db7 18 03			jr .pastdmark  
4db9 ..			.dmark: db "RE4"  
4dbc f1			.pastdmark: pop af  
4dbd			endm  
# End of macro DMARK
4dbd					CALLMONITOR 
4dbd cd 57 17			call break_point_state  
4dc0				endm  
# End of macro CALLMONITOR
4dc0				endif 
4dc0				; get next block  or mark as eof 
4dc0			 
4dc0 3a d5 fc			ld a, (store_openmaxext)   ; get our limit 
4dc3 4f				ld c, a	 
4dc4 3a d6 fc			ld a, (store_openext) 
4dc7			 
4dc7				if DEBUG_STORESE 
4dc7					DMARK "RE5" 
4dc7 f5				push af  
4dc8 3a dc 4d			ld a, (.dmark)  
4dcb 32 b4 fe			ld (debug_mark),a  
4dce 3a dd 4d			ld a, (.dmark+1)  
4dd1 32 b5 fe			ld (debug_mark+1),a  
4dd4 3a de 4d			ld a, (.dmark+2)  
4dd7 32 b6 fe			ld (debug_mark+2),a  
4dda 18 03			jr .pastdmark  
4ddc ..			.dmark: db "RE5"  
4ddf f1			.pastdmark: pop af  
4de0			endm  
# End of macro DMARK
4de0					CALLMONITOR 
4de0 cd 57 17			call break_point_state  
4de3				endm  
# End of macro CALLMONITOR
4de3				endif 
4de3 b9				cp c 
4de4 28 29			jr z, .readeof     ; at last extent 
4de6			 
4de6 3c					inc a 
4de7 32 d6 fc				ld (store_openext), a 
4dea			 
4dea				if DEBUG_STORESE 
4dea					DMARK "RE6" 
4dea f5				push af  
4deb 3a ff 4d			ld a, (.dmark)  
4dee 32 b4 fe			ld (debug_mark),a  
4df1 3a 00 4e			ld a, (.dmark+1)  
4df4 32 b5 fe			ld (debug_mark+1),a  
4df7 3a 01 4e			ld a, (.dmark+2)  
4dfa 32 b6 fe			ld (debug_mark+2),a  
4dfd 18 03			jr .pastdmark  
4dff ..			.dmark: db "RE6"  
4e02 f1			.pastdmark: pop af  
4e03			endm  
# End of macro DMARK
4e03					CALLMONITOR 
4e03 cd 57 17			call break_point_state  
4e06				endm  
# End of macro CALLMONITOR
4e06				endif 
4e06			 
4e06			 
4e06				       NEXTW 
4e06 c3 1d 21			jp macro_next 
4e09				endm 
# End of macro NEXTW
4e09			.ateof: 
4e09 21 33 4e				ld hl, .showeof 
4e0c cd 22 1e				call forth_push_str 
4e0f 3e 00		.readeof:	ld a, 0 
4e11 32 d6 fc				ld (store_openext), a 
4e14			 
4e14					 
4e14				if DEBUG_STORESE 
4e14					DMARK "REF" 
4e14 f5				push af  
4e15 3a 29 4e			ld a, (.dmark)  
4e18 32 b4 fe			ld (debug_mark),a  
4e1b 3a 2a 4e			ld a, (.dmark+1)  
4e1e 32 b5 fe			ld (debug_mark+1),a  
4e21 3a 2b 4e			ld a, (.dmark+2)  
4e24 32 b6 fe			ld (debug_mark+2),a  
4e27 18 03			jr .pastdmark  
4e29 ..			.dmark: db "REF"  
4e2c f1			.pastdmark: pop af  
4e2d			endm  
# End of macro DMARK
4e2d					CALLMONITOR 
4e2d cd 57 17			call break_point_state  
4e30				endm  
# End of macro CALLMONITOR
4e30				endif 
4e30				       NEXTW 
4e30 c3 1d 21			jp macro_next 
4e33				endm 
# End of macro NEXTW
4e33			 
4e33 .. 00		.showeof:   db "eof", 0 
4e37			 
4e37			 
4e37			.EOF: 
4e37				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4e37 6d				db WORD_SYS_CORE+89             
4e38 78 4e			dw .FORMAT            
4e3a 04				db 3 + 1 
4e3b .. 00			db "EOF",0              
4e3f				endm 
# End of macro CWHEAD
4e3f			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4e3f			; | | e.g. 
4e3f			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4e3f					; TODO if current block id for stream is zero then push true else false 
4e3f			 
4e3f					if DEBUG_FORTH_WORDS_KEY 
4e3f						DMARK "EOF" 
4e3f f5				push af  
4e40 3a 54 4e			ld a, (.dmark)  
4e43 32 b4 fe			ld (debug_mark),a  
4e46 3a 55 4e			ld a, (.dmark+1)  
4e49 32 b5 fe			ld (debug_mark+1),a  
4e4c 3a 56 4e			ld a, (.dmark+2)  
4e4f 32 b6 fe			ld (debug_mark+2),a  
4e52 18 03			jr .pastdmark  
4e54 ..			.dmark: db "EOF"  
4e57 f1			.pastdmark: pop af  
4e58			endm  
# End of macro DMARK
4e58						CALLMONITOR 
4e58 cd 57 17			call break_point_state  
4e5b				endm  
# End of macro CALLMONITOR
4e5b					endif 
4e5b			 
4e5b					; TODO handlue multiple file streams 
4e5b			 
4e5b					FORTH_DSP_POP     ; for now just get rid of stream id 
4e5b cd 63 20			call macro_forth_dsp_pop 
4e5e				endm 
# End of macro FORTH_DSP_POP
4e5e			 
4e5e 2e 01				ld l, 1 
4e60 3a d5 fc				ld a, (store_openmaxext) 
4e63 fe 00				cp 0 
4e65 28 09				jr  z, .eofdone   ; empty file 
4e67 3a d6 fc				ld a, (store_openext) 
4e6a fe 00				cp 0 
4e6c 28 02				jr  z, .eofdone 
4e6e 2e 00				ld l, 0 
4e70 26 00		.eofdone:	ld h, 0 
4e72 cd b4 1d				call forth_push_numhl 
4e75			 
4e75			 
4e75				       NEXTW 
4e75 c3 1d 21			jp macro_next 
4e78				endm 
# End of macro NEXTW
4e78			 
4e78			.FORMAT: 
4e78				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4e78 6d				db WORD_SYS_CORE+89             
4e79 c9 4e			dw .LABEL            
4e7b 07				db 6 + 1 
4e7c .. 00			db "FORMAT",0              
4e83				endm 
# End of macro CWHEAD
4e83			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4e83					; TODO if current block id for stream is zero then push true else false 
4e83				 
4e83				if DEBUG_STORESE 
4e83					DMARK "FOR" 
4e83 f5				push af  
4e84 3a 98 4e			ld a, (.dmark)  
4e87 32 b4 fe			ld (debug_mark),a  
4e8a 3a 99 4e			ld a, (.dmark+1)  
4e8d 32 b5 fe			ld (debug_mark+1),a  
4e90 3a 9a 4e			ld a, (.dmark+2)  
4e93 32 b6 fe			ld (debug_mark+2),a  
4e96 18 03			jr .pastdmark  
4e98 ..			.dmark: db "FOR"  
4e9b f1			.pastdmark: pop af  
4e9c			endm  
# End of macro DMARK
4e9c					CALLMONITOR 
4e9c cd 57 17			call break_point_state  
4e9f				endm  
# End of macro CALLMONITOR
4e9f				endif 
4e9f					; Wipes the bank check flags to cause a reformat on next block 0 read 
4e9f			 
4e9f 21 01 00				ld hl, 1 
4ea2 3e 00				ld a, 0 
4ea4 cd bd 01				call se_writebyte 
4ea7			 
4ea7				if DEBUG_STORESE 
4ea7					DMARK "FO0" 
4ea7 f5				push af  
4ea8 3a bc 4e			ld a, (.dmark)  
4eab 32 b4 fe			ld (debug_mark),a  
4eae 3a bd 4e			ld a, (.dmark+1)  
4eb1 32 b5 fe			ld (debug_mark+1),a  
4eb4 3a be 4e			ld a, (.dmark+2)  
4eb7 32 b6 fe			ld (debug_mark+2),a  
4eba 18 03			jr .pastdmark  
4ebc ..			.dmark: db "FO0"  
4ebf f1			.pastdmark: pop af  
4ec0			endm  
# End of macro DMARK
4ec0					CALLMONITOR 
4ec0 cd 57 17			call break_point_state  
4ec3				endm  
# End of macro CALLMONITOR
4ec3				endif 
4ec3					; force bank init 
4ec3			 
4ec3 cd 69 04				call storage_get_block_0 
4ec6					 
4ec6				       NEXTW 
4ec6 c3 1d 21			jp macro_next 
4ec9				endm 
# End of macro NEXTW
4ec9			.LABEL: 
4ec9				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4ec9 6d				db WORD_SYS_CORE+89             
4eca 17 4f			dw .STOREPAGE            
4ecc 06				db 5 + 1 
4ecd .. 00			db "LABEL",0              
4ed3				endm 
# End of macro CWHEAD
4ed3			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4ed3					; TODO test to see if bank is selected 
4ed3				 
4ed3					if DEBUG_FORTH_WORDS_KEY 
4ed3						DMARK "LBL" 
4ed3 f5				push af  
4ed4 3a e8 4e			ld a, (.dmark)  
4ed7 32 b4 fe			ld (debug_mark),a  
4eda 3a e9 4e			ld a, (.dmark+1)  
4edd 32 b5 fe			ld (debug_mark+1),a  
4ee0 3a ea 4e			ld a, (.dmark+2)  
4ee3 32 b6 fe			ld (debug_mark+2),a  
4ee6 18 03			jr .pastdmark  
4ee8 ..			.dmark: db "LBL"  
4eeb f1			.pastdmark: pop af  
4eec			endm  
# End of macro DMARK
4eec						CALLMONITOR 
4eec cd 57 17			call break_point_state  
4eef				endm  
# End of macro CALLMONITOR
4eef					endif 
4eef			;	if DEBUG_STORESE 
4eef			;		DMARK "LBL" 
4eef			;		CALLMONITOR 
4eef			;	endif 
4eef					FORTH_DSP_VALUEHL 
4eef cd ab 1f			call macro_dsp_valuehl 
4ef2				endm 
# End of macro FORTH_DSP_VALUEHL
4ef2					;v5FORTH_DSP_VALUE 
4ef2					 
4ef2			;		push hl 
4ef2					FORTH_DSP_POP 
4ef2 cd 63 20			call macro_forth_dsp_pop 
4ef5				endm 
# End of macro FORTH_DSP_POP
4ef5			;		pop hl 
4ef5			 
4ef5			;v5		inc hl   ; move past the type marker 
4ef5			 
4ef5				if DEBUG_STORESE 
4ef5					DMARK "LBl" 
4ef5 f5				push af  
4ef6 3a 0a 4f			ld a, (.dmark)  
4ef9 32 b4 fe			ld (debug_mark),a  
4efc 3a 0b 4f			ld a, (.dmark+1)  
4eff 32 b5 fe			ld (debug_mark+1),a  
4f02 3a 0c 4f			ld a, (.dmark+2)  
4f05 32 b6 fe			ld (debug_mark+2),a  
4f08 18 03			jr .pastdmark  
4f0a ..			.dmark: db "LBl"  
4f0d f1			.pastdmark: pop af  
4f0e			endm  
# End of macro DMARK
4f0e					CALLMONITOR 
4f0e cd 57 17			call break_point_state  
4f11				endm  
# End of macro CALLMONITOR
4f11				endif 
4f11 cd 8d 05				call storage_label 
4f14			 
4f14				       NEXTW 
4f14 c3 1d 21			jp macro_next 
4f17				endm 
# End of macro NEXTW
4f17			.STOREPAGE: 
4f17				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4f17 6d				db WORD_SYS_CORE+89             
4f18 4a 4f			dw .LABELS            
4f1a 0a				db 9 + 1 
4f1b .. 00			db "STOREPAGE",0              
4f25				endm 
# End of macro CWHEAD
4f25			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4f25					; TODO test to see if bank is selected 
4f25				 
4f25					if DEBUG_FORTH_WORDS_KEY 
4f25						DMARK "STP" 
4f25 f5				push af  
4f26 3a 3a 4f			ld a, (.dmark)  
4f29 32 b4 fe			ld (debug_mark),a  
4f2c 3a 3b 4f			ld a, (.dmark+1)  
4f2f 32 b5 fe			ld (debug_mark+1),a  
4f32 3a 3c 4f			ld a, (.dmark+2)  
4f35 32 b6 fe			ld (debug_mark+2),a  
4f38 18 03			jr .pastdmark  
4f3a ..			.dmark: db "STP"  
4f3d f1			.pastdmark: pop af  
4f3e			endm  
# End of macro DMARK
4f3e						CALLMONITOR 
4f3e cd 57 17			call break_point_state  
4f41				endm  
# End of macro CALLMONITOR
4f41					endif 
4f41			;	if DEBUG_STORESE 
4f41			;		DMARK "STP" 
4f41			;		CALLMONITOR 
4f41			;	endif 
4f41			 
4f41 21 df fc			ld hl, store_page 
4f44 cd b4 1d			call forth_push_numhl 
4f47			 
4f47			 
4f47				       NEXTW 
4f47 c3 1d 21			jp macro_next 
4f4a				endm 
# End of macro NEXTW
4f4a			.LABELS: 
4f4a				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4f4a 6d				db WORD_SYS_CORE+89             
4f4b d4 4f			dw .ENDSTORAGE            
4f4d 07				db 6 + 1 
4f4e .. 00			db "LABELS",0              
4f55				endm 
# End of macro CWHEAD
4f55			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4f55					;  
4f55			 
4f55					; save the current device selected to restore afterwards 
4f55				 
4f55 3a c5 fc				ld a, (spi_device) 
4f58 f5					push af 
4f59			 
4f59			 
4f59					; run through each of the banks 
4f59			 
4f59 21 01 00				ld hl, 1 
4f5c cd b4 1d				call forth_push_numhl 
4f5f 3e ff				ld a, SPI_CE_HIGH 
4f61 cb 87				res SPI_CE0, a 
4f63 32 c5 fc				ld (spi_device), a 
4f66 cd 69 04				call storage_get_block_0 
4f69 21 e2 fc				ld hl, store_page+3 
4f6c cd 22 1e				call forth_push_str 
4f6f			 
4f6f					 
4f6f 21 02 00				ld hl, 2 
4f72 cd b4 1d				call forth_push_numhl 
4f75 3e ff				ld a, SPI_CE_HIGH 
4f77 cb 8f				res SPI_CE1, a 
4f79 32 c5 fc				ld (spi_device), a 
4f7c cd 69 04				call storage_get_block_0 
4f7f 21 e2 fc				ld hl, store_page+3 
4f82 cd 22 1e				call forth_push_str 
4f85			 
4f85					 
4f85 21 03 00				ld hl, 3 
4f88 cd b4 1d				call forth_push_numhl 
4f8b 3e ff				ld a, SPI_CE_HIGH 
4f8d cb 97				res SPI_CE2, a 
4f8f 32 c5 fc				ld (spi_device), a 
4f92 cd 69 04				call storage_get_block_0 
4f95 21 e2 fc				ld hl, store_page+3 
4f98 cd 22 1e				call forth_push_str 
4f9b			 
4f9b			 
4f9b 21 04 00				ld hl, 4 
4f9e cd b4 1d				call forth_push_numhl 
4fa1 3e ff				ld a, SPI_CE_HIGH 
4fa3 cb 9f				res SPI_CE3, a 
4fa5 32 c5 fc				ld (spi_device), a 
4fa8 cd 69 04				call storage_get_block_0 
4fab 21 e2 fc				ld hl, store_page+3 
4fae cd 22 1e				call forth_push_str 
4fb1			 
4fb1					 
4fb1			 
4fb1 21 05 00				ld hl, 5 
4fb4 cd b4 1d				call forth_push_numhl 
4fb7 3e ff				ld a, SPI_CE_HIGH 
4fb9 cb a7				res SPI_CE4, a 
4fbb 32 c5 fc				ld (spi_device), a 
4fbe cd 69 04				call storage_get_block_0 
4fc1 21 e2 fc				ld hl, store_page+3 
4fc4 cd 22 1e				call forth_push_str 
4fc7			 
4fc7					 
4fc7					; push fixed count of storage devices (on board) for now 
4fc7			 
4fc7 21 05 00				ld hl, 5 
4fca cd b4 1d				call forth_push_numhl 
4fcd			 
4fcd					; restore selected device  
4fcd				 
4fcd f1					pop af 
4fce 32 c5 fc				ld (spi_device), a 
4fd1			 
4fd1				       NEXTW 
4fd1 c3 1d 21			jp macro_next 
4fd4				endm 
# End of macro NEXTW
4fd4			 
4fd4			.ENDSTORAGE: 
4fd4			; eof 
# End of file forth_words_storage.asm
4fd4			endif 
4fd4				include "forth_words_device.asm" 
4fd4			; Device related words 
4fd4			 
4fd4			; | ## Device Words 
4fd4			 
4fd4			if SOUND_ENABLE 
4fd4			.NOTE: 
4fd4				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4fd4			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4fd4					if DEBUG_FORTH_WORDS_KEY 
4fd4						DMARK "NTE" 
4fd4						CALLMONITOR 
4fd4					endif 
4fd4			 
4fd4				 
4fd4			 
4fd4					NEXTW 
4fd4			.AFTERSOUND: 
4fd4			endif 
4fd4			 
4fd4			 
4fd4			USE_GPIO: equ 0 
4fd4			 
4fd4			if USE_GPIO 
4fd4			.GP1: 
4fd4				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4fd4			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4fd4					NEXTW 
4fd4			.GP2: 
4fd4				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4fd4			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4fd4			 
4fd4					NEXTW 
4fd4			 
4fd4			.GP3: 
4fd4				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4fd4			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4fd4			 
4fd4					NEXTW 
4fd4			 
4fd4			.GP4: 
4fd4				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4fd4			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4fd4			 
4fd4					NEXTW 
4fd4			.SIN: 
4fd4			 
4fd4			 
4fd4			endif 
4fd4			 
4fd4			 
4fd4				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4fd4 33				db WORD_SYS_CORE+31             
4fd5 09 50			dw .SOUT            
4fd7 03				db 2 + 1 
4fd8 .. 00			db "IN",0              
4fdb				endm 
# End of macro CWHEAD
4fdb			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4fdb					if DEBUG_FORTH_WORDS_KEY 
4fdb						DMARK "IN." 
4fdb f5				push af  
4fdc 3a f0 4f			ld a, (.dmark)  
4fdf 32 b4 fe			ld (debug_mark),a  
4fe2 3a f1 4f			ld a, (.dmark+1)  
4fe5 32 b5 fe			ld (debug_mark+1),a  
4fe8 3a f2 4f			ld a, (.dmark+2)  
4feb 32 b6 fe			ld (debug_mark+2),a  
4fee 18 03			jr .pastdmark  
4ff0 ..			.dmark: db "IN."  
4ff3 f1			.pastdmark: pop af  
4ff4			endm  
# End of macro DMARK
4ff4						CALLMONITOR 
4ff4 cd 57 17			call break_point_state  
4ff7				endm  
# End of macro CALLMONITOR
4ff7					endif 
4ff7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ff7 cd ab 1f			call macro_dsp_valuehl 
4ffa				endm 
# End of macro FORTH_DSP_VALUEHL
4ffa			 
4ffa e5					push hl 
4ffb			 
4ffb					; destroy value TOS 
4ffb			 
4ffb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ffb cd 63 20			call macro_forth_dsp_pop 
4ffe				endm 
# End of macro FORTH_DSP_POP
4ffe			 
4ffe					; one value on hl get other one back 
4ffe			 
4ffe c1					pop bc 
4fff			 
4fff					; do the sub 
4fff			;		ex de, hl 
4fff			 
4fff ed 68				in l,(c) 
5001			 
5001					; save it 
5001			 
5001 26 00				ld h,0 
5003			 
5003					; TODO push value back onto stack for another op etc 
5003			 
5003 cd b4 1d				call forth_push_numhl 
5006					NEXTW 
5006 c3 1d 21			jp macro_next 
5009				endm 
# End of macro NEXTW
5009			.SOUT: 
5009				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5009 34				db WORD_SYS_CORE+32             
500a 5c 50			dw .SPIO            
500c 04				db 3 + 1 
500d .. 00			db "OUT",0              
5011				endm 
# End of macro CWHEAD
5011			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5011					if DEBUG_FORTH_WORDS_KEY 
5011						DMARK "OUT" 
5011 f5				push af  
5012 3a 26 50			ld a, (.dmark)  
5015 32 b4 fe			ld (debug_mark),a  
5018 3a 27 50			ld a, (.dmark+1)  
501b 32 b5 fe			ld (debug_mark+1),a  
501e 3a 28 50			ld a, (.dmark+2)  
5021 32 b6 fe			ld (debug_mark+2),a  
5024 18 03			jr .pastdmark  
5026 ..			.dmark: db "OUT"  
5029 f1			.pastdmark: pop af  
502a			endm  
# End of macro DMARK
502a						CALLMONITOR 
502a cd 57 17			call break_point_state  
502d				endm  
# End of macro CALLMONITOR
502d					endif 
502d			 
502d					; get port 
502d			 
502d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
502d cd ab 1f			call macro_dsp_valuehl 
5030				endm 
# End of macro FORTH_DSP_VALUEHL
5030			 
5030 e5					push hl 
5031			 
5031					; destroy value TOS 
5031			 
5031					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5031 cd 63 20			call macro_forth_dsp_pop 
5034				endm 
# End of macro FORTH_DSP_POP
5034			 
5034					; get byte to send 
5034			 
5034					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5034 cd ab 1f			call macro_dsp_valuehl 
5037				endm 
# End of macro FORTH_DSP_VALUEHL
5037			 
5037			;		push hl 
5037			 
5037					; destroy value TOS 
5037			 
5037					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5037 cd 63 20			call macro_forth_dsp_pop 
503a				endm 
# End of macro FORTH_DSP_POP
503a			 
503a					; one value on hl get other one back 
503a			 
503a			;		pop hl 
503a			 
503a c1					pop bc 
503b			 
503b					if DEBUG_FORTH_WORDS 
503b						DMARK "OUT" 
503b f5				push af  
503c 3a 50 50			ld a, (.dmark)  
503f 32 b4 fe			ld (debug_mark),a  
5042 3a 51 50			ld a, (.dmark+1)  
5045 32 b5 fe			ld (debug_mark+1),a  
5048 3a 52 50			ld a, (.dmark+2)  
504b 32 b6 fe			ld (debug_mark+2),a  
504e 18 03			jr .pastdmark  
5050 ..			.dmark: db "OUT"  
5053 f1			.pastdmark: pop af  
5054			endm  
# End of macro DMARK
5054						CALLMONITOR 
5054 cd 57 17			call break_point_state  
5057				endm  
# End of macro CALLMONITOR
5057					endif 
5057			 
5057 ed 69				out (c), l 
5059			 
5059					NEXTW 
5059 c3 1d 21			jp macro_next 
505c				endm 
# End of macro NEXTW
505c			 
505c			 
505c			.SPIO: 
505c			 
505c			if STORAGE_SE 
505c				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
505c 51				db WORD_SYS_CORE+61             
505d 6d 50			dw .SPICEH            
505f 07				db 6 + 1 
5060 .. 00			db "SPICEL",0              
5067				endm 
# End of macro CWHEAD
5067			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5067			 
5067 cd 6b 01				call spi_ce_low 
506a			    NEXTW 
506a c3 1d 21			jp macro_next 
506d				endm 
# End of macro NEXTW
506d			 
506d			.SPICEH: 
506d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
506d 51				db WORD_SYS_CORE+61             
506e 7e 50			dw .SPIOb            
5070 07				db 6 + 1 
5071 .. 00			db "SPICEH",0              
5078				endm 
# End of macro CWHEAD
5078			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5078			 
5078 cd 5a 01				call spi_ce_high 
507b			    NEXTW 
507b c3 1d 21			jp macro_next 
507e				endm 
# End of macro NEXTW
507e			 
507e			 
507e			.SPIOb: 
507e			 
507e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
507e 51				db WORD_SYS_CORE+61             
507f 94 50			dw .SPII            
5081 05				db 4 + 1 
5082 .. 00			db "SPIO",0              
5087				endm 
# End of macro CWHEAD
5087			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5087			 
5087					; get port 
5087			 
5087			 
5087					; get byte to send 
5087			 
5087					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5087 cd ab 1f			call macro_dsp_valuehl 
508a				endm 
# End of macro FORTH_DSP_VALUEHL
508a			 
508a			;		push hl    ; u1  
508a			 
508a					; destroy value TOS 
508a			 
508a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
508a cd 63 20			call macro_forth_dsp_pop 
508d				endm 
# End of macro FORTH_DSP_POP
508d			 
508d					; one value on hl get other one back 
508d			 
508d			;		pop hl   ; u2 - addr 
508d			 
508d					; TODO Send SPI byte 
508d			 
508d 7d					ld a, l 
508e cd 8f 00				call spi_send_byte 
5091			 
5091					NEXTW 
5091 c3 1d 21			jp macro_next 
5094				endm 
# End of macro NEXTW
5094			 
5094			.SPII: 
5094				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5094 52				db WORD_SYS_CORE+62             
5095 a9 50			dw .SESEL            
5097 06				db 5 + 1 
5098 .. 00			db "SPII",0              
509d				endm 
# End of macro CWHEAD
509d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
509d			 
509d					; TODO Get SPI byte 
509d			 
509d cd b0 00				call spi_read_byte 
50a0			 
50a0 26 00				ld h, 0 
50a2 6f					ld l, a 
50a3 cd b4 1d				call forth_push_numhl 
50a6			 
50a6					NEXTW 
50a6 c3 1d 21			jp macro_next 
50a9				endm 
# End of macro NEXTW
50a9			 
50a9			 
50a9			 
50a9			.SESEL: 
50a9				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
50a9 66				db WORD_SYS_CORE+82             
50aa 4d 51			dw .CARTDEV            
50ac 05				db 4 + 1 
50ad .. 00			db "BANK",0              
50b2				endm 
# End of macro CWHEAD
50b2			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
50b2					if DEBUG_FORTH_WORDS_KEY 
50b2						DMARK "BNK" 
50b2 f5				push af  
50b3 3a c7 50			ld a, (.dmark)  
50b6 32 b4 fe			ld (debug_mark),a  
50b9 3a c8 50			ld a, (.dmark+1)  
50bc 32 b5 fe			ld (debug_mark+1),a  
50bf 3a c9 50			ld a, (.dmark+2)  
50c2 32 b6 fe			ld (debug_mark+2),a  
50c5 18 03			jr .pastdmark  
50c7 ..			.dmark: db "BNK"  
50ca f1			.pastdmark: pop af  
50cb			endm  
# End of macro DMARK
50cb						CALLMONITOR 
50cb cd 57 17			call break_point_state  
50ce				endm  
# End of macro CALLMONITOR
50ce					endif 
50ce			 
50ce 3e ff				ld a, 255 
50d0 32 c8 fc				ld (spi_cartdev), a 
50d3			 
50d3					; get bank 
50d3			 
50d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d3 cd ab 1f			call macro_dsp_valuehl 
50d6				endm 
# End of macro FORTH_DSP_VALUEHL
50d6			 
50d6			;		push hl 
50d6			 
50d6					; destroy value TOS 
50d6			 
50d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50d6 cd 63 20			call macro_forth_dsp_pop 
50d9				endm 
# End of macro FORTH_DSP_POP
50d9			 
50d9					; one value on hl get other one back 
50d9			 
50d9			;		pop hl 
50d9			 
50d9			 
50d9 0e ff				ld c, SPI_CE_HIGH 
50db 06 30				ld b, '0'    ; human readable bank number 
50dd			 
50dd 7d					ld a, l 
50de			 
50de					if DEBUG_FORTH_WORDS 
50de						DMARK "BNK" 
50de f5				push af  
50df 3a f3 50			ld a, (.dmark)  
50e2 32 b4 fe			ld (debug_mark),a  
50e5 3a f4 50			ld a, (.dmark+1)  
50e8 32 b5 fe			ld (debug_mark+1),a  
50eb 3a f5 50			ld a, (.dmark+2)  
50ee 32 b6 fe			ld (debug_mark+2),a  
50f1 18 03			jr .pastdmark  
50f3 ..			.dmark: db "BNK"  
50f6 f1			.pastdmark: pop af  
50f7			endm  
# End of macro DMARK
50f7						CALLMONITOR 
50f7 cd 57 17			call break_point_state  
50fa				endm  
# End of macro CALLMONITOR
50fa					endif 
50fa			 
50fa					; active low 
50fa			 
50fa fe 00				cp 0 
50fc 28 28				jr z, .bset 
50fe fe 01				cp 1 
5100 20 04				jr nz, .b2 
5102 cb 81				res 0, c 
5104 06 31				ld b, '1'    ; human readable bank number 
5106 fe 02		.b2:		cp 2 
5108 20 04				jr nz, .b3 
510a cb 89				res 1, c 
510c 06 32				ld b, '2'    ; human readable bank number 
510e fe 03		.b3:		cp 3 
5110 20 04				jr nz, .b4 
5112 cb 91				res 2, c 
5114 06 33				ld b, '3'    ; human readable bank number 
5116 fe 04		.b4:		cp 4 
5118 20 04				jr nz, .b5 
511a cb 99				res 3, c 
511c 06 34				ld b, '4'    ; human readable bank number 
511e fe 05		.b5:		cp 5 
5120 20 04				jr nz, .bset 
5122 cb a1				res 4, c 
5124 06 35				ld b, '5'    ; human readable bank number 
5126			 
5126			.bset: 
5126 79					ld a, c 
5127 32 c5 fc				ld (spi_device),a 
512a 78					ld a, b 
512b 32 c4 fc				ld (spi_device_id),a 
512e					if DEBUG_FORTH_WORDS 
512e						DMARK "BN2" 
512e f5				push af  
512f 3a 43 51			ld a, (.dmark)  
5132 32 b4 fe			ld (debug_mark),a  
5135 3a 44 51			ld a, (.dmark+1)  
5138 32 b5 fe			ld (debug_mark+1),a  
513b 3a 45 51			ld a, (.dmark+2)  
513e 32 b6 fe			ld (debug_mark+2),a  
5141 18 03			jr .pastdmark  
5143 ..			.dmark: db "BN2"  
5146 f1			.pastdmark: pop af  
5147			endm  
# End of macro DMARK
5147						CALLMONITOR 
5147 cd 57 17			call break_point_state  
514a				endm  
# End of macro CALLMONITOR
514a					endif 
514a			 
514a					NEXTW 
514a c3 1d 21			jp macro_next 
514d				endm 
# End of macro NEXTW
514d			 
514d			.CARTDEV: 
514d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
514d 66				db WORD_SYS_CORE+82             
514e f6 51			dw .ENDDEVICE            
5150 08				db 7 + 1 
5151 .. 00			db "CARTDEV",0              
5159				endm 
# End of macro CWHEAD
5159			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5159					if DEBUG_FORTH_WORDS_KEY 
5159						DMARK "CDV" 
5159 f5				push af  
515a 3a 6e 51			ld a, (.dmark)  
515d 32 b4 fe			ld (debug_mark),a  
5160 3a 6f 51			ld a, (.dmark+1)  
5163 32 b5 fe			ld (debug_mark+1),a  
5166 3a 70 51			ld a, (.dmark+2)  
5169 32 b6 fe			ld (debug_mark+2),a  
516c 18 03			jr .pastdmark  
516e ..			.dmark: db "CDV"  
5171 f1			.pastdmark: pop af  
5172			endm  
# End of macro DMARK
5172						CALLMONITOR 
5172 cd 57 17			call break_point_state  
5175				endm  
# End of macro CALLMONITOR
5175					endif 
5175			 
5175					; disable se storage bank selection 
5175			 
5175 3e ff				ld a, SPI_CE_HIGH		; ce high 
5177 32 c5 fc				ld (spi_device), a 
517a			 
517a					; get bank 
517a			 
517a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
517a cd ab 1f			call macro_dsp_valuehl 
517d				endm 
# End of macro FORTH_DSP_VALUEHL
517d			 
517d			;		push hl 
517d			 
517d					; destroy value TOS 
517d			 
517d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
517d cd 63 20			call macro_forth_dsp_pop 
5180				endm 
# End of macro FORTH_DSP_POP
5180			 
5180					; one value on hl get other one back 
5180			 
5180			;		pop hl 
5180			 
5180					; active low 
5180			 
5180 0e ff				ld c, 255 
5182			 
5182 7d					ld a, l 
5183					if DEBUG_FORTH_WORDS 
5183						DMARK "CDV" 
5183 f5				push af  
5184 3a 98 51			ld a, (.dmark)  
5187 32 b4 fe			ld (debug_mark),a  
518a 3a 99 51			ld a, (.dmark+1)  
518d 32 b5 fe			ld (debug_mark+1),a  
5190 3a 9a 51			ld a, (.dmark+2)  
5193 32 b6 fe			ld (debug_mark+2),a  
5196 18 03			jr .pastdmark  
5198 ..			.dmark: db "CDV"  
519b f1			.pastdmark: pop af  
519c			endm  
# End of macro DMARK
519c						CALLMONITOR 
519c cd 57 17			call break_point_state  
519f				endm  
# End of macro CALLMONITOR
519f					endif 
519f fe 00				cp 0 
51a1 28 30				jr z, .cset 
51a3 fe 01				cp 1 
51a5 20 02				jr nz, .c2 
51a7 cb 81				res 0, c 
51a9 fe 02		.c2:		cp 2 
51ab 20 02				jr nz, .c3 
51ad cb 89				res 1, c 
51af fe 03		.c3:		cp 3 
51b1 20 02				jr nz, .c4 
51b3 cb 91				res 2, c 
51b5 fe 04		.c4:		cp 4 
51b7 20 02				jr nz, .c5 
51b9 cb 99				res 3, c 
51bb fe 05		.c5:		cp 5 
51bd 20 02				jr nz, .c6 
51bf cb a1				res 4, c 
51c1 fe 06		.c6:		cp 6 
51c3 20 02				jr nz, .c7 
51c5 cb a9				res 5, c 
51c7 fe 07		.c7:		cp 7 
51c9 20 02				jr nz, .c8 
51cb cb b1				res 6, c 
51cd fe 08		.c8:		cp 8 
51cf 20 02				jr nz, .cset 
51d1 cb b9				res 7, c 
51d3 79			.cset:		ld a, c 
51d4 32 c8 fc				ld (spi_cartdev),a 
51d7			 
51d7					if DEBUG_FORTH_WORDS 
51d7						DMARK "CD2" 
51d7 f5				push af  
51d8 3a ec 51			ld a, (.dmark)  
51db 32 b4 fe			ld (debug_mark),a  
51de 3a ed 51			ld a, (.dmark+1)  
51e1 32 b5 fe			ld (debug_mark+1),a  
51e4 3a ee 51			ld a, (.dmark+2)  
51e7 32 b6 fe			ld (debug_mark+2),a  
51ea 18 03			jr .pastdmark  
51ec ..			.dmark: db "CD2"  
51ef f1			.pastdmark: pop af  
51f0			endm  
# End of macro DMARK
51f0						CALLMONITOR 
51f0 cd 57 17			call break_point_state  
51f3				endm  
# End of macro CALLMONITOR
51f3					endif 
51f3					NEXTW 
51f3 c3 1d 21			jp macro_next 
51f6				endm 
# End of macro NEXTW
51f6			endif 
51f6			 
51f6			.ENDDEVICE: 
51f6			; eof 
51f6			 
# End of file forth_words_device.asm
51f6			 
51f6			; var handler 
51f6			 
51f6			 
51f6			.VARS: 
51f6				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
51f6 78				db WORD_SYS_CORE+100             
51f7 0e 52			dw .V0Q            
51f9 04				db 3 + 1 
51fa .. 00			db "V0!",0              
51fe				endm 
# End of macro CWHEAD
51fe			;| V0! ( u1 -- )  Store value to v0  | DONE 
51fe			 
51fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51fe cd ab 1f			call macro_dsp_valuehl 
5201				endm 
# End of macro FORTH_DSP_VALUEHL
5201			 
5201 11 8d fc				ld de, cli_var_array 
5204			 
5204 eb					ex de, hl 
5205 73					ld (hl), e 
5206 23					inc hl 
5207 72					ld (hl), d 
5208			 
5208					; destroy value TOS 
5208			 
5208					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5208 cd 63 20			call macro_forth_dsp_pop 
520b				endm 
# End of macro FORTH_DSP_POP
520b			 
520b				       NEXTW 
520b c3 1d 21			jp macro_next 
520e				endm 
# End of macro NEXTW
520e			.V0Q: 
520e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
520e 79				db WORD_SYS_CORE+101             
520f 1f 52			dw .V1S            
5211 04				db 3 + 1 
5212 .. 00			db "V0@",0              
5216				endm 
# End of macro CWHEAD
5216			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5216 2a 8d fc				ld hl, (cli_var_array) 
5219 cd b4 1d				call forth_push_numhl 
521c			 
521c				       NEXTW 
521c c3 1d 21			jp macro_next 
521f				endm 
# End of macro NEXTW
521f			.V1S: 
521f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
521f 7a				db WORD_SYS_CORE+102             
5220 37 52			dw .V1Q            
5222 04				db 3 + 1 
5223 .. 00			db "V1!",0              
5227				endm 
# End of macro CWHEAD
5227			;| V1! ( u1 -- )  Store value to v1 | DONE 
5227					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5227 cd ab 1f			call macro_dsp_valuehl 
522a				endm 
# End of macro FORTH_DSP_VALUEHL
522a			 
522a 11 8f fc				ld de, cli_var_array+2 
522d				 
522d eb					ex de, hl 
522e 73					ld (hl), e 
522f 23					inc hl 
5230 72					ld (hl), d 
5231			 
5231					; destroy value TOS 
5231			 
5231					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5231 cd 63 20			call macro_forth_dsp_pop 
5234				endm 
# End of macro FORTH_DSP_POP
5234				       NEXTW 
5234 c3 1d 21			jp macro_next 
5237				endm 
# End of macro NEXTW
5237			.V1Q: 
5237				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5237 7b				db WORD_SYS_CORE+103             
5238 48 52			dw .V2S            
523a 04				db 3 + 1 
523b .. 00			db "V1@",0              
523f				endm 
# End of macro CWHEAD
523f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
523f 2a 8f fc				ld hl, (cli_var_array+2) 
5242 cd b4 1d				call forth_push_numhl 
5245				       NEXTW 
5245 c3 1d 21			jp macro_next 
5248				endm 
# End of macro NEXTW
5248			.V2S: 
5248				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5248 7c				db WORD_SYS_CORE+104             
5249 60 52			dw .V2Q            
524b 04				db 3 + 1 
524c .. 00			db "V2!",0              
5250				endm 
# End of macro CWHEAD
5250			;| V2! ( u1 -- )  Store value to v2 | DONE 
5250					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5250 cd ab 1f			call macro_dsp_valuehl 
5253				endm 
# End of macro FORTH_DSP_VALUEHL
5253			 
5253 11 91 fc				ld de, cli_var_array+4 
5256				 
5256 eb					ex de, hl 
5257 73					ld (hl), e 
5258 23					inc hl 
5259 72					ld (hl), d 
525a			 
525a					; destroy value TOS 
525a			 
525a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
525a cd 63 20			call macro_forth_dsp_pop 
525d				endm 
# End of macro FORTH_DSP_POP
525d				       NEXTW 
525d c3 1d 21			jp macro_next 
5260				endm 
# End of macro NEXTW
5260			.V2Q: 
5260				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5260 7d				db WORD_SYS_CORE+105             
5261 71 52			dw .V3S            
5263 04				db 3 + 1 
5264 .. 00			db "V2@",0              
5268				endm 
# End of macro CWHEAD
5268			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5268 2a 91 fc				ld hl, (cli_var_array+4) 
526b cd b4 1d				call forth_push_numhl 
526e				       NEXTW 
526e c3 1d 21			jp macro_next 
5271				endm 
# End of macro NEXTW
5271			.V3S: 
5271				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5271 7c				db WORD_SYS_CORE+104             
5272 89 52			dw .V3Q            
5274 04				db 3 + 1 
5275 .. 00			db "V3!",0              
5279				endm 
# End of macro CWHEAD
5279			;| V3! ( u1 -- )  Store value to v3 | DONE 
5279					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5279 cd ab 1f			call macro_dsp_valuehl 
527c				endm 
# End of macro FORTH_DSP_VALUEHL
527c			 
527c 11 93 fc				ld de, cli_var_array+6 
527f				 
527f eb					ex de, hl 
5280 73					ld (hl), e 
5281 23					inc hl 
5282 72					ld (hl), d 
5283			 
5283					; destroy value TOS 
5283			 
5283					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5283 cd 63 20			call macro_forth_dsp_pop 
5286				endm 
# End of macro FORTH_DSP_POP
5286				       NEXTW 
5286 c3 1d 21			jp macro_next 
5289				endm 
# End of macro NEXTW
5289			.V3Q: 
5289				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5289 7d				db WORD_SYS_CORE+105             
528a 9a 52			dw .END            
528c 04				db 3 + 1 
528d .. 00			db "V3@",0              
5291				endm 
# End of macro CWHEAD
5291			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5291 2a 93 fc				ld hl, (cli_var_array+6) 
5294 cd b4 1d				call forth_push_numhl 
5297				       NEXTW 
5297 c3 1d 21			jp macro_next 
529a				endm 
# End of macro NEXTW
529a			 
529a			 
529a			 
529a			 
529a			 
529a			; end of dict marker 
529a			 
529a 00			.END:    db WORD_SYS_END 
529b 00 00			dw 0 
529d 00				db 0 
529e			 
529e			; use to jp here for user dict words to save on macro expansion  
529e			 
529e			user_dict_next: 
529e				NEXTW 
529e c3 1d 21			jp macro_next 
52a1				endm 
# End of macro NEXTW
52a1			 
52a1			 
52a1			user_exec: 
52a1				;    ld hl, <word code> 
52a1				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
52a1				;    call forthexec 
52a1				;    jp user_dict_next   (NEXT) 
52a1			        ;    <word code bytes> 
52a1 eb				ex de, hl 
52a2 2a 5b f7			ld hl,(os_tok_ptr) 
52a5				 
52a5				FORTH_RSP_NEXT 
52a5 cd 5b 1d			call macro_forth_rsp_next 
52a8				endm 
# End of macro FORTH_RSP_NEXT
52a8			 
52a8			if DEBUG_FORTH_UWORD 
52a8						DMARK "UEX" 
52a8 f5				push af  
52a9 3a bd 52			ld a, (.dmark)  
52ac 32 b4 fe			ld (debug_mark),a  
52af 3a be 52			ld a, (.dmark+1)  
52b2 32 b5 fe			ld (debug_mark+1),a  
52b5 3a bf 52			ld a, (.dmark+2)  
52b8 32 b6 fe			ld (debug_mark+2),a  
52bb 18 03			jr .pastdmark  
52bd ..			.dmark: db "UEX"  
52c0 f1			.pastdmark: pop af  
52c1			endm  
# End of macro DMARK
52c1				CALLMONITOR 
52c1 cd 57 17			call break_point_state  
52c4				endm  
# End of macro CALLMONITOR
52c4			endif 
52c4			 
52c4			 
52c4			 
52c4 eb				ex de, hl 
52c5 22 5b f7			ld (os_tok_ptr), hl 
52c8				 
52c8				; Don't use next - Skips the first word in uword. 
52c8			 
52c8 c3 ae 21			jp exec1 
52cb			;	NEXT 
52cb			 
52cb			 
52cb			; eof 
# End of file forth_wordsv4.asm
52cb			endif 
52cb			;;;;;;;;;;;;;; Debug code 
52cb			 
52cb			 
52cb			;if DEBUG_FORTH_PARSE 
52cb .. 00		.nowordfound: db "No match",0 
52d4 .. 00		.compword:	db "Comparing word ",0 
52e4 .. 00		.nextwordat:	db "Next word at",0 
52f1 .. 00		.charmatch:	db "Char match",0 
52fc			;endif 
52fc			if DEBUG_FORTH_JP 
52fc			.foundword:	db "Word match. Exec..",0 
52fc			endif 
52fc			;if DEBUG_FORTH_PUSH 
52fc .. 00		.enddict:	db "Dict end. Push.",0 
530c .. 00		.push_str:	db "Pushing string",0 
531b .. 00		.push_num:	db "Pushing number",0 
532a .. 00		.data_sp:	db "SP:",0 
532e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5340 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5352 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5364			;endif 
5364			;if DEBUG_FORTH_MALLOC 
5364 .. 00		.push_malloc:	db "Malloc address",0 
5373			;endif 
5373			 
5373			 
5373			 
5373			; display malloc address and current data stack pointer  
5373			 
5373			malloc_error: 
5373 d5				push de 
5374 f5				push af 
5375 e5				push hl 
5376 cd a6 0b			call clear_display 
5379 11 9b 53			ld de, .mallocerr 
537c 3e 00			ld a,0 
537e			;	ld de,os_word_scratch 
537e cd b9 0b			call str_at_display 
5381 3e 11			ld a, display_row_1+17 
5383 11 b4 fe			ld de, debug_mark 
5386 cd b9 0b			call str_at_display 
5389 cd c9 0b			call update_display 
538c				;call break_point_state 
538c cd 21 69			call cin_wait 
538f			 
538f 3e 20			ld a, ' ' 
5391 32 4b f4			ld (os_view_disable), a 
5394 e1				pop hl 
5395 f1				pop af 
5396 d1				pop de	 
5397				CALLMONITOR 
5397 cd 57 17			call break_point_state  
539a				endm  
# End of macro CALLMONITOR
539a c9				ret 
539b			 
539b .. 00		.mallocerr: 	db "Malloc Error",0 
53a8			;if DEBUG_FORTH_PUSH 
53a8			display_data_sp: 
53a8 f5				push af 
53a9			 
53a9				; see if disabled 
53a9			 
53a9 3a 4b f4			ld a, (os_view_disable) 
53ac fe 2a			cp '*' 
53ae 28 67			jr z, .skipdsp 
53b0			 
53b0 e5				push hl 
53b1 e5				push hl 
53b2 e5			push hl 
53b3 cd a6 0b			call clear_display 
53b6 e1			pop hl 
53b7 7c				ld a,h 
53b8 21 5f f7			ld hl, os_word_scratch 
53bb cd db 10			call hexout 
53be e1				pop hl 
53bf 7d				ld a,l 
53c0 21 61 f7			ld hl, os_word_scratch+2 
53c3 cd db 10			call hexout 
53c6 21 63 f7			ld hl, os_word_scratch+4 
53c9 3e 00			ld a,0 
53cb 77				ld (hl),a 
53cc 11 5f f7			ld de,os_word_scratch 
53cf 3e 14				ld a, display_row_2 
53d1 cd b9 0b				call str_at_display 
53d4 11 2e 53			ld de, .wordinhl 
53d7 3e 00			ld a, display_row_1 
53d9			 
53d9 cd b9 0b				call str_at_display 
53dc 11 b4 fe			ld de, debug_mark 
53df 3e 11			ld a, display_row_1+17 
53e1			 
53e1 cd b9 0b				call str_at_display 
53e4			 
53e4				; display current data stack pointer 
53e4 11 2a 53			ld de,.data_sp 
53e7 3e 1c				ld a, display_row_2 + 8 
53e9 cd b9 0b				call str_at_display 
53ec			 
53ec 2a 87 fc			ld hl,(cli_data_sp) 
53ef e5				push hl 
53f0 7c				ld a,h 
53f1 21 5f f7			ld hl, os_word_scratch 
53f4 cd db 10			call hexout 
53f7 e1				pop hl 
53f8 7d				ld a,l 
53f9 21 61 f7			ld hl, os_word_scratch+2 
53fc cd db 10			call hexout 
53ff 21 63 f7			ld hl, os_word_scratch+4 
5402 3e 00			ld a,0 
5404 77				ld (hl),a 
5405 11 5f f7			ld de,os_word_scratch 
5408 3e 1f				ld a, display_row_2 + 11 
540a cd b9 0b				call str_at_display 
540d			 
540d			 
540d cd c9 0b			call update_display 
5410 cd 23 0b			call delay1s 
5413 cd 23 0b			call delay1s 
5416 e1				pop hl 
5417			.skipdsp: 
5417 f1				pop af 
5418 c9				ret 
5419			 
5419			display_data_malloc: 
5419			 
5419 f5				push af 
541a e5				push hl 
541b e5				push hl 
541c e5			push hl 
541d cd a6 0b			call clear_display 
5420 e1			pop hl 
5421 7c				ld a,h 
5422 21 5f f7			ld hl, os_word_scratch 
5425 cd db 10			call hexout 
5428 e1				pop hl 
5429 7d				ld a,l 
542a 21 61 f7			ld hl, os_word_scratch+2 
542d cd db 10			call hexout 
5430 21 63 f7			ld hl, os_word_scratch+4 
5433 3e 00			ld a,0 
5435 77				ld (hl),a 
5436 11 5f f7			ld de,os_word_scratch 
5439 3e 14				ld a, display_row_2 
543b cd b9 0b				call str_at_display 
543e 11 64 53			ld de, .push_malloc 
5441 3e 00			ld a, display_row_1 
5443			 
5443 cd b9 0b				call str_at_display 
5446			 
5446				; display current data stack pointer 
5446 11 2a 53			ld de,.data_sp 
5449 3e 1c				ld a, display_row_2 + 8 
544b cd b9 0b				call str_at_display 
544e			 
544e 2a 87 fc			ld hl,(cli_data_sp) 
5451 e5				push hl 
5452 7c				ld a,h 
5453 21 5f f7			ld hl, os_word_scratch 
5456 cd db 10			call hexout 
5459 e1				pop hl 
545a 7d				ld a,l 
545b 21 61 f7			ld hl, os_word_scratch+2 
545e cd db 10			call hexout 
5461 21 63 f7			ld hl, os_word_scratch+4 
5464 3e 00			ld a,0 
5466 77				ld (hl),a 
5467 11 5f f7			ld de,os_word_scratch 
546a 3e 1f				ld a, display_row_2 + 11 
546c cd b9 0b				call str_at_display 
546f			 
546f cd c9 0b			call update_display 
5472 cd 23 0b			call delay1s 
5475 cd 23 0b			call delay1s 
5478 e1				pop hl 
5479 f1				pop af 
547a c9				ret 
547b			;endif 
547b			 
547b			include "forth_autostart.asm" 
547b			; list of commands to perform at system start up 
547b			 
547b			startcmds: 
547b			;	dw test11 
547b			;	dw test12 
547b			;	dw test13 
547b			;	dw test14 
547b			;	dw test15 
547b			;	dw test16 
547b			;	dw test17 
547b			;	dw ifthtest1 
547b			;	dw ifthtest2 
547b			;	dw ifthtest3 
547b			;	dw mmtest1 
547b			;	dw mmtest2 
547b			;	dw mmtest3 
547b			;	dw mmtest4 
547b			;	dw mmtest5 
547b			;	dw mmtest6 
547b			;	dw iftest1 
547b			;	dw iftest2 
547b			;	dw iftest3 
547b			;	dw looptest1 
547b			;	dw looptest2 
547b			;	dw test1 
547b			;	dw test2 
547b			;	dw test3 
547b			;	dw test4 
547b			;	dw game2r 
547b			;	dw game2b1 
547b			;	dw game2b2 
547b			 
547b				; start up words that are actually useful 
547b			 
547b d9 54			dw clrstack 
547d 0c 55			dw type 
547f fc 56			dw stest 
5481 30 55			dw strncpy 
5483 92 56			dw list 
5485 91 55			dw start1 
5487 a3 55			dw start2 
5489			;	dw start3 
5489 b6 55			dw start3b 
548b 32 56			dw start3c 
548d			 
548d				; (unit) testing words 
548d			 
548d 73 57			dw mtesta 
548f 28 58			dw mtestb 
5491 cb 58			dw mtestc 
5493 80 59			dw mtestd 
5495 24 5a			dw mteste 
5497			 
5497				; demo/game words 
5497			 
5497 30 61		        dw game3w 
5499 5e 61		        dw game3p 
549b 7c 61		        dw game3sc 
549d ad 61		        dw game3vsi 
549f d9 61		        dw game3vs 
54a1				 
54a1 23 5f			dw game2b 
54a3 91 5f			dw game2bf 
54a5 db 5f			dw game2mba 
54a7 71 60			dw game2mbas 
54a9 b3 60			dw game2mb 
54ab			 
54ab e4 5b			dw game1 
54ad f5 5b			dw game1a 
54af 57 5c			dw game1b 
54b1 8c 5c			dw game1c 
54b3 c2 5c			dw game1d 
54b5 f3 5c			dw game1s 
54b7 07 5d			dw game1t 
54b9 1c 5d			dw game1f 
54bb 50 5d			dw game1z 
54bd 94 5d			dw game1zz 
54bf			 
54bf da 5a			dw test5 
54c1 12 5b			dw test6 
54c3 4a 5b			dw test7 
54c5 5e 5b			dw test8 
54c7 8a 5b			dw test9 
54c9 a0 5b			dw test10 
54cb				 
54cb 6b 5e		        dw ssv5 
54cd 4f 5e		        dw ssv4 
54cf 33 5e		        dw ssv3 
54d1 fd 5d		        dw ssv2 
54d3 84 5e		        dw ssv1 
54d5 cc 5e		        dw ssv1cpm 
54d7			;	dw keyup 
54d7			;	dw keydown 
54d7			;	dw keyleft 
54d7			;	dw keyright 
54d7			;	dw 	keyf1 
54d7			;	dw keyf2 
54d7			;	dw keyf3 
54d7			;	dw keyf4 
54d7			;	dw keyf5 
54d7			;	dw keyf6 
54d7			;	dw keyf7 
54d7			;	dw keyf8 
54d7			;	dw keyf9 
54d7			;	dw keyf10 
54d7			;	dw keyf11 
54d7			;	dw keyf12 
54d7			;	dw keytab 
54d7			;	dw keycr 
54d7			;	dw keyhome 
54d7			;	dw keyend 
54d7			;	dw keybs 
54d7 00 00			db 0, 0	 
54d9			 
54d9			 
54d9			; clear stack  
54d9			 
54d9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
550c			 
550c			; type ( addr count - ) 
550c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5530			 
5530			; some direct memory words 
5530			; strncpy ( len t f -- t ) 
5530			 
5530 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5591			 
5591 .. 00		start1:     	db ": bpon $0000 bp ;",0 
55a3 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
55b6 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5632 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5692			 
5692			 
5692			; a handy word to list items on the stack 
5692			 
5692 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
56fc			 
56fc			 
56fc			; test stack  
56fc			; rnd8 stest 
56fc			 
56fc .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5773			 
5773			; random malloc and free cycles 
5773			 
5773 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5828			 
5828			; fixed malloc and free cycles 
5828			 
5828 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
58cb			 
58cb			; fixed double string push and drop cycle  
58cb			 
58cb .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5980			 
5980			; consistent fixed string push and drop cycle  
5980			 
5980 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5a24			 
5a24 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5ada			 
5ada			;test1:		db ": aa 1 2 3 ;", 0 
5ada			;test2:     	db "111 aa 888 999",0 
5ada			;test3:     	db ": bb 77 ;",0 
5ada			;test4:     	db "$02 $01 do i . loop bb",0 
5ada			 
5ada .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5b12 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5b4a .. 00		test7:     	db ": box hline vline ;",0 
5b5e .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5b8a .. 00		test9:     	db ": sw $01 adsp world ;",0 
5ba0 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5bc5 .. 00		test11:     	db "hello create .",0 
5bd4 .. 00		test12:     	db "hello2 create .",0 
5be4			 
5be4			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5be4			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5be4			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5be4			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5be4			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5be4			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5be4			 
5be4			;iftest1:     	db "$0001 IF cls .",0 
5be4			;iftest2:     	db "$0000 IF cls .",0 
5be4			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5be4			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5be4			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5be4			 
5be4			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5be4			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5be4			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5be4			 
5be4			 
5be4			 
5be4			; a small guess the number game 
5be4			 
5be4 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5bf5 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5c57			 
5c57 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5c8c .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5cc2 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5cf3 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5d07 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5d1c .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5d50 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5d94			 
5d94			; Using 'ga' save a high score across multiple runs using external storage 
5d94			 
5d94 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5dfd			 
5dfd			 
5dfd			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5dfd			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5dfd			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5dfd			 
5dfd			; simple screen saver to test code memory reuse to destruction 
5dfd			 
5dfd .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5e33 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5e4f .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5e6b .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5e84 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5ecc .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5f23			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5f23			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5f23			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5f23			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5f23			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5f23			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5f23			 
5f23			 
5f23			 
5f23			; minesweeper/battleship finding game 
5f23			; draws a game board of random ship/mine positions 
5f23			; user enters coords to see if it hits on 
5f23			; game ends when all are hit 
5f23			; when hit or miss says how many may be in the area 
5f23			 
5f23			; setup the game board and then hide it 
5f23 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5f91 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5fdb			; prompt for where to target 
5fdb .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6071 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6096			; TODO see if the entered coords hits or misses pushes char hit of miss 
6096 .. 00		game2mbht:      db ": mbckht nop ;",0 
60a5 .. 00		game2mbms:      db ": mbcms nop ;",0 
60b3			; TODO how many might be near by 
60b3 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6130			 
6130			; Game 3 
6130			 
6130			; Vert scroller ski game - avoid the trees! 
6130			 
6130			; v0 score (ie turns) 
6130			; v1 player pos 
6130			; v2 left wall 
6130			; v3 right wall 
6130			 
6130			; Draw side walls randomly 
6130			 
6130 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
615e			 
615e			; Draw player 
615e .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
617c			 
617c			; TODO Get Key 
617c			 
617c			; TODO Move left right 
617c			 
617c			; scroll and move walls a bit 
617c			 
617c .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
61ad			 
61ad			; main game loop 
61ad			 
61ad .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
61d9 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6218			 
6218			; key board defs 
6218			 
6218 .. 00		keyup:       db ": keyup $05 ;",0 
6226 .. 00		keydown:       db ": keydown $0a ;",0 
6236 .. 00		keyleft:       db ": keyleft $0b ;",0 
6246 .. 00		keyright:       db ": keyright $0c ;",0 
6257 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6265 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6273 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6281 .. 00		keyf4:       db ": keyf4 $13 ;",0 
628f .. 00		keyf5:       db ": keyf5 $14 ;",0 
629d .. 00		keyf6:       db ": keyf6 $15 ;",0 
62ab .. 00		keyf7:       db ": keyf7 $16 ;",0 
62b9 .. 00		keyf8:       db ": keyf8 $17 ;",0 
62c7 .. 00		keyf9:       db ": keyf9 $18 ;",0 
62d5 .. 00		keyf10:       db ": keyf10 $19 ;",0 
62e4 .. 00		keyf11:       db ": keyf11 $1a ;",0 
62f3 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6302			 
6302 .. 00		keytab:       db ": keytab $09 ;",0 
6311 .. 00		keycr:       db ": keycr $0d ;",0 
631f .. 00		keyhome:       db ": keyhome $0e ;",0 
632f .. 00		keyend:       db ": keyend $0f ;",0 
633e .. 00		keybs:       db ": keybs $08 ;",0 
634c			 
634c			   
634c			 
634c			 
634c			 
634c			; eof 
# End of file forth_autostart.asm
634c			 
634c .. 00		sprompt1: db "Startup load...",0 
635c .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6372			 
6372			 
6372			 
6372			 
6372			forth_startup: 
6372 21 7b 54			ld hl, startcmds 
6375 3e 00			ld a, 0 
6377 32 80 f8			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
637a			 
637a e5			.start1:	push hl 
637b cd a6 0b			call clear_display 
637e 11 4c 63			ld de, sprompt1 
6381 3e 00		        ld a, display_row_1 
6383 cd b9 0b			call str_at_display 
6386 11 5c 63			ld de, sprompt2 
6389 3e 14		        ld a, display_row_2 
638b cd b9 0b			call str_at_display 
638e e1				pop hl 
638f e5				push hl 
6390 5e				ld e,(hl) 
6391 23				inc hl 
6392 56				ld d,(hl) 
6393 3e 28		        ld a, display_row_3 
6395 cd b9 0b			call str_at_display 
6398 cd c9 0b			call update_display 
639b			 
639b			 
639b 3a 80 f8			ld a, (os_last_cmd) 
639e fe 00			cp 0 
63a0 28 05			jr z, .startprompt 
63a2 cd 17 0b			call delay250ms 
63a5 18 24			jr .startdo 
63a7				 
63a7				 
63a7			 
63a7			.startprompt: 
63a7			 
63a7 3e 4f			ld a,display_row_4 + display_cols - 1 
63a9 11 2a 1d		        ld de, endprg 
63ac cd b9 0b			call str_at_display 
63af cd c9 0b			call update_display 
63b2 cd 23 0b			call delay1s 
63b5 cd 21 69			call cin_wait 
63b8						 
63b8 fe 2a			cp '*' 
63ba 28 5e			jr z, .startupend1 
63bc fe 23			cp '#' 
63be 20 07			jr nz, .startno 
63c0 3e 01			ld a, 1 
63c2 32 80 f8			ld (os_last_cmd),a 
63c5 18 04			jr .startdo 
63c7 fe 31		.startno:	cp '1' 
63c9 28 3a			jr z,.startnxt  
63cb			 
63cb				; exec startup line 
63cb			.startdo:	 
63cb e1				pop hl 
63cc e5				push hl 
63cd				 
63cd 5e				ld e,(hl) 
63ce 23				inc hl 
63cf 56				ld d,(hl) 
63d0 eb				ex de,hl 
63d1			 
63d1 e5				push hl 
63d2			 
63d2 3e 00			ld a, 0 
63d4				;ld a, FORTH_END_BUFFER 
63d4 cd 43 12			call strlent 
63d7 23				inc hl   ; include zero term to copy 
63d8 06 00			ld b,0 
63da 4d				ld c,l 
63db e1				pop hl 
63dc 11 5a f4			ld de, scratch 
63df ed b0			ldir 
63e1			 
63e1			 
63e1 21 5a f4			ld hl, scratch 
63e4 cd 6b 21			call forthparse 
63e7 cd ab 21			call forthexec 
63ea cd c2 20			call forthexec_cleanup 
63ed			 
63ed 3e 3c			ld a, display_row_4 
63ef 11 ce 1a			ld de, endprog 
63f2			 
63f2 cd c9 0b			call update_display		 
63f5			 
63f5 3a 80 f8			ld a, (os_last_cmd) 
63f8 fe 00			cp 0 
63fa 20 09			jr nz, .startnxt 
63fc cd 2c 1d			call next_page_prompt 
63ff cd a6 0b		        call clear_display 
6402 cd c9 0b			call update_display		 
6405			 
6405				; move onto next startup line? 
6405			.startnxt: 
6405			 
6405 cd 17 0b			call delay250ms 
6408 e1				pop hl 
6409			 
6409 23				inc hl 
640a 23				inc hl 
640b			 
640b e5				push hl 
640c 5e				ld e, (hl) 
640d 23				inc hl 
640e 56				ld d, (hl) 
640f e1				pop hl 
6410				; TODO replace 0 test 
6410			 
6410 eb				ex de, hl 
6411 cd 03 0e			call ishlzero 
6414			;	ld a,e 
6414			;	add d 
6414			;	cp 0    ; any left to do? 
6414 eb				ex de, hl 
6415 c2 7a 63			jp nz, .start1 
6418 18 01			jr .startupend 
641a			 
641a e1			.startupend1: pop hl 
641b			.startupend: 
641b			 
641b cd a6 0b			call clear_display 
641e cd c9 0b			call update_display 
6421 c9				ret 
6422			 
6422			 
6422			; stack over and underflow checks 
6422			 
6422			; init the words to detect the under/overflow 
6422			 
6422			chk_stk_init: 
6422				; a vague random number to check so we dont get any "lucky" hits 
6422 3e 2d			ld a, 45 
6424 6f				ld l, a 
6425 00				nop 
6426 3e 17			ld a, 23 
6428 67				ld h, a 
6429			 
6429 22 41 f4			ld (chk_word), hl     ; the word we need to check against 
642c			 
642c			;	ld (chk_stund), hl	; stack points.... 
642c 22 fd fe			ld (chk_stovr), hl 
642f 22 85 fc			ld (chk_ret_und), hl 
6432 22 43 fc			ld (chk_ret_ovr), hl 
6435 22 c1 fb			ld (chk_loop_ovr), hl 
6438 22 bf f9			ld (chk_data_ovr), hl 
643b c9				ret 
643c				 
643c			check_stacks: 
643c				; check all stack words 
643c			 
643c e5				push hl 
643d d5				push de 
643e			 
643e			;	ld de,(chk_word) 
643e			;	ld hl, (chk_stund)	; stack points.... 
643e			;	if DEBUG_STK_FAULT 
643e			;		DMARK "FAa" 
643e			;		CALLMONITOR 
643e			;	endif 
643e			;	call cmp16 
643e			;	jp z, .chk_faulta 
643e			; 
643e			;	ld de, sfaultsu 
643e			;	jp .chk_fault 
643e			 
643e 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6441 ed 5b 41 f4		ld de,(chk_word) 
6445				if DEBUG_STK_FAULT 
6445					DMARK "FAb" 
6445					CALLMONITOR 
6445				endif 
6445 cd f8 0d			call cmp16 
6448 28 06			jr z, .chk_fault1 
644a 11 eb 64			ld de, sfaultso 
644d c3 9f 64			jp .chk_fault 
6450			.chk_fault1:  
6450 2a 85 fc			ld hl, (chk_ret_und) 
6453 ed 5b 41 f4		ld de,(chk_word) 
6457				if DEBUG_STK_FAULT 
6457					DMARK "FAU" 
6457					CALLMONITOR 
6457				endif 
6457 cd f8 0d			call cmp16 
645a ca 63 64			jp z, .chk_fault2 
645d 11 fb 64			ld de, sfaultru 
6460 c3 9f 64			jp .chk_fault 
6463			.chk_fault2:  
6463 2a 43 fc			ld hl, (chk_ret_ovr) 
6466 ed 5b 41 f4		ld de,(chk_word) 
646a				if DEBUG_STK_FAULT 
646a					DMARK "FA1" 
646a					CALLMONITOR 
646a				endif 
646a cd f8 0d			call cmp16 
646d ca 76 64			jp z, .chk_fault3 
6470 11 09 65			ld de, sfaultro 
6473 c3 9f 64			jp .chk_fault 
6476			.chk_fault3:  
6476 2a c1 fb			ld hl, (chk_loop_ovr) 
6479 ed 5b 41 f4		ld de,(chk_word) 
647d				if DEBUG_STK_FAULT 
647d					DMARK "FA2" 
647d					CALLMONITOR 
647d				endif 
647d cd f8 0d			call cmp16 
6480 ca 89 64			jp z, .chk_fault4 
6483 11 23 65			ld de, sfaultlo 
6486 c3 9f 64			jp .chk_fault 
6489			.chk_fault4:  
6489 2a bf f9			ld hl, (chk_data_ovr) 
648c ed 5b 41 f4		ld de,(chk_word) 
6490				if DEBUG_STK_FAULT 
6490					DMARK "FA3" 
6490					CALLMONITOR 
6490				endif 
6490 cd f8 0d			call cmp16 
6493 ca 9c 64			jp z, .chk_fault5 
6496 11 3d 65			ld de, sfaultdo 
6499 c3 9f 64			jp .chk_fault 
649c			 
649c			 
649c			.chk_fault5:  
649c d1				pop de 
649d e1				pop hl 
649e			 
649e c9				ret 
649f			 
649f cd a6 0b		.chk_fault: 	call clear_display 
64a2 3e 14				ld a, display_row_2 
64a4 cd b9 0b				call str_at_display 
64a7 11 cd 64				   ld de, .stackfault 
64aa 3e 00				ld a, display_row_1 
64ac cd b9 0b				call str_at_display 
64af 11 b4 fe				    ld de, debug_mark 
64b2 3e 11				ld a, display_row_1+17 
64b4 cd b9 0b				call str_at_display 
64b7 cd c9 0b				call update_display 
64ba			 
64ba				; prompt before entering montior for investigating issue 
64ba			 
64ba 3e 3c			ld a, display_row_4 
64bc 11 ce 1a			ld de, endprog 
64bf			 
64bf cd c9 0b			call update_display		 
64c2			 
64c2 cd 2c 1d			call next_page_prompt 
64c5			 
64c5 d1				pop de 
64c6 e1				pop hl 
64c7 cd 22 1b				call monitor 
64ca c3 19 1a				jp warmstart 
64cd					;jp 0 
64cd					;halt 
64cd			 
64cd			 
64cd			 
64cd .. 00		.stackfault: 	db "Stack fault:",0 
64da			 
64da .. 00		sfaultsu: 	db	"Stack under flow",0 
64eb .. 00		sfaultso: 	db	"Stack over flow",0 
64fb .. 00		sfaultru:	db "RTS underflow",0 
6509 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6523 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
653d .. 00		sfaultdo:	db "DTS overflow", 0 
654a			 
654a			 
654a			fault_dsp_under: 
654a 11 5c 65			ld de, .dsp_under 
654d c3 0c 66			jp .show_fault 
6550			 
6550			fault_rsp_under: 
6550 11 6a 65			ld de, .rsp_under 
6553 c3 0c 66			jp .show_fault 
6556			fault_loop_under: 
6556 11 78 65			ld de, .loop_under 
6559 c3 0c 66			jp .show_fault 
655c			 
655c .. 00		.dsp_under: db "DSP Underflow",0 
656a .. 00		.rsp_under: db "RSP Underflow",0 
6578 .. 00		.loop_under: db "LOOP Underflow",0 
6587			 
6587			 
6587 d5			type_faultn: 	push de 
6588 e5					push hl 
6589 cd a6 0b				call clear_display 
658c 11 b3 65				   ld de, .typefaultn 
658f 3e 00				ld a, display_row_1 
6591 cd b9 0b				call str_at_display 
6594 11 b4 fe				    ld de, debug_mark 
6597 3e 11				ld a, display_row_1+17 
6599 cd b9 0b				call str_at_display 
659c cd c9 0b				call update_display 
659f			 
659f				; prompt before entering montior for investigating issue 
659f			 
659f 3e 3c			ld a, display_row_4 
65a1 11 ce 1a			ld de, endprog 
65a4			 
65a4 cd c9 0b			call update_display		 
65a7			 
65a7 cd 2c 1d			call next_page_prompt 
65aa			 
65aa e5					push hl 
65ab d5					push de 
65ac cd 22 1b				call monitor 
65af c3 19 1a				jp warmstart 
65b2 76					halt 
65b3			 
65b3			 
65b3 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
65ca			 
65ca d5			type_faults: 	push de 
65cb e5					push hl 
65cc cd a6 0b				call clear_display 
65cf 11 f5 65				   ld de, .typefaults 
65d2 3e 00				ld a, display_row_1 
65d4 cd b9 0b				call str_at_display 
65d7 11 b4 fe				    ld de, debug_mark 
65da 3e 11				ld a, display_row_1+17 
65dc cd b9 0b				call str_at_display 
65df cd c9 0b				call update_display 
65e2			 
65e2				; prompt before entering montior for investigating issue 
65e2			 
65e2 3e 3c			ld a, display_row_4 
65e4 11 ce 1a			ld de, endprog 
65e7			 
65e7 cd c9 0b			call update_display		 
65ea			 
65ea cd 2c 1d			call next_page_prompt 
65ed			 
65ed e1					pop hl 
65ee d1					pop de 
65ef cd 22 1b				call monitor 
65f2 c3 19 1a				jp warmstart 
65f5			 
65f5			 
65f5 .. 00		.typefaults: db "STR Type Expected TOS!",0 
660c			 
660c			.show_fault: 	 
660c d5					push de 
660d cd a6 0b				call clear_display 
6610 d1					pop de 
6611 3e 00				ld a, display_row_1 
6613 cd b9 0b				call str_at_display 
6616 11 b4 fe				    ld de, debug_mark 
6619 3e 11				ld a, display_row_1+17 
661b cd b9 0b				call str_at_display 
661e cd c9 0b				call update_display 
6621			 
6621				; prompt before entering montior for investigating issue 
6621			 
6621 3e 3c			ld a, display_row_4 
6623 11 ce 1a			ld de, endprog 
6626			 
6626 cd c9 0b			call update_display		 
6629			 
6629 cd 2c 1d			call next_page_prompt 
662c			 
662c e1					pop hl 
662d d1					pop de 
662e cd 22 1b				call monitor 
6631			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6631			; TODO Make optional fault restart to cli or warm boot? 
6631					;jp warmstart 
6631 c3 74 1a				jp cli 
6634 76					halt 
6635			 
6635			; handle the auto run of code from files in storage 
6635			 
6635			 
6635			if STORAGE_SE 
6635			 
6635 .. 00		sprompt3: db "Loading from start-up file?:",0 
6652 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6663			 
6663			 
6663			forth_autoload: 
6663			 
6663				; load block 0 of store 1 
6663				 
6663 3e fe			ld a, $fe      ; bit 0 clear 
6665 32 c5 fc			ld (spi_device), a 
6668			 
6668 cd 69 04			call storage_get_block_0 
666b			 
666b 3a 00 fd			ld a, (store_page+STORE_0_AUTOFILE) 
666e			 
666e fe 00			cp 0 
6670 c8				ret z     ; auto start not enabled 
6671			 
6671 cd a6 0b			call clear_display 
6674			 
6674				; set bank 
6674			 
6674 3a 02 fd				ld a, (store_page+STORE_0_BANKRUN) 
6677 32 c5 fc				ld (spi_device), a 
667a			 
667a				; get file id to load from and get the file name to display 
667a			 
667a 3a 03 fd				ld a, (store_page+STORE_0_FILERUN) 
667d			 
667d 2e 00				ld l, 0 
667f 67					ld h, a 
6680 11 df fc				ld de, store_page 
6683			 
6683					if DEBUG_FORTH_WORDS 
6683						DMARK "ASp" 
6683 f5				push af  
6684 3a 98 66			ld a, (.dmark)  
6687 32 b4 fe			ld (debug_mark),a  
668a 3a 99 66			ld a, (.dmark+1)  
668d 32 b5 fe			ld (debug_mark+1),a  
6690 3a 9a 66			ld a, (.dmark+2)  
6693 32 b6 fe			ld (debug_mark+2),a  
6696 18 03			jr .pastdmark  
6698 ..			.dmark: db "ASp"  
669b f1			.pastdmark: pop af  
669c			endm  
# End of macro DMARK
669c						CALLMONITOR 
669c cd 57 17			call break_point_state  
669f				endm  
# End of macro CALLMONITOR
669f					endif 
669f cd 11 09				call storage_read 
66a2			 
66a2					if DEBUG_FORTH_WORDS 
66a2						DMARK "ASr" 
66a2 f5				push af  
66a3 3a b7 66			ld a, (.dmark)  
66a6 32 b4 fe			ld (debug_mark),a  
66a9 3a b8 66			ld a, (.dmark+1)  
66ac 32 b5 fe			ld (debug_mark+1),a  
66af 3a b9 66			ld a, (.dmark+2)  
66b2 32 b6 fe			ld (debug_mark+2),a  
66b5 18 03			jr .pastdmark  
66b7 ..			.dmark: db "ASr"  
66ba f1			.pastdmark: pop af  
66bb			endm  
# End of macro DMARK
66bb						CALLMONITOR 
66bb cd 57 17			call break_point_state  
66be				endm  
# End of macro CALLMONITOR
66be					endif 
66be			 
66be cd 03 0e				call ishlzero 
66c1 c8					ret z             ; file not found 
66c2			 
66c2 3e 1e				ld a, display_row_2 + 10 
66c4 11 e2 fc				ld de, store_page+3 
66c7 cd b9 0b				call str_at_display 
66ca				 
66ca			; 
66ca			 
66ca 3e 05			ld a, display_row_1+5 
66cc 11 35 66			ld de, sprompt3 
66cf cd b9 0b			call str_at_display 
66d2 3e 37			ld a, display_row_3+15 
66d4 11 52 66			ld de, sprompt4 
66d7 cd b9 0b			call str_at_display 
66da			 
66da cd c9 0b			call update_display 
66dd			 
66dd cd 21 69			call cin_wait 
66e0 fe 6e			cp 'n' 
66e2 c8				ret z 
66e3 fe 4e			cp 'N' 
66e5 c8				ret z 
66e6			 
66e6 cd 23 0b			call delay1s 
66e9			 
66e9 3a e1 fc			ld a, (store_page+2) 
66ec 32 d5 fc			ld (store_openmaxext), a    ; save count of ext 
66ef 3e 01			ld a, 1  
66f1 32 d6 fc			ld (store_openext), a    ; save count of ext 
66f4			 
66f4			.autof:  
66f4 6f				ld l , a 
66f5				 
66f5 3a df fc			ld a, (store_page) 
66f8 67				ld h, a	 
66f9 11 df fc			ld de, store_page 
66fc					if DEBUG_FORTH_WORDS 
66fc						DMARK "ASl" 
66fc f5				push af  
66fd 3a 11 67			ld a, (.dmark)  
6700 32 b4 fe			ld (debug_mark),a  
6703 3a 12 67			ld a, (.dmark+1)  
6706 32 b5 fe			ld (debug_mark+1),a  
6709 3a 13 67			ld a, (.dmark+2)  
670c 32 b6 fe			ld (debug_mark+2),a  
670f 18 03			jr .pastdmark  
6711 ..			.dmark: db "ASl"  
6714 f1			.pastdmark: pop af  
6715			endm  
# End of macro DMARK
6715						CALLMONITOR 
6715 cd 57 17			call break_point_state  
6718				endm  
# End of macro CALLMONITOR
6718					endif 
6718 cd 11 09				call storage_read 
671b cd 03 0e			call ishlzero 
671e c8				ret z 
671f			;	jr z, .autoend 
671f			 
671f					if DEBUG_FORTH_WORDS 
671f						DMARK "ASc" 
671f f5				push af  
6720 3a 34 67			ld a, (.dmark)  
6723 32 b4 fe			ld (debug_mark),a  
6726 3a 35 67			ld a, (.dmark+1)  
6729 32 b5 fe			ld (debug_mark+1),a  
672c 3a 36 67			ld a, (.dmark+2)  
672f 32 b6 fe			ld (debug_mark+2),a  
6732 18 03			jr .pastdmark  
6734 ..			.dmark: db "ASc"  
6737 f1			.pastdmark: pop af  
6738			endm  
# End of macro DMARK
6738						CALLMONITOR 
6738 cd 57 17			call break_point_state  
673b				endm  
# End of macro CALLMONITOR
673b					endif 
673b 11 e1 fc			ld de, store_page+2 
673e 3e 3c			ld a, display_row_4 
6740 cd b9 0b			call str_at_display 
6743			 
6743 cd c9 0b			call update_display 
6746 cd 17 0b			call delay250ms 
6749			 
6749			 
6749			 
6749 21 e1 fc			ld hl, store_page+2 
674c cd 6b 21			call forthparse 
674f cd ab 21			call forthexec 
6752 cd c2 20			call forthexec_cleanup 
6755			 
6755				 
6755 3a d6 fc			ld a, (store_openext) 
6758 3c				inc a 
6759 32 d6 fc			ld (store_openext), a    ; save count of ext 
675c			 
675c 18 96			jr .autof 
675e			;.autofdone: 
675e			; 
675e			;		if DEBUG_FORTH_WORDS 
675e			;			DMARK "ASx" 
675e			;			CALLMONITOR 
675e			;		endif 
675e			;;	call clear_display 
675e			;	ret 
675e			 
675e			 
675e			 
675e			endif 
675e			 
675e			 
675e			; eof 
# End of file forth_kernel.asm
675e			;include "nascombasic.asm" 
675e			 
675e			 
675e			; find out where the code ends if loaded into RAM (for SC114) 
675e			;endofcode:  
675e			;	nop 
675e			 
675e			 
675e			; eof 
675e			 
# End of file main.asm
675e			include "firmware_lcd_4x20.asm" 
675e			; **********************************************************************  
675e			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
675e			; **********************************************************************  
675e			;  
675e			; **  Written as a Small Computer Monitor App  
675e			; **  www.scc.me.uk  
675e			;  
675e			; History  
675e			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
675e			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
675e			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
675e			;  
675e			; **********************************************************************  
675e			;  
675e			; This program is an example of one of the methods of interfacing an   
675e			; alphanumeric LCD module.   
675e			;  
675e			; In this example the display is connected to either a Z80 PIO or a   
675e			; simple 8-bit output port.   
675e			;  
675e			; This interfacing method uses 4-bit data mode and uses time delays  
675e			; rather than polling the display's ready status. As a result the   
675e			; interface only requires 6 simple output lines:  
675e			;   Output bit 0 = not used  
675e			;   Output bit 1 = not used  
675e			;   Output bit 2 = RS         High = data, Low = instruction  
675e			;   Output bit 3 = E          Active high  
675e			;   Output bit 4 = DB4  
675e			;   Output bit 5 = DB5  
675e			;   Output bit 6 = DB6  
675e			;   Output bit 7 = DB7  
675e			; Display's R/W is connected to 0v so it is always in write mode  
675e			;  
675e			; This set up should work with any system supporting the RC2014 bus  
675e			  
675e			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
675e			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
675e			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
675e			;  
675e			; **********************************************************************  
675e			  
675e			; **********************************************************************  
675e			; **  Constants  
675e			; **********************************************************************  
675e			; LCD constants required by LCD support module  
675e			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
675e			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
675e			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
675e			kLCDWidth:  EQU display_cols             ;Width in characters  
675e			  
675e			; **********************************************************************  
675e			; **  Code library usage  
675e			; **********************************************************************  
675e			  
675e			; send character to current cursor position  
675e			; wraps and/or scrolls screen automatically  
675e			  
675e			  
675e			lcd_init:  
675e			  
675e			; SCMonAPI functions used  
675e			  
675e			; Alphanumeric LCD functions used  
675e			; no need to specify specific functions for this module  
675e			  
675e 3e cf		            LD   A, 11001111b  
6760 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6762 3e 00		            LD   A, 00000000b  
6764 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6766			  
6766			; Initialise alphanumeric LCD module  
6766 cd df 67		            CALL fLCD_Init      ;Initialise LCD module  
6769			  
6769 c9				ret  
676a			  
676a			;  
676a			;;  
676a			; lcd functions  
676a			;  
676a			;  
676a			  
676a			; what is at cursor position   
676a			  
676a			;get_cursor:	ld de, (cursor_row)   ;  row + col  
676a			;		call curptr  
676a			;		ret  
676a			  
676a			  
676a			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
676a			  
676a			curptr:  
676a c5				push bc  
676b 21 4a fe			ld hl, display_fb0  
676e			cpr:	  
676e				; loop for cursor whole row  
676e 0e 14			ld c, display_cols  
6770 23			cpr1:	inc hl  
6771 0d				dec c  
6772 20 fc			jr nz, cpr1  
6774 05				dec b  
6775 20 f7			jr nz, cpr  
6777			  
6777				; add col	  
6777			  
6777 23			cpr2:	inc hl  
6778 1d				dec e  
6779 20 fc			jr nz, cpr2  
677b			  
677b c1				pop bc  
677c c9				ret  
677d				  
677d			  
677d			  
677d			  
677d			  
677d			; write the frame buffer given in hl to hardware   
677d 22 52 fd		write_display: ld (display_write_tmp), hl 	   
6780 3e 00			ld a, kLCD_Line1  
6782 cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6785 06 14			ld b, display_cols  
6787 ed 5b 52 fd		ld de, (display_write_tmp)  
678b cd d7 67			call write_len_string  
678e				  
678e				  
678e 2a 52 fd			ld hl, (display_write_tmp)  
6791 11 14 00			ld de, display_cols  
6794 19				add hl,de  
6795 22 52 fd			ld (display_write_tmp),hl  
6798			  
6798				  
6798 3e 40			ld a, kLCD_Line2  
679a cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
679d 06 14			ld b, display_cols  
679f ed 5b 52 fd		ld de, (display_write_tmp)  
67a3 cd d7 67			call write_len_string  
67a6				  
67a6 2a 52 fd			ld hl, (display_write_tmp)  
67a9 11 14 00			ld de, display_cols  
67ac 19				add hl,de  
67ad 22 52 fd			ld (display_write_tmp),hl  
67b0			  
67b0				  
67b0 3e 14			ld a, kLCD_Line3  
67b2 cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67b5 06 14			ld b, display_cols  
67b7 ed 5b 52 fd		ld de, (display_write_tmp)  
67bb cd d7 67			call write_len_string  
67be				  
67be 2a 52 fd			ld hl, (display_write_tmp)  
67c1 11 14 00			ld de, display_cols  
67c4 19				add hl,de  
67c5 22 52 fd			ld (display_write_tmp),hl  
67c8			  
67c8				  
67c8 3e 54			ld a, kLCD_Line4  
67ca cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67cd 06 14			ld b, display_cols  
67cf ed 5b 52 fd		ld de, (display_write_tmp)  
67d3 cd d7 67			call write_len_string  
67d6 c9					ret  
67d7				  
67d7				; write out a fixed length string given in b from de  
67d7			  
67d7 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
67d8 cd 29 68		            CALL fLCD_Data      ;Write character to display  
67db 13				inc de  
67dc 10 f9			djnz write_len_string  
67de c9				ret  
67df			  
67df			; Some other things to do  
67df			;            LD   A, kLCD_Clear ;Display clear  
67df			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
67df			;            LD   A, kLCD_Under ;Display on with underscore cursor  
67df			;            LD   A, kLCD_On     ;Display on with no cursor  
67df			;            ;LD   A, kLCD_Off   ;Display off  
67df			;            CALL fLCD_Inst      ;Send instruction to display  
67df			;  
67df			;  
67df			;            halt  
67df			;  
67df			;  
67df			;MsgHello:   DB  "Hello World!",0  
67df			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
67df			  
67df			; Custom characters 5 pixels wide by 8 pixels high  
67df			; Up to 8 custom characters can be defined  
67df			;BitMaps:      
67df			;; Character 0x00 = Battery icon  
67df			;            DB  01110b  
67df			;            DB  11011b  
67df			;            DB  10001b  
67df			;            DB  10001b  
67df			;            DB  11111b  
67df			;            DB  11111b  
67df			;            DB  11111b  
67df			;            DB  11111b  
67df			;; Character 0x01 = Bluetooth icon  
67df			;            DB  01100b  
67df			;            DB  01010b  
67df			;            DB  11100b  
67df			;            DB  01000b  
67df			;            DB  11100b  
67df			;            DB  01010b  
67df			;            DB  01100b  
67df			;            DB  00000b  
67df			;  
67df			  
67df			  
67df			; **********************************************************************  
67df			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
67df			; **********************************************************************  
67df			;  
67df			; **  Written as a Small Computer Monitor App   
67df			; **  Version 0.1 SCC 2018-05-16  
67df			; **  www.scc.me.uk  
67df			;  
67df			; **********************************************************************  
67df			;  
67df			; This module provides support for alphanumeric LCD modules using with  
67df			; *  HD44780 (or compatible) controller  
67df			; *  5 x 7 pixel fonts  
67df			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
67df			; *  Interface via six digital outputs to the display (see below)  
67df			;  
67df			; LCD module pinout:  
67df			;   1  Vss   0v supply  
67df			;   2  Vdd   5v supply  
67df			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
67df			;   4  RS    High = data, Low = instruction  
67df			;   5  R/W   High = Read, Low = Write  
67df			;   6  E     Enable signal (active high)  
67df			;   7  DB0   Data bit 0  
67df			;   8  DB1   Data bit 1  
67df			;   9  DB2   Data bit 2  
67df			;  10  DB3   Data bit 3  
67df			;  11  DB4   Data bit 4  
67df			;  12  DB5   Data bit 5  
67df			;  13  DB6   Data bit 6  
67df			;  14  DB7   Data bit 7  
67df			;  15  A     Backlight anode (+)  
67df			;  16  K     Backlight cathode (-)  
67df			;  
67df			; This interfacing method uses 4-bit data mode and uses time delays  
67df			; rather than polling the display's ready status. As a result the   
67df			; interface only requires 6 simple output lines:  
67df			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
67df			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
67df			;   LCD DB4 = Microcomputer output port bit 4  
67df			;   LCD DB5 = Microcomputer output port bit 5  
67df			;   LCD DB6 = Microcomputer output port bit 6  
67df			;   LCD DB7 = Microcomputer output port bit 7  
67df			; Display's R/W is connected to 0v so it is always in write mode  
67df			; All 6 connections must be on the same port address <kLCDPrt>  
67df			; This method also allows a decent length of cable from micro to LCD  
67df			;  
67df			; **********************************************************************  
67df			;  
67df			; To include the code for any given function provided by this module,   
67df			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
67df			; the parent source file.  
67df			; For example:  #REQUIRES   uHexPrefix  
67df			;  
67df			; Also #INCLUDE this file at some point after the #REQUIRES statements  
67df			; in the parent source file.  
67df			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
67df			;  
67df			; These are the function names provided by this module:  
67df			; fLCD_Init                     ;Initialise LCD  
67df			; fLCD_Inst                     ;Send instruction to LCD  
67df			; fLCD_Data                     ;Send data byte to LCD  
67df			; fLCD_Pos                      ;Position cursor  
67df			; fLCD_Str                      ;Display string  
67df			; fLCD_Def                      ;Define custom character  
67df			;  
67df			; **********************************************************************  
67df			;  
67df			; Requires SCMonAPI.asm to also be included in the project  
67df			;  
67df			  
67df			  
67df			; **********************************************************************  
67df			; **  Constants  
67df			; **********************************************************************  
67df			  
67df			; Constants that must be defined externally  
67df			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
67df			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
67df			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
67df			;kLCDWidth: EQU 20             ;Width in characters  
67df			  
67df			; general line offsets in any frame buffer  
67df			  
67df			  
67df			display_row_1: equ 0  
67df			display_row_2: equ display_row_1+display_cols  
67df			display_row_3: equ display_row_2 + display_cols  
67df			display_row_4: equ display_row_3 + display_cols  
67df			;display_row_4_eol:   
67df			  
67df			  
67df			; Cursor position values for the start of each line  
67df			kLCD_Line1: EQU 0x00   
67df			kLCD_Line2: EQU 0x40    
67df			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
67df			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
67df			  
67df			; Instructions to send as A register to fLCD_Inst  
67df			kLCD_Clear: EQU 00000001b     ;LCD clear  
67df			kLCD_Off:   EQU 00001000b     ;LCD off  
67df			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
67df			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
67df			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
67df			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
67df			  
67df			; Constants used by this code module  
67df			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
67df			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
67df			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
67df			  
67df			  
67df			  
67df			; **********************************************************************  
67df			; **  LCD support functions  
67df			; **********************************************************************  
67df			  
67df			; Initialise alphanumeric LCD module  
67df			; LCD control register codes:  
67df			;   DL   0 = 4-bit mode        1 = 8-bit mode  
67df			;   N    0 = 1-line mode       1 = 2-line mode  
67df			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
67df			;   D    0 = Display off       1 = Display on  
67df			;   C    0 = Cursor off        1 = Cursor on  
67df			;   B    0 = Blinking off      1 = Blinking on  
67df			;   ID   0 = Decrement mode    1 = Increment mode  
67df			;   SH   0 = Entire shift off  1 = Entire shift on  
67df 3e 28		fLCD_Init:  LD   A, 40  
67e1 cd 96 68		            CALL LCDDelay       ;Delay 40ms after power up  
67e4			; For reliable reset set 8-bit mode - 3 times  
67e4 cd 80 68		            CALL WrFn8bit       ;Function = 8-bit mode  
67e7 cd 80 68		            CALL WrFn8bit       ;Function = 8-bit mode  
67ea cd 80 68		            CALL WrFn8bit       ;Function = 8-bit mode  
67ed			; Set 4-bit mode  
67ed cd 7c 68		            CALL WrFn4bit       ;Function = 4-bit mode  
67f0 cd 94 68		            CALL LCDDelay1      ;Delay 37 us or more  
67f3			; Function set  
67f3 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
67f5 cd 08 68		            CALL fLCD_Inst      ;2 line, display on  
67f8			; Display On/Off control  
67f8 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
67fa cd 08 68		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
67fd			; Display Clear  
67fd 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
67ff cd 08 68		            CALL fLCD_Inst      ;Clear display  
6802			; Entry mode  
6802 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6804 cd 08 68		            CALL fLCD_Inst      ;Increment mode, shift off  
6807			; Display module now initialised  
6807 c9			            RET  
6808			; ok to here  
6808			  
6808			; Write instruction to LCD  
6808			;   On entry: A = Instruction byte to be written  
6808			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6808 f5			fLCD_Inst:  PUSH AF  
6809 f5			            PUSH AF  
680a cd 1c 68		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
680d f1			            POP  AF  
680e 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
680f 17			            RLA  
6810 17			            RLA  
6811 17			            RLA  
6812 cd 1c 68		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6815 3e 02		            LD   A, 2  
6817 cd 96 68		            CALL LCDDelay       ;Delay 2 ms to complete   
681a f1			            POP  AF  
681b c9			            RET  
681c e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
681e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6820 cb df		            SET  kLCDBitE, A  
6822 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6824 cb 9f		            RES  kLCDBitE, A  
6826 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6828 c9			            RET  
6829			  
6829			  
6829			; Write data to LCD  
6829			;   On entry: A = Data byte to be written  
6829			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6829 f5			fLCD_Data:  PUSH AF  
682a f5			            PUSH AF  
682b cd 3d 68		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
682e f1			            POP  AF  
682f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6830 17			            RLA  
6831 17			            RLA  
6832 17			            RLA  
6833 cd 3d 68		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6836 3e 96		            LD   A, 150  
6838 3d			Wait:      DEC  A              ;Wait a while to allow data   
6839 20 fd		            JR   NZ, Wait      ;  write to complete  
683b f1			            POP  AF  
683c c9			            RET  
683d e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
683f cb d7		            SET  kLCDBitRS, A  
6841 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6843 cb df		            SET  kLCDBitE, A  
6845 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6847 cb 9f		            RES  kLCDBitE, A  
6849 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
684b cb 97		            RES  kLCDBitRS, A  
684d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
684f c9			            RET  
6850			  
6850			  
6850			; Position cursor to specified location  
6850			;   On entry: A = Cursor position  
6850			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6850 f5			fLCD_Pos:   PUSH AF  
6851 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6853 cd 08 68		            CALL fLCD_Inst      ;Write instruction to LCD  
6856 f1			            POP  AF  
6857 c9			            RET  
6858			  
6858			  
6858			; Output text string to LCD  
6858			;   On entry: DE = Pointer to null terminated text string  
6858			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6858 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6859 b7			            OR   A              ;Null terminator?  
685a c8			            RET  Z              ;Yes, so finished  
685b cd 29 68		            CALL fLCD_Data      ;Write character to display  
685e 13			            INC  DE             ;Point to next character  
685f 18 f7		            JR   fLCD_Str       ;Repeat  
6861 c9					ret  
6862			  
6862			; Define custom character  
6862			;   On entry: A = Character number (0 to 7)  
6862			;             DE = Pointer to character bitmap data  
6862			;   On exit:  A = Next character number  
6862			;             DE = Next location following bitmap  
6862			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6862			; Character is   
6862 c5			fLCD_Def:   PUSH BC  
6863 f5			            PUSH AF  
6864 07			            RLCA                ;Calculate location  
6865 07			            RLCA                ;  for bitmap data  
6866 07			            RLCA                ;  = 8 x CharacterNumber  
6867 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6869 cd 08 68		            CALL fLCD_Inst      ;Write instruction to LCD  
686c 06 00		            LD   B, 0  
686e 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
686f cd 29 68		            CALL fLCD_Data      ;Write byte to display  
6872 13			            INC  DE             ;Point to next byte  
6873 04			            INC  B              ;Count bytes  
6874 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6876 28 f6		            JR   Z, Loop       ;No, so repeat  
6878 f1			            POP  AF  
6879 3c			            INC  A              ;Increment character number  
687a c1			            POP  BC  
687b c9			            RET  
687c			  
687c			  
687c			; **********************************************************************  
687c			; **  Private functions  
687c			; **********************************************************************  
687c			  
687c			; Write function to LCD  
687c			;   On entry: A = Function byte to be written  
687c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
687c 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
687e 18 02		            JR   WrFunc  
6880 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6882 f5			WrFunc:     PUSH AF  
6883 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6885 cb df		            SET  kLCDBitE, A  
6887 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6889 cb 9f		            RES  kLCDBitE, A  
688b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
688d 3e 05		            LD   A, 5  
688f cd 96 68		            CALL LCDDelay       ;Delay 5 ms to complete  
6892 f1			            POP  AF  
6893 c9			            RET  
6894			  
6894			  
6894			; Delay in milliseconds  
6894			;   On entry: A = Number of milliseconds delay  
6894			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6894 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6896 d5			LCDDelay:   PUSH DE  
6897 5f			            LD   E, A           ;Delay by 'A' ms  
6898 16 00		            LD   D, 0  
689a cd 08 0b		            CALL aDelayInMS  
689d d1			            POP  DE  
689e c9			            RET  
689f			  
689f			  
689f			  
689f			  
689f			; eof  
689f			  
# End of file firmware_lcd_4x20.asm
689f			include "firmware_key_4x4.asm" 
689f			  
689f			  
689f			; bit mask for each scan column and row for teing the matrix  
689f			  
689f			; out   
689f 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
68a3			; in  
68a3 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
68a7			  
68a7			; row/col to character map  
68a7			  
68a7			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
68a7			;    
68a7			  
68a7			; physical key matrix map to face of key  
68a7			  
68a7			  
68a7			;      	1	2	3	A  
68a7			;   	abc”	def&	ghi$	s1  
68a7			;			  
68a7			;	4	5	6	B  
68a7			; 	jkl,	mno.	pqr:	s2  
68a7			;			  
68a7			; 	7	8	9	C  
68a7			;	stu;	vwx@	yz?!	s3  
68a7			;			  
68a7			; 	*	0	#	D  
68a7			; 	shift lck '	Space < >	Enter ( )	s4  
68a7			;       tab bs 		  
68a7			  
68a7			  
68a7			  
68a7			  
68a7			key_init:  
68a7			  
68a7			; SCMonAPI functions used  
68a7			  
68a7			; Alphanumeric LCD functions used  
68a7			; no need to specify specific functions for this module  
68a7			  
68a7			  
68a7 3e cf		            LD   A, 11001111b  
68a9 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
68ab			;            LD   A, 00000000b  
68ab 3e 0f		            LD   A, 00001111b  
68ad d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
68af			  
68af			  
68af				; TODO Configure cursor shapes  
68af			  
68af				; Load cursor shapes   
68af 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
68b1 11 c1 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
68b4 06 02		            LD   B, 2           ;Number of characters to define  
68b6 cd 62 68		.DefLoop:   CALL fLCD_Def       ;Define custom character  
68b9 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
68bb			  
68bb 3e 01				ld a, 1  
68bd 32 4d fd			ld (cursor_shape),a  
68c0 c9				ret  
68c1			  
68c1			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
68c1			; Up to 8 custom characters can be defined  
68c1			.cursor_shapes:      
68c1			;; Character 0x00 = Normal  
68c1 1f			            DB  11111b  
68c2 1f			            DB  11111b  
68c3 1f			            DB  11111b  
68c4 1f			            DB  11111b  
68c5 1f			            DB  11111b  
68c6 1f			            DB  11111b  
68c7 1f			            DB  11111b  
68c8 1f			            DB  11111b  
68c9			;; Character 0x01 = Modifier  
68c9 1f			            DB  11111b  
68ca 1b			            DB  11011b  
68cb 1b			            DB  11011b  
68cc 1b			            DB  11011b  
68cd 1b			            DB  11011b  
68ce 1f			            DB  11111b  
68cf 1b			            DB  11011b  
68d0 1f			            DB  11111b  
68d1			  
68d1			  
68d1			  
68d1			  
68d1			; Display custom character 0  
68d1			;            LD   A, kLCD_Line1+14  
68d1			;            CALL fLCD_Pos       ;Position cursor to location in A  
68d1			;            LD   A, 0  
68d1			;            CALL fLCD_Data      ;Write character in A at cursor  
68d1			  
68d1			; Display custom character 1  
68d1			;            LD   A, kLCD_Line2+14  
68d1			;            CALL fLCD_Pos      ;Position cursor to location in A  
68d1			;            LD   A, 1  
68d1			;            CALL fLCD_Data     ;Write character in A at cursor  
68d1			  
68d1			; keyboard scanning   
68d1			  
68d1			  
68d1			; key_rows: equ 4  
68d1			; key_cols: equ 4  
68d1			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
68d1			  
68d1			; key_scanr: equ key_row_bitmask  
68d1			; key_scanc: equ key_col_bitmask  
68d1			  
68d1			; key_char_map: equ key_map  
68d1			  
68d1			  
68d1			  
68d1			; character in from keyboard  
68d1			  
68d1 ..			.matrix_to_char: db "D#0*C987B654A321"  
68e1			  
68e1			  
68e1			; map the physical key to a char dependant on state  
68e1			  
68e1			.key_map_fa:   
68e1			  
68e1 ..					db 'D'  
68e2 0d					db KEY_CR    ; cr  
68e3 ..					db ' '  
68e4 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
68e5 ..					db 'C'  
68e6 ..					db 'y'  
68e7 ..					db 'v'  
68e8 ..					db 's'  
68e9 ..					db 'B'  
68ea ..					db 'p'  
68eb ..					db 'm'  
68ec ..					db 'j'  
68ed ..					db 'A'  
68ee ..					db 'g'  
68ef ..					db 'd'  
68f0 ..					db 'a'  
68f1			  
68f1			.key_map_fb:  
68f1			  
68f1 ..					db 'A'  
68f2 ..					db '+'   
68f3 ..					db '<'  
68f4 ..					db  "'"    
68f5			  
68f5 ..					db 'A'  
68f6 ..					db 'z'  
68f7 ..					db 'w'  
68f8 ..					db 't'  
68f9 ..					db 'A'  
68fa ..					db 'q'  
68fb ..					db 'n'  
68fc ..					db 'k'  
68fd ..					db 'A'  
68fe ..					db 'h'  
68ff ..					db 'e'  
6900 ..			 		db 'b'  
6901			  
6901			.key_map_fc:   
6901			  
6901			  
6901 ..					db 'A'  
6902 ..					db '-'   
6903 ..					db '>'  
6904 ..					db  '='   	  
6905 ..					db 'A'  
6906 ..					db '?'  
6907 ..					db 'x'  
6908 ..					db 'u'  
6909 ..					db 'A'  
690a ..					db 'r'  
690b ..					db 'o'  
690c ..					db 'l'  
690d ..					db 'A'  
690e ..					db 'i'  
690f ..					db 'f'  
6910 ..					db 'c'  
6911			  
6911				  
6911			.key_map_fd:  
6911			  
6911 ..					db 'A'  
6912 ..					db '/'   
6913 ..					db '%'   
6914 08					db KEY_BS  ; back space  
6915 ..					db 'A'  
6916 ..					db '!'  
6917 ..					db '@'  
6918 ..					db ';'  
6919 ..					db 'A'  
691a ..					db ':'  
691b ..					db '.'  
691c ..					db ','  
691d ..					db 'A'  
691e ..					db '$'  
691f ..					db '&'  
6920 ..				 	db '"'  
6921			  
6921					  
6921				  
6921			  
6921			; add cin and cin_wait  
6921			  
6921 cd 32 69		cin_wait: 	call cin  
6924 fe 00			cp 0  
6926 28 f9			jr z, cin_wait   ; block until key press  
6928			  
6928 f5				push af   ; save key pressed  
6929			  
6929 cd 32 69		.cin_wait1:	call cin  
692c fe 00			cp 0  
692e 20 f9			jr nz, .cin_wait1  	; wait for key release  
6930			  
6930 f1				pop af   ; get key  
6931 c9				ret  
6932			  
6932			  
6932 cd 43 69		cin: 	call .mtoc  
6935			  
6935				; no key held  
6935 fe 00			cp 0  
6937 c8				ret z  
6938			  
6938				; stop key bounce  
6938			  
6938			;	ld (key_held),a		 ; save it  
6938 47				ld b, a  
6939			  
6939 c5			.cina1:	push bc  
693a cd 43 69			call .mtoc  
693d c1				pop bc  
693e b8				cp b  
693f 28 f8			jr z, .cina1  
6941 78				ld a,b		  
6942 c9				ret  
6943			  
6943			; detect keyboard modifier key press and apply new overlay to the face key held  
6943			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6943			  
6943			;.cin_map_modifier:   
6943			;	ld a, (hl)  
6943			;	and 255  
6943			;	ret NZ		; modifier key not flagged  
6943			;  
6943			;	; get key face  
6943			;  
6943			;	ld b,(key_face_held)  
6943			;  
6943			;	ld b, key_cols * key_rows  
6943			;  
6943			;	push de  
6943			;	pop hl  
6943			;  
6943			;.mmod1: ld a,(hl)   ; get map test  
6943			;	cp b  
6943			;	jr z, .mmod2  
6943			;  
6943			;  
6943			;  
6943			;.mmod2: inc hl    ;   
6943			;  
6943			;	  
6943			;  
6943			;	  
6943			;  
6943			;	ld hl,key_actual_pressed  
6943			;	ld (hl),a,  
6943			;	ret  
6943			  
6943				  
6943			  
6943			; map matrix key held to char on face of key  
6943			  
6943			.mtoc:  
6943			  
6943			  
6943				; TODO optimise the code....  
6943			  
6943			; scan keyboard row 1  
6943 3e 80			ld a, 128  
6945 21 d3 fe			ld hl, keyscan_table  
6948 cd 2a 6a			call .rowscan  
694b			  
694b				   
694b			  
694b 3e 40			ld a, 64  
694d 21 d7 fe			ld hl, keyscan_table+key_cols  
6950 cd 2a 6a			call .rowscan  
6953			  
6953			  
6953			  
6953			  
6953 3e 20			ld a, 32  
6955 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6958 cd 2a 6a			call .rowscan  
695b			  
695b			  
695b			  
695b 3e 10			ld a, 16  
695d 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6960 cd 2a 6a			call .rowscan  
6963			  
6963			  
6963				; flag if key D is held down and remove from reporting  
6963 01 11 69			ld bc, .key_map_fd    
6966 21 d3 fe			ld hl, keyscan_table  
6969 11 c5 fe			ld de, key_fd  
696c cd bc 69			call .key_shift_hold  
696f fe ff			cp 255  
6971 28 33			jr z, .cinmap  
6973				; flag if key C is held down and remove from reporting  
6973 01 01 69			ld bc, .key_map_fc    
6976 21 d7 fe			ld hl, keyscan_table+key_cols  
6979 11 c6 fe			ld de, key_fc  
697c cd bc 69			call .key_shift_hold  
697f fe ff			cp 255  
6981 28 23			jr z, .cinmap  
6983				; flag if key B is held down and remove from reporting  
6983 01 f1 68			ld bc, .key_map_fb    
6986 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6989 11 c7 fe			ld de, key_fb  
698c cd bc 69			call .key_shift_hold  
698f fe ff			cp 255  
6991 28 13			jr z, .cinmap  
6993				; flag if key A is held down and remove from reporting  
6993 01 e1 68			ld bc, .key_map_fa    
6996 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6999 11 c8 fe			ld de, key_fa  
699c cd bc 69			call .key_shift_hold  
699f fe ff			cp 255  
69a1 28 03			jr z, .cinmap  
69a3			  
69a3 11 d1 68			ld de, .matrix_to_char  
69a6			  
69a6			  
69a6			.cinmap:   
69a6				if DEBUG_KEY  
69a6			            LD   A, kLCD_Line4  
69a6			            CALL fLCD_Pos       ;Position cursor to location in A  
69a6					push de  
69a6			            LD   DE, keyscan_table  
69a6			            CALL fLCD_Str       ;Display string pointed to by DE  
69a6					pop de  
69a6				endif  
69a6			  
69a6				; scan key matrix table for any held key  
69a6			  
69a6				; de holds either the default matrix or one selected above  
69a6			  
69a6 21 d3 fe			ld hl, keyscan_table  
69a9 06 10			ld b,key_cols*key_rows  
69ab			  
69ab 7e			.cin1:	ld a,(hl)  
69ac fe 23			cp '#'  
69ae 28 08			jr z, .cinhit  
69b0 23				inc hl  
69b1 13				inc de  
69b2 05				dec b  
69b3 20 f6			jr nz, .cin1  
69b5				; no key found held  
69b5 3e 00			ld a,0  
69b7 c9				ret  
69b8 d5			.cinhit: push de  
69b9 e1				pop hl  
69ba 7e				ld a,(hl)  
69bb c9				ret  
69bc			  
69bc			; flag a control key is held   
69bc			; hl is key pin, de is flag indicator  
69bc			  
69bc			.key_shift_hold:  
69bc c5				push bc  
69bd 3e 01			ld a, 1  
69bf 32 4d fd			ld (cursor_shape),a  
69c2 06 00			ld b, 0  
69c4 7e				ld a, (hl)  
69c5 fe 2e			cp '.'  
69c7 28 0a			jr z, .key_shift1  
69c9 06 ff			ld b, 255  
69cb 3e 2b			ld a, '+'    ; hide key from later scans  
69cd 77				ld (hl),a  
69ce 3e 02			ld a, 2  
69d0 32 4d fd			ld (cursor_shape),a  
69d3			.key_shift1:  
69d3				; write flag indicator  
69d3 78				ld a,b  
69d4 12				ld (de),a  
69d5			  
69d5 d1				pop de    ; de now holds the key map ptr  
69d6 c9				ret  
69d7			  
69d7				  
69d7				  
69d7			  
69d7			  
69d7			  
69d7			  
69d7			  
69d7			  
69d7			  
69d7			  
69d7			  
69d7			  
69d7 c9				ret  
69d8			  
69d8			;	push hl  
69d8			;	push de  
69d8			;	push bc  
69d8			;	call keyscan  
69d8			;	; map key matrix to ascii value of key face  
69d8			;  
69d8			;	ld hl, key_face_map  
69d8			;	ld de, keyscan_table  
69d8			;  
69d8			;	; get how many keys to look at  
69d8			;	ld b, keyscan_table_len  
69d8			;	  
69d8			;  
69d8			;	; at this stage fall out on first key hit  
69d8			;	; TODO handle multiple key press  
69d8			;  
69d8			;map1:	ld a,(hl)  
69d8			;	cp '#'  
69d8			;	jr z, keyhit  
69d8			;	inc hl  
69d8			;	inc de  
69d8			;	dec b  
69d8			;	jr nz, map1  
69d8			;nohit:	ld a, 0  
69d8			;	jr keydone  
69d8			;keyhit: push de  
69d8			;	pop hl  
69d8			;	ld a,(hl)  
69d8			;keydone:  
69d8			;	push bc  
69d8			;	push de  
69d8			; 	push hl  
69d8			;	ret   
69d8			;  
69d8			  
69d8			  
69d8			  
69d8			  
69d8			; scan physical key matrix  
69d8			  
69d8			  
69d8			;keyscan:  
69d8			;  
69d8			;; for each key_row use keyscanr bit mask for out  
69d8			;; then read in for keyscanc bitmask  
69d8			;; save result of row scan to keyscantable  
69d8			;  
69d8			;; scan keyboard row 1  
69d8			;  
69d8			;	ld b, key_rows  
69d8			;	ld hl, key_scanr  
69d8			;	ld de, keyscan_table  
69d8			;  
69d8			;rowloop:  
69d8			;  
69d8			;	ld a,(hl)		; out bit mask to energise keyboard row  
69d8			;	call rowscan  
69d8			;	inc hl  
69d8			;	dec b  
69d8			;	jr nz, rowloop  
69d8			;  
69d8			;	ret  
69d8			;  
69d8			;  
69d8			;; pass a out bitmask, b row number  
69d8			;arowscan:   
69d8			;	push bc  
69d8			;  
69d8			;	ld d, b  
69d8			;  
69d8			;	; calculate buffer location for this row  
69d8			;  
69d8			;	ld hl, keyscan_table	  
69d8			;kbufr:  ld e, key_cols  
69d8			;kbufc:	inc hl  
69d8			;	dec e  
69d8			;	jr nz, kbufc  
69d8			;	dec d  
69d8			;	jr nz, kbufr  
69d8			;  
69d8			;	; energise row and read columns  
69d8			;  
69d8			;	out (portbdata),a  
69d8			;	in a,(portbdata)  
69d8			;	ld c,a  
69d8			;  
69d8			;  
69d8			;	; save buffer loc  
69d8			;  
69d8			;	ld (keybufptr), hl  
69d8			;  
69d8			;	ld hl, key_scanc  
69d8			;	ld d, key_cols  
69d8			;  
69d8			;	; for each column check each bit mask  
69d8			;  
69d8			;colloop:  
69d8			;	  
69d8			;  
69d8			;	; reset flags for the row   
69d8			;  
69d8			;	ld b,'.'  
69d8			;	and (hl)  
69d8			;	jr z, maskskip  
69d8			;	ld b,'#'  
69d8			;maskskip:  
69d8			;	; save  key state  
69d8			;	push hl  
69d8			;	ld hl, (keybufptr)  
69d8			;	ld (hl), b  
69d8			;	inc hl  
69d8			;	ld (keybufptr), hl  
69d8			;  
69d8			;	; move to next bit mask  
69d8			;	pop hl  
69d8			;	inc hl  
69d8			;  
69d8			;	dec d  
69d8			;	jr nz, colloop  
69d8			;  
69d8			;	ret  
69d8			;  
69d8			;  
69d8			;;  
69d8			; lcd functions  
69d8			;  
69d8			;  
69d8			  
69d8			;if DEBUG_KEY_MATRIX  
69d8			  
69d8			; test function to display hardware view of matrix state  
69d8			  
69d8			matrix:  
69d8			  
69d8			  
69d8			  
69d8			; scan keyboard row 1  
69d8 3e 80			ld a, 128  
69da 21 f8 fe			ld hl, keyscan_table_row1  
69dd cd 2a 6a			call .rowscan  
69e0			  
69e0 3e 40			ld a, 64  
69e2 21 f3 fe			ld hl, keyscan_table_row2  
69e5 cd 2a 6a			call .rowscan  
69e8			  
69e8 3e 20			ld a, 32  
69ea 21 ee fe			ld hl, keyscan_table_row3  
69ed cd 2a 6a			call .rowscan  
69f0			  
69f0 3e 10			ld a, 16  
69f2 21 e9 fe			ld hl, keyscan_table_row4  
69f5 cd 2a 6a			call .rowscan  
69f8			  
69f8			; Display text on first line  
69f8 3e 00		            LD   A, kLCD_Line1  
69fa cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
69fd 11 f8 fe		            LD   DE, keyscan_table_row1  
6a00			            ;LD   DE, MsgHello  
6a00 cd 58 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a03			  
6a03			; Display text on second line  
6a03 3e 40		            LD   A, kLCD_Line2  
6a05 cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6a08 11 f3 fe		            LD   DE, keyscan_table_row2  
6a0b cd 58 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a0e 3e 14		            LD   A, kLCD_Line3  
6a10 cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6a13 11 ee fe		            LD   DE, keyscan_table_row3  
6a16 cd 58 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a19 3e 54		            LD   A, kLCD_Line4  
6a1b cd 50 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6a1e 11 e9 fe		            LD   DE, keyscan_table_row4  
6a21 cd 58 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a24			  
6a24 cd 17 0b			call delay250ms  
6a27 c3 d8 69			jp matrix  
6a2a			  
6a2a			; pass de as row display flags  
6a2a			.rowscan:   
6a2a d3 c1			out (portbdata),a  
6a2c db c1			in a,(portbdata)  
6a2e 4f				ld c,a  
6a2f				; reset flags for the row   
6a2f 06 2e			ld b,'.'  
6a31 e6 01			and 1  
6a33 28 02			jr z, .p1on  
6a35 06 23			ld b,'#'  
6a37			.p1on:  
6a37 70				ld (hl), b  
6a38 23				inc hl  
6a39			  
6a39 06 2e			ld b,'.'  
6a3b 79				ld a,c  
6a3c e6 02			and 2  
6a3e			;	bit 0,a  
6a3e 28 02			jr z, .p2on  
6a40 06 23			ld b,'#'  
6a42			.p2on:  
6a42 70				ld (hl), b  
6a43 23				inc hl  
6a44			;  
6a44 06 2e			ld b,'.'  
6a46 79				ld a,c  
6a47 e6 04			and 4  
6a49			;;	bit 0,a  
6a49 28 02			jr z, .p3on  
6a4b 06 23			ld b,'#'  
6a4d			.p3on:  
6a4d 70				ld (hl), b  
6a4e 23				inc hl  
6a4f			;;  
6a4f 06 2e			ld b,'.'  
6a51			;;	bit 0,a  
6a51 79				ld a,c  
6a52 e6 08			and 8  
6a54 28 02			jr z, .p4on  
6a56 06 23			ld b,'#'  
6a58			.p4on:  
6a58 70				ld (hl), b  
6a59 23				inc hl  
6a5a			  
6a5a			; zero term  
6a5a 06 00			ld b,0  
6a5c 70				ld (hl), b  
6a5d			  
6a5d c9			.rscandone: ret  
6a5e			  
6a5e			  
6a5e			  
6a5e			;endif  
6a5e			  
6a5e			  
6a5e			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6a5e
