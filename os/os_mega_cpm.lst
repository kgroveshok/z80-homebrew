# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5c 14			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 0   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ os_input  
0103			os_new_parse_len: equ os_new_malloc + 2  
0103			os_new_word_len: equ os_new_parse_len + 2  
0103			os_new_work_ptr: equ os_new_word_len + 2  
0103			os_new_src_ptr: equ os_new_work_ptr + 2  
0103			os_new_exec: equ os_new_src_ptr + 2  
0103			os_new_exec_ptr: equ os_new_exec + 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ scratch - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 69 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 69 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 69 09				call clear_display  
0123			  
0123			  
0123 cd 07 55				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd f5 55			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 65 0f				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd 8c 09			call update_display  
0132 cd e2 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 6e 09			call fill_display  
013a cd 8c 09			call update_display  
013d cd e2 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 6e 09			call fill_display  
0145 cd 8c 09			call update_display  
0148 cd e2 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 6e 09			call fill_display  
0150 cd 8c 09			call update_display  
0153 cd e2 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 7c 09			call str_at_display  
015e cd 8c 09			call update_display  
0161			  
0161			  
0161 cd e2 08			call delay1s  
0164 cd e2 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 7c 09			call str_at_display  
016f cd 8c 09			call update_display  
0172 cd e2 08			call delay1s  
0175 cd e2 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 86 12			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 86 12			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd c7 04			call storage_findnextid 
0205			 
0205 cd eb 0a			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 86 12			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 86 12			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 86 12			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 86 12			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 86 12			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 21 65 eb			ld hl, store_page 
02d3 3e 00			ld a, 0 
02d5				 
02d5 77				ld (hl),a   ; reset file counter 
02d6			 
02d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02d9 22 66 eb		 	ld (store_page+1), hl	 
02dc			 
02dc				; set default label 
02dc			 
02dc 21 71 03			ld hl, .defaultbanklabl 
02df 11 68 eb		 	ld de, store_page+3 
02e2 01 0f 00			ld bc, 15 
02e5 ed b0			ldir 
02e7			 
02e7				; save default page 0 
02e7			 
02e7 21 00 00			ld hl, 0 
02ea 11 65 eb			ld de, store_page 
02ed				if DEBUG_STORESE 
02ed					DMARK "SB3" 
02ed f5				push af  
02ee 3a 02 03			ld a, (.dmark)  
02f1 32 7a ee			ld (debug_mark),a  
02f4 3a 03 03			ld a, (.dmark+1)  
02f7 32 7b ee			ld (debug_mark+1),a  
02fa 3a 04 03			ld a, (.dmark+2)  
02fd 32 7c ee			ld (debug_mark+2),a  
0300 18 03			jr .pastdmark  
0302 ..			.dmark: db "SB3"  
0305 f1			.pastdmark: pop af  
0306			endm  
# End of macro DMARK
0306			;		push af 
0306			;		ld a, 'F' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306					CALLMONITOR 
0306 cd 86 12			call break_point_state  
0309				endm  
# End of macro CALLMONITOR
0309				endif 
0309 cd 16 02			call storage_write_block 
030c				if DEBUG_STORESE 
030c					DMARK "SB4" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 7a ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 7b ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 7c ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SB4"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			;		push af 
0325			;		ld a, '>' 
0325			;		ld (debug_mark),a 
0325			;		pop af 
0325					CALLMONITOR 
0325 cd 86 12			call break_point_state  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328			 
0328 00				nop 
0329 00				nop 
032a 00				nop 
032b			 
032b				; now set 0 in every page to mark as a free block 
032b			 
032b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
032d 21 40 00			ld hl, STORE_BLOCK_PHY 
0330			 
0330 3e 00		.setmark1:   	ld a,0 
0332 e5					push hl 
0333 c5					push bc 
0334 cd af 01				call se_writebyte 
0337 3e 0a			ld a, 10 
0339 cd c7 08			call aDelayInMS 
033c 23				inc hl 
033d cd af 01				call se_writebyte 
0340 3e 0a			ld a, 10 
0342 cd c7 08			call aDelayInMS 
0345 2b				dec hl 
0346 c1					pop bc 
0347 e1					pop hl 
0348 3e 40				ld a, STORE_BLOCK_PHY 
034a cd c2 0a				call addatohl 
034d 10 e1				djnz .setmark1 
034f			 
034f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0351 3e 00		.setmark2:   	ld a,0 
0353 e5					push hl 
0354 c5					push bc 
0355 cd af 01				call se_writebyte 
0358 3e 0a			ld a, 10 
035a cd c7 08			call aDelayInMS 
035d 23				inc hl 
035e cd af 01				call se_writebyte 
0361 3e 0a			ld a, 10 
0363 cd c7 08			call aDelayInMS 
0366 2b				dec hl 
0367 c1					pop bc 
0368 e1					pop hl 
0369 3e 40				ld a, STORE_BLOCK_PHY 
036b cd c2 0a				call addatohl 
036e 10 e1				djnz .setmark2 
0370			 
0370					 
0370			 
0370			 
0370 c9				ret 
0371			 
0371			 
0371			 
0371			 
0371 .. 00		.defaultbanklabl:   db "BankLabel",0 
037b			 
037b			 
037b			 
037b			; Label Bank 
037b			; ---------- 
037b			; 
037b			; With current bank 
037b			; Read block 0 
037b			; Set label 
037b			; Write block 0 
037b			 
037b			; label str pointer in hl 
037b			 
037b			storage_label:     
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "LBL" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 7a ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 7b ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 7c ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "LBL"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					CALLMONITOR 
0394 cd 86 12			call break_point_state  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 e5				push hl 
0398			 
0398 cd 62 02			call storage_get_block_0 
039b			 
039b				; set default label 
039b			 
039b e1				pop hl 
039c			 
039c 11 68 eb		 	ld de, store_page+3 
039f 01 0f 00			ld bc, 15 
03a2				if DEBUG_STORESE 
03a2					DMARK "LB3" 
03a2 f5				push af  
03a3 3a b7 03			ld a, (.dmark)  
03a6 32 7a ee			ld (debug_mark),a  
03a9 3a b8 03			ld a, (.dmark+1)  
03ac 32 7b ee			ld (debug_mark+1),a  
03af 3a b9 03			ld a, (.dmark+2)  
03b2 32 7c ee			ld (debug_mark+2),a  
03b5 18 03			jr .pastdmark  
03b7 ..			.dmark: db "LB3"  
03ba f1			.pastdmark: pop af  
03bb			endm  
# End of macro DMARK
03bb					CALLMONITOR 
03bb cd 86 12			call break_point_state  
03be				endm  
# End of macro CALLMONITOR
03be				endif 
03be ed b0			ldir 
03c0				; save default page 0 
03c0			 
03c0 21 00 00			ld hl, 0 
03c3 11 65 eb			ld de, store_page 
03c6				if DEBUG_STORESE 
03c6					DMARK "LBW" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 7a ee			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 7b ee			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 7c ee			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "LBW"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df					CALLMONITOR 
03df cd 86 12			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2 cd 16 02			call storage_write_block 
03e5			 
03e5 c9				ret 
03e6			 
03e6			 
03e6			 
03e6			; Read Block 0 - Config 
03e6			; --------------------- 
03e6			; 
03e6			; With current bank 
03e6			; Call presence test 
03e6			;    If not present format/init bank  
03e6			; Read block 0  
03e6			;  
03e6			 
03e6			 
03e6			; Dir 
03e6			; --- 
03e6			; 
03e6			; With current bank 
03e6			; Load Block 0 Config 
03e6			; Get max file id number 
03e6			; For each logical block 
03e6			;    Read block read byte 2 
03e6			;      if first block of file 
03e6			;         Display file name 
03e6			;         Display type flags for file 
03e6			;        
03e6			 
03e6			; moving to words as this requires stack control 
03e6			 
03e6			 
03e6			; Delete File 
03e6			; ----------- 
03e6			; 
03e6			; With current bank 
03e6			; 
03e6			; Load Block 0 Config 
03e6			; Get max file id number 
03e6			; For each logical block 
03e6			;    Read block file id 
03e6			;      If first block of file and dont have file id 
03e6			;         if file to delete 
03e6			;         Save file id 
03e6			;         Null file id 
03e6			;         Write this block back 
03e6			;      If file id is one saved 
03e6			;         Null file id 
03e6			;         Write this block back 
03e6			 
03e6			storage_erase: 
03e6			 
03e6				; hl contains the file id 
03e6			 
03e6 5d				ld e, l 
03e7 16 00			ld d, 0 
03e9 21 40 00			ld hl, STORE_BLOCK_PHY 
03ec					if DEBUG_FORTH_WORDS 
03ec						DMARK "ERA" 
03ec f5				push af  
03ed 3a 01 04			ld a, (.dmark)  
03f0 32 7a ee			ld (debug_mark),a  
03f3 3a 02 04			ld a, (.dmark+1)  
03f6 32 7b ee			ld (debug_mark+1),a  
03f9 3a 03 04			ld a, (.dmark+2)  
03fc 32 7c ee			ld (debug_mark+2),a  
03ff 18 03			jr .pastdmark  
0401 ..			.dmark: db "ERA"  
0404 f1			.pastdmark: pop af  
0405			endm  
# End of macro DMARK
0405						CALLMONITOR 
0405 cd 86 12			call break_point_state  
0408				endm  
# End of macro CALLMONITOR
0408					endif 
0408 cd c7 04			call storage_findnextid 
040b			 
040b e5				push hl 
040c			 
040c				; TODO check file not found 
040c			 
040c 11 65 eb			ld de, store_page 
040f cd b1 01			call storage_read_block 
0412			 
0412					if DEBUG_FORTH_WORDS 
0412						DMARK "ER1" 
0412 f5				push af  
0413 3a 27 04			ld a, (.dmark)  
0416 32 7a ee			ld (debug_mark),a  
0419 3a 28 04			ld a, (.dmark+1)  
041c 32 7b ee			ld (debug_mark+1),a  
041f 3a 29 04			ld a, (.dmark+2)  
0422 32 7c ee			ld (debug_mark+2),a  
0425 18 03			jr .pastdmark  
0427 ..			.dmark: db "ER1"  
042a f1			.pastdmark: pop af  
042b			endm  
# End of macro DMARK
042b						CALLMONITOR 
042b cd 86 12			call break_point_state  
042e				endm  
# End of macro CALLMONITOR
042e					endif 
042e 3a 65 eb			ld a, (store_page)	; get file id 
0431 32 5e eb			ld (store_tmpid), a 
0434			 
0434 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0437 32 5d eb			ld (store_tmpext), a 
043a			 
043a				; wipe file header 
043a			 
043a e1				pop hl 
043b 3e 00			ld a, 0 
043d 32 65 eb			ld (store_page), a 
0440 32 66 eb			ld (store_page+1),a 
0443 11 65 eb			ld de, store_page 
0446					if DEBUG_FORTH_WORDS 
0446						DMARK "ER2" 
0446 f5				push af  
0447 3a 5b 04			ld a, (.dmark)  
044a 32 7a ee			ld (debug_mark),a  
044d 3a 5c 04			ld a, (.dmark+1)  
0450 32 7b ee			ld (debug_mark+1),a  
0453 3a 5d 04			ld a, (.dmark+2)  
0456 32 7c ee			ld (debug_mark+2),a  
0459 18 03			jr .pastdmark  
045b ..			.dmark: db "ER2"  
045e f1			.pastdmark: pop af  
045f			endm  
# End of macro DMARK
045f						CALLMONITOR 
045f cd 86 12			call break_point_state  
0462				endm  
# End of macro CALLMONITOR
0462					endif 
0462 cd 16 02			call storage_write_block 
0465			 
0465			 
0465				; wipe file extents 
0465			 
0465 3a 5d eb			ld a, (store_tmpext) 
0468 47				ld b, a 
0469			 
0469			.eraext:	  
0469 c5				push bc 
046a			 
046a 21 40 00			ld hl, STORE_BLOCK_PHY 
046d 3a 5e eb			ld a,(store_tmpid) 
0470 5f				ld e, a 
0471 50				ld d, b	 
0472					if DEBUG_FORTH_WORDS 
0472						DMARK "ER3" 
0472 f5				push af  
0473 3a 87 04			ld a, (.dmark)  
0476 32 7a ee			ld (debug_mark),a  
0479 3a 88 04			ld a, (.dmark+1)  
047c 32 7b ee			ld (debug_mark+1),a  
047f 3a 89 04			ld a, (.dmark+2)  
0482 32 7c ee			ld (debug_mark+2),a  
0485 18 03			jr .pastdmark  
0487 ..			.dmark: db "ER3"  
048a f1			.pastdmark: pop af  
048b			endm  
# End of macro DMARK
048b						CALLMONITOR 
048b cd 86 12			call break_point_state  
048e				endm  
# End of macro CALLMONITOR
048e					endif 
048e cd c7 04			call storage_findnextid 
0491			 
0491 e5				push hl 
0492 11 65 eb			ld de, store_page 
0495 cd b1 01			call storage_read_block 
0498			 
0498				; free block	 
0498			 
0498 3e 00			ld a, 0 
049a 32 65 eb			ld (store_page), a 
049d 32 66 eb			ld (store_page+1),a 
04a0 11 65 eb			ld de, store_page 
04a3 e1				pop hl 
04a4					if DEBUG_FORTH_WORDS 
04a4						DMARK "ER4" 
04a4 f5				push af  
04a5 3a b9 04			ld a, (.dmark)  
04a8 32 7a ee			ld (debug_mark),a  
04ab 3a ba 04			ld a, (.dmark+1)  
04ae 32 7b ee			ld (debug_mark+1),a  
04b1 3a bb 04			ld a, (.dmark+2)  
04b4 32 7c ee			ld (debug_mark+2),a  
04b7 18 03			jr .pastdmark  
04b9 ..			.dmark: db "ER4"  
04bc f1			.pastdmark: pop af  
04bd			endm  
# End of macro DMARK
04bd						CALLMONITOR 
04bd cd 86 12			call break_point_state  
04c0				endm  
# End of macro CALLMONITOR
04c0					endif 
04c0 cd 16 02			call storage_write_block 
04c3			 
04c3 c1				pop bc 
04c4 10 a3			djnz .eraext 
04c6			 
04c6 c9				ret 
04c7			 
04c7			 
04c7			; Find Free Block 
04c7			; --------------- 
04c7			; 
04c7			; With current bank 
04c7			;  
04c7			; From given starting logical block 
04c7			;    Read block  
04c7			;    If no file id 
04c7			;         Return block id 
04c7			 
04c7			 
04c7			; hl starting page number 
04c7			; hl contains free page number or zero if no pages free 
04c7			; e contains the file id to locate 
04c7			; d contains the block number 
04c7			 
04c7			; TODO change to find file id and use zero for free block 
04c7			 
04c7			storage_findnextid: 
04c7			 
04c7				; now locate first 0 page to mark as a free block 
04c7			 
04c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04c9			;	ld hl, STORE_BLOCK_PHY 
04c9			 
04c9					if DEBUG_FORTH_WORDS 
04c9					DMARK "FNI" 
04c9 f5				push af  
04ca 3a de 04			ld a, (.dmark)  
04cd 32 7a ee			ld (debug_mark),a  
04d0 3a df 04			ld a, (.dmark+1)  
04d3 32 7b ee			ld (debug_mark+1),a  
04d6 3a e0 04			ld a, (.dmark+2)  
04d9 32 7c ee			ld (debug_mark+2),a  
04dc 18 03			jr .pastdmark  
04de ..			.dmark: db "FNI"  
04e1 f1			.pastdmark: pop af  
04e2			endm  
# End of macro DMARK
04e2						CALLMONITOR 
04e2 cd 86 12			call break_point_state  
04e5				endm  
# End of macro CALLMONITOR
04e5					endif 
04e5			.ff1:   	 
04e5 e5					push hl 
04e6 c5					push bc 
04e7 d5					push de 
04e8 cd ae 01				call se_readbyte 
04eb 5f					ld e,a 
04ec 23					inc hl 
04ed cd ae 01				call se_readbyte 
04f0 57					ld d, a 
04f1 e1					pop hl 
04f2 e5					push hl 
04f3 cd e0 0a				call cmp16 
04f6 28 49				jr z, .fffound 
04f8			 
04f8 d1					pop de 
04f9 c1					pop bc 
04fa e1					pop hl 
04fb			 
04fb					; is found? 
04fb					;cp e 
04fb					;ret z 
04fb			 
04fb 3e 40				ld a, STORE_BLOCK_PHY 
04fd cd c2 0a				call addatohl 
0500 10 e3				djnz .ff1 
0502			 
0502 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0504			.ff2:   	 
0504			 
0504 e5					push hl 
0505 c5					push bc 
0506 d5					push de 
0507 cd ae 01				call se_readbyte 
050a 5f					ld e,a 
050b 23					inc hl 
050c cd ae 01				call se_readbyte 
050f 57					ld d, a 
0510			 
0510 e1					pop hl 
0511 e5					push hl 
0512 cd e0 0a				call cmp16 
0515 28 2a				jr z, .fffound 
0517			 
0517 d1					pop de 
0518 c1					pop bc 
0519 e1					pop hl 
051a					; is found? 
051a					;cp e 
051a					;ret z 
051a			 
051a 3e 40				ld a, STORE_BLOCK_PHY 
051c cd c2 0a				call addatohl 
051f 10 e3				djnz .ff2 
0521			 
0521			 
0521					if DEBUG_FORTH_WORDS 
0521					DMARK "FN-" 
0521 f5				push af  
0522 3a 36 05			ld a, (.dmark)  
0525 32 7a ee			ld (debug_mark),a  
0528 3a 37 05			ld a, (.dmark+1)  
052b 32 7b ee			ld (debug_mark+1),a  
052e 3a 38 05			ld a, (.dmark+2)  
0531 32 7c ee			ld (debug_mark+2),a  
0534 18 03			jr .pastdmark  
0536 ..			.dmark: db "FN-"  
0539 f1			.pastdmark: pop af  
053a			endm  
# End of macro DMARK
053a					;	push af 
053a					;	ld a, 'n' 
053a					;	ld (debug_mark),a 
053a					;	pop af 
053a						CALLMONITOR 
053a cd 86 12			call break_point_state  
053d				endm  
# End of macro CALLMONITOR
053d					endif 
053d				; no free marks! 
053d 21 00 00				ld hl, 0 
0540 c9				ret 
0541			.fffound: 
0541				 
0541			 
0541 d1					pop de 
0542 c1					pop bc 
0543 e1					pop hl 
0544					if DEBUG_FORTH_WORDS 
0544					DMARK "FNF" 
0544 f5				push af  
0545 3a 59 05			ld a, (.dmark)  
0548 32 7a ee			ld (debug_mark),a  
054b 3a 5a 05			ld a, (.dmark+1)  
054e 32 7b ee			ld (debug_mark+1),a  
0551 3a 5b 05			ld a, (.dmark+2)  
0554 32 7c ee			ld (debug_mark+2),a  
0557 18 03			jr .pastdmark  
0559 ..			.dmark: db "FNF"  
055c f1			.pastdmark: pop af  
055d			endm  
# End of macro DMARK
055d					;	push af 
055d					;	ld a, 'n' 
055d					;	ld (debug_mark),a 
055d					;	pop af 
055d						CALLMONITOR 
055d cd 86 12			call break_point_state  
0560				endm  
# End of macro CALLMONITOR
0560					endif 
0560 c9				ret 
0561			 
0561			 
0561			 
0561			; Free Space 
0561			; ---------- 
0561			; 
0561			; With current bank 
0561			; 
0561			; Set block count to zero 
0561			; Starting with first logical block 
0561			;      Find free block  
0561			;      If block id given, increment block count 
0561			; 
0561			;  
0561			 
0561			 
0561			; hl contains count of free blocks 
0561			 
0561			storage_freeblocks: 
0561			 
0561				; now locate first 0 page to mark as a free block 
0561			 
0561 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0563 21 40 00			ld hl, STORE_BLOCK_PHY 
0566 11 00 00			ld de, 0 
0569			 
0569			.fb1:   	 
0569 e5					push hl 
056a c5					push bc 
056b d5					push de 
056c cd ae 01				call se_readbyte 
056f d1					pop de 
0570 c1					pop bc 
0571 e1					pop hl 
0572			 
0572					; is free? 
0572 fe 00				cp 0 
0574 20 01				jr nz, .ff1cont 
0576 13					inc de 
0577			 
0577			.ff1cont: 
0577			 
0577			 
0577 3e 40				ld a, STORE_BLOCK_PHY 
0579 cd c2 0a				call addatohl 
057c 10 eb				djnz .fb1 
057e			 
057e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0580			.fb2:   	 
0580 e5					push hl 
0581 c5					push bc 
0582 d5					push de 
0583 cd ae 01				call se_readbyte 
0586 d1					pop de 
0587 c1					pop bc 
0588 e1					pop hl 
0589			 
0589					; is free? 
0589 fe 00				cp 0 
058b 20 01				jr nz, .ff2cont 
058d 13					inc de 
058e			 
058e			.ff2cont: 
058e			 
058e 3e 40				ld a, STORE_BLOCK_PHY 
0590 cd c2 0a				call addatohl 
0593 10 eb				djnz .fb2 
0595			 
0595 eb				ex de, hl 
0596 c9				ret 
0597			 
0597			; Get File ID 
0597			; ----------- 
0597			; 
0597			; With current bank 
0597			;  
0597			; Load Block 0 Config 
0597			; Get max file id number 
0597			; For each logical block 
0597			;    Read block file id 
0597			;      If first block of file and dont have file id 
0597			;         if file get id and exit 
0597			 
0597			 
0597			 
0597			 
0597			; Create File 
0597			; ----------- 
0597			; 
0597			; With current bank  
0597			; Load Block 0 Config 
0597			; Get max file id number 
0597			; Increment file id number 
0597			; Save Config 
0597			; Find free block 
0597			; Set buffer with file name and file id 
0597			; Write buffer to free block  
0597			 
0597			 
0597			; hl point to file name 
0597			; hl returns file id 
0597			 
0597			; file format: 
0597			; byte 0 - file id 
0597			; byte 1 - extent number 
0597			; byte 2-> data 
0597			 
0597			; format for extent number 0: 
0597			; 
0597			; byte 0 - file id 
0597			; byte 1 - extent 0 
0597			; byte 2 - extent count 
0597			; byte 3 -> file name and meta data 
0597			 
0597			 
0597			storage_create: 
0597				if DEBUG_STORESE 
0597					DMARK "SCR" 
0597 f5				push af  
0598 3a ac 05			ld a, (.dmark)  
059b 32 7a ee			ld (debug_mark),a  
059e 3a ad 05			ld a, (.dmark+1)  
05a1 32 7b ee			ld (debug_mark+1),a  
05a4 3a ae 05			ld a, (.dmark+2)  
05a7 32 7c ee			ld (debug_mark+2),a  
05aa 18 03			jr .pastdmark  
05ac ..			.dmark: db "SCR"  
05af f1			.pastdmark: pop af  
05b0			endm  
# End of macro DMARK
05b0					CALLMONITOR 
05b0 cd 86 12			call break_point_state  
05b3				endm  
# End of macro CALLMONITOR
05b3				endif 
05b3			 
05b3 e5				push hl		; save file name pointer 
05b4			 
05b4 cd 62 02			call storage_get_block_0 
05b7			 
05b7 3a 65 eb			ld a,(store_page)	; get current file id 
05ba 3c				inc a 
05bb 32 65 eb			ld (store_page),a 
05be				 
05be 32 5e eb			ld (store_tmpid),a			; save id 
05c1			 
05c1 21 00 00			ld hl, 0 
05c4 11 65 eb			ld de, store_page 
05c7				if DEBUG_STORESE 
05c7					DMARK "SCw" 
05c7 f5				push af  
05c8 3a dc 05			ld a, (.dmark)  
05cb 32 7a ee			ld (debug_mark),a  
05ce 3a dd 05			ld a, (.dmark+1)  
05d1 32 7b ee			ld (debug_mark+1),a  
05d4 3a de 05			ld a, (.dmark+2)  
05d7 32 7c ee			ld (debug_mark+2),a  
05da 18 03			jr .pastdmark  
05dc ..			.dmark: db "SCw"  
05df f1			.pastdmark: pop af  
05e0			endm  
# End of macro DMARK
05e0					CALLMONITOR 
05e0 cd 86 12			call break_point_state  
05e3				endm  
# End of macro CALLMONITOR
05e3				endif 
05e3 cd 16 02			call storage_write_block	 ; save update 
05e6			 
05e6				if DEBUG_STORESE 
05e6 11 65 eb				ld de, store_page 
05e9					DMARK "SCC" 
05e9 f5				push af  
05ea 3a fe 05			ld a, (.dmark)  
05ed 32 7a ee			ld (debug_mark),a  
05f0 3a ff 05			ld a, (.dmark+1)  
05f3 32 7b ee			ld (debug_mark+1),a  
05f6 3a 00 06			ld a, (.dmark+2)  
05f9 32 7c ee			ld (debug_mark+2),a  
05fc 18 03			jr .pastdmark  
05fe ..			.dmark: db "SCC"  
0601 f1			.pastdmark: pop af  
0602			endm  
# End of macro DMARK
0602					CALLMONITOR 
0602 cd 86 12			call break_point_state  
0605				endm  
# End of macro CALLMONITOR
0605				endif 
0605				;  
0605				 
0605 21 40 00			ld hl, STORE_BLOCK_PHY 
0608 11 00 00			ld de, 0 
060b cd c7 04			call storage_findnextid 
060e			 
060e 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
0611			 
0611				; TODO detect 0 = no spare blocks 
0611			 
0611				; hl now contains the free page to use for the file header page 
0611			 
0611				if DEBUG_STORESE 
0611				DMARK "SCF" 
0611 f5				push af  
0612 3a 26 06			ld a, (.dmark)  
0615 32 7a ee			ld (debug_mark),a  
0618 3a 27 06			ld a, (.dmark+1)  
061b 32 7b ee			ld (debug_mark+1),a  
061e 3a 28 06			ld a, (.dmark+2)  
0621 32 7c ee			ld (debug_mark+2),a  
0624 18 03			jr .pastdmark  
0626 ..			.dmark: db "SCF"  
0629 f1			.pastdmark: pop af  
062a			endm  
# End of macro DMARK
062a					CALLMONITOR 
062a cd 86 12			call break_point_state  
062d				endm  
# End of macro CALLMONITOR
062d				endif 
062d			 
062d 22 63 eb			ld (store_tmppageid), hl 
0630				 
0630 3a 5e eb			ld a,(store_tmpid)    ; get file id 
0633			;	ld a, (store_filecache)			; save to cache 
0633			 
0633 32 65 eb			ld (store_page),a    ; set page id 
0636 3e 00			ld a, 0			 ; extent 0 is file header 
0638 32 66 eb			ld (store_page+1), a   ; set file extent 
063b			 
063b 32 67 eb			ld (store_page+2), a   ; extent count for the file 
063e			 
063e			;	inc hl 		; init block 0 of file 
063e			;	inc hl   		; skip file and extent id 
063e			 ;       ld a, 0 
063e			;	ld (hl),a 
063e			;	ld a, (store_filecache+1)  	; save to cache 
063e			 
063e			;	inc hl    ; file name 
063e				 
063e				 
063e 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0641				if DEBUG_STORESE 
0641					DMARK "SCc" 
0641 f5				push af  
0642 3a 56 06			ld a, (.dmark)  
0645 32 7a ee			ld (debug_mark),a  
0648 3a 57 06			ld a, (.dmark+1)  
064b 32 7b ee			ld (debug_mark+1),a  
064e 3a 58 06			ld a, (.dmark+2)  
0651 32 7c ee			ld (debug_mark+2),a  
0654 18 03			jr .pastdmark  
0656 ..			.dmark: db "SCc"  
0659 f1			.pastdmark: pop af  
065a			endm  
# End of macro DMARK
065a					CALLMONITOR 
065a cd 86 12			call break_point_state  
065d				endm  
# End of macro CALLMONITOR
065d				endif 
065d e1				pop hl    ; get zero term string 
065e e5				push hl 
065f 3e 00			ld a, 0 
0661 cd 2b 0f			call strlent 
0664 23				inc hl   ; cover zero term 
0665 06 00			ld b,0 
0667 4d				ld c,l 
0668 e1				pop hl 
0669				;ex de, hl 
0669				if DEBUG_STORESE 
0669					DMARK "SCa" 
0669 f5				push af  
066a 3a 7e 06			ld a, (.dmark)  
066d 32 7a ee			ld (debug_mark),a  
0670 3a 7f 06			ld a, (.dmark+1)  
0673 32 7b ee			ld (debug_mark+1),a  
0676 3a 80 06			ld a, (.dmark+2)  
0679 32 7c ee			ld (debug_mark+2),a  
067c 18 03			jr .pastdmark  
067e ..			.dmark: db "SCa"  
0681 f1			.pastdmark: pop af  
0682			endm  
# End of macro DMARK
0682					;push af 
0682					;ld a, 'a' 
0682					;ld (debug_mark),a 
0682					;pop af 
0682					CALLMONITOR 
0682 cd 86 12			call break_point_state  
0685				endm  
# End of macro CALLMONITOR
0685				endif 
0685 ed b0			ldir    ; copy zero term string 
0687				if DEBUG_STORESE 
0687					DMARK "SCA" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 7a ee			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 7b ee			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 7c ee			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "SCA"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					CALLMONITOR 
06a0 cd 86 12			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3				endif 
06a3			 
06a3				; write file header page 
06a3			 
06a3 2a 63 eb			ld hl,(store_tmppageid) 
06a6 11 65 eb			ld de, store_page 
06a9				if DEBUG_STORESE 
06a9					DMARK "SCb" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 7a ee			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 7b ee			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 7c ee			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "SCb"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2					;push af 
06c2					;ld a, 'b' 
06c2					;ld (debug_mark),a 
06c2					;pop af 
06c2					CALLMONITOR 
06c2 cd 86 12			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5				endif 
06c5 cd 16 02			call storage_write_block 
06c8			 
06c8 3a 5e eb			ld a, (store_tmpid) 
06cb 6f				ld l, a 
06cc 26 00			ld h,0 
06ce				if DEBUG_STORESE 
06ce					DMARK "SCz" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 7a ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 7b ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 7c ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCz"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 86 12			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea c9				ret 
06eb				 
06eb			 
06eb			 
06eb			; 
06eb			; Read File 
06eb			; 
06eb			; h - file id to locate 
06eb			; l - extent to locate 
06eb			; de - pointer to string to read into 
06eb			; 
06eb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06eb			storage_read: 
06eb d5				push de 
06ec			 
06ec			; TODO BUG the above push is it popped before the RET Z? 
06ec			 
06ec			; TODO how to handle multiple part blocks 
06ec			 
06ec				; locate file extent to read 
06ec			 
06ec 5c				ld e, h 
06ed 55				ld d, l 
06ee 21 40 00			ld hl, STORE_BLOCK_PHY 
06f1				if DEBUG_STORESE 
06f1					DMARK "SRE" 
06f1 f5				push af  
06f2 3a 06 07			ld a, (.dmark)  
06f5 32 7a ee			ld (debug_mark),a  
06f8 3a 07 07			ld a, (.dmark+1)  
06fb 32 7b ee			ld (debug_mark+1),a  
06fe 3a 08 07			ld a, (.dmark+2)  
0701 32 7c ee			ld (debug_mark+2),a  
0704 18 03			jr .pastdmark  
0706 ..			.dmark: db "SRE"  
0709 f1			.pastdmark: pop af  
070a			endm  
# End of macro DMARK
070a					CALLMONITOR 
070a cd 86 12			call break_point_state  
070d				endm  
# End of macro CALLMONITOR
070d				endif 
070d cd c7 04			call storage_findnextid 
0710			 
0710				if DEBUG_STORESE 
0710					DMARK "SRf" 
0710 f5				push af  
0711 3a 25 07			ld a, (.dmark)  
0714 32 7a ee			ld (debug_mark),a  
0717 3a 26 07			ld a, (.dmark+1)  
071a 32 7b ee			ld (debug_mark+1),a  
071d 3a 27 07			ld a, (.dmark+2)  
0720 32 7c ee			ld (debug_mark+2),a  
0723 18 03			jr .pastdmark  
0725 ..			.dmark: db "SRf"  
0728 f1			.pastdmark: pop af  
0729			endm  
# End of macro DMARK
0729					CALLMONITOR 
0729 cd 86 12			call break_point_state  
072c				endm  
# End of macro CALLMONITOR
072c				endif 
072c cd eb 0a			call ishlzero 
072f			;	ld a, l 
072f			;	add h 
072f			;	cp 0 
072f c8				ret z			; block not found so EOF 
0730			 
0730				; hl contains page number to load 
0730 d1				pop de   ; get storage 
0731 d5				push de 
0732				if DEBUG_STORESE 
0732					DMARK "SRg" 
0732 f5				push af  
0733 3a 47 07			ld a, (.dmark)  
0736 32 7a ee			ld (debug_mark),a  
0739 3a 48 07			ld a, (.dmark+1)  
073c 32 7b ee			ld (debug_mark+1),a  
073f 3a 49 07			ld a, (.dmark+2)  
0742 32 7c ee			ld (debug_mark+2),a  
0745 18 03			jr .pastdmark  
0747 ..			.dmark: db "SRg"  
074a f1			.pastdmark: pop af  
074b			endm  
# End of macro DMARK
074b					CALLMONITOR 
074b cd 86 12			call break_point_state  
074e				endm  
# End of macro CALLMONITOR
074e				endif 
074e cd b1 01			call storage_read_block 
0751			 
0751			 
0751			; TODO if block has no zeros then need to read next block  
0751			 
0751			 
0751					 
0751 e1				pop hl 		 ; return start of data to show as not EOF 
0752 23				inc hl   ; past file id 
0753 23				inc hl   ; past ext 
0754				if DEBUG_STORESE 
0754					DMARK "SRe" 
0754 f5				push af  
0755 3a 69 07			ld a, (.dmark)  
0758 32 7a ee			ld (debug_mark),a  
075b 3a 6a 07			ld a, (.dmark+1)  
075e 32 7b ee			ld (debug_mark+1),a  
0761 3a 6b 07			ld a, (.dmark+2)  
0764 32 7c ee			ld (debug_mark+2),a  
0767 18 03			jr .pastdmark  
0769 ..			.dmark: db "SRe"  
076c f1			.pastdmark: pop af  
076d			endm  
# End of macro DMARK
076d					CALLMONITOR 
076d cd 86 12			call break_point_state  
0770				endm  
# End of macro CALLMONITOR
0770				endif 
0770 c9					ret 
0771			 
0771			 
0771			 
0771			; 
0771			; Append File 
0771			; 
0771			; hl - file id to locate 
0771			; de - pointer to (multi block) string to write 
0771			 
0771			 
0771			storage_append: 
0771				; hl -  file id to append to 
0771				; de - string to append 
0771			 
0771 d5				push de 
0772				 
0772				if DEBUG_STORESE 
0772					DMARK "AP1" 
0772 f5				push af  
0773 3a 87 07			ld a, (.dmark)  
0776 32 7a ee			ld (debug_mark),a  
0779 3a 88 07			ld a, (.dmark+1)  
077c 32 7b ee			ld (debug_mark+1),a  
077f 3a 89 07			ld a, (.dmark+2)  
0782 32 7c ee			ld (debug_mark+2),a  
0785 18 03			jr .pastdmark  
0787 ..			.dmark: db "AP1"  
078a f1			.pastdmark: pop af  
078b			endm  
# End of macro DMARK
078b					CALLMONITOR 
078b cd 86 12			call break_point_state  
078e				endm  
# End of macro CALLMONITOR
078e				endif 
078e			 
078e 7d				ld a, l 
078f 32 5e eb			ld (store_tmpid), a 
0792			 
0792				; get file header  
0792			 
0792 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0794 3a 5e eb			ld a, (store_tmpid) 
0797 5f				ld e, a 
0798			 
0798 21 40 00				ld hl, STORE_BLOCK_PHY 
079b cd c7 04				call storage_findnextid 
079e			 
079e 22 63 eb			ld (store_tmppageid), hl 
07a1			 
07a1				; TODO handle file id not found 
07a1			 
07a1				if DEBUG_STORESE 
07a1					DMARK "AP2" 
07a1 f5				push af  
07a2 3a b6 07			ld a, (.dmark)  
07a5 32 7a ee			ld (debug_mark),a  
07a8 3a b7 07			ld a, (.dmark+1)  
07ab 32 7b ee			ld (debug_mark+1),a  
07ae 3a b8 07			ld a, (.dmark+2)  
07b1 32 7c ee			ld (debug_mark+2),a  
07b4 18 03			jr .pastdmark  
07b6 ..			.dmark: db "AP2"  
07b9 f1			.pastdmark: pop af  
07ba			endm  
# End of macro DMARK
07ba					CALLMONITOR 
07ba cd 86 12			call break_point_state  
07bd				endm  
# End of macro CALLMONITOR
07bd				endif 
07bd			 
07bd				; update file extent count 
07bd			 
07bd 11 65 eb			ld de, store_page 
07c0			 
07c0 cd b1 01			call storage_read_block 
07c3			 
07c3				if DEBUG_STORESE 
07c3					DMARK "AP3" 
07c3 f5				push af  
07c4 3a d8 07			ld a, (.dmark)  
07c7 32 7a ee			ld (debug_mark),a  
07ca 3a d9 07			ld a, (.dmark+1)  
07cd 32 7b ee			ld (debug_mark+1),a  
07d0 3a da 07			ld a, (.dmark+2)  
07d3 32 7c ee			ld (debug_mark+2),a  
07d6 18 03			jr .pastdmark  
07d8 ..			.dmark: db "AP3"  
07db f1			.pastdmark: pop af  
07dc			endm  
# End of macro DMARK
07dc					CALLMONITOR 
07dc cd 86 12			call break_point_state  
07df				endm  
# End of macro CALLMONITOR
07df				endif 
07df			;	ld (store_tmppageid), hl 
07df			 
07df 3a 67 eb			ld a, (store_page+2) 
07e2 3c				inc a 
07e3 32 67 eb			ld (store_page+2), a 
07e6 32 5d eb			ld (store_tmpext), a 
07e9				 
07e9				if DEBUG_STORESE 
07e9					DMARK "AP3" 
07e9 f5				push af  
07ea 3a fe 07			ld a, (.dmark)  
07ed 32 7a ee			ld (debug_mark),a  
07f0 3a ff 07			ld a, (.dmark+1)  
07f3 32 7b ee			ld (debug_mark+1),a  
07f6 3a 00 08			ld a, (.dmark+2)  
07f9 32 7c ee			ld (debug_mark+2),a  
07fc 18 03			jr .pastdmark  
07fe ..			.dmark: db "AP3"  
0801 f1			.pastdmark: pop af  
0802			endm  
# End of macro DMARK
0802					CALLMONITOR 
0802 cd 86 12			call break_point_state  
0805				endm  
# End of macro CALLMONITOR
0805				endif 
0805 2a 63 eb			ld hl, (store_tmppageid) 
0808 11 65 eb			ld de, store_page 
080b cd 16 02			call storage_write_block 
080e			 
080e				; find free block 
080e			 
080e 11 00 00			ld de, 0			 ; file extent to locate 
0811			 
0811 21 40 00				ld hl, STORE_BLOCK_PHY 
0814 cd c7 04				call storage_findnextid 
0817			 
0817					; TODO handle no space left 
0817					 
0817 22 63 eb				ld (store_tmppageid), hl 
081a			 
081a				if DEBUG_STORESE 
081a					DMARK "AP4" 
081a f5				push af  
081b 3a 2f 08			ld a, (.dmark)  
081e 32 7a ee			ld (debug_mark),a  
0821 3a 30 08			ld a, (.dmark+1)  
0824 32 7b ee			ld (debug_mark+1),a  
0827 3a 31 08			ld a, (.dmark+2)  
082a 32 7c ee			ld (debug_mark+2),a  
082d 18 03			jr .pastdmark  
082f ..			.dmark: db "AP4"  
0832 f1			.pastdmark: pop af  
0833			endm  
# End of macro DMARK
0833					CALLMONITOR 
0833 cd 86 12			call break_point_state  
0836				endm  
# End of macro CALLMONITOR
0836				endif 
0836					; init the buffer with zeros so we can id if the buffer is full or not 
0836			 
0836 e5					push hl 
0837 c5					push bc 
0838			 
0838 21 65 eb				ld hl, store_page 
083b 06 40				ld b, STORE_BLOCK_PHY 
083d 3e 00				ld a, 0 
083f 77			.zeroblock:	ld (hl), a 
0840 23					inc hl 
0841 10 fc				djnz .zeroblock 
0843			 
0843 c1					pop bc 
0844 e1					pop hl 
0845			 
0845					; construct block 
0845			 
0845 3a 5e eb				ld a, (store_tmpid) 
0848 32 65 eb				ld (store_page), a   ; file id 
084b 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
084e 32 66 eb				ld (store_page+1), a 
0851			 
0851 e1					pop hl    ; get string to write 
0852 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0854 11 67 eb				ld de, store_page+2 
0857			 
0857				if DEBUG_STORESE 
0857					DMARK "AP5" 
0857 f5				push af  
0858 3a 6c 08			ld a, (.dmark)  
085b 32 7a ee			ld (debug_mark),a  
085e 3a 6d 08			ld a, (.dmark+1)  
0861 32 7b ee			ld (debug_mark+1),a  
0864 3a 6e 08			ld a, (.dmark+2)  
0867 32 7c ee			ld (debug_mark+2),a  
086a 18 03			jr .pastdmark  
086c ..			.dmark: db "AP5"  
086f f1			.pastdmark: pop af  
0870			endm  
# End of macro DMARK
0870					CALLMONITOR 
0870 cd 86 12			call break_point_state  
0873				endm  
# End of macro CALLMONITOR
0873				endif 
0873			 
0873			 
0873			 
0873					; fill buffer with data until end of string or full block 
0873			 
0873 7e			.appd:		ld a, (hl) 
0874 12					ld (de), a 
0875 fe 00				cp 0 
0877 28 04				jr z, .appdone 
0879 23					inc hl 
087a 13					inc de 
087b 10 f6				djnz .appd 
087d			 
087d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
087e f5					push af   		; save last byte dumped 
087f			 
087f			 
087f 2a 63 eb			ld hl, (store_tmppageid) 
0882 11 65 eb			ld de, store_page 
0885				if DEBUG_STORESE 
0885					DMARK "AP6" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 7a ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 7b ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 7c ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "AP6"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 86 12			call break_point_state  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 cd 16 02				call storage_write_block 
08a4			 
08a4			 
08a4				; was that a full block of data written? 
08a4				; any more to write out? 
08a4			 
08a4				; if yes then set vars and jump to start of function again 
08a4			 
08a4 f1					pop af 
08a5 d1					pop de 
08a6			 
08a6 fe 00				cp 0		 ; no, string was fully written 
08a8 c8					ret z 
08a9			 
08a9					; setup vars for next cycle 
08a9			 
08a9 3a 5e eb				ld a, (store_tmpid) 
08ac 6f					ld l, a 
08ad 26 00				ld h, 0 
08af			 
08af c3 71 07			 	jp storage_append	 ; yes, need to write out some more 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			if DEBUG_STORECF 
08b2			storageput:	 
08b2					ret 
08b2			storageread: 
08b2					ld hl, store_page 
08b2					ld b, 200 
08b2					ld a,0 
08b2			.src:		ld (hl),a 
08b2					inc hl 
08b2					djnz .src 
08b2					 
08b2			 
08b2					ld de, 0 
08b2					ld bc, 1 
08b2					ld hl, store_page 
08b2					call cfRead 
08b2			 
08b2				call cfGetError 
08b2				ld hl,scratch 
08b2				call hexout 
08b2				ld hl, scratch+2 
08b2				ld a, 0 
08b2				ld (hl),a 
08b2				ld de, scratch 
08b2				ld a,display_row_1 
08b2				call str_at_display 
08b2				call update_display 
08b2			 
08b2					ld hl, store_page 
08b2					ld (os_cur_ptr),hl 
08b2			 
08b2					ret 
08b2			endif 
08b2			 
08b2			 
08b2			; Clear out the main buffer store (used to remove junk before writing a new block) 
08b2			 
08b2			storage_clear_page: 
08b2 e5				push hl 
08b3 d5				push de 
08b4 c5				push bc 
08b5 21 65 eb			ld hl, store_page 
08b8 3e 00			ld a, 0 
08ba 77				ld (hl), a 
08bb			 
08bb 11 66 eb			ld de, store_page+1 
08be 01 40 00			ld bc, STORE_BLOCK_PHY 
08c1			 
08c1 ed b0			ldir 
08c3				 
08c3 c1				pop bc 
08c4 d1				pop de 
08c5 e1				pop hl 
08c6 c9				ret 
08c7			 
08c7			; eof 
# End of file firmware_storage.asm
08c7			  
08c7			; support routines for above hardware abstraction layer  
08c7			  
08c7			include "firmware_general.asm"        ; general support functions  
08c7			 
08c7			 
08c7			 
08c7			; Delay loops 
08c7			 
08c7			 
08c7			 
08c7			aDelayInMS: 
08c7 c5				push bc 
08c8 47				ld b,a 
08c9			msdelay: 
08c9 c5				push bc 
08ca				 
08ca			 
08ca 01 41 00			ld bc,041h 
08cd cd e5 08			call delayloop 
08d0 c1				pop bc 
08d1 05				dec b 
08d2 20 f5			jr nz,msdelay 
08d4			 
08d4			;if CPU_CLOCK_8MHZ 
08d4			;msdelay8: 
08d4			;	push bc 
08d4			;	 
08d4			; 
08d4			;	ld bc,041h 
08d4			;	call delayloop 
08d4			;	pop bc 
08d4			;	dec b 
08d4			;	jr nz,msdelay8 
08d4			;endif 
08d4			 
08d4			 
08d4 c1				pop bc 
08d5 c9				ret 
08d6			 
08d6			 
08d6			delay250ms: 
08d6				;push de 
08d6 01 00 40			ld bc, 04000h 
08d9 c3 e5 08			jp delayloop 
08dc			delay500ms: 
08dc				;push de 
08dc 01 00 80			ld bc, 08000h 
08df c3 e5 08			jp delayloop 
08e2			delay1s: 
08e2				;push bc 
08e2			   ; Clobbers A, d and e 
08e2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08e5			delayloop: 
08e5 c5			    push bc 
08e6			 
08e6			if BASE_CPM 
08e6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
08e9			.cpmloop: 
08e9 c5				push bc 
08ea			 
08ea			endif 
08ea			 
08ea			 
08ea			 
08ea			delayloopi: 
08ea			;	push bc 
08ea			;.dl: 
08ea cb 47		    bit     0,a    	; 8 
08ec cb 47		    bit     0,a    	; 8 
08ee cb 47		    bit     0,a    	; 8 
08f0 e6 ff		    and     255  	; 7 
08f2 0b			    dec     bc      	; 6 
08f3 79			    ld      a,c     	; 4 
08f4 b0			    or      b     	; 4 
08f5 c2 ea 08		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
08f8			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
08f8				;pop de 
08f8			;pop bc 
08f8			 
08f8			if BASE_CPM 
08f8 c1				pop bc 
08f9				 
08f9 0b			    dec     bc      	; 6 
08fa 79			    ld      a,c     	; 4 
08fb b0			    or      b     	; 4 
08fc c2 e9 08		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
08ff				 
08ff			 
08ff			endif 
08ff			;if CPU_CLOCK_8MHZ 
08ff			;    pop bc 
08ff			;    push bc 
08ff			;.dl8: 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    and     255  	; 7 
08ff			;    dec     bc      	; 6 
08ff			;    ld      a,c     	; 4 
08ff			;    or      b     	; 4 
08ff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
08ff			;endif 
08ff			 
08ff			;if CPU_CLOCK_10MHZ 
08ff			;    pop bc 
08ff			;    push bc 
08ff			;.dl8: 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    and     255  	; 7 
08ff			;    dec     bc      	; 6 
08ff			;    ld      a,c     	; 4 
08ff			;    or      b     	; 4 
08ff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
08ff			;endif 
08ff c1			    pop bc 
0900			 
0900 c9				ret 
0901			 
0901			 
0901			 
0901			; eof 
# End of file firmware_general.asm
0901			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0901			; display routines that use the physical hardware abstraction layer 
0901			 
0901			 
0901			; TODO windowing? 
0901			 
0901			; TODO scroll line up 
0901			 
0901			scroll_up: 
0901			 
0901 e5				push hl 
0902 d5				push de 
0903 c5				push bc 
0904			 
0904				; get frame buffer  
0904			 
0904 2a db eb			ld hl, (display_fb_active) 
0907 e5				push hl    ; future de destination 
0908			 
0908 11 28 00			ld  de, display_cols 
090b 19				add hl, de 
090c			 
090c d1				pop de 
090d			 
090d				;ex de, hl 
090d 01 9f 00			ld bc, display_fb_len -1  
0910			;if DEBUG_FORTH_WORDS 
0910			;	DMARK "SCL" 
0910			;	CALLMONITOR 
0910			;endif	 
0910 ed b0			ldir 
0912			 
0912				; wipe bottom row 
0912			 
0912			 
0912 2a db eb			ld hl, (display_fb_active) 
0915 11 a0 00			ld de, display_cols*display_rows 
0918 19				add hl, de 
0919 06 28			ld b, display_cols 
091b 3e 20			ld a, ' ' 
091d			.scwipe: 
091d 77				ld (hl), a 
091e 2b				dec hl 
091f 10 fc			djnz .scwipe 
0921			 
0921				;pop hl 
0921			 
0921 c1				pop bc 
0922 d1				pop de 
0923 e1				pop hl 
0924			 
0924 c9				ret 
0925			 
0925			 
0925			scroll_upo: 
0925 11 00 00			ld de, display_row_1 
0928 21 28 00		 	ld hl, display_row_2 
092b 01 28 00			ld bc, display_cols 
092e ed b0			ldir 
0930 11 28 00			ld de, display_row_2 
0933 21 50 00		 	ld hl, display_row_3 
0936 01 28 00			ld bc, display_cols 
0939 ed b0			ldir 
093b 11 50 00			ld de, display_row_3 
093e 21 78 00		 	ld hl, display_row_4 
0941 01 28 00			ld bc, display_cols 
0944 ed b0			ldir 
0946			 
0946			; TODO clear row 4 
0946			 
0946 c9				ret 
0947				 
0947			scroll_down: 
0947 11 78 00			ld de, display_row_4 
094a 21 50 00		 	ld hl, display_row_3 
094d 01 28 00			ld bc, display_cols 
0950 ed b0			ldir 
0952 11 50 00			ld de, display_row_3 
0955 21 28 00		 	ld hl, display_row_2 
0958 01 28 00			ld bc, display_cols 
095b ed b0			ldir 
095d 11 28 00			ld de, display_row_2 
0960 21 00 00		 	ld hl, display_row_1 
0963 01 28 00			ld bc, display_cols 
0966 ed b0			ldir 
0968			; TODO clear row 1 
0968 c9				ret 
0969			 
0969			 
0969			 
0969			 
0969			 
0969			; clear active frame buffer 
0969			 
0969			clear_display: 
0969 3e 20			ld a, ' ' 
096b c3 6e 09			jp fill_display 
096e			 
096e			; fill active frame buffer with a char in A 
096e			 
096e			fill_display: 
096e 06 a0			ld b,display_fb_len 
0970 2a db eb			ld hl, (display_fb_active) 
0973 77			.fd1:	ld (hl),a 
0974 23				inc hl 
0975 10 fc			djnz .fd1 
0977 23				inc hl 
0978 3e 00			ld a,0 
097a 77				ld (hl),a 
097b			 
097b			 
097b c9				ret 
097c			; Write string (DE) at pos (A) to active frame buffer 
097c			 
097c 2a db eb		str_at_display:    ld hl,(display_fb_active) 
097f 06 00					ld b,0 
0981 4f					ld c,a 
0982 09					add hl,bc 
0983 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0984 b7			            OR   A              ;Null terminator? 
0985 c8			            RET  Z              ;Yes, so finished 
0986 77					ld (hl),a 
0987 23				inc hl 
0988 13			            INC  DE             ;Point to next character 
0989 18 f8		            JR   .sad1     ;Repeat 
098b c9					ret 
098c			 
098c			; using current frame buffer write to physical display 
098c			 
098c			update_display: 
098c e5				push hl 
098d 2a db eb			ld hl, (display_fb_active) 
0990 cd 44 55			call write_display 
0993 e1				pop hl 
0994 c9				ret 
0995			 
0995			; TODO scrolling 
0995			 
0995			 
0995			; move cursor right one char 
0995			cursor_right: 
0995			 
0995				; TODO shift right 
0995				; TODO if beyond max col 
0995				; TODO       cursor_next_line 
0995			 
0995 c9				ret 
0996			 
0996			 
0996			cursor_next_line: 
0996				; TODO first char 
0996				; TODO line down 
0996				; TODO if past last row 
0996				; TODO    scroll up 
0996			 
0996 c9				ret 
0997			 
0997			cursor_left: 
0997				; TODO shift left 
0997				; TODO if beyond left  
0997				; TODO     cursor prev line 
0997				 
0997 c9				ret 
0998			 
0998			cursor_prev_line: 
0998				; TODO last char 
0998				; TODO line up 
0998				; TODO if past first row 
0998				; TODO   scroll down 
0998			 
0998 c9				ret 
0999			 
0999			 
0999			cout: 
0999				; A - char 
0999 c9				ret 
099a			 
099a			; eof 
099a			 
# End of file firmware_display.asm
099a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
099a			; random number generators 
099a			 
099a			 
099a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
099a			 
099a			 
099a			;-----> Generate a random number 
099a			; output a=answer 0<=a<=255 
099a			; all registers are preserved except: af 
099a			random: 
099a e5			        push    hl 
099b d5			        push    de 
099c 2a bd eb		        ld      hl,(randData) 
099f ed 5f		        ld      a,r 
09a1 57			        ld      d,a 
09a2 5e			        ld      e,(hl) 
09a3 19			        add     hl,de 
09a4 85			        add     a,l 
09a5 ac			        xor     h 
09a6 22 bd eb		        ld      (randData),hl 
09a9 d1			        pop     de 
09aa e1			        pop     hl 
09ab c9			        ret 
09ac			 
09ac			 
09ac			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
09ac			 
09ac			 
09ac			 
09ac			;------LFSR------ 
09ac			;James Montelongo 
09ac			;optimized by Spencer Putt 
09ac			;out: 
09ac			; a = 8 bit random number 
09ac			RandLFSR: 
09ac 21 c3 eb		        ld hl,LFSRSeed+4 
09af 5e			        ld e,(hl) 
09b0 23			        inc hl 
09b1 56			        ld d,(hl) 
09b2 23			        inc hl 
09b3 4e			        ld c,(hl) 
09b4 23			        inc hl 
09b5 7e			        ld a,(hl) 
09b6 47			        ld b,a 
09b7 cb 13		        rl e  
09b9 cb 12			rl d 
09bb cb 11		        rl c  
09bd 17				rla 
09be cb 13		        rl e  
09c0 cb 12			rl d 
09c2 cb 11		        rl c  
09c4 17				rla 
09c5 cb 13		        rl e  
09c7 cb 12			rl d 
09c9 cb 11		        rl c  
09cb 17				rla 
09cc 67			        ld h,a 
09cd cb 13		        rl e  
09cf cb 12			rl d 
09d1 cb 11		        rl c  
09d3 17				rla 
09d4 a8			        xor b 
09d5 cb 13		        rl e  
09d7 cb 12			rl d 
09d9 ac			        xor h 
09da a9			        xor c 
09db aa			        xor d 
09dc 21 c5 eb		        ld hl,LFSRSeed+6 
09df 11 c6 eb		        ld de,LFSRSeed+7 
09e2 01 07 00		        ld bc,7 
09e5 ed b8		        lddr 
09e7 12			        ld (de),a 
09e8 c9			        ret 
09e9			 
09e9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
09e9			 
09e9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
09e9			 
09e9			 
09e9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
09e9			 
09e9			prng16: 
09e9			;Inputs: 
09e9			;   (seed1) contains a 16-bit seed value 
09e9			;   (seed2) contains a NON-ZERO 16-bit seed value 
09e9			;Outputs: 
09e9			;   HL is the result 
09e9			;   BC is the result of the LCG, so not that great of quality 
09e9			;   DE is preserved 
09e9			;Destroys: 
09e9			;   AF 
09e9			;cycle: 4,294,901,760 (almost 4.3 billion) 
09e9			;160cc 
09e9			;26 bytes 
09e9 2a b7 eb		    ld hl,(seed1) 
09ec 44			    ld b,h 
09ed 4d			    ld c,l 
09ee 29			    add hl,hl 
09ef 29			    add hl,hl 
09f0 2c			    inc l 
09f1 09			    add hl,bc 
09f2 22 b7 eb		    ld (seed1),hl 
09f5 2a b5 eb		    ld hl,(seed2) 
09f8 29			    add hl,hl 
09f9 9f			    sbc a,a 
09fa e6 2d		    and %00101101 
09fc ad			    xor l 
09fd 6f			    ld l,a 
09fe 22 b5 eb		    ld (seed2),hl 
0a01 09			    add hl,bc 
0a02 c9			    ret 
0a03			 
0a03			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0a03			 
0a03			rand32: 
0a03			;Inputs: 
0a03			;   (seed1_0) holds the lower 16 bits of the first seed 
0a03			;   (seed1_1) holds the upper 16 bits of the first seed 
0a03			;   (seed2_0) holds the lower 16 bits of the second seed 
0a03			;   (seed2_1) holds the upper 16 bits of the second seed 
0a03			;   **NOTE: seed2 must be non-zero 
0a03			;Outputs: 
0a03			;   HL is the result 
0a03			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0a03			;Destroys: 
0a03			;   AF 
0a03			;Tested and passes all CAcert tests 
0a03			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0a03			;it has a period of 18,446,744,069,414,584,320 
0a03			;roughly 18.4 quintillion. 
0a03			;LFSR taps: 0,2,6,7  = 11000101 
0a03			;291cc 
0a03			;seed1_0=$+1 
0a03			;    ld hl,12345 
0a03			;seed1_1=$+1 
0a03			;    ld de,6789 
0a03			;    ld b,h 
0a03			;    ld c,l 
0a03			;    add hl,hl \ rl e \ rl d 
0a03			;    add hl,hl \ rl e \ rl d 
0a03			;    inc l 
0a03			;    add hl,bc 
0a03			;    ld (seed1_0),hl 
0a03			;    ld hl,(seed1_1) 
0a03			;    adc hl,de 
0a03			;    ld (seed1_1),hl 
0a03			;    ex de,hl 
0a03			;seed2_0=$+1 
0a03			;    ld hl,9876 
0a03			;seed2_1=$+1 
0a03			;    ld bc,54321 
0a03			;    add hl,hl \ rl c \ rl b 
0a03			;    ld (seed2_1),bc 
0a03			;    sbc a,a 
0a03			;    and %11000101 
0a03			;    xor l 
0a03			;    ld l,a 
0a03			;    ld (seed2_0),hl 
0a03			;    ex de,hl 
0a03			;    add hl,bc 
0a03			;    ret 
0a03			; 
0a03			 
0a03			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0a03			; 20 bytes, 86 cycles (excluding ret) 
0a03			 
0a03			; returns   hl = pseudorandom number 
0a03			; corrupts   a 
0a03			 
0a03			; generates 16-bit pseudorandom numbers with a period of 65535 
0a03			; using the xorshift method: 
0a03			 
0a03			; hl ^= hl << 7 
0a03			; hl ^= hl >> 9 
0a03			; hl ^= hl << 8 
0a03			 
0a03			; some alternative shift triplets which also perform well are: 
0a03			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0a03			 
0a03			;  org 32768 
0a03			 
0a03			xrnd: 
0a03 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0a06 3e 00		  ld a,0 
0a08 bd			  cp l 
0a09 20 02		  jr nz, .xrnd1 
0a0b 2e 01		  ld l, 1 
0a0d			.xrnd1: 
0a0d			 
0a0d 7c			  ld a,h 
0a0e 1f			  rra 
0a0f 7d			  ld a,l 
0a10 1f			  rra 
0a11 ac			  xor h 
0a12 67			  ld h,a 
0a13 7d			  ld a,l 
0a14 1f			  rra 
0a15 7c			  ld a,h 
0a16 1f			  rra 
0a17 ad			  xor l 
0a18 6f			  ld l,a 
0a19 ac			  xor h 
0a1a 67			  ld h,a 
0a1b			 
0a1b 22 bb eb		  ld (xrandc),hl 
0a1e			 
0a1e c9			  ret 
0a1f			;  
0a1f			 
0a1f			 
0a1f			;;;; int maths 
0a1f			 
0a1f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0a1f			; Divide 16-bit values (with 16-bit result) 
0a1f			; In: Divide BC by divider DE 
0a1f			; Out: BC = result, HL = rest 
0a1f			; 
0a1f			Div16: 
0a1f 21 00 00		    ld hl,0 
0a22 78			    ld a,b 
0a23 06 08		    ld b,8 
0a25			Div16_Loop1: 
0a25 17			    rla 
0a26 ed 6a		    adc hl,hl 
0a28 ed 52		    sbc hl,de 
0a2a 30 01		    jr nc,Div16_NoAdd1 
0a2c 19			    add hl,de 
0a2d			Div16_NoAdd1: 
0a2d 10 f6		    djnz Div16_Loop1 
0a2f 17			    rla 
0a30 2f			    cpl 
0a31 47			    ld b,a 
0a32 79			    ld a,c 
0a33 48			    ld c,b 
0a34 06 08		    ld b,8 
0a36			Div16_Loop2: 
0a36 17			    rla 
0a37 ed 6a		    adc hl,hl 
0a39 ed 52		    sbc hl,de 
0a3b 30 01		    jr nc,Div16_NoAdd2 
0a3d 19			    add hl,de 
0a3e			Div16_NoAdd2: 
0a3e 10 f6		    djnz Div16_Loop2 
0a40 17			    rla 
0a41 2f			    cpl 
0a42 41			    ld b,c 
0a43 4f			    ld c,a 
0a44 c9			ret 
0a45			 
0a45			 
0a45			;http://z80-heaven.wikidot.com/math 
0a45			; 
0a45			;Inputs: 
0a45			;     DE and A are factors 
0a45			;Outputs: 
0a45			;     A is not changed 
0a45			;     B is 0 
0a45			;     C is not changed 
0a45			;     DE is not changed 
0a45			;     HL is the product 
0a45			;Time: 
0a45			;     342+6x 
0a45			; 
0a45			Mult16: 
0a45			 
0a45 06 08		     ld b,8          ;7           7 
0a47 21 00 00		     ld hl,0         ;10         10 
0a4a 29			       add hl,hl     ;11*8       88 
0a4b 07			       rlca          ;4*8        32 
0a4c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0a4e 19			         add hl,de   ;--         -- 
0a4f 10 f9		       djnz $-5      ;13*7+8     99 
0a51 c9			ret 
0a52			 
0a52			; 
0a52			; Square root of 16-bit value 
0a52			; In:  HL = value 
0a52			; Out:  D = result (rounded down) 
0a52			; 
0a52			;Sqr16: 
0a52			;    ld de,#0040 
0a52			;    ld a,l 
0a52			;    ld l,h 
0a52			;    ld h,d 
0a52			;    or a 
0a52			;    ld b,8 
0a52			;Sqr16_Loop: 
0a52			;    sbc hl,de 
0a52			;    jr nc,Sqr16_Skip 
0a52			;    add hl,de 
0a52			;Sqr16_Skip: 
0a52			;    ccf 
0a52			;    rl d 
0a52			;    add a,a 
0a52			;    adc hl,hl 
0a52			;    add a,a 
0a52			;    adc hl,hl 
0a52			;    djnz Sqr16_Loop 
0a52			;    ret 
0a52			; 
0a52			; 
0a52			; Divide 8-bit values 
0a52			; In: Divide E by divider C 
0a52			; Out: A = result, B = rest 
0a52			; 
0a52			Div8: 
0a52 af			    xor a 
0a53 06 08		    ld b,8 
0a55			Div8_Loop: 
0a55 cb 13		    rl e 
0a57 17			    rla 
0a58 91			    sub c 
0a59 30 01		    jr nc,Div8_NoAdd 
0a5b 81			    add a,c 
0a5c			Div8_NoAdd: 
0a5c 10 f7		    djnz Div8_Loop 
0a5e 47			    ld b,a 
0a5f 7b			    ld a,e 
0a60 17			    rla 
0a61 2f			    cpl 
0a62 c9			    ret 
0a63			 
0a63			; 
0a63			; Multiply 8-bit value with a 16-bit value (unrolled) 
0a63			; In: Multiply A with DE 
0a63			; Out: HL = result 
0a63			; 
0a63			Mult12U: 
0a63 2e 00		    ld l,0 
0a65 87			    add a,a 
0a66 30 01		    jr nc,Mult12U_NoAdd0 
0a68 19			    add hl,de 
0a69			Mult12U_NoAdd0: 
0a69 29			    add hl,hl 
0a6a 87			    add a,a 
0a6b 30 01		    jr nc,Mult12U_NoAdd1 
0a6d 19			    add hl,de 
0a6e			Mult12U_NoAdd1: 
0a6e 29			    add hl,hl 
0a6f 87			    add a,a 
0a70 30 01		    jr nc,Mult12U_NoAdd2 
0a72 19			    add hl,de 
0a73			Mult12U_NoAdd2: 
0a73 29			    add hl,hl 
0a74 87			    add a,a 
0a75 30 01		    jr nc,Mult12U_NoAdd3 
0a77 19			    add hl,de 
0a78			Mult12U_NoAdd3: 
0a78 29			    add hl,hl 
0a79 87			    add a,a 
0a7a 30 01		    jr nc,Mult12U_NoAdd4 
0a7c 19			    add hl,de 
0a7d			Mult12U_NoAdd4: 
0a7d 29			    add hl,hl 
0a7e 87			    add a,a 
0a7f 30 01		    jr nc,Mult12U_NoAdd5 
0a81 19			    add hl,de 
0a82			Mult12U_NoAdd5: 
0a82 29			    add hl,hl 
0a83 87			    add a,a 
0a84 30 01		    jr nc,Mult12U_NoAdd6 
0a86 19			    add hl,de 
0a87			Mult12U_NoAdd6: 
0a87 29			    add hl,hl 
0a88 87			    add a,a 
0a89 d0			    ret nc 
0a8a 19			    add hl,de 
0a8b c9			    ret 
0a8c			 
0a8c			; 
0a8c			; Multiply 8-bit value with a 16-bit value (right rotating) 
0a8c			; In: Multiply A with DE 
0a8c			;      Put lowest value in A for most efficient calculation 
0a8c			; Out: HL = result 
0a8c			; 
0a8c			Mult12R: 
0a8c 21 00 00		    ld hl,0 
0a8f			Mult12R_Loop: 
0a8f cb 3f		    srl a 
0a91 30 01		    jr nc,Mult12R_NoAdd 
0a93 19			    add hl,de 
0a94			Mult12R_NoAdd: 
0a94 cb 23		    sla e 
0a96 cb 12		    rl d 
0a98 b7			    or a 
0a99 c2 8f 0a		    jp nz,Mult12R_Loop 
0a9c c9			    ret 
0a9d			 
0a9d			; 
0a9d			; Multiply 16-bit values (with 32-bit result) 
0a9d			; In: Multiply BC with DE 
0a9d			; Out: BCHL = result 
0a9d			; 
0a9d			Mult32: 
0a9d 79			    ld a,c 
0a9e 48			    ld c,b 
0a9f 21 00 00		    ld hl,0 
0aa2 06 10		    ld b,16 
0aa4			Mult32_Loop: 
0aa4 29			    add hl,hl 
0aa5 17			    rla 
0aa6 cb 11		    rl c 
0aa8 30 07		    jr nc,Mult32_NoAdd 
0aaa 19			    add hl,de 
0aab ce 00		    adc a,0 
0aad d2 b1 0a		    jp nc,Mult32_NoAdd 
0ab0 0c			    inc c 
0ab1			Mult32_NoAdd: 
0ab1 10 f1		    djnz Mult32_Loop 
0ab3 41			    ld b,c 
0ab4 4f			    ld c,a 
0ab5 c9			    ret 
0ab6			 
0ab6			 
0ab6			 
0ab6			; 
0ab6			; Multiply 8-bit values 
0ab6			; In:  Multiply H with E 
0ab6			; Out: HL = result 
0ab6			; 
0ab6			Mult8: 
0ab6 16 00		    ld d,0 
0ab8 6a			    ld l,d 
0ab9 06 08		    ld b,8 
0abb			Mult8_Loop: 
0abb 29			    add hl,hl 
0abc 30 01		    jr nc,Mult8_NoAdd 
0abe 19			    add hl,de 
0abf			Mult8_NoAdd: 
0abf 10 fa		    djnz Mult8_Loop 
0ac1 c9			    ret 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			;;http://z80-heaven.wikidot.com/math 
0ac2			;;This divides DE by BC, storing the result in DE, remainder in HL 
0ac2			; 
0ac2			;DE_Div_BC:          ;1281-2x, x is at most 16 
0ac2			;     ld a,16        ;7 
0ac2			;     ld hl,0        ;10 
0ac2			;     jp $+5         ;10 
0ac2			;.DivLoop: 
0ac2			;       add hl,bc    ;-- 
0ac2			;       dec a        ;64 
0ac2			;       jr z,.DivLoopEnd        ;86 
0ac2			; 
0ac2			;       sla e        ;128 
0ac2			;       rl d         ;128 
0ac2			;       adc hl,hl    ;240 
0ac2			;       sbc hl,bc    ;240 
0ac2			;       jr nc,.DivLoop ;23|21 
0ac2			;       inc e        ;-- 
0ac2			;       jp .DivLoop+1 
0ac2			; 
0ac2			;.DivLoopEnd: 
0ac2			 
0ac2			;HL_Div_C: 
0ac2			;Inputs: 
0ac2			;     HL is the numerator 
0ac2			;     C is the denominator 
0ac2			;Outputs: 
0ac2			;     A is the remainder 
0ac2			;     B is 0 
0ac2			;     C is not changed 
0ac2			;     DE is not changed 
0ac2			;     HL is the quotient 
0ac2			; 
0ac2			;       ld b,16 
0ac2			;       xor a 
0ac2			;         add hl,hl 
0ac2			;         rla 
0ac2			;         cp c 
0ac2			;         jr c,$+4 
0ac2			;           inc l 
0ac2			;           sub c 
0ac2			;         djnz $-7 
0ac2			 
0ac2			; https://plutiedev.com/z80-add-8bit-to-16bit 
0ac2			 
0ac2			addatohl: 
0ac2 85			    add   a, l    ; A = A+L 
0ac3 6f			    ld    l, a    ; L = A+L 
0ac4 8c			    adc   a, h    ; A = A+L+H+carry 
0ac5 95			    sub   l       ; A = H+carry 
0ac6 67			    ld    h, a    ; H = H+carry 
0ac7 c9			ret 
0ac8			 
0ac8			addatode: 
0ac8 83			    add   a, e    ; A = A+L 
0ac9 5f			    ld    e, a    ; L = A+L 
0aca 8a			    adc   a, d    ; A = A+L+H+carry 
0acb 93			    sub   e       ; A = H+carry 
0acc 57			    ld    d, a    ; H = H+carry 
0acd c9			ret 
0ace			 
0ace			 
0ace			addatobc: 
0ace 81			    add   a, c    ; A = A+L 
0acf 4f			    ld    c, a    ; L = A+L 
0ad0 88			    adc   a, b    ; A = A+L+H+carry 
0ad1 91			    sub   c       ; A = H+carry 
0ad2 47			    ld    b, a    ; H = H+carry 
0ad3 c9			ret 
0ad4			 
0ad4			subafromhl: 
0ad4			   ; If A=0 do nothing 
0ad4			    ; Otherwise flip A's sign. Since 
0ad4			    ; the upper byte becomes -1, also 
0ad4			    ; substract 1 from H. 
0ad4 ed 44		    neg 
0ad6 ca df 0a		    jp    z, Skip 
0ad9 25			    dec   h 
0ada			     
0ada			    ; Now add the low byte as usual 
0ada			    ; Two's complement takes care of 
0ada			    ; ensuring the result is correct 
0ada 85			    add   a, l 
0adb 6f			    ld    l, a 
0adc 8c			    adc   a, h 
0add 95			    sub   l 
0ade 67			    ld    h, a 
0adf			Skip: 
0adf c9				ret 
0ae0			 
0ae0			 
0ae0			; compare hl and de 
0ae0			; returns:  
0ae0			; if hl = de, z=1, s=0, c0=0 
0ae0			; if hl > de, z=0, s=0, c=0 
0ae0			; if hl < de, z=0, s=1, c=1 
0ae0			cmp16:	 
0ae0 b7				or a 
0ae1 ed 52			sbc hl,de 
0ae3 e0				ret po 
0ae4 7c				ld a,h 
0ae5 1f				rra 
0ae6 ee 40			xor 01000000B 
0ae8 37				scf 
0ae9 8f				adc a,a 
0aea c9				ret 
0aeb			 
0aeb			 
0aeb			; test if hl contains zero   - A is destroyed 
0aeb			 
0aeb			ishlzero:    
0aeb b7				or a     ; reset flags 
0aec 7c				ld a, h 
0aed b5				or l        	 
0aee			 
0aee c9				ret 
0aef			 
0aef			 
0aef			 
0aef			 
0aef			if FORTH_ENABLE_FLOATMATH 
0aef			;include "float/bbcmath.z80" 
0aef			include "float/lpfpcalc.asm" 
0aef			endif 
0aef			 
0aef			 
0aef			; eof 
0aef			 
# End of file firmware_maths.asm
0aef			include "firmware_strings.asm"   ; string handling  
0aef			 
0aef			 
0aef			; TODO string len 
0aef			; input text string, end on cr with zero term 
0aef			; a offset into frame buffer to start prompt 
0aef			; d is max length 
0aef			; e is display size TODO 
0aef			; c is current cursor position 
0aef			; hl is ptr to where string will be stored 
0aef			 
0aef			 
0aef			; TODO check limit of buffer for new inserts 
0aef			; TODO check insert does not push beyond buffer 
0aef			; TODO scroll in a limited display area 
0aef			; TODO scroll whole screen on page wrap 
0aef			 
0aef			 
0aef			; TODO handle KEY_PREVWORD 
0aef			; TODO handle KEY_NEXTWORD 
0aef			; TODO handle KEY_HOME 
0aef			; TODO handle KEY_END 
0aef			; TODO use LCD cursor? 
0aef			 
0aef 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0af2 81					add c 
0af3 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0af6 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0af9 79					ld a, c 
0afa cd c2 0a				call addatohl 
0afd 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0b00 7a					ld a,d 
0b01 32 75 ee			        ld (input_size), a       ; save length of input area 
0b04 79					ld a, c 
0b05 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0b08 7b					ld a,e 
0b09 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0b0c					 
0b0c					 
0b0c			 
0b0c			;		ld a,(input_ptr) 
0b0c			;		ld (input_under_cursor),a 	; save what is under the cursor 
0b0c			 
0b0c			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0b0c					; init cursor shape if not set by the cin routines 
0b0c 21 d3 eb				ld hl, cursor_shape 
0b0f 3e ff				ld a, 255 
0b11 77					ld (hl), a 
0b12 23					inc hl 
0b13 3e 00				ld a, 0 
0b15 77					ld (hl), a 
0b16			 
0b16 3e 0f				ld a, CUR_BLINK_RATE 
0b18 32 6f ee				ld (input_cur_flash), a 
0b1b 3e 01				ld a, 1 
0b1d 32 6e ee				ld (input_cur_onoff),a 
0b20			 
0b20			;	if DEBUG_INPUT 
0b20			;		push af 
0b20			;		ld a, 'I' 
0b20			;		ld (debug_mark),a 
0b20			;		pop af 
0b20			;		CALLMONITOR 
0b20			;	endif 
0b20			.is1:		; main entry loop 
0b20			 
0b20			 
0b20			 
0b20					; pause 1ms 
0b20			 
0b20 3e 01				ld a, 1 
0b22 cd c7 08				call aDelayInMS 
0b25			 
0b25					; dec flash counter 
0b25 3a 6f ee				ld a, (input_cur_flash) 
0b28 3d					dec a 
0b29 32 6f ee				ld (input_cur_flash), a 
0b2c fe 00				cp 0 
0b2e 20 0d				jr nz, .nochgstate 
0b30			 
0b30			 
0b30					; change state 
0b30 3a 6e ee				ld a,(input_cur_onoff) 
0b33 ed 44				neg 
0b35 32 6e ee				ld (input_cur_onoff),a 
0b38			 
0b38			 
0b38					; reset on change of state 
0b38 3e 0f				ld a, CUR_BLINK_RATE 
0b3a 32 6f ee				ld (input_cur_flash), a 
0b3d			 
0b3d			.nochgstate: 
0b3d					 
0b3d					 
0b3d			 
0b3d					; display cursor  
0b3d			 
0b3d			;		ld hl, (input_start) 
0b3d			;		ld a, (input_cursor) 
0b3d			;		call addatohl 
0b3d			 
0b3d					; get char under cursor and replace with cursor 
0b3d 2a 78 ee		ld hl, (input_ptr) 
0b40			;		ld a, (hl) 
0b40			;		ld (input_under_cursor),a 
0b40			;		ld a, '_' 
0b40			;		ld (hl), a 
0b40			 
0b40					; display string 
0b40			 
0b40 ed 5b 76 ee			ld de, (input_start) 
0b44 3a 73 ee				ld a, (input_at_pos) 
0b47 cd 7c 09				call str_at_display 
0b4a			;	        call update_display 
0b4a			 
0b4a					; find place to put the cursor 
0b4a			;		add h 
0b4a			;		ld l, display_row_1 
0b4a			;		sub l 
0b4a			; (input_at_pos) 
0b4a					;ld c, a 
0b4a			;		ld a, (input_cursor) 
0b4a			;		ld l, (input_at_pos) 
0b4a			;		;ld b, h 
0b4a			;		add l 
0b4a			;		ld (input_at_cursor),a 
0b4a					;ld l,h 
0b4a			 
0b4a			;		ld h, 0 
0b4a			;		ld l,(input_at_pos) 
0b4a			;		ld a, (input_cursor) 
0b4a			;		call addatohl 
0b4a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0b4a			;		call subafromhl 
0b4a			;		ld a,l 
0b4a			;		ld (input_at_cursor), a 
0b4a			 
0b4a				if DEBUG_INPUT 
0b4a					ld a, (hardware_diag) 
0b4a					cp 0 
0b4a					jr z, .skip_input_diag 
0b4a			 
0b4a					ld a,(input_at_pos) 
0b4a					ld hl, LFSRSeed 
0b4a					call hexout 
0b4a					ld a, (input_cursor) 
0b4a					ld hl, LFSRSeed+2 
0b4a					call hexout 
0b4a					ld a,(input_at_cursor) 
0b4a					ld hl, LFSRSeed+4 
0b4a					call hexout 
0b4a			 
0b4a					ld a,(input_cur_onoff) 
0b4a					ld hl, LFSRSeed+6 
0b4a					call hexout 
0b4a			 
0b4a					ld a,(input_cur_flash) 
0b4a					ld hl, LFSRSeed+8 
0b4a					call hexout 
0b4a			 
0b4a					ld a,(input_len) 
0b4a					ld hl, LFSRSeed+10 
0b4a					call hexout 
0b4a					ld hl, LFSRSeed+12 
0b4a					ld a, 0 
0b4a					ld (hl),a 
0b4a					ld a, display_row_4 
0b4a					ld de, LFSRSeed 
0b4a					call str_at_display 
0b4a					.skip_input_diag: 
0b4a				endif 
0b4a			 
0b4a					; decide on if we are showing the cursor this time round 
0b4a			 
0b4a 3a 6e ee				ld a, (input_cur_onoff) 
0b4d fe ff				cp 255 
0b4f 28 13				jr z, .skipcur 
0b51			 
0b51			 
0b51 3a 71 ee				ld a,(input_at_cursor) 
0b54 11 d3 eb				ld de, cursor_shape 
0b57 cd 7c 09				call str_at_display 
0b5a			 
0b5a					; save length of current input string 
0b5a 2a 76 ee				ld hl, (input_start) 
0b5d cd 20 0f				call strlenz 
0b60 7d					ld a,l 
0b61 32 69 ee				ld (input_len),a 
0b64			 
0b64			.skipcur: 
0b64			 
0b64 cd 8c 09			        call update_display 
0b67					 
0b67			 
0b67			 
0b67					; wait 
0b67				 
0b67					; TODO loop without wait to flash the cursor and char under cursor	 
0b67 cd fe 55				call cin    ; _wait 
0b6a			 
0b6a fe 00				cp 0 
0b6c ca 20 0b				jp z, .is1 
0b6f			 
0b6f					; get ptr to char to input into 
0b6f			 
0b6f 4f					ld c,a 
0b70 2a 76 ee				ld hl, (input_start) 
0b73 3a 64 ee				ld a, (input_cursor) 
0b76 cd c2 0a				call addatohl 
0b79 22 78 ee				ld (input_ptr), hl 
0b7c 79					ld a,c 
0b7d			 
0b7d					; replace char under cursor 
0b7d			 
0b7d			;		ld hl, (input_ptr) 
0b7d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0b7d			;		ld (hl), a 
0b7d			 
0b7d			;	if DEBUG_INPUT 
0b7d			;		push af 
0b7d			;		ld a, 'i' 
0b7d			;		ld (debug_mark),a 
0b7d			;		pop af 
0b7d			;		CALLMONITOR 
0b7d			;	endif 
0b7d fe 0e				cp KEY_HOME 
0b7f 20 0e				jr nz, .iske 
0b81			 
0b81 3a 73 ee				ld a, (input_at_pos) 
0b84 32 71 ee				ld (input_at_cursor),a 
0b87 3e 00				ld a, 0 
0b89 32 64 ee				ld (input_cursor), a 
0b8c c3 20 0b				jp .is1 
0b8f					 
0b8f fe 0f		.iske:		cp KEY_END 
0b91 20 03				jr nz, .isknw 
0b93 c3 20 0b				jp .is1 
0b96			 
0b96 fe 06		.isknw:		cp KEY_NEXTWORD 
0b98 20 1b				jr nz, .iskpw 
0b9a			 
0b9a 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0b9d 7e					ld a,(hl)	 
0b9e fe 00				cp 0 
0ba0 ca 20 0b				jp z, .is1    ; end of string 
0ba3 fe 20				cp ' ' 
0ba5 ca 20 0b				jp z, .is1    ; end of word 
0ba8 23					inc hl 
0ba9 22 78 ee				ld (input_ptr), hl 
0bac 3a 71 ee				ld a, (input_at_cursor) 
0baf 3c					inc a 
0bb0 32 71 ee				ld (input_at_cursor), a 
0bb3 18 e5				jr .isknwm 
0bb5			 
0bb5 fe 07		.iskpw:		cp KEY_PREVWORD 
0bb7 20 1b				jr nz, .iskl 
0bb9			.iskpwm:	 
0bb9 2a 78 ee				ld hl, (input_ptr) 
0bbc 7e					ld a,(hl)	 
0bbd fe 00				cp 0  
0bbf ca 20 0b				jp z, .is1    ; end of string 
0bc2 fe 20				cp ' ' 
0bc4 ca 20 0b				jp z, .is1    ; end of word 
0bc7 2b					dec hl 
0bc8 22 78 ee				ld (input_ptr), hl 
0bcb 3a 71 ee				ld a, (input_at_cursor) 
0bce 3d					dec a 
0bcf 32 71 ee				ld (input_at_cursor), a 
0bd2 18 e5				jr .iskpwm 
0bd4			 
0bd4			 
0bd4 fe 0b		.iskl:		cp KEY_LEFT 
0bd6 20 27				jr nz, .isk1 
0bd8			 
0bd8 3a 64 ee				ld a, (input_cursor) 
0bdb			 
0bdb fe 00				cp 0 
0bdd ca 20 0b				jp z, .is1 		; at start of line to ignore  
0be0			 
0be0 3d					dec  a 		; TODO check underflow 
0be1 32 64 ee				ld (input_cursor), a 
0be4			 
0be4 2a 78 ee				ld hl, (input_ptr) 
0be7 2b					dec hl 
0be8 22 78 ee				ld (input_ptr), hl 
0beb					 
0beb 3a 71 ee				ld a, (input_at_cursor) 
0bee 3d					dec a 
0bef 32 71 ee				ld (input_at_cursor), a 
0bf2			 
0bf2 3e 01				ld a, 1		; show cursor moving 
0bf4 32 6e ee				ld (input_cur_onoff),a 
0bf7 3e 0f				ld a, CUR_BLINK_RATE 
0bf9 32 6f ee				ld (input_cur_flash), a 
0bfc			 
0bfc c3 20 0b				jp .is1 
0bff			 
0bff fe 0c		.isk1:		cp KEY_RIGHT 
0c01 20 2a				jr nz, .isk2 
0c03			 
0c03 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0c06 5f					ld e,a 
0c07 3a 64 ee				ld a, (input_cursor) 
0c0a bb					cp e 
0c0b ca 20 0b				jp z, .is1		; at the end of string so dont go right 
0c0e			 
0c0e 3c					inc  a 		; TODO check overflow 
0c0f 32 64 ee				ld (input_cursor), a 
0c12			 
0c12 3a 71 ee				ld a, (input_at_cursor) 
0c15 3c					inc a 
0c16 32 71 ee				ld (input_at_cursor), a 
0c19			 
0c19 2a 78 ee				ld hl, (input_ptr) 
0c1c 23					inc hl 
0c1d 22 78 ee				ld (input_ptr), hl 
0c20			 
0c20 3e 01				ld a, 1		; show cursor moving 
0c22 32 6e ee				ld (input_cur_onoff),a 
0c25 3e 0f				ld a, CUR_BLINK_RATE 
0c27 32 6f ee				ld (input_cur_flash), a 
0c2a			 
0c2a c3 20 0b				jp .is1 
0c2d			 
0c2d fe 05		.isk2:		cp KEY_UP 
0c2f			 
0c2f 20 26				jr nz, .isk3 
0c31			 
0c31					; swap last command with the current on 
0c31			 
0c31					; move cursor to start of string 
0c31 2a 76 ee				ld hl, (input_start) 
0c34 22 78 ee				ld (input_ptr), hl 
0c37			 
0c37 3a 73 ee				ld a, (input_at_pos) 
0c3a 32 71 ee				ld (input_at_cursor), a 
0c3d			 
0c3d 3e 00				ld a, 0 
0c3f 32 64 ee				ld (input_cursor), a 
0c42					 
0c42					; swap input and last command buffers 
0c42			 
0c42 21 9c e6				ld hl, os_cli_cmd 
0c45 11 9b e7				ld de, os_last_cmd 
0c48 06 ff				ld b, 255 
0c4a 7e			.swap1:		ld a, (hl) 
0c4b 4f					ld c,a 
0c4c 1a					ld a, (de) 
0c4d 77					ld (hl), a 
0c4e 79					ld a,c 
0c4f 12					ld (de),a 
0c50 23					inc hl 
0c51 13					inc de 
0c52 10 f6				djnz .swap1 
0c54			 
0c54			 
0c54			 
0c54			 
0c54			 
0c54 c3 20 0b				jp .is1 
0c57			 
0c57 fe 08		.isk3:		cp KEY_BS 
0c59 20 3c				jr nz, .isk4 
0c5b			 
0c5b 3a 64 ee				ld a, (input_cursor) 
0c5e			 
0c5e fe 00				cp 0 
0c60 ca 20 0b				jp z, .is1 		; at start of line to ignore  
0c63			 
0c63 3d					dec  a 		; TODO check underflow 
0c64 32 64 ee				ld (input_cursor), a 
0c67			 
0c67					; hl is source 
0c67					; de needs to be source - 1 
0c67			 
0c67			;		ld a, 0 
0c67			;		dec hl 
0c67			;		ld (hl), a 
0c67			 
0c67 2a 78 ee				ld hl, (input_ptr) 
0c6a 2b					dec hl 
0c6b 22 78 ee				ld (input_ptr), hl 
0c6e			 
0c6e					; shift all data 
0c6e			 
0c6e e5					push hl 
0c6f 23					inc hl 
0c70 d1					pop de 
0c71 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0c74 4f					ld c,a 
0c75 06 00				ld b,0 
0c77 ed b0				ldir  
0c79			 
0c79			 
0c79			 
0c79			 
0c79 3a 71 ee				ld a, (input_at_cursor) 
0c7c 3d					dec a 
0c7d 32 71 ee				ld (input_at_cursor), a 
0c80			 
0c80			 
0c80 3e 01				ld a, 1		; show cursor moving 
0c82 32 6e ee				ld (input_cur_onoff),a 
0c85 3e 0f				ld a, CUR_BLINK_RATE 
0c87 32 6f ee				ld (input_cur_flash), a 
0c8a			 
0c8a					; remove char 
0c8a 3a 71 ee				ld a, (input_at_cursor) 
0c8d 3c					inc a 
0c8e 11 18 0d				ld de,.iblank 
0c91 cd 7c 09				call str_at_display 
0c94			 
0c94 c3 20 0b				jp .is1 
0c97			 
0c97 fe 0d		.isk4:		cp KEY_CR 
0c99 28 6c				jr z, .endinput 
0c9b			 
0c9b					; else add the key press to the end 
0c9b			 
0c9b 4f					ld c, a			; save key pressed 
0c9c			 
0c9c 7e					ld a,(hl)		; get what is currently under char 
0c9d			 
0c9d fe 00				cp 0			; we are at the end of the string 
0c9f 20 2f				jr nz, .onchar 
0ca1					 
0ca1					; add a char to the end of the string 
0ca1				 
0ca1 71					ld (hl),c 
0ca2 23					inc hl 
0ca3			;		ld a,' ' 
0ca3			;		ld (hl),a 
0ca3			;		inc hl 
0ca3 3e 00				ld a,0 
0ca5 77					ld (hl),a 
0ca6 2b					dec hl 
0ca7			 
0ca7 3a 64 ee				ld a, (input_cursor) 
0caa 3c					inc a				; TODO check max string length and scroll  
0cab 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0cae							 
0cae 3a 71 ee				ld a, (input_at_cursor) 
0cb1 3c					inc a 
0cb2 32 71 ee				ld (input_at_cursor), a 
0cb5			 
0cb5 2a 78 ee				ld hl, (input_ptr) 
0cb8 23					inc hl 
0cb9 22 78 ee				ld (input_ptr), hl 
0cbc			 
0cbc 2a 78 ee				ld hl, (input_ptr) 
0cbf 23					inc hl 
0cc0 22 78 ee				ld (input_ptr), hl 
0cc3			;	if DEBUG_INPUT 
0cc3			;		push af 
0cc3			;		ld a, '+' 
0cc3			;		ld (debug_mark),a 
0cc3			;		pop af 
0cc3			;		CALLMONITOR 
0cc3			;	endif 
0cc3 3e 01				ld a, 1		; show cursor moving 
0cc5 32 6e ee				ld (input_cur_onoff),a 
0cc8 3e 0f				ld a, CUR_BLINK_RATE 
0cca 32 6f ee				ld (input_cur_flash), a 
0ccd c3 20 0b				jp .is1 
0cd0					 
0cd0			 
0cd0			 
0cd0					; if on a char then insert 
0cd0			.onchar: 
0cd0			 
0cd0					; TODO over flow check: make sure insert does not blow out buffer 
0cd0			 
0cd0					; need to do some maths to use lddr 
0cd0			 
0cd0 e5					push hl   ; save char pos 
0cd1 c5					push bc 
0cd2			 
0cd2 2a 76 ee				ld hl, (input_start) 
0cd5 3a 69 ee				ld a, (input_len) 
0cd8 cd c2 0a				call addatohl  		; end of string 
0cdb 23					inc hl 
0cdc 23					inc hl		; past zero term 
0cdd e5					push hl 
0cde 23					inc hl 
0cdf e5					push hl  
0ce0			 
0ce0								; start and end of lddr set, now how much to move? 
0ce0			 
0ce0							 
0ce0 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ce3 47					ld b,a 
0ce4 3a 69 ee				ld a,(input_len) 
0ce7 5f					ld e,a 
0ce8 90					sub b 
0ce9 3c					inc a		;?? 
0cea 3c					inc a		;?? 
0ceb 3c					inc a		;?? 
0cec			 
0cec 06 00				ld b,0 
0cee 4f					ld c,a 
0cef			 
0cef				if DEBUG_INPUT 
0cef					push af 
0cef					ld a, 'i' 
0cef					ld (debug_mark),a 
0cef					pop af 
0cef			;		CALLMONITOR 
0cef				endif 
0cef d1					pop de 
0cf0 e1					pop hl 
0cf1				if DEBUG_INPUT 
0cf1					push af 
0cf1					ld a, 'I' 
0cf1					ld (debug_mark),a 
0cf1					pop af 
0cf1			;		CALLMONITOR 
0cf1				endif 
0cf1 ed b8				lddr 
0cf3				 
0cf3			 
0cf3			 
0cf3					; TODO have a key for insert/overwrite mode???? 
0cf3 c1					pop bc 
0cf4 e1					pop hl 
0cf5 71					ld (hl), c		; otherwise overwrite current char 
0cf6					 
0cf6			 
0cf6			 
0cf6			 
0cf6 3a 64 ee				ld a, (input_cursor) 
0cf9 3c					inc  a 		; TODO check overflow 
0cfa 32 64 ee				ld (input_cursor), a 
0cfd			 
0cfd 3a 71 ee				ld a, (input_at_cursor) 
0d00 3c					inc a 
0d01 32 71 ee				ld (input_at_cursor), a 
0d04			 
0d04 c3 20 0b				jp .is1 
0d07			 
0d07			.endinput:	; TODO look for end of string 
0d07			 
0d07					; add trailing space for end of token 
0d07			 
0d07 2a 76 ee				ld hl, (input_start) 
0d0a 3a 69 ee				ld a,(input_len) 
0d0d cd c2 0a				call addatohl 
0d10 3e 20				ld a, ' ' 
0d12 77					ld (hl),a 
0d13					; TODO eof of parse marker 
0d13			 
0d13 23					inc hl 
0d14 3e 00				ld a, 0 
0d16 77					ld (hl),a 
0d17			 
0d17			 
0d17 c9					ret 
0d18			 
0d18 .. 00		.iblank: db " ",0 
0d1a			 
0d1a			 
0d1a 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0d1d 22 76 ee				ld (input_start), hl 
0d20 3e 01				ld a,1			; add cursor 
0d22 77					ld (hl),a 
0d23 23					inc hl 
0d24 3e 00				ld a,0 
0d26 77					ld (hl),a 
0d27 22 78 ee				ld (input_ptr), hl 
0d2a 7a					ld a,d 
0d2b 32 75 ee				ld (input_size), a 
0d2e 3e 00				ld a,0 
0d30 32 64 ee				ld (input_cursor),a 
0d33			.instr1:	 
0d33			 
0d33					; TODO do block cursor 
0d33					; TODO switch cursor depending on the modifer key 
0d33			 
0d33					; update cursor shape change on key hold 
0d33			 
0d33 2a 78 ee				ld hl, (input_ptr) 
0d36 2b					dec hl 
0d37 3a d3 eb				ld a,(cursor_shape) 
0d3a 77					ld (hl), a 
0d3b			 
0d3b					; display entered text 
0d3b 3a 73 ee				ld a,(input_at_pos) 
0d3e cd 13 55		            	CALL fLCD_Pos       ;Position cursor to location in A 
0d41 ed 5b 76 ee	            	LD   de, (input_start) 
0d45 cd 08 55		            	CALL fLCD_Str       ;Display string pointed to by DE 
0d48			 
0d48 cd fe 55				call cin 
0d4b fe 00				cp 0 
0d4d 28 e4				jr z, .instr1 
0d4f			 
0d4f					; proecess keyboard controls first 
0d4f			 
0d4f 2a 78 ee				ld hl,(input_ptr) 
0d52			 
0d52 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0d54 28 5a				jr z, .instrcr 
0d56			 
0d56 fe 08				cp KEY_BS 	; back space 
0d58 20 0f				jr nz, .instr2 
0d5a					; process back space 
0d5a			 
0d5a					; TODO stop back space if at start of string 
0d5a 2b					dec hl 
0d5b 2b					dec hl ; to over write cursor 
0d5c 3a d3 eb				ld a,(cursor_shape) 
0d5f					;ld a,0 
0d5f 77					ld (hl),a 
0d60 23					inc hl 
0d61 3e 20				ld a," " 
0d63 77					ld (hl),a 
0d64 22 78 ee				ld (input_ptr),hl 
0d67					 
0d67			 
0d67 18 ca				jr .instr1 
0d69			 
0d69 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0d6b 20 06				jr nz, .instr3 
0d6d 2b					dec hl 
0d6e 22 78 ee				ld (input_ptr),hl 
0d71 18 c0				jr .instr1 
0d73				 
0d73 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0d75 20 06				jr nz, .instr4 
0d77 23					inc hl 
0d78 22 78 ee				ld (input_ptr),hl 
0d7b 18 b6				jr .instr1 
0d7d			 
0d7d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0d7f 20 06				jr nz, .instr5 
0d81 2b					dec hl 
0d82 22 78 ee				ld (input_ptr),hl 
0d85 18 ac				jr .instr1 
0d87			 
0d87 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0d89 20 06				jr nz, .instr6 
0d8b 2b					dec hl 
0d8c 22 78 ee				ld (input_ptr),hl 
0d8f 18 a2				jr .instr1 
0d91 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0d93 20 0b				jr nz, .instrnew 
0d95			 
0d95 21 75 e3			ld hl, scratch 
0d98 11 9b e7			ld de, os_last_cmd 
0d9b cd b9 0d			call strcpy 
0d9e 18 93				jr .instr1 
0da0			 
0da0			 
0da0			.instrnew:	; no special key pressed to see if we have room to store it 
0da0			 
0da0					; TODO do string size test 
0da0			 
0da0 2b					dec hl ; to over write cursor 
0da1 77					ld (hl),a 
0da2 23					inc hl 
0da3 3a d3 eb				ld a,(cursor_shape) 
0da6 77					ld (hl),a 
0da7 23					inc hl 
0da8 3e 00				ld a,0 
0daa 77					ld (hl),a 
0dab			 
0dab 22 78 ee				ld (input_ptr),hl 
0dae					 
0dae 18 83				jr .instr1 
0db0 2b			.instrcr:	dec hl		; remove cursor 
0db1 3e 20				ld a,' '	; TODO add a trailing space for safety 
0db3 77					ld (hl),a 
0db4 23					inc hl 
0db5 3e 00				ld a,0 
0db7 77					ld (hl),a 
0db8			 
0db8			 
0db8					; if at end of line scroll up    
0db8					; TODO detecting only end of line 4 for scroll up  
0db8			 
0db8					;ld   
0db8			 
0db8 c9					ret 
0db9			 
0db9			 
0db9			; strcpy hl = dest, de source 
0db9			 
0db9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0dba b7			            OR   A              ;Null terminator? 
0dbb c8			            RET  Z              ;Yes, so finished 
0dbc 1a					ld a,(de) 
0dbd 77					ld (hl),a 
0dbe 13			            INC  DE             ;Point to next character 
0dbf 23					inc hl 
0dc0 18 f7		            JR   strcpy       ;Repeat 
0dc2 c9					ret 
0dc3			 
0dc3			 
0dc3			; TODO string_at  
0dc3			; pass string which starts with lcd offset address and then null term string 
0dc3			 
0dc3			; TODO string to dec 
0dc3			; TODO string to hex 
0dc3			; TODO byte to string hex 
0dc3			; TODO byte to string dec 
0dc3			 
0dc3			 
0dc3			 
0dc3			; from z80uartmonitor 
0dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dc3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0dc3			; pass hl for where to put the text 
0dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dc3 c5			hexout:	PUSH BC 
0dc4 f5					PUSH AF 
0dc5 47					LD B, A 
0dc6					; Upper nybble 
0dc6 cb 3f				SRL A 
0dc8 cb 3f				SRL A 
0dca cb 3f				SRL A 
0dcc cb 3f				SRL A 
0dce cd de 0d				CALL tohex 
0dd1 77					ld (hl),a 
0dd2 23					inc hl	 
0dd3					 
0dd3					; Lower nybble 
0dd3 78					LD A, B 
0dd4 e6 0f				AND 0FH 
0dd6 cd de 0d				CALL tohex 
0dd9 77					ld (hl),a 
0dda 23					inc hl	 
0ddb					 
0ddb f1					POP AF 
0ddc c1					POP BC 
0ddd c9					RET 
0dde					 
0dde			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dde			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0dde			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dde			tohex: 
0dde e5					PUSH HL 
0ddf d5					PUSH DE 
0de0 16 00				LD D, 0 
0de2 5f					LD E, A 
0de3 21 eb 0d				LD HL, .DATA 
0de6 19					ADD HL, DE 
0de7 7e					LD A, (HL) 
0de8 d1					POP DE 
0de9 e1					POP HL 
0dea c9					RET 
0deb			 
0deb			.DATA: 
0deb 30					DEFB	30h	; 0 
0dec 31					DEFB	31h	; 1 
0ded 32					DEFB	32h	; 2 
0dee 33					DEFB	33h	; 3 
0def 34					DEFB	34h	; 4 
0df0 35					DEFB	35h	; 5 
0df1 36					DEFB	36h	; 6 
0df2 37					DEFB	37h	; 7 
0df3 38					DEFB	38h	; 8 
0df4 39					DEFB	39h	; 9 
0df5 41					DEFB	41h	; A 
0df6 42					DEFB	42h	; B 
0df7 43					DEFB	43h	; C 
0df8 44					DEFB	44h	; D 
0df9 45					DEFB	45h	; E 
0dfa 46					DEFB	46h	; F 
0dfb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0dfb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0dfb			;;    subtract $30, if result > 9 then subtract $7 more 
0dfb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0dfb			atohex: 
0dfb d6 30				SUB $30 
0dfd fe 0a				CP 10 
0dff f8					RET M		; If result negative it was 0-9 so we're done 
0e00 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0e02 c9					RET		 
0e03			 
0e03			 
0e03			 
0e03			 
0e03			; Get 2 ASCII characters as hex byte from pointer in hl 
0e03			 
0e03			BYTERD: 
0e03 16 00			LD	D,00h		;Set up 
0e05 cd 0d 0e			CALL	HEXCON		;Get byte and convert to hex 
0e08 87				ADD	A,A		;First nibble so 
0e09 87				ADD	A,A		;multiply by 16 
0e0a 87				ADD	A,A		; 
0e0b 87				ADD	A,A		; 
0e0c 57				LD	D,A		;Save hi nibble in D 
0e0d			HEXCON: 
0e0d 7e				ld a, (hl)		;Get next chr 
0e0e 23				inc hl 
0e0f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0e11 fe 0a			CP	00Ah		;Is it 0-9 ? 
0e13 38 02			JR	C,NALPHA	;If so miss next bit 
0e15 d6 07			SUB	007h		;Else convert alpha 
0e17			NALPHA: 
0e17 b2				OR	D		;Add hi nibble back 
0e18 c9				RET			; 
0e19			 
0e19			 
0e19			; 
0e19			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0e19			; Since the routines get_byte and therefore get_nibble are called, only valid 
0e19			; characters (0-9a-f) are accepted. 
0e19			; 
0e19			;get_word        push    af 
0e19			;                call    get_byte        ; Get the upper byte 
0e19			;                ld      h, a 
0e19			;                call    get_byte        ; Get the lower byte 
0e19			;                ld      l, a 
0e19			;                pop     af 
0e19			;                ret 
0e19			; 
0e19			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0e19			; the routine get_nibble is used only valid characters are accepted - the  
0e19			; input routine only accepts characters 0-9a-f. 
0e19			; 
0e19 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0e1a 7e					ld a,(hl) 
0e1b 23					inc hl 
0e1c cd 41 0e		                call    nibble2val      ; Get upper nibble 
0e1f cb 07		                rlc     a 
0e21 cb 07		                rlc     a 
0e23 cb 07		                rlc     a 
0e25 cb 07		                rlc     a 
0e27 47			                ld      b, a            ; Save upper four bits 
0e28 7e					ld a,(hl) 
0e29 cd 41 0e		                call    nibble2val      ; Get lower nibble 
0e2c b0			                or      b               ; Combine both nibbles 
0e2d c1			                pop     bc              ; Restore B (and C) 
0e2e c9			                ret 
0e2f			; 
0e2f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0e2f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0e2f			; to the serial line interface. The lower 4 bits of A contain the value of  
0e2f			; that particular digit. 
0e2f			; 
0e2f			;get_nibble      ld a,(hl)           ; Read a character 
0e2f			;                call    to_upper        ; Convert to upper case 
0e2f			;                call    is_hex          ; Was it a hex digit? 
0e2f			;                jr      nc, get_nibble  ; No, get another character 
0e2f			 ;               call    nibble2val      ; Convert nibble to value 
0e2f			 ;               call    print_nibble 
0e2f			 ;               ret 
0e2f			; 
0e2f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0e2f			; A valid hexadecimal digit is denoted by a set C flag. 
0e2f			; 
0e2f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0e2f			;                ret     nc              ; Yes 
0e2f			;                cp      '0'             ; Less than '0'? 
0e2f			;                jr      nc, is_hex_1    ; No, continue 
0e2f			;                ccf                     ; Complement carry (i.e. clear it) 
0e2f			;                ret 
0e2f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0e2f			;                ret     c               ; Yes 
0e2f			;                cp      'A'             ; Less than 'A'? 
0e2f			;                jr      nc, is_hex_2    ; No, continue 
0e2f			;                ccf                     ; Yes - clear carry and return 
0e2f			;                ret 
0e2f			;is_hex_2        scf                     ; Set carry 
0e2f			;                ret 
0e2f			; 
0e2f			; Convert a single character contained in A to upper case: 
0e2f			; 
0e2f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0e31 d8			                ret     c 
0e32 fe 7b		                cp      'z' + 1         ; > 'z'? 
0e34 d0			                ret     nc              ; Nothing to do, either 
0e35 e6 5f		                and     $5f             ; Convert to upper case 
0e37 c9			                ret 
0e38			 
0e38			 
0e38			to_lower: 
0e38			 
0e38			   ; if char is in [A-Z] make it lower case 
0e38			 
0e38			   ; enter : a = char 
0e38			   ; exit  : a = lower case char 
0e38			   ; uses  : af 
0e38			 
0e38 fe 41		   cp 'A' 
0e3a d8			   ret c 
0e3b			    
0e3b fe 5b		   cp 'Z'+1 
0e3d d0			   ret nc 
0e3e			    
0e3e f6 20		   or $20 
0e40 c9			   ret 
0e41			 
0e41			; 
0e41			; Expects a hexadecimal digit (upper case!) in A and returns the 
0e41			; corresponding value in A. 
0e41			; 
0e41 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0e43 38 02		                jr      c, nibble2val_1 ; Yes 
0e45 d6 07		                sub     7               ; Adjust for A-F 
0e47 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0e49 e6 0f		                and     $f              ; Only return lower 4 bits 
0e4b c9			                ret 
0e4c			; 
0e4c			; Print_nibble prints a single hex nibble which is contained in the lower  
0e4c			; four bits of A: 
0e4c			; 
0e4c			;print_nibble    push    af              ; We won't destroy the contents of A 
0e4c			;                and     $f              ; Just in case... 
0e4c			;                add     a, '0'             ; If we have a digit we are done here. 
0e4c			;                cp      '9' + 1         ; Is the result > 9? 
0e4c			;                jr      c, print_nibble_1 
0e4c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0e4c			;print_nibble_1  call    putc            ; Print the nibble and 
0e4c			;                pop     af              ; restore the original value of A 
0e4c			;                ret 
0e4c			;; 
0e4c			;; Send a CR/LF pair: 
0e4c			; 
0e4c			;crlf            push    af 
0e4c			;                ld      a, cr 
0e4c			;                call    putc 
0e4c			;                ld      a, lf 
0e4c			;                call    putc 
0e4c			;                pop     af 
0e4c			;                ret 
0e4c			; 
0e4c			; Print_word prints the four hex digits of a word to the serial line. The  
0e4c			; word is expected to be in HL. 
0e4c			; 
0e4c			;print_word      push    hl 
0e4c			;                push    af 
0e4c			;                ld      a, h 
0e4c			;                call    print_byte 
0e4c			;                ld      a, l 
0e4c			;                call    print_byte 
0e4c			;                pop     af 
0e4c			;                pop     hl 
0e4c			;                ret 
0e4c			; 
0e4c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0e4c			; The byte to be printed is expected to be in A. 
0e4c			; 
0e4c			;print_byte      push    af              ; Save the contents of the registers 
0e4c			;                push    bc 
0e4c			;                ld      b, a 
0e4c			;                rrca 
0e4c			;                rrca 
0e4c			;                rrca 
0e4c			;                rrca 
0e4c			;                call    print_nibble    ; Print high nibble 
0e4c			;                ld      a, b 
0e4c			;                call    print_nibble    ; Print low nibble 
0e4c			;                pop     bc              ; Restore original register contents 
0e4c			;                pop     af 
0e4c			;                ret 
0e4c			 
0e4c			 
0e4c			 
0e4c			 
0e4c			 
0e4c			fourehexhl:  
0e4c 7e				ld a,(hl) 
0e4d cd fb 0d			call atohex 
0e50 cb 3f				SRL A 
0e52 cb 3f				SRL A 
0e54 cb 3f				SRL A 
0e56 cb 3f				SRL A 
0e58 47				ld b, a 
0e59 23				inc hl 
0e5a 7e				ld a,(hl) 
0e5b 23				inc hl 
0e5c cd fb 0d			call atohex 
0e5f 80				add b 
0e60 57				ld d,a 
0e61 7e				ld a,(hl) 
0e62 cd fb 0d			call atohex 
0e65 cb 3f				SRL A 
0e67 cb 3f				SRL A 
0e69 cb 3f				SRL A 
0e6b cb 3f				SRL A 
0e6d 47				ld b, a 
0e6e 23				inc hl 
0e6f 7e				ld a,(hl) 
0e70 23				inc hl 
0e71 cd fb 0d			call atohex 
0e74 80				add b 
0e75 5f				ld e, a 
0e76 d5				push de 
0e77 e1				pop hl 
0e78 c9				ret 
0e79			 
0e79			; pass hl. returns z set if the byte at hl is a digit 
0e79			;isdigithl:  
0e79			;	push bc 
0e79			;	ld a,(hl) 
0e79			;	cp ':' 
0e79			;	jr nc, .isdf 		; > 
0e79			;	cp '0' 
0e79			;	jr c, .isdf		; < 
0e79			; 
0e79			;	; TODO find a better way to set z 
0e79			; 
0e79			;	ld b,a 
0e79			;	cp b 
0e79			;	pop bc 
0e79			;	ret 
0e79			; 
0e79			;.isdf:	; not digit so clear z 
0e79			; 
0e79			;	; TODO find a better way to unset z 
0e79			; 
0e79			;	ld b,a 
0e79			;	inc b 
0e79			;	cp b 
0e79			; 
0e79			;	pop bc 
0e79			;	ret 
0e79				 
0e79				 
0e79			 
0e79			 
0e79			; pass hl as the four byte address to load 
0e79			 
0e79			get_word_hl:  
0e79 e5				push hl 
0e7a cd 19 0e			call get_byte 
0e7d				 
0e7d 47				ld b, a 
0e7e			 
0e7e e1				pop hl 
0e7f 23				inc hl 
0e80 23				inc hl 
0e81			 
0e81			; TODO not able to handle a-f  
0e81 7e				ld a,(hl) 
0e82			;	;cp ':' 
0e82			;	cp 'g' 
0e82			;	jr nc, .single_byte_hl 		; > 
0e82			;	cp 'G' 
0e82			;	jr nc, .single_byte_hl 		; > 
0e82			;	cp '0' 
0e82			;	jr c, .single_byte_hl		; < 
0e82			 
0e82				;call isdigithl 
0e82 fe 00			cp 0 
0e84 28 06			jr z, .single_byte_hl 
0e86			 
0e86			.getwhln:   ; hex word so get next byte 
0e86			 
0e86 cd 19 0e			call get_byte 
0e89 6f				ld l, a 
0e8a 60				ld h,b 
0e8b c9				ret 
0e8c 68			.single_byte_hl:   ld l,b 
0e8d 26 00				ld h,0 
0e8f c9					ret 
0e90			 
0e90			 
0e90			 
0e90			 
0e90 21 37 15			ld hl,asc+1 
0e93			;	ld a, (hl) 
0e93			;	call nibble2val 
0e93 cd 19 0e			call get_byte 
0e96			 
0e96			;	call fourehexhl 
0e96 32 a9 e3			ld (scratch+52),a 
0e99				 
0e99 21 a7 e3			ld hl,scratch+50 
0e9c 22 98 e6			ld (os_cur_ptr),hl 
0e9f			 
0e9f c9				ret 
0ea0			 
0ea0			 
0ea0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0ea0			 
0ea0			; Decimal Unsigned Version 
0ea0			 
0ea0			;Number in a to decimal ASCII 
0ea0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0ea0			;Example: display a=56 as "056" 
0ea0			;input: a = number 
0ea0			;Output: a=0,value of a in the screen 
0ea0			;destroys af,bc (don't know about hl and de) 
0ea0			DispAToASCII: 
0ea0 0e 9c			ld	c,-100 
0ea2 cd ac 0e			call	.Na1 
0ea5 0e f6			ld	c,-10 
0ea7 cd ac 0e			call	.Na1 
0eaa 0e ff			ld	c,-1 
0eac 06 2f		.Na1:	ld	b,'0'-1 
0eae 04			.Na2:	inc	b 
0eaf 81				add	a,c 
0eb0 38 fc			jr	c,.Na2 
0eb2 91				sub	c		;works as add 100/10/1 
0eb3 f5				push af		;safer than ld c,a 
0eb4 78				ld	a,b		;char is in b 
0eb5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0eb5 f1				pop af		;safer than ld a,c 
0eb6 c9				ret 
0eb7			 
0eb7			; Decimal Signed Version 
0eb7			 
0eb7			; DispA 
0eb7			; -------------------------------------------------------------- 
0eb7			; Converts a signed integer value to a zero-terminated ASCII 
0eb7			; string representative of that value (using radix 10). 
0eb7			; -------------------------------------------------------------- 
0eb7			; INPUTS: 
0eb7			;     HL     Value to convert (two's complement integer). 
0eb7			;     DE     Base address of string destination. (pointer). 
0eb7			; -------------------------------------------------------------- 
0eb7			; OUTPUTS: 
0eb7			;     None 
0eb7			; -------------------------------------------------------------- 
0eb7			; REGISTERS/MEMORY DESTROYED 
0eb7			; AF HL 
0eb7			; -------------------------------------------------------------- 
0eb7			 
0eb7			;DispHLToASCII: 
0eb7			;   push    de 
0eb7			;   push    bc 
0eb7			; 
0eb7			;; Detect sign of HL. 
0eb7			;    bit    7, h 
0eb7			;    jr     z, ._DoConvert 
0eb7			; 
0eb7			;; HL is negative. Output '-' to string and negate HL. 
0eb7			;    ld     a, '-' 
0eb7			;    ld     (de), a 
0eb7			;    inc    de 
0eb7			; 
0eb7			;; Negate HL (using two's complement) 
0eb7			;    xor    a 
0eb7			;    sub    l 
0eb7			;    ld     l, a 
0eb7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0eb7			;    sbc    a, h 
0eb7			;    ld     h, a 
0eb7			; 
0eb7			;; Convert HL to digit characters 
0eb7			;._DoConvert: 
0eb7			;    ld     b, 0     ; B will count character length of number 
0eb7			;-   ld     a, 10 
0eb7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0eb7			;    push   af 
0eb7			;    inc    b 
0eb7			;    ld     a, h 
0eb7			;    or     l 
0eb7			;    jr     nz, - 
0eb7			; 
0eb7			;; Retrieve digits from stack 
0eb7			;-   pop    af 
0eb7			;    or     $30 
0eb7			;    ld     (de), a 
0eb7			;    inc    de 
0eb7			;    djnz   - 
0eb7			; 
0eb7			;; Terminate string with NULL 
0eb7			;    xor    a 
0eb7			;    ld     (de), a 
0eb7			; 
0eb7			;    pop    bc 
0eb7			;    pop    de 
0eb7			;    ret 
0eb7			 
0eb7			;Comments 
0eb7			; 
0eb7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0eb7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0eb7			;    Note that the output string will not be fixed-width. 
0eb7			; 
0eb7			;Example Usage 
0eb7			; 
0eb7			;    ld    hl, -1004 
0eb7			;    ld    de, OP1 
0eb7			;    call  DispA 
0eb7			;    ld    hl, OP1 
0eb7			;    syscall  PutS 
0eb7			 
0eb7			 
0eb7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0eb7			 
0eb7			 
0eb7			;Converts an ASCII string to an unsigned 16-bit integer 
0eb7			;Quits when it reaches a non-decimal digit 
0eb7			 
0eb7			string_to_uint16: 
0eb7			atoui_16: 
0eb7			;Input: 
0eb7			;     DE points to the string 
0eb7			;Outputs: 
0eb7			;     HL is the result 
0eb7			;     A is the 8-bit value of the number 
0eb7			;     DE points to the byte after the number 
0eb7			;Destroys: 
0eb7			;     BC 
0eb7			;       if the string is non-empty, BC is HL/10 
0eb7			;Size:  24 bytes 
0eb7			;Speed: 42+d(104+{0,9}) 
0eb7			;       d is the number of digits in the number 
0eb7			;       max is 640 cycles for a 5 digit number 
0eb7			;Assuming no leading zeros: 
0eb7			;1 digit:  146cc 
0eb7			;2 digit:  250cc 
0eb7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0eb7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0eb7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0eb7			;avg: 544.81158447265625cc (544+13297/16384) 
0eb7			;=============================================================== 
0eb7 21 00 00		  ld hl,0 
0eba			.u16a: 
0eba 1a			  ld a,(de) 
0ebb d6 30		  sub 30h 
0ebd fe 0a		  cp 10 
0ebf d0			  ret nc 
0ec0 13			  inc de 
0ec1 44			  ld b,h 
0ec2 4d			  ld c,l 
0ec3 29			  add hl,hl 
0ec4 29			  add hl,hl 
0ec5 09			  add hl,bc 
0ec6 29			  add hl,hl 
0ec7 85			  add a,l 
0ec8 6f			  ld l,a 
0ec9 30 ef		  jr nc,.u16a 
0ecb 24			  inc h 
0ecc c3 ba 0e		  jp .u16a 
0ecf			 
0ecf			 
0ecf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0ecf			 
0ecf			;written by Zeda 
0ecf			;Converts a 16-bit unsigned integer to an ASCII string. 
0ecf			 
0ecf			uitoa_16: 
0ecf			;Input: 
0ecf			;   DE is the number to convert 
0ecf			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0ecf			;Output: 
0ecf			;   HL points to the null-terminated ASCII string 
0ecf			;      NOTE: This isn't necessarily the same as the input HL. 
0ecf d5			  push de 
0ed0 c5			  push bc 
0ed1 f5			  push af 
0ed2 eb			  ex de,hl 
0ed3			 
0ed3 01 f0 d8		  ld bc,-10000 
0ed6 3e 2f		  ld a,'0'-1 
0ed8 3c			  inc a 
0ed9 09			  add hl,bc  
0eda 38 fc		   jr c,$-2 
0edc 12			  ld (de),a 
0edd 13			  inc de 
0ede			 
0ede 01 e8 03		  ld bc,1000 
0ee1 3e 3a		  ld a,'9'+1 
0ee3 3d			  dec a  
0ee4 09			  add hl,bc  
0ee5 30 fc		   jr nc,$-2 
0ee7 12			  ld (de),a 
0ee8 13			  inc de 
0ee9			 
0ee9 01 9c ff		  ld bc,-100 
0eec 3e 2f		  ld a,'0'-1 
0eee 3c			  inc a  
0eef 09			  add hl,bc  
0ef0 38 fc		   jr c,$-2 
0ef2 12			  ld (de),a 
0ef3 13			  inc de 
0ef4			 
0ef4 7d			  ld a,l 
0ef5 26 3a		  ld h,'9'+1 
0ef7 25			  dec h  
0ef8 c6 0a		  add a,10  
0efa 30 fb		   jr nc,$-3 
0efc c6 30		  add a,'0' 
0efe eb			  ex de,hl 
0eff 72			  ld (hl),d 
0f00 23			  inc hl 
0f01 77			  ld (hl),a 
0f02 23			  inc hl 
0f03 36 00		  ld (hl),0 
0f05			 
0f05			;Now strip the leading zeros 
0f05 0e fa		  ld c,-6 
0f07 09			  add hl,bc 
0f08 3e 30		  ld a,'0' 
0f0a 23			  inc hl  
0f0b be			  cp (hl)  
0f0c 28 fc		  jr z,$-2 
0f0e			 
0f0e			;Make sure that the string is non-empty! 
0f0e 7e			  ld a,(hl) 
0f0f b7			  or a 
0f10 20 01		  jr nz,.atoub 
0f12 2b			  dec hl 
0f13			.atoub: 
0f13			 
0f13 f1			  pop af 
0f14 c1			  pop bc 
0f15 d1			  pop de 
0f16 c9			  ret 
0f17			 
0f17			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
0f17			 
0f17			toUpper: 
0f17			;A is the char. 
0f17			;If A is a lowercase letter, this sets it to the matching uppercase 
0f17			;18cc or 30cc or 41cc 
0f17			;avg: 26.75cc 
0f17 fe 61		  cp 'a' 
0f19 d8			  ret c 
0f1a fe 7b		  cp 'z'+1 
0f1c d0			  ret nc 
0f1d d6 20		  sub 'a'-'A' 
0f1f c9			  ret 
0f20			 
0f20			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
0f20			 
0f20			; String Length 
0f20			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
0f20			 
0f20			; Get the length of the null-terminated string starting at $8000 hl 
0f20			;    LD     HL, $8000 
0f20			 
0f20			strlenz: 
0f20			 
0f20 af			    XOR    A               ; Zero is the value we are looking for. 
0f21 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
0f22 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
0f23			                           ; 65, 536 bytes (the entire addressable memory space). 
0f23 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f25			 
0f25			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f25 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
0f26 6f			    LD     L, A             ; number of bytes 
0f27 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f29 2b			    DEC    HL              ; Compensate for null. 
0f2a c9				ret 
0f2b			 
0f2b			; Get the length of the A terminated string starting at $8000 hl 
0f2b			;    LD     HL, $8000 
0f2b			 
0f2b			strlent: 
0f2b			 
0f2b			                  ; A is the value we are looking for. 
0f2b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
0f2d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
0f2f			                           ; 65, 536 bytes (the entire addressable memory space). 
0f2f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f31			 
0f31			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f31 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
0f33 2e 00		    LD     L, 0             ; number of bytes 
0f35 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f37 2b			    DEC    HL              ; Compensate for null. 
0f38 c9				ret 
0f39			 
0f39			 
0f39			;Comparing Strings 
0f39			 
0f39			;IN    HL     Address of string1. 
0f39			;      DE     Address of string2. 
0f39			 
0f39			; doc given but wrong??? 
0f39			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
0f39			;      carry  Set if string1 > string2, reset if string1 <= string2. 
0f39			; tested 
0f39			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
0f39			 
0f39			strcmp_old: 
0f39 e5			    PUSH   HL 
0f3a d5			    PUSH   DE 
0f3b			 
0f3b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
0f3c be			    CP     (HL)            ; (want to minimize work). 
0f3d 38 01		    JR     C, Str1IsBigger 
0f3f 7e			    LD     A, (HL) 
0f40			 
0f40			Str1IsBigger: 
0f40 4f			    LD     C, A             ; Put length in BC 
0f41 06 00		    LD     B, 0 
0f43 13			    INC    DE              ; Increment pointers to meat of string. 
0f44 23			    INC    HL 
0f45			 
0f45			CmpLoop: 
0f45 1a			    LD     A, (DE)          ; Compare bytes. 
0f46 ed a1		    CPI 
0f48 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
0f4a 13			    INC    DE              ; Update pointer. 
0f4b ea 45 0f		    JP     PE, CmpLoop 
0f4e			 
0f4e d1			    POP    DE 
0f4f e1			    POP    HL 
0f50 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
0f51 be			    CP     (HL) 
0f52 c9			    RET 
0f53			 
0f53			NoMatch: 
0f53 2b			    DEC    HL 
0f54 be			    CP     (HL)            ; Compare again to affect carry. 
0f55 d1			    POP    DE 
0f56 e1			    POP    HL 
0f57 c9			    RET 
0f58			 
0f58			;; test strmp 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str2 
0f58			;call strcmp 
0f58			;jr z, .z1 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "NZ1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.z1: 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "ZZ1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str1 
0f58			;call strcmp 
0f58			;jr z, .z2 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "NZ2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.z2: 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "ZZ2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str2 
0f58			;call strcmp 
0f58			;jr c, .c1 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "Nc1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.c1: 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "cc1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str1 
0f58			;call strcmp 
0f58			;jr c, .c2 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "Nc2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.c2: 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "cc2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;	NEXTW 
0f58			;.str1:   db "string1",0 
0f58			;.str2:   db "string2",0 
0f58			 
0f58			; only care about direct match or not 
0f58			; hl and de strings 
0f58			; zero set if the same 
0f58			 
0f58			strcmp: 
0f58 1a				ld a, (de) 
0f59 be				cp (hl) 
0f5a 28 02			jr z, .ssame 
0f5c b7				or a 
0f5d c9				ret 
0f5e			 
0f5e			.ssame:  
0f5e fe 00			cp 0 
0f60 c8				ret z 
0f61			 
0f61 23				inc hl 
0f62 13				inc de 
0f63 18 f3			jr strcmp 
0f65				 
0f65				 
0f65			 
0f65			 
0f65			 
0f65			 
0f65			; eof 
0f65			 
0f65			 
0f65			 
0f65			 
0f65			 
0f65			 
# End of file firmware_strings.asm
0f65			include "firmware_memory.asm"   ; malloc and free  
0f65			 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65			.mallocsize: db "Wants malloc >256",0 
0f65			.mallocasize: db "MALLOC gives >256",0 
0f65			.malloczero: db "MALLOC gives zero",0 
0f65			 
0f65			malloc_guard_zerolen: 
0f65				push hl 
0f65				push de 
0f65				push af 
0f65			 
0f65				ld de, 0 
0f65			        call cmp16 
0f65				jr nz, .lowalloz 
0f65			 
0f65				push hl 
0f65				push de 
0f65					ld hl, display_fb0 
0f65					ld (display_fb_active), hl 
0f65				call clear_display 
0f65				ld a, 0 
0f65				ld de, .malloczero 
0f65				call str_at_display 
0f65				call update_display 
0f65				call delay1s 
0f65				call delay1s 
0f65				ld a, 0 
0f65				ld (os_view_disable), a 
0f65			 
0f65				pop de 
0f65				pop hl 
0f65			 
0f65				 
0f65			 
0f65				CALLMONITOR 
0f65			.lowalloz: 
0f65			 
0f65			 
0f65				pop af 
0f65				pop de 
0f65				pop hl 
0f65			ret 
0f65			 
0f65			malloc_guard_entry: 
0f65				push hl 
0f65				push de 
0f65				push af 
0f65			 
0f65			 	or a      ;clear carry flag 
0f65				push hl 
0f65				ld de, 255 
0f65				sbc hl, de 
0f65				jr c, .lowalloc 
0f65			 
0f65				push de 
0f65					ld hl, display_fb0 
0f65					ld (display_fb_active), hl 
0f65				call clear_display 
0f65				ld a, 0 
0f65				ld de, .mallocsize 
0f65				call str_at_display 
0f65				call update_display 
0f65				call delay1s 
0f65				call delay1s 
0f65				ld a, 0 
0f65				ld (os_view_disable), a 
0f65			 
0f65				pop de 
0f65				pop hl 
0f65			 
0f65				 
0f65			 
0f65				CALLMONITOR 
0f65				jr .lowdone 
0f65			.lowalloc: 
0f65			 
0f65			 
0f65				pop hl 
0f65			.lowdone:	pop af 
0f65				pop de 
0f65				pop hl 
0f65			ret 
0f65			 
0f65			malloc_guard_exit: 
0f65				push hl 
0f65				push de 
0f65				push af 
0f65			 
0f65			 	or a      ;clear carry flag 
0f65				push hl 
0f65				ld de, 255 
0f65				sbc hl, de 
0f65				jr c, .lowallocx 
0f65			 
0f65				push de 
0f65					ld hl, display_fb0 
0f65					ld (display_fb_active), hl 
0f65				call clear_display 
0f65				ld a, 0 
0f65				ld de, .mallocasize 
0f65				call str_at_display 
0f65				call update_display 
0f65				call delay1s 
0f65				call delay1s 
0f65				ld a, 0 
0f65				ld (os_view_disable), a 
0f65				pop de 
0f65				pop hl 
0f65			 
0f65				CALLMONITOR 
0f65				jr .lowdonex 
0f65			.lowallocx: 
0f65			 
0f65				pop hl 
0f65			.lowdonex:	pop af 
0f65				pop de 
0f65				pop hl 
0f65			ret 
0f65			endif 
0f65			 
0f65			if MALLOC_2 
0f65			; Z80 Malloc and Free Functions 
0f65			 
0f65			; Malloc Function: 
0f65			; Input: 
0f65			;   HL: Size of block to allocate 
0f65			; Output: 
0f65			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0f65			 
0f65			malloc: 
0f65				 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65			call malloc_guard_entry 
0f65			endif 
0f65			 
0f65			 
0f65			 
0f65			 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "mal" 
0f65						CALLMONITOR 
0f65					endif 
0f65			    push af            ; Save AF register 
0f65			    ld a, l            ; Load low byte of size into A 
0f65			    or h               ; Check if size is zero 
0f65			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
0f65			 
0f65			    ; Allocate memory 
0f65			    ld hl, (heap_start) ; Load start of heap into HL 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "ma1" 
0f65						CALLMONITOR 
0f65					endif 
0f65			    call malloc_internal ; Call internal malloc function 
0f65			    pop af             ; Restore AF register 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret                ; Return 
0f65			 
0f65			; Free Function: 
0f65			; Input: 
0f65			;   HL: Pointer to memory block to free 
0f65			; Output: 
0f65			;   None 
0f65			 
0f65			free: 
0f65			    push af            ; Save AF register 
0f65			    ld a, l            ; Load low byte of pointer into A 
0f65			    or h               ; Check if pointer is NULL 
0f65			    jp z, free_exit    ; If pointer is NULL, exit 
0f65			 
0f65			    ; Free memory 
0f65			    ld hl, (heap_start) ; Load start of heap into HL 
0f65			    call free_internal  ; Call internal free function 
0f65			    pop af             ; Restore AF register 
0f65			    ret                ; Return 
0f65			 
0f65			; Internal Malloc Function: 
0f65			; Input: 
0f65			;   HL: Size of block to allocate 
0f65			; Output: 
0f65			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0f65			 
0f65			malloc_internal: 
0f65			    ld bc, 2           ; Number of bytes to allocate for management overhead 
0f65			    add hl, bc         ; Add management overhead to requested size 
0f65			    ex de, hl          ; Save total size in DE, and keep it in HL 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "ma2" 
0f65						CALLMONITOR 
0f65					endif 
0f65			 
0f65			    ; Search for free memory block 
0f65			    ld de, (heap_end)  ; Load end of heap into DE 
0f65			    ld bc, 0           ; Initialize counter 
0f65			 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "ma2" 
0f65						CALLMONITOR 
0f65					endif 
0f65			malloc_search_loop: 
0f65			    ; Check if current block is free 
0f65			    ld a, (hl)         ; Load current block's status (free or used) 
0f65			    cp 0               ; Compare with zero (free) 
0f65			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
0f65			 
0f65			    ; Check if current block is large enough 
0f65			    ld a, (hl+1)       ; Load high byte of block size 
0f65			    cp l               ; Compare with low byte of requested size 
0f65			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
0f65			 
0f65			    ld a, (hl+2)       ; Load low byte of block size 
0f65			    cp h               ; Compare with high byte of requested size 
0f65			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
0f65			 
0f65			    ; Mark block as used 
0f65			    ld (hl), 0xFF      ; Set status byte to indicate used block 
0f65			 
0f65			    ; Calculate remaining space in block 
0f65			    ld bc, 0           ; Clear BC 
0f65			    add hl, bc         ; Increment HL to point to start of data block 
0f65			    add hl, de         ; HL = HL + DE (total size) 
0f65			    ld bc, 1           ; Number of bytes to allocate for management overhead 
0f65			    add hl, bc         ; Add management overhead to start of data block 
0f65			 
0f65			    ; Save pointer to allocated block in HL 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65						DMARK "ma5" 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret 
0f65			 
0f65			malloc_skip_block_check: 
0f65			    ; Move to the next block 
0f65			    ld bc, 3           ; Size of management overhead 
0f65			    add hl, bc         ; Move to the next block 
0f65			    inc de             ; Increment counter 
0f65			 
0f65			    ; Check if we have reached the end of heap 
0f65			    ld a, e            ; Load low byte of heap end address 
0f65			    cp (hl)            ; Compare with low byte of current address 
0f65			    jr nz, malloc_search_loop  ; If not equal, continue searching 
0f65			    ld a, d            ; Load high byte of heap end address 
0f65			    cp 0               ; Check if it's zero (end of memory) 
0f65			    jr nz, malloc_search_loop  ; If not zero, continue searching 
0f65			 
0f65			    ; If we reached here, allocation failed 
0f65			    xor a              ; Set result to NULL 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65						DMARK "ma6" 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret 
0f65			malloc_exit: 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65						DMARK "ma7" 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret 
0f65			 
0f65			; Internal Free Function: 
0f65			; Input: 
0f65			;   HL: Pointer to memory block to free 
0f65			; Output: 
0f65			;   None 
0f65			 
0f65			free_internal: 
0f65			    ld de, (heap_start) ; Load start of heap into DE 
0f65			    ld bc, 0            ; Initialize counter 
0f65			 
0f65			free_search_loop: 
0f65			    ; Check if current block contains the pointer 
0f65			    ld a, l             ; Load low byte of pointer 
0f65			    cp (hl+1)           ; Compare with high byte of current block's address 
0f65			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0f65			    ld a, h             ; Load high byte of pointer 
0f65			    cp (hl+2)           ; Compare with low byte of current block's address 
0f65			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0f65			 
0f65			    ; Mark block as free 
0f65			    ld (hl), 0          ; Set status byte to indicate free block 
0f65			    ret                 ; Return 
0f65			 
0f65			free_skip_block_check: 
0f65			    ; Move to the next block 
0f65			    ld bc, 3            ; Size of management overhead 
0f65			    add hl, bc          ; Move to the next block 
0f65			    inc de              ; Increment counter 
0f65			 
0f65			    ; Check if we have reached the end of heap 
0f65			    ld a, e             ; Load low byte of heap end address 
0f65			    cp (hl)             ; Compare with low byte of current address 
0f65			    jr nz, free_search_loop  ; If not equal, continue searching 
0f65			    ld a, d             ; Load high byte of heap end address 
0f65			    cp 0                ; Check if it's zero (end of memory) 
0f65			    jr nz, free_search_loop  ; If not zero, continue searching 
0f65			 
0f65			    ; If we reached here, pointer is not found in heap 
0f65			    ret 
0f65			 
0f65			free_exit: 
0f65			    ret                 ; Return 
0f65			 
0f65			; Define heap start and end addresses 
0f65			;heap_start:    .dw 0xC000   ; Start of heap 
0f65			;heap_end:      .dw 0xE000   ; End of heap 
0f65			 
0f65			endif 
0f65			 
0f65			 
0f65			if MALLOC_1 
0f65			 
0f65			 
0f65			 
0f65			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
0f65			 
0f65			;moved to firmware.asm 
0f65			;heap_start        .equ  0x9000      ; Starting address of heap 
0f65			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
0f65			 
0f65			;      .org 0 
0f65			;      jp    main 
0f65			 
0f65			 
0f65			;      .org  0x100 
0f65			;main: 
0f65			;      ld    HL, 0x8100 
0f65			;      ld    SP, HL 
0f65			; 
0f65			;      call  heap_init 
0f65			; 
0f65			;      ; Make some allocations 
0f65			;      ld    HL, 12 
0f65			;      call  malloc            ; Allocates 0x9004 
0f65			; 
0f65			;      ld    HL, 12 
0f65			;      call  malloc            ; Allocates 0x9014 
0f65			; 
0f65			;      ld    HL, 12 
0f65			;      call  malloc            ; Allocates 0x9024 
0f65			; 
0f65			;      ; Free some allocations 
0f65			;      ld    HL, 0x9014 
0f65			;      call  free 
0f65			; 
0f65			;      ld    HL, 0x9004 
0f65			;      call  free 
0f65			; 
0f65			;      ld    HL, 0x9024 
0f65			;      call  free 
0f65			; 
0f65			; 
0f65			;      halt 
0f65			 
0f65			 
0f65			;------------------------------------------------------------------------------ 
0f65			;     heap_init                                                               : 
0f65			;                                                                             : 
0f65			; Description                                                                 : 
0f65			;     Initialise the heap and make it ready for malloc and free operations.   : 
0f65			;                                                                             : 
0f65			;     The heap is maintained as a linked list, starting with an initial       : 
0f65			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
0f65			;     the first free block in the heap. Each block then points to the next    : 
0f65			;     free block within the heap, and the free list ends at the first block   : 
0f65			;     with a null pointer to the next free block.                             : 
0f65			;                                                                             : 
0f65			; Parameters                                                                  : 
0f65			;     Inputs are compile-time only. Two defines which specify the starting    : 
0f65			;     address of the heap and its size are required, along with a memory      : 
0f65			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
0f65			;     principally stores a pointer to the first free block in the heap.       : 
0f65			;                                                                             : 
0f65			; Returns                                                                     : 
0f65			;     Nothing                                                                 : 
0f65			;------------------------------------------------------------------------------ 
0f65			heap_init: 
0f65 e5			      push  HL 
0f66			 
0f66			      ; Initialise free list struct 
0f66 21 26 56		      ld    HL, heap_start 
0f69 22 21 56		      ld    (free_list), HL 
0f6c 21 00 00		      ld    HL, 0 
0f6f 22 23 56		      ld    (free_list+2), HL 
0f72			 
0f72			      ; Insert first free block at bottom of heap, consumes entire heap 
0f72 21 65 e3		      ld    HL, heap_start+heap_size-4 
0f75 22 26 56		      ld    (heap_start), HL        ; Next block (end of free list) 
0f78 21 3f 8d		      ld    HL, heap_size-4 
0f7b 22 28 56		      ld    (heap_start+2), HL      ; Block size 
0f7e			 
0f7e			      ; Insert end of free list block at top of heap - two null words will 
0f7e			      ; terminate the free list 
0f7e 21 00 00		      ld    HL, 0 
0f81 22 67 e3		      ld    (heap_start+heap_size-2), HL 
0f84 22 65 e3		      ld    (heap_start+heap_size-4), HL 
0f87			 
0f87 e1			      pop   HL 
0f88			 
0f88 c9			      ret 
0f89			 
0f89			 
0f89			;------------------------------------------------------------------------------ 
0f89			;     malloc                                                                  : 
0f89			;                                                                             : 
0f89			; Description                                                                 : 
0f89			;     Allocates the wanted space from the heap and returns the address of the : 
0f89			;     first useable byte of the allocation.                                   : 
0f89			;                                                                             : 
0f89			;     Allocations can happen in one of two ways:                              : 
0f89			;                                                                             : 
0f89			;     1. A free block may be found which is the exact size wanted. In this    : 
0f89			;        case the block is removed from the free list and retuedn to the      : 
0f89			;        caller.                                                              : 
0f89			;     2. A free block may be found which is larger than the size wanted. In   : 
0f89			;        this case, the larger block is split into two. The first portion of  : 
0f89			;        this block will become the requested space by the malloc call and    : 
0f89			;        is returned to the caller. The second portion becomes a new free     : 
0f89			;        block, and the free list is adjusted to maintain continuity via this : 
0f89			;        newly created block.                                                 : 
0f89			;                                                                             : 
0f89			;     malloc does not set any initial value in the allocated space, the       : 
0f89			;     caller is required to do this as required.                              : 
0f89			;                                                                             : 
0f89			;     This implementation of malloc uses the stack exclusively, and is        : 
0f89			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
0f89			;     advisable to disable interrupts before calling malloc, and recommended  : 
0f89			;     to avoid the use of malloc inside ISRs in general.                      : 
0f89			;                                                                             : 
0f89			;     NOTE: heap_init must be called before malloc and free can be used.      : 
0f89			;                                                                             : 
0f89			; Parameters                                                                  : 
0f89			;     HL  Number of bytes wanted                                              : 
0f89			;                                                                             : 
0f89			; Returns                                                                     : 
0f89			;     HL  Address of the first useable byte of the allocation                 : 
0f89			;                                                                             : 
0f89			; Flags                                                                       : 
0f89			;     Z   Set if the allocation did not succeed, clear otherwise              : 
0f89			;                                                                             : 
0f89			; Stack frame                                                                 : 
0f89			;       |             |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |     BC      |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |     DE      |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |     IX      |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |  prev_free  |                                                       : 
0f89			;   +4  +-------------+                                                       : 
0f89			;       |  this_free  |                                                       : 
0f89			;   +2  +-------------+                                                       : 
0f89			;       |  next_free  |                                                       : 
0f89			;   +0  +-------------+                                                       : 
0f89			;       |             |                                                       : 
0f89			;                                                                             : 
0f89			;------------------------------------------------------------------------------ 
0f89			 
0f89			 
0f89			;malloc: 
0f89			; 
0f89			;	SAVESP ON 1 
0f89			; 
0f89			;	call malloc_code 
0f89			; 
0f89			;	CHECKSP ON 1 
0f89			;	ret 
0f89			 
0f89			 
0f89			malloc: 
0f89 c5			      push  BC 
0f8a d5			      push  DE 
0f8b dd e5		      push  IX 
0f8d			if DEBUG_FORTH_MALLOC_HIGH 
0f8d			call malloc_guard_entry 
0f8d			endif 
0f8d			 
0f8d					if DEBUG_FORTH_MALLOC 
0f8d						DMARK "mal" 
0f8d						CALLMONITOR 
0f8d					endif 
0f8d 7c			      ld    A, H                    ; Exit if no space requested 
0f8e b5			      or    L 
0f8f ca 4e 10		      jp    Z, malloc_early_exit 
0f92			 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			; 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			 
0f92			 
0f92			 
0f92			 
0f92					if DEBUG_FORTH_MALLOC 
0f92						DMARK "maA" 
0f92						CALLMONITOR 
0f92					endif 
0f92			      ; Set up stack frame 
0f92 eb			      ex    DE, HL 
0f93 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
0f96 39			      add   HL, SP 
0f97 f9			      ld    SP, HL 
0f98 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
0f9c dd 39		      add   IX, SP 
0f9e			 
0f9e			      ; Setup initial state 
0f9e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
0fa1 19			      add   HL, DE 
0fa2			 
0fa2 44			      ld    B, H                    ; Move want to BC 
0fa3 4d			      ld    C, L 
0fa4			 
0fa4 21 21 56		      ld    HL, free_list           ; Store prev_free ptr to stack 
0fa7 dd 75 04		      ld    (IX+4), L 
0faa dd 74 05		      ld    (IX+5), H 
0fad			 
0fad 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
0fae 23			      inc   HL 
0faf 56			      ld    D, (HL) 
0fb0 dd 73 02		      ld    (IX+2), E 
0fb3 dd 72 03		      ld    (IX+3), D 
0fb6 eb			      ex    DE, HL                  ; this_free ptr into HL 
0fb7			 
0fb7					if DEBUG_FORTH_MALLOC 
0fb7						DMARK "maB" 
0fb7						CALLMONITOR 
0fb7					endif 
0fb7			      ; Loop through free block list to find some space 
0fb7			malloc_find_space: 
0fb7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
0fb8 23			      inc   HL 
0fb9 56			      ld    D, (HL) 
0fba			 
0fba 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
0fbb b3			      or    E 
0fbc ca 48 10		      jp    Z, malloc_no_space 
0fbf			 
0fbf dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
0fc2 dd 72 01		      ld    (IX+1), D 
0fc5			 
0fc5			      ; Does this block have enough space to make the allocation? 
0fc5 23			      inc   HL                      ; Load free block size into DE 
0fc6 5e			      ld    E, (HL) 
0fc7 23			      inc   HL 
0fc8 56			      ld    D, (HL) 
0fc9			 
0fc9 eb			      ex    DE, HL                  ; Check size of block against want 
0fca b7			      or    A                       ; Ensure carry flag clear 
0fcb ed 42		      sbc   HL, BC 
0fcd e5			      push  HL                      ; Store the result for later (new block size) 
0fce			 
0fce ca 1d 10		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
0fd1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
0fd3			 
0fd3			      ; this_free block is not big enough, setup ptrs to test next free block 
0fd3 e1			      pop   HL                      ; Discard previous result 
0fd4			 
0fd4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
0fd7 dd 66 03		      ld    H, (IX+3) 
0fda dd 75 04		      ld    (IX+4), L 
0fdd dd 74 05		      ld    (IX+5), H 
0fe0			 
0fe0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
0fe3 dd 66 01		      ld    H, (IX+1) 
0fe6 dd 75 02		      ld    (IX+2), L 
0fe9 dd 74 03		      ld    (IX+3), H 
0fec			 
0fec					if DEBUG_FORTH_MALLOC 
0fec						DMARK "MA>" 
0fec						CALLMONITOR 
0fec					endif 
0fec 18 c9		      jr    malloc_find_space 
0fee			 
0fee			      ; split a bigger block into two - requested size and remaining size 
0fee			malloc_alloc_split: 
0fee					if DEBUG_FORTH_MALLOC 
0fee						DMARK "MAs" 
0fee						CALLMONITOR 
0fee					endif 
0fee eb			      ex    DE, HL                  ; Calculate address of new free block 
0fef 2b			      dec   HL 
0ff0 2b			      dec   HL 
0ff1 2b			      dec   HL 
0ff2 09			      add   HL, BC 
0ff3			 
0ff3			      ; Create a new block and point it at next_free 
0ff3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
0ff6 dd 56 01		      ld    D, (IX+1) 
0ff9			 
0ff9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
0ffa 23			      inc   HL 
0ffb 72			      ld    (HL), D 
0ffc			 
0ffc d1			      pop   DE                      ; Store size of new block into new block 
0ffd 23			      inc   HL 
0ffe 73			      ld    (HL), E 
0fff 23			      inc   HL 
1000 72			      ld    (HL), D 
1001			 
1001			      ; Update this_free ptr to point to new block 
1001 2b			      dec   HL 
1002 2b			      dec   HL 
1003 2b			      dec   HL 
1004			 
1004 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1007 dd 56 03		      ld    D, (IX+3) 
100a			 
100a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
100d dd 74 03		      ld    (IX+3), H 
1010			 
1010			      ; Modify this_free block to be allocation 
1010 eb			      ex    DE, HL 
1011 af			      xor   A                       ; Null the next block ptr of allocated block 
1012 77			      ld    (HL), A 
1013 23			      inc   HL 
1014 77			      ld    (HL), A 
1015			 
1015 23			      inc   HL                      ; Store want size into allocated block 
1016 71			      ld    (HL), C 
1017 23			      inc   HL 
1018 70			      ld    (HL), B 
1019 23			      inc   HL 
101a e5			      push  HL                      ; Address of allocation to return 
101b			 
101b 18 19		      jr    malloc_update_links 
101d			 
101d			malloc_alloc_fit: 
101d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
101e			 
101e					if DEBUG_FORTH_MALLOC 
101e						DMARK "MAf" 
101e						CALLMONITOR 
101e					endif 
101e			      ; Modify this_free block to be allocation 
101e eb			      ex    DE, HL 
101f 2b			      dec   HL 
1020 2b			      dec   HL 
1021 2b			      dec   HL 
1022			 
1022 af			      xor   A                       ; Null the next block ptr of allocated block 
1023 77			      ld    (HL), A 
1024 23			      inc   HL 
1025 77			      ld    (HL), A 
1026			 
1026 23			      inc   HL                      ; Store address of allocation to return 
1027 23			      inc   HL 
1028 23			      inc   HL 
1029 e5			      push  HL 
102a			 
102a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
102a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
102d dd 66 01		      ld    H, (IX+1) 
1030			 
1030 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1033 dd 74 03		      ld    (IX+3), H 
1036			 
1036			 
1036			malloc_update_links: 
1036			      ; Update prev_free ptr to point to this_free 
1036 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1039 dd 66 05		      ld    H, (IX+5) 
103c			 
103c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
103f dd 56 03		      ld    D, (IX+3) 
1042			 
1042 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1043 23			      inc   HL 
1044 72			      ld    (HL), D 
1045			 
1045					if DEBUG_FORTH_MALLOC 
1045						DMARK "Mul" 
1045						CALLMONITOR 
1045					endif 
1045			      ; Clear the Z flag to indicate successful allocation 
1045 7a			      ld    A, D 
1046 b3			      or    E 
1047			 
1047 d1			      pop   DE                      ; Address of allocation 
1048					if DEBUG_FORTH_MALLOC 
1048						DMARK "MAu" 
1048						CALLMONITOR 
1048					endif 
1048			 
1048			malloc_no_space: 
1048 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
104b 39			      add   HL, SP 
104c f9			      ld    SP, HL 
104d			 
104d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
104e					if DEBUG_FORTH_MALLOC 
104e						DMARK "MAN" 
104e						CALLMONITOR 
104e					endif 
104e			 
104e			malloc_early_exit: 
104e					if DEBUG_FORTH_MALLOC 
104e						DMARK "MAx" 
104e						CALLMONITOR 
104e					endif 
104e dd e1		      pop   IX 
1050 d1			      pop   DE 
1051 c1			      pop   BC 
1052			 
1052			if DEBUG_FORTH_MALLOC_HIGH 
1052			call malloc_guard_exit 
1052			call malloc_guard_zerolen 
1052			endif 
1052 c9			      ret 
1053			 
1053			 
1053			;------------------------------------------------------------------------------ 
1053			;     free                                                                    : 
1053			;                                                                             : 
1053			; Description                                                                 : 
1053			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1053			;     returned by malloc, otherwise the behaviour is undefined.               : 
1053			;                                                                             : 
1053			;     Where possible, directly adjacent free blocks will be merged together   : 
1053			;     into larger blocks to help ensure that the heap does not become         : 
1053			;     excessively fragmented.                                                 : 
1053			;                                                                             : 
1053			;     free does not clear or set any other value into the freed space, and    : 
1053			;     therefore its contents may be visible through subsequent malloc's. The  : 
1053			;     caller should clear the freed space as required.                        : 
1053			;                                                                             : 
1053			;     This implementation of free uses the stack exclusively, and is          : 
1053			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1053			;     advisable to disable interrupts before calling free, and recommended    : 
1053			;     to avoid the use of free inside ISRs in general.                        : 
1053			;                                                                             : 
1053			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1053			;                                                                             : 
1053			; Parameters                                                                  : 
1053			;     HL  Pointer to address of first byte of allocation to be freed          : 
1053			;                                                                             : 
1053			; Returns                                                                     : 
1053			;     Nothing                                                                 : 
1053			;                                                                             : 
1053			; Stack frame                                                                 : 
1053			;       |             |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |     BC      |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |     DE      |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |     IX      |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |  prev_free  |                                                       : 
1053			;   +2  +-------------+                                                       : 
1053			;       |  next_free  |                                                       : 
1053			;   +0  +-------------+                                                       : 
1053			;       |             |                                                       : 
1053			;                                                                             : 
1053			;------------------------------------------------------------------------------ 
1053			free: 
1053 c5			      push  BC 
1054 d5			      push  DE 
1055 dd e5		      push  IX 
1057			 
1057 7c			      ld    A, H                    ; Exit if ptr is null 
1058 b5			      or    L 
1059 ca 1d 11		      jp    Z, free_early_exit 
105c			 
105c			      ; Set up stack frame 
105c eb			      ex    DE, HL 
105d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1060 39			      add   HL, SP 
1061 f9			      ld    SP, HL 
1062 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1066 dd 39		      add   IX, SP 
1068			 
1068			      ; The address in HL points to the start of the useable allocated space, 
1068			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1068			      ; address of the block itself. 
1068 eb			      ex    DE, HL 
1069 11 fc ff		      ld    DE, -4 
106c 19			      add   HL, DE 
106d			 
106d			      ; An allocated block must have a null next block pointer in it 
106d 7e			      ld    A, (HL) 
106e 23			      inc   HL 
106f b6			      or    (HL) 
1070 c2 18 11		      jp    NZ, free_done 
1073			 
1073 2b			      dec   HL 
1074			 
1074 44			      ld    B, H                    ; Copy HL to BC 
1075 4d			      ld    C, L 
1076			 
1076			      ; Loop through the free list to find the first block with an address 
1076			      ; higher than the block being freed 
1076 21 21 56		      ld    HL, free_list 
1079			 
1079			free_find_higher_block: 
1079 5e			      ld    E, (HL)                 ; Load next ptr from free block 
107a 23			      inc   HL 
107b 56			      ld    D, (HL) 
107c 2b			      dec   HL 
107d			 
107d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1080 dd 72 01		      ld    (IX+1), D 
1083 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1086 dd 74 03		      ld    (IX+3), H 
1089			 
1089 78			      ld    A, B                    ; Check if DE is greater than BC 
108a ba			      cp    D                       ; Compare MSB first 
108b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
108d 30 04		      jr    NC, free_find_higher_block_skip 
108f 79			      ld    A, C 
1090 bb			      cp    E                       ; Then compare LSB 
1091 38 08		      jr    C, free_found_higher_block 
1093			 
1093			free_find_higher_block_skip: 
1093 7a			      ld    A, D                    ; Reached the end of the free list? 
1094 b3			      or    E 
1095 ca 18 11		      jp    Z, free_done 
1098			 
1098 eb			      ex    DE, HL 
1099			 
1099 18 de		      jr    free_find_higher_block 
109b			 
109b			free_found_higher_block: 
109b			      ; Insert freed block between prev and next free blocks 
109b 71			      ld    (HL), C                 ; Point prev free block to freed block 
109c 23			      inc   HL 
109d 70			      ld    (HL), B 
109e			 
109e 60			      ld    H, B                    ; Point freed block at next free block 
109f 69			      ld    L, C 
10a0 73			      ld    (HL), E 
10a1 23			      inc   HL 
10a2 72			      ld    (HL), D 
10a3			 
10a3			      ; Check if the freed block is adjacent to the next free block 
10a3 23			      inc   HL                      ; Load size of freed block into HL 
10a4 5e			      ld    E, (HL) 
10a5 23			      inc   HL 
10a6 56			      ld    D, (HL) 
10a7 eb			      ex    DE, HL 
10a8			 
10a8 09			      add   HL, BC                  ; Add addr of freed block and its size 
10a9			 
10a9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
10ac dd 56 01		      ld    D, (IX+1) 
10af			 
10af b7			      or    A                       ; Clear the carry flag 
10b0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
10b2 20 22		      jr    NZ, free_check_adjacent_to_prev 
10b4			 
10b4			      ; Freed block is adjacent to next, merge into one bigger block 
10b4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
10b5 5e			      ld    E, (HL) 
10b6 23			      inc   HL 
10b7 56			      ld    D, (HL) 
10b8 e5			      push  HL                      ; Save ptr to next block for later 
10b9			 
10b9 60			      ld    H, B                    ; Store ptr from next block into freed block 
10ba 69			      ld    L, C 
10bb 73			      ld    (HL), E 
10bc 23			      inc   HL 
10bd 72			      ld    (HL), D 
10be			 
10be e1			      pop   HL                      ; Restore ptr to next block 
10bf 23			      inc   HL                      ; Load size of next block into DE 
10c0 5e			      ld    E, (HL) 
10c1 23			      inc   HL 
10c2 56			      ld    D, (HL) 
10c3 d5			      push  DE                      ; Save next block size for later 
10c4			 
10c4 60			      ld    H, B                    ; Load size of freed block into HL 
10c5 69			      ld    L, C 
10c6 23			      inc   HL 
10c7 23			      inc   HL 
10c8 5e			      ld    E, (HL) 
10c9 23			      inc   HL 
10ca 56			      ld    D, (HL) 
10cb eb			      ex    DE, HL 
10cc			 
10cc d1			      pop   DE                      ; Restore size of next block 
10cd 19			      add   HL, DE                  ; Add sizes of both blocks 
10ce eb			      ex    DE, HL 
10cf			 
10cf 60			      ld    H, B                    ; Store new bigger size into freed block 
10d0 69			      ld    L, C 
10d1 23			      inc   HL 
10d2 23			      inc   HL 
10d3 73			      ld    (HL), E 
10d4 23			      inc   HL 
10d5 72			      ld    (HL), D 
10d6			 
10d6			free_check_adjacent_to_prev: 
10d6			      ; Check if the freed block is adjacent to the prev free block 
10d6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
10d9 dd 66 03		      ld    H, (IX+3) 
10dc			 
10dc 23			      inc   HL                      ; Size of prev free block into DE 
10dd 23			      inc   HL 
10de 5e			      ld    E, (HL) 
10df 23			      inc   HL 
10e0 56			      ld    D, (HL) 
10e1 2b			      dec   HL 
10e2 2b			      dec   HL 
10e3 2b			      dec   HL 
10e4			 
10e4 19			      add   HL, DE                  ; Add prev block addr and size 
10e5			 
10e5 b7			      or    A                       ; Clear the carry flag 
10e6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
10e8 20 2e		      jr    NZ, free_done 
10ea			 
10ea			      ; Freed block is adjacent to prev, merge into one bigger block 
10ea 60			      ld    H, B                    ; Load next ptr from freed block into DE 
10eb 69			      ld    L, C 
10ec 5e			      ld    E, (HL) 
10ed 23			      inc   HL 
10ee 56			      ld    D, (HL) 
10ef e5			      push  HL                      ; Save freed block ptr for later 
10f0			 
10f0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
10f3 dd 66 03		      ld    H, (IX+3) 
10f6 73			      ld    (HL), E 
10f7 23			      inc   HL 
10f8 72			      ld    (HL), D 
10f9			 
10f9 e1			      pop   HL                      ; Restore freed block ptr 
10fa 23			      inc   HL                      ; Load size of freed block into DE 
10fb 5e			      ld    E, (HL) 
10fc 23			      inc   HL 
10fd 56			      ld    D, (HL) 
10fe d5			      push  DE                      ; Save freed block size for later 
10ff			 
10ff dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1102 dd 66 03		      ld    H, (IX+3) 
1105 23			      inc   HL 
1106 23			      inc   HL 
1107 5e			      ld    E, (HL) 
1108 23			      inc   HL 
1109 56			      ld    D, (HL) 
110a			 
110a e1			      pop   HL                      ; Add sizes of both blocks 
110b 19			      add   HL, DE 
110c eb			      ex    DE, HL 
110d			 
110d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1110 dd 66 03		      ld    H, (IX+3) 
1113 23			      inc   HL 
1114 23			      inc   HL 
1115 73			      ld    (HL), E 
1116 23			      inc   HL 
1117 72			      ld    (HL), D 
1118			 
1118			free_done: 
1118 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
111b 39			      add   HL, SP 
111c f9			      ld    SP, HL 
111d			 
111d			free_early_exit: 
111d dd e1		      pop   IX 
111f d1			      pop   DE 
1120 c1			      pop   BC 
1121			 
1121 c9			      ret 
1122			 
1122			; moved to firmware.asm 
1122			; 
1122			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1122			;                  .dw   0 
1122			 
1122			 
1122			endif 
1122			 
1122			 
1122			if MALLOC_3 
1122			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1122			;heap_start        .equ  0x9000      ; Starting address of heap 
1122			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1122			; 
1122			 ;     .org 0 
1122			  ;    jp    main 
1122			; 
1122			; 
1122			 ;     .org  0x100 
1122			;main: 
1122			 ;     ld    HL, 0x8100 
1122			  ;    ld    SP, HL 
1122			; 
1122			;      call  heap_init 
1122			 
1122			      ; Make some allocations 
1122			;      ld    HL, 12 
1122			;      call  malloc            ; Allocates 0x9004 
1122			; 
1122			 ;     ld    HL, 12 
1122			;      call  malloc            ; Allocates 0x9014 
1122			 
1122			;      ld    HL, 12 
1122			;      call  malloc            ; Allocates 0x9024 
1122			 
1122			      ; Free some allocations 
1122			;      ld    HL, 0x9014 
1122			;      call  free 
1122			 
1122			;      ld    HL, 0x9004 
1122			;      call  free 
1122			; 
1122			;      ld    HL, 0x9024 
1122			;      call  free 
1122			 
1122			 
1122			 ;     halt 
1122			 
1122			 
1122			;------------------------------------------------------------------------------ 
1122			;     heap_init                                                               : 
1122			;                                                                             : 
1122			; Description                                                                 : 
1122			;     Initialise the heap and make it ready for malloc and free operations.   : 
1122			;                                                                             : 
1122			;     The heap is maintained as a linked list, starting with an initial       : 
1122			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1122			;     the first free block in the heap. Each block then points to the next    : 
1122			;     free block within the heap, and the free list ends at the first block   : 
1122			;     with a null pointer to the next free block.                             : 
1122			;                                                                             : 
1122			; Parameters                                                                  : 
1122			;     Inputs are compile-time only. Two defines which specify the starting    : 
1122			;     address of the heap and its size are required, along with a memory      : 
1122			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1122			;     principally stores a pointer to the first free block in the heap.       : 
1122			;                                                                             : 
1122			; Returns                                                                     : 
1122			;     Nothing                                                                 : 
1122			;------------------------------------------------------------------------------ 
1122			heap_init: 
1122			      push  HL 
1122			 
1122			      ; Initialise free list struct 
1122			      ld    HL, heap_start 
1122			      ld    (free_list), HL 
1122			      ld    HL, 0 
1122			      ld    (free_list+2), HL 
1122			 
1122			      ; Insert first free block at bottom of heap, consumes entire heap 
1122			      ld    HL, heap_start+heap_size-4 
1122			      ld    (heap_start), HL        ; Next block (end of free list) 
1122			      ld    HL, heap_size-4 
1122			      ld    (heap_start+2), HL      ; Block size 
1122			 
1122			      ; Insert end of free list block at top of heap - two null words will 
1122			      ; terminate the free list 
1122			      ld    HL, 0 
1122			      ld    (heap_start+heap_size-2), HL 
1122			      ld    (heap_start+heap_size-4), HL 
1122			 
1122			      pop   HL 
1122			 
1122			      ret 
1122			 
1122			 
1122			;------------------------------------------------------------------------------ 
1122			;     malloc                                                                  : 
1122			;                                                                             : 
1122			; Description                                                                 : 
1122			;     Allocates the wanted space from the heap and returns the address of the : 
1122			;     first useable byte of the allocation.                                   : 
1122			;                                                                             : 
1122			;     Allocations can happen in one of two ways:                              : 
1122			;                                                                             : 
1122			;     1. A free block may be found which is the exact size wanted. In this    : 
1122			;        case the block is removed from the free list and retuedn to the      : 
1122			;        caller.                                                              : 
1122			;     2. A free block may be found which is larger than the size wanted. In   : 
1122			;        this case, the larger block is split into two. The first portion of  : 
1122			;        this block will become the requested space by the malloc call and    : 
1122			;        is returned to the caller. The second portion becomes a new free     : 
1122			;        block, and the free list is adjusted to maintain continuity via this : 
1122			;        newly created block.                                                 : 
1122			;                                                                             : 
1122			;     malloc does not set any initial value in the allocated space, the       : 
1122			;     caller is required to do this as required.                              : 
1122			;                                                                             : 
1122			;     This implementation of malloc uses the stack exclusively, and is        : 
1122			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1122			;     advisable to disable interrupts before calling malloc, and recommended  : 
1122			;     to avoid the use of malloc inside ISRs in general.                      : 
1122			;                                                                             : 
1122			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1122			;                                                                             : 
1122			; Parameters                                                                  : 
1122			;     HL  Number of bytes wanted                                              : 
1122			;                                                                             : 
1122			; Returns                                                                     : 
1122			;     HL  Address of the first useable byte of the allocation                 : 
1122			;                                                                             : 
1122			; Flags                                                                       : 
1122			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1122			;                                                                             : 
1122			; Stack frame                                                                 : 
1122			;       |             |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     BC      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     DE      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     IX      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |  prev_free  |                                                       : 
1122			;   +4  +-------------+                                                       : 
1122			;       |  this_free  |                                                       : 
1122			;   +2  +-------------+                                                       : 
1122			;       |  next_free  |                                                       : 
1122			;   +0  +-------------+                                                       : 
1122			;       |             |                                                       : 
1122			;                                                                             : 
1122			;------------------------------------------------------------------------------ 
1122			malloc: 
1122			      push  BC 
1122			      push  DE 
1122			      push  IX 
1122			 
1122			      ld    A, H                    ; Exit if no space requested 
1122			      or    L 
1122			      jp    Z, malloc_early_exit 
1122			 
1122			      ; Set up stack frame 
1122			      ex    DE, HL 
1122			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			      ld    IX, 0                   ; Use IX as a frame pointer 
1122			      add   IX, SP 
1122			 
1122			      ; Setup initial state 
1122			      ld    HL, 4                   ; want must also include space used by block struct 
1122			      add   HL, DE 
1122			 
1122			      ld    B, H                    ; Move want to BC 
1122			      ld    C, L 
1122			 
1122			      ld    HL, free_list           ; Store prev_free ptr to stack 
1122			      ld    (IX+4), L 
1122			      ld    (IX+5), H 
1122			 
1122			      ld    E, (HL)                 ; Store this_free ptr to stack 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      ld    (IX+2), E 
1122			      ld    (IX+3), D 
1122			      ex    DE, HL                  ; this_free ptr into HL 
1122			 
1122			      ; Loop through free block list to find some space 
1122			malloc_find_space: 
1122			      ld    E, (HL)                 ; Load next_free ptr into DE 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			 
1122			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1122			      or    E 
1122			      jp    Z, malloc_no_space 
1122			 
1122			      ld    (IX+0), E               ; Store next_free ptr to stack 
1122			      ld    (IX+1), D 
1122			 
1122			      ; Does this block have enough space to make the allocation? 
1122			      inc   HL                      ; Load free block size into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			 
1122			      ex    DE, HL                  ; Check size of block against want 
1122			      or    A                       ; Ensure carry flag clear 
1122			      sbc   HL, BC 
1122			      push  HL                      ; Store the result for later (new block size) 
1122			 
1122			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1122			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1122			 
1122			      ; this_free block is not big enough, setup ptrs to test next free block 
1122			      pop   HL                      ; Discard previous result 
1122			 
1122			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1122			      ld    H, (IX+3) 
1122			      ld    (IX+4), L 
1122			      ld    (IX+5), H 
1122			 
1122			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1122			      ld    H, (IX+1) 
1122			      ld    (IX+2), L 
1122			      ld    (IX+3), H 
1122			 
1122			      jr    malloc_find_space 
1122			 
1122			      ; split a bigger block into two - requested size and remaining size 
1122			malloc_alloc_split: 
1122			      ex    DE, HL                  ; Calculate address of new free block 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			      add   HL, BC 
1122			 
1122			      ; Create a new block and point it at next_free 
1122			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1122			      ld    D, (IX+1) 
1122			 
1122			      ld    (HL), E                 ; Store next_free ptr into new block 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      pop   DE                      ; Store size of new block into new block 
1122			      inc   HL 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      ; Update this_free ptr to point to new block 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			 
1122			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1122			      ld    D, (IX+3) 
1122			 
1122			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1122			      ld    (IX+3), H 
1122			 
1122			      ; Modify this_free block to be allocation 
1122			      ex    DE, HL 
1122			      xor   A                       ; Null the next block ptr of allocated block 
1122			      ld    (HL), A 
1122			      inc   HL 
1122			      ld    (HL), A 
1122			 
1122			      inc   HL                      ; Store want size into allocated block 
1122			      ld    (HL), C 
1122			      inc   HL 
1122			      ld    (HL), B 
1122			      inc   HL 
1122			      push  HL                      ; Address of allocation to return 
1122			 
1122			      jr    malloc_update_links 
1122			 
1122			malloc_alloc_fit: 
1122			      pop   HL                      ; Dont need new block size, want is exact fit 
1122			 
1122			      ; Modify this_free block to be allocation 
1122			      ex    DE, HL 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			 
1122			      xor   A                       ; Null the next block ptr of allocated block 
1122			      ld    (HL), A 
1122			      inc   HL 
1122			      ld    (HL), A 
1122			 
1122			      inc   HL                      ; Store address of allocation to return 
1122			      inc   HL 
1122			      inc   HL 
1122			      push  HL 
1122			 
1122			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1122			      ld    L, (IX+0)               ; next_free to HL 
1122			      ld    H, (IX+1) 
1122			 
1122			      ld    (IX+2), L               ; HL to this_free 
1122			      ld    (IX+3), H 
1122			 
1122			 
1122			malloc_update_links: 
1122			      ; Update prev_free ptr to point to this_free 
1122			      ld    L, (IX+4)               ; prev_free ptr to HL 
1122			      ld    H, (IX+5) 
1122			 
1122			      ld    E, (IX+2)               ; this_free ptr to DE 
1122			      ld    D, (IX+3) 
1122			 
1122			      ld    (HL), E                 ; this_free ptr into prev_free 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      ; Clear the Z flag to indicate successful allocation 
1122			      ld    A, D 
1122			      or    E 
1122			 
1122			      pop   DE                      ; Address of allocation 
1122			 
1122			malloc_no_space: 
1122			      ld    HL, 6                   ; Clean up stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			 
1122			      ex    DE, HL                  ; Alloc addr into HL for return 
1122			 
1122			malloc_early_exit: 
1122			      pop   IX 
1122			      pop   DE 
1122			      pop   BC 
1122			 
1122			      ret 
1122			 
1122			 
1122			;------------------------------------------------------------------------------ 
1122			;     free                                                                    : 
1122			;                                                                             : 
1122			; Description                                                                 : 
1122			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1122			;     returned by malloc, otherwise the behaviour is undefined.               : 
1122			;                                                                             : 
1122			;     Where possible, directly adjacent free blocks will be merged together   : 
1122			;     into larger blocks to help ensure that the heap does not become         : 
1122			;     excessively fragmented.                                                 : 
1122			;                                                                             : 
1122			;     free does not clear or set any other value into the freed space, and    : 
1122			;     therefore its contents may be visible through subsequent malloc's. The  : 
1122			;     caller should clear the freed space as required.                        : 
1122			;                                                                             : 
1122			;     This implementation of free uses the stack exclusively, and is          : 
1122			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1122			;     advisable to disable interrupts before calling free, and recommended    : 
1122			;     to avoid the use of free inside ISRs in general.                        : 
1122			;                                                                             : 
1122			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1122			;                                                                             : 
1122			; Parameters                                                                  : 
1122			;     HL  Pointer to address of first byte of allocation to be freed          : 
1122			;                                                                             : 
1122			; Returns                                                                     : 
1122			;     Nothing                                                                 : 
1122			;                                                                             : 
1122			; Stack frame                                                                 : 
1122			;       |             |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     BC      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     DE      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     IX      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |  prev_free  |                                                       : 
1122			;   +2  +-------------+                                                       : 
1122			;       |  next_free  |                                                       : 
1122			;   +0  +-------------+                                                       : 
1122			;       |             |                                                       : 
1122			;                                                                             : 
1122			;------------------------------------------------------------------------------ 
1122			free: 
1122			      push  BC 
1122			      push  DE 
1122			      push  IX 
1122			 
1122			      ld    A, H                    ; Exit if ptr is null 
1122			      or    L 
1122			      jp    Z, free_early_exit 
1122			 
1122			      ; Set up stack frame 
1122			      ex    DE, HL 
1122			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			      ld    IX, 0                   ; Use IX as a frame pointer 
1122			      add   IX, SP 
1122			 
1122			      ; The address in HL points to the start of the useable allocated space, 
1122			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1122			      ; address of the block itself. 
1122			      ex    DE, HL 
1122			      ld    DE, -4 
1122			      add   HL, DE 
1122			 
1122			      ; An allocated block must have a null next block pointer in it 
1122			      ld    A, (HL) 
1122			      inc   HL 
1122			      or    (HL) 
1122			      jp    NZ, free_done 
1122			 
1122			      dec   HL 
1122			 
1122			      ld    B, H                    ; Copy HL to BC 
1122			      ld    C, L 
1122			 
1122			      ; Loop through the free list to find the first block with an address 
1122			      ; higher than the block being freed 
1122			      ld    HL, free_list 
1122			 
1122			free_find_higher_block: 
1122			      ld    E, (HL)                 ; Load next ptr from free block 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      dec   HL 
1122			 
1122			      ld    (IX+0), E               ; Save ptr to next free block 
1122			      ld    (IX+1), D 
1122			      ld    (IX+2), L               ; Save ptr to prev free block 
1122			      ld    (IX+3), H 
1122			 
1122			      ld    A, B                    ; Check if DE is greater than BC 
1122			      cp    D                       ; Compare MSB first 
1122			      jr    Z, $+4                  ; MSB the same, compare LSB 
1122			      jr    NC, free_find_higher_block_skip 
1122			      ld    A, C 
1122			      cp    E                       ; Then compare LSB 
1122			      jr    C, free_found_higher_block 
1122			 
1122			free_find_higher_block_skip: 
1122			      ld    A, D                    ; Reached the end of the free list? 
1122			      or    E 
1122			      jp    Z, free_done 
1122			 
1122			      ex    DE, HL 
1122			 
1122			      jr    free_find_higher_block 
1122			 
1122			free_found_higher_block: 
1122			      ; Insert freed block between prev and next free blocks 
1122			      ld    (HL), C                 ; Point prev free block to freed block 
1122			      inc   HL 
1122			      ld    (HL), B 
1122			 
1122			      ld    H, B                    ; Point freed block at next free block 
1122			      ld    L, C 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      ; Check if the freed block is adjacent to the next free block 
1122			      inc   HL                      ; Load size of freed block into HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      ex    DE, HL 
1122			 
1122			      add   HL, BC                  ; Add addr of freed block and its size 
1122			 
1122			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1122			      ld    D, (IX+1) 
1122			 
1122			      or    A                       ; Clear the carry flag 
1122			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1122			      jr    NZ, free_check_adjacent_to_prev 
1122			 
1122			      ; Freed block is adjacent to next, merge into one bigger block 
1122			      ex    DE, HL                  ; Load next ptr from next block into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  HL                      ; Save ptr to next block for later 
1122			 
1122			      ld    H, B                    ; Store ptr from next block into freed block 
1122			      ld    L, C 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      pop   HL                      ; Restore ptr to next block 
1122			      inc   HL                      ; Load size of next block into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  DE                      ; Save next block size for later 
1122			 
1122			      ld    H, B                    ; Load size of freed block into HL 
1122			      ld    L, C 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      ex    DE, HL 
1122			 
1122			      pop   DE                      ; Restore size of next block 
1122			      add   HL, DE                  ; Add sizes of both blocks 
1122			      ex    DE, HL 
1122			 
1122			      ld    H, B                    ; Store new bigger size into freed block 
1122			      ld    L, C 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			free_check_adjacent_to_prev: 
1122			      ; Check if the freed block is adjacent to the prev free block 
1122			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1122			      ld    H, (IX+3) 
1122			 
1122			      inc   HL                      ; Size of prev free block into DE 
1122			      inc   HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			 
1122			      add   HL, DE                  ; Add prev block addr and size 
1122			 
1122			      or    A                       ; Clear the carry flag 
1122			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1122			      jr    NZ, free_done 
1122			 
1122			      ; Freed block is adjacent to prev, merge into one bigger block 
1122			      ld    H, B                    ; Load next ptr from freed block into DE 
1122			      ld    L, C 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  HL                      ; Save freed block ptr for later 
1122			 
1122			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1122			      ld    H, (IX+3) 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      pop   HL                      ; Restore freed block ptr 
1122			      inc   HL                      ; Load size of freed block into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  DE                      ; Save freed block size for later 
1122			 
1122			      ld    L, (IX+2)               ; Load size of prev block into DE 
1122			      ld    H, (IX+3) 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			 
1122			      pop   HL                      ; Add sizes of both blocks 
1122			      add   HL, DE 
1122			      ex    DE, HL 
1122			 
1122			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1122			      ld    H, (IX+3) 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			free_done: 
1122			      ld    HL, 4                   ; Clean up stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			 
1122			free_early_exit: 
1122			      pop   IX 
1122			      pop   DE 
1122			      pop   BC 
1122			 
1122			      ret 
1122			 
1122			 
1122			;      .org 0x8000 
1122			; 
1122			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1122			 ;                 .dw   0 
1122			 
1122			endif 
1122			 
1122			 
1122			if MALLOC_4 
1122			 
1122			; My memory allocation code. Very very simple.... 
1122			; allocate space under 250 chars 
1122			 
1122			heap_init: 
1122				; init start of heap as zero 
1122				;  
1122			 
1122				ld hl, heap_start 
1122				ld a, 0 
1122				ld (hl), a      ; empty block 
1122				inc hl 
1122				ld a, 0 
1122				ld (hl), a      ; length of block 
1122				; write end of list 
1122				inc hl 
1122				ld a,(hl) 
1122				inc hl 
1122				ld a,(hl) 
1122				 
1122			 
1122				; init some malloc vars 
1122			 
1122				ld hl, 0 
1122				ld (free_list), hl       ; store last malloc location 
1122			 
1122				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1122				ld a, 0 
1122				ld (hl), a 
1122			 
1122			 
1122				ld hl, heap_start 
1122				;  
1122				  
1122				ret 
1122			 
1122			 
1122			;    free block marker 
1122			;    requested size  
1122			;    pointer to next block 
1122			;    .... 
1122			;    next block marker 
1122			 
1122			 
1122			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1122			; 
1122			 
1122			 
1122			malloc:  
1122				push de 
1122				push bc 
1122				push af 
1122			 
1122				; hl space required 
1122				 
1122				ld c, l    ; hold space   (TODO only a max of 255) 
1122			 
1122			;	inc c     ; TODO BUG need to fix memory leak on push str 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			 
1122			 
1122			 
1122				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1122			 
1122				ld a, (free_list+3) 
1122				cp 0 
1122				jr z, .contheap 
1122			 
1122				ld hl, (free_list)     ; get last alloc 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mrs" 
1122						CALLMONITOR 
1122					endif 
1122				jr .startalloc 
1122			 
1122			.contheap: 
1122				ld hl, heap_start 
1122			 
1122			.startalloc: 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mym" 
1122						CALLMONITOR 
1122					endif 
1122			.findblock: 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mmf" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122				ld a,(hl)  
1122				; if byte is zero then clear to use 
1122			 
1122				cp 0 
1122				jr z, .foundemptyblock 
1122			 
1122				; if byte is not clear 
1122				;     then byte is offset to next block 
1122			 
1122				inc hl 
1122				ld a, (hl) ; get size 
1122			.nextblock:	inc hl 
1122					ld e, (hl) 
1122					inc hl 
1122					ld d, (hl) 
1122					ex de, hl 
1122			;	inc hl  ; move past the store space 
1122			;	inc hl  ; move past zero index  
1122			 
1122				; TODO detect no more space 
1122			 
1122				push hl 
1122				ld de, heap_end 
1122				call cmp16 
1122				pop hl 
1122				jr nc, .nospace 
1122			 
1122				jr .findblock 
1122			 
1122			.nospace: ld hl, 0 
1122				jp .exit 
1122			 
1122			 
1122			.foundemptyblock:	 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mme" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			; TODO has block enough space if reusing??? 
1122			 
1122				;  
1122			 
1122			; see if this block has been previously used 
1122				inc hl 
1122				ld a, (hl) 
1122				dec hl 
1122				cp 0 
1122				jr z, .newblock 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "meR" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			; no reusing previously allocated block 
1122			 
1122			; is it smaller than previously used? 
1122				 
1122				inc hl    ; move to size 
1122				ld a, c 
1122				sub (hl)        ; we want c < (hl) 
1122				dec hl    ; move back to marker 
1122			        jr z, .findblock 
1122			 
1122				; update with the new size which should be lower 
1122			 
1122			        ;inc  hl   ; negate next move. move back to size  
1122			 
1122			.newblock: 
1122				; need to be at marker here 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "meN" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			 
1122				ld a, c 
1122			 
1122				ld (free_list+3), a	 ; flag resume from last malloc  
1122				ld (free_list), hl    ; save out last location 
1122			 
1122			 
1122				;inc a     ; space for length byte 
1122				ld (hl), a     ; save block in use marker 
1122			 
1122				inc hl   ; move to space marker 
1122				ld (hl), a    ; save new space 
1122			 
1122				inc hl   ; move to start of allocated area 
1122				 
1122			;	push hl     ; save where we are - 1  
1122			 
1122			;	inc hl  ; move past zero index  
1122				; skip space to set down new marker 
1122			 
1122				; provide some extra space for now 
1122			 
1122				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1122				inc a 
1122				inc a 
1122			 
1122				push hl   ; save where we are in the node block 
1122			 
1122				call addatohl 
1122			 
1122				; write linked list point 
1122			 
1122				pop de     ; get our node position 
1122				ex de, hl 
1122			 
1122				ld (hl), e 
1122				inc hl 
1122				ld (hl), d 
1122			 
1122				inc hl 
1122			 
1122				; now at start of allocated data so save pointer 
1122			 
1122				push hl 
1122			 
1122				; jump to position of next node and setup empty header in DE 
1122			 
1122				ex de, hl 
1122			 
1122			;	inc hl ; move past end of block 
1122			 
1122				ld a, 0 
1122				ld (hl), a   ; empty marker 
1122				inc hl 
1122				ld (hl), a   ; size 
1122				inc hl  
1122				ld (hl), a   ; ptr 
1122				inc hl 
1122				ld (hl), a   ; ptr 
1122			 
1122			 
1122				pop hl 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mmr" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			.exit: 
1122				pop af 
1122				pop bc 
1122				pop de  
1122				ret 
1122			 
1122			 
1122			 
1122			 
1122			free:  
1122				push hl 
1122				push af 
1122				; get address in hl 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "fre" 
1122						CALLMONITOR 
1122					endif 
1122				; data is at hl - move to block count 
1122				dec hl 
1122				dec hl    ; get past pointer 
1122				dec hl 
1122			 
1122				ld a, (hl)    ; need this for a validation check 
1122			 
1122				dec hl    ; move to block marker 
1122			 
1122				; now check that the block count and block marker are the same  
1122			        ; this checks that we are on a malloc node and not random memory 
1122			        ; OK a faint chance this could be a problem but rare - famous last words! 
1122			 
1122				ld c, a 
1122				ld a, (hl)    
1122			 
1122				cp c 
1122				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1122			 
1122				; yes good chance we are on a malloc node 
1122			 
1122				ld a, 0      
1122				ld (hl), a   ; mark as free 
1122			 
1122				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1122			 
1122			.freeignore:  
1122			 
1122				pop af 
1122				pop hl 
1122			 
1122				ret 
1122			 
1122			 
1122			 
1122			endif 
1122			 
1122			; eof 
# End of file firmware_memory.asm
1122			  
1122			; device C  
1122			if SOUND_ENABLE  
1122				include "firmware_sound.asm"  
1122			endif  
1122			  
1122			include "firmware_diags.asm"  
1122			; Hardware diags menu 
1122			 
1122			 
1122 .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1143 .. 00		hd_menu2:   db "        2: Editor",0   
1155			;hd_menu2:   db "        2: Editor       6: BASIC",0   
1155 .. 00		hd_menu3:   db "        3: Storage",0 
1168 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
1179 .. 00		hd_don:     db "ON",0 
117c .. 00		hd_doff:     db "OFF",0 
1180			 
1180			 
1180			 
1180			hardware_diags:       
1180			 
1180			.diagmenu: 
1180 cd 69 09			call clear_display 
1183 3e 00			ld a, display_row_1 
1185 11 22 11			ld de, hd_menu1 
1188 cd 7c 09			call str_at_display 
118b			 
118b 3e 28			ld a, display_row_2 
118d 11 43 11			ld de, hd_menu2 
1190 cd 7c 09			call str_at_display 
1193			 
1193 3e 50			ld a, display_row_3 
1195 11 55 11			ld de, hd_menu3 
1198 cd 7c 09			call str_at_display 
119b			 
119b 3e 78			ld a,  display_row_4 
119d 11 68 11			ld de, hd_menu4 
11a0 cd 7c 09			call str_at_display 
11a3			 
11a3				; display debug state 
11a3			 
11a3 11 79 11			ld de, hd_don 
11a6 3a 74 e3			ld a, (os_view_disable) 
11a9 fe 00			cp 0 
11ab 28 03			jr z, .distog 
11ad 11 7c 11			ld de, hd_doff 
11b0 3e 89		.distog: ld a, display_row_4+17 
11b2 cd 7c 09			call str_at_display 
11b5			 
11b5 cd 8c 09			call update_display 
11b8			 
11b8 cd f6 55			call cin_wait 
11bb			 
11bb			 
11bb			 
11bb fe 34			cp '4' 
11bd 20 0f			jr nz, .diagn1 
11bf			 
11bf				; debug toggle 
11bf			 
11bf 3a 74 e3			ld a, (os_view_disable) 
11c2 06 2a			ld b, '*' 
11c4 fe 00			cp 0 
11c6 28 02			jr z, .debtog 
11c8 06 00			ld b, 0 
11ca			.debtog:	 
11ca 78				ld a,b 
11cb 32 74 e3			ld (os_view_disable),a 
11ce			 
11ce fe 30		.diagn1: cp '0' 
11d0 c8				 ret z 
11d1			 
11d1			;	cp '1' 
11d1			;       jp z, matrix	 
11d1			;   TODO keyboard matrix test 
11d1			 
11d1 fe 32			cp '2' 
11d3 ca da 11			jp z, .diagedit 
11d6			 
11d6			;if ENABLE_BASIC 
11d6			;	cp '6' 
11d6			;	jp z, basic 
11d6			;endif 
11d6			  
11d6 c3 80 11			jp .diagmenu 
11d9			 
11d9			 
11d9 c9				ret 
11da			 
11da			; debug editor 
11da			 
11da			.diagedit: 
11da			 
11da 21 75 e3			ld hl, scratch 
11dd			;	ld bc, 250 
11dd			;	ldir 
11dd				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
11dd 3e 00			ld a, 0 
11df 77				ld (hl), a 
11e0 23				inc hl 
11e1 77				ld (hl), a 
11e2 23				inc hl 
11e3 77				ld (hl), a 
11e4			 
11e4 cd 69 09		        call clear_display 
11e7 cd 8c 09			call update_display 
11ea 3e 01			ld a, 1 
11ec 32 80 ee			ld (hardware_diag), a 
11ef			.diloop: 
11ef 3e 00			ld a, display_row_1 
11f1 0e 00			ld c, 0 
11f3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
11f5 1e 28			ld e, 40 
11f7			 
11f7 21 75 e3			ld hl, scratch	 
11fa cd ef 0a			call input_str 
11fd			 
11fd 3e 28			ld a, display_row_2 
11ff 11 75 e3			ld de, scratch 
1202 cd 7c 09			call str_at_display 
1205 cd 8c 09			call update_display 
1208			 
1208 c3 ef 11			jp .diloop 
120b			 
120b			 
120b			; pass word in hl 
120b			; a has display location 
120b			display_word_at: 
120b f5				push af 
120c e5				push hl 
120d 7c				ld a,h 
120e 21 7a e6			ld hl, os_word_scratch 
1211 cd c3 0d			call hexout 
1214 e1				pop hl 
1215 7d				ld a,l 
1216 21 7c e6			ld hl, os_word_scratch+2 
1219 cd c3 0d			call hexout 
121c 21 7e e6			ld hl, os_word_scratch+4 
121f 3e 00			ld a,0 
1221 77				ld (hl),a 
1222 11 7a e6			ld de,os_word_scratch 
1225 f1				pop af 
1226 cd 7c 09				call str_at_display 
1229 c9				ret 
122a			 
122a			display_ptr_state: 
122a			 
122a				; to restore afterwards 
122a			 
122a d5				push de 
122b c5				push bc 
122c e5				push hl 
122d f5				push af 
122e			 
122e				; for use in here 
122e			 
122e			;	push bc 
122e			;	push de 
122e			;	push hl 
122e			;	push af 
122e			 
122e cd 69 09			call clear_display 
1231			 
1231 11 04 14			ld de, .ptrstate 
1234 3e 00			ld a, display_row_1 
1236 cd 7c 09			call str_at_display 
1239			 
1239				; display debug step 
1239			 
1239			 
1239 11 7a ee			ld de, debug_mark 
123c 3e 26			ld a, display_row_1+display_cols-2 
123e cd 7c 09			call str_at_display 
1241			 
1241				; display a 
1241 11 0e 14			ld de, .ptrcliptr 
1244 3e 28			ld a, display_row_2 
1246 cd 7c 09			call str_at_display 
1249			 
1249 f1				pop af 
124a 2a 40 eb			ld hl,(cli_ptr) 
124d 3e 30			ld a, display_row_2+8 
124f cd 0b 12			call display_word_at 
1252			 
1252			 
1252				; display hl 
1252			 
1252			 
1252 11 16 14			ld de, .ptrclioptr 
1255 3e 32			ld a, display_row_2+10 
1257 cd 7c 09			call str_at_display 
125a			; 
125a			;	pop hl 
125a 3e 35			ld a, display_row_2+13 
125c 2a 3e eb			ld hl,(cli_origptr) 
125f cd 0b 12			call display_word_at 
1262			; 
1262			;	 
1262			;	; display de 
1262			 
1262			;	ld de, .regstatede 
1262			;	ld a, display_row_3 
1262			;	call str_at_display 
1262			 
1262			;	pop de 
1262			;	ld h,d 
1262			;	ld l, e 
1262			;	ld a, display_row_3+3 
1262			;	call display_word_at 
1262			 
1262			 
1262				; display bc 
1262			 
1262			;	ld de, .regstatebc 
1262			;	ld a, display_row_3+10 
1262			;	call str_at_display 
1262			 
1262			;	pop bc 
1262			;	ld h,b 
1262			;	ld l, c 
1262			;	ld a, display_row_3+13 
1262			;	call display_word_at 
1262			 
1262			 
1262				; display dsp 
1262			 
1262			;	ld de, .regstatedsp 
1262			;	ld a, display_row_4 
1262			;	call str_at_display 
1262			 
1262				 
1262			;	ld hl,(cli_data_sp) 
1262			;	ld a, display_row_4+4 
1262			;	call display_word_at 
1262			 
1262				; display rsp 
1262			 
1262 11 45 14			ld de, .regstatersp 
1265 3e 82			ld a, display_row_4+10 
1267 cd 7c 09			call str_at_display 
126a			 
126a				 
126a 2a 26 eb			ld hl,(cli_ret_sp) 
126d 3e 86			ld a, display_row_4+14 
126f cd 0b 12			call display_word_at 
1272			 
1272 cd 8c 09			call update_display 
1275			 
1275 cd e2 08			call delay1s 
1278 cd e2 08			call delay1s 
127b cd e2 08			call delay1s 
127e			 
127e			 
127e cd 98 17			call next_page_prompt 
1281			 
1281				; restore  
1281			 
1281 f1				pop af 
1282 e1				pop hl 
1283 c1				pop bc 
1284 d1				pop de 
1285 c9				ret 
1286			 
1286			break_point_state: 
1286 f5				push af 
1287			 
1287				; see if disabled 
1287			 
1287 3a 74 e3			ld a, (os_view_disable) 
128a fe 2a			cp '*' 
128c 20 02			jr nz, .bpsgo 
128e f1				pop af 
128f c9				ret 
1290			 
1290			.bpsgo: 
1290 f1				pop af 
1291 f5				push af 
1292 22 70 e3			ld (os_view_hl), hl 
1295 ed 53 6e e3		ld (os_view_de), de 
1299 ed 43 6c e3		ld (os_view_bc), bc 
129d e5				push hl 
129e 6f				ld l, a 
129f 26 00			ld h, 0 
12a1 22 72 e3			ld (os_view_af),hl 
12a4			 
12a4 21 c0 ed				ld hl, display_fb0 
12a7 22 db eb				ld (display_fb_active), hl 
12aa e1				pop hl	 
12ab			 
12ab 3e 31			ld a, '1' 
12ad fe 2a		.bps1:  cp '*' 
12af 20 03			jr nz, .bps1b 
12b1 32 74 e3			ld (os_view_disable),a 
12b4 fe 31		.bps1b:  cp '1' 
12b6 20 14			jr nz, .bps2 
12b8			 
12b8				; display reg 
12b8			 
12b8				 
12b8			 
12b8 3a 72 e3			ld a, (os_view_af) 
12bb 2a 70 e3			ld hl, (os_view_hl) 
12be ed 5b 6e e3		ld de, (os_view_de) 
12c2 ed 4b 6c e3		ld bc, (os_view_bc) 
12c6 cd 60 13			call display_reg_state 
12c9 c3 4c 13			jp .bpschk 
12cc			 
12cc fe 32		.bps2:  cp '2' 
12ce 20 08			jr nz, .bps3 
12d0				 
12d0				; display hl 
12d0 2a 70 e3			ld hl, (os_view_hl) 
12d3 cd 4a 14			call display_dump_at_hl 
12d6			 
12d6 18 74			jr .bpschk 
12d8			 
12d8 fe 33		.bps3:  cp '3' 
12da 20 08			jr nz, .bps4 
12dc			 
12dc			        ; display de 
12dc 2a 6e e3			ld hl, (os_view_de) 
12df cd 4a 14			call display_dump_at_hl 
12e2			 
12e2 18 68			jr .bpschk 
12e4 fe 34		.bps4:  cp '4' 
12e6 20 08			jr nz, .bps5 
12e8			 
12e8			        ; display bc 
12e8 2a 6c e3			ld hl, (os_view_bc) 
12eb cd 4a 14			call display_dump_at_hl 
12ee			 
12ee 18 5c			jr .bpschk 
12f0 fe 35		.bps5:  cp '5' 
12f2 20 08		        jr nz, .bps7 
12f4			 
12f4				; display cur ptr 
12f4 2a 40 eb			ld hl, (cli_ptr) 
12f7 cd 4a 14			call display_dump_at_hl 
12fa			 
12fa 18 50			jr .bpschk 
12fc fe 36		.bps7:  cp '6' 
12fe 20 08			jr nz, .bps8b 
1300				 
1300				; display cur orig ptr 
1300 2a 3e eb			ld hl, (cli_origptr) 
1303 cd 4a 14			call display_dump_at_hl 
1306 18 44			jr .bpschk 
1308 fe 37		.bps8b:  cp '7' 
130a 20 08			jr nz, .bps9 
130c				 
130c				; display dsp 
130c 2a 22 eb			ld hl, (cli_data_sp) 
130f cd 4a 14			call display_dump_at_hl 
1312			 
1312 18 38			jr .bpschk 
1314 fe 39		.bps9:  cp '9' 
1316 20 05			jr nz, .bps8c 
1318				 
1318				; display SP 
1318			;	ld hl, sp 
1318 cd 4a 14			call display_dump_at_hl 
131b			 
131b 18 2f			jr .bpschk 
131d fe 38		.bps8c:  cp '8' 
131f 20 08			jr nz, .bps8d 
1321				 
1321				; display rsp 
1321 2a 26 eb			ld hl, (cli_ret_sp) 
1324 cd 4a 14			call display_dump_at_hl 
1327			 
1327 18 23			jr .bpschk 
1329 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
132b 20 05			jr nz, .bps8 
132d cd 8e 15			call monitor 
1330			 
1330 18 1a			jr .bpschk 
1332 fe 30		.bps8:  cp '0' 
1334 20 16			jr nz, .bpschk 
1336			 
1336 21 1f ed				ld hl, display_fb1 
1339 22 db eb				ld (display_fb_active), hl 
133c cd 8c 09				call update_display 
133f			 
133f				;ld a, (os_view_af) 
133f 2a 70 e3			ld hl, (os_view_hl) 
1342 ed 5b 6e e3		ld de, (os_view_de) 
1346 ed 4b 6c e3		ld bc, (os_view_bc) 
134a f1				pop af 
134b c9				ret 
134c			 
134c			.bpschk:   
134c cd e2 08			call delay1s 
134f 3e 9f		ld a,display_row_4 + display_cols - 1 
1351 11 96 17		        ld de, endprg 
1354 cd 7c 09			call str_at_display 
1357 cd 8c 09			call update_display 
135a cd f6 55			call cin_wait 
135d			 
135d c3 ad 12			jp .bps1 
1360			 
1360			 
1360			display_reg_state: 
1360			 
1360				; to restore afterwards 
1360			 
1360 d5				push de 
1361 c5				push bc 
1362 e5				push hl 
1363 f5				push af 
1364			 
1364				; for use in here 
1364			 
1364 c5				push bc 
1365 d5				push de 
1366 e5				push hl 
1367 f5				push af 
1368			 
1368 cd 69 09			call clear_display 
136b			 
136b 11 20 14			ld de, .regstate 
136e 3e 00			ld a, display_row_1 
1370 cd 7c 09			call str_at_display 
1373			 
1373				; display debug step 
1373			 
1373			 
1373 11 7a ee			ld de, debug_mark 
1376 3e 25			ld a, display_row_1+display_cols-3 
1378 cd 7c 09			call str_at_display 
137b			 
137b				; display a 
137b 11 3c 14			ld de, .regstatea 
137e 3e 28			ld a, display_row_2 
1380 cd 7c 09			call str_at_display 
1383			 
1383 e1				pop hl 
1384			;	ld h,0 
1384			;	ld l, a 
1384 3e 2b			ld a, display_row_2+3 
1386 cd 0b 12			call display_word_at 
1389			 
1389			 
1389				; display hl 
1389			 
1389			 
1389 11 30 14			ld de, .regstatehl 
138c 3e 32			ld a, display_row_2+10 
138e cd 7c 09			call str_at_display 
1391			 
1391 e1				pop hl 
1392 3e 35			ld a, display_row_2+13 
1394 cd 0b 12			call display_word_at 
1397			 
1397				 
1397				; display de 
1397			 
1397 11 34 14			ld de, .regstatede 
139a 3e 50			ld a, display_row_3 
139c cd 7c 09			call str_at_display 
139f			 
139f e1				pop hl 
13a0			;	ld h,d 
13a0			;	ld l, e 
13a0 3e 53			ld a, display_row_3+3 
13a2 cd 0b 12			call display_word_at 
13a5			 
13a5			 
13a5				; display bc 
13a5			 
13a5 11 38 14			ld de, .regstatebc 
13a8 3e 5a			ld a, display_row_3+10 
13aa cd 7c 09			call str_at_display 
13ad			 
13ad e1				pop hl 
13ae			;	ld h,b 
13ae			;	ld l, c 
13ae 3e 5d			ld a, display_row_3+13 
13b0 cd 0b 12			call display_word_at 
13b3			 
13b3			 
13b3				; display dsp 
13b3			 
13b3 11 40 14			ld de, .regstatedsp 
13b6 3e 78			ld a, display_row_4 
13b8 cd 7c 09			call str_at_display 
13bb			 
13bb				 
13bb 2a 22 eb			ld hl,(cli_data_sp) 
13be 3e 7c			ld a, display_row_4+4 
13c0 cd 0b 12			call display_word_at 
13c3			 
13c3				; display rsp 
13c3			 
13c3 11 45 14			ld de, .regstatersp 
13c6 3e 82			ld a, display_row_4+10 
13c8 cd 7c 09			call str_at_display 
13cb			 
13cb				 
13cb 2a 26 eb			ld hl,(cli_ret_sp) 
13ce 3e 86			ld a, display_row_4+14 
13d0 cd 0b 12			call display_word_at 
13d3			 
13d3 cd 8c 09			call update_display 
13d6			 
13d6			;	call delay1s 
13d6			;	call delay1s 
13d6			;	call delay1s 
13d6			 
13d6			 
13d6			;	call next_page_prompt 
13d6			 
13d6				; restore  
13d6			 
13d6 f1				pop af 
13d7 e1				pop hl 
13d8 c1				pop bc 
13d9 d1				pop de 
13da c9				ret 
13db			 
13db .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
13ef .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1404 .. 00		.ptrstate:	db "Ptr State",0 
140e .. 00		.ptrcliptr:     db "cli_ptr",0 
1416 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1420 .. 00		.regstate:	db "Reg State (1/0)",0 
1430 .. 00		.regstatehl:	db "HL:",0 
1434 .. 00		.regstatede:	db "DE:",0 
1438 .. 00		.regstatebc:	db "BC:",0 
143c .. 00		.regstatea:	db "A :",0 
1440 .. 00		.regstatedsp:	db "DSP:",0 
1445 .. 00		.regstatersp:	db "RSP:",0 
144a			 
144a			display_dump_at_hl: 
144a e5				push hl 
144b d5				push de 
144c c5				push bc 
144d f5				push af 
144e			 
144e 22 98 e6			ld (os_cur_ptr),hl	 
1451 cd 69 09			call clear_display 
1454 cd a0 16			call dumpcont 
1457			;	call delay1s 
1457			;	call next_page_prompt 
1457			 
1457			 
1457 f1				pop af 
1458 c1				pop bc 
1459 d1				pop de 
145a e1				pop hl 
145b c9				ret 
145c			 
145c			;if ENABLE_BASIC 
145c			;	include "nascombasic.asm" 
145c			;	basic: 
145c			;	include "forth/FORTH.ASM" 
145c			;endif 
145c			 
145c			; eof 
145c			 
145c			 
# End of file firmware_diags.asm
145c			  
145c			  
145c			  
145c			  
145c			; eof  
145c			  
# End of file firmware.asm
145c			 
145c			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
145c			;if BASE_KEV  
145c			;baseram: equ 08000h 
145c			;endif 
145c			 
145c			;if BASE_SC114 
145c			;baseram:     equ    endofcode 
145c			;endif 
145c			 
145c			 
145c			; start system 
145c			 
145c			coldstart: 
145c				; set sp 
145c				; di/ei 
145c			 
145c f3				di 
145d 31 00 f0			ld sp, tos 
1460			;	ei 
1460			 
1460			 
1460				; disable breakpoint by default 
1460			 
1460 3e 2a			ld a,'*' 
1462 32 74 e3			ld (os_view_disable),a 
1465			 
1465				; init hardware 
1465			 
1465				; init keyboard and screen hardware 
1465			 
1465 cd 03 01			call hardware_init 
1468			 
1468			 
1468				; detect if any keys are held down to enable breakpoints at start up 
1468			 
1468 cd fe 55			call cin  
146b fe 00			cp 0 
146d 28 03			jr z, .nokeys 
146f			 
146f cd 80 11			call hardware_diags 
1472			 
1472			;	ld de, .bpen 
1472			;	ld a, display_row_4 
1472			;	call str_at_display 
1472			;	call update_display 
1472			; 
1472			;	ld a,0 
1472			;	ld (os_view_disable),a 
1472			; 
1472			;.bpwait: 
1472			;	call cin 
1472			;	cp 0 
1472			;	jr z, .bpwait 
1472			;	jr .nokeys 
1472			; 
1472			; 
1472			;.bpen:  db "Break points enabled!",0 
1472			 
1472			 
1472			 
1472			 
1472			 
1472			 
1472			.nokeys: 
1472			 
1472			 
1472				 
1472			 
1472			;jp  testkey 
1472			 
1472			;call storage_get_block_0 
1472			; 
1472			;ld hl, 0 
1472			;ld de, store_page 
1472			;call storage_read_block 
1472			 
1472				 
1472			;ld hl, 10 
1472			;ld de, store_page 
1472			;call storage_read_block 
1472			 
1472			 
1472			 
1472			 
1472			 
1472			;stop:	nop 
1472			;	jp stop 
1472			 
1472			 
1472			 
1472			main: 
1472 cd 69 09			call clear_display 
1475 cd 8c 09			call update_display 
1478			 
1478			 
1478			 
1478			;	call testlcd 
1478			 
1478			 
1478			 
1478 cd e6 19			call forth_init 
147b			 
147b			 
147b			warmstart: 
147b cd bc 19			call forth_warmstart 
147e			 
147e				; run startup word load 
147e			        ; TODO prevent this running at warmstart after crash  
147e			 
147e				if STARTUP_ENABLE 
147e cd 44 52				call forth_startup 
1481				endif 
1481			 
1481				; show free memory after boot 
1481 11 28 15			ld de, freeram 
1484 3e 00			ld a, display_row_1 
1486 cd 7c 09			call str_at_display 
1489			 
1489			; Or use heap_size word???? 
1489 21 69 e3			ld hl, heap_end 
148c 11 26 56			ld de, heap_start 
148f ed 52			sbc hl, de 
1491 e5				push hl 
1492 7c				ld a,h	         	 
1493 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1496 cd c3 0d			call hexout 
1499 e1			   	pop hl 
149a			 
149a 7d				ld a,l 
149b 21 7c e6			ld hl, os_word_scratch+2 
149e cd c3 0d			call hexout 
14a1 21 7e e6			ld hl, os_word_scratch+4 
14a4 3e 00			ld a, 0 
14a6 77				ld (hl),a 
14a7 11 7a e6			ld de, os_word_scratch 
14aa 3e 0d			ld a, display_row_1 + 13 
14ac cd 7c 09			call str_at_display 
14af cd 8c 09			call update_display 
14b2			 
14b2			 
14b2				;call demo 
14b2			 
14b2			 
14b2				; init scratch input area for cli commands 
14b2			 
14b2 21 9c e6			ld hl, os_cli_cmd 
14b5 3e 00			ld a,0 
14b7 77				ld (hl),a 
14b8 23				inc hl 
14b9 77				ld (hl),a 
14ba			 
14ba 3e 00			ld a,0 
14bc 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
14bf			 
14bf 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
14c2 32 99 e6			ld (os_cur_ptr+1),a	 
14c5			 
14c5 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
14c8 32 7b e6			ld (os_word_scratch+1),a	 
14cb				 
14cb			 
14cb				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
14cb 21 9c e6			ld hl, os_cli_cmd 
14ce			 
14ce 3e 00			ld a, 0		 ; init cli input 
14d0 77				ld (hl), a 
14d1 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
14d3			cli: 
14d3				; show cli prompt 
14d3				;push af 
14d3				;ld a, 0 
14d3				;ld de, prompt 
14d3				;call str_at_display 
14d3			 
14d3				;call update_display 
14d3				;pop af 
14d3				;inc a 
14d3				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
14d3 0e 00			ld c, 0 
14d5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
14d7 1e 28			ld e, 40 
14d9			 
14d9 21 9c e6			ld hl, os_cli_cmd 
14dc			 
14dc				STACKFRAME OFF $fefe $9f9f 
14dc				if DEBUG_STACK_IMB 
14dc					if OFF 
14dc						exx 
14dc						ld de, $fefe 
14dc						ld a, d 
14dc						ld hl, curframe 
14dc						call hexout 
14dc						ld a, e 
14dc						ld hl, curframe+2 
14dc						call hexout 
14dc						ld hl, $fefe 
14dc						push hl 
14dc						ld hl, $9f9f 
14dc						push hl 
14dc						exx 
14dc					endif 
14dc				endif 
14dc			endm 
# End of macro STACKFRAME
14dc			 
14dc cd ef 0a			call input_str 
14df			 
14df				STACKFRAMECHK OFF $fefe $9f9f 
14df				if DEBUG_STACK_IMB 
14df					if OFF 
14df						exx 
14df						ld hl, $9f9f 
14df						pop de   ; $9f9f 
14df						call cmp16 
14df						jr nz, .spnosame 
14df						ld hl, $fefe 
14df						pop de   ; $fefe 
14df						call cmp16 
14df						jr z, .spfrsame 
14df						.spnosame: call showsperror 
14df						.spfrsame: nop 
14df						exx 
14df					endif 
14df				endif 
14df			endm 
# End of macro STACKFRAMECHK
14df			 
14df				; copy input to last command 
14df			 
14df 21 9c e6			ld hl, os_cli_cmd 
14e2 11 9b e7			ld de, os_last_cmd 
14e5 01 ff 00			ld bc, 255 
14e8 ed b0			ldir 
14ea			 
14ea				; wipe current buffer 
14ea			 
14ea 3e 00			ld a, 0 
14ec 21 9c e6			ld hl, os_cli_cmd 
14ef 11 9d e6			ld de, os_cli_cmd+1 
14f2 01 fe 00			ld bc, 254 
14f5 ed b0			ldir 
14f7				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
14f7			;	call strcpy 
14f7			;	ld a, 0 
14f7			;	ld (hl), a 
14f7			;	inc hl 
14f7			;	ld (hl), a 
14f7			;	inc hl 
14f7			;	ld (hl), a 
14f7			 
14f7				; switch frame buffer to program  
14f7			 
14f7 21 1f ed				ld hl, display_fb1 
14fa 22 db eb				ld (display_fb_active), hl 
14fd			 
14fd			;	nop 
14fd				STACKFRAME ON $fbfe $8f9f 
14fd				if DEBUG_STACK_IMB 
14fd					if ON 
14fd						exx 
14fd						ld de, $fbfe 
14fd						ld a, d 
14fd						ld hl, curframe 
14fd						call hexout 
14fd						ld a, e 
14fd						ld hl, curframe+2 
14fd						call hexout 
14fd						ld hl, $fbfe 
14fd						push hl 
14fd						ld hl, $8f9f 
14fd						push hl 
14fd						exx 
14fd					endif 
14fd				endif 
14fd			endm 
# End of macro STACKFRAME
14fd				; first time into the parser so pass over the current scratch pad 
14fd 21 9c e6			ld hl,os_cli_cmd 
1500				; tokenise the entered statement(s) in HL 
1500 cd 5f 1a			call forthparse 
1503			        ; exec forth statements in top of return stack 
1503 cd 9f 1a			call forthexec 
1506				;call forthexec_cleanup 
1506			;	call parsenext 
1506			 
1506				STACKFRAMECHK ON $fbfe $8f9f 
1506				if DEBUG_STACK_IMB 
1506					if ON 
1506						exx 
1506						ld hl, $8f9f 
1506						pop de   ; $8f9f 
1506						call cmp16 
1506						jr nz, .spnosame 
1506						ld hl, $fbfe 
1506						pop de   ; $fbfe 
1506						call cmp16 
1506						jr z, .spfrsame 
1506						.spnosame: call showsperror 
1506						.spfrsame: nop 
1506						exx 
1506					endif 
1506				endif 
1506			endm 
# End of macro STACKFRAMECHK
1506				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1506			 
1506 3e 78			ld a, display_row_4 
1508 11 3a 15			ld de, endprog 
150b			 
150b cd 8c 09			call update_display		 
150e			 
150e cd 98 17			call next_page_prompt 
1511			 
1511				; switch frame buffer to cli 
1511			 
1511 21 c0 ed				ld hl, display_fb0 
1514 22 db eb				ld (display_fb_active), hl 
1517			 
1517			 
1517 cd 69 09		        call clear_display 
151a cd 8c 09			call update_display		 
151d			 
151d 21 9c e6			ld hl, os_cli_cmd 
1520			 
1520 3e 00			ld a, 0		 ; init cli input 
1522 77				ld (hl), a 
1523			 
1523				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1523			 
1523				; now on last line 
1523			 
1523				; TODO scroll screen up 
1523			 
1523				; TODO instead just clear screen and place at top of screen 
1523			 
1523			;	ld a, 0 
1523			;	ld (f_cursor_ptr),a 
1523			 
1523				;call clear_display 
1523				;call update_display 
1523			 
1523				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1523 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1525 c3 d3 14			jp cli 
1528			 
1528 .. 00		freeram: db "Free bytes: $",0 
1536 ..			asc: db "1A2F" 
153a .. 00		endprog: db "End prog...",0 
1546			 
1546			testenter2:   
1546 21 a7 e3			ld hl,scratch+50 
1549 22 98 e6			ld (os_cur_ptr),hl 
154c c3 d3 14			jp cli 
154f			 
154f			testenter:  
154f			 
154f 21 36 15			ld hl,asc 
1552			;	ld a,(hl) 
1552			;	call nibble2val 
1552 cd 19 0e			call get_byte 
1555			 
1555			 
1555			;	ld a,(hl) 
1555			;	call atohex 
1555			 
1555			;	call fourehexhl 
1555 32 a7 e3			ld (scratch+50),a 
1558			 
1558			 
1558			 
1558 21 38 15			ld hl,asc+2 
155b			;	ld a, (hl) 
155b			;	call nibble2val 
155b cd 19 0e			call get_byte 
155e			 
155e			;	call fourehexhl 
155e 32 a9 e3			ld (scratch+52),a 
1561				 
1561 21 a7 e3			ld hl,scratch+50 
1564 22 98 e6			ld (os_cur_ptr),hl 
1567 c3 d3 14			jp cli 
156a			 
156a			enter:	 
156a 3a 79 e3			ld a,(scratch+4) 
156d fe 00			cp 0 
156f 28 0c			jr z, .entercont 
1571				; no, not a null term line so has an address to work out.... 
1571			 
1571 21 77 e3			ld hl,scratch+2 
1574 cd 79 0e			call get_word_hl 
1577			 
1577 22 98 e6			ld (os_cur_ptr),hl	 
157a c3 d3 14			jp cli 
157d			 
157d			 
157d			.entercont:  
157d			 
157d 21 77 e3			ld hl, scratch+2 
1580 cd 19 0e			call get_byte 
1583			 
1583 2a 98 e6		   	ld hl,(os_cur_ptr) 
1586 77					ld (hl),a 
1587 23					inc hl 
1588 22 98 e6				ld (os_cur_ptr),hl 
158b				 
158b			; get byte  
158b			 
158b			 
158b c3 d3 14			jp cli 
158e			 
158e			 
158e			; basic monitor support 
158e			 
158e			monitor: 
158e				;  
158e cd 69 09			call clear_display 
1591 3e 00			ld a, 0 
1593 11 db 15			ld de, .monprompt 
1596 cd 7c 09			call str_at_display 
1599 cd 8c 09			call update_display 
159c			 
159c				; get a monitor command 
159c			 
159c 0e 00			ld c, 0     ; entry at top left 
159e 16 64			ld d, 100   ; max buffer size 
15a0 1e 0f			ld e, 15    ; input scroll area 
15a2 3e 00			ld a, 0     ; init string 
15a4 21 73 e5			ld hl, os_input 
15a7 77				ld (hl), a 
15a8 23				inc hl 
15a9 77				ld (hl), a 
15aa 21 73 e5			ld hl, os_input 
15ad 3e 01			ld a, 1     ; init string 
15af cd ef 0a			call input_str 
15b2			 
15b2 cd 69 09		        call clear_display 
15b5 cd 8c 09			call update_display		 
15b8			 
15b8 3a 73 e5			ld a, (os_input) 
15bb cd 17 0f			call toUpper 
15be fe 48		        cp 'H' 
15c0 28 6f		        jr z, .monhelp 
15c2 fe 44			cp 'D'		; dump 
15c4 ca 52 16			jp z, .mondump	 
15c7 fe 43			cp 'C'		; dump 
15c9 ca 6c 16			jp z, .moncdump	 
15cc fe 4d			cp 'M'		; dump 
15ce ca dd 15			jp z, .moneditstart 
15d1 fe 55			cp 'U'		; dump 
15d3 28 14			jr z, .monedit	 
15d5 fe 51			cp 'Q'		; dump 
15d7 c8				ret z	 
15d8			 
15d8			 
15d8				; TODO "S" to access symbol by name and not need the address 
15d8				; TODO "F" to find a string in memory 
15d8			 
15d8 c3 8e 15			jp monitor 
15db			 
15db .. 00		.monprompt: db ">", 0 
15dd			 
15dd			.moneditstart: 
15dd				; get starting address 
15dd			 
15dd 21 75 e5			ld hl,os_input+2 
15e0 cd 79 0e			call get_word_hl 
15e3			 
15e3 22 98 e6			ld (os_cur_ptr),hl	 
15e6			 
15e6 c3 8e 15			jp monitor 
15e9			 
15e9			.monedit: 
15e9				; get byte to load 
15e9			 
15e9 21 75 e5			ld hl,os_input+2 
15ec cd 19 0e			call get_byte 
15ef			 
15ef				; get address to update 
15ef 2a 98 e6			ld hl, (os_cur_ptr) 
15f2			 
15f2				; update byte 
15f2			 
15f2 77				ld (hl), a 
15f3			 
15f3				; move to next address and save it 
15f3			 
15f3 23				inc hl 
15f4 22 98 e6			ld (os_cur_ptr),hl	 
15f7			 
15f7 c3 8e 15			jp monitor 
15fa			 
15fa			 
15fa .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
160e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
162a .. 00		.monhelptext3:  db "Q-Quit",0 
1631			        
1631			.monhelp: 
1631 3e 00			ld a, display_row_1 
1633 11 fa 15		        ld de, .monhelptext1 
1636			 
1636 cd 7c 09			call str_at_display 
1639 3e 28			ld a, display_row_2 
163b 11 0e 16		        ld de, .monhelptext2 
163e					 
163e cd 7c 09			call str_at_display 
1641 3e 50			ld a, display_row_3 
1643 11 2a 16		        ld de, .monhelptext3 
1646					 
1646 cd 7c 09			call str_at_display 
1649 cd 8c 09			call update_display		 
164c			 
164c cd 98 17			call next_page_prompt 
164f c3 8e 15			jp monitor 
1652			 
1652			.mondump:    
1652 21 75 e5			ld hl,os_input+2 
1655 cd 79 0e			call get_word_hl 
1658			 
1658 22 98 e6			ld (os_cur_ptr),hl	 
165b cd a0 16			call dumpcont 
165e 3e 78			ld a, display_row_4 
1660 11 3a 15			ld de, endprog 
1663			 
1663 cd 8c 09			call update_display		 
1666			 
1666 cd 98 17			call next_page_prompt 
1669 c3 8e 15			jp monitor 
166c			.moncdump: 
166c cd a0 16			call dumpcont 
166f 3e 78			ld a, display_row_4 
1671 11 3a 15			ld de, endprog 
1674			 
1674 cd 8c 09			call update_display		 
1677			 
1677 cd 98 17			call next_page_prompt 
167a c3 8e 15			jp monitor 
167d			 
167d			 
167d			; TODO symbol access  
167d			 
167d			.symbols:     ;; A list of symbols that can be called up  
167d c0 ed			dw display_fb0 
167f .. 00			db "fb0",0  
1683 65 eb		     	dw store_page 
1685 .. 00			db "store_page",0 
1690			 
1690			 
1690			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1690			 
1690 3a 76 e3			ld a,(scratch+1) 
1693 fe 00			cp 0 
1695 28 09			jr z, dumpcont 
1697			 
1697				; no, not a null term line so has an address to work out.... 
1697			 
1697 21 77 e3			ld hl,scratch+2 
169a cd 79 0e			call get_word_hl 
169d			 
169d 22 98 e6			ld (os_cur_ptr),hl	 
16a0			 
16a0			 
16a0			 
16a0			dumpcont: 
16a0			 
16a0				; dump bytes at ptr 
16a0			 
16a0			 
16a0 3e 00			ld a, display_row_1 
16a2 2a db eb			ld hl, (display_fb_active) 
16a5 cd c2 0a			call addatohl 
16a8 cd d0 16			call .dumpbyterow 
16ab			 
16ab 3e 28			ld a, display_row_2 
16ad 2a db eb			ld hl, (display_fb_active) 
16b0 cd c2 0a			call addatohl 
16b3 cd d0 16			call .dumpbyterow 
16b6			 
16b6			 
16b6 3e 50			ld a, display_row_3 
16b8 2a db eb			ld hl, (display_fb_active) 
16bb cd c2 0a			call addatohl 
16be cd d0 16			call .dumpbyterow 
16c1			 
16c1 3e 78			ld a, display_row_4 
16c3 2a db eb			ld hl, (display_fb_active) 
16c6 cd c2 0a			call addatohl 
16c9 cd d0 16			call .dumpbyterow 
16cc			 
16cc cd 8c 09			call update_display 
16cf			;		jp cli 
16cf c9				ret 
16d0			 
16d0			.dumpbyterow: 
16d0			 
16d0				;push af 
16d0			 
16d0 e5				push hl 
16d1			 
16d1				; calc where to poke the ascii 
16d1			if display_cols == 20 
16d1				ld a, 16 
16d1			else 
16d1 3e 1f			ld a, 31 
16d3			endif 
16d3			 
16d3 cd c2 0a			call addatohl 
16d6 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
16d9			 
16d9			 
16d9			; display decoding address 
16d9 2a 98 e6		   	ld hl,(os_cur_ptr) 
16dc			 
16dc 7c				ld a,h 
16dd e1				pop hl 
16de e5				push hl 
16df			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
16df cd c3 0d			call hexout 
16e2 2a 98 e6		   	ld hl,(os_cur_ptr) 
16e5			 
16e5 7d				ld a,l 
16e6 e1				pop hl 
16e7 23				inc hl 
16e8 23				inc hl 
16e9 e5				push hl 
16ea			;	ld hl, os_word_scratch+2 
16ea cd c3 0d			call hexout 
16ed e1				pop hl 
16ee 23				inc hl 
16ef 23				inc hl 
16f0				;ld hl, os_word_scratch+4 
16f0 3e 3a			ld a, ':' 
16f2 77				ld (hl),a 
16f3 23				inc hl 
16f4				;ld a, 0 
16f4				;ld (hl),a 
16f4				;ld de, os_word_scratch 
16f4				;pop af 
16f4				;push af 
16f4			;		ld a, display_row_2 
16f4			;		call str_at_display 
16f4			;		call update_display 
16f4			 
16f4			 
16f4			;pop af 
16f4			;	add 5 
16f4			 
16f4			if display_cols == 20 
16f4				ld b, 4 
16f4			else 
16f4 06 08			ld b, 8 
16f6			endif	 
16f6			 
16f6			.dumpbyte: 
16f6 c5				push bc 
16f7 e5				push hl 
16f8			 
16f8			 
16f8 2a 98 e6		   	ld hl,(os_cur_ptr) 
16fb 7e					ld a,(hl) 
16fc			 
16fc					; poke the ascii to display 
16fc 2a 7a e6				ld hl,(os_word_scratch) 
16ff 77					ld (hl),a 
1700 23					inc hl 
1701 22 7a e6				ld (os_word_scratch),hl 
1704			 
1704					 
1704			 
1704			 
1704 e1					pop hl 
1705 e5					push hl 
1706			 
1706 cd c3 0d				call hexout 
1709			 
1709					 
1709 2a 98 e6		   	ld hl,(os_cur_ptr) 
170c 23				inc hl 
170d 22 98 e6		   	ld (os_cur_ptr),hl 
1710			 
1710 e1					pop hl 
1711 23					inc hl 
1712 23					inc hl 
1713 23					inc hl 
1714			 
1714			 
1714			 
1714					;ld a,0 
1714					;ld (os_word_scratch+2),a 
1714					;pop af 
1714					;push af 
1714			 
1714					;ld de, os_word_scratch 
1714					;call str_at_display 
1714			;		call update_display 
1714			;		pop af 
1714 c1					pop bc 
1715 c6 03				add 3 
1717 10 dd			djnz .dumpbyte 
1719			 
1719				 
1719			 
1719 c9				ret 
171a			 
171a			jump:	 
171a			 
171a 21 77 e3			ld hl,scratch+2 
171d cd 79 0e			call get_word_hl 
1720				;ld hl,(scratch+2) 
1720				;call fourehexhl 
1720			 
1720 22 98 e6			ld (os_cur_ptr),hl	 
1723			 
1723 e9				jp (hl) 
1724			 
1724			 
1724			 
1724			; TODO implement a basic monitor mode to start with 
1724			 
1724			 
1724			 
1724			 
1724			 
1724			 
1724			 
1724			 
1724			 
1724			; testing and demo code during development 
1724			 
1724			 
1724 .. 00		str1: db "Enter some text...",0 
1737 .. 00		clear: db "                    ",0 
174c			 
174c			demo: 
174c			 
174c			 
174c			 
174c			;	call update_display 
174c			 
174c				; init scratch input area for testing 
174c 21 75 e3			ld hl, scratch	 
174f 3e 00			ld a,0 
1751 77				ld (hl),a 
1752			 
1752			 
1752 3e 28		            LD   A, display_row_2 
1754			;            CALL fLCD_Pos       ;Position cursor to location in A 
1754 11 24 17		            LD   DE, str1 
1757 cd 7c 09			call str_at_display 
175a			 
175a			;            CALL fLCD_Str       ;Display string pointed to by DE 
175a			cloop:	 
175a 3e 50		            LD   A, display_row_3 
175c			;            CALL fLCD_Pos       ;Position cursor to location in A 
175c 11 37 17		            LD   DE, clear 
175f			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
175f cd 7c 09				call str_at_display 
1762 3e 78			ld a, display_row_4 
1764 11 94 17			ld de, prompt 
1767			 
1767 cd 7c 09				call str_at_display 
176a cd 8c 09			call update_display 
176d			 
176d 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
176f 16 0a			ld d, 10 
1771 21 75 e3			ld hl, scratch	 
1774 cd ef 0a			call input_str 
1777			 
1777			;	call clear_display 
1777			;'	call update_display 
1777			 
1777 3e 00		            LD   A, display_row_1 
1779			;            CALL fLCD_Pos       ;Position cursor to location in A 
1779 11 37 17		            LD   DE, clear 
177c cd 7c 09				call str_at_display 
177f			;            CALL fLCD_Str       ;Display string pointed to by DE 
177f 3e 00		            LD   A, display_row_1 
1781			;            CALL fLCD_Pos       ;Position cursor to location in A 
1781 11 75 e3		            LD   DE, scratch 
1784			;            CALL fLCD_Str       ;Display string pointed to by DE 
1784 cd 7c 09				call str_at_display 
1787 cd 8c 09			call update_display 
178a			 
178a 3e 00				ld a,0 
178c 21 75 e3			ld hl, scratch 
178f 77				ld (hl),a 
1790			 
1790 00				nop 
1791 c3 5a 17			jp cloop 
1794			 
1794			 
1794			 
1794			; OS Prompt 
1794			 
1794 .. 00		prompt: db ">",0 
1796 .. 00		endprg: db "?",0 
1798			 
1798			 
1798			; handy next page prompt 
1798			next_page_prompt: 
1798 e5				push hl 
1799 d5				push de 
179a f5				push af 
179b c5				push bc 
179c			 
179c 3e 9f			ld a,display_row_4 + display_cols - 1 
179e 11 96 17		        ld de, endprg 
17a1 cd 7c 09			call str_at_display 
17a4 cd 8c 09			call update_display 
17a7 cd f6 55			call cin_wait 
17aa c1				pop bc 
17ab f1				pop af 
17ac d1				pop de 
17ad e1				pop hl 
17ae			 
17ae			 
17ae c9				ret 
17af			 
17af			 
17af			; forth parser 
17af			 
17af			; My forth kernel 
17af			include "forth_kernel.asm" 
17af			; 
17af			; kernel to the forth OS 
17af			 
17af			DS_TYPE_STR: equ 1     ; string type 
17af			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
17af			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
17af			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
17af			 
17af			FORTH_PARSEV1: equ 0 
17af			FORTH_PARSEV2: equ 0 
17af			FORTH_PARSEV3: equ 0 
17af			FORTH_PARSEV4: equ 0 
17af			FORTH_PARSEV5: equ 1 
17af			 
17af			;if FORTH_PARSEV5 
17af			;	FORTH_END_BUFFER: equ 0 
17af			;else 
17af			FORTH_END_BUFFER: equ 127 
17af			;endif 
17af			 
17af			FORTH_TRUE: equ 1 
17af			FORTH_FALSE: equ 0 
17af			 
17af			if FORTH_PARSEV4 
17af			include "forth_stackops.asm" 
17af			endif 
17af			 
17af			if FORTH_PARSEV5 
17af			include "forth_stackopsv5.asm" 
17af			 
17af			; Stack operations for v5 parser on wards 
17af			; * DATA stack 
17af			; * LOOP stack 
17af			; * RETURN stack 
17af			 
17af			 
17af			 
17af			FORTH_CHK_DSP_UNDER: macro 
17af				push hl 
17af				push de 
17af				ld hl,(cli_data_sp) 
17af				ld de, cli_data_stack 
17af				call cmp16 
17af				jp c, fault_dsp_under 
17af				pop de 
17af				pop hl 
17af				endm 
17af			 
17af			 
17af			FORTH_CHK_RSP_UNDER: macro 
17af				push hl 
17af				push de 
17af				ld hl,(cli_ret_sp) 
17af				ld de, cli_ret_stack 
17af				call cmp16 
17af				jp c, fault_rsp_under 
17af				pop de 
17af				pop hl 
17af				endm 
17af			 
17af			FORTH_CHK_LOOP_UNDER: macro 
17af				push hl 
17af				push de 
17af				ld hl,(cli_loop_sp) 
17af				ld de, cli_loop_stack 
17af				call cmp16 
17af				jp c, fault_loop_under 
17af				pop de 
17af				pop hl 
17af				endm 
17af			 
17af			FORTH_ERR_TOS_NOTSTR: macro 
17af				; TOSO might need more for checks when used 
17af				push af 
17af				ld a,(hl) 
17af				cp DS_TYPE_STR 
17af				jp nz, type_faultn   
17af				pop af 
17af				endm 
17af			 
17af			FORTH_ERR_TOS_NOTNUM: macro 
17af				push af 
17af				ld a,(hl) 
17af				cp DS_TYPE_INUM 
17af				jp nz, type_faultn   
17af				pop af 
17af				endm 
17af			 
17af			 
17af			; increase data stack pointer and save hl to it 
17af				 
17af			FORTH_DSP_NEXT: macro 
17af				call macro_forth_dsp_next 
17af				endm 
17af			 
17af			 
17af			macro_forth_dsp_next: 
17af				if DEBUG_FORTH_STACK_GUARD 
17af cd 0e 53				call check_stacks 
17b2				endif 
17b2 e5				push hl 
17b3 d5				push de 
17b4 eb				ex de,hl 
17b5 2a 22 eb			ld hl,(cli_data_sp) 
17b8 23				inc hl 
17b9 23				inc hl 
17ba			 
17ba			; PARSEV5 
17ba 23				inc hl 
17bb 22 22 eb			ld (cli_data_sp),hl 
17be 73				ld (hl), e 
17bf 23				inc hl 
17c0 72				ld (hl), d 
17c1 d1				pop de 
17c2 e1				pop hl 
17c3				if DEBUG_FORTH_STACK_GUARD 
17c3 cd 0e 53				call check_stacks 
17c6				endif 
17c6 c9				ret 
17c7			 
17c7			 
17c7			; increase ret stack pointer and save hl to it 
17c7				 
17c7			FORTH_RSP_NEXT: macro 
17c7				call macro_forth_rsp_next 
17c7				endm 
17c7			 
17c7			macro_forth_rsp_next: 
17c7				if DEBUG_FORTH_STACK_GUARD 
17c7 cd 0e 53				call check_stacks 
17ca				endif 
17ca e5				push hl 
17cb d5				push de 
17cc eb				ex de,hl 
17cd 2a 26 eb			ld hl,(cli_ret_sp) 
17d0 23				inc hl 
17d1 23				inc hl 
17d2 22 26 eb			ld (cli_ret_sp),hl 
17d5 73				ld (hl), e 
17d6 23				inc hl 
17d7 72				ld (hl), d 
17d8 d1				pop de 
17d9 e1				pop hl 
17da				if DEBUG_FORTH_STACK_GUARD 
17da cd 0e 53				call check_stacks 
17dd				endif 
17dd c9				ret 
17de			 
17de			; get current ret stack pointer and save to hl  
17de				 
17de			FORTH_RSP_TOS: macro 
17de				call macro_forth_rsp_tos 
17de				endm 
17de			 
17de			macro_forth_rsp_tos: 
17de				;push de 
17de 2a 26 eb			ld hl,(cli_ret_sp) 
17e1 cd 19 18			call loadhlptrtohl 
17e4				;ld e, (hl) 
17e4				;inc hl 
17e4				;ld d, (hl) 
17e4				;ex de, hl 
17e4					if DEBUG_FORTH_WORDS 
17e4			;			DMARK "RST" 
17e4						CALLMONITOR 
17e4 cd 86 12			call break_point_state  
17e7				endm  
# End of macro CALLMONITOR
17e7					endif 
17e7				;pop de 
17e7 c9				ret 
17e8			 
17e8			; pop ret stack pointer 
17e8				 
17e8			FORTH_RSP_POP: macro 
17e8				call macro_forth_rsp_pop 
17e8				endm 
17e8			 
17e8			 
17e8			macro_forth_rsp_pop: 
17e8				if DEBUG_FORTH_STACK_GUARD 
17e8			;		DMARK "RPP" 
17e8 cd 0e 53				call check_stacks 
17eb					FORTH_CHK_RSP_UNDER 
17eb e5				push hl 
17ec d5				push de 
17ed 2a 26 eb			ld hl,(cli_ret_sp) 
17f0 11 e0 ea			ld de, cli_ret_stack 
17f3 cd e0 0a			call cmp16 
17f6 da 22 54			jp c, fault_rsp_under 
17f9 d1				pop de 
17fa e1				pop hl 
17fb				endm 
# End of macro FORTH_CHK_RSP_UNDER
17fb				endif 
17fb e5				push hl 
17fc 2a 26 eb			ld hl,(cli_ret_sp) 
17ff			 
17ff			 
17ff				if FORTH_ENABLE_FREE 
17ff			 
17ff					; get pointer 
17ff			 
17ff					push de 
17ff					push hl 
17ff			 
17ff					ld e, (hl) 
17ff					inc hl 
17ff					ld d, (hl) 
17ff			 
17ff					ex de, hl 
17ff					call free 
17ff			 
17ff					pop hl 
17ff					pop de 
17ff			 
17ff			 
17ff				endif 
17ff			 
17ff			 
17ff 2b				dec hl 
1800 2b				dec hl 
1801 22 26 eb			ld (cli_ret_sp), hl 
1804				; do stack underflow checks 
1804 e1				pop hl 
1805				if DEBUG_FORTH_STACK_GUARD 
1805 cd 0e 53				call check_stacks 
1808					FORTH_CHK_RSP_UNDER 
1808 e5				push hl 
1809 d5				push de 
180a 2a 26 eb			ld hl,(cli_ret_sp) 
180d 11 e0 ea			ld de, cli_ret_stack 
1810 cd e0 0a			call cmp16 
1813 da 22 54			jp c, fault_rsp_under 
1816 d1				pop de 
1817 e1				pop hl 
1818				endm 
# End of macro FORTH_CHK_RSP_UNDER
1818				endif 
1818 c9				ret 
1819			 
1819			 
1819			 
1819			; routine to load word pointed to by hl into hl 
1819			 
1819			loadhlptrtohl: 
1819			 
1819 d5				push de 
181a 5e				ld e, (hl) 
181b 23				inc hl 
181c 56				ld d, (hl) 
181d eb				ex de, hl 
181e d1				pop de 
181f			 
181f c9				ret 
1820			 
1820			 
1820			 
1820			 
1820			 
1820			; push a number held in HL onto the data stack 
1820			; entry point for pushing a value when already in hl used in function above 
1820			 
1820			forth_push_numhl: 
1820			 
1820 e5				push hl    ; save value to push 
1821			 
1821			if DEBUG_FORTH_PUSH 
1821				; see if disabled 
1821			 
1821			 
1821				push af 
1821				ld a, (os_view_disable) 
1821				cp '*' 
1821				jr z, .pskip2 
1821				push hl 
1821			push hl 
1821				call clear_display 
1821			pop hl 
1821				ld a,h 
1821				ld hl, os_word_scratch 
1821				call hexout 
1821				pop hl 
1821				ld a,l 
1821				ld hl, os_word_scratch+2 
1821				call hexout 
1821			 
1821				ld hl, os_word_scratch+4 
1821				ld a,0 
1821				ld (hl),a 
1821				ld de,os_word_scratch 
1821					ld a, display_row_2 
1821					call str_at_display 
1821				ld de, .push_num 
1821				ld a, display_row_1 
1821			 
1821					call str_at_display 
1821			 
1821			 
1821				call update_display 
1821				call delay1s 
1821				call delay1s 
1821			.pskip2:  
1821			 
1821				pop af 
1821			endif	 
1821			 
1821			 
1821				FORTH_DSP_NEXT 
1821 cd af 17			call macro_forth_dsp_next 
1824				endm 
# End of macro FORTH_DSP_NEXT
1824			 
1824 2a 22 eb			ld hl, (cli_data_sp) 
1827			 
1827				; save item type 
1827 3e 02			ld a,  DS_TYPE_INUM 
1829 77				ld (hl), a 
182a 23				inc hl 
182b			 
182b				; get word off stack 
182b d1				pop de 
182c 7b				ld a,e 
182d 77				ld (hl), a 
182e 23				inc hl 
182f 7a				ld a,d 
1830 77				ld (hl), a 
1831			 
1831			if DEBUG_FORTH_PUSH 
1831				dec hl 
1831				dec hl 
1831				dec hl 
1831						DMARK "PH5" 
1831				CALLMONITOR 
1831			endif	 
1831			 
1831 c9				ret 
1832			 
1832			 
1832			; Push a string to stack pointed to by hl 
1832			 
1832			forth_push_str: 
1832			 
1832			if DEBUG_FORTH_PUSH 
1832						DMARK "PSQ" 
1832				CALLMONITOR 
1832			endif	 
1832			    
1832 e5				push hl 
1833 e5				push hl 
1834			 
1834 3e 00			ld a, 0   ; find end of string 
1836 cd 2b 0f			call strlent       
1839			if DEBUG_FORTH_PUSH 
1839						DMARK "PQ2" 
1839				CALLMONITOR 
1839			endif	 
1839 eb				ex de, hl 
183a e1				pop hl   ; get ptr to start of string 
183b			if DEBUG_FORTH_PUSH 
183b						DMARK "PQ3" 
183b				CALLMONITOR 
183b			endif	 
183b 19				add hl,de 
183c			if DEBUG_FORTH_PUSH 
183c						DMARK "PQE" 
183c				CALLMONITOR 
183c			endif	 
183c			 
183c 2b				dec hl    ; see if there is an optional trailing double quote 
183d 7e				ld a,(hl) 
183e fe 22			cp '"' 
1840 20 03			jr nz, .strnoq 
1842 3e 00			ld a, 0      ; get rid of double quote 
1844 77				ld (hl), a 
1845 23			.strnoq: inc hl 
1846			 
1846 3e 00			ld a, 0 
1848 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1849			 
1849 13				inc de ; add one for the type string 
184a 13				inc de ; add one for null term??? 
184b			 
184b				; tos is get string pointer again 
184b				; de contains space to allocate 
184b				 
184b d5				push de 
184c			 
184c eb				ex de, hl 
184d			 
184d				;push af 
184d			 
184d			if DEBUG_FORTH_PUSH 
184d						DMARK "PHm" 
184d				CALLMONITOR 
184d			endif	 
184d cd 89 0f			call malloc	; on ret hl now contains allocated memory 
1850				if DEBUG_FORTH_MALLOC_GUARD 
1850 cc 74 42				call z,malloc_error 
1853				endif 
1853			 
1853				 
1853 c1				pop bc    ; get length 
1854 d1				pop de   ;  get string start    
1855			 
1855				; hl has destination from malloc 
1855			 
1855 eb				ex de, hl    ; prep for ldir 
1856			 
1856 e5				push hl   ; save malloc area for DSP later 
1857			 
1857			if DEBUG_FORTH_PUSH 
1857						DMARK "PHc" 
1857				CALLMONITOR 
1857			endif	 
1857			 
1857			 
1857 ed b0			ldir 
1859			 
1859			 
1859				; push malloc to data stack     macro?????  
1859			 
1859				FORTH_DSP_NEXT 
1859 cd af 17			call macro_forth_dsp_next 
185c				endm 
# End of macro FORTH_DSP_NEXT
185c			 
185c				; save value and type 
185c			 
185c 2a 22 eb			ld hl, (cli_data_sp) 
185f			 
185f				; save item type 
185f 3e 01			ld a,  DS_TYPE_STR 
1861 77				ld (hl), a 
1862 23				inc hl 
1863			 
1863				; get malloc word off stack 
1863 d1				pop de 
1864 73				ld (hl), e 
1865 23				inc hl 
1866 72				ld (hl), d 
1867			 
1867			 
1867			 
1867			if DEBUG_FORTH_PUSH 
1867				ld hl, (cli_data_sp) 
1867						DMARK "PHS" 
1867				CALLMONITOR 
1867			;	ex de,hl 
1867			endif	 
1867				; in case of spaces, skip the ptr past the copied string 
1867				;pop af 
1867				;ld (cli_origptr),hl 
1867			 
1867 c9				ret 
1868			 
1868			 
1868			 
1868			; TODO ascii push input onto stack given hl to start of input 
1868			 
1868			; identify type 
1868			; if starts with a " then a string 
1868			; otherwise it is a number 
1868			;  
1868			; if a string 
1868			;     scan for ending " to get length of string to malloc for + 1 
1868			;     malloc 
1868			;     put pointer to string on stack first byte flags as string 
1868			; 
1868			; else a number 
1868			;    look for number format identifier 
1868			;    $xx hex 
1868			;    %xxxxx bin 
1868			;    xxxxx decimal 
1868			;    convert number to 16bit word.  
1868			;    malloc word + 1 with flag to identiy as num 
1868			;    put pointer to number on stack 
1868			;   
1868			;  
1868			  
1868			forth_apush: 
1868				; kernel push 
1868			 
1868			if DEBUG_FORTH_PUSH 
1868						DMARK "PSH" 
1868				CALLMONITOR 
1868			endif	 
1868				; identify input type 
1868			 
1868 7e				ld a,(hl) 
1869 fe 22			cp '"' 
186b 28 0a			jr z, .fapstr 
186d fe 24			cp '$' 
186f ca 97 18			jp z, .faphex 
1872 fe 25			cp '%' 
1874 ca 7f 18			jp z, .fapbin 
1877			;	cp 'b' 
1877			;	jp z, .fabin 
1877				; else decimal 
1877			 
1877				; TODO do decimal conversion 
1877				; decimal is stored as a 16bit word 
1877			 
1877				; by default everything is a string if type is not detected 
1877			.fapstr: ; 
1877 fe 22			cp '"' 
1879 20 01			jr nz, .strnoqu 
187b 23				inc hl 
187c			.strnoqu: 
187c c3 32 18			jp forth_push_str 
187f			 
187f			 
187f			 
187f			.fapbin:    ; push a binary string.  
187f 11 00 00			ld de, 0   ; hold a 16bit value 
1882			 
1882 23			.fapbinshift:	inc hl  
1883 7e				ld a,(hl) 
1884 fe 00			cp 0     ; done scanning  
1886 28 0b			jr z, .fapbdone  	; got it in HL so push  
1888			 
1888				; left shift de 
1888 eb				ex de, hl	 
1889 29				add hl, hl 
188a			 
188a				; is 1 
188a fe 31			cp '1' 
188c 20 02			jr nz, .binzero 
188e cb 4d			bit 1, l 
1890			.binzero: 
1890 eb				ex de, hl	 ; save current de 
1891 18 ef			jr .fapbinshift 
1893			 
1893			.fapbdone: 
1893 eb				ex de, hl 
1894 c3 20 18			jp forth_push_numhl 
1897			 
1897			 
1897			.faphex:   ; hex is always stored as a 16bit word 
1897				; skip number prefix 
1897 23				inc hl 
1898				; turn ascii into number 
1898 cd 79 0e			call get_word_hl	; ret 16bit word in hl 
189b			 
189b c3 20 18			jp forth_push_numhl 
189e			 
189e 00				 nop 
189f			 
189f			.fabin:   ; TODO bin conversion 
189f			 
189f			 
189f c9				ret 
18a0			 
18a0			 
18a0			; get either a string ptr or a 16bit word from the data stack 
18a0			 
18a0			FORTH_DSP: macro 
18a0				call macro_forth_dsp 
18a0				endm 
18a0			 
18a0			macro_forth_dsp: 
18a0				; data stack pointer points to current word on tos 
18a0			 
18a0 2a 22 eb			ld hl,(cli_data_sp) 
18a3			 
18a3				if DEBUG_FORTH_PUSH 
18a3						DMARK "DSP" 
18a3			 
18a3					call display_data_sp 
18a3				;call break_point_state 
18a3				;rst 030h 
18a3				CALLMONITOR 
18a3				endif 
18a3			 
18a3 c9				ret 
18a4			 
18a4			; return hl to start of value on stack 
18a4			 
18a4			FORTH_DSP_VALUE: macro 
18a4				call macro_forth_dsp_value 
18a4				endm 
18a4			 
18a4			macro_forth_dsp_value: 
18a4			 
18a4				FORTH_DSP 
18a4 cd a0 18			call macro_forth_dsp 
18a7				endm 
# End of macro FORTH_DSP
18a7			 
18a7 d5				push de 
18a8			 
18a8 23				inc hl ; skip type 
18a9			 
18a9 5e				ld e, (hl) 
18aa 23				inc hl 
18ab 56				ld d, (hl) 
18ac eb				ex de,hl  
18ad			 
18ad d1				pop de 
18ae			 
18ae c9				ret 
18af			 
18af			; return hl to start of value to second item on stack 
18af			 
18af			FORTH_DSP_VALUEM1: macro 
18af				call macro_forth_dsp_value_m1 
18af				endm 
18af			 
18af			macro_forth_dsp_value_m1: 
18af			 
18af				FORTH_DSP 
18af cd a0 18			call macro_forth_dsp 
18b2				endm 
# End of macro FORTH_DSP
18b2			 
18b2 2b				dec hl 
18b3 2b				dec hl 
18b4			;	dec hl 
18b4			 
18b4 d5				push de 
18b5			 
18b5 5e				ld e, (hl) 
18b6 23				inc hl 
18b7 56				ld d, (hl) 
18b8 eb				ex de,hl  
18b9			 
18b9 d1				pop de 
18ba			 
18ba c9				ret 
18bb			 
18bb				 
18bb			 
18bb			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
18bb			 
18bb			FORTH_DSP_POP: macro 
18bb				call macro_forth_dsp_pop 
18bb				endm 
18bb			 
18bb			 
18bb			; get the tos data type 
18bb			 
18bb			FORTH_DSP_TYPE:   macro 
18bb			 
18bb				;FORTH_DSP_VALUE 
18bb				FORTH_DSP 
18bb				 
18bb				; hl points to value 
18bb				; check type 
18bb			 
18bb				ld a,(hl) 
18bb			 
18bb				endm 
18bb			 
18bb			; load the tos value into hl 
18bb			 
18bb			 
18bb			FORTH_DSP_VALUEHL:  macro 
18bb				call macro_dsp_valuehl 
18bb				endm 
18bb			 
18bb			 
18bb			 
18bb			macro_dsp_valuehl: 
18bb				FORTH_DSP_VALUE 
18bb cd a4 18			call macro_forth_dsp_value 
18be				endm 
# End of macro FORTH_DSP_VALUE
18be			 
18be				;FORTH_ERR_TOS_NOTNUM 
18be			 
18be				;inc hl   ; skip type id 
18be			 
18be			;	push de 
18be			; 
18be			;	ld e, (hl) 
18be			;	inc hl 
18be			;	ld d, (hl) 
18be			;	ex de,hl  
18be			 
18be			;	pop de 
18be			 
18be				if DEBUG_FORTH_PUSH 
18be						DMARK "DVL" 
18be				CALLMONITOR 
18be				endif 
18be c9				ret 
18bf			 
18bf			forth_apushstrhl:      
18bf				; push of string requires use of cli_origptr 
18bf				; bodge use 
18bf			 
18bf				; get current cli_origptr, save, update with temp pointer  
18bf ed 5b 3e eb		ld de, (cli_origptr) 
18c3 22 3e eb			ld (cli_origptr), hl 
18c6 d5				push de 
18c7 cd 68 18			call forth_apush 
18ca d1				pop de 
18cb ed 53 3e eb		ld (cli_origptr), de 
18cf c9			        ret	 
18d0			 
18d0			 
18d0			; increase loop stack pointer and save hl to it 
18d0				 
18d0			FORTH_LOOP_NEXT: macro 
18d0				call macro_forth_loop_next 
18d0				;nop 
18d0				endm 
18d0			 
18d0			macro_forth_loop_next: 
18d0				if DEBUG_FORTH_STACK_GUARD 
18d0 cd 0e 53				call check_stacks 
18d3				endif 
18d3 e5				push hl 
18d4 d5				push de 
18d5 eb				ex de,hl 
18d6 2a 24 eb			ld hl,(cli_loop_sp) 
18d9 23				inc hl 
18da 23				inc hl 
18db					if DEBUG_FORTH_WORDS 
18db						DMARK "LNX" 
18db f5				push af  
18dc 3a f0 18			ld a, (.dmark)  
18df 32 7a ee			ld (debug_mark),a  
18e2 3a f1 18			ld a, (.dmark+1)  
18e5 32 7b ee			ld (debug_mark+1),a  
18e8 3a f2 18			ld a, (.dmark+2)  
18eb 32 7c ee			ld (debug_mark+2),a  
18ee 18 03			jr .pastdmark  
18f0 ..			.dmark: db "LNX"  
18f3 f1			.pastdmark: pop af  
18f4			endm  
# End of macro DMARK
18f4						CALLMONITOR 
18f4 cd 86 12			call break_point_state  
18f7				endm  
# End of macro CALLMONITOR
18f7					endif 
18f7 22 24 eb			ld (cli_loop_sp),hl 
18fa 73				ld (hl), e 
18fb 23				inc hl 
18fc 72				ld (hl), d 
18fd d1				pop de    ; been reversed so save a swap on restore 
18fe e1				pop hl 
18ff				if DEBUG_FORTH_STACK_GUARD 
18ff cd 0e 53				call check_stacks 
1902				endif 
1902 c9				ret 
1903			 
1903			; get current ret stack pointer and save to hl  
1903				 
1903			FORTH_LOOP_TOS: macro 
1903				call macro_forth_loop_tos 
1903				endm 
1903			 
1903			macro_forth_loop_tos: 
1903 d5				push de 
1904 2a 24 eb			ld hl,(cli_loop_sp) 
1907 5e				ld e, (hl) 
1908 23				inc hl 
1909 56				ld d, (hl) 
190a eb				ex de, hl 
190b d1				pop de 
190c c9				ret 
190d			 
190d			; pop loop stack pointer 
190d				 
190d			FORTH_LOOP_POP: macro 
190d				call macro_forth_loop_pop 
190d				endm 
190d			 
190d			 
190d			macro_forth_loop_pop: 
190d				if DEBUG_FORTH_STACK_GUARD 
190d					DMARK "LPP" 
190d f5				push af  
190e 3a 22 19			ld a, (.dmark)  
1911 32 7a ee			ld (debug_mark),a  
1914 3a 23 19			ld a, (.dmark+1)  
1917 32 7b ee			ld (debug_mark+1),a  
191a 3a 24 19			ld a, (.dmark+2)  
191d 32 7c ee			ld (debug_mark+2),a  
1920 18 03			jr .pastdmark  
1922 ..			.dmark: db "LPP"  
1925 f1			.pastdmark: pop af  
1926			endm  
# End of macro DMARK
1926 cd 0e 53				call check_stacks 
1929					FORTH_CHK_LOOP_UNDER 
1929 e5				push hl 
192a d5				push de 
192b 2a 24 eb			ld hl,(cli_loop_sp) 
192e 11 de e9			ld de, cli_loop_stack 
1931 cd e0 0a			call cmp16 
1934 da 28 54			jp c, fault_loop_under 
1937 d1				pop de 
1938 e1				pop hl 
1939				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1939				endif 
1939 e5				push hl 
193a 2a 24 eb			ld hl,(cli_loop_sp) 
193d 2b				dec hl 
193e 2b				dec hl 
193f 22 24 eb			ld (cli_loop_sp), hl 
1942				; TODO do stack underflow checks 
1942 e1				pop hl 
1943				if DEBUG_FORTH_STACK_GUARD 
1943 cd 0e 53				call check_stacks 
1946					FORTH_CHK_LOOP_UNDER 
1946 e5				push hl 
1947 d5				push de 
1948 2a 24 eb			ld hl,(cli_loop_sp) 
194b 11 de e9			ld de, cli_loop_stack 
194e cd e0 0a			call cmp16 
1951 da 28 54			jp c, fault_loop_under 
1954 d1				pop de 
1955 e1				pop hl 
1956				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1956				endif 
1956 c9				ret 
1957			 
1957			macro_forth_dsp_pop: 
1957			 
1957 e5				push hl 
1958			 
1958				; release malloc data 
1958			 
1958				if DEBUG_FORTH_STACK_GUARD 
1958 cd 0e 53				call check_stacks 
195b					FORTH_CHK_DSP_UNDER 
195b e5				push hl 
195c d5				push de 
195d 2a 22 eb			ld hl,(cli_data_sp) 
1960 11 dc e8			ld de, cli_data_stack 
1963 cd e0 0a			call cmp16 
1966 da 1c 54			jp c, fault_dsp_under 
1969 d1				pop de 
196a e1				pop hl 
196b				endm 
# End of macro FORTH_CHK_DSP_UNDER
196b				endif 
196b				;ld hl,(cli_data_sp) 
196b			if DEBUG_FORTH_DOT 
196b				DMARK "DPP" 
196b				CALLMONITOR 
196b			endif	 
196b			 
196b			 
196b			if FORTH_ENABLE_DSPPOPFREE 
196b			 
196b				FORTH_DSP 
196b cd a0 18			call macro_forth_dsp 
196e				endm 
# End of macro FORTH_DSP
196e			 
196e 7e				ld a, (hl) 
196f fe 01			cp DS_TYPE_STR 
1971 20 07			jr nz, .skippopfree 
1973			 
1973				FORTH_DSP_VALUEHL 
1973 cd bb 18			call macro_dsp_valuehl 
1976				endm 
# End of macro FORTH_DSP_VALUEHL
1976 00				nop 
1977			if DEBUG_FORTH_DOT 
1977				DMARK "DPf" 
1977				CALLMONITOR 
1977			endif	 
1977 cd 53 10			call free 
197a			.skippopfree: 
197a				 
197a			 
197a			endif 
197a			 
197a			if DEBUG_FORTH_DOT_KEY 
197a				DMARK "DP2" 
197a				CALLMONITOR 
197a			endif	 
197a			 
197a				; move pointer down 
197a			 
197a 2a 22 eb			ld hl,(cli_data_sp) 
197d 2b				dec hl 
197e 2b				dec hl 
197f			; PARSEV5 
197f 2b				dec hl 
1980 22 22 eb			ld (cli_data_sp), hl 
1983			 
1983				if DEBUG_FORTH_STACK_GUARD 
1983 cd 0e 53				call check_stacks 
1986					FORTH_CHK_DSP_UNDER 
1986 e5				push hl 
1987 d5				push de 
1988 2a 22 eb			ld hl,(cli_data_sp) 
198b 11 dc e8			ld de, cli_data_stack 
198e cd e0 0a			call cmp16 
1991 da 1c 54			jp c, fault_dsp_under 
1994 d1				pop de 
1995 e1				pop hl 
1996				endm 
# End of macro FORTH_CHK_DSP_UNDER
1996				endif 
1996			 
1996 e1				pop hl 
1997			 
1997 c9				ret 
1998			 
1998			getwordathl: 
1998				; hl points to an address 
1998				; load hl with the word at that address 
1998			 
1998 d5				push de 
1999			 
1999 5e				ld e, (hl) 
199a 23				inc hl 
199b 56				ld d, (hl) 
199c eb				ex de, hl 
199d			 
199d d1				pop de 
199e c9				ret 
199f			 
199f			 
199f			 
199f			 
199f			 
199f			; eof 
199f			 
# End of file forth_stackopsv5.asm
199f			endif 
199f			 
199f			user_word_eol:  
199f				; hl contains the pointer to where to create a linked list item from the end 
199f				; of the user dict to continue on at the system word dict 
199f				 
199f				; poke the stub of the word list linked list to repoint to rom words 
199f			 
199f				; stub format 
199f				; db   word id 
199f				; dw    link to next word 
199f			        ; db char length of token 
199f				; db string + 0 term 
199f				; db exec code....  
199f			 
199f 3e 00			ld a, WORD_SYS_ROOT     ; root word 
19a1 77				ld (hl), a		; word id 
19a2 23				inc hl 
19a3			 
19a3 11 69 1b			ld de, sysdict 
19a6 73				ld (hl), e		; next word link ie system dict 
19a7 23				inc hl 
19a8 72				ld (hl), d		; next word link ie system dict 
19a9 23				inc hl	 
19aa			 
19aa			;	ld (hl), sysdict		; next word link ie system dict 
19aa			;	inc hl 
19aa			;	inc hl 
19aa			 
19aa			;	inc hl 
19aa			;	inc hl 
19aa			 
19aa 3e 02			ld a, 2			; word length is 0 
19ac 77				ld (hl), a	 
19ad 23				inc hl 
19ae			 
19ae 3e 7e			ld a, '~'			; word length is 0 
19b0 77				ld (hl), a	 
19b1 23				inc hl 
19b2 3e 00			ld a, 0			; save empty word 
19b4 77				ld (hl), a 
19b5			 
19b5 c9				ret 
19b6			 
19b6				 
19b6			 
19b6			forthexec_cleanup: 
19b6				FORTH_RSP_POP 
19b6 cd e8 17			call macro_forth_rsp_pop 
19b9				endm 
# End of macro FORTH_RSP_POP
19b9 c9				ret 
19ba			 
19ba			forth_call_hl: 
19ba				; taking hl 
19ba e5				push hl 
19bb c9				ret 
19bc			 
19bc			; this is called to reset Forth system but keep existing uwords etc 
19bc			 
19bc			forth_warmstart: 
19bc				; setup stack over/under flow checks 
19bc				if DEBUG_FORTH_STACK_GUARD 
19bc cd f4 52				call chk_stk_init 
19bf				endif 
19bf			 
19bf				; init stack pointers  - * these stacks go upwards *  
19bf 21 e0 ea			ld hl, cli_ret_stack 
19c2 22 26 eb			ld (cli_ret_sp), hl	 
19c5				; set bottom of stack 
19c5 3e 00			ld a,0 
19c7 77				ld (hl),a 
19c8 23				inc hl 
19c9 77				ld (hl),a 
19ca			 
19ca 21 dc e8			ld hl, cli_data_stack 
19cd 22 22 eb			ld (cli_data_sp), hl	 
19d0				; set bottom of stack 
19d0 3e 00			ld a,0 
19d2 77				ld (hl),a 
19d3 23				inc hl 
19d4 77				ld (hl),a 
19d5			 
19d5 21 de e9			ld hl, cli_loop_stack 
19d8 22 24 eb			ld (cli_loop_sp), hl	 
19db				; set bottom of stack 
19db 3e 00			ld a,0 
19dd 77				ld (hl),a 
19de 23				inc hl 
19df 77				ld (hl),a 
19e0			 
19e0				; init extent of current open file 
19e0			 
19e0 3e 00			ld a, 0 
19e2 32 5c eb			ld (store_openext), a 
19e5			 
19e5 c9				ret 
19e6			 
19e6			 
19e6			; Cold Start - this is called to setup the whole Forth system 
19e6			 
19e6			forth_init: 
19e6			 
19e6				; setup stack over/under flow checks 
19e6			 
19e6			;	if DEBUG_FORTH_STACK_GUARD 
19e6			;		call chk_stk_init 
19e6			;	endif 
19e6			 
19e6				; enable auto display updates (slow.....) 
19e6			 
19e6 3e 01			ld a, 1 
19e8 32 3c eb			ld (cli_autodisplay), a 
19eb			 
19eb			 
19eb			 
19eb				; show start up screen 
19eb			 
19eb cd 69 09			call clear_display 
19ee			 
19ee 3e 00			ld a,0 
19f0 32 5e eb			ld (f_cursor_ptr), a 
19f3			 
19f3				; set start of word list in start of ram - for use when creating user words 
19f3			 
19f3 21 17 56			ld hl, baseram 
19f6 22 72 e6			ld (os_last_new_uword), hl 
19f9 cd 9f 19			call user_word_eol 
19fc				 
19fc			;		call display_data_sp 
19fc			;		call next_page_prompt 
19fc			 
19fc			 
19fc			 
19fc			 
19fc c9				ret 
19fd			 
19fd .. 00		.bootforth: db " Forth Kernel Init ",0 
1a11			 
1a11			; TODO push to stack 
1a11			 
1a11			;  
1a11			 
1a11			if FORTH_PARSEV2 
1a11			 
1a11			 
1a11				include "forth_parserv2.asm" 
1a11			 
1a11			endif 
1a11			 
1a11			 
1a11			; parse cli version 1 
1a11			 
1a11			if FORTH_PARSEV1 
1a11			 
1a11			 
1a11			 
1a11			      include "forth_parserv1.asm" 
1a11			endif 
1a11				 
1a11			if FORTH_PARSEV3 
1a11			 
1a11			 
1a11			 
1a11			      include "forth_parserv3.asm" 
1a11				include "forth_wordsv3.asm" 
1a11			endif 
1a11			 
1a11			if FORTH_PARSEV4 
1a11			 
1a11			 
1a11			 
1a11			      include "forth_parserv4.asm" 
1a11				include "forth_wordsv4.asm" 
1a11			endif 
1a11			 
1a11			if FORTH_PARSEV5 
1a11			 
1a11			 
1a11			 
1a11			      include "forth_parserv5.asm" 
1a11			 
1a11			 
1a11			; A better parser without using malloc and string copies all over the place.  
1a11			; Exec in situ should be faster 
1a11			 
1a11			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1a11			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1a11			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1a11			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1a11			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1a11			WORD_SYS_END: equ 0   ; Opcode for all user words 
1a11			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1a11			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1a11			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1a11			 
1a11			; Core word preamble macro 
1a11			 
1a11			CWHEAD:   macro nxtword opcode lit len opflags 
1a11				db WORD_SYS_CORE+opcode             
1a11				; internal op code number 
1a11				dw nxtword            
1a11				; link to next dict word block 
1a11				db len + 1 
1a11				; literal length of dict word inc zero term 
1a11				db lit,0              
1a11				; literal dict word 
1a11			        ; TODO db opflags        
1a11				endm 
1a11			 
1a11			 
1a11			NEXTW: macro  
1a11				jp macro_next 
1a11				endm 
1a11			 
1a11			macro_next: 
1a11			if DEBUG_FORTH_PARSE_KEY 
1a11				DMARK "NXT" 
1a11				CALLMONITOR 
1a11			endif	 
1a11			;	inc hl  ; skip token null term  
1a11 ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1a15 ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1a19 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1a1c			if DEBUG_FORTH_PARSE_KEY 
1a1c				DMARK "}AA" 
1a1c				CALLMONITOR 
1a1c			endif	 
1a1c c3 1f 1b			jp execnext 
1a1f				;jp exec1 
1a1f			       
1a1f			 
1a1f			 
1a1f			; Another go at the parser to compile  
1a1f			 
1a1f			 
1a1f			; TODO rework parser to change all of the string words to byte tokens 
1a1f			; TODO do a search for  
1a1f			 
1a1f			; TODO first run normal parser to zero term sections 
1a1f			; TODO for each word do a token look up to get the op code 
1a1f			; TODO need some means to flag to the exec that this is a byte code form    
1a1f			 
1a1f			 
1a1f			forthcompile: 
1a1f			 
1a1f			; 
1a1f			; line parse: 
1a1f			;       parse raw input buffer 
1a1f			;       tokenise the words 
1a1f			;       malloc new copy (for looping etc) 
1a1f			;       copy to malloc + current pc in line to start of string and add line term 
1a1f			;       save on new rsp 
1a1f			; 
1a1f			 
1a1f			; hl to point to the line to tokenise 
1a1f			 
1a1f			;	push hl 
1a1f 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1a22			 
1a22			;	ld a,0		; string term on input 
1a22			;	call strlent 
1a22			 
1a22			;	ld (os_tok_len), hl	 ; save string length 
1a22			 
1a22			;if DEBUG_FORTH_TOK 
1a22			;	ex de,hl		 
1a22			;endif 
1a22			 
1a22			;	pop hl 		; get back string pointer 
1a22			 
1a22			if DEBUG_FORTH_TOK 
1a22						DMARK "TOc" 
1a22				CALLMONITOR 
1a22			endif 
1a22 7e			.cptoken2:    ld a,(hl) 
1a23 23				inc hl 
1a24 fe 7f			cp FORTH_END_BUFFER 
1a26 28 29			jr z, .cptokendone2 
1a28 fe 00			cp 0 
1a2a 28 25			jr z, .cptokendone2 
1a2c fe 22			cp '"' 
1a2e 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1a30 fe 20			cp ' ' 
1a32 20 ee			jr nz,  .cptoken2 
1a34			 
1a34			; TODO consume comments held between ( and ) 
1a34			 
1a34				; we have a space so change to zero term for dict match later 
1a34 2b				dec hl 
1a35 3e 00			ld a,0 
1a37 77				ld (hl), a 
1a38 23				inc hl 
1a39 18 e7			jr .cptoken2 
1a3b				 
1a3b			 
1a3b			.cptokenstr2: 
1a3b				; skip all white space until either eol (because forgot to term) or end double quote 
1a3b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1a3b				;inc hl ; skip current double quote 
1a3b 7e				ld a,(hl) 
1a3c 23				inc hl 
1a3d fe 22			cp '"' 
1a3f 28 e1			jr z, .cptoken2 
1a41 fe 7f			cp FORTH_END_BUFFER 
1a43 28 0c			jr z, .cptokendone2 
1a45 fe 00			cp 0 
1a47 28 08			jr z, .cptokendone2 
1a49 fe 20			cp ' ' 
1a4b 28 02			jr z, .cptmp2 
1a4d 18 ec			jr .cptokenstr2 
1a4f			 
1a4f			.cptmp2:	; we have a space so change to zero term for dict match later 
1a4f				;dec hl 
1a4f				;ld a,"-"	; TODO remove this when working 
1a4f				;ld (hl), a 
1a4f				;inc hl 
1a4f 18 ea			jr .cptokenstr2 
1a51			 
1a51			.cptokendone2: 
1a51				;inc hl 
1a51 3e 7f			ld a, FORTH_END_BUFFER 
1a53 77				ld (hl),a 
1a54 23				inc hl 
1a55 3e 21			ld a, '!' 
1a57 77				ld (hl),a 
1a58			 
1a58 2a 76 e6			ld hl,(os_tok_ptr) 
1a5b			         
1a5b			if DEBUG_FORTH_TOK 
1a5b						DMARK "Tc1" 
1a5b				CALLMONITOR 
1a5b			endif 
1a5b			 
1a5b				; push exec string to top of return stack 
1a5b				FORTH_RSP_NEXT 
1a5b cd c7 17			call macro_forth_rsp_next 
1a5e				endm 
# End of macro FORTH_RSP_NEXT
1a5e c9				ret 
1a5f			 
1a5f			; Another go at the parser need to simplify the process 
1a5f			 
1a5f			forthparse: 
1a5f			 
1a5f			; 
1a5f			; line parse: 
1a5f			;       parse raw input buffer 
1a5f			;       tokenise the words 
1a5f			;       malloc new copy (for looping etc) 
1a5f			;       copy to malloc + current pc in line to start of string and add line term 
1a5f			;       save on new rsp 
1a5f			; 
1a5f			 
1a5f			; hl to point to the line to tokenise 
1a5f			 
1a5f			;	push hl 
1a5f 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1a62			 
1a62			;	ld a,0		; string term on input 
1a62			;	call strlent 
1a62			 
1a62			;	ld (os_tok_len), hl	 ; save string length 
1a62			 
1a62			;if DEBUG_FORTH_TOK 
1a62			;	ex de,hl		 
1a62			;endif 
1a62			 
1a62			;	pop hl 		; get back string pointer 
1a62			 
1a62			if DEBUG_FORTH_TOK 
1a62						DMARK "TOK" 
1a62				CALLMONITOR 
1a62			endif 
1a62 7e			.ptoken2:    ld a,(hl) 
1a63 23				inc hl 
1a64 fe 7f			cp FORTH_END_BUFFER 
1a66 28 29			jr z, .ptokendone2 
1a68 fe 00			cp 0 
1a6a 28 25			jr z, .ptokendone2 
1a6c fe 22			cp '"' 
1a6e 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1a70 fe 20			cp ' ' 
1a72 20 ee			jr nz,  .ptoken2 
1a74			 
1a74			; TODO consume comments held between ( and ) 
1a74			 
1a74				; we have a space so change to zero term for dict match later 
1a74 2b				dec hl 
1a75 3e 00			ld a,0 
1a77 77				ld (hl), a 
1a78 23				inc hl 
1a79 18 e7			jr .ptoken2 
1a7b				 
1a7b			 
1a7b			.ptokenstr2: 
1a7b				; skip all white space until either eol (because forgot to term) or end double quote 
1a7b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1a7b				;inc hl ; skip current double quote 
1a7b 7e				ld a,(hl) 
1a7c 23				inc hl 
1a7d fe 22			cp '"' 
1a7f 28 e1			jr z, .ptoken2 
1a81 fe 7f			cp FORTH_END_BUFFER 
1a83 28 0c			jr z, .ptokendone2 
1a85 fe 00			cp 0 
1a87 28 08			jr z, .ptokendone2 
1a89 fe 20			cp ' ' 
1a8b 28 02			jr z, .ptmp2 
1a8d 18 ec			jr .ptokenstr2 
1a8f			 
1a8f			.ptmp2:	; we have a space so change to zero term for dict match later 
1a8f				;dec hl 
1a8f				;ld a,"-"	; TODO remove this when working 
1a8f				;ld (hl), a 
1a8f				;inc hl 
1a8f 18 ea			jr .ptokenstr2 
1a91			 
1a91			.ptokendone2: 
1a91				;inc hl 
1a91 3e 7f			ld a, FORTH_END_BUFFER 
1a93 77				ld (hl),a 
1a94 23				inc hl 
1a95 3e 21			ld a, '!' 
1a97 77				ld (hl),a 
1a98			 
1a98 2a 76 e6			ld hl,(os_tok_ptr) 
1a9b			         
1a9b			if DEBUG_FORTH_TOK 
1a9b						DMARK "TK1" 
1a9b				CALLMONITOR 
1a9b			endif 
1a9b			 
1a9b				; push exec string to top of return stack 
1a9b				FORTH_RSP_NEXT 
1a9b cd c7 17			call macro_forth_rsp_next 
1a9e				endm 
# End of macro FORTH_RSP_NEXT
1a9e c9				ret 
1a9f			 
1a9f			; 
1a9f			;	; malloc size + buffer pointer + if is loop flag 
1a9f			;	ld hl,(os_tok_len) 		 ; get string length 
1a9f			; 
1a9f			;	ld a,l 
1a9f			; 
1a9f			;	cp 0			; we dont want to use a null string 
1a9f			;	ret z 
1a9f			; 
1a9f			;;	add 3    ; prefix malloc with buffer for current word ptr 
1a9f			; 
1a9f			;	add 5     ; TODO when certain not over writing memory remove 
1a9f			; 
1a9f			;		 
1a9f			; 
1a9f			;if DEBUG_FORTH_TOK 
1a9f			;			DMARK "TKE" 
1a9f			;	CALLMONITOR 
1a9f			;endif 
1a9f			; 
1a9f			;	ld l,a 
1a9f			;	ld h,0 
1a9f			;;	push hl   ; save required space for the copy later 
1a9f			;	call malloc 
1a9f			;if DEBUG_FORTH_TOK 
1a9f			;			DMARK "TKM" 
1a9f			;	CALLMONITOR 
1a9f			;endif 
1a9f			;	if DEBUG_FORTH_MALLOC_GUARD 
1a9f			;		push af 
1a9f			;		call ishlzero 
1a9f			;;		ld a, l 
1a9f			;;		add h 
1a9f			;;		cp 0 
1a9f			;		pop af 
1a9f			;		 
1a9f			;		call z,malloc_error 
1a9f			;	endif 
1a9f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1a9f			; 
1a9f			; 
1a9f			;if DEBUG_FORTH_TOK 
1a9f			;			DMARK "TKR" 
1a9f			;	CALLMONITOR 
1a9f			;endif 
1a9f			; 
1a9f			;	FORTH_RSP_NEXT 
1a9f			; 
1a9f			;	;inc hl	 ; go past current buffer pointer 
1a9f			;	;inc hl 
1a9f			;	;inc hl   ; and past if loop flag 
1a9f			;		; TODO Need to set flag  
1a9f			; 
1a9f			;	 
1a9f			;	 
1a9f			;	ex de,hl	; malloc is dest 
1a9f			;	ld hl, (os_tok_len) 
1a9f			;;	pop bc 
1a9f			;	ld c, l                
1a9f			;	ld b,0 
1a9f			;	ld hl, (os_tok_ptr) 
1a9f			; 
1a9f			;if DEBUG_FORTH_TOK 
1a9f			;			DMARK "TKT" 
1a9f			;	CALLMONITOR 
1a9f			;endif 
1a9f			; 
1a9f			;	; do str cpy 
1a9f			; 
1a9f			;	ldir      ; copy byte in hl to de 
1a9f			; 
1a9f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1a9f			; 
1a9f			;if DEBUG_FORTH_TOK 
1a9f			; 
1a9f			;			DMARK "TKY" 
1a9f			;	CALLMONITOR 
1a9f			;endif 
1a9f			;	;ld a,0 
1a9f			;	;ld a,FORTH_END_BUFFER 
1a9f			;	ex de, hl 
1a9f			;	;dec hl			 ; go back over the space delim at the end of word 
1a9f			;	;ld (hl),a 
1a9f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1a9f			;	ld a,FORTH_END_BUFFER 
1a9f			;	ld (hl),a 
1a9f			;	inc hl 
1a9f			;	ld a,FORTH_END_BUFFER 
1a9f			;	ld (hl),a 
1a9f			; 
1a9f			;	; init the malloc area data 
1a9f			;	; set pc for in current area 
1a9f			;	;ld hl, (os_tok_malloc) 
1a9f			;	;inc hl 
1a9f			;	;inc hl 
1a9f			;	;inc hl 
1a9f			;	;ex de,hl 
1a9f			;	;ld hl, (os_tok_malloc) 
1a9f			;	;ld (hl),e 
1a9f			;	;inc hl 
1a9f			;	;ld (hl),d 
1a9f			; 
1a9f			; 
1a9f			;	ld hl,(os_tok_malloc) 
1a9f			;if DEBUG_FORTH_PARSE_KEY 
1a9f			;			DMARK "TKU" 
1a9f			;	CALLMONITOR 
1a9f			;endif 
1a9f			; 
1a9f			;	ret 
1a9f			 
1a9f			forthexec: 
1a9f			 
1a9f			; line exec: 
1a9f			; forth parser 
1a9f			 
1a9f			; 
1a9f			;       get current exec line on rsp 
1a9f			 
1a9f				FORTH_RSP_TOS 
1a9f cd de 17			call macro_forth_rsp_tos 
1aa2				endm 
# End of macro FORTH_RSP_TOS
1aa2			 
1aa2			;       restore current pc - hl points to malloc of data 
1aa2			 
1aa2				;ld e, (hl) 
1aa2				;inc hl 
1aa2				;ld d, (hl) 
1aa2				;ex de,hl 
1aa2			 
1aa2			 
1aa2			exec1: 
1aa2 22 76 e6			ld (os_tok_ptr), hl 
1aa5			 
1aa5				; copy our PC to working vars  
1aa5 22 40 eb			ld (cli_ptr), hl 
1aa8 22 3e eb			ld (cli_origptr), hl 
1aab			 
1aab 7e				ld a,(hl) 
1aac fe 7f			cp FORTH_END_BUFFER 
1aae c8				ret z 
1aaf			 
1aaf				; skip any nulls 
1aaf			 
1aaf fe 00			cp 0 
1ab1 20 03			jr nz, .execword 
1ab3 23				inc hl 
1ab4 18 ec			jr exec1 
1ab6			 
1ab6			 
1ab6			.execword: 
1ab6			 
1ab6			 
1ab6			 
1ab6			if DEBUG_FORTH_PARSE_KEY 
1ab6						DMARK "KYQ" 
1ab6				CALLMONITOR 
1ab6			endif 
1ab6			;       while at start of word: 
1ab6			; get start of dict (in user area first) 
1ab6			 
1ab6 21 17 56		ld hl, baseram 
1ab9			;ld hl, sysdict 
1ab9 22 42 eb		ld (cli_nextword),hl 
1abc			;           match word at pc 
1abc			;           exec word 
1abc			;           or push to dsp 
1abc			;           forward to next token 
1abc			;           if line term pop rsp and exit 
1abc			;        
1abc			 
1abc			if DEBUG_FORTH_PARSE_KEY 
1abc						DMARK "KYq" 
1abc				CALLMONITOR 
1abc			endif 
1abc			 
1abc			; 
1abc			; word comp 
1abc			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1abc			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1abc			;    move to start of word  
1abc			;    compare word to cli_token 
1abc			 
1abc			.execpnword:	; HL at start of a word in the dictionary to check 
1abc			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1abc			;	ld (cli_ptr), hl 
1abc			 
1abc 2a 42 eb			ld hl,(cli_nextword) 
1abf			 
1abf cd 62 1b			call forth_tok_next 
1ac2			; tok next start here 
1ac2			;	; TODO skip compiled symbol for now 
1ac2			;	inc hl 
1ac2			; 
1ac2			;	; save pointer to next word 
1ac2			; 
1ac2			;	; hl now points to the address of the next word pointer  
1ac2			;	ld e, (hl) 
1ac2			;	inc hl 
1ac2			;	ld d, (hl) 
1ac2			;	inc l 
1ac2			; 
1ac2			;	ex de,hl 
1ac2			;if DEBUG_FORTH_PARSE_NEXTWORD 
1ac2			;	push bc 
1ac2			;	ld bc, (cli_nextword) 
1ac2			;			DMARK "NXW" 
1ac2			;	CALLMONITOR 
1ac2			;	pop bc 
1ac2			;endif 
1ac2			; tok next end here 
1ac2 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1ac5 eb				ex de, hl 
1ac6			 
1ac6			 
1ac6				; save the pointer of the current token - 1 to check against 
1ac6				 
1ac6 22 46 eb			ld (cli_token), hl   
1ac9				; TODO maybe remove below save if no debug 
1ac9				; save token string ptr for any debug later 
1ac9 23				inc hl  
1aca 22 48 eb			ld (cli_origtoken), hl 
1acd 2b				dec hl 
1ace				; save pointer to the start of the next dictionay word 
1ace 7e				ld a,(hl)   ; get string length 
1acf 47				ld b,a 
1ad0			.execpnwordinc:  
1ad0 23				inc hl 
1ad1 10 fd			djnz .execpnwordinc 
1ad3 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
1ad6			 
1ad6				; now check the word token against the string being parsed 
1ad6			 
1ad6 2a 46 eb			ld hl,(cli_token) 
1ad9 23				inc hl     ; skip string length (use zero term instead to end) 
1ada 22 46 eb			ld (cli_token), hl 
1add			 
1add			if DEBUG_FORTH_PARSE_KEY 
1add						DMARK "KY2" 
1add			endif 
1add			if DEBUG_FORTH_PARSE_EXEC 
1add				; see if disabled 
1add			 
1add				ld a, (os_view_disable) 
1add				cp '*' 
1add				jr z, .skip 
1add			 
1add				push hl 
1add				push hl 
1add				call clear_display 
1add				ld de, .compword 
1add				ld a, display_row_1 
1add				call str_at_display 
1add				pop de 
1add				ld a, display_row_2 
1add				call str_at_display 
1add				ld hl,(cli_ptr) 
1add				ld a,(hl) 
1add			        ld hl, os_word_scratch 
1add				ld (hl),a 
1add				ld a,0 
1add				inc hl 
1add				ld (hl),a 	 
1add				ld de, os_word_scratch 
1add				ld a, display_row_2+10 
1add				call str_at_display 
1add				call update_display 
1add				ld a, 100 
1add				call aDelayInMS 
1add				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1add				call delay250ms 
1add				endif 
1add				pop hl 
1add			.skip:  
1add			endif	 
1add			.execpnchar:    ; compare char between token and string to parse 
1add			 
1add			if DEBUG_FORTH_PARSE_KEY 
1add						DMARK "Ky3" 
1add			endif 
1add			if DEBUG_FORTH_PARSE_EXEC 
1add				; see if disabled 
1add			 
1add				ld a, (os_view_disable) 
1add				cp '*' 
1add				jr z, .skip2 
1add			 
1add			;	call clear_display 
1add			ld hl,(cli_token) 
1add			ld a,(hl) 
1add			ld (os_word_scratch),a 
1add				ld hl,(cli_ptr) 
1add			ld a,(hl) 
1add				ld (os_word_scratch+1),a 
1add				ld a,0 
1add				ld (os_word_scratch+2),a 
1add				ld de,os_word_scratch 
1add				ld a,display_row_4 
1add				call str_at_display 
1add				call update_display 
1add			.skip2:  
1add			endif 
1add 2a 46 eb			ld hl,(cli_token) 
1ae0 7e				ld a, (hl)	 ; char in word token 
1ae1 23				inc hl 		; move to next char 
1ae2 22 46 eb			ld (cli_token), hl ; and save it 
1ae5 47				ld b,a 
1ae6			 
1ae6 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1ae9 7e				ld a,(hl) 
1aea 23				inc hl 
1aeb 22 40 eb			ld (cli_ptr), hl		; move to next char 
1aee cd 17 0f			call toUpper 		; make sure the input string matches case 
1af1			 
1af1			if DEBUG_FORTH_PARSE 
1af1			endif 
1af1			 
1af1				; input stream end of token is a space so get rid of it 
1af1			 
1af1			;	cp ' ' 
1af1			;	jr nz, .pnskipspace 
1af1			; 
1af1			;	ld a, 0		; make same term as word token term 
1af1			; 
1af1			;.pnskipspace: 
1af1			 
1af1			if DEBUG_FORTH_PARSE_KEY 
1af1						DMARK "KY7" 
1af1			endif 
1af1 b8				cp b 
1af2 c2 08 1b			jp nz, .execpnskipword	 ; no match so move to next word 
1af5				 
1af5			;    if same 
1af5			;       scan for string terms 0 for token and 32 for input 
1af5			 
1af5				 
1af5			if DEBUG_FORTH_PARSE_KEY 
1af5						DMARK "KY8" 
1af5			endif 
1af5			 
1af5 80				add b			 
1af6 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1af8							; TODO need to make sure last word in zero term string is accounted for 
1af8 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1afa			 
1afa			 
1afa				; at end of both strings so both are exact match 
1afa			 
1afa			;       skip ptr for next word 
1afa			 
1afa 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
1afd 23				inc hl			 ; at next char 
1afe 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
1b01 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1b04				 
1b04				 
1b04			if DEBUG_FORTH_PARSE_KEY 
1b04						DMARK "KY3" 
1b04			endif 
1b04			 
1b04			 
1b04			 
1b04			;       exec code block 
1b04			if DEBUG_FORTH_JP 
1b04				call clear_display 
1b04				call update_display 
1b04				call delay1s 
1b04				ld hl, (cli_execword)     ; save for next check if no match on this word 
1b04				ld a,h 
1b04				ld hl, os_word_scratch 
1b04				call hexout 
1b04				ld hl, (cli_execword)     ; save for next check if no match on this word 
1b04				ld a,l 
1b04				ld hl, os_word_scratch+2 
1b04				call hexout 
1b04				ld hl, os_word_scratch+4 
1b04				ld a,0 
1b04				ld (hl),a 
1b04				ld de,os_word_scratch 
1b04				call str_at_display 
1b04					ld a, display_row_2 
1b04					call str_at_display 
1b04				ld de, (cli_origtoken) 
1b04				ld a, display_row_1+10 
1b04					call str_at_display 
1b04			 
1b04				ld a,display_row_1 
1b04				ld de, .foundword 
1b04				ld a, display_row_3 
1b04				call str_at_display 
1b04				call update_display 
1b04				call delay1s 
1b04				call delay1s 
1b04				call delay1s 
1b04			endif 
1b04			 
1b04			if DEBUG_FORTH_PARSE_KEY 
1b04						DMARK "KYj" 
1b04			endif 
1b04				; TODO save the word pointer in this exec 
1b04			 
1b04 2a 44 eb			ld hl,(cli_execword) 
1b07 e9				jp (hl) 
1b08			 
1b08			 
1b08			;    if not same 
1b08			;	scan for zero term 
1b08			;	get ptr for next word 
1b08			;	goto word comp 
1b08			 
1b08			.execpnskipword:	; get pointer to next word 
1b08 2a 42 eb			ld hl,(cli_nextword) 
1b0b			 
1b0b 7e				ld a,(hl) 
1b0c fe 00			cp WORD_SYS_END 
1b0e			;	cp 0 
1b0e 28 09			jr z, .execendofdict			 ; at end of words 
1b10			 
1b10			if DEBUG_FORTH_PARSE_KEY 
1b10						DMARK "KY4" 
1b10			endif 
1b10			if DEBUG_FORTH_PARSE_EXEC 
1b10			 
1b10				; see if disabled 
1b10			 
1b10				ld a, (os_view_disable) 
1b10				cp '*' 
1b10				jr z, .noskip 
1b10			 
1b10			 
1b10				ld de, .nowordfound 
1b10				ld a, display_row_3 
1b10				call str_at_display 
1b10				call update_display 
1b10				ld a, 100 
1b10				call aDelayInMS 
1b10				 
1b10				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b10					call delay250ms 
1b10				endif 
1b10			.noskip:  
1b10			 
1b10			endif	 
1b10			 
1b10 2a 3e eb			ld hl,(cli_origptr) 
1b13 22 40 eb			ld (cli_ptr),hl 
1b16			 
1b16			if DEBUG_FORTH_PARSE_KEY 
1b16						DMARK "KY5" 
1b16			endif 
1b16 c3 bc 1a			jp .execpnword			; else go to next word 
1b19			 
1b19			.execendofdict:  
1b19			 
1b19			if DEBUG_FORTH_PARSE_KEY 
1b19						DMARK "KYe" 
1b19			endif 
1b19			if DEBUG_FORTH_PARSE_EXEC 
1b19				; see if disabled 
1b19			 
1b19				ld a, (os_view_disable) 
1b19				cp '*' 
1b19				jr z, .ispskip 
1b19			 
1b19				call clear_display 
1b19				call update_display 
1b19				call delay1s 
1b19				ld de, (cli_origptr) 
1b19				ld a, display_row_1 
1b19				call str_at_display 
1b19				 
1b19				ld de, .enddict 
1b19				ld a, display_row_3 
1b19				call str_at_display 
1b19				call update_display 
1b19				ld a, 100 
1b19				call aDelayInMS 
1b19				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b19				call delay1s 
1b19				call delay1s 
1b19				call delay1s 
1b19				endif 
1b19			.ispskip:  
1b19				 
1b19			endif	 
1b19			 
1b19			 
1b19			 
1b19				; if the word is not a keyword then must be a literal so push it to stack 
1b19			 
1b19			; push token to stack to end of word 
1b19			 
1b19				STACKFRAME ON $1efe $2f9f 
1b19				if DEBUG_STACK_IMB 
1b19					if ON 
1b19						exx 
1b19						ld de, $1efe 
1b19						ld a, d 
1b19						ld hl, curframe 
1b19						call hexout 
1b19						ld a, e 
1b19						ld hl, curframe+2 
1b19						call hexout 
1b19						ld hl, $1efe 
1b19						push hl 
1b19						ld hl, $2f9f 
1b19						push hl 
1b19						exx 
1b19					endif 
1b19				endif 
1b19			endm 
# End of macro STACKFRAME
1b19			 
1b19 2a 76 e6		ld hl,(os_tok_ptr) 
1b1c cd 68 18		call forth_apush 
1b1f			 
1b1f				STACKFRAMECHK ON $1efe $2f9f 
1b1f				if DEBUG_STACK_IMB 
1b1f					if ON 
1b1f						exx 
1b1f						ld hl, $2f9f 
1b1f						pop de   ; $2f9f 
1b1f						call cmp16 
1b1f						jr nz, .spnosame 
1b1f						ld hl, $1efe 
1b1f						pop de   ; $1efe 
1b1f						call cmp16 
1b1f						jr z, .spfrsame 
1b1f						.spnosame: call showsperror 
1b1f						.spfrsame: nop 
1b1f						exx 
1b1f					endif 
1b1f				endif 
1b1f			endm 
# End of macro STACKFRAMECHK
1b1f			 
1b1f			execnext: 
1b1f			 
1b1f			if DEBUG_FORTH_PARSE_KEY 
1b1f						DMARK "KY>" 
1b1f			endif 
1b1f			; move past token to next word 
1b1f			 
1b1f 2a 76 e6		ld hl, (os_tok_ptr) 
1b22 3e 00		ld a, 0 
1b24 01 ff 00		ld bc, 255     ; input buffer size 
1b27 ed b1		cpir 
1b29			 
1b29			if DEBUG_FORTH_PARSE_KEY 
1b29						DMARK "KY!" 
1b29				CALLMONITOR 
1b29			endif	 
1b29			; TODO this might place hl on the null, so will need to forward on??? 
1b29			;inc hl   ; see if this gets onto the next item 
1b29			 
1b29			 
1b29			; TODO pass a pointer to the buffer to push 
1b29			; TODO call function to push 
1b29			 
1b29			; look for end of input 
1b29			 
1b29			;inc hl 
1b29			;ld a,(hl) 
1b29			;cp FORTH_END_BUFFER 
1b29			;ret z 
1b29			 
1b29			 
1b29 c3 a2 1a		jp exec1 
1b2c			 
1b2c			 
1b2c			 
1b2c			 
1b2c			 
1b2c			 
1b2c			 
1b2c			 
1b2c			 
1b2c			findnexttok: 
1b2c			 
1b2c				; hl is pointer to move 
1b2c				; de is the token to locate 
1b2c			 
1b2c					if DEBUG_FORTH 
1b2c						DMARK "NTK" 
1b2c						CALLMONITOR 
1b2c					endif 
1b2c d5				push de 
1b2d			 
1b2d			.fnt1:	 
1b2d				; find first char of token to locate 
1b2d			 
1b2d 1a				ld a, (de) 
1b2e 4f				ld c,a 
1b2f 7e				ld a,(hl) 
1b30 cd 17 0f			call toUpper 
1b33					if DEBUG_FORTH 
1b33						DMARK "NT1" 
1b33						CALLMONITOR 
1b33					endif 
1b33 b9				cp c 
1b34			 
1b34 28 03			jr z, .fnt2cmpmorefirst	 
1b36			 
1b36				; first char not found move to next char 
1b36			 
1b36 23				inc hl 
1b37 18 f4			jr .fnt1 
1b39			 
1b39			.fnt2cmpmorefirst:	 
1b39				; first char of token found.  
1b39			 
1b39 e5				push hl     ; save start of token just in case it is the right one 
1b3a d9				exx 
1b3b e1				pop hl        ; save it to hl' 
1b3c d9				exx 
1b3d			 
1b3d			 
1b3d			.fnt2cmpmore:	 
1b3d				; compare the rest 
1b3d				 
1b3d 23				inc hl 
1b3e 13				inc de 
1b3f				 
1b3f 1a				ld a, (de) 
1b40 4f				ld c,a 
1b41 7e				ld a,(hl) 
1b42 cd 17 0f			call toUpper 
1b45			 
1b45					if DEBUG_FORTH 
1b45						DMARK "NT2" 
1b45						CALLMONITOR 
1b45					endif 
1b45				; c has the token to find char 
1b45				; a has the mem to scan char 
1b45			 
1b45 b9				cp c 
1b46 28 04			jr z,.fntmatch1 
1b48			 
1b48				; they are not the same 
1b48			 
1b48					if DEBUG_FORTH 
1b48						DMARK "NT3" 
1b48						CALLMONITOR 
1b48					endif 
1b48 d1				pop de	; reset de token to look for 
1b49 d5				push de 
1b4a 18 e1			jr .fnt1 
1b4c				 
1b4c			.fntmatch1: 
1b4c			 
1b4c				; is the same char a null which means we might have a full hit? 
1b4c					if DEBUG_FORTH 
1b4c						DMARK "NT4" 
1b4c						CALLMONITOR 
1b4c					endif 
1b4c			 
1b4c fe 00			cp 0 
1b4e 28 0b			jr z, .fntmatchyes 
1b50			 
1b50				; are we at the end of the token to find? 
1b50			 
1b50					if DEBUG_FORTH 
1b50						DMARK "NT5" 
1b50						CALLMONITOR 
1b50					endif 
1b50 3e 00			ld a, 0 
1b52 b9				cp c 
1b53			 
1b53 c2 3d 1b			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1b56			 
1b56					if DEBUG_FORTH 
1b56						DMARK "NT6" 
1b56						CALLMONITOR 
1b56					endif 
1b56				; token to find is exhusted but no match to stream 
1b56			 
1b56				; restore tok pointer and continue on 
1b56 d1				pop de 
1b57 d5				push de 
1b58 c3 2d 1b			jp .fnt1 
1b5b			 
1b5b			 
1b5b			.fntmatchyes: 
1b5b			 
1b5b				; hl now contains the end of the found token 
1b5b			 
1b5b				; get rid of saved token pointer to find 
1b5b			 
1b5b d1				pop de 
1b5c			 
1b5c					if DEBUG_FORTH 
1b5c						DMARK "NT9" 
1b5c						CALLMONITOR 
1b5c					endif 
1b5c			 
1b5c				; hl will be on the null term so forward on 
1b5c			 
1b5c				; get back the saved start of the token 
1b5c			 
1b5c d9				exx 
1b5d e5				push hl     ; save start of token just in case it is the right one 
1b5e d9				exx 
1b5f e1				pop hl        ; save it to hl 
1b60			 
1b60 c9				ret 
1b61			 
1b61			 
1b61			; LIST needs to find a specific token   
1b61			; FORGET needs to find a spefici token 
1b61			 
1b61			; SAVE needs to find all tokens by flag 
1b61			; WORDS just needs to scan through all  by flag 
1b61			; UWORDS needs to scan through all by flag 
1b61			 
1b61			 
1b61			; given hl as pointer to start of dict look up string 
1b61			; return hl as pointer to start of word block 
1b61			; or 0 if not found 
1b61			 
1b61			forth_find_tok: 
1b61 c9				ret 
1b62			 
1b62			; given hl as pointer to dict structure 
1b62			; move to the next dict block structure 
1b62			 
1b62			forth_tok_next: 
1b62				; hl now points to the address of the next word pointer  
1b62				; TODO skip compiled symbol for now 
1b62			;	push de 
1b62 23				inc hl 
1b63 5e				ld e, (hl) 
1b64 23				inc hl 
1b65 56				ld d, (hl) 
1b66 23				inc hl 
1b67			 
1b67 eb				ex de,hl 
1b68			if DEBUG_FORTH_PARSE_NEXTWORD 
1b68				push bc 
1b68				ld bc, (cli_nextword) 
1b68						DMARK "NXW" 
1b68				CALLMONITOR 
1b68				pop bc 
1b68			endif 
1b68			;	pop de	 
1b68 c9				ret 
1b69			 
1b69			 
1b69			 
1b69			; eof 
# End of file forth_parserv5.asm
1b69				include "forth_wordsv4.asm" 
1b69			 
1b69			; the core word dictionary v4 
1b69			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1b69			 
1b69			; this is a linked list for each of the system words used 
1b69			; user defined words will follow the same format but will be in ram 
1b69			 
1b69			 
1b69			; 
1b69			; 
1b69			; define linked list: 
1b69			; 
1b69			; 1. compiled byte op code 
1b69			; 2. len of text word 
1b69			; 3. text word 
1b69			; 4. ptr to next dictionary word 
1b69			; 5. asm, calls etc for the word 
1b69			; 
1b69			;  if 1 == 0 then last word in dict  
1b69			;   
1b69			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1b69			;  
1b69			;  
1b69			; create basic standard set of words 
1b69			; 
1b69			;  
1b69			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1b69			; 2DUP 2DROP 2SWAP  
1b69			; @ C@ - get byte  
1b69			; ! C! - store byte 
1b69			; 0< true if less than zero 
1b69			; 0= true if zero 
1b69			; < >  
1b69			; = true if same 
1b69			; variables 
1b69			 
1b69			 
1b69			; Hardware specific words I may need 
1b69			; 
1b69			; IN OUT  
1b69			; calls to key util functions 
1b69			; calls to hardward abstraction stuff 
1b69			; easy control of frame buffers and lcd i/o 
1b69			; keyboard  
1b69			 
1b69			 
1b69			;DICT: macro 
1b69			; op_code, len, word, next 
1b69			;    word: 
1b69			;    db op_code 
1b69			;    ds word zero term 
1b69			;    dw next 
1b69			;    endm 
1b69			 
1b69			 
1b69			 
1b69			 
1b69			; op code 1 is a flag for user define words which are to be handled differently 
1b69			 
1b69			 
1b69			; 
1b69			; 
1b69			;    TODO on entry to a word this should be the expected environment 
1b69			;    hl - tos value if number then held, if string this is the ptr 
1b69			;    de -  
1b69			 
1b69			 
1b69			; opcode ranges 
1b69			; 0 - end of word dict 
1b69			; 255 - user define words 
1b69			 
1b69			sysdict: 
1b69			include "forth_opcodes.asm" 
1b69			; op codes for forth keywords 
1b69			; free to use code 0  
1b69				OPCODE_HEAP: equ  1 
1b69				OPCODE_EXEC: equ 2 
1b69				OPCODE_DUP: equ 3 
1b69				OPCODE_SWAP: equ 4 
1b69				OPCODE_COLN: equ 5 
1b69				OPCODE_SCOLN: equ 6 
1b69				OPCODE_DROP: equ 7 
1b69				OPCODE_DUP2: equ 8 
1b69				OPCODE_DROP2: equ 9 
1b69				OPCODE_SWAP2: equ 10 
1b69				OPCODE_AT: equ 11 
1b69				OPCODE_CAT: equ 12 
1b69				OPCODE_BANG: equ 13 
1b69				OPCODE_CBANG: equ 14 
1b69				OPCODE_SCALL: equ 15 
1b69				OPCODE_DEPTH: equ 16 
1b69				OPCODE_OVER: equ 17 
1b69				OPCODE_PAUSE: equ 18 
1b69				OPCODE_PAUSES: equ 19 
1b69				OPCODE_ROT: equ 20 
1b69			;free to reuse	OPCODE_WORDS: equ 21 
1b69			        OPCODE_NOT: equ 21 
1b69				OPCODE_UWORDS: equ 22 
1b69				OPCODE_BP: equ 23 
1b69				OPCODE_MONITOR: equ 24  
1b69				OPCODE_MALLOC: equ 25 
1b69				OPCODE_FREE: equ 26 
1b69				OPCODE_LIST: equ 27 
1b69				OPCODE_FORGET: equ 28 
1b69				OPCODE_NOP: equ 29 
1b69				OPCODE_COMO: equ 30 
1b69				OPCODE_COMC: equ 31 
1b69			;free to reuse	OPCODE_ENDCORE: equ 32 
1b69				OPCODE_AFTERSOUND: equ 33 
1b69				OPCODE_GP2: equ 34 
1b69				OPCODE_GP3: equ 35 
1b69				OPCODE_GP4: equ 36 
1b69				OPCODE_SIN: equ 37 
1b69				OPCODE_SOUT: equ 38 
1b69				OPCODE_SPIO: equ 39 
1b69				OPCODE_SPICEH: equ 40 
1b69				OPCODE_SPIOb: equ 41 
1b69				OPCODE_SPII: equ 42 
1b69				OPCODE_SESEL: equ 43 
1b69				OPCODE_CARTDEV: equ 44 
1b69			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1b69				OPCODE_FB: equ 46 
1b69				OPCODE_EMIT: equ 47 
1b69				OPCODE_DOTH: equ 48 
1b69				OPCODE_DOTF: equ 49 
1b69				OPCODE_DOT: equ 50 
1b69				OPCODE_CLS: equ 51 
1b69				OPCODE_DRAW: equ 52 
1b69				OPCODE_DUMP: equ 53 
1b69				OPCODE_CDUMP: equ 54 
1b69				OPCODE_DAT: equ 55 
1b69				OPCODE_HOME: equ 56 
1b69				OPCODE_SPACE: equ 57 
1b69				OPCODE_SPACES: equ 58 
1b69				OPCODE_SCROLL: equ 59 
1b69				OPCODE_ATQ: equ 60 
1b69				OPCODE_AUTODSP: equ 61 
1b69				OPCODE_MENU: equ 62 
1b69			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1b69				OPCODE_THEN: equ 64 
1b69				OPCODE_ELSE: equ 65 
1b69				OPCODE_DO: equ 66 
1b69				OPCODE_LOOP: equ 67 
1b69				OPCODE_I: equ 68 
1b69				OPCODE_DLOOP: equ 69  
1b69				OPCODE_REPEAT: equ 70  
1b69				OPCODE_UNTIL: equ 71 
1b69				OPCODE_ENDFLOW: equ 72 
1b69				OPCODE_WAITK: equ 73 
1b69				OPCODE_ACCEPT: equ 74 
1b69				OPCODE_EDIT: equ 75 
1b69			;free to reuse	OPCODE_ENDKEY: equ 76 
1b69				OPCODE_LZERO: equ 77 
1b69				OPCODE_TZERO: equ 78 
1b69				OPCODE_LESS: equ 79 
1b69				OPCODE_GT: equ 80 
1b69				OPCODE_EQUAL: equ 81  
1b69			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1b69				OPCODE_NEG: equ 83 
1b69				OPCODE_DIV: equ 84 
1b69				OPCODE_MUL: equ 85 
1b69				OPCODE_MIN: equ 86 
1b69				OPCODE_MAX: equ 87 
1b69				OPCODE_RND16: equ 88 
1b69				OPCODE_RND8: equ 89 
1b69				OPCODE_RND: equ 90 
1b69			;free to reuse	OPCODE_ENDMATHS: equ 91  
1b69				OPCODE_BYNAME: equ 92 
1b69				OPCODE_DIR: equ 93 
1b69				OPCODE_SAVE: equ 94 
1b69				OPCODE_LOAD: equ 95 
1b69				OPCODE_BSAVE: equ 96 
1b69				OPCODE_BLOAD: equ 97 
1b69				OPCODE_SEO: equ 98  
1b69				OPCODE_SEI: equ 99 
1b69				OPCODE_SFREE: equ 100 
1b69				OPCODE_SIZE: equ 101 
1b69				OPCODE_CREATE: equ 102 
1b69				OPCODE_APPEND: equ 103 
1b69				OPCODE_SDEL: equ 104 
1b69				OPCODE_OPEN: equ 105 
1b69				OPCODE_READ: equ 106 
1b69				OPCODE_EOF: equ 106 
1b69				OPCODE_FORMAT: equ 107 
1b69				OPCODE_LABEL: equ 108 
1b69				OPCODE_LABELS: equ 109 
1b69			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1b69				OPCODE_UPPER: equ 111 
1b69				OPCODE_LOWER: equ 112 
1b69				OPCODE_SUBSTR: equ 113 
1b69				OPCODE_LEFT: equ 114 
1b69				OPCODE_RIGHT: equ 115 
1b69				OPCODE_STR2NUM: equ 116 
1b69				OPCODE_NUM2STR: equ 117 
1b69				OPCODE_CONCAT: equ 118 
1b69				OPCODE_FIND: equ 119 
1b69				OPCODE_LEN: equ 120 
1b69				OPCODE_CHAR: equ 121 
1b69			; free to reuse	OPCODE_STRLEN: equ 122 
1b69			; free to reuse	OPCODE_ENDSTR: equ 123 
1b69				OPCODE_V0S: equ 124 
1b69				OPCODE_V0Q: equ 125 
1b69				OPCODE_V1S: equ 126 
1b69				OPCODE_V1Q: equ 127 
1b69				OPCODE_V2S: equ 128 
1b69				OPCODE_V2Q: equ 129 
1b69				OPCODE_V3S: equ 130 
1b69				OPCODE_V3Q: equ 131 
1b69			;free to reuse	OPCODE_END: equ 132 
1b69				OPCODE_ZDUP: equ 133 
1b69			 
1b69			; eof 
# End of file forth_opcodes.asm
1b69			 
1b69			include "forth_words_core.asm" 
1b69			 
1b69			; | ## Core Words 
1b69			 
1b69			;if MALLOC_4 
1b69			 
1b69			.HEAP: 
1b69				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1b69 15				db WORD_SYS_CORE+OPCODE_HEAP             
1b6a a8 1b			dw .EXEC            
1b6c 05				db 4 + 1 
1b6d .. 00			db "HEAP",0              
1b72				endm 
# End of macro CWHEAD
1b72			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1b72			; | | u1 - Current number of bytes in the heap 
1b72			; | | u2 - Remaining bytes left on the heap 
1b72			; | |  
1b72			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1b72			 
1b72			 
1b72					if DEBUG_FORTH_WORDS_KEY 
1b72						DMARK "HEP" 
1b72 f5				push af  
1b73 3a 87 1b			ld a, (.dmark)  
1b76 32 7a ee			ld (debug_mark),a  
1b79 3a 88 1b			ld a, (.dmark+1)  
1b7c 32 7b ee			ld (debug_mark+1),a  
1b7f 3a 89 1b			ld a, (.dmark+2)  
1b82 32 7c ee			ld (debug_mark+2),a  
1b85 18 03			jr .pastdmark  
1b87 ..			.dmark: db "HEP"  
1b8a f1			.pastdmark: pop af  
1b8b			endm  
# End of macro DMARK
1b8b						CALLMONITOR 
1b8b cd 86 12			call break_point_state  
1b8e				endm  
# End of macro CALLMONITOR
1b8e					endif 
1b8e 2a 21 56				ld hl, (free_list )      
1b91 11 26 56				ld de, heap_start 
1b94			 
1b94 ed 52				sbc hl, de  
1b96			 
1b96 cd 20 18				call forth_push_numhl 
1b99			 
1b99			 
1b99 ed 5b 21 56			ld de, (free_list )      
1b9d 21 69 e3				ld hl, heap_end 
1ba0			 
1ba0 ed 52				sbc hl, de 
1ba2			 
1ba2 cd 20 18				call forth_push_numhl 
1ba5					 
1ba5			 
1ba5					 
1ba5			 
1ba5			 
1ba5			 
1ba5					NEXTW 
1ba5 c3 11 1a			jp macro_next 
1ba8				endm 
# End of macro NEXTW
1ba8			;endif 
1ba8			 
1ba8			.EXEC: 
1ba8				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1ba8 16				db WORD_SYS_CORE+OPCODE_EXEC             
1ba9 44 1c			dw .STKEXEC            
1bab 05				db 4 + 1 
1bac .. 00			db "EXEC",0              
1bb1				endm 
# End of macro CWHEAD
1bb1			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1bb1			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1bb1			; | | 
1bb1			; | |   
1bb1				STACKFRAME OFF $5efe $5f9f 
1bb1				if DEBUG_STACK_IMB 
1bb1					if OFF 
1bb1						exx 
1bb1						ld de, $5efe 
1bb1						ld a, d 
1bb1						ld hl, curframe 
1bb1						call hexout 
1bb1						ld a, e 
1bb1						ld hl, curframe+2 
1bb1						call hexout 
1bb1						ld hl, $5efe 
1bb1						push hl 
1bb1						ld hl, $5f9f 
1bb1						push hl 
1bb1						exx 
1bb1					endif 
1bb1				endif 
1bb1			endm 
# End of macro STACKFRAME
1bb1			 
1bb1					if DEBUG_FORTH_WORDS_KEY 
1bb1						DMARK "EXE" 
1bb1 f5				push af  
1bb2 3a c6 1b			ld a, (.dmark)  
1bb5 32 7a ee			ld (debug_mark),a  
1bb8 3a c7 1b			ld a, (.dmark+1)  
1bbb 32 7b ee			ld (debug_mark+1),a  
1bbe 3a c8 1b			ld a, (.dmark+2)  
1bc1 32 7c ee			ld (debug_mark+2),a  
1bc4 18 03			jr .pastdmark  
1bc6 ..			.dmark: db "EXE"  
1bc9 f1			.pastdmark: pop af  
1bca			endm  
# End of macro DMARK
1bca						CALLMONITOR 
1bca cd 86 12			call break_point_state  
1bcd				endm  
# End of macro CALLMONITOR
1bcd					endif 
1bcd			 
1bcd				FORTH_DSP_VALUEHL 
1bcd cd bb 18			call macro_dsp_valuehl 
1bd0				endm 
# End of macro FORTH_DSP_VALUEHL
1bd0			 
1bd0				FORTH_DSP_POP 
1bd0 cd 57 19			call macro_forth_dsp_pop 
1bd3				endm 
# End of macro FORTH_DSP_POP
1bd3			 
1bd3					if DEBUG_FORTH_WORDS 
1bd3						DMARK "EX1" 
1bd3 f5				push af  
1bd4 3a e8 1b			ld a, (.dmark)  
1bd7 32 7a ee			ld (debug_mark),a  
1bda 3a e9 1b			ld a, (.dmark+1)  
1bdd 32 7b ee			ld (debug_mark+1),a  
1be0 3a ea 1b			ld a, (.dmark+2)  
1be3 32 7c ee			ld (debug_mark+2),a  
1be6 18 03			jr .pastdmark  
1be8 ..			.dmark: db "EX1"  
1beb f1			.pastdmark: pop af  
1bec			endm  
# End of macro DMARK
1bec						CALLMONITOR 
1bec cd 86 12			call break_point_state  
1bef				endm  
# End of macro CALLMONITOR
1bef					endif 
1bef			;	ld e,(hl) 
1bef			;	inc hl 
1bef			;	ld d,(hl) 
1bef			;	ex de,hl 
1bef			 
1bef			;		if DEBUG_FORTH_WORDS 
1bef			;			DMARK "EX2" 
1bef			;			CALLMONITOR 
1bef			;		endif 
1bef e5				push hl 
1bf0			 
1bf0				;ld a, 0 
1bf0				;ld a, FORTH_END_BUFFER 
1bf0 cd 20 0f			call strlenz 
1bf3 23				inc hl   ; include zero term to copy 
1bf4 23				inc hl   ; include term 
1bf5 23				inc hl   ; include term 
1bf6 06 00			ld b,0 
1bf8 4d				ld c,l 
1bf9 e1				pop hl 
1bfa 11 74 e4			ld de, execscratch 
1bfd					if DEBUG_FORTH_WORDS 
1bfd						DMARK "EX3" 
1bfd f5				push af  
1bfe 3a 12 1c			ld a, (.dmark)  
1c01 32 7a ee			ld (debug_mark),a  
1c04 3a 13 1c			ld a, (.dmark+1)  
1c07 32 7b ee			ld (debug_mark+1),a  
1c0a 3a 14 1c			ld a, (.dmark+2)  
1c0d 32 7c ee			ld (debug_mark+2),a  
1c10 18 03			jr .pastdmark  
1c12 ..			.dmark: db "EX3"  
1c15 f1			.pastdmark: pop af  
1c16			endm  
# End of macro DMARK
1c16						CALLMONITOR 
1c16 cd 86 12			call break_point_state  
1c19				endm  
# End of macro CALLMONITOR
1c19					endif 
1c19 ed b0			ldir 
1c1b			 
1c1b			 
1c1b 21 74 e4			ld hl, execscratch 
1c1e			 
1c1e					if DEBUG_FORTH_WORDS 
1c1e						DMARK "EXe" 
1c1e f5				push af  
1c1f 3a 33 1c			ld a, (.dmark)  
1c22 32 7a ee			ld (debug_mark),a  
1c25 3a 34 1c			ld a, (.dmark+1)  
1c28 32 7b ee			ld (debug_mark+1),a  
1c2b 3a 35 1c			ld a, (.dmark+2)  
1c2e 32 7c ee			ld (debug_mark+2),a  
1c31 18 03			jr .pastdmark  
1c33 ..			.dmark: db "EXe"  
1c36 f1			.pastdmark: pop af  
1c37			endm  
# End of macro DMARK
1c37						CALLMONITOR 
1c37 cd 86 12			call break_point_state  
1c3a				endm  
# End of macro CALLMONITOR
1c3a					endif 
1c3a			 
1c3a cd 5f 1a			call forthparse 
1c3d cd 9f 1a			call forthexec 
1c40			;	call forthexec_cleanup 
1c40			;	call forthparse 
1c40			;	call forthexec 
1c40			 
1c40				STACKFRAMECHK OFF $5efe $5f9f 
1c40				if DEBUG_STACK_IMB 
1c40					if OFF 
1c40						exx 
1c40						ld hl, $5f9f 
1c40						pop de   ; $5f9f 
1c40						call cmp16 
1c40						jr nz, .spnosame 
1c40						ld hl, $5efe 
1c40						pop de   ; $5efe 
1c40						call cmp16 
1c40						jr z, .spfrsame 
1c40						.spnosame: call showsperror 
1c40						.spfrsame: nop 
1c40						exx 
1c40					endif 
1c40				endif 
1c40			endm 
# End of macro STACKFRAMECHK
1c40			 
1c40				; an immediate word so no need to process any more words 
1c40 c9				ret 
1c41				NEXTW 
1c41 c3 11 1a			jp macro_next 
1c44				endm 
# End of macro NEXTW
1c44			 
1c44			; dead code - old version  
1c44			;	FORTH_RSP_NEXT 
1c44			 
1c44			;  
1c44			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1c44			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1c44			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1c44			;	push hl 
1c44			;	push de 
1c44			;	push bc 
1c44			; 
1c44			; 
1c44			;		if DEBUG_FORTH_WORDS_KEY 
1c44			;			DMARK "EXR" 
1c44			;			CALLMONITOR 
1c44			;		endif 
1c44			; 
1c44			; 
1c44			; 
1c44			;	;v5 FORTH_DSP_VALUE 
1c44			;	FORTH_DSP_VALUEHL 
1c44			; 
1c44			;	; TODO do string type checks 
1c44			; 
1c44			;;v5	inc hl   ; skip type 
1c44			; 
1c44			;	push hl  ; source code  
1c44			;		if DEBUG_FORTH_WORDS 
1c44			;			DMARK "EX1" 
1c44			;			CALLMONITOR 
1c44			;		endif 
1c44			;	ld a, 0 
1c44			;	call strlent 
1c44			; 
1c44			;	inc hl 
1c44			;	inc hl 
1c44			;	inc hl 
1c44			;	inc hl 
1c44			; 
1c44			;	push hl    ; size 
1c44			; 
1c44			;		if DEBUG_FORTH_WORDS 
1c44			;			DMARK "EX2" 
1c44			;			CALLMONITOR 
1c44			;		endif 
1c44			;	call malloc 
1c44			; 
1c44			;	ex de, hl    ; de now contains malloc area 
1c44			;	pop bc   	; get byte count 
1c44			;	pop hl      ; get string to copy 
1c44			; 
1c44			;	push de     ; save malloc for free later 
1c44			; 
1c44			;		if DEBUG_FORTH_WORDS 
1c44			;			DMARK "EX3" 
1c44			;			CALLMONITOR 
1c44			;		endif 
1c44			;	ldir       ; duplicate string 
1c44			; 
1c44			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1c44			;	 
1c44			;	; TODO fix the parse would be better than this...  
1c44			;	ex de, hl 
1c44			;	dec hl 
1c44			;	ld a, 0 
1c44			;	ld (hl), a 
1c44			;	dec hl 
1c44			;	ld a, ' ' 
1c44			;	ld (hl), a 
1c44			;	dec hl 
1c44			;	ld (hl), a 
1c44			; 
1c44			;	dec hl 
1c44			;	ld (hl), a 
1c44			; 
1c44			; 
1c44			;	FORTH_DSP_POP  
1c44			; 
1c44			;	pop hl     
1c44			;	push hl    ; save malloc area 
1c44			; 
1c44			;		if DEBUG_FORTH_WORDS 
1c44			;			DMARK "EX4" 
1c44			;			CALLMONITOR 
1c44			;		endif 
1c44			; 
1c44			;	call forthparse 
1c44			;	call forthexec 
1c44			;	 
1c44			;	pop hl 
1c44			;	if DEBUG_FORTH_WORDS 
1c44			;		DMARK "EX5" 
1c44			;		CALLMONITOR 
1c44			;	endif 
1c44			; 
1c44			;	if FORTH_ENABLE_FREE 
1c44			;	call free 
1c44			;	endif 
1c44			; 
1c44			;	if DEBUG_FORTH_WORDS 
1c44			;		DMARK "EX6" 
1c44			;		CALLMONITOR 
1c44			;	endif 
1c44			; 
1c44			;	pop bc 
1c44			;	pop de 
1c44			;	pop hl 
1c44			;;	FORTH_RSP_POP	  
1c44			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1c44			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1c44			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1c44			; 
1c44			;	if DEBUG_FORTH_WORDS 
1c44			;		DMARK "EX7" 
1c44			;		CALLMONITOR 
1c44			;	endif 
1c44			;	NEXTW 
1c44			 
1c44			.STKEXEC: 
1c44				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1c44 3f				db WORD_SYS_CORE+43             
1c45 8c 1d			dw .ZDUP            
1c47 08				db 7 + 1 
1c48 .. 00			db "STKEXEC",0              
1c50				endm 
# End of macro CWHEAD
1c50			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1c50			 
1c50			 
1c50					if DEBUG_FORTH_WORDS_KEY 
1c50						DMARK "STX" 
1c50 f5				push af  
1c51 3a 65 1c			ld a, (.dmark)  
1c54 32 7a ee			ld (debug_mark),a  
1c57 3a 66 1c			ld a, (.dmark+1)  
1c5a 32 7b ee			ld (debug_mark+1),a  
1c5d 3a 67 1c			ld a, (.dmark+2)  
1c60 32 7c ee			ld (debug_mark+2),a  
1c63 18 03			jr .pastdmark  
1c65 ..			.dmark: db "STX"  
1c68 f1			.pastdmark: pop af  
1c69			endm  
# End of macro DMARK
1c69						CALLMONITOR 
1c69 cd 86 12			call break_point_state  
1c6c				endm  
# End of macro CALLMONITOR
1c6c					endif 
1c6c			 
1c6c				FORTH_DSP_VALUEHL 
1c6c cd bb 18			call macro_dsp_valuehl 
1c6f				endm 
# End of macro FORTH_DSP_VALUEHL
1c6f			 
1c6f 22 63 eb			ld (store_tmp1), hl    ; count 
1c72			 
1c72				FORTH_DSP_POP 
1c72 cd 57 19			call macro_forth_dsp_pop 
1c75				endm 
# End of macro FORTH_DSP_POP
1c75			.stkexec1: 
1c75 2a 63 eb			ld hl, (store_tmp1)   ; count 
1c78 3e 00			ld a, 0 
1c7a bd				cp l 
1c7b c8				ret z 
1c7c			 
1c7c 2b				dec hl 
1c7d 22 63 eb			ld (store_tmp1), hl    ; count 
1c80				 
1c80				FORTH_DSP_VALUEHL 
1c80 cd bb 18			call macro_dsp_valuehl 
1c83				endm 
# End of macro FORTH_DSP_VALUEHL
1c83 e5				push hl 
1c84				 
1c84					if DEBUG_FORTH_WORDS 
1c84						DMARK "EXp" 
1c84 f5				push af  
1c85 3a 99 1c			ld a, (.dmark)  
1c88 32 7a ee			ld (debug_mark),a  
1c8b 3a 9a 1c			ld a, (.dmark+1)  
1c8e 32 7b ee			ld (debug_mark+1),a  
1c91 3a 9b 1c			ld a, (.dmark+2)  
1c94 32 7c ee			ld (debug_mark+2),a  
1c97 18 03			jr .pastdmark  
1c99 ..			.dmark: db "EXp"  
1c9c f1			.pastdmark: pop af  
1c9d			endm  
# End of macro DMARK
1c9d						CALLMONITOR 
1c9d cd 86 12			call break_point_state  
1ca0				endm  
# End of macro CALLMONITOR
1ca0					endif 
1ca0				FORTH_DSP_POP 
1ca0 cd 57 19			call macro_forth_dsp_pop 
1ca3				endm 
# End of macro FORTH_DSP_POP
1ca3			 
1ca3 cd 20 0f			call strlenz 
1ca6 23				inc hl   ; include zero term to copy 
1ca7 23				inc hl   ; include zero term to copy 
1ca8 23				inc hl   ; include zero term to copy 
1ca9 06 00			ld b,0 
1cab 4d				ld c,l 
1cac e1				pop hl 
1cad 11 74 e4			ld de, execscratch 
1cb0					if DEBUG_FORTH_WORDS 
1cb0						DMARK "EX3" 
1cb0 f5				push af  
1cb1 3a c5 1c			ld a, (.dmark)  
1cb4 32 7a ee			ld (debug_mark),a  
1cb7 3a c6 1c			ld a, (.dmark+1)  
1cba 32 7b ee			ld (debug_mark+1),a  
1cbd 3a c7 1c			ld a, (.dmark+2)  
1cc0 32 7c ee			ld (debug_mark+2),a  
1cc3 18 03			jr .pastdmark  
1cc5 ..			.dmark: db "EX3"  
1cc8 f1			.pastdmark: pop af  
1cc9			endm  
# End of macro DMARK
1cc9						CALLMONITOR 
1cc9 cd 86 12			call break_point_state  
1ccc				endm  
# End of macro CALLMONITOR
1ccc					endif 
1ccc ed b0			ldir 
1cce			 
1cce			 
1cce 21 74 e4			ld hl, execscratch 
1cd1			 
1cd1					if DEBUG_FORTH_WORDS 
1cd1						DMARK "EXP" 
1cd1 f5				push af  
1cd2 3a e6 1c			ld a, (.dmark)  
1cd5 32 7a ee			ld (debug_mark),a  
1cd8 3a e7 1c			ld a, (.dmark+1)  
1cdb 32 7b ee			ld (debug_mark+1),a  
1cde 3a e8 1c			ld a, (.dmark+2)  
1ce1 32 7c ee			ld (debug_mark+2),a  
1ce4 18 03			jr .pastdmark  
1ce6 ..			.dmark: db "EXP"  
1ce9 f1			.pastdmark: pop af  
1cea			endm  
# End of macro DMARK
1cea						CALLMONITOR 
1cea cd 86 12			call break_point_state  
1ced				endm  
# End of macro CALLMONITOR
1ced					endif 
1ced			 
1ced cd 5f 1a			call forthparse 
1cf0 21 74 e4			ld hl, execscratch 
1cf3					if DEBUG_FORTH_WORDS 
1cf3						DMARK "EXx" 
1cf3 f5				push af  
1cf4 3a 08 1d			ld a, (.dmark)  
1cf7 32 7a ee			ld (debug_mark),a  
1cfa 3a 09 1d			ld a, (.dmark+1)  
1cfd 32 7b ee			ld (debug_mark+1),a  
1d00 3a 0a 1d			ld a, (.dmark+2)  
1d03 32 7c ee			ld (debug_mark+2),a  
1d06 18 03			jr .pastdmark  
1d08 ..			.dmark: db "EXx"  
1d0b f1			.pastdmark: pop af  
1d0c			endm  
# End of macro DMARK
1d0c						CALLMONITOR 
1d0c cd 86 12			call break_point_state  
1d0f				endm  
# End of macro CALLMONITOR
1d0f					endif 
1d0f cd 9f 1a			call forthexec 
1d12			 
1d12 c3 75 1c			jp .stkexec1 
1d15			 
1d15 c9				ret 
1d16			 
1d16			 
1d16			.DUP: 
1d16				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1d16 17				db WORD_SYS_CORE+OPCODE_DUP             
1d17 8c 1d			dw .ZDUP            
1d19 04				db 3 + 1 
1d1a .. 00			db "DUP",0              
1d1e				endm 
# End of macro CWHEAD
1d1e			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1d1e			 
1d1e					if DEBUG_FORTH_WORDS_KEY 
1d1e						DMARK "DUP" 
1d1e f5				push af  
1d1f 3a 33 1d			ld a, (.dmark)  
1d22 32 7a ee			ld (debug_mark),a  
1d25 3a 34 1d			ld a, (.dmark+1)  
1d28 32 7b ee			ld (debug_mark+1),a  
1d2b 3a 35 1d			ld a, (.dmark+2)  
1d2e 32 7c ee			ld (debug_mark+2),a  
1d31 18 03			jr .pastdmark  
1d33 ..			.dmark: db "DUP"  
1d36 f1			.pastdmark: pop af  
1d37			endm  
# End of macro DMARK
1d37						CALLMONITOR 
1d37 cd 86 12			call break_point_state  
1d3a				endm  
# End of macro CALLMONITOR
1d3a					endif 
1d3a			 
1d3a					FORTH_DSP 
1d3a cd a0 18			call macro_forth_dsp 
1d3d				endm 
# End of macro FORTH_DSP
1d3d			 
1d3d 7e					ld a, (HL) 
1d3e fe 01				cp DS_TYPE_STR 
1d40 20 25				jr nz, .dupinum 
1d42			 
1d42					; push another string 
1d42			 
1d42					FORTH_DSP_VALUEHL     		 
1d42 cd bb 18			call macro_dsp_valuehl 
1d45				endm 
# End of macro FORTH_DSP_VALUEHL
1d45			 
1d45				if DEBUG_FORTH_WORDS 
1d45					DMARK "DUs" 
1d45 f5				push af  
1d46 3a 5a 1d			ld a, (.dmark)  
1d49 32 7a ee			ld (debug_mark),a  
1d4c 3a 5b 1d			ld a, (.dmark+1)  
1d4f 32 7b ee			ld (debug_mark+1),a  
1d52 3a 5c 1d			ld a, (.dmark+2)  
1d55 32 7c ee			ld (debug_mark+2),a  
1d58 18 03			jr .pastdmark  
1d5a ..			.dmark: db "DUs"  
1d5d f1			.pastdmark: pop af  
1d5e			endm  
# End of macro DMARK
1d5e					CALLMONITOR 
1d5e cd 86 12			call break_point_state  
1d61				endm  
# End of macro CALLMONITOR
1d61				endif 
1d61 cd 32 18				call forth_push_str 
1d64			 
1d64					NEXTW 
1d64 c3 11 1a			jp macro_next 
1d67				endm 
# End of macro NEXTW
1d67			 
1d67			 
1d67			.dupinum: 
1d67					 
1d67			 
1d67			 
1d67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1d67 cd bb 18			call macro_dsp_valuehl 
1d6a				endm 
# End of macro FORTH_DSP_VALUEHL
1d6a			 
1d6a				; TODO add floating point number detection 
1d6a			 
1d6a				if DEBUG_FORTH_WORDS 
1d6a					DMARK "DUi" 
1d6a f5				push af  
1d6b 3a 7f 1d			ld a, (.dmark)  
1d6e 32 7a ee			ld (debug_mark),a  
1d71 3a 80 1d			ld a, (.dmark+1)  
1d74 32 7b ee			ld (debug_mark+1),a  
1d77 3a 81 1d			ld a, (.dmark+2)  
1d7a 32 7c ee			ld (debug_mark+2),a  
1d7d 18 03			jr .pastdmark  
1d7f ..			.dmark: db "DUi"  
1d82 f1			.pastdmark: pop af  
1d83			endm  
# End of macro DMARK
1d83					CALLMONITOR 
1d83 cd 86 12			call break_point_state  
1d86				endm  
# End of macro CALLMONITOR
1d86				endif 
1d86			 
1d86 cd 20 18				call forth_push_numhl 
1d89					NEXTW 
1d89 c3 11 1a			jp macro_next 
1d8c				endm 
# End of macro NEXTW
1d8c			.ZDUP: 
1d8c				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1d8c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1d8d c4 1d			dw .SWAP            
1d8f 05				db 4 + 1 
1d90 .. 00			db "?DUP",0              
1d95				endm 
# End of macro CWHEAD
1d95			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1d95			 
1d95					if DEBUG_FORTH_WORDS_KEY 
1d95						DMARK "qDU" 
1d95 f5				push af  
1d96 3a aa 1d			ld a, (.dmark)  
1d99 32 7a ee			ld (debug_mark),a  
1d9c 3a ab 1d			ld a, (.dmark+1)  
1d9f 32 7b ee			ld (debug_mark+1),a  
1da2 3a ac 1d			ld a, (.dmark+2)  
1da5 32 7c ee			ld (debug_mark+2),a  
1da8 18 03			jr .pastdmark  
1daa ..			.dmark: db "qDU"  
1dad f1			.pastdmark: pop af  
1dae			endm  
# End of macro DMARK
1dae						CALLMONITOR 
1dae cd 86 12			call break_point_state  
1db1				endm  
# End of macro CALLMONITOR
1db1					endif 
1db1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1db1 cd bb 18			call macro_dsp_valuehl 
1db4				endm 
# End of macro FORTH_DSP_VALUEHL
1db4			 
1db4 e5					push hl 
1db5			 
1db5					; is it a zero? 
1db5			 
1db5 3e 00				ld a, 0 
1db7 84					add h 
1db8 85					add l 
1db9			 
1db9 e1					pop hl 
1dba			 
1dba fe 00				cp 0 
1dbc 28 03				jr z, .dup2orig 
1dbe			 
1dbe			 
1dbe cd 20 18				call forth_push_numhl 
1dc1			 
1dc1			 
1dc1				; TODO add floating point number detection 
1dc1			 
1dc1			.dup2orig: 
1dc1			 
1dc1					NEXTW 
1dc1 c3 11 1a			jp macro_next 
1dc4				endm 
# End of macro NEXTW
1dc4			.SWAP: 
1dc4				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1dc4 18				db WORD_SYS_CORE+OPCODE_SWAP             
1dc5 03 1e			dw .COLN            
1dc7 05				db 4 + 1 
1dc8 .. 00			db "SWAP",0              
1dcd				endm 
# End of macro CWHEAD
1dcd			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1dcd					if DEBUG_FORTH_WORDS_KEY 
1dcd						DMARK "SWP" 
1dcd f5				push af  
1dce 3a e2 1d			ld a, (.dmark)  
1dd1 32 7a ee			ld (debug_mark),a  
1dd4 3a e3 1d			ld a, (.dmark+1)  
1dd7 32 7b ee			ld (debug_mark+1),a  
1dda 3a e4 1d			ld a, (.dmark+2)  
1ddd 32 7c ee			ld (debug_mark+2),a  
1de0 18 03			jr .pastdmark  
1de2 ..			.dmark: db "SWP"  
1de5 f1			.pastdmark: pop af  
1de6			endm  
# End of macro DMARK
1de6						CALLMONITOR 
1de6 cd 86 12			call break_point_state  
1de9				endm  
# End of macro CALLMONITOR
1de9					endif 
1de9			 
1de9					FORTH_DSP_VALUEHL 
1de9 cd bb 18			call macro_dsp_valuehl 
1dec				endm 
# End of macro FORTH_DSP_VALUEHL
1dec e5					push hl     ; w2 
1ded			 
1ded					FORTH_DSP_POP 
1ded cd 57 19			call macro_forth_dsp_pop 
1df0				endm 
# End of macro FORTH_DSP_POP
1df0			 
1df0					FORTH_DSP_VALUEHL 
1df0 cd bb 18			call macro_dsp_valuehl 
1df3				endm 
# End of macro FORTH_DSP_VALUEHL
1df3			 
1df3					FORTH_DSP_POP 
1df3 cd 57 19			call macro_forth_dsp_pop 
1df6				endm 
# End of macro FORTH_DSP_POP
1df6			 
1df6 d1					pop de     ; w2	, hl = w1 
1df7			 
1df7 eb					ex de, hl 
1df8 d5					push de 
1df9			 
1df9 cd 20 18				call forth_push_numhl 
1dfc			 
1dfc e1					pop hl 
1dfd			 
1dfd cd 20 18				call forth_push_numhl 
1e00					 
1e00			 
1e00					NEXTW 
1e00 c3 11 1a			jp macro_next 
1e03				endm 
# End of macro NEXTW
1e03			.COLN: 
1e03				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1e03 19				db WORD_SYS_CORE+OPCODE_COLN             
1e04 8f 1f			dw .SCOLN            
1e06 02				db 1 + 1 
1e07 .. 00			db ":",0              
1e09				endm 
# End of macro CWHEAD
1e09			; | : ( -- )         Create new word | DONE 
1e09			 
1e09					if DEBUG_FORTH_WORDS_KEY 
1e09						DMARK "CLN" 
1e09 f5				push af  
1e0a 3a 1e 1e			ld a, (.dmark)  
1e0d 32 7a ee			ld (debug_mark),a  
1e10 3a 1f 1e			ld a, (.dmark+1)  
1e13 32 7b ee			ld (debug_mark+1),a  
1e16 3a 20 1e			ld a, (.dmark+2)  
1e19 32 7c ee			ld (debug_mark+2),a  
1e1c 18 03			jr .pastdmark  
1e1e ..			.dmark: db "CLN"  
1e21 f1			.pastdmark: pop af  
1e22			endm  
# End of macro DMARK
1e22						CALLMONITOR 
1e22 cd 86 12			call break_point_state  
1e25				endm  
# End of macro CALLMONITOR
1e25					endif 
1e25				STACKFRAME OFF $8efe $989f 
1e25				if DEBUG_STACK_IMB 
1e25					if OFF 
1e25						exx 
1e25						ld de, $8efe 
1e25						ld a, d 
1e25						ld hl, curframe 
1e25						call hexout 
1e25						ld a, e 
1e25						ld hl, curframe+2 
1e25						call hexout 
1e25						ld hl, $8efe 
1e25						push hl 
1e25						ld hl, $989f 
1e25						push hl 
1e25						exx 
1e25					endif 
1e25				endif 
1e25			endm 
# End of macro STACKFRAME
1e25				; get parser buffer length  of new word 
1e25			 
1e25				 
1e25			 
1e25					; move tok past this to start of name defintition 
1e25					; TODO get word to define 
1e25					; TODO Move past word token 
1e25					; TODO get length of string up to the ';' 
1e25			 
1e25 2a 76 e6			ld hl, (os_tok_ptr) 
1e28 23				inc hl 
1e29 23				inc hl 
1e2a			 
1e2a 3e 3b			ld a, ';' 
1e2c cd 2b 0f			call strlent 
1e2f			 
1e2f 7d				ld a,l 
1e30 32 75 e5			ld (os_new_parse_len), a 
1e33			 
1e33			 
1e33			if DEBUG_FORTH_UWORD 
1e33 ed 5b 76 e6		ld de, (os_tok_ptr) 
1e37						DMARK ":01" 
1e37 f5				push af  
1e38 3a 4c 1e			ld a, (.dmark)  
1e3b 32 7a ee			ld (debug_mark),a  
1e3e 3a 4d 1e			ld a, (.dmark+1)  
1e41 32 7b ee			ld (debug_mark+1),a  
1e44 3a 4e 1e			ld a, (.dmark+2)  
1e47 32 7c ee			ld (debug_mark+2),a  
1e4a 18 03			jr .pastdmark  
1e4c ..			.dmark: db ":01"  
1e4f f1			.pastdmark: pop af  
1e50			endm  
# End of macro DMARK
1e50				CALLMONITOR 
1e50 cd 86 12			call break_point_state  
1e53				endm  
# End of macro CALLMONITOR
1e53			endif 
1e53			 
1e53			; 
1e53			;  new word memory layout: 
1e53			;  
1e53			;    : adg 6666 ;  
1e53			; 
1e53			;    db   1     ; user defined word  
1e53 23				inc hl    
1e54			;    dw   sysdict 
1e54 23				inc hl 
1e55 23				inc hl 
1e56			;    db <word len>+1 (for null) 
1e56 23				inc hl 
1e57			;    db .... <word> 
1e57			; 
1e57			 
1e57 23				inc hl    ; some extras for the word preamble before the above 
1e58 23				inc hl 
1e59 23				inc hl 
1e5a 23				inc hl 
1e5b 23				inc hl 
1e5c 23				inc hl 
1e5d 23				inc hl  
1e5e 23				inc hl 
1e5f 23				inc hl 
1e60 23				inc hl 
1e61 23				inc hl 
1e62 23				inc hl 
1e63 23				inc hl 
1e64 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1e65			;       exec word buffer 
1e65			;	<ptr word>   
1e65 23				inc hl 
1e66 23				inc hl 
1e67			;       <word list><null term> 7F final term 
1e67			 
1e67			 
1e67			if DEBUG_FORTH_UWORD 
1e67						DMARK ":02" 
1e67 f5				push af  
1e68 3a 7c 1e			ld a, (.dmark)  
1e6b 32 7a ee			ld (debug_mark),a  
1e6e 3a 7d 1e			ld a, (.dmark+1)  
1e71 32 7b ee			ld (debug_mark+1),a  
1e74 3a 7e 1e			ld a, (.dmark+2)  
1e77 32 7c ee			ld (debug_mark+2),a  
1e7a 18 03			jr .pastdmark  
1e7c ..			.dmark: db ":02"  
1e7f f1			.pastdmark: pop af  
1e80			endm  
# End of macro DMARK
1e80				CALLMONITOR 
1e80 cd 86 12			call break_point_state  
1e83				endm  
# End of macro CALLMONITOR
1e83			endif 
1e83			 
1e83				 
1e83					; malloc the size 
1e83			 
1e83 cd 89 0f				call malloc 
1e86 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
1e89			 
1e89			;    db   1     ; user defined word  
1e89 3e 01				ld a, WORD_SYS_UWORD  
1e8b 77					ld (hl), a 
1e8c				 
1e8c 23				inc hl    
1e8d			;    dw   sysdict 
1e8d 11 69 1b			ld de, sysdict       ; continue on with the scan to the system dict 
1e90 73				ld (hl), e 
1e91 23				inc hl 
1e92 72				ld (hl), d 
1e93 23				inc hl 
1e94			 
1e94			 
1e94			;    Setup dict word 
1e94			 
1e94 23				inc hl 
1e95 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
1e98			 
1e98				; 1. get length of dict word 
1e98			 
1e98			 
1e98 2a 76 e6			ld hl, (os_tok_ptr) 
1e9b 23				inc hl 
1e9c 23				inc hl    ; position to start of dict word 
1e9d 3e 00			ld a, 0 
1e9f cd 2b 0f			call strlent 
1ea2			 
1ea2			 
1ea2 23				inc hl    ; to include null??? 
1ea3			 
1ea3				; write length of dict word 
1ea3			 
1ea3 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1ea7 1b				dec de 
1ea8 eb				ex de, hl 
1ea9 73				ld (hl), e 
1eaa eb				ex de, hl 
1eab			 
1eab				 
1eab			 
1eab				; copy  
1eab 4d				ld c, l 
1eac 06 00			ld b, 0 
1eae ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1eb2 2a 76 e6			ld hl, (os_tok_ptr) 
1eb5 23				inc hl 
1eb6 23				inc hl    ; position to start of dict word 
1eb7				 
1eb7			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
1eb7				 
1eb7				; TODO need to convert word to upper case 
1eb7			 
1eb7			ucasetok:	 
1eb7 7e				ld a,(hl) 
1eb8 cd 17 0f			call toUpper 
1ebb 77				ld (hl),a 
1ebc ed a0			ldi 
1ebe f2 b7 1e		 	jp p, ucasetok 
1ec1			 
1ec1			 
1ec1			 
1ec1				; de now points to start of where the word body code should be placed 
1ec1 ed 53 79 e5		ld (os_new_work_ptr), de 
1ec5				; hl now points to the words to throw at forthexec which needs to be copied 
1ec5 22 7b e5			ld (os_new_src_ptr), hl 
1ec8			 
1ec8				; TODO add 'call to forthexec' 
1ec8			 
1ec8			if DEBUG_FORTH_UWORD 
1ec8 c5				push bc 
1ec9 ed 4b 73 e5		ld bc, (os_new_malloc) 
1ecd						DMARK ":0x" 
1ecd f5				push af  
1ece 3a e2 1e			ld a, (.dmark)  
1ed1 32 7a ee			ld (debug_mark),a  
1ed4 3a e3 1e			ld a, (.dmark+1)  
1ed7 32 7b ee			ld (debug_mark+1),a  
1eda 3a e4 1e			ld a, (.dmark+2)  
1edd 32 7c ee			ld (debug_mark+2),a  
1ee0 18 03			jr .pastdmark  
1ee2 ..			.dmark: db ":0x"  
1ee5 f1			.pastdmark: pop af  
1ee6			endm  
# End of macro DMARK
1ee6				CALLMONITOR 
1ee6 cd 86 12			call break_point_state  
1ee9				endm  
# End of macro CALLMONITOR
1ee9 c1				pop bc 
1eea			endif 
1eea			 
1eea			 
1eea				; create word preamble which should be: 
1eea			 
1eea			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
1eea			 
1eea				;    ld hl, <word code> 
1eea				;    jp user_exec 
1eea			        ;    <word code bytes> 
1eea			 
1eea			 
1eea			;	inc de     ; TODO ??? or are we already past the word's null 
1eea eb				ex de, hl 
1eeb			 
1eeb 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
1eed			 
1eed 23				inc hl 
1eee 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
1ef1 23				inc hl 
1ef2			 
1ef2 23				inc hl 
1ef3 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
1ef5			 
1ef5 01 a2 41			ld bc, user_exec 
1ef8 23				inc hl 
1ef9 71				ld (hl), c     ; poke address of user_exec 
1efa 23				inc hl 
1efb 70				ld (hl), b     
1efc			 ; 
1efc			;	inc hl 
1efc			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1efc			; 
1efc			; 
1efc			;	ld bc, macro_forth_rsp_next 
1efc			;	inc hl 
1efc			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
1efc			;	inc hl 
1efc			;	ld (hl), b     
1efc			 ; 
1efc			;	inc hl 
1efc			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1efc			; 
1efc			; 
1efc			;	inc hl 
1efc			;	ld bc, forthexec 
1efc			;	ld (hl), c     ; poke address of forthexec 
1efc			;	inc hl 
1efc			;	ld (hl), b      
1efc			; 
1efc			;	inc hl 
1efc			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
1efc			; 
1efc			;	ld bc, user_dict_next 
1efc			;	inc hl 
1efc			;	ld (hl), c     ; poke address of forthexec 
1efc			;	inc hl 
1efc			;	ld (hl), b      
1efc			 
1efc				; hl is now where we need to copy the word byte data to save this 
1efc			 
1efc 23				inc hl 
1efd 22 7d e5			ld (os_new_exec), hl 
1f00				 
1f00				; copy definition 
1f00			 
1f00 eb				ex de, hl 
1f01			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
1f01			;	inc de    ; skip the PC for this parse 
1f01 3a 75 e5			ld a, (os_new_parse_len) 
1f04 4f				ld c, a 
1f05 06 00			ld b, 0 
1f07 ed b0			ldir		 ; copy defintion 
1f09			 
1f09			 
1f09				; poke the address of where the new word bytes live for forthexec 
1f09			 
1f09 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
1f0c			 
1f0c ed 5b 7d e5		ld de, (os_new_exec)      
1f10				 
1f10 73				ld (hl), e 
1f11 23				inc hl 
1f12 72				ld (hl), d 
1f13			 
1f13					; TODO copy last user dict word next link to this word 
1f13					; TODO update last user dict word to point to this word 
1f13			; 
1f13			; hl f923 de 812a ; bc 811a 
1f13			 
1f13			if DEBUG_FORTH_UWORD 
1f13 c5				push bc 
1f14 ed 4b 73 e5		ld bc, (os_new_malloc) 
1f18						DMARK ":0A" 
1f18 f5				push af  
1f19 3a 2d 1f			ld a, (.dmark)  
1f1c 32 7a ee			ld (debug_mark),a  
1f1f 3a 2e 1f			ld a, (.dmark+1)  
1f22 32 7b ee			ld (debug_mark+1),a  
1f25 3a 2f 1f			ld a, (.dmark+2)  
1f28 32 7c ee			ld (debug_mark+2),a  
1f2b 18 03			jr .pastdmark  
1f2d ..			.dmark: db ":0A"  
1f30 f1			.pastdmark: pop af  
1f31			endm  
# End of macro DMARK
1f31				CALLMONITOR 
1f31 cd 86 12			call break_point_state  
1f34				endm  
# End of macro CALLMONITOR
1f34 c1				pop bc 
1f35			endif 
1f35			if DEBUG_FORTH_UWORD 
1f35 c5				push bc 
1f36 ed 4b 73 e5		ld bc, (os_new_malloc) 
1f3a 03				inc bc 
1f3b 03				inc bc 
1f3c 03				inc bc 
1f3d 03				inc bc 
1f3e 03				inc bc 
1f3f 03				inc bc 
1f40 03				inc bc 
1f41 03				inc bc 
1f42			 
1f42						DMARK ":0B" 
1f42 f5				push af  
1f43 3a 57 1f			ld a, (.dmark)  
1f46 32 7a ee			ld (debug_mark),a  
1f49 3a 58 1f			ld a, (.dmark+1)  
1f4c 32 7b ee			ld (debug_mark+1),a  
1f4f 3a 59 1f			ld a, (.dmark+2)  
1f52 32 7c ee			ld (debug_mark+2),a  
1f55 18 03			jr .pastdmark  
1f57 ..			.dmark: db ":0B"  
1f5a f1			.pastdmark: pop af  
1f5b			endm  
# End of macro DMARK
1f5b				CALLMONITOR 
1f5b cd 86 12			call break_point_state  
1f5e				endm  
# End of macro CALLMONITOR
1f5e c1				pop bc 
1f5f			endif 
1f5f			 
1f5f			; update word dict linked list for new word 
1f5f			 
1f5f			 
1f5f 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
1f62 23			inc hl     ; move to next work linked list ptr 
1f63			 
1f63 ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
1f67 73			ld (hl), e 
1f68 23			inc hl 
1f69 72			ld (hl), d 
1f6a			 
1f6a			if DEBUG_FORTH_UWORD 
1f6a ed 4b 72 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
1f6e			endif 
1f6e			 
1f6e ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
1f72			 
1f72			 
1f72			if DEBUG_FORTH_UWORD 
1f72						DMARK ":0+" 
1f72 f5				push af  
1f73 3a 87 1f			ld a, (.dmark)  
1f76 32 7a ee			ld (debug_mark),a  
1f79 3a 88 1f			ld a, (.dmark+1)  
1f7c 32 7b ee			ld (debug_mark+1),a  
1f7f 3a 89 1f			ld a, (.dmark+2)  
1f82 32 7c ee			ld (debug_mark+2),a  
1f85 18 03			jr .pastdmark  
1f87 ..			.dmark: db ":0+"  
1f8a f1			.pastdmark: pop af  
1f8b			endm  
# End of macro DMARK
1f8b				CALLMONITOR 
1f8b cd 86 12			call break_point_state  
1f8e				endm  
# End of macro CALLMONITOR
1f8e			endif 
1f8e			 
1f8e				STACKFRAMECHK OFF $8efe $989f 
1f8e				if DEBUG_STACK_IMB 
1f8e					if OFF 
1f8e						exx 
1f8e						ld hl, $989f 
1f8e						pop de   ; $989f 
1f8e						call cmp16 
1f8e						jr nz, .spnosame 
1f8e						ld hl, $8efe 
1f8e						pop de   ; $8efe 
1f8e						call cmp16 
1f8e						jr z, .spfrsame 
1f8e						.spnosame: call showsperror 
1f8e						.spfrsame: nop 
1f8e						exx 
1f8e					endif 
1f8e				endif 
1f8e			endm 
# End of macro STACKFRAMECHK
1f8e			 
1f8e c9			ret    ; dont process any remaining parser tokens as they form new word 
1f8f			 
1f8f			 
1f8f			 
1f8f			 
1f8f			;		NEXT 
1f8f			.SCOLN: 
1f8f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
1f8f 06				db OPCODE_SCOLN 
1f90 db 1f			dw .DROP 
1f92 02				db 2 
1f93 .. 00			db ";",0           
1f95			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
1f95					if DEBUG_FORTH_WORDS_KEY 
1f95						DMARK "SCN" 
1f95 f5				push af  
1f96 3a aa 1f			ld a, (.dmark)  
1f99 32 7a ee			ld (debug_mark),a  
1f9c 3a ab 1f			ld a, (.dmark+1)  
1f9f 32 7b ee			ld (debug_mark+1),a  
1fa2 3a ac 1f			ld a, (.dmark+2)  
1fa5 32 7c ee			ld (debug_mark+2),a  
1fa8 18 03			jr .pastdmark  
1faa ..			.dmark: db "SCN"  
1fad f1			.pastdmark: pop af  
1fae			endm  
# End of macro DMARK
1fae						CALLMONITOR 
1fae cd 86 12			call break_point_state  
1fb1				endm  
# End of macro CALLMONITOR
1fb1					endif 
1fb1					FORTH_RSP_TOS 
1fb1 cd de 17			call macro_forth_rsp_tos 
1fb4				endm 
# End of macro FORTH_RSP_TOS
1fb4 e5					push hl 
1fb5					FORTH_RSP_POP 
1fb5 cd e8 17			call macro_forth_rsp_pop 
1fb8				endm 
# End of macro FORTH_RSP_POP
1fb8 e1					pop hl 
1fb9			;		ex de,hl 
1fb9 22 76 e6				ld (os_tok_ptr),hl 
1fbc			 
1fbc			if DEBUG_FORTH_UWORD 
1fbc						DMARK "SCL" 
1fbc f5				push af  
1fbd 3a d1 1f			ld a, (.dmark)  
1fc0 32 7a ee			ld (debug_mark),a  
1fc3 3a d2 1f			ld a, (.dmark+1)  
1fc6 32 7b ee			ld (debug_mark+1),a  
1fc9 3a d3 1f			ld a, (.dmark+2)  
1fcc 32 7c ee			ld (debug_mark+2),a  
1fcf 18 03			jr .pastdmark  
1fd1 ..			.dmark: db "SCL"  
1fd4 f1			.pastdmark: pop af  
1fd5			endm  
# End of macro DMARK
1fd5				CALLMONITOR 
1fd5 cd 86 12			call break_point_state  
1fd8				endm  
# End of macro CALLMONITOR
1fd8			endif 
1fd8					NEXTW 
1fd8 c3 11 1a			jp macro_next 
1fdb				endm 
# End of macro NEXTW
1fdb			 
1fdb			.DROP: 
1fdb				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
1fdb 1b				db WORD_SYS_CORE+OPCODE_DROP             
1fdc 06 20			dw .DUP2            
1fde 05				db 4 + 1 
1fdf .. 00			db "DROP",0              
1fe4				endm 
# End of macro CWHEAD
1fe4			; | DROP ( w -- )   drop the TOS item   | DONE 
1fe4					if DEBUG_FORTH_WORDS_KEY 
1fe4						DMARK "DRP" 
1fe4 f5				push af  
1fe5 3a f9 1f			ld a, (.dmark)  
1fe8 32 7a ee			ld (debug_mark),a  
1feb 3a fa 1f			ld a, (.dmark+1)  
1fee 32 7b ee			ld (debug_mark+1),a  
1ff1 3a fb 1f			ld a, (.dmark+2)  
1ff4 32 7c ee			ld (debug_mark+2),a  
1ff7 18 03			jr .pastdmark  
1ff9 ..			.dmark: db "DRP"  
1ffc f1			.pastdmark: pop af  
1ffd			endm  
# End of macro DMARK
1ffd						CALLMONITOR 
1ffd cd 86 12			call break_point_state  
2000				endm  
# End of macro CALLMONITOR
2000					endif 
2000					FORTH_DSP_POP 
2000 cd 57 19			call macro_forth_dsp_pop 
2003				endm 
# End of macro FORTH_DSP_POP
2003					NEXTW 
2003 c3 11 1a			jp macro_next 
2006				endm 
# End of macro NEXTW
2006			.DUP2: 
2006				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2006 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2007 4b 20			dw .DROP2            
2009 05				db 4 + 1 
200a .. 00			db "2DUP",0              
200f				endm 
# End of macro CWHEAD
200f			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
200f					if DEBUG_FORTH_WORDS_KEY 
200f						DMARK "2DU" 
200f f5				push af  
2010 3a 24 20			ld a, (.dmark)  
2013 32 7a ee			ld (debug_mark),a  
2016 3a 25 20			ld a, (.dmark+1)  
2019 32 7b ee			ld (debug_mark+1),a  
201c 3a 26 20			ld a, (.dmark+2)  
201f 32 7c ee			ld (debug_mark+2),a  
2022 18 03			jr .pastdmark  
2024 ..			.dmark: db "2DU"  
2027 f1			.pastdmark: pop af  
2028			endm  
# End of macro DMARK
2028						CALLMONITOR 
2028 cd 86 12			call break_point_state  
202b				endm  
# End of macro CALLMONITOR
202b					endif 
202b					FORTH_DSP_VALUEHL 
202b cd bb 18			call macro_dsp_valuehl 
202e				endm 
# End of macro FORTH_DSP_VALUEHL
202e e5					push hl      ; 2 
202f			 
202f					FORTH_DSP_POP 
202f cd 57 19			call macro_forth_dsp_pop 
2032				endm 
# End of macro FORTH_DSP_POP
2032					 
2032					FORTH_DSP_VALUEHL 
2032 cd bb 18			call macro_dsp_valuehl 
2035				endm 
# End of macro FORTH_DSP_VALUEHL
2035			;		push hl      ; 1 
2035			 
2035					FORTH_DSP_POP 
2035 cd 57 19			call macro_forth_dsp_pop 
2038				endm 
# End of macro FORTH_DSP_POP
2038			 
2038			;		pop hl       ; 1 
2038 d1					pop de       ; 2 
2039			 
2039 cd 20 18				call forth_push_numhl 
203c eb					ex de, hl 
203d cd 20 18				call forth_push_numhl 
2040			 
2040					 
2040 eb					ex de, hl 
2041			 
2041 cd 20 18				call forth_push_numhl 
2044 eb					ex de, hl 
2045 cd 20 18				call forth_push_numhl 
2048			 
2048			 
2048					NEXTW 
2048 c3 11 1a			jp macro_next 
204b				endm 
# End of macro NEXTW
204b			.DROP2: 
204b				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
204b 1d				db WORD_SYS_CORE+OPCODE_DROP2             
204c 7a 20			dw .SWAP2            
204e 06				db 5 + 1 
204f .. 00			db "2DROP",0              
2055				endm 
# End of macro CWHEAD
2055			; | 2DROP ( w w -- )    Double drop | DONE 
2055					if DEBUG_FORTH_WORDS_KEY 
2055						DMARK "2DR" 
2055 f5				push af  
2056 3a 6a 20			ld a, (.dmark)  
2059 32 7a ee			ld (debug_mark),a  
205c 3a 6b 20			ld a, (.dmark+1)  
205f 32 7b ee			ld (debug_mark+1),a  
2062 3a 6c 20			ld a, (.dmark+2)  
2065 32 7c ee			ld (debug_mark+2),a  
2068 18 03			jr .pastdmark  
206a ..			.dmark: db "2DR"  
206d f1			.pastdmark: pop af  
206e			endm  
# End of macro DMARK
206e						CALLMONITOR 
206e cd 86 12			call break_point_state  
2071				endm  
# End of macro CALLMONITOR
2071					endif 
2071					FORTH_DSP_POP 
2071 cd 57 19			call macro_forth_dsp_pop 
2074				endm 
# End of macro FORTH_DSP_POP
2074					FORTH_DSP_POP 
2074 cd 57 19			call macro_forth_dsp_pop 
2077				endm 
# End of macro FORTH_DSP_POP
2077					NEXTW 
2077 c3 11 1a			jp macro_next 
207a				endm 
# End of macro NEXTW
207a			.SWAP2: 
207a				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
207a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
207b a3 20			dw .AT            
207d 06				db 5 + 1 
207e .. 00			db "2SWAP",0              
2084				endm 
# End of macro CWHEAD
2084			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2084					if DEBUG_FORTH_WORDS_KEY 
2084						DMARK "2SW" 
2084 f5				push af  
2085 3a 99 20			ld a, (.dmark)  
2088 32 7a ee			ld (debug_mark),a  
208b 3a 9a 20			ld a, (.dmark+1)  
208e 32 7b ee			ld (debug_mark+1),a  
2091 3a 9b 20			ld a, (.dmark+2)  
2094 32 7c ee			ld (debug_mark+2),a  
2097 18 03			jr .pastdmark  
2099 ..			.dmark: db "2SW"  
209c f1			.pastdmark: pop af  
209d			endm  
# End of macro DMARK
209d						CALLMONITOR 
209d cd 86 12			call break_point_state  
20a0				endm  
# End of macro CALLMONITOR
20a0					endif 
20a0					NEXTW 
20a0 c3 11 1a			jp macro_next 
20a3				endm 
# End of macro NEXTW
20a3			.AT: 
20a3				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
20a3 1f				db WORD_SYS_CORE+OPCODE_AT             
20a4 d5 20			dw .CAT            
20a6 02				db 1 + 1 
20a7 .. 00			db "@",0              
20a9				endm 
# End of macro CWHEAD
20a9			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
20a9			 
20a9					if DEBUG_FORTH_WORDS_KEY 
20a9						DMARK "AT." 
20a9 f5				push af  
20aa 3a be 20			ld a, (.dmark)  
20ad 32 7a ee			ld (debug_mark),a  
20b0 3a bf 20			ld a, (.dmark+1)  
20b3 32 7b ee			ld (debug_mark+1),a  
20b6 3a c0 20			ld a, (.dmark+2)  
20b9 32 7c ee			ld (debug_mark+2),a  
20bc 18 03			jr .pastdmark  
20be ..			.dmark: db "AT."  
20c1 f1			.pastdmark: pop af  
20c2			endm  
# End of macro DMARK
20c2						CALLMONITOR 
20c2 cd 86 12			call break_point_state  
20c5				endm  
# End of macro CALLMONITOR
20c5					endif 
20c5			.getbyteat:	 
20c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20c5 cd bb 18			call macro_dsp_valuehl 
20c8				endm 
# End of macro FORTH_DSP_VALUEHL
20c8					 
20c8			;		push hl 
20c8				 
20c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
20c8 cd 57 19			call macro_forth_dsp_pop 
20cb				endm 
# End of macro FORTH_DSP_POP
20cb			 
20cb			;		pop hl 
20cb			 
20cb 7e					ld a, (hl) 
20cc			 
20cc 6f					ld l, a 
20cd 26 00				ld h, 0 
20cf cd 20 18				call forth_push_numhl 
20d2			 
20d2					NEXTW 
20d2 c3 11 1a			jp macro_next 
20d5				endm 
# End of macro NEXTW
20d5			.CAT: 
20d5				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
20d5 20				db WORD_SYS_CORE+OPCODE_CAT             
20d6 fe 20			dw .BANG            
20d8 03				db 2 + 1 
20d9 .. 00			db "C@",0              
20dc				endm 
# End of macro CWHEAD
20dc			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
20dc					if DEBUG_FORTH_WORDS_KEY 
20dc						DMARK "CAA" 
20dc f5				push af  
20dd 3a f1 20			ld a, (.dmark)  
20e0 32 7a ee			ld (debug_mark),a  
20e3 3a f2 20			ld a, (.dmark+1)  
20e6 32 7b ee			ld (debug_mark+1),a  
20e9 3a f3 20			ld a, (.dmark+2)  
20ec 32 7c ee			ld (debug_mark+2),a  
20ef 18 03			jr .pastdmark  
20f1 ..			.dmark: db "CAA"  
20f4 f1			.pastdmark: pop af  
20f5			endm  
# End of macro DMARK
20f5						CALLMONITOR 
20f5 cd 86 12			call break_point_state  
20f8				endm  
# End of macro CALLMONITOR
20f8					endif 
20f8 c3 c5 20				jp .getbyteat 
20fb					NEXTW 
20fb c3 11 1a			jp macro_next 
20fe				endm 
# End of macro NEXTW
20fe			.BANG: 
20fe				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
20fe 21				db WORD_SYS_CORE+OPCODE_BANG             
20ff 34 21			dw .CBANG            
2101 02				db 1 + 1 
2102 .. 00			db "!",0              
2104				endm 
# End of macro CWHEAD
2104			; | ! ( x w -- ) Store x at address w      | DONE 
2104					if DEBUG_FORTH_WORDS_KEY 
2104						DMARK "BNG" 
2104 f5				push af  
2105 3a 19 21			ld a, (.dmark)  
2108 32 7a ee			ld (debug_mark),a  
210b 3a 1a 21			ld a, (.dmark+1)  
210e 32 7b ee			ld (debug_mark+1),a  
2111 3a 1b 21			ld a, (.dmark+2)  
2114 32 7c ee			ld (debug_mark+2),a  
2117 18 03			jr .pastdmark  
2119 ..			.dmark: db "BNG"  
211c f1			.pastdmark: pop af  
211d			endm  
# End of macro DMARK
211d						CALLMONITOR 
211d cd 86 12			call break_point_state  
2120				endm  
# End of macro CALLMONITOR
2120					endif 
2120			 
2120			.storebyteat:		 
2120					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2120 cd bb 18			call macro_dsp_valuehl 
2123				endm 
# End of macro FORTH_DSP_VALUEHL
2123					 
2123 e5					push hl 
2124				 
2124					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2124 cd 57 19			call macro_forth_dsp_pop 
2127				endm 
# End of macro FORTH_DSP_POP
2127			 
2127					; get byte to poke 
2127			 
2127					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2127 cd bb 18			call macro_dsp_valuehl 
212a				endm 
# End of macro FORTH_DSP_VALUEHL
212a e5					push hl 
212b			 
212b			 
212b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
212b cd 57 19			call macro_forth_dsp_pop 
212e				endm 
# End of macro FORTH_DSP_POP
212e			 
212e			 
212e d1					pop de 
212f e1					pop hl 
2130			 
2130 73					ld (hl),e 
2131			 
2131			 
2131					NEXTW 
2131 c3 11 1a			jp macro_next 
2134				endm 
# End of macro NEXTW
2134			.CBANG: 
2134				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2134 22				db WORD_SYS_CORE+OPCODE_CBANG             
2135 5d 21			dw .SCALL            
2137 03				db 2 + 1 
2138 .. 00			db "C!",0              
213b				endm 
# End of macro CWHEAD
213b			; | C!  ( x w -- ) Store x at address w  | DONE 
213b					if DEBUG_FORTH_WORDS_KEY 
213b						DMARK "CBA" 
213b f5				push af  
213c 3a 50 21			ld a, (.dmark)  
213f 32 7a ee			ld (debug_mark),a  
2142 3a 51 21			ld a, (.dmark+1)  
2145 32 7b ee			ld (debug_mark+1),a  
2148 3a 52 21			ld a, (.dmark+2)  
214b 32 7c ee			ld (debug_mark+2),a  
214e 18 03			jr .pastdmark  
2150 ..			.dmark: db "CBA"  
2153 f1			.pastdmark: pop af  
2154			endm  
# End of macro DMARK
2154						CALLMONITOR 
2154 cd 86 12			call break_point_state  
2157				endm  
# End of macro CALLMONITOR
2157					endif 
2157 c3 20 21				jp .storebyteat 
215a					NEXTW 
215a c3 11 1a			jp macro_next 
215d				endm 
# End of macro NEXTW
215d			.SCALL: 
215d				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
215d 23				db WORD_SYS_CORE+OPCODE_SCALL             
215e 91 21			dw .DEPTH            
2160 05				db 4 + 1 
2161 .. 00			db "CALL",0              
2166				endm 
# End of macro CWHEAD
2166			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2166					if DEBUG_FORTH_WORDS_KEY 
2166						DMARK "CLL" 
2166 f5				push af  
2167 3a 7b 21			ld a, (.dmark)  
216a 32 7a ee			ld (debug_mark),a  
216d 3a 7c 21			ld a, (.dmark+1)  
2170 32 7b ee			ld (debug_mark+1),a  
2173 3a 7d 21			ld a, (.dmark+2)  
2176 32 7c ee			ld (debug_mark+2),a  
2179 18 03			jr .pastdmark  
217b ..			.dmark: db "CLL"  
217e f1			.pastdmark: pop af  
217f			endm  
# End of macro DMARK
217f						CALLMONITOR 
217f cd 86 12			call break_point_state  
2182				endm  
# End of macro CALLMONITOR
2182					endif 
2182			 
2182					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2182 cd bb 18			call macro_dsp_valuehl 
2185				endm 
# End of macro FORTH_DSP_VALUEHL
2185			 
2185			;		push hl 
2185			 
2185					; destroy value TOS 
2185			 
2185					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2185 cd 57 19			call macro_forth_dsp_pop 
2188				endm 
# End of macro FORTH_DSP_POP
2188			 
2188						 
2188			;		pop hl 
2188			 
2188					; how to do a call with hl???? save SP? 
2188 cd ba 19				call forth_call_hl 
218b			 
218b			 
218b					; TODO push value back onto stack for another op etc 
218b			 
218b cd 20 18				call forth_push_numhl 
218e					NEXTW 
218e c3 11 1a			jp macro_next 
2191				endm 
# End of macro NEXTW
2191			.DEPTH: 
2191				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2191 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2192 ce 21			dw .OVER            
2194 06				db 5 + 1 
2195 .. 00			db "DEPTH",0              
219b				endm 
# End of macro CWHEAD
219b			; | DEPTH ( -- u ) Push count of stack | DONE 
219b					; take current TOS and remove from base value div by two to get count 
219b					if DEBUG_FORTH_WORDS_KEY 
219b						DMARK "DEP" 
219b f5				push af  
219c 3a b0 21			ld a, (.dmark)  
219f 32 7a ee			ld (debug_mark),a  
21a2 3a b1 21			ld a, (.dmark+1)  
21a5 32 7b ee			ld (debug_mark+1),a  
21a8 3a b2 21			ld a, (.dmark+2)  
21ab 32 7c ee			ld (debug_mark+2),a  
21ae 18 03			jr .pastdmark  
21b0 ..			.dmark: db "DEP"  
21b3 f1			.pastdmark: pop af  
21b4			endm  
# End of macro DMARK
21b4						CALLMONITOR 
21b4 cd 86 12			call break_point_state  
21b7				endm  
# End of macro CALLMONITOR
21b7					endif 
21b7			 
21b7			 
21b7 2a 22 eb			ld hl, (cli_data_sp) 
21ba 11 dc e8			ld de, cli_data_stack 
21bd ed 52			sbc hl,de 
21bf				 
21bf				; div by size of stack item 
21bf			 
21bf 5d				ld e,l 
21c0 0e 03			ld c, 3 
21c2 cd 52 0a			call Div8 
21c5			 
21c5 6f				ld l,a 
21c6 26 00			ld h,0 
21c8			 
21c8				;srl h 
21c8				;rr l 
21c8			 
21c8 cd 20 18				call forth_push_numhl 
21cb					NEXTW 
21cb c3 11 1a			jp macro_next 
21ce				endm 
# End of macro NEXTW
21ce			.OVER: 
21ce				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
21ce 42				db WORD_SYS_CORE+46             
21cf 15 22			dw .PAUSE            
21d1 05				db 4 + 1 
21d2 .. 00			db "OVER",0              
21d7				endm 
# End of macro CWHEAD
21d7			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
21d7					if DEBUG_FORTH_WORDS_KEY 
21d7						DMARK "OVR" 
21d7 f5				push af  
21d8 3a ec 21			ld a, (.dmark)  
21db 32 7a ee			ld (debug_mark),a  
21de 3a ed 21			ld a, (.dmark+1)  
21e1 32 7b ee			ld (debug_mark+1),a  
21e4 3a ee 21			ld a, (.dmark+2)  
21e7 32 7c ee			ld (debug_mark+2),a  
21ea 18 03			jr .pastdmark  
21ec ..			.dmark: db "OVR"  
21ef f1			.pastdmark: pop af  
21f0			endm  
# End of macro DMARK
21f0						CALLMONITOR 
21f0 cd 86 12			call break_point_state  
21f3				endm  
# End of macro CALLMONITOR
21f3					endif 
21f3			 
21f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21f3 cd bb 18			call macro_dsp_valuehl 
21f6				endm 
# End of macro FORTH_DSP_VALUEHL
21f6 e5					push hl    ; n2 
21f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
21f7 cd 57 19			call macro_forth_dsp_pop 
21fa				endm 
# End of macro FORTH_DSP_POP
21fa			 
21fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21fa cd bb 18			call macro_dsp_valuehl 
21fd				endm 
# End of macro FORTH_DSP_VALUEHL
21fd e5					push hl    ; n1 
21fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
21fe cd 57 19			call macro_forth_dsp_pop 
2201				endm 
# End of macro FORTH_DSP_POP
2201			 
2201 d1					pop de     ; n1 
2202 e1					pop hl     ; n2 
2203			 
2203 d5					push de 
2204 e5					push hl 
2205 d5					push de 
2206			 
2206					; push back  
2206			 
2206 e1					pop hl 
2207 cd 20 18				call forth_push_numhl 
220a e1					pop hl 
220b cd 20 18				call forth_push_numhl 
220e e1					pop hl 
220f cd 20 18				call forth_push_numhl 
2212					NEXTW 
2212 c3 11 1a			jp macro_next 
2215				endm 
# End of macro NEXTW
2215			 
2215			.PAUSE: 
2215				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2215 43				db WORD_SYS_CORE+47             
2216 4a 22			dw .PAUSES            
2218 08				db 7 + 1 
2219 .. 00			db "PAUSEMS",0              
2221				endm 
# End of macro CWHEAD
2221			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2221					if DEBUG_FORTH_WORDS_KEY 
2221						DMARK "PMS" 
2221 f5				push af  
2222 3a 36 22			ld a, (.dmark)  
2225 32 7a ee			ld (debug_mark),a  
2228 3a 37 22			ld a, (.dmark+1)  
222b 32 7b ee			ld (debug_mark+1),a  
222e 3a 38 22			ld a, (.dmark+2)  
2231 32 7c ee			ld (debug_mark+2),a  
2234 18 03			jr .pastdmark  
2236 ..			.dmark: db "PMS"  
2239 f1			.pastdmark: pop af  
223a			endm  
# End of macro DMARK
223a						CALLMONITOR 
223a cd 86 12			call break_point_state  
223d				endm  
# End of macro CALLMONITOR
223d					endif 
223d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
223d cd bb 18			call macro_dsp_valuehl 
2240				endm 
# End of macro FORTH_DSP_VALUEHL
2240			;		push hl    ; n2 
2240					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2240 cd 57 19			call macro_forth_dsp_pop 
2243				endm 
# End of macro FORTH_DSP_POP
2243			;		pop hl 
2243			 
2243 7d					ld a, l 
2244 cd c7 08				call aDelayInMS 
2247				       NEXTW 
2247 c3 11 1a			jp macro_next 
224a				endm 
# End of macro NEXTW
224a			.PAUSES:  
224a				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
224a 44				db WORD_SYS_CORE+48             
224b b9 22			dw .ROT            
224d 06				db 5 + 1 
224e .. 00			db "PAUSE",0              
2254				endm 
# End of macro CWHEAD
2254			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2254					if DEBUG_FORTH_WORDS_KEY 
2254						DMARK "PAU" 
2254 f5				push af  
2255 3a 69 22			ld a, (.dmark)  
2258 32 7a ee			ld (debug_mark),a  
225b 3a 6a 22			ld a, (.dmark+1)  
225e 32 7b ee			ld (debug_mark+1),a  
2261 3a 6b 22			ld a, (.dmark+2)  
2264 32 7c ee			ld (debug_mark+2),a  
2267 18 03			jr .pastdmark  
2269 ..			.dmark: db "PAU"  
226c f1			.pastdmark: pop af  
226d			endm  
# End of macro DMARK
226d						CALLMONITOR 
226d cd 86 12			call break_point_state  
2270				endm  
# End of macro CALLMONITOR
2270					endif 
2270					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2270 cd bb 18			call macro_dsp_valuehl 
2273				endm 
# End of macro FORTH_DSP_VALUEHL
2273			;		push hl    ; n2 
2273					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2273 cd 57 19			call macro_forth_dsp_pop 
2276				endm 
# End of macro FORTH_DSP_POP
2276			;		pop hl 
2276 45					ld b, l 
2277					if DEBUG_FORTH_WORDS 
2277						DMARK "PAU" 
2277 f5				push af  
2278 3a 8c 22			ld a, (.dmark)  
227b 32 7a ee			ld (debug_mark),a  
227e 3a 8d 22			ld a, (.dmark+1)  
2281 32 7b ee			ld (debug_mark+1),a  
2284 3a 8e 22			ld a, (.dmark+2)  
2287 32 7c ee			ld (debug_mark+2),a  
228a 18 03			jr .pastdmark  
228c ..			.dmark: db "PAU"  
228f f1			.pastdmark: pop af  
2290			endm  
# End of macro DMARK
2290						CALLMONITOR 
2290 cd 86 12			call break_point_state  
2293				endm  
# End of macro CALLMONITOR
2293					endif 
2293 c5			.pauses1:	push bc 
2294 cd e2 08				call delay1s 
2297 c1					pop bc 
2298					if DEBUG_FORTH_WORDS 
2298						DMARK "PA1" 
2298 f5				push af  
2299 3a ad 22			ld a, (.dmark)  
229c 32 7a ee			ld (debug_mark),a  
229f 3a ae 22			ld a, (.dmark+1)  
22a2 32 7b ee			ld (debug_mark+1),a  
22a5 3a af 22			ld a, (.dmark+2)  
22a8 32 7c ee			ld (debug_mark+2),a  
22ab 18 03			jr .pastdmark  
22ad ..			.dmark: db "PA1"  
22b0 f1			.pastdmark: pop af  
22b1			endm  
# End of macro DMARK
22b1						CALLMONITOR 
22b1 cd 86 12			call break_point_state  
22b4				endm  
# End of macro CALLMONITOR
22b4					endif 
22b4 10 dd				djnz .pauses1 
22b6			 
22b6				       NEXTW 
22b6 c3 11 1a			jp macro_next 
22b9				endm 
# End of macro NEXTW
22b9			.ROT: 
22b9				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
22b9 45				db WORD_SYS_CORE+49             
22ba 07 23			dw .UWORDS            
22bc 04				db 3 + 1 
22bd .. 00			db "ROT",0              
22c1				endm 
# End of macro CWHEAD
22c1			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
22c1					if DEBUG_FORTH_WORDS_KEY 
22c1						DMARK "ROT" 
22c1 f5				push af  
22c2 3a d6 22			ld a, (.dmark)  
22c5 32 7a ee			ld (debug_mark),a  
22c8 3a d7 22			ld a, (.dmark+1)  
22cb 32 7b ee			ld (debug_mark+1),a  
22ce 3a d8 22			ld a, (.dmark+2)  
22d1 32 7c ee			ld (debug_mark+2),a  
22d4 18 03			jr .pastdmark  
22d6 ..			.dmark: db "ROT"  
22d9 f1			.pastdmark: pop af  
22da			endm  
# End of macro DMARK
22da						CALLMONITOR 
22da cd 86 12			call break_point_state  
22dd				endm  
# End of macro CALLMONITOR
22dd					endif 
22dd			 
22dd					FORTH_DSP_VALUEHL 
22dd cd bb 18			call macro_dsp_valuehl 
22e0				endm 
# End of macro FORTH_DSP_VALUEHL
22e0 e5					push hl    ; u3  
22e1			 
22e1					FORTH_DSP_POP 
22e1 cd 57 19			call macro_forth_dsp_pop 
22e4				endm 
# End of macro FORTH_DSP_POP
22e4			   
22e4					FORTH_DSP_VALUEHL 
22e4 cd bb 18			call macro_dsp_valuehl 
22e7				endm 
# End of macro FORTH_DSP_VALUEHL
22e7 e5					push hl     ; u2 
22e8			 
22e8					FORTH_DSP_POP 
22e8 cd 57 19			call macro_forth_dsp_pop 
22eb				endm 
# End of macro FORTH_DSP_POP
22eb			 
22eb					FORTH_DSP_VALUEHL 
22eb cd bb 18			call macro_dsp_valuehl 
22ee				endm 
# End of macro FORTH_DSP_VALUEHL
22ee e5					push hl     ; u1 
22ef			 
22ef					FORTH_DSP_POP 
22ef cd 57 19			call macro_forth_dsp_pop 
22f2				endm 
# End of macro FORTH_DSP_POP
22f2			 
22f2 c1					pop bc      ; u1 
22f3 e1					pop hl      ; u2 
22f4 d1					pop de      ; u3 
22f5			 
22f5			 
22f5 c5					push bc 
22f6 d5					push de 
22f7 e5					push hl 
22f8			 
22f8			 
22f8 e1					pop hl 
22f9 cd 20 18				call forth_push_numhl 
22fc			 
22fc e1					pop hl 
22fd cd 20 18				call forth_push_numhl 
2300			 
2300 e1					pop hl 
2301 cd 20 18				call forth_push_numhl 
2304					 
2304			 
2304			 
2304			 
2304			 
2304			 
2304				       NEXTW 
2304 c3 11 1a			jp macro_next 
2307				endm 
# End of macro NEXTW
2307			 
2307			.UWORDS: 
2307				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2307 50				db WORD_SYS_CORE+60             
2308 c9 23			dw .BP            
230a 07				db 6 + 1 
230b .. 00			db "UWORDS",0              
2312				endm 
# End of macro CWHEAD
2312			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2312			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2312			; | | Following the count are the individual words. 
2312			; | | 
2312			; | | e.g. UWORDS 
2312			; | | BOX DIRLIST 2 
2312			; | |  
2312			; | | Can be used to save the words to storage via: 
2312			; | | UWORDS $01 DO $01 APPEND LOOP 
2312				if DEBUG_FORTH_WORDS_KEY 
2312					DMARK "UWR" 
2312 f5				push af  
2313 3a 27 23			ld a, (.dmark)  
2316 32 7a ee			ld (debug_mark),a  
2319 3a 28 23			ld a, (.dmark+1)  
231c 32 7b ee			ld (debug_mark+1),a  
231f 3a 29 23			ld a, (.dmark+2)  
2322 32 7c ee			ld (debug_mark+2),a  
2325 18 03			jr .pastdmark  
2327 ..			.dmark: db "UWR"  
232a f1			.pastdmark: pop af  
232b			endm  
# End of macro DMARK
232b					CALLMONITOR 
232b cd 86 12			call break_point_state  
232e				endm  
# End of macro CALLMONITOR
232e				endif 
232e 21 17 56				ld hl, baseram 
2331					;ld hl, baseusermem 
2331 01 00 00				ld bc, 0    ; start a counter 
2334			 
2334				; skip dict stub 
2334			 
2334 cd 62 1b				call forth_tok_next 
2337			 
2337			 
2337			; while we have words to look for 
2337			 
2337 7e			.douscan:	ld a, (hl)      
2338				if DEBUG_FORTH_WORDS 
2338					DMARK "UWs" 
2338 f5				push af  
2339 3a 4d 23			ld a, (.dmark)  
233c 32 7a ee			ld (debug_mark),a  
233f 3a 4e 23			ld a, (.dmark+1)  
2342 32 7b ee			ld (debug_mark+1),a  
2345 3a 4f 23			ld a, (.dmark+2)  
2348 32 7c ee			ld (debug_mark+2),a  
234b 18 03			jr .pastdmark  
234d ..			.dmark: db "UWs"  
2350 f1			.pastdmark: pop af  
2351			endm  
# End of macro DMARK
2351					CALLMONITOR 
2351 cd 86 12			call break_point_state  
2354				endm  
# End of macro CALLMONITOR
2354				endif 
2354 fe 00				cp WORD_SYS_END 
2356 28 4d				jr z, .udone 
2358 fe 01				cp WORD_SYS_UWORD 
235a 20 44				jr nz, .nuword 
235c			 
235c				if DEBUG_FORTH_WORDS 
235c					DMARK "UWu" 
235c f5				push af  
235d 3a 71 23			ld a, (.dmark)  
2360 32 7a ee			ld (debug_mark),a  
2363 3a 72 23			ld a, (.dmark+1)  
2366 32 7b ee			ld (debug_mark+1),a  
2369 3a 73 23			ld a, (.dmark+2)  
236c 32 7c ee			ld (debug_mark+2),a  
236f 18 03			jr .pastdmark  
2371 ..			.dmark: db "UWu"  
2374 f1			.pastdmark: pop af  
2375			endm  
# End of macro DMARK
2375					CALLMONITOR 
2375 cd 86 12			call break_point_state  
2378				endm  
# End of macro CALLMONITOR
2378				endif 
2378					; we have a uword so push its name to the stack 
2378			 
2378 e5				   	push hl  ; save so we can move to next dict block 
2379			 
2379					; skip opcode 
2379 23					inc hl  
237a					; skip next ptr 
237a 23					inc hl  
237b 23					inc hl 
237c					; skip len 
237c 23					inc hl 
237d				if DEBUG_FORTH_WORDS 
237d					DMARK "UWt" 
237d f5				push af  
237e 3a 92 23			ld a, (.dmark)  
2381 32 7a ee			ld (debug_mark),a  
2384 3a 93 23			ld a, (.dmark+1)  
2387 32 7b ee			ld (debug_mark+1),a  
238a 3a 94 23			ld a, (.dmark+2)  
238d 32 7c ee			ld (debug_mark+2),a  
2390 18 03			jr .pastdmark  
2392 ..			.dmark: db "UWt"  
2395 f1			.pastdmark: pop af  
2396			endm  
# End of macro DMARK
2396					CALLMONITOR 
2396 cd 86 12			call break_point_state  
2399				endm  
# End of macro CALLMONITOR
2399				endif 
2399 03					inc bc 
239a			 
239a c5					push bc 
239b cd 32 18				call forth_push_str 
239e c1					pop bc 
239f			 
239f e1					pop hl 	 
23a0			 
23a0 cd 62 1b		.nuword:	call forth_tok_next 
23a3 18 92				jr .douscan  
23a5			 
23a5			.udone:		 ; push count of uwords found 
23a5 c5					push bc 
23a6 e1					pop hl 
23a7			 
23a7				if DEBUG_FORTH_WORDS 
23a7					DMARK "UWc" 
23a7 f5				push af  
23a8 3a bc 23			ld a, (.dmark)  
23ab 32 7a ee			ld (debug_mark),a  
23ae 3a bd 23			ld a, (.dmark+1)  
23b1 32 7b ee			ld (debug_mark+1),a  
23b4 3a be 23			ld a, (.dmark+2)  
23b7 32 7c ee			ld (debug_mark+2),a  
23ba 18 03			jr .pastdmark  
23bc ..			.dmark: db "UWc"  
23bf f1			.pastdmark: pop af  
23c0			endm  
# End of macro DMARK
23c0					CALLMONITOR 
23c0 cd 86 12			call break_point_state  
23c3				endm  
# End of macro CALLMONITOR
23c3				endif 
23c3 cd 20 18				call forth_push_numhl 
23c6			 
23c6			 
23c6				       NEXTW 
23c6 c3 11 1a			jp macro_next 
23c9				endm 
# End of macro NEXTW
23c9			 
23c9			.BP: 
23c9				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
23c9 54				db WORD_SYS_CORE+64             
23ca ff 23			dw .MONITOR            
23cc 03				db 2 + 1 
23cd .. 00			db "BP",0              
23d0				endm 
# End of macro CWHEAD
23d0			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
23d0			; | | $00 Will enable the break points within specific code paths 
23d0			; | | $01 Will disable break points 
23d0			; | |  
23d0			; | | By default break points are off. Either the above can be used to enable them 
23d0			; | | or if a key is held down during start up the spashscreen will appear to freeze 
23d0			; | | and on release of the pressed key a message will be disaplayed to notify 
23d0			; | | that break points are enabled. Pressing any key will then continue boot process. 
23d0					; get byte count 
23d0					if DEBUG_FORTH_WORDS_KEY 
23d0						DMARK "BP." 
23d0 f5				push af  
23d1 3a e5 23			ld a, (.dmark)  
23d4 32 7a ee			ld (debug_mark),a  
23d7 3a e6 23			ld a, (.dmark+1)  
23da 32 7b ee			ld (debug_mark+1),a  
23dd 3a e7 23			ld a, (.dmark+2)  
23e0 32 7c ee			ld (debug_mark+2),a  
23e3 18 03			jr .pastdmark  
23e5 ..			.dmark: db "BP."  
23e8 f1			.pastdmark: pop af  
23e9			endm  
# End of macro DMARK
23e9						CALLMONITOR 
23e9 cd 86 12			call break_point_state  
23ec				endm  
# End of macro CALLMONITOR
23ec					endif 
23ec			 
23ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ec cd bb 18			call macro_dsp_valuehl 
23ef				endm 
# End of macro FORTH_DSP_VALUEHL
23ef			 
23ef			;		push hl 
23ef			 
23ef					; destroy value TOS 
23ef			 
23ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ef cd 57 19			call macro_forth_dsp_pop 
23f2				endm 
# End of macro FORTH_DSP_POP
23f2			 
23f2			;		pop hl 
23f2			 
23f2 3e 00				ld a,0 
23f4 bd					cp l 
23f5 28 02				jr z, .bpset 
23f7 3e 2a				ld a, '*' 
23f9			 
23f9 32 74 e3		.bpset:		ld (os_view_disable), a 
23fc			 
23fc			 
23fc					NEXTW 
23fc c3 11 1a			jp macro_next 
23ff				endm 
# End of macro NEXTW
23ff			 
23ff			 
23ff			.MONITOR: 
23ff				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
23ff 55				db WORD_SYS_CORE+65             
2400 32 24			dw .MALLOC            
2402 08				db 7 + 1 
2403 .. 00			db "MONITOR",0              
240b				endm 
# End of macro CWHEAD
240b			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
240b			; | | At start the current various registers will be displayed with contents. 
240b			; | | Top right corner will show the most recent debug marker seen. 
240b			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
240b			; | | and the return stack pointer (RSP). 
240b			; | | Pressing: 
240b			; | |    1 - Initial screen 
240b			; | |    2 - Display a data dump of HL 
240b			; | |    3 - Display a data dump of DE 
240b			; | |    4 - Display a data dump of BC 
240b			; | |    5 - Display a data dump of HL 
240b			; | |    6 - Display a data dump of DSP 
240b			; | |    7 - Display a data dump of RSP 
240b			; | |    8 - Display a data dump of what is at DSP 
240b			; | |    9 - Display a data dump of what is at RSP 
240b			; | |    0 - Exit monitor and continue running. This will also enable break points 
240b			; | |    * - Disable break points 
240b			; | |    # - Enter traditional monitor mode 
240b			; | | 
240b			; | | Monitor Mode 
240b			; | | ------------ 
240b			; | | A prompt of '>' will be shown for various commands: 
240b			; | |    D xxxx - Display a data dump starting from hex address xxxx 
240b			; | |    C - Continue display a data dump from the last set address 
240b			; | |    M xxxx - Set start of memory edit at address xx 
240b			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
240b			; | |    Q - Return to previous 
240b					if DEBUG_FORTH_WORDS_KEY 
240b						DMARK "MON" 
240b f5				push af  
240c 3a 20 24			ld a, (.dmark)  
240f 32 7a ee			ld (debug_mark),a  
2412 3a 21 24			ld a, (.dmark+1)  
2415 32 7b ee			ld (debug_mark+1),a  
2418 3a 22 24			ld a, (.dmark+2)  
241b 32 7c ee			ld (debug_mark+2),a  
241e 18 03			jr .pastdmark  
2420 ..			.dmark: db "MON"  
2423 f1			.pastdmark: pop af  
2424			endm  
# End of macro DMARK
2424						CALLMONITOR 
2424 cd 86 12			call break_point_state  
2427				endm  
# End of macro CALLMONITOR
2427					endif 
2427 3e 00				ld a, 0 
2429 32 74 e3				ld (os_view_disable), a 
242c			 
242c					CALLMONITOR 
242c cd 86 12			call break_point_state  
242f				endm  
# End of macro CALLMONITOR
242f			 
242f			;	call monitor 
242f			 
242f					NEXTW 
242f c3 11 1a			jp macro_next 
2432				endm 
# End of macro NEXTW
2432			 
2432			 
2432			.MALLOC: 
2432				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2432 56				db WORD_SYS_CORE+66             
2433 5b 24			dw .MALLOC2            
2435 06				db 5 + 1 
2436 .. 00			db "ALLOT",0              
243c				endm 
# End of macro CWHEAD
243c			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
243c					if DEBUG_FORTH_WORDS_KEY 
243c						DMARK "ALL" 
243c f5				push af  
243d 3a 51 24			ld a, (.dmark)  
2440 32 7a ee			ld (debug_mark),a  
2443 3a 52 24			ld a, (.dmark+1)  
2446 32 7b ee			ld (debug_mark+1),a  
2449 3a 53 24			ld a, (.dmark+2)  
244c 32 7c ee			ld (debug_mark+2),a  
244f 18 03			jr .pastdmark  
2451 ..			.dmark: db "ALL"  
2454 f1			.pastdmark: pop af  
2455			endm  
# End of macro DMARK
2455						CALLMONITOR 
2455 cd 86 12			call break_point_state  
2458				endm  
# End of macro CALLMONITOR
2458					endif 
2458 c3 82 24				jp .mallocc 
245b			.MALLOC2: 
245b				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
245b 56				db WORD_SYS_CORE+66             
245c 99 24			dw .FREE            
245e 07				db 6 + 1 
245f .. 00			db "MALLOC",0              
2466				endm 
# End of macro CWHEAD
2466			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2466					; get byte count 
2466					if DEBUG_FORTH_WORDS_KEY 
2466						DMARK "MAL" 
2466 f5				push af  
2467 3a 7b 24			ld a, (.dmark)  
246a 32 7a ee			ld (debug_mark),a  
246d 3a 7c 24			ld a, (.dmark+1)  
2470 32 7b ee			ld (debug_mark+1),a  
2473 3a 7d 24			ld a, (.dmark+2)  
2476 32 7c ee			ld (debug_mark+2),a  
2479 18 03			jr .pastdmark  
247b ..			.dmark: db "MAL"  
247e f1			.pastdmark: pop af  
247f			endm  
# End of macro DMARK
247f						CALLMONITOR 
247f cd 86 12			call break_point_state  
2482				endm  
# End of macro CALLMONITOR
2482					endif 
2482			.mallocc: 
2482					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2482 cd bb 18			call macro_dsp_valuehl 
2485				endm 
# End of macro FORTH_DSP_VALUEHL
2485			 
2485			;		push hl 
2485			 
2485					; destroy value TOS 
2485			 
2485					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2485 cd 57 19			call macro_forth_dsp_pop 
2488				endm 
# End of macro FORTH_DSP_POP
2488			 
2488			;		pop hl 
2488 cd 89 0f				call malloc 
248b				if DEBUG_FORTH_MALLOC_GUARD 
248b f5					push af 
248c cd eb 0a				call ishlzero 
248f			;		ld a, l 
248f			;		add h 
248f			;		cp 0 
248f f1					pop af 
2490					 
2490 cc 74 42				call z,malloc_error 
2493				endif 
2493			 
2493 cd 20 18				call forth_push_numhl 
2496					NEXTW 
2496 c3 11 1a			jp macro_next 
2499				endm 
# End of macro NEXTW
2499			 
2499			.FREE: 
2499				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2499 57				db WORD_SYS_CORE+67             
249a ca 24			dw .LIST            
249c 05				db 4 + 1 
249d .. 00			db "FREE",0              
24a2				endm 
# End of macro CWHEAD
24a2			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
24a2					if DEBUG_FORTH_WORDS_KEY 
24a2						DMARK "FRE" 
24a2 f5				push af  
24a3 3a b7 24			ld a, (.dmark)  
24a6 32 7a ee			ld (debug_mark),a  
24a9 3a b8 24			ld a, (.dmark+1)  
24ac 32 7b ee			ld (debug_mark+1),a  
24af 3a b9 24			ld a, (.dmark+2)  
24b2 32 7c ee			ld (debug_mark+2),a  
24b5 18 03			jr .pastdmark  
24b7 ..			.dmark: db "FRE"  
24ba f1			.pastdmark: pop af  
24bb			endm  
# End of macro DMARK
24bb						CALLMONITOR 
24bb cd 86 12			call break_point_state  
24be				endm  
# End of macro CALLMONITOR
24be					endif 
24be					; get address 
24be			 
24be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24be cd bb 18			call macro_dsp_valuehl 
24c1				endm 
# End of macro FORTH_DSP_VALUEHL
24c1			 
24c1			;		push hl 
24c1			 
24c1					; destroy value TOS 
24c1			 
24c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24c1 cd 57 19			call macro_forth_dsp_pop 
24c4				endm 
# End of macro FORTH_DSP_POP
24c4			 
24c4			;		pop hl 
24c4			if FORTH_ENABLE_MALLOCFREE 
24c4 cd 53 10				call free 
24c7			endif 
24c7					NEXTW 
24c7 c3 11 1a			jp macro_next 
24ca				endm 
# End of macro NEXTW
24ca			.LIST: 
24ca				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
24ca 5c				db WORD_SYS_CORE+72             
24cb 8d 26			dw .FORGET            
24cd 05				db 4 + 1 
24ce .. 00			db "LIST",0              
24d3				endm 
# End of macro CWHEAD
24d3			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
24d3			; | | The quoted word must be in upper case. 
24d3				if DEBUG_FORTH_WORDS_KEY 
24d3					DMARK "LST" 
24d3 f5				push af  
24d4 3a e8 24			ld a, (.dmark)  
24d7 32 7a ee			ld (debug_mark),a  
24da 3a e9 24			ld a, (.dmark+1)  
24dd 32 7b ee			ld (debug_mark+1),a  
24e0 3a ea 24			ld a, (.dmark+2)  
24e3 32 7c ee			ld (debug_mark+2),a  
24e6 18 03			jr .pastdmark  
24e8 ..			.dmark: db "LST"  
24eb f1			.pastdmark: pop af  
24ec			endm  
# End of macro DMARK
24ec					CALLMONITOR 
24ec cd 86 12			call break_point_state  
24ef				endm  
# End of macro CALLMONITOR
24ef				endif 
24ef			 
24ef					FORTH_DSP_VALUEHL 
24ef cd bb 18			call macro_dsp_valuehl 
24f2				endm 
# End of macro FORTH_DSP_VALUEHL
24f2			 
24f2 e5					push hl 
24f3 c1					pop bc 
24f4			 
24f4			; Start format of scratch string 
24f4			 
24f4 21 75 e3				ld hl, scratch 
24f7			 
24f7 3e 3a				ld a, ':' 
24f9 77					ld (hl),a 
24fa 23					inc hl 
24fb 3e 20				ld a, ' ' 
24fd 77					ld (hl), a 
24fe			 
24fe					; Get ptr to the word we need to look up 
24fe			 
24fe			;		FORTH_DSP_VALUEHL 
24fe					;v5 FORTH_DSP_VALUE 
24fe				; TODO type check 
24fe			;		inc hl    ; Skip type check  
24fe			;		push hl 
24fe			;		ex de, hl    ; put into DE 
24fe			 
24fe			 
24fe 21 17 56				ld hl, baseram 
2501					;ld hl, baseusermem 
2501			 
2501 e5			push hl   ; sacreifical push 
2502			 
2502			.ldouscanm: 
2502 e1				pop hl 
2503			.ldouscan: 
2503				if DEBUG_FORTH_WORDS 
2503					DMARK "LSs" 
2503 f5				push af  
2504 3a 18 25			ld a, (.dmark)  
2507 32 7a ee			ld (debug_mark),a  
250a 3a 19 25			ld a, (.dmark+1)  
250d 32 7b ee			ld (debug_mark+1),a  
2510 3a 1a 25			ld a, (.dmark+2)  
2513 32 7c ee			ld (debug_mark+2),a  
2516 18 03			jr .pastdmark  
2518 ..			.dmark: db "LSs"  
251b f1			.pastdmark: pop af  
251c			endm  
# End of macro DMARK
251c					CALLMONITOR 
251c cd 86 12			call break_point_state  
251f				endm  
# End of macro CALLMONITOR
251f				endif 
251f				; skip dict stub 
251f cd 62 1b				call forth_tok_next 
2522			 
2522			 
2522			; while we have words to look for 
2522			 
2522 7e				ld a, (hl)      
2523				if DEBUG_FORTH_WORDS 
2523					DMARK "LSk" 
2523 f5				push af  
2524 3a 38 25			ld a, (.dmark)  
2527 32 7a ee			ld (debug_mark),a  
252a 3a 39 25			ld a, (.dmark+1)  
252d 32 7b ee			ld (debug_mark+1),a  
2530 3a 3a 25			ld a, (.dmark+2)  
2533 32 7c ee			ld (debug_mark+2),a  
2536 18 03			jr .pastdmark  
2538 ..			.dmark: db "LSk"  
253b f1			.pastdmark: pop af  
253c			endm  
# End of macro DMARK
253c					CALLMONITOR 
253c cd 86 12			call break_point_state  
253f				endm  
# End of macro CALLMONITOR
253f				endif 
253f fe 00				cp WORD_SYS_END 
2541 ca 74 26				jp z, .lunotfound 
2544 fe 01				cp WORD_SYS_UWORD 
2546 c2 03 25				jp nz, .ldouscan 
2549			 
2549				if DEBUG_FORTH_WORDS 
2549					DMARK "LSu" 
2549 f5				push af  
254a 3a 5e 25			ld a, (.dmark)  
254d 32 7a ee			ld (debug_mark),a  
2550 3a 5f 25			ld a, (.dmark+1)  
2553 32 7b ee			ld (debug_mark+1),a  
2556 3a 60 25			ld a, (.dmark+2)  
2559 32 7c ee			ld (debug_mark+2),a  
255c 18 03			jr .pastdmark  
255e ..			.dmark: db "LSu"  
2561 f1			.pastdmark: pop af  
2562			endm  
# End of macro DMARK
2562					CALLMONITOR 
2562 cd 86 12			call break_point_state  
2565				endm  
# End of macro CALLMONITOR
2565				endif 
2565			 
2565					; found a uword but is it the one we want... 
2565			 
2565 c5					push bc     ; uword to find is on bc 
2566 d1					pop de 
2567			 
2567 e5					push hl  ; to save the ptr 
2568			 
2568					; skip opcode 
2568 23					inc hl  
2569					; skip next ptr 
2569 23					inc hl  
256a 23					inc hl 
256b					; skip len 
256b 23					inc hl 
256c			 
256c				if DEBUG_FORTH_WORDS 
256c					DMARK "LSc" 
256c f5				push af  
256d 3a 81 25			ld a, (.dmark)  
2570 32 7a ee			ld (debug_mark),a  
2573 3a 82 25			ld a, (.dmark+1)  
2576 32 7b ee			ld (debug_mark+1),a  
2579 3a 83 25			ld a, (.dmark+2)  
257c 32 7c ee			ld (debug_mark+2),a  
257f 18 03			jr .pastdmark  
2581 ..			.dmark: db "LSc"  
2584 f1			.pastdmark: pop af  
2585			endm  
# End of macro DMARK
2585					CALLMONITOR 
2585 cd 86 12			call break_point_state  
2588				endm  
# End of macro CALLMONITOR
2588				endif 
2588 cd 58 0f				call strcmp 
258b c2 02 25				jp nz, .ldouscanm 
258e				 
258e			 
258e			 
258e					; we have a uword so push its name to the stack 
258e			 
258e			;	   	push hl  ; save so we can move to next dict block 
258e e1			pop hl 
258f			 
258f				if DEBUG_FORTH_WORDS 
258f					DMARK "LSm" 
258f f5				push af  
2590 3a a4 25			ld a, (.dmark)  
2593 32 7a ee			ld (debug_mark),a  
2596 3a a5 25			ld a, (.dmark+1)  
2599 32 7b ee			ld (debug_mark+1),a  
259c 3a a6 25			ld a, (.dmark+2)  
259f 32 7c ee			ld (debug_mark+2),a  
25a2 18 03			jr .pastdmark  
25a4 ..			.dmark: db "LSm"  
25a7 f1			.pastdmark: pop af  
25a8			endm  
# End of macro DMARK
25a8					CALLMONITOR 
25a8 cd 86 12			call break_point_state  
25ab				endm  
# End of macro CALLMONITOR
25ab				endif 
25ab			 
25ab					; skip opcode 
25ab 23					inc hl  
25ac					; skip next ptr 
25ac 23					inc hl  
25ad 23					inc hl 
25ae					; skip len 
25ae 7e					ld a, (hl)   ; save length to add 
25af				if DEBUG_FORTH_WORDS 
25af					DMARK "LS2" 
25af f5				push af  
25b0 3a c4 25			ld a, (.dmark)  
25b3 32 7a ee			ld (debug_mark),a  
25b6 3a c5 25			ld a, (.dmark+1)  
25b9 32 7b ee			ld (debug_mark+1),a  
25bc 3a c6 25			ld a, (.dmark+2)  
25bf 32 7c ee			ld (debug_mark+2),a  
25c2 18 03			jr .pastdmark  
25c4 ..			.dmark: db "LS2"  
25c7 f1			.pastdmark: pop af  
25c8			endm  
# End of macro DMARK
25c8					CALLMONITOR 
25c8 cd 86 12			call break_point_state  
25cb				endm  
# End of macro CALLMONITOR
25cb				endif 
25cb			 
25cb					; save this location 
25cb				 
25cb e5					push hl 
25cc			 
25cc 23					inc hl 
25cd 11 77 e3				ld de, scratch+2 
25d0 4f					ld c, a 
25d1 06 00				ld b, 0 
25d3			 
25d3				if DEBUG_FORTH_WORDS 
25d3					DMARK "LSn" 
25d3 f5				push af  
25d4 3a e8 25			ld a, (.dmark)  
25d7 32 7a ee			ld (debug_mark),a  
25da 3a e9 25			ld a, (.dmark+1)  
25dd 32 7b ee			ld (debug_mark+1),a  
25e0 3a ea 25			ld a, (.dmark+2)  
25e3 32 7c ee			ld (debug_mark+2),a  
25e6 18 03			jr .pastdmark  
25e8 ..			.dmark: db "LSn"  
25eb f1			.pastdmark: pop af  
25ec			endm  
# End of macro DMARK
25ec					CALLMONITOR 
25ec cd 86 12			call break_point_state  
25ef				endm  
# End of macro CALLMONITOR
25ef				endif 
25ef			 
25ef					; copy uword name to scratch 
25ef			 
25ef ed b0				ldir 
25f1			 
25f1 1b					dec de 
25f2 3e 20				ld a, ' '    ; change null to space 
25f4 12					ld (de), a 
25f5			 
25f5 13					inc de 
25f6			 
25f6 d5					push de 
25f7 c1					pop bc     ; move scratch pointer to end of word name and save it 
25f8			 
25f8 e1					pop hl 
25f9 7e					ld a, (hl) 
25fa					;inc hl 
25fa					; skip word string 
25fa cd c2 0a				call addatohl 
25fd			 
25fd 23					inc hl 
25fe			 
25fe				if DEBUG_FORTH_WORDS 
25fe					DMARK "LS3" 
25fe f5				push af  
25ff 3a 13 26			ld a, (.dmark)  
2602 32 7a ee			ld (debug_mark),a  
2605 3a 14 26			ld a, (.dmark+1)  
2608 32 7b ee			ld (debug_mark+1),a  
260b 3a 15 26			ld a, (.dmark+2)  
260e 32 7c ee			ld (debug_mark+2),a  
2611 18 03			jr .pastdmark  
2613 ..			.dmark: db "LS3"  
2616 f1			.pastdmark: pop af  
2617			endm  
# End of macro DMARK
2617					CALLMONITOR 
2617 cd 86 12			call break_point_state  
261a				endm  
# End of macro CALLMONITOR
261a				endif 
261a					; should now be at the start of the machine code to setup the eval of the uword 
261a					; now locate the ptr to the string defintion 
261a			 
261a					; skip ld hl, 
261a					; then load the ptr 
261a			 
261a 23					inc hl 
261b 5e					ld e, (hl) 
261c 23					inc hl 
261d 56					ld d, (hl) 
261e eb					ex de, hl 
261f			 
261f			 
261f				if DEBUG_FORTH_WORDS 
261f					DMARK "LSt" 
261f f5				push af  
2620 3a 34 26			ld a, (.dmark)  
2623 32 7a ee			ld (debug_mark),a  
2626 3a 35 26			ld a, (.dmark+1)  
2629 32 7b ee			ld (debug_mark+1),a  
262c 3a 36 26			ld a, (.dmark+2)  
262f 32 7c ee			ld (debug_mark+2),a  
2632 18 03			jr .pastdmark  
2634 ..			.dmark: db "LSt"  
2637 f1			.pastdmark: pop af  
2638			endm  
# End of macro DMARK
2638					CALLMONITOR 
2638 cd 86 12			call break_point_state  
263b				endm  
# End of macro CALLMONITOR
263b				endif 
263b			 
263b			; cant push right now due to tokenised strings  
263b			 
263b			; get the destination of where to copy this definition to. 
263b			 
263b c5					push bc 
263c d1					pop de 
263d			 
263d 7e			.listl:         ld a,(hl) 
263e fe 00				cp 0 
2640 28 09				jr z, .lreplsp     ; replace zero with space 
2642 fe 7f				cp FORTH_END_BUFFER 
2644 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2646				 
2646					; just copy this char as is then 
2646			 
2646 12					ld (de), a 
2647			 
2647 23			.listnxt:	inc hl 
2648 13					inc de 
2649 18 f2				jr .listl 
264b			 
264b 3e 20		.lreplsp:	ld a,' ' 
264d 12					ld (de), a 
264e 18 f7				jr .listnxt 
2650			 
2650			; close up uword def 
2650			 
2650			.listdone: 
2650 3e 00				ld a, 0 
2652 12					ld (de), a 
2653			 
2653			; now have def so clean up and push to stack 
2653			 
2653 21 75 e3				ld hl, scratch 
2656				if DEBUG_FORTH_WORDS 
2656					DMARK "Ltp" 
2656 f5				push af  
2657 3a 6b 26			ld a, (.dmark)  
265a 32 7a ee			ld (debug_mark),a  
265d 3a 6c 26			ld a, (.dmark+1)  
2660 32 7b ee			ld (debug_mark+1),a  
2663 3a 6d 26			ld a, (.dmark+2)  
2666 32 7c ee			ld (debug_mark+2),a  
2669 18 03			jr .pastdmark  
266b ..			.dmark: db "Ltp"  
266e f1			.pastdmark: pop af  
266f			endm  
# End of macro DMARK
266f					CALLMONITOR 
266f cd 86 12			call break_point_state  
2672				endm  
# End of macro CALLMONITOR
2672				endif 
2672			 
2672 18 06			jr .listpush 
2674			 
2674			;.lnuword:	pop hl 
2674			;		call forth_tok_next 
2674			;		jp .ldouscan  
2674			 
2674			.lunotfound:		  
2674			 
2674			 
2674					 
2674					FORTH_DSP_POP 
2674 cd 57 19			call macro_forth_dsp_pop 
2677				endm 
# End of macro FORTH_DSP_POP
2677 21 80 26				ld hl, .luno 
267a						 
267a			 
267a			.listpush: 
267a cd 32 18				call forth_push_str 
267d			 
267d			 
267d			 
267d					NEXTW 
267d c3 11 1a			jp macro_next 
2680				endm 
# End of macro NEXTW
2680			 
2680 .. 00		.luno:    db "Not found",0 
268a			 
268a			 
268a			 
268a			 
268a			 
268a			;		push hl   ; save pointer to start of uword def string 
268a			; 
268a			;; look for FORTH_EOL_LINE 
268a			;		ld a, FORTH_END_BUFFER 
268a			;		call strlent 
268a			; 
268a			;		inc hl		 ; space for coln def 
268a			;		inc hl 
268a			;		inc hl          ; space for terms 
268a			;		inc hl 
268a			; 
268a			;		ld a, 20   ; TODO get actual length 
268a			;		call addatohl    ; include a random amount of room for the uword name 
268a			; 
268a			;		 
268a			;	if DEBUG_FORTH_WORDS 
268a			;		DMARK "Lt1" 
268a			;		CALLMONITOR 
268a			;	endif 
268a			;		 
268a			; 
268a			;; malloc space for the string because we cant change it 
268a			; 
268a			;		call malloc 
268a			;	if DEBUG_FORTH_MALLOC_GUARD 
268a			;		push af 
268a			;		call ishlzero 
268a			;		pop af 
268a			;		 
268a			;		call z,malloc_error 
268a			;	endif 
268a			; 
268a			;	if DEBUG_FORTH_WORDS 
268a			;		DMARK "Lt2" 
268a			;		CALLMONITOR 
268a			;	endif 
268a			;		pop de 
268a			;		push hl    ; push the malloc to release later 
268a			;		push hl   ;  push back a copy for the later stack push 
268a			;		 
268a			;; copy the string swapping out the zero terms for spaces 
268a			; 
268a			;		; de has our source 
268a			;		; hl has our dest 
268a			; 
268a			;; add the coln def 
268a			; 
268a			;		ld a, ':' 
268a			;		ld (hl), a 
268a			;		inc hl 
268a			;		ld a, ' ' 
268a			;		ld (hl), a 
268a			;		inc hl 
268a			; 
268a			;; add the uname word 
268a			;		push de   ; save our string for now 
268a			;		ex de, hl 
268a			; 
268a			;		FORTH_DSP_VALUE 
268a			;		;v5 FORTH_DSP_VALUE 
268a			; 
268a			;		inc hl   ; skip type but we know by now this is OK 
268a			; 
268a			;.luword:	ld a,(hl) 
268a			;		cp 0 
268a			;		jr z, .luword2 
268a			;		ld (de), a 
268a			;		inc de 
268a			;		inc hl 
268a			;		jr .luword 
268a			; 
268a			;.luword2:	ld a, ' ' 
268a			;		ld (de), a 
268a			;;		inc hl 
268a			;;		inc de 
268a			;;		ld (de), a 
268a			;;		inc hl 
268a			;		inc de 
268a			; 
268a			;		ex de, hl 
268a			;		pop de 
268a			;		 
268a			;		 
268a			; 
268a			;; detoken that string and copy it 
268a			; 
268a			;	if DEBUG_FORTH_WORDS 
268a			;		DMARK "Lt2" 
268a			;		CALLMONITOR 
268a			;	endif 
268a			;.ldetok:	ld a, (de) 
268a			;		cp FORTH_END_BUFFER 
268a			;		jr z, .ldetokend 
268a			;		; swap out any zero term for space 
268a			;		cp 0 
268a			;		jr nz, .ldetoknext 
268a			;		ld a, ' ' 
268a			; 
268a			;	if DEBUG_FORTH_WORDS 
268a			;		DMARK "LtS" 
268a			;		CALLMONITOR 
268a			;	endif 
268a			;.ldetoknext:	ld (hl), a 
268a			;		inc de 
268a			;		inc hl 
268a			;		jr .ldetok 
268a			; 
268a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
268a			;		ld (hl), a  
268a			; 
268a			;; free that temp malloc 
268a			; 
268a			;		pop hl    
268a			; 
268a			;	if DEBUG_FORTH_WORDS 
268a			;		DMARK "Lt4" 
268a			;		CALLMONITOR 
268a			;	endif 
268a			;		call forth_apushstrhl 
268a			; 
268a			;		; get rid of temp malloc area 
268a			; 
268a			;		pop hl 
268a			;		call free 
268a			; 
268a			;		jr .ludone 
268a			; 
268a			;.lnuword:	pop hl 
268a			;		call forth_tok_next 
268a			;		jp .ldouscan  
268a			; 
268a			;.ludone:		 pop hl 
268a			; 
268a					NEXTW 
268a c3 11 1a			jp macro_next 
268d				endm 
# End of macro NEXTW
268d			 
268d			.FORGET: 
268d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
268d 5d				db WORD_SYS_CORE+73             
268e 06 27			dw .NOP            
2690 07				db 6 + 1 
2691 .. 00			db "FORGET",0              
2698				endm 
# End of macro CWHEAD
2698			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2698			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2698			; | |  
2698			; | | e.g. "MORE" forget 
2698					if DEBUG_FORTH_WORDS_KEY 
2698						DMARK "FRG" 
2698 f5				push af  
2699 3a ad 26			ld a, (.dmark)  
269c 32 7a ee			ld (debug_mark),a  
269f 3a ae 26			ld a, (.dmark+1)  
26a2 32 7b ee			ld (debug_mark+1),a  
26a5 3a af 26			ld a, (.dmark+2)  
26a8 32 7c ee			ld (debug_mark+2),a  
26ab 18 03			jr .pastdmark  
26ad ..			.dmark: db "FRG"  
26b0 f1			.pastdmark: pop af  
26b1			endm  
# End of macro DMARK
26b1						CALLMONITOR 
26b1 cd 86 12			call break_point_state  
26b4				endm  
# End of macro CALLMONITOR
26b4					endif 
26b4			 
26b4				; find uword 
26b4			        ; update start of word with "_" 
26b4				; replace uword with deleted flag 
26b4			 
26b4			 
26b4			;	if DEBUG_FORTH_WORDS 
26b4			;		DMARK "FOG" 
26b4			;		CALLMONITOR 
26b4			;	endif 
26b4			 
26b4			 
26b4					; Get ptr to the word we need to look up 
26b4			 
26b4					FORTH_DSP_VALUEHL 
26b4 cd bb 18			call macro_dsp_valuehl 
26b7				endm 
# End of macro FORTH_DSP_VALUEHL
26b7					;v5 FORTH_DSP_VALUE 
26b7				; TODO type check 
26b7			;		inc hl    ; Skip type check  
26b7 e5					push hl 
26b8 c1					pop bc 
26b9			;		ex de, hl    ; put into DE 
26b9			 
26b9			 
26b9 21 17 56				ld hl, baseram 
26bc					;ld hl, baseusermem 
26bc			 
26bc				; skip dict stub 
26bc			;	call forth_tok_next 
26bc e5			push hl   ; sacreifical push 
26bd			 
26bd			.fldouscanm: 
26bd e1				pop hl 
26be			.fldouscan: 
26be			;	if DEBUG_FORTH_WORDS 
26be			;		DMARK "LSs" 
26be			;		CALLMONITOR 
26be			;	endif 
26be				; skip dict stub 
26be cd 62 1b				call forth_tok_next 
26c1			 
26c1			 
26c1			; while we have words to look for 
26c1			 
26c1 7e				ld a, (hl)      
26c2			;	if DEBUG_FORTH_WORDS 
26c2			;		DMARK "LSk" 
26c2			;		CALLMONITOR 
26c2			;	endif 
26c2 fe 00				cp WORD_SYS_END 
26c4 ca 00 27				jp z, .flunotfound 
26c7 fe 01				cp WORD_SYS_UWORD 
26c9 c2 be 26				jp nz, .fldouscan 
26cc			 
26cc			;	if DEBUG_FORTH_WORDS 
26cc			;		DMARK "LSu" 
26cc			;		CALLMONITOR 
26cc			;	endif 
26cc			 
26cc					; found a uword but is it the one we want... 
26cc			 
26cc c5					push bc     ; uword to find is on bc 
26cd d1					pop de 
26ce			 
26ce e5					push hl  ; to save the ptr 
26cf			 
26cf					; skip opcode 
26cf 23					inc hl  
26d0					; skip next ptr 
26d0 23					inc hl  
26d1 23					inc hl 
26d2					; skip len 
26d2 23					inc hl 
26d3			 
26d3			;	if DEBUG_FORTH_WORDS 
26d3			;		DMARK "LSc" 
26d3			;		CALLMONITOR 
26d3			;	endif 
26d3 cd 58 0f				call strcmp 
26d6 c2 bd 26				jp nz, .fldouscanm 
26d9			; 
26d9			; 
26d9			;; while we have words to look for 
26d9			; 
26d9			;.fdouscan:	ld a, (hl)      
26d9			;	if DEBUG_FORTH_WORDS 
26d9			;		DMARK "LSs" 
26d9			;		CALLMONITOR 
26d9			;	endif 
26d9			;		cp WORD_SYS_END 
26d9			;		jp z, .fudone 
26d9			;		cp WORD_SYS_UWORD 
26d9			;		jp nz, .fnuword 
26d9			; 
26d9			;	if DEBUG_FORTH_WORDS 
26d9			;		DMARK "FGu" 
26d9			;		CALLMONITOR 
26d9			;	endif 
26d9			; 
26d9			;		; found a uword but is it the one we want... 
26d9			; 
26d9			; 
26d9			;	        pop de   ; get back the dsp name 
26d9			;		push de 
26d9			; 
26d9			;		push hl  ; to save the ptr 
26d9			; 
26d9			;		; skip opcode 
26d9			;		inc hl  
26d9			;		; skip next ptr 
26d9			;		inc hl  
26d9			;		inc hl 
26d9			;		; skip len 
26d9			;		inc hl 
26d9			; 
26d9			;	if DEBUG_FORTH_WORDS 
26d9			;		DMARK "FGc" 
26d9			;		CALLMONITOR 
26d9			;	endif 
26d9			;		call strcmp 
26d9			;		jp nz, .fnuword 
26d9			 
26d9			 
26d9 e1			pop hl 
26da			 
26da				 
26da				if DEBUG_FORTH_WORDS 
26da					DMARK "FGm" 
26da f5				push af  
26db 3a ef 26			ld a, (.dmark)  
26de 32 7a ee			ld (debug_mark),a  
26e1 3a f0 26			ld a, (.dmark+1)  
26e4 32 7b ee			ld (debug_mark+1),a  
26e7 3a f1 26			ld a, (.dmark+2)  
26ea 32 7c ee			ld (debug_mark+2),a  
26ed 18 03			jr .pastdmark  
26ef ..			.dmark: db "FGm"  
26f2 f1			.pastdmark: pop af  
26f3			endm  
# End of macro DMARK
26f3					CALLMONITOR 
26f3 cd 86 12			call break_point_state  
26f6				endm  
# End of macro CALLMONITOR
26f6				endif 
26f6			 
26f6			 
26f6			 
26f6					; we have a uword so push its name to the stack 
26f6			 
26f6			;	   	push hl  ; save so we can move to next dict block 
26f6			;pop hl 
26f6			 
26f6					; update opcode to deleted 
26f6 3e 03				ld a, WORD_SYS_DELETED 
26f8 77					ld (hl), a 
26f9			 
26f9 23					inc hl  
26fa					; skip next ptr 
26fa 23					inc hl  
26fb 23					inc hl 
26fc					; skip len 
26fc 23					inc hl 
26fd			 
26fd					; TODO change parser to skip deleted words but for now mark it out 
26fd 3e 5f				ld a, "_" 
26ff 77					ld  (hl),a 
2700			 
2700			;		jr .fudone 
2700			; 
2700			;.fnuword:	pop hl 
2700			;		call forth_tok_next 
2700			;		jp .fdouscan  
2700			 
2700			.flunotfound:		  
2700			 
2700			 
2700					 
2700					FORTH_DSP_POP 
2700 cd 57 19			call macro_forth_dsp_pop 
2703				endm 
# End of macro FORTH_DSP_POP
2703			;		ld hl, .luno 
2703			;.fudone:		 pop hl 
2703					NEXTW 
2703 c3 11 1a			jp macro_next 
2706				endm 
# End of macro NEXTW
2706			.NOP: 
2706				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2706 61				db WORD_SYS_CORE+77             
2707 2d 27			dw .COMO            
2709 04				db 3 + 1 
270a .. 00			db "NOP",0              
270e				endm 
# End of macro CWHEAD
270e			; | NOP (  --  ) Do nothing | DONE 
270e					if DEBUG_FORTH_WORDS_KEY 
270e						DMARK "NOP" 
270e f5				push af  
270f 3a 23 27			ld a, (.dmark)  
2712 32 7a ee			ld (debug_mark),a  
2715 3a 24 27			ld a, (.dmark+1)  
2718 32 7b ee			ld (debug_mark+1),a  
271b 3a 25 27			ld a, (.dmark+2)  
271e 32 7c ee			ld (debug_mark+2),a  
2721 18 03			jr .pastdmark  
2723 ..			.dmark: db "NOP"  
2726 f1			.pastdmark: pop af  
2727			endm  
# End of macro DMARK
2727						CALLMONITOR 
2727 cd 86 12			call break_point_state  
272a				endm  
# End of macro CALLMONITOR
272a					endif 
272a				       NEXTW 
272a c3 11 1a			jp macro_next 
272d				endm 
# End of macro NEXTW
272d			.COMO: 
272d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
272d 6e				db WORD_SYS_CORE+90             
272e 7f 27			dw .COMC            
2730 02				db 1 + 1 
2731 .. 00			db "(",0              
2733				endm 
# End of macro CWHEAD
2733			; | ( ( -- )  Start of comment | DONE 
2733			 
2733			 
2733 2a 76 e6				ld hl, ( os_tok_ptr) 
2736 11 7a 27			ld de, .closepar 
2739					 
2739					if DEBUG_FORTH_WORDS 
2739						DMARK ").." 
2739 f5				push af  
273a 3a 4e 27			ld a, (.dmark)  
273d 32 7a ee			ld (debug_mark),a  
2740 3a 4f 27			ld a, (.dmark+1)  
2743 32 7b ee			ld (debug_mark+1),a  
2746 3a 50 27			ld a, (.dmark+2)  
2749 32 7c ee			ld (debug_mark+2),a  
274c 18 03			jr .pastdmark  
274e ..			.dmark: db ").."  
2751 f1			.pastdmark: pop af  
2752			endm  
# End of macro DMARK
2752						CALLMONITOR 
2752 cd 86 12			call break_point_state  
2755				endm  
# End of macro CALLMONITOR
2755					endif 
2755 cd 2c 1b			call findnexttok  
2758			 
2758					if DEBUG_FORTH_WORDS 
2758						DMARK "IF5" 
2758 f5				push af  
2759 3a 6d 27			ld a, (.dmark)  
275c 32 7a ee			ld (debug_mark),a  
275f 3a 6e 27			ld a, (.dmark+1)  
2762 32 7b ee			ld (debug_mark+1),a  
2765 3a 6f 27			ld a, (.dmark+2)  
2768 32 7c ee			ld (debug_mark+2),a  
276b 18 03			jr .pastdmark  
276d ..			.dmark: db "IF5"  
2770 f1			.pastdmark: pop af  
2771			endm  
# End of macro DMARK
2771						CALLMONITOR 
2771 cd 86 12			call break_point_state  
2774				endm  
# End of macro CALLMONITOR
2774					endif 
2774				; replace below with ) exec using tok_ptr 
2774 22 76 e6			ld (os_tok_ptr), hl 
2777 c3 a2 1a			jp exec1 
277a			 
277a .. 00			.closepar:   db ")",0 
277c			 
277c				       NEXTW 
277c c3 11 1a			jp macro_next 
277f				endm 
# End of macro NEXTW
277f			.COMC: 
277f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
277f 6f				db WORD_SYS_CORE+91             
2780 88 27			dw .SCRATCH            
2782 02				db 1 + 1 
2783 .. 00			db ")",0              
2785				endm 
# End of macro CWHEAD
2785			; | ) ( -- )  End of comment |  DONE  
2785				       NEXTW 
2785 c3 11 1a			jp macro_next 
2788				endm 
# End of macro NEXTW
2788			 
2788			.SCRATCH: 
2788				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2788 6f				db WORD_SYS_CORE+91             
2789 c3 27			dw .INC            
278b 08				db 7 + 1 
278c .. 00			db "SCRATCH",0              
2794				endm 
# End of macro CWHEAD
2794			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2794			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2794			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2794			; | |  
2794			; | | e.g.    : score $00 scratch ; 
2794			; | |  
2794			; | | $00 score ! 
2794			; | | $01 score +! 
2794			; | |  
2794			; | | e.g.   : varword $0a scratch ;  
2794			; | | 
2794			; | | $8000 varword ! 
2794					if DEBUG_FORTH_WORDS_KEY 
2794						DMARK "SCR" 
2794 f5				push af  
2795 3a a9 27			ld a, (.dmark)  
2798 32 7a ee			ld (debug_mark),a  
279b 3a aa 27			ld a, (.dmark+1)  
279e 32 7b ee			ld (debug_mark+1),a  
27a1 3a ab 27			ld a, (.dmark+2)  
27a4 32 7c ee			ld (debug_mark+2),a  
27a7 18 03			jr .pastdmark  
27a9 ..			.dmark: db "SCR"  
27ac f1			.pastdmark: pop af  
27ad			endm  
# End of macro DMARK
27ad						CALLMONITOR 
27ad cd 86 12			call break_point_state  
27b0				endm  
# End of macro CALLMONITOR
27b0					endif 
27b0			 
27b0					FORTH_DSP_VALUEHL 
27b0 cd bb 18			call macro_dsp_valuehl 
27b3				endm 
# End of macro FORTH_DSP_VALUEHL
27b3				 
27b3					FORTH_DSP_POP 
27b3 cd 57 19			call macro_forth_dsp_pop 
27b6				endm 
# End of macro FORTH_DSP_POP
27b6			 
27b6 7d					ld a, l 
27b7 21 9a e8				ld hl, os_var_array 
27ba cd c2 0a				call addatohl 
27bd			 
27bd cd 20 18				call forth_push_numhl 
27c0			 
27c0				       NEXTW 
27c0 c3 11 1a			jp macro_next 
27c3				endm 
# End of macro NEXTW
27c3			 
27c3			.INC: 
27c3				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
27c3 6f				db WORD_SYS_CORE+91             
27c4 17 28			dw .DEC            
27c6 03				db 2 + 1 
27c7 .. 00			db "+!",0              
27ca				endm 
# End of macro CWHEAD
27ca			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
27ca					if DEBUG_FORTH_WORDS_KEY 
27ca						DMARK "+s_" 
27ca f5				push af  
27cb 3a df 27			ld a, (.dmark)  
27ce 32 7a ee			ld (debug_mark),a  
27d1 3a e0 27			ld a, (.dmark+1)  
27d4 32 7b ee			ld (debug_mark+1),a  
27d7 3a e1 27			ld a, (.dmark+2)  
27da 32 7c ee			ld (debug_mark+2),a  
27dd 18 03			jr .pastdmark  
27df ..			.dmark: db "+s_"  
27e2 f1			.pastdmark: pop af  
27e3			endm  
# End of macro DMARK
27e3						CALLMONITOR 
27e3 cd 86 12			call break_point_state  
27e6				endm  
# End of macro CALLMONITOR
27e6					endif 
27e6			 
27e6					FORTH_DSP_VALUEHL 
27e6 cd bb 18			call macro_dsp_valuehl 
27e9				endm 
# End of macro FORTH_DSP_VALUEHL
27e9			 
27e9 e5					push hl   ; save address 
27ea			 
27ea					FORTH_DSP_POP 
27ea cd 57 19			call macro_forth_dsp_pop 
27ed				endm 
# End of macro FORTH_DSP_POP
27ed			 
27ed					FORTH_DSP_VALUEHL 
27ed cd bb 18			call macro_dsp_valuehl 
27f0				endm 
# End of macro FORTH_DSP_VALUEHL
27f0			 
27f0					FORTH_DSP_POP 
27f0 cd 57 19			call macro_forth_dsp_pop 
27f3				endm 
# End of macro FORTH_DSP_POP
27f3			 
27f3					; hl contains value to add to byte at a 
27f3				 
27f3 eb					ex de, hl 
27f4			 
27f4 e1					pop hl 
27f5			 
27f5					if DEBUG_FORTH_WORDS 
27f5						DMARK "INC" 
27f5 f5				push af  
27f6 3a 0a 28			ld a, (.dmark)  
27f9 32 7a ee			ld (debug_mark),a  
27fc 3a 0b 28			ld a, (.dmark+1)  
27ff 32 7b ee			ld (debug_mark+1),a  
2802 3a 0c 28			ld a, (.dmark+2)  
2805 32 7c ee			ld (debug_mark+2),a  
2808 18 03			jr .pastdmark  
280a ..			.dmark: db "INC"  
280d f1			.pastdmark: pop af  
280e			endm  
# End of macro DMARK
280e						CALLMONITOR 
280e cd 86 12			call break_point_state  
2811				endm  
# End of macro CALLMONITOR
2811					endif 
2811			 
2811 7e					ld a,(hl) 
2812 83					add e 
2813 77					ld (hl),a 
2814			 
2814			 
2814			 
2814				       NEXTW 
2814 c3 11 1a			jp macro_next 
2817				endm 
# End of macro NEXTW
2817			 
2817			.DEC: 
2817				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2817 6f				db WORD_SYS_CORE+91             
2818 68 28			dw .INC2            
281a 03				db 2 + 1 
281b .. 00			db "-!",0              
281e				endm 
# End of macro CWHEAD
281e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
281e					if DEBUG_FORTH_WORDS_KEY 
281e						DMARK "-s_" 
281e f5				push af  
281f 3a 33 28			ld a, (.dmark)  
2822 32 7a ee			ld (debug_mark),a  
2825 3a 34 28			ld a, (.dmark+1)  
2828 32 7b ee			ld (debug_mark+1),a  
282b 3a 35 28			ld a, (.dmark+2)  
282e 32 7c ee			ld (debug_mark+2),a  
2831 18 03			jr .pastdmark  
2833 ..			.dmark: db "-s_"  
2836 f1			.pastdmark: pop af  
2837			endm  
# End of macro DMARK
2837						CALLMONITOR 
2837 cd 86 12			call break_point_state  
283a				endm  
# End of macro CALLMONITOR
283a					endif 
283a			 
283a					FORTH_DSP_VALUEHL 
283a cd bb 18			call macro_dsp_valuehl 
283d				endm 
# End of macro FORTH_DSP_VALUEHL
283d			 
283d e5					push hl   ; save address 
283e			 
283e					FORTH_DSP_POP 
283e cd 57 19			call macro_forth_dsp_pop 
2841				endm 
# End of macro FORTH_DSP_POP
2841			 
2841					FORTH_DSP_VALUEHL 
2841 cd bb 18			call macro_dsp_valuehl 
2844				endm 
# End of macro FORTH_DSP_VALUEHL
2844			 
2844					; hl contains value to add to byte at a 
2844				 
2844 eb					ex de, hl 
2845			 
2845 e1					pop hl 
2846			 
2846					if DEBUG_FORTH_WORDS 
2846						DMARK "DEC" 
2846 f5				push af  
2847 3a 5b 28			ld a, (.dmark)  
284a 32 7a ee			ld (debug_mark),a  
284d 3a 5c 28			ld a, (.dmark+1)  
2850 32 7b ee			ld (debug_mark+1),a  
2853 3a 5d 28			ld a, (.dmark+2)  
2856 32 7c ee			ld (debug_mark+2),a  
2859 18 03			jr .pastdmark  
285b ..			.dmark: db "DEC"  
285e f1			.pastdmark: pop af  
285f			endm  
# End of macro DMARK
285f						CALLMONITOR 
285f cd 86 12			call break_point_state  
2862				endm  
# End of macro CALLMONITOR
2862					endif 
2862			 
2862 7e					ld a,(hl) 
2863 93					sub e 
2864 77					ld (hl),a 
2865			 
2865			 
2865			 
2865				       NEXTW 
2865 c3 11 1a			jp macro_next 
2868				endm 
# End of macro NEXTW
2868			 
2868			.INC2: 
2868				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2868 6f				db WORD_SYS_CORE+91             
2869 12 29			dw .DEC2            
286b 04				db 3 + 1 
286c .. 00			db "+2!",0              
2870				endm 
# End of macro CWHEAD
2870			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2870			 
2870					if DEBUG_FORTH_WORDS_KEY 
2870						DMARK "+2s" 
2870 f5				push af  
2871 3a 85 28			ld a, (.dmark)  
2874 32 7a ee			ld (debug_mark),a  
2877 3a 86 28			ld a, (.dmark+1)  
287a 32 7b ee			ld (debug_mark+1),a  
287d 3a 87 28			ld a, (.dmark+2)  
2880 32 7c ee			ld (debug_mark+2),a  
2883 18 03			jr .pastdmark  
2885 ..			.dmark: db "+2s"  
2888 f1			.pastdmark: pop af  
2889			endm  
# End of macro DMARK
2889						CALLMONITOR 
2889 cd 86 12			call break_point_state  
288c				endm  
# End of macro CALLMONITOR
288c					endif 
288c			 
288c					; Address 
288c			 
288c					FORTH_DSP_VALUEHL 
288c cd bb 18			call macro_dsp_valuehl 
288f				endm 
# End of macro FORTH_DSP_VALUEHL
288f			 
288f e5					push hl    ; save address 
2890			 
2890					; load content into de 
2890			 
2890 5e					ld e,(hl) 
2891 23					inc hl 
2892 56					ld d, (hl) 
2893			 
2893					if DEBUG_FORTH_WORDS 
2893						DMARK "+2a" 
2893 f5				push af  
2894 3a a8 28			ld a, (.dmark)  
2897 32 7a ee			ld (debug_mark),a  
289a 3a a9 28			ld a, (.dmark+1)  
289d 32 7b ee			ld (debug_mark+1),a  
28a0 3a aa 28			ld a, (.dmark+2)  
28a3 32 7c ee			ld (debug_mark+2),a  
28a6 18 03			jr .pastdmark  
28a8 ..			.dmark: db "+2a"  
28ab f1			.pastdmark: pop af  
28ac			endm  
# End of macro DMARK
28ac						CALLMONITOR 
28ac cd 86 12			call break_point_state  
28af				endm  
# End of macro CALLMONITOR
28af					endif 
28af			 
28af					FORTH_DSP_POP 
28af cd 57 19			call macro_forth_dsp_pop 
28b2				endm 
# End of macro FORTH_DSP_POP
28b2			 
28b2					; Get value to add 
28b2			 
28b2					FORTH_DSP_VALUE 
28b2 cd a4 18			call macro_forth_dsp_value 
28b5				endm 
# End of macro FORTH_DSP_VALUE
28b5			 
28b5					if DEBUG_FORTH_WORDS 
28b5						DMARK "+2v" 
28b5 f5				push af  
28b6 3a ca 28			ld a, (.dmark)  
28b9 32 7a ee			ld (debug_mark),a  
28bc 3a cb 28			ld a, (.dmark+1)  
28bf 32 7b ee			ld (debug_mark+1),a  
28c2 3a cc 28			ld a, (.dmark+2)  
28c5 32 7c ee			ld (debug_mark+2),a  
28c8 18 03			jr .pastdmark  
28ca ..			.dmark: db "+2v"  
28cd f1			.pastdmark: pop af  
28ce			endm  
# End of macro DMARK
28ce						CALLMONITOR 
28ce cd 86 12			call break_point_state  
28d1				endm  
# End of macro CALLMONITOR
28d1					endif 
28d1			 
28d1 19					add hl, de 
28d2			 
28d2					if DEBUG_FORTH_WORDS 
28d2						DMARK "+2+" 
28d2 f5				push af  
28d3 3a e7 28			ld a, (.dmark)  
28d6 32 7a ee			ld (debug_mark),a  
28d9 3a e8 28			ld a, (.dmark+1)  
28dc 32 7b ee			ld (debug_mark+1),a  
28df 3a e9 28			ld a, (.dmark+2)  
28e2 32 7c ee			ld (debug_mark+2),a  
28e5 18 03			jr .pastdmark  
28e7 ..			.dmark: db "+2+"  
28ea f1			.pastdmark: pop af  
28eb			endm  
# End of macro DMARK
28eb						CALLMONITOR 
28eb cd 86 12			call break_point_state  
28ee				endm  
# End of macro CALLMONITOR
28ee					endif 
28ee			 
28ee					; move result to de 
28ee			 
28ee eb					ex de, hl 
28ef			 
28ef					; Address 
28ef			 
28ef e1					pop hl 
28f0			 
28f0					; save it back 
28f0			 
28f0 73					ld (hl), e 
28f1 23					inc hl 
28f2 72					ld (hl), d 
28f3			 
28f3					if DEBUG_FORTH_WORDS 
28f3						DMARK "+2e" 
28f3 f5				push af  
28f4 3a 08 29			ld a, (.dmark)  
28f7 32 7a ee			ld (debug_mark),a  
28fa 3a 09 29			ld a, (.dmark+1)  
28fd 32 7b ee			ld (debug_mark+1),a  
2900 3a 0a 29			ld a, (.dmark+2)  
2903 32 7c ee			ld (debug_mark+2),a  
2906 18 03			jr .pastdmark  
2908 ..			.dmark: db "+2e"  
290b f1			.pastdmark: pop af  
290c			endm  
# End of macro DMARK
290c						CALLMONITOR 
290c cd 86 12			call break_point_state  
290f				endm  
# End of macro CALLMONITOR
290f					endif 
290f			 
290f			 
290f			 
290f			 
290f			 
290f				       NEXTW 
290f c3 11 1a			jp macro_next 
2912				endm 
# End of macro NEXTW
2912			 
2912			.DEC2: 
2912				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2912 6f				db WORD_SYS_CORE+91             
2913 be 29			dw .GET2            
2915 04				db 3 + 1 
2916 .. 00			db "-2!",0              
291a				endm 
# End of macro CWHEAD
291a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
291a			 
291a			 
291a					if DEBUG_FORTH_WORDS_KEY 
291a						DMARK "-2s" 
291a f5				push af  
291b 3a 2f 29			ld a, (.dmark)  
291e 32 7a ee			ld (debug_mark),a  
2921 3a 30 29			ld a, (.dmark+1)  
2924 32 7b ee			ld (debug_mark+1),a  
2927 3a 31 29			ld a, (.dmark+2)  
292a 32 7c ee			ld (debug_mark+2),a  
292d 18 03			jr .pastdmark  
292f ..			.dmark: db "-2s"  
2932 f1			.pastdmark: pop af  
2933			endm  
# End of macro DMARK
2933						CALLMONITOR 
2933 cd 86 12			call break_point_state  
2936				endm  
# End of macro CALLMONITOR
2936					endif 
2936			 
2936					; Address 
2936			 
2936					FORTH_DSP_VALUEHL 
2936 cd bb 18			call macro_dsp_valuehl 
2939				endm 
# End of macro FORTH_DSP_VALUEHL
2939			 
2939 e5					push hl    ; save address 
293a			 
293a					; load content into de 
293a			 
293a 5e					ld e,(hl) 
293b 23					inc hl 
293c 56					ld d, (hl) 
293d			 
293d					if DEBUG_FORTH_WORDS 
293d						DMARK "-2a" 
293d f5				push af  
293e 3a 52 29			ld a, (.dmark)  
2941 32 7a ee			ld (debug_mark),a  
2944 3a 53 29			ld a, (.dmark+1)  
2947 32 7b ee			ld (debug_mark+1),a  
294a 3a 54 29			ld a, (.dmark+2)  
294d 32 7c ee			ld (debug_mark+2),a  
2950 18 03			jr .pastdmark  
2952 ..			.dmark: db "-2a"  
2955 f1			.pastdmark: pop af  
2956			endm  
# End of macro DMARK
2956						CALLMONITOR 
2956 cd 86 12			call break_point_state  
2959				endm  
# End of macro CALLMONITOR
2959					endif 
2959			 
2959					FORTH_DSP_POP 
2959 cd 57 19			call macro_forth_dsp_pop 
295c				endm 
# End of macro FORTH_DSP_POP
295c			 
295c					; Get value to remove 
295c			 
295c					FORTH_DSP_VALUE 
295c cd a4 18			call macro_forth_dsp_value 
295f				endm 
# End of macro FORTH_DSP_VALUE
295f			 
295f					if DEBUG_FORTH_WORDS 
295f						DMARK "-2v" 
295f f5				push af  
2960 3a 74 29			ld a, (.dmark)  
2963 32 7a ee			ld (debug_mark),a  
2966 3a 75 29			ld a, (.dmark+1)  
2969 32 7b ee			ld (debug_mark+1),a  
296c 3a 76 29			ld a, (.dmark+2)  
296f 32 7c ee			ld (debug_mark+2),a  
2972 18 03			jr .pastdmark  
2974 ..			.dmark: db "-2v"  
2977 f1			.pastdmark: pop af  
2978			endm  
# End of macro DMARK
2978						CALLMONITOR 
2978 cd 86 12			call break_point_state  
297b				endm  
# End of macro CALLMONITOR
297b					endif 
297b			 
297b eb					ex de, hl 
297c ed 52				sbc hl, de 
297e			 
297e					if DEBUG_FORTH_WORDS 
297e						DMARK "-2d" 
297e f5				push af  
297f 3a 93 29			ld a, (.dmark)  
2982 32 7a ee			ld (debug_mark),a  
2985 3a 94 29			ld a, (.dmark+1)  
2988 32 7b ee			ld (debug_mark+1),a  
298b 3a 95 29			ld a, (.dmark+2)  
298e 32 7c ee			ld (debug_mark+2),a  
2991 18 03			jr .pastdmark  
2993 ..			.dmark: db "-2d"  
2996 f1			.pastdmark: pop af  
2997			endm  
# End of macro DMARK
2997						CALLMONITOR 
2997 cd 86 12			call break_point_state  
299a				endm  
# End of macro CALLMONITOR
299a					endif 
299a			 
299a					; move result to de 
299a			 
299a eb					ex de, hl 
299b			 
299b					; Address 
299b			 
299b e1					pop hl 
299c			 
299c					; save it back 
299c			 
299c 73					ld (hl), e 
299d 23					inc hl 
299e 72					ld (hl), d 
299f			 
299f					if DEBUG_FORTH_WORDS 
299f						DMARK "-2e" 
299f f5				push af  
29a0 3a b4 29			ld a, (.dmark)  
29a3 32 7a ee			ld (debug_mark),a  
29a6 3a b5 29			ld a, (.dmark+1)  
29a9 32 7b ee			ld (debug_mark+1),a  
29ac 3a b6 29			ld a, (.dmark+2)  
29af 32 7c ee			ld (debug_mark+2),a  
29b2 18 03			jr .pastdmark  
29b4 ..			.dmark: db "-2e"  
29b7 f1			.pastdmark: pop af  
29b8			endm  
# End of macro DMARK
29b8						CALLMONITOR 
29b8 cd 86 12			call break_point_state  
29bb				endm  
# End of macro CALLMONITOR
29bb					endif 
29bb			 
29bb			 
29bb			 
29bb			 
29bb			 
29bb				       NEXTW 
29bb c3 11 1a			jp macro_next 
29be				endm 
# End of macro NEXTW
29be			.GET2: 
29be				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
29be 6f				db WORD_SYS_CORE+91             
29bf ee 29			dw .BANG2            
29c1 03				db 2 + 1 
29c2 .. 00			db "2@",0              
29c5				endm 
# End of macro CWHEAD
29c5			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
29c5					if DEBUG_FORTH_WORDS_KEY 
29c5						DMARK "2A_" 
29c5 f5				push af  
29c6 3a da 29			ld a, (.dmark)  
29c9 32 7a ee			ld (debug_mark),a  
29cc 3a db 29			ld a, (.dmark+1)  
29cf 32 7b ee			ld (debug_mark+1),a  
29d2 3a dc 29			ld a, (.dmark+2)  
29d5 32 7c ee			ld (debug_mark+2),a  
29d8 18 03			jr .pastdmark  
29da ..			.dmark: db "2A_"  
29dd f1			.pastdmark: pop af  
29de			endm  
# End of macro DMARK
29de						CALLMONITOR 
29de cd 86 12			call break_point_state  
29e1				endm  
# End of macro CALLMONITOR
29e1					endif 
29e1			 
29e1					FORTH_DSP_VALUEHL 
29e1 cd bb 18			call macro_dsp_valuehl 
29e4				endm 
# End of macro FORTH_DSP_VALUEHL
29e4			 
29e4 5e					ld e, (hl) 
29e5 23					inc hl 
29e6 56					ld d, (hl) 
29e7			 
29e7 eb					ex de, hl 
29e8			 
29e8 cd 20 18				call forth_push_numhl 
29eb			 
29eb				       NEXTW 
29eb c3 11 1a			jp macro_next 
29ee				endm 
# End of macro NEXTW
29ee			.BANG2: 
29ee				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
29ee 6f				db WORD_SYS_CORE+91             
29ef 26 2a			dw .ENDCORE            
29f1 03				db 2 + 1 
29f2 .. 00			db "2!",0              
29f5				endm 
# End of macro CWHEAD
29f5			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
29f5					if DEBUG_FORTH_WORDS_KEY 
29f5						DMARK "2S_" 
29f5 f5				push af  
29f6 3a 0a 2a			ld a, (.dmark)  
29f9 32 7a ee			ld (debug_mark),a  
29fc 3a 0b 2a			ld a, (.dmark+1)  
29ff 32 7b ee			ld (debug_mark+1),a  
2a02 3a 0c 2a			ld a, (.dmark+2)  
2a05 32 7c ee			ld (debug_mark+2),a  
2a08 18 03			jr .pastdmark  
2a0a ..			.dmark: db "2S_"  
2a0d f1			.pastdmark: pop af  
2a0e			endm  
# End of macro DMARK
2a0e						CALLMONITOR 
2a0e cd 86 12			call break_point_state  
2a11				endm  
# End of macro CALLMONITOR
2a11					endif 
2a11			 
2a11					FORTH_DSP_VALUEHL 
2a11 cd bb 18			call macro_dsp_valuehl 
2a14				endm 
# End of macro FORTH_DSP_VALUEHL
2a14			 
2a14 e5					push hl   ; save address 
2a15			 
2a15			 
2a15					FORTH_DSP_POP 
2a15 cd 57 19			call macro_forth_dsp_pop 
2a18				endm 
# End of macro FORTH_DSP_POP
2a18			 
2a18					 
2a18					FORTH_DSP_VALUEHL 
2a18 cd bb 18			call macro_dsp_valuehl 
2a1b				endm 
# End of macro FORTH_DSP_VALUEHL
2a1b			 
2a1b					FORTH_DSP_POP 
2a1b cd 57 19			call macro_forth_dsp_pop 
2a1e				endm 
# End of macro FORTH_DSP_POP
2a1e			 
2a1e eb					ex de, hl    ; value now in de 
2a1f			 
2a1f e1					pop hl 
2a20			 
2a20 73					ld (hl), e 
2a21			 
2a21 23					inc hl 
2a22			 
2a22 72					ld (hl), d 
2a23			 
2a23			 
2a23				       NEXTW 
2a23 c3 11 1a			jp macro_next 
2a26				endm 
# End of macro NEXTW
2a26			.ENDCORE: 
2a26			 
2a26			; eof 
2a26			 
2a26			 
# End of file forth_words_core.asm
2a26			include "forth_words_flow.asm" 
2a26			 
2a26			; | ## Program Flow Words 
2a26			 
2a26			.IF: 
2a26				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2a26 1e				db WORD_SYS_CORE+10             
2a27 1b 2b			dw .THEN            
2a29 03				db 2 + 1 
2a2a .. 00			db "IF",0              
2a2d				endm 
# End of macro CWHEAD
2a2d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2a2d			; 
2a2d					if DEBUG_FORTH_WORDS_KEY 
2a2d						DMARK "IF." 
2a2d f5				push af  
2a2e 3a 42 2a			ld a, (.dmark)  
2a31 32 7a ee			ld (debug_mark),a  
2a34 3a 43 2a			ld a, (.dmark+1)  
2a37 32 7b ee			ld (debug_mark+1),a  
2a3a 3a 44 2a			ld a, (.dmark+2)  
2a3d 32 7c ee			ld (debug_mark+2),a  
2a40 18 03			jr .pastdmark  
2a42 ..			.dmark: db "IF."  
2a45 f1			.pastdmark: pop af  
2a46			endm  
# End of macro DMARK
2a46						CALLMONITOR 
2a46 cd 86 12			call break_point_state  
2a49				endm  
# End of macro CALLMONITOR
2a49					endif 
2a49			; eval TOS 
2a49			 
2a49				FORTH_DSP_VALUEHL 
2a49 cd bb 18			call macro_dsp_valuehl 
2a4c				endm 
# End of macro FORTH_DSP_VALUEHL
2a4c			 
2a4c			;	push hl 
2a4c				FORTH_DSP_POP 
2a4c cd 57 19			call macro_forth_dsp_pop 
2a4f				endm 
# End of macro FORTH_DSP_POP
2a4f			;	pop hl 
2a4f			 
2a4f					if DEBUG_FORTH_WORDS 
2a4f						DMARK "IF1" 
2a4f f5				push af  
2a50 3a 64 2a			ld a, (.dmark)  
2a53 32 7a ee			ld (debug_mark),a  
2a56 3a 65 2a			ld a, (.dmark+1)  
2a59 32 7b ee			ld (debug_mark+1),a  
2a5c 3a 66 2a			ld a, (.dmark+2)  
2a5f 32 7c ee			ld (debug_mark+2),a  
2a62 18 03			jr .pastdmark  
2a64 ..			.dmark: db "IF1"  
2a67 f1			.pastdmark: pop af  
2a68			endm  
# End of macro DMARK
2a68						CALLMONITOR 
2a68 cd 86 12			call break_point_state  
2a6b				endm  
# End of macro CALLMONITOR
2a6b					endif 
2a6b b7				or a        ; clear carry flag 
2a6c 11 00 00			ld de, 0 
2a6f eb				ex de,hl 
2a70 ed 52			sbc hl, de 
2a72 c2 fc 2a			jp nz, .iftrue 
2a75			 
2a75					if DEBUG_FORTH_WORDS 
2a75						DMARK "IF2" 
2a75 f5				push af  
2a76 3a 8a 2a			ld a, (.dmark)  
2a79 32 7a ee			ld (debug_mark),a  
2a7c 3a 8b 2a			ld a, (.dmark+1)  
2a7f 32 7b ee			ld (debug_mark+1),a  
2a82 3a 8c 2a			ld a, (.dmark+2)  
2a85 32 7c ee			ld (debug_mark+2),a  
2a88 18 03			jr .pastdmark  
2a8a ..			.dmark: db "IF2"  
2a8d f1			.pastdmark: pop af  
2a8e			endm  
# End of macro DMARK
2a8e						CALLMONITOR 
2a8e cd 86 12			call break_point_state  
2a91				endm  
# End of macro CALLMONITOR
2a91					endif 
2a91			 
2a91			; if not true then skip to THEN 
2a91			 
2a91				; TODO get tok_ptr 
2a91				; TODO consume toks until we get to THEN 
2a91			 
2a91 2a 76 e6			ld hl, (os_tok_ptr) 
2a94					if DEBUG_FORTH_WORDS 
2a94						DMARK "IF3" 
2a94 f5				push af  
2a95 3a a9 2a			ld a, (.dmark)  
2a98 32 7a ee			ld (debug_mark),a  
2a9b 3a aa 2a			ld a, (.dmark+1)  
2a9e 32 7b ee			ld (debug_mark+1),a  
2aa1 3a ab 2a			ld a, (.dmark+2)  
2aa4 32 7c ee			ld (debug_mark+2),a  
2aa7 18 03			jr .pastdmark  
2aa9 ..			.dmark: db "IF3"  
2aac f1			.pastdmark: pop af  
2aad			endm  
# End of macro DMARK
2aad						CALLMONITOR 
2aad cd 86 12			call break_point_state  
2ab0				endm  
# End of macro CALLMONITOR
2ab0						 
2ab0					endif 
2ab0 11 f7 2a			ld de, .ifthen 
2ab3					if DEBUG_FORTH_WORDS 
2ab3						DMARK "IF4" 
2ab3 f5				push af  
2ab4 3a c8 2a			ld a, (.dmark)  
2ab7 32 7a ee			ld (debug_mark),a  
2aba 3a c9 2a			ld a, (.dmark+1)  
2abd 32 7b ee			ld (debug_mark+1),a  
2ac0 3a ca 2a			ld a, (.dmark+2)  
2ac3 32 7c ee			ld (debug_mark+2),a  
2ac6 18 03			jr .pastdmark  
2ac8 ..			.dmark: db "IF4"  
2acb f1			.pastdmark: pop af  
2acc			endm  
# End of macro DMARK
2acc						CALLMONITOR 
2acc cd 86 12			call break_point_state  
2acf				endm  
# End of macro CALLMONITOR
2acf					endif 
2acf cd 2c 1b			call findnexttok  
2ad2			 
2ad2					if DEBUG_FORTH_WORDS 
2ad2						DMARK "IF5" 
2ad2 f5				push af  
2ad3 3a e7 2a			ld a, (.dmark)  
2ad6 32 7a ee			ld (debug_mark),a  
2ad9 3a e8 2a			ld a, (.dmark+1)  
2adc 32 7b ee			ld (debug_mark+1),a  
2adf 3a e9 2a			ld a, (.dmark+2)  
2ae2 32 7c ee			ld (debug_mark+2),a  
2ae5 18 03			jr .pastdmark  
2ae7 ..			.dmark: db "IF5"  
2aea f1			.pastdmark: pop af  
2aeb			endm  
# End of macro DMARK
2aeb						CALLMONITOR 
2aeb cd 86 12			call break_point_state  
2aee				endm  
# End of macro CALLMONITOR
2aee					endif 
2aee				; TODO replace below with ; exec using tok_ptr 
2aee 22 76 e6			ld (os_tok_ptr), hl 
2af1 c3 a2 1a			jp exec1 
2af4				NEXTW 
2af4 c3 11 1a			jp macro_next 
2af7				endm 
# End of macro NEXTW
2af7			 
2af7 .. 00		.ifthen:  db "THEN",0 
2afc			 
2afc			.iftrue:		 
2afc				; Exec next words normally 
2afc			 
2afc				; if true then exec following IF as normal 
2afc					if DEBUG_FORTH_WORDS 
2afc						DMARK "IFT" 
2afc f5				push af  
2afd 3a 11 2b			ld a, (.dmark)  
2b00 32 7a ee			ld (debug_mark),a  
2b03 3a 12 2b			ld a, (.dmark+1)  
2b06 32 7b ee			ld (debug_mark+1),a  
2b09 3a 13 2b			ld a, (.dmark+2)  
2b0c 32 7c ee			ld (debug_mark+2),a  
2b0f 18 03			jr .pastdmark  
2b11 ..			.dmark: db "IFT"  
2b14 f1			.pastdmark: pop af  
2b15			endm  
# End of macro DMARK
2b15						CALLMONITOR 
2b15 cd 86 12			call break_point_state  
2b18				endm  
# End of macro CALLMONITOR
2b18					endif 
2b18			 
2b18					NEXTW 
2b18 c3 11 1a			jp macro_next 
2b1b				endm 
# End of macro NEXTW
2b1b			.THEN: 
2b1b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2b1b 1f				db WORD_SYS_CORE+11             
2b1c 43 2b			dw .ELSE            
2b1e 05				db 4 + 1 
2b1f .. 00			db "THEN",0              
2b24				endm 
# End of macro CWHEAD
2b24			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2b24					if DEBUG_FORTH_WORDS_KEY 
2b24						DMARK "THN" 
2b24 f5				push af  
2b25 3a 39 2b			ld a, (.dmark)  
2b28 32 7a ee			ld (debug_mark),a  
2b2b 3a 3a 2b			ld a, (.dmark+1)  
2b2e 32 7b ee			ld (debug_mark+1),a  
2b31 3a 3b 2b			ld a, (.dmark+2)  
2b34 32 7c ee			ld (debug_mark+2),a  
2b37 18 03			jr .pastdmark  
2b39 ..			.dmark: db "THN"  
2b3c f1			.pastdmark: pop af  
2b3d			endm  
# End of macro DMARK
2b3d						CALLMONITOR 
2b3d cd 86 12			call break_point_state  
2b40				endm  
# End of macro CALLMONITOR
2b40					endif 
2b40					NEXTW 
2b40 c3 11 1a			jp macro_next 
2b43				endm 
# End of macro NEXTW
2b43			.ELSE: 
2b43				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2b43 20				db WORD_SYS_CORE+12             
2b44 6b 2b			dw .DO            
2b46 03				db 2 + 1 
2b47 .. 00			db "ELSE",0              
2b4c				endm 
# End of macro CWHEAD
2b4c			; | ELSE ( -- ) Not supported - does nothing | TODO 
2b4c			 
2b4c					if DEBUG_FORTH_WORDS_KEY 
2b4c						DMARK "ELS" 
2b4c f5				push af  
2b4d 3a 61 2b			ld a, (.dmark)  
2b50 32 7a ee			ld (debug_mark),a  
2b53 3a 62 2b			ld a, (.dmark+1)  
2b56 32 7b ee			ld (debug_mark+1),a  
2b59 3a 63 2b			ld a, (.dmark+2)  
2b5c 32 7c ee			ld (debug_mark+2),a  
2b5f 18 03			jr .pastdmark  
2b61 ..			.dmark: db "ELS"  
2b64 f1			.pastdmark: pop af  
2b65			endm  
# End of macro DMARK
2b65						CALLMONITOR 
2b65 cd 86 12			call break_point_state  
2b68				endm  
# End of macro CALLMONITOR
2b68					endif 
2b68			 
2b68			 
2b68					NEXTW 
2b68 c3 11 1a			jp macro_next 
2b6b				endm 
# End of macro NEXTW
2b6b			.DO: 
2b6b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2b6b 21				db WORD_SYS_CORE+13             
2b6c 92 2c			dw .LOOP            
2b6e 03				db 2 + 1 
2b6f .. 00			db "DO",0              
2b72				endm 
# End of macro CWHEAD
2b72			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2b72			 
2b72					if DEBUG_FORTH_WORDS_KEY 
2b72						DMARK "DO." 
2b72 f5				push af  
2b73 3a 87 2b			ld a, (.dmark)  
2b76 32 7a ee			ld (debug_mark),a  
2b79 3a 88 2b			ld a, (.dmark+1)  
2b7c 32 7b ee			ld (debug_mark+1),a  
2b7f 3a 89 2b			ld a, (.dmark+2)  
2b82 32 7c ee			ld (debug_mark+2),a  
2b85 18 03			jr .pastdmark  
2b87 ..			.dmark: db "DO."  
2b8a f1			.pastdmark: pop af  
2b8b			endm  
# End of macro DMARK
2b8b						CALLMONITOR 
2b8b cd 86 12			call break_point_state  
2b8e				endm  
# End of macro CALLMONITOR
2b8e					endif 
2b8e			;  push pc to rsp stack past the DO 
2b8e			 
2b8e 2a 76 e6				ld hl, (os_tok_ptr) 
2b91 23					inc hl   ; D 
2b92 23					inc hl  ; O 
2b93 23					inc hl   ; null 
2b94					if DEBUG_FORTH_WORDS 
2b94						DMARK "DO2" 
2b94 f5				push af  
2b95 3a a9 2b			ld a, (.dmark)  
2b98 32 7a ee			ld (debug_mark),a  
2b9b 3a aa 2b			ld a, (.dmark+1)  
2b9e 32 7b ee			ld (debug_mark+1),a  
2ba1 3a ab 2b			ld a, (.dmark+2)  
2ba4 32 7c ee			ld (debug_mark+2),a  
2ba7 18 03			jr .pastdmark  
2ba9 ..			.dmark: db "DO2"  
2bac f1			.pastdmark: pop af  
2bad			endm  
# End of macro DMARK
2bad						CALLMONITOR 
2bad cd 86 12			call break_point_state  
2bb0				endm  
# End of macro CALLMONITOR
2bb0					endif 
2bb0					FORTH_RSP_NEXT 
2bb0 cd c7 17			call macro_forth_rsp_next 
2bb3				endm 
# End of macro FORTH_RSP_NEXT
2bb3					if DEBUG_FORTH_WORDS 
2bb3						DMARK "DO3" 
2bb3 f5				push af  
2bb4 3a c8 2b			ld a, (.dmark)  
2bb7 32 7a ee			ld (debug_mark),a  
2bba 3a c9 2b			ld a, (.dmark+1)  
2bbd 32 7b ee			ld (debug_mark+1),a  
2bc0 3a ca 2b			ld a, (.dmark+2)  
2bc3 32 7c ee			ld (debug_mark+2),a  
2bc6 18 03			jr .pastdmark  
2bc8 ..			.dmark: db "DO3"  
2bcb f1			.pastdmark: pop af  
2bcc			endm  
# End of macro DMARK
2bcc						CALLMONITOR 
2bcc cd 86 12			call break_point_state  
2bcf				endm  
# End of macro CALLMONITOR
2bcf					endif 
2bcf			 
2bcf					;if DEBUG_FORTH_WORDS 
2bcf				;		push hl 
2bcf			;		endif  
2bcf			 
2bcf			; get counters from data stack 
2bcf			 
2bcf			 
2bcf					FORTH_DSP_VALUEHL 
2bcf cd bb 18			call macro_dsp_valuehl 
2bd2				endm 
# End of macro FORTH_DSP_VALUEHL
2bd2 e5					push hl		 ; hl now has starting counter which needs to be tos 
2bd3			 
2bd3					if DEBUG_FORTH_WORDS 
2bd3						DMARK "DO4" 
2bd3 f5				push af  
2bd4 3a e8 2b			ld a, (.dmark)  
2bd7 32 7a ee			ld (debug_mark),a  
2bda 3a e9 2b			ld a, (.dmark+1)  
2bdd 32 7b ee			ld (debug_mark+1),a  
2be0 3a ea 2b			ld a, (.dmark+2)  
2be3 32 7c ee			ld (debug_mark+2),a  
2be6 18 03			jr .pastdmark  
2be8 ..			.dmark: db "DO4"  
2beb f1			.pastdmark: pop af  
2bec			endm  
# End of macro DMARK
2bec						CALLMONITOR 
2bec cd 86 12			call break_point_state  
2bef				endm  
# End of macro CALLMONITOR
2bef					endif 
2bef					FORTH_DSP_POP 
2bef cd 57 19			call macro_forth_dsp_pop 
2bf2				endm 
# End of macro FORTH_DSP_POP
2bf2			 
2bf2					if DEBUG_FORTH_WORDS 
2bf2						DMARK "DO5" 
2bf2 f5				push af  
2bf3 3a 07 2c			ld a, (.dmark)  
2bf6 32 7a ee			ld (debug_mark),a  
2bf9 3a 08 2c			ld a, (.dmark+1)  
2bfc 32 7b ee			ld (debug_mark+1),a  
2bff 3a 09 2c			ld a, (.dmark+2)  
2c02 32 7c ee			ld (debug_mark+2),a  
2c05 18 03			jr .pastdmark  
2c07 ..			.dmark: db "DO5"  
2c0a f1			.pastdmark: pop af  
2c0b			endm  
# End of macro DMARK
2c0b						CALLMONITOR 
2c0b cd 86 12			call break_point_state  
2c0e				endm  
# End of macro CALLMONITOR
2c0e					endif 
2c0e			 
2c0e					FORTH_DSP_VALUEHL 
2c0e cd bb 18			call macro_dsp_valuehl 
2c11				endm 
# End of macro FORTH_DSP_VALUEHL
2c11			;		push hl		 ; hl now has starting limit counter 
2c11			 
2c11					if DEBUG_FORTH_WORDS 
2c11						DMARK "DO6" 
2c11 f5				push af  
2c12 3a 26 2c			ld a, (.dmark)  
2c15 32 7a ee			ld (debug_mark),a  
2c18 3a 27 2c			ld a, (.dmark+1)  
2c1b 32 7b ee			ld (debug_mark+1),a  
2c1e 3a 28 2c			ld a, (.dmark+2)  
2c21 32 7c ee			ld (debug_mark+2),a  
2c24 18 03			jr .pastdmark  
2c26 ..			.dmark: db "DO6"  
2c29 f1			.pastdmark: pop af  
2c2a			endm  
# End of macro DMARK
2c2a						CALLMONITOR 
2c2a cd 86 12			call break_point_state  
2c2d				endm  
# End of macro CALLMONITOR
2c2d					endif 
2c2d					FORTH_DSP_POP 
2c2d cd 57 19			call macro_forth_dsp_pop 
2c30				endm 
# End of macro FORTH_DSP_POP
2c30			 
2c30			; put counters on the loop stack 
2c30			 
2c30			;		pop hl			 ; limit counter 
2c30 d1					pop de			; start counter 
2c31			 
2c31					; push limit counter 
2c31			 
2c31					if DEBUG_FORTH_WORDS 
2c31						DMARK "DO7" 
2c31 f5				push af  
2c32 3a 46 2c			ld a, (.dmark)  
2c35 32 7a ee			ld (debug_mark),a  
2c38 3a 47 2c			ld a, (.dmark+1)  
2c3b 32 7b ee			ld (debug_mark+1),a  
2c3e 3a 48 2c			ld a, (.dmark+2)  
2c41 32 7c ee			ld (debug_mark+2),a  
2c44 18 03			jr .pastdmark  
2c46 ..			.dmark: db "DO7"  
2c49 f1			.pastdmark: pop af  
2c4a			endm  
# End of macro DMARK
2c4a						CALLMONITOR 
2c4a cd 86 12			call break_point_state  
2c4d				endm  
# End of macro CALLMONITOR
2c4d					endif 
2c4d					FORTH_LOOP_NEXT 
2c4d cd d0 18			call macro_forth_loop_next 
2c50				endm 
# End of macro FORTH_LOOP_NEXT
2c50			 
2c50					; push start counter 
2c50			 
2c50 eb					ex de, hl 
2c51					if DEBUG_FORTH_WORDS 
2c51						DMARK "DO7" 
2c51 f5				push af  
2c52 3a 66 2c			ld a, (.dmark)  
2c55 32 7a ee			ld (debug_mark),a  
2c58 3a 67 2c			ld a, (.dmark+1)  
2c5b 32 7b ee			ld (debug_mark+1),a  
2c5e 3a 68 2c			ld a, (.dmark+2)  
2c61 32 7c ee			ld (debug_mark+2),a  
2c64 18 03			jr .pastdmark  
2c66 ..			.dmark: db "DO7"  
2c69 f1			.pastdmark: pop af  
2c6a			endm  
# End of macro DMARK
2c6a						CALLMONITOR 
2c6a cd 86 12			call break_point_state  
2c6d				endm  
# End of macro CALLMONITOR
2c6d					endif 
2c6d					FORTH_LOOP_NEXT 
2c6d cd d0 18			call macro_forth_loop_next 
2c70				endm 
# End of macro FORTH_LOOP_NEXT
2c70			 
2c70			 
2c70					; init first round of I counter 
2c70			 
2c70 22 9a e6				ld (os_current_i), hl 
2c73			 
2c73					if DEBUG_FORTH_WORDS 
2c73						DMARK "DO8" 
2c73 f5				push af  
2c74 3a 88 2c			ld a, (.dmark)  
2c77 32 7a ee			ld (debug_mark),a  
2c7a 3a 89 2c			ld a, (.dmark+1)  
2c7d 32 7b ee			ld (debug_mark+1),a  
2c80 3a 8a 2c			ld a, (.dmark+2)  
2c83 32 7c ee			ld (debug_mark+2),a  
2c86 18 03			jr .pastdmark  
2c88 ..			.dmark: db "DO8"  
2c8b f1			.pastdmark: pop af  
2c8c			endm  
# End of macro DMARK
2c8c						CALLMONITOR 
2c8c cd 86 12			call break_point_state  
2c8f				endm  
# End of macro CALLMONITOR
2c8f					endif 
2c8f			 
2c8f					NEXTW 
2c8f c3 11 1a			jp macro_next 
2c92				endm 
# End of macro NEXTW
2c92			.LOOP: 
2c92				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2c92 22				db WORD_SYS_CORE+14             
2c93 aa 2d			dw .I            
2c95 05				db 4 + 1 
2c96 .. 00			db "LOOP",0              
2c9b				endm 
# End of macro CWHEAD
2c9b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2c9b			 
2c9b				; pop tos as current loop count to hl 
2c9b			 
2c9b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2c9b			 
2c9b				FORTH_LOOP_TOS 
2c9b cd 03 19			call macro_forth_loop_tos 
2c9e				endm 
# End of macro FORTH_LOOP_TOS
2c9e e5				push hl 
2c9f			 
2c9f					if DEBUG_FORTH_WORDS_KEY 
2c9f						DMARK "LOP" 
2c9f f5				push af  
2ca0 3a b4 2c			ld a, (.dmark)  
2ca3 32 7a ee			ld (debug_mark),a  
2ca6 3a b5 2c			ld a, (.dmark+1)  
2ca9 32 7b ee			ld (debug_mark+1),a  
2cac 3a b6 2c			ld a, (.dmark+2)  
2caf 32 7c ee			ld (debug_mark+2),a  
2cb2 18 03			jr .pastdmark  
2cb4 ..			.dmark: db "LOP"  
2cb7 f1			.pastdmark: pop af  
2cb8			endm  
# End of macro DMARK
2cb8						CALLMONITOR 
2cb8 cd 86 12			call break_point_state  
2cbb				endm  
# End of macro CALLMONITOR
2cbb					endif 
2cbb				; next item on the stack is the limit. get it 
2cbb			 
2cbb			 
2cbb				FORTH_LOOP_POP 
2cbb cd 0d 19			call macro_forth_loop_pop 
2cbe				endm 
# End of macro FORTH_LOOP_POP
2cbe			 
2cbe				FORTH_LOOP_TOS 
2cbe cd 03 19			call macro_forth_loop_tos 
2cc1				endm 
# End of macro FORTH_LOOP_TOS
2cc1			 
2cc1 d1				pop de		 ; de = i, hl = limit 
2cc2			 
2cc2					if DEBUG_FORTH_WORDS 
2cc2						DMARK "LP1" 
2cc2 f5				push af  
2cc3 3a d7 2c			ld a, (.dmark)  
2cc6 32 7a ee			ld (debug_mark),a  
2cc9 3a d8 2c			ld a, (.dmark+1)  
2ccc 32 7b ee			ld (debug_mark+1),a  
2ccf 3a d9 2c			ld a, (.dmark+2)  
2cd2 32 7c ee			ld (debug_mark+2),a  
2cd5 18 03			jr .pastdmark  
2cd7 ..			.dmark: db "LP1"  
2cda f1			.pastdmark: pop af  
2cdb			endm  
# End of macro DMARK
2cdb						CALLMONITOR 
2cdb cd 86 12			call break_point_state  
2cde				endm  
# End of macro CALLMONITOR
2cde					endif 
2cde			 
2cde				; go back to previous word 
2cde			 
2cde d5				push de    ; save I for inc later 
2cdf			 
2cdf			 
2cdf				; get limit 
2cdf				;  is I at limit? 
2cdf			 
2cdf			 
2cdf					if DEBUG_FORTH_WORDS 
2cdf						DMARK "LP1" 
2cdf f5				push af  
2ce0 3a f4 2c			ld a, (.dmark)  
2ce3 32 7a ee			ld (debug_mark),a  
2ce6 3a f5 2c			ld a, (.dmark+1)  
2ce9 32 7b ee			ld (debug_mark+1),a  
2cec 3a f6 2c			ld a, (.dmark+2)  
2cef 32 7c ee			ld (debug_mark+2),a  
2cf2 18 03			jr .pastdmark  
2cf4 ..			.dmark: db "LP1"  
2cf7 f1			.pastdmark: pop af  
2cf8			endm  
# End of macro DMARK
2cf8						CALLMONITOR 
2cf8 cd 86 12			call break_point_state  
2cfb				endm  
# End of macro CALLMONITOR
2cfb					endif 
2cfb			 
2cfb ed 52			sbc hl, de 
2cfd			 
2cfd			 
2cfd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2cfd			 
2cfd 20 26				jr nz, .loopnotdone 
2cff			 
2cff e1				pop hl   ; get rid of saved I 
2d00				FORTH_LOOP_POP     ; get rid of limit 
2d00 cd 0d 19			call macro_forth_loop_pop 
2d03				endm 
# End of macro FORTH_LOOP_POP
2d03			 
2d03				FORTH_RSP_POP     ; get rid of DO ptr 
2d03 cd e8 17			call macro_forth_rsp_pop 
2d06				endm 
# End of macro FORTH_RSP_POP
2d06			 
2d06			if DEBUG_FORTH_WORDS 
2d06						DMARK "LP>" 
2d06 f5				push af  
2d07 3a 1b 2d			ld a, (.dmark)  
2d0a 32 7a ee			ld (debug_mark),a  
2d0d 3a 1c 2d			ld a, (.dmark+1)  
2d10 32 7b ee			ld (debug_mark+1),a  
2d13 3a 1d 2d			ld a, (.dmark+2)  
2d16 32 7c ee			ld (debug_mark+2),a  
2d19 18 03			jr .pastdmark  
2d1b ..			.dmark: db "LP>"  
2d1e f1			.pastdmark: pop af  
2d1f			endm  
# End of macro DMARK
2d1f				CALLMONITOR 
2d1f cd 86 12			call break_point_state  
2d22				endm  
# End of macro CALLMONITOR
2d22			endif 
2d22			 
2d22					NEXTW 
2d22 c3 11 1a			jp macro_next 
2d25				endm 
# End of macro NEXTW
2d25				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2d25			 
2d25			.loopnotdone: 
2d25			 
2d25 e1				pop hl    ; get I 
2d26 23				inc hl 
2d27			 
2d27			   	; save new I 
2d27			 
2d27			 
2d27					; set I counter 
2d27			 
2d27 22 9a e6				ld (os_current_i), hl 
2d2a			 
2d2a					if DEBUG_FORTH_WORDS 
2d2a						DMARK "LPN" 
2d2a f5				push af  
2d2b 3a 3f 2d			ld a, (.dmark)  
2d2e 32 7a ee			ld (debug_mark),a  
2d31 3a 40 2d			ld a, (.dmark+1)  
2d34 32 7b ee			ld (debug_mark+1),a  
2d37 3a 41 2d			ld a, (.dmark+2)  
2d3a 32 7c ee			ld (debug_mark+2),a  
2d3d 18 03			jr .pastdmark  
2d3f ..			.dmark: db "LPN"  
2d42 f1			.pastdmark: pop af  
2d43			endm  
# End of macro DMARK
2d43					CALLMONITOR 
2d43 cd 86 12			call break_point_state  
2d46				endm  
# End of macro CALLMONITOR
2d46					endif 
2d46					 
2d46				FORTH_LOOP_NEXT 
2d46 cd d0 18			call macro_forth_loop_next 
2d49				endm 
# End of macro FORTH_LOOP_NEXT
2d49			 
2d49			 
2d49					if DEBUG_FORTH_WORDS 
2d49 eb						ex de,hl 
2d4a					endif 
2d4a			 
2d4a			;	; get DO ptr 
2d4a			; 
2d4a					if DEBUG_FORTH_WORDS 
2d4a						DMARK "LP7" 
2d4a f5				push af  
2d4b 3a 5f 2d			ld a, (.dmark)  
2d4e 32 7a ee			ld (debug_mark),a  
2d51 3a 60 2d			ld a, (.dmark+1)  
2d54 32 7b ee			ld (debug_mark+1),a  
2d57 3a 61 2d			ld a, (.dmark+2)  
2d5a 32 7c ee			ld (debug_mark+2),a  
2d5d 18 03			jr .pastdmark  
2d5f ..			.dmark: db "LP7"  
2d62 f1			.pastdmark: pop af  
2d63			endm  
# End of macro DMARK
2d63					CALLMONITOR 
2d63 cd 86 12			call break_point_state  
2d66				endm  
# End of macro CALLMONITOR
2d66					endif 
2d66				FORTH_RSP_TOS 
2d66 cd de 17			call macro_forth_rsp_tos 
2d69				endm 
# End of macro FORTH_RSP_TOS
2d69			 
2d69					if DEBUG_FORTH_WORDS 
2d69						DMARK "LP8" 
2d69 f5				push af  
2d6a 3a 7e 2d			ld a, (.dmark)  
2d6d 32 7a ee			ld (debug_mark),a  
2d70 3a 7f 2d			ld a, (.dmark+1)  
2d73 32 7b ee			ld (debug_mark+1),a  
2d76 3a 80 2d			ld a, (.dmark+2)  
2d79 32 7c ee			ld (debug_mark+2),a  
2d7c 18 03			jr .pastdmark  
2d7e ..			.dmark: db "LP8"  
2d81 f1			.pastdmark: pop af  
2d82			endm  
# End of macro DMARK
2d82					CALLMONITOR 
2d82 cd 86 12			call break_point_state  
2d85				endm  
# End of macro CALLMONITOR
2d85					endif 
2d85				;push hl 
2d85			 
2d85				; not going to DO any more 
2d85				; get rid of the RSP pointer as DO will add it back in 
2d85				;FORTH_RSP_POP 
2d85				;pop hl 
2d85			 
2d85				;ld hl,(cli_ret_sp) 
2d85				;ld e, (hl) 
2d85				;inc hl 
2d85				;ld d, (hl) 
2d85				;ex de,hl 
2d85 22 76 e6			ld (os_tok_ptr), hl 
2d88					if DEBUG_FORTH_WORDS 
2d88						DMARK "LP<" 
2d88 f5				push af  
2d89 3a 9d 2d			ld a, (.dmark)  
2d8c 32 7a ee			ld (debug_mark),a  
2d8f 3a 9e 2d			ld a, (.dmark+1)  
2d92 32 7b ee			ld (debug_mark+1),a  
2d95 3a 9f 2d			ld a, (.dmark+2)  
2d98 32 7c ee			ld (debug_mark+2),a  
2d9b 18 03			jr .pastdmark  
2d9d ..			.dmark: db "LP<"  
2da0 f1			.pastdmark: pop af  
2da1			endm  
# End of macro DMARK
2da1					CALLMONITOR 
2da1 cd 86 12			call break_point_state  
2da4				endm  
# End of macro CALLMONITOR
2da4				endif 
2da4 c3 a2 1a			jp exec1 
2da7			 
2da7					 
2da7			 
2da7			 
2da7					NEXTW 
2da7 c3 11 1a			jp macro_next 
2daa				endm 
# End of macro NEXTW
2daa			.I:  
2daa			 
2daa				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2daa 5e				db WORD_SYS_CORE+74             
2dab d5 2d			dw .DLOOP            
2dad 02				db 1 + 1 
2dae .. 00			db "I",0              
2db0				endm 
# End of macro CWHEAD
2db0			; | I ( -- ) Current loop counter | DONE 
2db0					if DEBUG_FORTH_WORDS_KEY 
2db0						DMARK "I.." 
2db0 f5				push af  
2db1 3a c5 2d			ld a, (.dmark)  
2db4 32 7a ee			ld (debug_mark),a  
2db7 3a c6 2d			ld a, (.dmark+1)  
2dba 32 7b ee			ld (debug_mark+1),a  
2dbd 3a c7 2d			ld a, (.dmark+2)  
2dc0 32 7c ee			ld (debug_mark+2),a  
2dc3 18 03			jr .pastdmark  
2dc5 ..			.dmark: db "I.."  
2dc8 f1			.pastdmark: pop af  
2dc9			endm  
# End of macro DMARK
2dc9						CALLMONITOR 
2dc9 cd 86 12			call break_point_state  
2dcc				endm  
# End of macro CALLMONITOR
2dcc					endif 
2dcc			 
2dcc 2a 9a e6				ld hl,(os_current_i) 
2dcf cd 20 18				call forth_push_numhl 
2dd2			 
2dd2					NEXTW 
2dd2 c3 11 1a			jp macro_next 
2dd5				endm 
# End of macro NEXTW
2dd5			.DLOOP: 
2dd5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2dd5 5f				db WORD_SYS_CORE+75             
2dd6 b6 2e			dw .REPEAT            
2dd8 06				db 5 + 1 
2dd9 .. 00			db "-LOOP",0              
2ddf				endm 
# End of macro CWHEAD
2ddf			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2ddf				; pop tos as current loop count to hl 
2ddf					if DEBUG_FORTH_WORDS_KEY 
2ddf						DMARK "-LP" 
2ddf f5				push af  
2de0 3a f4 2d			ld a, (.dmark)  
2de3 32 7a ee			ld (debug_mark),a  
2de6 3a f5 2d			ld a, (.dmark+1)  
2de9 32 7b ee			ld (debug_mark+1),a  
2dec 3a f6 2d			ld a, (.dmark+2)  
2def 32 7c ee			ld (debug_mark+2),a  
2df2 18 03			jr .pastdmark  
2df4 ..			.dmark: db "-LP"  
2df7 f1			.pastdmark: pop af  
2df8			endm  
# End of macro DMARK
2df8						CALLMONITOR 
2df8 cd 86 12			call break_point_state  
2dfb				endm  
# End of macro CALLMONITOR
2dfb					endif 
2dfb			 
2dfb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2dfb			 
2dfb				FORTH_LOOP_TOS 
2dfb cd 03 19			call macro_forth_loop_tos 
2dfe				endm 
# End of macro FORTH_LOOP_TOS
2dfe e5				push hl 
2dff			 
2dff					if DEBUG_FORTH_WORDS 
2dff						DMARK "-LP" 
2dff f5				push af  
2e00 3a 14 2e			ld a, (.dmark)  
2e03 32 7a ee			ld (debug_mark),a  
2e06 3a 15 2e			ld a, (.dmark+1)  
2e09 32 7b ee			ld (debug_mark+1),a  
2e0c 3a 16 2e			ld a, (.dmark+2)  
2e0f 32 7c ee			ld (debug_mark+2),a  
2e12 18 03			jr .pastdmark  
2e14 ..			.dmark: db "-LP"  
2e17 f1			.pastdmark: pop af  
2e18			endm  
# End of macro DMARK
2e18						CALLMONITOR 
2e18 cd 86 12			call break_point_state  
2e1b				endm  
# End of macro CALLMONITOR
2e1b					endif 
2e1b				; next item on the stack is the limit. get it 
2e1b			 
2e1b			 
2e1b				FORTH_LOOP_POP 
2e1b cd 0d 19			call macro_forth_loop_pop 
2e1e				endm 
# End of macro FORTH_LOOP_POP
2e1e			 
2e1e				FORTH_LOOP_TOS 
2e1e cd 03 19			call macro_forth_loop_tos 
2e21				endm 
# End of macro FORTH_LOOP_TOS
2e21			 
2e21 d1				pop de		 ; de = i, hl = limit 
2e22			 
2e22					if DEBUG_FORTH_WORDS 
2e22						DMARK "-L1" 
2e22 f5				push af  
2e23 3a 37 2e			ld a, (.dmark)  
2e26 32 7a ee			ld (debug_mark),a  
2e29 3a 38 2e			ld a, (.dmark+1)  
2e2c 32 7b ee			ld (debug_mark+1),a  
2e2f 3a 39 2e			ld a, (.dmark+2)  
2e32 32 7c ee			ld (debug_mark+2),a  
2e35 18 03			jr .pastdmark  
2e37 ..			.dmark: db "-L1"  
2e3a f1			.pastdmark: pop af  
2e3b			endm  
# End of macro DMARK
2e3b						CALLMONITOR 
2e3b cd 86 12			call break_point_state  
2e3e				endm  
# End of macro CALLMONITOR
2e3e					endif 
2e3e			 
2e3e				; go back to previous word 
2e3e			 
2e3e d5				push de    ; save I for inc later 
2e3f			 
2e3f			 
2e3f				; get limit 
2e3f				;  is I at limit? 
2e3f			 
2e3f			 
2e3f					if DEBUG_FORTH_WORDS 
2e3f						DMARK "-L1" 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 7a ee			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 7b ee			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 7c ee			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db "-L1"  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58						CALLMONITOR 
2e58 cd 86 12			call break_point_state  
2e5b				endm  
# End of macro CALLMONITOR
2e5b					endif 
2e5b			 
2e5b ed 52			sbc hl, de 
2e5d			 
2e5d			 
2e5d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e5d			 
2e5d 20 26				jr nz, .mloopnotdone 
2e5f			 
2e5f e1				pop hl   ; get rid of saved I 
2e60				FORTH_LOOP_POP     ; get rid of limit 
2e60 cd 0d 19			call macro_forth_loop_pop 
2e63				endm 
# End of macro FORTH_LOOP_POP
2e63			 
2e63				FORTH_RSP_POP     ; get rid of DO ptr 
2e63 cd e8 17			call macro_forth_rsp_pop 
2e66				endm 
# End of macro FORTH_RSP_POP
2e66			 
2e66			if DEBUG_FORTH_WORDS 
2e66						DMARK "-L>" 
2e66 f5				push af  
2e67 3a 7b 2e			ld a, (.dmark)  
2e6a 32 7a ee			ld (debug_mark),a  
2e6d 3a 7c 2e			ld a, (.dmark+1)  
2e70 32 7b ee			ld (debug_mark+1),a  
2e73 3a 7d 2e			ld a, (.dmark+2)  
2e76 32 7c ee			ld (debug_mark+2),a  
2e79 18 03			jr .pastdmark  
2e7b ..			.dmark: db "-L>"  
2e7e f1			.pastdmark: pop af  
2e7f			endm  
# End of macro DMARK
2e7f				CALLMONITOR 
2e7f cd 86 12			call break_point_state  
2e82				endm  
# End of macro CALLMONITOR
2e82			endif 
2e82			 
2e82					NEXTW 
2e82 c3 11 1a			jp macro_next 
2e85				endm 
# End of macro NEXTW
2e85				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e85			 
2e85			.mloopnotdone: 
2e85			 
2e85 e1				pop hl    ; get I 
2e86 2b				dec hl 
2e87			 
2e87			   	; save new I 
2e87			 
2e87			 
2e87					; set I counter 
2e87			 
2e87 22 9a e6				ld (os_current_i), hl 
2e8a			 
2e8a					 
2e8a				FORTH_LOOP_NEXT 
2e8a cd d0 18			call macro_forth_loop_next 
2e8d				endm 
# End of macro FORTH_LOOP_NEXT
2e8d			 
2e8d			 
2e8d					if DEBUG_FORTH_WORDS 
2e8d eb						ex de,hl 
2e8e					endif 
2e8e			 
2e8e			;	; get DO ptr 
2e8e			; 
2e8e				FORTH_RSP_TOS 
2e8e cd de 17			call macro_forth_rsp_tos 
2e91				endm 
# End of macro FORTH_RSP_TOS
2e91			 
2e91				;push hl 
2e91			 
2e91				; not going to DO any more 
2e91				; get rid of the RSP pointer as DO will add it back in 
2e91				;FORTH_RSP_POP 
2e91				;pop hl 
2e91			 
2e91			 
2e91 22 76 e6			ld (os_tok_ptr), hl 
2e94					if DEBUG_FORTH_WORDS 
2e94						DMARK "-L<" 
2e94 f5				push af  
2e95 3a a9 2e			ld a, (.dmark)  
2e98 32 7a ee			ld (debug_mark),a  
2e9b 3a aa 2e			ld a, (.dmark+1)  
2e9e 32 7b ee			ld (debug_mark+1),a  
2ea1 3a ab 2e			ld a, (.dmark+2)  
2ea4 32 7c ee			ld (debug_mark+2),a  
2ea7 18 03			jr .pastdmark  
2ea9 ..			.dmark: db "-L<"  
2eac f1			.pastdmark: pop af  
2ead			endm  
# End of macro DMARK
2ead					CALLMONITOR 
2ead cd 86 12			call break_point_state  
2eb0				endm  
# End of macro CALLMONITOR
2eb0				endif 
2eb0 c3 a2 1a			jp exec1 
2eb3			 
2eb3					 
2eb3			 
2eb3			 
2eb3			 
2eb3				NEXTW 
2eb3 c3 11 1a			jp macro_next 
2eb6				endm 
# End of macro NEXTW
2eb6			 
2eb6			 
2eb6			 
2eb6			 
2eb6			.REPEAT: 
2eb6				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
2eb6 71				db WORD_SYS_CORE+93             
2eb7 09 2f			dw .UNTIL            
2eb9 06				db 5 + 1 
2eba .. 00			db "REPEAT",0              
2ec1				endm 
# End of macro CWHEAD
2ec1			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
2ec1			;  push pc to rsp stack past the REPEAT 
2ec1					if DEBUG_FORTH_WORDS_KEY 
2ec1						DMARK "REP" 
2ec1 f5				push af  
2ec2 3a d6 2e			ld a, (.dmark)  
2ec5 32 7a ee			ld (debug_mark),a  
2ec8 3a d7 2e			ld a, (.dmark+1)  
2ecb 32 7b ee			ld (debug_mark+1),a  
2ece 3a d8 2e			ld a, (.dmark+2)  
2ed1 32 7c ee			ld (debug_mark+2),a  
2ed4 18 03			jr .pastdmark  
2ed6 ..			.dmark: db "REP"  
2ed9 f1			.pastdmark: pop af  
2eda			endm  
# End of macro DMARK
2eda						CALLMONITOR 
2eda cd 86 12			call break_point_state  
2edd				endm  
# End of macro CALLMONITOR
2edd					endif 
2edd			 
2edd 2a 76 e6				ld hl, (os_tok_ptr) 
2ee0 23					inc hl   ; R 
2ee1 23					inc hl  ; E 
2ee2 23					inc hl   ; P 
2ee3 23					inc hl   ; E 
2ee4 23					inc hl   ; A 
2ee5 23					inc hl   ; T 
2ee6 23					inc hl   ; zero 
2ee7					FORTH_RSP_NEXT 
2ee7 cd c7 17			call macro_forth_rsp_next 
2eea				endm 
# End of macro FORTH_RSP_NEXT
2eea			 
2eea			 
2eea					if DEBUG_FORTH_WORDS 
2eea						DMARK "REP" 
2eea f5				push af  
2eeb 3a ff 2e			ld a, (.dmark)  
2eee 32 7a ee			ld (debug_mark),a  
2ef1 3a 00 2f			ld a, (.dmark+1)  
2ef4 32 7b ee			ld (debug_mark+1),a  
2ef7 3a 01 2f			ld a, (.dmark+2)  
2efa 32 7c ee			ld (debug_mark+2),a  
2efd 18 03			jr .pastdmark  
2eff ..			.dmark: db "REP"  
2f02 f1			.pastdmark: pop af  
2f03			endm  
# End of macro DMARK
2f03						;pop bc    ; TODO BUG ?????? what is this for???? 
2f03						CALLMONITOR 
2f03 cd 86 12			call break_point_state  
2f06				endm  
# End of macro CALLMONITOR
2f06					endif 
2f06			 
2f06					NEXTW 
2f06 c3 11 1a			jp macro_next 
2f09				endm 
# End of macro NEXTW
2f09			;	       NEXTW 
2f09			 
2f09			.UNTIL: 
2f09				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
2f09 72				db WORD_SYS_CORE+94             
2f0a a0 2f			dw .ENDFLOW            
2f0c 06				db 5 + 1 
2f0d .. 00			db "UNTIL",0              
2f13				endm 
# End of macro CWHEAD
2f13			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
2f13			 
2f13				; pop tos as check 
2f13			 
2f13				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f13			 
2f13				FORTH_DSP_VALUEHL 
2f13 cd bb 18			call macro_dsp_valuehl 
2f16				endm 
# End of macro FORTH_DSP_VALUEHL
2f16			 
2f16					if DEBUG_FORTH_WORDS_KEY 
2f16						DMARK "UNT" 
2f16 f5				push af  
2f17 3a 2b 2f			ld a, (.dmark)  
2f1a 32 7a ee			ld (debug_mark),a  
2f1d 3a 2c 2f			ld a, (.dmark+1)  
2f20 32 7b ee			ld (debug_mark+1),a  
2f23 3a 2d 2f			ld a, (.dmark+2)  
2f26 32 7c ee			ld (debug_mark+2),a  
2f29 18 03			jr .pastdmark  
2f2b ..			.dmark: db "UNT"  
2f2e f1			.pastdmark: pop af  
2f2f			endm  
# End of macro DMARK
2f2f						CALLMONITOR 
2f2f cd 86 12			call break_point_state  
2f32				endm  
# End of macro CALLMONITOR
2f32					endif 
2f32			 
2f32			;	push hl 
2f32				FORTH_DSP_POP 
2f32 cd 57 19			call macro_forth_dsp_pop 
2f35				endm 
# End of macro FORTH_DSP_POP
2f35			 
2f35			;	pop hl 
2f35			 
2f35				; test if true 
2f35			 
2f35 cd eb 0a			call ishlzero 
2f38			;	ld a,l 
2f38			;	add h 
2f38			; 
2f38			;	cp 0 
2f38			 
2f38 20 3e			jr nz, .untilnotdone 
2f3a			 
2f3a					if DEBUG_FORTH_WORDS 
2f3a						DMARK "UNf" 
2f3a f5				push af  
2f3b 3a 4f 2f			ld a, (.dmark)  
2f3e 32 7a ee			ld (debug_mark),a  
2f41 3a 50 2f			ld a, (.dmark+1)  
2f44 32 7b ee			ld (debug_mark+1),a  
2f47 3a 51 2f			ld a, (.dmark+2)  
2f4a 32 7c ee			ld (debug_mark+2),a  
2f4d 18 03			jr .pastdmark  
2f4f ..			.dmark: db "UNf"  
2f52 f1			.pastdmark: pop af  
2f53			endm  
# End of macro DMARK
2f53						CALLMONITOR 
2f53 cd 86 12			call break_point_state  
2f56				endm  
# End of macro CALLMONITOR
2f56					endif 
2f56			 
2f56			 
2f56			 
2f56				FORTH_RSP_POP     ; get rid of DO ptr 
2f56 cd e8 17			call macro_forth_rsp_pop 
2f59				endm 
# End of macro FORTH_RSP_POP
2f59			 
2f59			if DEBUG_FORTH_WORDS 
2f59						DMARK "UN>" 
2f59 f5				push af  
2f5a 3a 6e 2f			ld a, (.dmark)  
2f5d 32 7a ee			ld (debug_mark),a  
2f60 3a 6f 2f			ld a, (.dmark+1)  
2f63 32 7b ee			ld (debug_mark+1),a  
2f66 3a 70 2f			ld a, (.dmark+2)  
2f69 32 7c ee			ld (debug_mark+2),a  
2f6c 18 03			jr .pastdmark  
2f6e ..			.dmark: db "UN>"  
2f71 f1			.pastdmark: pop af  
2f72			endm  
# End of macro DMARK
2f72				CALLMONITOR 
2f72 cd 86 12			call break_point_state  
2f75				endm  
# End of macro CALLMONITOR
2f75			endif 
2f75			 
2f75					NEXTW 
2f75 c3 11 1a			jp macro_next 
2f78				endm 
# End of macro NEXTW
2f78				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f78			 
2f78			.untilnotdone: 
2f78			 
2f78			 
2f78			;	; get DO ptr 
2f78			; 
2f78				FORTH_RSP_TOS 
2f78 cd de 17			call macro_forth_rsp_tos 
2f7b				endm 
# End of macro FORTH_RSP_TOS
2f7b			 
2f7b				;push hl 
2f7b			 
2f7b				; not going to DO any more 
2f7b				; get rid of the RSP pointer as DO will add it back in 
2f7b				;FORTH_RSP_POP 
2f7b				;pop hl 
2f7b			 
2f7b			 
2f7b 22 76 e6			ld (os_tok_ptr), hl 
2f7e					if DEBUG_FORTH_WORDS 
2f7e						DMARK "UN<" 
2f7e f5				push af  
2f7f 3a 93 2f			ld a, (.dmark)  
2f82 32 7a ee			ld (debug_mark),a  
2f85 3a 94 2f			ld a, (.dmark+1)  
2f88 32 7b ee			ld (debug_mark+1),a  
2f8b 3a 95 2f			ld a, (.dmark+2)  
2f8e 32 7c ee			ld (debug_mark+2),a  
2f91 18 03			jr .pastdmark  
2f93 ..			.dmark: db "UN<"  
2f96 f1			.pastdmark: pop af  
2f97			endm  
# End of macro DMARK
2f97					CALLMONITOR 
2f97 cd 86 12			call break_point_state  
2f9a				endm  
# End of macro CALLMONITOR
2f9a				endif 
2f9a c3 a2 1a			jp exec1 
2f9d			 
2f9d					 
2f9d			 
2f9d			 
2f9d					NEXTW 
2f9d c3 11 1a			jp macro_next 
2fa0				endm 
# End of macro NEXTW
2fa0			 
2fa0			 
2fa0			.ENDFLOW: 
2fa0			 
2fa0			; eof 
2fa0			 
# End of file forth_words_flow.asm
2fa0			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
2fa0			include "forth_words_logic.asm" 
2fa0			 
2fa0			; | ## Logic Words 
2fa0			 
2fa0			.NOT: 
2fa0				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
2fa0 2d				db WORD_SYS_CORE+25             
2fa1 e8 2f			dw .IS            
2fa3 04				db 3 + 1 
2fa4 .. 00			db "NOT",0              
2fa8				endm 
# End of macro CWHEAD
2fa8			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
2fa8					if DEBUG_FORTH_WORDS_KEY 
2fa8						DMARK "NOT" 
2fa8 f5				push af  
2fa9 3a bd 2f			ld a, (.dmark)  
2fac 32 7a ee			ld (debug_mark),a  
2faf 3a be 2f			ld a, (.dmark+1)  
2fb2 32 7b ee			ld (debug_mark+1),a  
2fb5 3a bf 2f			ld a, (.dmark+2)  
2fb8 32 7c ee			ld (debug_mark+2),a  
2fbb 18 03			jr .pastdmark  
2fbd ..			.dmark: db "NOT"  
2fc0 f1			.pastdmark: pop af  
2fc1			endm  
# End of macro DMARK
2fc1						CALLMONITOR 
2fc1 cd 86 12			call break_point_state  
2fc4				endm  
# End of macro CALLMONITOR
2fc4					endif 
2fc4					FORTH_DSP 
2fc4 cd a0 18			call macro_forth_dsp 
2fc7				endm 
# End of macro FORTH_DSP
2fc7 7e					ld a,(hl)	; get type of value on TOS 
2fc8 fe 02				cp DS_TYPE_INUM  
2fca 28 03				jr z, .noti 
2fcc					NEXTW 
2fcc c3 11 1a			jp macro_next 
2fcf				endm 
# End of macro NEXTW
2fcf			.noti:          FORTH_DSP_VALUEHL 
2fcf cd bb 18			call macro_dsp_valuehl 
2fd2				endm 
# End of macro FORTH_DSP_VALUEHL
2fd2			;		push hl 
2fd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fd2 cd 57 19			call macro_forth_dsp_pop 
2fd5				endm 
# End of macro FORTH_DSP_POP
2fd5			;		pop hl 
2fd5 3e 00				ld a,0 
2fd7 bd					cp l 
2fd8 28 04				jr z, .not2t 
2fda 2e 00				ld l, 0 
2fdc 18 02				jr .notip 
2fde			 
2fde 2e ff		.not2t:		ld l, 255 
2fe0			 
2fe0 26 00		.notip:		ld h, 0	 
2fe2			 
2fe2 cd 20 18				call forth_push_numhl 
2fe5					NEXTW 
2fe5 c3 11 1a			jp macro_next 
2fe8				endm 
# End of macro NEXTW
2fe8			 
2fe8			.IS: 
2fe8				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
2fe8 2d				db WORD_SYS_CORE+25             
2fe9 0e 30			dw .LZERO            
2feb 03				db 2 + 1 
2fec .. 00			db "IS",0              
2fef				endm 
# End of macro CWHEAD
2fef			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
2fef					if DEBUG_FORTH_WORDS_KEY 
2fef						DMARK "IS." 
2fef f5				push af  
2ff0 3a 04 30			ld a, (.dmark)  
2ff3 32 7a ee			ld (debug_mark),a  
2ff6 3a 05 30			ld a, (.dmark+1)  
2ff9 32 7b ee			ld (debug_mark+1),a  
2ffc 3a 06 30			ld a, (.dmark+2)  
2fff 32 7c ee			ld (debug_mark+2),a  
3002 18 03			jr .pastdmark  
3004 ..			.dmark: db "IS."  
3007 f1			.pastdmark: pop af  
3008			endm  
# End of macro DMARK
3008						CALLMONITOR 
3008 cd 86 12			call break_point_state  
300b				endm  
# End of macro CALLMONITOR
300b					endif 
300b					NEXTW 
300b c3 11 1a			jp macro_next 
300e				endm 
# End of macro NEXTW
300e			.LZERO: 
300e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
300e 2d				db WORD_SYS_CORE+25             
300f 18 30			dw .TZERO            
3011 03				db 2 + 1 
3012 .. 00			db "0<",0              
3015				endm 
# End of macro CWHEAD
3015			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3015					NEXTW 
3015 c3 11 1a			jp macro_next 
3018				endm 
# End of macro NEXTW
3018			.TZERO: 
3018				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3018 2e				db WORD_SYS_CORE+26             
3019 5f 30			dw .LESS            
301b 03				db 2 + 1 
301c .. 00			db "0=",0              
301f				endm 
# End of macro CWHEAD
301f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
301f				; TODO add floating point number detection 
301f					;v5 FORTH_DSP_VALUE 
301f					if DEBUG_FORTH_WORDS_KEY 
301f						DMARK "0=." 
301f f5				push af  
3020 3a 34 30			ld a, (.dmark)  
3023 32 7a ee			ld (debug_mark),a  
3026 3a 35 30			ld a, (.dmark+1)  
3029 32 7b ee			ld (debug_mark+1),a  
302c 3a 36 30			ld a, (.dmark+2)  
302f 32 7c ee			ld (debug_mark+2),a  
3032 18 03			jr .pastdmark  
3034 ..			.dmark: db "0=."  
3037 f1			.pastdmark: pop af  
3038			endm  
# End of macro DMARK
3038						CALLMONITOR 
3038 cd 86 12			call break_point_state  
303b				endm  
# End of macro CALLMONITOR
303b					endif 
303b					FORTH_DSP 
303b cd a0 18			call macro_forth_dsp 
303e				endm 
# End of macro FORTH_DSP
303e 7e					ld a,(hl)	; get type of value on TOS 
303f fe 02				cp DS_TYPE_INUM  
3041 28 00				jr z, .tz_inum 
3043			 
3043				if FORTH_ENABLE_FLOATMATH 
3043					jr .tz_done 
3043			 
3043				endif 
3043					 
3043			 
3043			.tz_inum: 
3043					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3043 cd bb 18			call macro_dsp_valuehl 
3046				endm 
# End of macro FORTH_DSP_VALUEHL
3046			 
3046			;		push hl 
3046			 
3046					; destroy value TOS 
3046			 
3046					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3046 cd 57 19			call macro_forth_dsp_pop 
3049				endm 
# End of macro FORTH_DSP_POP
3049			 
3049			;		pop hl 
3049			 
3049 3e 00				ld a,0 
304b			 
304b bd					cp l 
304c 20 08				jr nz, .tz_notzero 
304e			 
304e bc					cp h 
304f			 
304f 20 05				jr nz, .tz_notzero 
3051			 
3051			 
3051 21 01 00				ld hl, FORTH_TRUE 
3054 18 03				jr .tz_done 
3056			 
3056 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3059			 
3059					; push value back onto stack for another op etc 
3059			 
3059			.tz_done: 
3059 cd 20 18				call forth_push_numhl 
305c			 
305c					NEXTW 
305c c3 11 1a			jp macro_next 
305f				endm 
# End of macro NEXTW
305f			.LESS: 
305f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
305f 2f				db WORD_SYS_CORE+27             
3060 c8 30			dw .GT            
3062 02				db 1 + 1 
3063 .. 00			db "<",0              
3065				endm 
# End of macro CWHEAD
3065			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3065				; TODO add floating point number detection 
3065					if DEBUG_FORTH_WORDS_KEY 
3065						DMARK "LES" 
3065 f5				push af  
3066 3a 7a 30			ld a, (.dmark)  
3069 32 7a ee			ld (debug_mark),a  
306c 3a 7b 30			ld a, (.dmark+1)  
306f 32 7b ee			ld (debug_mark+1),a  
3072 3a 7c 30			ld a, (.dmark+2)  
3075 32 7c ee			ld (debug_mark+2),a  
3078 18 03			jr .pastdmark  
307a ..			.dmark: db "LES"  
307d f1			.pastdmark: pop af  
307e			endm  
# End of macro DMARK
307e						CALLMONITOR 
307e cd 86 12			call break_point_state  
3081				endm  
# End of macro CALLMONITOR
3081					endif 
3081					FORTH_DSP 
3081 cd a0 18			call macro_forth_dsp 
3084				endm 
# End of macro FORTH_DSP
3084					;v5 FORTH_DSP_VALUE 
3084 7e					ld a,(hl)	; get type of value on TOS 
3085 fe 02				cp DS_TYPE_INUM  
3087 28 00				jr z, .less_inum 
3089			 
3089				if FORTH_ENABLE_FLOATMATH 
3089					jr .less_done 
3089			 
3089				endif 
3089					 
3089			 
3089			.less_inum: 
3089					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3089 cd bb 18			call macro_dsp_valuehl 
308c				endm 
# End of macro FORTH_DSP_VALUEHL
308c			 
308c e5					push hl  ; u2 
308d			 
308d					; destroy value TOS 
308d			 
308d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
308d cd 57 19			call macro_forth_dsp_pop 
3090				endm 
# End of macro FORTH_DSP_POP
3090			 
3090			 
3090					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3090 cd bb 18			call macro_dsp_valuehl 
3093				endm 
# End of macro FORTH_DSP_VALUEHL
3093			 
3093 e5					push hl    ; u1 
3094			 
3094					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3094 cd 57 19			call macro_forth_dsp_pop 
3097				endm 
# End of macro FORTH_DSP_POP
3097			 
3097			 
3097 b7			 or a      ;clear carry flag 
3098 01 00 00		 ld bc, FORTH_FALSE 
309b e1			  pop hl    ; u1 
309c d1			  pop de    ; u2 
309d ed 52		  sbc hl,de 
309f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
30a1			 
30a1 01 01 00		 ld bc, FORTH_TRUE 
30a4			.lscont:  
30a4 c5					push bc 
30a5 e1					pop hl 
30a6			 
30a6					if DEBUG_FORTH_WORDS 
30a6						DMARK "LT1" 
30a6 f5				push af  
30a7 3a bb 30			ld a, (.dmark)  
30aa 32 7a ee			ld (debug_mark),a  
30ad 3a bc 30			ld a, (.dmark+1)  
30b0 32 7b ee			ld (debug_mark+1),a  
30b3 3a bd 30			ld a, (.dmark+2)  
30b6 32 7c ee			ld (debug_mark+2),a  
30b9 18 03			jr .pastdmark  
30bb ..			.dmark: db "LT1"  
30be f1			.pastdmark: pop af  
30bf			endm  
# End of macro DMARK
30bf						CALLMONITOR 
30bf cd 86 12			call break_point_state  
30c2				endm  
# End of macro CALLMONITOR
30c2					endif 
30c2 cd 20 18				call forth_push_numhl 
30c5			 
30c5					NEXTW 
30c5 c3 11 1a			jp macro_next 
30c8				endm 
# End of macro NEXTW
30c8			.GT: 
30c8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
30c8 30				db WORD_SYS_CORE+28             
30c9 31 31			dw .EQUAL            
30cb 02				db 1 + 1 
30cc .. 00			db ">",0              
30ce				endm 
# End of macro CWHEAD
30ce			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
30ce				; TODO add floating point number detection 
30ce					if DEBUG_FORTH_WORDS_KEY 
30ce						DMARK "GRT" 
30ce f5				push af  
30cf 3a e3 30			ld a, (.dmark)  
30d2 32 7a ee			ld (debug_mark),a  
30d5 3a e4 30			ld a, (.dmark+1)  
30d8 32 7b ee			ld (debug_mark+1),a  
30db 3a e5 30			ld a, (.dmark+2)  
30de 32 7c ee			ld (debug_mark+2),a  
30e1 18 03			jr .pastdmark  
30e3 ..			.dmark: db "GRT"  
30e6 f1			.pastdmark: pop af  
30e7			endm  
# End of macro DMARK
30e7						CALLMONITOR 
30e7 cd 86 12			call break_point_state  
30ea				endm  
# End of macro CALLMONITOR
30ea					endif 
30ea					FORTH_DSP 
30ea cd a0 18			call macro_forth_dsp 
30ed				endm 
# End of macro FORTH_DSP
30ed					;FORTH_DSP_VALUE 
30ed 7e					ld a,(hl)	; get type of value on TOS 
30ee fe 02				cp DS_TYPE_INUM  
30f0 28 00				jr z, .gt_inum 
30f2			 
30f2				if FORTH_ENABLE_FLOATMATH 
30f2					jr .gt_done 
30f2			 
30f2				endif 
30f2					 
30f2			 
30f2			.gt_inum: 
30f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
30f2 cd bb 18			call macro_dsp_valuehl 
30f5				endm 
# End of macro FORTH_DSP_VALUEHL
30f5			 
30f5 e5					push hl  ; u2 
30f6			 
30f6					; destroy value TOS 
30f6			 
30f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
30f6 cd 57 19			call macro_forth_dsp_pop 
30f9				endm 
# End of macro FORTH_DSP_POP
30f9			 
30f9			 
30f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
30f9 cd bb 18			call macro_dsp_valuehl 
30fc				endm 
# End of macro FORTH_DSP_VALUEHL
30fc			 
30fc e5					push hl    ; u1 
30fd			 
30fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
30fd cd 57 19			call macro_forth_dsp_pop 
3100				endm 
# End of macro FORTH_DSP_POP
3100			 
3100			 
3100 b7			 or a      ;clear carry flag 
3101 01 00 00		 ld bc, FORTH_FALSE 
3104 e1			  pop hl    ; u1 
3105 d1			  pop de    ; u2 
3106 ed 52		  sbc hl,de 
3108 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
310a			 
310a 01 01 00		 ld bc, FORTH_TRUE 
310d			.gtcont:  
310d c5					push bc 
310e e1					pop hl 
310f			 
310f					if DEBUG_FORTH_WORDS 
310f						DMARK "GT1" 
310f f5				push af  
3110 3a 24 31			ld a, (.dmark)  
3113 32 7a ee			ld (debug_mark),a  
3116 3a 25 31			ld a, (.dmark+1)  
3119 32 7b ee			ld (debug_mark+1),a  
311c 3a 26 31			ld a, (.dmark+2)  
311f 32 7c ee			ld (debug_mark+2),a  
3122 18 03			jr .pastdmark  
3124 ..			.dmark: db "GT1"  
3127 f1			.pastdmark: pop af  
3128			endm  
# End of macro DMARK
3128						CALLMONITOR 
3128 cd 86 12			call break_point_state  
312b				endm  
# End of macro CALLMONITOR
312b					endif 
312b cd 20 18				call forth_push_numhl 
312e			 
312e					NEXTW 
312e c3 11 1a			jp macro_next 
3131				endm 
# End of macro NEXTW
3131			.EQUAL: 
3131				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3131 31				db WORD_SYS_CORE+29             
3132 9c 31			dw .ENDLOGIC            
3134 02				db 1 + 1 
3135 .. 00			db "=",0              
3137				endm 
# End of macro CWHEAD
3137			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3137				; TODO add floating point number detection 
3137					if DEBUG_FORTH_WORDS_KEY 
3137						DMARK "EQ." 
3137 f5				push af  
3138 3a 4c 31			ld a, (.dmark)  
313b 32 7a ee			ld (debug_mark),a  
313e 3a 4d 31			ld a, (.dmark+1)  
3141 32 7b ee			ld (debug_mark+1),a  
3144 3a 4e 31			ld a, (.dmark+2)  
3147 32 7c ee			ld (debug_mark+2),a  
314a 18 03			jr .pastdmark  
314c ..			.dmark: db "EQ."  
314f f1			.pastdmark: pop af  
3150			endm  
# End of macro DMARK
3150						CALLMONITOR 
3150 cd 86 12			call break_point_state  
3153				endm  
# End of macro CALLMONITOR
3153					endif 
3153					FORTH_DSP 
3153 cd a0 18			call macro_forth_dsp 
3156				endm 
# End of macro FORTH_DSP
3156					;v5 FORTH_DSP_VALUE 
3156 7e					ld a,(hl)	; get type of value on TOS 
3157 fe 02				cp DS_TYPE_INUM  
3159 28 00				jr z, .eq_inum 
315b			 
315b				if FORTH_ENABLE_FLOATMATH 
315b					jr .eq_done 
315b			 
315b				endif 
315b					 
315b			 
315b			.eq_inum: 
315b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
315b cd bb 18			call macro_dsp_valuehl 
315e				endm 
# End of macro FORTH_DSP_VALUEHL
315e			 
315e e5					push hl 
315f			 
315f					; destroy value TOS 
315f			 
315f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
315f cd 57 19			call macro_forth_dsp_pop 
3162				endm 
# End of macro FORTH_DSP_POP
3162			 
3162			 
3162					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3162 cd bb 18			call macro_dsp_valuehl 
3165				endm 
# End of macro FORTH_DSP_VALUEHL
3165			 
3165					; one value on hl get other one back 
3165			 
3165 e5					push hl 
3166			 
3166					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3166 cd 57 19			call macro_forth_dsp_pop 
3169				endm 
# End of macro FORTH_DSP_POP
3169			 
3169 0e 00				ld c, FORTH_FALSE 
316b			 
316b e1					pop hl 
316c d1					pop de 
316d			 
316d 7b					ld a, e 
316e bd					cp l 
316f			 
316f 20 06				jr nz, .eq_done 
3171			 
3171 7a					ld a, d 
3172 bc					cp h 
3173			 
3173 20 02				jr nz, .eq_done 
3175			 
3175 0e 01				ld c, FORTH_TRUE 
3177					 
3177			 
3177			 
3177			.eq_done: 
3177			 
3177					; TODO push value back onto stack for another op etc 
3177			 
3177 26 00				ld h, 0 
3179 69					ld l, c 
317a					if DEBUG_FORTH_WORDS 
317a						DMARK "EQ1" 
317a f5				push af  
317b 3a 8f 31			ld a, (.dmark)  
317e 32 7a ee			ld (debug_mark),a  
3181 3a 90 31			ld a, (.dmark+1)  
3184 32 7b ee			ld (debug_mark+1),a  
3187 3a 91 31			ld a, (.dmark+2)  
318a 32 7c ee			ld (debug_mark+2),a  
318d 18 03			jr .pastdmark  
318f ..			.dmark: db "EQ1"  
3192 f1			.pastdmark: pop af  
3193			endm  
# End of macro DMARK
3193						CALLMONITOR 
3193 cd 86 12			call break_point_state  
3196				endm  
# End of macro CALLMONITOR
3196					endif 
3196 cd 20 18				call forth_push_numhl 
3199			 
3199					NEXTW 
3199 c3 11 1a			jp macro_next 
319c				endm 
# End of macro NEXTW
319c			 
319c			 
319c			.ENDLOGIC: 
319c			; eof 
319c			 
319c			 
# End of file forth_words_logic.asm
319c			include "forth_words_maths.asm" 
319c			 
319c			; | ## Maths Words 
319c			 
319c			.PLUS:	 
319c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
319c 15				db WORD_SYS_CORE+1             
319d de 31			dw .NEG            
319f 02				db 1 + 1 
31a0 .. 00			db "+",0              
31a2				endm 
# End of macro CWHEAD
31a2			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
31a2					if DEBUG_FORTH_WORDS_KEY 
31a2						DMARK "PLU" 
31a2 f5				push af  
31a3 3a b7 31			ld a, (.dmark)  
31a6 32 7a ee			ld (debug_mark),a  
31a9 3a b8 31			ld a, (.dmark+1)  
31ac 32 7b ee			ld (debug_mark+1),a  
31af 3a b9 31			ld a, (.dmark+2)  
31b2 32 7c ee			ld (debug_mark+2),a  
31b5 18 03			jr .pastdmark  
31b7 ..			.dmark: db "PLU"  
31ba f1			.pastdmark: pop af  
31bb			endm  
# End of macro DMARK
31bb						CALLMONITOR 
31bb cd 86 12			call break_point_state  
31be				endm  
# End of macro CALLMONITOR
31be					endif 
31be					; add top two values and push back result 
31be			 
31be					;for v5 FORTH_DSP_VALUE 
31be					FORTH_DSP 
31be cd a0 18			call macro_forth_dsp 
31c1				endm 
# End of macro FORTH_DSP
31c1 7e					ld a,(hl)	; get type of value on TOS 
31c2 fe 02				cp DS_TYPE_INUM  
31c4 28 03				jr z, .dot_inum 
31c6			 
31c6					NEXTW 
31c6 c3 11 1a			jp macro_next 
31c9				endm 
# End of macro NEXTW
31c9			 
31c9			; float maths 
31c9			 
31c9				if FORTH_ENABLE_FLOATMATH 
31c9						inc hl      ; now at start of numeric as string 
31c9			 
31c9					if DEBUG_FORTH_MATHS 
31c9						DMARK "ADD" 
31c9				CALLMONITOR 
31c9					endif 
31c9			 
31c9					;ld ix, hl 
31c9					call CON 
31c9			 
31c9			 
31c9					push hl 
31c9					 
31c9					 
31c9			 
31c9						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
31c9			 
31c9					; get next number 
31c9			 
31c9						FORTH_DSP_VALUE 
31c9			 
31c9						inc hl      ; now at start of numeric as string 
31c9			 
31c9					;ld ix, hl 
31c9					call CON 
31c9			 
31c9					push hl 
31c9			 
31c9			 
31c9						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31c9			 
31c9						; TODO do add 
31c9			 
31c9						call IADD 
31c9			 
31c9						; TODO get result back as ascii 
31c9			 
31c9						; TODO push result  
31c9			 
31c9			 
31c9			 
31c9						jr .dot_done 
31c9				endif 
31c9			 
31c9			.dot_inum: 
31c9			 
31c9			 
31c9					if DEBUG_FORTH_DOT 
31c9						DMARK "+IT" 
31c9				CALLMONITOR 
31c9					endif 
31c9			 
31c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31c9 cd bb 18			call macro_dsp_valuehl 
31cc				endm 
# End of macro FORTH_DSP_VALUEHL
31cc			 
31cc				; TODO add floating point number detection 
31cc			 
31cc e5					push hl 
31cd			 
31cd					; destroy value TOS 
31cd			 
31cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31cd cd 57 19			call macro_forth_dsp_pop 
31d0				endm 
# End of macro FORTH_DSP_POP
31d0			 
31d0			 
31d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31d0 cd bb 18			call macro_dsp_valuehl 
31d3				endm 
# End of macro FORTH_DSP_VALUEHL
31d3			 
31d3					; one value on hl get other one back 
31d3			 
31d3 d1					pop de 
31d4			 
31d4					; do the add 
31d4			 
31d4 19					add hl,de 
31d5			 
31d5					; save it 
31d5			 
31d5			;		push hl	 
31d5			 
31d5					; 
31d5			 
31d5					; destroy value TOS 
31d5			 
31d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31d5 cd 57 19			call macro_forth_dsp_pop 
31d8				endm 
# End of macro FORTH_DSP_POP
31d8			 
31d8					; TODO push value back onto stack for another op etc 
31d8			 
31d8			;		pop hl 
31d8			 
31d8			.dot_done: 
31d8 cd 20 18				call forth_push_numhl 
31db			 
31db					NEXTW 
31db c3 11 1a			jp macro_next 
31de				endm 
# End of macro NEXTW
31de			.NEG: 
31de			 
31de				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
31de 17				db WORD_SYS_CORE+3             
31df 21 32			dw .DIV            
31e1 02				db 1 + 1 
31e2 .. 00			db "-",0              
31e4				endm 
# End of macro CWHEAD
31e4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
31e4					if DEBUG_FORTH_WORDS_KEY 
31e4						DMARK "SUB" 
31e4 f5				push af  
31e5 3a f9 31			ld a, (.dmark)  
31e8 32 7a ee			ld (debug_mark),a  
31eb 3a fa 31			ld a, (.dmark+1)  
31ee 32 7b ee			ld (debug_mark+1),a  
31f1 3a fb 31			ld a, (.dmark+2)  
31f4 32 7c ee			ld (debug_mark+2),a  
31f7 18 03			jr .pastdmark  
31f9 ..			.dmark: db "SUB"  
31fc f1			.pastdmark: pop af  
31fd			endm  
# End of macro DMARK
31fd						CALLMONITOR 
31fd cd 86 12			call break_point_state  
3200				endm  
# End of macro CALLMONITOR
3200					endif 
3200			 
3200			 
3200				; TODO add floating point number detection 
3200					; v5 FORTH_DSP_VALUE 
3200					FORTH_DSP 
3200 cd a0 18			call macro_forth_dsp 
3203				endm 
# End of macro FORTH_DSP
3203 7e					ld a,(hl)	; get type of value on TOS 
3204 fe 02				cp DS_TYPE_INUM  
3206 28 03				jr z, .neg_inum 
3208			 
3208					NEXTW 
3208 c3 11 1a			jp macro_next 
320b				endm 
# End of macro NEXTW
320b			 
320b			; float maths 
320b			 
320b				if FORTH_ENABLE_FLOATMATH 
320b					jr .neg_done 
320b			 
320b				endif 
320b					 
320b			 
320b			.neg_inum: 
320b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
320b cd bb 18			call macro_dsp_valuehl 
320e				endm 
# End of macro FORTH_DSP_VALUEHL
320e			 
320e e5					push hl 
320f			 
320f					; destroy value TOS 
320f			 
320f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
320f cd 57 19			call macro_forth_dsp_pop 
3212				endm 
# End of macro FORTH_DSP_POP
3212			 
3212			 
3212					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3212 cd bb 18			call macro_dsp_valuehl 
3215				endm 
# End of macro FORTH_DSP_VALUEHL
3215			 
3215					; one value on hl get other one back 
3215			 
3215 d1					pop de 
3216			 
3216					; do the sub 
3216			;		ex de, hl 
3216			 
3216 ed 52				sbc hl,de 
3218			 
3218					; save it 
3218			 
3218			;		push hl	 
3218			 
3218					; 
3218			 
3218					; destroy value TOS 
3218			 
3218					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3218 cd 57 19			call macro_forth_dsp_pop 
321b				endm 
# End of macro FORTH_DSP_POP
321b			 
321b					; TODO push value back onto stack for another op etc 
321b			 
321b			;		pop hl 
321b			 
321b cd 20 18				call forth_push_numhl 
321e			.neg_done: 
321e			 
321e					NEXTW 
321e c3 11 1a			jp macro_next 
3221				endm 
# End of macro NEXTW
3221			.DIV: 
3221				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3221 18				db WORD_SYS_CORE+4             
3222 6e 32			dw .MUL            
3224 02				db 1 + 1 
3225 .. 00			db "/",0              
3227				endm 
# End of macro CWHEAD
3227			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3227					if DEBUG_FORTH_WORDS_KEY 
3227						DMARK "DIV" 
3227 f5				push af  
3228 3a 3c 32			ld a, (.dmark)  
322b 32 7a ee			ld (debug_mark),a  
322e 3a 3d 32			ld a, (.dmark+1)  
3231 32 7b ee			ld (debug_mark+1),a  
3234 3a 3e 32			ld a, (.dmark+2)  
3237 32 7c ee			ld (debug_mark+2),a  
323a 18 03			jr .pastdmark  
323c ..			.dmark: db "DIV"  
323f f1			.pastdmark: pop af  
3240			endm  
# End of macro DMARK
3240						CALLMONITOR 
3240 cd 86 12			call break_point_state  
3243				endm  
# End of macro CALLMONITOR
3243					endif 
3243				; TODO add floating point number detection 
3243					; v5 FORTH_DSP_VALUE 
3243					FORTH_DSP 
3243 cd a0 18			call macro_forth_dsp 
3246				endm 
# End of macro FORTH_DSP
3246 7e					ld a,(hl)	; get type of value on TOS 
3247 fe 02				cp DS_TYPE_INUM  
3249 28 03				jr z, .div_inum 
324b			 
324b				if FORTH_ENABLE_FLOATMATH 
324b					jr .div_done 
324b			 
324b				endif 
324b					NEXTW 
324b c3 11 1a			jp macro_next 
324e				endm 
# End of macro NEXTW
324e			.div_inum: 
324e			 
324e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
324e cd bb 18			call macro_dsp_valuehl 
3251				endm 
# End of macro FORTH_DSP_VALUEHL
3251			 
3251 e5					push hl    ; to go to bc 
3252			 
3252					; destroy value TOS 
3252			 
3252					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3252 cd 57 19			call macro_forth_dsp_pop 
3255				endm 
# End of macro FORTH_DSP_POP
3255			 
3255			 
3255					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3255 cd bb 18			call macro_dsp_valuehl 
3258				endm 
# End of macro FORTH_DSP_VALUEHL
3258			 
3258					; hl to go to de 
3258			 
3258 e5					push hl 
3259			 
3259 c1					pop bc 
325a d1					pop de		 
325b			 
325b			 
325b					if DEBUG_FORTH_MATHS 
325b						DMARK "DIV" 
325b				CALLMONITOR 
325b					endif 
325b					; one value on hl but move to a get other one back 
325b			 
325b			        
325b cd 1f 0a			call Div16 
325e			 
325e			;	push af	 
325e e5				push hl 
325f c5				push bc 
3260			 
3260					if DEBUG_FORTH_MATHS 
3260						DMARK "DI1" 
3260				CALLMONITOR 
3260					endif 
3260			 
3260					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3260 cd 57 19			call macro_forth_dsp_pop 
3263				endm 
# End of macro FORTH_DSP_POP
3263			 
3263			 
3263			 
3263 e1					pop hl    ; result 
3264			 
3264 cd 20 18				call forth_push_numhl 
3267			 
3267 e1					pop hl    ; reminder 
3268			;		ld h,0 
3268			;		ld l,d 
3268			 
3268 cd 20 18				call forth_push_numhl 
326b			.div_done: 
326b					NEXTW 
326b c3 11 1a			jp macro_next 
326e				endm 
# End of macro NEXTW
326e			.MUL: 
326e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
326e 19				db WORD_SYS_CORE+5             
326f b3 32			dw .MIN            
3271 02				db 1 + 1 
3272 .. 00			db "*",0              
3274				endm 
# End of macro CWHEAD
3274			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3274				; TODO add floating point number detection 
3274					if DEBUG_FORTH_WORDS_KEY 
3274						DMARK "MUL" 
3274 f5				push af  
3275 3a 89 32			ld a, (.dmark)  
3278 32 7a ee			ld (debug_mark),a  
327b 3a 8a 32			ld a, (.dmark+1)  
327e 32 7b ee			ld (debug_mark+1),a  
3281 3a 8b 32			ld a, (.dmark+2)  
3284 32 7c ee			ld (debug_mark+2),a  
3287 18 03			jr .pastdmark  
3289 ..			.dmark: db "MUL"  
328c f1			.pastdmark: pop af  
328d			endm  
# End of macro DMARK
328d						CALLMONITOR 
328d cd 86 12			call break_point_state  
3290				endm  
# End of macro CALLMONITOR
3290					endif 
3290					FORTH_DSP 
3290 cd a0 18			call macro_forth_dsp 
3293				endm 
# End of macro FORTH_DSP
3293					; v5 FORTH_DSP_VALUE 
3293 7e					ld a,(hl)	; get type of value on TOS 
3294 fe 02				cp DS_TYPE_INUM  
3296 28 03				jr z, .mul_inum 
3298			 
3298				if FORTH_ENABLE_FLOATMATH 
3298					jr .mul_done 
3298			 
3298				endif 
3298			 
3298					NEXTW 
3298 c3 11 1a			jp macro_next 
329b				endm 
# End of macro NEXTW
329b			.mul_inum:	 
329b			 
329b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
329b cd bb 18			call macro_dsp_valuehl 
329e				endm 
# End of macro FORTH_DSP_VALUEHL
329e			 
329e e5					push hl 
329f			 
329f					; destroy value TOS 
329f			 
329f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
329f cd 57 19			call macro_forth_dsp_pop 
32a2				endm 
# End of macro FORTH_DSP_POP
32a2			 
32a2			 
32a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a2 cd bb 18			call macro_dsp_valuehl 
32a5				endm 
# End of macro FORTH_DSP_VALUEHL
32a5			 
32a5					; one value on hl but move to a get other one back 
32a5			 
32a5 7d					ld a, l 
32a6			 
32a6 d1					pop de 
32a7			 
32a7					; do the mull 
32a7			;		ex de, hl 
32a7			 
32a7 cd 45 0a				call Mult16 
32aa					; save it 
32aa			 
32aa			;		push hl	 
32aa			 
32aa					; 
32aa			 
32aa					; destroy value TOS 
32aa			 
32aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32aa cd 57 19			call macro_forth_dsp_pop 
32ad				endm 
# End of macro FORTH_DSP_POP
32ad			 
32ad					; TODO push value back onto stack for another op etc 
32ad			 
32ad			;		pop hl 
32ad			 
32ad cd 20 18				call forth_push_numhl 
32b0			 
32b0			.mul_done: 
32b0					NEXTW 
32b0 c3 11 1a			jp macro_next 
32b3				endm 
# End of macro NEXTW
32b3			 
32b3			 
32b3			 
32b3			 
32b3			.MIN: 
32b3				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
32b3 49				db WORD_SYS_CORE+53             
32b4 34 33			dw .MAX            
32b6 04				db 3 + 1 
32b7 .. 00			db "MIN",0              
32bb				endm 
# End of macro CWHEAD
32bb			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
32bb					if DEBUG_FORTH_WORDS_KEY 
32bb						DMARK "MIN" 
32bb f5				push af  
32bc 3a d0 32			ld a, (.dmark)  
32bf 32 7a ee			ld (debug_mark),a  
32c2 3a d1 32			ld a, (.dmark+1)  
32c5 32 7b ee			ld (debug_mark+1),a  
32c8 3a d2 32			ld a, (.dmark+2)  
32cb 32 7c ee			ld (debug_mark+2),a  
32ce 18 03			jr .pastdmark  
32d0 ..			.dmark: db "MIN"  
32d3 f1			.pastdmark: pop af  
32d4			endm  
# End of macro DMARK
32d4						CALLMONITOR 
32d4 cd 86 12			call break_point_state  
32d7				endm  
# End of macro CALLMONITOR
32d7					endif 
32d7					; get u2 
32d7			 
32d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32d7 cd bb 18			call macro_dsp_valuehl 
32da				endm 
# End of macro FORTH_DSP_VALUEHL
32da			 
32da e5					push hl   ; u2 
32db			 
32db					; destroy value TOS 
32db			 
32db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32db cd 57 19			call macro_forth_dsp_pop 
32de				endm 
# End of macro FORTH_DSP_POP
32de			 
32de					; get u1 
32de			 
32de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32de cd bb 18			call macro_dsp_valuehl 
32e1				endm 
# End of macro FORTH_DSP_VALUEHL
32e1			 
32e1 e5					push hl  ; u1 
32e2			 
32e2					; destroy value TOS 
32e2			 
32e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32e2 cd 57 19			call macro_forth_dsp_pop 
32e5				endm 
# End of macro FORTH_DSP_POP
32e5			 
32e5 b7			 or a      ;clear carry flag 
32e6 e1			  pop hl    ; u1 
32e7 d1			  pop de    ; u2 
32e8 e5				push hl   ; saved in case hl is lowest 
32e9 ed 52		  sbc hl,de 
32eb 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
32ed			 
32ed e1				pop hl 
32ee					if DEBUG_FORTH_WORDS 
32ee						DMARK "MIN" 
32ee f5				push af  
32ef 3a 03 33			ld a, (.dmark)  
32f2 32 7a ee			ld (debug_mark),a  
32f5 3a 04 33			ld a, (.dmark+1)  
32f8 32 7b ee			ld (debug_mark+1),a  
32fb 3a 05 33			ld a, (.dmark+2)  
32fe 32 7c ee			ld (debug_mark+2),a  
3301 18 03			jr .pastdmark  
3303 ..			.dmark: db "MIN"  
3306 f1			.pastdmark: pop af  
3307			endm  
# End of macro DMARK
3307						CALLMONITOR 
3307 cd 86 12			call break_point_state  
330a				endm  
# End of macro CALLMONITOR
330a					endif 
330a cd 20 18				call forth_push_numhl 
330d			 
330d				       NEXTW 
330d c3 11 1a			jp macro_next 
3310				endm 
# End of macro NEXTW
3310			 
3310			.mincont:  
3310 c1				pop bc   ; tidy up 
3311 eb				ex de , hl  
3312					if DEBUG_FORTH_WORDS 
3312						DMARK "MI1" 
3312 f5				push af  
3313 3a 27 33			ld a, (.dmark)  
3316 32 7a ee			ld (debug_mark),a  
3319 3a 28 33			ld a, (.dmark+1)  
331c 32 7b ee			ld (debug_mark+1),a  
331f 3a 29 33			ld a, (.dmark+2)  
3322 32 7c ee			ld (debug_mark+2),a  
3325 18 03			jr .pastdmark  
3327 ..			.dmark: db "MI1"  
332a f1			.pastdmark: pop af  
332b			endm  
# End of macro DMARK
332b						CALLMONITOR 
332b cd 86 12			call break_point_state  
332e				endm  
# End of macro CALLMONITOR
332e					endif 
332e cd 20 18				call forth_push_numhl 
3331			 
3331				       NEXTW 
3331 c3 11 1a			jp macro_next 
3334				endm 
# End of macro NEXTW
3334			.MAX: 
3334				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3334 4a				db WORD_SYS_CORE+54             
3335 b5 33			dw .RND16            
3337 04				db 3 + 1 
3338 .. 00			db "MAX",0              
333c				endm 
# End of macro CWHEAD
333c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
333c					if DEBUG_FORTH_WORDS_KEY 
333c						DMARK "MAX" 
333c f5				push af  
333d 3a 51 33			ld a, (.dmark)  
3340 32 7a ee			ld (debug_mark),a  
3343 3a 52 33			ld a, (.dmark+1)  
3346 32 7b ee			ld (debug_mark+1),a  
3349 3a 53 33			ld a, (.dmark+2)  
334c 32 7c ee			ld (debug_mark+2),a  
334f 18 03			jr .pastdmark  
3351 ..			.dmark: db "MAX"  
3354 f1			.pastdmark: pop af  
3355			endm  
# End of macro DMARK
3355						CALLMONITOR 
3355 cd 86 12			call break_point_state  
3358				endm  
# End of macro CALLMONITOR
3358					endif 
3358					; get u2 
3358			 
3358					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3358 cd bb 18			call macro_dsp_valuehl 
335b				endm 
# End of macro FORTH_DSP_VALUEHL
335b			 
335b e5					push hl   ; u2 
335c			 
335c					; destroy value TOS 
335c			 
335c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
335c cd 57 19			call macro_forth_dsp_pop 
335f				endm 
# End of macro FORTH_DSP_POP
335f			 
335f					; get u1 
335f			 
335f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
335f cd bb 18			call macro_dsp_valuehl 
3362				endm 
# End of macro FORTH_DSP_VALUEHL
3362			 
3362 e5					push hl  ; u1 
3363			 
3363					; destroy value TOS 
3363			 
3363					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3363 cd 57 19			call macro_forth_dsp_pop 
3366				endm 
# End of macro FORTH_DSP_POP
3366			 
3366 b7			 or a      ;clear carry flag 
3367 e1			  pop hl    ; u1 
3368 d1			  pop de    ; u2 
3369 e5				push hl   ; saved in case hl is lowest 
336a ed 52		  sbc hl,de 
336c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
336e			 
336e e1				pop hl 
336f					if DEBUG_FORTH_WORDS 
336f						DMARK "MAX" 
336f f5				push af  
3370 3a 84 33			ld a, (.dmark)  
3373 32 7a ee			ld (debug_mark),a  
3376 3a 85 33			ld a, (.dmark+1)  
3379 32 7b ee			ld (debug_mark+1),a  
337c 3a 86 33			ld a, (.dmark+2)  
337f 32 7c ee			ld (debug_mark+2),a  
3382 18 03			jr .pastdmark  
3384 ..			.dmark: db "MAX"  
3387 f1			.pastdmark: pop af  
3388			endm  
# End of macro DMARK
3388						CALLMONITOR 
3388 cd 86 12			call break_point_state  
338b				endm  
# End of macro CALLMONITOR
338b					endif 
338b cd 20 18				call forth_push_numhl 
338e			 
338e				       NEXTW 
338e c3 11 1a			jp macro_next 
3391				endm 
# End of macro NEXTW
3391			 
3391			.maxcont:  
3391 c1				pop bc   ; tidy up 
3392 eb				ex de , hl  
3393					if DEBUG_FORTH_WORDS 
3393						DMARK "MA1" 
3393 f5				push af  
3394 3a a8 33			ld a, (.dmark)  
3397 32 7a ee			ld (debug_mark),a  
339a 3a a9 33			ld a, (.dmark+1)  
339d 32 7b ee			ld (debug_mark+1),a  
33a0 3a aa 33			ld a, (.dmark+2)  
33a3 32 7c ee			ld (debug_mark+2),a  
33a6 18 03			jr .pastdmark  
33a8 ..			.dmark: db "MA1"  
33ab f1			.pastdmark: pop af  
33ac			endm  
# End of macro DMARK
33ac						CALLMONITOR 
33ac cd 86 12			call break_point_state  
33af				endm  
# End of macro CALLMONITOR
33af					endif 
33af cd 20 18				call forth_push_numhl 
33b2				       NEXTW 
33b2 c3 11 1a			jp macro_next 
33b5				endm 
# End of macro NEXTW
33b5			 
33b5			.RND16: 
33b5				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
33b5 4e				db WORD_SYS_CORE+58             
33b6 e4 33			dw .RND8            
33b8 06				db 5 + 1 
33b9 .. 00			db "RND16",0              
33bf				endm 
# End of macro CWHEAD
33bf			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
33bf					if DEBUG_FORTH_WORDS_KEY 
33bf						DMARK "R16" 
33bf f5				push af  
33c0 3a d4 33			ld a, (.dmark)  
33c3 32 7a ee			ld (debug_mark),a  
33c6 3a d5 33			ld a, (.dmark+1)  
33c9 32 7b ee			ld (debug_mark+1),a  
33cc 3a d6 33			ld a, (.dmark+2)  
33cf 32 7c ee			ld (debug_mark+2),a  
33d2 18 03			jr .pastdmark  
33d4 ..			.dmark: db "R16"  
33d7 f1			.pastdmark: pop af  
33d8			endm  
# End of macro DMARK
33d8						CALLMONITOR 
33d8 cd 86 12			call break_point_state  
33db				endm  
# End of macro CALLMONITOR
33db					endif 
33db cd e9 09				call prng16  
33de cd 20 18				call forth_push_numhl 
33e1				       NEXTW 
33e1 c3 11 1a			jp macro_next 
33e4				endm 
# End of macro NEXTW
33e4			.RND8: 
33e4				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
33e4 60				db WORD_SYS_CORE+76             
33e5 19 34			dw .RND            
33e7 05				db 4 + 1 
33e8 .. 00			db "RND8",0              
33ed				endm 
# End of macro CWHEAD
33ed			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
33ed					if DEBUG_FORTH_WORDS_KEY 
33ed						DMARK "RN8" 
33ed f5				push af  
33ee 3a 02 34			ld a, (.dmark)  
33f1 32 7a ee			ld (debug_mark),a  
33f4 3a 03 34			ld a, (.dmark+1)  
33f7 32 7b ee			ld (debug_mark+1),a  
33fa 3a 04 34			ld a, (.dmark+2)  
33fd 32 7c ee			ld (debug_mark+2),a  
3400 18 03			jr .pastdmark  
3402 ..			.dmark: db "RN8"  
3405 f1			.pastdmark: pop af  
3406			endm  
# End of macro DMARK
3406						CALLMONITOR 
3406 cd 86 12			call break_point_state  
3409				endm  
# End of macro CALLMONITOR
3409					endif 
3409 2a bb eb				ld hl,(xrandc) 
340c 23					inc hl 
340d cd 03 0a				call xrnd 
3410 6f					ld l,a	 
3411 26 00				ld h,0 
3413 cd 20 18				call forth_push_numhl 
3416				       NEXTW 
3416 c3 11 1a			jp macro_next 
3419				endm 
# End of macro NEXTW
3419			.RND: 
3419				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3419 60				db WORD_SYS_CORE+76             
341a 1f 35			dw .ENDMATHS            
341c 04				db 3 + 1 
341d .. 00			db "RND",0              
3421				endm 
# End of macro CWHEAD
3421			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3421			 
3421					if DEBUG_FORTH_WORDS_KEY 
3421						DMARK "RND" 
3421 f5				push af  
3422 3a 36 34			ld a, (.dmark)  
3425 32 7a ee			ld (debug_mark),a  
3428 3a 37 34			ld a, (.dmark+1)  
342b 32 7b ee			ld (debug_mark+1),a  
342e 3a 38 34			ld a, (.dmark+2)  
3431 32 7c ee			ld (debug_mark+2),a  
3434 18 03			jr .pastdmark  
3436 ..			.dmark: db "RND"  
3439 f1			.pastdmark: pop af  
343a			endm  
# End of macro DMARK
343a						CALLMONITOR 
343a cd 86 12			call break_point_state  
343d				endm  
# End of macro CALLMONITOR
343d					endif 
343d					 
343d					FORTH_DSP_VALUEHL    ; upper range 
343d cd bb 18			call macro_dsp_valuehl 
3440				endm 
# End of macro FORTH_DSP_VALUEHL
3440			 
3440 22 bf eb				ld (LFSRSeed), hl	 
3443			 
3443					if DEBUG_FORTH_WORDS 
3443						DMARK "RN1" 
3443 f5				push af  
3444 3a 58 34			ld a, (.dmark)  
3447 32 7a ee			ld (debug_mark),a  
344a 3a 59 34			ld a, (.dmark+1)  
344d 32 7b ee			ld (debug_mark+1),a  
3450 3a 5a 34			ld a, (.dmark+2)  
3453 32 7c ee			ld (debug_mark+2),a  
3456 18 03			jr .pastdmark  
3458 ..			.dmark: db "RN1"  
345b f1			.pastdmark: pop af  
345c			endm  
# End of macro DMARK
345c						CALLMONITOR 
345c cd 86 12			call break_point_state  
345f				endm  
# End of macro CALLMONITOR
345f					endif 
345f					FORTH_DSP_POP 
345f cd 57 19			call macro_forth_dsp_pop 
3462				endm 
# End of macro FORTH_DSP_POP
3462			 
3462					FORTH_DSP_VALUEHL    ; low range 
3462 cd bb 18			call macro_dsp_valuehl 
3465				endm 
# End of macro FORTH_DSP_VALUEHL
3465			 
3465					if DEBUG_FORTH_WORDS 
3465						DMARK "RN2" 
3465 f5				push af  
3466 3a 7a 34			ld a, (.dmark)  
3469 32 7a ee			ld (debug_mark),a  
346c 3a 7b 34			ld a, (.dmark+1)  
346f 32 7b ee			ld (debug_mark+1),a  
3472 3a 7c 34			ld a, (.dmark+2)  
3475 32 7c ee			ld (debug_mark+2),a  
3478 18 03			jr .pastdmark  
347a ..			.dmark: db "RN2"  
347d f1			.pastdmark: pop af  
347e			endm  
# End of macro DMARK
347e						CALLMONITOR 
347e cd 86 12			call break_point_state  
3481				endm  
# End of macro CALLMONITOR
3481					endif 
3481 22 c1 eb				ld (LFSRSeed+2), hl 
3484			 
3484					FORTH_DSP_POP 
3484 cd 57 19			call macro_forth_dsp_pop 
3487				endm 
# End of macro FORTH_DSP_POP
3487			 
3487 e5					push hl 
3488			 
3488 e1			.inrange:	pop hl 
3489 cd e9 09				call prng16  
348c					if DEBUG_FORTH_WORDS 
348c						DMARK "RN3" 
348c f5				push af  
348d 3a a1 34			ld a, (.dmark)  
3490 32 7a ee			ld (debug_mark),a  
3493 3a a2 34			ld a, (.dmark+1)  
3496 32 7b ee			ld (debug_mark+1),a  
3499 3a a3 34			ld a, (.dmark+2)  
349c 32 7c ee			ld (debug_mark+2),a  
349f 18 03			jr .pastdmark  
34a1 ..			.dmark: db "RN3"  
34a4 f1			.pastdmark: pop af  
34a5			endm  
# End of macro DMARK
34a5						CALLMONITOR 
34a5 cd 86 12			call break_point_state  
34a8				endm  
# End of macro CALLMONITOR
34a8					endif 
34a8					 
34a8					; if the range is 8bit knock out the high byte 
34a8			 
34a8 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
34ac			 
34ac 3e 00				ld a, 0 
34ae ba					cp d  
34af 20 1e				jr nz, .hirange 
34b1 26 00				ld h, 0   ; knock it down to 8bit 
34b3			 
34b3					if DEBUG_FORTH_WORDS 
34b3						DMARK "RNk" 
34b3 f5				push af  
34b4 3a c8 34			ld a, (.dmark)  
34b7 32 7a ee			ld (debug_mark),a  
34ba 3a c9 34			ld a, (.dmark+1)  
34bd 32 7b ee			ld (debug_mark+1),a  
34c0 3a ca 34			ld a, (.dmark+2)  
34c3 32 7c ee			ld (debug_mark+2),a  
34c6 18 03			jr .pastdmark  
34c8 ..			.dmark: db "RNk"  
34cb f1			.pastdmark: pop af  
34cc			endm  
# End of macro DMARK
34cc						CALLMONITOR 
34cc cd 86 12			call break_point_state  
34cf				endm  
# End of macro CALLMONITOR
34cf					endif 
34cf			.hirange:   
34cf e5					push hl  
34d0 b7					or a  
34d1 ed 52		                sbc hl, de 
34d3			 
34d3					;call cmp16 
34d3			 
34d3 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
34d5 e1					pop hl 
34d6 e5					push hl 
34d7			 
34d7					if DEBUG_FORTH_WORDS 
34d7						DMARK "RN4" 
34d7 f5				push af  
34d8 3a ec 34			ld a, (.dmark)  
34db 32 7a ee			ld (debug_mark),a  
34de 3a ed 34			ld a, (.dmark+1)  
34e1 32 7b ee			ld (debug_mark+1),a  
34e4 3a ee 34			ld a, (.dmark+2)  
34e7 32 7c ee			ld (debug_mark+2),a  
34ea 18 03			jr .pastdmark  
34ec ..			.dmark: db "RN4"  
34ef f1			.pastdmark: pop af  
34f0			endm  
# End of macro DMARK
34f0						CALLMONITOR 
34f0 cd 86 12			call break_point_state  
34f3				endm  
# End of macro CALLMONITOR
34f3					endif 
34f3 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
34f7					;call cmp16 
34f7				 
34f7 b7					or a  
34f8 ed 52		                sbc hl, de 
34fa 38 8c				jr c, .inrange 
34fc			 
34fc e1					pop hl 
34fd					 
34fd					if DEBUG_FORTH_WORDS 
34fd						DMARK "RNd" 
34fd f5				push af  
34fe 3a 12 35			ld a, (.dmark)  
3501 32 7a ee			ld (debug_mark),a  
3504 3a 13 35			ld a, (.dmark+1)  
3507 32 7b ee			ld (debug_mark+1),a  
350a 3a 14 35			ld a, (.dmark+2)  
350d 32 7c ee			ld (debug_mark+2),a  
3510 18 03			jr .pastdmark  
3512 ..			.dmark: db "RNd"  
3515 f1			.pastdmark: pop af  
3516			endm  
# End of macro DMARK
3516						CALLMONITOR 
3516 cd 86 12			call break_point_state  
3519				endm  
# End of macro CALLMONITOR
3519					endif 
3519			 
3519			 
3519 cd 20 18				call forth_push_numhl 
351c				       NEXTW 
351c c3 11 1a			jp macro_next 
351f				endm 
# End of macro NEXTW
351f			 
351f			.ENDMATHS: 
351f			 
351f			; eof 
351f			 
# End of file forth_words_maths.asm
351f			include "forth_words_display.asm" 
351f			 
351f			; | ## Display Words 
351f			 
351f			.ATP: 
351f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
351f 62				db WORD_SYS_CORE+78             
3520 96 35			dw .FB            
3522 04				db 3 + 1 
3523 .. 00			db "AT?",0              
3527				endm 
# End of macro CWHEAD
3527			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3527					if DEBUG_FORTH_WORDS_KEY 
3527						DMARK "AT?" 
3527 f5				push af  
3528 3a 3c 35			ld a, (.dmark)  
352b 32 7a ee			ld (debug_mark),a  
352e 3a 3d 35			ld a, (.dmark+1)  
3531 32 7b ee			ld (debug_mark+1),a  
3534 3a 3e 35			ld a, (.dmark+2)  
3537 32 7c ee			ld (debug_mark+2),a  
353a 18 03			jr .pastdmark  
353c ..			.dmark: db "AT?"  
353f f1			.pastdmark: pop af  
3540			endm  
# End of macro DMARK
3540						CALLMONITOR 
3540 cd 86 12			call break_point_state  
3543				endm  
# End of macro CALLMONITOR
3543					endif 
3543 3a 5e eb				ld a, (f_cursor_ptr) 
3546			 
3546			if DEBUG_FORTH_WORDS 
3546				DMARK "AT?" 
3546 f5				push af  
3547 3a 5b 35			ld a, (.dmark)  
354a 32 7a ee			ld (debug_mark),a  
354d 3a 5c 35			ld a, (.dmark+1)  
3550 32 7b ee			ld (debug_mark+1),a  
3553 3a 5d 35			ld a, (.dmark+2)  
3556 32 7c ee			ld (debug_mark+2),a  
3559 18 03			jr .pastdmark  
355b ..			.dmark: db "AT?"  
355e f1			.pastdmark: pop af  
355f			endm  
# End of macro DMARK
355f				CALLMONITOR 
355f cd 86 12			call break_point_state  
3562				endm  
# End of macro CALLMONITOR
3562			endif	 
3562					; count the number of rows 
3562			 
3562 06 00				ld b, 0 
3564 4f			.atpr:		ld c, a    ; save in case we go below zero 
3565 d6 28				sub display_cols 
3567 f2 6d 35				jp p, .atprunder 
356a 04					inc b 
356b 18 f7				jr .atpr 
356d			.atprunder:	 
356d			if DEBUG_FORTH_WORDS 
356d				DMARK "A?2" 
356d f5				push af  
356e 3a 82 35			ld a, (.dmark)  
3571 32 7a ee			ld (debug_mark),a  
3574 3a 83 35			ld a, (.dmark+1)  
3577 32 7b ee			ld (debug_mark+1),a  
357a 3a 84 35			ld a, (.dmark+2)  
357d 32 7c ee			ld (debug_mark+2),a  
3580 18 03			jr .pastdmark  
3582 ..			.dmark: db "A?2"  
3585 f1			.pastdmark: pop af  
3586			endm  
# End of macro DMARK
3586				CALLMONITOR 
3586 cd 86 12			call break_point_state  
3589				endm  
# End of macro CALLMONITOR
3589			endif	 
3589 26 00				ld h, 0 
358b 69					ld l, c 
358c cd 20 18				call forth_push_numhl 
358f 68					ld l, b  
3590 cd 20 18				call forth_push_numhl 
3593			 
3593			 
3593				NEXTW 
3593 c3 11 1a			jp macro_next 
3596				endm 
# End of macro NEXTW
3596			 
3596			.FB: 
3596				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3596 1b				db WORD_SYS_CORE+7             
3597 e4 35			dw .EMIT            
3599 03				db 2 + 1 
359a .. 00			db "FB",0              
359d				endm 
# End of macro CWHEAD
359d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
359d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
359d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
359d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
359d					if DEBUG_FORTH_WORDS_KEY 
359d						DMARK "FB." 
359d f5				push af  
359e 3a b2 35			ld a, (.dmark)  
35a1 32 7a ee			ld (debug_mark),a  
35a4 3a b3 35			ld a, (.dmark+1)  
35a7 32 7b ee			ld (debug_mark+1),a  
35aa 3a b4 35			ld a, (.dmark+2)  
35ad 32 7c ee			ld (debug_mark+2),a  
35b0 18 03			jr .pastdmark  
35b2 ..			.dmark: db "FB."  
35b5 f1			.pastdmark: pop af  
35b6			endm  
# End of macro DMARK
35b6						CALLMONITOR 
35b6 cd 86 12			call break_point_state  
35b9				endm  
# End of macro CALLMONITOR
35b9					endif 
35b9			 
35b9					FORTH_DSP_VALUEHL 
35b9 cd bb 18			call macro_dsp_valuehl 
35bc				endm 
# End of macro FORTH_DSP_VALUEHL
35bc			 
35bc 7d					ld a, l 
35bd fe 01				cp 1 
35bf 20 05				jr nz, .fbn1 
35c1 21 1f ed				ld hl, display_fb1 
35c4 18 15				jr .fbset 
35c6 fe 02		.fbn1:		cp 2 
35c8 20 05				jr nz, .fbn2 
35ca 21 dd eb				ld hl, display_fb2 
35cd 18 0c				jr .fbset 
35cf fe 03		.fbn2:		cp 3 
35d1 20 05				jr nz, .fbn3 
35d3 21 7e ec				ld hl, display_fb3 
35d6 18 03				jr .fbset 
35d8			.fbn3:		 ; if invalid number select first 
35d8 21 1f ed				ld hl, display_fb1 
35db 22 db eb		.fbset:		ld (display_fb_active), hl 
35de			 
35de					FORTH_DSP_POP 
35de cd 57 19			call macro_forth_dsp_pop 
35e1				endm 
# End of macro FORTH_DSP_POP
35e1			 
35e1					NEXTW 
35e1 c3 11 1a			jp macro_next 
35e4				endm 
# End of macro NEXTW
35e4			 
35e4			 
35e4			.EMIT: 
35e4				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
35e4 1b				db WORD_SYS_CORE+7             
35e5 35 36			dw .DOTH            
35e7 05				db 4 + 1 
35e8 .. 00			db "EMIT",0              
35ed				endm 
# End of macro CWHEAD
35ed			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
35ed					; get value off TOS and display it 
35ed			 
35ed					if DEBUG_FORTH_WORDS_KEY 
35ed						DMARK "EMT" 
35ed f5				push af  
35ee 3a 02 36			ld a, (.dmark)  
35f1 32 7a ee			ld (debug_mark),a  
35f4 3a 03 36			ld a, (.dmark+1)  
35f7 32 7b ee			ld (debug_mark+1),a  
35fa 3a 04 36			ld a, (.dmark+2)  
35fd 32 7c ee			ld (debug_mark+2),a  
3600 18 03			jr .pastdmark  
3602 ..			.dmark: db "EMT"  
3605 f1			.pastdmark: pop af  
3606			endm  
# End of macro DMARK
3606						CALLMONITOR 
3606 cd 86 12			call break_point_state  
3609				endm  
# End of macro CALLMONITOR
3609					endif 
3609			 
3609					FORTH_DSP_VALUEHL 
3609 cd bb 18			call macro_dsp_valuehl 
360c				endm 
# End of macro FORTH_DSP_VALUEHL
360c			 
360c 7d					ld a,l 
360d			 
360d					; TODO write to display 
360d			 
360d 32 73 e5				ld (os_input), a 
3610 3e 00				ld a, 0 
3612 32 74 e5				ld (os_input+1), a 
3615					 
3615 3a 5e eb				ld a, (f_cursor_ptr) 
3618 11 73 e5				ld de, os_input 
361b cd 7c 09				call str_at_display 
361e			 
361e			 
361e 3a 3c eb				ld a,(cli_autodisplay) 
3621 fe 00				cp 0 
3623 28 03				jr z, .enoupdate 
3625 cd 8c 09						call update_display 
3628					.enoupdate: 
3628			 
3628 3a 5e eb				ld a, (f_cursor_ptr) 
362b 3c					inc a 
362c 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
362f			 
362f			 
362f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
362f cd 57 19			call macro_forth_dsp_pop 
3632				endm 
# End of macro FORTH_DSP_POP
3632			  
3632			 
3632					NEXTW 
3632 c3 11 1a			jp macro_next 
3635				endm 
# End of macro NEXTW
3635			.DOTH: 
3635				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3635 1c				db WORD_SYS_CORE+8             
3636 65 36			dw .DOTF            
3638 03				db 2 + 1 
3639 .. 00			db ".-",0              
363c				endm 
# End of macro CWHEAD
363c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
363c					; get value off TOS and display it 
363c					if DEBUG_FORTH_WORDS_KEY 
363c						DMARK "DTD" 
363c f5				push af  
363d 3a 51 36			ld a, (.dmark)  
3640 32 7a ee			ld (debug_mark),a  
3643 3a 52 36			ld a, (.dmark+1)  
3646 32 7b ee			ld (debug_mark+1),a  
3649 3a 53 36			ld a, (.dmark+2)  
364c 32 7c ee			ld (debug_mark+2),a  
364f 18 03			jr .pastdmark  
3651 ..			.dmark: db "DTD"  
3654 f1			.pastdmark: pop af  
3655			endm  
# End of macro DMARK
3655						CALLMONITOR 
3655 cd 86 12			call break_point_state  
3658				endm  
# End of macro CALLMONITOR
3658					endif 
3658 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
365a 3e 00			ld a, 0 
365c 32 3d eb			ld (cli_mvdot), a 
365f c3 bc 36			jp .dotgo 
3662				NEXTW 
3662 c3 11 1a			jp macro_next 
3665				endm 
# End of macro NEXTW
3665			.DOTF: 
3665				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3665 1c				db WORD_SYS_CORE+8             
3666 93 36			dw .DOT            
3668 03				db 2 + 1 
3669 .. 00			db ".>",0              
366c				endm 
# End of macro CWHEAD
366c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
366c					; get value off TOS and display it 
366c			        ; TODO BUG adds extra spaces 
366c			        ; TODO BUG handle numerics? 
366c					if DEBUG_FORTH_WORDS_KEY 
366c						DMARK "DTC" 
366c f5				push af  
366d 3a 81 36			ld a, (.dmark)  
3670 32 7a ee			ld (debug_mark),a  
3673 3a 82 36			ld a, (.dmark+1)  
3676 32 7b ee			ld (debug_mark+1),a  
3679 3a 83 36			ld a, (.dmark+2)  
367c 32 7c ee			ld (debug_mark+2),a  
367f 18 03			jr .pastdmark  
3681 ..			.dmark: db "DTC"  
3684 f1			.pastdmark: pop af  
3685			endm  
# End of macro DMARK
3685						CALLMONITOR 
3685 cd 86 12			call break_point_state  
3688				endm  
# End of macro CALLMONITOR
3688					endif 
3688 3e 01			ld a, 1 
368a 32 3d eb			ld (cli_mvdot), a 
368d c3 bc 36			jp .dotgo 
3690				NEXTW 
3690 c3 11 1a			jp macro_next 
3693				endm 
# End of macro NEXTW
3693			 
3693			.DOT: 
3693				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3693 1c				db WORD_SYS_CORE+8             
3694 1f 37			dw .CLS            
3696 02				db 1 + 1 
3697 .. 00			db ".",0              
3699				endm 
# End of macro CWHEAD
3699			        ; | . ( u -- ) Display TOS | DONE 
3699					; get value off TOS and display it 
3699			 
3699					if DEBUG_FORTH_WORDS_KEY 
3699						DMARK "DOT" 
3699 f5				push af  
369a 3a ae 36			ld a, (.dmark)  
369d 32 7a ee			ld (debug_mark),a  
36a0 3a af 36			ld a, (.dmark+1)  
36a3 32 7b ee			ld (debug_mark+1),a  
36a6 3a b0 36			ld a, (.dmark+2)  
36a9 32 7c ee			ld (debug_mark+2),a  
36ac 18 03			jr .pastdmark  
36ae ..			.dmark: db "DOT"  
36b1 f1			.pastdmark: pop af  
36b2			endm  
# End of macro DMARK
36b2						CALLMONITOR 
36b2 cd 86 12			call break_point_state  
36b5				endm  
# End of macro CALLMONITOR
36b5					endif 
36b5 3e 00			ld a, 0 
36b7 32 3d eb			ld (cli_mvdot), a 
36ba 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
36bc				 
36bc			 
36bc			.dotgo: 
36bc			 
36bc			; move up type to on stack for parserv5 
36bc					FORTH_DSP 
36bc cd a0 18			call macro_forth_dsp 
36bf				endm 
# End of macro FORTH_DSP
36bf				;FORTH_DSP_VALUE  
36bf			 
36bf			if DEBUG_FORTH_DOT 
36bf				DMARK "DOT" 
36bf				CALLMONITOR 
36bf			endif	 
36bf			;		.print: 
36bf			 
36bf 7e				ld a,(hl)  ; work out what type of value is on the TOS 
36c0 23				inc hl   ; position to the actual value 
36c1 fe 01			cp DS_TYPE_STR 
36c3 20 06			jr nz, .dotnum1  
36c5			 
36c5			; display string 
36c5				FORTH_DSP_VALUE  
36c5 cd a4 18			call macro_forth_dsp_value 
36c8				endm 
# End of macro FORTH_DSP_VALUE
36c8 eb				ex de,hl 
36c9 18 11			jr .dotwrite 
36cb			 
36cb			.dotnum1: 
36cb fe 02			cp DS_TYPE_INUM 
36cd 20 0c			jr nz, .dotflot 
36cf			 
36cf			 
36cf			; display number 
36cf			 
36cf			;	push hl 
36cf			;	call clear_display 
36cf			;	pop hl 
36cf			 
36cf 5e				ld e, (hl) 
36d0 23				inc hl 
36d1 56				ld d, (hl) 
36d2 21 75 e3			ld hl, scratch 
36d5			if DEBUG_FORTH_DOT 
36d5				DMARK "DT1" 
36d5				CALLMONITOR 
36d5			endif	 
36d5			 
36d5 cd cf 0e			call uitoa_16 
36d8 eb				ex de,hl 
36d9			 
36d9			if DEBUG_FORTH_DOT 
36d9				DMARK "DT2" 
36d9				CALLMONITOR 
36d9			endif	 
36d9			 
36d9			;	ld de, os_word_scratch 
36d9 18 01			jr .dotwrite 
36db			 
36db 00			.dotflot:   nop 
36dc			; TODO print floating point number 
36dc			 
36dc			.dotwrite:		 
36dc			 
36dc					; if c is set then set all '-' to spaces 
36dc					; need to also take into account .>  
36dc			 
36dc 3e 01				ld a, 1 
36de b9					cp c 
36df 20 13				jr nz, .nodashswap 
36e1			 
36e1					; DE has the string to write, working with HL 
36e1			 
36e1 06 ff				ld b, 255 
36e3 d5					push de 
36e4 e1					pop hl 
36e5			 
36e5			if DEBUG_FORTH_DOT 
36e5				DMARK "DT-" 
36e5				CALLMONITOR 
36e5			endif	 
36e5 7e			.dashscan:	ld a, (hl) 
36e6 fe 00				cp 0 
36e8 28 0a				jr z, .nodashswap 
36ea fe 2d				cp '-' 
36ec 20 03				jr nz, .dashskip 
36ee 3e 20				ld a, ' ' 
36f0 77					ld (hl), a 
36f1 23			.dashskip:	inc hl 
36f2			if DEBUG_FORTH_DOT 
36f2				DMARK "D-2" 
36f2				CALLMONITOR 
36f2			endif	 
36f2 10 f1				djnz .dashscan 
36f4			 
36f4			if DEBUG_FORTH_DOT 
36f4				DMARK "D-1" 
36f4				CALLMONITOR 
36f4			endif	 
36f4			 
36f4			.nodashswap: 
36f4			 
36f4 e5					push hl   ; save string start in case we need to advance print 
36f5			 
36f5 3a 5e eb				ld a, (f_cursor_ptr) 
36f8 cd 7c 09				call str_at_display 
36fb 3a 3c eb				ld a,(cli_autodisplay) 
36fe fe 00				cp 0 
3700 28 03				jr z, .noupdate 
3702 cd 8c 09						call update_display 
3705					.noupdate: 
3705			 
3705			 
3705					; see if we need to advance the print position 
3705			 
3705 e1					pop hl   ; get back string 
3706			 
3706 3a 3d eb				ld a, (cli_mvdot) 
3709			if DEBUG_FORTH_DOT 
3709					ld e,a 
3709				DMARK "D>1" 
3709				CALLMONITOR 
3709			endif	 
3709 fe 00				cp 0 
370b 28 0c				jr z, .noadv 
370d					; yes, lets advance the print position 
370d 3e 00				ld a, 0 
370f cd 2b 0f				call strlent 
3712 3a 5e eb				ld a, (f_cursor_ptr) 
3715 85					add a,l 
3716					;call addatohl 
3716					;ld a, l 
3716 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
3719			 
3719			if DEBUG_FORTH_DOT 
3719				DMARK "D->" 
3719				CALLMONITOR 
3719			endif	 
3719			 
3719			.noadv:	 
3719			 
3719					if DEBUG_FORTH_DOT_WAIT 
3719							call next_page_prompt 
3719					endif	 
3719			; TODO this pop off the stack causes a crash. i dont know why 
3719			 
3719			 
3719			if DEBUG_FORTH_DOT 
3719				DMARK "DTh" 
3719				CALLMONITOR 
3719			endif	 
3719			 
3719					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3719 cd 57 19			call macro_forth_dsp_pop 
371c				endm 
# End of macro FORTH_DSP_POP
371c			 
371c			if DEBUG_FORTH_DOT 
371c				DMARK "DTi" 
371c				CALLMONITOR 
371c			endif	 
371c			 
371c			 
371c					NEXTW 
371c c3 11 1a			jp macro_next 
371f				endm 
# End of macro NEXTW
371f			 
371f			.CLS: 
371f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
371f 35				db WORD_SYS_CORE+33             
3720 4c 37			dw .DRAW            
3722 04				db 3 + 1 
3723 .. 00			db "CLS",0              
3727				endm 
# End of macro CWHEAD
3727			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3727					if DEBUG_FORTH_WORDS_KEY 
3727						DMARK "CLS" 
3727 f5				push af  
3728 3a 3c 37			ld a, (.dmark)  
372b 32 7a ee			ld (debug_mark),a  
372e 3a 3d 37			ld a, (.dmark+1)  
3731 32 7b ee			ld (debug_mark+1),a  
3734 3a 3e 37			ld a, (.dmark+2)  
3737 32 7c ee			ld (debug_mark+2),a  
373a 18 03			jr .pastdmark  
373c ..			.dmark: db "CLS"  
373f f1			.pastdmark: pop af  
3740			endm  
# End of macro DMARK
3740						CALLMONITOR 
3740 cd 86 12			call break_point_state  
3743				endm  
# End of macro CALLMONITOR
3743					endif 
3743 cd 69 09				call clear_display 
3746 c3 5a 38				jp .home		; and home cursor 
3749					NEXTW 
3749 c3 11 1a			jp macro_next 
374c				endm 
# End of macro NEXTW
374c			 
374c			.DRAW: 
374c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
374c 36				db WORD_SYS_CORE+34             
374d 77 37			dw .DUMP            
374f 05				db 4 + 1 
3750 .. 00			db "DRAW",0              
3755				endm 
# End of macro CWHEAD
3755			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3755					if DEBUG_FORTH_WORDS_KEY 
3755						DMARK "DRW" 
3755 f5				push af  
3756 3a 6a 37			ld a, (.dmark)  
3759 32 7a ee			ld (debug_mark),a  
375c 3a 6b 37			ld a, (.dmark+1)  
375f 32 7b ee			ld (debug_mark+1),a  
3762 3a 6c 37			ld a, (.dmark+2)  
3765 32 7c ee			ld (debug_mark+2),a  
3768 18 03			jr .pastdmark  
376a ..			.dmark: db "DRW"  
376d f1			.pastdmark: pop af  
376e			endm  
# End of macro DMARK
376e						CALLMONITOR 
376e cd 86 12			call break_point_state  
3771				endm  
# End of macro CALLMONITOR
3771					endif 
3771 cd 8c 09				call update_display 
3774					NEXTW 
3774 c3 11 1a			jp macro_next 
3777				endm 
# End of macro NEXTW
3777			 
3777			.DUMP: 
3777				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3777 37				db WORD_SYS_CORE+35             
3778 af 37			dw .CDUMP            
377a 05				db 4 + 1 
377b .. 00			db "DUMP",0              
3780				endm 
# End of macro CWHEAD
3780			; | DUMP ( x -- ) With address x display dump   | DONE 
3780			; TODO pop address to use off of the stack 
3780					if DEBUG_FORTH_WORDS_KEY 
3780						DMARK "DUM" 
3780 f5				push af  
3781 3a 95 37			ld a, (.dmark)  
3784 32 7a ee			ld (debug_mark),a  
3787 3a 96 37			ld a, (.dmark+1)  
378a 32 7b ee			ld (debug_mark+1),a  
378d 3a 97 37			ld a, (.dmark+2)  
3790 32 7c ee			ld (debug_mark+2),a  
3793 18 03			jr .pastdmark  
3795 ..			.dmark: db "DUM"  
3798 f1			.pastdmark: pop af  
3799			endm  
# End of macro DMARK
3799						CALLMONITOR 
3799 cd 86 12			call break_point_state  
379c				endm  
# End of macro CALLMONITOR
379c					endif 
379c cd 69 09				call clear_display 
379f			 
379f					; get address 
379f			 
379f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379f cd bb 18			call macro_dsp_valuehl 
37a2				endm 
# End of macro FORTH_DSP_VALUEHL
37a2				 
37a2					; save it for cdump 
37a2			 
37a2 22 98 e6				ld (os_cur_ptr),hl 
37a5			 
37a5					; destroy value TOS 
37a5			 
37a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a5 cd 57 19			call macro_forth_dsp_pop 
37a8				endm 
# End of macro FORTH_DSP_POP
37a8			 
37a8 cd a0 16				call dumpcont	; skip old style of param parsing	 
37ab c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
37ac					NEXTW 
37ac c3 11 1a			jp macro_next 
37af				endm 
# End of macro NEXTW
37af			.CDUMP: 
37af				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
37af 38				db WORD_SYS_CORE+36             
37b0 df 37			dw .DAT            
37b2 06				db 5 + 1 
37b3 .. 00			db "CDUMP",0              
37b9				endm 
# End of macro CWHEAD
37b9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
37b9					if DEBUG_FORTH_WORDS_KEY 
37b9						DMARK "CDP" 
37b9 f5				push af  
37ba 3a ce 37			ld a, (.dmark)  
37bd 32 7a ee			ld (debug_mark),a  
37c0 3a cf 37			ld a, (.dmark+1)  
37c3 32 7b ee			ld (debug_mark+1),a  
37c6 3a d0 37			ld a, (.dmark+2)  
37c9 32 7c ee			ld (debug_mark+2),a  
37cc 18 03			jr .pastdmark  
37ce ..			.dmark: db "CDP"  
37d1 f1			.pastdmark: pop af  
37d2			endm  
# End of macro DMARK
37d2						CALLMONITOR 
37d2 cd 86 12			call break_point_state  
37d5				endm  
# End of macro CALLMONITOR
37d5					endif 
37d5 cd 69 09				call clear_display 
37d8 cd a0 16				call dumpcont	 
37db c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
37dc					NEXTW 
37dc c3 11 1a			jp macro_next 
37df				endm 
# End of macro NEXTW
37df			 
37df			 
37df			 
37df			 
37df			.DAT: 
37df				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
37df 3d				db WORD_SYS_CORE+41             
37e0 35 38			dw .HOME            
37e2 03				db 2 + 1 
37e3 .. 00			db "AT",0              
37e6				endm 
# End of macro CWHEAD
37e6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
37e6					if DEBUG_FORTH_WORDS_KEY 
37e6						DMARK "AT." 
37e6 f5				push af  
37e7 3a fb 37			ld a, (.dmark)  
37ea 32 7a ee			ld (debug_mark),a  
37ed 3a fc 37			ld a, (.dmark+1)  
37f0 32 7b ee			ld (debug_mark+1),a  
37f3 3a fd 37			ld a, (.dmark+2)  
37f6 32 7c ee			ld (debug_mark+2),a  
37f9 18 03			jr .pastdmark  
37fb ..			.dmark: db "AT."  
37fe f1			.pastdmark: pop af  
37ff			endm  
# End of macro DMARK
37ff						CALLMONITOR 
37ff cd 86 12			call break_point_state  
3802				endm  
# End of macro CALLMONITOR
3802					endif 
3802					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3802 cd bb 18			call macro_dsp_valuehl 
3805				endm 
# End of macro FORTH_DSP_VALUEHL
3805			 
3805			 
3805					; TODO save cursor row 
3805 7d					ld a,l 
3806 fe 02				cp 2 
3808 20 04				jr nz, .crow3 
380a 3e 28				ld a, display_row_2 
380c 18 12				jr .ccol1 
380e fe 03		.crow3:		cp 3 
3810 20 04				jr nz, .crow4 
3812 3e 50				ld a, display_row_3 
3814 18 0a				jr .ccol1 
3816 fe 04		.crow4:		cp 4 
3818 20 04				jr nz, .crow1 
381a 3e 78				ld a, display_row_4 
381c 18 02				jr .ccol1 
381e 3e 00		.crow1:		ld a,display_row_1 
3820 f5			.ccol1:		push af			; got row offset 
3821 6f					ld l,a 
3822 26 00				ld h,0 
3824					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3824 cd 57 19			call macro_forth_dsp_pop 
3827				endm 
# End of macro FORTH_DSP_POP
3827					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3827 cd bb 18			call macro_dsp_valuehl 
382a				endm 
# End of macro FORTH_DSP_VALUEHL
382a					; TODO save cursor col 
382a f1					pop af 
382b 85					add l		; add col offset 
382c 32 5e eb				ld (f_cursor_ptr), a 
382f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
382f cd 57 19			call macro_forth_dsp_pop 
3832				endm 
# End of macro FORTH_DSP_POP
3832			 
3832					; calculate  
3832			 
3832					NEXTW 
3832 c3 11 1a			jp macro_next 
3835				endm 
# End of macro NEXTW
3835			 
3835			 
3835			.HOME: 
3835				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3835 41				db WORD_SYS_CORE+45             
3836 62 38			dw .SPACE            
3838 05				db 4 + 1 
3839 .. 00			db "HOME",0              
383e				endm 
# End of macro CWHEAD
383e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
383e					if DEBUG_FORTH_WORDS_KEY 
383e						DMARK "HOM" 
383e f5				push af  
383f 3a 53 38			ld a, (.dmark)  
3842 32 7a ee			ld (debug_mark),a  
3845 3a 54 38			ld a, (.dmark+1)  
3848 32 7b ee			ld (debug_mark+1),a  
384b 3a 55 38			ld a, (.dmark+2)  
384e 32 7c ee			ld (debug_mark+2),a  
3851 18 03			jr .pastdmark  
3853 ..			.dmark: db "HOM"  
3856 f1			.pastdmark: pop af  
3857			endm  
# End of macro DMARK
3857						CALLMONITOR 
3857 cd 86 12			call break_point_state  
385a				endm  
# End of macro CALLMONITOR
385a					endif 
385a 3e 00		.home:		ld a, 0		; and home cursor 
385c 32 5e eb				ld (f_cursor_ptr), a 
385f					NEXTW 
385f c3 11 1a			jp macro_next 
3862				endm 
# End of macro NEXTW
3862			 
3862			 
3862			.SPACE: 
3862				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3862 46				db WORD_SYS_CORE+50             
3863 90 38			dw .SPACES            
3865 03				db 2 + 1 
3866 .. 00			db "BL",0              
3869				endm 
# End of macro CWHEAD
3869			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3869					if DEBUG_FORTH_WORDS_KEY 
3869						DMARK "BL." 
3869 f5				push af  
386a 3a 7e 38			ld a, (.dmark)  
386d 32 7a ee			ld (debug_mark),a  
3870 3a 7f 38			ld a, (.dmark+1)  
3873 32 7b ee			ld (debug_mark+1),a  
3876 3a 80 38			ld a, (.dmark+2)  
3879 32 7c ee			ld (debug_mark+2),a  
387c 18 03			jr .pastdmark  
387e ..			.dmark: db "BL."  
3881 f1			.pastdmark: pop af  
3882			endm  
# End of macro DMARK
3882						CALLMONITOR 
3882 cd 86 12			call break_point_state  
3885				endm  
# End of macro CALLMONITOR
3885					endif 
3885 21 8e 38				ld hl, .blstr 
3888 cd 32 18				call forth_push_str 
388b					 
388b				       NEXTW 
388b c3 11 1a			jp macro_next 
388e				endm 
# End of macro NEXTW
388e			 
388e .. 00		.blstr: db " ", 0 
3890			 
3890			.SPACES: 
3890				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3890 47				db WORD_SYS_CORE+51             
3891 2b 39			dw .SCROLL            
3893 07				db 6 + 1 
3894 .. 00			db "SPACES",0              
389b				endm 
# End of macro CWHEAD
389b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
389b					if DEBUG_FORTH_WORDS_KEY 
389b						DMARK "SPS" 
389b f5				push af  
389c 3a b0 38			ld a, (.dmark)  
389f 32 7a ee			ld (debug_mark),a  
38a2 3a b1 38			ld a, (.dmark+1)  
38a5 32 7b ee			ld (debug_mark+1),a  
38a8 3a b2 38			ld a, (.dmark+2)  
38ab 32 7c ee			ld (debug_mark+2),a  
38ae 18 03			jr .pastdmark  
38b0 ..			.dmark: db "SPS"  
38b3 f1			.pastdmark: pop af  
38b4			endm  
# End of macro DMARK
38b4						CALLMONITOR 
38b4 cd 86 12			call break_point_state  
38b7				endm  
# End of macro CALLMONITOR
38b7					endif 
38b7			 
38b7			 
38b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b7 cd bb 18			call macro_dsp_valuehl 
38ba				endm 
# End of macro FORTH_DSP_VALUEHL
38ba			 
38ba			;		push hl    ; u 
38ba					if DEBUG_FORTH_WORDS 
38ba						DMARK "SPA" 
38ba f5				push af  
38bb 3a cf 38			ld a, (.dmark)  
38be 32 7a ee			ld (debug_mark),a  
38c1 3a d0 38			ld a, (.dmark+1)  
38c4 32 7b ee			ld (debug_mark+1),a  
38c7 3a d1 38			ld a, (.dmark+2)  
38ca 32 7c ee			ld (debug_mark+2),a  
38cd 18 03			jr .pastdmark  
38cf ..			.dmark: db "SPA"  
38d2 f1			.pastdmark: pop af  
38d3			endm  
# End of macro DMARK
38d3						CALLMONITOR 
38d3 cd 86 12			call break_point_state  
38d6				endm  
# End of macro CALLMONITOR
38d6					endif 
38d6			 
38d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38d6 cd 57 19			call macro_forth_dsp_pop 
38d9				endm 
# End of macro FORTH_DSP_POP
38d9			;		pop hl 
38d9 4d					ld c, l 
38da 06 00				ld b, 0 
38dc 21 75 e3				ld hl, scratch  
38df			 
38df					if DEBUG_FORTH_WORDS 
38df						DMARK "SP2" 
38df f5				push af  
38e0 3a f4 38			ld a, (.dmark)  
38e3 32 7a ee			ld (debug_mark),a  
38e6 3a f5 38			ld a, (.dmark+1)  
38e9 32 7b ee			ld (debug_mark+1),a  
38ec 3a f6 38			ld a, (.dmark+2)  
38ef 32 7c ee			ld (debug_mark+2),a  
38f2 18 03			jr .pastdmark  
38f4 ..			.dmark: db "SP2"  
38f7 f1			.pastdmark: pop af  
38f8			endm  
# End of macro DMARK
38f8						CALLMONITOR 
38f8 cd 86 12			call break_point_state  
38fb				endm  
# End of macro CALLMONITOR
38fb					endif 
38fb 3e 20				ld a, ' ' 
38fd c5			.spaces1:	push bc 
38fe 77					ld (hl),a 
38ff 23					inc hl 
3900 c1					pop bc 
3901 10 fa				djnz .spaces1 
3903 3e 00				ld a,0 
3905 77					ld (hl),a 
3906 21 75 e3				ld hl, scratch 
3909					if DEBUG_FORTH_WORDS 
3909						DMARK "SP3" 
3909 f5				push af  
390a 3a 1e 39			ld a, (.dmark)  
390d 32 7a ee			ld (debug_mark),a  
3910 3a 1f 39			ld a, (.dmark+1)  
3913 32 7b ee			ld (debug_mark+1),a  
3916 3a 20 39			ld a, (.dmark+2)  
3919 32 7c ee			ld (debug_mark+2),a  
391c 18 03			jr .pastdmark  
391e ..			.dmark: db "SP3"  
3921 f1			.pastdmark: pop af  
3922			endm  
# End of macro DMARK
3922						CALLMONITOR 
3922 cd 86 12			call break_point_state  
3925				endm  
# End of macro CALLMONITOR
3925					endif 
3925 cd 68 18				call forth_apush 
3928			 
3928				       NEXTW 
3928 c3 11 1a			jp macro_next 
392b				endm 
# End of macro NEXTW
392b			 
392b			 
392b			 
392b			.SCROLL: 
392b				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
392b 53				db WORD_SYS_CORE+63             
392c 58 39			dw .ATQ            
392e 07				db 6 + 1 
392f .. 00			db "SCROLL",0              
3936				endm 
# End of macro CWHEAD
3936			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3936					if DEBUG_FORTH_WORDS_KEY 
3936						DMARK "SCR" 
3936 f5				push af  
3937 3a 4b 39			ld a, (.dmark)  
393a 32 7a ee			ld (debug_mark),a  
393d 3a 4c 39			ld a, (.dmark+1)  
3940 32 7b ee			ld (debug_mark+1),a  
3943 3a 4d 39			ld a, (.dmark+2)  
3946 32 7c ee			ld (debug_mark+2),a  
3949 18 03			jr .pastdmark  
394b ..			.dmark: db "SCR"  
394e f1			.pastdmark: pop af  
394f			endm  
# End of macro DMARK
394f						CALLMONITOR 
394f cd 86 12			call break_point_state  
3952				endm  
# End of macro CALLMONITOR
3952					endif 
3952			 
3952 cd 01 09			call scroll_up 
3955			;	call update_display 
3955			 
3955					NEXTW 
3955 c3 11 1a			jp macro_next 
3958				endm 
# End of macro NEXTW
3958			 
3958			 
3958			 
3958			;		; get dir 
3958			; 
3958			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3958			; 
3958			;		push hl 
3958			; 
3958			;		; destroy value TOS 
3958			; 
3958			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3958			; 
3958			;		; get count 
3958			; 
3958			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3958			; 
3958			;		push hl 
3958			; 
3958			;		; destroy value TOS 
3958			; 
3958			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3958			; 
3958			;		; one value on hl get other one back 
3958			; 
3958			;		pop bc    ; count 
3958			; 
3958			;		pop de   ; dir 
3958			; 
3958			; 
3958			;		ld b, c 
3958			; 
3958			;.scrolldir:     push bc 
3958			;		push de 
3958			; 
3958			;		ld a, 0 
3958			;		cp e 
3958			;		jr z, .scrollup  
3958			;		call scroll_down 
3958			;		jr .scrollnext 
3958			;.scrollup:	call scroll_up 
3958			; 
3958			;		 
3958			;.scrollnext: 
3958			;		pop de 
3958			;		pop bc 
3958			;		djnz .scrolldir 
3958			; 
3958			; 
3958			; 
3958			; 
3958			; 
3958			;		NEXTW 
3958			 
3958			 
3958			 
3958			 
3958			.ATQ: 
3958				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3958 62				db WORD_SYS_CORE+78             
3959 b6 39			dw .AUTODSP            
395b 04				db 3 + 1 
395c .. 00			db "AT@",0              
3960				endm 
# End of macro CWHEAD
3960			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3960					if DEBUG_FORTH_WORDS_KEY 
3960						DMARK "ATA" 
3960 f5				push af  
3961 3a 75 39			ld a, (.dmark)  
3964 32 7a ee			ld (debug_mark),a  
3967 3a 76 39			ld a, (.dmark+1)  
396a 32 7b ee			ld (debug_mark+1),a  
396d 3a 77 39			ld a, (.dmark+2)  
3970 32 7c ee			ld (debug_mark+2),a  
3973 18 03			jr .pastdmark  
3975 ..			.dmark: db "ATA"  
3978 f1			.pastdmark: pop af  
3979			endm  
# End of macro DMARK
3979						CALLMONITOR 
3979 cd 86 12			call break_point_state  
397c				endm  
# End of macro CALLMONITOR
397c					endif 
397c			 
397c			 
397c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
397c cd bb 18			call macro_dsp_valuehl 
397f				endm 
# End of macro FORTH_DSP_VALUEHL
397f			 
397f					; TODO save cursor row 
397f 7d					ld a,l 
3980 fe 02				cp 2 
3982 20 04				jr nz, .crow3aq 
3984 3e 28				ld a, display_row_2 
3986 18 12				jr .ccol1aq 
3988 fe 03		.crow3aq:		cp 3 
398a 20 04				jr nz, .crow4aq 
398c 3e 50				ld a, display_row_3 
398e 18 0a				jr .ccol1aq 
3990 fe 04		.crow4aq:		cp 4 
3992 20 04				jr nz, .crow1aq 
3994 3e 78				ld a, display_row_4 
3996 18 02				jr .ccol1aq 
3998 3e 00		.crow1aq:		ld a,display_row_1 
399a f5			.ccol1aq:		push af			; got row offset 
399b 6f					ld l,a 
399c 26 00				ld h,0 
399e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399e cd 57 19			call macro_forth_dsp_pop 
39a1				endm 
# End of macro FORTH_DSP_POP
39a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39a1 cd bb 18			call macro_dsp_valuehl 
39a4				endm 
# End of macro FORTH_DSP_VALUEHL
39a4					; TODO save cursor col 
39a4 f1					pop af 
39a5 85					add l		; add col offset 
39a6			 
39a6					; add current frame buffer address 
39a6 2a db eb				ld hl, (display_fb_active) 
39a9 cd c2 0a				call addatohl 
39ac			 
39ac			 
39ac			 
39ac			 
39ac					; get char frame buffer location offset in hl 
39ac			 
39ac 7e					ld a,(hl) 
39ad 26 00				ld h, 0 
39af 6f					ld l, a 
39b0			 
39b0 cd 20 18				call forth_push_numhl 
39b3			 
39b3			 
39b3					NEXTW 
39b3 c3 11 1a			jp macro_next 
39b6				endm 
# End of macro NEXTW
39b6			 
39b6			.AUTODSP: 
39b6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
39b6 63				db WORD_SYS_CORE+79             
39b7 cc 39			dw .MENU            
39b9 05				db 4 + 1 
39ba .. 00			db "ADSP",0              
39bf				endm 
# End of macro CWHEAD
39bf			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
39bf			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
39bf			 
39bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39bf cd bb 18			call macro_dsp_valuehl 
39c2				endm 
# End of macro FORTH_DSP_VALUEHL
39c2			 
39c2			;		push hl 
39c2			 
39c2					; destroy value TOS 
39c2			 
39c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c2 cd 57 19			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5			;		pop hl 
39c5			 
39c5 7d					ld a,l 
39c6 32 3c eb				ld (cli_autodisplay), a 
39c9				       NEXTW 
39c9 c3 11 1a			jp macro_next 
39cc				endm 
# End of macro NEXTW
39cc			 
39cc			.MENU: 
39cc				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
39cc 70				db WORD_SYS_CORE+92             
39cd d8 39			dw .ENDDISPLAY            
39cf 05				db 4 + 1 
39d0 .. 00			db "MENU",0              
39d5				endm 
# End of macro CWHEAD
39d5			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
39d5			 
39d5					; get the title address and save it 
39d5			 
39d5			;		FORTH_DSP_VALUEHL 
39d5			;		push hl 
39d5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d5			; 
39d5			;		; get number of items on the stack 
39d5			; 
39d5			;	 
39d5			;		FORTH_DSP_VALUEHL 
39d5			;		push hl 
39d5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d5			 
39d5			 
39d5			 
39d5			 
39d5				       NEXTW 
39d5 c3 11 1a			jp macro_next 
39d8				endm 
# End of macro NEXTW
39d8			 
39d8			 
39d8			.ENDDISPLAY: 
39d8			 
39d8			; eof 
# End of file forth_words_display.asm
39d8			include "forth_words_str.asm" 
39d8			 
39d8			; | ## String Words 
39d8			 
39d8			.PTR:   
39d8			 
39d8				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
39d8 48				db WORD_SYS_CORE+52             
39d9 05 3a			dw .STYPE            
39db 04				db 3 + 1 
39dc .. 00			db "PTR",0              
39e0				endm 
# End of macro CWHEAD
39e0			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
39e0			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
39e0			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
39e0			 
39e0					if DEBUG_FORTH_WORDS_KEY 
39e0						DMARK "PTR" 
39e0 f5				push af  
39e1 3a f5 39			ld a, (.dmark)  
39e4 32 7a ee			ld (debug_mark),a  
39e7 3a f6 39			ld a, (.dmark+1)  
39ea 32 7b ee			ld (debug_mark+1),a  
39ed 3a f7 39			ld a, (.dmark+2)  
39f0 32 7c ee			ld (debug_mark+2),a  
39f3 18 03			jr .pastdmark  
39f5 ..			.dmark: db "PTR"  
39f8 f1			.pastdmark: pop af  
39f9			endm  
# End of macro DMARK
39f9						CALLMONITOR 
39f9 cd 86 12			call break_point_state  
39fc				endm  
# End of macro CALLMONITOR
39fc					endif 
39fc					FORTH_DSP_VALUEHL 
39fc cd bb 18			call macro_dsp_valuehl 
39ff				endm 
# End of macro FORTH_DSP_VALUEHL
39ff cd 20 18				call forth_push_numhl 
3a02			 
3a02			 
3a02					NEXTW 
3a02 c3 11 1a			jp macro_next 
3a05				endm 
# End of macro NEXTW
3a05			.STYPE: 
3a05				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3a05 48				db WORD_SYS_CORE+52             
3a06 54 3a			dw .UPPER            
3a08 06				db 5 + 1 
3a09 .. 00			db "STYPE",0              
3a0f				endm 
# End of macro CWHEAD
3a0f			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3a0f					if DEBUG_FORTH_WORDS_KEY 
3a0f						DMARK "STY" 
3a0f f5				push af  
3a10 3a 24 3a			ld a, (.dmark)  
3a13 32 7a ee			ld (debug_mark),a  
3a16 3a 25 3a			ld a, (.dmark+1)  
3a19 32 7b ee			ld (debug_mark+1),a  
3a1c 3a 26 3a			ld a, (.dmark+2)  
3a1f 32 7c ee			ld (debug_mark+2),a  
3a22 18 03			jr .pastdmark  
3a24 ..			.dmark: db "STY"  
3a27 f1			.pastdmark: pop af  
3a28			endm  
# End of macro DMARK
3a28						CALLMONITOR 
3a28 cd 86 12			call break_point_state  
3a2b				endm  
# End of macro CALLMONITOR
3a2b					endif 
3a2b					FORTH_DSP 
3a2b cd a0 18			call macro_forth_dsp 
3a2e				endm 
# End of macro FORTH_DSP
3a2e					;v5 FORTH_DSP_VALUE 
3a2e			 
3a2e 7e					ld a, (hl) 
3a2f			 
3a2f f5					push af 
3a30			 
3a30			; Dont destroy TOS		FORTH_DSP_POP 
3a30			 
3a30 f1					pop af 
3a31			 
3a31 fe 01				cp DS_TYPE_STR 
3a33 28 09				jr z, .typestr 
3a35			 
3a35 fe 02				cp DS_TYPE_INUM 
3a37 28 0a				jr z, .typeinum 
3a39			 
3a39 21 52 3a				ld hl, .tna 
3a3c 18 0a				jr .tpush 
3a3e			 
3a3e 21 4e 3a		.typestr:	ld hl, .tstr 
3a41 18 05				jr .tpush 
3a43 21 50 3a		.typeinum:	ld hl, .tinum 
3a46 18 00				jr .tpush 
3a48			 
3a48			.tpush: 
3a48			 
3a48 cd 32 18				call forth_push_str 
3a4b			 
3a4b					NEXTW 
3a4b c3 11 1a			jp macro_next 
3a4e				endm 
# End of macro NEXTW
3a4e .. 00		.tstr:	db "s",0 
3a50 .. 00		.tinum:  db "i",0 
3a52 .. 00		.tna:   db "?", 0 
3a54			 
3a54			 
3a54			.UPPER: 
3a54				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3a54 48				db WORD_SYS_CORE+52             
3a55 8f 3a			dw .LOWER            
3a57 06				db 5 + 1 
3a58 .. 00			db "UPPER",0              
3a5e				endm 
# End of macro CWHEAD
3a5e			; | UPPER ( s -- s ) Upper case string s  | DONE 
3a5e					if DEBUG_FORTH_WORDS_KEY 
3a5e						DMARK "UPR" 
3a5e f5				push af  
3a5f 3a 73 3a			ld a, (.dmark)  
3a62 32 7a ee			ld (debug_mark),a  
3a65 3a 74 3a			ld a, (.dmark+1)  
3a68 32 7b ee			ld (debug_mark+1),a  
3a6b 3a 75 3a			ld a, (.dmark+2)  
3a6e 32 7c ee			ld (debug_mark+2),a  
3a71 18 03			jr .pastdmark  
3a73 ..			.dmark: db "UPR"  
3a76 f1			.pastdmark: pop af  
3a77			endm  
# End of macro DMARK
3a77						CALLMONITOR 
3a77 cd 86 12			call break_point_state  
3a7a				endm  
# End of macro CALLMONITOR
3a7a					endif 
3a7a			 
3a7a					FORTH_DSP 
3a7a cd a0 18			call macro_forth_dsp 
3a7d				endm 
# End of macro FORTH_DSP
3a7d					 
3a7d			; TODO check is string type 
3a7d			 
3a7d					FORTH_DSP_VALUEHL 
3a7d cd bb 18			call macro_dsp_valuehl 
3a80				endm 
# End of macro FORTH_DSP_VALUEHL
3a80			; get pointer to string in hl 
3a80			 
3a80 7e			.toup:		ld a, (hl) 
3a81 fe 00				cp 0 
3a83 28 07				jr z, .toupdone 
3a85			 
3a85 cd 2f 0e				call to_upper 
3a88			 
3a88 77					ld (hl), a 
3a89 23					inc hl 
3a8a 18 f4				jr .toup 
3a8c			 
3a8c					 
3a8c			 
3a8c			 
3a8c			; for each char convert to upper 
3a8c					 
3a8c			.toupdone: 
3a8c			 
3a8c			 
3a8c					NEXTW 
3a8c c3 11 1a			jp macro_next 
3a8f				endm 
# End of macro NEXTW
3a8f			.LOWER: 
3a8f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3a8f 48				db WORD_SYS_CORE+52             
3a90 ca 3a			dw .TCASE            
3a92 06				db 5 + 1 
3a93 .. 00			db "LOWER",0              
3a99				endm 
# End of macro CWHEAD
3a99			; | LOWER ( s -- s ) Lower case string s  | DONE 
3a99					if DEBUG_FORTH_WORDS_KEY 
3a99						DMARK "LWR" 
3a99 f5				push af  
3a9a 3a ae 3a			ld a, (.dmark)  
3a9d 32 7a ee			ld (debug_mark),a  
3aa0 3a af 3a			ld a, (.dmark+1)  
3aa3 32 7b ee			ld (debug_mark+1),a  
3aa6 3a b0 3a			ld a, (.dmark+2)  
3aa9 32 7c ee			ld (debug_mark+2),a  
3aac 18 03			jr .pastdmark  
3aae ..			.dmark: db "LWR"  
3ab1 f1			.pastdmark: pop af  
3ab2			endm  
# End of macro DMARK
3ab2						CALLMONITOR 
3ab2 cd 86 12			call break_point_state  
3ab5				endm  
# End of macro CALLMONITOR
3ab5					endif 
3ab5			 
3ab5					FORTH_DSP 
3ab5 cd a0 18			call macro_forth_dsp 
3ab8				endm 
# End of macro FORTH_DSP
3ab8					 
3ab8			; TODO check is string type 
3ab8			 
3ab8					FORTH_DSP_VALUEHL 
3ab8 cd bb 18			call macro_dsp_valuehl 
3abb				endm 
# End of macro FORTH_DSP_VALUEHL
3abb			; get pointer to string in hl 
3abb			 
3abb 7e			.tolow:		ld a, (hl) 
3abc fe 00				cp 0 
3abe 28 07				jr z, .tolowdone 
3ac0			 
3ac0 cd 38 0e				call to_lower 
3ac3			 
3ac3 77					ld (hl), a 
3ac4 23					inc hl 
3ac5 18 f4				jr .tolow 
3ac7			 
3ac7					 
3ac7			 
3ac7			 
3ac7			; for each char convert to low 
3ac7					 
3ac7			.tolowdone: 
3ac7					NEXTW 
3ac7 c3 11 1a			jp macro_next 
3aca				endm 
# End of macro NEXTW
3aca			.TCASE: 
3aca				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3aca 48				db WORD_SYS_CORE+52             
3acb 00 3c			dw .SUBSTR            
3acd 06				db 5 + 1 
3ace .. 00			db "TCASE",0              
3ad4				endm 
# End of macro CWHEAD
3ad4			; | TCASE ( s -- s ) Title case string s  | DONE 
3ad4					if DEBUG_FORTH_WORDS_KEY 
3ad4						DMARK "TCS" 
3ad4 f5				push af  
3ad5 3a e9 3a			ld a, (.dmark)  
3ad8 32 7a ee			ld (debug_mark),a  
3adb 3a ea 3a			ld a, (.dmark+1)  
3ade 32 7b ee			ld (debug_mark+1),a  
3ae1 3a eb 3a			ld a, (.dmark+2)  
3ae4 32 7c ee			ld (debug_mark+2),a  
3ae7 18 03			jr .pastdmark  
3ae9 ..			.dmark: db "TCS"  
3aec f1			.pastdmark: pop af  
3aed			endm  
# End of macro DMARK
3aed						CALLMONITOR 
3aed cd 86 12			call break_point_state  
3af0				endm  
# End of macro CALLMONITOR
3af0					endif 
3af0			 
3af0					FORTH_DSP 
3af0 cd a0 18			call macro_forth_dsp 
3af3				endm 
# End of macro FORTH_DSP
3af3					 
3af3			; TODO check is string type 
3af3			 
3af3					FORTH_DSP_VALUEHL 
3af3 cd bb 18			call macro_dsp_valuehl 
3af6				endm 
# End of macro FORTH_DSP_VALUEHL
3af6			; get pointer to string in hl 
3af6			 
3af6					if DEBUG_FORTH_WORDS 
3af6						DMARK "TC1" 
3af6 f5				push af  
3af7 3a 0b 3b			ld a, (.dmark)  
3afa 32 7a ee			ld (debug_mark),a  
3afd 3a 0c 3b			ld a, (.dmark+1)  
3b00 32 7b ee			ld (debug_mark+1),a  
3b03 3a 0d 3b			ld a, (.dmark+2)  
3b06 32 7c ee			ld (debug_mark+2),a  
3b09 18 03			jr .pastdmark  
3b0b ..			.dmark: db "TC1"  
3b0e f1			.pastdmark: pop af  
3b0f			endm  
# End of macro DMARK
3b0f						CALLMONITOR 
3b0f cd 86 12			call break_point_state  
3b12				endm  
# End of macro CALLMONITOR
3b12					endif 
3b12			 
3b12					; first time in turn to upper case first char 
3b12			 
3b12 7e					ld a, (hl) 
3b13 c3 9d 3b				jp .totsiptou 
3b16			 
3b16			 
3b16 7e			.tot:		ld a, (hl) 
3b17 fe 00				cp 0 
3b19 ca e1 3b				jp z, .totdone 
3b1c			 
3b1c					if DEBUG_FORTH_WORDS 
3b1c						DMARK "TC2" 
3b1c f5				push af  
3b1d 3a 31 3b			ld a, (.dmark)  
3b20 32 7a ee			ld (debug_mark),a  
3b23 3a 32 3b			ld a, (.dmark+1)  
3b26 32 7b ee			ld (debug_mark+1),a  
3b29 3a 33 3b			ld a, (.dmark+2)  
3b2c 32 7c ee			ld (debug_mark+2),a  
3b2f 18 03			jr .pastdmark  
3b31 ..			.dmark: db "TC2"  
3b34 f1			.pastdmark: pop af  
3b35			endm  
# End of macro DMARK
3b35						CALLMONITOR 
3b35 cd 86 12			call break_point_state  
3b38				endm  
# End of macro CALLMONITOR
3b38					endif 
3b38					; check to see if current char is a space 
3b38			 
3b38 fe 20				cp ' ' 
3b3a 28 21				jr z, .totsp 
3b3c cd 38 0e				call to_lower 
3b3f					if DEBUG_FORTH_WORDS 
3b3f						DMARK "TC3" 
3b3f f5				push af  
3b40 3a 54 3b			ld a, (.dmark)  
3b43 32 7a ee			ld (debug_mark),a  
3b46 3a 55 3b			ld a, (.dmark+1)  
3b49 32 7b ee			ld (debug_mark+1),a  
3b4c 3a 56 3b			ld a, (.dmark+2)  
3b4f 32 7c ee			ld (debug_mark+2),a  
3b52 18 03			jr .pastdmark  
3b54 ..			.dmark: db "TC3"  
3b57 f1			.pastdmark: pop af  
3b58			endm  
# End of macro DMARK
3b58						CALLMONITOR 
3b58 cd 86 12			call break_point_state  
3b5b				endm  
# End of macro CALLMONITOR
3b5b					endif 
3b5b 18 63				jr .totnxt 
3b5d			 
3b5d			.totsp:         ; on a space, find next char which should be upper 
3b5d			 
3b5d					if DEBUG_FORTH_WORDS 
3b5d						DMARK "TC4" 
3b5d f5				push af  
3b5e 3a 72 3b			ld a, (.dmark)  
3b61 32 7a ee			ld (debug_mark),a  
3b64 3a 73 3b			ld a, (.dmark+1)  
3b67 32 7b ee			ld (debug_mark+1),a  
3b6a 3a 74 3b			ld a, (.dmark+2)  
3b6d 32 7c ee			ld (debug_mark+2),a  
3b70 18 03			jr .pastdmark  
3b72 ..			.dmark: db "TC4"  
3b75 f1			.pastdmark: pop af  
3b76			endm  
# End of macro DMARK
3b76						CALLMONITOR 
3b76 cd 86 12			call break_point_state  
3b79				endm  
# End of macro CALLMONITOR
3b79					endif 
3b79					;; 
3b79			 
3b79 fe 20				cp ' ' 
3b7b 20 20				jr nz, .totsiptou 
3b7d 23					inc hl 
3b7e 7e					ld a, (hl) 
3b7f					if DEBUG_FORTH_WORDS 
3b7f						DMARK "TC5" 
3b7f f5				push af  
3b80 3a 94 3b			ld a, (.dmark)  
3b83 32 7a ee			ld (debug_mark),a  
3b86 3a 95 3b			ld a, (.dmark+1)  
3b89 32 7b ee			ld (debug_mark+1),a  
3b8c 3a 96 3b			ld a, (.dmark+2)  
3b8f 32 7c ee			ld (debug_mark+2),a  
3b92 18 03			jr .pastdmark  
3b94 ..			.dmark: db "TC5"  
3b97 f1			.pastdmark: pop af  
3b98			endm  
# End of macro DMARK
3b98						CALLMONITOR 
3b98 cd 86 12			call break_point_state  
3b9b				endm  
# End of macro CALLMONITOR
3b9b					endif 
3b9b 18 c0				jr .totsp 
3b9d fe 00		.totsiptou:    cp 0 
3b9f 28 40				jr z, .totdone 
3ba1					; not space and not zero term so upper case it 
3ba1 cd 2f 0e				call to_upper 
3ba4			 
3ba4					if DEBUG_FORTH_WORDS 
3ba4						DMARK "TC6" 
3ba4 f5				push af  
3ba5 3a b9 3b			ld a, (.dmark)  
3ba8 32 7a ee			ld (debug_mark),a  
3bab 3a ba 3b			ld a, (.dmark+1)  
3bae 32 7b ee			ld (debug_mark+1),a  
3bb1 3a bb 3b			ld a, (.dmark+2)  
3bb4 32 7c ee			ld (debug_mark+2),a  
3bb7 18 03			jr .pastdmark  
3bb9 ..			.dmark: db "TC6"  
3bbc f1			.pastdmark: pop af  
3bbd			endm  
# End of macro DMARK
3bbd						CALLMONITOR 
3bbd cd 86 12			call break_point_state  
3bc0				endm  
# End of macro CALLMONITOR
3bc0					endif 
3bc0			 
3bc0			 
3bc0			.totnxt: 
3bc0			 
3bc0 77					ld (hl), a 
3bc1 23					inc hl 
3bc2					if DEBUG_FORTH_WORDS 
3bc2						DMARK "TC7" 
3bc2 f5				push af  
3bc3 3a d7 3b			ld a, (.dmark)  
3bc6 32 7a ee			ld (debug_mark),a  
3bc9 3a d8 3b			ld a, (.dmark+1)  
3bcc 32 7b ee			ld (debug_mark+1),a  
3bcf 3a d9 3b			ld a, (.dmark+2)  
3bd2 32 7c ee			ld (debug_mark+2),a  
3bd5 18 03			jr .pastdmark  
3bd7 ..			.dmark: db "TC7"  
3bda f1			.pastdmark: pop af  
3bdb			endm  
# End of macro DMARK
3bdb						CALLMONITOR 
3bdb cd 86 12			call break_point_state  
3bde				endm  
# End of macro CALLMONITOR
3bde					endif 
3bde c3 16 3b				jp .tot 
3be1			 
3be1					 
3be1			 
3be1			 
3be1			; for each char convert to low 
3be1					 
3be1			.totdone: 
3be1					if DEBUG_FORTH_WORDS 
3be1						DMARK "TCd" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 7a ee			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 7b ee			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 7c ee			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "TCd"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa						CALLMONITOR 
3bfa cd 86 12			call break_point_state  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd					NEXTW 
3bfd c3 11 1a			jp macro_next 
3c00				endm 
# End of macro NEXTW
3c00			 
3c00			.SUBSTR: 
3c00				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3c00 48				db WORD_SYS_CORE+52             
3c01 5e 3c			dw .LEFT            
3c03 07				db 6 + 1 
3c04 .. 00			db "SUBSTR",0              
3c0b				endm 
# End of macro CWHEAD
3c0b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3c0b			 
3c0b					if DEBUG_FORTH_WORDS_KEY 
3c0b						DMARK "SST" 
3c0b f5				push af  
3c0c 3a 20 3c			ld a, (.dmark)  
3c0f 32 7a ee			ld (debug_mark),a  
3c12 3a 21 3c			ld a, (.dmark+1)  
3c15 32 7b ee			ld (debug_mark+1),a  
3c18 3a 22 3c			ld a, (.dmark+2)  
3c1b 32 7c ee			ld (debug_mark+2),a  
3c1e 18 03			jr .pastdmark  
3c20 ..			.dmark: db "SST"  
3c23 f1			.pastdmark: pop af  
3c24			endm  
# End of macro DMARK
3c24						CALLMONITOR 
3c24 cd 86 12			call break_point_state  
3c27				endm  
# End of macro CALLMONITOR
3c27					endif 
3c27			; TODO check string type 
3c27					FORTH_DSP_VALUEHL 
3c27 cd bb 18			call macro_dsp_valuehl 
3c2a				endm 
# End of macro FORTH_DSP_VALUEHL
3c2a			 
3c2a e5					push hl      ; string length 
3c2b			 
3c2b					FORTH_DSP_POP 
3c2b cd 57 19			call macro_forth_dsp_pop 
3c2e				endm 
# End of macro FORTH_DSP_POP
3c2e			 
3c2e					FORTH_DSP_VALUEHL 
3c2e cd bb 18			call macro_dsp_valuehl 
3c31				endm 
# End of macro FORTH_DSP_VALUEHL
3c31			 
3c31 e5					push hl     ; start char 
3c32			 
3c32					FORTH_DSP_POP 
3c32 cd 57 19			call macro_forth_dsp_pop 
3c35				endm 
# End of macro FORTH_DSP_POP
3c35			 
3c35			 
3c35					FORTH_DSP_VALUE 
3c35 cd a4 18			call macro_forth_dsp_value 
3c38				endm 
# End of macro FORTH_DSP_VALUE
3c38			 
3c38 d1					pop de    ; get start post offset 
3c39			 
3c39 19					add hl, de    ; starting offset 
3c3a			 
3c3a c1					pop bc 
3c3b c5					push bc      ; grab size of string 
3c3c			 
3c3c e5					push hl    ; save string start  
3c3d			 
3c3d 26 00				ld h, 0 
3c3f 69					ld l, c 
3c40 23					inc hl 
3c41 23					inc hl 
3c42			 
3c42 cd 89 0f				call malloc 
3c45				if DEBUG_FORTH_MALLOC_GUARD 
3c45 cc 74 42				call z,malloc_error 
3c48				endif 
3c48			 
3c48 eb					ex de, hl      ; save malloc area for string copy 
3c49 e1					pop hl    ; get back source 
3c4a c1					pop bc    ; get length of string back 
3c4b			 
3c4b d5					push de    ; save malloc area for after we push 
3c4c ed b0				ldir     ; copy substr 
3c4e			 
3c4e			 
3c4e eb					ex de, hl 
3c4f 3e 00				ld a, 0 
3c51 77					ld (hl), a   ; term substr 
3c52			 
3c52					 
3c52 e1					pop hl    ; get malloc so we can push it 
3c53 e5					push hl   ; save so we can free it afterwards 
3c54			 
3c54 cd 32 18				call forth_push_str 
3c57			 
3c57 e1					pop hl 
3c58 cd 53 10				call free 
3c5b			 
3c5b					 
3c5b					 
3c5b			 
3c5b			 
3c5b					NEXTW 
3c5b c3 11 1a			jp macro_next 
3c5e				endm 
# End of macro NEXTW
3c5e			 
3c5e			.LEFT: 
3c5e				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3c5e 48				db WORD_SYS_CORE+52             
3c5f 86 3c			dw .RIGHT            
3c61 05				db 4 + 1 
3c62 .. 00			db "LEFT",0              
3c67				endm 
# End of macro CWHEAD
3c67			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3c67					if DEBUG_FORTH_WORDS_KEY 
3c67						DMARK "LEF" 
3c67 f5				push af  
3c68 3a 7c 3c			ld a, (.dmark)  
3c6b 32 7a ee			ld (debug_mark),a  
3c6e 3a 7d 3c			ld a, (.dmark+1)  
3c71 32 7b ee			ld (debug_mark+1),a  
3c74 3a 7e 3c			ld a, (.dmark+2)  
3c77 32 7c ee			ld (debug_mark+2),a  
3c7a 18 03			jr .pastdmark  
3c7c ..			.dmark: db "LEF"  
3c7f f1			.pastdmark: pop af  
3c80			endm  
# End of macro DMARK
3c80						CALLMONITOR 
3c80 cd 86 12			call break_point_state  
3c83				endm  
# End of macro CALLMONITOR
3c83					endif 
3c83			 
3c83					NEXTW 
3c83 c3 11 1a			jp macro_next 
3c86				endm 
# End of macro NEXTW
3c86			.RIGHT: 
3c86				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3c86 48				db WORD_SYS_CORE+52             
3c87 af 3c			dw .STR2NUM            
3c89 06				db 5 + 1 
3c8a .. 00			db "RIGHT",0              
3c90				endm 
# End of macro CWHEAD
3c90			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3c90					if DEBUG_FORTH_WORDS_KEY 
3c90						DMARK "RIG" 
3c90 f5				push af  
3c91 3a a5 3c			ld a, (.dmark)  
3c94 32 7a ee			ld (debug_mark),a  
3c97 3a a6 3c			ld a, (.dmark+1)  
3c9a 32 7b ee			ld (debug_mark+1),a  
3c9d 3a a7 3c			ld a, (.dmark+2)  
3ca0 32 7c ee			ld (debug_mark+2),a  
3ca3 18 03			jr .pastdmark  
3ca5 ..			.dmark: db "RIG"  
3ca8 f1			.pastdmark: pop af  
3ca9			endm  
# End of macro DMARK
3ca9						CALLMONITOR 
3ca9 cd 86 12			call break_point_state  
3cac				endm  
# End of macro CALLMONITOR
3cac					endif 
3cac			 
3cac					NEXTW 
3cac c3 11 1a			jp macro_next 
3caf				endm 
# End of macro NEXTW
3caf			 
3caf			 
3caf			.STR2NUM: 
3caf				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3caf 48				db WORD_SYS_CORE+52             
3cb0 3b 3d			dw .NUM2STR            
3cb2 08				db 7 + 1 
3cb3 .. 00			db "STR2NUM",0              
3cbb				endm 
# End of macro CWHEAD
3cbb			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3cbb			 
3cbb			 
3cbb			; TODO STR type check to do 
3cbb					if DEBUG_FORTH_WORDS_KEY 
3cbb						DMARK "S2N" 
3cbb f5				push af  
3cbc 3a d0 3c			ld a, (.dmark)  
3cbf 32 7a ee			ld (debug_mark),a  
3cc2 3a d1 3c			ld a, (.dmark+1)  
3cc5 32 7b ee			ld (debug_mark+1),a  
3cc8 3a d2 3c			ld a, (.dmark+2)  
3ccb 32 7c ee			ld (debug_mark+2),a  
3cce 18 03			jr .pastdmark  
3cd0 ..			.dmark: db "S2N"  
3cd3 f1			.pastdmark: pop af  
3cd4			endm  
# End of macro DMARK
3cd4						CALLMONITOR 
3cd4 cd 86 12			call break_point_state  
3cd7				endm  
# End of macro CALLMONITOR
3cd7					endif 
3cd7			 
3cd7					;FORTH_DSP 
3cd7					FORTH_DSP_VALUE 
3cd7 cd a4 18			call macro_forth_dsp_value 
3cda				endm 
# End of macro FORTH_DSP_VALUE
3cda					;inc hl 
3cda			 
3cda eb					ex de, hl 
3cdb					if DEBUG_FORTH_WORDS 
3cdb						DMARK "S2a" 
3cdb f5				push af  
3cdc 3a f0 3c			ld a, (.dmark)  
3cdf 32 7a ee			ld (debug_mark),a  
3ce2 3a f1 3c			ld a, (.dmark+1)  
3ce5 32 7b ee			ld (debug_mark+1),a  
3ce8 3a f2 3c			ld a, (.dmark+2)  
3ceb 32 7c ee			ld (debug_mark+2),a  
3cee 18 03			jr .pastdmark  
3cf0 ..			.dmark: db "S2a"  
3cf3 f1			.pastdmark: pop af  
3cf4			endm  
# End of macro DMARK
3cf4						CALLMONITOR 
3cf4 cd 86 12			call break_point_state  
3cf7				endm  
# End of macro CALLMONITOR
3cf7					endif 
3cf7 cd b7 0e				call string_to_uint16 
3cfa			 
3cfa					if DEBUG_FORTH_WORDS 
3cfa						DMARK "S2b" 
3cfa f5				push af  
3cfb 3a 0f 3d			ld a, (.dmark)  
3cfe 32 7a ee			ld (debug_mark),a  
3d01 3a 10 3d			ld a, (.dmark+1)  
3d04 32 7b ee			ld (debug_mark+1),a  
3d07 3a 11 3d			ld a, (.dmark+2)  
3d0a 32 7c ee			ld (debug_mark+2),a  
3d0d 18 03			jr .pastdmark  
3d0f ..			.dmark: db "S2b"  
3d12 f1			.pastdmark: pop af  
3d13			endm  
# End of macro DMARK
3d13						CALLMONITOR 
3d13 cd 86 12			call break_point_state  
3d16				endm  
# End of macro CALLMONITOR
3d16					endif 
3d16			;		push hl 
3d16					FORTH_DSP_POP 
3d16 cd 57 19			call macro_forth_dsp_pop 
3d19				endm 
# End of macro FORTH_DSP_POP
3d19			;		pop hl 
3d19					 
3d19					if DEBUG_FORTH_WORDS 
3d19						DMARK "S2b" 
3d19 f5				push af  
3d1a 3a 2e 3d			ld a, (.dmark)  
3d1d 32 7a ee			ld (debug_mark),a  
3d20 3a 2f 3d			ld a, (.dmark+1)  
3d23 32 7b ee			ld (debug_mark+1),a  
3d26 3a 30 3d			ld a, (.dmark+2)  
3d29 32 7c ee			ld (debug_mark+2),a  
3d2c 18 03			jr .pastdmark  
3d2e ..			.dmark: db "S2b"  
3d31 f1			.pastdmark: pop af  
3d32			endm  
# End of macro DMARK
3d32						CALLMONITOR 
3d32 cd 86 12			call break_point_state  
3d35				endm  
# End of macro CALLMONITOR
3d35					endif 
3d35 cd 20 18				call forth_push_numhl	 
3d38			 
3d38				 
3d38				       NEXTW 
3d38 c3 11 1a			jp macro_next 
3d3b				endm 
# End of macro NEXTW
3d3b			.NUM2STR: 
3d3b				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3d3b 48				db WORD_SYS_CORE+52             
3d3c 4a 3d			dw .CONCAT            
3d3e 08				db 7 + 1 
3d3f .. 00			db "NUM2STR",0              
3d47				endm 
# End of macro CWHEAD
3d47			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3d47			 
3d47			;		; malloc a string to target 
3d47			;		ld hl, 10     ; TODO max string size should be fine 
3d47			;		call malloc 
3d47			;		push hl    ; save malloc location 
3d47			; 
3d47			; 
3d47			;; TODO check int type 
3d47			;		FORTH_DSP_VALUEHL 
3d47			;		ld a, l 
3d47			;		call DispAToASCII   
3d47			;;TODO need to chage above call to dump into string 
3d47			; 
3d47			; 
3d47			 
3d47				       NEXTW 
3d47 c3 11 1a			jp macro_next 
3d4a				endm 
# End of macro NEXTW
3d4a			 
3d4a			.CONCAT: 
3d4a				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3d4a 48				db WORD_SYS_CORE+52             
3d4b fd 3d			dw .FIND            
3d4d 07				db 6 + 1 
3d4e .. 00			db "CONCAT",0              
3d55				endm 
# End of macro CWHEAD
3d55			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3d55			 
3d55			; TODO check string type 
3d55			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3d55			 
3d55					if DEBUG_FORTH_WORDS_KEY 
3d55						DMARK "CON" 
3d55 f5				push af  
3d56 3a 6a 3d			ld a, (.dmark)  
3d59 32 7a ee			ld (debug_mark),a  
3d5c 3a 6b 3d			ld a, (.dmark+1)  
3d5f 32 7b ee			ld (debug_mark+1),a  
3d62 3a 6c 3d			ld a, (.dmark+2)  
3d65 32 7c ee			ld (debug_mark+2),a  
3d68 18 03			jr .pastdmark  
3d6a ..			.dmark: db "CON"  
3d6d f1			.pastdmark: pop af  
3d6e			endm  
# End of macro DMARK
3d6e						CALLMONITOR 
3d6e cd 86 12			call break_point_state  
3d71				endm  
# End of macro CALLMONITOR
3d71					endif 
3d71			 
3d71			 
3d71					FORTH_DSP_VALUE 
3d71 cd a4 18			call macro_forth_dsp_value 
3d74				endm 
# End of macro FORTH_DSP_VALUE
3d74 e5					push hl   ; s2 
3d75			 
3d75					FORTH_DSP_POP 
3d75 cd 57 19			call macro_forth_dsp_pop 
3d78				endm 
# End of macro FORTH_DSP_POP
3d78			 
3d78					FORTH_DSP_VALUE 
3d78 cd a4 18			call macro_forth_dsp_value 
3d7b				endm 
# End of macro FORTH_DSP_VALUE
3d7b			 
3d7b e5					push hl   ; s1 
3d7c			 
3d7c					FORTH_DSP_POP 
3d7c cd 57 19			call macro_forth_dsp_pop 
3d7f				endm 
# End of macro FORTH_DSP_POP
3d7f					 
3d7f			 
3d7f					; copy s1 
3d7f			 
3d7f				 
3d7f					; save ptr 
3d7f e1					pop hl  
3d80 e5					push hl 
3d81 3e 00				ld a, 0 
3d83 cd 2b 0f				call strlent 
3d86					;inc hl    ; zer0 
3d86 06 00				ld b, 0 
3d88 4d					ld c, l 
3d89 e1					pop hl		 
3d8a 11 75 e3				ld de, scratch	 
3d8d					if DEBUG_FORTH_WORDS 
3d8d						DMARK "CO1" 
3d8d f5				push af  
3d8e 3a a2 3d			ld a, (.dmark)  
3d91 32 7a ee			ld (debug_mark),a  
3d94 3a a3 3d			ld a, (.dmark+1)  
3d97 32 7b ee			ld (debug_mark+1),a  
3d9a 3a a4 3d			ld a, (.dmark+2)  
3d9d 32 7c ee			ld (debug_mark+2),a  
3da0 18 03			jr .pastdmark  
3da2 ..			.dmark: db "CO1"  
3da5 f1			.pastdmark: pop af  
3da6			endm  
# End of macro DMARK
3da6						CALLMONITOR 
3da6 cd 86 12			call break_point_state  
3da9				endm  
# End of macro CALLMONITOR
3da9					endif 
3da9 ed b0				ldir 
3dab			 
3dab e1					pop hl 
3dac e5					push hl 
3dad d5					push de 
3dae			 
3dae			 
3dae 3e 00				ld a, 0 
3db0 cd 2b 0f				call strlent 
3db3 23					inc hl    ; zer0 
3db4 23					inc hl 
3db5 06 00				ld b, 0 
3db7 4d					ld c, l 
3db8 d1					pop de 
3db9 e1					pop hl		 
3dba					if DEBUG_FORTH_WORDS 
3dba						DMARK "CO2" 
3dba f5				push af  
3dbb 3a cf 3d			ld a, (.dmark)  
3dbe 32 7a ee			ld (debug_mark),a  
3dc1 3a d0 3d			ld a, (.dmark+1)  
3dc4 32 7b ee			ld (debug_mark+1),a  
3dc7 3a d1 3d			ld a, (.dmark+2)  
3dca 32 7c ee			ld (debug_mark+2),a  
3dcd 18 03			jr .pastdmark  
3dcf ..			.dmark: db "CO2"  
3dd2 f1			.pastdmark: pop af  
3dd3			endm  
# End of macro DMARK
3dd3						CALLMONITOR 
3dd3 cd 86 12			call break_point_state  
3dd6				endm  
# End of macro CALLMONITOR
3dd6					endif 
3dd6 ed b0				ldir 
3dd8			 
3dd8			 
3dd8			 
3dd8 21 75 e3				ld hl, scratch 
3ddb					if DEBUG_FORTH_WORDS 
3ddb						DMARK "CO5" 
3ddb f5				push af  
3ddc 3a f0 3d			ld a, (.dmark)  
3ddf 32 7a ee			ld (debug_mark),a  
3de2 3a f1 3d			ld a, (.dmark+1)  
3de5 32 7b ee			ld (debug_mark+1),a  
3de8 3a f2 3d			ld a, (.dmark+2)  
3deb 32 7c ee			ld (debug_mark+2),a  
3dee 18 03			jr .pastdmark  
3df0 ..			.dmark: db "CO5"  
3df3 f1			.pastdmark: pop af  
3df4			endm  
# End of macro DMARK
3df4						CALLMONITOR 
3df4 cd 86 12			call break_point_state  
3df7				endm  
# End of macro CALLMONITOR
3df7					endif 
3df7			 
3df7 cd 32 18				call forth_push_str 
3dfa			 
3dfa			 
3dfa			 
3dfa			 
3dfa				       NEXTW 
3dfa c3 11 1a			jp macro_next 
3dfd				endm 
# End of macro NEXTW
3dfd			 
3dfd			 
3dfd			.FIND: 
3dfd				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3dfd 4b				db WORD_SYS_CORE+55             
3dfe bb 3e			dw .LEN            
3e00 05				db 4 + 1 
3e01 .. 00			db "FIND",0              
3e06				endm 
# End of macro CWHEAD
3e06			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3e06			 
3e06					if DEBUG_FORTH_WORDS_KEY 
3e06						DMARK "FND" 
3e06 f5				push af  
3e07 3a 1b 3e			ld a, (.dmark)  
3e0a 32 7a ee			ld (debug_mark),a  
3e0d 3a 1c 3e			ld a, (.dmark+1)  
3e10 32 7b ee			ld (debug_mark+1),a  
3e13 3a 1d 3e			ld a, (.dmark+2)  
3e16 32 7c ee			ld (debug_mark+2),a  
3e19 18 03			jr .pastdmark  
3e1b ..			.dmark: db "FND"  
3e1e f1			.pastdmark: pop af  
3e1f			endm  
# End of macro DMARK
3e1f						CALLMONITOR 
3e1f cd 86 12			call break_point_state  
3e22				endm  
# End of macro CALLMONITOR
3e22					endif 
3e22			 
3e22			; TODO check string type 
3e22					FORTH_DSP_VALUE 
3e22 cd a4 18			call macro_forth_dsp_value 
3e25				endm 
# End of macro FORTH_DSP_VALUE
3e25			 
3e25 e5					push hl    
3e26 7e					ld a,(hl)    ; char to find   
3e27			; TODO change char to substr 
3e27			 
3e27 f5					push af 
3e28					 
3e28			 
3e28			 
3e28					if DEBUG_FORTH_WORDS 
3e28						DMARK "FN1" 
3e28 f5				push af  
3e29 3a 3d 3e			ld a, (.dmark)  
3e2c 32 7a ee			ld (debug_mark),a  
3e2f 3a 3e 3e			ld a, (.dmark+1)  
3e32 32 7b ee			ld (debug_mark+1),a  
3e35 3a 3f 3e			ld a, (.dmark+2)  
3e38 32 7c ee			ld (debug_mark+2),a  
3e3b 18 03			jr .pastdmark  
3e3d ..			.dmark: db "FN1"  
3e40 f1			.pastdmark: pop af  
3e41			endm  
# End of macro DMARK
3e41						CALLMONITOR 
3e41 cd 86 12			call break_point_state  
3e44				endm  
# End of macro CALLMONITOR
3e44					endif 
3e44			 
3e44					FORTH_DSP_POP 
3e44 cd 57 19			call macro_forth_dsp_pop 
3e47				endm 
# End of macro FORTH_DSP_POP
3e47			 
3e47					; string to search 
3e47			 
3e47					FORTH_DSP_VALUE 
3e47 cd a4 18			call macro_forth_dsp_value 
3e4a				endm 
# End of macro FORTH_DSP_VALUE
3e4a			 
3e4a d1					pop de  ; d is char to find  
3e4b			 
3e4b					if DEBUG_FORTH_WORDS 
3e4b						DMARK "FN2" 
3e4b f5				push af  
3e4c 3a 60 3e			ld a, (.dmark)  
3e4f 32 7a ee			ld (debug_mark),a  
3e52 3a 61 3e			ld a, (.dmark+1)  
3e55 32 7b ee			ld (debug_mark+1),a  
3e58 3a 62 3e			ld a, (.dmark+2)  
3e5b 32 7c ee			ld (debug_mark+2),a  
3e5e 18 03			jr .pastdmark  
3e60 ..			.dmark: db "FN2"  
3e63 f1			.pastdmark: pop af  
3e64			endm  
# End of macro DMARK
3e64						CALLMONITOR 
3e64 cd 86 12			call break_point_state  
3e67				endm  
# End of macro CALLMONITOR
3e67					endif 
3e67					 
3e67 01 00 00				ld bc, 0 
3e6a 7e			.findchar:      ld a,(hl) 
3e6b fe 00				cp 0   		 
3e6d 28 27				jr z, .finddone     
3e6f ba					cp d 
3e70 28 20				jr z, .foundchar 
3e72 03					inc bc 
3e73 23					inc hl 
3e74					if DEBUG_FORTH_WORDS 
3e74						DMARK "FN3" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 7a ee			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 7b ee			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 7c ee			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "FN3"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd 86 12			call break_point_state  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90 18 d8				jr .findchar 
3e92			 
3e92			 
3e92 c5			.foundchar:	push bc 
3e93 e1					pop hl 
3e94 18 03				jr .findexit 
3e96			 
3e96			 
3e96							 
3e96			 
3e96			.finddone:     ; got to end of string with no find 
3e96 21 00 00				ld hl, 0 
3e99			.findexit: 
3e99			 
3e99					if DEBUG_FORTH_WORDS 
3e99						DMARK "FNd" 
3e99 f5				push af  
3e9a 3a ae 3e			ld a, (.dmark)  
3e9d 32 7a ee			ld (debug_mark),a  
3ea0 3a af 3e			ld a, (.dmark+1)  
3ea3 32 7b ee			ld (debug_mark+1),a  
3ea6 3a b0 3e			ld a, (.dmark+2)  
3ea9 32 7c ee			ld (debug_mark+2),a  
3eac 18 03			jr .pastdmark  
3eae ..			.dmark: db "FNd"  
3eb1 f1			.pastdmark: pop af  
3eb2			endm  
# End of macro DMARK
3eb2						CALLMONITOR 
3eb2 cd 86 12			call break_point_state  
3eb5				endm  
# End of macro CALLMONITOR
3eb5					endif 
3eb5 cd 20 18			call forth_push_numhl 
3eb8			 
3eb8				       NEXTW 
3eb8 c3 11 1a			jp macro_next 
3ebb				endm 
# End of macro NEXTW
3ebb			 
3ebb			.LEN: 
3ebb				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
3ebb 4c				db WORD_SYS_CORE+56             
3ebc f0 3e			dw .CHAR            
3ebe 06				db 5 + 1 
3ebf .. 00			db "COUNT",0              
3ec5				endm 
# End of macro CWHEAD
3ec5			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
3ec5			 
3ec5					if DEBUG_FORTH_WORDS_KEY 
3ec5						DMARK "CNT" 
3ec5 f5				push af  
3ec6 3a da 3e			ld a, (.dmark)  
3ec9 32 7a ee			ld (debug_mark),a  
3ecc 3a db 3e			ld a, (.dmark+1)  
3ecf 32 7b ee			ld (debug_mark+1),a  
3ed2 3a dc 3e			ld a, (.dmark+2)  
3ed5 32 7c ee			ld (debug_mark+2),a  
3ed8 18 03			jr .pastdmark  
3eda ..			.dmark: db "CNT"  
3edd f1			.pastdmark: pop af  
3ede			endm  
# End of macro DMARK
3ede						CALLMONITOR 
3ede cd 86 12			call break_point_state  
3ee1				endm  
# End of macro CALLMONITOR
3ee1					endif 
3ee1			; TODO check string type 
3ee1					FORTH_DSP 
3ee1 cd a0 18			call macro_forth_dsp 
3ee4				endm 
# End of macro FORTH_DSP
3ee4					;v5FORTH_DSP_VALUE 
3ee4			 
3ee4 23					inc hl 
3ee5			 
3ee5 3e 00				ld a, 0 
3ee7 cd 2b 0f				call strlent 
3eea			 
3eea cd 20 18				call forth_push_numhl 
3eed			 
3eed			 
3eed			 
3eed				       NEXTW 
3eed c3 11 1a			jp macro_next 
3ef0				endm 
# End of macro NEXTW
3ef0			.CHAR: 
3ef0				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
3ef0 4d				db WORD_SYS_CORE+57             
3ef1 26 3f			dw .ENDSTR            
3ef3 05				db 4 + 1 
3ef4 .. 00			db "CHAR",0              
3ef9				endm 
# End of macro CWHEAD
3ef9			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
3ef9					if DEBUG_FORTH_WORDS_KEY 
3ef9						DMARK "CHR" 
3ef9 f5				push af  
3efa 3a 0e 3f			ld a, (.dmark)  
3efd 32 7a ee			ld (debug_mark),a  
3f00 3a 0f 3f			ld a, (.dmark+1)  
3f03 32 7b ee			ld (debug_mark+1),a  
3f06 3a 10 3f			ld a, (.dmark+2)  
3f09 32 7c ee			ld (debug_mark+2),a  
3f0c 18 03			jr .pastdmark  
3f0e ..			.dmark: db "CHR"  
3f11 f1			.pastdmark: pop af  
3f12			endm  
# End of macro DMARK
3f12						CALLMONITOR 
3f12 cd 86 12			call break_point_state  
3f15				endm  
# End of macro CALLMONITOR
3f15					endif 
3f15					FORTH_DSP 
3f15 cd a0 18			call macro_forth_dsp 
3f18				endm 
# End of macro FORTH_DSP
3f18					;v5 FORTH_DSP_VALUE 
3f18 23					inc hl      ; now at start of numeric as string 
3f19			 
3f19			;		push hl 
3f19			 
3f19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f19 cd 57 19			call macro_forth_dsp_pop 
3f1c				endm 
# End of macro FORTH_DSP_POP
3f1c			 
3f1c			;		pop hl 
3f1c			 
3f1c					; push the content of a onto the stack as a value 
3f1c			 
3f1c 7e					ld a,(hl)   ; get char 
3f1d 26 00				ld h,0 
3f1f 6f					ld l,a 
3f20 cd 20 18				call forth_push_numhl 
3f23			 
3f23				       NEXTW 
3f23 c3 11 1a			jp macro_next 
3f26				endm 
# End of macro NEXTW
3f26			 
3f26			 
3f26			 
3f26			 
3f26			.ENDSTR: 
3f26			; eof 
3f26			 
# End of file forth_words_str.asm
3f26			include "forth_words_key.asm" 
3f26			 
3f26			; | ## Keyboard Words 
3f26			 
3f26			.KEY: 
3f26				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
3f26 3e				db WORD_SYS_CORE+42             
3f27 56 3f			dw .WAITK            
3f29 04				db 3 + 1 
3f2a .. 00			db "KEY",0              
3f2e				endm 
# End of macro CWHEAD
3f2e			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
3f2e			 
3f2e					if DEBUG_FORTH_WORDS_KEY 
3f2e						DMARK "KEY" 
3f2e f5				push af  
3f2f 3a 43 3f			ld a, (.dmark)  
3f32 32 7a ee			ld (debug_mark),a  
3f35 3a 44 3f			ld a, (.dmark+1)  
3f38 32 7b ee			ld (debug_mark+1),a  
3f3b 3a 45 3f			ld a, (.dmark+2)  
3f3e 32 7c ee			ld (debug_mark+2),a  
3f41 18 03			jr .pastdmark  
3f43 ..			.dmark: db "KEY"  
3f46 f1			.pastdmark: pop af  
3f47			endm  
# End of macro DMARK
3f47						CALLMONITOR 
3f47 cd 86 12			call break_point_state  
3f4a				endm  
# End of macro CALLMONITOR
3f4a					endif 
3f4a			; TODO currently waits 
3f4a cd fe 55				call cin 
3f4d					;call cin_wait 
3f4d 6f					ld l, a 
3f4e 26 00				ld h, 0 
3f50 cd 20 18				call forth_push_numhl 
3f53					NEXTW 
3f53 c3 11 1a			jp macro_next 
3f56				endm 
# End of macro NEXTW
3f56			.WAITK: 
3f56				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
3f56 3f				db WORD_SYS_CORE+43             
3f57 88 3f			dw .ACCEPT            
3f59 06				db 5 + 1 
3f5a .. 00			db "WAITK",0              
3f60				endm 
# End of macro CWHEAD
3f60			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
3f60					if DEBUG_FORTH_WORDS_KEY 
3f60						DMARK "WAI" 
3f60 f5				push af  
3f61 3a 75 3f			ld a, (.dmark)  
3f64 32 7a ee			ld (debug_mark),a  
3f67 3a 76 3f			ld a, (.dmark+1)  
3f6a 32 7b ee			ld (debug_mark+1),a  
3f6d 3a 77 3f			ld a, (.dmark+2)  
3f70 32 7c ee			ld (debug_mark+2),a  
3f73 18 03			jr .pastdmark  
3f75 ..			.dmark: db "WAI"  
3f78 f1			.pastdmark: pop af  
3f79			endm  
# End of macro DMARK
3f79						CALLMONITOR 
3f79 cd 86 12			call break_point_state  
3f7c				endm  
# End of macro CALLMONITOR
3f7c					endif 
3f7c cd f6 55				call cin_wait 
3f7f 6f					ld l, a 
3f80 26 00				ld h, 0 
3f82 cd 20 18				call forth_push_numhl 
3f85					NEXTW 
3f85 c3 11 1a			jp macro_next 
3f88				endm 
# End of macro NEXTW
3f88			.ACCEPT: 
3f88				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
3f88 40				db WORD_SYS_CORE+44             
3f89 e6 3f			dw .EDIT            
3f8b 07				db 6 + 1 
3f8c .. 00			db "ACCEPT",0              
3f93				endm 
# End of macro CWHEAD
3f93			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
3f93					; TODO crashes on push 
3f93					if DEBUG_FORTH_WORDS_KEY 
3f93						DMARK "ACC" 
3f93 f5				push af  
3f94 3a a8 3f			ld a, (.dmark)  
3f97 32 7a ee			ld (debug_mark),a  
3f9a 3a a9 3f			ld a, (.dmark+1)  
3f9d 32 7b ee			ld (debug_mark+1),a  
3fa0 3a aa 3f			ld a, (.dmark+2)  
3fa3 32 7c ee			ld (debug_mark+2),a  
3fa6 18 03			jr .pastdmark  
3fa8 ..			.dmark: db "ACC"  
3fab f1			.pastdmark: pop af  
3fac			endm  
# End of macro DMARK
3fac						CALLMONITOR 
3fac cd 86 12			call break_point_state  
3faf				endm  
# End of macro CALLMONITOR
3faf					endif 
3faf 21 73 e5				ld hl, os_input 
3fb2 3e 00				ld a, 0 
3fb4 77					ld (hl),a 
3fb5 3a 5e eb				ld a,(f_cursor_ptr) 
3fb8 16 64				ld d, 100 
3fba 0e 00				ld c, 0 
3fbc 1e 28				ld e, 40 
3fbe cd ef 0a				call input_str 
3fc1					; TODO perhaps do a type check and wrap in quotes if not a number 
3fc1 21 73 e5				ld hl, os_input 
3fc4					if DEBUG_FORTH_WORDS 
3fc4						DMARK "AC1" 
3fc4 f5				push af  
3fc5 3a d9 3f			ld a, (.dmark)  
3fc8 32 7a ee			ld (debug_mark),a  
3fcb 3a da 3f			ld a, (.dmark+1)  
3fce 32 7b ee			ld (debug_mark+1),a  
3fd1 3a db 3f			ld a, (.dmark+2)  
3fd4 32 7c ee			ld (debug_mark+2),a  
3fd7 18 03			jr .pastdmark  
3fd9 ..			.dmark: db "AC1"  
3fdc f1			.pastdmark: pop af  
3fdd			endm  
# End of macro DMARK
3fdd						CALLMONITOR 
3fdd cd 86 12			call break_point_state  
3fe0				endm  
# End of macro CALLMONITOR
3fe0					endif 
3fe0 cd 32 18				call forth_push_str 
3fe3					NEXTW 
3fe3 c3 11 1a			jp macro_next 
3fe6				endm 
# End of macro NEXTW
3fe6			 
3fe6			.EDIT: 
3fe6				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
3fe6 40				db WORD_SYS_CORE+44             
3fe7 6f 40			dw .ENDKEY            
3fe9 05				db 4 + 1 
3fea .. 00			db "EDIT",0              
3fef				endm 
# End of macro CWHEAD
3fef			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
3fef			 
3fef					; TODO does not copy from stack 
3fef					if DEBUG_FORTH_WORDS_KEY 
3fef						DMARK "EDT" 
3fef f5				push af  
3ff0 3a 04 40			ld a, (.dmark)  
3ff3 32 7a ee			ld (debug_mark),a  
3ff6 3a 05 40			ld a, (.dmark+1)  
3ff9 32 7b ee			ld (debug_mark+1),a  
3ffc 3a 06 40			ld a, (.dmark+2)  
3fff 32 7c ee			ld (debug_mark+2),a  
4002 18 03			jr .pastdmark  
4004 ..			.dmark: db "EDT"  
4007 f1			.pastdmark: pop af  
4008			endm  
# End of macro DMARK
4008						CALLMONITOR 
4008 cd 86 12			call break_point_state  
400b				endm  
# End of macro CALLMONITOR
400b					endif 
400b			 
400b					FORTH_DSP 
400b cd a0 18			call macro_forth_dsp 
400e				endm 
# End of macro FORTH_DSP
400e					;v5 FORTH_DSP_VALUE 
400e 23					inc hl    ; TODO do type check 
400f			 
400f e5					push hl 
4010 3e 00				ld a, 0 
4012 cd 2b 0f				call strlent 
4015 23					inc hl 
4016			 
4016 06 00				ld b, 0 
4018 4d					ld c, l 
4019			 
4019 e1					pop hl 
401a 11 73 e5				ld de, os_input 
401d					if DEBUG_FORTH_WORDS_KEY 
401d						DMARK "EDc" 
401d f5				push af  
401e 3a 32 40			ld a, (.dmark)  
4021 32 7a ee			ld (debug_mark),a  
4024 3a 33 40			ld a, (.dmark+1)  
4027 32 7b ee			ld (debug_mark+1),a  
402a 3a 34 40			ld a, (.dmark+2)  
402d 32 7c ee			ld (debug_mark+2),a  
4030 18 03			jr .pastdmark  
4032 ..			.dmark: db "EDc"  
4035 f1			.pastdmark: pop af  
4036			endm  
# End of macro DMARK
4036						CALLMONITOR 
4036 cd 86 12			call break_point_state  
4039				endm  
# End of macro CALLMONITOR
4039					endif 
4039 ed b0				ldir 
403b			 
403b			 
403b 21 73 e5				ld hl, os_input 
403e					;ld a, 0 
403e					;ld (hl),a 
403e 3a 5e eb				ld a,(f_cursor_ptr) 
4041 16 64				ld d, 100 
4043 0e 00				ld c, 0 
4045 1e 28				ld e, 40 
4047 cd ef 0a				call input_str 
404a					; TODO perhaps do a type check and wrap in quotes if not a number 
404a 21 73 e5				ld hl, os_input 
404d					if DEBUG_FORTH_WORDS 
404d						DMARK "ED1" 
404d f5				push af  
404e 3a 62 40			ld a, (.dmark)  
4051 32 7a ee			ld (debug_mark),a  
4054 3a 63 40			ld a, (.dmark+1)  
4057 32 7b ee			ld (debug_mark+1),a  
405a 3a 64 40			ld a, (.dmark+2)  
405d 32 7c ee			ld (debug_mark+2),a  
4060 18 03			jr .pastdmark  
4062 ..			.dmark: db "ED1"  
4065 f1			.pastdmark: pop af  
4066			endm  
# End of macro DMARK
4066						CALLMONITOR 
4066 cd 86 12			call break_point_state  
4069				endm  
# End of macro CALLMONITOR
4069					endif 
4069 cd 32 18				call forth_push_str 
406c					NEXTW 
406c c3 11 1a			jp macro_next 
406f				endm 
# End of macro NEXTW
406f			 
406f			 
406f			 
406f			.ENDKEY: 
406f			; eof 
406f			 
# End of file forth_words_key.asm
406f			 
406f			if STORAGE_SE 
406f			   	include "forth_words_storage.asm" 
406f			endif 
406f				include "forth_words_device.asm" 
406f			; Device related words 
406f			 
406f			; | ## Device Words 
406f			 
406f			if SOUND_ENABLE 
406f			.NOTE: 
406f				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
406f			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
406f					if DEBUG_FORTH_WORDS_KEY 
406f						DMARK "NTE" 
406f						CALLMONITOR 
406f					endif 
406f			 
406f				 
406f			 
406f					NEXTW 
406f			.AFTERSOUND: 
406f			endif 
406f			 
406f			 
406f			USE_GPIO: equ 0 
406f			 
406f			if USE_GPIO 
406f			.GP1: 
406f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
406f			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
406f					NEXTW 
406f			.GP2: 
406f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
406f			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
406f			 
406f					NEXTW 
406f			 
406f			.GP3: 
406f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
406f			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
406f			 
406f					NEXTW 
406f			 
406f			.GP4: 
406f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
406f			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
406f			 
406f					NEXTW 
406f			.SIN: 
406f			 
406f			 
406f			endif 
406f			 
406f			 
406f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
406f 33				db WORD_SYS_CORE+31             
4070 a4 40			dw .SOUT            
4072 03				db 2 + 1 
4073 .. 00			db "IN",0              
4076				endm 
# End of macro CWHEAD
4076			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4076					if DEBUG_FORTH_WORDS_KEY 
4076						DMARK "IN." 
4076 f5				push af  
4077 3a 8b 40			ld a, (.dmark)  
407a 32 7a ee			ld (debug_mark),a  
407d 3a 8c 40			ld a, (.dmark+1)  
4080 32 7b ee			ld (debug_mark+1),a  
4083 3a 8d 40			ld a, (.dmark+2)  
4086 32 7c ee			ld (debug_mark+2),a  
4089 18 03			jr .pastdmark  
408b ..			.dmark: db "IN."  
408e f1			.pastdmark: pop af  
408f			endm  
# End of macro DMARK
408f						CALLMONITOR 
408f cd 86 12			call break_point_state  
4092				endm  
# End of macro CALLMONITOR
4092					endif 
4092					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4092 cd bb 18			call macro_dsp_valuehl 
4095				endm 
# End of macro FORTH_DSP_VALUEHL
4095			 
4095 e5					push hl 
4096			 
4096					; destroy value TOS 
4096			 
4096					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4096 cd 57 19			call macro_forth_dsp_pop 
4099				endm 
# End of macro FORTH_DSP_POP
4099			 
4099					; one value on hl get other one back 
4099			 
4099 c1					pop bc 
409a			 
409a					; do the sub 
409a			;		ex de, hl 
409a			 
409a ed 68				in l,(c) 
409c			 
409c					; save it 
409c			 
409c 26 00				ld h,0 
409e			 
409e					; TODO push value back onto stack for another op etc 
409e			 
409e cd 20 18				call forth_push_numhl 
40a1					NEXTW 
40a1 c3 11 1a			jp macro_next 
40a4				endm 
# End of macro NEXTW
40a4			.SOUT: 
40a4				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
40a4 34				db WORD_SYS_CORE+32             
40a5 f7 40			dw .SPIO            
40a7 04				db 3 + 1 
40a8 .. 00			db "OUT",0              
40ac				endm 
# End of macro CWHEAD
40ac			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
40ac					if DEBUG_FORTH_WORDS_KEY 
40ac						DMARK "OUT" 
40ac f5				push af  
40ad 3a c1 40			ld a, (.dmark)  
40b0 32 7a ee			ld (debug_mark),a  
40b3 3a c2 40			ld a, (.dmark+1)  
40b6 32 7b ee			ld (debug_mark+1),a  
40b9 3a c3 40			ld a, (.dmark+2)  
40bc 32 7c ee			ld (debug_mark+2),a  
40bf 18 03			jr .pastdmark  
40c1 ..			.dmark: db "OUT"  
40c4 f1			.pastdmark: pop af  
40c5			endm  
# End of macro DMARK
40c5						CALLMONITOR 
40c5 cd 86 12			call break_point_state  
40c8				endm  
# End of macro CALLMONITOR
40c8					endif 
40c8			 
40c8					; get port 
40c8			 
40c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40c8 cd bb 18			call macro_dsp_valuehl 
40cb				endm 
# End of macro FORTH_DSP_VALUEHL
40cb			 
40cb e5					push hl 
40cc			 
40cc					; destroy value TOS 
40cc			 
40cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40cc cd 57 19			call macro_forth_dsp_pop 
40cf				endm 
# End of macro FORTH_DSP_POP
40cf			 
40cf					; get byte to send 
40cf			 
40cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40cf cd bb 18			call macro_dsp_valuehl 
40d2				endm 
# End of macro FORTH_DSP_VALUEHL
40d2			 
40d2			;		push hl 
40d2			 
40d2					; destroy value TOS 
40d2			 
40d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d2 cd 57 19			call macro_forth_dsp_pop 
40d5				endm 
# End of macro FORTH_DSP_POP
40d5			 
40d5					; one value on hl get other one back 
40d5			 
40d5			;		pop hl 
40d5			 
40d5 c1					pop bc 
40d6			 
40d6					if DEBUG_FORTH_WORDS 
40d6						DMARK "OUT" 
40d6 f5				push af  
40d7 3a eb 40			ld a, (.dmark)  
40da 32 7a ee			ld (debug_mark),a  
40dd 3a ec 40			ld a, (.dmark+1)  
40e0 32 7b ee			ld (debug_mark+1),a  
40e3 3a ed 40			ld a, (.dmark+2)  
40e6 32 7c ee			ld (debug_mark+2),a  
40e9 18 03			jr .pastdmark  
40eb ..			.dmark: db "OUT"  
40ee f1			.pastdmark: pop af  
40ef			endm  
# End of macro DMARK
40ef						CALLMONITOR 
40ef cd 86 12			call break_point_state  
40f2				endm  
# End of macro CALLMONITOR
40f2					endif 
40f2			 
40f2 ed 69				out (c), l 
40f4			 
40f4					NEXTW 
40f4 c3 11 1a			jp macro_next 
40f7				endm 
# End of macro NEXTW
40f7			 
40f7			 
40f7			.SPIO: 
40f7			 
40f7			if STORAGE_SE 
40f7				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
40f7			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
40f7			 
40f7					call spi_ce_low 
40f7			    NEXTW 
40f7			 
40f7			.SPICEH: 
40f7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
40f7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
40f7			 
40f7					call spi_ce_high 
40f7			    NEXTW 
40f7			 
40f7			 
40f7			.SPIOb: 
40f7			 
40f7				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
40f7			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
40f7			 
40f7					; get port 
40f7			 
40f7			 
40f7					; get byte to send 
40f7			 
40f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f7			 
40f7			;		push hl    ; u1  
40f7			 
40f7					; destroy value TOS 
40f7			 
40f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f7			 
40f7					; one value on hl get other one back 
40f7			 
40f7			;		pop hl   ; u2 - addr 
40f7			 
40f7					; TODO Send SPI byte 
40f7			 
40f7					ld a, l 
40f7					call spi_send_byte 
40f7			 
40f7					NEXTW 
40f7			 
40f7			.SPII: 
40f7				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
40f7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
40f7			 
40f7					; TODO Get SPI byte 
40f7			 
40f7					call spi_read_byte 
40f7			 
40f7					ld h, 0 
40f7					ld l, a 
40f7					call forth_push_numhl 
40f7			 
40f7					NEXTW 
40f7			 
40f7			 
40f7			 
40f7			.SESEL: 
40f7				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
40f7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
40f7					if DEBUG_FORTH_WORDS_KEY 
40f7						DMARK "BNK" 
40f7						CALLMONITOR 
40f7					endif 
40f7			 
40f7					ld a, 255 
40f7					ld (spi_cartdev), a 
40f7			 
40f7					; get bank 
40f7			 
40f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f7			 
40f7			;		push hl 
40f7			 
40f7					; destroy value TOS 
40f7			 
40f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f7			 
40f7					; one value on hl get other one back 
40f7			 
40f7			;		pop hl 
40f7			 
40f7			 
40f7					ld c, SPI_CE_HIGH 
40f7			 
40f7					ld a, l 
40f7			 
40f7					if DEBUG_FORTH_WORDS 
40f7						DMARK "BNK" 
40f7						CALLMONITOR 
40f7					endif 
40f7			 
40f7					; active low 
40f7			 
40f7					cp 0 
40f7					jr z, .bset 
40f7					cp 1 
40f7					jr nz, .b2 
40f7					res 0, c 
40f7			.b2:		cp 2 
40f7					jr nz, .b3 
40f7					res 1, c 
40f7			.b3:		cp 3 
40f7					jr nz, .b4 
40f7					res 2, c 
40f7			.b4:		cp 4 
40f7					jr nz, .b5 
40f7					res 3, c 
40f7			.b5:		cp 5 
40f7					jr nz, .bset 
40f7					res 4, c 
40f7			 
40f7			.bset: 
40f7					ld a, c 
40f7					ld (spi_device),a 
40f7					if DEBUG_FORTH_WORDS 
40f7						DMARK "BN2" 
40f7						CALLMONITOR 
40f7					endif 
40f7			 
40f7					NEXTW 
40f7			 
40f7			.CARTDEV: 
40f7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
40f7			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
40f7					if DEBUG_FORTH_WORDS_KEY 
40f7						DMARK "CDV" 
40f7						CALLMONITOR 
40f7					endif 
40f7			 
40f7					; disable se storage bank selection 
40f7			 
40f7					ld a, SPI_CE_HIGH		; ce high 
40f7					ld (spi_device), a 
40f7			 
40f7					; get bank 
40f7			 
40f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f7			 
40f7			;		push hl 
40f7			 
40f7					; destroy value TOS 
40f7			 
40f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f7			 
40f7					; one value on hl get other one back 
40f7			 
40f7			;		pop hl 
40f7			 
40f7					; active low 
40f7			 
40f7					ld c, 255 
40f7			 
40f7					ld a, l 
40f7					if DEBUG_FORTH_WORDS 
40f7						DMARK "CDV" 
40f7						CALLMONITOR 
40f7					endif 
40f7					cp 0 
40f7					jr z, .cset 
40f7					cp 1 
40f7					jr nz, .c2 
40f7					res 0, c 
40f7			.c2:		cp 2 
40f7					jr nz, .c3 
40f7					res 1, c 
40f7			.c3:		cp 3 
40f7					jr nz, .c4 
40f7					res 2, c 
40f7			.c4:		cp 4 
40f7					jr nz, .c5 
40f7					res 3, c 
40f7			.c5:		cp 5 
40f7					jr nz, .c6 
40f7					res 4, c 
40f7			.c6:		cp 6 
40f7					jr nz, .c7 
40f7					res 5, c 
40f7			.c7:		cp 7 
40f7					jr nz, .c8 
40f7					res 6, c 
40f7			.c8:		cp 8 
40f7					jr nz, .cset 
40f7					res 7, c 
40f7			.cset:		ld a, c 
40f7					ld (spi_cartdev),a 
40f7			 
40f7					if DEBUG_FORTH_WORDS 
40f7						DMARK "CD2" 
40f7						CALLMONITOR 
40f7					endif 
40f7					NEXTW 
40f7			endif 
40f7			 
40f7			.ENDDEVICE: 
40f7			; eof 
40f7			 
# End of file forth_words_device.asm
40f7			 
40f7			; var handler 
40f7			 
40f7			 
40f7			.VARS: 
40f7				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
40f7 78				db WORD_SYS_CORE+100             
40f8 0f 41			dw .V0Q            
40fa 04				db 3 + 1 
40fb .. 00			db "V0!",0              
40ff				endm 
# End of macro CWHEAD
40ff			;| V0! ( u1 -- )  Store value to v0  | DONE 
40ff			 
40ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ff cd bb 18			call macro_dsp_valuehl 
4102				endm 
# End of macro FORTH_DSP_VALUEHL
4102			 
4102 11 28 eb				ld de, cli_var_array 
4105			 
4105 eb					ex de, hl 
4106 73					ld (hl), e 
4107 23					inc hl 
4108 72					ld (hl), d 
4109			 
4109					; destroy value TOS 
4109			 
4109					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4109 cd 57 19			call macro_forth_dsp_pop 
410c				endm 
# End of macro FORTH_DSP_POP
410c			 
410c				       NEXTW 
410c c3 11 1a			jp macro_next 
410f				endm 
# End of macro NEXTW
410f			.V0Q: 
410f				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
410f 79				db WORD_SYS_CORE+101             
4110 20 41			dw .V1S            
4112 04				db 3 + 1 
4113 .. 00			db "V0@",0              
4117				endm 
# End of macro CWHEAD
4117			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4117 2a 28 eb				ld hl, (cli_var_array) 
411a cd 20 18				call forth_push_numhl 
411d			 
411d				       NEXTW 
411d c3 11 1a			jp macro_next 
4120				endm 
# End of macro NEXTW
4120			.V1S: 
4120				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4120 7a				db WORD_SYS_CORE+102             
4121 38 41			dw .V1Q            
4123 04				db 3 + 1 
4124 .. 00			db "V1!",0              
4128				endm 
# End of macro CWHEAD
4128			;| V1! ( u1 -- )  Store value to v1 | DONE 
4128					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4128 cd bb 18			call macro_dsp_valuehl 
412b				endm 
# End of macro FORTH_DSP_VALUEHL
412b			 
412b 11 2a eb				ld de, cli_var_array+2 
412e				 
412e eb					ex de, hl 
412f 73					ld (hl), e 
4130 23					inc hl 
4131 72					ld (hl), d 
4132			 
4132					; destroy value TOS 
4132			 
4132					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4132 cd 57 19			call macro_forth_dsp_pop 
4135				endm 
# End of macro FORTH_DSP_POP
4135				       NEXTW 
4135 c3 11 1a			jp macro_next 
4138				endm 
# End of macro NEXTW
4138			.V1Q: 
4138				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4138 7b				db WORD_SYS_CORE+103             
4139 49 41			dw .V2S            
413b 04				db 3 + 1 
413c .. 00			db "V1@",0              
4140				endm 
# End of macro CWHEAD
4140			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4140 2a 2a eb				ld hl, (cli_var_array+2) 
4143 cd 20 18				call forth_push_numhl 
4146				       NEXTW 
4146 c3 11 1a			jp macro_next 
4149				endm 
# End of macro NEXTW
4149			.V2S: 
4149				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4149 7c				db WORD_SYS_CORE+104             
414a 61 41			dw .V2Q            
414c 04				db 3 + 1 
414d .. 00			db "V2!",0              
4151				endm 
# End of macro CWHEAD
4151			;| V2! ( u1 -- )  Store value to v2 | DONE 
4151					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4151 cd bb 18			call macro_dsp_valuehl 
4154				endm 
# End of macro FORTH_DSP_VALUEHL
4154			 
4154 11 2c eb				ld de, cli_var_array+4 
4157				 
4157 eb					ex de, hl 
4158 73					ld (hl), e 
4159 23					inc hl 
415a 72					ld (hl), d 
415b			 
415b					; destroy value TOS 
415b			 
415b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
415b cd 57 19			call macro_forth_dsp_pop 
415e				endm 
# End of macro FORTH_DSP_POP
415e				       NEXTW 
415e c3 11 1a			jp macro_next 
4161				endm 
# End of macro NEXTW
4161			.V2Q: 
4161				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4161 7d				db WORD_SYS_CORE+105             
4162 72 41			dw .V3S            
4164 04				db 3 + 1 
4165 .. 00			db "V2@",0              
4169				endm 
# End of macro CWHEAD
4169			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4169 2a 2c eb				ld hl, (cli_var_array+4) 
416c cd 20 18				call forth_push_numhl 
416f				       NEXTW 
416f c3 11 1a			jp macro_next 
4172				endm 
# End of macro NEXTW
4172			.V3S: 
4172				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4172 7c				db WORD_SYS_CORE+104             
4173 8a 41			dw .V3Q            
4175 04				db 3 + 1 
4176 .. 00			db "V3!",0              
417a				endm 
# End of macro CWHEAD
417a			;| V3! ( u1 -- )  Store value to v3 | DONE 
417a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
417a cd bb 18			call macro_dsp_valuehl 
417d				endm 
# End of macro FORTH_DSP_VALUEHL
417d			 
417d 11 2e eb				ld de, cli_var_array+6 
4180				 
4180 eb					ex de, hl 
4181 73					ld (hl), e 
4182 23					inc hl 
4183 72					ld (hl), d 
4184			 
4184					; destroy value TOS 
4184			 
4184					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4184 cd 57 19			call macro_forth_dsp_pop 
4187				endm 
# End of macro FORTH_DSP_POP
4187				       NEXTW 
4187 c3 11 1a			jp macro_next 
418a				endm 
# End of macro NEXTW
418a			.V3Q: 
418a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
418a 7d				db WORD_SYS_CORE+105             
418b 9b 41			dw .END            
418d 04				db 3 + 1 
418e .. 00			db "V3@",0              
4192				endm 
# End of macro CWHEAD
4192			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4192 2a 2e eb				ld hl, (cli_var_array+6) 
4195 cd 20 18				call forth_push_numhl 
4198				       NEXTW 
4198 c3 11 1a			jp macro_next 
419b				endm 
# End of macro NEXTW
419b			 
419b			 
419b			 
419b			 
419b			 
419b			; end of dict marker 
419b			 
419b 00			.END:    db WORD_SYS_END 
419c 00 00			dw 0 
419e 00				db 0 
419f			 
419f			; use to jp here for user dict words to save on macro expansion  
419f			 
419f			user_dict_next: 
419f				NEXTW 
419f c3 11 1a			jp macro_next 
41a2				endm 
# End of macro NEXTW
41a2			 
41a2			 
41a2			user_exec: 
41a2				;    ld hl, <word code> 
41a2				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
41a2				;    call forthexec 
41a2				;    jp user_dict_next   (NEXT) 
41a2			        ;    <word code bytes> 
41a2 eb				ex de, hl 
41a3 2a 76 e6			ld hl,(os_tok_ptr) 
41a6				 
41a6				FORTH_RSP_NEXT 
41a6 cd c7 17			call macro_forth_rsp_next 
41a9				endm 
# End of macro FORTH_RSP_NEXT
41a9			 
41a9			if DEBUG_FORTH_UWORD 
41a9						DMARK "UEX" 
41a9 f5				push af  
41aa 3a be 41			ld a, (.dmark)  
41ad 32 7a ee			ld (debug_mark),a  
41b0 3a bf 41			ld a, (.dmark+1)  
41b3 32 7b ee			ld (debug_mark+1),a  
41b6 3a c0 41			ld a, (.dmark+2)  
41b9 32 7c ee			ld (debug_mark+2),a  
41bc 18 03			jr .pastdmark  
41be ..			.dmark: db "UEX"  
41c1 f1			.pastdmark: pop af  
41c2			endm  
# End of macro DMARK
41c2				CALLMONITOR 
41c2 cd 86 12			call break_point_state  
41c5				endm  
# End of macro CALLMONITOR
41c5			endif 
41c5			 
41c5			 
41c5			 
41c5 eb				ex de, hl 
41c6 22 76 e6			ld (os_tok_ptr), hl 
41c9				 
41c9				; Don't use next - Skips the first word in uword. 
41c9			 
41c9 c3 a2 1a			jp exec1 
41cc			;	NEXT 
41cc			 
41cc			 
41cc			; eof 
# End of file forth_wordsv4.asm
41cc			endif 
41cc			;;;;;;;;;;;;;; Debug code 
41cc			 
41cc			 
41cc			;if DEBUG_FORTH_PARSE 
41cc .. 00		.nowordfound: db "No match",0 
41d5 .. 00		.compword:	db "Comparing word ",0 
41e5 .. 00		.nextwordat:	db "Next word at",0 
41f2 .. 00		.charmatch:	db "Char match",0 
41fd			;endif 
41fd			if DEBUG_FORTH_JP 
41fd			.foundword:	db "Word match. Exec..",0 
41fd			endif 
41fd			;if DEBUG_FORTH_PUSH 
41fd .. 00		.enddict:	db "Dict end. Push.",0 
420d .. 00		.push_str:	db "Pushing string",0 
421c .. 00		.push_num:	db "Pushing number",0 
422b .. 00		.data_sp:	db "SP:",0 
422f .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4241 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4253 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4265			;endif 
4265			;if DEBUG_FORTH_MALLOC 
4265 .. 00		.push_malloc:	db "Malloc address",0 
4274			;endif 
4274			 
4274			 
4274			 
4274			; display malloc address and current data stack pointer  
4274			 
4274			malloc_error: 
4274 d5				push de 
4275 f5				push af 
4276 e5				push hl 
4277 cd 69 09			call clear_display 
427a 11 9c 42			ld de, .mallocerr 
427d 3e 00			ld a,0 
427f			;	ld de,os_word_scratch 
427f cd 7c 09			call str_at_display 
4282 3e 11			ld a, display_row_1+17 
4284 11 7a ee			ld de, debug_mark 
4287 cd 7c 09			call str_at_display 
428a cd 8c 09			call update_display 
428d				;call break_point_state 
428d cd f6 55			call cin_wait 
4290			 
4290 3e 20			ld a, ' ' 
4292 32 74 e3			ld (os_view_disable), a 
4295 e1				pop hl 
4296 f1				pop af 
4297 d1				pop de	 
4298				CALLMONITOR 
4298 cd 86 12			call break_point_state  
429b				endm  
# End of macro CALLMONITOR
429b c9				ret 
429c			 
429c .. 00		.mallocerr: 	db "Malloc Error",0 
42a9			;if DEBUG_FORTH_PUSH 
42a9			display_data_sp: 
42a9 f5				push af 
42aa			 
42aa				; see if disabled 
42aa			 
42aa 3a 74 e3			ld a, (os_view_disable) 
42ad fe 2a			cp '*' 
42af 28 67			jr z, .skipdsp 
42b1			 
42b1 e5				push hl 
42b2 e5				push hl 
42b3 e5			push hl 
42b4 cd 69 09			call clear_display 
42b7 e1			pop hl 
42b8 7c				ld a,h 
42b9 21 7a e6			ld hl, os_word_scratch 
42bc cd c3 0d			call hexout 
42bf e1				pop hl 
42c0 7d				ld a,l 
42c1 21 7c e6			ld hl, os_word_scratch+2 
42c4 cd c3 0d			call hexout 
42c7 21 7e e6			ld hl, os_word_scratch+4 
42ca 3e 00			ld a,0 
42cc 77				ld (hl),a 
42cd 11 7a e6			ld de,os_word_scratch 
42d0 3e 28				ld a, display_row_2 
42d2 cd 7c 09				call str_at_display 
42d5 11 2f 42			ld de, .wordinhl 
42d8 3e 00			ld a, display_row_1 
42da			 
42da cd 7c 09				call str_at_display 
42dd 11 7a ee			ld de, debug_mark 
42e0 3e 11			ld a, display_row_1+17 
42e2			 
42e2 cd 7c 09				call str_at_display 
42e5			 
42e5				; display current data stack pointer 
42e5 11 2b 42			ld de,.data_sp 
42e8 3e 30				ld a, display_row_2 + 8 
42ea cd 7c 09				call str_at_display 
42ed			 
42ed 2a 22 eb			ld hl,(cli_data_sp) 
42f0 e5				push hl 
42f1 7c				ld a,h 
42f2 21 7a e6			ld hl, os_word_scratch 
42f5 cd c3 0d			call hexout 
42f8 e1				pop hl 
42f9 7d				ld a,l 
42fa 21 7c e6			ld hl, os_word_scratch+2 
42fd cd c3 0d			call hexout 
4300 21 7e e6			ld hl, os_word_scratch+4 
4303 3e 00			ld a,0 
4305 77				ld (hl),a 
4306 11 7a e6			ld de,os_word_scratch 
4309 3e 33				ld a, display_row_2 + 11 
430b cd 7c 09				call str_at_display 
430e			 
430e			 
430e cd 8c 09			call update_display 
4311 cd e2 08			call delay1s 
4314 cd e2 08			call delay1s 
4317 e1				pop hl 
4318			.skipdsp: 
4318 f1				pop af 
4319 c9				ret 
431a			 
431a			display_data_malloc: 
431a			 
431a f5				push af 
431b e5				push hl 
431c e5				push hl 
431d e5			push hl 
431e cd 69 09			call clear_display 
4321 e1			pop hl 
4322 7c				ld a,h 
4323 21 7a e6			ld hl, os_word_scratch 
4326 cd c3 0d			call hexout 
4329 e1				pop hl 
432a 7d				ld a,l 
432b 21 7c e6			ld hl, os_word_scratch+2 
432e cd c3 0d			call hexout 
4331 21 7e e6			ld hl, os_word_scratch+4 
4334 3e 00			ld a,0 
4336 77				ld (hl),a 
4337 11 7a e6			ld de,os_word_scratch 
433a 3e 28				ld a, display_row_2 
433c cd 7c 09				call str_at_display 
433f 11 65 42			ld de, .push_malloc 
4342 3e 00			ld a, display_row_1 
4344			 
4344 cd 7c 09				call str_at_display 
4347			 
4347				; display current data stack pointer 
4347 11 2b 42			ld de,.data_sp 
434a 3e 30				ld a, display_row_2 + 8 
434c cd 7c 09				call str_at_display 
434f			 
434f 2a 22 eb			ld hl,(cli_data_sp) 
4352 e5				push hl 
4353 7c				ld a,h 
4354 21 7a e6			ld hl, os_word_scratch 
4357 cd c3 0d			call hexout 
435a e1				pop hl 
435b 7d				ld a,l 
435c 21 7c e6			ld hl, os_word_scratch+2 
435f cd c3 0d			call hexout 
4362 21 7e e6			ld hl, os_word_scratch+4 
4365 3e 00			ld a,0 
4367 77				ld (hl),a 
4368 11 7a e6			ld de,os_word_scratch 
436b 3e 33				ld a, display_row_2 + 11 
436d cd 7c 09				call str_at_display 
4370			 
4370 cd 8c 09			call update_display 
4373 cd e2 08			call delay1s 
4376 cd e2 08			call delay1s 
4379 e1				pop hl 
437a f1				pop af 
437b c9				ret 
437c			;endif 
437c			 
437c			include "forth_autostart.asm" 
437c			; list of commands to perform at system start up 
437c			 
437c			startcmds: 
437c			;	dw test11 
437c			;	dw test12 
437c			;	dw test13 
437c			;	dw test14 
437c			;	dw test15 
437c			;	dw test16 
437c			;	dw test17 
437c			;	dw ifthtest1 
437c			;	dw ifthtest2 
437c			;	dw ifthtest3 
437c			;	dw mmtest1 
437c			;	dw mmtest2 
437c			;	dw mmtest3 
437c			;	dw mmtest4 
437c			;	dw mmtest5 
437c			;	dw mmtest6 
437c			;	dw iftest1 
437c			;	dw iftest2 
437c			;	dw iftest3 
437c			;	dw looptest1 
437c			;	dw looptest2 
437c			;	dw test1 
437c			;	dw test2 
437c			;	dw test3 
437c			;	dw test4 
437c			;	dw game2r 
437c			;	dw game2b1 
437c			;	dw game2b2 
437c			 
437c				; start up words that are actually useful 
437c			 
437c da 43			dw clrstack 
437e 0d 44			dw type 
4380 ce 45			dw stest 
4382 31 44			dw strncpy 
4384 6f 45			dw list 
4386 92 44			dw start1 
4388 a4 44			dw start2 
438a			;	dw start3 
438a b7 44			dw start3b 
438c 0f 45			dw start3c 
438e			 
438e				; (unit) testing words 
438e			 
438e 45 46			dw mtesta 
4390 fa 46			dw mtestb 
4392 9d 47			dw mtestc 
4394 52 48			dw mtestd 
4396 f6 48			dw mteste 
4398			 
4398				; demo/game words 
4398			 
4398 02 50		        dw game3w 
439a 30 50		        dw game3p 
439c 4e 50		        dw game3sc 
439e 7f 50		        dw game3vsi 
43a0 ab 50		        dw game3vs 
43a2				 
43a2 f5 4d			dw game2b 
43a4 63 4e			dw game2bf 
43a6 ad 4e			dw game2mba 
43a8 43 4f			dw game2mbas 
43aa 85 4f			dw game2mb 
43ac			 
43ac b6 4a			dw game1 
43ae c7 4a			dw game1a 
43b0 29 4b			dw game1b 
43b2 5e 4b			dw game1c 
43b4 94 4b			dw game1d 
43b6 c5 4b			dw game1s 
43b8 d9 4b			dw game1t 
43ba ee 4b			dw game1f 
43bc 22 4c			dw game1z 
43be 66 4c			dw game1zz 
43c0			 
43c0 ac 49			dw test5 
43c2 e4 49			dw test6 
43c4 1c 4a			dw test7 
43c6 30 4a			dw test8 
43c8 5c 4a			dw test9 
43ca 72 4a			dw test10 
43cc				 
43cc 3d 4d		        dw ssv5 
43ce 21 4d		        dw ssv4 
43d0 05 4d		        dw ssv3 
43d2 cf 4c		        dw ssv2 
43d4 56 4d		        dw ssv1 
43d6 9e 4d		        dw ssv1cpm 
43d8			;	dw keyup 
43d8			;	dw keydown 
43d8			;	dw keyleft 
43d8			;	dw keyright 
43d8			;	dw 	keyf1 
43d8			;	dw keyf2 
43d8			;	dw keyf3 
43d8			;	dw keyf4 
43d8			;	dw keyf5 
43d8			;	dw keyf6 
43d8			;	dw keyf7 
43d8			;	dw keyf8 
43d8			;	dw keyf9 
43d8			;	dw keyf10 
43d8			;	dw keyf11 
43d8			;	dw keyf12 
43d8			;	dw keytab 
43d8			;	dw keycr 
43d8			;	dw keyhome 
43d8			;	dw keyend 
43d8			;	dw keybs 
43d8 00 00			db 0, 0	 
43da			 
43da			 
43da			; clear stack  
43da			 
43da .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
440d			 
440d			; type ( addr count - ) 
440d .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4431			 
4431			; some direct memory words 
4431			; strncpy ( len t f -- t ) 
4431			 
4431 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4492			 
4492 .. 00		start1:     	db ": bpon $0000 bp ;",0 
44a4 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
44b7			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
44b7 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
450f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
456f			 
456f			 
456f			; a handy word to list items on the stack 
456f			 
456f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
45ce			 
45ce			 
45ce			; test stack  
45ce			; rnd8 stest 
45ce			 
45ce .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4645			 
4645			; random malloc and free cycles 
4645			 
4645 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
46fa			 
46fa			; fixed malloc and free cycles 
46fa			 
46fa .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
479d			 
479d			; fixed double string push and drop cycle  
479d			 
479d .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4852			 
4852			; consistent fixed string push and drop cycle  
4852			 
4852 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
48f6			 
48f6 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
49ac			 
49ac			;test1:		db ": aa 1 2 3 ;", 0 
49ac			;test2:     	db "111 aa 888 999",0 
49ac			;test3:     	db ": bb 77 ;",0 
49ac			;test4:     	db "$02 $01 do i . loop bb",0 
49ac			 
49ac .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
49e4 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4a1c .. 00		test7:     	db ": box hline vline ;",0 
4a30 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4a5c .. 00		test9:     	db ": sw $01 adsp world ;",0 
4a72 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4a97 .. 00		test11:     	db "hello create .",0 
4aa6 .. 00		test12:     	db "hello2 create .",0 
4ab6			 
4ab6			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4ab6			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4ab6			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4ab6			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4ab6			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4ab6			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4ab6			 
4ab6			;iftest1:     	db "$0001 IF cls .",0 
4ab6			;iftest2:     	db "$0000 IF cls .",0 
4ab6			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4ab6			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4ab6			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4ab6			 
4ab6			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4ab6			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4ab6			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4ab6			 
4ab6			 
4ab6			 
4ab6			; a small guess the number game 
4ab6			 
4ab6 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4ac7 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4b29			 
4b29 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4b5e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4b94 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4bc5 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4bd9 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4bee .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4c22 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4c66			 
4c66			; Using 'ga' save a high score across multiple runs using external storage 
4c66			 
4c66 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4ccf			 
4ccf			 
4ccf			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4ccf			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ccf			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ccf			 
4ccf			; simple screen saver to test code memory reuse to destruction 
4ccf			 
4ccf .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
4d05 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
4d21 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
4d3d .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
4d56 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
4d9e .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
4df5			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
4df5			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
4df5			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
4df5			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
4df5			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
4df5			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
4df5			 
4df5			 
4df5			 
4df5			; minesweeper/battleship finding game 
4df5			; draws a game board of random ship/mine positions 
4df5			; user enters coords to see if it hits on 
4df5			; game ends when all are hit 
4df5			; when hit or miss says how many may be in the area 
4df5			 
4df5			; setup the game board and then hide it 
4df5 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
4e63 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
4ead			; prompt for where to target 
4ead .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
4f43 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
4f68			; TODO see if the entered coords hits or misses pushes char hit of miss 
4f68 .. 00		game2mbht:      db ": mbckht nop ;",0 
4f77 .. 00		game2mbms:      db ": mbcms nop ;",0 
4f85			; TODO how many might be near by 
4f85 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5002			 
5002			; Game 3 
5002			 
5002			; Vert scroller ski game - avoid the trees! 
5002			 
5002			; v0 score (ie turns) 
5002			; v1 player pos 
5002			; v2 left wall 
5002			; v3 right wall 
5002			 
5002			; Draw side walls randomly 
5002			 
5002 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5030			 
5030			; Draw player 
5030 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
504e			 
504e			; TODO Get Key 
504e			 
504e			; TODO Move left right 
504e			 
504e			; scroll and move walls a bit 
504e			 
504e .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
507f			 
507f			; main game loop 
507f			 
507f .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
50ab .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
50ea			 
50ea			; key board defs 
50ea			 
50ea .. 00		keyup:       db ": keyup $05 ;",0 
50f8 .. 00		keydown:       db ": keydown $0a ;",0 
5108 .. 00		keyleft:       db ": keyleft $0b ;",0 
5118 .. 00		keyright:       db ": keyright $0c ;",0 
5129 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5137 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5145 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5153 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5161 .. 00		keyf5:       db ": keyf5 $14 ;",0 
516f .. 00		keyf6:       db ": keyf6 $15 ;",0 
517d .. 00		keyf7:       db ": keyf7 $16 ;",0 
518b .. 00		keyf8:       db ": keyf8 $17 ;",0 
5199 .. 00		keyf9:       db ": keyf9 $18 ;",0 
51a7 .. 00		keyf10:       db ": keyf10 $19 ;",0 
51b6 .. 00		keyf11:       db ": keyf11 $1a ;",0 
51c5 .. 00		keyf12:       db ": keyf12 $1b ;",0 
51d4			 
51d4 .. 00		keytab:       db ": keytab $09 ;",0 
51e3 .. 00		keycr:       db ": keycr $0d ;",0 
51f1 .. 00		keyhome:       db ": keyhome $0e ;",0 
5201 .. 00		keyend:       db ": keyend $0f ;",0 
5210 .. 00		keybs:       db ": keybs $08 ;",0 
521e			 
521e			   
521e			 
521e			 
521e			 
521e			; eof 
# End of file forth_autostart.asm
521e			 
521e .. 00		sprompt1: db "Startup load...",0 
522e .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5244			 
5244			forth_startup: 
5244 21 7c 43			ld hl, startcmds 
5247 3e 00			ld a, 0 
5249 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
524c			 
524c e5			.start1:	push hl 
524d cd 69 09			call clear_display 
5250 11 1e 52			ld de, sprompt1 
5253 3e 00		        ld a, display_row_1 
5255 cd 7c 09			call str_at_display 
5258 11 2e 52			ld de, sprompt2 
525b 3e 28		        ld a, display_row_2 
525d cd 7c 09			call str_at_display 
5260 e1				pop hl 
5261 e5				push hl 
5262 5e				ld e,(hl) 
5263 23				inc hl 
5264 56				ld d,(hl) 
5265 3e 50		        ld a, display_row_3 
5267 cd 7c 09			call str_at_display 
526a cd 8c 09			call update_display 
526d			 
526d			 
526d 3a 9b e7			ld a, (os_last_cmd) 
5270 fe 00			cp 0 
5272 28 05			jr z, .startprompt 
5274 cd d6 08			call delay250ms 
5277 18 24			jr .startdo 
5279				 
5279				 
5279			 
5279			.startprompt: 
5279			 
5279 3e 9f			ld a,display_row_4 + display_cols - 1 
527b 11 96 17		        ld de, endprg 
527e cd 7c 09			call str_at_display 
5281 cd 8c 09			call update_display 
5284 cd e2 08			call delay1s 
5287 cd f6 55			call cin_wait 
528a						 
528a fe 2a			cp '*' 
528c 28 5e			jr z, .startupend1 
528e fe 23			cp '#' 
5290 20 07			jr nz, .startno 
5292 3e 01			ld a, 1 
5294 32 9b e7			ld (os_last_cmd),a 
5297 18 04			jr .startdo 
5299 fe 31		.startno:	cp '1' 
529b 28 3a			jr z,.startnxt  
529d			 
529d				; exec startup line 
529d			.startdo:	 
529d e1				pop hl 
529e e5				push hl 
529f				 
529f 5e				ld e,(hl) 
52a0 23				inc hl 
52a1 56				ld d,(hl) 
52a2 eb				ex de,hl 
52a3			 
52a3 e5				push hl 
52a4			 
52a4 3e 00			ld a, 0 
52a6				;ld a, FORTH_END_BUFFER 
52a6 cd 2b 0f			call strlent 
52a9 23				inc hl   ; include zero term to copy 
52aa 06 00			ld b,0 
52ac 4d				ld c,l 
52ad e1				pop hl 
52ae 11 75 e3			ld de, scratch 
52b1 ed b0			ldir 
52b3			 
52b3			 
52b3 21 75 e3			ld hl, scratch 
52b6 cd 5f 1a			call forthparse 
52b9 cd 9f 1a			call forthexec 
52bc cd b6 19			call forthexec_cleanup 
52bf			 
52bf 3e 78			ld a, display_row_4 
52c1 11 3a 15			ld de, endprog 
52c4			 
52c4 cd 8c 09			call update_display		 
52c7			 
52c7 3a 9b e7			ld a, (os_last_cmd) 
52ca fe 00			cp 0 
52cc 20 09			jr nz, .startnxt 
52ce cd 98 17			call next_page_prompt 
52d1 cd 69 09		        call clear_display 
52d4 cd 8c 09			call update_display		 
52d7			 
52d7				; move onto next startup line? 
52d7			.startnxt: 
52d7			 
52d7 cd d6 08			call delay250ms 
52da e1				pop hl 
52db			 
52db 23				inc hl 
52dc 23				inc hl 
52dd			 
52dd e5				push hl 
52de 5e				ld e, (hl) 
52df 23				inc hl 
52e0 56				ld d, (hl) 
52e1 e1				pop hl 
52e2				; TODO replace 0 test 
52e2			 
52e2 eb				ex de, hl 
52e3 cd eb 0a			call ishlzero 
52e6			;	ld a,e 
52e6			;	add d 
52e6			;	cp 0    ; any left to do? 
52e6 eb				ex de, hl 
52e7 c2 4c 52			jp nz, .start1 
52ea 18 01			jr .startupend 
52ec			 
52ec e1			.startupend1: pop hl 
52ed			.startupend: 
52ed			 
52ed cd 69 09			call clear_display 
52f0 cd 8c 09			call update_display 
52f3 c9				ret 
52f4			 
52f4			 
52f4			; stack over and underflow checks 
52f4			 
52f4			; init the words to detect the under/overflow 
52f4			 
52f4			chk_stk_init: 
52f4				; a vague random number to check so we dont get any "lucky" hits 
52f4 3e 2d			ld a, 45 
52f6 6f				ld l, a 
52f7 00				nop 
52f8 3e 17			ld a, 23 
52fa 67				ld h, a 
52fb			 
52fb 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
52fe			 
52fe			;	ld (chk_stund), hl	; stack points.... 
52fe 22 00 ef			ld (chk_stovr), hl 
5301 22 20 eb			ld (chk_ret_und), hl 
5304 22 de ea			ld (chk_ret_ovr), hl 
5307 22 dc e9			ld (chk_loop_ovr), hl 
530a 22 da e8			ld (chk_data_ovr), hl 
530d c9				ret 
530e				 
530e			check_stacks: 
530e				; check all stack words 
530e			 
530e e5				push hl 
530f d5				push de 
5310			 
5310			;	ld de,(chk_word) 
5310			;	ld hl, (chk_stund)	; stack points.... 
5310			;	if DEBUG_STK_FAULT 
5310			;		DMARK "FAa" 
5310			;		CALLMONITOR 
5310			;	endif 
5310			;	call cmp16 
5310			;	jp z, .chk_faulta 
5310			; 
5310			;	ld de, sfaultsu 
5310			;	jp .chk_fault 
5310			 
5310 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5313 ed 5b 6a e3		ld de,(chk_word) 
5317				if DEBUG_STK_FAULT 
5317					DMARK "FAb" 
5317					CALLMONITOR 
5317				endif 
5317 cd e0 0a			call cmp16 
531a 28 06			jr z, .chk_fault1 
531c 11 bd 53			ld de, sfaultso 
531f c3 71 53			jp .chk_fault 
5322			.chk_fault1:  
5322 2a 20 eb			ld hl, (chk_ret_und) 
5325 ed 5b 6a e3		ld de,(chk_word) 
5329				if DEBUG_STK_FAULT 
5329					DMARK "FAU" 
5329					CALLMONITOR 
5329				endif 
5329 cd e0 0a			call cmp16 
532c ca 35 53			jp z, .chk_fault2 
532f 11 cd 53			ld de, sfaultru 
5332 c3 71 53			jp .chk_fault 
5335			.chk_fault2:  
5335 2a de ea			ld hl, (chk_ret_ovr) 
5338 ed 5b 6a e3		ld de,(chk_word) 
533c				if DEBUG_STK_FAULT 
533c					DMARK "FA1" 
533c					CALLMONITOR 
533c				endif 
533c cd e0 0a			call cmp16 
533f ca 48 53			jp z, .chk_fault3 
5342 11 db 53			ld de, sfaultro 
5345 c3 71 53			jp .chk_fault 
5348			.chk_fault3:  
5348 2a dc e9			ld hl, (chk_loop_ovr) 
534b ed 5b 6a e3		ld de,(chk_word) 
534f				if DEBUG_STK_FAULT 
534f					DMARK "FA2" 
534f					CALLMONITOR 
534f				endif 
534f cd e0 0a			call cmp16 
5352 ca 5b 53			jp z, .chk_fault4 
5355 11 f5 53			ld de, sfaultlo 
5358 c3 71 53			jp .chk_fault 
535b			.chk_fault4:  
535b 2a da e8			ld hl, (chk_data_ovr) 
535e ed 5b 6a e3		ld de,(chk_word) 
5362				if DEBUG_STK_FAULT 
5362					DMARK "FA3" 
5362					CALLMONITOR 
5362				endif 
5362 cd e0 0a			call cmp16 
5365 ca 6e 53			jp z, .chk_fault5 
5368 11 0f 54			ld de, sfaultdo 
536b c3 71 53			jp .chk_fault 
536e			 
536e			 
536e			.chk_fault5:  
536e d1				pop de 
536f e1				pop hl 
5370			 
5370 c9				ret 
5371			 
5371 cd 69 09		.chk_fault: 	call clear_display 
5374 3e 28				ld a, display_row_2 
5376 cd 7c 09				call str_at_display 
5379 11 9f 53				   ld de, .stackfault 
537c 3e 00				ld a, display_row_1 
537e cd 7c 09				call str_at_display 
5381 11 7a ee				    ld de, debug_mark 
5384 3e 11				ld a, display_row_1+17 
5386 cd 7c 09				call str_at_display 
5389 cd 8c 09				call update_display 
538c			 
538c				; prompt before entering montior for investigating issue 
538c			 
538c 3e 78			ld a, display_row_4 
538e 11 3a 15			ld de, endprog 
5391			 
5391 cd 8c 09			call update_display		 
5394			 
5394 cd 98 17			call next_page_prompt 
5397			 
5397 d1				pop de 
5398 e1				pop hl 
5399 cd 8e 15				call monitor 
539c c3 7b 14				jp warmstart 
539f					;jp 0 
539f					;halt 
539f			 
539f			 
539f			 
539f .. 00		.stackfault: 	db "Stack fault:",0 
53ac			 
53ac .. 00		sfaultsu: 	db	"Stack under flow",0 
53bd .. 00		sfaultso: 	db	"Stack over flow",0 
53cd .. 00		sfaultru:	db "RTS underflow",0 
53db .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
53f5 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
540f .. 00		sfaultdo:	db "DTS overflow", 0 
541c			 
541c			 
541c			fault_dsp_under: 
541c 11 2e 54			ld de, .dsp_under 
541f c3 de 54			jp .show_fault 
5422			 
5422			fault_rsp_under: 
5422 11 3c 54			ld de, .rsp_under 
5425 c3 de 54			jp .show_fault 
5428			fault_loop_under: 
5428 11 4a 54			ld de, .loop_under 
542b c3 de 54			jp .show_fault 
542e			 
542e .. 00		.dsp_under: db "DSP Underflow",0 
543c .. 00		.rsp_under: db "RSP Underflow",0 
544a .. 00		.loop_under: db "LOOP Underflow",0 
5459			 
5459			 
5459 d5			type_faultn: 	push de 
545a e5					push hl 
545b cd 69 09				call clear_display 
545e 11 85 54				   ld de, .typefaultn 
5461 3e 00				ld a, display_row_1 
5463 cd 7c 09				call str_at_display 
5466 11 7a ee				    ld de, debug_mark 
5469 3e 11				ld a, display_row_1+17 
546b cd 7c 09				call str_at_display 
546e cd 8c 09				call update_display 
5471			 
5471				; prompt before entering montior for investigating issue 
5471			 
5471 3e 78			ld a, display_row_4 
5473 11 3a 15			ld de, endprog 
5476			 
5476 cd 8c 09			call update_display		 
5479			 
5479 cd 98 17			call next_page_prompt 
547c			 
547c e5					push hl 
547d d5					push de 
547e cd 8e 15				call monitor 
5481 c3 7b 14				jp warmstart 
5484 76					halt 
5485			 
5485			 
5485 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
549c			 
549c d5			type_faults: 	push de 
549d e5					push hl 
549e cd 69 09				call clear_display 
54a1 11 c7 54				   ld de, .typefaults 
54a4 3e 00				ld a, display_row_1 
54a6 cd 7c 09				call str_at_display 
54a9 11 7a ee				    ld de, debug_mark 
54ac 3e 11				ld a, display_row_1+17 
54ae cd 7c 09				call str_at_display 
54b1 cd 8c 09				call update_display 
54b4			 
54b4				; prompt before entering montior for investigating issue 
54b4			 
54b4 3e 78			ld a, display_row_4 
54b6 11 3a 15			ld de, endprog 
54b9			 
54b9 cd 8c 09			call update_display		 
54bc			 
54bc cd 98 17			call next_page_prompt 
54bf			 
54bf e1					pop hl 
54c0 d1					pop de 
54c1 cd 8e 15				call monitor 
54c4 c3 7b 14				jp warmstart 
54c7			 
54c7			 
54c7 .. 00		.typefaults: db "STR Type Expected TOS!",0 
54de			 
54de			.show_fault: 	 
54de d5					push de 
54df cd 69 09				call clear_display 
54e2 d1					pop de 
54e3 3e 00				ld a, display_row_1 
54e5 cd 7c 09				call str_at_display 
54e8 11 7a ee				    ld de, debug_mark 
54eb 3e 11				ld a, display_row_1+17 
54ed cd 7c 09				call str_at_display 
54f0 cd 8c 09				call update_display 
54f3			 
54f3				; prompt before entering montior for investigating issue 
54f3			 
54f3 3e 78			ld a, display_row_4 
54f5 11 3a 15			ld de, endprog 
54f8			 
54f8 cd 8c 09			call update_display		 
54fb			 
54fb cd 98 17			call next_page_prompt 
54fe			 
54fe e1					pop hl 
54ff d1					pop de 
5500 cd 8e 15				call monitor 
5503			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5503			; TODO Make optional fault restart to cli or warm boot? 
5503					;jp warmstart 
5503 c3 d3 14				jp cli 
5506 76					halt 
5507			; eof 
# End of file forth_kernel.asm
5507			;include "nascombasic.asm" 
5507			 
5507			 
5507			; find out where the code ends if loaded into RAM (for SC114) 
5507			;endofcode:  
5507			;	nop 
5507			 
5507			 
5507			; eof 
5507			 
# End of file main.asm
5507			;include "firmware_lcd_4x40.asm" 
5507			;;include "firmware_lcd_4x20.asm" 
5507			include "firmware_cpm_display.asm" 
5507			 
5507			; Serial display interface for SC114 
5507			 
5507			 
5507			display_row_1: equ 0 
5507			display_row_2: equ display_row_1+display_cols 
5507			display_row_3: equ display_row_2 + display_cols 
5507			display_row_4: equ display_row_3 + display_cols 
5507			 
5507			kLCDWidth:  EQU display_cols             ;Width in characters 
5507			kLCD_Line1: EQU 0x00  
5507			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5507			; E1 
5507			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5507			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5507			 
5507			lcd_init: 
5507				; no init as handled by the SCM bios 
5507 c9				ret 
5508			 
5508			 
5508			; low level functions for direct screen writes 
5508			 
5508			; output char at pos? 
5508			fLCD_Str: 
5508			        ;out (SC114_SIO_1_OUT),a 
5508 c5				push bc 
5509 d5				push de 
550a 5f				ld e, a 
550b			; TODO Replace with CP/M BIOS call 
550b 0e 02			ld c, $02 
550d cd 05 00			call 5 
5510 d1				pop de 
5511 c1				pop bc 
5512 c9				ret 
5513			 
5513			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5513			fLCD_Pos: 
5513				; use ASCII escape to position 
5513			        ;out (SC114_SIO_1_OUT),a 
5513 c5				push bc 
5514 d5				push de 
5515 5f				ld e, a 
5516 0e 02			ld c, $02 
5518			; TODO Replace with CP/M BIOS call 
5518 cd 05 00			call 5 
551b d1				pop de 
551c c1				pop bc 
551d			 
551d c9				ret 
551e			 
551e			; output char at pos 
551e			fLCD_Data: 
551e			      ;  out (SC114_SIO_1_OUT),a 
551e c5				push bc 
551f d5				push de 
5520 0e 02			ld c, $02 
5522 5f				ld e, a 
5523			; TODO Replace with CP/M BIOS call 
5523 cd 05 00			call 5 
5526 d1				pop de 
5527 c1				pop bc 
5528			 
5528 c9				ret 
5529			 
5529			; ascii cls  
5529			 
5529 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
552d			 
552d 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5544			;.clscpm: db 3, $3c,"$" 
5544			 
5544			; write the frame buffer given in hl to hardware  
5544			write_display: 
5544			 
5544			API: equ 0 
5544			 
5544			if API 
5544				push bc 
5544				ld b, 4 
5544			 
5544			        ld (display_write_tmp), hl 	  
5544			 
5544				; clear and home cursor 
5544			 
5544				ld c, 9 
5544				ld de, .cls 
5544			; TODO Replace with CP/M BIOS call 
5544				call 5 
5544			 
5544			 
5544			.writeln: 
5544			 
5544				ld de, (display_write_tmp) 
5544				ld c, 6 
5544			; TODO Replace with CP/M BIOS call 
5544				rst $30 
5544				ld c, 7 
5544				rst $30 
5544			 
5544				ld hl, (display_write_tmp) 
5544				ld de, display_cols 
5544				add hl,de 
5544				ld (display_write_tmp),hl 
5544			 
5544				djnz  .writeln 
5544			 
5544				pop bc 
5544			 
5544			 
5544				ret 
5544			endif 
5544 e5				push hl 
5545 c5				push bc 
5546 d5				push de 
5547			 
5547			;	ld c, 2 
5547			;	;ld de, .cls 
5547			;	ld a, 27 
5547			;	rst $30 
5547			;	ld c, 2 
5547			;	;ld de, .cls 
5547			;	ld a, '[' 
5547			;	rst $30 
5547			; 
5547			;	ld c, 2 
5547			;	;ld de, .cls 
5547			;	ld a, 'H' 
5547			;	rst $30 
5547			; 
5547			 
5547			 
5547			; lots of CR/LF 
5547			;	ld c, 9 
5547			;	ld de, .clscpm 
5547			;	call 5 
5547			 
5547			; xterm cls 
5547 0e 02			ld c, 2 
5549 1e 1b			ld e, 27 
554b cd 05 00			call 5 
554e			; cls causes too much flicker 
554e			;	ld c, 2 
554e			;	ld e, 'c' 
554e			;	call 5 
554e			 
554e			; use xterm home instead 
554e 0e 02			ld c, 2 
5550 1e 5b			ld e, '[' 
5552 cd 05 00			call 5 
5555 0e 02			ld c, 2 
5557 1e 48			ld e, 'H' 
5559 cd 05 00			call 5 
555c			LLL: equ 0 
555c			 
555c			if LLL 
555c			 
555c				ld c, 2 
555c				;ld de, .cls 
555c				ld e, 27 
555c			; TODO Replace with CP/M BIOS call 
555c				call 5 
555c			 
555c			 
555c				ld c, 2 
555c				;ld de, .cls 
555c				ld e, '[' 
555c			; TODO Replace with CP/M BIOS call 
555c				call 5 
555c				ld c, 2 
555c				;ld de, .cls 
555c				ld e, '2' 
555c			; TODO Replace with CP/M BIOS call 
555c				call 5 
555c				ld c, 2 
555c				;ld de, .cls 
555c				ld e, 'J' 
555c			; TODO Replace with CP/M BIOS call 
555c				call 5 
555c			 
555c			endif 
555c			 
555c d1				pop de 
555d c1				pop bc 
555e e1				pop hl 
555f			 
555f			 
555f 22 d8 eb		        ld (display_write_tmp), hl 	  
5562 3e 00			ld a, kLCD_Line1 
5564			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5564 06 28			ld b, display_cols 
5566 ed 5b d8 eb		ld de, (display_write_tmp) 
556a cd ed 55			call write_len_string 
556d				 
556d			 
556d e5			push hl 
556e d5			push de 
556f c5			push bc 
5570 0e 02			ld c, 2 
5572 1e 0a			ld e, 10 
5574 cd 05 00			call 5 
5577 0e 02			ld c, 2 
5579 1e 0d			ld e, 13 
557b cd 05 00			call 5 
557e			; TODO Replace with CP/M BIOS call 
557e				;rst $30 
557e c1			pop bc 
557f d1			pop de 
5580 e1			pop hl 
5581			 
5581				 
5581 2a d8 eb			ld hl, (display_write_tmp) 
5584 11 28 00			ld de, display_cols 
5587 19				add hl,de 
5588 22 d8 eb			ld (display_write_tmp),hl 
558b			 
558b				 
558b 3e 28			ld a, kLCD_Line2 
558d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
558d 06 28			ld b, display_cols 
558f ed 5b d8 eb		ld de, (display_write_tmp) 
5593 cd ed 55			call write_len_string 
5596				 
5596 2a d8 eb			ld hl, (display_write_tmp) 
5599 11 28 00			ld de, display_cols 
559c 19				add hl,de 
559d 22 d8 eb			ld (display_write_tmp),hl 
55a0			 
55a0 e5			push hl 
55a1 d5			push de 
55a2 c5			push bc 
55a3 0e 07			ld c, 7 
55a5			; TODO Replace with CP/M BIOS call 
55a5				;rst $30 
55a5 0e 02			ld c, 2 
55a7 1e 0a			ld e, 10 
55a9 cd 05 00			call 5 
55ac 0e 02			ld c, 2 
55ae 1e 0d			ld e, 13 
55b0 cd 05 00			call 5 
55b3 c1			pop bc 
55b4 d1			pop de 
55b5 e1			pop hl 
55b6			 
55b6				 
55b6 3e 50			ld a, kLCD_Line3 
55b8			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
55b8 06 28			ld b, display_cols 
55ba ed 5b d8 eb		ld de, (display_write_tmp) 
55be cd ed 55			call write_len_string 
55c1				 
55c1 2a d8 eb			ld hl, (display_write_tmp) 
55c4 11 28 00			ld de, display_cols 
55c7 19				add hl,de 
55c8 22 d8 eb			ld (display_write_tmp),hl 
55cb			 
55cb e5			push hl 
55cc d5			push de 
55cd c5			push bc 
55ce 0e 07			ld c, 7 
55d0			; TODO Replace with CP/M BIOS call 
55d0				;rst $30 
55d0 0e 02			ld c, 2 
55d2 1e 0a			ld e, 10 
55d4 cd 05 00			call 5 
55d7 0e 02			ld c, 2 
55d9 1e 0d			ld e, 13 
55db cd 05 00			call 5 
55de c1			pop bc 
55df d1			pop de 
55e0 e1			pop hl 
55e1			 
55e1				 
55e1 3e 78			ld a, kLCD_Line4 
55e3			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
55e3 06 28			ld b, display_cols 
55e5 ed 5b d8 eb		ld de, (display_write_tmp) 
55e9 cd ed 55			call write_len_string 
55ec c9					ret 
55ed			 
55ed			 
55ed				; write out a fixed length string given in b from de 
55ed			 
55ed 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
55ee cd 1e 55		            CALL fLCD_Data      ;Write character to display 
55f1 13				inc de 
55f2 10 f9			djnz write_len_string 
55f4 c9				ret 
55f5			 
55f5			 
55f5			; eof 
# End of file firmware_cpm_display.asm
55f5			;include "firmware_key_5x10.asm" 
55f5			;;include "firmware_key_4x10.asm" 
55f5			include "firmware_key_cpm.asm" 
55f5			; Serial keyboard interface for SC114 
55f5			 
55f5			 
55f5			key_init: 
55f5				; no init as handled by the SCM bios 
55f5 c9				ret 
55f6			 
55f6			 
55f6			cin_wait: 
55f6			;	ld a, 0 
55f6			;	ret 
55f6			 
55f6				;in a,(SC114_SIO_1_IN) 
55f6			        ; Use SCM API to get from whatever console device we are using 
55f6			 
55f6			; TODO Replace with CP/M BIOS call 
55f6 c5				push bc 
55f7 0e 01			ld c, $01 
55f9 cd 05 00			call 5 
55fc c1				pop bc 
55fd c9				ret 
55fe			 
55fe			cin: 
55fe			 
55fe			 
55fe c5				push bc 
55ff			 
55ff				; any key waiting to process? 
55ff			; TODO Replace with CP/M BIOS call 
55ff 0e 06			ld c, $06 
5601 cd 05 00			call 5 
5604 28 0d			jr z, .cin_skip 
5606			 
5606				; yep, get it 
5606			 
5606 0e 01			ld c, $01 
5608			; TODO Replace with CP/M BIOS call 
5608 cd 05 00			call 5 
560b			 
560b fe 7f			cp $7f     ; back space 
560d 20 02			jr nz, .skipbs 
560f 3e 08			ld a, KEY_BS 
5611			.skipbs: 
5611			 
5611 c1				pop bc 
5612 c9				ret 
5613			.cin_skip: 
5613 3e 00			ld a, 0 
5615 c1				pop bc 
5616 c9				ret 
5617			 
5617			 
5617			 
5617			 
# End of file firmware_key_cpm.asm
5617			endofcode:  
5617			baseram:  
5617 00				nop 
5618			 
5618			heap_start: equ baseram+15  ; Starting address of heap 
5618			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5618			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5618			;VDU:  EQU     endofcode           ; BASIC Work space 
5618			; eof 
5618			 
# End of file os_mega_cpm.asm
5618
