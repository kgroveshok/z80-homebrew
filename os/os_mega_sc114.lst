# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 4f 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			if BASE_KEV = 1  
801c			 
801c				; need to be at $66 for nmi support 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255 
801c				jp nmi 
801c			endif 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 0       
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c			;	call break_point_state  
801c			; now use the break point debug vector  
801c				call debug_vector  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801c			  
801c			debug_mark: equ debug_vector - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_active-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			;os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_new_exec_ptr - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c			;	ld a, ' ' 
801c			;	ld (os_view_disable), a 
801c				call bp_on 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 10 ed				ld hl, display_fb1  
801f 22 cc eb				ld (display_fb_active), hl  
8022			  
8022 cd af 8a				call clear_display  
8025			  
8025 21 ce eb				ld hl, display_fb2  
8028 22 cc eb				ld (display_fb_active), hl  
802b			  
802b cd af 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b1 ed				ld hl, display_fb0  
8031 22 cc eb				ld (display_fb_active), hl  
8034			  
8034 cd af 8a				call clear_display  
8037			  
8037			  
8037 cd 85 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 27 e4			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 7f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd d2 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd b4 8a			call fill_display  
804e cd d2 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd b4 8a			call fill_display  
8059 cd d2 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd b4 8a			call fill_display  
8064 cd d2 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 ad 96			ld de, prom_bootmsg  
806f cd c2 8a			call str_at_display  
8072 cd d2 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 c2 96			ld de, prom_bootmsg1  
8080 cd c2 8a			call str_at_display  
8083 cd d2 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 6b ee		ld (debug_mark),a  
8091 32 6c ee		ld (debug_mark+1),a  
8094 32 6d ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 6e ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 73 ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 6b ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 6c ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 6d ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 6f ee			call debug_vector  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 7a ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 6b ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 6c ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 6d ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 6f ee			call debug_vector  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 7a ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 6b ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 6c ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 6d ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 6f ee			call debug_vector  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 05 8d				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 73 ea				ld hl, (store_tmp1) 
8110 11 7d ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 6b ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 6c ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 6d ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 6f ee			call debug_vector  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 72 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 6b ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 6c ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 6d ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 6f ee			call debug_vector  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 6b ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 6c ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 6d ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 6f ee			call debug_vector  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 6b ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 6c ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 6d ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 6f ee			call debug_vector  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 6b ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 6c ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 6d ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 6f ee			call debug_vector  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 05 8d			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 7a ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 6b ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 6c ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 6d ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 6f ee			call debug_vector  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 6b ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 6c ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 6d ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 6f ee			call debug_vector  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 7a ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 6b ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 6c ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 6d ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 7a ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 6f ee			call debug_vector  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 7b ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 6b ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 6c ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 6d ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 6f ee			call debug_vector  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 6b ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 6c ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 6d ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 6f ee			call debug_vector  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 7a ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 7b ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 7d ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 86 ea			ld hl, store_page+3+9 
82b5 3a 5f ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 7a ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 6b ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 6c ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 6d ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 6f ee			call debug_vector  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 6b ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 6c ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 6d ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 6f ee			call debug_vector  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd dc 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd dc 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 6b ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 6c ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 6d ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 6f ee			call debug_vector  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 7d ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 6b ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 6c ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 6d ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 6f ee			call debug_vector  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 7a ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 6b ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 6c ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 6d ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 6f ee			call debug_vector  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 6b ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 6c ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 6d ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 6f ee			call debug_vector  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 05 8d			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 7a ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 05 8d			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 6b ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 6c ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 6d ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 6f ee			call debug_vector  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 7a ea			ld a, (store_page)	; get file id 
8410 32 6e ea			ld (store_tmpid), a 
8413			 
8413 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8416 32 6d ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 7a ea			ld (store_page), a 
841f 32 7b ea			ld (store_page+1),a 
8422 11 7a ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 6b ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 6c ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 6d ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 6f ee			call debug_vector  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 6d ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 6e ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 6b ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 6c ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 6d ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 6f ee			call debug_vector  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 05 8d			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 7a ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 7a ea			ld (store_page), a 
8482 32 7b ea			ld (store_page+1),a 
8485 11 7a ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 6b ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 6c ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 6d ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 6f ee			call debug_vector  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 6b ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 6c ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 6d ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 6f ee			call debug_vector  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd fa 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd dc 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd fa 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd dc 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 6b ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 6c ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 6d ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 6f ee			call debug_vector  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 6b ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 6c ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 6d ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 6f ee			call debug_vector  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd dc 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd dc 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 6b ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 6c ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 6d ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 6f ee			call debug_vector  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 7a ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 7a ea			ld (store_page),a 
85a3				 
85a3 32 6e ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 7a ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 6b ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 6c ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 6d ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 6f ee			call debug_vector  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 7a ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 6b ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 6c ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 6d ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 6f ee			call debug_vector  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 6b ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 6c ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 6d ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 6f ee			call debug_vector  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 65 ea			ld (store_tmppageid), hl 
8615				 
8615 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 7a ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 7b ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 6b ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 6c ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 6d ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 6f ee			call debug_vector  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 45 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 6b ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 6c ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 6d ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 6f ee			call debug_vector  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 6b ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 6c ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 6d ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 6f ee			call debug_vector  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 65 ea			ld hl,(store_tmppageid) 
868b 11 7a ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 6b ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 6c ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 6d ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 6f ee			call debug_vector  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 6e ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 6b ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 6c ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 6d ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 6f ee			call debug_vector  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 6b ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 6c ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 6d ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd 6f ee			call debug_vector  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 6b ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 6c ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 6d ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd 6f ee			call debug_vector  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 05 8d			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 6b ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 6b ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 6c ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 6d ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd 6f ee			call debug_vector  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd dc 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 6d ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 6b ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 6c ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 6d ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd 6f ee			call debug_vector  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 75 ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd dc 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 6b ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 6c ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 6d ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd 6f ee			call debug_vector  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 6b ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 6c ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 6d ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd 6f ee			call debug_vector  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 6b ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 6c ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 6d ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd 6f ee			call debug_vector  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd 05 8d			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 6b ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 6b ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 6c ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 6d ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd 6f ee			call debug_vector  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 6b ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 6c ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 6d ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd 6f ee			call debug_vector  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 6b ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 6c ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 6d ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd 6f ee			call debug_vector  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 6b ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 6c ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 6d ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd 6f ee			call debug_vector  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 6e ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 6e ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd 05 8d			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 65 ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 6b ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 6c ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 6d ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd 6f ee			call debug_vector  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 7a ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 6b ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 6c ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 6d ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd 6f ee			call debug_vector  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 7c ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 7c ea			ld (store_page+2), a 
88e3 32 6d ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 6b ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 6c ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 6d ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd 6f ee			call debug_vector  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 65 ea			ld hl, (store_tmppageid) 
8905 11 7a ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd 05 8d			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 65 ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 6b ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 6c ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 6d ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd 6f ee			call debug_vector  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 7a ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 6e ea				ld a, (store_tmpid) 
894b 32 7a ea				ld (store_page), a   ; file id 
894e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 7b ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 7c ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 6b ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 6c ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 6d ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd 6f ee			call debug_vector  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 65 ea			ld hl, (store_tmppageid) 
8985 11 7a ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 6b ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 6c ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 6d ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 6f ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 6e ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 7a ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 7b ea			ld de, store_page+1 
89c1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; Display an activity indicator 
8a06			; Each call returns the new char pointed to in hl 
8a06			 
8a06			active: 
8a06 3a c6 eb			ld a, (display_active) 
8a09 fe 06			cp 6 
8a0b			 
8a0b 20 02			jr nz, .sne 
8a0d				; gone past the last one reset sequence 
8a0d 3e ff			ld a, 255 
8a0f			 
8a0f			.sne:   
8a0f				; get the next char in seq 
8a0f 3c				inc a 
8a10 32 c6 eb			ld (display_active), a 
8a13			 
8a13				; look up the string in the table 
8a13 21 2a 8a			ld hl, actseq 
8a16 cb 27			sla a 
8a18 cd dc 8c			call addatohl 
8a1b cd 7a 9e			call loadwordinhl 
8a1e			 
8a1e				; forth will write the to string when pushing so move from rom to ram 
8a1e			 
8a1e 11 c7 eb			ld de, display_active+1 
8a21 01 02 00			ld bc, 2 
8a24 ed b0			ldir 
8a26			 
8a26 21 c7 eb			ld hl, display_active+1 
8a29 c9				ret 
8a2a				 
8a2a				 
8a2a			 
8a2a			 
8a2a			;db "|/-\|-\" 
8a2a			 
8a2a			actseq: 
8a2a			 
8a2a 38 8a		dw spin0 
8a2c 3a 8a		dw spin1 
8a2e 3c 8a		dw spin2 
8a30 3e 8a		dw spin3 
8a32 3c 8a		dw spin2 
8a34 3a 8a		dw spin1 
8a36 38 8a		dw spin0 
8a38			 
8a38 .. 00		spin0: db " ", 0 
8a3a .. 00		spin1: db "-", 0 
8a3c .. 00		spin2: db "+", 0 
8a3e .. 00		spin3: db "#", 0 
8a40			 
8a40			 
8a40			; information window 
8a40			 
8a40			; pass hl with 1st string to display 
8a40			; pass de with 2nd string to display 
8a40			 
8a40			info_panel: 
8a40 e5				push hl 
8a41			 
8a41 2a cc eb			ld hl, (display_fb_active) 
8a44 e5				push hl    ; future de destination 
8a45 21 b1 ed				ld hl, display_fb0 
8a48 22 cc eb				ld (display_fb_active), hl 
8a4b			 
8a4b			;	call clear_display 
8a4b			 
8a4b				if BASE_CPM 
8a4b				ld a, '.' 
8a4b				else 
8a4b 3e a5			ld a, 165 
8a4d				endif 
8a4d cd b4 8a			call fill_display 
8a50			 
8a50			 
8a50 3e 55			ld a, display_row_3 + 5 
8a52 cd c2 8a			call str_at_display 
8a55			 
8a55 e1				pop hl 
8a56 d1				pop de 
8a57			 
8a57 e5				push hl 
8a58			 
8a58			 
8a58 3e 2d			ld a, display_row_2 + 5 
8a5a cd c2 8a			call str_at_display 
8a5d			 
8a5d			 
8a5d cd d2 8a			call update_display 
8a60 cd c3 9a			call next_page_prompt 
8a63 cd af 8a			call clear_display 
8a66			 
8a66				 
8a66 21 10 ed				ld hl, display_fb1 
8a69 22 cc eb				ld (display_fb_active), hl 
8a6c cd d2 8a			call update_display 
8a6f			 
8a6f e1				pop hl 
8a70			 
8a70 c9				ret 
8a71			 
8a71			 
8a71			 
8a71			 
8a71			; TODO windowing? 
8a71			 
8a71			; TODO scroll line up 
8a71			 
8a71			scroll_up: 
8a71			 
8a71 e5				push hl 
8a72 d5				push de 
8a73 c5				push bc 
8a74			 
8a74				; get frame buffer  
8a74			 
8a74 2a cc eb			ld hl, (display_fb_active) 
8a77 e5				push hl    ; future de destination 
8a78			 
8a78 11 28 00			ld  de, display_cols 
8a7b 19				add hl, de 
8a7c			 
8a7c d1				pop de 
8a7d			 
8a7d				;ex de, hl 
8a7d 01 9f 00			ld bc, display_fb_len -1  
8a80			;if DEBUG_FORTH_WORDS 
8a80			;	DMARK "SCL" 
8a80			;	CALLMONITOR 
8a80			;endif	 
8a80 ed b0			ldir 
8a82			 
8a82				; wipe bottom row 
8a82			 
8a82			 
8a82 2a cc eb			ld hl, (display_fb_active) 
8a85 11 a0 00			ld de, display_cols*display_rows 
8a88 19				add hl, de 
8a89 06 28			ld b, display_cols 
8a8b 3e 20			ld a, ' ' 
8a8d			.scwipe: 
8a8d 77				ld (hl), a 
8a8e 2b				dec hl 
8a8f 10 fc			djnz .scwipe 
8a91			 
8a91				;pop hl 
8a91			 
8a91 c1				pop bc 
8a92 d1				pop de 
8a93 e1				pop hl 
8a94			 
8a94 c9				ret 
8a95			 
8a95			 
8a95			;scroll_upo: 
8a95			;	ld de, display_row_1 
8a95			 ;	ld hl, display_row_2 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_2 
8a95			 ;	ld hl, display_row_3 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_3 
8a95			 ;	ld hl, display_row_4 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			 
8a95			; TODO clear row 4 
8a95			 
8a95			;	ret 
8a95			 
8a95				 
8a95			scroll_down: 
8a95			 
8a95 e5				push hl 
8a96 d5				push de 
8a97 c5				push bc 
8a98			 
8a98				; get frame buffer  
8a98			 
8a98 2a cc eb			ld hl, (display_fb_active) 
8a9b			 
8a9b 11 9f 00			ld de, display_fb_len - 1 
8a9e 19				add hl, de 
8a9f			 
8a9f e5			push hl    ; future de destination 
8aa0			 
8aa0 11 28 00			ld  de, display_cols 
8aa3 ed 52			sbc hl, de 
8aa5			 
8aa5			 
8aa5 d1				pop de 
8aa6			 
8aa6			;	ex de, hl 
8aa6 01 9f 00			ld bc, display_fb_len -1  
8aa9			 
8aa9			 
8aa9				 
8aa9			 
8aa9 ed b0			ldir 
8aab			 
8aab				; wipe bottom row 
8aab			 
8aab			 
8aab			;	ld hl, (display_fb_active) 
8aab			;;	ld de, display_cols*display_rows 
8aab			;;	add hl, de 
8aab			;	ld b, display_cols 
8aab			;	ld a, ' ' 
8aab			;.scwiped: 
8aab			;	ld (hl), a 
8aab			;	dec hl 
8aab			;	djnz .scwiped 
8aab			 
8aab				;pop hl 
8aab			 
8aab c1				pop bc 
8aac d1				pop de 
8aad e1				pop hl 
8aae			 
8aae c9				ret 
8aaf			;scroll_down: 
8aaf			;	ld de, display_row_4 
8aaf			;	ld hl, display_row_3 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_3 
8aaf			; 	ld hl, display_row_2 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_2 
8aaf			;	ld hl, display_row_1 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;;; TODO clear row 1 
8aaf			;	ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			; clear active frame buffer 
8aaf			 
8aaf			clear_display: 
8aaf 3e 20			ld a, ' ' 
8ab1 c3 b4 8a			jp fill_display 
8ab4			 
8ab4			; fill active frame buffer with a char in A 
8ab4			 
8ab4			fill_display: 
8ab4 06 a0			ld b,display_fb_len 
8ab6 2a cc eb			ld hl, (display_fb_active) 
8ab9 77			.fd1:	ld (hl),a 
8aba 23				inc hl 
8abb 10 fc			djnz .fd1 
8abd 23				inc hl 
8abe 3e 00			ld a,0 
8ac0 77				ld (hl),a 
8ac1			 
8ac1			 
8ac1 c9				ret 
8ac2			; Write string (DE) at pos (A) to active frame buffer 
8ac2			 
8ac2 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac5 06 00					ld b,0 
8ac7 4f					ld c,a 
8ac8 09					add hl,bc 
8ac9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8aca b7			            OR   A              ;Null terminator? 
8acb c8			            RET  Z              ;Yes, so finished 
8acc 77					ld (hl),a 
8acd 23				inc hl 
8ace 13			            INC  DE             ;Point to next character 
8acf 18 f8		            JR   .sad1     ;Repeat 
8ad1 c9					ret 
8ad2			 
8ad2			; using current frame buffer write to physical display 
8ad2			 
8ad2			update_display: 
8ad2 e5				push hl 
8ad3 2a cc eb			ld hl, (display_fb_active) 
8ad6 cd 9c e3			call write_display 
8ad9 e1				pop hl 
8ada c9				ret 
8adb			 
8adb			; TODO scrolling 
8adb			 
8adb			 
8adb			; move cursor right one char 
8adb			cursor_right: 
8adb			 
8adb				; TODO shift right 
8adb				; TODO if beyond max col 
8adb				; TODO       cursor_next_line 
8adb			 
8adb c9				ret 
8adc			 
8adc			 
8adc			cursor_next_line: 
8adc				; TODO first char 
8adc				; TODO line down 
8adc				; TODO if past last row 
8adc				; TODO    scroll up 
8adc			 
8adc c9				ret 
8add			 
8add			cursor_left: 
8add				; TODO shift left 
8add				; TODO if beyond left  
8add				; TODO     cursor prev line 
8add				 
8add c9				ret 
8ade			 
8ade			cursor_prev_line: 
8ade				; TODO last char 
8ade				; TODO line up 
8ade				; TODO if past first row 
8ade				; TODO   scroll down 
8ade			 
8ade c9				ret 
8adf			 
8adf			 
8adf			cout: 
8adf				; A - char 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			; Display a menu and allow item selection (optional toggle items) 
8ae0			; 
8ae0			; format: 
8ae0			; hl pointer to word array with zero term for items 
8ae0			; e.g.    db item1 
8ae0			;         db .... 
8ae0			;         db 0 
8ae0			; 
8ae0			; a = starting menu item  
8ae0			; 
8ae0			; de = pointer item toggle array   (todo) 
8ae0			; 
8ae0			; returns item selected in a 1-... 
8ae0			; returns 0 if back button pressed 
8ae0			; 
8ae0			; NOTE: Uses system frame buffer to display 
8ae0			; 
8ae0			; LEFT, Q = go back 
8ae0			; RIGHT, SPACE, CR = select 
8ae0			; UP, A - Up 
8ae0			; DOWN, Z - Down 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			menu: 
8ae0			 
8ae0					; keep array pointer 
8ae0			 
8ae0 22 73 ea				ld (store_tmp1), hl 
8ae3 32 71 ea				ld (store_tmp2), a 
8ae6			 
8ae6					; check for key bounce 
8ae6			 
8ae6			if BASE_KEV 
8ae6			 
8ae6			.mbounce:	call cin 
8ae6					cp 0 
8ae6					jr nz, .mbounce 
8ae6			endif 
8ae6					; for ease use ex 
8ae6			 
8ae6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae6 21 b1 ed				ld hl, display_fb0 
8ae9 22 cc eb				ld (display_fb_active), hl 
8aec			 
8aec cd af 8a		.mloop:		call clear_display 
8aef cd d2 8a				call update_display 
8af2			 
8af2					; draw selection id '>' at 1 
8af2			 
8af2					; init start of list display 
8af2			 
8af2 3e 05				ld a, 5 
8af4 32 6f ea				ld (store_tmp3), a   ; display row count 
8af7 3a 71 ea				ld a,( store_tmp2) 
8afa 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afd			 
8afd					 
8afd			.mitem:	 
8afd			 
8afd			 
8afd 3a 72 ea				ld a,(store_tmp2+1) 
8b00 6f					ld l, a 
8b01 26 00				ld h, 0 
8b03 29					add hl, hl 
8b04 ed 5b 73 ea			ld de, (store_tmp1) 
8b08 19					add hl, de 
8b09 7e					ld a, (hl) 
8b0a 23					inc hl 
8b0b 66					ld h,(hl) 
8b0c 6f					ld l, a 
8b0d			 
8b0d cd 05 8d				call ishlzero 
8b10 28 1a				jr z, .mdone 
8b12			 
8b12 eb					ex de, hl 
8b13 3a 6f ea				ld a, (store_tmp3) 
8b16 cd c2 8a				call str_at_display 
8b19					 
8b19			 
8b19					; next item 
8b19 3a 72 ea				ld a, (store_tmp2+1) 
8b1c 3c					inc a 
8b1d 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b20			 
8b20			 		; next row 
8b20			 
8b20 3a 6f ea				ld a, (store_tmp3) 
8b23 c6 28				add display_cols 
8b25 32 6f ea				ld (store_tmp3), a 
8b28			 
8b28					; at end of screen? 
8b28			 
8b28 fe 10				cp display_rows*4 
8b2a 20 d1				jr nz, .mitem 
8b2c			 
8b2c			 
8b2c			.mdone: 
8b2c cd 05 8d				call ishlzero 
8b2f 28 08				jr z, .nodn 
8b31			 
8b31 3e 78				ld a, display_row_4 
8b33 11 b2 8b				ld de, .mdown 
8b36 cd c2 8a				call str_at_display 
8b39			 
8b39					; draw options to fill the screens with active item on line 1 
8b39					; if current option is 2 or more then display ^ in top 
8b39			 
8b39 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3c fe 00				cp 0 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 b0 8b				ld de, .mup 
8b45 cd c2 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ae 8b				ld de, .msel 
8b4d cd c2 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d2 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd 28 e4				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 32				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2e				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 34				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 30				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2c				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ec 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1d			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 71 ea				ld a, (store_tmp2) 
8b88 fe 00				cp 0 
8b8a ca ec 8a				jp z, .mloop 
8b8d 3d					dec a 
8b8e 32 71 ea				ld (store_tmp2), a 
8b91 c3 ec 8a				jp .mloop 
8b94			 
8b94				; move down one 
8b94			.mgod: 
8b94 3a 71 ea				ld a, (store_tmp2) 
8b97 3c					inc a 
8b98 32 71 ea				ld (store_tmp2), a 
8b9b c3 ec 8a				jp .mloop 
8b9e			 
8b9e			 
8b9e			.goend: 
8b9e					; get selected item number 
8b9e			 
8b9e 3a 71 ea				ld a, (store_tmp2) 
8ba1 3c					inc a 
8ba2			 
8ba2			.goend2: 
8ba2 f5					push af 
8ba3			 
8ba3					; restore active fb 
8ba3					; TODO BUG assumes fb1 
8ba3			 
8ba3 21 10 ed				ld hl, display_fb1 
8ba6 22 cc eb				ld (display_fb_active), hl 
8ba9			 
8ba9					; restore main regs 
8ba9			 
8ba9			 
8ba9 cd d2 8a				call update_display 
8bac			 
8bac f1					pop af 
8bad			 
8bad c9				ret 
8bae			 
8bae .. 00		.msel:   db ">",0 
8bb0 .. 00		.mup:   db "^",0 
8bb2 .. 00		.mdown:   db "v",0 
8bb4			 
8bb4			 
8bb4			; eof 
8bb4			 
# End of file firmware_display.asm
8bb4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb4			; random number generators 
8bb4			 
8bb4			 
8bb4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb4			 
8bb4			 
8bb4			;-----> Generate a random number 
8bb4			; output a=answer 0<=a<=255 
8bb4			; all registers are preserved except: af 
8bb4			random: 
8bb4 e5			        push    hl 
8bb5 d5			        push    de 
8bb6 2a ab eb		        ld      hl,(randData) 
8bb9 ed 5f		        ld      a,r 
8bbb 57			        ld      d,a 
8bbc 5e			        ld      e,(hl) 
8bbd 19			        add     hl,de 
8bbe 85			        add     a,l 
8bbf ac			        xor     h 
8bc0 22 ab eb		        ld      (randData),hl 
8bc3 d1			        pop     de 
8bc4 e1			        pop     hl 
8bc5 c9			        ret 
8bc6			 
8bc6			 
8bc6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc6			 
8bc6			 
8bc6			 
8bc6			;------LFSR------ 
8bc6			;James Montelongo 
8bc6			;optimized by Spencer Putt 
8bc6			;out: 
8bc6			; a = 8 bit random number 
8bc6			RandLFSR: 
8bc6 21 b1 eb		        ld hl,LFSRSeed+4 
8bc9 5e			        ld e,(hl) 
8bca 23			        inc hl 
8bcb 56			        ld d,(hl) 
8bcc 23			        inc hl 
8bcd 4e			        ld c,(hl) 
8bce 23			        inc hl 
8bcf 7e			        ld a,(hl) 
8bd0 47			        ld b,a 
8bd1 cb 13		        rl e  
8bd3 cb 12			rl d 
8bd5 cb 11		        rl c  
8bd7 17				rla 
8bd8 cb 13		        rl e  
8bda cb 12			rl d 
8bdc cb 11		        rl c  
8bde 17				rla 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 67			        ld h,a 
8be7 cb 13		        rl e  
8be9 cb 12			rl d 
8beb cb 11		        rl c  
8bed 17				rla 
8bee a8			        xor b 
8bef cb 13		        rl e  
8bf1 cb 12			rl d 
8bf3 ac			        xor h 
8bf4 a9			        xor c 
8bf5 aa			        xor d 
8bf6 21 b3 eb		        ld hl,LFSRSeed+6 
8bf9 11 b4 eb		        ld de,LFSRSeed+7 
8bfc 01 07 00		        ld bc,7 
8bff ed b8		        lddr 
8c01 12			        ld (de),a 
8c02 c9			        ret 
8c03			 
8c03			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c03			 
8c03			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c03			 
8c03			 
8c03			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c03			 
8c03			prng16: 
8c03			;Inputs: 
8c03			;   (seed1) contains a 16-bit seed value 
8c03			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c03			;Outputs: 
8c03			;   HL is the result 
8c03			;   BC is the result of the LCG, so not that great of quality 
8c03			;   DE is preserved 
8c03			;Destroys: 
8c03			;   AF 
8c03			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c03			;160cc 
8c03			;26 bytes 
8c03 2a a5 eb		    ld hl,(seed1) 
8c06 44			    ld b,h 
8c07 4d			    ld c,l 
8c08 29			    add hl,hl 
8c09 29			    add hl,hl 
8c0a 2c			    inc l 
8c0b 09			    add hl,bc 
8c0c 22 a5 eb		    ld (seed1),hl 
8c0f 2a a3 eb		    ld hl,(seed2) 
8c12 29			    add hl,hl 
8c13 9f			    sbc a,a 
8c14 e6 2d		    and %00101101 
8c16 ad			    xor l 
8c17 6f			    ld l,a 
8c18 22 a3 eb		    ld (seed2),hl 
8c1b 09			    add hl,bc 
8c1c c9			    ret 
8c1d			 
8c1d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1d			 
8c1d			rand32: 
8c1d			;Inputs: 
8c1d			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1d			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1d			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1d			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1d			;   **NOTE: seed2 must be non-zero 
8c1d			;Outputs: 
8c1d			;   HL is the result 
8c1d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1d			;Destroys: 
8c1d			;   AF 
8c1d			;Tested and passes all CAcert tests 
8c1d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1d			;it has a period of 18,446,744,069,414,584,320 
8c1d			;roughly 18.4 quintillion. 
8c1d			;LFSR taps: 0,2,6,7  = 11000101 
8c1d			;291cc 
8c1d			;seed1_0=$+1 
8c1d			;    ld hl,12345 
8c1d			;seed1_1=$+1 
8c1d			;    ld de,6789 
8c1d			;    ld b,h 
8c1d			;    ld c,l 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    inc l 
8c1d			;    add hl,bc 
8c1d			;    ld (seed1_0),hl 
8c1d			;    ld hl,(seed1_1) 
8c1d			;    adc hl,de 
8c1d			;    ld (seed1_1),hl 
8c1d			;    ex de,hl 
8c1d			;seed2_0=$+1 
8c1d			;    ld hl,9876 
8c1d			;seed2_1=$+1 
8c1d			;    ld bc,54321 
8c1d			;    add hl,hl \ rl c \ rl b 
8c1d			;    ld (seed2_1),bc 
8c1d			;    sbc a,a 
8c1d			;    and %11000101 
8c1d			;    xor l 
8c1d			;    ld l,a 
8c1d			;    ld (seed2_0),hl 
8c1d			;    ex de,hl 
8c1d			;    add hl,bc 
8c1d			;    ret 
8c1d			; 
8c1d			 
8c1d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1d			; 20 bytes, 86 cycles (excluding ret) 
8c1d			 
8c1d			; returns   hl = pseudorandom number 
8c1d			; corrupts   a 
8c1d			 
8c1d			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1d			; using the xorshift method: 
8c1d			 
8c1d			; hl ^= hl << 7 
8c1d			; hl ^= hl >> 9 
8c1d			; hl ^= hl << 8 
8c1d			 
8c1d			; some alternative shift triplets which also perform well are: 
8c1d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1d			 
8c1d			;  org 32768 
8c1d			 
8c1d			xrnd: 
8c1d 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c20 3e 00		  ld a,0 
8c22 bd			  cp l 
8c23 20 02		  jr nz, .xrnd1 
8c25 2e 01		  ld l, 1 
8c27			.xrnd1: 
8c27			 
8c27 7c			  ld a,h 
8c28 1f			  rra 
8c29 7d			  ld a,l 
8c2a 1f			  rra 
8c2b ac			  xor h 
8c2c 67			  ld h,a 
8c2d 7d			  ld a,l 
8c2e 1f			  rra 
8c2f 7c			  ld a,h 
8c30 1f			  rra 
8c31 ad			  xor l 
8c32 6f			  ld l,a 
8c33 ac			  xor h 
8c34 67			  ld h,a 
8c35			 
8c35 22 a9 eb		  ld (xrandc),hl 
8c38			 
8c38 c9			  ret 
8c39			;  
8c39			 
8c39			 
8c39			;;;; int maths 
8c39			 
8c39			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c39			; Divide 16-bit values (with 16-bit result) 
8c39			; In: Divide BC by divider DE 
8c39			; Out: BC = result, HL = rest 
8c39			; 
8c39			Div16: 
8c39 21 00 00		    ld hl,0 
8c3c 78			    ld a,b 
8c3d 06 08		    ld b,8 
8c3f			Div16_Loop1: 
8c3f 17			    rla 
8c40 ed 6a		    adc hl,hl 
8c42 ed 52		    sbc hl,de 
8c44 30 01		    jr nc,Div16_NoAdd1 
8c46 19			    add hl,de 
8c47			Div16_NoAdd1: 
8c47 10 f6		    djnz Div16_Loop1 
8c49 17			    rla 
8c4a 2f			    cpl 
8c4b 47			    ld b,a 
8c4c 79			    ld a,c 
8c4d 48			    ld c,b 
8c4e 06 08		    ld b,8 
8c50			Div16_Loop2: 
8c50 17			    rla 
8c51 ed 6a		    adc hl,hl 
8c53 ed 52		    sbc hl,de 
8c55 30 01		    jr nc,Div16_NoAdd2 
8c57 19			    add hl,de 
8c58			Div16_NoAdd2: 
8c58 10 f6		    djnz Div16_Loop2 
8c5a 17			    rla 
8c5b 2f			    cpl 
8c5c 41			    ld b,c 
8c5d 4f			    ld c,a 
8c5e c9			ret 
8c5f			 
8c5f			 
8c5f			;http://z80-heaven.wikidot.com/math 
8c5f			; 
8c5f			;Inputs: 
8c5f			;     DE and A are factors 
8c5f			;Outputs: 
8c5f			;     A is not changed 
8c5f			;     B is 0 
8c5f			;     C is not changed 
8c5f			;     DE is not changed 
8c5f			;     HL is the product 
8c5f			;Time: 
8c5f			;     342+6x 
8c5f			; 
8c5f			Mult16: 
8c5f			 
8c5f 06 08		     ld b,8          ;7           7 
8c61 21 00 00		     ld hl,0         ;10         10 
8c64 29			       add hl,hl     ;11*8       88 
8c65 07			       rlca          ;4*8        32 
8c66 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c68 19			         add hl,de   ;--         -- 
8c69 10 f9		       djnz $-5      ;13*7+8     99 
8c6b c9			ret 
8c6c			 
8c6c			; 
8c6c			; Square root of 16-bit value 
8c6c			; In:  HL = value 
8c6c			; Out:  D = result (rounded down) 
8c6c			; 
8c6c			;Sqr16: 
8c6c			;    ld de,#0040 
8c6c			;    ld a,l 
8c6c			;    ld l,h 
8c6c			;    ld h,d 
8c6c			;    or a 
8c6c			;    ld b,8 
8c6c			;Sqr16_Loop: 
8c6c			;    sbc hl,de 
8c6c			;    jr nc,Sqr16_Skip 
8c6c			;    add hl,de 
8c6c			;Sqr16_Skip: 
8c6c			;    ccf 
8c6c			;    rl d 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    djnz Sqr16_Loop 
8c6c			;    ret 
8c6c			; 
8c6c			; 
8c6c			; Divide 8-bit values 
8c6c			; In: Divide E by divider C 
8c6c			; Out: A = result, B = rest 
8c6c			; 
8c6c			Div8: 
8c6c af			    xor a 
8c6d 06 08		    ld b,8 
8c6f			Div8_Loop: 
8c6f cb 13		    rl e 
8c71 17			    rla 
8c72 91			    sub c 
8c73 30 01		    jr nc,Div8_NoAdd 
8c75 81			    add a,c 
8c76			Div8_NoAdd: 
8c76 10 f7		    djnz Div8_Loop 
8c78 47			    ld b,a 
8c79 7b			    ld a,e 
8c7a 17			    rla 
8c7b 2f			    cpl 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7d			; In: Multiply A with DE 
8c7d			; Out: HL = result 
8c7d			; 
8c7d			Mult12U: 
8c7d 2e 00		    ld l,0 
8c7f 87			    add a,a 
8c80 30 01		    jr nc,Mult12U_NoAdd0 
8c82 19			    add hl,de 
8c83			Mult12U_NoAdd0: 
8c83 29			    add hl,hl 
8c84 87			    add a,a 
8c85 30 01		    jr nc,Mult12U_NoAdd1 
8c87 19			    add hl,de 
8c88			Mult12U_NoAdd1: 
8c88 29			    add hl,hl 
8c89 87			    add a,a 
8c8a 30 01		    jr nc,Mult12U_NoAdd2 
8c8c 19			    add hl,de 
8c8d			Mult12U_NoAdd2: 
8c8d 29			    add hl,hl 
8c8e 87			    add a,a 
8c8f 30 01		    jr nc,Mult12U_NoAdd3 
8c91 19			    add hl,de 
8c92			Mult12U_NoAdd3: 
8c92 29			    add hl,hl 
8c93 87			    add a,a 
8c94 30 01		    jr nc,Mult12U_NoAdd4 
8c96 19			    add hl,de 
8c97			Mult12U_NoAdd4: 
8c97 29			    add hl,hl 
8c98 87			    add a,a 
8c99 30 01		    jr nc,Mult12U_NoAdd5 
8c9b 19			    add hl,de 
8c9c			Mult12U_NoAdd5: 
8c9c 29			    add hl,hl 
8c9d 87			    add a,a 
8c9e 30 01		    jr nc,Mult12U_NoAdd6 
8ca0 19			    add hl,de 
8ca1			Mult12U_NoAdd6: 
8ca1 29			    add hl,hl 
8ca2 87			    add a,a 
8ca3 d0			    ret nc 
8ca4 19			    add hl,de 
8ca5 c9			    ret 
8ca6			 
8ca6			; 
8ca6			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca6			; In: Multiply A with DE 
8ca6			;      Put lowest value in A for most efficient calculation 
8ca6			; Out: HL = result 
8ca6			; 
8ca6			Mult12R: 
8ca6 21 00 00		    ld hl,0 
8ca9			Mult12R_Loop: 
8ca9 cb 3f		    srl a 
8cab 30 01		    jr nc,Mult12R_NoAdd 
8cad 19			    add hl,de 
8cae			Mult12R_NoAdd: 
8cae cb 23		    sla e 
8cb0 cb 12		    rl d 
8cb2 b7			    or a 
8cb3 c2 a9 8c		    jp nz,Mult12R_Loop 
8cb6 c9			    ret 
8cb7			 
8cb7			; 
8cb7			; Multiply 16-bit values (with 32-bit result) 
8cb7			; In: Multiply BC with DE 
8cb7			; Out: BCHL = result 
8cb7			; 
8cb7			Mult32: 
8cb7 79			    ld a,c 
8cb8 48			    ld c,b 
8cb9 21 00 00		    ld hl,0 
8cbc 06 10		    ld b,16 
8cbe			Mult32_Loop: 
8cbe 29			    add hl,hl 
8cbf 17			    rla 
8cc0 cb 11		    rl c 
8cc2 30 07		    jr nc,Mult32_NoAdd 
8cc4 19			    add hl,de 
8cc5 ce 00		    adc a,0 
8cc7 d2 cb 8c		    jp nc,Mult32_NoAdd 
8cca 0c			    inc c 
8ccb			Mult32_NoAdd: 
8ccb 10 f1		    djnz Mult32_Loop 
8ccd 41			    ld b,c 
8cce 4f			    ld c,a 
8ccf c9			    ret 
8cd0			 
8cd0			 
8cd0			 
8cd0			; 
8cd0			; Multiply 8-bit values 
8cd0			; In:  Multiply H with E 
8cd0			; Out: HL = result 
8cd0			; 
8cd0			Mult8: 
8cd0 16 00		    ld d,0 
8cd2 6a			    ld l,d 
8cd3 06 08		    ld b,8 
8cd5			Mult8_Loop: 
8cd5 29			    add hl,hl 
8cd6 30 01		    jr nc,Mult8_NoAdd 
8cd8 19			    add hl,de 
8cd9			Mult8_NoAdd: 
8cd9 10 fa		    djnz Mult8_Loop 
8cdb c9			    ret 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			;;http://z80-heaven.wikidot.com/math 
8cdc			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdc			; 
8cdc			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdc			;     ld a,16        ;7 
8cdc			;     ld hl,0        ;10 
8cdc			;     jp $+5         ;10 
8cdc			;.DivLoop: 
8cdc			;       add hl,bc    ;-- 
8cdc			;       dec a        ;64 
8cdc			;       jr z,.DivLoopEnd        ;86 
8cdc			; 
8cdc			;       sla e        ;128 
8cdc			;       rl d         ;128 
8cdc			;       adc hl,hl    ;240 
8cdc			;       sbc hl,bc    ;240 
8cdc			;       jr nc,.DivLoop ;23|21 
8cdc			;       inc e        ;-- 
8cdc			;       jp .DivLoop+1 
8cdc			; 
8cdc			;.DivLoopEnd: 
8cdc			 
8cdc			;HL_Div_C: 
8cdc			;Inputs: 
8cdc			;     HL is the numerator 
8cdc			;     C is the denominator 
8cdc			;Outputs: 
8cdc			;     A is the remainder 
8cdc			;     B is 0 
8cdc			;     C is not changed 
8cdc			;     DE is not changed 
8cdc			;     HL is the quotient 
8cdc			; 
8cdc			;       ld b,16 
8cdc			;       xor a 
8cdc			;         add hl,hl 
8cdc			;         rla 
8cdc			;         cp c 
8cdc			;         jr c,$+4 
8cdc			;           inc l 
8cdc			;           sub c 
8cdc			;         djnz $-7 
8cdc			 
8cdc			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdc			 
8cdc			addatohl: 
8cdc 85			    add   a, l    ; A = A+L 
8cdd 6f			    ld    l, a    ; L = A+L 
8cde 8c			    adc   a, h    ; A = A+L+H+carry 
8cdf 95			    sub   l       ; A = H+carry 
8ce0 67			    ld    h, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			addatode: 
8ce2 83			    add   a, e    ; A = A+L 
8ce3 5f			    ld    e, a    ; L = A+L 
8ce4 8a			    adc   a, d    ; A = A+L+H+carry 
8ce5 93			    sub   e       ; A = H+carry 
8ce6 57			    ld    d, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			 
8ce8			addatobc: 
8ce8 81			    add   a, c    ; A = A+L 
8ce9 4f			    ld    c, a    ; L = A+L 
8cea 88			    adc   a, b    ; A = A+L+H+carry 
8ceb 91			    sub   c       ; A = H+carry 
8cec 47			    ld    b, a    ; H = H+carry 
8ced c9			ret 
8cee			 
8cee			subafromhl: 
8cee			   ; If A=0 do nothing 
8cee			    ; Otherwise flip A's sign. Since 
8cee			    ; the upper byte becomes -1, also 
8cee			    ; substract 1 from H. 
8cee ed 44		    neg 
8cf0 ca f9 8c		    jp    z, Skip 
8cf3 25			    dec   h 
8cf4			     
8cf4			    ; Now add the low byte as usual 
8cf4			    ; Two's complement takes care of 
8cf4			    ; ensuring the result is correct 
8cf4 85			    add   a, l 
8cf5 6f			    ld    l, a 
8cf6 8c			    adc   a, h 
8cf7 95			    sub   l 
8cf8 67			    ld    h, a 
8cf9			Skip: 
8cf9 c9				ret 
8cfa			 
8cfa			 
8cfa			; compare hl and de 
8cfa			; returns:  
8cfa			; if hl = de, z=1, s=0, c0=0 
8cfa			; if hl > de, z=0, s=0, c=0 
8cfa			; if hl < de, z=0, s=1, c=1 
8cfa			cmp16:	 
8cfa b7				or a 
8cfb ed 52			sbc hl,de 
8cfd e0				ret po 
8cfe 7c				ld a,h 
8cff 1f				rra 
8d00 ee 40			xor 01000000B 
8d02 37				scf 
8d03 8f				adc a,a 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; test if hl contains zero   - A is destroyed 
8d05			 
8d05			ishlzero:    
8d05 b7				or a     ; reset flags 
8d06 7c				ld a, h 
8d07 b5				or l        	 
8d08			 
8d08 c9				ret 
8d09			 
8d09			 
8d09			 
8d09			 
8d09			if FORTH_ENABLE_FLOATMATH 
8d09			;include "float/bbcmath.z80" 
8d09			include "float/lpfpcalc.asm" 
8d09			endif 
8d09			 
8d09			 
8d09			; eof 
8d09			 
# End of file firmware_maths.asm
8d09			include "firmware_strings.asm"   ; string handling  
8d09			 
8d09			 
8d09			; TODO string len 
8d09			; input text string, end on cr with zero term 
8d09			; a offset into frame buffer to start prompt 
8d09			; d is max length 
8d09			; e is display size TODO 
8d09			; c is current cursor position 
8d09			; hl is ptr to where string will be stored 
8d09			 
8d09			 
8d09			; TODO check limit of buffer for new inserts 
8d09			; TODO check insert does not push beyond buffer 
8d09			; TODO scroll in a limited display area 
8d09			; TODO scroll whole screen on page wrap 
8d09			 
8d09			 
8d09			; TODO handle KEY_PREVWORD 
8d09			; TODO handle KEY_NEXTWORD 
8d09			; TODO handle KEY_HOME 
8d09			; TODO handle KEY_END 
8d09			; TODO use LCD cursor? 
8d09			 
8d09 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0c 81					add c 
8d0d 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d10 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d13 79					ld a, c 
8d14 cd dc 8c				call addatohl 
8d17 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8d22 7b					ld a,e 
8d23 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26					 
8d26					 
8d26			 
8d26			;		ld a,(input_ptr) 
8d26			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c1 eb				ld hl, cursor_shape 
8d29 3e ff				ld a, 255 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 0f				ld a, CUR_BLINK_RATE 
8d32 32 60 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 5f ee				ld (input_cur_onoff),a 
8d3a			 
8d3a			;	if DEBUG_INPUT 
8d3a			;		push af 
8d3a			;		ld a, 'I' 
8d3a			;		ld (debug_mark),a 
8d3a			;		pop af 
8d3a			;		CALLMONITOR 
8d3a			;	endif 
8d3a			.is1:		; main entry loop 
8d3a			 
8d3a			 
8d3a			 
8d3a					; pause 1ms 
8d3a			 
8d3a 3e 01				ld a, 1 
8d3c cd d7 89				call aDelayInMS 
8d3f			 
8d3f					; dec flash counter 
8d3f 3a 60 ee				ld a, (input_cur_flash) 
8d42 3d					dec a 
8d43 32 60 ee				ld (input_cur_flash), a 
8d46 fe 00				cp 0 
8d48 20 0d				jr nz, .nochgstate 
8d4a			 
8d4a			 
8d4a					; change state 
8d4a 3a 5f ee				ld a,(input_cur_onoff) 
8d4d ed 44				neg 
8d4f 32 5f ee				ld (input_cur_onoff),a 
8d52			 
8d52			 
8d52					; reset on change of state 
8d52 3e 0f				ld a, CUR_BLINK_RATE 
8d54 32 60 ee				ld (input_cur_flash), a 
8d57			 
8d57			.nochgstate: 
8d57					 
8d57					 
8d57			 
8d57					; display cursor  
8d57			 
8d57			;		ld hl, (input_start) 
8d57			;		ld a, (input_cursor) 
8d57			;		call addatohl 
8d57			 
8d57					; get char under cursor and replace with cursor 
8d57 2a 69 ee		ld hl, (input_ptr) 
8d5a			;		ld a, (hl) 
8d5a			;		ld (input_under_cursor),a 
8d5a			;		ld a, '_' 
8d5a			;		ld (hl), a 
8d5a			 
8d5a					; display string 
8d5a			 
8d5a ed 5b 67 ee			ld de, (input_start) 
8d5e 3a 64 ee				ld a, (input_at_pos) 
8d61 cd c2 8a				call str_at_display 
8d64			;	        call update_display 
8d64			 
8d64					; find place to put the cursor 
8d64			;		add h 
8d64			;		ld l, display_row_1 
8d64			;		sub l 
8d64			; (input_at_pos) 
8d64					;ld c, a 
8d64			;		ld a, (input_cursor) 
8d64			;		ld l, (input_at_pos) 
8d64			;		;ld b, h 
8d64			;		add l 
8d64			;		ld (input_at_cursor),a 
8d64					;ld l,h 
8d64			 
8d64			;		ld h, 0 
8d64			;		ld l,(input_at_pos) 
8d64			;		ld a, (input_cursor) 
8d64			;		call addatohl 
8d64			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d64			;		call subafromhl 
8d64			;		ld a,l 
8d64			;		ld (input_at_cursor), a 
8d64			 
8d64				if DEBUG_INPUT 
8d64					ld a, (hardware_diag) 
8d64					cp 0 
8d64					jr z, .skip_input_diag 
8d64			 
8d64					ld a,(input_at_pos) 
8d64					ld hl, LFSRSeed 
8d64					call hexout 
8d64					ld a, (input_cursor) 
8d64					ld hl, LFSRSeed+2 
8d64					call hexout 
8d64					ld a,(input_at_cursor) 
8d64					ld hl, LFSRSeed+4 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_onoff) 
8d64					ld hl, LFSRSeed+6 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_flash) 
8d64					ld hl, LFSRSeed+8 
8d64					call hexout 
8d64			 
8d64					ld a,(input_len) 
8d64					ld hl, LFSRSeed+10 
8d64					call hexout 
8d64					ld hl, LFSRSeed+12 
8d64					ld a, 0 
8d64					ld (hl),a 
8d64					ld a, display_row_4 
8d64					ld de, LFSRSeed 
8d64					call str_at_display 
8d64					.skip_input_diag: 
8d64				endif 
8d64			 
8d64					; decide on if we are showing the cursor this time round 
8d64			 
8d64 3a 5f ee				ld a, (input_cur_onoff) 
8d67 fe ff				cp 255 
8d69 28 13				jr z, .skipcur 
8d6b			 
8d6b			 
8d6b 3a 62 ee				ld a,(input_at_cursor) 
8d6e 11 c1 eb				ld de, cursor_shape 
8d71 cd c2 8a				call str_at_display 
8d74			 
8d74					; save length of current input string 
8d74 2a 67 ee				ld hl, (input_start) 
8d77 cd 3a 91				call strlenz 
8d7a 7d					ld a,l 
8d7b 32 5a ee				ld (input_len),a 
8d7e			 
8d7e			.skipcur: 
8d7e			 
8d7e cd d2 8a			        call update_display 
8d81					 
8d81			 
8d81			 
8d81					; wait 
8d81				 
8d81					; TODO loop without wait to flash the cursor and char under cursor	 
8d81 cd 2e e4				call cin    ; _wait 
8d84			 
8d84 fe 00				cp 0 
8d86 ca 3a 8d				jp z, .is1 
8d89			 
8d89					; get ptr to char to input into 
8d89			 
8d89 4f					ld c,a 
8d8a 2a 67 ee				ld hl, (input_start) 
8d8d 3a 55 ee				ld a, (input_cursor) 
8d90 cd dc 8c				call addatohl 
8d93 22 69 ee				ld (input_ptr), hl 
8d96 79					ld a,c 
8d97			 
8d97					; replace char under cursor 
8d97			 
8d97			;		ld hl, (input_ptr) 
8d97			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d97			;		ld (hl), a 
8d97			 
8d97			;	if DEBUG_INPUT 
8d97			;		push af 
8d97			;		ld a, 'i' 
8d97			;		ld (debug_mark),a 
8d97			;		pop af 
8d97			;		CALLMONITOR 
8d97			;	endif 
8d97 fe 0e				cp KEY_HOME 
8d99 20 0e				jr nz, .iske 
8d9b			 
8d9b 3a 64 ee				ld a, (input_at_pos) 
8d9e 32 62 ee				ld (input_at_cursor),a 
8da1 3e 00				ld a, 0 
8da3 32 55 ee				ld (input_cursor), a 
8da6 c3 3a 8d				jp .is1 
8da9					 
8da9 fe 0f		.iske:		cp KEY_END 
8dab 20 03				jr nz, .isknw 
8dad c3 3a 8d				jp .is1 
8db0			 
8db0 fe 06		.isknw:		cp KEY_NEXTWORD 
8db2 20 1b				jr nz, .iskpw 
8db4			 
8db4 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8db7 7e					ld a,(hl)	 
8db8 fe 00				cp 0 
8dba ca 3a 8d				jp z, .is1    ; end of string 
8dbd fe 20				cp ' ' 
8dbf ca 3a 8d				jp z, .is1    ; end of word 
8dc2 23					inc hl 
8dc3 22 69 ee				ld (input_ptr), hl 
8dc6 3a 62 ee				ld a, (input_at_cursor) 
8dc9 3c					inc a 
8dca 32 62 ee				ld (input_at_cursor), a 
8dcd 18 e5				jr .isknwm 
8dcf			 
8dcf fe 07		.iskpw:		cp KEY_PREVWORD 
8dd1 20 1b				jr nz, .iskl 
8dd3			.iskpwm:	 
8dd3 2a 69 ee				ld hl, (input_ptr) 
8dd6 7e					ld a,(hl)	 
8dd7 fe 00				cp 0  
8dd9 ca 3a 8d				jp z, .is1    ; end of string 
8ddc fe 20				cp ' ' 
8dde ca 3a 8d				jp z, .is1    ; end of word 
8de1 2b					dec hl 
8de2 22 69 ee				ld (input_ptr), hl 
8de5 3a 62 ee				ld a, (input_at_cursor) 
8de8 3d					dec a 
8de9 32 62 ee				ld (input_at_cursor), a 
8dec 18 e5				jr .iskpwm 
8dee			 
8dee			 
8dee fe 0b		.iskl:		cp KEY_LEFT 
8df0 20 27				jr nz, .isk1 
8df2			 
8df2 3a 55 ee				ld a, (input_cursor) 
8df5			 
8df5 fe 00				cp 0 
8df7 ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8dfa			 
8dfa 3d					dec  a 		; TODO check underflow 
8dfb 32 55 ee				ld (input_cursor), a 
8dfe			 
8dfe 2a 69 ee				ld hl, (input_ptr) 
8e01 2b					dec hl 
8e02 22 69 ee				ld (input_ptr), hl 
8e05					 
8e05 3a 62 ee				ld a, (input_at_cursor) 
8e08 3d					dec a 
8e09 32 62 ee				ld (input_at_cursor), a 
8e0c			 
8e0c 3e 01				ld a, 1		; show cursor moving 
8e0e 32 5f ee				ld (input_cur_onoff),a 
8e11 3e 0f				ld a, CUR_BLINK_RATE 
8e13 32 60 ee				ld (input_cur_flash), a 
8e16			 
8e16 c3 3a 8d				jp .is1 
8e19			 
8e19 fe 0c		.isk1:		cp KEY_RIGHT 
8e1b 20 2a				jr nz, .isk2 
8e1d			 
8e1d 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e20 5f					ld e,a 
8e21 3a 55 ee				ld a, (input_cursor) 
8e24 bb					cp e 
8e25 ca 3a 8d				jp z, .is1		; at the end of string so dont go right 
8e28			 
8e28 3c					inc  a 		; TODO check overflow 
8e29 32 55 ee				ld (input_cursor), a 
8e2c			 
8e2c 3a 62 ee				ld a, (input_at_cursor) 
8e2f 3c					inc a 
8e30 32 62 ee				ld (input_at_cursor), a 
8e33			 
8e33 2a 69 ee				ld hl, (input_ptr) 
8e36 23					inc hl 
8e37 22 69 ee				ld (input_ptr), hl 
8e3a			 
8e3a 3e 01				ld a, 1		; show cursor moving 
8e3c 32 5f ee				ld (input_cur_onoff),a 
8e3f 3e 0f				ld a, CUR_BLINK_RATE 
8e41 32 60 ee				ld (input_cur_flash), a 
8e44			 
8e44 c3 3a 8d				jp .is1 
8e47			 
8e47 fe 05		.isk2:		cp KEY_UP 
8e49			 
8e49 20 26				jr nz, .isk3 
8e4b			 
8e4b					; swap last command with the current on 
8e4b			 
8e4b					; move cursor to start of string 
8e4b 2a 67 ee				ld hl, (input_start) 
8e4e 22 69 ee				ld (input_ptr), hl 
8e51			 
8e51 3a 64 ee				ld a, (input_at_pos) 
8e54 32 62 ee				ld (input_at_cursor), a 
8e57			 
8e57 3e 00				ld a, 0 
8e59 32 55 ee				ld (input_cursor), a 
8e5c					 
8e5c					; swap input and last command buffers 
8e5c			 
8e5c 21 e8 e5				ld hl, os_cli_cmd 
8e5f 11 e7 e6				ld de, os_last_cmd 
8e62 06 ff				ld b, 255 
8e64 7e			.swap1:		ld a, (hl) 
8e65 4f					ld c,a 
8e66 1a					ld a, (de) 
8e67 77					ld (hl), a 
8e68 79					ld a,c 
8e69 12					ld (de),a 
8e6a 23					inc hl 
8e6b 13					inc de 
8e6c 10 f6				djnz .swap1 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e c3 3a 8d				jp .is1 
8e71			 
8e71 fe 08		.isk3:		cp KEY_BS 
8e73 20 3c				jr nz, .isk4 
8e75			 
8e75 3a 55 ee				ld a, (input_cursor) 
8e78			 
8e78 fe 00				cp 0 
8e7a ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8e7d			 
8e7d 3d					dec  a 		; TODO check underflow 
8e7e 32 55 ee				ld (input_cursor), a 
8e81			 
8e81					; hl is source 
8e81					; de needs to be source - 1 
8e81			 
8e81			;		ld a, 0 
8e81			;		dec hl 
8e81			;		ld (hl), a 
8e81			 
8e81 2a 69 ee				ld hl, (input_ptr) 
8e84 2b					dec hl 
8e85 22 69 ee				ld (input_ptr), hl 
8e88			 
8e88					; shift all data 
8e88			 
8e88 e5					push hl 
8e89 23					inc hl 
8e8a d1					pop de 
8e8b 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8e 4f					ld c,a 
8e8f 06 00				ld b,0 
8e91 ed b0				ldir  
8e93			 
8e93			 
8e93			 
8e93			 
8e93 3a 62 ee				ld a, (input_at_cursor) 
8e96 3d					dec a 
8e97 32 62 ee				ld (input_at_cursor), a 
8e9a			 
8e9a			 
8e9a 3e 01				ld a, 1		; show cursor moving 
8e9c 32 5f ee				ld (input_cur_onoff),a 
8e9f 3e 0f				ld a, CUR_BLINK_RATE 
8ea1 32 60 ee				ld (input_cur_flash), a 
8ea4			 
8ea4					; remove char 
8ea4 3a 62 ee				ld a, (input_at_cursor) 
8ea7 3c					inc a 
8ea8 11 32 8f				ld de,.iblank 
8eab cd c2 8a				call str_at_display 
8eae			 
8eae c3 3a 8d				jp .is1 
8eb1			 
8eb1 fe 0d		.isk4:		cp KEY_CR 
8eb3 28 6c				jr z, .endinput 
8eb5			 
8eb5					; else add the key press to the end 
8eb5			 
8eb5 4f					ld c, a			; save key pressed 
8eb6			 
8eb6 7e					ld a,(hl)		; get what is currently under char 
8eb7			 
8eb7 fe 00				cp 0			; we are at the end of the string 
8eb9 20 2f				jr nz, .onchar 
8ebb					 
8ebb					; add a char to the end of the string 
8ebb				 
8ebb 71					ld (hl),c 
8ebc 23					inc hl 
8ebd			;		ld a,' ' 
8ebd			;		ld (hl),a 
8ebd			;		inc hl 
8ebd 3e 00				ld a,0 
8ebf 77					ld (hl),a 
8ec0 2b					dec hl 
8ec1			 
8ec1 3a 55 ee				ld a, (input_cursor) 
8ec4 3c					inc a				; TODO check max string length and scroll  
8ec5 32 55 ee				ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8 3a 62 ee				ld a, (input_at_cursor) 
8ecb 3c					inc a 
8ecc 32 62 ee				ld (input_at_cursor), a 
8ecf			 
8ecf 2a 69 ee				ld hl, (input_ptr) 
8ed2 23					inc hl 
8ed3 22 69 ee				ld (input_ptr), hl 
8ed6			 
8ed6 2a 69 ee				ld hl, (input_ptr) 
8ed9 23					inc hl 
8eda 22 69 ee				ld (input_ptr), hl 
8edd			;	if DEBUG_INPUT 
8edd			;		push af 
8edd			;		ld a, '+' 
8edd			;		ld (debug_mark),a 
8edd			;		pop af 
8edd			;		CALLMONITOR 
8edd			;	endif 
8edd 3e 01				ld a, 1		; show cursor moving 
8edf 32 5f ee				ld (input_cur_onoff),a 
8ee2 3e 0f				ld a, CUR_BLINK_RATE 
8ee4 32 60 ee				ld (input_cur_flash), a 
8ee7 c3 3a 8d				jp .is1 
8eea					 
8eea			 
8eea			 
8eea					; if on a char then insert 
8eea			.onchar: 
8eea			 
8eea					; TODO over flow check: make sure insert does not blow out buffer 
8eea			 
8eea					; need to do some maths to use lddr 
8eea			 
8eea e5					push hl   ; save char pos 
8eeb c5					push bc 
8eec			 
8eec 2a 67 ee				ld hl, (input_start) 
8eef 3a 5a ee				ld a, (input_len) 
8ef2 cd dc 8c				call addatohl  		; end of string 
8ef5 23					inc hl 
8ef6 23					inc hl		; past zero term 
8ef7 e5					push hl 
8ef8 23					inc hl 
8ef9 e5					push hl  
8efa			 
8efa								; start and end of lddr set, now how much to move? 
8efa			 
8efa							 
8efa 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efd 47					ld b,a 
8efe 3a 5a ee				ld a,(input_len) 
8f01 5f					ld e,a 
8f02 90					sub b 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05 3c					inc a		;?? 
8f06			 
8f06 06 00				ld b,0 
8f08 4f					ld c,a 
8f09			 
8f09				if DEBUG_INPUT 
8f09					push af 
8f09					ld a, 'i' 
8f09					ld (debug_mark),a 
8f09					pop af 
8f09			;		CALLMONITOR 
8f09				endif 
8f09 d1					pop de 
8f0a e1					pop hl 
8f0b				if DEBUG_INPUT 
8f0b					push af 
8f0b					ld a, 'I' 
8f0b					ld (debug_mark),a 
8f0b					pop af 
8f0b			;		CALLMONITOR 
8f0b				endif 
8f0b ed b8				lddr 
8f0d				 
8f0d			 
8f0d			 
8f0d					; TODO have a key for insert/overwrite mode???? 
8f0d c1					pop bc 
8f0e e1					pop hl 
8f0f 71					ld (hl), c		; otherwise overwrite current char 
8f10					 
8f10			 
8f10			 
8f10			 
8f10 3a 55 ee				ld a, (input_cursor) 
8f13 3c					inc  a 		; TODO check overflow 
8f14 32 55 ee				ld (input_cursor), a 
8f17			 
8f17 3a 62 ee				ld a, (input_at_cursor) 
8f1a 3c					inc a 
8f1b 32 62 ee				ld (input_at_cursor), a 
8f1e			 
8f1e c3 3a 8d				jp .is1 
8f21			 
8f21			.endinput:	; TODO look for end of string 
8f21			 
8f21					; add trailing space for end of token 
8f21			 
8f21 2a 67 ee				ld hl, (input_start) 
8f24 3a 5a ee				ld a,(input_len) 
8f27 cd dc 8c				call addatohl 
8f2a 3e 20				ld a, ' ' 
8f2c 77					ld (hl),a 
8f2d					; TODO eof of parse marker 
8f2d			 
8f2d 23					inc hl 
8f2e 3e 00				ld a, 0 
8f30 77					ld (hl),a 
8f31			 
8f31			 
8f31 c9					ret 
8f32			 
8f32 .. 00		.iblank: db " ",0 
8f34			 
8f34			 
8f34 32 64 ee		input_str_prev:	ld (input_at_pos), a 
8f37 22 67 ee				ld (input_start), hl 
8f3a 3e 01				ld a,1			; add cursor 
8f3c 77					ld (hl),a 
8f3d 23					inc hl 
8f3e 3e 00				ld a,0 
8f40 77					ld (hl),a 
8f41 22 69 ee				ld (input_ptr), hl 
8f44 7a					ld a,d 
8f45 32 66 ee				ld (input_size), a 
8f48 3e 00				ld a,0 
8f4a 32 55 ee				ld (input_cursor),a 
8f4d			.instr1:	 
8f4d			 
8f4d					; TODO do block cursor 
8f4d					; TODO switch cursor depending on the modifer key 
8f4d			 
8f4d					; update cursor shape change on key hold 
8f4d			 
8f4d 2a 69 ee				ld hl, (input_ptr) 
8f50 2b					dec hl 
8f51 3a c1 eb				ld a,(cursor_shape) 
8f54 77					ld (hl), a 
8f55			 
8f55					; display entered text 
8f55 3a 64 ee				ld a,(input_at_pos) 
8f58 cd 8c e3		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5b ed 5b 67 ee	            	LD   de, (input_start) 
8f5f cd 86 e3		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f62			 
8f62 cd 2e e4				call cin 
8f65 fe 00				cp 0 
8f67 28 e4				jr z, .instr1 
8f69			 
8f69					; proecess keyboard controls first 
8f69			 
8f69 2a 69 ee				ld hl,(input_ptr) 
8f6c			 
8f6c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6e 28 5a				jr z, .instrcr 
8f70			 
8f70 fe 08				cp KEY_BS 	; back space 
8f72 20 0f				jr nz, .instr2 
8f74					; process back space 
8f74			 
8f74					; TODO stop back space if at start of string 
8f74 2b					dec hl 
8f75 2b					dec hl ; to over write cursor 
8f76 3a c1 eb				ld a,(cursor_shape) 
8f79					;ld a,0 
8f79 77					ld (hl),a 
8f7a 23					inc hl 
8f7b 3e 20				ld a," " 
8f7d 77					ld (hl),a 
8f7e 22 69 ee				ld (input_ptr),hl 
8f81					 
8f81			 
8f81 18 ca				jr .instr1 
8f83			 
8f83 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f85 20 06				jr nz, .instr3 
8f87 2b					dec hl 
8f88 22 69 ee				ld (input_ptr),hl 
8f8b 18 c0				jr .instr1 
8f8d				 
8f8d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8f 20 06				jr nz, .instr4 
8f91 23					inc hl 
8f92 22 69 ee				ld (input_ptr),hl 
8f95 18 b6				jr .instr1 
8f97			 
8f97 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f99 20 06				jr nz, .instr5 
8f9b 2b					dec hl 
8f9c 22 69 ee				ld (input_ptr),hl 
8f9f 18 ac				jr .instr1 
8fa1			 
8fa1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa3 20 06				jr nz, .instr6 
8fa5 2b					dec hl 
8fa6 22 69 ee				ld (input_ptr),hl 
8fa9 18 a2				jr .instr1 
8fab fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fad 20 0b				jr nz, .instrnew 
8faf			 
8faf 21 c1 e2			ld hl, scratch 
8fb2 11 e7 e6			ld de, os_last_cmd 
8fb5 cd d3 8f			call strcpy 
8fb8 18 93				jr .instr1 
8fba			 
8fba			 
8fba			.instrnew:	; no special key pressed to see if we have room to store it 
8fba			 
8fba					; TODO do string size test 
8fba			 
8fba 2b					dec hl ; to over write cursor 
8fbb 77					ld (hl),a 
8fbc 23					inc hl 
8fbd 3a c1 eb				ld a,(cursor_shape) 
8fc0 77					ld (hl),a 
8fc1 23					inc hl 
8fc2 3e 00				ld a,0 
8fc4 77					ld (hl),a 
8fc5			 
8fc5 22 69 ee				ld (input_ptr),hl 
8fc8					 
8fc8 18 83				jr .instr1 
8fca 2b			.instrcr:	dec hl		; remove cursor 
8fcb 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcd 77					ld (hl),a 
8fce 23					inc hl 
8fcf 3e 00				ld a,0 
8fd1 77					ld (hl),a 
8fd2			 
8fd2			 
8fd2					; if at end of line scroll up    
8fd2					; TODO detecting only end of line 4 for scroll up  
8fd2			 
8fd2					;ld   
8fd2			 
8fd2 c9					ret 
8fd3			 
8fd3			 
8fd3			; strcpy hl = dest, de source 
8fd3			 
8fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd4 b7			            OR   A              ;Null terminator? 
8fd5 c8			            RET  Z              ;Yes, so finished 
8fd6 1a					ld a,(de) 
8fd7 77					ld (hl),a 
8fd8 13			            INC  DE             ;Point to next character 
8fd9 23					inc hl 
8fda 18 f7		            JR   strcpy       ;Repeat 
8fdc c9					ret 
8fdd			 
8fdd			 
8fdd			; TODO string_at  
8fdd			; pass string which starts with lcd offset address and then null term string 
8fdd			 
8fdd			; TODO string to dec 
8fdd			; TODO string to hex 
8fdd			; TODO byte to string hex 
8fdd			; TODO byte to string dec 
8fdd			 
8fdd			 
8fdd			 
8fdd			; from z80uartmonitor 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdd			; pass hl for where to put the text 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd c5			hexout:	PUSH BC 
8fde f5					PUSH AF 
8fdf 47					LD B, A 
8fe0					; Upper nybble 
8fe0 cb 3f				SRL A 
8fe2 cb 3f				SRL A 
8fe4 cb 3f				SRL A 
8fe6 cb 3f				SRL A 
8fe8 cd f8 8f				CALL tohex 
8feb 77					ld (hl),a 
8fec 23					inc hl	 
8fed					 
8fed					; Lower nybble 
8fed 78					LD A, B 
8fee e6 0f				AND 0FH 
8ff0 cd f8 8f				CALL tohex 
8ff3 77					ld (hl),a 
8ff4 23					inc hl	 
8ff5					 
8ff5 f1					POP AF 
8ff6 c1					POP BC 
8ff7 c9					RET 
8ff8					 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			tohex: 
8ff8 e5					PUSH HL 
8ff9 d5					PUSH DE 
8ffa 16 00				LD D, 0 
8ffc 5f					LD E, A 
8ffd 21 05 90				LD HL, .DATA 
9000 19					ADD HL, DE 
9001 7e					LD A, (HL) 
9002 d1					POP DE 
9003 e1					POP HL 
9004 c9					RET 
9005			 
9005			.DATA: 
9005 30					DEFB	30h	; 0 
9006 31					DEFB	31h	; 1 
9007 32					DEFB	32h	; 2 
9008 33					DEFB	33h	; 3 
9009 34					DEFB	34h	; 4 
900a 35					DEFB	35h	; 5 
900b 36					DEFB	36h	; 6 
900c 37					DEFB	37h	; 7 
900d 38					DEFB	38h	; 8 
900e 39					DEFB	39h	; 9 
900f 41					DEFB	41h	; A 
9010 42					DEFB	42h	; B 
9011 43					DEFB	43h	; C 
9012 44					DEFB	44h	; D 
9013 45					DEFB	45h	; E 
9014 46					DEFB	46h	; F 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9015			;;    subtract $30, if result > 9 then subtract $7 more 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			atohex: 
9015 d6 30				SUB $30 
9017 fe 0a				CP 10 
9019 f8					RET M		; If result negative it was 0-9 so we're done 
901a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901c c9					RET		 
901d			 
901d			 
901d			 
901d			 
901d			; Get 2 ASCII characters as hex byte from pointer in hl 
901d			 
901d			BYTERD: 
901d 16 00			LD	D,00h		;Set up 
901f cd 27 90			CALL	HEXCON		;Get byte and convert to hex 
9022 87				ADD	A,A		;First nibble so 
9023 87				ADD	A,A		;multiply by 16 
9024 87				ADD	A,A		; 
9025 87				ADD	A,A		; 
9026 57				LD	D,A		;Save hi nibble in D 
9027			HEXCON: 
9027 7e				ld a, (hl)		;Get next chr 
9028 23				inc hl 
9029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902b fe 0a			CP	00Ah		;Is it 0-9 ? 
902d 38 02			JR	C,NALPHA	;If so miss next bit 
902f d6 07			SUB	007h		;Else convert alpha 
9031			NALPHA: 
9031 b2				OR	D		;Add hi nibble back 
9032 c9				RET			; 
9033			 
9033			 
9033			; 
9033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9033			; Since the routines get_byte and therefore get_nibble are called, only valid 
9033			; characters (0-9a-f) are accepted. 
9033			; 
9033			;get_word        push    af 
9033			;                call    get_byte        ; Get the upper byte 
9033			;                ld      h, a 
9033			;                call    get_byte        ; Get the lower byte 
9033			;                ld      l, a 
9033			;                pop     af 
9033			;                ret 
9033			; 
9033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9033			; the routine get_nibble is used only valid characters are accepted - the  
9033			; input routine only accepts characters 0-9a-f. 
9033			; 
9033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9034 7e					ld a,(hl) 
9035 23					inc hl 
9036 cd 5b 90		                call    nibble2val      ; Get upper nibble 
9039 cb 07		                rlc     a 
903b cb 07		                rlc     a 
903d cb 07		                rlc     a 
903f cb 07		                rlc     a 
9041 47			                ld      b, a            ; Save upper four bits 
9042 7e					ld a,(hl) 
9043 cd 5b 90		                call    nibble2val      ; Get lower nibble 
9046 b0			                or      b               ; Combine both nibbles 
9047 c1			                pop     bc              ; Restore B (and C) 
9048 c9			                ret 
9049			; 
9049			; Get a hexadecimal digit from the serial line. This routine blocks until 
9049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9049			; to the serial line interface. The lower 4 bits of A contain the value of  
9049			; that particular digit. 
9049			; 
9049			;get_nibble      ld a,(hl)           ; Read a character 
9049			;                call    to_upper        ; Convert to upper case 
9049			;                call    is_hex          ; Was it a hex digit? 
9049			;                jr      nc, get_nibble  ; No, get another character 
9049			 ;               call    nibble2val      ; Convert nibble to value 
9049			 ;               call    print_nibble 
9049			 ;               ret 
9049			; 
9049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9049			; A valid hexadecimal digit is denoted by a set C flag. 
9049			; 
9049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9049			;                ret     nc              ; Yes 
9049			;                cp      '0'             ; Less than '0'? 
9049			;                jr      nc, is_hex_1    ; No, continue 
9049			;                ccf                     ; Complement carry (i.e. clear it) 
9049			;                ret 
9049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9049			;                ret     c               ; Yes 
9049			;                cp      'A'             ; Less than 'A'? 
9049			;                jr      nc, is_hex_2    ; No, continue 
9049			;                ccf                     ; Yes - clear carry and return 
9049			;                ret 
9049			;is_hex_2        scf                     ; Set carry 
9049			;                ret 
9049			; 
9049			; Convert a single character contained in A to upper case: 
9049			; 
9049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904b d8			                ret     c 
904c fe 7b		                cp      'z' + 1         ; > 'z'? 
904e d0			                ret     nc              ; Nothing to do, either 
904f e6 5f		                and     $5f             ; Convert to upper case 
9051 c9			                ret 
9052			 
9052			 
9052			to_lower: 
9052			 
9052			   ; if char is in [A-Z] make it lower case 
9052			 
9052			   ; enter : a = char 
9052			   ; exit  : a = lower case char 
9052			   ; uses  : af 
9052			 
9052 fe 41		   cp 'A' 
9054 d8			   ret c 
9055			    
9055 fe 5b		   cp 'Z'+1 
9057 d0			   ret nc 
9058			    
9058 f6 20		   or $20 
905a c9			   ret 
905b			 
905b			; 
905b			; Expects a hexadecimal digit (upper case!) in A and returns the 
905b			; corresponding value in A. 
905b			; 
905b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905d 38 02		                jr      c, nibble2val_1 ; Yes 
905f d6 07		                sub     7               ; Adjust for A-F 
9061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9063 e6 0f		                and     $f              ; Only return lower 4 bits 
9065 c9			                ret 
9066			; 
9066			; Print_nibble prints a single hex nibble which is contained in the lower  
9066			; four bits of A: 
9066			; 
9066			;print_nibble    push    af              ; We won't destroy the contents of A 
9066			;                and     $f              ; Just in case... 
9066			;                add     a, '0'             ; If we have a digit we are done here. 
9066			;                cp      '9' + 1         ; Is the result > 9? 
9066			;                jr      c, print_nibble_1 
9066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9066			;print_nibble_1  call    putc            ; Print the nibble and 
9066			;                pop     af              ; restore the original value of A 
9066			;                ret 
9066			;; 
9066			;; Send a CR/LF pair: 
9066			; 
9066			;crlf            push    af 
9066			;                ld      a, cr 
9066			;                call    putc 
9066			;                ld      a, lf 
9066			;                call    putc 
9066			;                pop     af 
9066			;                ret 
9066			; 
9066			; Print_word prints the four hex digits of a word to the serial line. The  
9066			; word is expected to be in HL. 
9066			; 
9066			;print_word      push    hl 
9066			;                push    af 
9066			;                ld      a, h 
9066			;                call    print_byte 
9066			;                ld      a, l 
9066			;                call    print_byte 
9066			;                pop     af 
9066			;                pop     hl 
9066			;                ret 
9066			; 
9066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9066			; The byte to be printed is expected to be in A. 
9066			; 
9066			;print_byte      push    af              ; Save the contents of the registers 
9066			;                push    bc 
9066			;                ld      b, a 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                call    print_nibble    ; Print high nibble 
9066			;                ld      a, b 
9066			;                call    print_nibble    ; Print low nibble 
9066			;                pop     bc              ; Restore original register contents 
9066			;                pop     af 
9066			;                ret 
9066			 
9066			 
9066			 
9066			 
9066			 
9066			fourehexhl:  
9066 7e				ld a,(hl) 
9067 cd 15 90			call atohex 
906a cb 3f				SRL A 
906c cb 3f				SRL A 
906e cb 3f				SRL A 
9070 cb 3f				SRL A 
9072 47				ld b, a 
9073 23				inc hl 
9074 7e				ld a,(hl) 
9075 23				inc hl 
9076 cd 15 90			call atohex 
9079 80				add b 
907a 57				ld d,a 
907b 7e				ld a,(hl) 
907c cd 15 90			call atohex 
907f cb 3f				SRL A 
9081 cb 3f				SRL A 
9083 cb 3f				SRL A 
9085 cb 3f				SRL A 
9087 47				ld b, a 
9088 23				inc hl 
9089 7e				ld a,(hl) 
908a 23				inc hl 
908b cd 15 90			call atohex 
908e 80				add b 
908f 5f				ld e, a 
9090 d5				push de 
9091 e1				pop hl 
9092 c9				ret 
9093			 
9093			; pass hl. returns z set if the byte at hl is a digit 
9093			;isdigithl:  
9093			;	push bc 
9093			;	ld a,(hl) 
9093			;	cp ':' 
9093			;	jr nc, .isdf 		; > 
9093			;	cp '0' 
9093			;	jr c, .isdf		; < 
9093			; 
9093			;	; TODO find a better way to set z 
9093			; 
9093			;	ld b,a 
9093			;	cp b 
9093			;	pop bc 
9093			;	ret 
9093			; 
9093			;.isdf:	; not digit so clear z 
9093			; 
9093			;	; TODO find a better way to unset z 
9093			; 
9093			;	ld b,a 
9093			;	inc b 
9093			;	cp b 
9093			; 
9093			;	pop bc 
9093			;	ret 
9093				 
9093				 
9093			 
9093			 
9093			; pass hl as the four byte address to load 
9093			 
9093			get_word_hl:  
9093 e5				push hl 
9094 cd 33 90			call get_byte 
9097				 
9097 47				ld b, a 
9098			 
9098 e1				pop hl 
9099 23				inc hl 
909a 23				inc hl 
909b			 
909b			; TODO not able to handle a-f  
909b 7e				ld a,(hl) 
909c			;	;cp ':' 
909c			;	cp 'g' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp 'G' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp '0' 
909c			;	jr c, .single_byte_hl		; < 
909c			 
909c				;call isdigithl 
909c fe 00			cp 0 
909e 28 06			jr z, .single_byte_hl 
90a0			 
90a0			.getwhln:   ; hex word so get next byte 
90a0			 
90a0 cd 33 90			call get_byte 
90a3 6f				ld l, a 
90a4 60				ld h,b 
90a5 c9				ret 
90a6 68			.single_byte_hl:   ld l,b 
90a7 26 00				ld h,0 
90a9 c9					ret 
90aa			 
90aa			 
90aa			 
90aa			 
90aa 21 3a 98			ld hl,asc+1 
90ad			;	ld a, (hl) 
90ad			;	call nibble2val 
90ad cd 33 90			call get_byte 
90b0			 
90b0			;	call fourehexhl 
90b0 32 f5 e2			ld (scratch+52),a 
90b3				 
90b3 21 f3 e2			ld hl,scratch+50 
90b6 22 e4 e5			ld (os_cur_ptr),hl 
90b9			 
90b9 c9				ret 
90ba			 
90ba			 
90ba			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90ba			 
90ba			; Decimal Unsigned Version 
90ba			 
90ba			;Number in a to decimal ASCII 
90ba			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90ba			;Example: display a=56 as "056" 
90ba			;input: a = number 
90ba			;Output: a=0,value of a in the screen 
90ba			;destroys af,bc (don't know about hl and de) 
90ba			DispAToASCII: 
90ba 0e 9c			ld	c,-100 
90bc cd c6 90			call	.Na1 
90bf 0e f6			ld	c,-10 
90c1 cd c6 90			call	.Na1 
90c4 0e ff			ld	c,-1 
90c6 06 2f		.Na1:	ld	b,'0'-1 
90c8 04			.Na2:	inc	b 
90c9 81				add	a,c 
90ca 38 fc			jr	c,.Na2 
90cc 91				sub	c		;works as add 100/10/1 
90cd f5				push af		;safer than ld c,a 
90ce 78				ld	a,b		;char is in b 
90cf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90cf f1				pop af		;safer than ld a,c 
90d0 c9				ret 
90d1			 
90d1			; Decimal Signed Version 
90d1			 
90d1			; DispA 
90d1			; -------------------------------------------------------------- 
90d1			; Converts a signed integer value to a zero-terminated ASCII 
90d1			; string representative of that value (using radix 10). 
90d1			; -------------------------------------------------------------- 
90d1			; INPUTS: 
90d1			;     HL     Value to convert (two's complement integer). 
90d1			;     DE     Base address of string destination. (pointer). 
90d1			; -------------------------------------------------------------- 
90d1			; OUTPUTS: 
90d1			;     None 
90d1			; -------------------------------------------------------------- 
90d1			; REGISTERS/MEMORY DESTROYED 
90d1			; AF HL 
90d1			; -------------------------------------------------------------- 
90d1			 
90d1			;DispHLToASCII: 
90d1			;   push    de 
90d1			;   push    bc 
90d1			; 
90d1			;; Detect sign of HL. 
90d1			;    bit    7, h 
90d1			;    jr     z, ._DoConvert 
90d1			; 
90d1			;; HL is negative. Output '-' to string and negate HL. 
90d1			;    ld     a, '-' 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			; 
90d1			;; Negate HL (using two's complement) 
90d1			;    xor    a 
90d1			;    sub    l 
90d1			;    ld     l, a 
90d1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d1			;    sbc    a, h 
90d1			;    ld     h, a 
90d1			; 
90d1			;; Convert HL to digit characters 
90d1			;._DoConvert: 
90d1			;    ld     b, 0     ; B will count character length of number 
90d1			;-   ld     a, 10 
90d1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d1			;    push   af 
90d1			;    inc    b 
90d1			;    ld     a, h 
90d1			;    or     l 
90d1			;    jr     nz, - 
90d1			; 
90d1			;; Retrieve digits from stack 
90d1			;-   pop    af 
90d1			;    or     $30 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			;    djnz   - 
90d1			; 
90d1			;; Terminate string with NULL 
90d1			;    xor    a 
90d1			;    ld     (de), a 
90d1			; 
90d1			;    pop    bc 
90d1			;    pop    de 
90d1			;    ret 
90d1			 
90d1			;Comments 
90d1			; 
90d1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d1			;    Note that the output string will not be fixed-width. 
90d1			; 
90d1			;Example Usage 
90d1			; 
90d1			;    ld    hl, -1004 
90d1			;    ld    de, OP1 
90d1			;    call  DispA 
90d1			;    ld    hl, OP1 
90d1			;    syscall  PutS 
90d1			 
90d1			 
90d1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d1			 
90d1			 
90d1			;Converts an ASCII string to an unsigned 16-bit integer 
90d1			;Quits when it reaches a non-decimal digit 
90d1			 
90d1			string_to_uint16: 
90d1			atoui_16: 
90d1			;Input: 
90d1			;     DE points to the string 
90d1			;Outputs: 
90d1			;     HL is the result 
90d1			;     A is the 8-bit value of the number 
90d1			;     DE points to the byte after the number 
90d1			;Destroys: 
90d1			;     BC 
90d1			;       if the string is non-empty, BC is HL/10 
90d1			;Size:  24 bytes 
90d1			;Speed: 42+d(104+{0,9}) 
90d1			;       d is the number of digits in the number 
90d1			;       max is 640 cycles for a 5 digit number 
90d1			;Assuming no leading zeros: 
90d1			;1 digit:  146cc 
90d1			;2 digit:  250cc 
90d1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d1			;avg: 544.81158447265625cc (544+13297/16384) 
90d1			;=============================================================== 
90d1 21 00 00		  ld hl,0 
90d4			.u16a: 
90d4 1a			  ld a,(de) 
90d5 d6 30		  sub 30h 
90d7 fe 0a		  cp 10 
90d9 d0			  ret nc 
90da 13			  inc de 
90db 44			  ld b,h 
90dc 4d			  ld c,l 
90dd 29			  add hl,hl 
90de 29			  add hl,hl 
90df 09			  add hl,bc 
90e0 29			  add hl,hl 
90e1 85			  add a,l 
90e2 6f			  ld l,a 
90e3 30 ef		  jr nc,.u16a 
90e5 24			  inc h 
90e6 c3 d4 90		  jp .u16a 
90e9			 
90e9			 
90e9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e9			 
90e9			;written by Zeda 
90e9			;Converts a 16-bit unsigned integer to an ASCII string. 
90e9			 
90e9			uitoa_16: 
90e9			;Input: 
90e9			;   DE is the number to convert 
90e9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e9			;Output: 
90e9			;   HL points to the null-terminated ASCII string 
90e9			;      NOTE: This isn't necessarily the same as the input HL. 
90e9 d5			  push de 
90ea c5			  push bc 
90eb f5			  push af 
90ec eb			  ex de,hl 
90ed			 
90ed 01 f0 d8		  ld bc,-10000 
90f0 3e 2f		  ld a,'0'-1 
90f2 3c			  inc a 
90f3 09			  add hl,bc  
90f4 38 fc		   jr c,$-2 
90f6 12			  ld (de),a 
90f7 13			  inc de 
90f8			 
90f8 01 e8 03		  ld bc,1000 
90fb 3e 3a		  ld a,'9'+1 
90fd 3d			  dec a  
90fe 09			  add hl,bc  
90ff 30 fc		   jr nc,$-2 
9101 12			  ld (de),a 
9102 13			  inc de 
9103			 
9103 01 9c ff		  ld bc,-100 
9106 3e 2f		  ld a,'0'-1 
9108 3c			  inc a  
9109 09			  add hl,bc  
910a 38 fc		   jr c,$-2 
910c 12			  ld (de),a 
910d 13			  inc de 
910e			 
910e 7d			  ld a,l 
910f 26 3a		  ld h,'9'+1 
9111 25			  dec h  
9112 c6 0a		  add a,10  
9114 30 fb		   jr nc,$-3 
9116 c6 30		  add a,'0' 
9118 eb			  ex de,hl 
9119 72			  ld (hl),d 
911a 23			  inc hl 
911b 77			  ld (hl),a 
911c 23			  inc hl 
911d 36 00		  ld (hl),0 
911f			 
911f			;Now strip the leading zeros 
911f 0e fa		  ld c,-6 
9121 09			  add hl,bc 
9122 3e 30		  ld a,'0' 
9124 23			  inc hl  
9125 be			  cp (hl)  
9126 28 fc		  jr z,$-2 
9128			 
9128			;Make sure that the string is non-empty! 
9128 7e			  ld a,(hl) 
9129 b7			  or a 
912a 20 01		  jr nz,.atoub 
912c 2b			  dec hl 
912d			.atoub: 
912d			 
912d f1			  pop af 
912e c1			  pop bc 
912f d1			  pop de 
9130 c9			  ret 
9131			 
9131			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9131			 
9131			toUpper: 
9131			;A is the char. 
9131			;If A is a lowercase letter, this sets it to the matching uppercase 
9131			;18cc or 30cc or 41cc 
9131			;avg: 26.75cc 
9131 fe 61		  cp 'a' 
9133 d8			  ret c 
9134 fe 7b		  cp 'z'+1 
9136 d0			  ret nc 
9137 d6 20		  sub 'a'-'A' 
9139 c9			  ret 
913a			 
913a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
913a			 
913a			; String Length 
913a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
913a			 
913a			; Get the length of the null-terminated string starting at $8000 hl 
913a			;    LD     HL, $8000 
913a			 
913a			strlenz: 
913a			 
913a af			    XOR    A               ; Zero is the value we are looking for. 
913b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913d			                           ; 65, 536 bytes (the entire addressable memory space). 
913d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913f			 
913f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9140 6f			    LD     L, A             ; number of bytes 
9141 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9143 2b			    DEC    HL              ; Compensate for null. 
9144 c9				ret 
9145			 
9145			; Get the length of the A terminated string starting at $8000 hl 
9145			;    LD     HL, $8000 
9145			 
9145			strlent: 
9145			 
9145			                  ; A is the value we are looking for. 
9145 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9147 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9149			                           ; 65, 536 bytes (the entire addressable memory space). 
9149 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914b			 
914b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914d 2e 00		    LD     L, 0             ; number of bytes 
914f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9151 2b			    DEC    HL              ; Compensate for null. 
9152 c9				ret 
9153			 
9153			 
9153			;Comparing Strings 
9153			 
9153			;IN    HL     Address of string1. 
9153			;      DE     Address of string2. 
9153			 
9153			; doc given but wrong??? 
9153			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9153			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9153			; tested 
9153			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9153			 
9153			strcmp_old: 
9153 e5			    PUSH   HL 
9154 d5			    PUSH   DE 
9155			 
9155 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9156 be			    CP     (HL)            ; (want to minimize work). 
9157 38 01		    JR     C, Str1IsBigger 
9159 7e			    LD     A, (HL) 
915a			 
915a			Str1IsBigger: 
915a 4f			    LD     C, A             ; Put length in BC 
915b 06 00		    LD     B, 0 
915d 13			    INC    DE              ; Increment pointers to meat of string. 
915e 23			    INC    HL 
915f			 
915f			CmpLoop: 
915f 1a			    LD     A, (DE)          ; Compare bytes. 
9160 ed a1		    CPI 
9162 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9164 13			    INC    DE              ; Update pointer. 
9165 ea 5f 91		    JP     PE, CmpLoop 
9168			 
9168 d1			    POP    DE 
9169 e1			    POP    HL 
916a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916b be			    CP     (HL) 
916c c9			    RET 
916d			 
916d			NoMatch: 
916d 2b			    DEC    HL 
916e be			    CP     (HL)            ; Compare again to affect carry. 
916f d1			    POP    DE 
9170 e1			    POP    HL 
9171 c9			    RET 
9172			 
9172			;; test strmp 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr z, .z1 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z1: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr z, .z2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr c, .c1 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c1: 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr c, .c2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;	NEXTW 
9172			;.str1:   db "string1",0 
9172			;.str2:   db "string2",0 
9172			 
9172			; only care about direct match or not 
9172			; hl and de strings 
9172			; zero set if the same 
9172			 
9172			strcmp: 
9172 1a				ld a, (de) 
9173 be				cp (hl) 
9174 28 02			jr z, .ssame 
9176 b7				or a 
9177 c9				ret 
9178			 
9178			.ssame:  
9178 fe 00			cp 0 
917a c8				ret z 
917b			 
917b 23				inc hl 
917c 13				inc de 
917d 18 f3			jr strcmp 
917f				 
917f				 
917f			 
917f			 
917f			 
917f			 
917f			; eof 
917f			 
917f			 
917f			 
917f			 
917f			 
917f			 
# End of file firmware_strings.asm
917f			include "firmware_memory.asm"   ; malloc and free  
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			.mallocsize: db "Wants malloc >256",0 
917f			.mallocasize: db "MALLOC gives >256",0 
917f			.malloczero: db "MALLOC gives zero",0 
917f			 
917f			malloc_guard_zerolen: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f				ld de, 0 
917f			        call cmp16 
917f				jr nz, .lowalloz 
917f			 
917f				push hl 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .malloczero 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				call bp_on 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f			.lowalloz: 
917f			 
917f			 
917f				pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_entry: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowalloc 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocsize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f				jr .lowdone 
917f			.lowalloc: 
917f			 
917f			 
917f				pop hl 
917f			.lowdone:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_exit: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowallocx 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocasize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f				pop de 
917f				pop hl 
917f			 
917f				CALLMONITOR 
917f				jr .lowdonex 
917f			.lowallocx: 
917f			 
917f				pop hl 
917f			.lowdonex:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			endif 
917f			 
917f			if MALLOC_2 
917f			; Z80 Malloc and Free Functions 
917f			 
917f			; Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc: 
917f				 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_entry 
917f			endif 
917f			 
917f			 
917f			 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "mal" 
917f						CALLMONITOR 
917f					endif 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of size into A 
917f			    or h               ; Check if size is zero 
917f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917f			 
917f			    ; Allocate memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma1" 
917f						CALLMONITOR 
917f					endif 
917f			    call malloc_internal ; Call internal malloc function 
917f			    pop af             ; Restore AF register 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret                ; Return 
917f			 
917f			; Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free: 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of pointer into A 
917f			    or h               ; Check if pointer is NULL 
917f			    jp z, free_exit    ; If pointer is NULL, exit 
917f			 
917f			    ; Free memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f			    call free_internal  ; Call internal free function 
917f			    pop af             ; Restore AF register 
917f			    ret                ; Return 
917f			 
917f			; Internal Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc_internal: 
917f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to requested size 
917f			    ex de, hl          ; Save total size in DE, and keep it in HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			 
917f			    ; Search for free memory block 
917f			    ld de, (heap_end)  ; Load end of heap into DE 
917f			    ld bc, 0           ; Initialize counter 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			malloc_search_loop: 
917f			    ; Check if current block is free 
917f			    ld a, (hl)         ; Load current block's status (free or used) 
917f			    cp 0               ; Compare with zero (free) 
917f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917f			 
917f			    ; Check if current block is large enough 
917f			    ld a, (hl+1)       ; Load high byte of block size 
917f			    cp l               ; Compare with low byte of requested size 
917f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917f			 
917f			    ld a, (hl+2)       ; Load low byte of block size 
917f			    cp h               ; Compare with high byte of requested size 
917f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917f			 
917f			    ; Mark block as used 
917f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917f			 
917f			    ; Calculate remaining space in block 
917f			    ld bc, 0           ; Clear BC 
917f			    add hl, bc         ; Increment HL to point to start of data block 
917f			    add hl, de         ; HL = HL + DE (total size) 
917f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to start of data block 
917f			 
917f			    ; Save pointer to allocated block in HL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma5" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			malloc_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3           ; Size of management overhead 
917f			    add hl, bc         ; Move to the next block 
917f			    inc de             ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e            ; Load low byte of heap end address 
917f			    cp (hl)            ; Compare with low byte of current address 
917f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917f			    ld a, d            ; Load high byte of heap end address 
917f			    cp 0               ; Check if it's zero (end of memory) 
917f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, allocation failed 
917f			    xor a              ; Set result to NULL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma6" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			malloc_exit: 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma7" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			; Internal Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free_internal: 
917f			    ld de, (heap_start) ; Load start of heap into DE 
917f			    ld bc, 0            ; Initialize counter 
917f			 
917f			free_search_loop: 
917f			    ; Check if current block contains the pointer 
917f			    ld a, l             ; Load low byte of pointer 
917f			    cp (hl+1)           ; Compare with high byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			    ld a, h             ; Load high byte of pointer 
917f			    cp (hl+2)           ; Compare with low byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			 
917f			    ; Mark block as free 
917f			    ld (hl), 0          ; Set status byte to indicate free block 
917f			    ret                 ; Return 
917f			 
917f			free_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3            ; Size of management overhead 
917f			    add hl, bc          ; Move to the next block 
917f			    inc de              ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e             ; Load low byte of heap end address 
917f			    cp (hl)             ; Compare with low byte of current address 
917f			    jr nz, free_search_loop  ; If not equal, continue searching 
917f			    ld a, d             ; Load high byte of heap end address 
917f			    cp 0                ; Check if it's zero (end of memory) 
917f			    jr nz, free_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, pointer is not found in heap 
917f			    ret 
917f			 
917f			free_exit: 
917f			    ret                 ; Return 
917f			 
917f			; Define heap start and end addresses 
917f			;heap_start:    .dw 0xC000   ; Start of heap 
917f			;heap_end:      .dw 0xE000   ; End of heap 
917f			 
917f			endif 
917f			 
917f			 
917f			if MALLOC_1 
917f			 
917f			 
917f			 
917f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917f			 
917f			;moved to firmware.asm 
917f			;heap_start        .equ  0x9000      ; Starting address of heap 
917f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917f			 
917f			;      .org 0 
917f			;      jp    main 
917f			 
917f			 
917f			;      .org  0x100 
917f			;main: 
917f			;      ld    HL, 0x8100 
917f			;      ld    SP, HL 
917f			; 
917f			;      call  heap_init 
917f			; 
917f			;      ; Make some allocations 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9004 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9014 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9024 
917f			; 
917f			;      ; Free some allocations 
917f			;      ld    HL, 0x9014 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9004 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9024 
917f			;      call  free 
917f			; 
917f			; 
917f			;      halt 
917f			 
917f			 
917f			;------------------------------------------------------------------------------ 
917f			;     heap_init                                                               : 
917f			;                                                                             : 
917f			; Description                                                                 : 
917f			;     Initialise the heap and make it ready for malloc and free operations.   : 
917f			;                                                                             : 
917f			;     The heap is maintained as a linked list, starting with an initial       : 
917f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917f			;     the first free block in the heap. Each block then points to the next    : 
917f			;     free block within the heap, and the free list ends at the first block   : 
917f			;     with a null pointer to the next free block.                             : 
917f			;                                                                             : 
917f			; Parameters                                                                  : 
917f			;     Inputs are compile-time only. Two defines which specify the starting    : 
917f			;     address of the heap and its size are required, along with a memory      : 
917f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917f			;     principally stores a pointer to the first free block in the heap.       : 
917f			;                                                                             : 
917f			; Returns                                                                     : 
917f			;     Nothing                                                                 : 
917f			;------------------------------------------------------------------------------ 
917f			heap_init: 
917f e5			      push  HL 
9180			 
9180			      ; Initialise free list struct 
9180 21 4c e4		      ld    HL, heap_start 
9183 22 47 e4		      ld    (free_list), HL 
9186 21 00 00		      ld    HL, 0 
9189 22 49 e4		      ld    (free_list+2), HL 
918c			 
918c			      ; Insert first free block at bottom of heap, consumes entire heap 
918c 21 a4 e2		      ld    HL, heap_start+heap_size-4 
918f 22 4c e4		      ld    (heap_start), HL        ; Next block (end of free list) 
9192 21 58 fe		      ld    HL, heap_size-4 
9195 22 4e e4		      ld    (heap_start+2), HL      ; Block size 
9198			 
9198			      ; Insert end of free list block at top of heap - two null words will 
9198			      ; terminate the free list 
9198 21 00 00		      ld    HL, 0 
919b 22 a6 e2		      ld    (heap_start+heap_size-2), HL 
919e 22 a4 e2		      ld    (heap_start+heap_size-4), HL 
91a1			 
91a1 e1			      pop   HL 
91a2			 
91a2 c9			      ret 
91a3			 
91a3			 
91a3			;------------------------------------------------------------------------------ 
91a3			;     malloc                                                                  : 
91a3			;                                                                             : 
91a3			; Description                                                                 : 
91a3			;     Allocates the wanted space from the heap and returns the address of the : 
91a3			;     first useable byte of the allocation.                                   : 
91a3			;                                                                             : 
91a3			;     Allocations can happen in one of two ways:                              : 
91a3			;                                                                             : 
91a3			;     1. A free block may be found which is the exact size wanted. In this    : 
91a3			;        case the block is removed from the free list and retuedn to the      : 
91a3			;        caller.                                                              : 
91a3			;     2. A free block may be found which is larger than the size wanted. In   : 
91a3			;        this case, the larger block is split into two. The first portion of  : 
91a3			;        this block will become the requested space by the malloc call and    : 
91a3			;        is returned to the caller. The second portion becomes a new free     : 
91a3			;        block, and the free list is adjusted to maintain continuity via this : 
91a3			;        newly created block.                                                 : 
91a3			;                                                                             : 
91a3			;     malloc does not set any initial value in the allocated space, the       : 
91a3			;     caller is required to do this as required.                              : 
91a3			;                                                                             : 
91a3			;     This implementation of malloc uses the stack exclusively, and is        : 
91a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a3			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a3			;     to avoid the use of malloc inside ISRs in general.                      : 
91a3			;                                                                             : 
91a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a3			;                                                                             : 
91a3			; Parameters                                                                  : 
91a3			;     HL  Number of bytes wanted                                              : 
91a3			;                                                                             : 
91a3			; Returns                                                                     : 
91a3			;     HL  Address of the first useable byte of the allocation                 : 
91a3			;                                                                             : 
91a3			; Flags                                                                       : 
91a3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a3			;                                                                             : 
91a3			; Stack frame                                                                 : 
91a3			;       |             |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     BC      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     DE      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     IX      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |  prev_free  |                                                       : 
91a3			;   +4  +-------------+                                                       : 
91a3			;       |  this_free  |                                                       : 
91a3			;   +2  +-------------+                                                       : 
91a3			;       |  next_free  |                                                       : 
91a3			;   +0  +-------------+                                                       : 
91a3			;       |             |                                                       : 
91a3			;                                                                             : 
91a3			;------------------------------------------------------------------------------ 
91a3			 
91a3			 
91a3			;malloc: 
91a3			; 
91a3			;	SAVESP ON 1 
91a3			; 
91a3			;	call malloc_code 
91a3			; 
91a3			;	CHECKSP ON 1 
91a3			;	ret 
91a3			 
91a3			 
91a3			malloc: 
91a3 c5			      push  BC 
91a4 d5			      push  DE 
91a5 dd e5		      push  IX 
91a7			if DEBUG_FORTH_MALLOC_HIGH 
91a7			call malloc_guard_entry 
91a7			endif 
91a7			 
91a7					if DEBUG_FORTH_MALLOC 
91a7						DMARK "mal" 
91a7						CALLMONITOR 
91a7					endif 
91a7 7c			      ld    A, H                    ; Exit if no space requested 
91a8 b5			      or    L 
91a9 ca 68 92		      jp    Z, malloc_early_exit 
91ac			 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			; 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			 
91ac			 
91ac			 
91ac			 
91ac					if DEBUG_FORTH_MALLOC 
91ac						DMARK "maA" 
91ac						CALLMONITOR 
91ac					endif 
91ac			      ; Set up stack frame 
91ac eb			      ex    DE, HL 
91ad 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91b0 39			      add   HL, SP 
91b1 f9			      ld    SP, HL 
91b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b6 dd 39		      add   IX, SP 
91b8			 
91b8			      ; Setup initial state 
91b8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91bb 19			      add   HL, DE 
91bc			 
91bc 44			      ld    B, H                    ; Move want to BC 
91bd 4d			      ld    C, L 
91be			 
91be 21 47 e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c1 dd 75 04		      ld    (IX+4), L 
91c4 dd 74 05		      ld    (IX+5), H 
91c7			 
91c7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c8 23			      inc   HL 
91c9 56			      ld    D, (HL) 
91ca dd 73 02		      ld    (IX+2), E 
91cd dd 72 03		      ld    (IX+3), D 
91d0 eb			      ex    DE, HL                  ; this_free ptr into HL 
91d1			 
91d1					if DEBUG_FORTH_MALLOC 
91d1						DMARK "maB" 
91d1						CALLMONITOR 
91d1					endif 
91d1			      ; Loop through free block list to find some space 
91d1			malloc_find_space: 
91d1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4			 
91d4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d5 b3			      or    E 
91d6 ca 62 92		      jp    Z, malloc_no_space 
91d9			 
91d9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91dc dd 72 01		      ld    (IX+1), D 
91df			 
91df			      ; Does this block have enough space to make the allocation? 
91df 23			      inc   HL                      ; Load free block size into DE 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3			 
91e3 eb			      ex    DE, HL                  ; Check size of block against want 
91e4 b7			      or    A                       ; Ensure carry flag clear 
91e5 ed 42		      sbc   HL, BC 
91e7 e5			      push  HL                      ; Store the result for later (new block size) 
91e8			 
91e8 ca 37 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91eb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ed			 
91ed			      ; this_free block is not big enough, setup ptrs to test next free block 
91ed e1			      pop   HL                      ; Discard previous result 
91ee			 
91ee dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f1 dd 66 03		      ld    H, (IX+3) 
91f4 dd 75 04		      ld    (IX+4), L 
91f7 dd 74 05		      ld    (IX+5), H 
91fa			 
91fa dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fd dd 66 01		      ld    H, (IX+1) 
9200 dd 75 02		      ld    (IX+2), L 
9203 dd 74 03		      ld    (IX+3), H 
9206			 
9206					if DEBUG_FORTH_MALLOC 
9206						DMARK "MA>" 
9206						CALLMONITOR 
9206					endif 
9206 18 c9		      jr    malloc_find_space 
9208			 
9208			      ; split a bigger block into two - requested size and remaining size 
9208			malloc_alloc_split: 
9208					if DEBUG_FORTH_MALLOC 
9208						DMARK "MAs" 
9208						CALLMONITOR 
9208					endif 
9208 eb			      ex    DE, HL                  ; Calculate address of new free block 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 2b			      dec   HL 
920c 09			      add   HL, BC 
920d			 
920d			      ; Create a new block and point it at next_free 
920d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9210 dd 56 01		      ld    D, (IX+1) 
9213			 
9213 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9214 23			      inc   HL 
9215 72			      ld    (HL), D 
9216			 
9216 d1			      pop   DE                      ; Store size of new block into new block 
9217 23			      inc   HL 
9218 73			      ld    (HL), E 
9219 23			      inc   HL 
921a 72			      ld    (HL), D 
921b			 
921b			      ; Update this_free ptr to point to new block 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9221 dd 56 03		      ld    D, (IX+3) 
9224			 
9224 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9227 dd 74 03		      ld    (IX+3), H 
922a			 
922a			      ; Modify this_free block to be allocation 
922a eb			      ex    DE, HL 
922b af			      xor   A                       ; Null the next block ptr of allocated block 
922c 77			      ld    (HL), A 
922d 23			      inc   HL 
922e 77			      ld    (HL), A 
922f			 
922f 23			      inc   HL                      ; Store want size into allocated block 
9230 71			      ld    (HL), C 
9231 23			      inc   HL 
9232 70			      ld    (HL), B 
9233 23			      inc   HL 
9234 e5			      push  HL                      ; Address of allocation to return 
9235			 
9235 18 19		      jr    malloc_update_links 
9237			 
9237			malloc_alloc_fit: 
9237 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9238			 
9238					if DEBUG_FORTH_MALLOC 
9238						DMARK "MAf" 
9238						CALLMONITOR 
9238					endif 
9238			      ; Modify this_free block to be allocation 
9238 eb			      ex    DE, HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b 2b			      dec   HL 
923c			 
923c af			      xor   A                       ; Null the next block ptr of allocated block 
923d 77			      ld    (HL), A 
923e 23			      inc   HL 
923f 77			      ld    (HL), A 
9240			 
9240 23			      inc   HL                      ; Store address of allocation to return 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 e5			      push  HL 
9244			 
9244			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9244 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9247 dd 66 01		      ld    H, (IX+1) 
924a			 
924a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924d dd 74 03		      ld    (IX+3), H 
9250			 
9250			 
9250			malloc_update_links: 
9250			      ; Update prev_free ptr to point to this_free 
9250 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9253 dd 66 05		      ld    H, (IX+5) 
9256			 
9256 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9259 dd 56 03		      ld    D, (IX+3) 
925c			 
925c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925d 23			      inc   HL 
925e 72			      ld    (HL), D 
925f			 
925f					if DEBUG_FORTH_MALLOC 
925f						DMARK "Mul" 
925f						CALLMONITOR 
925f					endif 
925f			      ; Clear the Z flag to indicate successful allocation 
925f 7a			      ld    A, D 
9260 b3			      or    E 
9261			 
9261 d1			      pop   DE                      ; Address of allocation 
9262					if DEBUG_FORTH_MALLOC 
9262						DMARK "MAu" 
9262						CALLMONITOR 
9262					endif 
9262			 
9262			malloc_no_space: 
9262 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9265 39			      add   HL, SP 
9266 f9			      ld    SP, HL 
9267			 
9267 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAN" 
9268						CALLMONITOR 
9268					endif 
9268			 
9268			malloc_early_exit: 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAx" 
9268						CALLMONITOR 
9268					endif 
9268 dd e1		      pop   IX 
926a d1			      pop   DE 
926b c1			      pop   BC 
926c			 
926c			if DEBUG_FORTH_MALLOC_HIGH 
926c			call malloc_guard_exit 
926c			call malloc_guard_zerolen 
926c			endif 
926c c9			      ret 
926d			 
926d			 
926d			;------------------------------------------------------------------------------ 
926d			;     free                                                                    : 
926d			;                                                                             : 
926d			; Description                                                                 : 
926d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926d			;     returned by malloc, otherwise the behaviour is undefined.               : 
926d			;                                                                             : 
926d			;     Where possible, directly adjacent free blocks will be merged together   : 
926d			;     into larger blocks to help ensure that the heap does not become         : 
926d			;     excessively fragmented.                                                 : 
926d			;                                                                             : 
926d			;     free does not clear or set any other value into the freed space, and    : 
926d			;     therefore its contents may be visible through subsequent malloc's. The  : 
926d			;     caller should clear the freed space as required.                        : 
926d			;                                                                             : 
926d			;     This implementation of free uses the stack exclusively, and is          : 
926d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926d			;     advisable to disable interrupts before calling free, and recommended    : 
926d			;     to avoid the use of free inside ISRs in general.                        : 
926d			;                                                                             : 
926d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926d			;                                                                             : 
926d			; Parameters                                                                  : 
926d			;     HL  Pointer to address of first byte of allocation to be freed          : 
926d			;                                                                             : 
926d			; Returns                                                                     : 
926d			;     Nothing                                                                 : 
926d			;                                                                             : 
926d			; Stack frame                                                                 : 
926d			;       |             |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     BC      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     DE      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     IX      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |  prev_free  |                                                       : 
926d			;   +2  +-------------+                                                       : 
926d			;       |  next_free  |                                                       : 
926d			;   +0  +-------------+                                                       : 
926d			;       |             |                                                       : 
926d			;                                                                             : 
926d			;------------------------------------------------------------------------------ 
926d			free: 
926d c5			      push  BC 
926e d5			      push  DE 
926f dd e5		      push  IX 
9271			 
9271 7c			      ld    A, H                    ; Exit if ptr is null 
9272 b5			      or    L 
9273 ca 37 93		      jp    Z, free_early_exit 
9276			 
9276			      ; Set up stack frame 
9276 eb			      ex    DE, HL 
9277 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
927a 39			      add   HL, SP 
927b f9			      ld    SP, HL 
927c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9280 dd 39		      add   IX, SP 
9282			 
9282			      ; The address in HL points to the start of the useable allocated space, 
9282			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9282			      ; address of the block itself. 
9282 eb			      ex    DE, HL 
9283 11 fc ff		      ld    DE, -4 
9286 19			      add   HL, DE 
9287			 
9287			      ; An allocated block must have a null next block pointer in it 
9287 7e			      ld    A, (HL) 
9288 23			      inc   HL 
9289 b6			      or    (HL) 
928a c2 32 93		      jp    NZ, free_done 
928d			 
928d 2b			      dec   HL 
928e			 
928e 44			      ld    B, H                    ; Copy HL to BC 
928f 4d			      ld    C, L 
9290			 
9290			      ; Loop through the free list to find the first block with an address 
9290			      ; higher than the block being freed 
9290 21 47 e4		      ld    HL, free_list 
9293			 
9293			free_find_higher_block: 
9293 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9294 23			      inc   HL 
9295 56			      ld    D, (HL) 
9296 2b			      dec   HL 
9297			 
9297 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
929a dd 72 01		      ld    (IX+1), D 
929d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92a0 dd 74 03		      ld    (IX+3), H 
92a3			 
92a3 78			      ld    A, B                    ; Check if DE is greater than BC 
92a4 ba			      cp    D                       ; Compare MSB first 
92a5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a7 30 04		      jr    NC, free_find_higher_block_skip 
92a9 79			      ld    A, C 
92aa bb			      cp    E                       ; Then compare LSB 
92ab 38 08		      jr    C, free_found_higher_block 
92ad			 
92ad			free_find_higher_block_skip: 
92ad 7a			      ld    A, D                    ; Reached the end of the free list? 
92ae b3			      or    E 
92af ca 32 93		      jp    Z, free_done 
92b2			 
92b2 eb			      ex    DE, HL 
92b3			 
92b3 18 de		      jr    free_find_higher_block 
92b5			 
92b5			free_found_higher_block: 
92b5			      ; Insert freed block between prev and next free blocks 
92b5 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b6 23			      inc   HL 
92b7 70			      ld    (HL), B 
92b8			 
92b8 60			      ld    H, B                    ; Point freed block at next free block 
92b9 69			      ld    L, C 
92ba 73			      ld    (HL), E 
92bb 23			      inc   HL 
92bc 72			      ld    (HL), D 
92bd			 
92bd			      ; Check if the freed block is adjacent to the next free block 
92bd 23			      inc   HL                      ; Load size of freed block into HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 eb			      ex    DE, HL 
92c2			 
92c2 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c3			 
92c3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c6 dd 56 01		      ld    D, (IX+1) 
92c9			 
92c9 b7			      or    A                       ; Clear the carry flag 
92ca ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cc 20 22		      jr    NZ, free_check_adjacent_to_prev 
92ce			 
92ce			      ; Freed block is adjacent to next, merge into one bigger block 
92ce eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92cf 5e			      ld    E, (HL) 
92d0 23			      inc   HL 
92d1 56			      ld    D, (HL) 
92d2 e5			      push  HL                      ; Save ptr to next block for later 
92d3			 
92d3 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d4 69			      ld    L, C 
92d5 73			      ld    (HL), E 
92d6 23			      inc   HL 
92d7 72			      ld    (HL), D 
92d8			 
92d8 e1			      pop   HL                      ; Restore ptr to next block 
92d9 23			      inc   HL                      ; Load size of next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd d5			      push  DE                      ; Save next block size for later 
92de			 
92de 60			      ld    H, B                    ; Load size of freed block into HL 
92df 69			      ld    L, C 
92e0 23			      inc   HL 
92e1 23			      inc   HL 
92e2 5e			      ld    E, (HL) 
92e3 23			      inc   HL 
92e4 56			      ld    D, (HL) 
92e5 eb			      ex    DE, HL 
92e6			 
92e6 d1			      pop   DE                      ; Restore size of next block 
92e7 19			      add   HL, DE                  ; Add sizes of both blocks 
92e8 eb			      ex    DE, HL 
92e9			 
92e9 60			      ld    H, B                    ; Store new bigger size into freed block 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 73			      ld    (HL), E 
92ee 23			      inc   HL 
92ef 72			      ld    (HL), D 
92f0			 
92f0			free_check_adjacent_to_prev: 
92f0			      ; Check if the freed block is adjacent to the prev free block 
92f0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f3 dd 66 03		      ld    H, (IX+3) 
92f6			 
92f6 23			      inc   HL                      ; Size of prev free block into DE 
92f7 23			      inc   HL 
92f8 5e			      ld    E, (HL) 
92f9 23			      inc   HL 
92fa 56			      ld    D, (HL) 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd 2b			      dec   HL 
92fe			 
92fe 19			      add   HL, DE                  ; Add prev block addr and size 
92ff			 
92ff b7			      or    A                       ; Clear the carry flag 
9300 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302 20 2e		      jr    NZ, free_done 
9304			 
9304			      ; Freed block is adjacent to prev, merge into one bigger block 
9304 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9305 69			      ld    L, C 
9306 5e			      ld    E, (HL) 
9307 23			      inc   HL 
9308 56			      ld    D, (HL) 
9309 e5			      push  HL                      ; Save freed block ptr for later 
930a			 
930a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930d dd 66 03		      ld    H, (IX+3) 
9310 73			      ld    (HL), E 
9311 23			      inc   HL 
9312 72			      ld    (HL), D 
9313			 
9313 e1			      pop   HL                      ; Restore freed block ptr 
9314 23			      inc   HL                      ; Load size of freed block into DE 
9315 5e			      ld    E, (HL) 
9316 23			      inc   HL 
9317 56			      ld    D, (HL) 
9318 d5			      push  DE                      ; Save freed block size for later 
9319			 
9319 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931c dd 66 03		      ld    H, (IX+3) 
931f 23			      inc   HL 
9320 23			      inc   HL 
9321 5e			      ld    E, (HL) 
9322 23			      inc   HL 
9323 56			      ld    D, (HL) 
9324			 
9324 e1			      pop   HL                      ; Add sizes of both blocks 
9325 19			      add   HL, DE 
9326 eb			      ex    DE, HL 
9327			 
9327 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
932a dd 66 03		      ld    H, (IX+3) 
932d 23			      inc   HL 
932e 23			      inc   HL 
932f 73			      ld    (HL), E 
9330 23			      inc   HL 
9331 72			      ld    (HL), D 
9332			 
9332			free_done: 
9332 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9335 39			      add   HL, SP 
9336 f9			      ld    SP, HL 
9337			 
9337			free_early_exit: 
9337 dd e1		      pop   IX 
9339 d1			      pop   DE 
933a c1			      pop   BC 
933b			 
933b c9			      ret 
933c			 
933c			; moved to firmware.asm 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			;                  .dw   0 
933c			 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_3 
933c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933c			;heap_start        .equ  0x9000      ; Starting address of heap 
933c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933c			; 
933c			 ;     .org 0 
933c			  ;    jp    main 
933c			; 
933c			; 
933c			 ;     .org  0x100 
933c			;main: 
933c			 ;     ld    HL, 0x8100 
933c			  ;    ld    SP, HL 
933c			; 
933c			;      call  heap_init 
933c			 
933c			      ; Make some allocations 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9004 
933c			; 
933c			 ;     ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9014 
933c			 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9024 
933c			 
933c			      ; Free some allocations 
933c			;      ld    HL, 0x9014 
933c			;      call  free 
933c			 
933c			;      ld    HL, 0x9004 
933c			;      call  free 
933c			; 
933c			;      ld    HL, 0x9024 
933c			;      call  free 
933c			 
933c			 
933c			 ;     halt 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     heap_init                                                               : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Initialise the heap and make it ready for malloc and free operations.   : 
933c			;                                                                             : 
933c			;     The heap is maintained as a linked list, starting with an initial       : 
933c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933c			;     the first free block in the heap. Each block then points to the next    : 
933c			;     free block within the heap, and the free list ends at the first block   : 
933c			;     with a null pointer to the next free block.                             : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     Inputs are compile-time only. Two defines which specify the starting    : 
933c			;     address of the heap and its size are required, along with a memory      : 
933c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933c			;     principally stores a pointer to the first free block in the heap.       : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;------------------------------------------------------------------------------ 
933c			heap_init: 
933c			      push  HL 
933c			 
933c			      ; Initialise free list struct 
933c			      ld    HL, heap_start 
933c			      ld    (free_list), HL 
933c			      ld    HL, 0 
933c			      ld    (free_list+2), HL 
933c			 
933c			      ; Insert first free block at bottom of heap, consumes entire heap 
933c			      ld    HL, heap_start+heap_size-4 
933c			      ld    (heap_start), HL        ; Next block (end of free list) 
933c			      ld    HL, heap_size-4 
933c			      ld    (heap_start+2), HL      ; Block size 
933c			 
933c			      ; Insert end of free list block at top of heap - two null words will 
933c			      ; terminate the free list 
933c			      ld    HL, 0 
933c			      ld    (heap_start+heap_size-2), HL 
933c			      ld    (heap_start+heap_size-4), HL 
933c			 
933c			      pop   HL 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     malloc                                                                  : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Allocates the wanted space from the heap and returns the address of the : 
933c			;     first useable byte of the allocation.                                   : 
933c			;                                                                             : 
933c			;     Allocations can happen in one of two ways:                              : 
933c			;                                                                             : 
933c			;     1. A free block may be found which is the exact size wanted. In this    : 
933c			;        case the block is removed from the free list and retuedn to the      : 
933c			;        caller.                                                              : 
933c			;     2. A free block may be found which is larger than the size wanted. In   : 
933c			;        this case, the larger block is split into two. The first portion of  : 
933c			;        this block will become the requested space by the malloc call and    : 
933c			;        is returned to the caller. The second portion becomes a new free     : 
933c			;        block, and the free list is adjusted to maintain continuity via this : 
933c			;        newly created block.                                                 : 
933c			;                                                                             : 
933c			;     malloc does not set any initial value in the allocated space, the       : 
933c			;     caller is required to do this as required.                              : 
933c			;                                                                             : 
933c			;     This implementation of malloc uses the stack exclusively, and is        : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling malloc, and recommended  : 
933c			;     to avoid the use of malloc inside ISRs in general.                      : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Number of bytes wanted                                              : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     HL  Address of the first useable byte of the allocation                 : 
933c			;                                                                             : 
933c			; Flags                                                                       : 
933c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +4  +-------------+                                                       : 
933c			;       |  this_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			malloc: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if no space requested 
933c			      or    L 
933c			      jp    Z, malloc_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; Setup initial state 
933c			      ld    HL, 4                   ; want must also include space used by block struct 
933c			      add   HL, DE 
933c			 
933c			      ld    B, H                    ; Move want to BC 
933c			      ld    C, L 
933c			 
933c			      ld    HL, free_list           ; Store prev_free ptr to stack 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    E, (HL)                 ; Store this_free ptr to stack 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ld    (IX+2), E 
933c			      ld    (IX+3), D 
933c			      ex    DE, HL                  ; this_free ptr into HL 
933c			 
933c			      ; Loop through free block list to find some space 
933c			malloc_find_space: 
933c			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933c			      or    E 
933c			      jp    Z, malloc_no_space 
933c			 
933c			      ld    (IX+0), E               ; Store next_free ptr to stack 
933c			      ld    (IX+1), D 
933c			 
933c			      ; Does this block have enough space to make the allocation? 
933c			      inc   HL                      ; Load free block size into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ex    DE, HL                  ; Check size of block against want 
933c			      or    A                       ; Ensure carry flag clear 
933c			      sbc   HL, BC 
933c			      push  HL                      ; Store the result for later (new block size) 
933c			 
933c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933c			 
933c			      ; this_free block is not big enough, setup ptrs to test next free block 
933c			      pop   HL                      ; Discard previous result 
933c			 
933c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933c			      ld    H, (IX+3) 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933c			      ld    H, (IX+1) 
933c			      ld    (IX+2), L 
933c			      ld    (IX+3), H 
933c			 
933c			      jr    malloc_find_space 
933c			 
933c			      ; split a bigger block into two - requested size and remaining size 
933c			malloc_alloc_split: 
933c			      ex    DE, HL                  ; Calculate address of new free block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      add   HL, BC 
933c			 
933c			      ; Create a new block and point it at next_free 
933c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      ld    (HL), E                 ; Store next_free ptr into new block 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   DE                      ; Store size of new block into new block 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Update this_free ptr to point to new block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933c			      ld    (IX+3), H 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store want size into allocated block 
933c			      ld    (HL), C 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			      inc   HL 
933c			      push  HL                      ; Address of allocation to return 
933c			 
933c			      jr    malloc_update_links 
933c			 
933c			malloc_alloc_fit: 
933c			      pop   HL                      ; Dont need new block size, want is exact fit 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store address of allocation to return 
933c			      inc   HL 
933c			      inc   HL 
933c			      push  HL 
933c			 
933c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933c			      ld    L, (IX+0)               ; next_free to HL 
933c			      ld    H, (IX+1) 
933c			 
933c			      ld    (IX+2), L               ; HL to this_free 
933c			      ld    (IX+3), H 
933c			 
933c			 
933c			malloc_update_links: 
933c			      ; Update prev_free ptr to point to this_free 
933c			      ld    L, (IX+4)               ; prev_free ptr to HL 
933c			      ld    H, (IX+5) 
933c			 
933c			      ld    E, (IX+2)               ; this_free ptr to DE 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (HL), E                 ; this_free ptr into prev_free 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Clear the Z flag to indicate successful allocation 
933c			      ld    A, D 
933c			      or    E 
933c			 
933c			      pop   DE                      ; Address of allocation 
933c			 
933c			malloc_no_space: 
933c			      ld    HL, 6                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			      ex    DE, HL                  ; Alloc addr into HL for return 
933c			 
933c			malloc_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     free                                                                    : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933c			;     returned by malloc, otherwise the behaviour is undefined.               : 
933c			;                                                                             : 
933c			;     Where possible, directly adjacent free blocks will be merged together   : 
933c			;     into larger blocks to help ensure that the heap does not become         : 
933c			;     excessively fragmented.                                                 : 
933c			;                                                                             : 
933c			;     free does not clear or set any other value into the freed space, and    : 
933c			;     therefore its contents may be visible through subsequent malloc's. The  : 
933c			;     caller should clear the freed space as required.                        : 
933c			;                                                                             : 
933c			;     This implementation of free uses the stack exclusively, and is          : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling free, and recommended    : 
933c			;     to avoid the use of free inside ISRs in general.                        : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Pointer to address of first byte of allocation to be freed          : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			free: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if ptr is null 
933c			      or    L 
933c			      jp    Z, free_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; The address in HL points to the start of the useable allocated space, 
933c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933c			      ; address of the block itself. 
933c			      ex    DE, HL 
933c			      ld    DE, -4 
933c			      add   HL, DE 
933c			 
933c			      ; An allocated block must have a null next block pointer in it 
933c			      ld    A, (HL) 
933c			      inc   HL 
933c			      or    (HL) 
933c			      jp    NZ, free_done 
933c			 
933c			      dec   HL 
933c			 
933c			      ld    B, H                    ; Copy HL to BC 
933c			      ld    C, L 
933c			 
933c			      ; Loop through the free list to find the first block with an address 
933c			      ; higher than the block being freed 
933c			      ld    HL, free_list 
933c			 
933c			free_find_higher_block: 
933c			      ld    E, (HL)                 ; Load next ptr from free block 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			 
933c			      ld    (IX+0), E               ; Save ptr to next free block 
933c			      ld    (IX+1), D 
933c			      ld    (IX+2), L               ; Save ptr to prev free block 
933c			      ld    (IX+3), H 
933c			 
933c			      ld    A, B                    ; Check if DE is greater than BC 
933c			      cp    D                       ; Compare MSB first 
933c			      jr    Z, $+4                  ; MSB the same, compare LSB 
933c			      jr    NC, free_find_higher_block_skip 
933c			      ld    A, C 
933c			      cp    E                       ; Then compare LSB 
933c			      jr    C, free_found_higher_block 
933c			 
933c			free_find_higher_block_skip: 
933c			      ld    A, D                    ; Reached the end of the free list? 
933c			      or    E 
933c			      jp    Z, free_done 
933c			 
933c			      ex    DE, HL 
933c			 
933c			      jr    free_find_higher_block 
933c			 
933c			free_found_higher_block: 
933c			      ; Insert freed block between prev and next free blocks 
933c			      ld    (HL), C                 ; Point prev free block to freed block 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			 
933c			      ld    H, B                    ; Point freed block at next free block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Check if the freed block is adjacent to the next free block 
933c			      inc   HL                      ; Load size of freed block into HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      add   HL, BC                  ; Add addr of freed block and its size 
933c			 
933c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_check_adjacent_to_prev 
933c			 
933c			      ; Freed block is adjacent to next, merge into one bigger block 
933c			      ex    DE, HL                  ; Load next ptr from next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save ptr to next block for later 
933c			 
933c			      ld    H, B                    ; Store ptr from next block into freed block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore ptr to next block 
933c			      inc   HL                      ; Load size of next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save next block size for later 
933c			 
933c			      ld    H, B                    ; Load size of freed block into HL 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      pop   DE                      ; Restore size of next block 
933c			      add   HL, DE                  ; Add sizes of both blocks 
933c			      ex    DE, HL 
933c			 
933c			      ld    H, B                    ; Store new bigger size into freed block 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_check_adjacent_to_prev: 
933c			      ; Check if the freed block is adjacent to the prev free block 
933c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933c			      ld    H, (IX+3) 
933c			 
933c			      inc   HL                      ; Size of prev free block into DE 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      add   HL, DE                  ; Add prev block addr and size 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_done 
933c			 
933c			      ; Freed block is adjacent to prev, merge into one bigger block 
933c			      ld    H, B                    ; Load next ptr from freed block into DE 
933c			      ld    L, C 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save freed block ptr for later 
933c			 
933c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933c			      ld    H, (IX+3) 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore freed block ptr 
933c			      inc   HL                      ; Load size of freed block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save freed block size for later 
933c			 
933c			      ld    L, (IX+2)               ; Load size of prev block into DE 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      pop   HL                      ; Add sizes of both blocks 
933c			      add   HL, DE 
933c			      ex    DE, HL 
933c			 
933c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_done: 
933c			      ld    HL, 4                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			free_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;      .org 0x8000 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			 ;                 .dw   0 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_4 
933c			 
933c			; My memory allocation code. Very very simple.... 
933c			; allocate space under 250 chars 
933c			 
933c			heap_init: 
933c				; init start of heap as zero 
933c				;  
933c			 
933c				ld hl, heap_start 
933c				ld a, 0 
933c				ld (hl), a      ; empty block 
933c				inc hl 
933c				ld a, 0 
933c				ld (hl), a      ; length of block 
933c				; write end of list 
933c				inc hl 
933c				ld a,(hl) 
933c				inc hl 
933c				ld a,(hl) 
933c				 
933c			 
933c				; init some malloc vars 
933c			 
933c				ld hl, 0 
933c				ld (free_list), hl       ; store last malloc location 
933c			 
933c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933c				ld a, 0 
933c				ld (hl), a 
933c			 
933c			 
933c				ld hl, heap_start 
933c				;  
933c				  
933c				ret 
933c			 
933c			 
933c			;    free block marker 
933c			;    requested size  
933c			;    pointer to next block 
933c			;    .... 
933c			;    next block marker 
933c			 
933c			 
933c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933c			; 
933c			 
933c			 
933c			malloc:  
933c				push de 
933c				push bc 
933c				push af 
933c			 
933c				; hl space required 
933c				 
933c				ld c, l    ; hold space   (TODO only a max of 255) 
933c			 
933c			;	inc c     ; TODO BUG need to fix memory leak on push str 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			 
933c			 
933c			 
933c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933c			 
933c				ld a, (free_list+3) 
933c				cp 0 
933c				jr z, .contheap 
933c			 
933c				ld hl, (free_list)     ; get last alloc 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mrs" 
933c						CALLMONITOR 
933c					endif 
933c				jr .startalloc 
933c			 
933c			.contheap: 
933c				ld hl, heap_start 
933c			 
933c			.startalloc: 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mym" 
933c						CALLMONITOR 
933c					endif 
933c			.findblock: 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmf" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c				ld a,(hl)  
933c				; if byte is zero then clear to use 
933c			 
933c				cp 0 
933c				jr z, .foundemptyblock 
933c			 
933c				; if byte is not clear 
933c				;     then byte is offset to next block 
933c			 
933c				inc hl 
933c				ld a, (hl) ; get size 
933c			.nextblock:	inc hl 
933c					ld e, (hl) 
933c					inc hl 
933c					ld d, (hl) 
933c					ex de, hl 
933c			;	inc hl  ; move past the store space 
933c			;	inc hl  ; move past zero index  
933c			 
933c				; TODO detect no more space 
933c			 
933c				push hl 
933c				ld de, heap_end 
933c				call cmp16 
933c				pop hl 
933c				jr nc, .nospace 
933c			 
933c				jr .findblock 
933c			 
933c			.nospace: ld hl, 0 
933c				jp .exit 
933c			 
933c			 
933c			.foundemptyblock:	 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mme" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; TODO has block enough space if reusing??? 
933c			 
933c				;  
933c			 
933c			; see if this block has been previously used 
933c				inc hl 
933c				ld a, (hl) 
933c				dec hl 
933c				cp 0 
933c				jr z, .newblock 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meR" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; no reusing previously allocated block 
933c			 
933c			; is it smaller than previously used? 
933c				 
933c				inc hl    ; move to size 
933c				ld a, c 
933c				sub (hl)        ; we want c < (hl) 
933c				dec hl    ; move back to marker 
933c			        jr z, .findblock 
933c			 
933c				; update with the new size which should be lower 
933c			 
933c			        ;inc  hl   ; negate next move. move back to size  
933c			 
933c			.newblock: 
933c				; need to be at marker here 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meN" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			 
933c				ld a, c 
933c			 
933c				ld (free_list+3), a	 ; flag resume from last malloc  
933c				ld (free_list), hl    ; save out last location 
933c			 
933c			 
933c				;inc a     ; space for length byte 
933c				ld (hl), a     ; save block in use marker 
933c			 
933c				inc hl   ; move to space marker 
933c				ld (hl), a    ; save new space 
933c			 
933c				inc hl   ; move to start of allocated area 
933c				 
933c			;	push hl     ; save where we are - 1  
933c			 
933c			;	inc hl  ; move past zero index  
933c				; skip space to set down new marker 
933c			 
933c				; provide some extra space for now 
933c			 
933c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933c				inc a 
933c				inc a 
933c			 
933c				push hl   ; save where we are in the node block 
933c			 
933c				call addatohl 
933c			 
933c				; write linked list point 
933c			 
933c				pop de     ; get our node position 
933c				ex de, hl 
933c			 
933c				ld (hl), e 
933c				inc hl 
933c				ld (hl), d 
933c			 
933c				inc hl 
933c			 
933c				; now at start of allocated data so save pointer 
933c			 
933c				push hl 
933c			 
933c				; jump to position of next node and setup empty header in DE 
933c			 
933c				ex de, hl 
933c			 
933c			;	inc hl ; move past end of block 
933c			 
933c				ld a, 0 
933c				ld (hl), a   ; empty marker 
933c				inc hl 
933c				ld (hl), a   ; size 
933c				inc hl  
933c				ld (hl), a   ; ptr 
933c				inc hl 
933c				ld (hl), a   ; ptr 
933c			 
933c			 
933c				pop hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmr" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			.exit: 
933c				pop af 
933c				pop bc 
933c				pop de  
933c				ret 
933c			 
933c			 
933c			 
933c			 
933c			free:  
933c				push hl 
933c				push af 
933c				; get address in hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "fre" 
933c						CALLMONITOR 
933c					endif 
933c				; data is at hl - move to block count 
933c				dec hl 
933c				dec hl    ; get past pointer 
933c				dec hl 
933c			 
933c				ld a, (hl)    ; need this for a validation check 
933c			 
933c				dec hl    ; move to block marker 
933c			 
933c				; now check that the block count and block marker are the same  
933c			        ; this checks that we are on a malloc node and not random memory 
933c			        ; OK a faint chance this could be a problem but rare - famous last words! 
933c			 
933c				ld c, a 
933c				ld a, (hl)    
933c			 
933c				cp c 
933c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933c			 
933c				; yes good chance we are on a malloc node 
933c			 
933c				ld a, 0      
933c				ld (hl), a   ; mark as free 
933c			 
933c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933c			 
933c			.freeignore:  
933c			 
933c				pop af 
933c				pop hl 
933c			 
933c				ret 
933c			 
933c			 
933c			 
933c			endif 
933c			 
933c			; eof 
# End of file firmware_memory.asm
933c			  
933c			; device C  
933c			; Now handled by SPI  
933c			;if SOUND_ENABLE  
933c			;	include "firmware_sound.asm"  
933c			;endif  
933c			  
933c			include "firmware_diags.asm"  
933c			; Hardware diags menu 
933c			 
933c			 
933c			config: 
933c			 
933c 3e 00			ld a, 0 
933e 21 62 93			ld hl, .configmn 
9341 cd e0 8a			call menu 
9344			 
9344 fe 00			cp 0 
9346 c8				ret z 
9347			 
9347			;	cp 1 
9347			;	call z, .savetostore 
9347			 
9347 fe 01			cp 1 
9349			if STARTUP_V1 
9349 cc 78 93			call z, .selautoload 
934c			endif 
934c			 
934c			if STARTUP_V2 
934c				call z, .enautoload 
934c			endif 
934c fe 02			cp 2 
934e cc 6e 93			call z, .disautoload 
9351			;	cp 3 
9351			;	call z, .selbank 
9351 fe 03			cp 3 
9353 cc 96 93			call z, .debug_tog 
9356 fe 04			cp 4 
9358 cc e4 94			call z, .bpsgo 
935b fe 05			cp 5 
935d cc bf 93			call z, hardware_diags 
9360			if STARTUP_V2 
9360				cp 6 
9360				call z, create_startup 
9360			endif 
9360 18 da			jr config 
9362			 
9362			.configmn: 
9362			;	dw prom_c3 
9362 d2 96			dw prom_c2 
9364 e7 96			dw prom_c2a 
9366			;	dw prom_c2b 
9366			;	dw prom_c4 
9366 06 97			dw prom_m4 
9368 21 97			dw prom_m4b 
936a 29 97			dw prom_c1 
936c			if STARTUP_V2 
936c				dw prom_c9 
936c			endif 
936c 00 00			dw 0 
936e				 
936e			 
936e			if STARTUP_V2 
936e			.enautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 1 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e				ld hl, prom_notav 
936e				ld de, prom_empty 
936e				call info_panel 
936e				endif 
936e			 
936e			 
936e				ret 
936e			endif 
936e			 
936e			.disautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 0 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e 21 38 97			ld hl, prom_notav 
9371 11 4e 97			ld de, prom_empty 
9374 cd 40 8a			call info_panel 
9377				endif 
9377			 
9377			 
9377 c9				ret 
9378			 
9378			if STARTUP_V1 
9378			 
9378			; Select auto start 
9378			 
9378			.selautoload: 
9378			 
9378				 
9378				if STORAGE_SE 
9378			 
9378					call config_dir 
9378				        ld hl, scratch 
9378					ld a, 0 
9378					call menu 
9378			 
9378					cp 0 
9378					ret z 
9378			 
9378					dec a 
9378			 
9378			 
9378					; locate menu option 
9378			 
9378					ld hl, scratch 
9378					call table_lookup 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALl" 
9378						CALLMONITOR 
9378					endif 
9378					; with the pointer to the menu it, the byte following the zero term is the file id 
9378			 
9378					ld a, 0 
9378					ld bc, 50   ; max of bytes to look at 
9378					cpir  
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALb" 
9378						CALLMONITOR 
9378					endif 
9378					;inc hl 
9378			 
9378					ld a, (hl)   ; file id 
9378					 
9378				        ; save bank and file ids 
9378			 
9378					push af 
9378			 
9378			; TODO need to save to block 0 on bank 1	 
9378			 
9378					call storage_get_block_0 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "AL0" 
9378						CALLMONITOR 
9378					endif 
9378					pop af 
9378			 
9378					ld (store_page+STORE_0_FILERUN),a 
9378					 
9378					; save bank id 
9378			 
9378					ld a,(spi_device) 
9378					ld (store_page+STORE_0_BANKRUN),a 
9378			 
9378					; enable auto run of store file 
9378			 
9378					ld a, 1 
9378					ld (store_page+STORE_0_AUTOFILE),a 
9378			 
9378					; save buffer 
9378			 
9378					ld hl, 0 
9378					ld de, store_page 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALw" 
9378						CALLMONITOR 
9378					endif 
9378				call storage_write_block	 ; save update 
9378			  
9378			 
9378			 
9378			 
9378					ld hl, scratch 
9378					call config_fdir 
9378			 
9378				else 
9378			 
9378 21 38 97			ld hl, prom_notav 
937b 11 4e 97			ld de, prom_empty 
937e cd 40 8a			call info_panel 
9381			 
9381				endif 
9381 c9				ret 
9382			endif 
9382			 
9382			 
9382			; Select storage bank 
9382			 
9382			.selbank: 
9382			 
9382			;	if STORAGE_SE 
9382			;	else 
9382			 
9382 21 38 97			ld hl, prom_notav 
9385 11 4e 97			ld de, prom_empty 
9388 cd 40 8a			call info_panel 
938b			;	endif 
938b				 
938b c9				ret 
938c			 
938c			if STORAGE_SE 
938c			 
938c			.config_ldir:   
938c				; Load storage bank labels into menu array 
938c			 
938c				 
938c			 
938c			 
938c				ret 
938c			 
938c			 
938c			endif 
938c			 
938c			 
938c			; Save user words to storage 
938c			 
938c			.savetostore: 
938c			 
938c			;	if STORAGE_SE 
938c			; 
938c			;		call config_dir 
938c			;	        ld hl, scratch 
938c			;		ld a, 0 
938c			;		call menu 
938c			;		 
938c			;		ld hl, scratch 
938c			;		call config_fdir 
938c			; 
938c			;	else 
938c			 
938c 21 38 97			ld hl, prom_notav 
938f 11 4e 97			ld de, prom_empty 
9392 cd 40 8a			call info_panel 
9395			 
9395			;	endif 
9395			 
9395 c9				ret 
9396			 
9396			if STARTUP_V2 
9396			 
9396			create_startup: 
9396			 
9396				ld a, 0 
9396				ld hl, .crstart 
9396				call menu 
9396			 
9396				cp 0 
9396				ret z 
9396			 
9396				cp 1 
9396				call z, .genlsword 
9396				cp 2 
9396				call z, .genedword 
9396			 
9396				cp 3 
9396				call z, .gendemword 
9396			 
9396				cp 4 
9396				call z, .genutlword 
9396				cp 5 
9396				call z, .genspiword 
9396				cp 6 
9396				call z, .genkeyword 
9396				cp 7 
9396				call z, .gensoundword 
9396				jr create_startup 
9396			 
9396			.gensoundword: 
9396				ld hl, crs_sound 
9396				ld de, .soundworddef 
9396				call .genfile 
9396				ret 
9396			.genlsword: 
9396				ld hl, crs_s1 
9396				ld de, .lsworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			.genedword: 
9396				ld de, .edworddef 
9396				ld hl, crs_s2 
9396				call .genfile 
9396				ret 
9396			 
9396			.gendemword: 
9396				ld de, .demoworddef 
9396				ld hl, crs_s3 
9396				call .genfile 
9396				ret 
9396			 
9396			.genutlword: 
9396				ld hl, crs_s4 
9396				ld de, .utilwordef 
9396				call .genfile 
9396				ret 
9396			.genspiword: 
9396				ld hl, crs_s5 
9396				ld de, .spiworddef 
9396				call .genfile 
9396				ret 
9396			.genkeyword: 
9396				ld hl, crs_s6 
9396				ld de, .keyworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			; hl - points to file name 
9396			; de - points to strings to add to file 
9396			 
9396			.genfile: 
9396				push hl 
9396				push de 
9396			 
9396				call clear_display 
9396				ld a, display_row_1 
9396				ld de, .genfiletxt 
9396				call str_at_display 
9396				call update_display 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396			 
9396				push de 
9396				call storage_create 
9396				; id in hl 
9396				pop de   ; table of strings to add 
9396			 
9396			.genloop: 
9396			 
9396				push hl ; save id for next time around 
9396				push de ; save de for next time around 
9396			 
9396				ex de, hl 
9396				call loadwordinhl 
9396				ex de, hl 
9396			 
9396				; need hl to be the id 
9396				; need de to be the string ptr 
9396				 
9396				call storage_append 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396				inc de 
9396				inc de 
9396			 
9396				ld a,(de) 
9396				cp 0 
9396				jr nz, .genloop 
9396				inc de 
9396				ld a, (de) 
9396				dec de 
9396				cp 0 
9396				jr nz, .genloop	 
9396			 
9396				ret 
9396			 
9396			.genfiletxt:  db "Creating file...",0 
9396			 
9396			.soundworddef: 
9396				dw sound1 
9396				dw sound2 
9396				dw sound3 
9396				dw sound4 
9396				dw sound5 
9396				dw sound6 
9396				dw sound7 
9396				dw sound8 
9396				dw sound9 
9396				dw 0 
9396			 
9396			.utilwordef: 
9396				dw strncpy 
9396				dw type 
9396				dw clrstack 
9396				dw longread 
9396				dw start1 
9396				dw start2 
9396				dw start3b 
9396				dw start3c 
9396				dw list 
9396				dw 0 
9396			 
9396			.lsworddef: 
9396				dw start3b 
9396				dw 0 
9396			 
9396			.edworddef: 
9396				dw edit1 
9396				dw edit2 
9396				dw edit3 
9396				dw 0 
9396			 
9396			.demoworddef: 
9396				dw test5 
9396				dw test6 
9396				dw test7 
9396				dw test8 
9396				dw test9 
9396				dw test10 
9396				dw game1 
9396				dw game1a 
9396				dw game1b 
9396				dw game1c 
9396				dw game1d 
9396				dw game1s 
9396				dw game1t 
9396				dw game1f 
9396				dw game1z 
9396				dw game1zz 
9396				dw ssv2 
9396				dw ssv3 
9396				dw ssv4 
9396				dw ssv5 
9396				dw ssv1 
9396				dw ssv1cpm	 
9396				dw game2b 
9396				dw game2bf 
9396				dw game2mba 
9396				dw game2mbas	 
9396				dw game2mbht 
9396				dw game2mbms 
9396				dw game2mb 
9396				dw game3w 
9396				dw game3p 
9396				dw game3sc 
9396				dw game3vsi 
9396				dw game3vs 
9396				dw 0 
9396			 
9396			 
9396			.spiworddef: 
9396			 
9396			    dw spi1 
9396			    dw spi2 
9396			    dw spi3 
9396			    dw spi4 
9396			    dw spi5 
9396			    dw spi6 
9396			    dw spi7 
9396			 
9396			    dw spi8 
9396			    dw spi9 
9396			    dw spi10 
9396			    dw 0 
9396			 
9396			.keyworddef: 
9396			 
9396				dw keyup 
9396				dw keydown 
9396				dw keyleft 
9396				dw keyright 
9396				dw 	keyf1 
9396				dw keyf2 
9396				dw keyf3 
9396				dw keyf4 
9396				dw keyf5 
9396				dw keyf6 
9396				dw keyf7 
9396				dw keyf8 
9396				dw keyf9 
9396				dw keyf10 
9396				dw keyf11 
9396				dw keyf12 
9396				dw keytab 
9396				dw keycr 
9396				dw keyhome 
9396				dw keyend 
9396				dw keybs 
9396				dw 0 
9396			 
9396			.crstart: 
9396				dw crs_s1 
9396				dw crs_s2 
9396				dw crs_s3 
9396				dw crs_s4 
9396				dw crs_s5 
9396				dw crs_s6 
9396				dw crs_sound 
9396				dw 0 
9396			 
9396			endif 
9396			 
9396			 
9396			if STORAGE_SE 
9396			 
9396			config_fdir: 
9396				; using the scratch dir go through and release the memory allocated for each string 
9396				 
9396				ld hl, scratch 
9396			.cfdir:	ld e,(hl) 
9396				inc hl 
9396				ld d,(hl) 
9396				inc hl 
9396			 
9396				ex de, hl 
9396				call ishlzero 
9396				ret z     ; return on null pointer 
9396				call free 
9396				ex de, hl 
9396				jr .cfdir 
9396			 
9396			 
9396				ret 
9396			 
9396			 
9396			config_dir: 
9396			 
9396				; for the config menus that need to build a directory of storage call this routine 
9396				; it will construct a menu in scratch to pass to menu 
9396			 
9396				; open storage device 
9396			 
9396				; execute DIR to build a list of files and their ids into scratch in menu format 
9396				; once the menu has finished then will need to call config_fdir to release the strings 
9396				 
9396				; c = number items 
9396			 
9396				 
9396				call storage_get_block_0 
9396			 
9396				ld hl, store_page     ; get current id count 
9396				ld b, (hl) 
9396				ld c, 0    ; count of files   
9396			 
9396			 
9396				ld hl, scratch 
9396				ld (store_tmp2), hl    ; location to poke strings 
9396			 
9396				; check for empty drive 
9396			 
9396				ld a, 0 
9396				cp b 
9396				jp z, .dirdone 
9396			 
9396				 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdc" 
9396						CALLMONITOR 
9396					endif 
9396			 
9396			 
9396			.diritem:	 
9396				push bc 
9396				; for each of the current ids do a search for them and if found push to stack 
9396			 
9396					ld hl, STORE_BLOCK_PHY 
9396					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9396					ld e,b 
9396			 
9396					call storage_findnextid 
9396			 
9396			 
9396					; if found hl will be non zero 
9396			 
9396					call ishlzero 
9396					jr z, .dirnotfound 
9396			 
9396					; increase count 
9396			 
9396					pop bc	 
9396					inc c 
9396					push bc 
9396					 
9396			 
9396					; get file header and push the file name 
9396			 
9396					ld de, store_page 
9396					call storage_read_block 
9396			 
9396					; push file id to stack 
9396				 
9396					ld a, (store_page) 
9396					ld h, 0 
9396					ld l, a 
9396			 
9396					;call forth_push_numhl 
9396					; TODO store id 
9396			 
9396					push hl 
9396			 
9396					; push extent count to stack  
9396				 
9396					ld hl, store_page+3 
9396			 
9396					; get file name length 
9396			 
9396					call strlenz   
9396			 
9396					inc hl   ; cover zero term 
9396					inc hl  ; stick the id at the end of the area 
9396			 
9396					push hl 
9396					pop bc    ; move length to bc 
9396			 
9396					call malloc 
9396			 
9396					; TODO save malloc area to scratch 
9396			 
9396					ex de, hl 
9396					ld hl, (store_tmp2) 
9396					ld (hl), e 
9396					inc hl 
9396					ld (hl), d 
9396					inc hl 
9396					ld (store_tmp2), hl 
9396			 
9396					 
9396			 
9396					;pop hl   ; get source 
9396			;		ex de, hl    ; swap aronund	 
9396			 
9396					ld hl, store_page+3 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "CFd" 
9396						CALLMONITOR 
9396					endif 
9396					ldir 
9396			 
9396					; de is past string, move back one and store id 
9396					 
9396					dec de 
9396			 
9396					; store file id 
9396			 
9396					pop hl 
9396					ex de,hl 
9396					ld (hl), e 
9396			 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdi" 
9396						CALLMONITOR 
9396					endif 
9396					 
9396			.dirnotfound: 
9396					pop bc     
9396					djnz .diritem 
9396				 
9396			.dirdone:	 
9396			 
9396					ld a, 0 
9396					ld hl, (store_tmp2) 
9396					ld (hl), a 
9396					inc hl 
9396					ld (hl), a 
9396					inc hl 
9396					; push a count of the dir items found 
9396			 
9396			;		ld h, 0 
9396			;		ld l, c 
9396			 
9396				ret 
9396			 
9396			endif 
9396			 
9396			 
9396			; Settings 
9396			; Run  
9396			 
9396			 
9396			 
9396			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9396			;;hd_menu2:   db "        2: Editor",0   
9396			;hd_menu2:   db "        2: Editor       6: Menu",0   
9396			;hd_menu3:   db "        3: Storage",0 
9396			;hd_menu4:   db "0=quit  4: Debug",0 
9396			;hd_don:     db "ON",0 
9396			;hd_doff:     db "OFF",0 
9396			; 
9396			; 
9396			; 
9396			;hardware_diags_old:       
9396			; 
9396			;.diagmenu: 
9396			;	call clear_display 
9396			;	ld a, display_row_1 
9396			;	ld de, hd_menu1 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_2 
9396			;	ld de, hd_menu2 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_3 
9396			;	ld de, hd_menu3 
9396			;	call str_at_display 
9396			; 
9396			;	ld a,  display_row_4 
9396			;	ld de, hd_menu4 
9396			;	call str_at_display 
9396			; 
9396			;	; display debug state 
9396			; 
9396			;	ld de, hd_don 
9396			;	ld a, (os_view_disable) 
9396			;	cp 0 
9396			;	jr z, .distog 
9396			;	ld de, hd_doff 
9396			;.distog: ld a, display_row_4+17 
9396			;	call str_at_display 
9396			; 
9396			;	call update_display 
9396			; 
9396			;	call cin_wait 
9396			; 
9396			; 
9396			; 
9396			;	cp '4' 
9396			;	jr nz, .diagn1 
9396			; 
9396			;	; debug toggle 
9396			; 
9396			;	ld a, (os_view_disable) 
9396			;	ld b, '*' 
9396			;	cp 0 
9396			;	jr z, .debtog 
9396			;	ld b, 0 
9396			;.debtog:	 
9396			;	ld a,b 
9396			;	ld (os_view_disable),a 
9396			; 
9396			;.diagn1: cp '0' 
9396			;	 ret z 
9396			; 
9396			;;	cp '1' 
9396			;;       jp z, matrix	 
9396			;;   TODO keyboard matrix test 
9396			; 
9396			;	cp '2' 
9396			;	jp z, .diagedit 
9396			; 
9396			;;	cp '6' 
9396			;;	jp z, .menutest 
9396			;;if ENABLE_BASIC 
9396			;;	cp '6' 
9396			;;	jp z, basic 
9396			;;endif 
9396			 ; 
9396			;	jp .diagmenu 
9396			; 
9396			; 
9396			;	ret 
9396			 
9396			 
9396			.debug_tog: 
9396 21 e0 93			ld hl, .menudebug 
9399				 
9399			;	ld a, (os_view_disable) 
9399			;	cp '*' 
9399 3a 6f ee			ld a,(debug_vector) 
939c fe c9			cp $C9   ; RET 
939e 20 04			jr nz,.tdon  
93a0 3e 01			ld a, 1 
93a2 18 02			jr .tog1 
93a4 3e 00		.tdon: ld a, 0 
93a6			 
93a6			.tog1: 
93a6 cd e0 8a			call menu 
93a9 fe 00			cp 0 
93ab c8				ret z 
93ac fe 01			cp 1    ; disable debug 
93ae 28 04			jr z, .dtog0 
93b0 3e 2a			ld a, '*' 
93b2 18 05			jr .dtogset 
93b4			.dtog0:  
93b4				;ld a, 0 
93b4 cd d2 94			call bp_on 
93b7 18 dd			jr .debug_tog 
93b9			.dtogset:  
93b9				; ld (os_view_disable), a 
93b9 cd de 94			call bp_off 
93bc c3 96 93			jp .debug_tog 
93bf			 
93bf			 
93bf			hardware_diags:       
93bf			 
93bf			.diagm: 
93bf 21 d2 93			ld hl, .menuitems 
93c2 3e 00			ld a, 0 
93c4 cd e0 8a			call menu 
93c7			 
93c7 fe 00		         cp 0 
93c9 c8				 ret z 
93ca			 
93ca fe 02			cp 2 
93cc ca 2b 94			jp z, .diagedit 
93cf			 
93cf			;	cp '6' 
93cf			;	jp z, .menutest 
93cf			;if ENABLE_BASIC 
93cf			;	cp '6' 
93cf			;	jp z, basic 
93cf			;endif 
93cf			  
93cf c3 bf 93			jp .diagm 
93d2			 
93d2				 
93d2 e6 93		.menuitems:   	dw .m1 
93d4 f1 93				dw .m2 
93d6 f8 93				dw .m3 
93d8 00 94				dw .m5 
93da 06 94				dw .m5a 
93dc 0f 94				dw .m5b 
93de 00 00				dw 0 
93e0			 
93e0			.menudebug: 
93e0 18 94				dw .m6 
93e2 21 94				dw .m7 
93e4 00 00				dw 0 
93e6			 
93e6 .. 00		.m1:   db "Key Matrix",0 
93f1 .. 00		.m2:   db "Editor",0 
93f8 .. 00		.m3:   db "Storage",0 
9400 .. 00		.m5:   db "Sound",0 
9406 .. 00		.m5a:  db "RAM Test",0 
940f .. 00		.m5b:  db "LCD Test",0 
9418			 
9418 .. 00		.m6:   db "Debug ON",0 
9421 .. 00		.m7:   db "Debug OFF",0 
942b			 
942b			; debug editor 
942b			 
942b			.diagedit: 
942b			 
942b 21 c1 e2			ld hl, scratch 
942e			;	ld bc, 250 
942e			;	ldir 
942e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
942e 3e 00			ld a, 0 
9430 77				ld (hl), a 
9431 23				inc hl 
9432 77				ld (hl), a 
9433 23				inc hl 
9434 77				ld (hl), a 
9435			 
9435 cd af 8a		        call clear_display 
9438 cd d2 8a			call update_display 
943b				;ld a, 1 
943b				;ld (hardware_diag), a 
943b			.diloop: 
943b 3e 00			ld a, display_row_1 
943d 0e 00			ld c, 0 
943f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9441 1e 28			ld e, 40 
9443			 
9443 21 c1 e2			ld hl, scratch	 
9446 cd 09 8d			call input_str 
9449			 
9449 3e 28			ld a, display_row_2 
944b 11 c1 e2			ld de, scratch 
944e cd c2 8a			call str_at_display 
9451 cd d2 8a			call update_display 
9454			 
9454 c3 3b 94			jp .diloop 
9457			 
9457			 
9457			; pass word in hl 
9457			; a has display location 
9457			display_word_at: 
9457 f5				push af 
9458 e5				push hl 
9459 7c				ld a,h 
945a 21 c6 e5			ld hl, os_word_scratch 
945d cd dd 8f			call hexout 
9460 e1				pop hl 
9461 7d				ld a,l 
9462 21 c8 e5			ld hl, os_word_scratch+2 
9465 cd dd 8f			call hexout 
9468 21 ca e5			ld hl, os_word_scratch+4 
946b 3e 00			ld a,0 
946d 77				ld (hl),a 
946e 11 c6 e5			ld de,os_word_scratch 
9471 f1				pop af 
9472 cd c2 8a				call str_at_display 
9475 c9				ret 
9476			 
9476			display_ptr_state: 
9476			 
9476				; to restore afterwards 
9476			 
9476 d5				push de 
9477 c5				push bc 
9478 e5				push hl 
9479 f5				push af 
947a			 
947a				; for use in here 
947a			 
947a			;	push bc 
947a			;	push de 
947a			;	push hl 
947a			;	push af 
947a			 
947a cd af 8a			call clear_display 
947d			 
947d 11 55 96			ld de, .ptrstate 
9480 3e 00			ld a, display_row_1 
9482 cd c2 8a			call str_at_display 
9485			 
9485				; display debug step 
9485			 
9485			 
9485 11 6b ee			ld de, debug_mark 
9488 3e 26			ld a, display_row_1+display_cols-2 
948a cd c2 8a			call str_at_display 
948d			 
948d				; display a 
948d 11 5f 96			ld de, .ptrcliptr 
9490 3e 28			ld a, display_row_2 
9492 cd c2 8a			call str_at_display 
9495			 
9495 f1				pop af 
9496 2a 40 ea			ld hl,(cli_ptr) 
9499 3e 30			ld a, display_row_2+8 
949b cd 57 94			call display_word_at 
949e			 
949e			 
949e				; display hl 
949e			 
949e			 
949e 11 67 96			ld de, .ptrclioptr 
94a1 3e 32			ld a, display_row_2+10 
94a3 cd c2 8a			call str_at_display 
94a6			; 
94a6			;	pop hl 
94a6 3e 35			ld a, display_row_2+13 
94a8 2a 3e ea			ld hl,(cli_origptr) 
94ab cd 57 94			call display_word_at 
94ae			; 
94ae			;	 
94ae			;	; display de 
94ae			 
94ae			;	ld de, .regstatede 
94ae			;	ld a, display_row_3 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop de 
94ae			;	ld h,d 
94ae			;	ld l, e 
94ae			;	ld a, display_row_3+3 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display bc 
94ae			 
94ae			;	ld de, .regstatebc 
94ae			;	ld a, display_row_3+10 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop bc 
94ae			;	ld h,b 
94ae			;	ld l, c 
94ae			;	ld a, display_row_3+13 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display dsp 
94ae			 
94ae			;	ld de, .regstatedsp 
94ae			;	ld a, display_row_4 
94ae			;	call str_at_display 
94ae			 
94ae				 
94ae			;	ld hl,(cli_data_sp) 
94ae			;	ld a, display_row_4+4 
94ae			;	call display_word_at 
94ae			 
94ae				; display rsp 
94ae			 
94ae 11 96 96			ld de, .regstatersp 
94b1 3e 82			ld a, display_row_4+10 
94b3 cd c2 8a			call str_at_display 
94b6			 
94b6				 
94b6 2a f2 e9			ld hl,(cli_ret_sp) 
94b9 3e 86			ld a, display_row_4+14 
94bb cd 57 94			call display_word_at 
94be			 
94be cd d2 8a			call update_display 
94c1			 
94c1 cd f2 89			call delay1s 
94c4 cd f2 89			call delay1s 
94c7 cd f2 89			call delay1s 
94ca			 
94ca			 
94ca cd c3 9a			call next_page_prompt 
94cd			 
94cd				; restore  
94cd			 
94cd f1				pop af 
94ce e1				pop hl 
94cf c1				pop bc 
94d0 d1				pop de 
94d1 c9				ret 
94d2			 
94d2			; Update the break point vector so that the user can hook a new routine 
94d2			 
94d2			bp_on: 
94d2 3e c3			ld a, $c3    ; JP 
94d4 32 6f ee			ld (debug_vector), a 
94d7 21 e4 94			ld hl, break_point_state 
94da 22 70 ee			ld (debug_vector+1), hl 
94dd c9				ret 
94de			 
94de			bp_off: 
94de 3e c9			ld a, $c9    ; RET 
94e0 32 6f ee			ld (debug_vector), a 
94e3 c9				ret 
94e4			 
94e4			 
94e4			break_point_state: 
94e4			;	push af 
94e4			; 
94e4			;	; see if disabled 
94e4			; 
94e4			;	ld a, (os_view_disable) 
94e4			;	cp '*' 
94e4			;	jr nz, .bpsgo 
94e4			;	pop af 
94e4			;	ret 
94e4			 
94e4			.bpsgo: 
94e4			;	pop af 
94e4 f5				push af 
94e5 22 af e2			ld (os_view_hl), hl 
94e8 ed 53 ad e2		ld (os_view_de), de 
94ec ed 43 ab e2		ld (os_view_bc), bc 
94f0 e5				push hl 
94f1 6f				ld l, a 
94f2 26 00			ld h, 0 
94f4 22 b1 e2			ld (os_view_af),hl 
94f7			 
94f7 21 b1 ed				ld hl, display_fb0 
94fa 22 cc eb				ld (display_fb_active), hl 
94fd e1				pop hl	 
94fe			 
94fe 3e 31			ld a, '1' 
9500 fe 2a		.bps1:  cp '*' 
9502 cc de 94			call z, bp_off 
9505			;	jr nz, .bps1b 
9505			;	ld (os_view_disable),a 
9505 fe 31		.bps1b:  cp '1' 
9507 20 14			jr nz, .bps2 
9509			 
9509				; display reg 
9509			 
9509				 
9509			 
9509 3a b1 e2			ld a, (os_view_af) 
950c 2a af e2			ld hl, (os_view_hl) 
950f ed 5b ad e2		ld de, (os_view_de) 
9513 ed 4b ab e2		ld bc, (os_view_bc) 
9517 cd b1 95			call display_reg_state 
951a c3 9d 95			jp .bpschk 
951d			 
951d fe 32		.bps2:  cp '2' 
951f 20 08			jr nz, .bps3 
9521				 
9521				; display hl 
9521 2a af e2			ld hl, (os_view_hl) 
9524 cd 9b 96			call display_dump_at_hl 
9527			 
9527 18 74			jr .bpschk 
9529			 
9529 fe 33		.bps3:  cp '3' 
952b 20 08			jr nz, .bps4 
952d			 
952d			        ; display de 
952d 2a ad e2			ld hl, (os_view_de) 
9530 cd 9b 96			call display_dump_at_hl 
9533			 
9533 18 68			jr .bpschk 
9535 fe 34		.bps4:  cp '4' 
9537 20 08			jr nz, .bps5 
9539			 
9539			        ; display bc 
9539 2a ab e2			ld hl, (os_view_bc) 
953c cd 9b 96			call display_dump_at_hl 
953f			 
953f 18 5c			jr .bpschk 
9541 fe 35		.bps5:  cp '5' 
9543 20 08		        jr nz, .bps7 
9545			 
9545				; display cur ptr 
9545 2a 40 ea			ld hl, (cli_ptr) 
9548 cd 9b 96			call display_dump_at_hl 
954b			 
954b 18 50			jr .bpschk 
954d fe 36		.bps7:  cp '6' 
954f 20 08			jr nz, .bps8b 
9551				 
9551				; display cur orig ptr 
9551 2a 3e ea			ld hl, (cli_origptr) 
9554 cd 9b 96			call display_dump_at_hl 
9557 18 44			jr .bpschk 
9559 fe 37		.bps8b:  cp '7' 
955b 20 08			jr nz, .bps9 
955d				 
955d				; display dsp 
955d 2a ee e9			ld hl, (cli_data_sp) 
9560 cd 9b 96			call display_dump_at_hl 
9563			 
9563 18 38			jr .bpschk 
9565 fe 39		.bps9:  cp '9' 
9567 20 05			jr nz, .bps8c 
9569				 
9569				; display SP 
9569			;	ld hl, sp 
9569 cd 9b 96			call display_dump_at_hl 
956c			 
956c 18 2f			jr .bpschk 
956e fe 38		.bps8c:  cp '8' 
9570 20 08			jr nz, .bps8d 
9572				 
9572				; display rsp 
9572 2a f2 e9			ld hl, (cli_ret_sp) 
9575 cd 9b 96			call display_dump_at_hl 
9578			 
9578 18 23			jr .bpschk 
957a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
957c 20 05			jr nz, .bps8 
957e cd 91 98			call monitor 
9581			 
9581 18 1a			jr .bpschk 
9583 fe 30		.bps8:  cp '0' 
9585 20 16			jr nz, .bpschk 
9587			 
9587 21 10 ed				ld hl, display_fb1 
958a 22 cc eb				ld (display_fb_active), hl 
958d cd d2 8a				call update_display 
9590			 
9590				;ld a, (os_view_af) 
9590 2a af e2			ld hl, (os_view_hl) 
9593 ed 5b ad e2		ld de, (os_view_de) 
9597 ed 4b ab e2		ld bc, (os_view_bc) 
959b f1				pop af 
959c c9				ret 
959d			 
959d			.bpschk:   
959d cd f2 89			call delay1s 
95a0 3e 9f		ld a,display_row_4 + display_cols - 1 
95a2 11 c1 9a		        ld de, endprg 
95a5 cd c2 8a			call str_at_display 
95a8 cd d2 8a			call update_display 
95ab cd 28 e4			call cin_wait 
95ae			 
95ae c3 00 95			jp .bps1 
95b1			 
95b1			 
95b1			display_reg_state: 
95b1			 
95b1				; to restore afterwards 
95b1			 
95b1 d5				push de 
95b2 c5				push bc 
95b3 e5				push hl 
95b4 f5				push af 
95b5			 
95b5				; for use in here 
95b5			 
95b5 c5				push bc 
95b6 d5				push de 
95b7 e5				push hl 
95b8 f5				push af 
95b9			 
95b9 cd af 8a			call clear_display 
95bc			 
95bc 11 71 96			ld de, .regstate 
95bf 3e 00			ld a, display_row_1 
95c1 cd c2 8a			call str_at_display 
95c4			 
95c4				; display debug step 
95c4			 
95c4			 
95c4 11 6b ee			ld de, debug_mark 
95c7 3e 25			ld a, display_row_1+display_cols-3 
95c9 cd c2 8a			call str_at_display 
95cc			 
95cc				; display a 
95cc 11 8d 96			ld de, .regstatea 
95cf 3e 28			ld a, display_row_2 
95d1 cd c2 8a			call str_at_display 
95d4			 
95d4 e1				pop hl 
95d5			;	ld h,0 
95d5			;	ld l, a 
95d5 3e 2b			ld a, display_row_2+3 
95d7 cd 57 94			call display_word_at 
95da			 
95da			 
95da				; display hl 
95da			 
95da			 
95da 11 81 96			ld de, .regstatehl 
95dd 3e 32			ld a, display_row_2+10 
95df cd c2 8a			call str_at_display 
95e2			 
95e2 e1				pop hl 
95e3 3e 35			ld a, display_row_2+13 
95e5 cd 57 94			call display_word_at 
95e8			 
95e8				 
95e8				; display de 
95e8			 
95e8 11 85 96			ld de, .regstatede 
95eb 3e 50			ld a, display_row_3 
95ed cd c2 8a			call str_at_display 
95f0			 
95f0 e1				pop hl 
95f1			;	ld h,d 
95f1			;	ld l, e 
95f1 3e 53			ld a, display_row_3+3 
95f3 cd 57 94			call display_word_at 
95f6			 
95f6			 
95f6				; display bc 
95f6			 
95f6 11 89 96			ld de, .regstatebc 
95f9 3e 5a			ld a, display_row_3+10 
95fb cd c2 8a			call str_at_display 
95fe			 
95fe e1				pop hl 
95ff			;	ld h,b 
95ff			;	ld l, c 
95ff 3e 5d			ld a, display_row_3+13 
9601 cd 57 94			call display_word_at 
9604			 
9604			 
9604				; display dsp 
9604			 
9604 11 91 96			ld de, .regstatedsp 
9607 3e 78			ld a, display_row_4 
9609 cd c2 8a			call str_at_display 
960c			 
960c				 
960c 2a ee e9			ld hl,(cli_data_sp) 
960f 3e 7c			ld a, display_row_4+4 
9611 cd 57 94			call display_word_at 
9614			 
9614				; display rsp 
9614			 
9614 11 96 96			ld de, .regstatersp 
9617 3e 82			ld a, display_row_4+10 
9619 cd c2 8a			call str_at_display 
961c			 
961c				 
961c 2a f2 e9			ld hl,(cli_ret_sp) 
961f 3e 86			ld a, display_row_4+14 
9621 cd 57 94			call display_word_at 
9624			 
9624 cd d2 8a			call update_display 
9627			 
9627			;	call delay1s 
9627			;	call delay1s 
9627			;	call delay1s 
9627			 
9627			 
9627			;	call next_page_prompt 
9627			 
9627				; restore  
9627			 
9627 f1				pop af 
9628 e1				pop hl 
9629 c1				pop bc 
962a d1				pop de 
962b c9				ret 
962c			 
962c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9640 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9655 .. 00		.ptrstate:	db "Ptr State",0 
965f .. 00		.ptrcliptr:     db "cli_ptr",0 
9667 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9671 .. 00		.regstate:	db "Reg State (1/0)",0 
9681 .. 00		.regstatehl:	db "HL:",0 
9685 .. 00		.regstatede:	db "DE:",0 
9689 .. 00		.regstatebc:	db "BC:",0 
968d .. 00		.regstatea:	db "A :",0 
9691 .. 00		.regstatedsp:	db "DSP:",0 
9696 .. 00		.regstatersp:	db "RSP:",0 
969b			 
969b			display_dump_at_hl: 
969b e5				push hl 
969c d5				push de 
969d c5				push bc 
969e f5				push af 
969f			 
969f 22 e4 e5			ld (os_cur_ptr),hl	 
96a2 cd af 8a			call clear_display 
96a5 cd cb 99			call dumpcont 
96a8			;	call delay1s 
96a8			;	call next_page_prompt 
96a8			 
96a8			 
96a8 f1				pop af 
96a9 c1				pop bc 
96aa d1				pop de 
96ab e1				pop hl 
96ac c9				ret 
96ad			 
96ad			;if ENABLE_BASIC 
96ad			;	include "nascombasic.asm" 
96ad			;	basic: 
96ad			;	include "forth/FORTH.ASM" 
96ad			;endif 
96ad			 
96ad			; eof 
96ad			 
96ad			 
# End of file firmware_diags.asm
96ad			  
96ad			include "firmware_prompts.asm"  
96ad			; Prompts  
96ad			 
96ad			; boot messages 
96ad			 
96ad .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c2 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d2			 
96d2			 
96d2			; config menus 
96d2			 
96d2			;prom_c3: db "Add Dictionary To File",0 
96d2			 
96d2			if STARTUP_V1 
96d2 .. 00		prom_c2: db "Select Autoload File",0 
96e7 .. 00		prom_c2a: db "Disable Autoload File", 0 
96fd			endif 
96fd			 
96fd			if STARTUP_V2 
96fd			prom_c2: db "Enable Autoload Files",0 
96fd			prom_c2a: db "Disable Autoload Files", 0 
96fd			 
96fd			crs_s1: db "*ls-word", 0 
96fd			crs_s2: db "*ed-word", 0 
96fd			crs_s3: db "*Demo-Programs", 0 
96fd			crs_s4: db "*Utils", 0 
96fd			crs_s5: db "*SPI-Addons", 0 
96fd			crs_s6: db "*Key-constants", 0 
96fd			crs_sound: db "*Sound-Util", 0 
96fd			 
96fd			 
96fd			 
96fd			endif 
96fd			;prom_c2b: db "Select Storage Bank",0 
96fd .. 00		prom_c4: db "Settings",0 
9706 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9721 .. 00		prom_m4b:   db "Monitor",0 
9729 .. 00		prom_c1: db "Hardware Diags",0 
9738			 
9738			 
9738			if STARTUP_V2 
9738			prom_c9: db "Create Startup Files",0 
9738			endif 
9738			 
9738 .. 00		prom_notav:    db "Feature not available",0 
974e .. 00		prom_empty:    db "",0 
974f			 
974f			; eof 
974f			 
# End of file firmware_prompts.asm
974f			  
974f			  
974f			; eof  
974f			  
# End of file firmware.asm
974f			 
974f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
974f			;if BASE_KEV  
974f			;baseram: equ 08000h 
974f			;endif 
974f			 
974f			;if BASE_SC114 
974f			;baseram:     equ    endofcode 
974f			;endif 
974f			 
974f			 
974f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
974f			 
974f			; start system 
974f			 
974f			coldstart: 
974f				; set sp 
974f				; di/ei 
974f			 
974f f3				di 
9750 31 00 f0			ld sp, tos 
9753 cd 72 e3			call init_nmi 
9756			;	ei 
9756			 
9756				; init spinner 
9756 3e 00			ld a,0 
9758 32 c6 eb			ld (display_active), a 
975b			 
975b				; disable breakpoint by default 
975b			 
975b				;ld a,'*' 
975b			;	ld a,' ' 
975b			;	ld (os_view_disable),a 
975b			 
975b				; set break point vector as new break point on or off 
975b cd de 94			call bp_off 
975e			 
975e				; init hardware 
975e			 
975e				; init keyboard and screen hardware 
975e			 
975e cd 1c 80			call hardware_init 
9761			 
9761			 
9761 cd f2 89			call delay1s 
9764 3e 58			ld a, display_row_3+8 
9766 11 03 80			ld de, buildtime 
9769 cd c2 8a			call str_at_display 
976c cd d2 8a			call update_display 
976f			 
976f cd f2 89			call delay1s 
9772 cd f2 89			call delay1s 
9775 cd f2 89			call delay1s 
9778			 
9778				; detect if any keys are held down to enable breakpoints at start up 
9778			 
9778 cd 2e e4			call cin  
977b fe 00			cp 0 
977d 28 03			jr z, .nokeys 
977f			 
977f				;call hardware_diags 
977f cd 3c 93			call config 
9782			 
9782			;	ld de, .bpen 
9782			;	ld a, display_row_4 
9782			;	call str_at_display 
9782			;	call update_display 
9782			; 
9782			;	ld a,0 
9782			;	ld (os_view_disable),a 
9782			; 
9782			;.bpwait: 
9782			;	call cin 
9782			;	cp 0 
9782			;	jr z, .bpwait 
9782			;	jr .nokeys 
9782			; 
9782			; 
9782			;.bpen:  db "Break points enabled!",0 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			.nokeys: 
9782			 
9782			 
9782				 
9782			 
9782			;jp  testkey 
9782			 
9782			;call storage_get_block_0 
9782			; 
9782			;ld hl, 0 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782				 
9782			;ld hl, 10 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			;stop:	nop 
9782			;	jp stop 
9782			 
9782			 
9782			 
9782			main: 
9782 cd af 8a			call clear_display 
9785 cd d2 8a			call update_display 
9788			 
9788			 
9788			 
9788			;	call testlcd 
9788			 
9788			 
9788			 
9788 cd c8 9e			call forth_init 
978b			 
978b			 
978b			warmstart: 
978b cd 9e 9e			call forth_warmstart 
978e			 
978e				; run startup word load 
978e			        ; TODO prevent this running at warmstart after crash  
978e			 
978e				if STARTUP_ENABLE 
978e			 
978e					if STARTUP_V1 
978e			 
978e						if STORAGE_SE 
978e							call forth_autoload 
978e						endif 
978e cd c2 e2					call forth_startup 
9791					endif 
9791			 
9791					if STARTUP_V2 
9791			 
9791						if STORAGE_SE 
9791							call forth_autoload 
9791						else 
9791							call forth_startup 
9791						endif 
9791			 
9791			 
9791					endif 
9791			 
9791				endif 
9791			 
9791				; show free memory after boot 
9791 11 2b 98			ld de, freeram 
9794 3e 00			ld a, display_row_1 
9796 cd c2 8a			call str_at_display 
9799			 
9799			; Or use heap_size word???? 
9799 21 a8 e2			ld hl, heap_end 
979c 11 4c e4			ld de, heap_start 
979f ed 52			sbc hl, de 
97a1 e5				push hl 
97a2 7c				ld a,h	         	 
97a3 21 c6 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97a6 cd dd 8f			call hexout 
97a9 e1			   	pop hl 
97aa			 
97aa 7d				ld a,l 
97ab 21 c8 e5			ld hl, os_word_scratch+2 
97ae cd dd 8f			call hexout 
97b1 21 ca e5			ld hl, os_word_scratch+4 
97b4 3e 00			ld a, 0 
97b6 77				ld (hl),a 
97b7 11 c6 e5			ld de, os_word_scratch 
97ba 3e 0d			ld a, display_row_1 + 13 
97bc cd c2 8a			call str_at_display 
97bf cd d2 8a			call update_display 
97c2			 
97c2			 
97c2				;call demo 
97c2			 
97c2			 
97c2				; init scratch input area for cli commands 
97c2			 
97c2 21 e8 e5			ld hl, os_cli_cmd 
97c5 3e 00			ld a,0 
97c7 77				ld (hl),a 
97c8 23				inc hl 
97c9 77				ld (hl),a 
97ca			 
97ca 3e 00			ld a,0 
97cc 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97cf			 
97cf 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97d2 32 e5 e5			ld (os_cur_ptr+1),a	 
97d5			 
97d5 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97d8 32 c7 e5			ld (os_word_scratch+1),a	 
97db				 
97db			 
97db				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97db 21 e8 e5			ld hl, os_cli_cmd 
97de			 
97de 3e 00			ld a, 0		 ; init cli input 
97e0 77				ld (hl), a 
97e1 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97e3			cli: 
97e3				; show cli prompt 
97e3				;push af 
97e3				;ld a, 0 
97e3				;ld de, prompt 
97e3				;call str_at_display 
97e3			 
97e3				;call update_display 
97e3				;pop af 
97e3				;inc a 
97e3				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97e3 0e 00			ld c, 0 
97e5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97e7 1e 28			ld e, 40 
97e9			 
97e9 21 e8 e5			ld hl, os_cli_cmd 
97ec			 
97ec				STACKFRAME OFF $fefe $9f9f 
97ec				if DEBUG_STACK_IMB 
97ec					if OFF 
97ec						exx 
97ec						ld de, $fefe 
97ec						ld a, d 
97ec						ld hl, curframe 
97ec						call hexout 
97ec						ld a, e 
97ec						ld hl, curframe+2 
97ec						call hexout 
97ec						ld hl, $fefe 
97ec						push hl 
97ec						ld hl, $9f9f 
97ec						push hl 
97ec						exx 
97ec					endif 
97ec				endif 
97ec			endm 
# End of macro STACKFRAME
97ec			 
97ec cd 09 8d			call input_str 
97ef			 
97ef				STACKFRAMECHK OFF $fefe $9f9f 
97ef				if DEBUG_STACK_IMB 
97ef					if OFF 
97ef						exx 
97ef						ld hl, $9f9f 
97ef						pop de   ; $9f9f 
97ef						call cmp16 
97ef						jr nz, .spnosame 
97ef						ld hl, $fefe 
97ef						pop de   ; $fefe 
97ef						call cmp16 
97ef						jr z, .spfrsame 
97ef						.spnosame: call showsperror 
97ef						.spfrsame: nop 
97ef						exx 
97ef					endif 
97ef				endif 
97ef			endm 
# End of macro STACKFRAMECHK
97ef			 
97ef				; copy input to last command 
97ef			 
97ef 21 e8 e5			ld hl, os_cli_cmd 
97f2 11 e7 e6			ld de, os_last_cmd 
97f5 01 ff 00			ld bc, 255 
97f8 ed b0			ldir 
97fa			 
97fa				; wipe current buffer 
97fa			 
97fa			;	ld a, 0 
97fa			;	ld hl, os_cli_cmd 
97fa			;	ld de, os_cli_cmd+1 
97fa			;	ld bc, 254 
97fa			;	ldir 
97fa				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97fa			;	call strcpy 
97fa			;	ld a, 0 
97fa			;	ld (hl), a 
97fa			;	inc hl 
97fa			;	ld (hl), a 
97fa			;	inc hl 
97fa			;	ld (hl), a 
97fa			 
97fa				; switch frame buffer to program  
97fa			 
97fa 21 10 ed				ld hl, display_fb1 
97fd 22 cc eb				ld (display_fb_active), hl 
9800			 
9800			;	nop 
9800				STACKFRAME ON $fbfe $8f9f 
9800				if DEBUG_STACK_IMB 
9800					if ON 
9800						exx 
9800						ld de, $fbfe 
9800						ld a, d 
9800						ld hl, curframe 
9800						call hexout 
9800						ld a, e 
9800						ld hl, curframe+2 
9800						call hexout 
9800						ld hl, $fbfe 
9800						push hl 
9800						ld hl, $8f9f 
9800						push hl 
9800						exx 
9800					endif 
9800				endif 
9800			endm 
# End of macro STACKFRAME
9800				; first time into the parser so pass over the current scratch pad 
9800 21 e8 e5			ld hl,os_cli_cmd 
9803				; tokenise the entered statement(s) in HL 
9803 cd 46 9f			call forthparse 
9806			        ; exec forth statements in top of return stack 
9806 cd 86 9f			call forthexec 
9809				;call forthexec_cleanup 
9809			;	call parsenext 
9809			 
9809				STACKFRAMECHK ON $fbfe $8f9f 
9809				if DEBUG_STACK_IMB 
9809					if ON 
9809						exx 
9809						ld hl, $8f9f 
9809						pop de   ; $8f9f 
9809						call cmp16 
9809						jr nz, .spnosame 
9809						ld hl, $fbfe 
9809						pop de   ; $fbfe 
9809						call cmp16 
9809						jr z, .spfrsame 
9809						.spnosame: call showsperror 
9809						.spfrsame: nop 
9809						exx 
9809					endif 
9809				endif 
9809			endm 
# End of macro STACKFRAMECHK
9809				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9809			 
9809 3e 78			ld a, display_row_4 
980b 11 3d 98			ld de, endprog 
980e			 
980e cd d2 8a			call update_display		 
9811			 
9811 cd c3 9a			call next_page_prompt 
9814			 
9814				; switch frame buffer to cli 
9814			 
9814 21 b1 ed				ld hl, display_fb0 
9817 22 cc eb				ld (display_fb_active), hl 
981a			 
981a			 
981a cd af 8a		        call clear_display 
981d cd d2 8a			call update_display		 
9820			 
9820 21 e8 e5			ld hl, os_cli_cmd 
9823			 
9823 3e 00			ld a, 0		 ; init cli input 
9825 77				ld (hl), a 
9826			 
9826				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9826			 
9826				; now on last line 
9826			 
9826				; TODO scroll screen up 
9826			 
9826				; TODO instead just clear screen and place at top of screen 
9826			 
9826			;	ld a, 0 
9826			;	ld (f_cursor_ptr),a 
9826			 
9826				;call clear_display 
9826				;call update_display 
9826			 
9826				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9826 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9828 c3 e3 97			jp cli 
982b			 
982b .. 00		freeram: db "Free bytes: $",0 
9839 ..			asc: db "1A2F" 
983d .. 00		endprog: db "End prog...",0 
9849			 
9849			testenter2:   
9849 21 f3 e2			ld hl,scratch+50 
984c 22 e4 e5			ld (os_cur_ptr),hl 
984f c3 e3 97			jp cli 
9852			 
9852			testenter:  
9852			 
9852 21 39 98			ld hl,asc 
9855			;	ld a,(hl) 
9855			;	call nibble2val 
9855 cd 33 90			call get_byte 
9858			 
9858			 
9858			;	ld a,(hl) 
9858			;	call atohex 
9858			 
9858			;	call fourehexhl 
9858 32 f3 e2			ld (scratch+50),a 
985b			 
985b			 
985b			 
985b 21 3b 98			ld hl,asc+2 
985e			;	ld a, (hl) 
985e			;	call nibble2val 
985e cd 33 90			call get_byte 
9861			 
9861			;	call fourehexhl 
9861 32 f5 e2			ld (scratch+52),a 
9864				 
9864 21 f3 e2			ld hl,scratch+50 
9867 22 e4 e5			ld (os_cur_ptr),hl 
986a c3 e3 97			jp cli 
986d			 
986d			enter:	 
986d 3a c5 e2			ld a,(scratch+4) 
9870 fe 00			cp 0 
9872 28 0c			jr z, .entercont 
9874				; no, not a null term line so has an address to work out.... 
9874			 
9874 21 c3 e2			ld hl,scratch+2 
9877 cd 93 90			call get_word_hl 
987a			 
987a 22 e4 e5			ld (os_cur_ptr),hl	 
987d c3 e3 97			jp cli 
9880			 
9880			 
9880			.entercont:  
9880			 
9880 21 c3 e2			ld hl, scratch+2 
9883 cd 33 90			call get_byte 
9886			 
9886 2a e4 e5		   	ld hl,(os_cur_ptr) 
9889 77					ld (hl),a 
988a 23					inc hl 
988b 22 e4 e5				ld (os_cur_ptr),hl 
988e				 
988e			; get byte  
988e			 
988e			 
988e c3 e3 97			jp cli 
9891			 
9891			 
9891			; basic monitor support 
9891			 
9891			monitor: 
9891				;  
9891 cd af 8a			call clear_display 
9894 3e 00			ld a, 0 
9896 11 e5 98			ld de, .monprompt 
9899 cd c2 8a			call str_at_display 
989c cd d2 8a			call update_display 
989f			 
989f				; get a monitor command 
989f			 
989f 0e 00			ld c, 0     ; entry at top left 
98a1 16 64			ld d, 100   ; max buffer size 
98a3 1e 0f			ld e, 15    ; input scroll area 
98a5 3e 00			ld a, 0     ; init string 
98a7 21 bf e4			ld hl, os_input 
98aa 77				ld (hl), a 
98ab 23				inc hl 
98ac 77				ld (hl), a 
98ad 21 bf e4			ld hl, os_input 
98b0 3e 01			ld a, 1     ; init string 
98b2 cd 09 8d			call input_str 
98b5			 
98b5 cd af 8a		        call clear_display 
98b8 cd d2 8a			call update_display		 
98bb			 
98bb 3a bf e4			ld a, (os_input) 
98be cd 31 91			call toUpper 
98c1 fe 48		        cp 'H' 
98c3 ca 4a 99		        jp z, .monhelp 
98c6 fe 44			cp 'D'		; dump 
98c8 ca 7d 99			jp z, .mondump	 
98cb fe 43			cp 'C'		; dump 
98cd ca 97 99			jp z, .moncdump	 
98d0 fe 4d			cp 'M'		; dump 
98d2 ca e7 98			jp z, .moneditstart 
98d5 fe 55			cp 'U'		; dump 
98d7 ca f3 98			jp z, .monedit	 
98da fe 47			cp 'G'		; dump 
98dc ca 73 99			jp z, .monjump 
98df fe 51			cp 'Q'		; dump 
98e1 c8				ret z	 
98e2			 
98e2			 
98e2				; TODO "S" to access symbol by name and not need the address 
98e2				; TODO "F" to find a string in memory 
98e2			 
98e2 c3 91 98			jp monitor 
98e5			 
98e5 .. 00		.monprompt: db ">", 0 
98e7			 
98e7			.moneditstart: 
98e7				; get starting address 
98e7			 
98e7 21 c1 e4			ld hl,os_input+2 
98ea cd 93 90			call get_word_hl 
98ed			 
98ed 22 e4 e5			ld (os_cur_ptr),hl	 
98f0			 
98f0 c3 91 98			jp monitor 
98f3			 
98f3			.monedit: 
98f3				; get byte to load 
98f3			 
98f3 21 c1 e4			ld hl,os_input+2 
98f6 cd 33 90			call get_byte 
98f9			 
98f9				; get address to update 
98f9 2a e4 e5			ld hl, (os_cur_ptr) 
98fc			 
98fc				; update byte 
98fc			 
98fc 77				ld (hl), a 
98fd			 
98fd				; move to next address and save it 
98fd			 
98fd 23				inc hl 
98fe 22 e4 e5			ld (os_cur_ptr),hl	 
9901			 
9901 c3 91 98			jp monitor 
9904			 
9904			 
9904 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9918 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9934 .. 00		.monhelptext3:  db "G-Call address",0 
9943 .. 00		.monhelptext4:  db "Q-Quit",0 
994a			        
994a			.monhelp: 
994a 3e 00			ld a, display_row_1 
994c 11 04 99		        ld de, .monhelptext1 
994f			 
994f cd c2 8a			call str_at_display 
9952 3e 28			ld a, display_row_2 
9954 11 18 99		        ld de, .monhelptext2 
9957					 
9957 cd c2 8a			call str_at_display 
995a 3e 50			ld a, display_row_3 
995c 11 34 99		        ld de, .monhelptext3 
995f					 
995f cd c2 8a			call str_at_display 
9962 3e 78			ld a, display_row_4 
9964 11 43 99		        ld de, .monhelptext4 
9967 cd c2 8a			call str_at_display 
996a			 
996a cd d2 8a			call update_display		 
996d			 
996d cd c3 9a			call next_page_prompt 
9970 c3 91 98			jp monitor 
9973			 
9973			.monjump:    
9973 21 c1 e4			ld hl,os_input+2 
9976 cd 93 90			call get_word_hl 
9979			 
9979 e9				jp (hl) 
997a c3 91 98			jp monitor 
997d			 
997d			.mondump:    
997d 21 c1 e4			ld hl,os_input+2 
9980 cd 93 90			call get_word_hl 
9983			 
9983 22 e4 e5			ld (os_cur_ptr),hl	 
9986 cd cb 99			call dumpcont 
9989 3e 78			ld a, display_row_4 
998b 11 3d 98			ld de, endprog 
998e			 
998e cd d2 8a			call update_display		 
9991			 
9991 cd c3 9a			call next_page_prompt 
9994 c3 91 98			jp monitor 
9997			.moncdump: 
9997 cd cb 99			call dumpcont 
999a 3e 78			ld a, display_row_4 
999c 11 3d 98			ld de, endprog 
999f			 
999f cd d2 8a			call update_display		 
99a2			 
99a2 cd c3 9a			call next_page_prompt 
99a5 c3 91 98			jp monitor 
99a8			 
99a8			 
99a8			; TODO symbol access  
99a8			 
99a8			.symbols:     ;; A list of symbols that can be called up  
99a8 b1 ed			dw display_fb0 
99aa .. 00			db "fb0",0  
99ae 7a ea		     	dw store_page 
99b0 .. 00			db "store_page",0 
99bb			 
99bb			 
99bb			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99bb			 
99bb 3a c2 e2			ld a,(scratch+1) 
99be fe 00			cp 0 
99c0 28 09			jr z, dumpcont 
99c2			 
99c2				; no, not a null term line so has an address to work out.... 
99c2			 
99c2 21 c3 e2			ld hl,scratch+2 
99c5 cd 93 90			call get_word_hl 
99c8			 
99c8 22 e4 e5			ld (os_cur_ptr),hl	 
99cb			 
99cb			 
99cb			 
99cb			dumpcont: 
99cb			 
99cb				; dump bytes at ptr 
99cb			 
99cb			 
99cb 3e 00			ld a, display_row_1 
99cd 2a cc eb			ld hl, (display_fb_active) 
99d0 cd dc 8c			call addatohl 
99d3 cd fb 99			call .dumpbyterow 
99d6			 
99d6 3e 28			ld a, display_row_2 
99d8 2a cc eb			ld hl, (display_fb_active) 
99db cd dc 8c			call addatohl 
99de cd fb 99			call .dumpbyterow 
99e1			 
99e1			 
99e1 3e 50			ld a, display_row_3 
99e3 2a cc eb			ld hl, (display_fb_active) 
99e6 cd dc 8c			call addatohl 
99e9 cd fb 99			call .dumpbyterow 
99ec			 
99ec 3e 78			ld a, display_row_4 
99ee 2a cc eb			ld hl, (display_fb_active) 
99f1 cd dc 8c			call addatohl 
99f4 cd fb 99			call .dumpbyterow 
99f7			 
99f7 cd d2 8a			call update_display 
99fa			;		jp cli 
99fa c9				ret 
99fb			 
99fb			.dumpbyterow: 
99fb			 
99fb				;push af 
99fb			 
99fb e5				push hl 
99fc			 
99fc				; calc where to poke the ascii 
99fc			if display_cols == 20 
99fc				ld a, 16 
99fc			else 
99fc 3e 1f			ld a, 31 
99fe			endif 
99fe			 
99fe cd dc 8c			call addatohl 
9a01 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9a04			 
9a04			 
9a04			; display decoding address 
9a04 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a07			 
9a07 7c				ld a,h 
9a08 e1				pop hl 
9a09 e5				push hl 
9a0a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9a0a cd dd 8f			call hexout 
9a0d 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a10			 
9a10 7d				ld a,l 
9a11 e1				pop hl 
9a12 23				inc hl 
9a13 23				inc hl 
9a14 e5				push hl 
9a15			;	ld hl, os_word_scratch+2 
9a15 cd dd 8f			call hexout 
9a18 e1				pop hl 
9a19 23				inc hl 
9a1a 23				inc hl 
9a1b				;ld hl, os_word_scratch+4 
9a1b 3e 3a			ld a, ':' 
9a1d 77				ld (hl),a 
9a1e 23				inc hl 
9a1f				;ld a, 0 
9a1f				;ld (hl),a 
9a1f				;ld de, os_word_scratch 
9a1f				;pop af 
9a1f				;push af 
9a1f			;		ld a, display_row_2 
9a1f			;		call str_at_display 
9a1f			;		call update_display 
9a1f			 
9a1f			 
9a1f			;pop af 
9a1f			;	add 5 
9a1f			 
9a1f			if display_cols == 20 
9a1f				ld b, 4 
9a1f			else 
9a1f 06 08			ld b, 8 
9a21			endif	 
9a21			 
9a21			.dumpbyte: 
9a21 c5				push bc 
9a22 e5				push hl 
9a23			 
9a23			 
9a23 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a26 7e					ld a,(hl) 
9a27			 
9a27					; poke the ascii to display 
9a27 2a c6 e5				ld hl,(os_word_scratch) 
9a2a 77					ld (hl),a 
9a2b 23					inc hl 
9a2c 22 c6 e5				ld (os_word_scratch),hl 
9a2f			 
9a2f					 
9a2f			 
9a2f			 
9a2f e1					pop hl 
9a30 e5					push hl 
9a31			 
9a31 cd dd 8f				call hexout 
9a34			 
9a34					 
9a34 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a37 23				inc hl 
9a38 22 e4 e5		   	ld (os_cur_ptr),hl 
9a3b			 
9a3b e1					pop hl 
9a3c 23					inc hl 
9a3d 23					inc hl 
9a3e 23					inc hl 
9a3f			 
9a3f			 
9a3f			 
9a3f					;ld a,0 
9a3f					;ld (os_word_scratch+2),a 
9a3f					;pop af 
9a3f					;push af 
9a3f			 
9a3f					;ld de, os_word_scratch 
9a3f					;call str_at_display 
9a3f			;		call update_display 
9a3f			;		pop af 
9a3f c1					pop bc 
9a40 c6 03				add 3 
9a42 10 dd			djnz .dumpbyte 
9a44			 
9a44				 
9a44			 
9a44 c9				ret 
9a45			 
9a45			jump:	 
9a45			 
9a45 21 c3 e2			ld hl,scratch+2 
9a48 cd 93 90			call get_word_hl 
9a4b				;ld hl,(scratch+2) 
9a4b				;call fourehexhl 
9a4b			 
9a4b 22 e4 e5			ld (os_cur_ptr),hl	 
9a4e			 
9a4e e9				jp (hl) 
9a4f			 
9a4f			 
9a4f			 
9a4f			; TODO implement a basic monitor mode to start with 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			; testing and demo code during development 
9a4f			 
9a4f			 
9a4f .. 00		str1: db "Enter some text...",0 
9a62 .. 00		clear: db "                    ",0 
9a77			 
9a77			demo: 
9a77			 
9a77			 
9a77			 
9a77			;	call update_display 
9a77			 
9a77				; init scratch input area for testing 
9a77 21 c1 e2			ld hl, scratch	 
9a7a 3e 00			ld a,0 
9a7c 77				ld (hl),a 
9a7d			 
9a7d			 
9a7d 3e 28		            LD   A, display_row_2 
9a7f			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a7f 11 4f 9a		            LD   DE, str1 
9a82 cd c2 8a			call str_at_display 
9a85			 
9a85			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a85			cloop:	 
9a85 3e 50		            LD   A, display_row_3 
9a87			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a87 11 62 9a		            LD   DE, clear 
9a8a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a8a cd c2 8a				call str_at_display 
9a8d 3e 78			ld a, display_row_4 
9a8f 11 bf 9a			ld de, prompt 
9a92			 
9a92 cd c2 8a				call str_at_display 
9a95 cd d2 8a			call update_display 
9a98			 
9a98 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a9a 16 0a			ld d, 10 
9a9c 21 c1 e2			ld hl, scratch	 
9a9f cd 09 8d			call input_str 
9aa2			 
9aa2			;	call clear_display 
9aa2			;'	call update_display 
9aa2			 
9aa2 3e 00		            LD   A, display_row_1 
9aa4			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aa4 11 62 9a		            LD   DE, clear 
9aa7 cd c2 8a				call str_at_display 
9aaa			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aaa 3e 00		            LD   A, display_row_1 
9aac			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aac 11 c1 e2		            LD   DE, scratch 
9aaf			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aaf cd c2 8a				call str_at_display 
9ab2 cd d2 8a			call update_display 
9ab5			 
9ab5 3e 00				ld a,0 
9ab7 21 c1 e2			ld hl, scratch 
9aba 77				ld (hl),a 
9abb			 
9abb 00				nop 
9abc c3 85 9a			jp cloop 
9abf			 
9abf			 
9abf			 
9abf			; OS Prompt 
9abf			 
9abf .. 00		prompt: db ">",0 
9ac1 .. 00		endprg: db "?",0 
9ac3			 
9ac3			 
9ac3			; handy next page prompt 
9ac3			next_page_prompt: 
9ac3 e5				push hl 
9ac4 d5				push de 
9ac5 f5				push af 
9ac6 c5				push bc 
9ac7			 
9ac7 3e 9f			ld a,display_row_4 + display_cols - 1 
9ac9 11 c1 9a		        ld de, endprg 
9acc cd c2 8a			call str_at_display 
9acf cd d2 8a			call update_display 
9ad2 cd 28 e4			call cin_wait 
9ad5 c1				pop bc 
9ad6 f1				pop af 
9ad7 d1				pop de 
9ad8 e1				pop hl 
9ad9			 
9ad9			 
9ad9 c9				ret 
9ada			 
9ada			 
9ada			; forth parser 
9ada			 
9ada			; My forth kernel 
9ada			include "forth_kernel.asm" 
9ada			; 
9ada			; kernel to the forth OS 
9ada			 
9ada			DS_TYPE_STR: equ 1     ; string type 
9ada			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9ada			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9ada			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9ada			 
9ada			FORTH_PARSEV1: equ 0 
9ada			FORTH_PARSEV2: equ 0 
9ada			FORTH_PARSEV3: equ 0 
9ada			FORTH_PARSEV4: equ 0 
9ada			FORTH_PARSEV5: equ 1 
9ada			 
9ada			;if FORTH_PARSEV5 
9ada			;	FORTH_END_BUFFER: equ 0 
9ada			;else 
9ada			FORTH_END_BUFFER: equ 127 
9ada			;endif 
9ada			 
9ada			FORTH_TRUE: equ 1 
9ada			FORTH_FALSE: equ 0 
9ada			 
9ada			if FORTH_PARSEV4 
9ada			include "forth_stackops.asm" 
9ada			endif 
9ada			 
9ada			if FORTH_PARSEV5 
9ada			include "forth_stackopsv5.asm" 
9ada			 
9ada			; Stack operations for v5 parser on wards 
9ada			; * DATA stack 
9ada			; * LOOP stack 
9ada			; * RETURN stack 
9ada			 
9ada			 
9ada			 
9ada			FORTH_CHK_DSP_UNDER: macro 
9ada				push hl 
9ada				push de 
9ada				ld hl,(cli_data_sp) 
9ada				ld de, cli_data_stack 
9ada				call cmp16 
9ada				jp c, fault_dsp_under 
9ada				pop de 
9ada				pop hl 
9ada				endm 
9ada			 
9ada			 
9ada			FORTH_CHK_RSP_UNDER: macro 
9ada				push hl 
9ada				push de 
9ada				ld hl,(cli_ret_sp) 
9ada				ld de, cli_ret_stack 
9ada				call cmp16 
9ada				jp c, fault_rsp_under 
9ada				pop de 
9ada				pop hl 
9ada				endm 
9ada			 
9ada			FORTH_CHK_LOOP_UNDER: macro 
9ada				push hl 
9ada				push de 
9ada				ld hl,(cli_loop_sp) 
9ada				ld de, cli_loop_stack 
9ada				call cmp16 
9ada				jp c, fault_loop_under 
9ada				pop de 
9ada				pop hl 
9ada				endm 
9ada			 
9ada			FORTH_ERR_TOS_NOTSTR: macro 
9ada				; TOSO might need more for checks when used 
9ada				push af 
9ada				ld a,(hl) 
9ada				cp DS_TYPE_STR 
9ada				jp nz, type_faultn   
9ada				pop af 
9ada				endm 
9ada			 
9ada			FORTH_ERR_TOS_NOTNUM: macro 
9ada				push af 
9ada				ld a,(hl) 
9ada				cp DS_TYPE_INUM 
9ada				jp nz, type_faultn   
9ada				pop af 
9ada				endm 
9ada			 
9ada			 
9ada			; increase data stack pointer and save hl to it 
9ada				 
9ada			FORTH_DSP_NEXT: macro 
9ada				call macro_forth_dsp_next 
9ada				endm 
9ada			 
9ada			 
9ada			macro_forth_dsp_next: 
9ada				if DEBUG_FORTH_STACK_GUARD 
9ada cd a3 e0				call check_stacks 
9add				endif 
9add e5				push hl 
9ade d5				push de 
9adf eb				ex de,hl 
9ae0 2a ee e9			ld hl,(cli_data_sp) 
9ae3 23				inc hl 
9ae4 23				inc hl 
9ae5			 
9ae5			; PARSEV5 
9ae5 23				inc hl 
9ae6 22 ee e9			ld (cli_data_sp),hl 
9ae9 73				ld (hl), e 
9aea 23				inc hl 
9aeb 72				ld (hl), d 
9aec d1				pop de 
9aed e1				pop hl 
9aee				if DEBUG_FORTH_STACK_GUARD 
9aee cd a3 e0				call check_stacks 
9af1				endif 
9af1 c9				ret 
9af2			 
9af2			 
9af2			; increase ret stack pointer and save hl to it 
9af2				 
9af2			FORTH_RSP_NEXT: macro 
9af2				call macro_forth_rsp_next 
9af2				endm 
9af2			 
9af2			macro_forth_rsp_next: 
9af2				if DEBUG_FORTH_STACK_GUARD 
9af2 cd a3 e0				call check_stacks 
9af5				endif 
9af5 e5				push hl 
9af6 d5				push de 
9af7 eb				ex de,hl 
9af8 2a f2 e9			ld hl,(cli_ret_sp) 
9afb 23				inc hl 
9afc 23				inc hl 
9afd 22 f2 e9			ld (cli_ret_sp),hl 
9b00 73				ld (hl), e 
9b01 23				inc hl 
9b02 72				ld (hl), d 
9b03 d1				pop de 
9b04 e1				pop hl 
9b05				if DEBUG_FORTH_STACK_GUARD 
9b05 cd a3 e0				call check_stacks 
9b08				endif 
9b08 c9				ret 
9b09			 
9b09			; get current ret stack pointer and save to hl  
9b09				 
9b09			FORTH_RSP_TOS: macro 
9b09				call macro_forth_rsp_tos 
9b09				endm 
9b09			 
9b09			macro_forth_rsp_tos: 
9b09				;push de 
9b09 2a f2 e9			ld hl,(cli_ret_sp) 
9b0c cd 44 9b			call loadhlptrtohl 
9b0f				;ld e, (hl) 
9b0f				;inc hl 
9b0f				;ld d, (hl) 
9b0f				;ex de, hl 
9b0f					if DEBUG_FORTH_WORDS 
9b0f			;			DMARK "RST" 
9b0f						CALLMONITOR 
9b0f cd 6f ee			call debug_vector  
9b12				endm  
# End of macro CALLMONITOR
9b12					endif 
9b12				;pop de 
9b12 c9				ret 
9b13			 
9b13			; pop ret stack pointer 
9b13				 
9b13			FORTH_RSP_POP: macro 
9b13				call macro_forth_rsp_pop 
9b13				endm 
9b13			 
9b13			 
9b13			macro_forth_rsp_pop: 
9b13				if DEBUG_FORTH_STACK_GUARD 
9b13			;		DMARK "RPP" 
9b13 cd a3 e0				call check_stacks 
9b16					FORTH_CHK_RSP_UNDER 
9b16 e5				push hl 
9b17 d5				push de 
9b18 2a f2 e9			ld hl,(cli_ret_sp) 
9b1b 11 ac e9			ld de, cli_ret_stack 
9b1e cd fa 8c			call cmp16 
9b21 da b7 e1			jp c, fault_rsp_under 
9b24 d1				pop de 
9b25 e1				pop hl 
9b26				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b26				endif 
9b26 e5				push hl 
9b27 2a f2 e9			ld hl,(cli_ret_sp) 
9b2a			 
9b2a			 
9b2a				if FORTH_ENABLE_FREE 
9b2a			 
9b2a					; get pointer 
9b2a			 
9b2a					push de 
9b2a					push hl 
9b2a			 
9b2a					ld e, (hl) 
9b2a					inc hl 
9b2a					ld d, (hl) 
9b2a			 
9b2a					ex de, hl 
9b2a					call free 
9b2a			 
9b2a					pop hl 
9b2a					pop de 
9b2a			 
9b2a			 
9b2a				endif 
9b2a			 
9b2a			 
9b2a 2b				dec hl 
9b2b 2b				dec hl 
9b2c 22 f2 e9			ld (cli_ret_sp), hl 
9b2f				; do stack underflow checks 
9b2f e1				pop hl 
9b30				if DEBUG_FORTH_STACK_GUARD 
9b30 cd a3 e0				call check_stacks 
9b33					FORTH_CHK_RSP_UNDER 
9b33 e5				push hl 
9b34 d5				push de 
9b35 2a f2 e9			ld hl,(cli_ret_sp) 
9b38 11 ac e9			ld de, cli_ret_stack 
9b3b cd fa 8c			call cmp16 
9b3e da b7 e1			jp c, fault_rsp_under 
9b41 d1				pop de 
9b42 e1				pop hl 
9b43				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b43				endif 
9b43 c9				ret 
9b44			 
9b44			 
9b44			 
9b44			; routine to load word pointed to by hl into hl 
9b44			 
9b44			loadhlptrtohl: 
9b44			 
9b44 d5				push de 
9b45 5e				ld e, (hl) 
9b46 23				inc hl 
9b47 56				ld d, (hl) 
9b48 eb				ex de, hl 
9b49 d1				pop de 
9b4a			 
9b4a c9				ret 
9b4b			 
9b4b			 
9b4b			 
9b4b			 
9b4b			 
9b4b			; push a number held in HL onto the data stack 
9b4b			; entry point for pushing a value when already in hl used in function above 
9b4b			 
9b4b			forth_push_numhl: 
9b4b			 
9b4b e5				push hl    ; save value to push 
9b4c			 
9b4c			if DEBUG_FORTH_PUSH 
9b4c				; see if disabled 
9b4c			 
9b4c			 
9b4c f5				push af 
9b4d 3a 6f ee			ld a,(debug_vector) 
9b50 fe c9			cp $c9   ; ret 
9b52			;	ld a, (os_view_disable) 
9b52			;	cp '*' 
9b52 28 34			jr z, .pskip2 
9b54 e5				push hl 
9b55 e5			push hl 
9b56 cd af 8a			call clear_display 
9b59 e1			pop hl 
9b5a 7c				ld a,h 
9b5b 21 c6 e5			ld hl, os_word_scratch 
9b5e cd dd 8f			call hexout 
9b61 e1				pop hl 
9b62 7d				ld a,l 
9b63 21 c8 e5			ld hl, os_word_scratch+2 
9b66 cd dd 8f			call hexout 
9b69			 
9b69 21 ca e5			ld hl, os_word_scratch+4 
9b6c 3e 00			ld a,0 
9b6e 77				ld (hl),a 
9b6f 11 c6 e5			ld de,os_word_scratch 
9b72 3e 28				ld a, display_row_2 
9b74 cd c2 8a				call str_at_display 
9b77 11 df cb			ld de, .push_num 
9b7a 3e 00			ld a, display_row_1 
9b7c			 
9b7c cd c2 8a				call str_at_display 
9b7f			 
9b7f			 
9b7f cd d2 8a			call update_display 
9b82 cd f2 89			call delay1s 
9b85 cd f2 89			call delay1s 
9b88			.pskip2:  
9b88			 
9b88 f1				pop af 
9b89			endif	 
9b89			 
9b89			 
9b89				FORTH_DSP_NEXT 
9b89 cd da 9a			call macro_forth_dsp_next 
9b8c				endm 
# End of macro FORTH_DSP_NEXT
9b8c			 
9b8c 2a ee e9			ld hl, (cli_data_sp) 
9b8f			 
9b8f				; save item type 
9b8f 3e 02			ld a,  DS_TYPE_INUM 
9b91 77				ld (hl), a 
9b92 23				inc hl 
9b93			 
9b93				; get word off stack 
9b93 d1				pop de 
9b94 7b				ld a,e 
9b95 77				ld (hl), a 
9b96 23				inc hl 
9b97 7a				ld a,d 
9b98 77				ld (hl), a 
9b99			 
9b99			if DEBUG_FORTH_PUSH 
9b99 2b				dec hl 
9b9a 2b				dec hl 
9b9b 2b				dec hl 
9b9c						DMARK "PH5" 
9b9c f5				push af  
9b9d 3a b1 9b			ld a, (.dmark)  
9ba0 32 6b ee			ld (debug_mark),a  
9ba3 3a b2 9b			ld a, (.dmark+1)  
9ba6 32 6c ee			ld (debug_mark+1),a  
9ba9 3a b3 9b			ld a, (.dmark+2)  
9bac 32 6d ee			ld (debug_mark+2),a  
9baf 18 03			jr .pastdmark  
9bb1 ..			.dmark: db "PH5"  
9bb4 f1			.pastdmark: pop af  
9bb5			endm  
# End of macro DMARK
9bb5				CALLMONITOR 
9bb5 cd 6f ee			call debug_vector  
9bb8				endm  
# End of macro CALLMONITOR
9bb8			endif	 
9bb8			 
9bb8 c9				ret 
9bb9			 
9bb9			 
9bb9			; Push a string to stack pointed to by hl 
9bb9			 
9bb9			forth_push_str: 
9bb9			 
9bb9			if DEBUG_FORTH_PUSH 
9bb9						DMARK "PSQ" 
9bb9 f5				push af  
9bba 3a ce 9b			ld a, (.dmark)  
9bbd 32 6b ee			ld (debug_mark),a  
9bc0 3a cf 9b			ld a, (.dmark+1)  
9bc3 32 6c ee			ld (debug_mark+1),a  
9bc6 3a d0 9b			ld a, (.dmark+2)  
9bc9 32 6d ee			ld (debug_mark+2),a  
9bcc 18 03			jr .pastdmark  
9bce ..			.dmark: db "PSQ"  
9bd1 f1			.pastdmark: pop af  
9bd2			endm  
# End of macro DMARK
9bd2				CALLMONITOR 
9bd2 cd 6f ee			call debug_vector  
9bd5				endm  
# End of macro CALLMONITOR
9bd5			endif	 
9bd5			    
9bd5 e5				push hl 
9bd6 e5				push hl 
9bd7			 
9bd7			;	ld a, 0   ; find end of string 
9bd7 cd 3a 91			call strlenz 
9bda			if DEBUG_FORTH_PUSH 
9bda						DMARK "PQ2" 
9bda f5				push af  
9bdb 3a ef 9b			ld a, (.dmark)  
9bde 32 6b ee			ld (debug_mark),a  
9be1 3a f0 9b			ld a, (.dmark+1)  
9be4 32 6c ee			ld (debug_mark+1),a  
9be7 3a f1 9b			ld a, (.dmark+2)  
9bea 32 6d ee			ld (debug_mark+2),a  
9bed 18 03			jr .pastdmark  
9bef ..			.dmark: db "PQ2"  
9bf2 f1			.pastdmark: pop af  
9bf3			endm  
# End of macro DMARK
9bf3				CALLMONITOR 
9bf3 cd 6f ee			call debug_vector  
9bf6				endm  
# End of macro CALLMONITOR
9bf6			endif	 
9bf6 eb				ex de, hl 
9bf7 e1				pop hl   ; get ptr to start of string 
9bf8			if DEBUG_FORTH_PUSH 
9bf8						DMARK "PQ3" 
9bf8 f5				push af  
9bf9 3a 0d 9c			ld a, (.dmark)  
9bfc 32 6b ee			ld (debug_mark),a  
9bff 3a 0e 9c			ld a, (.dmark+1)  
9c02 32 6c ee			ld (debug_mark+1),a  
9c05 3a 0f 9c			ld a, (.dmark+2)  
9c08 32 6d ee			ld (debug_mark+2),a  
9c0b 18 03			jr .pastdmark  
9c0d ..			.dmark: db "PQ3"  
9c10 f1			.pastdmark: pop af  
9c11			endm  
# End of macro DMARK
9c11				CALLMONITOR 
9c11 cd 6f ee			call debug_vector  
9c14				endm  
# End of macro CALLMONITOR
9c14			endif	 
9c14 19				add hl,de 
9c15			if DEBUG_FORTH_PUSH 
9c15						DMARK "PQE" 
9c15 f5				push af  
9c16 3a 2a 9c			ld a, (.dmark)  
9c19 32 6b ee			ld (debug_mark),a  
9c1c 3a 2b 9c			ld a, (.dmark+1)  
9c1f 32 6c ee			ld (debug_mark+1),a  
9c22 3a 2c 9c			ld a, (.dmark+2)  
9c25 32 6d ee			ld (debug_mark+2),a  
9c28 18 03			jr .pastdmark  
9c2a ..			.dmark: db "PQE"  
9c2d f1			.pastdmark: pop af  
9c2e			endm  
# End of macro DMARK
9c2e				CALLMONITOR 
9c2e cd 6f ee			call debug_vector  
9c31				endm  
# End of macro CALLMONITOR
9c31			endif	 
9c31			 
9c31 2b				dec hl    ; see if there is an optional trailing double quote 
9c32 7e				ld a,(hl) 
9c33 fe 22			cp '"' 
9c35 20 03			jr nz, .strnoq 
9c37 3e 00			ld a, 0      ; get rid of double quote 
9c39 77				ld (hl), a 
9c3a 23			.strnoq: inc hl 
9c3b			 
9c3b 3e 00			ld a, 0 
9c3d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c3e			 
9c3e 13				inc de ; add one for the type string 
9c3f 13				inc de ; add one for null term??? 
9c40			 
9c40				; tos is get string pointer again 
9c40				; de contains space to allocate 
9c40				 
9c40 d5				push de 
9c41			 
9c41 eb				ex de, hl 
9c42			 
9c42				;push af 
9c42			 
9c42			if DEBUG_FORTH_PUSH 
9c42						DMARK "PHm" 
9c42 f5				push af  
9c43 3a 57 9c			ld a, (.dmark)  
9c46 32 6b ee			ld (debug_mark),a  
9c49 3a 58 9c			ld a, (.dmark+1)  
9c4c 32 6c ee			ld (debug_mark+1),a  
9c4f 3a 59 9c			ld a, (.dmark+2)  
9c52 32 6d ee			ld (debug_mark+2),a  
9c55 18 03			jr .pastdmark  
9c57 ..			.dmark: db "PHm"  
9c5a f1			.pastdmark: pop af  
9c5b			endm  
# End of macro DMARK
9c5b				CALLMONITOR 
9c5b cd 6f ee			call debug_vector  
9c5e				endm  
# End of macro CALLMONITOR
9c5e			endif	 
9c5e cd a3 91			call malloc	; on ret hl now contains allocated memory 
9c61				if DEBUG_FORTH_MALLOC_GUARD 
9c61 cc 37 cc				call z,malloc_error 
9c64				endif 
9c64			 
9c64				 
9c64 c1				pop bc    ; get length 
9c65 d1				pop de   ;  get string start    
9c66			 
9c66				; hl has destination from malloc 
9c66			 
9c66 eb				ex de, hl    ; prep for ldir 
9c67			 
9c67 d5				push de   ; save malloc area for DSP later 
9c68				;push hl   ; save malloc area for DSP later 
9c68			 
9c68			if DEBUG_FORTH_PUSH 
9c68						DMARK "PHc" 
9c68 f5				push af  
9c69 3a 7d 9c			ld a, (.dmark)  
9c6c 32 6b ee			ld (debug_mark),a  
9c6f 3a 7e 9c			ld a, (.dmark+1)  
9c72 32 6c ee			ld (debug_mark+1),a  
9c75 3a 7f 9c			ld a, (.dmark+2)  
9c78 32 6d ee			ld (debug_mark+2),a  
9c7b 18 03			jr .pastdmark  
9c7d ..			.dmark: db "PHc"  
9c80 f1			.pastdmark: pop af  
9c81			endm  
# End of macro DMARK
9c81				CALLMONITOR 
9c81 cd 6f ee			call debug_vector  
9c84				endm  
# End of macro CALLMONITOR
9c84			endif	 
9c84			 
9c84			 
9c84 ed b0			ldir 
9c86			 
9c86			 
9c86				; push malloc to data stack     macro?????  
9c86			 
9c86				FORTH_DSP_NEXT 
9c86 cd da 9a			call macro_forth_dsp_next 
9c89				endm 
# End of macro FORTH_DSP_NEXT
9c89			 
9c89				; save value and type 
9c89			 
9c89 2a ee e9			ld hl, (cli_data_sp) 
9c8c			 
9c8c				; save item type 
9c8c 3e 01			ld a,  DS_TYPE_STR 
9c8e 77				ld (hl), a 
9c8f 23				inc hl 
9c90			 
9c90				; get malloc word off stack 
9c90 d1				pop de 
9c91 73				ld (hl), e 
9c92 23				inc hl 
9c93 72				ld (hl), d 
9c94			 
9c94			 
9c94			 
9c94			if DEBUG_FORTH_PUSH 
9c94 2a ee e9			ld hl, (cli_data_sp) 
9c97						DMARK "PHS" 
9c97 f5				push af  
9c98 3a ac 9c			ld a, (.dmark)  
9c9b 32 6b ee			ld (debug_mark),a  
9c9e 3a ad 9c			ld a, (.dmark+1)  
9ca1 32 6c ee			ld (debug_mark+1),a  
9ca4 3a ae 9c			ld a, (.dmark+2)  
9ca7 32 6d ee			ld (debug_mark+2),a  
9caa 18 03			jr .pastdmark  
9cac ..			.dmark: db "PHS"  
9caf f1			.pastdmark: pop af  
9cb0			endm  
# End of macro DMARK
9cb0				CALLMONITOR 
9cb0 cd 6f ee			call debug_vector  
9cb3				endm  
# End of macro CALLMONITOR
9cb3			;	ex de,hl 
9cb3			endif	 
9cb3				; in case of spaces, skip the ptr past the copied string 
9cb3				;pop af 
9cb3				;ld (cli_origptr),hl 
9cb3			 
9cb3 c9				ret 
9cb4			 
9cb4			 
9cb4			 
9cb4			; TODO ascii push input onto stack given hl to start of input 
9cb4			 
9cb4			; identify type 
9cb4			; if starts with a " then a string 
9cb4			; otherwise it is a number 
9cb4			;  
9cb4			; if a string 
9cb4			;     scan for ending " to get length of string to malloc for + 1 
9cb4			;     malloc 
9cb4			;     put pointer to string on stack first byte flags as string 
9cb4			; 
9cb4			; else a number 
9cb4			;    look for number format identifier 
9cb4			;    $xx hex 
9cb4			;    %xxxxx bin 
9cb4			;    xxxxx decimal 
9cb4			;    convert number to 16bit word.  
9cb4			;    malloc word + 1 with flag to identiy as num 
9cb4			;    put pointer to number on stack 
9cb4			;   
9cb4			;  
9cb4			  
9cb4			forth_apush: 
9cb4				; kernel push 
9cb4			 
9cb4			if DEBUG_FORTH_PUSH 
9cb4						DMARK "PSH" 
9cb4 f5				push af  
9cb5 3a c9 9c			ld a, (.dmark)  
9cb8 32 6b ee			ld (debug_mark),a  
9cbb 3a ca 9c			ld a, (.dmark+1)  
9cbe 32 6c ee			ld (debug_mark+1),a  
9cc1 3a cb 9c			ld a, (.dmark+2)  
9cc4 32 6d ee			ld (debug_mark+2),a  
9cc7 18 03			jr .pastdmark  
9cc9 ..			.dmark: db "PSH"  
9ccc f1			.pastdmark: pop af  
9ccd			endm  
# End of macro DMARK
9ccd				CALLMONITOR 
9ccd cd 6f ee			call debug_vector  
9cd0				endm  
# End of macro CALLMONITOR
9cd0			endif	 
9cd0				; identify input type 
9cd0			 
9cd0 7e				ld a,(hl) 
9cd1 fe 22			cp '"' 
9cd3 28 0a			jr z, .fapstr 
9cd5 fe 24			cp '$' 
9cd7 ca ff 9c			jp z, .faphex 
9cda fe 25			cp '%' 
9cdc ca e7 9c			jp z, .fapbin 
9cdf			;	cp 'b' 
9cdf			;	jp z, .fabin 
9cdf				; else decimal 
9cdf			 
9cdf				; TODO do decimal conversion 
9cdf				; decimal is stored as a 16bit word 
9cdf			 
9cdf				; by default everything is a string if type is not detected 
9cdf			.fapstr: ; 
9cdf fe 22			cp '"' 
9ce1 20 01			jr nz, .strnoqu 
9ce3 23				inc hl 
9ce4			.strnoqu: 
9ce4 c3 b9 9b			jp forth_push_str 
9ce7			 
9ce7			 
9ce7			 
9ce7			.fapbin:    ; push a binary string.  
9ce7 11 00 00			ld de, 0   ; hold a 16bit value 
9cea			 
9cea 23			.fapbinshift:	inc hl  
9ceb 7e				ld a,(hl) 
9cec fe 00			cp 0     ; done scanning  
9cee 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cf0			 
9cf0				; left shift de 
9cf0 eb				ex de, hl	 
9cf1 29				add hl, hl 
9cf2			 
9cf2				; is 1 
9cf2 fe 31			cp '1' 
9cf4 20 02			jr nz, .binzero 
9cf6 cb 4d			bit 1, l 
9cf8			.binzero: 
9cf8 eb				ex de, hl	 ; save current de 
9cf9 18 ef			jr .fapbinshift 
9cfb			 
9cfb			.fapbdone: 
9cfb eb				ex de, hl 
9cfc c3 4b 9b			jp forth_push_numhl 
9cff			 
9cff			 
9cff			.faphex:   ; hex is always stored as a 16bit word 
9cff				; skip number prefix 
9cff 23				inc hl 
9d00				; turn ascii into number 
9d00 cd 93 90			call get_word_hl	; ret 16bit word in hl 
9d03			 
9d03 c3 4b 9b			jp forth_push_numhl 
9d06			 
9d06 00				 nop 
9d07			 
9d07			.fabin:   ; TODO bin conversion 
9d07			 
9d07			 
9d07 c9				ret 
9d08			 
9d08			 
9d08			; get either a string ptr or a 16bit word from the data stack 
9d08			 
9d08			FORTH_DSP: macro 
9d08				call macro_forth_dsp 
9d08				endm 
9d08			 
9d08			macro_forth_dsp: 
9d08				; data stack pointer points to current word on tos 
9d08			 
9d08 2a ee e9			ld hl,(cli_data_sp) 
9d0b			 
9d0b				if DEBUG_FORTH_PUSH 
9d0b						DMARK "DSP" 
9d0b f5				push af  
9d0c 3a 20 9d			ld a, (.dmark)  
9d0f 32 6b ee			ld (debug_mark),a  
9d12 3a 21 9d			ld a, (.dmark+1)  
9d15 32 6c ee			ld (debug_mark+1),a  
9d18 3a 22 9d			ld a, (.dmark+2)  
9d1b 32 6d ee			ld (debug_mark+2),a  
9d1e 18 03			jr .pastdmark  
9d20 ..			.dmark: db "DSP"  
9d23 f1			.pastdmark: pop af  
9d24			endm  
# End of macro DMARK
9d24			 
9d24 cd 6a cc				call display_data_sp 
9d27				;call break_point_state 
9d27				;rst 030h 
9d27				CALLMONITOR 
9d27 cd 6f ee			call debug_vector  
9d2a				endm  
# End of macro CALLMONITOR
9d2a				endif 
9d2a			 
9d2a c9				ret 
9d2b			 
9d2b			; return hl to start of value on stack 
9d2b			 
9d2b			FORTH_DSP_VALUE: macro 
9d2b				call macro_forth_dsp_value 
9d2b				endm 
9d2b			 
9d2b			macro_forth_dsp_value: 
9d2b			 
9d2b				FORTH_DSP 
9d2b cd 08 9d			call macro_forth_dsp 
9d2e				endm 
# End of macro FORTH_DSP
9d2e			 
9d2e d5				push de 
9d2f			 
9d2f 23				inc hl ; skip type 
9d30			 
9d30 5e				ld e, (hl) 
9d31 23				inc hl 
9d32 56				ld d, (hl) 
9d33 eb				ex de,hl  
9d34			 
9d34 d1				pop de 
9d35			 
9d35 c9				ret 
9d36			 
9d36			; return hl to start of value to second item on stack 
9d36			 
9d36			FORTH_DSP_VALUEM1: macro 
9d36				call macro_forth_dsp_value_m1 
9d36				endm 
9d36			 
9d36			macro_forth_dsp_value_m1: 
9d36			 
9d36				FORTH_DSP 
9d36 cd 08 9d			call macro_forth_dsp 
9d39				endm 
# End of macro FORTH_DSP
9d39			 
9d39 2b				dec hl 
9d3a 2b				dec hl 
9d3b			;	dec hl 
9d3b			 
9d3b d5				push de 
9d3c			 
9d3c 5e				ld e, (hl) 
9d3d 23				inc hl 
9d3e 56				ld d, (hl) 
9d3f eb				ex de,hl  
9d40			 
9d40 d1				pop de 
9d41			 
9d41 c9				ret 
9d42			 
9d42				 
9d42			 
9d42			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d42			 
9d42			FORTH_DSP_POP: macro 
9d42				call macro_forth_dsp_pop 
9d42				endm 
9d42			 
9d42			 
9d42			; get the tos data type 
9d42			 
9d42			FORTH_DSP_TYPE:   macro 
9d42			 
9d42				;FORTH_DSP_VALUE 
9d42				FORTH_DSP 
9d42				 
9d42				; hl points to value 
9d42				; check type 
9d42			 
9d42				ld a,(hl) 
9d42			 
9d42				endm 
9d42			 
9d42			; load the tos value into hl 
9d42			 
9d42			 
9d42			FORTH_DSP_VALUEHL:  macro 
9d42				call macro_dsp_valuehl 
9d42				endm 
9d42			 
9d42			 
9d42			 
9d42			macro_dsp_valuehl: 
9d42				FORTH_DSP_VALUE 
9d42 cd 2b 9d			call macro_forth_dsp_value 
9d45				endm 
# End of macro FORTH_DSP_VALUE
9d45			 
9d45				;FORTH_ERR_TOS_NOTNUM 
9d45			 
9d45				;inc hl   ; skip type id 
9d45			 
9d45			;	push de 
9d45			; 
9d45			;	ld e, (hl) 
9d45			;	inc hl 
9d45			;	ld d, (hl) 
9d45			;	ex de,hl  
9d45			 
9d45			;	pop de 
9d45			 
9d45				if DEBUG_FORTH_PUSH 
9d45						DMARK "DVL" 
9d45 f5				push af  
9d46 3a 5a 9d			ld a, (.dmark)  
9d49 32 6b ee			ld (debug_mark),a  
9d4c 3a 5b 9d			ld a, (.dmark+1)  
9d4f 32 6c ee			ld (debug_mark+1),a  
9d52 3a 5c 9d			ld a, (.dmark+2)  
9d55 32 6d ee			ld (debug_mark+2),a  
9d58 18 03			jr .pastdmark  
9d5a ..			.dmark: db "DVL"  
9d5d f1			.pastdmark: pop af  
9d5e			endm  
# End of macro DMARK
9d5e				CALLMONITOR 
9d5e cd 6f ee			call debug_vector  
9d61				endm  
# End of macro CALLMONITOR
9d61				endif 
9d61 c9				ret 
9d62			 
9d62			forth_apushstrhl:      
9d62				; push of string requires use of cli_origptr 
9d62				; bodge use 
9d62			 
9d62				; get current cli_origptr, save, update with temp pointer  
9d62 ed 5b 3e ea		ld de, (cli_origptr) 
9d66 22 3e ea			ld (cli_origptr), hl 
9d69 d5				push de 
9d6a cd b4 9c			call forth_apush 
9d6d d1				pop de 
9d6e ed 53 3e ea		ld (cli_origptr), de 
9d72 c9			        ret	 
9d73			 
9d73			 
9d73			; increase loop stack pointer and save hl to it 
9d73				 
9d73			FORTH_LOOP_NEXT: macro 
9d73				call macro_forth_loop_next 
9d73				;nop 
9d73				endm 
9d73			 
9d73			macro_forth_loop_next: 
9d73				if DEBUG_FORTH_STACK_GUARD 
9d73 cd a3 e0				call check_stacks 
9d76				endif 
9d76 e5				push hl 
9d77 d5				push de 
9d78 eb				ex de,hl 
9d79 2a f0 e9			ld hl,(cli_loop_sp) 
9d7c 23				inc hl 
9d7d 23				inc hl 
9d7e					if DEBUG_FORTH_WORDS 
9d7e						DMARK "LNX" 
9d7e f5				push af  
9d7f 3a 93 9d			ld a, (.dmark)  
9d82 32 6b ee			ld (debug_mark),a  
9d85 3a 94 9d			ld a, (.dmark+1)  
9d88 32 6c ee			ld (debug_mark+1),a  
9d8b 3a 95 9d			ld a, (.dmark+2)  
9d8e 32 6d ee			ld (debug_mark+2),a  
9d91 18 03			jr .pastdmark  
9d93 ..			.dmark: db "LNX"  
9d96 f1			.pastdmark: pop af  
9d97			endm  
# End of macro DMARK
9d97						CALLMONITOR 
9d97 cd 6f ee			call debug_vector  
9d9a				endm  
# End of macro CALLMONITOR
9d9a					endif 
9d9a 22 f0 e9			ld (cli_loop_sp),hl 
9d9d 73				ld (hl), e 
9d9e 23				inc hl 
9d9f 72				ld (hl), d 
9da0 d1				pop de    ; been reversed so save a swap on restore 
9da1 e1				pop hl 
9da2				if DEBUG_FORTH_STACK_GUARD 
9da2 cd a3 e0				call check_stacks 
9da5				endif 
9da5 c9				ret 
9da6			 
9da6			; get current ret stack pointer and save to hl  
9da6				 
9da6			FORTH_LOOP_TOS: macro 
9da6				call macro_forth_loop_tos 
9da6				endm 
9da6			 
9da6			macro_forth_loop_tos: 
9da6 d5				push de 
9da7 2a f0 e9			ld hl,(cli_loop_sp) 
9daa 5e				ld e, (hl) 
9dab 23				inc hl 
9dac 56				ld d, (hl) 
9dad eb				ex de, hl 
9dae d1				pop de 
9daf c9				ret 
9db0			 
9db0			; pop loop stack pointer 
9db0				 
9db0			FORTH_LOOP_POP: macro 
9db0				call macro_forth_loop_pop 
9db0				endm 
9db0			 
9db0			 
9db0			macro_forth_loop_pop: 
9db0				if DEBUG_FORTH_STACK_GUARD 
9db0					DMARK "LPP" 
9db0 f5				push af  
9db1 3a c5 9d			ld a, (.dmark)  
9db4 32 6b ee			ld (debug_mark),a  
9db7 3a c6 9d			ld a, (.dmark+1)  
9dba 32 6c ee			ld (debug_mark+1),a  
9dbd 3a c7 9d			ld a, (.dmark+2)  
9dc0 32 6d ee			ld (debug_mark+2),a  
9dc3 18 03			jr .pastdmark  
9dc5 ..			.dmark: db "LPP"  
9dc8 f1			.pastdmark: pop af  
9dc9			endm  
# End of macro DMARK
9dc9 cd a3 e0				call check_stacks 
9dcc					FORTH_CHK_LOOP_UNDER 
9dcc e5				push hl 
9dcd d5				push de 
9dce 2a f0 e9			ld hl,(cli_loop_sp) 
9dd1 11 2a e9			ld de, cli_loop_stack 
9dd4 cd fa 8c			call cmp16 
9dd7 da bd e1			jp c, fault_loop_under 
9dda d1				pop de 
9ddb e1				pop hl 
9ddc				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9ddc				endif 
9ddc e5				push hl 
9ddd 2a f0 e9			ld hl,(cli_loop_sp) 
9de0 2b				dec hl 
9de1 2b				dec hl 
9de2 22 f0 e9			ld (cli_loop_sp), hl 
9de5				; TODO do stack underflow checks 
9de5 e1				pop hl 
9de6				if DEBUG_FORTH_STACK_GUARD 
9de6 cd a3 e0				call check_stacks 
9de9					FORTH_CHK_LOOP_UNDER 
9de9 e5				push hl 
9dea d5				push de 
9deb 2a f0 e9			ld hl,(cli_loop_sp) 
9dee 11 2a e9			ld de, cli_loop_stack 
9df1 cd fa 8c			call cmp16 
9df4 da bd e1			jp c, fault_loop_under 
9df7 d1				pop de 
9df8 e1				pop hl 
9df9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9df9				endif 
9df9 c9				ret 
9dfa			 
9dfa			macro_forth_dsp_pop: 
9dfa			 
9dfa e5				push hl 
9dfb			 
9dfb				; release malloc data 
9dfb			 
9dfb				if DEBUG_FORTH_STACK_GUARD 
9dfb cd a3 e0				call check_stacks 
9dfe					FORTH_CHK_DSP_UNDER 
9dfe e5				push hl 
9dff d5				push de 
9e00 2a ee e9			ld hl,(cli_data_sp) 
9e03 11 28 e8			ld de, cli_data_stack 
9e06 cd fa 8c			call cmp16 
9e09 da b1 e1			jp c, fault_dsp_under 
9e0c d1				pop de 
9e0d e1				pop hl 
9e0e				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e0e				endif 
9e0e				;ld hl,(cli_data_sp) 
9e0e			if DEBUG_FORTH_DOT 
9e0e				DMARK "DPP" 
9e0e f5				push af  
9e0f 3a 23 9e			ld a, (.dmark)  
9e12 32 6b ee			ld (debug_mark),a  
9e15 3a 24 9e			ld a, (.dmark+1)  
9e18 32 6c ee			ld (debug_mark+1),a  
9e1b 3a 25 9e			ld a, (.dmark+2)  
9e1e 32 6d ee			ld (debug_mark+2),a  
9e21 18 03			jr .pastdmark  
9e23 ..			.dmark: db "DPP"  
9e26 f1			.pastdmark: pop af  
9e27			endm  
# End of macro DMARK
9e27				CALLMONITOR 
9e27 cd 6f ee			call debug_vector  
9e2a				endm  
# End of macro CALLMONITOR
9e2a			endif	 
9e2a			 
9e2a			 
9e2a			if FORTH_ENABLE_DSPPOPFREE 
9e2a			 
9e2a				FORTH_DSP 
9e2a cd 08 9d			call macro_forth_dsp 
9e2d				endm 
# End of macro FORTH_DSP
9e2d			 
9e2d 7e				ld a, (hl) 
9e2e fe 01			cp DS_TYPE_STR 
9e30 20 23			jr nz, .skippopfree 
9e32			 
9e32				FORTH_DSP_VALUEHL 
9e32 cd 42 9d			call macro_dsp_valuehl 
9e35				endm 
# End of macro FORTH_DSP_VALUEHL
9e35 00				nop 
9e36			if DEBUG_FORTH_DOT 
9e36				DMARK "DPf" 
9e36 f5				push af  
9e37 3a 4b 9e			ld a, (.dmark)  
9e3a 32 6b ee			ld (debug_mark),a  
9e3d 3a 4c 9e			ld a, (.dmark+1)  
9e40 32 6c ee			ld (debug_mark+1),a  
9e43 3a 4d 9e			ld a, (.dmark+2)  
9e46 32 6d ee			ld (debug_mark+2),a  
9e49 18 03			jr .pastdmark  
9e4b ..			.dmark: db "DPf"  
9e4e f1			.pastdmark: pop af  
9e4f			endm  
# End of macro DMARK
9e4f				CALLMONITOR 
9e4f cd 6f ee			call debug_vector  
9e52				endm  
# End of macro CALLMONITOR
9e52			endif	 
9e52 cd 6d 92			call free 
9e55			.skippopfree: 
9e55				 
9e55			 
9e55			endif 
9e55			 
9e55			if DEBUG_FORTH_DOT_KEY 
9e55				DMARK "DP2" 
9e55				CALLMONITOR 
9e55			endif	 
9e55			 
9e55				; move pointer down 
9e55			 
9e55 2a ee e9			ld hl,(cli_data_sp) 
9e58 2b				dec hl 
9e59 2b				dec hl 
9e5a			; PARSEV5 
9e5a 2b				dec hl 
9e5b 22 ee e9			ld (cli_data_sp), hl 
9e5e			 
9e5e				if DEBUG_FORTH_STACK_GUARD 
9e5e cd a3 e0				call check_stacks 
9e61					FORTH_CHK_DSP_UNDER 
9e61 e5				push hl 
9e62 d5				push de 
9e63 2a ee e9			ld hl,(cli_data_sp) 
9e66 11 28 e8			ld de, cli_data_stack 
9e69 cd fa 8c			call cmp16 
9e6c da b1 e1			jp c, fault_dsp_under 
9e6f d1				pop de 
9e70 e1				pop hl 
9e71				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e71				endif 
9e71			 
9e71 e1				pop hl 
9e72			 
9e72 c9				ret 
9e73			 
9e73			getwordathl: 
9e73				; hl points to an address 
9e73				; load hl with the word at that address 
9e73			 
9e73 d5				push de 
9e74			 
9e74 5e				ld e, (hl) 
9e75 23				inc hl 
9e76 56				ld d, (hl) 
9e77 eb				ex de, hl 
9e78			 
9e78 d1				pop de 
9e79 c9				ret 
9e7a			 
9e7a			 
9e7a			 
9e7a			 
9e7a			 
9e7a			; eof 
9e7a			 
# End of file forth_stackopsv5.asm
9e7a			endif 
9e7a			 
9e7a			loadwordinhl:	 
9e7a			 
9e7a d5				push de 
9e7b			 
9e7b 5e				ld e, (hl) 
9e7c 23				inc hl 
9e7d 56				ld d, (hl) 
9e7e eb				ex de,hl  
9e7f			 
9e7f d1				pop de 
9e80			 
9e80 c9				ret 
9e81			 
9e81			user_word_eol:  
9e81				; hl contains the pointer to where to create a linked list item from the end 
9e81				; of the user dict to continue on at the system word dict 
9e81				 
9e81				; poke the stub of the word list linked list to repoint to rom words 
9e81			 
9e81				; stub format 
9e81				; db   word id 
9e81				; dw    link to next word 
9e81			        ; db char length of token 
9e81				; db string + 0 term 
9e81				; db exec code....  
9e81			 
9e81 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e83 77				ld (hl), a		; word id 
9e84 23				inc hl 
9e85			 
9e85 11 50 a0			ld de, sysdict 
9e88 73				ld (hl), e		; next word link ie system dict 
9e89 23				inc hl 
9e8a 72				ld (hl), d		; next word link ie system dict 
9e8b 23				inc hl	 
9e8c			 
9e8c			;	ld (hl), sysdict		; next word link ie system dict 
9e8c			;	inc hl 
9e8c			;	inc hl 
9e8c			 
9e8c			;	inc hl 
9e8c			;	inc hl 
9e8c			 
9e8c 3e 02			ld a, 2			; word length is 0 
9e8e 77				ld (hl), a	 
9e8f 23				inc hl 
9e90			 
9e90 3e 7e			ld a, '~'			; word length is 0 
9e92 77				ld (hl), a	 
9e93 23				inc hl 
9e94 3e 00			ld a, 0			; save empty word 
9e96 77				ld (hl), a 
9e97			 
9e97 c9				ret 
9e98			 
9e98				 
9e98			 
9e98			forthexec_cleanup: 
9e98				FORTH_RSP_POP 
9e98 cd 13 9b			call macro_forth_rsp_pop 
9e9b				endm 
# End of macro FORTH_RSP_POP
9e9b c9				ret 
9e9c			 
9e9c			forth_call_hl: 
9e9c				; taking hl 
9e9c e5				push hl 
9e9d c9				ret 
9e9e			 
9e9e			; this is called to reset Forth system but keep existing uwords etc 
9e9e			 
9e9e			forth_warmstart: 
9e9e				; setup stack over/under flow checks 
9e9e				if DEBUG_FORTH_STACK_GUARD 
9e9e cd 89 e0				call chk_stk_init 
9ea1				endif 
9ea1			 
9ea1				; init stack pointers  - * these stacks go upwards *  
9ea1 21 ac e9			ld hl, cli_ret_stack 
9ea4 22 f2 e9			ld (cli_ret_sp), hl	 
9ea7				; set bottom of stack 
9ea7 3e 00			ld a,0 
9ea9 77				ld (hl),a 
9eaa 23				inc hl 
9eab 77				ld (hl),a 
9eac			 
9eac 21 28 e8			ld hl, cli_data_stack 
9eaf 22 ee e9			ld (cli_data_sp), hl	 
9eb2				; set bottom of stack 
9eb2 3e 00			ld a,0 
9eb4 77				ld (hl),a 
9eb5 23				inc hl 
9eb6 77				ld (hl),a 
9eb7			 
9eb7 21 2a e9			ld hl, cli_loop_stack 
9eba 22 f0 e9			ld (cli_loop_sp), hl	 
9ebd				; set bottom of stack 
9ebd 3e 00			ld a,0 
9ebf 77				ld (hl),a 
9ec0 23				inc hl 
9ec1 77				ld (hl),a 
9ec2			 
9ec2				; init extent of current open file 
9ec2			 
9ec2 3e 00			ld a, 0 
9ec4 32 6a ea			ld (store_openext), a 
9ec7			 
9ec7 c9				ret 
9ec8			 
9ec8			 
9ec8			 
9ec8			; Cold Start - this is called to setup the whole Forth system 
9ec8			 
9ec8			forth_init: 
9ec8			 
9ec8				; setup stack over/under flow checks 
9ec8			 
9ec8			;	if DEBUG_FORTH_STACK_GUARD 
9ec8			;		call chk_stk_init 
9ec8			;	endif 
9ec8			 
9ec8				; enable auto display updates (slow.....) 
9ec8			 
9ec8 3e 01			ld a, 1 
9eca 32 3c ea			ld (cli_autodisplay), a 
9ecd			 
9ecd				; if storage is in use disable long reads for now 
9ecd 3e 00			ld a, 0 
9ecf 32 75 ea			ld (store_longread), a 
9ed2			 
9ed2			 
9ed2				; show start up screen 
9ed2			 
9ed2 cd af 8a			call clear_display 
9ed5			 
9ed5 3e 00			ld a,0 
9ed7 32 5e ea			ld (f_cursor_ptr), a 
9eda			 
9eda				; set start of word list in start of ram - for use when creating user words 
9eda			 
9eda 21 3d e4			ld hl, baseram 
9edd 22 be e5			ld (os_last_new_uword), hl 
9ee0 cd 81 9e			call user_word_eol 
9ee3				 
9ee3			;		call display_data_sp 
9ee3			;		call next_page_prompt 
9ee3			 
9ee3			 
9ee3			 
9ee3			 
9ee3 c9				ret 
9ee4			 
9ee4 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ef8			 
9ef8			; TODO push to stack 
9ef8			 
9ef8			;  
9ef8			 
9ef8			if FORTH_PARSEV2 
9ef8			 
9ef8			 
9ef8				include "forth_parserv2.asm" 
9ef8			 
9ef8			endif 
9ef8			 
9ef8			 
9ef8			; parse cli version 1 
9ef8			 
9ef8			if FORTH_PARSEV1 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv1.asm" 
9ef8			endif 
9ef8				 
9ef8			if FORTH_PARSEV3 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv3.asm" 
9ef8				include "forth_wordsv3.asm" 
9ef8			endif 
9ef8			 
9ef8			if FORTH_PARSEV4 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv4.asm" 
9ef8				include "forth_wordsv4.asm" 
9ef8			endif 
9ef8			 
9ef8			if FORTH_PARSEV5 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv5.asm" 
9ef8			 
9ef8			 
9ef8			; A better parser without using malloc and string copies all over the place.  
9ef8			; Exec in situ should be faster 
9ef8			 
9ef8			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ef8			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ef8			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ef8			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ef8			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ef8			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ef8			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ef8			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ef8			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ef8			 
9ef8			; Core word preamble macro 
9ef8			 
9ef8			CWHEAD:   macro nxtword opcode lit len opflags 
9ef8				db WORD_SYS_CORE+opcode             
9ef8				; internal op code number 
9ef8				dw nxtword            
9ef8				; link to next dict word block 
9ef8				db len + 1 
9ef8				; literal length of dict word inc zero term 
9ef8				db lit,0              
9ef8				; literal dict word 
9ef8			        ; TODO db opflags        
9ef8				endm 
9ef8			 
9ef8			 
9ef8			NEXTW: macro  
9ef8				jp macro_next 
9ef8				endm 
9ef8			 
9ef8			macro_next: 
9ef8			if DEBUG_FORTH_PARSE_KEY 
9ef8				DMARK "NXT" 
9ef8				CALLMONITOR 
9ef8			endif	 
9ef8			;	inc hl  ; skip token null term  
9ef8 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9efc ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f00 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f03			if DEBUG_FORTH_PARSE_KEY 
9f03				DMARK "}AA" 
9f03				CALLMONITOR 
9f03			endif	 
9f03 c3 06 a0			jp execnext 
9f06				;jp exec1 
9f06			       
9f06			 
9f06			 
9f06			; Another go at the parser to compile  
9f06			 
9f06			 
9f06			; TODO rework parser to change all of the string words to byte tokens 
9f06			; TODO do a search for  
9f06			 
9f06			; TODO first run normal parser to zero term sections 
9f06			; TODO for each word do a token look up to get the op code 
9f06			; TODO need some means to flag to the exec that this is a byte code form    
9f06			 
9f06			 
9f06			forthcompile: 
9f06			 
9f06			; 
9f06			; line parse: 
9f06			;       parse raw input buffer 
9f06			;       tokenise the words 
9f06			;       malloc new copy (for looping etc) 
9f06			;       copy to malloc + current pc in line to start of string and add line term 
9f06			;       save on new rsp 
9f06			; 
9f06			 
9f06			; hl to point to the line to tokenise 
9f06			 
9f06			;	push hl 
9f06 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f09			 
9f09			;	ld a,0		; string term on input 
9f09			;	call strlent 
9f09			 
9f09			;	ld (os_tok_len), hl	 ; save string length 
9f09			 
9f09			;if DEBUG_FORTH_TOK 
9f09			;	ex de,hl		 
9f09			;endif 
9f09			 
9f09			;	pop hl 		; get back string pointer 
9f09			 
9f09			if DEBUG_FORTH_TOK 
9f09						DMARK "TOc" 
9f09				CALLMONITOR 
9f09			endif 
9f09 7e			.cptoken2:    ld a,(hl) 
9f0a 23				inc hl 
9f0b fe 7f			cp FORTH_END_BUFFER 
9f0d 28 29			jr z, .cptokendone2 
9f0f fe 00			cp 0 
9f11 28 25			jr z, .cptokendone2 
9f13 fe 22			cp '"' 
9f15 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f17 fe 20			cp ' ' 
9f19 20 ee			jr nz,  .cptoken2 
9f1b			 
9f1b			; TODO consume comments held between ( and ) 
9f1b			 
9f1b				; we have a space so change to zero term for dict match later 
9f1b 2b				dec hl 
9f1c 3e 00			ld a,0 
9f1e 77				ld (hl), a 
9f1f 23				inc hl 
9f20 18 e7			jr .cptoken2 
9f22				 
9f22			 
9f22			.cptokenstr2: 
9f22				; skip all white space until either eol (because forgot to term) or end double quote 
9f22			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f22				;inc hl ; skip current double quote 
9f22 7e				ld a,(hl) 
9f23 23				inc hl 
9f24 fe 22			cp '"' 
9f26 28 e1			jr z, .cptoken2 
9f28 fe 7f			cp FORTH_END_BUFFER 
9f2a 28 0c			jr z, .cptokendone2 
9f2c fe 00			cp 0 
9f2e 28 08			jr z, .cptokendone2 
9f30 fe 20			cp ' ' 
9f32 28 02			jr z, .cptmp2 
9f34 18 ec			jr .cptokenstr2 
9f36			 
9f36			.cptmp2:	; we have a space so change to zero term for dict match later 
9f36				;dec hl 
9f36				;ld a,"-"	; TODO remove this when working 
9f36				;ld (hl), a 
9f36				;inc hl 
9f36 18 ea			jr .cptokenstr2 
9f38			 
9f38			.cptokendone2: 
9f38				;inc hl 
9f38 3e 7f			ld a, FORTH_END_BUFFER 
9f3a 77				ld (hl),a 
9f3b 23				inc hl 
9f3c 3e 21			ld a, '!' 
9f3e 77				ld (hl),a 
9f3f			 
9f3f 2a c2 e5			ld hl,(os_tok_ptr) 
9f42			         
9f42			if DEBUG_FORTH_TOK 
9f42						DMARK "Tc1" 
9f42				CALLMONITOR 
9f42			endif 
9f42			 
9f42				; push exec string to top of return stack 
9f42				FORTH_RSP_NEXT 
9f42 cd f2 9a			call macro_forth_rsp_next 
9f45				endm 
# End of macro FORTH_RSP_NEXT
9f45 c9				ret 
9f46			 
9f46			; Another go at the parser need to simplify the process 
9f46			 
9f46			forthparse: 
9f46			 
9f46			; 
9f46			; line parse: 
9f46			;       parse raw input buffer 
9f46			;       tokenise the words 
9f46			;       malloc new copy (for looping etc) 
9f46			;       copy to malloc + current pc in line to start of string and add line term 
9f46			;       save on new rsp 
9f46			; 
9f46			 
9f46			; hl to point to the line to tokenise 
9f46			 
9f46			;	push hl 
9f46 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f49			 
9f49			;	ld a,0		; string term on input 
9f49			;	call strlent 
9f49			 
9f49			;	ld (os_tok_len), hl	 ; save string length 
9f49			 
9f49			;if DEBUG_FORTH_TOK 
9f49			;	ex de,hl		 
9f49			;endif 
9f49			 
9f49			;	pop hl 		; get back string pointer 
9f49			 
9f49			if DEBUG_FORTH_TOK 
9f49						DMARK "TOK" 
9f49				CALLMONITOR 
9f49			endif 
9f49 7e			.ptoken2:    ld a,(hl) 
9f4a 23				inc hl 
9f4b fe 7f			cp FORTH_END_BUFFER 
9f4d 28 29			jr z, .ptokendone2 
9f4f fe 00			cp 0 
9f51 28 25			jr z, .ptokendone2 
9f53 fe 22			cp '"' 
9f55 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f57 fe 20			cp ' ' 
9f59 20 ee			jr nz,  .ptoken2 
9f5b			 
9f5b			; TODO consume comments held between ( and ) 
9f5b			 
9f5b				; we have a space so change to zero term for dict match later 
9f5b 2b				dec hl 
9f5c 3e 00			ld a,0 
9f5e 77				ld (hl), a 
9f5f 23				inc hl 
9f60 18 e7			jr .ptoken2 
9f62				 
9f62			 
9f62			.ptokenstr2: 
9f62				; skip all white space until either eol (because forgot to term) or end double quote 
9f62			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f62				;inc hl ; skip current double quote 
9f62 7e				ld a,(hl) 
9f63 23				inc hl 
9f64 fe 22			cp '"' 
9f66 28 e1			jr z, .ptoken2 
9f68 fe 7f			cp FORTH_END_BUFFER 
9f6a 28 0c			jr z, .ptokendone2 
9f6c fe 00			cp 0 
9f6e 28 08			jr z, .ptokendone2 
9f70 fe 20			cp ' ' 
9f72 28 02			jr z, .ptmp2 
9f74 18 ec			jr .ptokenstr2 
9f76			 
9f76			.ptmp2:	; we have a space so change to zero term for dict match later 
9f76				;dec hl 
9f76				;ld a,"-"	; TODO remove this when working 
9f76				;ld (hl), a 
9f76				;inc hl 
9f76 18 ea			jr .ptokenstr2 
9f78			 
9f78			.ptokendone2: 
9f78				;inc hl 
9f78 3e 7f			ld a, FORTH_END_BUFFER 
9f7a 77				ld (hl),a 
9f7b 23				inc hl 
9f7c 3e 21			ld a, '!' 
9f7e 77				ld (hl),a 
9f7f			 
9f7f 2a c2 e5			ld hl,(os_tok_ptr) 
9f82			         
9f82			if DEBUG_FORTH_TOK 
9f82						DMARK "TK1" 
9f82				CALLMONITOR 
9f82			endif 
9f82			 
9f82				; push exec string to top of return stack 
9f82				FORTH_RSP_NEXT 
9f82 cd f2 9a			call macro_forth_rsp_next 
9f85				endm 
# End of macro FORTH_RSP_NEXT
9f85 c9				ret 
9f86			 
9f86			; 
9f86			;	; malloc size + buffer pointer + if is loop flag 
9f86			;	ld hl,(os_tok_len) 		 ; get string length 
9f86			; 
9f86			;	ld a,l 
9f86			; 
9f86			;	cp 0			; we dont want to use a null string 
9f86			;	ret z 
9f86			; 
9f86			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f86			; 
9f86			;	add 5     ; TODO when certain not over writing memory remove 
9f86			; 
9f86			;		 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKE" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	ld l,a 
9f86			;	ld h,0 
9f86			;;	push hl   ; save required space for the copy later 
9f86			;	call malloc 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKM" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			;	if DEBUG_FORTH_MALLOC_GUARD 
9f86			;		push af 
9f86			;		call ishlzero 
9f86			;;		ld a, l 
9f86			;;		add h 
9f86			;;		cp 0 
9f86			;		pop af 
9f86			;		 
9f86			;		call z,malloc_error 
9f86			;	endif 
9f86			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f86			; 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKR" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	FORTH_RSP_NEXT 
9f86			; 
9f86			;	;inc hl	 ; go past current buffer pointer 
9f86			;	;inc hl 
9f86			;	;inc hl   ; and past if loop flag 
9f86			;		; TODO Need to set flag  
9f86			; 
9f86			;	 
9f86			;	 
9f86			;	ex de,hl	; malloc is dest 
9f86			;	ld hl, (os_tok_len) 
9f86			;;	pop bc 
9f86			;	ld c, l                
9f86			;	ld b,0 
9f86			;	ld hl, (os_tok_ptr) 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKT" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	; do str cpy 
9f86			; 
9f86			;	ldir      ; copy byte in hl to de 
9f86			; 
9f86			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			; 
9f86			;			DMARK "TKY" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			;	;ld a,0 
9f86			;	;ld a,FORTH_END_BUFFER 
9f86			;	ex de, hl 
9f86			;	;dec hl			 ; go back over the space delim at the end of word 
9f86			;	;ld (hl),a 
9f86			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f86			;	ld a,FORTH_END_BUFFER 
9f86			;	ld (hl),a 
9f86			;	inc hl 
9f86			;	ld a,FORTH_END_BUFFER 
9f86			;	ld (hl),a 
9f86			; 
9f86			;	; init the malloc area data 
9f86			;	; set pc for in current area 
9f86			;	;ld hl, (os_tok_malloc) 
9f86			;	;inc hl 
9f86			;	;inc hl 
9f86			;	;inc hl 
9f86			;	;ex de,hl 
9f86			;	;ld hl, (os_tok_malloc) 
9f86			;	;ld (hl),e 
9f86			;	;inc hl 
9f86			;	;ld (hl),d 
9f86			; 
9f86			; 
9f86			;	ld hl,(os_tok_malloc) 
9f86			;if DEBUG_FORTH_PARSE_KEY 
9f86			;			DMARK "TKU" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	ret 
9f86			 
9f86			forthexec: 
9f86			 
9f86			; line exec: 
9f86			; forth parser 
9f86			 
9f86			; 
9f86			;       get current exec line on rsp 
9f86			 
9f86				FORTH_RSP_TOS 
9f86 cd 09 9b			call macro_forth_rsp_tos 
9f89				endm 
# End of macro FORTH_RSP_TOS
9f89			 
9f89			;       restore current pc - hl points to malloc of data 
9f89			 
9f89				;ld e, (hl) 
9f89				;inc hl 
9f89				;ld d, (hl) 
9f89				;ex de,hl 
9f89			 
9f89			 
9f89			exec1: 
9f89 22 c2 e5			ld (os_tok_ptr), hl 
9f8c			 
9f8c				; copy our PC to working vars  
9f8c 22 40 ea			ld (cli_ptr), hl 
9f8f 22 3e ea			ld (cli_origptr), hl 
9f92			 
9f92 7e				ld a,(hl) 
9f93 fe 7f			cp FORTH_END_BUFFER 
9f95 c8				ret z 
9f96			 
9f96				; skip any nulls 
9f96			 
9f96 fe 00			cp 0 
9f98 20 03			jr nz, .execword 
9f9a 23				inc hl 
9f9b 18 ec			jr exec1 
9f9d			 
9f9d			 
9f9d			.execword: 
9f9d			 
9f9d			 
9f9d			 
9f9d			if DEBUG_FORTH_PARSE_KEY 
9f9d						DMARK "KYQ" 
9f9d				CALLMONITOR 
9f9d			endif 
9f9d			;       while at start of word: 
9f9d			; get start of dict (in user area first) 
9f9d			 
9f9d 21 3d e4		ld hl, baseram 
9fa0			;ld hl, sysdict 
9fa0 22 42 ea		ld (cli_nextword),hl 
9fa3			;           match word at pc 
9fa3			;           exec word 
9fa3			;           or push to dsp 
9fa3			;           forward to next token 
9fa3			;           if line term pop rsp and exit 
9fa3			;        
9fa3			 
9fa3			if DEBUG_FORTH_PARSE_KEY 
9fa3						DMARK "KYq" 
9fa3				CALLMONITOR 
9fa3			endif 
9fa3			 
9fa3			; 
9fa3			; word comp 
9fa3			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9fa3			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9fa3			;    move to start of word  
9fa3			;    compare word to cli_token 
9fa3			 
9fa3			.execpnword:	; HL at start of a word in the dictionary to check 
9fa3			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9fa3			;	ld (cli_ptr), hl 
9fa3			 
9fa3 2a 42 ea			ld hl,(cli_nextword) 
9fa6			 
9fa6 cd 49 a0			call forth_tok_next 
9fa9			; tok next start here 
9fa9			;	; TODO skip compiled symbol for now 
9fa9			;	inc hl 
9fa9			; 
9fa9			;	; save pointer to next word 
9fa9			; 
9fa9			;	; hl now points to the address of the next word pointer  
9fa9			;	ld e, (hl) 
9fa9			;	inc hl 
9fa9			;	ld d, (hl) 
9fa9			;	inc l 
9fa9			; 
9fa9			;	ex de,hl 
9fa9			;if DEBUG_FORTH_PARSE_NEXTWORD 
9fa9			;	push bc 
9fa9			;	ld bc, (cli_nextword) 
9fa9			;			DMARK "NXW" 
9fa9			;	CALLMONITOR 
9fa9			;	pop bc 
9fa9			;endif 
9fa9			; tok next end here 
9fa9 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9fac eb				ex de, hl 
9fad			 
9fad			 
9fad				; save the pointer of the current token - 1 to check against 
9fad				 
9fad 22 46 ea			ld (cli_token), hl   
9fb0				; TODO maybe remove below save if no debug 
9fb0				; save token string ptr for any debug later 
9fb0 23				inc hl  
9fb1 22 48 ea			ld (cli_origtoken), hl 
9fb4 2b				dec hl 
9fb5				; save pointer to the start of the next dictionay word 
9fb5 7e				ld a,(hl)   ; get string length 
9fb6 47				ld b,a 
9fb7			.execpnwordinc:  
9fb7 23				inc hl 
9fb8 10 fd			djnz .execpnwordinc 
9fba 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9fbd			 
9fbd				; now check the word token against the string being parsed 
9fbd			 
9fbd 2a 46 ea			ld hl,(cli_token) 
9fc0 23				inc hl     ; skip string length (use zero term instead to end) 
9fc1 22 46 ea			ld (cli_token), hl 
9fc4			 
9fc4			if DEBUG_FORTH_PARSE_KEY 
9fc4						DMARK "KY2" 
9fc4			endif 
9fc4			if DEBUG_FORTH_PARSE_EXEC 
9fc4				; see if disabled 
9fc4			 
9fc4			;	ld a, (os_view_disable) 
9fc4			;	cp '*' 
9fc4				ld a, (debug_vector) 
9fc4				cp $c9   ; RET  
9fc4				jr z, .skip 
9fc4			 
9fc4				push hl 
9fc4				push hl 
9fc4				call clear_display 
9fc4				ld de, .compword 
9fc4				ld a, display_row_1 
9fc4				call str_at_display 
9fc4				pop de 
9fc4				ld a, display_row_2 
9fc4				call str_at_display 
9fc4				ld hl,(cli_ptr) 
9fc4				ld a,(hl) 
9fc4			        ld hl, os_word_scratch 
9fc4				ld (hl),a 
9fc4				ld a,0 
9fc4				inc hl 
9fc4				ld (hl),a 	 
9fc4				ld de, os_word_scratch 
9fc4				ld a, display_row_2+10 
9fc4				call str_at_display 
9fc4				call update_display 
9fc4				ld a, 100 
9fc4				call aDelayInMS 
9fc4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc4				call delay250ms 
9fc4				endif 
9fc4				pop hl 
9fc4			.skip:  
9fc4			endif	 
9fc4			.execpnchar:    ; compare char between token and string to parse 
9fc4			 
9fc4			if DEBUG_FORTH_PARSE_KEY 
9fc4						DMARK "Ky3" 
9fc4			endif 
9fc4			if DEBUG_FORTH_PARSE_EXEC 
9fc4				; see if disabled 
9fc4			 
9fc4			;	ld a, (os_view_disable) 
9fc4			;	cp '*' 
9fc4				ld a, (debug_vector) 
9fc4				cp $C9  ; RET 
9fc4				jr z, .skip2 
9fc4			 
9fc4			;	call clear_display 
9fc4			ld hl,(cli_token) 
9fc4			ld a,(hl) 
9fc4			ld (os_word_scratch),a 
9fc4				ld hl,(cli_ptr) 
9fc4			ld a,(hl) 
9fc4				ld (os_word_scratch+1),a 
9fc4				ld a,0 
9fc4				ld (os_word_scratch+2),a 
9fc4				ld de,os_word_scratch 
9fc4				ld a,display_row_4 
9fc4				call str_at_display 
9fc4				call update_display 
9fc4			.skip2:  
9fc4			endif 
9fc4 2a 46 ea			ld hl,(cli_token) 
9fc7 7e				ld a, (hl)	 ; char in word token 
9fc8 23				inc hl 		; move to next char 
9fc9 22 46 ea			ld (cli_token), hl ; and save it 
9fcc 47				ld b,a 
9fcd			 
9fcd 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fd0 7e				ld a,(hl) 
9fd1 23				inc hl 
9fd2 22 40 ea			ld (cli_ptr), hl		; move to next char 
9fd5 cd 31 91			call toUpper 		; make sure the input string matches case 
9fd8			 
9fd8			if DEBUG_FORTH_PARSE 
9fd8			endif 
9fd8			 
9fd8				; input stream end of token is a space so get rid of it 
9fd8			 
9fd8			;	cp ' ' 
9fd8			;	jr nz, .pnskipspace 
9fd8			; 
9fd8			;	ld a, 0		; make same term as word token term 
9fd8			; 
9fd8			;.pnskipspace: 
9fd8			 
9fd8			if DEBUG_FORTH_PARSE_KEY 
9fd8						DMARK "KY7" 
9fd8			endif 
9fd8 b8				cp b 
9fd9 c2 ef 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fdc				 
9fdc			;    if same 
9fdc			;       scan for string terms 0 for token and 32 for input 
9fdc			 
9fdc				 
9fdc			if DEBUG_FORTH_PARSE_KEY 
9fdc						DMARK "KY8" 
9fdc			endif 
9fdc			 
9fdc 80				add b			 
9fdd fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fdf							; TODO need to make sure last word in zero term string is accounted for 
9fdf 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fe1			 
9fe1			 
9fe1				; at end of both strings so both are exact match 
9fe1			 
9fe1			;       skip ptr for next word 
9fe1			 
9fe1 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9fe4 23				inc hl			 ; at next char 
9fe5 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fe8 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9feb				 
9feb				 
9feb			if DEBUG_FORTH_PARSE_KEY 
9feb						DMARK "KY3" 
9feb			endif 
9feb			 
9feb			 
9feb			 
9feb			;       exec code block 
9feb			if DEBUG_FORTH_JP 
9feb				call clear_display 
9feb				call update_display 
9feb				call delay1s 
9feb				ld hl, (cli_execword)     ; save for next check if no match on this word 
9feb				ld a,h 
9feb				ld hl, os_word_scratch 
9feb				call hexout 
9feb				ld hl, (cli_execword)     ; save for next check if no match on this word 
9feb				ld a,l 
9feb				ld hl, os_word_scratch+2 
9feb				call hexout 
9feb				ld hl, os_word_scratch+4 
9feb				ld a,0 
9feb				ld (hl),a 
9feb				ld de,os_word_scratch 
9feb				call str_at_display 
9feb					ld a, display_row_2 
9feb					call str_at_display 
9feb				ld de, (cli_origtoken) 
9feb				ld a, display_row_1+10 
9feb					call str_at_display 
9feb			 
9feb				ld a,display_row_1 
9feb				ld de, .foundword 
9feb				ld a, display_row_3 
9feb				call str_at_display 
9feb				call update_display 
9feb				call delay1s 
9feb				call delay1s 
9feb				call delay1s 
9feb			endif 
9feb			 
9feb			if DEBUG_FORTH_PARSE_KEY 
9feb						DMARK "KYj" 
9feb			endif 
9feb				; TODO save the word pointer in this exec 
9feb			 
9feb 2a 44 ea			ld hl,(cli_execword) 
9fee e9				jp (hl) 
9fef			 
9fef			 
9fef			;    if not same 
9fef			;	scan for zero term 
9fef			;	get ptr for next word 
9fef			;	goto word comp 
9fef			 
9fef			.execpnskipword:	; get pointer to next word 
9fef 2a 42 ea			ld hl,(cli_nextword) 
9ff2			 
9ff2 7e				ld a,(hl) 
9ff3 fe 00			cp WORD_SYS_END 
9ff5			;	cp 0 
9ff5 28 09			jr z, .execendofdict			 ; at end of words 
9ff7			 
9ff7			if DEBUG_FORTH_PARSE_KEY 
9ff7						DMARK "KY4" 
9ff7			endif 
9ff7			if DEBUG_FORTH_PARSE_EXEC 
9ff7			 
9ff7				; see if disabled 
9ff7			 
9ff7			;	ld a, (os_view_disable) 
9ff7			;	cp '*' 
9ff7				ld a,(debug_vector) 
9ff7				cp $c9   ; RET 
9ff7				jr z, .noskip 
9ff7			 
9ff7			 
9ff7				ld de, .nowordfound 
9ff7				ld a, display_row_3 
9ff7				call str_at_display 
9ff7				call update_display 
9ff7				ld a, 100 
9ff7				call aDelayInMS 
9ff7				 
9ff7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ff7					call delay250ms 
9ff7				endif 
9ff7			.noskip:  
9ff7			 
9ff7			endif	 
9ff7			 
9ff7 2a 3e ea			ld hl,(cli_origptr) 
9ffa 22 40 ea			ld (cli_ptr),hl 
9ffd			 
9ffd			if DEBUG_FORTH_PARSE_KEY 
9ffd						DMARK "KY5" 
9ffd			endif 
9ffd c3 a3 9f			jp .execpnword			; else go to next word 
a000			 
a000			.execendofdict:  
a000			 
a000			if DEBUG_FORTH_PARSE_KEY 
a000						DMARK "KYe" 
a000			endif 
a000			if DEBUG_FORTH_PARSE_EXEC 
a000				; see if disabled 
a000			 
a000			;	ld a, (os_view_disable) 
a000			;	cp '*' 
a000				ld a,(debug_vector) 
a000				cp $c9   ; ret 
a000				jr z, .ispskip 
a000			 
a000				call clear_display 
a000				call update_display 
a000				call delay1s 
a000				ld de, (cli_origptr) 
a000				ld a, display_row_1 
a000				call str_at_display 
a000				 
a000				ld de, .enddict 
a000				ld a, display_row_3 
a000				call str_at_display 
a000				call update_display 
a000				ld a, 100 
a000				call aDelayInMS 
a000				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a000				call delay1s 
a000				call delay1s 
a000				call delay1s 
a000				endif 
a000			.ispskip:  
a000				 
a000			endif	 
a000			 
a000			 
a000			 
a000				; if the word is not a keyword then must be a literal so push it to stack 
a000			 
a000			; push token to stack to end of word 
a000			 
a000				STACKFRAME ON $1efe $2f9f 
a000				if DEBUG_STACK_IMB 
a000					if ON 
a000						exx 
a000						ld de, $1efe 
a000						ld a, d 
a000						ld hl, curframe 
a000						call hexout 
a000						ld a, e 
a000						ld hl, curframe+2 
a000						call hexout 
a000						ld hl, $1efe 
a000						push hl 
a000						ld hl, $2f9f 
a000						push hl 
a000						exx 
a000					endif 
a000				endif 
a000			endm 
# End of macro STACKFRAME
a000			 
a000 2a c2 e5		ld hl,(os_tok_ptr) 
a003 cd b4 9c		call forth_apush 
a006			 
a006				STACKFRAMECHK ON $1efe $2f9f 
a006				if DEBUG_STACK_IMB 
a006					if ON 
a006						exx 
a006						ld hl, $2f9f 
a006						pop de   ; $2f9f 
a006						call cmp16 
a006						jr nz, .spnosame 
a006						ld hl, $1efe 
a006						pop de   ; $1efe 
a006						call cmp16 
a006						jr z, .spfrsame 
a006						.spnosame: call showsperror 
a006						.spfrsame: nop 
a006						exx 
a006					endif 
a006				endif 
a006			endm 
# End of macro STACKFRAMECHK
a006			 
a006			execnext: 
a006			 
a006			if DEBUG_FORTH_PARSE_KEY 
a006						DMARK "KY>" 
a006			endif 
a006			; move past token to next word 
a006			 
a006 2a c2 e5		ld hl, (os_tok_ptr) 
a009 3e 00		ld a, 0 
a00b 01 ff 00		ld bc, 255     ; input buffer size 
a00e ed b1		cpir 
a010			 
a010			if DEBUG_FORTH_PARSE_KEY 
a010						DMARK "KY!" 
a010				CALLMONITOR 
a010			endif	 
a010			; TODO this might place hl on the null, so will need to forward on??? 
a010			;inc hl   ; see if this gets onto the next item 
a010			 
a010			 
a010			; TODO pass a pointer to the buffer to push 
a010			; TODO call function to push 
a010			 
a010			; look for end of input 
a010			 
a010			;inc hl 
a010			;ld a,(hl) 
a010			;cp FORTH_END_BUFFER 
a010			;ret z 
a010			 
a010			 
a010 c3 89 9f		jp exec1 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			findnexttok: 
a013			 
a013				; hl is pointer to move 
a013				; de is the token to locate 
a013			 
a013					if DEBUG_FORTH 
a013						DMARK "NTK" 
a013						CALLMONITOR 
a013					endif 
a013 d5				push de 
a014			 
a014			.fnt1:	 
a014				; find first char of token to locate 
a014			 
a014 1a				ld a, (de) 
a015 4f				ld c,a 
a016 7e				ld a,(hl) 
a017 cd 31 91			call toUpper 
a01a					if DEBUG_FORTH 
a01a						DMARK "NT1" 
a01a						CALLMONITOR 
a01a					endif 
a01a b9				cp c 
a01b			 
a01b 28 03			jr z, .fnt2cmpmorefirst	 
a01d			 
a01d				; first char not found move to next char 
a01d			 
a01d 23				inc hl 
a01e 18 f4			jr .fnt1 
a020			 
a020			.fnt2cmpmorefirst:	 
a020				; first char of token found.  
a020			 
a020 e5				push hl     ; save start of token just in case it is the right one 
a021 d9				exx 
a022 e1				pop hl        ; save it to hl' 
a023 d9				exx 
a024			 
a024			 
a024			.fnt2cmpmore:	 
a024				; compare the rest 
a024				 
a024 23				inc hl 
a025 13				inc de 
a026				 
a026 1a				ld a, (de) 
a027 4f				ld c,a 
a028 7e				ld a,(hl) 
a029 cd 31 91			call toUpper 
a02c			 
a02c					if DEBUG_FORTH 
a02c						DMARK "NT2" 
a02c						CALLMONITOR 
a02c					endif 
a02c				; c has the token to find char 
a02c				; a has the mem to scan char 
a02c			 
a02c b9				cp c 
a02d 28 04			jr z,.fntmatch1 
a02f			 
a02f				; they are not the same 
a02f			 
a02f					if DEBUG_FORTH 
a02f						DMARK "NT3" 
a02f						CALLMONITOR 
a02f					endif 
a02f d1				pop de	; reset de token to look for 
a030 d5				push de 
a031 18 e1			jr .fnt1 
a033				 
a033			.fntmatch1: 
a033			 
a033				; is the same char a null which means we might have a full hit? 
a033					if DEBUG_FORTH 
a033						DMARK "NT4" 
a033						CALLMONITOR 
a033					endif 
a033			 
a033 fe 00			cp 0 
a035 28 0b			jr z, .fntmatchyes 
a037			 
a037				; are we at the end of the token to find? 
a037			 
a037					if DEBUG_FORTH 
a037						DMARK "NT5" 
a037						CALLMONITOR 
a037					endif 
a037 3e 00			ld a, 0 
a039 b9				cp c 
a03a			 
a03a c2 24 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a03d			 
a03d					if DEBUG_FORTH 
a03d						DMARK "NT6" 
a03d						CALLMONITOR 
a03d					endif 
a03d				; token to find is exhusted but no match to stream 
a03d			 
a03d				; restore tok pointer and continue on 
a03d d1				pop de 
a03e d5				push de 
a03f c3 14 a0			jp .fnt1 
a042			 
a042			 
a042			.fntmatchyes: 
a042			 
a042				; hl now contains the end of the found token 
a042			 
a042				; get rid of saved token pointer to find 
a042			 
a042 d1				pop de 
a043			 
a043					if DEBUG_FORTH 
a043						DMARK "NT9" 
a043						CALLMONITOR 
a043					endif 
a043			 
a043				; hl will be on the null term so forward on 
a043			 
a043				; get back the saved start of the token 
a043			 
a043 d9				exx 
a044 e5				push hl     ; save start of token just in case it is the right one 
a045 d9				exx 
a046 e1				pop hl        ; save it to hl 
a047			 
a047 c9				ret 
a048			 
a048			 
a048			; LIST needs to find a specific token   
a048			; FORGET needs to find a spefici token 
a048			 
a048			; SAVE needs to find all tokens by flag 
a048			; WORDS just needs to scan through all  by flag 
a048			; UWORDS needs to scan through all by flag 
a048			 
a048			 
a048			; given hl as pointer to start of dict look up string 
a048			; return hl as pointer to start of word block 
a048			; or 0 if not found 
a048			 
a048			forth_find_tok: 
a048 c9				ret 
a049			 
a049			; given hl as pointer to dict structure 
a049			; move to the next dict block structure 
a049			 
a049			forth_tok_next: 
a049				; hl now points to the address of the next word pointer  
a049				; TODO skip compiled symbol for now 
a049			;	push de 
a049 23				inc hl 
a04a 5e				ld e, (hl) 
a04b 23				inc hl 
a04c 56				ld d, (hl) 
a04d 23				inc hl 
a04e			 
a04e eb				ex de,hl 
a04f			if DEBUG_FORTH_PARSE_NEXTWORD 
a04f				push bc 
a04f				ld bc, (cli_nextword) 
a04f						DMARK "NXW" 
a04f				CALLMONITOR 
a04f				pop bc 
a04f			endif 
a04f			;	pop de	 
a04f c9				ret 
a050			 
a050			 
a050			 
a050			; eof 
# End of file forth_parserv5.asm
a050				include "forth_wordsv4.asm" 
a050			 
a050			; the core word dictionary v4 
a050			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a050			 
a050			; this is a linked list for each of the system words used 
a050			; user defined words will follow the same format but will be in ram 
a050			 
a050			 
a050			; 
a050			; 
a050			; define linked list: 
a050			; 
a050			; 1. compiled byte op code 
a050			; 2. len of text word 
a050			; 3. text word 
a050			; 4. ptr to next dictionary word 
a050			; 5. asm, calls etc for the word 
a050			; 
a050			;  if 1 == 0 then last word in dict  
a050			;   
a050			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a050			;  
a050			;  
a050			; create basic standard set of words 
a050			; 
a050			;  
a050			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a050			; 2DUP 2DROP 2SWAP  
a050			; @ C@ - get byte  
a050			; ! C! - store byte 
a050			; 0< true if less than zero 
a050			; 0= true if zero 
a050			; < >  
a050			; = true if same 
a050			; variables 
a050			 
a050			 
a050			; Hardware specific words I may need 
a050			; 
a050			; IN OUT  
a050			; calls to key util functions 
a050			; calls to hardward abstraction stuff 
a050			; easy control of frame buffers and lcd i/o 
a050			; keyboard  
a050			 
a050			 
a050			;DICT: macro 
a050			; op_code, len, word, next 
a050			;    word: 
a050			;    db op_code 
a050			;    ds word zero term 
a050			;    dw next 
a050			;    endm 
a050			 
a050			 
a050			 
a050			 
a050			; op code 1 is a flag for user define words which are to be handled differently 
a050			 
a050			 
a050			; 
a050			; 
a050			;    TODO on entry to a word this should be the expected environment 
a050			;    hl - tos value if number then held, if string this is the ptr 
a050			;    de -  
a050			 
a050			 
a050			; opcode ranges 
a050			; 0 - end of word dict 
a050			; 255 - user define words 
a050			 
a050			sysdict: 
a050			include "forth_opcodes.asm" 
a050			; op codes for forth keywords 
a050			; free to use code 0  
a050				OPCODE_HEAP: equ  1 
a050				OPCODE_EXEC: equ 2 
a050				OPCODE_DUP: equ 3 
a050				OPCODE_SWAP: equ 4 
a050				OPCODE_COLN: equ 5 
a050				OPCODE_SCOLN: equ 6 
a050				OPCODE_DROP: equ 7 
a050				OPCODE_DUP2: equ 8 
a050				OPCODE_DROP2: equ 9 
a050				OPCODE_SWAP2: equ 10 
a050				OPCODE_AT: equ 11 
a050				OPCODE_CAT: equ 12 
a050				OPCODE_BANG: equ 13 
a050				OPCODE_CBANG: equ 14 
a050				OPCODE_SCALL: equ 15 
a050				OPCODE_DEPTH: equ 16 
a050				OPCODE_OVER: equ 17 
a050				OPCODE_PAUSE: equ 18 
a050				OPCODE_PAUSES: equ 19 
a050				OPCODE_ROT: equ 20 
a050			;free to reuse	OPCODE_WORDS: equ 21 
a050			        OPCODE_NOT: equ 21 
a050				OPCODE_UWORDS: equ 22 
a050				OPCODE_BP: equ 23 
a050				OPCODE_MONITOR: equ 24  
a050				OPCODE_MALLOC: equ 25 
a050				OPCODE_FREE: equ 26 
a050				OPCODE_LIST: equ 27 
a050				OPCODE_FORGET: equ 28 
a050				OPCODE_NOP: equ 29 
a050				OPCODE_COMO: equ 30 
a050				OPCODE_COMC: equ 31 
a050			;free to reuse	OPCODE_ENDCORE: equ 32 
a050				OPCODE_AFTERSOUND: equ 33 
a050				OPCODE_GP2: equ 34 
a050				OPCODE_GP3: equ 35 
a050				OPCODE_GP4: equ 36 
a050				OPCODE_SIN: equ 37 
a050				OPCODE_SOUT: equ 38 
a050				OPCODE_SPIO: equ 39 
a050				OPCODE_SPICEH: equ 40 
a050				OPCODE_SPIOb: equ 41 
a050				OPCODE_SPII: equ 42 
a050				OPCODE_SESEL: equ 43 
a050				OPCODE_CARTDEV: equ 44 
a050			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a050				OPCODE_FB: equ 46 
a050				OPCODE_EMIT: equ 47 
a050				OPCODE_DOTH: equ 48 
a050				OPCODE_DOTF: equ 49 
a050				OPCODE_DOT: equ 50 
a050				OPCODE_CLS: equ 51 
a050				OPCODE_DRAW: equ 52 
a050				OPCODE_DUMP: equ 53 
a050				OPCODE_CDUMP: equ 54 
a050				OPCODE_DAT: equ 55 
a050				OPCODE_HOME: equ 56 
a050				OPCODE_SPACE: equ 57 
a050				OPCODE_SPACES: equ 58 
a050				OPCODE_SCROLL: equ 59 
a050				OPCODE_ATQ: equ 60 
a050				OPCODE_AUTODSP: equ 61 
a050				OPCODE_MENU: equ 62 
a050			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a050				OPCODE_THEN: equ 64 
a050				OPCODE_ELSE: equ 65 
a050				OPCODE_DO: equ 66 
a050				OPCODE_LOOP: equ 67 
a050				OPCODE_I: equ 68 
a050				OPCODE_DLOOP: equ 69  
a050				OPCODE_REPEAT: equ 70  
a050				OPCODE_UNTIL: equ 71 
a050				OPCODE_ENDFLOW: equ 72 
a050				OPCODE_WAITK: equ 73 
a050				OPCODE_ACCEPT: equ 74 
a050				OPCODE_EDIT: equ 75 
a050			;free to reuse	OPCODE_ENDKEY: equ 76 
a050				OPCODE_LZERO: equ 77 
a050				OPCODE_TZERO: equ 78 
a050				OPCODE_LESS: equ 79 
a050				OPCODE_GT: equ 80 
a050				OPCODE_EQUAL: equ 81  
a050			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a050				OPCODE_NEG: equ 83 
a050				OPCODE_DIV: equ 84 
a050				OPCODE_MUL: equ 85 
a050				OPCODE_MIN: equ 86 
a050				OPCODE_MAX: equ 87 
a050				OPCODE_RND16: equ 88 
a050				OPCODE_RND8: equ 89 
a050				OPCODE_RND: equ 90 
a050			;free to reuse	OPCODE_ENDMATHS: equ 91  
a050				OPCODE_BYNAME: equ 92 
a050				OPCODE_DIR: equ 93 
a050				OPCODE_SAVE: equ 94 
a050				OPCODE_LOAD: equ 95 
a050				OPCODE_BSAVE: equ 96 
a050				OPCODE_BLOAD: equ 97 
a050				OPCODE_SEO: equ 98  
a050				OPCODE_SEI: equ 99 
a050				OPCODE_SFREE: equ 100 
a050				OPCODE_SIZE: equ 101 
a050				OPCODE_CREATE: equ 102 
a050				OPCODE_APPEND: equ 103 
a050				OPCODE_SDEL: equ 104 
a050				OPCODE_OPEN: equ 105 
a050				OPCODE_READ: equ 106 
a050				OPCODE_EOF: equ 106 
a050				OPCODE_FORMAT: equ 107 
a050				OPCODE_LABEL: equ 108 
a050				OPCODE_LABELS: equ 109 
a050			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a050				OPCODE_UPPER: equ 111 
a050				OPCODE_LOWER: equ 112 
a050				OPCODE_SUBSTR: equ 113 
a050				OPCODE_LEFT: equ 114 
a050				OPCODE_RIGHT: equ 115 
a050				OPCODE_STR2NUM: equ 116 
a050				OPCODE_NUM2STR: equ 117 
a050				OPCODE_CONCAT: equ 118 
a050				OPCODE_FIND: equ 119 
a050				OPCODE_LEN: equ 120 
a050				OPCODE_CHAR: equ 121 
a050			; free to reuse	OPCODE_STRLEN: equ 122 
a050			; free to reuse	OPCODE_ENDSTR: equ 123 
a050				OPCODE_V0S: equ 124 
a050				OPCODE_V0Q: equ 125 
a050				OPCODE_V1S: equ 126 
a050				OPCODE_V1Q: equ 127 
a050				OPCODE_V2S: equ 128 
a050				OPCODE_V2Q: equ 129 
a050				OPCODE_V3S: equ 130 
a050				OPCODE_V3Q: equ 131 
a050			;free to reuse	OPCODE_END: equ 132 
a050				OPCODE_ZDUP: equ 133 
a050			 
a050			; eof 
# End of file forth_opcodes.asm
a050			 
a050			include "forth_words_core.asm" 
a050			 
a050			; | ## Core Words 
a050			 
a050			;if MALLOC_4 
a050			 
a050			.HEAP: 
a050				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a050 15				db WORD_SYS_CORE+OPCODE_HEAP             
a051 8f a0			dw .EXEC            
a053 05				db 4 + 1 
a054 .. 00			db "HEAP",0              
a059				endm 
# End of macro CWHEAD
a059			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a059			; | | u1 - Current number of bytes in the heap 
a059			; | | u2 - Remaining bytes left on the heap 
a059			; | |  
a059			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a059			 
a059			 
a059					if DEBUG_FORTH_WORDS_KEY 
a059						DMARK "HEP" 
a059 f5				push af  
a05a 3a 6e a0			ld a, (.dmark)  
a05d 32 6b ee			ld (debug_mark),a  
a060 3a 6f a0			ld a, (.dmark+1)  
a063 32 6c ee			ld (debug_mark+1),a  
a066 3a 70 a0			ld a, (.dmark+2)  
a069 32 6d ee			ld (debug_mark+2),a  
a06c 18 03			jr .pastdmark  
a06e ..			.dmark: db "HEP"  
a071 f1			.pastdmark: pop af  
a072			endm  
# End of macro DMARK
a072						CALLMONITOR 
a072 cd 6f ee			call debug_vector  
a075				endm  
# End of macro CALLMONITOR
a075					endif 
a075 2a 47 e4				ld hl, (free_list )      
a078 11 4c e4				ld de, heap_start 
a07b			 
a07b ed 52				sbc hl, de  
a07d			 
a07d cd 4b 9b				call forth_push_numhl 
a080			 
a080			 
a080 ed 5b 47 e4			ld de, (free_list )      
a084 21 a8 e2				ld hl, heap_end 
a087			 
a087 ed 52				sbc hl, de 
a089			 
a089 cd 4b 9b				call forth_push_numhl 
a08c					 
a08c			 
a08c					 
a08c			 
a08c			 
a08c			 
a08c					NEXTW 
a08c c3 f8 9e			jp macro_next 
a08f				endm 
# End of macro NEXTW
a08f			;endif 
a08f			 
a08f			.EXEC: 
a08f			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a08f			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a08f			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a08f			;; > > 
a08f			;; > >   
a08f			;	STACKFRAME OFF $5efe $5f9f 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS_KEY 
a08f			;			DMARK "EXE" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	FORTH_DSP_VALUEHL 
a08f			; 
a08f			;	FORTH_DSP_POP 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX1" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;;	ld e,(hl) 
a08f			;;	inc hl 
a08f			;;	ld d,(hl) 
a08f			;;	ex de,hl 
a08f			; 
a08f			;;		if DEBUG_FORTH_WORDS 
a08f			;;			DMARK "EX2" 
a08f			;;			CALLMONITOR 
a08f			;;		endif 
a08f			;	push hl 
a08f			; 
a08f			;	;ld a, 0 
a08f			;	;ld a, FORTH_END_BUFFER 
a08f			;	call strlenz 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	inc hl   ; include term 
a08f			;	inc hl   ; include term 
a08f			;	ld b,0 
a08f			;	ld c,l 
a08f			;	pop hl 
a08f			;	ld de, execscratch 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX3" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ldir 
a08f			; 
a08f			; 
a08f			;	ld hl, execscratch 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXe" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	call forthparse 
a08f			;	call forthexec 
a08f			;;	call forthexec_cleanup 
a08f			;;	call forthparse 
a08f			;;	call forthexec 
a08f			; 
a08f			;	STACKFRAMECHK OFF $5efe $5f9f 
a08f			; 
a08f			;	; an immediate word so no need to process any more words 
a08f			;	ret 
a08f			;	NEXTW 
a08f			 
a08f			; dead code - old version  
a08f			;	FORTH_RSP_NEXT 
a08f			 
a08f			;  
a08f			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a08f			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a08f			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a08f			;	push hl 
a08f			;	push de 
a08f			;	push bc 
a08f			; 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS_KEY 
a08f			;			DMARK "EXR" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			; 
a08f			; 
a08f			;	;v5 FORTH_DSP_VALUE 
a08f			;	FORTH_DSP_VALUEHL 
a08f			; 
a08f			;	; TODO do string type checks 
a08f			; 
a08f			;;v5	inc hl   ; skip type 
a08f			; 
a08f			;	push hl  ; source code  
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX1" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ld a, 0 
a08f			;	call strlent 
a08f			; 
a08f			;	inc hl 
a08f			;	inc hl 
a08f			;	inc hl 
a08f			;	inc hl 
a08f			; 
a08f			;	push hl    ; size 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX2" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	call malloc 
a08f			; 
a08f			;	ex de, hl    ; de now contains malloc area 
a08f			;	pop bc   	; get byte count 
a08f			;	pop hl      ; get string to copy 
a08f			; 
a08f			;	push de     ; save malloc for free later 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX3" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ldir       ; duplicate string 
a08f			; 
a08f			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a08f			;	 
a08f			;	; TODO fix the parse would be better than this...  
a08f			;	ex de, hl 
a08f			;	dec hl 
a08f			;	ld a, 0 
a08f			;	ld (hl), a 
a08f			;	dec hl 
a08f			;	ld a, ' ' 
a08f			;	ld (hl), a 
a08f			;	dec hl 
a08f			;	ld (hl), a 
a08f			; 
a08f			;	dec hl 
a08f			;	ld (hl), a 
a08f			; 
a08f			; 
a08f			;	FORTH_DSP_POP  
a08f			; 
a08f			;	pop hl     
a08f			;	push hl    ; save malloc area 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX4" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	call forthparse 
a08f			;	call forthexec 
a08f			;	 
a08f			;	pop hl 
a08f			;	if DEBUG_FORTH_WORDS 
a08f			;		DMARK "EX5" 
a08f			;		CALLMONITOR 
a08f			;	endif 
a08f			; 
a08f			;	if FORTH_ENABLE_FREE 
a08f			;	call free 
a08f			;	endif 
a08f			; 
a08f			;	if DEBUG_FORTH_WORDS 
a08f			;		DMARK "EX6" 
a08f			;		CALLMONITOR 
a08f			;	endif 
a08f			; 
a08f			;	pop bc 
a08f			;	pop de 
a08f			;	pop hl 
a08f			;;	FORTH_RSP_POP	  
a08f			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a08f			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a08f			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a08f			; 
a08f			;	if DEBUG_FORTH_WORDS 
a08f			;		DMARK "EX7" 
a08f			;		CALLMONITOR 
a08f			;	endif 
a08f			;	NEXTW 
a08f			 
a08f			;.STKEXEC: 
a08f			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a08f			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a08f			; 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS_KEY 
a08f			;			DMARK "STX" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	FORTH_DSP_VALUEHL 
a08f			; 
a08f			;	ld (store_tmp1), hl    ; count 
a08f			; 
a08f			;	FORTH_DSP_POP 
a08f			;.stkexec1: 
a08f			;	ld hl, (store_tmp1)   ; count 
a08f			;	ld a, 0 
a08f			;	cp l 
a08f			;	ret z 
a08f			; 
a08f			;	dec hl 
a08f			;	ld (store_tmp1), hl    ; count 
a08f			;	 
a08f			;	FORTH_DSP_VALUEHL 
a08f			;	push hl 
a08f			;	 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXp" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	FORTH_DSP_POP 
a08f			; 
a08f			;	call strlenz 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	ld b,0 
a08f			;	ld c,l 
a08f			;	pop hl 
a08f			;	ld de, execscratch 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX3" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ldir 
a08f			; 
a08f			; 
a08f			;	ld hl, execscratch 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXP" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	call forthparse 
a08f			;	ld hl, execscratch 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXx" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	call forthexec 
a08f			; 
a08f			;	jp .stkexec1 
a08f			; 
a08f			;	ret 
a08f			 
a08f			 
a08f			.DUP: 
a08f				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a08f 17				db WORD_SYS_CORE+OPCODE_DUP             
a090 05 a1			dw .ZDUP            
a092 04				db 3 + 1 
a093 .. 00			db "DUP",0              
a097				endm 
# End of macro CWHEAD
a097			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a097			 
a097					if DEBUG_FORTH_WORDS_KEY 
a097						DMARK "DUP" 
a097 f5				push af  
a098 3a ac a0			ld a, (.dmark)  
a09b 32 6b ee			ld (debug_mark),a  
a09e 3a ad a0			ld a, (.dmark+1)  
a0a1 32 6c ee			ld (debug_mark+1),a  
a0a4 3a ae a0			ld a, (.dmark+2)  
a0a7 32 6d ee			ld (debug_mark+2),a  
a0aa 18 03			jr .pastdmark  
a0ac ..			.dmark: db "DUP"  
a0af f1			.pastdmark: pop af  
a0b0			endm  
# End of macro DMARK
a0b0						CALLMONITOR 
a0b0 cd 6f ee			call debug_vector  
a0b3				endm  
# End of macro CALLMONITOR
a0b3					endif 
a0b3			 
a0b3					FORTH_DSP 
a0b3 cd 08 9d			call macro_forth_dsp 
a0b6				endm 
# End of macro FORTH_DSP
a0b6			 
a0b6 7e					ld a, (HL) 
a0b7 fe 01				cp DS_TYPE_STR 
a0b9 20 25				jr nz, .dupinum 
a0bb			 
a0bb					; push another string 
a0bb			 
a0bb					FORTH_DSP_VALUEHL     		 
a0bb cd 42 9d			call macro_dsp_valuehl 
a0be				endm 
# End of macro FORTH_DSP_VALUEHL
a0be			 
a0be				if DEBUG_FORTH_WORDS 
a0be					DMARK "DUs" 
a0be f5				push af  
a0bf 3a d3 a0			ld a, (.dmark)  
a0c2 32 6b ee			ld (debug_mark),a  
a0c5 3a d4 a0			ld a, (.dmark+1)  
a0c8 32 6c ee			ld (debug_mark+1),a  
a0cb 3a d5 a0			ld a, (.dmark+2)  
a0ce 32 6d ee			ld (debug_mark+2),a  
a0d1 18 03			jr .pastdmark  
a0d3 ..			.dmark: db "DUs"  
a0d6 f1			.pastdmark: pop af  
a0d7			endm  
# End of macro DMARK
a0d7					CALLMONITOR 
a0d7 cd 6f ee			call debug_vector  
a0da				endm  
# End of macro CALLMONITOR
a0da				endif 
a0da cd b9 9b				call forth_push_str 
a0dd			 
a0dd					NEXTW 
a0dd c3 f8 9e			jp macro_next 
a0e0				endm 
# End of macro NEXTW
a0e0			 
a0e0			 
a0e0			.dupinum: 
a0e0					 
a0e0			 
a0e0			 
a0e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0e0 cd 42 9d			call macro_dsp_valuehl 
a0e3				endm 
# End of macro FORTH_DSP_VALUEHL
a0e3			 
a0e3				; TODO add floating point number detection 
a0e3			 
a0e3				if DEBUG_FORTH_WORDS 
a0e3					DMARK "DUi" 
a0e3 f5				push af  
a0e4 3a f8 a0			ld a, (.dmark)  
a0e7 32 6b ee			ld (debug_mark),a  
a0ea 3a f9 a0			ld a, (.dmark+1)  
a0ed 32 6c ee			ld (debug_mark+1),a  
a0f0 3a fa a0			ld a, (.dmark+2)  
a0f3 32 6d ee			ld (debug_mark+2),a  
a0f6 18 03			jr .pastdmark  
a0f8 ..			.dmark: db "DUi"  
a0fb f1			.pastdmark: pop af  
a0fc			endm  
# End of macro DMARK
a0fc					CALLMONITOR 
a0fc cd 6f ee			call debug_vector  
a0ff				endm  
# End of macro CALLMONITOR
a0ff				endif 
a0ff			 
a0ff cd 4b 9b				call forth_push_numhl 
a102					NEXTW 
a102 c3 f8 9e			jp macro_next 
a105				endm 
# End of macro NEXTW
a105			.ZDUP: 
a105				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a105 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a106 3d a1			dw .SWAP            
a108 05				db 4 + 1 
a109 .. 00			db "?DUP",0              
a10e				endm 
# End of macro CWHEAD
a10e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a10e			 
a10e					if DEBUG_FORTH_WORDS_KEY 
a10e						DMARK "qDU" 
a10e f5				push af  
a10f 3a 23 a1			ld a, (.dmark)  
a112 32 6b ee			ld (debug_mark),a  
a115 3a 24 a1			ld a, (.dmark+1)  
a118 32 6c ee			ld (debug_mark+1),a  
a11b 3a 25 a1			ld a, (.dmark+2)  
a11e 32 6d ee			ld (debug_mark+2),a  
a121 18 03			jr .pastdmark  
a123 ..			.dmark: db "qDU"  
a126 f1			.pastdmark: pop af  
a127			endm  
# End of macro DMARK
a127						CALLMONITOR 
a127 cd 6f ee			call debug_vector  
a12a				endm  
# End of macro CALLMONITOR
a12a					endif 
a12a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a12a cd 42 9d			call macro_dsp_valuehl 
a12d				endm 
# End of macro FORTH_DSP_VALUEHL
a12d			 
a12d e5					push hl 
a12e			 
a12e					; is it a zero? 
a12e			 
a12e 3e 00				ld a, 0 
a130 84					add h 
a131 85					add l 
a132			 
a132 e1					pop hl 
a133			 
a133 fe 00				cp 0 
a135 28 03				jr z, .dup2orig 
a137			 
a137			 
a137 cd 4b 9b				call forth_push_numhl 
a13a			 
a13a			 
a13a				; TODO add floating point number detection 
a13a			 
a13a			.dup2orig: 
a13a			 
a13a					NEXTW 
a13a c3 f8 9e			jp macro_next 
a13d				endm 
# End of macro NEXTW
a13d			.SWAP: 
a13d				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a13d 18				db WORD_SYS_CORE+OPCODE_SWAP             
a13e 7c a1			dw .COLN            
a140 05				db 4 + 1 
a141 .. 00			db "SWAP",0              
a146				endm 
# End of macro CWHEAD
a146			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a146					if DEBUG_FORTH_WORDS_KEY 
a146						DMARK "SWP" 
a146 f5				push af  
a147 3a 5b a1			ld a, (.dmark)  
a14a 32 6b ee			ld (debug_mark),a  
a14d 3a 5c a1			ld a, (.dmark+1)  
a150 32 6c ee			ld (debug_mark+1),a  
a153 3a 5d a1			ld a, (.dmark+2)  
a156 32 6d ee			ld (debug_mark+2),a  
a159 18 03			jr .pastdmark  
a15b ..			.dmark: db "SWP"  
a15e f1			.pastdmark: pop af  
a15f			endm  
# End of macro DMARK
a15f						CALLMONITOR 
a15f cd 6f ee			call debug_vector  
a162				endm  
# End of macro CALLMONITOR
a162					endif 
a162			 
a162					FORTH_DSP_VALUEHL 
a162 cd 42 9d			call macro_dsp_valuehl 
a165				endm 
# End of macro FORTH_DSP_VALUEHL
a165 e5					push hl     ; w2 
a166			 
a166					FORTH_DSP_POP 
a166 cd fa 9d			call macro_forth_dsp_pop 
a169				endm 
# End of macro FORTH_DSP_POP
a169			 
a169					FORTH_DSP_VALUEHL 
a169 cd 42 9d			call macro_dsp_valuehl 
a16c				endm 
# End of macro FORTH_DSP_VALUEHL
a16c			 
a16c					FORTH_DSP_POP 
a16c cd fa 9d			call macro_forth_dsp_pop 
a16f				endm 
# End of macro FORTH_DSP_POP
a16f			 
a16f d1					pop de     ; w2	, hl = w1 
a170			 
a170 eb					ex de, hl 
a171 d5					push de 
a172			 
a172 cd 4b 9b				call forth_push_numhl 
a175			 
a175 e1					pop hl 
a176			 
a176 cd 4b 9b				call forth_push_numhl 
a179					 
a179			 
a179					NEXTW 
a179 c3 f8 9e			jp macro_next 
a17c				endm 
# End of macro NEXTW
a17c			.COLN: 
a17c				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a17c 19				db WORD_SYS_CORE+OPCODE_COLN             
a17d 08 a3			dw .SCOLN            
a17f 02				db 1 + 1 
a180 .. 00			db ":",0              
a182				endm 
# End of macro CWHEAD
a182			; | : ( -- )         Create new word | DONE 
a182			 
a182					if DEBUG_FORTH_WORDS_KEY 
a182						DMARK "CLN" 
a182 f5				push af  
a183 3a 97 a1			ld a, (.dmark)  
a186 32 6b ee			ld (debug_mark),a  
a189 3a 98 a1			ld a, (.dmark+1)  
a18c 32 6c ee			ld (debug_mark+1),a  
a18f 3a 99 a1			ld a, (.dmark+2)  
a192 32 6d ee			ld (debug_mark+2),a  
a195 18 03			jr .pastdmark  
a197 ..			.dmark: db "CLN"  
a19a f1			.pastdmark: pop af  
a19b			endm  
# End of macro DMARK
a19b						CALLMONITOR 
a19b cd 6f ee			call debug_vector  
a19e				endm  
# End of macro CALLMONITOR
a19e					endif 
a19e				STACKFRAME OFF $8efe $989f 
a19e				if DEBUG_STACK_IMB 
a19e					if OFF 
a19e						exx 
a19e						ld de, $8efe 
a19e						ld a, d 
a19e						ld hl, curframe 
a19e						call hexout 
a19e						ld a, e 
a19e						ld hl, curframe+2 
a19e						call hexout 
a19e						ld hl, $8efe 
a19e						push hl 
a19e						ld hl, $989f 
a19e						push hl 
a19e						exx 
a19e					endif 
a19e				endif 
a19e			endm 
# End of macro STACKFRAME
a19e				; get parser buffer length  of new word 
a19e			 
a19e				 
a19e			 
a19e					; move tok past this to start of name defintition 
a19e					; TODO get word to define 
a19e					; TODO Move past word token 
a19e					; TODO get length of string up to the ';' 
a19e			 
a19e 2a c2 e5			ld hl, (os_tok_ptr) 
a1a1 23				inc hl 
a1a2 23				inc hl 
a1a3			 
a1a3 3e 3b			ld a, ';' 
a1a5 cd 45 91			call strlent 
a1a8			 
a1a8 7d				ld a,l 
a1a9 32 bd e2			ld (os_new_parse_len), a 
a1ac			 
a1ac			 
a1ac			if DEBUG_FORTH_UWORD 
a1ac ed 5b c2 e5		ld de, (os_tok_ptr) 
a1b0						DMARK ":01" 
a1b0 f5				push af  
a1b1 3a c5 a1			ld a, (.dmark)  
a1b4 32 6b ee			ld (debug_mark),a  
a1b7 3a c6 a1			ld a, (.dmark+1)  
a1ba 32 6c ee			ld (debug_mark+1),a  
a1bd 3a c7 a1			ld a, (.dmark+2)  
a1c0 32 6d ee			ld (debug_mark+2),a  
a1c3 18 03			jr .pastdmark  
a1c5 ..			.dmark: db ":01"  
a1c8 f1			.pastdmark: pop af  
a1c9			endm  
# End of macro DMARK
a1c9				CALLMONITOR 
a1c9 cd 6f ee			call debug_vector  
a1cc				endm  
# End of macro CALLMONITOR
a1cc			endif 
a1cc			 
a1cc			; 
a1cc			;  new word memory layout: 
a1cc			;  
a1cc			;    : adg 6666 ;  
a1cc			; 
a1cc			;    db   1     ; user defined word  
a1cc 23				inc hl    
a1cd			;    dw   sysdict 
a1cd 23				inc hl 
a1ce 23				inc hl 
a1cf			;    db <word len>+1 (for null) 
a1cf 23				inc hl 
a1d0			;    db .... <word> 
a1d0			; 
a1d0			 
a1d0 23				inc hl    ; some extras for the word preamble before the above 
a1d1 23				inc hl 
a1d2 23				inc hl 
a1d3 23				inc hl 
a1d4 23				inc hl 
a1d5 23				inc hl 
a1d6 23				inc hl  
a1d7 23				inc hl 
a1d8 23				inc hl 
a1d9 23				inc hl 
a1da 23				inc hl 
a1db 23				inc hl 
a1dc 23				inc hl 
a1dd 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1de			;       exec word buffer 
a1de			;	<ptr word>   
a1de 23				inc hl 
a1df 23				inc hl 
a1e0			;       <word list><null term> 7F final term 
a1e0			 
a1e0			 
a1e0			if DEBUG_FORTH_UWORD 
a1e0						DMARK ":02" 
a1e0 f5				push af  
a1e1 3a f5 a1			ld a, (.dmark)  
a1e4 32 6b ee			ld (debug_mark),a  
a1e7 3a f6 a1			ld a, (.dmark+1)  
a1ea 32 6c ee			ld (debug_mark+1),a  
a1ed 3a f7 a1			ld a, (.dmark+2)  
a1f0 32 6d ee			ld (debug_mark+2),a  
a1f3 18 03			jr .pastdmark  
a1f5 ..			.dmark: db ":02"  
a1f8 f1			.pastdmark: pop af  
a1f9			endm  
# End of macro DMARK
a1f9				CALLMONITOR 
a1f9 cd 6f ee			call debug_vector  
a1fc				endm  
# End of macro CALLMONITOR
a1fc			endif 
a1fc			 
a1fc				 
a1fc					; malloc the size 
a1fc			 
a1fc cd a3 91				call malloc 
a1ff 22 bf e2				ld (os_new_malloc), hl     ; save malloc start 
a202			 
a202			;    db   1     ; user defined word  
a202 3e 01				ld a, WORD_SYS_UWORD  
a204 77					ld (hl), a 
a205				 
a205 23				inc hl    
a206			;    dw   sysdict 
a206 11 50 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a209 73				ld (hl), e 
a20a 23				inc hl 
a20b 72				ld (hl), d 
a20c 23				inc hl 
a20d			 
a20d			 
a20d			;    Setup dict word 
a20d			 
a20d 23				inc hl 
a20e 22 b9 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a211			 
a211				; 1. get length of dict word 
a211			 
a211			 
a211 2a c2 e5			ld hl, (os_tok_ptr) 
a214 23				inc hl 
a215 23				inc hl    ; position to start of dict word 
a216 3e 00			ld a, 0 
a218 cd 45 91			call strlent 
a21b			 
a21b			 
a21b 23				inc hl    ; to include null??? 
a21c			 
a21c				; write length of dict word 
a21c			 
a21c ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a220 1b				dec de 
a221 eb				ex de, hl 
a222 73				ld (hl), e 
a223 eb				ex de, hl 
a224			 
a224				 
a224			 
a224				; copy  
a224 4d				ld c, l 
a225 06 00			ld b, 0 
a227 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a22b 2a c2 e5			ld hl, (os_tok_ptr) 
a22e 23				inc hl 
a22f 23				inc hl    ; position to start of dict word 
a230				 
a230			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a230				 
a230				; TODO need to convert word to upper case 
a230			 
a230			ucasetok:	 
a230 7e				ld a,(hl) 
a231 cd 31 91			call toUpper 
a234 77				ld (hl),a 
a235 ed a0			ldi 
a237 f2 30 a2		 	jp p, ucasetok 
a23a			 
a23a			 
a23a			 
a23a				; de now points to start of where the word body code should be placed 
a23a ed 53 b9 e2		ld (os_new_work_ptr), de 
a23e				; hl now points to the words to throw at forthexec which needs to be copied 
a23e 22 b7 e2			ld (os_new_src_ptr), hl 
a241			 
a241				; TODO add 'call to forthexec' 
a241			 
a241			if DEBUG_FORTH_UWORD 
a241 c5				push bc 
a242 ed 4b bf e2		ld bc, (os_new_malloc) 
a246						DMARK ":0x" 
a246 f5				push af  
a247 3a 5b a2			ld a, (.dmark)  
a24a 32 6b ee			ld (debug_mark),a  
a24d 3a 5c a2			ld a, (.dmark+1)  
a250 32 6c ee			ld (debug_mark+1),a  
a253 3a 5d a2			ld a, (.dmark+2)  
a256 32 6d ee			ld (debug_mark+2),a  
a259 18 03			jr .pastdmark  
a25b ..			.dmark: db ":0x"  
a25e f1			.pastdmark: pop af  
a25f			endm  
# End of macro DMARK
a25f				CALLMONITOR 
a25f cd 6f ee			call debug_vector  
a262				endm  
# End of macro CALLMONITOR
a262 c1				pop bc 
a263			endif 
a263			 
a263			 
a263				; create word preamble which should be: 
a263			 
a263			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a263			 
a263				;    ld hl, <word code> 
a263				;    jp user_exec 
a263			        ;    <word code bytes> 
a263			 
a263			 
a263			;	inc de     ; TODO ??? or are we already past the word's null 
a263 eb				ex de, hl 
a264			 
a264 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a266			 
a266 23				inc hl 
a267 22 b3 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a26a 23				inc hl 
a26b			 
a26b 23				inc hl 
a26c 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a26e			 
a26e 01 65 cb			ld bc, user_exec 
a271 23				inc hl 
a272 71				ld (hl), c     ; poke address of user_exec 
a273 23				inc hl 
a274 70				ld (hl), b     
a275			 ; 
a275			;	inc hl 
a275			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a275			; 
a275			; 
a275			;	ld bc, macro_forth_rsp_next 
a275			;	inc hl 
a275			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a275			;	inc hl 
a275			;	ld (hl), b     
a275			 ; 
a275			;	inc hl 
a275			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a275			; 
a275			; 
a275			;	inc hl 
a275			;	ld bc, forthexec 
a275			;	ld (hl), c     ; poke address of forthexec 
a275			;	inc hl 
a275			;	ld (hl), b      
a275			; 
a275			;	inc hl 
a275			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a275			; 
a275			;	ld bc, user_dict_next 
a275			;	inc hl 
a275			;	ld (hl), c     ; poke address of forthexec 
a275			;	inc hl 
a275			;	ld (hl), b      
a275			 
a275				; hl is now where we need to copy the word byte data to save this 
a275			 
a275 23				inc hl 
a276 22 b5 e2			ld (os_new_exec), hl 
a279				 
a279				; copy definition 
a279			 
a279 eb				ex de, hl 
a27a			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a27a			;	inc de    ; skip the PC for this parse 
a27a 3a bd e2			ld a, (os_new_parse_len) 
a27d 4f				ld c, a 
a27e 06 00			ld b, 0 
a280 ed b0			ldir		 ; copy defintion 
a282			 
a282			 
a282				; poke the address of where the new word bytes live for forthexec 
a282			 
a282 2a b3 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a285			 
a285 ed 5b b5 e2		ld de, (os_new_exec)      
a289				 
a289 73				ld (hl), e 
a28a 23				inc hl 
a28b 72				ld (hl), d 
a28c			 
a28c					; TODO copy last user dict word next link to this word 
a28c					; TODO update last user dict word to point to this word 
a28c			; 
a28c			; hl f923 de 812a ; bc 811a 
a28c			 
a28c			if DEBUG_FORTH_UWORD 
a28c c5				push bc 
a28d ed 4b bf e2		ld bc, (os_new_malloc) 
a291						DMARK ":0A" 
a291 f5				push af  
a292 3a a6 a2			ld a, (.dmark)  
a295 32 6b ee			ld (debug_mark),a  
a298 3a a7 a2			ld a, (.dmark+1)  
a29b 32 6c ee			ld (debug_mark+1),a  
a29e 3a a8 a2			ld a, (.dmark+2)  
a2a1 32 6d ee			ld (debug_mark+2),a  
a2a4 18 03			jr .pastdmark  
a2a6 ..			.dmark: db ":0A"  
a2a9 f1			.pastdmark: pop af  
a2aa			endm  
# End of macro DMARK
a2aa				CALLMONITOR 
a2aa cd 6f ee			call debug_vector  
a2ad				endm  
# End of macro CALLMONITOR
a2ad c1				pop bc 
a2ae			endif 
a2ae			if DEBUG_FORTH_UWORD 
a2ae c5				push bc 
a2af ed 4b bf e2		ld bc, (os_new_malloc) 
a2b3 03				inc bc 
a2b4 03				inc bc 
a2b5 03				inc bc 
a2b6 03				inc bc 
a2b7 03				inc bc 
a2b8 03				inc bc 
a2b9 03				inc bc 
a2ba 03				inc bc 
a2bb			 
a2bb						DMARK ":0B" 
a2bb f5				push af  
a2bc 3a d0 a2			ld a, (.dmark)  
a2bf 32 6b ee			ld (debug_mark),a  
a2c2 3a d1 a2			ld a, (.dmark+1)  
a2c5 32 6c ee			ld (debug_mark+1),a  
a2c8 3a d2 a2			ld a, (.dmark+2)  
a2cb 32 6d ee			ld (debug_mark+2),a  
a2ce 18 03			jr .pastdmark  
a2d0 ..			.dmark: db ":0B"  
a2d3 f1			.pastdmark: pop af  
a2d4			endm  
# End of macro DMARK
a2d4				CALLMONITOR 
a2d4 cd 6f ee			call debug_vector  
a2d7				endm  
# End of macro CALLMONITOR
a2d7 c1				pop bc 
a2d8			endif 
a2d8			 
a2d8			; update word dict linked list for new word 
a2d8			 
a2d8			 
a2d8 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2db 23			inc hl     ; move to next work linked list ptr 
a2dc			 
a2dc ed 5b bf e2	ld de, (os_new_malloc)		 ; new next word 
a2e0 73			ld (hl), e 
a2e1 23			inc hl 
a2e2 72			ld (hl), d 
a2e3			 
a2e3			if DEBUG_FORTH_UWORD 
a2e3 ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2e7			endif 
a2e7			 
a2e7 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2eb			 
a2eb			 
a2eb			if DEBUG_FORTH_UWORD 
a2eb						DMARK ":0+" 
a2eb f5				push af  
a2ec 3a 00 a3			ld a, (.dmark)  
a2ef 32 6b ee			ld (debug_mark),a  
a2f2 3a 01 a3			ld a, (.dmark+1)  
a2f5 32 6c ee			ld (debug_mark+1),a  
a2f8 3a 02 a3			ld a, (.dmark+2)  
a2fb 32 6d ee			ld (debug_mark+2),a  
a2fe 18 03			jr .pastdmark  
a300 ..			.dmark: db ":0+"  
a303 f1			.pastdmark: pop af  
a304			endm  
# End of macro DMARK
a304				CALLMONITOR 
a304 cd 6f ee			call debug_vector  
a307				endm  
# End of macro CALLMONITOR
a307			endif 
a307			 
a307				STACKFRAMECHK OFF $8efe $989f 
a307				if DEBUG_STACK_IMB 
a307					if OFF 
a307						exx 
a307						ld hl, $989f 
a307						pop de   ; $989f 
a307						call cmp16 
a307						jr nz, .spnosame 
a307						ld hl, $8efe 
a307						pop de   ; $8efe 
a307						call cmp16 
a307						jr z, .spfrsame 
a307						.spnosame: call showsperror 
a307						.spfrsame: nop 
a307						exx 
a307					endif 
a307				endif 
a307			endm 
# End of macro STACKFRAMECHK
a307			 
a307 c9			ret    ; dont process any remaining parser tokens as they form new word 
a308			 
a308			 
a308			 
a308			 
a308			;		NEXT 
a308			.SCOLN: 
a308			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a308 06				db OPCODE_SCOLN 
a309 54 a3			dw .DROP 
a30b 02				db 2 
a30c .. 00			db ";",0           
a30e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a30e					if DEBUG_FORTH_WORDS_KEY 
a30e						DMARK "SCN" 
a30e f5				push af  
a30f 3a 23 a3			ld a, (.dmark)  
a312 32 6b ee			ld (debug_mark),a  
a315 3a 24 a3			ld a, (.dmark+1)  
a318 32 6c ee			ld (debug_mark+1),a  
a31b 3a 25 a3			ld a, (.dmark+2)  
a31e 32 6d ee			ld (debug_mark+2),a  
a321 18 03			jr .pastdmark  
a323 ..			.dmark: db "SCN"  
a326 f1			.pastdmark: pop af  
a327			endm  
# End of macro DMARK
a327						CALLMONITOR 
a327 cd 6f ee			call debug_vector  
a32a				endm  
# End of macro CALLMONITOR
a32a					endif 
a32a					FORTH_RSP_TOS 
a32a cd 09 9b			call macro_forth_rsp_tos 
a32d				endm 
# End of macro FORTH_RSP_TOS
a32d e5					push hl 
a32e					FORTH_RSP_POP 
a32e cd 13 9b			call macro_forth_rsp_pop 
a331				endm 
# End of macro FORTH_RSP_POP
a331 e1					pop hl 
a332			;		ex de,hl 
a332 22 c2 e5				ld (os_tok_ptr),hl 
a335			 
a335			if DEBUG_FORTH_UWORD 
a335						DMARK "SCL" 
a335 f5				push af  
a336 3a 4a a3			ld a, (.dmark)  
a339 32 6b ee			ld (debug_mark),a  
a33c 3a 4b a3			ld a, (.dmark+1)  
a33f 32 6c ee			ld (debug_mark+1),a  
a342 3a 4c a3			ld a, (.dmark+2)  
a345 32 6d ee			ld (debug_mark+2),a  
a348 18 03			jr .pastdmark  
a34a ..			.dmark: db "SCL"  
a34d f1			.pastdmark: pop af  
a34e			endm  
# End of macro DMARK
a34e				CALLMONITOR 
a34e cd 6f ee			call debug_vector  
a351				endm  
# End of macro CALLMONITOR
a351			endif 
a351					NEXTW 
a351 c3 f8 9e			jp macro_next 
a354				endm 
# End of macro NEXTW
a354			 
a354			.DROP: 
a354				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a354 1b				db WORD_SYS_CORE+OPCODE_DROP             
a355 7f a3			dw .DUP2            
a357 05				db 4 + 1 
a358 .. 00			db "DROP",0              
a35d				endm 
# End of macro CWHEAD
a35d			; | DROP ( w -- )   drop the TOS item   | DONE 
a35d					if DEBUG_FORTH_WORDS_KEY 
a35d						DMARK "DRP" 
a35d f5				push af  
a35e 3a 72 a3			ld a, (.dmark)  
a361 32 6b ee			ld (debug_mark),a  
a364 3a 73 a3			ld a, (.dmark+1)  
a367 32 6c ee			ld (debug_mark+1),a  
a36a 3a 74 a3			ld a, (.dmark+2)  
a36d 32 6d ee			ld (debug_mark+2),a  
a370 18 03			jr .pastdmark  
a372 ..			.dmark: db "DRP"  
a375 f1			.pastdmark: pop af  
a376			endm  
# End of macro DMARK
a376						CALLMONITOR 
a376 cd 6f ee			call debug_vector  
a379				endm  
# End of macro CALLMONITOR
a379					endif 
a379					FORTH_DSP_POP 
a379 cd fa 9d			call macro_forth_dsp_pop 
a37c				endm 
# End of macro FORTH_DSP_POP
a37c					NEXTW 
a37c c3 f8 9e			jp macro_next 
a37f				endm 
# End of macro NEXTW
a37f			.DUP2: 
a37f				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a37f 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a380 c4 a3			dw .DROP2            
a382 05				db 4 + 1 
a383 .. 00			db "2DUP",0              
a388				endm 
# End of macro CWHEAD
a388			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a388					if DEBUG_FORTH_WORDS_KEY 
a388						DMARK "2DU" 
a388 f5				push af  
a389 3a 9d a3			ld a, (.dmark)  
a38c 32 6b ee			ld (debug_mark),a  
a38f 3a 9e a3			ld a, (.dmark+1)  
a392 32 6c ee			ld (debug_mark+1),a  
a395 3a 9f a3			ld a, (.dmark+2)  
a398 32 6d ee			ld (debug_mark+2),a  
a39b 18 03			jr .pastdmark  
a39d ..			.dmark: db "2DU"  
a3a0 f1			.pastdmark: pop af  
a3a1			endm  
# End of macro DMARK
a3a1						CALLMONITOR 
a3a1 cd 6f ee			call debug_vector  
a3a4				endm  
# End of macro CALLMONITOR
a3a4					endif 
a3a4					FORTH_DSP_VALUEHL 
a3a4 cd 42 9d			call macro_dsp_valuehl 
a3a7				endm 
# End of macro FORTH_DSP_VALUEHL
a3a7 e5					push hl      ; 2 
a3a8			 
a3a8					FORTH_DSP_POP 
a3a8 cd fa 9d			call macro_forth_dsp_pop 
a3ab				endm 
# End of macro FORTH_DSP_POP
a3ab					 
a3ab					FORTH_DSP_VALUEHL 
a3ab cd 42 9d			call macro_dsp_valuehl 
a3ae				endm 
# End of macro FORTH_DSP_VALUEHL
a3ae			;		push hl      ; 1 
a3ae			 
a3ae					FORTH_DSP_POP 
a3ae cd fa 9d			call macro_forth_dsp_pop 
a3b1				endm 
# End of macro FORTH_DSP_POP
a3b1			 
a3b1			;		pop hl       ; 1 
a3b1 d1					pop de       ; 2 
a3b2			 
a3b2 cd 4b 9b				call forth_push_numhl 
a3b5 eb					ex de, hl 
a3b6 cd 4b 9b				call forth_push_numhl 
a3b9			 
a3b9					 
a3b9 eb					ex de, hl 
a3ba			 
a3ba cd 4b 9b				call forth_push_numhl 
a3bd eb					ex de, hl 
a3be cd 4b 9b				call forth_push_numhl 
a3c1			 
a3c1			 
a3c1					NEXTW 
a3c1 c3 f8 9e			jp macro_next 
a3c4				endm 
# End of macro NEXTW
a3c4			.DROP2: 
a3c4				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3c4 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3c5 f3 a3			dw .SWAP2            
a3c7 06				db 5 + 1 
a3c8 .. 00			db "2DROP",0              
a3ce				endm 
# End of macro CWHEAD
a3ce			; | 2DROP ( w w -- )    Double drop | DONE 
a3ce					if DEBUG_FORTH_WORDS_KEY 
a3ce						DMARK "2DR" 
a3ce f5				push af  
a3cf 3a e3 a3			ld a, (.dmark)  
a3d2 32 6b ee			ld (debug_mark),a  
a3d5 3a e4 a3			ld a, (.dmark+1)  
a3d8 32 6c ee			ld (debug_mark+1),a  
a3db 3a e5 a3			ld a, (.dmark+2)  
a3de 32 6d ee			ld (debug_mark+2),a  
a3e1 18 03			jr .pastdmark  
a3e3 ..			.dmark: db "2DR"  
a3e6 f1			.pastdmark: pop af  
a3e7			endm  
# End of macro DMARK
a3e7						CALLMONITOR 
a3e7 cd 6f ee			call debug_vector  
a3ea				endm  
# End of macro CALLMONITOR
a3ea					endif 
a3ea					FORTH_DSP_POP 
a3ea cd fa 9d			call macro_forth_dsp_pop 
a3ed				endm 
# End of macro FORTH_DSP_POP
a3ed					FORTH_DSP_POP 
a3ed cd fa 9d			call macro_forth_dsp_pop 
a3f0				endm 
# End of macro FORTH_DSP_POP
a3f0					NEXTW 
a3f0 c3 f8 9e			jp macro_next 
a3f3				endm 
# End of macro NEXTW
a3f3			.SWAP2: 
a3f3				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3f3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3f4 1c a4			dw .AT            
a3f6 06				db 5 + 1 
a3f7 .. 00			db "2SWAP",0              
a3fd				endm 
# End of macro CWHEAD
a3fd			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3fd					if DEBUG_FORTH_WORDS_KEY 
a3fd						DMARK "2SW" 
a3fd f5				push af  
a3fe 3a 12 a4			ld a, (.dmark)  
a401 32 6b ee			ld (debug_mark),a  
a404 3a 13 a4			ld a, (.dmark+1)  
a407 32 6c ee			ld (debug_mark+1),a  
a40a 3a 14 a4			ld a, (.dmark+2)  
a40d 32 6d ee			ld (debug_mark+2),a  
a410 18 03			jr .pastdmark  
a412 ..			.dmark: db "2SW"  
a415 f1			.pastdmark: pop af  
a416			endm  
# End of macro DMARK
a416						CALLMONITOR 
a416 cd 6f ee			call debug_vector  
a419				endm  
# End of macro CALLMONITOR
a419					endif 
a419					NEXTW 
a419 c3 f8 9e			jp macro_next 
a41c				endm 
# End of macro NEXTW
a41c			.AT: 
a41c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a41c 1f				db WORD_SYS_CORE+OPCODE_AT             
a41d 4e a4			dw .CAT            
a41f 02				db 1 + 1 
a420 .. 00			db "@",0              
a422				endm 
# End of macro CWHEAD
a422			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a422			 
a422					if DEBUG_FORTH_WORDS_KEY 
a422						DMARK "AT." 
a422 f5				push af  
a423 3a 37 a4			ld a, (.dmark)  
a426 32 6b ee			ld (debug_mark),a  
a429 3a 38 a4			ld a, (.dmark+1)  
a42c 32 6c ee			ld (debug_mark+1),a  
a42f 3a 39 a4			ld a, (.dmark+2)  
a432 32 6d ee			ld (debug_mark+2),a  
a435 18 03			jr .pastdmark  
a437 ..			.dmark: db "AT."  
a43a f1			.pastdmark: pop af  
a43b			endm  
# End of macro DMARK
a43b						CALLMONITOR 
a43b cd 6f ee			call debug_vector  
a43e				endm  
# End of macro CALLMONITOR
a43e					endif 
a43e			.getbyteat:	 
a43e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a43e cd 42 9d			call macro_dsp_valuehl 
a441				endm 
# End of macro FORTH_DSP_VALUEHL
a441					 
a441			;		push hl 
a441				 
a441					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a441 cd fa 9d			call macro_forth_dsp_pop 
a444				endm 
# End of macro FORTH_DSP_POP
a444			 
a444			;		pop hl 
a444			 
a444 7e					ld a, (hl) 
a445			 
a445 6f					ld l, a 
a446 26 00				ld h, 0 
a448 cd 4b 9b				call forth_push_numhl 
a44b			 
a44b					NEXTW 
a44b c3 f8 9e			jp macro_next 
a44e				endm 
# End of macro NEXTW
a44e			.CAT: 
a44e				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a44e 20				db WORD_SYS_CORE+OPCODE_CAT             
a44f 77 a4			dw .BANG            
a451 03				db 2 + 1 
a452 .. 00			db "C@",0              
a455				endm 
# End of macro CWHEAD
a455			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a455					if DEBUG_FORTH_WORDS_KEY 
a455						DMARK "CAA" 
a455 f5				push af  
a456 3a 6a a4			ld a, (.dmark)  
a459 32 6b ee			ld (debug_mark),a  
a45c 3a 6b a4			ld a, (.dmark+1)  
a45f 32 6c ee			ld (debug_mark+1),a  
a462 3a 6c a4			ld a, (.dmark+2)  
a465 32 6d ee			ld (debug_mark+2),a  
a468 18 03			jr .pastdmark  
a46a ..			.dmark: db "CAA"  
a46d f1			.pastdmark: pop af  
a46e			endm  
# End of macro DMARK
a46e						CALLMONITOR 
a46e cd 6f ee			call debug_vector  
a471				endm  
# End of macro CALLMONITOR
a471					endif 
a471 c3 3e a4				jp .getbyteat 
a474					NEXTW 
a474 c3 f8 9e			jp macro_next 
a477				endm 
# End of macro NEXTW
a477			.BANG: 
a477				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a477 21				db WORD_SYS_CORE+OPCODE_BANG             
a478 ad a4			dw .CBANG            
a47a 02				db 1 + 1 
a47b .. 00			db "!",0              
a47d				endm 
# End of macro CWHEAD
a47d			; | ! ( x w -- ) Store x at address w      | DONE 
a47d					if DEBUG_FORTH_WORDS_KEY 
a47d						DMARK "BNG" 
a47d f5				push af  
a47e 3a 92 a4			ld a, (.dmark)  
a481 32 6b ee			ld (debug_mark),a  
a484 3a 93 a4			ld a, (.dmark+1)  
a487 32 6c ee			ld (debug_mark+1),a  
a48a 3a 94 a4			ld a, (.dmark+2)  
a48d 32 6d ee			ld (debug_mark+2),a  
a490 18 03			jr .pastdmark  
a492 ..			.dmark: db "BNG"  
a495 f1			.pastdmark: pop af  
a496			endm  
# End of macro DMARK
a496						CALLMONITOR 
a496 cd 6f ee			call debug_vector  
a499				endm  
# End of macro CALLMONITOR
a499					endif 
a499			 
a499			.storebyteat:		 
a499					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a499 cd 42 9d			call macro_dsp_valuehl 
a49c				endm 
# End of macro FORTH_DSP_VALUEHL
a49c					 
a49c e5					push hl 
a49d				 
a49d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a49d cd fa 9d			call macro_forth_dsp_pop 
a4a0				endm 
# End of macro FORTH_DSP_POP
a4a0			 
a4a0					; get byte to poke 
a4a0			 
a4a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4a0 cd 42 9d			call macro_dsp_valuehl 
a4a3				endm 
# End of macro FORTH_DSP_VALUEHL
a4a3 e5					push hl 
a4a4			 
a4a4			 
a4a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a4 cd fa 9d			call macro_forth_dsp_pop 
a4a7				endm 
# End of macro FORTH_DSP_POP
a4a7			 
a4a7			 
a4a7 d1					pop de 
a4a8 e1					pop hl 
a4a9			 
a4a9 73					ld (hl),e 
a4aa			 
a4aa			 
a4aa					NEXTW 
a4aa c3 f8 9e			jp macro_next 
a4ad				endm 
# End of macro NEXTW
a4ad			.CBANG: 
a4ad				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a4ad 22				db WORD_SYS_CORE+OPCODE_CBANG             
a4ae d6 a4			dw .SCALL            
a4b0 03				db 2 + 1 
a4b1 .. 00			db "C!",0              
a4b4				endm 
# End of macro CWHEAD
a4b4			; | C!  ( x w -- ) Store x at address w  | DONE 
a4b4					if DEBUG_FORTH_WORDS_KEY 
a4b4						DMARK "CBA" 
a4b4 f5				push af  
a4b5 3a c9 a4			ld a, (.dmark)  
a4b8 32 6b ee			ld (debug_mark),a  
a4bb 3a ca a4			ld a, (.dmark+1)  
a4be 32 6c ee			ld (debug_mark+1),a  
a4c1 3a cb a4			ld a, (.dmark+2)  
a4c4 32 6d ee			ld (debug_mark+2),a  
a4c7 18 03			jr .pastdmark  
a4c9 ..			.dmark: db "CBA"  
a4cc f1			.pastdmark: pop af  
a4cd			endm  
# End of macro DMARK
a4cd						CALLMONITOR 
a4cd cd 6f ee			call debug_vector  
a4d0				endm  
# End of macro CALLMONITOR
a4d0					endif 
a4d0 c3 99 a4				jp .storebyteat 
a4d3					NEXTW 
a4d3 c3 f8 9e			jp macro_next 
a4d6				endm 
# End of macro NEXTW
a4d6			.SCALL: 
a4d6				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4d6 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4d7 0a a5			dw .DEPTH            
a4d9 05				db 4 + 1 
a4da .. 00			db "CALL",0              
a4df				endm 
# End of macro CWHEAD
a4df			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4df					if DEBUG_FORTH_WORDS_KEY 
a4df						DMARK "CLL" 
a4df f5				push af  
a4e0 3a f4 a4			ld a, (.dmark)  
a4e3 32 6b ee			ld (debug_mark),a  
a4e6 3a f5 a4			ld a, (.dmark+1)  
a4e9 32 6c ee			ld (debug_mark+1),a  
a4ec 3a f6 a4			ld a, (.dmark+2)  
a4ef 32 6d ee			ld (debug_mark+2),a  
a4f2 18 03			jr .pastdmark  
a4f4 ..			.dmark: db "CLL"  
a4f7 f1			.pastdmark: pop af  
a4f8			endm  
# End of macro DMARK
a4f8						CALLMONITOR 
a4f8 cd 6f ee			call debug_vector  
a4fb				endm  
# End of macro CALLMONITOR
a4fb					endif 
a4fb			 
a4fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4fb cd 42 9d			call macro_dsp_valuehl 
a4fe				endm 
# End of macro FORTH_DSP_VALUEHL
a4fe			 
a4fe			;		push hl 
a4fe			 
a4fe					; destroy value TOS 
a4fe			 
a4fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4fe cd fa 9d			call macro_forth_dsp_pop 
a501				endm 
# End of macro FORTH_DSP_POP
a501			 
a501						 
a501			;		pop hl 
a501			 
a501					; how to do a call with hl???? save SP? 
a501 cd 9c 9e				call forth_call_hl 
a504			 
a504			 
a504					; TODO push value back onto stack for another op etc 
a504			 
a504 cd 4b 9b				call forth_push_numhl 
a507					NEXTW 
a507 c3 f8 9e			jp macro_next 
a50a				endm 
# End of macro NEXTW
a50a			.DEPTH: 
a50a				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a50a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a50b 47 a5			dw .OVER            
a50d 06				db 5 + 1 
a50e .. 00			db "DEPTH",0              
a514				endm 
# End of macro CWHEAD
a514			; | DEPTH ( -- u ) Push count of stack | DONE 
a514					; take current TOS and remove from base value div by two to get count 
a514					if DEBUG_FORTH_WORDS_KEY 
a514						DMARK "DEP" 
a514 f5				push af  
a515 3a 29 a5			ld a, (.dmark)  
a518 32 6b ee			ld (debug_mark),a  
a51b 3a 2a a5			ld a, (.dmark+1)  
a51e 32 6c ee			ld (debug_mark+1),a  
a521 3a 2b a5			ld a, (.dmark+2)  
a524 32 6d ee			ld (debug_mark+2),a  
a527 18 03			jr .pastdmark  
a529 ..			.dmark: db "DEP"  
a52c f1			.pastdmark: pop af  
a52d			endm  
# End of macro DMARK
a52d						CALLMONITOR 
a52d cd 6f ee			call debug_vector  
a530				endm  
# End of macro CALLMONITOR
a530					endif 
a530			 
a530			 
a530 2a ee e9			ld hl, (cli_data_sp) 
a533 11 28 e8			ld de, cli_data_stack 
a536 ed 52			sbc hl,de 
a538				 
a538				; div by size of stack item 
a538			 
a538 5d				ld e,l 
a539 0e 03			ld c, 3 
a53b cd 6c 8c			call Div8 
a53e			 
a53e 6f				ld l,a 
a53f 26 00			ld h,0 
a541			 
a541				;srl h 
a541				;rr l 
a541			 
a541 cd 4b 9b				call forth_push_numhl 
a544					NEXTW 
a544 c3 f8 9e			jp macro_next 
a547				endm 
# End of macro NEXTW
a547			.OVER: 
a547				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a547 42				db WORD_SYS_CORE+46             
a548 8e a5			dw .PAUSE            
a54a 05				db 4 + 1 
a54b .. 00			db "OVER",0              
a550				endm 
# End of macro CWHEAD
a550			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a550					if DEBUG_FORTH_WORDS_KEY 
a550						DMARK "OVR" 
a550 f5				push af  
a551 3a 65 a5			ld a, (.dmark)  
a554 32 6b ee			ld (debug_mark),a  
a557 3a 66 a5			ld a, (.dmark+1)  
a55a 32 6c ee			ld (debug_mark+1),a  
a55d 3a 67 a5			ld a, (.dmark+2)  
a560 32 6d ee			ld (debug_mark+2),a  
a563 18 03			jr .pastdmark  
a565 ..			.dmark: db "OVR"  
a568 f1			.pastdmark: pop af  
a569			endm  
# End of macro DMARK
a569						CALLMONITOR 
a569 cd 6f ee			call debug_vector  
a56c				endm  
# End of macro CALLMONITOR
a56c					endif 
a56c			 
a56c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a56c cd 42 9d			call macro_dsp_valuehl 
a56f				endm 
# End of macro FORTH_DSP_VALUEHL
a56f e5					push hl    ; n2 
a570					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a570 cd fa 9d			call macro_forth_dsp_pop 
a573				endm 
# End of macro FORTH_DSP_POP
a573			 
a573					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a573 cd 42 9d			call macro_dsp_valuehl 
a576				endm 
# End of macro FORTH_DSP_VALUEHL
a576 e5					push hl    ; n1 
a577					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a577 cd fa 9d			call macro_forth_dsp_pop 
a57a				endm 
# End of macro FORTH_DSP_POP
a57a			 
a57a d1					pop de     ; n1 
a57b e1					pop hl     ; n2 
a57c			 
a57c d5					push de 
a57d e5					push hl 
a57e d5					push de 
a57f			 
a57f					; push back  
a57f			 
a57f e1					pop hl 
a580 cd 4b 9b				call forth_push_numhl 
a583 e1					pop hl 
a584 cd 4b 9b				call forth_push_numhl 
a587 e1					pop hl 
a588 cd 4b 9b				call forth_push_numhl 
a58b					NEXTW 
a58b c3 f8 9e			jp macro_next 
a58e				endm 
# End of macro NEXTW
a58e			 
a58e			.PAUSE: 
a58e				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a58e 43				db WORD_SYS_CORE+47             
a58f c3 a5			dw .PAUSES            
a591 08				db 7 + 1 
a592 .. 00			db "PAUSEMS",0              
a59a				endm 
# End of macro CWHEAD
a59a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a59a					if DEBUG_FORTH_WORDS_KEY 
a59a						DMARK "PMS" 
a59a f5				push af  
a59b 3a af a5			ld a, (.dmark)  
a59e 32 6b ee			ld (debug_mark),a  
a5a1 3a b0 a5			ld a, (.dmark+1)  
a5a4 32 6c ee			ld (debug_mark+1),a  
a5a7 3a b1 a5			ld a, (.dmark+2)  
a5aa 32 6d ee			ld (debug_mark+2),a  
a5ad 18 03			jr .pastdmark  
a5af ..			.dmark: db "PMS"  
a5b2 f1			.pastdmark: pop af  
a5b3			endm  
# End of macro DMARK
a5b3						CALLMONITOR 
a5b3 cd 6f ee			call debug_vector  
a5b6				endm  
# End of macro CALLMONITOR
a5b6					endif 
a5b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b6 cd 42 9d			call macro_dsp_valuehl 
a5b9				endm 
# End of macro FORTH_DSP_VALUEHL
a5b9			;		push hl    ; n2 
a5b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b9 cd fa 9d			call macro_forth_dsp_pop 
a5bc				endm 
# End of macro FORTH_DSP_POP
a5bc			;		pop hl 
a5bc			 
a5bc 7d					ld a, l 
a5bd cd d7 89				call aDelayInMS 
a5c0				       NEXTW 
a5c0 c3 f8 9e			jp macro_next 
a5c3				endm 
# End of macro NEXTW
a5c3			.PAUSES:  
a5c3				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5c3 44				db WORD_SYS_CORE+48             
a5c4 32 a6			dw .ROT            
a5c6 06				db 5 + 1 
a5c7 .. 00			db "PAUSE",0              
a5cd				endm 
# End of macro CWHEAD
a5cd			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5cd					if DEBUG_FORTH_WORDS_KEY 
a5cd						DMARK "PAU" 
a5cd f5				push af  
a5ce 3a e2 a5			ld a, (.dmark)  
a5d1 32 6b ee			ld (debug_mark),a  
a5d4 3a e3 a5			ld a, (.dmark+1)  
a5d7 32 6c ee			ld (debug_mark+1),a  
a5da 3a e4 a5			ld a, (.dmark+2)  
a5dd 32 6d ee			ld (debug_mark+2),a  
a5e0 18 03			jr .pastdmark  
a5e2 ..			.dmark: db "PAU"  
a5e5 f1			.pastdmark: pop af  
a5e6			endm  
# End of macro DMARK
a5e6						CALLMONITOR 
a5e6 cd 6f ee			call debug_vector  
a5e9				endm  
# End of macro CALLMONITOR
a5e9					endif 
a5e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5e9 cd 42 9d			call macro_dsp_valuehl 
a5ec				endm 
# End of macro FORTH_DSP_VALUEHL
a5ec			;		push hl    ; n2 
a5ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5ec cd fa 9d			call macro_forth_dsp_pop 
a5ef				endm 
# End of macro FORTH_DSP_POP
a5ef			;		pop hl 
a5ef 45					ld b, l 
a5f0					if DEBUG_FORTH_WORDS 
a5f0						DMARK "PAU" 
a5f0 f5				push af  
a5f1 3a 05 a6			ld a, (.dmark)  
a5f4 32 6b ee			ld (debug_mark),a  
a5f7 3a 06 a6			ld a, (.dmark+1)  
a5fa 32 6c ee			ld (debug_mark+1),a  
a5fd 3a 07 a6			ld a, (.dmark+2)  
a600 32 6d ee			ld (debug_mark+2),a  
a603 18 03			jr .pastdmark  
a605 ..			.dmark: db "PAU"  
a608 f1			.pastdmark: pop af  
a609			endm  
# End of macro DMARK
a609						CALLMONITOR 
a609 cd 6f ee			call debug_vector  
a60c				endm  
# End of macro CALLMONITOR
a60c					endif 
a60c c5			.pauses1:	push bc 
a60d cd f2 89				call delay1s 
a610 c1					pop bc 
a611					if DEBUG_FORTH_WORDS 
a611						DMARK "PA1" 
a611 f5				push af  
a612 3a 26 a6			ld a, (.dmark)  
a615 32 6b ee			ld (debug_mark),a  
a618 3a 27 a6			ld a, (.dmark+1)  
a61b 32 6c ee			ld (debug_mark+1),a  
a61e 3a 28 a6			ld a, (.dmark+2)  
a621 32 6d ee			ld (debug_mark+2),a  
a624 18 03			jr .pastdmark  
a626 ..			.dmark: db "PA1"  
a629 f1			.pastdmark: pop af  
a62a			endm  
# End of macro DMARK
a62a						CALLMONITOR 
a62a cd 6f ee			call debug_vector  
a62d				endm  
# End of macro CALLMONITOR
a62d					endif 
a62d 10 dd				djnz .pauses1 
a62f			 
a62f				       NEXTW 
a62f c3 f8 9e			jp macro_next 
a632				endm 
# End of macro NEXTW
a632			.ROT: 
a632				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a632 45				db WORD_SYS_CORE+49             
a633 80 a6			dw .UWORDS            
a635 04				db 3 + 1 
a636 .. 00			db "ROT",0              
a63a				endm 
# End of macro CWHEAD
a63a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a63a					if DEBUG_FORTH_WORDS_KEY 
a63a						DMARK "ROT" 
a63a f5				push af  
a63b 3a 4f a6			ld a, (.dmark)  
a63e 32 6b ee			ld (debug_mark),a  
a641 3a 50 a6			ld a, (.dmark+1)  
a644 32 6c ee			ld (debug_mark+1),a  
a647 3a 51 a6			ld a, (.dmark+2)  
a64a 32 6d ee			ld (debug_mark+2),a  
a64d 18 03			jr .pastdmark  
a64f ..			.dmark: db "ROT"  
a652 f1			.pastdmark: pop af  
a653			endm  
# End of macro DMARK
a653						CALLMONITOR 
a653 cd 6f ee			call debug_vector  
a656				endm  
# End of macro CALLMONITOR
a656					endif 
a656			 
a656					FORTH_DSP_VALUEHL 
a656 cd 42 9d			call macro_dsp_valuehl 
a659				endm 
# End of macro FORTH_DSP_VALUEHL
a659 e5					push hl    ; u3  
a65a			 
a65a					FORTH_DSP_POP 
a65a cd fa 9d			call macro_forth_dsp_pop 
a65d				endm 
# End of macro FORTH_DSP_POP
a65d			   
a65d					FORTH_DSP_VALUEHL 
a65d cd 42 9d			call macro_dsp_valuehl 
a660				endm 
# End of macro FORTH_DSP_VALUEHL
a660 e5					push hl     ; u2 
a661			 
a661					FORTH_DSP_POP 
a661 cd fa 9d			call macro_forth_dsp_pop 
a664				endm 
# End of macro FORTH_DSP_POP
a664			 
a664					FORTH_DSP_VALUEHL 
a664 cd 42 9d			call macro_dsp_valuehl 
a667				endm 
# End of macro FORTH_DSP_VALUEHL
a667 e5					push hl     ; u1 
a668			 
a668					FORTH_DSP_POP 
a668 cd fa 9d			call macro_forth_dsp_pop 
a66b				endm 
# End of macro FORTH_DSP_POP
a66b			 
a66b c1					pop bc      ; u1 
a66c e1					pop hl      ; u2 
a66d d1					pop de      ; u3 
a66e			 
a66e			 
a66e c5					push bc 
a66f d5					push de 
a670 e5					push hl 
a671			 
a671			 
a671 e1					pop hl 
a672 cd 4b 9b				call forth_push_numhl 
a675			 
a675 e1					pop hl 
a676 cd 4b 9b				call forth_push_numhl 
a679			 
a679 e1					pop hl 
a67a cd 4b 9b				call forth_push_numhl 
a67d					 
a67d			 
a67d			 
a67d			 
a67d			 
a67d			 
a67d				       NEXTW 
a67d c3 f8 9e			jp macro_next 
a680				endm 
# End of macro NEXTW
a680			 
a680			.UWORDS: 
a680				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a680 50				db WORD_SYS_CORE+60             
a681 42 a7			dw .BP            
a683 07				db 6 + 1 
a684 .. 00			db "UWORDS",0              
a68b				endm 
# End of macro CWHEAD
a68b			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a68b			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a68b			; | | Following the count are the individual words. 
a68b			; | | 
a68b			; | | e.g. UWORDS 
a68b			; | | BOX DIRLIST 2 
a68b			; | |  
a68b			; | | Can be used to save the words to storage via: 
a68b			; | | UWORDS $01 DO $01 APPEND LOOP 
a68b				if DEBUG_FORTH_WORDS_KEY 
a68b					DMARK "UWR" 
a68b f5				push af  
a68c 3a a0 a6			ld a, (.dmark)  
a68f 32 6b ee			ld (debug_mark),a  
a692 3a a1 a6			ld a, (.dmark+1)  
a695 32 6c ee			ld (debug_mark+1),a  
a698 3a a2 a6			ld a, (.dmark+2)  
a69b 32 6d ee			ld (debug_mark+2),a  
a69e 18 03			jr .pastdmark  
a6a0 ..			.dmark: db "UWR"  
a6a3 f1			.pastdmark: pop af  
a6a4			endm  
# End of macro DMARK
a6a4					CALLMONITOR 
a6a4 cd 6f ee			call debug_vector  
a6a7				endm  
# End of macro CALLMONITOR
a6a7				endif 
a6a7 21 3d e4				ld hl, baseram 
a6aa					;ld hl, baseusermem 
a6aa 01 00 00				ld bc, 0    ; start a counter 
a6ad			 
a6ad				; skip dict stub 
a6ad			 
a6ad cd 49 a0				call forth_tok_next 
a6b0			 
a6b0			 
a6b0			; while we have words to look for 
a6b0			 
a6b0 7e			.douscan:	ld a, (hl)      
a6b1				if DEBUG_FORTH_WORDS 
a6b1					DMARK "UWs" 
a6b1 f5				push af  
a6b2 3a c6 a6			ld a, (.dmark)  
a6b5 32 6b ee			ld (debug_mark),a  
a6b8 3a c7 a6			ld a, (.dmark+1)  
a6bb 32 6c ee			ld (debug_mark+1),a  
a6be 3a c8 a6			ld a, (.dmark+2)  
a6c1 32 6d ee			ld (debug_mark+2),a  
a6c4 18 03			jr .pastdmark  
a6c6 ..			.dmark: db "UWs"  
a6c9 f1			.pastdmark: pop af  
a6ca			endm  
# End of macro DMARK
a6ca					CALLMONITOR 
a6ca cd 6f ee			call debug_vector  
a6cd				endm  
# End of macro CALLMONITOR
a6cd				endif 
a6cd fe 00				cp WORD_SYS_END 
a6cf 28 4d				jr z, .udone 
a6d1 fe 01				cp WORD_SYS_UWORD 
a6d3 20 44				jr nz, .nuword 
a6d5			 
a6d5				if DEBUG_FORTH_WORDS 
a6d5					DMARK "UWu" 
a6d5 f5				push af  
a6d6 3a ea a6			ld a, (.dmark)  
a6d9 32 6b ee			ld (debug_mark),a  
a6dc 3a eb a6			ld a, (.dmark+1)  
a6df 32 6c ee			ld (debug_mark+1),a  
a6e2 3a ec a6			ld a, (.dmark+2)  
a6e5 32 6d ee			ld (debug_mark+2),a  
a6e8 18 03			jr .pastdmark  
a6ea ..			.dmark: db "UWu"  
a6ed f1			.pastdmark: pop af  
a6ee			endm  
# End of macro DMARK
a6ee					CALLMONITOR 
a6ee cd 6f ee			call debug_vector  
a6f1				endm  
# End of macro CALLMONITOR
a6f1				endif 
a6f1					; we have a uword so push its name to the stack 
a6f1			 
a6f1 e5				   	push hl  ; save so we can move to next dict block 
a6f2			 
a6f2					; skip opcode 
a6f2 23					inc hl  
a6f3					; skip next ptr 
a6f3 23					inc hl  
a6f4 23					inc hl 
a6f5					; skip len 
a6f5 23					inc hl 
a6f6				if DEBUG_FORTH_WORDS 
a6f6					DMARK "UWt" 
a6f6 f5				push af  
a6f7 3a 0b a7			ld a, (.dmark)  
a6fa 32 6b ee			ld (debug_mark),a  
a6fd 3a 0c a7			ld a, (.dmark+1)  
a700 32 6c ee			ld (debug_mark+1),a  
a703 3a 0d a7			ld a, (.dmark+2)  
a706 32 6d ee			ld (debug_mark+2),a  
a709 18 03			jr .pastdmark  
a70b ..			.dmark: db "UWt"  
a70e f1			.pastdmark: pop af  
a70f			endm  
# End of macro DMARK
a70f					CALLMONITOR 
a70f cd 6f ee			call debug_vector  
a712				endm  
# End of macro CALLMONITOR
a712				endif 
a712 03					inc bc 
a713			 
a713 c5					push bc 
a714 cd b9 9b				call forth_push_str 
a717 c1					pop bc 
a718			 
a718 e1					pop hl 	 
a719			 
a719 cd 49 a0		.nuword:	call forth_tok_next 
a71c 18 92				jr .douscan  
a71e			 
a71e			.udone:		 ; push count of uwords found 
a71e c5					push bc 
a71f e1					pop hl 
a720			 
a720				if DEBUG_FORTH_WORDS 
a720					DMARK "UWc" 
a720 f5				push af  
a721 3a 35 a7			ld a, (.dmark)  
a724 32 6b ee			ld (debug_mark),a  
a727 3a 36 a7			ld a, (.dmark+1)  
a72a 32 6c ee			ld (debug_mark+1),a  
a72d 3a 37 a7			ld a, (.dmark+2)  
a730 32 6d ee			ld (debug_mark+2),a  
a733 18 03			jr .pastdmark  
a735 ..			.dmark: db "UWc"  
a738 f1			.pastdmark: pop af  
a739			endm  
# End of macro DMARK
a739					CALLMONITOR 
a739 cd 6f ee			call debug_vector  
a73c				endm  
# End of macro CALLMONITOR
a73c				endif 
a73c cd 4b 9b				call forth_push_numhl 
a73f			 
a73f			 
a73f				       NEXTW 
a73f c3 f8 9e			jp macro_next 
a742				endm 
# End of macro NEXTW
a742			 
a742			.BP: 
a742				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a742 54				db WORD_SYS_CORE+64             
a743 7c a7			dw .MONITOR            
a745 03				db 2 + 1 
a746 .. 00			db "BP",0              
a749				endm 
# End of macro CWHEAD
a749			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a749			; | | $00 Will enable the break points within specific code paths 
a749			; | | $01 Will disable break points 
a749			; | |  
a749			; | | By default break points are off. Either the above can be used to enable them 
a749			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a749			; | | and on release of the pressed key a message will be disaplayed to notify 
a749			; | | that break points are enabled. Pressing any key will then continue boot process. 
a749					; get byte count 
a749					if DEBUG_FORTH_WORDS_KEY 
a749						DMARK "BP." 
a749 f5				push af  
a74a 3a 5e a7			ld a, (.dmark)  
a74d 32 6b ee			ld (debug_mark),a  
a750 3a 5f a7			ld a, (.dmark+1)  
a753 32 6c ee			ld (debug_mark+1),a  
a756 3a 60 a7			ld a, (.dmark+2)  
a759 32 6d ee			ld (debug_mark+2),a  
a75c 18 03			jr .pastdmark  
a75e ..			.dmark: db "BP."  
a761 f1			.pastdmark: pop af  
a762			endm  
# End of macro DMARK
a762						CALLMONITOR 
a762 cd 6f ee			call debug_vector  
a765				endm  
# End of macro CALLMONITOR
a765					endif 
a765			 
a765					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a765 cd 42 9d			call macro_dsp_valuehl 
a768				endm 
# End of macro FORTH_DSP_VALUEHL
a768			 
a768			;		push hl 
a768			 
a768					; destroy value TOS 
a768			 
a768					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a768 cd fa 9d			call macro_forth_dsp_pop 
a76b				endm 
# End of macro FORTH_DSP_POP
a76b			 
a76b			;		pop hl 
a76b			 
a76b 3e 00				ld a,0 
a76d bd					cp l 
a76e 28 06				jr z, .bpset 
a770			;		ld a, '*' 
a770 cd de 94				call bp_off 
a773					NEXTW 
a773 c3 f8 9e			jp macro_next 
a776				endm 
# End of macro NEXTW
a776			 
a776			.bpset:	 
a776					;	ld (os_view_disable), a 
a776 cd d2 94				call bp_on 
a779			 
a779			 
a779					NEXTW 
a779 c3 f8 9e			jp macro_next 
a77c				endm 
# End of macro NEXTW
a77c			 
a77c			 
a77c			.MONITOR: 
a77c				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a77c 55				db WORD_SYS_CORE+65             
a77d ad a7			dw .MALLOC            
a77f 08				db 7 + 1 
a780 .. 00			db "MONITOR",0              
a788				endm 
# End of macro CWHEAD
a788			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a788			; | | At start the current various registers will be displayed with contents. 
a788			; | | Top right corner will show the most recent debug marker seen. 
a788			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a788			; | | and the return stack pointer (RSP). 
a788			; | | Pressing: 
a788			; | |    1 - Initial screen 
a788			; | |    2 - Display a data dump of HL 
a788			; | |    3 - Display a data dump of DE 
a788			; | |    4 - Display a data dump of BC 
a788			; | |    5 - Display a data dump of HL 
a788			; | |    6 - Display a data dump of DSP 
a788			; | |    7 - Display a data dump of RSP 
a788			; | |    8 - Display a data dump of what is at DSP 
a788			; | |    9 - Display a data dump of what is at RSP 
a788			; | |    0 - Exit monitor and continue running. This will also enable break points 
a788			; | |    * - Disable break points 
a788			; | |    # - Enter traditional monitor mode 
a788			; | | 
a788			; | | Monitor Mode 
a788			; | | ------------ 
a788			; | | A prompt of '>' will be shown for various commands: 
a788			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a788			; | |    C - Continue display a data dump from the last set address 
a788			; | |    M xxxx - Set start of memory edit at address xx 
a788			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a788			; | |    Q - Return to previous 
a788					if DEBUG_FORTH_WORDS_KEY 
a788						DMARK "MON" 
a788 f5				push af  
a789 3a 9d a7			ld a, (.dmark)  
a78c 32 6b ee			ld (debug_mark),a  
a78f 3a 9e a7			ld a, (.dmark+1)  
a792 32 6c ee			ld (debug_mark+1),a  
a795 3a 9f a7			ld a, (.dmark+2)  
a798 32 6d ee			ld (debug_mark+2),a  
a79b 18 03			jr .pastdmark  
a79d ..			.dmark: db "MON"  
a7a0 f1			.pastdmark: pop af  
a7a1			endm  
# End of macro DMARK
a7a1						CALLMONITOR 
a7a1 cd 6f ee			call debug_vector  
a7a4				endm  
# End of macro CALLMONITOR
a7a4					endif 
a7a4			;		ld a, 0 
a7a4			;		ld (os_view_disable), a 
a7a4 cd d2 94				call bp_on 
a7a7			 
a7a7					CALLMONITOR 
a7a7 cd 6f ee			call debug_vector  
a7aa				endm  
# End of macro CALLMONITOR
a7aa			 
a7aa			;	call monitor 
a7aa			 
a7aa					NEXTW 
a7aa c3 f8 9e			jp macro_next 
a7ad				endm 
# End of macro NEXTW
a7ad			 
a7ad			 
a7ad			.MALLOC: 
a7ad				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a7ad 56				db WORD_SYS_CORE+66             
a7ae d6 a7			dw .MALLOC2            
a7b0 06				db 5 + 1 
a7b1 .. 00			db "ALLOT",0              
a7b7				endm 
# End of macro CWHEAD
a7b7			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7b7					if DEBUG_FORTH_WORDS_KEY 
a7b7						DMARK "ALL" 
a7b7 f5				push af  
a7b8 3a cc a7			ld a, (.dmark)  
a7bb 32 6b ee			ld (debug_mark),a  
a7be 3a cd a7			ld a, (.dmark+1)  
a7c1 32 6c ee			ld (debug_mark+1),a  
a7c4 3a ce a7			ld a, (.dmark+2)  
a7c7 32 6d ee			ld (debug_mark+2),a  
a7ca 18 03			jr .pastdmark  
a7cc ..			.dmark: db "ALL"  
a7cf f1			.pastdmark: pop af  
a7d0			endm  
# End of macro DMARK
a7d0						CALLMONITOR 
a7d0 cd 6f ee			call debug_vector  
a7d3				endm  
# End of macro CALLMONITOR
a7d3					endif 
a7d3 c3 fd a7				jp .mallocc 
a7d6			.MALLOC2: 
a7d6				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7d6 56				db WORD_SYS_CORE+66             
a7d7 14 a8			dw .FREE            
a7d9 07				db 6 + 1 
a7da .. 00			db "MALLOC",0              
a7e1				endm 
# End of macro CWHEAD
a7e1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7e1					; get byte count 
a7e1					if DEBUG_FORTH_WORDS_KEY 
a7e1						DMARK "MAL" 
a7e1 f5				push af  
a7e2 3a f6 a7			ld a, (.dmark)  
a7e5 32 6b ee			ld (debug_mark),a  
a7e8 3a f7 a7			ld a, (.dmark+1)  
a7eb 32 6c ee			ld (debug_mark+1),a  
a7ee 3a f8 a7			ld a, (.dmark+2)  
a7f1 32 6d ee			ld (debug_mark+2),a  
a7f4 18 03			jr .pastdmark  
a7f6 ..			.dmark: db "MAL"  
a7f9 f1			.pastdmark: pop af  
a7fa			endm  
# End of macro DMARK
a7fa						CALLMONITOR 
a7fa cd 6f ee			call debug_vector  
a7fd				endm  
# End of macro CALLMONITOR
a7fd					endif 
a7fd			.mallocc: 
a7fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7fd cd 42 9d			call macro_dsp_valuehl 
a800				endm 
# End of macro FORTH_DSP_VALUEHL
a800			 
a800			;		push hl 
a800			 
a800					; destroy value TOS 
a800			 
a800					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a800 cd fa 9d			call macro_forth_dsp_pop 
a803				endm 
# End of macro FORTH_DSP_POP
a803			 
a803			;		pop hl 
a803 cd a3 91				call malloc 
a806				if DEBUG_FORTH_MALLOC_GUARD 
a806 f5					push af 
a807 cd 05 8d				call ishlzero 
a80a			;		ld a, l 
a80a			;		add h 
a80a			;		cp 0 
a80a f1					pop af 
a80b					 
a80b cc 37 cc				call z,malloc_error 
a80e				endif 
a80e			 
a80e cd 4b 9b				call forth_push_numhl 
a811					NEXTW 
a811 c3 f8 9e			jp macro_next 
a814				endm 
# End of macro NEXTW
a814			 
a814			.FREE: 
a814				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a814 57				db WORD_SYS_CORE+67             
a815 45 a8			dw .LIST            
a817 05				db 4 + 1 
a818 .. 00			db "FREE",0              
a81d				endm 
# End of macro CWHEAD
a81d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a81d					if DEBUG_FORTH_WORDS_KEY 
a81d						DMARK "FRE" 
a81d f5				push af  
a81e 3a 32 a8			ld a, (.dmark)  
a821 32 6b ee			ld (debug_mark),a  
a824 3a 33 a8			ld a, (.dmark+1)  
a827 32 6c ee			ld (debug_mark+1),a  
a82a 3a 34 a8			ld a, (.dmark+2)  
a82d 32 6d ee			ld (debug_mark+2),a  
a830 18 03			jr .pastdmark  
a832 ..			.dmark: db "FRE"  
a835 f1			.pastdmark: pop af  
a836			endm  
# End of macro DMARK
a836						CALLMONITOR 
a836 cd 6f ee			call debug_vector  
a839				endm  
# End of macro CALLMONITOR
a839					endif 
a839					; get address 
a839			 
a839					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a839 cd 42 9d			call macro_dsp_valuehl 
a83c				endm 
# End of macro FORTH_DSP_VALUEHL
a83c			 
a83c			;		push hl 
a83c			 
a83c					; destroy value TOS 
a83c			 
a83c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a83c cd fa 9d			call macro_forth_dsp_pop 
a83f				endm 
# End of macro FORTH_DSP_POP
a83f			 
a83f			;		pop hl 
a83f			if FORTH_ENABLE_MALLOCFREE 
a83f cd 6d 92				call free 
a842			endif 
a842					NEXTW 
a842 c3 f8 9e			jp macro_next 
a845				endm 
# End of macro NEXTW
a845			.LIST: 
a845				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a845 5c				db WORD_SYS_CORE+72             
a846 33 aa			dw .FORGET            
a848 05				db 4 + 1 
a849 .. 00			db "LIST",0              
a84e				endm 
# End of macro CWHEAD
a84e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a84e			; | | The quoted word must be in upper case. 
a84e				if DEBUG_FORTH_WORDS_KEY 
a84e					DMARK "LST" 
a84e f5				push af  
a84f 3a 63 a8			ld a, (.dmark)  
a852 32 6b ee			ld (debug_mark),a  
a855 3a 64 a8			ld a, (.dmark+1)  
a858 32 6c ee			ld (debug_mark+1),a  
a85b 3a 65 a8			ld a, (.dmark+2)  
a85e 32 6d ee			ld (debug_mark+2),a  
a861 18 03			jr .pastdmark  
a863 ..			.dmark: db "LST"  
a866 f1			.pastdmark: pop af  
a867			endm  
# End of macro DMARK
a867					CALLMONITOR 
a867 cd 6f ee			call debug_vector  
a86a				endm  
# End of macro CALLMONITOR
a86a				endif 
a86a			 
a86a					FORTH_DSP_VALUEHL 
a86a cd 42 9d			call macro_dsp_valuehl 
a86d				endm 
# End of macro FORTH_DSP_VALUEHL
a86d			 
a86d e5					push hl 
a86e					FORTH_DSP_POP 
a86e cd fa 9d			call macro_forth_dsp_pop 
a871				endm 
# End of macro FORTH_DSP_POP
a871 c1					pop bc 
a872			 
a872			; Start format of scratch string 
a872			 
a872 21 c1 e2				ld hl, scratch 
a875			 
a875 3e 3a				ld a, ':' 
a877 77					ld (hl),a 
a878 23					inc hl 
a879 3e 20				ld a, ' ' 
a87b 77					ld (hl), a 
a87c			 
a87c					; Get ptr to the word we need to look up 
a87c			 
a87c			;		FORTH_DSP_VALUEHL 
a87c					;v5 FORTH_DSP_VALUE 
a87c				; TODO type check 
a87c			;		inc hl    ; Skip type check  
a87c			;		push hl 
a87c			;		ex de, hl    ; put into DE 
a87c			 
a87c			 
a87c 21 3d e4				ld hl, baseram 
a87f					;ld hl, baseusermem 
a87f			 
a87f e5			push hl   ; sacreifical push 
a880			 
a880			.ldouscanm: 
a880 e1				pop hl 
a881			.ldouscan: 
a881				if DEBUG_FORTH_WORDS 
a881					DMARK "LSs" 
a881 f5				push af  
a882 3a 96 a8			ld a, (.dmark)  
a885 32 6b ee			ld (debug_mark),a  
a888 3a 97 a8			ld a, (.dmark+1)  
a88b 32 6c ee			ld (debug_mark+1),a  
a88e 3a 98 a8			ld a, (.dmark+2)  
a891 32 6d ee			ld (debug_mark+2),a  
a894 18 03			jr .pastdmark  
a896 ..			.dmark: db "LSs"  
a899 f1			.pastdmark: pop af  
a89a			endm  
# End of macro DMARK
a89a					CALLMONITOR 
a89a cd 6f ee			call debug_vector  
a89d				endm  
# End of macro CALLMONITOR
a89d				endif 
a89d				; skip dict stub 
a89d cd 49 a0				call forth_tok_next 
a8a0			 
a8a0			 
a8a0			; while we have words to look for 
a8a0			 
a8a0 7e				ld a, (hl)      
a8a1				if DEBUG_FORTH_WORDS 
a8a1					DMARK "LSk" 
a8a1 f5				push af  
a8a2 3a b6 a8			ld a, (.dmark)  
a8a5 32 6b ee			ld (debug_mark),a  
a8a8 3a b7 a8			ld a, (.dmark+1)  
a8ab 32 6c ee			ld (debug_mark+1),a  
a8ae 3a b8 a8			ld a, (.dmark+2)  
a8b1 32 6d ee			ld (debug_mark+2),a  
a8b4 18 03			jr .pastdmark  
a8b6 ..			.dmark: db "LSk"  
a8b9 f1			.pastdmark: pop af  
a8ba			endm  
# End of macro DMARK
a8ba					CALLMONITOR 
a8ba cd 6f ee			call debug_vector  
a8bd				endm  
# End of macro CALLMONITOR
a8bd				endif 
a8bd					;cp WORD_SYS_END 
a8bd					;jp z, .lunotfound 
a8bd			 
a8bd					; if we hit non uwords then gone too far 
a8bd fe 01				cp WORD_SYS_UWORD 
a8bf c2 ef a9				jp nz, .lunotfound 
a8c2			 
a8c2				if DEBUG_FORTH_WORDS 
a8c2					DMARK "LSu" 
a8c2 f5				push af  
a8c3 3a d7 a8			ld a, (.dmark)  
a8c6 32 6b ee			ld (debug_mark),a  
a8c9 3a d8 a8			ld a, (.dmark+1)  
a8cc 32 6c ee			ld (debug_mark+1),a  
a8cf 3a d9 a8			ld a, (.dmark+2)  
a8d2 32 6d ee			ld (debug_mark+2),a  
a8d5 18 03			jr .pastdmark  
a8d7 ..			.dmark: db "LSu"  
a8da f1			.pastdmark: pop af  
a8db			endm  
# End of macro DMARK
a8db					CALLMONITOR 
a8db cd 6f ee			call debug_vector  
a8de				endm  
# End of macro CALLMONITOR
a8de				endif 
a8de			 
a8de					; found a uword but is it the one we want... 
a8de			 
a8de c5					push bc     ; uword to find is on bc 
a8df d1					pop de 
a8e0			 
a8e0 e5					push hl  ; to save the ptr 
a8e1			 
a8e1					; skip opcode 
a8e1 23					inc hl  
a8e2					; skip next ptr 
a8e2 23					inc hl  
a8e3 23					inc hl 
a8e4					; skip len 
a8e4 23					inc hl 
a8e5			 
a8e5				if DEBUG_FORTH_WORDS 
a8e5					DMARK "LSc" 
a8e5 f5				push af  
a8e6 3a fa a8			ld a, (.dmark)  
a8e9 32 6b ee			ld (debug_mark),a  
a8ec 3a fb a8			ld a, (.dmark+1)  
a8ef 32 6c ee			ld (debug_mark+1),a  
a8f2 3a fc a8			ld a, (.dmark+2)  
a8f5 32 6d ee			ld (debug_mark+2),a  
a8f8 18 03			jr .pastdmark  
a8fa ..			.dmark: db "LSc"  
a8fd f1			.pastdmark: pop af  
a8fe			endm  
# End of macro DMARK
a8fe					CALLMONITOR 
a8fe cd 6f ee			call debug_vector  
a901				endm  
# End of macro CALLMONITOR
a901				endif 
a901 cd 72 91				call strcmp 
a904 c2 80 a8				jp nz, .ldouscanm 
a907				 
a907			 
a907			 
a907					; we have a uword so push its name to the stack 
a907			 
a907			;	   	push hl  ; save so we can move to next dict block 
a907 e1			pop hl 
a908			 
a908				if DEBUG_FORTH_WORDS 
a908					DMARK "LSm" 
a908 f5				push af  
a909 3a 1d a9			ld a, (.dmark)  
a90c 32 6b ee			ld (debug_mark),a  
a90f 3a 1e a9			ld a, (.dmark+1)  
a912 32 6c ee			ld (debug_mark+1),a  
a915 3a 1f a9			ld a, (.dmark+2)  
a918 32 6d ee			ld (debug_mark+2),a  
a91b 18 03			jr .pastdmark  
a91d ..			.dmark: db "LSm"  
a920 f1			.pastdmark: pop af  
a921			endm  
# End of macro DMARK
a921					CALLMONITOR 
a921 cd 6f ee			call debug_vector  
a924				endm  
# End of macro CALLMONITOR
a924				endif 
a924			 
a924					; skip opcode 
a924 23					inc hl  
a925					; skip next ptr 
a925 23					inc hl  
a926 23					inc hl 
a927					; skip len 
a927 7e					ld a, (hl)   ; save length to add 
a928				if DEBUG_FORTH_WORDS 
a928					DMARK "LS2" 
a928 f5				push af  
a929 3a 3d a9			ld a, (.dmark)  
a92c 32 6b ee			ld (debug_mark),a  
a92f 3a 3e a9			ld a, (.dmark+1)  
a932 32 6c ee			ld (debug_mark+1),a  
a935 3a 3f a9			ld a, (.dmark+2)  
a938 32 6d ee			ld (debug_mark+2),a  
a93b 18 03			jr .pastdmark  
a93d ..			.dmark: db "LS2"  
a940 f1			.pastdmark: pop af  
a941			endm  
# End of macro DMARK
a941					CALLMONITOR 
a941 cd 6f ee			call debug_vector  
a944				endm  
# End of macro CALLMONITOR
a944				endif 
a944			 
a944					; save this location 
a944				 
a944 e5					push hl 
a945			 
a945 23					inc hl 
a946 11 c3 e2				ld de, scratch+2 
a949 4f					ld c, a 
a94a 06 00				ld b, 0 
a94c			 
a94c				if DEBUG_FORTH_WORDS 
a94c					DMARK "LSn" 
a94c f5				push af  
a94d 3a 61 a9			ld a, (.dmark)  
a950 32 6b ee			ld (debug_mark),a  
a953 3a 62 a9			ld a, (.dmark+1)  
a956 32 6c ee			ld (debug_mark+1),a  
a959 3a 63 a9			ld a, (.dmark+2)  
a95c 32 6d ee			ld (debug_mark+2),a  
a95f 18 03			jr .pastdmark  
a961 ..			.dmark: db "LSn"  
a964 f1			.pastdmark: pop af  
a965			endm  
# End of macro DMARK
a965					CALLMONITOR 
a965 cd 6f ee			call debug_vector  
a968				endm  
# End of macro CALLMONITOR
a968				endif 
a968			 
a968					; copy uword name to scratch 
a968			 
a968 ed b0				ldir 
a96a			 
a96a 1b					dec de 
a96b 3e 20				ld a, ' '    ; change null to space 
a96d 12					ld (de), a 
a96e			 
a96e 13					inc de 
a96f			 
a96f d5					push de 
a970 c1					pop bc     ; move scratch pointer to end of word name and save it 
a971			 
a971 e1					pop hl 
a972 7e					ld a, (hl) 
a973					;inc hl 
a973					; skip word string 
a973 cd dc 8c				call addatohl 
a976			 
a976 23					inc hl 
a977			 
a977				if DEBUG_FORTH_WORDS 
a977					DMARK "LS3" 
a977 f5				push af  
a978 3a 8c a9			ld a, (.dmark)  
a97b 32 6b ee			ld (debug_mark),a  
a97e 3a 8d a9			ld a, (.dmark+1)  
a981 32 6c ee			ld (debug_mark+1),a  
a984 3a 8e a9			ld a, (.dmark+2)  
a987 32 6d ee			ld (debug_mark+2),a  
a98a 18 03			jr .pastdmark  
a98c ..			.dmark: db "LS3"  
a98f f1			.pastdmark: pop af  
a990			endm  
# End of macro DMARK
a990					CALLMONITOR 
a990 cd 6f ee			call debug_vector  
a993				endm  
# End of macro CALLMONITOR
a993				endif 
a993					; should now be at the start of the machine code to setup the eval of the uword 
a993					; now locate the ptr to the string defintion 
a993			 
a993					; skip ld hl, 
a993					; then load the ptr 
a993			; TODO use get from hl ptr 
a993 23					inc hl 
a994 5e					ld e, (hl) 
a995 23					inc hl 
a996 56					ld d, (hl) 
a997 eb					ex de, hl 
a998			 
a998			 
a998				if DEBUG_FORTH_WORDS 
a998					DMARK "LSt" 
a998 f5				push af  
a999 3a ad a9			ld a, (.dmark)  
a99c 32 6b ee			ld (debug_mark),a  
a99f 3a ae a9			ld a, (.dmark+1)  
a9a2 32 6c ee			ld (debug_mark+1),a  
a9a5 3a af a9			ld a, (.dmark+2)  
a9a8 32 6d ee			ld (debug_mark+2),a  
a9ab 18 03			jr .pastdmark  
a9ad ..			.dmark: db "LSt"  
a9b0 f1			.pastdmark: pop af  
a9b1			endm  
# End of macro DMARK
a9b1					CALLMONITOR 
a9b1 cd 6f ee			call debug_vector  
a9b4				endm  
# End of macro CALLMONITOR
a9b4				endif 
a9b4			 
a9b4			; cant push right now due to tokenised strings  
a9b4			 
a9b4			; get the destination of where to copy this definition to. 
a9b4			 
a9b4 c5					push bc 
a9b5 d1					pop de 
a9b6			 
a9b6 7e			.listl:         ld a,(hl) 
a9b7 fe 00				cp 0 
a9b9 28 09				jr z, .lreplsp     ; replace zero with space 
a9bb					;cp FORTH_END_BUFFER 
a9bb fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9bd 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9bf				 
a9bf					; just copy this char as is then 
a9bf			 
a9bf 12					ld (de), a 
a9c0			 
a9c0 23			.listnxt:	inc hl 
a9c1 13					inc de 
a9c2 18 f2				jr .listl 
a9c4			 
a9c4 3e 20		.lreplsp:	ld a,' ' 
a9c6 12					ld (de), a 
a9c7 18 f7				jr .listnxt 
a9c9			 
a9c9			; close up uword def 
a9c9			 
a9c9			.listdone: 
a9c9 12					ld (de), a 
a9ca 13					inc de 
a9cb 3e 00				ld a, 0 
a9cd 12					ld (de), a 
a9ce			 
a9ce			; now have def so clean up and push to stack 
a9ce			 
a9ce 21 c1 e2				ld hl, scratch 
a9d1				if DEBUG_FORTH_WORDS 
a9d1					DMARK "Ltp" 
a9d1 f5				push af  
a9d2 3a e6 a9			ld a, (.dmark)  
a9d5 32 6b ee			ld (debug_mark),a  
a9d8 3a e7 a9			ld a, (.dmark+1)  
a9db 32 6c ee			ld (debug_mark+1),a  
a9de 3a e8 a9			ld a, (.dmark+2)  
a9e1 32 6d ee			ld (debug_mark+2),a  
a9e4 18 03			jr .pastdmark  
a9e6 ..			.dmark: db "Ltp"  
a9e9 f1			.pastdmark: pop af  
a9ea			endm  
# End of macro DMARK
a9ea					CALLMONITOR 
a9ea cd 6f ee			call debug_vector  
a9ed				endm  
# End of macro CALLMONITOR
a9ed				endif 
a9ed			 
a9ed 18 1f			jr .listpush 
a9ef			 
a9ef			;.lnuword:	pop hl 
a9ef			;		call forth_tok_next 
a9ef			;		jp .ldouscan  
a9ef			 
a9ef			.lunotfound:		  
a9ef			 
a9ef				if DEBUG_FORTH_WORDS 
a9ef					DMARK "LSn" 
a9ef f5				push af  
a9f0 3a 04 aa			ld a, (.dmark)  
a9f3 32 6b ee			ld (debug_mark),a  
a9f6 3a 05 aa			ld a, (.dmark+1)  
a9f9 32 6c ee			ld (debug_mark+1),a  
a9fc 3a 06 aa			ld a, (.dmark+2)  
a9ff 32 6d ee			ld (debug_mark+2),a  
aa02 18 03			jr .pastdmark  
aa04 ..			.dmark: db "LSn"  
aa07 f1			.pastdmark: pop af  
aa08			endm  
# End of macro DMARK
aa08					CALLMONITOR 
aa08 cd 6f ee			call debug_vector  
aa0b				endm  
# End of macro CALLMONITOR
aa0b				endif 
aa0b			 
aa0b					 
aa0b			;		FORTH_DSP_POP 
aa0b			;		ld hl, .luno 
aa0b			 
aa0b					NEXTW			 
aa0b c3 f8 9e			jp macro_next 
aa0e				endm 
# End of macro NEXTW
aa0e			 
aa0e			.listpush: 
aa0e				if DEBUG_FORTH_WORDS 
aa0e					DMARK "LS>" 
aa0e f5				push af  
aa0f 3a 23 aa			ld a, (.dmark)  
aa12 32 6b ee			ld (debug_mark),a  
aa15 3a 24 aa			ld a, (.dmark+1)  
aa18 32 6c ee			ld (debug_mark+1),a  
aa1b 3a 25 aa			ld a, (.dmark+2)  
aa1e 32 6d ee			ld (debug_mark+2),a  
aa21 18 03			jr .pastdmark  
aa23 ..			.dmark: db "LS>"  
aa26 f1			.pastdmark: pop af  
aa27			endm  
# End of macro DMARK
aa27					CALLMONITOR 
aa27 cd 6f ee			call debug_vector  
aa2a				endm  
# End of macro CALLMONITOR
aa2a				endif 
aa2a cd b9 9b				call forth_push_str 
aa2d			 
aa2d			 
aa2d			 
aa2d					NEXTW 
aa2d c3 f8 9e			jp macro_next 
aa30				endm 
# End of macro NEXTW
aa30			 
aa30			;.luno:    db "Word not found",0 
aa30			 
aa30			 
aa30			 
aa30			 
aa30			 
aa30			;		push hl   ; save pointer to start of uword def string 
aa30			; 
aa30			;; look for FORTH_EOL_LINE 
aa30			;		ld a, FORTH_END_BUFFER 
aa30			;		call strlent 
aa30			; 
aa30			;		inc hl		 ; space for coln def 
aa30			;		inc hl 
aa30			;		inc hl          ; space for terms 
aa30			;		inc hl 
aa30			; 
aa30			;		ld a, 20   ; TODO get actual length 
aa30			;		call addatohl    ; include a random amount of room for the uword name 
aa30			; 
aa30			;		 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt1" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;		 
aa30			; 
aa30			;; malloc space for the string because we cant change it 
aa30			; 
aa30			;		call malloc 
aa30			;	if DEBUG_FORTH_MALLOC_GUARD 
aa30			;		push af 
aa30			;		call ishlzero 
aa30			;		pop af 
aa30			;		 
aa30			;		call z,malloc_error 
aa30			;	endif 
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt2" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;		pop de 
aa30			;		push hl    ; push the malloc to release later 
aa30			;		push hl   ;  push back a copy for the later stack push 
aa30			;		 
aa30			;; copy the string swapping out the zero terms for spaces 
aa30			; 
aa30			;		; de has our source 
aa30			;		; hl has our dest 
aa30			; 
aa30			;; add the coln def 
aa30			; 
aa30			;		ld a, ':' 
aa30			;		ld (hl), a 
aa30			;		inc hl 
aa30			;		ld a, ' ' 
aa30			;		ld (hl), a 
aa30			;		inc hl 
aa30			; 
aa30			;; add the uname word 
aa30			;		push de   ; save our string for now 
aa30			;		ex de, hl 
aa30			; 
aa30			;		FORTH_DSP_VALUE 
aa30			;		;v5 FORTH_DSP_VALUE 
aa30			; 
aa30			;		inc hl   ; skip type but we know by now this is OK 
aa30			; 
aa30			;.luword:	ld a,(hl) 
aa30			;		cp 0 
aa30			;		jr z, .luword2 
aa30			;		ld (de), a 
aa30			;		inc de 
aa30			;		inc hl 
aa30			;		jr .luword 
aa30			; 
aa30			;.luword2:	ld a, ' ' 
aa30			;		ld (de), a 
aa30			;;		inc hl 
aa30			;;		inc de 
aa30			;;		ld (de), a 
aa30			;;		inc hl 
aa30			;		inc de 
aa30			; 
aa30			;		ex de, hl 
aa30			;		pop de 
aa30			;		 
aa30			;		 
aa30			; 
aa30			;; detoken that string and copy it 
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt2" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;.ldetok:	ld a, (de) 
aa30			;		cp FORTH_END_BUFFER 
aa30			;		jr z, .ldetokend 
aa30			;		; swap out any zero term for space 
aa30			;		cp 0 
aa30			;		jr nz, .ldetoknext 
aa30			;		ld a, ' ' 
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "LtS" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;.ldetoknext:	ld (hl), a 
aa30			;		inc de 
aa30			;		inc hl 
aa30			;		jr .ldetok 
aa30			; 
aa30			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa30			;		ld (hl), a  
aa30			; 
aa30			;; free that temp malloc 
aa30			; 
aa30			;		pop hl    
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt4" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;		call forth_apushstrhl 
aa30			; 
aa30			;		; get rid of temp malloc area 
aa30			; 
aa30			;		pop hl 
aa30			;		call free 
aa30			; 
aa30			;		jr .ludone 
aa30			; 
aa30			;.lnuword:	pop hl 
aa30			;		call forth_tok_next 
aa30			;		jp .ldouscan  
aa30			; 
aa30			;.ludone:		 pop hl 
aa30			; 
aa30					NEXTW 
aa30 c3 f8 9e			jp macro_next 
aa33				endm 
# End of macro NEXTW
aa33			 
aa33			.FORGET: 
aa33				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa33 5d				db WORD_SYS_CORE+73             
aa34 ac aa			dw .NOP            
aa36 07				db 6 + 1 
aa37 .. 00			db "FORGET",0              
aa3e				endm 
# End of macro CWHEAD
aa3e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa3e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa3e			; | |  
aa3e			; | | e.g. "MORE" forget 
aa3e					if DEBUG_FORTH_WORDS_KEY 
aa3e						DMARK "FRG" 
aa3e f5				push af  
aa3f 3a 53 aa			ld a, (.dmark)  
aa42 32 6b ee			ld (debug_mark),a  
aa45 3a 54 aa			ld a, (.dmark+1)  
aa48 32 6c ee			ld (debug_mark+1),a  
aa4b 3a 55 aa			ld a, (.dmark+2)  
aa4e 32 6d ee			ld (debug_mark+2),a  
aa51 18 03			jr .pastdmark  
aa53 ..			.dmark: db "FRG"  
aa56 f1			.pastdmark: pop af  
aa57			endm  
# End of macro DMARK
aa57						CALLMONITOR 
aa57 cd 6f ee			call debug_vector  
aa5a				endm  
# End of macro CALLMONITOR
aa5a					endif 
aa5a			 
aa5a				; find uword 
aa5a			        ; update start of word with "_" 
aa5a				; replace uword with deleted flag 
aa5a			 
aa5a			 
aa5a			;	if DEBUG_FORTH_WORDS 
aa5a			;		DMARK "FOG" 
aa5a			;		CALLMONITOR 
aa5a			;	endif 
aa5a			 
aa5a			 
aa5a					; Get ptr to the word we need to look up 
aa5a			 
aa5a					FORTH_DSP_VALUEHL 
aa5a cd 42 9d			call macro_dsp_valuehl 
aa5d				endm 
# End of macro FORTH_DSP_VALUEHL
aa5d					;v5 FORTH_DSP_VALUE 
aa5d				; TODO type check 
aa5d			;		inc hl    ; Skip type check  
aa5d e5					push hl 
aa5e c1					pop bc 
aa5f			;		ex de, hl    ; put into DE 
aa5f			 
aa5f			 
aa5f 21 3d e4				ld hl, baseram 
aa62					;ld hl, baseusermem 
aa62			 
aa62				; skip dict stub 
aa62			;	call forth_tok_next 
aa62 e5			push hl   ; sacreifical push 
aa63			 
aa63			.fldouscanm: 
aa63 e1				pop hl 
aa64			.fldouscan: 
aa64			;	if DEBUG_FORTH_WORDS 
aa64			;		DMARK "LSs" 
aa64			;		CALLMONITOR 
aa64			;	endif 
aa64				; skip dict stub 
aa64 cd 49 a0				call forth_tok_next 
aa67			 
aa67			 
aa67			; while we have words to look for 
aa67			 
aa67 7e				ld a, (hl)      
aa68			;	if DEBUG_FORTH_WORDS 
aa68			;		DMARK "LSk" 
aa68			;		CALLMONITOR 
aa68			;	endif 
aa68 fe 00				cp WORD_SYS_END 
aa6a ca a6 aa				jp z, .flunotfound 
aa6d fe 01				cp WORD_SYS_UWORD 
aa6f c2 64 aa				jp nz, .fldouscan 
aa72			 
aa72			;	if DEBUG_FORTH_WORDS 
aa72			;		DMARK "LSu" 
aa72			;		CALLMONITOR 
aa72			;	endif 
aa72			 
aa72					; found a uword but is it the one we want... 
aa72			 
aa72 c5					push bc     ; uword to find is on bc 
aa73 d1					pop de 
aa74			 
aa74 e5					push hl  ; to save the ptr 
aa75			 
aa75					; skip opcode 
aa75 23					inc hl  
aa76					; skip next ptr 
aa76 23					inc hl  
aa77 23					inc hl 
aa78					; skip len 
aa78 23					inc hl 
aa79			 
aa79			;	if DEBUG_FORTH_WORDS 
aa79			;		DMARK "LSc" 
aa79			;		CALLMONITOR 
aa79			;	endif 
aa79 cd 72 91				call strcmp 
aa7c c2 63 aa				jp nz, .fldouscanm 
aa7f			; 
aa7f			; 
aa7f			;; while we have words to look for 
aa7f			; 
aa7f			;.fdouscan:	ld a, (hl)      
aa7f			;	if DEBUG_FORTH_WORDS 
aa7f			;		DMARK "LSs" 
aa7f			;		CALLMONITOR 
aa7f			;	endif 
aa7f			;		cp WORD_SYS_END 
aa7f			;		jp z, .fudone 
aa7f			;		cp WORD_SYS_UWORD 
aa7f			;		jp nz, .fnuword 
aa7f			; 
aa7f			;	if DEBUG_FORTH_WORDS 
aa7f			;		DMARK "FGu" 
aa7f			;		CALLMONITOR 
aa7f			;	endif 
aa7f			; 
aa7f			;		; found a uword but is it the one we want... 
aa7f			; 
aa7f			; 
aa7f			;	        pop de   ; get back the dsp name 
aa7f			;		push de 
aa7f			; 
aa7f			;		push hl  ; to save the ptr 
aa7f			; 
aa7f			;		; skip opcode 
aa7f			;		inc hl  
aa7f			;		; skip next ptr 
aa7f			;		inc hl  
aa7f			;		inc hl 
aa7f			;		; skip len 
aa7f			;		inc hl 
aa7f			; 
aa7f			;	if DEBUG_FORTH_WORDS 
aa7f			;		DMARK "FGc" 
aa7f			;		CALLMONITOR 
aa7f			;	endif 
aa7f			;		call strcmp 
aa7f			;		jp nz, .fnuword 
aa7f			 
aa7f			 
aa7f e1			pop hl 
aa80			 
aa80				 
aa80				if DEBUG_FORTH_WORDS 
aa80					DMARK "FGm" 
aa80 f5				push af  
aa81 3a 95 aa			ld a, (.dmark)  
aa84 32 6b ee			ld (debug_mark),a  
aa87 3a 96 aa			ld a, (.dmark+1)  
aa8a 32 6c ee			ld (debug_mark+1),a  
aa8d 3a 97 aa			ld a, (.dmark+2)  
aa90 32 6d ee			ld (debug_mark+2),a  
aa93 18 03			jr .pastdmark  
aa95 ..			.dmark: db "FGm"  
aa98 f1			.pastdmark: pop af  
aa99			endm  
# End of macro DMARK
aa99					CALLMONITOR 
aa99 cd 6f ee			call debug_vector  
aa9c				endm  
# End of macro CALLMONITOR
aa9c				endif 
aa9c			 
aa9c			 
aa9c			 
aa9c					; we have a uword so push its name to the stack 
aa9c			 
aa9c			;	   	push hl  ; save so we can move to next dict block 
aa9c			;pop hl 
aa9c			 
aa9c					; update opcode to deleted 
aa9c 3e 03				ld a, WORD_SYS_DELETED 
aa9e 77					ld (hl), a 
aa9f			 
aa9f 23					inc hl  
aaa0					; skip next ptr 
aaa0 23					inc hl  
aaa1 23					inc hl 
aaa2					; skip len 
aaa2 23					inc hl 
aaa3			 
aaa3					; TODO change parser to skip deleted words but for now mark it out 
aaa3 3e 5f				ld a, "_" 
aaa5 77					ld  (hl),a 
aaa6			 
aaa6			;		jr .fudone 
aaa6			; 
aaa6			;.fnuword:	pop hl 
aaa6			;		call forth_tok_next 
aaa6			;		jp .fdouscan  
aaa6			 
aaa6			.flunotfound:		  
aaa6			 
aaa6			 
aaa6					 
aaa6					FORTH_DSP_POP 
aaa6 cd fa 9d			call macro_forth_dsp_pop 
aaa9				endm 
# End of macro FORTH_DSP_POP
aaa9			;		ld hl, .luno 
aaa9			;.fudone:		 pop hl 
aaa9					NEXTW 
aaa9 c3 f8 9e			jp macro_next 
aaac				endm 
# End of macro NEXTW
aaac			.NOP: 
aaac				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aaac 61				db WORD_SYS_CORE+77             
aaad d3 aa			dw .COMO            
aaaf 04				db 3 + 1 
aab0 .. 00			db "NOP",0              
aab4				endm 
# End of macro CWHEAD
aab4			; | NOP (  --  ) Do nothing | DONE 
aab4					if DEBUG_FORTH_WORDS_KEY 
aab4						DMARK "NOP" 
aab4 f5				push af  
aab5 3a c9 aa			ld a, (.dmark)  
aab8 32 6b ee			ld (debug_mark),a  
aabb 3a ca aa			ld a, (.dmark+1)  
aabe 32 6c ee			ld (debug_mark+1),a  
aac1 3a cb aa			ld a, (.dmark+2)  
aac4 32 6d ee			ld (debug_mark+2),a  
aac7 18 03			jr .pastdmark  
aac9 ..			.dmark: db "NOP"  
aacc f1			.pastdmark: pop af  
aacd			endm  
# End of macro DMARK
aacd						CALLMONITOR 
aacd cd 6f ee			call debug_vector  
aad0				endm  
# End of macro CALLMONITOR
aad0					endif 
aad0				       NEXTW 
aad0 c3 f8 9e			jp macro_next 
aad3				endm 
# End of macro NEXTW
aad3			.COMO: 
aad3				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aad3 6e				db WORD_SYS_CORE+90             
aad4 25 ab			dw .COMC            
aad6 02				db 1 + 1 
aad7 .. 00			db "(",0              
aad9				endm 
# End of macro CWHEAD
aad9			; | ( ( -- )  Start of comment | DONE 
aad9			 
aad9			 
aad9 2a c2 e5				ld hl, ( os_tok_ptr) 
aadc 11 20 ab			ld de, .closepar 
aadf					 
aadf					if DEBUG_FORTH_WORDS 
aadf						DMARK ").." 
aadf f5				push af  
aae0 3a f4 aa			ld a, (.dmark)  
aae3 32 6b ee			ld (debug_mark),a  
aae6 3a f5 aa			ld a, (.dmark+1)  
aae9 32 6c ee			ld (debug_mark+1),a  
aaec 3a f6 aa			ld a, (.dmark+2)  
aaef 32 6d ee			ld (debug_mark+2),a  
aaf2 18 03			jr .pastdmark  
aaf4 ..			.dmark: db ").."  
aaf7 f1			.pastdmark: pop af  
aaf8			endm  
# End of macro DMARK
aaf8						CALLMONITOR 
aaf8 cd 6f ee			call debug_vector  
aafb				endm  
# End of macro CALLMONITOR
aafb					endif 
aafb cd 13 a0			call findnexttok  
aafe			 
aafe					if DEBUG_FORTH_WORDS 
aafe						DMARK "IF5" 
aafe f5				push af  
aaff 3a 13 ab			ld a, (.dmark)  
ab02 32 6b ee			ld (debug_mark),a  
ab05 3a 14 ab			ld a, (.dmark+1)  
ab08 32 6c ee			ld (debug_mark+1),a  
ab0b 3a 15 ab			ld a, (.dmark+2)  
ab0e 32 6d ee			ld (debug_mark+2),a  
ab11 18 03			jr .pastdmark  
ab13 ..			.dmark: db "IF5"  
ab16 f1			.pastdmark: pop af  
ab17			endm  
# End of macro DMARK
ab17						CALLMONITOR 
ab17 cd 6f ee			call debug_vector  
ab1a				endm  
# End of macro CALLMONITOR
ab1a					endif 
ab1a				; replace below with ) exec using tok_ptr 
ab1a 22 c2 e5			ld (os_tok_ptr), hl 
ab1d c3 89 9f			jp exec1 
ab20			 
ab20 .. 00			.closepar:   db ")",0 
ab22			 
ab22				       NEXTW 
ab22 c3 f8 9e			jp macro_next 
ab25				endm 
# End of macro NEXTW
ab25			.COMC: 
ab25				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab25 6f				db WORD_SYS_CORE+91             
ab26 2e ab			dw .SCRATCH            
ab28 02				db 1 + 1 
ab29 .. 00			db ")",0              
ab2b				endm 
# End of macro CWHEAD
ab2b			; | ) ( -- )  End of comment |  DONE  
ab2b				       NEXTW 
ab2b c3 f8 9e			jp macro_next 
ab2e				endm 
# End of macro NEXTW
ab2e			 
ab2e			.SCRATCH: 
ab2e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab2e 6f				db WORD_SYS_CORE+91             
ab2f 69 ab			dw .INC            
ab31 08				db 7 + 1 
ab32 .. 00			db "SCRATCH",0              
ab3a				endm 
# End of macro CWHEAD
ab3a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab3a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab3a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab3a			; | |  
ab3a			; | | e.g.    : score $00 scratch ; 
ab3a			; | |  
ab3a			; | | $00 score ! 
ab3a			; | | $01 score +! 
ab3a			; | |  
ab3a			; | | e.g.   : varword $0a scratch ;  
ab3a			; | | 
ab3a			; | | $8000 varword ! 
ab3a					if DEBUG_FORTH_WORDS_KEY 
ab3a						DMARK "SCR" 
ab3a f5				push af  
ab3b 3a 4f ab			ld a, (.dmark)  
ab3e 32 6b ee			ld (debug_mark),a  
ab41 3a 50 ab			ld a, (.dmark+1)  
ab44 32 6c ee			ld (debug_mark+1),a  
ab47 3a 51 ab			ld a, (.dmark+2)  
ab4a 32 6d ee			ld (debug_mark+2),a  
ab4d 18 03			jr .pastdmark  
ab4f ..			.dmark: db "SCR"  
ab52 f1			.pastdmark: pop af  
ab53			endm  
# End of macro DMARK
ab53						CALLMONITOR 
ab53 cd 6f ee			call debug_vector  
ab56				endm  
# End of macro CALLMONITOR
ab56					endif 
ab56			 
ab56					FORTH_DSP_VALUEHL 
ab56 cd 42 9d			call macro_dsp_valuehl 
ab59				endm 
# End of macro FORTH_DSP_VALUEHL
ab59				 
ab59					FORTH_DSP_POP 
ab59 cd fa 9d			call macro_forth_dsp_pop 
ab5c				endm 
# End of macro FORTH_DSP_POP
ab5c			 
ab5c 7d					ld a, l 
ab5d 21 e6 e7				ld hl, os_var_array 
ab60 cd dc 8c				call addatohl 
ab63			 
ab63 cd 4b 9b				call forth_push_numhl 
ab66			 
ab66				       NEXTW 
ab66 c3 f8 9e			jp macro_next 
ab69				endm 
# End of macro NEXTW
ab69			 
ab69			.INC: 
ab69				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab69 6f				db WORD_SYS_CORE+91             
ab6a bd ab			dw .DEC            
ab6c 03				db 2 + 1 
ab6d .. 00			db "+!",0              
ab70				endm 
# End of macro CWHEAD
ab70			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab70					if DEBUG_FORTH_WORDS_KEY 
ab70						DMARK "+s_" 
ab70 f5				push af  
ab71 3a 85 ab			ld a, (.dmark)  
ab74 32 6b ee			ld (debug_mark),a  
ab77 3a 86 ab			ld a, (.dmark+1)  
ab7a 32 6c ee			ld (debug_mark+1),a  
ab7d 3a 87 ab			ld a, (.dmark+2)  
ab80 32 6d ee			ld (debug_mark+2),a  
ab83 18 03			jr .pastdmark  
ab85 ..			.dmark: db "+s_"  
ab88 f1			.pastdmark: pop af  
ab89			endm  
# End of macro DMARK
ab89						CALLMONITOR 
ab89 cd 6f ee			call debug_vector  
ab8c				endm  
# End of macro CALLMONITOR
ab8c					endif 
ab8c			 
ab8c					FORTH_DSP_VALUEHL 
ab8c cd 42 9d			call macro_dsp_valuehl 
ab8f				endm 
# End of macro FORTH_DSP_VALUEHL
ab8f			 
ab8f e5					push hl   ; save address 
ab90			 
ab90					FORTH_DSP_POP 
ab90 cd fa 9d			call macro_forth_dsp_pop 
ab93				endm 
# End of macro FORTH_DSP_POP
ab93			 
ab93					FORTH_DSP_VALUEHL 
ab93 cd 42 9d			call macro_dsp_valuehl 
ab96				endm 
# End of macro FORTH_DSP_VALUEHL
ab96			 
ab96					FORTH_DSP_POP 
ab96 cd fa 9d			call macro_forth_dsp_pop 
ab99				endm 
# End of macro FORTH_DSP_POP
ab99			 
ab99					; hl contains value to add to byte at a 
ab99				 
ab99 eb					ex de, hl 
ab9a			 
ab9a e1					pop hl 
ab9b			 
ab9b					if DEBUG_FORTH_WORDS 
ab9b						DMARK "INC" 
ab9b f5				push af  
ab9c 3a b0 ab			ld a, (.dmark)  
ab9f 32 6b ee			ld (debug_mark),a  
aba2 3a b1 ab			ld a, (.dmark+1)  
aba5 32 6c ee			ld (debug_mark+1),a  
aba8 3a b2 ab			ld a, (.dmark+2)  
abab 32 6d ee			ld (debug_mark+2),a  
abae 18 03			jr .pastdmark  
abb0 ..			.dmark: db "INC"  
abb3 f1			.pastdmark: pop af  
abb4			endm  
# End of macro DMARK
abb4						CALLMONITOR 
abb4 cd 6f ee			call debug_vector  
abb7				endm  
# End of macro CALLMONITOR
abb7					endif 
abb7			 
abb7 7e					ld a,(hl) 
abb8 83					add e 
abb9 77					ld (hl),a 
abba			 
abba			 
abba			 
abba				       NEXTW 
abba c3 f8 9e			jp macro_next 
abbd				endm 
# End of macro NEXTW
abbd			 
abbd			.DEC: 
abbd				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abbd 6f				db WORD_SYS_CORE+91             
abbe 0e ac			dw .INC2            
abc0 03				db 2 + 1 
abc1 .. 00			db "-!",0              
abc4				endm 
# End of macro CWHEAD
abc4			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abc4					if DEBUG_FORTH_WORDS_KEY 
abc4						DMARK "-s_" 
abc4 f5				push af  
abc5 3a d9 ab			ld a, (.dmark)  
abc8 32 6b ee			ld (debug_mark),a  
abcb 3a da ab			ld a, (.dmark+1)  
abce 32 6c ee			ld (debug_mark+1),a  
abd1 3a db ab			ld a, (.dmark+2)  
abd4 32 6d ee			ld (debug_mark+2),a  
abd7 18 03			jr .pastdmark  
abd9 ..			.dmark: db "-s_"  
abdc f1			.pastdmark: pop af  
abdd			endm  
# End of macro DMARK
abdd						CALLMONITOR 
abdd cd 6f ee			call debug_vector  
abe0				endm  
# End of macro CALLMONITOR
abe0					endif 
abe0			 
abe0					FORTH_DSP_VALUEHL 
abe0 cd 42 9d			call macro_dsp_valuehl 
abe3				endm 
# End of macro FORTH_DSP_VALUEHL
abe3			 
abe3 e5					push hl   ; save address 
abe4			 
abe4					FORTH_DSP_POP 
abe4 cd fa 9d			call macro_forth_dsp_pop 
abe7				endm 
# End of macro FORTH_DSP_POP
abe7			 
abe7					FORTH_DSP_VALUEHL 
abe7 cd 42 9d			call macro_dsp_valuehl 
abea				endm 
# End of macro FORTH_DSP_VALUEHL
abea			 
abea					; hl contains value to add to byte at a 
abea				 
abea eb					ex de, hl 
abeb			 
abeb e1					pop hl 
abec			 
abec					if DEBUG_FORTH_WORDS 
abec						DMARK "DEC" 
abec f5				push af  
abed 3a 01 ac			ld a, (.dmark)  
abf0 32 6b ee			ld (debug_mark),a  
abf3 3a 02 ac			ld a, (.dmark+1)  
abf6 32 6c ee			ld (debug_mark+1),a  
abf9 3a 03 ac			ld a, (.dmark+2)  
abfc 32 6d ee			ld (debug_mark+2),a  
abff 18 03			jr .pastdmark  
ac01 ..			.dmark: db "DEC"  
ac04 f1			.pastdmark: pop af  
ac05			endm  
# End of macro DMARK
ac05						CALLMONITOR 
ac05 cd 6f ee			call debug_vector  
ac08				endm  
# End of macro CALLMONITOR
ac08					endif 
ac08			 
ac08 7e					ld a,(hl) 
ac09 93					sub e 
ac0a 77					ld (hl),a 
ac0b			 
ac0b			 
ac0b			 
ac0b				       NEXTW 
ac0b c3 f8 9e			jp macro_next 
ac0e				endm 
# End of macro NEXTW
ac0e			 
ac0e			.INC2: 
ac0e				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ac0e 6f				db WORD_SYS_CORE+91             
ac0f b8 ac			dw .DEC2            
ac11 04				db 3 + 1 
ac12 .. 00			db "+2!",0              
ac16				endm 
# End of macro CWHEAD
ac16			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac16			 
ac16					if DEBUG_FORTH_WORDS_KEY 
ac16						DMARK "+2s" 
ac16 f5				push af  
ac17 3a 2b ac			ld a, (.dmark)  
ac1a 32 6b ee			ld (debug_mark),a  
ac1d 3a 2c ac			ld a, (.dmark+1)  
ac20 32 6c ee			ld (debug_mark+1),a  
ac23 3a 2d ac			ld a, (.dmark+2)  
ac26 32 6d ee			ld (debug_mark+2),a  
ac29 18 03			jr .pastdmark  
ac2b ..			.dmark: db "+2s"  
ac2e f1			.pastdmark: pop af  
ac2f			endm  
# End of macro DMARK
ac2f						CALLMONITOR 
ac2f cd 6f ee			call debug_vector  
ac32				endm  
# End of macro CALLMONITOR
ac32					endif 
ac32			 
ac32					; Address 
ac32			 
ac32					FORTH_DSP_VALUEHL 
ac32 cd 42 9d			call macro_dsp_valuehl 
ac35				endm 
# End of macro FORTH_DSP_VALUEHL
ac35			 
ac35 e5					push hl    ; save address 
ac36			 
ac36					; load content into de 
ac36			 
ac36 5e					ld e,(hl) 
ac37 23					inc hl 
ac38 56					ld d, (hl) 
ac39			 
ac39					if DEBUG_FORTH_WORDS 
ac39						DMARK "+2a" 
ac39 f5				push af  
ac3a 3a 4e ac			ld a, (.dmark)  
ac3d 32 6b ee			ld (debug_mark),a  
ac40 3a 4f ac			ld a, (.dmark+1)  
ac43 32 6c ee			ld (debug_mark+1),a  
ac46 3a 50 ac			ld a, (.dmark+2)  
ac49 32 6d ee			ld (debug_mark+2),a  
ac4c 18 03			jr .pastdmark  
ac4e ..			.dmark: db "+2a"  
ac51 f1			.pastdmark: pop af  
ac52			endm  
# End of macro DMARK
ac52						CALLMONITOR 
ac52 cd 6f ee			call debug_vector  
ac55				endm  
# End of macro CALLMONITOR
ac55					endif 
ac55			 
ac55					FORTH_DSP_POP 
ac55 cd fa 9d			call macro_forth_dsp_pop 
ac58				endm 
# End of macro FORTH_DSP_POP
ac58			 
ac58					; Get value to add 
ac58			 
ac58					FORTH_DSP_VALUE 
ac58 cd 2b 9d			call macro_forth_dsp_value 
ac5b				endm 
# End of macro FORTH_DSP_VALUE
ac5b			 
ac5b					if DEBUG_FORTH_WORDS 
ac5b						DMARK "+2v" 
ac5b f5				push af  
ac5c 3a 70 ac			ld a, (.dmark)  
ac5f 32 6b ee			ld (debug_mark),a  
ac62 3a 71 ac			ld a, (.dmark+1)  
ac65 32 6c ee			ld (debug_mark+1),a  
ac68 3a 72 ac			ld a, (.dmark+2)  
ac6b 32 6d ee			ld (debug_mark+2),a  
ac6e 18 03			jr .pastdmark  
ac70 ..			.dmark: db "+2v"  
ac73 f1			.pastdmark: pop af  
ac74			endm  
# End of macro DMARK
ac74						CALLMONITOR 
ac74 cd 6f ee			call debug_vector  
ac77				endm  
# End of macro CALLMONITOR
ac77					endif 
ac77			 
ac77 19					add hl, de 
ac78			 
ac78					if DEBUG_FORTH_WORDS 
ac78						DMARK "+2+" 
ac78 f5				push af  
ac79 3a 8d ac			ld a, (.dmark)  
ac7c 32 6b ee			ld (debug_mark),a  
ac7f 3a 8e ac			ld a, (.dmark+1)  
ac82 32 6c ee			ld (debug_mark+1),a  
ac85 3a 8f ac			ld a, (.dmark+2)  
ac88 32 6d ee			ld (debug_mark+2),a  
ac8b 18 03			jr .pastdmark  
ac8d ..			.dmark: db "+2+"  
ac90 f1			.pastdmark: pop af  
ac91			endm  
# End of macro DMARK
ac91						CALLMONITOR 
ac91 cd 6f ee			call debug_vector  
ac94				endm  
# End of macro CALLMONITOR
ac94					endif 
ac94			 
ac94					; move result to de 
ac94			 
ac94 eb					ex de, hl 
ac95			 
ac95					; Address 
ac95			 
ac95 e1					pop hl 
ac96			 
ac96					; save it back 
ac96			 
ac96 73					ld (hl), e 
ac97 23					inc hl 
ac98 72					ld (hl), d 
ac99			 
ac99					if DEBUG_FORTH_WORDS 
ac99						DMARK "+2e" 
ac99 f5				push af  
ac9a 3a ae ac			ld a, (.dmark)  
ac9d 32 6b ee			ld (debug_mark),a  
aca0 3a af ac			ld a, (.dmark+1)  
aca3 32 6c ee			ld (debug_mark+1),a  
aca6 3a b0 ac			ld a, (.dmark+2)  
aca9 32 6d ee			ld (debug_mark+2),a  
acac 18 03			jr .pastdmark  
acae ..			.dmark: db "+2e"  
acb1 f1			.pastdmark: pop af  
acb2			endm  
# End of macro DMARK
acb2						CALLMONITOR 
acb2 cd 6f ee			call debug_vector  
acb5				endm  
# End of macro CALLMONITOR
acb5					endif 
acb5			 
acb5			 
acb5			 
acb5			 
acb5			 
acb5				       NEXTW 
acb5 c3 f8 9e			jp macro_next 
acb8				endm 
# End of macro NEXTW
acb8			 
acb8			.DEC2: 
acb8				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
acb8 6f				db WORD_SYS_CORE+91             
acb9 64 ad			dw .GET2            
acbb 04				db 3 + 1 
acbc .. 00			db "-2!",0              
acc0				endm 
# End of macro CWHEAD
acc0			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acc0			 
acc0			 
acc0					if DEBUG_FORTH_WORDS_KEY 
acc0						DMARK "-2s" 
acc0 f5				push af  
acc1 3a d5 ac			ld a, (.dmark)  
acc4 32 6b ee			ld (debug_mark),a  
acc7 3a d6 ac			ld a, (.dmark+1)  
acca 32 6c ee			ld (debug_mark+1),a  
accd 3a d7 ac			ld a, (.dmark+2)  
acd0 32 6d ee			ld (debug_mark+2),a  
acd3 18 03			jr .pastdmark  
acd5 ..			.dmark: db "-2s"  
acd8 f1			.pastdmark: pop af  
acd9			endm  
# End of macro DMARK
acd9						CALLMONITOR 
acd9 cd 6f ee			call debug_vector  
acdc				endm  
# End of macro CALLMONITOR
acdc					endif 
acdc			 
acdc					; Address 
acdc			 
acdc					FORTH_DSP_VALUEHL 
acdc cd 42 9d			call macro_dsp_valuehl 
acdf				endm 
# End of macro FORTH_DSP_VALUEHL
acdf			 
acdf e5					push hl    ; save address 
ace0			 
ace0					; load content into de 
ace0			 
ace0 5e					ld e,(hl) 
ace1 23					inc hl 
ace2 56					ld d, (hl) 
ace3			 
ace3					if DEBUG_FORTH_WORDS 
ace3						DMARK "-2a" 
ace3 f5				push af  
ace4 3a f8 ac			ld a, (.dmark)  
ace7 32 6b ee			ld (debug_mark),a  
acea 3a f9 ac			ld a, (.dmark+1)  
aced 32 6c ee			ld (debug_mark+1),a  
acf0 3a fa ac			ld a, (.dmark+2)  
acf3 32 6d ee			ld (debug_mark+2),a  
acf6 18 03			jr .pastdmark  
acf8 ..			.dmark: db "-2a"  
acfb f1			.pastdmark: pop af  
acfc			endm  
# End of macro DMARK
acfc						CALLMONITOR 
acfc cd 6f ee			call debug_vector  
acff				endm  
# End of macro CALLMONITOR
acff					endif 
acff			 
acff					FORTH_DSP_POP 
acff cd fa 9d			call macro_forth_dsp_pop 
ad02				endm 
# End of macro FORTH_DSP_POP
ad02			 
ad02					; Get value to remove 
ad02			 
ad02					FORTH_DSP_VALUE 
ad02 cd 2b 9d			call macro_forth_dsp_value 
ad05				endm 
# End of macro FORTH_DSP_VALUE
ad05			 
ad05					if DEBUG_FORTH_WORDS 
ad05						DMARK "-2v" 
ad05 f5				push af  
ad06 3a 1a ad			ld a, (.dmark)  
ad09 32 6b ee			ld (debug_mark),a  
ad0c 3a 1b ad			ld a, (.dmark+1)  
ad0f 32 6c ee			ld (debug_mark+1),a  
ad12 3a 1c ad			ld a, (.dmark+2)  
ad15 32 6d ee			ld (debug_mark+2),a  
ad18 18 03			jr .pastdmark  
ad1a ..			.dmark: db "-2v"  
ad1d f1			.pastdmark: pop af  
ad1e			endm  
# End of macro DMARK
ad1e						CALLMONITOR 
ad1e cd 6f ee			call debug_vector  
ad21				endm  
# End of macro CALLMONITOR
ad21					endif 
ad21			 
ad21 eb					ex de, hl 
ad22 ed 52				sbc hl, de 
ad24			 
ad24					if DEBUG_FORTH_WORDS 
ad24						DMARK "-2d" 
ad24 f5				push af  
ad25 3a 39 ad			ld a, (.dmark)  
ad28 32 6b ee			ld (debug_mark),a  
ad2b 3a 3a ad			ld a, (.dmark+1)  
ad2e 32 6c ee			ld (debug_mark+1),a  
ad31 3a 3b ad			ld a, (.dmark+2)  
ad34 32 6d ee			ld (debug_mark+2),a  
ad37 18 03			jr .pastdmark  
ad39 ..			.dmark: db "-2d"  
ad3c f1			.pastdmark: pop af  
ad3d			endm  
# End of macro DMARK
ad3d						CALLMONITOR 
ad3d cd 6f ee			call debug_vector  
ad40				endm  
# End of macro CALLMONITOR
ad40					endif 
ad40			 
ad40					; move result to de 
ad40			 
ad40 eb					ex de, hl 
ad41			 
ad41					; Address 
ad41			 
ad41 e1					pop hl 
ad42			 
ad42					; save it back 
ad42			 
ad42 73					ld (hl), e 
ad43 23					inc hl 
ad44 72					ld (hl), d 
ad45			 
ad45					if DEBUG_FORTH_WORDS 
ad45						DMARK "-2e" 
ad45 f5				push af  
ad46 3a 5a ad			ld a, (.dmark)  
ad49 32 6b ee			ld (debug_mark),a  
ad4c 3a 5b ad			ld a, (.dmark+1)  
ad4f 32 6c ee			ld (debug_mark+1),a  
ad52 3a 5c ad			ld a, (.dmark+2)  
ad55 32 6d ee			ld (debug_mark+2),a  
ad58 18 03			jr .pastdmark  
ad5a ..			.dmark: db "-2e"  
ad5d f1			.pastdmark: pop af  
ad5e			endm  
# End of macro DMARK
ad5e						CALLMONITOR 
ad5e cd 6f ee			call debug_vector  
ad61				endm  
# End of macro CALLMONITOR
ad61					endif 
ad61			 
ad61			 
ad61			 
ad61			 
ad61			 
ad61				       NEXTW 
ad61 c3 f8 9e			jp macro_next 
ad64				endm 
# End of macro NEXTW
ad64			.GET2: 
ad64				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad64 6f				db WORD_SYS_CORE+91             
ad65 94 ad			dw .BANG2            
ad67 03				db 2 + 1 
ad68 .. 00			db "2@",0              
ad6b				endm 
# End of macro CWHEAD
ad6b			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad6b					if DEBUG_FORTH_WORDS_KEY 
ad6b						DMARK "2A_" 
ad6b f5				push af  
ad6c 3a 80 ad			ld a, (.dmark)  
ad6f 32 6b ee			ld (debug_mark),a  
ad72 3a 81 ad			ld a, (.dmark+1)  
ad75 32 6c ee			ld (debug_mark+1),a  
ad78 3a 82 ad			ld a, (.dmark+2)  
ad7b 32 6d ee			ld (debug_mark+2),a  
ad7e 18 03			jr .pastdmark  
ad80 ..			.dmark: db "2A_"  
ad83 f1			.pastdmark: pop af  
ad84			endm  
# End of macro DMARK
ad84						CALLMONITOR 
ad84 cd 6f ee			call debug_vector  
ad87				endm  
# End of macro CALLMONITOR
ad87					endif 
ad87			 
ad87					FORTH_DSP_VALUEHL 
ad87 cd 42 9d			call macro_dsp_valuehl 
ad8a				endm 
# End of macro FORTH_DSP_VALUEHL
ad8a			 
ad8a 5e					ld e, (hl) 
ad8b 23					inc hl 
ad8c 56					ld d, (hl) 
ad8d			 
ad8d eb					ex de, hl 
ad8e			 
ad8e cd 4b 9b				call forth_push_numhl 
ad91			 
ad91				       NEXTW 
ad91 c3 f8 9e			jp macro_next 
ad94				endm 
# End of macro NEXTW
ad94			.BANG2: 
ad94				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad94 6f				db WORD_SYS_CORE+91             
ad95 cc ad			dw .CONFIG            
ad97 03				db 2 + 1 
ad98 .. 00			db "2!",0              
ad9b				endm 
# End of macro CWHEAD
ad9b			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad9b					if DEBUG_FORTH_WORDS_KEY 
ad9b						DMARK "2S_" 
ad9b f5				push af  
ad9c 3a b0 ad			ld a, (.dmark)  
ad9f 32 6b ee			ld (debug_mark),a  
ada2 3a b1 ad			ld a, (.dmark+1)  
ada5 32 6c ee			ld (debug_mark+1),a  
ada8 3a b2 ad			ld a, (.dmark+2)  
adab 32 6d ee			ld (debug_mark+2),a  
adae 18 03			jr .pastdmark  
adb0 ..			.dmark: db "2S_"  
adb3 f1			.pastdmark: pop af  
adb4			endm  
# End of macro DMARK
adb4						CALLMONITOR 
adb4 cd 6f ee			call debug_vector  
adb7				endm  
# End of macro CALLMONITOR
adb7					endif 
adb7			 
adb7					FORTH_DSP_VALUEHL 
adb7 cd 42 9d			call macro_dsp_valuehl 
adba				endm 
# End of macro FORTH_DSP_VALUEHL
adba			 
adba e5					push hl   ; save address 
adbb			 
adbb			 
adbb					FORTH_DSP_POP 
adbb cd fa 9d			call macro_forth_dsp_pop 
adbe				endm 
# End of macro FORTH_DSP_POP
adbe			 
adbe					 
adbe					FORTH_DSP_VALUEHL 
adbe cd 42 9d			call macro_dsp_valuehl 
adc1				endm 
# End of macro FORTH_DSP_VALUEHL
adc1			 
adc1					FORTH_DSP_POP 
adc1 cd fa 9d			call macro_forth_dsp_pop 
adc4				endm 
# End of macro FORTH_DSP_POP
adc4			 
adc4 eb					ex de, hl    ; value now in de 
adc5			 
adc5 e1					pop hl 
adc6			 
adc6 73					ld (hl), e 
adc7			 
adc7 23					inc hl 
adc8			 
adc8 72					ld (hl), d 
adc9			 
adc9			 
adc9				       NEXTW 
adc9 c3 f8 9e			jp macro_next 
adcc				endm 
# End of macro NEXTW
adcc			.CONFIG: 
adcc				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
adcc 6f				db WORD_SYS_CORE+91             
adcd dd ad			dw .ADTOS            
adcf 07				db 6 + 1 
add0 .. 00			db "CONFIG",0              
add7				endm 
# End of macro CWHEAD
add7			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
add7			 
add7 cd 3c 93				call config 
adda					NEXTW 
adda c3 f8 9e			jp macro_next 
addd				endm 
# End of macro NEXTW
addd			 
addd			.ADTOS: 
addd				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
addd 6f				db WORD_SYS_CORE+91             
adde f3 ad			dw .SBTOS            
ade0 03				db 2 + 1 
ade1 .. 00			db "1+",0              
ade4				endm 
# End of macro CWHEAD
ade4			; | 1+ ( u -- u )  Increment value on TOS | DONE 
ade4			 
ade4					FORTH_DSP_VALUEHL 
ade4 cd 42 9d			call macro_dsp_valuehl 
ade7				endm 
# End of macro FORTH_DSP_VALUEHL
ade7 e5					push hl 
ade8			 
ade8					FORTH_DSP_POP 
ade8 cd fa 9d			call macro_forth_dsp_pop 
adeb				endm 
# End of macro FORTH_DSP_POP
adeb e1					pop hl 
adec			 
adec 23					inc hl 
aded cd 4b 9b				call forth_push_numhl 
adf0					 
adf0					NEXTW 
adf0 c3 f8 9e			jp macro_next 
adf3				endm 
# End of macro NEXTW
adf3			.SBTOS: 
adf3				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
adf3 6f				db WORD_SYS_CORE+91             
adf4 09 ae			dw .ADSTORE            
adf6 03				db 2 + 1 
adf7 .. 00			db "1-",0              
adfa				endm 
# End of macro CWHEAD
adfa			; | 1- ( u -- u )  Decrement value on TOS | DONE 
adfa			 
adfa					FORTH_DSP_VALUEHL 
adfa cd 42 9d			call macro_dsp_valuehl 
adfd				endm 
# End of macro FORTH_DSP_VALUEHL
adfd e5					push hl 
adfe			 
adfe					FORTH_DSP_POP 
adfe cd fa 9d			call macro_forth_dsp_pop 
ae01				endm 
# End of macro FORTH_DSP_POP
ae01 e1					pop hl 
ae02			 
ae02 2b					dec hl 
ae03 cd 4b 9b				call forth_push_numhl 
ae06					 
ae06					NEXTW 
ae06 c3 f8 9e			jp macro_next 
ae09				endm 
# End of macro NEXTW
ae09			.ADSTORE: 
ae09				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ae09 6f				db WORD_SYS_CORE+91             
ae0a 1f ae			dw .ADWSTORE            
ae0c 04				db 3 + 1 
ae0d .. 00			db "1+!",0              
ae11				endm 
# End of macro CWHEAD
ae11			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ae11			 
ae11					FORTH_DSP_VALUEHL 
ae11 cd 42 9d			call macro_dsp_valuehl 
ae14				endm 
# End of macro FORTH_DSP_VALUEHL
ae14 e5					push hl 
ae15			 
ae15					FORTH_DSP_POP 
ae15 cd fa 9d			call macro_forth_dsp_pop 
ae18				endm 
# End of macro FORTH_DSP_POP
ae18 e1					pop hl 
ae19			 
ae19 7e					ld a, (hl) 
ae1a 3c					inc a 
ae1b 77					ld (hl), a 
ae1c					 
ae1c					NEXTW 
ae1c c3 f8 9e			jp macro_next 
ae1f				endm 
# End of macro NEXTW
ae1f			.ADWSTORE: 
ae1f				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
ae1f 6f				db WORD_SYS_CORE+91             
ae20 3d ae			dw .ENDCORE            
ae22 05				db 4 + 1 
ae23 .. 00			db "1+2!",0              
ae28				endm 
# End of macro CWHEAD
ae28			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ae28			 
ae28					FORTH_DSP_VALUEHL 
ae28 cd 42 9d			call macro_dsp_valuehl 
ae2b				endm 
# End of macro FORTH_DSP_VALUEHL
ae2b e5					push hl 
ae2c			 
ae2c					FORTH_DSP_POP 
ae2c cd fa 9d			call macro_forth_dsp_pop 
ae2f				endm 
# End of macro FORTH_DSP_POP
ae2f e1					pop hl 
ae30			 
ae30 e5					push hl 
ae31			 
ae31 cd 7a 9e				call loadwordinhl 
ae34 23					inc hl 
ae35			 
ae35 d1					pop de 
ae36 eb					ex de, hl 
ae37 73					ld (hl), e 
ae38 23					inc hl 
ae39 72					ld (hl), d 
ae3a					 
ae3a					NEXTW 
ae3a c3 f8 9e			jp macro_next 
ae3d				endm 
# End of macro NEXTW
ae3d			.ENDCORE: 
ae3d			 
ae3d			; eof 
ae3d			 
ae3d			 
# End of file forth_words_core.asm
ae3d			include "forth_words_flow.asm" 
ae3d			 
ae3d			; | ## Program Flow Words 
ae3d			 
ae3d			.IF: 
ae3d				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ae3d 1e				db WORD_SYS_CORE+10             
ae3e 32 af			dw .THEN            
ae40 03				db 2 + 1 
ae41 .. 00			db "IF",0              
ae44				endm 
# End of macro CWHEAD
ae44			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ae44			; 
ae44					if DEBUG_FORTH_WORDS_KEY 
ae44						DMARK "IF." 
ae44 f5				push af  
ae45 3a 59 ae			ld a, (.dmark)  
ae48 32 6b ee			ld (debug_mark),a  
ae4b 3a 5a ae			ld a, (.dmark+1)  
ae4e 32 6c ee			ld (debug_mark+1),a  
ae51 3a 5b ae			ld a, (.dmark+2)  
ae54 32 6d ee			ld (debug_mark+2),a  
ae57 18 03			jr .pastdmark  
ae59 ..			.dmark: db "IF."  
ae5c f1			.pastdmark: pop af  
ae5d			endm  
# End of macro DMARK
ae5d						CALLMONITOR 
ae5d cd 6f ee			call debug_vector  
ae60				endm  
# End of macro CALLMONITOR
ae60					endif 
ae60			; eval TOS 
ae60			 
ae60				FORTH_DSP_VALUEHL 
ae60 cd 42 9d			call macro_dsp_valuehl 
ae63				endm 
# End of macro FORTH_DSP_VALUEHL
ae63			 
ae63			;	push hl 
ae63				FORTH_DSP_POP 
ae63 cd fa 9d			call macro_forth_dsp_pop 
ae66				endm 
# End of macro FORTH_DSP_POP
ae66			;	pop hl 
ae66			 
ae66					if DEBUG_FORTH_WORDS 
ae66						DMARK "IF1" 
ae66 f5				push af  
ae67 3a 7b ae			ld a, (.dmark)  
ae6a 32 6b ee			ld (debug_mark),a  
ae6d 3a 7c ae			ld a, (.dmark+1)  
ae70 32 6c ee			ld (debug_mark+1),a  
ae73 3a 7d ae			ld a, (.dmark+2)  
ae76 32 6d ee			ld (debug_mark+2),a  
ae79 18 03			jr .pastdmark  
ae7b ..			.dmark: db "IF1"  
ae7e f1			.pastdmark: pop af  
ae7f			endm  
# End of macro DMARK
ae7f						CALLMONITOR 
ae7f cd 6f ee			call debug_vector  
ae82				endm  
# End of macro CALLMONITOR
ae82					endif 
ae82 b7				or a        ; clear carry flag 
ae83 11 00 00			ld de, 0 
ae86 eb				ex de,hl 
ae87 ed 52			sbc hl, de 
ae89 c2 13 af			jp nz, .iftrue 
ae8c			 
ae8c					if DEBUG_FORTH_WORDS 
ae8c						DMARK "IF2" 
ae8c f5				push af  
ae8d 3a a1 ae			ld a, (.dmark)  
ae90 32 6b ee			ld (debug_mark),a  
ae93 3a a2 ae			ld a, (.dmark+1)  
ae96 32 6c ee			ld (debug_mark+1),a  
ae99 3a a3 ae			ld a, (.dmark+2)  
ae9c 32 6d ee			ld (debug_mark+2),a  
ae9f 18 03			jr .pastdmark  
aea1 ..			.dmark: db "IF2"  
aea4 f1			.pastdmark: pop af  
aea5			endm  
# End of macro DMARK
aea5						CALLMONITOR 
aea5 cd 6f ee			call debug_vector  
aea8				endm  
# End of macro CALLMONITOR
aea8					endif 
aea8			 
aea8			; if not true then skip to THEN 
aea8			 
aea8				; TODO get tok_ptr 
aea8				; TODO consume toks until we get to THEN 
aea8			 
aea8 2a c2 e5			ld hl, (os_tok_ptr) 
aeab					if DEBUG_FORTH_WORDS 
aeab						DMARK "IF3" 
aeab f5				push af  
aeac 3a c0 ae			ld a, (.dmark)  
aeaf 32 6b ee			ld (debug_mark),a  
aeb2 3a c1 ae			ld a, (.dmark+1)  
aeb5 32 6c ee			ld (debug_mark+1),a  
aeb8 3a c2 ae			ld a, (.dmark+2)  
aebb 32 6d ee			ld (debug_mark+2),a  
aebe 18 03			jr .pastdmark  
aec0 ..			.dmark: db "IF3"  
aec3 f1			.pastdmark: pop af  
aec4			endm  
# End of macro DMARK
aec4						CALLMONITOR 
aec4 cd 6f ee			call debug_vector  
aec7				endm  
# End of macro CALLMONITOR
aec7						 
aec7					endif 
aec7 11 0e af			ld de, .ifthen 
aeca					if DEBUG_FORTH_WORDS 
aeca						DMARK "IF4" 
aeca f5				push af  
aecb 3a df ae			ld a, (.dmark)  
aece 32 6b ee			ld (debug_mark),a  
aed1 3a e0 ae			ld a, (.dmark+1)  
aed4 32 6c ee			ld (debug_mark+1),a  
aed7 3a e1 ae			ld a, (.dmark+2)  
aeda 32 6d ee			ld (debug_mark+2),a  
aedd 18 03			jr .pastdmark  
aedf ..			.dmark: db "IF4"  
aee2 f1			.pastdmark: pop af  
aee3			endm  
# End of macro DMARK
aee3						CALLMONITOR 
aee3 cd 6f ee			call debug_vector  
aee6				endm  
# End of macro CALLMONITOR
aee6					endif 
aee6 cd 13 a0			call findnexttok  
aee9			 
aee9					if DEBUG_FORTH_WORDS 
aee9						DMARK "IF5" 
aee9 f5				push af  
aeea 3a fe ae			ld a, (.dmark)  
aeed 32 6b ee			ld (debug_mark),a  
aef0 3a ff ae			ld a, (.dmark+1)  
aef3 32 6c ee			ld (debug_mark+1),a  
aef6 3a 00 af			ld a, (.dmark+2)  
aef9 32 6d ee			ld (debug_mark+2),a  
aefc 18 03			jr .pastdmark  
aefe ..			.dmark: db "IF5"  
af01 f1			.pastdmark: pop af  
af02			endm  
# End of macro DMARK
af02						CALLMONITOR 
af02 cd 6f ee			call debug_vector  
af05				endm  
# End of macro CALLMONITOR
af05					endif 
af05				; TODO replace below with ; exec using tok_ptr 
af05 22 c2 e5			ld (os_tok_ptr), hl 
af08 c3 89 9f			jp exec1 
af0b				NEXTW 
af0b c3 f8 9e			jp macro_next 
af0e				endm 
# End of macro NEXTW
af0e			 
af0e .. 00		.ifthen:  db "THEN",0 
af13			 
af13			.iftrue:		 
af13				; Exec next words normally 
af13			 
af13				; if true then exec following IF as normal 
af13					if DEBUG_FORTH_WORDS 
af13						DMARK "IFT" 
af13 f5				push af  
af14 3a 28 af			ld a, (.dmark)  
af17 32 6b ee			ld (debug_mark),a  
af1a 3a 29 af			ld a, (.dmark+1)  
af1d 32 6c ee			ld (debug_mark+1),a  
af20 3a 2a af			ld a, (.dmark+2)  
af23 32 6d ee			ld (debug_mark+2),a  
af26 18 03			jr .pastdmark  
af28 ..			.dmark: db "IFT"  
af2b f1			.pastdmark: pop af  
af2c			endm  
# End of macro DMARK
af2c						CALLMONITOR 
af2c cd 6f ee			call debug_vector  
af2f				endm  
# End of macro CALLMONITOR
af2f					endif 
af2f			 
af2f					NEXTW 
af2f c3 f8 9e			jp macro_next 
af32				endm 
# End of macro NEXTW
af32			.THEN: 
af32				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
af32 1f				db WORD_SYS_CORE+11             
af33 5a af			dw .ELSE            
af35 05				db 4 + 1 
af36 .. 00			db "THEN",0              
af3b				endm 
# End of macro CWHEAD
af3b			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
af3b					if DEBUG_FORTH_WORDS_KEY 
af3b						DMARK "THN" 
af3b f5				push af  
af3c 3a 50 af			ld a, (.dmark)  
af3f 32 6b ee			ld (debug_mark),a  
af42 3a 51 af			ld a, (.dmark+1)  
af45 32 6c ee			ld (debug_mark+1),a  
af48 3a 52 af			ld a, (.dmark+2)  
af4b 32 6d ee			ld (debug_mark+2),a  
af4e 18 03			jr .pastdmark  
af50 ..			.dmark: db "THN"  
af53 f1			.pastdmark: pop af  
af54			endm  
# End of macro DMARK
af54						CALLMONITOR 
af54 cd 6f ee			call debug_vector  
af57				endm  
# End of macro CALLMONITOR
af57					endif 
af57					NEXTW 
af57 c3 f8 9e			jp macro_next 
af5a				endm 
# End of macro NEXTW
af5a			.ELSE: 
af5a				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af5a 20				db WORD_SYS_CORE+12             
af5b 82 af			dw .DO            
af5d 03				db 2 + 1 
af5e .. 00			db "ELSE",0              
af63				endm 
# End of macro CWHEAD
af63			; | ELSE ( -- ) Not supported - does nothing | TODO 
af63			 
af63					if DEBUG_FORTH_WORDS_KEY 
af63						DMARK "ELS" 
af63 f5				push af  
af64 3a 78 af			ld a, (.dmark)  
af67 32 6b ee			ld (debug_mark),a  
af6a 3a 79 af			ld a, (.dmark+1)  
af6d 32 6c ee			ld (debug_mark+1),a  
af70 3a 7a af			ld a, (.dmark+2)  
af73 32 6d ee			ld (debug_mark+2),a  
af76 18 03			jr .pastdmark  
af78 ..			.dmark: db "ELS"  
af7b f1			.pastdmark: pop af  
af7c			endm  
# End of macro DMARK
af7c						CALLMONITOR 
af7c cd 6f ee			call debug_vector  
af7f				endm  
# End of macro CALLMONITOR
af7f					endif 
af7f			 
af7f			 
af7f					NEXTW 
af7f c3 f8 9e			jp macro_next 
af82				endm 
# End of macro NEXTW
af82			.DO: 
af82				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af82 21				db WORD_SYS_CORE+13             
af83 a9 b0			dw .LOOP            
af85 03				db 2 + 1 
af86 .. 00			db "DO",0              
af89				endm 
# End of macro CWHEAD
af89			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af89			 
af89					if DEBUG_FORTH_WORDS_KEY 
af89						DMARK "DO." 
af89 f5				push af  
af8a 3a 9e af			ld a, (.dmark)  
af8d 32 6b ee			ld (debug_mark),a  
af90 3a 9f af			ld a, (.dmark+1)  
af93 32 6c ee			ld (debug_mark+1),a  
af96 3a a0 af			ld a, (.dmark+2)  
af99 32 6d ee			ld (debug_mark+2),a  
af9c 18 03			jr .pastdmark  
af9e ..			.dmark: db "DO."  
afa1 f1			.pastdmark: pop af  
afa2			endm  
# End of macro DMARK
afa2						CALLMONITOR 
afa2 cd 6f ee			call debug_vector  
afa5				endm  
# End of macro CALLMONITOR
afa5					endif 
afa5			;  push pc to rsp stack past the DO 
afa5			 
afa5 2a c2 e5				ld hl, (os_tok_ptr) 
afa8 23					inc hl   ; D 
afa9 23					inc hl  ; O 
afaa 23					inc hl   ; null 
afab					if DEBUG_FORTH_WORDS 
afab						DMARK "DO2" 
afab f5				push af  
afac 3a c0 af			ld a, (.dmark)  
afaf 32 6b ee			ld (debug_mark),a  
afb2 3a c1 af			ld a, (.dmark+1)  
afb5 32 6c ee			ld (debug_mark+1),a  
afb8 3a c2 af			ld a, (.dmark+2)  
afbb 32 6d ee			ld (debug_mark+2),a  
afbe 18 03			jr .pastdmark  
afc0 ..			.dmark: db "DO2"  
afc3 f1			.pastdmark: pop af  
afc4			endm  
# End of macro DMARK
afc4						CALLMONITOR 
afc4 cd 6f ee			call debug_vector  
afc7				endm  
# End of macro CALLMONITOR
afc7					endif 
afc7					FORTH_RSP_NEXT 
afc7 cd f2 9a			call macro_forth_rsp_next 
afca				endm 
# End of macro FORTH_RSP_NEXT
afca					if DEBUG_FORTH_WORDS 
afca						DMARK "DO3" 
afca f5				push af  
afcb 3a df af			ld a, (.dmark)  
afce 32 6b ee			ld (debug_mark),a  
afd1 3a e0 af			ld a, (.dmark+1)  
afd4 32 6c ee			ld (debug_mark+1),a  
afd7 3a e1 af			ld a, (.dmark+2)  
afda 32 6d ee			ld (debug_mark+2),a  
afdd 18 03			jr .pastdmark  
afdf ..			.dmark: db "DO3"  
afe2 f1			.pastdmark: pop af  
afe3			endm  
# End of macro DMARK
afe3						CALLMONITOR 
afe3 cd 6f ee			call debug_vector  
afe6				endm  
# End of macro CALLMONITOR
afe6					endif 
afe6			 
afe6					;if DEBUG_FORTH_WORDS 
afe6				;		push hl 
afe6			;		endif  
afe6			 
afe6			; get counters from data stack 
afe6			 
afe6			 
afe6					FORTH_DSP_VALUEHL 
afe6 cd 42 9d			call macro_dsp_valuehl 
afe9				endm 
# End of macro FORTH_DSP_VALUEHL
afe9 e5					push hl		 ; hl now has starting counter which needs to be tos 
afea			 
afea					if DEBUG_FORTH_WORDS 
afea						DMARK "DO4" 
afea f5				push af  
afeb 3a ff af			ld a, (.dmark)  
afee 32 6b ee			ld (debug_mark),a  
aff1 3a 00 b0			ld a, (.dmark+1)  
aff4 32 6c ee			ld (debug_mark+1),a  
aff7 3a 01 b0			ld a, (.dmark+2)  
affa 32 6d ee			ld (debug_mark+2),a  
affd 18 03			jr .pastdmark  
afff ..			.dmark: db "DO4"  
b002 f1			.pastdmark: pop af  
b003			endm  
# End of macro DMARK
b003						CALLMONITOR 
b003 cd 6f ee			call debug_vector  
b006				endm  
# End of macro CALLMONITOR
b006					endif 
b006					FORTH_DSP_POP 
b006 cd fa 9d			call macro_forth_dsp_pop 
b009				endm 
# End of macro FORTH_DSP_POP
b009			 
b009					if DEBUG_FORTH_WORDS 
b009						DMARK "DO5" 
b009 f5				push af  
b00a 3a 1e b0			ld a, (.dmark)  
b00d 32 6b ee			ld (debug_mark),a  
b010 3a 1f b0			ld a, (.dmark+1)  
b013 32 6c ee			ld (debug_mark+1),a  
b016 3a 20 b0			ld a, (.dmark+2)  
b019 32 6d ee			ld (debug_mark+2),a  
b01c 18 03			jr .pastdmark  
b01e ..			.dmark: db "DO5"  
b021 f1			.pastdmark: pop af  
b022			endm  
# End of macro DMARK
b022						CALLMONITOR 
b022 cd 6f ee			call debug_vector  
b025				endm  
# End of macro CALLMONITOR
b025					endif 
b025			 
b025					FORTH_DSP_VALUEHL 
b025 cd 42 9d			call macro_dsp_valuehl 
b028				endm 
# End of macro FORTH_DSP_VALUEHL
b028			;		push hl		 ; hl now has starting limit counter 
b028			 
b028					if DEBUG_FORTH_WORDS 
b028						DMARK "DO6" 
b028 f5				push af  
b029 3a 3d b0			ld a, (.dmark)  
b02c 32 6b ee			ld (debug_mark),a  
b02f 3a 3e b0			ld a, (.dmark+1)  
b032 32 6c ee			ld (debug_mark+1),a  
b035 3a 3f b0			ld a, (.dmark+2)  
b038 32 6d ee			ld (debug_mark+2),a  
b03b 18 03			jr .pastdmark  
b03d ..			.dmark: db "DO6"  
b040 f1			.pastdmark: pop af  
b041			endm  
# End of macro DMARK
b041						CALLMONITOR 
b041 cd 6f ee			call debug_vector  
b044				endm  
# End of macro CALLMONITOR
b044					endif 
b044					FORTH_DSP_POP 
b044 cd fa 9d			call macro_forth_dsp_pop 
b047				endm 
# End of macro FORTH_DSP_POP
b047			 
b047			; put counters on the loop stack 
b047			 
b047			;		pop hl			 ; limit counter 
b047 d1					pop de			; start counter 
b048			 
b048					; push limit counter 
b048			 
b048					if DEBUG_FORTH_WORDS 
b048						DMARK "DO7" 
b048 f5				push af  
b049 3a 5d b0			ld a, (.dmark)  
b04c 32 6b ee			ld (debug_mark),a  
b04f 3a 5e b0			ld a, (.dmark+1)  
b052 32 6c ee			ld (debug_mark+1),a  
b055 3a 5f b0			ld a, (.dmark+2)  
b058 32 6d ee			ld (debug_mark+2),a  
b05b 18 03			jr .pastdmark  
b05d ..			.dmark: db "DO7"  
b060 f1			.pastdmark: pop af  
b061			endm  
# End of macro DMARK
b061						CALLMONITOR 
b061 cd 6f ee			call debug_vector  
b064				endm  
# End of macro CALLMONITOR
b064					endif 
b064					FORTH_LOOP_NEXT 
b064 cd 73 9d			call macro_forth_loop_next 
b067				endm 
# End of macro FORTH_LOOP_NEXT
b067			 
b067					; push start counter 
b067			 
b067 eb					ex de, hl 
b068					if DEBUG_FORTH_WORDS 
b068						DMARK "DO7" 
b068 f5				push af  
b069 3a 7d b0			ld a, (.dmark)  
b06c 32 6b ee			ld (debug_mark),a  
b06f 3a 7e b0			ld a, (.dmark+1)  
b072 32 6c ee			ld (debug_mark+1),a  
b075 3a 7f b0			ld a, (.dmark+2)  
b078 32 6d ee			ld (debug_mark+2),a  
b07b 18 03			jr .pastdmark  
b07d ..			.dmark: db "DO7"  
b080 f1			.pastdmark: pop af  
b081			endm  
# End of macro DMARK
b081						CALLMONITOR 
b081 cd 6f ee			call debug_vector  
b084				endm  
# End of macro CALLMONITOR
b084					endif 
b084					FORTH_LOOP_NEXT 
b084 cd 73 9d			call macro_forth_loop_next 
b087				endm 
# End of macro FORTH_LOOP_NEXT
b087			 
b087			 
b087					; init first round of I counter 
b087			 
b087 22 e6 e5				ld (os_current_i), hl 
b08a			 
b08a					if DEBUG_FORTH_WORDS 
b08a						DMARK "DO8" 
b08a f5				push af  
b08b 3a 9f b0			ld a, (.dmark)  
b08e 32 6b ee			ld (debug_mark),a  
b091 3a a0 b0			ld a, (.dmark+1)  
b094 32 6c ee			ld (debug_mark+1),a  
b097 3a a1 b0			ld a, (.dmark+2)  
b09a 32 6d ee			ld (debug_mark+2),a  
b09d 18 03			jr .pastdmark  
b09f ..			.dmark: db "DO8"  
b0a2 f1			.pastdmark: pop af  
b0a3			endm  
# End of macro DMARK
b0a3						CALLMONITOR 
b0a3 cd 6f ee			call debug_vector  
b0a6				endm  
# End of macro CALLMONITOR
b0a6					endif 
b0a6			 
b0a6					NEXTW 
b0a6 c3 f8 9e			jp macro_next 
b0a9				endm 
# End of macro NEXTW
b0a9			.LOOP: 
b0a9				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b0a9 22				db WORD_SYS_CORE+14             
b0aa c1 b1			dw .I            
b0ac 05				db 4 + 1 
b0ad .. 00			db "LOOP",0              
b0b2				endm 
# End of macro CWHEAD
b0b2			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b0b2			 
b0b2				; pop tos as current loop count to hl 
b0b2			 
b0b2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0b2			 
b0b2				FORTH_LOOP_TOS 
b0b2 cd a6 9d			call macro_forth_loop_tos 
b0b5				endm 
# End of macro FORTH_LOOP_TOS
b0b5 e5				push hl 
b0b6			 
b0b6					if DEBUG_FORTH_WORDS_KEY 
b0b6						DMARK "LOP" 
b0b6 f5				push af  
b0b7 3a cb b0			ld a, (.dmark)  
b0ba 32 6b ee			ld (debug_mark),a  
b0bd 3a cc b0			ld a, (.dmark+1)  
b0c0 32 6c ee			ld (debug_mark+1),a  
b0c3 3a cd b0			ld a, (.dmark+2)  
b0c6 32 6d ee			ld (debug_mark+2),a  
b0c9 18 03			jr .pastdmark  
b0cb ..			.dmark: db "LOP"  
b0ce f1			.pastdmark: pop af  
b0cf			endm  
# End of macro DMARK
b0cf						CALLMONITOR 
b0cf cd 6f ee			call debug_vector  
b0d2				endm  
# End of macro CALLMONITOR
b0d2					endif 
b0d2				; next item on the stack is the limit. get it 
b0d2			 
b0d2			 
b0d2				FORTH_LOOP_POP 
b0d2 cd b0 9d			call macro_forth_loop_pop 
b0d5				endm 
# End of macro FORTH_LOOP_POP
b0d5			 
b0d5				FORTH_LOOP_TOS 
b0d5 cd a6 9d			call macro_forth_loop_tos 
b0d8				endm 
# End of macro FORTH_LOOP_TOS
b0d8			 
b0d8 d1				pop de		 ; de = i, hl = limit 
b0d9			 
b0d9					if DEBUG_FORTH_WORDS 
b0d9						DMARK "LP1" 
b0d9 f5				push af  
b0da 3a ee b0			ld a, (.dmark)  
b0dd 32 6b ee			ld (debug_mark),a  
b0e0 3a ef b0			ld a, (.dmark+1)  
b0e3 32 6c ee			ld (debug_mark+1),a  
b0e6 3a f0 b0			ld a, (.dmark+2)  
b0e9 32 6d ee			ld (debug_mark+2),a  
b0ec 18 03			jr .pastdmark  
b0ee ..			.dmark: db "LP1"  
b0f1 f1			.pastdmark: pop af  
b0f2			endm  
# End of macro DMARK
b0f2						CALLMONITOR 
b0f2 cd 6f ee			call debug_vector  
b0f5				endm  
# End of macro CALLMONITOR
b0f5					endif 
b0f5			 
b0f5				; go back to previous word 
b0f5			 
b0f5 d5				push de    ; save I for inc later 
b0f6			 
b0f6			 
b0f6				; get limit 
b0f6				;  is I at limit? 
b0f6			 
b0f6			 
b0f6					if DEBUG_FORTH_WORDS 
b0f6						DMARK "LP1" 
b0f6 f5				push af  
b0f7 3a 0b b1			ld a, (.dmark)  
b0fa 32 6b ee			ld (debug_mark),a  
b0fd 3a 0c b1			ld a, (.dmark+1)  
b100 32 6c ee			ld (debug_mark+1),a  
b103 3a 0d b1			ld a, (.dmark+2)  
b106 32 6d ee			ld (debug_mark+2),a  
b109 18 03			jr .pastdmark  
b10b ..			.dmark: db "LP1"  
b10e f1			.pastdmark: pop af  
b10f			endm  
# End of macro DMARK
b10f						CALLMONITOR 
b10f cd 6f ee			call debug_vector  
b112				endm  
# End of macro CALLMONITOR
b112					endif 
b112			 
b112 ed 52			sbc hl, de 
b114			 
b114			 
b114				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b114			 
b114 20 26				jr nz, .loopnotdone 
b116			 
b116 e1				pop hl   ; get rid of saved I 
b117				FORTH_LOOP_POP     ; get rid of limit 
b117 cd b0 9d			call macro_forth_loop_pop 
b11a				endm 
# End of macro FORTH_LOOP_POP
b11a			 
b11a				FORTH_RSP_POP     ; get rid of DO ptr 
b11a cd 13 9b			call macro_forth_rsp_pop 
b11d				endm 
# End of macro FORTH_RSP_POP
b11d			 
b11d			if DEBUG_FORTH_WORDS 
b11d						DMARK "LP>" 
b11d f5				push af  
b11e 3a 32 b1			ld a, (.dmark)  
b121 32 6b ee			ld (debug_mark),a  
b124 3a 33 b1			ld a, (.dmark+1)  
b127 32 6c ee			ld (debug_mark+1),a  
b12a 3a 34 b1			ld a, (.dmark+2)  
b12d 32 6d ee			ld (debug_mark+2),a  
b130 18 03			jr .pastdmark  
b132 ..			.dmark: db "LP>"  
b135 f1			.pastdmark: pop af  
b136			endm  
# End of macro DMARK
b136				CALLMONITOR 
b136 cd 6f ee			call debug_vector  
b139				endm  
# End of macro CALLMONITOR
b139			endif 
b139			 
b139					NEXTW 
b139 c3 f8 9e			jp macro_next 
b13c				endm 
# End of macro NEXTW
b13c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b13c			 
b13c			.loopnotdone: 
b13c			 
b13c e1				pop hl    ; get I 
b13d 23				inc hl 
b13e			 
b13e			   	; save new I 
b13e			 
b13e			 
b13e					; set I counter 
b13e			 
b13e 22 e6 e5				ld (os_current_i), hl 
b141			 
b141					if DEBUG_FORTH_WORDS 
b141						DMARK "LPN" 
b141 f5				push af  
b142 3a 56 b1			ld a, (.dmark)  
b145 32 6b ee			ld (debug_mark),a  
b148 3a 57 b1			ld a, (.dmark+1)  
b14b 32 6c ee			ld (debug_mark+1),a  
b14e 3a 58 b1			ld a, (.dmark+2)  
b151 32 6d ee			ld (debug_mark+2),a  
b154 18 03			jr .pastdmark  
b156 ..			.dmark: db "LPN"  
b159 f1			.pastdmark: pop af  
b15a			endm  
# End of macro DMARK
b15a					CALLMONITOR 
b15a cd 6f ee			call debug_vector  
b15d				endm  
# End of macro CALLMONITOR
b15d					endif 
b15d					 
b15d				FORTH_LOOP_NEXT 
b15d cd 73 9d			call macro_forth_loop_next 
b160				endm 
# End of macro FORTH_LOOP_NEXT
b160			 
b160			 
b160					if DEBUG_FORTH_WORDS 
b160 eb						ex de,hl 
b161					endif 
b161			 
b161			;	; get DO ptr 
b161			; 
b161					if DEBUG_FORTH_WORDS 
b161						DMARK "LP7" 
b161 f5				push af  
b162 3a 76 b1			ld a, (.dmark)  
b165 32 6b ee			ld (debug_mark),a  
b168 3a 77 b1			ld a, (.dmark+1)  
b16b 32 6c ee			ld (debug_mark+1),a  
b16e 3a 78 b1			ld a, (.dmark+2)  
b171 32 6d ee			ld (debug_mark+2),a  
b174 18 03			jr .pastdmark  
b176 ..			.dmark: db "LP7"  
b179 f1			.pastdmark: pop af  
b17a			endm  
# End of macro DMARK
b17a					CALLMONITOR 
b17a cd 6f ee			call debug_vector  
b17d				endm  
# End of macro CALLMONITOR
b17d					endif 
b17d				FORTH_RSP_TOS 
b17d cd 09 9b			call macro_forth_rsp_tos 
b180				endm 
# End of macro FORTH_RSP_TOS
b180			 
b180					if DEBUG_FORTH_WORDS 
b180						DMARK "LP8" 
b180 f5				push af  
b181 3a 95 b1			ld a, (.dmark)  
b184 32 6b ee			ld (debug_mark),a  
b187 3a 96 b1			ld a, (.dmark+1)  
b18a 32 6c ee			ld (debug_mark+1),a  
b18d 3a 97 b1			ld a, (.dmark+2)  
b190 32 6d ee			ld (debug_mark+2),a  
b193 18 03			jr .pastdmark  
b195 ..			.dmark: db "LP8"  
b198 f1			.pastdmark: pop af  
b199			endm  
# End of macro DMARK
b199					CALLMONITOR 
b199 cd 6f ee			call debug_vector  
b19c				endm  
# End of macro CALLMONITOR
b19c					endif 
b19c				;push hl 
b19c			 
b19c				; not going to DO any more 
b19c				; get rid of the RSP pointer as DO will add it back in 
b19c				;FORTH_RSP_POP 
b19c				;pop hl 
b19c			 
b19c				;ld hl,(cli_ret_sp) 
b19c				;ld e, (hl) 
b19c				;inc hl 
b19c				;ld d, (hl) 
b19c				;ex de,hl 
b19c 22 c2 e5			ld (os_tok_ptr), hl 
b19f					if DEBUG_FORTH_WORDS 
b19f						DMARK "LP<" 
b19f f5				push af  
b1a0 3a b4 b1			ld a, (.dmark)  
b1a3 32 6b ee			ld (debug_mark),a  
b1a6 3a b5 b1			ld a, (.dmark+1)  
b1a9 32 6c ee			ld (debug_mark+1),a  
b1ac 3a b6 b1			ld a, (.dmark+2)  
b1af 32 6d ee			ld (debug_mark+2),a  
b1b2 18 03			jr .pastdmark  
b1b4 ..			.dmark: db "LP<"  
b1b7 f1			.pastdmark: pop af  
b1b8			endm  
# End of macro DMARK
b1b8					CALLMONITOR 
b1b8 cd 6f ee			call debug_vector  
b1bb				endm  
# End of macro CALLMONITOR
b1bb				endif 
b1bb c3 89 9f			jp exec1 
b1be			 
b1be					 
b1be			 
b1be			 
b1be					NEXTW 
b1be c3 f8 9e			jp macro_next 
b1c1				endm 
# End of macro NEXTW
b1c1			.I:  
b1c1			 
b1c1				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b1c1 5e				db WORD_SYS_CORE+74             
b1c2 ec b1			dw .DLOOP            
b1c4 02				db 1 + 1 
b1c5 .. 00			db "I",0              
b1c7				endm 
# End of macro CWHEAD
b1c7			; | I ( -- ) Current loop counter | DONE 
b1c7					if DEBUG_FORTH_WORDS_KEY 
b1c7						DMARK "I.." 
b1c7 f5				push af  
b1c8 3a dc b1			ld a, (.dmark)  
b1cb 32 6b ee			ld (debug_mark),a  
b1ce 3a dd b1			ld a, (.dmark+1)  
b1d1 32 6c ee			ld (debug_mark+1),a  
b1d4 3a de b1			ld a, (.dmark+2)  
b1d7 32 6d ee			ld (debug_mark+2),a  
b1da 18 03			jr .pastdmark  
b1dc ..			.dmark: db "I.."  
b1df f1			.pastdmark: pop af  
b1e0			endm  
# End of macro DMARK
b1e0						CALLMONITOR 
b1e0 cd 6f ee			call debug_vector  
b1e3				endm  
# End of macro CALLMONITOR
b1e3					endif 
b1e3			 
b1e3 2a e6 e5				ld hl,(os_current_i) 
b1e6 cd 4b 9b				call forth_push_numhl 
b1e9			 
b1e9					NEXTW 
b1e9 c3 f8 9e			jp macro_next 
b1ec				endm 
# End of macro NEXTW
b1ec			.DLOOP: 
b1ec				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b1ec 5f				db WORD_SYS_CORE+75             
b1ed cd b2			dw .REPEAT            
b1ef 06				db 5 + 1 
b1f0 .. 00			db "-LOOP",0              
b1f6				endm 
# End of macro CWHEAD
b1f6			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b1f6				; pop tos as current loop count to hl 
b1f6					if DEBUG_FORTH_WORDS_KEY 
b1f6						DMARK "-LP" 
b1f6 f5				push af  
b1f7 3a 0b b2			ld a, (.dmark)  
b1fa 32 6b ee			ld (debug_mark),a  
b1fd 3a 0c b2			ld a, (.dmark+1)  
b200 32 6c ee			ld (debug_mark+1),a  
b203 3a 0d b2			ld a, (.dmark+2)  
b206 32 6d ee			ld (debug_mark+2),a  
b209 18 03			jr .pastdmark  
b20b ..			.dmark: db "-LP"  
b20e f1			.pastdmark: pop af  
b20f			endm  
# End of macro DMARK
b20f						CALLMONITOR 
b20f cd 6f ee			call debug_vector  
b212				endm  
# End of macro CALLMONITOR
b212					endif 
b212			 
b212				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b212			 
b212				FORTH_LOOP_TOS 
b212 cd a6 9d			call macro_forth_loop_tos 
b215				endm 
# End of macro FORTH_LOOP_TOS
b215 e5				push hl 
b216			 
b216					if DEBUG_FORTH_WORDS 
b216						DMARK "-LP" 
b216 f5				push af  
b217 3a 2b b2			ld a, (.dmark)  
b21a 32 6b ee			ld (debug_mark),a  
b21d 3a 2c b2			ld a, (.dmark+1)  
b220 32 6c ee			ld (debug_mark+1),a  
b223 3a 2d b2			ld a, (.dmark+2)  
b226 32 6d ee			ld (debug_mark+2),a  
b229 18 03			jr .pastdmark  
b22b ..			.dmark: db "-LP"  
b22e f1			.pastdmark: pop af  
b22f			endm  
# End of macro DMARK
b22f						CALLMONITOR 
b22f cd 6f ee			call debug_vector  
b232				endm  
# End of macro CALLMONITOR
b232					endif 
b232				; next item on the stack is the limit. get it 
b232			 
b232			 
b232				FORTH_LOOP_POP 
b232 cd b0 9d			call macro_forth_loop_pop 
b235				endm 
# End of macro FORTH_LOOP_POP
b235			 
b235				FORTH_LOOP_TOS 
b235 cd a6 9d			call macro_forth_loop_tos 
b238				endm 
# End of macro FORTH_LOOP_TOS
b238			 
b238 d1				pop de		 ; de = i, hl = limit 
b239			 
b239					if DEBUG_FORTH_WORDS 
b239						DMARK "-L1" 
b239 f5				push af  
b23a 3a 4e b2			ld a, (.dmark)  
b23d 32 6b ee			ld (debug_mark),a  
b240 3a 4f b2			ld a, (.dmark+1)  
b243 32 6c ee			ld (debug_mark+1),a  
b246 3a 50 b2			ld a, (.dmark+2)  
b249 32 6d ee			ld (debug_mark+2),a  
b24c 18 03			jr .pastdmark  
b24e ..			.dmark: db "-L1"  
b251 f1			.pastdmark: pop af  
b252			endm  
# End of macro DMARK
b252						CALLMONITOR 
b252 cd 6f ee			call debug_vector  
b255				endm  
# End of macro CALLMONITOR
b255					endif 
b255			 
b255				; go back to previous word 
b255			 
b255 d5				push de    ; save I for inc later 
b256			 
b256			 
b256				; get limit 
b256				;  is I at limit? 
b256			 
b256			 
b256					if DEBUG_FORTH_WORDS 
b256						DMARK "-L1" 
b256 f5				push af  
b257 3a 6b b2			ld a, (.dmark)  
b25a 32 6b ee			ld (debug_mark),a  
b25d 3a 6c b2			ld a, (.dmark+1)  
b260 32 6c ee			ld (debug_mark+1),a  
b263 3a 6d b2			ld a, (.dmark+2)  
b266 32 6d ee			ld (debug_mark+2),a  
b269 18 03			jr .pastdmark  
b26b ..			.dmark: db "-L1"  
b26e f1			.pastdmark: pop af  
b26f			endm  
# End of macro DMARK
b26f						CALLMONITOR 
b26f cd 6f ee			call debug_vector  
b272				endm  
# End of macro CALLMONITOR
b272					endif 
b272			 
b272 ed 52			sbc hl, de 
b274			 
b274			 
b274				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b274			 
b274 20 26				jr nz, .mloopnotdone 
b276			 
b276 e1				pop hl   ; get rid of saved I 
b277				FORTH_LOOP_POP     ; get rid of limit 
b277 cd b0 9d			call macro_forth_loop_pop 
b27a				endm 
# End of macro FORTH_LOOP_POP
b27a			 
b27a				FORTH_RSP_POP     ; get rid of DO ptr 
b27a cd 13 9b			call macro_forth_rsp_pop 
b27d				endm 
# End of macro FORTH_RSP_POP
b27d			 
b27d			if DEBUG_FORTH_WORDS 
b27d						DMARK "-L>" 
b27d f5				push af  
b27e 3a 92 b2			ld a, (.dmark)  
b281 32 6b ee			ld (debug_mark),a  
b284 3a 93 b2			ld a, (.dmark+1)  
b287 32 6c ee			ld (debug_mark+1),a  
b28a 3a 94 b2			ld a, (.dmark+2)  
b28d 32 6d ee			ld (debug_mark+2),a  
b290 18 03			jr .pastdmark  
b292 ..			.dmark: db "-L>"  
b295 f1			.pastdmark: pop af  
b296			endm  
# End of macro DMARK
b296				CALLMONITOR 
b296 cd 6f ee			call debug_vector  
b299				endm  
# End of macro CALLMONITOR
b299			endif 
b299			 
b299					NEXTW 
b299 c3 f8 9e			jp macro_next 
b29c				endm 
# End of macro NEXTW
b29c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b29c			 
b29c			.mloopnotdone: 
b29c			 
b29c e1				pop hl    ; get I 
b29d 2b				dec hl 
b29e			 
b29e			   	; save new I 
b29e			 
b29e			 
b29e					; set I counter 
b29e			 
b29e 22 e6 e5				ld (os_current_i), hl 
b2a1			 
b2a1					 
b2a1				FORTH_LOOP_NEXT 
b2a1 cd 73 9d			call macro_forth_loop_next 
b2a4				endm 
# End of macro FORTH_LOOP_NEXT
b2a4			 
b2a4			 
b2a4					if DEBUG_FORTH_WORDS 
b2a4 eb						ex de,hl 
b2a5					endif 
b2a5			 
b2a5			;	; get DO ptr 
b2a5			; 
b2a5				FORTH_RSP_TOS 
b2a5 cd 09 9b			call macro_forth_rsp_tos 
b2a8				endm 
# End of macro FORTH_RSP_TOS
b2a8			 
b2a8				;push hl 
b2a8			 
b2a8				; not going to DO any more 
b2a8				; get rid of the RSP pointer as DO will add it back in 
b2a8				;FORTH_RSP_POP 
b2a8				;pop hl 
b2a8			 
b2a8			 
b2a8 22 c2 e5			ld (os_tok_ptr), hl 
b2ab					if DEBUG_FORTH_WORDS 
b2ab						DMARK "-L<" 
b2ab f5				push af  
b2ac 3a c0 b2			ld a, (.dmark)  
b2af 32 6b ee			ld (debug_mark),a  
b2b2 3a c1 b2			ld a, (.dmark+1)  
b2b5 32 6c ee			ld (debug_mark+1),a  
b2b8 3a c2 b2			ld a, (.dmark+2)  
b2bb 32 6d ee			ld (debug_mark+2),a  
b2be 18 03			jr .pastdmark  
b2c0 ..			.dmark: db "-L<"  
b2c3 f1			.pastdmark: pop af  
b2c4			endm  
# End of macro DMARK
b2c4					CALLMONITOR 
b2c4 cd 6f ee			call debug_vector  
b2c7				endm  
# End of macro CALLMONITOR
b2c7				endif 
b2c7 c3 89 9f			jp exec1 
b2ca			 
b2ca					 
b2ca			 
b2ca			 
b2ca			 
b2ca				NEXTW 
b2ca c3 f8 9e			jp macro_next 
b2cd				endm 
# End of macro NEXTW
b2cd			 
b2cd			 
b2cd			 
b2cd			 
b2cd			.REPEAT: 
b2cd				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b2cd 71				db WORD_SYS_CORE+93             
b2ce 20 b3			dw .UNTIL            
b2d0 06				db 5 + 1 
b2d1 .. 00			db "REPEAT",0              
b2d8				endm 
# End of macro CWHEAD
b2d8			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b2d8			;  push pc to rsp stack past the REPEAT 
b2d8					if DEBUG_FORTH_WORDS_KEY 
b2d8						DMARK "REP" 
b2d8 f5				push af  
b2d9 3a ed b2			ld a, (.dmark)  
b2dc 32 6b ee			ld (debug_mark),a  
b2df 3a ee b2			ld a, (.dmark+1)  
b2e2 32 6c ee			ld (debug_mark+1),a  
b2e5 3a ef b2			ld a, (.dmark+2)  
b2e8 32 6d ee			ld (debug_mark+2),a  
b2eb 18 03			jr .pastdmark  
b2ed ..			.dmark: db "REP"  
b2f0 f1			.pastdmark: pop af  
b2f1			endm  
# End of macro DMARK
b2f1						CALLMONITOR 
b2f1 cd 6f ee			call debug_vector  
b2f4				endm  
# End of macro CALLMONITOR
b2f4					endif 
b2f4			 
b2f4 2a c2 e5				ld hl, (os_tok_ptr) 
b2f7 23					inc hl   ; R 
b2f8 23					inc hl  ; E 
b2f9 23					inc hl   ; P 
b2fa 23					inc hl   ; E 
b2fb 23					inc hl   ; A 
b2fc 23					inc hl   ; T 
b2fd 23					inc hl   ; zero 
b2fe					FORTH_RSP_NEXT 
b2fe cd f2 9a			call macro_forth_rsp_next 
b301				endm 
# End of macro FORTH_RSP_NEXT
b301			 
b301			 
b301					if DEBUG_FORTH_WORDS 
b301						DMARK "REP" 
b301 f5				push af  
b302 3a 16 b3			ld a, (.dmark)  
b305 32 6b ee			ld (debug_mark),a  
b308 3a 17 b3			ld a, (.dmark+1)  
b30b 32 6c ee			ld (debug_mark+1),a  
b30e 3a 18 b3			ld a, (.dmark+2)  
b311 32 6d ee			ld (debug_mark+2),a  
b314 18 03			jr .pastdmark  
b316 ..			.dmark: db "REP"  
b319 f1			.pastdmark: pop af  
b31a			endm  
# End of macro DMARK
b31a						;pop bc    ; TODO BUG ?????? what is this for???? 
b31a						CALLMONITOR 
b31a cd 6f ee			call debug_vector  
b31d				endm  
# End of macro CALLMONITOR
b31d					endif 
b31d			 
b31d					NEXTW 
b31d c3 f8 9e			jp macro_next 
b320				endm 
# End of macro NEXTW
b320			;	       NEXTW 
b320			 
b320			.UNTIL: 
b320				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b320 72				db WORD_SYS_CORE+94             
b321 b7 b3			dw .ENDFLOW            
b323 06				db 5 + 1 
b324 .. 00			db "UNTIL",0              
b32a				endm 
# End of macro CWHEAD
b32a			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b32a			 
b32a				; pop tos as check 
b32a			 
b32a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b32a			 
b32a				FORTH_DSP_VALUEHL 
b32a cd 42 9d			call macro_dsp_valuehl 
b32d				endm 
# End of macro FORTH_DSP_VALUEHL
b32d			 
b32d					if DEBUG_FORTH_WORDS_KEY 
b32d						DMARK "UNT" 
b32d f5				push af  
b32e 3a 42 b3			ld a, (.dmark)  
b331 32 6b ee			ld (debug_mark),a  
b334 3a 43 b3			ld a, (.dmark+1)  
b337 32 6c ee			ld (debug_mark+1),a  
b33a 3a 44 b3			ld a, (.dmark+2)  
b33d 32 6d ee			ld (debug_mark+2),a  
b340 18 03			jr .pastdmark  
b342 ..			.dmark: db "UNT"  
b345 f1			.pastdmark: pop af  
b346			endm  
# End of macro DMARK
b346						CALLMONITOR 
b346 cd 6f ee			call debug_vector  
b349				endm  
# End of macro CALLMONITOR
b349					endif 
b349			 
b349			;	push hl 
b349				FORTH_DSP_POP 
b349 cd fa 9d			call macro_forth_dsp_pop 
b34c				endm 
# End of macro FORTH_DSP_POP
b34c			 
b34c			;	pop hl 
b34c			 
b34c				; test if true 
b34c			 
b34c cd 05 8d			call ishlzero 
b34f			;	ld a,l 
b34f			;	add h 
b34f			; 
b34f			;	cp 0 
b34f			 
b34f 20 3e			jr nz, .untilnotdone 
b351			 
b351					if DEBUG_FORTH_WORDS 
b351						DMARK "UNf" 
b351 f5				push af  
b352 3a 66 b3			ld a, (.dmark)  
b355 32 6b ee			ld (debug_mark),a  
b358 3a 67 b3			ld a, (.dmark+1)  
b35b 32 6c ee			ld (debug_mark+1),a  
b35e 3a 68 b3			ld a, (.dmark+2)  
b361 32 6d ee			ld (debug_mark+2),a  
b364 18 03			jr .pastdmark  
b366 ..			.dmark: db "UNf"  
b369 f1			.pastdmark: pop af  
b36a			endm  
# End of macro DMARK
b36a						CALLMONITOR 
b36a cd 6f ee			call debug_vector  
b36d				endm  
# End of macro CALLMONITOR
b36d					endif 
b36d			 
b36d			 
b36d			 
b36d				FORTH_RSP_POP     ; get rid of DO ptr 
b36d cd 13 9b			call macro_forth_rsp_pop 
b370				endm 
# End of macro FORTH_RSP_POP
b370			 
b370			if DEBUG_FORTH_WORDS 
b370						DMARK "UN>" 
b370 f5				push af  
b371 3a 85 b3			ld a, (.dmark)  
b374 32 6b ee			ld (debug_mark),a  
b377 3a 86 b3			ld a, (.dmark+1)  
b37a 32 6c ee			ld (debug_mark+1),a  
b37d 3a 87 b3			ld a, (.dmark+2)  
b380 32 6d ee			ld (debug_mark+2),a  
b383 18 03			jr .pastdmark  
b385 ..			.dmark: db "UN>"  
b388 f1			.pastdmark: pop af  
b389			endm  
# End of macro DMARK
b389				CALLMONITOR 
b389 cd 6f ee			call debug_vector  
b38c				endm  
# End of macro CALLMONITOR
b38c			endif 
b38c			 
b38c					NEXTW 
b38c c3 f8 9e			jp macro_next 
b38f				endm 
# End of macro NEXTW
b38f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b38f			 
b38f			.untilnotdone: 
b38f			 
b38f			 
b38f			;	; get DO ptr 
b38f			; 
b38f				FORTH_RSP_TOS 
b38f cd 09 9b			call macro_forth_rsp_tos 
b392				endm 
# End of macro FORTH_RSP_TOS
b392			 
b392				;push hl 
b392			 
b392				; not going to DO any more 
b392				; get rid of the RSP pointer as DO will add it back in 
b392				;FORTH_RSP_POP 
b392				;pop hl 
b392			 
b392			 
b392 22 c2 e5			ld (os_tok_ptr), hl 
b395					if DEBUG_FORTH_WORDS 
b395						DMARK "UN<" 
b395 f5				push af  
b396 3a aa b3			ld a, (.dmark)  
b399 32 6b ee			ld (debug_mark),a  
b39c 3a ab b3			ld a, (.dmark+1)  
b39f 32 6c ee			ld (debug_mark+1),a  
b3a2 3a ac b3			ld a, (.dmark+2)  
b3a5 32 6d ee			ld (debug_mark+2),a  
b3a8 18 03			jr .pastdmark  
b3aa ..			.dmark: db "UN<"  
b3ad f1			.pastdmark: pop af  
b3ae			endm  
# End of macro DMARK
b3ae					CALLMONITOR 
b3ae cd 6f ee			call debug_vector  
b3b1				endm  
# End of macro CALLMONITOR
b3b1				endif 
b3b1 c3 89 9f			jp exec1 
b3b4			 
b3b4					 
b3b4			 
b3b4			 
b3b4					NEXTW 
b3b4 c3 f8 9e			jp macro_next 
b3b7				endm 
# End of macro NEXTW
b3b7			 
b3b7			 
b3b7			.ENDFLOW: 
b3b7			 
b3b7			; eof 
b3b7			 
# End of file forth_words_flow.asm
b3b7			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b3b7			include "forth_words_logic.asm" 
b3b7			 
b3b7			; | ## Logic Words 
b3b7			 
b3b7			.NOT: 
b3b7				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b3b7 2d				db WORD_SYS_CORE+25             
b3b8 ff b3			dw .IS            
b3ba 04				db 3 + 1 
b3bb .. 00			db "NOT",0              
b3bf				endm 
# End of macro CWHEAD
b3bf			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b3bf					if DEBUG_FORTH_WORDS_KEY 
b3bf						DMARK "NOT" 
b3bf f5				push af  
b3c0 3a d4 b3			ld a, (.dmark)  
b3c3 32 6b ee			ld (debug_mark),a  
b3c6 3a d5 b3			ld a, (.dmark+1)  
b3c9 32 6c ee			ld (debug_mark+1),a  
b3cc 3a d6 b3			ld a, (.dmark+2)  
b3cf 32 6d ee			ld (debug_mark+2),a  
b3d2 18 03			jr .pastdmark  
b3d4 ..			.dmark: db "NOT"  
b3d7 f1			.pastdmark: pop af  
b3d8			endm  
# End of macro DMARK
b3d8						CALLMONITOR 
b3d8 cd 6f ee			call debug_vector  
b3db				endm  
# End of macro CALLMONITOR
b3db					endif 
b3db					FORTH_DSP 
b3db cd 08 9d			call macro_forth_dsp 
b3de				endm 
# End of macro FORTH_DSP
b3de 7e					ld a,(hl)	; get type of value on TOS 
b3df fe 02				cp DS_TYPE_INUM  
b3e1 28 03				jr z, .noti 
b3e3					NEXTW 
b3e3 c3 f8 9e			jp macro_next 
b3e6				endm 
# End of macro NEXTW
b3e6			.noti:          FORTH_DSP_VALUEHL 
b3e6 cd 42 9d			call macro_dsp_valuehl 
b3e9				endm 
# End of macro FORTH_DSP_VALUEHL
b3e9			;		push hl 
b3e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3e9 cd fa 9d			call macro_forth_dsp_pop 
b3ec				endm 
# End of macro FORTH_DSP_POP
b3ec			;		pop hl 
b3ec 3e 00				ld a,0 
b3ee bd					cp l 
b3ef 28 04				jr z, .not2t 
b3f1 2e 00				ld l, 0 
b3f3 18 02				jr .notip 
b3f5			 
b3f5 2e ff		.not2t:		ld l, 255 
b3f7			 
b3f7 26 00		.notip:		ld h, 0	 
b3f9			 
b3f9 cd 4b 9b				call forth_push_numhl 
b3fc					NEXTW 
b3fc c3 f8 9e			jp macro_next 
b3ff				endm 
# End of macro NEXTW
b3ff			 
b3ff			.IS: 
b3ff				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b3ff 2d				db WORD_SYS_CORE+25             
b400 25 b4			dw .LZERO            
b402 03				db 2 + 1 
b403 .. 00			db "IS",0              
b406				endm 
# End of macro CWHEAD
b406			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b406					if DEBUG_FORTH_WORDS_KEY 
b406						DMARK "IS." 
b406 f5				push af  
b407 3a 1b b4			ld a, (.dmark)  
b40a 32 6b ee			ld (debug_mark),a  
b40d 3a 1c b4			ld a, (.dmark+1)  
b410 32 6c ee			ld (debug_mark+1),a  
b413 3a 1d b4			ld a, (.dmark+2)  
b416 32 6d ee			ld (debug_mark+2),a  
b419 18 03			jr .pastdmark  
b41b ..			.dmark: db "IS."  
b41e f1			.pastdmark: pop af  
b41f			endm  
# End of macro DMARK
b41f						CALLMONITOR 
b41f cd 6f ee			call debug_vector  
b422				endm  
# End of macro CALLMONITOR
b422					endif 
b422					NEXTW 
b422 c3 f8 9e			jp macro_next 
b425				endm 
# End of macro NEXTW
b425			.LZERO: 
b425				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b425 2d				db WORD_SYS_CORE+25             
b426 2f b4			dw .TZERO            
b428 03				db 2 + 1 
b429 .. 00			db "0<",0              
b42c				endm 
# End of macro CWHEAD
b42c			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b42c					NEXTW 
b42c c3 f8 9e			jp macro_next 
b42f				endm 
# End of macro NEXTW
b42f			.TZERO: 
b42f				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b42f 2e				db WORD_SYS_CORE+26             
b430 76 b4			dw .LESS            
b432 03				db 2 + 1 
b433 .. 00			db "0=",0              
b436				endm 
# End of macro CWHEAD
b436			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b436				; TODO add floating point number detection 
b436					;v5 FORTH_DSP_VALUE 
b436					if DEBUG_FORTH_WORDS_KEY 
b436						DMARK "0=." 
b436 f5				push af  
b437 3a 4b b4			ld a, (.dmark)  
b43a 32 6b ee			ld (debug_mark),a  
b43d 3a 4c b4			ld a, (.dmark+1)  
b440 32 6c ee			ld (debug_mark+1),a  
b443 3a 4d b4			ld a, (.dmark+2)  
b446 32 6d ee			ld (debug_mark+2),a  
b449 18 03			jr .pastdmark  
b44b ..			.dmark: db "0=."  
b44e f1			.pastdmark: pop af  
b44f			endm  
# End of macro DMARK
b44f						CALLMONITOR 
b44f cd 6f ee			call debug_vector  
b452				endm  
# End of macro CALLMONITOR
b452					endif 
b452					FORTH_DSP 
b452 cd 08 9d			call macro_forth_dsp 
b455				endm 
# End of macro FORTH_DSP
b455 7e					ld a,(hl)	; get type of value on TOS 
b456 fe 02				cp DS_TYPE_INUM  
b458 28 00				jr z, .tz_inum 
b45a			 
b45a				if FORTH_ENABLE_FLOATMATH 
b45a					jr .tz_done 
b45a			 
b45a				endif 
b45a					 
b45a			 
b45a			.tz_inum: 
b45a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b45a cd 42 9d			call macro_dsp_valuehl 
b45d				endm 
# End of macro FORTH_DSP_VALUEHL
b45d			 
b45d			;		push hl 
b45d			 
b45d					; destroy value TOS 
b45d			 
b45d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b45d cd fa 9d			call macro_forth_dsp_pop 
b460				endm 
# End of macro FORTH_DSP_POP
b460			 
b460			;		pop hl 
b460			 
b460 3e 00				ld a,0 
b462			 
b462 bd					cp l 
b463 20 08				jr nz, .tz_notzero 
b465			 
b465 bc					cp h 
b466			 
b466 20 05				jr nz, .tz_notzero 
b468			 
b468			 
b468 21 01 00				ld hl, FORTH_TRUE 
b46b 18 03				jr .tz_done 
b46d			 
b46d 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b470			 
b470					; push value back onto stack for another op etc 
b470			 
b470			.tz_done: 
b470 cd 4b 9b				call forth_push_numhl 
b473			 
b473					NEXTW 
b473 c3 f8 9e			jp macro_next 
b476				endm 
# End of macro NEXTW
b476			.LESS: 
b476				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b476 2f				db WORD_SYS_CORE+27             
b477 df b4			dw .GT            
b479 02				db 1 + 1 
b47a .. 00			db "<",0              
b47c				endm 
# End of macro CWHEAD
b47c			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b47c				; TODO add floating point number detection 
b47c					if DEBUG_FORTH_WORDS_KEY 
b47c						DMARK "LES" 
b47c f5				push af  
b47d 3a 91 b4			ld a, (.dmark)  
b480 32 6b ee			ld (debug_mark),a  
b483 3a 92 b4			ld a, (.dmark+1)  
b486 32 6c ee			ld (debug_mark+1),a  
b489 3a 93 b4			ld a, (.dmark+2)  
b48c 32 6d ee			ld (debug_mark+2),a  
b48f 18 03			jr .pastdmark  
b491 ..			.dmark: db "LES"  
b494 f1			.pastdmark: pop af  
b495			endm  
# End of macro DMARK
b495						CALLMONITOR 
b495 cd 6f ee			call debug_vector  
b498				endm  
# End of macro CALLMONITOR
b498					endif 
b498					FORTH_DSP 
b498 cd 08 9d			call macro_forth_dsp 
b49b				endm 
# End of macro FORTH_DSP
b49b					;v5 FORTH_DSP_VALUE 
b49b 7e					ld a,(hl)	; get type of value on TOS 
b49c fe 02				cp DS_TYPE_INUM  
b49e 28 00				jr z, .less_inum 
b4a0			 
b4a0				if FORTH_ENABLE_FLOATMATH 
b4a0					jr .less_done 
b4a0			 
b4a0				endif 
b4a0					 
b4a0			 
b4a0			.less_inum: 
b4a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4a0 cd 42 9d			call macro_dsp_valuehl 
b4a3				endm 
# End of macro FORTH_DSP_VALUEHL
b4a3			 
b4a3 e5					push hl  ; u2 
b4a4			 
b4a4					; destroy value TOS 
b4a4			 
b4a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4a4 cd fa 9d			call macro_forth_dsp_pop 
b4a7				endm 
# End of macro FORTH_DSP_POP
b4a7			 
b4a7			 
b4a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4a7 cd 42 9d			call macro_dsp_valuehl 
b4aa				endm 
# End of macro FORTH_DSP_VALUEHL
b4aa			 
b4aa e5					push hl    ; u1 
b4ab			 
b4ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4ab cd fa 9d			call macro_forth_dsp_pop 
b4ae				endm 
# End of macro FORTH_DSP_POP
b4ae			 
b4ae			 
b4ae b7			 or a      ;clear carry flag 
b4af 01 00 00		 ld bc, FORTH_FALSE 
b4b2 e1			  pop hl    ; u1 
b4b3 d1			  pop de    ; u2 
b4b4 ed 52		  sbc hl,de 
b4b6 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b4b8			 
b4b8 01 01 00		 ld bc, FORTH_TRUE 
b4bb			.lscont:  
b4bb c5					push bc 
b4bc e1					pop hl 
b4bd			 
b4bd					if DEBUG_FORTH_WORDS 
b4bd						DMARK "LT1" 
b4bd f5				push af  
b4be 3a d2 b4			ld a, (.dmark)  
b4c1 32 6b ee			ld (debug_mark),a  
b4c4 3a d3 b4			ld a, (.dmark+1)  
b4c7 32 6c ee			ld (debug_mark+1),a  
b4ca 3a d4 b4			ld a, (.dmark+2)  
b4cd 32 6d ee			ld (debug_mark+2),a  
b4d0 18 03			jr .pastdmark  
b4d2 ..			.dmark: db "LT1"  
b4d5 f1			.pastdmark: pop af  
b4d6			endm  
# End of macro DMARK
b4d6						CALLMONITOR 
b4d6 cd 6f ee			call debug_vector  
b4d9				endm  
# End of macro CALLMONITOR
b4d9					endif 
b4d9 cd 4b 9b				call forth_push_numhl 
b4dc			 
b4dc					NEXTW 
b4dc c3 f8 9e			jp macro_next 
b4df				endm 
# End of macro NEXTW
b4df			.GT: 
b4df				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b4df 30				db WORD_SYS_CORE+28             
b4e0 48 b5			dw .EQUAL            
b4e2 02				db 1 + 1 
b4e3 .. 00			db ">",0              
b4e5				endm 
# End of macro CWHEAD
b4e5			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b4e5				; TODO add floating point number detection 
b4e5					if DEBUG_FORTH_WORDS_KEY 
b4e5						DMARK "GRT" 
b4e5 f5				push af  
b4e6 3a fa b4			ld a, (.dmark)  
b4e9 32 6b ee			ld (debug_mark),a  
b4ec 3a fb b4			ld a, (.dmark+1)  
b4ef 32 6c ee			ld (debug_mark+1),a  
b4f2 3a fc b4			ld a, (.dmark+2)  
b4f5 32 6d ee			ld (debug_mark+2),a  
b4f8 18 03			jr .pastdmark  
b4fa ..			.dmark: db "GRT"  
b4fd f1			.pastdmark: pop af  
b4fe			endm  
# End of macro DMARK
b4fe						CALLMONITOR 
b4fe cd 6f ee			call debug_vector  
b501				endm  
# End of macro CALLMONITOR
b501					endif 
b501					FORTH_DSP 
b501 cd 08 9d			call macro_forth_dsp 
b504				endm 
# End of macro FORTH_DSP
b504					;FORTH_DSP_VALUE 
b504 7e					ld a,(hl)	; get type of value on TOS 
b505 fe 02				cp DS_TYPE_INUM  
b507 28 00				jr z, .gt_inum 
b509			 
b509				if FORTH_ENABLE_FLOATMATH 
b509					jr .gt_done 
b509			 
b509				endif 
b509					 
b509			 
b509			.gt_inum: 
b509					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b509 cd 42 9d			call macro_dsp_valuehl 
b50c				endm 
# End of macro FORTH_DSP_VALUEHL
b50c			 
b50c e5					push hl  ; u2 
b50d			 
b50d					; destroy value TOS 
b50d			 
b50d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b50d cd fa 9d			call macro_forth_dsp_pop 
b510				endm 
# End of macro FORTH_DSP_POP
b510			 
b510			 
b510					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b510 cd 42 9d			call macro_dsp_valuehl 
b513				endm 
# End of macro FORTH_DSP_VALUEHL
b513			 
b513 e5					push hl    ; u1 
b514			 
b514					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b514 cd fa 9d			call macro_forth_dsp_pop 
b517				endm 
# End of macro FORTH_DSP_POP
b517			 
b517			 
b517 b7			 or a      ;clear carry flag 
b518 01 00 00		 ld bc, FORTH_FALSE 
b51b e1			  pop hl    ; u1 
b51c d1			  pop de    ; u2 
b51d ed 52		  sbc hl,de 
b51f 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b521			 
b521 01 01 00		 ld bc, FORTH_TRUE 
b524			.gtcont:  
b524 c5					push bc 
b525 e1					pop hl 
b526			 
b526					if DEBUG_FORTH_WORDS 
b526						DMARK "GT1" 
b526 f5				push af  
b527 3a 3b b5			ld a, (.dmark)  
b52a 32 6b ee			ld (debug_mark),a  
b52d 3a 3c b5			ld a, (.dmark+1)  
b530 32 6c ee			ld (debug_mark+1),a  
b533 3a 3d b5			ld a, (.dmark+2)  
b536 32 6d ee			ld (debug_mark+2),a  
b539 18 03			jr .pastdmark  
b53b ..			.dmark: db "GT1"  
b53e f1			.pastdmark: pop af  
b53f			endm  
# End of macro DMARK
b53f						CALLMONITOR 
b53f cd 6f ee			call debug_vector  
b542				endm  
# End of macro CALLMONITOR
b542					endif 
b542 cd 4b 9b				call forth_push_numhl 
b545			 
b545					NEXTW 
b545 c3 f8 9e			jp macro_next 
b548				endm 
# End of macro NEXTW
b548			.EQUAL: 
b548				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b548 31				db WORD_SYS_CORE+29             
b549 b3 b5			dw .ENDLOGIC            
b54b 02				db 1 + 1 
b54c .. 00			db "=",0              
b54e				endm 
# End of macro CWHEAD
b54e			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b54e				; TODO add floating point number detection 
b54e					if DEBUG_FORTH_WORDS_KEY 
b54e						DMARK "EQ." 
b54e f5				push af  
b54f 3a 63 b5			ld a, (.dmark)  
b552 32 6b ee			ld (debug_mark),a  
b555 3a 64 b5			ld a, (.dmark+1)  
b558 32 6c ee			ld (debug_mark+1),a  
b55b 3a 65 b5			ld a, (.dmark+2)  
b55e 32 6d ee			ld (debug_mark+2),a  
b561 18 03			jr .pastdmark  
b563 ..			.dmark: db "EQ."  
b566 f1			.pastdmark: pop af  
b567			endm  
# End of macro DMARK
b567						CALLMONITOR 
b567 cd 6f ee			call debug_vector  
b56a				endm  
# End of macro CALLMONITOR
b56a					endif 
b56a					FORTH_DSP 
b56a cd 08 9d			call macro_forth_dsp 
b56d				endm 
# End of macro FORTH_DSP
b56d					;v5 FORTH_DSP_VALUE 
b56d 7e					ld a,(hl)	; get type of value on TOS 
b56e fe 02				cp DS_TYPE_INUM  
b570 28 00				jr z, .eq_inum 
b572			 
b572				if FORTH_ENABLE_FLOATMATH 
b572					jr .eq_done 
b572			 
b572				endif 
b572					 
b572			 
b572			.eq_inum: 
b572					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b572 cd 42 9d			call macro_dsp_valuehl 
b575				endm 
# End of macro FORTH_DSP_VALUEHL
b575			 
b575 e5					push hl 
b576			 
b576					; destroy value TOS 
b576			 
b576					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b576 cd fa 9d			call macro_forth_dsp_pop 
b579				endm 
# End of macro FORTH_DSP_POP
b579			 
b579			 
b579					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b579 cd 42 9d			call macro_dsp_valuehl 
b57c				endm 
# End of macro FORTH_DSP_VALUEHL
b57c			 
b57c					; one value on hl get other one back 
b57c			 
b57c e5					push hl 
b57d			 
b57d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b57d cd fa 9d			call macro_forth_dsp_pop 
b580				endm 
# End of macro FORTH_DSP_POP
b580			 
b580 0e 00				ld c, FORTH_FALSE 
b582			 
b582 e1					pop hl 
b583 d1					pop de 
b584			 
b584 7b					ld a, e 
b585 bd					cp l 
b586			 
b586 20 06				jr nz, .eq_done 
b588			 
b588 7a					ld a, d 
b589 bc					cp h 
b58a			 
b58a 20 02				jr nz, .eq_done 
b58c			 
b58c 0e 01				ld c, FORTH_TRUE 
b58e					 
b58e			 
b58e			 
b58e			.eq_done: 
b58e			 
b58e					; TODO push value back onto stack for another op etc 
b58e			 
b58e 26 00				ld h, 0 
b590 69					ld l, c 
b591					if DEBUG_FORTH_WORDS 
b591						DMARK "EQ1" 
b591 f5				push af  
b592 3a a6 b5			ld a, (.dmark)  
b595 32 6b ee			ld (debug_mark),a  
b598 3a a7 b5			ld a, (.dmark+1)  
b59b 32 6c ee			ld (debug_mark+1),a  
b59e 3a a8 b5			ld a, (.dmark+2)  
b5a1 32 6d ee			ld (debug_mark+2),a  
b5a4 18 03			jr .pastdmark  
b5a6 ..			.dmark: db "EQ1"  
b5a9 f1			.pastdmark: pop af  
b5aa			endm  
# End of macro DMARK
b5aa						CALLMONITOR 
b5aa cd 6f ee			call debug_vector  
b5ad				endm  
# End of macro CALLMONITOR
b5ad					endif 
b5ad cd 4b 9b				call forth_push_numhl 
b5b0			 
b5b0					NEXTW 
b5b0 c3 f8 9e			jp macro_next 
b5b3				endm 
# End of macro NEXTW
b5b3			 
b5b3			 
b5b3			.ENDLOGIC: 
b5b3			; eof 
b5b3			 
b5b3			 
# End of file forth_words_logic.asm
b5b3			include "forth_words_maths.asm" 
b5b3			 
b5b3			; | ## Maths Words 
b5b3			 
b5b3			.PLUS:	 
b5b3				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b5b3 15				db WORD_SYS_CORE+1             
b5b4 11 b6			dw .NEG            
b5b6 02				db 1 + 1 
b5b7 .. 00			db "+",0              
b5b9				endm 
# End of macro CWHEAD
b5b9			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b5b9					if DEBUG_FORTH_WORDS_KEY 
b5b9						DMARK "PLU" 
b5b9 f5				push af  
b5ba 3a ce b5			ld a, (.dmark)  
b5bd 32 6b ee			ld (debug_mark),a  
b5c0 3a cf b5			ld a, (.dmark+1)  
b5c3 32 6c ee			ld (debug_mark+1),a  
b5c6 3a d0 b5			ld a, (.dmark+2)  
b5c9 32 6d ee			ld (debug_mark+2),a  
b5cc 18 03			jr .pastdmark  
b5ce ..			.dmark: db "PLU"  
b5d1 f1			.pastdmark: pop af  
b5d2			endm  
# End of macro DMARK
b5d2						CALLMONITOR 
b5d2 cd 6f ee			call debug_vector  
b5d5				endm  
# End of macro CALLMONITOR
b5d5					endif 
b5d5					; add top two values and push back result 
b5d5			 
b5d5					;for v5 FORTH_DSP_VALUE 
b5d5					FORTH_DSP 
b5d5 cd 08 9d			call macro_forth_dsp 
b5d8				endm 
# End of macro FORTH_DSP
b5d8 7e					ld a,(hl)	; get type of value on TOS 
b5d9 fe 02				cp DS_TYPE_INUM  
b5db 28 03				jr z, .dot_inum 
b5dd			 
b5dd					NEXTW 
b5dd c3 f8 9e			jp macro_next 
b5e0				endm 
# End of macro NEXTW
b5e0			 
b5e0			; float maths 
b5e0			 
b5e0				if FORTH_ENABLE_FLOATMATH 
b5e0						inc hl      ; now at start of numeric as string 
b5e0			 
b5e0					if DEBUG_FORTH_MATHS 
b5e0						DMARK "ADD" 
b5e0				CALLMONITOR 
b5e0					endif 
b5e0			 
b5e0					;ld ix, hl 
b5e0					call CON 
b5e0			 
b5e0			 
b5e0					push hl 
b5e0					 
b5e0					 
b5e0			 
b5e0						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b5e0			 
b5e0					; get next number 
b5e0			 
b5e0						FORTH_DSP_VALUE 
b5e0			 
b5e0						inc hl      ; now at start of numeric as string 
b5e0			 
b5e0					;ld ix, hl 
b5e0					call CON 
b5e0			 
b5e0					push hl 
b5e0			 
b5e0			 
b5e0						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e0			 
b5e0						; TODO do add 
b5e0			 
b5e0						call IADD 
b5e0			 
b5e0						; TODO get result back as ascii 
b5e0			 
b5e0						; TODO push result  
b5e0			 
b5e0			 
b5e0			 
b5e0						jr .dot_done 
b5e0				endif 
b5e0			 
b5e0			.dot_inum: 
b5e0			 
b5e0			 
b5e0					if DEBUG_FORTH_DOT 
b5e0						DMARK "+IT" 
b5e0 f5				push af  
b5e1 3a f5 b5			ld a, (.dmark)  
b5e4 32 6b ee			ld (debug_mark),a  
b5e7 3a f6 b5			ld a, (.dmark+1)  
b5ea 32 6c ee			ld (debug_mark+1),a  
b5ed 3a f7 b5			ld a, (.dmark+2)  
b5f0 32 6d ee			ld (debug_mark+2),a  
b5f3 18 03			jr .pastdmark  
b5f5 ..			.dmark: db "+IT"  
b5f8 f1			.pastdmark: pop af  
b5f9			endm  
# End of macro DMARK
b5f9				CALLMONITOR 
b5f9 cd 6f ee			call debug_vector  
b5fc				endm  
# End of macro CALLMONITOR
b5fc					endif 
b5fc			 
b5fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5fc cd 42 9d			call macro_dsp_valuehl 
b5ff				endm 
# End of macro FORTH_DSP_VALUEHL
b5ff			 
b5ff				; TODO add floating point number detection 
b5ff			 
b5ff e5					push hl 
b600			 
b600					; destroy value TOS 
b600			 
b600					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b600 cd fa 9d			call macro_forth_dsp_pop 
b603				endm 
# End of macro FORTH_DSP_POP
b603			 
b603			 
b603					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b603 cd 42 9d			call macro_dsp_valuehl 
b606				endm 
# End of macro FORTH_DSP_VALUEHL
b606			 
b606					; one value on hl get other one back 
b606			 
b606 d1					pop de 
b607			 
b607					; do the add 
b607			 
b607 19					add hl,de 
b608			 
b608					; save it 
b608			 
b608			;		push hl	 
b608			 
b608					; 
b608			 
b608					; destroy value TOS 
b608			 
b608					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b608 cd fa 9d			call macro_forth_dsp_pop 
b60b				endm 
# End of macro FORTH_DSP_POP
b60b			 
b60b					; TODO push value back onto stack for another op etc 
b60b			 
b60b			;		pop hl 
b60b			 
b60b			.dot_done: 
b60b cd 4b 9b				call forth_push_numhl 
b60e			 
b60e					NEXTW 
b60e c3 f8 9e			jp macro_next 
b611				endm 
# End of macro NEXTW
b611			.NEG: 
b611			 
b611				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b611 17				db WORD_SYS_CORE+3             
b612 54 b6			dw .DIV            
b614 02				db 1 + 1 
b615 .. 00			db "-",0              
b617				endm 
# End of macro CWHEAD
b617			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b617					if DEBUG_FORTH_WORDS_KEY 
b617						DMARK "SUB" 
b617 f5				push af  
b618 3a 2c b6			ld a, (.dmark)  
b61b 32 6b ee			ld (debug_mark),a  
b61e 3a 2d b6			ld a, (.dmark+1)  
b621 32 6c ee			ld (debug_mark+1),a  
b624 3a 2e b6			ld a, (.dmark+2)  
b627 32 6d ee			ld (debug_mark+2),a  
b62a 18 03			jr .pastdmark  
b62c ..			.dmark: db "SUB"  
b62f f1			.pastdmark: pop af  
b630			endm  
# End of macro DMARK
b630						CALLMONITOR 
b630 cd 6f ee			call debug_vector  
b633				endm  
# End of macro CALLMONITOR
b633					endif 
b633			 
b633			 
b633				; TODO add floating point number detection 
b633					; v5 FORTH_DSP_VALUE 
b633					FORTH_DSP 
b633 cd 08 9d			call macro_forth_dsp 
b636				endm 
# End of macro FORTH_DSP
b636 7e					ld a,(hl)	; get type of value on TOS 
b637 fe 02				cp DS_TYPE_INUM  
b639 28 03				jr z, .neg_inum 
b63b			 
b63b					NEXTW 
b63b c3 f8 9e			jp macro_next 
b63e				endm 
# End of macro NEXTW
b63e			 
b63e			; float maths 
b63e			 
b63e				if FORTH_ENABLE_FLOATMATH 
b63e					jr .neg_done 
b63e			 
b63e				endif 
b63e					 
b63e			 
b63e			.neg_inum: 
b63e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b63e cd 42 9d			call macro_dsp_valuehl 
b641				endm 
# End of macro FORTH_DSP_VALUEHL
b641			 
b641 e5					push hl 
b642			 
b642					; destroy value TOS 
b642			 
b642					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b642 cd fa 9d			call macro_forth_dsp_pop 
b645				endm 
# End of macro FORTH_DSP_POP
b645			 
b645			 
b645					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b645 cd 42 9d			call macro_dsp_valuehl 
b648				endm 
# End of macro FORTH_DSP_VALUEHL
b648			 
b648					; one value on hl get other one back 
b648			 
b648 d1					pop de 
b649			 
b649					; do the sub 
b649			;		ex de, hl 
b649			 
b649 ed 52				sbc hl,de 
b64b			 
b64b					; save it 
b64b			 
b64b			;		push hl	 
b64b			 
b64b					; 
b64b			 
b64b					; destroy value TOS 
b64b			 
b64b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b64b cd fa 9d			call macro_forth_dsp_pop 
b64e				endm 
# End of macro FORTH_DSP_POP
b64e			 
b64e					; TODO push value back onto stack for another op etc 
b64e			 
b64e			;		pop hl 
b64e			 
b64e cd 4b 9b				call forth_push_numhl 
b651			.neg_done: 
b651			 
b651					NEXTW 
b651 c3 f8 9e			jp macro_next 
b654				endm 
# End of macro NEXTW
b654			.DIV: 
b654				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b654 18				db WORD_SYS_CORE+4             
b655 a1 b6			dw .MUL            
b657 02				db 1 + 1 
b658 .. 00			db "/",0              
b65a				endm 
# End of macro CWHEAD
b65a			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b65a					if DEBUG_FORTH_WORDS_KEY 
b65a						DMARK "DIV" 
b65a f5				push af  
b65b 3a 6f b6			ld a, (.dmark)  
b65e 32 6b ee			ld (debug_mark),a  
b661 3a 70 b6			ld a, (.dmark+1)  
b664 32 6c ee			ld (debug_mark+1),a  
b667 3a 71 b6			ld a, (.dmark+2)  
b66a 32 6d ee			ld (debug_mark+2),a  
b66d 18 03			jr .pastdmark  
b66f ..			.dmark: db "DIV"  
b672 f1			.pastdmark: pop af  
b673			endm  
# End of macro DMARK
b673						CALLMONITOR 
b673 cd 6f ee			call debug_vector  
b676				endm  
# End of macro CALLMONITOR
b676					endif 
b676				; TODO add floating point number detection 
b676					; v5 FORTH_DSP_VALUE 
b676					FORTH_DSP 
b676 cd 08 9d			call macro_forth_dsp 
b679				endm 
# End of macro FORTH_DSP
b679 7e					ld a,(hl)	; get type of value on TOS 
b67a fe 02				cp DS_TYPE_INUM  
b67c 28 03				jr z, .div_inum 
b67e			 
b67e				if FORTH_ENABLE_FLOATMATH 
b67e					jr .div_done 
b67e			 
b67e				endif 
b67e					NEXTW 
b67e c3 f8 9e			jp macro_next 
b681				endm 
# End of macro NEXTW
b681			.div_inum: 
b681			 
b681					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b681 cd 42 9d			call macro_dsp_valuehl 
b684				endm 
# End of macro FORTH_DSP_VALUEHL
b684			 
b684 e5					push hl    ; to go to bc 
b685			 
b685					; destroy value TOS 
b685			 
b685					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b685 cd fa 9d			call macro_forth_dsp_pop 
b688				endm 
# End of macro FORTH_DSP_POP
b688			 
b688			 
b688					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b688 cd 42 9d			call macro_dsp_valuehl 
b68b				endm 
# End of macro FORTH_DSP_VALUEHL
b68b			 
b68b					; hl to go to de 
b68b			 
b68b e5					push hl 
b68c			 
b68c c1					pop bc 
b68d d1					pop de		 
b68e			 
b68e			 
b68e					if DEBUG_FORTH_MATHS 
b68e						DMARK "DIV" 
b68e				CALLMONITOR 
b68e					endif 
b68e					; one value on hl but move to a get other one back 
b68e			 
b68e			        
b68e cd 39 8c			call Div16 
b691			 
b691			;	push af	 
b691 e5				push hl 
b692 c5				push bc 
b693			 
b693					if DEBUG_FORTH_MATHS 
b693						DMARK "DI1" 
b693				CALLMONITOR 
b693					endif 
b693			 
b693					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b693 cd fa 9d			call macro_forth_dsp_pop 
b696				endm 
# End of macro FORTH_DSP_POP
b696			 
b696			 
b696			 
b696 e1					pop hl    ; result 
b697			 
b697 cd 4b 9b				call forth_push_numhl 
b69a			 
b69a e1					pop hl    ; reminder 
b69b			;		ld h,0 
b69b			;		ld l,d 
b69b			 
b69b cd 4b 9b				call forth_push_numhl 
b69e			.div_done: 
b69e					NEXTW 
b69e c3 f8 9e			jp macro_next 
b6a1				endm 
# End of macro NEXTW
b6a1			.MUL: 
b6a1				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b6a1 19				db WORD_SYS_CORE+5             
b6a2 e6 b6			dw .MIN            
b6a4 02				db 1 + 1 
b6a5 .. 00			db "*",0              
b6a7				endm 
# End of macro CWHEAD
b6a7			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b6a7				; TODO add floating point number detection 
b6a7					if DEBUG_FORTH_WORDS_KEY 
b6a7						DMARK "MUL" 
b6a7 f5				push af  
b6a8 3a bc b6			ld a, (.dmark)  
b6ab 32 6b ee			ld (debug_mark),a  
b6ae 3a bd b6			ld a, (.dmark+1)  
b6b1 32 6c ee			ld (debug_mark+1),a  
b6b4 3a be b6			ld a, (.dmark+2)  
b6b7 32 6d ee			ld (debug_mark+2),a  
b6ba 18 03			jr .pastdmark  
b6bc ..			.dmark: db "MUL"  
b6bf f1			.pastdmark: pop af  
b6c0			endm  
# End of macro DMARK
b6c0						CALLMONITOR 
b6c0 cd 6f ee			call debug_vector  
b6c3				endm  
# End of macro CALLMONITOR
b6c3					endif 
b6c3					FORTH_DSP 
b6c3 cd 08 9d			call macro_forth_dsp 
b6c6				endm 
# End of macro FORTH_DSP
b6c6					; v5 FORTH_DSP_VALUE 
b6c6 7e					ld a,(hl)	; get type of value on TOS 
b6c7 fe 02				cp DS_TYPE_INUM  
b6c9 28 03				jr z, .mul_inum 
b6cb			 
b6cb				if FORTH_ENABLE_FLOATMATH 
b6cb					jr .mul_done 
b6cb			 
b6cb				endif 
b6cb			 
b6cb					NEXTW 
b6cb c3 f8 9e			jp macro_next 
b6ce				endm 
# End of macro NEXTW
b6ce			.mul_inum:	 
b6ce			 
b6ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6ce cd 42 9d			call macro_dsp_valuehl 
b6d1				endm 
# End of macro FORTH_DSP_VALUEHL
b6d1			 
b6d1 e5					push hl 
b6d2			 
b6d2					; destroy value TOS 
b6d2			 
b6d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6d2 cd fa 9d			call macro_forth_dsp_pop 
b6d5				endm 
# End of macro FORTH_DSP_POP
b6d5			 
b6d5			 
b6d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6d5 cd 42 9d			call macro_dsp_valuehl 
b6d8				endm 
# End of macro FORTH_DSP_VALUEHL
b6d8			 
b6d8					; one value on hl but move to a get other one back 
b6d8			 
b6d8 7d					ld a, l 
b6d9			 
b6d9 d1					pop de 
b6da			 
b6da					; do the mull 
b6da			;		ex de, hl 
b6da			 
b6da cd 5f 8c				call Mult16 
b6dd					; save it 
b6dd			 
b6dd			;		push hl	 
b6dd			 
b6dd					; 
b6dd			 
b6dd					; destroy value TOS 
b6dd			 
b6dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6dd cd fa 9d			call macro_forth_dsp_pop 
b6e0				endm 
# End of macro FORTH_DSP_POP
b6e0			 
b6e0					; TODO push value back onto stack for another op etc 
b6e0			 
b6e0			;		pop hl 
b6e0			 
b6e0 cd 4b 9b				call forth_push_numhl 
b6e3			 
b6e3			.mul_done: 
b6e3					NEXTW 
b6e3 c3 f8 9e			jp macro_next 
b6e6				endm 
# End of macro NEXTW
b6e6			 
b6e6			 
b6e6			 
b6e6			 
b6e6			.MIN: 
b6e6				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b6e6 49				db WORD_SYS_CORE+53             
b6e7 67 b7			dw .MAX            
b6e9 04				db 3 + 1 
b6ea .. 00			db "MIN",0              
b6ee				endm 
# End of macro CWHEAD
b6ee			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b6ee					if DEBUG_FORTH_WORDS_KEY 
b6ee						DMARK "MIN" 
b6ee f5				push af  
b6ef 3a 03 b7			ld a, (.dmark)  
b6f2 32 6b ee			ld (debug_mark),a  
b6f5 3a 04 b7			ld a, (.dmark+1)  
b6f8 32 6c ee			ld (debug_mark+1),a  
b6fb 3a 05 b7			ld a, (.dmark+2)  
b6fe 32 6d ee			ld (debug_mark+2),a  
b701 18 03			jr .pastdmark  
b703 ..			.dmark: db "MIN"  
b706 f1			.pastdmark: pop af  
b707			endm  
# End of macro DMARK
b707						CALLMONITOR 
b707 cd 6f ee			call debug_vector  
b70a				endm  
# End of macro CALLMONITOR
b70a					endif 
b70a					; get u2 
b70a			 
b70a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b70a cd 42 9d			call macro_dsp_valuehl 
b70d				endm 
# End of macro FORTH_DSP_VALUEHL
b70d			 
b70d e5					push hl   ; u2 
b70e			 
b70e					; destroy value TOS 
b70e			 
b70e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b70e cd fa 9d			call macro_forth_dsp_pop 
b711				endm 
# End of macro FORTH_DSP_POP
b711			 
b711					; get u1 
b711			 
b711					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b711 cd 42 9d			call macro_dsp_valuehl 
b714				endm 
# End of macro FORTH_DSP_VALUEHL
b714			 
b714 e5					push hl  ; u1 
b715			 
b715					; destroy value TOS 
b715			 
b715					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b715 cd fa 9d			call macro_forth_dsp_pop 
b718				endm 
# End of macro FORTH_DSP_POP
b718			 
b718 b7			 or a      ;clear carry flag 
b719 e1			  pop hl    ; u1 
b71a d1			  pop de    ; u2 
b71b e5				push hl   ; saved in case hl is lowest 
b71c ed 52		  sbc hl,de 
b71e 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b720			 
b720 e1				pop hl 
b721					if DEBUG_FORTH_WORDS 
b721						DMARK "MIN" 
b721 f5				push af  
b722 3a 36 b7			ld a, (.dmark)  
b725 32 6b ee			ld (debug_mark),a  
b728 3a 37 b7			ld a, (.dmark+1)  
b72b 32 6c ee			ld (debug_mark+1),a  
b72e 3a 38 b7			ld a, (.dmark+2)  
b731 32 6d ee			ld (debug_mark+2),a  
b734 18 03			jr .pastdmark  
b736 ..			.dmark: db "MIN"  
b739 f1			.pastdmark: pop af  
b73a			endm  
# End of macro DMARK
b73a						CALLMONITOR 
b73a cd 6f ee			call debug_vector  
b73d				endm  
# End of macro CALLMONITOR
b73d					endif 
b73d cd 4b 9b				call forth_push_numhl 
b740			 
b740				       NEXTW 
b740 c3 f8 9e			jp macro_next 
b743				endm 
# End of macro NEXTW
b743			 
b743			.mincont:  
b743 c1				pop bc   ; tidy up 
b744 eb				ex de , hl  
b745					if DEBUG_FORTH_WORDS 
b745						DMARK "MI1" 
b745 f5				push af  
b746 3a 5a b7			ld a, (.dmark)  
b749 32 6b ee			ld (debug_mark),a  
b74c 3a 5b b7			ld a, (.dmark+1)  
b74f 32 6c ee			ld (debug_mark+1),a  
b752 3a 5c b7			ld a, (.dmark+2)  
b755 32 6d ee			ld (debug_mark+2),a  
b758 18 03			jr .pastdmark  
b75a ..			.dmark: db "MI1"  
b75d f1			.pastdmark: pop af  
b75e			endm  
# End of macro DMARK
b75e						CALLMONITOR 
b75e cd 6f ee			call debug_vector  
b761				endm  
# End of macro CALLMONITOR
b761					endif 
b761 cd 4b 9b				call forth_push_numhl 
b764			 
b764				       NEXTW 
b764 c3 f8 9e			jp macro_next 
b767				endm 
# End of macro NEXTW
b767			.MAX: 
b767				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b767 4a				db WORD_SYS_CORE+54             
b768 e8 b7			dw .RND16            
b76a 04				db 3 + 1 
b76b .. 00			db "MAX",0              
b76f				endm 
# End of macro CWHEAD
b76f			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b76f					if DEBUG_FORTH_WORDS_KEY 
b76f						DMARK "MAX" 
b76f f5				push af  
b770 3a 84 b7			ld a, (.dmark)  
b773 32 6b ee			ld (debug_mark),a  
b776 3a 85 b7			ld a, (.dmark+1)  
b779 32 6c ee			ld (debug_mark+1),a  
b77c 3a 86 b7			ld a, (.dmark+2)  
b77f 32 6d ee			ld (debug_mark+2),a  
b782 18 03			jr .pastdmark  
b784 ..			.dmark: db "MAX"  
b787 f1			.pastdmark: pop af  
b788			endm  
# End of macro DMARK
b788						CALLMONITOR 
b788 cd 6f ee			call debug_vector  
b78b				endm  
# End of macro CALLMONITOR
b78b					endif 
b78b					; get u2 
b78b			 
b78b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b78b cd 42 9d			call macro_dsp_valuehl 
b78e				endm 
# End of macro FORTH_DSP_VALUEHL
b78e			 
b78e e5					push hl   ; u2 
b78f			 
b78f					; destroy value TOS 
b78f			 
b78f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b78f cd fa 9d			call macro_forth_dsp_pop 
b792				endm 
# End of macro FORTH_DSP_POP
b792			 
b792					; get u1 
b792			 
b792					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b792 cd 42 9d			call macro_dsp_valuehl 
b795				endm 
# End of macro FORTH_DSP_VALUEHL
b795			 
b795 e5					push hl  ; u1 
b796			 
b796					; destroy value TOS 
b796			 
b796					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b796 cd fa 9d			call macro_forth_dsp_pop 
b799				endm 
# End of macro FORTH_DSP_POP
b799			 
b799 b7			 or a      ;clear carry flag 
b79a e1			  pop hl    ; u1 
b79b d1			  pop de    ; u2 
b79c e5				push hl   ; saved in case hl is lowest 
b79d ed 52		  sbc hl,de 
b79f 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b7a1			 
b7a1 e1				pop hl 
b7a2					if DEBUG_FORTH_WORDS 
b7a2						DMARK "MAX" 
b7a2 f5				push af  
b7a3 3a b7 b7			ld a, (.dmark)  
b7a6 32 6b ee			ld (debug_mark),a  
b7a9 3a b8 b7			ld a, (.dmark+1)  
b7ac 32 6c ee			ld (debug_mark+1),a  
b7af 3a b9 b7			ld a, (.dmark+2)  
b7b2 32 6d ee			ld (debug_mark+2),a  
b7b5 18 03			jr .pastdmark  
b7b7 ..			.dmark: db "MAX"  
b7ba f1			.pastdmark: pop af  
b7bb			endm  
# End of macro DMARK
b7bb						CALLMONITOR 
b7bb cd 6f ee			call debug_vector  
b7be				endm  
# End of macro CALLMONITOR
b7be					endif 
b7be cd 4b 9b				call forth_push_numhl 
b7c1			 
b7c1				       NEXTW 
b7c1 c3 f8 9e			jp macro_next 
b7c4				endm 
# End of macro NEXTW
b7c4			 
b7c4			.maxcont:  
b7c4 c1				pop bc   ; tidy up 
b7c5 eb				ex de , hl  
b7c6					if DEBUG_FORTH_WORDS 
b7c6						DMARK "MA1" 
b7c6 f5				push af  
b7c7 3a db b7			ld a, (.dmark)  
b7ca 32 6b ee			ld (debug_mark),a  
b7cd 3a dc b7			ld a, (.dmark+1)  
b7d0 32 6c ee			ld (debug_mark+1),a  
b7d3 3a dd b7			ld a, (.dmark+2)  
b7d6 32 6d ee			ld (debug_mark+2),a  
b7d9 18 03			jr .pastdmark  
b7db ..			.dmark: db "MA1"  
b7de f1			.pastdmark: pop af  
b7df			endm  
# End of macro DMARK
b7df						CALLMONITOR 
b7df cd 6f ee			call debug_vector  
b7e2				endm  
# End of macro CALLMONITOR
b7e2					endif 
b7e2 cd 4b 9b				call forth_push_numhl 
b7e5				       NEXTW 
b7e5 c3 f8 9e			jp macro_next 
b7e8				endm 
# End of macro NEXTW
b7e8			 
b7e8			.RND16: 
b7e8				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b7e8 4e				db WORD_SYS_CORE+58             
b7e9 17 b8			dw .RND8            
b7eb 06				db 5 + 1 
b7ec .. 00			db "RND16",0              
b7f2				endm 
# End of macro CWHEAD
b7f2			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b7f2					if DEBUG_FORTH_WORDS_KEY 
b7f2						DMARK "R16" 
b7f2 f5				push af  
b7f3 3a 07 b8			ld a, (.dmark)  
b7f6 32 6b ee			ld (debug_mark),a  
b7f9 3a 08 b8			ld a, (.dmark+1)  
b7fc 32 6c ee			ld (debug_mark+1),a  
b7ff 3a 09 b8			ld a, (.dmark+2)  
b802 32 6d ee			ld (debug_mark+2),a  
b805 18 03			jr .pastdmark  
b807 ..			.dmark: db "R16"  
b80a f1			.pastdmark: pop af  
b80b			endm  
# End of macro DMARK
b80b						CALLMONITOR 
b80b cd 6f ee			call debug_vector  
b80e				endm  
# End of macro CALLMONITOR
b80e					endif 
b80e cd 03 8c				call prng16  
b811 cd 4b 9b				call forth_push_numhl 
b814				       NEXTW 
b814 c3 f8 9e			jp macro_next 
b817				endm 
# End of macro NEXTW
b817			.RND8: 
b817				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b817 60				db WORD_SYS_CORE+76             
b818 4c b8			dw .RND            
b81a 05				db 4 + 1 
b81b .. 00			db "RND8",0              
b820				endm 
# End of macro CWHEAD
b820			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b820					if DEBUG_FORTH_WORDS_KEY 
b820						DMARK "RN8" 
b820 f5				push af  
b821 3a 35 b8			ld a, (.dmark)  
b824 32 6b ee			ld (debug_mark),a  
b827 3a 36 b8			ld a, (.dmark+1)  
b82a 32 6c ee			ld (debug_mark+1),a  
b82d 3a 37 b8			ld a, (.dmark+2)  
b830 32 6d ee			ld (debug_mark+2),a  
b833 18 03			jr .pastdmark  
b835 ..			.dmark: db "RN8"  
b838 f1			.pastdmark: pop af  
b839			endm  
# End of macro DMARK
b839						CALLMONITOR 
b839 cd 6f ee			call debug_vector  
b83c				endm  
# End of macro CALLMONITOR
b83c					endif 
b83c 2a a9 eb				ld hl,(xrandc) 
b83f 23					inc hl 
b840 cd 1d 8c				call xrnd 
b843 6f					ld l,a	 
b844 26 00				ld h,0 
b846 cd 4b 9b				call forth_push_numhl 
b849				       NEXTW 
b849 c3 f8 9e			jp macro_next 
b84c				endm 
# End of macro NEXTW
b84c			.RND: 
b84c				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b84c 60				db WORD_SYS_CORE+76             
b84d 52 b9			dw .ENDMATHS            
b84f 04				db 3 + 1 
b850 .. 00			db "RND",0              
b854				endm 
# End of macro CWHEAD
b854			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b854			 
b854					if DEBUG_FORTH_WORDS_KEY 
b854						DMARK "RND" 
b854 f5				push af  
b855 3a 69 b8			ld a, (.dmark)  
b858 32 6b ee			ld (debug_mark),a  
b85b 3a 6a b8			ld a, (.dmark+1)  
b85e 32 6c ee			ld (debug_mark+1),a  
b861 3a 6b b8			ld a, (.dmark+2)  
b864 32 6d ee			ld (debug_mark+2),a  
b867 18 03			jr .pastdmark  
b869 ..			.dmark: db "RND"  
b86c f1			.pastdmark: pop af  
b86d			endm  
# End of macro DMARK
b86d						CALLMONITOR 
b86d cd 6f ee			call debug_vector  
b870				endm  
# End of macro CALLMONITOR
b870					endif 
b870					 
b870					FORTH_DSP_VALUEHL    ; upper range 
b870 cd 42 9d			call macro_dsp_valuehl 
b873				endm 
# End of macro FORTH_DSP_VALUEHL
b873			 
b873 22 ad eb				ld (LFSRSeed), hl	 
b876			 
b876					if DEBUG_FORTH_WORDS 
b876						DMARK "RN1" 
b876 f5				push af  
b877 3a 8b b8			ld a, (.dmark)  
b87a 32 6b ee			ld (debug_mark),a  
b87d 3a 8c b8			ld a, (.dmark+1)  
b880 32 6c ee			ld (debug_mark+1),a  
b883 3a 8d b8			ld a, (.dmark+2)  
b886 32 6d ee			ld (debug_mark+2),a  
b889 18 03			jr .pastdmark  
b88b ..			.dmark: db "RN1"  
b88e f1			.pastdmark: pop af  
b88f			endm  
# End of macro DMARK
b88f						CALLMONITOR 
b88f cd 6f ee			call debug_vector  
b892				endm  
# End of macro CALLMONITOR
b892					endif 
b892					FORTH_DSP_POP 
b892 cd fa 9d			call macro_forth_dsp_pop 
b895				endm 
# End of macro FORTH_DSP_POP
b895			 
b895					FORTH_DSP_VALUEHL    ; low range 
b895 cd 42 9d			call macro_dsp_valuehl 
b898				endm 
# End of macro FORTH_DSP_VALUEHL
b898			 
b898					if DEBUG_FORTH_WORDS 
b898						DMARK "RN2" 
b898 f5				push af  
b899 3a ad b8			ld a, (.dmark)  
b89c 32 6b ee			ld (debug_mark),a  
b89f 3a ae b8			ld a, (.dmark+1)  
b8a2 32 6c ee			ld (debug_mark+1),a  
b8a5 3a af b8			ld a, (.dmark+2)  
b8a8 32 6d ee			ld (debug_mark+2),a  
b8ab 18 03			jr .pastdmark  
b8ad ..			.dmark: db "RN2"  
b8b0 f1			.pastdmark: pop af  
b8b1			endm  
# End of macro DMARK
b8b1						CALLMONITOR 
b8b1 cd 6f ee			call debug_vector  
b8b4				endm  
# End of macro CALLMONITOR
b8b4					endif 
b8b4 22 af eb				ld (LFSRSeed+2), hl 
b8b7			 
b8b7					FORTH_DSP_POP 
b8b7 cd fa 9d			call macro_forth_dsp_pop 
b8ba				endm 
# End of macro FORTH_DSP_POP
b8ba			 
b8ba e5					push hl 
b8bb			 
b8bb e1			.inrange:	pop hl 
b8bc cd 03 8c				call prng16  
b8bf					if DEBUG_FORTH_WORDS 
b8bf						DMARK "RN3" 
b8bf f5				push af  
b8c0 3a d4 b8			ld a, (.dmark)  
b8c3 32 6b ee			ld (debug_mark),a  
b8c6 3a d5 b8			ld a, (.dmark+1)  
b8c9 32 6c ee			ld (debug_mark+1),a  
b8cc 3a d6 b8			ld a, (.dmark+2)  
b8cf 32 6d ee			ld (debug_mark+2),a  
b8d2 18 03			jr .pastdmark  
b8d4 ..			.dmark: db "RN3"  
b8d7 f1			.pastdmark: pop af  
b8d8			endm  
# End of macro DMARK
b8d8						CALLMONITOR 
b8d8 cd 6f ee			call debug_vector  
b8db				endm  
# End of macro CALLMONITOR
b8db					endif 
b8db					 
b8db					; if the range is 8bit knock out the high byte 
b8db			 
b8db ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b8df			 
b8df 3e 00				ld a, 0 
b8e1 ba					cp d  
b8e2 20 1e				jr nz, .hirange 
b8e4 26 00				ld h, 0   ; knock it down to 8bit 
b8e6			 
b8e6					if DEBUG_FORTH_WORDS 
b8e6						DMARK "RNk" 
b8e6 f5				push af  
b8e7 3a fb b8			ld a, (.dmark)  
b8ea 32 6b ee			ld (debug_mark),a  
b8ed 3a fc b8			ld a, (.dmark+1)  
b8f0 32 6c ee			ld (debug_mark+1),a  
b8f3 3a fd b8			ld a, (.dmark+2)  
b8f6 32 6d ee			ld (debug_mark+2),a  
b8f9 18 03			jr .pastdmark  
b8fb ..			.dmark: db "RNk"  
b8fe f1			.pastdmark: pop af  
b8ff			endm  
# End of macro DMARK
b8ff						CALLMONITOR 
b8ff cd 6f ee			call debug_vector  
b902				endm  
# End of macro CALLMONITOR
b902					endif 
b902			.hirange:   
b902 e5					push hl  
b903 b7					or a  
b904 ed 52		                sbc hl, de 
b906			 
b906					;call cmp16 
b906			 
b906 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b908 e1					pop hl 
b909 e5					push hl 
b90a			 
b90a					if DEBUG_FORTH_WORDS 
b90a						DMARK "RN4" 
b90a f5				push af  
b90b 3a 1f b9			ld a, (.dmark)  
b90e 32 6b ee			ld (debug_mark),a  
b911 3a 20 b9			ld a, (.dmark+1)  
b914 32 6c ee			ld (debug_mark+1),a  
b917 3a 21 b9			ld a, (.dmark+2)  
b91a 32 6d ee			ld (debug_mark+2),a  
b91d 18 03			jr .pastdmark  
b91f ..			.dmark: db "RN4"  
b922 f1			.pastdmark: pop af  
b923			endm  
# End of macro DMARK
b923						CALLMONITOR 
b923 cd 6f ee			call debug_vector  
b926				endm  
# End of macro CALLMONITOR
b926					endif 
b926 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b92a					;call cmp16 
b92a				 
b92a b7					or a  
b92b ed 52		                sbc hl, de 
b92d 38 8c				jr c, .inrange 
b92f			 
b92f e1					pop hl 
b930					 
b930					if DEBUG_FORTH_WORDS 
b930						DMARK "RNd" 
b930 f5				push af  
b931 3a 45 b9			ld a, (.dmark)  
b934 32 6b ee			ld (debug_mark),a  
b937 3a 46 b9			ld a, (.dmark+1)  
b93a 32 6c ee			ld (debug_mark+1),a  
b93d 3a 47 b9			ld a, (.dmark+2)  
b940 32 6d ee			ld (debug_mark+2),a  
b943 18 03			jr .pastdmark  
b945 ..			.dmark: db "RNd"  
b948 f1			.pastdmark: pop af  
b949			endm  
# End of macro DMARK
b949						CALLMONITOR 
b949 cd 6f ee			call debug_vector  
b94c				endm  
# End of macro CALLMONITOR
b94c					endif 
b94c			 
b94c			 
b94c cd 4b 9b				call forth_push_numhl 
b94f				       NEXTW 
b94f c3 f8 9e			jp macro_next 
b952				endm 
# End of macro NEXTW
b952			 
b952			.ENDMATHS: 
b952			 
b952			; eof 
b952			 
# End of file forth_words_maths.asm
b952			include "forth_words_display.asm" 
b952			 
b952			; | ## Display Words 
b952			 
b952			.ACT: 
b952			 
b952				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b952 62				db WORD_SYS_CORE+78             
b953 9e b9			dw .INFO            
b955 07				db 6 + 1 
b956 .. 00			db "ACTIVE",0              
b95d				endm 
# End of macro CWHEAD
b95d			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b95d			;  
b95d			; | | e.g. $ff $00 do active . $01 pause loop 
b95d			 
b95d					if DEBUG_FORTH_WORDS_KEY 
b95d						DMARK "ACT" 
b95d f5				push af  
b95e 3a 72 b9			ld a, (.dmark)  
b961 32 6b ee			ld (debug_mark),a  
b964 3a 73 b9			ld a, (.dmark+1)  
b967 32 6c ee			ld (debug_mark+1),a  
b96a 3a 74 b9			ld a, (.dmark+2)  
b96d 32 6d ee			ld (debug_mark+2),a  
b970 18 03			jr .pastdmark  
b972 ..			.dmark: db "ACT"  
b975 f1			.pastdmark: pop af  
b976			endm  
# End of macro DMARK
b976						CALLMONITOR 
b976 cd 6f ee			call debug_vector  
b979				endm  
# End of macro CALLMONITOR
b979					endif 
b979 cd 06 8a				call active 
b97c					if DEBUG_FORTH_WORDS 
b97c						DMARK "ACp" 
b97c f5				push af  
b97d 3a 91 b9			ld a, (.dmark)  
b980 32 6b ee			ld (debug_mark),a  
b983 3a 92 b9			ld a, (.dmark+1)  
b986 32 6c ee			ld (debug_mark+1),a  
b989 3a 93 b9			ld a, (.dmark+2)  
b98c 32 6d ee			ld (debug_mark+2),a  
b98f 18 03			jr .pastdmark  
b991 ..			.dmark: db "ACp"  
b994 f1			.pastdmark: pop af  
b995			endm  
# End of macro DMARK
b995						CALLMONITOR 
b995 cd 6f ee			call debug_vector  
b998				endm  
# End of macro CALLMONITOR
b998					endif 
b998 cd b9 9b				call forth_push_str 
b99b			 
b99b					NEXTW 
b99b c3 f8 9e			jp macro_next 
b99e				endm 
# End of macro NEXTW
b99e			.INFO: 
b99e			 
b99e				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b99e 62				db WORD_SYS_CORE+78             
b99f bb b9			dw .ATP            
b9a1 05				db 4 + 1 
b9a2 .. 00			db "INFO",0              
b9a7				endm 
# End of macro CWHEAD
b9a7			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b9a7					FORTH_DSP_VALUEHL 
b9a7 cd 42 9d			call macro_dsp_valuehl 
b9aa				endm 
# End of macro FORTH_DSP_VALUEHL
b9aa			 
b9aa					FORTH_DSP_POP 
b9aa cd fa 9d			call macro_forth_dsp_pop 
b9ad				endm 
# End of macro FORTH_DSP_POP
b9ad			 
b9ad e5					push hl 
b9ae			 
b9ae					FORTH_DSP_VALUEHL 
b9ae cd 42 9d			call macro_dsp_valuehl 
b9b1				endm 
# End of macro FORTH_DSP_VALUEHL
b9b1			 
b9b1					FORTH_DSP_POP 
b9b1 cd fa 9d			call macro_forth_dsp_pop 
b9b4				endm 
# End of macro FORTH_DSP_POP
b9b4			 
b9b4 d1					pop de 
b9b5			 
b9b5 cd 40 8a				call info_panel 
b9b8			 
b9b8			 
b9b8					NEXTW 
b9b8 c3 f8 9e			jp macro_next 
b9bb				endm 
# End of macro NEXTW
b9bb			.ATP: 
b9bb				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b9bb 62				db WORD_SYS_CORE+78             
b9bc 32 ba			dw .FB            
b9be 04				db 3 + 1 
b9bf .. 00			db "AT?",0              
b9c3				endm 
# End of macro CWHEAD
b9c3			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b9c3					if DEBUG_FORTH_WORDS_KEY 
b9c3						DMARK "AT?" 
b9c3 f5				push af  
b9c4 3a d8 b9			ld a, (.dmark)  
b9c7 32 6b ee			ld (debug_mark),a  
b9ca 3a d9 b9			ld a, (.dmark+1)  
b9cd 32 6c ee			ld (debug_mark+1),a  
b9d0 3a da b9			ld a, (.dmark+2)  
b9d3 32 6d ee			ld (debug_mark+2),a  
b9d6 18 03			jr .pastdmark  
b9d8 ..			.dmark: db "AT?"  
b9db f1			.pastdmark: pop af  
b9dc			endm  
# End of macro DMARK
b9dc						CALLMONITOR 
b9dc cd 6f ee			call debug_vector  
b9df				endm  
# End of macro CALLMONITOR
b9df					endif 
b9df 3a 5e ea				ld a, (f_cursor_ptr) 
b9e2			 
b9e2			if DEBUG_FORTH_WORDS 
b9e2				DMARK "AT?" 
b9e2 f5				push af  
b9e3 3a f7 b9			ld a, (.dmark)  
b9e6 32 6b ee			ld (debug_mark),a  
b9e9 3a f8 b9			ld a, (.dmark+1)  
b9ec 32 6c ee			ld (debug_mark+1),a  
b9ef 3a f9 b9			ld a, (.dmark+2)  
b9f2 32 6d ee			ld (debug_mark+2),a  
b9f5 18 03			jr .pastdmark  
b9f7 ..			.dmark: db "AT?"  
b9fa f1			.pastdmark: pop af  
b9fb			endm  
# End of macro DMARK
b9fb				CALLMONITOR 
b9fb cd 6f ee			call debug_vector  
b9fe				endm  
# End of macro CALLMONITOR
b9fe			endif	 
b9fe					; count the number of rows 
b9fe			 
b9fe 06 00				ld b, 0 
ba00 4f			.atpr:		ld c, a    ; save in case we go below zero 
ba01 d6 28				sub display_cols 
ba03 f2 09 ba				jp p, .atprunder 
ba06 04					inc b 
ba07 18 f7				jr .atpr 
ba09			.atprunder:	 
ba09			if DEBUG_FORTH_WORDS 
ba09				DMARK "A?2" 
ba09 f5				push af  
ba0a 3a 1e ba			ld a, (.dmark)  
ba0d 32 6b ee			ld (debug_mark),a  
ba10 3a 1f ba			ld a, (.dmark+1)  
ba13 32 6c ee			ld (debug_mark+1),a  
ba16 3a 20 ba			ld a, (.dmark+2)  
ba19 32 6d ee			ld (debug_mark+2),a  
ba1c 18 03			jr .pastdmark  
ba1e ..			.dmark: db "A?2"  
ba21 f1			.pastdmark: pop af  
ba22			endm  
# End of macro DMARK
ba22				CALLMONITOR 
ba22 cd 6f ee			call debug_vector  
ba25				endm  
# End of macro CALLMONITOR
ba25			endif	 
ba25 26 00				ld h, 0 
ba27 69					ld l, c 
ba28 cd 4b 9b				call forth_push_numhl 
ba2b 68					ld l, b  
ba2c cd 4b 9b				call forth_push_numhl 
ba2f			 
ba2f			 
ba2f				NEXTW 
ba2f c3 f8 9e			jp macro_next 
ba32				endm 
# End of macro NEXTW
ba32			 
ba32			.FB: 
ba32				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
ba32 1b				db WORD_SYS_CORE+7             
ba33 80 ba			dw .EMIT            
ba35 03				db 2 + 1 
ba36 .. 00			db "FB",0              
ba39				endm 
# End of macro CWHEAD
ba39			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
ba39			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
ba39			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
ba39			; | | If automatic display is off then updates will not be shown until DRAW is used. 
ba39					if DEBUG_FORTH_WORDS_KEY 
ba39						DMARK "FB." 
ba39 f5				push af  
ba3a 3a 4e ba			ld a, (.dmark)  
ba3d 32 6b ee			ld (debug_mark),a  
ba40 3a 4f ba			ld a, (.dmark+1)  
ba43 32 6c ee			ld (debug_mark+1),a  
ba46 3a 50 ba			ld a, (.dmark+2)  
ba49 32 6d ee			ld (debug_mark+2),a  
ba4c 18 03			jr .pastdmark  
ba4e ..			.dmark: db "FB."  
ba51 f1			.pastdmark: pop af  
ba52			endm  
# End of macro DMARK
ba52						CALLMONITOR 
ba52 cd 6f ee			call debug_vector  
ba55				endm  
# End of macro CALLMONITOR
ba55					endif 
ba55			 
ba55					FORTH_DSP_VALUEHL 
ba55 cd 42 9d			call macro_dsp_valuehl 
ba58				endm 
# End of macro FORTH_DSP_VALUEHL
ba58			 
ba58 7d					ld a, l 
ba59 fe 01				cp 1 
ba5b 20 05				jr nz, .fbn1 
ba5d 21 10 ed				ld hl, display_fb1 
ba60 18 15				jr .fbset 
ba62 fe 02		.fbn1:		cp 2 
ba64 20 05				jr nz, .fbn2 
ba66 21 ce eb				ld hl, display_fb2 
ba69 18 0c				jr .fbset 
ba6b fe 03		.fbn2:		cp 3 
ba6d 20 05				jr nz, .fbn3 
ba6f 21 6f ec				ld hl, display_fb3 
ba72 18 03				jr .fbset 
ba74			.fbn3:		 ; if invalid number select first 
ba74 21 10 ed				ld hl, display_fb1 
ba77 22 cc eb		.fbset:		ld (display_fb_active), hl 
ba7a			 
ba7a					FORTH_DSP_POP 
ba7a cd fa 9d			call macro_forth_dsp_pop 
ba7d				endm 
# End of macro FORTH_DSP_POP
ba7d			 
ba7d					NEXTW 
ba7d c3 f8 9e			jp macro_next 
ba80				endm 
# End of macro NEXTW
ba80			 
ba80			 
ba80			.EMIT: 
ba80				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba80 1b				db WORD_SYS_CORE+7             
ba81 d1 ba			dw .DOTH            
ba83 05				db 4 + 1 
ba84 .. 00			db "EMIT",0              
ba89				endm 
# End of macro CWHEAD
ba89			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba89					; get value off TOS and display it 
ba89			 
ba89					if DEBUG_FORTH_WORDS_KEY 
ba89						DMARK "EMT" 
ba89 f5				push af  
ba8a 3a 9e ba			ld a, (.dmark)  
ba8d 32 6b ee			ld (debug_mark),a  
ba90 3a 9f ba			ld a, (.dmark+1)  
ba93 32 6c ee			ld (debug_mark+1),a  
ba96 3a a0 ba			ld a, (.dmark+2)  
ba99 32 6d ee			ld (debug_mark+2),a  
ba9c 18 03			jr .pastdmark  
ba9e ..			.dmark: db "EMT"  
baa1 f1			.pastdmark: pop af  
baa2			endm  
# End of macro DMARK
baa2						CALLMONITOR 
baa2 cd 6f ee			call debug_vector  
baa5				endm  
# End of macro CALLMONITOR
baa5					endif 
baa5			 
baa5					FORTH_DSP_VALUEHL 
baa5 cd 42 9d			call macro_dsp_valuehl 
baa8				endm 
# End of macro FORTH_DSP_VALUEHL
baa8			 
baa8 7d					ld a,l 
baa9			 
baa9					; TODO write to display 
baa9			 
baa9 32 bf e4				ld (os_input), a 
baac 3e 00				ld a, 0 
baae 32 c0 e4				ld (os_input+1), a 
bab1					 
bab1 3a 5e ea				ld a, (f_cursor_ptr) 
bab4 11 bf e4				ld de, os_input 
bab7 cd c2 8a				call str_at_display 
baba			 
baba			 
baba 3a 3c ea				ld a,(cli_autodisplay) 
babd fe 00				cp 0 
babf 28 03				jr z, .enoupdate 
bac1 cd d2 8a						call update_display 
bac4					.enoupdate: 
bac4			 
bac4 3a 5e ea				ld a, (f_cursor_ptr) 
bac7 3c					inc a 
bac8 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bacb			 
bacb			 
bacb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bacb cd fa 9d			call macro_forth_dsp_pop 
bace				endm 
# End of macro FORTH_DSP_POP
bace			  
bace			 
bace					NEXTW 
bace c3 f8 9e			jp macro_next 
bad1				endm 
# End of macro NEXTW
bad1			.DOTH: 
bad1				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bad1 1c				db WORD_SYS_CORE+8             
bad2 01 bb			dw .DOTF            
bad4 03				db 2 + 1 
bad5 .. 00			db ".-",0              
bad8				endm 
# End of macro CWHEAD
bad8			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bad8					; get value off TOS and display it 
bad8					if DEBUG_FORTH_WORDS_KEY 
bad8						DMARK "DTD" 
bad8 f5				push af  
bad9 3a ed ba			ld a, (.dmark)  
badc 32 6b ee			ld (debug_mark),a  
badf 3a ee ba			ld a, (.dmark+1)  
bae2 32 6c ee			ld (debug_mark+1),a  
bae5 3a ef ba			ld a, (.dmark+2)  
bae8 32 6d ee			ld (debug_mark+2),a  
baeb 18 03			jr .pastdmark  
baed ..			.dmark: db "DTD"  
baf0 f1			.pastdmark: pop af  
baf1			endm  
# End of macro DMARK
baf1						CALLMONITOR 
baf1 cd 6f ee			call debug_vector  
baf4				endm  
# End of macro CALLMONITOR
baf4					endif 
baf4 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
baf6 3e 00			ld a, 0 
baf8 32 3d ea			ld (cli_mvdot), a 
bafb c3 58 bb			jp .dotgo 
bafe				NEXTW 
bafe c3 f8 9e			jp macro_next 
bb01				endm 
# End of macro NEXTW
bb01			.DOTF: 
bb01				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bb01 1c				db WORD_SYS_CORE+8             
bb02 2f bb			dw .DOT            
bb04 03				db 2 + 1 
bb05 .. 00			db ".>",0              
bb08				endm 
# End of macro CWHEAD
bb08			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
bb08					; get value off TOS and display it 
bb08			        ; TODO BUG adds extra spaces 
bb08			        ; TODO BUG handle numerics? 
bb08					if DEBUG_FORTH_WORDS_KEY 
bb08						DMARK "DTC" 
bb08 f5				push af  
bb09 3a 1d bb			ld a, (.dmark)  
bb0c 32 6b ee			ld (debug_mark),a  
bb0f 3a 1e bb			ld a, (.dmark+1)  
bb12 32 6c ee			ld (debug_mark+1),a  
bb15 3a 1f bb			ld a, (.dmark+2)  
bb18 32 6d ee			ld (debug_mark+2),a  
bb1b 18 03			jr .pastdmark  
bb1d ..			.dmark: db "DTC"  
bb20 f1			.pastdmark: pop af  
bb21			endm  
# End of macro DMARK
bb21						CALLMONITOR 
bb21 cd 6f ee			call debug_vector  
bb24				endm  
# End of macro CALLMONITOR
bb24					endif 
bb24 3e 01			ld a, 1 
bb26 32 3d ea			ld (cli_mvdot), a 
bb29 c3 58 bb			jp .dotgo 
bb2c				NEXTW 
bb2c c3 f8 9e			jp macro_next 
bb2f				endm 
# End of macro NEXTW
bb2f			 
bb2f			.DOT: 
bb2f				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bb2f 1c				db WORD_SYS_CORE+8             
bb30 0b bd			dw .CLS            
bb32 02				db 1 + 1 
bb33 .. 00			db ".",0              
bb35				endm 
# End of macro CWHEAD
bb35			        ; | . ( u -- ) Display TOS | DONE 
bb35					; get value off TOS and display it 
bb35			 
bb35					if DEBUG_FORTH_WORDS_KEY 
bb35						DMARK "DOT" 
bb35 f5				push af  
bb36 3a 4a bb			ld a, (.dmark)  
bb39 32 6b ee			ld (debug_mark),a  
bb3c 3a 4b bb			ld a, (.dmark+1)  
bb3f 32 6c ee			ld (debug_mark+1),a  
bb42 3a 4c bb			ld a, (.dmark+2)  
bb45 32 6d ee			ld (debug_mark+2),a  
bb48 18 03			jr .pastdmark  
bb4a ..			.dmark: db "DOT"  
bb4d f1			.pastdmark: pop af  
bb4e			endm  
# End of macro DMARK
bb4e						CALLMONITOR 
bb4e cd 6f ee			call debug_vector  
bb51				endm  
# End of macro CALLMONITOR
bb51					endif 
bb51 3e 00			ld a, 0 
bb53 32 3d ea			ld (cli_mvdot), a 
bb56 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bb58				 
bb58			 
bb58			.dotgo: 
bb58			 
bb58			; move up type to on stack for parserv5 
bb58					FORTH_DSP 
bb58 cd 08 9d			call macro_forth_dsp 
bb5b				endm 
# End of macro FORTH_DSP
bb5b				;FORTH_DSP_VALUE  
bb5b			 
bb5b			if DEBUG_FORTH_DOT 
bb5b				DMARK "DOT" 
bb5b f5				push af  
bb5c 3a 70 bb			ld a, (.dmark)  
bb5f 32 6b ee			ld (debug_mark),a  
bb62 3a 71 bb			ld a, (.dmark+1)  
bb65 32 6c ee			ld (debug_mark+1),a  
bb68 3a 72 bb			ld a, (.dmark+2)  
bb6b 32 6d ee			ld (debug_mark+2),a  
bb6e 18 03			jr .pastdmark  
bb70 ..			.dmark: db "DOT"  
bb73 f1			.pastdmark: pop af  
bb74			endm  
# End of macro DMARK
bb74				CALLMONITOR 
bb74 cd 6f ee			call debug_vector  
bb77				endm  
# End of macro CALLMONITOR
bb77			endif	 
bb77			;		.print: 
bb77			 
bb77 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb78 23				inc hl   ; position to the actual value 
bb79 fe 01			cp DS_TYPE_STR 
bb7b 20 06			jr nz, .dotnum1  
bb7d			 
bb7d			; display string 
bb7d				FORTH_DSP_VALUE  
bb7d cd 2b 9d			call macro_forth_dsp_value 
bb80				endm 
# End of macro FORTH_DSP_VALUE
bb80 eb				ex de,hl 
bb81 18 49			jr .dotwrite 
bb83			 
bb83			.dotnum1: 
bb83 fe 02			cp DS_TYPE_INUM 
bb85 20 44			jr nz, .dotflot 
bb87			 
bb87			 
bb87			; display number 
bb87			 
bb87			;	push hl 
bb87			;	call clear_display 
bb87			;	pop hl 
bb87			 
bb87 5e				ld e, (hl) 
bb88 23				inc hl 
bb89 56				ld d, (hl) 
bb8a 21 c1 e2			ld hl, scratch 
bb8d			if DEBUG_FORTH_DOT 
bb8d				DMARK "DT1" 
bb8d f5				push af  
bb8e 3a a2 bb			ld a, (.dmark)  
bb91 32 6b ee			ld (debug_mark),a  
bb94 3a a3 bb			ld a, (.dmark+1)  
bb97 32 6c ee			ld (debug_mark+1),a  
bb9a 3a a4 bb			ld a, (.dmark+2)  
bb9d 32 6d ee			ld (debug_mark+2),a  
bba0 18 03			jr .pastdmark  
bba2 ..			.dmark: db "DT1"  
bba5 f1			.pastdmark: pop af  
bba6			endm  
# End of macro DMARK
bba6				CALLMONITOR 
bba6 cd 6f ee			call debug_vector  
bba9				endm  
# End of macro CALLMONITOR
bba9			endif	 
bba9			 
bba9 cd e9 90			call uitoa_16 
bbac eb				ex de,hl 
bbad			 
bbad			if DEBUG_FORTH_DOT 
bbad				DMARK "DT2" 
bbad f5				push af  
bbae 3a c2 bb			ld a, (.dmark)  
bbb1 32 6b ee			ld (debug_mark),a  
bbb4 3a c3 bb			ld a, (.dmark+1)  
bbb7 32 6c ee			ld (debug_mark+1),a  
bbba 3a c4 bb			ld a, (.dmark+2)  
bbbd 32 6d ee			ld (debug_mark+2),a  
bbc0 18 03			jr .pastdmark  
bbc2 ..			.dmark: db "DT2"  
bbc5 f1			.pastdmark: pop af  
bbc6			endm  
# End of macro DMARK
bbc6				CALLMONITOR 
bbc6 cd 6f ee			call debug_vector  
bbc9				endm  
# End of macro CALLMONITOR
bbc9			endif	 
bbc9			 
bbc9			;	ld de, os_word_scratch 
bbc9 18 01			jr .dotwrite 
bbcb			 
bbcb 00			.dotflot:   nop 
bbcc			; TODO print floating point number 
bbcc			 
bbcc			.dotwrite:		 
bbcc			 
bbcc					; if c is set then set all '-' to spaces 
bbcc					; need to also take into account .>  
bbcc			 
bbcc 3e 01				ld a, 1 
bbce b9					cp c 
bbcf 20 67				jr nz, .nodashswap 
bbd1			 
bbd1					; DE has the string to write, working with HL 
bbd1			 
bbd1 06 ff				ld b, 255 
bbd3 d5					push de 
bbd4 e1					pop hl 
bbd5			 
bbd5			if DEBUG_FORTH_DOT 
bbd5				DMARK "DT-" 
bbd5 f5				push af  
bbd6 3a ea bb			ld a, (.dmark)  
bbd9 32 6b ee			ld (debug_mark),a  
bbdc 3a eb bb			ld a, (.dmark+1)  
bbdf 32 6c ee			ld (debug_mark+1),a  
bbe2 3a ec bb			ld a, (.dmark+2)  
bbe5 32 6d ee			ld (debug_mark+2),a  
bbe8 18 03			jr .pastdmark  
bbea ..			.dmark: db "DT-"  
bbed f1			.pastdmark: pop af  
bbee			endm  
# End of macro DMARK
bbee				CALLMONITOR 
bbee cd 6f ee			call debug_vector  
bbf1				endm  
# End of macro CALLMONITOR
bbf1			endif	 
bbf1 7e			.dashscan:	ld a, (hl) 
bbf2 fe 00				cp 0 
bbf4 28 42				jr z, .nodashswap 
bbf6 fe 2d				cp '-' 
bbf8 20 03				jr nz, .dashskip 
bbfa 3e 20				ld a, ' ' 
bbfc 77					ld (hl), a 
bbfd 23			.dashskip:	inc hl 
bbfe			if DEBUG_FORTH_DOT 
bbfe				DMARK "D-2" 
bbfe f5				push af  
bbff 3a 13 bc			ld a, (.dmark)  
bc02 32 6b ee			ld (debug_mark),a  
bc05 3a 14 bc			ld a, (.dmark+1)  
bc08 32 6c ee			ld (debug_mark+1),a  
bc0b 3a 15 bc			ld a, (.dmark+2)  
bc0e 32 6d ee			ld (debug_mark+2),a  
bc11 18 03			jr .pastdmark  
bc13 ..			.dmark: db "D-2"  
bc16 f1			.pastdmark: pop af  
bc17			endm  
# End of macro DMARK
bc17				CALLMONITOR 
bc17 cd 6f ee			call debug_vector  
bc1a				endm  
# End of macro CALLMONITOR
bc1a			endif	 
bc1a 10 d5				djnz .dashscan 
bc1c			 
bc1c			if DEBUG_FORTH_DOT 
bc1c				DMARK "D-1" 
bc1c f5				push af  
bc1d 3a 31 bc			ld a, (.dmark)  
bc20 32 6b ee			ld (debug_mark),a  
bc23 3a 32 bc			ld a, (.dmark+1)  
bc26 32 6c ee			ld (debug_mark+1),a  
bc29 3a 33 bc			ld a, (.dmark+2)  
bc2c 32 6d ee			ld (debug_mark+2),a  
bc2f 18 03			jr .pastdmark  
bc31 ..			.dmark: db "D-1"  
bc34 f1			.pastdmark: pop af  
bc35			endm  
# End of macro DMARK
bc35				CALLMONITOR 
bc35 cd 6f ee			call debug_vector  
bc38				endm  
# End of macro CALLMONITOR
bc38			endif	 
bc38			 
bc38			.nodashswap: 
bc38			 
bc38			if DEBUG_FORTH_DOT 
bc38				DMARK "D-o" 
bc38 f5				push af  
bc39 3a 4d bc			ld a, (.dmark)  
bc3c 32 6b ee			ld (debug_mark),a  
bc3f 3a 4e bc			ld a, (.dmark+1)  
bc42 32 6c ee			ld (debug_mark+1),a  
bc45 3a 4f bc			ld a, (.dmark+2)  
bc48 32 6d ee			ld (debug_mark+2),a  
bc4b 18 03			jr .pastdmark  
bc4d ..			.dmark: db "D-o"  
bc50 f1			.pastdmark: pop af  
bc51			endm  
# End of macro DMARK
bc51				CALLMONITOR 
bc51 cd 6f ee			call debug_vector  
bc54				endm  
# End of macro CALLMONITOR
bc54			endif	 
bc54			 
bc54 d5					push de   ; save string start in case we need to advance print 
bc55			 
bc55 3a 5e ea				ld a, (f_cursor_ptr) 
bc58 cd c2 8a				call str_at_display 
bc5b 3a 3c ea				ld a,(cli_autodisplay) 
bc5e fe 00				cp 0 
bc60 28 03				jr z, .noupdate 
bc62 cd d2 8a						call update_display 
bc65					.noupdate: 
bc65			 
bc65			 
bc65					; see if we need to advance the print position 
bc65			 
bc65 e1					pop hl   ; get back string 
bc66			;		ex de,hl 
bc66			 
bc66 3a 3d ea				ld a, (cli_mvdot) 
bc69			if DEBUG_FORTH_DOT 
bc69			;		ld e,a 
bc69				DMARK "D>1" 
bc69 f5				push af  
bc6a 3a 7e bc			ld a, (.dmark)  
bc6d 32 6b ee			ld (debug_mark),a  
bc70 3a 7f bc			ld a, (.dmark+1)  
bc73 32 6c ee			ld (debug_mark+1),a  
bc76 3a 80 bc			ld a, (.dmark+2)  
bc79 32 6d ee			ld (debug_mark+2),a  
bc7c 18 03			jr .pastdmark  
bc7e ..			.dmark: db "D>1"  
bc81 f1			.pastdmark: pop af  
bc82			endm  
# End of macro DMARK
bc82				CALLMONITOR 
bc82 cd 6f ee			call debug_vector  
bc85				endm  
# End of macro CALLMONITOR
bc85			endif	 
bc85 fe 00				cp 0 
bc87 28 44				jr z, .noadv 
bc89					; yes, lets advance the print position 
bc89 3e 00				ld a, 0 
bc8b cd 45 91				call strlent 
bc8e			if DEBUG_FORTH_DOT 
bc8e				DMARK "D-?" 
bc8e f5				push af  
bc8f 3a a3 bc			ld a, (.dmark)  
bc92 32 6b ee			ld (debug_mark),a  
bc95 3a a4 bc			ld a, (.dmark+1)  
bc98 32 6c ee			ld (debug_mark+1),a  
bc9b 3a a5 bc			ld a, (.dmark+2)  
bc9e 32 6d ee			ld (debug_mark+2),a  
bca1 18 03			jr .pastdmark  
bca3 ..			.dmark: db "D-?"  
bca6 f1			.pastdmark: pop af  
bca7			endm  
# End of macro DMARK
bca7				CALLMONITOR 
bca7 cd 6f ee			call debug_vector  
bcaa				endm  
# End of macro CALLMONITOR
bcaa			endif	 
bcaa 3a 5e ea				ld a, (f_cursor_ptr) 
bcad 85					add a,l 
bcae					;call addatohl 
bcae					;ld a, l 
bcae 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bcb1			 
bcb1			if DEBUG_FORTH_DOT 
bcb1				DMARK "D->" 
bcb1 f5				push af  
bcb2 3a c6 bc			ld a, (.dmark)  
bcb5 32 6b ee			ld (debug_mark),a  
bcb8 3a c7 bc			ld a, (.dmark+1)  
bcbb 32 6c ee			ld (debug_mark+1),a  
bcbe 3a c8 bc			ld a, (.dmark+2)  
bcc1 32 6d ee			ld (debug_mark+2),a  
bcc4 18 03			jr .pastdmark  
bcc6 ..			.dmark: db "D->"  
bcc9 f1			.pastdmark: pop af  
bcca			endm  
# End of macro DMARK
bcca				CALLMONITOR 
bcca cd 6f ee			call debug_vector  
bccd				endm  
# End of macro CALLMONITOR
bccd			endif	 
bccd			 
bccd			.noadv:	 
bccd			 
bccd					if DEBUG_FORTH_DOT_WAIT 
bccd							call next_page_prompt 
bccd					endif	 
bccd			; TODO this pop off the stack causes a crash. i dont know why 
bccd			 
bccd			 
bccd			if DEBUG_FORTH_DOT 
bccd				DMARK "DTh" 
bccd f5				push af  
bcce 3a e2 bc			ld a, (.dmark)  
bcd1 32 6b ee			ld (debug_mark),a  
bcd4 3a e3 bc			ld a, (.dmark+1)  
bcd7 32 6c ee			ld (debug_mark+1),a  
bcda 3a e4 bc			ld a, (.dmark+2)  
bcdd 32 6d ee			ld (debug_mark+2),a  
bce0 18 03			jr .pastdmark  
bce2 ..			.dmark: db "DTh"  
bce5 f1			.pastdmark: pop af  
bce6			endm  
# End of macro DMARK
bce6				CALLMONITOR 
bce6 cd 6f ee			call debug_vector  
bce9				endm  
# End of macro CALLMONITOR
bce9			endif	 
bce9			 
bce9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bce9 cd fa 9d			call macro_forth_dsp_pop 
bcec				endm 
# End of macro FORTH_DSP_POP
bcec			 
bcec			if DEBUG_FORTH_DOT 
bcec				DMARK "DTi" 
bcec f5				push af  
bced 3a 01 bd			ld a, (.dmark)  
bcf0 32 6b ee			ld (debug_mark),a  
bcf3 3a 02 bd			ld a, (.dmark+1)  
bcf6 32 6c ee			ld (debug_mark+1),a  
bcf9 3a 03 bd			ld a, (.dmark+2)  
bcfc 32 6d ee			ld (debug_mark+2),a  
bcff 18 03			jr .pastdmark  
bd01 ..			.dmark: db "DTi"  
bd04 f1			.pastdmark: pop af  
bd05			endm  
# End of macro DMARK
bd05				CALLMONITOR 
bd05 cd 6f ee			call debug_vector  
bd08				endm  
# End of macro CALLMONITOR
bd08			endif	 
bd08			 
bd08			 
bd08					NEXTW 
bd08 c3 f8 9e			jp macro_next 
bd0b				endm 
# End of macro NEXTW
bd0b			 
bd0b			.CLS: 
bd0b				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bd0b 35				db WORD_SYS_CORE+33             
bd0c 38 bd			dw .DRAW            
bd0e 04				db 3 + 1 
bd0f .. 00			db "CLS",0              
bd13				endm 
# End of macro CWHEAD
bd13			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bd13					if DEBUG_FORTH_WORDS_KEY 
bd13						DMARK "CLS" 
bd13 f5				push af  
bd14 3a 28 bd			ld a, (.dmark)  
bd17 32 6b ee			ld (debug_mark),a  
bd1a 3a 29 bd			ld a, (.dmark+1)  
bd1d 32 6c ee			ld (debug_mark+1),a  
bd20 3a 2a bd			ld a, (.dmark+2)  
bd23 32 6d ee			ld (debug_mark+2),a  
bd26 18 03			jr .pastdmark  
bd28 ..			.dmark: db "CLS"  
bd2b f1			.pastdmark: pop af  
bd2c			endm  
# End of macro DMARK
bd2c						CALLMONITOR 
bd2c cd 6f ee			call debug_vector  
bd2f				endm  
# End of macro CALLMONITOR
bd2f					endif 
bd2f cd af 8a				call clear_display 
bd32 c3 46 be				jp .home		; and home cursor 
bd35					NEXTW 
bd35 c3 f8 9e			jp macro_next 
bd38				endm 
# End of macro NEXTW
bd38			 
bd38			.DRAW: 
bd38				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bd38 36				db WORD_SYS_CORE+34             
bd39 63 bd			dw .DUMP            
bd3b 05				db 4 + 1 
bd3c .. 00			db "DRAW",0              
bd41				endm 
# End of macro CWHEAD
bd41			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bd41					if DEBUG_FORTH_WORDS_KEY 
bd41						DMARK "DRW" 
bd41 f5				push af  
bd42 3a 56 bd			ld a, (.dmark)  
bd45 32 6b ee			ld (debug_mark),a  
bd48 3a 57 bd			ld a, (.dmark+1)  
bd4b 32 6c ee			ld (debug_mark+1),a  
bd4e 3a 58 bd			ld a, (.dmark+2)  
bd51 32 6d ee			ld (debug_mark+2),a  
bd54 18 03			jr .pastdmark  
bd56 ..			.dmark: db "DRW"  
bd59 f1			.pastdmark: pop af  
bd5a			endm  
# End of macro DMARK
bd5a						CALLMONITOR 
bd5a cd 6f ee			call debug_vector  
bd5d				endm  
# End of macro CALLMONITOR
bd5d					endif 
bd5d cd d2 8a				call update_display 
bd60					NEXTW 
bd60 c3 f8 9e			jp macro_next 
bd63				endm 
# End of macro NEXTW
bd63			 
bd63			.DUMP: 
bd63				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd63 37				db WORD_SYS_CORE+35             
bd64 9b bd			dw .CDUMP            
bd66 05				db 4 + 1 
bd67 .. 00			db "DUMP",0              
bd6c				endm 
# End of macro CWHEAD
bd6c			; | DUMP ( x -- ) With address x display dump   | DONE 
bd6c			; TODO pop address to use off of the stack 
bd6c					if DEBUG_FORTH_WORDS_KEY 
bd6c						DMARK "DUM" 
bd6c f5				push af  
bd6d 3a 81 bd			ld a, (.dmark)  
bd70 32 6b ee			ld (debug_mark),a  
bd73 3a 82 bd			ld a, (.dmark+1)  
bd76 32 6c ee			ld (debug_mark+1),a  
bd79 3a 83 bd			ld a, (.dmark+2)  
bd7c 32 6d ee			ld (debug_mark+2),a  
bd7f 18 03			jr .pastdmark  
bd81 ..			.dmark: db "DUM"  
bd84 f1			.pastdmark: pop af  
bd85			endm  
# End of macro DMARK
bd85						CALLMONITOR 
bd85 cd 6f ee			call debug_vector  
bd88				endm  
# End of macro CALLMONITOR
bd88					endif 
bd88 cd af 8a				call clear_display 
bd8b			 
bd8b					; get address 
bd8b			 
bd8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd8b cd 42 9d			call macro_dsp_valuehl 
bd8e				endm 
# End of macro FORTH_DSP_VALUEHL
bd8e				 
bd8e					; save it for cdump 
bd8e			 
bd8e 22 e4 e5				ld (os_cur_ptr),hl 
bd91			 
bd91					; destroy value TOS 
bd91			 
bd91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd91 cd fa 9d			call macro_forth_dsp_pop 
bd94				endm 
# End of macro FORTH_DSP_POP
bd94			 
bd94 cd cb 99				call dumpcont	; skip old style of param parsing	 
bd97 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd98					NEXTW 
bd98 c3 f8 9e			jp macro_next 
bd9b				endm 
# End of macro NEXTW
bd9b			.CDUMP: 
bd9b				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd9b 38				db WORD_SYS_CORE+36             
bd9c cb bd			dw .DAT            
bd9e 06				db 5 + 1 
bd9f .. 00			db "CDUMP",0              
bda5				endm 
# End of macro CWHEAD
bda5			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bda5					if DEBUG_FORTH_WORDS_KEY 
bda5						DMARK "CDP" 
bda5 f5				push af  
bda6 3a ba bd			ld a, (.dmark)  
bda9 32 6b ee			ld (debug_mark),a  
bdac 3a bb bd			ld a, (.dmark+1)  
bdaf 32 6c ee			ld (debug_mark+1),a  
bdb2 3a bc bd			ld a, (.dmark+2)  
bdb5 32 6d ee			ld (debug_mark+2),a  
bdb8 18 03			jr .pastdmark  
bdba ..			.dmark: db "CDP"  
bdbd f1			.pastdmark: pop af  
bdbe			endm  
# End of macro DMARK
bdbe						CALLMONITOR 
bdbe cd 6f ee			call debug_vector  
bdc1				endm  
# End of macro CALLMONITOR
bdc1					endif 
bdc1 cd af 8a				call clear_display 
bdc4 cd cb 99				call dumpcont	 
bdc7 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bdc8					NEXTW 
bdc8 c3 f8 9e			jp macro_next 
bdcb				endm 
# End of macro NEXTW
bdcb			 
bdcb			 
bdcb			 
bdcb			 
bdcb			.DAT: 
bdcb				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bdcb 3d				db WORD_SYS_CORE+41             
bdcc 21 be			dw .HOME            
bdce 03				db 2 + 1 
bdcf .. 00			db "AT",0              
bdd2				endm 
# End of macro CWHEAD
bdd2			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bdd2					if DEBUG_FORTH_WORDS_KEY 
bdd2						DMARK "AT." 
bdd2 f5				push af  
bdd3 3a e7 bd			ld a, (.dmark)  
bdd6 32 6b ee			ld (debug_mark),a  
bdd9 3a e8 bd			ld a, (.dmark+1)  
bddc 32 6c ee			ld (debug_mark+1),a  
bddf 3a e9 bd			ld a, (.dmark+2)  
bde2 32 6d ee			ld (debug_mark+2),a  
bde5 18 03			jr .pastdmark  
bde7 ..			.dmark: db "AT."  
bdea f1			.pastdmark: pop af  
bdeb			endm  
# End of macro DMARK
bdeb						CALLMONITOR 
bdeb cd 6f ee			call debug_vector  
bdee				endm  
# End of macro CALLMONITOR
bdee					endif 
bdee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdee cd 42 9d			call macro_dsp_valuehl 
bdf1				endm 
# End of macro FORTH_DSP_VALUEHL
bdf1			 
bdf1			 
bdf1					; TODO save cursor row 
bdf1 7d					ld a,l 
bdf2 fe 02				cp 2 
bdf4 20 04				jr nz, .crow3 
bdf6 3e 28				ld a, display_row_2 
bdf8 18 12				jr .ccol1 
bdfa fe 03		.crow3:		cp 3 
bdfc 20 04				jr nz, .crow4 
bdfe 3e 50				ld a, display_row_3 
be00 18 0a				jr .ccol1 
be02 fe 04		.crow4:		cp 4 
be04 20 04				jr nz, .crow1 
be06 3e 78				ld a, display_row_4 
be08 18 02				jr .ccol1 
be0a 3e 00		.crow1:		ld a,display_row_1 
be0c f5			.ccol1:		push af			; got row offset 
be0d 6f					ld l,a 
be0e 26 00				ld h,0 
be10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be10 cd fa 9d			call macro_forth_dsp_pop 
be13				endm 
# End of macro FORTH_DSP_POP
be13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be13 cd 42 9d			call macro_dsp_valuehl 
be16				endm 
# End of macro FORTH_DSP_VALUEHL
be16					; TODO save cursor col 
be16 f1					pop af 
be17 85					add l		; add col offset 
be18 32 5e ea				ld (f_cursor_ptr), a 
be1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be1b cd fa 9d			call macro_forth_dsp_pop 
be1e				endm 
# End of macro FORTH_DSP_POP
be1e			 
be1e					; calculate  
be1e			 
be1e					NEXTW 
be1e c3 f8 9e			jp macro_next 
be21				endm 
# End of macro NEXTW
be21			 
be21			 
be21			.HOME: 
be21				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
be21 41				db WORD_SYS_CORE+45             
be22 4e be			dw .SPACE            
be24 05				db 4 + 1 
be25 .. 00			db "HOME",0              
be2a				endm 
# End of macro CWHEAD
be2a			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
be2a					if DEBUG_FORTH_WORDS_KEY 
be2a						DMARK "HOM" 
be2a f5				push af  
be2b 3a 3f be			ld a, (.dmark)  
be2e 32 6b ee			ld (debug_mark),a  
be31 3a 40 be			ld a, (.dmark+1)  
be34 32 6c ee			ld (debug_mark+1),a  
be37 3a 41 be			ld a, (.dmark+2)  
be3a 32 6d ee			ld (debug_mark+2),a  
be3d 18 03			jr .pastdmark  
be3f ..			.dmark: db "HOM"  
be42 f1			.pastdmark: pop af  
be43			endm  
# End of macro DMARK
be43						CALLMONITOR 
be43 cd 6f ee			call debug_vector  
be46				endm  
# End of macro CALLMONITOR
be46					endif 
be46 3e 00		.home:		ld a, 0		; and home cursor 
be48 32 5e ea				ld (f_cursor_ptr), a 
be4b					NEXTW 
be4b c3 f8 9e			jp macro_next 
be4e				endm 
# End of macro NEXTW
be4e			 
be4e			 
be4e			.SPACE: 
be4e				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be4e 46				db WORD_SYS_CORE+50             
be4f 84 be			dw .SPACES            
be51 03				db 2 + 1 
be52 .. 00			db "BL",0              
be55				endm 
# End of macro CWHEAD
be55			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be55					if DEBUG_FORTH_WORDS_KEY 
be55						DMARK "BL." 
be55 f5				push af  
be56 3a 6a be			ld a, (.dmark)  
be59 32 6b ee			ld (debug_mark),a  
be5c 3a 6b be			ld a, (.dmark+1)  
be5f 32 6c ee			ld (debug_mark+1),a  
be62 3a 6c be			ld a, (.dmark+2)  
be65 32 6d ee			ld (debug_mark+2),a  
be68 18 03			jr .pastdmark  
be6a ..			.dmark: db "BL."  
be6d f1			.pastdmark: pop af  
be6e			endm  
# End of macro DMARK
be6e						CALLMONITOR 
be6e cd 6f ee			call debug_vector  
be71				endm  
# End of macro CALLMONITOR
be71					endif 
be71 3e 20				ld a, " " 
be73 32 c1 e2				ld (scratch),a 
be76 3e 00				ld a, 0 
be78 32 c2 e2				ld (scratch+1),a 
be7b 21 c1 e2				ld hl, scratch 
be7e cd b9 9b				call forth_push_str 
be81					 
be81				       NEXTW 
be81 c3 f8 9e			jp macro_next 
be84				endm 
# End of macro NEXTW
be84			 
be84			;.blstr: db " ", 0 
be84			 
be84			.SPACES: 
be84				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be84 47				db WORD_SYS_CORE+51             
be85 1f bf			dw .SCROLL            
be87 07				db 6 + 1 
be88 .. 00			db "SPACES",0              
be8f				endm 
# End of macro CWHEAD
be8f			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be8f					if DEBUG_FORTH_WORDS_KEY 
be8f						DMARK "SPS" 
be8f f5				push af  
be90 3a a4 be			ld a, (.dmark)  
be93 32 6b ee			ld (debug_mark),a  
be96 3a a5 be			ld a, (.dmark+1)  
be99 32 6c ee			ld (debug_mark+1),a  
be9c 3a a6 be			ld a, (.dmark+2)  
be9f 32 6d ee			ld (debug_mark+2),a  
bea2 18 03			jr .pastdmark  
bea4 ..			.dmark: db "SPS"  
bea7 f1			.pastdmark: pop af  
bea8			endm  
# End of macro DMARK
bea8						CALLMONITOR 
bea8 cd 6f ee			call debug_vector  
beab				endm  
# End of macro CALLMONITOR
beab					endif 
beab			 
beab			 
beab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beab cd 42 9d			call macro_dsp_valuehl 
beae				endm 
# End of macro FORTH_DSP_VALUEHL
beae			 
beae e5					push hl    ; u 
beaf					if DEBUG_FORTH_WORDS 
beaf						DMARK "SPA" 
beaf f5				push af  
beb0 3a c4 be			ld a, (.dmark)  
beb3 32 6b ee			ld (debug_mark),a  
beb6 3a c5 be			ld a, (.dmark+1)  
beb9 32 6c ee			ld (debug_mark+1),a  
bebc 3a c6 be			ld a, (.dmark+2)  
bebf 32 6d ee			ld (debug_mark+2),a  
bec2 18 03			jr .pastdmark  
bec4 ..			.dmark: db "SPA"  
bec7 f1			.pastdmark: pop af  
bec8			endm  
# End of macro DMARK
bec8						CALLMONITOR 
bec8 cd 6f ee			call debug_vector  
becb				endm  
# End of macro CALLMONITOR
becb					endif 
becb			 
becb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
becb cd fa 9d			call macro_forth_dsp_pop 
bece				endm 
# End of macro FORTH_DSP_POP
bece e1					pop hl 
becf 0e 00				ld c, 0 
bed1 45					ld b, l 
bed2 21 c1 e2				ld hl, scratch  
bed5			 
bed5					if DEBUG_FORTH_WORDS 
bed5						DMARK "SP2" 
bed5 f5				push af  
bed6 3a ea be			ld a, (.dmark)  
bed9 32 6b ee			ld (debug_mark),a  
bedc 3a eb be			ld a, (.dmark+1)  
bedf 32 6c ee			ld (debug_mark+1),a  
bee2 3a ec be			ld a, (.dmark+2)  
bee5 32 6d ee			ld (debug_mark+2),a  
bee8 18 03			jr .pastdmark  
beea ..			.dmark: db "SP2"  
beed f1			.pastdmark: pop af  
beee			endm  
# End of macro DMARK
beee						CALLMONITOR 
beee cd 6f ee			call debug_vector  
bef1				endm  
# End of macro CALLMONITOR
bef1					endif 
bef1 3e 20				ld a, ' ' 
bef3			.spaces1:	 
bef3 77					ld (hl),a 
bef4 23					inc hl 
bef5					 
bef5 10 fc				djnz .spaces1 
bef7 3e 00				ld a,0 
bef9 77					ld (hl),a 
befa 21 c1 e2				ld hl, scratch 
befd					if DEBUG_FORTH_WORDS 
befd						DMARK "SP3" 
befd f5				push af  
befe 3a 12 bf			ld a, (.dmark)  
bf01 32 6b ee			ld (debug_mark),a  
bf04 3a 13 bf			ld a, (.dmark+1)  
bf07 32 6c ee			ld (debug_mark+1),a  
bf0a 3a 14 bf			ld a, (.dmark+2)  
bf0d 32 6d ee			ld (debug_mark+2),a  
bf10 18 03			jr .pastdmark  
bf12 ..			.dmark: db "SP3"  
bf15 f1			.pastdmark: pop af  
bf16			endm  
# End of macro DMARK
bf16						CALLMONITOR 
bf16 cd 6f ee			call debug_vector  
bf19				endm  
# End of macro CALLMONITOR
bf19					endif 
bf19 cd b9 9b				call forth_push_str 
bf1c			 
bf1c				       NEXTW 
bf1c c3 f8 9e			jp macro_next 
bf1f				endm 
# End of macro NEXTW
bf1f			 
bf1f			 
bf1f			 
bf1f			.SCROLL: 
bf1f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bf1f 53				db WORD_SYS_CORE+63             
bf20 4c bf			dw .SCROLLD            
bf22 07				db 6 + 1 
bf23 .. 00			db "SCROLL",0              
bf2a				endm 
# End of macro CWHEAD
bf2a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bf2a					if DEBUG_FORTH_WORDS_KEY 
bf2a						DMARK "SCR" 
bf2a f5				push af  
bf2b 3a 3f bf			ld a, (.dmark)  
bf2e 32 6b ee			ld (debug_mark),a  
bf31 3a 40 bf			ld a, (.dmark+1)  
bf34 32 6c ee			ld (debug_mark+1),a  
bf37 3a 41 bf			ld a, (.dmark+2)  
bf3a 32 6d ee			ld (debug_mark+2),a  
bf3d 18 03			jr .pastdmark  
bf3f ..			.dmark: db "SCR"  
bf42 f1			.pastdmark: pop af  
bf43			endm  
# End of macro DMARK
bf43						CALLMONITOR 
bf43 cd 6f ee			call debug_vector  
bf46				endm  
# End of macro CALLMONITOR
bf46					endif 
bf46			 
bf46 cd 71 8a			call scroll_up 
bf49			;	call update_display 
bf49			 
bf49					NEXTW 
bf49 c3 f8 9e			jp macro_next 
bf4c				endm 
# End of macro NEXTW
bf4c			 
bf4c			 
bf4c			 
bf4c			;		; get dir 
bf4c			; 
bf4c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf4c			; 
bf4c			;		push hl 
bf4c			; 
bf4c			;		; destroy value TOS 
bf4c			; 
bf4c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf4c			; 
bf4c			;		; get count 
bf4c			; 
bf4c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf4c			; 
bf4c			;		push hl 
bf4c			; 
bf4c			;		; destroy value TOS 
bf4c			; 
bf4c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf4c			; 
bf4c			;		; one value on hl get other one back 
bf4c			; 
bf4c			;		pop bc    ; count 
bf4c			; 
bf4c			;		pop de   ; dir 
bf4c			; 
bf4c			; 
bf4c			;		ld b, c 
bf4c			; 
bf4c			;.scrolldir:     push bc 
bf4c			;		push de 
bf4c			; 
bf4c			;		ld a, 0 
bf4c			;		cp e 
bf4c			;		jr z, .scrollup  
bf4c			;		call scroll_down 
bf4c			;		jr .scrollnext 
bf4c			;.scrollup:	call scroll_up 
bf4c			; 
bf4c			;		 
bf4c			;.scrollnext: 
bf4c			;		pop de 
bf4c			;		pop bc 
bf4c			;		djnz .scrolldir 
bf4c			; 
bf4c			; 
bf4c			; 
bf4c			; 
bf4c			; 
bf4c			;		NEXTW 
bf4c			 
bf4c			.SCROLLD: 
bf4c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bf4c 53				db WORD_SYS_CORE+63             
bf4d 7a bf			dw .ATQ            
bf4f 08				db 7 + 1 
bf50 .. 00			db "SCROLLD",0              
bf58				endm 
# End of macro CWHEAD
bf58			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf58					if DEBUG_FORTH_WORDS_KEY 
bf58						DMARK "SCD" 
bf58 f5				push af  
bf59 3a 6d bf			ld a, (.dmark)  
bf5c 32 6b ee			ld (debug_mark),a  
bf5f 3a 6e bf			ld a, (.dmark+1)  
bf62 32 6c ee			ld (debug_mark+1),a  
bf65 3a 6f bf			ld a, (.dmark+2)  
bf68 32 6d ee			ld (debug_mark+2),a  
bf6b 18 03			jr .pastdmark  
bf6d ..			.dmark: db "SCD"  
bf70 f1			.pastdmark: pop af  
bf71			endm  
# End of macro DMARK
bf71						CALLMONITOR 
bf71 cd 6f ee			call debug_vector  
bf74				endm  
# End of macro CALLMONITOR
bf74					endif 
bf74			 
bf74 cd 95 8a			call scroll_down 
bf77			;	call update_display 
bf77			 
bf77					NEXTW 
bf77 c3 f8 9e			jp macro_next 
bf7a				endm 
# End of macro NEXTW
bf7a			 
bf7a			 
bf7a			.ATQ: 
bf7a				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf7a 62				db WORD_SYS_CORE+78             
bf7b d8 bf			dw .AUTODSP            
bf7d 04				db 3 + 1 
bf7e .. 00			db "AT@",0              
bf82				endm 
# End of macro CWHEAD
bf82			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf82					if DEBUG_FORTH_WORDS_KEY 
bf82						DMARK "ATA" 
bf82 f5				push af  
bf83 3a 97 bf			ld a, (.dmark)  
bf86 32 6b ee			ld (debug_mark),a  
bf89 3a 98 bf			ld a, (.dmark+1)  
bf8c 32 6c ee			ld (debug_mark+1),a  
bf8f 3a 99 bf			ld a, (.dmark+2)  
bf92 32 6d ee			ld (debug_mark+2),a  
bf95 18 03			jr .pastdmark  
bf97 ..			.dmark: db "ATA"  
bf9a f1			.pastdmark: pop af  
bf9b			endm  
# End of macro DMARK
bf9b						CALLMONITOR 
bf9b cd 6f ee			call debug_vector  
bf9e				endm  
# End of macro CALLMONITOR
bf9e					endif 
bf9e			 
bf9e			 
bf9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf9e cd 42 9d			call macro_dsp_valuehl 
bfa1				endm 
# End of macro FORTH_DSP_VALUEHL
bfa1			 
bfa1					; TODO save cursor row 
bfa1 7d					ld a,l 
bfa2 fe 02				cp 2 
bfa4 20 04				jr nz, .crow3aq 
bfa6 3e 28				ld a, display_row_2 
bfa8 18 12				jr .ccol1aq 
bfaa fe 03		.crow3aq:		cp 3 
bfac 20 04				jr nz, .crow4aq 
bfae 3e 50				ld a, display_row_3 
bfb0 18 0a				jr .ccol1aq 
bfb2 fe 04		.crow4aq:		cp 4 
bfb4 20 04				jr nz, .crow1aq 
bfb6 3e 78				ld a, display_row_4 
bfb8 18 02				jr .ccol1aq 
bfba 3e 00		.crow1aq:		ld a,display_row_1 
bfbc f5			.ccol1aq:		push af			; got row offset 
bfbd 6f					ld l,a 
bfbe 26 00				ld h,0 
bfc0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfc0 cd fa 9d			call macro_forth_dsp_pop 
bfc3				endm 
# End of macro FORTH_DSP_POP
bfc3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfc3 cd 42 9d			call macro_dsp_valuehl 
bfc6				endm 
# End of macro FORTH_DSP_VALUEHL
bfc6					; TODO save cursor col 
bfc6 f1					pop af 
bfc7 85					add l		; add col offset 
bfc8			 
bfc8					; add current frame buffer address 
bfc8 2a cc eb				ld hl, (display_fb_active) 
bfcb cd dc 8c				call addatohl 
bfce			 
bfce			 
bfce			 
bfce			 
bfce					; get char frame buffer location offset in hl 
bfce			 
bfce 7e					ld a,(hl) 
bfcf 26 00				ld h, 0 
bfd1 6f					ld l, a 
bfd2			 
bfd2 cd 4b 9b				call forth_push_numhl 
bfd5			 
bfd5			 
bfd5					NEXTW 
bfd5 c3 f8 9e			jp macro_next 
bfd8				endm 
# End of macro NEXTW
bfd8			 
bfd8			.AUTODSP: 
bfd8				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bfd8 63				db WORD_SYS_CORE+79             
bfd9 ee bf			dw .MENU            
bfdb 05				db 4 + 1 
bfdc .. 00			db "ADSP",0              
bfe1				endm 
# End of macro CWHEAD
bfe1			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bfe1			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bfe1			 
bfe1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfe1 cd 42 9d			call macro_dsp_valuehl 
bfe4				endm 
# End of macro FORTH_DSP_VALUEHL
bfe4			 
bfe4			;		push hl 
bfe4			 
bfe4					; destroy value TOS 
bfe4			 
bfe4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfe4 cd fa 9d			call macro_forth_dsp_pop 
bfe7				endm 
# End of macro FORTH_DSP_POP
bfe7			 
bfe7			;		pop hl 
bfe7			 
bfe7 7d					ld a,l 
bfe8 32 3c ea				ld (cli_autodisplay), a 
bfeb				       NEXTW 
bfeb c3 f8 9e			jp macro_next 
bfee				endm 
# End of macro NEXTW
bfee			 
bfee			.MENU: 
bfee				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bfee 70				db WORD_SYS_CORE+92             
bfef 97 c0			dw .ENDDISPLAY            
bff1 05				db 4 + 1 
bff2 .. 00			db "MENU",0              
bff7				endm 
# End of macro CWHEAD
bff7			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bff7			 
bff7			;		; get number of items on the stack 
bff7			; 
bff7				 
bff7					FORTH_DSP_VALUEHL 
bff7 cd 42 9d			call macro_dsp_valuehl 
bffa				endm 
# End of macro FORTH_DSP_VALUEHL
bffa				 
bffa					if DEBUG_FORTH_WORDS_KEY 
bffa						DMARK "MNU" 
bffa f5				push af  
bffb 3a 0f c0			ld a, (.dmark)  
bffe 32 6b ee			ld (debug_mark),a  
c001 3a 10 c0			ld a, (.dmark+1)  
c004 32 6c ee			ld (debug_mark+1),a  
c007 3a 11 c0			ld a, (.dmark+2)  
c00a 32 6d ee			ld (debug_mark+2),a  
c00d 18 03			jr .pastdmark  
c00f ..			.dmark: db "MNU"  
c012 f1			.pastdmark: pop af  
c013			endm  
# End of macro DMARK
c013						CALLMONITOR 
c013 cd 6f ee			call debug_vector  
c016				endm  
# End of macro CALLMONITOR
c016					endif 
c016			 
c016 45					ld b, l	 
c017 05					dec b 
c018			 
c018					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c018 cd fa 9d			call macro_forth_dsp_pop 
c01b				endm 
# End of macro FORTH_DSP_POP
c01b			 
c01b			 
c01b					; go directly through the stack to pluck out the string pointers and build an array 
c01b			 
c01b			;		FORTH_DSP 
c01b			 
c01b					; hl contains top most stack item 
c01b				 
c01b 11 c1 e2				ld de, scratch 
c01e			 
c01e			.mbuild: 
c01e			 
c01e					FORTH_DSP_VALUEHL 
c01e cd 42 9d			call macro_dsp_valuehl 
c021				endm 
# End of macro FORTH_DSP_VALUEHL
c021			 
c021					if DEBUG_FORTH_WORDS 
c021						DMARK "MN3" 
c021 f5				push af  
c022 3a 36 c0			ld a, (.dmark)  
c025 32 6b ee			ld (debug_mark),a  
c028 3a 37 c0			ld a, (.dmark+1)  
c02b 32 6c ee			ld (debug_mark+1),a  
c02e 3a 38 c0			ld a, (.dmark+2)  
c031 32 6d ee			ld (debug_mark+2),a  
c034 18 03			jr .pastdmark  
c036 ..			.dmark: db "MN3"  
c039 f1			.pastdmark: pop af  
c03a			endm  
# End of macro DMARK
c03a						CALLMONITOR 
c03a cd 6f ee			call debug_vector  
c03d				endm  
# End of macro CALLMONITOR
c03d					endif 
c03d eb					ex de, hl 
c03e 73					ld (hl), e 
c03f 23					inc hl 
c040 72					ld (hl), d 
c041 23					inc hl 
c042 eb					ex de, hl 
c043			 
c043					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c043 cd fa 9d			call macro_forth_dsp_pop 
c046				endm 
# End of macro FORTH_DSP_POP
c046			 
c046 10 d6				djnz .mbuild 
c048			 
c048					; done add term 
c048			 
c048 eb					ex de, hl 
c049 36 00				ld (hl), 0 
c04b 23					inc hl 
c04c 36 00				ld (hl), 0 
c04e			 
c04e				 
c04e					 
c04e 21 c1 e2				ld hl, scratch 
c051			 
c051					if DEBUG_FORTH_WORDS 
c051						DMARK "MNx" 
c051 f5				push af  
c052 3a 66 c0			ld a, (.dmark)  
c055 32 6b ee			ld (debug_mark),a  
c058 3a 67 c0			ld a, (.dmark+1)  
c05b 32 6c ee			ld (debug_mark+1),a  
c05e 3a 68 c0			ld a, (.dmark+2)  
c061 32 6d ee			ld (debug_mark+2),a  
c064 18 03			jr .pastdmark  
c066 ..			.dmark: db "MNx"  
c069 f1			.pastdmark: pop af  
c06a			endm  
# End of macro DMARK
c06a						CALLMONITOR 
c06a cd 6f ee			call debug_vector  
c06d				endm  
# End of macro CALLMONITOR
c06d					endif 
c06d			 
c06d			 
c06d			 
c06d 3e 00				ld a, 0 
c06f cd e0 8a				call menu 
c072			 
c072			 
c072 6f					ld l, a 
c073 26 00				ld h, 0 
c075			 
c075					if DEBUG_FORTH_WORDS 
c075						DMARK "MNr" 
c075 f5				push af  
c076 3a 8a c0			ld a, (.dmark)  
c079 32 6b ee			ld (debug_mark),a  
c07c 3a 8b c0			ld a, (.dmark+1)  
c07f 32 6c ee			ld (debug_mark+1),a  
c082 3a 8c c0			ld a, (.dmark+2)  
c085 32 6d ee			ld (debug_mark+2),a  
c088 18 03			jr .pastdmark  
c08a ..			.dmark: db "MNr"  
c08d f1			.pastdmark: pop af  
c08e			endm  
# End of macro DMARK
c08e						CALLMONITOR 
c08e cd 6f ee			call debug_vector  
c091				endm  
# End of macro CALLMONITOR
c091					endif 
c091			 
c091 cd 4b 9b				call forth_push_numhl 
c094			 
c094			 
c094			 
c094			 
c094				       NEXTW 
c094 c3 f8 9e			jp macro_next 
c097				endm 
# End of macro NEXTW
c097			 
c097			 
c097			.ENDDISPLAY: 
c097			 
c097			; eof 
# End of file forth_words_display.asm
c097			include "forth_words_str.asm" 
c097			 
c097			; | ## String Words 
c097			 
c097			.PTR:   
c097			 
c097				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c097 48				db WORD_SYS_CORE+52             
c098 c4 c0			dw .STYPE            
c09a 04				db 3 + 1 
c09b .. 00			db "PTR",0              
c09f				endm 
# End of macro CWHEAD
c09f			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c09f			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c09f			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c09f			 
c09f					if DEBUG_FORTH_WORDS_KEY 
c09f						DMARK "PTR" 
c09f f5				push af  
c0a0 3a b4 c0			ld a, (.dmark)  
c0a3 32 6b ee			ld (debug_mark),a  
c0a6 3a b5 c0			ld a, (.dmark+1)  
c0a9 32 6c ee			ld (debug_mark+1),a  
c0ac 3a b6 c0			ld a, (.dmark+2)  
c0af 32 6d ee			ld (debug_mark+2),a  
c0b2 18 03			jr .pastdmark  
c0b4 ..			.dmark: db "PTR"  
c0b7 f1			.pastdmark: pop af  
c0b8			endm  
# End of macro DMARK
c0b8						CALLMONITOR 
c0b8 cd 6f ee			call debug_vector  
c0bb				endm  
# End of macro CALLMONITOR
c0bb					endif 
c0bb					FORTH_DSP_VALUEHL 
c0bb cd 42 9d			call macro_dsp_valuehl 
c0be				endm 
# End of macro FORTH_DSP_VALUEHL
c0be cd 4b 9b				call forth_push_numhl 
c0c1			 
c0c1			 
c0c1					NEXTW 
c0c1 c3 f8 9e			jp macro_next 
c0c4				endm 
# End of macro NEXTW
c0c4			.STYPE: 
c0c4				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c0c4 48				db WORD_SYS_CORE+52             
c0c5 13 c1			dw .UPPER            
c0c7 06				db 5 + 1 
c0c8 .. 00			db "STYPE",0              
c0ce				endm 
# End of macro CWHEAD
c0ce			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c0ce					if DEBUG_FORTH_WORDS_KEY 
c0ce						DMARK "STY" 
c0ce f5				push af  
c0cf 3a e3 c0			ld a, (.dmark)  
c0d2 32 6b ee			ld (debug_mark),a  
c0d5 3a e4 c0			ld a, (.dmark+1)  
c0d8 32 6c ee			ld (debug_mark+1),a  
c0db 3a e5 c0			ld a, (.dmark+2)  
c0de 32 6d ee			ld (debug_mark+2),a  
c0e1 18 03			jr .pastdmark  
c0e3 ..			.dmark: db "STY"  
c0e6 f1			.pastdmark: pop af  
c0e7			endm  
# End of macro DMARK
c0e7						CALLMONITOR 
c0e7 cd 6f ee			call debug_vector  
c0ea				endm  
# End of macro CALLMONITOR
c0ea					endif 
c0ea					FORTH_DSP 
c0ea cd 08 9d			call macro_forth_dsp 
c0ed				endm 
# End of macro FORTH_DSP
c0ed					;v5 FORTH_DSP_VALUE 
c0ed			 
c0ed 7e					ld a, (hl) 
c0ee			 
c0ee f5					push af 
c0ef			 
c0ef			; Dont destroy TOS		FORTH_DSP_POP 
c0ef			 
c0ef f1					pop af 
c0f0			 
c0f0 fe 01				cp DS_TYPE_STR 
c0f2 28 09				jr z, .typestr 
c0f4			 
c0f4 fe 02				cp DS_TYPE_INUM 
c0f6 28 0a				jr z, .typeinum 
c0f8			 
c0f8 21 11 c1				ld hl, .tna 
c0fb 18 0a				jr .tpush 
c0fd			 
c0fd 21 0d c1		.typestr:	ld hl, .tstr 
c100 18 05				jr .tpush 
c102 21 0f c1		.typeinum:	ld hl, .tinum 
c105 18 00				jr .tpush 
c107			 
c107			.tpush: 
c107			 
c107 cd b9 9b				call forth_push_str 
c10a			 
c10a					NEXTW 
c10a c3 f8 9e			jp macro_next 
c10d				endm 
# End of macro NEXTW
c10d .. 00		.tstr:	db "s",0 
c10f .. 00		.tinum:  db "i",0 
c111 .. 00		.tna:   db "?", 0 
c113			 
c113			 
c113			.UPPER: 
c113				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c113 48				db WORD_SYS_CORE+52             
c114 4e c1			dw .LOWER            
c116 06				db 5 + 1 
c117 .. 00			db "UPPER",0              
c11d				endm 
# End of macro CWHEAD
c11d			; | UPPER ( s -- s ) Upper case string s  | DONE 
c11d					if DEBUG_FORTH_WORDS_KEY 
c11d						DMARK "UPR" 
c11d f5				push af  
c11e 3a 32 c1			ld a, (.dmark)  
c121 32 6b ee			ld (debug_mark),a  
c124 3a 33 c1			ld a, (.dmark+1)  
c127 32 6c ee			ld (debug_mark+1),a  
c12a 3a 34 c1			ld a, (.dmark+2)  
c12d 32 6d ee			ld (debug_mark+2),a  
c130 18 03			jr .pastdmark  
c132 ..			.dmark: db "UPR"  
c135 f1			.pastdmark: pop af  
c136			endm  
# End of macro DMARK
c136						CALLMONITOR 
c136 cd 6f ee			call debug_vector  
c139				endm  
# End of macro CALLMONITOR
c139					endif 
c139			 
c139					FORTH_DSP 
c139 cd 08 9d			call macro_forth_dsp 
c13c				endm 
# End of macro FORTH_DSP
c13c					 
c13c			; TODO check is string type 
c13c			 
c13c					FORTH_DSP_VALUEHL 
c13c cd 42 9d			call macro_dsp_valuehl 
c13f				endm 
# End of macro FORTH_DSP_VALUEHL
c13f			; get pointer to string in hl 
c13f			 
c13f 7e			.toup:		ld a, (hl) 
c140 fe 00				cp 0 
c142 28 07				jr z, .toupdone 
c144			 
c144 cd 49 90				call to_upper 
c147			 
c147 77					ld (hl), a 
c148 23					inc hl 
c149 18 f4				jr .toup 
c14b			 
c14b					 
c14b			 
c14b			 
c14b			; for each char convert to upper 
c14b					 
c14b			.toupdone: 
c14b			 
c14b			 
c14b					NEXTW 
c14b c3 f8 9e			jp macro_next 
c14e				endm 
# End of macro NEXTW
c14e			.LOWER: 
c14e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c14e 48				db WORD_SYS_CORE+52             
c14f 89 c1			dw .TCASE            
c151 06				db 5 + 1 
c152 .. 00			db "LOWER",0              
c158				endm 
# End of macro CWHEAD
c158			; | LOWER ( s -- s ) Lower case string s  | DONE 
c158					if DEBUG_FORTH_WORDS_KEY 
c158						DMARK "LWR" 
c158 f5				push af  
c159 3a 6d c1			ld a, (.dmark)  
c15c 32 6b ee			ld (debug_mark),a  
c15f 3a 6e c1			ld a, (.dmark+1)  
c162 32 6c ee			ld (debug_mark+1),a  
c165 3a 6f c1			ld a, (.dmark+2)  
c168 32 6d ee			ld (debug_mark+2),a  
c16b 18 03			jr .pastdmark  
c16d ..			.dmark: db "LWR"  
c170 f1			.pastdmark: pop af  
c171			endm  
# End of macro DMARK
c171						CALLMONITOR 
c171 cd 6f ee			call debug_vector  
c174				endm  
# End of macro CALLMONITOR
c174					endif 
c174			 
c174					FORTH_DSP 
c174 cd 08 9d			call macro_forth_dsp 
c177				endm 
# End of macro FORTH_DSP
c177					 
c177			; TODO check is string type 
c177			 
c177					FORTH_DSP_VALUEHL 
c177 cd 42 9d			call macro_dsp_valuehl 
c17a				endm 
# End of macro FORTH_DSP_VALUEHL
c17a			; get pointer to string in hl 
c17a			 
c17a 7e			.tolow:		ld a, (hl) 
c17b fe 00				cp 0 
c17d 28 07				jr z, .tolowdone 
c17f			 
c17f cd 52 90				call to_lower 
c182			 
c182 77					ld (hl), a 
c183 23					inc hl 
c184 18 f4				jr .tolow 
c186			 
c186					 
c186			 
c186			 
c186			; for each char convert to low 
c186					 
c186			.tolowdone: 
c186					NEXTW 
c186 c3 f8 9e			jp macro_next 
c189				endm 
# End of macro NEXTW
c189			.TCASE: 
c189				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c189 48				db WORD_SYS_CORE+52             
c18a bf c2			dw .SUBSTR            
c18c 06				db 5 + 1 
c18d .. 00			db "TCASE",0              
c193				endm 
# End of macro CWHEAD
c193			; | TCASE ( s -- s ) Title case string s  | DONE 
c193					if DEBUG_FORTH_WORDS_KEY 
c193						DMARK "TCS" 
c193 f5				push af  
c194 3a a8 c1			ld a, (.dmark)  
c197 32 6b ee			ld (debug_mark),a  
c19a 3a a9 c1			ld a, (.dmark+1)  
c19d 32 6c ee			ld (debug_mark+1),a  
c1a0 3a aa c1			ld a, (.dmark+2)  
c1a3 32 6d ee			ld (debug_mark+2),a  
c1a6 18 03			jr .pastdmark  
c1a8 ..			.dmark: db "TCS"  
c1ab f1			.pastdmark: pop af  
c1ac			endm  
# End of macro DMARK
c1ac						CALLMONITOR 
c1ac cd 6f ee			call debug_vector  
c1af				endm  
# End of macro CALLMONITOR
c1af					endif 
c1af			 
c1af					FORTH_DSP 
c1af cd 08 9d			call macro_forth_dsp 
c1b2				endm 
# End of macro FORTH_DSP
c1b2					 
c1b2			; TODO check is string type 
c1b2			 
c1b2					FORTH_DSP_VALUEHL 
c1b2 cd 42 9d			call macro_dsp_valuehl 
c1b5				endm 
# End of macro FORTH_DSP_VALUEHL
c1b5			; get pointer to string in hl 
c1b5			 
c1b5					if DEBUG_FORTH_WORDS 
c1b5						DMARK "TC1" 
c1b5 f5				push af  
c1b6 3a ca c1			ld a, (.dmark)  
c1b9 32 6b ee			ld (debug_mark),a  
c1bc 3a cb c1			ld a, (.dmark+1)  
c1bf 32 6c ee			ld (debug_mark+1),a  
c1c2 3a cc c1			ld a, (.dmark+2)  
c1c5 32 6d ee			ld (debug_mark+2),a  
c1c8 18 03			jr .pastdmark  
c1ca ..			.dmark: db "TC1"  
c1cd f1			.pastdmark: pop af  
c1ce			endm  
# End of macro DMARK
c1ce						CALLMONITOR 
c1ce cd 6f ee			call debug_vector  
c1d1				endm  
# End of macro CALLMONITOR
c1d1					endif 
c1d1			 
c1d1					; first time in turn to upper case first char 
c1d1			 
c1d1 7e					ld a, (hl) 
c1d2 c3 5c c2				jp .totsiptou 
c1d5			 
c1d5			 
c1d5 7e			.tot:		ld a, (hl) 
c1d6 fe 00				cp 0 
c1d8 ca a0 c2				jp z, .totdone 
c1db			 
c1db					if DEBUG_FORTH_WORDS 
c1db						DMARK "TC2" 
c1db f5				push af  
c1dc 3a f0 c1			ld a, (.dmark)  
c1df 32 6b ee			ld (debug_mark),a  
c1e2 3a f1 c1			ld a, (.dmark+1)  
c1e5 32 6c ee			ld (debug_mark+1),a  
c1e8 3a f2 c1			ld a, (.dmark+2)  
c1eb 32 6d ee			ld (debug_mark+2),a  
c1ee 18 03			jr .pastdmark  
c1f0 ..			.dmark: db "TC2"  
c1f3 f1			.pastdmark: pop af  
c1f4			endm  
# End of macro DMARK
c1f4						CALLMONITOR 
c1f4 cd 6f ee			call debug_vector  
c1f7				endm  
# End of macro CALLMONITOR
c1f7					endif 
c1f7					; check to see if current char is a space 
c1f7			 
c1f7 fe 20				cp ' ' 
c1f9 28 21				jr z, .totsp 
c1fb cd 52 90				call to_lower 
c1fe					if DEBUG_FORTH_WORDS 
c1fe						DMARK "TC3" 
c1fe f5				push af  
c1ff 3a 13 c2			ld a, (.dmark)  
c202 32 6b ee			ld (debug_mark),a  
c205 3a 14 c2			ld a, (.dmark+1)  
c208 32 6c ee			ld (debug_mark+1),a  
c20b 3a 15 c2			ld a, (.dmark+2)  
c20e 32 6d ee			ld (debug_mark+2),a  
c211 18 03			jr .pastdmark  
c213 ..			.dmark: db "TC3"  
c216 f1			.pastdmark: pop af  
c217			endm  
# End of macro DMARK
c217						CALLMONITOR 
c217 cd 6f ee			call debug_vector  
c21a				endm  
# End of macro CALLMONITOR
c21a					endif 
c21a 18 63				jr .totnxt 
c21c			 
c21c			.totsp:         ; on a space, find next char which should be upper 
c21c			 
c21c					if DEBUG_FORTH_WORDS 
c21c						DMARK "TC4" 
c21c f5				push af  
c21d 3a 31 c2			ld a, (.dmark)  
c220 32 6b ee			ld (debug_mark),a  
c223 3a 32 c2			ld a, (.dmark+1)  
c226 32 6c ee			ld (debug_mark+1),a  
c229 3a 33 c2			ld a, (.dmark+2)  
c22c 32 6d ee			ld (debug_mark+2),a  
c22f 18 03			jr .pastdmark  
c231 ..			.dmark: db "TC4"  
c234 f1			.pastdmark: pop af  
c235			endm  
# End of macro DMARK
c235						CALLMONITOR 
c235 cd 6f ee			call debug_vector  
c238				endm  
# End of macro CALLMONITOR
c238					endif 
c238					;; 
c238			 
c238 fe 20				cp ' ' 
c23a 20 20				jr nz, .totsiptou 
c23c 23					inc hl 
c23d 7e					ld a, (hl) 
c23e					if DEBUG_FORTH_WORDS 
c23e						DMARK "TC5" 
c23e f5				push af  
c23f 3a 53 c2			ld a, (.dmark)  
c242 32 6b ee			ld (debug_mark),a  
c245 3a 54 c2			ld a, (.dmark+1)  
c248 32 6c ee			ld (debug_mark+1),a  
c24b 3a 55 c2			ld a, (.dmark+2)  
c24e 32 6d ee			ld (debug_mark+2),a  
c251 18 03			jr .pastdmark  
c253 ..			.dmark: db "TC5"  
c256 f1			.pastdmark: pop af  
c257			endm  
# End of macro DMARK
c257						CALLMONITOR 
c257 cd 6f ee			call debug_vector  
c25a				endm  
# End of macro CALLMONITOR
c25a					endif 
c25a 18 c0				jr .totsp 
c25c fe 00		.totsiptou:    cp 0 
c25e 28 40				jr z, .totdone 
c260					; not space and not zero term so upper case it 
c260 cd 49 90				call to_upper 
c263			 
c263					if DEBUG_FORTH_WORDS 
c263						DMARK "TC6" 
c263 f5				push af  
c264 3a 78 c2			ld a, (.dmark)  
c267 32 6b ee			ld (debug_mark),a  
c26a 3a 79 c2			ld a, (.dmark+1)  
c26d 32 6c ee			ld (debug_mark+1),a  
c270 3a 7a c2			ld a, (.dmark+2)  
c273 32 6d ee			ld (debug_mark+2),a  
c276 18 03			jr .pastdmark  
c278 ..			.dmark: db "TC6"  
c27b f1			.pastdmark: pop af  
c27c			endm  
# End of macro DMARK
c27c						CALLMONITOR 
c27c cd 6f ee			call debug_vector  
c27f				endm  
# End of macro CALLMONITOR
c27f					endif 
c27f			 
c27f			 
c27f			.totnxt: 
c27f			 
c27f 77					ld (hl), a 
c280 23					inc hl 
c281					if DEBUG_FORTH_WORDS 
c281						DMARK "TC7" 
c281 f5				push af  
c282 3a 96 c2			ld a, (.dmark)  
c285 32 6b ee			ld (debug_mark),a  
c288 3a 97 c2			ld a, (.dmark+1)  
c28b 32 6c ee			ld (debug_mark+1),a  
c28e 3a 98 c2			ld a, (.dmark+2)  
c291 32 6d ee			ld (debug_mark+2),a  
c294 18 03			jr .pastdmark  
c296 ..			.dmark: db "TC7"  
c299 f1			.pastdmark: pop af  
c29a			endm  
# End of macro DMARK
c29a						CALLMONITOR 
c29a cd 6f ee			call debug_vector  
c29d				endm  
# End of macro CALLMONITOR
c29d					endif 
c29d c3 d5 c1				jp .tot 
c2a0			 
c2a0					 
c2a0			 
c2a0			 
c2a0			; for each char convert to low 
c2a0					 
c2a0			.totdone: 
c2a0					if DEBUG_FORTH_WORDS 
c2a0						DMARK "TCd" 
c2a0 f5				push af  
c2a1 3a b5 c2			ld a, (.dmark)  
c2a4 32 6b ee			ld (debug_mark),a  
c2a7 3a b6 c2			ld a, (.dmark+1)  
c2aa 32 6c ee			ld (debug_mark+1),a  
c2ad 3a b7 c2			ld a, (.dmark+2)  
c2b0 32 6d ee			ld (debug_mark+2),a  
c2b3 18 03			jr .pastdmark  
c2b5 ..			.dmark: db "TCd"  
c2b8 f1			.pastdmark: pop af  
c2b9			endm  
# End of macro DMARK
c2b9						CALLMONITOR 
c2b9 cd 6f ee			call debug_vector  
c2bc				endm  
# End of macro CALLMONITOR
c2bc					endif 
c2bc					NEXTW 
c2bc c3 f8 9e			jp macro_next 
c2bf				endm 
# End of macro NEXTW
c2bf			 
c2bf			.SUBSTR: 
c2bf				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c2bf 48				db WORD_SYS_CORE+52             
c2c0 1d c3			dw .LEFT            
c2c2 07				db 6 + 1 
c2c3 .. 00			db "SUBSTR",0              
c2ca				endm 
# End of macro CWHEAD
c2ca			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c2ca			 
c2ca					if DEBUG_FORTH_WORDS_KEY 
c2ca						DMARK "SST" 
c2ca f5				push af  
c2cb 3a df c2			ld a, (.dmark)  
c2ce 32 6b ee			ld (debug_mark),a  
c2d1 3a e0 c2			ld a, (.dmark+1)  
c2d4 32 6c ee			ld (debug_mark+1),a  
c2d7 3a e1 c2			ld a, (.dmark+2)  
c2da 32 6d ee			ld (debug_mark+2),a  
c2dd 18 03			jr .pastdmark  
c2df ..			.dmark: db "SST"  
c2e2 f1			.pastdmark: pop af  
c2e3			endm  
# End of macro DMARK
c2e3						CALLMONITOR 
c2e3 cd 6f ee			call debug_vector  
c2e6				endm  
# End of macro CALLMONITOR
c2e6					endif 
c2e6			; TODO check string type 
c2e6					FORTH_DSP_VALUEHL 
c2e6 cd 42 9d			call macro_dsp_valuehl 
c2e9				endm 
# End of macro FORTH_DSP_VALUEHL
c2e9			 
c2e9 e5					push hl      ; string length 
c2ea			 
c2ea					FORTH_DSP_POP 
c2ea cd fa 9d			call macro_forth_dsp_pop 
c2ed				endm 
# End of macro FORTH_DSP_POP
c2ed			 
c2ed					FORTH_DSP_VALUEHL 
c2ed cd 42 9d			call macro_dsp_valuehl 
c2f0				endm 
# End of macro FORTH_DSP_VALUEHL
c2f0			 
c2f0 e5					push hl     ; start char 
c2f1			 
c2f1					FORTH_DSP_POP 
c2f1 cd fa 9d			call macro_forth_dsp_pop 
c2f4				endm 
# End of macro FORTH_DSP_POP
c2f4			 
c2f4			 
c2f4					FORTH_DSP_VALUE 
c2f4 cd 2b 9d			call macro_forth_dsp_value 
c2f7				endm 
# End of macro FORTH_DSP_VALUE
c2f7			 
c2f7 d1					pop de    ; get start post offset 
c2f8			 
c2f8 19					add hl, de    ; starting offset 
c2f9			 
c2f9 c1					pop bc 
c2fa c5					push bc      ; grab size of string 
c2fb			 
c2fb e5					push hl    ; save string start  
c2fc			 
c2fc 26 00				ld h, 0 
c2fe 69					ld l, c 
c2ff 23					inc hl 
c300 23					inc hl 
c301			 
c301 cd a3 91				call malloc 
c304				if DEBUG_FORTH_MALLOC_GUARD 
c304 cc 37 cc				call z,malloc_error 
c307				endif 
c307			 
c307 eb					ex de, hl      ; save malloc area for string copy 
c308 e1					pop hl    ; get back source 
c309 c1					pop bc    ; get length of string back 
c30a			 
c30a d5					push de    ; save malloc area for after we push 
c30b ed b0				ldir     ; copy substr 
c30d			 
c30d			 
c30d eb					ex de, hl 
c30e 3e 00				ld a, 0 
c310 77					ld (hl), a   ; term substr 
c311			 
c311					 
c311 e1					pop hl    ; get malloc so we can push it 
c312 e5					push hl   ; save so we can free it afterwards 
c313			 
c313 cd b9 9b				call forth_push_str 
c316			 
c316 e1					pop hl 
c317 cd 6d 92				call free 
c31a			 
c31a					 
c31a					 
c31a			 
c31a			 
c31a					NEXTW 
c31a c3 f8 9e			jp macro_next 
c31d				endm 
# End of macro NEXTW
c31d			 
c31d			.LEFT: 
c31d				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c31d 48				db WORD_SYS_CORE+52             
c31e 45 c3			dw .RIGHT            
c320 05				db 4 + 1 
c321 .. 00			db "LEFT",0              
c326				endm 
# End of macro CWHEAD
c326			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c326					if DEBUG_FORTH_WORDS_KEY 
c326						DMARK "LEF" 
c326 f5				push af  
c327 3a 3b c3			ld a, (.dmark)  
c32a 32 6b ee			ld (debug_mark),a  
c32d 3a 3c c3			ld a, (.dmark+1)  
c330 32 6c ee			ld (debug_mark+1),a  
c333 3a 3d c3			ld a, (.dmark+2)  
c336 32 6d ee			ld (debug_mark+2),a  
c339 18 03			jr .pastdmark  
c33b ..			.dmark: db "LEF"  
c33e f1			.pastdmark: pop af  
c33f			endm  
# End of macro DMARK
c33f						CALLMONITOR 
c33f cd 6f ee			call debug_vector  
c342				endm  
# End of macro CALLMONITOR
c342					endif 
c342			 
c342					NEXTW 
c342 c3 f8 9e			jp macro_next 
c345				endm 
# End of macro NEXTW
c345			.RIGHT: 
c345				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c345 48				db WORD_SYS_CORE+52             
c346 6e c3			dw .STR2NUM            
c348 06				db 5 + 1 
c349 .. 00			db "RIGHT",0              
c34f				endm 
# End of macro CWHEAD
c34f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c34f					if DEBUG_FORTH_WORDS_KEY 
c34f						DMARK "RIG" 
c34f f5				push af  
c350 3a 64 c3			ld a, (.dmark)  
c353 32 6b ee			ld (debug_mark),a  
c356 3a 65 c3			ld a, (.dmark+1)  
c359 32 6c ee			ld (debug_mark+1),a  
c35c 3a 66 c3			ld a, (.dmark+2)  
c35f 32 6d ee			ld (debug_mark+2),a  
c362 18 03			jr .pastdmark  
c364 ..			.dmark: db "RIG"  
c367 f1			.pastdmark: pop af  
c368			endm  
# End of macro DMARK
c368						CALLMONITOR 
c368 cd 6f ee			call debug_vector  
c36b				endm  
# End of macro CALLMONITOR
c36b					endif 
c36b			 
c36b					NEXTW 
c36b c3 f8 9e			jp macro_next 
c36e				endm 
# End of macro NEXTW
c36e			 
c36e			 
c36e			.STR2NUM: 
c36e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c36e 48				db WORD_SYS_CORE+52             
c36f fa c3			dw .NUM2STR            
c371 08				db 7 + 1 
c372 .. 00			db "STR2NUM",0              
c37a				endm 
# End of macro CWHEAD
c37a			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c37a			 
c37a			 
c37a			; TODO STR type check to do 
c37a					if DEBUG_FORTH_WORDS_KEY 
c37a						DMARK "S2N" 
c37a f5				push af  
c37b 3a 8f c3			ld a, (.dmark)  
c37e 32 6b ee			ld (debug_mark),a  
c381 3a 90 c3			ld a, (.dmark+1)  
c384 32 6c ee			ld (debug_mark+1),a  
c387 3a 91 c3			ld a, (.dmark+2)  
c38a 32 6d ee			ld (debug_mark+2),a  
c38d 18 03			jr .pastdmark  
c38f ..			.dmark: db "S2N"  
c392 f1			.pastdmark: pop af  
c393			endm  
# End of macro DMARK
c393						CALLMONITOR 
c393 cd 6f ee			call debug_vector  
c396				endm  
# End of macro CALLMONITOR
c396					endif 
c396			 
c396					;FORTH_DSP 
c396					FORTH_DSP_VALUE 
c396 cd 2b 9d			call macro_forth_dsp_value 
c399				endm 
# End of macro FORTH_DSP_VALUE
c399					;inc hl 
c399			 
c399 eb					ex de, hl 
c39a					if DEBUG_FORTH_WORDS 
c39a						DMARK "S2a" 
c39a f5				push af  
c39b 3a af c3			ld a, (.dmark)  
c39e 32 6b ee			ld (debug_mark),a  
c3a1 3a b0 c3			ld a, (.dmark+1)  
c3a4 32 6c ee			ld (debug_mark+1),a  
c3a7 3a b1 c3			ld a, (.dmark+2)  
c3aa 32 6d ee			ld (debug_mark+2),a  
c3ad 18 03			jr .pastdmark  
c3af ..			.dmark: db "S2a"  
c3b2 f1			.pastdmark: pop af  
c3b3			endm  
# End of macro DMARK
c3b3						CALLMONITOR 
c3b3 cd 6f ee			call debug_vector  
c3b6				endm  
# End of macro CALLMONITOR
c3b6					endif 
c3b6 cd d1 90				call string_to_uint16 
c3b9			 
c3b9					if DEBUG_FORTH_WORDS 
c3b9						DMARK "S2b" 
c3b9 f5				push af  
c3ba 3a ce c3			ld a, (.dmark)  
c3bd 32 6b ee			ld (debug_mark),a  
c3c0 3a cf c3			ld a, (.dmark+1)  
c3c3 32 6c ee			ld (debug_mark+1),a  
c3c6 3a d0 c3			ld a, (.dmark+2)  
c3c9 32 6d ee			ld (debug_mark+2),a  
c3cc 18 03			jr .pastdmark  
c3ce ..			.dmark: db "S2b"  
c3d1 f1			.pastdmark: pop af  
c3d2			endm  
# End of macro DMARK
c3d2						CALLMONITOR 
c3d2 cd 6f ee			call debug_vector  
c3d5				endm  
# End of macro CALLMONITOR
c3d5					endif 
c3d5			;		push hl 
c3d5					FORTH_DSP_POP 
c3d5 cd fa 9d			call macro_forth_dsp_pop 
c3d8				endm 
# End of macro FORTH_DSP_POP
c3d8			;		pop hl 
c3d8					 
c3d8					if DEBUG_FORTH_WORDS 
c3d8						DMARK "S2b" 
c3d8 f5				push af  
c3d9 3a ed c3			ld a, (.dmark)  
c3dc 32 6b ee			ld (debug_mark),a  
c3df 3a ee c3			ld a, (.dmark+1)  
c3e2 32 6c ee			ld (debug_mark+1),a  
c3e5 3a ef c3			ld a, (.dmark+2)  
c3e8 32 6d ee			ld (debug_mark+2),a  
c3eb 18 03			jr .pastdmark  
c3ed ..			.dmark: db "S2b"  
c3f0 f1			.pastdmark: pop af  
c3f1			endm  
# End of macro DMARK
c3f1						CALLMONITOR 
c3f1 cd 6f ee			call debug_vector  
c3f4				endm  
# End of macro CALLMONITOR
c3f4					endif 
c3f4 cd 4b 9b				call forth_push_numhl	 
c3f7			 
c3f7				 
c3f7				       NEXTW 
c3f7 c3 f8 9e			jp macro_next 
c3fa				endm 
# End of macro NEXTW
c3fa			.NUM2STR: 
c3fa				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3fa 48				db WORD_SYS_CORE+52             
c3fb 09 c4			dw .CONCAT            
c3fd 08				db 7 + 1 
c3fe .. 00			db "NUM2STR",0              
c406				endm 
# End of macro CWHEAD
c406			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c406			 
c406			;		; malloc a string to target 
c406			;		ld hl, 10     ; TODO max string size should be fine 
c406			;		call malloc 
c406			;		push hl    ; save malloc location 
c406			; 
c406			; 
c406			;; TODO check int type 
c406			;		FORTH_DSP_VALUEHL 
c406			;		ld a, l 
c406			;		call DispAToASCII   
c406			;;TODO need to chage above call to dump into string 
c406			; 
c406			; 
c406			 
c406				       NEXTW 
c406 c3 f8 9e			jp macro_next 
c409				endm 
# End of macro NEXTW
c409			 
c409			.CONCAT: 
c409				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c409 48				db WORD_SYS_CORE+52             
c40a bc c4			dw .FIND            
c40c 07				db 6 + 1 
c40d .. 00			db "CONCAT",0              
c414				endm 
# End of macro CWHEAD
c414			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c414			 
c414			; TODO check string type 
c414			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c414			 
c414					if DEBUG_FORTH_WORDS_KEY 
c414						DMARK "CON" 
c414 f5				push af  
c415 3a 29 c4			ld a, (.dmark)  
c418 32 6b ee			ld (debug_mark),a  
c41b 3a 2a c4			ld a, (.dmark+1)  
c41e 32 6c ee			ld (debug_mark+1),a  
c421 3a 2b c4			ld a, (.dmark+2)  
c424 32 6d ee			ld (debug_mark+2),a  
c427 18 03			jr .pastdmark  
c429 ..			.dmark: db "CON"  
c42c f1			.pastdmark: pop af  
c42d			endm  
# End of macro DMARK
c42d						CALLMONITOR 
c42d cd 6f ee			call debug_vector  
c430				endm  
# End of macro CALLMONITOR
c430					endif 
c430			 
c430			 
c430					FORTH_DSP_VALUE 
c430 cd 2b 9d			call macro_forth_dsp_value 
c433				endm 
# End of macro FORTH_DSP_VALUE
c433 e5					push hl   ; s2 
c434			 
c434					FORTH_DSP_POP 
c434 cd fa 9d			call macro_forth_dsp_pop 
c437				endm 
# End of macro FORTH_DSP_POP
c437			 
c437					FORTH_DSP_VALUE 
c437 cd 2b 9d			call macro_forth_dsp_value 
c43a				endm 
# End of macro FORTH_DSP_VALUE
c43a			 
c43a e5					push hl   ; s1 
c43b			 
c43b					FORTH_DSP_POP 
c43b cd fa 9d			call macro_forth_dsp_pop 
c43e				endm 
# End of macro FORTH_DSP_POP
c43e					 
c43e			 
c43e					; copy s1 
c43e			 
c43e				 
c43e					; save ptr 
c43e e1					pop hl  
c43f e5					push hl 
c440 3e 00				ld a, 0 
c442 cd 45 91				call strlent 
c445					;inc hl    ; zer0 
c445 06 00				ld b, 0 
c447 4d					ld c, l 
c448 e1					pop hl		 
c449 11 c1 e2				ld de, scratch	 
c44c					if DEBUG_FORTH_WORDS 
c44c						DMARK "CO1" 
c44c f5				push af  
c44d 3a 61 c4			ld a, (.dmark)  
c450 32 6b ee			ld (debug_mark),a  
c453 3a 62 c4			ld a, (.dmark+1)  
c456 32 6c ee			ld (debug_mark+1),a  
c459 3a 63 c4			ld a, (.dmark+2)  
c45c 32 6d ee			ld (debug_mark+2),a  
c45f 18 03			jr .pastdmark  
c461 ..			.dmark: db "CO1"  
c464 f1			.pastdmark: pop af  
c465			endm  
# End of macro DMARK
c465						CALLMONITOR 
c465 cd 6f ee			call debug_vector  
c468				endm  
# End of macro CALLMONITOR
c468					endif 
c468 ed b0				ldir 
c46a			 
c46a e1					pop hl 
c46b e5					push hl 
c46c d5					push de 
c46d			 
c46d			 
c46d 3e 00				ld a, 0 
c46f cd 45 91				call strlent 
c472 23					inc hl    ; zer0 
c473 23					inc hl 
c474 06 00				ld b, 0 
c476 4d					ld c, l 
c477 d1					pop de 
c478 e1					pop hl		 
c479					if DEBUG_FORTH_WORDS 
c479						DMARK "CO2" 
c479 f5				push af  
c47a 3a 8e c4			ld a, (.dmark)  
c47d 32 6b ee			ld (debug_mark),a  
c480 3a 8f c4			ld a, (.dmark+1)  
c483 32 6c ee			ld (debug_mark+1),a  
c486 3a 90 c4			ld a, (.dmark+2)  
c489 32 6d ee			ld (debug_mark+2),a  
c48c 18 03			jr .pastdmark  
c48e ..			.dmark: db "CO2"  
c491 f1			.pastdmark: pop af  
c492			endm  
# End of macro DMARK
c492						CALLMONITOR 
c492 cd 6f ee			call debug_vector  
c495				endm  
# End of macro CALLMONITOR
c495					endif 
c495 ed b0				ldir 
c497			 
c497			 
c497			 
c497 21 c1 e2				ld hl, scratch 
c49a					if DEBUG_FORTH_WORDS 
c49a						DMARK "CO5" 
c49a f5				push af  
c49b 3a af c4			ld a, (.dmark)  
c49e 32 6b ee			ld (debug_mark),a  
c4a1 3a b0 c4			ld a, (.dmark+1)  
c4a4 32 6c ee			ld (debug_mark+1),a  
c4a7 3a b1 c4			ld a, (.dmark+2)  
c4aa 32 6d ee			ld (debug_mark+2),a  
c4ad 18 03			jr .pastdmark  
c4af ..			.dmark: db "CO5"  
c4b2 f1			.pastdmark: pop af  
c4b3			endm  
# End of macro DMARK
c4b3						CALLMONITOR 
c4b3 cd 6f ee			call debug_vector  
c4b6				endm  
# End of macro CALLMONITOR
c4b6					endif 
c4b6			 
c4b6 cd b9 9b				call forth_push_str 
c4b9			 
c4b9			 
c4b9			 
c4b9			 
c4b9				       NEXTW 
c4b9 c3 f8 9e			jp macro_next 
c4bc				endm 
# End of macro NEXTW
c4bc			 
c4bc			 
c4bc			.FIND: 
c4bc				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c4bc 4b				db WORD_SYS_CORE+55             
c4bd 7a c5			dw .LEN            
c4bf 05				db 4 + 1 
c4c0 .. 00			db "FIND",0              
c4c5				endm 
# End of macro CWHEAD
c4c5			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c4c5			 
c4c5					if DEBUG_FORTH_WORDS_KEY 
c4c5						DMARK "FND" 
c4c5 f5				push af  
c4c6 3a da c4			ld a, (.dmark)  
c4c9 32 6b ee			ld (debug_mark),a  
c4cc 3a db c4			ld a, (.dmark+1)  
c4cf 32 6c ee			ld (debug_mark+1),a  
c4d2 3a dc c4			ld a, (.dmark+2)  
c4d5 32 6d ee			ld (debug_mark+2),a  
c4d8 18 03			jr .pastdmark  
c4da ..			.dmark: db "FND"  
c4dd f1			.pastdmark: pop af  
c4de			endm  
# End of macro DMARK
c4de						CALLMONITOR 
c4de cd 6f ee			call debug_vector  
c4e1				endm  
# End of macro CALLMONITOR
c4e1					endif 
c4e1			 
c4e1			; TODO check string type 
c4e1					FORTH_DSP_VALUE 
c4e1 cd 2b 9d			call macro_forth_dsp_value 
c4e4				endm 
# End of macro FORTH_DSP_VALUE
c4e4			 
c4e4 e5					push hl    
c4e5 7e					ld a,(hl)    ; char to find   
c4e6			; TODO change char to substr 
c4e6			 
c4e6 f5					push af 
c4e7					 
c4e7			 
c4e7			 
c4e7					if DEBUG_FORTH_WORDS 
c4e7						DMARK "FN1" 
c4e7 f5				push af  
c4e8 3a fc c4			ld a, (.dmark)  
c4eb 32 6b ee			ld (debug_mark),a  
c4ee 3a fd c4			ld a, (.dmark+1)  
c4f1 32 6c ee			ld (debug_mark+1),a  
c4f4 3a fe c4			ld a, (.dmark+2)  
c4f7 32 6d ee			ld (debug_mark+2),a  
c4fa 18 03			jr .pastdmark  
c4fc ..			.dmark: db "FN1"  
c4ff f1			.pastdmark: pop af  
c500			endm  
# End of macro DMARK
c500						CALLMONITOR 
c500 cd 6f ee			call debug_vector  
c503				endm  
# End of macro CALLMONITOR
c503					endif 
c503			 
c503					FORTH_DSP_POP 
c503 cd fa 9d			call macro_forth_dsp_pop 
c506				endm 
# End of macro FORTH_DSP_POP
c506			 
c506					; string to search 
c506			 
c506					FORTH_DSP_VALUE 
c506 cd 2b 9d			call macro_forth_dsp_value 
c509				endm 
# End of macro FORTH_DSP_VALUE
c509			 
c509 d1					pop de  ; d is char to find  
c50a			 
c50a					if DEBUG_FORTH_WORDS 
c50a						DMARK "FN2" 
c50a f5				push af  
c50b 3a 1f c5			ld a, (.dmark)  
c50e 32 6b ee			ld (debug_mark),a  
c511 3a 20 c5			ld a, (.dmark+1)  
c514 32 6c ee			ld (debug_mark+1),a  
c517 3a 21 c5			ld a, (.dmark+2)  
c51a 32 6d ee			ld (debug_mark+2),a  
c51d 18 03			jr .pastdmark  
c51f ..			.dmark: db "FN2"  
c522 f1			.pastdmark: pop af  
c523			endm  
# End of macro DMARK
c523						CALLMONITOR 
c523 cd 6f ee			call debug_vector  
c526				endm  
# End of macro CALLMONITOR
c526					endif 
c526					 
c526 01 00 00				ld bc, 0 
c529 7e			.findchar:      ld a,(hl) 
c52a fe 00				cp 0   		 
c52c 28 27				jr z, .finddone     
c52e ba					cp d 
c52f 28 20				jr z, .foundchar 
c531 03					inc bc 
c532 23					inc hl 
c533					if DEBUG_FORTH_WORDS 
c533						DMARK "FN3" 
c533 f5				push af  
c534 3a 48 c5			ld a, (.dmark)  
c537 32 6b ee			ld (debug_mark),a  
c53a 3a 49 c5			ld a, (.dmark+1)  
c53d 32 6c ee			ld (debug_mark+1),a  
c540 3a 4a c5			ld a, (.dmark+2)  
c543 32 6d ee			ld (debug_mark+2),a  
c546 18 03			jr .pastdmark  
c548 ..			.dmark: db "FN3"  
c54b f1			.pastdmark: pop af  
c54c			endm  
# End of macro DMARK
c54c						CALLMONITOR 
c54c cd 6f ee			call debug_vector  
c54f				endm  
# End of macro CALLMONITOR
c54f					endif 
c54f 18 d8				jr .findchar 
c551			 
c551			 
c551 c5			.foundchar:	push bc 
c552 e1					pop hl 
c553 18 03				jr .findexit 
c555			 
c555			 
c555							 
c555			 
c555			.finddone:     ; got to end of string with no find 
c555 21 00 00				ld hl, 0 
c558			.findexit: 
c558			 
c558					if DEBUG_FORTH_WORDS 
c558						DMARK "FNd" 
c558 f5				push af  
c559 3a 6d c5			ld a, (.dmark)  
c55c 32 6b ee			ld (debug_mark),a  
c55f 3a 6e c5			ld a, (.dmark+1)  
c562 32 6c ee			ld (debug_mark+1),a  
c565 3a 6f c5			ld a, (.dmark+2)  
c568 32 6d ee			ld (debug_mark+2),a  
c56b 18 03			jr .pastdmark  
c56d ..			.dmark: db "FNd"  
c570 f1			.pastdmark: pop af  
c571			endm  
# End of macro DMARK
c571						CALLMONITOR 
c571 cd 6f ee			call debug_vector  
c574				endm  
# End of macro CALLMONITOR
c574					endif 
c574 cd 4b 9b			call forth_push_numhl 
c577			 
c577				       NEXTW 
c577 c3 f8 9e			jp macro_next 
c57a				endm 
# End of macro NEXTW
c57a			 
c57a			.LEN: 
c57a				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c57a 4c				db WORD_SYS_CORE+56             
c57b e4 c5			dw .ASC            
c57d 06				db 5 + 1 
c57e .. 00			db "COUNT",0              
c584				endm 
# End of macro CWHEAD
c584			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c584			 
c584					if DEBUG_FORTH_WORDS_KEY 
c584						DMARK "CNT" 
c584 f5				push af  
c585 3a 99 c5			ld a, (.dmark)  
c588 32 6b ee			ld (debug_mark),a  
c58b 3a 9a c5			ld a, (.dmark+1)  
c58e 32 6c ee			ld (debug_mark+1),a  
c591 3a 9b c5			ld a, (.dmark+2)  
c594 32 6d ee			ld (debug_mark+2),a  
c597 18 03			jr .pastdmark  
c599 ..			.dmark: db "CNT"  
c59c f1			.pastdmark: pop af  
c59d			endm  
# End of macro DMARK
c59d						CALLMONITOR 
c59d cd 6f ee			call debug_vector  
c5a0				endm  
# End of macro CALLMONITOR
c5a0					endif 
c5a0			; TODO check string type 
c5a0					FORTH_DSP_VALUE 
c5a0 cd 2b 9d			call macro_forth_dsp_value 
c5a3				endm 
# End of macro FORTH_DSP_VALUE
c5a3			 
c5a3			 
c5a3					if DEBUG_FORTH_WORDS 
c5a3						DMARK "CN?" 
c5a3 f5				push af  
c5a4 3a b8 c5			ld a, (.dmark)  
c5a7 32 6b ee			ld (debug_mark),a  
c5aa 3a b9 c5			ld a, (.dmark+1)  
c5ad 32 6c ee			ld (debug_mark+1),a  
c5b0 3a ba c5			ld a, (.dmark+2)  
c5b3 32 6d ee			ld (debug_mark+2),a  
c5b6 18 03			jr .pastdmark  
c5b8 ..			.dmark: db "CN?"  
c5bb f1			.pastdmark: pop af  
c5bc			endm  
# End of macro DMARK
c5bc						CALLMONITOR 
c5bc cd 6f ee			call debug_vector  
c5bf				endm  
# End of macro CALLMONITOR
c5bf					endif 
c5bf cd 3a 91				call strlenz 
c5c2					if DEBUG_FORTH_WORDS 
c5c2						DMARK "CNl" 
c5c2 f5				push af  
c5c3 3a d7 c5			ld a, (.dmark)  
c5c6 32 6b ee			ld (debug_mark),a  
c5c9 3a d8 c5			ld a, (.dmark+1)  
c5cc 32 6c ee			ld (debug_mark+1),a  
c5cf 3a d9 c5			ld a, (.dmark+2)  
c5d2 32 6d ee			ld (debug_mark+2),a  
c5d5 18 03			jr .pastdmark  
c5d7 ..			.dmark: db "CNl"  
c5da f1			.pastdmark: pop af  
c5db			endm  
# End of macro DMARK
c5db						CALLMONITOR 
c5db cd 6f ee			call debug_vector  
c5de				endm  
# End of macro CALLMONITOR
c5de					endif 
c5de			 
c5de cd 4b 9b				call forth_push_numhl 
c5e1			 
c5e1			 
c5e1			 
c5e1				       NEXTW 
c5e1 c3 f8 9e			jp macro_next 
c5e4				endm 
# End of macro NEXTW
c5e4			.ASC: 
c5e4				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c5e4 4d				db WORD_SYS_CORE+57             
c5e5 52 c6			dw .CHR            
c5e7 04				db 3 + 1 
c5e8 .. 00			db "ASC",0              
c5ec				endm 
# End of macro CWHEAD
c5ec			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c5ec					if DEBUG_FORTH_WORDS_KEY 
c5ec						DMARK "ASC" 
c5ec f5				push af  
c5ed 3a 01 c6			ld a, (.dmark)  
c5f0 32 6b ee			ld (debug_mark),a  
c5f3 3a 02 c6			ld a, (.dmark+1)  
c5f6 32 6c ee			ld (debug_mark+1),a  
c5f9 3a 03 c6			ld a, (.dmark+2)  
c5fc 32 6d ee			ld (debug_mark+2),a  
c5ff 18 03			jr .pastdmark  
c601 ..			.dmark: db "ASC"  
c604 f1			.pastdmark: pop af  
c605			endm  
# End of macro DMARK
c605						CALLMONITOR 
c605 cd 6f ee			call debug_vector  
c608				endm  
# End of macro CALLMONITOR
c608					endif 
c608					FORTH_DSP_VALUE 
c608 cd 2b 9d			call macro_forth_dsp_value 
c60b				endm 
# End of macro FORTH_DSP_VALUE
c60b					;v5 FORTH_DSP_VALUE 
c60b			;		inc hl      ; now at start of numeric as string 
c60b			 
c60b e5					push hl 
c60c			 
c60c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c60c cd fa 9d			call macro_forth_dsp_pop 
c60f				endm 
# End of macro FORTH_DSP_POP
c60f			 
c60f e1					pop hl 
c610			 
c610					if DEBUG_FORTH_WORDS 
c610						DMARK "AS1" 
c610 f5				push af  
c611 3a 25 c6			ld a, (.dmark)  
c614 32 6b ee			ld (debug_mark),a  
c617 3a 26 c6			ld a, (.dmark+1)  
c61a 32 6c ee			ld (debug_mark+1),a  
c61d 3a 27 c6			ld a, (.dmark+2)  
c620 32 6d ee			ld (debug_mark+2),a  
c623 18 03			jr .pastdmark  
c625 ..			.dmark: db "AS1"  
c628 f1			.pastdmark: pop af  
c629			endm  
# End of macro DMARK
c629						CALLMONITOR 
c629 cd 6f ee			call debug_vector  
c62c				endm  
# End of macro CALLMONITOR
c62c					endif 
c62c					; push the content of a onto the stack as a value 
c62c			 
c62c 7e					ld a,(hl)   ; get char 
c62d 26 00				ld h,0 
c62f 6f					ld l,a 
c630					if DEBUG_FORTH_WORDS 
c630						DMARK "AS2" 
c630 f5				push af  
c631 3a 45 c6			ld a, (.dmark)  
c634 32 6b ee			ld (debug_mark),a  
c637 3a 46 c6			ld a, (.dmark+1)  
c63a 32 6c ee			ld (debug_mark+1),a  
c63d 3a 47 c6			ld a, (.dmark+2)  
c640 32 6d ee			ld (debug_mark+2),a  
c643 18 03			jr .pastdmark  
c645 ..			.dmark: db "AS2"  
c648 f1			.pastdmark: pop af  
c649			endm  
# End of macro DMARK
c649						CALLMONITOR 
c649 cd 6f ee			call debug_vector  
c64c				endm  
# End of macro CALLMONITOR
c64c					endif 
c64c cd 4b 9b				call forth_push_numhl 
c64f			 
c64f				       NEXTW 
c64f c3 f8 9e			jp macro_next 
c652				endm 
# End of macro NEXTW
c652			 
c652			.CHR: 
c652				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c652 4d				db WORD_SYS_CORE+57             
c653 8e c6			dw .ENDSTR            
c655 04				db 3 + 1 
c656 .. 00			db "CHR",0              
c65a				endm 
# End of macro CWHEAD
c65a			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c65a					if DEBUG_FORTH_WORDS_KEY 
c65a						DMARK "CHR" 
c65a f5				push af  
c65b 3a 6f c6			ld a, (.dmark)  
c65e 32 6b ee			ld (debug_mark),a  
c661 3a 70 c6			ld a, (.dmark+1)  
c664 32 6c ee			ld (debug_mark+1),a  
c667 3a 71 c6			ld a, (.dmark+2)  
c66a 32 6d ee			ld (debug_mark+2),a  
c66d 18 03			jr .pastdmark  
c66f ..			.dmark: db "CHR"  
c672 f1			.pastdmark: pop af  
c673			endm  
# End of macro DMARK
c673						CALLMONITOR 
c673 cd 6f ee			call debug_vector  
c676				endm  
# End of macro CALLMONITOR
c676					endif 
c676					FORTH_DSP_VALUEHL 
c676 cd 42 9d			call macro_dsp_valuehl 
c679				endm 
# End of macro FORTH_DSP_VALUEHL
c679			 
c679					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c679 cd fa 9d			call macro_forth_dsp_pop 
c67c				endm 
# End of macro FORTH_DSP_POP
c67c			 
c67c					; save asci byte as a zero term string and push string 
c67c			 
c67c 7d					ld a,l 
c67d 32 c1 e2				ld (scratch), a 
c680			 
c680 3e 00				ld a, 0 
c682 32 c2 e2				ld (scratch+1), a 
c685			 
c685 21 c1 e2				ld hl, scratch 
c688 cd b9 9b				call forth_push_str 
c68b			 
c68b			 
c68b				       NEXTW 
c68b c3 f8 9e			jp macro_next 
c68e				endm 
# End of macro NEXTW
c68e			 
c68e			 
c68e			 
c68e			 
c68e			.ENDSTR: 
c68e			; eof 
c68e			 
# End of file forth_words_str.asm
c68e			include "forth_words_key.asm" 
c68e			 
c68e			; | ## Keyboard Words 
c68e			 
c68e			.KEY: 
c68e				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c68e 3e				db WORD_SYS_CORE+42             
c68f be c6			dw .WAITK            
c691 04				db 3 + 1 
c692 .. 00			db "KEY",0              
c696				endm 
# End of macro CWHEAD
c696			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c696			 
c696					if DEBUG_FORTH_WORDS_KEY 
c696						DMARK "KEY" 
c696 f5				push af  
c697 3a ab c6			ld a, (.dmark)  
c69a 32 6b ee			ld (debug_mark),a  
c69d 3a ac c6			ld a, (.dmark+1)  
c6a0 32 6c ee			ld (debug_mark+1),a  
c6a3 3a ad c6			ld a, (.dmark+2)  
c6a6 32 6d ee			ld (debug_mark+2),a  
c6a9 18 03			jr .pastdmark  
c6ab ..			.dmark: db "KEY"  
c6ae f1			.pastdmark: pop af  
c6af			endm  
# End of macro DMARK
c6af						CALLMONITOR 
c6af cd 6f ee			call debug_vector  
c6b2				endm  
# End of macro CALLMONITOR
c6b2					endif 
c6b2			; TODO currently waits 
c6b2 cd 2e e4				call cin 
c6b5					;call cin_wait 
c6b5 6f					ld l, a 
c6b6 26 00				ld h, 0 
c6b8 cd 4b 9b				call forth_push_numhl 
c6bb					NEXTW 
c6bb c3 f8 9e			jp macro_next 
c6be				endm 
# End of macro NEXTW
c6be			.WAITK: 
c6be				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c6be 3f				db WORD_SYS_CORE+43             
c6bf f0 c6			dw .ACCEPT            
c6c1 06				db 5 + 1 
c6c2 .. 00			db "WAITK",0              
c6c8				endm 
# End of macro CWHEAD
c6c8			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c6c8					if DEBUG_FORTH_WORDS_KEY 
c6c8						DMARK "WAI" 
c6c8 f5				push af  
c6c9 3a dd c6			ld a, (.dmark)  
c6cc 32 6b ee			ld (debug_mark),a  
c6cf 3a de c6			ld a, (.dmark+1)  
c6d2 32 6c ee			ld (debug_mark+1),a  
c6d5 3a df c6			ld a, (.dmark+2)  
c6d8 32 6d ee			ld (debug_mark+2),a  
c6db 18 03			jr .pastdmark  
c6dd ..			.dmark: db "WAI"  
c6e0 f1			.pastdmark: pop af  
c6e1			endm  
# End of macro DMARK
c6e1						CALLMONITOR 
c6e1 cd 6f ee			call debug_vector  
c6e4				endm  
# End of macro CALLMONITOR
c6e4					endif 
c6e4 cd 28 e4				call cin_wait 
c6e7 6f					ld l, a 
c6e8 26 00				ld h, 0 
c6ea cd 4b 9b				call forth_push_numhl 
c6ed					NEXTW 
c6ed c3 f8 9e			jp macro_next 
c6f0				endm 
# End of macro NEXTW
c6f0			.ACCEPT: 
c6f0				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c6f0 40				db WORD_SYS_CORE+44             
c6f1 4e c7			dw .EDIT            
c6f3 07				db 6 + 1 
c6f4 .. 00			db "ACCEPT",0              
c6fb				endm 
# End of macro CWHEAD
c6fb			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6fb					; TODO crashes on push 
c6fb					if DEBUG_FORTH_WORDS_KEY 
c6fb						DMARK "ACC" 
c6fb f5				push af  
c6fc 3a 10 c7			ld a, (.dmark)  
c6ff 32 6b ee			ld (debug_mark),a  
c702 3a 11 c7			ld a, (.dmark+1)  
c705 32 6c ee			ld (debug_mark+1),a  
c708 3a 12 c7			ld a, (.dmark+2)  
c70b 32 6d ee			ld (debug_mark+2),a  
c70e 18 03			jr .pastdmark  
c710 ..			.dmark: db "ACC"  
c713 f1			.pastdmark: pop af  
c714			endm  
# End of macro DMARK
c714						CALLMONITOR 
c714 cd 6f ee			call debug_vector  
c717				endm  
# End of macro CALLMONITOR
c717					endif 
c717 21 bf e4				ld hl, os_input 
c71a 3e 00				ld a, 0 
c71c 77					ld (hl),a 
c71d 3a 5e ea				ld a,(f_cursor_ptr) 
c720 16 64				ld d, 100 
c722 0e 00				ld c, 0 
c724 1e 28				ld e, 40 
c726 cd 09 8d				call input_str 
c729					; TODO perhaps do a type check and wrap in quotes if not a number 
c729 21 bf e4				ld hl, os_input 
c72c					if DEBUG_FORTH_WORDS 
c72c						DMARK "AC1" 
c72c f5				push af  
c72d 3a 41 c7			ld a, (.dmark)  
c730 32 6b ee			ld (debug_mark),a  
c733 3a 42 c7			ld a, (.dmark+1)  
c736 32 6c ee			ld (debug_mark+1),a  
c739 3a 43 c7			ld a, (.dmark+2)  
c73c 32 6d ee			ld (debug_mark+2),a  
c73f 18 03			jr .pastdmark  
c741 ..			.dmark: db "AC1"  
c744 f1			.pastdmark: pop af  
c745			endm  
# End of macro DMARK
c745						CALLMONITOR 
c745 cd 6f ee			call debug_vector  
c748				endm  
# End of macro CALLMONITOR
c748					endif 
c748 cd b9 9b				call forth_push_str 
c74b					NEXTW 
c74b c3 f8 9e			jp macro_next 
c74e				endm 
# End of macro NEXTW
c74e			 
c74e			.EDIT: 
c74e				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c74e 40				db WORD_SYS_CORE+44             
c74f f0 c7			dw .DEDIT            
c751 05				db 4 + 1 
c752 .. 00			db "EDIT",0              
c757				endm 
# End of macro CWHEAD
c757			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c757			 
c757					; TODO does not copy from stack 
c757					if DEBUG_FORTH_WORDS_KEY 
c757						DMARK "EDT" 
c757 f5				push af  
c758 3a 6c c7			ld a, (.dmark)  
c75b 32 6b ee			ld (debug_mark),a  
c75e 3a 6d c7			ld a, (.dmark+1)  
c761 32 6c ee			ld (debug_mark+1),a  
c764 3a 6e c7			ld a, (.dmark+2)  
c767 32 6d ee			ld (debug_mark+2),a  
c76a 18 03			jr .pastdmark  
c76c ..			.dmark: db "EDT"  
c76f f1			.pastdmark: pop af  
c770			endm  
# End of macro DMARK
c770						CALLMONITOR 
c770 cd 6f ee			call debug_vector  
c773				endm  
# End of macro CALLMONITOR
c773					endif 
c773			 
c773					;FORTH_DSP 
c773					FORTH_DSP_VALUEHL 
c773 cd 42 9d			call macro_dsp_valuehl 
c776				endm 
# End of macro FORTH_DSP_VALUEHL
c776			;		inc hl    ; TODO do type check 
c776			 
c776			;		call get_word_hl 
c776 e5					push hl 
c777					if DEBUG_FORTH_WORDS 
c777						DMARK "EDp" 
c777 f5				push af  
c778 3a 8c c7			ld a, (.dmark)  
c77b 32 6b ee			ld (debug_mark),a  
c77e 3a 8d c7			ld a, (.dmark+1)  
c781 32 6c ee			ld (debug_mark+1),a  
c784 3a 8e c7			ld a, (.dmark+2)  
c787 32 6d ee			ld (debug_mark+2),a  
c78a 18 03			jr .pastdmark  
c78c ..			.dmark: db "EDp"  
c78f f1			.pastdmark: pop af  
c790			endm  
# End of macro DMARK
c790						CALLMONITOR 
c790 cd 6f ee			call debug_vector  
c793				endm  
# End of macro CALLMONITOR
c793					endif 
c793				;	ld a, 0 
c793 cd 3a 91				call strlenz 
c796 23					inc hl 
c797			 
c797 06 00				ld b, 0 
c799 4d					ld c, l 
c79a			 
c79a e1					pop hl 
c79b 11 bf e4				ld de, os_input 
c79e					if DEBUG_FORTH_WORDS_KEY 
c79e						DMARK "EDc" 
c79e f5				push af  
c79f 3a b3 c7			ld a, (.dmark)  
c7a2 32 6b ee			ld (debug_mark),a  
c7a5 3a b4 c7			ld a, (.dmark+1)  
c7a8 32 6c ee			ld (debug_mark+1),a  
c7ab 3a b5 c7			ld a, (.dmark+2)  
c7ae 32 6d ee			ld (debug_mark+2),a  
c7b1 18 03			jr .pastdmark  
c7b3 ..			.dmark: db "EDc"  
c7b6 f1			.pastdmark: pop af  
c7b7			endm  
# End of macro DMARK
c7b7						CALLMONITOR 
c7b7 cd 6f ee			call debug_vector  
c7ba				endm  
# End of macro CALLMONITOR
c7ba					endif 
c7ba ed b0				ldir 
c7bc			 
c7bc			 
c7bc 21 bf e4				ld hl, os_input 
c7bf					;ld a, 0 
c7bf					;ld (hl),a 
c7bf 3a 5e ea				ld a,(f_cursor_ptr) 
c7c2 16 64				ld d, 100 
c7c4 0e 00				ld c, 0 
c7c6 1e 28				ld e, 40 
c7c8 cd 09 8d				call input_str 
c7cb					; TODO perhaps do a type check and wrap in quotes if not a number 
c7cb 21 bf e4				ld hl, os_input 
c7ce					if DEBUG_FORTH_WORDS 
c7ce						DMARK "ED1" 
c7ce f5				push af  
c7cf 3a e3 c7			ld a, (.dmark)  
c7d2 32 6b ee			ld (debug_mark),a  
c7d5 3a e4 c7			ld a, (.dmark+1)  
c7d8 32 6c ee			ld (debug_mark+1),a  
c7db 3a e5 c7			ld a, (.dmark+2)  
c7de 32 6d ee			ld (debug_mark+2),a  
c7e1 18 03			jr .pastdmark  
c7e3 ..			.dmark: db "ED1"  
c7e6 f1			.pastdmark: pop af  
c7e7			endm  
# End of macro DMARK
c7e7						CALLMONITOR 
c7e7 cd 6f ee			call debug_vector  
c7ea				endm  
# End of macro CALLMONITOR
c7ea					endif 
c7ea cd b9 9b				call forth_push_str 
c7ed					NEXTW 
c7ed c3 f8 9e			jp macro_next 
c7f0				endm 
# End of macro NEXTW
c7f0			 
c7f0			.DEDIT: 
c7f0				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c7f0 40				db WORD_SYS_CORE+44             
c7f1 52 c8			dw .ENDKEY            
c7f3 06				db 5 + 1 
c7f4 .. 00			db "DEDIT",0              
c7fa				endm 
# End of macro CWHEAD
c7fa			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7fa			 
c7fa					; TODO does not copy from stack 
c7fa					if DEBUG_FORTH_WORDS_KEY 
c7fa						DMARK "DED" 
c7fa f5				push af  
c7fb 3a 0f c8			ld a, (.dmark)  
c7fe 32 6b ee			ld (debug_mark),a  
c801 3a 10 c8			ld a, (.dmark+1)  
c804 32 6c ee			ld (debug_mark+1),a  
c807 3a 11 c8			ld a, (.dmark+2)  
c80a 32 6d ee			ld (debug_mark+2),a  
c80d 18 03			jr .pastdmark  
c80f ..			.dmark: db "DED"  
c812 f1			.pastdmark: pop af  
c813			endm  
# End of macro DMARK
c813						CALLMONITOR 
c813 cd 6f ee			call debug_vector  
c816				endm  
# End of macro CALLMONITOR
c816					endif 
c816			 
c816					;FORTH_DSP 
c816					FORTH_DSP_VALUEHL 
c816 cd 42 9d			call macro_dsp_valuehl 
c819				endm 
# End of macro FORTH_DSP_VALUEHL
c819			;		inc hl    ; TODO do type check 
c819			 
c819			;		call get_word_hl 
c819 e5					push hl 
c81a e5					push hl 
c81b					FORTH_DSP_POP 
c81b cd fa 9d			call macro_forth_dsp_pop 
c81e				endm 
# End of macro FORTH_DSP_POP
c81e e1					pop hl 
c81f					if DEBUG_FORTH_WORDS 
c81f						DMARK "EDp" 
c81f f5				push af  
c820 3a 34 c8			ld a, (.dmark)  
c823 32 6b ee			ld (debug_mark),a  
c826 3a 35 c8			ld a, (.dmark+1)  
c829 32 6c ee			ld (debug_mark+1),a  
c82c 3a 36 c8			ld a, (.dmark+2)  
c82f 32 6d ee			ld (debug_mark+2),a  
c832 18 03			jr .pastdmark  
c834 ..			.dmark: db "EDp"  
c837 f1			.pastdmark: pop af  
c838			endm  
# End of macro DMARK
c838						CALLMONITOR 
c838 cd 6f ee			call debug_vector  
c83b				endm  
# End of macro CALLMONITOR
c83b					endif 
c83b				;	ld a, 0 
c83b cd 3a 91				call strlenz 
c83e 23					inc hl 
c83f			 
c83f 06 00				ld b, 0 
c841 4d					ld c, l 
c842			 
c842 e1					pop hl 
c843			 
c843					;ld a, 0 
c843					;ld (hl),a 
c843 3a 5e ea				ld a,(f_cursor_ptr) 
c846 16 64				ld d, 100 
c848 0e 00				ld c, 0 
c84a 1e 28				ld e, 40 
c84c cd 09 8d				call input_str 
c84f					; TODO perhaps do a type check and wrap in quotes if not a number 
c84f					NEXTW 
c84f c3 f8 9e			jp macro_next 
c852				endm 
# End of macro NEXTW
c852			 
c852			 
c852			.ENDKEY: 
c852			; eof 
c852			 
# End of file forth_words_key.asm
c852			include "forth_words_const.asm" 
c852			 
c852			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c852			 
c852			 
c852			.SPITIME: 
c852				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c852 77				db WORD_SYS_CORE+99             
c853 67 c8			dw .VA            
c855 08				db 7 + 1 
c856 .. 00			db "SPITIME",0              
c85e				endm 
# End of macro CWHEAD
c85e			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c85e			; 
c85e			; | If using BANK devices then leave as is. 
c85e			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c85e			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c85e			 
c85e 21 64 ea				ld hl, spi_clktime  
c861 cd 4b 9b				call forth_push_numhl 
c864			 
c864					NEXTW 
c864 c3 f8 9e			jp macro_next 
c867				endm 
# End of macro NEXTW
c867			 
c867			 
c867			.VA: 
c867				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c867 77				db WORD_SYS_CORE+99             
c868 77 c8			dw .SYMBOL            
c86a 03				db 2 + 1 
c86b .. 00			db "VA",0              
c86e				endm 
# End of macro CWHEAD
c86e			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c86e 21 28 ea				ld hl, cli_var_array 
c871 cd 4b 9b				call forth_push_numhl 
c874			 
c874					NEXTW 
c874 c3 f8 9e			jp macro_next 
c877				endm 
# End of macro NEXTW
c877			 
c877			.SYMBOL: 
c877				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c877 77				db WORD_SYS_CORE+99             
c878 81 c9			dw .ENDCONST            
c87a 07				db 6 + 1 
c87b .. 00			db "SYMBOL",0              
c882				endm 
# End of macro CWHEAD
c882			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c882			; | 
c882			; | The value is the number reference and the final address is pushed to stack 
c882			 
c882			; | dw sym_table 
c882			; | dw nmi_vector 
c882			; | dw cli_autodisplay 
c882			; | dw cli_data_sp 
c882			; | dw cli_data_stack 
c882			; | dw cli_loop_sp 
c882			; | dw cli_loop_stack 
c882			; | dw cli_var_array 
c882			; | dw cursor_col 
c882			; | dw cursor_ptr 
c882			; | ; 10 
c882			; | dw cursor_row 
c882			; | dw debug_mark 
c882			; | dw display_fb0 
c882			; | dw display_fb1 
c882			; | dw display_fb2 
c882			; | dw display_fb3 
c882			; | dw display_fb_active 
c882			; | dw execscratch 
c882			; | dw f_cursor_ptr 
c882			; | dw hardware_word 
c882			; | ;20 
c882			; | dw input_at_cursor 
c882			; | dw input_at_pos 
c882			; | dw input_cur_flash 
c882			; | dw input_cur_onoff 
c882			; | dw input_cursor 
c882			; | dw input_display_size 
c882			; | dw input_len 
c882			; | dw input_ptr 
c882			; | dw input_size 
c882			; | dw input_start 
c882			; | ; 30 
c882			; | dw input_str 
c882			; | dw input_under_cursor 
c882			; | dw os_cli_cmd 
c882			; | dw os_cur_ptr 
c882			; | dw os_current_i 
c882			; | dw os_input 
c882			; | dw os_last_cmd 
c882			; | dw os_last_new_uword 
c882			; | dw debug_vector 
c882			; | dw os_view_hl 
c882			; | ;40 
c882			; | dw os_word_scratch 
c882			; | dw portbctl 
c882			; | dw portbdata 
c882			; | dw spi_cartdev 
c882			; | dw spi_cartdev2 
c882			; | dw spi_clktime 
c882			; | dw spi_device 
c882			; | dw spi_device_id 
c882			; | dw spi_portbyte 
c882			; | dw stackstore 
c882			; | ; 50 
c882			; | if STORAGE_SE 
c882			; | dw storage_actl 
c882			; | dw storage_adata 
c882			; | else 
c882			; | dw 0 
c882			; | dw 0 
c882			; | endif 
c882			; | dw storage_append 
c882			; | if STORAGE_SE 
c882			; | dw storage_bctl 
c882			; | else 
c882			; | dw 0 
c882			; | endif 
c882			; | dw store_bank_active 
c882			; | dw store_filecache 
c882			; | dw store_longread 
c882			; | dw store_openaddr 
c882			; | dw store_openext 
c882			; | dw store_openmaxext 
c882			; | ; 60 
c882			; | dw store_page 
c882			; | dw store_readbuf 
c882			; | dw store_readcont 
c882			; | dw store_readptr 
c882			; | dw store_tmpext 
c882			; | dw store_tmpid 
c882			; | dw store_tmppageid 
c882			; | dw malloc 
c882			; | dw free 
c882			; | dw cin 
c882			; | ; 70 
c882			; | dw cin_wait 
c882			; | dw forth_push_numhl 
c882			; | dw forth_push_str 
c882			 
c882					if DEBUG_FORTH_WORDS_KEY 
c882						DMARK "SYM" 
c882 f5				push af  
c883 3a 97 c8			ld a, (.dmark)  
c886 32 6b ee			ld (debug_mark),a  
c889 3a 98 c8			ld a, (.dmark+1)  
c88c 32 6c ee			ld (debug_mark+1),a  
c88f 3a 99 c8			ld a, (.dmark+2)  
c892 32 6d ee			ld (debug_mark+2),a  
c895 18 03			jr .pastdmark  
c897 ..			.dmark: db "SYM"  
c89a f1			.pastdmark: pop af  
c89b			endm  
# End of macro DMARK
c89b						CALLMONITOR 
c89b cd 6f ee			call debug_vector  
c89e				endm  
# End of macro CALLMONITOR
c89e					endif 
c89e			 
c89e					FORTH_DSP_VALUEHL 
c89e cd 42 9d			call macro_dsp_valuehl 
c8a1				endm 
# End of macro FORTH_DSP_VALUEHL
c8a1			 
c8a1 7d					ld a, l     
c8a2			 
c8a2			 
c8a2					if DEBUG_FORTH_WORDS 
c8a2						DMARK "SY1" 
c8a2 f5				push af  
c8a3 3a b7 c8			ld a, (.dmark)  
c8a6 32 6b ee			ld (debug_mark),a  
c8a9 3a b8 c8			ld a, (.dmark+1)  
c8ac 32 6c ee			ld (debug_mark+1),a  
c8af 3a b9 c8			ld a, (.dmark+2)  
c8b2 32 6d ee			ld (debug_mark+2),a  
c8b5 18 03			jr .pastdmark  
c8b7 ..			.dmark: db "SY1"  
c8ba f1			.pastdmark: pop af  
c8bb			endm  
# End of macro DMARK
c8bb						CALLMONITOR 
c8bb cd 6f ee			call debug_vector  
c8be				endm  
# End of macro CALLMONITOR
c8be					endif 
c8be					 
c8be f5					push af	 
c8bf					FORTH_DSP_POP 
c8bf cd fa 9d			call macro_forth_dsp_pop 
c8c2				endm 
# End of macro FORTH_DSP_POP
c8c2 f1					pop af 
c8c3			 
c8c3 cb 27				sla a  
c8c5				 
c8c5					 
c8c5					if DEBUG_FORTH_WORDS 
c8c5						DMARK "SY" 
c8c5 f5				push af  
c8c6 3a da c8			ld a, (.dmark)  
c8c9 32 6b ee			ld (debug_mark),a  
c8cc 3a db c8			ld a, (.dmark+1)  
c8cf 32 6c ee			ld (debug_mark+1),a  
c8d2 3a dc c8			ld a, (.dmark+2)  
c8d5 32 6d ee			ld (debug_mark+2),a  
c8d8 18 02			jr .pastdmark  
c8da ..			.dmark: db "SY"  
c8dc f1			.pastdmark: pop af  
c8dd			endm  
# End of macro DMARK
c8dd						CALLMONITOR 
c8dd cd 6f ee			call debug_vector  
c8e0				endm  
# End of macro CALLMONITOR
c8e0					endif 
c8e0			 
c8e0 21 ef c8				ld hl, sym_table 
c8e3 cd dc 8c				call addatohl 
c8e6 cd 7a 9e				call loadwordinhl 
c8e9 cd 4b 9b				call forth_push_numhl 
c8ec			 
c8ec			 
c8ec				       NEXTW 
c8ec c3 f8 9e			jp macro_next 
c8ef				endm 
# End of macro NEXTW
c8ef			 
c8ef			sym_table: 
c8ef			 
c8ef			; 0 
c8ef ef c8		dw sym_table 
c8f1 72 ee		dw nmi_vector 
c8f3 3c ea		dw cli_autodisplay 
c8f5 ee e9		dw cli_data_sp 
c8f7 28 e8		dw cli_data_stack 
c8f9 f0 e9		dw cli_loop_sp 
c8fb 2a e9		dw cli_loop_stack 
c8fd 28 ea		dw cli_var_array 
c8ff c5 eb		dw cursor_col 
c901 c3 eb		dw cursor_ptr 
c903			; 10 
c903 c4 eb		dw cursor_row 
c905 6b ee		dw debug_mark 
c907 b1 ed		dw display_fb0 
c909 10 ed		dw display_fb1 
c90b ce eb		dw display_fb2 
c90d 6f ec		dw display_fb3 
c90f cc eb		dw display_fb_active 
c911 c0 e3		dw execscratch 
c913 5e ea		dw f_cursor_ptr 
c915 75 ee		dw hardware_word 
c917			;20 
c917 62 ee		dw input_at_cursor 
c919 64 ee		dw input_at_pos 
c91b 60 ee		dw input_cur_flash 
c91d 5f ee		dw input_cur_onoff 
c91f 55 ee		dw input_cursor 
c921 65 ee		dw input_display_size 
c923 5a ee		dw input_len 
c925 69 ee		dw input_ptr 
c927 66 ee		dw input_size 
c929 67 ee		dw input_start 
c92b			; 30 
c92b 09 8d		dw input_str 
c92d 63 ee		dw input_under_cursor 
c92f e8 e5		dw os_cli_cmd 
c931 e4 e5		dw os_cur_ptr 
c933 e6 e5		dw os_current_i 
c935 bf e4		dw os_input 
c937 e7 e6		dw os_last_cmd 
c939 be e5		dw os_last_new_uword 
c93b 6f ee		dw debug_vector 
c93d af e2		dw os_view_hl 
c93f			;40 
c93f c6 e5		dw os_word_scratch 
c941 c3 00		dw portbctl 
c943 c1 00		dw portbdata 
c945 63 ea		dw spi_cartdev 
c947 62 ea		dw spi_cartdev2 
c949 64 ea		dw spi_clktime 
c94b 60 ea		dw spi_device 
c94d 5f ea		dw spi_device_id 
c94f 61 ea		dw spi_portbyte 
c951 a7 eb		dw stackstore 
c953			; 50 
c953			if STORAGE_SE 
c953			dw storage_actl 
c953			dw storage_adata 
c953			else 
c953 00 00		dw 0 
c955 00 00		dw 0 
c957			endif 
c957 69 88		dw storage_append 
c959			if STORAGE_SE 
c959			dw storage_bctl 
c959			else 
c959 00 00		dw 0 
c95b			endif 
c95b 93 eb		dw store_bank_active 
c95d 67 ea		dw store_filecache 
c95f 75 ea		dw store_longread 
c961 6b ea		dw store_openaddr 
c963 6a ea		dw store_openext 
c965 69 ea		dw store_openmaxext 
c967			; 60 
c967 7a ea		dw store_page 
c969 76 ea		dw store_readbuf 
c96b 6d ea		dw store_readcont 
c96d 78 ea		dw store_readptr 
c96f 6d ea		dw store_tmpext 
c971 6e ea		dw store_tmpid 
c973 65 ea		dw store_tmppageid 
c975 a3 91		dw malloc 
c977 6d 92		dw free 
c979 2e e4		dw cin 
c97b			; 70 
c97b 28 e4		dw cin_wait 
c97d 4b 9b		dw forth_push_numhl 
c97f b9 9b		dw forth_push_str 
c981			 
c981			 
c981			.ENDCONST: 
c981			 
c981			; eof 
c981			 
c981			 
# End of file forth_words_const.asm
c981			 
c981			if STORAGE_SE 
c981			   	include "forth_words_storage.asm" 
c981			endif 
c981				include "forth_words_device.asm" 
c981			; Device related words 
c981			 
c981			; | ## Device Words 
c981			 
c981			;if SOUND_ENABLE 
c981			;.NOTE: 
c981			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c981			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c981			;		if DEBUG_FORTH_WORDS_KEY 
c981			;			DMARK "NTE" 
c981			;			CALLMONITOR 
c981			;		endif 
c981			; 
c981			;	 
c981			; 
c981			;		NEXTW 
c981			;.AFTERSOUND: 
c981			;endif 
c981			 
c981			 
c981			USE_GPIO: equ 0 
c981			 
c981			if USE_GPIO 
c981			.GP1: 
c981				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c981			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c981					NEXTW 
c981			.GP2: 
c981				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c981			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c981			 
c981					NEXTW 
c981			 
c981			.GP3: 
c981				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c981			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c981			 
c981					NEXTW 
c981			 
c981			.GP4: 
c981				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c981			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c981			 
c981					NEXTW 
c981			.SIN: 
c981			 
c981			 
c981			endif 
c981			 
c981			 
c981				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c981 33				db WORD_SYS_CORE+31             
c982 b6 c9			dw .SOUT            
c984 03				db 2 + 1 
c985 .. 00			db "IN",0              
c988				endm 
# End of macro CWHEAD
c988			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c988					if DEBUG_FORTH_WORDS_KEY 
c988						DMARK "IN." 
c988 f5				push af  
c989 3a 9d c9			ld a, (.dmark)  
c98c 32 6b ee			ld (debug_mark),a  
c98f 3a 9e c9			ld a, (.dmark+1)  
c992 32 6c ee			ld (debug_mark+1),a  
c995 3a 9f c9			ld a, (.dmark+2)  
c998 32 6d ee			ld (debug_mark+2),a  
c99b 18 03			jr .pastdmark  
c99d ..			.dmark: db "IN."  
c9a0 f1			.pastdmark: pop af  
c9a1			endm  
# End of macro DMARK
c9a1						CALLMONITOR 
c9a1 cd 6f ee			call debug_vector  
c9a4				endm  
# End of macro CALLMONITOR
c9a4					endif 
c9a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9a4 cd 42 9d			call macro_dsp_valuehl 
c9a7				endm 
# End of macro FORTH_DSP_VALUEHL
c9a7			 
c9a7 e5					push hl 
c9a8			 
c9a8					; destroy value TOS 
c9a8			 
c9a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9a8 cd fa 9d			call macro_forth_dsp_pop 
c9ab				endm 
# End of macro FORTH_DSP_POP
c9ab			 
c9ab					; one value on hl get other one back 
c9ab			 
c9ab c1					pop bc 
c9ac			 
c9ac					; do the sub 
c9ac			;		ex de, hl 
c9ac			 
c9ac ed 68				in l,(c) 
c9ae			 
c9ae					; save it 
c9ae			 
c9ae 26 00				ld h,0 
c9b0			 
c9b0					; TODO push value back onto stack for another op etc 
c9b0			 
c9b0 cd 4b 9b				call forth_push_numhl 
c9b3					NEXTW 
c9b3 c3 f8 9e			jp macro_next 
c9b6				endm 
# End of macro NEXTW
c9b6			.SOUT: 
c9b6				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c9b6 34				db WORD_SYS_CORE+32             
c9b7 09 ca			dw .SPIO            
c9b9 04				db 3 + 1 
c9ba .. 00			db "OUT",0              
c9be				endm 
# End of macro CWHEAD
c9be			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c9be					if DEBUG_FORTH_WORDS_KEY 
c9be						DMARK "OUT" 
c9be f5				push af  
c9bf 3a d3 c9			ld a, (.dmark)  
c9c2 32 6b ee			ld (debug_mark),a  
c9c5 3a d4 c9			ld a, (.dmark+1)  
c9c8 32 6c ee			ld (debug_mark+1),a  
c9cb 3a d5 c9			ld a, (.dmark+2)  
c9ce 32 6d ee			ld (debug_mark+2),a  
c9d1 18 03			jr .pastdmark  
c9d3 ..			.dmark: db "OUT"  
c9d6 f1			.pastdmark: pop af  
c9d7			endm  
# End of macro DMARK
c9d7						CALLMONITOR 
c9d7 cd 6f ee			call debug_vector  
c9da				endm  
# End of macro CALLMONITOR
c9da					endif 
c9da			 
c9da					; get port 
c9da			 
c9da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9da cd 42 9d			call macro_dsp_valuehl 
c9dd				endm 
# End of macro FORTH_DSP_VALUEHL
c9dd			 
c9dd e5					push hl 
c9de			 
c9de					; destroy value TOS 
c9de			 
c9de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9de cd fa 9d			call macro_forth_dsp_pop 
c9e1				endm 
# End of macro FORTH_DSP_POP
c9e1			 
c9e1					; get byte to send 
c9e1			 
c9e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9e1 cd 42 9d			call macro_dsp_valuehl 
c9e4				endm 
# End of macro FORTH_DSP_VALUEHL
c9e4			 
c9e4			;		push hl 
c9e4			 
c9e4					; destroy value TOS 
c9e4			 
c9e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9e4 cd fa 9d			call macro_forth_dsp_pop 
c9e7				endm 
# End of macro FORTH_DSP_POP
c9e7			 
c9e7					; one value on hl get other one back 
c9e7			 
c9e7			;		pop hl 
c9e7			 
c9e7 c1					pop bc 
c9e8			 
c9e8					if DEBUG_FORTH_WORDS 
c9e8						DMARK "OUT" 
c9e8 f5				push af  
c9e9 3a fd c9			ld a, (.dmark)  
c9ec 32 6b ee			ld (debug_mark),a  
c9ef 3a fe c9			ld a, (.dmark+1)  
c9f2 32 6c ee			ld (debug_mark+1),a  
c9f5 3a ff c9			ld a, (.dmark+2)  
c9f8 32 6d ee			ld (debug_mark+2),a  
c9fb 18 03			jr .pastdmark  
c9fd ..			.dmark: db "OUT"  
ca00 f1			.pastdmark: pop af  
ca01			endm  
# End of macro DMARK
ca01						CALLMONITOR 
ca01 cd 6f ee			call debug_vector  
ca04				endm  
# End of macro CALLMONITOR
ca04					endif 
ca04			 
ca04 ed 69				out (c), l 
ca06			 
ca06					NEXTW 
ca06 c3 f8 9e			jp macro_next 
ca09				endm 
# End of macro NEXTW
ca09			 
ca09			 
ca09			.SPIO: 
ca09			 
ca09			if STORAGE_SE 
ca09				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
ca09			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
ca09			 
ca09					call spi_ce_low 
ca09			    NEXTW 
ca09			 
ca09			.SPICEH: 
ca09				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
ca09			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
ca09			 
ca09					call spi_ce_high 
ca09			    NEXTW 
ca09			 
ca09			 
ca09			.SPIOb: 
ca09			 
ca09				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
ca09			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
ca09			 
ca09					if DEBUG_FORTH_WORDS_KEY 
ca09						DMARK "SPo" 
ca09						CALLMONITOR 
ca09					endif 
ca09					; get port 
ca09			 
ca09			 
ca09					; get byte to send 
ca09			 
ca09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca09			 
ca09			;		push hl    ; u1  
ca09			 
ca09					; destroy value TOS 
ca09			 
ca09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca09			 
ca09					; one value on hl get other one back 
ca09			 
ca09			;		pop hl   ; u2 - addr 
ca09			 
ca09					; TODO Send SPI byte 
ca09			 
ca09			;		push hl 
ca09			;		call spi_ce_low 
ca09			;		pop hl 
ca09					ld a, l 
ca09					call spi_send_byte 
ca09			;		call spi_ce_high 
ca09			 
ca09					NEXTW 
ca09			 
ca09			.SPII: 
ca09				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
ca09			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
ca09					if DEBUG_FORTH_WORDS_KEY 
ca09						DMARK "SPi" 
ca09						CALLMONITOR 
ca09					endif 
ca09			 
ca09					; TODO Get SPI byte 
ca09			 
ca09					call spi_read_byte 
ca09			 
ca09					if DEBUG_FORTH_WORDS 
ca09						DMARK "Si2" 
ca09						CALLMONITOR 
ca09					endif 
ca09					ld h, 0 
ca09					ld l, a 
ca09					if DEBUG_FORTH_WORDS 
ca09						DMARK "Si3" 
ca09						CALLMONITOR 
ca09					endif 
ca09					call forth_push_numhl 
ca09			 
ca09					NEXTW 
ca09			 
ca09			 
ca09			 
ca09			.SESEL: 
ca09				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
ca09			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
ca09					if DEBUG_FORTH_WORDS_KEY 
ca09						DMARK "BNK" 
ca09						CALLMONITOR 
ca09					endif 
ca09			 
ca09					ld a, 255 
ca09					ld (spi_cartdev), a 
ca09			 
ca09					; get bank 
ca09			 
ca09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca09			 
ca09			;		push hl 
ca09			 
ca09					; destroy value TOS 
ca09			 
ca09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca09			 
ca09					; one value on hl get other one back 
ca09			 
ca09			;		pop hl 
ca09			 
ca09			 
ca09					ld c, SPI_CE_HIGH 
ca09					ld b, '0'    ; human readable bank number 
ca09			 
ca09					ld a, l 
ca09			 
ca09					if DEBUG_FORTH_WORDS 
ca09						DMARK "BNK" 
ca09						CALLMONITOR 
ca09					endif 
ca09			 
ca09					; active low 
ca09			 
ca09					cp 0 
ca09					jr z, .bset 
ca09					cp 1 
ca09					jr nz, .b2 
ca09					res 0, c 
ca09					ld b, '1'    ; human readable bank number 
ca09			.b2:		cp 2 
ca09					jr nz, .b3 
ca09					res 1, c 
ca09					ld b, '2'    ; human readable bank number 
ca09			.b3:		cp 3 
ca09					jr nz, .b4 
ca09					res 2, c 
ca09					ld b, '3'    ; human readable bank number 
ca09			.b4:		cp 4 
ca09					jr nz, .b5 
ca09					res 3, c 
ca09					ld b, '4'    ; human readable bank number 
ca09			.b5:		cp 5 
ca09					jr nz, .bset 
ca09					res 4, c 
ca09					ld b, '5'    ; human readable bank number 
ca09			 
ca09			.bset: 
ca09					ld a, c 
ca09					ld (spi_device),a 
ca09					ld a, b 
ca09					ld (spi_device_id),a 
ca09					if DEBUG_FORTH_WORDS 
ca09						DMARK "BN2" 
ca09						CALLMONITOR 
ca09					endif 
ca09			 
ca09					; set default SPI clk pulse time as disabled for BANK use 
ca09			 
ca09					ld a, 0 
ca09					ld (spi_clktime), a 
ca09			 
ca09					NEXTW 
ca09			 
ca09			.CARTDEV: 
ca09				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
ca09			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
ca09					if DEBUG_FORTH_WORDS_KEY 
ca09						DMARK "CDV" 
ca09						CALLMONITOR 
ca09					endif 
ca09			 
ca09					; disable se storage bank selection 
ca09			 
ca09					ld a, SPI_CE_HIGH		; ce high 
ca09					ld (spi_device), a 
ca09			 
ca09					; get bank 
ca09			 
ca09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca09			 
ca09			;		push hl 
ca09			 
ca09					; destroy value TOS 
ca09			 
ca09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca09			 
ca09					; one value on hl get other one back 
ca09			 
ca09			;		pop hl 
ca09			 
ca09					; active low 
ca09			 
ca09					ld c, 255 
ca09			 
ca09					ld a, l 
ca09					if DEBUG_FORTH_WORDS 
ca09						DMARK "CDV" 
ca09						CALLMONITOR 
ca09					endif 
ca09					cp 0 
ca09					jr z, .cset 
ca09					cp 1 
ca09					jr nz, .c2 
ca09					res 0, c 
ca09			.c2:		cp 2 
ca09					jr nz, .c3 
ca09					res 1, c 
ca09			.c3:		cp 3 
ca09					jr nz, .c4 
ca09					res 2, c 
ca09			.c4:		cp 4 
ca09					jr nz, .c5 
ca09					res 3, c 
ca09			.c5:		cp 5 
ca09					jr nz, .c6 
ca09					res 4, c 
ca09			.c6:		cp 6 
ca09					jr nz, .c7 
ca09					res 5, c 
ca09			.c7:		cp 7 
ca09					jr nz, .c8 
ca09					res 6, c 
ca09			.c8:		cp 8 
ca09					jr nz, .cset 
ca09					res 7, c 
ca09			.cset:		ld a, c 
ca09					ld (spi_cartdev),a 
ca09			 
ca09					if DEBUG_FORTH_WORDS 
ca09						DMARK "CD2" 
ca09						CALLMONITOR 
ca09					endif 
ca09			 
ca09					; set default SPI clk pulse time as 10ms for CARTDEV use 
ca09			 
ca09					ld a, $0a 
ca09					ld (spi_clktime), a 
ca09					NEXTW 
ca09			endif 
ca09			 
ca09			.ENDDEVICE: 
ca09			; eof 
ca09			 
# End of file forth_words_device.asm
ca09			 
ca09			; var handler 
ca09			 
ca09			 
ca09			.VARS: 
ca09				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
ca09 77				db WORD_SYS_CORE+99             
ca0a ba ca			dw .V0            
ca0c 04				db 3 + 1 
ca0d .. 00			db "VAR",0              
ca11				endm 
# End of macro CWHEAD
ca11			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
ca11			;| 
ca11			;| The variable name should consist of a single letter. e.g. "a" 
ca11			;! If a full string is passed then only the first char is looked at 
ca11			;| Any other char could exceed bounds checks!  
ca11			 
ca11					if DEBUG_FORTH_WORDS_KEY 
ca11						DMARK "VAR" 
ca11 f5				push af  
ca12 3a 26 ca			ld a, (.dmark)  
ca15 32 6b ee			ld (debug_mark),a  
ca18 3a 27 ca			ld a, (.dmark+1)  
ca1b 32 6c ee			ld (debug_mark+1),a  
ca1e 3a 28 ca			ld a, (.dmark+2)  
ca21 32 6d ee			ld (debug_mark+2),a  
ca24 18 03			jr .pastdmark  
ca26 ..			.dmark: db "VAR"  
ca29 f1			.pastdmark: pop af  
ca2a			endm  
# End of macro DMARK
ca2a						CALLMONITOR 
ca2a cd 6f ee			call debug_vector  
ca2d				endm  
# End of macro CALLMONITOR
ca2d					endif 
ca2d			 
ca2d					FORTH_DSP_VALUEHL 
ca2d cd 42 9d			call macro_dsp_valuehl 
ca30				endm 
# End of macro FORTH_DSP_VALUEHL
ca30			 
ca30 7e					ld a, (hl)    ; get first char on of the string 
ca31			 
ca31			 
ca31					if DEBUG_FORTH_WORDS 
ca31						DMARK "VR1" 
ca31 f5				push af  
ca32 3a 46 ca			ld a, (.dmark)  
ca35 32 6b ee			ld (debug_mark),a  
ca38 3a 47 ca			ld a, (.dmark+1)  
ca3b 32 6c ee			ld (debug_mark+1),a  
ca3e 3a 48 ca			ld a, (.dmark+2)  
ca41 32 6d ee			ld (debug_mark+2),a  
ca44 18 03			jr .pastdmark  
ca46 ..			.dmark: db "VR1"  
ca49 f1			.pastdmark: pop af  
ca4a			endm  
# End of macro DMARK
ca4a						CALLMONITOR 
ca4a cd 6f ee			call debug_vector  
ca4d				endm  
# End of macro CALLMONITOR
ca4d					endif 
ca4d					 
ca4d f5					push af	 
ca4e					FORTH_DSP_POP 
ca4e cd fa 9d			call macro_forth_dsp_pop 
ca51				endm 
# End of macro FORTH_DSP_POP
ca51 f1					pop af 
ca52			 
ca52					; convert to upper 
ca52			 
ca52 cd 49 90				call to_upper 
ca55					if DEBUG_FORTH_WORDS 
ca55						DMARK "Vaa" 
ca55 f5				push af  
ca56 3a 6a ca			ld a, (.dmark)  
ca59 32 6b ee			ld (debug_mark),a  
ca5c 3a 6b ca			ld a, (.dmark+1)  
ca5f 32 6c ee			ld (debug_mark+1),a  
ca62 3a 6c ca			ld a, (.dmark+2)  
ca65 32 6d ee			ld (debug_mark+2),a  
ca68 18 03			jr .pastdmark  
ca6a ..			.dmark: db "Vaa"  
ca6d f1			.pastdmark: pop af  
ca6e			endm  
# End of macro DMARK
ca6e						CALLMONITOR 
ca6e cd 6f ee			call debug_vector  
ca71				endm  
# End of macro CALLMONITOR
ca71					endif 
ca71 06 41				ld b, 'A' 
ca73 90					sub b			; set offset 
ca74					if DEBUG_FORTH_WORDS 
ca74						DMARK "Vbb" 
ca74 f5				push af  
ca75 3a 89 ca			ld a, (.dmark)  
ca78 32 6b ee			ld (debug_mark),a  
ca7b 3a 8a ca			ld a, (.dmark+1)  
ca7e 32 6c ee			ld (debug_mark+1),a  
ca81 3a 8b ca			ld a, (.dmark+2)  
ca84 32 6d ee			ld (debug_mark+2),a  
ca87 18 03			jr .pastdmark  
ca89 ..			.dmark: db "Vbb"  
ca8c f1			.pastdmark: pop af  
ca8d			endm  
# End of macro DMARK
ca8d						CALLMONITOR 
ca8d cd 6f ee			call debug_vector  
ca90				endm  
# End of macro CALLMONITOR
ca90					endif 
ca90 cb 27				sla a  
ca92				 
ca92					 
ca92					if DEBUG_FORTH_WORDS 
ca92						DMARK "VR2" 
ca92 f5				push af  
ca93 3a a7 ca			ld a, (.dmark)  
ca96 32 6b ee			ld (debug_mark),a  
ca99 3a a8 ca			ld a, (.dmark+1)  
ca9c 32 6c ee			ld (debug_mark+1),a  
ca9f 3a a9 ca			ld a, (.dmark+2)  
caa2 32 6d ee			ld (debug_mark+2),a  
caa5 18 03			jr .pastdmark  
caa7 ..			.dmark: db "VR2"  
caaa f1			.pastdmark: pop af  
caab			endm  
# End of macro DMARK
caab						CALLMONITOR 
caab cd 6f ee			call debug_vector  
caae				endm  
# End of macro CALLMONITOR
caae					endif 
caae			 
caae 21 f4 e9				ld hl, cli_var_array2 
cab1 cd dc 8c				call addatohl 
cab4 cd 4b 9b				call forth_push_numhl 
cab7			 
cab7			 
cab7				       NEXTW 
cab7 c3 f8 9e			jp macro_next 
caba				endm 
# End of macro NEXTW
caba			.V0: 
caba				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
caba 78				db WORD_SYS_CORE+100             
cabb d2 ca			dw .V0Q            
cabd 04				db 3 + 1 
cabe .. 00			db "V0!",0              
cac2				endm 
# End of macro CWHEAD
cac2			;| V0! ( u1 -- )  Store value to v0  | DONE 
cac2			 
cac2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cac2 cd 42 9d			call macro_dsp_valuehl 
cac5				endm 
# End of macro FORTH_DSP_VALUEHL
cac5			 
cac5 11 28 ea				ld de, cli_var_array 
cac8			 
cac8 eb					ex de, hl 
cac9 73					ld (hl), e 
caca 23					inc hl 
cacb 72					ld (hl), d 
cacc			 
cacc					; destroy value TOS 
cacc			 
cacc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cacc cd fa 9d			call macro_forth_dsp_pop 
cacf				endm 
# End of macro FORTH_DSP_POP
cacf			 
cacf				       NEXTW 
cacf c3 f8 9e			jp macro_next 
cad2				endm 
# End of macro NEXTW
cad2			.V0Q: 
cad2				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cad2 79				db WORD_SYS_CORE+101             
cad3 e3 ca			dw .V1S            
cad5 04				db 3 + 1 
cad6 .. 00			db "V0@",0              
cada				endm 
# End of macro CWHEAD
cada			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cada 2a 28 ea				ld hl, (cli_var_array) 
cadd cd 4b 9b				call forth_push_numhl 
cae0			 
cae0				       NEXTW 
cae0 c3 f8 9e			jp macro_next 
cae3				endm 
# End of macro NEXTW
cae3			.V1S: 
cae3				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cae3 7a				db WORD_SYS_CORE+102             
cae4 fb ca			dw .V1Q            
cae6 04				db 3 + 1 
cae7 .. 00			db "V1!",0              
caeb				endm 
# End of macro CWHEAD
caeb			;| V1! ( u1 -- )  Store value to v1 | DONE 
caeb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
caeb cd 42 9d			call macro_dsp_valuehl 
caee				endm 
# End of macro FORTH_DSP_VALUEHL
caee			 
caee 11 2a ea				ld de, cli_var_array+2 
caf1				 
caf1 eb					ex de, hl 
caf2 73					ld (hl), e 
caf3 23					inc hl 
caf4 72					ld (hl), d 
caf5			 
caf5					; destroy value TOS 
caf5			 
caf5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caf5 cd fa 9d			call macro_forth_dsp_pop 
caf8				endm 
# End of macro FORTH_DSP_POP
caf8				       NEXTW 
caf8 c3 f8 9e			jp macro_next 
cafb				endm 
# End of macro NEXTW
cafb			.V1Q: 
cafb				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cafb 7b				db WORD_SYS_CORE+103             
cafc 0c cb			dw .V2S            
cafe 04				db 3 + 1 
caff .. 00			db "V1@",0              
cb03				endm 
# End of macro CWHEAD
cb03			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cb03 2a 2a ea				ld hl, (cli_var_array+2) 
cb06 cd 4b 9b				call forth_push_numhl 
cb09				       NEXTW 
cb09 c3 f8 9e			jp macro_next 
cb0c				endm 
# End of macro NEXTW
cb0c			.V2S: 
cb0c				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cb0c 7c				db WORD_SYS_CORE+104             
cb0d 24 cb			dw .V2Q            
cb0f 04				db 3 + 1 
cb10 .. 00			db "V2!",0              
cb14				endm 
# End of macro CWHEAD
cb14			;| V2! ( u1 -- )  Store value to v2 | DONE 
cb14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb14 cd 42 9d			call macro_dsp_valuehl 
cb17				endm 
# End of macro FORTH_DSP_VALUEHL
cb17			 
cb17 11 2c ea				ld de, cli_var_array+4 
cb1a				 
cb1a eb					ex de, hl 
cb1b 73					ld (hl), e 
cb1c 23					inc hl 
cb1d 72					ld (hl), d 
cb1e			 
cb1e					; destroy value TOS 
cb1e			 
cb1e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb1e cd fa 9d			call macro_forth_dsp_pop 
cb21				endm 
# End of macro FORTH_DSP_POP
cb21				       NEXTW 
cb21 c3 f8 9e			jp macro_next 
cb24				endm 
# End of macro NEXTW
cb24			.V2Q: 
cb24				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cb24 7d				db WORD_SYS_CORE+105             
cb25 35 cb			dw .V3S            
cb27 04				db 3 + 1 
cb28 .. 00			db "V2@",0              
cb2c				endm 
# End of macro CWHEAD
cb2c			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cb2c 2a 2c ea				ld hl, (cli_var_array+4) 
cb2f cd 4b 9b				call forth_push_numhl 
cb32				       NEXTW 
cb32 c3 f8 9e			jp macro_next 
cb35				endm 
# End of macro NEXTW
cb35			.V3S: 
cb35				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb35 7c				db WORD_SYS_CORE+104             
cb36 4d cb			dw .V3Q            
cb38 04				db 3 + 1 
cb39 .. 00			db "V3!",0              
cb3d				endm 
# End of macro CWHEAD
cb3d			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb3d cd 42 9d			call macro_dsp_valuehl 
cb40				endm 
# End of macro FORTH_DSP_VALUEHL
cb40			 
cb40 11 2e ea				ld de, cli_var_array+6 
cb43				 
cb43 eb					ex de, hl 
cb44 73					ld (hl), e 
cb45 23					inc hl 
cb46 72					ld (hl), d 
cb47			 
cb47					; destroy value TOS 
cb47			 
cb47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb47 cd fa 9d			call macro_forth_dsp_pop 
cb4a				endm 
# End of macro FORTH_DSP_POP
cb4a				       NEXTW 
cb4a c3 f8 9e			jp macro_next 
cb4d				endm 
# End of macro NEXTW
cb4d			.V3Q: 
cb4d				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb4d 7d				db WORD_SYS_CORE+105             
cb4e 5e cb			dw .END            
cb50 04				db 3 + 1 
cb51 .. 00			db "V3@",0              
cb55				endm 
# End of macro CWHEAD
cb55			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb55 2a 2e ea				ld hl, (cli_var_array+6) 
cb58 cd 4b 9b				call forth_push_numhl 
cb5b				       NEXTW 
cb5b c3 f8 9e			jp macro_next 
cb5e				endm 
# End of macro NEXTW
cb5e			 
cb5e			 
cb5e			 
cb5e			 
cb5e			 
cb5e			; end of dict marker 
cb5e			 
cb5e 00			.END:    db WORD_SYS_END 
cb5f 00 00			dw 0 
cb61 00				db 0 
cb62			 
cb62			; use to jp here for user dict words to save on macro expansion  
cb62			 
cb62			user_dict_next: 
cb62				NEXTW 
cb62 c3 f8 9e			jp macro_next 
cb65				endm 
# End of macro NEXTW
cb65			 
cb65			 
cb65			user_exec: 
cb65				;    ld hl, <word code> 
cb65				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb65				;    call forthexec 
cb65				;    jp user_dict_next   (NEXT) 
cb65			        ;    <word code bytes> 
cb65 eb				ex de, hl 
cb66 2a c2 e5			ld hl,(os_tok_ptr) 
cb69				 
cb69				FORTH_RSP_NEXT 
cb69 cd f2 9a			call macro_forth_rsp_next 
cb6c				endm 
# End of macro FORTH_RSP_NEXT
cb6c			 
cb6c			if DEBUG_FORTH_UWORD 
cb6c						DMARK "UEX" 
cb6c f5				push af  
cb6d 3a 81 cb			ld a, (.dmark)  
cb70 32 6b ee			ld (debug_mark),a  
cb73 3a 82 cb			ld a, (.dmark+1)  
cb76 32 6c ee			ld (debug_mark+1),a  
cb79 3a 83 cb			ld a, (.dmark+2)  
cb7c 32 6d ee			ld (debug_mark+2),a  
cb7f 18 03			jr .pastdmark  
cb81 ..			.dmark: db "UEX"  
cb84 f1			.pastdmark: pop af  
cb85			endm  
# End of macro DMARK
cb85				CALLMONITOR 
cb85 cd 6f ee			call debug_vector  
cb88				endm  
# End of macro CALLMONITOR
cb88			endif 
cb88			 
cb88			 
cb88			 
cb88 eb				ex de, hl 
cb89 22 c2 e5			ld (os_tok_ptr), hl 
cb8c				 
cb8c				; Don't use next - Skips the first word in uword. 
cb8c			 
cb8c c3 89 9f			jp exec1 
cb8f			;	NEXT 
cb8f			 
cb8f			 
cb8f			; eof 
# End of file forth_wordsv4.asm
cb8f			endif 
cb8f			;;;;;;;;;;;;;; Debug code 
cb8f			 
cb8f			 
cb8f			;if DEBUG_FORTH_PARSE 
cb8f .. 00		.nowordfound: db "No match",0 
cb98 .. 00		.compword:	db "Comparing word ",0 
cba8 .. 00		.nextwordat:	db "Next word at",0 
cbb5 .. 00		.charmatch:	db "Char match",0 
cbc0			;endif 
cbc0			if DEBUG_FORTH_JP 
cbc0			.foundword:	db "Word match. Exec..",0 
cbc0			endif 
cbc0			;if DEBUG_FORTH_PUSH 
cbc0 .. 00		.enddict:	db "Dict end. Push.",0 
cbd0 .. 00		.push_str:	db "Pushing string",0 
cbdf .. 00		.push_num:	db "Pushing number",0 
cbee .. 00		.data_sp:	db "SP:",0 
cbf2 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cc04 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cc16 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cc28			;endif 
cc28			;if DEBUG_FORTH_MALLOC 
cc28 .. 00		.push_malloc:	db "Malloc address",0 
cc37			;endif 
cc37			 
cc37			 
cc37			 
cc37			; display malloc address and current data stack pointer  
cc37			 
cc37			malloc_error: 
cc37 d5				push de 
cc38 f5				push af 
cc39 e5				push hl 
cc3a cd af 8a			call clear_display 
cc3d 11 5d cc			ld de, .mallocerr 
cc40 3e 00			ld a,0 
cc42			;	ld de,os_word_scratch 
cc42 cd c2 8a			call str_at_display 
cc45 3e 11			ld a, display_row_1+17 
cc47 11 6b ee			ld de, debug_mark 
cc4a cd c2 8a			call str_at_display 
cc4d cd d2 8a			call update_display 
cc50				;call break_point_state 
cc50 cd 28 e4			call cin_wait 
cc53			 
cc53			;	ld a, ' ' 
cc53			;	ld (os_view_disable), a 
cc53 cd d2 94			call bp_on 
cc56 e1				pop hl 
cc57 f1				pop af 
cc58 d1				pop de	 
cc59				CALLMONITOR 
cc59 cd 6f ee			call debug_vector  
cc5c				endm  
# End of macro CALLMONITOR
cc5c c9				ret 
cc5d			 
cc5d .. 00		.mallocerr: 	db "Malloc Error",0 
cc6a			;if DEBUG_FORTH_PUSH 
cc6a			display_data_sp: 
cc6a f5				push af 
cc6b			 
cc6b				; see if disabled 
cc6b			 
cc6b			 
cc6b 3a 6f ee			ld a, (debug_vector) 
cc6e fe c9			cp $C9  ; RET 
cc70				;ld a, (os_view_disable) 
cc70				;cp '*' 
cc70 28 67			jr z, .skipdsp 
cc72			 
cc72 e5				push hl 
cc73 e5				push hl 
cc74 e5			push hl 
cc75 cd af 8a			call clear_display 
cc78 e1			pop hl 
cc79 7c				ld a,h 
cc7a 21 c6 e5			ld hl, os_word_scratch 
cc7d cd dd 8f			call hexout 
cc80 e1				pop hl 
cc81 7d				ld a,l 
cc82 21 c8 e5			ld hl, os_word_scratch+2 
cc85 cd dd 8f			call hexout 
cc88 21 ca e5			ld hl, os_word_scratch+4 
cc8b 3e 00			ld a,0 
cc8d 77				ld (hl),a 
cc8e 11 c6 e5			ld de,os_word_scratch 
cc91 3e 28				ld a, display_row_2 
cc93 cd c2 8a				call str_at_display 
cc96 11 f2 cb			ld de, .wordinhl 
cc99 3e 00			ld a, display_row_1 
cc9b			 
cc9b cd c2 8a				call str_at_display 
cc9e 11 6b ee			ld de, debug_mark 
cca1 3e 11			ld a, display_row_1+17 
cca3			 
cca3 cd c2 8a				call str_at_display 
cca6			 
cca6				; display current data stack pointer 
cca6 11 ee cb			ld de,.data_sp 
cca9 3e 30				ld a, display_row_2 + 8 
ccab cd c2 8a				call str_at_display 
ccae			 
ccae 2a ee e9			ld hl,(cli_data_sp) 
ccb1 e5				push hl 
ccb2 7c				ld a,h 
ccb3 21 c6 e5			ld hl, os_word_scratch 
ccb6 cd dd 8f			call hexout 
ccb9 e1				pop hl 
ccba 7d				ld a,l 
ccbb 21 c8 e5			ld hl, os_word_scratch+2 
ccbe cd dd 8f			call hexout 
ccc1 21 ca e5			ld hl, os_word_scratch+4 
ccc4 3e 00			ld a,0 
ccc6 77				ld (hl),a 
ccc7 11 c6 e5			ld de,os_word_scratch 
ccca 3e 33				ld a, display_row_2 + 11 
cccc cd c2 8a				call str_at_display 
cccf			 
cccf			 
cccf cd d2 8a			call update_display 
ccd2 cd f2 89			call delay1s 
ccd5 cd f2 89			call delay1s 
ccd8 e1				pop hl 
ccd9			.skipdsp: 
ccd9 f1				pop af 
ccda c9				ret 
ccdb			 
ccdb			display_data_malloc: 
ccdb			 
ccdb f5				push af 
ccdc e5				push hl 
ccdd e5				push hl 
ccde e5			push hl 
ccdf cd af 8a			call clear_display 
cce2 e1			pop hl 
cce3 7c				ld a,h 
cce4 21 c6 e5			ld hl, os_word_scratch 
cce7 cd dd 8f			call hexout 
ccea e1				pop hl 
cceb 7d				ld a,l 
ccec 21 c8 e5			ld hl, os_word_scratch+2 
ccef cd dd 8f			call hexout 
ccf2 21 ca e5			ld hl, os_word_scratch+4 
ccf5 3e 00			ld a,0 
ccf7 77				ld (hl),a 
ccf8 11 c6 e5			ld de,os_word_scratch 
ccfb 3e 28				ld a, display_row_2 
ccfd cd c2 8a				call str_at_display 
cd00 11 28 cc			ld de, .push_malloc 
cd03 3e 00			ld a, display_row_1 
cd05			 
cd05 cd c2 8a				call str_at_display 
cd08			 
cd08				; display current data stack pointer 
cd08 11 ee cb			ld de,.data_sp 
cd0b 3e 30				ld a, display_row_2 + 8 
cd0d cd c2 8a				call str_at_display 
cd10			 
cd10 2a ee e9			ld hl,(cli_data_sp) 
cd13 e5				push hl 
cd14 7c				ld a,h 
cd15 21 c6 e5			ld hl, os_word_scratch 
cd18 cd dd 8f			call hexout 
cd1b e1				pop hl 
cd1c 7d				ld a,l 
cd1d 21 c8 e5			ld hl, os_word_scratch+2 
cd20 cd dd 8f			call hexout 
cd23 21 ca e5			ld hl, os_word_scratch+4 
cd26 3e 00			ld a,0 
cd28 77				ld (hl),a 
cd29 11 c6 e5			ld de,os_word_scratch 
cd2c 3e 33				ld a, display_row_2 + 11 
cd2e cd c2 8a				call str_at_display 
cd31			 
cd31 cd d2 8a			call update_display 
cd34 cd f2 89			call delay1s 
cd37 cd f2 89			call delay1s 
cd3a e1				pop hl 
cd3b f1				pop af 
cd3c c9				ret 
cd3d			;endif 
cd3d			 
cd3d			include "forth_autostart.asm" 
cd3d			; list of commands to perform at system start up 
cd3d			 
cd3d			startcmds: 
cd3d			;	dw test11 
cd3d			;	dw test12 
cd3d			;	dw test13 
cd3d			;	dw test14 
cd3d			;	dw test15 
cd3d			;	dw test16 
cd3d			;	dw test17 
cd3d			;	dw ifthtest1 
cd3d			;	dw ifthtest2 
cd3d			;	dw ifthtest3 
cd3d			;	dw mmtest1 
cd3d			;	dw mmtest2 
cd3d			;	dw mmtest3 
cd3d			;	dw mmtest4 
cd3d			;	dw mmtest5 
cd3d			;	dw mmtest6 
cd3d			;	dw iftest1 
cd3d			;	dw iftest2 
cd3d			;	dw iftest3 
cd3d			;	dw looptest1 
cd3d			;	dw looptest2 
cd3d			;	dw test1 
cd3d			;	dw test2 
cd3d			;	dw test3 
cd3d			;	dw test4 
cd3d			;	dw game2r 
cd3d			;	dw game2b1 
cd3d			;	dw game2b2 
cd3d			 
cd3d				; start up words that are actually useful 
cd3d			 
cd3d			;    dw spi1 
cd3d			;    dw spi2 
cd3d			;    dw spi3 
cd3d			;    dw spi4 
cd3d			;    dw spi5 
cd3d			;    dw spi6 
cd3d			;    dw spi7 
cd3d			; 
cd3d			;    dw spi8 
cd3d			;    dw spi9 
cd3d			;    dw spi10 
cd3d			 
cd3d			; file editor 
cd3d			;	dw edit1 
cd3d			;	dw edit2 
cd3d			;	dw edit3 
cd3d			 
cd3d			;	dw longread 
cd3d 3d d1			dw clrstack 
cd3f 71 d1			dw type 
cd41			;	dw stest 
cd41 96 d1			dw strncpy 
cd43			;	dw list 
cd43 f7 d1			dw start1 
cd45 07 d2			dw start2 
cd47			;	dw start3 
cd47			;	dw start3b 
cd47			;	dw start3c 
cd47			 
cd47				; (unit) testing words 
cd47			 
cd47			;	dw mtesta 
cd47			;	dw mtestb 
cd47			;	dw mtestc 
cd47			;	dw mtestd 
cd47			;	dw mteste 
cd47			 
cd47				; demo/game words 
cd47			 
cd47			;        dw game3w 
cd47			;        dw game3p 
cd47			;        dw game3sc 
cd47			;        dw game3vsi 
cd47			;        dw game3vs 
cd47				 
cd47 60 dc			dw game2b 
cd49 ce dc			dw game2bf 
cd4b 18 dd			dw game2mba 
cd4d ae dd			dw game2mbas 
cd4f f0 dd			dw game2mb 
cd51			 
cd51 21 d9			dw game1 
cd53 32 d9			dw game1a 
cd55 94 d9			dw game1b 
cd57 c9 d9			dw game1c 
cd59 ff d9			dw game1d 
cd5b 30 da			dw game1s 
cd5d 44 da			dw game1t 
cd5f 59 da			dw game1f 
cd61 8d da			dw game1z 
cd63 d1 da			dw game1zz 
cd65			 
cd65 3b d7			dw test5 
cd67 73 d7			dw test6 
cd69 ab d7			dw test7 
cd6b bf d7			dw test8 
cd6d eb d7			dw test9 
cd6f 01 d8			dw test10 
cd71				 
cd71 a8 db		        dw ssv5 
cd73 8c db		        dw ssv4 
cd75 70 db		        dw ssv3 
cd77 3a db		        dw ssv2 
cd79 c1 db		        dw ssv1 
cd7b 09 dc		        dw ssv1cpm 
cd7d			;	dw keyup 
cd7d			;	dw keydown 
cd7d			;	dw keyleft 
cd7d			;	dw keyright 
cd7d			;	dw 	keyf1 
cd7d			;	dw keyf2 
cd7d			;	dw keyf3 
cd7d			;	dw keyf4 
cd7d			;	dw keyf5 
cd7d			;	dw keyf6 
cd7d			;	dw keyf7 
cd7d			;	dw keyf8 
cd7d			;	dw keyf9 
cd7d			;	dw keyf10 
cd7d			;	dw keyf11 
cd7d			;	dw keyf12 
cd7d			;	dw keytab 
cd7d			;	dw keycr 
cd7d			;	dw keyhome 
cd7d			;	dw keyend 
cd7d			;	dw keybs 
cd7d 00 00			db 0, 0	 
cd7f			 
cd7f			 
cd7f			; File Editor 
cd7f			 
cd7f			; ( id - ) use 'e' to edit the displayed line 
cd7f .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cda0 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdd5			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdd5 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
ce0d			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
ce0d			 
ce0d			; SPI Net support words 
ce0d			 
ce0d			; v0! = node to send to 
ce0d			; ( str count - ) 
ce0d .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce66			 
ce66			; spiputchr ( char node - ) 
ce66 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce9c			 
ce9c			; spigetchr ( - n ) 
ce9c .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
cec7			 
cec7			; getnode ( - n ) 
cec7 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cef4			 
cef4			; ( str node - )  
cef4 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf5a			; store string ( str i - ) 
cf5a			 
cf5a			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf5a .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cfaf			 
cfaf			; get string ( addr i -  )    TO FIX 
cfaf			 
cfaf .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d007			 
d007			 
d007			; NETCHAT (TODO) 
d007			; Program to allow two nodes to chat with eachother 
d007			; 
d007			; v0 - target node 
d007			;  
d007			; accept input at 0,0 
d007			; if input is string send spitype to target node 
d007			; starting at row 2,0 , while spigetchr is not zero ->  
d007			; 
d007			; 
d007			; TODO add paging of get request 
d007			 
d007			; ( node - ) 
d007 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d026 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d07e .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0f6			 
d0f6			 
d0f6			; Long read of currently open file 
d0f6 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d13d			 
d13d			; clear stack  
d13d			 
d13d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d171			 
d171			; type ( addr count - ) 
d171 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d196			 
d196			; some direct memory words 
d196			; strncpy ( len t f -- t ) 
d196			 
d196 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1f7			 
d1f7 .. 00		start1:     	db ": bpon $00 bp ;",0 
d207 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d218 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d293 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2f3			 
d2f3			 
d2f3			; a handy word to list items on the stack 
d2f3			 
d2f3 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d35d			 
d35d			 
d35d			; test stack  
d35d			; rnd8 stest 
d35d			 
d35d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d3d4			 
d3d4			; random malloc and free cycles 
d3d4			 
d3d4 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d489			 
d489			; fixed malloc and free cycles 
d489			 
d489 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d52c			 
d52c			; fixed double string push and drop cycle  
d52c			 
d52c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d5e1			 
d5e1			; consistent fixed string push and drop cycle  
d5e1			 
d5e1 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d685			 
d685 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d73b			 
d73b			;test1:		db ": aa 1 2 3 ;", 0 
d73b			;test2:     	db "111 aa 888 999",0 
d73b			;test3:     	db ": bb 77 ;",0 
d73b			;test4:     	db "$02 $01 do i . loop bb",0 
d73b			 
d73b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d773 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d7ab .. 00		test7:     	db ": box hline vline ;",0 
d7bf .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d7eb .. 00		test9:     	db ": sw $01 adsp world ;",0 
d801 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d826 .. 00		test11:     	db "hello create .",0 
d835 .. 00		test12:     	db "hello2 create .",0 
d845			 
d845			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d845			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d845			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d845			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d845			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d845			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d845			 
d845			;iftest1:     	db "$0001 IF cls .",0 
d845			;iftest2:     	db "$0000 IF cls .",0 
d845			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d845			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d845			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d845			 
d845			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d845			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d845			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d845			 
d845			 
d845 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d869 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d899 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d8be .. 00		sound4: db ": cha $00 ; ",0 
d8cb .. 00		sound5: db ": chb $20 ; ",0 
d8d8 .. 00		sound6: db ": chc $40 ; ",0 
d8e5 .. 00		sound7: db ": chd $60 ; ",0 
d8f2 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d90a .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d921			 
d921			 
d921			 
d921			 
d921			; a small guess the number game 
d921			 
d921 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d932 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d994			 
d994 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d9c9 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d9ff .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
da30 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
da44 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
da59 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
da8d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dad1			 
dad1			; Using 'ga' save a high score across multiple runs using external storage 
dad1			 
dad1 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
db3a			 
db3a			 
db3a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
db3a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
db3a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
db3a			 
db3a			; simple screen saver to test code memory reuse to destruction 
db3a			 
db3a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
db70 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
db8c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dba8 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dbc1 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc09 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dc60			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc60			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dc60			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dc60			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dc60			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dc60			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dc60			 
dc60			 
dc60			 
dc60			; minesweeper/battleship finding game 
dc60			; draws a game board of random ship/mine positions 
dc60			; user enters coords to see if it hits on 
dc60			; game ends when all are hit 
dc60			; when hit or miss says how many may be in the area 
dc60			 
dc60			; setup the game board and then hide it 
dc60 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dcce .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dd18			; prompt for where to target 
dd18 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
ddae .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
ddd3			; TODO see if the entered coords hits or misses pushes char hit of miss 
ddd3 .. 00		game2mbht:      db ": mbckht nop ;",0 
dde2 .. 00		game2mbms:      db ": mbcms nop ;",0 
ddf0			; TODO how many might be near by 
ddf0 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
de6d			 
de6d			; Game 3 
de6d			 
de6d			; Vert scroller ski game - avoid the trees! 
de6d			 
de6d			; v0 score (ie turns) 
de6d			; v1 player pos 
de6d			; v2 left wall 
de6d			; v3 right wall 
de6d			 
de6d			; Draw side walls randomly 
de6d			 
de6d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
de9b			 
de9b			; Draw player 
de9b .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
deb9			 
deb9			; TODO Get Key 
deb9			 
deb9			; TODO Move left right 
deb9			 
deb9			; scroll and move walls a bit 
deb9			 
deb9 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
deea			 
deea			; main game loop 
deea			 
deea .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
df16 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
df55			 
df55			; key board defs 
df55			 
df55 .. 00		keyup:       db ": keyup $05 ;",0 
df63 .. 00		keydown:       db ": keydown $0a ;",0 
df73 .. 00		keyleft:       db ": keyleft $0b ;",0 
df83 .. 00		keyright:       db ": keyright $0c ;",0 
df94 .. 00		keyf1:       db ": keyf1 $10 ;",0 
dfa2 .. 00		keyf2:       db ": keyf2 $11 ;",0 
dfb0 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dfbe .. 00		keyf4:       db ": keyf4 $13 ;",0 
dfcc .. 00		keyf5:       db ": keyf5 $14 ;",0 
dfda .. 00		keyf6:       db ": keyf6 $15 ;",0 
dfe8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dff6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
e004 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e012 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e021 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e030 .. 00		keyf12:       db ": keyf12 $1b ;",0 
e03f			 
e03f .. 00		keytab:       db ": keytab $09 ;",0 
e04e .. 00		keycr:       db ": keycr $0d ;",0 
e05c .. 00		keyhome:       db ": keyhome $0e ;",0 
e06c .. 00		keyend:       db ": keyend $0f ;",0 
e07b .. 00		keybs:       db ": keybs $08 ;",0 
e089			 
e089			   
e089			 
e089			 
e089			 
e089			; eof 
# End of file forth_autostart.asm
e089			 
e089			 
e089			 
e089			; stack over and underflow checks 
e089			 
e089			; init the words to detect the under/overflow 
e089			 
e089			chk_stk_init: 
e089				; a vague random number to check so we dont get any "lucky" hits 
e089 3e 2d			ld a, 45 
e08b 6f				ld l, a 
e08c 00				nop 
e08d 3e 17			ld a, 23 
e08f 67				ld h, a 
e090			 
e090 22 a9 e2			ld (chk_word), hl     ; the word we need to check against 
e093			 
e093			;	ld (chk_stund), hl	; stack points.... 
e093 22 00 ef			ld (chk_stovr), hl 
e096 22 ec e9			ld (chk_ret_und), hl 
e099 22 aa e9			ld (chk_ret_ovr), hl 
e09c 22 28 e9			ld (chk_loop_ovr), hl 
e09f 22 26 e8			ld (chk_data_ovr), hl 
e0a2 c9				ret 
e0a3				 
e0a3			check_stacks: 
e0a3				; check all stack words 
e0a3			 
e0a3 e5				push hl 
e0a4 d5				push de 
e0a5			 
e0a5			;	ld de,(chk_word) 
e0a5			;	ld hl, (chk_stund)	; stack points.... 
e0a5			;	if DEBUG_STK_FAULT 
e0a5			;		DMARK "FAa" 
e0a5			;		CALLMONITOR 
e0a5			;	endif 
e0a5			;	call cmp16 
e0a5			;	jp z, .chk_faulta 
e0a5			; 
e0a5			;	ld de, sfaultsu 
e0a5			;	jp .chk_fault 
e0a5			 
e0a5 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e0a8 ed 5b a9 e2		ld de,(chk_word) 
e0ac				if DEBUG_STK_FAULT 
e0ac					DMARK "FAb" 
e0ac					CALLMONITOR 
e0ac				endif 
e0ac cd fa 8c			call cmp16 
e0af 28 06			jr z, .chk_fault1 
e0b1 11 52 e1			ld de, sfaultso 
e0b4 c3 06 e1			jp .chk_fault 
e0b7			.chk_fault1:  
e0b7 2a ec e9			ld hl, (chk_ret_und) 
e0ba ed 5b a9 e2		ld de,(chk_word) 
e0be				if DEBUG_STK_FAULT 
e0be					DMARK "FAU" 
e0be					CALLMONITOR 
e0be				endif 
e0be cd fa 8c			call cmp16 
e0c1 ca ca e0			jp z, .chk_fault2 
e0c4 11 62 e1			ld de, sfaultru 
e0c7 c3 06 e1			jp .chk_fault 
e0ca			.chk_fault2:  
e0ca 2a aa e9			ld hl, (chk_ret_ovr) 
e0cd ed 5b a9 e2		ld de,(chk_word) 
e0d1				if DEBUG_STK_FAULT 
e0d1					DMARK "FA1" 
e0d1					CALLMONITOR 
e0d1				endif 
e0d1 cd fa 8c			call cmp16 
e0d4 ca dd e0			jp z, .chk_fault3 
e0d7 11 70 e1			ld de, sfaultro 
e0da c3 06 e1			jp .chk_fault 
e0dd			.chk_fault3:  
e0dd 2a 28 e9			ld hl, (chk_loop_ovr) 
e0e0 ed 5b a9 e2		ld de,(chk_word) 
e0e4				if DEBUG_STK_FAULT 
e0e4					DMARK "FA2" 
e0e4					CALLMONITOR 
e0e4				endif 
e0e4 cd fa 8c			call cmp16 
e0e7 ca f0 e0			jp z, .chk_fault4 
e0ea 11 8a e1			ld de, sfaultlo 
e0ed c3 06 e1			jp .chk_fault 
e0f0			.chk_fault4:  
e0f0 2a 26 e8			ld hl, (chk_data_ovr) 
e0f3 ed 5b a9 e2		ld de,(chk_word) 
e0f7				if DEBUG_STK_FAULT 
e0f7					DMARK "FA3" 
e0f7					CALLMONITOR 
e0f7				endif 
e0f7 cd fa 8c			call cmp16 
e0fa ca 03 e1			jp z, .chk_fault5 
e0fd 11 a4 e1			ld de, sfaultdo 
e100 c3 06 e1			jp .chk_fault 
e103			 
e103			 
e103			.chk_fault5:  
e103 d1				pop de 
e104 e1				pop hl 
e105			 
e105 c9				ret 
e106			 
e106 cd af 8a		.chk_fault: 	call clear_display 
e109 3e 28				ld a, display_row_2 
e10b cd c2 8a				call str_at_display 
e10e 11 34 e1				   ld de, .stackfault 
e111 3e 00				ld a, display_row_1 
e113 cd c2 8a				call str_at_display 
e116 11 6b ee				    ld de, debug_mark 
e119 3e 11				ld a, display_row_1+17 
e11b cd c2 8a				call str_at_display 
e11e cd d2 8a				call update_display 
e121			 
e121				; prompt before entering montior for investigating issue 
e121			 
e121 3e 78			ld a, display_row_4 
e123 11 3d 98			ld de, endprog 
e126			 
e126 cd d2 8a			call update_display		 
e129			 
e129 cd c3 9a			call next_page_prompt 
e12c			 
e12c d1				pop de 
e12d e1				pop hl 
e12e cd 91 98				call monitor 
e131 c3 8b 97				jp warmstart 
e134					;jp 0 
e134					;halt 
e134			 
e134			 
e134			 
e134 .. 00		.stackfault: 	db "Stack fault:",0 
e141			 
e141 .. 00		sfaultsu: 	db	"Stack under flow",0 
e152 .. 00		sfaultso: 	db	"Stack over flow",0 
e162 .. 00		sfaultru:	db "RTS underflow",0 
e170 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e18a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e1a4 .. 00		sfaultdo:	db "DTS overflow", 0 
e1b1			 
e1b1			 
e1b1			fault_dsp_under: 
e1b1 11 c3 e1			ld de, .dsp_under 
e1b4 c3 73 e2			jp .show_fault 
e1b7			 
e1b7			fault_rsp_under: 
e1b7 11 d1 e1			ld de, .rsp_under 
e1ba c3 73 e2			jp .show_fault 
e1bd			fault_loop_under: 
e1bd 11 df e1			ld de, .loop_under 
e1c0 c3 73 e2			jp .show_fault 
e1c3			 
e1c3 .. 00		.dsp_under: db "DSP Underflow",0 
e1d1 .. 00		.rsp_under: db "RSP Underflow",0 
e1df .. 00		.loop_under: db "LOOP Underflow",0 
e1ee			 
e1ee			 
e1ee d5			type_faultn: 	push de 
e1ef e5					push hl 
e1f0 cd af 8a				call clear_display 
e1f3 11 1a e2				   ld de, .typefaultn 
e1f6 3e 00				ld a, display_row_1 
e1f8 cd c2 8a				call str_at_display 
e1fb 11 6b ee				    ld de, debug_mark 
e1fe 3e 11				ld a, display_row_1+17 
e200 cd c2 8a				call str_at_display 
e203 cd d2 8a				call update_display 
e206			 
e206				; prompt before entering montior for investigating issue 
e206			 
e206 3e 78			ld a, display_row_4 
e208 11 3d 98			ld de, endprog 
e20b			 
e20b cd d2 8a			call update_display		 
e20e			 
e20e cd c3 9a			call next_page_prompt 
e211			 
e211 e5					push hl 
e212 d5					push de 
e213 cd 91 98				call monitor 
e216 c3 8b 97				jp warmstart 
e219 76					halt 
e21a			 
e21a			 
e21a .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e231			 
e231 d5			type_faults: 	push de 
e232 e5					push hl 
e233 cd af 8a				call clear_display 
e236 11 5c e2				   ld de, .typefaults 
e239 3e 00				ld a, display_row_1 
e23b cd c2 8a				call str_at_display 
e23e 11 6b ee				    ld de, debug_mark 
e241 3e 11				ld a, display_row_1+17 
e243 cd c2 8a				call str_at_display 
e246 cd d2 8a				call update_display 
e249			 
e249				; prompt before entering montior for investigating issue 
e249			 
e249 3e 78			ld a, display_row_4 
e24b 11 3d 98			ld de, endprog 
e24e			 
e24e cd d2 8a			call update_display		 
e251			 
e251 cd c3 9a			call next_page_prompt 
e254			 
e254 e1					pop hl 
e255 d1					pop de 
e256 cd 91 98				call monitor 
e259 c3 8b 97				jp warmstart 
e25c			 
e25c			 
e25c .. 00		.typefaults: db "STR Type Expected TOS!",0 
e273			 
e273			.show_fault: 	 
e273 d5					push de 
e274 cd af 8a				call clear_display 
e277 d1					pop de 
e278 3e 00				ld a, display_row_1 
e27a cd c2 8a				call str_at_display 
e27d 11 6b ee				    ld de, debug_mark 
e280 3e 11				ld a, display_row_1+17 
e282 cd c2 8a				call str_at_display 
e285 cd d2 8a				call update_display 
e288			 
e288				; prompt before entering montior for investigating issue 
e288			 
e288 3e 78			ld a, display_row_4 
e28a 11 3d 98			ld de, endprog 
e28d			 
e28d cd d2 8a			call update_display		 
e290			 
e290 cd c3 9a			call next_page_prompt 
e293			 
e293 e1					pop hl 
e294 d1					pop de 
e295 cd 91 98				call monitor 
e298			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e298			; TODO Make optional fault restart to cli or warm boot? 
e298					;jp warmstart 
e298 c3 e3 97				jp cli 
e29b 76					halt 
e29c			 
e29c			; handle the auto run of code from files in storage 
e29c			 
e29c			 
e29c			include "forth_startup.asm" 
e29c			; Which startup method to use? 
e29c			; 
e29c			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e29c			; followed by loading of a list of scripts in eeprom 
e29c			 
e29c			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e29c			; from eeprom 
e29c			 
e29c			; Select with define in main stubs 
e29c			 
e29c			if STARTUP_V1 
e29c				include "forth_startupv1.asm" 
e29c			; Startup script loading version 1 
e29c			 
e29c			; If SE storage is available first stage is to use the selected file 
e29c			; then go through the eeprom list 
e29c			 
e29c .. 00		sprompt1: db "Startup load...",0 
e2ac .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e2c2			 
e2c2			 
e2c2			 
e2c2			 
e2c2			forth_startup: 
e2c2 21 3d cd			ld hl, startcmds 
e2c5 3e 00			ld a, 0 
e2c7 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e2ca			 
e2ca e5			.start1:	push hl 
e2cb cd af 8a			call clear_display 
e2ce 11 9c e2			ld de, sprompt1 
e2d1 3e 00		        ld a, display_row_1 
e2d3 cd c2 8a			call str_at_display 
e2d6 11 ac e2			ld de, sprompt2 
e2d9 3e 28		        ld a, display_row_2 
e2db cd c2 8a			call str_at_display 
e2de e1				pop hl 
e2df e5				push hl 
e2e0 5e				ld e,(hl) 
e2e1 23				inc hl 
e2e2 56				ld d,(hl) 
e2e3 3e 50		        ld a, display_row_3 
e2e5 cd c2 8a			call str_at_display 
e2e8 cd d2 8a			call update_display 
e2eb			 
e2eb			 
e2eb 3a e7 e6			ld a, (os_last_cmd) 
e2ee fe 00			cp 0 
e2f0 28 05			jr z, .startprompt 
e2f2 cd e6 89			call delay250ms 
e2f5 18 24			jr .startdo 
e2f7				 
e2f7				 
e2f7			 
e2f7			.startprompt: 
e2f7			 
e2f7 3e 9f			ld a,display_row_4 + display_cols - 1 
e2f9 11 c1 9a		        ld de, endprg 
e2fc cd c2 8a			call str_at_display 
e2ff cd d2 8a			call update_display 
e302 cd f2 89			call delay1s 
e305 cd 28 e4			call cin_wait 
e308						 
e308 fe 2a			cp '*' 
e30a 28 5e			jr z, .startupend1 
e30c fe 23			cp '#' 
e30e 20 07			jr nz, .startno 
e310 3e 01			ld a, 1 
e312 32 e7 e6			ld (os_last_cmd),a 
e315 18 04			jr .startdo 
e317 fe 31		.startno:	cp '1' 
e319 28 3a			jr z,.startnxt  
e31b			 
e31b				; exec startup line 
e31b			.startdo:	 
e31b e1				pop hl 
e31c e5				push hl 
e31d				 
e31d 5e				ld e,(hl) 
e31e 23				inc hl 
e31f 56				ld d,(hl) 
e320 eb				ex de,hl 
e321			 
e321 e5				push hl 
e322			 
e322 3e 00			ld a, 0 
e324				;ld a, FORTH_END_BUFFER 
e324 cd 45 91			call strlent 
e327 23				inc hl   ; include zero term to copy 
e328 06 00			ld b,0 
e32a 4d				ld c,l 
e32b e1				pop hl 
e32c 11 c1 e2			ld de, scratch 
e32f ed b0			ldir 
e331			 
e331			 
e331 21 c1 e2			ld hl, scratch 
e334 cd 46 9f			call forthparse 
e337 cd 86 9f			call forthexec 
e33a cd 98 9e			call forthexec_cleanup 
e33d			 
e33d 3e 78			ld a, display_row_4 
e33f 11 3d 98			ld de, endprog 
e342			 
e342 cd d2 8a			call update_display		 
e345			 
e345 3a e7 e6			ld a, (os_last_cmd) 
e348 fe 00			cp 0 
e34a 20 09			jr nz, .startnxt 
e34c cd c3 9a			call next_page_prompt 
e34f cd af 8a		        call clear_display 
e352 cd d2 8a			call update_display		 
e355			 
e355				; move onto next startup line? 
e355			.startnxt: 
e355			 
e355 cd e6 89			call delay250ms 
e358 e1				pop hl 
e359			 
e359 23				inc hl 
e35a 23				inc hl 
e35b			 
e35b e5				push hl 
e35c 5e				ld e, (hl) 
e35d 23				inc hl 
e35e 56				ld d, (hl) 
e35f e1				pop hl 
e360				; TODO replace 0 test 
e360			 
e360 eb				ex de, hl 
e361 cd 05 8d			call ishlzero 
e364			;	ld a,e 
e364			;	add d 
e364			;	cp 0    ; any left to do? 
e364 eb				ex de, hl 
e365 c2 ca e2			jp nz, .start1 
e368 18 01			jr .startupend 
e36a			 
e36a e1			.startupend1: pop hl 
e36b			.startupend: 
e36b			 
e36b cd af 8a			call clear_display 
e36e cd d2 8a			call update_display 
e371 c9				ret 
e372			if STORAGE_SE 
e372			 
e372			sprompt3: db "Loading from start-up file?:",0 
e372			sprompt4: db "(Y=Any key/N=No)",0 
e372			 
e372			 
e372			forth_autoload: 
e372			 
e372				; load block 0 of store 1 
e372				 
e372				ld a, $fe      ; bit 0 clear 
e372				ld (spi_device), a 
e372			 
e372				call storage_get_block_0 
e372			 
e372				ld a, (store_page+STORE_0_AUTOFILE) 
e372			 
e372				cp 0 
e372				ret z     ; auto start not enabled 
e372			 
e372				call clear_display 
e372			 
e372				; set bank 
e372			 
e372					ld a, (store_page+STORE_0_BANKRUN) 
e372					ld (spi_device), a 
e372			 
e372				; get file id to load from and get the file name to display 
e372			 
e372					ld a, (store_page+STORE_0_FILERUN) 
e372			 
e372					ld l, 0 
e372					ld h, a 
e372					ld de, store_page 
e372			 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASp" 
e372						CALLMONITOR 
e372					endif 
e372					call storage_read 
e372			 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASr" 
e372						CALLMONITOR 
e372					endif 
e372			 
e372					call ishlzero 
e372					ret z             ; file not found 
e372			 
e372					ld a, display_row_2 + 10 
e372					ld de, store_page+3 
e372					call str_at_display 
e372				 
e372			; 
e372			 
e372				ld a, display_row_1+5 
e372				ld de, sprompt3 
e372				call str_at_display 
e372				ld a, display_row_3+15 
e372				ld de, sprompt4 
e372				call str_at_display 
e372			 
e372				call update_display 
e372			 
e372				call cin_wait 
e372				cp 'n' 
e372				ret z 
e372				cp 'N' 
e372				ret z 
e372			 
e372				call delay1s 
e372			 
e372				ld a, (store_page+2) 
e372				ld (store_openmaxext), a    ; save count of ext 
e372				ld a, 1  
e372				ld (store_openext), a    ; save count of ext 
e372			 
e372			.autof:  
e372				ld l , a 
e372				 
e372				ld a, (store_page) 
e372				ld h, a	 
e372				ld de, store_page 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASl" 
e372						CALLMONITOR 
e372					endif 
e372					call storage_read 
e372				call ishlzero 
e372				ret z 
e372			;	jr z, .autoend 
e372			 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASc" 
e372						CALLMONITOR 
e372					endif 
e372				ld de, store_page+2 
e372				ld a, display_row_4 
e372				call str_at_display 
e372			 
e372				call update_display 
e372				call delay250ms 
e372			 
e372			 
e372			 
e372				ld hl, store_page+2 
e372				call forthparse 
e372				call forthexec 
e372				call forthexec_cleanup 
e372			 
e372				 
e372				ld a, (store_openext) 
e372				inc a 
e372				ld (store_openext), a    ; save count of ext 
e372			 
e372				jr .autof 
e372			;.autofdone: 
e372			; 
e372			;		if DEBUG_FORTH_WORDS 
e372			;			DMARK "ASx" 
e372			;			CALLMONITOR 
e372			;		endif 
e372			;;	call clear_display 
e372			;	ret 
e372			 
e372			 
e372			 
e372			endif 
# End of file forth_startupv1.asm
e372			endif 
e372			if STARTUP_V2 
e372				include "forth_startupv2.asm" 
e372			endif 
e372			 
# End of file forth_startup.asm
e372			 
e372			; eof 
# End of file forth_kernel.asm
e372			;include "nascombasic.asm" 
e372			 
e372			 
e372			; find out where the code ends if loaded into RAM (for SC114) 
e372			;endofcode:  
e372			;	nop 
e372			 
e372			 
e372			; jump to nmi vector 
e372			 
e372			init_nmi: 
e372 3e c9			ld a, $c9   ; RET 
e374 32 72 ee			ld (nmi_vector), a 
e377 c9				ret 
e378			nmi: 
e378 e5				push hl 
e379 d5				push de 
e37a c5				push bc 
e37b f5				push af 
e37c cd 72 ee			call nmi_vector 
e37f f5				push af 
e380 c5				push bc 
e381 d5				push de 
e382 e5				push hl 
e383 ed 4d			reti 
e385			 
e385			 
e385			; eof 
e385			 
# End of file main.asm
e385			;include "firmware_lcd_4x40.asm" 
e385			;;include "firmware_lcd_4x20.asm" 
e385			include "firmware_serial_display.asm" 
e385			 
e385			; Serial display interface for SC114 
e385			 
e385			 
e385			display_row_1: equ 0 
e385			display_row_2: equ display_row_1+display_cols 
e385			display_row_3: equ display_row_2 + display_cols 
e385			display_row_4: equ display_row_3 + display_cols 
e385			 
e385			kLCDWidth:  EQU display_cols             ;Width in characters 
e385			kLCD_Line1: EQU 0x00  
e385			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e385			; E1 
e385			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e385			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e385			 
e385			lcd_init: 
e385				; no init as handled by the SCM bios 
e385 c9				ret 
e386			 
e386			 
e386			; low level functions for direct screen writes 
e386			 
e386			; output char at pos? 
e386			fLCD_Str: 
e386			        ;out (SC114_SIO_1_OUT),a 
e386 c5				push bc 
e387 0e 02			ld c, $02 
e389 f7				rst $30 
e38a c1				pop bc 
e38b c9				ret 
e38c			 
e38c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e38c			fLCD_Pos: 
e38c				; use ASCII escape to position 
e38c			        ;out (SC114_SIO_1_OUT),a 
e38c c5				push bc 
e38d 0e 02			ld c, $02 
e38f f7				rst $30 
e390 c1				pop bc 
e391			 
e391 c9				ret 
e392			 
e392			; output char at pos 
e392			fLCD_Data: 
e392			      ;  out (SC114_SIO_1_OUT),a 
e392 c5				push bc 
e393 0e 02			ld c, $02 
e395 f7				rst $30 
e396 c1				pop bc 
e397			 
e397 c9				ret 
e398			 
e398			; ascii cls  
e398			 
e398 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e39c			 
e39c			; write the frame buffer given in hl to hardware  
e39c			write_display: 
e39c			 
e39c			API: equ 0 
e39c			 
e39c			if API 
e39c				push bc 
e39c				ld b, 4 
e39c			 
e39c			        ld (display_write_tmp), hl 	  
e39c			 
e39c				; clear and home cursor 
e39c			 
e39c				ld c, 6 
e39c				ld de, .cls 
e39c				rst $30 
e39c			 
e39c			 
e39c			.writeln: 
e39c			 
e39c				ld de, (display_write_tmp) 
e39c				ld c, 6 
e39c				rst $30 
e39c				ld c, 7 
e39c				rst $30 
e39c			 
e39c				ld hl, (display_write_tmp) 
e39c				ld de, display_cols 
e39c				add hl,de 
e39c				ld (display_write_tmp),hl 
e39c			 
e39c				djnz  .writeln 
e39c			 
e39c				pop bc 
e39c			 
e39c			 
e39c				ret 
e39c			endif 
e39c e5				push hl 
e39d c5				push bc 
e39e d5				push de 
e39f			 
e39f			;	ld c, 2 
e39f			;	;ld de, .cls 
e39f			;	ld a, 27 
e39f			;	rst $30 
e39f			;	ld c, 2 
e39f			;	;ld de, .cls 
e39f			;	ld a, '[' 
e39f			;	rst $30 
e39f			; 
e39f			;	ld c, 2 
e39f			;	;ld de, .cls 
e39f			;	ld a, 'H' 
e39f			;	rst $30 
e39f			; 
e39f			 
e39f 0e 02			ld c, 2 
e3a1				;ld de, .cls 
e3a1 3e 1b			ld a, 27 
e3a3 f7				rst $30 
e3a4			 
e3a4			 
e3a4 0e 02			ld c, 2 
e3a6				;ld de, .cls 
e3a6 3e 5b			ld a, '[' 
e3a8 f7				rst $30 
e3a9 0e 02			ld c, 2 
e3ab				;ld de, .cls 
e3ab 3e 32			ld a, '2' 
e3ad f7				rst $30 
e3ae 0e 02			ld c, 2 
e3b0				;ld de, .cls 
e3b0 3e 4a			ld a, 'J' 
e3b2 f7				rst $30 
e3b3 d1				pop de 
e3b4 c1				pop bc 
e3b5 e1				pop hl 
e3b6			 
e3b6			 
e3b6 22 c9 eb		        ld (display_write_tmp), hl 	  
e3b9 3e 00			ld a, kLCD_Line1 
e3bb			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3bb 06 28			ld b, display_cols 
e3bd ed 5b c9 eb		ld de, (display_write_tmp) 
e3c1 cd 1f e4			call write_len_string 
e3c4				 
e3c4			 
e3c4 e5			push hl 
e3c5 d5			push de 
e3c6 c5			push bc 
e3c7 0e 07			ld c, 7 
e3c9 f7				rst $30 
e3ca c1			pop bc 
e3cb d1			pop de 
e3cc e1			pop hl 
e3cd			 
e3cd				 
e3cd 2a c9 eb			ld hl, (display_write_tmp) 
e3d0 11 28 00			ld de, display_cols 
e3d3 19				add hl,de 
e3d4 22 c9 eb			ld (display_write_tmp),hl 
e3d7			 
e3d7				 
e3d7 3e 28			ld a, kLCD_Line2 
e3d9			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3d9 06 28			ld b, display_cols 
e3db ed 5b c9 eb		ld de, (display_write_tmp) 
e3df cd 1f e4			call write_len_string 
e3e2				 
e3e2 2a c9 eb			ld hl, (display_write_tmp) 
e3e5 11 28 00			ld de, display_cols 
e3e8 19				add hl,de 
e3e9 22 c9 eb			ld (display_write_tmp),hl 
e3ec			 
e3ec e5			push hl 
e3ed d5			push de 
e3ee c5			push bc 
e3ef 0e 07			ld c, 7 
e3f1 f7				rst $30 
e3f2 c1			pop bc 
e3f3 d1			pop de 
e3f4 e1			pop hl 
e3f5			 
e3f5				 
e3f5 3e 50			ld a, kLCD_Line3 
e3f7			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e3f7 06 28			ld b, display_cols 
e3f9 ed 5b c9 eb		ld de, (display_write_tmp) 
e3fd cd 1f e4			call write_len_string 
e400				 
e400 2a c9 eb			ld hl, (display_write_tmp) 
e403 11 28 00			ld de, display_cols 
e406 19				add hl,de 
e407 22 c9 eb			ld (display_write_tmp),hl 
e40a			 
e40a e5			push hl 
e40b d5			push de 
e40c c5			push bc 
e40d 0e 07			ld c, 7 
e40f f7				rst $30 
e410 c1			pop bc 
e411 d1			pop de 
e412 e1			pop hl 
e413			 
e413				 
e413 3e 78			ld a, kLCD_Line4 
e415			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e415 06 28			ld b, display_cols 
e417 ed 5b c9 eb		ld de, (display_write_tmp) 
e41b cd 1f e4			call write_len_string 
e41e c9					ret 
e41f			 
e41f			 
e41f				; write out a fixed length string given in b from de 
e41f			 
e41f 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e420 cd 92 e3		            CALL fLCD_Data      ;Write character to display 
e423 13				inc de 
e424 10 f9			djnz write_len_string 
e426 c9				ret 
e427			 
e427			 
e427			; eof 
# End of file firmware_serial_display.asm
e427			;include "firmware_key_5x10.asm" 
e427			;;include "firmware_key_4x10.asm" 
e427			include "firmware_key_serial.asm" 
e427			; Serial keyboard interface for SC114 
e427			 
e427			key_init: 
e427				; no init as handled by the SCM bios 
e427 c9				ret 
e428			 
e428			 
e428			cin_wait: 
e428			;	ld a, 0 
e428			;	ret 
e428			 
e428				;in a,(SC114_SIO_1_IN) 
e428			        ; Use SCM API to get from whatever console device we are using 
e428 c5				push bc 
e429 0e 01			ld c, $01 
e42b f7				rst $30 
e42c c1				pop bc 
e42d c9				ret 
e42e			 
e42e			cin: 
e42e			 
e42e			 
e42e c5				push bc 
e42f			 
e42f				; any key waiting to process? 
e42f 0e 03			ld c, $03 
e431 f7				rst $30 
e432 28 05			jr z, .cin_skip 
e434			 
e434				; yep, get it 
e434			 
e434 0e 01			ld c, $01 
e436 f7				rst $30 
e437 c1				pop bc 
e438 c9				ret 
e439			.cin_skip: 
e439 3e 00			ld a, 0 
e43b c1				pop bc 
e43c c9				ret 
e43d			 
e43d			 
e43d			 
e43d			 
# End of file firmware_key_serial.asm
e43d			endofcode:  
e43d			baseram:  
e43d 00				nop 
e43e			 
e43e			heap_start: equ baseram+15  ; Starting address of heap 
e43e			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e43e			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e43e			;VDU:  EQU     endofcode           ; BASIC Work space 
e43e			; eof 
e43e			 
# End of file os_mega_sc114.asm
e43e
