# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 2e 1f			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-09 10:11' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 11 79			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			;stacksize: equ 256  
0068			; each stack entry is three bytes (type + word)  
0068			stacksize: equ 3*150  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			; cursor blink rate  
0068			CUR_BLINK_RATE: equ $09  
0068			;CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 4b fc				ld hl, display_fb1  
006b 22 07 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 09 fb				ld hl, display_fb2  
0074 22 07 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ec fc				ld hl, display_fb0  
007d 22 07 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd 1e 79				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd b5 7b			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd 96 16				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 28 1e			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 3d 1e			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 a6 fd		ld (debug_mark),a  
00dd 32 a7 fd		ld (debug_mark+1),a  
00e0 32 a8 fd		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 a9 fd		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 9f f9			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 9c f9			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 9c f9			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 9c f9			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 9c f9			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 9c f9			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 9e f9			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 9b f9			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 9f f9				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 9b f9			ld (spi_device), a 
0263 32 9e f9			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 9c f9		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 9c f9		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 9c f9		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 9c f9		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 9c f9		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 9c f9		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 9c f9		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 9c f9		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 9c f9		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 9c f9		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 9c f9		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 9c f9		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 9c f9		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 9c f9		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 9c f9		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 9c f9		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 fe f0			ld hl,scratch+2 
033e cd 9e 15			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 1f f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 03 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a 1f f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 1f f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 1f f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 24 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a 24 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a 1f f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 1f f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 24 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 1f f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 ae f9			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 a6 fd			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 a7 fd			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 a8 fd			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd aa fd			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a b5 f9			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 a6 fd			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 a7 fd			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 a8 fd			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd aa fd			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 b5 f9				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 a6 fd			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 a7 fd			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 a8 fd			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd aa fd			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a ae f9				ld hl, (store_tmp1) 
03fc 11 b8 f9				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 a6 fd			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 a7 fd			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 a8 fd			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd aa fd			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd 7d 16				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 a6 fd			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 a7 fd			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 a8 fd			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd aa fd			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 a6 fd			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 a7 fd			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 a8 fd			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd aa fd			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 a6 fd			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 a7 fd			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 a8 fd			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd aa fd			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 a6 fd			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 a7 fd			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 a8 fd			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd aa fd			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 b5 f9			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 a6 fd			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 a7 fd			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 a8 fd			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd aa fd			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 a6 fd			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 a7 fd			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 a8 fd			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd aa fd			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 b5 f9			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 a6 fd			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 a7 fd			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 a8 fd			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 b5 f9				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd aa fd			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a b6 f9			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 a6 fd			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 a7 fd			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 a8 fd			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd aa fd			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 a6 fd			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 a7 fd			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 a8 fd			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd aa fd			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 b5 f9			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 b6 f9		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 b8 f9		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 c1 f9			ld hl, store_page+3+9 
05a1 3a 9a f9			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 b5 f9			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 a6 fd			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 a7 fd			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 a8 fd			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd aa fd			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 a6 fd			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 a7 fd			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 a8 fd			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd aa fd			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 a6 fd			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 a7 fd			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 a8 fd			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd aa fd			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 b8 f9		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 a6 fd			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 a7 fd			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 a8 fd			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd aa fd			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 b5 f9			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 a6 fd			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 a7 fd			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 a8 fd			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd aa fd			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 a6 fd			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 a7 fd			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 a8 fd			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd aa fd			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 b5 f9			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 a6 fd			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 a7 fd			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 a8 fd			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd aa fd			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a b5 f9			ld a, (store_page)	; get file id 
06fc 32 a9 f9			ld (store_tmpid), a 
06ff			 
06ff 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
0702 32 a8 f9			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 b5 f9			ld (store_page), a 
070b 32 b6 f9			ld (store_page+1),a 
070e 11 b5 f9			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 a6 fd			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 a7 fd			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 a8 fd			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd aa fd			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a a8 f9			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a a9 f9			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 a6 fd			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 a7 fd			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 a8 fd			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd aa fd			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 b5 f9			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 b5 f9			ld (store_page), a 
076e 32 b6 f9			ld (store_page+1),a 
0771 11 b5 f9			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 a6 fd			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 a7 fd			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 a8 fd			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd aa fd			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 a6 fd			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 a7 fd			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 a8 fd			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd aa fd			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 a6 fd			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 a7 fd			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 a8 fd			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd aa fd			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 a6 fd			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 a7 fd			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 a8 fd			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd aa fd			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 a6 fd			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 a7 fd			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 a8 fd			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd aa fd			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a b5 f9			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 b5 f9			ld (store_page),a 
088f				 
088f 32 a9 f9			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 b5 f9			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 a6 fd			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 a7 fd			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 a8 fd			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd aa fd			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 b5 f9				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 a6 fd			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 a7 fd			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 a8 fd			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd aa fd			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 a6 fd			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 a7 fd			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 a8 fd			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd aa fd			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 a0 f9			ld (store_tmppageid), hl 
0901				 
0901 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 b5 f9			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 b6 f9			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 a6 fd			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 a7 fd			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 a8 fd			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd aa fd			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 50 16			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 a6 fd			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 a7 fd			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 a8 fd			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd aa fd			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 a6 fd			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 a7 fd			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 a8 fd			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd aa fd			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a a0 f9			ld hl,(store_tmppageid) 
0977 11 b5 f9			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 a6 fd			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 a7 fd			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 a8 fd			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd aa fd			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a a9 f9			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 a6 fd			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 a7 fd			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 a8 fd			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd aa fd			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 a6 fd			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 a7 fd			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 a8 fd			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd aa fd			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 a6 fd			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 a7 fd			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 a8 fd			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd aa fd			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 a6 f9			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 a6 fd			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 a7 fd			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 a8 fd			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd aa fd			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 a8 f9			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 a6 fd			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 a7 fd			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 a8 fd			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd aa fd			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a b0 f9			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 a6 fd			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 a7 fd			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 a8 fd			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd aa fd			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 a6 fd			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 a7 fd			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 a8 fd			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd aa fd			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 a6 fd			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 a7 fd			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 a8 fd			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd aa fd			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 a6 f9			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 a6 fd			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 a7 fd			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 a8 fd			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd aa fd			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 a6 fd			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 a7 fd			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 a8 fd			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd aa fd			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 a6 fd			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 a7 fd			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 a8 fd			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd aa fd			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 a6 fd			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 a7 fd			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 a8 fd			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd aa fd			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 a9 f9			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a a9 f9			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 a0 f9			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 a6 fd			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 a7 fd			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 a8 fd			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd aa fd			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 b5 f9			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 a6 fd			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 a7 fd			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 a8 fd			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd aa fd			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a b7 f9			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 b7 f9			ld (store_page+2), a 
0bcf 32 a8 f9			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 a6 fd			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 a7 fd			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 a8 fd			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd aa fd			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a a0 f9			ld hl, (store_tmppageid) 
0bf1 11 b5 f9			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 a0 f9				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 a6 fd			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 a7 fd			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 a8 fd			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd aa fd			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 b5 f9				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a a9 f9				ld a, (store_tmpid) 
0c37 32 b5 f9				ld (store_page), a   ; file id 
0c3a 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 b6 f9				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 b7 f9				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 a6 fd			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 a7 fd			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 a8 fd			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd aa fd			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a a0 f9			ld hl, (store_tmppageid) 
0c71 11 b5 f9			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 a6 fd			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 a7 fd			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 a8 fd			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd aa fd			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a a9 f9				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 b5 f9			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 b6 f9			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a 01 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 01 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 4a 26			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 02 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 02 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a 07 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ec fc				ld hl, display_fb0 
0d34 22 07 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd 93 22			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 4b fc				ld hl, display_fb1 
0d55 22 07 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a 07 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a 07 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a 07 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a 07 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a 07 fb			ld hl, (display_fb_active) 
0dc2 cd 4a 79			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 ae f9				ld (store_tmp1), hl 
0dcf 32 ac f9				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd 95 7c		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ec fc				ld hl, display_fb0 
0ddc 22 07 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 aa f9				ld (store_tmp3), a   ; display row count 
0dea 3a ac f9				ld a,( store_tmp2) 
0ded 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a ad f9				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b ae f9			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a aa f9				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a ad f9				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a aa f9				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 aa f9				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd 84 7c				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a ac f9				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 ac f9				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a ac f9				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 ac f9				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a ac f9				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 4b fc				ld hl, display_fb1 
0e99 22 07 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a e6 fa		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 e6 fa		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ec fa		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 ee fa		        ld hl,LFSRSeed+6 
0eec 11 ef fa		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a e0 fa		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 e0 fa		    ld (seed1),hl 
0f02 2a de fa		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 de fa		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 e4 fa		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored and edited directly 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc			EDIT_V1: equ 0 
0ffc			EDIT_V2: equ 1 
0ffc			 
0ffc			 
0ffc			 
0ffc			if EDIT_V2 
0ffc			input_str: 
0ffc			else 
0ffc			input_str_new: 
0ffc			endif 
0ffc			 
0ffc 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
0fff			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fff 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1002			;		ld a, c 
1002			;		call addatohl 
1002			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1002 7a					ld a,d 
1003 32 a1 fd			        ld (input_size), a       ; save length of input area 
1006 79					ld a, c 
1007 32 90 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
100a 7b					ld a,e 
100b 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
100e			 
100e			 
100e					; add a trailing space to make screen refresh nicer 
100e			 
100e					;ld hl, (input_start) 
100e					;push hl 
100e					;ld a, 0 
100e					;call strlent 
100e					;ld a, l 
100e					;pop hl 
100e					;call addatohl 
100e					;dec hl 
100e					;ld a, ' ' 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld a, 0 
100e					;ld (hl), a 
100e			 
100e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
100e					; init cursor shape if not set by the cin routines 
100e 21 fc fa				ld hl, cursor_shape 
1011			if BASE_KEV 
1011 3e ff				ld a, 255 
1013			else 
1013					ld a, '#' 
1013			endif 
1013 77					ld (hl), a 
1014 23					inc hl 
1015 3e 00				ld a, 0 
1017 77					ld (hl), a 
1018			 
1018 3e 09				ld a, CUR_BLINK_RATE 
101a 32 9b fd				ld (input_cur_flash), a 
101d 3e 01				ld a, 1 
101f 32 9a fd				ld (input_cur_onoff),a 
1022			.inmain:	 
1022			 
1022 cd 8e 11				call input_disp_ref 
1025			 
1025					; save current length of string 
1025			 
1025 2a a2 fd				ld hl, (input_start) 
1028 3e 00				ld a, 0 
102a cd 50 16				call strlent 
102d 7d					ld a,l 
102e 32 95 fd				ld (input_len), a 
1031			 
1031					;call input_disp_oncur 
1031			 
1031					; display current state of input buffer 
1031			 
1031					; clean any backspace chars 
1031			 
1031 3e 5f				ld a, "_" 
1033 32 fc f0				ld (scratch),a 
1036 3e 00				ld a, 0 
1038 32 fd f0				ld (scratch+1),a 
103b 3a 9f fd				ld a,(input_at_pos) 
103e 85					add l 
103f 11 fc f0				ld de, scratch 
1042 cd ae 0d				call str_at_display 
1045			 
1045					; pause 1ms 
1045			 
1045 3e 01				ld a, 1 
1047 cd c3 0c				call aDelayInMS 
104a			 
104a			; display cursor if visible on this cycle 
104a			 
104a					; dec flash counter 
104a 3a 9b fd				ld a, (input_cur_flash) 
104d 3d					dec a 
104e 32 9b fd				ld (input_cur_flash), a 
1051 fe 00				cp 0 
1053 20 0d				jr nz, .inochgstate 
1055			 
1055			 
1055					; reset on change of state 
1055 3e 09				ld a, CUR_BLINK_RATE 
1057 32 9b fd				ld (input_cur_flash), a 
105a			 
105a					; change state 
105a 3a 9a fd				ld a,(input_cur_onoff) 
105d ed 44				neg 
105f 32 9a fd				ld (input_cur_onoff),a 
1062			 
1062			 
1062			 
1062			 
1062					; TODO is cursor visible? 
1062					; TODO if so then over write the char at curspos pos with the cursor shape 
1062			 
1062								 
1062			 
1062			.inochgstate: 
1062 3a 9a fd				ld a,(input_cur_onoff) 
1065 fe ff				cp 255 
1067 28 0e				jr z, .skipcursor 
1069 3a 9f fd				ld a, (input_at_pos) 
106c 47					ld b, a 
106d 3a 90 fd				ld a, (input_cursor) 
1070 80					add b 
1071 11 fc fa				ld de, cursor_shape 
1074					 
1074 cd ae 0d				call str_at_display 
1077			 
1077			.skipcursor: 
1077				if DEBUG_INPUTV2 
1077			 
1077 3a 9f fd				ld a,(input_at_pos) 
107a 21 e8 fa				ld hl, LFSRSeed 
107d cd e8 14				call hexout 
1080 3a 90 fd				ld a, (input_cursor) 
1083 21 ea fa				ld hl, LFSRSeed+2 
1086 cd e8 14				call hexout 
1089 3a a1 fd				ld a,(input_size) 
108c 21 ec fa				ld hl, LFSRSeed+4 
108f cd e8 14				call hexout 
1092			 
1092 3a 9a fd				ld a,(input_cur_onoff) 
1095 21 ee fa				ld hl, LFSRSeed+6 
1098 cd e8 14				call hexout 
109b			 
109b 3a 9b fd				ld a,(input_cur_flash) 
109e 21 f0 fa				ld hl, LFSRSeed+8 
10a1 cd e8 14				call hexout 
10a4			 
10a4 3a 95 fd				ld a,(input_len) 
10a7 21 f2 fa				ld hl, LFSRSeed+10 
10aa cd e8 14				call hexout 
10ad 21 f4 fa				ld hl, LFSRSeed+12 
10b0 3e 00				ld a, 0 
10b2 77					ld (hl),a 
10b3 3e 78				ld a, display_row_4 
10b5 11 e8 fa				ld de, LFSRSeed 
10b8 cd ae 0d				call str_at_display 
10bb				endif 
10bb cd be 0d				call update_display 
10be			 
10be					; TODO keyboard processing 
10be			 
10be			if BASE_CPM 
10be					call cin_wait 
10be			else 
10be cd 95 7c				call cin    ; _wait 
10c1			endif 
10c1 fe 00				cp 0 
10c3 ca 22 10				jp z, .inmain 
10c6			 
10c6 fe 0b				cp KEY_LEFT    ; cursor left 
10c8 ca 80 11				jp z, input_left 
10cb				 
10cb fe 0c				cp KEY_RIGHT      ; cursor right 
10cd ca 87 11				jp z, input_right 
10d0			 
10d0 fe 0d				cp KEY_CR 
10d2 c8					ret z 
10d3			 
10d3 fe 08				cp KEY_BS 
10d5 ca f5 11				jp z, input_delchar 
10d8			 
10d8 fe 06				cp KEY_NEXTWORD 
10da ca 13 11				jp z, input_nxtword 
10dd			 
10dd fe 07				cp KEY_PREVWORD 
10df ca 3a 11				jp z, input_prvword 
10e2 fe 10				cp KEY_F1 
10e4 ca 3a 11				jp z, input_prvword 
10e7			.inskl: 
10e7 fe 0e				cp KEY_HOME    ; jump to start of line 
10e9 20 08				jr nz, .ikh 
10eb 3e 00				ld a, 0 
10ed 32 90 fd				ld (input_cursor), a 
10f0 ca 22 10				jp z, .inmain 
10f3			.ikh: 
10f3			 
10f3 fe 0f				cp KEY_END     ; jump to end of line 
10f5 20 09				jr nz, .ike 
10f7 3a 95 fd				ld a, (input_len) 
10fa 32 90 fd				ld (input_cursor),a 
10fd ca 22 10				jp z, .inmain 
1100			.ike: 
1100 fe 05			        cp KEY_UP      ; recall last command 
1102 20 0c				jr nz, .irec 
1104			; TODO next word 
1104			; TODO prev word 
1104			;  
1104			; 
1104 21 fc f0			ld hl, scratch 
1107 11 22 f5			ld de, os_last_cmd 
110a cd de 14			call strcpy 
110d ca 22 10				jp z, .inmain 
1110			.irec: 
1110			;		jr .instr1 
1110			 
1110			 
1110					; if no special key then insert as a char 
1110			 
1110 c3 c7 11				jp input_inschr 
1113			 
1113				 
1113			input_nxtword: 
1113				; jump to start next word after the cursor 
1113			 
1113			.insknwn:	 
1113 cd bd 11				call input_curptr	 
1116 7e					ld a,(hl)	 
1117 fe 00				cp 0 
1119 ca 22 10				jp z, .inmain    ; end of string 
111c			 
111c			; if we are on a word, then move off of it 
111c			 
111c fe 20				cp ' ' 
111e 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
1120 21 90 fd				ld hl, input_cursor 
1123 34					inc (hl) 
1124 18 ed				jr .insknwn 
1126			 
1126			.inspace: 
1126			 
1126 cd bd 11				call input_curptr	 
1129 7e					ld a,(hl)	 
112a fe 00				cp 0 
112c ca 22 10				jp z, .inmain    ; end of string 
112f			 
112f			; if we are on a word, then move off of it 
112f			 
112f fe 20				cp ' ' 
1131 c2 22 10				jp nz, .inmain     ; we are on non space so at next word 
1134 21 90 fd				ld hl, input_cursor 
1137 34					inc (hl) 
1138 18 ec				jr .inspace 
113a			 
113a			 
113a			 
113a			 
113a			input_prvword: 
113a				; jump to the start of previous word before the cursor 
113a			.inskpwn:	 
113a 3a 90 fd				ld a,(input_cursor) 
113d fe 00				cp 0 
113f ca 22 10				jp z, .inmain    ; start of string 
1142			 
1142			; if we are on a word, then move off of it 
1142			 
1142 cd bd 11				call input_curptr	 
1145 fe 20				cp ' ' 
1147 28 06				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
1149					;jp z, .inmain    ; start of string 
1149 21 90 fd				ld hl, input_cursor 
114c 35					dec (hl) 
114d 18 eb				jr .inskpwn 
114f			 
114f			.inspacep: 
114f			 
114f 3a 90 fd				ld a,(input_cursor) 
1152 fe 00				cp 0 
1154 ca 22 10				jp z, .inmain    ; start of string 
1157			 
1157			; if we are on a word, then move off of it 
1157			 
1157 cd bd 11				call input_curptr	 
115a fe 20				cp ' ' 
115c c2 65 11				jp nz, .incharp     ; we are on non space so at end of prev word 
115f 21 90 fd				ld hl, input_cursor 
1162 35					dec (hl) 
1163 18 ea				jr .inspacep 
1165			 
1165			 
1165			.incharp:	 
1165					; eat the word to get to the start 
1165 3a 90 fd				ld a,(input_cursor) 
1168 fe 00				cp 0 
116a ca 22 10				jp z, .inmain    ; start of string 
116d			 
116d			; if we are on a word, then move off of it 
116d			 
116d cd bd 11				call input_curptr	 
1170 fe 20				cp ' ' 
1172 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
1174 21 90 fd				ld hl, input_cursor 
1177 35					dec (hl) 
1178 18 eb				jr .incharp 
117a			.ipwordst: 
117a					; at space before the prev word so reposition over it 
117a 21 90 fd				ld hl, input_cursor 
117d 34					inc (hl) 
117e 18 ba				jr .inskpwn 
1180					 
1180			 
1180			 
1180			input_left: 
1180				; move cursor left 
1180 21 90 fd			ld hl, input_cursor 
1183 35				dec (hl) 
1184			;	cp 0 
1184			;	jp z, .inmain    ; ignore left as at the start of the string 
1184 c3 22 10			jp .inmain 
1187			 
1187			input_right: 
1187				; move cursor right 
1187				 
1187				;ld a, (input_size) 
1187				;ld b, a 
1187 21 90 fd			ld hl, input_cursor 
118a 34				inc (hl) 
118b				;dec b 
118b				;cp 0 
118b				;jp z, .inmain   ; ignore as at end of the string buffer 
118b				;ld a, b 
118b				;inc a 
118b				;ld (input_cursor), a 
118b c3 22 10			jp .inmain 
118e			 
118e			 
118e			 
118e			input_disp_ref: 
118e				; display the text from start of buffer (ie full refresh) 
118e 3a 9f fd			ld a, (input_at_pos) 
1191 2a a2 fd			ld hl,(input_start) 
1194 eb				ex de, hl 
1195 cd ae 0d			call str_at_display  
1198 c9				ret 
1199			input_disp_oncur: 
1199				; display the text from cursor position to end of buffer 
1199				; TODO position start of string at cursor position on screen 
1199				; TODO draw from that point on 
1199 3a 90 fd			ld a, (input_cursor) 
119c 47				ld b, a 
119d 3a 9f fd			ld a, (input_at_pos) 
11a0 80				add b 
11a1 48				ld c, b     ; save a 
11a2 78				ld a, b     ; inc string start for cursor 
11a3 2a a2 fd			ld hl,(input_start) 
11a6 cd cf 0f			call addatohl 
11a9 eb				ex de, hl 
11aa 79				ld a, c 
11ab cd ae 0d			call str_at_display  
11ae c9				ret 
11af			 
11af			input_nxtw: 
11af				; Find next word 
11af c9				ret 
11b0			 
11b0			input_prvw: 
11b0				; Find previous word 
11b0 c9				ret 
11b1			 
11b1			input_lenrem:   
11b1				; Calculate the length of string remaining from current cursor 
11b1				; position to end of buffer (exc null term) 
11b1				 
11b1 3a 90 fd			ld a, (input_cursor) 
11b4 4f				ld c, a 
11b5 3a a1 fd			ld a, (input_size) 
11b8 91				sub c 
11b9 06 00			ld b, 0 
11bb 0d				dec c 
11bc c9				ret	 
11bd			 
11bd			input_curptr: 
11bd				; calc address of the character under the cursor 
11bd				 
11bd 2a a2 fd			ld hl, (input_start) 
11c0 3a 90 fd			ld a, (input_cursor) 
11c3 cd cf 0f			call addatohl 
11c6 c9				ret 
11c7			 
11c7			input_inschr: 
11c7				; Insert char at cursor position 
11c7 f5				push af   ; save char 
11c8				;call input_lenrem    ; get bc length of remaining string 
11c8			 
11c8				 
11c8 cd bd 11			call input_curptr 
11cb			;	ld hl, (input_start) 
11cb			;	ld a, (input_cursor) 
11cb			;	call addatohl 
11cb				;push hl   ; save to come back to 
11cb			 
11cb				; shift everything up one to end of buffer 
11cb			 
11cb				;push hl 
11cb				;dec de 
11cb				;inc de 
11cb			;	ldir 
11cb				 
11cb				;pop hl 
11cb			 
11cb				; are we adding to the end of line? 
11cb			 
11cb 3a 90 fd			ld a, (input_cursor) 
11ce 47				ld b, a 
11cf 3a 95 fd			ld a, (input_len) 
11d2 b8				cp b 
11d3 20 09			jr nz, .insmid   ; no, insert in middle of text 
11d5			 
11d5				; tack on the end of the line 
11d5 f1				pop af 
11d6 77				ld (hl), a   ; save new char 
11d7 23				inc hl 
11d8 3e 00			ld a, 0 
11da 77				ld (hl), a 
11db c3 87 11			jp input_right 
11de				 
11de			.insmid: 
11de				; hl has insertion point so move everything up one to allow for insertion 
11de				;call input_shiftright 
11de f1				pop af 
11df			 
11df			.shufinsmid: 
11df 47				ld b, a     ; b contains new char, c prev char at this position  
11e0 7e				ld a, (hl) 
11e1			 
11e1 fe 00			cp 0    ; at end of string need to then dump new char and add term 
11e3 28 07			jr z, .endinsmid 
11e5 4f				ld c, a 
11e6 78				ld a, b 
11e7 77				ld (hl), a 
11e8 23				inc hl 
11e9 79				ld a, c 
11ea 18 f3			jr .shufinsmid 
11ec				 
11ec			 
11ec			 
11ec			 
11ec			.endinsmid: 
11ec 78				ld a, b 
11ed 77				ld (hl), a 
11ee 23				inc hl 
11ef 3e 00			ld a, 0 
11f1 77				ld (hl), a 
11f2			 
11f2			 
11f2			;	ld (hl), a   ; save new char 
11f2			 
11f2 c3 87 11			jp input_right 
11f5			 
11f5			;input_shiftright: 
11f5			;	; shift text right at cursor, hl has shift start 
11f5			;	push hl 
11f5			;	push de 
11f5			;	push bc 
11f5			; 
11f5			; 
11f5			;	; move to end of string past zero term 
11f5			;	ld hl,(input_start) 
11f5			;	ld a, (input_len) 
11f5			;	call addatohl 
11f5			;	inc hl 
11f5			;;	inc hl 
11f5			;;	inc hl 
11f5			;	ld a, 0 
11f5			;	ld (hl), a 
11f5			;;	dec hl 
11f5			;	 
11f5			;;	ld (hl), a 
11f5			;;	dec hl 
11f5			; 
11f5			;	push hl 
11f5			;	pop de 
11f5			;	inc de 
11f5			;	 
11f5			; 
11f5			;;	ld hl,(input_start) 
11f5			;;	ld a, (input_cursor) 
11f5			;;	call addatohl 
11f5			; 
11f5			; 
11f5			;	; calc how many bytes from cursor pos to end of string we need to shift 
11f5			;	call input_lenrem    ; get bc length of remaining string 
11f5			;	;ld a, (input_cursor) 
11f5			;	;ld c, a 
11f5			;	ld a, (input_len) 
11f5			;	cp 2 
11f5			;	jr z, .iskipzero	 
11f5			;	;sub c 
11f5			;	;inc a 
11f5			;	;ld c, a 
11f5			;	;ld b, 0 
11f5			;	inc c 
11f5			;	inc c 
11f5			;	; move data 
11f5			;	lddr 
11f5			;.iskipzero: 
11f5			; 
11f5			;	pop bc 
11f5			;	pop de 
11f5			;	pop hl 
11f5			;	ret	 
11f5			 
11f5			input_delchar: 
11f5				; Delete char at cursor position 
11f5 cd b1 11			call input_lenrem    ; get bc length of remaining string 
11f8 2a a2 fd			ld hl, (input_start) 
11fb 3a 90 fd			ld a, (input_cursor) 
11fe cd cf 0f			call addatohl 
1201			 
1201 e5				push hl 
1202 d1				pop de 
1203 1b				dec de 
1204			 
1204			.dl:	 
1204 ed a0			ldi  
1206 7e				ld a, (hl) 
1207 fe 00			cp 0 
1209 28 02			jr z, .dldone 
120b 18 f7			jr .dl 
120d			.dldone: 
120d ed a0			ldi 
120f			 
120f c3 80 11			jp input_left 
1212			 
1212			 
1212			 
1212			 
1212			 
1212			if EDIT_V1 
1212			input_str: 
1212			else 
1212			input_str_old: 
1212			endif 
1212			 
1212 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
1215 81					add c 
1216 32 9d fd				ld (input_at_cursor),a	; save draw pos of cursor 
1219 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
121c 79					ld a, c 
121d cd cf 0f				call addatohl 
1220 22 a4 fd				ld (input_ptr), hl     ; save ptr to point under the cursor 
1223 7a					ld a,d 
1224 32 a1 fd			        ld (input_size), a       ; save length of input area 
1227 79					ld a, c 
1228 32 90 fd				ld (input_cursor),a      ; init cursor start position  
122b 7b					ld a,e 
122c 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
122f					 
122f					 
122f			 
122f			;		ld a,(input_ptr) 
122f			;		ld (input_under_cursor),a 	; save what is under the cursor 
122f			 
122f			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
122f					; init cursor shape if not set by the cin routines 
122f 21 fc fa				ld hl, cursor_shape 
1232			if BASE_KEV 
1232 3e ff				ld a, 255 
1234			else 
1234					ld a, '#' 
1234			endif 
1234 77					ld (hl), a 
1235 23					inc hl 
1236 3e 00				ld a, 0 
1238 77					ld (hl), a 
1239			 
1239 3e 09				ld a, CUR_BLINK_RATE 
123b 32 9b fd				ld (input_cur_flash), a 
123e 3e 01				ld a, 1 
1240 32 9a fd				ld (input_cur_onoff),a 
1243			 
1243			;	if DEBUG_INPUT 
1243			;		push af 
1243			;		ld a, 'I' 
1243			;		ld (debug_mark),a 
1243			;		pop af 
1243			;		CALLMONITOR 
1243			;	endif 
1243			.is1:		; main entry loop 
1243			 
1243			 
1243			 
1243					; pause 1ms 
1243			 
1243 3e 01				ld a, 1 
1245 cd c3 0c				call aDelayInMS 
1248			 
1248					; dec flash counter 
1248 3a 9b fd				ld a, (input_cur_flash) 
124b 3d					dec a 
124c 32 9b fd				ld (input_cur_flash), a 
124f fe 00				cp 0 
1251 20 0d				jr nz, .nochgstate 
1253			 
1253			 
1253					; change state 
1253 3a 9a fd				ld a,(input_cur_onoff) 
1256 ed 44				neg 
1258 32 9a fd				ld (input_cur_onoff),a 
125b			 
125b			 
125b					; reset on change of state 
125b 3e 09				ld a, CUR_BLINK_RATE 
125d 32 9b fd				ld (input_cur_flash), a 
1260			 
1260			.nochgstate: 
1260					 
1260					 
1260			 
1260					; display cursor  
1260			 
1260			;		ld hl, (input_start) 
1260			;		ld a, (input_cursor) 
1260			;		call addatohl 
1260			 
1260					; get char under cursor and replace with cursor 
1260 2a a4 fd		ld hl, (input_ptr) 
1263			;		ld a, (hl) 
1263			;		ld (input_under_cursor),a 
1263			;		ld a, '_' 
1263			;		ld (hl), a 
1263			 
1263					; display string 
1263			 
1263 ed 5b a2 fd			ld de, (input_start) 
1267 3a 9f fd				ld a, (input_at_pos) 
126a cd ae 0d				call str_at_display 
126d			;	        call update_display 
126d			 
126d					; find place to put the cursor 
126d			;		add h 
126d			;		ld l, display_row_1 
126d			;		sub l 
126d			; (input_at_pos) 
126d					;ld c, a 
126d			;		ld a, (input_cursor) 
126d			;		ld l, (input_at_pos) 
126d			;		;ld b, h 
126d			;		add l 
126d			;		ld (input_at_cursor),a 
126d					;ld l,h 
126d			 
126d			;		ld h, 0 
126d			;		ld l,(input_at_pos) 
126d			;		ld a, (input_cursor) 
126d			;		call addatohl 
126d			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
126d			;		call subafromhl 
126d			;		ld a,l 
126d			;		ld (input_at_cursor), a 
126d			 
126d				if DEBUG_INPUT 
126d					ld a, (hardware_diag) 
126d					cp 0 
126d					jr z, .skip_input_diag 
126d			 
126d					ld a,(input_at_pos) 
126d					ld hl, LFSRSeed 
126d					call hexout 
126d					ld a, (input_cursor) 
126d					ld hl, LFSRSeed+2 
126d					call hexout 
126d					ld a,(input_at_cursor) 
126d					ld hl, LFSRSeed+4 
126d					call hexout 
126d			 
126d					ld a,(input_cur_onoff) 
126d					ld hl, LFSRSeed+6 
126d					call hexout 
126d			 
126d					ld a,(input_cur_flash) 
126d					ld hl, LFSRSeed+8 
126d					call hexout 
126d			 
126d					ld a,(input_len) 
126d					ld hl, LFSRSeed+10 
126d					call hexout 
126d					ld hl, LFSRSeed+12 
126d					ld a, 0 
126d					ld (hl),a 
126d					ld a, display_row_4 
126d					ld de, LFSRSeed 
126d					call str_at_display 
126d					.skip_input_diag: 
126d				endif 
126d			 
126d					; decide on if we are showing the cursor this time round 
126d			 
126d 3a 9a fd				ld a, (input_cur_onoff) 
1270 fe ff				cp 255 
1272 28 15				jr z, .skipcur 
1274			 
1274			 
1274 3a 9d fd				ld a,(input_at_cursor) 
1277 11 fc fa				ld de, cursor_shape 
127a cd ae 0d				call str_at_display 
127d			 
127d					; save length of current input string 
127d 2a a2 fd				ld hl, (input_start) 
1280 3e 00				ld a, 0 
1282 cd 50 16				call strlent 
1285 7d					ld a,l 
1286 32 95 fd				ld (input_len),a 
1289			 
1289			.skipcur: 
1289			 
1289 cd be 0d			        call update_display 
128c					 
128c			 
128c			 
128c					; wait 
128c				 
128c					; TODO loop without wait to flash the cursor and char under cursor	 
128c cd 95 7c				call cin    ; _wait 
128f			 
128f fe 00				cp 0 
1291 ca 43 12				jp z, .is1 
1294			 
1294					; get ptr to char to input into 
1294			 
1294 4f					ld c,a 
1295 2a a2 fd				ld hl, (input_start) 
1298 3a 90 fd				ld a, (input_cursor) 
129b cd cf 0f				call addatohl 
129e 22 a4 fd				ld (input_ptr), hl 
12a1 79					ld a,c 
12a2			 
12a2					; replace char under cursor 
12a2			 
12a2			;		ld hl, (input_ptr) 
12a2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
12a2			;		ld (hl), a 
12a2			 
12a2			;	if DEBUG_INPUT 
12a2			;		push af 
12a2			;		ld a, 'i' 
12a2			;		ld (debug_mark),a 
12a2			;		pop af 
12a2			;		CALLMONITOR 
12a2			;	endif 
12a2 fe 0e				cp KEY_HOME 
12a4 20 0e				jr nz, .iske 
12a6			 
12a6 3a 9f fd				ld a, (input_at_pos) 
12a9 32 9d fd				ld (input_at_cursor),a 
12ac 3e 00				ld a, 0 
12ae 32 90 fd				ld (input_cursor), a 
12b1 c3 43 12				jp .is1 
12b4					 
12b4 fe 0f		.iske:		cp KEY_END 
12b6 20 03				jr nz, .isknw 
12b8 c3 43 12				jp .is1 
12bb			 
12bb fe 06		.isknw:		cp KEY_NEXTWORD 
12bd 20 1b				jr nz, .iskpw 
12bf			 
12bf 2a a4 fd		.isknwm:	ld hl, (input_ptr) 
12c2 7e					ld a,(hl)	 
12c3 fe 00				cp 0 
12c5 ca 43 12				jp z, .is1    ; end of string 
12c8 fe 20				cp ' ' 
12ca ca 43 12				jp z, .is1    ; end of word 
12cd 23					inc hl 
12ce 22 a4 fd				ld (input_ptr), hl 
12d1 3a 9d fd				ld a, (input_at_cursor) 
12d4 3c					inc a 
12d5 32 9d fd				ld (input_at_cursor), a 
12d8 18 e5				jr .isknwm 
12da			 
12da fe 07		.iskpw:		cp KEY_PREVWORD 
12dc 20 1b				jr nz, .iskl 
12de			.iskpwm:	 
12de 2a a4 fd				ld hl, (input_ptr) 
12e1 7e					ld a,(hl)	 
12e2 fe 00				cp 0  
12e4 ca 43 12				jp z, .is1    ; end of string 
12e7 fe 20				cp ' ' 
12e9 ca 43 12				jp z, .is1    ; end of word 
12ec 2b					dec hl 
12ed 22 a4 fd				ld (input_ptr), hl 
12f0 3a 9d fd				ld a, (input_at_cursor) 
12f3 3d					dec a 
12f4 32 9d fd				ld (input_at_cursor), a 
12f7 18 e5				jr .iskpwm 
12f9			 
12f9			 
12f9 fe 0b		.iskl:		cp KEY_LEFT 
12fb 20 27				jr nz, .isk1 
12fd			 
12fd 3a 90 fd				ld a, (input_cursor) 
1300			 
1300 fe 00				cp 0 
1302 ca 43 12				jp z, .is1 		; at start of line to ignore  
1305			 
1305 3d					dec  a 		; TODO check underflow 
1306 32 90 fd				ld (input_cursor), a 
1309			 
1309 2a a4 fd				ld hl, (input_ptr) 
130c 2b					dec hl 
130d 22 a4 fd				ld (input_ptr), hl 
1310					 
1310 3a 9d fd				ld a, (input_at_cursor) 
1313 3d					dec a 
1314 32 9d fd				ld (input_at_cursor), a 
1317			 
1317 3e 01				ld a, 1		; show cursor moving 
1319 32 9a fd				ld (input_cur_onoff),a 
131c 3e 09				ld a, CUR_BLINK_RATE 
131e 32 9b fd				ld (input_cur_flash), a 
1321			 
1321 c3 43 12				jp .is1 
1324			 
1324 fe 0c		.isk1:		cp KEY_RIGHT 
1326 20 2a				jr nz, .isk2 
1328			 
1328 3a 95 fd				ld a,(input_len)		; TODO BUG why cant i load e direct? 
132b 5f					ld e,a 
132c 3a 90 fd				ld a, (input_cursor) 
132f bb					cp e 
1330 ca 43 12				jp z, .is1		; at the end of string so dont go right 
1333			 
1333 3c					inc  a 		; TODO check overflow 
1334 32 90 fd				ld (input_cursor), a 
1337			 
1337 3a 9d fd				ld a, (input_at_cursor) 
133a 3c					inc a 
133b 32 9d fd				ld (input_at_cursor), a 
133e			 
133e 2a a4 fd				ld hl, (input_ptr) 
1341 23					inc hl 
1342 22 a4 fd				ld (input_ptr), hl 
1345			 
1345 3e 01				ld a, 1		; show cursor moving 
1347 32 9a fd				ld (input_cur_onoff),a 
134a 3e 09				ld a, CUR_BLINK_RATE 
134c 32 9b fd				ld (input_cur_flash), a 
134f			 
134f c3 43 12				jp .is1 
1352			 
1352 fe 05		.isk2:		cp KEY_UP 
1354			 
1354 20 26				jr nz, .isk3 
1356			 
1356					; swap last command with the current on 
1356			 
1356					; move cursor to start of string 
1356 2a a2 fd				ld hl, (input_start) 
1359 22 a4 fd				ld (input_ptr), hl 
135c			 
135c 3a 9f fd				ld a, (input_at_pos) 
135f 32 9d fd				ld (input_at_cursor), a 
1362			 
1362 3e 00				ld a, 0 
1364 32 90 fd				ld (input_cursor), a 
1367					 
1367					; swap input and last command buffers 
1367			 
1367 21 23 f4				ld hl, os_cli_cmd 
136a 11 22 f5				ld de, os_last_cmd 
136d 06 ff				ld b, 255 
136f 7e			.swap1:		ld a, (hl) 
1370 4f					ld c,a 
1371 1a					ld a, (de) 
1372 77					ld (hl), a 
1373 79					ld a,c 
1374 12					ld (de),a 
1375 23					inc hl 
1376 13					inc de 
1377 10 f6				djnz .swap1 
1379			 
1379			 
1379			 
1379			 
1379			 
1379 c3 43 12				jp .is1 
137c			 
137c fe 08		.isk3:		cp KEY_BS 
137e 20 3c				jr nz, .isk4 
1380			 
1380 3a 90 fd				ld a, (input_cursor) 
1383			 
1383 fe 00				cp 0 
1385 ca 43 12				jp z, .is1 		; at start of line to ignore  
1388			 
1388 3d					dec  a 		; TODO check underflow 
1389 32 90 fd				ld (input_cursor), a 
138c			 
138c					; hl is source 
138c					; de needs to be source - 1 
138c			 
138c			;		ld a, 0 
138c			;		dec hl 
138c			;		ld (hl), a 
138c			 
138c 2a a4 fd				ld hl, (input_ptr) 
138f 2b					dec hl 
1390 22 a4 fd				ld (input_ptr), hl 
1393			 
1393					; shift all data 
1393			 
1393 e5					push hl 
1394 23					inc hl 
1395 d1					pop de 
1396 3a 95 fd				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1399 4f					ld c,a 
139a 06 00				ld b,0 
139c ed b0				ldir  
139e			 
139e			 
139e			 
139e			 
139e 3a 9d fd				ld a, (input_at_cursor) 
13a1 3d					dec a 
13a2 32 9d fd				ld (input_at_cursor), a 
13a5			 
13a5			 
13a5 3e 01				ld a, 1		; show cursor moving 
13a7 32 9a fd				ld (input_cur_onoff),a 
13aa 3e 09				ld a, CUR_BLINK_RATE 
13ac 32 9b fd				ld (input_cur_flash), a 
13af			 
13af					; remove char 
13af 3a 9d fd				ld a, (input_at_cursor) 
13b2 3c					inc a 
13b3 11 3d 14				ld de,.iblank 
13b6 cd ae 0d				call str_at_display 
13b9			 
13b9 c3 43 12				jp .is1 
13bc			 
13bc fe 0d		.isk4:		cp KEY_CR 
13be 28 6c				jr z, .endinput 
13c0			 
13c0					; else add the key press to the end 
13c0			 
13c0 4f					ld c, a			; save key pressed 
13c1			 
13c1 7e					ld a,(hl)		; get what is currently under char 
13c2			 
13c2 fe 00				cp 0			; we are at the end of the string 
13c4 20 2f				jr nz, .onchar 
13c6					 
13c6					; add a char to the end of the string 
13c6				 
13c6 71					ld (hl),c 
13c7 23					inc hl 
13c8			;		ld a,' ' 
13c8			;		ld (hl),a 
13c8			;		inc hl 
13c8 3e 00				ld a,0 
13ca 77					ld (hl),a 
13cb 2b					dec hl 
13cc			 
13cc 3a 90 fd				ld a, (input_cursor) 
13cf 3c					inc a				; TODO check max string length and scroll  
13d0 32 90 fd				ld (input_cursor), a		; inc cursor pos 
13d3							 
13d3 3a 9d fd				ld a, (input_at_cursor) 
13d6 3c					inc a 
13d7 32 9d fd				ld (input_at_cursor), a 
13da			 
13da 2a a4 fd				ld hl, (input_ptr) 
13dd 23					inc hl 
13de 22 a4 fd				ld (input_ptr), hl 
13e1			 
13e1 2a a4 fd				ld hl, (input_ptr) 
13e4 23					inc hl 
13e5 22 a4 fd				ld (input_ptr), hl 
13e8			;	if DEBUG_INPUT 
13e8			;		push af 
13e8			;		ld a, '+' 
13e8			;		ld (debug_mark),a 
13e8			;		pop af 
13e8			;		CALLMONITOR 
13e8			;	endif 
13e8 3e 01				ld a, 1		; show cursor moving 
13ea 32 9a fd				ld (input_cur_onoff),a 
13ed 3e 09				ld a, CUR_BLINK_RATE 
13ef 32 9b fd				ld (input_cur_flash), a 
13f2 c3 43 12				jp .is1 
13f5					 
13f5			 
13f5			 
13f5					; if on a char then insert 
13f5			.onchar: 
13f5			 
13f5					; TODO over flow check: make sure insert does not blow out buffer 
13f5			 
13f5					; need to do some maths to use lddr 
13f5			 
13f5 e5					push hl   ; save char pos 
13f6 c5					push bc 
13f7			 
13f7 2a a2 fd				ld hl, (input_start) 
13fa 3a 95 fd				ld a, (input_len) 
13fd cd cf 0f				call addatohl  		; end of string 
1400 23					inc hl 
1401 23					inc hl		; past zero term 
1402 e5					push hl 
1403 23					inc hl 
1404 e5					push hl  
1405			 
1405								; start and end of lddr set, now how much to move? 
1405			 
1405							 
1405 3a 90 fd				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1408 47					ld b,a 
1409 3a 95 fd				ld a,(input_len) 
140c 5f					ld e,a 
140d 90					sub b 
140e 3c					inc a		;?? 
140f 3c					inc a		;?? 
1410 3c					inc a		;?? 
1411			 
1411 06 00				ld b,0 
1413 4f					ld c,a 
1414			 
1414				if DEBUG_INPUT 
1414					push af 
1414					ld a, 'i' 
1414					ld (debug_mark),a 
1414					pop af 
1414			;		CALLMONITOR 
1414				endif 
1414 d1					pop de 
1415 e1					pop hl 
1416				if DEBUG_INPUT 
1416					push af 
1416					ld a, 'I' 
1416					ld (debug_mark),a 
1416					pop af 
1416			;		CALLMONITOR 
1416				endif 
1416 ed b8				lddr 
1418				 
1418			 
1418			 
1418					; TODO have a key for insert/overwrite mode???? 
1418 c1					pop bc 
1419 e1					pop hl 
141a 71					ld (hl), c		; otherwise overwrite current char 
141b					 
141b			 
141b			 
141b			 
141b 3a 90 fd				ld a, (input_cursor) 
141e 3c					inc  a 		; TODO check overflow 
141f 32 90 fd				ld (input_cursor), a 
1422			 
1422 3a 9d fd				ld a, (input_at_cursor) 
1425 3c					inc a 
1426 32 9d fd				ld (input_at_cursor), a 
1429			 
1429 c3 43 12				jp .is1 
142c			 
142c			.endinput:	; TODO look for end of string 
142c			 
142c					; add trailing space for end of token 
142c			 
142c 2a a2 fd				ld hl, (input_start) 
142f 3a 95 fd				ld a,(input_len) 
1432 cd cf 0f				call addatohl 
1435 3e 20				ld a, ' ' 
1437 77					ld (hl),a 
1438					; TODO eof of parse marker 
1438			 
1438 23					inc hl 
1439 3e 00				ld a, 0 
143b 77					ld (hl),a 
143c			 
143c			 
143c c9					ret 
143d			 
143d .. 00		.iblank: db " ",0 
143f			 
143f			 
143f 32 9f fd		input_str_prev:	ld (input_at_pos), a 
1442 22 a2 fd				ld (input_start), hl 
1445 3e 01				ld a,1			; add cursor 
1447 77					ld (hl),a 
1448 23					inc hl 
1449 3e 00				ld a,0 
144b 77					ld (hl),a 
144c 22 a4 fd				ld (input_ptr), hl 
144f 7a					ld a,d 
1450 32 a1 fd				ld (input_size), a 
1453 3e 00				ld a,0 
1455 32 90 fd				ld (input_cursor),a 
1458			.instr1:	 
1458			 
1458					; TODO do block cursor 
1458					; TODO switch cursor depending on the modifer key 
1458			 
1458					; update cursor shape change on key hold 
1458			 
1458 2a a4 fd				ld hl, (input_ptr) 
145b 2b					dec hl 
145c 3a fc fa				ld a,(cursor_shape) 
145f 77					ld (hl), a 
1460			 
1460					; display entered text 
1460 3a 9f fd				ld a,(input_at_pos) 
1463 cd 59 7a		            	CALL fLCD_Pos       ;Position cursor to location in A 
1466 ed 5b a2 fd	            	LD   de, (input_start) 
146a cd 7b 7a		            	CALL fLCD_Str       ;Display string pointed to by DE 
146d			 
146d cd 95 7c				call cin 
1470 fe 00				cp 0 
1472 28 e4				jr z, .instr1 
1474			 
1474					; proecess keyboard controls first 
1474			 
1474 2a a4 fd				ld hl,(input_ptr) 
1477			 
1477 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1479 28 5a				jr z, .instrcr 
147b			 
147b fe 08				cp KEY_BS 	; back space 
147d 20 0f				jr nz, .instr2 
147f					; process back space 
147f			 
147f					; TODO stop back space if at start of string 
147f 2b					dec hl 
1480 2b					dec hl ; to over write cursor 
1481 3a fc fa				ld a,(cursor_shape) 
1484					;ld a,0 
1484 77					ld (hl),a 
1485 23					inc hl 
1486 3e 20				ld a," " 
1488 77					ld (hl),a 
1489 22 a4 fd				ld (input_ptr),hl 
148c					 
148c			 
148c 18 ca				jr .instr1 
148e			 
148e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1490 20 06				jr nz, .instr3 
1492 2b					dec hl 
1493 22 a4 fd				ld (input_ptr),hl 
1496 18 c0				jr .instr1 
1498				 
1498 fe 0c		.instr3:	cp KEY_RIGHT      ; cursor right 
149a 20 06				jr nz, .instr4 
149c 23					inc hl 
149d 22 a4 fd				ld (input_ptr),hl 
14a0 18 b6				jr .instr1 
14a2			 
14a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
14a4 20 06				jr nz, .instr5 
14a6 2b					dec hl 
14a7 22 a4 fd				ld (input_ptr),hl 
14aa 18 ac				jr .instr1 
14ac			 
14ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
14ae 20 06				jr nz, .instr6 
14b0 2b					dec hl 
14b1 22 a4 fd				ld (input_ptr),hl 
14b4 18 a2				jr .instr1 
14b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
14b8 20 0b				jr nz, .instrnew 
14ba			 
14ba 21 fc f0			ld hl, scratch 
14bd 11 22 f5			ld de, os_last_cmd 
14c0 cd de 14			call strcpy 
14c3 18 93				jr .instr1 
14c5			 
14c5			 
14c5			.instrnew:	; no special key pressed to see if we have room to store it 
14c5			 
14c5					; TODO do string size test 
14c5			 
14c5 2b					dec hl ; to over write cursor 
14c6 77					ld (hl),a 
14c7 23					inc hl 
14c8 3a fc fa				ld a,(cursor_shape) 
14cb 77					ld (hl),a 
14cc 23					inc hl 
14cd 3e 00				ld a,0 
14cf 77					ld (hl),a 
14d0			 
14d0 22 a4 fd				ld (input_ptr),hl 
14d3					 
14d3 18 83				jr .instr1 
14d5 2b			.instrcr:	dec hl		; remove cursor 
14d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
14d8 77					ld (hl),a 
14d9 23					inc hl 
14da 3e 00				ld a,0 
14dc 77					ld (hl),a 
14dd			 
14dd			 
14dd					; if at end of line scroll up    
14dd					; TODO detecting only end of line 4 for scroll up  
14dd			 
14dd					;ld   
14dd			 
14dd c9					ret 
14de			 
14de			 
14de			; strcpy hl = dest, de source 
14de			 
14de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
14df b7			            OR   A              ;Null terminator? 
14e0 c8			            RET  Z              ;Yes, so finished 
14e1 1a					ld a,(de) 
14e2 77					ld (hl),a 
14e3 13			            INC  DE             ;Point to next character 
14e4 23					inc hl 
14e5 18 f7		            JR   strcpy       ;Repeat 
14e7 c9					ret 
14e8			 
14e8			 
14e8			; TODO string_at  
14e8			; pass string which starts with lcd offset address and then null term string 
14e8			 
14e8			; TODO string to dec 
14e8			; TODO string to hex 
14e8			; TODO byte to string hex 
14e8			; TODO byte to string dec 
14e8			 
14e8			 
14e8			 
14e8			; from z80uartmonitor 
14e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
14e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
14e8			; pass hl for where to put the text 
14e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
14e8 c5			hexout:	PUSH BC 
14e9 f5					PUSH AF 
14ea 47					LD B, A 
14eb					; Upper nybble 
14eb cb 3f				SRL A 
14ed cb 3f				SRL A 
14ef cb 3f				SRL A 
14f1 cb 3f				SRL A 
14f3 cd 03 15				CALL tohex 
14f6 77					ld (hl),a 
14f7 23					inc hl	 
14f8					 
14f8					; Lower nybble 
14f8 78					LD A, B 
14f9 e6 0f				AND 0FH 
14fb cd 03 15				CALL tohex 
14fe 77					ld (hl),a 
14ff 23					inc hl	 
1500					 
1500 f1					POP AF 
1501 c1					POP BC 
1502 c9					RET 
1503					 
1503			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1503			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1503			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1503			tohex: 
1503 e5					PUSH HL 
1504 d5					PUSH DE 
1505 16 00				LD D, 0 
1507 5f					LD E, A 
1508 21 10 15				LD HL, .DATA 
150b 19					ADD HL, DE 
150c 7e					LD A, (HL) 
150d d1					POP DE 
150e e1					POP HL 
150f c9					RET 
1510			 
1510			.DATA: 
1510 30					DEFB	30h	; 0 
1511 31					DEFB	31h	; 1 
1512 32					DEFB	32h	; 2 
1513 33					DEFB	33h	; 3 
1514 34					DEFB	34h	; 4 
1515 35					DEFB	35h	; 5 
1516 36					DEFB	36h	; 6 
1517 37					DEFB	37h	; 7 
1518 38					DEFB	38h	; 8 
1519 39					DEFB	39h	; 9 
151a 41					DEFB	41h	; A 
151b 42					DEFB	42h	; B 
151c 43					DEFB	43h	; C 
151d 44					DEFB	44h	; D 
151e 45					DEFB	45h	; E 
151f 46					DEFB	46h	; F 
1520			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1520			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1520			;;    subtract $30, if result > 9 then subtract $7 more 
1520			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1520			atohex: 
1520 d6 30				SUB $30 
1522 fe 0a				CP 10 
1524 f8					RET M		; If result negative it was 0-9 so we're done 
1525 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1527 c9					RET		 
1528			 
1528			 
1528			 
1528			 
1528			; Get 2 ASCII characters as hex byte from pointer in hl 
1528			 
1528			BYTERD: 
1528 16 00			LD	D,00h		;Set up 
152a cd 32 15			CALL	HEXCON		;Get byte and convert to hex 
152d 87				ADD	A,A		;First nibble so 
152e 87				ADD	A,A		;multiply by 16 
152f 87				ADD	A,A		; 
1530 87				ADD	A,A		; 
1531 57				LD	D,A		;Save hi nibble in D 
1532			HEXCON: 
1532 7e				ld a, (hl)		;Get next chr 
1533 23				inc hl 
1534 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1536 fe 0a			CP	00Ah		;Is it 0-9 ? 
1538 38 02			JR	C,NALPHA	;If so miss next bit 
153a d6 07			SUB	007h		;Else convert alpha 
153c			NALPHA: 
153c b2				OR	D		;Add hi nibble back 
153d c9				RET			; 
153e			 
153e			 
153e			; 
153e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
153e			; Since the routines get_byte and therefore get_nibble are called, only valid 
153e			; characters (0-9a-f) are accepted. 
153e			; 
153e			;get_word        push    af 
153e			;                call    get_byte        ; Get the upper byte 
153e			;                ld      h, a 
153e			;                call    get_byte        ; Get the lower byte 
153e			;                ld      l, a 
153e			;                pop     af 
153e			;                ret 
153e			; 
153e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
153e			; the routine get_nibble is used only valid characters are accepted - the  
153e			; input routine only accepts characters 0-9a-f. 
153e			; 
153e c5			get_byte:        push    bc              ; Save contents of B (and C) 
153f 7e					ld a,(hl) 
1540 23					inc hl 
1541 cd 66 15		                call    nibble2val      ; Get upper nibble 
1544 cb 07		                rlc     a 
1546 cb 07		                rlc     a 
1548 cb 07		                rlc     a 
154a cb 07		                rlc     a 
154c 47			                ld      b, a            ; Save upper four bits 
154d 7e					ld a,(hl) 
154e cd 66 15		                call    nibble2val      ; Get lower nibble 
1551 b0			                or      b               ; Combine both nibbles 
1552 c1			                pop     bc              ; Restore B (and C) 
1553 c9			                ret 
1554			; 
1554			; Get a hexadecimal digit from the serial line. This routine blocks until 
1554			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1554			; to the serial line interface. The lower 4 bits of A contain the value of  
1554			; that particular digit. 
1554			; 
1554			;get_nibble      ld a,(hl)           ; Read a character 
1554			;                call    to_upper        ; Convert to upper case 
1554			;                call    is_hex          ; Was it a hex digit? 
1554			;                jr      nc, get_nibble  ; No, get another character 
1554			 ;               call    nibble2val      ; Convert nibble to value 
1554			 ;               call    print_nibble 
1554			 ;               ret 
1554			; 
1554			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1554			; A valid hexadecimal digit is denoted by a set C flag. 
1554			; 
1554			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1554			;                ret     nc              ; Yes 
1554			;                cp      '0'             ; Less than '0'? 
1554			;                jr      nc, is_hex_1    ; No, continue 
1554			;                ccf                     ; Complement carry (i.e. clear it) 
1554			;                ret 
1554			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1554			;                ret     c               ; Yes 
1554			;                cp      'A'             ; Less than 'A'? 
1554			;                jr      nc, is_hex_2    ; No, continue 
1554			;                ccf                     ; Yes - clear carry and return 
1554			;                ret 
1554			;is_hex_2        scf                     ; Set carry 
1554			;                ret 
1554			; 
1554			; Convert a single character contained in A to upper case: 
1554			; 
1554 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1556 d8			                ret     c 
1557 fe 7b		                cp      'z' + 1         ; > 'z'? 
1559 d0			                ret     nc              ; Nothing to do, either 
155a e6 5f		                and     $5f             ; Convert to upper case 
155c c9			                ret 
155d			 
155d			 
155d			to_lower: 
155d			 
155d			   ; if char is in [A-Z] make it lower case 
155d			 
155d			   ; enter : a = char 
155d			   ; exit  : a = lower case char 
155d			   ; uses  : af 
155d			 
155d fe 41		   cp 'A' 
155f d8			   ret c 
1560			    
1560 fe 5b		   cp 'Z'+1 
1562 d0			   ret nc 
1563			    
1563 f6 20		   or $20 
1565 c9			   ret 
1566			 
1566			; 
1566			; Expects a hexadecimal digit (upper case!) in A and returns the 
1566			; corresponding value in A. 
1566			; 
1566 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1568 38 02		                jr      c, nibble2val_1 ; Yes 
156a d6 07		                sub     7               ; Adjust for A-F 
156c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
156e e6 0f		                and     $f              ; Only return lower 4 bits 
1570 c9			                ret 
1571			; 
1571			; Print_nibble prints a single hex nibble which is contained in the lower  
1571			; four bits of A: 
1571			; 
1571			;print_nibble    push    af              ; We won't destroy the contents of A 
1571			;                and     $f              ; Just in case... 
1571			;                add     a, '0'             ; If we have a digit we are done here. 
1571			;                cp      '9' + 1         ; Is the result > 9? 
1571			;                jr      c, print_nibble_1 
1571			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1571			;print_nibble_1  call    putc            ; Print the nibble and 
1571			;                pop     af              ; restore the original value of A 
1571			;                ret 
1571			;; 
1571			;; Send a CR/LF pair: 
1571			; 
1571			;crlf            push    af 
1571			;                ld      a, cr 
1571			;                call    putc 
1571			;                ld      a, lf 
1571			;                call    putc 
1571			;                pop     af 
1571			;                ret 
1571			; 
1571			; Print_word prints the four hex digits of a word to the serial line. The  
1571			; word is expected to be in HL. 
1571			; 
1571			;print_word      push    hl 
1571			;                push    af 
1571			;                ld      a, h 
1571			;                call    print_byte 
1571			;                ld      a, l 
1571			;                call    print_byte 
1571			;                pop     af 
1571			;                pop     hl 
1571			;                ret 
1571			; 
1571			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1571			; The byte to be printed is expected to be in A. 
1571			; 
1571			;print_byte      push    af              ; Save the contents of the registers 
1571			;                push    bc 
1571			;                ld      b, a 
1571			;                rrca 
1571			;                rrca 
1571			;                rrca 
1571			;                rrca 
1571			;                call    print_nibble    ; Print high nibble 
1571			;                ld      a, b 
1571			;                call    print_nibble    ; Print low nibble 
1571			;                pop     bc              ; Restore original register contents 
1571			;                pop     af 
1571			;                ret 
1571			 
1571			 
1571			 
1571			 
1571			 
1571			fourehexhl:  
1571 7e				ld a,(hl) 
1572 cd 20 15			call atohex 
1575 cb 3f				SRL A 
1577 cb 3f				SRL A 
1579 cb 3f				SRL A 
157b cb 3f				SRL A 
157d 47				ld b, a 
157e 23				inc hl 
157f 7e				ld a,(hl) 
1580 23				inc hl 
1581 cd 20 15			call atohex 
1584 80				add b 
1585 57				ld d,a 
1586 7e				ld a,(hl) 
1587 cd 20 15			call atohex 
158a cb 3f				SRL A 
158c cb 3f				SRL A 
158e cb 3f				SRL A 
1590 cb 3f				SRL A 
1592 47				ld b, a 
1593 23				inc hl 
1594 7e				ld a,(hl) 
1595 23				inc hl 
1596 cd 20 15			call atohex 
1599 80				add b 
159a 5f				ld e, a 
159b d5				push de 
159c e1				pop hl 
159d c9				ret 
159e			 
159e			; pass hl. returns z set if the byte at hl is a digit 
159e			;isdigithl:  
159e			;	push bc 
159e			;	ld a,(hl) 
159e			;	cp ':' 
159e			;	jr nc, .isdf 		; > 
159e			;	cp '0' 
159e			;	jr c, .isdf		; < 
159e			; 
159e			;	; TODO find a better way to set z 
159e			; 
159e			;	ld b,a 
159e			;	cp b 
159e			;	pop bc 
159e			;	ret 
159e			; 
159e			;.isdf:	; not digit so clear z 
159e			; 
159e			;	; TODO find a better way to unset z 
159e			; 
159e			;	ld b,a 
159e			;	inc b 
159e			;	cp b 
159e			; 
159e			;	pop bc 
159e			;	ret 
159e				 
159e				 
159e			 
159e			 
159e			; pass hl as the four byte address to load 
159e			 
159e			get_word_hl:  
159e e5				push hl 
159f cd 3e 15			call get_byte 
15a2				 
15a2 47				ld b, a 
15a3			 
15a3 e1				pop hl 
15a4 23				inc hl 
15a5 23				inc hl 
15a6			 
15a6			; TODO not able to handle a-f  
15a6 7e				ld a,(hl) 
15a7			;	;cp ':' 
15a7			;	cp 'g' 
15a7			;	jr nc, .single_byte_hl 		; > 
15a7			;	cp 'G' 
15a7			;	jr nc, .single_byte_hl 		; > 
15a7			;	cp '0' 
15a7			;	jr c, .single_byte_hl		; < 
15a7			 
15a7				;call isdigithl 
15a7 fe 00			cp 0 
15a9 28 06			jr z, .single_byte_hl 
15ab			 
15ab			.getwhln:   ; hex word so get next byte 
15ab			 
15ab cd 3e 15			call get_byte 
15ae 6f				ld l, a 
15af 60				ld h,b 
15b0 c9				ret 
15b1 68			.single_byte_hl:   ld l,b 
15b2 26 00				ld h,0 
15b4 c9					ret 
15b5			 
15b5			 
15b5			 
15b5			 
15b5 21 0a 20			ld hl,asc+1 
15b8			;	ld a, (hl) 
15b8			;	call nibble2val 
15b8 cd 3e 15			call get_byte 
15bb			 
15bb			;	call fourehexhl 
15bb 32 30 f1			ld (scratch+52),a 
15be				 
15be 21 2e f1			ld hl,scratch+50 
15c1 22 1f f4			ld (os_cur_ptr),hl 
15c4			 
15c4 c9				ret 
15c5			 
15c5			 
15c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
15c5			 
15c5			; Decimal Unsigned Version 
15c5			 
15c5			;Number in a to decimal ASCII 
15c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
15c5			;Example: display a=56 as "056" 
15c5			;input: a = number 
15c5			;Output: a=0,value of a in the screen 
15c5			;destroys af,bc (don't know about hl and de) 
15c5			DispAToASCII: 
15c5 0e 9c			ld	c,-100 
15c7 cd d1 15			call	.Na1 
15ca 0e f6			ld	c,-10 
15cc cd d1 15			call	.Na1 
15cf 0e ff			ld	c,-1 
15d1 06 2f		.Na1:	ld	b,'0'-1 
15d3 04			.Na2:	inc	b 
15d4 81				add	a,c 
15d5 38 fc			jr	c,.Na2 
15d7 91				sub	c		;works as add 100/10/1 
15d8 f5				push af		;safer than ld c,a 
15d9 78				ld	a,b		;char is in b 
15da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
15da f1				pop af		;safer than ld a,c 
15db c9				ret 
15dc			 
15dc			; Decimal Signed Version 
15dc			 
15dc			; DispA 
15dc			; -------------------------------------------------------------- 
15dc			; Converts a signed integer value to a zero-terminated ASCII 
15dc			; string representative of that value (using radix 10). 
15dc			; -------------------------------------------------------------- 
15dc			; INPUTS: 
15dc			;     HL     Value to convert (two's complement integer). 
15dc			;     DE     Base address of string destination. (pointer). 
15dc			; -------------------------------------------------------------- 
15dc			; OUTPUTS: 
15dc			;     None 
15dc			; -------------------------------------------------------------- 
15dc			; REGISTERS/MEMORY DESTROYED 
15dc			; AF HL 
15dc			; -------------------------------------------------------------- 
15dc			 
15dc			;DispHLToASCII: 
15dc			;   push    de 
15dc			;   push    bc 
15dc			; 
15dc			;; Detect sign of HL. 
15dc			;    bit    7, h 
15dc			;    jr     z, ._DoConvert 
15dc			; 
15dc			;; HL is negative. Output '-' to string and negate HL. 
15dc			;    ld     a, '-' 
15dc			;    ld     (de), a 
15dc			;    inc    de 
15dc			; 
15dc			;; Negate HL (using two's complement) 
15dc			;    xor    a 
15dc			;    sub    l 
15dc			;    ld     l, a 
15dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
15dc			;    sbc    a, h 
15dc			;    ld     h, a 
15dc			; 
15dc			;; Convert HL to digit characters 
15dc			;._DoConvert: 
15dc			;    ld     b, 0     ; B will count character length of number 
15dc			;-   ld     a, 10 
15dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
15dc			;    push   af 
15dc			;    inc    b 
15dc			;    ld     a, h 
15dc			;    or     l 
15dc			;    jr     nz, - 
15dc			; 
15dc			;; Retrieve digits from stack 
15dc			;-   pop    af 
15dc			;    or     $30 
15dc			;    ld     (de), a 
15dc			;    inc    de 
15dc			;    djnz   - 
15dc			; 
15dc			;; Terminate string with NULL 
15dc			;    xor    a 
15dc			;    ld     (de), a 
15dc			; 
15dc			;    pop    bc 
15dc			;    pop    de 
15dc			;    ret 
15dc			 
15dc			;Comments 
15dc			; 
15dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
15dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
15dc			;    Note that the output string will not be fixed-width. 
15dc			; 
15dc			;Example Usage 
15dc			; 
15dc			;    ld    hl, -1004 
15dc			;    ld    de, OP1 
15dc			;    call  DispA 
15dc			;    ld    hl, OP1 
15dc			;    syscall  PutS 
15dc			 
15dc			 
15dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
15dc			 
15dc			 
15dc			;Converts an ASCII string to an unsigned 16-bit integer 
15dc			;Quits when it reaches a non-decimal digit 
15dc			 
15dc			string_to_uint16: 
15dc			atoui_16: 
15dc			;Input: 
15dc			;     DE points to the string 
15dc			;Outputs: 
15dc			;     HL is the result 
15dc			;     A is the 8-bit value of the number 
15dc			;     DE points to the byte after the number 
15dc			;Destroys: 
15dc			;     BC 
15dc			;       if the string is non-empty, BC is HL/10 
15dc			;Size:  24 bytes 
15dc			;Speed: 42+d(104+{0,9}) 
15dc			;       d is the number of digits in the number 
15dc			;       max is 640 cycles for a 5 digit number 
15dc			;Assuming no leading zeros: 
15dc			;1 digit:  146cc 
15dc			;2 digit:  250cc 
15dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
15dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
15dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
15dc			;avg: 544.81158447265625cc (544+13297/16384) 
15dc			;=============================================================== 
15dc 21 00 00		  ld hl,0 
15df			.u16a: 
15df 1a			  ld a,(de) 
15e0 d6 30		  sub 30h 
15e2 fe 0a		  cp 10 
15e4 d0			  ret nc 
15e5 13			  inc de 
15e6 44			  ld b,h 
15e7 4d			  ld c,l 
15e8 29			  add hl,hl 
15e9 29			  add hl,hl 
15ea 09			  add hl,bc 
15eb 29			  add hl,hl 
15ec 85			  add a,l 
15ed 6f			  ld l,a 
15ee 30 ef		  jr nc,.u16a 
15f0 24			  inc h 
15f1 c3 df 15		  jp .u16a 
15f4			 
15f4			 
15f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
15f4			 
15f4			;written by Zeda 
15f4			;Converts a 16-bit unsigned integer to an ASCII string. 
15f4			 
15f4			uitoa_16: 
15f4			;Input: 
15f4			;   DE is the number to convert 
15f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
15f4			;Output: 
15f4			;   HL points to the null-terminated ASCII string 
15f4			;      NOTE: This isn't necessarily the same as the input HL. 
15f4 d5			  push de 
15f5 c5			  push bc 
15f6 f5			  push af 
15f7 eb			  ex de,hl 
15f8			 
15f8 01 f0 d8		  ld bc,-10000 
15fb 3e 2f		  ld a,'0'-1 
15fd 3c			  inc a 
15fe 09			  add hl,bc  
15ff 38 fc		   jr c,$-2 
1601 12			  ld (de),a 
1602 13			  inc de 
1603			 
1603 01 e8 03		  ld bc,1000 
1606 3e 3a		  ld a,'9'+1 
1608 3d			  dec a  
1609 09			  add hl,bc  
160a 30 fc		   jr nc,$-2 
160c 12			  ld (de),a 
160d 13			  inc de 
160e			 
160e 01 9c ff		  ld bc,-100 
1611 3e 2f		  ld a,'0'-1 
1613 3c			  inc a  
1614 09			  add hl,bc  
1615 38 fc		   jr c,$-2 
1617 12			  ld (de),a 
1618 13			  inc de 
1619			 
1619 7d			  ld a,l 
161a 26 3a		  ld h,'9'+1 
161c 25			  dec h  
161d c6 0a		  add a,10  
161f 30 fb		   jr nc,$-3 
1621 c6 30		  add a,'0' 
1623 eb			  ex de,hl 
1624 72			  ld (hl),d 
1625 23			  inc hl 
1626 77			  ld (hl),a 
1627 23			  inc hl 
1628 36 00		  ld (hl),0 
162a			 
162a			;Now strip the leading zeros 
162a 0e fa		  ld c,-6 
162c 09			  add hl,bc 
162d 3e 30		  ld a,'0' 
162f 23			  inc hl  
1630 be			  cp (hl)  
1631 28 fc		  jr z,$-2 
1633			 
1633			;Make sure that the string is non-empty! 
1633 7e			  ld a,(hl) 
1634 b7			  or a 
1635 20 01		  jr nz,.atoub 
1637 2b			  dec hl 
1638			.atoub: 
1638			 
1638 f1			  pop af 
1639 c1			  pop bc 
163a d1			  pop de 
163b c9			  ret 
163c			 
163c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
163c			 
163c			toUpper: 
163c			;A is the char. 
163c			;If A is a lowercase letter, this sets it to the matching uppercase 
163c			;18cc or 30cc or 41cc 
163c			;avg: 26.75cc 
163c fe 61		  cp 'a' 
163e d8			  ret c 
163f fe 7b		  cp 'z'+1 
1641 d0			  ret nc 
1642 d6 20		  sub 'a'-'A' 
1644 c9			  ret 
1645			 
1645			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1645			 
1645			; String Length 
1645			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1645			 
1645			; Get the length of the null-terminated string starting at $8000 hl 
1645			;    LD     HL, $8000 
1645			 
1645			strlenz: 
1645			 
1645 af			    XOR    A               ; Zero is the value we are looking for. 
1646 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1647 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1648			                           ; 65, 536 bytes (the entire addressable memory space). 
1648 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
164a			 
164a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
164a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
164b 6f			    LD     L, A             ; number of bytes 
164c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
164e 2b			    DEC    HL              ; Compensate for null. 
164f c9				ret 
1650			 
1650			; Get the length of the A terminated string starting at $8000 hl 
1650			;    LD     HL, $8000 
1650			 
1650			strlent: 
1650			 
1650			                  ; A is the value we are looking for. 
1650 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1652 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1654			                           ; 65, 536 bytes (the entire addressable memory space). 
1654 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1656			 
1656			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1656 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1658 2e 00		    LD     L, 0             ; number of bytes 
165a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
165c 2b			    DEC    HL              ; Compensate for null. 
165d c9				ret 
165e			 
165e			 
165e			;Comparing Strings 
165e			 
165e			;IN    HL     Address of string1. 
165e			;      DE     Address of string2. 
165e			 
165e			; doc given but wrong??? 
165e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
165e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
165e			; tested 
165e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
165e			 
165e			strcmp_old: 
165e e5			    PUSH   HL 
165f d5			    PUSH   DE 
1660			 
1660 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1661 be			    CP     (HL)            ; (want to minimize work). 
1662 38 01		    JR     C, Str1IsBigger 
1664 7e			    LD     A, (HL) 
1665			 
1665			Str1IsBigger: 
1665 4f			    LD     C, A             ; Put length in BC 
1666 06 00		    LD     B, 0 
1668 13			    INC    DE              ; Increment pointers to meat of string. 
1669 23			    INC    HL 
166a			 
166a			CmpLoop: 
166a 1a			    LD     A, (DE)          ; Compare bytes. 
166b ed a1		    CPI 
166d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
166f 13			    INC    DE              ; Update pointer. 
1670 ea 6a 16		    JP     PE, CmpLoop 
1673			 
1673 d1			    POP    DE 
1674 e1			    POP    HL 
1675 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1676 be			    CP     (HL) 
1677 c9			    RET 
1678			 
1678			NoMatch: 
1678 2b			    DEC    HL 
1679 be			    CP     (HL)            ; Compare again to affect carry. 
167a d1			    POP    DE 
167b e1			    POP    HL 
167c c9			    RET 
167d			 
167d			;; test strmp 
167d			; 
167d			;ld de, .str1 
167d			;ld hl, .str2 
167d			;call strcmp 
167d			;jr z, .z1 
167d			;;this 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "NZ1" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			;.z1: 
167d			; 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "ZZ1" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			; 
167d			;ld de, .str1 
167d			;ld hl, .str1 
167d			;call strcmp 
167d			;jr z, .z2 
167d			;;this 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "NZ2" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			;.z2: 
167d			; 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "ZZ2" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			; 
167d			;ld de, .str1 
167d			;ld hl, .str2 
167d			;call strcmp 
167d			;jr c, .c1 
167d			; 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "Nc1" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			;.c1: 
167d			;;this 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "cc1" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			; 
167d			;ld de, .str1 
167d			;ld hl, .str1 
167d			;call strcmp 
167d			;jr c, .c2 
167d			;;this 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "Nc2" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			;.c2: 
167d			; 
167d			;	if DEBUG_FORTH_WORDS 
167d			;		DMARK "cc2" 
167d			;		CALLMONITOR 
167d			;	endif 
167d			;	NEXTW 
167d			;.str1:   db "string1",0 
167d			;.str2:   db "string2",0 
167d			 
167d			; only care about direct match or not 
167d			; hl and de strings 
167d			; zero set if the same 
167d			 
167d			strcmp: 
167d 1a				ld a, (de) 
167e be				cp (hl) 
167f 28 02			jr z, .ssame 
1681 b7				or a 
1682 c9				ret 
1683			 
1683			.ssame:  
1683 fe 00			cp 0 
1685 c8				ret z 
1686			 
1686 23				inc hl 
1687 13				inc de 
1688 18 f3			jr strcmp 
168a				 
168a				 
168a			 
168a			;Copyright (c) 2014, Luke Maurits 
168a			;All rights reserved. 
168a			; 
168a			;Redistribution and use in source and binary forms, with or without 
168a			;modification, are permitted provided that the following conditions are met: 
168a			; 
168a			;* Redistributions of source code must retain the above copyright notice, this 
168a			;  list of conditions and the following disclaimer. 
168a			; 
168a			;* Redistributions in binary form must reproduce the above copyright notice, 
168a			;  this list of conditions and the following disclaimer in the documentation 
168a			;  and/or other materials provided with the distribution. 
168a			; 
168a			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
168a			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
168a			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
168a			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
168a			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
168a			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
168a			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
168a			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
168a			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
168a			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
168a			 
168a			; https://github.com/lmaurits/lm512/blob/master/string.z80 
168a			 
168a			StrictStrCmp: 
168a				; Load next chars of each string 
168a 1a				ld a, (de) 
168b 47				ld b, a 
168c 7e				ld a, (hl) 
168d				; Compare 
168d b8				cp b 
168e				; Return non-zero if chars don't match 
168e c0				ret nz 
168f				; Check for end of both strings 
168f fe 00			cp "\0" 
1691				; Return if strings have ended 
1691 c8				ret z 
1692				; Otherwise, advance to next chars 
1692 23				inc hl 
1693 13				inc de 
1694 18 f4			jr StrictStrCmp 
1696			 
1696			;end 
1696			; eof 
1696			 
1696			 
1696			 
1696			 
1696			 
1696			 
# End of file firmware_strings.asm
1696			include "firmware_memory.asm"   ; malloc and free  
1696			 
1696			if DEBUG_FORTH_MALLOC_HIGH 
1696			.mallocsize: db "Wants malloc >256",0 
1696			.mallocasize: db "MALLOC gives >256",0 
1696			.malloczero: db "MALLOC gives zero",0 
1696			 
1696			malloc_guard_zerolen: 
1696				push hl 
1696				push de 
1696				push af 
1696			 
1696				ld de, 0 
1696			        call cmp16 
1696				jr nz, .lowalloz 
1696			 
1696				push hl 
1696				push de 
1696					ld hl, display_fb0 
1696					ld (display_fb_active), hl 
1696				call clear_display 
1696				ld a, 0 
1696				ld de, .malloczero 
1696				call str_at_display 
1696				call update_display 
1696				call delay1s 
1696				call delay1s 
1696				call bp_on 
1696			;	ld a, 0 
1696			;	ld (os_view_disable), a 
1696			 
1696				pop de 
1696				pop hl 
1696			 
1696				 
1696			 
1696				CALLMONITOR 
1696			.lowalloz: 
1696			 
1696			 
1696				pop af 
1696				pop de 
1696				pop hl 
1696			ret 
1696			 
1696			malloc_guard_entry: 
1696				push hl 
1696				push de 
1696				push af 
1696			 
1696			 	or a      ;clear carry flag 
1696				push hl 
1696				ld de, 255 
1696				sbc hl, de 
1696				jr c, .lowalloc 
1696			 
1696				push de 
1696					ld hl, display_fb0 
1696					ld (display_fb_active), hl 
1696				call clear_display 
1696				ld a, 0 
1696				ld de, .mallocsize 
1696				call str_at_display 
1696				call update_display 
1696				call delay1s 
1696				call delay1s 
1696			;	ld a, 0 
1696			;	ld (os_view_disable), a 
1696				call bp_on 
1696			 
1696				pop de 
1696				pop hl 
1696			 
1696				 
1696			 
1696				CALLMONITOR 
1696				jr .lowdone 
1696			.lowalloc: 
1696			 
1696			 
1696				pop hl 
1696			.lowdone:	pop af 
1696				pop de 
1696				pop hl 
1696			ret 
1696			 
1696			malloc_guard_exit: 
1696				push hl 
1696				push de 
1696				push af 
1696			 
1696			 	or a      ;clear carry flag 
1696				push hl 
1696				ld de, 255 
1696				sbc hl, de 
1696				jr c, .lowallocx 
1696			 
1696				push de 
1696					ld hl, display_fb0 
1696					ld (display_fb_active), hl 
1696				call clear_display 
1696				ld a, 0 
1696				ld de, .mallocasize 
1696				call str_at_display 
1696				call update_display 
1696				call delay1s 
1696				call delay1s 
1696			;	ld a, 0 
1696			;	ld (os_view_disable), a 
1696				call bp_on 
1696				pop de 
1696				pop hl 
1696			 
1696				CALLMONITOR 
1696				jr .lowdonex 
1696			.lowallocx: 
1696			 
1696				pop hl 
1696			.lowdonex:	pop af 
1696				pop de 
1696				pop hl 
1696			ret 
1696			endif 
1696			 
1696			if MALLOC_2 
1696			; Z80 Malloc and Free Functions 
1696			 
1696			; Malloc Function: 
1696			; Input: 
1696			;   HL: Size of block to allocate 
1696			; Output: 
1696			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1696			 
1696			malloc: 
1696				 
1696			if DEBUG_FORTH_MALLOC_HIGH 
1696			call malloc_guard_entry 
1696			endif 
1696			 
1696			 
1696			 
1696			 
1696					if DEBUG_FORTH_MALLOC 
1696						DMARK "mal" 
1696						CALLMONITOR 
1696					endif 
1696			    push af            ; Save AF register 
1696			    ld a, l            ; Load low byte of size into A 
1696			    or h               ; Check if size is zero 
1696			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1696			 
1696			    ; Allocate memory 
1696			    ld hl, (heap_start) ; Load start of heap into HL 
1696					if DEBUG_FORTH_MALLOC 
1696						DMARK "ma1" 
1696						CALLMONITOR 
1696					endif 
1696			    call malloc_internal ; Call internal malloc function 
1696			    pop af             ; Restore AF register 
1696			if DEBUG_FORTH_MALLOC_HIGH 
1696			call malloc_guard_exit 
1696			call malloc_guard_zerolen 
1696			endif 
1696			    ret                ; Return 
1696			 
1696			; Free Function: 
1696			; Input: 
1696			;   HL: Pointer to memory block to free 
1696			; Output: 
1696			;   None 
1696			 
1696			free: 
1696			    push af            ; Save AF register 
1696			    ld a, l            ; Load low byte of pointer into A 
1696			    or h               ; Check if pointer is NULL 
1696			    jp z, free_exit    ; If pointer is NULL, exit 
1696			 
1696			    ; Free memory 
1696			    ld hl, (heap_start) ; Load start of heap into HL 
1696			    call free_internal  ; Call internal free function 
1696			    pop af             ; Restore AF register 
1696			    ret                ; Return 
1696			 
1696			; Internal Malloc Function: 
1696			; Input: 
1696			;   HL: Size of block to allocate 
1696			; Output: 
1696			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1696			 
1696			malloc_internal: 
1696			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1696			    add hl, bc         ; Add management overhead to requested size 
1696			    ex de, hl          ; Save total size in DE, and keep it in HL 
1696					if DEBUG_FORTH_MALLOC 
1696						DMARK "ma2" 
1696						CALLMONITOR 
1696					endif 
1696			 
1696			    ; Search for free memory block 
1696			    ld de, (heap_end)  ; Load end of heap into DE 
1696			    ld bc, 0           ; Initialize counter 
1696			 
1696					if DEBUG_FORTH_MALLOC 
1696						DMARK "ma2" 
1696						CALLMONITOR 
1696					endif 
1696			malloc_search_loop: 
1696			    ; Check if current block is free 
1696			    ld a, (hl)         ; Load current block's status (free or used) 
1696			    cp 0               ; Compare with zero (free) 
1696			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1696			 
1696			    ; Check if current block is large enough 
1696			    ld a, (hl+1)       ; Load high byte of block size 
1696			    cp l               ; Compare with low byte of requested size 
1696			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1696			 
1696			    ld a, (hl+2)       ; Load low byte of block size 
1696			    cp h               ; Compare with high byte of requested size 
1696			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1696			 
1696			    ; Mark block as used 
1696			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1696			 
1696			    ; Calculate remaining space in block 
1696			    ld bc, 0           ; Clear BC 
1696			    add hl, bc         ; Increment HL to point to start of data block 
1696			    add hl, de         ; HL = HL + DE (total size) 
1696			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1696			    add hl, bc         ; Add management overhead to start of data block 
1696			 
1696			    ; Save pointer to allocated block in HL 
1696			if DEBUG_FORTH_MALLOC_HIGH 
1696						DMARK "ma5" 
1696			call malloc_guard_exit 
1696			call malloc_guard_zerolen 
1696			endif 
1696			    ret 
1696			 
1696			malloc_skip_block_check: 
1696			    ; Move to the next block 
1696			    ld bc, 3           ; Size of management overhead 
1696			    add hl, bc         ; Move to the next block 
1696			    inc de             ; Increment counter 
1696			 
1696			    ; Check if we have reached the end of heap 
1696			    ld a, e            ; Load low byte of heap end address 
1696			    cp (hl)            ; Compare with low byte of current address 
1696			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1696			    ld a, d            ; Load high byte of heap end address 
1696			    cp 0               ; Check if it's zero (end of memory) 
1696			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1696			 
1696			    ; If we reached here, allocation failed 
1696			    xor a              ; Set result to NULL 
1696			if DEBUG_FORTH_MALLOC_HIGH 
1696						DMARK "ma6" 
1696			call malloc_guard_exit 
1696			call malloc_guard_zerolen 
1696			endif 
1696			    ret 
1696			malloc_exit: 
1696			if DEBUG_FORTH_MALLOC_HIGH 
1696						DMARK "ma7" 
1696			call malloc_guard_exit 
1696			call malloc_guard_zerolen 
1696			endif 
1696			    ret 
1696			 
1696			; Internal Free Function: 
1696			; Input: 
1696			;   HL: Pointer to memory block to free 
1696			; Output: 
1696			;   None 
1696			 
1696			free_internal: 
1696			    ld de, (heap_start) ; Load start of heap into DE 
1696			    ld bc, 0            ; Initialize counter 
1696			 
1696			free_search_loop: 
1696			    ; Check if current block contains the pointer 
1696			    ld a, l             ; Load low byte of pointer 
1696			    cp (hl+1)           ; Compare with high byte of current block's address 
1696			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1696			    ld a, h             ; Load high byte of pointer 
1696			    cp (hl+2)           ; Compare with low byte of current block's address 
1696			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1696			 
1696			    ; Mark block as free 
1696			    ld (hl), 0          ; Set status byte to indicate free block 
1696			    ret                 ; Return 
1696			 
1696			free_skip_block_check: 
1696			    ; Move to the next block 
1696			    ld bc, 3            ; Size of management overhead 
1696			    add hl, bc          ; Move to the next block 
1696			    inc de              ; Increment counter 
1696			 
1696			    ; Check if we have reached the end of heap 
1696			    ld a, e             ; Load low byte of heap end address 
1696			    cp (hl)             ; Compare with low byte of current address 
1696			    jr nz, free_search_loop  ; If not equal, continue searching 
1696			    ld a, d             ; Load high byte of heap end address 
1696			    cp 0                ; Check if it's zero (end of memory) 
1696			    jr nz, free_search_loop  ; If not zero, continue searching 
1696			 
1696			    ; If we reached here, pointer is not found in heap 
1696			    ret 
1696			 
1696			free_exit: 
1696			    ret                 ; Return 
1696			 
1696			; Define heap start and end addresses 
1696			;heap_start:    .dw 0xC000   ; Start of heap 
1696			;heap_end:      .dw 0xE000   ; End of heap 
1696			 
1696			endif 
1696			 
1696			 
1696			if MALLOC_1 
1696			 
1696			 
1696			 
1696			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1696			 
1696			;moved to firmware.asm 
1696			;heap_start        .equ  0x9000      ; Starting address of heap 
1696			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1696			 
1696			;      .org 0 
1696			;      jp    main 
1696			 
1696			 
1696			;      .org  0x100 
1696			;main: 
1696			;      ld    HL, 0x8100 
1696			;      ld    SP, HL 
1696			; 
1696			;      call  heap_init 
1696			; 
1696			;      ; Make some allocations 
1696			;      ld    HL, 12 
1696			;      call  malloc            ; Allocates 0x9004 
1696			; 
1696			;      ld    HL, 12 
1696			;      call  malloc            ; Allocates 0x9014 
1696			; 
1696			;      ld    HL, 12 
1696			;      call  malloc            ; Allocates 0x9024 
1696			; 
1696			;      ; Free some allocations 
1696			;      ld    HL, 0x9014 
1696			;      call  free 
1696			; 
1696			;      ld    HL, 0x9004 
1696			;      call  free 
1696			; 
1696			;      ld    HL, 0x9024 
1696			;      call  free 
1696			; 
1696			; 
1696			;      halt 
1696			 
1696			 
1696			;------------------------------------------------------------------------------ 
1696			;     heap_init                                                               : 
1696			;                                                                             : 
1696			; Description                                                                 : 
1696			;     Initialise the heap and make it ready for malloc and free operations.   : 
1696			;                                                                             : 
1696			;     The heap is maintained as a linked list, starting with an initial       : 
1696			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1696			;     the first free block in the heap. Each block then points to the next    : 
1696			;     free block within the heap, and the free list ends at the first block   : 
1696			;     with a null pointer to the next free block.                             : 
1696			;                                                                             : 
1696			; Parameters                                                                  : 
1696			;     Inputs are compile-time only. Two defines which specify the starting    : 
1696			;     address of the heap and its size are required, along with a memory      : 
1696			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1696			;     principally stores a pointer to the first free block in the heap.       : 
1696			;                                                                             : 
1696			; Returns                                                                     : 
1696			;     Nothing                                                                 : 
1696			;------------------------------------------------------------------------------ 
1696			heap_init: 
1696 e5			      push  HL 
1697			 
1697			      ; Initialise free list struct 
1697 21 0e 80		      ld    HL, heap_start 
169a 22 0a 80		      ld    (free_list), HL 
169d 21 00 00		      ld    HL, 0 
16a0 22 0c 80		      ld    (free_list+2), HL 
16a3			 
16a3			      ; Insert first free block at bottom of heap, consumes entire heap 
16a3 21 d3 f0		      ld    HL, heap_start+heap_size-4 
16a6 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
16a9 21 c5 70		      ld    HL, heap_size-4 
16ac 22 10 80		      ld    (heap_start+2), HL      ; Block size 
16af			 
16af			      ; Insert end of free list block at top of heap - two null words will 
16af			      ; terminate the free list 
16af 21 00 00		      ld    HL, 0 
16b2 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
16b5 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
16b8			 
16b8 e1			      pop   HL 
16b9			 
16b9 c9			      ret 
16ba			 
16ba			 
16ba			;------------------------------------------------------------------------------ 
16ba			;     malloc                                                                  : 
16ba			;                                                                             : 
16ba			; Description                                                                 : 
16ba			;     Allocates the wanted space from the heap and returns the address of the : 
16ba			;     first useable byte of the allocation.                                   : 
16ba			;                                                                             : 
16ba			;     Allocations can happen in one of two ways:                              : 
16ba			;                                                                             : 
16ba			;     1. A free block may be found which is the exact size wanted. In this    : 
16ba			;        case the block is removed from the free list and retuedn to the      : 
16ba			;        caller.                                                              : 
16ba			;     2. A free block may be found which is larger than the size wanted. In   : 
16ba			;        this case, the larger block is split into two. The first portion of  : 
16ba			;        this block will become the requested space by the malloc call and    : 
16ba			;        is returned to the caller. The second portion becomes a new free     : 
16ba			;        block, and the free list is adjusted to maintain continuity via this : 
16ba			;        newly created block.                                                 : 
16ba			;                                                                             : 
16ba			;     malloc does not set any initial value in the allocated space, the       : 
16ba			;     caller is required to do this as required.                              : 
16ba			;                                                                             : 
16ba			;     This implementation of malloc uses the stack exclusively, and is        : 
16ba			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
16ba			;     advisable to disable interrupts before calling malloc, and recommended  : 
16ba			;     to avoid the use of malloc inside ISRs in general.                      : 
16ba			;                                                                             : 
16ba			;     NOTE: heap_init must be called before malloc and free can be used.      : 
16ba			;                                                                             : 
16ba			; Parameters                                                                  : 
16ba			;     HL  Number of bytes wanted                                              : 
16ba			;                                                                             : 
16ba			; Returns                                                                     : 
16ba			;     HL  Address of the first useable byte of the allocation                 : 
16ba			;                                                                             : 
16ba			; Flags                                                                       : 
16ba			;     Z   Set if the allocation did not succeed, clear otherwise              : 
16ba			;                                                                             : 
16ba			; Stack frame                                                                 : 
16ba			;       |             |                                                       : 
16ba			;       +-------------+                                                       : 
16ba			;       |     BC      |                                                       : 
16ba			;       +-------------+                                                       : 
16ba			;       |     DE      |                                                       : 
16ba			;       +-------------+                                                       : 
16ba			;       |     IX      |                                                       : 
16ba			;       +-------------+                                                       : 
16ba			;       |  prev_free  |                                                       : 
16ba			;   +4  +-------------+                                                       : 
16ba			;       |  this_free  |                                                       : 
16ba			;   +2  +-------------+                                                       : 
16ba			;       |  next_free  |                                                       : 
16ba			;   +0  +-------------+                                                       : 
16ba			;       |             |                                                       : 
16ba			;                                                                             : 
16ba			;------------------------------------------------------------------------------ 
16ba			 
16ba			 
16ba			;malloc: 
16ba			; 
16ba			;	SAVESP ON 1 
16ba			; 
16ba			;	call malloc_code 
16ba			; 
16ba			;	CHECKSP ON 1 
16ba			;	ret 
16ba			 
16ba			 
16ba			malloc: 
16ba c5			      push  BC 
16bb d5			      push  DE 
16bc dd e5		      push  IX 
16be			if DEBUG_FORTH_MALLOC_HIGH 
16be			call malloc_guard_entry 
16be			endif 
16be			 
16be					if DEBUG_FORTH_MALLOC 
16be						DMARK "mal" 
16be						CALLMONITOR 
16be					endif 
16be 7c			      ld    A, H                    ; Exit if no space requested 
16bf b5			      or    L 
16c0 ca 7f 17		      jp    Z, malloc_early_exit 
16c3			 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			; 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			;inc hl 
16c3			 
16c3			 
16c3			 
16c3			 
16c3					if DEBUG_FORTH_MALLOC 
16c3						DMARK "maA" 
16c3						CALLMONITOR 
16c3					endif 
16c3			      ; Set up stack frame 
16c3 eb			      ex    DE, HL 
16c4 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
16c7 39			      add   HL, SP 
16c8 f9			      ld    SP, HL 
16c9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
16cd dd 39		      add   IX, SP 
16cf			 
16cf			      ; Setup initial state 
16cf 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
16d2 19			      add   HL, DE 
16d3			 
16d3 44			      ld    B, H                    ; Move want to BC 
16d4 4d			      ld    C, L 
16d5			 
16d5 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
16d8 dd 75 04		      ld    (IX+4), L 
16db dd 74 05		      ld    (IX+5), H 
16de			 
16de 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
16df 23			      inc   HL 
16e0 56			      ld    D, (HL) 
16e1 dd 73 02		      ld    (IX+2), E 
16e4 dd 72 03		      ld    (IX+3), D 
16e7 eb			      ex    DE, HL                  ; this_free ptr into HL 
16e8			 
16e8					if DEBUG_FORTH_MALLOC 
16e8						DMARK "maB" 
16e8						CALLMONITOR 
16e8					endif 
16e8			      ; Loop through free block list to find some space 
16e8			malloc_find_space: 
16e8 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
16e9 23			      inc   HL 
16ea 56			      ld    D, (HL) 
16eb			 
16eb 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
16ec b3			      or    E 
16ed ca 79 17		      jp    Z, malloc_no_space 
16f0			 
16f0 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
16f3 dd 72 01		      ld    (IX+1), D 
16f6			 
16f6			      ; Does this block have enough space to make the allocation? 
16f6 23			      inc   HL                      ; Load free block size into DE 
16f7 5e			      ld    E, (HL) 
16f8 23			      inc   HL 
16f9 56			      ld    D, (HL) 
16fa			 
16fa eb			      ex    DE, HL                  ; Check size of block against want 
16fb b7			      or    A                       ; Ensure carry flag clear 
16fc ed 42		      sbc   HL, BC 
16fe e5			      push  HL                      ; Store the result for later (new block size) 
16ff			 
16ff ca 4e 17		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1702 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1704			 
1704			      ; this_free block is not big enough, setup ptrs to test next free block 
1704 e1			      pop   HL                      ; Discard previous result 
1705			 
1705 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1708 dd 66 03		      ld    H, (IX+3) 
170b dd 75 04		      ld    (IX+4), L 
170e dd 74 05		      ld    (IX+5), H 
1711			 
1711 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1714 dd 66 01		      ld    H, (IX+1) 
1717 dd 75 02		      ld    (IX+2), L 
171a dd 74 03		      ld    (IX+3), H 
171d			 
171d					if DEBUG_FORTH_MALLOC 
171d						DMARK "MA>" 
171d						CALLMONITOR 
171d					endif 
171d 18 c9		      jr    malloc_find_space 
171f			 
171f			      ; split a bigger block into two - requested size and remaining size 
171f			malloc_alloc_split: 
171f					if DEBUG_FORTH_MALLOC 
171f						DMARK "MAs" 
171f						CALLMONITOR 
171f					endif 
171f eb			      ex    DE, HL                  ; Calculate address of new free block 
1720 2b			      dec   HL 
1721 2b			      dec   HL 
1722 2b			      dec   HL 
1723 09			      add   HL, BC 
1724			 
1724			      ; Create a new block and point it at next_free 
1724 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1727 dd 56 01		      ld    D, (IX+1) 
172a			 
172a 73			      ld    (HL), E                 ; Store next_free ptr into new block 
172b 23			      inc   HL 
172c 72			      ld    (HL), D 
172d			 
172d d1			      pop   DE                      ; Store size of new block into new block 
172e 23			      inc   HL 
172f 73			      ld    (HL), E 
1730 23			      inc   HL 
1731 72			      ld    (HL), D 
1732			 
1732			      ; Update this_free ptr to point to new block 
1732 2b			      dec   HL 
1733 2b			      dec   HL 
1734 2b			      dec   HL 
1735			 
1735 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1738 dd 56 03		      ld    D, (IX+3) 
173b			 
173b dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
173e dd 74 03		      ld    (IX+3), H 
1741			 
1741			      ; Modify this_free block to be allocation 
1741 eb			      ex    DE, HL 
1742 af			      xor   A                       ; Null the next block ptr of allocated block 
1743 77			      ld    (HL), A 
1744 23			      inc   HL 
1745 77			      ld    (HL), A 
1746			 
1746 23			      inc   HL                      ; Store want size into allocated block 
1747 71			      ld    (HL), C 
1748 23			      inc   HL 
1749 70			      ld    (HL), B 
174a 23			      inc   HL 
174b e5			      push  HL                      ; Address of allocation to return 
174c			 
174c 18 19		      jr    malloc_update_links 
174e			 
174e			malloc_alloc_fit: 
174e e1			      pop   HL                      ; Dont need new block size, want is exact fit 
174f			 
174f					if DEBUG_FORTH_MALLOC 
174f						DMARK "MAf" 
174f						CALLMONITOR 
174f					endif 
174f			      ; Modify this_free block to be allocation 
174f eb			      ex    DE, HL 
1750 2b			      dec   HL 
1751 2b			      dec   HL 
1752 2b			      dec   HL 
1753			 
1753 af			      xor   A                       ; Null the next block ptr of allocated block 
1754 77			      ld    (HL), A 
1755 23			      inc   HL 
1756 77			      ld    (HL), A 
1757			 
1757 23			      inc   HL                      ; Store address of allocation to return 
1758 23			      inc   HL 
1759 23			      inc   HL 
175a e5			      push  HL 
175b			 
175b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
175b dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
175e dd 66 01		      ld    H, (IX+1) 
1761			 
1761 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1764 dd 74 03		      ld    (IX+3), H 
1767			 
1767			 
1767			malloc_update_links: 
1767			      ; Update prev_free ptr to point to this_free 
1767 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
176a dd 66 05		      ld    H, (IX+5) 
176d			 
176d dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1770 dd 56 03		      ld    D, (IX+3) 
1773			 
1773 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1774 23			      inc   HL 
1775 72			      ld    (HL), D 
1776			 
1776					if DEBUG_FORTH_MALLOC 
1776						DMARK "Mul" 
1776						CALLMONITOR 
1776					endif 
1776			      ; Clear the Z flag to indicate successful allocation 
1776 7a			      ld    A, D 
1777 b3			      or    E 
1778			 
1778 d1			      pop   DE                      ; Address of allocation 
1779					if DEBUG_FORTH_MALLOC 
1779						DMARK "MAu" 
1779						CALLMONITOR 
1779					endif 
1779			 
1779			malloc_no_space: 
1779 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
177c 39			      add   HL, SP 
177d f9			      ld    SP, HL 
177e			 
177e eb			      ex    DE, HL                  ; Alloc addr into HL for return 
177f					if DEBUG_FORTH_MALLOC 
177f						DMARK "MAN" 
177f						CALLMONITOR 
177f					endif 
177f			 
177f			malloc_early_exit: 
177f					if DEBUG_FORTH_MALLOC 
177f						DMARK "MAx" 
177f						CALLMONITOR 
177f					endif 
177f dd e1		      pop   IX 
1781 d1			      pop   DE 
1782 c1			      pop   BC 
1783			 
1783			if DEBUG_FORTH_MALLOC_HIGH 
1783			call malloc_guard_exit 
1783			call malloc_guard_zerolen 
1783			endif 
1783 c9			      ret 
1784			 
1784			 
1784			;------------------------------------------------------------------------------ 
1784			;     free                                                                    : 
1784			;                                                                             : 
1784			; Description                                                                 : 
1784			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1784			;     returned by malloc, otherwise the behaviour is undefined.               : 
1784			;                                                                             : 
1784			;     Where possible, directly adjacent free blocks will be merged together   : 
1784			;     into larger blocks to help ensure that the heap does not become         : 
1784			;     excessively fragmented.                                                 : 
1784			;                                                                             : 
1784			;     free does not clear or set any other value into the freed space, and    : 
1784			;     therefore its contents may be visible through subsequent malloc's. The  : 
1784			;     caller should clear the freed space as required.                        : 
1784			;                                                                             : 
1784			;     This implementation of free uses the stack exclusively, and is          : 
1784			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1784			;     advisable to disable interrupts before calling free, and recommended    : 
1784			;     to avoid the use of free inside ISRs in general.                        : 
1784			;                                                                             : 
1784			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1784			;                                                                             : 
1784			; Parameters                                                                  : 
1784			;     HL  Pointer to address of first byte of allocation to be freed          : 
1784			;                                                                             : 
1784			; Returns                                                                     : 
1784			;     Nothing                                                                 : 
1784			;                                                                             : 
1784			; Stack frame                                                                 : 
1784			;       |             |                                                       : 
1784			;       +-------------+                                                       : 
1784			;       |     BC      |                                                       : 
1784			;       +-------------+                                                       : 
1784			;       |     DE      |                                                       : 
1784			;       +-------------+                                                       : 
1784			;       |     IX      |                                                       : 
1784			;       +-------------+                                                       : 
1784			;       |  prev_free  |                                                       : 
1784			;   +2  +-------------+                                                       : 
1784			;       |  next_free  |                                                       : 
1784			;   +0  +-------------+                                                       : 
1784			;       |             |                                                       : 
1784			;                                                                             : 
1784			;------------------------------------------------------------------------------ 
1784			free: 
1784 c5			      push  BC 
1785 d5			      push  DE 
1786 dd e5		      push  IX 
1788			 
1788 7c			      ld    A, H                    ; Exit if ptr is null 
1789 b5			      or    L 
178a ca 4e 18		      jp    Z, free_early_exit 
178d			 
178d			      ; Set up stack frame 
178d eb			      ex    DE, HL 
178e 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1791 39			      add   HL, SP 
1792 f9			      ld    SP, HL 
1793 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1797 dd 39		      add   IX, SP 
1799			 
1799			      ; The address in HL points to the start of the useable allocated space, 
1799			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1799			      ; address of the block itself. 
1799 eb			      ex    DE, HL 
179a 11 fc ff		      ld    DE, -4 
179d 19			      add   HL, DE 
179e			 
179e			      ; An allocated block must have a null next block pointer in it 
179e 7e			      ld    A, (HL) 
179f 23			      inc   HL 
17a0 b6			      or    (HL) 
17a1 c2 49 18		      jp    NZ, free_done 
17a4			 
17a4 2b			      dec   HL 
17a5			 
17a5 44			      ld    B, H                    ; Copy HL to BC 
17a6 4d			      ld    C, L 
17a7			 
17a7			      ; Loop through the free list to find the first block with an address 
17a7			      ; higher than the block being freed 
17a7 21 0a 80		      ld    HL, free_list 
17aa			 
17aa			free_find_higher_block: 
17aa 5e			      ld    E, (HL)                 ; Load next ptr from free block 
17ab 23			      inc   HL 
17ac 56			      ld    D, (HL) 
17ad 2b			      dec   HL 
17ae			 
17ae dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
17b1 dd 72 01		      ld    (IX+1), D 
17b4 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
17b7 dd 74 03		      ld    (IX+3), H 
17ba			 
17ba 78			      ld    A, B                    ; Check if DE is greater than BC 
17bb ba			      cp    D                       ; Compare MSB first 
17bc 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
17be 30 04		      jr    NC, free_find_higher_block_skip 
17c0 79			      ld    A, C 
17c1 bb			      cp    E                       ; Then compare LSB 
17c2 38 08		      jr    C, free_found_higher_block 
17c4			 
17c4			free_find_higher_block_skip: 
17c4 7a			      ld    A, D                    ; Reached the end of the free list? 
17c5 b3			      or    E 
17c6 ca 49 18		      jp    Z, free_done 
17c9			 
17c9 eb			      ex    DE, HL 
17ca			 
17ca 18 de		      jr    free_find_higher_block 
17cc			 
17cc			free_found_higher_block: 
17cc			      ; Insert freed block between prev and next free blocks 
17cc 71			      ld    (HL), C                 ; Point prev free block to freed block 
17cd 23			      inc   HL 
17ce 70			      ld    (HL), B 
17cf			 
17cf 60			      ld    H, B                    ; Point freed block at next free block 
17d0 69			      ld    L, C 
17d1 73			      ld    (HL), E 
17d2 23			      inc   HL 
17d3 72			      ld    (HL), D 
17d4			 
17d4			      ; Check if the freed block is adjacent to the next free block 
17d4 23			      inc   HL                      ; Load size of freed block into HL 
17d5 5e			      ld    E, (HL) 
17d6 23			      inc   HL 
17d7 56			      ld    D, (HL) 
17d8 eb			      ex    DE, HL 
17d9			 
17d9 09			      add   HL, BC                  ; Add addr of freed block and its size 
17da			 
17da dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
17dd dd 56 01		      ld    D, (IX+1) 
17e0			 
17e0 b7			      or    A                       ; Clear the carry flag 
17e1 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
17e3 20 22		      jr    NZ, free_check_adjacent_to_prev 
17e5			 
17e5			      ; Freed block is adjacent to next, merge into one bigger block 
17e5 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
17e6 5e			      ld    E, (HL) 
17e7 23			      inc   HL 
17e8 56			      ld    D, (HL) 
17e9 e5			      push  HL                      ; Save ptr to next block for later 
17ea			 
17ea 60			      ld    H, B                    ; Store ptr from next block into freed block 
17eb 69			      ld    L, C 
17ec 73			      ld    (HL), E 
17ed 23			      inc   HL 
17ee 72			      ld    (HL), D 
17ef			 
17ef e1			      pop   HL                      ; Restore ptr to next block 
17f0 23			      inc   HL                      ; Load size of next block into DE 
17f1 5e			      ld    E, (HL) 
17f2 23			      inc   HL 
17f3 56			      ld    D, (HL) 
17f4 d5			      push  DE                      ; Save next block size for later 
17f5			 
17f5 60			      ld    H, B                    ; Load size of freed block into HL 
17f6 69			      ld    L, C 
17f7 23			      inc   HL 
17f8 23			      inc   HL 
17f9 5e			      ld    E, (HL) 
17fa 23			      inc   HL 
17fb 56			      ld    D, (HL) 
17fc eb			      ex    DE, HL 
17fd			 
17fd d1			      pop   DE                      ; Restore size of next block 
17fe 19			      add   HL, DE                  ; Add sizes of both blocks 
17ff eb			      ex    DE, HL 
1800			 
1800 60			      ld    H, B                    ; Store new bigger size into freed block 
1801 69			      ld    L, C 
1802 23			      inc   HL 
1803 23			      inc   HL 
1804 73			      ld    (HL), E 
1805 23			      inc   HL 
1806 72			      ld    (HL), D 
1807			 
1807			free_check_adjacent_to_prev: 
1807			      ; Check if the freed block is adjacent to the prev free block 
1807 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
180a dd 66 03		      ld    H, (IX+3) 
180d			 
180d 23			      inc   HL                      ; Size of prev free block into DE 
180e 23			      inc   HL 
180f 5e			      ld    E, (HL) 
1810 23			      inc   HL 
1811 56			      ld    D, (HL) 
1812 2b			      dec   HL 
1813 2b			      dec   HL 
1814 2b			      dec   HL 
1815			 
1815 19			      add   HL, DE                  ; Add prev block addr and size 
1816			 
1816 b7			      or    A                       ; Clear the carry flag 
1817 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1819 20 2e		      jr    NZ, free_done 
181b			 
181b			      ; Freed block is adjacent to prev, merge into one bigger block 
181b 60			      ld    H, B                    ; Load next ptr from freed block into DE 
181c 69			      ld    L, C 
181d 5e			      ld    E, (HL) 
181e 23			      inc   HL 
181f 56			      ld    D, (HL) 
1820 e5			      push  HL                      ; Save freed block ptr for later 
1821			 
1821 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1824 dd 66 03		      ld    H, (IX+3) 
1827 73			      ld    (HL), E 
1828 23			      inc   HL 
1829 72			      ld    (HL), D 
182a			 
182a e1			      pop   HL                      ; Restore freed block ptr 
182b 23			      inc   HL                      ; Load size of freed block into DE 
182c 5e			      ld    E, (HL) 
182d 23			      inc   HL 
182e 56			      ld    D, (HL) 
182f d5			      push  DE                      ; Save freed block size for later 
1830			 
1830 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1833 dd 66 03		      ld    H, (IX+3) 
1836 23			      inc   HL 
1837 23			      inc   HL 
1838 5e			      ld    E, (HL) 
1839 23			      inc   HL 
183a 56			      ld    D, (HL) 
183b			 
183b e1			      pop   HL                      ; Add sizes of both blocks 
183c 19			      add   HL, DE 
183d eb			      ex    DE, HL 
183e			 
183e dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1841 dd 66 03		      ld    H, (IX+3) 
1844 23			      inc   HL 
1845 23			      inc   HL 
1846 73			      ld    (HL), E 
1847 23			      inc   HL 
1848 72			      ld    (HL), D 
1849			 
1849			free_done: 
1849 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
184c 39			      add   HL, SP 
184d f9			      ld    SP, HL 
184e			 
184e			free_early_exit: 
184e dd e1		      pop   IX 
1850 d1			      pop   DE 
1851 c1			      pop   BC 
1852			 
1852 c9			      ret 
1853			 
1853			; moved to firmware.asm 
1853			; 
1853			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1853			;                  .dw   0 
1853			 
1853			 
1853			endif 
1853			 
1853			 
1853			if MALLOC_3 
1853			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1853			;heap_start        .equ  0x9000      ; Starting address of heap 
1853			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1853			; 
1853			 ;     .org 0 
1853			  ;    jp    main 
1853			; 
1853			; 
1853			 ;     .org  0x100 
1853			;main: 
1853			 ;     ld    HL, 0x8100 
1853			  ;    ld    SP, HL 
1853			; 
1853			;      call  heap_init 
1853			 
1853			      ; Make some allocations 
1853			;      ld    HL, 12 
1853			;      call  malloc            ; Allocates 0x9004 
1853			; 
1853			 ;     ld    HL, 12 
1853			;      call  malloc            ; Allocates 0x9014 
1853			 
1853			;      ld    HL, 12 
1853			;      call  malloc            ; Allocates 0x9024 
1853			 
1853			      ; Free some allocations 
1853			;      ld    HL, 0x9014 
1853			;      call  free 
1853			 
1853			;      ld    HL, 0x9004 
1853			;      call  free 
1853			; 
1853			;      ld    HL, 0x9024 
1853			;      call  free 
1853			 
1853			 
1853			 ;     halt 
1853			 
1853			 
1853			;------------------------------------------------------------------------------ 
1853			;     heap_init                                                               : 
1853			;                                                                             : 
1853			; Description                                                                 : 
1853			;     Initialise the heap and make it ready for malloc and free operations.   : 
1853			;                                                                             : 
1853			;     The heap is maintained as a linked list, starting with an initial       : 
1853			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1853			;     the first free block in the heap. Each block then points to the next    : 
1853			;     free block within the heap, and the free list ends at the first block   : 
1853			;     with a null pointer to the next free block.                             : 
1853			;                                                                             : 
1853			; Parameters                                                                  : 
1853			;     Inputs are compile-time only. Two defines which specify the starting    : 
1853			;     address of the heap and its size are required, along with a memory      : 
1853			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1853			;     principally stores a pointer to the first free block in the heap.       : 
1853			;                                                                             : 
1853			; Returns                                                                     : 
1853			;     Nothing                                                                 : 
1853			;------------------------------------------------------------------------------ 
1853			heap_init: 
1853			      push  HL 
1853			 
1853			      ; Initialise free list struct 
1853			      ld    HL, heap_start 
1853			      ld    (free_list), HL 
1853			      ld    HL, 0 
1853			      ld    (free_list+2), HL 
1853			 
1853			      ; Insert first free block at bottom of heap, consumes entire heap 
1853			      ld    HL, heap_start+heap_size-4 
1853			      ld    (heap_start), HL        ; Next block (end of free list) 
1853			      ld    HL, heap_size-4 
1853			      ld    (heap_start+2), HL      ; Block size 
1853			 
1853			      ; Insert end of free list block at top of heap - two null words will 
1853			      ; terminate the free list 
1853			      ld    HL, 0 
1853			      ld    (heap_start+heap_size-2), HL 
1853			      ld    (heap_start+heap_size-4), HL 
1853			 
1853			      pop   HL 
1853			 
1853			      ret 
1853			 
1853			 
1853			;------------------------------------------------------------------------------ 
1853			;     malloc                                                                  : 
1853			;                                                                             : 
1853			; Description                                                                 : 
1853			;     Allocates the wanted space from the heap and returns the address of the : 
1853			;     first useable byte of the allocation.                                   : 
1853			;                                                                             : 
1853			;     Allocations can happen in one of two ways:                              : 
1853			;                                                                             : 
1853			;     1. A free block may be found which is the exact size wanted. In this    : 
1853			;        case the block is removed from the free list and retuedn to the      : 
1853			;        caller.                                                              : 
1853			;     2. A free block may be found which is larger than the size wanted. In   : 
1853			;        this case, the larger block is split into two. The first portion of  : 
1853			;        this block will become the requested space by the malloc call and    : 
1853			;        is returned to the caller. The second portion becomes a new free     : 
1853			;        block, and the free list is adjusted to maintain continuity via this : 
1853			;        newly created block.                                                 : 
1853			;                                                                             : 
1853			;     malloc does not set any initial value in the allocated space, the       : 
1853			;     caller is required to do this as required.                              : 
1853			;                                                                             : 
1853			;     This implementation of malloc uses the stack exclusively, and is        : 
1853			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1853			;     advisable to disable interrupts before calling malloc, and recommended  : 
1853			;     to avoid the use of malloc inside ISRs in general.                      : 
1853			;                                                                             : 
1853			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1853			;                                                                             : 
1853			; Parameters                                                                  : 
1853			;     HL  Number of bytes wanted                                              : 
1853			;                                                                             : 
1853			; Returns                                                                     : 
1853			;     HL  Address of the first useable byte of the allocation                 : 
1853			;                                                                             : 
1853			; Flags                                                                       : 
1853			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1853			;                                                                             : 
1853			; Stack frame                                                                 : 
1853			;       |             |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |     BC      |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |     DE      |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |     IX      |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |  prev_free  |                                                       : 
1853			;   +4  +-------------+                                                       : 
1853			;       |  this_free  |                                                       : 
1853			;   +2  +-------------+                                                       : 
1853			;       |  next_free  |                                                       : 
1853			;   +0  +-------------+                                                       : 
1853			;       |             |                                                       : 
1853			;                                                                             : 
1853			;------------------------------------------------------------------------------ 
1853			malloc: 
1853			      push  BC 
1853			      push  DE 
1853			      push  IX 
1853			 
1853			      ld    A, H                    ; Exit if no space requested 
1853			      or    L 
1853			      jp    Z, malloc_early_exit 
1853			 
1853			      ; Set up stack frame 
1853			      ex    DE, HL 
1853			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1853			      add   HL, SP 
1853			      ld    SP, HL 
1853			      ld    IX, 0                   ; Use IX as a frame pointer 
1853			      add   IX, SP 
1853			 
1853			      ; Setup initial state 
1853			      ld    HL, 4                   ; want must also include space used by block struct 
1853			      add   HL, DE 
1853			 
1853			      ld    B, H                    ; Move want to BC 
1853			      ld    C, L 
1853			 
1853			      ld    HL, free_list           ; Store prev_free ptr to stack 
1853			      ld    (IX+4), L 
1853			      ld    (IX+5), H 
1853			 
1853			      ld    E, (HL)                 ; Store this_free ptr to stack 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      ld    (IX+2), E 
1853			      ld    (IX+3), D 
1853			      ex    DE, HL                  ; this_free ptr into HL 
1853			 
1853			      ; Loop through free block list to find some space 
1853			malloc_find_space: 
1853			      ld    E, (HL)                 ; Load next_free ptr into DE 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			 
1853			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1853			      or    E 
1853			      jp    Z, malloc_no_space 
1853			 
1853			      ld    (IX+0), E               ; Store next_free ptr to stack 
1853			      ld    (IX+1), D 
1853			 
1853			      ; Does this block have enough space to make the allocation? 
1853			      inc   HL                      ; Load free block size into DE 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			 
1853			      ex    DE, HL                  ; Check size of block against want 
1853			      or    A                       ; Ensure carry flag clear 
1853			      sbc   HL, BC 
1853			      push  HL                      ; Store the result for later (new block size) 
1853			 
1853			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1853			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1853			 
1853			      ; this_free block is not big enough, setup ptrs to test next free block 
1853			      pop   HL                      ; Discard previous result 
1853			 
1853			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1853			      ld    H, (IX+3) 
1853			      ld    (IX+4), L 
1853			      ld    (IX+5), H 
1853			 
1853			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1853			      ld    H, (IX+1) 
1853			      ld    (IX+2), L 
1853			      ld    (IX+3), H 
1853			 
1853			      jr    malloc_find_space 
1853			 
1853			      ; split a bigger block into two - requested size and remaining size 
1853			malloc_alloc_split: 
1853			      ex    DE, HL                  ; Calculate address of new free block 
1853			      dec   HL 
1853			      dec   HL 
1853			      dec   HL 
1853			      add   HL, BC 
1853			 
1853			      ; Create a new block and point it at next_free 
1853			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1853			      ld    D, (IX+1) 
1853			 
1853			      ld    (HL), E                 ; Store next_free ptr into new block 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			      pop   DE                      ; Store size of new block into new block 
1853			      inc   HL 
1853			      ld    (HL), E 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			      ; Update this_free ptr to point to new block 
1853			      dec   HL 
1853			      dec   HL 
1853			      dec   HL 
1853			 
1853			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1853			      ld    D, (IX+3) 
1853			 
1853			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1853			      ld    (IX+3), H 
1853			 
1853			      ; Modify this_free block to be allocation 
1853			      ex    DE, HL 
1853			      xor   A                       ; Null the next block ptr of allocated block 
1853			      ld    (HL), A 
1853			      inc   HL 
1853			      ld    (HL), A 
1853			 
1853			      inc   HL                      ; Store want size into allocated block 
1853			      ld    (HL), C 
1853			      inc   HL 
1853			      ld    (HL), B 
1853			      inc   HL 
1853			      push  HL                      ; Address of allocation to return 
1853			 
1853			      jr    malloc_update_links 
1853			 
1853			malloc_alloc_fit: 
1853			      pop   HL                      ; Dont need new block size, want is exact fit 
1853			 
1853			      ; Modify this_free block to be allocation 
1853			      ex    DE, HL 
1853			      dec   HL 
1853			      dec   HL 
1853			      dec   HL 
1853			 
1853			      xor   A                       ; Null the next block ptr of allocated block 
1853			      ld    (HL), A 
1853			      inc   HL 
1853			      ld    (HL), A 
1853			 
1853			      inc   HL                      ; Store address of allocation to return 
1853			      inc   HL 
1853			      inc   HL 
1853			      push  HL 
1853			 
1853			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1853			      ld    L, (IX+0)               ; next_free to HL 
1853			      ld    H, (IX+1) 
1853			 
1853			      ld    (IX+2), L               ; HL to this_free 
1853			      ld    (IX+3), H 
1853			 
1853			 
1853			malloc_update_links: 
1853			      ; Update prev_free ptr to point to this_free 
1853			      ld    L, (IX+4)               ; prev_free ptr to HL 
1853			      ld    H, (IX+5) 
1853			 
1853			      ld    E, (IX+2)               ; this_free ptr to DE 
1853			      ld    D, (IX+3) 
1853			 
1853			      ld    (HL), E                 ; this_free ptr into prev_free 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			      ; Clear the Z flag to indicate successful allocation 
1853			      ld    A, D 
1853			      or    E 
1853			 
1853			      pop   DE                      ; Address of allocation 
1853			 
1853			malloc_no_space: 
1853			      ld    HL, 6                   ; Clean up stack frame 
1853			      add   HL, SP 
1853			      ld    SP, HL 
1853			 
1853			      ex    DE, HL                  ; Alloc addr into HL for return 
1853			 
1853			malloc_early_exit: 
1853			      pop   IX 
1853			      pop   DE 
1853			      pop   BC 
1853			 
1853			      ret 
1853			 
1853			 
1853			;------------------------------------------------------------------------------ 
1853			;     free                                                                    : 
1853			;                                                                             : 
1853			; Description                                                                 : 
1853			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1853			;     returned by malloc, otherwise the behaviour is undefined.               : 
1853			;                                                                             : 
1853			;     Where possible, directly adjacent free blocks will be merged together   : 
1853			;     into larger blocks to help ensure that the heap does not become         : 
1853			;     excessively fragmented.                                                 : 
1853			;                                                                             : 
1853			;     free does not clear or set any other value into the freed space, and    : 
1853			;     therefore its contents may be visible through subsequent malloc's. The  : 
1853			;     caller should clear the freed space as required.                        : 
1853			;                                                                             : 
1853			;     This implementation of free uses the stack exclusively, and is          : 
1853			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1853			;     advisable to disable interrupts before calling free, and recommended    : 
1853			;     to avoid the use of free inside ISRs in general.                        : 
1853			;                                                                             : 
1853			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1853			;                                                                             : 
1853			; Parameters                                                                  : 
1853			;     HL  Pointer to address of first byte of allocation to be freed          : 
1853			;                                                                             : 
1853			; Returns                                                                     : 
1853			;     Nothing                                                                 : 
1853			;                                                                             : 
1853			; Stack frame                                                                 : 
1853			;       |             |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |     BC      |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |     DE      |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |     IX      |                                                       : 
1853			;       +-------------+                                                       : 
1853			;       |  prev_free  |                                                       : 
1853			;   +2  +-------------+                                                       : 
1853			;       |  next_free  |                                                       : 
1853			;   +0  +-------------+                                                       : 
1853			;       |             |                                                       : 
1853			;                                                                             : 
1853			;------------------------------------------------------------------------------ 
1853			free: 
1853			      push  BC 
1853			      push  DE 
1853			      push  IX 
1853			 
1853			      ld    A, H                    ; Exit if ptr is null 
1853			      or    L 
1853			      jp    Z, free_early_exit 
1853			 
1853			      ; Set up stack frame 
1853			      ex    DE, HL 
1853			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1853			      add   HL, SP 
1853			      ld    SP, HL 
1853			      ld    IX, 0                   ; Use IX as a frame pointer 
1853			      add   IX, SP 
1853			 
1853			      ; The address in HL points to the start of the useable allocated space, 
1853			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1853			      ; address of the block itself. 
1853			      ex    DE, HL 
1853			      ld    DE, -4 
1853			      add   HL, DE 
1853			 
1853			      ; An allocated block must have a null next block pointer in it 
1853			      ld    A, (HL) 
1853			      inc   HL 
1853			      or    (HL) 
1853			      jp    NZ, free_done 
1853			 
1853			      dec   HL 
1853			 
1853			      ld    B, H                    ; Copy HL to BC 
1853			      ld    C, L 
1853			 
1853			      ; Loop through the free list to find the first block with an address 
1853			      ; higher than the block being freed 
1853			      ld    HL, free_list 
1853			 
1853			free_find_higher_block: 
1853			      ld    E, (HL)                 ; Load next ptr from free block 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      dec   HL 
1853			 
1853			      ld    (IX+0), E               ; Save ptr to next free block 
1853			      ld    (IX+1), D 
1853			      ld    (IX+2), L               ; Save ptr to prev free block 
1853			      ld    (IX+3), H 
1853			 
1853			      ld    A, B                    ; Check if DE is greater than BC 
1853			      cp    D                       ; Compare MSB first 
1853			      jr    Z, $+4                  ; MSB the same, compare LSB 
1853			      jr    NC, free_find_higher_block_skip 
1853			      ld    A, C 
1853			      cp    E                       ; Then compare LSB 
1853			      jr    C, free_found_higher_block 
1853			 
1853			free_find_higher_block_skip: 
1853			      ld    A, D                    ; Reached the end of the free list? 
1853			      or    E 
1853			      jp    Z, free_done 
1853			 
1853			      ex    DE, HL 
1853			 
1853			      jr    free_find_higher_block 
1853			 
1853			free_found_higher_block: 
1853			      ; Insert freed block between prev and next free blocks 
1853			      ld    (HL), C                 ; Point prev free block to freed block 
1853			      inc   HL 
1853			      ld    (HL), B 
1853			 
1853			      ld    H, B                    ; Point freed block at next free block 
1853			      ld    L, C 
1853			      ld    (HL), E 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			      ; Check if the freed block is adjacent to the next free block 
1853			      inc   HL                      ; Load size of freed block into HL 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      ex    DE, HL 
1853			 
1853			      add   HL, BC                  ; Add addr of freed block and its size 
1853			 
1853			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1853			      ld    D, (IX+1) 
1853			 
1853			      or    A                       ; Clear the carry flag 
1853			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1853			      jr    NZ, free_check_adjacent_to_prev 
1853			 
1853			      ; Freed block is adjacent to next, merge into one bigger block 
1853			      ex    DE, HL                  ; Load next ptr from next block into DE 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      push  HL                      ; Save ptr to next block for later 
1853			 
1853			      ld    H, B                    ; Store ptr from next block into freed block 
1853			      ld    L, C 
1853			      ld    (HL), E 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			      pop   HL                      ; Restore ptr to next block 
1853			      inc   HL                      ; Load size of next block into DE 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      push  DE                      ; Save next block size for later 
1853			 
1853			      ld    H, B                    ; Load size of freed block into HL 
1853			      ld    L, C 
1853			      inc   HL 
1853			      inc   HL 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      ex    DE, HL 
1853			 
1853			      pop   DE                      ; Restore size of next block 
1853			      add   HL, DE                  ; Add sizes of both blocks 
1853			      ex    DE, HL 
1853			 
1853			      ld    H, B                    ; Store new bigger size into freed block 
1853			      ld    L, C 
1853			      inc   HL 
1853			      inc   HL 
1853			      ld    (HL), E 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			free_check_adjacent_to_prev: 
1853			      ; Check if the freed block is adjacent to the prev free block 
1853			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1853			      ld    H, (IX+3) 
1853			 
1853			      inc   HL                      ; Size of prev free block into DE 
1853			      inc   HL 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      dec   HL 
1853			      dec   HL 
1853			      dec   HL 
1853			 
1853			      add   HL, DE                  ; Add prev block addr and size 
1853			 
1853			      or    A                       ; Clear the carry flag 
1853			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1853			      jr    NZ, free_done 
1853			 
1853			      ; Freed block is adjacent to prev, merge into one bigger block 
1853			      ld    H, B                    ; Load next ptr from freed block into DE 
1853			      ld    L, C 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      push  HL                      ; Save freed block ptr for later 
1853			 
1853			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1853			      ld    H, (IX+3) 
1853			      ld    (HL), E 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			      pop   HL                      ; Restore freed block ptr 
1853			      inc   HL                      ; Load size of freed block into DE 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			      push  DE                      ; Save freed block size for later 
1853			 
1853			      ld    L, (IX+2)               ; Load size of prev block into DE 
1853			      ld    H, (IX+3) 
1853			      inc   HL 
1853			      inc   HL 
1853			      ld    E, (HL) 
1853			      inc   HL 
1853			      ld    D, (HL) 
1853			 
1853			      pop   HL                      ; Add sizes of both blocks 
1853			      add   HL, DE 
1853			      ex    DE, HL 
1853			 
1853			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1853			      ld    H, (IX+3) 
1853			      inc   HL 
1853			      inc   HL 
1853			      ld    (HL), E 
1853			      inc   HL 
1853			      ld    (HL), D 
1853			 
1853			free_done: 
1853			      ld    HL, 4                   ; Clean up stack frame 
1853			      add   HL, SP 
1853			      ld    SP, HL 
1853			 
1853			free_early_exit: 
1853			      pop   IX 
1853			      pop   DE 
1853			      pop   BC 
1853			 
1853			      ret 
1853			 
1853			 
1853			;      .org 0x8000 
1853			; 
1853			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1853			 ;                 .dw   0 
1853			 
1853			endif 
1853			 
1853			 
1853			if MALLOC_4 
1853			 
1853			; My memory allocation code. Very very simple.... 
1853			; allocate space under 250 chars 
1853			 
1853			heap_init: 
1853				; init start of heap as zero 
1853				;  
1853			 
1853				ld hl, heap_start 
1853				ld a, 0 
1853				ld (hl), a      ; empty block 
1853				inc hl 
1853				ld a, 0 
1853				ld (hl), a      ; length of block 
1853				; write end of list 
1853				inc hl 
1853				ld a,(hl) 
1853				inc hl 
1853				ld a,(hl) 
1853				 
1853			 
1853				; init some malloc vars 
1853			 
1853				ld hl, 0 
1853				ld (free_list), hl       ; store last malloc location 
1853			 
1853				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1853				ld a, 0 
1853				ld (hl), a 
1853			 
1853			 
1853				ld hl, heap_start 
1853				;  
1853				  
1853				ret 
1853			 
1853			 
1853			;    free block marker 
1853			;    requested size  
1853			;    pointer to next block 
1853			;    .... 
1853			;    next block marker 
1853			 
1853			 
1853			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1853			; 
1853			 
1853			 
1853			malloc:  
1853				push de 
1853				push bc 
1853				push af 
1853			 
1853				; hl space required 
1853				 
1853				ld c, l    ; hold space   (TODO only a max of 255) 
1853			 
1853			;	inc c     ; TODO BUG need to fix memory leak on push str 
1853			;	inc c 
1853			;	inc c 
1853			;	inc c 
1853			;	inc c 
1853			;	inc c 
1853			;	inc c 
1853			 
1853			 
1853			 
1853				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1853			 
1853				ld a, (free_list+3) 
1853				cp 0 
1853				jr z, .contheap 
1853			 
1853				ld hl, (free_list)     ; get last alloc 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "mrs" 
1853						CALLMONITOR 
1853					endif 
1853				jr .startalloc 
1853			 
1853			.contheap: 
1853				ld hl, heap_start 
1853			 
1853			.startalloc: 
1853			 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "mym" 
1853						CALLMONITOR 
1853					endif 
1853			.findblock: 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "mmf" 
1853						CALLMONITOR 
1853					endif 
1853			 
1853				ld a,(hl)  
1853				; if byte is zero then clear to use 
1853			 
1853				cp 0 
1853				jr z, .foundemptyblock 
1853			 
1853				; if byte is not clear 
1853				;     then byte is offset to next block 
1853			 
1853				inc hl 
1853				ld a, (hl) ; get size 
1853			.nextblock:	inc hl 
1853					ld e, (hl) 
1853					inc hl 
1853					ld d, (hl) 
1853					ex de, hl 
1853			;	inc hl  ; move past the store space 
1853			;	inc hl  ; move past zero index  
1853			 
1853				; TODO detect no more space 
1853			 
1853				push hl 
1853				ld de, heap_end 
1853				call cmp16 
1853				pop hl 
1853				jr nc, .nospace 
1853			 
1853				jr .findblock 
1853			 
1853			.nospace: ld hl, 0 
1853				jp .exit 
1853			 
1853			 
1853			.foundemptyblock:	 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "mme" 
1853						CALLMONITOR 
1853					endif 
1853			 
1853			; TODO has block enough space if reusing??? 
1853			 
1853				;  
1853			 
1853			; see if this block has been previously used 
1853				inc hl 
1853				ld a, (hl) 
1853				dec hl 
1853				cp 0 
1853				jr z, .newblock 
1853			 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "meR" 
1853						CALLMONITOR 
1853					endif 
1853			 
1853			; no reusing previously allocated block 
1853			 
1853			; is it smaller than previously used? 
1853				 
1853				inc hl    ; move to size 
1853				ld a, c 
1853				sub (hl)        ; we want c < (hl) 
1853				dec hl    ; move back to marker 
1853			        jr z, .findblock 
1853			 
1853				; update with the new size which should be lower 
1853			 
1853			        ;inc  hl   ; negate next move. move back to size  
1853			 
1853			.newblock: 
1853				; need to be at marker here 
1853			 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "meN" 
1853						CALLMONITOR 
1853					endif 
1853			 
1853			 
1853				ld a, c 
1853			 
1853				ld (free_list+3), a	 ; flag resume from last malloc  
1853				ld (free_list), hl    ; save out last location 
1853			 
1853			 
1853				;inc a     ; space for length byte 
1853				ld (hl), a     ; save block in use marker 
1853			 
1853				inc hl   ; move to space marker 
1853				ld (hl), a    ; save new space 
1853			 
1853				inc hl   ; move to start of allocated area 
1853				 
1853			;	push hl     ; save where we are - 1  
1853			 
1853			;	inc hl  ; move past zero index  
1853				; skip space to set down new marker 
1853			 
1853				; provide some extra space for now 
1853			 
1853				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1853				inc a 
1853				inc a 
1853			 
1853				push hl   ; save where we are in the node block 
1853			 
1853				call addatohl 
1853			 
1853				; write linked list point 
1853			 
1853				pop de     ; get our node position 
1853				ex de, hl 
1853			 
1853				ld (hl), e 
1853				inc hl 
1853				ld (hl), d 
1853			 
1853				inc hl 
1853			 
1853				; now at start of allocated data so save pointer 
1853			 
1853				push hl 
1853			 
1853				; jump to position of next node and setup empty header in DE 
1853			 
1853				ex de, hl 
1853			 
1853			;	inc hl ; move past end of block 
1853			 
1853				ld a, 0 
1853				ld (hl), a   ; empty marker 
1853				inc hl 
1853				ld (hl), a   ; size 
1853				inc hl  
1853				ld (hl), a   ; ptr 
1853				inc hl 
1853				ld (hl), a   ; ptr 
1853			 
1853			 
1853				pop hl 
1853			 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "mmr" 
1853						CALLMONITOR 
1853					endif 
1853			 
1853			.exit: 
1853				pop af 
1853				pop bc 
1853				pop de  
1853				ret 
1853			 
1853			 
1853			 
1853			 
1853			free:  
1853				push hl 
1853				push af 
1853				; get address in hl 
1853			 
1853					if DEBUG_FORTH_MALLOC_INT 
1853						DMARK "fre" 
1853						CALLMONITOR 
1853					endif 
1853				; data is at hl - move to block count 
1853				dec hl 
1853				dec hl    ; get past pointer 
1853				dec hl 
1853			 
1853				ld a, (hl)    ; need this for a validation check 
1853			 
1853				dec hl    ; move to block marker 
1853			 
1853				; now check that the block count and block marker are the same  
1853			        ; this checks that we are on a malloc node and not random memory 
1853			        ; OK a faint chance this could be a problem but rare - famous last words! 
1853			 
1853				ld c, a 
1853				ld a, (hl)    
1853			 
1853				cp c 
1853				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1853			 
1853				; yes good chance we are on a malloc node 
1853			 
1853				ld a, 0      
1853				ld (hl), a   ; mark as free 
1853			 
1853				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1853			 
1853			.freeignore:  
1853			 
1853				pop af 
1853				pop hl 
1853			 
1853				ret 
1853			 
1853			 
1853			 
1853			endif 
1853			 
1853			; eof 
# End of file firmware_memory.asm
1853			  
1853			; device C  
1853			; Now handled by SPI  
1853			;if SOUND_ENABLE  
1853			;	include "firmware_sound.asm"  
1853			;endif  
1853			  
1853			include "firmware_diags.asm"  
1853			; Hardware diags menu 
1853			 
1853			 
1853			config: 
1853			 
1853 3e 00			ld a, 0 
1855 21 7e 18			ld hl, .configmn 
1858 cd cc 0d			call menu 
185b			 
185b fe 00			cp 0 
185d c8				ret z 
185e			 
185e			;	cp 1 
185e			;	call z, .savetostore 
185e			 
185e fe 01			cp 1 
1860			if STARTUP_V1 
1860				call z, .selautoload 
1860			endif 
1860			 
1860			if STARTUP_V2 
1860 cc 8c 18			call z, .enautoload 
1863			endif 
1863 fe 02			cp 2 
1865 cc a3 18			call z, .disautoload 
1868			;	cp 3 
1868			;	call z, .selbank 
1868 fe 03			cp 3 
186a cc 11 1b			call z, .debug_tog 
186d fe 04			cp 4 
186f cc 5f 1c			call z, .bpsgo 
1872 fe 05			cp 5 
1874 cc 3a 1b			call z, hardware_diags 
1877			if STARTUP_V2 
1877 fe 06			cp 6 
1879 cc cf 18			call z, create_startup 
187c			endif 
187c 18 d5			jr config 
187e			 
187e			.configmn: 
187e			;	dw prom_c3 
187e 4d 1e			dw prom_c2 
1880 63 1e			dw prom_c2a 
1882			;	dw prom_c2b 
1882			;	dw prom_c4 
1882 d0 1e			dw prom_m4 
1884 eb 1e			dw prom_m4b 
1886 f3 1e			dw prom_c1 
1888			if STARTUP_V2 
1888 02 1f			dw prom_c9 
188a			endif 
188a 00 00			dw 0 
188c				 
188c			 
188c			if STARTUP_V2 
188c			.enautoload: 
188c				if STORAGE_SE 
188c 3e fe			ld a, $fe      ; bit 0 clear 
188e 32 9b f9			ld (spi_device), a 
1891			 
1891 cd 16 05			call storage_get_block_0 
1894			 
1894 3e 01			ld a, 1 
1896 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
1899			 
1899 21 00 00				ld hl, 0 
189c 11 b5 f9				ld de, store_page 
189f cd ca 04			call storage_write_block	 ; save update 
18a2				else 
18a2			 
18a2				ld hl, prom_notav 
18a2				ld de, prom_empty 
18a2				call info_panel 
18a2				endif 
18a2			 
18a2			 
18a2 c9				ret 
18a3			endif 
18a3			 
18a3			.disautoload: 
18a3				if STORAGE_SE 
18a3 3e fe			ld a, $fe      ; bit 0 clear 
18a5 32 9b f9			ld (spi_device), a 
18a8			 
18a8 cd 16 05			call storage_get_block_0 
18ab			 
18ab 3e 00			ld a, 0 
18ad 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
18b0			 
18b0 21 00 00				ld hl, 0 
18b3 11 b5 f9				ld de, store_page 
18b6 cd ca 04			call storage_write_block	 ; save update 
18b9				else 
18b9			 
18b9				ld hl, prom_notav 
18b9				ld de, prom_empty 
18b9				call info_panel 
18b9				endif 
18b9			 
18b9			 
18b9 c9				ret 
18ba			 
18ba			if STARTUP_V1 
18ba			 
18ba			; Select auto start 
18ba			 
18ba			.selautoload: 
18ba			 
18ba				 
18ba				if STORAGE_SE 
18ba			 
18ba					call config_dir 
18ba				        ld hl, scratch 
18ba					ld a, 0 
18ba					call menu 
18ba			 
18ba					cp 0 
18ba					ret z 
18ba			 
18ba					dec a 
18ba			 
18ba			 
18ba					; locate menu option 
18ba			 
18ba					ld hl, scratch 
18ba					call table_lookup 
18ba			 
18ba					if DEBUG_FORTH_WORDS 
18ba						DMARK "ALl" 
18ba						CALLMONITOR 
18ba					endif 
18ba					; with the pointer to the menu it, the byte following the zero term is the file id 
18ba			 
18ba					ld a, 0 
18ba					ld bc, 50   ; max of bytes to look at 
18ba					cpir  
18ba			 
18ba					if DEBUG_FORTH_WORDS 
18ba						DMARK "ALb" 
18ba						CALLMONITOR 
18ba					endif 
18ba					;inc hl 
18ba			 
18ba					ld a, (hl)   ; file id 
18ba					 
18ba				        ; save bank and file ids 
18ba			 
18ba					push af 
18ba			 
18ba			; TODO need to save to block 0 on bank 1	 
18ba			 
18ba					call storage_get_block_0 
18ba			 
18ba					if DEBUG_FORTH_WORDS 
18ba						DMARK "AL0" 
18ba						CALLMONITOR 
18ba					endif 
18ba					pop af 
18ba			 
18ba					ld (store_page+STORE_0_FILERUN),a 
18ba					 
18ba					; save bank id 
18ba			 
18ba					ld a,(spi_device) 
18ba					ld (store_page+STORE_0_BANKRUN),a 
18ba			 
18ba					; enable auto run of store file 
18ba			 
18ba					ld a, 1 
18ba					ld (store_page+STORE_0_AUTOFILE),a 
18ba			 
18ba					; save buffer 
18ba			 
18ba					ld hl, 0 
18ba					ld de, store_page 
18ba					if DEBUG_FORTH_WORDS 
18ba						DMARK "ALw" 
18ba						CALLMONITOR 
18ba					endif 
18ba				call storage_write_block	 ; save update 
18ba			  
18ba			 
18ba			 
18ba			 
18ba					ld hl, scratch 
18ba					call config_fdir 
18ba			 
18ba				else 
18ba			 
18ba				ld hl, prom_notav 
18ba				ld de, prom_empty 
18ba				call info_panel 
18ba			 
18ba				endif 
18ba				ret 
18ba			endif 
18ba			 
18ba			 
18ba			; Select storage bank 
18ba			 
18ba			.selbank: 
18ba			 
18ba			;	if STORAGE_SE 
18ba			;	else 
18ba			 
18ba 21 17 1f			ld hl, prom_notav 
18bd 11 2d 1f			ld de, prom_empty 
18c0 cd 2c 0d			call info_panel 
18c3			;	endif 
18c3				 
18c3 c9				ret 
18c4			 
18c4			if STORAGE_SE 
18c4			 
18c4			.config_ldir:   
18c4				; Load storage bank labels into menu array 
18c4			 
18c4				 
18c4			 
18c4			 
18c4 c9				ret 
18c5			 
18c5			 
18c5			endif 
18c5			 
18c5			 
18c5			; Save user words to storage 
18c5			 
18c5			.savetostore: 
18c5			 
18c5			;	if STORAGE_SE 
18c5			; 
18c5			;		call config_dir 
18c5			;	        ld hl, scratch 
18c5			;		ld a, 0 
18c5			;		call menu 
18c5			;		 
18c5			;		ld hl, scratch 
18c5			;		call config_fdir 
18c5			; 
18c5			;	else 
18c5			 
18c5 21 17 1f			ld hl, prom_notav 
18c8 11 2d 1f			ld de, prom_empty 
18cb cd 2c 0d			call info_panel 
18ce			 
18ce			;	endif 
18ce			 
18ce c9				ret 
18cf			 
18cf			if STARTUP_V2 
18cf			 
18cf			create_startup: 
18cf			 
18cf 3e 00			ld a, 0 
18d1 21 38 1a			ld hl, .crstart 
18d4 cd cc 0d			call menu 
18d7			 
18d7 fe 00			cp 0 
18d9 c8				ret z 
18da			 
18da fe 01			cp 1 
18dc cc 09 19			call z, .genlsword 
18df fe 02			cp 2 
18e1 cc 13 19			call z, .genedword 
18e4			 
18e4 fe 03			cp 3 
18e6 cc 1d 19			call z, .gendemword 
18e9			 
18e9 fe 04			cp 4 
18eb cc 27 19			call z, .genutlword 
18ee fe 05			cp 5 
18f0 cc 31 19			call z, .genspiword 
18f3 fe 06			cp 6 
18f5 cc 3b 19			call z, .genkeyword 
18f8 fe 07			cp 7 
18fa cc ff 18			call z, .gensoundword 
18fd 18 d0			jr create_startup 
18ff			 
18ff			.gensoundword: 
18ff 21 bb 1e			ld hl, crs_sound 
1902 11 88 19			ld de, .soundworddef 
1905 cd 45 19			call .genfile 
1908 c9				ret 
1909			.genlsword: 
1909 21 7a 1e			ld hl, crs_s1 
190c 11 ac 19			ld de, .lsworddef 
190f cd 45 19			call .genfile 
1912 c9				ret 
1913			 
1913			.genedword: 
1913 11 b0 19			ld de, .edworddef 
1916 21 83 1e			ld hl, crs_s2 
1919 cd 45 19			call .genfile 
191c c9				ret 
191d			 
191d			.gendemword: 
191d 11 b8 19			ld de, .demoworddef 
1920 21 8c 1e			ld hl, crs_s3 
1923 cd 45 19			call .genfile 
1926 c9				ret 
1927			 
1927			.genutlword: 
1927 21 9b 1e			ld hl, crs_s4 
192a 11 9c 19			ld de, .utilwordef 
192d cd 45 19			call .genfile 
1930 c9				ret 
1931			.genspiword: 
1931 21 a2 1e			ld hl, crs_s5 
1934 11 fe 19			ld de, .spiworddef 
1937 cd 45 19			call .genfile 
193a c9				ret 
193b			.genkeyword: 
193b 21 ac 1e			ld hl, crs_s6 
193e 11 0c 1a			ld de, .keyworddef 
1941 cd 45 19			call .genfile 
1944 c9				ret 
1945			 
1945			; hl - points to file name 
1945			; de - points to strings to add to file 
1945			 
1945			.genfile: 
1945 e5				push hl 
1946 d5				push de 
1947			 
1947 cd 9b 0d			call clear_display 
194a 3e 00			ld a, display_row_1 
194c 11 77 19			ld de, .genfiletxt 
194f cd ae 0d			call str_at_display 
1952 cd be 0d			call update_display 
1955			 
1955 d1				pop de 
1956 e1				pop hl 
1957			 
1957			 
1957 d5				push de 
1958 cd 68 08			call storage_create 
195b				; id in hl 
195b d1				pop de   ; table of strings to add 
195c			 
195c			.genloop: 
195c			 
195c e5				push hl ; save id for next time around 
195d d5				push de ; save de for next time around 
195e			 
195e eb				ex de, hl 
195f cd 4a 26			call loadwordinhl 
1962 eb				ex de, hl 
1963			 
1963				; need hl to be the id 
1963				; need de to be the string ptr 
1963				 
1963 cd 55 0b			call storage_append 
1966			 
1966 d1				pop de 
1967 e1				pop hl 
1968			 
1968 13				inc de 
1969 13				inc de 
196a			 
196a 1a				ld a,(de) 
196b fe 00			cp 0 
196d 20 ed			jr nz, .genloop 
196f 13				inc de 
1970 1a				ld a, (de) 
1971 1b				dec de 
1972 fe 00			cp 0 
1974 20 e6			jr nz, .genloop	 
1976			 
1976 c9				ret 
1977			 
1977 .. 00		.genfiletxt:  db "Creating file...",0 
1988			 
1988			.soundworddef: 
1988 d3 6c			dw sound1 
198a f7 6c			dw sound2 
198c 27 6d			dw sound3 
198e 4c 6d			dw sound4 
1990 59 6d			dw sound5 
1992 66 6d			dw sound6 
1994 73 6d			dw sound7 
1996 80 6d			dw sound8 
1998 98 6d			dw sound9 
199a 00 00			dw 0 
199c			 
199c			.utilwordef: 
199c 24 66			dw strncpy 
199e ff 65			dw type 
19a0 cb 65			dw clrstack 
19a2 84 65			dw longread 
19a4 85 66			dw start1 
19a6 95 66			dw start2 
19a8			; duplicated 
19a8			;	dw start3b 
19a8			;	dw start3c 
19a8 81 67			dw list 
19aa 00 00			dw 0 
19ac			 
19ac			.lsworddef: 
19ac a6 66			dw start3b 
19ae 00 00			dw 0 
19b0			 
19b0			.edworddef: 
19b0 e3 61			dw edit1 
19b2 04 62			dw edit2 
19b4 39 62			dw edit3 
19b6 00 00			dw 0 
19b8			 
19b8			.demoworddef: 
19b8 c9 6b			dw test5 
19ba 01 6c			dw test6 
19bc 39 6c			dw test7 
19be 4d 6c			dw test8 
19c0 79 6c			dw test9 
19c2 8f 6c			dw test10 
19c4 af 6d			dw game1 
19c6 c0 6d			dw game1a 
19c8 22 6e			dw game1b 
19ca 57 6e			dw game1c 
19cc 8d 6e			dw game1d 
19ce be 6e			dw game1s 
19d0 d2 6e			dw game1t 
19d2 e7 6e			dw game1f 
19d4 1b 6f			dw game1z 
19d6 5f 6f			dw game1zz 
19d8 c8 6f			dw ssv2 
19da fe 6f			dw ssv3 
19dc 1a 70			dw ssv4 
19de 36 70			dw ssv5 
19e0 4f 70			dw ssv1 
19e2 97 70			dw ssv1cpm	 
19e4 ee 70			dw game2b 
19e6 5c 71			dw game2bf 
19e8 a6 71			dw game2mba 
19ea 3c 72			dw game2mbas	 
19ec 61 72			dw game2mbht 
19ee 70 72			dw game2mbms 
19f0 7e 72			dw game2mb 
19f2 fb 72			dw game3w 
19f4 29 73			dw game3p 
19f6 47 73			dw game3sc 
19f8 78 73			dw game3vsi 
19fa a4 73			dw game3vs 
19fc 00 00			dw 0 
19fe			 
19fe			 
19fe			.spiworddef: 
19fe			 
19fe 71 62		    dw spi1 
1a00 ca 62		    dw spi2 
1a02 fe 62		    dw spi2b 
1a04 82 63		    dw spi3 
1a06 2c 63		    dw spi4 
1a08 55 63		    dw spi5 
1a0a			;    dw spi6 
1a0a			;    dw spi7 
1a0a			 
1a0a			;    dw spi8 
1a0a			;    dw spi9 
1a0a			;    dw spi10 
1a0a 00 00		    dw 0 
1a0c			 
1a0c			.keyworddef: 
1a0c			 
1a0c e3 73			dw keyup 
1a0e f1 73			dw keydown 
1a10 01 74			dw keyleft 
1a12 11 74			dw keyright 
1a14 22 74			dw 	keyf1 
1a16 30 74			dw keyf2 
1a18 3e 74			dw keyf3 
1a1a 4c 74			dw keyf4 
1a1c 5a 74			dw keyf5 
1a1e 68 74			dw keyf6 
1a20 76 74			dw keyf7 
1a22 84 74			dw keyf8 
1a24 92 74			dw keyf9 
1a26 a0 74			dw keyf10 
1a28 af 74			dw keyf11 
1a2a be 74			dw keyf12 
1a2c cd 74			dw keytab 
1a2e dc 74			dw keycr 
1a30 ea 74			dw keyhome 
1a32 fa 74			dw keyend 
1a34 09 75			dw keybs 
1a36 00 00			dw 0 
1a38			 
1a38			.crstart: 
1a38 7a 1e			dw crs_s1 
1a3a 83 1e			dw crs_s2 
1a3c 8c 1e			dw crs_s3 
1a3e 9b 1e			dw crs_s4 
1a40 a2 1e			dw crs_s5 
1a42 ac 1e			dw crs_s6 
1a44 bb 1e			dw crs_sound 
1a46 00 00			dw 0 
1a48			 
1a48			endif 
1a48			 
1a48			 
1a48			if STORAGE_SE 
1a48			 
1a48			config_fdir: 
1a48				; using the scratch dir go through and release the memory allocated for each string 
1a48				 
1a48 21 fc f0			ld hl, scratch 
1a4b 5e			.cfdir:	ld e,(hl) 
1a4c 23				inc hl 
1a4d 56				ld d,(hl) 
1a4e 23				inc hl 
1a4f			 
1a4f eb				ex de, hl 
1a50 cd f8 0f			call ishlzero 
1a53 c8				ret z     ; return on null pointer 
1a54 cd 84 17			call free 
1a57 eb				ex de, hl 
1a58 18 f1			jr .cfdir 
1a5a			 
1a5a			 
1a5a c9				ret 
1a5b			 
1a5b			 
1a5b			config_dir: 
1a5b			 
1a5b				; for the config menus that need to build a directory of storage call this routine 
1a5b				; it will construct a menu in scratch to pass to menu 
1a5b			 
1a5b				; open storage device 
1a5b			 
1a5b				; execute DIR to build a list of files and their ids into scratch in menu format 
1a5b				; once the menu has finished then will need to call config_fdir to release the strings 
1a5b				 
1a5b				; c = number items 
1a5b			 
1a5b				 
1a5b cd 16 05			call storage_get_block_0 
1a5e			 
1a5e 21 b5 f9			ld hl, store_page     ; get current id count 
1a61 46				ld b, (hl) 
1a62 0e 00			ld c, 0    ; count of files   
1a64			 
1a64			 
1a64 21 fc f0			ld hl, scratch 
1a67 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
1a6a			 
1a6a				; check for empty drive 
1a6a			 
1a6a 3e 00			ld a, 0 
1a6c b8				cp b 
1a6d ca 07 1b			jp z, .dirdone 
1a70			 
1a70				 
1a70					if DEBUG_FORTH_WORDS 
1a70						DMARK "Cdc" 
1a70 f5				push af  
1a71 3a 85 1a			ld a, (.dmark)  
1a74 32 a6 fd			ld (debug_mark),a  
1a77 3a 86 1a			ld a, (.dmark+1)  
1a7a 32 a7 fd			ld (debug_mark+1),a  
1a7d 3a 87 1a			ld a, (.dmark+2)  
1a80 32 a8 fd			ld (debug_mark+2),a  
1a83 18 03			jr .pastdmark  
1a85 ..			.dmark: db "Cdc"  
1a88 f1			.pastdmark: pop af  
1a89			endm  
# End of macro DMARK
1a89						CALLMONITOR 
1a89 cd aa fd			call debug_vector  
1a8c				endm  
# End of macro CALLMONITOR
1a8c					endif 
1a8c			 
1a8c			 
1a8c			.diritem:	 
1a8c c5				push bc 
1a8d				; for each of the current ids do a search for them and if found push to stack 
1a8d			 
1a8d 21 40 00				ld hl, STORE_BLOCK_PHY 
1a90 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1a92 58					ld e,b 
1a93			 
1a93 cd 98 07				call storage_findnextid 
1a96			 
1a96			 
1a96					; if found hl will be non zero 
1a96			 
1a96 cd f8 0f				call ishlzero 
1a99 28 69				jr z, .dirnotfound 
1a9b			 
1a9b					; increase count 
1a9b			 
1a9b c1					pop bc	 
1a9c 0c					inc c 
1a9d c5					push bc 
1a9e					 
1a9e			 
1a9e					; get file header and push the file name 
1a9e			 
1a9e 11 b5 f9				ld de, store_page 
1aa1 cd 65 04				call storage_read_block 
1aa4			 
1aa4					; push file id to stack 
1aa4				 
1aa4 3a b5 f9				ld a, (store_page) 
1aa7 26 00				ld h, 0 
1aa9 6f					ld l, a 
1aaa			 
1aaa					;call forth_push_numhl 
1aaa					; TODO store id 
1aaa			 
1aaa e5					push hl 
1aab			 
1aab					; push extent count to stack  
1aab				 
1aab 21 b8 f9				ld hl, store_page+3 
1aae			 
1aae					; get file name length 
1aae			 
1aae cd 45 16				call strlenz   
1ab1			 
1ab1 23					inc hl   ; cover zero term 
1ab2 23					inc hl  ; stick the id at the end of the area 
1ab3			 
1ab3 e5					push hl 
1ab4 c1					pop bc    ; move length to bc 
1ab5			 
1ab5 cd ba 16				call malloc 
1ab8			 
1ab8					; TODO save malloc area to scratch 
1ab8			 
1ab8 eb					ex de, hl 
1ab9 2a ac f9				ld hl, (store_tmp2) 
1abc 73					ld (hl), e 
1abd 23					inc hl 
1abe 72					ld (hl), d 
1abf 23					inc hl 
1ac0 22 ac f9				ld (store_tmp2), hl 
1ac3			 
1ac3					 
1ac3			 
1ac3					;pop hl   ; get source 
1ac3			;		ex de, hl    ; swap aronund	 
1ac3			 
1ac3 21 b8 f9				ld hl, store_page+3 
1ac6					if DEBUG_FORTH_WORDS 
1ac6						DMARK "CFd" 
1ac6 f5				push af  
1ac7 3a db 1a			ld a, (.dmark)  
1aca 32 a6 fd			ld (debug_mark),a  
1acd 3a dc 1a			ld a, (.dmark+1)  
1ad0 32 a7 fd			ld (debug_mark+1),a  
1ad3 3a dd 1a			ld a, (.dmark+2)  
1ad6 32 a8 fd			ld (debug_mark+2),a  
1ad9 18 03			jr .pastdmark  
1adb ..			.dmark: db "CFd"  
1ade f1			.pastdmark: pop af  
1adf			endm  
# End of macro DMARK
1adf						CALLMONITOR 
1adf cd aa fd			call debug_vector  
1ae2				endm  
# End of macro CALLMONITOR
1ae2					endif 
1ae2 ed b0				ldir 
1ae4			 
1ae4					; de is past string, move back one and store id 
1ae4					 
1ae4 1b					dec de 
1ae5			 
1ae5					; store file id 
1ae5			 
1ae5 e1					pop hl 
1ae6 eb					ex de,hl 
1ae7 73					ld (hl), e 
1ae8			 
1ae8					if DEBUG_FORTH_WORDS 
1ae8						DMARK "Cdi" 
1ae8 f5				push af  
1ae9 3a fd 1a			ld a, (.dmark)  
1aec 32 a6 fd			ld (debug_mark),a  
1aef 3a fe 1a			ld a, (.dmark+1)  
1af2 32 a7 fd			ld (debug_mark+1),a  
1af5 3a ff 1a			ld a, (.dmark+2)  
1af8 32 a8 fd			ld (debug_mark+2),a  
1afb 18 03			jr .pastdmark  
1afd ..			.dmark: db "Cdi"  
1b00 f1			.pastdmark: pop af  
1b01			endm  
# End of macro DMARK
1b01						CALLMONITOR 
1b01 cd aa fd			call debug_vector  
1b04				endm  
# End of macro CALLMONITOR
1b04					endif 
1b04					 
1b04			.dirnotfound: 
1b04 c1					pop bc     
1b05 10 85				djnz .diritem 
1b07				 
1b07			.dirdone:	 
1b07			 
1b07 3e 00				ld a, 0 
1b09 2a ac f9				ld hl, (store_tmp2) 
1b0c 77					ld (hl), a 
1b0d 23					inc hl 
1b0e 77					ld (hl), a 
1b0f 23					inc hl 
1b10					; push a count of the dir items found 
1b10			 
1b10			;		ld h, 0 
1b10			;		ld l, c 
1b10			 
1b10 c9				ret 
1b11			 
1b11			endif 
1b11			 
1b11			 
1b11			; Settings 
1b11			; Run  
1b11			 
1b11			 
1b11			 
1b11			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1b11			;;hd_menu2:   db "        2: Editor",0   
1b11			;hd_menu2:   db "        2: Editor       6: Menu",0   
1b11			;hd_menu3:   db "        3: Storage",0 
1b11			;hd_menu4:   db "0=quit  4: Debug",0 
1b11			;hd_don:     db "ON",0 
1b11			;hd_doff:     db "OFF",0 
1b11			; 
1b11			; 
1b11			; 
1b11			;hardware_diags_old:       
1b11			; 
1b11			;.diagmenu: 
1b11			;	call clear_display 
1b11			;	ld a, display_row_1 
1b11			;	ld de, hd_menu1 
1b11			;	call str_at_display 
1b11			; 
1b11			;	ld a, display_row_2 
1b11			;	ld de, hd_menu2 
1b11			;	call str_at_display 
1b11			; 
1b11			;	ld a, display_row_3 
1b11			;	ld de, hd_menu3 
1b11			;	call str_at_display 
1b11			; 
1b11			;	ld a,  display_row_4 
1b11			;	ld de, hd_menu4 
1b11			;	call str_at_display 
1b11			; 
1b11			;	; display debug state 
1b11			; 
1b11			;	ld de, hd_don 
1b11			;	ld a, (os_view_disable) 
1b11			;	cp 0 
1b11			;	jr z, .distog 
1b11			;	ld de, hd_doff 
1b11			;.distog: ld a, display_row_4+17 
1b11			;	call str_at_display 
1b11			; 
1b11			;	call update_display 
1b11			; 
1b11			;	call cin_wait 
1b11			; 
1b11			; 
1b11			; 
1b11			;	cp '4' 
1b11			;	jr nz, .diagn1 
1b11			; 
1b11			;	; debug toggle 
1b11			; 
1b11			;	ld a, (os_view_disable) 
1b11			;	ld b, '*' 
1b11			;	cp 0 
1b11			;	jr z, .debtog 
1b11			;	ld b, 0 
1b11			;.debtog:	 
1b11			;	ld a,b 
1b11			;	ld (os_view_disable),a 
1b11			; 
1b11			;.diagn1: cp '0' 
1b11			;	 ret z 
1b11			; 
1b11			;;	cp '1' 
1b11			;;       jp z, matrix	 
1b11			;;   TODO keyboard matrix test 
1b11			; 
1b11			;	cp '2' 
1b11			;	jp z, .diagedit 
1b11			; 
1b11			;;	cp '6' 
1b11			;;	jp z, .menutest 
1b11			;;if ENABLE_BASIC 
1b11			;;	cp '6' 
1b11			;;	jp z, basic 
1b11			;;endif 
1b11			 ; 
1b11			;	jp .diagmenu 
1b11			; 
1b11			; 
1b11			;	ret 
1b11			 
1b11			 
1b11			.debug_tog: 
1b11 21 5b 1b			ld hl, .menudebug 
1b14				 
1b14			;	ld a, (os_view_disable) 
1b14			;	cp '*' 
1b14 3a aa fd			ld a,(debug_vector) 
1b17 fe c9			cp $C9   ; RET 
1b19 20 04			jr nz,.tdon  
1b1b 3e 01			ld a, 1 
1b1d 18 02			jr .tog1 
1b1f 3e 00		.tdon: ld a, 0 
1b21			 
1b21			.tog1: 
1b21 cd cc 0d			call menu 
1b24 fe 00			cp 0 
1b26 c8				ret z 
1b27 fe 01			cp 1    ; disable debug 
1b29 28 04			jr z, .dtog0 
1b2b 3e 2a			ld a, '*' 
1b2d 18 05			jr .dtogset 
1b2f			.dtog0:  
1b2f				;ld a, 0 
1b2f cd 4d 1c			call bp_on 
1b32 18 dd			jr .debug_tog 
1b34			.dtogset:  
1b34				; ld (os_view_disable), a 
1b34 cd 59 1c			call bp_off 
1b37 c3 11 1b			jp .debug_tog 
1b3a			 
1b3a			 
1b3a			hardware_diags:       
1b3a			 
1b3a			.diagm: 
1b3a 21 4d 1b			ld hl, .menuitems 
1b3d 3e 00			ld a, 0 
1b3f cd cc 0d			call menu 
1b42			 
1b42 fe 00		         cp 0 
1b44 c8				 ret z 
1b45			 
1b45 fe 02			cp 2 
1b47 ca a6 1b			jp z, .diagedit 
1b4a			 
1b4a			;	cp '6' 
1b4a			;	jp z, .menutest 
1b4a			;if ENABLE_BASIC 
1b4a			;	cp '6' 
1b4a			;	jp z, basic 
1b4a			;endif 
1b4a			  
1b4a c3 3a 1b			jp .diagm 
1b4d			 
1b4d				 
1b4d 61 1b		.menuitems:   	dw .m1 
1b4f 6c 1b				dw .m2 
1b51 73 1b				dw .m3 
1b53 7b 1b				dw .m5 
1b55 81 1b				dw .m5a 
1b57 8a 1b				dw .m5b 
1b59 00 00				dw 0 
1b5b			 
1b5b			.menudebug: 
1b5b 93 1b				dw .m6 
1b5d 9c 1b				dw .m7 
1b5f 00 00				dw 0 
1b61			 
1b61 .. 00		.m1:   db "Key Matrix",0 
1b6c .. 00		.m2:   db "Editor",0 
1b73 .. 00		.m3:   db "Storage",0 
1b7b .. 00		.m5:   db "Sound",0 
1b81 .. 00		.m5a:  db "RAM Test",0 
1b8a .. 00		.m5b:  db "LCD Test",0 
1b93			 
1b93 .. 00		.m6:   db "Debug ON",0 
1b9c .. 00		.m7:   db "Debug OFF",0 
1ba6			 
1ba6			; debug editor 
1ba6			 
1ba6			.diagedit: 
1ba6			 
1ba6 21 fc f0			ld hl, scratch 
1ba9			;	ld bc, 250 
1ba9			;	ldir 
1ba9				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ba9 3e 00			ld a, 0 
1bab 77				ld (hl), a 
1bac 23				inc hl 
1bad 77				ld (hl), a 
1bae 23				inc hl 
1baf 77				ld (hl), a 
1bb0			 
1bb0 cd 9b 0d		        call clear_display 
1bb3 cd be 0d			call update_display 
1bb6				;ld a, 1 
1bb6				;ld (hardware_diag), a 
1bb6			.diloop: 
1bb6 3e 00			ld a, display_row_1 
1bb8 0e 00			ld c, 0 
1bba 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bbc 1e 28			ld e, 40 
1bbe			 
1bbe 21 fc f0			ld hl, scratch	 
1bc1 cd fc 0f			call input_str 
1bc4			 
1bc4 3e 28			ld a, display_row_2 
1bc6 11 fc f0			ld de, scratch 
1bc9 cd ae 0d			call str_at_display 
1bcc cd be 0d			call update_display 
1bcf			 
1bcf c3 b6 1b			jp .diloop 
1bd2			 
1bd2			 
1bd2			; pass word in hl 
1bd2			; a has display location 
1bd2			display_word_at: 
1bd2 f5				push af 
1bd3 e5				push hl 
1bd4 7c				ld a,h 
1bd5 21 01 f4			ld hl, os_word_scratch 
1bd8 cd e8 14			call hexout 
1bdb e1				pop hl 
1bdc 7d				ld a,l 
1bdd 21 03 f4			ld hl, os_word_scratch+2 
1be0 cd e8 14			call hexout 
1be3 21 05 f4			ld hl, os_word_scratch+4 
1be6 3e 00			ld a,0 
1be8 77				ld (hl),a 
1be9 11 01 f4			ld de,os_word_scratch 
1bec f1				pop af 
1bed cd ae 0d				call str_at_display 
1bf0 c9				ret 
1bf1			 
1bf1			display_ptr_state: 
1bf1			 
1bf1				; to restore afterwards 
1bf1			 
1bf1 d5				push de 
1bf2 c5				push bc 
1bf3 e5				push hl 
1bf4 f5				push af 
1bf5			 
1bf5				; for use in here 
1bf5			 
1bf5			;	push bc 
1bf5			;	push de 
1bf5			;	push hl 
1bf5			;	push af 
1bf5			 
1bf5 cd 9b 0d			call clear_display 
1bf8			 
1bf8 11 d0 1d			ld de, .ptrstate 
1bfb 3e 00			ld a, display_row_1 
1bfd cd ae 0d			call str_at_display 
1c00			 
1c00				; display debug step 
1c00			 
1c00			 
1c00 11 a6 fd			ld de, debug_mark 
1c03 3e 26			ld a, display_row_1+display_cols-2 
1c05 cd ae 0d			call str_at_display 
1c08			 
1c08				; display a 
1c08 11 da 1d			ld de, .ptrcliptr 
1c0b 3e 28			ld a, display_row_2 
1c0d cd ae 0d			call str_at_display 
1c10			 
1c10 f1				pop af 
1c11 2a 7b f9			ld hl,(cli_ptr) 
1c14 3e 30			ld a, display_row_2+8 
1c16 cd d2 1b			call display_word_at 
1c19			 
1c19			 
1c19				; display hl 
1c19			 
1c19			 
1c19 11 e2 1d			ld de, .ptrclioptr 
1c1c 3e 32			ld a, display_row_2+10 
1c1e cd ae 0d			call str_at_display 
1c21			; 
1c21			;	pop hl 
1c21 3e 35			ld a, display_row_2+13 
1c23 2a 79 f9			ld hl,(cli_origptr) 
1c26 cd d2 1b			call display_word_at 
1c29			; 
1c29			;	 
1c29			;	; display de 
1c29			 
1c29			;	ld de, .regstatede 
1c29			;	ld a, display_row_3 
1c29			;	call str_at_display 
1c29			 
1c29			;	pop de 
1c29			;	ld h,d 
1c29			;	ld l, e 
1c29			;	ld a, display_row_3+3 
1c29			;	call display_word_at 
1c29			 
1c29			 
1c29				; display bc 
1c29			 
1c29			;	ld de, .regstatebc 
1c29			;	ld a, display_row_3+10 
1c29			;	call str_at_display 
1c29			 
1c29			;	pop bc 
1c29			;	ld h,b 
1c29			;	ld l, c 
1c29			;	ld a, display_row_3+13 
1c29			;	call display_word_at 
1c29			 
1c29			 
1c29				; display dsp 
1c29			 
1c29			;	ld de, .regstatedsp 
1c29			;	ld a, display_row_4 
1c29			;	call str_at_display 
1c29			 
1c29				 
1c29			;	ld hl,(cli_data_sp) 
1c29			;	ld a, display_row_4+4 
1c29			;	call display_word_at 
1c29			 
1c29				; display rsp 
1c29			 
1c29 11 11 1e			ld de, .regstatersp 
1c2c 3e 82			ld a, display_row_4+10 
1c2e cd ae 0d			call str_at_display 
1c31			 
1c31				 
1c31 2a 2d f9			ld hl,(cli_ret_sp) 
1c34 3e 86			ld a, display_row_4+14 
1c36 cd d2 1b			call display_word_at 
1c39			 
1c39 cd be 0d			call update_display 
1c3c			 
1c3c cd de 0c			call delay1s 
1c3f cd de 0c			call delay1s 
1c42 cd de 0c			call delay1s 
1c45			 
1c45			 
1c45 cd 93 22			call next_page_prompt 
1c48			 
1c48				; restore  
1c48			 
1c48 f1				pop af 
1c49 e1				pop hl 
1c4a c1				pop bc 
1c4b d1				pop de 
1c4c c9				ret 
1c4d			 
1c4d			; Update the break point vector so that the user can hook a new routine 
1c4d			 
1c4d			bp_on: 
1c4d 3e c3			ld a, $c3    ; JP 
1c4f 32 aa fd			ld (debug_vector), a 
1c52 21 5f 1c			ld hl, break_point_state 
1c55 22 ab fd			ld (debug_vector+1), hl 
1c58 c9				ret 
1c59			 
1c59			bp_off: 
1c59 3e c9			ld a, $c9    ; RET 
1c5b 32 aa fd			ld (debug_vector), a 
1c5e c9				ret 
1c5f			 
1c5f			 
1c5f			break_point_state: 
1c5f			;	push af 
1c5f			; 
1c5f			;	; see if disabled 
1c5f			; 
1c5f			;	ld a, (os_view_disable) 
1c5f			;	cp '*' 
1c5f			;	jr nz, .bpsgo 
1c5f			;	pop af 
1c5f			;	ret 
1c5f			 
1c5f			.bpsgo: 
1c5f			;	pop af 
1c5f f5				push af 
1c60 22 de f0			ld (os_view_hl), hl 
1c63 ed 53 dc f0		ld (os_view_de), de 
1c67 ed 43 da f0		ld (os_view_bc), bc 
1c6b e5				push hl 
1c6c 6f				ld l, a 
1c6d 26 00			ld h, 0 
1c6f 22 e0 f0			ld (os_view_af),hl 
1c72			 
1c72 21 ec fc				ld hl, display_fb0 
1c75 22 07 fb				ld (display_fb_active), hl 
1c78 e1				pop hl	 
1c79			 
1c79 3e 31			ld a, '1' 
1c7b fe 2a		.bps1:  cp '*' 
1c7d cc 59 1c			call z, bp_off 
1c80			;	jr nz, .bps1b 
1c80			;	ld (os_view_disable),a 
1c80 fe 31		.bps1b:  cp '1' 
1c82 20 14			jr nz, .bps2 
1c84			 
1c84				; display reg 
1c84			 
1c84				 
1c84			 
1c84 3a e0 f0			ld a, (os_view_af) 
1c87 2a de f0			ld hl, (os_view_hl) 
1c8a ed 5b dc f0		ld de, (os_view_de) 
1c8e ed 4b da f0		ld bc, (os_view_bc) 
1c92 cd 2c 1d			call display_reg_state 
1c95 c3 18 1d			jp .bpschk 
1c98			 
1c98 fe 32		.bps2:  cp '2' 
1c9a 20 08			jr nz, .bps3 
1c9c				 
1c9c				; display hl 
1c9c 2a de f0			ld hl, (os_view_hl) 
1c9f cd 16 1e			call display_dump_at_hl 
1ca2			 
1ca2 18 74			jr .bpschk 
1ca4			 
1ca4 fe 33		.bps3:  cp '3' 
1ca6 20 08			jr nz, .bps4 
1ca8			 
1ca8			        ; display de 
1ca8 2a dc f0			ld hl, (os_view_de) 
1cab cd 16 1e			call display_dump_at_hl 
1cae			 
1cae 18 68			jr .bpschk 
1cb0 fe 34		.bps4:  cp '4' 
1cb2 20 08			jr nz, .bps5 
1cb4			 
1cb4			        ; display bc 
1cb4 2a da f0			ld hl, (os_view_bc) 
1cb7 cd 16 1e			call display_dump_at_hl 
1cba			 
1cba 18 5c			jr .bpschk 
1cbc fe 35		.bps5:  cp '5' 
1cbe 20 08		        jr nz, .bps7 
1cc0			 
1cc0				; display cur ptr 
1cc0 2a 7b f9			ld hl, (cli_ptr) 
1cc3 cd 16 1e			call display_dump_at_hl 
1cc6			 
1cc6 18 50			jr .bpschk 
1cc8 fe 36		.bps7:  cp '6' 
1cca 20 08			jr nz, .bps8b 
1ccc				 
1ccc				; display cur orig ptr 
1ccc 2a 79 f9			ld hl, (cli_origptr) 
1ccf cd 16 1e			call display_dump_at_hl 
1cd2 18 44			jr .bpschk 
1cd4 fe 37		.bps8b:  cp '7' 
1cd6 20 08			jr nz, .bps9 
1cd8				 
1cd8				; display dsp 
1cd8 2a 29 f9			ld hl, (cli_data_sp) 
1cdb cd 16 1e			call display_dump_at_hl 
1cde			 
1cde 18 38			jr .bpschk 
1ce0 fe 39		.bps9:  cp '9' 
1ce2 20 05			jr nz, .bps8c 
1ce4				 
1ce4				; display SP 
1ce4			;	ld hl, sp 
1ce4 cd 16 1e			call display_dump_at_hl 
1ce7			 
1ce7 18 2f			jr .bpschk 
1ce9 fe 38		.bps8c:  cp '8' 
1ceb 20 08			jr nz, .bps8d 
1ced				 
1ced				; display rsp 
1ced 2a 2d f9			ld hl, (cli_ret_sp) 
1cf0 cd 16 1e			call display_dump_at_hl 
1cf3			 
1cf3 18 23			jr .bpschk 
1cf5 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1cf7 20 05			jr nz, .bps8 
1cf9 cd 61 20			call monitor 
1cfc			 
1cfc 18 1a			jr .bpschk 
1cfe fe 30		.bps8:  cp '0' 
1d00 20 16			jr nz, .bpschk 
1d02			 
1d02 21 4b fc				ld hl, display_fb1 
1d05 22 07 fb				ld (display_fb_active), hl 
1d08 cd be 0d				call update_display 
1d0b			 
1d0b				;ld a, (os_view_af) 
1d0b 2a de f0			ld hl, (os_view_hl) 
1d0e ed 5b dc f0		ld de, (os_view_de) 
1d12 ed 4b da f0		ld bc, (os_view_bc) 
1d16 f1				pop af 
1d17 c9				ret 
1d18			 
1d18			.bpschk:   
1d18 cd de 0c			call delay1s 
1d1b 3e 9f		ld a,display_row_4 + display_cols - 1 
1d1d 11 91 22		        ld de, endprg 
1d20 cd ae 0d			call str_at_display 
1d23 cd be 0d			call update_display 
1d26 cd 84 7c			call cin_wait 
1d29			 
1d29 c3 7b 1c			jp .bps1 
1d2c			 
1d2c			 
1d2c			display_reg_state: 
1d2c			 
1d2c				; to restore afterwards 
1d2c			 
1d2c d5				push de 
1d2d c5				push bc 
1d2e e5				push hl 
1d2f f5				push af 
1d30			 
1d30				; for use in here 
1d30			 
1d30 c5				push bc 
1d31 d5				push de 
1d32 e5				push hl 
1d33 f5				push af 
1d34			 
1d34 cd 9b 0d			call clear_display 
1d37			 
1d37 11 ec 1d			ld de, .regstate 
1d3a 3e 00			ld a, display_row_1 
1d3c cd ae 0d			call str_at_display 
1d3f			 
1d3f				; display debug step 
1d3f			 
1d3f			 
1d3f 11 a6 fd			ld de, debug_mark 
1d42 3e 25			ld a, display_row_1+display_cols-3 
1d44 cd ae 0d			call str_at_display 
1d47			 
1d47				; display a 
1d47 11 08 1e			ld de, .regstatea 
1d4a 3e 28			ld a, display_row_2 
1d4c cd ae 0d			call str_at_display 
1d4f			 
1d4f e1				pop hl 
1d50			;	ld h,0 
1d50			;	ld l, a 
1d50 3e 2b			ld a, display_row_2+3 
1d52 cd d2 1b			call display_word_at 
1d55			 
1d55			 
1d55				; display hl 
1d55			 
1d55			 
1d55 11 fc 1d			ld de, .regstatehl 
1d58 3e 32			ld a, display_row_2+10 
1d5a cd ae 0d			call str_at_display 
1d5d			 
1d5d e1				pop hl 
1d5e 3e 35			ld a, display_row_2+13 
1d60 cd d2 1b			call display_word_at 
1d63			 
1d63				 
1d63				; display de 
1d63			 
1d63 11 00 1e			ld de, .regstatede 
1d66 3e 50			ld a, display_row_3 
1d68 cd ae 0d			call str_at_display 
1d6b			 
1d6b e1				pop hl 
1d6c			;	ld h,d 
1d6c			;	ld l, e 
1d6c 3e 53			ld a, display_row_3+3 
1d6e cd d2 1b			call display_word_at 
1d71			 
1d71			 
1d71				; display bc 
1d71			 
1d71 11 04 1e			ld de, .regstatebc 
1d74 3e 5a			ld a, display_row_3+10 
1d76 cd ae 0d			call str_at_display 
1d79			 
1d79 e1				pop hl 
1d7a			;	ld h,b 
1d7a			;	ld l, c 
1d7a 3e 5d			ld a, display_row_3+13 
1d7c cd d2 1b			call display_word_at 
1d7f			 
1d7f			 
1d7f				; display dsp 
1d7f			 
1d7f 11 0c 1e			ld de, .regstatedsp 
1d82 3e 78			ld a, display_row_4 
1d84 cd ae 0d			call str_at_display 
1d87			 
1d87				 
1d87 2a 29 f9			ld hl,(cli_data_sp) 
1d8a 3e 7c			ld a, display_row_4+4 
1d8c cd d2 1b			call display_word_at 
1d8f			 
1d8f				; display rsp 
1d8f			 
1d8f 11 11 1e			ld de, .regstatersp 
1d92 3e 82			ld a, display_row_4+10 
1d94 cd ae 0d			call str_at_display 
1d97			 
1d97				 
1d97 2a 2d f9			ld hl,(cli_ret_sp) 
1d9a 3e 86			ld a, display_row_4+14 
1d9c cd d2 1b			call display_word_at 
1d9f			 
1d9f cd be 0d			call update_display 
1da2			 
1da2			;	call delay1s 
1da2			;	call delay1s 
1da2			;	call delay1s 
1da2			 
1da2			 
1da2			;	call next_page_prompt 
1da2			 
1da2				; restore  
1da2			 
1da2 f1				pop af 
1da3 e1				pop hl 
1da4 c1				pop bc 
1da5 d1				pop de 
1da6 c9				ret 
1da7			 
1da7 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1dbb .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1dd0 .. 00		.ptrstate:	db "Ptr State",0 
1dda .. 00		.ptrcliptr:     db "cli_ptr",0 
1de2 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1dec .. 00		.regstate:	db "Reg State (1/0)",0 
1dfc .. 00		.regstatehl:	db "HL:",0 
1e00 .. 00		.regstatede:	db "DE:",0 
1e04 .. 00		.regstatebc:	db "BC:",0 
1e08 .. 00		.regstatea:	db "A :",0 
1e0c .. 00		.regstatedsp:	db "DSP:",0 
1e11 .. 00		.regstatersp:	db "RSP:",0 
1e16			 
1e16			display_dump_at_hl: 
1e16 e5				push hl 
1e17 d5				push de 
1e18 c5				push bc 
1e19 f5				push af 
1e1a			 
1e1a 22 1f f4			ld (os_cur_ptr),hl	 
1e1d cd 9b 0d			call clear_display 
1e20 cd 9b 21			call dumpcont 
1e23			;	call delay1s 
1e23			;	call next_page_prompt 
1e23			 
1e23			 
1e23 f1				pop af 
1e24 c1				pop bc 
1e25 d1				pop de 
1e26 e1				pop hl 
1e27 c9				ret 
1e28			 
1e28			;if ENABLE_BASIC 
1e28			;	include "nascombasic.asm" 
1e28			;	basic: 
1e28			;	include "forth/FORTH.ASM" 
1e28			;endif 
1e28			 
1e28			; eof 
1e28			 
1e28			 
# End of file firmware_diags.asm
1e28			  
1e28			include "firmware_prompts.asm"  
1e28			; Prompts  
1e28			 
1e28			; boot messages 
1e28			 
1e28 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1e3d .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1e4d			 
1e4d			 
1e4d			; config menus 
1e4d			 
1e4d			;prom_c3: db "Add Dictionary To File",0 
1e4d			 
1e4d			if STARTUP_V1 
1e4d			prom_c2: db "Select Autoload File",0 
1e4d			prom_c2a: db "Disable Autoload File", 0 
1e4d			endif 
1e4d			 
1e4d			if STARTUP_V2 
1e4d .. 00		prom_c2: db "Enable Autoload Files",0 
1e63 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1e7a			 
1e7a .. 00		crs_s1: db "*ls-word", 0 
1e83 .. 00		crs_s2: db "*ed-word", 0 
1e8c .. 00		crs_s3: db "*Demo-Programs", 0 
1e9b .. 00		crs_s4: db "*Utils", 0 
1ea2 .. 00		crs_s5: db "*SPI-Util", 0 
1eac .. 00		crs_s6: db "*Key-constants", 0 
1ebb .. 00		crs_sound: db "*Sound-Util", 0 
1ec7			 
1ec7			 
1ec7			 
1ec7			endif 
1ec7			;prom_c2b: db "Select Storage Bank",0 
1ec7 .. 00		prom_c4: db "Settings",0 
1ed0 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1eeb .. 00		prom_m4b:   db "Monitor",0 
1ef3 .. 00		prom_c1: db "Hardware Diags",0 
1f02			 
1f02			 
1f02			if STARTUP_V2 
1f02 .. 00		prom_c9: db "Create Startup Files",0 
1f17			endif 
1f17			 
1f17 .. 00		prom_notav:    db "Feature not available",0 
1f2d .. 00		prom_empty:    db "",0 
1f2e			 
1f2e			; eof 
1f2e			 
# End of file firmware_prompts.asm
1f2e			  
1f2e			  
1f2e			; eof  
1f2e			  
# End of file firmware.asm
1f2e			 
1f2e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1f2e			;if BASE_KEV  
1f2e			;baseram: equ 08000h 
1f2e			;endif 
1f2e			 
1f2e			;if BASE_SC114 
1f2e			;baseram:     equ    endofcode 
1f2e			;endif 
1f2e			 
1f2e			 
1f2e			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1f2e			 
1f2e			; start system 
1f2e			 
1f2e			coldstart: 
1f2e				; set sp 
1f2e				; di/ei 
1f2e			 
1f2e f3				di 
1f2f 31 fd ff			ld sp, tos 
1f32 cd 0b 79			call init_nmi 
1f35			;	ei 
1f35			 
1f35				; init spinner 
1f35 3e 00			ld a,0 
1f37 32 01 fb			ld (display_active), a 
1f3a			 
1f3a				; disable breakpoint by default 
1f3a			 
1f3a				;ld a,'*' 
1f3a			;	ld a,' ' 
1f3a			;	ld (os_view_disable),a 
1f3a			 
1f3a				; set break point vector as new break point on or off 
1f3a cd 59 1c			call bp_off 
1f3d			 
1f3d				; init hardware 
1f3d			 
1f3d				; init keyboard and screen hardware 
1f3d			 
1f3d cd 68 00			call hardware_init 
1f40			 
1f40			 
1f40 cd de 0c			call delay1s 
1f43 3e 58			ld a, display_row_3+8 
1f45 11 03 00			ld de, buildtime 
1f48 cd ae 0d			call str_at_display 
1f4b cd be 0d			call update_display 
1f4e			 
1f4e cd de 0c			call delay1s 
1f51 cd de 0c			call delay1s 
1f54 cd de 0c			call delay1s 
1f57			 
1f57				; detect if any keys are held down to enable breakpoints at start up 
1f57			 
1f57 cd 95 7c			call cin  
1f5a fe 00			cp 0 
1f5c 28 03			jr z, .nokeys 
1f5e			 
1f5e				;call hardware_diags 
1f5e cd 53 18			call config 
1f61			 
1f61			;	ld de, .bpen 
1f61			;	ld a, display_row_4 
1f61			;	call str_at_display 
1f61			;	call update_display 
1f61			; 
1f61			;	ld a,0 
1f61			;	ld (os_view_disable),a 
1f61			; 
1f61			;.bpwait: 
1f61			;	call cin 
1f61			;	cp 0 
1f61			;	jr z, .bpwait 
1f61			;	jr .nokeys 
1f61			; 
1f61			; 
1f61			;.bpen:  db "Break points enabled!",0 
1f61			 
1f61			 
1f61			 
1f61			 
1f61			 
1f61			 
1f61			.nokeys: 
1f61			 
1f61			 
1f61				 
1f61			 
1f61			;jp  testkey 
1f61			 
1f61			;call storage_get_block_0 
1f61			; 
1f61			;ld hl, 0 
1f61			;ld de, store_page 
1f61			;call storage_read_block 
1f61			 
1f61				 
1f61			;ld hl, 10 
1f61			;ld de, store_page 
1f61			;call storage_read_block 
1f61			 
1f61			 
1f61			 
1f61			 
1f61			 
1f61			;stop:	nop 
1f61			;	jp stop 
1f61			 
1f61			 
1f61			 
1f61			main: 
1f61 cd 9b 0d			call clear_display 
1f64 cd be 0d			call update_display 
1f67			 
1f67			 
1f67			 
1f67			;	call testlcd 
1f67			 
1f67			 
1f67			 
1f67 cd 98 26			call forth_init 
1f6a			 
1f6a			 
1f6a			warmstart: 
1f6a cd 6e 26			call forth_warmstart 
1f6d			 
1f6d				; run startup word load 
1f6d			        ; TODO prevent this running at warmstart after crash  
1f6d			 
1f6d				if STARTUP_ENABLE 
1f6d			 
1f6d					if STARTUP_V1 
1f6d			 
1f6d						if STORAGE_SE 
1f6d							call forth_autoload 
1f6d						endif 
1f6d						call forth_startup 
1f6d					endif 
1f6d			 
1f6d					if STARTUP_V2 
1f6d			 
1f6d						if STORAGE_SE 
1f6d cd 39 77						call forth_autoload 
1f70						else 
1f70							call forth_startup 
1f70						endif 
1f70			 
1f70			 
1f70					endif 
1f70			 
1f70				endif 
1f70			 
1f70				; show free memory after boot 
1f70 11 fc 1f			ld de, freeram 
1f73 3e 00			ld a, display_row_1 
1f75 cd ae 0d			call str_at_display 
1f78			 
1f78				; get current heap start after loading any uwords 
1f78			 
1f78				;ld de, (os_last_new_uword) 
1f78				;ex de, hl 
1f78			 
1f78			; Or use heap_size word???? 
1f78				;ld hl, heap_end 
1f78				;ld hl, heap_size 
1f78				;ld de, topusermem 
1f78				;ld de, heap_start 
1f78 ed 5b 0a 80			ld de, (free_list )      
1f7c 21 d7 f0				ld hl, heap_end 
1f7f ed 52			sbc hl, de 
1f81				;push hl 
1f81				;ld a,h	         	 
1f81				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f81				;call hexout 
1f81			   	;pop hl 
1f81			; 
1f81			;	ld a,l 
1f81			;	ld hl, os_word_scratch+2 
1f81			;	call hexout 
1f81			;	ld hl, os_word_scratch+4 
1f81			;	ld a, 0 
1f81			;	ld (hl),a 
1f81 eb				ex de, hl 
1f82 21 01 f4			ld hl, os_word_scratch 
1f85 cd f4 15			call uitoa_16 
1f88			 
1f88			 
1f88 11 01 f4			ld de, os_word_scratch 
1f8b 3e 0d			ld a, display_row_1 + 13 
1f8d cd ae 0d			call str_at_display 
1f90 cd be 0d			call update_display 
1f93			 
1f93			 
1f93				;call demo 
1f93			 
1f93			 
1f93				; init scratch input area for cli commands 
1f93			 
1f93 21 23 f4			ld hl, os_cli_cmd 
1f96 3e 00			ld a,0 
1f98 77				ld (hl),a 
1f99 23				inc hl 
1f9a 77				ld (hl),a 
1f9b			 
1f9b 3e 00			ld a,0 
1f9d 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1fa0			 
1fa0 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1fa3 32 20 f4			ld (os_cur_ptr+1),a	 
1fa6			 
1fa6 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1fa9 32 02 f4			ld (os_word_scratch+1),a	 
1fac				 
1fac			 
1fac				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1fac 21 23 f4			ld hl, os_cli_cmd 
1faf			 
1faf 3e 00			ld a, 0		 ; init cli input 
1fb1 77				ld (hl), a 
1fb2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1fb4			cli: 
1fb4				; show cli prompt 
1fb4				;push af 
1fb4				;ld a, 0 
1fb4				;ld de, prompt 
1fb4				;call str_at_display 
1fb4			 
1fb4				;call update_display 
1fb4				;pop af 
1fb4				;inc a 
1fb4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1fb4 0e 00			ld c, 0 
1fb6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1fb8 1e 28			ld e, 40 
1fba			 
1fba 21 23 f4			ld hl, os_cli_cmd 
1fbd			 
1fbd				STACKFRAME OFF $fefe $9f9f 
1fbd				if DEBUG_STACK_IMB 
1fbd					if OFF 
1fbd						exx 
1fbd						ld de, $fefe 
1fbd						ld a, d 
1fbd						ld hl, curframe 
1fbd						call hexout 
1fbd						ld a, e 
1fbd						ld hl, curframe+2 
1fbd						call hexout 
1fbd						ld hl, $fefe 
1fbd						push hl 
1fbd						ld hl, $9f9f 
1fbd						push hl 
1fbd						exx 
1fbd					endif 
1fbd				endif 
1fbd			endm 
# End of macro STACKFRAME
1fbd			 
1fbd cd fc 0f			call input_str 
1fc0			 
1fc0				STACKFRAMECHK OFF $fefe $9f9f 
1fc0				if DEBUG_STACK_IMB 
1fc0					if OFF 
1fc0						exx 
1fc0						ld hl, $9f9f 
1fc0						pop de   ; $9f9f 
1fc0						call cmp16 
1fc0						jr nz, .spnosame 
1fc0						ld hl, $fefe 
1fc0						pop de   ; $fefe 
1fc0						call cmp16 
1fc0						jr z, .spfrsame 
1fc0						.spnosame: call showsperror 
1fc0						.spfrsame: nop 
1fc0						exx 
1fc0					endif 
1fc0				endif 
1fc0			endm 
# End of macro STACKFRAMECHK
1fc0			 
1fc0				; copy input to last command 
1fc0			 
1fc0 21 23 f4			ld hl, os_cli_cmd 
1fc3 11 22 f5			ld de, os_last_cmd 
1fc6 01 ff 00			ld bc, 255 
1fc9 ed b0			ldir 
1fcb			 
1fcb				; wipe current buffer 
1fcb			 
1fcb			;	ld a, 0 
1fcb			;	ld hl, os_cli_cmd 
1fcb			;	ld de, os_cli_cmd+1 
1fcb			;	ld bc, 254 
1fcb			;	ldir 
1fcb				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1fcb			;	call strcpy 
1fcb			;	ld a, 0 
1fcb			;	ld (hl), a 
1fcb			;	inc hl 
1fcb			;	ld (hl), a 
1fcb			;	inc hl 
1fcb			;	ld (hl), a 
1fcb			 
1fcb				; switch frame buffer to program  
1fcb			 
1fcb 21 4b fc				ld hl, display_fb1 
1fce 22 07 fb				ld (display_fb_active), hl 
1fd1			 
1fd1			;	nop 
1fd1				STACKFRAME ON $fbfe $8f9f 
1fd1				if DEBUG_STACK_IMB 
1fd1					if ON 
1fd1						exx 
1fd1						ld de, $fbfe 
1fd1						ld a, d 
1fd1						ld hl, curframe 
1fd1						call hexout 
1fd1						ld a, e 
1fd1						ld hl, curframe+2 
1fd1						call hexout 
1fd1						ld hl, $fbfe 
1fd1						push hl 
1fd1						ld hl, $8f9f 
1fd1						push hl 
1fd1						exx 
1fd1					endif 
1fd1				endif 
1fd1			endm 
# End of macro STACKFRAME
1fd1				; first time into the parser so pass over the current scratch pad 
1fd1 21 23 f4			ld hl,os_cli_cmd 
1fd4				; tokenise the entered statement(s) in HL 
1fd4 cd 16 27			call forthparse 
1fd7			        ; exec forth statements in top of return stack 
1fd7 cd 56 27			call forthexec 
1fda				;call forthexec_cleanup 
1fda			;	call parsenext 
1fda			 
1fda				STACKFRAMECHK ON $fbfe $8f9f 
1fda				if DEBUG_STACK_IMB 
1fda					if ON 
1fda						exx 
1fda						ld hl, $8f9f 
1fda						pop de   ; $8f9f 
1fda						call cmp16 
1fda						jr nz, .spnosame 
1fda						ld hl, $fbfe 
1fda						pop de   ; $fbfe 
1fda						call cmp16 
1fda						jr z, .spfrsame 
1fda						.spnosame: call showsperror 
1fda						.spfrsame: nop 
1fda						exx 
1fda					endif 
1fda				endif 
1fda			endm 
# End of macro STACKFRAMECHK
1fda				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1fda			 
1fda 3e 78			ld a, display_row_4 
1fdc 11 0d 20			ld de, endprog 
1fdf			 
1fdf cd be 0d			call update_display		 
1fe2			 
1fe2 cd 93 22			call next_page_prompt 
1fe5			 
1fe5				; switch frame buffer to cli 
1fe5			 
1fe5 21 ec fc				ld hl, display_fb0 
1fe8 22 07 fb				ld (display_fb_active), hl 
1feb			 
1feb			 
1feb cd 9b 0d		        call clear_display 
1fee cd be 0d			call update_display		 
1ff1			 
1ff1 21 23 f4			ld hl, os_cli_cmd 
1ff4			 
1ff4 3e 00			ld a, 0		 ; init cli input 
1ff6 77				ld (hl), a 
1ff7			 
1ff7				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1ff7			 
1ff7				; now on last line 
1ff7			 
1ff7				; TODO scroll screen up 
1ff7			 
1ff7				; TODO instead just clear screen and place at top of screen 
1ff7			 
1ff7			;	ld a, 0 
1ff7			;	ld (f_cursor_ptr),a 
1ff7			 
1ff7				;call clear_display 
1ff7				;call update_display 
1ff7			 
1ff7				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ff7 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ff9 c3 b4 1f			jp cli 
1ffc			 
1ffc .. 00		freeram: db "Free bytes: ",0 
2009 ..			asc: db "1A2F" 
200d .. 00		endprog: db "End prog...",0 
2019			 
2019			testenter2:   
2019 21 2e f1			ld hl,scratch+50 
201c 22 1f f4			ld (os_cur_ptr),hl 
201f c3 b4 1f			jp cli 
2022			 
2022			testenter:  
2022			 
2022 21 09 20			ld hl,asc 
2025			;	ld a,(hl) 
2025			;	call nibble2val 
2025 cd 3e 15			call get_byte 
2028			 
2028			 
2028			;	ld a,(hl) 
2028			;	call atohex 
2028			 
2028			;	call fourehexhl 
2028 32 2e f1			ld (scratch+50),a 
202b			 
202b			 
202b			 
202b 21 0b 20			ld hl,asc+2 
202e			;	ld a, (hl) 
202e			;	call nibble2val 
202e cd 3e 15			call get_byte 
2031			 
2031			;	call fourehexhl 
2031 32 30 f1			ld (scratch+52),a 
2034				 
2034 21 2e f1			ld hl,scratch+50 
2037 22 1f f4			ld (os_cur_ptr),hl 
203a c3 b4 1f			jp cli 
203d			 
203d			enter:	 
203d 3a 00 f1			ld a,(scratch+4) 
2040 fe 00			cp 0 
2042 28 0c			jr z, .entercont 
2044				; no, not a null term line so has an address to work out.... 
2044			 
2044 21 fe f0			ld hl,scratch+2 
2047 cd 9e 15			call get_word_hl 
204a			 
204a 22 1f f4			ld (os_cur_ptr),hl	 
204d c3 b4 1f			jp cli 
2050			 
2050			 
2050			.entercont:  
2050			 
2050 21 fe f0			ld hl, scratch+2 
2053 cd 3e 15			call get_byte 
2056			 
2056 2a 1f f4		   	ld hl,(os_cur_ptr) 
2059 77					ld (hl),a 
205a 23					inc hl 
205b 22 1f f4				ld (os_cur_ptr),hl 
205e				 
205e			; get byte  
205e			 
205e			 
205e c3 b4 1f			jp cli 
2061			 
2061			 
2061			; basic monitor support 
2061			 
2061			monitor: 
2061				;  
2061 cd 9b 0d			call clear_display 
2064 3e 00			ld a, 0 
2066 11 b5 20			ld de, .monprompt 
2069 cd ae 0d			call str_at_display 
206c cd be 0d			call update_display 
206f			 
206f				; get a monitor command 
206f			 
206f 0e 00			ld c, 0     ; entry at top left 
2071 16 64			ld d, 100   ; max buffer size 
2073 1e 0f			ld e, 15    ; input scroll area 
2075 3e 00			ld a, 0     ; init string 
2077 21 fa f2			ld hl, os_input 
207a 77				ld (hl), a 
207b 23				inc hl 
207c 77				ld (hl), a 
207d 21 fa f2			ld hl, os_input 
2080 3e 01			ld a, 1     ; init string 
2082 cd fc 0f			call input_str 
2085			 
2085 cd 9b 0d		        call clear_display 
2088 cd be 0d			call update_display		 
208b			 
208b 3a fa f2			ld a, (os_input) 
208e cd 3c 16			call toUpper 
2091 fe 48		        cp 'H' 
2093 ca 1a 21		        jp z, .monhelp 
2096 fe 44			cp 'D'		; dump 
2098 ca 4d 21			jp z, .mondump	 
209b fe 43			cp 'C'		; dump 
209d ca 67 21			jp z, .moncdump	 
20a0 fe 4d			cp 'M'		; dump 
20a2 ca b7 20			jp z, .moneditstart 
20a5 fe 55			cp 'U'		; dump 
20a7 ca c3 20			jp z, .monedit	 
20aa fe 47			cp 'G'		; dump 
20ac ca 43 21			jp z, .monjump 
20af fe 51			cp 'Q'		; dump 
20b1 c8				ret z	 
20b2			 
20b2			 
20b2				; TODO "S" to access symbol by name and not need the address 
20b2				; TODO "F" to find a string in memory 
20b2			 
20b2 c3 61 20			jp monitor 
20b5			 
20b5 .. 00		.monprompt: db ">", 0 
20b7			 
20b7			.moneditstart: 
20b7				; get starting address 
20b7			 
20b7 21 fc f2			ld hl,os_input+2 
20ba cd 9e 15			call get_word_hl 
20bd			 
20bd 22 1f f4			ld (os_cur_ptr),hl	 
20c0			 
20c0 c3 61 20			jp monitor 
20c3			 
20c3			.monedit: 
20c3				; get byte to load 
20c3			 
20c3 21 fc f2			ld hl,os_input+2 
20c6 cd 3e 15			call get_byte 
20c9			 
20c9				; get address to update 
20c9 2a 1f f4			ld hl, (os_cur_ptr) 
20cc			 
20cc				; update byte 
20cc			 
20cc 77				ld (hl), a 
20cd			 
20cd				; move to next address and save it 
20cd			 
20cd 23				inc hl 
20ce 22 1f f4			ld (os_cur_ptr),hl	 
20d1			 
20d1 c3 61 20			jp monitor 
20d4			 
20d4			 
20d4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
20e8 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
2104 .. 00		.monhelptext3:  db "G-Call address",0 
2113 .. 00		.monhelptext4:  db "Q-Quit",0 
211a			        
211a			.monhelp: 
211a 3e 00			ld a, display_row_1 
211c 11 d4 20		        ld de, .monhelptext1 
211f			 
211f cd ae 0d			call str_at_display 
2122 3e 28			ld a, display_row_2 
2124 11 e8 20		        ld de, .monhelptext2 
2127					 
2127 cd ae 0d			call str_at_display 
212a 3e 50			ld a, display_row_3 
212c 11 04 21		        ld de, .monhelptext3 
212f					 
212f cd ae 0d			call str_at_display 
2132 3e 78			ld a, display_row_4 
2134 11 13 21		        ld de, .monhelptext4 
2137 cd ae 0d			call str_at_display 
213a			 
213a cd be 0d			call update_display		 
213d			 
213d cd 93 22			call next_page_prompt 
2140 c3 61 20			jp monitor 
2143			 
2143			.monjump:    
2143 21 fc f2			ld hl,os_input+2 
2146 cd 9e 15			call get_word_hl 
2149			 
2149 e9				jp (hl) 
214a c3 61 20			jp monitor 
214d			 
214d			.mondump:    
214d 21 fc f2			ld hl,os_input+2 
2150 cd 9e 15			call get_word_hl 
2153			 
2153 22 1f f4			ld (os_cur_ptr),hl	 
2156 cd 9b 21			call dumpcont 
2159 3e 78			ld a, display_row_4 
215b 11 0d 20			ld de, endprog 
215e			 
215e cd be 0d			call update_display		 
2161			 
2161 cd 93 22			call next_page_prompt 
2164 c3 61 20			jp monitor 
2167			.moncdump: 
2167 cd 9b 21			call dumpcont 
216a 3e 78			ld a, display_row_4 
216c 11 0d 20			ld de, endprog 
216f			 
216f cd be 0d			call update_display		 
2172			 
2172 cd 93 22			call next_page_prompt 
2175 c3 61 20			jp monitor 
2178			 
2178			 
2178			; TODO symbol access  
2178			 
2178			.symbols:     ;; A list of symbols that can be called up  
2178 ec fc			dw display_fb0 
217a .. 00			db "fb0",0  
217e b5 f9		     	dw store_page 
2180 .. 00			db "store_page",0 
218b			 
218b			 
218b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
218b			 
218b 3a fd f0			ld a,(scratch+1) 
218e fe 00			cp 0 
2190 28 09			jr z, dumpcont 
2192			 
2192				; no, not a null term line so has an address to work out.... 
2192			 
2192 21 fe f0			ld hl,scratch+2 
2195 cd 9e 15			call get_word_hl 
2198			 
2198 22 1f f4			ld (os_cur_ptr),hl	 
219b			 
219b			 
219b			 
219b			dumpcont: 
219b			 
219b				; dump bytes at ptr 
219b			 
219b			 
219b 3e 00			ld a, display_row_1 
219d 2a 07 fb			ld hl, (display_fb_active) 
21a0 cd cf 0f			call addatohl 
21a3 cd cb 21			call .dumpbyterow 
21a6			 
21a6 3e 28			ld a, display_row_2 
21a8 2a 07 fb			ld hl, (display_fb_active) 
21ab cd cf 0f			call addatohl 
21ae cd cb 21			call .dumpbyterow 
21b1			 
21b1			 
21b1 3e 50			ld a, display_row_3 
21b3 2a 07 fb			ld hl, (display_fb_active) 
21b6 cd cf 0f			call addatohl 
21b9 cd cb 21			call .dumpbyterow 
21bc			 
21bc 3e 78			ld a, display_row_4 
21be 2a 07 fb			ld hl, (display_fb_active) 
21c1 cd cf 0f			call addatohl 
21c4 cd cb 21			call .dumpbyterow 
21c7			 
21c7 cd be 0d			call update_display 
21ca			;		jp cli 
21ca c9				ret 
21cb			 
21cb			.dumpbyterow: 
21cb			 
21cb				;push af 
21cb			 
21cb e5				push hl 
21cc			 
21cc				; calc where to poke the ascii 
21cc			if display_cols == 20 
21cc				ld a, 16 
21cc			else 
21cc 3e 1f			ld a, 31 
21ce			endif 
21ce			 
21ce cd cf 0f			call addatohl 
21d1 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
21d4			 
21d4			 
21d4			; display decoding address 
21d4 2a 1f f4		   	ld hl,(os_cur_ptr) 
21d7			 
21d7 7c				ld a,h 
21d8 e1				pop hl 
21d9 e5				push hl 
21da			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
21da cd e8 14			call hexout 
21dd 2a 1f f4		   	ld hl,(os_cur_ptr) 
21e0			 
21e0 7d				ld a,l 
21e1 e1				pop hl 
21e2 23				inc hl 
21e3 23				inc hl 
21e4 e5				push hl 
21e5			;	ld hl, os_word_scratch+2 
21e5 cd e8 14			call hexout 
21e8 e1				pop hl 
21e9 23				inc hl 
21ea 23				inc hl 
21eb				;ld hl, os_word_scratch+4 
21eb 3e 3a			ld a, ':' 
21ed 77				ld (hl),a 
21ee 23				inc hl 
21ef				;ld a, 0 
21ef				;ld (hl),a 
21ef				;ld de, os_word_scratch 
21ef				;pop af 
21ef				;push af 
21ef			;		ld a, display_row_2 
21ef			;		call str_at_display 
21ef			;		call update_display 
21ef			 
21ef			 
21ef			;pop af 
21ef			;	add 5 
21ef			 
21ef			if display_cols == 20 
21ef				ld b, 4 
21ef			else 
21ef 06 08			ld b, 8 
21f1			endif	 
21f1			 
21f1			.dumpbyte: 
21f1 c5				push bc 
21f2 e5				push hl 
21f3			 
21f3			 
21f3 2a 1f f4		   	ld hl,(os_cur_ptr) 
21f6 7e					ld a,(hl) 
21f7			 
21f7					; poke the ascii to display 
21f7 2a 01 f4				ld hl,(os_word_scratch) 
21fa 77					ld (hl),a 
21fb 23					inc hl 
21fc 22 01 f4				ld (os_word_scratch),hl 
21ff			 
21ff					 
21ff			 
21ff			 
21ff e1					pop hl 
2200 e5					push hl 
2201			 
2201 cd e8 14				call hexout 
2204			 
2204					 
2204 2a 1f f4		   	ld hl,(os_cur_ptr) 
2207 23				inc hl 
2208 22 1f f4		   	ld (os_cur_ptr),hl 
220b			 
220b e1					pop hl 
220c 23					inc hl 
220d 23					inc hl 
220e 23					inc hl 
220f			 
220f			 
220f			 
220f					;ld a,0 
220f					;ld (os_word_scratch+2),a 
220f					;pop af 
220f					;push af 
220f			 
220f					;ld de, os_word_scratch 
220f					;call str_at_display 
220f			;		call update_display 
220f			;		pop af 
220f c1					pop bc 
2210 c6 03				add 3 
2212 10 dd			djnz .dumpbyte 
2214			 
2214				 
2214			 
2214 c9				ret 
2215			 
2215			jump:	 
2215			 
2215 21 fe f0			ld hl,scratch+2 
2218 cd 9e 15			call get_word_hl 
221b				;ld hl,(scratch+2) 
221b				;call fourehexhl 
221b			 
221b 22 1f f4			ld (os_cur_ptr),hl	 
221e			 
221e e9				jp (hl) 
221f			 
221f			 
221f			 
221f			; TODO implement a basic monitor mode to start with 
221f			 
221f			 
221f			 
221f			 
221f			 
221f			 
221f			 
221f			 
221f			 
221f			; testing and demo code during development 
221f			 
221f			 
221f .. 00		str1: db "Enter some text...",0 
2232 .. 00		clear: db "                    ",0 
2247			 
2247			demo: 
2247			 
2247			 
2247			 
2247			;	call update_display 
2247			 
2247				; init scratch input area for testing 
2247 21 fc f0			ld hl, scratch	 
224a 3e 00			ld a,0 
224c 77				ld (hl),a 
224d			 
224d			 
224d 3e 28		            LD   A, display_row_2 
224f			;            CALL fLCD_Pos       ;Position cursor to location in A 
224f 11 1f 22		            LD   DE, str1 
2252 cd ae 0d			call str_at_display 
2255			 
2255			;            CALL fLCD_Str       ;Display string pointed to by DE 
2255			cloop:	 
2255 3e 50		            LD   A, display_row_3 
2257			;            CALL fLCD_Pos       ;Position cursor to location in A 
2257 11 32 22		            LD   DE, clear 
225a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
225a cd ae 0d				call str_at_display 
225d 3e 78			ld a, display_row_4 
225f 11 8f 22			ld de, prompt 
2262			 
2262 cd ae 0d				call str_at_display 
2265 cd be 0d			call update_display 
2268			 
2268 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
226a 16 0a			ld d, 10 
226c 21 fc f0			ld hl, scratch	 
226f cd fc 0f			call input_str 
2272			 
2272			;	call clear_display 
2272			;'	call update_display 
2272			 
2272 3e 00		            LD   A, display_row_1 
2274			;            CALL fLCD_Pos       ;Position cursor to location in A 
2274 11 32 22		            LD   DE, clear 
2277 cd ae 0d				call str_at_display 
227a			;            CALL fLCD_Str       ;Display string pointed to by DE 
227a 3e 00		            LD   A, display_row_1 
227c			;            CALL fLCD_Pos       ;Position cursor to location in A 
227c 11 fc f0		            LD   DE, scratch 
227f			;            CALL fLCD_Str       ;Display string pointed to by DE 
227f cd ae 0d				call str_at_display 
2282 cd be 0d			call update_display 
2285			 
2285 3e 00				ld a,0 
2287 21 fc f0			ld hl, scratch 
228a 77				ld (hl),a 
228b			 
228b 00				nop 
228c c3 55 22			jp cloop 
228f			 
228f			 
228f			 
228f			; OS Prompt 
228f			 
228f .. 00		prompt: db ">",0 
2291 .. 00		endprg: db "?",0 
2293			 
2293			 
2293			; handy next page prompt 
2293			next_page_prompt: 
2293 e5				push hl 
2294 d5				push de 
2295 f5				push af 
2296 c5				push bc 
2297			 
2297 3e 9f			ld a,display_row_4 + display_cols - 1 
2299 11 91 22		        ld de, endprg 
229c cd ae 0d			call str_at_display 
229f cd be 0d			call update_display 
22a2 cd 84 7c			call cin_wait 
22a5 c1				pop bc 
22a6 f1				pop af 
22a7 d1				pop de 
22a8 e1				pop hl 
22a9			 
22a9			 
22a9 c9				ret 
22aa			 
22aa			 
22aa			; forth parser 
22aa			 
22aa			; My forth kernel 
22aa			include "forth_kernel.asm" 
22aa			; 
22aa			; kernel to the forth OS 
22aa			 
22aa			DS_TYPE_STR: equ 1     ; string type 
22aa			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
22aa			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
22aa			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
22aa			 
22aa			FORTH_PARSEV1: equ 0 
22aa			FORTH_PARSEV2: equ 0 
22aa			FORTH_PARSEV3: equ 0 
22aa			FORTH_PARSEV4: equ 0 
22aa			FORTH_PARSEV5: equ 1 
22aa			 
22aa			;if FORTH_PARSEV5 
22aa			;	FORTH_END_BUFFER: equ 0 
22aa			;else 
22aa			FORTH_END_BUFFER: equ 127 
22aa			;endif 
22aa			 
22aa			FORTH_TRUE: equ 1 
22aa			FORTH_FALSE: equ 0 
22aa			 
22aa			if FORTH_PARSEV4 
22aa			include "forth_stackops.asm" 
22aa			endif 
22aa			 
22aa			if FORTH_PARSEV5 
22aa			include "forth_stackopsv5.asm" 
22aa			 
22aa			; Stack operations for v5 parser on wards 
22aa			; * DATA stack 
22aa			; * LOOP stack 
22aa			; * RETURN stack 
22aa			 
22aa			 
22aa			 
22aa			FORTH_CHK_DSP_UNDER: macro 
22aa				push hl 
22aa				push de 
22aa				ld hl,(cli_data_sp) 
22aa				ld de, cli_data_stack 
22aa				call cmp16 
22aa				jp c, fault_dsp_under 
22aa				pop de 
22aa				pop hl 
22aa				endm 
22aa			 
22aa			 
22aa			FORTH_CHK_RSP_UNDER: macro 
22aa				push hl 
22aa				push de 
22aa				ld hl,(cli_ret_sp) 
22aa				ld de, cli_ret_stack 
22aa				call cmp16 
22aa				jp c, fault_rsp_under 
22aa				pop de 
22aa				pop hl 
22aa				endm 
22aa			 
22aa			FORTH_CHK_LOOP_UNDER: macro 
22aa				push hl 
22aa				push de 
22aa				ld hl,(cli_loop_sp) 
22aa				ld de, cli_loop_stack 
22aa				call cmp16 
22aa				jp c, fault_loop_under 
22aa				pop de 
22aa				pop hl 
22aa				endm 
22aa			 
22aa			FORTH_ERR_TOS_NOTSTR: macro 
22aa				; TOSO might need more for checks when used 
22aa				push af 
22aa				ld a,(hl) 
22aa				cp DS_TYPE_STR 
22aa				jp nz, type_faultn   
22aa				pop af 
22aa				endm 
22aa			 
22aa			FORTH_ERR_TOS_NOTNUM: macro 
22aa				push af 
22aa				ld a,(hl) 
22aa				cp DS_TYPE_INUM 
22aa				jp nz, type_faultn   
22aa				pop af 
22aa				endm 
22aa			 
22aa			 
22aa			; increase data stack pointer and save hl to it 
22aa				 
22aa			FORTH_DSP_NEXT: macro 
22aa				call macro_forth_dsp_next 
22aa				endm 
22aa			 
22aa			 
22aa			macro_forth_dsp_next: 
22aa				if DEBUG_FORTH_STACK_GUARD 
22aa cd 31 75				call check_stacks 
22ad				endif 
22ad e5				push hl 
22ae d5				push de 
22af eb				ex de,hl 
22b0 2a 29 f9			ld hl,(cli_data_sp) 
22b3 23				inc hl 
22b4 23				inc hl 
22b5			 
22b5			; PARSEV5 
22b5 23				inc hl 
22b6 22 29 f9			ld (cli_data_sp),hl 
22b9 73				ld (hl), e 
22ba 23				inc hl 
22bb 72				ld (hl), d 
22bc d1				pop de 
22bd e1				pop hl 
22be				if DEBUG_FORTH_STACK_GUARD 
22be cd 31 75				call check_stacks 
22c1				endif 
22c1 c9				ret 
22c2			 
22c2			 
22c2			; increase ret stack pointer and save hl to it 
22c2				 
22c2			FORTH_RSP_NEXT: macro 
22c2				call macro_forth_rsp_next 
22c2				endm 
22c2			 
22c2			macro_forth_rsp_next: 
22c2				if DEBUG_FORTH_STACK_GUARD 
22c2 cd 31 75				call check_stacks 
22c5				endif 
22c5 e5				push hl 
22c6 d5				push de 
22c7 eb				ex de,hl 
22c8 2a 2d f9			ld hl,(cli_ret_sp) 
22cb 23				inc hl 
22cc 23				inc hl 
22cd 22 2d f9			ld (cli_ret_sp),hl 
22d0 73				ld (hl), e 
22d1 23				inc hl 
22d2 72				ld (hl), d 
22d3 d1				pop de 
22d4 e1				pop hl 
22d5				if DEBUG_FORTH_STACK_GUARD 
22d5 cd 31 75				call check_stacks 
22d8				endif 
22d8 c9				ret 
22d9			 
22d9			; get current ret stack pointer and save to hl  
22d9				 
22d9			FORTH_RSP_TOS: macro 
22d9				call macro_forth_rsp_tos 
22d9				endm 
22d9			 
22d9			macro_forth_rsp_tos: 
22d9				;push de 
22d9 2a 2d f9			ld hl,(cli_ret_sp) 
22dc cd 14 23			call loadhlptrtohl 
22df				;ld e, (hl) 
22df				;inc hl 
22df				;ld d, (hl) 
22df				;ex de, hl 
22df					if DEBUG_FORTH_WORDS 
22df			;			DMARK "RST" 
22df						CALLMONITOR 
22df cd aa fd			call debug_vector  
22e2				endm  
# End of macro CALLMONITOR
22e2					endif 
22e2				;pop de 
22e2 c9				ret 
22e3			 
22e3			; pop ret stack pointer 
22e3				 
22e3			FORTH_RSP_POP: macro 
22e3				call macro_forth_rsp_pop 
22e3				endm 
22e3			 
22e3			 
22e3			macro_forth_rsp_pop: 
22e3				if DEBUG_FORTH_STACK_GUARD 
22e3			;		DMARK "RPP" 
22e3 cd 31 75				call check_stacks 
22e6					FORTH_CHK_RSP_UNDER 
22e6 e5				push hl 
22e7 d5				push de 
22e8 2a 2d f9			ld hl,(cli_ret_sp) 
22eb 11 e7 f8			ld de, cli_ret_stack 
22ee cd ed 0f			call cmp16 
22f1 da 45 76			jp c, fault_rsp_under 
22f4 d1				pop de 
22f5 e1				pop hl 
22f6				endm 
# End of macro FORTH_CHK_RSP_UNDER
22f6				endif 
22f6 e5				push hl 
22f7 2a 2d f9			ld hl,(cli_ret_sp) 
22fa			 
22fa			 
22fa				if FORTH_ENABLE_FREE 
22fa			 
22fa					; get pointer 
22fa			 
22fa					push de 
22fa					push hl 
22fa			 
22fa					ld e, (hl) 
22fa					inc hl 
22fa					ld d, (hl) 
22fa			 
22fa					ex de, hl 
22fa					call free 
22fa			 
22fa					pop hl 
22fa					pop de 
22fa			 
22fa			 
22fa				endif 
22fa			 
22fa			 
22fa 2b				dec hl 
22fb 2b				dec hl 
22fc 22 2d f9			ld (cli_ret_sp), hl 
22ff				; do stack underflow checks 
22ff e1				pop hl 
2300				if DEBUG_FORTH_STACK_GUARD 
2300 cd 31 75				call check_stacks 
2303					FORTH_CHK_RSP_UNDER 
2303 e5				push hl 
2304 d5				push de 
2305 2a 2d f9			ld hl,(cli_ret_sp) 
2308 11 e7 f8			ld de, cli_ret_stack 
230b cd ed 0f			call cmp16 
230e da 45 76			jp c, fault_rsp_under 
2311 d1				pop de 
2312 e1				pop hl 
2313				endm 
# End of macro FORTH_CHK_RSP_UNDER
2313				endif 
2313 c9				ret 
2314			 
2314			 
2314			 
2314			; routine to load word pointed to by hl into hl 
2314			 
2314			loadhlptrtohl: 
2314			 
2314 d5				push de 
2315 5e				ld e, (hl) 
2316 23				inc hl 
2317 56				ld d, (hl) 
2318 eb				ex de, hl 
2319 d1				pop de 
231a			 
231a c9				ret 
231b			 
231b			 
231b			 
231b			 
231b			 
231b			; push a number held in HL onto the data stack 
231b			; entry point for pushing a value when already in hl used in function above 
231b			 
231b			forth_push_numhl: 
231b			 
231b e5				push hl    ; save value to push 
231c			 
231c			if DEBUG_FORTH_PUSH 
231c				; see if disabled 
231c			 
231c			 
231c f5				push af 
231d 3a aa fd			ld a,(debug_vector) 
2320 fe c9			cp $c9   ; ret 
2322			;	ld a, (os_view_disable) 
2322			;	cp '*' 
2322 28 34			jr z, .pskip2 
2324 e5				push hl 
2325 e5			push hl 
2326 cd 9b 0d			call clear_display 
2329 e1			pop hl 
232a 7c				ld a,h 
232b 21 01 f4			ld hl, os_word_scratch 
232e cd e8 14			call hexout 
2331 e1				pop hl 
2332 7d				ld a,l 
2333 21 03 f4			ld hl, os_word_scratch+2 
2336 cd e8 14			call hexout 
2339			 
2339 21 05 f4			ld hl, os_word_scratch+4 
233c 3e 00			ld a,0 
233e 77				ld (hl),a 
233f 11 01 f4			ld de,os_word_scratch 
2342 3e 28				ld a, display_row_2 
2344 cd ae 0d				call str_at_display 
2347 11 43 60			ld de, .push_num 
234a 3e 00			ld a, display_row_1 
234c			 
234c cd ae 0d				call str_at_display 
234f			 
234f			 
234f cd be 0d			call update_display 
2352 cd de 0c			call delay1s 
2355 cd de 0c			call delay1s 
2358			.pskip2:  
2358			 
2358 f1				pop af 
2359			endif	 
2359			 
2359			 
2359				FORTH_DSP_NEXT 
2359 cd aa 22			call macro_forth_dsp_next 
235c				endm 
# End of macro FORTH_DSP_NEXT
235c			 
235c 2a 29 f9			ld hl, (cli_data_sp) 
235f			 
235f				; save item type 
235f 3e 02			ld a,  DS_TYPE_INUM 
2361 77				ld (hl), a 
2362 23				inc hl 
2363			 
2363				; get word off stack 
2363 d1				pop de 
2364 7b				ld a,e 
2365 77				ld (hl), a 
2366 23				inc hl 
2367 7a				ld a,d 
2368 77				ld (hl), a 
2369			 
2369			if DEBUG_FORTH_PUSH 
2369 2b				dec hl 
236a 2b				dec hl 
236b 2b				dec hl 
236c						DMARK "PH5" 
236c f5				push af  
236d 3a 81 23			ld a, (.dmark)  
2370 32 a6 fd			ld (debug_mark),a  
2373 3a 82 23			ld a, (.dmark+1)  
2376 32 a7 fd			ld (debug_mark+1),a  
2379 3a 83 23			ld a, (.dmark+2)  
237c 32 a8 fd			ld (debug_mark+2),a  
237f 18 03			jr .pastdmark  
2381 ..			.dmark: db "PH5"  
2384 f1			.pastdmark: pop af  
2385			endm  
# End of macro DMARK
2385				CALLMONITOR 
2385 cd aa fd			call debug_vector  
2388				endm  
# End of macro CALLMONITOR
2388			endif	 
2388			 
2388 c9				ret 
2389			 
2389			 
2389			; Push a string to stack pointed to by hl 
2389			 
2389			forth_push_str: 
2389			 
2389			if DEBUG_FORTH_PUSH 
2389						DMARK "PSQ" 
2389 f5				push af  
238a 3a 9e 23			ld a, (.dmark)  
238d 32 a6 fd			ld (debug_mark),a  
2390 3a 9f 23			ld a, (.dmark+1)  
2393 32 a7 fd			ld (debug_mark+1),a  
2396 3a a0 23			ld a, (.dmark+2)  
2399 32 a8 fd			ld (debug_mark+2),a  
239c 18 03			jr .pastdmark  
239e ..			.dmark: db "PSQ"  
23a1 f1			.pastdmark: pop af  
23a2			endm  
# End of macro DMARK
23a2				CALLMONITOR 
23a2 cd aa fd			call debug_vector  
23a5				endm  
# End of macro CALLMONITOR
23a5			endif	 
23a5			    
23a5 e5				push hl 
23a6 e5				push hl 
23a7			 
23a7			;	ld a, 0   ; find end of string 
23a7 cd 45 16			call strlenz 
23aa			if DEBUG_FORTH_PUSH 
23aa						DMARK "PQ2" 
23aa f5				push af  
23ab 3a bf 23			ld a, (.dmark)  
23ae 32 a6 fd			ld (debug_mark),a  
23b1 3a c0 23			ld a, (.dmark+1)  
23b4 32 a7 fd			ld (debug_mark+1),a  
23b7 3a c1 23			ld a, (.dmark+2)  
23ba 32 a8 fd			ld (debug_mark+2),a  
23bd 18 03			jr .pastdmark  
23bf ..			.dmark: db "PQ2"  
23c2 f1			.pastdmark: pop af  
23c3			endm  
# End of macro DMARK
23c3				CALLMONITOR 
23c3 cd aa fd			call debug_vector  
23c6				endm  
# End of macro CALLMONITOR
23c6			endif	 
23c6 eb				ex de, hl 
23c7 e1				pop hl   ; get ptr to start of string 
23c8			if DEBUG_FORTH_PUSH 
23c8						DMARK "PQ3" 
23c8 f5				push af  
23c9 3a dd 23			ld a, (.dmark)  
23cc 32 a6 fd			ld (debug_mark),a  
23cf 3a de 23			ld a, (.dmark+1)  
23d2 32 a7 fd			ld (debug_mark+1),a  
23d5 3a df 23			ld a, (.dmark+2)  
23d8 32 a8 fd			ld (debug_mark+2),a  
23db 18 03			jr .pastdmark  
23dd ..			.dmark: db "PQ3"  
23e0 f1			.pastdmark: pop af  
23e1			endm  
# End of macro DMARK
23e1				CALLMONITOR 
23e1 cd aa fd			call debug_vector  
23e4				endm  
# End of macro CALLMONITOR
23e4			endif	 
23e4 19				add hl,de 
23e5			if DEBUG_FORTH_PUSH 
23e5						DMARK "PQE" 
23e5 f5				push af  
23e6 3a fa 23			ld a, (.dmark)  
23e9 32 a6 fd			ld (debug_mark),a  
23ec 3a fb 23			ld a, (.dmark+1)  
23ef 32 a7 fd			ld (debug_mark+1),a  
23f2 3a fc 23			ld a, (.dmark+2)  
23f5 32 a8 fd			ld (debug_mark+2),a  
23f8 18 03			jr .pastdmark  
23fa ..			.dmark: db "PQE"  
23fd f1			.pastdmark: pop af  
23fe			endm  
# End of macro DMARK
23fe				CALLMONITOR 
23fe cd aa fd			call debug_vector  
2401				endm  
# End of macro CALLMONITOR
2401			endif	 
2401			 
2401 2b				dec hl    ; see if there is an optional trailing double quote 
2402 7e				ld a,(hl) 
2403 fe 22			cp '"' 
2405 20 03			jr nz, .strnoq 
2407 3e 00			ld a, 0      ; get rid of double quote 
2409 77				ld (hl), a 
240a 23			.strnoq: inc hl 
240b			 
240b 3e 00			ld a, 0 
240d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
240e			 
240e 13				inc de ; add one for the type string 
240f 13				inc de ; add one for null term??? 
2410			 
2410				; tos is get string pointer again 
2410				; de contains space to allocate 
2410				 
2410 d5				push de 
2411			 
2411 eb				ex de, hl 
2412			 
2412				;push af 
2412			 
2412			if DEBUG_FORTH_PUSH 
2412						DMARK "PHm" 
2412 f5				push af  
2413 3a 27 24			ld a, (.dmark)  
2416 32 a6 fd			ld (debug_mark),a  
2419 3a 28 24			ld a, (.dmark+1)  
241c 32 a7 fd			ld (debug_mark+1),a  
241f 3a 29 24			ld a, (.dmark+2)  
2422 32 a8 fd			ld (debug_mark+2),a  
2425 18 03			jr .pastdmark  
2427 ..			.dmark: db "PHm"  
242a f1			.pastdmark: pop af  
242b			endm  
# End of macro DMARK
242b				CALLMONITOR 
242b cd aa fd			call debug_vector  
242e				endm  
# End of macro CALLMONITOR
242e			endif	 
242e cd ba 16			call malloc	; on ret hl now contains allocated memory 
2431				if DEBUG_FORTH_MALLOC_GUARD 
2431 cc 9b 60				call z,malloc_error 
2434				endif 
2434			 
2434				 
2434 c1				pop bc    ; get length 
2435 d1				pop de   ;  get string start    
2436			 
2436				; hl has destination from malloc 
2436			 
2436 eb				ex de, hl    ; prep for ldir 
2437			 
2437 d5				push de   ; save malloc area for DSP later 
2438				;push hl   ; save malloc area for DSP later 
2438			 
2438			if DEBUG_FORTH_PUSH 
2438						DMARK "PHc" 
2438 f5				push af  
2439 3a 4d 24			ld a, (.dmark)  
243c 32 a6 fd			ld (debug_mark),a  
243f 3a 4e 24			ld a, (.dmark+1)  
2442 32 a7 fd			ld (debug_mark+1),a  
2445 3a 4f 24			ld a, (.dmark+2)  
2448 32 a8 fd			ld (debug_mark+2),a  
244b 18 03			jr .pastdmark  
244d ..			.dmark: db "PHc"  
2450 f1			.pastdmark: pop af  
2451			endm  
# End of macro DMARK
2451				CALLMONITOR 
2451 cd aa fd			call debug_vector  
2454				endm  
# End of macro CALLMONITOR
2454			endif	 
2454			 
2454			 
2454 ed b0			ldir 
2456			 
2456			 
2456				; push malloc to data stack     macro?????  
2456			 
2456				FORTH_DSP_NEXT 
2456 cd aa 22			call macro_forth_dsp_next 
2459				endm 
# End of macro FORTH_DSP_NEXT
2459			 
2459				; save value and type 
2459			 
2459 2a 29 f9			ld hl, (cli_data_sp) 
245c			 
245c				; save item type 
245c 3e 01			ld a,  DS_TYPE_STR 
245e 77				ld (hl), a 
245f 23				inc hl 
2460			 
2460				; get malloc word off stack 
2460 d1				pop de 
2461 73				ld (hl), e 
2462 23				inc hl 
2463 72				ld (hl), d 
2464			 
2464			 
2464			 
2464			if DEBUG_FORTH_PUSH 
2464 2a 29 f9			ld hl, (cli_data_sp) 
2467						DMARK "PHS" 
2467 f5				push af  
2468 3a 7c 24			ld a, (.dmark)  
246b 32 a6 fd			ld (debug_mark),a  
246e 3a 7d 24			ld a, (.dmark+1)  
2471 32 a7 fd			ld (debug_mark+1),a  
2474 3a 7e 24			ld a, (.dmark+2)  
2477 32 a8 fd			ld (debug_mark+2),a  
247a 18 03			jr .pastdmark  
247c ..			.dmark: db "PHS"  
247f f1			.pastdmark: pop af  
2480			endm  
# End of macro DMARK
2480				CALLMONITOR 
2480 cd aa fd			call debug_vector  
2483				endm  
# End of macro CALLMONITOR
2483			;	ex de,hl 
2483			endif	 
2483				; in case of spaces, skip the ptr past the copied string 
2483				;pop af 
2483				;ld (cli_origptr),hl 
2483			 
2483 c9				ret 
2484			 
2484			 
2484			 
2484			; TODO ascii push input onto stack given hl to start of input 
2484			 
2484			; identify type 
2484			; if starts with a " then a string 
2484			; otherwise it is a number 
2484			;  
2484			; if a string 
2484			;     scan for ending " to get length of string to malloc for + 1 
2484			;     malloc 
2484			;     put pointer to string on stack first byte flags as string 
2484			; 
2484			; else a number 
2484			;    look for number format identifier 
2484			;    $xx hex 
2484			;    %xxxxx bin 
2484			;    xxxxx decimal 
2484			;    convert number to 16bit word.  
2484			;    malloc word + 1 with flag to identiy as num 
2484			;    put pointer to number on stack 
2484			;   
2484			;  
2484			  
2484			forth_apush: 
2484				; kernel push 
2484			 
2484			if DEBUG_FORTH_PUSH 
2484						DMARK "PSH" 
2484 f5				push af  
2485 3a 99 24			ld a, (.dmark)  
2488 32 a6 fd			ld (debug_mark),a  
248b 3a 9a 24			ld a, (.dmark+1)  
248e 32 a7 fd			ld (debug_mark+1),a  
2491 3a 9b 24			ld a, (.dmark+2)  
2494 32 a8 fd			ld (debug_mark+2),a  
2497 18 03			jr .pastdmark  
2499 ..			.dmark: db "PSH"  
249c f1			.pastdmark: pop af  
249d			endm  
# End of macro DMARK
249d				CALLMONITOR 
249d cd aa fd			call debug_vector  
24a0				endm  
# End of macro CALLMONITOR
24a0			endif	 
24a0				; identify input type 
24a0			 
24a0 7e				ld a,(hl) 
24a1 fe 22			cp '"' 
24a3 28 0a			jr z, .fapstr 
24a5 fe 24			cp '$' 
24a7 ca cf 24			jp z, .faphex 
24aa fe 25			cp '%' 
24ac ca b7 24			jp z, .fapbin 
24af			;	cp 'b' 
24af			;	jp z, .fabin 
24af				; else decimal 
24af			 
24af				; TODO do decimal conversion 
24af				; decimal is stored as a 16bit word 
24af			 
24af				; by default everything is a string if type is not detected 
24af			.fapstr: ; 
24af fe 22			cp '"' 
24b1 20 01			jr nz, .strnoqu 
24b3 23				inc hl 
24b4			.strnoqu: 
24b4 c3 89 23			jp forth_push_str 
24b7			 
24b7			 
24b7			 
24b7			.fapbin:    ; push a binary string.  
24b7 11 00 00			ld de, 0   ; hold a 16bit value 
24ba			 
24ba 23			.fapbinshift:	inc hl  
24bb 7e				ld a,(hl) 
24bc fe 00			cp 0     ; done scanning  
24be 28 0b			jr z, .fapbdone  	; got it in HL so push  
24c0			 
24c0				; left shift de 
24c0 eb				ex de, hl	 
24c1 29				add hl, hl 
24c2			 
24c2				; is 1 
24c2 fe 31			cp '1' 
24c4 20 02			jr nz, .binzero 
24c6 cb 4d			bit 1, l 
24c8			.binzero: 
24c8 eb				ex de, hl	 ; save current de 
24c9 18 ef			jr .fapbinshift 
24cb			 
24cb			.fapbdone: 
24cb eb				ex de, hl 
24cc c3 1b 23			jp forth_push_numhl 
24cf			 
24cf			 
24cf			.faphex:   ; hex is always stored as a 16bit word 
24cf				; skip number prefix 
24cf 23				inc hl 
24d0				; turn ascii into number 
24d0 cd 9e 15			call get_word_hl	; ret 16bit word in hl 
24d3			 
24d3 c3 1b 23			jp forth_push_numhl 
24d6			 
24d6 00				 nop 
24d7			 
24d7			.fabin:   ; TODO bin conversion 
24d7			 
24d7			 
24d7 c9				ret 
24d8			 
24d8			 
24d8			; get either a string ptr or a 16bit word from the data stack 
24d8			 
24d8			FORTH_DSP: macro 
24d8				call macro_forth_dsp 
24d8				endm 
24d8			 
24d8			macro_forth_dsp: 
24d8				; data stack pointer points to current word on tos 
24d8			 
24d8 2a 29 f9			ld hl,(cli_data_sp) 
24db			 
24db				if DEBUG_FORTH_PUSH 
24db						DMARK "DSP" 
24db f5				push af  
24dc 3a f0 24			ld a, (.dmark)  
24df 32 a6 fd			ld (debug_mark),a  
24e2 3a f1 24			ld a, (.dmark+1)  
24e5 32 a7 fd			ld (debug_mark+1),a  
24e8 3a f2 24			ld a, (.dmark+2)  
24eb 32 a8 fd			ld (debug_mark+2),a  
24ee 18 03			jr .pastdmark  
24f0 ..			.dmark: db "DSP"  
24f3 f1			.pastdmark: pop af  
24f4			endm  
# End of macro DMARK
24f4			 
24f4 cd ce 60				call display_data_sp 
24f7				;call break_point_state 
24f7				;rst 030h 
24f7				CALLMONITOR 
24f7 cd aa fd			call debug_vector  
24fa				endm  
# End of macro CALLMONITOR
24fa				endif 
24fa			 
24fa c9				ret 
24fb			 
24fb			; return hl to start of value on stack 
24fb			 
24fb			FORTH_DSP_VALUE: macro 
24fb				call macro_forth_dsp_value 
24fb				endm 
24fb			 
24fb			macro_forth_dsp_value: 
24fb			 
24fb				FORTH_DSP 
24fb cd d8 24			call macro_forth_dsp 
24fe				endm 
# End of macro FORTH_DSP
24fe			 
24fe d5				push de 
24ff			 
24ff 23				inc hl ; skip type 
2500			 
2500 5e				ld e, (hl) 
2501 23				inc hl 
2502 56				ld d, (hl) 
2503 eb				ex de,hl  
2504			 
2504 d1				pop de 
2505			 
2505 c9				ret 
2506			 
2506			; return hl to start of value to second item on stack 
2506			 
2506			FORTH_DSP_VALUEM1: macro 
2506				call macro_forth_dsp_value_m1 
2506				endm 
2506			 
2506			macro_forth_dsp_value_m1: 
2506			 
2506				FORTH_DSP 
2506 cd d8 24			call macro_forth_dsp 
2509				endm 
# End of macro FORTH_DSP
2509			 
2509 2b				dec hl 
250a 2b				dec hl 
250b			;	dec hl 
250b			 
250b d5				push de 
250c			 
250c 5e				ld e, (hl) 
250d 23				inc hl 
250e 56				ld d, (hl) 
250f eb				ex de,hl  
2510			 
2510 d1				pop de 
2511			 
2511 c9				ret 
2512			 
2512				 
2512			 
2512			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2512			 
2512			FORTH_DSP_POP: macro 
2512				call macro_forth_dsp_pop 
2512				endm 
2512			 
2512			 
2512			; get the tos data type 
2512			 
2512			FORTH_DSP_TYPE:   macro 
2512			 
2512				;FORTH_DSP_VALUE 
2512				FORTH_DSP 
2512				 
2512				; hl points to value 
2512				; check type 
2512			 
2512				ld a,(hl) 
2512			 
2512				endm 
2512			 
2512			; load the tos value into hl 
2512			 
2512			 
2512			FORTH_DSP_VALUEHL:  macro 
2512				call macro_dsp_valuehl 
2512				endm 
2512			 
2512			 
2512			 
2512			macro_dsp_valuehl: 
2512				FORTH_DSP_VALUE 
2512 cd fb 24			call macro_forth_dsp_value 
2515				endm 
# End of macro FORTH_DSP_VALUE
2515			 
2515				;FORTH_ERR_TOS_NOTNUM 
2515			 
2515				;inc hl   ; skip type id 
2515			 
2515			;	push de 
2515			; 
2515			;	ld e, (hl) 
2515			;	inc hl 
2515			;	ld d, (hl) 
2515			;	ex de,hl  
2515			 
2515			;	pop de 
2515			 
2515				if DEBUG_FORTH_PUSH 
2515						DMARK "DVL" 
2515 f5				push af  
2516 3a 2a 25			ld a, (.dmark)  
2519 32 a6 fd			ld (debug_mark),a  
251c 3a 2b 25			ld a, (.dmark+1)  
251f 32 a7 fd			ld (debug_mark+1),a  
2522 3a 2c 25			ld a, (.dmark+2)  
2525 32 a8 fd			ld (debug_mark+2),a  
2528 18 03			jr .pastdmark  
252a ..			.dmark: db "DVL"  
252d f1			.pastdmark: pop af  
252e			endm  
# End of macro DMARK
252e				CALLMONITOR 
252e cd aa fd			call debug_vector  
2531				endm  
# End of macro CALLMONITOR
2531				endif 
2531 c9				ret 
2532			 
2532			forth_apushstrhl:      
2532				; push of string requires use of cli_origptr 
2532				; bodge use 
2532			 
2532				; get current cli_origptr, save, update with temp pointer  
2532 ed 5b 79 f9		ld de, (cli_origptr) 
2536 22 79 f9			ld (cli_origptr), hl 
2539 d5				push de 
253a cd 84 24			call forth_apush 
253d d1				pop de 
253e ed 53 79 f9		ld (cli_origptr), de 
2542 c9			        ret	 
2543			 
2543			 
2543			; increase loop stack pointer and save hl to it 
2543				 
2543			FORTH_LOOP_NEXT: macro 
2543				call macro_forth_loop_next 
2543				;nop 
2543				endm 
2543			 
2543			macro_forth_loop_next: 
2543				if DEBUG_FORTH_STACK_GUARD 
2543 cd 31 75				call check_stacks 
2546				endif 
2546 e5				push hl 
2547 d5				push de 
2548 eb				ex de,hl 
2549 2a 2b f9			ld hl,(cli_loop_sp) 
254c 23				inc hl 
254d 23				inc hl 
254e					if DEBUG_FORTH_WORDS 
254e						DMARK "LNX" 
254e f5				push af  
254f 3a 63 25			ld a, (.dmark)  
2552 32 a6 fd			ld (debug_mark),a  
2555 3a 64 25			ld a, (.dmark+1)  
2558 32 a7 fd			ld (debug_mark+1),a  
255b 3a 65 25			ld a, (.dmark+2)  
255e 32 a8 fd			ld (debug_mark+2),a  
2561 18 03			jr .pastdmark  
2563 ..			.dmark: db "LNX"  
2566 f1			.pastdmark: pop af  
2567			endm  
# End of macro DMARK
2567						CALLMONITOR 
2567 cd aa fd			call debug_vector  
256a				endm  
# End of macro CALLMONITOR
256a					endif 
256a 22 2b f9			ld (cli_loop_sp),hl 
256d 73				ld (hl), e 
256e 23				inc hl 
256f 72				ld (hl), d 
2570 d1				pop de    ; been reversed so save a swap on restore 
2571 e1				pop hl 
2572				if DEBUG_FORTH_STACK_GUARD 
2572 cd 31 75				call check_stacks 
2575				endif 
2575 c9				ret 
2576			 
2576			; get current ret stack pointer and save to hl  
2576				 
2576			FORTH_LOOP_TOS: macro 
2576				call macro_forth_loop_tos 
2576				endm 
2576			 
2576			macro_forth_loop_tos: 
2576 d5				push de 
2577 2a 2b f9			ld hl,(cli_loop_sp) 
257a 5e				ld e, (hl) 
257b 23				inc hl 
257c 56				ld d, (hl) 
257d eb				ex de, hl 
257e d1				pop de 
257f c9				ret 
2580			 
2580			; pop loop stack pointer 
2580				 
2580			FORTH_LOOP_POP: macro 
2580				call macro_forth_loop_pop 
2580				endm 
2580			 
2580			 
2580			macro_forth_loop_pop: 
2580				if DEBUG_FORTH_STACK_GUARD 
2580					DMARK "LPP" 
2580 f5				push af  
2581 3a 95 25			ld a, (.dmark)  
2584 32 a6 fd			ld (debug_mark),a  
2587 3a 96 25			ld a, (.dmark+1)  
258a 32 a7 fd			ld (debug_mark+1),a  
258d 3a 97 25			ld a, (.dmark+2)  
2590 32 a8 fd			ld (debug_mark+2),a  
2593 18 03			jr .pastdmark  
2595 ..			.dmark: db "LPP"  
2598 f1			.pastdmark: pop af  
2599			endm  
# End of macro DMARK
2599 cd 31 75				call check_stacks 
259c					FORTH_CHK_LOOP_UNDER 
259c e5				push hl 
259d d5				push de 
259e 2a 2b f9			ld hl,(cli_loop_sp) 
25a1 11 65 f8			ld de, cli_loop_stack 
25a4 cd ed 0f			call cmp16 
25a7 da 4b 76			jp c, fault_loop_under 
25aa d1				pop de 
25ab e1				pop hl 
25ac				endm 
# End of macro FORTH_CHK_LOOP_UNDER
25ac				endif 
25ac e5				push hl 
25ad 2a 2b f9			ld hl,(cli_loop_sp) 
25b0 2b				dec hl 
25b1 2b				dec hl 
25b2 22 2b f9			ld (cli_loop_sp), hl 
25b5				; TODO do stack underflow checks 
25b5 e1				pop hl 
25b6				if DEBUG_FORTH_STACK_GUARD 
25b6 cd 31 75				call check_stacks 
25b9					FORTH_CHK_LOOP_UNDER 
25b9 e5				push hl 
25ba d5				push de 
25bb 2a 2b f9			ld hl,(cli_loop_sp) 
25be 11 65 f8			ld de, cli_loop_stack 
25c1 cd ed 0f			call cmp16 
25c4 da 4b 76			jp c, fault_loop_under 
25c7 d1				pop de 
25c8 e1				pop hl 
25c9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
25c9				endif 
25c9 c9				ret 
25ca			 
25ca			macro_forth_dsp_pop: 
25ca			 
25ca e5				push hl 
25cb			 
25cb				; release malloc data 
25cb			 
25cb				if DEBUG_FORTH_STACK_GUARD 
25cb cd 31 75				call check_stacks 
25ce					FORTH_CHK_DSP_UNDER 
25ce e5				push hl 
25cf d5				push de 
25d0 2a 29 f9			ld hl,(cli_data_sp) 
25d3 11 63 f6			ld de, cli_data_stack 
25d6 cd ed 0f			call cmp16 
25d9 da 3f 76			jp c, fault_dsp_under 
25dc d1				pop de 
25dd e1				pop hl 
25de				endm 
# End of macro FORTH_CHK_DSP_UNDER
25de				endif 
25de				;ld hl,(cli_data_sp) 
25de			if DEBUG_FORTH_DOT 
25de				DMARK "DPP" 
25de f5				push af  
25df 3a f3 25			ld a, (.dmark)  
25e2 32 a6 fd			ld (debug_mark),a  
25e5 3a f4 25			ld a, (.dmark+1)  
25e8 32 a7 fd			ld (debug_mark+1),a  
25eb 3a f5 25			ld a, (.dmark+2)  
25ee 32 a8 fd			ld (debug_mark+2),a  
25f1 18 03			jr .pastdmark  
25f3 ..			.dmark: db "DPP"  
25f6 f1			.pastdmark: pop af  
25f7			endm  
# End of macro DMARK
25f7				CALLMONITOR 
25f7 cd aa fd			call debug_vector  
25fa				endm  
# End of macro CALLMONITOR
25fa			endif	 
25fa			 
25fa			 
25fa			if FORTH_ENABLE_DSPPOPFREE 
25fa			 
25fa				FORTH_DSP 
25fa cd d8 24			call macro_forth_dsp 
25fd				endm 
# End of macro FORTH_DSP
25fd			 
25fd 7e				ld a, (hl) 
25fe fe 01			cp DS_TYPE_STR 
2600 20 23			jr nz, .skippopfree 
2602			 
2602				FORTH_DSP_VALUEHL 
2602 cd 12 25			call macro_dsp_valuehl 
2605				endm 
# End of macro FORTH_DSP_VALUEHL
2605 00				nop 
2606			if DEBUG_FORTH_DOT 
2606				DMARK "DPf" 
2606 f5				push af  
2607 3a 1b 26			ld a, (.dmark)  
260a 32 a6 fd			ld (debug_mark),a  
260d 3a 1c 26			ld a, (.dmark+1)  
2610 32 a7 fd			ld (debug_mark+1),a  
2613 3a 1d 26			ld a, (.dmark+2)  
2616 32 a8 fd			ld (debug_mark+2),a  
2619 18 03			jr .pastdmark  
261b ..			.dmark: db "DPf"  
261e f1			.pastdmark: pop af  
261f			endm  
# End of macro DMARK
261f				CALLMONITOR 
261f cd aa fd			call debug_vector  
2622				endm  
# End of macro CALLMONITOR
2622			endif	 
2622 cd 84 17			call free 
2625			.skippopfree: 
2625				 
2625			 
2625			endif 
2625			 
2625			if DEBUG_FORTH_DOT_KEY 
2625				DMARK "DP2" 
2625				CALLMONITOR 
2625			endif	 
2625			 
2625				; move pointer down 
2625			 
2625 2a 29 f9			ld hl,(cli_data_sp) 
2628 2b				dec hl 
2629 2b				dec hl 
262a			; PARSEV5 
262a 2b				dec hl 
262b 22 29 f9			ld (cli_data_sp), hl 
262e			 
262e				if DEBUG_FORTH_STACK_GUARD 
262e cd 31 75				call check_stacks 
2631					FORTH_CHK_DSP_UNDER 
2631 e5				push hl 
2632 d5				push de 
2633 2a 29 f9			ld hl,(cli_data_sp) 
2636 11 63 f6			ld de, cli_data_stack 
2639 cd ed 0f			call cmp16 
263c da 3f 76			jp c, fault_dsp_under 
263f d1				pop de 
2640 e1				pop hl 
2641				endm 
# End of macro FORTH_CHK_DSP_UNDER
2641				endif 
2641			 
2641 e1				pop hl 
2642			 
2642 c9				ret 
2643			 
2643			getwordathl: 
2643				; hl points to an address 
2643				; load hl with the word at that address 
2643			 
2643 d5				push de 
2644			 
2644 5e				ld e, (hl) 
2645 23				inc hl 
2646 56				ld d, (hl) 
2647 eb				ex de, hl 
2648			 
2648 d1				pop de 
2649 c9				ret 
264a			 
264a			 
264a			 
264a			 
264a			 
264a			; eof 
264a			 
# End of file forth_stackopsv5.asm
264a			endif 
264a			 
264a			loadwordinhl:	 
264a			 
264a d5				push de 
264b			 
264b 5e				ld e, (hl) 
264c 23				inc hl 
264d 56				ld d, (hl) 
264e eb				ex de,hl  
264f			 
264f d1				pop de 
2650			 
2650 c9				ret 
2651			 
2651			user_word_eol:  
2651				; hl contains the pointer to where to create a linked list item from the end 
2651				; of the user dict to continue on at the system word dict 
2651				 
2651				; poke the stub of the word list linked list to repoint to rom words 
2651			 
2651				; stub format 
2651				; db   word id 
2651				; dw    link to next word 
2651			        ; db char length of token 
2651				; db string + 0 term 
2651				; db exec code....  
2651			 
2651 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2653 77				ld (hl), a		; word id 
2654 23				inc hl 
2655			 
2655 11 20 28			ld de, sysdict 
2658 73				ld (hl), e		; next word link ie system dict 
2659 23				inc hl 
265a 72				ld (hl), d		; next word link ie system dict 
265b 23				inc hl	 
265c			 
265c			;	ld (hl), sysdict		; next word link ie system dict 
265c			;	inc hl 
265c			;	inc hl 
265c			 
265c			;	inc hl 
265c			;	inc hl 
265c			 
265c 3e 02			ld a, 2			; word length is 0 
265e 77				ld (hl), a	 
265f 23				inc hl 
2660			 
2660 3e 7e			ld a, '~'			; word length is 0 
2662 77				ld (hl), a	 
2663 23				inc hl 
2664 3e 00			ld a, 0			; save empty word 
2666 77				ld (hl), a 
2667			 
2667 c9				ret 
2668			 
2668				 
2668			 
2668			forthexec_cleanup: 
2668				FORTH_RSP_POP 
2668 cd e3 22			call macro_forth_rsp_pop 
266b				endm 
# End of macro FORTH_RSP_POP
266b c9				ret 
266c			 
266c			forth_call_hl: 
266c				; taking hl 
266c e5				push hl 
266d c9				ret 
266e			 
266e			; this is called to reset Forth system but keep existing uwords etc 
266e			 
266e			forth_warmstart: 
266e				; setup stack over/under flow checks 
266e				if DEBUG_FORTH_STACK_GUARD 
266e cd 17 75				call chk_stk_init 
2671				endif 
2671			 
2671				; init stack pointers  - * these stacks go upwards *  
2671 21 e7 f8			ld hl, cli_ret_stack 
2674 22 2d f9			ld (cli_ret_sp), hl	 
2677				; set bottom of stack 
2677 3e 00			ld a,0 
2679 77				ld (hl),a 
267a 23				inc hl 
267b 77				ld (hl),a 
267c			 
267c 21 63 f6			ld hl, cli_data_stack 
267f 22 29 f9			ld (cli_data_sp), hl	 
2682				; set bottom of stack 
2682 3e 00			ld a,0 
2684 77				ld (hl),a 
2685 23				inc hl 
2686 77				ld (hl),a 
2687			 
2687 21 65 f8			ld hl, cli_loop_stack 
268a 22 2b f9			ld (cli_loop_sp), hl	 
268d				; set bottom of stack 
268d 3e 00			ld a,0 
268f 77				ld (hl),a 
2690 23				inc hl 
2691 77				ld (hl),a 
2692			 
2692				; init extent of current open file 
2692			 
2692 3e 00			ld a, 0 
2694 32 a5 f9			ld (store_openext), a 
2697			 
2697 c9				ret 
2698			 
2698			 
2698			 
2698			; Cold Start - this is called to setup the whole Forth system 
2698			 
2698			forth_init: 
2698			 
2698				; setup stack over/under flow checks 
2698			 
2698			;	if DEBUG_FORTH_STACK_GUARD 
2698			;		call chk_stk_init 
2698			;	endif 
2698			 
2698				; enable auto display updates (slow.....) 
2698			 
2698 3e 01			ld a, 1 
269a 32 77 f9			ld (cli_autodisplay), a 
269d			 
269d				; if storage is in use disable long reads for now 
269d 3e 00			ld a, 0 
269f 32 b0 f9			ld (store_longread), a 
26a2			 
26a2			 
26a2				; show start up screen 
26a2			 
26a2 cd 9b 0d			call clear_display 
26a5			 
26a5 3e 00			ld a,0 
26a7 32 99 f9			ld (f_cursor_ptr), a 
26aa			 
26aa				; set start of word list in start of ram - for use when creating user words 
26aa			 
26aa 21 00 80			ld hl, baseram 
26ad 22 f9 f3			ld (os_last_new_uword), hl 
26b0 cd 51 26			call user_word_eol 
26b3				 
26b3			;		call display_data_sp 
26b3			;		call next_page_prompt 
26b3			 
26b3			 
26b3			 
26b3			 
26b3 c9				ret 
26b4			 
26b4 .. 00		.bootforth: db " Forth Kernel Init ",0 
26c8			 
26c8			; TODO push to stack 
26c8			 
26c8			;  
26c8			 
26c8			if FORTH_PARSEV2 
26c8			 
26c8			 
26c8				include "forth_parserv2.asm" 
26c8			 
26c8			endif 
26c8			 
26c8			 
26c8			; parse cli version 1 
26c8			 
26c8			if FORTH_PARSEV1 
26c8			 
26c8			 
26c8			 
26c8			      include "forth_parserv1.asm" 
26c8			endif 
26c8				 
26c8			if FORTH_PARSEV3 
26c8			 
26c8			 
26c8			 
26c8			      include "forth_parserv3.asm" 
26c8				include "forth_wordsv3.asm" 
26c8			endif 
26c8			 
26c8			if FORTH_PARSEV4 
26c8			 
26c8			 
26c8			 
26c8			      include "forth_parserv4.asm" 
26c8				include "forth_wordsv4.asm" 
26c8			endif 
26c8			 
26c8			if FORTH_PARSEV5 
26c8			 
26c8			 
26c8			 
26c8			      include "forth_parserv5.asm" 
26c8			 
26c8			 
26c8			; A better parser without using malloc and string copies all over the place.  
26c8			; Exec in situ should be faster 
26c8			 
26c8			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
26c8			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
26c8			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
26c8			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
26c8			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
26c8			WORD_SYS_END: equ 0   ; Opcode for all user words 
26c8			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
26c8			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
26c8			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
26c8			 
26c8			; Core word preamble macro 
26c8			 
26c8			CWHEAD:   macro nxtword opcode lit len opflags 
26c8				db WORD_SYS_CORE+opcode             
26c8				; internal op code number 
26c8				dw nxtword            
26c8				; link to next dict word block 
26c8				db len + 1 
26c8				; literal length of dict word inc zero term 
26c8				db lit,0              
26c8				; literal dict word 
26c8			        ; TODO db opflags        
26c8				endm 
26c8			 
26c8			 
26c8			NEXTW: macro  
26c8				jp macro_next 
26c8				endm 
26c8			 
26c8			macro_next: 
26c8			if DEBUG_FORTH_PARSE_KEY 
26c8				DMARK "NXT" 
26c8				CALLMONITOR 
26c8			endif	 
26c8			;	inc hl  ; skip token null term  
26c8 ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
26cc ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
26d0 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
26d3			if DEBUG_FORTH_PARSE_KEY 
26d3				DMARK "}AA" 
26d3				CALLMONITOR 
26d3			endif	 
26d3 c3 d6 27			jp execnext 
26d6				;jp exec1 
26d6			       
26d6			 
26d6			 
26d6			; Another go at the parser to compile  
26d6			 
26d6			 
26d6			; TODO rework parser to change all of the string words to byte tokens 
26d6			; TODO do a search for  
26d6			 
26d6			; TODO first run normal parser to zero term sections 
26d6			; TODO for each word do a token look up to get the op code 
26d6			; TODO need some means to flag to the exec that this is a byte code form    
26d6			 
26d6			 
26d6			forthcompile: 
26d6			 
26d6			; 
26d6			; line parse: 
26d6			;       parse raw input buffer 
26d6			;       tokenise the words 
26d6			;       malloc new copy (for looping etc) 
26d6			;       copy to malloc + current pc in line to start of string and add line term 
26d6			;       save on new rsp 
26d6			; 
26d6			 
26d6			; hl to point to the line to tokenise 
26d6			 
26d6			;	push hl 
26d6 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
26d9			 
26d9			;	ld a,0		; string term on input 
26d9			;	call strlent 
26d9			 
26d9			;	ld (os_tok_len), hl	 ; save string length 
26d9			 
26d9			;if DEBUG_FORTH_TOK 
26d9			;	ex de,hl		 
26d9			;endif 
26d9			 
26d9			;	pop hl 		; get back string pointer 
26d9			 
26d9			if DEBUG_FORTH_TOK 
26d9						DMARK "TOc" 
26d9				CALLMONITOR 
26d9			endif 
26d9 7e			.cptoken2:    ld a,(hl) 
26da 23				inc hl 
26db fe 7f			cp FORTH_END_BUFFER 
26dd 28 29			jr z, .cptokendone2 
26df fe 00			cp 0 
26e1 28 25			jr z, .cptokendone2 
26e3 fe 22			cp '"' 
26e5 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
26e7 fe 20			cp ' ' 
26e9 20 ee			jr nz,  .cptoken2 
26eb			 
26eb			; TODO consume comments held between ( and ) 
26eb			 
26eb				; we have a space so change to zero term for dict match later 
26eb 2b				dec hl 
26ec 3e 00			ld a,0 
26ee 77				ld (hl), a 
26ef 23				inc hl 
26f0 18 e7			jr .cptoken2 
26f2				 
26f2			 
26f2			.cptokenstr2: 
26f2				; skip all white space until either eol (because forgot to term) or end double quote 
26f2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
26f2				;inc hl ; skip current double quote 
26f2 7e				ld a,(hl) 
26f3 23				inc hl 
26f4 fe 22			cp '"' 
26f6 28 e1			jr z, .cptoken2 
26f8 fe 7f			cp FORTH_END_BUFFER 
26fa 28 0c			jr z, .cptokendone2 
26fc fe 00			cp 0 
26fe 28 08			jr z, .cptokendone2 
2700 fe 20			cp ' ' 
2702 28 02			jr z, .cptmp2 
2704 18 ec			jr .cptokenstr2 
2706			 
2706			.cptmp2:	; we have a space so change to zero term for dict match later 
2706				;dec hl 
2706				;ld a,"-"	; TODO remove this when working 
2706				;ld (hl), a 
2706				;inc hl 
2706 18 ea			jr .cptokenstr2 
2708			 
2708			.cptokendone2: 
2708				;inc hl 
2708 3e 7f			ld a, FORTH_END_BUFFER 
270a 77				ld (hl),a 
270b 23				inc hl 
270c 3e 21			ld a, '!' 
270e 77				ld (hl),a 
270f			 
270f 2a fd f3			ld hl,(os_tok_ptr) 
2712			         
2712			if DEBUG_FORTH_TOK 
2712						DMARK "Tc1" 
2712				CALLMONITOR 
2712			endif 
2712			 
2712				; push exec string to top of return stack 
2712				FORTH_RSP_NEXT 
2712 cd c2 22			call macro_forth_rsp_next 
2715				endm 
# End of macro FORTH_RSP_NEXT
2715 c9				ret 
2716			 
2716			; Another go at the parser need to simplify the process 
2716			 
2716			forthparse: 
2716			 
2716			; 
2716			; line parse: 
2716			;       parse raw input buffer 
2716			;       tokenise the words 
2716			;       malloc new copy (for looping etc) 
2716			;       copy to malloc + current pc in line to start of string and add line term 
2716			;       save on new rsp 
2716			; 
2716			 
2716			; hl to point to the line to tokenise 
2716			 
2716			;	push hl 
2716 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
2719			 
2719			;	ld a,0		; string term on input 
2719			;	call strlent 
2719			 
2719			;	ld (os_tok_len), hl	 ; save string length 
2719			 
2719			;if DEBUG_FORTH_TOK 
2719			;	ex de,hl		 
2719			;endif 
2719			 
2719			;	pop hl 		; get back string pointer 
2719			 
2719			if DEBUG_FORTH_TOK 
2719						DMARK "TOK" 
2719				CALLMONITOR 
2719			endif 
2719 7e			.ptoken2:    ld a,(hl) 
271a 23				inc hl 
271b fe 7f			cp FORTH_END_BUFFER 
271d 28 29			jr z, .ptokendone2 
271f fe 00			cp 0 
2721 28 25			jr z, .ptokendone2 
2723 fe 22			cp '"' 
2725 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2727 fe 20			cp ' ' 
2729 20 ee			jr nz,  .ptoken2 
272b			 
272b			; TODO consume comments held between ( and ) 
272b			 
272b				; we have a space so change to zero term for dict match later 
272b 2b				dec hl 
272c 3e 00			ld a,0 
272e 77				ld (hl), a 
272f 23				inc hl 
2730 18 e7			jr .ptoken2 
2732				 
2732			 
2732			.ptokenstr2: 
2732				; skip all white space until either eol (because forgot to term) or end double quote 
2732			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2732				;inc hl ; skip current double quote 
2732 7e				ld a,(hl) 
2733 23				inc hl 
2734 fe 22			cp '"' 
2736 28 e1			jr z, .ptoken2 
2738 fe 7f			cp FORTH_END_BUFFER 
273a 28 0c			jr z, .ptokendone2 
273c fe 00			cp 0 
273e 28 08			jr z, .ptokendone2 
2740 fe 20			cp ' ' 
2742 28 02			jr z, .ptmp2 
2744 18 ec			jr .ptokenstr2 
2746			 
2746			.ptmp2:	; we have a space so change to zero term for dict match later 
2746				;dec hl 
2746				;ld a,"-"	; TODO remove this when working 
2746				;ld (hl), a 
2746				;inc hl 
2746 18 ea			jr .ptokenstr2 
2748			 
2748			.ptokendone2: 
2748				;inc hl 
2748 3e 7f			ld a, FORTH_END_BUFFER 
274a 77				ld (hl),a 
274b 23				inc hl 
274c 3e 21			ld a, '!' 
274e 77				ld (hl),a 
274f			 
274f 2a fd f3			ld hl,(os_tok_ptr) 
2752			         
2752			if DEBUG_FORTH_TOK 
2752						DMARK "TK1" 
2752				CALLMONITOR 
2752			endif 
2752			 
2752				; push exec string to top of return stack 
2752				FORTH_RSP_NEXT 
2752 cd c2 22			call macro_forth_rsp_next 
2755				endm 
# End of macro FORTH_RSP_NEXT
2755 c9				ret 
2756			 
2756			; 
2756			;	; malloc size + buffer pointer + if is loop flag 
2756			;	ld hl,(os_tok_len) 		 ; get string length 
2756			; 
2756			;	ld a,l 
2756			; 
2756			;	cp 0			; we dont want to use a null string 
2756			;	ret z 
2756			; 
2756			;;	add 3    ; prefix malloc with buffer for current word ptr 
2756			; 
2756			;	add 5     ; TODO when certain not over writing memory remove 
2756			; 
2756			;		 
2756			; 
2756			;if DEBUG_FORTH_TOK 
2756			;			DMARK "TKE" 
2756			;	CALLMONITOR 
2756			;endif 
2756			; 
2756			;	ld l,a 
2756			;	ld h,0 
2756			;;	push hl   ; save required space for the copy later 
2756			;	call malloc 
2756			;if DEBUG_FORTH_TOK 
2756			;			DMARK "TKM" 
2756			;	CALLMONITOR 
2756			;endif 
2756			;	if DEBUG_FORTH_MALLOC_GUARD 
2756			;		push af 
2756			;		call ishlzero 
2756			;;		ld a, l 
2756			;;		add h 
2756			;;		cp 0 
2756			;		pop af 
2756			;		 
2756			;		call z,malloc_error 
2756			;	endif 
2756			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2756			; 
2756			; 
2756			;if DEBUG_FORTH_TOK 
2756			;			DMARK "TKR" 
2756			;	CALLMONITOR 
2756			;endif 
2756			; 
2756			;	FORTH_RSP_NEXT 
2756			; 
2756			;	;inc hl	 ; go past current buffer pointer 
2756			;	;inc hl 
2756			;	;inc hl   ; and past if loop flag 
2756			;		; TODO Need to set flag  
2756			; 
2756			;	 
2756			;	 
2756			;	ex de,hl	; malloc is dest 
2756			;	ld hl, (os_tok_len) 
2756			;;	pop bc 
2756			;	ld c, l                
2756			;	ld b,0 
2756			;	ld hl, (os_tok_ptr) 
2756			; 
2756			;if DEBUG_FORTH_TOK 
2756			;			DMARK "TKT" 
2756			;	CALLMONITOR 
2756			;endif 
2756			; 
2756			;	; do str cpy 
2756			; 
2756			;	ldir      ; copy byte in hl to de 
2756			; 
2756			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2756			; 
2756			;if DEBUG_FORTH_TOK 
2756			; 
2756			;			DMARK "TKY" 
2756			;	CALLMONITOR 
2756			;endif 
2756			;	;ld a,0 
2756			;	;ld a,FORTH_END_BUFFER 
2756			;	ex de, hl 
2756			;	;dec hl			 ; go back over the space delim at the end of word 
2756			;	;ld (hl),a 
2756			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2756			;	ld a,FORTH_END_BUFFER 
2756			;	ld (hl),a 
2756			;	inc hl 
2756			;	ld a,FORTH_END_BUFFER 
2756			;	ld (hl),a 
2756			; 
2756			;	; init the malloc area data 
2756			;	; set pc for in current area 
2756			;	;ld hl, (os_tok_malloc) 
2756			;	;inc hl 
2756			;	;inc hl 
2756			;	;inc hl 
2756			;	;ex de,hl 
2756			;	;ld hl, (os_tok_malloc) 
2756			;	;ld (hl),e 
2756			;	;inc hl 
2756			;	;ld (hl),d 
2756			; 
2756			; 
2756			;	ld hl,(os_tok_malloc) 
2756			;if DEBUG_FORTH_PARSE_KEY 
2756			;			DMARK "TKU" 
2756			;	CALLMONITOR 
2756			;endif 
2756			; 
2756			;	ret 
2756			 
2756			forthexec: 
2756			 
2756			; line exec: 
2756			; forth parser 
2756			 
2756			; 
2756			;       get current exec line on rsp 
2756			 
2756				FORTH_RSP_TOS 
2756 cd d9 22			call macro_forth_rsp_tos 
2759				endm 
# End of macro FORTH_RSP_TOS
2759			 
2759			;       restore current pc - hl points to malloc of data 
2759			 
2759				;ld e, (hl) 
2759				;inc hl 
2759				;ld d, (hl) 
2759				;ex de,hl 
2759			 
2759			 
2759			exec1: 
2759 22 fd f3			ld (os_tok_ptr), hl 
275c			 
275c				; copy our PC to working vars  
275c 22 7b f9			ld (cli_ptr), hl 
275f 22 79 f9			ld (cli_origptr), hl 
2762			 
2762 7e				ld a,(hl) 
2763 fe 7f			cp FORTH_END_BUFFER 
2765 c8				ret z 
2766			 
2766				; skip any nulls 
2766			 
2766 fe 00			cp 0 
2768 20 03			jr nz, .execword 
276a 23				inc hl 
276b 18 ec			jr exec1 
276d			 
276d			 
276d			.execword: 
276d			 
276d			 
276d			 
276d			if DEBUG_FORTH_PARSE_KEY 
276d						DMARK "KYQ" 
276d				CALLMONITOR 
276d			endif 
276d			;       while at start of word: 
276d			; get start of dict (in user area first) 
276d			 
276d 21 00 80		ld hl, baseram 
2770			;ld hl, sysdict 
2770 22 7d f9		ld (cli_nextword),hl 
2773			;           match word at pc 
2773			;           exec word 
2773			;           or push to dsp 
2773			;           forward to next token 
2773			;           if line term pop rsp and exit 
2773			;        
2773			 
2773			if DEBUG_FORTH_PARSE_KEY 
2773						DMARK "KYq" 
2773				CALLMONITOR 
2773			endif 
2773			 
2773			; 
2773			; word comp 
2773			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2773			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2773			;    move to start of word  
2773			;    compare word to cli_token 
2773			 
2773			.execpnword:	; HL at start of a word in the dictionary to check 
2773			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2773			;	ld (cli_ptr), hl 
2773			 
2773 2a 7d f9			ld hl,(cli_nextword) 
2776			 
2776 cd 19 28			call forth_tok_next 
2779			; tok next start here 
2779			;	; TODO skip compiled symbol for now 
2779			;	inc hl 
2779			; 
2779			;	; save pointer to next word 
2779			; 
2779			;	; hl now points to the address of the next word pointer  
2779			;	ld e, (hl) 
2779			;	inc hl 
2779			;	ld d, (hl) 
2779			;	inc l 
2779			; 
2779			;	ex de,hl 
2779			;if DEBUG_FORTH_PARSE_NEXTWORD 
2779			;	push bc 
2779			;	ld bc, (cli_nextword) 
2779			;			DMARK "NXW" 
2779			;	CALLMONITOR 
2779			;	pop bc 
2779			;endif 
2779			; tok next end here 
2779 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
277c eb				ex de, hl 
277d			 
277d			 
277d				; save the pointer of the current token - 1 to check against 
277d				 
277d 22 81 f9			ld (cli_token), hl   
2780				; TODO maybe remove below save if no debug 
2780				; save token string ptr for any debug later 
2780 23				inc hl  
2781 22 83 f9			ld (cli_origtoken), hl 
2784 2b				dec hl 
2785				; save pointer to the start of the next dictionay word 
2785 7e				ld a,(hl)   ; get string length 
2786 47				ld b,a 
2787			.execpnwordinc:  
2787 23				inc hl 
2788 10 fd			djnz .execpnwordinc 
278a 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
278d			 
278d				; now check the word token against the string being parsed 
278d			 
278d 2a 81 f9			ld hl,(cli_token) 
2790 23				inc hl     ; skip string length (use zero term instead to end) 
2791 22 81 f9			ld (cli_token), hl 
2794			 
2794			if DEBUG_FORTH_PARSE_KEY 
2794						DMARK "KY2" 
2794			endif 
2794			if DEBUG_FORTH_PARSE_EXEC 
2794				; see if disabled 
2794			 
2794			;	ld a, (os_view_disable) 
2794			;	cp '*' 
2794				ld a, (debug_vector) 
2794				cp $c9   ; RET  
2794				jr z, .skip 
2794			 
2794				push hl 
2794				push hl 
2794				call clear_display 
2794				ld de, .compword 
2794				ld a, display_row_1 
2794				call str_at_display 
2794				pop de 
2794				ld a, display_row_2 
2794				call str_at_display 
2794				ld hl,(cli_ptr) 
2794				ld a,(hl) 
2794			        ld hl, os_word_scratch 
2794				ld (hl),a 
2794				ld a,0 
2794				inc hl 
2794				ld (hl),a 	 
2794				ld de, os_word_scratch 
2794				ld a, display_row_2+10 
2794				call str_at_display 
2794				call update_display 
2794				ld a, 100 
2794				call aDelayInMS 
2794				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2794				call delay250ms 
2794				endif 
2794				pop hl 
2794			.skip:  
2794			endif	 
2794			.execpnchar:    ; compare char between token and string to parse 
2794			 
2794			if DEBUG_FORTH_PARSE_KEY 
2794						DMARK "Ky3" 
2794			endif 
2794			if DEBUG_FORTH_PARSE_EXEC 
2794				; see if disabled 
2794			 
2794			;	ld a, (os_view_disable) 
2794			;	cp '*' 
2794				ld a, (debug_vector) 
2794				cp $C9  ; RET 
2794				jr z, .skip2 
2794			 
2794			;	call clear_display 
2794			ld hl,(cli_token) 
2794			ld a,(hl) 
2794			ld (os_word_scratch),a 
2794				ld hl,(cli_ptr) 
2794			ld a,(hl) 
2794				ld (os_word_scratch+1),a 
2794				ld a,0 
2794				ld (os_word_scratch+2),a 
2794				ld de,os_word_scratch 
2794				ld a,display_row_4 
2794				call str_at_display 
2794				call update_display 
2794			.skip2:  
2794			endif 
2794 2a 81 f9			ld hl,(cli_token) 
2797 7e				ld a, (hl)	 ; char in word token 
2798 23				inc hl 		; move to next char 
2799 22 81 f9			ld (cli_token), hl ; and save it 
279c 47				ld b,a 
279d			 
279d 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
27a0 7e				ld a,(hl) 
27a1 23				inc hl 
27a2 22 7b f9			ld (cli_ptr), hl		; move to next char 
27a5 cd 3c 16			call toUpper 		; make sure the input string matches case 
27a8			 
27a8			if DEBUG_FORTH_PARSE 
27a8			endif 
27a8			 
27a8				; input stream end of token is a space so get rid of it 
27a8			 
27a8			;	cp ' ' 
27a8			;	jr nz, .pnskipspace 
27a8			; 
27a8			;	ld a, 0		; make same term as word token term 
27a8			; 
27a8			;.pnskipspace: 
27a8			 
27a8			if DEBUG_FORTH_PARSE_KEY 
27a8						DMARK "KY7" 
27a8			endif 
27a8 b8				cp b 
27a9 c2 bf 27			jp nz, .execpnskipword	 ; no match so move to next word 
27ac				 
27ac			;    if same 
27ac			;       scan for string terms 0 for token and 32 for input 
27ac			 
27ac				 
27ac			if DEBUG_FORTH_PARSE_KEY 
27ac						DMARK "KY8" 
27ac			endif 
27ac			 
27ac 80				add b			 
27ad fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
27af							; TODO need to make sure last word in zero term string is accounted for 
27af 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
27b1			 
27b1			 
27b1				; at end of both strings so both are exact match 
27b1			 
27b1			;       skip ptr for next word 
27b1			 
27b1 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
27b4 23				inc hl			 ; at next char 
27b5 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
27b8 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
27bb				 
27bb				 
27bb			if DEBUG_FORTH_PARSE_KEY 
27bb						DMARK "KY3" 
27bb			endif 
27bb			 
27bb			 
27bb			 
27bb			;       exec code block 
27bb			if DEBUG_FORTH_JP 
27bb				call clear_display 
27bb				call update_display 
27bb				call delay1s 
27bb				ld hl, (cli_execword)     ; save for next check if no match on this word 
27bb				ld a,h 
27bb				ld hl, os_word_scratch 
27bb				call hexout 
27bb				ld hl, (cli_execword)     ; save for next check if no match on this word 
27bb				ld a,l 
27bb				ld hl, os_word_scratch+2 
27bb				call hexout 
27bb				ld hl, os_word_scratch+4 
27bb				ld a,0 
27bb				ld (hl),a 
27bb				ld de,os_word_scratch 
27bb				call str_at_display 
27bb					ld a, display_row_2 
27bb					call str_at_display 
27bb				ld de, (cli_origtoken) 
27bb				ld a, display_row_1+10 
27bb					call str_at_display 
27bb			 
27bb				ld a,display_row_1 
27bb				ld de, .foundword 
27bb				ld a, display_row_3 
27bb				call str_at_display 
27bb				call update_display 
27bb				call delay1s 
27bb				call delay1s 
27bb				call delay1s 
27bb			endif 
27bb			 
27bb			if DEBUG_FORTH_PARSE_KEY 
27bb						DMARK "KYj" 
27bb			endif 
27bb				; TODO save the word pointer in this exec 
27bb			 
27bb 2a 7f f9			ld hl,(cli_execword) 
27be e9				jp (hl) 
27bf			 
27bf			 
27bf			;    if not same 
27bf			;	scan for zero term 
27bf			;	get ptr for next word 
27bf			;	goto word comp 
27bf			 
27bf			.execpnskipword:	; get pointer to next word 
27bf 2a 7d f9			ld hl,(cli_nextword) 
27c2			 
27c2 7e				ld a,(hl) 
27c3 fe 00			cp WORD_SYS_END 
27c5			;	cp 0 
27c5 28 09			jr z, .execendofdict			 ; at end of words 
27c7			 
27c7			if DEBUG_FORTH_PARSE_KEY 
27c7						DMARK "KY4" 
27c7			endif 
27c7			if DEBUG_FORTH_PARSE_EXEC 
27c7			 
27c7				; see if disabled 
27c7			 
27c7			;	ld a, (os_view_disable) 
27c7			;	cp '*' 
27c7				ld a,(debug_vector) 
27c7				cp $c9   ; RET 
27c7				jr z, .noskip 
27c7			 
27c7			 
27c7				ld de, .nowordfound 
27c7				ld a, display_row_3 
27c7				call str_at_display 
27c7				call update_display 
27c7				ld a, 100 
27c7				call aDelayInMS 
27c7				 
27c7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
27c7					call delay250ms 
27c7				endif 
27c7			.noskip:  
27c7			 
27c7			endif	 
27c7			 
27c7 2a 79 f9			ld hl,(cli_origptr) 
27ca 22 7b f9			ld (cli_ptr),hl 
27cd			 
27cd			if DEBUG_FORTH_PARSE_KEY 
27cd						DMARK "KY5" 
27cd			endif 
27cd c3 73 27			jp .execpnword			; else go to next word 
27d0			 
27d0			.execendofdict:  
27d0			 
27d0			if DEBUG_FORTH_PARSE_KEY 
27d0						DMARK "KYe" 
27d0			endif 
27d0			if DEBUG_FORTH_PARSE_EXEC 
27d0				; see if disabled 
27d0			 
27d0			;	ld a, (os_view_disable) 
27d0			;	cp '*' 
27d0				ld a,(debug_vector) 
27d0				cp $c9   ; ret 
27d0				jr z, .ispskip 
27d0			 
27d0				call clear_display 
27d0				call update_display 
27d0				call delay1s 
27d0				ld de, (cli_origptr) 
27d0				ld a, display_row_1 
27d0				call str_at_display 
27d0				 
27d0				ld de, .enddict 
27d0				ld a, display_row_3 
27d0				call str_at_display 
27d0				call update_display 
27d0				ld a, 100 
27d0				call aDelayInMS 
27d0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
27d0				call delay1s 
27d0				call delay1s 
27d0				call delay1s 
27d0				endif 
27d0			.ispskip:  
27d0				 
27d0			endif	 
27d0			 
27d0			 
27d0			 
27d0				; if the word is not a keyword then must be a literal so push it to stack 
27d0			 
27d0			; push token to stack to end of word 
27d0			 
27d0				STACKFRAME ON $1efe $2f9f 
27d0				if DEBUG_STACK_IMB 
27d0					if ON 
27d0						exx 
27d0						ld de, $1efe 
27d0						ld a, d 
27d0						ld hl, curframe 
27d0						call hexout 
27d0						ld a, e 
27d0						ld hl, curframe+2 
27d0						call hexout 
27d0						ld hl, $1efe 
27d0						push hl 
27d0						ld hl, $2f9f 
27d0						push hl 
27d0						exx 
27d0					endif 
27d0				endif 
27d0			endm 
# End of macro STACKFRAME
27d0			 
27d0 2a fd f3		ld hl,(os_tok_ptr) 
27d3 cd 84 24		call forth_apush 
27d6			 
27d6				STACKFRAMECHK ON $1efe $2f9f 
27d6				if DEBUG_STACK_IMB 
27d6					if ON 
27d6						exx 
27d6						ld hl, $2f9f 
27d6						pop de   ; $2f9f 
27d6						call cmp16 
27d6						jr nz, .spnosame 
27d6						ld hl, $1efe 
27d6						pop de   ; $1efe 
27d6						call cmp16 
27d6						jr z, .spfrsame 
27d6						.spnosame: call showsperror 
27d6						.spfrsame: nop 
27d6						exx 
27d6					endif 
27d6				endif 
27d6			endm 
# End of macro STACKFRAMECHK
27d6			 
27d6			execnext: 
27d6			 
27d6			if DEBUG_FORTH_PARSE_KEY 
27d6						DMARK "KY>" 
27d6			endif 
27d6			; move past token to next word 
27d6			 
27d6 2a fd f3		ld hl, (os_tok_ptr) 
27d9 3e 00		ld a, 0 
27db 01 ff 00		ld bc, 255     ; input buffer size 
27de ed b1		cpir 
27e0			 
27e0			if DEBUG_FORTH_PARSE_KEY 
27e0						DMARK "KY!" 
27e0				CALLMONITOR 
27e0			endif	 
27e0			; TODO this might place hl on the null, so will need to forward on??? 
27e0			;inc hl   ; see if this gets onto the next item 
27e0			 
27e0			 
27e0			; TODO pass a pointer to the buffer to push 
27e0			; TODO call function to push 
27e0			 
27e0			; look for end of input 
27e0			 
27e0			;inc hl 
27e0			;ld a,(hl) 
27e0			;cp FORTH_END_BUFFER 
27e0			;ret z 
27e0			 
27e0			 
27e0 c3 59 27		jp exec1 
27e3			 
27e3			 
27e3			 
27e3			 
27e3			 
27e3			 
27e3			 
27e3			 
27e3			 
27e3			findnexttok: 
27e3			 
27e3				; hl is pointer to move 
27e3				; de is the token to locate 
27e3			 
27e3					if DEBUG_FORTH 
27e3						DMARK "NTK" 
27e3						CALLMONITOR 
27e3					endif 
27e3 d5				push de 
27e4			 
27e4			.fnt1:	 
27e4				; find first char of token to locate 
27e4			 
27e4 1a				ld a, (de) 
27e5 4f				ld c,a 
27e6 7e				ld a,(hl) 
27e7 cd 3c 16			call toUpper 
27ea					if DEBUG_FORTH 
27ea						DMARK "NT1" 
27ea						CALLMONITOR 
27ea					endif 
27ea b9				cp c 
27eb			 
27eb 28 03			jr z, .fnt2cmpmorefirst	 
27ed			 
27ed				; first char not found move to next char 
27ed			 
27ed 23				inc hl 
27ee 18 f4			jr .fnt1 
27f0			 
27f0			.fnt2cmpmorefirst:	 
27f0				; first char of token found.  
27f0			 
27f0 e5				push hl     ; save start of token just in case it is the right one 
27f1 d9				exx 
27f2 e1				pop hl        ; save it to hl' 
27f3 d9				exx 
27f4			 
27f4			 
27f4			.fnt2cmpmore:	 
27f4				; compare the rest 
27f4				 
27f4 23				inc hl 
27f5 13				inc de 
27f6				 
27f6 1a				ld a, (de) 
27f7 4f				ld c,a 
27f8 7e				ld a,(hl) 
27f9 cd 3c 16			call toUpper 
27fc			 
27fc					if DEBUG_FORTH 
27fc						DMARK "NT2" 
27fc						CALLMONITOR 
27fc					endif 
27fc				; c has the token to find char 
27fc				; a has the mem to scan char 
27fc			 
27fc b9				cp c 
27fd 28 04			jr z,.fntmatch1 
27ff			 
27ff				; they are not the same 
27ff			 
27ff					if DEBUG_FORTH 
27ff						DMARK "NT3" 
27ff						CALLMONITOR 
27ff					endif 
27ff d1				pop de	; reset de token to look for 
2800 d5				push de 
2801 18 e1			jr .fnt1 
2803				 
2803			.fntmatch1: 
2803			 
2803				; is the same char a null which means we might have a full hit? 
2803					if DEBUG_FORTH 
2803						DMARK "NT4" 
2803						CALLMONITOR 
2803					endif 
2803			 
2803 fe 00			cp 0 
2805 28 0b			jr z, .fntmatchyes 
2807			 
2807				; are we at the end of the token to find? 
2807			 
2807					if DEBUG_FORTH 
2807						DMARK "NT5" 
2807						CALLMONITOR 
2807					endif 
2807 3e 00			ld a, 0 
2809 b9				cp c 
280a			 
280a c2 f4 27			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
280d			 
280d					if DEBUG_FORTH 
280d						DMARK "NT6" 
280d						CALLMONITOR 
280d					endif 
280d				; token to find is exhusted but no match to stream 
280d			 
280d				; restore tok pointer and continue on 
280d d1				pop de 
280e d5				push de 
280f c3 e4 27			jp .fnt1 
2812			 
2812			 
2812			.fntmatchyes: 
2812			 
2812				; hl now contains the end of the found token 
2812			 
2812				; get rid of saved token pointer to find 
2812			 
2812 d1				pop de 
2813			 
2813					if DEBUG_FORTH 
2813						DMARK "NT9" 
2813						CALLMONITOR 
2813					endif 
2813			 
2813				; hl will be on the null term so forward on 
2813			 
2813				; get back the saved start of the token 
2813			 
2813 d9				exx 
2814 e5				push hl     ; save start of token just in case it is the right one 
2815 d9				exx 
2816 e1				pop hl        ; save it to hl 
2817			 
2817 c9				ret 
2818			 
2818			 
2818			; LIST needs to find a specific token   
2818			; FORGET needs to find a spefici token 
2818			 
2818			; SAVE needs to find all tokens by flag 
2818			; WORDS just needs to scan through all  by flag 
2818			; UWORDS needs to scan through all by flag 
2818			 
2818			 
2818			; given hl as pointer to start of dict look up string 
2818			; return hl as pointer to start of word block 
2818			; or 0 if not found 
2818			 
2818			forth_find_tok: 
2818 c9				ret 
2819			 
2819			; given hl as pointer to dict structure 
2819			; move to the next dict block structure 
2819			 
2819			forth_tok_next: 
2819				; hl now points to the address of the next word pointer  
2819				; TODO skip compiled symbol for now 
2819			;	push de 
2819 23				inc hl 
281a 5e				ld e, (hl) 
281b 23				inc hl 
281c 56				ld d, (hl) 
281d 23				inc hl 
281e			 
281e eb				ex de,hl 
281f			if DEBUG_FORTH_PARSE_NEXTWORD 
281f				push bc 
281f				ld bc, (cli_nextword) 
281f						DMARK "NXW" 
281f				CALLMONITOR 
281f				pop bc 
281f			endif 
281f			;	pop de	 
281f c9				ret 
2820			 
2820			 
2820			 
2820			; eof 
# End of file forth_parserv5.asm
2820				include "forth_wordsv4.asm" 
2820			 
2820			; the core word dictionary v4 
2820			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2820			 
2820			; this is a linked list for each of the system words used 
2820			; user defined words will follow the same format but will be in ram 
2820			 
2820			 
2820			; 
2820			; 
2820			; define linked list: 
2820			; 
2820			; 1. compiled byte op code 
2820			; 2. len of text word 
2820			; 3. text word 
2820			; 4. ptr to next dictionary word 
2820			; 5. asm, calls etc for the word 
2820			; 
2820			;  if 1 == 0 then last word in dict  
2820			;   
2820			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2820			;  
2820			;  
2820			; create basic standard set of words 
2820			; 
2820			;  
2820			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2820			; 2DUP 2DROP 2SWAP  
2820			; @ C@ - get byte  
2820			; ! C! - store byte 
2820			; 0< true if less than zero 
2820			; 0= true if zero 
2820			; < >  
2820			; = true if same 
2820			; variables 
2820			 
2820			 
2820			; Hardware specific words I may need 
2820			; 
2820			; IN OUT  
2820			; calls to key util functions 
2820			; calls to hardward abstraction stuff 
2820			; easy control of frame buffers and lcd i/o 
2820			; keyboard  
2820			 
2820			 
2820			;DICT: macro 
2820			; op_code, len, word, next 
2820			;    word: 
2820			;    db op_code 
2820			;    ds word zero term 
2820			;    dw next 
2820			;    endm 
2820			 
2820			 
2820			 
2820			 
2820			; op code 1 is a flag for user define words which are to be handled differently 
2820			 
2820			 
2820			; 
2820			; 
2820			;    TODO on entry to a word this should be the expected environment 
2820			;    hl - tos value if number then held, if string this is the ptr 
2820			;    de -  
2820			 
2820			 
2820			; opcode ranges 
2820			; 0 - end of word dict 
2820			; 255 - user define words 
2820			 
2820			sysdict: 
2820			include "forth_opcodes.asm" 
2820			; op codes for forth keywords 
2820			; free to use code 0  
2820				OPCODE_HEAP: equ  1 
2820				OPCODE_EXEC: equ 2 
2820				OPCODE_DUP: equ 3 
2820				OPCODE_SWAP: equ 4 
2820				OPCODE_COLN: equ 5 
2820				OPCODE_SCOLN: equ 6 
2820				OPCODE_DROP: equ 7 
2820				OPCODE_DUP2: equ 8 
2820				OPCODE_DROP2: equ 9 
2820				OPCODE_SWAP2: equ 10 
2820				OPCODE_AT: equ 11 
2820				OPCODE_CAT: equ 12 
2820				OPCODE_BANG: equ 13 
2820				OPCODE_CBANG: equ 14 
2820				OPCODE_SCALL: equ 15 
2820				OPCODE_DEPTH: equ 16 
2820				OPCODE_OVER: equ 17 
2820				OPCODE_PAUSE: equ 18 
2820				OPCODE_PAUSES: equ 19 
2820				OPCODE_ROT: equ 20 
2820			;free to reuse	OPCODE_WORDS: equ 21 
2820			        OPCODE_NOT: equ 21 
2820				OPCODE_UWORDS: equ 22 
2820				OPCODE_BP: equ 23 
2820				OPCODE_MONITOR: equ 24  
2820				OPCODE_MALLOC: equ 25 
2820				OPCODE_FREE: equ 26 
2820				OPCODE_LIST: equ 27 
2820				OPCODE_FORGET: equ 28 
2820				OPCODE_NOP: equ 29 
2820				OPCODE_COMO: equ 30 
2820				OPCODE_COMC: equ 31 
2820			;free to reuse	OPCODE_ENDCORE: equ 32 
2820				OPCODE_AFTERSOUND: equ 33 
2820				OPCODE_GP2: equ 34 
2820				OPCODE_GP3: equ 35 
2820				OPCODE_GP4: equ 36 
2820				OPCODE_SIN: equ 37 
2820				OPCODE_SOUT: equ 38 
2820				OPCODE_SPIO: equ 39 
2820				OPCODE_SPICEH: equ 40 
2820				OPCODE_SPIOb: equ 41 
2820				OPCODE_SPII: equ 42 
2820				OPCODE_SESEL: equ 43 
2820				OPCODE_CARTDEV: equ 44 
2820			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2820				OPCODE_FB: equ 46 
2820				OPCODE_EMIT: equ 47 
2820				OPCODE_DOTH: equ 48 
2820				OPCODE_DOTF: equ 49 
2820				OPCODE_DOT: equ 50 
2820				OPCODE_CLS: equ 51 
2820				OPCODE_DRAW: equ 52 
2820				OPCODE_DUMP: equ 53 
2820				OPCODE_CDUMP: equ 54 
2820				OPCODE_DAT: equ 55 
2820				OPCODE_HOME: equ 56 
2820				OPCODE_SPACE: equ 57 
2820				OPCODE_SPACES: equ 58 
2820				OPCODE_SCROLL: equ 59 
2820				OPCODE_ATQ: equ 60 
2820				OPCODE_AUTODSP: equ 61 
2820				OPCODE_MENU: equ 62 
2820			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2820				OPCODE_THEN: equ 64 
2820				OPCODE_ELSE: equ 65 
2820				OPCODE_DO: equ 66 
2820				OPCODE_LOOP: equ 67 
2820				OPCODE_I: equ 68 
2820				OPCODE_DLOOP: equ 69  
2820				OPCODE_REPEAT: equ 70  
2820				OPCODE_UNTIL: equ 71 
2820				OPCODE_ENDFLOW: equ 72 
2820				OPCODE_WAITK: equ 73 
2820				OPCODE_ACCEPT: equ 74 
2820				OPCODE_EDIT: equ 75 
2820			;free to reuse	OPCODE_ENDKEY: equ 76 
2820				OPCODE_LZERO: equ 77 
2820				OPCODE_TZERO: equ 78 
2820				OPCODE_LESS: equ 79 
2820				OPCODE_GT: equ 80 
2820				OPCODE_EQUAL: equ 81  
2820			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2820				OPCODE_NEG: equ 83 
2820				OPCODE_DIV: equ 84 
2820				OPCODE_MUL: equ 85 
2820				OPCODE_MIN: equ 86 
2820				OPCODE_MAX: equ 87 
2820				OPCODE_RND16: equ 88 
2820				OPCODE_RND8: equ 89 
2820				OPCODE_RND: equ 90 
2820			;free to reuse	OPCODE_ENDMATHS: equ 91  
2820				OPCODE_BYNAME: equ 92 
2820				OPCODE_DIR: equ 93 
2820				OPCODE_SAVE: equ 94 
2820				OPCODE_LOAD: equ 95 
2820				OPCODE_BSAVE: equ 96 
2820				OPCODE_BLOAD: equ 97 
2820				OPCODE_SEO: equ 98  
2820				OPCODE_SEI: equ 99 
2820				OPCODE_SFREE: equ 100 
2820				OPCODE_SIZE: equ 101 
2820				OPCODE_CREATE: equ 102 
2820				OPCODE_APPEND: equ 103 
2820				OPCODE_SDEL: equ 104 
2820				OPCODE_OPEN: equ 105 
2820				OPCODE_READ: equ 106 
2820				OPCODE_EOF: equ 106 
2820				OPCODE_FORMAT: equ 107 
2820				OPCODE_LABEL: equ 108 
2820				OPCODE_LABELS: equ 109 
2820			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2820				OPCODE_UPPER: equ 111 
2820				OPCODE_LOWER: equ 112 
2820				OPCODE_SUBSTR: equ 113 
2820				OPCODE_LEFT: equ 114 
2820				OPCODE_RIGHT: equ 115 
2820				OPCODE_STR2NUM: equ 116 
2820				OPCODE_NUM2STR: equ 117 
2820				OPCODE_CONCAT: equ 118 
2820				OPCODE_FIND: equ 119 
2820				OPCODE_LEN: equ 120 
2820				OPCODE_CHAR: equ 121 
2820			; free to reuse	OPCODE_STRLEN: equ 122 
2820			; free to reuse	OPCODE_ENDSTR: equ 123 
2820				OPCODE_V0S: equ 124 
2820				OPCODE_V0Q: equ 125 
2820				OPCODE_V1S: equ 126 
2820				OPCODE_V1Q: equ 127 
2820				OPCODE_V2S: equ 128 
2820				OPCODE_V2Q: equ 129 
2820				OPCODE_V3S: equ 130 
2820				OPCODE_V3Q: equ 131 
2820			;free to reuse	OPCODE_END: equ 132 
2820				OPCODE_ZDUP: equ 133 
2820			 
2820			; eof 
# End of file forth_opcodes.asm
2820			 
2820			include "forth_words_core.asm" 
2820			 
2820			; | ## Core Words 
2820			 
2820			;if MALLOC_4 
2820			 
2820			.HEAP: 
2820			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2820 15				db WORD_SYS_CORE+OPCODE_HEAP             
2821 5f 28			dw .EXEC            
2823 05				db 4 + 1 
2824 .. 00			db "HEAP",0              
2829				endm 
# End of macro CWHEAD
2829			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2829			; | | u1 - Current number of bytes in the heap 
2829			; | | u2 - Remaining bytes left on the heap 
2829			; | |  
2829			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2829			 
2829			 
2829				if DEBUG_FORTH_WORDS_KEY 
2829					DMARK "HEP" 
2829 f5				push af  
282a 3a 3e 28			ld a, (.dmark)  
282d 32 a6 fd			ld (debug_mark),a  
2830 3a 3f 28			ld a, (.dmark+1)  
2833 32 a7 fd			ld (debug_mark+1),a  
2836 3a 40 28			ld a, (.dmark+2)  
2839 32 a8 fd			ld (debug_mark+2),a  
283c 18 03			jr .pastdmark  
283e ..			.dmark: db "HEP"  
2841 f1			.pastdmark: pop af  
2842			endm  
# End of macro DMARK
2842					CALLMONITOR 
2842 cd aa fd			call debug_vector  
2845				endm  
# End of macro CALLMONITOR
2845				endif 
2845 2a 0a 80			ld hl, (free_list )      
2848 11 0e 80			ld de, heap_start 
284b			 
284b ed 52			sbc hl, de  
284d			 
284d cd 1b 23			call forth_push_numhl 
2850			 
2850			 
2850 ed 5b 0a 80		ld de, (free_list )      
2854 21 d7 f0			ld hl, heap_end 
2857			 
2857 ed 52			sbc hl, de 
2859			 
2859 cd 1b 23			call forth_push_numhl 
285c				 
285c			 
285c				 
285c			 
285c			 
285c			 
285c				NEXTW 
285c c3 c8 26			jp macro_next 
285f				endm 
# End of macro NEXTW
285f			;endif 
285f			 
285f			.EXEC: 
285f			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
285f			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
285f			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
285f			;; > > 
285f			;; > >   
285f			;	STACKFRAME OFF $5efe $5f9f 
285f			; 
285f			;		if DEBUG_FORTH_WORDS_KEY 
285f			;			DMARK "EXE" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			; 
285f			;	FORTH_DSP_VALUEHL 
285f			; 
285f			;	FORTH_DSP_POP 
285f			; 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EX1" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;;	ld e,(hl) 
285f			;;	inc hl 
285f			;;	ld d,(hl) 
285f			;;	ex de,hl 
285f			; 
285f			;;		if DEBUG_FORTH_WORDS 
285f			;;			DMARK "EX2" 
285f			;;			CALLMONITOR 
285f			;;		endif 
285f			;	push hl 
285f			; 
285f			;	;ld a, 0 
285f			;	;ld a, FORTH_END_BUFFER 
285f			;	call strlenz 
285f			;	inc hl   ; include zero term to copy 
285f			;	inc hl   ; include term 
285f			;	inc hl   ; include term 
285f			;	ld b,0 
285f			;	ld c,l 
285f			;	pop hl 
285f			;	ld de, execscratch 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EX3" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;	ldir 
285f			; 
285f			; 
285f			;	ld hl, execscratch 
285f			; 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EXe" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			; 
285f			;	call forthparse 
285f			;	call forthexec 
285f			;;	call forthexec_cleanup 
285f			;;	call forthparse 
285f			;;	call forthexec 
285f			; 
285f			;	STACKFRAMECHK OFF $5efe $5f9f 
285f			; 
285f			;	; an immediate word so no need to process any more words 
285f			;	ret 
285f			;	NEXTW 
285f			 
285f			; dead code - old version  
285f			;	FORTH_RSP_NEXT 
285f			 
285f			;  
285f			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
285f			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
285f			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
285f			;	push hl 
285f			;	push de 
285f			;	push bc 
285f			; 
285f			; 
285f			;		if DEBUG_FORTH_WORDS_KEY 
285f			;			DMARK "EXR" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			; 
285f			; 
285f			; 
285f			;	;v5 FORTH_DSP_VALUE 
285f			;	FORTH_DSP_VALUEHL 
285f			; 
285f			;	; TODO do string type checks 
285f			; 
285f			;;v5	inc hl   ; skip type 
285f			; 
285f			;	push hl  ; source code  
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EX1" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;	ld a, 0 
285f			;	call strlent 
285f			; 
285f			;	inc hl 
285f			;	inc hl 
285f			;	inc hl 
285f			;	inc hl 
285f			; 
285f			;	push hl    ; size 
285f			; 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EX2" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;	call malloc 
285f			; 
285f			;	ex de, hl    ; de now contains malloc area 
285f			;	pop bc   	; get byte count 
285f			;	pop hl      ; get string to copy 
285f			; 
285f			;	push de     ; save malloc for free later 
285f			; 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EX3" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;	ldir       ; duplicate string 
285f			; 
285f			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
285f			;	 
285f			;	; TODO fix the parse would be better than this...  
285f			;	ex de, hl 
285f			;	dec hl 
285f			;	ld a, 0 
285f			;	ld (hl), a 
285f			;	dec hl 
285f			;	ld a, ' ' 
285f			;	ld (hl), a 
285f			;	dec hl 
285f			;	ld (hl), a 
285f			; 
285f			;	dec hl 
285f			;	ld (hl), a 
285f			; 
285f			; 
285f			;	FORTH_DSP_POP  
285f			; 
285f			;	pop hl     
285f			;	push hl    ; save malloc area 
285f			; 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EX4" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			; 
285f			;	call forthparse 
285f			;	call forthexec 
285f			;	 
285f			;	pop hl 
285f			;	if DEBUG_FORTH_WORDS 
285f			;		DMARK "EX5" 
285f			;		CALLMONITOR 
285f			;	endif 
285f			; 
285f			;	if FORTH_ENABLE_FREE 
285f			;	call free 
285f			;	endif 
285f			; 
285f			;	if DEBUG_FORTH_WORDS 
285f			;		DMARK "EX6" 
285f			;		CALLMONITOR 
285f			;	endif 
285f			; 
285f			;	pop bc 
285f			;	pop de 
285f			;	pop hl 
285f			;;	FORTH_RSP_POP	  
285f			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
285f			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
285f			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
285f			; 
285f			;	if DEBUG_FORTH_WORDS 
285f			;		DMARK "EX7" 
285f			;		CALLMONITOR 
285f			;	endif 
285f			;	NEXTW 
285f			 
285f			;.STKEXEC: 
285f			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
285f			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
285f			; 
285f			; 
285f			;		if DEBUG_FORTH_WORDS_KEY 
285f			;			DMARK "STX" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			; 
285f			;	FORTH_DSP_VALUEHL 
285f			; 
285f			;	ld (store_tmp1), hl    ; count 
285f			; 
285f			;	FORTH_DSP_POP 
285f			;.stkexec1: 
285f			;	ld hl, (store_tmp1)   ; count 
285f			;	ld a, 0 
285f			;	cp l 
285f			;	ret z 
285f			; 
285f			;	dec hl 
285f			;	ld (store_tmp1), hl    ; count 
285f			;	 
285f			;	FORTH_DSP_VALUEHL 
285f			;	push hl 
285f			;	 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EXp" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;	FORTH_DSP_POP 
285f			; 
285f			;	call strlenz 
285f			;	inc hl   ; include zero term to copy 
285f			;	inc hl   ; include zero term to copy 
285f			;	inc hl   ; include zero term to copy 
285f			;	ld b,0 
285f			;	ld c,l 
285f			;	pop hl 
285f			;	ld de, execscratch 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EX3" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;	ldir 
285f			; 
285f			; 
285f			;	ld hl, execscratch 
285f			; 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EXP" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			; 
285f			;	call forthparse 
285f			;	ld hl, execscratch 
285f			;		if DEBUG_FORTH_WORDS 
285f			;			DMARK "EXx" 
285f			;			CALLMONITOR 
285f			;		endif 
285f			;	call forthexec 
285f			; 
285f			;	jp .stkexec1 
285f			; 
285f			;	ret 
285f			 
285f			 
285f			.DUP: 
285f			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
285f 17				db WORD_SYS_CORE+OPCODE_DUP             
2860 d5 28			dw .ZDUP            
2862 04				db 3 + 1 
2863 .. 00			db "DUP",0              
2867				endm 
# End of macro CWHEAD
2867			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2867			 
2867				if DEBUG_FORTH_WORDS_KEY 
2867					DMARK "DUP" 
2867 f5				push af  
2868 3a 7c 28			ld a, (.dmark)  
286b 32 a6 fd			ld (debug_mark),a  
286e 3a 7d 28			ld a, (.dmark+1)  
2871 32 a7 fd			ld (debug_mark+1),a  
2874 3a 7e 28			ld a, (.dmark+2)  
2877 32 a8 fd			ld (debug_mark+2),a  
287a 18 03			jr .pastdmark  
287c ..			.dmark: db "DUP"  
287f f1			.pastdmark: pop af  
2880			endm  
# End of macro DMARK
2880					CALLMONITOR 
2880 cd aa fd			call debug_vector  
2883				endm  
# End of macro CALLMONITOR
2883				endif 
2883			 
2883				FORTH_DSP 
2883 cd d8 24			call macro_forth_dsp 
2886				endm 
# End of macro FORTH_DSP
2886			 
2886 7e				ld a, (HL) 
2887 fe 01			cp DS_TYPE_STR 
2889 20 25			jr nz, .dupinum 
288b			 
288b				; push another string 
288b			 
288b				FORTH_DSP_VALUEHL     		 
288b cd 12 25			call macro_dsp_valuehl 
288e				endm 
# End of macro FORTH_DSP_VALUEHL
288e			 
288e			if DEBUG_FORTH_WORDS 
288e				DMARK "DUs" 
288e f5				push af  
288f 3a a3 28			ld a, (.dmark)  
2892 32 a6 fd			ld (debug_mark),a  
2895 3a a4 28			ld a, (.dmark+1)  
2898 32 a7 fd			ld (debug_mark+1),a  
289b 3a a5 28			ld a, (.dmark+2)  
289e 32 a8 fd			ld (debug_mark+2),a  
28a1 18 03			jr .pastdmark  
28a3 ..			.dmark: db "DUs"  
28a6 f1			.pastdmark: pop af  
28a7			endm  
# End of macro DMARK
28a7				CALLMONITOR 
28a7 cd aa fd			call debug_vector  
28aa				endm  
# End of macro CALLMONITOR
28aa			endif 
28aa cd 89 23			call forth_push_str 
28ad			 
28ad				NEXTW 
28ad c3 c8 26			jp macro_next 
28b0				endm 
# End of macro NEXTW
28b0			 
28b0			 
28b0			.dupinum: 
28b0				 
28b0			 
28b0			 
28b0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28b0 cd 12 25			call macro_dsp_valuehl 
28b3				endm 
# End of macro FORTH_DSP_VALUEHL
28b3			 
28b3			; TODO add floating point number detection 
28b3			 
28b3			if DEBUG_FORTH_WORDS 
28b3				DMARK "DUi" 
28b3 f5				push af  
28b4 3a c8 28			ld a, (.dmark)  
28b7 32 a6 fd			ld (debug_mark),a  
28ba 3a c9 28			ld a, (.dmark+1)  
28bd 32 a7 fd			ld (debug_mark+1),a  
28c0 3a ca 28			ld a, (.dmark+2)  
28c3 32 a8 fd			ld (debug_mark+2),a  
28c6 18 03			jr .pastdmark  
28c8 ..			.dmark: db "DUi"  
28cb f1			.pastdmark: pop af  
28cc			endm  
# End of macro DMARK
28cc				CALLMONITOR 
28cc cd aa fd			call debug_vector  
28cf				endm  
# End of macro CALLMONITOR
28cf			endif 
28cf			 
28cf cd 1b 23			call forth_push_numhl 
28d2				NEXTW 
28d2 c3 c8 26			jp macro_next 
28d5				endm 
# End of macro NEXTW
28d5			.ZDUP: 
28d5			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
28d5 99				db WORD_SYS_CORE+OPCODE_ZDUP             
28d6 0d 29			dw .SWAP            
28d8 05				db 4 + 1 
28d9 .. 00			db "?DUP",0              
28de				endm 
# End of macro CWHEAD
28de			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
28de			 
28de				if DEBUG_FORTH_WORDS_KEY 
28de					DMARK "qDU" 
28de f5				push af  
28df 3a f3 28			ld a, (.dmark)  
28e2 32 a6 fd			ld (debug_mark),a  
28e5 3a f4 28			ld a, (.dmark+1)  
28e8 32 a7 fd			ld (debug_mark+1),a  
28eb 3a f5 28			ld a, (.dmark+2)  
28ee 32 a8 fd			ld (debug_mark+2),a  
28f1 18 03			jr .pastdmark  
28f3 ..			.dmark: db "qDU"  
28f6 f1			.pastdmark: pop af  
28f7			endm  
# End of macro DMARK
28f7					CALLMONITOR 
28f7 cd aa fd			call debug_vector  
28fa				endm  
# End of macro CALLMONITOR
28fa				endif 
28fa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28fa cd 12 25			call macro_dsp_valuehl 
28fd				endm 
# End of macro FORTH_DSP_VALUEHL
28fd			 
28fd e5				push hl 
28fe			 
28fe				; is it a zero? 
28fe			 
28fe 3e 00			ld a, 0 
2900 84				add h 
2901 85				add l 
2902			 
2902 e1				pop hl 
2903			 
2903 fe 00			cp 0 
2905 28 03			jr z, .dup2orig 
2907			 
2907			 
2907 cd 1b 23			call forth_push_numhl 
290a			 
290a			 
290a			; TODO add floating point number detection 
290a			 
290a			.dup2orig: 
290a			 
290a				NEXTW 
290a c3 c8 26			jp macro_next 
290d				endm 
# End of macro NEXTW
290d			.SWAP: 
290d			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
290d 18				db WORD_SYS_CORE+OPCODE_SWAP             
290e 4c 29			dw .COLN            
2910 05				db 4 + 1 
2911 .. 00			db "SWAP",0              
2916				endm 
# End of macro CWHEAD
2916			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2916				if DEBUG_FORTH_WORDS_KEY 
2916					DMARK "SWP" 
2916 f5				push af  
2917 3a 2b 29			ld a, (.dmark)  
291a 32 a6 fd			ld (debug_mark),a  
291d 3a 2c 29			ld a, (.dmark+1)  
2920 32 a7 fd			ld (debug_mark+1),a  
2923 3a 2d 29			ld a, (.dmark+2)  
2926 32 a8 fd			ld (debug_mark+2),a  
2929 18 03			jr .pastdmark  
292b ..			.dmark: db "SWP"  
292e f1			.pastdmark: pop af  
292f			endm  
# End of macro DMARK
292f					CALLMONITOR 
292f cd aa fd			call debug_vector  
2932				endm  
# End of macro CALLMONITOR
2932				endif 
2932			 
2932			; TODO Use os stack swap memory 
2932				FORTH_DSP_VALUEHL 
2932 cd 12 25			call macro_dsp_valuehl 
2935				endm 
# End of macro FORTH_DSP_VALUEHL
2935 e5				push hl     ; w2 
2936			 
2936				FORTH_DSP_POP 
2936 cd ca 25			call macro_forth_dsp_pop 
2939				endm 
# End of macro FORTH_DSP_POP
2939			 
2939				FORTH_DSP_VALUEHL 
2939 cd 12 25			call macro_dsp_valuehl 
293c				endm 
# End of macro FORTH_DSP_VALUEHL
293c			 
293c				FORTH_DSP_POP 
293c cd ca 25			call macro_forth_dsp_pop 
293f				endm 
# End of macro FORTH_DSP_POP
293f			 
293f d1				pop de     ; w2	, hl = w1 
2940			 
2940 eb				ex de, hl 
2941 d5				push de 
2942			 
2942 cd 1b 23			call forth_push_numhl 
2945			 
2945 e1				pop hl 
2946			 
2946 cd 1b 23			call forth_push_numhl 
2949				 
2949			 
2949				NEXTW 
2949 c3 c8 26			jp macro_next 
294c				endm 
# End of macro NEXTW
294c			.COLN: 
294c			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
294c 19				db WORD_SYS_CORE+OPCODE_COLN             
294d d8 2a			dw .SCOLN            
294f 02				db 1 + 1 
2950 .. 00			db ":",0              
2952				endm 
# End of macro CWHEAD
2952			; | : ( -- )         Create new word | DONE 
2952			 
2952				if DEBUG_FORTH_WORDS_KEY 
2952					DMARK "CLN" 
2952 f5				push af  
2953 3a 67 29			ld a, (.dmark)  
2956 32 a6 fd			ld (debug_mark),a  
2959 3a 68 29			ld a, (.dmark+1)  
295c 32 a7 fd			ld (debug_mark+1),a  
295f 3a 69 29			ld a, (.dmark+2)  
2962 32 a8 fd			ld (debug_mark+2),a  
2965 18 03			jr .pastdmark  
2967 ..			.dmark: db "CLN"  
296a f1			.pastdmark: pop af  
296b			endm  
# End of macro DMARK
296b					CALLMONITOR 
296b cd aa fd			call debug_vector  
296e				endm  
# End of macro CALLMONITOR
296e				endif 
296e			STACKFRAME OFF $8efe $989f 
296e				if DEBUG_STACK_IMB 
296e					if OFF 
296e						exx 
296e						ld de, $8efe 
296e						ld a, d 
296e						ld hl, curframe 
296e						call hexout 
296e						ld a, e 
296e						ld hl, curframe+2 
296e						call hexout 
296e						ld hl, $8efe 
296e						push hl 
296e						ld hl, $989f 
296e						push hl 
296e						exx 
296e					endif 
296e				endif 
296e			endm 
# End of macro STACKFRAME
296e			; get parser buffer length  of new word 
296e			 
296e			 
296e			 
296e				; move tok past this to start of name defintition 
296e				; TODO get word to define 
296e				; TODO Move past word token 
296e				; TODO get length of string up to the ';' 
296e			 
296e 2a fd f3		ld hl, (os_tok_ptr) 
2971 23			inc hl 
2972 23			inc hl 
2973			 
2973 3e 3b		ld a, ';' 
2975 cd 50 16		call strlent 
2978			 
2978 7d			ld a,l 
2979 32 ec f0		ld (os_new_parse_len), a 
297c			 
297c			 
297c			if DEBUG_FORTH_UWORD 
297c ed 5b fd f3	ld de, (os_tok_ptr) 
2980					DMARK ":01" 
2980 f5				push af  
2981 3a 95 29			ld a, (.dmark)  
2984 32 a6 fd			ld (debug_mark),a  
2987 3a 96 29			ld a, (.dmark+1)  
298a 32 a7 fd			ld (debug_mark+1),a  
298d 3a 97 29			ld a, (.dmark+2)  
2990 32 a8 fd			ld (debug_mark+2),a  
2993 18 03			jr .pastdmark  
2995 ..			.dmark: db ":01"  
2998 f1			.pastdmark: pop af  
2999			endm  
# End of macro DMARK
2999			CALLMONITOR 
2999 cd aa fd			call debug_vector  
299c				endm  
# End of macro CALLMONITOR
299c			endif 
299c			 
299c			; 
299c			;  new word memory layout: 
299c			;  
299c			;    : adg 6666 ;  
299c			; 
299c			;    db   1     ; user defined word  
299c 23			inc hl    
299d			;    dw   sysdict 
299d 23			inc hl 
299e 23			inc hl 
299f			;    db <word len>+1 (for null) 
299f 23			inc hl 
29a0			;    db .... <word> 
29a0			; 
29a0			 
29a0 23			inc hl    ; some extras for the word preamble before the above 
29a1 23			inc hl 
29a2 23			inc hl 
29a3 23			inc hl 
29a4 23			inc hl 
29a5 23			inc hl 
29a6 23			inc hl  
29a7 23			inc hl 
29a8 23			inc hl 
29a9 23			inc hl 
29aa 23			inc hl 
29ab 23			inc hl 
29ac 23			inc hl 
29ad 23			inc hl     ; TODO how many do we really need?     maybe only 6 
29ae			;       exec word buffer 
29ae			;	<ptr word>   
29ae 23			inc hl 
29af 23			inc hl 
29b0			;       <word list><null term> 7F final term 
29b0			 
29b0			 
29b0			if DEBUG_FORTH_UWORD 
29b0					DMARK ":02" 
29b0 f5				push af  
29b1 3a c5 29			ld a, (.dmark)  
29b4 32 a6 fd			ld (debug_mark),a  
29b7 3a c6 29			ld a, (.dmark+1)  
29ba 32 a7 fd			ld (debug_mark+1),a  
29bd 3a c7 29			ld a, (.dmark+2)  
29c0 32 a8 fd			ld (debug_mark+2),a  
29c3 18 03			jr .pastdmark  
29c5 ..			.dmark: db ":02"  
29c8 f1			.pastdmark: pop af  
29c9			endm  
# End of macro DMARK
29c9			CALLMONITOR 
29c9 cd aa fd			call debug_vector  
29cc				endm  
# End of macro CALLMONITOR
29cc			endif 
29cc			 
29cc			 
29cc				; malloc the size 
29cc			 
29cc cd ba 16			call malloc 
29cf 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
29d2			 
29d2			;    db   1     ; user defined word  
29d2 3e 01			ld a, WORD_SYS_UWORD  
29d4 77				ld (hl), a 
29d5			 
29d5 23			inc hl    
29d6			;    dw   sysdict 
29d6 11 20 28		ld de, sysdict       ; continue on with the scan to the system dict 
29d9 73			ld (hl), e 
29da 23			inc hl 
29db 72			ld (hl), d 
29dc 23			inc hl 
29dd			 
29dd			 
29dd			;    Setup dict word 
29dd			 
29dd 23			inc hl 
29de 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
29e1			 
29e1			; 1. get length of dict word 
29e1			 
29e1			 
29e1 2a fd f3		ld hl, (os_tok_ptr) 
29e4 23			inc hl 
29e5 23			inc hl    ; position to start of dict word 
29e6 3e 00		ld a, 0 
29e8 cd 50 16		call strlent 
29eb			 
29eb			 
29eb 23			inc hl    ; to include null??? 
29ec			 
29ec			; write length of dict word 
29ec			 
29ec ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
29f0 1b			dec de 
29f1 eb			ex de, hl 
29f2 73			ld (hl), e 
29f3 eb			ex de, hl 
29f4			 
29f4			 
29f4			 
29f4			; copy  
29f4 4d			ld c, l 
29f5 06 00		ld b, 0 
29f7 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
29fb 2a fd f3		ld hl, (os_tok_ptr) 
29fe 23			inc hl 
29ff 23			inc hl    ; position to start of dict word 
2a00			 
2a00			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2a00			 
2a00			; TODO need to convert word to upper case 
2a00			 
2a00			ucasetok:	 
2a00 7e			ld a,(hl) 
2a01 cd 3c 16		call toUpper 
2a04 77			ld (hl),a 
2a05 ed a0		ldi 
2a07 f2 00 2a		jp p, ucasetok 
2a0a			 
2a0a			 
2a0a			 
2a0a			; de now points to start of where the word body code should be placed 
2a0a ed 53 e8 f0	ld (os_new_work_ptr), de 
2a0e			; hl now points to the words to throw at forthexec which needs to be copied 
2a0e 22 e6 f0		ld (os_new_src_ptr), hl 
2a11			 
2a11			; TODO add 'call to forthexec' 
2a11			 
2a11			if DEBUG_FORTH_UWORD 
2a11 c5			push bc 
2a12 ed 4b ee f0	ld bc, (os_new_malloc) 
2a16					DMARK ":0x" 
2a16 f5				push af  
2a17 3a 2b 2a			ld a, (.dmark)  
2a1a 32 a6 fd			ld (debug_mark),a  
2a1d 3a 2c 2a			ld a, (.dmark+1)  
2a20 32 a7 fd			ld (debug_mark+1),a  
2a23 3a 2d 2a			ld a, (.dmark+2)  
2a26 32 a8 fd			ld (debug_mark+2),a  
2a29 18 03			jr .pastdmark  
2a2b ..			.dmark: db ":0x"  
2a2e f1			.pastdmark: pop af  
2a2f			endm  
# End of macro DMARK
2a2f			CALLMONITOR 
2a2f cd aa fd			call debug_vector  
2a32				endm  
# End of macro CALLMONITOR
2a32 c1			pop bc 
2a33			endif 
2a33			 
2a33			 
2a33			; create word preamble which should be: 
2a33			 
2a33			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2a33			 
2a33			;    ld hl, <word code> 
2a33			;    jp user_exec 
2a33			;    <word code bytes> 
2a33			 
2a33			 
2a33			;	inc de     ; TODO ??? or are we already past the word's null 
2a33 eb			ex de, hl 
2a34			 
2a34 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2a36			 
2a36 23			inc hl 
2a37 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2a3a 23			inc hl 
2a3b			 
2a3b 23			inc hl 
2a3c 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2a3e			 
2a3e 01 c9 5f		ld bc, user_exec 
2a41 23			inc hl 
2a42 71			ld (hl), c     ; poke address of user_exec 
2a43 23			inc hl 
2a44 70			ld (hl), b     
2a45			; 
2a45			;	inc hl 
2a45			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2a45			; 
2a45			; 
2a45			;	ld bc, macro_forth_rsp_next 
2a45			;	inc hl 
2a45			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2a45			;	inc hl 
2a45			;	ld (hl), b     
2a45			; 
2a45			;	inc hl 
2a45			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2a45			; 
2a45			; 
2a45			;	inc hl 
2a45			;	ld bc, forthexec 
2a45			;	ld (hl), c     ; poke address of forthexec 
2a45			;	inc hl 
2a45			;	ld (hl), b      
2a45			; 
2a45			;	inc hl 
2a45			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2a45			; 
2a45			;	ld bc, user_dict_next 
2a45			;	inc hl 
2a45			;	ld (hl), c     ; poke address of forthexec 
2a45			;	inc hl 
2a45			;	ld (hl), b      
2a45			 
2a45			; hl is now where we need to copy the word byte data to save this 
2a45			 
2a45 23			inc hl 
2a46 22 e4 f0		ld (os_new_exec), hl 
2a49			 
2a49			; copy definition 
2a49			 
2a49 eb			ex de, hl 
2a4a			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2a4a			;	inc de    ; skip the PC for this parse 
2a4a 3a ec f0		ld a, (os_new_parse_len) 
2a4d 4f			ld c, a 
2a4e 06 00		ld b, 0 
2a50 ed b0		ldir		 ; copy defintion 
2a52			 
2a52			 
2a52			; poke the address of where the new word bytes live for forthexec 
2a52			 
2a52 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2a55			 
2a55 ed 5b e4 f0	ld de, (os_new_exec)      
2a59			 
2a59 73			ld (hl), e 
2a5a 23			inc hl 
2a5b 72			ld (hl), d 
2a5c			 
2a5c				; TODO copy last user dict word next link to this word 
2a5c				; TODO update last user dict word to point to this word 
2a5c			; 
2a5c			; hl f923 de 812a ; bc 811a 
2a5c			 
2a5c			if DEBUG_FORTH_UWORD 
2a5c c5			push bc 
2a5d ed 4b ee f0	ld bc, (os_new_malloc) 
2a61					DMARK ":0A" 
2a61 f5				push af  
2a62 3a 76 2a			ld a, (.dmark)  
2a65 32 a6 fd			ld (debug_mark),a  
2a68 3a 77 2a			ld a, (.dmark+1)  
2a6b 32 a7 fd			ld (debug_mark+1),a  
2a6e 3a 78 2a			ld a, (.dmark+2)  
2a71 32 a8 fd			ld (debug_mark+2),a  
2a74 18 03			jr .pastdmark  
2a76 ..			.dmark: db ":0A"  
2a79 f1			.pastdmark: pop af  
2a7a			endm  
# End of macro DMARK
2a7a			CALLMONITOR 
2a7a cd aa fd			call debug_vector  
2a7d				endm  
# End of macro CALLMONITOR
2a7d c1			pop bc 
2a7e			endif 
2a7e			if DEBUG_FORTH_UWORD 
2a7e c5			push bc 
2a7f ed 4b ee f0	ld bc, (os_new_malloc) 
2a83 03			inc bc 
2a84 03			inc bc 
2a85 03			inc bc 
2a86 03			inc bc 
2a87 03			inc bc 
2a88 03			inc bc 
2a89 03			inc bc 
2a8a 03			inc bc 
2a8b			 
2a8b					DMARK ":0B" 
2a8b f5				push af  
2a8c 3a a0 2a			ld a, (.dmark)  
2a8f 32 a6 fd			ld (debug_mark),a  
2a92 3a a1 2a			ld a, (.dmark+1)  
2a95 32 a7 fd			ld (debug_mark+1),a  
2a98 3a a2 2a			ld a, (.dmark+2)  
2a9b 32 a8 fd			ld (debug_mark+2),a  
2a9e 18 03			jr .pastdmark  
2aa0 ..			.dmark: db ":0B"  
2aa3 f1			.pastdmark: pop af  
2aa4			endm  
# End of macro DMARK
2aa4			CALLMONITOR 
2aa4 cd aa fd			call debug_vector  
2aa7				endm  
# End of macro CALLMONITOR
2aa7 c1			pop bc 
2aa8			endif 
2aa8			 
2aa8			; update word dict linked list for new word 
2aa8			 
2aa8			 
2aa8 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2aab 23			inc hl     ; move to next work linked list ptr 
2aac			 
2aac ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
2ab0 73			ld (hl), e 
2ab1 23			inc hl 
2ab2 72			ld (hl), d 
2ab3			 
2ab3			if DEBUG_FORTH_UWORD 
2ab3 ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2ab7			endif 
2ab7			 
2ab7 ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
2abb			 
2abb			 
2abb			if DEBUG_FORTH_UWORD 
2abb					DMARK ":0+" 
2abb f5				push af  
2abc 3a d0 2a			ld a, (.dmark)  
2abf 32 a6 fd			ld (debug_mark),a  
2ac2 3a d1 2a			ld a, (.dmark+1)  
2ac5 32 a7 fd			ld (debug_mark+1),a  
2ac8 3a d2 2a			ld a, (.dmark+2)  
2acb 32 a8 fd			ld (debug_mark+2),a  
2ace 18 03			jr .pastdmark  
2ad0 ..			.dmark: db ":0+"  
2ad3 f1			.pastdmark: pop af  
2ad4			endm  
# End of macro DMARK
2ad4			CALLMONITOR 
2ad4 cd aa fd			call debug_vector  
2ad7				endm  
# End of macro CALLMONITOR
2ad7			endif 
2ad7			 
2ad7			STACKFRAMECHK OFF $8efe $989f 
2ad7				if DEBUG_STACK_IMB 
2ad7					if OFF 
2ad7						exx 
2ad7						ld hl, $989f 
2ad7						pop de   ; $989f 
2ad7						call cmp16 
2ad7						jr nz, .spnosame 
2ad7						ld hl, $8efe 
2ad7						pop de   ; $8efe 
2ad7						call cmp16 
2ad7						jr z, .spfrsame 
2ad7						.spnosame: call showsperror 
2ad7						.spfrsame: nop 
2ad7						exx 
2ad7					endif 
2ad7				endif 
2ad7			endm 
# End of macro STACKFRAMECHK
2ad7			 
2ad7 c9			ret    ; dont process any remaining parser tokens as they form new word 
2ad8			 
2ad8			 
2ad8			 
2ad8			 
2ad8			;		NEXT 
2ad8			.SCOLN: 
2ad8			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2ad8 06			db OPCODE_SCOLN 
2ad9 24 2b		dw .DROP 
2adb 02			db 2 
2adc .. 00		db ";",0           
2ade			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2ade				if DEBUG_FORTH_WORDS_KEY 
2ade					DMARK "SCN" 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 a6 fd			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 a7 fd			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 a8 fd			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "SCN"  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7					CALLMONITOR 
2af7 cd aa fd			call debug_vector  
2afa				endm  
# End of macro CALLMONITOR
2afa				endif 
2afa				FORTH_RSP_TOS 
2afa cd d9 22			call macro_forth_rsp_tos 
2afd				endm 
# End of macro FORTH_RSP_TOS
2afd e5				push hl 
2afe				FORTH_RSP_POP 
2afe cd e3 22			call macro_forth_rsp_pop 
2b01				endm 
# End of macro FORTH_RSP_POP
2b01 e1				pop hl 
2b02			;		ex de,hl 
2b02 22 fd f3			ld (os_tok_ptr),hl 
2b05			 
2b05			if DEBUG_FORTH_UWORD 
2b05					DMARK "SCL" 
2b05 f5				push af  
2b06 3a 1a 2b			ld a, (.dmark)  
2b09 32 a6 fd			ld (debug_mark),a  
2b0c 3a 1b 2b			ld a, (.dmark+1)  
2b0f 32 a7 fd			ld (debug_mark+1),a  
2b12 3a 1c 2b			ld a, (.dmark+2)  
2b15 32 a8 fd			ld (debug_mark+2),a  
2b18 18 03			jr .pastdmark  
2b1a ..			.dmark: db "SCL"  
2b1d f1			.pastdmark: pop af  
2b1e			endm  
# End of macro DMARK
2b1e			CALLMONITOR 
2b1e cd aa fd			call debug_vector  
2b21				endm  
# End of macro CALLMONITOR
2b21			endif 
2b21				NEXTW 
2b21 c3 c8 26			jp macro_next 
2b24				endm 
# End of macro NEXTW
2b24			 
2b24			.DROP: 
2b24			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2b24 1b				db WORD_SYS_CORE+OPCODE_DROP             
2b25 4f 2b			dw .DUP2            
2b27 05				db 4 + 1 
2b28 .. 00			db "DROP",0              
2b2d				endm 
# End of macro CWHEAD
2b2d			; | DROP ( w -- )   drop the TOS item   | DONE 
2b2d				if DEBUG_FORTH_WORDS_KEY 
2b2d					DMARK "DRP" 
2b2d f5				push af  
2b2e 3a 42 2b			ld a, (.dmark)  
2b31 32 a6 fd			ld (debug_mark),a  
2b34 3a 43 2b			ld a, (.dmark+1)  
2b37 32 a7 fd			ld (debug_mark+1),a  
2b3a 3a 44 2b			ld a, (.dmark+2)  
2b3d 32 a8 fd			ld (debug_mark+2),a  
2b40 18 03			jr .pastdmark  
2b42 ..			.dmark: db "DRP"  
2b45 f1			.pastdmark: pop af  
2b46			endm  
# End of macro DMARK
2b46					CALLMONITOR 
2b46 cd aa fd			call debug_vector  
2b49				endm  
# End of macro CALLMONITOR
2b49				endif 
2b49				FORTH_DSP_POP 
2b49 cd ca 25			call macro_forth_dsp_pop 
2b4c				endm 
# End of macro FORTH_DSP_POP
2b4c				NEXTW 
2b4c c3 c8 26			jp macro_next 
2b4f				endm 
# End of macro NEXTW
2b4f			.DUP2: 
2b4f			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2b4f 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2b50 94 2b			dw .DROP2            
2b52 05				db 4 + 1 
2b53 .. 00			db "2DUP",0              
2b58				endm 
# End of macro CWHEAD
2b58			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2b58				if DEBUG_FORTH_WORDS_KEY 
2b58					DMARK "2DU" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 a6 fd			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 a7 fd			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 a8 fd			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "2DU"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71					CALLMONITOR 
2b71 cd aa fd			call debug_vector  
2b74				endm  
# End of macro CALLMONITOR
2b74				endif 
2b74				FORTH_DSP_VALUEHL 
2b74 cd 12 25			call macro_dsp_valuehl 
2b77				endm 
# End of macro FORTH_DSP_VALUEHL
2b77 e5				push hl      ; 2 
2b78			 
2b78				FORTH_DSP_POP 
2b78 cd ca 25			call macro_forth_dsp_pop 
2b7b				endm 
# End of macro FORTH_DSP_POP
2b7b				 
2b7b				FORTH_DSP_VALUEHL 
2b7b cd 12 25			call macro_dsp_valuehl 
2b7e				endm 
# End of macro FORTH_DSP_VALUEHL
2b7e			;		push hl      ; 1 
2b7e			 
2b7e				FORTH_DSP_POP 
2b7e cd ca 25			call macro_forth_dsp_pop 
2b81				endm 
# End of macro FORTH_DSP_POP
2b81			 
2b81			;		pop hl       ; 1 
2b81 d1				pop de       ; 2 
2b82			 
2b82 cd 1b 23			call forth_push_numhl 
2b85 eb				ex de, hl 
2b86 cd 1b 23			call forth_push_numhl 
2b89			 
2b89				 
2b89 eb				ex de, hl 
2b8a			 
2b8a cd 1b 23			call forth_push_numhl 
2b8d eb				ex de, hl 
2b8e cd 1b 23			call forth_push_numhl 
2b91			 
2b91			 
2b91				NEXTW 
2b91 c3 c8 26			jp macro_next 
2b94				endm 
# End of macro NEXTW
2b94			.DROP2: 
2b94			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2b94 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2b95 c3 2b			dw .SWAP2            
2b97 06				db 5 + 1 
2b98 .. 00			db "2DROP",0              
2b9e				endm 
# End of macro CWHEAD
2b9e			; | 2DROP ( w w -- )    Double drop | DONE 
2b9e				if DEBUG_FORTH_WORDS_KEY 
2b9e					DMARK "2DR" 
2b9e f5				push af  
2b9f 3a b3 2b			ld a, (.dmark)  
2ba2 32 a6 fd			ld (debug_mark),a  
2ba5 3a b4 2b			ld a, (.dmark+1)  
2ba8 32 a7 fd			ld (debug_mark+1),a  
2bab 3a b5 2b			ld a, (.dmark+2)  
2bae 32 a8 fd			ld (debug_mark+2),a  
2bb1 18 03			jr .pastdmark  
2bb3 ..			.dmark: db "2DR"  
2bb6 f1			.pastdmark: pop af  
2bb7			endm  
# End of macro DMARK
2bb7					CALLMONITOR 
2bb7 cd aa fd			call debug_vector  
2bba				endm  
# End of macro CALLMONITOR
2bba				endif 
2bba				FORTH_DSP_POP 
2bba cd ca 25			call macro_forth_dsp_pop 
2bbd				endm 
# End of macro FORTH_DSP_POP
2bbd				FORTH_DSP_POP 
2bbd cd ca 25			call macro_forth_dsp_pop 
2bc0				endm 
# End of macro FORTH_DSP_POP
2bc0				NEXTW 
2bc0 c3 c8 26			jp macro_next 
2bc3				endm 
# End of macro NEXTW
2bc3			.SWAP2: 
2bc3			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2bc3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2bc4 ec 2b			dw .AT            
2bc6 06				db 5 + 1 
2bc7 .. 00			db "2SWAP",0              
2bcd				endm 
# End of macro CWHEAD
2bcd			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2bcd				if DEBUG_FORTH_WORDS_KEY 
2bcd					DMARK "2SW" 
2bcd f5				push af  
2bce 3a e2 2b			ld a, (.dmark)  
2bd1 32 a6 fd			ld (debug_mark),a  
2bd4 3a e3 2b			ld a, (.dmark+1)  
2bd7 32 a7 fd			ld (debug_mark+1),a  
2bda 3a e4 2b			ld a, (.dmark+2)  
2bdd 32 a8 fd			ld (debug_mark+2),a  
2be0 18 03			jr .pastdmark  
2be2 ..			.dmark: db "2SW"  
2be5 f1			.pastdmark: pop af  
2be6			endm  
# End of macro DMARK
2be6					CALLMONITOR 
2be6 cd aa fd			call debug_vector  
2be9				endm  
# End of macro CALLMONITOR
2be9				endif 
2be9			; TODO Use os stack swap memory 
2be9				NEXTW 
2be9 c3 c8 26			jp macro_next 
2bec				endm 
# End of macro NEXTW
2bec			.AT: 
2bec			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2bec 1f				db WORD_SYS_CORE+OPCODE_AT             
2bed 1e 2c			dw .CAT            
2bef 02				db 1 + 1 
2bf0 .. 00			db "@",0              
2bf2				endm 
# End of macro CWHEAD
2bf2			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2bf2			 
2bf2				if DEBUG_FORTH_WORDS_KEY 
2bf2					DMARK "AT." 
2bf2 f5				push af  
2bf3 3a 07 2c			ld a, (.dmark)  
2bf6 32 a6 fd			ld (debug_mark),a  
2bf9 3a 08 2c			ld a, (.dmark+1)  
2bfc 32 a7 fd			ld (debug_mark+1),a  
2bff 3a 09 2c			ld a, (.dmark+2)  
2c02 32 a8 fd			ld (debug_mark+2),a  
2c05 18 03			jr .pastdmark  
2c07 ..			.dmark: db "AT."  
2c0a f1			.pastdmark: pop af  
2c0b			endm  
# End of macro DMARK
2c0b					CALLMONITOR 
2c0b cd aa fd			call debug_vector  
2c0e				endm  
# End of macro CALLMONITOR
2c0e				endif 
2c0e			.getbyteat:	 
2c0e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c0e cd 12 25			call macro_dsp_valuehl 
2c11				endm 
# End of macro FORTH_DSP_VALUEHL
2c11				 
2c11			;		push hl 
2c11			 
2c11				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c11 cd ca 25			call macro_forth_dsp_pop 
2c14				endm 
# End of macro FORTH_DSP_POP
2c14			 
2c14			;		pop hl 
2c14			 
2c14 7e				ld a, (hl) 
2c15			 
2c15 6f				ld l, a 
2c16 26 00			ld h, 0 
2c18 cd 1b 23			call forth_push_numhl 
2c1b			 
2c1b				NEXTW 
2c1b c3 c8 26			jp macro_next 
2c1e				endm 
# End of macro NEXTW
2c1e			.CAT: 
2c1e			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2c1e 20				db WORD_SYS_CORE+OPCODE_CAT             
2c1f 47 2c			dw .BANG            
2c21 03				db 2 + 1 
2c22 .. 00			db "C@",0              
2c25				endm 
# End of macro CWHEAD
2c25			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2c25				if DEBUG_FORTH_WORDS_KEY 
2c25					DMARK "CAA" 
2c25 f5				push af  
2c26 3a 3a 2c			ld a, (.dmark)  
2c29 32 a6 fd			ld (debug_mark),a  
2c2c 3a 3b 2c			ld a, (.dmark+1)  
2c2f 32 a7 fd			ld (debug_mark+1),a  
2c32 3a 3c 2c			ld a, (.dmark+2)  
2c35 32 a8 fd			ld (debug_mark+2),a  
2c38 18 03			jr .pastdmark  
2c3a ..			.dmark: db "CAA"  
2c3d f1			.pastdmark: pop af  
2c3e			endm  
# End of macro DMARK
2c3e					CALLMONITOR 
2c3e cd aa fd			call debug_vector  
2c41				endm  
# End of macro CALLMONITOR
2c41				endif 
2c41 c3 0e 2c			jp .getbyteat 
2c44				NEXTW 
2c44 c3 c8 26			jp macro_next 
2c47				endm 
# End of macro NEXTW
2c47			.BANG: 
2c47			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2c47 21				db WORD_SYS_CORE+OPCODE_BANG             
2c48 7d 2c			dw .CBANG            
2c4a 02				db 1 + 1 
2c4b .. 00			db "!",0              
2c4d				endm 
# End of macro CWHEAD
2c4d			; | ! ( x w -- ) Store x at address w      | DONE 
2c4d				if DEBUG_FORTH_WORDS_KEY 
2c4d					DMARK "BNG" 
2c4d f5				push af  
2c4e 3a 62 2c			ld a, (.dmark)  
2c51 32 a6 fd			ld (debug_mark),a  
2c54 3a 63 2c			ld a, (.dmark+1)  
2c57 32 a7 fd			ld (debug_mark+1),a  
2c5a 3a 64 2c			ld a, (.dmark+2)  
2c5d 32 a8 fd			ld (debug_mark+2),a  
2c60 18 03			jr .pastdmark  
2c62 ..			.dmark: db "BNG"  
2c65 f1			.pastdmark: pop af  
2c66			endm  
# End of macro DMARK
2c66					CALLMONITOR 
2c66 cd aa fd			call debug_vector  
2c69				endm  
# End of macro CALLMONITOR
2c69				endif 
2c69			 
2c69			.storebyteat:		 
2c69				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c69 cd 12 25			call macro_dsp_valuehl 
2c6c				endm 
# End of macro FORTH_DSP_VALUEHL
2c6c				 
2c6c e5				push hl 
2c6d			 
2c6d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c6d cd ca 25			call macro_forth_dsp_pop 
2c70				endm 
# End of macro FORTH_DSP_POP
2c70			 
2c70				; get byte to poke 
2c70			 
2c70				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c70 cd 12 25			call macro_dsp_valuehl 
2c73				endm 
# End of macro FORTH_DSP_VALUEHL
2c73 e5				push hl 
2c74			 
2c74			 
2c74				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c74 cd ca 25			call macro_forth_dsp_pop 
2c77				endm 
# End of macro FORTH_DSP_POP
2c77			 
2c77			 
2c77 d1				pop de 
2c78 e1				pop hl 
2c79			 
2c79 73				ld (hl),e 
2c7a			 
2c7a			 
2c7a				NEXTW 
2c7a c3 c8 26			jp macro_next 
2c7d				endm 
# End of macro NEXTW
2c7d			.CBANG: 
2c7d			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2c7d 22				db WORD_SYS_CORE+OPCODE_CBANG             
2c7e a6 2c			dw .SCALL            
2c80 03				db 2 + 1 
2c81 .. 00			db "C!",0              
2c84				endm 
# End of macro CWHEAD
2c84			; | C!  ( x w -- ) Store x at address w  | DONE 
2c84				if DEBUG_FORTH_WORDS_KEY 
2c84					DMARK "CBA" 
2c84 f5				push af  
2c85 3a 99 2c			ld a, (.dmark)  
2c88 32 a6 fd			ld (debug_mark),a  
2c8b 3a 9a 2c			ld a, (.dmark+1)  
2c8e 32 a7 fd			ld (debug_mark+1),a  
2c91 3a 9b 2c			ld a, (.dmark+2)  
2c94 32 a8 fd			ld (debug_mark+2),a  
2c97 18 03			jr .pastdmark  
2c99 ..			.dmark: db "CBA"  
2c9c f1			.pastdmark: pop af  
2c9d			endm  
# End of macro DMARK
2c9d					CALLMONITOR 
2c9d cd aa fd			call debug_vector  
2ca0				endm  
# End of macro CALLMONITOR
2ca0				endif 
2ca0 c3 69 2c			jp .storebyteat 
2ca3				NEXTW 
2ca3 c3 c8 26			jp macro_next 
2ca6				endm 
# End of macro NEXTW
2ca6			.SCALL: 
2ca6			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2ca6 23				db WORD_SYS_CORE+OPCODE_SCALL             
2ca7 da 2c			dw .DEPTH            
2ca9 05				db 4 + 1 
2caa .. 00			db "CALL",0              
2caf				endm 
# End of macro CWHEAD
2caf			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2caf				if DEBUG_FORTH_WORDS_KEY 
2caf					DMARK "CLL" 
2caf f5				push af  
2cb0 3a c4 2c			ld a, (.dmark)  
2cb3 32 a6 fd			ld (debug_mark),a  
2cb6 3a c5 2c			ld a, (.dmark+1)  
2cb9 32 a7 fd			ld (debug_mark+1),a  
2cbc 3a c6 2c			ld a, (.dmark+2)  
2cbf 32 a8 fd			ld (debug_mark+2),a  
2cc2 18 03			jr .pastdmark  
2cc4 ..			.dmark: db "CLL"  
2cc7 f1			.pastdmark: pop af  
2cc8			endm  
# End of macro DMARK
2cc8					CALLMONITOR 
2cc8 cd aa fd			call debug_vector  
2ccb				endm  
# End of macro CALLMONITOR
2ccb				endif 
2ccb			 
2ccb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ccb cd 12 25			call macro_dsp_valuehl 
2cce				endm 
# End of macro FORTH_DSP_VALUEHL
2cce			 
2cce			;		push hl 
2cce			 
2cce				; destroy value TOS 
2cce			 
2cce				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cce cd ca 25			call macro_forth_dsp_pop 
2cd1				endm 
# End of macro FORTH_DSP_POP
2cd1			 
2cd1					 
2cd1			;		pop hl 
2cd1			 
2cd1				; how to do a call with hl???? save SP? 
2cd1 cd 6c 26			call forth_call_hl 
2cd4			 
2cd4			 
2cd4				; TODO push value back onto stack for another op etc 
2cd4			 
2cd4 cd 1b 23			call forth_push_numhl 
2cd7				NEXTW 
2cd7 c3 c8 26			jp macro_next 
2cda				endm 
# End of macro NEXTW
2cda			.DEPTH: 
2cda			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2cda 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2cdb 17 2d			dw .OVER            
2cdd 06				db 5 + 1 
2cde .. 00			db "DEPTH",0              
2ce4				endm 
# End of macro CWHEAD
2ce4			; | DEPTH ( -- u ) Push count of stack | DONE 
2ce4				; take current TOS and remove from base value div by two to get count 
2ce4				if DEBUG_FORTH_WORDS_KEY 
2ce4					DMARK "DEP" 
2ce4 f5				push af  
2ce5 3a f9 2c			ld a, (.dmark)  
2ce8 32 a6 fd			ld (debug_mark),a  
2ceb 3a fa 2c			ld a, (.dmark+1)  
2cee 32 a7 fd			ld (debug_mark+1),a  
2cf1 3a fb 2c			ld a, (.dmark+2)  
2cf4 32 a8 fd			ld (debug_mark+2),a  
2cf7 18 03			jr .pastdmark  
2cf9 ..			.dmark: db "DEP"  
2cfc f1			.pastdmark: pop af  
2cfd			endm  
# End of macro DMARK
2cfd					CALLMONITOR 
2cfd cd aa fd			call debug_vector  
2d00				endm  
# End of macro CALLMONITOR
2d00				endif 
2d00			 
2d00			 
2d00 2a 29 f9		ld hl, (cli_data_sp) 
2d03 11 63 f6		ld de, cli_data_stack 
2d06 ed 52		sbc hl,de 
2d08			 
2d08			; div by size of stack item 
2d08			 
2d08 5d			ld e,l 
2d09 0e 03		ld c, 3 
2d0b cd 5f 0f		call Div8 
2d0e			 
2d0e 6f			ld l,a 
2d0f 26 00		ld h,0 
2d11			 
2d11			;srl h 
2d11			;rr l 
2d11			 
2d11 cd 1b 23			call forth_push_numhl 
2d14				NEXTW 
2d14 c3 c8 26			jp macro_next 
2d17				endm 
# End of macro NEXTW
2d17			.OVER: 
2d17			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2d17 42				db WORD_SYS_CORE+46             
2d18 5e 2d			dw .PAUSE            
2d1a 05				db 4 + 1 
2d1b .. 00			db "OVER",0              
2d20				endm 
# End of macro CWHEAD
2d20			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2d20				if DEBUG_FORTH_WORDS_KEY 
2d20					DMARK "OVR" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 a6 fd			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 a7 fd			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 a8 fd			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "OVR"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39					CALLMONITOR 
2d39 cd aa fd			call debug_vector  
2d3c				endm  
# End of macro CALLMONITOR
2d3c				endif 
2d3c			 
2d3c			; TODO Use os stack swap memory 
2d3c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d3c cd 12 25			call macro_dsp_valuehl 
2d3f				endm 
# End of macro FORTH_DSP_VALUEHL
2d3f e5				push hl    ; n2 
2d40				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d40 cd ca 25			call macro_forth_dsp_pop 
2d43				endm 
# End of macro FORTH_DSP_POP
2d43			 
2d43				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d43 cd 12 25			call macro_dsp_valuehl 
2d46				endm 
# End of macro FORTH_DSP_VALUEHL
2d46 e5				push hl    ; n1 
2d47				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d47 cd ca 25			call macro_forth_dsp_pop 
2d4a				endm 
# End of macro FORTH_DSP_POP
2d4a			 
2d4a d1				pop de     ; n1 
2d4b e1				pop hl     ; n2 
2d4c			 
2d4c d5				push de 
2d4d e5				push hl 
2d4e d5				push de 
2d4f			 
2d4f				; push back  
2d4f			 
2d4f e1				pop hl 
2d50 cd 1b 23			call forth_push_numhl 
2d53 e1				pop hl 
2d54 cd 1b 23			call forth_push_numhl 
2d57 e1				pop hl 
2d58 cd 1b 23			call forth_push_numhl 
2d5b				NEXTW 
2d5b c3 c8 26			jp macro_next 
2d5e				endm 
# End of macro NEXTW
2d5e			 
2d5e			.PAUSE: 
2d5e			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2d5e 43				db WORD_SYS_CORE+47             
2d5f 93 2d			dw .PAUSES            
2d61 08				db 7 + 1 
2d62 .. 00			db "PAUSEMS",0              
2d6a				endm 
# End of macro CWHEAD
2d6a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2d6a				if DEBUG_FORTH_WORDS_KEY 
2d6a					DMARK "PMS" 
2d6a f5				push af  
2d6b 3a 7f 2d			ld a, (.dmark)  
2d6e 32 a6 fd			ld (debug_mark),a  
2d71 3a 80 2d			ld a, (.dmark+1)  
2d74 32 a7 fd			ld (debug_mark+1),a  
2d77 3a 81 2d			ld a, (.dmark+2)  
2d7a 32 a8 fd			ld (debug_mark+2),a  
2d7d 18 03			jr .pastdmark  
2d7f ..			.dmark: db "PMS"  
2d82 f1			.pastdmark: pop af  
2d83			endm  
# End of macro DMARK
2d83					CALLMONITOR 
2d83 cd aa fd			call debug_vector  
2d86				endm  
# End of macro CALLMONITOR
2d86				endif 
2d86				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d86 cd 12 25			call macro_dsp_valuehl 
2d89				endm 
# End of macro FORTH_DSP_VALUEHL
2d89			;		push hl    ; n2 
2d89				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d89 cd ca 25			call macro_forth_dsp_pop 
2d8c				endm 
# End of macro FORTH_DSP_POP
2d8c			;		pop hl 
2d8c			 
2d8c 7d				ld a, l 
2d8d cd c3 0c			call aDelayInMS 
2d90			       NEXTW 
2d90 c3 c8 26			jp macro_next 
2d93				endm 
# End of macro NEXTW
2d93			.PAUSES:  
2d93			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2d93 44				db WORD_SYS_CORE+48             
2d94 02 2e			dw .ROT            
2d96 06				db 5 + 1 
2d97 .. 00			db "PAUSE",0              
2d9d				endm 
# End of macro CWHEAD
2d9d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2d9d				if DEBUG_FORTH_WORDS_KEY 
2d9d					DMARK "PAU" 
2d9d f5				push af  
2d9e 3a b2 2d			ld a, (.dmark)  
2da1 32 a6 fd			ld (debug_mark),a  
2da4 3a b3 2d			ld a, (.dmark+1)  
2da7 32 a7 fd			ld (debug_mark+1),a  
2daa 3a b4 2d			ld a, (.dmark+2)  
2dad 32 a8 fd			ld (debug_mark+2),a  
2db0 18 03			jr .pastdmark  
2db2 ..			.dmark: db "PAU"  
2db5 f1			.pastdmark: pop af  
2db6			endm  
# End of macro DMARK
2db6					CALLMONITOR 
2db6 cd aa fd			call debug_vector  
2db9				endm  
# End of macro CALLMONITOR
2db9				endif 
2db9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2db9 cd 12 25			call macro_dsp_valuehl 
2dbc				endm 
# End of macro FORTH_DSP_VALUEHL
2dbc			;		push hl    ; n2 
2dbc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dbc cd ca 25			call macro_forth_dsp_pop 
2dbf				endm 
# End of macro FORTH_DSP_POP
2dbf			;		pop hl 
2dbf 45				ld b, l 
2dc0				if DEBUG_FORTH_WORDS 
2dc0					DMARK "PAU" 
2dc0 f5				push af  
2dc1 3a d5 2d			ld a, (.dmark)  
2dc4 32 a6 fd			ld (debug_mark),a  
2dc7 3a d6 2d			ld a, (.dmark+1)  
2dca 32 a7 fd			ld (debug_mark+1),a  
2dcd 3a d7 2d			ld a, (.dmark+2)  
2dd0 32 a8 fd			ld (debug_mark+2),a  
2dd3 18 03			jr .pastdmark  
2dd5 ..			.dmark: db "PAU"  
2dd8 f1			.pastdmark: pop af  
2dd9			endm  
# End of macro DMARK
2dd9					CALLMONITOR 
2dd9 cd aa fd			call debug_vector  
2ddc				endm  
# End of macro CALLMONITOR
2ddc				endif 
2ddc c5			.pauses1:	push bc 
2ddd cd de 0c			call delay1s 
2de0 c1				pop bc 
2de1				if DEBUG_FORTH_WORDS 
2de1					DMARK "PA1" 
2de1 f5				push af  
2de2 3a f6 2d			ld a, (.dmark)  
2de5 32 a6 fd			ld (debug_mark),a  
2de8 3a f7 2d			ld a, (.dmark+1)  
2deb 32 a7 fd			ld (debug_mark+1),a  
2dee 3a f8 2d			ld a, (.dmark+2)  
2df1 32 a8 fd			ld (debug_mark+2),a  
2df4 18 03			jr .pastdmark  
2df6 ..			.dmark: db "PA1"  
2df9 f1			.pastdmark: pop af  
2dfa			endm  
# End of macro DMARK
2dfa					CALLMONITOR 
2dfa cd aa fd			call debug_vector  
2dfd				endm  
# End of macro CALLMONITOR
2dfd				endif 
2dfd 10 dd			djnz .pauses1 
2dff			 
2dff			       NEXTW 
2dff c3 c8 26			jp macro_next 
2e02				endm 
# End of macro NEXTW
2e02			.ROT: 
2e02			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2e02 45				db WORD_SYS_CORE+49             
2e03 50 2e			dw .UWORDS            
2e05 04				db 3 + 1 
2e06 .. 00			db "ROT",0              
2e0a				endm 
# End of macro CWHEAD
2e0a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2e0a				if DEBUG_FORTH_WORDS_KEY 
2e0a					DMARK "ROT" 
2e0a f5				push af  
2e0b 3a 1f 2e			ld a, (.dmark)  
2e0e 32 a6 fd			ld (debug_mark),a  
2e11 3a 20 2e			ld a, (.dmark+1)  
2e14 32 a7 fd			ld (debug_mark+1),a  
2e17 3a 21 2e			ld a, (.dmark+2)  
2e1a 32 a8 fd			ld (debug_mark+2),a  
2e1d 18 03			jr .pastdmark  
2e1f ..			.dmark: db "ROT"  
2e22 f1			.pastdmark: pop af  
2e23			endm  
# End of macro DMARK
2e23					CALLMONITOR 
2e23 cd aa fd			call debug_vector  
2e26				endm  
# End of macro CALLMONITOR
2e26				endif 
2e26			 
2e26			; TODO Use os stack swap memory 
2e26				FORTH_DSP_VALUEHL 
2e26 cd 12 25			call macro_dsp_valuehl 
2e29				endm 
# End of macro FORTH_DSP_VALUEHL
2e29 e5				push hl    ; u3  
2e2a			 
2e2a				FORTH_DSP_POP 
2e2a cd ca 25			call macro_forth_dsp_pop 
2e2d				endm 
# End of macro FORTH_DSP_POP
2e2d			 
2e2d				FORTH_DSP_VALUEHL 
2e2d cd 12 25			call macro_dsp_valuehl 
2e30				endm 
# End of macro FORTH_DSP_VALUEHL
2e30 e5				push hl     ; u2 
2e31			 
2e31				FORTH_DSP_POP 
2e31 cd ca 25			call macro_forth_dsp_pop 
2e34				endm 
# End of macro FORTH_DSP_POP
2e34			 
2e34				FORTH_DSP_VALUEHL 
2e34 cd 12 25			call macro_dsp_valuehl 
2e37				endm 
# End of macro FORTH_DSP_VALUEHL
2e37 e5				push hl     ; u1 
2e38			 
2e38				FORTH_DSP_POP 
2e38 cd ca 25			call macro_forth_dsp_pop 
2e3b				endm 
# End of macro FORTH_DSP_POP
2e3b			 
2e3b c1				pop bc      ; u1 
2e3c e1				pop hl      ; u2 
2e3d d1				pop de      ; u3 
2e3e			 
2e3e			 
2e3e c5				push bc 
2e3f d5				push de 
2e40 e5				push hl 
2e41			 
2e41			 
2e41 e1				pop hl 
2e42 cd 1b 23			call forth_push_numhl 
2e45			 
2e45 e1				pop hl 
2e46 cd 1b 23			call forth_push_numhl 
2e49			 
2e49 e1				pop hl 
2e4a cd 1b 23			call forth_push_numhl 
2e4d				 
2e4d			 
2e4d			 
2e4d			 
2e4d			 
2e4d			 
2e4d			       NEXTW 
2e4d c3 c8 26			jp macro_next 
2e50				endm 
# End of macro NEXTW
2e50			 
2e50			.UWORDS: 
2e50			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2e50 50				db WORD_SYS_CORE+60             
2e51 12 2f			dw .BP            
2e53 07				db 6 + 1 
2e54 .. 00			db "UWORDS",0              
2e5b				endm 
# End of macro CWHEAD
2e5b			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2e5b			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2e5b			; | | Following the count are the individual words. 
2e5b			; | | 
2e5b			; | | e.g. UWORDS 
2e5b			; | | BOX DIRLIST 2 
2e5b			; | |  
2e5b			; | | Can be used to save the words to storage via: 
2e5b			; | | UWORDS $01 DO $01 APPEND LOOP 
2e5b			if DEBUG_FORTH_WORDS_KEY 
2e5b				DMARK "UWR" 
2e5b f5				push af  
2e5c 3a 70 2e			ld a, (.dmark)  
2e5f 32 a6 fd			ld (debug_mark),a  
2e62 3a 71 2e			ld a, (.dmark+1)  
2e65 32 a7 fd			ld (debug_mark+1),a  
2e68 3a 72 2e			ld a, (.dmark+2)  
2e6b 32 a8 fd			ld (debug_mark+2),a  
2e6e 18 03			jr .pastdmark  
2e70 ..			.dmark: db "UWR"  
2e73 f1			.pastdmark: pop af  
2e74			endm  
# End of macro DMARK
2e74				CALLMONITOR 
2e74 cd aa fd			call debug_vector  
2e77				endm  
# End of macro CALLMONITOR
2e77			endif 
2e77 21 00 80			ld hl, baseram 
2e7a				;ld hl, baseusermem 
2e7a 01 00 00			ld bc, 0    ; start a counter 
2e7d			 
2e7d			; skip dict stub 
2e7d			 
2e7d cd 19 28			call forth_tok_next 
2e80			 
2e80			 
2e80			; while we have words to look for 
2e80			 
2e80 7e			.douscan:	ld a, (hl)      
2e81			if DEBUG_FORTH_WORDS 
2e81				DMARK "UWs" 
2e81 f5				push af  
2e82 3a 96 2e			ld a, (.dmark)  
2e85 32 a6 fd			ld (debug_mark),a  
2e88 3a 97 2e			ld a, (.dmark+1)  
2e8b 32 a7 fd			ld (debug_mark+1),a  
2e8e 3a 98 2e			ld a, (.dmark+2)  
2e91 32 a8 fd			ld (debug_mark+2),a  
2e94 18 03			jr .pastdmark  
2e96 ..			.dmark: db "UWs"  
2e99 f1			.pastdmark: pop af  
2e9a			endm  
# End of macro DMARK
2e9a				CALLMONITOR 
2e9a cd aa fd			call debug_vector  
2e9d				endm  
# End of macro CALLMONITOR
2e9d			endif 
2e9d fe 00			cp WORD_SYS_END 
2e9f 28 4d			jr z, .udone 
2ea1 fe 01			cp WORD_SYS_UWORD 
2ea3 20 44			jr nz, .nuword 
2ea5			 
2ea5			if DEBUG_FORTH_WORDS 
2ea5				DMARK "UWu" 
2ea5 f5				push af  
2ea6 3a ba 2e			ld a, (.dmark)  
2ea9 32 a6 fd			ld (debug_mark),a  
2eac 3a bb 2e			ld a, (.dmark+1)  
2eaf 32 a7 fd			ld (debug_mark+1),a  
2eb2 3a bc 2e			ld a, (.dmark+2)  
2eb5 32 a8 fd			ld (debug_mark+2),a  
2eb8 18 03			jr .pastdmark  
2eba ..			.dmark: db "UWu"  
2ebd f1			.pastdmark: pop af  
2ebe			endm  
# End of macro DMARK
2ebe				CALLMONITOR 
2ebe cd aa fd			call debug_vector  
2ec1				endm  
# End of macro CALLMONITOR
2ec1			endif 
2ec1				; we have a uword so push its name to the stack 
2ec1			 
2ec1 e5				push hl  ; save so we can move to next dict block 
2ec2			 
2ec2				; skip opcode 
2ec2 23				inc hl  
2ec3				; skip next ptr 
2ec3 23				inc hl  
2ec4 23				inc hl 
2ec5				; skip len 
2ec5 23				inc hl 
2ec6			if DEBUG_FORTH_WORDS 
2ec6				DMARK "UWt" 
2ec6 f5				push af  
2ec7 3a db 2e			ld a, (.dmark)  
2eca 32 a6 fd			ld (debug_mark),a  
2ecd 3a dc 2e			ld a, (.dmark+1)  
2ed0 32 a7 fd			ld (debug_mark+1),a  
2ed3 3a dd 2e			ld a, (.dmark+2)  
2ed6 32 a8 fd			ld (debug_mark+2),a  
2ed9 18 03			jr .pastdmark  
2edb ..			.dmark: db "UWt"  
2ede f1			.pastdmark: pop af  
2edf			endm  
# End of macro DMARK
2edf				CALLMONITOR 
2edf cd aa fd			call debug_vector  
2ee2				endm  
# End of macro CALLMONITOR
2ee2			endif 
2ee2 03				inc bc 
2ee3			 
2ee3 c5				push bc 
2ee4 cd 89 23			call forth_push_str 
2ee7 c1				pop bc 
2ee8			 
2ee8 e1				pop hl 	 
2ee9			 
2ee9 cd 19 28		.nuword:	call forth_tok_next 
2eec 18 92			jr .douscan  
2eee			 
2eee			.udone:		 ; push count of uwords found 
2eee c5				push bc 
2eef e1				pop hl 
2ef0			 
2ef0			if DEBUG_FORTH_WORDS 
2ef0				DMARK "UWc" 
2ef0 f5				push af  
2ef1 3a 05 2f			ld a, (.dmark)  
2ef4 32 a6 fd			ld (debug_mark),a  
2ef7 3a 06 2f			ld a, (.dmark+1)  
2efa 32 a7 fd			ld (debug_mark+1),a  
2efd 3a 07 2f			ld a, (.dmark+2)  
2f00 32 a8 fd			ld (debug_mark+2),a  
2f03 18 03			jr .pastdmark  
2f05 ..			.dmark: db "UWc"  
2f08 f1			.pastdmark: pop af  
2f09			endm  
# End of macro DMARK
2f09				CALLMONITOR 
2f09 cd aa fd			call debug_vector  
2f0c				endm  
# End of macro CALLMONITOR
2f0c			endif 
2f0c cd 1b 23			call forth_push_numhl 
2f0f			 
2f0f			 
2f0f			       NEXTW 
2f0f c3 c8 26			jp macro_next 
2f12				endm 
# End of macro NEXTW
2f12			 
2f12			.BP: 
2f12			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2f12 54				db WORD_SYS_CORE+64             
2f13 4c 2f			dw .MONITOR            
2f15 03				db 2 + 1 
2f16 .. 00			db "BP",0              
2f19				endm 
# End of macro CWHEAD
2f19			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2f19			; | | $00 Will enable the break points within specific code paths 
2f19			; | | $01 Will disable break points 
2f19			; | |  
2f19			; | | By default break points are off. Either the above can be used to enable them 
2f19			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2f19			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2f19			; | | can disable break points. Exiting will then continue boot process. 
2f19				; get byte count 
2f19				if DEBUG_FORTH_WORDS_KEY 
2f19					DMARK "BP." 
2f19 f5				push af  
2f1a 3a 2e 2f			ld a, (.dmark)  
2f1d 32 a6 fd			ld (debug_mark),a  
2f20 3a 2f 2f			ld a, (.dmark+1)  
2f23 32 a7 fd			ld (debug_mark+1),a  
2f26 3a 30 2f			ld a, (.dmark+2)  
2f29 32 a8 fd			ld (debug_mark+2),a  
2f2c 18 03			jr .pastdmark  
2f2e ..			.dmark: db "BP."  
2f31 f1			.pastdmark: pop af  
2f32			endm  
# End of macro DMARK
2f32					CALLMONITOR 
2f32 cd aa fd			call debug_vector  
2f35				endm  
# End of macro CALLMONITOR
2f35				endif 
2f35			 
2f35				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f35 cd 12 25			call macro_dsp_valuehl 
2f38				endm 
# End of macro FORTH_DSP_VALUEHL
2f38			 
2f38			;		push hl 
2f38			 
2f38				; destroy value TOS 
2f38			 
2f38				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f38 cd ca 25			call macro_forth_dsp_pop 
2f3b				endm 
# End of macro FORTH_DSP_POP
2f3b			 
2f3b			;		pop hl 
2f3b			 
2f3b 3e 00			ld a,0 
2f3d bd				cp l 
2f3e 28 06			jr z, .bpset 
2f40			;		ld a, '*' 
2f40 cd 59 1c			call bp_off 
2f43				NEXTW 
2f43 c3 c8 26			jp macro_next 
2f46				endm 
# End of macro NEXTW
2f46			 
2f46			.bpset:	 
2f46				;	ld (os_view_disable), a 
2f46 cd 4d 1c			call bp_on 
2f49			 
2f49			 
2f49				NEXTW 
2f49 c3 c8 26			jp macro_next 
2f4c				endm 
# End of macro NEXTW
2f4c			 
2f4c			 
2f4c			.MONITOR: 
2f4c			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2f4c 55				db WORD_SYS_CORE+65             
2f4d 7d 2f			dw .MALLOC            
2f4f 08				db 7 + 1 
2f50 .. 00			db "MONITOR",0              
2f58				endm 
# End of macro CWHEAD
2f58			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2f58			; | | At start the current various registers will be displayed with contents. 
2f58			; | | Top right corner will show the most recent debug marker seen. 
2f58			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2f58			; | | and the return stack pointer (RSP). 
2f58			; | | Pressing: 
2f58			; | |    1 - Initial screen 
2f58			; | |    2 - Display a data dump of HL 
2f58			; | |    3 - Display a data dump of DE 
2f58			; | |    4 - Display a data dump of BC 
2f58			; | |    5 - Display a data dump of HL 
2f58			; | |    6 - Display a data dump of DSP 
2f58			; | |    7 - Display a data dump of RSP 
2f58			; | |    8 - Display a data dump of what is at DSP 
2f58			; | |    9 - Display a data dump of what is at RSP 
2f58			; | |    0 - Exit monitor and continue running. This will also enable break points 
2f58			; | |    * - Disable break points 
2f58			; | |    # - Enter traditional monitor mode 
2f58			; | | 
2f58			; | | Monitor Mode 
2f58			; | | ------------ 
2f58			; | | A prompt of '>' will be shown for various commands: 
2f58			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2f58			; | |    C - Continue display a data dump from the last set address 
2f58			; | |    M xxxx - Set start of memory edit at address xx 
2f58			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2f58			; | |    G xxxx - Exec code at specific address 
2f58			; | |    Q - Return to previous 
2f58				if DEBUG_FORTH_WORDS_KEY 
2f58					DMARK "MON" 
2f58 f5				push af  
2f59 3a 6d 2f			ld a, (.dmark)  
2f5c 32 a6 fd			ld (debug_mark),a  
2f5f 3a 6e 2f			ld a, (.dmark+1)  
2f62 32 a7 fd			ld (debug_mark+1),a  
2f65 3a 6f 2f			ld a, (.dmark+2)  
2f68 32 a8 fd			ld (debug_mark+2),a  
2f6b 18 03			jr .pastdmark  
2f6d ..			.dmark: db "MON"  
2f70 f1			.pastdmark: pop af  
2f71			endm  
# End of macro DMARK
2f71					CALLMONITOR 
2f71 cd aa fd			call debug_vector  
2f74				endm  
# End of macro CALLMONITOR
2f74				endif 
2f74			;		ld a, 0 
2f74			;		ld (os_view_disable), a 
2f74 cd 4d 1c			call bp_on 
2f77			 
2f77				CALLMONITOR 
2f77 cd aa fd			call debug_vector  
2f7a				endm  
# End of macro CALLMONITOR
2f7a			 
2f7a			;	call monitor 
2f7a			 
2f7a				NEXTW 
2f7a c3 c8 26			jp macro_next 
2f7d				endm 
# End of macro NEXTW
2f7d			 
2f7d			 
2f7d			.MALLOC: 
2f7d			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2f7d 56				db WORD_SYS_CORE+66             
2f7e a6 2f			dw .MALLOC2            
2f80 06				db 5 + 1 
2f81 .. 00			db "ALLOT",0              
2f87				endm 
# End of macro CWHEAD
2f87			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2f87				if DEBUG_FORTH_WORDS_KEY 
2f87					DMARK "ALL" 
2f87 f5				push af  
2f88 3a 9c 2f			ld a, (.dmark)  
2f8b 32 a6 fd			ld (debug_mark),a  
2f8e 3a 9d 2f			ld a, (.dmark+1)  
2f91 32 a7 fd			ld (debug_mark+1),a  
2f94 3a 9e 2f			ld a, (.dmark+2)  
2f97 32 a8 fd			ld (debug_mark+2),a  
2f9a 18 03			jr .pastdmark  
2f9c ..			.dmark: db "ALL"  
2f9f f1			.pastdmark: pop af  
2fa0			endm  
# End of macro DMARK
2fa0					CALLMONITOR 
2fa0 cd aa fd			call debug_vector  
2fa3				endm  
# End of macro CALLMONITOR
2fa3				endif 
2fa3 c3 cd 2f			jp .mallocc 
2fa6			.MALLOC2: 
2fa6			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2fa6 56				db WORD_SYS_CORE+66             
2fa7 e4 2f			dw .FREE            
2fa9 07				db 6 + 1 
2faa .. 00			db "MALLOC",0              
2fb1				endm 
# End of macro CWHEAD
2fb1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2fb1				; get byte count 
2fb1				if DEBUG_FORTH_WORDS_KEY 
2fb1					DMARK "MAL" 
2fb1 f5				push af  
2fb2 3a c6 2f			ld a, (.dmark)  
2fb5 32 a6 fd			ld (debug_mark),a  
2fb8 3a c7 2f			ld a, (.dmark+1)  
2fbb 32 a7 fd			ld (debug_mark+1),a  
2fbe 3a c8 2f			ld a, (.dmark+2)  
2fc1 32 a8 fd			ld (debug_mark+2),a  
2fc4 18 03			jr .pastdmark  
2fc6 ..			.dmark: db "MAL"  
2fc9 f1			.pastdmark: pop af  
2fca			endm  
# End of macro DMARK
2fca					CALLMONITOR 
2fca cd aa fd			call debug_vector  
2fcd				endm  
# End of macro CALLMONITOR
2fcd				endif 
2fcd			.mallocc: 
2fcd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2fcd cd 12 25			call macro_dsp_valuehl 
2fd0				endm 
# End of macro FORTH_DSP_VALUEHL
2fd0			 
2fd0			;		push hl 
2fd0			 
2fd0				; destroy value TOS 
2fd0			 
2fd0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fd0 cd ca 25			call macro_forth_dsp_pop 
2fd3				endm 
# End of macro FORTH_DSP_POP
2fd3			 
2fd3			;		pop hl 
2fd3 cd ba 16			call malloc 
2fd6			if DEBUG_FORTH_MALLOC_GUARD 
2fd6 f5				push af 
2fd7 cd f8 0f			call ishlzero 
2fda			;		ld a, l 
2fda			;		add h 
2fda			;		cp 0 
2fda f1				pop af 
2fdb				 
2fdb cc 9b 60			call z,malloc_error 
2fde			endif 
2fde			 
2fde cd 1b 23			call forth_push_numhl 
2fe1				NEXTW 
2fe1 c3 c8 26			jp macro_next 
2fe4				endm 
# End of macro NEXTW
2fe4			 
2fe4			.FREE: 
2fe4			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2fe4 57				db WORD_SYS_CORE+67             
2fe5 15 30			dw .LIST            
2fe7 05				db 4 + 1 
2fe8 .. 00			db "FREE",0              
2fed				endm 
# End of macro CWHEAD
2fed			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2fed				if DEBUG_FORTH_WORDS_KEY 
2fed					DMARK "FRE" 
2fed f5				push af  
2fee 3a 02 30			ld a, (.dmark)  
2ff1 32 a6 fd			ld (debug_mark),a  
2ff4 3a 03 30			ld a, (.dmark+1)  
2ff7 32 a7 fd			ld (debug_mark+1),a  
2ffa 3a 04 30			ld a, (.dmark+2)  
2ffd 32 a8 fd			ld (debug_mark+2),a  
3000 18 03			jr .pastdmark  
3002 ..			.dmark: db "FRE"  
3005 f1			.pastdmark: pop af  
3006			endm  
# End of macro DMARK
3006					CALLMONITOR 
3006 cd aa fd			call debug_vector  
3009				endm  
# End of macro CALLMONITOR
3009				endif 
3009				; get address 
3009			 
3009				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3009 cd 12 25			call macro_dsp_valuehl 
300c				endm 
# End of macro FORTH_DSP_VALUEHL
300c			 
300c			;		push hl 
300c			 
300c				; destroy value TOS 
300c			 
300c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
300c cd ca 25			call macro_forth_dsp_pop 
300f				endm 
# End of macro FORTH_DSP_POP
300f			 
300f			;		pop hl 
300f			if FORTH_ENABLE_MALLOCFREE 
300f cd 84 17			call free 
3012			endif 
3012				NEXTW 
3012 c3 c8 26			jp macro_next 
3015				endm 
# End of macro NEXTW
3015			.LIST: 
3015			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
3015 5c				db WORD_SYS_CORE+72             
3016 05 32			dw .FORGET            
3018 05				db 4 + 1 
3019 .. 00			db "LIST",0              
301e				endm 
# End of macro CWHEAD
301e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
301e			; | | The quoted word must be in upper case. 
301e			if DEBUG_FORTH_WORDS_KEY 
301e				DMARK "LST" 
301e f5				push af  
301f 3a 33 30			ld a, (.dmark)  
3022 32 a6 fd			ld (debug_mark),a  
3025 3a 34 30			ld a, (.dmark+1)  
3028 32 a7 fd			ld (debug_mark+1),a  
302b 3a 35 30			ld a, (.dmark+2)  
302e 32 a8 fd			ld (debug_mark+2),a  
3031 18 03			jr .pastdmark  
3033 ..			.dmark: db "LST"  
3036 f1			.pastdmark: pop af  
3037			endm  
# End of macro DMARK
3037				CALLMONITOR 
3037 cd aa fd			call debug_vector  
303a				endm  
# End of macro CALLMONITOR
303a			endif 
303a			 
303a				FORTH_DSP_VALUEHL 
303a cd 12 25			call macro_dsp_valuehl 
303d				endm 
# End of macro FORTH_DSP_VALUEHL
303d			 
303d e5				push hl 
303e				FORTH_DSP_POP 
303e cd ca 25			call macro_forth_dsp_pop 
3041				endm 
# End of macro FORTH_DSP_POP
3041 c1				pop bc 
3042			 
3042			; Start format of scratch string 
3042			 
3042 21 fc f0			ld hl, scratch 
3045			 
3045 3e 3a			ld a, ':' 
3047 77				ld (hl),a 
3048 23				inc hl 
3049 3e 20			ld a, ' ' 
304b 77				ld (hl), a 
304c			 
304c				; Get ptr to the word we need to look up 
304c			 
304c			;		FORTH_DSP_VALUEHL 
304c				;v5 FORTH_DSP_VALUE 
304c			; TODO type check 
304c			;		inc hl    ; Skip type check  
304c			;		push hl 
304c			;		ex de, hl    ; put into DE 
304c			 
304c			 
304c 21 00 80			ld hl, baseram 
304f				;ld hl, baseusermem 
304f			 
304f e5			push hl   ; sacreifical push 
3050			 
3050			.ldouscanm: 
3050 e1			pop hl 
3051			.ldouscan: 
3051			if DEBUG_FORTH_WORDS 
3051				DMARK "LSs" 
3051 f5				push af  
3052 3a 66 30			ld a, (.dmark)  
3055 32 a6 fd			ld (debug_mark),a  
3058 3a 67 30			ld a, (.dmark+1)  
305b 32 a7 fd			ld (debug_mark+1),a  
305e 3a 68 30			ld a, (.dmark+2)  
3061 32 a8 fd			ld (debug_mark+2),a  
3064 18 03			jr .pastdmark  
3066 ..			.dmark: db "LSs"  
3069 f1			.pastdmark: pop af  
306a			endm  
# End of macro DMARK
306a				CALLMONITOR 
306a cd aa fd			call debug_vector  
306d				endm  
# End of macro CALLMONITOR
306d			endif 
306d			; skip dict stub 
306d cd 19 28			call forth_tok_next 
3070			 
3070			 
3070			; while we have words to look for 
3070			 
3070 7e			ld a, (hl)      
3071			if DEBUG_FORTH_WORDS 
3071				DMARK "LSk" 
3071 f5				push af  
3072 3a 86 30			ld a, (.dmark)  
3075 32 a6 fd			ld (debug_mark),a  
3078 3a 87 30			ld a, (.dmark+1)  
307b 32 a7 fd			ld (debug_mark+1),a  
307e 3a 88 30			ld a, (.dmark+2)  
3081 32 a8 fd			ld (debug_mark+2),a  
3084 18 03			jr .pastdmark  
3086 ..			.dmark: db "LSk"  
3089 f1			.pastdmark: pop af  
308a			endm  
# End of macro DMARK
308a				CALLMONITOR 
308a cd aa fd			call debug_vector  
308d				endm  
# End of macro CALLMONITOR
308d			endif 
308d				;cp WORD_SYS_END 
308d				;jp z, .lunotfound 
308d			 
308d					; if we hit non uwords then gone too far 
308d fe 01				cp WORD_SYS_UWORD 
308f c2 c1 31				jp nz, .lunotfound 
3092			 
3092				if DEBUG_FORTH_WORDS 
3092					DMARK "LSu" 
3092 f5				push af  
3093 3a a7 30			ld a, (.dmark)  
3096 32 a6 fd			ld (debug_mark),a  
3099 3a a8 30			ld a, (.dmark+1)  
309c 32 a7 fd			ld (debug_mark+1),a  
309f 3a a9 30			ld a, (.dmark+2)  
30a2 32 a8 fd			ld (debug_mark+2),a  
30a5 18 03			jr .pastdmark  
30a7 ..			.dmark: db "LSu"  
30aa f1			.pastdmark: pop af  
30ab			endm  
# End of macro DMARK
30ab					CALLMONITOR 
30ab cd aa fd			call debug_vector  
30ae				endm  
# End of macro CALLMONITOR
30ae				endif 
30ae			 
30ae					; found a uword but is it the one we want... 
30ae			 
30ae c5					push bc     ; uword to find is on bc 
30af d1					pop de 
30b0			 
30b0 e5					push hl  ; to save the ptr 
30b1			 
30b1					; skip opcode 
30b1 23					inc hl  
30b2					; skip next ptr 
30b2 23					inc hl  
30b3 23					inc hl 
30b4					; skip len 
30b4 23					inc hl 
30b5			 
30b5				if DEBUG_FORTH_WORDS 
30b5					DMARK "LSc" 
30b5 f5				push af  
30b6 3a ca 30			ld a, (.dmark)  
30b9 32 a6 fd			ld (debug_mark),a  
30bc 3a cb 30			ld a, (.dmark+1)  
30bf 32 a7 fd			ld (debug_mark+1),a  
30c2 3a cc 30			ld a, (.dmark+2)  
30c5 32 a8 fd			ld (debug_mark+2),a  
30c8 18 03			jr .pastdmark  
30ca ..			.dmark: db "LSc"  
30cd f1			.pastdmark: pop af  
30ce			endm  
# End of macro DMARK
30ce					CALLMONITOR 
30ce cd aa fd			call debug_vector  
30d1				endm  
# End of macro CALLMONITOR
30d1				endif 
30d1			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
30d1			; ie. If WOO is defined first and then WO. Couldnt list WO. 
30d1			; Nope that has gone the other way. It needs to be exact not on first zero 
30d1			;		call strcmp 
30d1 c5					push bc 
30d2 cd 8a 16				call StrictStrCmp 
30d5 c1					pop bc 
30d6 c2 50 30				jp nz, .ldouscanm 
30d9				 
30d9			 
30d9			 
30d9					; we have a uword so push its name to the stack 
30d9			 
30d9			;	   	push hl  ; save so we can move to next dict block 
30d9 e1			pop hl 
30da			 
30da				if DEBUG_FORTH_WORDS 
30da					DMARK "LSm" 
30da f5				push af  
30db 3a ef 30			ld a, (.dmark)  
30de 32 a6 fd			ld (debug_mark),a  
30e1 3a f0 30			ld a, (.dmark+1)  
30e4 32 a7 fd			ld (debug_mark+1),a  
30e7 3a f1 30			ld a, (.dmark+2)  
30ea 32 a8 fd			ld (debug_mark+2),a  
30ed 18 03			jr .pastdmark  
30ef ..			.dmark: db "LSm"  
30f2 f1			.pastdmark: pop af  
30f3			endm  
# End of macro DMARK
30f3					CALLMONITOR 
30f3 cd aa fd			call debug_vector  
30f6				endm  
# End of macro CALLMONITOR
30f6				endif 
30f6			 
30f6					; skip opcode 
30f6 23					inc hl  
30f7					; skip next ptr 
30f7 23					inc hl  
30f8 23					inc hl 
30f9					; skip len 
30f9 7e					ld a, (hl)   ; save length to add 
30fa				if DEBUG_FORTH_WORDS 
30fa					DMARK "LS2" 
30fa f5				push af  
30fb 3a 0f 31			ld a, (.dmark)  
30fe 32 a6 fd			ld (debug_mark),a  
3101 3a 10 31			ld a, (.dmark+1)  
3104 32 a7 fd			ld (debug_mark+1),a  
3107 3a 11 31			ld a, (.dmark+2)  
310a 32 a8 fd			ld (debug_mark+2),a  
310d 18 03			jr .pastdmark  
310f ..			.dmark: db "LS2"  
3112 f1			.pastdmark: pop af  
3113			endm  
# End of macro DMARK
3113					CALLMONITOR 
3113 cd aa fd			call debug_vector  
3116				endm  
# End of macro CALLMONITOR
3116				endif 
3116			 
3116					; save this location 
3116				 
3116 e5					push hl 
3117			 
3117 23					inc hl 
3118 11 fe f0				ld de, scratch+2 
311b 4f					ld c, a 
311c 06 00				ld b, 0 
311e			 
311e				if DEBUG_FORTH_WORDS 
311e					DMARK "LSn" 
311e f5				push af  
311f 3a 33 31			ld a, (.dmark)  
3122 32 a6 fd			ld (debug_mark),a  
3125 3a 34 31			ld a, (.dmark+1)  
3128 32 a7 fd			ld (debug_mark+1),a  
312b 3a 35 31			ld a, (.dmark+2)  
312e 32 a8 fd			ld (debug_mark+2),a  
3131 18 03			jr .pastdmark  
3133 ..			.dmark: db "LSn"  
3136 f1			.pastdmark: pop af  
3137			endm  
# End of macro DMARK
3137					CALLMONITOR 
3137 cd aa fd			call debug_vector  
313a				endm  
# End of macro CALLMONITOR
313a				endif 
313a			 
313a					; copy uword name to scratch 
313a			 
313a ed b0				ldir 
313c			 
313c 1b					dec de 
313d 3e 20				ld a, ' '    ; change null to space 
313f 12					ld (de), a 
3140			 
3140 13					inc de 
3141			 
3141 d5					push de 
3142 c1					pop bc     ; move scratch pointer to end of word name and save it 
3143			 
3143 e1					pop hl 
3144 7e					ld a, (hl) 
3145					;inc hl 
3145					; skip word string 
3145 cd cf 0f				call addatohl 
3148			 
3148 23					inc hl 
3149			 
3149				if DEBUG_FORTH_WORDS 
3149					DMARK "LS3" 
3149 f5				push af  
314a 3a 5e 31			ld a, (.dmark)  
314d 32 a6 fd			ld (debug_mark),a  
3150 3a 5f 31			ld a, (.dmark+1)  
3153 32 a7 fd			ld (debug_mark+1),a  
3156 3a 60 31			ld a, (.dmark+2)  
3159 32 a8 fd			ld (debug_mark+2),a  
315c 18 03			jr .pastdmark  
315e ..			.dmark: db "LS3"  
3161 f1			.pastdmark: pop af  
3162			endm  
# End of macro DMARK
3162					CALLMONITOR 
3162 cd aa fd			call debug_vector  
3165				endm  
# End of macro CALLMONITOR
3165				endif 
3165					; should now be at the start of the machine code to setup the eval of the uword 
3165					; now locate the ptr to the string defintion 
3165			 
3165					; skip ld hl, 
3165					; then load the ptr 
3165			; TODO use get from hl ptr 
3165 23					inc hl 
3166 5e					ld e, (hl) 
3167 23					inc hl 
3168 56					ld d, (hl) 
3169 eb					ex de, hl 
316a			 
316a			 
316a				if DEBUG_FORTH_WORDS 
316a					DMARK "LSt" 
316a f5				push af  
316b 3a 7f 31			ld a, (.dmark)  
316e 32 a6 fd			ld (debug_mark),a  
3171 3a 80 31			ld a, (.dmark+1)  
3174 32 a7 fd			ld (debug_mark+1),a  
3177 3a 81 31			ld a, (.dmark+2)  
317a 32 a8 fd			ld (debug_mark+2),a  
317d 18 03			jr .pastdmark  
317f ..			.dmark: db "LSt"  
3182 f1			.pastdmark: pop af  
3183			endm  
# End of macro DMARK
3183					CALLMONITOR 
3183 cd aa fd			call debug_vector  
3186				endm  
# End of macro CALLMONITOR
3186				endif 
3186			 
3186			; cant push right now due to tokenised strings  
3186			 
3186			; get the destination of where to copy this definition to. 
3186			 
3186 c5					push bc 
3187 d1					pop de 
3188			 
3188 7e			.listl:         ld a,(hl) 
3189 fe 00				cp 0 
318b 28 09				jr z, .lreplsp     ; replace zero with space 
318d					;cp FORTH_END_BUFFER 
318d fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
318f 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
3191				 
3191					; just copy this char as is then 
3191			 
3191 12					ld (de), a 
3192			 
3192 23			.listnxt:	inc hl 
3193 13					inc de 
3194 18 f2				jr .listl 
3196			 
3196 3e 20		.lreplsp:	ld a,' ' 
3198 12					ld (de), a 
3199 18 f7				jr .listnxt 
319b			 
319b			; close up uword def 
319b			 
319b			.listdone: 
319b 12					ld (de), a 
319c 13					inc de 
319d 3e 00				ld a, 0 
319f 12					ld (de), a 
31a0			 
31a0			; now have def so clean up and push to stack 
31a0			 
31a0 21 fc f0				ld hl, scratch 
31a3				if DEBUG_FORTH_WORDS 
31a3					DMARK "Ltp" 
31a3 f5				push af  
31a4 3a b8 31			ld a, (.dmark)  
31a7 32 a6 fd			ld (debug_mark),a  
31aa 3a b9 31			ld a, (.dmark+1)  
31ad 32 a7 fd			ld (debug_mark+1),a  
31b0 3a ba 31			ld a, (.dmark+2)  
31b3 32 a8 fd			ld (debug_mark+2),a  
31b6 18 03			jr .pastdmark  
31b8 ..			.dmark: db "Ltp"  
31bb f1			.pastdmark: pop af  
31bc			endm  
# End of macro DMARK
31bc					CALLMONITOR 
31bc cd aa fd			call debug_vector  
31bf				endm  
# End of macro CALLMONITOR
31bf				endif 
31bf			 
31bf 18 1f			jr .listpush 
31c1			 
31c1			;.lnuword:	pop hl 
31c1			;		call forth_tok_next 
31c1			;		jp .ldouscan  
31c1			 
31c1			.lunotfound:		  
31c1			 
31c1				if DEBUG_FORTH_WORDS 
31c1					DMARK "LSn" 
31c1 f5				push af  
31c2 3a d6 31			ld a, (.dmark)  
31c5 32 a6 fd			ld (debug_mark),a  
31c8 3a d7 31			ld a, (.dmark+1)  
31cb 32 a7 fd			ld (debug_mark+1),a  
31ce 3a d8 31			ld a, (.dmark+2)  
31d1 32 a8 fd			ld (debug_mark+2),a  
31d4 18 03			jr .pastdmark  
31d6 ..			.dmark: db "LSn"  
31d9 f1			.pastdmark: pop af  
31da			endm  
# End of macro DMARK
31da					CALLMONITOR 
31da cd aa fd			call debug_vector  
31dd				endm  
# End of macro CALLMONITOR
31dd				endif 
31dd			 
31dd					 
31dd			;		FORTH_DSP_POP 
31dd			;		ld hl, .luno 
31dd			 
31dd					NEXTW			 
31dd c3 c8 26			jp macro_next 
31e0				endm 
# End of macro NEXTW
31e0			 
31e0			.listpush: 
31e0				if DEBUG_FORTH_WORDS 
31e0					DMARK "LS>" 
31e0 f5				push af  
31e1 3a f5 31			ld a, (.dmark)  
31e4 32 a6 fd			ld (debug_mark),a  
31e7 3a f6 31			ld a, (.dmark+1)  
31ea 32 a7 fd			ld (debug_mark+1),a  
31ed 3a f7 31			ld a, (.dmark+2)  
31f0 32 a8 fd			ld (debug_mark+2),a  
31f3 18 03			jr .pastdmark  
31f5 ..			.dmark: db "LS>"  
31f8 f1			.pastdmark: pop af  
31f9			endm  
# End of macro DMARK
31f9					CALLMONITOR 
31f9 cd aa fd			call debug_vector  
31fc				endm  
# End of macro CALLMONITOR
31fc				endif 
31fc cd 89 23				call forth_push_str 
31ff			 
31ff			 
31ff			 
31ff					NEXTW 
31ff c3 c8 26			jp macro_next 
3202				endm 
# End of macro NEXTW
3202			 
3202			;.luno:    db "Word not found",0 
3202			 
3202			 
3202			 
3202			 
3202			 
3202			;		push hl   ; save pointer to start of uword def string 
3202			; 
3202			;; look for FORTH_EOL_LINE 
3202			;		ld a, FORTH_END_BUFFER 
3202			;		call strlent 
3202			; 
3202			;		inc hl		 ; space for coln def 
3202			;		inc hl 
3202			;		inc hl          ; space for terms 
3202			;		inc hl 
3202			; 
3202			;		ld a, 20   ; TODO get actual length 
3202			;		call addatohl    ; include a random amount of room for the uword name 
3202			; 
3202			;		 
3202			;	if DEBUG_FORTH_WORDS 
3202			;		DMARK "Lt1" 
3202			;		CALLMONITOR 
3202			;	endif 
3202			;		 
3202			; 
3202			;; malloc space for the string because we cant change it 
3202			; 
3202			;		call malloc 
3202			;	if DEBUG_FORTH_MALLOC_GUARD 
3202			;		push af 
3202			;		call ishlzero 
3202			;		pop af 
3202			;		 
3202			;		call z,malloc_error 
3202			;	endif 
3202			; 
3202			;	if DEBUG_FORTH_WORDS 
3202			;		DMARK "Lt2" 
3202			;		CALLMONITOR 
3202			;	endif 
3202			;		pop de 
3202			;		push hl    ; push the malloc to release later 
3202			;		push hl   ;  push back a copy for the later stack push 
3202			;		 
3202			;; copy the string swapping out the zero terms for spaces 
3202			; 
3202			;		; de has our source 
3202			;		; hl has our dest 
3202			; 
3202			;; add the coln def 
3202			; 
3202			;		ld a, ':' 
3202			;		ld (hl), a 
3202			;		inc hl 
3202			;		ld a, ' ' 
3202			;		ld (hl), a 
3202			;		inc hl 
3202			; 
3202			;; add the uname word 
3202			;		push de   ; save our string for now 
3202			;		ex de, hl 
3202			; 
3202			;		FORTH_DSP_VALUE 
3202			;		;v5 FORTH_DSP_VALUE 
3202			; 
3202			;		inc hl   ; skip type but we know by now this is OK 
3202			; 
3202			;.luword:	ld a,(hl) 
3202			;		cp 0 
3202			;		jr z, .luword2 
3202			;		ld (de), a 
3202			;		inc de 
3202			;		inc hl 
3202			;		jr .luword 
3202			; 
3202			;.luword2:	ld a, ' ' 
3202			;		ld (de), a 
3202			;;		inc hl 
3202			;;		inc de 
3202			;;		ld (de), a 
3202			;;		inc hl 
3202			;		inc de 
3202			; 
3202			;		ex de, hl 
3202			;		pop de 
3202			;		 
3202			;		 
3202			; 
3202			;; detoken that string and copy it 
3202			; 
3202			;	if DEBUG_FORTH_WORDS 
3202			;		DMARK "Lt2" 
3202			;		CALLMONITOR 
3202			;	endif 
3202			;.ldetok:	ld a, (de) 
3202			;		cp FORTH_END_BUFFER 
3202			;		jr z, .ldetokend 
3202			;		; swap out any zero term for space 
3202			;		cp 0 
3202			;		jr nz, .ldetoknext 
3202			;		ld a, ' ' 
3202			; 
3202			;	if DEBUG_FORTH_WORDS 
3202			;		DMARK "LtS" 
3202			;		CALLMONITOR 
3202			;	endif 
3202			;.ldetoknext:	ld (hl), a 
3202			;		inc de 
3202			;		inc hl 
3202			;		jr .ldetok 
3202			; 
3202			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
3202			;		ld (hl), a  
3202			; 
3202			;; free that temp malloc 
3202			; 
3202			;		pop hl    
3202			; 
3202			;	if DEBUG_FORTH_WORDS 
3202			;		DMARK "Lt4" 
3202			;		CALLMONITOR 
3202			;	endif 
3202			;		call forth_apushstrhl 
3202			; 
3202			;		; get rid of temp malloc area 
3202			; 
3202			;		pop hl 
3202			;		call free 
3202			; 
3202			;		jr .ludone 
3202			; 
3202			;.lnuword:	pop hl 
3202			;		call forth_tok_next 
3202			;		jp .ldouscan  
3202			; 
3202			;.ludone:		 pop hl 
3202			; 
3202					NEXTW 
3202 c3 c8 26			jp macro_next 
3205				endm 
# End of macro NEXTW
3205			 
3205			.FORGET: 
3205				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
3205 5d				db WORD_SYS_CORE+73             
3206 7e 32			dw .NOP            
3208 07				db 6 + 1 
3209 .. 00			db "FORGET",0              
3210				endm 
# End of macro CWHEAD
3210			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
3210			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
3210			; | |  
3210			; | | e.g. "MORE" forget 
3210					if DEBUG_FORTH_WORDS_KEY 
3210						DMARK "FRG" 
3210 f5				push af  
3211 3a 25 32			ld a, (.dmark)  
3214 32 a6 fd			ld (debug_mark),a  
3217 3a 26 32			ld a, (.dmark+1)  
321a 32 a7 fd			ld (debug_mark+1),a  
321d 3a 27 32			ld a, (.dmark+2)  
3220 32 a8 fd			ld (debug_mark+2),a  
3223 18 03			jr .pastdmark  
3225 ..			.dmark: db "FRG"  
3228 f1			.pastdmark: pop af  
3229			endm  
# End of macro DMARK
3229						CALLMONITOR 
3229 cd aa fd			call debug_vector  
322c				endm  
# End of macro CALLMONITOR
322c					endif 
322c			 
322c				; find uword 
322c			        ; update start of word with "_" 
322c				; replace uword with deleted flag 
322c			 
322c			 
322c			;	if DEBUG_FORTH_WORDS 
322c			;		DMARK "FOG" 
322c			;		CALLMONITOR 
322c			;	endif 
322c			 
322c			 
322c					; Get ptr to the word we need to look up 
322c			 
322c					FORTH_DSP_VALUEHL 
322c cd 12 25			call macro_dsp_valuehl 
322f				endm 
# End of macro FORTH_DSP_VALUEHL
322f					;v5 FORTH_DSP_VALUE 
322f				; TODO type check 
322f			;		inc hl    ; Skip type check  
322f e5					push hl 
3230 c1					pop bc 
3231			;		ex de, hl    ; put into DE 
3231			 
3231			 
3231 21 00 80				ld hl, baseram 
3234					;ld hl, baseusermem 
3234			 
3234				; skip dict stub 
3234			;	call forth_tok_next 
3234 e5			push hl   ; sacreifical push 
3235			 
3235			.fldouscanm: 
3235 e1				pop hl 
3236			.fldouscan: 
3236			;	if DEBUG_FORTH_WORDS 
3236			;		DMARK "LSs" 
3236			;		CALLMONITOR 
3236			;	endif 
3236				; skip dict stub 
3236 cd 19 28				call forth_tok_next 
3239			 
3239			 
3239			; while we have words to look for 
3239			 
3239 7e				ld a, (hl)      
323a			;	if DEBUG_FORTH_WORDS 
323a			;		DMARK "LSk" 
323a			;		CALLMONITOR 
323a			;	endif 
323a fe 00				cp WORD_SYS_END 
323c ca 78 32				jp z, .flunotfound 
323f fe 01				cp WORD_SYS_UWORD 
3241 c2 36 32				jp nz, .fldouscan 
3244			 
3244			;	if DEBUG_FORTH_WORDS 
3244			;		DMARK "LSu" 
3244			;		CALLMONITOR 
3244			;	endif 
3244			 
3244					; found a uword but is it the one we want... 
3244			 
3244 c5					push bc     ; uword to find is on bc 
3245 d1					pop de 
3246			 
3246 e5					push hl  ; to save the ptr 
3247			 
3247					; skip opcode 
3247 23					inc hl  
3248					; skip next ptr 
3248 23					inc hl  
3249 23					inc hl 
324a					; skip len 
324a 23					inc hl 
324b			 
324b			;	if DEBUG_FORTH_WORDS 
324b			;		DMARK "LSc" 
324b			;		CALLMONITOR 
324b			;	endif 
324b cd 7d 16				call strcmp 
324e c2 35 32				jp nz, .fldouscanm 
3251			; 
3251			; 
3251			;; while we have words to look for 
3251			; 
3251			;.fdouscan:	ld a, (hl)      
3251			;	if DEBUG_FORTH_WORDS 
3251			;		DMARK "LSs" 
3251			;		CALLMONITOR 
3251			;	endif 
3251			;		cp WORD_SYS_END 
3251			;		jp z, .fudone 
3251			;		cp WORD_SYS_UWORD 
3251			;		jp nz, .fnuword 
3251			; 
3251			;	if DEBUG_FORTH_WORDS 
3251			;		DMARK "FGu" 
3251			;		CALLMONITOR 
3251			;	endif 
3251			; 
3251			;		; found a uword but is it the one we want... 
3251			; 
3251			; 
3251			;	        pop de   ; get back the dsp name 
3251			;		push de 
3251			; 
3251			;		push hl  ; to save the ptr 
3251			; 
3251			;		; skip opcode 
3251			;		inc hl  
3251			;		; skip next ptr 
3251			;		inc hl  
3251			;		inc hl 
3251			;		; skip len 
3251			;		inc hl 
3251			; 
3251			;	if DEBUG_FORTH_WORDS 
3251			;		DMARK "FGc" 
3251			;		CALLMONITOR 
3251			;	endif 
3251			;		call strcmp 
3251			;		jp nz, .fnuword 
3251			 
3251			 
3251 e1			pop hl 
3252			 
3252				 
3252				if DEBUG_FORTH_WORDS 
3252					DMARK "FGm" 
3252 f5				push af  
3253 3a 67 32			ld a, (.dmark)  
3256 32 a6 fd			ld (debug_mark),a  
3259 3a 68 32			ld a, (.dmark+1)  
325c 32 a7 fd			ld (debug_mark+1),a  
325f 3a 69 32			ld a, (.dmark+2)  
3262 32 a8 fd			ld (debug_mark+2),a  
3265 18 03			jr .pastdmark  
3267 ..			.dmark: db "FGm"  
326a f1			.pastdmark: pop af  
326b			endm  
# End of macro DMARK
326b					CALLMONITOR 
326b cd aa fd			call debug_vector  
326e				endm  
# End of macro CALLMONITOR
326e				endif 
326e			 
326e			 
326e			 
326e					; we have a uword so push its name to the stack 
326e			 
326e			;	   	push hl  ; save so we can move to next dict block 
326e			;pop hl 
326e			 
326e					; update opcode to deleted 
326e 3e 03				ld a, WORD_SYS_DELETED 
3270 77					ld (hl), a 
3271			 
3271 23					inc hl  
3272					; skip next ptr 
3272 23					inc hl  
3273 23					inc hl 
3274					; skip len 
3274 23					inc hl 
3275			 
3275					; TODO change parser to skip deleted words but for now mark it out 
3275 3e 5f				ld a, "_" 
3277 77					ld  (hl),a 
3278			 
3278			;		jr .fudone 
3278			; 
3278			;.fnuword:	pop hl 
3278			;		call forth_tok_next 
3278			;		jp .fdouscan  
3278			 
3278			.flunotfound:		  
3278			 
3278			 
3278					 
3278					FORTH_DSP_POP 
3278 cd ca 25			call macro_forth_dsp_pop 
327b				endm 
# End of macro FORTH_DSP_POP
327b			;		ld hl, .luno 
327b			;.fudone:		 pop hl 
327b					NEXTW 
327b c3 c8 26			jp macro_next 
327e				endm 
# End of macro NEXTW
327e			.NOP: 
327e				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
327e 61				db WORD_SYS_CORE+77             
327f a5 32			dw .COMO            
3281 04				db 3 + 1 
3282 .. 00			db "NOP",0              
3286				endm 
# End of macro CWHEAD
3286			; | NOP (  --  ) Do nothing | DONE 
3286					if DEBUG_FORTH_WORDS_KEY 
3286						DMARK "NOP" 
3286 f5				push af  
3287 3a 9b 32			ld a, (.dmark)  
328a 32 a6 fd			ld (debug_mark),a  
328d 3a 9c 32			ld a, (.dmark+1)  
3290 32 a7 fd			ld (debug_mark+1),a  
3293 3a 9d 32			ld a, (.dmark+2)  
3296 32 a8 fd			ld (debug_mark+2),a  
3299 18 03			jr .pastdmark  
329b ..			.dmark: db "NOP"  
329e f1			.pastdmark: pop af  
329f			endm  
# End of macro DMARK
329f						CALLMONITOR 
329f cd aa fd			call debug_vector  
32a2				endm  
# End of macro CALLMONITOR
32a2					endif 
32a2				       NEXTW 
32a2 c3 c8 26			jp macro_next 
32a5				endm 
# End of macro NEXTW
32a5			.COMO: 
32a5				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
32a5 6e				db WORD_SYS_CORE+90             
32a6 f7 32			dw .COMC            
32a8 02				db 1 + 1 
32a9 .. 00			db "(",0              
32ab				endm 
# End of macro CWHEAD
32ab			; | ( ( -- )  Start of comment | DONE 
32ab			 
32ab			 
32ab 2a fd f3				ld hl, ( os_tok_ptr) 
32ae 11 f2 32			ld de, .closepar 
32b1					 
32b1					if DEBUG_FORTH_WORDS 
32b1						DMARK ").." 
32b1 f5				push af  
32b2 3a c6 32			ld a, (.dmark)  
32b5 32 a6 fd			ld (debug_mark),a  
32b8 3a c7 32			ld a, (.dmark+1)  
32bb 32 a7 fd			ld (debug_mark+1),a  
32be 3a c8 32			ld a, (.dmark+2)  
32c1 32 a8 fd			ld (debug_mark+2),a  
32c4 18 03			jr .pastdmark  
32c6 ..			.dmark: db ").."  
32c9 f1			.pastdmark: pop af  
32ca			endm  
# End of macro DMARK
32ca						CALLMONITOR 
32ca cd aa fd			call debug_vector  
32cd				endm  
# End of macro CALLMONITOR
32cd					endif 
32cd cd e3 27			call findnexttok  
32d0			 
32d0					if DEBUG_FORTH_WORDS 
32d0						DMARK "IF5" 
32d0 f5				push af  
32d1 3a e5 32			ld a, (.dmark)  
32d4 32 a6 fd			ld (debug_mark),a  
32d7 3a e6 32			ld a, (.dmark+1)  
32da 32 a7 fd			ld (debug_mark+1),a  
32dd 3a e7 32			ld a, (.dmark+2)  
32e0 32 a8 fd			ld (debug_mark+2),a  
32e3 18 03			jr .pastdmark  
32e5 ..			.dmark: db "IF5"  
32e8 f1			.pastdmark: pop af  
32e9			endm  
# End of macro DMARK
32e9						CALLMONITOR 
32e9 cd aa fd			call debug_vector  
32ec				endm  
# End of macro CALLMONITOR
32ec					endif 
32ec				; replace below with ) exec using tok_ptr 
32ec 22 fd f3			ld (os_tok_ptr), hl 
32ef c3 59 27			jp exec1 
32f2			 
32f2 .. 00			.closepar:   db ")",0 
32f4			 
32f4				       NEXTW 
32f4 c3 c8 26			jp macro_next 
32f7				endm 
# End of macro NEXTW
32f7			.COMC: 
32f7				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
32f7 6f				db WORD_SYS_CORE+91             
32f8 00 33			dw .SCRATCH            
32fa 02				db 1 + 1 
32fb .. 00			db ")",0              
32fd				endm 
# End of macro CWHEAD
32fd			; | ) ( -- )  End of comment |  DONE  
32fd				       NEXTW 
32fd c3 c8 26			jp macro_next 
3300				endm 
# End of macro NEXTW
3300			 
3300			.SCRATCH: 
3300				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3300 6f				db WORD_SYS_CORE+91             
3301 3b 33			dw .INC            
3303 08				db 7 + 1 
3304 .. 00			db "SCRATCH",0              
330c				endm 
# End of macro CWHEAD
330c			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
330c			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
330c			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
330c			; | |  
330c			; | | e.g.    : score $00 scratch ; 
330c			; | |  
330c			; | | $00 score ! 
330c			; | | $01 score +! 
330c			; | |  
330c			; | | e.g.   : varword $0a scratch ;  
330c			; | | 
330c			; | | $8000 varword ! 
330c					if DEBUG_FORTH_WORDS_KEY 
330c						DMARK "SCR" 
330c f5				push af  
330d 3a 21 33			ld a, (.dmark)  
3310 32 a6 fd			ld (debug_mark),a  
3313 3a 22 33			ld a, (.dmark+1)  
3316 32 a7 fd			ld (debug_mark+1),a  
3319 3a 23 33			ld a, (.dmark+2)  
331c 32 a8 fd			ld (debug_mark+2),a  
331f 18 03			jr .pastdmark  
3321 ..			.dmark: db "SCR"  
3324 f1			.pastdmark: pop af  
3325			endm  
# End of macro DMARK
3325						CALLMONITOR 
3325 cd aa fd			call debug_vector  
3328				endm  
# End of macro CALLMONITOR
3328					endif 
3328			 
3328					FORTH_DSP_VALUEHL 
3328 cd 12 25			call macro_dsp_valuehl 
332b				endm 
# End of macro FORTH_DSP_VALUEHL
332b				 
332b					FORTH_DSP_POP 
332b cd ca 25			call macro_forth_dsp_pop 
332e				endm 
# End of macro FORTH_DSP_POP
332e			 
332e 7d					ld a, l 
332f 21 21 f6				ld hl, os_var_array 
3332 cd cf 0f				call addatohl 
3335			 
3335 cd 1b 23				call forth_push_numhl 
3338			 
3338				       NEXTW 
3338 c3 c8 26			jp macro_next 
333b				endm 
# End of macro NEXTW
333b			 
333b			.INC: 
333b				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
333b 6f				db WORD_SYS_CORE+91             
333c 91 33			dw .DEC            
333e 03				db 2 + 1 
333f .. 00			db "+!",0              
3342				endm 
# End of macro CWHEAD
3342			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3342					if DEBUG_FORTH_WORDS_KEY 
3342						DMARK "+s_" 
3342 f5				push af  
3343 3a 57 33			ld a, (.dmark)  
3346 32 a6 fd			ld (debug_mark),a  
3349 3a 58 33			ld a, (.dmark+1)  
334c 32 a7 fd			ld (debug_mark+1),a  
334f 3a 59 33			ld a, (.dmark+2)  
3352 32 a8 fd			ld (debug_mark+2),a  
3355 18 03			jr .pastdmark  
3357 ..			.dmark: db "+s_"  
335a f1			.pastdmark: pop af  
335b			endm  
# End of macro DMARK
335b						CALLMONITOR 
335b cd aa fd			call debug_vector  
335e				endm  
# End of macro CALLMONITOR
335e					endif 
335e			 
335e					FORTH_DSP_VALUEHL 
335e cd 12 25			call macro_dsp_valuehl 
3361				endm 
# End of macro FORTH_DSP_VALUEHL
3361			 
3361 e5					push hl   ; save address 
3362			 
3362					FORTH_DSP_POP 
3362 cd ca 25			call macro_forth_dsp_pop 
3365				endm 
# End of macro FORTH_DSP_POP
3365			 
3365					FORTH_DSP_VALUEHL 
3365 cd 12 25			call macro_dsp_valuehl 
3368				endm 
# End of macro FORTH_DSP_VALUEHL
3368			 
3368 e5					push hl 
3369					FORTH_DSP_POP 
3369 cd ca 25			call macro_forth_dsp_pop 
336c				endm 
# End of macro FORTH_DSP_POP
336c e1					pop hl 
336d			 
336d					; hl contains value to add to byte at a 
336d				 
336d eb					ex de, hl 
336e			 
336e e1					pop hl 
336f			 
336f					if DEBUG_FORTH_WORDS 
336f						DMARK "INC" 
336f f5				push af  
3370 3a 84 33			ld a, (.dmark)  
3373 32 a6 fd			ld (debug_mark),a  
3376 3a 85 33			ld a, (.dmark+1)  
3379 32 a7 fd			ld (debug_mark+1),a  
337c 3a 86 33			ld a, (.dmark+2)  
337f 32 a8 fd			ld (debug_mark+2),a  
3382 18 03			jr .pastdmark  
3384 ..			.dmark: db "INC"  
3387 f1			.pastdmark: pop af  
3388			endm  
# End of macro DMARK
3388						CALLMONITOR 
3388 cd aa fd			call debug_vector  
338b				endm  
# End of macro CALLMONITOR
338b					endif 
338b			 
338b 7e					ld a,(hl) 
338c 83					add e 
338d 77					ld (hl),a 
338e			 
338e			 
338e			 
338e				       NEXTW 
338e c3 c8 26			jp macro_next 
3391				endm 
# End of macro NEXTW
3391			 
3391			.DEC: 
3391				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3391 6f				db WORD_SYS_CORE+91             
3392 e5 33			dw .INC2            
3394 03				db 2 + 1 
3395 .. 00			db "-!",0              
3398				endm 
# End of macro CWHEAD
3398			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3398					if DEBUG_FORTH_WORDS_KEY 
3398						DMARK "-s_" 
3398 f5				push af  
3399 3a ad 33			ld a, (.dmark)  
339c 32 a6 fd			ld (debug_mark),a  
339f 3a ae 33			ld a, (.dmark+1)  
33a2 32 a7 fd			ld (debug_mark+1),a  
33a5 3a af 33			ld a, (.dmark+2)  
33a8 32 a8 fd			ld (debug_mark+2),a  
33ab 18 03			jr .pastdmark  
33ad ..			.dmark: db "-s_"  
33b0 f1			.pastdmark: pop af  
33b1			endm  
# End of macro DMARK
33b1						CALLMONITOR 
33b1 cd aa fd			call debug_vector  
33b4				endm  
# End of macro CALLMONITOR
33b4					endif 
33b4			 
33b4					FORTH_DSP_VALUEHL 
33b4 cd 12 25			call macro_dsp_valuehl 
33b7				endm 
# End of macro FORTH_DSP_VALUEHL
33b7			 
33b7 e5					push hl   ; save address 
33b8			 
33b8					FORTH_DSP_POP 
33b8 cd ca 25			call macro_forth_dsp_pop 
33bb				endm 
# End of macro FORTH_DSP_POP
33bb			 
33bb					FORTH_DSP_VALUEHL 
33bb cd 12 25			call macro_dsp_valuehl 
33be				endm 
# End of macro FORTH_DSP_VALUEHL
33be			 
33be					; hl contains value to add to byte at a 
33be				 
33be eb					ex de, hl 
33bf			 
33bf e1					pop hl 
33c0			 
33c0					if DEBUG_FORTH_WORDS 
33c0						DMARK "DEC" 
33c0 f5				push af  
33c1 3a d5 33			ld a, (.dmark)  
33c4 32 a6 fd			ld (debug_mark),a  
33c7 3a d6 33			ld a, (.dmark+1)  
33ca 32 a7 fd			ld (debug_mark+1),a  
33cd 3a d7 33			ld a, (.dmark+2)  
33d0 32 a8 fd			ld (debug_mark+2),a  
33d3 18 03			jr .pastdmark  
33d5 ..			.dmark: db "DEC"  
33d8 f1			.pastdmark: pop af  
33d9			endm  
# End of macro DMARK
33d9						CALLMONITOR 
33d9 cd aa fd			call debug_vector  
33dc				endm  
# End of macro CALLMONITOR
33dc					endif 
33dc			 
33dc 7e					ld a,(hl) 
33dd 93					sub e 
33de 77					ld (hl),a 
33df			 
33df			 
33df					FORTH_DSP_POP 
33df cd ca 25			call macro_forth_dsp_pop 
33e2				endm 
# End of macro FORTH_DSP_POP
33e2			 
33e2				       NEXTW 
33e2 c3 c8 26			jp macro_next 
33e5				endm 
# End of macro NEXTW
33e5			 
33e5			.INC2: 
33e5				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
33e5 6f				db WORD_SYS_CORE+91             
33e6 92 34			dw .DEC2            
33e8 04				db 3 + 1 
33e9 .. 00			db "+2!",0              
33ed				endm 
# End of macro CWHEAD
33ed			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
33ed			 
33ed					if DEBUG_FORTH_WORDS_KEY 
33ed						DMARK "+2s" 
33ed f5				push af  
33ee 3a 02 34			ld a, (.dmark)  
33f1 32 a6 fd			ld (debug_mark),a  
33f4 3a 03 34			ld a, (.dmark+1)  
33f7 32 a7 fd			ld (debug_mark+1),a  
33fa 3a 04 34			ld a, (.dmark+2)  
33fd 32 a8 fd			ld (debug_mark+2),a  
3400 18 03			jr .pastdmark  
3402 ..			.dmark: db "+2s"  
3405 f1			.pastdmark: pop af  
3406			endm  
# End of macro DMARK
3406						CALLMONITOR 
3406 cd aa fd			call debug_vector  
3409				endm  
# End of macro CALLMONITOR
3409					endif 
3409			 
3409					; Address 
3409			 
3409					FORTH_DSP_VALUEHL 
3409 cd 12 25			call macro_dsp_valuehl 
340c				endm 
# End of macro FORTH_DSP_VALUEHL
340c			 
340c e5					push hl    ; save address 
340d			 
340d					; load content into de 
340d			 
340d 5e					ld e,(hl) 
340e 23					inc hl 
340f 56					ld d, (hl) 
3410			 
3410					if DEBUG_FORTH_WORDS 
3410						DMARK "+2a" 
3410 f5				push af  
3411 3a 25 34			ld a, (.dmark)  
3414 32 a6 fd			ld (debug_mark),a  
3417 3a 26 34			ld a, (.dmark+1)  
341a 32 a7 fd			ld (debug_mark+1),a  
341d 3a 27 34			ld a, (.dmark+2)  
3420 32 a8 fd			ld (debug_mark+2),a  
3423 18 03			jr .pastdmark  
3425 ..			.dmark: db "+2a"  
3428 f1			.pastdmark: pop af  
3429			endm  
# End of macro DMARK
3429						CALLMONITOR 
3429 cd aa fd			call debug_vector  
342c				endm  
# End of macro CALLMONITOR
342c					endif 
342c			 
342c					FORTH_DSP_POP 
342c cd ca 25			call macro_forth_dsp_pop 
342f				endm 
# End of macro FORTH_DSP_POP
342f			 
342f					; Get value to add 
342f			 
342f					FORTH_DSP_VALUE 
342f cd fb 24			call macro_forth_dsp_value 
3432				endm 
# End of macro FORTH_DSP_VALUE
3432			 
3432					if DEBUG_FORTH_WORDS 
3432						DMARK "+2v" 
3432 f5				push af  
3433 3a 47 34			ld a, (.dmark)  
3436 32 a6 fd			ld (debug_mark),a  
3439 3a 48 34			ld a, (.dmark+1)  
343c 32 a7 fd			ld (debug_mark+1),a  
343f 3a 49 34			ld a, (.dmark+2)  
3442 32 a8 fd			ld (debug_mark+2),a  
3445 18 03			jr .pastdmark  
3447 ..			.dmark: db "+2v"  
344a f1			.pastdmark: pop af  
344b			endm  
# End of macro DMARK
344b						CALLMONITOR 
344b cd aa fd			call debug_vector  
344e				endm  
# End of macro CALLMONITOR
344e					endif 
344e			 
344e 19					add hl, de 
344f			 
344f					if DEBUG_FORTH_WORDS 
344f						DMARK "+2+" 
344f f5				push af  
3450 3a 64 34			ld a, (.dmark)  
3453 32 a6 fd			ld (debug_mark),a  
3456 3a 65 34			ld a, (.dmark+1)  
3459 32 a7 fd			ld (debug_mark+1),a  
345c 3a 66 34			ld a, (.dmark+2)  
345f 32 a8 fd			ld (debug_mark+2),a  
3462 18 03			jr .pastdmark  
3464 ..			.dmark: db "+2+"  
3467 f1			.pastdmark: pop af  
3468			endm  
# End of macro DMARK
3468						CALLMONITOR 
3468 cd aa fd			call debug_vector  
346b				endm  
# End of macro CALLMONITOR
346b					endif 
346b			 
346b					; move result to de 
346b			 
346b eb					ex de, hl 
346c			 
346c					; Address 
346c			 
346c e1					pop hl 
346d			 
346d					; save it back 
346d			 
346d 73					ld (hl), e 
346e 23					inc hl 
346f 72					ld (hl), d 
3470			 
3470					if DEBUG_FORTH_WORDS 
3470						DMARK "+2e" 
3470 f5				push af  
3471 3a 85 34			ld a, (.dmark)  
3474 32 a6 fd			ld (debug_mark),a  
3477 3a 86 34			ld a, (.dmark+1)  
347a 32 a7 fd			ld (debug_mark+1),a  
347d 3a 87 34			ld a, (.dmark+2)  
3480 32 a8 fd			ld (debug_mark+2),a  
3483 18 03			jr .pastdmark  
3485 ..			.dmark: db "+2e"  
3488 f1			.pastdmark: pop af  
3489			endm  
# End of macro DMARK
3489						CALLMONITOR 
3489 cd aa fd			call debug_vector  
348c				endm  
# End of macro CALLMONITOR
348c					endif 
348c			 
348c			 
348c			 
348c					FORTH_DSP_POP 
348c cd ca 25			call macro_forth_dsp_pop 
348f				endm 
# End of macro FORTH_DSP_POP
348f			 
348f			 
348f				       NEXTW 
348f c3 c8 26			jp macro_next 
3492				endm 
# End of macro NEXTW
3492			 
3492			.DEC2: 
3492				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3492 6f				db WORD_SYS_CORE+91             
3493 41 35			dw .GET2            
3495 04				db 3 + 1 
3496 .. 00			db "-2!",0              
349a				endm 
# End of macro CWHEAD
349a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
349a			 
349a			 
349a					if DEBUG_FORTH_WORDS_KEY 
349a						DMARK "-2s" 
349a f5				push af  
349b 3a af 34			ld a, (.dmark)  
349e 32 a6 fd			ld (debug_mark),a  
34a1 3a b0 34			ld a, (.dmark+1)  
34a4 32 a7 fd			ld (debug_mark+1),a  
34a7 3a b1 34			ld a, (.dmark+2)  
34aa 32 a8 fd			ld (debug_mark+2),a  
34ad 18 03			jr .pastdmark  
34af ..			.dmark: db "-2s"  
34b2 f1			.pastdmark: pop af  
34b3			endm  
# End of macro DMARK
34b3						CALLMONITOR 
34b3 cd aa fd			call debug_vector  
34b6				endm  
# End of macro CALLMONITOR
34b6					endif 
34b6			 
34b6					; Address 
34b6			 
34b6					FORTH_DSP_VALUEHL 
34b6 cd 12 25			call macro_dsp_valuehl 
34b9				endm 
# End of macro FORTH_DSP_VALUEHL
34b9			 
34b9 e5					push hl    ; save address 
34ba			 
34ba					; load content into de 
34ba			 
34ba 5e					ld e,(hl) 
34bb 23					inc hl 
34bc 56					ld d, (hl) 
34bd			 
34bd					if DEBUG_FORTH_WORDS 
34bd						DMARK "-2a" 
34bd f5				push af  
34be 3a d2 34			ld a, (.dmark)  
34c1 32 a6 fd			ld (debug_mark),a  
34c4 3a d3 34			ld a, (.dmark+1)  
34c7 32 a7 fd			ld (debug_mark+1),a  
34ca 3a d4 34			ld a, (.dmark+2)  
34cd 32 a8 fd			ld (debug_mark+2),a  
34d0 18 03			jr .pastdmark  
34d2 ..			.dmark: db "-2a"  
34d5 f1			.pastdmark: pop af  
34d6			endm  
# End of macro DMARK
34d6						CALLMONITOR 
34d6 cd aa fd			call debug_vector  
34d9				endm  
# End of macro CALLMONITOR
34d9					endif 
34d9			 
34d9					FORTH_DSP_POP 
34d9 cd ca 25			call macro_forth_dsp_pop 
34dc				endm 
# End of macro FORTH_DSP_POP
34dc			 
34dc					; Get value to remove 
34dc			 
34dc					FORTH_DSP_VALUE 
34dc cd fb 24			call macro_forth_dsp_value 
34df				endm 
# End of macro FORTH_DSP_VALUE
34df			 
34df					if DEBUG_FORTH_WORDS 
34df						DMARK "-2v" 
34df f5				push af  
34e0 3a f4 34			ld a, (.dmark)  
34e3 32 a6 fd			ld (debug_mark),a  
34e6 3a f5 34			ld a, (.dmark+1)  
34e9 32 a7 fd			ld (debug_mark+1),a  
34ec 3a f6 34			ld a, (.dmark+2)  
34ef 32 a8 fd			ld (debug_mark+2),a  
34f2 18 03			jr .pastdmark  
34f4 ..			.dmark: db "-2v"  
34f7 f1			.pastdmark: pop af  
34f8			endm  
# End of macro DMARK
34f8						CALLMONITOR 
34f8 cd aa fd			call debug_vector  
34fb				endm  
# End of macro CALLMONITOR
34fb					endif 
34fb			 
34fb eb					ex de, hl 
34fc ed 52				sbc hl, de 
34fe			 
34fe					if DEBUG_FORTH_WORDS 
34fe						DMARK "-2d" 
34fe f5				push af  
34ff 3a 13 35			ld a, (.dmark)  
3502 32 a6 fd			ld (debug_mark),a  
3505 3a 14 35			ld a, (.dmark+1)  
3508 32 a7 fd			ld (debug_mark+1),a  
350b 3a 15 35			ld a, (.dmark+2)  
350e 32 a8 fd			ld (debug_mark+2),a  
3511 18 03			jr .pastdmark  
3513 ..			.dmark: db "-2d"  
3516 f1			.pastdmark: pop af  
3517			endm  
# End of macro DMARK
3517						CALLMONITOR 
3517 cd aa fd			call debug_vector  
351a				endm  
# End of macro CALLMONITOR
351a					endif 
351a			 
351a					; move result to de 
351a			 
351a eb					ex de, hl 
351b			 
351b					; Address 
351b			 
351b e1					pop hl 
351c			 
351c					; save it back 
351c			 
351c 73					ld (hl), e 
351d 23					inc hl 
351e 72					ld (hl), d 
351f			 
351f					if DEBUG_FORTH_WORDS 
351f						DMARK "-2e" 
351f f5				push af  
3520 3a 34 35			ld a, (.dmark)  
3523 32 a6 fd			ld (debug_mark),a  
3526 3a 35 35			ld a, (.dmark+1)  
3529 32 a7 fd			ld (debug_mark+1),a  
352c 3a 36 35			ld a, (.dmark+2)  
352f 32 a8 fd			ld (debug_mark+2),a  
3532 18 03			jr .pastdmark  
3534 ..			.dmark: db "-2e"  
3537 f1			.pastdmark: pop af  
3538			endm  
# End of macro DMARK
3538						CALLMONITOR 
3538 cd aa fd			call debug_vector  
353b				endm  
# End of macro CALLMONITOR
353b					endif 
353b			 
353b			 
353b					FORTH_DSP_POP 
353b cd ca 25			call macro_forth_dsp_pop 
353e				endm 
# End of macro FORTH_DSP_POP
353e			 
353e			 
353e			 
353e				       NEXTW 
353e c3 c8 26			jp macro_next 
3541				endm 
# End of macro NEXTW
3541			.GET2: 
3541				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3541 6f				db WORD_SYS_CORE+91             
3542 76 35			dw .BANG2            
3544 03				db 2 + 1 
3545 .. 00			db "2@",0              
3548				endm 
# End of macro CWHEAD
3548			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3548					if DEBUG_FORTH_WORDS_KEY 
3548						DMARK "2A_" 
3548 f5				push af  
3549 3a 5d 35			ld a, (.dmark)  
354c 32 a6 fd			ld (debug_mark),a  
354f 3a 5e 35			ld a, (.dmark+1)  
3552 32 a7 fd			ld (debug_mark+1),a  
3555 3a 5f 35			ld a, (.dmark+2)  
3558 32 a8 fd			ld (debug_mark+2),a  
355b 18 03			jr .pastdmark  
355d ..			.dmark: db "2A_"  
3560 f1			.pastdmark: pop af  
3561			endm  
# End of macro DMARK
3561						CALLMONITOR 
3561 cd aa fd			call debug_vector  
3564				endm  
# End of macro CALLMONITOR
3564					endif 
3564			 
3564					FORTH_DSP_VALUEHL 
3564 cd 12 25			call macro_dsp_valuehl 
3567				endm 
# End of macro FORTH_DSP_VALUEHL
3567			 
3567 e5					push hl   ; save address 
3568			 
3568					FORTH_DSP_POP 
3568 cd ca 25			call macro_forth_dsp_pop 
356b				endm 
# End of macro FORTH_DSP_POP
356b			 
356b e1					pop hl 
356c			 
356c 5e					ld e, (hl) 
356d 23					inc hl 
356e 56					ld d, (hl) 
356f			 
356f eb					ex de, hl 
3570			 
3570 cd 1b 23				call forth_push_numhl 
3573			 
3573				       NEXTW 
3573 c3 c8 26			jp macro_next 
3576				endm 
# End of macro NEXTW
3576			.BANG2: 
3576				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3576 6f				db WORD_SYS_CORE+91             
3577 ae 35			dw .CONFIG            
3579 03				db 2 + 1 
357a .. 00			db "2!",0              
357d				endm 
# End of macro CWHEAD
357d			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
357d					if DEBUG_FORTH_WORDS_KEY 
357d						DMARK "2S_" 
357d f5				push af  
357e 3a 92 35			ld a, (.dmark)  
3581 32 a6 fd			ld (debug_mark),a  
3584 3a 93 35			ld a, (.dmark+1)  
3587 32 a7 fd			ld (debug_mark+1),a  
358a 3a 94 35			ld a, (.dmark+2)  
358d 32 a8 fd			ld (debug_mark+2),a  
3590 18 03			jr .pastdmark  
3592 ..			.dmark: db "2S_"  
3595 f1			.pastdmark: pop af  
3596			endm  
# End of macro DMARK
3596						CALLMONITOR 
3596 cd aa fd			call debug_vector  
3599				endm  
# End of macro CALLMONITOR
3599					endif 
3599			 
3599					FORTH_DSP_VALUEHL 
3599 cd 12 25			call macro_dsp_valuehl 
359c				endm 
# End of macro FORTH_DSP_VALUEHL
359c			 
359c e5					push hl   ; save address 
359d			 
359d			 
359d					FORTH_DSP_POP 
359d cd ca 25			call macro_forth_dsp_pop 
35a0				endm 
# End of macro FORTH_DSP_POP
35a0			 
35a0					 
35a0					FORTH_DSP_VALUEHL 
35a0 cd 12 25			call macro_dsp_valuehl 
35a3				endm 
# End of macro FORTH_DSP_VALUEHL
35a3			 
35a3					FORTH_DSP_POP 
35a3 cd ca 25			call macro_forth_dsp_pop 
35a6				endm 
# End of macro FORTH_DSP_POP
35a6			 
35a6 eb					ex de, hl    ; value now in de 
35a7			 
35a7 e1					pop hl 
35a8			 
35a8 73					ld (hl), e 
35a9			 
35a9 23					inc hl 
35aa			 
35aa 72					ld (hl), d 
35ab			 
35ab			 
35ab				       NEXTW 
35ab c3 c8 26			jp macro_next 
35ae				endm 
# End of macro NEXTW
35ae			.CONFIG: 
35ae				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
35ae 6f				db WORD_SYS_CORE+91             
35af bf 35			dw .ADTOS            
35b1 07				db 6 + 1 
35b2 .. 00			db "CONFIG",0              
35b9				endm 
# End of macro CWHEAD
35b9			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
35b9			 
35b9 cd 53 18				call config 
35bc					NEXTW 
35bc c3 c8 26			jp macro_next 
35bf				endm 
# End of macro NEXTW
35bf			 
35bf			.ADTOS: 
35bf				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
35bf 6f				db WORD_SYS_CORE+91             
35c0 d5 35			dw .SBTOS            
35c2 03				db 2 + 1 
35c3 .. 00			db "1+",0              
35c6				endm 
# End of macro CWHEAD
35c6			; | 1+ ( u -- u )  Increment value on TOS | DONE 
35c6			 
35c6					FORTH_DSP_VALUEHL 
35c6 cd 12 25			call macro_dsp_valuehl 
35c9				endm 
# End of macro FORTH_DSP_VALUEHL
35c9 e5					push hl 
35ca			 
35ca					FORTH_DSP_POP 
35ca cd ca 25			call macro_forth_dsp_pop 
35cd				endm 
# End of macro FORTH_DSP_POP
35cd e1					pop hl 
35ce			 
35ce 23					inc hl 
35cf cd 1b 23				call forth_push_numhl 
35d2					 
35d2					NEXTW 
35d2 c3 c8 26			jp macro_next 
35d5				endm 
# End of macro NEXTW
35d5			.SBTOS: 
35d5				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
35d5 6f				db WORD_SYS_CORE+91             
35d6 eb 35			dw .ADSTORE            
35d8 03				db 2 + 1 
35d9 .. 00			db "1-",0              
35dc				endm 
# End of macro CWHEAD
35dc			; | 1- ( u -- u )  Decrement value on TOS | DONE 
35dc			 
35dc					FORTH_DSP_VALUEHL 
35dc cd 12 25			call macro_dsp_valuehl 
35df				endm 
# End of macro FORTH_DSP_VALUEHL
35df e5					push hl 
35e0			 
35e0					FORTH_DSP_POP 
35e0 cd ca 25			call macro_forth_dsp_pop 
35e3				endm 
# End of macro FORTH_DSP_POP
35e3 e1					pop hl 
35e4			 
35e4 2b					dec hl 
35e5 cd 1b 23				call forth_push_numhl 
35e8					 
35e8					NEXTW 
35e8 c3 c8 26			jp macro_next 
35eb				endm 
# End of macro NEXTW
35eb			.ADSTORE: 
35eb				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
35eb 6f				db WORD_SYS_CORE+91             
35ec 01 36			dw .ADWSTORE            
35ee 04				db 3 + 1 
35ef .. 00			db "1+!",0              
35f3				endm 
# End of macro CWHEAD
35f3			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
35f3			 
35f3					FORTH_DSP_VALUEHL 
35f3 cd 12 25			call macro_dsp_valuehl 
35f6				endm 
# End of macro FORTH_DSP_VALUEHL
35f6 e5					push hl 
35f7			 
35f7					FORTH_DSP_POP 
35f7 cd ca 25			call macro_forth_dsp_pop 
35fa				endm 
# End of macro FORTH_DSP_POP
35fa e1					pop hl 
35fb			 
35fb 7e					ld a, (hl) 
35fc 3c					inc a 
35fd 77					ld (hl), a 
35fe					 
35fe					NEXTW 
35fe c3 c8 26			jp macro_next 
3601				endm 
# End of macro NEXTW
3601			.ADWSTORE: 
3601				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3601 6f				db WORD_SYS_CORE+91             
3602 1f 36			dw .SBSTORE            
3604 05				db 4 + 1 
3605 .. 00			db "1+2!",0              
360a				endm 
# End of macro CWHEAD
360a			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
360a			 
360a					FORTH_DSP_VALUEHL 
360a cd 12 25			call macro_dsp_valuehl 
360d				endm 
# End of macro FORTH_DSP_VALUEHL
360d e5					push hl 
360e			 
360e					FORTH_DSP_POP 
360e cd ca 25			call macro_forth_dsp_pop 
3611				endm 
# End of macro FORTH_DSP_POP
3611 e1					pop hl 
3612			 
3612 e5					push hl 
3613			 
3613 cd 4a 26				call loadwordinhl 
3616 23					inc hl 
3617			 
3617 d1					pop de 
3618 eb					ex de, hl 
3619 73					ld (hl), e 
361a 23					inc hl 
361b 72					ld (hl), d 
361c					 
361c					NEXTW 
361c c3 c8 26			jp macro_next 
361f				endm 
# End of macro NEXTW
361f			.SBSTORE: 
361f				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
361f 6f				db WORD_SYS_CORE+91             
3620 35 36			dw .SBWSTORE            
3622 04				db 3 + 1 
3623 .. 00			db "1-!",0              
3627				endm 
# End of macro CWHEAD
3627			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3627			 
3627					FORTH_DSP_VALUEHL 
3627 cd 12 25			call macro_dsp_valuehl 
362a				endm 
# End of macro FORTH_DSP_VALUEHL
362a e5					push hl 
362b			 
362b					FORTH_DSP_POP 
362b cd ca 25			call macro_forth_dsp_pop 
362e				endm 
# End of macro FORTH_DSP_POP
362e e1					pop hl 
362f			 
362f 7e					ld a, (hl) 
3630 3d					dec a 
3631 77					ld (hl), a 
3632					 
3632					NEXTW 
3632 c3 c8 26			jp macro_next 
3635				endm 
# End of macro NEXTW
3635			.SBWSTORE: 
3635				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3635 6f				db WORD_SYS_CORE+91             
3636 53 36			dw .ENDCORE            
3638 05				db 4 + 1 
3639 .. 00			db "1-2!",0              
363e				endm 
# End of macro CWHEAD
363e			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
363e			 
363e					FORTH_DSP_VALUEHL 
363e cd 12 25			call macro_dsp_valuehl 
3641				endm 
# End of macro FORTH_DSP_VALUEHL
3641 e5					push hl 
3642			 
3642					FORTH_DSP_POP 
3642 cd ca 25			call macro_forth_dsp_pop 
3645				endm 
# End of macro FORTH_DSP_POP
3645 e1					pop hl 
3646			 
3646 e5					push hl 
3647			 
3647 cd 4a 26				call loadwordinhl 
364a 2b					dec hl 
364b			 
364b d1					pop de 
364c eb					ex de, hl 
364d 73					ld (hl), e 
364e 23					inc hl 
364f 72					ld (hl), d 
3650					 
3650					NEXTW 
3650 c3 c8 26			jp macro_next 
3653				endm 
# End of macro NEXTW
3653			.ENDCORE: 
3653			 
3653			; eof 
3653			 
3653			 
# End of file forth_words_core.asm
3653			include "forth_words_flow.asm" 
3653			 
3653			; | ## Program Flow Words 
3653			 
3653			.IF: 
3653				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3653 1e				db WORD_SYS_CORE+10             
3654 48 37			dw .THEN            
3656 03				db 2 + 1 
3657 .. 00			db "IF",0              
365a				endm 
# End of macro CWHEAD
365a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
365a			; 
365a					if DEBUG_FORTH_WORDS_KEY 
365a						DMARK "IF." 
365a f5				push af  
365b 3a 6f 36			ld a, (.dmark)  
365e 32 a6 fd			ld (debug_mark),a  
3661 3a 70 36			ld a, (.dmark+1)  
3664 32 a7 fd			ld (debug_mark+1),a  
3667 3a 71 36			ld a, (.dmark+2)  
366a 32 a8 fd			ld (debug_mark+2),a  
366d 18 03			jr .pastdmark  
366f ..			.dmark: db "IF."  
3672 f1			.pastdmark: pop af  
3673			endm  
# End of macro DMARK
3673						CALLMONITOR 
3673 cd aa fd			call debug_vector  
3676				endm  
# End of macro CALLMONITOR
3676					endif 
3676			; eval TOS 
3676			 
3676				FORTH_DSP_VALUEHL 
3676 cd 12 25			call macro_dsp_valuehl 
3679				endm 
# End of macro FORTH_DSP_VALUEHL
3679			 
3679			;	push hl 
3679				FORTH_DSP_POP 
3679 cd ca 25			call macro_forth_dsp_pop 
367c				endm 
# End of macro FORTH_DSP_POP
367c			;	pop hl 
367c			 
367c					if DEBUG_FORTH_WORDS 
367c						DMARK "IF1" 
367c f5				push af  
367d 3a 91 36			ld a, (.dmark)  
3680 32 a6 fd			ld (debug_mark),a  
3683 3a 92 36			ld a, (.dmark+1)  
3686 32 a7 fd			ld (debug_mark+1),a  
3689 3a 93 36			ld a, (.dmark+2)  
368c 32 a8 fd			ld (debug_mark+2),a  
368f 18 03			jr .pastdmark  
3691 ..			.dmark: db "IF1"  
3694 f1			.pastdmark: pop af  
3695			endm  
# End of macro DMARK
3695						CALLMONITOR 
3695 cd aa fd			call debug_vector  
3698				endm  
# End of macro CALLMONITOR
3698					endif 
3698 b7				or a        ; clear carry flag 
3699 11 00 00			ld de, 0 
369c eb				ex de,hl 
369d ed 52			sbc hl, de 
369f c2 29 37			jp nz, .iftrue 
36a2			 
36a2					if DEBUG_FORTH_WORDS 
36a2						DMARK "IF2" 
36a2 f5				push af  
36a3 3a b7 36			ld a, (.dmark)  
36a6 32 a6 fd			ld (debug_mark),a  
36a9 3a b8 36			ld a, (.dmark+1)  
36ac 32 a7 fd			ld (debug_mark+1),a  
36af 3a b9 36			ld a, (.dmark+2)  
36b2 32 a8 fd			ld (debug_mark+2),a  
36b5 18 03			jr .pastdmark  
36b7 ..			.dmark: db "IF2"  
36ba f1			.pastdmark: pop af  
36bb			endm  
# End of macro DMARK
36bb						CALLMONITOR 
36bb cd aa fd			call debug_vector  
36be				endm  
# End of macro CALLMONITOR
36be					endif 
36be			 
36be			; if not true then skip to THEN 
36be			 
36be				; TODO get tok_ptr 
36be				; TODO consume toks until we get to THEN 
36be			 
36be 2a fd f3			ld hl, (os_tok_ptr) 
36c1					if DEBUG_FORTH_WORDS 
36c1						DMARK "IF3" 
36c1 f5				push af  
36c2 3a d6 36			ld a, (.dmark)  
36c5 32 a6 fd			ld (debug_mark),a  
36c8 3a d7 36			ld a, (.dmark+1)  
36cb 32 a7 fd			ld (debug_mark+1),a  
36ce 3a d8 36			ld a, (.dmark+2)  
36d1 32 a8 fd			ld (debug_mark+2),a  
36d4 18 03			jr .pastdmark  
36d6 ..			.dmark: db "IF3"  
36d9 f1			.pastdmark: pop af  
36da			endm  
# End of macro DMARK
36da						CALLMONITOR 
36da cd aa fd			call debug_vector  
36dd				endm  
# End of macro CALLMONITOR
36dd						 
36dd					endif 
36dd 11 24 37			ld de, .ifthen 
36e0					if DEBUG_FORTH_WORDS 
36e0						DMARK "IF4" 
36e0 f5				push af  
36e1 3a f5 36			ld a, (.dmark)  
36e4 32 a6 fd			ld (debug_mark),a  
36e7 3a f6 36			ld a, (.dmark+1)  
36ea 32 a7 fd			ld (debug_mark+1),a  
36ed 3a f7 36			ld a, (.dmark+2)  
36f0 32 a8 fd			ld (debug_mark+2),a  
36f3 18 03			jr .pastdmark  
36f5 ..			.dmark: db "IF4"  
36f8 f1			.pastdmark: pop af  
36f9			endm  
# End of macro DMARK
36f9						CALLMONITOR 
36f9 cd aa fd			call debug_vector  
36fc				endm  
# End of macro CALLMONITOR
36fc					endif 
36fc cd e3 27			call findnexttok  
36ff			 
36ff					if DEBUG_FORTH_WORDS 
36ff						DMARK "IF5" 
36ff f5				push af  
3700 3a 14 37			ld a, (.dmark)  
3703 32 a6 fd			ld (debug_mark),a  
3706 3a 15 37			ld a, (.dmark+1)  
3709 32 a7 fd			ld (debug_mark+1),a  
370c 3a 16 37			ld a, (.dmark+2)  
370f 32 a8 fd			ld (debug_mark+2),a  
3712 18 03			jr .pastdmark  
3714 ..			.dmark: db "IF5"  
3717 f1			.pastdmark: pop af  
3718			endm  
# End of macro DMARK
3718						CALLMONITOR 
3718 cd aa fd			call debug_vector  
371b				endm  
# End of macro CALLMONITOR
371b					endif 
371b				; TODO replace below with ; exec using tok_ptr 
371b 22 fd f3			ld (os_tok_ptr), hl 
371e c3 59 27			jp exec1 
3721				NEXTW 
3721 c3 c8 26			jp macro_next 
3724				endm 
# End of macro NEXTW
3724			 
3724 .. 00		.ifthen:  db "THEN",0 
3729			 
3729			.iftrue:		 
3729				; Exec next words normally 
3729			 
3729				; if true then exec following IF as normal 
3729					if DEBUG_FORTH_WORDS 
3729						DMARK "IFT" 
3729 f5				push af  
372a 3a 3e 37			ld a, (.dmark)  
372d 32 a6 fd			ld (debug_mark),a  
3730 3a 3f 37			ld a, (.dmark+1)  
3733 32 a7 fd			ld (debug_mark+1),a  
3736 3a 40 37			ld a, (.dmark+2)  
3739 32 a8 fd			ld (debug_mark+2),a  
373c 18 03			jr .pastdmark  
373e ..			.dmark: db "IFT"  
3741 f1			.pastdmark: pop af  
3742			endm  
# End of macro DMARK
3742						CALLMONITOR 
3742 cd aa fd			call debug_vector  
3745				endm  
# End of macro CALLMONITOR
3745					endif 
3745			 
3745					NEXTW 
3745 c3 c8 26			jp macro_next 
3748				endm 
# End of macro NEXTW
3748			.THEN: 
3748				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3748 1f				db WORD_SYS_CORE+11             
3749 70 37			dw .ELSE            
374b 05				db 4 + 1 
374c .. 00			db "THEN",0              
3751				endm 
# End of macro CWHEAD
3751			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3751					if DEBUG_FORTH_WORDS_KEY 
3751						DMARK "THN" 
3751 f5				push af  
3752 3a 66 37			ld a, (.dmark)  
3755 32 a6 fd			ld (debug_mark),a  
3758 3a 67 37			ld a, (.dmark+1)  
375b 32 a7 fd			ld (debug_mark+1),a  
375e 3a 68 37			ld a, (.dmark+2)  
3761 32 a8 fd			ld (debug_mark+2),a  
3764 18 03			jr .pastdmark  
3766 ..			.dmark: db "THN"  
3769 f1			.pastdmark: pop af  
376a			endm  
# End of macro DMARK
376a						CALLMONITOR 
376a cd aa fd			call debug_vector  
376d				endm  
# End of macro CALLMONITOR
376d					endif 
376d					NEXTW 
376d c3 c8 26			jp macro_next 
3770				endm 
# End of macro NEXTW
3770			.ELSE: 
3770				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3770 20				db WORD_SYS_CORE+12             
3771 98 37			dw .DO            
3773 03				db 2 + 1 
3774 .. 00			db "ELSE",0              
3779				endm 
# End of macro CWHEAD
3779			; | ELSE ( -- ) Not supported - does nothing | TODO 
3779			 
3779					if DEBUG_FORTH_WORDS_KEY 
3779						DMARK "ELS" 
3779 f5				push af  
377a 3a 8e 37			ld a, (.dmark)  
377d 32 a6 fd			ld (debug_mark),a  
3780 3a 8f 37			ld a, (.dmark+1)  
3783 32 a7 fd			ld (debug_mark+1),a  
3786 3a 90 37			ld a, (.dmark+2)  
3789 32 a8 fd			ld (debug_mark+2),a  
378c 18 03			jr .pastdmark  
378e ..			.dmark: db "ELS"  
3791 f1			.pastdmark: pop af  
3792			endm  
# End of macro DMARK
3792						CALLMONITOR 
3792 cd aa fd			call debug_vector  
3795				endm  
# End of macro CALLMONITOR
3795					endif 
3795			 
3795			 
3795					NEXTW 
3795 c3 c8 26			jp macro_next 
3798				endm 
# End of macro NEXTW
3798			.DO: 
3798				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3798 21				db WORD_SYS_CORE+13             
3799 bf 38			dw .LOOP            
379b 03				db 2 + 1 
379c .. 00			db "DO",0              
379f				endm 
# End of macro CWHEAD
379f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
379f			 
379f					if DEBUG_FORTH_WORDS_KEY 
379f						DMARK "DO." 
379f f5				push af  
37a0 3a b4 37			ld a, (.dmark)  
37a3 32 a6 fd			ld (debug_mark),a  
37a6 3a b5 37			ld a, (.dmark+1)  
37a9 32 a7 fd			ld (debug_mark+1),a  
37ac 3a b6 37			ld a, (.dmark+2)  
37af 32 a8 fd			ld (debug_mark+2),a  
37b2 18 03			jr .pastdmark  
37b4 ..			.dmark: db "DO."  
37b7 f1			.pastdmark: pop af  
37b8			endm  
# End of macro DMARK
37b8						CALLMONITOR 
37b8 cd aa fd			call debug_vector  
37bb				endm  
# End of macro CALLMONITOR
37bb					endif 
37bb			;  push pc to rsp stack past the DO 
37bb			 
37bb 2a fd f3				ld hl, (os_tok_ptr) 
37be 23					inc hl   ; D 
37bf 23					inc hl  ; O 
37c0 23					inc hl   ; null 
37c1					if DEBUG_FORTH_WORDS 
37c1						DMARK "DO2" 
37c1 f5				push af  
37c2 3a d6 37			ld a, (.dmark)  
37c5 32 a6 fd			ld (debug_mark),a  
37c8 3a d7 37			ld a, (.dmark+1)  
37cb 32 a7 fd			ld (debug_mark+1),a  
37ce 3a d8 37			ld a, (.dmark+2)  
37d1 32 a8 fd			ld (debug_mark+2),a  
37d4 18 03			jr .pastdmark  
37d6 ..			.dmark: db "DO2"  
37d9 f1			.pastdmark: pop af  
37da			endm  
# End of macro DMARK
37da						CALLMONITOR 
37da cd aa fd			call debug_vector  
37dd				endm  
# End of macro CALLMONITOR
37dd					endif 
37dd					FORTH_RSP_NEXT 
37dd cd c2 22			call macro_forth_rsp_next 
37e0				endm 
# End of macro FORTH_RSP_NEXT
37e0					if DEBUG_FORTH_WORDS 
37e0						DMARK "DO3" 
37e0 f5				push af  
37e1 3a f5 37			ld a, (.dmark)  
37e4 32 a6 fd			ld (debug_mark),a  
37e7 3a f6 37			ld a, (.dmark+1)  
37ea 32 a7 fd			ld (debug_mark+1),a  
37ed 3a f7 37			ld a, (.dmark+2)  
37f0 32 a8 fd			ld (debug_mark+2),a  
37f3 18 03			jr .pastdmark  
37f5 ..			.dmark: db "DO3"  
37f8 f1			.pastdmark: pop af  
37f9			endm  
# End of macro DMARK
37f9						CALLMONITOR 
37f9 cd aa fd			call debug_vector  
37fc				endm  
# End of macro CALLMONITOR
37fc					endif 
37fc			 
37fc					;if DEBUG_FORTH_WORDS 
37fc				;		push hl 
37fc			;		endif  
37fc			 
37fc			; get counters from data stack 
37fc			 
37fc			 
37fc					FORTH_DSP_VALUEHL 
37fc cd 12 25			call macro_dsp_valuehl 
37ff				endm 
# End of macro FORTH_DSP_VALUEHL
37ff e5					push hl		 ; hl now has starting counter which needs to be tos 
3800			 
3800					if DEBUG_FORTH_WORDS 
3800						DMARK "DO4" 
3800 f5				push af  
3801 3a 15 38			ld a, (.dmark)  
3804 32 a6 fd			ld (debug_mark),a  
3807 3a 16 38			ld a, (.dmark+1)  
380a 32 a7 fd			ld (debug_mark+1),a  
380d 3a 17 38			ld a, (.dmark+2)  
3810 32 a8 fd			ld (debug_mark+2),a  
3813 18 03			jr .pastdmark  
3815 ..			.dmark: db "DO4"  
3818 f1			.pastdmark: pop af  
3819			endm  
# End of macro DMARK
3819						CALLMONITOR 
3819 cd aa fd			call debug_vector  
381c				endm  
# End of macro CALLMONITOR
381c					endif 
381c					FORTH_DSP_POP 
381c cd ca 25			call macro_forth_dsp_pop 
381f				endm 
# End of macro FORTH_DSP_POP
381f			 
381f					if DEBUG_FORTH_WORDS 
381f						DMARK "DO5" 
381f f5				push af  
3820 3a 34 38			ld a, (.dmark)  
3823 32 a6 fd			ld (debug_mark),a  
3826 3a 35 38			ld a, (.dmark+1)  
3829 32 a7 fd			ld (debug_mark+1),a  
382c 3a 36 38			ld a, (.dmark+2)  
382f 32 a8 fd			ld (debug_mark+2),a  
3832 18 03			jr .pastdmark  
3834 ..			.dmark: db "DO5"  
3837 f1			.pastdmark: pop af  
3838			endm  
# End of macro DMARK
3838						CALLMONITOR 
3838 cd aa fd			call debug_vector  
383b				endm  
# End of macro CALLMONITOR
383b					endif 
383b			 
383b					FORTH_DSP_VALUEHL 
383b cd 12 25			call macro_dsp_valuehl 
383e				endm 
# End of macro FORTH_DSP_VALUEHL
383e			;		push hl		 ; hl now has starting limit counter 
383e			 
383e					if DEBUG_FORTH_WORDS 
383e						DMARK "DO6" 
383e f5				push af  
383f 3a 53 38			ld a, (.dmark)  
3842 32 a6 fd			ld (debug_mark),a  
3845 3a 54 38			ld a, (.dmark+1)  
3848 32 a7 fd			ld (debug_mark+1),a  
384b 3a 55 38			ld a, (.dmark+2)  
384e 32 a8 fd			ld (debug_mark+2),a  
3851 18 03			jr .pastdmark  
3853 ..			.dmark: db "DO6"  
3856 f1			.pastdmark: pop af  
3857			endm  
# End of macro DMARK
3857						CALLMONITOR 
3857 cd aa fd			call debug_vector  
385a				endm  
# End of macro CALLMONITOR
385a					endif 
385a					FORTH_DSP_POP 
385a cd ca 25			call macro_forth_dsp_pop 
385d				endm 
# End of macro FORTH_DSP_POP
385d			 
385d			; put counters on the loop stack 
385d			 
385d			;		pop hl			 ; limit counter 
385d d1					pop de			; start counter 
385e			 
385e					; push limit counter 
385e			 
385e					if DEBUG_FORTH_WORDS 
385e						DMARK "DO7" 
385e f5				push af  
385f 3a 73 38			ld a, (.dmark)  
3862 32 a6 fd			ld (debug_mark),a  
3865 3a 74 38			ld a, (.dmark+1)  
3868 32 a7 fd			ld (debug_mark+1),a  
386b 3a 75 38			ld a, (.dmark+2)  
386e 32 a8 fd			ld (debug_mark+2),a  
3871 18 03			jr .pastdmark  
3873 ..			.dmark: db "DO7"  
3876 f1			.pastdmark: pop af  
3877			endm  
# End of macro DMARK
3877						CALLMONITOR 
3877 cd aa fd			call debug_vector  
387a				endm  
# End of macro CALLMONITOR
387a					endif 
387a					FORTH_LOOP_NEXT 
387a cd 43 25			call macro_forth_loop_next 
387d				endm 
# End of macro FORTH_LOOP_NEXT
387d			 
387d					; push start counter 
387d			 
387d eb					ex de, hl 
387e					if DEBUG_FORTH_WORDS 
387e						DMARK "DO7" 
387e f5				push af  
387f 3a 93 38			ld a, (.dmark)  
3882 32 a6 fd			ld (debug_mark),a  
3885 3a 94 38			ld a, (.dmark+1)  
3888 32 a7 fd			ld (debug_mark+1),a  
388b 3a 95 38			ld a, (.dmark+2)  
388e 32 a8 fd			ld (debug_mark+2),a  
3891 18 03			jr .pastdmark  
3893 ..			.dmark: db "DO7"  
3896 f1			.pastdmark: pop af  
3897			endm  
# End of macro DMARK
3897						CALLMONITOR 
3897 cd aa fd			call debug_vector  
389a				endm  
# End of macro CALLMONITOR
389a					endif 
389a					FORTH_LOOP_NEXT 
389a cd 43 25			call macro_forth_loop_next 
389d				endm 
# End of macro FORTH_LOOP_NEXT
389d			 
389d			 
389d					; init first round of I counter 
389d			 
389d 22 21 f4				ld (os_current_i), hl 
38a0			 
38a0					if DEBUG_FORTH_WORDS 
38a0						DMARK "DO8" 
38a0 f5				push af  
38a1 3a b5 38			ld a, (.dmark)  
38a4 32 a6 fd			ld (debug_mark),a  
38a7 3a b6 38			ld a, (.dmark+1)  
38aa 32 a7 fd			ld (debug_mark+1),a  
38ad 3a b7 38			ld a, (.dmark+2)  
38b0 32 a8 fd			ld (debug_mark+2),a  
38b3 18 03			jr .pastdmark  
38b5 ..			.dmark: db "DO8"  
38b8 f1			.pastdmark: pop af  
38b9			endm  
# End of macro DMARK
38b9						CALLMONITOR 
38b9 cd aa fd			call debug_vector  
38bc				endm  
# End of macro CALLMONITOR
38bc					endif 
38bc			 
38bc					NEXTW 
38bc c3 c8 26			jp macro_next 
38bf				endm 
# End of macro NEXTW
38bf			.LOOP: 
38bf				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
38bf 22				db WORD_SYS_CORE+14             
38c0 d7 39			dw .I            
38c2 05				db 4 + 1 
38c3 .. 00			db "LOOP",0              
38c8				endm 
# End of macro CWHEAD
38c8			; | LOOP ( -- ) Increment and test loop counter  | DONE 
38c8			 
38c8				; pop tos as current loop count to hl 
38c8			 
38c8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38c8			 
38c8				FORTH_LOOP_TOS 
38c8 cd 76 25			call macro_forth_loop_tos 
38cb				endm 
# End of macro FORTH_LOOP_TOS
38cb e5				push hl 
38cc			 
38cc					if DEBUG_FORTH_WORDS_KEY 
38cc						DMARK "LOP" 
38cc f5				push af  
38cd 3a e1 38			ld a, (.dmark)  
38d0 32 a6 fd			ld (debug_mark),a  
38d3 3a e2 38			ld a, (.dmark+1)  
38d6 32 a7 fd			ld (debug_mark+1),a  
38d9 3a e3 38			ld a, (.dmark+2)  
38dc 32 a8 fd			ld (debug_mark+2),a  
38df 18 03			jr .pastdmark  
38e1 ..			.dmark: db "LOP"  
38e4 f1			.pastdmark: pop af  
38e5			endm  
# End of macro DMARK
38e5						CALLMONITOR 
38e5 cd aa fd			call debug_vector  
38e8				endm  
# End of macro CALLMONITOR
38e8					endif 
38e8				; next item on the stack is the limit. get it 
38e8			 
38e8			 
38e8				FORTH_LOOP_POP 
38e8 cd 80 25			call macro_forth_loop_pop 
38eb				endm 
# End of macro FORTH_LOOP_POP
38eb			 
38eb				FORTH_LOOP_TOS 
38eb cd 76 25			call macro_forth_loop_tos 
38ee				endm 
# End of macro FORTH_LOOP_TOS
38ee			 
38ee d1				pop de		 ; de = i, hl = limit 
38ef			 
38ef					if DEBUG_FORTH_WORDS 
38ef						DMARK "LP1" 
38ef f5				push af  
38f0 3a 04 39			ld a, (.dmark)  
38f3 32 a6 fd			ld (debug_mark),a  
38f6 3a 05 39			ld a, (.dmark+1)  
38f9 32 a7 fd			ld (debug_mark+1),a  
38fc 3a 06 39			ld a, (.dmark+2)  
38ff 32 a8 fd			ld (debug_mark+2),a  
3902 18 03			jr .pastdmark  
3904 ..			.dmark: db "LP1"  
3907 f1			.pastdmark: pop af  
3908			endm  
# End of macro DMARK
3908						CALLMONITOR 
3908 cd aa fd			call debug_vector  
390b				endm  
# End of macro CALLMONITOR
390b					endif 
390b			 
390b				; go back to previous word 
390b			 
390b d5				push de    ; save I for inc later 
390c			 
390c			 
390c				; get limit 
390c				;  is I at limit? 
390c			 
390c			 
390c					if DEBUG_FORTH_WORDS 
390c						DMARK "LP1" 
390c f5				push af  
390d 3a 21 39			ld a, (.dmark)  
3910 32 a6 fd			ld (debug_mark),a  
3913 3a 22 39			ld a, (.dmark+1)  
3916 32 a7 fd			ld (debug_mark+1),a  
3919 3a 23 39			ld a, (.dmark+2)  
391c 32 a8 fd			ld (debug_mark+2),a  
391f 18 03			jr .pastdmark  
3921 ..			.dmark: db "LP1"  
3924 f1			.pastdmark: pop af  
3925			endm  
# End of macro DMARK
3925						CALLMONITOR 
3925 cd aa fd			call debug_vector  
3928				endm  
# End of macro CALLMONITOR
3928					endif 
3928			 
3928 ed 52			sbc hl, de 
392a			 
392a			 
392a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
392a			 
392a 20 26				jr nz, .loopnotdone 
392c			 
392c e1				pop hl   ; get rid of saved I 
392d				FORTH_LOOP_POP     ; get rid of limit 
392d cd 80 25			call macro_forth_loop_pop 
3930				endm 
# End of macro FORTH_LOOP_POP
3930			 
3930				FORTH_RSP_POP     ; get rid of DO ptr 
3930 cd e3 22			call macro_forth_rsp_pop 
3933				endm 
# End of macro FORTH_RSP_POP
3933			 
3933			if DEBUG_FORTH_WORDS 
3933						DMARK "LP>" 
3933 f5				push af  
3934 3a 48 39			ld a, (.dmark)  
3937 32 a6 fd			ld (debug_mark),a  
393a 3a 49 39			ld a, (.dmark+1)  
393d 32 a7 fd			ld (debug_mark+1),a  
3940 3a 4a 39			ld a, (.dmark+2)  
3943 32 a8 fd			ld (debug_mark+2),a  
3946 18 03			jr .pastdmark  
3948 ..			.dmark: db "LP>"  
394b f1			.pastdmark: pop af  
394c			endm  
# End of macro DMARK
394c				CALLMONITOR 
394c cd aa fd			call debug_vector  
394f				endm  
# End of macro CALLMONITOR
394f			endif 
394f			 
394f					NEXTW 
394f c3 c8 26			jp macro_next 
3952				endm 
# End of macro NEXTW
3952				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3952			 
3952			.loopnotdone: 
3952			 
3952 e1				pop hl    ; get I 
3953 23				inc hl 
3954			 
3954			   	; save new I 
3954			 
3954			 
3954					; set I counter 
3954			 
3954 22 21 f4				ld (os_current_i), hl 
3957			 
3957					if DEBUG_FORTH_WORDS 
3957						DMARK "LPN" 
3957 f5				push af  
3958 3a 6c 39			ld a, (.dmark)  
395b 32 a6 fd			ld (debug_mark),a  
395e 3a 6d 39			ld a, (.dmark+1)  
3961 32 a7 fd			ld (debug_mark+1),a  
3964 3a 6e 39			ld a, (.dmark+2)  
3967 32 a8 fd			ld (debug_mark+2),a  
396a 18 03			jr .pastdmark  
396c ..			.dmark: db "LPN"  
396f f1			.pastdmark: pop af  
3970			endm  
# End of macro DMARK
3970					CALLMONITOR 
3970 cd aa fd			call debug_vector  
3973				endm  
# End of macro CALLMONITOR
3973					endif 
3973					 
3973				FORTH_LOOP_NEXT 
3973 cd 43 25			call macro_forth_loop_next 
3976				endm 
# End of macro FORTH_LOOP_NEXT
3976			 
3976			 
3976					if DEBUG_FORTH_WORDS 
3976 eb						ex de,hl 
3977					endif 
3977			 
3977			;	; get DO ptr 
3977			; 
3977					if DEBUG_FORTH_WORDS 
3977						DMARK "LP7" 
3977 f5				push af  
3978 3a 8c 39			ld a, (.dmark)  
397b 32 a6 fd			ld (debug_mark),a  
397e 3a 8d 39			ld a, (.dmark+1)  
3981 32 a7 fd			ld (debug_mark+1),a  
3984 3a 8e 39			ld a, (.dmark+2)  
3987 32 a8 fd			ld (debug_mark+2),a  
398a 18 03			jr .pastdmark  
398c ..			.dmark: db "LP7"  
398f f1			.pastdmark: pop af  
3990			endm  
# End of macro DMARK
3990					CALLMONITOR 
3990 cd aa fd			call debug_vector  
3993				endm  
# End of macro CALLMONITOR
3993					endif 
3993				FORTH_RSP_TOS 
3993 cd d9 22			call macro_forth_rsp_tos 
3996				endm 
# End of macro FORTH_RSP_TOS
3996			 
3996					if DEBUG_FORTH_WORDS 
3996						DMARK "LP8" 
3996 f5				push af  
3997 3a ab 39			ld a, (.dmark)  
399a 32 a6 fd			ld (debug_mark),a  
399d 3a ac 39			ld a, (.dmark+1)  
39a0 32 a7 fd			ld (debug_mark+1),a  
39a3 3a ad 39			ld a, (.dmark+2)  
39a6 32 a8 fd			ld (debug_mark+2),a  
39a9 18 03			jr .pastdmark  
39ab ..			.dmark: db "LP8"  
39ae f1			.pastdmark: pop af  
39af			endm  
# End of macro DMARK
39af					CALLMONITOR 
39af cd aa fd			call debug_vector  
39b2				endm  
# End of macro CALLMONITOR
39b2					endif 
39b2				;push hl 
39b2			 
39b2				; not going to DO any more 
39b2				; get rid of the RSP pointer as DO will add it back in 
39b2				;FORTH_RSP_POP 
39b2				;pop hl 
39b2			 
39b2				;ld hl,(cli_ret_sp) 
39b2				;ld e, (hl) 
39b2				;inc hl 
39b2				;ld d, (hl) 
39b2				;ex de,hl 
39b2 22 fd f3			ld (os_tok_ptr), hl 
39b5					if DEBUG_FORTH_WORDS 
39b5						DMARK "LP<" 
39b5 f5				push af  
39b6 3a ca 39			ld a, (.dmark)  
39b9 32 a6 fd			ld (debug_mark),a  
39bc 3a cb 39			ld a, (.dmark+1)  
39bf 32 a7 fd			ld (debug_mark+1),a  
39c2 3a cc 39			ld a, (.dmark+2)  
39c5 32 a8 fd			ld (debug_mark+2),a  
39c8 18 03			jr .pastdmark  
39ca ..			.dmark: db "LP<"  
39cd f1			.pastdmark: pop af  
39ce			endm  
# End of macro DMARK
39ce					CALLMONITOR 
39ce cd aa fd			call debug_vector  
39d1				endm  
# End of macro CALLMONITOR
39d1				endif 
39d1 c3 59 27			jp exec1 
39d4			 
39d4					 
39d4			 
39d4			 
39d4					NEXTW 
39d4 c3 c8 26			jp macro_next 
39d7				endm 
# End of macro NEXTW
39d7			.I:  
39d7			 
39d7				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
39d7 5e				db WORD_SYS_CORE+74             
39d8 02 3a			dw .DLOOP            
39da 02				db 1 + 1 
39db .. 00			db "I",0              
39dd				endm 
# End of macro CWHEAD
39dd			; | I ( -- ) Current loop counter | DONE 
39dd					if DEBUG_FORTH_WORDS_KEY 
39dd						DMARK "I.." 
39dd f5				push af  
39de 3a f2 39			ld a, (.dmark)  
39e1 32 a6 fd			ld (debug_mark),a  
39e4 3a f3 39			ld a, (.dmark+1)  
39e7 32 a7 fd			ld (debug_mark+1),a  
39ea 3a f4 39			ld a, (.dmark+2)  
39ed 32 a8 fd			ld (debug_mark+2),a  
39f0 18 03			jr .pastdmark  
39f2 ..			.dmark: db "I.."  
39f5 f1			.pastdmark: pop af  
39f6			endm  
# End of macro DMARK
39f6						CALLMONITOR 
39f6 cd aa fd			call debug_vector  
39f9				endm  
# End of macro CALLMONITOR
39f9					endif 
39f9			 
39f9 2a 21 f4				ld hl,(os_current_i) 
39fc cd 1b 23				call forth_push_numhl 
39ff			 
39ff					NEXTW 
39ff c3 c8 26			jp macro_next 
3a02				endm 
# End of macro NEXTW
3a02			.DLOOP: 
3a02				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3a02 5f				db WORD_SYS_CORE+75             
3a03 e3 3a			dw .REPEAT            
3a05 06				db 5 + 1 
3a06 .. 00			db "-LOOP",0              
3a0c				endm 
# End of macro CWHEAD
3a0c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3a0c				; pop tos as current loop count to hl 
3a0c					if DEBUG_FORTH_WORDS_KEY 
3a0c						DMARK "-LP" 
3a0c f5				push af  
3a0d 3a 21 3a			ld a, (.dmark)  
3a10 32 a6 fd			ld (debug_mark),a  
3a13 3a 22 3a			ld a, (.dmark+1)  
3a16 32 a7 fd			ld (debug_mark+1),a  
3a19 3a 23 3a			ld a, (.dmark+2)  
3a1c 32 a8 fd			ld (debug_mark+2),a  
3a1f 18 03			jr .pastdmark  
3a21 ..			.dmark: db "-LP"  
3a24 f1			.pastdmark: pop af  
3a25			endm  
# End of macro DMARK
3a25						CALLMONITOR 
3a25 cd aa fd			call debug_vector  
3a28				endm  
# End of macro CALLMONITOR
3a28					endif 
3a28			 
3a28				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3a28			 
3a28				FORTH_LOOP_TOS 
3a28 cd 76 25			call macro_forth_loop_tos 
3a2b				endm 
# End of macro FORTH_LOOP_TOS
3a2b e5				push hl 
3a2c			 
3a2c					if DEBUG_FORTH_WORDS 
3a2c						DMARK "-LP" 
3a2c f5				push af  
3a2d 3a 41 3a			ld a, (.dmark)  
3a30 32 a6 fd			ld (debug_mark),a  
3a33 3a 42 3a			ld a, (.dmark+1)  
3a36 32 a7 fd			ld (debug_mark+1),a  
3a39 3a 43 3a			ld a, (.dmark+2)  
3a3c 32 a8 fd			ld (debug_mark+2),a  
3a3f 18 03			jr .pastdmark  
3a41 ..			.dmark: db "-LP"  
3a44 f1			.pastdmark: pop af  
3a45			endm  
# End of macro DMARK
3a45						CALLMONITOR 
3a45 cd aa fd			call debug_vector  
3a48				endm  
# End of macro CALLMONITOR
3a48					endif 
3a48				; next item on the stack is the limit. get it 
3a48			 
3a48			 
3a48				FORTH_LOOP_POP 
3a48 cd 80 25			call macro_forth_loop_pop 
3a4b				endm 
# End of macro FORTH_LOOP_POP
3a4b			 
3a4b				FORTH_LOOP_TOS 
3a4b cd 76 25			call macro_forth_loop_tos 
3a4e				endm 
# End of macro FORTH_LOOP_TOS
3a4e			 
3a4e d1				pop de		 ; de = i, hl = limit 
3a4f			 
3a4f					if DEBUG_FORTH_WORDS 
3a4f						DMARK "-L1" 
3a4f f5				push af  
3a50 3a 64 3a			ld a, (.dmark)  
3a53 32 a6 fd			ld (debug_mark),a  
3a56 3a 65 3a			ld a, (.dmark+1)  
3a59 32 a7 fd			ld (debug_mark+1),a  
3a5c 3a 66 3a			ld a, (.dmark+2)  
3a5f 32 a8 fd			ld (debug_mark+2),a  
3a62 18 03			jr .pastdmark  
3a64 ..			.dmark: db "-L1"  
3a67 f1			.pastdmark: pop af  
3a68			endm  
# End of macro DMARK
3a68						CALLMONITOR 
3a68 cd aa fd			call debug_vector  
3a6b				endm  
# End of macro CALLMONITOR
3a6b					endif 
3a6b			 
3a6b				; go back to previous word 
3a6b			 
3a6b d5				push de    ; save I for inc later 
3a6c			 
3a6c			 
3a6c				; get limit 
3a6c				;  is I at limit? 
3a6c			 
3a6c			 
3a6c					if DEBUG_FORTH_WORDS 
3a6c						DMARK "-L1" 
3a6c f5				push af  
3a6d 3a 81 3a			ld a, (.dmark)  
3a70 32 a6 fd			ld (debug_mark),a  
3a73 3a 82 3a			ld a, (.dmark+1)  
3a76 32 a7 fd			ld (debug_mark+1),a  
3a79 3a 83 3a			ld a, (.dmark+2)  
3a7c 32 a8 fd			ld (debug_mark+2),a  
3a7f 18 03			jr .pastdmark  
3a81 ..			.dmark: db "-L1"  
3a84 f1			.pastdmark: pop af  
3a85			endm  
# End of macro DMARK
3a85						CALLMONITOR 
3a85 cd aa fd			call debug_vector  
3a88				endm  
# End of macro CALLMONITOR
3a88					endif 
3a88			 
3a88 ed 52			sbc hl, de 
3a8a			 
3a8a			 
3a8a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3a8a			 
3a8a 20 26				jr nz, .mloopnotdone 
3a8c			 
3a8c e1				pop hl   ; get rid of saved I 
3a8d				FORTH_LOOP_POP     ; get rid of limit 
3a8d cd 80 25			call macro_forth_loop_pop 
3a90				endm 
# End of macro FORTH_LOOP_POP
3a90			 
3a90				FORTH_RSP_POP     ; get rid of DO ptr 
3a90 cd e3 22			call macro_forth_rsp_pop 
3a93				endm 
# End of macro FORTH_RSP_POP
3a93			 
3a93			if DEBUG_FORTH_WORDS 
3a93						DMARK "-L>" 
3a93 f5				push af  
3a94 3a a8 3a			ld a, (.dmark)  
3a97 32 a6 fd			ld (debug_mark),a  
3a9a 3a a9 3a			ld a, (.dmark+1)  
3a9d 32 a7 fd			ld (debug_mark+1),a  
3aa0 3a aa 3a			ld a, (.dmark+2)  
3aa3 32 a8 fd			ld (debug_mark+2),a  
3aa6 18 03			jr .pastdmark  
3aa8 ..			.dmark: db "-L>"  
3aab f1			.pastdmark: pop af  
3aac			endm  
# End of macro DMARK
3aac				CALLMONITOR 
3aac cd aa fd			call debug_vector  
3aaf				endm  
# End of macro CALLMONITOR
3aaf			endif 
3aaf			 
3aaf					NEXTW 
3aaf c3 c8 26			jp macro_next 
3ab2				endm 
# End of macro NEXTW
3ab2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3ab2			 
3ab2			.mloopnotdone: 
3ab2			 
3ab2 e1				pop hl    ; get I 
3ab3 2b				dec hl 
3ab4			 
3ab4			   	; save new I 
3ab4			 
3ab4			 
3ab4					; set I counter 
3ab4			 
3ab4 22 21 f4				ld (os_current_i), hl 
3ab7			 
3ab7					 
3ab7				FORTH_LOOP_NEXT 
3ab7 cd 43 25			call macro_forth_loop_next 
3aba				endm 
# End of macro FORTH_LOOP_NEXT
3aba			 
3aba			 
3aba					if DEBUG_FORTH_WORDS 
3aba eb						ex de,hl 
3abb					endif 
3abb			 
3abb			;	; get DO ptr 
3abb			; 
3abb				FORTH_RSP_TOS 
3abb cd d9 22			call macro_forth_rsp_tos 
3abe				endm 
# End of macro FORTH_RSP_TOS
3abe			 
3abe				;push hl 
3abe			 
3abe				; not going to DO any more 
3abe				; get rid of the RSP pointer as DO will add it back in 
3abe				;FORTH_RSP_POP 
3abe				;pop hl 
3abe			 
3abe			 
3abe 22 fd f3			ld (os_tok_ptr), hl 
3ac1					if DEBUG_FORTH_WORDS 
3ac1						DMARK "-L<" 
3ac1 f5				push af  
3ac2 3a d6 3a			ld a, (.dmark)  
3ac5 32 a6 fd			ld (debug_mark),a  
3ac8 3a d7 3a			ld a, (.dmark+1)  
3acb 32 a7 fd			ld (debug_mark+1),a  
3ace 3a d8 3a			ld a, (.dmark+2)  
3ad1 32 a8 fd			ld (debug_mark+2),a  
3ad4 18 03			jr .pastdmark  
3ad6 ..			.dmark: db "-L<"  
3ad9 f1			.pastdmark: pop af  
3ada			endm  
# End of macro DMARK
3ada					CALLMONITOR 
3ada cd aa fd			call debug_vector  
3add				endm  
# End of macro CALLMONITOR
3add				endif 
3add c3 59 27			jp exec1 
3ae0			 
3ae0					 
3ae0			 
3ae0			 
3ae0			 
3ae0				NEXTW 
3ae0 c3 c8 26			jp macro_next 
3ae3				endm 
# End of macro NEXTW
3ae3			 
3ae3			 
3ae3			 
3ae3			 
3ae3			.REPEAT: 
3ae3				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3ae3 71				db WORD_SYS_CORE+93             
3ae4 36 3b			dw .UNTIL            
3ae6 06				db 5 + 1 
3ae7 .. 00			db "REPEAT",0              
3aee				endm 
# End of macro CWHEAD
3aee			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3aee			;  push pc to rsp stack past the REPEAT 
3aee					if DEBUG_FORTH_WORDS_KEY 
3aee						DMARK "REP" 
3aee f5				push af  
3aef 3a 03 3b			ld a, (.dmark)  
3af2 32 a6 fd			ld (debug_mark),a  
3af5 3a 04 3b			ld a, (.dmark+1)  
3af8 32 a7 fd			ld (debug_mark+1),a  
3afb 3a 05 3b			ld a, (.dmark+2)  
3afe 32 a8 fd			ld (debug_mark+2),a  
3b01 18 03			jr .pastdmark  
3b03 ..			.dmark: db "REP"  
3b06 f1			.pastdmark: pop af  
3b07			endm  
# End of macro DMARK
3b07						CALLMONITOR 
3b07 cd aa fd			call debug_vector  
3b0a				endm  
# End of macro CALLMONITOR
3b0a					endif 
3b0a			 
3b0a 2a fd f3				ld hl, (os_tok_ptr) 
3b0d 23					inc hl   ; R 
3b0e 23					inc hl  ; E 
3b0f 23					inc hl   ; P 
3b10 23					inc hl   ; E 
3b11 23					inc hl   ; A 
3b12 23					inc hl   ; T 
3b13 23					inc hl   ; zero 
3b14					FORTH_RSP_NEXT 
3b14 cd c2 22			call macro_forth_rsp_next 
3b17				endm 
# End of macro FORTH_RSP_NEXT
3b17			 
3b17			 
3b17					if DEBUG_FORTH_WORDS 
3b17						DMARK "REP" 
3b17 f5				push af  
3b18 3a 2c 3b			ld a, (.dmark)  
3b1b 32 a6 fd			ld (debug_mark),a  
3b1e 3a 2d 3b			ld a, (.dmark+1)  
3b21 32 a7 fd			ld (debug_mark+1),a  
3b24 3a 2e 3b			ld a, (.dmark+2)  
3b27 32 a8 fd			ld (debug_mark+2),a  
3b2a 18 03			jr .pastdmark  
3b2c ..			.dmark: db "REP"  
3b2f f1			.pastdmark: pop af  
3b30			endm  
# End of macro DMARK
3b30						;pop bc    ; TODO BUG ?????? what is this for???? 
3b30						CALLMONITOR 
3b30 cd aa fd			call debug_vector  
3b33				endm  
# End of macro CALLMONITOR
3b33					endif 
3b33			 
3b33					NEXTW 
3b33 c3 c8 26			jp macro_next 
3b36				endm 
# End of macro NEXTW
3b36			;	       NEXTW 
3b36			 
3b36			.UNTIL: 
3b36				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3b36 72				db WORD_SYS_CORE+94             
3b37 cd 3b			dw .ENDFLOW            
3b39 06				db 5 + 1 
3b3a .. 00			db "UNTIL",0              
3b40				endm 
# End of macro CWHEAD
3b40			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3b40			 
3b40				; pop tos as check 
3b40			 
3b40				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3b40			 
3b40				FORTH_DSP_VALUEHL 
3b40 cd 12 25			call macro_dsp_valuehl 
3b43				endm 
# End of macro FORTH_DSP_VALUEHL
3b43			 
3b43					if DEBUG_FORTH_WORDS_KEY 
3b43						DMARK "UNT" 
3b43 f5				push af  
3b44 3a 58 3b			ld a, (.dmark)  
3b47 32 a6 fd			ld (debug_mark),a  
3b4a 3a 59 3b			ld a, (.dmark+1)  
3b4d 32 a7 fd			ld (debug_mark+1),a  
3b50 3a 5a 3b			ld a, (.dmark+2)  
3b53 32 a8 fd			ld (debug_mark+2),a  
3b56 18 03			jr .pastdmark  
3b58 ..			.dmark: db "UNT"  
3b5b f1			.pastdmark: pop af  
3b5c			endm  
# End of macro DMARK
3b5c						CALLMONITOR 
3b5c cd aa fd			call debug_vector  
3b5f				endm  
# End of macro CALLMONITOR
3b5f					endif 
3b5f			 
3b5f			;	push hl 
3b5f				FORTH_DSP_POP 
3b5f cd ca 25			call macro_forth_dsp_pop 
3b62				endm 
# End of macro FORTH_DSP_POP
3b62			 
3b62			;	pop hl 
3b62			 
3b62				; test if true 
3b62			 
3b62 cd f8 0f			call ishlzero 
3b65			;	ld a,l 
3b65			;	add h 
3b65			; 
3b65			;	cp 0 
3b65			 
3b65 20 3e			jr nz, .untilnotdone 
3b67			 
3b67					if DEBUG_FORTH_WORDS 
3b67						DMARK "UNf" 
3b67 f5				push af  
3b68 3a 7c 3b			ld a, (.dmark)  
3b6b 32 a6 fd			ld (debug_mark),a  
3b6e 3a 7d 3b			ld a, (.dmark+1)  
3b71 32 a7 fd			ld (debug_mark+1),a  
3b74 3a 7e 3b			ld a, (.dmark+2)  
3b77 32 a8 fd			ld (debug_mark+2),a  
3b7a 18 03			jr .pastdmark  
3b7c ..			.dmark: db "UNf"  
3b7f f1			.pastdmark: pop af  
3b80			endm  
# End of macro DMARK
3b80						CALLMONITOR 
3b80 cd aa fd			call debug_vector  
3b83				endm  
# End of macro CALLMONITOR
3b83					endif 
3b83			 
3b83			 
3b83			 
3b83				FORTH_RSP_POP     ; get rid of DO ptr 
3b83 cd e3 22			call macro_forth_rsp_pop 
3b86				endm 
# End of macro FORTH_RSP_POP
3b86			 
3b86			if DEBUG_FORTH_WORDS 
3b86						DMARK "UN>" 
3b86 f5				push af  
3b87 3a 9b 3b			ld a, (.dmark)  
3b8a 32 a6 fd			ld (debug_mark),a  
3b8d 3a 9c 3b			ld a, (.dmark+1)  
3b90 32 a7 fd			ld (debug_mark+1),a  
3b93 3a 9d 3b			ld a, (.dmark+2)  
3b96 32 a8 fd			ld (debug_mark+2),a  
3b99 18 03			jr .pastdmark  
3b9b ..			.dmark: db "UN>"  
3b9e f1			.pastdmark: pop af  
3b9f			endm  
# End of macro DMARK
3b9f				CALLMONITOR 
3b9f cd aa fd			call debug_vector  
3ba2				endm  
# End of macro CALLMONITOR
3ba2			endif 
3ba2			 
3ba2					NEXTW 
3ba2 c3 c8 26			jp macro_next 
3ba5				endm 
# End of macro NEXTW
3ba5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3ba5			 
3ba5			.untilnotdone: 
3ba5			 
3ba5			 
3ba5			;	; get DO ptr 
3ba5			; 
3ba5				FORTH_RSP_TOS 
3ba5 cd d9 22			call macro_forth_rsp_tos 
3ba8				endm 
# End of macro FORTH_RSP_TOS
3ba8			 
3ba8				;push hl 
3ba8			 
3ba8				; not going to DO any more 
3ba8				; get rid of the RSP pointer as DO will add it back in 
3ba8				;FORTH_RSP_POP 
3ba8				;pop hl 
3ba8			 
3ba8			 
3ba8 22 fd f3			ld (os_tok_ptr), hl 
3bab					if DEBUG_FORTH_WORDS 
3bab						DMARK "UN<" 
3bab f5				push af  
3bac 3a c0 3b			ld a, (.dmark)  
3baf 32 a6 fd			ld (debug_mark),a  
3bb2 3a c1 3b			ld a, (.dmark+1)  
3bb5 32 a7 fd			ld (debug_mark+1),a  
3bb8 3a c2 3b			ld a, (.dmark+2)  
3bbb 32 a8 fd			ld (debug_mark+2),a  
3bbe 18 03			jr .pastdmark  
3bc0 ..			.dmark: db "UN<"  
3bc3 f1			.pastdmark: pop af  
3bc4			endm  
# End of macro DMARK
3bc4					CALLMONITOR 
3bc4 cd aa fd			call debug_vector  
3bc7				endm  
# End of macro CALLMONITOR
3bc7				endif 
3bc7 c3 59 27			jp exec1 
3bca			 
3bca					 
3bca			 
3bca			 
3bca					NEXTW 
3bca c3 c8 26			jp macro_next 
3bcd				endm 
# End of macro NEXTW
3bcd			 
3bcd			 
3bcd			.ENDFLOW: 
3bcd			 
3bcd			; eof 
3bcd			 
# End of file forth_words_flow.asm
3bcd			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3bcd			include "forth_words_logic.asm" 
3bcd			 
3bcd			; | ## Logic Words 
3bcd			 
3bcd			.NOT: 
3bcd				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3bcd 2d				db WORD_SYS_CORE+25             
3bce 15 3c			dw .IS            
3bd0 04				db 3 + 1 
3bd1 .. 00			db "NOT",0              
3bd5				endm 
# End of macro CWHEAD
3bd5			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3bd5					if DEBUG_FORTH_WORDS_KEY 
3bd5						DMARK "NOT" 
3bd5 f5				push af  
3bd6 3a ea 3b			ld a, (.dmark)  
3bd9 32 a6 fd			ld (debug_mark),a  
3bdc 3a eb 3b			ld a, (.dmark+1)  
3bdf 32 a7 fd			ld (debug_mark+1),a  
3be2 3a ec 3b			ld a, (.dmark+2)  
3be5 32 a8 fd			ld (debug_mark+2),a  
3be8 18 03			jr .pastdmark  
3bea ..			.dmark: db "NOT"  
3bed f1			.pastdmark: pop af  
3bee			endm  
# End of macro DMARK
3bee						CALLMONITOR 
3bee cd aa fd			call debug_vector  
3bf1				endm  
# End of macro CALLMONITOR
3bf1					endif 
3bf1					FORTH_DSP 
3bf1 cd d8 24			call macro_forth_dsp 
3bf4				endm 
# End of macro FORTH_DSP
3bf4 7e					ld a,(hl)	; get type of value on TOS 
3bf5 fe 02				cp DS_TYPE_INUM  
3bf7 28 03				jr z, .noti 
3bf9					NEXTW 
3bf9 c3 c8 26			jp macro_next 
3bfc				endm 
# End of macro NEXTW
3bfc			.noti:          FORTH_DSP_VALUEHL 
3bfc cd 12 25			call macro_dsp_valuehl 
3bff				endm 
# End of macro FORTH_DSP_VALUEHL
3bff			;		push hl 
3bff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bff cd ca 25			call macro_forth_dsp_pop 
3c02				endm 
# End of macro FORTH_DSP_POP
3c02			;		pop hl 
3c02 3e 00				ld a,0 
3c04 bd					cp l 
3c05 28 04				jr z, .not2t 
3c07 2e 00				ld l, 0 
3c09 18 02				jr .notip 
3c0b			 
3c0b 2e ff		.not2t:		ld l, 255 
3c0d			 
3c0d 26 00		.notip:		ld h, 0	 
3c0f			 
3c0f cd 1b 23				call forth_push_numhl 
3c12					NEXTW 
3c12 c3 c8 26			jp macro_next 
3c15				endm 
# End of macro NEXTW
3c15			 
3c15			.IS: 
3c15				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3c15 2d				db WORD_SYS_CORE+25             
3c16 3b 3c			dw .LZERO            
3c18 03				db 2 + 1 
3c19 .. 00			db "IS",0              
3c1c				endm 
# End of macro CWHEAD
3c1c			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3c1c					if DEBUG_FORTH_WORDS_KEY 
3c1c						DMARK "IS." 
3c1c f5				push af  
3c1d 3a 31 3c			ld a, (.dmark)  
3c20 32 a6 fd			ld (debug_mark),a  
3c23 3a 32 3c			ld a, (.dmark+1)  
3c26 32 a7 fd			ld (debug_mark+1),a  
3c29 3a 33 3c			ld a, (.dmark+2)  
3c2c 32 a8 fd			ld (debug_mark+2),a  
3c2f 18 03			jr .pastdmark  
3c31 ..			.dmark: db "IS."  
3c34 f1			.pastdmark: pop af  
3c35			endm  
# End of macro DMARK
3c35						CALLMONITOR 
3c35 cd aa fd			call debug_vector  
3c38				endm  
# End of macro CALLMONITOR
3c38					endif 
3c38					NEXTW 
3c38 c3 c8 26			jp macro_next 
3c3b				endm 
# End of macro NEXTW
3c3b			.LZERO: 
3c3b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3c3b 2d				db WORD_SYS_CORE+25             
3c3c 45 3c			dw .TZERO            
3c3e 03				db 2 + 1 
3c3f .. 00			db "0<",0              
3c42				endm 
# End of macro CWHEAD
3c42			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3c42					NEXTW 
3c42 c3 c8 26			jp macro_next 
3c45				endm 
# End of macro NEXTW
3c45			.TZERO: 
3c45				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3c45 2e				db WORD_SYS_CORE+26             
3c46 8c 3c			dw .LESS            
3c48 03				db 2 + 1 
3c49 .. 00			db "0=",0              
3c4c				endm 
# End of macro CWHEAD
3c4c			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3c4c				; TODO add floating point number detection 
3c4c					;v5 FORTH_DSP_VALUE 
3c4c					if DEBUG_FORTH_WORDS_KEY 
3c4c						DMARK "0=." 
3c4c f5				push af  
3c4d 3a 61 3c			ld a, (.dmark)  
3c50 32 a6 fd			ld (debug_mark),a  
3c53 3a 62 3c			ld a, (.dmark+1)  
3c56 32 a7 fd			ld (debug_mark+1),a  
3c59 3a 63 3c			ld a, (.dmark+2)  
3c5c 32 a8 fd			ld (debug_mark+2),a  
3c5f 18 03			jr .pastdmark  
3c61 ..			.dmark: db "0=."  
3c64 f1			.pastdmark: pop af  
3c65			endm  
# End of macro DMARK
3c65						CALLMONITOR 
3c65 cd aa fd			call debug_vector  
3c68				endm  
# End of macro CALLMONITOR
3c68					endif 
3c68					FORTH_DSP 
3c68 cd d8 24			call macro_forth_dsp 
3c6b				endm 
# End of macro FORTH_DSP
3c6b 7e					ld a,(hl)	; get type of value on TOS 
3c6c fe 02				cp DS_TYPE_INUM  
3c6e 28 00				jr z, .tz_inum 
3c70			 
3c70				if FORTH_ENABLE_FLOATMATH 
3c70					jr .tz_done 
3c70			 
3c70				endif 
3c70					 
3c70			 
3c70			.tz_inum: 
3c70					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c70 cd 12 25			call macro_dsp_valuehl 
3c73				endm 
# End of macro FORTH_DSP_VALUEHL
3c73			 
3c73			;		push hl 
3c73			 
3c73					; destroy value TOS 
3c73			 
3c73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c73 cd ca 25			call macro_forth_dsp_pop 
3c76				endm 
# End of macro FORTH_DSP_POP
3c76			 
3c76			;		pop hl 
3c76			 
3c76 3e 00				ld a,0 
3c78			 
3c78 bd					cp l 
3c79 20 08				jr nz, .tz_notzero 
3c7b			 
3c7b bc					cp h 
3c7c			 
3c7c 20 05				jr nz, .tz_notzero 
3c7e			 
3c7e			 
3c7e 21 01 00				ld hl, FORTH_TRUE 
3c81 18 03				jr .tz_done 
3c83			 
3c83 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3c86			 
3c86					; push value back onto stack for another op etc 
3c86			 
3c86			.tz_done: 
3c86 cd 1b 23				call forth_push_numhl 
3c89			 
3c89					NEXTW 
3c89 c3 c8 26			jp macro_next 
3c8c				endm 
# End of macro NEXTW
3c8c			.LESS: 
3c8c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3c8c 2f				db WORD_SYS_CORE+27             
3c8d f5 3c			dw .GT            
3c8f 02				db 1 + 1 
3c90 .. 00			db "<",0              
3c92				endm 
# End of macro CWHEAD
3c92			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3c92				; TODO add floating point number detection 
3c92					if DEBUG_FORTH_WORDS_KEY 
3c92						DMARK "LES" 
3c92 f5				push af  
3c93 3a a7 3c			ld a, (.dmark)  
3c96 32 a6 fd			ld (debug_mark),a  
3c99 3a a8 3c			ld a, (.dmark+1)  
3c9c 32 a7 fd			ld (debug_mark+1),a  
3c9f 3a a9 3c			ld a, (.dmark+2)  
3ca2 32 a8 fd			ld (debug_mark+2),a  
3ca5 18 03			jr .pastdmark  
3ca7 ..			.dmark: db "LES"  
3caa f1			.pastdmark: pop af  
3cab			endm  
# End of macro DMARK
3cab						CALLMONITOR 
3cab cd aa fd			call debug_vector  
3cae				endm  
# End of macro CALLMONITOR
3cae					endif 
3cae					FORTH_DSP 
3cae cd d8 24			call macro_forth_dsp 
3cb1				endm 
# End of macro FORTH_DSP
3cb1					;v5 FORTH_DSP_VALUE 
3cb1 7e					ld a,(hl)	; get type of value on TOS 
3cb2 fe 02				cp DS_TYPE_INUM  
3cb4 28 00				jr z, .less_inum 
3cb6			 
3cb6				if FORTH_ENABLE_FLOATMATH 
3cb6					jr .less_done 
3cb6			 
3cb6				endif 
3cb6					 
3cb6			 
3cb6			.less_inum: 
3cb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cb6 cd 12 25			call macro_dsp_valuehl 
3cb9				endm 
# End of macro FORTH_DSP_VALUEHL
3cb9			 
3cb9 e5					push hl  ; u2 
3cba			 
3cba					; destroy value TOS 
3cba			 
3cba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cba cd ca 25			call macro_forth_dsp_pop 
3cbd				endm 
# End of macro FORTH_DSP_POP
3cbd			 
3cbd			 
3cbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cbd cd 12 25			call macro_dsp_valuehl 
3cc0				endm 
# End of macro FORTH_DSP_VALUEHL
3cc0			 
3cc0 e5					push hl    ; u1 
3cc1			 
3cc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc1 cd ca 25			call macro_forth_dsp_pop 
3cc4				endm 
# End of macro FORTH_DSP_POP
3cc4			 
3cc4			 
3cc4 b7			 or a      ;clear carry flag 
3cc5 01 00 00		 ld bc, FORTH_FALSE 
3cc8 e1			  pop hl    ; u1 
3cc9 d1			  pop de    ; u2 
3cca ed 52		  sbc hl,de 
3ccc 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3cce			 
3cce 01 01 00		 ld bc, FORTH_TRUE 
3cd1			.lscont:  
3cd1 c5					push bc 
3cd2 e1					pop hl 
3cd3			 
3cd3					if DEBUG_FORTH_WORDS 
3cd3						DMARK "LT1" 
3cd3 f5				push af  
3cd4 3a e8 3c			ld a, (.dmark)  
3cd7 32 a6 fd			ld (debug_mark),a  
3cda 3a e9 3c			ld a, (.dmark+1)  
3cdd 32 a7 fd			ld (debug_mark+1),a  
3ce0 3a ea 3c			ld a, (.dmark+2)  
3ce3 32 a8 fd			ld (debug_mark+2),a  
3ce6 18 03			jr .pastdmark  
3ce8 ..			.dmark: db "LT1"  
3ceb f1			.pastdmark: pop af  
3cec			endm  
# End of macro DMARK
3cec						CALLMONITOR 
3cec cd aa fd			call debug_vector  
3cef				endm  
# End of macro CALLMONITOR
3cef					endif 
3cef cd 1b 23				call forth_push_numhl 
3cf2			 
3cf2					NEXTW 
3cf2 c3 c8 26			jp macro_next 
3cf5				endm 
# End of macro NEXTW
3cf5			.GT: 
3cf5				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3cf5 30				db WORD_SYS_CORE+28             
3cf6 5e 3d			dw .EQUAL            
3cf8 02				db 1 + 1 
3cf9 .. 00			db ">",0              
3cfb				endm 
# End of macro CWHEAD
3cfb			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3cfb				; TODO add floating point number detection 
3cfb					if DEBUG_FORTH_WORDS_KEY 
3cfb						DMARK "GRT" 
3cfb f5				push af  
3cfc 3a 10 3d			ld a, (.dmark)  
3cff 32 a6 fd			ld (debug_mark),a  
3d02 3a 11 3d			ld a, (.dmark+1)  
3d05 32 a7 fd			ld (debug_mark+1),a  
3d08 3a 12 3d			ld a, (.dmark+2)  
3d0b 32 a8 fd			ld (debug_mark+2),a  
3d0e 18 03			jr .pastdmark  
3d10 ..			.dmark: db "GRT"  
3d13 f1			.pastdmark: pop af  
3d14			endm  
# End of macro DMARK
3d14						CALLMONITOR 
3d14 cd aa fd			call debug_vector  
3d17				endm  
# End of macro CALLMONITOR
3d17					endif 
3d17					FORTH_DSP 
3d17 cd d8 24			call macro_forth_dsp 
3d1a				endm 
# End of macro FORTH_DSP
3d1a					;FORTH_DSP_VALUE 
3d1a 7e					ld a,(hl)	; get type of value on TOS 
3d1b fe 02				cp DS_TYPE_INUM  
3d1d 28 00				jr z, .gt_inum 
3d1f			 
3d1f				if FORTH_ENABLE_FLOATMATH 
3d1f					jr .gt_done 
3d1f			 
3d1f				endif 
3d1f					 
3d1f			 
3d1f			.gt_inum: 
3d1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d1f cd 12 25			call macro_dsp_valuehl 
3d22				endm 
# End of macro FORTH_DSP_VALUEHL
3d22			 
3d22 e5					push hl  ; u2 
3d23			 
3d23					; destroy value TOS 
3d23			 
3d23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d23 cd ca 25			call macro_forth_dsp_pop 
3d26				endm 
# End of macro FORTH_DSP_POP
3d26			 
3d26			 
3d26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d26 cd 12 25			call macro_dsp_valuehl 
3d29				endm 
# End of macro FORTH_DSP_VALUEHL
3d29			 
3d29 e5					push hl    ; u1 
3d2a			 
3d2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d2a cd ca 25			call macro_forth_dsp_pop 
3d2d				endm 
# End of macro FORTH_DSP_POP
3d2d			 
3d2d			 
3d2d b7			 or a      ;clear carry flag 
3d2e 01 00 00		 ld bc, FORTH_FALSE 
3d31 e1			  pop hl    ; u1 
3d32 d1			  pop de    ; u2 
3d33 ed 52		  sbc hl,de 
3d35 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3d37			 
3d37 01 01 00		 ld bc, FORTH_TRUE 
3d3a			.gtcont:  
3d3a c5					push bc 
3d3b e1					pop hl 
3d3c			 
3d3c					if DEBUG_FORTH_WORDS 
3d3c						DMARK "GT1" 
3d3c f5				push af  
3d3d 3a 51 3d			ld a, (.dmark)  
3d40 32 a6 fd			ld (debug_mark),a  
3d43 3a 52 3d			ld a, (.dmark+1)  
3d46 32 a7 fd			ld (debug_mark+1),a  
3d49 3a 53 3d			ld a, (.dmark+2)  
3d4c 32 a8 fd			ld (debug_mark+2),a  
3d4f 18 03			jr .pastdmark  
3d51 ..			.dmark: db "GT1"  
3d54 f1			.pastdmark: pop af  
3d55			endm  
# End of macro DMARK
3d55						CALLMONITOR 
3d55 cd aa fd			call debug_vector  
3d58				endm  
# End of macro CALLMONITOR
3d58					endif 
3d58 cd 1b 23				call forth_push_numhl 
3d5b			 
3d5b					NEXTW 
3d5b c3 c8 26			jp macro_next 
3d5e				endm 
# End of macro NEXTW
3d5e			.EQUAL: 
3d5e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3d5e 31				db WORD_SYS_CORE+29             
3d5f c9 3d			dw .ENDLOGIC            
3d61 02				db 1 + 1 
3d62 .. 00			db "=",0              
3d64				endm 
# End of macro CWHEAD
3d64			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3d64				; TODO add floating point number detection 
3d64					if DEBUG_FORTH_WORDS_KEY 
3d64						DMARK "EQ." 
3d64 f5				push af  
3d65 3a 79 3d			ld a, (.dmark)  
3d68 32 a6 fd			ld (debug_mark),a  
3d6b 3a 7a 3d			ld a, (.dmark+1)  
3d6e 32 a7 fd			ld (debug_mark+1),a  
3d71 3a 7b 3d			ld a, (.dmark+2)  
3d74 32 a8 fd			ld (debug_mark+2),a  
3d77 18 03			jr .pastdmark  
3d79 ..			.dmark: db "EQ."  
3d7c f1			.pastdmark: pop af  
3d7d			endm  
# End of macro DMARK
3d7d						CALLMONITOR 
3d7d cd aa fd			call debug_vector  
3d80				endm  
# End of macro CALLMONITOR
3d80					endif 
3d80					FORTH_DSP 
3d80 cd d8 24			call macro_forth_dsp 
3d83				endm 
# End of macro FORTH_DSP
3d83					;v5 FORTH_DSP_VALUE 
3d83 7e					ld a,(hl)	; get type of value on TOS 
3d84 fe 02				cp DS_TYPE_INUM  
3d86 28 00				jr z, .eq_inum 
3d88			 
3d88				if FORTH_ENABLE_FLOATMATH 
3d88					jr .eq_done 
3d88			 
3d88				endif 
3d88					 
3d88			 
3d88			.eq_inum: 
3d88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d88 cd 12 25			call macro_dsp_valuehl 
3d8b				endm 
# End of macro FORTH_DSP_VALUEHL
3d8b			 
3d8b e5					push hl 
3d8c			 
3d8c					; destroy value TOS 
3d8c			 
3d8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8c cd ca 25			call macro_forth_dsp_pop 
3d8f				endm 
# End of macro FORTH_DSP_POP
3d8f			 
3d8f			 
3d8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8f cd 12 25			call macro_dsp_valuehl 
3d92				endm 
# End of macro FORTH_DSP_VALUEHL
3d92			 
3d92					; one value on hl get other one back 
3d92			 
3d92 e5					push hl 
3d93			 
3d93					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d93 cd ca 25			call macro_forth_dsp_pop 
3d96				endm 
# End of macro FORTH_DSP_POP
3d96			 
3d96 0e 00				ld c, FORTH_FALSE 
3d98			 
3d98 e1					pop hl 
3d99 d1					pop de 
3d9a			 
3d9a 7b					ld a, e 
3d9b bd					cp l 
3d9c			 
3d9c 20 06				jr nz, .eq_done 
3d9e			 
3d9e 7a					ld a, d 
3d9f bc					cp h 
3da0			 
3da0 20 02				jr nz, .eq_done 
3da2			 
3da2 0e 01				ld c, FORTH_TRUE 
3da4					 
3da4			 
3da4			 
3da4			.eq_done: 
3da4			 
3da4					; TODO push value back onto stack for another op etc 
3da4			 
3da4 26 00				ld h, 0 
3da6 69					ld l, c 
3da7					if DEBUG_FORTH_WORDS 
3da7						DMARK "EQ1" 
3da7 f5				push af  
3da8 3a bc 3d			ld a, (.dmark)  
3dab 32 a6 fd			ld (debug_mark),a  
3dae 3a bd 3d			ld a, (.dmark+1)  
3db1 32 a7 fd			ld (debug_mark+1),a  
3db4 3a be 3d			ld a, (.dmark+2)  
3db7 32 a8 fd			ld (debug_mark+2),a  
3dba 18 03			jr .pastdmark  
3dbc ..			.dmark: db "EQ1"  
3dbf f1			.pastdmark: pop af  
3dc0			endm  
# End of macro DMARK
3dc0						CALLMONITOR 
3dc0 cd aa fd			call debug_vector  
3dc3				endm  
# End of macro CALLMONITOR
3dc3					endif 
3dc3 cd 1b 23				call forth_push_numhl 
3dc6			 
3dc6					NEXTW 
3dc6 c3 c8 26			jp macro_next 
3dc9				endm 
# End of macro NEXTW
3dc9			 
3dc9			 
3dc9			.ENDLOGIC: 
3dc9			; eof 
3dc9			 
3dc9			 
# End of file forth_words_logic.asm
3dc9			include "forth_words_maths.asm" 
3dc9			 
3dc9			; | ## Maths Words 
3dc9			 
3dc9			.PLUS:	 
3dc9				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3dc9 15				db WORD_SYS_CORE+1             
3dca 27 3e			dw .NEG            
3dcc 02				db 1 + 1 
3dcd .. 00			db "+",0              
3dcf				endm 
# End of macro CWHEAD
3dcf			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3dcf					if DEBUG_FORTH_WORDS_KEY 
3dcf						DMARK "PLU" 
3dcf f5				push af  
3dd0 3a e4 3d			ld a, (.dmark)  
3dd3 32 a6 fd			ld (debug_mark),a  
3dd6 3a e5 3d			ld a, (.dmark+1)  
3dd9 32 a7 fd			ld (debug_mark+1),a  
3ddc 3a e6 3d			ld a, (.dmark+2)  
3ddf 32 a8 fd			ld (debug_mark+2),a  
3de2 18 03			jr .pastdmark  
3de4 ..			.dmark: db "PLU"  
3de7 f1			.pastdmark: pop af  
3de8			endm  
# End of macro DMARK
3de8						CALLMONITOR 
3de8 cd aa fd			call debug_vector  
3deb				endm  
# End of macro CALLMONITOR
3deb					endif 
3deb					; add top two values and push back result 
3deb			 
3deb					;for v5 FORTH_DSP_VALUE 
3deb					FORTH_DSP 
3deb cd d8 24			call macro_forth_dsp 
3dee				endm 
# End of macro FORTH_DSP
3dee 7e					ld a,(hl)	; get type of value on TOS 
3def fe 02				cp DS_TYPE_INUM  
3df1 28 03				jr z, .dot_inum 
3df3			 
3df3					NEXTW 
3df3 c3 c8 26			jp macro_next 
3df6				endm 
# End of macro NEXTW
3df6			 
3df6			; float maths 
3df6			 
3df6				if FORTH_ENABLE_FLOATMATH 
3df6						inc hl      ; now at start of numeric as string 
3df6			 
3df6					if DEBUG_FORTH_MATHS 
3df6						DMARK "ADD" 
3df6				CALLMONITOR 
3df6					endif 
3df6			 
3df6					;ld ix, hl 
3df6					call CON 
3df6			 
3df6			 
3df6					push hl 
3df6					 
3df6					 
3df6			 
3df6						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3df6			 
3df6					; get next number 
3df6			 
3df6						FORTH_DSP_VALUE 
3df6			 
3df6						inc hl      ; now at start of numeric as string 
3df6			 
3df6					;ld ix, hl 
3df6					call CON 
3df6			 
3df6					push hl 
3df6			 
3df6			 
3df6						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df6			 
3df6						; TODO do add 
3df6			 
3df6						call IADD 
3df6			 
3df6						; TODO get result back as ascii 
3df6			 
3df6						; TODO push result  
3df6			 
3df6			 
3df6			 
3df6						jr .dot_done 
3df6				endif 
3df6			 
3df6			.dot_inum: 
3df6			 
3df6			 
3df6					if DEBUG_FORTH_DOT 
3df6						DMARK "+IT" 
3df6 f5				push af  
3df7 3a 0b 3e			ld a, (.dmark)  
3dfa 32 a6 fd			ld (debug_mark),a  
3dfd 3a 0c 3e			ld a, (.dmark+1)  
3e00 32 a7 fd			ld (debug_mark+1),a  
3e03 3a 0d 3e			ld a, (.dmark+2)  
3e06 32 a8 fd			ld (debug_mark+2),a  
3e09 18 03			jr .pastdmark  
3e0b ..			.dmark: db "+IT"  
3e0e f1			.pastdmark: pop af  
3e0f			endm  
# End of macro DMARK
3e0f				CALLMONITOR 
3e0f cd aa fd			call debug_vector  
3e12				endm  
# End of macro CALLMONITOR
3e12					endif 
3e12			 
3e12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e12 cd 12 25			call macro_dsp_valuehl 
3e15				endm 
# End of macro FORTH_DSP_VALUEHL
3e15			 
3e15				; TODO add floating point number detection 
3e15			 
3e15 e5					push hl 
3e16			 
3e16					; destroy value TOS 
3e16			 
3e16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e16 cd ca 25			call macro_forth_dsp_pop 
3e19				endm 
# End of macro FORTH_DSP_POP
3e19			 
3e19			 
3e19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e19 cd 12 25			call macro_dsp_valuehl 
3e1c				endm 
# End of macro FORTH_DSP_VALUEHL
3e1c			 
3e1c					; one value on hl get other one back 
3e1c			 
3e1c d1					pop de 
3e1d			 
3e1d					; do the add 
3e1d			 
3e1d 19					add hl,de 
3e1e			 
3e1e					; save it 
3e1e			 
3e1e			;		push hl	 
3e1e			 
3e1e					; 
3e1e			 
3e1e					; destroy value TOS 
3e1e			 
3e1e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e1e cd ca 25			call macro_forth_dsp_pop 
3e21				endm 
# End of macro FORTH_DSP_POP
3e21			 
3e21					; TODO push value back onto stack for another op etc 
3e21			 
3e21			;		pop hl 
3e21			 
3e21			.dot_done: 
3e21 cd 1b 23				call forth_push_numhl 
3e24			 
3e24					NEXTW 
3e24 c3 c8 26			jp macro_next 
3e27				endm 
# End of macro NEXTW
3e27			.NEG: 
3e27			 
3e27				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3e27 17				db WORD_SYS_CORE+3             
3e28 6a 3e			dw .DIV            
3e2a 02				db 1 + 1 
3e2b .. 00			db "-",0              
3e2d				endm 
# End of macro CWHEAD
3e2d			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3e2d					if DEBUG_FORTH_WORDS_KEY 
3e2d						DMARK "SUB" 
3e2d f5				push af  
3e2e 3a 42 3e			ld a, (.dmark)  
3e31 32 a6 fd			ld (debug_mark),a  
3e34 3a 43 3e			ld a, (.dmark+1)  
3e37 32 a7 fd			ld (debug_mark+1),a  
3e3a 3a 44 3e			ld a, (.dmark+2)  
3e3d 32 a8 fd			ld (debug_mark+2),a  
3e40 18 03			jr .pastdmark  
3e42 ..			.dmark: db "SUB"  
3e45 f1			.pastdmark: pop af  
3e46			endm  
# End of macro DMARK
3e46						CALLMONITOR 
3e46 cd aa fd			call debug_vector  
3e49				endm  
# End of macro CALLMONITOR
3e49					endif 
3e49			 
3e49			 
3e49				; TODO add floating point number detection 
3e49					; v5 FORTH_DSP_VALUE 
3e49					FORTH_DSP 
3e49 cd d8 24			call macro_forth_dsp 
3e4c				endm 
# End of macro FORTH_DSP
3e4c 7e					ld a,(hl)	; get type of value on TOS 
3e4d fe 02				cp DS_TYPE_INUM  
3e4f 28 03				jr z, .neg_inum 
3e51			 
3e51					NEXTW 
3e51 c3 c8 26			jp macro_next 
3e54				endm 
# End of macro NEXTW
3e54			 
3e54			; float maths 
3e54			 
3e54				if FORTH_ENABLE_FLOATMATH 
3e54					jr .neg_done 
3e54			 
3e54				endif 
3e54					 
3e54			 
3e54			.neg_inum: 
3e54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e54 cd 12 25			call macro_dsp_valuehl 
3e57				endm 
# End of macro FORTH_DSP_VALUEHL
3e57			 
3e57 e5					push hl 
3e58			 
3e58					; destroy value TOS 
3e58			 
3e58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e58 cd ca 25			call macro_forth_dsp_pop 
3e5b				endm 
# End of macro FORTH_DSP_POP
3e5b			 
3e5b			 
3e5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e5b cd 12 25			call macro_dsp_valuehl 
3e5e				endm 
# End of macro FORTH_DSP_VALUEHL
3e5e			 
3e5e					; one value on hl get other one back 
3e5e			 
3e5e d1					pop de 
3e5f			 
3e5f					; do the sub 
3e5f			;		ex de, hl 
3e5f			 
3e5f ed 52				sbc hl,de 
3e61			 
3e61					; save it 
3e61			 
3e61			;		push hl	 
3e61			 
3e61					; 
3e61			 
3e61					; destroy value TOS 
3e61			 
3e61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e61 cd ca 25			call macro_forth_dsp_pop 
3e64				endm 
# End of macro FORTH_DSP_POP
3e64			 
3e64					; TODO push value back onto stack for another op etc 
3e64			 
3e64			;		pop hl 
3e64			 
3e64 cd 1b 23				call forth_push_numhl 
3e67			.neg_done: 
3e67			 
3e67					NEXTW 
3e67 c3 c8 26			jp macro_next 
3e6a				endm 
# End of macro NEXTW
3e6a			.DIV: 
3e6a				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3e6a 18				db WORD_SYS_CORE+4             
3e6b b7 3e			dw .MUL            
3e6d 02				db 1 + 1 
3e6e .. 00			db "/",0              
3e70				endm 
# End of macro CWHEAD
3e70			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3e70					if DEBUG_FORTH_WORDS_KEY 
3e70						DMARK "DIV" 
3e70 f5				push af  
3e71 3a 85 3e			ld a, (.dmark)  
3e74 32 a6 fd			ld (debug_mark),a  
3e77 3a 86 3e			ld a, (.dmark+1)  
3e7a 32 a7 fd			ld (debug_mark+1),a  
3e7d 3a 87 3e			ld a, (.dmark+2)  
3e80 32 a8 fd			ld (debug_mark+2),a  
3e83 18 03			jr .pastdmark  
3e85 ..			.dmark: db "DIV"  
3e88 f1			.pastdmark: pop af  
3e89			endm  
# End of macro DMARK
3e89						CALLMONITOR 
3e89 cd aa fd			call debug_vector  
3e8c				endm  
# End of macro CALLMONITOR
3e8c					endif 
3e8c				; TODO add floating point number detection 
3e8c					; v5 FORTH_DSP_VALUE 
3e8c					FORTH_DSP 
3e8c cd d8 24			call macro_forth_dsp 
3e8f				endm 
# End of macro FORTH_DSP
3e8f 7e					ld a,(hl)	; get type of value on TOS 
3e90 fe 02				cp DS_TYPE_INUM  
3e92 28 03				jr z, .div_inum 
3e94			 
3e94				if FORTH_ENABLE_FLOATMATH 
3e94					jr .div_done 
3e94			 
3e94				endif 
3e94					NEXTW 
3e94 c3 c8 26			jp macro_next 
3e97				endm 
# End of macro NEXTW
3e97			.div_inum: 
3e97			 
3e97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e97 cd 12 25			call macro_dsp_valuehl 
3e9a				endm 
# End of macro FORTH_DSP_VALUEHL
3e9a			 
3e9a e5					push hl    ; to go to bc 
3e9b			 
3e9b					; destroy value TOS 
3e9b			 
3e9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9b cd ca 25			call macro_forth_dsp_pop 
3e9e				endm 
# End of macro FORTH_DSP_POP
3e9e			 
3e9e			 
3e9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e9e cd 12 25			call macro_dsp_valuehl 
3ea1				endm 
# End of macro FORTH_DSP_VALUEHL
3ea1			 
3ea1					; hl to go to de 
3ea1			 
3ea1 e5					push hl 
3ea2			 
3ea2 c1					pop bc 
3ea3 d1					pop de		 
3ea4			 
3ea4			 
3ea4					if DEBUG_FORTH_MATHS 
3ea4						DMARK "DIV" 
3ea4				CALLMONITOR 
3ea4					endif 
3ea4					; one value on hl but move to a get other one back 
3ea4			 
3ea4			        
3ea4 cd 2c 0f			call Div16 
3ea7			 
3ea7			;	push af	 
3ea7 e5				push hl 
3ea8 c5				push bc 
3ea9			 
3ea9					if DEBUG_FORTH_MATHS 
3ea9						DMARK "DI1" 
3ea9				CALLMONITOR 
3ea9					endif 
3ea9			 
3ea9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea9 cd ca 25			call macro_forth_dsp_pop 
3eac				endm 
# End of macro FORTH_DSP_POP
3eac			 
3eac			 
3eac			 
3eac e1					pop hl    ; result 
3ead			 
3ead cd 1b 23				call forth_push_numhl 
3eb0			 
3eb0 e1					pop hl    ; reminder 
3eb1			;		ld h,0 
3eb1			;		ld l,d 
3eb1			 
3eb1 cd 1b 23				call forth_push_numhl 
3eb4			.div_done: 
3eb4					NEXTW 
3eb4 c3 c8 26			jp macro_next 
3eb7				endm 
# End of macro NEXTW
3eb7			.MUL: 
3eb7				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3eb7 19				db WORD_SYS_CORE+5             
3eb8 fc 3e			dw .MIN            
3eba 02				db 1 + 1 
3ebb .. 00			db "*",0              
3ebd				endm 
# End of macro CWHEAD
3ebd			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3ebd				; TODO add floating point number detection 
3ebd					if DEBUG_FORTH_WORDS_KEY 
3ebd						DMARK "MUL" 
3ebd f5				push af  
3ebe 3a d2 3e			ld a, (.dmark)  
3ec1 32 a6 fd			ld (debug_mark),a  
3ec4 3a d3 3e			ld a, (.dmark+1)  
3ec7 32 a7 fd			ld (debug_mark+1),a  
3eca 3a d4 3e			ld a, (.dmark+2)  
3ecd 32 a8 fd			ld (debug_mark+2),a  
3ed0 18 03			jr .pastdmark  
3ed2 ..			.dmark: db "MUL"  
3ed5 f1			.pastdmark: pop af  
3ed6			endm  
# End of macro DMARK
3ed6						CALLMONITOR 
3ed6 cd aa fd			call debug_vector  
3ed9				endm  
# End of macro CALLMONITOR
3ed9					endif 
3ed9					FORTH_DSP 
3ed9 cd d8 24			call macro_forth_dsp 
3edc				endm 
# End of macro FORTH_DSP
3edc					; v5 FORTH_DSP_VALUE 
3edc 7e					ld a,(hl)	; get type of value on TOS 
3edd fe 02				cp DS_TYPE_INUM  
3edf 28 03				jr z, .mul_inum 
3ee1			 
3ee1				if FORTH_ENABLE_FLOATMATH 
3ee1					jr .mul_done 
3ee1			 
3ee1				endif 
3ee1			 
3ee1					NEXTW 
3ee1 c3 c8 26			jp macro_next 
3ee4				endm 
# End of macro NEXTW
3ee4			.mul_inum:	 
3ee4			 
3ee4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee4 cd 12 25			call macro_dsp_valuehl 
3ee7				endm 
# End of macro FORTH_DSP_VALUEHL
3ee7			 
3ee7 e5					push hl 
3ee8			 
3ee8					; destroy value TOS 
3ee8			 
3ee8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee8 cd ca 25			call macro_forth_dsp_pop 
3eeb				endm 
# End of macro FORTH_DSP_POP
3eeb			 
3eeb			 
3eeb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eeb cd 12 25			call macro_dsp_valuehl 
3eee				endm 
# End of macro FORTH_DSP_VALUEHL
3eee			 
3eee					; one value on hl but move to a get other one back 
3eee			 
3eee 7d					ld a, l 
3eef			 
3eef d1					pop de 
3ef0			 
3ef0					; do the mull 
3ef0			;		ex de, hl 
3ef0			 
3ef0 cd 52 0f				call Mult16 
3ef3					; save it 
3ef3			 
3ef3			;		push hl	 
3ef3			 
3ef3					; 
3ef3			 
3ef3					; destroy value TOS 
3ef3			 
3ef3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef3 cd ca 25			call macro_forth_dsp_pop 
3ef6				endm 
# End of macro FORTH_DSP_POP
3ef6			 
3ef6					; TODO push value back onto stack for another op etc 
3ef6			 
3ef6			;		pop hl 
3ef6			 
3ef6 cd 1b 23				call forth_push_numhl 
3ef9			 
3ef9			.mul_done: 
3ef9					NEXTW 
3ef9 c3 c8 26			jp macro_next 
3efc				endm 
# End of macro NEXTW
3efc			 
3efc			 
3efc			 
3efc			 
3efc			.MIN: 
3efc				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3efc 49				db WORD_SYS_CORE+53             
3efd 7d 3f			dw .MAX            
3eff 04				db 3 + 1 
3f00 .. 00			db "MIN",0              
3f04				endm 
# End of macro CWHEAD
3f04			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3f04					if DEBUG_FORTH_WORDS_KEY 
3f04						DMARK "MIN" 
3f04 f5				push af  
3f05 3a 19 3f			ld a, (.dmark)  
3f08 32 a6 fd			ld (debug_mark),a  
3f0b 3a 1a 3f			ld a, (.dmark+1)  
3f0e 32 a7 fd			ld (debug_mark+1),a  
3f11 3a 1b 3f			ld a, (.dmark+2)  
3f14 32 a8 fd			ld (debug_mark+2),a  
3f17 18 03			jr .pastdmark  
3f19 ..			.dmark: db "MIN"  
3f1c f1			.pastdmark: pop af  
3f1d			endm  
# End of macro DMARK
3f1d						CALLMONITOR 
3f1d cd aa fd			call debug_vector  
3f20				endm  
# End of macro CALLMONITOR
3f20					endif 
3f20					; get u2 
3f20			 
3f20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f20 cd 12 25			call macro_dsp_valuehl 
3f23				endm 
# End of macro FORTH_DSP_VALUEHL
3f23			 
3f23 e5					push hl   ; u2 
3f24			 
3f24					; destroy value TOS 
3f24			 
3f24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f24 cd ca 25			call macro_forth_dsp_pop 
3f27				endm 
# End of macro FORTH_DSP_POP
3f27			 
3f27					; get u1 
3f27			 
3f27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f27 cd 12 25			call macro_dsp_valuehl 
3f2a				endm 
# End of macro FORTH_DSP_VALUEHL
3f2a			 
3f2a e5					push hl  ; u1 
3f2b			 
3f2b					; destroy value TOS 
3f2b			 
3f2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f2b cd ca 25			call macro_forth_dsp_pop 
3f2e				endm 
# End of macro FORTH_DSP_POP
3f2e			 
3f2e b7			 or a      ;clear carry flag 
3f2f e1			  pop hl    ; u1 
3f30 d1			  pop de    ; u2 
3f31 e5				push hl   ; saved in case hl is lowest 
3f32 ed 52		  sbc hl,de 
3f34 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3f36			 
3f36 e1				pop hl 
3f37					if DEBUG_FORTH_WORDS 
3f37						DMARK "MIN" 
3f37 f5				push af  
3f38 3a 4c 3f			ld a, (.dmark)  
3f3b 32 a6 fd			ld (debug_mark),a  
3f3e 3a 4d 3f			ld a, (.dmark+1)  
3f41 32 a7 fd			ld (debug_mark+1),a  
3f44 3a 4e 3f			ld a, (.dmark+2)  
3f47 32 a8 fd			ld (debug_mark+2),a  
3f4a 18 03			jr .pastdmark  
3f4c ..			.dmark: db "MIN"  
3f4f f1			.pastdmark: pop af  
3f50			endm  
# End of macro DMARK
3f50						CALLMONITOR 
3f50 cd aa fd			call debug_vector  
3f53				endm  
# End of macro CALLMONITOR
3f53					endif 
3f53 cd 1b 23				call forth_push_numhl 
3f56			 
3f56				       NEXTW 
3f56 c3 c8 26			jp macro_next 
3f59				endm 
# End of macro NEXTW
3f59			 
3f59			.mincont:  
3f59 c1				pop bc   ; tidy up 
3f5a eb				ex de , hl  
3f5b					if DEBUG_FORTH_WORDS 
3f5b						DMARK "MI1" 
3f5b f5				push af  
3f5c 3a 70 3f			ld a, (.dmark)  
3f5f 32 a6 fd			ld (debug_mark),a  
3f62 3a 71 3f			ld a, (.dmark+1)  
3f65 32 a7 fd			ld (debug_mark+1),a  
3f68 3a 72 3f			ld a, (.dmark+2)  
3f6b 32 a8 fd			ld (debug_mark+2),a  
3f6e 18 03			jr .pastdmark  
3f70 ..			.dmark: db "MI1"  
3f73 f1			.pastdmark: pop af  
3f74			endm  
# End of macro DMARK
3f74						CALLMONITOR 
3f74 cd aa fd			call debug_vector  
3f77				endm  
# End of macro CALLMONITOR
3f77					endif 
3f77 cd 1b 23				call forth_push_numhl 
3f7a			 
3f7a				       NEXTW 
3f7a c3 c8 26			jp macro_next 
3f7d				endm 
# End of macro NEXTW
3f7d			.MAX: 
3f7d				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3f7d 4a				db WORD_SYS_CORE+54             
3f7e fe 3f			dw .RND16            
3f80 04				db 3 + 1 
3f81 .. 00			db "MAX",0              
3f85				endm 
# End of macro CWHEAD
3f85			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3f85					if DEBUG_FORTH_WORDS_KEY 
3f85						DMARK "MAX" 
3f85 f5				push af  
3f86 3a 9a 3f			ld a, (.dmark)  
3f89 32 a6 fd			ld (debug_mark),a  
3f8c 3a 9b 3f			ld a, (.dmark+1)  
3f8f 32 a7 fd			ld (debug_mark+1),a  
3f92 3a 9c 3f			ld a, (.dmark+2)  
3f95 32 a8 fd			ld (debug_mark+2),a  
3f98 18 03			jr .pastdmark  
3f9a ..			.dmark: db "MAX"  
3f9d f1			.pastdmark: pop af  
3f9e			endm  
# End of macro DMARK
3f9e						CALLMONITOR 
3f9e cd aa fd			call debug_vector  
3fa1				endm  
# End of macro CALLMONITOR
3fa1					endif 
3fa1					; get u2 
3fa1			 
3fa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa1 cd 12 25			call macro_dsp_valuehl 
3fa4				endm 
# End of macro FORTH_DSP_VALUEHL
3fa4			 
3fa4 e5					push hl   ; u2 
3fa5			 
3fa5					; destroy value TOS 
3fa5			 
3fa5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fa5 cd ca 25			call macro_forth_dsp_pop 
3fa8				endm 
# End of macro FORTH_DSP_POP
3fa8			 
3fa8					; get u1 
3fa8			 
3fa8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa8 cd 12 25			call macro_dsp_valuehl 
3fab				endm 
# End of macro FORTH_DSP_VALUEHL
3fab			 
3fab e5					push hl  ; u1 
3fac			 
3fac					; destroy value TOS 
3fac			 
3fac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fac cd ca 25			call macro_forth_dsp_pop 
3faf				endm 
# End of macro FORTH_DSP_POP
3faf			 
3faf b7			 or a      ;clear carry flag 
3fb0 e1			  pop hl    ; u1 
3fb1 d1			  pop de    ; u2 
3fb2 e5				push hl   ; saved in case hl is lowest 
3fb3 ed 52		  sbc hl,de 
3fb5 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3fb7			 
3fb7 e1				pop hl 
3fb8					if DEBUG_FORTH_WORDS 
3fb8						DMARK "MAX" 
3fb8 f5				push af  
3fb9 3a cd 3f			ld a, (.dmark)  
3fbc 32 a6 fd			ld (debug_mark),a  
3fbf 3a ce 3f			ld a, (.dmark+1)  
3fc2 32 a7 fd			ld (debug_mark+1),a  
3fc5 3a cf 3f			ld a, (.dmark+2)  
3fc8 32 a8 fd			ld (debug_mark+2),a  
3fcb 18 03			jr .pastdmark  
3fcd ..			.dmark: db "MAX"  
3fd0 f1			.pastdmark: pop af  
3fd1			endm  
# End of macro DMARK
3fd1						CALLMONITOR 
3fd1 cd aa fd			call debug_vector  
3fd4				endm  
# End of macro CALLMONITOR
3fd4					endif 
3fd4 cd 1b 23				call forth_push_numhl 
3fd7			 
3fd7				       NEXTW 
3fd7 c3 c8 26			jp macro_next 
3fda				endm 
# End of macro NEXTW
3fda			 
3fda			.maxcont:  
3fda c1				pop bc   ; tidy up 
3fdb eb				ex de , hl  
3fdc					if DEBUG_FORTH_WORDS 
3fdc						DMARK "MA1" 
3fdc f5				push af  
3fdd 3a f1 3f			ld a, (.dmark)  
3fe0 32 a6 fd			ld (debug_mark),a  
3fe3 3a f2 3f			ld a, (.dmark+1)  
3fe6 32 a7 fd			ld (debug_mark+1),a  
3fe9 3a f3 3f			ld a, (.dmark+2)  
3fec 32 a8 fd			ld (debug_mark+2),a  
3fef 18 03			jr .pastdmark  
3ff1 ..			.dmark: db "MA1"  
3ff4 f1			.pastdmark: pop af  
3ff5			endm  
# End of macro DMARK
3ff5						CALLMONITOR 
3ff5 cd aa fd			call debug_vector  
3ff8				endm  
# End of macro CALLMONITOR
3ff8					endif 
3ff8 cd 1b 23				call forth_push_numhl 
3ffb				       NEXTW 
3ffb c3 c8 26			jp macro_next 
3ffe				endm 
# End of macro NEXTW
3ffe			 
3ffe			.RND16: 
3ffe				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ffe 4e				db WORD_SYS_CORE+58             
3fff 2d 40			dw .RND8            
4001 06				db 5 + 1 
4002 .. 00			db "RND16",0              
4008				endm 
# End of macro CWHEAD
4008			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
4008					if DEBUG_FORTH_WORDS_KEY 
4008						DMARK "R16" 
4008 f5				push af  
4009 3a 1d 40			ld a, (.dmark)  
400c 32 a6 fd			ld (debug_mark),a  
400f 3a 1e 40			ld a, (.dmark+1)  
4012 32 a7 fd			ld (debug_mark+1),a  
4015 3a 1f 40			ld a, (.dmark+2)  
4018 32 a8 fd			ld (debug_mark+2),a  
401b 18 03			jr .pastdmark  
401d ..			.dmark: db "R16"  
4020 f1			.pastdmark: pop af  
4021			endm  
# End of macro DMARK
4021						CALLMONITOR 
4021 cd aa fd			call debug_vector  
4024				endm  
# End of macro CALLMONITOR
4024					endif 
4024 cd f6 0e				call prng16  
4027 cd 1b 23				call forth_push_numhl 
402a				       NEXTW 
402a c3 c8 26			jp macro_next 
402d				endm 
# End of macro NEXTW
402d			.RND8: 
402d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
402d 60				db WORD_SYS_CORE+76             
402e 62 40			dw .RND            
4030 05				db 4 + 1 
4031 .. 00			db "RND8",0              
4036				endm 
# End of macro CWHEAD
4036			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
4036					if DEBUG_FORTH_WORDS_KEY 
4036						DMARK "RN8" 
4036 f5				push af  
4037 3a 4b 40			ld a, (.dmark)  
403a 32 a6 fd			ld (debug_mark),a  
403d 3a 4c 40			ld a, (.dmark+1)  
4040 32 a7 fd			ld (debug_mark+1),a  
4043 3a 4d 40			ld a, (.dmark+2)  
4046 32 a8 fd			ld (debug_mark+2),a  
4049 18 03			jr .pastdmark  
404b ..			.dmark: db "RN8"  
404e f1			.pastdmark: pop af  
404f			endm  
# End of macro DMARK
404f						CALLMONITOR 
404f cd aa fd			call debug_vector  
4052				endm  
# End of macro CALLMONITOR
4052					endif 
4052 2a e4 fa				ld hl,(xrandc) 
4055 23					inc hl 
4056 cd 10 0f				call xrnd 
4059 6f					ld l,a	 
405a 26 00				ld h,0 
405c cd 1b 23				call forth_push_numhl 
405f				       NEXTW 
405f c3 c8 26			jp macro_next 
4062				endm 
# End of macro NEXTW
4062			.RND: 
4062				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
4062 60				db WORD_SYS_CORE+76             
4063 68 41			dw .ENDMATHS            
4065 04				db 3 + 1 
4066 .. 00			db "RND",0              
406a				endm 
# End of macro CWHEAD
406a			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
406a			 
406a					if DEBUG_FORTH_WORDS_KEY 
406a						DMARK "RND" 
406a f5				push af  
406b 3a 7f 40			ld a, (.dmark)  
406e 32 a6 fd			ld (debug_mark),a  
4071 3a 80 40			ld a, (.dmark+1)  
4074 32 a7 fd			ld (debug_mark+1),a  
4077 3a 81 40			ld a, (.dmark+2)  
407a 32 a8 fd			ld (debug_mark+2),a  
407d 18 03			jr .pastdmark  
407f ..			.dmark: db "RND"  
4082 f1			.pastdmark: pop af  
4083			endm  
# End of macro DMARK
4083						CALLMONITOR 
4083 cd aa fd			call debug_vector  
4086				endm  
# End of macro CALLMONITOR
4086					endif 
4086					 
4086					FORTH_DSP_VALUEHL    ; upper range 
4086 cd 12 25			call macro_dsp_valuehl 
4089				endm 
# End of macro FORTH_DSP_VALUEHL
4089			 
4089 22 e8 fa				ld (LFSRSeed), hl	 
408c			 
408c					if DEBUG_FORTH_WORDS 
408c						DMARK "RN1" 
408c f5				push af  
408d 3a a1 40			ld a, (.dmark)  
4090 32 a6 fd			ld (debug_mark),a  
4093 3a a2 40			ld a, (.dmark+1)  
4096 32 a7 fd			ld (debug_mark+1),a  
4099 3a a3 40			ld a, (.dmark+2)  
409c 32 a8 fd			ld (debug_mark+2),a  
409f 18 03			jr .pastdmark  
40a1 ..			.dmark: db "RN1"  
40a4 f1			.pastdmark: pop af  
40a5			endm  
# End of macro DMARK
40a5						CALLMONITOR 
40a5 cd aa fd			call debug_vector  
40a8				endm  
# End of macro CALLMONITOR
40a8					endif 
40a8					FORTH_DSP_POP 
40a8 cd ca 25			call macro_forth_dsp_pop 
40ab				endm 
# End of macro FORTH_DSP_POP
40ab			 
40ab					FORTH_DSP_VALUEHL    ; low range 
40ab cd 12 25			call macro_dsp_valuehl 
40ae				endm 
# End of macro FORTH_DSP_VALUEHL
40ae			 
40ae					if DEBUG_FORTH_WORDS 
40ae						DMARK "RN2" 
40ae f5				push af  
40af 3a c3 40			ld a, (.dmark)  
40b2 32 a6 fd			ld (debug_mark),a  
40b5 3a c4 40			ld a, (.dmark+1)  
40b8 32 a7 fd			ld (debug_mark+1),a  
40bb 3a c5 40			ld a, (.dmark+2)  
40be 32 a8 fd			ld (debug_mark+2),a  
40c1 18 03			jr .pastdmark  
40c3 ..			.dmark: db "RN2"  
40c6 f1			.pastdmark: pop af  
40c7			endm  
# End of macro DMARK
40c7						CALLMONITOR 
40c7 cd aa fd			call debug_vector  
40ca				endm  
# End of macro CALLMONITOR
40ca					endif 
40ca 22 ea fa				ld (LFSRSeed+2), hl 
40cd			 
40cd					FORTH_DSP_POP 
40cd cd ca 25			call macro_forth_dsp_pop 
40d0				endm 
# End of macro FORTH_DSP_POP
40d0			 
40d0 e5					push hl 
40d1			 
40d1 e1			.inrange:	pop hl 
40d2 cd f6 0e				call prng16  
40d5					if DEBUG_FORTH_WORDS 
40d5						DMARK "RN3" 
40d5 f5				push af  
40d6 3a ea 40			ld a, (.dmark)  
40d9 32 a6 fd			ld (debug_mark),a  
40dc 3a eb 40			ld a, (.dmark+1)  
40df 32 a7 fd			ld (debug_mark+1),a  
40e2 3a ec 40			ld a, (.dmark+2)  
40e5 32 a8 fd			ld (debug_mark+2),a  
40e8 18 03			jr .pastdmark  
40ea ..			.dmark: db "RN3"  
40ed f1			.pastdmark: pop af  
40ee			endm  
# End of macro DMARK
40ee						CALLMONITOR 
40ee cd aa fd			call debug_vector  
40f1				endm  
# End of macro CALLMONITOR
40f1					endif 
40f1					 
40f1					; if the range is 8bit knock out the high byte 
40f1			 
40f1 ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
40f5			 
40f5 3e 00				ld a, 0 
40f7 ba					cp d  
40f8 20 1e				jr nz, .hirange 
40fa 26 00				ld h, 0   ; knock it down to 8bit 
40fc			 
40fc					if DEBUG_FORTH_WORDS 
40fc						DMARK "RNk" 
40fc f5				push af  
40fd 3a 11 41			ld a, (.dmark)  
4100 32 a6 fd			ld (debug_mark),a  
4103 3a 12 41			ld a, (.dmark+1)  
4106 32 a7 fd			ld (debug_mark+1),a  
4109 3a 13 41			ld a, (.dmark+2)  
410c 32 a8 fd			ld (debug_mark+2),a  
410f 18 03			jr .pastdmark  
4111 ..			.dmark: db "RNk"  
4114 f1			.pastdmark: pop af  
4115			endm  
# End of macro DMARK
4115						CALLMONITOR 
4115 cd aa fd			call debug_vector  
4118				endm  
# End of macro CALLMONITOR
4118					endif 
4118			.hirange:   
4118 e5					push hl  
4119 b7					or a  
411a ed 52		                sbc hl, de 
411c			 
411c					;call cmp16 
411c			 
411c 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
411e e1					pop hl 
411f e5					push hl 
4120			 
4120					if DEBUG_FORTH_WORDS 
4120						DMARK "RN4" 
4120 f5				push af  
4121 3a 35 41			ld a, (.dmark)  
4124 32 a6 fd			ld (debug_mark),a  
4127 3a 36 41			ld a, (.dmark+1)  
412a 32 a7 fd			ld (debug_mark+1),a  
412d 3a 37 41			ld a, (.dmark+2)  
4130 32 a8 fd			ld (debug_mark+2),a  
4133 18 03			jr .pastdmark  
4135 ..			.dmark: db "RN4"  
4138 f1			.pastdmark: pop af  
4139			endm  
# End of macro DMARK
4139						CALLMONITOR 
4139 cd aa fd			call debug_vector  
413c				endm  
# End of macro CALLMONITOR
413c					endif 
413c ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
4140					;call cmp16 
4140				 
4140 b7					or a  
4141 ed 52		                sbc hl, de 
4143 38 8c				jr c, .inrange 
4145			 
4145 e1					pop hl 
4146					 
4146					if DEBUG_FORTH_WORDS 
4146						DMARK "RNd" 
4146 f5				push af  
4147 3a 5b 41			ld a, (.dmark)  
414a 32 a6 fd			ld (debug_mark),a  
414d 3a 5c 41			ld a, (.dmark+1)  
4150 32 a7 fd			ld (debug_mark+1),a  
4153 3a 5d 41			ld a, (.dmark+2)  
4156 32 a8 fd			ld (debug_mark+2),a  
4159 18 03			jr .pastdmark  
415b ..			.dmark: db "RNd"  
415e f1			.pastdmark: pop af  
415f			endm  
# End of macro DMARK
415f						CALLMONITOR 
415f cd aa fd			call debug_vector  
4162				endm  
# End of macro CALLMONITOR
4162					endif 
4162			 
4162			 
4162 cd 1b 23				call forth_push_numhl 
4165				       NEXTW 
4165 c3 c8 26			jp macro_next 
4168				endm 
# End of macro NEXTW
4168			 
4168			.ENDMATHS: 
4168			 
4168			; eof 
4168			 
# End of file forth_words_maths.asm
4168			include "forth_words_display.asm" 
4168			 
4168			; | ## Display Words 
4168			 
4168			.ACT: 
4168			 
4168				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
4168 62				db WORD_SYS_CORE+78             
4169 b4 41			dw .INFO            
416b 07				db 6 + 1 
416c .. 00			db "ACTIVE",0              
4173				endm 
# End of macro CWHEAD
4173			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
4173			;  
4173			; | | To display a pulsing activity indicator in a processing loop do this... 
4173			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
4173			 
4173					if DEBUG_FORTH_WORDS_KEY 
4173						DMARK "ACT" 
4173 f5				push af  
4174 3a 88 41			ld a, (.dmark)  
4177 32 a6 fd			ld (debug_mark),a  
417a 3a 89 41			ld a, (.dmark+1)  
417d 32 a7 fd			ld (debug_mark+1),a  
4180 3a 8a 41			ld a, (.dmark+2)  
4183 32 a8 fd			ld (debug_mark+2),a  
4186 18 03			jr .pastdmark  
4188 ..			.dmark: db "ACT"  
418b f1			.pastdmark: pop af  
418c			endm  
# End of macro DMARK
418c						CALLMONITOR 
418c cd aa fd			call debug_vector  
418f				endm  
# End of macro CALLMONITOR
418f					endif 
418f cd f2 0c				call active 
4192					if DEBUG_FORTH_WORDS 
4192						DMARK "ACp" 
4192 f5				push af  
4193 3a a7 41			ld a, (.dmark)  
4196 32 a6 fd			ld (debug_mark),a  
4199 3a a8 41			ld a, (.dmark+1)  
419c 32 a7 fd			ld (debug_mark+1),a  
419f 3a a9 41			ld a, (.dmark+2)  
41a2 32 a8 fd			ld (debug_mark+2),a  
41a5 18 03			jr .pastdmark  
41a7 ..			.dmark: db "ACp"  
41aa f1			.pastdmark: pop af  
41ab			endm  
# End of macro DMARK
41ab						CALLMONITOR 
41ab cd aa fd			call debug_vector  
41ae				endm  
# End of macro CALLMONITOR
41ae					endif 
41ae cd 89 23				call forth_push_str 
41b1			 
41b1					NEXTW 
41b1 c3 c8 26			jp macro_next 
41b4				endm 
# End of macro NEXTW
41b4			.INFO: 
41b4			 
41b4				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
41b4 62				db WORD_SYS_CORE+78             
41b5 d1 41			dw .ATP            
41b7 05				db 4 + 1 
41b8 .. 00			db "INFO",0              
41bd				endm 
# End of macro CWHEAD
41bd			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
41bd					FORTH_DSP_VALUEHL 
41bd cd 12 25			call macro_dsp_valuehl 
41c0				endm 
# End of macro FORTH_DSP_VALUEHL
41c0			 
41c0					FORTH_DSP_POP 
41c0 cd ca 25			call macro_forth_dsp_pop 
41c3				endm 
# End of macro FORTH_DSP_POP
41c3			 
41c3 e5					push hl 
41c4			 
41c4					FORTH_DSP_VALUEHL 
41c4 cd 12 25			call macro_dsp_valuehl 
41c7				endm 
# End of macro FORTH_DSP_VALUEHL
41c7			 
41c7					FORTH_DSP_POP 
41c7 cd ca 25			call macro_forth_dsp_pop 
41ca				endm 
# End of macro FORTH_DSP_POP
41ca			 
41ca d1					pop de 
41cb			 
41cb cd 2c 0d				call info_panel 
41ce			 
41ce			 
41ce					NEXTW 
41ce c3 c8 26			jp macro_next 
41d1				endm 
# End of macro NEXTW
41d1			.ATP: 
41d1				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
41d1 62				db WORD_SYS_CORE+78             
41d2 48 42			dw .FB            
41d4 04				db 3 + 1 
41d5 .. 00			db "AT?",0              
41d9				endm 
# End of macro CWHEAD
41d9			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
41d9					if DEBUG_FORTH_WORDS_KEY 
41d9						DMARK "AT?" 
41d9 f5				push af  
41da 3a ee 41			ld a, (.dmark)  
41dd 32 a6 fd			ld (debug_mark),a  
41e0 3a ef 41			ld a, (.dmark+1)  
41e3 32 a7 fd			ld (debug_mark+1),a  
41e6 3a f0 41			ld a, (.dmark+2)  
41e9 32 a8 fd			ld (debug_mark+2),a  
41ec 18 03			jr .pastdmark  
41ee ..			.dmark: db "AT?"  
41f1 f1			.pastdmark: pop af  
41f2			endm  
# End of macro DMARK
41f2						CALLMONITOR 
41f2 cd aa fd			call debug_vector  
41f5				endm  
# End of macro CALLMONITOR
41f5					endif 
41f5 3a 99 f9				ld a, (f_cursor_ptr) 
41f8			 
41f8			if DEBUG_FORTH_WORDS 
41f8				DMARK "AT?" 
41f8 f5				push af  
41f9 3a 0d 42			ld a, (.dmark)  
41fc 32 a6 fd			ld (debug_mark),a  
41ff 3a 0e 42			ld a, (.dmark+1)  
4202 32 a7 fd			ld (debug_mark+1),a  
4205 3a 0f 42			ld a, (.dmark+2)  
4208 32 a8 fd			ld (debug_mark+2),a  
420b 18 03			jr .pastdmark  
420d ..			.dmark: db "AT?"  
4210 f1			.pastdmark: pop af  
4211			endm  
# End of macro DMARK
4211				CALLMONITOR 
4211 cd aa fd			call debug_vector  
4214				endm  
# End of macro CALLMONITOR
4214			endif	 
4214					; count the number of rows 
4214			 
4214 06 00				ld b, 0 
4216 4f			.atpr:		ld c, a    ; save in case we go below zero 
4217 d6 28				sub display_cols 
4219 f2 1f 42				jp p, .atprunder 
421c 04					inc b 
421d 18 f7				jr .atpr 
421f			.atprunder:	 
421f			if DEBUG_FORTH_WORDS 
421f				DMARK "A?2" 
421f f5				push af  
4220 3a 34 42			ld a, (.dmark)  
4223 32 a6 fd			ld (debug_mark),a  
4226 3a 35 42			ld a, (.dmark+1)  
4229 32 a7 fd			ld (debug_mark+1),a  
422c 3a 36 42			ld a, (.dmark+2)  
422f 32 a8 fd			ld (debug_mark+2),a  
4232 18 03			jr .pastdmark  
4234 ..			.dmark: db "A?2"  
4237 f1			.pastdmark: pop af  
4238			endm  
# End of macro DMARK
4238				CALLMONITOR 
4238 cd aa fd			call debug_vector  
423b				endm  
# End of macro CALLMONITOR
423b			endif	 
423b 26 00				ld h, 0 
423d 69					ld l, c 
423e cd 1b 23				call forth_push_numhl 
4241 68					ld l, b  
4242 cd 1b 23				call forth_push_numhl 
4245			 
4245			 
4245				NEXTW 
4245 c3 c8 26			jp macro_next 
4248				endm 
# End of macro NEXTW
4248			 
4248			.FB: 
4248				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
4248 1b				db WORD_SYS_CORE+7             
4249 96 42			dw .EMIT            
424b 03				db 2 + 1 
424c .. 00			db "FB",0              
424f				endm 
# End of macro CWHEAD
424f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
424f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
424f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
424f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
424f					if DEBUG_FORTH_WORDS_KEY 
424f						DMARK "FB." 
424f f5				push af  
4250 3a 64 42			ld a, (.dmark)  
4253 32 a6 fd			ld (debug_mark),a  
4256 3a 65 42			ld a, (.dmark+1)  
4259 32 a7 fd			ld (debug_mark+1),a  
425c 3a 66 42			ld a, (.dmark+2)  
425f 32 a8 fd			ld (debug_mark+2),a  
4262 18 03			jr .pastdmark  
4264 ..			.dmark: db "FB."  
4267 f1			.pastdmark: pop af  
4268			endm  
# End of macro DMARK
4268						CALLMONITOR 
4268 cd aa fd			call debug_vector  
426b				endm  
# End of macro CALLMONITOR
426b					endif 
426b			 
426b					FORTH_DSP_VALUEHL 
426b cd 12 25			call macro_dsp_valuehl 
426e				endm 
# End of macro FORTH_DSP_VALUEHL
426e			 
426e 7d					ld a, l 
426f fe 01				cp 1 
4271 20 05				jr nz, .fbn1 
4273 21 4b fc				ld hl, display_fb1 
4276 18 15				jr .fbset 
4278 fe 02		.fbn1:		cp 2 
427a 20 05				jr nz, .fbn2 
427c 21 09 fb				ld hl, display_fb2 
427f 18 0c				jr .fbset 
4281 fe 03		.fbn2:		cp 3 
4283 20 05				jr nz, .fbn3 
4285 21 aa fb				ld hl, display_fb3 
4288 18 03				jr .fbset 
428a			.fbn3:		 ; if invalid number select first 
428a 21 4b fc				ld hl, display_fb1 
428d 22 07 fb		.fbset:		ld (display_fb_active), hl 
4290			 
4290					FORTH_DSP_POP 
4290 cd ca 25			call macro_forth_dsp_pop 
4293				endm 
# End of macro FORTH_DSP_POP
4293			 
4293					NEXTW 
4293 c3 c8 26			jp macro_next 
4296				endm 
# End of macro NEXTW
4296			 
4296			 
4296			.EMIT: 
4296				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4296 1b				db WORD_SYS_CORE+7             
4297 e7 42			dw .DOTH            
4299 05				db 4 + 1 
429a .. 00			db "EMIT",0              
429f				endm 
# End of macro CWHEAD
429f			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
429f					; get value off TOS and display it 
429f			 
429f					if DEBUG_FORTH_WORDS_KEY 
429f						DMARK "EMT" 
429f f5				push af  
42a0 3a b4 42			ld a, (.dmark)  
42a3 32 a6 fd			ld (debug_mark),a  
42a6 3a b5 42			ld a, (.dmark+1)  
42a9 32 a7 fd			ld (debug_mark+1),a  
42ac 3a b6 42			ld a, (.dmark+2)  
42af 32 a8 fd			ld (debug_mark+2),a  
42b2 18 03			jr .pastdmark  
42b4 ..			.dmark: db "EMT"  
42b7 f1			.pastdmark: pop af  
42b8			endm  
# End of macro DMARK
42b8						CALLMONITOR 
42b8 cd aa fd			call debug_vector  
42bb				endm  
# End of macro CALLMONITOR
42bb					endif 
42bb			 
42bb					FORTH_DSP_VALUEHL 
42bb cd 12 25			call macro_dsp_valuehl 
42be				endm 
# End of macro FORTH_DSP_VALUEHL
42be			 
42be 7d					ld a,l 
42bf			 
42bf					; TODO write to display 
42bf			 
42bf 32 fa f2				ld (os_input), a 
42c2 3e 00				ld a, 0 
42c4 32 fb f2				ld (os_input+1), a 
42c7					 
42c7 3a 99 f9				ld a, (f_cursor_ptr) 
42ca 11 fa f2				ld de, os_input 
42cd cd ae 0d				call str_at_display 
42d0			 
42d0			 
42d0 3a 77 f9				ld a,(cli_autodisplay) 
42d3 fe 00				cp 0 
42d5 28 03				jr z, .enoupdate 
42d7 cd be 0d						call update_display 
42da					.enoupdate: 
42da			 
42da 3a 99 f9				ld a, (f_cursor_ptr) 
42dd 3c					inc a 
42de 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
42e1			 
42e1			 
42e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42e1 cd ca 25			call macro_forth_dsp_pop 
42e4				endm 
# End of macro FORTH_DSP_POP
42e4			  
42e4			 
42e4					NEXTW 
42e4 c3 c8 26			jp macro_next 
42e7				endm 
# End of macro NEXTW
42e7			.DOTH: 
42e7				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
42e7 1c				db WORD_SYS_CORE+8             
42e8 17 43			dw .DOTF            
42ea 03				db 2 + 1 
42eb .. 00			db ".-",0              
42ee				endm 
# End of macro CWHEAD
42ee			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
42ee					; get value off TOS and display it 
42ee					if DEBUG_FORTH_WORDS_KEY 
42ee						DMARK "DTD" 
42ee f5				push af  
42ef 3a 03 43			ld a, (.dmark)  
42f2 32 a6 fd			ld (debug_mark),a  
42f5 3a 04 43			ld a, (.dmark+1)  
42f8 32 a7 fd			ld (debug_mark+1),a  
42fb 3a 05 43			ld a, (.dmark+2)  
42fe 32 a8 fd			ld (debug_mark+2),a  
4301 18 03			jr .pastdmark  
4303 ..			.dmark: db "DTD"  
4306 f1			.pastdmark: pop af  
4307			endm  
# End of macro DMARK
4307						CALLMONITOR 
4307 cd aa fd			call debug_vector  
430a				endm  
# End of macro CALLMONITOR
430a					endif 
430a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
430c 3e 00			ld a, 0 
430e 32 78 f9			ld (cli_mvdot), a 
4311 c3 6e 43			jp .dotgo 
4314				NEXTW 
4314 c3 c8 26			jp macro_next 
4317				endm 
# End of macro NEXTW
4317			.DOTF: 
4317				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4317 1c				db WORD_SYS_CORE+8             
4318 45 43			dw .DOT            
431a 03				db 2 + 1 
431b .. 00			db ".>",0              
431e				endm 
# End of macro CWHEAD
431e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
431e					; get value off TOS and display it 
431e			        ; TODO BUG adds extra spaces 
431e			        ; TODO BUG handle numerics? 
431e					if DEBUG_FORTH_WORDS_KEY 
431e						DMARK "DTC" 
431e f5				push af  
431f 3a 33 43			ld a, (.dmark)  
4322 32 a6 fd			ld (debug_mark),a  
4325 3a 34 43			ld a, (.dmark+1)  
4328 32 a7 fd			ld (debug_mark+1),a  
432b 3a 35 43			ld a, (.dmark+2)  
432e 32 a8 fd			ld (debug_mark+2),a  
4331 18 03			jr .pastdmark  
4333 ..			.dmark: db "DTC"  
4336 f1			.pastdmark: pop af  
4337			endm  
# End of macro DMARK
4337						CALLMONITOR 
4337 cd aa fd			call debug_vector  
433a				endm  
# End of macro CALLMONITOR
433a					endif 
433a 3e 01			ld a, 1 
433c 32 78 f9			ld (cli_mvdot), a 
433f c3 6e 43			jp .dotgo 
4342				NEXTW 
4342 c3 c8 26			jp macro_next 
4345				endm 
# End of macro NEXTW
4345			 
4345			.DOT: 
4345				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4345 1c				db WORD_SYS_CORE+8             
4346 21 45			dw .CLS            
4348 02				db 1 + 1 
4349 .. 00			db ".",0              
434b				endm 
# End of macro CWHEAD
434b			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
434b					; get value off TOS and display it 
434b			 
434b					if DEBUG_FORTH_WORDS_KEY 
434b						DMARK "DOT" 
434b f5				push af  
434c 3a 60 43			ld a, (.dmark)  
434f 32 a6 fd			ld (debug_mark),a  
4352 3a 61 43			ld a, (.dmark+1)  
4355 32 a7 fd			ld (debug_mark+1),a  
4358 3a 62 43			ld a, (.dmark+2)  
435b 32 a8 fd			ld (debug_mark+2),a  
435e 18 03			jr .pastdmark  
4360 ..			.dmark: db "DOT"  
4363 f1			.pastdmark: pop af  
4364			endm  
# End of macro DMARK
4364						CALLMONITOR 
4364 cd aa fd			call debug_vector  
4367				endm  
# End of macro CALLMONITOR
4367					endif 
4367 3e 00			ld a, 0 
4369 32 78 f9			ld (cli_mvdot), a 
436c 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
436e				 
436e			 
436e			.dotgo: 
436e			 
436e			; move up type to on stack for parserv5 
436e					FORTH_DSP 
436e cd d8 24			call macro_forth_dsp 
4371				endm 
# End of macro FORTH_DSP
4371				;FORTH_DSP_VALUE  
4371			 
4371			if DEBUG_FORTH_DOT 
4371				DMARK "DOT" 
4371 f5				push af  
4372 3a 86 43			ld a, (.dmark)  
4375 32 a6 fd			ld (debug_mark),a  
4378 3a 87 43			ld a, (.dmark+1)  
437b 32 a7 fd			ld (debug_mark+1),a  
437e 3a 88 43			ld a, (.dmark+2)  
4381 32 a8 fd			ld (debug_mark+2),a  
4384 18 03			jr .pastdmark  
4386 ..			.dmark: db "DOT"  
4389 f1			.pastdmark: pop af  
438a			endm  
# End of macro DMARK
438a				CALLMONITOR 
438a cd aa fd			call debug_vector  
438d				endm  
# End of macro CALLMONITOR
438d			endif	 
438d			;		.print: 
438d			 
438d 7e				ld a,(hl)  ; work out what type of value is on the TOS 
438e 23				inc hl   ; position to the actual value 
438f fe 01			cp DS_TYPE_STR 
4391 20 06			jr nz, .dotnum1  
4393			 
4393			; display string 
4393				FORTH_DSP_VALUE  
4393 cd fb 24			call macro_forth_dsp_value 
4396				endm 
# End of macro FORTH_DSP_VALUE
4396 eb				ex de,hl 
4397 18 49			jr .dotwrite 
4399			 
4399			.dotnum1: 
4399 fe 02			cp DS_TYPE_INUM 
439b 20 44			jr nz, .dotflot 
439d			 
439d			 
439d			; display number 
439d			 
439d			;	push hl 
439d			;	call clear_display 
439d			;	pop hl 
439d			 
439d 5e				ld e, (hl) 
439e 23				inc hl 
439f 56				ld d, (hl) 
43a0 21 fc f0			ld hl, scratch 
43a3			if DEBUG_FORTH_DOT 
43a3				DMARK "DT1" 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 a6 fd			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 a7 fd			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 a8 fd			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "DT1"  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc				CALLMONITOR 
43bc cd aa fd			call debug_vector  
43bf				endm  
# End of macro CALLMONITOR
43bf			endif	 
43bf			 
43bf cd f4 15			call uitoa_16 
43c2 eb				ex de,hl 
43c3			 
43c3			if DEBUG_FORTH_DOT 
43c3				DMARK "DT2" 
43c3 f5				push af  
43c4 3a d8 43			ld a, (.dmark)  
43c7 32 a6 fd			ld (debug_mark),a  
43ca 3a d9 43			ld a, (.dmark+1)  
43cd 32 a7 fd			ld (debug_mark+1),a  
43d0 3a da 43			ld a, (.dmark+2)  
43d3 32 a8 fd			ld (debug_mark+2),a  
43d6 18 03			jr .pastdmark  
43d8 ..			.dmark: db "DT2"  
43db f1			.pastdmark: pop af  
43dc			endm  
# End of macro DMARK
43dc				CALLMONITOR 
43dc cd aa fd			call debug_vector  
43df				endm  
# End of macro CALLMONITOR
43df			endif	 
43df			 
43df			;	ld de, os_word_scratch 
43df 18 01			jr .dotwrite 
43e1			 
43e1 00			.dotflot:   nop 
43e2			; TODO print floating point number 
43e2			 
43e2			.dotwrite:		 
43e2			 
43e2					; if c is set then set all '-' to spaces 
43e2					; need to also take into account .>  
43e2			 
43e2 3e 01				ld a, 1 
43e4 b9					cp c 
43e5 20 67				jr nz, .nodashswap 
43e7			 
43e7					; DE has the string to write, working with HL 
43e7			 
43e7 06 ff				ld b, 255 
43e9 d5					push de 
43ea e1					pop hl 
43eb			 
43eb			if DEBUG_FORTH_DOT 
43eb				DMARK "DT-" 
43eb f5				push af  
43ec 3a 00 44			ld a, (.dmark)  
43ef 32 a6 fd			ld (debug_mark),a  
43f2 3a 01 44			ld a, (.dmark+1)  
43f5 32 a7 fd			ld (debug_mark+1),a  
43f8 3a 02 44			ld a, (.dmark+2)  
43fb 32 a8 fd			ld (debug_mark+2),a  
43fe 18 03			jr .pastdmark  
4400 ..			.dmark: db "DT-"  
4403 f1			.pastdmark: pop af  
4404			endm  
# End of macro DMARK
4404				CALLMONITOR 
4404 cd aa fd			call debug_vector  
4407				endm  
# End of macro CALLMONITOR
4407			endif	 
4407 7e			.dashscan:	ld a, (hl) 
4408 fe 00				cp 0 
440a 28 42				jr z, .nodashswap 
440c fe 2d				cp '-' 
440e 20 03				jr nz, .dashskip 
4410 3e 20				ld a, ' ' 
4412 77					ld (hl), a 
4413 23			.dashskip:	inc hl 
4414			if DEBUG_FORTH_DOT 
4414				DMARK "D-2" 
4414 f5				push af  
4415 3a 29 44			ld a, (.dmark)  
4418 32 a6 fd			ld (debug_mark),a  
441b 3a 2a 44			ld a, (.dmark+1)  
441e 32 a7 fd			ld (debug_mark+1),a  
4421 3a 2b 44			ld a, (.dmark+2)  
4424 32 a8 fd			ld (debug_mark+2),a  
4427 18 03			jr .pastdmark  
4429 ..			.dmark: db "D-2"  
442c f1			.pastdmark: pop af  
442d			endm  
# End of macro DMARK
442d				CALLMONITOR 
442d cd aa fd			call debug_vector  
4430				endm  
# End of macro CALLMONITOR
4430			endif	 
4430 10 d5				djnz .dashscan 
4432			 
4432			if DEBUG_FORTH_DOT 
4432				DMARK "D-1" 
4432 f5				push af  
4433 3a 47 44			ld a, (.dmark)  
4436 32 a6 fd			ld (debug_mark),a  
4439 3a 48 44			ld a, (.dmark+1)  
443c 32 a7 fd			ld (debug_mark+1),a  
443f 3a 49 44			ld a, (.dmark+2)  
4442 32 a8 fd			ld (debug_mark+2),a  
4445 18 03			jr .pastdmark  
4447 ..			.dmark: db "D-1"  
444a f1			.pastdmark: pop af  
444b			endm  
# End of macro DMARK
444b				CALLMONITOR 
444b cd aa fd			call debug_vector  
444e				endm  
# End of macro CALLMONITOR
444e			endif	 
444e			 
444e			.nodashswap: 
444e			 
444e			if DEBUG_FORTH_DOT 
444e				DMARK "D-o" 
444e f5				push af  
444f 3a 63 44			ld a, (.dmark)  
4452 32 a6 fd			ld (debug_mark),a  
4455 3a 64 44			ld a, (.dmark+1)  
4458 32 a7 fd			ld (debug_mark+1),a  
445b 3a 65 44			ld a, (.dmark+2)  
445e 32 a8 fd			ld (debug_mark+2),a  
4461 18 03			jr .pastdmark  
4463 ..			.dmark: db "D-o"  
4466 f1			.pastdmark: pop af  
4467			endm  
# End of macro DMARK
4467				CALLMONITOR 
4467 cd aa fd			call debug_vector  
446a				endm  
# End of macro CALLMONITOR
446a			endif	 
446a			 
446a d5					push de   ; save string start in case we need to advance print 
446b			 
446b 3a 99 f9				ld a, (f_cursor_ptr) 
446e cd ae 0d				call str_at_display 
4471 3a 77 f9				ld a,(cli_autodisplay) 
4474 fe 00				cp 0 
4476 28 03				jr z, .noupdate 
4478 cd be 0d						call update_display 
447b					.noupdate: 
447b			 
447b			 
447b					; see if we need to advance the print position 
447b			 
447b e1					pop hl   ; get back string 
447c			;		ex de,hl 
447c			 
447c 3a 78 f9				ld a, (cli_mvdot) 
447f			if DEBUG_FORTH_DOT 
447f			;		ld e,a 
447f				DMARK "D>1" 
447f f5				push af  
4480 3a 94 44			ld a, (.dmark)  
4483 32 a6 fd			ld (debug_mark),a  
4486 3a 95 44			ld a, (.dmark+1)  
4489 32 a7 fd			ld (debug_mark+1),a  
448c 3a 96 44			ld a, (.dmark+2)  
448f 32 a8 fd			ld (debug_mark+2),a  
4492 18 03			jr .pastdmark  
4494 ..			.dmark: db "D>1"  
4497 f1			.pastdmark: pop af  
4498			endm  
# End of macro DMARK
4498				CALLMONITOR 
4498 cd aa fd			call debug_vector  
449b				endm  
# End of macro CALLMONITOR
449b			endif	 
449b fe 00				cp 0 
449d 28 44				jr z, .noadv 
449f					; yes, lets advance the print position 
449f 3e 00				ld a, 0 
44a1 cd 50 16				call strlent 
44a4			if DEBUG_FORTH_DOT 
44a4				DMARK "D-?" 
44a4 f5				push af  
44a5 3a b9 44			ld a, (.dmark)  
44a8 32 a6 fd			ld (debug_mark),a  
44ab 3a ba 44			ld a, (.dmark+1)  
44ae 32 a7 fd			ld (debug_mark+1),a  
44b1 3a bb 44			ld a, (.dmark+2)  
44b4 32 a8 fd			ld (debug_mark+2),a  
44b7 18 03			jr .pastdmark  
44b9 ..			.dmark: db "D-?"  
44bc f1			.pastdmark: pop af  
44bd			endm  
# End of macro DMARK
44bd				CALLMONITOR 
44bd cd aa fd			call debug_vector  
44c0				endm  
# End of macro CALLMONITOR
44c0			endif	 
44c0 3a 99 f9				ld a, (f_cursor_ptr) 
44c3 85					add a,l 
44c4					;call addatohl 
44c4					;ld a, l 
44c4 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
44c7			 
44c7			if DEBUG_FORTH_DOT 
44c7				DMARK "D->" 
44c7 f5				push af  
44c8 3a dc 44			ld a, (.dmark)  
44cb 32 a6 fd			ld (debug_mark),a  
44ce 3a dd 44			ld a, (.dmark+1)  
44d1 32 a7 fd			ld (debug_mark+1),a  
44d4 3a de 44			ld a, (.dmark+2)  
44d7 32 a8 fd			ld (debug_mark+2),a  
44da 18 03			jr .pastdmark  
44dc ..			.dmark: db "D->"  
44df f1			.pastdmark: pop af  
44e0			endm  
# End of macro DMARK
44e0				CALLMONITOR 
44e0 cd aa fd			call debug_vector  
44e3				endm  
# End of macro CALLMONITOR
44e3			endif	 
44e3			 
44e3			.noadv:	 
44e3			 
44e3					if DEBUG_FORTH_DOT_WAIT 
44e3							call next_page_prompt 
44e3					endif	 
44e3			; TODO this pop off the stack causes a crash. i dont know why 
44e3			 
44e3			 
44e3			if DEBUG_FORTH_DOT 
44e3				DMARK "DTh" 
44e3 f5				push af  
44e4 3a f8 44			ld a, (.dmark)  
44e7 32 a6 fd			ld (debug_mark),a  
44ea 3a f9 44			ld a, (.dmark+1)  
44ed 32 a7 fd			ld (debug_mark+1),a  
44f0 3a fa 44			ld a, (.dmark+2)  
44f3 32 a8 fd			ld (debug_mark+2),a  
44f6 18 03			jr .pastdmark  
44f8 ..			.dmark: db "DTh"  
44fb f1			.pastdmark: pop af  
44fc			endm  
# End of macro DMARK
44fc				CALLMONITOR 
44fc cd aa fd			call debug_vector  
44ff				endm  
# End of macro CALLMONITOR
44ff			endif	 
44ff			 
44ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44ff cd ca 25			call macro_forth_dsp_pop 
4502				endm 
# End of macro FORTH_DSP_POP
4502			 
4502			if DEBUG_FORTH_DOT 
4502				DMARK "DTi" 
4502 f5				push af  
4503 3a 17 45			ld a, (.dmark)  
4506 32 a6 fd			ld (debug_mark),a  
4509 3a 18 45			ld a, (.dmark+1)  
450c 32 a7 fd			ld (debug_mark+1),a  
450f 3a 19 45			ld a, (.dmark+2)  
4512 32 a8 fd			ld (debug_mark+2),a  
4515 18 03			jr .pastdmark  
4517 ..			.dmark: db "DTi"  
451a f1			.pastdmark: pop af  
451b			endm  
# End of macro DMARK
451b				CALLMONITOR 
451b cd aa fd			call debug_vector  
451e				endm  
# End of macro CALLMONITOR
451e			endif	 
451e			 
451e			 
451e					NEXTW 
451e c3 c8 26			jp macro_next 
4521				endm 
# End of macro NEXTW
4521			 
4521			.CLS: 
4521				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4521 35				db WORD_SYS_CORE+33             
4522 4e 45			dw .DRAW            
4524 04				db 3 + 1 
4525 .. 00			db "CLS",0              
4529				endm 
# End of macro CWHEAD
4529			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4529					if DEBUG_FORTH_WORDS_KEY 
4529						DMARK "CLS" 
4529 f5				push af  
452a 3a 3e 45			ld a, (.dmark)  
452d 32 a6 fd			ld (debug_mark),a  
4530 3a 3f 45			ld a, (.dmark+1)  
4533 32 a7 fd			ld (debug_mark+1),a  
4536 3a 40 45			ld a, (.dmark+2)  
4539 32 a8 fd			ld (debug_mark+2),a  
453c 18 03			jr .pastdmark  
453e ..			.dmark: db "CLS"  
4541 f1			.pastdmark: pop af  
4542			endm  
# End of macro DMARK
4542						CALLMONITOR 
4542 cd aa fd			call debug_vector  
4545				endm  
# End of macro CALLMONITOR
4545					endif 
4545 cd 9b 0d				call clear_display 
4548 c3 5c 46				jp .home		; and home cursor 
454b					NEXTW 
454b c3 c8 26			jp macro_next 
454e				endm 
# End of macro NEXTW
454e			 
454e			.DRAW: 
454e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
454e 36				db WORD_SYS_CORE+34             
454f 79 45			dw .DUMP            
4551 05				db 4 + 1 
4552 .. 00			db "DRAW",0              
4557				endm 
# End of macro CWHEAD
4557			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4557					if DEBUG_FORTH_WORDS_KEY 
4557						DMARK "DRW" 
4557 f5				push af  
4558 3a 6c 45			ld a, (.dmark)  
455b 32 a6 fd			ld (debug_mark),a  
455e 3a 6d 45			ld a, (.dmark+1)  
4561 32 a7 fd			ld (debug_mark+1),a  
4564 3a 6e 45			ld a, (.dmark+2)  
4567 32 a8 fd			ld (debug_mark+2),a  
456a 18 03			jr .pastdmark  
456c ..			.dmark: db "DRW"  
456f f1			.pastdmark: pop af  
4570			endm  
# End of macro DMARK
4570						CALLMONITOR 
4570 cd aa fd			call debug_vector  
4573				endm  
# End of macro CALLMONITOR
4573					endif 
4573 cd be 0d				call update_display 
4576					NEXTW 
4576 c3 c8 26			jp macro_next 
4579				endm 
# End of macro NEXTW
4579			 
4579			.DUMP: 
4579				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4579 37				db WORD_SYS_CORE+35             
457a b1 45			dw .CDUMP            
457c 05				db 4 + 1 
457d .. 00			db "DUMP",0              
4582				endm 
# End of macro CWHEAD
4582			; | DUMP ( x -- ) With address x display dump   | DONE 
4582			; TODO pop address to use off of the stack 
4582					if DEBUG_FORTH_WORDS_KEY 
4582						DMARK "DUM" 
4582 f5				push af  
4583 3a 97 45			ld a, (.dmark)  
4586 32 a6 fd			ld (debug_mark),a  
4589 3a 98 45			ld a, (.dmark+1)  
458c 32 a7 fd			ld (debug_mark+1),a  
458f 3a 99 45			ld a, (.dmark+2)  
4592 32 a8 fd			ld (debug_mark+2),a  
4595 18 03			jr .pastdmark  
4597 ..			.dmark: db "DUM"  
459a f1			.pastdmark: pop af  
459b			endm  
# End of macro DMARK
459b						CALLMONITOR 
459b cd aa fd			call debug_vector  
459e				endm  
# End of macro CALLMONITOR
459e					endif 
459e cd 9b 0d				call clear_display 
45a1			 
45a1					; get address 
45a1			 
45a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45a1 cd 12 25			call macro_dsp_valuehl 
45a4				endm 
# End of macro FORTH_DSP_VALUEHL
45a4				 
45a4					; save it for cdump 
45a4			 
45a4 22 1f f4				ld (os_cur_ptr),hl 
45a7			 
45a7					; destroy value TOS 
45a7			 
45a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45a7 cd ca 25			call macro_forth_dsp_pop 
45aa				endm 
# End of macro FORTH_DSP_POP
45aa			 
45aa cd 9b 21				call dumpcont	; skip old style of param parsing	 
45ad c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
45ae					NEXTW 
45ae c3 c8 26			jp macro_next 
45b1				endm 
# End of macro NEXTW
45b1			.CDUMP: 
45b1				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
45b1 38				db WORD_SYS_CORE+36             
45b2 e1 45			dw .DAT            
45b4 06				db 5 + 1 
45b5 .. 00			db "CDUMP",0              
45bb				endm 
# End of macro CWHEAD
45bb			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
45bb					if DEBUG_FORTH_WORDS_KEY 
45bb						DMARK "CDP" 
45bb f5				push af  
45bc 3a d0 45			ld a, (.dmark)  
45bf 32 a6 fd			ld (debug_mark),a  
45c2 3a d1 45			ld a, (.dmark+1)  
45c5 32 a7 fd			ld (debug_mark+1),a  
45c8 3a d2 45			ld a, (.dmark+2)  
45cb 32 a8 fd			ld (debug_mark+2),a  
45ce 18 03			jr .pastdmark  
45d0 ..			.dmark: db "CDP"  
45d3 f1			.pastdmark: pop af  
45d4			endm  
# End of macro DMARK
45d4						CALLMONITOR 
45d4 cd aa fd			call debug_vector  
45d7				endm  
# End of macro CALLMONITOR
45d7					endif 
45d7 cd 9b 0d				call clear_display 
45da cd 9b 21				call dumpcont	 
45dd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
45de					NEXTW 
45de c3 c8 26			jp macro_next 
45e1				endm 
# End of macro NEXTW
45e1			 
45e1			 
45e1			 
45e1			 
45e1			.DAT: 
45e1				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
45e1 3d				db WORD_SYS_CORE+41             
45e2 37 46			dw .HOME            
45e4 03				db 2 + 1 
45e5 .. 00			db "AT",0              
45e8				endm 
# End of macro CWHEAD
45e8			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
45e8					if DEBUG_FORTH_WORDS_KEY 
45e8						DMARK "AT." 
45e8 f5				push af  
45e9 3a fd 45			ld a, (.dmark)  
45ec 32 a6 fd			ld (debug_mark),a  
45ef 3a fe 45			ld a, (.dmark+1)  
45f2 32 a7 fd			ld (debug_mark+1),a  
45f5 3a ff 45			ld a, (.dmark+2)  
45f8 32 a8 fd			ld (debug_mark+2),a  
45fb 18 03			jr .pastdmark  
45fd ..			.dmark: db "AT."  
4600 f1			.pastdmark: pop af  
4601			endm  
# End of macro DMARK
4601						CALLMONITOR 
4601 cd aa fd			call debug_vector  
4604				endm  
# End of macro CALLMONITOR
4604					endif 
4604					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4604 cd 12 25			call macro_dsp_valuehl 
4607				endm 
# End of macro FORTH_DSP_VALUEHL
4607			 
4607			 
4607					; TODO save cursor row 
4607 7d					ld a,l 
4608 fe 02				cp 2 
460a 20 04				jr nz, .crow3 
460c 3e 28				ld a, display_row_2 
460e 18 12				jr .ccol1 
4610 fe 03		.crow3:		cp 3 
4612 20 04				jr nz, .crow4 
4614 3e 50				ld a, display_row_3 
4616 18 0a				jr .ccol1 
4618 fe 04		.crow4:		cp 4 
461a 20 04				jr nz, .crow1 
461c 3e 78				ld a, display_row_4 
461e 18 02				jr .ccol1 
4620 3e 00		.crow1:		ld a,display_row_1 
4622 f5			.ccol1:		push af			; got row offset 
4623 6f					ld l,a 
4624 26 00				ld h,0 
4626					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4626 cd ca 25			call macro_forth_dsp_pop 
4629				endm 
# End of macro FORTH_DSP_POP
4629					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4629 cd 12 25			call macro_dsp_valuehl 
462c				endm 
# End of macro FORTH_DSP_VALUEHL
462c					; TODO save cursor col 
462c f1					pop af 
462d 85					add l		; add col offset 
462e 32 99 f9				ld (f_cursor_ptr), a 
4631					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4631 cd ca 25			call macro_forth_dsp_pop 
4634				endm 
# End of macro FORTH_DSP_POP
4634			 
4634					; calculate  
4634			 
4634					NEXTW 
4634 c3 c8 26			jp macro_next 
4637				endm 
# End of macro NEXTW
4637			 
4637			 
4637			.HOME: 
4637				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4637 41				db WORD_SYS_CORE+45             
4638 64 46			dw .CR            
463a 05				db 4 + 1 
463b .. 00			db "HOME",0              
4640				endm 
# End of macro CWHEAD
4640			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4640					if DEBUG_FORTH_WORDS_KEY 
4640						DMARK "HOM" 
4640 f5				push af  
4641 3a 55 46			ld a, (.dmark)  
4644 32 a6 fd			ld (debug_mark),a  
4647 3a 56 46			ld a, (.dmark+1)  
464a 32 a7 fd			ld (debug_mark+1),a  
464d 3a 57 46			ld a, (.dmark+2)  
4650 32 a8 fd			ld (debug_mark+2),a  
4653 18 03			jr .pastdmark  
4655 ..			.dmark: db "HOM"  
4658 f1			.pastdmark: pop af  
4659			endm  
# End of macro DMARK
4659						CALLMONITOR 
4659 cd aa fd			call debug_vector  
465c				endm  
# End of macro CALLMONITOR
465c					endif 
465c 3e 00		.home:		ld a, 0		; and home cursor 
465e 32 99 f9				ld (f_cursor_ptr), a 
4661					NEXTW 
4661 c3 c8 26			jp macro_next 
4664				endm 
# End of macro NEXTW
4664			 
4664			 
4664			.CR: 
4664				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4664 46				db WORD_SYS_CORE+50             
4665 9f 46			dw .SPACE            
4667 03				db 2 + 1 
4668 .. 00			db "CR",0              
466b				endm 
# End of macro CWHEAD
466b			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
466b					if DEBUG_FORTH_WORDS_KEY 
466b						DMARK "CR." 
466b f5				push af  
466c 3a 80 46			ld a, (.dmark)  
466f 32 a6 fd			ld (debug_mark),a  
4672 3a 81 46			ld a, (.dmark+1)  
4675 32 a7 fd			ld (debug_mark+1),a  
4678 3a 82 46			ld a, (.dmark+2)  
467b 32 a8 fd			ld (debug_mark+2),a  
467e 18 03			jr .pastdmark  
4680 ..			.dmark: db "CR."  
4683 f1			.pastdmark: pop af  
4684			endm  
# End of macro DMARK
4684						CALLMONITOR 
4684 cd aa fd			call debug_vector  
4687				endm  
# End of macro CALLMONITOR
4687					endif 
4687 3e 0d				ld a, 13 
4689 32 fc f0				ld (scratch),a 
468c 3e 0a				ld a, 10 
468e 32 fd f0				ld (scratch+1),a 
4691 3e 00				ld a, 0 
4693 32 fe f0				ld (scratch+2),a 
4696 21 fc f0				ld hl, scratch 
4699 cd 89 23				call forth_push_str 
469c					 
469c				       NEXTW 
469c c3 c8 26			jp macro_next 
469f				endm 
# End of macro NEXTW
469f			.SPACE: 
469f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
469f 46				db WORD_SYS_CORE+50             
46a0 d5 46			dw .SPACES            
46a2 03				db 2 + 1 
46a3 .. 00			db "BL",0              
46a6				endm 
# End of macro CWHEAD
46a6			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
46a6					if DEBUG_FORTH_WORDS_KEY 
46a6						DMARK "BL." 
46a6 f5				push af  
46a7 3a bb 46			ld a, (.dmark)  
46aa 32 a6 fd			ld (debug_mark),a  
46ad 3a bc 46			ld a, (.dmark+1)  
46b0 32 a7 fd			ld (debug_mark+1),a  
46b3 3a bd 46			ld a, (.dmark+2)  
46b6 32 a8 fd			ld (debug_mark+2),a  
46b9 18 03			jr .pastdmark  
46bb ..			.dmark: db "BL."  
46be f1			.pastdmark: pop af  
46bf			endm  
# End of macro DMARK
46bf						CALLMONITOR 
46bf cd aa fd			call debug_vector  
46c2				endm  
# End of macro CALLMONITOR
46c2					endif 
46c2 3e 20				ld a, " " 
46c4 32 fc f0				ld (scratch),a 
46c7 3e 00				ld a, 0 
46c9 32 fd f0				ld (scratch+1),a 
46cc 21 fc f0				ld hl, scratch 
46cf cd 89 23				call forth_push_str 
46d2					 
46d2				       NEXTW 
46d2 c3 c8 26			jp macro_next 
46d5				endm 
# End of macro NEXTW
46d5			 
46d5			;.blstr: db " ", 0 
46d5			 
46d5			.SPACES: 
46d5				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
46d5 47				db WORD_SYS_CORE+51             
46d6 70 47			dw .SCROLL            
46d8 07				db 6 + 1 
46d9 .. 00			db "SPACES",0              
46e0				endm 
# End of macro CWHEAD
46e0			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
46e0					if DEBUG_FORTH_WORDS_KEY 
46e0						DMARK "SPS" 
46e0 f5				push af  
46e1 3a f5 46			ld a, (.dmark)  
46e4 32 a6 fd			ld (debug_mark),a  
46e7 3a f6 46			ld a, (.dmark+1)  
46ea 32 a7 fd			ld (debug_mark+1),a  
46ed 3a f7 46			ld a, (.dmark+2)  
46f0 32 a8 fd			ld (debug_mark+2),a  
46f3 18 03			jr .pastdmark  
46f5 ..			.dmark: db "SPS"  
46f8 f1			.pastdmark: pop af  
46f9			endm  
# End of macro DMARK
46f9						CALLMONITOR 
46f9 cd aa fd			call debug_vector  
46fc				endm  
# End of macro CALLMONITOR
46fc					endif 
46fc			 
46fc			 
46fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46fc cd 12 25			call macro_dsp_valuehl 
46ff				endm 
# End of macro FORTH_DSP_VALUEHL
46ff			 
46ff e5					push hl    ; u 
4700					if DEBUG_FORTH_WORDS 
4700						DMARK "SPA" 
4700 f5				push af  
4701 3a 15 47			ld a, (.dmark)  
4704 32 a6 fd			ld (debug_mark),a  
4707 3a 16 47			ld a, (.dmark+1)  
470a 32 a7 fd			ld (debug_mark+1),a  
470d 3a 17 47			ld a, (.dmark+2)  
4710 32 a8 fd			ld (debug_mark+2),a  
4713 18 03			jr .pastdmark  
4715 ..			.dmark: db "SPA"  
4718 f1			.pastdmark: pop af  
4719			endm  
# End of macro DMARK
4719						CALLMONITOR 
4719 cd aa fd			call debug_vector  
471c				endm  
# End of macro CALLMONITOR
471c					endif 
471c			 
471c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
471c cd ca 25			call macro_forth_dsp_pop 
471f				endm 
# End of macro FORTH_DSP_POP
471f e1					pop hl 
4720 0e 00				ld c, 0 
4722 45					ld b, l 
4723 21 fc f0				ld hl, scratch  
4726			 
4726					if DEBUG_FORTH_WORDS 
4726						DMARK "SP2" 
4726 f5				push af  
4727 3a 3b 47			ld a, (.dmark)  
472a 32 a6 fd			ld (debug_mark),a  
472d 3a 3c 47			ld a, (.dmark+1)  
4730 32 a7 fd			ld (debug_mark+1),a  
4733 3a 3d 47			ld a, (.dmark+2)  
4736 32 a8 fd			ld (debug_mark+2),a  
4739 18 03			jr .pastdmark  
473b ..			.dmark: db "SP2"  
473e f1			.pastdmark: pop af  
473f			endm  
# End of macro DMARK
473f						CALLMONITOR 
473f cd aa fd			call debug_vector  
4742				endm  
# End of macro CALLMONITOR
4742					endif 
4742 3e 20				ld a, ' ' 
4744			.spaces1:	 
4744 77					ld (hl),a 
4745 23					inc hl 
4746					 
4746 10 fc				djnz .spaces1 
4748 3e 00				ld a,0 
474a 77					ld (hl),a 
474b 21 fc f0				ld hl, scratch 
474e					if DEBUG_FORTH_WORDS 
474e						DMARK "SP3" 
474e f5				push af  
474f 3a 63 47			ld a, (.dmark)  
4752 32 a6 fd			ld (debug_mark),a  
4755 3a 64 47			ld a, (.dmark+1)  
4758 32 a7 fd			ld (debug_mark+1),a  
475b 3a 65 47			ld a, (.dmark+2)  
475e 32 a8 fd			ld (debug_mark+2),a  
4761 18 03			jr .pastdmark  
4763 ..			.dmark: db "SP3"  
4766 f1			.pastdmark: pop af  
4767			endm  
# End of macro DMARK
4767						CALLMONITOR 
4767 cd aa fd			call debug_vector  
476a				endm  
# End of macro CALLMONITOR
476a					endif 
476a cd 89 23				call forth_push_str 
476d			 
476d				       NEXTW 
476d c3 c8 26			jp macro_next 
4770				endm 
# End of macro NEXTW
4770			 
4770			 
4770			 
4770			.SCROLL: 
4770				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4770 53				db WORD_SYS_CORE+63             
4771 9d 47			dw .SCROLLD            
4773 07				db 6 + 1 
4774 .. 00			db "SCROLL",0              
477b				endm 
# End of macro CWHEAD
477b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
477b					if DEBUG_FORTH_WORDS_KEY 
477b						DMARK "SCR" 
477b f5				push af  
477c 3a 90 47			ld a, (.dmark)  
477f 32 a6 fd			ld (debug_mark),a  
4782 3a 91 47			ld a, (.dmark+1)  
4785 32 a7 fd			ld (debug_mark+1),a  
4788 3a 92 47			ld a, (.dmark+2)  
478b 32 a8 fd			ld (debug_mark+2),a  
478e 18 03			jr .pastdmark  
4790 ..			.dmark: db "SCR"  
4793 f1			.pastdmark: pop af  
4794			endm  
# End of macro DMARK
4794						CALLMONITOR 
4794 cd aa fd			call debug_vector  
4797				endm  
# End of macro CALLMONITOR
4797					endif 
4797			 
4797 cd 5d 0d			call scroll_up 
479a			;	call update_display 
479a			 
479a					NEXTW 
479a c3 c8 26			jp macro_next 
479d				endm 
# End of macro NEXTW
479d			 
479d			 
479d			 
479d			;		; get dir 
479d			; 
479d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
479d			; 
479d			;		push hl 
479d			; 
479d			;		; destroy value TOS 
479d			; 
479d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
479d			; 
479d			;		; get count 
479d			; 
479d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
479d			; 
479d			;		push hl 
479d			; 
479d			;		; destroy value TOS 
479d			; 
479d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
479d			; 
479d			;		; one value on hl get other one back 
479d			; 
479d			;		pop bc    ; count 
479d			; 
479d			;		pop de   ; dir 
479d			; 
479d			; 
479d			;		ld b, c 
479d			; 
479d			;.scrolldir:     push bc 
479d			;		push de 
479d			; 
479d			;		ld a, 0 
479d			;		cp e 
479d			;		jr z, .scrollup  
479d			;		call scroll_down 
479d			;		jr .scrollnext 
479d			;.scrollup:	call scroll_up 
479d			; 
479d			;		 
479d			;.scrollnext: 
479d			;		pop de 
479d			;		pop bc 
479d			;		djnz .scrolldir 
479d			; 
479d			; 
479d			; 
479d			; 
479d			; 
479d			;		NEXTW 
479d			 
479d			.SCROLLD: 
479d				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
479d 53				db WORD_SYS_CORE+63             
479e cb 47			dw .ATQ            
47a0 08				db 7 + 1 
47a1 .. 00			db "SCROLLD",0              
47a9				endm 
# End of macro CWHEAD
47a9			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
47a9					if DEBUG_FORTH_WORDS_KEY 
47a9						DMARK "SCD" 
47a9 f5				push af  
47aa 3a be 47			ld a, (.dmark)  
47ad 32 a6 fd			ld (debug_mark),a  
47b0 3a bf 47			ld a, (.dmark+1)  
47b3 32 a7 fd			ld (debug_mark+1),a  
47b6 3a c0 47			ld a, (.dmark+2)  
47b9 32 a8 fd			ld (debug_mark+2),a  
47bc 18 03			jr .pastdmark  
47be ..			.dmark: db "SCD"  
47c1 f1			.pastdmark: pop af  
47c2			endm  
# End of macro DMARK
47c2						CALLMONITOR 
47c2 cd aa fd			call debug_vector  
47c5				endm  
# End of macro CALLMONITOR
47c5					endif 
47c5			 
47c5 cd 81 0d			call scroll_down 
47c8			;	call update_display 
47c8			 
47c8					NEXTW 
47c8 c3 c8 26			jp macro_next 
47cb				endm 
# End of macro NEXTW
47cb			 
47cb			 
47cb			.ATQ: 
47cb				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
47cb 62				db WORD_SYS_CORE+78             
47cc 29 48			dw .AUTODSP            
47ce 04				db 3 + 1 
47cf .. 00			db "AT@",0              
47d3				endm 
# End of macro CWHEAD
47d3			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
47d3					if DEBUG_FORTH_WORDS_KEY 
47d3						DMARK "ATA" 
47d3 f5				push af  
47d4 3a e8 47			ld a, (.dmark)  
47d7 32 a6 fd			ld (debug_mark),a  
47da 3a e9 47			ld a, (.dmark+1)  
47dd 32 a7 fd			ld (debug_mark+1),a  
47e0 3a ea 47			ld a, (.dmark+2)  
47e3 32 a8 fd			ld (debug_mark+2),a  
47e6 18 03			jr .pastdmark  
47e8 ..			.dmark: db "ATA"  
47eb f1			.pastdmark: pop af  
47ec			endm  
# End of macro DMARK
47ec						CALLMONITOR 
47ec cd aa fd			call debug_vector  
47ef				endm  
# End of macro CALLMONITOR
47ef					endif 
47ef			 
47ef			 
47ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
47ef cd 12 25			call macro_dsp_valuehl 
47f2				endm 
# End of macro FORTH_DSP_VALUEHL
47f2			 
47f2					; TODO save cursor row 
47f2 7d					ld a,l 
47f3 fe 02				cp 2 
47f5 20 04				jr nz, .crow3aq 
47f7 3e 28				ld a, display_row_2 
47f9 18 12				jr .ccol1aq 
47fb fe 03		.crow3aq:		cp 3 
47fd 20 04				jr nz, .crow4aq 
47ff 3e 50				ld a, display_row_3 
4801 18 0a				jr .ccol1aq 
4803 fe 04		.crow4aq:		cp 4 
4805 20 04				jr nz, .crow1aq 
4807 3e 78				ld a, display_row_4 
4809 18 02				jr .ccol1aq 
480b 3e 00		.crow1aq:		ld a,display_row_1 
480d f5			.ccol1aq:		push af			; got row offset 
480e 6f					ld l,a 
480f 26 00				ld h,0 
4811					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4811 cd ca 25			call macro_forth_dsp_pop 
4814				endm 
# End of macro FORTH_DSP_POP
4814					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4814 cd 12 25			call macro_dsp_valuehl 
4817				endm 
# End of macro FORTH_DSP_VALUEHL
4817					; TODO save cursor col 
4817 f1					pop af 
4818 85					add l		; add col offset 
4819			 
4819					; add current frame buffer address 
4819 2a 07 fb				ld hl, (display_fb_active) 
481c cd cf 0f				call addatohl 
481f			 
481f			 
481f			 
481f			 
481f					; get char frame buffer location offset in hl 
481f			 
481f 7e					ld a,(hl) 
4820 26 00				ld h, 0 
4822 6f					ld l, a 
4823			 
4823 cd 1b 23				call forth_push_numhl 
4826			 
4826			 
4826					NEXTW 
4826 c3 c8 26			jp macro_next 
4829				endm 
# End of macro NEXTW
4829			 
4829			.AUTODSP: 
4829				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4829 63				db WORD_SYS_CORE+79             
482a 3f 48			dw .MENU            
482c 05				db 4 + 1 
482d .. 00			db "ADSP",0              
4832				endm 
# End of macro CWHEAD
4832			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4832			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4832			 
4832					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4832 cd 12 25			call macro_dsp_valuehl 
4835				endm 
# End of macro FORTH_DSP_VALUEHL
4835			 
4835			;		push hl 
4835			 
4835					; destroy value TOS 
4835			 
4835					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4835 cd ca 25			call macro_forth_dsp_pop 
4838				endm 
# End of macro FORTH_DSP_POP
4838			 
4838			;		pop hl 
4838			 
4838 7d					ld a,l 
4839 32 77 f9				ld (cli_autodisplay), a 
483c				       NEXTW 
483c c3 c8 26			jp macro_next 
483f				endm 
# End of macro NEXTW
483f			 
483f			.MENU: 
483f				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
483f 70				db WORD_SYS_CORE+92             
4840 e8 48			dw .ENDDISPLAY            
4842 05				db 4 + 1 
4843 .. 00			db "MENU",0              
4848				endm 
# End of macro CWHEAD
4848			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4848			 
4848			;		; get number of items on the stack 
4848			; 
4848				 
4848					FORTH_DSP_VALUEHL 
4848 cd 12 25			call macro_dsp_valuehl 
484b				endm 
# End of macro FORTH_DSP_VALUEHL
484b				 
484b					if DEBUG_FORTH_WORDS_KEY 
484b						DMARK "MNU" 
484b f5				push af  
484c 3a 60 48			ld a, (.dmark)  
484f 32 a6 fd			ld (debug_mark),a  
4852 3a 61 48			ld a, (.dmark+1)  
4855 32 a7 fd			ld (debug_mark+1),a  
4858 3a 62 48			ld a, (.dmark+2)  
485b 32 a8 fd			ld (debug_mark+2),a  
485e 18 03			jr .pastdmark  
4860 ..			.dmark: db "MNU"  
4863 f1			.pastdmark: pop af  
4864			endm  
# End of macro DMARK
4864						CALLMONITOR 
4864 cd aa fd			call debug_vector  
4867				endm  
# End of macro CALLMONITOR
4867					endif 
4867			 
4867 45					ld b, l	 
4868 05					dec b 
4869			 
4869					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4869 cd ca 25			call macro_forth_dsp_pop 
486c				endm 
# End of macro FORTH_DSP_POP
486c			 
486c			 
486c					; go directly through the stack to pluck out the string pointers and build an array 
486c			 
486c			;		FORTH_DSP 
486c			 
486c					; hl contains top most stack item 
486c				 
486c 11 fc f0				ld de, scratch 
486f			 
486f			.mbuild: 
486f			 
486f					FORTH_DSP_VALUEHL 
486f cd 12 25			call macro_dsp_valuehl 
4872				endm 
# End of macro FORTH_DSP_VALUEHL
4872			 
4872					if DEBUG_FORTH_WORDS 
4872						DMARK "MN3" 
4872 f5				push af  
4873 3a 87 48			ld a, (.dmark)  
4876 32 a6 fd			ld (debug_mark),a  
4879 3a 88 48			ld a, (.dmark+1)  
487c 32 a7 fd			ld (debug_mark+1),a  
487f 3a 89 48			ld a, (.dmark+2)  
4882 32 a8 fd			ld (debug_mark+2),a  
4885 18 03			jr .pastdmark  
4887 ..			.dmark: db "MN3"  
488a f1			.pastdmark: pop af  
488b			endm  
# End of macro DMARK
488b						CALLMONITOR 
488b cd aa fd			call debug_vector  
488e				endm  
# End of macro CALLMONITOR
488e					endif 
488e eb					ex de, hl 
488f 73					ld (hl), e 
4890 23					inc hl 
4891 72					ld (hl), d 
4892 23					inc hl 
4893 eb					ex de, hl 
4894			 
4894					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4894 cd ca 25			call macro_forth_dsp_pop 
4897				endm 
# End of macro FORTH_DSP_POP
4897			 
4897 10 d6				djnz .mbuild 
4899			 
4899					; done add term 
4899			 
4899 eb					ex de, hl 
489a 36 00				ld (hl), 0 
489c 23					inc hl 
489d 36 00				ld (hl), 0 
489f			 
489f				 
489f					 
489f 21 fc f0				ld hl, scratch 
48a2			 
48a2					if DEBUG_FORTH_WORDS 
48a2						DMARK "MNx" 
48a2 f5				push af  
48a3 3a b7 48			ld a, (.dmark)  
48a6 32 a6 fd			ld (debug_mark),a  
48a9 3a b8 48			ld a, (.dmark+1)  
48ac 32 a7 fd			ld (debug_mark+1),a  
48af 3a b9 48			ld a, (.dmark+2)  
48b2 32 a8 fd			ld (debug_mark+2),a  
48b5 18 03			jr .pastdmark  
48b7 ..			.dmark: db "MNx"  
48ba f1			.pastdmark: pop af  
48bb			endm  
# End of macro DMARK
48bb						CALLMONITOR 
48bb cd aa fd			call debug_vector  
48be				endm  
# End of macro CALLMONITOR
48be					endif 
48be			 
48be			 
48be			 
48be 3e 00				ld a, 0 
48c0 cd cc 0d				call menu 
48c3			 
48c3			 
48c3 6f					ld l, a 
48c4 26 00				ld h, 0 
48c6			 
48c6					if DEBUG_FORTH_WORDS 
48c6						DMARK "MNr" 
48c6 f5				push af  
48c7 3a db 48			ld a, (.dmark)  
48ca 32 a6 fd			ld (debug_mark),a  
48cd 3a dc 48			ld a, (.dmark+1)  
48d0 32 a7 fd			ld (debug_mark+1),a  
48d3 3a dd 48			ld a, (.dmark+2)  
48d6 32 a8 fd			ld (debug_mark+2),a  
48d9 18 03			jr .pastdmark  
48db ..			.dmark: db "MNr"  
48de f1			.pastdmark: pop af  
48df			endm  
# End of macro DMARK
48df						CALLMONITOR 
48df cd aa fd			call debug_vector  
48e2				endm  
# End of macro CALLMONITOR
48e2					endif 
48e2			 
48e2 cd 1b 23				call forth_push_numhl 
48e5			 
48e5			 
48e5			 
48e5			 
48e5				       NEXTW 
48e5 c3 c8 26			jp macro_next 
48e8				endm 
# End of macro NEXTW
48e8			 
48e8			 
48e8			.ENDDISPLAY: 
48e8			 
48e8			; eof 
# End of file forth_words_display.asm
48e8			include "forth_words_str.asm" 
48e8			 
48e8			; | ## String Words 
48e8			 
48e8			.PTR:   
48e8			 
48e8				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
48e8 48				db WORD_SYS_CORE+52             
48e9 15 49			dw .STYPE            
48eb 04				db 3 + 1 
48ec .. 00			db "PTR",0              
48f0				endm 
# End of macro CWHEAD
48f0			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
48f0			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
48f0			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
48f0			 
48f0					if DEBUG_FORTH_WORDS_KEY 
48f0						DMARK "PTR" 
48f0 f5				push af  
48f1 3a 05 49			ld a, (.dmark)  
48f4 32 a6 fd			ld (debug_mark),a  
48f7 3a 06 49			ld a, (.dmark+1)  
48fa 32 a7 fd			ld (debug_mark+1),a  
48fd 3a 07 49			ld a, (.dmark+2)  
4900 32 a8 fd			ld (debug_mark+2),a  
4903 18 03			jr .pastdmark  
4905 ..			.dmark: db "PTR"  
4908 f1			.pastdmark: pop af  
4909			endm  
# End of macro DMARK
4909						CALLMONITOR 
4909 cd aa fd			call debug_vector  
490c				endm  
# End of macro CALLMONITOR
490c					endif 
490c					FORTH_DSP_VALUEHL 
490c cd 12 25			call macro_dsp_valuehl 
490f				endm 
# End of macro FORTH_DSP_VALUEHL
490f cd 1b 23				call forth_push_numhl 
4912			 
4912			 
4912					NEXTW 
4912 c3 c8 26			jp macro_next 
4915				endm 
# End of macro NEXTW
4915			.STYPE: 
4915				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4915 48				db WORD_SYS_CORE+52             
4916 64 49			dw .UPPER            
4918 06				db 5 + 1 
4919 .. 00			db "STYPE",0              
491f				endm 
# End of macro CWHEAD
491f			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
491f					if DEBUG_FORTH_WORDS_KEY 
491f						DMARK "STY" 
491f f5				push af  
4920 3a 34 49			ld a, (.dmark)  
4923 32 a6 fd			ld (debug_mark),a  
4926 3a 35 49			ld a, (.dmark+1)  
4929 32 a7 fd			ld (debug_mark+1),a  
492c 3a 36 49			ld a, (.dmark+2)  
492f 32 a8 fd			ld (debug_mark+2),a  
4932 18 03			jr .pastdmark  
4934 ..			.dmark: db "STY"  
4937 f1			.pastdmark: pop af  
4938			endm  
# End of macro DMARK
4938						CALLMONITOR 
4938 cd aa fd			call debug_vector  
493b				endm  
# End of macro CALLMONITOR
493b					endif 
493b					FORTH_DSP 
493b cd d8 24			call macro_forth_dsp 
493e				endm 
# End of macro FORTH_DSP
493e					;v5 FORTH_DSP_VALUE 
493e			 
493e 7e					ld a, (hl) 
493f			 
493f f5					push af 
4940			 
4940			; Dont destroy TOS		FORTH_DSP_POP 
4940			 
4940 f1					pop af 
4941			 
4941 fe 01				cp DS_TYPE_STR 
4943 28 09				jr z, .typestr 
4945			 
4945 fe 02				cp DS_TYPE_INUM 
4947 28 0a				jr z, .typeinum 
4949			 
4949 21 62 49				ld hl, .tna 
494c 18 0a				jr .tpush 
494e			 
494e 21 5e 49		.typestr:	ld hl, .tstr 
4951 18 05				jr .tpush 
4953 21 60 49		.typeinum:	ld hl, .tinum 
4956 18 00				jr .tpush 
4958			 
4958			.tpush: 
4958			 
4958 cd 89 23				call forth_push_str 
495b			 
495b					NEXTW 
495b c3 c8 26			jp macro_next 
495e				endm 
# End of macro NEXTW
495e .. 00		.tstr:	db "s",0 
4960 .. 00		.tinum:  db "i",0 
4962 .. 00		.tna:   db "?", 0 
4964			 
4964			 
4964			.UPPER: 
4964				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4964 48				db WORD_SYS_CORE+52             
4965 9f 49			dw .LOWER            
4967 06				db 5 + 1 
4968 .. 00			db "UPPER",0              
496e				endm 
# End of macro CWHEAD
496e			; | UPPER ( s -- s ) Upper case string s  | DONE 
496e					if DEBUG_FORTH_WORDS_KEY 
496e						DMARK "UPR" 
496e f5				push af  
496f 3a 83 49			ld a, (.dmark)  
4972 32 a6 fd			ld (debug_mark),a  
4975 3a 84 49			ld a, (.dmark+1)  
4978 32 a7 fd			ld (debug_mark+1),a  
497b 3a 85 49			ld a, (.dmark+2)  
497e 32 a8 fd			ld (debug_mark+2),a  
4981 18 03			jr .pastdmark  
4983 ..			.dmark: db "UPR"  
4986 f1			.pastdmark: pop af  
4987			endm  
# End of macro DMARK
4987						CALLMONITOR 
4987 cd aa fd			call debug_vector  
498a				endm  
# End of macro CALLMONITOR
498a					endif 
498a			 
498a					FORTH_DSP 
498a cd d8 24			call macro_forth_dsp 
498d				endm 
# End of macro FORTH_DSP
498d					 
498d			; TODO check is string type 
498d			 
498d					FORTH_DSP_VALUEHL 
498d cd 12 25			call macro_dsp_valuehl 
4990				endm 
# End of macro FORTH_DSP_VALUEHL
4990			; get pointer to string in hl 
4990			 
4990 7e			.toup:		ld a, (hl) 
4991 fe 00				cp 0 
4993 28 07				jr z, .toupdone 
4995			 
4995 cd 54 15				call to_upper 
4998			 
4998 77					ld (hl), a 
4999 23					inc hl 
499a 18 f4				jr .toup 
499c			 
499c					 
499c			 
499c			 
499c			; for each char convert to upper 
499c					 
499c			.toupdone: 
499c			 
499c			 
499c					NEXTW 
499c c3 c8 26			jp macro_next 
499f				endm 
# End of macro NEXTW
499f			.LOWER: 
499f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
499f 48				db WORD_SYS_CORE+52             
49a0 da 49			dw .TCASE            
49a2 06				db 5 + 1 
49a3 .. 00			db "LOWER",0              
49a9				endm 
# End of macro CWHEAD
49a9			; | LOWER ( s -- s ) Lower case string s  | DONE 
49a9					if DEBUG_FORTH_WORDS_KEY 
49a9						DMARK "LWR" 
49a9 f5				push af  
49aa 3a be 49			ld a, (.dmark)  
49ad 32 a6 fd			ld (debug_mark),a  
49b0 3a bf 49			ld a, (.dmark+1)  
49b3 32 a7 fd			ld (debug_mark+1),a  
49b6 3a c0 49			ld a, (.dmark+2)  
49b9 32 a8 fd			ld (debug_mark+2),a  
49bc 18 03			jr .pastdmark  
49be ..			.dmark: db "LWR"  
49c1 f1			.pastdmark: pop af  
49c2			endm  
# End of macro DMARK
49c2						CALLMONITOR 
49c2 cd aa fd			call debug_vector  
49c5				endm  
# End of macro CALLMONITOR
49c5					endif 
49c5			 
49c5					FORTH_DSP 
49c5 cd d8 24			call macro_forth_dsp 
49c8				endm 
# End of macro FORTH_DSP
49c8					 
49c8			; TODO check is string type 
49c8			 
49c8					FORTH_DSP_VALUEHL 
49c8 cd 12 25			call macro_dsp_valuehl 
49cb				endm 
# End of macro FORTH_DSP_VALUEHL
49cb			; get pointer to string in hl 
49cb			 
49cb 7e			.tolow:		ld a, (hl) 
49cc fe 00				cp 0 
49ce 28 07				jr z, .tolowdone 
49d0			 
49d0 cd 5d 15				call to_lower 
49d3			 
49d3 77					ld (hl), a 
49d4 23					inc hl 
49d5 18 f4				jr .tolow 
49d7			 
49d7					 
49d7			 
49d7			 
49d7			; for each char convert to low 
49d7					 
49d7			.tolowdone: 
49d7					NEXTW 
49d7 c3 c8 26			jp macro_next 
49da				endm 
# End of macro NEXTW
49da			.TCASE: 
49da				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
49da 48				db WORD_SYS_CORE+52             
49db 10 4b			dw .SUBSTR            
49dd 06				db 5 + 1 
49de .. 00			db "TCASE",0              
49e4				endm 
# End of macro CWHEAD
49e4			; | TCASE ( s -- s ) Title case string s  | DONE 
49e4					if DEBUG_FORTH_WORDS_KEY 
49e4						DMARK "TCS" 
49e4 f5				push af  
49e5 3a f9 49			ld a, (.dmark)  
49e8 32 a6 fd			ld (debug_mark),a  
49eb 3a fa 49			ld a, (.dmark+1)  
49ee 32 a7 fd			ld (debug_mark+1),a  
49f1 3a fb 49			ld a, (.dmark+2)  
49f4 32 a8 fd			ld (debug_mark+2),a  
49f7 18 03			jr .pastdmark  
49f9 ..			.dmark: db "TCS"  
49fc f1			.pastdmark: pop af  
49fd			endm  
# End of macro DMARK
49fd						CALLMONITOR 
49fd cd aa fd			call debug_vector  
4a00				endm  
# End of macro CALLMONITOR
4a00					endif 
4a00			 
4a00					FORTH_DSP 
4a00 cd d8 24			call macro_forth_dsp 
4a03				endm 
# End of macro FORTH_DSP
4a03					 
4a03			; TODO check is string type 
4a03			 
4a03					FORTH_DSP_VALUEHL 
4a03 cd 12 25			call macro_dsp_valuehl 
4a06				endm 
# End of macro FORTH_DSP_VALUEHL
4a06			; get pointer to string in hl 
4a06			 
4a06					if DEBUG_FORTH_WORDS 
4a06						DMARK "TC1" 
4a06 f5				push af  
4a07 3a 1b 4a			ld a, (.dmark)  
4a0a 32 a6 fd			ld (debug_mark),a  
4a0d 3a 1c 4a			ld a, (.dmark+1)  
4a10 32 a7 fd			ld (debug_mark+1),a  
4a13 3a 1d 4a			ld a, (.dmark+2)  
4a16 32 a8 fd			ld (debug_mark+2),a  
4a19 18 03			jr .pastdmark  
4a1b ..			.dmark: db "TC1"  
4a1e f1			.pastdmark: pop af  
4a1f			endm  
# End of macro DMARK
4a1f						CALLMONITOR 
4a1f cd aa fd			call debug_vector  
4a22				endm  
# End of macro CALLMONITOR
4a22					endif 
4a22			 
4a22					; first time in turn to upper case first char 
4a22			 
4a22 7e					ld a, (hl) 
4a23 c3 ad 4a				jp .totsiptou 
4a26			 
4a26			 
4a26 7e			.tot:		ld a, (hl) 
4a27 fe 00				cp 0 
4a29 ca f1 4a				jp z, .totdone 
4a2c			 
4a2c					if DEBUG_FORTH_WORDS 
4a2c						DMARK "TC2" 
4a2c f5				push af  
4a2d 3a 41 4a			ld a, (.dmark)  
4a30 32 a6 fd			ld (debug_mark),a  
4a33 3a 42 4a			ld a, (.dmark+1)  
4a36 32 a7 fd			ld (debug_mark+1),a  
4a39 3a 43 4a			ld a, (.dmark+2)  
4a3c 32 a8 fd			ld (debug_mark+2),a  
4a3f 18 03			jr .pastdmark  
4a41 ..			.dmark: db "TC2"  
4a44 f1			.pastdmark: pop af  
4a45			endm  
# End of macro DMARK
4a45						CALLMONITOR 
4a45 cd aa fd			call debug_vector  
4a48				endm  
# End of macro CALLMONITOR
4a48					endif 
4a48					; check to see if current char is a space 
4a48			 
4a48 fe 20				cp ' ' 
4a4a 28 21				jr z, .totsp 
4a4c cd 5d 15				call to_lower 
4a4f					if DEBUG_FORTH_WORDS 
4a4f						DMARK "TC3" 
4a4f f5				push af  
4a50 3a 64 4a			ld a, (.dmark)  
4a53 32 a6 fd			ld (debug_mark),a  
4a56 3a 65 4a			ld a, (.dmark+1)  
4a59 32 a7 fd			ld (debug_mark+1),a  
4a5c 3a 66 4a			ld a, (.dmark+2)  
4a5f 32 a8 fd			ld (debug_mark+2),a  
4a62 18 03			jr .pastdmark  
4a64 ..			.dmark: db "TC3"  
4a67 f1			.pastdmark: pop af  
4a68			endm  
# End of macro DMARK
4a68						CALLMONITOR 
4a68 cd aa fd			call debug_vector  
4a6b				endm  
# End of macro CALLMONITOR
4a6b					endif 
4a6b 18 63				jr .totnxt 
4a6d			 
4a6d			.totsp:         ; on a space, find next char which should be upper 
4a6d			 
4a6d					if DEBUG_FORTH_WORDS 
4a6d						DMARK "TC4" 
4a6d f5				push af  
4a6e 3a 82 4a			ld a, (.dmark)  
4a71 32 a6 fd			ld (debug_mark),a  
4a74 3a 83 4a			ld a, (.dmark+1)  
4a77 32 a7 fd			ld (debug_mark+1),a  
4a7a 3a 84 4a			ld a, (.dmark+2)  
4a7d 32 a8 fd			ld (debug_mark+2),a  
4a80 18 03			jr .pastdmark  
4a82 ..			.dmark: db "TC4"  
4a85 f1			.pastdmark: pop af  
4a86			endm  
# End of macro DMARK
4a86						CALLMONITOR 
4a86 cd aa fd			call debug_vector  
4a89				endm  
# End of macro CALLMONITOR
4a89					endif 
4a89					;; 
4a89			 
4a89 fe 20				cp ' ' 
4a8b 20 20				jr nz, .totsiptou 
4a8d 23					inc hl 
4a8e 7e					ld a, (hl) 
4a8f					if DEBUG_FORTH_WORDS 
4a8f						DMARK "TC5" 
4a8f f5				push af  
4a90 3a a4 4a			ld a, (.dmark)  
4a93 32 a6 fd			ld (debug_mark),a  
4a96 3a a5 4a			ld a, (.dmark+1)  
4a99 32 a7 fd			ld (debug_mark+1),a  
4a9c 3a a6 4a			ld a, (.dmark+2)  
4a9f 32 a8 fd			ld (debug_mark+2),a  
4aa2 18 03			jr .pastdmark  
4aa4 ..			.dmark: db "TC5"  
4aa7 f1			.pastdmark: pop af  
4aa8			endm  
# End of macro DMARK
4aa8						CALLMONITOR 
4aa8 cd aa fd			call debug_vector  
4aab				endm  
# End of macro CALLMONITOR
4aab					endif 
4aab 18 c0				jr .totsp 
4aad fe 00		.totsiptou:    cp 0 
4aaf 28 40				jr z, .totdone 
4ab1					; not space and not zero term so upper case it 
4ab1 cd 54 15				call to_upper 
4ab4			 
4ab4					if DEBUG_FORTH_WORDS 
4ab4						DMARK "TC6" 
4ab4 f5				push af  
4ab5 3a c9 4a			ld a, (.dmark)  
4ab8 32 a6 fd			ld (debug_mark),a  
4abb 3a ca 4a			ld a, (.dmark+1)  
4abe 32 a7 fd			ld (debug_mark+1),a  
4ac1 3a cb 4a			ld a, (.dmark+2)  
4ac4 32 a8 fd			ld (debug_mark+2),a  
4ac7 18 03			jr .pastdmark  
4ac9 ..			.dmark: db "TC6"  
4acc f1			.pastdmark: pop af  
4acd			endm  
# End of macro DMARK
4acd						CALLMONITOR 
4acd cd aa fd			call debug_vector  
4ad0				endm  
# End of macro CALLMONITOR
4ad0					endif 
4ad0			 
4ad0			 
4ad0			.totnxt: 
4ad0			 
4ad0 77					ld (hl), a 
4ad1 23					inc hl 
4ad2					if DEBUG_FORTH_WORDS 
4ad2						DMARK "TC7" 
4ad2 f5				push af  
4ad3 3a e7 4a			ld a, (.dmark)  
4ad6 32 a6 fd			ld (debug_mark),a  
4ad9 3a e8 4a			ld a, (.dmark+1)  
4adc 32 a7 fd			ld (debug_mark+1),a  
4adf 3a e9 4a			ld a, (.dmark+2)  
4ae2 32 a8 fd			ld (debug_mark+2),a  
4ae5 18 03			jr .pastdmark  
4ae7 ..			.dmark: db "TC7"  
4aea f1			.pastdmark: pop af  
4aeb			endm  
# End of macro DMARK
4aeb						CALLMONITOR 
4aeb cd aa fd			call debug_vector  
4aee				endm  
# End of macro CALLMONITOR
4aee					endif 
4aee c3 26 4a				jp .tot 
4af1			 
4af1					 
4af1			 
4af1			 
4af1			; for each char convert to low 
4af1					 
4af1			.totdone: 
4af1					if DEBUG_FORTH_WORDS 
4af1						DMARK "TCd" 
4af1 f5				push af  
4af2 3a 06 4b			ld a, (.dmark)  
4af5 32 a6 fd			ld (debug_mark),a  
4af8 3a 07 4b			ld a, (.dmark+1)  
4afb 32 a7 fd			ld (debug_mark+1),a  
4afe 3a 08 4b			ld a, (.dmark+2)  
4b01 32 a8 fd			ld (debug_mark+2),a  
4b04 18 03			jr .pastdmark  
4b06 ..			.dmark: db "TCd"  
4b09 f1			.pastdmark: pop af  
4b0a			endm  
# End of macro DMARK
4b0a						CALLMONITOR 
4b0a cd aa fd			call debug_vector  
4b0d				endm  
# End of macro CALLMONITOR
4b0d					endif 
4b0d					NEXTW 
4b0d c3 c8 26			jp macro_next 
4b10				endm 
# End of macro NEXTW
4b10			 
4b10			.SUBSTR: 
4b10				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4b10 48				db WORD_SYS_CORE+52             
4b11 6e 4b			dw .LEFT            
4b13 07				db 6 + 1 
4b14 .. 00			db "SUBSTR",0              
4b1b				endm 
# End of macro CWHEAD
4b1b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4b1b			 
4b1b					if DEBUG_FORTH_WORDS_KEY 
4b1b						DMARK "SST" 
4b1b f5				push af  
4b1c 3a 30 4b			ld a, (.dmark)  
4b1f 32 a6 fd			ld (debug_mark),a  
4b22 3a 31 4b			ld a, (.dmark+1)  
4b25 32 a7 fd			ld (debug_mark+1),a  
4b28 3a 32 4b			ld a, (.dmark+2)  
4b2b 32 a8 fd			ld (debug_mark+2),a  
4b2e 18 03			jr .pastdmark  
4b30 ..			.dmark: db "SST"  
4b33 f1			.pastdmark: pop af  
4b34			endm  
# End of macro DMARK
4b34						CALLMONITOR 
4b34 cd aa fd			call debug_vector  
4b37				endm  
# End of macro CALLMONITOR
4b37					endif 
4b37			; TODO check string type 
4b37					FORTH_DSP_VALUEHL 
4b37 cd 12 25			call macro_dsp_valuehl 
4b3a				endm 
# End of macro FORTH_DSP_VALUEHL
4b3a			 
4b3a e5					push hl      ; string length 
4b3b			 
4b3b					FORTH_DSP_POP 
4b3b cd ca 25			call macro_forth_dsp_pop 
4b3e				endm 
# End of macro FORTH_DSP_POP
4b3e			 
4b3e					FORTH_DSP_VALUEHL 
4b3e cd 12 25			call macro_dsp_valuehl 
4b41				endm 
# End of macro FORTH_DSP_VALUEHL
4b41			 
4b41 e5					push hl     ; start char 
4b42			 
4b42					FORTH_DSP_POP 
4b42 cd ca 25			call macro_forth_dsp_pop 
4b45				endm 
# End of macro FORTH_DSP_POP
4b45			 
4b45			 
4b45					FORTH_DSP_VALUE 
4b45 cd fb 24			call macro_forth_dsp_value 
4b48				endm 
# End of macro FORTH_DSP_VALUE
4b48			 
4b48 d1					pop de    ; get start post offset 
4b49			 
4b49 19					add hl, de    ; starting offset 
4b4a			 
4b4a c1					pop bc 
4b4b c5					push bc      ; grab size of string 
4b4c			 
4b4c e5					push hl    ; save string start  
4b4d			 
4b4d 26 00				ld h, 0 
4b4f 69					ld l, c 
4b50 23					inc hl 
4b51 23					inc hl 
4b52			 
4b52 cd ba 16				call malloc 
4b55				if DEBUG_FORTH_MALLOC_GUARD 
4b55 cc 9b 60				call z,malloc_error 
4b58				endif 
4b58			 
4b58 eb					ex de, hl      ; save malloc area for string copy 
4b59 e1					pop hl    ; get back source 
4b5a c1					pop bc    ; get length of string back 
4b5b			 
4b5b d5					push de    ; save malloc area for after we push 
4b5c ed b0				ldir     ; copy substr 
4b5e			 
4b5e			 
4b5e eb					ex de, hl 
4b5f 3e 00				ld a, 0 
4b61 77					ld (hl), a   ; term substr 
4b62			 
4b62					 
4b62 e1					pop hl    ; get malloc so we can push it 
4b63 e5					push hl   ; save so we can free it afterwards 
4b64			 
4b64 cd 89 23				call forth_push_str 
4b67			 
4b67 e1					pop hl 
4b68 cd 84 17				call free 
4b6b			 
4b6b					 
4b6b					 
4b6b			 
4b6b			 
4b6b					NEXTW 
4b6b c3 c8 26			jp macro_next 
4b6e				endm 
# End of macro NEXTW
4b6e			 
4b6e			.LEFT: 
4b6e				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4b6e 48				db WORD_SYS_CORE+52             
4b6f 96 4b			dw .RIGHT            
4b71 05				db 4 + 1 
4b72 .. 00			db "LEFT",0              
4b77				endm 
# End of macro CWHEAD
4b77			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4b77					if DEBUG_FORTH_WORDS_KEY 
4b77						DMARK "LEF" 
4b77 f5				push af  
4b78 3a 8c 4b			ld a, (.dmark)  
4b7b 32 a6 fd			ld (debug_mark),a  
4b7e 3a 8d 4b			ld a, (.dmark+1)  
4b81 32 a7 fd			ld (debug_mark+1),a  
4b84 3a 8e 4b			ld a, (.dmark+2)  
4b87 32 a8 fd			ld (debug_mark+2),a  
4b8a 18 03			jr .pastdmark  
4b8c ..			.dmark: db "LEF"  
4b8f f1			.pastdmark: pop af  
4b90			endm  
# End of macro DMARK
4b90						CALLMONITOR 
4b90 cd aa fd			call debug_vector  
4b93				endm  
# End of macro CALLMONITOR
4b93					endif 
4b93			 
4b93					NEXTW 
4b93 c3 c8 26			jp macro_next 
4b96				endm 
# End of macro NEXTW
4b96			.RIGHT: 
4b96				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4b96 48				db WORD_SYS_CORE+52             
4b97 bf 4b			dw .STR2NUM            
4b99 06				db 5 + 1 
4b9a .. 00			db "RIGHT",0              
4ba0				endm 
# End of macro CWHEAD
4ba0			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4ba0					if DEBUG_FORTH_WORDS_KEY 
4ba0						DMARK "RIG" 
4ba0 f5				push af  
4ba1 3a b5 4b			ld a, (.dmark)  
4ba4 32 a6 fd			ld (debug_mark),a  
4ba7 3a b6 4b			ld a, (.dmark+1)  
4baa 32 a7 fd			ld (debug_mark+1),a  
4bad 3a b7 4b			ld a, (.dmark+2)  
4bb0 32 a8 fd			ld (debug_mark+2),a  
4bb3 18 03			jr .pastdmark  
4bb5 ..			.dmark: db "RIG"  
4bb8 f1			.pastdmark: pop af  
4bb9			endm  
# End of macro DMARK
4bb9						CALLMONITOR 
4bb9 cd aa fd			call debug_vector  
4bbc				endm  
# End of macro CALLMONITOR
4bbc					endif 
4bbc			 
4bbc					NEXTW 
4bbc c3 c8 26			jp macro_next 
4bbf				endm 
# End of macro NEXTW
4bbf			 
4bbf			 
4bbf			.STR2NUM: 
4bbf				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4bbf 48				db WORD_SYS_CORE+52             
4bc0 4b 4c			dw .NUM2STR            
4bc2 08				db 7 + 1 
4bc3 .. 00			db "STR2NUM",0              
4bcb				endm 
# End of macro CWHEAD
4bcb			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4bcb			 
4bcb			 
4bcb			; TODO STR type check to do 
4bcb					if DEBUG_FORTH_WORDS_KEY 
4bcb						DMARK "S2N" 
4bcb f5				push af  
4bcc 3a e0 4b			ld a, (.dmark)  
4bcf 32 a6 fd			ld (debug_mark),a  
4bd2 3a e1 4b			ld a, (.dmark+1)  
4bd5 32 a7 fd			ld (debug_mark+1),a  
4bd8 3a e2 4b			ld a, (.dmark+2)  
4bdb 32 a8 fd			ld (debug_mark+2),a  
4bde 18 03			jr .pastdmark  
4be0 ..			.dmark: db "S2N"  
4be3 f1			.pastdmark: pop af  
4be4			endm  
# End of macro DMARK
4be4						CALLMONITOR 
4be4 cd aa fd			call debug_vector  
4be7				endm  
# End of macro CALLMONITOR
4be7					endif 
4be7			 
4be7					;FORTH_DSP 
4be7					FORTH_DSP_VALUE 
4be7 cd fb 24			call macro_forth_dsp_value 
4bea				endm 
# End of macro FORTH_DSP_VALUE
4bea					;inc hl 
4bea			 
4bea eb					ex de, hl 
4beb					if DEBUG_FORTH_WORDS 
4beb						DMARK "S2a" 
4beb f5				push af  
4bec 3a 00 4c			ld a, (.dmark)  
4bef 32 a6 fd			ld (debug_mark),a  
4bf2 3a 01 4c			ld a, (.dmark+1)  
4bf5 32 a7 fd			ld (debug_mark+1),a  
4bf8 3a 02 4c			ld a, (.dmark+2)  
4bfb 32 a8 fd			ld (debug_mark+2),a  
4bfe 18 03			jr .pastdmark  
4c00 ..			.dmark: db "S2a"  
4c03 f1			.pastdmark: pop af  
4c04			endm  
# End of macro DMARK
4c04						CALLMONITOR 
4c04 cd aa fd			call debug_vector  
4c07				endm  
# End of macro CALLMONITOR
4c07					endif 
4c07 cd dc 15				call string_to_uint16 
4c0a			 
4c0a					if DEBUG_FORTH_WORDS 
4c0a						DMARK "S2b" 
4c0a f5				push af  
4c0b 3a 1f 4c			ld a, (.dmark)  
4c0e 32 a6 fd			ld (debug_mark),a  
4c11 3a 20 4c			ld a, (.dmark+1)  
4c14 32 a7 fd			ld (debug_mark+1),a  
4c17 3a 21 4c			ld a, (.dmark+2)  
4c1a 32 a8 fd			ld (debug_mark+2),a  
4c1d 18 03			jr .pastdmark  
4c1f ..			.dmark: db "S2b"  
4c22 f1			.pastdmark: pop af  
4c23			endm  
# End of macro DMARK
4c23						CALLMONITOR 
4c23 cd aa fd			call debug_vector  
4c26				endm  
# End of macro CALLMONITOR
4c26					endif 
4c26			;		push hl 
4c26					FORTH_DSP_POP 
4c26 cd ca 25			call macro_forth_dsp_pop 
4c29				endm 
# End of macro FORTH_DSP_POP
4c29			;		pop hl 
4c29					 
4c29					if DEBUG_FORTH_WORDS 
4c29						DMARK "S2b" 
4c29 f5				push af  
4c2a 3a 3e 4c			ld a, (.dmark)  
4c2d 32 a6 fd			ld (debug_mark),a  
4c30 3a 3f 4c			ld a, (.dmark+1)  
4c33 32 a7 fd			ld (debug_mark+1),a  
4c36 3a 40 4c			ld a, (.dmark+2)  
4c39 32 a8 fd			ld (debug_mark+2),a  
4c3c 18 03			jr .pastdmark  
4c3e ..			.dmark: db "S2b"  
4c41 f1			.pastdmark: pop af  
4c42			endm  
# End of macro DMARK
4c42						CALLMONITOR 
4c42 cd aa fd			call debug_vector  
4c45				endm  
# End of macro CALLMONITOR
4c45					endif 
4c45 cd 1b 23				call forth_push_numhl	 
4c48			 
4c48				 
4c48				       NEXTW 
4c48 c3 c8 26			jp macro_next 
4c4b				endm 
# End of macro NEXTW
4c4b			.NUM2STR: 
4c4b				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4c4b 48				db WORD_SYS_CORE+52             
4c4c 5a 4c			dw .CONCAT            
4c4e 08				db 7 + 1 
4c4f .. 00			db "NUM2STR",0              
4c57				endm 
# End of macro CWHEAD
4c57			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4c57			 
4c57			;		; malloc a string to target 
4c57			;		ld hl, 10     ; TODO max string size should be fine 
4c57			;		call malloc 
4c57			;		push hl    ; save malloc location 
4c57			; 
4c57			; 
4c57			;; TODO check int type 
4c57			;		FORTH_DSP_VALUEHL 
4c57			;		ld a, l 
4c57			;		call DispAToASCII   
4c57			;;TODO need to chage above call to dump into string 
4c57			; 
4c57			; 
4c57			 
4c57				       NEXTW 
4c57 c3 c8 26			jp macro_next 
4c5a				endm 
# End of macro NEXTW
4c5a			 
4c5a			.CONCAT: 
4c5a				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4c5a 48				db WORD_SYS_CORE+52             
4c5b 0d 4d			dw .FIND            
4c5d 07				db 6 + 1 
4c5e .. 00			db "CONCAT",0              
4c65				endm 
# End of macro CWHEAD
4c65			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4c65			 
4c65			; TODO check string type 
4c65			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4c65			 
4c65					if DEBUG_FORTH_WORDS_KEY 
4c65						DMARK "CON" 
4c65 f5				push af  
4c66 3a 7a 4c			ld a, (.dmark)  
4c69 32 a6 fd			ld (debug_mark),a  
4c6c 3a 7b 4c			ld a, (.dmark+1)  
4c6f 32 a7 fd			ld (debug_mark+1),a  
4c72 3a 7c 4c			ld a, (.dmark+2)  
4c75 32 a8 fd			ld (debug_mark+2),a  
4c78 18 03			jr .pastdmark  
4c7a ..			.dmark: db "CON"  
4c7d f1			.pastdmark: pop af  
4c7e			endm  
# End of macro DMARK
4c7e						CALLMONITOR 
4c7e cd aa fd			call debug_vector  
4c81				endm  
# End of macro CALLMONITOR
4c81					endif 
4c81			 
4c81			 
4c81					FORTH_DSP_VALUE 
4c81 cd fb 24			call macro_forth_dsp_value 
4c84				endm 
# End of macro FORTH_DSP_VALUE
4c84 e5					push hl   ; s2 
4c85			 
4c85					FORTH_DSP_POP 
4c85 cd ca 25			call macro_forth_dsp_pop 
4c88				endm 
# End of macro FORTH_DSP_POP
4c88			 
4c88					FORTH_DSP_VALUE 
4c88 cd fb 24			call macro_forth_dsp_value 
4c8b				endm 
# End of macro FORTH_DSP_VALUE
4c8b			 
4c8b e5					push hl   ; s1 
4c8c			 
4c8c					FORTH_DSP_POP 
4c8c cd ca 25			call macro_forth_dsp_pop 
4c8f				endm 
# End of macro FORTH_DSP_POP
4c8f					 
4c8f			 
4c8f					; copy s1 
4c8f			 
4c8f				 
4c8f					; save ptr 
4c8f e1					pop hl  
4c90 e5					push hl 
4c91 3e 00				ld a, 0 
4c93 cd 50 16				call strlent 
4c96					;inc hl    ; zer0 
4c96 06 00				ld b, 0 
4c98 4d					ld c, l 
4c99 e1					pop hl		 
4c9a 11 fc f0				ld de, scratch	 
4c9d					if DEBUG_FORTH_WORDS 
4c9d						DMARK "CO1" 
4c9d f5				push af  
4c9e 3a b2 4c			ld a, (.dmark)  
4ca1 32 a6 fd			ld (debug_mark),a  
4ca4 3a b3 4c			ld a, (.dmark+1)  
4ca7 32 a7 fd			ld (debug_mark+1),a  
4caa 3a b4 4c			ld a, (.dmark+2)  
4cad 32 a8 fd			ld (debug_mark+2),a  
4cb0 18 03			jr .pastdmark  
4cb2 ..			.dmark: db "CO1"  
4cb5 f1			.pastdmark: pop af  
4cb6			endm  
# End of macro DMARK
4cb6						CALLMONITOR 
4cb6 cd aa fd			call debug_vector  
4cb9				endm  
# End of macro CALLMONITOR
4cb9					endif 
4cb9 ed b0				ldir 
4cbb			 
4cbb e1					pop hl 
4cbc e5					push hl 
4cbd d5					push de 
4cbe			 
4cbe			 
4cbe 3e 00				ld a, 0 
4cc0 cd 50 16				call strlent 
4cc3 23					inc hl    ; zer0 
4cc4 23					inc hl 
4cc5 06 00				ld b, 0 
4cc7 4d					ld c, l 
4cc8 d1					pop de 
4cc9 e1					pop hl		 
4cca					if DEBUG_FORTH_WORDS 
4cca						DMARK "CO2" 
4cca f5				push af  
4ccb 3a df 4c			ld a, (.dmark)  
4cce 32 a6 fd			ld (debug_mark),a  
4cd1 3a e0 4c			ld a, (.dmark+1)  
4cd4 32 a7 fd			ld (debug_mark+1),a  
4cd7 3a e1 4c			ld a, (.dmark+2)  
4cda 32 a8 fd			ld (debug_mark+2),a  
4cdd 18 03			jr .pastdmark  
4cdf ..			.dmark: db "CO2"  
4ce2 f1			.pastdmark: pop af  
4ce3			endm  
# End of macro DMARK
4ce3						CALLMONITOR 
4ce3 cd aa fd			call debug_vector  
4ce6				endm  
# End of macro CALLMONITOR
4ce6					endif 
4ce6 ed b0				ldir 
4ce8			 
4ce8			 
4ce8			 
4ce8 21 fc f0				ld hl, scratch 
4ceb					if DEBUG_FORTH_WORDS 
4ceb						DMARK "CO5" 
4ceb f5				push af  
4cec 3a 00 4d			ld a, (.dmark)  
4cef 32 a6 fd			ld (debug_mark),a  
4cf2 3a 01 4d			ld a, (.dmark+1)  
4cf5 32 a7 fd			ld (debug_mark+1),a  
4cf8 3a 02 4d			ld a, (.dmark+2)  
4cfb 32 a8 fd			ld (debug_mark+2),a  
4cfe 18 03			jr .pastdmark  
4d00 ..			.dmark: db "CO5"  
4d03 f1			.pastdmark: pop af  
4d04			endm  
# End of macro DMARK
4d04						CALLMONITOR 
4d04 cd aa fd			call debug_vector  
4d07				endm  
# End of macro CALLMONITOR
4d07					endif 
4d07			 
4d07 cd 89 23				call forth_push_str 
4d0a			 
4d0a			 
4d0a			 
4d0a			 
4d0a				       NEXTW 
4d0a c3 c8 26			jp macro_next 
4d0d				endm 
# End of macro NEXTW
4d0d			 
4d0d			 
4d0d			.FIND: 
4d0d				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4d0d 4b				db WORD_SYS_CORE+55             
4d0e cb 4d			dw .LEN            
4d10 05				db 4 + 1 
4d11 .. 00			db "FIND",0              
4d16				endm 
# End of macro CWHEAD
4d16			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4d16			 
4d16					if DEBUG_FORTH_WORDS_KEY 
4d16						DMARK "FND" 
4d16 f5				push af  
4d17 3a 2b 4d			ld a, (.dmark)  
4d1a 32 a6 fd			ld (debug_mark),a  
4d1d 3a 2c 4d			ld a, (.dmark+1)  
4d20 32 a7 fd			ld (debug_mark+1),a  
4d23 3a 2d 4d			ld a, (.dmark+2)  
4d26 32 a8 fd			ld (debug_mark+2),a  
4d29 18 03			jr .pastdmark  
4d2b ..			.dmark: db "FND"  
4d2e f1			.pastdmark: pop af  
4d2f			endm  
# End of macro DMARK
4d2f						CALLMONITOR 
4d2f cd aa fd			call debug_vector  
4d32				endm  
# End of macro CALLMONITOR
4d32					endif 
4d32			 
4d32			; TODO check string type 
4d32					FORTH_DSP_VALUE 
4d32 cd fb 24			call macro_forth_dsp_value 
4d35				endm 
# End of macro FORTH_DSP_VALUE
4d35			 
4d35 e5					push hl    
4d36 7e					ld a,(hl)    ; char to find   
4d37			; TODO change char to substr 
4d37			 
4d37 f5					push af 
4d38					 
4d38			 
4d38			 
4d38					if DEBUG_FORTH_WORDS 
4d38						DMARK "FN1" 
4d38 f5				push af  
4d39 3a 4d 4d			ld a, (.dmark)  
4d3c 32 a6 fd			ld (debug_mark),a  
4d3f 3a 4e 4d			ld a, (.dmark+1)  
4d42 32 a7 fd			ld (debug_mark+1),a  
4d45 3a 4f 4d			ld a, (.dmark+2)  
4d48 32 a8 fd			ld (debug_mark+2),a  
4d4b 18 03			jr .pastdmark  
4d4d ..			.dmark: db "FN1"  
4d50 f1			.pastdmark: pop af  
4d51			endm  
# End of macro DMARK
4d51						CALLMONITOR 
4d51 cd aa fd			call debug_vector  
4d54				endm  
# End of macro CALLMONITOR
4d54					endif 
4d54			 
4d54					FORTH_DSP_POP 
4d54 cd ca 25			call macro_forth_dsp_pop 
4d57				endm 
# End of macro FORTH_DSP_POP
4d57			 
4d57					; string to search 
4d57			 
4d57					FORTH_DSP_VALUE 
4d57 cd fb 24			call macro_forth_dsp_value 
4d5a				endm 
# End of macro FORTH_DSP_VALUE
4d5a			 
4d5a d1					pop de  ; d is char to find  
4d5b			 
4d5b					if DEBUG_FORTH_WORDS 
4d5b						DMARK "FN2" 
4d5b f5				push af  
4d5c 3a 70 4d			ld a, (.dmark)  
4d5f 32 a6 fd			ld (debug_mark),a  
4d62 3a 71 4d			ld a, (.dmark+1)  
4d65 32 a7 fd			ld (debug_mark+1),a  
4d68 3a 72 4d			ld a, (.dmark+2)  
4d6b 32 a8 fd			ld (debug_mark+2),a  
4d6e 18 03			jr .pastdmark  
4d70 ..			.dmark: db "FN2"  
4d73 f1			.pastdmark: pop af  
4d74			endm  
# End of macro DMARK
4d74						CALLMONITOR 
4d74 cd aa fd			call debug_vector  
4d77				endm  
# End of macro CALLMONITOR
4d77					endif 
4d77					 
4d77 01 00 00				ld bc, 0 
4d7a 7e			.findchar:      ld a,(hl) 
4d7b fe 00				cp 0   		 
4d7d 28 27				jr z, .finddone     
4d7f ba					cp d 
4d80 28 20				jr z, .foundchar 
4d82 03					inc bc 
4d83 23					inc hl 
4d84					if DEBUG_FORTH_WORDS 
4d84						DMARK "FN3" 
4d84 f5				push af  
4d85 3a 99 4d			ld a, (.dmark)  
4d88 32 a6 fd			ld (debug_mark),a  
4d8b 3a 9a 4d			ld a, (.dmark+1)  
4d8e 32 a7 fd			ld (debug_mark+1),a  
4d91 3a 9b 4d			ld a, (.dmark+2)  
4d94 32 a8 fd			ld (debug_mark+2),a  
4d97 18 03			jr .pastdmark  
4d99 ..			.dmark: db "FN3"  
4d9c f1			.pastdmark: pop af  
4d9d			endm  
# End of macro DMARK
4d9d						CALLMONITOR 
4d9d cd aa fd			call debug_vector  
4da0				endm  
# End of macro CALLMONITOR
4da0					endif 
4da0 18 d8				jr .findchar 
4da2			 
4da2			 
4da2 c5			.foundchar:	push bc 
4da3 e1					pop hl 
4da4 18 03				jr .findexit 
4da6			 
4da6			 
4da6							 
4da6			 
4da6			.finddone:     ; got to end of string with no find 
4da6 21 00 00				ld hl, 0 
4da9			.findexit: 
4da9			 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "FNd" 
4da9 f5				push af  
4daa 3a be 4d			ld a, (.dmark)  
4dad 32 a6 fd			ld (debug_mark),a  
4db0 3a bf 4d			ld a, (.dmark+1)  
4db3 32 a7 fd			ld (debug_mark+1),a  
4db6 3a c0 4d			ld a, (.dmark+2)  
4db9 32 a8 fd			ld (debug_mark+2),a  
4dbc 18 03			jr .pastdmark  
4dbe ..			.dmark: db "FNd"  
4dc1 f1			.pastdmark: pop af  
4dc2			endm  
# End of macro DMARK
4dc2						CALLMONITOR 
4dc2 cd aa fd			call debug_vector  
4dc5				endm  
# End of macro CALLMONITOR
4dc5					endif 
4dc5 cd 1b 23			call forth_push_numhl 
4dc8			 
4dc8				       NEXTW 
4dc8 c3 c8 26			jp macro_next 
4dcb				endm 
# End of macro NEXTW
4dcb			 
4dcb			.LEN: 
4dcb				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4dcb 4c				db WORD_SYS_CORE+56             
4dcc 35 4e			dw .ASC            
4dce 06				db 5 + 1 
4dcf .. 00			db "COUNT",0              
4dd5				endm 
# End of macro CWHEAD
4dd5			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4dd5			 
4dd5					if DEBUG_FORTH_WORDS_KEY 
4dd5						DMARK "CNT" 
4dd5 f5				push af  
4dd6 3a ea 4d			ld a, (.dmark)  
4dd9 32 a6 fd			ld (debug_mark),a  
4ddc 3a eb 4d			ld a, (.dmark+1)  
4ddf 32 a7 fd			ld (debug_mark+1),a  
4de2 3a ec 4d			ld a, (.dmark+2)  
4de5 32 a8 fd			ld (debug_mark+2),a  
4de8 18 03			jr .pastdmark  
4dea ..			.dmark: db "CNT"  
4ded f1			.pastdmark: pop af  
4dee			endm  
# End of macro DMARK
4dee						CALLMONITOR 
4dee cd aa fd			call debug_vector  
4df1				endm  
# End of macro CALLMONITOR
4df1					endif 
4df1			; TODO check string type 
4df1					FORTH_DSP_VALUE 
4df1 cd fb 24			call macro_forth_dsp_value 
4df4				endm 
# End of macro FORTH_DSP_VALUE
4df4			 
4df4			 
4df4					if DEBUG_FORTH_WORDS 
4df4						DMARK "CN?" 
4df4 f5				push af  
4df5 3a 09 4e			ld a, (.dmark)  
4df8 32 a6 fd			ld (debug_mark),a  
4dfb 3a 0a 4e			ld a, (.dmark+1)  
4dfe 32 a7 fd			ld (debug_mark+1),a  
4e01 3a 0b 4e			ld a, (.dmark+2)  
4e04 32 a8 fd			ld (debug_mark+2),a  
4e07 18 03			jr .pastdmark  
4e09 ..			.dmark: db "CN?"  
4e0c f1			.pastdmark: pop af  
4e0d			endm  
# End of macro DMARK
4e0d						CALLMONITOR 
4e0d cd aa fd			call debug_vector  
4e10				endm  
# End of macro CALLMONITOR
4e10					endif 
4e10 cd 45 16				call strlenz 
4e13					if DEBUG_FORTH_WORDS 
4e13						DMARK "CNl" 
4e13 f5				push af  
4e14 3a 28 4e			ld a, (.dmark)  
4e17 32 a6 fd			ld (debug_mark),a  
4e1a 3a 29 4e			ld a, (.dmark+1)  
4e1d 32 a7 fd			ld (debug_mark+1),a  
4e20 3a 2a 4e			ld a, (.dmark+2)  
4e23 32 a8 fd			ld (debug_mark+2),a  
4e26 18 03			jr .pastdmark  
4e28 ..			.dmark: db "CNl"  
4e2b f1			.pastdmark: pop af  
4e2c			endm  
# End of macro DMARK
4e2c						CALLMONITOR 
4e2c cd aa fd			call debug_vector  
4e2f				endm  
# End of macro CALLMONITOR
4e2f					endif 
4e2f			 
4e2f cd 1b 23				call forth_push_numhl 
4e32			 
4e32			 
4e32			 
4e32				       NEXTW 
4e32 c3 c8 26			jp macro_next 
4e35				endm 
# End of macro NEXTW
4e35			.ASC: 
4e35				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4e35 4d				db WORD_SYS_CORE+57             
4e36 a3 4e			dw .CHR            
4e38 04				db 3 + 1 
4e39 .. 00			db "ASC",0              
4e3d				endm 
# End of macro CWHEAD
4e3d			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4e3d					if DEBUG_FORTH_WORDS_KEY 
4e3d						DMARK "ASC" 
4e3d f5				push af  
4e3e 3a 52 4e			ld a, (.dmark)  
4e41 32 a6 fd			ld (debug_mark),a  
4e44 3a 53 4e			ld a, (.dmark+1)  
4e47 32 a7 fd			ld (debug_mark+1),a  
4e4a 3a 54 4e			ld a, (.dmark+2)  
4e4d 32 a8 fd			ld (debug_mark+2),a  
4e50 18 03			jr .pastdmark  
4e52 ..			.dmark: db "ASC"  
4e55 f1			.pastdmark: pop af  
4e56			endm  
# End of macro DMARK
4e56						CALLMONITOR 
4e56 cd aa fd			call debug_vector  
4e59				endm  
# End of macro CALLMONITOR
4e59					endif 
4e59					FORTH_DSP_VALUE 
4e59 cd fb 24			call macro_forth_dsp_value 
4e5c				endm 
# End of macro FORTH_DSP_VALUE
4e5c					;v5 FORTH_DSP_VALUE 
4e5c			;		inc hl      ; now at start of numeric as string 
4e5c			 
4e5c e5					push hl 
4e5d			 
4e5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e5d cd ca 25			call macro_forth_dsp_pop 
4e60				endm 
# End of macro FORTH_DSP_POP
4e60			 
4e60 e1					pop hl 
4e61			 
4e61					if DEBUG_FORTH_WORDS 
4e61						DMARK "AS1" 
4e61 f5				push af  
4e62 3a 76 4e			ld a, (.dmark)  
4e65 32 a6 fd			ld (debug_mark),a  
4e68 3a 77 4e			ld a, (.dmark+1)  
4e6b 32 a7 fd			ld (debug_mark+1),a  
4e6e 3a 78 4e			ld a, (.dmark+2)  
4e71 32 a8 fd			ld (debug_mark+2),a  
4e74 18 03			jr .pastdmark  
4e76 ..			.dmark: db "AS1"  
4e79 f1			.pastdmark: pop af  
4e7a			endm  
# End of macro DMARK
4e7a						CALLMONITOR 
4e7a cd aa fd			call debug_vector  
4e7d				endm  
# End of macro CALLMONITOR
4e7d					endif 
4e7d					; push the content of a onto the stack as a value 
4e7d			 
4e7d 7e					ld a,(hl)   ; get char 
4e7e 26 00				ld h,0 
4e80 6f					ld l,a 
4e81					if DEBUG_FORTH_WORDS 
4e81						DMARK "AS2" 
4e81 f5				push af  
4e82 3a 96 4e			ld a, (.dmark)  
4e85 32 a6 fd			ld (debug_mark),a  
4e88 3a 97 4e			ld a, (.dmark+1)  
4e8b 32 a7 fd			ld (debug_mark+1),a  
4e8e 3a 98 4e			ld a, (.dmark+2)  
4e91 32 a8 fd			ld (debug_mark+2),a  
4e94 18 03			jr .pastdmark  
4e96 ..			.dmark: db "AS2"  
4e99 f1			.pastdmark: pop af  
4e9a			endm  
# End of macro DMARK
4e9a						CALLMONITOR 
4e9a cd aa fd			call debug_vector  
4e9d				endm  
# End of macro CALLMONITOR
4e9d					endif 
4e9d cd 1b 23				call forth_push_numhl 
4ea0			 
4ea0				       NEXTW 
4ea0 c3 c8 26			jp macro_next 
4ea3				endm 
# End of macro NEXTW
4ea3			 
4ea3			.CHR: 
4ea3				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4ea3 4d				db WORD_SYS_CORE+57             
4ea4 df 4e			dw .ENDSTR            
4ea6 04				db 3 + 1 
4ea7 .. 00			db "CHR",0              
4eab				endm 
# End of macro CWHEAD
4eab			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4eab					if DEBUG_FORTH_WORDS_KEY 
4eab						DMARK "CHR" 
4eab f5				push af  
4eac 3a c0 4e			ld a, (.dmark)  
4eaf 32 a6 fd			ld (debug_mark),a  
4eb2 3a c1 4e			ld a, (.dmark+1)  
4eb5 32 a7 fd			ld (debug_mark+1),a  
4eb8 3a c2 4e			ld a, (.dmark+2)  
4ebb 32 a8 fd			ld (debug_mark+2),a  
4ebe 18 03			jr .pastdmark  
4ec0 ..			.dmark: db "CHR"  
4ec3 f1			.pastdmark: pop af  
4ec4			endm  
# End of macro DMARK
4ec4						CALLMONITOR 
4ec4 cd aa fd			call debug_vector  
4ec7				endm  
# End of macro CALLMONITOR
4ec7					endif 
4ec7					FORTH_DSP_VALUEHL 
4ec7 cd 12 25			call macro_dsp_valuehl 
4eca				endm 
# End of macro FORTH_DSP_VALUEHL
4eca			 
4eca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eca cd ca 25			call macro_forth_dsp_pop 
4ecd				endm 
# End of macro FORTH_DSP_POP
4ecd			 
4ecd					; save asci byte as a zero term string and push string 
4ecd			 
4ecd 7d					ld a,l 
4ece 32 fc f0				ld (scratch), a 
4ed1			 
4ed1 3e 00				ld a, 0 
4ed3 32 fd f0				ld (scratch+1), a 
4ed6			 
4ed6 21 fc f0				ld hl, scratch 
4ed9 cd 89 23				call forth_push_str 
4edc			 
4edc			 
4edc				       NEXTW 
4edc c3 c8 26			jp macro_next 
4edf				endm 
# End of macro NEXTW
4edf			 
4edf			 
4edf			 
4edf			 
4edf			.ENDSTR: 
4edf			; eof 
4edf			 
# End of file forth_words_str.asm
4edf			include "forth_words_key.asm" 
4edf			 
4edf			; | ## Keyboard Words 
4edf			 
4edf			.KEY: 
4edf				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4edf 3e				db WORD_SYS_CORE+42             
4ee0 0f 4f			dw .WAITK            
4ee2 04				db 3 + 1 
4ee3 .. 00			db "KEY",0              
4ee7				endm 
# End of macro CWHEAD
4ee7			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4ee7			 
4ee7					if DEBUG_FORTH_WORDS_KEY 
4ee7						DMARK "KEY" 
4ee7 f5				push af  
4ee8 3a fc 4e			ld a, (.dmark)  
4eeb 32 a6 fd			ld (debug_mark),a  
4eee 3a fd 4e			ld a, (.dmark+1)  
4ef1 32 a7 fd			ld (debug_mark+1),a  
4ef4 3a fe 4e			ld a, (.dmark+2)  
4ef7 32 a8 fd			ld (debug_mark+2),a  
4efa 18 03			jr .pastdmark  
4efc ..			.dmark: db "KEY"  
4eff f1			.pastdmark: pop af  
4f00			endm  
# End of macro DMARK
4f00						CALLMONITOR 
4f00 cd aa fd			call debug_vector  
4f03				endm  
# End of macro CALLMONITOR
4f03					endif 
4f03			; TODO currently waits 
4f03 cd 95 7c				call cin 
4f06					;call cin_wait 
4f06 6f					ld l, a 
4f07 26 00				ld h, 0 
4f09 cd 1b 23				call forth_push_numhl 
4f0c					NEXTW 
4f0c c3 c8 26			jp macro_next 
4f0f				endm 
# End of macro NEXTW
4f0f			.WAITK: 
4f0f				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4f0f 3f				db WORD_SYS_CORE+43             
4f10 41 4f			dw .ACCEPT            
4f12 06				db 5 + 1 
4f13 .. 00			db "WAITK",0              
4f19				endm 
# End of macro CWHEAD
4f19			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4f19					if DEBUG_FORTH_WORDS_KEY 
4f19						DMARK "WAI" 
4f19 f5				push af  
4f1a 3a 2e 4f			ld a, (.dmark)  
4f1d 32 a6 fd			ld (debug_mark),a  
4f20 3a 2f 4f			ld a, (.dmark+1)  
4f23 32 a7 fd			ld (debug_mark+1),a  
4f26 3a 30 4f			ld a, (.dmark+2)  
4f29 32 a8 fd			ld (debug_mark+2),a  
4f2c 18 03			jr .pastdmark  
4f2e ..			.dmark: db "WAI"  
4f31 f1			.pastdmark: pop af  
4f32			endm  
# End of macro DMARK
4f32						CALLMONITOR 
4f32 cd aa fd			call debug_vector  
4f35				endm  
# End of macro CALLMONITOR
4f35					endif 
4f35 cd 84 7c				call cin_wait 
4f38 6f					ld l, a 
4f39 26 00				ld h, 0 
4f3b cd 1b 23				call forth_push_numhl 
4f3e					NEXTW 
4f3e c3 c8 26			jp macro_next 
4f41				endm 
# End of macro NEXTW
4f41			.ACCEPT: 
4f41				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4f41 40				db WORD_SYS_CORE+44             
4f42 9f 4f			dw .EDIT            
4f44 07				db 6 + 1 
4f45 .. 00			db "ACCEPT",0              
4f4c				endm 
# End of macro CWHEAD
4f4c			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4f4c					; TODO crashes on push 
4f4c					if DEBUG_FORTH_WORDS_KEY 
4f4c						DMARK "ACC" 
4f4c f5				push af  
4f4d 3a 61 4f			ld a, (.dmark)  
4f50 32 a6 fd			ld (debug_mark),a  
4f53 3a 62 4f			ld a, (.dmark+1)  
4f56 32 a7 fd			ld (debug_mark+1),a  
4f59 3a 63 4f			ld a, (.dmark+2)  
4f5c 32 a8 fd			ld (debug_mark+2),a  
4f5f 18 03			jr .pastdmark  
4f61 ..			.dmark: db "ACC"  
4f64 f1			.pastdmark: pop af  
4f65			endm  
# End of macro DMARK
4f65						CALLMONITOR 
4f65 cd aa fd			call debug_vector  
4f68				endm  
# End of macro CALLMONITOR
4f68					endif 
4f68 21 fa f2				ld hl, os_input 
4f6b 3e 00				ld a, 0 
4f6d 77					ld (hl),a 
4f6e 3a 99 f9				ld a,(f_cursor_ptr) 
4f71 16 64				ld d, 100 
4f73 0e 00				ld c, 0 
4f75 1e 28				ld e, 40 
4f77 cd fc 0f				call input_str 
4f7a					; TODO perhaps do a type check and wrap in quotes if not a number 
4f7a 21 fa f2				ld hl, os_input 
4f7d					if DEBUG_FORTH_WORDS 
4f7d						DMARK "AC1" 
4f7d f5				push af  
4f7e 3a 92 4f			ld a, (.dmark)  
4f81 32 a6 fd			ld (debug_mark),a  
4f84 3a 93 4f			ld a, (.dmark+1)  
4f87 32 a7 fd			ld (debug_mark+1),a  
4f8a 3a 94 4f			ld a, (.dmark+2)  
4f8d 32 a8 fd			ld (debug_mark+2),a  
4f90 18 03			jr .pastdmark  
4f92 ..			.dmark: db "AC1"  
4f95 f1			.pastdmark: pop af  
4f96			endm  
# End of macro DMARK
4f96						CALLMONITOR 
4f96 cd aa fd			call debug_vector  
4f99				endm  
# End of macro CALLMONITOR
4f99					endif 
4f99 cd 89 23				call forth_push_str 
4f9c					NEXTW 
4f9c c3 c8 26			jp macro_next 
4f9f				endm 
# End of macro NEXTW
4f9f			 
4f9f			.EDIT: 
4f9f				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4f9f 40				db WORD_SYS_CORE+44             
4fa0 41 50			dw .DEDIT            
4fa2 05				db 4 + 1 
4fa3 .. 00			db "EDIT",0              
4fa8				endm 
# End of macro CWHEAD
4fa8			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4fa8			 
4fa8					; TODO does not copy from stack 
4fa8					if DEBUG_FORTH_WORDS_KEY 
4fa8						DMARK "EDT" 
4fa8 f5				push af  
4fa9 3a bd 4f			ld a, (.dmark)  
4fac 32 a6 fd			ld (debug_mark),a  
4faf 3a be 4f			ld a, (.dmark+1)  
4fb2 32 a7 fd			ld (debug_mark+1),a  
4fb5 3a bf 4f			ld a, (.dmark+2)  
4fb8 32 a8 fd			ld (debug_mark+2),a  
4fbb 18 03			jr .pastdmark  
4fbd ..			.dmark: db "EDT"  
4fc0 f1			.pastdmark: pop af  
4fc1			endm  
# End of macro DMARK
4fc1						CALLMONITOR 
4fc1 cd aa fd			call debug_vector  
4fc4				endm  
# End of macro CALLMONITOR
4fc4					endif 
4fc4			 
4fc4					;FORTH_DSP 
4fc4					FORTH_DSP_VALUEHL 
4fc4 cd 12 25			call macro_dsp_valuehl 
4fc7				endm 
# End of macro FORTH_DSP_VALUEHL
4fc7			;		inc hl    ; TODO do type check 
4fc7			 
4fc7			;		call get_word_hl 
4fc7 e5					push hl 
4fc8					if DEBUG_FORTH_WORDS 
4fc8						DMARK "EDp" 
4fc8 f5				push af  
4fc9 3a dd 4f			ld a, (.dmark)  
4fcc 32 a6 fd			ld (debug_mark),a  
4fcf 3a de 4f			ld a, (.dmark+1)  
4fd2 32 a7 fd			ld (debug_mark+1),a  
4fd5 3a df 4f			ld a, (.dmark+2)  
4fd8 32 a8 fd			ld (debug_mark+2),a  
4fdb 18 03			jr .pastdmark  
4fdd ..			.dmark: db "EDp"  
4fe0 f1			.pastdmark: pop af  
4fe1			endm  
# End of macro DMARK
4fe1						CALLMONITOR 
4fe1 cd aa fd			call debug_vector  
4fe4				endm  
# End of macro CALLMONITOR
4fe4					endif 
4fe4				;	ld a, 0 
4fe4 cd 45 16				call strlenz 
4fe7 23					inc hl 
4fe8			 
4fe8 06 00				ld b, 0 
4fea 4d					ld c, l 
4feb			 
4feb e1					pop hl 
4fec 11 fa f2				ld de, os_input 
4fef					if DEBUG_FORTH_WORDS_KEY 
4fef						DMARK "EDc" 
4fef f5				push af  
4ff0 3a 04 50			ld a, (.dmark)  
4ff3 32 a6 fd			ld (debug_mark),a  
4ff6 3a 05 50			ld a, (.dmark+1)  
4ff9 32 a7 fd			ld (debug_mark+1),a  
4ffc 3a 06 50			ld a, (.dmark+2)  
4fff 32 a8 fd			ld (debug_mark+2),a  
5002 18 03			jr .pastdmark  
5004 ..			.dmark: db "EDc"  
5007 f1			.pastdmark: pop af  
5008			endm  
# End of macro DMARK
5008						CALLMONITOR 
5008 cd aa fd			call debug_vector  
500b				endm  
# End of macro CALLMONITOR
500b					endif 
500b ed b0				ldir 
500d			 
500d			 
500d 21 fa f2				ld hl, os_input 
5010					;ld a, 0 
5010					;ld (hl),a 
5010 3a 99 f9				ld a,(f_cursor_ptr) 
5013 16 64				ld d, 100 
5015 0e 00				ld c, 0 
5017 1e 28				ld e, 40 
5019 cd fc 0f				call input_str 
501c					; TODO perhaps do a type check and wrap in quotes if not a number 
501c 21 fa f2				ld hl, os_input 
501f					if DEBUG_FORTH_WORDS 
501f						DMARK "ED1" 
501f f5				push af  
5020 3a 34 50			ld a, (.dmark)  
5023 32 a6 fd			ld (debug_mark),a  
5026 3a 35 50			ld a, (.dmark+1)  
5029 32 a7 fd			ld (debug_mark+1),a  
502c 3a 36 50			ld a, (.dmark+2)  
502f 32 a8 fd			ld (debug_mark+2),a  
5032 18 03			jr .pastdmark  
5034 ..			.dmark: db "ED1"  
5037 f1			.pastdmark: pop af  
5038			endm  
# End of macro DMARK
5038						CALLMONITOR 
5038 cd aa fd			call debug_vector  
503b				endm  
# End of macro CALLMONITOR
503b					endif 
503b cd 89 23				call forth_push_str 
503e					NEXTW 
503e c3 c8 26			jp macro_next 
5041				endm 
# End of macro NEXTW
5041			 
5041			.DEDIT: 
5041				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
5041 40				db WORD_SYS_CORE+44             
5042 a3 50			dw .ENDKEY            
5044 06				db 5 + 1 
5045 .. 00			db "DEDIT",0              
504b				endm 
# End of macro CWHEAD
504b			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
504b			 
504b					; TODO does not copy from stack 
504b					if DEBUG_FORTH_WORDS_KEY 
504b						DMARK "DED" 
504b f5				push af  
504c 3a 60 50			ld a, (.dmark)  
504f 32 a6 fd			ld (debug_mark),a  
5052 3a 61 50			ld a, (.dmark+1)  
5055 32 a7 fd			ld (debug_mark+1),a  
5058 3a 62 50			ld a, (.dmark+2)  
505b 32 a8 fd			ld (debug_mark+2),a  
505e 18 03			jr .pastdmark  
5060 ..			.dmark: db "DED"  
5063 f1			.pastdmark: pop af  
5064			endm  
# End of macro DMARK
5064						CALLMONITOR 
5064 cd aa fd			call debug_vector  
5067				endm  
# End of macro CALLMONITOR
5067					endif 
5067			 
5067					;FORTH_DSP 
5067					FORTH_DSP_VALUEHL 
5067 cd 12 25			call macro_dsp_valuehl 
506a				endm 
# End of macro FORTH_DSP_VALUEHL
506a			;		inc hl    ; TODO do type check 
506a			 
506a			;		call get_word_hl 
506a e5					push hl 
506b e5					push hl 
506c					FORTH_DSP_POP 
506c cd ca 25			call macro_forth_dsp_pop 
506f				endm 
# End of macro FORTH_DSP_POP
506f e1					pop hl 
5070					if DEBUG_FORTH_WORDS 
5070						DMARK "EDp" 
5070 f5				push af  
5071 3a 85 50			ld a, (.dmark)  
5074 32 a6 fd			ld (debug_mark),a  
5077 3a 86 50			ld a, (.dmark+1)  
507a 32 a7 fd			ld (debug_mark+1),a  
507d 3a 87 50			ld a, (.dmark+2)  
5080 32 a8 fd			ld (debug_mark+2),a  
5083 18 03			jr .pastdmark  
5085 ..			.dmark: db "EDp"  
5088 f1			.pastdmark: pop af  
5089			endm  
# End of macro DMARK
5089						CALLMONITOR 
5089 cd aa fd			call debug_vector  
508c				endm  
# End of macro CALLMONITOR
508c					endif 
508c				;	ld a, 0 
508c cd 45 16				call strlenz 
508f 23					inc hl 
5090			 
5090 06 00				ld b, 0 
5092 4d					ld c, l 
5093			 
5093 e1					pop hl 
5094			 
5094					;ld a, 0 
5094					;ld (hl),a 
5094 3a 99 f9				ld a,(f_cursor_ptr) 
5097 16 64				ld d, 100 
5099 0e 00				ld c, 0 
509b 1e 28				ld e, 40 
509d cd fc 0f				call input_str 
50a0					; TODO perhaps do a type check and wrap in quotes if not a number 
50a0					NEXTW 
50a0 c3 c8 26			jp macro_next 
50a3				endm 
# End of macro NEXTW
50a3			 
50a3			 
50a3			.ENDKEY: 
50a3			; eof 
50a3			 
# End of file forth_words_key.asm
50a3			include "forth_words_const.asm" 
50a3			 
50a3			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
50a3			 
50a3			 
50a3			.SPITIME: 
50a3				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
50a3 77				db WORD_SYS_CORE+99             
50a4 b8 50			dw .VA            
50a6 08				db 7 + 1 
50a7 .. 00			db "SPITIME",0              
50af				endm 
# End of macro CWHEAD
50af			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
50af			; 
50af			; | | If using BANK devices then leave as is. 
50af			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
50af			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
50af			 
50af 21 9f f9				ld hl, spi_clktime  
50b2 cd 1b 23				call forth_push_numhl 
50b5			 
50b5					NEXTW 
50b5 c3 c8 26			jp macro_next 
50b8				endm 
# End of macro NEXTW
50b8			 
50b8			 
50b8			.VA: 
50b8				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
50b8 77				db WORD_SYS_CORE+99             
50b9 c8 50			dw .SYMBOL            
50bb 03				db 2 + 1 
50bc .. 00			db "VA",0              
50bf				endm 
# End of macro CWHEAD
50bf			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
50bf 21 63 f9				ld hl, cli_var_array 
50c2 cd 1b 23				call forth_push_numhl 
50c5			 
50c5					NEXTW 
50c5 c3 c8 26			jp macro_next 
50c8				endm 
# End of macro NEXTW
50c8			 
50c8			.SYMBOL: 
50c8				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
50c8 77				db WORD_SYS_CORE+99             
50c9 d2 51			dw .ENDCONST            
50cb 07				db 6 + 1 
50cc .. 00			db "SYMBOL",0              
50d3				endm 
# End of macro CWHEAD
50d3			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
50d3			; | 
50d3			; | | The value is the number reference and the final address is pushed to stack 
50d3			 
50d3			; | | ``` 
50d3			; | | dw sym_table 
50d3			; | | dw nmi_vector 
50d3			; | | dw cli_autodisplay 
50d3			; | | dw cli_data_sp 
50d3			; | | dw cli_data_stack 
50d3			; | | dw cli_loop_sp 
50d3			; | | dw cli_loop_stack 
50d3			; | | dw cli_var_array 
50d3			; | | dw cursor_col 
50d3			; | | dw cursor_ptr 
50d3			; | | ; 10 
50d3			; | | dw cursor_row 
50d3			; | | dw debug_mark 
50d3			; | | dw display_fb0 
50d3			; | | dw display_fb1 
50d3			; | | dw display_fb2 
50d3			; | | dw display_fb3 
50d3			; | | dw display_fb_active 
50d3			; | | dw execscratch 
50d3			; | | dw f_cursor_ptr 
50d3			; | | dw hardware_word 
50d3			; | | ;20 
50d3			; | | dw input_at_cursor 
50d3			; | | dw input_at_pos 
50d3			; | | dw input_cur_flash 
50d3			; | | dw input_cur_onoff 
50d3			; | | dw input_cursor 
50d3			; | | dw input_display_size 
50d3			; | | dw input_len 
50d3			; | | dw input_ptr 
50d3			; | | dw input_size 
50d3			; | | dw input_start 
50d3			; | | ; 30 
50d3			; | | dw input_str 
50d3			; | | dw input_under_cursor 
50d3			; | | dw os_cli_cmd 
50d3			; | | dw os_cur_ptr 
50d3			; | | dw os_current_i 
50d3			; | | dw os_input 
50d3			; | | dw os_last_cmd 
50d3			; | | dw os_last_new_uword 
50d3			; | | dw debug_vector 
50d3			; | | dw os_view_hl 
50d3			; | | ;40 
50d3			; | | dw os_word_scratch 
50d3			; | | dw portbctl 
50d3			; | | dw portbdata 
50d3			; | | dw spi_cartdev 
50d3			; | | dw spi_cartdev2 
50d3			; | | dw spi_clktime 
50d3			; | | dw spi_device 
50d3			; | | dw spi_device_id 
50d3			; | | dw spi_portbyte 
50d3			; | | dw stackstore 
50d3			; | | ; 50 
50d3			; | | if STORAGE_SE 
50d3			; | | dw storage_actl 
50d3			; | | dw storage_adata 
50d3			; | | else 
50d3			; | | dw 0 
50d3			; | | dw 0 
50d3			; | | endif 
50d3			; | | dw storage_append 
50d3			; | | if STORAGE_SE 
50d3			; | | dw storage_bctl 
50d3			; | | else 
50d3			; | | dw 0 
50d3			; | | endif 
50d3			; | | dw store_bank_active 
50d3			; | | dw store_filecache 
50d3			; | | dw store_longread 
50d3			; | | dw store_openaddr 
50d3			; | | dw store_openext 
50d3			; | | dw store_openmaxext 
50d3			; | | ; 60 
50d3			; | | dw store_page 
50d3			; | | dw store_readbuf 
50d3			; | | dw store_readcont 
50d3			; | | dw store_readptr 
50d3			; | | dw store_tmpext 
50d3			; | | dw store_tmpid 
50d3			; | | dw store_tmppageid 
50d3			; | | dw malloc 
50d3			; | | dw free 
50d3			; | | dw cin 
50d3			; | | ; 70 
50d3			; | | dw cin_wait 
50d3			; | | dw forth_push_numhl 
50d3			; | | dw forth_push_str 
50d3			; | | ``` 
50d3			 
50d3					if DEBUG_FORTH_WORDS_KEY 
50d3						DMARK "SYM" 
50d3 f5				push af  
50d4 3a e8 50			ld a, (.dmark)  
50d7 32 a6 fd			ld (debug_mark),a  
50da 3a e9 50			ld a, (.dmark+1)  
50dd 32 a7 fd			ld (debug_mark+1),a  
50e0 3a ea 50			ld a, (.dmark+2)  
50e3 32 a8 fd			ld (debug_mark+2),a  
50e6 18 03			jr .pastdmark  
50e8 ..			.dmark: db "SYM"  
50eb f1			.pastdmark: pop af  
50ec			endm  
# End of macro DMARK
50ec						CALLMONITOR 
50ec cd aa fd			call debug_vector  
50ef				endm  
# End of macro CALLMONITOR
50ef					endif 
50ef			 
50ef					FORTH_DSP_VALUEHL 
50ef cd 12 25			call macro_dsp_valuehl 
50f2				endm 
# End of macro FORTH_DSP_VALUEHL
50f2			 
50f2 7d					ld a, l     
50f3			 
50f3			 
50f3					if DEBUG_FORTH_WORDS 
50f3						DMARK "SY1" 
50f3 f5				push af  
50f4 3a 08 51			ld a, (.dmark)  
50f7 32 a6 fd			ld (debug_mark),a  
50fa 3a 09 51			ld a, (.dmark+1)  
50fd 32 a7 fd			ld (debug_mark+1),a  
5100 3a 0a 51			ld a, (.dmark+2)  
5103 32 a8 fd			ld (debug_mark+2),a  
5106 18 03			jr .pastdmark  
5108 ..			.dmark: db "SY1"  
510b f1			.pastdmark: pop af  
510c			endm  
# End of macro DMARK
510c						CALLMONITOR 
510c cd aa fd			call debug_vector  
510f				endm  
# End of macro CALLMONITOR
510f					endif 
510f					 
510f f5					push af	 
5110					FORTH_DSP_POP 
5110 cd ca 25			call macro_forth_dsp_pop 
5113				endm 
# End of macro FORTH_DSP_POP
5113 f1					pop af 
5114			 
5114 cb 27				sla a  
5116				 
5116					 
5116					if DEBUG_FORTH_WORDS 
5116						DMARK "SY" 
5116 f5				push af  
5117 3a 2b 51			ld a, (.dmark)  
511a 32 a6 fd			ld (debug_mark),a  
511d 3a 2c 51			ld a, (.dmark+1)  
5120 32 a7 fd			ld (debug_mark+1),a  
5123 3a 2d 51			ld a, (.dmark+2)  
5126 32 a8 fd			ld (debug_mark+2),a  
5129 18 02			jr .pastdmark  
512b ..			.dmark: db "SY"  
512d f1			.pastdmark: pop af  
512e			endm  
# End of macro DMARK
512e						CALLMONITOR 
512e cd aa fd			call debug_vector  
5131				endm  
# End of macro CALLMONITOR
5131					endif 
5131			 
5131 21 40 51				ld hl, sym_table 
5134 cd cf 0f				call addatohl 
5137 cd 4a 26				call loadwordinhl 
513a cd 1b 23				call forth_push_numhl 
513d			 
513d			 
513d				       NEXTW 
513d c3 c8 26			jp macro_next 
5140				endm 
# End of macro NEXTW
5140			 
5140			sym_table: 
5140			 
5140			; 0 
5140 40 51		dw sym_table 
5142 ad fd		dw nmi_vector 
5144 77 f9		dw cli_autodisplay 
5146 29 f9		dw cli_data_sp 
5148 63 f6		dw cli_data_stack 
514a 2b f9		dw cli_loop_sp 
514c 65 f8		dw cli_loop_stack 
514e 63 f9		dw cli_var_array 
5150 00 fb		dw cursor_col 
5152 fe fa		dw cursor_ptr 
5154			; 10 
5154 ff fa		dw cursor_row 
5156 a6 fd		dw debug_mark 
5158 ec fc		dw display_fb0 
515a 4b fc		dw display_fb1 
515c 09 fb		dw display_fb2 
515e aa fb		dw display_fb3 
5160 07 fb		dw display_fb_active 
5162 fb f1		dw execscratch 
5164 99 f9		dw f_cursor_ptr 
5166 b0 fd		dw hardware_word 
5168			;20 
5168 9d fd		dw input_at_cursor 
516a 9f fd		dw input_at_pos 
516c 9b fd		dw input_cur_flash 
516e 9a fd		dw input_cur_onoff 
5170 90 fd		dw input_cursor 
5172 a0 fd		dw input_display_size 
5174 95 fd		dw input_len 
5176 a4 fd		dw input_ptr 
5178 a1 fd		dw input_size 
517a a2 fd		dw input_start 
517c			; 30 
517c fc 0f		dw input_str 
517e 9e fd		dw input_under_cursor 
5180 23 f4		dw os_cli_cmd 
5182 1f f4		dw os_cur_ptr 
5184 21 f4		dw os_current_i 
5186 fa f2		dw os_input 
5188 22 f5		dw os_last_cmd 
518a f9 f3		dw os_last_new_uword 
518c aa fd		dw debug_vector 
518e de f0		dw os_view_hl 
5190			;40 
5190 01 f4		dw os_word_scratch 
5192 c3 00		dw portbctl 
5194 c1 00		dw portbdata 
5196 9e f9		dw spi_cartdev 
5198 9d f9		dw spi_cartdev2 
519a 9f f9		dw spi_clktime 
519c 9b f9		dw spi_device 
519e 9a f9		dw spi_device_id 
51a0 9c f9		dw spi_portbyte 
51a2 e2 fa		dw stackstore 
51a4			; 50 
51a4			if STORAGE_SE 
51a4 82 00		dw storage_actl 
51a6 80 00		dw storage_adata 
51a8			else 
51a8			dw 0 
51a8			dw 0 
51a8			endif 
51a8 55 0b		dw storage_append 
51aa			if STORAGE_SE 
51aa 83 00		dw storage_bctl 
51ac			else 
51ac			dw 0 
51ac			endif 
51ac ce fa		dw store_bank_active 
51ae a2 f9		dw store_filecache 
51b0 b0 f9		dw store_longread 
51b2 a6 f9		dw store_openaddr 
51b4 a5 f9		dw store_openext 
51b6 a4 f9		dw store_openmaxext 
51b8			; 60 
51b8 b5 f9		dw store_page 
51ba b1 f9		dw store_readbuf 
51bc a8 f9		dw store_readcont 
51be b3 f9		dw store_readptr 
51c0 a8 f9		dw store_tmpext 
51c2 a9 f9		dw store_tmpid 
51c4 a0 f9		dw store_tmppageid 
51c6 ba 16		dw malloc 
51c8 84 17		dw free 
51ca 95 7c		dw cin 
51cc			; 70 
51cc 84 7c		dw cin_wait 
51ce 1b 23		dw forth_push_numhl 
51d0 89 23		dw forth_push_str 
51d2			 
51d2			 
51d2			.ENDCONST: 
51d2			 
51d2			; eof 
51d2			 
51d2			 
# End of file forth_words_const.asm
51d2			 
51d2			if STORAGE_SE 
51d2			   	include "forth_words_storage.asm" 
51d2			 
51d2			; | ## Fixed Storage Words 
51d2			 
51d2			.RENAME: 
51d2			  
51d2				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
51d2 3a				db WORD_SYS_CORE+38             
51d3 c8 52			dw .RECORD            
51d5 07				db 6 + 1 
51d6 .. 00			db "RENAME",0              
51dd				endm 
# End of macro CWHEAD
51dd			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
51dd			; | | > [!NOTE] 
51dd			; | | > Compatible with PicoSPINet  
51dd					if DEBUG_FORTH_WORDS_KEY 
51dd						DMARK "REN" 
51dd f5				push af  
51de 3a f2 51			ld a, (.dmark)  
51e1 32 a6 fd			ld (debug_mark),a  
51e4 3a f3 51			ld a, (.dmark+1)  
51e7 32 a7 fd			ld (debug_mark+1),a  
51ea 3a f4 51			ld a, (.dmark+2)  
51ed 32 a8 fd			ld (debug_mark+2),a  
51f0 18 03			jr .pastdmark  
51f2 ..			.dmark: db "REN"  
51f5 f1			.pastdmark: pop af  
51f6			endm  
# End of macro DMARK
51f6						CALLMONITOR 
51f6 cd aa fd			call debug_vector  
51f9				endm  
# End of macro CALLMONITOR
51f9					endif 
51f9			 
51f9			 
51f9					; preserve some internal vars used by other file handing routines 
51f9			 
51f9 2a a6 f9				ld hl, (store_openaddr) 
51fc e5					push hl 
51fd 3a a8 f9				ld a, (store_readcont) 
5200 f5					push af 
5201			 
5201					FORTH_DSP_VALUEHL 
5201 cd 12 25			call macro_dsp_valuehl 
5204				endm 
# End of macro FORTH_DSP_VALUEHL
5204			 
5204					; move ext and id around for the file header 
5204			 
5204 65					ld h, l 
5205 2e 00				ld l, 0 
5207			 
5207 e5					push hl    ; id 
5208			 
5208					FORTH_DSP_POP 
5208 cd ca 25			call macro_forth_dsp_pop 
520b				endm 
# End of macro FORTH_DSP_POP
520b			 
520b					; Locate the file header 
520b			 
520b e1					pop hl 
520c e5					push hl 
520d 11 b5 f9				ld de, store_page      ; get block zero of file 
5210					if DEBUG_FORTH_WORDS 
5210						DMARK "REr" 
5210 f5				push af  
5211 3a 25 52			ld a, (.dmark)  
5214 32 a6 fd			ld (debug_mark),a  
5217 3a 26 52			ld a, (.dmark+1)  
521a 32 a7 fd			ld (debug_mark+1),a  
521d 3a 27 52			ld a, (.dmark+2)  
5220 32 a8 fd			ld (debug_mark+2),a  
5223 18 03			jr .pastdmark  
5225 ..			.dmark: db "REr"  
5228 f1			.pastdmark: pop af  
5229			endm  
# End of macro DMARK
5229						CALLMONITOR 
5229 cd aa fd			call debug_vector  
522c				endm  
# End of macro CALLMONITOR
522c					endif 
522c cd be 09				call storage_read 
522f			 
522f cd f8 0f			call ishlzero 
5232 20 05			jr nz, .rnfound 
5234			 
5234				; file does not exist so indicate with 255 extents in use 
5234			 
5234 3e ff			ld a, 255 
5236 e1				pop hl ; clear dup hl 
5237 18 7b			jr .skiprneof 
5239			 
5239			 
5239			.rnfound: 
5239					; file found so rename 
5239			 
5239					FORTH_DSP_VALUEHL 
5239 cd 12 25			call macro_dsp_valuehl 
523c				endm 
# End of macro FORTH_DSP_VALUEHL
523c			 
523c e5				push hl 
523d 3e 00			ld a, 0 
523f cd 50 16			call strlent 
5242 23				inc hl   ; cover zero term 
5243 06 00			ld b,0 
5245 4d				ld c,l 
5246 e1				pop hl 
5247 11 b8 f9				ld de, store_page + 3 
524a ed b0				ldir 
524c			 
524c 11 b5 f9				ld de, store_page 
524f					if DEBUG_FORTH_WORDS 
524f						DMARK "RER" 
524f f5				push af  
5250 3a 64 52			ld a, (.dmark)  
5253 32 a6 fd			ld (debug_mark),a  
5256 3a 65 52			ld a, (.dmark+1)  
5259 32 a7 fd			ld (debug_mark+1),a  
525c 3a 66 52			ld a, (.dmark+2)  
525f 32 a8 fd			ld (debug_mark+2),a  
5262 18 03			jr .pastdmark  
5264 ..			.dmark: db "RER"  
5267 f1			.pastdmark: pop af  
5268			endm  
# End of macro DMARK
5268						CALLMONITOR 
5268 cd aa fd			call debug_vector  
526b				endm  
# End of macro CALLMONITOR
526b					endif 
526b			 
526b e1					pop hl    ; get orig file id and mangle it for find id 
526c 55					ld d, l 
526d 5c					ld e, h 
526e			 
526e 21 00 00				ld hl, 0 
5271					if DEBUG_FORTH_WORDS 
5271						DMARK "REf" 
5271 f5				push af  
5272 3a 86 52			ld a, (.dmark)  
5275 32 a6 fd			ld (debug_mark),a  
5278 3a 87 52			ld a, (.dmark+1)  
527b 32 a7 fd			ld (debug_mark+1),a  
527e 3a 88 52			ld a, (.dmark+2)  
5281 32 a8 fd			ld (debug_mark+2),a  
5284 18 03			jr .pastdmark  
5286 ..			.dmark: db "REf"  
5289 f1			.pastdmark: pop af  
528a			endm  
# End of macro DMARK
528a						CALLMONITOR 
528a cd aa fd			call debug_vector  
528d				endm  
# End of macro CALLMONITOR
528d					endif 
528d cd 98 07				call storage_findnextid 
5290 11 b5 f9				ld de, store_page 
5293					if DEBUG_FORTH_WORDS 
5293						DMARK "REw" 
5293 f5				push af  
5294 3a a8 52			ld a, (.dmark)  
5297 32 a6 fd			ld (debug_mark),a  
529a 3a a9 52			ld a, (.dmark+1)  
529d 32 a7 fd			ld (debug_mark+1),a  
52a0 3a aa 52			ld a, (.dmark+2)  
52a3 32 a8 fd			ld (debug_mark+2),a  
52a6 18 03			jr .pastdmark  
52a8 ..			.dmark: db "REw"  
52ab f1			.pastdmark: pop af  
52ac			endm  
# End of macro DMARK
52ac						CALLMONITOR 
52ac cd aa fd			call debug_vector  
52af				endm  
# End of macro CALLMONITOR
52af					endif 
52af cd ca 04				call storage_write_block 
52b2			 
52b2 3e 00				ld a, 0 
52b4			.skiprneof: 
52b4					; drop file name 
52b4					FORTH_DSP_POP 
52b4 cd ca 25			call macro_forth_dsp_pop 
52b7				endm 
# End of macro FORTH_DSP_POP
52b7			 
52b7 6f					ld l, a 
52b8 26 00				ld h, 0 
52ba cd 1b 23				call forth_push_numhl 
52bd			 
52bd			 
52bd f1					pop af 
52be 32 a8 f9				ld (store_readcont),a 
52c1 e1					pop hl 
52c2 22 a6 f9				ld (store_openaddr), hl 
52c5						 
52c5				NEXTW 
52c5 c3 c8 26			jp macro_next 
52c8				endm 
# End of macro NEXTW
52c8			.RECORD: 
52c8			  
52c8				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
52c8 3a				db WORD_SYS_CORE+38             
52c9 6c 53			dw .BREAD            
52cb 07				db 6 + 1 
52cc .. 00			db "RECORD",0              
52d3				endm 
# End of macro CWHEAD
52d3			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
52d3			; | | > [!NOTE] 
52d3			; | | > Compatible with PicoSPINet  
52d3			 
52d3					if DEBUG_FORTH_WORDS_KEY 
52d3						DMARK "REC" 
52d3 f5				push af  
52d4 3a e8 52			ld a, (.dmark)  
52d7 32 a6 fd			ld (debug_mark),a  
52da 3a e9 52			ld a, (.dmark+1)  
52dd 32 a7 fd			ld (debug_mark+1),a  
52e0 3a ea 52			ld a, (.dmark+2)  
52e3 32 a8 fd			ld (debug_mark+2),a  
52e6 18 03			jr .pastdmark  
52e8 ..			.dmark: db "REC"  
52eb f1			.pastdmark: pop af  
52ec			endm  
# End of macro DMARK
52ec						CALLMONITOR 
52ec cd aa fd			call debug_vector  
52ef				endm  
# End of macro CALLMONITOR
52ef					endif 
52ef			 
52ef					FORTH_DSP_VALUEHL 
52ef cd 12 25			call macro_dsp_valuehl 
52f2				endm 
# End of macro FORTH_DSP_VALUEHL
52f2			 
52f2 e5					push hl    ; id 
52f3			 
52f3					FORTH_DSP_POP 
52f3 cd ca 25			call macro_forth_dsp_pop 
52f6				endm 
# End of macro FORTH_DSP_POP
52f6			 
52f6					FORTH_DSP_VALUEHL 
52f6 cd 12 25			call macro_dsp_valuehl 
52f9				endm 
# End of macro FORTH_DSP_VALUEHL
52f9			 
52f9					FORTH_DSP_POP 
52f9 cd ca 25			call macro_forth_dsp_pop 
52fc				endm 
# End of macro FORTH_DSP_POP
52fc			 
52fc d1					pop de     ; get file id 
52fd			 
52fd					; e = file id 
52fd					; l = file extent 
52fd			 
52fd			 
52fd					; construct request to access file extent 
52fd			 
52fd			;		ld a, e 
52fd 63					ld h, e 
52fe					 
52fe					 
52fe					 
52fe			 
52fe					; e has id 
52fe			 
52fe 11 b5 f9			ld de, store_page 
5301					if DEBUG_FORTH_WORDS 
5301						DMARK "REr" 
5301 f5				push af  
5302 3a 16 53			ld a, (.dmark)  
5305 32 a6 fd			ld (debug_mark),a  
5308 3a 17 53			ld a, (.dmark+1)  
530b 32 a7 fd			ld (debug_mark+1),a  
530e 3a 18 53			ld a, (.dmark+2)  
5311 32 a8 fd			ld (debug_mark+2),a  
5314 18 03			jr .pastdmark  
5316 ..			.dmark: db "REr"  
5319 f1			.pastdmark: pop af  
531a			endm  
# End of macro DMARK
531a						CALLMONITOR 
531a cd aa fd			call debug_vector  
531d				endm  
# End of macro CALLMONITOR
531d					endif 
531d cd be 09				call storage_read 
5320 cd f8 0f			call ishlzero 
5323 28 22			jr z, .recnotfound 
5325			 
5325			 
5325					if DEBUG_FORTH_WORDS 
5325						DMARK "REe" 
5325 f5				push af  
5326 3a 3a 53			ld a, (.dmark)  
5329 32 a6 fd			ld (debug_mark),a  
532c 3a 3b 53			ld a, (.dmark+1)  
532f 32 a7 fd			ld (debug_mark+1),a  
5332 3a 3c 53			ld a, (.dmark+2)  
5335 32 a8 fd			ld (debug_mark+2),a  
5338 18 03			jr .pastdmark  
533a ..			.dmark: db "REe"  
533d f1			.pastdmark: pop af  
533e			endm  
# End of macro DMARK
533e						CALLMONITOR 
533e cd aa fd			call debug_vector  
5341				endm  
# End of macro CALLMONITOR
5341					endif 
5341 cd 89 23			call forth_push_str 
5344			 
5344					NEXTW 
5344 c3 c8 26			jp macro_next 
5347				endm 
# End of macro NEXTW
5347			 
5347			.recnotfound: 
5347					if DEBUG_FORTH_WORDS 
5347						DMARK "REf" 
5347 f5				push af  
5348 3a 5c 53			ld a, (.dmark)  
534b 32 a6 fd			ld (debug_mark),a  
534e 3a 5d 53			ld a, (.dmark+1)  
5351 32 a7 fd			ld (debug_mark+1),a  
5354 3a 5e 53			ld a, (.dmark+2)  
5357 32 a8 fd			ld (debug_mark+2),a  
535a 18 03			jr .pastdmark  
535c ..			.dmark: db "REf"  
535f f1			.pastdmark: pop af  
5360			endm  
# End of macro DMARK
5360						CALLMONITOR 
5360 cd aa fd			call debug_vector  
5363				endm  
# End of macro CALLMONITOR
5363					endif 
5363 21 ff 00			ld hl, 255 
5366 cd 1b 23			call forth_push_numhl 
5369				NEXTW 
5369 c3 c8 26			jp macro_next 
536c				endm 
# End of macro NEXTW
536c			 
536c			 
536c			.BREAD: 
536c			  
536c				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
536c 3a				db WORD_SYS_CORE+38             
536d ef 53			dw .BWRITE            
536f 06				db 5 + 1 
5370 .. 00			db "BREAD",0              
5376				endm 
# End of macro CWHEAD
5376			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5376			; | | > [!NOTE] 
5376			; | | > Compatible with PicoSPINet  
5376				 
5376					if DEBUG_FORTH_WORDS_KEY 
5376						DMARK "BRD" 
5376 f5				push af  
5377 3a 8b 53			ld a, (.dmark)  
537a 32 a6 fd			ld (debug_mark),a  
537d 3a 8c 53			ld a, (.dmark+1)  
5380 32 a7 fd			ld (debug_mark+1),a  
5383 3a 8d 53			ld a, (.dmark+2)  
5386 32 a8 fd			ld (debug_mark+2),a  
5389 18 03			jr .pastdmark  
538b ..			.dmark: db "BRD"  
538e f1			.pastdmark: pop af  
538f			endm  
# End of macro DMARK
538f						CALLMONITOR 
538f cd aa fd			call debug_vector  
5392				endm  
# End of macro CALLMONITOR
5392					endif 
5392			 
5392				FORTH_DSP_VALUEHL 
5392 cd 12 25			call macro_dsp_valuehl 
5395				endm 
# End of macro FORTH_DSP_VALUEHL
5395			 
5395				FORTH_DSP_POP 
5395 cd ca 25			call macro_forth_dsp_pop 
5398				endm 
# End of macro FORTH_DSP_POP
5398			 
5398				; calc block address 
5398			 
5398 eb				ex de, hl 
5399 3e 40			ld a, STORE_BLOCK_PHY 
539b cd 52 0f			call Mult16 
539e			 
539e			 
539e 11 b5 f9			ld de, store_page 
53a1			 
53a1					if DEBUG_FORTH_WORDS 
53a1						DMARK "BR1" 
53a1 f5				push af  
53a2 3a b6 53			ld a, (.dmark)  
53a5 32 a6 fd			ld (debug_mark),a  
53a8 3a b7 53			ld a, (.dmark+1)  
53ab 32 a7 fd			ld (debug_mark+1),a  
53ae 3a b8 53			ld a, (.dmark+2)  
53b1 32 a8 fd			ld (debug_mark+2),a  
53b4 18 03			jr .pastdmark  
53b6 ..			.dmark: db "BR1"  
53b9 f1			.pastdmark: pop af  
53ba			endm  
# End of macro DMARK
53ba						CALLMONITOR 
53ba cd aa fd			call debug_vector  
53bd				endm  
# End of macro CALLMONITOR
53bd					endif 
53bd			 
53bd cd 65 04			call storage_read_block 
53c0			 
53c0 cd f8 0f			call ishlzero 
53c3 20 05			jr nz, .brfound 
53c5			 
53c5 cd 1b 23			call forth_push_numhl 
53c8 18 22			jr .brdone 
53ca			 
53ca			 
53ca			.brfound: 
53ca 21 b7 f9		        ld hl, store_page+2 
53cd			 
53cd					if DEBUG_FORTH_WORDS 
53cd						DMARK "BR2" 
53cd f5				push af  
53ce 3a e2 53			ld a, (.dmark)  
53d1 32 a6 fd			ld (debug_mark),a  
53d4 3a e3 53			ld a, (.dmark+1)  
53d7 32 a7 fd			ld (debug_mark+1),a  
53da 3a e4 53			ld a, (.dmark+2)  
53dd 32 a8 fd			ld (debug_mark+2),a  
53e0 18 03			jr .pastdmark  
53e2 ..			.dmark: db "BR2"  
53e5 f1			.pastdmark: pop af  
53e6			endm  
# End of macro DMARK
53e6						CALLMONITOR 
53e6 cd aa fd			call debug_vector  
53e9				endm  
# End of macro CALLMONITOR
53e9					endif 
53e9			 
53e9 cd 89 23			call forth_push_str 
53ec			 
53ec			 
53ec			.brdone: 
53ec			 
53ec					NEXTW 
53ec c3 c8 26			jp macro_next 
53ef				endm 
# End of macro NEXTW
53ef			.BWRITE: 
53ef				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
53ef 3a				db WORD_SYS_CORE+38             
53f0 84 54			dw .BUPD            
53f2 07				db 6 + 1 
53f3 .. 00			db "BWRITE",0              
53fa				endm 
# End of macro CWHEAD
53fa			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
53fa			; | | > [!NOTE] 
53fa			; | | > Compatible with PicoSPINet  
53fa			 
53fa					if DEBUG_FORTH_WORDS_KEY 
53fa						DMARK "BWR" 
53fa f5				push af  
53fb 3a 0f 54			ld a, (.dmark)  
53fe 32 a6 fd			ld (debug_mark),a  
5401 3a 10 54			ld a, (.dmark+1)  
5404 32 a7 fd			ld (debug_mark+1),a  
5407 3a 11 54			ld a, (.dmark+2)  
540a 32 a8 fd			ld (debug_mark+2),a  
540d 18 03			jr .pastdmark  
540f ..			.dmark: db "BWR"  
5412 f1			.pastdmark: pop af  
5413			endm  
# End of macro DMARK
5413						CALLMONITOR 
5413 cd aa fd			call debug_vector  
5416				endm  
# End of macro CALLMONITOR
5416					endif 
5416			 
5416				FORTH_DSP_VALUEHL 
5416 cd 12 25			call macro_dsp_valuehl 
5419				endm 
# End of macro FORTH_DSP_VALUEHL
5419			 
5419				; calc block address 
5419			 
5419 eb				ex de, hl 
541a 3e 40			ld a, STORE_BLOCK_PHY 
541c cd 52 0f			call Mult16 
541f			 
541f e5				push hl         ; address 
5420			 
5420				FORTH_DSP_POP 
5420 cd ca 25			call macro_forth_dsp_pop 
5423				endm 
# End of macro FORTH_DSP_POP
5423			 
5423				FORTH_DSP_VALUEHL 
5423 cd 12 25			call macro_dsp_valuehl 
5426				endm 
# End of macro FORTH_DSP_VALUEHL
5426			 
5426				FORTH_DSP_POP 
5426 cd ca 25			call macro_forth_dsp_pop 
5429				endm 
# End of macro FORTH_DSP_POP
5429			 
5429 cd a1 0c			call storage_clear_page 
542c			 
542c				; copy string to store page 
542c			 
542c e5				push hl     ; save string address 
542d			 
542d 3e 00			ld a, 0 
542f cd 50 16			call strlent 
5432			 
5432 23				inc hl 
5433			 
5433 4d				ld c, l 
5434 06 00			ld b, 0 
5436			 
5436 e1				pop hl 
5437 11 b7 f9			ld de, store_page + 2 
543a					if DEBUG_FORTH_WORDS 
543a						DMARK "BW1" 
543a f5				push af  
543b 3a 4f 54			ld a, (.dmark)  
543e 32 a6 fd			ld (debug_mark),a  
5441 3a 50 54			ld a, (.dmark+1)  
5444 32 a7 fd			ld (debug_mark+1),a  
5447 3a 51 54			ld a, (.dmark+2)  
544a 32 a8 fd			ld (debug_mark+2),a  
544d 18 03			jr .pastdmark  
544f ..			.dmark: db "BW1"  
5452 f1			.pastdmark: pop af  
5453			endm  
# End of macro DMARK
5453						CALLMONITOR 
5453 cd aa fd			call debug_vector  
5456				endm  
# End of macro CALLMONITOR
5456					endif 
5456 ed b0			ldir 
5458			 
5458			 
5458				; poke the start of the block with flags to prevent high level file ops hitting the block 
5458			 
5458 21 ff ff			ld hl, $ffff 
545b			 
545b 22 b5 f9			ld (store_page), hl	 
545e				 
545e e1				pop hl    ; get address 
545f 11 b5 f9			ld de, store_page 
5462			 
5462					if DEBUG_FORTH_WORDS 
5462						DMARK "BW2" 
5462 f5				push af  
5463 3a 77 54			ld a, (.dmark)  
5466 32 a6 fd			ld (debug_mark),a  
5469 3a 78 54			ld a, (.dmark+1)  
546c 32 a7 fd			ld (debug_mark+1),a  
546f 3a 79 54			ld a, (.dmark+2)  
5472 32 a8 fd			ld (debug_mark+2),a  
5475 18 03			jr .pastdmark  
5477 ..			.dmark: db "BW2"  
547a f1			.pastdmark: pop af  
547b			endm  
# End of macro DMARK
547b						CALLMONITOR 
547b cd aa fd			call debug_vector  
547e				endm  
# End of macro CALLMONITOR
547e					endif 
547e			 
547e cd ca 04			call storage_write_block 
5481			 
5481					NEXTW 
5481 c3 c8 26			jp macro_next 
5484				endm 
# End of macro NEXTW
5484			 
5484			.BUPD: 
5484				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5484 3a				db WORD_SYS_CORE+38             
5485 da 54			dw .BYID            
5487 05				db 4 + 1 
5488 .. 00			db "BUPD",0              
548d				endm 
# End of macro CWHEAD
548d			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
548d			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
548d			; | | or completely different file system structure. 
548d			; | | > [!NOTE] 
548d			; | | > Compatible with PicoSPINet  
548d			 
548d					if DEBUG_FORTH_WORDS_KEY 
548d						DMARK "BUD" 
548d f5				push af  
548e 3a a2 54			ld a, (.dmark)  
5491 32 a6 fd			ld (debug_mark),a  
5494 3a a3 54			ld a, (.dmark+1)  
5497 32 a7 fd			ld (debug_mark+1),a  
549a 3a a4 54			ld a, (.dmark+2)  
549d 32 a8 fd			ld (debug_mark+2),a  
54a0 18 03			jr .pastdmark  
54a2 ..			.dmark: db "BUD"  
54a5 f1			.pastdmark: pop af  
54a6			endm  
# End of macro DMARK
54a6						CALLMONITOR 
54a6 cd aa fd			call debug_vector  
54a9				endm  
# End of macro CALLMONITOR
54a9					endif 
54a9			 
54a9				FORTH_DSP_VALUEHL 
54a9 cd 12 25			call macro_dsp_valuehl 
54ac				endm 
# End of macro FORTH_DSP_VALUEHL
54ac			 
54ac				; calc block address 
54ac			 
54ac eb				ex de, hl 
54ad 3e 40			ld a, STORE_BLOCK_PHY 
54af cd 52 0f			call Mult16 
54b2			 
54b2				FORTH_DSP_POP 
54b2 cd ca 25			call macro_forth_dsp_pop 
54b5				endm 
# End of macro FORTH_DSP_POP
54b5			 
54b5			 
54b5 11 b5 f9			ld de, store_page 
54b8			 
54b8					if DEBUG_FORTH_WORDS 
54b8						DMARK "BUe" 
54b8 f5				push af  
54b9 3a cd 54			ld a, (.dmark)  
54bc 32 a6 fd			ld (debug_mark),a  
54bf 3a ce 54			ld a, (.dmark+1)  
54c2 32 a7 fd			ld (debug_mark+1),a  
54c5 3a cf 54			ld a, (.dmark+2)  
54c8 32 a8 fd			ld (debug_mark+2),a  
54cb 18 03			jr .pastdmark  
54cd ..			.dmark: db "BUe"  
54d0 f1			.pastdmark: pop af  
54d1			endm  
# End of macro DMARK
54d1						CALLMONITOR 
54d1 cd aa fd			call debug_vector  
54d4				endm  
# End of macro CALLMONITOR
54d4					endif 
54d4			 
54d4 cd ca 04			call storage_write_block 
54d7			 
54d7					NEXTW 
54d7 c3 c8 26			jp macro_next 
54da				endm 
# End of macro NEXTW
54da			 
54da			.BYID: 
54da			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
54da			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
54da			; 
54da			;		 
54da			;		if DEBUG_FORTH_WORDS_KEY 
54da			;			DMARK "BYID" 
54da			;			CALLMONITOR 
54da			;		endif 
54da			; 
54da			;		; get direct address 
54da			; 
54da			;		FORTH_DSP_VALUEHL 
54da			; 
54da			;		FORTH_DSP_POP 
54da			; 
54da			;	; calc block address 
54da			; 
54da			;	ex de, hl 
54da			;	ld a, STORE_BLOCK_PHY 
54da			;	call Mult16 
54da			;	;	do BREAD with number as param 
54da			;	; push the file name	 
54da			;	ld de, store_page 
54da			;	call storage_read_block 
54da			 ;       ld hl, store_page+2 
54da			; 
54da			; 
54da			;		NEXTW 
54da			;.BYNAME: 
54da				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
54da 3a				db WORD_SYS_CORE+38             
54db f3 54			dw .DIR            
54dd 06				db 5 + 1 
54de .. 00			db "GETID",0              
54e4				endm 
# End of macro CWHEAD
54e4			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
54e4			; | | > [!NOTE] 
54e4			; | | > Compatible with PicoSPINet  
54e4			 
54e4					; get pointer to file name to seek 
54e4			 
54e4					FORTH_DSP_VALUEHL 
54e4 cd 12 25			call macro_dsp_valuehl 
54e7				endm 
# End of macro FORTH_DSP_VALUEHL
54e7			 
54e7			 
54e7 cd 8c 03				call storage_getid  
54ea			 
54ea					FORTH_DSP_POP 
54ea cd ca 25			call macro_forth_dsp_pop 
54ed				endm 
# End of macro FORTH_DSP_POP
54ed			 
54ed cd 1b 23				call forth_push_numhl 
54f0			 
54f0					NEXTW 
54f0 c3 c8 26			jp macro_next 
54f3				endm 
# End of macro NEXTW
54f3			; 
54f3			.DIR: 
54f3				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
54f3 3a				db WORD_SYS_CORE+38             
54f4 f7 55			dw .SAVE            
54f6 04				db 3 + 1 
54f7 .. 00			db "DIR",0              
54fb				endm 
# End of macro CWHEAD
54fb			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
54fb			; | | > [!NOTE] 
54fb			; | | > Compatible with PicoSPINet  
54fb			 
54fb					if DEBUG_FORTH_WORDS_KEY 
54fb						DMARK "DIR" 
54fb f5				push af  
54fc 3a 10 55			ld a, (.dmark)  
54ff 32 a6 fd			ld (debug_mark),a  
5502 3a 11 55			ld a, (.dmark+1)  
5505 32 a7 fd			ld (debug_mark+1),a  
5508 3a 12 55			ld a, (.dmark+2)  
550b 32 a8 fd			ld (debug_mark+2),a  
550e 18 03			jr .pastdmark  
5510 ..			.dmark: db "DIR"  
5513 f1			.pastdmark: pop af  
5514			endm  
# End of macro DMARK
5514						CALLMONITOR 
5514 cd aa fd			call debug_vector  
5517				endm  
# End of macro CALLMONITOR
5517					endif 
5517 cd 16 05			call storage_get_block_0 
551a			 
551a 21 b5 f9			ld hl, store_page     ; get current id count 
551d 46				ld b, (hl) 
551e 0e 00			ld c, 0    ; count of files   
5520					if DEBUG_FORTH_WORDS 
5520						DMARK "DI1" 
5520 f5				push af  
5521 3a 35 55			ld a, (.dmark)  
5524 32 a6 fd			ld (debug_mark),a  
5527 3a 36 55			ld a, (.dmark+1)  
552a 32 a7 fd			ld (debug_mark+1),a  
552d 3a 37 55			ld a, (.dmark+2)  
5530 32 a8 fd			ld (debug_mark+2),a  
5533 18 03			jr .pastdmark  
5535 ..			.dmark: db "DI1"  
5538 f1			.pastdmark: pop af  
5539			endm  
# End of macro DMARK
5539						CALLMONITOR 
5539 cd aa fd			call debug_vector  
553c				endm  
# End of macro CALLMONITOR
553c					endif 
553c			 
553c				; check for empty drive 
553c			 
553c 3e 00			ld a, 0 
553e b8				cp b 
553f ca ad 55			jp z, .dirdone 
5542			 
5542				; for each of the current ids do a search for them and if found push to stack 
5542			 
5542 c5			.diritem:	push bc 
5543 21 40 00				ld hl, STORE_BLOCK_PHY 
5546 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5548 58					ld e,b 
5549			 
5549			;		if DEBUG_FORTH_WORDS 
5549			;			DMARK "DI2" 
5549			;			CALLMONITOR 
5549			;		endif 
5549			 
5549 cd 98 07				call storage_findnextid 
554c			 
554c			;		if DEBUG_FORTH_WORDS 
554c			;			DMARK "DI3" 
554c			;			CALLMONITOR 
554c			;		endif 
554c			 
554c					; if found hl will be non zero 
554c			 
554c cd f8 0f				call ishlzero 
554f			;		ld a, l 
554f			;		add h 
554f			; 
554f			;		cp 0 
554f 28 59				jr z, .dirnotfound 
5551			 
5551					; increase count 
5551			 
5551 c1					pop bc	 
5552 0c					inc c 
5553 c5					push bc 
5554					 
5554			 
5554					; get file header and push the file name 
5554			 
5554 11 b5 f9				ld de, store_page 
5557 cd 65 04				call storage_read_block 
555a			 
555a					; push file id to stack 
555a				 
555a 3a b5 f9				ld a, (store_page) 
555d 26 00				ld h, 0 
555f 6f					ld l, a 
5560 cd 1b 23				call forth_push_numhl 
5563			 
5563					; push extent count to stack  
5563				 
5563 3a b7 f9				ld a, (store_page+2) 
5566 26 00				ld h, 0 
5568 6f					ld l, a 
5569 cd 1b 23				call forth_push_numhl 
556c			 
556c					; push file name 
556c			 
556c 21 b8 f9				ld hl, store_page+3 
556f					if DEBUG_FORTH_WORDS 
556f						DMARK "DI5" 
556f f5				push af  
5570 3a 84 55			ld a, (.dmark)  
5573 32 a6 fd			ld (debug_mark),a  
5576 3a 85 55			ld a, (.dmark+1)  
5579 32 a7 fd			ld (debug_mark+1),a  
557c 3a 86 55			ld a, (.dmark+2)  
557f 32 a8 fd			ld (debug_mark+2),a  
5582 18 03			jr .pastdmark  
5584 ..			.dmark: db "DI5"  
5587 f1			.pastdmark: pop af  
5588			endm  
# End of macro DMARK
5588						CALLMONITOR 
5588 cd aa fd			call debug_vector  
558b				endm  
# End of macro CALLMONITOR
558b					endif 
558b cd 89 23				call forth_push_str 
558e					if DEBUG_FORTH_WORDS 
558e						DMARK "DI6" 
558e f5				push af  
558f 3a a3 55			ld a, (.dmark)  
5592 32 a6 fd			ld (debug_mark),a  
5595 3a a4 55			ld a, (.dmark+1)  
5598 32 a7 fd			ld (debug_mark+1),a  
559b 3a a5 55			ld a, (.dmark+2)  
559e 32 a8 fd			ld (debug_mark+2),a  
55a1 18 03			jr .pastdmark  
55a3 ..			.dmark: db "DI6"  
55a6 f1			.pastdmark: pop af  
55a7			endm  
# End of macro DMARK
55a7						CALLMONITOR 
55a7 cd aa fd			call debug_vector  
55aa				endm  
# End of macro CALLMONITOR
55aa					endif 
55aa			.dirnotfound: 
55aa c1					pop bc     
55ab 10 95				djnz .diritem 
55ad				 
55ad			.dirdone:	 
55ad					if DEBUG_FORTH_WORDS 
55ad						DMARK "DI7" 
55ad f5				push af  
55ae 3a c2 55			ld a, (.dmark)  
55b1 32 a6 fd			ld (debug_mark),a  
55b4 3a c3 55			ld a, (.dmark+1)  
55b7 32 a7 fd			ld (debug_mark+1),a  
55ba 3a c4 55			ld a, (.dmark+2)  
55bd 32 a8 fd			ld (debug_mark+2),a  
55c0 18 03			jr .pastdmark  
55c2 ..			.dmark: db "DI7"  
55c5 f1			.pastdmark: pop af  
55c6			endm  
# End of macro DMARK
55c6						CALLMONITOR 
55c6 cd aa fd			call debug_vector  
55c9				endm  
# End of macro CALLMONITOR
55c9					endif 
55c9			 
55c9					; push a count of the dir items found 
55c9			 
55c9 26 00				ld h, 0 
55cb 69					ld l, c 
55cc cd 1b 23				call forth_push_numhl 
55cf			 
55cf					; push the bank label 
55cf			 
55cf cd 16 05				call storage_get_block_0 
55d2			 
55d2				 
55d2 21 b8 f9		 		ld hl, store_page+3 
55d5			 
55d5					if DEBUG_FORTH_WORDS 
55d5						DMARK "DI8" 
55d5 f5				push af  
55d6 3a ea 55			ld a, (.dmark)  
55d9 32 a6 fd			ld (debug_mark),a  
55dc 3a eb 55			ld a, (.dmark+1)  
55df 32 a7 fd			ld (debug_mark+1),a  
55e2 3a ec 55			ld a, (.dmark+2)  
55e5 32 a8 fd			ld (debug_mark+2),a  
55e8 18 03			jr .pastdmark  
55ea ..			.dmark: db "DI8"  
55ed f1			.pastdmark: pop af  
55ee			endm  
# End of macro DMARK
55ee						CALLMONITOR 
55ee cd aa fd			call debug_vector  
55f1				endm  
# End of macro CALLMONITOR
55f1					endif 
55f1 cd 89 23				call forth_push_str 
55f4			 
55f4			 
55f4				 
55f4					NEXTW 
55f4 c3 c8 26			jp macro_next 
55f7				endm 
# End of macro NEXTW
55f7			.SAVE: 
55f7			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
55f7			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
55f7			;		NEXTW 
55f7			;.LOAD: 
55f7			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
55f7			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
55f7			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
55f7			;; > > The LOAD command can not be used in any user words or compound lines. 
55f7			; 
55f7			;		; store_openext use it. If zero it is EOF 
55f7			; 
55f7			;		; read block from current stream id 
55f7			;		; if the block does not contain zero term keep reading blocks until zero found 
55f7			;		; push the block to stack 
55f7			;		; save the block id to stream 
55f7			; 
55f7			; 
55f7			;		FORTH_DSP_VALUEHL 
55f7			; 
55f7			;;		push hl 
55f7			; 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LOA" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			;		FORTH_DSP_POP 
55f7			; 
55f7			;;		pop hl 
55f7			; 
55f7			;		ld h, l 
55f7			;		ld l, 0 
55f7			; 
55f7			;		push hl     ; stack holds current file id and extent to work with 
55f7			; 
55f7			; 
55f7			;		ld de, store_page      ; get block zero of file 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LO0" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			;		call storage_read 
55f7			; 
55f7			;		ld a, (store_page+2)    ; max extents for this file 
55f7			;		ld  (store_openmaxext),a   ; get our limit 
55f7			; 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LOE" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			; 
55f7			;; TODO dont know why max extents are not present 
55f7			;;		cp 0 
55f7			;;		jp z, .loadeof     ; dont read past eof 
55f7			; 
55f7			;;		ld a, 1   ; start from the head of the file 
55f7			; 
55f7			;.loadline:	pop hl 
55f7			;		inc hl 
55f7			;		ld  a, (store_openmaxext)   ; get our limit 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LOx" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			;		inc a 
55f7			;		cp l 
55f7			;		jp z, .loadeof 
55f7			;		push hl    ; save current extent 
55f7			; 
55f7			;		ld de, store_page 
55f7			; 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LO1" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			;		call storage_read 
55f7			; 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LO2" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			;	call ishlzero 
55f7			;	ld a, l 
55f7			;	add h 
55f7			;	cp 0 
55f7			;	jr z, .loadeof 
55f7			; 
55f7			;	; not eof so hl should point to data to exec 
55f7			; 
55f7			;	; will need to add the FORTH_END_BUFFER flag 
55f7			 ; 
55f7			;	ld hl, store_page+2 
55f7			;	ld bc, 255 
55f7			;	ld a, 0 
55f7			;	cpir 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LOt" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			;	dec hl 
55f7			;	ld a, ' ' 
55f7			;	ld (hl), a 
55f7			;	inc hl 
55f7			;	ld (hl), a 
55f7			;	inc hl 
55f7			;	ld (hl), a 
55f7			;	inc hl 
55f7			;	ld a, FORTH_END_BUFFER 
55f7			;	ld (hl), a 
55f7			; 
55f7			;	; TODO handle more than a single block read 
55f7			; 
55f7			; 
55f7			;	ld hl, store_page+2 
55f7			; 
55f7			;	ld (os_tok_ptr), hl 
55f7			; 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LO3" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			; 
55f7			;	call forthparse 
55f7			;	call forthexec 
55f7			;	call forthexec_cleanup 
55f7			; 
55f7			;	; go to next extent 
55f7			; 
55f7			;	; get next block  or mark as eof 
55f7			;	jp .loadline 
55f7			; 
55f7			; 
55f7			; 
55f7			;	       NEXTW 
55f7			;.loadeof:	ld a, 0 
55f7			;		ld (store_openext), a 
55f7			; 
55f7			;	if DEBUG_STORESE 
55f7			;		DMARK "LOF" 
55f7			;		CALLMONITOR 
55f7			;	endif 
55f7			;		ret 
55f7			;		;NEXTW 
55f7			;.BSAVE:   
55f7			; 
55f7			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
55f7			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
55f7			;		NEXTW 
55f7			;.BLOAD: 
55f7			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
55f7			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
55f7			;		NEXTW 
55f7			;;;; counter gap 
55f7			 
55f7			 
55f7			.SEO: 
55f7				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
55f7 64				db WORD_SYS_CORE+80             
55f8 16 56			dw .SEI            
55fa 04				db 3 + 1 
55fb .. 00			db "SEO",0              
55ff				endm 
# End of macro CWHEAD
55ff			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
55ff			 
55ff					; get port 
55ff			 
55ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55ff cd 12 25			call macro_dsp_valuehl 
5602				endm 
# End of macro FORTH_DSP_VALUEHL
5602			 
5602 e5					push hl    ; u2 - byte 
5603			 
5603					; destroy value TOS 
5603			 
5603					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5603 cd ca 25			call macro_forth_dsp_pop 
5606				endm 
# End of macro FORTH_DSP_POP
5606			 
5606					; get byte to send 
5606			 
5606					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5606 cd 12 25			call macro_dsp_valuehl 
5609				endm 
# End of macro FORTH_DSP_VALUEHL
5609			 
5609 e5					push hl    ; u1 - addr 
560a			 
560a					; destroy value TOS 
560a			 
560a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
560a cd ca 25			call macro_forth_dsp_pop 
560d				endm 
# End of macro FORTH_DSP_POP
560d			 
560d					; one value on hl get other one back 
560d			 
560d d1					pop de   ; u1 - byte 
560e			 
560e e1					pop hl   ; u2 - addr 
560f			 
560f					; TODO Send SPI byte 
560f			 
560f			 
560f 7b					ld a, e 
5610 cd 6a 02				call se_writebyte 
5613			 
5613					 
5613			 
5613					NEXTW 
5613 c3 c8 26			jp macro_next 
5616				endm 
# End of macro NEXTW
5616			 
5616			.SEI: 
5616				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5616 65				db WORD_SYS_CORE+81             
5617 30 56			dw .SFREE            
5619 04				db 3 + 1 
561a .. 00			db "SEI",0              
561e				endm 
# End of macro CWHEAD
561e			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
561e			 
561e					; get port 
561e			 
561e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
561e cd 12 25			call macro_dsp_valuehl 
5621				endm 
# End of macro FORTH_DSP_VALUEHL
5621			 
5621			;		push hl 
5621			 
5621					; destroy value TOS 
5621			 
5621					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5621 cd ca 25			call macro_forth_dsp_pop 
5624				endm 
# End of macro FORTH_DSP_POP
5624			 
5624					; one value on hl get other one back 
5624			 
5624			;		pop hl 
5624			 
5624			 
5624					; TODO Get SPI byte 
5624			 
5624 cd 0c 03				call se_readbyte 
5627			 
5627 26 00				ld h, 0 
5629 6f					ld l, a 
562a cd 1b 23				call forth_push_numhl 
562d			 
562d					NEXTW 
562d c3 c8 26			jp macro_next 
5630				endm 
# End of macro NEXTW
5630			 
5630			.SFREE: 
5630				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5630 67				db WORD_SYS_CORE+83             
5631 5f 56			dw .SIZE            
5633 06				db 5 + 1 
5634 .. 00			db "FFREE",0              
563a				endm 
# End of macro CWHEAD
563a			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
563a			; | | > [!NOTE] 
563a			; | | > Compatible with PicoSPINet  
563a					if DEBUG_FORTH_WORDS_KEY 
563a						DMARK "FFR" 
563a f5				push af  
563b 3a 4f 56			ld a, (.dmark)  
563e 32 a6 fd			ld (debug_mark),a  
5641 3a 50 56			ld a, (.dmark+1)  
5644 32 a7 fd			ld (debug_mark+1),a  
5647 3a 51 56			ld a, (.dmark+2)  
564a 32 a8 fd			ld (debug_mark+2),a  
564d 18 03			jr .pastdmark  
564f ..			.dmark: db "FFR"  
5652 f1			.pastdmark: pop af  
5653			endm  
# End of macro DMARK
5653						CALLMONITOR 
5653 cd aa fd			call debug_vector  
5656				endm  
# End of macro CALLMONITOR
5656					endif 
5656			 
5656 cd 32 08				call storage_freeblocks 
5659			 
5659 cd 1b 23				call forth_push_numhl 
565c			 
565c				       NEXTW 
565c c3 c8 26			jp macro_next 
565f				endm 
# End of macro NEXTW
565f			.SIZE: 
565f				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
565f 67				db WORD_SYS_CORE+83             
5660 93 56			dw .CREATE            
5662 05				db 4 + 1 
5663 .. 00			db "SIZE",0              
5668				endm 
# End of macro CWHEAD
5668			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5668			; | | > [!NOTE] 
5668			; | | > Compatible with PicoSPINet  
5668					if DEBUG_FORTH_WORDS_KEY 
5668						DMARK "SIZ" 
5668 f5				push af  
5669 3a 7d 56			ld a, (.dmark)  
566c 32 a6 fd			ld (debug_mark),a  
566f 3a 7e 56			ld a, (.dmark+1)  
5672 32 a7 fd			ld (debug_mark+1),a  
5675 3a 7f 56			ld a, (.dmark+2)  
5678 32 a8 fd			ld (debug_mark+2),a  
567b 18 03			jr .pastdmark  
567d ..			.dmark: db "SIZ"  
5680 f1			.pastdmark: pop af  
5681			endm  
# End of macro DMARK
5681						CALLMONITOR 
5681 cd aa fd			call debug_vector  
5684				endm  
# End of macro CALLMONITOR
5684					endif 
5684			 
5684					FORTH_DSP_VALUEHL 
5684 cd 12 25			call macro_dsp_valuehl 
5687				endm 
# End of macro FORTH_DSP_VALUEHL
5687			;		push hl 
5687					FORTH_DSP_POP 
5687 cd ca 25			call macro_forth_dsp_pop 
568a				endm 
# End of macro FORTH_DSP_POP
568a			;		pop hl 
568a cd 94 04				call storage_file_size 
568d			 
568d cd 1b 23				call forth_push_numhl 
5690			  
5690			 
5690				       NEXTW 
5690 c3 c8 26			jp macro_next 
5693				endm 
# End of macro NEXTW
5693			 
5693			.CREATE: 
5693				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5693 68				db WORD_SYS_CORE+84             
5694 01 57			dw .APPEND            
5696 07				db 6 + 1 
5697 .. 00			db "CREATE",0              
569e				endm 
# End of macro CWHEAD
569e			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
569e			; | | e.g.  
569e			; | | TestProgram CREATE 
569e			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
569e			; | |  
569e			; | | Max file IDs are 255. 
569e			; | |  
569e			; | | > [!NOTE] 
569e			; | | > Compatible with PicoSPINet  
569e					 
569e					if DEBUG_FORTH_WORDS_KEY 
569e						DMARK "CRT" 
569e f5				push af  
569f 3a b3 56			ld a, (.dmark)  
56a2 32 a6 fd			ld (debug_mark),a  
56a5 3a b4 56			ld a, (.dmark+1)  
56a8 32 a7 fd			ld (debug_mark+1),a  
56ab 3a b5 56			ld a, (.dmark+2)  
56ae 32 a8 fd			ld (debug_mark+2),a  
56b1 18 03			jr .pastdmark  
56b3 ..			.dmark: db "CRT"  
56b6 f1			.pastdmark: pop af  
56b7			endm  
# End of macro DMARK
56b7						CALLMONITOR 
56b7 cd aa fd			call debug_vector  
56ba				endm  
# End of macro CALLMONITOR
56ba					endif 
56ba			;		call storage_get_block_0 
56ba			 
56ba					; TODO pop hl 
56ba			 
56ba					;v5 FORTH_DSP_VALUE 
56ba					FORTH_DSP_VALUE 
56ba cd fb 24			call macro_forth_dsp_value 
56bd				endm 
# End of macro FORTH_DSP_VALUE
56bd			 
56bd				if DEBUG_STORESE 
56bd					DMARK "CR1" 
56bd f5				push af  
56be 3a d2 56			ld a, (.dmark)  
56c1 32 a6 fd			ld (debug_mark),a  
56c4 3a d3 56			ld a, (.dmark+1)  
56c7 32 a7 fd			ld (debug_mark+1),a  
56ca 3a d4 56			ld a, (.dmark+2)  
56cd 32 a8 fd			ld (debug_mark+2),a  
56d0 18 03			jr .pastdmark  
56d2 ..			.dmark: db "CR1"  
56d5 f1			.pastdmark: pop af  
56d6			endm  
# End of macro DMARK
56d6					CALLMONITOR 
56d6 cd aa fd			call debug_vector  
56d9				endm  
# End of macro CALLMONITOR
56d9				endif 
56d9			;		push hl 
56d9			;		FORTH_DSP_POP 
56d9			;		pop hl 
56d9			 
56d9			;		inc hl   ; move past the type marker 
56d9			 
56d9 cd 68 08				call storage_create 
56dc			 
56dc				if DEBUG_STORESE 
56dc					DMARK "CT1" 
56dc f5				push af  
56dd 3a f1 56			ld a, (.dmark)  
56e0 32 a6 fd			ld (debug_mark),a  
56e3 3a f2 56			ld a, (.dmark+1)  
56e6 32 a7 fd			ld (debug_mark+1),a  
56e9 3a f3 56			ld a, (.dmark+2)  
56ec 32 a8 fd			ld (debug_mark+2),a  
56ef 18 03			jr .pastdmark  
56f1 ..			.dmark: db "CT1"  
56f4 f1			.pastdmark: pop af  
56f5			endm  
# End of macro DMARK
56f5					CALLMONITOR 
56f5 cd aa fd			call debug_vector  
56f8				endm  
# End of macro CALLMONITOR
56f8				endif 
56f8			;		push hl 
56f8					FORTH_DSP_POP 
56f8 cd ca 25			call macro_forth_dsp_pop 
56fb				endm 
# End of macro FORTH_DSP_POP
56fb			;		pop hl 
56fb					; push file id to stack 
56fb cd 1b 23				call forth_push_numhl 
56fe			 
56fe			 
56fe			 
56fe				       NEXTW 
56fe c3 c8 26			jp macro_next 
5701				endm 
# End of macro NEXTW
5701			 
5701			.APPEND: 
5701				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5701 69				db WORD_SYS_CORE+85             
5702 92 57			dw .SDEL            
5704 07				db 6 + 1 
5705 .. 00			db "APPEND",0              
570c				endm 
# End of macro CWHEAD
570c			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
570c			; | | e.g. 
570c			; | | Test CREATE      -> $01 
570c			; | | "A string to add to file" $01 APPEND 
570c			; | |  
570c			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
570c			; | | > [!NOTE] 
570c			; | | > Compatible with PicoSPINet  
570c					if DEBUG_FORTH_WORDS_KEY 
570c						DMARK "APP" 
570c f5				push af  
570d 3a 21 57			ld a, (.dmark)  
5710 32 a6 fd			ld (debug_mark),a  
5713 3a 22 57			ld a, (.dmark+1)  
5716 32 a7 fd			ld (debug_mark+1),a  
5719 3a 23 57			ld a, (.dmark+2)  
571c 32 a8 fd			ld (debug_mark+2),a  
571f 18 03			jr .pastdmark  
5721 ..			.dmark: db "APP"  
5724 f1			.pastdmark: pop af  
5725			endm  
# End of macro DMARK
5725						CALLMONITOR 
5725 cd aa fd			call debug_vector  
5728				endm  
# End of macro CALLMONITOR
5728					endif 
5728			 
5728					FORTH_DSP_VALUEHL 
5728 cd 12 25			call macro_dsp_valuehl 
572b				endm 
# End of macro FORTH_DSP_VALUEHL
572b e5					push hl 	; save file id 
572c			 
572c				if DEBUG_STORESE 
572c					DMARK "AP1" 
572c f5				push af  
572d 3a 41 57			ld a, (.dmark)  
5730 32 a6 fd			ld (debug_mark),a  
5733 3a 42 57			ld a, (.dmark+1)  
5736 32 a7 fd			ld (debug_mark+1),a  
5739 3a 43 57			ld a, (.dmark+2)  
573c 32 a8 fd			ld (debug_mark+2),a  
573f 18 03			jr .pastdmark  
5741 ..			.dmark: db "AP1"  
5744 f1			.pastdmark: pop af  
5745			endm  
# End of macro DMARK
5745					CALLMONITOR 
5745 cd aa fd			call debug_vector  
5748				endm  
# End of macro CALLMONITOR
5748				endif 
5748					FORTH_DSP_POP 
5748 cd ca 25			call macro_forth_dsp_pop 
574b				endm 
# End of macro FORTH_DSP_POP
574b			 
574b					FORTH_DSP_VALUEHL 
574b cd 12 25			call macro_dsp_valuehl 
574e				endm 
# End of macro FORTH_DSP_VALUEHL
574e					;v5 FORTH_DSP_VALUE 
574e e5					push hl 	; save ptr to string to save 
574f			 
574f				if DEBUG_STORESE 
574f					DMARK "AP1" 
574f f5				push af  
5750 3a 64 57			ld a, (.dmark)  
5753 32 a6 fd			ld (debug_mark),a  
5756 3a 65 57			ld a, (.dmark+1)  
5759 32 a7 fd			ld (debug_mark+1),a  
575c 3a 66 57			ld a, (.dmark+2)  
575f 32 a8 fd			ld (debug_mark+2),a  
5762 18 03			jr .pastdmark  
5764 ..			.dmark: db "AP1"  
5767 f1			.pastdmark: pop af  
5768			endm  
# End of macro DMARK
5768					CALLMONITOR 
5768 cd aa fd			call debug_vector  
576b				endm  
# End of macro CALLMONITOR
576b				endif 
576b					FORTH_DSP_POP 
576b cd ca 25			call macro_forth_dsp_pop 
576e				endm 
# End of macro FORTH_DSP_POP
576e			 
576e d1					pop de 
576f e1					pop hl 
5770				if DEBUG_STORESE 
5770					DMARK "AP2" 
5770 f5				push af  
5771 3a 85 57			ld a, (.dmark)  
5774 32 a6 fd			ld (debug_mark),a  
5777 3a 86 57			ld a, (.dmark+1)  
577a 32 a7 fd			ld (debug_mark+1),a  
577d 3a 87 57			ld a, (.dmark+2)  
5780 32 a8 fd			ld (debug_mark+2),a  
5783 18 03			jr .pastdmark  
5785 ..			.dmark: db "AP2"  
5788 f1			.pastdmark: pop af  
5789			endm  
# End of macro DMARK
5789					CALLMONITOR 
5789 cd aa fd			call debug_vector  
578c				endm  
# End of macro CALLMONITOR
578c				endif 
578c					;inc de ; skip var type indicator 
578c			 
578c					; TODO how to append numerics???? 
578c			 
578c cd 55 0b				call storage_append		 
578f			 
578f				       NEXTW 
578f c3 c8 26			jp macro_next 
5792				endm 
# End of macro NEXTW
5792			.SDEL: 
5792				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5792 6a				db WORD_SYS_CORE+86             
5793 de 57			dw .OPEN            
5795 05				db 4 + 1 
5796 .. 00			db "ERA",0              
579a				endm 
# End of macro CWHEAD
579a			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
579a			; | | > [!NOTE] 
579a			; | | > Compatible with PicoSPINet  
579a					FORTH_DSP_VALUEHL 
579a cd 12 25			call macro_dsp_valuehl 
579d				endm 
# End of macro FORTH_DSP_VALUEHL
579d			;		push hl 	; save file id 
579d			 
579d					if DEBUG_FORTH_WORDS_KEY 
579d						DMARK "ERA" 
579d f5				push af  
579e 3a b2 57			ld a, (.dmark)  
57a1 32 a6 fd			ld (debug_mark),a  
57a4 3a b3 57			ld a, (.dmark+1)  
57a7 32 a7 fd			ld (debug_mark+1),a  
57aa 3a b4 57			ld a, (.dmark+2)  
57ad 32 a8 fd			ld (debug_mark+2),a  
57b0 18 03			jr .pastdmark  
57b2 ..			.dmark: db "ERA"  
57b5 f1			.pastdmark: pop af  
57b6			endm  
# End of macro DMARK
57b6						CALLMONITOR 
57b6 cd aa fd			call debug_vector  
57b9				endm  
# End of macro CALLMONITOR
57b9					endif 
57b9				if DEBUG_STORESE 
57b9					DMARK "ER1" 
57b9 f5				push af  
57ba 3a ce 57			ld a, (.dmark)  
57bd 32 a6 fd			ld (debug_mark),a  
57c0 3a cf 57			ld a, (.dmark+1)  
57c3 32 a7 fd			ld (debug_mark+1),a  
57c6 3a d0 57			ld a, (.dmark+2)  
57c9 32 a8 fd			ld (debug_mark+2),a  
57cc 18 03			jr .pastdmark  
57ce ..			.dmark: db "ER1"  
57d1 f1			.pastdmark: pop af  
57d2			endm  
# End of macro DMARK
57d2					CALLMONITOR 
57d2 cd aa fd			call debug_vector  
57d5				endm  
# End of macro CALLMONITOR
57d5				endif 
57d5					FORTH_DSP_POP 
57d5 cd ca 25			call macro_forth_dsp_pop 
57d8				endm 
# End of macro FORTH_DSP_POP
57d8			 
57d8			;		pop hl 
57d8			 
57d8 cd a7 06				call storage_erase 
57db				       NEXTW 
57db c3 c8 26			jp macro_next 
57de				endm 
# End of macro NEXTW
57de			 
57de			.OPEN: 
57de				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
57de 6b				db WORD_SYS_CORE+87             
57df 72 58			dw .READ            
57e1 05				db 4 + 1 
57e2 .. 00			db "OPEN",0              
57e7				endm 
# End of macro CWHEAD
57e7			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
57e7			; | | e.g. 
57e7			; | | $01 OPEN $01 DO $01 READ . LOOP 
57e7			; | | 
57e7			; | | Will return with 255 blocks if the file does not exist 
57e7			; | | > [!NOTE] 
57e7			; | | > Compatible with PicoSPINet  
57e7			 
57e7					if DEBUG_FORTH_WORDS_KEY 
57e7						DMARK "OPN" 
57e7 f5				push af  
57e8 3a fc 57			ld a, (.dmark)  
57eb 32 a6 fd			ld (debug_mark),a  
57ee 3a fd 57			ld a, (.dmark+1)  
57f1 32 a7 fd			ld (debug_mark+1),a  
57f4 3a fe 57			ld a, (.dmark+2)  
57f7 32 a8 fd			ld (debug_mark+2),a  
57fa 18 03			jr .pastdmark  
57fc ..			.dmark: db "OPN"  
57ff f1			.pastdmark: pop af  
5800			endm  
# End of macro DMARK
5800						CALLMONITOR 
5800 cd aa fd			call debug_vector  
5803				endm  
# End of macro CALLMONITOR
5803					endif 
5803					; TODO handle multiple file opens 
5803			 
5803 3e 01			       	ld a, 1 
5805 32 a5 f9				ld (store_openext), a 
5808			 
5808					; get max extents for this file 
5808				 
5808								 
5808					FORTH_DSP_VALUEHL 
5808 cd 12 25			call macro_dsp_valuehl 
580b				endm 
# End of macro FORTH_DSP_VALUEHL
580b			 
580b 65					ld h, l 
580c 2e 00				ld l, 0 
580e			 
580e					; store file id 
580e			 
580e 7c					ld a, h 
580f 32 a2 f9				ld (store_filecache), a 
5812			 
5812				if DEBUG_STORESE 
5812					DMARK "OPN" 
5812 f5				push af  
5813 3a 27 58			ld a, (.dmark)  
5816 32 a6 fd			ld (debug_mark),a  
5819 3a 28 58			ld a, (.dmark+1)  
581c 32 a7 fd			ld (debug_mark+1),a  
581f 3a 29 58			ld a, (.dmark+2)  
5822 32 a8 fd			ld (debug_mark+2),a  
5825 18 03			jr .pastdmark  
5827 ..			.dmark: db "OPN"  
582a f1			.pastdmark: pop af  
582b			endm  
# End of macro DMARK
582b					CALLMONITOR 
582b cd aa fd			call debug_vector  
582e				endm  
# End of macro CALLMONITOR
582e				endif 
582e			;		push hl 
582e					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
582e cd ca 25			call macro_forth_dsp_pop 
5831				endm 
# End of macro FORTH_DSP_POP
5831			;		pop hl 
5831						 
5831 11 b5 f9				ld de, store_page      ; get block zero of file 
5834 cd be 09				call storage_read 
5837 cd f8 0f			call ishlzero 
583a 20 04			jr nz, .opfound 
583c			 
583c				; file does not exist so indicate with 255 extents in use 
583c			 
583c 3e ff			ld a, 255 
583e 18 29			jr .skipopeneof 
5840			 
5840			 
5840			.opfound: 
5840			 
5840			 
5840 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
5843 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
5846					 
5846				if DEBUG_STORESE 
5846					DMARK "OPx" 
5846 f5				push af  
5847 3a 5b 58			ld a, (.dmark)  
584a 32 a6 fd			ld (debug_mark),a  
584d 3a 5c 58			ld a, (.dmark+1)  
5850 32 a7 fd			ld (debug_mark+1),a  
5853 3a 5d 58			ld a, (.dmark+2)  
5856 32 a8 fd			ld (debug_mark+2),a  
5859 18 03			jr .pastdmark  
585b ..			.dmark: db "OPx"  
585e f1			.pastdmark: pop af  
585f			endm  
# End of macro DMARK
585f					CALLMONITOR 
585f cd aa fd			call debug_vector  
5862				endm  
# End of macro CALLMONITOR
5862				endif 
5862 fe 00				cp 0 
5864 20 03				jr nz, .skipopeneof 
5866					; have opened an empty file 
5866					 
5866 32 a5 f9				ld (store_openext), a 
5869			 
5869			.skipopeneof: 
5869			 
5869 6f					ld l, a 
586a 26 00				ld h, 0 
586c cd 1b 23				call forth_push_numhl 
586f			 
586f			 
586f				       NEXTW 
586f c3 c8 26			jp macro_next 
5872				endm 
# End of macro NEXTW
5872			.READ: 
5872				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5872 6c				db WORD_SYS_CORE+88             
5873 9c 59			dw .EOF            
5875 05				db 4 + 1 
5876 .. 00			db "READ",0              
587b				endm 
# End of macro CWHEAD
587b			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
587b			; | | e.g. 
587b			; | | $01 OPEN $01 DO READ . LOOP 
587b			; | | 
587b			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
587b			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
587b			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
587b			; | | two bytes contain the file id and extent. 
587b			; | |  
587b			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
587b			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
587b			; | | > [!NOTE] 
587b			; | | > Compatible with PicoSPINet  
587b			 
587b					if DEBUG_FORTH_WORDS_KEY 
587b						DMARK "REA" 
587b f5				push af  
587c 3a 90 58			ld a, (.dmark)  
587f 32 a6 fd			ld (debug_mark),a  
5882 3a 91 58			ld a, (.dmark+1)  
5885 32 a7 fd			ld (debug_mark+1),a  
5888 3a 92 58			ld a, (.dmark+2)  
588b 32 a8 fd			ld (debug_mark+2),a  
588e 18 03			jr .pastdmark  
5890 ..			.dmark: db "REA"  
5893 f1			.pastdmark: pop af  
5894			endm  
# End of macro DMARK
5894						CALLMONITOR 
5894 cd aa fd			call debug_vector  
5897				endm  
# End of macro CALLMONITOR
5897					endif 
5897					; store_openext use it. If zero it is EOF 
5897			 
5897					; read block from current stream id 
5897					; if the block does not contain zero term keep reading blocks until zero found 
5897					; push the block to stack 
5897					; save the block id to stream 
5897			 
5897			 
5897 cd c9 59				call .testeof 
589a 3e 01				ld a, 1 
589c bd					cp l 
589d ca 78 59				jp z, .ateof 
58a0			 
58a0			 
58a0			;		FORTH_DSP_VALUEHL 
58a0			 
58a0			;		push hl 
58a0			 
58a0			;	if DEBUG_STORESE 
58a0			;		DMARK "REA" 
58a0			;		CALLMONITOR 
58a0			;	endif 
58a0			;		FORTH_DSP_POP 
58a0			 
58a0			;		pop hl 
58a0				 
58a0 3a a2 f9				ld a, (store_filecache) 
58a3 67					ld h,a 
58a4			 
58a4 3a a5 f9				ld a, (store_openext) 
58a7 6f					ld l, a 
58a8					 
58a8 fe 00				cp 0 
58aa ca 78 59				jp z, .ateof     ; dont read past eof 
58ad			 
58ad cd a1 0c				call storage_clear_page 
58b0			 
58b0 11 b5 f9				ld de, store_page 
58b3				if DEBUG_STORESE 
58b3					DMARK "RE1" 
58b3 f5				push af  
58b4 3a c8 58			ld a, (.dmark)  
58b7 32 a6 fd			ld (debug_mark),a  
58ba 3a c9 58			ld a, (.dmark+1)  
58bd 32 a7 fd			ld (debug_mark+1),a  
58c0 3a ca 58			ld a, (.dmark+2)  
58c3 32 a8 fd			ld (debug_mark+2),a  
58c6 18 03			jr .pastdmark  
58c8 ..			.dmark: db "RE1"  
58cb f1			.pastdmark: pop af  
58cc			endm  
# End of macro DMARK
58cc					CALLMONITOR 
58cc cd aa fd			call debug_vector  
58cf				endm  
# End of macro CALLMONITOR
58cf				endif 
58cf cd be 09				call storage_read 
58d2			 
58d2				if DEBUG_STORESE 
58d2					DMARK "RE2" 
58d2 f5				push af  
58d3 3a e7 58			ld a, (.dmark)  
58d6 32 a6 fd			ld (debug_mark),a  
58d9 3a e8 58			ld a, (.dmark+1)  
58dc 32 a7 fd			ld (debug_mark+1),a  
58df 3a e9 58			ld a, (.dmark+2)  
58e2 32 a8 fd			ld (debug_mark+2),a  
58e5 18 03			jr .pastdmark  
58e7 ..			.dmark: db "RE2"  
58ea f1			.pastdmark: pop af  
58eb			endm  
# End of macro DMARK
58eb					CALLMONITOR 
58eb cd aa fd			call debug_vector  
58ee				endm  
# End of macro CALLMONITOR
58ee				endif 
58ee cd f8 0f			call ishlzero 
58f1			;	ld a, l 
58f1			;	add h 
58f1			;	cp 0 
58f1 ca 78 59			jp z, .readeof 
58f4			 
58f4				; not eof so hl should point to data to push to stack 
58f4			 
58f4				if DEBUG_STORESE 
58f4					DMARK "RE3" 
58f4 f5				push af  
58f5 3a 09 59			ld a, (.dmark)  
58f8 32 a6 fd			ld (debug_mark),a  
58fb 3a 0a 59			ld a, (.dmark+1)  
58fe 32 a7 fd			ld (debug_mark+1),a  
5901 3a 0b 59			ld a, (.dmark+2)  
5904 32 a8 fd			ld (debug_mark+2),a  
5907 18 03			jr .pastdmark  
5909 ..			.dmark: db "RE3"  
590c f1			.pastdmark: pop af  
590d			endm  
# End of macro DMARK
590d					CALLMONITOR 
590d cd aa fd			call debug_vector  
5910				endm  
# End of macro CALLMONITOR
5910				endif 
5910 cd 89 23			call forth_push_str 
5913			 
5913				if DEBUG_STORESE 
5913					DMARK "RE4" 
5913 f5				push af  
5914 3a 28 59			ld a, (.dmark)  
5917 32 a6 fd			ld (debug_mark),a  
591a 3a 29 59			ld a, (.dmark+1)  
591d 32 a7 fd			ld (debug_mark+1),a  
5920 3a 2a 59			ld a, (.dmark+2)  
5923 32 a8 fd			ld (debug_mark+2),a  
5926 18 03			jr .pastdmark  
5928 ..			.dmark: db "RE4"  
592b f1			.pastdmark: pop af  
592c			endm  
# End of macro DMARK
592c					CALLMONITOR 
592c cd aa fd			call debug_vector  
592f				endm  
# End of macro CALLMONITOR
592f				endif 
592f				; get next block  or mark as eof 
592f			 
592f 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
5932 4f				ld c, a	 
5933 3a a5 f9			ld a, (store_openext) 
5936			 
5936				if DEBUG_STORESE 
5936					DMARK "RE5" 
5936 f5				push af  
5937 3a 4b 59			ld a, (.dmark)  
593a 32 a6 fd			ld (debug_mark),a  
593d 3a 4c 59			ld a, (.dmark+1)  
5940 32 a7 fd			ld (debug_mark+1),a  
5943 3a 4d 59			ld a, (.dmark+2)  
5946 32 a8 fd			ld (debug_mark+2),a  
5949 18 03			jr .pastdmark  
594b ..			.dmark: db "RE5"  
594e f1			.pastdmark: pop af  
594f			endm  
# End of macro DMARK
594f					CALLMONITOR 
594f cd aa fd			call debug_vector  
5952				endm  
# End of macro CALLMONITOR
5952				endif 
5952 b9				cp c 
5953 28 23			jr z, .readeof     ; at last extent 
5955			 
5955 3c					inc a 
5956 32 a5 f9				ld (store_openext), a 
5959			 
5959				if DEBUG_STORESE 
5959					DMARK "RE6" 
5959 f5				push af  
595a 3a 6e 59			ld a, (.dmark)  
595d 32 a6 fd			ld (debug_mark),a  
5960 3a 6f 59			ld a, (.dmark+1)  
5963 32 a7 fd			ld (debug_mark+1),a  
5966 3a 70 59			ld a, (.dmark+2)  
5969 32 a8 fd			ld (debug_mark+2),a  
596c 18 03			jr .pastdmark  
596e ..			.dmark: db "RE6"  
5971 f1			.pastdmark: pop af  
5972			endm  
# End of macro DMARK
5972					CALLMONITOR 
5972 cd aa fd			call debug_vector  
5975				endm  
# End of macro CALLMONITOR
5975				endif 
5975			 
5975			 
5975				       NEXTW 
5975 c3 c8 26			jp macro_next 
5978				endm 
# End of macro NEXTW
5978			.ateof: 
5978				;	ld hl, .showeof 
5978				;	call forth_push_str 
5978 3e 00		.readeof:	ld a, 0 
597a 32 a5 f9				ld (store_openext), a 
597d			 
597d					 
597d				if DEBUG_STORESE 
597d					DMARK "REF" 
597d f5				push af  
597e 3a 92 59			ld a, (.dmark)  
5981 32 a6 fd			ld (debug_mark),a  
5984 3a 93 59			ld a, (.dmark+1)  
5987 32 a7 fd			ld (debug_mark+1),a  
598a 3a 94 59			ld a, (.dmark+2)  
598d 32 a8 fd			ld (debug_mark+2),a  
5990 18 03			jr .pastdmark  
5992 ..			.dmark: db "REF"  
5995 f1			.pastdmark: pop af  
5996			endm  
# End of macro DMARK
5996					CALLMONITOR 
5996 cd aa fd			call debug_vector  
5999				endm  
# End of macro CALLMONITOR
5999				endif 
5999				       NEXTW 
5999 c3 c8 26			jp macro_next 
599c				endm 
# End of macro NEXTW
599c			 
599c			;.showeof:   db "eof", 0 
599c			 
599c			 
599c			.EOF: 
599c				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
599c 6d				db WORD_SYS_CORE+89             
599d de 59			dw .FORMAT            
599f 04				db 3 + 1 
59a0 .. 00			db "EOF",0              
59a4				endm 
# End of macro CWHEAD
59a4			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
59a4			; | | e.g. 
59a4			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
59a4			; | | > [!NOTE] 
59a4			; | | > Compatible with PicoSPINet  
59a4					; TODO if current block id for stream is zero then push true else false 
59a4			 
59a4					if DEBUG_FORTH_WORDS_KEY 
59a4						DMARK "EOF" 
59a4 f5				push af  
59a5 3a b9 59			ld a, (.dmark)  
59a8 32 a6 fd			ld (debug_mark),a  
59ab 3a ba 59			ld a, (.dmark+1)  
59ae 32 a7 fd			ld (debug_mark+1),a  
59b1 3a bb 59			ld a, (.dmark+2)  
59b4 32 a8 fd			ld (debug_mark+2),a  
59b7 18 03			jr .pastdmark  
59b9 ..			.dmark: db "EOF"  
59bc f1			.pastdmark: pop af  
59bd			endm  
# End of macro DMARK
59bd						CALLMONITOR 
59bd cd aa fd			call debug_vector  
59c0				endm  
# End of macro CALLMONITOR
59c0					endif 
59c0			 
59c0					; TODO handlue multiple file streams 
59c0			 
59c0			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
59c0 cd c9 59				call .testeof 
59c3 cd 1b 23				call forth_push_numhl 
59c6			 
59c6			 
59c6				       NEXTW 
59c6 c3 c8 26			jp macro_next 
59c9				endm 
# End of macro NEXTW
59c9			 
59c9			.testeof: 
59c9 2e 01				ld l, 1 
59cb 3a a4 f9				ld a, (store_openmaxext) 
59ce fe 00				cp 0 
59d0 28 09				jr  z, .eofdone   ; empty file 
59d2 3a a5 f9				ld a, (store_openext) 
59d5 fe 00				cp 0 
59d7 28 02				jr  z, .eofdone 
59d9 2e 00				ld l, 0 
59db 26 00		.eofdone:	ld h, 0 
59dd c9					ret 
59de			 
59de			 
59de			 
59de			 
59de			.FORMAT: 
59de				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
59de 6d				db WORD_SYS_CORE+89             
59df 2f 5a			dw .LABEL            
59e1 07				db 6 + 1 
59e2 .. 00			db "FORMAT",0              
59e9				endm 
# End of macro CWHEAD
59e9			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
59e9			; | | > [!NOTE] 
59e9			; | | > Compatible with PicoSPINet  
59e9					; TODO if current block id for stream is zero then push true else false 
59e9				 
59e9				if DEBUG_STORESE 
59e9					DMARK "FOR" 
59e9 f5				push af  
59ea 3a fe 59			ld a, (.dmark)  
59ed 32 a6 fd			ld (debug_mark),a  
59f0 3a ff 59			ld a, (.dmark+1)  
59f3 32 a7 fd			ld (debug_mark+1),a  
59f6 3a 00 5a			ld a, (.dmark+2)  
59f9 32 a8 fd			ld (debug_mark+2),a  
59fc 18 03			jr .pastdmark  
59fe ..			.dmark: db "FOR"  
5a01 f1			.pastdmark: pop af  
5a02			endm  
# End of macro DMARK
5a02					CALLMONITOR 
5a02 cd aa fd			call debug_vector  
5a05				endm  
# End of macro CALLMONITOR
5a05				endif 
5a05					; Wipes the bank check flags to cause a reformat on next block 0 read 
5a05			 
5a05 21 01 00				ld hl, 1 
5a08 3e 00				ld a, 0 
5a0a cd 6a 02				call se_writebyte 
5a0d			 
5a0d				if DEBUG_STORESE 
5a0d					DMARK "FO0" 
5a0d f5				push af  
5a0e 3a 22 5a			ld a, (.dmark)  
5a11 32 a6 fd			ld (debug_mark),a  
5a14 3a 23 5a			ld a, (.dmark+1)  
5a17 32 a7 fd			ld (debug_mark+1),a  
5a1a 3a 24 5a			ld a, (.dmark+2)  
5a1d 32 a8 fd			ld (debug_mark+2),a  
5a20 18 03			jr .pastdmark  
5a22 ..			.dmark: db "FO0"  
5a25 f1			.pastdmark: pop af  
5a26			endm  
# End of macro DMARK
5a26					CALLMONITOR 
5a26 cd aa fd			call debug_vector  
5a29				endm  
# End of macro CALLMONITOR
5a29				endif 
5a29					; force bank init 
5a29			 
5a29 cd 16 05				call storage_get_block_0 
5a2c					 
5a2c				       NEXTW 
5a2c c3 c8 26			jp macro_next 
5a2f				endm 
# End of macro NEXTW
5a2f			.LABEL: 
5a2f				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5a2f 6d				db WORD_SYS_CORE+89             
5a30 7d 5a			dw .STOREPAGE            
5a32 06				db 5 + 1 
5a33 .. 00			db "LABEL",0              
5a39				endm 
# End of macro CWHEAD
5a39			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5a39			; | | > [!NOTE] 
5a39			; | | > Compatible with PicoSPINet  
5a39					; TODO test to see if bank is selected 
5a39				 
5a39					if DEBUG_FORTH_WORDS_KEY 
5a39						DMARK "LBL" 
5a39 f5				push af  
5a3a 3a 4e 5a			ld a, (.dmark)  
5a3d 32 a6 fd			ld (debug_mark),a  
5a40 3a 4f 5a			ld a, (.dmark+1)  
5a43 32 a7 fd			ld (debug_mark+1),a  
5a46 3a 50 5a			ld a, (.dmark+2)  
5a49 32 a8 fd			ld (debug_mark+2),a  
5a4c 18 03			jr .pastdmark  
5a4e ..			.dmark: db "LBL"  
5a51 f1			.pastdmark: pop af  
5a52			endm  
# End of macro DMARK
5a52						CALLMONITOR 
5a52 cd aa fd			call debug_vector  
5a55				endm  
# End of macro CALLMONITOR
5a55					endif 
5a55			;	if DEBUG_STORESE 
5a55			;		DMARK "LBL" 
5a55			;		CALLMONITOR 
5a55			;	endif 
5a55					FORTH_DSP_VALUEHL 
5a55 cd 12 25			call macro_dsp_valuehl 
5a58				endm 
# End of macro FORTH_DSP_VALUEHL
5a58					;v5FORTH_DSP_VALUE 
5a58					 
5a58			;		push hl 
5a58					FORTH_DSP_POP 
5a58 cd ca 25			call macro_forth_dsp_pop 
5a5b				endm 
# End of macro FORTH_DSP_POP
5a5b			;		pop hl 
5a5b			 
5a5b			;v5		inc hl   ; move past the type marker 
5a5b			 
5a5b				if DEBUG_STORESE 
5a5b					DMARK "LBl" 
5a5b f5				push af  
5a5c 3a 70 5a			ld a, (.dmark)  
5a5f 32 a6 fd			ld (debug_mark),a  
5a62 3a 71 5a			ld a, (.dmark+1)  
5a65 32 a7 fd			ld (debug_mark+1),a  
5a68 3a 72 5a			ld a, (.dmark+2)  
5a6b 32 a8 fd			ld (debug_mark+2),a  
5a6e 18 03			jr .pastdmark  
5a70 ..			.dmark: db "LBl"  
5a73 f1			.pastdmark: pop af  
5a74			endm  
# End of macro DMARK
5a74					CALLMONITOR 
5a74 cd aa fd			call debug_vector  
5a77				endm  
# End of macro CALLMONITOR
5a77				endif 
5a77 cd 3a 06				call storage_label 
5a7a			 
5a7a				       NEXTW 
5a7a c3 c8 26			jp macro_next 
5a7d				endm 
# End of macro NEXTW
5a7d			.STOREPAGE: 
5a7d				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5a7d 6d				db WORD_SYS_CORE+89             
5a7e b0 5a			dw .LABELS            
5a80 0a				db 9 + 1 
5a81 .. 00			db "STOREPAGE",0              
5a8b				endm 
# End of macro CWHEAD
5a8b			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5a8b			; | | > [!NOTE] 
5a8b			; | | > Compatible with PicoSPINet  
5a8b					; TODO test to see if bank is selected 
5a8b				 
5a8b					if DEBUG_FORTH_WORDS_KEY 
5a8b						DMARK "STP" 
5a8b f5				push af  
5a8c 3a a0 5a			ld a, (.dmark)  
5a8f 32 a6 fd			ld (debug_mark),a  
5a92 3a a1 5a			ld a, (.dmark+1)  
5a95 32 a7 fd			ld (debug_mark+1),a  
5a98 3a a2 5a			ld a, (.dmark+2)  
5a9b 32 a8 fd			ld (debug_mark+2),a  
5a9e 18 03			jr .pastdmark  
5aa0 ..			.dmark: db "STP"  
5aa3 f1			.pastdmark: pop af  
5aa4			endm  
# End of macro DMARK
5aa4						CALLMONITOR 
5aa4 cd aa fd			call debug_vector  
5aa7				endm  
# End of macro CALLMONITOR
5aa7					endif 
5aa7			;	if DEBUG_STORESE 
5aa7			;		DMARK "STP" 
5aa7			;		CALLMONITOR 
5aa7			;	endif 
5aa7			 
5aa7 21 b5 f9			ld hl, store_page 
5aaa cd 1b 23			call forth_push_numhl 
5aad			 
5aad			 
5aad				       NEXTW 
5aad c3 c8 26			jp macro_next 
5ab0				endm 
# End of macro NEXTW
5ab0			.LABELS: 
5ab0				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5ab0 6d				db WORD_SYS_CORE+89             
5ab1 3a 5b			dw .SCONST1            
5ab3 07				db 6 + 1 
5ab4 .. 00			db "LABELS",0              
5abb				endm 
# End of macro CWHEAD
5abb			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5abb			; | | > [!CAUTION] 
5abb			; | | > *NOT* Compatible with PicoSPINet  
5abb					;  
5abb			 
5abb					; save the current device selected to restore afterwards 
5abb				 
5abb 3a 9b f9				ld a, (spi_device) 
5abe f5					push af 
5abf			 
5abf			 
5abf					; run through each of the banks 
5abf			 
5abf 21 01 00				ld hl, 1 
5ac2 cd 1b 23				call forth_push_numhl 
5ac5 3e ff				ld a, SPI_CE_HIGH 
5ac7 cb 87				res SPI_CE0, a 
5ac9 32 9b f9				ld (spi_device), a 
5acc cd 16 05				call storage_get_block_0 
5acf 21 b8 f9				ld hl, store_page+3 
5ad2 cd 89 23				call forth_push_str 
5ad5			 
5ad5					 
5ad5 21 02 00				ld hl, 2 
5ad8 cd 1b 23				call forth_push_numhl 
5adb 3e ff				ld a, SPI_CE_HIGH 
5add cb 8f				res SPI_CE1, a 
5adf 32 9b f9				ld (spi_device), a 
5ae2 cd 16 05				call storage_get_block_0 
5ae5 21 b8 f9				ld hl, store_page+3 
5ae8 cd 89 23				call forth_push_str 
5aeb			 
5aeb					 
5aeb 21 03 00				ld hl, 3 
5aee cd 1b 23				call forth_push_numhl 
5af1 3e ff				ld a, SPI_CE_HIGH 
5af3 cb 97				res SPI_CE2, a 
5af5 32 9b f9				ld (spi_device), a 
5af8 cd 16 05				call storage_get_block_0 
5afb 21 b8 f9				ld hl, store_page+3 
5afe cd 89 23				call forth_push_str 
5b01			 
5b01			 
5b01 21 04 00				ld hl, 4 
5b04 cd 1b 23				call forth_push_numhl 
5b07 3e ff				ld a, SPI_CE_HIGH 
5b09 cb 9f				res SPI_CE3, a 
5b0b 32 9b f9				ld (spi_device), a 
5b0e cd 16 05				call storage_get_block_0 
5b11 21 b8 f9				ld hl, store_page+3 
5b14 cd 89 23				call forth_push_str 
5b17			 
5b17					 
5b17			 
5b17 21 05 00				ld hl, 5 
5b1a cd 1b 23				call forth_push_numhl 
5b1d 3e ff				ld a, SPI_CE_HIGH 
5b1f cb a7				res SPI_CE4, a 
5b21 32 9b f9				ld (spi_device), a 
5b24 cd 16 05				call storage_get_block_0 
5b27 21 b8 f9				ld hl, store_page+3 
5b2a cd 89 23				call forth_push_str 
5b2d			 
5b2d					 
5b2d					; push fixed count of storage devices (on board) for now 
5b2d			 
5b2d 21 05 00				ld hl, 5 
5b30 cd 1b 23				call forth_push_numhl 
5b33			 
5b33					; restore selected device  
5b33				 
5b33 f1					pop af 
5b34 32 9b f9				ld (spi_device), a 
5b37			 
5b37				       NEXTW 
5b37 c3 c8 26			jp macro_next 
5b3a				endm 
# End of macro NEXTW
5b3a			 
5b3a			.SCONST1: 
5b3a				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5b3a 6d				db WORD_SYS_CORE+89             
5b3b 51 5b			dw .SCONST2            
5b3d 07				db 6 + 1 
5b3e .. 00			db "FILEID",0              
5b45				endm 
# End of macro CWHEAD
5b45			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5b45			; | | > [!NOTE] 
5b45			; | | > Compatible with PicoSPINet  
5b45 3a a2 f9				ld a, (store_filecache) 
5b48 26 00				ld h, 0 
5b4a 6f					ld l, a 
5b4b cd 1b 23				call forth_push_numhl 
5b4e					NEXTW 
5b4e c3 c8 26			jp macro_next 
5b51				endm 
# End of macro NEXTW
5b51			.SCONST2: 
5b51				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5b51 6d				db WORD_SYS_CORE+89             
5b52 69 5b			dw .SCONST3            
5b54 08				db 7 + 1 
5b55 .. 00			db "FILEEXT",0              
5b5d				endm 
# End of macro CWHEAD
5b5d			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5b5d			; | | > [!NOTE] 
5b5d			; | | > Compatible with PicoSPINet  
5b5d 3a a5 f9				ld a, (store_openext) 
5b60 26 00				ld h, 0 
5b62 6f					ld l, a 
5b63 cd 1b 23				call forth_push_numhl 
5b66					NEXTW 
5b66 c3 c8 26			jp macro_next 
5b69				endm 
# End of macro NEXTW
5b69			.SCONST3: 
5b69				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5b69 6d				db WORD_SYS_CORE+89             
5b6a 81 5b			dw .SCONST4            
5b6c 08				db 7 + 1 
5b6d .. 00			db "FILEMAX",0              
5b75				endm 
# End of macro CWHEAD
5b75			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5b75			; | | > [!NOTE] 
5b75			; | | > Compatible with PicoSPINet  
5b75 3a a4 f9				ld a, (store_openmaxext) 
5b78 26 00				ld h, 0 
5b7a 6f					ld l, a 
5b7b cd 1b 23				call forth_push_numhl 
5b7e					NEXTW 
5b7e c3 c8 26			jp macro_next 
5b81				endm 
# End of macro NEXTW
5b81			.SCONST4: 
5b81				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5b81 6d				db WORD_SYS_CORE+89             
5b82 97 5b			dw .SCONST5            
5b84 09				db 8 + 1 
5b85 .. 00			db "FILEADDR",0              
5b8e				endm 
# End of macro CWHEAD
5b8e			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5b8e			; | | > [!NOTE] 
5b8e			; | | > Compatible with PicoSPINet  
5b8e 2a a6 f9				ld hl, (store_openaddr) 
5b91 cd 1b 23				call forth_push_numhl 
5b94					NEXTW 
5b94 c3 c8 26			jp macro_next 
5b97				endm 
# End of macro NEXTW
5b97			.SCONST5: 
5b97				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5b97 6d				db WORD_SYS_CORE+89             
5b98 b8 5b			dw .SCONST6            
5b9a 09				db 8 + 1 
5b9b .. 00			db "FILEPAGE",0              
5ba4				endm 
# End of macro CWHEAD
5ba4			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5ba4			; | | > [!NOTE] 
5ba4			; | | > Compatible with PicoSPINet  
5ba4 2a a6 f9				ld hl, (store_openaddr) 
5ba7 e5					push hl 
5ba8 c1					pop bc 
5ba9 16 00				ld d, 0 
5bab 1e 40				ld e, STORE_BLOCK_PHY 
5bad cd 2c 0f				call Div16 
5bb0 c5					push bc 
5bb1 e1					pop hl 
5bb2 cd 1b 23				call forth_push_numhl 
5bb5					NEXTW 
5bb5 c3 c8 26			jp macro_next 
5bb8				endm 
# End of macro NEXTW
5bb8			.SCONST6: 
5bb8				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5bb8 6d				db WORD_SYS_CORE+89             
5bb9 d1 5b			dw .ENDSTORAGE            
5bbb 09				db 8 + 1 
5bbc .. 00			db "READCONT",0              
5bc5				endm 
# End of macro CWHEAD
5bc5			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5bc5			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5bc5			; | | a further read should, if applicable, be CONCAT to the previous read. 
5bc5			; | | > [!NOTE] 
5bc5			; | | > Compatible with PicoSPINet  
5bc5 3a a8 f9				ld a, (store_readcont) 
5bc8 26 00				ld h, 0 
5bca 6f					ld l, a 
5bcb cd 1b 23				call forth_push_numhl 
5bce					NEXTW 
5bce c3 c8 26			jp macro_next 
5bd1				endm 
# End of macro NEXTW
5bd1			.ENDSTORAGE: 
5bd1			; eof 
# End of file forth_words_storage.asm
5bd1			endif 
5bd1				include "forth_words_device.asm" 
5bd1			; Device related words 
5bd1			 
5bd1			; | ## Device Words 
5bd1			 
5bd1			;if SOUND_ENABLE 
5bd1			;.NOTE: 
5bd1			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5bd1			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5bd1			;		if DEBUG_FORTH_WORDS_KEY 
5bd1			;			DMARK "NTE" 
5bd1			;			CALLMONITOR 
5bd1			;		endif 
5bd1			; 
5bd1			;	 
5bd1			; 
5bd1			;		NEXTW 
5bd1			;.AFTERSOUND: 
5bd1			;endif 
5bd1			 
5bd1			 
5bd1			USE_GPIO: equ 0 
5bd1			 
5bd1			if USE_GPIO 
5bd1			.GP1: 
5bd1				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5bd1			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5bd1					NEXTW 
5bd1			.GP2: 
5bd1				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5bd1			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5bd1			 
5bd1					NEXTW 
5bd1			 
5bd1			.GP3: 
5bd1				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5bd1			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5bd1			 
5bd1					NEXTW 
5bd1			 
5bd1			.GP4: 
5bd1				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5bd1			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5bd1			 
5bd1					NEXTW 
5bd1			.SIN: 
5bd1			 
5bd1			 
5bd1			endif 
5bd1			 
5bd1			 
5bd1				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5bd1 33				db WORD_SYS_CORE+31             
5bd2 06 5c			dw .SOUT            
5bd4 03				db 2 + 1 
5bd5 .. 00			db "IN",0              
5bd8				endm 
# End of macro CWHEAD
5bd8			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5bd8					if DEBUG_FORTH_WORDS_KEY 
5bd8						DMARK "IN." 
5bd8 f5				push af  
5bd9 3a ed 5b			ld a, (.dmark)  
5bdc 32 a6 fd			ld (debug_mark),a  
5bdf 3a ee 5b			ld a, (.dmark+1)  
5be2 32 a7 fd			ld (debug_mark+1),a  
5be5 3a ef 5b			ld a, (.dmark+2)  
5be8 32 a8 fd			ld (debug_mark+2),a  
5beb 18 03			jr .pastdmark  
5bed ..			.dmark: db "IN."  
5bf0 f1			.pastdmark: pop af  
5bf1			endm  
# End of macro DMARK
5bf1						CALLMONITOR 
5bf1 cd aa fd			call debug_vector  
5bf4				endm  
# End of macro CALLMONITOR
5bf4					endif 
5bf4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5bf4 cd 12 25			call macro_dsp_valuehl 
5bf7				endm 
# End of macro FORTH_DSP_VALUEHL
5bf7			 
5bf7 e5					push hl 
5bf8			 
5bf8					; destroy value TOS 
5bf8			 
5bf8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bf8 cd ca 25			call macro_forth_dsp_pop 
5bfb				endm 
# End of macro FORTH_DSP_POP
5bfb			 
5bfb					; one value on hl get other one back 
5bfb			 
5bfb c1					pop bc 
5bfc			 
5bfc					; do the sub 
5bfc			;		ex de, hl 
5bfc			 
5bfc ed 68				in l,(c) 
5bfe			 
5bfe					; save it 
5bfe			 
5bfe 26 00				ld h,0 
5c00			 
5c00					; TODO push value back onto stack for another op etc 
5c00			 
5c00 cd 1b 23				call forth_push_numhl 
5c03					NEXTW 
5c03 c3 c8 26			jp macro_next 
5c06				endm 
# End of macro NEXTW
5c06			.SOUT: 
5c06				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5c06 34				db WORD_SYS_CORE+32             
5c07 59 5c			dw .SPIO            
5c09 04				db 3 + 1 
5c0a .. 00			db "OUT",0              
5c0e				endm 
# End of macro CWHEAD
5c0e			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5c0e					if DEBUG_FORTH_WORDS_KEY 
5c0e						DMARK "OUT" 
5c0e f5				push af  
5c0f 3a 23 5c			ld a, (.dmark)  
5c12 32 a6 fd			ld (debug_mark),a  
5c15 3a 24 5c			ld a, (.dmark+1)  
5c18 32 a7 fd			ld (debug_mark+1),a  
5c1b 3a 25 5c			ld a, (.dmark+2)  
5c1e 32 a8 fd			ld (debug_mark+2),a  
5c21 18 03			jr .pastdmark  
5c23 ..			.dmark: db "OUT"  
5c26 f1			.pastdmark: pop af  
5c27			endm  
# End of macro DMARK
5c27						CALLMONITOR 
5c27 cd aa fd			call debug_vector  
5c2a				endm  
# End of macro CALLMONITOR
5c2a					endif 
5c2a			 
5c2a					; get port 
5c2a			 
5c2a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c2a cd 12 25			call macro_dsp_valuehl 
5c2d				endm 
# End of macro FORTH_DSP_VALUEHL
5c2d			 
5c2d e5					push hl 
5c2e			 
5c2e					; destroy value TOS 
5c2e			 
5c2e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c2e cd ca 25			call macro_forth_dsp_pop 
5c31				endm 
# End of macro FORTH_DSP_POP
5c31			 
5c31					; get byte to send 
5c31			 
5c31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c31 cd 12 25			call macro_dsp_valuehl 
5c34				endm 
# End of macro FORTH_DSP_VALUEHL
5c34			 
5c34			;		push hl 
5c34			 
5c34					; destroy value TOS 
5c34			 
5c34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c34 cd ca 25			call macro_forth_dsp_pop 
5c37				endm 
# End of macro FORTH_DSP_POP
5c37			 
5c37					; one value on hl get other one back 
5c37			 
5c37			;		pop hl 
5c37			 
5c37 c1					pop bc 
5c38			 
5c38					if DEBUG_FORTH_WORDS 
5c38						DMARK "OUT" 
5c38 f5				push af  
5c39 3a 4d 5c			ld a, (.dmark)  
5c3c 32 a6 fd			ld (debug_mark),a  
5c3f 3a 4e 5c			ld a, (.dmark+1)  
5c42 32 a7 fd			ld (debug_mark+1),a  
5c45 3a 4f 5c			ld a, (.dmark+2)  
5c48 32 a8 fd			ld (debug_mark+2),a  
5c4b 18 03			jr .pastdmark  
5c4d ..			.dmark: db "OUT"  
5c50 f1			.pastdmark: pop af  
5c51			endm  
# End of macro DMARK
5c51						CALLMONITOR 
5c51 cd aa fd			call debug_vector  
5c54				endm  
# End of macro CALLMONITOR
5c54					endif 
5c54			 
5c54 ed 69				out (c), l 
5c56			 
5c56					NEXTW 
5c56 c3 c8 26			jp macro_next 
5c59				endm 
# End of macro NEXTW
5c59			 
5c59			 
5c59			.SPIO: 
5c59			 
5c59			if STORAGE_SE 
5c59				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5c59 51				db WORD_SYS_CORE+61             
5c5a 6a 5c			dw .SPICEH            
5c5c 07				db 6 + 1 
5c5d .. 00			db "SPICEL",0              
5c64				endm 
# End of macro CWHEAD
5c64			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5c64			 
5c64 cd 13 02				call spi_ce_low 
5c67			    NEXTW 
5c67 c3 c8 26			jp macro_next 
5c6a				endm 
# End of macro NEXTW
5c6a			 
5c6a			.SPICEH: 
5c6a				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5c6a 51				db WORD_SYS_CORE+61             
5c6b 7b 5c			dw .SPIOb            
5c6d 07				db 6 + 1 
5c6e .. 00			db "SPICEH",0              
5c75				endm 
# End of macro CWHEAD
5c75			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5c75			 
5c75 cd 02 02				call spi_ce_high 
5c78			    NEXTW 
5c78 c3 c8 26			jp macro_next 
5c7b				endm 
# End of macro NEXTW
5c7b			 
5c7b			 
5c7b			.SPIOb: 
5c7b			 
5c7b				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5c7b 51				db WORD_SYS_CORE+61             
5c7c ad 5c			dw .SPII            
5c7e 05				db 4 + 1 
5c7f .. 00			db "SPIO",0              
5c84				endm 
# End of macro CWHEAD
5c84			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5c84			 
5c84					if DEBUG_FORTH_WORDS_KEY 
5c84						DMARK "SPo" 
5c84 f5				push af  
5c85 3a 99 5c			ld a, (.dmark)  
5c88 32 a6 fd			ld (debug_mark),a  
5c8b 3a 9a 5c			ld a, (.dmark+1)  
5c8e 32 a7 fd			ld (debug_mark+1),a  
5c91 3a 9b 5c			ld a, (.dmark+2)  
5c94 32 a8 fd			ld (debug_mark+2),a  
5c97 18 03			jr .pastdmark  
5c99 ..			.dmark: db "SPo"  
5c9c f1			.pastdmark: pop af  
5c9d			endm  
# End of macro DMARK
5c9d						CALLMONITOR 
5c9d cd aa fd			call debug_vector  
5ca0				endm  
# End of macro CALLMONITOR
5ca0					endif 
5ca0					; get port 
5ca0			 
5ca0			 
5ca0					; get byte to send 
5ca0			 
5ca0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ca0 cd 12 25			call macro_dsp_valuehl 
5ca3				endm 
# End of macro FORTH_DSP_VALUEHL
5ca3			 
5ca3			;		push hl    ; u1  
5ca3			 
5ca3					; destroy value TOS 
5ca3			 
5ca3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ca3 cd ca 25			call macro_forth_dsp_pop 
5ca6				endm 
# End of macro FORTH_DSP_POP
5ca6			 
5ca6					; one value on hl get other one back 
5ca6			 
5ca6			;		pop hl   ; u2 - addr 
5ca6			 
5ca6					; TODO Send SPI byte 
5ca6			 
5ca6			;		push hl 
5ca6			;		call spi_ce_low 
5ca6			;		pop hl 
5ca6 7d					ld a, l 
5ca7 cd 01 01				call spi_send_byte 
5caa			;		call spi_ce_high 
5caa			 
5caa					NEXTW 
5caa c3 c8 26			jp macro_next 
5cad				endm 
# End of macro NEXTW
5cad			 
5cad			.SPII: 
5cad				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5cad 52				db WORD_SYS_CORE+62             
5cae 16 5d			dw .SESEL            
5cb0 06				db 5 + 1 
5cb1 .. 00			db "SPII",0              
5cb6				endm 
# End of macro CWHEAD
5cb6			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5cb6					if DEBUG_FORTH_WORDS_KEY 
5cb6						DMARK "SPi" 
5cb6 f5				push af  
5cb7 3a cb 5c			ld a, (.dmark)  
5cba 32 a6 fd			ld (debug_mark),a  
5cbd 3a cc 5c			ld a, (.dmark+1)  
5cc0 32 a7 fd			ld (debug_mark+1),a  
5cc3 3a cd 5c			ld a, (.dmark+2)  
5cc6 32 a8 fd			ld (debug_mark+2),a  
5cc9 18 03			jr .pastdmark  
5ccb ..			.dmark: db "SPi"  
5cce f1			.pastdmark: pop af  
5ccf			endm  
# End of macro DMARK
5ccf						CALLMONITOR 
5ccf cd aa fd			call debug_vector  
5cd2				endm  
# End of macro CALLMONITOR
5cd2					endif 
5cd2			 
5cd2					; TODO Get SPI byte 
5cd2			 
5cd2 cd 28 01				call spi_read_byte 
5cd5			 
5cd5					if DEBUG_FORTH_WORDS 
5cd5						DMARK "Si2" 
5cd5 f5				push af  
5cd6 3a ea 5c			ld a, (.dmark)  
5cd9 32 a6 fd			ld (debug_mark),a  
5cdc 3a eb 5c			ld a, (.dmark+1)  
5cdf 32 a7 fd			ld (debug_mark+1),a  
5ce2 3a ec 5c			ld a, (.dmark+2)  
5ce5 32 a8 fd			ld (debug_mark+2),a  
5ce8 18 03			jr .pastdmark  
5cea ..			.dmark: db "Si2"  
5ced f1			.pastdmark: pop af  
5cee			endm  
# End of macro DMARK
5cee						CALLMONITOR 
5cee cd aa fd			call debug_vector  
5cf1				endm  
# End of macro CALLMONITOR
5cf1					endif 
5cf1 26 00				ld h, 0 
5cf3 6f					ld l, a 
5cf4					if DEBUG_FORTH_WORDS 
5cf4						DMARK "Si3" 
5cf4 f5				push af  
5cf5 3a 09 5d			ld a, (.dmark)  
5cf8 32 a6 fd			ld (debug_mark),a  
5cfb 3a 0a 5d			ld a, (.dmark+1)  
5cfe 32 a7 fd			ld (debug_mark+1),a  
5d01 3a 0b 5d			ld a, (.dmark+2)  
5d04 32 a8 fd			ld (debug_mark+2),a  
5d07 18 03			jr .pastdmark  
5d09 ..			.dmark: db "Si3"  
5d0c f1			.pastdmark: pop af  
5d0d			endm  
# End of macro DMARK
5d0d						CALLMONITOR 
5d0d cd aa fd			call debug_vector  
5d10				endm  
# End of macro CALLMONITOR
5d10					endif 
5d10 cd 1b 23				call forth_push_numhl 
5d13			 
5d13					NEXTW 
5d13 c3 c8 26			jp macro_next 
5d16				endm 
# End of macro NEXTW
5d16			 
5d16			 
5d16			 
5d16			.SESEL: 
5d16				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5d16 66				db WORD_SYS_CORE+82             
5d17 bf 5d			dw .CARTDEV            
5d19 05				db 4 + 1 
5d1a .. 00			db "BANK",0              
5d1f				endm 
# End of macro CWHEAD
5d1f			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5d1f					if DEBUG_FORTH_WORDS_KEY 
5d1f						DMARK "BNK" 
5d1f f5				push af  
5d20 3a 34 5d			ld a, (.dmark)  
5d23 32 a6 fd			ld (debug_mark),a  
5d26 3a 35 5d			ld a, (.dmark+1)  
5d29 32 a7 fd			ld (debug_mark+1),a  
5d2c 3a 36 5d			ld a, (.dmark+2)  
5d2f 32 a8 fd			ld (debug_mark+2),a  
5d32 18 03			jr .pastdmark  
5d34 ..			.dmark: db "BNK"  
5d37 f1			.pastdmark: pop af  
5d38			endm  
# End of macro DMARK
5d38						CALLMONITOR 
5d38 cd aa fd			call debug_vector  
5d3b				endm  
# End of macro CALLMONITOR
5d3b					endif 
5d3b			 
5d3b 3e ff				ld a, 255 
5d3d 32 9e f9				ld (spi_cartdev), a 
5d40			 
5d40					; get bank 
5d40			 
5d40					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d40 cd 12 25			call macro_dsp_valuehl 
5d43				endm 
# End of macro FORTH_DSP_VALUEHL
5d43			 
5d43			;		push hl 
5d43			 
5d43					; destroy value TOS 
5d43			 
5d43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d43 cd ca 25			call macro_forth_dsp_pop 
5d46				endm 
# End of macro FORTH_DSP_POP
5d46			 
5d46					; one value on hl get other one back 
5d46			 
5d46			;		pop hl 
5d46			 
5d46			 
5d46 0e ff				ld c, SPI_CE_HIGH 
5d48 06 30				ld b, '0'    ; human readable bank number 
5d4a			 
5d4a 7d					ld a, l 
5d4b			 
5d4b					if DEBUG_FORTH_WORDS 
5d4b						DMARK "BNK" 
5d4b f5				push af  
5d4c 3a 60 5d			ld a, (.dmark)  
5d4f 32 a6 fd			ld (debug_mark),a  
5d52 3a 61 5d			ld a, (.dmark+1)  
5d55 32 a7 fd			ld (debug_mark+1),a  
5d58 3a 62 5d			ld a, (.dmark+2)  
5d5b 32 a8 fd			ld (debug_mark+2),a  
5d5e 18 03			jr .pastdmark  
5d60 ..			.dmark: db "BNK"  
5d63 f1			.pastdmark: pop af  
5d64			endm  
# End of macro DMARK
5d64						CALLMONITOR 
5d64 cd aa fd			call debug_vector  
5d67				endm  
# End of macro CALLMONITOR
5d67					endif 
5d67			 
5d67					; active low 
5d67			 
5d67 fe 00				cp 0 
5d69 28 28				jr z, .bset 
5d6b fe 01				cp 1 
5d6d 20 04				jr nz, .b2 
5d6f cb 81				res 0, c 
5d71 06 31				ld b, '1'    ; human readable bank number 
5d73 fe 02		.b2:		cp 2 
5d75 20 04				jr nz, .b3 
5d77 cb 89				res 1, c 
5d79 06 32				ld b, '2'    ; human readable bank number 
5d7b fe 03		.b3:		cp 3 
5d7d 20 04				jr nz, .b4 
5d7f cb 91				res 2, c 
5d81 06 33				ld b, '3'    ; human readable bank number 
5d83 fe 04		.b4:		cp 4 
5d85 20 04				jr nz, .b5 
5d87 cb 99				res 3, c 
5d89 06 34				ld b, '4'    ; human readable bank number 
5d8b fe 05		.b5:		cp 5 
5d8d 20 04				jr nz, .bset 
5d8f cb a1				res 4, c 
5d91 06 35				ld b, '5'    ; human readable bank number 
5d93			 
5d93			.bset: 
5d93 79					ld a, c 
5d94 32 9b f9				ld (spi_device),a 
5d97 78					ld a, b 
5d98 32 9a f9				ld (spi_device_id),a 
5d9b					if DEBUG_FORTH_WORDS 
5d9b						DMARK "BN2" 
5d9b f5				push af  
5d9c 3a b0 5d			ld a, (.dmark)  
5d9f 32 a6 fd			ld (debug_mark),a  
5da2 3a b1 5d			ld a, (.dmark+1)  
5da5 32 a7 fd			ld (debug_mark+1),a  
5da8 3a b2 5d			ld a, (.dmark+2)  
5dab 32 a8 fd			ld (debug_mark+2),a  
5dae 18 03			jr .pastdmark  
5db0 ..			.dmark: db "BN2"  
5db3 f1			.pastdmark: pop af  
5db4			endm  
# End of macro DMARK
5db4						CALLMONITOR 
5db4 cd aa fd			call debug_vector  
5db7				endm  
# End of macro CALLMONITOR
5db7					endif 
5db7			 
5db7					; set default SPI clk pulse time as disabled for BANK use 
5db7			 
5db7 3e 00				ld a, 0 
5db9 32 9f f9				ld (spi_clktime), a 
5dbc			 
5dbc					NEXTW 
5dbc c3 c8 26			jp macro_next 
5dbf				endm 
# End of macro NEXTW
5dbf			 
5dbf			.CARTDEV: 
5dbf				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5dbf 66				db WORD_SYS_CORE+82             
5dc0 6d 5e			dw .ENDDEVICE            
5dc2 08				db 7 + 1 
5dc3 .. 00			db "CARTDEV",0              
5dcb				endm 
# End of macro CWHEAD
5dcb			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5dcb					if DEBUG_FORTH_WORDS_KEY 
5dcb						DMARK "CDV" 
5dcb f5				push af  
5dcc 3a e0 5d			ld a, (.dmark)  
5dcf 32 a6 fd			ld (debug_mark),a  
5dd2 3a e1 5d			ld a, (.dmark+1)  
5dd5 32 a7 fd			ld (debug_mark+1),a  
5dd8 3a e2 5d			ld a, (.dmark+2)  
5ddb 32 a8 fd			ld (debug_mark+2),a  
5dde 18 03			jr .pastdmark  
5de0 ..			.dmark: db "CDV"  
5de3 f1			.pastdmark: pop af  
5de4			endm  
# End of macro DMARK
5de4						CALLMONITOR 
5de4 cd aa fd			call debug_vector  
5de7				endm  
# End of macro CALLMONITOR
5de7					endif 
5de7			 
5de7					; disable se storage bank selection 
5de7			 
5de7 3e ff				ld a, SPI_CE_HIGH		; ce high 
5de9 32 9b f9				ld (spi_device), a 
5dec			 
5dec					; get bank 
5dec			 
5dec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5dec cd 12 25			call macro_dsp_valuehl 
5def				endm 
# End of macro FORTH_DSP_VALUEHL
5def			 
5def			;		push hl 
5def			 
5def					; destroy value TOS 
5def			 
5def					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5def cd ca 25			call macro_forth_dsp_pop 
5df2				endm 
# End of macro FORTH_DSP_POP
5df2			 
5df2					; one value on hl get other one back 
5df2			 
5df2			;		pop hl 
5df2			 
5df2					; active low 
5df2			 
5df2 0e ff				ld c, 255 
5df4			 
5df4 7d					ld a, l 
5df5					if DEBUG_FORTH_WORDS 
5df5						DMARK "CDV" 
5df5 f5				push af  
5df6 3a 0a 5e			ld a, (.dmark)  
5df9 32 a6 fd			ld (debug_mark),a  
5dfc 3a 0b 5e			ld a, (.dmark+1)  
5dff 32 a7 fd			ld (debug_mark+1),a  
5e02 3a 0c 5e			ld a, (.dmark+2)  
5e05 32 a8 fd			ld (debug_mark+2),a  
5e08 18 03			jr .pastdmark  
5e0a ..			.dmark: db "CDV"  
5e0d f1			.pastdmark: pop af  
5e0e			endm  
# End of macro DMARK
5e0e						CALLMONITOR 
5e0e cd aa fd			call debug_vector  
5e11				endm  
# End of macro CALLMONITOR
5e11					endif 
5e11 fe 00				cp 0 
5e13 28 30				jr z, .cset 
5e15 fe 01				cp 1 
5e17 20 02				jr nz, .c2 
5e19 cb 81				res 0, c 
5e1b fe 02		.c2:		cp 2 
5e1d 20 02				jr nz, .c3 
5e1f cb 89				res 1, c 
5e21 fe 03		.c3:		cp 3 
5e23 20 02				jr nz, .c4 
5e25 cb 91				res 2, c 
5e27 fe 04		.c4:		cp 4 
5e29 20 02				jr nz, .c5 
5e2b cb 99				res 3, c 
5e2d fe 05		.c5:		cp 5 
5e2f 20 02				jr nz, .c6 
5e31 cb a1				res 4, c 
5e33 fe 06		.c6:		cp 6 
5e35 20 02				jr nz, .c7 
5e37 cb a9				res 5, c 
5e39 fe 07		.c7:		cp 7 
5e3b 20 02				jr nz, .c8 
5e3d cb b1				res 6, c 
5e3f fe 08		.c8:		cp 8 
5e41 20 02				jr nz, .cset 
5e43 cb b9				res 7, c 
5e45 79			.cset:		ld a, c 
5e46 32 9e f9				ld (spi_cartdev),a 
5e49			 
5e49					if DEBUG_FORTH_WORDS 
5e49						DMARK "CD2" 
5e49 f5				push af  
5e4a 3a 5e 5e			ld a, (.dmark)  
5e4d 32 a6 fd			ld (debug_mark),a  
5e50 3a 5f 5e			ld a, (.dmark+1)  
5e53 32 a7 fd			ld (debug_mark+1),a  
5e56 3a 60 5e			ld a, (.dmark+2)  
5e59 32 a8 fd			ld (debug_mark+2),a  
5e5c 18 03			jr .pastdmark  
5e5e ..			.dmark: db "CD2"  
5e61 f1			.pastdmark: pop af  
5e62			endm  
# End of macro DMARK
5e62						CALLMONITOR 
5e62 cd aa fd			call debug_vector  
5e65				endm  
# End of macro CALLMONITOR
5e65					endif 
5e65			 
5e65					; set default SPI clk pulse time as 10ms for CARTDEV use 
5e65			 
5e65 3e 0a				ld a, $0a 
5e67 32 9f f9				ld (spi_clktime), a 
5e6a					NEXTW 
5e6a c3 c8 26			jp macro_next 
5e6d				endm 
# End of macro NEXTW
5e6d			endif 
5e6d			 
5e6d			.ENDDEVICE: 
5e6d			; eof 
5e6d			 
# End of file forth_words_device.asm
5e6d			 
5e6d			; var handler 
5e6d			 
5e6d			 
5e6d			.VARS: 
5e6d				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5e6d 77				db WORD_SYS_CORE+99             
5e6e 1e 5f			dw .V0            
5e70 04				db 3 + 1 
5e71 .. 00			db "VAR",0              
5e75				endm 
# End of macro CWHEAD
5e75			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5e75			;| 
5e75			;| The variable name should consist of a single letter. e.g. "a" 
5e75			;! If a full string is passed then only the first char is looked at 
5e75			;| Any other char could exceed bounds checks!  
5e75			 
5e75					if DEBUG_FORTH_WORDS_KEY 
5e75						DMARK "VAR" 
5e75 f5				push af  
5e76 3a 8a 5e			ld a, (.dmark)  
5e79 32 a6 fd			ld (debug_mark),a  
5e7c 3a 8b 5e			ld a, (.dmark+1)  
5e7f 32 a7 fd			ld (debug_mark+1),a  
5e82 3a 8c 5e			ld a, (.dmark+2)  
5e85 32 a8 fd			ld (debug_mark+2),a  
5e88 18 03			jr .pastdmark  
5e8a ..			.dmark: db "VAR"  
5e8d f1			.pastdmark: pop af  
5e8e			endm  
# End of macro DMARK
5e8e						CALLMONITOR 
5e8e cd aa fd			call debug_vector  
5e91				endm  
# End of macro CALLMONITOR
5e91					endif 
5e91			 
5e91					FORTH_DSP_VALUEHL 
5e91 cd 12 25			call macro_dsp_valuehl 
5e94				endm 
# End of macro FORTH_DSP_VALUEHL
5e94			 
5e94 7e					ld a, (hl)    ; get first char on of the string 
5e95			 
5e95			 
5e95					if DEBUG_FORTH_WORDS 
5e95						DMARK "VR1" 
5e95 f5				push af  
5e96 3a aa 5e			ld a, (.dmark)  
5e99 32 a6 fd			ld (debug_mark),a  
5e9c 3a ab 5e			ld a, (.dmark+1)  
5e9f 32 a7 fd			ld (debug_mark+1),a  
5ea2 3a ac 5e			ld a, (.dmark+2)  
5ea5 32 a8 fd			ld (debug_mark+2),a  
5ea8 18 03			jr .pastdmark  
5eaa ..			.dmark: db "VR1"  
5ead f1			.pastdmark: pop af  
5eae			endm  
# End of macro DMARK
5eae						CALLMONITOR 
5eae cd aa fd			call debug_vector  
5eb1				endm  
# End of macro CALLMONITOR
5eb1					endif 
5eb1					 
5eb1 f5					push af	 
5eb2					FORTH_DSP_POP 
5eb2 cd ca 25			call macro_forth_dsp_pop 
5eb5				endm 
# End of macro FORTH_DSP_POP
5eb5 f1					pop af 
5eb6			 
5eb6					; convert to upper 
5eb6			 
5eb6 cd 54 15				call to_upper 
5eb9					if DEBUG_FORTH_WORDS 
5eb9						DMARK "Vaa" 
5eb9 f5				push af  
5eba 3a ce 5e			ld a, (.dmark)  
5ebd 32 a6 fd			ld (debug_mark),a  
5ec0 3a cf 5e			ld a, (.dmark+1)  
5ec3 32 a7 fd			ld (debug_mark+1),a  
5ec6 3a d0 5e			ld a, (.dmark+2)  
5ec9 32 a8 fd			ld (debug_mark+2),a  
5ecc 18 03			jr .pastdmark  
5ece ..			.dmark: db "Vaa"  
5ed1 f1			.pastdmark: pop af  
5ed2			endm  
# End of macro DMARK
5ed2						CALLMONITOR 
5ed2 cd aa fd			call debug_vector  
5ed5				endm  
# End of macro CALLMONITOR
5ed5					endif 
5ed5 06 41				ld b, 'A' 
5ed7 90					sub b			; set offset 
5ed8					if DEBUG_FORTH_WORDS 
5ed8						DMARK "Vbb" 
5ed8 f5				push af  
5ed9 3a ed 5e			ld a, (.dmark)  
5edc 32 a6 fd			ld (debug_mark),a  
5edf 3a ee 5e			ld a, (.dmark+1)  
5ee2 32 a7 fd			ld (debug_mark+1),a  
5ee5 3a ef 5e			ld a, (.dmark+2)  
5ee8 32 a8 fd			ld (debug_mark+2),a  
5eeb 18 03			jr .pastdmark  
5eed ..			.dmark: db "Vbb"  
5ef0 f1			.pastdmark: pop af  
5ef1			endm  
# End of macro DMARK
5ef1						CALLMONITOR 
5ef1 cd aa fd			call debug_vector  
5ef4				endm  
# End of macro CALLMONITOR
5ef4					endif 
5ef4 cb 27				sla a  
5ef6				 
5ef6					 
5ef6					if DEBUG_FORTH_WORDS 
5ef6						DMARK "VR2" 
5ef6 f5				push af  
5ef7 3a 0b 5f			ld a, (.dmark)  
5efa 32 a6 fd			ld (debug_mark),a  
5efd 3a 0c 5f			ld a, (.dmark+1)  
5f00 32 a7 fd			ld (debug_mark+1),a  
5f03 3a 0d 5f			ld a, (.dmark+2)  
5f06 32 a8 fd			ld (debug_mark+2),a  
5f09 18 03			jr .pastdmark  
5f0b ..			.dmark: db "VR2"  
5f0e f1			.pastdmark: pop af  
5f0f			endm  
# End of macro DMARK
5f0f						CALLMONITOR 
5f0f cd aa fd			call debug_vector  
5f12				endm  
# End of macro CALLMONITOR
5f12					endif 
5f12			 
5f12 21 2f f9				ld hl, cli_var_array2 
5f15 cd cf 0f				call addatohl 
5f18 cd 1b 23				call forth_push_numhl 
5f1b			 
5f1b			 
5f1b				       NEXTW 
5f1b c3 c8 26			jp macro_next 
5f1e				endm 
# End of macro NEXTW
5f1e			.V0: 
5f1e				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5f1e 78				db WORD_SYS_CORE+100             
5f1f 36 5f			dw .V0Q            
5f21 04				db 3 + 1 
5f22 .. 00			db "V0!",0              
5f26				endm 
# End of macro CWHEAD
5f26			;| V0! ( u1 -- )  Store value to v0  | DONE 
5f26			 
5f26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5f26 cd 12 25			call macro_dsp_valuehl 
5f29				endm 
# End of macro FORTH_DSP_VALUEHL
5f29			 
5f29 11 63 f9				ld de, cli_var_array 
5f2c			 
5f2c eb					ex de, hl 
5f2d 73					ld (hl), e 
5f2e 23					inc hl 
5f2f 72					ld (hl), d 
5f30			 
5f30					; destroy value TOS 
5f30			 
5f30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5f30 cd ca 25			call macro_forth_dsp_pop 
5f33				endm 
# End of macro FORTH_DSP_POP
5f33			 
5f33				       NEXTW 
5f33 c3 c8 26			jp macro_next 
5f36				endm 
# End of macro NEXTW
5f36			.V0Q: 
5f36				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5f36 79				db WORD_SYS_CORE+101             
5f37 47 5f			dw .V1S            
5f39 04				db 3 + 1 
5f3a .. 00			db "V0@",0              
5f3e				endm 
# End of macro CWHEAD
5f3e			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5f3e 2a 63 f9				ld hl, (cli_var_array) 
5f41 cd 1b 23				call forth_push_numhl 
5f44			 
5f44				       NEXTW 
5f44 c3 c8 26			jp macro_next 
5f47				endm 
# End of macro NEXTW
5f47			.V1S: 
5f47				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5f47 7a				db WORD_SYS_CORE+102             
5f48 5f 5f			dw .V1Q            
5f4a 04				db 3 + 1 
5f4b .. 00			db "V1!",0              
5f4f				endm 
# End of macro CWHEAD
5f4f			;| V1! ( u1 -- )  Store value to v1 | DONE 
5f4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5f4f cd 12 25			call macro_dsp_valuehl 
5f52				endm 
# End of macro FORTH_DSP_VALUEHL
5f52			 
5f52 11 65 f9				ld de, cli_var_array+2 
5f55				 
5f55 eb					ex de, hl 
5f56 73					ld (hl), e 
5f57 23					inc hl 
5f58 72					ld (hl), d 
5f59			 
5f59					; destroy value TOS 
5f59			 
5f59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5f59 cd ca 25			call macro_forth_dsp_pop 
5f5c				endm 
# End of macro FORTH_DSP_POP
5f5c				       NEXTW 
5f5c c3 c8 26			jp macro_next 
5f5f				endm 
# End of macro NEXTW
5f5f			.V1Q: 
5f5f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5f5f 7b				db WORD_SYS_CORE+103             
5f60 70 5f			dw .V2S            
5f62 04				db 3 + 1 
5f63 .. 00			db "V1@",0              
5f67				endm 
# End of macro CWHEAD
5f67			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5f67 2a 65 f9				ld hl, (cli_var_array+2) 
5f6a cd 1b 23				call forth_push_numhl 
5f6d				       NEXTW 
5f6d c3 c8 26			jp macro_next 
5f70				endm 
# End of macro NEXTW
5f70			.V2S: 
5f70				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5f70 7c				db WORD_SYS_CORE+104             
5f71 88 5f			dw .V2Q            
5f73 04				db 3 + 1 
5f74 .. 00			db "V2!",0              
5f78				endm 
# End of macro CWHEAD
5f78			;| V2! ( u1 -- )  Store value to v2 | DONE 
5f78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5f78 cd 12 25			call macro_dsp_valuehl 
5f7b				endm 
# End of macro FORTH_DSP_VALUEHL
5f7b			 
5f7b 11 67 f9				ld de, cli_var_array+4 
5f7e				 
5f7e eb					ex de, hl 
5f7f 73					ld (hl), e 
5f80 23					inc hl 
5f81 72					ld (hl), d 
5f82			 
5f82					; destroy value TOS 
5f82			 
5f82					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5f82 cd ca 25			call macro_forth_dsp_pop 
5f85				endm 
# End of macro FORTH_DSP_POP
5f85				       NEXTW 
5f85 c3 c8 26			jp macro_next 
5f88				endm 
# End of macro NEXTW
5f88			.V2Q: 
5f88				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5f88 7d				db WORD_SYS_CORE+105             
5f89 99 5f			dw .V3S            
5f8b 04				db 3 + 1 
5f8c .. 00			db "V2@",0              
5f90				endm 
# End of macro CWHEAD
5f90			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5f90 2a 67 f9				ld hl, (cli_var_array+4) 
5f93 cd 1b 23				call forth_push_numhl 
5f96				       NEXTW 
5f96 c3 c8 26			jp macro_next 
5f99				endm 
# End of macro NEXTW
5f99			.V3S: 
5f99				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5f99 7c				db WORD_SYS_CORE+104             
5f9a b1 5f			dw .V3Q            
5f9c 04				db 3 + 1 
5f9d .. 00			db "V3!",0              
5fa1				endm 
# End of macro CWHEAD
5fa1			;| V3! ( u1 -- )  Store value to v3 | DONE 
5fa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5fa1 cd 12 25			call macro_dsp_valuehl 
5fa4				endm 
# End of macro FORTH_DSP_VALUEHL
5fa4			 
5fa4 11 69 f9				ld de, cli_var_array+6 
5fa7				 
5fa7 eb					ex de, hl 
5fa8 73					ld (hl), e 
5fa9 23					inc hl 
5faa 72					ld (hl), d 
5fab			 
5fab					; destroy value TOS 
5fab			 
5fab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5fab cd ca 25			call macro_forth_dsp_pop 
5fae				endm 
# End of macro FORTH_DSP_POP
5fae				       NEXTW 
5fae c3 c8 26			jp macro_next 
5fb1				endm 
# End of macro NEXTW
5fb1			.V3Q: 
5fb1				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5fb1 7d				db WORD_SYS_CORE+105             
5fb2 c2 5f			dw .END            
5fb4 04				db 3 + 1 
5fb5 .. 00			db "V3@",0              
5fb9				endm 
# End of macro CWHEAD
5fb9			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5fb9 2a 69 f9				ld hl, (cli_var_array+6) 
5fbc cd 1b 23				call forth_push_numhl 
5fbf				       NEXTW 
5fbf c3 c8 26			jp macro_next 
5fc2				endm 
# End of macro NEXTW
5fc2			 
5fc2			 
5fc2			 
5fc2			 
5fc2			 
5fc2			; end of dict marker 
5fc2			 
5fc2 00			.END:    db WORD_SYS_END 
5fc3 00 00			dw 0 
5fc5 00				db 0 
5fc6			 
5fc6			; use to jp here for user dict words to save on macro expansion  
5fc6			 
5fc6			user_dict_next: 
5fc6				NEXTW 
5fc6 c3 c8 26			jp macro_next 
5fc9				endm 
# End of macro NEXTW
5fc9			 
5fc9			 
5fc9			user_exec: 
5fc9				;    ld hl, <word code> 
5fc9				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5fc9				;    call forthexec 
5fc9				;    jp user_dict_next   (NEXT) 
5fc9			        ;    <word code bytes> 
5fc9 eb				ex de, hl 
5fca 2a fd f3			ld hl,(os_tok_ptr) 
5fcd				 
5fcd				FORTH_RSP_NEXT 
5fcd cd c2 22			call macro_forth_rsp_next 
5fd0				endm 
# End of macro FORTH_RSP_NEXT
5fd0			 
5fd0			if DEBUG_FORTH_UWORD 
5fd0						DMARK "UEX" 
5fd0 f5				push af  
5fd1 3a e5 5f			ld a, (.dmark)  
5fd4 32 a6 fd			ld (debug_mark),a  
5fd7 3a e6 5f			ld a, (.dmark+1)  
5fda 32 a7 fd			ld (debug_mark+1),a  
5fdd 3a e7 5f			ld a, (.dmark+2)  
5fe0 32 a8 fd			ld (debug_mark+2),a  
5fe3 18 03			jr .pastdmark  
5fe5 ..			.dmark: db "UEX"  
5fe8 f1			.pastdmark: pop af  
5fe9			endm  
# End of macro DMARK
5fe9				CALLMONITOR 
5fe9 cd aa fd			call debug_vector  
5fec				endm  
# End of macro CALLMONITOR
5fec			endif 
5fec			 
5fec			 
5fec			 
5fec eb				ex de, hl 
5fed 22 fd f3			ld (os_tok_ptr), hl 
5ff0				 
5ff0				; Don't use next - Skips the first word in uword. 
5ff0			 
5ff0 c3 59 27			jp exec1 
5ff3			;	NEXT 
5ff3			 
5ff3			 
5ff3			; eof 
# End of file forth_wordsv4.asm
5ff3			endif 
5ff3			;;;;;;;;;;;;;; Debug code 
5ff3			 
5ff3			 
5ff3			;if DEBUG_FORTH_PARSE 
5ff3 .. 00		.nowordfound: db "No match",0 
5ffc .. 00		.compword:	db "Comparing word ",0 
600c .. 00		.nextwordat:	db "Next word at",0 
6019 .. 00		.charmatch:	db "Char match",0 
6024			;endif 
6024			if DEBUG_FORTH_JP 
6024			.foundword:	db "Word match. Exec..",0 
6024			endif 
6024			;if DEBUG_FORTH_PUSH 
6024 .. 00		.enddict:	db "Dict end. Push.",0 
6034 .. 00		.push_str:	db "Pushing string",0 
6043 .. 00		.push_num:	db "Pushing number",0 
6052 .. 00		.data_sp:	db "SP:",0 
6056 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
6068 .. 00		.wordinde:	db "Word in DE (3/0):",0 
607a .. 00		.wordinbc:	db "Word in BC (4/0):",0 
608c			;endif 
608c			;if DEBUG_FORTH_MALLOC 
608c .. 00		.push_malloc:	db "Malloc address",0 
609b			;endif 
609b			 
609b			 
609b			 
609b			; display malloc address and current data stack pointer  
609b			 
609b			malloc_error: 
609b d5				push de 
609c f5				push af 
609d e5				push hl 
609e cd 9b 0d			call clear_display 
60a1 11 c1 60			ld de, .mallocerr 
60a4 3e 00			ld a,0 
60a6			;	ld de,os_word_scratch 
60a6 cd ae 0d			call str_at_display 
60a9 3e 11			ld a, display_row_1+17 
60ab 11 a6 fd			ld de, debug_mark 
60ae cd ae 0d			call str_at_display 
60b1 cd be 0d			call update_display 
60b4				;call break_point_state 
60b4 cd 84 7c			call cin_wait 
60b7			 
60b7			;	ld a, ' ' 
60b7			;	ld (os_view_disable), a 
60b7 cd 4d 1c			call bp_on 
60ba e1				pop hl 
60bb f1				pop af 
60bc d1				pop de	 
60bd				CALLMONITOR 
60bd cd aa fd			call debug_vector  
60c0				endm  
# End of macro CALLMONITOR
60c0 c9				ret 
60c1			 
60c1 .. 00		.mallocerr: 	db "Malloc Error",0 
60ce			;if DEBUG_FORTH_PUSH 
60ce			display_data_sp: 
60ce f5				push af 
60cf			 
60cf				; see if disabled 
60cf			 
60cf			 
60cf 3a aa fd			ld a, (debug_vector) 
60d2 fe c9			cp $C9  ; RET 
60d4				;ld a, (os_view_disable) 
60d4				;cp '*' 
60d4 28 67			jr z, .skipdsp 
60d6			 
60d6 e5				push hl 
60d7 e5				push hl 
60d8 e5			push hl 
60d9 cd 9b 0d			call clear_display 
60dc e1			pop hl 
60dd 7c				ld a,h 
60de 21 01 f4			ld hl, os_word_scratch 
60e1 cd e8 14			call hexout 
60e4 e1				pop hl 
60e5 7d				ld a,l 
60e6 21 03 f4			ld hl, os_word_scratch+2 
60e9 cd e8 14			call hexout 
60ec 21 05 f4			ld hl, os_word_scratch+4 
60ef 3e 00			ld a,0 
60f1 77				ld (hl),a 
60f2 11 01 f4			ld de,os_word_scratch 
60f5 3e 28				ld a, display_row_2 
60f7 cd ae 0d				call str_at_display 
60fa 11 56 60			ld de, .wordinhl 
60fd 3e 00			ld a, display_row_1 
60ff			 
60ff cd ae 0d				call str_at_display 
6102 11 a6 fd			ld de, debug_mark 
6105 3e 11			ld a, display_row_1+17 
6107			 
6107 cd ae 0d				call str_at_display 
610a			 
610a				; display current data stack pointer 
610a 11 52 60			ld de,.data_sp 
610d 3e 30				ld a, display_row_2 + 8 
610f cd ae 0d				call str_at_display 
6112			 
6112 2a 29 f9			ld hl,(cli_data_sp) 
6115 e5				push hl 
6116 7c				ld a,h 
6117 21 01 f4			ld hl, os_word_scratch 
611a cd e8 14			call hexout 
611d e1				pop hl 
611e 7d				ld a,l 
611f 21 03 f4			ld hl, os_word_scratch+2 
6122 cd e8 14			call hexout 
6125 21 05 f4			ld hl, os_word_scratch+4 
6128 3e 00			ld a,0 
612a 77				ld (hl),a 
612b 11 01 f4			ld de,os_word_scratch 
612e 3e 33				ld a, display_row_2 + 11 
6130 cd ae 0d				call str_at_display 
6133			 
6133			 
6133 cd be 0d			call update_display 
6136 cd de 0c			call delay1s 
6139 cd de 0c			call delay1s 
613c e1				pop hl 
613d			.skipdsp: 
613d f1				pop af 
613e c9				ret 
613f			 
613f			display_data_malloc: 
613f			 
613f f5				push af 
6140 e5				push hl 
6141 e5				push hl 
6142 e5			push hl 
6143 cd 9b 0d			call clear_display 
6146 e1			pop hl 
6147 7c				ld a,h 
6148 21 01 f4			ld hl, os_word_scratch 
614b cd e8 14			call hexout 
614e e1				pop hl 
614f 7d				ld a,l 
6150 21 03 f4			ld hl, os_word_scratch+2 
6153 cd e8 14			call hexout 
6156 21 05 f4			ld hl, os_word_scratch+4 
6159 3e 00			ld a,0 
615b 77				ld (hl),a 
615c 11 01 f4			ld de,os_word_scratch 
615f 3e 28				ld a, display_row_2 
6161 cd ae 0d				call str_at_display 
6164 11 8c 60			ld de, .push_malloc 
6167 3e 00			ld a, display_row_1 
6169			 
6169 cd ae 0d				call str_at_display 
616c			 
616c				; display current data stack pointer 
616c 11 52 60			ld de,.data_sp 
616f 3e 30				ld a, display_row_2 + 8 
6171 cd ae 0d				call str_at_display 
6174			 
6174 2a 29 f9			ld hl,(cli_data_sp) 
6177 e5				push hl 
6178 7c				ld a,h 
6179 21 01 f4			ld hl, os_word_scratch 
617c cd e8 14			call hexout 
617f e1				pop hl 
6180 7d				ld a,l 
6181 21 03 f4			ld hl, os_word_scratch+2 
6184 cd e8 14			call hexout 
6187 21 05 f4			ld hl, os_word_scratch+4 
618a 3e 00			ld a,0 
618c 77				ld (hl),a 
618d 11 01 f4			ld de,os_word_scratch 
6190 3e 33				ld a, display_row_2 + 11 
6192 cd ae 0d				call str_at_display 
6195			 
6195 cd be 0d			call update_display 
6198 cd de 0c			call delay1s 
619b cd de 0c			call delay1s 
619e e1				pop hl 
619f f1				pop af 
61a0 c9				ret 
61a1			;endif 
61a1			 
61a1			include "forth_autostart.asm" 
61a1			; list of commands to perform at system start up 
61a1			 
61a1			startcmds: 
61a1			;	dw test11 
61a1			;	dw test12 
61a1			;	dw test13 
61a1			;	dw test14 
61a1			;	dw test15 
61a1			;	dw test16 
61a1			;	dw test17 
61a1			;	dw ifthtest1 
61a1			;	dw ifthtest2 
61a1			;	dw ifthtest3 
61a1			;	dw mmtest1 
61a1			;	dw mmtest2 
61a1			;	dw mmtest3 
61a1			;	dw mmtest4 
61a1			;	dw mmtest5 
61a1			;	dw mmtest6 
61a1			;	dw iftest1 
61a1			;	dw iftest2 
61a1			;	dw iftest3 
61a1			;	dw looptest1 
61a1			;	dw looptest2 
61a1			;	dw test1 
61a1			;	dw test2 
61a1			;	dw test3 
61a1			;	dw test4 
61a1			;	dw game2r 
61a1			;	dw game2b1 
61a1			;	dw game2b2 
61a1			 
61a1				; start up words that are actually useful 
61a1			 
61a1			;    dw spi1 
61a1			;    dw spi2 
61a1			;    dw spi3 
61a1			;    dw spi4 
61a1			;    dw spi5 
61a1			;    dw spi6 
61a1			;    dw spi7 
61a1			; 
61a1			;    dw spi8 
61a1			;    dw spi9 
61a1			;    dw spi10 
61a1			 
61a1			; file editor 
61a1			;	dw edit1 
61a1			;	dw edit2 
61a1			;	dw edit3 
61a1			 
61a1			;	dw longread 
61a1 cb 65			dw clrstack 
61a3 ff 65			dw type 
61a5			;	dw stest 
61a5 24 66			dw strncpy 
61a7			;	dw list 
61a7 85 66			dw start1 
61a9 95 66			dw start2 
61ab			;	dw start3 
61ab			;	dw start3b 
61ab			;	dw start3c 
61ab			 
61ab				; (unit) testing words 
61ab			 
61ab			;	dw mtesta 
61ab			;	dw mtestb 
61ab			;	dw mtestc 
61ab			;	dw mtestd 
61ab			;	dw mteste 
61ab			 
61ab				; demo/game words 
61ab			 
61ab			;        dw game3w 
61ab			;        dw game3p 
61ab			;        dw game3sc 
61ab			;        dw game3vsi 
61ab			;        dw game3vs 
61ab				 
61ab ee 70			dw game2b 
61ad 5c 71			dw game2bf 
61af a6 71			dw game2mba 
61b1 3c 72			dw game2mbas 
61b3 7e 72			dw game2mb 
61b5			 
61b5 af 6d			dw game1 
61b7 c0 6d			dw game1a 
61b9 22 6e			dw game1b 
61bb 57 6e			dw game1c 
61bd 8d 6e			dw game1d 
61bf be 6e			dw game1s 
61c1 d2 6e			dw game1t 
61c3 e7 6e			dw game1f 
61c5 1b 6f			dw game1z 
61c7 5f 6f			dw game1zz 
61c9			 
61c9 c9 6b			dw test5 
61cb 01 6c			dw test6 
61cd 39 6c			dw test7 
61cf 4d 6c			dw test8 
61d1 79 6c			dw test9 
61d3 8f 6c			dw test10 
61d5				 
61d5 36 70		        dw ssv5 
61d7 1a 70		        dw ssv4 
61d9 fe 6f		        dw ssv3 
61db c8 6f		        dw ssv2 
61dd 4f 70		        dw ssv1 
61df 97 70		        dw ssv1cpm 
61e1			;	dw keyup 
61e1			;	dw keydown 
61e1			;	dw keyleft 
61e1			;	dw keyright 
61e1			;	dw 	keyf1 
61e1			;	dw keyf2 
61e1			;	dw keyf3 
61e1			;	dw keyf4 
61e1			;	dw keyf5 
61e1			;	dw keyf6 
61e1			;	dw keyf7 
61e1			;	dw keyf8 
61e1			;	dw keyf9 
61e1			;	dw keyf10 
61e1			;	dw keyf11 
61e1			;	dw keyf12 
61e1			;	dw keytab 
61e1			;	dw keycr 
61e1			;	dw keyhome 
61e1			;	dw keyend 
61e1			;	dw keybs 
61e1 00 00			db 0, 0	 
61e3			 
61e3			 
61e3			; File Editor 
61e3			 
61e3			; ( id - ) use 'e' to edit the displayed line 
61e3 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
6204 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6239			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6239 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6271			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6271			 
6271			; SPI Net support words 
6271			 
6271			; v0! = node to send to 
6271			; ( str count - ) 
6271 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
62ca			 
62ca			; spiputc ( char node - ) 
62ca .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
62fe			; spiputc ( u node - ) 
62fe .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
632c			 
632c			; spigetc ( - n ) 
632c .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6355			 
6355			; getnode ( - n ) 
6355 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6382			 
6382			; ( str node - )  
6382 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
63e8			; store string ( str i - ) 
63e8			 
63e8			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
63e8 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
643d			 
643d			; get string ( addr i -  )    TO FIX 
643d			 
643d .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6495			 
6495			 
6495			; NETCHAT (TODO) 
6495			; Program to allow two nodes to chat with eachother 
6495			; 
6495			; v0 - target node 
6495			;  
6495			; accept input at 0,0 
6495			; if input is string send spitype to target node 
6495			; starting at row 2,0 , while spigetchr is not zero ->  
6495			; 
6495			; 
6495			; TODO add paging of get request 
6495			 
6495			; ( node - ) 
6495 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
64b4 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
650c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6584			 
6584			 
6584			; Long read of currently open file 
6584 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
65cb			 
65cb			; clear stack  
65cb			 
65cb .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
65ff			 
65ff			; type ( addr count - ) 
65ff .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6624			 
6624			; some direct memory words 
6624			; strncpy ( len t f -- t ) 
6624			 
6624 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6685			 
6685 .. 00		start1:     	db ": bpon $00 bp ;",0 
6695 .. 00		start2:     	db ": bpoff $01 bp ;",0 
66a6 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6721 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6781			 
6781			 
6781			; a handy word to list items on the stack 
6781			 
6781 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
67eb			 
67eb			 
67eb			; test stack  
67eb			; rnd8 stest 
67eb			 
67eb .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6862			 
6862			; random malloc and free cycles 
6862			 
6862 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6917			 
6917			; fixed malloc and free cycles 
6917			 
6917 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
69ba			 
69ba			; fixed double string push and drop cycle  
69ba			 
69ba .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6a6f			 
6a6f			; consistent fixed string push and drop cycle  
6a6f			 
6a6f .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6b13			 
6b13 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6bc9			 
6bc9			;test1:		db ": aa 1 2 3 ;", 0 
6bc9			;test2:     	db "111 aa 888 999",0 
6bc9			;test3:     	db ": bb 77 ;",0 
6bc9			;test4:     	db "$02 $01 do i . loop bb",0 
6bc9			 
6bc9 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6c01 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6c39 .. 00		test7:     	db ": box hline vline ;",0 
6c4d .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6c79 .. 00		test9:     	db ": sw $01 adsp world ;",0 
6c8f .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6cb4 .. 00		test11:     	db "hello create .",0 
6cc3 .. 00		test12:     	db "hello2 create .",0 
6cd3			 
6cd3			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6cd3			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6cd3			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6cd3			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6cd3			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6cd3			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6cd3			 
6cd3			;iftest1:     	db "$0001 IF cls .",0 
6cd3			;iftest2:     	db "$0000 IF cls .",0 
6cd3			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6cd3			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6cd3			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6cd3			 
6cd3			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6cd3			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6cd3			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6cd3			 
6cd3			 
6cd3 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6cf7 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6d27 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6d4c .. 00		sound4: db ": cha $00 ; ",0 
6d59 .. 00		sound5: db ": chb $20 ; ",0 
6d66 .. 00		sound6: db ": chc $40 ; ",0 
6d73 .. 00		sound7: db ": chd $60 ; ",0 
6d80 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6d98 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6daf			 
6daf			 
6daf			 
6daf			 
6daf			; a small guess the number game 
6daf			 
6daf .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6dc0 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6e22			 
6e22 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6e57 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6e8d .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6ebe .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6ed2 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6ee7 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6f1b .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6f5f			 
6f5f			; Using 'ga' save a high score across multiple runs using external storage 
6f5f			 
6f5f .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6fc8			 
6fc8			 
6fc8			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6fc8			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6fc8			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6fc8			 
6fc8			; simple screen saver to test code memory reuse to destruction 
6fc8			 
6fc8 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6ffe .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
701a .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
7036 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
704f .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
7097 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
70ee			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
70ee			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
70ee			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
70ee			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
70ee			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
70ee			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
70ee			 
70ee			 
70ee			 
70ee			; minesweeper/battleship finding game 
70ee			; draws a game board of random ship/mine positions 
70ee			; user enters coords to see if it hits on 
70ee			; game ends when all are hit 
70ee			; when hit or miss says how many may be in the area 
70ee			 
70ee			; setup the game board and then hide it 
70ee .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
715c .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
71a6			; prompt for where to target 
71a6 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
723c .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
7261			; TODO see if the entered coords hits or misses pushes char hit of miss 
7261 .. 00		game2mbht:      db ": mbckht nop ;",0 
7270 .. 00		game2mbms:      db ": mbcms nop ;",0 
727e			; TODO how many might be near by 
727e .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
72fb			 
72fb			; Game 3 
72fb			 
72fb			; Vert scroller ski game - avoid the trees! 
72fb			 
72fb			; v0 score (ie turns) 
72fb			; v1 player pos 
72fb			; v2 left wall 
72fb			; v3 right wall 
72fb			 
72fb			; Draw side walls randomly 
72fb			 
72fb .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7329			 
7329			; Draw player 
7329 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7347			 
7347			; TODO Get Key 
7347			 
7347			; TODO Move left right 
7347			 
7347			; scroll and move walls a bit 
7347			 
7347 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
7378			 
7378			; main game loop 
7378			 
7378 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
73a4 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
73e3			 
73e3			; key board defs 
73e3			 
73e3 .. 00		keyup:       db ": keyup $05 ;",0 
73f1 .. 00		keydown:       db ": keydown $0a ;",0 
7401 .. 00		keyleft:       db ": keyleft $0b ;",0 
7411 .. 00		keyright:       db ": keyright $0c ;",0 
7422 .. 00		keyf1:       db ": keyf1 $10 ;",0 
7430 .. 00		keyf2:       db ": keyf2 $11 ;",0 
743e .. 00		keyf3:       db ": keyf3 $12 ;",0 
744c .. 00		keyf4:       db ": keyf4 $13 ;",0 
745a .. 00		keyf5:       db ": keyf5 $14 ;",0 
7468 .. 00		keyf6:       db ": keyf6 $15 ;",0 
7476 .. 00		keyf7:       db ": keyf7 $16 ;",0 
7484 .. 00		keyf8:       db ": keyf8 $17 ;",0 
7492 .. 00		keyf9:       db ": keyf9 $18 ;",0 
74a0 .. 00		keyf10:       db ": keyf10 $19 ;",0 
74af .. 00		keyf11:       db ": keyf11 $1a ;",0 
74be .. 00		keyf12:       db ": keyf12 $1b ;",0 
74cd			 
74cd .. 00		keytab:       db ": keytab $09 ;",0 
74dc .. 00		keycr:       db ": keycr $0d ;",0 
74ea .. 00		keyhome:       db ": keyhome $0e ;",0 
74fa .. 00		keyend:       db ": keyend $0f ;",0 
7509 .. 00		keybs:       db ": keybs $08 ;",0 
7517			 
7517			   
7517			 
7517			 
7517			 
7517			; eof 
# End of file forth_autostart.asm
7517			 
7517			 
7517			 
7517			; stack over and underflow checks 
7517			 
7517			; init the words to detect the under/overflow 
7517			 
7517			chk_stk_init: 
7517				; a vague random number to check so we dont get any "lucky" hits 
7517 3e 2d			ld a, 45 
7519 6f				ld l, a 
751a 00				nop 
751b 3e 17			ld a, 23 
751d 67				ld h, a 
751e			 
751e 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
7521			 
7521			;	ld (chk_stund), hl	; stack points.... 
7521 22 3b fe			ld (chk_stovr), hl 
7524 22 27 f9			ld (chk_ret_und), hl 
7527 22 e5 f8			ld (chk_ret_ovr), hl 
752a 22 63 f8			ld (chk_loop_ovr), hl 
752d 22 61 f6			ld (chk_data_ovr), hl 
7530 c9				ret 
7531				 
7531			check_stacks: 
7531				; check all stack words 
7531			 
7531 e5				push hl 
7532 d5				push de 
7533			 
7533			;	ld de,(chk_word) 
7533			;	ld hl, (chk_stund)	; stack points.... 
7533			;	if DEBUG_STK_FAULT 
7533			;		DMARK "FAa" 
7533			;		CALLMONITOR 
7533			;	endif 
7533			;	call cmp16 
7533			;	jp z, .chk_faulta 
7533			; 
7533			;	ld de, sfaultsu 
7533			;	jp .chk_fault 
7533			 
7533 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
7536 ed 5b d8 f0		ld de,(chk_word) 
753a				if DEBUG_STK_FAULT 
753a					DMARK "FAb" 
753a					CALLMONITOR 
753a				endif 
753a cd ed 0f			call cmp16 
753d 28 06			jr z, .chk_fault1 
753f 11 e0 75			ld de, sfaultso 
7542 c3 94 75			jp .chk_fault 
7545			.chk_fault1:  
7545 2a 27 f9			ld hl, (chk_ret_und) 
7548 ed 5b d8 f0		ld de,(chk_word) 
754c				if DEBUG_STK_FAULT 
754c					DMARK "FAU" 
754c					CALLMONITOR 
754c				endif 
754c cd ed 0f			call cmp16 
754f ca 58 75			jp z, .chk_fault2 
7552 11 f0 75			ld de, sfaultru 
7555 c3 94 75			jp .chk_fault 
7558			.chk_fault2:  
7558 2a e5 f8			ld hl, (chk_ret_ovr) 
755b ed 5b d8 f0		ld de,(chk_word) 
755f				if DEBUG_STK_FAULT 
755f					DMARK "FA1" 
755f					CALLMONITOR 
755f				endif 
755f cd ed 0f			call cmp16 
7562 ca 6b 75			jp z, .chk_fault3 
7565 11 fe 75			ld de, sfaultro 
7568 c3 94 75			jp .chk_fault 
756b			.chk_fault3:  
756b 2a 63 f8			ld hl, (chk_loop_ovr) 
756e ed 5b d8 f0		ld de,(chk_word) 
7572				if DEBUG_STK_FAULT 
7572					DMARK "FA2" 
7572					CALLMONITOR 
7572				endif 
7572 cd ed 0f			call cmp16 
7575 ca 7e 75			jp z, .chk_fault4 
7578 11 18 76			ld de, sfaultlo 
757b c3 94 75			jp .chk_fault 
757e			.chk_fault4:  
757e 2a 61 f6			ld hl, (chk_data_ovr) 
7581 ed 5b d8 f0		ld de,(chk_word) 
7585				if DEBUG_STK_FAULT 
7585					DMARK "FA3" 
7585					CALLMONITOR 
7585				endif 
7585 cd ed 0f			call cmp16 
7588 ca 91 75			jp z, .chk_fault5 
758b 11 32 76			ld de, sfaultdo 
758e c3 94 75			jp .chk_fault 
7591			 
7591			 
7591			.chk_fault5:  
7591 d1				pop de 
7592 e1				pop hl 
7593			 
7593 c9				ret 
7594			 
7594 cd 9b 0d		.chk_fault: 	call clear_display 
7597 3e 28				ld a, display_row_2 
7599 cd ae 0d				call str_at_display 
759c 11 c2 75				   ld de, .stackfault 
759f 3e 00				ld a, display_row_1 
75a1 cd ae 0d				call str_at_display 
75a4 11 a6 fd				    ld de, debug_mark 
75a7 3e 11				ld a, display_row_1+17 
75a9 cd ae 0d				call str_at_display 
75ac cd be 0d				call update_display 
75af			 
75af				; prompt before entering montior for investigating issue 
75af			 
75af 3e 78			ld a, display_row_4 
75b1 11 0d 20			ld de, endprog 
75b4			 
75b4 cd be 0d			call update_display		 
75b7			 
75b7 cd 93 22			call next_page_prompt 
75ba			 
75ba d1				pop de 
75bb e1				pop hl 
75bc cd 61 20				call monitor 
75bf c3 6a 1f				jp warmstart 
75c2					;jp 0 
75c2					;halt 
75c2			 
75c2			 
75c2			 
75c2 .. 00		.stackfault: 	db "Stack fault:",0 
75cf			 
75cf .. 00		sfaultsu: 	db	"Stack under flow",0 
75e0 .. 00		sfaultso: 	db	"Stack over flow",0 
75f0 .. 00		sfaultru:	db "RTS underflow",0 
75fe .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7618 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7632 .. 00		sfaultdo:	db "DTS overflow", 0 
763f			 
763f			 
763f			fault_dsp_under: 
763f 11 51 76			ld de, .dsp_under 
7642 c3 01 77			jp .show_fault 
7645			 
7645			fault_rsp_under: 
7645 11 5f 76			ld de, .rsp_under 
7648 c3 01 77			jp .show_fault 
764b			fault_loop_under: 
764b 11 6d 76			ld de, .loop_under 
764e c3 01 77			jp .show_fault 
7651			 
7651 .. 00		.dsp_under: db "DSP Underflow",0 
765f .. 00		.rsp_under: db "RSP Underflow",0 
766d .. 00		.loop_under: db "LOOP Underflow",0 
767c			 
767c			 
767c d5			type_faultn: 	push de 
767d e5					push hl 
767e cd 9b 0d				call clear_display 
7681 11 a8 76				   ld de, .typefaultn 
7684 3e 00				ld a, display_row_1 
7686 cd ae 0d				call str_at_display 
7689 11 a6 fd				    ld de, debug_mark 
768c 3e 11				ld a, display_row_1+17 
768e cd ae 0d				call str_at_display 
7691 cd be 0d				call update_display 
7694			 
7694				; prompt before entering montior for investigating issue 
7694			 
7694 3e 78			ld a, display_row_4 
7696 11 0d 20			ld de, endprog 
7699			 
7699 cd be 0d			call update_display		 
769c			 
769c cd 93 22			call next_page_prompt 
769f			 
769f e5					push hl 
76a0 d5					push de 
76a1 cd 61 20				call monitor 
76a4 c3 6a 1f				jp warmstart 
76a7 76					halt 
76a8			 
76a8			 
76a8 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
76bf			 
76bf d5			type_faults: 	push de 
76c0 e5					push hl 
76c1 cd 9b 0d				call clear_display 
76c4 11 ea 76				   ld de, .typefaults 
76c7 3e 00				ld a, display_row_1 
76c9 cd ae 0d				call str_at_display 
76cc 11 a6 fd				    ld de, debug_mark 
76cf 3e 11				ld a, display_row_1+17 
76d1 cd ae 0d				call str_at_display 
76d4 cd be 0d				call update_display 
76d7			 
76d7				; prompt before entering montior for investigating issue 
76d7			 
76d7 3e 78			ld a, display_row_4 
76d9 11 0d 20			ld de, endprog 
76dc			 
76dc cd be 0d			call update_display		 
76df			 
76df cd 93 22			call next_page_prompt 
76e2			 
76e2 e1					pop hl 
76e3 d1					pop de 
76e4 cd 61 20				call monitor 
76e7 c3 6a 1f				jp warmstart 
76ea			 
76ea			 
76ea .. 00		.typefaults: db "STR Type Expected TOS!",0 
7701			 
7701			.show_fault: 	 
7701 d5					push de 
7702 cd 9b 0d				call clear_display 
7705 d1					pop de 
7706 3e 00				ld a, display_row_1 
7708 cd ae 0d				call str_at_display 
770b 11 a6 fd				    ld de, debug_mark 
770e 3e 11				ld a, display_row_1+17 
7710 cd ae 0d				call str_at_display 
7713 cd be 0d				call update_display 
7716			 
7716				; prompt before entering montior for investigating issue 
7716			 
7716 3e 78			ld a, display_row_4 
7718 11 0d 20			ld de, endprog 
771b			 
771b cd be 0d			call update_display		 
771e			 
771e cd 93 22			call next_page_prompt 
7721			 
7721 e1					pop hl 
7722 d1					pop de 
7723 cd 61 20				call monitor 
7726			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7726			; TODO Make optional fault restart to cli or warm boot? 
7726					;jp warmstart 
7726 c3 b4 1f				jp cli 
7729 76					halt 
772a			 
772a			; handle the auto run of code from files in storage 
772a			 
772a			 
772a			include "forth_startup.asm" 
772a			; Which startup method to use? 
772a			; 
772a			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
772a			; followed by loading of a list of scripts in eeprom 
772a			 
772a			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
772a			; from eeprom 
772a			 
772a			; Select with define in main stubs 
772a			 
772a			if STARTUP_V1 
772a				include "forth_startupv1.asm" 
772a			endif 
772a			if STARTUP_V2 
772a				include "forth_startupv2.asm" 
772a			; Version 2 of the startup  
772a			;  
772a			; Auto load any files in bank 1 that start with a '*' 
772a			; If no se storage then revert to using eprom 
772a			 
772a			 
772a			if STORAGE_SE = 0 
772a			 
772a			sprompt1: db "Startup load...",0 
772a			sprompt2: db "Run? 1=No *=End #=All",0 
772a			 
772a			 
772a			 
772a			 
772a			forth_startup: 
772a				ld hl, startcmds 
772a				ld a, 0 
772a				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
772a			 
772a			.start1:	push hl 
772a				call clear_display 
772a				ld de, sprompt1 
772a			        ld a, display_row_1 
772a				call str_at_display 
772a				ld de, sprompt2 
772a			        ld a, display_row_2 
772a				call str_at_display 
772a				pop hl 
772a				push hl 
772a				ld e,(hl) 
772a				inc hl 
772a				ld d,(hl) 
772a			        ld a, display_row_3 
772a				call str_at_display 
772a				call update_display 
772a			 
772a			 
772a				ld a, (os_last_cmd) 
772a				cp 0 
772a				jr z, .startprompt 
772a				call delay250ms 
772a				jr .startdo 
772a				 
772a				 
772a			 
772a			.startprompt: 
772a			 
772a				ld a,display_row_4 + display_cols - 1 
772a			        ld de, endprg 
772a				call str_at_display 
772a				call update_display 
772a				call delay1s 
772a				call cin_wait 
772a						 
772a				cp '*' 
772a				jr z, .startupend1 
772a				cp '#' 
772a				jr nz, .startno 
772a				ld a, 1 
772a				ld (os_last_cmd),a 
772a				jr .startdo 
772a			.startno:	cp '1' 
772a				jr z,.startnxt  
772a			 
772a				; exec startup line 
772a			.startdo:	 
772a				pop hl 
772a				push hl 
772a				 
772a				ld e,(hl) 
772a				inc hl 
772a				ld d,(hl) 
772a				ex de,hl 
772a			 
772a				push hl 
772a			 
772a				ld a, 0 
772a				;ld a, FORTH_END_BUFFER 
772a				call strlent 
772a				inc hl   ; include zero term to copy 
772a				ld b,0 
772a				ld c,l 
772a				pop hl 
772a				ld de, scratch 
772a				ldir 
772a			 
772a			 
772a				ld hl, scratch 
772a				call forthparse 
772a				call forthexec 
772a				call forthexec_cleanup 
772a			 
772a				ld a, display_row_4 
772a				ld de, endprog 
772a			 
772a				call update_display		 
772a			 
772a				ld a, (os_last_cmd) 
772a				cp 0 
772a				jr nz, .startnxt 
772a				call next_page_prompt 
772a			        call clear_display 
772a				call update_display		 
772a			 
772a				; move onto next startup line? 
772a			.startnxt: 
772a			 
772a				call delay250ms 
772a				pop hl 
772a			 
772a				inc hl 
772a				inc hl 
772a			 
772a				push hl 
772a				ld e, (hl) 
772a				inc hl 
772a				ld d, (hl) 
772a				pop hl 
772a				; TODO replace 0 test 
772a			 
772a				ex de, hl 
772a				call ishlzero 
772a			;	ld a,e 
772a			;	add d 
772a			;	cp 0    ; any left to do? 
772a				ex de, hl 
772a				jp nz, .start1 
772a				jr .startupend 
772a			 
772a			.startupend1: pop hl 
772a			.startupend: 
772a			 
772a				call clear_display 
772a				call update_display 
772a				ret 
772a			endif 
772a			 
772a			 
772a			if STORAGE_SE 
772a			 
772a			;sprompt3: db "Loading from start-up file:",0 
772a .. 00		sprompt3: db "  Searching...",0 
7739			;sprompt4: db "(Any key to stop)",0 
7739			 
7739			 
7739			forth_autoload: 
7739			 
7739				; load block 0 of store 1 
7739				 
7739 3e fe			ld a, $fe      ; bit 0 clear 
773b 32 9b f9			ld (spi_device), a 
773e			 
773e cd 16 05			call storage_get_block_0 
7741			 
7741 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
7744			 
7744 fe 00			cp 0 
7746 c8				ret z     ; auto start not enabled 
7747			 
7747 cd 9b 0d			call clear_display 
774a			 
774a				; set bank 
774a			 
774a 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
774d 32 9b f9				ld (spi_device), a 
7750			 
7750			 
7750				; generate a directory of bank 1 and search for flagged files 
7750			 
7750					if DEBUG_FORTH_WORDS_KEY 
7750						DMARK "DIR" 
7750 f5				push af  
7751 3a 65 77			ld a, (.dmark)  
7754 32 a6 fd			ld (debug_mark),a  
7757 3a 66 77			ld a, (.dmark+1)  
775a 32 a7 fd			ld (debug_mark+1),a  
775d 3a 67 77			ld a, (.dmark+2)  
7760 32 a8 fd			ld (debug_mark+2),a  
7763 18 03			jr .pastdmark  
7765 ..			.dmark: db "DIR"  
7768 f1			.pastdmark: pop af  
7769			endm  
# End of macro DMARK
7769						CALLMONITOR 
7769 cd aa fd			call debug_vector  
776c				endm  
# End of macro CALLMONITOR
776c					endif 
776c			 
776c cd 16 05			call storage_get_block_0 
776f			 
776f 21 b5 f9			ld hl, store_page     ; get current id count 
7772 46				ld b, (hl) 
7773 0e 00			ld c, 0    ; count of files   
7775					if DEBUG_FORTH_WORDS 
7775						DMARK "DI1" 
7775 f5				push af  
7776 3a 8a 77			ld a, (.dmark)  
7779 32 a6 fd			ld (debug_mark),a  
777c 3a 8b 77			ld a, (.dmark+1)  
777f 32 a7 fd			ld (debug_mark+1),a  
7782 3a 8c 77			ld a, (.dmark+2)  
7785 32 a8 fd			ld (debug_mark+2),a  
7788 18 03			jr .pastdmark  
778a ..			.dmark: db "DI1"  
778d f1			.pastdmark: pop af  
778e			endm  
# End of macro DMARK
778e						CALLMONITOR 
778e cd aa fd			call debug_vector  
7791				endm  
# End of macro CALLMONITOR
7791					endif 
7791			 
7791				; check for empty drive 
7791			 
7791 3e 00			ld a, 0 
7793 b8				cp b 
7794 ca e1 77			jp z, .dirdone 
7797			 
7797				; for each of the current ids do a search for them and if found push to stack 
7797			 
7797 c5			.diritem:	push bc 
7798 21 40 00				ld hl, STORE_BLOCK_PHY 
779b 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
779d 58					ld e,b 
779e			 
779e d5					push de 
779f e5					push hl 
77a0 cd 9b 0d			call clear_display 
77a3 3e 32			ld a, display_row_2 + 10 
77a5 11 2a 77			ld de, sprompt3 
77a8 cd ae 0d			call str_at_display 
77ab cd f2 0c			call active 
77ae eb				ex de, hl 
77af 3e 2f			ld a, display_row_2 + 7 
77b1 cd ae 0d			call str_at_display 
77b4 cd be 0d			call update_display 
77b7 e1				pop hl 
77b8 d1				pop de 
77b9			 
77b9			;		if DEBUG_FORTH_WORDS 
77b9			;			DMARK "DI2" 
77b9			;			CALLMONITOR 
77b9			;		endif 
77b9			 
77b9 cd 98 07				call storage_findnextid 
77bc			 
77bc			;		if DEBUG_FORTH_WORDS 
77bc			;			DMARK "DI3" 
77bc			;			CALLMONITOR 
77bc			;		endif 
77bc			 
77bc					; if found hl will be non zero 
77bc			 
77bc cd f8 0f				call ishlzero 
77bf			;		ld a, l 
77bf			;		add h 
77bf			; 
77bf			;		cp 0 
77bf 28 1d				jr z, .dirnotfound 
77c1			 
77c1					; increase count 
77c1			 
77c1 c1					pop bc	 
77c2 0c					inc c 
77c3 c5					push bc 
77c4					 
77c4			 
77c4					; get file header and push the file name 
77c4			 
77c4 11 b5 f9				ld de, store_page 
77c7 cd 65 04				call storage_read_block 
77ca			 
77ca					; push file id to stack 
77ca				 
77ca			 
77ca					; is this a file we want to run? 
77ca			 
77ca 21 b8 f9				ld hl, store_page+3 
77cd 7e					ld a,(hl) 
77ce fe 2a				cp '*' 
77d0 20 0c				jr nz,  .dirnotfound 
77d2					 
77d2			 
77d2			 
77d2 3a b5 f9				ld a, (store_page) 
77d5 d5					push de 
77d6 e5					push hl 
77d7 c5					push bc 
77d8 cd 04 78				call .autorunf 
77db c1					pop bc 
77dc e1					pop hl 
77dd d1					pop de 
77de			 
77de			 
77de			 
77de				; save this extent 
77de			 
77de					; push file name 
77de			;display file name to run 
77de			 
77de			;		ld hl, store_page+3 
77de			;		if DEBUG_FORTH_WORDS 
77de			;			DMARK "DI5" 
77de			;			CALLMONITOR 
77de			;		endif 
77de			; 
77de			;		 
77de			; 
77de			;		call forth_push_str 
77de			;		if DEBUG_FORTH_WORDS 
77de			;			DMARK "DI6" 
77de			;			CALLMONITOR 
77de			;		endif 
77de			.dirnotfound: 
77de c1					pop bc     
77df 10 b6				djnz .diritem 
77e1				 
77e1			.dirdone:	 
77e1					if DEBUG_FORTH_WORDS 
77e1						DMARK "DI7" 
77e1 f5				push af  
77e2 3a f6 77			ld a, (.dmark)  
77e5 32 a6 fd			ld (debug_mark),a  
77e8 3a f7 77			ld a, (.dmark+1)  
77eb 32 a7 fd			ld (debug_mark+1),a  
77ee 3a f8 77			ld a, (.dmark+2)  
77f1 32 a8 fd			ld (debug_mark+2),a  
77f4 18 03			jr .pastdmark  
77f6 ..			.dmark: db "DI7"  
77f9 f1			.pastdmark: pop af  
77fa			endm  
# End of macro DMARK
77fa						CALLMONITOR 
77fa cd aa fd			call debug_vector  
77fd				endm  
# End of macro CALLMONITOR
77fd					endif 
77fd			 
77fd cd 9b 0d				call clear_display 
7800 cd be 0d				call update_display 
7803			 
7803 c9					ret 
7804			 
7804			 
7804			 
7804			 
7804			 
7804			.autorunf: 
7804			 
7804			 
7804				; get file id to load from and get the file name to display 
7804			 
7804			;		ld a, (store_page+STORE_0_FILERUN) 
7804			 
7804 2e 00				ld l, 0 
7806 67					ld h, a 
7807 11 b5 f9				ld de, store_page 
780a			 
780a					if DEBUG_FORTH_WORDS 
780a						DMARK "ASp" 
780a f5				push af  
780b 3a 1f 78			ld a, (.dmark)  
780e 32 a6 fd			ld (debug_mark),a  
7811 3a 20 78			ld a, (.dmark+1)  
7814 32 a7 fd			ld (debug_mark+1),a  
7817 3a 21 78			ld a, (.dmark+2)  
781a 32 a8 fd			ld (debug_mark+2),a  
781d 18 03			jr .pastdmark  
781f ..			.dmark: db "ASp"  
7822 f1			.pastdmark: pop af  
7823			endm  
# End of macro DMARK
7823						CALLMONITOR 
7823 cd aa fd			call debug_vector  
7826				endm  
# End of macro CALLMONITOR
7826					endif 
7826 cd be 09				call storage_read 
7829			 
7829					if DEBUG_FORTH_WORDS 
7829						DMARK "ASr" 
7829 f5				push af  
782a 3a 3e 78			ld a, (.dmark)  
782d 32 a6 fd			ld (debug_mark),a  
7830 3a 3f 78			ld a, (.dmark+1)  
7833 32 a7 fd			ld (debug_mark+1),a  
7836 3a 40 78			ld a, (.dmark+2)  
7839 32 a8 fd			ld (debug_mark+2),a  
783c 18 03			jr .pastdmark  
783e ..			.dmark: db "ASr"  
7841 f1			.pastdmark: pop af  
7842			endm  
# End of macro DMARK
7842						CALLMONITOR 
7842 cd aa fd			call debug_vector  
7845				endm  
# End of macro CALLMONITOR
7845					endif 
7845			 
7845 cd f8 0f				call ishlzero 
7848 c8					ret z             ; file not found 
7849			 
7849					; display file name we are loading 
7849			 
7849 cd 9b 0d				call clear_display 
784c			 
784c 3e 32				ld a, display_row_2 + 10 
784e 11 b8 f9				ld de, store_page+3 
7851 cd ae 0d				call str_at_display 
7854				 
7854			; 
7854			 
7854			;	ld a, display_row_1+5 
7854			;	ld de, sprompt3 
7854			;	call str_at_display 
7854			;	ld a, display_row_2+7 
7854			;	call active 
7854			;	ex de, hl 
7854			;;	ld de, sprompt4 
7854			;	call str_at_display 
7854			; 
7854 cd be 0d			call update_display 
7857			 
7857			;	call cin_wait 
7857			;	cp 'n' 
7857			;	ret z 
7857			;	cp 'N' 
7857			;	ret z 
7857			 
7857			;	call delay1s 
7857			 
7857 3a b7 f9			ld a, (store_page+2) 
785a 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
785d 3e 01			ld a, 1  
785f 32 a5 f9			ld (store_openext), a    ; save count of ext 
7862			 
7862			.autof: 
7862				; begin to read a line from file 
7862			 
7862 21 23 f4			ld hl, os_cli_cmd 
7865 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7868			  
7868			.readext: 
7868 3a a5 f9			ld a, (store_openext) 
786b 6f				ld l , a 
786c				 
786c 3a b5 f9			ld a, (store_page) 
786f 67				ld h, a	 
7870 11 b5 f9			ld de, store_page 
7873					if DEBUG_FORTH_WORDS 
7873						DMARK "ASl" 
7873 f5				push af  
7874 3a 88 78			ld a, (.dmark)  
7877 32 a6 fd			ld (debug_mark),a  
787a 3a 89 78			ld a, (.dmark+1)  
787d 32 a7 fd			ld (debug_mark+1),a  
7880 3a 8a 78			ld a, (.dmark+2)  
7883 32 a8 fd			ld (debug_mark+2),a  
7886 18 03			jr .pastdmark  
7888 ..			.dmark: db "ASl"  
788b f1			.pastdmark: pop af  
788c			endm  
# End of macro DMARK
788c						CALLMONITOR 
788c cd aa fd			call debug_vector  
788f				endm  
# End of macro CALLMONITOR
788f					endif 
788f cd be 09				call storage_read 
7892 cd f8 0f			call ishlzero 
7895 c8				ret z 
7896			 
7896			; TODO copy to exec buffer 
7896			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7896			 
7896				; copy the record buffer to the cli buffer 
7896			 
7896 ed 5b 21 f6		ld de, (os_var_array) 
789a 21 b7 f9			ld hl, store_page+2 
789d			;	ex de, hl 
789d 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
78a0 ed b0			ldir 
78a2 ed 53 21 f6		ld (os_var_array), de 
78a6				 
78a6 3a a5 f9			ld a, (store_openext) 
78a9 3c				inc a 
78aa 32 a5 f9			ld (store_openext), a    ; save count of ext 
78ad			 
78ad			 
78ad			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
78ad				 
78ad 3a a8 f9			ld a, (store_readcont) 
78b0 fe 00			cp 0 
78b2 20 b4			jr nz, .readext 
78b4			 
78b4			;	jr z, .autoend 
78b4			 
78b4					if DEBUG_FORTH_WORDS 
78b4						DMARK "ASc" 
78b4 f5				push af  
78b5 3a c9 78			ld a, (.dmark)  
78b8 32 a6 fd			ld (debug_mark),a  
78bb 3a ca 78			ld a, (.dmark+1)  
78be 32 a7 fd			ld (debug_mark+1),a  
78c1 3a cb 78			ld a, (.dmark+2)  
78c4 32 a8 fd			ld (debug_mark+2),a  
78c7 18 03			jr .pastdmark  
78c9 ..			.dmark: db "ASc"  
78cc f1			.pastdmark: pop af  
78cd			endm  
# End of macro DMARK
78cd						CALLMONITOR 
78cd cd aa fd			call debug_vector  
78d0				endm  
# End of macro CALLMONITOR
78d0					endif 
78d0 e5				push hl	 
78d1 d5				push de 
78d2 cd f2 0c			call active 
78d5 eb				ex de, hl 
78d6 3e 2f			ld a, display_row_2 + 7 
78d8 cd ae 0d			call str_at_display 
78db			 
78db cd be 0d			call update_display 
78de d1				pop de  
78df e1				pop hl 
78e0			;	call delay250ms 
78e0			 
78e0			 
78e0			 
78e0			 
78e0			.autoexec: 
78e0			 
78e0			 
78e0 21 23 f4			ld hl, os_cli_cmd 
78e3					if DEBUG_FORTH_WORDS 
78e3						DMARK "ASx" 
78e3 f5				push af  
78e4 3a f8 78			ld a, (.dmark)  
78e7 32 a6 fd			ld (debug_mark),a  
78ea 3a f9 78			ld a, (.dmark+1)  
78ed 32 a7 fd			ld (debug_mark+1),a  
78f0 3a fa 78			ld a, (.dmark+2)  
78f3 32 a8 fd			ld (debug_mark+2),a  
78f6 18 03			jr .pastdmark  
78f8 ..			.dmark: db "ASx"  
78fb f1			.pastdmark: pop af  
78fc			endm  
# End of macro DMARK
78fc						CALLMONITOR 
78fc cd aa fd			call debug_vector  
78ff				endm  
# End of macro CALLMONITOR
78ff					endif 
78ff cd 16 27			call forthparse 
7902 cd 56 27			call forthexec 
7905 cd 68 26			call forthexec_cleanup 
7908			 
7908			 
7908			 
7908 c3 62 78			jp .autof 
790b			;.autofdone: 
790b			; 
790b			;		if DEBUG_FORTH_WORDS 
790b			;			DMARK "ASx" 
790b			;			CALLMONITOR 
790b			;		endif 
790b			;;	call clear_display 
790b			;	ret 
790b			 
790b			 
790b			 
790b			endif 
# End of file forth_startupv2.asm
790b			endif 
790b			 
# End of file forth_startup.asm
790b			 
790b			; eof 
# End of file forth_kernel.asm
790b			;include "nascombasic.asm" 
790b			 
790b			 
790b			; find out where the code ends if loaded into RAM (for SC114) 
790b			;endofcode:  
790b			;	nop 
790b			 
790b			 
790b			; jump to nmi vector 
790b			 
790b			init_nmi: 
790b 3e c9			ld a, $c9   ; RET 
790d 32 ad fd			ld (nmi_vector), a 
7910 c9				ret 
7911			nmi: 
7911 e5				push hl 
7912 d5				push de 
7913 c5				push bc 
7914 f5				push af 
7915 cd ad fd			call nmi_vector 
7918 f5				push af 
7919 c5				push bc 
791a d5				push de 
791b e5				push hl 
791c ed 4d			reti 
791e			 
791e			 
791e			; eof 
791e			 
# End of file main.asm
791e			include "firmware_lcd_4x40.asm" 
791e			; **********************************************************************  
791e			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
791e			; **********************************************************************  
791e			;  
791e			; **  Written as a Small Computer Monitor App  
791e			; **  www.scc.me.uk  
791e			;  
791e			; History  
791e			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
791e			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
791e			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
791e			;  
791e			; **********************************************************************  
791e			;  
791e			; This program is an example of one of the methods of interfacing an   
791e			; alphanumeric LCD module.   
791e			;  
791e			; In this example the display is connected to either a Z80 PIO or a   
791e			; simple 8-bit output port.   
791e			;  
791e			; This interfacing method uses 4-bit data mode and uses time delays  
791e			; rather than polling the display's ready status. As a result the   
791e			; interface only requires 6 simple output lines:  
791e			;   Output bit 0 = not used  
791e			;   Output bit 1 = not used  
791e			;   Output bit 2 = RS         High = data, Low = instruction  
791e			;   Output bit 3 = E          Active high  
791e			;   Output bit 4 = DB4  
791e			;   Output bit 5 = DB5  
791e			;   Output bit 6 = DB6  
791e			;   Output bit 7 = DB7  
791e			; Display's R/W is connected to 0v so it is always in write mode  
791e			;  
791e			; This set up should work with any system supporting the RC2014 bus  
791e			  
791e			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
791e			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
791e			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
791e			;  
791e			; **********************************************************************  
791e			  
791e			; Additonal for 4x40. E1 and E2 instead of just E   
791e			; TODO swipe vidout signal on port a to activate E2  
791e			  
791e			; **********************************************************************  
791e			; **  Constants  
791e			; **********************************************************************  
791e			; LCD constants required by LCD support module  
791e			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
791e			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
791e			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
791e			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
791e			; TODO Decide which E is being set  
791e			kLCDWidth:  EQU display_cols             ;Width in characters  
791e			  
791e			; **********************************************************************  
791e			; **  Code library usage  
791e			; **********************************************************************  
791e			  
791e			; send character to current cursor position  
791e			; wraps and/or scrolls screen automatically  
791e			  
791e			  
791e			  
791e			lcd_init:  
791e			  
791e			; SCMonAPI functions used  
791e			  
791e			; Alphanumeric LCD functions used  
791e			; no need to specify specific functions for this module  
791e			  
791e 3e cf		            LD   A, 11001111b  
7920 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7922 3e 00		            LD   A, 00000000b  
7924 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7926			  
7926			; Initialise alphanumeric LCD module  
7926 3e 00				ld a, 0  
7928 32 06 fb				ld (display_lcde1e2), a  
792b cd ac 79		            CALL fLCD_Init      ;Initialise LCD module  
792e 3e 01				ld a, 1  
7930 32 06 fb				ld (display_lcde1e2), a  
7933 cd ac 79		            CALL fLCD_Init      ;Initialise LCD module  
7936			  
7936 c9				ret  
7937			  
7937			;  
7937			;;  
7937			; lcd functions  
7937			;  
7937			;  
7937			  
7937			; what is at cursor position   
7937			  
7937			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7937			;		call curptr  
7937			;		ret  
7937			  
7937			  
7937			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7937			  
7937			curptr:  
7937 c5				push bc  
7938 21 ec fc			ld hl, display_fb0  
793b			cpr:	  
793b				; loop for cursor whole row  
793b 0e 28			ld c, display_cols  
793d 23			cpr1:	inc hl  
793e 0d				dec c  
793f 20 fc			jr nz, cpr1  
7941 05				dec b  
7942 20 f7			jr nz, cpr  
7944			  
7944				; add col	  
7944			  
7944 23			cpr2:	inc hl  
7945 1d				dec e  
7946 20 fc			jr nz, cpr2  
7948			  
7948 c1				pop bc  
7949 c9				ret  
794a				  
794a			  
794a			  
794a			  
794a			  
794a			; write the frame buffer given in hl to hardware   
794a 22 04 fb		write_display: ld (display_write_tmp), hl 	   
794d 3e 00			ld a, kLCD_Line1  
794f cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7952 06 28			ld b, display_cols  
7954 ed 5b 04 fb		ld de, (display_write_tmp)  
7958 cd a4 79			call write_len_string  
795b				  
795b				  
795b 2a 04 fb			ld hl, (display_write_tmp)  
795e 11 28 00			ld de, display_cols  
7961 19				add hl,de  
7962 22 04 fb			ld (display_write_tmp),hl  
7965			  
7965				  
7965 3e 28			ld a, kLCD_Line2  
7967 cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
796a 06 28			ld b, display_cols  
796c ed 5b 04 fb		ld de, (display_write_tmp)  
7970 cd a4 79			call write_len_string  
7973				  
7973 2a 04 fb			ld hl, (display_write_tmp)  
7976 11 28 00			ld de, display_cols  
7979 19				add hl,de  
797a 22 04 fb			ld (display_write_tmp),hl  
797d			  
797d				  
797d 3e 50			ld a, kLCD_Line3  
797f cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7982 06 28			ld b, display_cols  
7984 ed 5b 04 fb		ld de, (display_write_tmp)  
7988 cd a4 79			call write_len_string  
798b				  
798b 2a 04 fb			ld hl, (display_write_tmp)  
798e 11 28 00			ld de, display_cols  
7991 19				add hl,de  
7992 22 04 fb			ld (display_write_tmp),hl  
7995			  
7995				  
7995 3e 78			ld a, kLCD_Line4  
7997 cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
799a 06 28			ld b, display_cols  
799c ed 5b 04 fb		ld de, (display_write_tmp)  
79a0 cd a4 79			call write_len_string  
79a3 c9					ret  
79a4				  
79a4				; write out a fixed length string given in b from de  
79a4			  
79a4 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
79a5 cd 11 7a		            CALL fLCD_Data      ;Write character to display  
79a8 13				inc de  
79a9 10 f9			djnz write_len_string  
79ab c9				ret  
79ac			  
79ac			; Some other things to do  
79ac			;            LD   A, kLCD_Clear ;Display clear  
79ac			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
79ac			;            LD   A, kLCD_Under ;Display on with underscore cursor  
79ac			;            LD   A, kLCD_On     ;Display on with no cursor  
79ac			;            ;LD   A, kLCD_Off   ;Display off  
79ac			;            CALL fLCD_Inst      ;Send instruction to display  
79ac			;  
79ac			;  
79ac			;            halt  
79ac			;  
79ac			;  
79ac			;MsgHello:   DB  "Hello World!",0  
79ac			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
79ac			  
79ac			; Custom characters 5 pixels wide by 8 pixels high  
79ac			; Up to 8 custom characters can be defined  
79ac			;BitMaps:      
79ac			;; Character 0x00 = Battery icon  
79ac			;            DB  01110b  
79ac			;            DB  11011b  
79ac			;            DB  10001b  
79ac			;            DB  10001b  
79ac			;            DB  11111b  
79ac			;            DB  11111b  
79ac			;            DB  11111b  
79ac			;            DB  11111b  
79ac			;; Character 0x01 = Bluetooth icon  
79ac			;            DB  01100b  
79ac			;            DB  01010b  
79ac			;            DB  11100b  
79ac			;            DB  01000b  
79ac			;            DB  11100b  
79ac			;            DB  01010b  
79ac			;            DB  01100b  
79ac			;            DB  00000b  
79ac			;  
79ac			  
79ac			  
79ac			; **********************************************************************  
79ac			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
79ac			; **********************************************************************  
79ac			;  
79ac			; **  Written as a Small Computer Monitor App   
79ac			; **  Version 0.1 SCC 2018-05-16  
79ac			; **  www.scc.me.uk  
79ac			;  
79ac			; **********************************************************************  
79ac			;  
79ac			; This module provides support for alphanumeric LCD modules using with  
79ac			; *  HD44780 (or compatible) controller  
79ac			; *  5 x 7 pixel fonts  
79ac			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
79ac			; *  Interface via six digital outputs to the display (see below)  
79ac			;  
79ac			; LCD module pinout:  
79ac			;   1  Vss   0v supply  
79ac			;   2  Vdd   5v supply  
79ac			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
79ac			;   4  RS    High = data, Low = instruction  
79ac			;   5  R/W   High = Read, Low = Write  
79ac			;   6  E     Enable signal (active high)  
79ac			;   7  DB0   Data bit 0  
79ac			;   8  DB1   Data bit 1  
79ac			;   9  DB2   Data bit 2  
79ac			;  10  DB3   Data bit 3  
79ac			;  11  DB4   Data bit 4  
79ac			;  12  DB5   Data bit 5  
79ac			;  13  DB6   Data bit 6  
79ac			;  14  DB7   Data bit 7  
79ac			;  15  A     Backlight anode (+)  
79ac			;  16  K     Backlight cathode (-)  
79ac			;  
79ac			; This interfacing method uses 4-bit data mode and uses time delays  
79ac			; rather than polling the display's ready status. As a result the   
79ac			; interface only requires 6 simple output lines:  
79ac			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
79ac			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
79ac			;   LCD DB4 = Microcomputer output port bit 4  
79ac			;   LCD DB5 = Microcomputer output port bit 5  
79ac			;   LCD DB6 = Microcomputer output port bit 6  
79ac			;   LCD DB7 = Microcomputer output port bit 7  
79ac			; Display's R/W is connected to 0v so it is always in write mode  
79ac			; All 6 connections must be on the same port address <kLCDPrt>  
79ac			; This method also allows a decent length of cable from micro to LCD  
79ac			;  
79ac			; **********************************************************************  
79ac			;  
79ac			; To include the code for any given function provided by this module,   
79ac			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
79ac			; the parent source file.  
79ac			; For example:  #REQUIRES   uHexPrefix  
79ac			;  
79ac			; Also #INCLUDE this file at some point after the #REQUIRES statements  
79ac			; in the parent source file.  
79ac			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
79ac			;  
79ac			; These are the function names provided by this module:  
79ac			; fLCD_Init                     ;Initialise LCD  
79ac			; fLCD_Inst                     ;Send instruction to LCD  
79ac			; fLCD_Data                     ;Send data byte to LCD  
79ac			; fLCD_Pos                      ;Position cursor  
79ac			; fLCD_Str                      ;Display string  
79ac			; fLCD_Def                      ;Define custom character  
79ac			;  
79ac			; **********************************************************************  
79ac			;  
79ac			; Requires SCMonAPI.asm to also be included in the project  
79ac			;  
79ac			  
79ac			  
79ac			; **********************************************************************  
79ac			; **  Constants  
79ac			; **********************************************************************  
79ac			  
79ac			; Constants that must be defined externally  
79ac			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
79ac			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
79ac			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
79ac			;kLCDWidth: EQU 20             ;Width in characters  
79ac			  
79ac			; general line offsets in any frame buffer  
79ac			  
79ac			  
79ac			display_row_1: equ 0  
79ac			display_row_2: equ display_row_1+display_cols  
79ac			display_row_3: equ display_row_2 + display_cols  
79ac			display_row_4: equ display_row_3 + display_cols  
79ac			;display_row_4_eol:   
79ac			  
79ac			  
79ac			; Cursor position values for the start of each line  
79ac			  
79ac			; E  
79ac			kLCD_Line1: EQU 0x00   
79ac			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
79ac			; E1  
79ac			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
79ac			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
79ac			  
79ac			; Instructions to send as A register to fLCD_Inst  
79ac			kLCD_Clear: EQU 00000001b     ;LCD clear  
79ac			kLCD_Off:   EQU 00001000b     ;LCD off  
79ac			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
79ac			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
79ac			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
79ac			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
79ac			  
79ac			; Constants used by this code module  
79ac			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
79ac			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
79ac			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
79ac			  
79ac			  
79ac			  
79ac			; **********************************************************************  
79ac			; **  LCD support functions  
79ac			; **********************************************************************  
79ac			  
79ac			; Initialise alphanumeric LCD module  
79ac			; LCD control register codes:  
79ac			;   DL   0 = 4-bit mode        1 = 8-bit mode  
79ac			;   N    0 = 1-line mode       1 = 2-line mode  
79ac			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
79ac			;   D    0 = Display off       1 = Display on  
79ac			;   C    0 = Cursor off        1 = Cursor on  
79ac			;   B    0 = Blinking off      1 = Blinking on  
79ac			;   ID   0 = Decrement mode    1 = Increment mode  
79ac			;   SH   0 = Entire shift off  1 = Entire shift on  
79ac 3e 28		fLCD_Init:  LD   A, 40  
79ae cd d3 7a		            CALL LCDDelay       ;Delay 40ms after power up  
79b1			; For reliable reset set 8-bit mode - 3 times  
79b1 cd a3 7a		            CALL WrFn8bit       ;Function = 8-bit mode  
79b4 cd a3 7a		            CALL WrFn8bit       ;Function = 8-bit mode  
79b7 cd a3 7a		            CALL WrFn8bit       ;Function = 8-bit mode  
79ba			; Set 4-bit mode  
79ba cd 9f 7a		            CALL WrFn4bit       ;Function = 4-bit mode  
79bd cd d1 7a		            CALL LCDDelay1      ;Delay 37 us or more  
79c0			; Function set  
79c0 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
79c2 cd d5 79		            CALL fLCD_Inst      ;2 line, display on  
79c5			; Display On/Off control  
79c5 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
79c7 cd d5 79		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
79ca			; Display Clear  
79ca 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
79cc cd d5 79		            CALL fLCD_Inst      ;Clear display  
79cf			; Entry mode  
79cf 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
79d1 cd d5 79		            CALL fLCD_Inst      ;Increment mode, shift off  
79d4			; Display module now initialised  
79d4 c9			            RET  
79d5			; ok to here  
79d5			  
79d5			; Write instruction to LCD  
79d5			;   On entry: A = Instruction byte to be written  
79d5			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
79d5 f5			fLCD_Inst:  PUSH AF  
79d6 f5			            PUSH AF  
79d7 cd e9 79		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
79da f1			            POP  AF  
79db 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
79dc 17			            RLA  
79dd 17			            RLA  
79de 17			            RLA  
79df cd e9 79		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
79e2 3e 02		            LD   A, 2  
79e4 cd d3 7a		            CALL LCDDelay       ;Delay 2 ms to complete   
79e7 f1			            POP  AF  
79e8 c9			            RET  
79e9			Wr4bits:   
79e9 f5					push af  
79ea 3a 06 fb				ld a, (display_lcde1e2)  
79ed fe 00				cp 0     ; e  
79ef 20 10				jr nz, .wea2	  
79f1 f1					pop af  
79f2 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
79f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
79f6 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
79f8 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
79fa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
79fc cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
79fe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a00 c9			            RET  
7a01 f1			.wea2:		pop af  
7a02 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7a04 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a06 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7a08 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7a0a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7a0c cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7a0e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a10 c9			            RET  
7a11			  
7a11			  
7a11			; Write data to LCD  
7a11			;   On entry: A = Data byte to be written  
7a11			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7a11 f5			fLCD_Data:  PUSH AF  
7a12 f5			            PUSH AF  
7a13 cd 25 7a		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7a16 f1			            POP  AF  
7a17 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7a18 17			            RLA  
7a19 17			            RLA  
7a1a 17			            RLA  
7a1b cd 25 7a		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7a1e 3e 96		            LD   A, 150  
7a20 3d			Wait:      DEC  A              ;Wait a while to allow data   
7a21 20 fd		            JR   NZ, Wait      ;  write to complete  
7a23 f1			            POP  AF  
7a24 c9			            RET  
7a25			Wr4bitsa:     
7a25 f5					push af  
7a26 3a 06 fb				ld a, (display_lcde1e2)  
7a29 fe 00				cp 0     ; e1  
7a2b 20 16				jr nz, .we2	  
7a2d f1					pop af  
7a2e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7a30 cb d7		            SET  kLCDBitRS, A  
7a32 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7a34 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7a36 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7a38 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7a3a cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7a3c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7a3e cb 97		            RES  kLCDBitRS, A  
7a40 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a42 c9			            RET  
7a43 f1			.we2:		pop af  
7a44 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7a46 cb d7		            SET  kLCDBitRS, A  
7a48 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7a4a cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7a4c cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7a4e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7a50 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7a52 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7a54 cb 97		            RES  kLCDBitRS, A  
7a56 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a58 c9			            RET  
7a59			  
7a59			  
7a59			; Position cursor to specified location  
7a59			;   On entry: A = Cursor position  
7a59			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7a59 f5			fLCD_Pos:   PUSH AF  
7a5a					; at this point set the E1 or E2 flag depending on position  
7a5a			  
7a5a c5					push bc  
7a5b			;		push af  
7a5b 06 00				ld b, 0  
7a5d 4f					ld c, a  
7a5e 3e 4f				ld a, kLCD_Line3-1  
7a60 b7			 		or a      ;clear carry flag  
7a61 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7a62 38 04				jr c, .pe1  
7a64			  
7a64					; E selection  
7a64 cb 80				res 0, b         ; bit 0 unset e  
7a66			;		pop af    ; before line 3 so recover orig pos  
7a66			;		ld c, a    ; save for poking back  
7a66 18 06				jr .peset	          
7a68			.pe1:          	; E2 selection  
7a68 cb c0				set 0, b         ; bit 0 set e1  
7a6a 79					ld a, c  
7a6b de 4f				sbc a, kLCD_Line3-1  
7a6d 4f					ld c, a	         ; save caculated offset  
7a6e			;		pop af     ; bin this original value now we have calculated form  
7a6e			  
7a6e			.peset:		; set bit  
7a6e 78					ld a, b  
7a6f 32 06 fb				ld (display_lcde1e2), a 	  
7a72 79					ld a, c  
7a73 c1					pop bc  
7a74			  
7a74 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7a76 cd d5 79		            CALL fLCD_Inst      ;Write instruction to LCD  
7a79 f1			            POP  AF  
7a7a c9			            RET  
7a7b			  
7a7b			  
7a7b			; Output text string to LCD  
7a7b			;   On entry: DE = Pointer to null terminated text string  
7a7b			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7a7b 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7a7c b7			            OR   A              ;Null terminator?  
7a7d c8			            RET  Z              ;Yes, so finished  
7a7e cd 11 7a		            CALL fLCD_Data      ;Write character to display  
7a81 13			            INC  DE             ;Point to next character  
7a82 18 f7		            JR   fLCD_Str       ;Repeat  
7a84 c9					ret  
7a85			  
7a85			; Define custom character  
7a85			;   On entry: A = Character number (0 to 7)  
7a85			;             DE = Pointer to character bitmap data  
7a85			;   On exit:  A = Next character number  
7a85			;             DE = Next location following bitmap  
7a85			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7a85			; Character is   
7a85 c5			fLCD_Def:   PUSH BC  
7a86 f5			            PUSH AF  
7a87 07			            RLCA                ;Calculate location  
7a88 07			            RLCA                ;  for bitmap data  
7a89 07			            RLCA                ;  = 8 x CharacterNumber  
7a8a f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7a8c cd d5 79		            CALL fLCD_Inst      ;Write instruction to LCD  
7a8f 06 00		            LD   B, 0  
7a91 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7a92 cd 11 7a		            CALL fLCD_Data      ;Write byte to display  
7a95 13			            INC  DE             ;Point to next byte  
7a96 04			            INC  B              ;Count bytes  
7a97 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7a99 28 f6		            JR   Z, Loop       ;No, so repeat  
7a9b f1			            POP  AF  
7a9c 3c			            INC  A              ;Increment character number  
7a9d c1			            POP  BC  
7a9e c9			            RET  
7a9f			  
7a9f			  
7a9f			; **********************************************************************  
7a9f			; **  Private functions  
7a9f			; **********************************************************************  
7a9f			  
7a9f			; Write function to LCD  
7a9f			;   On entry: A = Function byte to be written  
7a9f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7a9f 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7aa1 18 02		            JR   WrFunc  
7aa3 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7aa5 f5			WrFunc:     PUSH AF  
7aa6 f5					push af  
7aa7 3a 06 fb				ld a, (display_lcde1e2)  
7aaa fe 00				cp 0     ; e1  
7aac 20 0f				jr nz, .wfea2	  
7aae f1					pop af  
7aaf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7ab1 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7ab3 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7ab5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7ab7 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7ab9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7abb 18 0d			jr .wfskip  
7abd f1			.wfea2:		pop af  
7abe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7ac0 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7ac2 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7ac4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7ac6 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7ac8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7aca 3e 05		.wfskip:            LD  A, 5  
7acc cd d3 7a		            CALL LCDDelay       ;Delay 5 ms to complete  
7acf f1			            POP  AF  
7ad0 c9			            RET  
7ad1			  
7ad1			  
7ad1			; Delay in milliseconds  
7ad1			;   On entry: A = Number of milliseconds delay  
7ad1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7ad1 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7ad3 d5			LCDDelay:   PUSH DE  
7ad4 5f			            LD   E, A           ;Delay by 'A' ms  
7ad5 16 00		            LD   D, 0  
7ad7 cd c3 0c		            CALL aDelayInMS  
7ada d1			            POP  DE  
7adb c9			            RET  
7adc			  
7adc			  
7adc			testlcd:  
7adc 3e 00			ld a, kLCD_Line1  
7ade cd 59 7a			call fLCD_Pos  
7ae1 06 28			ld b, 40  
7ae3 11 11 7b			ld de, .ttext1  
7ae6 cd a4 79			call write_len_string  
7ae9			  
7ae9 3e 28			ld a, kLCD_Line2  
7aeb cd 59 7a			call fLCD_Pos  
7aee 06 28			ld b, 40  
7af0 11 3a 7b			ld de, .ttext2  
7af3 cd a4 79			call write_len_string  
7af6 3e 50			ld a, kLCD_Line3  
7af8 cd 59 7a			call fLCD_Pos  
7afb 06 28			ld b, 40  
7afd 11 63 7b			ld de, .ttext3  
7b00 cd a4 79			call write_len_string  
7b03 3e 78			ld a, kLCD_Line4  
7b05 cd 59 7a			call fLCD_Pos  
7b08 06 28			ld b, 40  
7b0a 11 8c 7b			ld de, .ttext4  
7b0d cd a4 79			call write_len_string  
7b10			  
7b10 76				halt  
7b11			  
7b11			  
7b11 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7b3a .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7b63 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7b8c .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7bb5			   
7bb5			  
7bb5			  
7bb5			; eof  
7bb5			  
# End of file firmware_lcd_4x40.asm
7bb5			;include "firmware_lcd_4x20.asm" 
7bb5			include "firmware_key_5x10.asm" 
7bb5			; 5 x 10 decade counter scanner  
7bb5			  
7bb5			  
7bb5			; TODO do cursor shape change for shift keys  
7bb5			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7bb5			  
7bb5			  
7bb5			; bit mask for each scan column and row for teing the matrix  
7bb5			  
7bb5			  
7bb5			key_init:  
7bb5			  
7bb5			; SCMonAPI functions used  
7bb5			  
7bb5			; Alphanumeric LCD functions used  
7bb5			; no need to specify specific functions for this module  
7bb5			  
7bb5			  
7bb5 3e cf		            LD   A, 11001111b  
7bb7 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7bb9			;            LD   A, 00000000b  
7bb9 3e 1f		            LD   A, 00011111b  
7bbb d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7bbd			  
7bbd			  
7bbd				; TODO Configure cursor shapes  
7bbd			  
7bbd				; Load cursor shapes   
7bbd 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7bbf 11 cf 7b		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7bc2 06 02		            LD   B, 2           ;Number of characters to define  
7bc4 cd 85 7a		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7bc7 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7bc9			  
7bc9 3e 01				ld a, 1  
7bcb 32 fc fa			ld (cursor_shape),a  
7bce c9				ret  
7bcf			  
7bcf			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7bcf			; Up to 8 custom characters can be defined  
7bcf			.cursor_shapes:      
7bcf			;; Character 0x00 = Normal  
7bcf 1f			            DB  11111b  
7bd0 1f			            DB  11111b  
7bd1 1f			            DB  11111b  
7bd2 1f			            DB  11111b  
7bd3 1f			            DB  11111b  
7bd4 1f			            DB  11111b  
7bd5 1f			            DB  11111b  
7bd6 1f			            DB  11111b  
7bd7			;; Character 0x01 = Modifier  
7bd7 1f			            DB  11111b  
7bd8 1b			            DB  11011b  
7bd9 1b			            DB  11011b  
7bda 1b			            DB  11011b  
7bdb 1b			            DB  11011b  
7bdc 1f			            DB  11111b  
7bdd 1b			            DB  11011b  
7bde 1f			            DB  11111b  
7bdf			  
7bdf			  
7bdf			  
7bdf			  
7bdf			; Display custom character 0  
7bdf			;            LD   A, kLCD_Line1+14  
7bdf			;            CALL fLCD_Pos       ;Position cursor to location in A  
7bdf			;            LD   A, 0  
7bdf			;            CALL fLCD_Data      ;Write character in A at cursor  
7bdf			  
7bdf			; Display custom character 1  
7bdf			;            LD   A, kLCD_Line2+14  
7bdf			;            CALL fLCD_Pos      ;Position cursor to location in A  
7bdf			;            LD   A, 1  
7bdf			;            CALL fLCD_Data     ;Write character in A at cursor  
7bdf			  
7bdf			; keyboard scanning   
7bdf			  
7bdf			; character in from keyboard  
7bdf			  
7bdf			; mapping for the pcb layout  
7bdf			  
7bdf			.matrix_to_char:  
7bdf .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7bea .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7bf5 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7c00 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7c0b .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7c16			.matrix_to_shift:  
7c16			  
7c16 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7c21 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7c2c 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7c37 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7c42 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7c4d			  
7c4d			.matrix_to_symbolshift:  
7c4d			  
7c4d fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7c58 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7c63 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7c6e			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7c6e 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7c79 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7c84			  
7c84			  
7c84			  
7c84			; mapping for a simple straight through breadboard layout  
7c84			  
7c84			;.matrix_to_char:  
7c84			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7c84			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7c84			;		db "asdfghjkl",KEY_CR,0  
7c84			;		db "qwertyuiop",0  
7c84			;		 db "1234567890",0  
7c84			;.matrix_to_shift:  
7c84			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7c84			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7c84			;		db "ASDFGHJKL",KEY_CR,0  
7c84			;		db "QWERTYUIOP",0  
7c84			;		 db "!",'"',"#$%^&*()",0  
7c84			;.matrix_to_symbolshift:  
7c84			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7c84			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7c84			;		db "_?*fghjk=",KEY_CR,0  
7c84			;		db "-/+*[]{}@#",0  
7c84			;		 db "1234567890",0  
7c84			  
7c84			;.matrix_to_char: db "D#0*C987B654A321"  
7c84			  
7c84			  
7c84				  
7c84			  
7c84			; add cin and cin_wait  
7c84			  
7c84 cd 95 7c		cin_wait: 	call cin  
7c87						if DEBUG_KEYCINWAIT  
7c87							push af  
7c87							  
7c87							ld hl,key_repeat_ct  
7c87							ld (hl),a  
7c87							inc hl  
7c87							call hexout  
7c87							ld hl,key_repeat_ct+3  
7c87							ld a,0  
7c87							ld (hl),a  
7c87			  
7c87							    LD   A, kLCD_Line1+11  
7c87							    CALL fLCD_Pos       ;Position cursor to location in A  
7c87							    LD   DE, key_repeat_ct  
7c87							    ;LD   DE, MsgHello  
7c87							    CALL fLCD_Str       ;Display string pointed to by DE  
7c87			  
7c87			  
7c87			  
7c87							pop af  
7c87						endif  
7c87 fe 00			cp 0  
7c89 28 f9			jr z, cin_wait   ; block until key press  
7c8b			  
7c8b							if DEBUG_KEYCINWAIT  
7c8b								push af  
7c8b			  
7c8b								ld a, 'A'	  
7c8b								ld hl,key_repeat_ct  
7c8b								ld (hl),a  
7c8b								inc hl  
7c8b								ld a,0  
7c8b								ld (hl),a  
7c8b			  
7c8b								    LD   A, kLCD_Line2+11  
7c8b								    CALL fLCD_Pos       ;Position cursor to location in A  
7c8b								    LD   DE, key_repeat_ct  
7c8b								    ;LD   DE, MsgHello  
7c8b								    CALL fLCD_Str       ;Display string pointed to by DE  
7c8b			  
7c8b							call delay500ms  
7c8b			  
7c8b								pop af  
7c8b							endif  
7c8b f5				push af   ; save key pressed  
7c8c			  
7c8c			.cin_wait1:	  
7c8c							if DEBUG_KEYCINWAIT  
7c8c								push af  
7c8c			  
7c8c								ld a, 'b'	  
7c8c								ld hl,key_repeat_ct  
7c8c								ld (hl),a  
7c8c								inc hl  
7c8c								ld a,0  
7c8c								ld (hl),a  
7c8c			  
7c8c								    LD   A, kLCD_Line2+11  
7c8c								    CALL fLCD_Pos       ;Position cursor to location in A  
7c8c								    LD   DE, key_repeat_ct  
7c8c								    ;LD   DE, MsgHello  
7c8c								    CALL fLCD_Str       ;Display string pointed to by DE  
7c8c			  
7c8c			  
7c8c							call delay500ms  
7c8c			  
7c8c								pop af  
7c8c							endif  
7c8c			  
7c8c cd 95 7c		call cin  
7c8f fe 00			cp 0  
7c91 20 f9			jr nz, .cin_wait1  	; wait for key release  
7c93			if DEBUG_KEYCINWAIT  
7c93				push af  
7c93			  
7c93				ld a, '3'	  
7c93				ld hl,key_repeat_ct  
7c93				ld (hl),a  
7c93				inc hl  
7c93				ld a,0  
7c93				ld (hl),a  
7c93			  
7c93			            LD   A, kLCD_Line2+11  
7c93			            CALL fLCD_Pos       ;Position cursor to location in A  
7c93			            LD   DE, key_repeat_ct  
7c93			            ;LD   DE, MsgHello  
7c93			            CALL fLCD_Str       ;Display string pointed to by DE  
7c93			  
7c93			  
7c93			call delay500ms  
7c93			  
7c93				pop af  
7c93			endif  
7c93			  
7c93 f1				pop af   ; get key  
7c94 c9				ret  
7c95			  
7c95			  
7c95 cd a9 7c		cin: 	call .mtoc  
7c98			  
7c98			if DEBUG_KEYCIN  
7c98				push af  
7c98				  
7c98				ld hl,key_repeat_ct  
7c98				ld (hl),a  
7c98				inc hl  
7c98				call hexout  
7c98				ld hl,key_repeat_ct+3  
7c98				ld a,0  
7c98				ld (hl),a  
7c98			  
7c98			            LD   A, kLCD_Line3+15  
7c98			            CALL fLCD_Pos       ;Position cursor to location in A  
7c98			            LD   DE, key_repeat_ct  
7c98			            ;LD   DE, MsgHello  
7c98			            CALL fLCD_Str       ;Display string pointed to by DE  
7c98			  
7c98			  
7c98			call delay500ms  
7c98			  
7c98				pop af  
7c98			endif  
7c98			  
7c98			  
7c98				; no key held  
7c98 fe 00			cp 0  
7c9a c8				ret z  
7c9b			  
7c9b			if DEBUG_KEYCIN  
7c9b				push af  
7c9b			  
7c9b				ld a, '1'	  
7c9b				ld hl,key_repeat_ct  
7c9b				ld (hl),a  
7c9b				inc hl  
7c9b				ld a,0  
7c9b				ld (hl),a  
7c9b			  
7c9b			            LD   A, kLCD_Line4+15  
7c9b			            CALL fLCD_Pos       ;Position cursor to location in A  
7c9b			            LD   DE, key_repeat_ct  
7c9b			            ;LD   DE, MsgHello  
7c9b			            CALL fLCD_Str       ;Display string pointed to by DE  
7c9b			  
7c9b			  
7c9b			call delay500ms  
7c9b			  
7c9b				pop af  
7c9b			endif  
7c9b			  
7c9b				; stop key bounce  
7c9b			  
7c9b 32 c6 fd			ld (key_held),a		 ; save it  
7c9e 47				ld b, a  
7c9f			  
7c9f c5			.cina1:	push bc  
7ca0			if DEBUG_KEYCIN  
7ca0				push af  
7ca0			  
7ca0				ld hl,key_repeat_ct  
7ca0				inc hl  
7ca0				call hexout  
7ca0				ld hl,key_repeat_ct+3  
7ca0				ld a,0  
7ca0				ld (hl),a  
7ca0				ld hl,key_repeat_ct  
7ca0				ld a, '2'	  
7ca0				ld (hl),a  
7ca0			  
7ca0			            LD   A, kLCD_Line4+15  
7ca0			            CALL fLCD_Pos       ;Position cursor to location in A  
7ca0			            LD   DE, key_repeat_ct  
7ca0			            ;LD   DE, MsgHello  
7ca0			            CALL fLCD_Str       ;Display string pointed to by DE  
7ca0			  
7ca0				pop af  
7ca0			endif  
7ca0 cd a9 7c			call .mtoc  
7ca3 c1				pop bc  
7ca4 b8				cp b  
7ca5 28 f8			jr z, .cina1  
7ca7 78				ld a,b		  
7ca8			if DEBUG_KEYCIN  
7ca8				push af  
7ca8			  
7ca8				ld hl,key_repeat_ct  
7ca8				inc hl  
7ca8				call hexout  
7ca8				ld hl,key_repeat_ct+3  
7ca8				ld a,0  
7ca8				ld (hl),a  
7ca8				ld hl,key_repeat_ct  
7ca8				ld a, '3'	  
7ca8				ld (hl),a  
7ca8			  
7ca8			            LD   A, kLCD_Line4+15  
7ca8			            CALL fLCD_Pos       ;Position cursor to location in A  
7ca8			            LD   DE, key_repeat_ct  
7ca8			            ;LD   DE, MsgHello  
7ca8			            CALL fLCD_Str       ;Display string pointed to by DE  
7ca8			  
7ca8				pop af  
7ca8			endif  
7ca8 c9				ret  
7ca9			  
7ca9			; detect keyboard modifier key press and apply new overlay to the face key held  
7ca9			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7ca9			  
7ca9			;.cin_map_modifier:   
7ca9			;	ld a, (hl)  
7ca9			;	and 255  
7ca9			;	ret NZ		; modifier key not flagged  
7ca9			;  
7ca9			;	; get key face  
7ca9			;  
7ca9			;	ld b,(key_face_held)  
7ca9			;  
7ca9			;	ld b, key_cols * key_rows  
7ca9			;  
7ca9			;	push de  
7ca9			;	pop hl  
7ca9			;  
7ca9			;.mmod1: ld a,(hl)   ; get map test  
7ca9			;	cp b  
7ca9			;	jr z, .mmod2  
7ca9			;  
7ca9			;  
7ca9			;  
7ca9			;.mmod2: inc hl    ;   
7ca9			;  
7ca9			;	  
7ca9			;  
7ca9			;	  
7ca9			;  
7ca9			;	ld hl,key_actual_pressed  
7ca9			;	ld (hl),a,  
7ca9			;	ret  
7ca9			  
7ca9			; map matrix key held to char on face of key  
7ca9			  
7ca9			.mtoc:  
7ca9			  
7ca9			; test decade counter strobes  
7ca9			  
7ca9			;.decadetest1:  
7ca9			  
7ca9			; reset counter  
7ca9			;ld a, 128  
7ca9			;out (portbdata),a  
7ca9			  
7ca9			  
7ca9			;ld b, 5  
7ca9			;.dec1:  
7ca9			;ld a, 0  
7ca9			;out (portbdata),a  
7ca9			;call delay1s  
7ca9			  
7ca9			;ld a, 32  
7ca9			;out (portbdata),a  
7ca9			;call delay1s  
7ca9			;call delay1s  
7ca9			;call delay1s  
7ca9			;  
7ca9			;ld a, 64+32  
7ca9			;out (portbdata),a  
7ca9			;call delay1s  
7ca9			;;djnz .dec1  
7ca9			;  
7ca9			;jp .decadetest1  
7ca9			  
7ca9			  
7ca9			  
7ca9			  
7ca9			  
7ca9			  
7ca9			  
7ca9			  
7ca9			  
7ca9			  
7ca9				; scan keyboard matrix and generate raw scan map  
7ca9 cd 3c 7d			call matrix  
7cac			  
7cac				; reuse c bit 0 left modifer button - ie shift  
7cac			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7cac				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7cac			  
7cac 0e 00			ld c, 0  
7cae			  
7cae				; TODO set flags for modifer key presses   
7cae				; TODO do a search for modifer key...  
7cae			  
7cae				;ld hl,keyscan_table_row4  
7cae 21 25 fe			ld hl,keyscan_table_row2  
7cb1			  
7cb1 7e				ld a, (hl)  
7cb2 fe 23			cp '#'  
7cb4 20 07			jr nz, .nextmodcheck  
7cb6 cb c1			set 0, c  
7cb8 21 16 7c			ld hl, .matrix_to_shift  
7cbb 18 21			jr .dokeymap  
7cbd				; TODO for now igonre  
7cbd			.nextmodcheck:  
7cbd 21 1a fe			ld hl,keyscan_table_row3  
7cc0			  
7cc0 7e				ld a, (hl)  
7cc1 fe 23			cp '#'  
7cc3 20 07			jr nz, .nextmodcheck2  
7cc5 cb c9			set 1, c   
7cc7 21 4d 7c			ld hl, .matrix_to_symbolshift  
7cca 18 12			jr .dokeymap  
7ccc			.nextmodcheck2:  
7ccc 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7ccf			  
7ccf 7e				ld a, (hl)  
7cd0 fe 23			cp '#'  
7cd2 20 07			jr nz, .donemodcheck  
7cd4 cb c9			set 1, c   
7cd6 21 16 7c			ld hl, .matrix_to_shift  
7cd9 18 03			jr .dokeymap  
7cdb			  
7cdb				; no modifer found so just map to normal keys  
7cdb				; get mtoc map matrix to respective keys  
7cdb			;	ld hl, .matrix_to_char  
7cdb			;	ld hl, .matrix_to_char  
7cdb			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7cdb			;	ld a, KEY_SHIFT  
7cdb			;	call findchar  
7cdb			;  
7cdb			;	; got offset to key modifer in b  
7cdb			;  
7cdb			;	ld hl,keyscan_table_row5  
7cdb			;  
7cdb			;	ld a,b  
7cdb			;	call addatohl  
7cdb			;	ld a,(hl)  
7cdb			;  
7cdb			;	cp '#'  
7cdb			;	jr nz, .nextmodcheck  
7cdb			;	set 0, c  
7cdb			;	ld hl, .matrix_to_char  
7cdb			;	jr .dokeymap  
7cdb			;	; TODO for now igonre  
7cdb			;.nextmodcheck:  
7cdb			;	ld hl, .matrix_to_symbolshift  
7cdb			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7cdb			;	ld a, KEY_SYMBOLSHIFT  
7cdb			;	call findchar  
7cdb			;  
7cdb			;  
7cdb			;	; got offset to key modifer in b  
7cdb			;  
7cdb			;	ld hl,keyscan_table_row5  
7cdb			;  
7cdb			;	ld a,b  
7cdb			;	call addatohl  
7cdb			;	ld a,(hl)  
7cdb			;  
7cdb			;	cp '#'  
7cdb			;	jr nz, .donemodcheck  
7cdb			;	set 1, c   
7cdb			;	ld hl, .matrix_to_symbolshift  
7cdb			;	jr .dokeymap  
7cdb			  
7cdb			  
7cdb			  
7cdb			.donemodcheck:  
7cdb				; no modifer found so just map to normal keys  
7cdb				; get mtoc map matrix to respective keys  
7cdb 21 df 7b			ld hl, .matrix_to_char  
7cde			  
7cde			.dokeymap:  
7cde				;ld (key_fa), c   
7cde cd f7 7c			call .mapkeys  
7ce1			  
7ce1			  
7ce1			if DEBUG_KEY  
7ce1			  
7ce1			; Display text on first line  
7ce1			            LD   A, kLCD_Line1  
7ce1			            CALL fLCD_Pos       ;Position cursor to location in A  
7ce1			            LD   DE, keyscan_table_row1  
7ce1			            ;LD   DE, MsgHello  
7ce1			            CALL fLCD_Str       ;Display string pointed to by DE  
7ce1			  
7ce1			; Display text on second line  
7ce1			            LD   A, kLCD_Line2  
7ce1			            CALL fLCD_Pos       ;Position cursor to location in A  
7ce1			            LD   DE, keyscan_table_row2  
7ce1			            CALL fLCD_Str       ;Display string pointed to by DE  
7ce1			            LD   A, kLCD_Line3  
7ce1			            CALL fLCD_Pos       ;Position cursor to location in A  
7ce1			            LD   DE, keyscan_table_row3  
7ce1			            CALL fLCD_Str       ;Display string pointed to by DE  
7ce1			            LD   A, kLCD_Line4  
7ce1			            CALL fLCD_Pos       ;Position cursor to location in A  
7ce1			            LD   DE, keyscan_table_row4  
7ce1			            CALL fLCD_Str       ;Display string pointed to by DE  
7ce1			            LD   A, kLCD_Line1+10  
7ce1			            CALL fLCD_Pos       ;Position cursor to location in A  
7ce1			            LD   DE, keyscan_table_row5  
7ce1			            CALL fLCD_Str       ;Display string pointed to by DE  
7ce1			  
7ce1				;call delay250ms  
7ce1			endif  
7ce1			;	jp testkey  
7ce1			  
7ce1			; get first char reported  
7ce1			  
7ce1 21 04 fe			ld hl,keyscan_table_row5  
7ce4			  
7ce4				;ld b, 46   ; 30 keys to remap + 8 nulls   
7ce4 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7ce6			.findkey:  
7ce6 7e				ld a,(hl)  
7ce7 fe 00			cp 0  
7ce9 28 04			jr z, .nextkey  
7ceb fe 7e			cp KEY_MATRIX_NO_PRESS  
7ced 20 06			jr nz, .foundkey  
7cef			.nextkey:  
7cef 23				inc hl  
7cf0 10 f4			djnz .findkey  
7cf2 3e 00			ld a,0  
7cf4 c9				ret  
7cf5			.foundkey:  
7cf5 7e				ld a,(hl)  
7cf6 c9				ret  
7cf7				  
7cf7			  
7cf7			; convert the raw key map given hl for destination key  
7cf7			.mapkeys:  
7cf7 11 04 fe			ld de,keyscan_table_row5  
7cfa			  
7cfa 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7cfc			.remap:  
7cfc 1a				ld a,(de)  
7cfd fe 23			cp '#'  
7cff 20 02			jr nz, .remapnext  
7d01				;CALLMONITOR  
7d01 7e				ld a,(hl)  
7d02 12				ld (de),a  
7d03			  
7d03			  
7d03			  
7d03			.remapnext:  
7d03 23				inc hl  
7d04 13				inc de  
7d05 10 f5			djnz .remap  
7d07				  
7d07 c9				ret  
7d08			  
7d08			  
7d08			  
7d08			.mtocold2:  
7d08			  
7d08			;	; flag if key D is held down and remove from reporting  
7d08			;	ld bc, .key_map_fd    
7d08			;	ld hl, keyscan_table  
7d08			;	ld de, key_fd  
7d08			;	call .key_shift_hold  
7d08			;	cp 255  
7d08			;	jr z, .cinmap  
7d08			;	; flag if key C is held down and remove from reporting  
7d08			;	ld bc, .key_map_fc    
7d08			;	ld hl, keyscan_table+key_cols  
7d08			;	ld de, key_fc  
7d08			;	call .key_shift_hold  
7d08			;	cp 255  
7d08			;	jr z, .cinmap  
7d08			;	; flag if key B is held down and remove from reporting  
7d08			;	ld bc, .key_map_fb    
7d08			;	ld hl, keyscan_table+(key_cols*2)  
7d08			;	ld de, key_fb  
7d08			;	call .key_shift_hold  
7d08			;	cp 255  
7d08			;	jr z, .cinmap  
7d08			;	; flag if key A is held down and remove from reporting  
7d08			;	ld bc, .key_map_fa    
7d08			;	ld hl, keyscan_table+(key_cols*3)  
7d08			;	ld de, key_fa  
7d08			;	call .key_shift_hold  
7d08			;	cp 255  
7d08			;	jr z, .cinmap  
7d08			  
7d08 11 df 7b			ld de, .matrix_to_char  
7d0b			  
7d0b			  
7d0b			.cinmap1:   
7d0b				if DEBUG_KEY  
7d0b			            LD   A, kLCD_Line4  
7d0b			            CALL fLCD_Pos       ;Position cursor to location in A  
7d0b					push de  
7d0b			            LD   DE, keyscan_table  
7d0b			            CALL fLCD_Str       ;Display string pointed to by DE  
7d0b					pop de  
7d0b				endif  
7d0b			  
7d0b				; scan key matrix table for any held key  
7d0b			  
7d0b				; de holds either the default matrix or one selected above  
7d0b			  
7d0b 21 d1 fd			ld hl, keyscan_table  
7d0e 06 32			ld b,key_cols*key_rows  
7d10			  
7d10 7e			.cin11:	ld a,(hl)  
7d11 fe 23			cp '#'  
7d13 28 08			jr z, .cinhit1  
7d15 23				inc hl  
7d16 13				inc de  
7d17 05				dec b  
7d18 20 f6			jr nz, .cin11  
7d1a				; no key found held  
7d1a 3e 00			ld a,0  
7d1c c9				ret  
7d1d d5			.cinhit1: push de  
7d1e e1				pop hl  
7d1f 7e				ld a,(hl)  
7d20 c9				ret  
7d21			  
7d21			; flag a control key is held   
7d21			; hl is key pin, de is flag indicator  
7d21			  
7d21			.key_shift_hold1:  
7d21 c5				push bc  
7d22 3e 01			ld a, 1  
7d24 32 fc fa			ld (cursor_shape),a  
7d27 06 00			ld b, 0  
7d29 7e				ld a, (hl)  
7d2a fe 2e			cp '.'  
7d2c 28 0a			jr z, .key_shift11  
7d2e 06 ff			ld b, 255  
7d30 3e 2b			ld a, '+'    ; hide key from later scans  
7d32 77				ld (hl),a  
7d33 3e 02			ld a, 2  
7d35 32 fc fa			ld (cursor_shape),a  
7d38			.key_shift11:  
7d38				; write flag indicator  
7d38 78				ld a,b  
7d39 12				ld (de),a  
7d3a			  
7d3a d1				pop de    ; de now holds the key map ptr  
7d3b c9				ret  
7d3c			  
7d3c				  
7d3c			  
7d3c			; scans keyboard matrix and flags key press in memory array	  
7d3c				  
7d3c			matrix:  
7d3c				;call matrix  
7d3c				; TODO optimise the code....  
7d3c			  
7d3c			  
7d3c			;ld hl, keyscan_table_row1  
7d3c			;ld de, keyscan_table_row1+1  
7d3c			;ld bc,46  
7d3c			;ld a,KEY_MATRIX_NO_PRESS  
7d3c			;ldir  
7d3c			  
7d3c			  
7d3c			  
7d3c			; reset counter  
7d3c 3e 80		ld a, 128  
7d3e d3 c1		out (portbdata),a  
7d40			  
7d40 06 0a		ld b, 10  
7d42 0e 00		ld c, 0       ; current clock toggle  
7d44			  
7d44			.colscan:  
7d44			  
7d44			; set current column  
7d44			; disable clock enable and set clock low  
7d44			  
7d44			;ld a, 0  
7d44			;out (portbdata),a  
7d44			  
7d44			; For each column scan for switches  
7d44			  
7d44 c5			push bc  
7d45 21 c7 fd		ld hl, keyscan_scancol  
7d48 cd 51 7e		call .rowscan  
7d4b c1			pop bc  
7d4c			  
7d4c			  
7d4c			; get back current column  
7d4c			  
7d4c			; translate the row scan  
7d4c			  
7d4c			;   
7d4c			; row 1  
7d4c			  
7d4c 78			ld a,b  
7d4d			  
7d4d 21 3a fe		LD   hl, keyscan_table_row1+10  
7d50			  
7d50 cd e1 0f		call subafromhl  
7d53			;call addatohl  
7d53			  
7d53 11 c7 fd		ld de, keyscan_scancol  
7d56			  
7d56 1a			ld a,(de)  
7d57 77			ld (hl),a  
7d58			  
7d58			  
7d58			  
7d58			  
7d58			; row 2  
7d58			  
7d58 78			ld a,b  
7d59			  
7d59 21 2f fe		LD   hl, keyscan_table_row2+10  
7d5c			  
7d5c			;call addatohl  
7d5c cd e1 0f		call subafromhl  
7d5f			  
7d5f			  
7d5f 11 c8 fd		ld de, keyscan_scancol+1  
7d62			  
7d62 1a			ld a,(de)  
7d63 77			ld (hl),a  
7d64			  
7d64			  
7d64			; row 3  
7d64			  
7d64 78			ld a,b  
7d65			  
7d65 21 24 fe		LD   hl, keyscan_table_row3+10  
7d68			  
7d68			;call addatohl  
7d68 cd e1 0f		call subafromhl  
7d6b			  
7d6b 11 c9 fd		ld de, keyscan_scancol+2  
7d6e			  
7d6e 1a			ld a,(de)  
7d6f 77			ld (hl),a  
7d70			  
7d70			  
7d70			  
7d70			; row 4  
7d70			  
7d70 78			ld a,b  
7d71			  
7d71 21 19 fe		LD   hl, keyscan_table_row4+10  
7d74			  
7d74			;call addatohl  
7d74 cd e1 0f		call subafromhl  
7d77			  
7d77 11 ca fd		ld de, keyscan_scancol+3  
7d7a			  
7d7a 1a			ld a,(de)  
7d7b 77			ld (hl),a  
7d7c			  
7d7c			; row 5  
7d7c			  
7d7c 78			ld a,b  
7d7d			  
7d7d 21 0e fe		LD   hl, keyscan_table_row5+10  
7d80			  
7d80			;call addatohl  
7d80 cd e1 0f		call subafromhl  
7d83			  
7d83 11 cb fd		ld de, keyscan_scancol+4  
7d86			  
7d86 1a			ld a,(de)  
7d87 77			ld (hl),a  
7d88			  
7d88			; handshake next column  
7d88			  
7d88			  
7d88 3e 40		ld a, 64  
7d8a d3 c1		out (portbdata),a  
7d8c			  
7d8c 3e 00		ld a, 0  
7d8e d3 c1		out (portbdata),a  
7d90			  
7d90			; toggle clk and move to next column  
7d90			;ld a, 64  
7d90			;cp c  
7d90			;  
7d90			;jr z, .coltoglow  
7d90			;ld c, a  
7d90			;jr .coltog  
7d90			;.coltoglow:  
7d90			;ld c, 0  
7d90			;.coltog:  
7d90			;ld a, c  
7d90			;out (portbdata),a  
7d90			  
7d90 10 b2		djnz .colscan  
7d92			  
7d92 3e 0a		ld a,10  
7d94 21 30 fe		LD   hl, keyscan_table_row1  
7d97 cd cf 0f		call addatohl  
7d9a 3e 00		ld a, 0  
7d9c 77			ld (hl), a  
7d9d			  
7d9d			  
7d9d 3e 0a		ld a,10  
7d9f 21 25 fe		LD   hl, keyscan_table_row2  
7da2 cd cf 0f		call addatohl  
7da5 3e 00		ld a, 0  
7da7 77			ld (hl), a  
7da8			  
7da8 3e 0a		ld a,10  
7daa 21 1a fe		LD   hl, keyscan_table_row3  
7dad cd cf 0f		call addatohl  
7db0 3e 00		ld a, 0  
7db2 77			ld (hl), a  
7db3			  
7db3 3e 0a		ld a,10  
7db5 21 0f fe		LD   hl, keyscan_table_row4  
7db8 cd cf 0f		call addatohl  
7dbb 3e 00		ld a, 0  
7dbd 77			ld (hl), a  
7dbe			  
7dbe 3e 0a		ld a,10  
7dc0 21 04 fe		LD   hl, keyscan_table_row5  
7dc3 cd cf 0f		call addatohl  
7dc6 3e 00		ld a, 0  
7dc8 77			ld (hl), a  
7dc9			  
7dc9			if DEBUG_KEY_MATRIX  
7dc9			  
7dc9			; Display text on first line  
7dc9			            LD   A, kLCD_Line1  
7dc9			            CALL fLCD_Pos       ;Position cursor to location in A  
7dc9			            LD   DE, keyscan_table_row1  
7dc9			            ;LD   DE, MsgHello  
7dc9			            CALL fLCD_Str       ;Display string pointed to by DE  
7dc9			  
7dc9			; Display text on second line  
7dc9			            LD   A, kLCD_Line2  
7dc9			            CALL fLCD_Pos       ;Position cursor to location in A  
7dc9			            LD   DE, keyscan_table_row2  
7dc9			            CALL fLCD_Str       ;Display string pointed to by DE  
7dc9			            LD   A, kLCD_Line3  
7dc9			            CALL fLCD_Pos       ;Position cursor to location in A  
7dc9			            LD   DE, keyscan_table_row3  
7dc9			            CALL fLCD_Str       ;Display string pointed to by DE  
7dc9			            LD   A, kLCD_Line4  
7dc9			            CALL fLCD_Pos       ;Position cursor to location in A  
7dc9			            LD   DE, keyscan_table_row4  
7dc9			            CALL fLCD_Str       ;Display string pointed to by DE  
7dc9			            LD   A, kLCD_Line4+10  
7dc9			            CALL fLCD_Pos       ;Position cursor to location in A  
7dc9			            LD   DE, keyscan_table_row5  
7dc9			            CALL fLCD_Str       ;Display string pointed to by DE  
7dc9			  
7dc9			;call delay250ms  
7dc9				jp matrix  
7dc9			endif  
7dc9 c9			ret  
7dca			  
7dca			; using decade counter....  
7dca			  
7dca			  
7dca			; TODO reset decade counter to start of scan  
7dca			  
7dca			; reset 15  
7dca			; clock 14  
7dca			; ce 13  
7dca			  
7dca			; 1 - q5  
7dca			; 2 - q1  
7dca			; 3 - q0  
7dca			; 4 - q2  
7dca			; 5 - q6  
7dca			; 6 - q7  
7dca			; 7 - q3  
7dca			; 8 - vss  
7dca			; 9 - q8  
7dca			; 10 - q4  
7dca			; 11 - q9  
7dca			; 12 - cout  
7dca			; 16 - vdd  
7dca			  
7dca			; clock      ce       reset     output  
7dca			; 0          x        0         n  
7dca			; x          1        0         n  
7dca			; x          x        1         q0  
7dca			; rising     0        0         n+1  
7dca			; falling    x        0         n  
7dca			; x          rising   0         n  
7dca			; 1          falling  0         x+1  
7dca			;  
7dca			; x = dont care, if n < 5 carry = 1 otherwise 0  
7dca			  
7dca			;   
7dca			; reset   
7dca			; 13=0, 14=0, 15=1 .. 15=0  
7dca			;  
7dca			; handshake line  
7dca			; 14=1.... read line 14=0  
7dca			  
7dca			  
7dca			  
7dca			  
7dca			  
7dca			; TODO hand shake clock for next column scan  
7dca			; TODO detect each row  
7dca			  
7dca			  
7dca			  
7dca			  
7dca			; reset 128  
7dca			; clock 64  
7dca			; ce 32  
7dca			  
7dca			  
7dca			.cyclestart:  
7dca			  
7dca			; reset counter  
7dca 3e 80		ld a, 128  
7dcc d3 c1		out (portbdata),a  
7dce			  
7dce			; loop leds  
7dce 06 0a		ld b,10  
7dd0			  
7dd0			.cycle1:  
7dd0 c5			push bc  
7dd1 3e 00		ld a, 0  
7dd3 d3 c1		out (portbdata),a  
7dd5 cd d2 0c		call delay250ms  
7dd8			  
7dd8 3e 40		ld a, 64  
7dda d3 c1		out (portbdata),a  
7ddc cd d2 0c		call delay250ms  
7ddf			  
7ddf 3e 00		ld a, 0  
7de1 d3 c1		out (portbdata),a  
7de3 cd d2 0c		call delay250ms  
7de6			  
7de6 c1			pop bc  
7de7 10 e7		djnz .cycle1  
7de9			  
7de9			  
7de9 18 df		jr .cyclestart  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			; map matrix key held to char on face of key  
7deb			  
7deb			;.mtocold:  
7deb			;  
7deb			;  
7deb			;; reset counter  
7deb			;ld a, 128  
7deb			;out (portbdata),a  
7deb			;  
7deb			;  
7deb			;; scan keyboard row 1  
7deb			;ld a, 0  
7deb			;out (portbdata),a  
7deb			;;ld a, 64  
7deb			;;out (portbdata),a  
7deb			;  
7deb			;  
7deb			;	ld a, 128  
7deb			;	ld hl, keyscan_table  
7deb			;	call .rowscan  
7deb			;  
7deb			;;ld a, 0  
7deb			;;out (portbdata),a  
7deb			;ld a, 64  
7deb			;out (portbdata),a  
7deb			;  
7deb			;	ld a, 64  
7deb			;	ld hl, keyscan_table+key_cols  
7deb			;	call .rowscan  
7deb			;  
7deb			;ld a, 0  
7deb			;out (portbdata),a  
7deb			;;ld a, 64  
7deb			;;out (portbdata),a  
7deb			;	ld a, 32  
7deb			;	ld hl, keyscan_table+(key_cols*2)  
7deb			;	call .rowscan  
7deb			;  
7deb			;  
7deb			;;ld a, 0  
7deb			;;out (portbdata),a  
7deb			;ld a, 64  
7deb			;out (portbdata),a  
7deb			;  
7deb			;	ld a, 16  
7deb			;	ld hl, keyscan_table+(key_cols*3)  
7deb			;	call .rowscan  
7deb			;  
7deb			;  
7deb			;	; flag if key D is held down and remove from reporting  
7deb			;	ld bc, .key_map_fd    
7deb			;	ld hl, keyscan_table  
7deb			;	ld de, key_fd  
7deb			;	call .key_shift_hold  
7deb			;	cp 255  
7deb			;	jr z, .cinmap  
7deb			;	; flag if key C is held down and remove from reporting  
7deb			;	ld bc, .key_map_fc    
7deb			;	ld hl, keyscan_table+key_cols  
7deb			;	ld de, key_fc  
7deb			;	call .key_shift_hold  
7deb			;	cp 255  
7deb			;	jr z, .cinmap  
7deb			;	; flag if key B is held down and remove from reporting  
7deb			;	ld bc, .key_map_fb    
7deb			;	ld hl, keyscan_table+(key_cols*2)  
7deb			;	ld de, key_fb  
7deb			;	call .key_shift_hold  
7deb			;	cp 255  
7deb			;	jr z, .cinmap  
7deb			;	; flag if key A is held down and remove from reporting  
7deb			;	ld bc, .key_map_fa    
7deb			;	ld hl, keyscan_table+(key_cols*3)  
7deb			;	ld de, key_fa  
7deb			;	call .key_shift_hold  
7deb			;	cp 255  
7deb			;	jr z, .cinmap  
7deb			;  
7deb			;	ld de, .matrix_to_char  
7deb			;  
7deb			;  
7deb			;.cinmap:   
7deb			;	if DEBUG_KEY  
7deb			;            LD   A, kLCD_Line4  
7deb			;            CALL fLCD_Pos       ;Position cursor to location in A  
7deb			;		push de  
7deb			;            LD   DE, keyscan_table  
7deb			;            CALL fLCD_Str       ;Display string pointed to by DE  
7deb			;		pop de  
7deb			;	endif  
7deb			  
7deb				; scan key matrix table for any held key  
7deb			  
7deb				; de holds either the default matrix or one selected above  
7deb			  
7deb			;	ld hl, keyscan_table  
7deb			;	ld b,key_cols*key_rows  
7deb			;  
7deb			;.cin1:	ld a,(hl)  
7deb			;	cp '#'  
7deb			;	jr z, .cinhit  
7deb			;	inc hl  
7deb			;	inc de  
7deb			;	dec b  
7deb			;	jr nz, .cin1  
7deb			;	; no key found held  
7deb			;	ld a,0  
7deb			;	ret  
7deb			;.cinhit: push de  
7deb			;	pop hl  
7deb			;	ld a,(hl)  
7deb			;	ret  
7deb			  
7deb			; flag a control key is held   
7deb			; hl is key pin, de is flag indicator  
7deb			  
7deb			;.key_shift_hold:  
7deb			;	push bc  
7deb			;	ld a, 1  
7deb			;	ld (cursor_shape),a  
7deb			;	ld b, 0  
7deb			;	ld a, (hl)  
7deb			;	cp '.'  
7deb			;	jr z, .key_shift1  
7deb			;	ld b, 255  
7deb			;	ld a, '+'    ; hide key from later scans  
7deb			;	ld (hl),a  
7deb			;	ld a, 2  
7deb			;	ld (cursor_shape),a  
7deb			;.key_shift1:  
7deb			;	; write flag indicator  
7deb			;	ld a,b  
7deb			;	ld (de),a  
7deb			;  
7deb			;	pop de    ; de now holds the key map ptr  
7deb			;	ret  
7deb			  
7deb				  
7deb				  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			;	push hl  
7deb			;	push de  
7deb			;	push bc  
7deb			;	call keyscan  
7deb			;	; map key matrix to ascii value of key face  
7deb			;  
7deb			;	ld hl, key_face_map  
7deb			;	ld de, keyscan_table  
7deb			;  
7deb			;	; get how many keys to look at  
7deb			;	ld b, keyscan_table_len  
7deb			;	  
7deb			;  
7deb			;	; at this stage fall out on first key hit  
7deb			;	; TODO handle multiple key press  
7deb			;  
7deb			;map1:	ld a,(hl)  
7deb			;	cp '#'  
7deb			;	jr z, keyhit  
7deb			;	inc hl  
7deb			;	inc de  
7deb			;	dec b  
7deb			;	jr nz, map1  
7deb			;nohit:	ld a, 0  
7deb			;	jr keydone  
7deb			;keyhit: push de  
7deb			;	pop hl  
7deb			;	ld a,(hl)  
7deb			;keydone:  
7deb			;	push bc  
7deb			;	push de  
7deb			; 	push hl  
7deb			;	ret   
7deb			;  
7deb			  
7deb			  
7deb			  
7deb			  
7deb			; scan physical key matrix  
7deb			  
7deb			  
7deb			;keyscan:  
7deb			;  
7deb			;; for each key_row use keyscanr bit mask for out  
7deb			;; then read in for keyscanc bitmask  
7deb			;; save result of row scan to keyscantable  
7deb			;  
7deb			;; scan keyboard row 1  
7deb			;  
7deb			;	ld b, key_rows  
7deb			;	ld hl, key_scanr  
7deb			;	ld de, keyscan_table  
7deb			;  
7deb			;rowloop:  
7deb			;  
7deb			;	ld a,(hl)		; out bit mask to energise keyboard row  
7deb			;	call rowscan  
7deb			;	inc hl  
7deb			;	dec b  
7deb			;	jr nz, rowloop  
7deb			;  
7deb			;	ret  
7deb			;  
7deb			;  
7deb			;; pass a out bitmask, b row number  
7deb			;arowscan:   
7deb			;	push bc  
7deb			;  
7deb			;	ld d, b  
7deb			;  
7deb			;	; calculate buffer location for this row  
7deb			;  
7deb			;	ld hl, keyscan_table	  
7deb			;kbufr:  ld e, key_cols  
7deb			;kbufc:	inc hl  
7deb			;	dec e  
7deb			;	jr nz, kbufc  
7deb			;	dec d  
7deb			;	jr nz, kbufr  
7deb			;  
7deb			;	; energise row and read columns  
7deb			;  
7deb			;	out (portbdata),a  
7deb			;	in a,(portbdata)  
7deb			;	ld c,a  
7deb			;  
7deb			;  
7deb			;	; save buffer loc  
7deb			;  
7deb			;	ld (keybufptr), hl  
7deb			;  
7deb			;	ld hl, key_scanc  
7deb			;	ld d, key_cols  
7deb			;  
7deb			;	; for each column check each bit mask  
7deb			;  
7deb			;colloop:  
7deb			;	  
7deb			;  
7deb			;	; reset flags for the row   
7deb			;  
7deb			;	ld b,'.'  
7deb			;	and (hl)  
7deb			;	jr z, maskskip  
7deb			;	ld b,'#'  
7deb			;maskskip:  
7deb			;	; save  key state  
7deb			;	push hl  
7deb			;	ld hl, (keybufptr)  
7deb			;	ld (hl), b  
7deb			;	inc hl  
7deb			;	ld (keybufptr), hl  
7deb			;  
7deb			;	; move to next bit mask  
7deb			;	pop hl  
7deb			;	inc hl  
7deb			;  
7deb			;	dec d  
7deb			;	jr nz, colloop  
7deb			;  
7deb			;	ret  
7deb			;  
7deb			;  
7deb			;;  
7deb			; lcd functions  
7deb			;  
7deb			;  
7deb			  
7deb			;if DEBUG_KEY_MATRIX  
7deb			  
7deb			; test function to display hardware view of matrix state  
7deb			  
7deb			matrixold:  
7deb			  
7deb			  
7deb			  
7deb			; reset counter  
7deb 3e 80		ld a, 128  
7ded d3 c1		out (portbdata),a  
7def			; scan keyboard row 1  
7def 3e 00		ld a, 0  
7df1 d3 c1		out (portbdata),a  
7df3			;ld a, 64  
7df3			;out (portbdata),a  
7df3 3e 80			ld a, 128  
7df5 21 30 fe			ld hl, keyscan_table_row1  
7df8 cd 51 7e			call .rowscan  
7dfb			  
7dfb			;ld a, 0  
7dfb			;out (portbdata),a  
7dfb 3e 40		ld a, 64  
7dfd d3 c1		out (portbdata),a  
7dff 3e 40			ld a, 64  
7e01 21 25 fe			ld hl, keyscan_table_row2  
7e04 cd 51 7e			call .rowscan  
7e07			  
7e07 3e 00		ld a, 0  
7e09 d3 c1		out (portbdata),a  
7e0b			;ld a, 64  
7e0b			;out (portbdata),a  
7e0b 3e 20			ld a, 32  
7e0d 21 1a fe			ld hl, keyscan_table_row3  
7e10 cd 51 7e			call .rowscan  
7e13			  
7e13			;ld a, 0  
7e13			;out (portbdata),a  
7e13 3e 40		ld a, 64  
7e15 d3 c1		out (portbdata),a  
7e17 3e 10			ld a, 16  
7e19 21 0f fe			ld hl, keyscan_table_row4  
7e1c cd 51 7e			call .rowscan  
7e1f			  
7e1f			; Display text on first line  
7e1f 3e 00		            LD   A, kLCD_Line1  
7e21 cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7e24 11 30 fe		            LD   DE, keyscan_table_row1  
7e27			            ;LD   DE, MsgHello  
7e27 cd 7b 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7e2a			  
7e2a			; Display text on second line  
7e2a 3e 28		            LD   A, kLCD_Line2  
7e2c cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7e2f 11 25 fe		            LD   DE, keyscan_table_row2  
7e32 cd 7b 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7e35 3e 50		            LD   A, kLCD_Line3  
7e37 cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7e3a 11 1a fe		            LD   DE, keyscan_table_row3  
7e3d cd 7b 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7e40 3e 78		            LD   A, kLCD_Line4  
7e42 cd 59 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7e45 11 0f fe		            LD   DE, keyscan_table_row4  
7e48 cd 7b 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7e4b			  
7e4b cd d2 0c			call delay250ms  
7e4e c3 3c 7d			jp matrix  
7e51			  
7e51			; pass de as row display flags  
7e51			.rowscan:   
7e51			;	out (portbdata),a  
7e51 db c1			in a,(portbdata)  
7e53 4f				ld c,a  
7e54				; reset flags for the row   
7e54 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7e56 e6 01			and 1  
7e58 28 02			jr z, .p1on  
7e5a 06 23			ld b,'#'  
7e5c			.p1on:  
7e5c 70				ld (hl), b  
7e5d 23				inc hl  
7e5e			  
7e5e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7e60 79				ld a,c  
7e61 e6 02			and 2  
7e63			;	bit 0,a  
7e63 28 02			jr z, .p2on  
7e65 06 23			ld b,'#'  
7e67			.p2on:  
7e67 70				ld (hl), b  
7e68 23				inc hl  
7e69			;  
7e69 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7e6b 79				ld a,c  
7e6c e6 04			and 4  
7e6e			;;	bit 0,a  
7e6e 28 02			jr z, .p3on  
7e70 06 23			ld b,'#'  
7e72			.p3on:  
7e72 70				ld (hl), b  
7e73 23				inc hl  
7e74			;;  
7e74 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7e76			;;	bit 0,a  
7e76 79				ld a,c  
7e77 e6 08			and 8  
7e79 28 02			jr z, .p4on  
7e7b 06 23			ld b,'#'  
7e7d			.p4on:  
7e7d 70				ld (hl), b  
7e7e 23				inc hl  
7e7f			  
7e7f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7e81			;;	bit 0,a  
7e81 79				ld a,c  
7e82 e6 10			and 16  
7e84 28 02			jr z, .p5on  
7e86 06 23			ld b,'#'  
7e88			.p5on:  
7e88 70				ld (hl), b  
7e89 23				inc hl  
7e8a			; zero term  
7e8a 06 00			ld b,0  
7e8c 70				ld (hl), b  
7e8d			  
7e8d c9			.rscandone: ret  
7e8e			  
7e8e			;addatohl:  
7e8e			;  
7e8e			 ;add   a, l    ; A = A+L  
7e8e			  ;  ld    l, a    ; L = A+L  
7e8e			   ; adc   a, h    ; A = A+L+H+carry  
7e8e			   ; sub   l       ; A = H+carry  
7e8e			   ; ld    h, a    ; H = H+carry  
7e8e			  
7e8e			;ret  
7e8e			; eof  
# End of file firmware_key_5x10.asm
7e8e			;include "firmware_key_4x10.asm" 
7e8e			 
7e8e			heap_size:    equ heap_end - heap_start 
7e8e			;eof 
# End of file os_mega.asm
7e8e
