# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5b 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c			;	call break_point_state  
011c			; now use the break point debug vector  
011c				call debug_vector  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_vector:  equ hardware_word - 3   ; vector to the debug handler  
011c			  
011c			debug_mark: equ debug_vector - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			;os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_new_exec_ptr - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c			;	ld a, ' ' 
011c			;	ld (os_view_disable), a 
011c				call bp_on 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 13 ed				ld hl, display_fb1  
011f 22 cf eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 d1 eb				ld hl, display_fb2  
0128 22 cf eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b4 ed				ld hl, display_fb0  
0131 22 cf eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd 9e 63				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 8c 64			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 b9 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 ce 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 6e ee		ld (debug_mark),a  
0191 32 6f ee		ld (debug_mark+1),a  
0194 32 70 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 71 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 76 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 6e ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 6f ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 70 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd 72 ee			call debug_vector  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 7d ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 6e ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 6f ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 70 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd 72 ee			call debug_vector  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 7d ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 6e ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 6f ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 70 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd 72 ee			call debug_vector  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 76 ea				ld hl, (store_tmp1) 
0210 11 80 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 6e ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 6f ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 70 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd 72 ee			call debug_vector  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 6e ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 6f ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 70 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd 72 ee			call debug_vector  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 6e ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 6f ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 70 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd 72 ee			call debug_vector  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 6e ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 6f ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 70 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd 72 ee			call debug_vector  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 6e ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 6f ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 70 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd 72 ee			call debug_vector  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 7d ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 7f ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 6e ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 6f ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 70 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd 72 ee			call debug_vector  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 6e ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 6f ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 70 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd 72 ee			call debug_vector  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 7d ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 6e ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 6f ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 70 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 7d ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd 72 ee			call debug_vector  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 7e ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 6e ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 6f ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 70 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd 72 ee			call debug_vector  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 6e ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 6f ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 70 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd 72 ee			call debug_vector  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 7d ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 7e ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 80 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 89 ea			ld hl, store_page+3+9 
03b5 3a 62 ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 7d ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 6e ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 6f ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 70 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd 72 ee			call debug_vector  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 6e ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 6f ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 70 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd 72 ee			call debug_vector  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 6e ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 6f ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 70 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd 72 ee			call debug_vector  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 80 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 6e ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 6f ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 70 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd 72 ee			call debug_vector  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 7d ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 6e ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 6f ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 70 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd 72 ee			call debug_vector  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 6e ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 6f ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 70 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd 72 ee			call debug_vector  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 7d ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 6e ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 6f ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 70 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd 72 ee			call debug_vector  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 7d ea			ld a, (store_page)	; get file id 
0510 32 71 ea			ld (store_tmpid), a 
0513			 
0513 3a 7f ea			ld a, (store_page+2)    ; get count of extends 
0516 32 70 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 7d ea			ld (store_page), a 
051f 32 7e ea			ld (store_page+1),a 
0522 11 7d ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 6e ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 6f ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 70 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd 72 ee			call debug_vector  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 70 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 71 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 6e ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 6f ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 70 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd 72 ee			call debug_vector  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 7d ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 7d ea			ld (store_page), a 
0582 32 7e ea			ld (store_page+1),a 
0585 11 7d ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 6e ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 6f ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 70 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd 72 ee			call debug_vector  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 6e ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 6f ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 70 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd 72 ee			call debug_vector  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 6e ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 6f ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 70 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd 72 ee			call debug_vector  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 6e ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 6f ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 70 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd 72 ee			call debug_vector  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 6e ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 6f ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 70 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd 72 ee			call debug_vector  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 7d ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 7d ea			ld (store_page),a 
06a3				 
06a3 32 71 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 7d ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6e ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6f ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 70 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd 72 ee			call debug_vector  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 7d ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 6e ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 6f ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 70 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 72 ee			call debug_vector  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 68 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 6e ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 6f ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 70 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd 72 ee			call debug_vector  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 68 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 71 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 7d ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 7e ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 7f ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 80 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 6e ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 6f ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 70 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd 72 ee			call debug_vector  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 6e ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 6f ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 70 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd 72 ee			call debug_vector  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 6e ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 6f ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 70 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 72 ee			call debug_vector  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 68 ea			ld hl,(store_tmppageid) 
078b 11 7d ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 6e ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 6f ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 70 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd 72 ee			call debug_vector  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 71 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 6e ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 6f ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 70 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 72 ee			call debug_vector  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 7b ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 79 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 6e ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 6f ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 70 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd 72 ee			call debug_vector  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 6e ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 6f ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 70 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd 72 ee			call debug_vector  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 6e ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 79 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 6e ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 6f ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 70 ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd 72 ee			call debug_vector  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 79 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 70 ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 6e ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 6f ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 70 ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd 72 ee			call debug_vector  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 78 ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 79 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 6e ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 6f ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 70 ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd 72 ee			call debug_vector  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 79 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 7b ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 7b ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 6e ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 6f ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 70 ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd 72 ee			call debug_vector  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 6e ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 6f ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 70 ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd 72 ee			call debug_vector  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 6e ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 79 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 79 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 6e ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 6f ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 70 ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 72 ee			call debug_vector  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 6e ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 6f ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 70 ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd 72 ee			call debug_vector  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 6e ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 6f ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 70 ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd 72 ee			call debug_vector  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 6e ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 6f ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 70 ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd 72 ee			call debug_vector  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 71 ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 71 ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 68 ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 6e ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 6f ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 70 ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd 72 ee			call debug_vector  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 7d ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 6e ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 6f ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 70 ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd 72 ee			call debug_vector  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 7f ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 7f ea			ld (store_page+2), a 
09e3 32 70 ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 6e ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 6f ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 70 ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd 72 ee			call debug_vector  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 68 ea			ld hl, (store_tmppageid) 
0a05 11 7d ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 68 ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 6e ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 6f ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 70 ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd 72 ee			call debug_vector  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 7d ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 71 ea				ld a, (store_tmpid) 
0a4b 32 7d ea				ld (store_page), a   ; file id 
0a4e 3a 70 ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 7e ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 7f ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 6e ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 6f ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 70 ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd 72 ee			call debug_vector  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 68 ea			ld hl, (store_tmppageid) 
0a85 11 7d ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 6e ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 6f ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 70 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 72 ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 71 ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 7d ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 7e ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a c9 eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 c9 eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd 83 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 ca eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 ca eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a cf eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b4 ed				ld hl, display_fb0 
0b53 22 cf eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd cc 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 13 ed				ld hl, display_fb1 
0b74 22 cf eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a cf eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a cf eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a cf eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a cf eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a cf eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a cf eb			ld hl, (display_fb_active) 
0be1 cd db 63			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 76 ea				ld (store_tmp1), hl 
0bee 32 74 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b4 ed				ld hl, display_fb0 
0bf4 22 cf eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 72 ea				ld (store_tmp3), a   ; display row count 
0c02 3a 74 ea				ld a,( store_tmp2) 
0c05 32 75 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 75 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 76 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 72 ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 75 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 75 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 72 ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 72 ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 74 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 8d 64				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 74 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 74 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 74 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 74 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 74 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 13 ed				ld hl, display_fb1 
0cb1 22 cf eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a ae eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 ae eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b4 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b6 eb		        ld hl,LFSRSeed+6 
0d04 11 b7 eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a a8 eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 a8 eb		    ld (seed1),hl 
0d1a 2a a6 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a6 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a ac eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 ac eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 67 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 65 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 6a ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 6c ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 69 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 58 ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 68 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c4 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 63 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 62 ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 63 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 63 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 62 ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 62 ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 63 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 6c ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 6a ee			ld de, (input_start) 
0e69 3a 67 ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 62 ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 65 ee				ld a,(input_at_cursor) 
0e79 11 c4 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 6a ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 5d ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd 95 64				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 6a ee				ld hl, (input_start) 
0e98 3a 58 ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 6c ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 67 ee				ld a, (input_at_pos) 
0ea9 32 65 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 58 ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 6c ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 6c ee				ld (input_ptr), hl 
0ed1 3a 65 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 65 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 6c ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 6c ee				ld (input_ptr), hl 
0ef0 3a 65 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 65 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 58 ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 58 ee				ld (input_cursor), a 
0f09			 
0f09 2a 6c ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 6c ee				ld (input_ptr), hl 
0f10					 
0f10 3a 65 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 65 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 62 ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 63 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 5d ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 58 ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 58 ee				ld (input_cursor), a 
0f37			 
0f37 3a 65 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 65 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 6c ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 6c ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 62 ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 63 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 6a ee				ld hl, (input_start) 
0f59 22 6c ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 67 ee				ld a, (input_at_pos) 
0f5f 32 65 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 58 ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 eb e5				ld hl, os_cli_cmd 
0f6a 11 ea e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 58 ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 58 ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 6c ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 6c ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 5d ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 65 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 65 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 62 ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 63 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 65 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 58 ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 58 ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 65 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 65 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 6c ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 6c ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 6c ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 6c ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 62 ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 63 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 6a ee				ld hl, (input_start) 
0ffa 3a 5d ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 58 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 5d ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 58 ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 58 ee				ld (input_cursor), a 
1022			 
1022 3a 65 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 65 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 6a ee				ld hl, (input_start) 
102f 3a 5d ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 67 ee		input_str_prev:	ld (input_at_pos), a 
1042 22 6a ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 6c ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 69 ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 58 ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 6c ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c4 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 67 ee				ld a,(input_at_pos) 
1063 cd aa 63		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 6a ee	            	LD   de, (input_start) 
106a cd 9f 63		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd 95 64				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 6c ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c4 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 6c ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 6c ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 6c ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 6c ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 6c ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c4 e2			ld hl, scratch 
10bd 11 ea e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c4 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 6c ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 43 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 f8 e2			ld (scratch+52),a 
11be				 
11be 21 f6 e2			ld hl,scratch+50 
11c1 22 e7 e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				call bp_on 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 bd 64		      ld    HL, heap_start 
128e 22 b8 64		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 ba 64		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 a7 e2		      ld    HL, heap_start+heap_size-4 
129a 22 bd 64		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 ea 7d		      ld    HL, heap_size-4 
12a0 22 bf 64		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 a9 e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 a7 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 b8 64		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 b8 64		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			if SOUND_ENABLE  
1447				include "firmware_sound.asm"  
1447			endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 6d 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452			;	cp 1 
1452			;	call z, .savetostore 
1452			 
1452 fe 01			cp 1 
1454			if STARTUP_V1 
1454 cc 83 14			call z, .selautoload 
1457			endif 
1457			 
1457			if STARTUP_V2 
1457				call z, .enautoload 
1457			endif 
1457 fe 02			cp 2 
1459 cc 79 14			call z, .disautoload 
145c			;	cp 3 
145c			;	call z, .selbank 
145c fe 03			cp 3 
145e cc a1 14			call z, .debug_tog 
1461 fe 04			cp 4 
1463 cc ef 15			call z, .bpsgo 
1466 fe 05			cp 5 
1468 cc ca 14			call z, hardware_diags 
146b			if STARTUP_V2 
146b				cp 6 
146b				call z, create_startup 
146b			endif 
146b 18 da			jr config 
146d			 
146d			.configmn: 
146d			;	dw prom_c3 
146d de 17			dw prom_c2 
146f f3 17			dw prom_c2a 
1471			;	dw prom_c2b 
1471			;	dw prom_c4 
1471 12 18			dw prom_m4 
1473 2d 18			dw prom_m4b 
1475 35 18			dw prom_c1 
1477			if STARTUP_V2 
1477				dw prom_c9 
1477			endif 
1477 00 00			dw 0 
1479				 
1479			 
1479			if STARTUP_V2 
1479			.enautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 1 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479				ld hl, prom_notav 
1479				ld de, prom_empty 
1479				call info_panel 
1479				endif 
1479			 
1479			 
1479				ret 
1479			endif 
1479			 
1479			.disautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 0 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479 21 44 18			ld hl, prom_notav 
147c 11 5a 18			ld de, prom_empty 
147f cd 4b 0b			call info_panel 
1482				endif 
1482			 
1482			 
1482 c9				ret 
1483			 
1483			if STARTUP_V1 
1483			 
1483			; Select auto start 
1483			 
1483			.selautoload: 
1483			 
1483				 
1483				if STORAGE_SE 
1483			 
1483					call config_dir 
1483				        ld hl, scratch 
1483					ld a, 0 
1483					call menu 
1483			 
1483					cp 0 
1483					ret z 
1483			 
1483					dec a 
1483			 
1483			 
1483					; locate menu option 
1483			 
1483					ld hl, scratch 
1483					call table_lookup 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALl" 
1483						CALLMONITOR 
1483					endif 
1483					; with the pointer to the menu it, the byte following the zero term is the file id 
1483			 
1483					ld a, 0 
1483					ld bc, 50   ; max of bytes to look at 
1483					cpir  
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALb" 
1483						CALLMONITOR 
1483					endif 
1483					;inc hl 
1483			 
1483					ld a, (hl)   ; file id 
1483					 
1483				        ; save bank and file ids 
1483			 
1483					push af 
1483			 
1483			; TODO need to save to block 0 on bank 1	 
1483			 
1483					call storage_get_block_0 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "AL0" 
1483						CALLMONITOR 
1483					endif 
1483					pop af 
1483			 
1483					ld (store_page+STORE_0_FILERUN),a 
1483					 
1483					; save bank id 
1483			 
1483					ld a,(spi_device) 
1483					ld (store_page+STORE_0_BANKRUN),a 
1483			 
1483					; enable auto run of store file 
1483			 
1483					ld a, 1 
1483					ld (store_page+STORE_0_AUTOFILE),a 
1483			 
1483					; save buffer 
1483			 
1483					ld hl, 0 
1483					ld de, store_page 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALw" 
1483						CALLMONITOR 
1483					endif 
1483				call storage_write_block	 ; save update 
1483			  
1483			 
1483			 
1483			 
1483					ld hl, scratch 
1483					call config_fdir 
1483			 
1483				else 
1483			 
1483 21 44 18			ld hl, prom_notav 
1486 11 5a 18			ld de, prom_empty 
1489 cd 4b 0b			call info_panel 
148c			 
148c				endif 
148c c9				ret 
148d			endif 
148d			 
148d			 
148d			; Select storage bank 
148d			 
148d			.selbank: 
148d			 
148d			;	if STORAGE_SE 
148d			;	else 
148d			 
148d 21 44 18			ld hl, prom_notav 
1490 11 5a 18			ld de, prom_empty 
1493 cd 4b 0b			call info_panel 
1496			;	endif 
1496				 
1496 c9				ret 
1497			 
1497			if STORAGE_SE 
1497			 
1497			.config_ldir:   
1497				; Load storage bank labels into menu array 
1497			 
1497				 
1497			 
1497			 
1497				ret 
1497			 
1497			 
1497			endif 
1497			 
1497			 
1497			; Save user words to storage 
1497			 
1497			.savetostore: 
1497			 
1497			;	if STORAGE_SE 
1497			; 
1497			;		call config_dir 
1497			;	        ld hl, scratch 
1497			;		ld a, 0 
1497			;		call menu 
1497			;		 
1497			;		ld hl, scratch 
1497			;		call config_fdir 
1497			; 
1497			;	else 
1497			 
1497 21 44 18			ld hl, prom_notav 
149a 11 5a 18			ld de, prom_empty 
149d cd 4b 0b			call info_panel 
14a0			 
14a0			;	endif 
14a0			 
14a0 c9				ret 
14a1			 
14a1			if STARTUP_V2 
14a1			 
14a1			create_startup: 
14a1			 
14a1				ld a, 0 
14a1				ld hl, .crstart 
14a1				call menu 
14a1			 
14a1				cp 0 
14a1				ret z 
14a1			 
14a1				cp 1 
14a1				call z, .genlsword 
14a1				cp 2 
14a1				call z, .genedword 
14a1			 
14a1				cp 3 
14a1				call z, .gendemword 
14a1			 
14a1				cp 4 
14a1				call z, .genutlword 
14a1				cp 5 
14a1				call z, .genspiword 
14a1				cp 6 
14a1				call z, .genkeyword 
14a1				jr create_startup 
14a1			 
14a1			.genlsword: 
14a1				ld hl, crs_s1 
14a1				ld de, .lsworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genedword: 
14a1				ld de, .edworddef 
14a1				ld hl, crs_s2 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.gendemword: 
14a1				ld de, .demoworddef 
14a1				ld hl, crs_s3 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genutlword: 
14a1				ld hl, crs_s4 
14a1				ld de, .utilwordef 
14a1				call .genfile 
14a1				ret 
14a1			.genspiword: 
14a1				ld hl, crs_s5 
14a1				ld de, .spiworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genkeyword: 
14a1				ld hl, crs_s6 
14a1				ld de, .keyworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			; hl - points to file name 
14a1			; de - points to strings to add to file 
14a1			 
14a1			.genfile: 
14a1				push hl 
14a1				push de 
14a1			 
14a1				call clear_display 
14a1				ld a, display_row_1 
14a1				ld de, .genfiletxt 
14a1				call str_at_display 
14a1				call update_display 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1			 
14a1				push de 
14a1				call storage_create 
14a1				; id in hl 
14a1				pop de   ; table of strings to add 
14a1			 
14a1			.genloop: 
14a1			 
14a1				push hl ; save id for next time around 
14a1				push de ; save de for next time around 
14a1			 
14a1				ex de, hl 
14a1				call loadwordinhl 
14a1				ex de, hl 
14a1			 
14a1				; need hl to be the id 
14a1				; need de to be the string ptr 
14a1				 
14a1				call storage_append 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1				inc de 
14a1				inc de 
14a1			 
14a1				ld a,(de) 
14a1				cp 0 
14a1				jr nz, .genloop 
14a1				inc de 
14a1				ld a, (de) 
14a1				dec de 
14a1				cp 0 
14a1				jr nz, .genloop	 
14a1			 
14a1				ret 
14a1			 
14a1			.genfiletxt:  db "Creating file...",0 
14a1			 
14a1			.utilwordef: 
14a1				dw strncpy 
14a1				dw type 
14a1				dw clrstack 
14a1				dw longread 
14a1				dw start1 
14a1				dw start2 
14a1				dw start3b 
14a1				dw start3c 
14a1				dw list 
14a1				dw 0 
14a1			 
14a1			.lsworddef: 
14a1				dw start3b 
14a1				dw 0 
14a1			 
14a1			.edworddef: 
14a1				dw edit1 
14a1				dw edit2 
14a1				dw edit3 
14a1				dw 0 
14a1			 
14a1			.demoworddef: 
14a1				dw test5 
14a1				dw test6 
14a1				dw test7 
14a1				dw test8 
14a1				dw test9 
14a1				dw test10 
14a1				dw game1 
14a1				dw game1a 
14a1				dw game1b 
14a1				dw game1c 
14a1				dw game1d 
14a1				dw game1s 
14a1				dw game1t 
14a1				dw game1f 
14a1				dw game1z 
14a1				dw game1zz 
14a1				dw ssv2 
14a1				dw ssv3 
14a1				dw ssv4 
14a1				dw ssv5 
14a1				dw ssv1 
14a1				dw ssv1cpm	 
14a1				dw game2b 
14a1				dw game2bf 
14a1				dw game2mba 
14a1				dw game2mbas	 
14a1				dw game2mbht 
14a1				dw game2mbms 
14a1				dw game2mb 
14a1				dw game3w 
14a1				dw game3p 
14a1				dw game3sc 
14a1				dw game3vsi 
14a1				dw game3vs 
14a1				dw 0 
14a1			 
14a1			 
14a1			.spiworddef: 
14a1			 
14a1			    dw spi1 
14a1			    dw spi2 
14a1			    dw spi3 
14a1			    dw spi4 
14a1			    dw spi5 
14a1			    dw spi6 
14a1			    dw spi7 
14a1			 
14a1			    dw spi8 
14a1			    dw spi9 
14a1			    dw spi10 
14a1			    dw 0 
14a1			 
14a1			.keyworddef: 
14a1			 
14a1				dw keyup 
14a1				dw keydown 
14a1				dw keyleft 
14a1				dw keyright 
14a1				dw 	keyf1 
14a1				dw keyf2 
14a1				dw keyf3 
14a1				dw keyf4 
14a1				dw keyf5 
14a1				dw keyf6 
14a1				dw keyf7 
14a1				dw keyf8 
14a1				dw keyf9 
14a1				dw keyf10 
14a1				dw keyf11 
14a1				dw keyf12 
14a1				dw keytab 
14a1				dw keycr 
14a1				dw keyhome 
14a1				dw keyend 
14a1				dw keybs 
14a1				dw 0 
14a1			 
14a1			.crstart: 
14a1				dw crs_s1 
14a1				dw crs_s2 
14a1				dw crs_s3 
14a1				dw crs_s4 
14a1				dw crs_s5 
14a1				dw crs_s6 
14a1				dw 0 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			if STORAGE_SE 
14a1			 
14a1			config_fdir: 
14a1				; using the scratch dir go through and release the memory allocated for each string 
14a1				 
14a1				ld hl, scratch 
14a1			.cfdir:	ld e,(hl) 
14a1				inc hl 
14a1				ld d,(hl) 
14a1				inc hl 
14a1			 
14a1				ex de, hl 
14a1				call ishlzero 
14a1				ret z     ; return on null pointer 
14a1				call free 
14a1				ex de, hl 
14a1				jr .cfdir 
14a1			 
14a1			 
14a1				ret 
14a1			 
14a1			 
14a1			config_dir: 
14a1			 
14a1				; for the config menus that need to build a directory of storage call this routine 
14a1				; it will construct a menu in scratch to pass to menu 
14a1			 
14a1				; open storage device 
14a1			 
14a1				; execute DIR to build a list of files and their ids into scratch in menu format 
14a1				; once the menu has finished then will need to call config_fdir to release the strings 
14a1				 
14a1				; c = number items 
14a1			 
14a1				 
14a1				call storage_get_block_0 
14a1			 
14a1				ld hl, store_page     ; get current id count 
14a1				ld b, (hl) 
14a1				ld c, 0    ; count of files   
14a1			 
14a1			 
14a1				ld hl, scratch 
14a1				ld (store_tmp2), hl    ; location to poke strings 
14a1			 
14a1				; check for empty drive 
14a1			 
14a1				ld a, 0 
14a1				cp b 
14a1				jp z, .dirdone 
14a1			 
14a1				 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdc" 
14a1						CALLMONITOR 
14a1					endif 
14a1			 
14a1			 
14a1			.diritem:	 
14a1				push bc 
14a1				; for each of the current ids do a search for them and if found push to stack 
14a1			 
14a1					ld hl, STORE_BLOCK_PHY 
14a1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a1					ld e,b 
14a1			 
14a1					call storage_findnextid 
14a1			 
14a1			 
14a1					; if found hl will be non zero 
14a1			 
14a1					call ishlzero 
14a1					jr z, .dirnotfound 
14a1			 
14a1					; increase count 
14a1			 
14a1					pop bc	 
14a1					inc c 
14a1					push bc 
14a1					 
14a1			 
14a1					; get file header and push the file name 
14a1			 
14a1					ld de, store_page 
14a1					call storage_read_block 
14a1			 
14a1					; push file id to stack 
14a1				 
14a1					ld a, (store_page) 
14a1					ld h, 0 
14a1					ld l, a 
14a1			 
14a1					;call forth_push_numhl 
14a1					; TODO store id 
14a1			 
14a1					push hl 
14a1			 
14a1					; push extent count to stack  
14a1				 
14a1					ld hl, store_page+3 
14a1			 
14a1					; get file name length 
14a1			 
14a1					call strlenz   
14a1			 
14a1					inc hl   ; cover zero term 
14a1					inc hl  ; stick the id at the end of the area 
14a1			 
14a1					push hl 
14a1					pop bc    ; move length to bc 
14a1			 
14a1					call malloc 
14a1			 
14a1					; TODO save malloc area to scratch 
14a1			 
14a1					ex de, hl 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), e 
14a1					inc hl 
14a1					ld (hl), d 
14a1					inc hl 
14a1					ld (store_tmp2), hl 
14a1			 
14a1					 
14a1			 
14a1					;pop hl   ; get source 
14a1			;		ex de, hl    ; swap aronund	 
14a1			 
14a1					ld hl, store_page+3 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "CFd" 
14a1						CALLMONITOR 
14a1					endif 
14a1					ldir 
14a1			 
14a1					; de is past string, move back one and store id 
14a1					 
14a1					dec de 
14a1			 
14a1					; store file id 
14a1			 
14a1					pop hl 
14a1					ex de,hl 
14a1					ld (hl), e 
14a1			 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdi" 
14a1						CALLMONITOR 
14a1					endif 
14a1					 
14a1			.dirnotfound: 
14a1					pop bc     
14a1					djnz .diritem 
14a1				 
14a1			.dirdone:	 
14a1			 
14a1					ld a, 0 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), a 
14a1					inc hl 
14a1					ld (hl), a 
14a1					inc hl 
14a1					; push a count of the dir items found 
14a1			 
14a1			;		ld h, 0 
14a1			;		ld l, c 
14a1			 
14a1				ret 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			; Settings 
14a1			; Run  
14a1			 
14a1			 
14a1			 
14a1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14a1			;;hd_menu2:   db "        2: Editor",0   
14a1			;hd_menu2:   db "        2: Editor       6: Menu",0   
14a1			;hd_menu3:   db "        3: Storage",0 
14a1			;hd_menu4:   db "0=quit  4: Debug",0 
14a1			;hd_don:     db "ON",0 
14a1			;hd_doff:     db "OFF",0 
14a1			; 
14a1			; 
14a1			; 
14a1			;hardware_diags_old:       
14a1			; 
14a1			;.diagmenu: 
14a1			;	call clear_display 
14a1			;	ld a, display_row_1 
14a1			;	ld de, hd_menu1 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_2 
14a1			;	ld de, hd_menu2 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_3 
14a1			;	ld de, hd_menu3 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a,  display_row_4 
14a1			;	ld de, hd_menu4 
14a1			;	call str_at_display 
14a1			; 
14a1			;	; display debug state 
14a1			; 
14a1			;	ld de, hd_don 
14a1			;	ld a, (os_view_disable) 
14a1			;	cp 0 
14a1			;	jr z, .distog 
14a1			;	ld de, hd_doff 
14a1			;.distog: ld a, display_row_4+17 
14a1			;	call str_at_display 
14a1			; 
14a1			;	call update_display 
14a1			; 
14a1			;	call cin_wait 
14a1			; 
14a1			; 
14a1			; 
14a1			;	cp '4' 
14a1			;	jr nz, .diagn1 
14a1			; 
14a1			;	; debug toggle 
14a1			; 
14a1			;	ld a, (os_view_disable) 
14a1			;	ld b, '*' 
14a1			;	cp 0 
14a1			;	jr z, .debtog 
14a1			;	ld b, 0 
14a1			;.debtog:	 
14a1			;	ld a,b 
14a1			;	ld (os_view_disable),a 
14a1			; 
14a1			;.diagn1: cp '0' 
14a1			;	 ret z 
14a1			; 
14a1			;;	cp '1' 
14a1			;;       jp z, matrix	 
14a1			;;   TODO keyboard matrix test 
14a1			; 
14a1			;	cp '2' 
14a1			;	jp z, .diagedit 
14a1			; 
14a1			;;	cp '6' 
14a1			;;	jp z, .menutest 
14a1			;;if ENABLE_BASIC 
14a1			;;	cp '6' 
14a1			;;	jp z, basic 
14a1			;;endif 
14a1			 ; 
14a1			;	jp .diagmenu 
14a1			; 
14a1			; 
14a1			;	ret 
14a1			 
14a1			 
14a1			.debug_tog: 
14a1 21 eb 14			ld hl, .menudebug 
14a4				 
14a4			;	ld a, (os_view_disable) 
14a4			;	cp '*' 
14a4 3a 72 ee			ld a,(debug_vector) 
14a7 fe c9			cp $C9   ; RET 
14a9 20 04			jr nz,.tdon  
14ab 3e 01			ld a, 1 
14ad 18 02			jr .tog1 
14af 3e 00		.tdon: ld a, 0 
14b1			 
14b1			.tog1: 
14b1 cd eb 0b			call menu 
14b4 fe 00			cp 0 
14b6 c8				ret z 
14b7 fe 01			cp 1    ; disable debug 
14b9 28 04			jr z, .dtog0 
14bb 3e 2a			ld a, '*' 
14bd 18 05			jr .dtogset 
14bf			.dtog0:  
14bf				;ld a, 0 
14bf cd dd 15			call bp_on 
14c2 18 dd			jr .debug_tog 
14c4			.dtogset:  
14c4				; ld (os_view_disable), a 
14c4 cd e9 15			call bp_off 
14c7 c3 a1 14			jp .debug_tog 
14ca			 
14ca			 
14ca			hardware_diags:       
14ca			 
14ca			.diagm: 
14ca 21 dd 14			ld hl, .menuitems 
14cd 3e 00			ld a, 0 
14cf cd eb 0b			call menu 
14d2			 
14d2 fe 00		         cp 0 
14d4 c8				 ret z 
14d5			 
14d5 fe 02			cp 2 
14d7 ca 36 15			jp z, .diagedit 
14da			 
14da			;	cp '6' 
14da			;	jp z, .menutest 
14da			;if ENABLE_BASIC 
14da			;	cp '6' 
14da			;	jp z, basic 
14da			;endif 
14da			  
14da c3 ca 14			jp .diagm 
14dd			 
14dd				 
14dd f1 14		.menuitems:   	dw .m1 
14df fc 14				dw .m2 
14e1 03 15				dw .m3 
14e3 0b 15				dw .m5 
14e5 11 15				dw .m5a 
14e7 1a 15				dw .m5b 
14e9 00 00				dw 0 
14eb			 
14eb			.menudebug: 
14eb 23 15				dw .m6 
14ed 2c 15				dw .m7 
14ef 00 00				dw 0 
14f1			 
14f1 .. 00		.m1:   db "Key Matrix",0 
14fc .. 00		.m2:   db "Editor",0 
1503 .. 00		.m3:   db "Storage",0 
150b .. 00		.m5:   db "Sound",0 
1511 .. 00		.m5a:  db "RAM Test",0 
151a .. 00		.m5b:  db "LCD Test",0 
1523			 
1523 .. 00		.m6:   db "Debug ON",0 
152c .. 00		.m7:   db "Debug OFF",0 
1536			 
1536			; debug editor 
1536			 
1536			.diagedit: 
1536			 
1536 21 c4 e2			ld hl, scratch 
1539			;	ld bc, 250 
1539			;	ldir 
1539				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1539 3e 00			ld a, 0 
153b 77				ld (hl), a 
153c 23				inc hl 
153d 77				ld (hl), a 
153e 23				inc hl 
153f 77				ld (hl), a 
1540			 
1540 cd ba 0b		        call clear_display 
1543 cd dd 0b			call update_display 
1546				;ld a, 1 
1546				;ld (hardware_diag), a 
1546			.diloop: 
1546 3e 00			ld a, display_row_1 
1548 0e 00			ld c, 0 
154a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
154c 1e 28			ld e, 40 
154e			 
154e 21 c4 e2			ld hl, scratch	 
1551 cd 14 0e			call input_str 
1554			 
1554 3e 28			ld a, display_row_2 
1556 11 c4 e2			ld de, scratch 
1559 cd cd 0b			call str_at_display 
155c cd dd 0b			call update_display 
155f			 
155f c3 46 15			jp .diloop 
1562			 
1562			 
1562			; pass word in hl 
1562			; a has display location 
1562			display_word_at: 
1562 f5				push af 
1563 e5				push hl 
1564 7c				ld a,h 
1565 21 c9 e5			ld hl, os_word_scratch 
1568 cd e8 10			call hexout 
156b e1				pop hl 
156c 7d				ld a,l 
156d 21 cb e5			ld hl, os_word_scratch+2 
1570 cd e8 10			call hexout 
1573 21 cd e5			ld hl, os_word_scratch+4 
1576 3e 00			ld a,0 
1578 77				ld (hl),a 
1579 11 c9 e5			ld de,os_word_scratch 
157c f1				pop af 
157d cd cd 0b				call str_at_display 
1580 c9				ret 
1581			 
1581			display_ptr_state: 
1581			 
1581				; to restore afterwards 
1581			 
1581 d5				push de 
1582 c5				push bc 
1583 e5				push hl 
1584 f5				push af 
1585			 
1585				; for use in here 
1585			 
1585			;	push bc 
1585			;	push de 
1585			;	push hl 
1585			;	push af 
1585			 
1585 cd ba 0b			call clear_display 
1588			 
1588 11 61 17			ld de, .ptrstate 
158b 3e 00			ld a, display_row_1 
158d cd cd 0b			call str_at_display 
1590			 
1590				; display debug step 
1590			 
1590			 
1590 11 6e ee			ld de, debug_mark 
1593 3e 26			ld a, display_row_1+display_cols-2 
1595 cd cd 0b			call str_at_display 
1598			 
1598				; display a 
1598 11 6b 17			ld de, .ptrcliptr 
159b 3e 28			ld a, display_row_2 
159d cd cd 0b			call str_at_display 
15a0			 
15a0 f1				pop af 
15a1 2a 43 ea			ld hl,(cli_ptr) 
15a4 3e 30			ld a, display_row_2+8 
15a6 cd 62 15			call display_word_at 
15a9			 
15a9			 
15a9				; display hl 
15a9			 
15a9			 
15a9 11 73 17			ld de, .ptrclioptr 
15ac 3e 32			ld a, display_row_2+10 
15ae cd cd 0b			call str_at_display 
15b1			; 
15b1			;	pop hl 
15b1 3e 35			ld a, display_row_2+13 
15b3 2a 41 ea			ld hl,(cli_origptr) 
15b6 cd 62 15			call display_word_at 
15b9			; 
15b9			;	 
15b9			;	; display de 
15b9			 
15b9			;	ld de, .regstatede 
15b9			;	ld a, display_row_3 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop de 
15b9			;	ld h,d 
15b9			;	ld l, e 
15b9			;	ld a, display_row_3+3 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display bc 
15b9			 
15b9			;	ld de, .regstatebc 
15b9			;	ld a, display_row_3+10 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop bc 
15b9			;	ld h,b 
15b9			;	ld l, c 
15b9			;	ld a, display_row_3+13 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display dsp 
15b9			 
15b9			;	ld de, .regstatedsp 
15b9			;	ld a, display_row_4 
15b9			;	call str_at_display 
15b9			 
15b9				 
15b9			;	ld hl,(cli_data_sp) 
15b9			;	ld a, display_row_4+4 
15b9			;	call display_word_at 
15b9			 
15b9				; display rsp 
15b9			 
15b9 11 a2 17			ld de, .regstatersp 
15bc 3e 82			ld a, display_row_4+10 
15be cd cd 0b			call str_at_display 
15c1			 
15c1				 
15c1 2a f5 e9			ld hl,(cli_ret_sp) 
15c4 3e 86			ld a, display_row_4+14 
15c6 cd 62 15			call display_word_at 
15c9			 
15c9 cd dd 0b			call update_display 
15cc			 
15cc cd f2 0a			call delay1s 
15cf cd f2 0a			call delay1s 
15d2 cd f2 0a			call delay1s 
15d5			 
15d5			 
15d5 cd cc 1b			call next_page_prompt 
15d8			 
15d8				; restore  
15d8			 
15d8 f1				pop af 
15d9 e1				pop hl 
15da c1				pop bc 
15db d1				pop de 
15dc c9				ret 
15dd			 
15dd			; Update the break point vector so that the user can hook a new routine 
15dd			 
15dd			bp_on: 
15dd 3e c3			ld a, $c3    ; JP 
15df 32 72 ee			ld (debug_vector), a 
15e2 21 ef 15			ld hl, break_point_state 
15e5 22 73 ee			ld (debug_vector+1), hl 
15e8 c9				ret 
15e9			 
15e9			bp_off: 
15e9 3e c9			ld a, $c9    ; RET 
15eb 32 72 ee			ld (debug_vector), a 
15ee c9				ret 
15ef			 
15ef			 
15ef			break_point_state: 
15ef			;	push af 
15ef			; 
15ef			;	; see if disabled 
15ef			; 
15ef			;	ld a, (os_view_disable) 
15ef			;	cp '*' 
15ef			;	jr nz, .bpsgo 
15ef			;	pop af 
15ef			;	ret 
15ef			 
15ef			.bpsgo: 
15ef f1				pop af 
15f0 f5				push af 
15f1 22 b2 e2			ld (os_view_hl), hl 
15f4 ed 53 b0 e2		ld (os_view_de), de 
15f8 ed 43 ae e2		ld (os_view_bc), bc 
15fc e5				push hl 
15fd 6f				ld l, a 
15fe 26 00			ld h, 0 
1600 22 b4 e2			ld (os_view_af),hl 
1603			 
1603 21 b4 ed				ld hl, display_fb0 
1606 22 cf eb				ld (display_fb_active), hl 
1609 e1				pop hl	 
160a			 
160a 3e 31			ld a, '1' 
160c fe 2a		.bps1:  cp '*' 
160e cc e9 15			call z, bp_off 
1611			;	jr nz, .bps1b 
1611			;	ld (os_view_disable),a 
1611 fe 31		.bps1b:  cp '1' 
1613 20 14			jr nz, .bps2 
1615			 
1615				; display reg 
1615			 
1615				 
1615			 
1615 3a b4 e2			ld a, (os_view_af) 
1618 2a b2 e2			ld hl, (os_view_hl) 
161b ed 5b b0 e2		ld de, (os_view_de) 
161f ed 4b ae e2		ld bc, (os_view_bc) 
1623 cd bd 16			call display_reg_state 
1626 c3 a9 16			jp .bpschk 
1629			 
1629 fe 32		.bps2:  cp '2' 
162b 20 08			jr nz, .bps3 
162d				 
162d				; display hl 
162d 2a b2 e2			ld hl, (os_view_hl) 
1630 cd a7 17			call display_dump_at_hl 
1633			 
1633 18 74			jr .bpschk 
1635			 
1635 fe 33		.bps3:  cp '3' 
1637 20 08			jr nz, .bps4 
1639			 
1639			        ; display de 
1639 2a b0 e2			ld hl, (os_view_de) 
163c cd a7 17			call display_dump_at_hl 
163f			 
163f 18 68			jr .bpschk 
1641 fe 34		.bps4:  cp '4' 
1643 20 08			jr nz, .bps5 
1645			 
1645			        ; display bc 
1645 2a ae e2			ld hl, (os_view_bc) 
1648 cd a7 17			call display_dump_at_hl 
164b			 
164b 18 5c			jr .bpschk 
164d fe 35		.bps5:  cp '5' 
164f 20 08		        jr nz, .bps7 
1651			 
1651				; display cur ptr 
1651 2a 43 ea			ld hl, (cli_ptr) 
1654 cd a7 17			call display_dump_at_hl 
1657			 
1657 18 50			jr .bpschk 
1659 fe 36		.bps7:  cp '6' 
165b 20 08			jr nz, .bps8b 
165d				 
165d				; display cur orig ptr 
165d 2a 41 ea			ld hl, (cli_origptr) 
1660 cd a7 17			call display_dump_at_hl 
1663 18 44			jr .bpschk 
1665 fe 37		.bps8b:  cp '7' 
1667 20 08			jr nz, .bps9 
1669				 
1669				; display dsp 
1669 2a f1 e9			ld hl, (cli_data_sp) 
166c cd a7 17			call display_dump_at_hl 
166f			 
166f 18 38			jr .bpschk 
1671 fe 39		.bps9:  cp '9' 
1673 20 05			jr nz, .bps8c 
1675				 
1675				; display SP 
1675			;	ld hl, sp 
1675 cd a7 17			call display_dump_at_hl 
1678			 
1678 18 2f			jr .bpschk 
167a fe 38		.bps8c:  cp '8' 
167c 20 08			jr nz, .bps8d 
167e				 
167e				; display rsp 
167e 2a f5 e9			ld hl, (cli_ret_sp) 
1681 cd a7 17			call display_dump_at_hl 
1684			 
1684 18 23			jr .bpschk 
1686 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1688 20 05			jr nz, .bps8 
168a cd 9a 19			call monitor 
168d			 
168d 18 1a			jr .bpschk 
168f fe 30		.bps8:  cp '0' 
1691 20 16			jr nz, .bpschk 
1693			 
1693 21 13 ed				ld hl, display_fb1 
1696 22 cf eb				ld (display_fb_active), hl 
1699 cd dd 0b				call update_display 
169c			 
169c				;ld a, (os_view_af) 
169c 2a b2 e2			ld hl, (os_view_hl) 
169f ed 5b b0 e2		ld de, (os_view_de) 
16a3 ed 4b ae e2		ld bc, (os_view_bc) 
16a7 f1				pop af 
16a8 c9				ret 
16a9			 
16a9			.bpschk:   
16a9 cd f2 0a			call delay1s 
16ac 3e 9f		ld a,display_row_4 + display_cols - 1 
16ae 11 ca 1b		        ld de, endprg 
16b1 cd cd 0b			call str_at_display 
16b4 cd dd 0b			call update_display 
16b7 cd 8d 64			call cin_wait 
16ba			 
16ba c3 0c 16			jp .bps1 
16bd			 
16bd			 
16bd			display_reg_state: 
16bd			 
16bd				; to restore afterwards 
16bd			 
16bd d5				push de 
16be c5				push bc 
16bf e5				push hl 
16c0 f5				push af 
16c1			 
16c1				; for use in here 
16c1			 
16c1 c5				push bc 
16c2 d5				push de 
16c3 e5				push hl 
16c4 f5				push af 
16c5			 
16c5 cd ba 0b			call clear_display 
16c8			 
16c8 11 7d 17			ld de, .regstate 
16cb 3e 00			ld a, display_row_1 
16cd cd cd 0b			call str_at_display 
16d0			 
16d0				; display debug step 
16d0			 
16d0			 
16d0 11 6e ee			ld de, debug_mark 
16d3 3e 25			ld a, display_row_1+display_cols-3 
16d5 cd cd 0b			call str_at_display 
16d8			 
16d8				; display a 
16d8 11 99 17			ld de, .regstatea 
16db 3e 28			ld a, display_row_2 
16dd cd cd 0b			call str_at_display 
16e0			 
16e0 e1				pop hl 
16e1			;	ld h,0 
16e1			;	ld l, a 
16e1 3e 2b			ld a, display_row_2+3 
16e3 cd 62 15			call display_word_at 
16e6			 
16e6			 
16e6				; display hl 
16e6			 
16e6			 
16e6 11 8d 17			ld de, .regstatehl 
16e9 3e 32			ld a, display_row_2+10 
16eb cd cd 0b			call str_at_display 
16ee			 
16ee e1				pop hl 
16ef 3e 35			ld a, display_row_2+13 
16f1 cd 62 15			call display_word_at 
16f4			 
16f4				 
16f4				; display de 
16f4			 
16f4 11 91 17			ld de, .regstatede 
16f7 3e 50			ld a, display_row_3 
16f9 cd cd 0b			call str_at_display 
16fc			 
16fc e1				pop hl 
16fd			;	ld h,d 
16fd			;	ld l, e 
16fd 3e 53			ld a, display_row_3+3 
16ff cd 62 15			call display_word_at 
1702			 
1702			 
1702				; display bc 
1702			 
1702 11 95 17			ld de, .regstatebc 
1705 3e 5a			ld a, display_row_3+10 
1707 cd cd 0b			call str_at_display 
170a			 
170a e1				pop hl 
170b			;	ld h,b 
170b			;	ld l, c 
170b 3e 5d			ld a, display_row_3+13 
170d cd 62 15			call display_word_at 
1710			 
1710			 
1710				; display dsp 
1710			 
1710 11 9d 17			ld de, .regstatedsp 
1713 3e 78			ld a, display_row_4 
1715 cd cd 0b			call str_at_display 
1718			 
1718				 
1718 2a f1 e9			ld hl,(cli_data_sp) 
171b 3e 7c			ld a, display_row_4+4 
171d cd 62 15			call display_word_at 
1720			 
1720				; display rsp 
1720			 
1720 11 a2 17			ld de, .regstatersp 
1723 3e 82			ld a, display_row_4+10 
1725 cd cd 0b			call str_at_display 
1728			 
1728				 
1728 2a f5 e9			ld hl,(cli_ret_sp) 
172b 3e 86			ld a, display_row_4+14 
172d cd 62 15			call display_word_at 
1730			 
1730 cd dd 0b			call update_display 
1733			 
1733			;	call delay1s 
1733			;	call delay1s 
1733			;	call delay1s 
1733			 
1733			 
1733			;	call next_page_prompt 
1733			 
1733				; restore  
1733			 
1733 f1				pop af 
1734 e1				pop hl 
1735 c1				pop bc 
1736 d1				pop de 
1737 c9				ret 
1738			 
1738 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
174c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1761 .. 00		.ptrstate:	db "Ptr State",0 
176b .. 00		.ptrcliptr:     db "cli_ptr",0 
1773 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
177d .. 00		.regstate:	db "Reg State (1/0)",0 
178d .. 00		.regstatehl:	db "HL:",0 
1791 .. 00		.regstatede:	db "DE:",0 
1795 .. 00		.regstatebc:	db "BC:",0 
1799 .. 00		.regstatea:	db "A :",0 
179d .. 00		.regstatedsp:	db "DSP:",0 
17a2 .. 00		.regstatersp:	db "RSP:",0 
17a7			 
17a7			display_dump_at_hl: 
17a7 e5				push hl 
17a8 d5				push de 
17a9 c5				push bc 
17aa f5				push af 
17ab			 
17ab 22 e7 e5			ld (os_cur_ptr),hl	 
17ae cd ba 0b			call clear_display 
17b1 cd d4 1a			call dumpcont 
17b4			;	call delay1s 
17b4			;	call next_page_prompt 
17b4			 
17b4			 
17b4 f1				pop af 
17b5 c1				pop bc 
17b6 d1				pop de 
17b7 e1				pop hl 
17b8 c9				ret 
17b9			 
17b9			;if ENABLE_BASIC 
17b9			;	include "nascombasic.asm" 
17b9			;	basic: 
17b9			;	include "forth/FORTH.ASM" 
17b9			;endif 
17b9			 
17b9			; eof 
17b9			 
17b9			 
# End of file firmware_diags.asm
17b9			  
17b9			include "firmware_prompts.asm"  
17b9			; Prompts  
17b9			 
17b9			; boot messages 
17b9			 
17b9 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17ce .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17de			 
17de			 
17de			; config menus 
17de			 
17de			;prom_c3: db "Add Dictionary To File",0 
17de			 
17de			if STARTUP_V1 
17de .. 00		prom_c2: db "Select Autoload File",0 
17f3 .. 00		prom_c2a: db "Disable Autoload File", 0 
1809			endif 
1809			 
1809			if STARTUP_V2 
1809			prom_c2: db "Enable Autoload Files",0 
1809			prom_c2a: db "Disable Autoload Files", 0 
1809			 
1809			crs_s1: db "*ls-word", 0 
1809			crs_s2: db "*ed-word", 0 
1809			crs_s3: db "*Demo-Programs", 0 
1809			crs_s4: db "*Utils", 0 
1809			crs_s5: db "*SPI-Addons", 0 
1809			crs_s6: db "*Key-constants", 0 
1809			 
1809			 
1809			 
1809			endif 
1809			;prom_c2b: db "Select Storage Bank",0 
1809 .. 00		prom_c4: db "Settings",0 
1812 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
182d .. 00		prom_m4b:   db "Monitor",0 
1835 .. 00		prom_c1: db "Hardware Diags",0 
1844			 
1844			 
1844			if STARTUP_V2 
1844			prom_c9: db "Create Startup Files",0 
1844			endif 
1844			 
1844 .. 00		prom_notav:    db "Feature not available",0 
185a .. 00		prom_empty:    db "",0 
185b			 
185b			; eof 
185b			 
# End of file firmware_prompts.asm
185b			  
185b			  
185b			; eof  
185b			  
# End of file firmware.asm
185b			 
185b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
185b			;if BASE_KEV  
185b			;baseram: equ 08000h 
185b			;endif 
185b			 
185b			;if BASE_SC114 
185b			;baseram:     equ    endofcode 
185b			;endif 
185b			 
185b			 
185b			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
185b			 
185b			; start system 
185b			 
185b			coldstart: 
185b				; set sp 
185b				; di/ei 
185b			 
185b f3				di 
185c 31 00 f0			ld sp, tos 
185f			;	ei 
185f			 
185f				; init spinner 
185f 3e 00			ld a,0 
1861 32 c9 eb			ld (display_active), a 
1864			 
1864				; disable breakpoint by default 
1864			 
1864				;ld a,'*' 
1864			;	ld a,' ' 
1864			;	ld (os_view_disable),a 
1864			 
1864				; set break point vector as new break point on or off 
1864 cd e9 15			call bp_off 
1867			 
1867				; init hardware 
1867			 
1867				; init keyboard and screen hardware 
1867			 
1867 cd 1c 01			call hardware_init 
186a			 
186a			 
186a cd f2 0a			call delay1s 
186d 3e 58			ld a, display_row_3+8 
186f 11 03 01			ld de, buildtime 
1872 cd cd 0b			call str_at_display 
1875 cd dd 0b			call update_display 
1878			 
1878 cd f2 0a			call delay1s 
187b cd f2 0a			call delay1s 
187e cd f2 0a			call delay1s 
1881			 
1881				; detect if any keys are held down to enable breakpoints at start up 
1881			 
1881 cd 95 64			call cin  
1884 fe 00			cp 0 
1886 28 03			jr z, .nokeys 
1888			 
1888				;call hardware_diags 
1888 cd 47 14			call config 
188b			 
188b			;	ld de, .bpen 
188b			;	ld a, display_row_4 
188b			;	call str_at_display 
188b			;	call update_display 
188b			; 
188b			;	ld a,0 
188b			;	ld (os_view_disable),a 
188b			; 
188b			;.bpwait: 
188b			;	call cin 
188b			;	cp 0 
188b			;	jr z, .bpwait 
188b			;	jr .nokeys 
188b			; 
188b			; 
188b			;.bpen:  db "Break points enabled!",0 
188b			 
188b			 
188b			 
188b			 
188b			 
188b			 
188b			.nokeys: 
188b			 
188b			 
188b				 
188b			 
188b			;jp  testkey 
188b			 
188b			;call storage_get_block_0 
188b			; 
188b			;ld hl, 0 
188b			;ld de, store_page 
188b			;call storage_read_block 
188b			 
188b				 
188b			;ld hl, 10 
188b			;ld de, store_page 
188b			;call storage_read_block 
188b			 
188b			 
188b			 
188b			 
188b			 
188b			;stop:	nop 
188b			;	jp stop 
188b			 
188b			 
188b			 
188b			main: 
188b cd ba 0b			call clear_display 
188e cd dd 0b			call update_display 
1891			 
1891			 
1891			 
1891			;	call testlcd 
1891			 
1891			 
1891			 
1891 cd d1 1f			call forth_init 
1894			 
1894			 
1894			warmstart: 
1894 cd a7 1f			call forth_warmstart 
1897			 
1897				; run startup word load 
1897			        ; TODO prevent this running at warmstart after crash  
1897			 
1897				if STARTUP_ENABLE 
1897			 
1897					if STARTUP_V1 
1897			 
1897						if STORAGE_SE 
1897							call forth_autoload 
1897						endif 
1897 cd ee 62					call forth_startup 
189a					endif 
189a			 
189a					if STARTUP_V2 
189a			 
189a						if STORAGE_SE 
189a							call forth_autoload 
189a						else 
189a							call forth_startup 
189a						endif 
189a			 
189a			 
189a					endif 
189a			 
189a				endif 
189a			 
189a				; show free memory after boot 
189a 11 34 19			ld de, freeram 
189d 3e 00			ld a, display_row_1 
189f cd cd 0b			call str_at_display 
18a2			 
18a2			; Or use heap_size word???? 
18a2 21 ab e2			ld hl, heap_end 
18a5 11 bd 64			ld de, heap_start 
18a8 ed 52			sbc hl, de 
18aa e5				push hl 
18ab 7c				ld a,h	         	 
18ac 21 c9 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18af cd e8 10			call hexout 
18b2 e1			   	pop hl 
18b3			 
18b3 7d				ld a,l 
18b4 21 cb e5			ld hl, os_word_scratch+2 
18b7 cd e8 10			call hexout 
18ba 21 cd e5			ld hl, os_word_scratch+4 
18bd 3e 00			ld a, 0 
18bf 77				ld (hl),a 
18c0 11 c9 e5			ld de, os_word_scratch 
18c3 3e 0d			ld a, display_row_1 + 13 
18c5 cd cd 0b			call str_at_display 
18c8 cd dd 0b			call update_display 
18cb			 
18cb			 
18cb				;call demo 
18cb			 
18cb			 
18cb				; init scratch input area for cli commands 
18cb			 
18cb 21 eb e5			ld hl, os_cli_cmd 
18ce 3e 00			ld a,0 
18d0 77				ld (hl),a 
18d1 23				inc hl 
18d2 77				ld (hl),a 
18d3			 
18d3 3e 00			ld a,0 
18d5 32 ea e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18d8			 
18d8 32 e7 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18db 32 e8 e5			ld (os_cur_ptr+1),a	 
18de			 
18de 32 c9 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18e1 32 ca e5			ld (os_word_scratch+1),a	 
18e4				 
18e4			 
18e4				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18e4 21 eb e5			ld hl, os_cli_cmd 
18e7			 
18e7 3e 00			ld a, 0		 ; init cli input 
18e9 77				ld (hl), a 
18ea 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18ec			cli: 
18ec				; show cli prompt 
18ec				;push af 
18ec				;ld a, 0 
18ec				;ld de, prompt 
18ec				;call str_at_display 
18ec			 
18ec				;call update_display 
18ec				;pop af 
18ec				;inc a 
18ec				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18ec 0e 00			ld c, 0 
18ee 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18f0 1e 28			ld e, 40 
18f2			 
18f2 21 eb e5			ld hl, os_cli_cmd 
18f5			 
18f5				STACKFRAME OFF $fefe $9f9f 
18f5				if DEBUG_STACK_IMB 
18f5					if OFF 
18f5						exx 
18f5						ld de, $fefe 
18f5						ld a, d 
18f5						ld hl, curframe 
18f5						call hexout 
18f5						ld a, e 
18f5						ld hl, curframe+2 
18f5						call hexout 
18f5						ld hl, $fefe 
18f5						push hl 
18f5						ld hl, $9f9f 
18f5						push hl 
18f5						exx 
18f5					endif 
18f5				endif 
18f5			endm 
# End of macro STACKFRAME
18f5			 
18f5 cd 14 0e			call input_str 
18f8			 
18f8				STACKFRAMECHK OFF $fefe $9f9f 
18f8				if DEBUG_STACK_IMB 
18f8					if OFF 
18f8						exx 
18f8						ld hl, $9f9f 
18f8						pop de   ; $9f9f 
18f8						call cmp16 
18f8						jr nz, .spnosame 
18f8						ld hl, $fefe 
18f8						pop de   ; $fefe 
18f8						call cmp16 
18f8						jr z, .spfrsame 
18f8						.spnosame: call showsperror 
18f8						.spfrsame: nop 
18f8						exx 
18f8					endif 
18f8				endif 
18f8			endm 
# End of macro STACKFRAMECHK
18f8			 
18f8				; copy input to last command 
18f8			 
18f8 21 eb e5			ld hl, os_cli_cmd 
18fb 11 ea e6			ld de, os_last_cmd 
18fe 01 ff 00			ld bc, 255 
1901 ed b0			ldir 
1903			 
1903				; wipe current buffer 
1903			 
1903			;	ld a, 0 
1903			;	ld hl, os_cli_cmd 
1903			;	ld de, os_cli_cmd+1 
1903			;	ld bc, 254 
1903			;	ldir 
1903				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1903			;	call strcpy 
1903			;	ld a, 0 
1903			;	ld (hl), a 
1903			;	inc hl 
1903			;	ld (hl), a 
1903			;	inc hl 
1903			;	ld (hl), a 
1903			 
1903				; switch frame buffer to program  
1903			 
1903 21 13 ed				ld hl, display_fb1 
1906 22 cf eb				ld (display_fb_active), hl 
1909			 
1909			;	nop 
1909				STACKFRAME ON $fbfe $8f9f 
1909				if DEBUG_STACK_IMB 
1909					if ON 
1909						exx 
1909						ld de, $fbfe 
1909						ld a, d 
1909						ld hl, curframe 
1909						call hexout 
1909						ld a, e 
1909						ld hl, curframe+2 
1909						call hexout 
1909						ld hl, $fbfe 
1909						push hl 
1909						ld hl, $8f9f 
1909						push hl 
1909						exx 
1909					endif 
1909				endif 
1909			endm 
# End of macro STACKFRAME
1909				; first time into the parser so pass over the current scratch pad 
1909 21 eb e5			ld hl,os_cli_cmd 
190c				; tokenise the entered statement(s) in HL 
190c cd 4f 20			call forthparse 
190f			        ; exec forth statements in top of return stack 
190f cd 8f 20			call forthexec 
1912				;call forthexec_cleanup 
1912			;	call parsenext 
1912			 
1912				STACKFRAMECHK ON $fbfe $8f9f 
1912				if DEBUG_STACK_IMB 
1912					if ON 
1912						exx 
1912						ld hl, $8f9f 
1912						pop de   ; $8f9f 
1912						call cmp16 
1912						jr nz, .spnosame 
1912						ld hl, $fbfe 
1912						pop de   ; $fbfe 
1912						call cmp16 
1912						jr z, .spfrsame 
1912						.spnosame: call showsperror 
1912						.spfrsame: nop 
1912						exx 
1912					endif 
1912				endif 
1912			endm 
# End of macro STACKFRAMECHK
1912				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1912			 
1912 3e 78			ld a, display_row_4 
1914 11 46 19			ld de, endprog 
1917			 
1917 cd dd 0b			call update_display		 
191a			 
191a cd cc 1b			call next_page_prompt 
191d			 
191d				; switch frame buffer to cli 
191d			 
191d 21 b4 ed				ld hl, display_fb0 
1920 22 cf eb				ld (display_fb_active), hl 
1923			 
1923			 
1923 cd ba 0b		        call clear_display 
1926 cd dd 0b			call update_display		 
1929			 
1929 21 eb e5			ld hl, os_cli_cmd 
192c			 
192c 3e 00			ld a, 0		 ; init cli input 
192e 77				ld (hl), a 
192f			 
192f				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
192f			 
192f				; now on last line 
192f			 
192f				; TODO scroll screen up 
192f			 
192f				; TODO instead just clear screen and place at top of screen 
192f			 
192f			;	ld a, 0 
192f			;	ld (f_cursor_ptr),a 
192f			 
192f				;call clear_display 
192f				;call update_display 
192f			 
192f				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
192f 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1931 c3 ec 18			jp cli 
1934			 
1934 .. 00		freeram: db "Free bytes: $",0 
1942 ..			asc: db "1A2F" 
1946 .. 00		endprog: db "End prog...",0 
1952			 
1952			testenter2:   
1952 21 f6 e2			ld hl,scratch+50 
1955 22 e7 e5			ld (os_cur_ptr),hl 
1958 c3 ec 18			jp cli 
195b			 
195b			testenter:  
195b			 
195b 21 42 19			ld hl,asc 
195e			;	ld a,(hl) 
195e			;	call nibble2val 
195e cd 3e 11			call get_byte 
1961			 
1961			 
1961			;	ld a,(hl) 
1961			;	call atohex 
1961			 
1961			;	call fourehexhl 
1961 32 f6 e2			ld (scratch+50),a 
1964			 
1964			 
1964			 
1964 21 44 19			ld hl,asc+2 
1967			;	ld a, (hl) 
1967			;	call nibble2val 
1967 cd 3e 11			call get_byte 
196a			 
196a			;	call fourehexhl 
196a 32 f8 e2			ld (scratch+52),a 
196d				 
196d 21 f6 e2			ld hl,scratch+50 
1970 22 e7 e5			ld (os_cur_ptr),hl 
1973 c3 ec 18			jp cli 
1976			 
1976			enter:	 
1976 3a c8 e2			ld a,(scratch+4) 
1979 fe 00			cp 0 
197b 28 0c			jr z, .entercont 
197d				; no, not a null term line so has an address to work out.... 
197d			 
197d 21 c6 e2			ld hl,scratch+2 
1980 cd 9e 11			call get_word_hl 
1983			 
1983 22 e7 e5			ld (os_cur_ptr),hl	 
1986 c3 ec 18			jp cli 
1989			 
1989			 
1989			.entercont:  
1989			 
1989 21 c6 e2			ld hl, scratch+2 
198c cd 3e 11			call get_byte 
198f			 
198f 2a e7 e5		   	ld hl,(os_cur_ptr) 
1992 77					ld (hl),a 
1993 23					inc hl 
1994 22 e7 e5				ld (os_cur_ptr),hl 
1997				 
1997			; get byte  
1997			 
1997			 
1997 c3 ec 18			jp cli 
199a			 
199a			 
199a			; basic monitor support 
199a			 
199a			monitor: 
199a				;  
199a cd ba 0b			call clear_display 
199d 3e 00			ld a, 0 
199f 11 ee 19			ld de, .monprompt 
19a2 cd cd 0b			call str_at_display 
19a5 cd dd 0b			call update_display 
19a8			 
19a8				; get a monitor command 
19a8			 
19a8 0e 00			ld c, 0     ; entry at top left 
19aa 16 64			ld d, 100   ; max buffer size 
19ac 1e 0f			ld e, 15    ; input scroll area 
19ae 3e 00			ld a, 0     ; init string 
19b0 21 c2 e4			ld hl, os_input 
19b3 77				ld (hl), a 
19b4 23				inc hl 
19b5 77				ld (hl), a 
19b6 21 c2 e4			ld hl, os_input 
19b9 3e 01			ld a, 1     ; init string 
19bb cd 14 0e			call input_str 
19be			 
19be cd ba 0b		        call clear_display 
19c1 cd dd 0b			call update_display		 
19c4			 
19c4 3a c2 e4			ld a, (os_input) 
19c7 cd 3c 12			call toUpper 
19ca fe 48		        cp 'H' 
19cc ca 53 1a		        jp z, .monhelp 
19cf fe 44			cp 'D'		; dump 
19d1 ca 86 1a			jp z, .mondump	 
19d4 fe 43			cp 'C'		; dump 
19d6 ca a0 1a			jp z, .moncdump	 
19d9 fe 4d			cp 'M'		; dump 
19db ca f0 19			jp z, .moneditstart 
19de fe 55			cp 'U'		; dump 
19e0 ca fc 19			jp z, .monedit	 
19e3 fe 47			cp 'G'		; dump 
19e5 ca 7c 1a			jp z, .monjump 
19e8 fe 51			cp 'Q'		; dump 
19ea c8				ret z	 
19eb			 
19eb			 
19eb				; TODO "S" to access symbol by name and not need the address 
19eb				; TODO "F" to find a string in memory 
19eb			 
19eb c3 9a 19			jp monitor 
19ee			 
19ee .. 00		.monprompt: db ">", 0 
19f0			 
19f0			.moneditstart: 
19f0				; get starting address 
19f0			 
19f0 21 c4 e4			ld hl,os_input+2 
19f3 cd 9e 11			call get_word_hl 
19f6			 
19f6 22 e7 e5			ld (os_cur_ptr),hl	 
19f9			 
19f9 c3 9a 19			jp monitor 
19fc			 
19fc			.monedit: 
19fc				; get byte to load 
19fc			 
19fc 21 c4 e4			ld hl,os_input+2 
19ff cd 3e 11			call get_byte 
1a02			 
1a02				; get address to update 
1a02 2a e7 e5			ld hl, (os_cur_ptr) 
1a05			 
1a05				; update byte 
1a05			 
1a05 77				ld (hl), a 
1a06			 
1a06				; move to next address and save it 
1a06			 
1a06 23				inc hl 
1a07 22 e7 e5			ld (os_cur_ptr),hl	 
1a0a			 
1a0a c3 9a 19			jp monitor 
1a0d			 
1a0d			 
1a0d .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a21 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a3d .. 00		.monhelptext3:  db "G-Call address",0 
1a4c .. 00		.monhelptext4:  db "Q-Quit",0 
1a53			        
1a53			.monhelp: 
1a53 3e 00			ld a, display_row_1 
1a55 11 0d 1a		        ld de, .monhelptext1 
1a58			 
1a58 cd cd 0b			call str_at_display 
1a5b 3e 28			ld a, display_row_2 
1a5d 11 21 1a		        ld de, .monhelptext2 
1a60					 
1a60 cd cd 0b			call str_at_display 
1a63 3e 50			ld a, display_row_3 
1a65 11 3d 1a		        ld de, .monhelptext3 
1a68					 
1a68 cd cd 0b			call str_at_display 
1a6b 3e 78			ld a, display_row_4 
1a6d 11 4c 1a		        ld de, .monhelptext4 
1a70 cd cd 0b			call str_at_display 
1a73			 
1a73 cd dd 0b			call update_display		 
1a76			 
1a76 cd cc 1b			call next_page_prompt 
1a79 c3 9a 19			jp monitor 
1a7c			 
1a7c			.monjump:    
1a7c 21 c4 e4			ld hl,os_input+2 
1a7f cd 9e 11			call get_word_hl 
1a82			 
1a82 e9				jp (hl) 
1a83 c3 9a 19			jp monitor 
1a86			 
1a86			.mondump:    
1a86 21 c4 e4			ld hl,os_input+2 
1a89 cd 9e 11			call get_word_hl 
1a8c			 
1a8c 22 e7 e5			ld (os_cur_ptr),hl	 
1a8f cd d4 1a			call dumpcont 
1a92 3e 78			ld a, display_row_4 
1a94 11 46 19			ld de, endprog 
1a97			 
1a97 cd dd 0b			call update_display		 
1a9a			 
1a9a cd cc 1b			call next_page_prompt 
1a9d c3 9a 19			jp monitor 
1aa0			.moncdump: 
1aa0 cd d4 1a			call dumpcont 
1aa3 3e 78			ld a, display_row_4 
1aa5 11 46 19			ld de, endprog 
1aa8			 
1aa8 cd dd 0b			call update_display		 
1aab			 
1aab cd cc 1b			call next_page_prompt 
1aae c3 9a 19			jp monitor 
1ab1			 
1ab1			 
1ab1			; TODO symbol access  
1ab1			 
1ab1			.symbols:     ;; A list of symbols that can be called up  
1ab1 b4 ed			dw display_fb0 
1ab3 .. 00			db "fb0",0  
1ab7 7d ea		     	dw store_page 
1ab9 .. 00			db "store_page",0 
1ac4			 
1ac4			 
1ac4			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ac4			 
1ac4 3a c5 e2			ld a,(scratch+1) 
1ac7 fe 00			cp 0 
1ac9 28 09			jr z, dumpcont 
1acb			 
1acb				; no, not a null term line so has an address to work out.... 
1acb			 
1acb 21 c6 e2			ld hl,scratch+2 
1ace cd 9e 11			call get_word_hl 
1ad1			 
1ad1 22 e7 e5			ld (os_cur_ptr),hl	 
1ad4			 
1ad4			 
1ad4			 
1ad4			dumpcont: 
1ad4			 
1ad4				; dump bytes at ptr 
1ad4			 
1ad4			 
1ad4 3e 00			ld a, display_row_1 
1ad6 2a cf eb			ld hl, (display_fb_active) 
1ad9 cd e7 0d			call addatohl 
1adc cd 04 1b			call .dumpbyterow 
1adf			 
1adf 3e 28			ld a, display_row_2 
1ae1 2a cf eb			ld hl, (display_fb_active) 
1ae4 cd e7 0d			call addatohl 
1ae7 cd 04 1b			call .dumpbyterow 
1aea			 
1aea			 
1aea 3e 50			ld a, display_row_3 
1aec 2a cf eb			ld hl, (display_fb_active) 
1aef cd e7 0d			call addatohl 
1af2 cd 04 1b			call .dumpbyterow 
1af5			 
1af5 3e 78			ld a, display_row_4 
1af7 2a cf eb			ld hl, (display_fb_active) 
1afa cd e7 0d			call addatohl 
1afd cd 04 1b			call .dumpbyterow 
1b00			 
1b00 cd dd 0b			call update_display 
1b03			;		jp cli 
1b03 c9				ret 
1b04			 
1b04			.dumpbyterow: 
1b04			 
1b04				;push af 
1b04			 
1b04 e5				push hl 
1b05			 
1b05				; calc where to poke the ascii 
1b05			if display_cols == 20 
1b05				ld a, 16 
1b05			else 
1b05 3e 1f			ld a, 31 
1b07			endif 
1b07			 
1b07 cd e7 0d			call addatohl 
1b0a 22 c9 e5			ld (os_word_scratch),hl  		; save pos for later 
1b0d			 
1b0d			 
1b0d			; display decoding address 
1b0d 2a e7 e5		   	ld hl,(os_cur_ptr) 
1b10			 
1b10 7c				ld a,h 
1b11 e1				pop hl 
1b12 e5				push hl 
1b13			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b13 cd e8 10			call hexout 
1b16 2a e7 e5		   	ld hl,(os_cur_ptr) 
1b19			 
1b19 7d				ld a,l 
1b1a e1				pop hl 
1b1b 23				inc hl 
1b1c 23				inc hl 
1b1d e5				push hl 
1b1e			;	ld hl, os_word_scratch+2 
1b1e cd e8 10			call hexout 
1b21 e1				pop hl 
1b22 23				inc hl 
1b23 23				inc hl 
1b24				;ld hl, os_word_scratch+4 
1b24 3e 3a			ld a, ':' 
1b26 77				ld (hl),a 
1b27 23				inc hl 
1b28				;ld a, 0 
1b28				;ld (hl),a 
1b28				;ld de, os_word_scratch 
1b28				;pop af 
1b28				;push af 
1b28			;		ld a, display_row_2 
1b28			;		call str_at_display 
1b28			;		call update_display 
1b28			 
1b28			 
1b28			;pop af 
1b28			;	add 5 
1b28			 
1b28			if display_cols == 20 
1b28				ld b, 4 
1b28			else 
1b28 06 08			ld b, 8 
1b2a			endif	 
1b2a			 
1b2a			.dumpbyte: 
1b2a c5				push bc 
1b2b e5				push hl 
1b2c			 
1b2c			 
1b2c 2a e7 e5		   	ld hl,(os_cur_ptr) 
1b2f 7e					ld a,(hl) 
1b30			 
1b30					; poke the ascii to display 
1b30 2a c9 e5				ld hl,(os_word_scratch) 
1b33 77					ld (hl),a 
1b34 23					inc hl 
1b35 22 c9 e5				ld (os_word_scratch),hl 
1b38			 
1b38					 
1b38			 
1b38			 
1b38 e1					pop hl 
1b39 e5					push hl 
1b3a			 
1b3a cd e8 10				call hexout 
1b3d			 
1b3d					 
1b3d 2a e7 e5		   	ld hl,(os_cur_ptr) 
1b40 23				inc hl 
1b41 22 e7 e5		   	ld (os_cur_ptr),hl 
1b44			 
1b44 e1					pop hl 
1b45 23					inc hl 
1b46 23					inc hl 
1b47 23					inc hl 
1b48			 
1b48			 
1b48			 
1b48					;ld a,0 
1b48					;ld (os_word_scratch+2),a 
1b48					;pop af 
1b48					;push af 
1b48			 
1b48					;ld de, os_word_scratch 
1b48					;call str_at_display 
1b48			;		call update_display 
1b48			;		pop af 
1b48 c1					pop bc 
1b49 c6 03				add 3 
1b4b 10 dd			djnz .dumpbyte 
1b4d			 
1b4d				 
1b4d			 
1b4d c9				ret 
1b4e			 
1b4e			jump:	 
1b4e			 
1b4e 21 c6 e2			ld hl,scratch+2 
1b51 cd 9e 11			call get_word_hl 
1b54				;ld hl,(scratch+2) 
1b54				;call fourehexhl 
1b54			 
1b54 22 e7 e5			ld (os_cur_ptr),hl	 
1b57			 
1b57 e9				jp (hl) 
1b58			 
1b58			 
1b58			 
1b58			; TODO implement a basic monitor mode to start with 
1b58			 
1b58			 
1b58			 
1b58			 
1b58			 
1b58			 
1b58			 
1b58			 
1b58			 
1b58			; testing and demo code during development 
1b58			 
1b58			 
1b58 .. 00		str1: db "Enter some text...",0 
1b6b .. 00		clear: db "                    ",0 
1b80			 
1b80			demo: 
1b80			 
1b80			 
1b80			 
1b80			;	call update_display 
1b80			 
1b80				; init scratch input area for testing 
1b80 21 c4 e2			ld hl, scratch	 
1b83 3e 00			ld a,0 
1b85 77				ld (hl),a 
1b86			 
1b86			 
1b86 3e 28		            LD   A, display_row_2 
1b88			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b88 11 58 1b		            LD   DE, str1 
1b8b cd cd 0b			call str_at_display 
1b8e			 
1b8e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b8e			cloop:	 
1b8e 3e 50		            LD   A, display_row_3 
1b90			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b90 11 6b 1b		            LD   DE, clear 
1b93			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b93 cd cd 0b				call str_at_display 
1b96 3e 78			ld a, display_row_4 
1b98 11 c8 1b			ld de, prompt 
1b9b			 
1b9b cd cd 0b				call str_at_display 
1b9e cd dd 0b			call update_display 
1ba1			 
1ba1 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ba3 16 0a			ld d, 10 
1ba5 21 c4 e2			ld hl, scratch	 
1ba8 cd 14 0e			call input_str 
1bab			 
1bab			;	call clear_display 
1bab			;'	call update_display 
1bab			 
1bab 3e 00		            LD   A, display_row_1 
1bad			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bad 11 6b 1b		            LD   DE, clear 
1bb0 cd cd 0b				call str_at_display 
1bb3			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bb3 3e 00		            LD   A, display_row_1 
1bb5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bb5 11 c4 e2		            LD   DE, scratch 
1bb8			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bb8 cd cd 0b				call str_at_display 
1bbb cd dd 0b			call update_display 
1bbe			 
1bbe 3e 00				ld a,0 
1bc0 21 c4 e2			ld hl, scratch 
1bc3 77				ld (hl),a 
1bc4			 
1bc4 00				nop 
1bc5 c3 8e 1b			jp cloop 
1bc8			 
1bc8			 
1bc8			 
1bc8			; OS Prompt 
1bc8			 
1bc8 .. 00		prompt: db ">",0 
1bca .. 00		endprg: db "?",0 
1bcc			 
1bcc			 
1bcc			; handy next page prompt 
1bcc			next_page_prompt: 
1bcc e5				push hl 
1bcd d5				push de 
1bce f5				push af 
1bcf c5				push bc 
1bd0			 
1bd0 3e 9f			ld a,display_row_4 + display_cols - 1 
1bd2 11 ca 1b		        ld de, endprg 
1bd5 cd cd 0b			call str_at_display 
1bd8 cd dd 0b			call update_display 
1bdb cd 8d 64			call cin_wait 
1bde c1				pop bc 
1bdf f1				pop af 
1be0 d1				pop de 
1be1 e1				pop hl 
1be2			 
1be2			 
1be2 c9				ret 
1be3			 
1be3			 
1be3			; forth parser 
1be3			 
1be3			; My forth kernel 
1be3			include "forth_kernel.asm" 
1be3			; 
1be3			; kernel to the forth OS 
1be3			 
1be3			DS_TYPE_STR: equ 1     ; string type 
1be3			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1be3			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1be3			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1be3			 
1be3			FORTH_PARSEV1: equ 0 
1be3			FORTH_PARSEV2: equ 0 
1be3			FORTH_PARSEV3: equ 0 
1be3			FORTH_PARSEV4: equ 0 
1be3			FORTH_PARSEV5: equ 1 
1be3			 
1be3			;if FORTH_PARSEV5 
1be3			;	FORTH_END_BUFFER: equ 0 
1be3			;else 
1be3			FORTH_END_BUFFER: equ 127 
1be3			;endif 
1be3			 
1be3			FORTH_TRUE: equ 1 
1be3			FORTH_FALSE: equ 0 
1be3			 
1be3			if FORTH_PARSEV4 
1be3			include "forth_stackops.asm" 
1be3			endif 
1be3			 
1be3			if FORTH_PARSEV5 
1be3			include "forth_stackopsv5.asm" 
1be3			 
1be3			; Stack operations for v5 parser on wards 
1be3			; * DATA stack 
1be3			; * LOOP stack 
1be3			; * RETURN stack 
1be3			 
1be3			 
1be3			 
1be3			FORTH_CHK_DSP_UNDER: macro 
1be3				push hl 
1be3				push de 
1be3				ld hl,(cli_data_sp) 
1be3				ld de, cli_data_stack 
1be3				call cmp16 
1be3				jp c, fault_dsp_under 
1be3				pop de 
1be3				pop hl 
1be3				endm 
1be3			 
1be3			 
1be3			FORTH_CHK_RSP_UNDER: macro 
1be3				push hl 
1be3				push de 
1be3				ld hl,(cli_ret_sp) 
1be3				ld de, cli_ret_stack 
1be3				call cmp16 
1be3				jp c, fault_rsp_under 
1be3				pop de 
1be3				pop hl 
1be3				endm 
1be3			 
1be3			FORTH_CHK_LOOP_UNDER: macro 
1be3				push hl 
1be3				push de 
1be3				ld hl,(cli_loop_sp) 
1be3				ld de, cli_loop_stack 
1be3				call cmp16 
1be3				jp c, fault_loop_under 
1be3				pop de 
1be3				pop hl 
1be3				endm 
1be3			 
1be3			FORTH_ERR_TOS_NOTSTR: macro 
1be3				; TOSO might need more for checks when used 
1be3				push af 
1be3				ld a,(hl) 
1be3				cp DS_TYPE_STR 
1be3				jp nz, type_faultn   
1be3				pop af 
1be3				endm 
1be3			 
1be3			FORTH_ERR_TOS_NOTNUM: macro 
1be3				push af 
1be3				ld a,(hl) 
1be3				cp DS_TYPE_INUM 
1be3				jp nz, type_faultn   
1be3				pop af 
1be3				endm 
1be3			 
1be3			 
1be3			; increase data stack pointer and save hl to it 
1be3				 
1be3			FORTH_DSP_NEXT: macro 
1be3				call macro_forth_dsp_next 
1be3				endm 
1be3			 
1be3			 
1be3			macro_forth_dsp_next: 
1be3				if DEBUG_FORTH_STACK_GUARD 
1be3 cd cf 60				call check_stacks 
1be6				endif 
1be6 e5				push hl 
1be7 d5				push de 
1be8 eb				ex de,hl 
1be9 2a f1 e9			ld hl,(cli_data_sp) 
1bec 23				inc hl 
1bed 23				inc hl 
1bee			 
1bee			; PARSEV5 
1bee 23				inc hl 
1bef 22 f1 e9			ld (cli_data_sp),hl 
1bf2 73				ld (hl), e 
1bf3 23				inc hl 
1bf4 72				ld (hl), d 
1bf5 d1				pop de 
1bf6 e1				pop hl 
1bf7				if DEBUG_FORTH_STACK_GUARD 
1bf7 cd cf 60				call check_stacks 
1bfa				endif 
1bfa c9				ret 
1bfb			 
1bfb			 
1bfb			; increase ret stack pointer and save hl to it 
1bfb				 
1bfb			FORTH_RSP_NEXT: macro 
1bfb				call macro_forth_rsp_next 
1bfb				endm 
1bfb			 
1bfb			macro_forth_rsp_next: 
1bfb				if DEBUG_FORTH_STACK_GUARD 
1bfb cd cf 60				call check_stacks 
1bfe				endif 
1bfe e5				push hl 
1bff d5				push de 
1c00 eb				ex de,hl 
1c01 2a f5 e9			ld hl,(cli_ret_sp) 
1c04 23				inc hl 
1c05 23				inc hl 
1c06 22 f5 e9			ld (cli_ret_sp),hl 
1c09 73				ld (hl), e 
1c0a 23				inc hl 
1c0b 72				ld (hl), d 
1c0c d1				pop de 
1c0d e1				pop hl 
1c0e				if DEBUG_FORTH_STACK_GUARD 
1c0e cd cf 60				call check_stacks 
1c11				endif 
1c11 c9				ret 
1c12			 
1c12			; get current ret stack pointer and save to hl  
1c12				 
1c12			FORTH_RSP_TOS: macro 
1c12				call macro_forth_rsp_tos 
1c12				endm 
1c12			 
1c12			macro_forth_rsp_tos: 
1c12				;push de 
1c12 2a f5 e9			ld hl,(cli_ret_sp) 
1c15 cd 4d 1c			call loadhlptrtohl 
1c18				;ld e, (hl) 
1c18				;inc hl 
1c18				;ld d, (hl) 
1c18				;ex de, hl 
1c18					if DEBUG_FORTH_WORDS 
1c18			;			DMARK "RST" 
1c18						CALLMONITOR 
1c18 cd 72 ee			call debug_vector  
1c1b				endm  
# End of macro CALLMONITOR
1c1b					endif 
1c1b				;pop de 
1c1b c9				ret 
1c1c			 
1c1c			; pop ret stack pointer 
1c1c				 
1c1c			FORTH_RSP_POP: macro 
1c1c				call macro_forth_rsp_pop 
1c1c				endm 
1c1c			 
1c1c			 
1c1c			macro_forth_rsp_pop: 
1c1c				if DEBUG_FORTH_STACK_GUARD 
1c1c			;		DMARK "RPP" 
1c1c cd cf 60				call check_stacks 
1c1f					FORTH_CHK_RSP_UNDER 
1c1f e5				push hl 
1c20 d5				push de 
1c21 2a f5 e9			ld hl,(cli_ret_sp) 
1c24 11 af e9			ld de, cli_ret_stack 
1c27 cd 05 0e			call cmp16 
1c2a da e3 61			jp c, fault_rsp_under 
1c2d d1				pop de 
1c2e e1				pop hl 
1c2f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c2f				endif 
1c2f e5				push hl 
1c30 2a f5 e9			ld hl,(cli_ret_sp) 
1c33			 
1c33			 
1c33				if FORTH_ENABLE_FREE 
1c33			 
1c33					; get pointer 
1c33			 
1c33					push de 
1c33					push hl 
1c33			 
1c33					ld e, (hl) 
1c33					inc hl 
1c33					ld d, (hl) 
1c33			 
1c33					ex de, hl 
1c33					call free 
1c33			 
1c33					pop hl 
1c33					pop de 
1c33			 
1c33			 
1c33				endif 
1c33			 
1c33			 
1c33 2b				dec hl 
1c34 2b				dec hl 
1c35 22 f5 e9			ld (cli_ret_sp), hl 
1c38				; do stack underflow checks 
1c38 e1				pop hl 
1c39				if DEBUG_FORTH_STACK_GUARD 
1c39 cd cf 60				call check_stacks 
1c3c					FORTH_CHK_RSP_UNDER 
1c3c e5				push hl 
1c3d d5				push de 
1c3e 2a f5 e9			ld hl,(cli_ret_sp) 
1c41 11 af e9			ld de, cli_ret_stack 
1c44 cd 05 0e			call cmp16 
1c47 da e3 61			jp c, fault_rsp_under 
1c4a d1				pop de 
1c4b e1				pop hl 
1c4c				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c4c				endif 
1c4c c9				ret 
1c4d			 
1c4d			 
1c4d			 
1c4d			; routine to load word pointed to by hl into hl 
1c4d			 
1c4d			loadhlptrtohl: 
1c4d			 
1c4d d5				push de 
1c4e 5e				ld e, (hl) 
1c4f 23				inc hl 
1c50 56				ld d, (hl) 
1c51 eb				ex de, hl 
1c52 d1				pop de 
1c53			 
1c53 c9				ret 
1c54			 
1c54			 
1c54			 
1c54			 
1c54			 
1c54			; push a number held in HL onto the data stack 
1c54			; entry point for pushing a value when already in hl used in function above 
1c54			 
1c54			forth_push_numhl: 
1c54			 
1c54 e5				push hl    ; save value to push 
1c55			 
1c55			if DEBUG_FORTH_PUSH 
1c55				; see if disabled 
1c55			 
1c55			 
1c55 f5				push af 
1c56 3a 72 ee			ld a,(debug_vector) 
1c59 fe c9			cp $c9   ; ret 
1c5b			;	ld a, (os_view_disable) 
1c5b			;	cp '*' 
1c5b 28 34			jr z, .pskip2 
1c5d e5				push hl 
1c5e e5			push hl 
1c5f cd ba 0b			call clear_display 
1c62 e1			pop hl 
1c63 7c				ld a,h 
1c64 21 c9 e5			ld hl, os_word_scratch 
1c67 cd e8 10			call hexout 
1c6a e1				pop hl 
1c6b 7d				ld a,l 
1c6c 21 cb e5			ld hl, os_word_scratch+2 
1c6f cd e8 10			call hexout 
1c72			 
1c72 21 cd e5			ld hl, os_word_scratch+4 
1c75 3e 00			ld a,0 
1c77 77				ld (hl),a 
1c78 11 c9 e5			ld de,os_word_scratch 
1c7b 3e 28				ld a, display_row_2 
1c7d cd cd 0b				call str_at_display 
1c80 11 b6 4c			ld de, .push_num 
1c83 3e 00			ld a, display_row_1 
1c85			 
1c85 cd cd 0b				call str_at_display 
1c88			 
1c88			 
1c88 cd dd 0b			call update_display 
1c8b cd f2 0a			call delay1s 
1c8e cd f2 0a			call delay1s 
1c91			.pskip2:  
1c91			 
1c91 f1				pop af 
1c92			endif	 
1c92			 
1c92			 
1c92				FORTH_DSP_NEXT 
1c92 cd e3 1b			call macro_forth_dsp_next 
1c95				endm 
# End of macro FORTH_DSP_NEXT
1c95			 
1c95 2a f1 e9			ld hl, (cli_data_sp) 
1c98			 
1c98				; save item type 
1c98 3e 02			ld a,  DS_TYPE_INUM 
1c9a 77				ld (hl), a 
1c9b 23				inc hl 
1c9c			 
1c9c				; get word off stack 
1c9c d1				pop de 
1c9d 7b				ld a,e 
1c9e 77				ld (hl), a 
1c9f 23				inc hl 
1ca0 7a				ld a,d 
1ca1 77				ld (hl), a 
1ca2			 
1ca2			if DEBUG_FORTH_PUSH 
1ca2 2b				dec hl 
1ca3 2b				dec hl 
1ca4 2b				dec hl 
1ca5						DMARK "PH5" 
1ca5 f5				push af  
1ca6 3a ba 1c			ld a, (.dmark)  
1ca9 32 6e ee			ld (debug_mark),a  
1cac 3a bb 1c			ld a, (.dmark+1)  
1caf 32 6f ee			ld (debug_mark+1),a  
1cb2 3a bc 1c			ld a, (.dmark+2)  
1cb5 32 70 ee			ld (debug_mark+2),a  
1cb8 18 03			jr .pastdmark  
1cba ..			.dmark: db "PH5"  
1cbd f1			.pastdmark: pop af  
1cbe			endm  
# End of macro DMARK
1cbe				CALLMONITOR 
1cbe cd 72 ee			call debug_vector  
1cc1				endm  
# End of macro CALLMONITOR
1cc1			endif	 
1cc1			 
1cc1 c9				ret 
1cc2			 
1cc2			 
1cc2			; Push a string to stack pointed to by hl 
1cc2			 
1cc2			forth_push_str: 
1cc2			 
1cc2			if DEBUG_FORTH_PUSH 
1cc2						DMARK "PSQ" 
1cc2 f5				push af  
1cc3 3a d7 1c			ld a, (.dmark)  
1cc6 32 6e ee			ld (debug_mark),a  
1cc9 3a d8 1c			ld a, (.dmark+1)  
1ccc 32 6f ee			ld (debug_mark+1),a  
1ccf 3a d9 1c			ld a, (.dmark+2)  
1cd2 32 70 ee			ld (debug_mark+2),a  
1cd5 18 03			jr .pastdmark  
1cd7 ..			.dmark: db "PSQ"  
1cda f1			.pastdmark: pop af  
1cdb			endm  
# End of macro DMARK
1cdb				CALLMONITOR 
1cdb cd 72 ee			call debug_vector  
1cde				endm  
# End of macro CALLMONITOR
1cde			endif	 
1cde			    
1cde e5				push hl 
1cdf e5				push hl 
1ce0			 
1ce0			;	ld a, 0   ; find end of string 
1ce0 cd 45 12			call strlenz 
1ce3			if DEBUG_FORTH_PUSH 
1ce3						DMARK "PQ2" 
1ce3 f5				push af  
1ce4 3a f8 1c			ld a, (.dmark)  
1ce7 32 6e ee			ld (debug_mark),a  
1cea 3a f9 1c			ld a, (.dmark+1)  
1ced 32 6f ee			ld (debug_mark+1),a  
1cf0 3a fa 1c			ld a, (.dmark+2)  
1cf3 32 70 ee			ld (debug_mark+2),a  
1cf6 18 03			jr .pastdmark  
1cf8 ..			.dmark: db "PQ2"  
1cfb f1			.pastdmark: pop af  
1cfc			endm  
# End of macro DMARK
1cfc				CALLMONITOR 
1cfc cd 72 ee			call debug_vector  
1cff				endm  
# End of macro CALLMONITOR
1cff			endif	 
1cff eb				ex de, hl 
1d00 e1				pop hl   ; get ptr to start of string 
1d01			if DEBUG_FORTH_PUSH 
1d01						DMARK "PQ3" 
1d01 f5				push af  
1d02 3a 16 1d			ld a, (.dmark)  
1d05 32 6e ee			ld (debug_mark),a  
1d08 3a 17 1d			ld a, (.dmark+1)  
1d0b 32 6f ee			ld (debug_mark+1),a  
1d0e 3a 18 1d			ld a, (.dmark+2)  
1d11 32 70 ee			ld (debug_mark+2),a  
1d14 18 03			jr .pastdmark  
1d16 ..			.dmark: db "PQ3"  
1d19 f1			.pastdmark: pop af  
1d1a			endm  
# End of macro DMARK
1d1a				CALLMONITOR 
1d1a cd 72 ee			call debug_vector  
1d1d				endm  
# End of macro CALLMONITOR
1d1d			endif	 
1d1d 19				add hl,de 
1d1e			if DEBUG_FORTH_PUSH 
1d1e						DMARK "PQE" 
1d1e f5				push af  
1d1f 3a 33 1d			ld a, (.dmark)  
1d22 32 6e ee			ld (debug_mark),a  
1d25 3a 34 1d			ld a, (.dmark+1)  
1d28 32 6f ee			ld (debug_mark+1),a  
1d2b 3a 35 1d			ld a, (.dmark+2)  
1d2e 32 70 ee			ld (debug_mark+2),a  
1d31 18 03			jr .pastdmark  
1d33 ..			.dmark: db "PQE"  
1d36 f1			.pastdmark: pop af  
1d37			endm  
# End of macro DMARK
1d37				CALLMONITOR 
1d37 cd 72 ee			call debug_vector  
1d3a				endm  
# End of macro CALLMONITOR
1d3a			endif	 
1d3a			 
1d3a 2b				dec hl    ; see if there is an optional trailing double quote 
1d3b 7e				ld a,(hl) 
1d3c fe 22			cp '"' 
1d3e 20 03			jr nz, .strnoq 
1d40 3e 00			ld a, 0      ; get rid of double quote 
1d42 77				ld (hl), a 
1d43 23			.strnoq: inc hl 
1d44			 
1d44 3e 00			ld a, 0 
1d46 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d47			 
1d47 13				inc de ; add one for the type string 
1d48 13				inc de ; add one for null term??? 
1d49			 
1d49				; tos is get string pointer again 
1d49				; de contains space to allocate 
1d49				 
1d49 d5				push de 
1d4a			 
1d4a eb				ex de, hl 
1d4b			 
1d4b				;push af 
1d4b			 
1d4b			if DEBUG_FORTH_PUSH 
1d4b						DMARK "PHm" 
1d4b f5				push af  
1d4c 3a 60 1d			ld a, (.dmark)  
1d4f 32 6e ee			ld (debug_mark),a  
1d52 3a 61 1d			ld a, (.dmark+1)  
1d55 32 6f ee			ld (debug_mark+1),a  
1d58 3a 62 1d			ld a, (.dmark+2)  
1d5b 32 70 ee			ld (debug_mark+2),a  
1d5e 18 03			jr .pastdmark  
1d60 ..			.dmark: db "PHm"  
1d63 f1			.pastdmark: pop af  
1d64			endm  
# End of macro DMARK
1d64				CALLMONITOR 
1d64 cd 72 ee			call debug_vector  
1d67				endm  
# End of macro CALLMONITOR
1d67			endif	 
1d67 cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d6a				if DEBUG_FORTH_MALLOC_GUARD 
1d6a cc 0e 4d				call z,malloc_error 
1d6d				endif 
1d6d			 
1d6d				 
1d6d c1				pop bc    ; get length 
1d6e d1				pop de   ;  get string start    
1d6f			 
1d6f				; hl has destination from malloc 
1d6f			 
1d6f eb				ex de, hl    ; prep for ldir 
1d70			 
1d70 d5				push de   ; save malloc area for DSP later 
1d71				;push hl   ; save malloc area for DSP later 
1d71			 
1d71			if DEBUG_FORTH_PUSH 
1d71						DMARK "PHc" 
1d71 f5				push af  
1d72 3a 86 1d			ld a, (.dmark)  
1d75 32 6e ee			ld (debug_mark),a  
1d78 3a 87 1d			ld a, (.dmark+1)  
1d7b 32 6f ee			ld (debug_mark+1),a  
1d7e 3a 88 1d			ld a, (.dmark+2)  
1d81 32 70 ee			ld (debug_mark+2),a  
1d84 18 03			jr .pastdmark  
1d86 ..			.dmark: db "PHc"  
1d89 f1			.pastdmark: pop af  
1d8a			endm  
# End of macro DMARK
1d8a				CALLMONITOR 
1d8a cd 72 ee			call debug_vector  
1d8d				endm  
# End of macro CALLMONITOR
1d8d			endif	 
1d8d			 
1d8d			 
1d8d ed b0			ldir 
1d8f			 
1d8f			 
1d8f				; push malloc to data stack     macro?????  
1d8f			 
1d8f				FORTH_DSP_NEXT 
1d8f cd e3 1b			call macro_forth_dsp_next 
1d92				endm 
# End of macro FORTH_DSP_NEXT
1d92			 
1d92				; save value and type 
1d92			 
1d92 2a f1 e9			ld hl, (cli_data_sp) 
1d95			 
1d95				; save item type 
1d95 3e 01			ld a,  DS_TYPE_STR 
1d97 77				ld (hl), a 
1d98 23				inc hl 
1d99			 
1d99				; get malloc word off stack 
1d99 d1				pop de 
1d9a 73				ld (hl), e 
1d9b 23				inc hl 
1d9c 72				ld (hl), d 
1d9d			 
1d9d			 
1d9d			 
1d9d			if DEBUG_FORTH_PUSH 
1d9d 2a f1 e9			ld hl, (cli_data_sp) 
1da0						DMARK "PHS" 
1da0 f5				push af  
1da1 3a b5 1d			ld a, (.dmark)  
1da4 32 6e ee			ld (debug_mark),a  
1da7 3a b6 1d			ld a, (.dmark+1)  
1daa 32 6f ee			ld (debug_mark+1),a  
1dad 3a b7 1d			ld a, (.dmark+2)  
1db0 32 70 ee			ld (debug_mark+2),a  
1db3 18 03			jr .pastdmark  
1db5 ..			.dmark: db "PHS"  
1db8 f1			.pastdmark: pop af  
1db9			endm  
# End of macro DMARK
1db9				CALLMONITOR 
1db9 cd 72 ee			call debug_vector  
1dbc				endm  
# End of macro CALLMONITOR
1dbc			;	ex de,hl 
1dbc			endif	 
1dbc				; in case of spaces, skip the ptr past the copied string 
1dbc				;pop af 
1dbc				;ld (cli_origptr),hl 
1dbc			 
1dbc c9				ret 
1dbd			 
1dbd			 
1dbd			 
1dbd			; TODO ascii push input onto stack given hl to start of input 
1dbd			 
1dbd			; identify type 
1dbd			; if starts with a " then a string 
1dbd			; otherwise it is a number 
1dbd			;  
1dbd			; if a string 
1dbd			;     scan for ending " to get length of string to malloc for + 1 
1dbd			;     malloc 
1dbd			;     put pointer to string on stack first byte flags as string 
1dbd			; 
1dbd			; else a number 
1dbd			;    look for number format identifier 
1dbd			;    $xx hex 
1dbd			;    %xxxxx bin 
1dbd			;    xxxxx decimal 
1dbd			;    convert number to 16bit word.  
1dbd			;    malloc word + 1 with flag to identiy as num 
1dbd			;    put pointer to number on stack 
1dbd			;   
1dbd			;  
1dbd			  
1dbd			forth_apush: 
1dbd				; kernel push 
1dbd			 
1dbd			if DEBUG_FORTH_PUSH 
1dbd						DMARK "PSH" 
1dbd f5				push af  
1dbe 3a d2 1d			ld a, (.dmark)  
1dc1 32 6e ee			ld (debug_mark),a  
1dc4 3a d3 1d			ld a, (.dmark+1)  
1dc7 32 6f ee			ld (debug_mark+1),a  
1dca 3a d4 1d			ld a, (.dmark+2)  
1dcd 32 70 ee			ld (debug_mark+2),a  
1dd0 18 03			jr .pastdmark  
1dd2 ..			.dmark: db "PSH"  
1dd5 f1			.pastdmark: pop af  
1dd6			endm  
# End of macro DMARK
1dd6				CALLMONITOR 
1dd6 cd 72 ee			call debug_vector  
1dd9				endm  
# End of macro CALLMONITOR
1dd9			endif	 
1dd9				; identify input type 
1dd9			 
1dd9 7e				ld a,(hl) 
1dda fe 22			cp '"' 
1ddc 28 0a			jr z, .fapstr 
1dde fe 24			cp '$' 
1de0 ca 08 1e			jp z, .faphex 
1de3 fe 25			cp '%' 
1de5 ca f0 1d			jp z, .fapbin 
1de8			;	cp 'b' 
1de8			;	jp z, .fabin 
1de8				; else decimal 
1de8			 
1de8				; TODO do decimal conversion 
1de8				; decimal is stored as a 16bit word 
1de8			 
1de8				; by default everything is a string if type is not detected 
1de8			.fapstr: ; 
1de8 fe 22			cp '"' 
1dea 20 01			jr nz, .strnoqu 
1dec 23				inc hl 
1ded			.strnoqu: 
1ded c3 c2 1c			jp forth_push_str 
1df0			 
1df0			 
1df0			 
1df0			.fapbin:    ; push a binary string.  
1df0 11 00 00			ld de, 0   ; hold a 16bit value 
1df3			 
1df3 23			.fapbinshift:	inc hl  
1df4 7e				ld a,(hl) 
1df5 fe 00			cp 0     ; done scanning  
1df7 28 0b			jr z, .fapbdone  	; got it in HL so push  
1df9			 
1df9				; left shift de 
1df9 eb				ex de, hl	 
1dfa 29				add hl, hl 
1dfb			 
1dfb				; is 1 
1dfb fe 31			cp '1' 
1dfd 20 02			jr nz, .binzero 
1dff cb 4d			bit 1, l 
1e01			.binzero: 
1e01 eb				ex de, hl	 ; save current de 
1e02 18 ef			jr .fapbinshift 
1e04			 
1e04			.fapbdone: 
1e04 eb				ex de, hl 
1e05 c3 54 1c			jp forth_push_numhl 
1e08			 
1e08			 
1e08			.faphex:   ; hex is always stored as a 16bit word 
1e08				; skip number prefix 
1e08 23				inc hl 
1e09				; turn ascii into number 
1e09 cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1e0c			 
1e0c c3 54 1c			jp forth_push_numhl 
1e0f			 
1e0f 00				 nop 
1e10			 
1e10			.fabin:   ; TODO bin conversion 
1e10			 
1e10			 
1e10 c9				ret 
1e11			 
1e11			 
1e11			; get either a string ptr or a 16bit word from the data stack 
1e11			 
1e11			FORTH_DSP: macro 
1e11				call macro_forth_dsp 
1e11				endm 
1e11			 
1e11			macro_forth_dsp: 
1e11				; data stack pointer points to current word on tos 
1e11			 
1e11 2a f1 e9			ld hl,(cli_data_sp) 
1e14			 
1e14				if DEBUG_FORTH_PUSH 
1e14						DMARK "DSP" 
1e14 f5				push af  
1e15 3a 29 1e			ld a, (.dmark)  
1e18 32 6e ee			ld (debug_mark),a  
1e1b 3a 2a 1e			ld a, (.dmark+1)  
1e1e 32 6f ee			ld (debug_mark+1),a  
1e21 3a 2b 1e			ld a, (.dmark+2)  
1e24 32 70 ee			ld (debug_mark+2),a  
1e27 18 03			jr .pastdmark  
1e29 ..			.dmark: db "DSP"  
1e2c f1			.pastdmark: pop af  
1e2d			endm  
# End of macro DMARK
1e2d			 
1e2d cd 41 4d				call display_data_sp 
1e30				;call break_point_state 
1e30				;rst 030h 
1e30				CALLMONITOR 
1e30 cd 72 ee			call debug_vector  
1e33				endm  
# End of macro CALLMONITOR
1e33				endif 
1e33			 
1e33 c9				ret 
1e34			 
1e34			; return hl to start of value on stack 
1e34			 
1e34			FORTH_DSP_VALUE: macro 
1e34				call macro_forth_dsp_value 
1e34				endm 
1e34			 
1e34			macro_forth_dsp_value: 
1e34			 
1e34				FORTH_DSP 
1e34 cd 11 1e			call macro_forth_dsp 
1e37				endm 
# End of macro FORTH_DSP
1e37			 
1e37 d5				push de 
1e38			 
1e38 23				inc hl ; skip type 
1e39			 
1e39 5e				ld e, (hl) 
1e3a 23				inc hl 
1e3b 56				ld d, (hl) 
1e3c eb				ex de,hl  
1e3d			 
1e3d d1				pop de 
1e3e			 
1e3e c9				ret 
1e3f			 
1e3f			; return hl to start of value to second item on stack 
1e3f			 
1e3f			FORTH_DSP_VALUEM1: macro 
1e3f				call macro_forth_dsp_value_m1 
1e3f				endm 
1e3f			 
1e3f			macro_forth_dsp_value_m1: 
1e3f			 
1e3f				FORTH_DSP 
1e3f cd 11 1e			call macro_forth_dsp 
1e42				endm 
# End of macro FORTH_DSP
1e42			 
1e42 2b				dec hl 
1e43 2b				dec hl 
1e44			;	dec hl 
1e44			 
1e44 d5				push de 
1e45			 
1e45 5e				ld e, (hl) 
1e46 23				inc hl 
1e47 56				ld d, (hl) 
1e48 eb				ex de,hl  
1e49			 
1e49 d1				pop de 
1e4a			 
1e4a c9				ret 
1e4b			 
1e4b				 
1e4b			 
1e4b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e4b			 
1e4b			FORTH_DSP_POP: macro 
1e4b				call macro_forth_dsp_pop 
1e4b				endm 
1e4b			 
1e4b			 
1e4b			; get the tos data type 
1e4b			 
1e4b			FORTH_DSP_TYPE:   macro 
1e4b			 
1e4b				;FORTH_DSP_VALUE 
1e4b				FORTH_DSP 
1e4b				 
1e4b				; hl points to value 
1e4b				; check type 
1e4b			 
1e4b				ld a,(hl) 
1e4b			 
1e4b				endm 
1e4b			 
1e4b			; load the tos value into hl 
1e4b			 
1e4b			 
1e4b			FORTH_DSP_VALUEHL:  macro 
1e4b				call macro_dsp_valuehl 
1e4b				endm 
1e4b			 
1e4b			 
1e4b			 
1e4b			macro_dsp_valuehl: 
1e4b				FORTH_DSP_VALUE 
1e4b cd 34 1e			call macro_forth_dsp_value 
1e4e				endm 
# End of macro FORTH_DSP_VALUE
1e4e			 
1e4e				;FORTH_ERR_TOS_NOTNUM 
1e4e			 
1e4e				;inc hl   ; skip type id 
1e4e			 
1e4e			;	push de 
1e4e			; 
1e4e			;	ld e, (hl) 
1e4e			;	inc hl 
1e4e			;	ld d, (hl) 
1e4e			;	ex de,hl  
1e4e			 
1e4e			;	pop de 
1e4e			 
1e4e				if DEBUG_FORTH_PUSH 
1e4e						DMARK "DVL" 
1e4e f5				push af  
1e4f 3a 63 1e			ld a, (.dmark)  
1e52 32 6e ee			ld (debug_mark),a  
1e55 3a 64 1e			ld a, (.dmark+1)  
1e58 32 6f ee			ld (debug_mark+1),a  
1e5b 3a 65 1e			ld a, (.dmark+2)  
1e5e 32 70 ee			ld (debug_mark+2),a  
1e61 18 03			jr .pastdmark  
1e63 ..			.dmark: db "DVL"  
1e66 f1			.pastdmark: pop af  
1e67			endm  
# End of macro DMARK
1e67				CALLMONITOR 
1e67 cd 72 ee			call debug_vector  
1e6a				endm  
# End of macro CALLMONITOR
1e6a				endif 
1e6a c9				ret 
1e6b			 
1e6b			forth_apushstrhl:      
1e6b				; push of string requires use of cli_origptr 
1e6b				; bodge use 
1e6b			 
1e6b				; get current cli_origptr, save, update with temp pointer  
1e6b ed 5b 41 ea		ld de, (cli_origptr) 
1e6f 22 41 ea			ld (cli_origptr), hl 
1e72 d5				push de 
1e73 cd bd 1d			call forth_apush 
1e76 d1				pop de 
1e77 ed 53 41 ea		ld (cli_origptr), de 
1e7b c9			        ret	 
1e7c			 
1e7c			 
1e7c			; increase loop stack pointer and save hl to it 
1e7c				 
1e7c			FORTH_LOOP_NEXT: macro 
1e7c				call macro_forth_loop_next 
1e7c				;nop 
1e7c				endm 
1e7c			 
1e7c			macro_forth_loop_next: 
1e7c				if DEBUG_FORTH_STACK_GUARD 
1e7c cd cf 60				call check_stacks 
1e7f				endif 
1e7f e5				push hl 
1e80 d5				push de 
1e81 eb				ex de,hl 
1e82 2a f3 e9			ld hl,(cli_loop_sp) 
1e85 23				inc hl 
1e86 23				inc hl 
1e87					if DEBUG_FORTH_WORDS 
1e87						DMARK "LNX" 
1e87 f5				push af  
1e88 3a 9c 1e			ld a, (.dmark)  
1e8b 32 6e ee			ld (debug_mark),a  
1e8e 3a 9d 1e			ld a, (.dmark+1)  
1e91 32 6f ee			ld (debug_mark+1),a  
1e94 3a 9e 1e			ld a, (.dmark+2)  
1e97 32 70 ee			ld (debug_mark+2),a  
1e9a 18 03			jr .pastdmark  
1e9c ..			.dmark: db "LNX"  
1e9f f1			.pastdmark: pop af  
1ea0			endm  
# End of macro DMARK
1ea0						CALLMONITOR 
1ea0 cd 72 ee			call debug_vector  
1ea3				endm  
# End of macro CALLMONITOR
1ea3					endif 
1ea3 22 f3 e9			ld (cli_loop_sp),hl 
1ea6 73				ld (hl), e 
1ea7 23				inc hl 
1ea8 72				ld (hl), d 
1ea9 d1				pop de    ; been reversed so save a swap on restore 
1eaa e1				pop hl 
1eab				if DEBUG_FORTH_STACK_GUARD 
1eab cd cf 60				call check_stacks 
1eae				endif 
1eae c9				ret 
1eaf			 
1eaf			; get current ret stack pointer and save to hl  
1eaf				 
1eaf			FORTH_LOOP_TOS: macro 
1eaf				call macro_forth_loop_tos 
1eaf				endm 
1eaf			 
1eaf			macro_forth_loop_tos: 
1eaf d5				push de 
1eb0 2a f3 e9			ld hl,(cli_loop_sp) 
1eb3 5e				ld e, (hl) 
1eb4 23				inc hl 
1eb5 56				ld d, (hl) 
1eb6 eb				ex de, hl 
1eb7 d1				pop de 
1eb8 c9				ret 
1eb9			 
1eb9			; pop loop stack pointer 
1eb9				 
1eb9			FORTH_LOOP_POP: macro 
1eb9				call macro_forth_loop_pop 
1eb9				endm 
1eb9			 
1eb9			 
1eb9			macro_forth_loop_pop: 
1eb9				if DEBUG_FORTH_STACK_GUARD 
1eb9					DMARK "LPP" 
1eb9 f5				push af  
1eba 3a ce 1e			ld a, (.dmark)  
1ebd 32 6e ee			ld (debug_mark),a  
1ec0 3a cf 1e			ld a, (.dmark+1)  
1ec3 32 6f ee			ld (debug_mark+1),a  
1ec6 3a d0 1e			ld a, (.dmark+2)  
1ec9 32 70 ee			ld (debug_mark+2),a  
1ecc 18 03			jr .pastdmark  
1ece ..			.dmark: db "LPP"  
1ed1 f1			.pastdmark: pop af  
1ed2			endm  
# End of macro DMARK
1ed2 cd cf 60				call check_stacks 
1ed5					FORTH_CHK_LOOP_UNDER 
1ed5 e5				push hl 
1ed6 d5				push de 
1ed7 2a f3 e9			ld hl,(cli_loop_sp) 
1eda 11 2d e9			ld de, cli_loop_stack 
1edd cd 05 0e			call cmp16 
1ee0 da e9 61			jp c, fault_loop_under 
1ee3 d1				pop de 
1ee4 e1				pop hl 
1ee5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ee5				endif 
1ee5 e5				push hl 
1ee6 2a f3 e9			ld hl,(cli_loop_sp) 
1ee9 2b				dec hl 
1eea 2b				dec hl 
1eeb 22 f3 e9			ld (cli_loop_sp), hl 
1eee				; TODO do stack underflow checks 
1eee e1				pop hl 
1eef				if DEBUG_FORTH_STACK_GUARD 
1eef cd cf 60				call check_stacks 
1ef2					FORTH_CHK_LOOP_UNDER 
1ef2 e5				push hl 
1ef3 d5				push de 
1ef4 2a f3 e9			ld hl,(cli_loop_sp) 
1ef7 11 2d e9			ld de, cli_loop_stack 
1efa cd 05 0e			call cmp16 
1efd da e9 61			jp c, fault_loop_under 
1f00 d1				pop de 
1f01 e1				pop hl 
1f02				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f02				endif 
1f02 c9				ret 
1f03			 
1f03			macro_forth_dsp_pop: 
1f03			 
1f03 e5				push hl 
1f04			 
1f04				; release malloc data 
1f04			 
1f04				if DEBUG_FORTH_STACK_GUARD 
1f04 cd cf 60				call check_stacks 
1f07					FORTH_CHK_DSP_UNDER 
1f07 e5				push hl 
1f08 d5				push de 
1f09 2a f1 e9			ld hl,(cli_data_sp) 
1f0c 11 2b e8			ld de, cli_data_stack 
1f0f cd 05 0e			call cmp16 
1f12 da dd 61			jp c, fault_dsp_under 
1f15 d1				pop de 
1f16 e1				pop hl 
1f17				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f17				endif 
1f17				;ld hl,(cli_data_sp) 
1f17			if DEBUG_FORTH_DOT 
1f17				DMARK "DPP" 
1f17 f5				push af  
1f18 3a 2c 1f			ld a, (.dmark)  
1f1b 32 6e ee			ld (debug_mark),a  
1f1e 3a 2d 1f			ld a, (.dmark+1)  
1f21 32 6f ee			ld (debug_mark+1),a  
1f24 3a 2e 1f			ld a, (.dmark+2)  
1f27 32 70 ee			ld (debug_mark+2),a  
1f2a 18 03			jr .pastdmark  
1f2c ..			.dmark: db "DPP"  
1f2f f1			.pastdmark: pop af  
1f30			endm  
# End of macro DMARK
1f30				CALLMONITOR 
1f30 cd 72 ee			call debug_vector  
1f33				endm  
# End of macro CALLMONITOR
1f33			endif	 
1f33			 
1f33			 
1f33			if FORTH_ENABLE_DSPPOPFREE 
1f33			 
1f33				FORTH_DSP 
1f33 cd 11 1e			call macro_forth_dsp 
1f36				endm 
# End of macro FORTH_DSP
1f36			 
1f36 7e				ld a, (hl) 
1f37 fe 01			cp DS_TYPE_STR 
1f39 20 23			jr nz, .skippopfree 
1f3b			 
1f3b				FORTH_DSP_VALUEHL 
1f3b cd 4b 1e			call macro_dsp_valuehl 
1f3e				endm 
# End of macro FORTH_DSP_VALUEHL
1f3e 00				nop 
1f3f			if DEBUG_FORTH_DOT 
1f3f				DMARK "DPf" 
1f3f f5				push af  
1f40 3a 54 1f			ld a, (.dmark)  
1f43 32 6e ee			ld (debug_mark),a  
1f46 3a 55 1f			ld a, (.dmark+1)  
1f49 32 6f ee			ld (debug_mark+1),a  
1f4c 3a 56 1f			ld a, (.dmark+2)  
1f4f 32 70 ee			ld (debug_mark+2),a  
1f52 18 03			jr .pastdmark  
1f54 ..			.dmark: db "DPf"  
1f57 f1			.pastdmark: pop af  
1f58			endm  
# End of macro DMARK
1f58				CALLMONITOR 
1f58 cd 72 ee			call debug_vector  
1f5b				endm  
# End of macro CALLMONITOR
1f5b			endif	 
1f5b cd 78 13			call free 
1f5e			.skippopfree: 
1f5e				 
1f5e			 
1f5e			endif 
1f5e			 
1f5e			if DEBUG_FORTH_DOT_KEY 
1f5e				DMARK "DP2" 
1f5e				CALLMONITOR 
1f5e			endif	 
1f5e			 
1f5e				; move pointer down 
1f5e			 
1f5e 2a f1 e9			ld hl,(cli_data_sp) 
1f61 2b				dec hl 
1f62 2b				dec hl 
1f63			; PARSEV5 
1f63 2b				dec hl 
1f64 22 f1 e9			ld (cli_data_sp), hl 
1f67			 
1f67				if DEBUG_FORTH_STACK_GUARD 
1f67 cd cf 60				call check_stacks 
1f6a					FORTH_CHK_DSP_UNDER 
1f6a e5				push hl 
1f6b d5				push de 
1f6c 2a f1 e9			ld hl,(cli_data_sp) 
1f6f 11 2b e8			ld de, cli_data_stack 
1f72 cd 05 0e			call cmp16 
1f75 da dd 61			jp c, fault_dsp_under 
1f78 d1				pop de 
1f79 e1				pop hl 
1f7a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f7a				endif 
1f7a			 
1f7a e1				pop hl 
1f7b			 
1f7b c9				ret 
1f7c			 
1f7c			getwordathl: 
1f7c				; hl points to an address 
1f7c				; load hl with the word at that address 
1f7c			 
1f7c d5				push de 
1f7d			 
1f7d 5e				ld e, (hl) 
1f7e 23				inc hl 
1f7f 56				ld d, (hl) 
1f80 eb				ex de, hl 
1f81			 
1f81 d1				pop de 
1f82 c9				ret 
1f83			 
1f83			 
1f83			 
1f83			 
1f83			 
1f83			; eof 
1f83			 
# End of file forth_stackopsv5.asm
1f83			endif 
1f83			 
1f83			loadwordinhl:	 
1f83			 
1f83 d5				push de 
1f84			 
1f84 5e				ld e, (hl) 
1f85 23				inc hl 
1f86 56				ld d, (hl) 
1f87 eb				ex de,hl  
1f88			 
1f88 d1				pop de 
1f89			 
1f89 c9				ret 
1f8a			 
1f8a			user_word_eol:  
1f8a				; hl contains the pointer to where to create a linked list item from the end 
1f8a				; of the user dict to continue on at the system word dict 
1f8a				 
1f8a				; poke the stub of the word list linked list to repoint to rom words 
1f8a			 
1f8a				; stub format 
1f8a				; db   word id 
1f8a				; dw    link to next word 
1f8a			        ; db char length of token 
1f8a				; db string + 0 term 
1f8a				; db exec code....  
1f8a			 
1f8a 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f8c 77				ld (hl), a		; word id 
1f8d 23				inc hl 
1f8e			 
1f8e 11 59 21			ld de, sysdict 
1f91 73				ld (hl), e		; next word link ie system dict 
1f92 23				inc hl 
1f93 72				ld (hl), d		; next word link ie system dict 
1f94 23				inc hl	 
1f95			 
1f95			;	ld (hl), sysdict		; next word link ie system dict 
1f95			;	inc hl 
1f95			;	inc hl 
1f95			 
1f95			;	inc hl 
1f95			;	inc hl 
1f95			 
1f95 3e 02			ld a, 2			; word length is 0 
1f97 77				ld (hl), a	 
1f98 23				inc hl 
1f99			 
1f99 3e 7e			ld a, '~'			; word length is 0 
1f9b 77				ld (hl), a	 
1f9c 23				inc hl 
1f9d 3e 00			ld a, 0			; save empty word 
1f9f 77				ld (hl), a 
1fa0			 
1fa0 c9				ret 
1fa1			 
1fa1				 
1fa1			 
1fa1			forthexec_cleanup: 
1fa1				FORTH_RSP_POP 
1fa1 cd 1c 1c			call macro_forth_rsp_pop 
1fa4				endm 
# End of macro FORTH_RSP_POP
1fa4 c9				ret 
1fa5			 
1fa5			forth_call_hl: 
1fa5				; taking hl 
1fa5 e5				push hl 
1fa6 c9				ret 
1fa7			 
1fa7			; this is called to reset Forth system but keep existing uwords etc 
1fa7			 
1fa7			forth_warmstart: 
1fa7				; setup stack over/under flow checks 
1fa7				if DEBUG_FORTH_STACK_GUARD 
1fa7 cd b5 60				call chk_stk_init 
1faa				endif 
1faa			 
1faa				; init stack pointers  - * these stacks go upwards *  
1faa 21 af e9			ld hl, cli_ret_stack 
1fad 22 f5 e9			ld (cli_ret_sp), hl	 
1fb0				; set bottom of stack 
1fb0 3e 00			ld a,0 
1fb2 77				ld (hl),a 
1fb3 23				inc hl 
1fb4 77				ld (hl),a 
1fb5			 
1fb5 21 2b e8			ld hl, cli_data_stack 
1fb8 22 f1 e9			ld (cli_data_sp), hl	 
1fbb				; set bottom of stack 
1fbb 3e 00			ld a,0 
1fbd 77				ld (hl),a 
1fbe 23				inc hl 
1fbf 77				ld (hl),a 
1fc0			 
1fc0 21 2d e9			ld hl, cli_loop_stack 
1fc3 22 f3 e9			ld (cli_loop_sp), hl	 
1fc6				; set bottom of stack 
1fc6 3e 00			ld a,0 
1fc8 77				ld (hl),a 
1fc9 23				inc hl 
1fca 77				ld (hl),a 
1fcb			 
1fcb				; init extent of current open file 
1fcb			 
1fcb 3e 00			ld a, 0 
1fcd 32 6d ea			ld (store_openext), a 
1fd0			 
1fd0 c9				ret 
1fd1			 
1fd1			 
1fd1			 
1fd1			; Cold Start - this is called to setup the whole Forth system 
1fd1			 
1fd1			forth_init: 
1fd1			 
1fd1				; setup stack over/under flow checks 
1fd1			 
1fd1			;	if DEBUG_FORTH_STACK_GUARD 
1fd1			;		call chk_stk_init 
1fd1			;	endif 
1fd1			 
1fd1				; enable auto display updates (slow.....) 
1fd1			 
1fd1 3e 01			ld a, 1 
1fd3 32 3f ea			ld (cli_autodisplay), a 
1fd6			 
1fd6				; if storage is in use disable long reads for now 
1fd6 3e 00			ld a, 0 
1fd8 32 78 ea			ld (store_longread), a 
1fdb			 
1fdb			 
1fdb				; show start up screen 
1fdb			 
1fdb cd ba 0b			call clear_display 
1fde			 
1fde 3e 00			ld a,0 
1fe0 32 61 ea			ld (f_cursor_ptr), a 
1fe3			 
1fe3				; set start of word list in start of ram - for use when creating user words 
1fe3			 
1fe3 21 ae 64			ld hl, baseram 
1fe6 22 c1 e5			ld (os_last_new_uword), hl 
1fe9 cd 8a 1f			call user_word_eol 
1fec				 
1fec			;		call display_data_sp 
1fec			;		call next_page_prompt 
1fec			 
1fec			 
1fec			 
1fec			 
1fec c9				ret 
1fed			 
1fed .. 00		.bootforth: db " Forth Kernel Init ",0 
2001			 
2001			; TODO push to stack 
2001			 
2001			;  
2001			 
2001			if FORTH_PARSEV2 
2001			 
2001			 
2001				include "forth_parserv2.asm" 
2001			 
2001			endif 
2001			 
2001			 
2001			; parse cli version 1 
2001			 
2001			if FORTH_PARSEV1 
2001			 
2001			 
2001			 
2001			      include "forth_parserv1.asm" 
2001			endif 
2001				 
2001			if FORTH_PARSEV3 
2001			 
2001			 
2001			 
2001			      include "forth_parserv3.asm" 
2001				include "forth_wordsv3.asm" 
2001			endif 
2001			 
2001			if FORTH_PARSEV4 
2001			 
2001			 
2001			 
2001			      include "forth_parserv4.asm" 
2001				include "forth_wordsv4.asm" 
2001			endif 
2001			 
2001			if FORTH_PARSEV5 
2001			 
2001			 
2001			 
2001			      include "forth_parserv5.asm" 
2001			 
2001			 
2001			; A better parser without using malloc and string copies all over the place.  
2001			; Exec in situ should be faster 
2001			 
2001			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2001			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2001			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2001			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2001			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2001			WORD_SYS_END: equ 0   ; Opcode for all user words 
2001			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2001			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2001			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2001			 
2001			; Core word preamble macro 
2001			 
2001			CWHEAD:   macro nxtword opcode lit len opflags 
2001				db WORD_SYS_CORE+opcode             
2001				; internal op code number 
2001				dw nxtword            
2001				; link to next dict word block 
2001				db len + 1 
2001				; literal length of dict word inc zero term 
2001				db lit,0              
2001				; literal dict word 
2001			        ; TODO db opflags        
2001				endm 
2001			 
2001			 
2001			NEXTW: macro  
2001				jp macro_next 
2001				endm 
2001			 
2001			macro_next: 
2001			if DEBUG_FORTH_PARSE_KEY 
2001				DMARK "NXT" 
2001				CALLMONITOR 
2001			endif	 
2001			;	inc hl  ; skip token null term  
2001 ed 4b 43 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2005 ed 5b 41 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2009 2a c5 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
200c			if DEBUG_FORTH_PARSE_KEY 
200c				DMARK "}AA" 
200c				CALLMONITOR 
200c			endif	 
200c c3 0f 21			jp execnext 
200f				;jp exec1 
200f			       
200f			 
200f			 
200f			; Another go at the parser to compile  
200f			 
200f			 
200f			; TODO rework parser to change all of the string words to byte tokens 
200f			; TODO do a search for  
200f			 
200f			; TODO first run normal parser to zero term sections 
200f			; TODO for each word do a token look up to get the op code 
200f			; TODO need some means to flag to the exec that this is a byte code form    
200f			 
200f			 
200f			forthcompile: 
200f			 
200f			; 
200f			; line parse: 
200f			;       parse raw input buffer 
200f			;       tokenise the words 
200f			;       malloc new copy (for looping etc) 
200f			;       copy to malloc + current pc in line to start of string and add line term 
200f			;       save on new rsp 
200f			; 
200f			 
200f			; hl to point to the line to tokenise 
200f			 
200f			;	push hl 
200f 22 c5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2012			 
2012			;	ld a,0		; string term on input 
2012			;	call strlent 
2012			 
2012			;	ld (os_tok_len), hl	 ; save string length 
2012			 
2012			;if DEBUG_FORTH_TOK 
2012			;	ex de,hl		 
2012			;endif 
2012			 
2012			;	pop hl 		; get back string pointer 
2012			 
2012			if DEBUG_FORTH_TOK 
2012						DMARK "TOc" 
2012				CALLMONITOR 
2012			endif 
2012 7e			.cptoken2:    ld a,(hl) 
2013 23				inc hl 
2014 fe 7f			cp FORTH_END_BUFFER 
2016 28 29			jr z, .cptokendone2 
2018 fe 00			cp 0 
201a 28 25			jr z, .cptokendone2 
201c fe 22			cp '"' 
201e 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2020 fe 20			cp ' ' 
2022 20 ee			jr nz,  .cptoken2 
2024			 
2024			; TODO consume comments held between ( and ) 
2024			 
2024				; we have a space so change to zero term for dict match later 
2024 2b				dec hl 
2025 3e 00			ld a,0 
2027 77				ld (hl), a 
2028 23				inc hl 
2029 18 e7			jr .cptoken2 
202b				 
202b			 
202b			.cptokenstr2: 
202b				; skip all white space until either eol (because forgot to term) or end double quote 
202b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
202b				;inc hl ; skip current double quote 
202b 7e				ld a,(hl) 
202c 23				inc hl 
202d fe 22			cp '"' 
202f 28 e1			jr z, .cptoken2 
2031 fe 7f			cp FORTH_END_BUFFER 
2033 28 0c			jr z, .cptokendone2 
2035 fe 00			cp 0 
2037 28 08			jr z, .cptokendone2 
2039 fe 20			cp ' ' 
203b 28 02			jr z, .cptmp2 
203d 18 ec			jr .cptokenstr2 
203f			 
203f			.cptmp2:	; we have a space so change to zero term for dict match later 
203f				;dec hl 
203f				;ld a,"-"	; TODO remove this when working 
203f				;ld (hl), a 
203f				;inc hl 
203f 18 ea			jr .cptokenstr2 
2041			 
2041			.cptokendone2: 
2041				;inc hl 
2041 3e 7f			ld a, FORTH_END_BUFFER 
2043 77				ld (hl),a 
2044 23				inc hl 
2045 3e 21			ld a, '!' 
2047 77				ld (hl),a 
2048			 
2048 2a c5 e5			ld hl,(os_tok_ptr) 
204b			         
204b			if DEBUG_FORTH_TOK 
204b						DMARK "Tc1" 
204b				CALLMONITOR 
204b			endif 
204b			 
204b				; push exec string to top of return stack 
204b				FORTH_RSP_NEXT 
204b cd fb 1b			call macro_forth_rsp_next 
204e				endm 
# End of macro FORTH_RSP_NEXT
204e c9				ret 
204f			 
204f			; Another go at the parser need to simplify the process 
204f			 
204f			forthparse: 
204f			 
204f			; 
204f			; line parse: 
204f			;       parse raw input buffer 
204f			;       tokenise the words 
204f			;       malloc new copy (for looping etc) 
204f			;       copy to malloc + current pc in line to start of string and add line term 
204f			;       save on new rsp 
204f			; 
204f			 
204f			; hl to point to the line to tokenise 
204f			 
204f			;	push hl 
204f 22 c5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2052			 
2052			;	ld a,0		; string term on input 
2052			;	call strlent 
2052			 
2052			;	ld (os_tok_len), hl	 ; save string length 
2052			 
2052			;if DEBUG_FORTH_TOK 
2052			;	ex de,hl		 
2052			;endif 
2052			 
2052			;	pop hl 		; get back string pointer 
2052			 
2052			if DEBUG_FORTH_TOK 
2052						DMARK "TOK" 
2052				CALLMONITOR 
2052			endif 
2052 7e			.ptoken2:    ld a,(hl) 
2053 23				inc hl 
2054 fe 7f			cp FORTH_END_BUFFER 
2056 28 29			jr z, .ptokendone2 
2058 fe 00			cp 0 
205a 28 25			jr z, .ptokendone2 
205c fe 22			cp '"' 
205e 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2060 fe 20			cp ' ' 
2062 20 ee			jr nz,  .ptoken2 
2064			 
2064			; TODO consume comments held between ( and ) 
2064			 
2064				; we have a space so change to zero term for dict match later 
2064 2b				dec hl 
2065 3e 00			ld a,0 
2067 77				ld (hl), a 
2068 23				inc hl 
2069 18 e7			jr .ptoken2 
206b				 
206b			 
206b			.ptokenstr2: 
206b				; skip all white space until either eol (because forgot to term) or end double quote 
206b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
206b				;inc hl ; skip current double quote 
206b 7e				ld a,(hl) 
206c 23				inc hl 
206d fe 22			cp '"' 
206f 28 e1			jr z, .ptoken2 
2071 fe 7f			cp FORTH_END_BUFFER 
2073 28 0c			jr z, .ptokendone2 
2075 fe 00			cp 0 
2077 28 08			jr z, .ptokendone2 
2079 fe 20			cp ' ' 
207b 28 02			jr z, .ptmp2 
207d 18 ec			jr .ptokenstr2 
207f			 
207f			.ptmp2:	; we have a space so change to zero term for dict match later 
207f				;dec hl 
207f				;ld a,"-"	; TODO remove this when working 
207f				;ld (hl), a 
207f				;inc hl 
207f 18 ea			jr .ptokenstr2 
2081			 
2081			.ptokendone2: 
2081				;inc hl 
2081 3e 7f			ld a, FORTH_END_BUFFER 
2083 77				ld (hl),a 
2084 23				inc hl 
2085 3e 21			ld a, '!' 
2087 77				ld (hl),a 
2088			 
2088 2a c5 e5			ld hl,(os_tok_ptr) 
208b			         
208b			if DEBUG_FORTH_TOK 
208b						DMARK "TK1" 
208b				CALLMONITOR 
208b			endif 
208b			 
208b				; push exec string to top of return stack 
208b				FORTH_RSP_NEXT 
208b cd fb 1b			call macro_forth_rsp_next 
208e				endm 
# End of macro FORTH_RSP_NEXT
208e c9				ret 
208f			 
208f			; 
208f			;	; malloc size + buffer pointer + if is loop flag 
208f			;	ld hl,(os_tok_len) 		 ; get string length 
208f			; 
208f			;	ld a,l 
208f			; 
208f			;	cp 0			; we dont want to use a null string 
208f			;	ret z 
208f			; 
208f			;;	add 3    ; prefix malloc with buffer for current word ptr 
208f			; 
208f			;	add 5     ; TODO when certain not over writing memory remove 
208f			; 
208f			;		 
208f			; 
208f			;if DEBUG_FORTH_TOK 
208f			;			DMARK "TKE" 
208f			;	CALLMONITOR 
208f			;endif 
208f			; 
208f			;	ld l,a 
208f			;	ld h,0 
208f			;;	push hl   ; save required space for the copy later 
208f			;	call malloc 
208f			;if DEBUG_FORTH_TOK 
208f			;			DMARK "TKM" 
208f			;	CALLMONITOR 
208f			;endif 
208f			;	if DEBUG_FORTH_MALLOC_GUARD 
208f			;		push af 
208f			;		call ishlzero 
208f			;;		ld a, l 
208f			;;		add h 
208f			;;		cp 0 
208f			;		pop af 
208f			;		 
208f			;		call z,malloc_error 
208f			;	endif 
208f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
208f			; 
208f			; 
208f			;if DEBUG_FORTH_TOK 
208f			;			DMARK "TKR" 
208f			;	CALLMONITOR 
208f			;endif 
208f			; 
208f			;	FORTH_RSP_NEXT 
208f			; 
208f			;	;inc hl	 ; go past current buffer pointer 
208f			;	;inc hl 
208f			;	;inc hl   ; and past if loop flag 
208f			;		; TODO Need to set flag  
208f			; 
208f			;	 
208f			;	 
208f			;	ex de,hl	; malloc is dest 
208f			;	ld hl, (os_tok_len) 
208f			;;	pop bc 
208f			;	ld c, l                
208f			;	ld b,0 
208f			;	ld hl, (os_tok_ptr) 
208f			; 
208f			;if DEBUG_FORTH_TOK 
208f			;			DMARK "TKT" 
208f			;	CALLMONITOR 
208f			;endif 
208f			; 
208f			;	; do str cpy 
208f			; 
208f			;	ldir      ; copy byte in hl to de 
208f			; 
208f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
208f			; 
208f			;if DEBUG_FORTH_TOK 
208f			; 
208f			;			DMARK "TKY" 
208f			;	CALLMONITOR 
208f			;endif 
208f			;	;ld a,0 
208f			;	;ld a,FORTH_END_BUFFER 
208f			;	ex de, hl 
208f			;	;dec hl			 ; go back over the space delim at the end of word 
208f			;	;ld (hl),a 
208f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
208f			;	ld a,FORTH_END_BUFFER 
208f			;	ld (hl),a 
208f			;	inc hl 
208f			;	ld a,FORTH_END_BUFFER 
208f			;	ld (hl),a 
208f			; 
208f			;	; init the malloc area data 
208f			;	; set pc for in current area 
208f			;	;ld hl, (os_tok_malloc) 
208f			;	;inc hl 
208f			;	;inc hl 
208f			;	;inc hl 
208f			;	;ex de,hl 
208f			;	;ld hl, (os_tok_malloc) 
208f			;	;ld (hl),e 
208f			;	;inc hl 
208f			;	;ld (hl),d 
208f			; 
208f			; 
208f			;	ld hl,(os_tok_malloc) 
208f			;if DEBUG_FORTH_PARSE_KEY 
208f			;			DMARK "TKU" 
208f			;	CALLMONITOR 
208f			;endif 
208f			; 
208f			;	ret 
208f			 
208f			forthexec: 
208f			 
208f			; line exec: 
208f			; forth parser 
208f			 
208f			; 
208f			;       get current exec line on rsp 
208f			 
208f				FORTH_RSP_TOS 
208f cd 12 1c			call macro_forth_rsp_tos 
2092				endm 
# End of macro FORTH_RSP_TOS
2092			 
2092			;       restore current pc - hl points to malloc of data 
2092			 
2092				;ld e, (hl) 
2092				;inc hl 
2092				;ld d, (hl) 
2092				;ex de,hl 
2092			 
2092			 
2092			exec1: 
2092 22 c5 e5			ld (os_tok_ptr), hl 
2095			 
2095				; copy our PC to working vars  
2095 22 43 ea			ld (cli_ptr), hl 
2098 22 41 ea			ld (cli_origptr), hl 
209b			 
209b 7e				ld a,(hl) 
209c fe 7f			cp FORTH_END_BUFFER 
209e c8				ret z 
209f			 
209f				; skip any nulls 
209f			 
209f fe 00			cp 0 
20a1 20 03			jr nz, .execword 
20a3 23				inc hl 
20a4 18 ec			jr exec1 
20a6			 
20a6			 
20a6			.execword: 
20a6			 
20a6			 
20a6			 
20a6			if DEBUG_FORTH_PARSE_KEY 
20a6						DMARK "KYQ" 
20a6				CALLMONITOR 
20a6			endif 
20a6			;       while at start of word: 
20a6			; get start of dict (in user area first) 
20a6			 
20a6 21 ae 64		ld hl, baseram 
20a9			;ld hl, sysdict 
20a9 22 45 ea		ld (cli_nextword),hl 
20ac			;           match word at pc 
20ac			;           exec word 
20ac			;           or push to dsp 
20ac			;           forward to next token 
20ac			;           if line term pop rsp and exit 
20ac			;        
20ac			 
20ac			if DEBUG_FORTH_PARSE_KEY 
20ac						DMARK "KYq" 
20ac				CALLMONITOR 
20ac			endif 
20ac			 
20ac			; 
20ac			; word comp 
20ac			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20ac			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20ac			;    move to start of word  
20ac			;    compare word to cli_token 
20ac			 
20ac			.execpnword:	; HL at start of a word in the dictionary to check 
20ac			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20ac			;	ld (cli_ptr), hl 
20ac			 
20ac 2a 45 ea			ld hl,(cli_nextword) 
20af			 
20af cd 52 21			call forth_tok_next 
20b2			; tok next start here 
20b2			;	; TODO skip compiled symbol for now 
20b2			;	inc hl 
20b2			; 
20b2			;	; save pointer to next word 
20b2			; 
20b2			;	; hl now points to the address of the next word pointer  
20b2			;	ld e, (hl) 
20b2			;	inc hl 
20b2			;	ld d, (hl) 
20b2			;	inc l 
20b2			; 
20b2			;	ex de,hl 
20b2			;if DEBUG_FORTH_PARSE_NEXTWORD 
20b2			;	push bc 
20b2			;	ld bc, (cli_nextword) 
20b2			;			DMARK "NXW" 
20b2			;	CALLMONITOR 
20b2			;	pop bc 
20b2			;endif 
20b2			; tok next end here 
20b2 22 45 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20b5 eb				ex de, hl 
20b6			 
20b6			 
20b6				; save the pointer of the current token - 1 to check against 
20b6				 
20b6 22 49 ea			ld (cli_token), hl   
20b9				; TODO maybe remove below save if no debug 
20b9				; save token string ptr for any debug later 
20b9 23				inc hl  
20ba 22 4b ea			ld (cli_origtoken), hl 
20bd 2b				dec hl 
20be				; save pointer to the start of the next dictionay word 
20be 7e				ld a,(hl)   ; get string length 
20bf 47				ld b,a 
20c0			.execpnwordinc:  
20c0 23				inc hl 
20c1 10 fd			djnz .execpnwordinc 
20c3 22 47 ea			ld (cli_execword), hl      ; save start of this words code 
20c6			 
20c6				; now check the word token against the string being parsed 
20c6			 
20c6 2a 49 ea			ld hl,(cli_token) 
20c9 23				inc hl     ; skip string length (use zero term instead to end) 
20ca 22 49 ea			ld (cli_token), hl 
20cd			 
20cd			if DEBUG_FORTH_PARSE_KEY 
20cd						DMARK "KY2" 
20cd			endif 
20cd			if DEBUG_FORTH_PARSE_EXEC 
20cd				; see if disabled 
20cd			 
20cd			;	ld a, (os_view_disable) 
20cd			;	cp '*' 
20cd				ld a, (debug_vector) 
20cd				cp $c9   ; RET  
20cd				jr z, .skip 
20cd			 
20cd				push hl 
20cd				push hl 
20cd				call clear_display 
20cd				ld de, .compword 
20cd				ld a, display_row_1 
20cd				call str_at_display 
20cd				pop de 
20cd				ld a, display_row_2 
20cd				call str_at_display 
20cd				ld hl,(cli_ptr) 
20cd				ld a,(hl) 
20cd			        ld hl, os_word_scratch 
20cd				ld (hl),a 
20cd				ld a,0 
20cd				inc hl 
20cd				ld (hl),a 	 
20cd				ld de, os_word_scratch 
20cd				ld a, display_row_2+10 
20cd				call str_at_display 
20cd				call update_display 
20cd				ld a, 100 
20cd				call aDelayInMS 
20cd				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20cd				call delay250ms 
20cd				endif 
20cd				pop hl 
20cd			.skip:  
20cd			endif	 
20cd			.execpnchar:    ; compare char between token and string to parse 
20cd			 
20cd			if DEBUG_FORTH_PARSE_KEY 
20cd						DMARK "Ky3" 
20cd			endif 
20cd			if DEBUG_FORTH_PARSE_EXEC 
20cd				; see if disabled 
20cd			 
20cd			;	ld a, (os_view_disable) 
20cd			;	cp '*' 
20cd				ld a, (debug_vector) 
20cd				cp $C9  ; RET 
20cd				jr z, .skip2 
20cd			 
20cd			;	call clear_display 
20cd			ld hl,(cli_token) 
20cd			ld a,(hl) 
20cd			ld (os_word_scratch),a 
20cd				ld hl,(cli_ptr) 
20cd			ld a,(hl) 
20cd				ld (os_word_scratch+1),a 
20cd				ld a,0 
20cd				ld (os_word_scratch+2),a 
20cd				ld de,os_word_scratch 
20cd				ld a,display_row_4 
20cd				call str_at_display 
20cd				call update_display 
20cd			.skip2:  
20cd			endif 
20cd 2a 49 ea			ld hl,(cli_token) 
20d0 7e				ld a, (hl)	 ; char in word token 
20d1 23				inc hl 		; move to next char 
20d2 22 49 ea			ld (cli_token), hl ; and save it 
20d5 47				ld b,a 
20d6			 
20d6 2a 43 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20d9 7e				ld a,(hl) 
20da 23				inc hl 
20db 22 43 ea			ld (cli_ptr), hl		; move to next char 
20de cd 3c 12			call toUpper 		; make sure the input string matches case 
20e1			 
20e1			if DEBUG_FORTH_PARSE 
20e1			endif 
20e1			 
20e1				; input stream end of token is a space so get rid of it 
20e1			 
20e1			;	cp ' ' 
20e1			;	jr nz, .pnskipspace 
20e1			; 
20e1			;	ld a, 0		; make same term as word token term 
20e1			; 
20e1			;.pnskipspace: 
20e1			 
20e1			if DEBUG_FORTH_PARSE_KEY 
20e1						DMARK "KY7" 
20e1			endif 
20e1 b8				cp b 
20e2 c2 f8 20			jp nz, .execpnskipword	 ; no match so move to next word 
20e5				 
20e5			;    if same 
20e5			;       scan for string terms 0 for token and 32 for input 
20e5			 
20e5				 
20e5			if DEBUG_FORTH_PARSE_KEY 
20e5						DMARK "KY8" 
20e5			endif 
20e5			 
20e5 80				add b			 
20e6 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20e8							; TODO need to make sure last word in zero term string is accounted for 
20e8 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20ea			 
20ea			 
20ea				; at end of both strings so both are exact match 
20ea			 
20ea			;       skip ptr for next word 
20ea			 
20ea 2a 43 ea			ld hl,(cli_ptr) 	; at input string term 
20ed 23				inc hl			 ; at next char 
20ee 22 43 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20f1 22 41 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20f4				 
20f4				 
20f4			if DEBUG_FORTH_PARSE_KEY 
20f4						DMARK "KY3" 
20f4			endif 
20f4			 
20f4			 
20f4			 
20f4			;       exec code block 
20f4			if DEBUG_FORTH_JP 
20f4				call clear_display 
20f4				call update_display 
20f4				call delay1s 
20f4				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f4				ld a,h 
20f4				ld hl, os_word_scratch 
20f4				call hexout 
20f4				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f4				ld a,l 
20f4				ld hl, os_word_scratch+2 
20f4				call hexout 
20f4				ld hl, os_word_scratch+4 
20f4				ld a,0 
20f4				ld (hl),a 
20f4				ld de,os_word_scratch 
20f4				call str_at_display 
20f4					ld a, display_row_2 
20f4					call str_at_display 
20f4				ld de, (cli_origtoken) 
20f4				ld a, display_row_1+10 
20f4					call str_at_display 
20f4			 
20f4				ld a,display_row_1 
20f4				ld de, .foundword 
20f4				ld a, display_row_3 
20f4				call str_at_display 
20f4				call update_display 
20f4				call delay1s 
20f4				call delay1s 
20f4				call delay1s 
20f4			endif 
20f4			 
20f4			if DEBUG_FORTH_PARSE_KEY 
20f4						DMARK "KYj" 
20f4			endif 
20f4				; TODO save the word pointer in this exec 
20f4			 
20f4 2a 47 ea			ld hl,(cli_execword) 
20f7 e9				jp (hl) 
20f8			 
20f8			 
20f8			;    if not same 
20f8			;	scan for zero term 
20f8			;	get ptr for next word 
20f8			;	goto word comp 
20f8			 
20f8			.execpnskipword:	; get pointer to next word 
20f8 2a 45 ea			ld hl,(cli_nextword) 
20fb			 
20fb 7e				ld a,(hl) 
20fc fe 00			cp WORD_SYS_END 
20fe			;	cp 0 
20fe 28 09			jr z, .execendofdict			 ; at end of words 
2100			 
2100			if DEBUG_FORTH_PARSE_KEY 
2100						DMARK "KY4" 
2100			endif 
2100			if DEBUG_FORTH_PARSE_EXEC 
2100			 
2100				; see if disabled 
2100			 
2100			;	ld a, (os_view_disable) 
2100			;	cp '*' 
2100				ld a,(debug_vector) 
2100				cp $c9   ; RET 
2100				jr z, .noskip 
2100			 
2100			 
2100				ld de, .nowordfound 
2100				ld a, display_row_3 
2100				call str_at_display 
2100				call update_display 
2100				ld a, 100 
2100				call aDelayInMS 
2100				 
2100				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2100					call delay250ms 
2100				endif 
2100			.noskip:  
2100			 
2100			endif	 
2100			 
2100 2a 41 ea			ld hl,(cli_origptr) 
2103 22 43 ea			ld (cli_ptr),hl 
2106			 
2106			if DEBUG_FORTH_PARSE_KEY 
2106						DMARK "KY5" 
2106			endif 
2106 c3 ac 20			jp .execpnword			; else go to next word 
2109			 
2109			.execendofdict:  
2109			 
2109			if DEBUG_FORTH_PARSE_KEY 
2109						DMARK "KYe" 
2109			endif 
2109			if DEBUG_FORTH_PARSE_EXEC 
2109				; see if disabled 
2109			 
2109			;	ld a, (os_view_disable) 
2109			;	cp '*' 
2109				ld a,(debug_vector) 
2109				cp $c9   ; ret 
2109				jr z, .ispskip 
2109			 
2109				call clear_display 
2109				call update_display 
2109				call delay1s 
2109				ld de, (cli_origptr) 
2109				ld a, display_row_1 
2109				call str_at_display 
2109				 
2109				ld de, .enddict 
2109				ld a, display_row_3 
2109				call str_at_display 
2109				call update_display 
2109				ld a, 100 
2109				call aDelayInMS 
2109				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2109				call delay1s 
2109				call delay1s 
2109				call delay1s 
2109				endif 
2109			.ispskip:  
2109				 
2109			endif	 
2109			 
2109			 
2109			 
2109				; if the word is not a keyword then must be a literal so push it to stack 
2109			 
2109			; push token to stack to end of word 
2109			 
2109				STACKFRAME ON $1efe $2f9f 
2109				if DEBUG_STACK_IMB 
2109					if ON 
2109						exx 
2109						ld de, $1efe 
2109						ld a, d 
2109						ld hl, curframe 
2109						call hexout 
2109						ld a, e 
2109						ld hl, curframe+2 
2109						call hexout 
2109						ld hl, $1efe 
2109						push hl 
2109						ld hl, $2f9f 
2109						push hl 
2109						exx 
2109					endif 
2109				endif 
2109			endm 
# End of macro STACKFRAME
2109			 
2109 2a c5 e5		ld hl,(os_tok_ptr) 
210c cd bd 1d		call forth_apush 
210f			 
210f				STACKFRAMECHK ON $1efe $2f9f 
210f				if DEBUG_STACK_IMB 
210f					if ON 
210f						exx 
210f						ld hl, $2f9f 
210f						pop de   ; $2f9f 
210f						call cmp16 
210f						jr nz, .spnosame 
210f						ld hl, $1efe 
210f						pop de   ; $1efe 
210f						call cmp16 
210f						jr z, .spfrsame 
210f						.spnosame: call showsperror 
210f						.spfrsame: nop 
210f						exx 
210f					endif 
210f				endif 
210f			endm 
# End of macro STACKFRAMECHK
210f			 
210f			execnext: 
210f			 
210f			if DEBUG_FORTH_PARSE_KEY 
210f						DMARK "KY>" 
210f			endif 
210f			; move past token to next word 
210f			 
210f 2a c5 e5		ld hl, (os_tok_ptr) 
2112 3e 00		ld a, 0 
2114 01 ff 00		ld bc, 255     ; input buffer size 
2117 ed b1		cpir 
2119			 
2119			if DEBUG_FORTH_PARSE_KEY 
2119						DMARK "KY!" 
2119				CALLMONITOR 
2119			endif	 
2119			; TODO this might place hl on the null, so will need to forward on??? 
2119			;inc hl   ; see if this gets onto the next item 
2119			 
2119			 
2119			; TODO pass a pointer to the buffer to push 
2119			; TODO call function to push 
2119			 
2119			; look for end of input 
2119			 
2119			;inc hl 
2119			;ld a,(hl) 
2119			;cp FORTH_END_BUFFER 
2119			;ret z 
2119			 
2119			 
2119 c3 92 20		jp exec1 
211c			 
211c			 
211c			 
211c			 
211c			 
211c			 
211c			 
211c			 
211c			 
211c			findnexttok: 
211c			 
211c				; hl is pointer to move 
211c				; de is the token to locate 
211c			 
211c					if DEBUG_FORTH 
211c						DMARK "NTK" 
211c						CALLMONITOR 
211c					endif 
211c d5				push de 
211d			 
211d			.fnt1:	 
211d				; find first char of token to locate 
211d			 
211d 1a				ld a, (de) 
211e 4f				ld c,a 
211f 7e				ld a,(hl) 
2120 cd 3c 12			call toUpper 
2123					if DEBUG_FORTH 
2123						DMARK "NT1" 
2123						CALLMONITOR 
2123					endif 
2123 b9				cp c 
2124			 
2124 28 03			jr z, .fnt2cmpmorefirst	 
2126			 
2126				; first char not found move to next char 
2126			 
2126 23				inc hl 
2127 18 f4			jr .fnt1 
2129			 
2129			.fnt2cmpmorefirst:	 
2129				; first char of token found.  
2129			 
2129 e5				push hl     ; save start of token just in case it is the right one 
212a d9				exx 
212b e1				pop hl        ; save it to hl' 
212c d9				exx 
212d			 
212d			 
212d			.fnt2cmpmore:	 
212d				; compare the rest 
212d				 
212d 23				inc hl 
212e 13				inc de 
212f				 
212f 1a				ld a, (de) 
2130 4f				ld c,a 
2131 7e				ld a,(hl) 
2132 cd 3c 12			call toUpper 
2135			 
2135					if DEBUG_FORTH 
2135						DMARK "NT2" 
2135						CALLMONITOR 
2135					endif 
2135				; c has the token to find char 
2135				; a has the mem to scan char 
2135			 
2135 b9				cp c 
2136 28 04			jr z,.fntmatch1 
2138			 
2138				; they are not the same 
2138			 
2138					if DEBUG_FORTH 
2138						DMARK "NT3" 
2138						CALLMONITOR 
2138					endif 
2138 d1				pop de	; reset de token to look for 
2139 d5				push de 
213a 18 e1			jr .fnt1 
213c				 
213c			.fntmatch1: 
213c			 
213c				; is the same char a null which means we might have a full hit? 
213c					if DEBUG_FORTH 
213c						DMARK "NT4" 
213c						CALLMONITOR 
213c					endif 
213c			 
213c fe 00			cp 0 
213e 28 0b			jr z, .fntmatchyes 
2140			 
2140				; are we at the end of the token to find? 
2140			 
2140					if DEBUG_FORTH 
2140						DMARK "NT5" 
2140						CALLMONITOR 
2140					endif 
2140 3e 00			ld a, 0 
2142 b9				cp c 
2143			 
2143 c2 2d 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2146			 
2146					if DEBUG_FORTH 
2146						DMARK "NT6" 
2146						CALLMONITOR 
2146					endif 
2146				; token to find is exhusted but no match to stream 
2146			 
2146				; restore tok pointer and continue on 
2146 d1				pop de 
2147 d5				push de 
2148 c3 1d 21			jp .fnt1 
214b			 
214b			 
214b			.fntmatchyes: 
214b			 
214b				; hl now contains the end of the found token 
214b			 
214b				; get rid of saved token pointer to find 
214b			 
214b d1				pop de 
214c			 
214c					if DEBUG_FORTH 
214c						DMARK "NT9" 
214c						CALLMONITOR 
214c					endif 
214c			 
214c				; hl will be on the null term so forward on 
214c			 
214c				; get back the saved start of the token 
214c			 
214c d9				exx 
214d e5				push hl     ; save start of token just in case it is the right one 
214e d9				exx 
214f e1				pop hl        ; save it to hl 
2150			 
2150 c9				ret 
2151			 
2151			 
2151			; LIST needs to find a specific token   
2151			; FORGET needs to find a spefici token 
2151			 
2151			; SAVE needs to find all tokens by flag 
2151			; WORDS just needs to scan through all  by flag 
2151			; UWORDS needs to scan through all by flag 
2151			 
2151			 
2151			; given hl as pointer to start of dict look up string 
2151			; return hl as pointer to start of word block 
2151			; or 0 if not found 
2151			 
2151			forth_find_tok: 
2151 c9				ret 
2152			 
2152			; given hl as pointer to dict structure 
2152			; move to the next dict block structure 
2152			 
2152			forth_tok_next: 
2152				; hl now points to the address of the next word pointer  
2152				; TODO skip compiled symbol for now 
2152			;	push de 
2152 23				inc hl 
2153 5e				ld e, (hl) 
2154 23				inc hl 
2155 56				ld d, (hl) 
2156 23				inc hl 
2157			 
2157 eb				ex de,hl 
2158			if DEBUG_FORTH_PARSE_NEXTWORD 
2158				push bc 
2158				ld bc, (cli_nextword) 
2158						DMARK "NXW" 
2158				CALLMONITOR 
2158				pop bc 
2158			endif 
2158			;	pop de	 
2158 c9				ret 
2159			 
2159			 
2159			 
2159			; eof 
# End of file forth_parserv5.asm
2159				include "forth_wordsv4.asm" 
2159			 
2159			; the core word dictionary v4 
2159			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2159			 
2159			; this is a linked list for each of the system words used 
2159			; user defined words will follow the same format but will be in ram 
2159			 
2159			 
2159			; 
2159			; 
2159			; define linked list: 
2159			; 
2159			; 1. compiled byte op code 
2159			; 2. len of text word 
2159			; 3. text word 
2159			; 4. ptr to next dictionary word 
2159			; 5. asm, calls etc for the word 
2159			; 
2159			;  if 1 == 0 then last word in dict  
2159			;   
2159			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2159			;  
2159			;  
2159			; create basic standard set of words 
2159			; 
2159			;  
2159			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2159			; 2DUP 2DROP 2SWAP  
2159			; @ C@ - get byte  
2159			; ! C! - store byte 
2159			; 0< true if less than zero 
2159			; 0= true if zero 
2159			; < >  
2159			; = true if same 
2159			; variables 
2159			 
2159			 
2159			; Hardware specific words I may need 
2159			; 
2159			; IN OUT  
2159			; calls to key util functions 
2159			; calls to hardward abstraction stuff 
2159			; easy control of frame buffers and lcd i/o 
2159			; keyboard  
2159			 
2159			 
2159			;DICT: macro 
2159			; op_code, len, word, next 
2159			;    word: 
2159			;    db op_code 
2159			;    ds word zero term 
2159			;    dw next 
2159			;    endm 
2159			 
2159			 
2159			 
2159			 
2159			; op code 1 is a flag for user define words which are to be handled differently 
2159			 
2159			 
2159			; 
2159			; 
2159			;    TODO on entry to a word this should be the expected environment 
2159			;    hl - tos value if number then held, if string this is the ptr 
2159			;    de -  
2159			 
2159			 
2159			; opcode ranges 
2159			; 0 - end of word dict 
2159			; 255 - user define words 
2159			 
2159			sysdict: 
2159			include "forth_opcodes.asm" 
2159			; op codes for forth keywords 
2159			; free to use code 0  
2159				OPCODE_HEAP: equ  1 
2159				OPCODE_EXEC: equ 2 
2159				OPCODE_DUP: equ 3 
2159				OPCODE_SWAP: equ 4 
2159				OPCODE_COLN: equ 5 
2159				OPCODE_SCOLN: equ 6 
2159				OPCODE_DROP: equ 7 
2159				OPCODE_DUP2: equ 8 
2159				OPCODE_DROP2: equ 9 
2159				OPCODE_SWAP2: equ 10 
2159				OPCODE_AT: equ 11 
2159				OPCODE_CAT: equ 12 
2159				OPCODE_BANG: equ 13 
2159				OPCODE_CBANG: equ 14 
2159				OPCODE_SCALL: equ 15 
2159				OPCODE_DEPTH: equ 16 
2159				OPCODE_OVER: equ 17 
2159				OPCODE_PAUSE: equ 18 
2159				OPCODE_PAUSES: equ 19 
2159				OPCODE_ROT: equ 20 
2159			;free to reuse	OPCODE_WORDS: equ 21 
2159			        OPCODE_NOT: equ 21 
2159				OPCODE_UWORDS: equ 22 
2159				OPCODE_BP: equ 23 
2159				OPCODE_MONITOR: equ 24  
2159				OPCODE_MALLOC: equ 25 
2159				OPCODE_FREE: equ 26 
2159				OPCODE_LIST: equ 27 
2159				OPCODE_FORGET: equ 28 
2159				OPCODE_NOP: equ 29 
2159				OPCODE_COMO: equ 30 
2159				OPCODE_COMC: equ 31 
2159			;free to reuse	OPCODE_ENDCORE: equ 32 
2159				OPCODE_AFTERSOUND: equ 33 
2159				OPCODE_GP2: equ 34 
2159				OPCODE_GP3: equ 35 
2159				OPCODE_GP4: equ 36 
2159				OPCODE_SIN: equ 37 
2159				OPCODE_SOUT: equ 38 
2159				OPCODE_SPIO: equ 39 
2159				OPCODE_SPICEH: equ 40 
2159				OPCODE_SPIOb: equ 41 
2159				OPCODE_SPII: equ 42 
2159				OPCODE_SESEL: equ 43 
2159				OPCODE_CARTDEV: equ 44 
2159			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2159				OPCODE_FB: equ 46 
2159				OPCODE_EMIT: equ 47 
2159				OPCODE_DOTH: equ 48 
2159				OPCODE_DOTF: equ 49 
2159				OPCODE_DOT: equ 50 
2159				OPCODE_CLS: equ 51 
2159				OPCODE_DRAW: equ 52 
2159				OPCODE_DUMP: equ 53 
2159				OPCODE_CDUMP: equ 54 
2159				OPCODE_DAT: equ 55 
2159				OPCODE_HOME: equ 56 
2159				OPCODE_SPACE: equ 57 
2159				OPCODE_SPACES: equ 58 
2159				OPCODE_SCROLL: equ 59 
2159				OPCODE_ATQ: equ 60 
2159				OPCODE_AUTODSP: equ 61 
2159				OPCODE_MENU: equ 62 
2159			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2159				OPCODE_THEN: equ 64 
2159				OPCODE_ELSE: equ 65 
2159				OPCODE_DO: equ 66 
2159				OPCODE_LOOP: equ 67 
2159				OPCODE_I: equ 68 
2159				OPCODE_DLOOP: equ 69  
2159				OPCODE_REPEAT: equ 70  
2159				OPCODE_UNTIL: equ 71 
2159				OPCODE_ENDFLOW: equ 72 
2159				OPCODE_WAITK: equ 73 
2159				OPCODE_ACCEPT: equ 74 
2159				OPCODE_EDIT: equ 75 
2159			;free to reuse	OPCODE_ENDKEY: equ 76 
2159				OPCODE_LZERO: equ 77 
2159				OPCODE_TZERO: equ 78 
2159				OPCODE_LESS: equ 79 
2159				OPCODE_GT: equ 80 
2159				OPCODE_EQUAL: equ 81  
2159			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2159				OPCODE_NEG: equ 83 
2159				OPCODE_DIV: equ 84 
2159				OPCODE_MUL: equ 85 
2159				OPCODE_MIN: equ 86 
2159				OPCODE_MAX: equ 87 
2159				OPCODE_RND16: equ 88 
2159				OPCODE_RND8: equ 89 
2159				OPCODE_RND: equ 90 
2159			;free to reuse	OPCODE_ENDMATHS: equ 91  
2159				OPCODE_BYNAME: equ 92 
2159				OPCODE_DIR: equ 93 
2159				OPCODE_SAVE: equ 94 
2159				OPCODE_LOAD: equ 95 
2159				OPCODE_BSAVE: equ 96 
2159				OPCODE_BLOAD: equ 97 
2159				OPCODE_SEO: equ 98  
2159				OPCODE_SEI: equ 99 
2159				OPCODE_SFREE: equ 100 
2159				OPCODE_SIZE: equ 101 
2159				OPCODE_CREATE: equ 102 
2159				OPCODE_APPEND: equ 103 
2159				OPCODE_SDEL: equ 104 
2159				OPCODE_OPEN: equ 105 
2159				OPCODE_READ: equ 106 
2159				OPCODE_EOF: equ 106 
2159				OPCODE_FORMAT: equ 107 
2159				OPCODE_LABEL: equ 108 
2159				OPCODE_LABELS: equ 109 
2159			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2159				OPCODE_UPPER: equ 111 
2159				OPCODE_LOWER: equ 112 
2159				OPCODE_SUBSTR: equ 113 
2159				OPCODE_LEFT: equ 114 
2159				OPCODE_RIGHT: equ 115 
2159				OPCODE_STR2NUM: equ 116 
2159				OPCODE_NUM2STR: equ 117 
2159				OPCODE_CONCAT: equ 118 
2159				OPCODE_FIND: equ 119 
2159				OPCODE_LEN: equ 120 
2159				OPCODE_CHAR: equ 121 
2159			; free to reuse	OPCODE_STRLEN: equ 122 
2159			; free to reuse	OPCODE_ENDSTR: equ 123 
2159				OPCODE_V0S: equ 124 
2159				OPCODE_V0Q: equ 125 
2159				OPCODE_V1S: equ 126 
2159				OPCODE_V1Q: equ 127 
2159				OPCODE_V2S: equ 128 
2159				OPCODE_V2Q: equ 129 
2159				OPCODE_V3S: equ 130 
2159				OPCODE_V3Q: equ 131 
2159			;free to reuse	OPCODE_END: equ 132 
2159				OPCODE_ZDUP: equ 133 
2159			 
2159			; eof 
# End of file forth_opcodes.asm
2159			 
2159			include "forth_words_core.asm" 
2159			 
2159			; | ## Core Words 
2159			 
2159			;if MALLOC_4 
2159			 
2159			.HEAP: 
2159				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2159 15				db WORD_SYS_CORE+OPCODE_HEAP             
215a 98 21			dw .EXEC            
215c 05				db 4 + 1 
215d .. 00			db "HEAP",0              
2162				endm 
# End of macro CWHEAD
2162			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2162			; | | u1 - Current number of bytes in the heap 
2162			; | | u2 - Remaining bytes left on the heap 
2162			; | |  
2162			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2162			 
2162			 
2162					if DEBUG_FORTH_WORDS_KEY 
2162						DMARK "HEP" 
2162 f5				push af  
2163 3a 77 21			ld a, (.dmark)  
2166 32 6e ee			ld (debug_mark),a  
2169 3a 78 21			ld a, (.dmark+1)  
216c 32 6f ee			ld (debug_mark+1),a  
216f 3a 79 21			ld a, (.dmark+2)  
2172 32 70 ee			ld (debug_mark+2),a  
2175 18 03			jr .pastdmark  
2177 ..			.dmark: db "HEP"  
217a f1			.pastdmark: pop af  
217b			endm  
# End of macro DMARK
217b						CALLMONITOR 
217b cd 72 ee			call debug_vector  
217e				endm  
# End of macro CALLMONITOR
217e					endif 
217e 2a b8 64				ld hl, (free_list )      
2181 11 bd 64				ld de, heap_start 
2184			 
2184 ed 52				sbc hl, de  
2186			 
2186 cd 54 1c				call forth_push_numhl 
2189			 
2189			 
2189 ed 5b b8 64			ld de, (free_list )      
218d 21 ab e2				ld hl, heap_end 
2190			 
2190 ed 52				sbc hl, de 
2192			 
2192 cd 54 1c				call forth_push_numhl 
2195					 
2195			 
2195					 
2195			 
2195			 
2195			 
2195					NEXTW 
2195 c3 01 20			jp macro_next 
2198				endm 
# End of macro NEXTW
2198			;endif 
2198			 
2198			.EXEC: 
2198			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2198			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2198			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2198			;; > > 
2198			;; > >   
2198			;	STACKFRAME OFF $5efe $5f9f 
2198			; 
2198			;		if DEBUG_FORTH_WORDS_KEY 
2198			;			DMARK "EXE" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			; 
2198			;	FORTH_DSP_VALUEHL 
2198			; 
2198			;	FORTH_DSP_POP 
2198			; 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EX1" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;;	ld e,(hl) 
2198			;;	inc hl 
2198			;;	ld d,(hl) 
2198			;;	ex de,hl 
2198			; 
2198			;;		if DEBUG_FORTH_WORDS 
2198			;;			DMARK "EX2" 
2198			;;			CALLMONITOR 
2198			;;		endif 
2198			;	push hl 
2198			; 
2198			;	;ld a, 0 
2198			;	;ld a, FORTH_END_BUFFER 
2198			;	call strlenz 
2198			;	inc hl   ; include zero term to copy 
2198			;	inc hl   ; include term 
2198			;	inc hl   ; include term 
2198			;	ld b,0 
2198			;	ld c,l 
2198			;	pop hl 
2198			;	ld de, execscratch 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EX3" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;	ldir 
2198			; 
2198			; 
2198			;	ld hl, execscratch 
2198			; 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EXe" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			; 
2198			;	call forthparse 
2198			;	call forthexec 
2198			;;	call forthexec_cleanup 
2198			;;	call forthparse 
2198			;;	call forthexec 
2198			; 
2198			;	STACKFRAMECHK OFF $5efe $5f9f 
2198			; 
2198			;	; an immediate word so no need to process any more words 
2198			;	ret 
2198			;	NEXTW 
2198			 
2198			; dead code - old version  
2198			;	FORTH_RSP_NEXT 
2198			 
2198			;  
2198			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2198			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2198			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2198			;	push hl 
2198			;	push de 
2198			;	push bc 
2198			; 
2198			; 
2198			;		if DEBUG_FORTH_WORDS_KEY 
2198			;			DMARK "EXR" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			; 
2198			; 
2198			; 
2198			;	;v5 FORTH_DSP_VALUE 
2198			;	FORTH_DSP_VALUEHL 
2198			; 
2198			;	; TODO do string type checks 
2198			; 
2198			;;v5	inc hl   ; skip type 
2198			; 
2198			;	push hl  ; source code  
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EX1" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;	ld a, 0 
2198			;	call strlent 
2198			; 
2198			;	inc hl 
2198			;	inc hl 
2198			;	inc hl 
2198			;	inc hl 
2198			; 
2198			;	push hl    ; size 
2198			; 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EX2" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;	call malloc 
2198			; 
2198			;	ex de, hl    ; de now contains malloc area 
2198			;	pop bc   	; get byte count 
2198			;	pop hl      ; get string to copy 
2198			; 
2198			;	push de     ; save malloc for free later 
2198			; 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EX3" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;	ldir       ; duplicate string 
2198			; 
2198			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2198			;	 
2198			;	; TODO fix the parse would be better than this...  
2198			;	ex de, hl 
2198			;	dec hl 
2198			;	ld a, 0 
2198			;	ld (hl), a 
2198			;	dec hl 
2198			;	ld a, ' ' 
2198			;	ld (hl), a 
2198			;	dec hl 
2198			;	ld (hl), a 
2198			; 
2198			;	dec hl 
2198			;	ld (hl), a 
2198			; 
2198			; 
2198			;	FORTH_DSP_POP  
2198			; 
2198			;	pop hl     
2198			;	push hl    ; save malloc area 
2198			; 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EX4" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			; 
2198			;	call forthparse 
2198			;	call forthexec 
2198			;	 
2198			;	pop hl 
2198			;	if DEBUG_FORTH_WORDS 
2198			;		DMARK "EX5" 
2198			;		CALLMONITOR 
2198			;	endif 
2198			; 
2198			;	if FORTH_ENABLE_FREE 
2198			;	call free 
2198			;	endif 
2198			; 
2198			;	if DEBUG_FORTH_WORDS 
2198			;		DMARK "EX6" 
2198			;		CALLMONITOR 
2198			;	endif 
2198			; 
2198			;	pop bc 
2198			;	pop de 
2198			;	pop hl 
2198			;;	FORTH_RSP_POP	  
2198			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2198			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2198			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2198			; 
2198			;	if DEBUG_FORTH_WORDS 
2198			;		DMARK "EX7" 
2198			;		CALLMONITOR 
2198			;	endif 
2198			;	NEXTW 
2198			 
2198			;.STKEXEC: 
2198			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2198			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2198			; 
2198			; 
2198			;		if DEBUG_FORTH_WORDS_KEY 
2198			;			DMARK "STX" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			; 
2198			;	FORTH_DSP_VALUEHL 
2198			; 
2198			;	ld (store_tmp1), hl    ; count 
2198			; 
2198			;	FORTH_DSP_POP 
2198			;.stkexec1: 
2198			;	ld hl, (store_tmp1)   ; count 
2198			;	ld a, 0 
2198			;	cp l 
2198			;	ret z 
2198			; 
2198			;	dec hl 
2198			;	ld (store_tmp1), hl    ; count 
2198			;	 
2198			;	FORTH_DSP_VALUEHL 
2198			;	push hl 
2198			;	 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EXp" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;	FORTH_DSP_POP 
2198			; 
2198			;	call strlenz 
2198			;	inc hl   ; include zero term to copy 
2198			;	inc hl   ; include zero term to copy 
2198			;	inc hl   ; include zero term to copy 
2198			;	ld b,0 
2198			;	ld c,l 
2198			;	pop hl 
2198			;	ld de, execscratch 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EX3" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;	ldir 
2198			; 
2198			; 
2198			;	ld hl, execscratch 
2198			; 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EXP" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			; 
2198			;	call forthparse 
2198			;	ld hl, execscratch 
2198			;		if DEBUG_FORTH_WORDS 
2198			;			DMARK "EXx" 
2198			;			CALLMONITOR 
2198			;		endif 
2198			;	call forthexec 
2198			; 
2198			;	jp .stkexec1 
2198			; 
2198			;	ret 
2198			 
2198			 
2198			.DUP: 
2198				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2198 17				db WORD_SYS_CORE+OPCODE_DUP             
2199 0e 22			dw .ZDUP            
219b 04				db 3 + 1 
219c .. 00			db "DUP",0              
21a0				endm 
# End of macro CWHEAD
21a0			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21a0			 
21a0					if DEBUG_FORTH_WORDS_KEY 
21a0						DMARK "DUP" 
21a0 f5				push af  
21a1 3a b5 21			ld a, (.dmark)  
21a4 32 6e ee			ld (debug_mark),a  
21a7 3a b6 21			ld a, (.dmark+1)  
21aa 32 6f ee			ld (debug_mark+1),a  
21ad 3a b7 21			ld a, (.dmark+2)  
21b0 32 70 ee			ld (debug_mark+2),a  
21b3 18 03			jr .pastdmark  
21b5 ..			.dmark: db "DUP"  
21b8 f1			.pastdmark: pop af  
21b9			endm  
# End of macro DMARK
21b9						CALLMONITOR 
21b9 cd 72 ee			call debug_vector  
21bc				endm  
# End of macro CALLMONITOR
21bc					endif 
21bc			 
21bc					FORTH_DSP 
21bc cd 11 1e			call macro_forth_dsp 
21bf				endm 
# End of macro FORTH_DSP
21bf			 
21bf 7e					ld a, (HL) 
21c0 fe 01				cp DS_TYPE_STR 
21c2 20 25				jr nz, .dupinum 
21c4			 
21c4					; push another string 
21c4			 
21c4					FORTH_DSP_VALUEHL     		 
21c4 cd 4b 1e			call macro_dsp_valuehl 
21c7				endm 
# End of macro FORTH_DSP_VALUEHL
21c7			 
21c7				if DEBUG_FORTH_WORDS 
21c7					DMARK "DUs" 
21c7 f5				push af  
21c8 3a dc 21			ld a, (.dmark)  
21cb 32 6e ee			ld (debug_mark),a  
21ce 3a dd 21			ld a, (.dmark+1)  
21d1 32 6f ee			ld (debug_mark+1),a  
21d4 3a de 21			ld a, (.dmark+2)  
21d7 32 70 ee			ld (debug_mark+2),a  
21da 18 03			jr .pastdmark  
21dc ..			.dmark: db "DUs"  
21df f1			.pastdmark: pop af  
21e0			endm  
# End of macro DMARK
21e0					CALLMONITOR 
21e0 cd 72 ee			call debug_vector  
21e3				endm  
# End of macro CALLMONITOR
21e3				endif 
21e3 cd c2 1c				call forth_push_str 
21e6			 
21e6					NEXTW 
21e6 c3 01 20			jp macro_next 
21e9				endm 
# End of macro NEXTW
21e9			 
21e9			 
21e9			.dupinum: 
21e9					 
21e9			 
21e9			 
21e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21e9 cd 4b 1e			call macro_dsp_valuehl 
21ec				endm 
# End of macro FORTH_DSP_VALUEHL
21ec			 
21ec				; TODO add floating point number detection 
21ec			 
21ec				if DEBUG_FORTH_WORDS 
21ec					DMARK "DUi" 
21ec f5				push af  
21ed 3a 01 22			ld a, (.dmark)  
21f0 32 6e ee			ld (debug_mark),a  
21f3 3a 02 22			ld a, (.dmark+1)  
21f6 32 6f ee			ld (debug_mark+1),a  
21f9 3a 03 22			ld a, (.dmark+2)  
21fc 32 70 ee			ld (debug_mark+2),a  
21ff 18 03			jr .pastdmark  
2201 ..			.dmark: db "DUi"  
2204 f1			.pastdmark: pop af  
2205			endm  
# End of macro DMARK
2205					CALLMONITOR 
2205 cd 72 ee			call debug_vector  
2208				endm  
# End of macro CALLMONITOR
2208				endif 
2208			 
2208 cd 54 1c				call forth_push_numhl 
220b					NEXTW 
220b c3 01 20			jp macro_next 
220e				endm 
# End of macro NEXTW
220e			.ZDUP: 
220e				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
220e 99				db WORD_SYS_CORE+OPCODE_ZDUP             
220f 46 22			dw .SWAP            
2211 05				db 4 + 1 
2212 .. 00			db "?DUP",0              
2217				endm 
# End of macro CWHEAD
2217			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2217			 
2217					if DEBUG_FORTH_WORDS_KEY 
2217						DMARK "qDU" 
2217 f5				push af  
2218 3a 2c 22			ld a, (.dmark)  
221b 32 6e ee			ld (debug_mark),a  
221e 3a 2d 22			ld a, (.dmark+1)  
2221 32 6f ee			ld (debug_mark+1),a  
2224 3a 2e 22			ld a, (.dmark+2)  
2227 32 70 ee			ld (debug_mark+2),a  
222a 18 03			jr .pastdmark  
222c ..			.dmark: db "qDU"  
222f f1			.pastdmark: pop af  
2230			endm  
# End of macro DMARK
2230						CALLMONITOR 
2230 cd 72 ee			call debug_vector  
2233				endm  
# End of macro CALLMONITOR
2233					endif 
2233					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2233 cd 4b 1e			call macro_dsp_valuehl 
2236				endm 
# End of macro FORTH_DSP_VALUEHL
2236			 
2236 e5					push hl 
2237			 
2237					; is it a zero? 
2237			 
2237 3e 00				ld a, 0 
2239 84					add h 
223a 85					add l 
223b			 
223b e1					pop hl 
223c			 
223c fe 00				cp 0 
223e 28 03				jr z, .dup2orig 
2240			 
2240			 
2240 cd 54 1c				call forth_push_numhl 
2243			 
2243			 
2243				; TODO add floating point number detection 
2243			 
2243			.dup2orig: 
2243			 
2243					NEXTW 
2243 c3 01 20			jp macro_next 
2246				endm 
# End of macro NEXTW
2246			.SWAP: 
2246				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2246 18				db WORD_SYS_CORE+OPCODE_SWAP             
2247 85 22			dw .COLN            
2249 05				db 4 + 1 
224a .. 00			db "SWAP",0              
224f				endm 
# End of macro CWHEAD
224f			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
224f					if DEBUG_FORTH_WORDS_KEY 
224f						DMARK "SWP" 
224f f5				push af  
2250 3a 64 22			ld a, (.dmark)  
2253 32 6e ee			ld (debug_mark),a  
2256 3a 65 22			ld a, (.dmark+1)  
2259 32 6f ee			ld (debug_mark+1),a  
225c 3a 66 22			ld a, (.dmark+2)  
225f 32 70 ee			ld (debug_mark+2),a  
2262 18 03			jr .pastdmark  
2264 ..			.dmark: db "SWP"  
2267 f1			.pastdmark: pop af  
2268			endm  
# End of macro DMARK
2268						CALLMONITOR 
2268 cd 72 ee			call debug_vector  
226b				endm  
# End of macro CALLMONITOR
226b					endif 
226b			 
226b					FORTH_DSP_VALUEHL 
226b cd 4b 1e			call macro_dsp_valuehl 
226e				endm 
# End of macro FORTH_DSP_VALUEHL
226e e5					push hl     ; w2 
226f			 
226f					FORTH_DSP_POP 
226f cd 03 1f			call macro_forth_dsp_pop 
2272				endm 
# End of macro FORTH_DSP_POP
2272			 
2272					FORTH_DSP_VALUEHL 
2272 cd 4b 1e			call macro_dsp_valuehl 
2275				endm 
# End of macro FORTH_DSP_VALUEHL
2275			 
2275					FORTH_DSP_POP 
2275 cd 03 1f			call macro_forth_dsp_pop 
2278				endm 
# End of macro FORTH_DSP_POP
2278			 
2278 d1					pop de     ; w2	, hl = w1 
2279			 
2279 eb					ex de, hl 
227a d5					push de 
227b			 
227b cd 54 1c				call forth_push_numhl 
227e			 
227e e1					pop hl 
227f			 
227f cd 54 1c				call forth_push_numhl 
2282					 
2282			 
2282					NEXTW 
2282 c3 01 20			jp macro_next 
2285				endm 
# End of macro NEXTW
2285			.COLN: 
2285				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2285 19				db WORD_SYS_CORE+OPCODE_COLN             
2286 11 24			dw .SCOLN            
2288 02				db 1 + 1 
2289 .. 00			db ":",0              
228b				endm 
# End of macro CWHEAD
228b			; | : ( -- )         Create new word | DONE 
228b			 
228b					if DEBUG_FORTH_WORDS_KEY 
228b						DMARK "CLN" 
228b f5				push af  
228c 3a a0 22			ld a, (.dmark)  
228f 32 6e ee			ld (debug_mark),a  
2292 3a a1 22			ld a, (.dmark+1)  
2295 32 6f ee			ld (debug_mark+1),a  
2298 3a a2 22			ld a, (.dmark+2)  
229b 32 70 ee			ld (debug_mark+2),a  
229e 18 03			jr .pastdmark  
22a0 ..			.dmark: db "CLN"  
22a3 f1			.pastdmark: pop af  
22a4			endm  
# End of macro DMARK
22a4						CALLMONITOR 
22a4 cd 72 ee			call debug_vector  
22a7				endm  
# End of macro CALLMONITOR
22a7					endif 
22a7				STACKFRAME OFF $8efe $989f 
22a7				if DEBUG_STACK_IMB 
22a7					if OFF 
22a7						exx 
22a7						ld de, $8efe 
22a7						ld a, d 
22a7						ld hl, curframe 
22a7						call hexout 
22a7						ld a, e 
22a7						ld hl, curframe+2 
22a7						call hexout 
22a7						ld hl, $8efe 
22a7						push hl 
22a7						ld hl, $989f 
22a7						push hl 
22a7						exx 
22a7					endif 
22a7				endif 
22a7			endm 
# End of macro STACKFRAME
22a7				; get parser buffer length  of new word 
22a7			 
22a7				 
22a7			 
22a7					; move tok past this to start of name defintition 
22a7					; TODO get word to define 
22a7					; TODO Move past word token 
22a7					; TODO get length of string up to the ';' 
22a7			 
22a7 2a c5 e5			ld hl, (os_tok_ptr) 
22aa 23				inc hl 
22ab 23				inc hl 
22ac			 
22ac 3e 3b			ld a, ';' 
22ae cd 50 12			call strlent 
22b1			 
22b1 7d				ld a,l 
22b2 32 c0 e2			ld (os_new_parse_len), a 
22b5			 
22b5			 
22b5			if DEBUG_FORTH_UWORD 
22b5 ed 5b c5 e5		ld de, (os_tok_ptr) 
22b9						DMARK ":01" 
22b9 f5				push af  
22ba 3a ce 22			ld a, (.dmark)  
22bd 32 6e ee			ld (debug_mark),a  
22c0 3a cf 22			ld a, (.dmark+1)  
22c3 32 6f ee			ld (debug_mark+1),a  
22c6 3a d0 22			ld a, (.dmark+2)  
22c9 32 70 ee			ld (debug_mark+2),a  
22cc 18 03			jr .pastdmark  
22ce ..			.dmark: db ":01"  
22d1 f1			.pastdmark: pop af  
22d2			endm  
# End of macro DMARK
22d2				CALLMONITOR 
22d2 cd 72 ee			call debug_vector  
22d5				endm  
# End of macro CALLMONITOR
22d5			endif 
22d5			 
22d5			; 
22d5			;  new word memory layout: 
22d5			;  
22d5			;    : adg 6666 ;  
22d5			; 
22d5			;    db   1     ; user defined word  
22d5 23				inc hl    
22d6			;    dw   sysdict 
22d6 23				inc hl 
22d7 23				inc hl 
22d8			;    db <word len>+1 (for null) 
22d8 23				inc hl 
22d9			;    db .... <word> 
22d9			; 
22d9			 
22d9 23				inc hl    ; some extras for the word preamble before the above 
22da 23				inc hl 
22db 23				inc hl 
22dc 23				inc hl 
22dd 23				inc hl 
22de 23				inc hl 
22df 23				inc hl  
22e0 23				inc hl 
22e1 23				inc hl 
22e2 23				inc hl 
22e3 23				inc hl 
22e4 23				inc hl 
22e5 23				inc hl 
22e6 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22e7			;       exec word buffer 
22e7			;	<ptr word>   
22e7 23				inc hl 
22e8 23				inc hl 
22e9			;       <word list><null term> 7F final term 
22e9			 
22e9			 
22e9			if DEBUG_FORTH_UWORD 
22e9						DMARK ":02" 
22e9 f5				push af  
22ea 3a fe 22			ld a, (.dmark)  
22ed 32 6e ee			ld (debug_mark),a  
22f0 3a ff 22			ld a, (.dmark+1)  
22f3 32 6f ee			ld (debug_mark+1),a  
22f6 3a 00 23			ld a, (.dmark+2)  
22f9 32 70 ee			ld (debug_mark+2),a  
22fc 18 03			jr .pastdmark  
22fe ..			.dmark: db ":02"  
2301 f1			.pastdmark: pop af  
2302			endm  
# End of macro DMARK
2302				CALLMONITOR 
2302 cd 72 ee			call debug_vector  
2305				endm  
# End of macro CALLMONITOR
2305			endif 
2305			 
2305				 
2305					; malloc the size 
2305			 
2305 cd ae 12				call malloc 
2308 22 c2 e2				ld (os_new_malloc), hl     ; save malloc start 
230b			 
230b			;    db   1     ; user defined word  
230b 3e 01				ld a, WORD_SYS_UWORD  
230d 77					ld (hl), a 
230e				 
230e 23				inc hl    
230f			;    dw   sysdict 
230f 11 59 21			ld de, sysdict       ; continue on with the scan to the system dict 
2312 73				ld (hl), e 
2313 23				inc hl 
2314 72				ld (hl), d 
2315 23				inc hl 
2316			 
2316			 
2316			;    Setup dict word 
2316			 
2316 23				inc hl 
2317 22 bc e2			ld (os_new_work_ptr), hl     ; save start of dict word  
231a			 
231a				; 1. get length of dict word 
231a			 
231a			 
231a 2a c5 e5			ld hl, (os_tok_ptr) 
231d 23				inc hl 
231e 23				inc hl    ; position to start of dict word 
231f 3e 00			ld a, 0 
2321 cd 50 12			call strlent 
2324			 
2324			 
2324 23				inc hl    ; to include null??? 
2325			 
2325				; write length of dict word 
2325			 
2325 ed 5b bc e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2329 1b				dec de 
232a eb				ex de, hl 
232b 73				ld (hl), e 
232c eb				ex de, hl 
232d			 
232d				 
232d			 
232d				; copy  
232d 4d				ld c, l 
232e 06 00			ld b, 0 
2330 ed 5b bc e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2334 2a c5 e5			ld hl, (os_tok_ptr) 
2337 23				inc hl 
2338 23				inc hl    ; position to start of dict word 
2339				 
2339			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2339				 
2339				; TODO need to convert word to upper case 
2339			 
2339			ucasetok:	 
2339 7e				ld a,(hl) 
233a cd 3c 12			call toUpper 
233d 77				ld (hl),a 
233e ed a0			ldi 
2340 f2 39 23		 	jp p, ucasetok 
2343			 
2343			 
2343			 
2343				; de now points to start of where the word body code should be placed 
2343 ed 53 bc e2		ld (os_new_work_ptr), de 
2347				; hl now points to the words to throw at forthexec which needs to be copied 
2347 22 ba e2			ld (os_new_src_ptr), hl 
234a			 
234a				; TODO add 'call to forthexec' 
234a			 
234a			if DEBUG_FORTH_UWORD 
234a c5				push bc 
234b ed 4b c2 e2		ld bc, (os_new_malloc) 
234f						DMARK ":0x" 
234f f5				push af  
2350 3a 64 23			ld a, (.dmark)  
2353 32 6e ee			ld (debug_mark),a  
2356 3a 65 23			ld a, (.dmark+1)  
2359 32 6f ee			ld (debug_mark+1),a  
235c 3a 66 23			ld a, (.dmark+2)  
235f 32 70 ee			ld (debug_mark+2),a  
2362 18 03			jr .pastdmark  
2364 ..			.dmark: db ":0x"  
2367 f1			.pastdmark: pop af  
2368			endm  
# End of macro DMARK
2368				CALLMONITOR 
2368 cd 72 ee			call debug_vector  
236b				endm  
# End of macro CALLMONITOR
236b c1				pop bc 
236c			endif 
236c			 
236c			 
236c				; create word preamble which should be: 
236c			 
236c			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
236c			 
236c				;    ld hl, <word code> 
236c				;    jp user_exec 
236c			        ;    <word code bytes> 
236c			 
236c			 
236c			;	inc de     ; TODO ??? or are we already past the word's null 
236c eb				ex de, hl 
236d			 
236d 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
236f			 
236f 23				inc hl 
2370 22 b6 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2373 23				inc hl 
2374			 
2374 23				inc hl 
2375 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2377			 
2377 01 3c 4c			ld bc, user_exec 
237a 23				inc hl 
237b 71				ld (hl), c     ; poke address of user_exec 
237c 23				inc hl 
237d 70				ld (hl), b     
237e			 ; 
237e			;	inc hl 
237e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
237e			; 
237e			; 
237e			;	ld bc, macro_forth_rsp_next 
237e			;	inc hl 
237e			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
237e			;	inc hl 
237e			;	ld (hl), b     
237e			 ; 
237e			;	inc hl 
237e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
237e			; 
237e			; 
237e			;	inc hl 
237e			;	ld bc, forthexec 
237e			;	ld (hl), c     ; poke address of forthexec 
237e			;	inc hl 
237e			;	ld (hl), b      
237e			; 
237e			;	inc hl 
237e			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
237e			; 
237e			;	ld bc, user_dict_next 
237e			;	inc hl 
237e			;	ld (hl), c     ; poke address of forthexec 
237e			;	inc hl 
237e			;	ld (hl), b      
237e			 
237e				; hl is now where we need to copy the word byte data to save this 
237e			 
237e 23				inc hl 
237f 22 b8 e2			ld (os_new_exec), hl 
2382				 
2382				; copy definition 
2382			 
2382 eb				ex de, hl 
2383			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2383			;	inc de    ; skip the PC for this parse 
2383 3a c0 e2			ld a, (os_new_parse_len) 
2386 4f				ld c, a 
2387 06 00			ld b, 0 
2389 ed b0			ldir		 ; copy defintion 
238b			 
238b			 
238b				; poke the address of where the new word bytes live for forthexec 
238b			 
238b 2a b6 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
238e			 
238e ed 5b b8 e2		ld de, (os_new_exec)      
2392				 
2392 73				ld (hl), e 
2393 23				inc hl 
2394 72				ld (hl), d 
2395			 
2395					; TODO copy last user dict word next link to this word 
2395					; TODO update last user dict word to point to this word 
2395			; 
2395			; hl f923 de 812a ; bc 811a 
2395			 
2395			if DEBUG_FORTH_UWORD 
2395 c5				push bc 
2396 ed 4b c2 e2		ld bc, (os_new_malloc) 
239a						DMARK ":0A" 
239a f5				push af  
239b 3a af 23			ld a, (.dmark)  
239e 32 6e ee			ld (debug_mark),a  
23a1 3a b0 23			ld a, (.dmark+1)  
23a4 32 6f ee			ld (debug_mark+1),a  
23a7 3a b1 23			ld a, (.dmark+2)  
23aa 32 70 ee			ld (debug_mark+2),a  
23ad 18 03			jr .pastdmark  
23af ..			.dmark: db ":0A"  
23b2 f1			.pastdmark: pop af  
23b3			endm  
# End of macro DMARK
23b3				CALLMONITOR 
23b3 cd 72 ee			call debug_vector  
23b6				endm  
# End of macro CALLMONITOR
23b6 c1				pop bc 
23b7			endif 
23b7			if DEBUG_FORTH_UWORD 
23b7 c5				push bc 
23b8 ed 4b c2 e2		ld bc, (os_new_malloc) 
23bc 03				inc bc 
23bd 03				inc bc 
23be 03				inc bc 
23bf 03				inc bc 
23c0 03				inc bc 
23c1 03				inc bc 
23c2 03				inc bc 
23c3 03				inc bc 
23c4			 
23c4						DMARK ":0B" 
23c4 f5				push af  
23c5 3a d9 23			ld a, (.dmark)  
23c8 32 6e ee			ld (debug_mark),a  
23cb 3a da 23			ld a, (.dmark+1)  
23ce 32 6f ee			ld (debug_mark+1),a  
23d1 3a db 23			ld a, (.dmark+2)  
23d4 32 70 ee			ld (debug_mark+2),a  
23d7 18 03			jr .pastdmark  
23d9 ..			.dmark: db ":0B"  
23dc f1			.pastdmark: pop af  
23dd			endm  
# End of macro DMARK
23dd				CALLMONITOR 
23dd cd 72 ee			call debug_vector  
23e0				endm  
# End of macro CALLMONITOR
23e0 c1				pop bc 
23e1			endif 
23e1			 
23e1			; update word dict linked list for new word 
23e1			 
23e1			 
23e1 2a c1 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23e4 23			inc hl     ; move to next work linked list ptr 
23e5			 
23e5 ed 5b c2 e2	ld de, (os_new_malloc)		 ; new next word 
23e9 73			ld (hl), e 
23ea 23			inc hl 
23eb 72			ld (hl), d 
23ec			 
23ec			if DEBUG_FORTH_UWORD 
23ec ed 4b c1 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23f0			endif 
23f0			 
23f0 ed 53 c1 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23f4			 
23f4			 
23f4			if DEBUG_FORTH_UWORD 
23f4						DMARK ":0+" 
23f4 f5				push af  
23f5 3a 09 24			ld a, (.dmark)  
23f8 32 6e ee			ld (debug_mark),a  
23fb 3a 0a 24			ld a, (.dmark+1)  
23fe 32 6f ee			ld (debug_mark+1),a  
2401 3a 0b 24			ld a, (.dmark+2)  
2404 32 70 ee			ld (debug_mark+2),a  
2407 18 03			jr .pastdmark  
2409 ..			.dmark: db ":0+"  
240c f1			.pastdmark: pop af  
240d			endm  
# End of macro DMARK
240d				CALLMONITOR 
240d cd 72 ee			call debug_vector  
2410				endm  
# End of macro CALLMONITOR
2410			endif 
2410			 
2410				STACKFRAMECHK OFF $8efe $989f 
2410				if DEBUG_STACK_IMB 
2410					if OFF 
2410						exx 
2410						ld hl, $989f 
2410						pop de   ; $989f 
2410						call cmp16 
2410						jr nz, .spnosame 
2410						ld hl, $8efe 
2410						pop de   ; $8efe 
2410						call cmp16 
2410						jr z, .spfrsame 
2410						.spnosame: call showsperror 
2410						.spfrsame: nop 
2410						exx 
2410					endif 
2410				endif 
2410			endm 
# End of macro STACKFRAMECHK
2410			 
2410 c9			ret    ; dont process any remaining parser tokens as they form new word 
2411			 
2411			 
2411			 
2411			 
2411			;		NEXT 
2411			.SCOLN: 
2411			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2411 06				db OPCODE_SCOLN 
2412 5d 24			dw .DROP 
2414 02				db 2 
2415 .. 00			db ";",0           
2417			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2417					if DEBUG_FORTH_WORDS_KEY 
2417						DMARK "SCN" 
2417 f5				push af  
2418 3a 2c 24			ld a, (.dmark)  
241b 32 6e ee			ld (debug_mark),a  
241e 3a 2d 24			ld a, (.dmark+1)  
2421 32 6f ee			ld (debug_mark+1),a  
2424 3a 2e 24			ld a, (.dmark+2)  
2427 32 70 ee			ld (debug_mark+2),a  
242a 18 03			jr .pastdmark  
242c ..			.dmark: db "SCN"  
242f f1			.pastdmark: pop af  
2430			endm  
# End of macro DMARK
2430						CALLMONITOR 
2430 cd 72 ee			call debug_vector  
2433				endm  
# End of macro CALLMONITOR
2433					endif 
2433					FORTH_RSP_TOS 
2433 cd 12 1c			call macro_forth_rsp_tos 
2436				endm 
# End of macro FORTH_RSP_TOS
2436 e5					push hl 
2437					FORTH_RSP_POP 
2437 cd 1c 1c			call macro_forth_rsp_pop 
243a				endm 
# End of macro FORTH_RSP_POP
243a e1					pop hl 
243b			;		ex de,hl 
243b 22 c5 e5				ld (os_tok_ptr),hl 
243e			 
243e			if DEBUG_FORTH_UWORD 
243e						DMARK "SCL" 
243e f5				push af  
243f 3a 53 24			ld a, (.dmark)  
2442 32 6e ee			ld (debug_mark),a  
2445 3a 54 24			ld a, (.dmark+1)  
2448 32 6f ee			ld (debug_mark+1),a  
244b 3a 55 24			ld a, (.dmark+2)  
244e 32 70 ee			ld (debug_mark+2),a  
2451 18 03			jr .pastdmark  
2453 ..			.dmark: db "SCL"  
2456 f1			.pastdmark: pop af  
2457			endm  
# End of macro DMARK
2457				CALLMONITOR 
2457 cd 72 ee			call debug_vector  
245a				endm  
# End of macro CALLMONITOR
245a			endif 
245a					NEXTW 
245a c3 01 20			jp macro_next 
245d				endm 
# End of macro NEXTW
245d			 
245d			.DROP: 
245d				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
245d 1b				db WORD_SYS_CORE+OPCODE_DROP             
245e 88 24			dw .DUP2            
2460 05				db 4 + 1 
2461 .. 00			db "DROP",0              
2466				endm 
# End of macro CWHEAD
2466			; | DROP ( w -- )   drop the TOS item   | DONE 
2466					if DEBUG_FORTH_WORDS_KEY 
2466						DMARK "DRP" 
2466 f5				push af  
2467 3a 7b 24			ld a, (.dmark)  
246a 32 6e ee			ld (debug_mark),a  
246d 3a 7c 24			ld a, (.dmark+1)  
2470 32 6f ee			ld (debug_mark+1),a  
2473 3a 7d 24			ld a, (.dmark+2)  
2476 32 70 ee			ld (debug_mark+2),a  
2479 18 03			jr .pastdmark  
247b ..			.dmark: db "DRP"  
247e f1			.pastdmark: pop af  
247f			endm  
# End of macro DMARK
247f						CALLMONITOR 
247f cd 72 ee			call debug_vector  
2482				endm  
# End of macro CALLMONITOR
2482					endif 
2482					FORTH_DSP_POP 
2482 cd 03 1f			call macro_forth_dsp_pop 
2485				endm 
# End of macro FORTH_DSP_POP
2485					NEXTW 
2485 c3 01 20			jp macro_next 
2488				endm 
# End of macro NEXTW
2488			.DUP2: 
2488				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2488 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2489 cd 24			dw .DROP2            
248b 05				db 4 + 1 
248c .. 00			db "2DUP",0              
2491				endm 
# End of macro CWHEAD
2491			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2491					if DEBUG_FORTH_WORDS_KEY 
2491						DMARK "2DU" 
2491 f5				push af  
2492 3a a6 24			ld a, (.dmark)  
2495 32 6e ee			ld (debug_mark),a  
2498 3a a7 24			ld a, (.dmark+1)  
249b 32 6f ee			ld (debug_mark+1),a  
249e 3a a8 24			ld a, (.dmark+2)  
24a1 32 70 ee			ld (debug_mark+2),a  
24a4 18 03			jr .pastdmark  
24a6 ..			.dmark: db "2DU"  
24a9 f1			.pastdmark: pop af  
24aa			endm  
# End of macro DMARK
24aa						CALLMONITOR 
24aa cd 72 ee			call debug_vector  
24ad				endm  
# End of macro CALLMONITOR
24ad					endif 
24ad					FORTH_DSP_VALUEHL 
24ad cd 4b 1e			call macro_dsp_valuehl 
24b0				endm 
# End of macro FORTH_DSP_VALUEHL
24b0 e5					push hl      ; 2 
24b1			 
24b1					FORTH_DSP_POP 
24b1 cd 03 1f			call macro_forth_dsp_pop 
24b4				endm 
# End of macro FORTH_DSP_POP
24b4					 
24b4					FORTH_DSP_VALUEHL 
24b4 cd 4b 1e			call macro_dsp_valuehl 
24b7				endm 
# End of macro FORTH_DSP_VALUEHL
24b7			;		push hl      ; 1 
24b7			 
24b7					FORTH_DSP_POP 
24b7 cd 03 1f			call macro_forth_dsp_pop 
24ba				endm 
# End of macro FORTH_DSP_POP
24ba			 
24ba			;		pop hl       ; 1 
24ba d1					pop de       ; 2 
24bb			 
24bb cd 54 1c				call forth_push_numhl 
24be eb					ex de, hl 
24bf cd 54 1c				call forth_push_numhl 
24c2			 
24c2					 
24c2 eb					ex de, hl 
24c3			 
24c3 cd 54 1c				call forth_push_numhl 
24c6 eb					ex de, hl 
24c7 cd 54 1c				call forth_push_numhl 
24ca			 
24ca			 
24ca					NEXTW 
24ca c3 01 20			jp macro_next 
24cd				endm 
# End of macro NEXTW
24cd			.DROP2: 
24cd				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24cd 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24ce fc 24			dw .SWAP2            
24d0 06				db 5 + 1 
24d1 .. 00			db "2DROP",0              
24d7				endm 
# End of macro CWHEAD
24d7			; | 2DROP ( w w -- )    Double drop | DONE 
24d7					if DEBUG_FORTH_WORDS_KEY 
24d7						DMARK "2DR" 
24d7 f5				push af  
24d8 3a ec 24			ld a, (.dmark)  
24db 32 6e ee			ld (debug_mark),a  
24de 3a ed 24			ld a, (.dmark+1)  
24e1 32 6f ee			ld (debug_mark+1),a  
24e4 3a ee 24			ld a, (.dmark+2)  
24e7 32 70 ee			ld (debug_mark+2),a  
24ea 18 03			jr .pastdmark  
24ec ..			.dmark: db "2DR"  
24ef f1			.pastdmark: pop af  
24f0			endm  
# End of macro DMARK
24f0						CALLMONITOR 
24f0 cd 72 ee			call debug_vector  
24f3				endm  
# End of macro CALLMONITOR
24f3					endif 
24f3					FORTH_DSP_POP 
24f3 cd 03 1f			call macro_forth_dsp_pop 
24f6				endm 
# End of macro FORTH_DSP_POP
24f6					FORTH_DSP_POP 
24f6 cd 03 1f			call macro_forth_dsp_pop 
24f9				endm 
# End of macro FORTH_DSP_POP
24f9					NEXTW 
24f9 c3 01 20			jp macro_next 
24fc				endm 
# End of macro NEXTW
24fc			.SWAP2: 
24fc				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24fc 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24fd 25 25			dw .AT            
24ff 06				db 5 + 1 
2500 .. 00			db "2SWAP",0              
2506				endm 
# End of macro CWHEAD
2506			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2506					if DEBUG_FORTH_WORDS_KEY 
2506						DMARK "2SW" 
2506 f5				push af  
2507 3a 1b 25			ld a, (.dmark)  
250a 32 6e ee			ld (debug_mark),a  
250d 3a 1c 25			ld a, (.dmark+1)  
2510 32 6f ee			ld (debug_mark+1),a  
2513 3a 1d 25			ld a, (.dmark+2)  
2516 32 70 ee			ld (debug_mark+2),a  
2519 18 03			jr .pastdmark  
251b ..			.dmark: db "2SW"  
251e f1			.pastdmark: pop af  
251f			endm  
# End of macro DMARK
251f						CALLMONITOR 
251f cd 72 ee			call debug_vector  
2522				endm  
# End of macro CALLMONITOR
2522					endif 
2522					NEXTW 
2522 c3 01 20			jp macro_next 
2525				endm 
# End of macro NEXTW
2525			.AT: 
2525				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2525 1f				db WORD_SYS_CORE+OPCODE_AT             
2526 57 25			dw .CAT            
2528 02				db 1 + 1 
2529 .. 00			db "@",0              
252b				endm 
# End of macro CWHEAD
252b			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
252b			 
252b					if DEBUG_FORTH_WORDS_KEY 
252b						DMARK "AT." 
252b f5				push af  
252c 3a 40 25			ld a, (.dmark)  
252f 32 6e ee			ld (debug_mark),a  
2532 3a 41 25			ld a, (.dmark+1)  
2535 32 6f ee			ld (debug_mark+1),a  
2538 3a 42 25			ld a, (.dmark+2)  
253b 32 70 ee			ld (debug_mark+2),a  
253e 18 03			jr .pastdmark  
2540 ..			.dmark: db "AT."  
2543 f1			.pastdmark: pop af  
2544			endm  
# End of macro DMARK
2544						CALLMONITOR 
2544 cd 72 ee			call debug_vector  
2547				endm  
# End of macro CALLMONITOR
2547					endif 
2547			.getbyteat:	 
2547					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2547 cd 4b 1e			call macro_dsp_valuehl 
254a				endm 
# End of macro FORTH_DSP_VALUEHL
254a					 
254a			;		push hl 
254a				 
254a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
254a cd 03 1f			call macro_forth_dsp_pop 
254d				endm 
# End of macro FORTH_DSP_POP
254d			 
254d			;		pop hl 
254d			 
254d 7e					ld a, (hl) 
254e			 
254e 6f					ld l, a 
254f 26 00				ld h, 0 
2551 cd 54 1c				call forth_push_numhl 
2554			 
2554					NEXTW 
2554 c3 01 20			jp macro_next 
2557				endm 
# End of macro NEXTW
2557			.CAT: 
2557				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2557 20				db WORD_SYS_CORE+OPCODE_CAT             
2558 80 25			dw .BANG            
255a 03				db 2 + 1 
255b .. 00			db "C@",0              
255e				endm 
# End of macro CWHEAD
255e			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
255e					if DEBUG_FORTH_WORDS_KEY 
255e						DMARK "CAA" 
255e f5				push af  
255f 3a 73 25			ld a, (.dmark)  
2562 32 6e ee			ld (debug_mark),a  
2565 3a 74 25			ld a, (.dmark+1)  
2568 32 6f ee			ld (debug_mark+1),a  
256b 3a 75 25			ld a, (.dmark+2)  
256e 32 70 ee			ld (debug_mark+2),a  
2571 18 03			jr .pastdmark  
2573 ..			.dmark: db "CAA"  
2576 f1			.pastdmark: pop af  
2577			endm  
# End of macro DMARK
2577						CALLMONITOR 
2577 cd 72 ee			call debug_vector  
257a				endm  
# End of macro CALLMONITOR
257a					endif 
257a c3 47 25				jp .getbyteat 
257d					NEXTW 
257d c3 01 20			jp macro_next 
2580				endm 
# End of macro NEXTW
2580			.BANG: 
2580				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2580 21				db WORD_SYS_CORE+OPCODE_BANG             
2581 b6 25			dw .CBANG            
2583 02				db 1 + 1 
2584 .. 00			db "!",0              
2586				endm 
# End of macro CWHEAD
2586			; | ! ( x w -- ) Store x at address w      | DONE 
2586					if DEBUG_FORTH_WORDS_KEY 
2586						DMARK "BNG" 
2586 f5				push af  
2587 3a 9b 25			ld a, (.dmark)  
258a 32 6e ee			ld (debug_mark),a  
258d 3a 9c 25			ld a, (.dmark+1)  
2590 32 6f ee			ld (debug_mark+1),a  
2593 3a 9d 25			ld a, (.dmark+2)  
2596 32 70 ee			ld (debug_mark+2),a  
2599 18 03			jr .pastdmark  
259b ..			.dmark: db "BNG"  
259e f1			.pastdmark: pop af  
259f			endm  
# End of macro DMARK
259f						CALLMONITOR 
259f cd 72 ee			call debug_vector  
25a2				endm  
# End of macro CALLMONITOR
25a2					endif 
25a2			 
25a2			.storebyteat:		 
25a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a2 cd 4b 1e			call macro_dsp_valuehl 
25a5				endm 
# End of macro FORTH_DSP_VALUEHL
25a5					 
25a5 e5					push hl 
25a6				 
25a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25a6 cd 03 1f			call macro_forth_dsp_pop 
25a9				endm 
# End of macro FORTH_DSP_POP
25a9			 
25a9					; get byte to poke 
25a9			 
25a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a9 cd 4b 1e			call macro_dsp_valuehl 
25ac				endm 
# End of macro FORTH_DSP_VALUEHL
25ac e5					push hl 
25ad			 
25ad			 
25ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ad cd 03 1f			call macro_forth_dsp_pop 
25b0				endm 
# End of macro FORTH_DSP_POP
25b0			 
25b0			 
25b0 d1					pop de 
25b1 e1					pop hl 
25b2			 
25b2 73					ld (hl),e 
25b3			 
25b3			 
25b3					NEXTW 
25b3 c3 01 20			jp macro_next 
25b6				endm 
# End of macro NEXTW
25b6			.CBANG: 
25b6				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25b6 22				db WORD_SYS_CORE+OPCODE_CBANG             
25b7 df 25			dw .SCALL            
25b9 03				db 2 + 1 
25ba .. 00			db "C!",0              
25bd				endm 
# End of macro CWHEAD
25bd			; | C!  ( x w -- ) Store x at address w  | DONE 
25bd					if DEBUG_FORTH_WORDS_KEY 
25bd						DMARK "CBA" 
25bd f5				push af  
25be 3a d2 25			ld a, (.dmark)  
25c1 32 6e ee			ld (debug_mark),a  
25c4 3a d3 25			ld a, (.dmark+1)  
25c7 32 6f ee			ld (debug_mark+1),a  
25ca 3a d4 25			ld a, (.dmark+2)  
25cd 32 70 ee			ld (debug_mark+2),a  
25d0 18 03			jr .pastdmark  
25d2 ..			.dmark: db "CBA"  
25d5 f1			.pastdmark: pop af  
25d6			endm  
# End of macro DMARK
25d6						CALLMONITOR 
25d6 cd 72 ee			call debug_vector  
25d9				endm  
# End of macro CALLMONITOR
25d9					endif 
25d9 c3 a2 25				jp .storebyteat 
25dc					NEXTW 
25dc c3 01 20			jp macro_next 
25df				endm 
# End of macro NEXTW
25df			.SCALL: 
25df				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25df 23				db WORD_SYS_CORE+OPCODE_SCALL             
25e0 13 26			dw .DEPTH            
25e2 05				db 4 + 1 
25e3 .. 00			db "CALL",0              
25e8				endm 
# End of macro CWHEAD
25e8			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25e8					if DEBUG_FORTH_WORDS_KEY 
25e8						DMARK "CLL" 
25e8 f5				push af  
25e9 3a fd 25			ld a, (.dmark)  
25ec 32 6e ee			ld (debug_mark),a  
25ef 3a fe 25			ld a, (.dmark+1)  
25f2 32 6f ee			ld (debug_mark+1),a  
25f5 3a ff 25			ld a, (.dmark+2)  
25f8 32 70 ee			ld (debug_mark+2),a  
25fb 18 03			jr .pastdmark  
25fd ..			.dmark: db "CLL"  
2600 f1			.pastdmark: pop af  
2601			endm  
# End of macro DMARK
2601						CALLMONITOR 
2601 cd 72 ee			call debug_vector  
2604				endm  
# End of macro CALLMONITOR
2604					endif 
2604			 
2604					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2604 cd 4b 1e			call macro_dsp_valuehl 
2607				endm 
# End of macro FORTH_DSP_VALUEHL
2607			 
2607			;		push hl 
2607			 
2607					; destroy value TOS 
2607			 
2607					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2607 cd 03 1f			call macro_forth_dsp_pop 
260a				endm 
# End of macro FORTH_DSP_POP
260a			 
260a						 
260a			;		pop hl 
260a			 
260a					; how to do a call with hl???? save SP? 
260a cd a5 1f				call forth_call_hl 
260d			 
260d			 
260d					; TODO push value back onto stack for another op etc 
260d			 
260d cd 54 1c				call forth_push_numhl 
2610					NEXTW 
2610 c3 01 20			jp macro_next 
2613				endm 
# End of macro NEXTW
2613			.DEPTH: 
2613				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2613 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2614 50 26			dw .OVER            
2616 06				db 5 + 1 
2617 .. 00			db "DEPTH",0              
261d				endm 
# End of macro CWHEAD
261d			; | DEPTH ( -- u ) Push count of stack | DONE 
261d					; take current TOS and remove from base value div by two to get count 
261d					if DEBUG_FORTH_WORDS_KEY 
261d						DMARK "DEP" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 6e ee			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 6f ee			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 70 ee			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db "DEP"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636						CALLMONITOR 
2636 cd 72 ee			call debug_vector  
2639				endm  
# End of macro CALLMONITOR
2639					endif 
2639			 
2639			 
2639 2a f1 e9			ld hl, (cli_data_sp) 
263c 11 2b e8			ld de, cli_data_stack 
263f ed 52			sbc hl,de 
2641				 
2641				; div by size of stack item 
2641			 
2641 5d				ld e,l 
2642 0e 03			ld c, 3 
2644 cd 77 0d			call Div8 
2647			 
2647 6f				ld l,a 
2648 26 00			ld h,0 
264a			 
264a				;srl h 
264a				;rr l 
264a			 
264a cd 54 1c				call forth_push_numhl 
264d					NEXTW 
264d c3 01 20			jp macro_next 
2650				endm 
# End of macro NEXTW
2650			.OVER: 
2650				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2650 42				db WORD_SYS_CORE+46             
2651 97 26			dw .PAUSE            
2653 05				db 4 + 1 
2654 .. 00			db "OVER",0              
2659				endm 
# End of macro CWHEAD
2659			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2659					if DEBUG_FORTH_WORDS_KEY 
2659						DMARK "OVR" 
2659 f5				push af  
265a 3a 6e 26			ld a, (.dmark)  
265d 32 6e ee			ld (debug_mark),a  
2660 3a 6f 26			ld a, (.dmark+1)  
2663 32 6f ee			ld (debug_mark+1),a  
2666 3a 70 26			ld a, (.dmark+2)  
2669 32 70 ee			ld (debug_mark+2),a  
266c 18 03			jr .pastdmark  
266e ..			.dmark: db "OVR"  
2671 f1			.pastdmark: pop af  
2672			endm  
# End of macro DMARK
2672						CALLMONITOR 
2672 cd 72 ee			call debug_vector  
2675				endm  
# End of macro CALLMONITOR
2675					endif 
2675			 
2675					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2675 cd 4b 1e			call macro_dsp_valuehl 
2678				endm 
# End of macro FORTH_DSP_VALUEHL
2678 e5					push hl    ; n2 
2679					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2679 cd 03 1f			call macro_forth_dsp_pop 
267c				endm 
# End of macro FORTH_DSP_POP
267c			 
267c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267c cd 4b 1e			call macro_dsp_valuehl 
267f				endm 
# End of macro FORTH_DSP_VALUEHL
267f e5					push hl    ; n1 
2680					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2680 cd 03 1f			call macro_forth_dsp_pop 
2683				endm 
# End of macro FORTH_DSP_POP
2683			 
2683 d1					pop de     ; n1 
2684 e1					pop hl     ; n2 
2685			 
2685 d5					push de 
2686 e5					push hl 
2687 d5					push de 
2688			 
2688					; push back  
2688			 
2688 e1					pop hl 
2689 cd 54 1c				call forth_push_numhl 
268c e1					pop hl 
268d cd 54 1c				call forth_push_numhl 
2690 e1					pop hl 
2691 cd 54 1c				call forth_push_numhl 
2694					NEXTW 
2694 c3 01 20			jp macro_next 
2697				endm 
# End of macro NEXTW
2697			 
2697			.PAUSE: 
2697				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2697 43				db WORD_SYS_CORE+47             
2698 cc 26			dw .PAUSES            
269a 08				db 7 + 1 
269b .. 00			db "PAUSEMS",0              
26a3				endm 
# End of macro CWHEAD
26a3			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26a3					if DEBUG_FORTH_WORDS_KEY 
26a3						DMARK "PMS" 
26a3 f5				push af  
26a4 3a b8 26			ld a, (.dmark)  
26a7 32 6e ee			ld (debug_mark),a  
26aa 3a b9 26			ld a, (.dmark+1)  
26ad 32 6f ee			ld (debug_mark+1),a  
26b0 3a ba 26			ld a, (.dmark+2)  
26b3 32 70 ee			ld (debug_mark+2),a  
26b6 18 03			jr .pastdmark  
26b8 ..			.dmark: db "PMS"  
26bb f1			.pastdmark: pop af  
26bc			endm  
# End of macro DMARK
26bc						CALLMONITOR 
26bc cd 72 ee			call debug_vector  
26bf				endm  
# End of macro CALLMONITOR
26bf					endif 
26bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bf cd 4b 1e			call macro_dsp_valuehl 
26c2				endm 
# End of macro FORTH_DSP_VALUEHL
26c2			;		push hl    ; n2 
26c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c2 cd 03 1f			call macro_forth_dsp_pop 
26c5				endm 
# End of macro FORTH_DSP_POP
26c5			;		pop hl 
26c5			 
26c5 7d					ld a, l 
26c6 cd d7 0a				call aDelayInMS 
26c9				       NEXTW 
26c9 c3 01 20			jp macro_next 
26cc				endm 
# End of macro NEXTW
26cc			.PAUSES:  
26cc				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26cc 44				db WORD_SYS_CORE+48             
26cd 3b 27			dw .ROT            
26cf 06				db 5 + 1 
26d0 .. 00			db "PAUSE",0              
26d6				endm 
# End of macro CWHEAD
26d6			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26d6					if DEBUG_FORTH_WORDS_KEY 
26d6						DMARK "PAU" 
26d6 f5				push af  
26d7 3a eb 26			ld a, (.dmark)  
26da 32 6e ee			ld (debug_mark),a  
26dd 3a ec 26			ld a, (.dmark+1)  
26e0 32 6f ee			ld (debug_mark+1),a  
26e3 3a ed 26			ld a, (.dmark+2)  
26e6 32 70 ee			ld (debug_mark+2),a  
26e9 18 03			jr .pastdmark  
26eb ..			.dmark: db "PAU"  
26ee f1			.pastdmark: pop af  
26ef			endm  
# End of macro DMARK
26ef						CALLMONITOR 
26ef cd 72 ee			call debug_vector  
26f2				endm  
# End of macro CALLMONITOR
26f2					endif 
26f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f2 cd 4b 1e			call macro_dsp_valuehl 
26f5				endm 
# End of macro FORTH_DSP_VALUEHL
26f5			;		push hl    ; n2 
26f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f5 cd 03 1f			call macro_forth_dsp_pop 
26f8				endm 
# End of macro FORTH_DSP_POP
26f8			;		pop hl 
26f8 45					ld b, l 
26f9					if DEBUG_FORTH_WORDS 
26f9						DMARK "PAU" 
26f9 f5				push af  
26fa 3a 0e 27			ld a, (.dmark)  
26fd 32 6e ee			ld (debug_mark),a  
2700 3a 0f 27			ld a, (.dmark+1)  
2703 32 6f ee			ld (debug_mark+1),a  
2706 3a 10 27			ld a, (.dmark+2)  
2709 32 70 ee			ld (debug_mark+2),a  
270c 18 03			jr .pastdmark  
270e ..			.dmark: db "PAU"  
2711 f1			.pastdmark: pop af  
2712			endm  
# End of macro DMARK
2712						CALLMONITOR 
2712 cd 72 ee			call debug_vector  
2715				endm  
# End of macro CALLMONITOR
2715					endif 
2715 c5			.pauses1:	push bc 
2716 cd f2 0a				call delay1s 
2719 c1					pop bc 
271a					if DEBUG_FORTH_WORDS 
271a						DMARK "PA1" 
271a f5				push af  
271b 3a 2f 27			ld a, (.dmark)  
271e 32 6e ee			ld (debug_mark),a  
2721 3a 30 27			ld a, (.dmark+1)  
2724 32 6f ee			ld (debug_mark+1),a  
2727 3a 31 27			ld a, (.dmark+2)  
272a 32 70 ee			ld (debug_mark+2),a  
272d 18 03			jr .pastdmark  
272f ..			.dmark: db "PA1"  
2732 f1			.pastdmark: pop af  
2733			endm  
# End of macro DMARK
2733						CALLMONITOR 
2733 cd 72 ee			call debug_vector  
2736				endm  
# End of macro CALLMONITOR
2736					endif 
2736 10 dd				djnz .pauses1 
2738			 
2738				       NEXTW 
2738 c3 01 20			jp macro_next 
273b				endm 
# End of macro NEXTW
273b			.ROT: 
273b				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
273b 45				db WORD_SYS_CORE+49             
273c 89 27			dw .UWORDS            
273e 04				db 3 + 1 
273f .. 00			db "ROT",0              
2743				endm 
# End of macro CWHEAD
2743			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2743					if DEBUG_FORTH_WORDS_KEY 
2743						DMARK "ROT" 
2743 f5				push af  
2744 3a 58 27			ld a, (.dmark)  
2747 32 6e ee			ld (debug_mark),a  
274a 3a 59 27			ld a, (.dmark+1)  
274d 32 6f ee			ld (debug_mark+1),a  
2750 3a 5a 27			ld a, (.dmark+2)  
2753 32 70 ee			ld (debug_mark+2),a  
2756 18 03			jr .pastdmark  
2758 ..			.dmark: db "ROT"  
275b f1			.pastdmark: pop af  
275c			endm  
# End of macro DMARK
275c						CALLMONITOR 
275c cd 72 ee			call debug_vector  
275f				endm  
# End of macro CALLMONITOR
275f					endif 
275f			 
275f					FORTH_DSP_VALUEHL 
275f cd 4b 1e			call macro_dsp_valuehl 
2762				endm 
# End of macro FORTH_DSP_VALUEHL
2762 e5					push hl    ; u3  
2763			 
2763					FORTH_DSP_POP 
2763 cd 03 1f			call macro_forth_dsp_pop 
2766				endm 
# End of macro FORTH_DSP_POP
2766			   
2766					FORTH_DSP_VALUEHL 
2766 cd 4b 1e			call macro_dsp_valuehl 
2769				endm 
# End of macro FORTH_DSP_VALUEHL
2769 e5					push hl     ; u2 
276a			 
276a					FORTH_DSP_POP 
276a cd 03 1f			call macro_forth_dsp_pop 
276d				endm 
# End of macro FORTH_DSP_POP
276d			 
276d					FORTH_DSP_VALUEHL 
276d cd 4b 1e			call macro_dsp_valuehl 
2770				endm 
# End of macro FORTH_DSP_VALUEHL
2770 e5					push hl     ; u1 
2771			 
2771					FORTH_DSP_POP 
2771 cd 03 1f			call macro_forth_dsp_pop 
2774				endm 
# End of macro FORTH_DSP_POP
2774			 
2774 c1					pop bc      ; u1 
2775 e1					pop hl      ; u2 
2776 d1					pop de      ; u3 
2777			 
2777			 
2777 c5					push bc 
2778 d5					push de 
2779 e5					push hl 
277a			 
277a			 
277a e1					pop hl 
277b cd 54 1c				call forth_push_numhl 
277e			 
277e e1					pop hl 
277f cd 54 1c				call forth_push_numhl 
2782			 
2782 e1					pop hl 
2783 cd 54 1c				call forth_push_numhl 
2786					 
2786			 
2786			 
2786			 
2786			 
2786			 
2786				       NEXTW 
2786 c3 01 20			jp macro_next 
2789				endm 
# End of macro NEXTW
2789			 
2789			.UWORDS: 
2789				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2789 50				db WORD_SYS_CORE+60             
278a 4b 28			dw .BP            
278c 07				db 6 + 1 
278d .. 00			db "UWORDS",0              
2794				endm 
# End of macro CWHEAD
2794			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2794			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2794			; | | Following the count are the individual words. 
2794			; | | 
2794			; | | e.g. UWORDS 
2794			; | | BOX DIRLIST 2 
2794			; | |  
2794			; | | Can be used to save the words to storage via: 
2794			; | | UWORDS $01 DO $01 APPEND LOOP 
2794				if DEBUG_FORTH_WORDS_KEY 
2794					DMARK "UWR" 
2794 f5				push af  
2795 3a a9 27			ld a, (.dmark)  
2798 32 6e ee			ld (debug_mark),a  
279b 3a aa 27			ld a, (.dmark+1)  
279e 32 6f ee			ld (debug_mark+1),a  
27a1 3a ab 27			ld a, (.dmark+2)  
27a4 32 70 ee			ld (debug_mark+2),a  
27a7 18 03			jr .pastdmark  
27a9 ..			.dmark: db "UWR"  
27ac f1			.pastdmark: pop af  
27ad			endm  
# End of macro DMARK
27ad					CALLMONITOR 
27ad cd 72 ee			call debug_vector  
27b0				endm  
# End of macro CALLMONITOR
27b0				endif 
27b0 21 ae 64				ld hl, baseram 
27b3					;ld hl, baseusermem 
27b3 01 00 00				ld bc, 0    ; start a counter 
27b6			 
27b6				; skip dict stub 
27b6			 
27b6 cd 52 21				call forth_tok_next 
27b9			 
27b9			 
27b9			; while we have words to look for 
27b9			 
27b9 7e			.douscan:	ld a, (hl)      
27ba				if DEBUG_FORTH_WORDS 
27ba					DMARK "UWs" 
27ba f5				push af  
27bb 3a cf 27			ld a, (.dmark)  
27be 32 6e ee			ld (debug_mark),a  
27c1 3a d0 27			ld a, (.dmark+1)  
27c4 32 6f ee			ld (debug_mark+1),a  
27c7 3a d1 27			ld a, (.dmark+2)  
27ca 32 70 ee			ld (debug_mark+2),a  
27cd 18 03			jr .pastdmark  
27cf ..			.dmark: db "UWs"  
27d2 f1			.pastdmark: pop af  
27d3			endm  
# End of macro DMARK
27d3					CALLMONITOR 
27d3 cd 72 ee			call debug_vector  
27d6				endm  
# End of macro CALLMONITOR
27d6				endif 
27d6 fe 00				cp WORD_SYS_END 
27d8 28 4d				jr z, .udone 
27da fe 01				cp WORD_SYS_UWORD 
27dc 20 44				jr nz, .nuword 
27de			 
27de				if DEBUG_FORTH_WORDS 
27de					DMARK "UWu" 
27de f5				push af  
27df 3a f3 27			ld a, (.dmark)  
27e2 32 6e ee			ld (debug_mark),a  
27e5 3a f4 27			ld a, (.dmark+1)  
27e8 32 6f ee			ld (debug_mark+1),a  
27eb 3a f5 27			ld a, (.dmark+2)  
27ee 32 70 ee			ld (debug_mark+2),a  
27f1 18 03			jr .pastdmark  
27f3 ..			.dmark: db "UWu"  
27f6 f1			.pastdmark: pop af  
27f7			endm  
# End of macro DMARK
27f7					CALLMONITOR 
27f7 cd 72 ee			call debug_vector  
27fa				endm  
# End of macro CALLMONITOR
27fa				endif 
27fa					; we have a uword so push its name to the stack 
27fa			 
27fa e5				   	push hl  ; save so we can move to next dict block 
27fb			 
27fb					; skip opcode 
27fb 23					inc hl  
27fc					; skip next ptr 
27fc 23					inc hl  
27fd 23					inc hl 
27fe					; skip len 
27fe 23					inc hl 
27ff				if DEBUG_FORTH_WORDS 
27ff					DMARK "UWt" 
27ff f5				push af  
2800 3a 14 28			ld a, (.dmark)  
2803 32 6e ee			ld (debug_mark),a  
2806 3a 15 28			ld a, (.dmark+1)  
2809 32 6f ee			ld (debug_mark+1),a  
280c 3a 16 28			ld a, (.dmark+2)  
280f 32 70 ee			ld (debug_mark+2),a  
2812 18 03			jr .pastdmark  
2814 ..			.dmark: db "UWt"  
2817 f1			.pastdmark: pop af  
2818			endm  
# End of macro DMARK
2818					CALLMONITOR 
2818 cd 72 ee			call debug_vector  
281b				endm  
# End of macro CALLMONITOR
281b				endif 
281b 03					inc bc 
281c			 
281c c5					push bc 
281d cd c2 1c				call forth_push_str 
2820 c1					pop bc 
2821			 
2821 e1					pop hl 	 
2822			 
2822 cd 52 21		.nuword:	call forth_tok_next 
2825 18 92				jr .douscan  
2827			 
2827			.udone:		 ; push count of uwords found 
2827 c5					push bc 
2828 e1					pop hl 
2829			 
2829				if DEBUG_FORTH_WORDS 
2829					DMARK "UWc" 
2829 f5				push af  
282a 3a 3e 28			ld a, (.dmark)  
282d 32 6e ee			ld (debug_mark),a  
2830 3a 3f 28			ld a, (.dmark+1)  
2833 32 6f ee			ld (debug_mark+1),a  
2836 3a 40 28			ld a, (.dmark+2)  
2839 32 70 ee			ld (debug_mark+2),a  
283c 18 03			jr .pastdmark  
283e ..			.dmark: db "UWc"  
2841 f1			.pastdmark: pop af  
2842			endm  
# End of macro DMARK
2842					CALLMONITOR 
2842 cd 72 ee			call debug_vector  
2845				endm  
# End of macro CALLMONITOR
2845				endif 
2845 cd 54 1c				call forth_push_numhl 
2848			 
2848			 
2848				       NEXTW 
2848 c3 01 20			jp macro_next 
284b				endm 
# End of macro NEXTW
284b			 
284b			.BP: 
284b				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
284b 54				db WORD_SYS_CORE+64             
284c 85 28			dw .MONITOR            
284e 03				db 2 + 1 
284f .. 00			db "BP",0              
2852				endm 
# End of macro CWHEAD
2852			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2852			; | | $00 Will enable the break points within specific code paths 
2852			; | | $01 Will disable break points 
2852			; | |  
2852			; | | By default break points are off. Either the above can be used to enable them 
2852			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2852			; | | and on release of the pressed key a message will be disaplayed to notify 
2852			; | | that break points are enabled. Pressing any key will then continue boot process. 
2852					; get byte count 
2852					if DEBUG_FORTH_WORDS_KEY 
2852						DMARK "BP." 
2852 f5				push af  
2853 3a 67 28			ld a, (.dmark)  
2856 32 6e ee			ld (debug_mark),a  
2859 3a 68 28			ld a, (.dmark+1)  
285c 32 6f ee			ld (debug_mark+1),a  
285f 3a 69 28			ld a, (.dmark+2)  
2862 32 70 ee			ld (debug_mark+2),a  
2865 18 03			jr .pastdmark  
2867 ..			.dmark: db "BP."  
286a f1			.pastdmark: pop af  
286b			endm  
# End of macro DMARK
286b						CALLMONITOR 
286b cd 72 ee			call debug_vector  
286e				endm  
# End of macro CALLMONITOR
286e					endif 
286e			 
286e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
286e cd 4b 1e			call macro_dsp_valuehl 
2871				endm 
# End of macro FORTH_DSP_VALUEHL
2871			 
2871			;		push hl 
2871			 
2871					; destroy value TOS 
2871			 
2871					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2871 cd 03 1f			call macro_forth_dsp_pop 
2874				endm 
# End of macro FORTH_DSP_POP
2874			 
2874			;		pop hl 
2874			 
2874 3e 00				ld a,0 
2876 bd					cp l 
2877 28 06				jr z, .bpset 
2879			;		ld a, '*' 
2879 cd e9 15				call bp_off 
287c					NEXTW 
287c c3 01 20			jp macro_next 
287f				endm 
# End of macro NEXTW
287f			 
287f			.bpset:	 
287f					;	ld (os_view_disable), a 
287f cd dd 15				call bp_on 
2882			 
2882			 
2882					NEXTW 
2882 c3 01 20			jp macro_next 
2885				endm 
# End of macro NEXTW
2885			 
2885			 
2885			.MONITOR: 
2885				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2885 55				db WORD_SYS_CORE+65             
2886 b6 28			dw .MALLOC            
2888 08				db 7 + 1 
2889 .. 00			db "MONITOR",0              
2891				endm 
# End of macro CWHEAD
2891			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2891			; | | At start the current various registers will be displayed with contents. 
2891			; | | Top right corner will show the most recent debug marker seen. 
2891			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2891			; | | and the return stack pointer (RSP). 
2891			; | | Pressing: 
2891			; | |    1 - Initial screen 
2891			; | |    2 - Display a data dump of HL 
2891			; | |    3 - Display a data dump of DE 
2891			; | |    4 - Display a data dump of BC 
2891			; | |    5 - Display a data dump of HL 
2891			; | |    6 - Display a data dump of DSP 
2891			; | |    7 - Display a data dump of RSP 
2891			; | |    8 - Display a data dump of what is at DSP 
2891			; | |    9 - Display a data dump of what is at RSP 
2891			; | |    0 - Exit monitor and continue running. This will also enable break points 
2891			; | |    * - Disable break points 
2891			; | |    # - Enter traditional monitor mode 
2891			; | | 
2891			; | | Monitor Mode 
2891			; | | ------------ 
2891			; | | A prompt of '>' will be shown for various commands: 
2891			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2891			; | |    C - Continue display a data dump from the last set address 
2891			; | |    M xxxx - Set start of memory edit at address xx 
2891			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2891			; | |    Q - Return to previous 
2891					if DEBUG_FORTH_WORDS_KEY 
2891						DMARK "MON" 
2891 f5				push af  
2892 3a a6 28			ld a, (.dmark)  
2895 32 6e ee			ld (debug_mark),a  
2898 3a a7 28			ld a, (.dmark+1)  
289b 32 6f ee			ld (debug_mark+1),a  
289e 3a a8 28			ld a, (.dmark+2)  
28a1 32 70 ee			ld (debug_mark+2),a  
28a4 18 03			jr .pastdmark  
28a6 ..			.dmark: db "MON"  
28a9 f1			.pastdmark: pop af  
28aa			endm  
# End of macro DMARK
28aa						CALLMONITOR 
28aa cd 72 ee			call debug_vector  
28ad				endm  
# End of macro CALLMONITOR
28ad					endif 
28ad			;		ld a, 0 
28ad			;		ld (os_view_disable), a 
28ad cd dd 15				call bp_on 
28b0			 
28b0					CALLMONITOR 
28b0 cd 72 ee			call debug_vector  
28b3				endm  
# End of macro CALLMONITOR
28b3			 
28b3			;	call monitor 
28b3			 
28b3					NEXTW 
28b3 c3 01 20			jp macro_next 
28b6				endm 
# End of macro NEXTW
28b6			 
28b6			 
28b6			.MALLOC: 
28b6				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28b6 56				db WORD_SYS_CORE+66             
28b7 df 28			dw .MALLOC2            
28b9 06				db 5 + 1 
28ba .. 00			db "ALLOT",0              
28c0				endm 
# End of macro CWHEAD
28c0			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28c0					if DEBUG_FORTH_WORDS_KEY 
28c0						DMARK "ALL" 
28c0 f5				push af  
28c1 3a d5 28			ld a, (.dmark)  
28c4 32 6e ee			ld (debug_mark),a  
28c7 3a d6 28			ld a, (.dmark+1)  
28ca 32 6f ee			ld (debug_mark+1),a  
28cd 3a d7 28			ld a, (.dmark+2)  
28d0 32 70 ee			ld (debug_mark+2),a  
28d3 18 03			jr .pastdmark  
28d5 ..			.dmark: db "ALL"  
28d8 f1			.pastdmark: pop af  
28d9			endm  
# End of macro DMARK
28d9						CALLMONITOR 
28d9 cd 72 ee			call debug_vector  
28dc				endm  
# End of macro CALLMONITOR
28dc					endif 
28dc c3 06 29				jp .mallocc 
28df			.MALLOC2: 
28df				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28df 56				db WORD_SYS_CORE+66             
28e0 1d 29			dw .FREE            
28e2 07				db 6 + 1 
28e3 .. 00			db "MALLOC",0              
28ea				endm 
# End of macro CWHEAD
28ea			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28ea					; get byte count 
28ea					if DEBUG_FORTH_WORDS_KEY 
28ea						DMARK "MAL" 
28ea f5				push af  
28eb 3a ff 28			ld a, (.dmark)  
28ee 32 6e ee			ld (debug_mark),a  
28f1 3a 00 29			ld a, (.dmark+1)  
28f4 32 6f ee			ld (debug_mark+1),a  
28f7 3a 01 29			ld a, (.dmark+2)  
28fa 32 70 ee			ld (debug_mark+2),a  
28fd 18 03			jr .pastdmark  
28ff ..			.dmark: db "MAL"  
2902 f1			.pastdmark: pop af  
2903			endm  
# End of macro DMARK
2903						CALLMONITOR 
2903 cd 72 ee			call debug_vector  
2906				endm  
# End of macro CALLMONITOR
2906					endif 
2906			.mallocc: 
2906					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2906 cd 4b 1e			call macro_dsp_valuehl 
2909				endm 
# End of macro FORTH_DSP_VALUEHL
2909			 
2909			;		push hl 
2909			 
2909					; destroy value TOS 
2909			 
2909					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2909 cd 03 1f			call macro_forth_dsp_pop 
290c				endm 
# End of macro FORTH_DSP_POP
290c			 
290c			;		pop hl 
290c cd ae 12				call malloc 
290f				if DEBUG_FORTH_MALLOC_GUARD 
290f f5					push af 
2910 cd 10 0e				call ishlzero 
2913			;		ld a, l 
2913			;		add h 
2913			;		cp 0 
2913 f1					pop af 
2914					 
2914 cc 0e 4d				call z,malloc_error 
2917				endif 
2917			 
2917 cd 54 1c				call forth_push_numhl 
291a					NEXTW 
291a c3 01 20			jp macro_next 
291d				endm 
# End of macro NEXTW
291d			 
291d			.FREE: 
291d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
291d 57				db WORD_SYS_CORE+67             
291e 4e 29			dw .LIST            
2920 05				db 4 + 1 
2921 .. 00			db "FREE",0              
2926				endm 
# End of macro CWHEAD
2926			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2926					if DEBUG_FORTH_WORDS_KEY 
2926						DMARK "FRE" 
2926 f5				push af  
2927 3a 3b 29			ld a, (.dmark)  
292a 32 6e ee			ld (debug_mark),a  
292d 3a 3c 29			ld a, (.dmark+1)  
2930 32 6f ee			ld (debug_mark+1),a  
2933 3a 3d 29			ld a, (.dmark+2)  
2936 32 70 ee			ld (debug_mark+2),a  
2939 18 03			jr .pastdmark  
293b ..			.dmark: db "FRE"  
293e f1			.pastdmark: pop af  
293f			endm  
# End of macro DMARK
293f						CALLMONITOR 
293f cd 72 ee			call debug_vector  
2942				endm  
# End of macro CALLMONITOR
2942					endif 
2942					; get address 
2942			 
2942					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2942 cd 4b 1e			call macro_dsp_valuehl 
2945				endm 
# End of macro FORTH_DSP_VALUEHL
2945			 
2945			;		push hl 
2945			 
2945					; destroy value TOS 
2945			 
2945					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2945 cd 03 1f			call macro_forth_dsp_pop 
2948				endm 
# End of macro FORTH_DSP_POP
2948			 
2948			;		pop hl 
2948			if FORTH_ENABLE_MALLOCFREE 
2948 cd 78 13				call free 
294b			endif 
294b					NEXTW 
294b c3 01 20			jp macro_next 
294e				endm 
# End of macro NEXTW
294e			.LIST: 
294e				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
294e 5c				db WORD_SYS_CORE+72             
294f 3c 2b			dw .FORGET            
2951 05				db 4 + 1 
2952 .. 00			db "LIST",0              
2957				endm 
# End of macro CWHEAD
2957			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2957			; | | The quoted word must be in upper case. 
2957				if DEBUG_FORTH_WORDS_KEY 
2957					DMARK "LST" 
2957 f5				push af  
2958 3a 6c 29			ld a, (.dmark)  
295b 32 6e ee			ld (debug_mark),a  
295e 3a 6d 29			ld a, (.dmark+1)  
2961 32 6f ee			ld (debug_mark+1),a  
2964 3a 6e 29			ld a, (.dmark+2)  
2967 32 70 ee			ld (debug_mark+2),a  
296a 18 03			jr .pastdmark  
296c ..			.dmark: db "LST"  
296f f1			.pastdmark: pop af  
2970			endm  
# End of macro DMARK
2970					CALLMONITOR 
2970 cd 72 ee			call debug_vector  
2973				endm  
# End of macro CALLMONITOR
2973				endif 
2973			 
2973					FORTH_DSP_VALUEHL 
2973 cd 4b 1e			call macro_dsp_valuehl 
2976				endm 
# End of macro FORTH_DSP_VALUEHL
2976			 
2976 e5					push hl 
2977					FORTH_DSP_POP 
2977 cd 03 1f			call macro_forth_dsp_pop 
297a				endm 
# End of macro FORTH_DSP_POP
297a c1					pop bc 
297b			 
297b			; Start format of scratch string 
297b			 
297b 21 c4 e2				ld hl, scratch 
297e			 
297e 3e 3a				ld a, ':' 
2980 77					ld (hl),a 
2981 23					inc hl 
2982 3e 20				ld a, ' ' 
2984 77					ld (hl), a 
2985			 
2985					; Get ptr to the word we need to look up 
2985			 
2985			;		FORTH_DSP_VALUEHL 
2985					;v5 FORTH_DSP_VALUE 
2985				; TODO type check 
2985			;		inc hl    ; Skip type check  
2985			;		push hl 
2985			;		ex de, hl    ; put into DE 
2985			 
2985			 
2985 21 ae 64				ld hl, baseram 
2988					;ld hl, baseusermem 
2988			 
2988 e5			push hl   ; sacreifical push 
2989			 
2989			.ldouscanm: 
2989 e1				pop hl 
298a			.ldouscan: 
298a				if DEBUG_FORTH_WORDS 
298a					DMARK "LSs" 
298a f5				push af  
298b 3a 9f 29			ld a, (.dmark)  
298e 32 6e ee			ld (debug_mark),a  
2991 3a a0 29			ld a, (.dmark+1)  
2994 32 6f ee			ld (debug_mark+1),a  
2997 3a a1 29			ld a, (.dmark+2)  
299a 32 70 ee			ld (debug_mark+2),a  
299d 18 03			jr .pastdmark  
299f ..			.dmark: db "LSs"  
29a2 f1			.pastdmark: pop af  
29a3			endm  
# End of macro DMARK
29a3					CALLMONITOR 
29a3 cd 72 ee			call debug_vector  
29a6				endm  
# End of macro CALLMONITOR
29a6				endif 
29a6				; skip dict stub 
29a6 cd 52 21				call forth_tok_next 
29a9			 
29a9			 
29a9			; while we have words to look for 
29a9			 
29a9 7e				ld a, (hl)      
29aa				if DEBUG_FORTH_WORDS 
29aa					DMARK "LSk" 
29aa f5				push af  
29ab 3a bf 29			ld a, (.dmark)  
29ae 32 6e ee			ld (debug_mark),a  
29b1 3a c0 29			ld a, (.dmark+1)  
29b4 32 6f ee			ld (debug_mark+1),a  
29b7 3a c1 29			ld a, (.dmark+2)  
29ba 32 70 ee			ld (debug_mark+2),a  
29bd 18 03			jr .pastdmark  
29bf ..			.dmark: db "LSk"  
29c2 f1			.pastdmark: pop af  
29c3			endm  
# End of macro DMARK
29c3					CALLMONITOR 
29c3 cd 72 ee			call debug_vector  
29c6				endm  
# End of macro CALLMONITOR
29c6				endif 
29c6					;cp WORD_SYS_END 
29c6					;jp z, .lunotfound 
29c6			 
29c6					; if we hit non uwords then gone too far 
29c6 fe 01				cp WORD_SYS_UWORD 
29c8 c2 f8 2a				jp nz, .lunotfound 
29cb			 
29cb				if DEBUG_FORTH_WORDS 
29cb					DMARK "LSu" 
29cb f5				push af  
29cc 3a e0 29			ld a, (.dmark)  
29cf 32 6e ee			ld (debug_mark),a  
29d2 3a e1 29			ld a, (.dmark+1)  
29d5 32 6f ee			ld (debug_mark+1),a  
29d8 3a e2 29			ld a, (.dmark+2)  
29db 32 70 ee			ld (debug_mark+2),a  
29de 18 03			jr .pastdmark  
29e0 ..			.dmark: db "LSu"  
29e3 f1			.pastdmark: pop af  
29e4			endm  
# End of macro DMARK
29e4					CALLMONITOR 
29e4 cd 72 ee			call debug_vector  
29e7				endm  
# End of macro CALLMONITOR
29e7				endif 
29e7			 
29e7					; found a uword but is it the one we want... 
29e7			 
29e7 c5					push bc     ; uword to find is on bc 
29e8 d1					pop de 
29e9			 
29e9 e5					push hl  ; to save the ptr 
29ea			 
29ea					; skip opcode 
29ea 23					inc hl  
29eb					; skip next ptr 
29eb 23					inc hl  
29ec 23					inc hl 
29ed					; skip len 
29ed 23					inc hl 
29ee			 
29ee				if DEBUG_FORTH_WORDS 
29ee					DMARK "LSc" 
29ee f5				push af  
29ef 3a 03 2a			ld a, (.dmark)  
29f2 32 6e ee			ld (debug_mark),a  
29f5 3a 04 2a			ld a, (.dmark+1)  
29f8 32 6f ee			ld (debug_mark+1),a  
29fb 3a 05 2a			ld a, (.dmark+2)  
29fe 32 70 ee			ld (debug_mark+2),a  
2a01 18 03			jr .pastdmark  
2a03 ..			.dmark: db "LSc"  
2a06 f1			.pastdmark: pop af  
2a07			endm  
# End of macro DMARK
2a07					CALLMONITOR 
2a07 cd 72 ee			call debug_vector  
2a0a				endm  
# End of macro CALLMONITOR
2a0a				endif 
2a0a cd 7d 12				call strcmp 
2a0d c2 89 29				jp nz, .ldouscanm 
2a10				 
2a10			 
2a10			 
2a10					; we have a uword so push its name to the stack 
2a10			 
2a10			;	   	push hl  ; save so we can move to next dict block 
2a10 e1			pop hl 
2a11			 
2a11				if DEBUG_FORTH_WORDS 
2a11					DMARK "LSm" 
2a11 f5				push af  
2a12 3a 26 2a			ld a, (.dmark)  
2a15 32 6e ee			ld (debug_mark),a  
2a18 3a 27 2a			ld a, (.dmark+1)  
2a1b 32 6f ee			ld (debug_mark+1),a  
2a1e 3a 28 2a			ld a, (.dmark+2)  
2a21 32 70 ee			ld (debug_mark+2),a  
2a24 18 03			jr .pastdmark  
2a26 ..			.dmark: db "LSm"  
2a29 f1			.pastdmark: pop af  
2a2a			endm  
# End of macro DMARK
2a2a					CALLMONITOR 
2a2a cd 72 ee			call debug_vector  
2a2d				endm  
# End of macro CALLMONITOR
2a2d				endif 
2a2d			 
2a2d					; skip opcode 
2a2d 23					inc hl  
2a2e					; skip next ptr 
2a2e 23					inc hl  
2a2f 23					inc hl 
2a30					; skip len 
2a30 7e					ld a, (hl)   ; save length to add 
2a31				if DEBUG_FORTH_WORDS 
2a31					DMARK "LS2" 
2a31 f5				push af  
2a32 3a 46 2a			ld a, (.dmark)  
2a35 32 6e ee			ld (debug_mark),a  
2a38 3a 47 2a			ld a, (.dmark+1)  
2a3b 32 6f ee			ld (debug_mark+1),a  
2a3e 3a 48 2a			ld a, (.dmark+2)  
2a41 32 70 ee			ld (debug_mark+2),a  
2a44 18 03			jr .pastdmark  
2a46 ..			.dmark: db "LS2"  
2a49 f1			.pastdmark: pop af  
2a4a			endm  
# End of macro DMARK
2a4a					CALLMONITOR 
2a4a cd 72 ee			call debug_vector  
2a4d				endm  
# End of macro CALLMONITOR
2a4d				endif 
2a4d			 
2a4d					; save this location 
2a4d				 
2a4d e5					push hl 
2a4e			 
2a4e 23					inc hl 
2a4f 11 c6 e2				ld de, scratch+2 
2a52 4f					ld c, a 
2a53 06 00				ld b, 0 
2a55			 
2a55				if DEBUG_FORTH_WORDS 
2a55					DMARK "LSn" 
2a55 f5				push af  
2a56 3a 6a 2a			ld a, (.dmark)  
2a59 32 6e ee			ld (debug_mark),a  
2a5c 3a 6b 2a			ld a, (.dmark+1)  
2a5f 32 6f ee			ld (debug_mark+1),a  
2a62 3a 6c 2a			ld a, (.dmark+2)  
2a65 32 70 ee			ld (debug_mark+2),a  
2a68 18 03			jr .pastdmark  
2a6a ..			.dmark: db "LSn"  
2a6d f1			.pastdmark: pop af  
2a6e			endm  
# End of macro DMARK
2a6e					CALLMONITOR 
2a6e cd 72 ee			call debug_vector  
2a71				endm  
# End of macro CALLMONITOR
2a71				endif 
2a71			 
2a71					; copy uword name to scratch 
2a71			 
2a71 ed b0				ldir 
2a73			 
2a73 1b					dec de 
2a74 3e 20				ld a, ' '    ; change null to space 
2a76 12					ld (de), a 
2a77			 
2a77 13					inc de 
2a78			 
2a78 d5					push de 
2a79 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a7a			 
2a7a e1					pop hl 
2a7b 7e					ld a, (hl) 
2a7c					;inc hl 
2a7c					; skip word string 
2a7c cd e7 0d				call addatohl 
2a7f			 
2a7f 23					inc hl 
2a80			 
2a80				if DEBUG_FORTH_WORDS 
2a80					DMARK "LS3" 
2a80 f5				push af  
2a81 3a 95 2a			ld a, (.dmark)  
2a84 32 6e ee			ld (debug_mark),a  
2a87 3a 96 2a			ld a, (.dmark+1)  
2a8a 32 6f ee			ld (debug_mark+1),a  
2a8d 3a 97 2a			ld a, (.dmark+2)  
2a90 32 70 ee			ld (debug_mark+2),a  
2a93 18 03			jr .pastdmark  
2a95 ..			.dmark: db "LS3"  
2a98 f1			.pastdmark: pop af  
2a99			endm  
# End of macro DMARK
2a99					CALLMONITOR 
2a99 cd 72 ee			call debug_vector  
2a9c				endm  
# End of macro CALLMONITOR
2a9c				endif 
2a9c					; should now be at the start of the machine code to setup the eval of the uword 
2a9c					; now locate the ptr to the string defintion 
2a9c			 
2a9c					; skip ld hl, 
2a9c					; then load the ptr 
2a9c			; TODO use get from hl ptr 
2a9c 23					inc hl 
2a9d 5e					ld e, (hl) 
2a9e 23					inc hl 
2a9f 56					ld d, (hl) 
2aa0 eb					ex de, hl 
2aa1			 
2aa1			 
2aa1				if DEBUG_FORTH_WORDS 
2aa1					DMARK "LSt" 
2aa1 f5				push af  
2aa2 3a b6 2a			ld a, (.dmark)  
2aa5 32 6e ee			ld (debug_mark),a  
2aa8 3a b7 2a			ld a, (.dmark+1)  
2aab 32 6f ee			ld (debug_mark+1),a  
2aae 3a b8 2a			ld a, (.dmark+2)  
2ab1 32 70 ee			ld (debug_mark+2),a  
2ab4 18 03			jr .pastdmark  
2ab6 ..			.dmark: db "LSt"  
2ab9 f1			.pastdmark: pop af  
2aba			endm  
# End of macro DMARK
2aba					CALLMONITOR 
2aba cd 72 ee			call debug_vector  
2abd				endm  
# End of macro CALLMONITOR
2abd				endif 
2abd			 
2abd			; cant push right now due to tokenised strings  
2abd			 
2abd			; get the destination of where to copy this definition to. 
2abd			 
2abd c5					push bc 
2abe d1					pop de 
2abf			 
2abf 7e			.listl:         ld a,(hl) 
2ac0 fe 00				cp 0 
2ac2 28 09				jr z, .lreplsp     ; replace zero with space 
2ac4					;cp FORTH_END_BUFFER 
2ac4 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ac6 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ac8				 
2ac8					; just copy this char as is then 
2ac8			 
2ac8 12					ld (de), a 
2ac9			 
2ac9 23			.listnxt:	inc hl 
2aca 13					inc de 
2acb 18 f2				jr .listl 
2acd			 
2acd 3e 20		.lreplsp:	ld a,' ' 
2acf 12					ld (de), a 
2ad0 18 f7				jr .listnxt 
2ad2			 
2ad2			; close up uword def 
2ad2			 
2ad2			.listdone: 
2ad2 12					ld (de), a 
2ad3 13					inc de 
2ad4 3e 00				ld a, 0 
2ad6 12					ld (de), a 
2ad7			 
2ad7			; now have def so clean up and push to stack 
2ad7			 
2ad7 21 c4 e2				ld hl, scratch 
2ada				if DEBUG_FORTH_WORDS 
2ada					DMARK "Ltp" 
2ada f5				push af  
2adb 3a ef 2a			ld a, (.dmark)  
2ade 32 6e ee			ld (debug_mark),a  
2ae1 3a f0 2a			ld a, (.dmark+1)  
2ae4 32 6f ee			ld (debug_mark+1),a  
2ae7 3a f1 2a			ld a, (.dmark+2)  
2aea 32 70 ee			ld (debug_mark+2),a  
2aed 18 03			jr .pastdmark  
2aef ..			.dmark: db "Ltp"  
2af2 f1			.pastdmark: pop af  
2af3			endm  
# End of macro DMARK
2af3					CALLMONITOR 
2af3 cd 72 ee			call debug_vector  
2af6				endm  
# End of macro CALLMONITOR
2af6				endif 
2af6			 
2af6 18 1f			jr .listpush 
2af8			 
2af8			;.lnuword:	pop hl 
2af8			;		call forth_tok_next 
2af8			;		jp .ldouscan  
2af8			 
2af8			.lunotfound:		  
2af8			 
2af8				if DEBUG_FORTH_WORDS 
2af8					DMARK "LSn" 
2af8 f5				push af  
2af9 3a 0d 2b			ld a, (.dmark)  
2afc 32 6e ee			ld (debug_mark),a  
2aff 3a 0e 2b			ld a, (.dmark+1)  
2b02 32 6f ee			ld (debug_mark+1),a  
2b05 3a 0f 2b			ld a, (.dmark+2)  
2b08 32 70 ee			ld (debug_mark+2),a  
2b0b 18 03			jr .pastdmark  
2b0d ..			.dmark: db "LSn"  
2b10 f1			.pastdmark: pop af  
2b11			endm  
# End of macro DMARK
2b11					CALLMONITOR 
2b11 cd 72 ee			call debug_vector  
2b14				endm  
# End of macro CALLMONITOR
2b14				endif 
2b14			 
2b14					 
2b14			;		FORTH_DSP_POP 
2b14			;		ld hl, .luno 
2b14			 
2b14					NEXTW			 
2b14 c3 01 20			jp macro_next 
2b17				endm 
# End of macro NEXTW
2b17			 
2b17			.listpush: 
2b17				if DEBUG_FORTH_WORDS 
2b17					DMARK "LS>" 
2b17 f5				push af  
2b18 3a 2c 2b			ld a, (.dmark)  
2b1b 32 6e ee			ld (debug_mark),a  
2b1e 3a 2d 2b			ld a, (.dmark+1)  
2b21 32 6f ee			ld (debug_mark+1),a  
2b24 3a 2e 2b			ld a, (.dmark+2)  
2b27 32 70 ee			ld (debug_mark+2),a  
2b2a 18 03			jr .pastdmark  
2b2c ..			.dmark: db "LS>"  
2b2f f1			.pastdmark: pop af  
2b30			endm  
# End of macro DMARK
2b30					CALLMONITOR 
2b30 cd 72 ee			call debug_vector  
2b33				endm  
# End of macro CALLMONITOR
2b33				endif 
2b33 cd c2 1c				call forth_push_str 
2b36			 
2b36			 
2b36			 
2b36					NEXTW 
2b36 c3 01 20			jp macro_next 
2b39				endm 
# End of macro NEXTW
2b39			 
2b39			;.luno:    db "Word not found",0 
2b39			 
2b39			 
2b39			 
2b39			 
2b39			 
2b39			;		push hl   ; save pointer to start of uword def string 
2b39			; 
2b39			;; look for FORTH_EOL_LINE 
2b39			;		ld a, FORTH_END_BUFFER 
2b39			;		call strlent 
2b39			; 
2b39			;		inc hl		 ; space for coln def 
2b39			;		inc hl 
2b39			;		inc hl          ; space for terms 
2b39			;		inc hl 
2b39			; 
2b39			;		ld a, 20   ; TODO get actual length 
2b39			;		call addatohl    ; include a random amount of room for the uword name 
2b39			; 
2b39			;		 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt1" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;		 
2b39			; 
2b39			;; malloc space for the string because we cant change it 
2b39			; 
2b39			;		call malloc 
2b39			;	if DEBUG_FORTH_MALLOC_GUARD 
2b39			;		push af 
2b39			;		call ishlzero 
2b39			;		pop af 
2b39			;		 
2b39			;		call z,malloc_error 
2b39			;	endif 
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt2" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;		pop de 
2b39			;		push hl    ; push the malloc to release later 
2b39			;		push hl   ;  push back a copy for the later stack push 
2b39			;		 
2b39			;; copy the string swapping out the zero terms for spaces 
2b39			; 
2b39			;		; de has our source 
2b39			;		; hl has our dest 
2b39			; 
2b39			;; add the coln def 
2b39			; 
2b39			;		ld a, ':' 
2b39			;		ld (hl), a 
2b39			;		inc hl 
2b39			;		ld a, ' ' 
2b39			;		ld (hl), a 
2b39			;		inc hl 
2b39			; 
2b39			;; add the uname word 
2b39			;		push de   ; save our string for now 
2b39			;		ex de, hl 
2b39			; 
2b39			;		FORTH_DSP_VALUE 
2b39			;		;v5 FORTH_DSP_VALUE 
2b39			; 
2b39			;		inc hl   ; skip type but we know by now this is OK 
2b39			; 
2b39			;.luword:	ld a,(hl) 
2b39			;		cp 0 
2b39			;		jr z, .luword2 
2b39			;		ld (de), a 
2b39			;		inc de 
2b39			;		inc hl 
2b39			;		jr .luword 
2b39			; 
2b39			;.luword2:	ld a, ' ' 
2b39			;		ld (de), a 
2b39			;;		inc hl 
2b39			;;		inc de 
2b39			;;		ld (de), a 
2b39			;;		inc hl 
2b39			;		inc de 
2b39			; 
2b39			;		ex de, hl 
2b39			;		pop de 
2b39			;		 
2b39			;		 
2b39			; 
2b39			;; detoken that string and copy it 
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt2" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;.ldetok:	ld a, (de) 
2b39			;		cp FORTH_END_BUFFER 
2b39			;		jr z, .ldetokend 
2b39			;		; swap out any zero term for space 
2b39			;		cp 0 
2b39			;		jr nz, .ldetoknext 
2b39			;		ld a, ' ' 
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "LtS" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;.ldetoknext:	ld (hl), a 
2b39			;		inc de 
2b39			;		inc hl 
2b39			;		jr .ldetok 
2b39			; 
2b39			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b39			;		ld (hl), a  
2b39			; 
2b39			;; free that temp malloc 
2b39			; 
2b39			;		pop hl    
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt4" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;		call forth_apushstrhl 
2b39			; 
2b39			;		; get rid of temp malloc area 
2b39			; 
2b39			;		pop hl 
2b39			;		call free 
2b39			; 
2b39			;		jr .ludone 
2b39			; 
2b39			;.lnuword:	pop hl 
2b39			;		call forth_tok_next 
2b39			;		jp .ldouscan  
2b39			; 
2b39			;.ludone:		 pop hl 
2b39			; 
2b39					NEXTW 
2b39 c3 01 20			jp macro_next 
2b3c				endm 
# End of macro NEXTW
2b3c			 
2b3c			.FORGET: 
2b3c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b3c 5d				db WORD_SYS_CORE+73             
2b3d b5 2b			dw .NOP            
2b3f 07				db 6 + 1 
2b40 .. 00			db "FORGET",0              
2b47				endm 
# End of macro CWHEAD
2b47			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b47			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b47			; | |  
2b47			; | | e.g. "MORE" forget 
2b47					if DEBUG_FORTH_WORDS_KEY 
2b47						DMARK "FRG" 
2b47 f5				push af  
2b48 3a 5c 2b			ld a, (.dmark)  
2b4b 32 6e ee			ld (debug_mark),a  
2b4e 3a 5d 2b			ld a, (.dmark+1)  
2b51 32 6f ee			ld (debug_mark+1),a  
2b54 3a 5e 2b			ld a, (.dmark+2)  
2b57 32 70 ee			ld (debug_mark+2),a  
2b5a 18 03			jr .pastdmark  
2b5c ..			.dmark: db "FRG"  
2b5f f1			.pastdmark: pop af  
2b60			endm  
# End of macro DMARK
2b60						CALLMONITOR 
2b60 cd 72 ee			call debug_vector  
2b63				endm  
# End of macro CALLMONITOR
2b63					endif 
2b63			 
2b63				; find uword 
2b63			        ; update start of word with "_" 
2b63				; replace uword with deleted flag 
2b63			 
2b63			 
2b63			;	if DEBUG_FORTH_WORDS 
2b63			;		DMARK "FOG" 
2b63			;		CALLMONITOR 
2b63			;	endif 
2b63			 
2b63			 
2b63					; Get ptr to the word we need to look up 
2b63			 
2b63					FORTH_DSP_VALUEHL 
2b63 cd 4b 1e			call macro_dsp_valuehl 
2b66				endm 
# End of macro FORTH_DSP_VALUEHL
2b66					;v5 FORTH_DSP_VALUE 
2b66				; TODO type check 
2b66			;		inc hl    ; Skip type check  
2b66 e5					push hl 
2b67 c1					pop bc 
2b68			;		ex de, hl    ; put into DE 
2b68			 
2b68			 
2b68 21 ae 64				ld hl, baseram 
2b6b					;ld hl, baseusermem 
2b6b			 
2b6b				; skip dict stub 
2b6b			;	call forth_tok_next 
2b6b e5			push hl   ; sacreifical push 
2b6c			 
2b6c			.fldouscanm: 
2b6c e1				pop hl 
2b6d			.fldouscan: 
2b6d			;	if DEBUG_FORTH_WORDS 
2b6d			;		DMARK "LSs" 
2b6d			;		CALLMONITOR 
2b6d			;	endif 
2b6d				; skip dict stub 
2b6d cd 52 21				call forth_tok_next 
2b70			 
2b70			 
2b70			; while we have words to look for 
2b70			 
2b70 7e				ld a, (hl)      
2b71			;	if DEBUG_FORTH_WORDS 
2b71			;		DMARK "LSk" 
2b71			;		CALLMONITOR 
2b71			;	endif 
2b71 fe 00				cp WORD_SYS_END 
2b73 ca af 2b				jp z, .flunotfound 
2b76 fe 01				cp WORD_SYS_UWORD 
2b78 c2 6d 2b				jp nz, .fldouscan 
2b7b			 
2b7b			;	if DEBUG_FORTH_WORDS 
2b7b			;		DMARK "LSu" 
2b7b			;		CALLMONITOR 
2b7b			;	endif 
2b7b			 
2b7b					; found a uword but is it the one we want... 
2b7b			 
2b7b c5					push bc     ; uword to find is on bc 
2b7c d1					pop de 
2b7d			 
2b7d e5					push hl  ; to save the ptr 
2b7e			 
2b7e					; skip opcode 
2b7e 23					inc hl  
2b7f					; skip next ptr 
2b7f 23					inc hl  
2b80 23					inc hl 
2b81					; skip len 
2b81 23					inc hl 
2b82			 
2b82			;	if DEBUG_FORTH_WORDS 
2b82			;		DMARK "LSc" 
2b82			;		CALLMONITOR 
2b82			;	endif 
2b82 cd 7d 12				call strcmp 
2b85 c2 6c 2b				jp nz, .fldouscanm 
2b88			; 
2b88			; 
2b88			;; while we have words to look for 
2b88			; 
2b88			;.fdouscan:	ld a, (hl)      
2b88			;	if DEBUG_FORTH_WORDS 
2b88			;		DMARK "LSs" 
2b88			;		CALLMONITOR 
2b88			;	endif 
2b88			;		cp WORD_SYS_END 
2b88			;		jp z, .fudone 
2b88			;		cp WORD_SYS_UWORD 
2b88			;		jp nz, .fnuword 
2b88			; 
2b88			;	if DEBUG_FORTH_WORDS 
2b88			;		DMARK "FGu" 
2b88			;		CALLMONITOR 
2b88			;	endif 
2b88			; 
2b88			;		; found a uword but is it the one we want... 
2b88			; 
2b88			; 
2b88			;	        pop de   ; get back the dsp name 
2b88			;		push de 
2b88			; 
2b88			;		push hl  ; to save the ptr 
2b88			; 
2b88			;		; skip opcode 
2b88			;		inc hl  
2b88			;		; skip next ptr 
2b88			;		inc hl  
2b88			;		inc hl 
2b88			;		; skip len 
2b88			;		inc hl 
2b88			; 
2b88			;	if DEBUG_FORTH_WORDS 
2b88			;		DMARK "FGc" 
2b88			;		CALLMONITOR 
2b88			;	endif 
2b88			;		call strcmp 
2b88			;		jp nz, .fnuword 
2b88			 
2b88			 
2b88 e1			pop hl 
2b89			 
2b89				 
2b89				if DEBUG_FORTH_WORDS 
2b89					DMARK "FGm" 
2b89 f5				push af  
2b8a 3a 9e 2b			ld a, (.dmark)  
2b8d 32 6e ee			ld (debug_mark),a  
2b90 3a 9f 2b			ld a, (.dmark+1)  
2b93 32 6f ee			ld (debug_mark+1),a  
2b96 3a a0 2b			ld a, (.dmark+2)  
2b99 32 70 ee			ld (debug_mark+2),a  
2b9c 18 03			jr .pastdmark  
2b9e ..			.dmark: db "FGm"  
2ba1 f1			.pastdmark: pop af  
2ba2			endm  
# End of macro DMARK
2ba2					CALLMONITOR 
2ba2 cd 72 ee			call debug_vector  
2ba5				endm  
# End of macro CALLMONITOR
2ba5				endif 
2ba5			 
2ba5			 
2ba5			 
2ba5					; we have a uword so push its name to the stack 
2ba5			 
2ba5			;	   	push hl  ; save so we can move to next dict block 
2ba5			;pop hl 
2ba5			 
2ba5					; update opcode to deleted 
2ba5 3e 03				ld a, WORD_SYS_DELETED 
2ba7 77					ld (hl), a 
2ba8			 
2ba8 23					inc hl  
2ba9					; skip next ptr 
2ba9 23					inc hl  
2baa 23					inc hl 
2bab					; skip len 
2bab 23					inc hl 
2bac			 
2bac					; TODO change parser to skip deleted words but for now mark it out 
2bac 3e 5f				ld a, "_" 
2bae 77					ld  (hl),a 
2baf			 
2baf			;		jr .fudone 
2baf			; 
2baf			;.fnuword:	pop hl 
2baf			;		call forth_tok_next 
2baf			;		jp .fdouscan  
2baf			 
2baf			.flunotfound:		  
2baf			 
2baf			 
2baf					 
2baf					FORTH_DSP_POP 
2baf cd 03 1f			call macro_forth_dsp_pop 
2bb2				endm 
# End of macro FORTH_DSP_POP
2bb2			;		ld hl, .luno 
2bb2			;.fudone:		 pop hl 
2bb2					NEXTW 
2bb2 c3 01 20			jp macro_next 
2bb5				endm 
# End of macro NEXTW
2bb5			.NOP: 
2bb5				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bb5 61				db WORD_SYS_CORE+77             
2bb6 dc 2b			dw .COMO            
2bb8 04				db 3 + 1 
2bb9 .. 00			db "NOP",0              
2bbd				endm 
# End of macro CWHEAD
2bbd			; | NOP (  --  ) Do nothing | DONE 
2bbd					if DEBUG_FORTH_WORDS_KEY 
2bbd						DMARK "NOP" 
2bbd f5				push af  
2bbe 3a d2 2b			ld a, (.dmark)  
2bc1 32 6e ee			ld (debug_mark),a  
2bc4 3a d3 2b			ld a, (.dmark+1)  
2bc7 32 6f ee			ld (debug_mark+1),a  
2bca 3a d4 2b			ld a, (.dmark+2)  
2bcd 32 70 ee			ld (debug_mark+2),a  
2bd0 18 03			jr .pastdmark  
2bd2 ..			.dmark: db "NOP"  
2bd5 f1			.pastdmark: pop af  
2bd6			endm  
# End of macro DMARK
2bd6						CALLMONITOR 
2bd6 cd 72 ee			call debug_vector  
2bd9				endm  
# End of macro CALLMONITOR
2bd9					endif 
2bd9				       NEXTW 
2bd9 c3 01 20			jp macro_next 
2bdc				endm 
# End of macro NEXTW
2bdc			.COMO: 
2bdc				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bdc 6e				db WORD_SYS_CORE+90             
2bdd 2e 2c			dw .COMC            
2bdf 02				db 1 + 1 
2be0 .. 00			db "(",0              
2be2				endm 
# End of macro CWHEAD
2be2			; | ( ( -- )  Start of comment | DONE 
2be2			 
2be2			 
2be2 2a c5 e5				ld hl, ( os_tok_ptr) 
2be5 11 29 2c			ld de, .closepar 
2be8					 
2be8					if DEBUG_FORTH_WORDS 
2be8						DMARK ").." 
2be8 f5				push af  
2be9 3a fd 2b			ld a, (.dmark)  
2bec 32 6e ee			ld (debug_mark),a  
2bef 3a fe 2b			ld a, (.dmark+1)  
2bf2 32 6f ee			ld (debug_mark+1),a  
2bf5 3a ff 2b			ld a, (.dmark+2)  
2bf8 32 70 ee			ld (debug_mark+2),a  
2bfb 18 03			jr .pastdmark  
2bfd ..			.dmark: db ").."  
2c00 f1			.pastdmark: pop af  
2c01			endm  
# End of macro DMARK
2c01						CALLMONITOR 
2c01 cd 72 ee			call debug_vector  
2c04				endm  
# End of macro CALLMONITOR
2c04					endif 
2c04 cd 1c 21			call findnexttok  
2c07			 
2c07					if DEBUG_FORTH_WORDS 
2c07						DMARK "IF5" 
2c07 f5				push af  
2c08 3a 1c 2c			ld a, (.dmark)  
2c0b 32 6e ee			ld (debug_mark),a  
2c0e 3a 1d 2c			ld a, (.dmark+1)  
2c11 32 6f ee			ld (debug_mark+1),a  
2c14 3a 1e 2c			ld a, (.dmark+2)  
2c17 32 70 ee			ld (debug_mark+2),a  
2c1a 18 03			jr .pastdmark  
2c1c ..			.dmark: db "IF5"  
2c1f f1			.pastdmark: pop af  
2c20			endm  
# End of macro DMARK
2c20						CALLMONITOR 
2c20 cd 72 ee			call debug_vector  
2c23				endm  
# End of macro CALLMONITOR
2c23					endif 
2c23				; replace below with ) exec using tok_ptr 
2c23 22 c5 e5			ld (os_tok_ptr), hl 
2c26 c3 92 20			jp exec1 
2c29			 
2c29 .. 00			.closepar:   db ")",0 
2c2b			 
2c2b				       NEXTW 
2c2b c3 01 20			jp macro_next 
2c2e				endm 
# End of macro NEXTW
2c2e			.COMC: 
2c2e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c2e 6f				db WORD_SYS_CORE+91             
2c2f 37 2c			dw .SCRATCH            
2c31 02				db 1 + 1 
2c32 .. 00			db ")",0              
2c34				endm 
# End of macro CWHEAD
2c34			; | ) ( -- )  End of comment |  DONE  
2c34				       NEXTW 
2c34 c3 01 20			jp macro_next 
2c37				endm 
# End of macro NEXTW
2c37			 
2c37			.SCRATCH: 
2c37				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c37 6f				db WORD_SYS_CORE+91             
2c38 72 2c			dw .INC            
2c3a 08				db 7 + 1 
2c3b .. 00			db "SCRATCH",0              
2c43				endm 
# End of macro CWHEAD
2c43			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c43			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c43			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c43			; | |  
2c43			; | | e.g.    : score $00 scratch ; 
2c43			; | |  
2c43			; | | $00 score ! 
2c43			; | | $01 score +! 
2c43			; | |  
2c43			; | | e.g.   : varword $0a scratch ;  
2c43			; | | 
2c43			; | | $8000 varword ! 
2c43					if DEBUG_FORTH_WORDS_KEY 
2c43						DMARK "SCR" 
2c43 f5				push af  
2c44 3a 58 2c			ld a, (.dmark)  
2c47 32 6e ee			ld (debug_mark),a  
2c4a 3a 59 2c			ld a, (.dmark+1)  
2c4d 32 6f ee			ld (debug_mark+1),a  
2c50 3a 5a 2c			ld a, (.dmark+2)  
2c53 32 70 ee			ld (debug_mark+2),a  
2c56 18 03			jr .pastdmark  
2c58 ..			.dmark: db "SCR"  
2c5b f1			.pastdmark: pop af  
2c5c			endm  
# End of macro DMARK
2c5c						CALLMONITOR 
2c5c cd 72 ee			call debug_vector  
2c5f				endm  
# End of macro CALLMONITOR
2c5f					endif 
2c5f			 
2c5f					FORTH_DSP_VALUEHL 
2c5f cd 4b 1e			call macro_dsp_valuehl 
2c62				endm 
# End of macro FORTH_DSP_VALUEHL
2c62				 
2c62					FORTH_DSP_POP 
2c62 cd 03 1f			call macro_forth_dsp_pop 
2c65				endm 
# End of macro FORTH_DSP_POP
2c65			 
2c65 7d					ld a, l 
2c66 21 e9 e7				ld hl, os_var_array 
2c69 cd e7 0d				call addatohl 
2c6c			 
2c6c cd 54 1c				call forth_push_numhl 
2c6f			 
2c6f				       NEXTW 
2c6f c3 01 20			jp macro_next 
2c72				endm 
# End of macro NEXTW
2c72			 
2c72			.INC: 
2c72				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c72 6f				db WORD_SYS_CORE+91             
2c73 c6 2c			dw .DEC            
2c75 03				db 2 + 1 
2c76 .. 00			db "+!",0              
2c79				endm 
# End of macro CWHEAD
2c79			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c79					if DEBUG_FORTH_WORDS_KEY 
2c79						DMARK "+s_" 
2c79 f5				push af  
2c7a 3a 8e 2c			ld a, (.dmark)  
2c7d 32 6e ee			ld (debug_mark),a  
2c80 3a 8f 2c			ld a, (.dmark+1)  
2c83 32 6f ee			ld (debug_mark+1),a  
2c86 3a 90 2c			ld a, (.dmark+2)  
2c89 32 70 ee			ld (debug_mark+2),a  
2c8c 18 03			jr .pastdmark  
2c8e ..			.dmark: db "+s_"  
2c91 f1			.pastdmark: pop af  
2c92			endm  
# End of macro DMARK
2c92						CALLMONITOR 
2c92 cd 72 ee			call debug_vector  
2c95				endm  
# End of macro CALLMONITOR
2c95					endif 
2c95			 
2c95					FORTH_DSP_VALUEHL 
2c95 cd 4b 1e			call macro_dsp_valuehl 
2c98				endm 
# End of macro FORTH_DSP_VALUEHL
2c98			 
2c98 e5					push hl   ; save address 
2c99			 
2c99					FORTH_DSP_POP 
2c99 cd 03 1f			call macro_forth_dsp_pop 
2c9c				endm 
# End of macro FORTH_DSP_POP
2c9c			 
2c9c					FORTH_DSP_VALUEHL 
2c9c cd 4b 1e			call macro_dsp_valuehl 
2c9f				endm 
# End of macro FORTH_DSP_VALUEHL
2c9f			 
2c9f					FORTH_DSP_POP 
2c9f cd 03 1f			call macro_forth_dsp_pop 
2ca2				endm 
# End of macro FORTH_DSP_POP
2ca2			 
2ca2					; hl contains value to add to byte at a 
2ca2				 
2ca2 eb					ex de, hl 
2ca3			 
2ca3 e1					pop hl 
2ca4			 
2ca4					if DEBUG_FORTH_WORDS 
2ca4						DMARK "INC" 
2ca4 f5				push af  
2ca5 3a b9 2c			ld a, (.dmark)  
2ca8 32 6e ee			ld (debug_mark),a  
2cab 3a ba 2c			ld a, (.dmark+1)  
2cae 32 6f ee			ld (debug_mark+1),a  
2cb1 3a bb 2c			ld a, (.dmark+2)  
2cb4 32 70 ee			ld (debug_mark+2),a  
2cb7 18 03			jr .pastdmark  
2cb9 ..			.dmark: db "INC"  
2cbc f1			.pastdmark: pop af  
2cbd			endm  
# End of macro DMARK
2cbd						CALLMONITOR 
2cbd cd 72 ee			call debug_vector  
2cc0				endm  
# End of macro CALLMONITOR
2cc0					endif 
2cc0			 
2cc0 7e					ld a,(hl) 
2cc1 83					add e 
2cc2 77					ld (hl),a 
2cc3			 
2cc3			 
2cc3			 
2cc3				       NEXTW 
2cc3 c3 01 20			jp macro_next 
2cc6				endm 
# End of macro NEXTW
2cc6			 
2cc6			.DEC: 
2cc6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cc6 6f				db WORD_SYS_CORE+91             
2cc7 17 2d			dw .INC2            
2cc9 03				db 2 + 1 
2cca .. 00			db "-!",0              
2ccd				endm 
# End of macro CWHEAD
2ccd			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ccd					if DEBUG_FORTH_WORDS_KEY 
2ccd						DMARK "-s_" 
2ccd f5				push af  
2cce 3a e2 2c			ld a, (.dmark)  
2cd1 32 6e ee			ld (debug_mark),a  
2cd4 3a e3 2c			ld a, (.dmark+1)  
2cd7 32 6f ee			ld (debug_mark+1),a  
2cda 3a e4 2c			ld a, (.dmark+2)  
2cdd 32 70 ee			ld (debug_mark+2),a  
2ce0 18 03			jr .pastdmark  
2ce2 ..			.dmark: db "-s_"  
2ce5 f1			.pastdmark: pop af  
2ce6			endm  
# End of macro DMARK
2ce6						CALLMONITOR 
2ce6 cd 72 ee			call debug_vector  
2ce9				endm  
# End of macro CALLMONITOR
2ce9					endif 
2ce9			 
2ce9					FORTH_DSP_VALUEHL 
2ce9 cd 4b 1e			call macro_dsp_valuehl 
2cec				endm 
# End of macro FORTH_DSP_VALUEHL
2cec			 
2cec e5					push hl   ; save address 
2ced			 
2ced					FORTH_DSP_POP 
2ced cd 03 1f			call macro_forth_dsp_pop 
2cf0				endm 
# End of macro FORTH_DSP_POP
2cf0			 
2cf0					FORTH_DSP_VALUEHL 
2cf0 cd 4b 1e			call macro_dsp_valuehl 
2cf3				endm 
# End of macro FORTH_DSP_VALUEHL
2cf3			 
2cf3					; hl contains value to add to byte at a 
2cf3				 
2cf3 eb					ex de, hl 
2cf4			 
2cf4 e1					pop hl 
2cf5			 
2cf5					if DEBUG_FORTH_WORDS 
2cf5						DMARK "DEC" 
2cf5 f5				push af  
2cf6 3a 0a 2d			ld a, (.dmark)  
2cf9 32 6e ee			ld (debug_mark),a  
2cfc 3a 0b 2d			ld a, (.dmark+1)  
2cff 32 6f ee			ld (debug_mark+1),a  
2d02 3a 0c 2d			ld a, (.dmark+2)  
2d05 32 70 ee			ld (debug_mark+2),a  
2d08 18 03			jr .pastdmark  
2d0a ..			.dmark: db "DEC"  
2d0d f1			.pastdmark: pop af  
2d0e			endm  
# End of macro DMARK
2d0e						CALLMONITOR 
2d0e cd 72 ee			call debug_vector  
2d11				endm  
# End of macro CALLMONITOR
2d11					endif 
2d11			 
2d11 7e					ld a,(hl) 
2d12 93					sub e 
2d13 77					ld (hl),a 
2d14			 
2d14			 
2d14			 
2d14				       NEXTW 
2d14 c3 01 20			jp macro_next 
2d17				endm 
# End of macro NEXTW
2d17			 
2d17			.INC2: 
2d17				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d17 6f				db WORD_SYS_CORE+91             
2d18 c1 2d			dw .DEC2            
2d1a 04				db 3 + 1 
2d1b .. 00			db "+2!",0              
2d1f				endm 
# End of macro CWHEAD
2d1f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d1f			 
2d1f					if DEBUG_FORTH_WORDS_KEY 
2d1f						DMARK "+2s" 
2d1f f5				push af  
2d20 3a 34 2d			ld a, (.dmark)  
2d23 32 6e ee			ld (debug_mark),a  
2d26 3a 35 2d			ld a, (.dmark+1)  
2d29 32 6f ee			ld (debug_mark+1),a  
2d2c 3a 36 2d			ld a, (.dmark+2)  
2d2f 32 70 ee			ld (debug_mark+2),a  
2d32 18 03			jr .pastdmark  
2d34 ..			.dmark: db "+2s"  
2d37 f1			.pastdmark: pop af  
2d38			endm  
# End of macro DMARK
2d38						CALLMONITOR 
2d38 cd 72 ee			call debug_vector  
2d3b				endm  
# End of macro CALLMONITOR
2d3b					endif 
2d3b			 
2d3b					; Address 
2d3b			 
2d3b					FORTH_DSP_VALUEHL 
2d3b cd 4b 1e			call macro_dsp_valuehl 
2d3e				endm 
# End of macro FORTH_DSP_VALUEHL
2d3e			 
2d3e e5					push hl    ; save address 
2d3f			 
2d3f					; load content into de 
2d3f			 
2d3f 5e					ld e,(hl) 
2d40 23					inc hl 
2d41 56					ld d, (hl) 
2d42			 
2d42					if DEBUG_FORTH_WORDS 
2d42						DMARK "+2a" 
2d42 f5				push af  
2d43 3a 57 2d			ld a, (.dmark)  
2d46 32 6e ee			ld (debug_mark),a  
2d49 3a 58 2d			ld a, (.dmark+1)  
2d4c 32 6f ee			ld (debug_mark+1),a  
2d4f 3a 59 2d			ld a, (.dmark+2)  
2d52 32 70 ee			ld (debug_mark+2),a  
2d55 18 03			jr .pastdmark  
2d57 ..			.dmark: db "+2a"  
2d5a f1			.pastdmark: pop af  
2d5b			endm  
# End of macro DMARK
2d5b						CALLMONITOR 
2d5b cd 72 ee			call debug_vector  
2d5e				endm  
# End of macro CALLMONITOR
2d5e					endif 
2d5e			 
2d5e					FORTH_DSP_POP 
2d5e cd 03 1f			call macro_forth_dsp_pop 
2d61				endm 
# End of macro FORTH_DSP_POP
2d61			 
2d61					; Get value to add 
2d61			 
2d61					FORTH_DSP_VALUE 
2d61 cd 34 1e			call macro_forth_dsp_value 
2d64				endm 
# End of macro FORTH_DSP_VALUE
2d64			 
2d64					if DEBUG_FORTH_WORDS 
2d64						DMARK "+2v" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 6e ee			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 6f ee			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 70 ee			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "+2v"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d						CALLMONITOR 
2d7d cd 72 ee			call debug_vector  
2d80				endm  
# End of macro CALLMONITOR
2d80					endif 
2d80			 
2d80 19					add hl, de 
2d81			 
2d81					if DEBUG_FORTH_WORDS 
2d81						DMARK "+2+" 
2d81 f5				push af  
2d82 3a 96 2d			ld a, (.dmark)  
2d85 32 6e ee			ld (debug_mark),a  
2d88 3a 97 2d			ld a, (.dmark+1)  
2d8b 32 6f ee			ld (debug_mark+1),a  
2d8e 3a 98 2d			ld a, (.dmark+2)  
2d91 32 70 ee			ld (debug_mark+2),a  
2d94 18 03			jr .pastdmark  
2d96 ..			.dmark: db "+2+"  
2d99 f1			.pastdmark: pop af  
2d9a			endm  
# End of macro DMARK
2d9a						CALLMONITOR 
2d9a cd 72 ee			call debug_vector  
2d9d				endm  
# End of macro CALLMONITOR
2d9d					endif 
2d9d			 
2d9d					; move result to de 
2d9d			 
2d9d eb					ex de, hl 
2d9e			 
2d9e					; Address 
2d9e			 
2d9e e1					pop hl 
2d9f			 
2d9f					; save it back 
2d9f			 
2d9f 73					ld (hl), e 
2da0 23					inc hl 
2da1 72					ld (hl), d 
2da2			 
2da2					if DEBUG_FORTH_WORDS 
2da2						DMARK "+2e" 
2da2 f5				push af  
2da3 3a b7 2d			ld a, (.dmark)  
2da6 32 6e ee			ld (debug_mark),a  
2da9 3a b8 2d			ld a, (.dmark+1)  
2dac 32 6f ee			ld (debug_mark+1),a  
2daf 3a b9 2d			ld a, (.dmark+2)  
2db2 32 70 ee			ld (debug_mark+2),a  
2db5 18 03			jr .pastdmark  
2db7 ..			.dmark: db "+2e"  
2dba f1			.pastdmark: pop af  
2dbb			endm  
# End of macro DMARK
2dbb						CALLMONITOR 
2dbb cd 72 ee			call debug_vector  
2dbe				endm  
# End of macro CALLMONITOR
2dbe					endif 
2dbe			 
2dbe			 
2dbe			 
2dbe			 
2dbe			 
2dbe				       NEXTW 
2dbe c3 01 20			jp macro_next 
2dc1				endm 
# End of macro NEXTW
2dc1			 
2dc1			.DEC2: 
2dc1				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dc1 6f				db WORD_SYS_CORE+91             
2dc2 6d 2e			dw .GET2            
2dc4 04				db 3 + 1 
2dc5 .. 00			db "-2!",0              
2dc9				endm 
# End of macro CWHEAD
2dc9			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dc9			 
2dc9			 
2dc9					if DEBUG_FORTH_WORDS_KEY 
2dc9						DMARK "-2s" 
2dc9 f5				push af  
2dca 3a de 2d			ld a, (.dmark)  
2dcd 32 6e ee			ld (debug_mark),a  
2dd0 3a df 2d			ld a, (.dmark+1)  
2dd3 32 6f ee			ld (debug_mark+1),a  
2dd6 3a e0 2d			ld a, (.dmark+2)  
2dd9 32 70 ee			ld (debug_mark+2),a  
2ddc 18 03			jr .pastdmark  
2dde ..			.dmark: db "-2s"  
2de1 f1			.pastdmark: pop af  
2de2			endm  
# End of macro DMARK
2de2						CALLMONITOR 
2de2 cd 72 ee			call debug_vector  
2de5				endm  
# End of macro CALLMONITOR
2de5					endif 
2de5			 
2de5					; Address 
2de5			 
2de5					FORTH_DSP_VALUEHL 
2de5 cd 4b 1e			call macro_dsp_valuehl 
2de8				endm 
# End of macro FORTH_DSP_VALUEHL
2de8			 
2de8 e5					push hl    ; save address 
2de9			 
2de9					; load content into de 
2de9			 
2de9 5e					ld e,(hl) 
2dea 23					inc hl 
2deb 56					ld d, (hl) 
2dec			 
2dec					if DEBUG_FORTH_WORDS 
2dec						DMARK "-2a" 
2dec f5				push af  
2ded 3a 01 2e			ld a, (.dmark)  
2df0 32 6e ee			ld (debug_mark),a  
2df3 3a 02 2e			ld a, (.dmark+1)  
2df6 32 6f ee			ld (debug_mark+1),a  
2df9 3a 03 2e			ld a, (.dmark+2)  
2dfc 32 70 ee			ld (debug_mark+2),a  
2dff 18 03			jr .pastdmark  
2e01 ..			.dmark: db "-2a"  
2e04 f1			.pastdmark: pop af  
2e05			endm  
# End of macro DMARK
2e05						CALLMONITOR 
2e05 cd 72 ee			call debug_vector  
2e08				endm  
# End of macro CALLMONITOR
2e08					endif 
2e08			 
2e08					FORTH_DSP_POP 
2e08 cd 03 1f			call macro_forth_dsp_pop 
2e0b				endm 
# End of macro FORTH_DSP_POP
2e0b			 
2e0b					; Get value to remove 
2e0b			 
2e0b					FORTH_DSP_VALUE 
2e0b cd 34 1e			call macro_forth_dsp_value 
2e0e				endm 
# End of macro FORTH_DSP_VALUE
2e0e			 
2e0e					if DEBUG_FORTH_WORDS 
2e0e						DMARK "-2v" 
2e0e f5				push af  
2e0f 3a 23 2e			ld a, (.dmark)  
2e12 32 6e ee			ld (debug_mark),a  
2e15 3a 24 2e			ld a, (.dmark+1)  
2e18 32 6f ee			ld (debug_mark+1),a  
2e1b 3a 25 2e			ld a, (.dmark+2)  
2e1e 32 70 ee			ld (debug_mark+2),a  
2e21 18 03			jr .pastdmark  
2e23 ..			.dmark: db "-2v"  
2e26 f1			.pastdmark: pop af  
2e27			endm  
# End of macro DMARK
2e27						CALLMONITOR 
2e27 cd 72 ee			call debug_vector  
2e2a				endm  
# End of macro CALLMONITOR
2e2a					endif 
2e2a			 
2e2a eb					ex de, hl 
2e2b ed 52				sbc hl, de 
2e2d			 
2e2d					if DEBUG_FORTH_WORDS 
2e2d						DMARK "-2d" 
2e2d f5				push af  
2e2e 3a 42 2e			ld a, (.dmark)  
2e31 32 6e ee			ld (debug_mark),a  
2e34 3a 43 2e			ld a, (.dmark+1)  
2e37 32 6f ee			ld (debug_mark+1),a  
2e3a 3a 44 2e			ld a, (.dmark+2)  
2e3d 32 70 ee			ld (debug_mark+2),a  
2e40 18 03			jr .pastdmark  
2e42 ..			.dmark: db "-2d"  
2e45 f1			.pastdmark: pop af  
2e46			endm  
# End of macro DMARK
2e46						CALLMONITOR 
2e46 cd 72 ee			call debug_vector  
2e49				endm  
# End of macro CALLMONITOR
2e49					endif 
2e49			 
2e49					; move result to de 
2e49			 
2e49 eb					ex de, hl 
2e4a			 
2e4a					; Address 
2e4a			 
2e4a e1					pop hl 
2e4b			 
2e4b					; save it back 
2e4b			 
2e4b 73					ld (hl), e 
2e4c 23					inc hl 
2e4d 72					ld (hl), d 
2e4e			 
2e4e					if DEBUG_FORTH_WORDS 
2e4e						DMARK "-2e" 
2e4e f5				push af  
2e4f 3a 63 2e			ld a, (.dmark)  
2e52 32 6e ee			ld (debug_mark),a  
2e55 3a 64 2e			ld a, (.dmark+1)  
2e58 32 6f ee			ld (debug_mark+1),a  
2e5b 3a 65 2e			ld a, (.dmark+2)  
2e5e 32 70 ee			ld (debug_mark+2),a  
2e61 18 03			jr .pastdmark  
2e63 ..			.dmark: db "-2e"  
2e66 f1			.pastdmark: pop af  
2e67			endm  
# End of macro DMARK
2e67						CALLMONITOR 
2e67 cd 72 ee			call debug_vector  
2e6a				endm  
# End of macro CALLMONITOR
2e6a					endif 
2e6a			 
2e6a			 
2e6a			 
2e6a			 
2e6a			 
2e6a				       NEXTW 
2e6a c3 01 20			jp macro_next 
2e6d				endm 
# End of macro NEXTW
2e6d			.GET2: 
2e6d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e6d 6f				db WORD_SYS_CORE+91             
2e6e 9d 2e			dw .BANG2            
2e70 03				db 2 + 1 
2e71 .. 00			db "2@",0              
2e74				endm 
# End of macro CWHEAD
2e74			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e74					if DEBUG_FORTH_WORDS_KEY 
2e74						DMARK "2A_" 
2e74 f5				push af  
2e75 3a 89 2e			ld a, (.dmark)  
2e78 32 6e ee			ld (debug_mark),a  
2e7b 3a 8a 2e			ld a, (.dmark+1)  
2e7e 32 6f ee			ld (debug_mark+1),a  
2e81 3a 8b 2e			ld a, (.dmark+2)  
2e84 32 70 ee			ld (debug_mark+2),a  
2e87 18 03			jr .pastdmark  
2e89 ..			.dmark: db "2A_"  
2e8c f1			.pastdmark: pop af  
2e8d			endm  
# End of macro DMARK
2e8d						CALLMONITOR 
2e8d cd 72 ee			call debug_vector  
2e90				endm  
# End of macro CALLMONITOR
2e90					endif 
2e90			 
2e90					FORTH_DSP_VALUEHL 
2e90 cd 4b 1e			call macro_dsp_valuehl 
2e93				endm 
# End of macro FORTH_DSP_VALUEHL
2e93			 
2e93 5e					ld e, (hl) 
2e94 23					inc hl 
2e95 56					ld d, (hl) 
2e96			 
2e96 eb					ex de, hl 
2e97			 
2e97 cd 54 1c				call forth_push_numhl 
2e9a			 
2e9a				       NEXTW 
2e9a c3 01 20			jp macro_next 
2e9d				endm 
# End of macro NEXTW
2e9d			.BANG2: 
2e9d				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e9d 6f				db WORD_SYS_CORE+91             
2e9e d5 2e			dw .CONFIG            
2ea0 03				db 2 + 1 
2ea1 .. 00			db "2!",0              
2ea4				endm 
# End of macro CWHEAD
2ea4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ea4					if DEBUG_FORTH_WORDS_KEY 
2ea4						DMARK "2S_" 
2ea4 f5				push af  
2ea5 3a b9 2e			ld a, (.dmark)  
2ea8 32 6e ee			ld (debug_mark),a  
2eab 3a ba 2e			ld a, (.dmark+1)  
2eae 32 6f ee			ld (debug_mark+1),a  
2eb1 3a bb 2e			ld a, (.dmark+2)  
2eb4 32 70 ee			ld (debug_mark+2),a  
2eb7 18 03			jr .pastdmark  
2eb9 ..			.dmark: db "2S_"  
2ebc f1			.pastdmark: pop af  
2ebd			endm  
# End of macro DMARK
2ebd						CALLMONITOR 
2ebd cd 72 ee			call debug_vector  
2ec0				endm  
# End of macro CALLMONITOR
2ec0					endif 
2ec0			 
2ec0					FORTH_DSP_VALUEHL 
2ec0 cd 4b 1e			call macro_dsp_valuehl 
2ec3				endm 
# End of macro FORTH_DSP_VALUEHL
2ec3			 
2ec3 e5					push hl   ; save address 
2ec4			 
2ec4			 
2ec4					FORTH_DSP_POP 
2ec4 cd 03 1f			call macro_forth_dsp_pop 
2ec7				endm 
# End of macro FORTH_DSP_POP
2ec7			 
2ec7					 
2ec7					FORTH_DSP_VALUEHL 
2ec7 cd 4b 1e			call macro_dsp_valuehl 
2eca				endm 
# End of macro FORTH_DSP_VALUEHL
2eca			 
2eca					FORTH_DSP_POP 
2eca cd 03 1f			call macro_forth_dsp_pop 
2ecd				endm 
# End of macro FORTH_DSP_POP
2ecd			 
2ecd eb					ex de, hl    ; value now in de 
2ece			 
2ece e1					pop hl 
2ecf			 
2ecf 73					ld (hl), e 
2ed0			 
2ed0 23					inc hl 
2ed1			 
2ed1 72					ld (hl), d 
2ed2			 
2ed2			 
2ed2				       NEXTW 
2ed2 c3 01 20			jp macro_next 
2ed5				endm 
# End of macro NEXTW
2ed5			.CONFIG: 
2ed5				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ed5 6f				db WORD_SYS_CORE+91             
2ed6 e6 2e			dw .ENDCORE            
2ed8 07				db 6 + 1 
2ed9 .. 00			db "CONFIG",0              
2ee0				endm 
# End of macro CWHEAD
2ee0			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ee0			 
2ee0 cd 47 14				call config 
2ee3					NEXTW 
2ee3 c3 01 20			jp macro_next 
2ee6				endm 
# End of macro NEXTW
2ee6			.ENDCORE: 
2ee6			 
2ee6			; eof 
2ee6			 
2ee6			 
# End of file forth_words_core.asm
2ee6			include "forth_words_flow.asm" 
2ee6			 
2ee6			; | ## Program Flow Words 
2ee6			 
2ee6			.IF: 
2ee6				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ee6 1e				db WORD_SYS_CORE+10             
2ee7 db 2f			dw .THEN            
2ee9 03				db 2 + 1 
2eea .. 00			db "IF",0              
2eed				endm 
# End of macro CWHEAD
2eed			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2eed			; 
2eed					if DEBUG_FORTH_WORDS_KEY 
2eed						DMARK "IF." 
2eed f5				push af  
2eee 3a 02 2f			ld a, (.dmark)  
2ef1 32 6e ee			ld (debug_mark),a  
2ef4 3a 03 2f			ld a, (.dmark+1)  
2ef7 32 6f ee			ld (debug_mark+1),a  
2efa 3a 04 2f			ld a, (.dmark+2)  
2efd 32 70 ee			ld (debug_mark+2),a  
2f00 18 03			jr .pastdmark  
2f02 ..			.dmark: db "IF."  
2f05 f1			.pastdmark: pop af  
2f06			endm  
# End of macro DMARK
2f06						CALLMONITOR 
2f06 cd 72 ee			call debug_vector  
2f09				endm  
# End of macro CALLMONITOR
2f09					endif 
2f09			; eval TOS 
2f09			 
2f09				FORTH_DSP_VALUEHL 
2f09 cd 4b 1e			call macro_dsp_valuehl 
2f0c				endm 
# End of macro FORTH_DSP_VALUEHL
2f0c			 
2f0c			;	push hl 
2f0c				FORTH_DSP_POP 
2f0c cd 03 1f			call macro_forth_dsp_pop 
2f0f				endm 
# End of macro FORTH_DSP_POP
2f0f			;	pop hl 
2f0f			 
2f0f					if DEBUG_FORTH_WORDS 
2f0f						DMARK "IF1" 
2f0f f5				push af  
2f10 3a 24 2f			ld a, (.dmark)  
2f13 32 6e ee			ld (debug_mark),a  
2f16 3a 25 2f			ld a, (.dmark+1)  
2f19 32 6f ee			ld (debug_mark+1),a  
2f1c 3a 26 2f			ld a, (.dmark+2)  
2f1f 32 70 ee			ld (debug_mark+2),a  
2f22 18 03			jr .pastdmark  
2f24 ..			.dmark: db "IF1"  
2f27 f1			.pastdmark: pop af  
2f28			endm  
# End of macro DMARK
2f28						CALLMONITOR 
2f28 cd 72 ee			call debug_vector  
2f2b				endm  
# End of macro CALLMONITOR
2f2b					endif 
2f2b b7				or a        ; clear carry flag 
2f2c 11 00 00			ld de, 0 
2f2f eb				ex de,hl 
2f30 ed 52			sbc hl, de 
2f32 c2 bc 2f			jp nz, .iftrue 
2f35			 
2f35					if DEBUG_FORTH_WORDS 
2f35						DMARK "IF2" 
2f35 f5				push af  
2f36 3a 4a 2f			ld a, (.dmark)  
2f39 32 6e ee			ld (debug_mark),a  
2f3c 3a 4b 2f			ld a, (.dmark+1)  
2f3f 32 6f ee			ld (debug_mark+1),a  
2f42 3a 4c 2f			ld a, (.dmark+2)  
2f45 32 70 ee			ld (debug_mark+2),a  
2f48 18 03			jr .pastdmark  
2f4a ..			.dmark: db "IF2"  
2f4d f1			.pastdmark: pop af  
2f4e			endm  
# End of macro DMARK
2f4e						CALLMONITOR 
2f4e cd 72 ee			call debug_vector  
2f51				endm  
# End of macro CALLMONITOR
2f51					endif 
2f51			 
2f51			; if not true then skip to THEN 
2f51			 
2f51				; TODO get tok_ptr 
2f51				; TODO consume toks until we get to THEN 
2f51			 
2f51 2a c5 e5			ld hl, (os_tok_ptr) 
2f54					if DEBUG_FORTH_WORDS 
2f54						DMARK "IF3" 
2f54 f5				push af  
2f55 3a 69 2f			ld a, (.dmark)  
2f58 32 6e ee			ld (debug_mark),a  
2f5b 3a 6a 2f			ld a, (.dmark+1)  
2f5e 32 6f ee			ld (debug_mark+1),a  
2f61 3a 6b 2f			ld a, (.dmark+2)  
2f64 32 70 ee			ld (debug_mark+2),a  
2f67 18 03			jr .pastdmark  
2f69 ..			.dmark: db "IF3"  
2f6c f1			.pastdmark: pop af  
2f6d			endm  
# End of macro DMARK
2f6d						CALLMONITOR 
2f6d cd 72 ee			call debug_vector  
2f70				endm  
# End of macro CALLMONITOR
2f70						 
2f70					endif 
2f70 11 b7 2f			ld de, .ifthen 
2f73					if DEBUG_FORTH_WORDS 
2f73						DMARK "IF4" 
2f73 f5				push af  
2f74 3a 88 2f			ld a, (.dmark)  
2f77 32 6e ee			ld (debug_mark),a  
2f7a 3a 89 2f			ld a, (.dmark+1)  
2f7d 32 6f ee			ld (debug_mark+1),a  
2f80 3a 8a 2f			ld a, (.dmark+2)  
2f83 32 70 ee			ld (debug_mark+2),a  
2f86 18 03			jr .pastdmark  
2f88 ..			.dmark: db "IF4"  
2f8b f1			.pastdmark: pop af  
2f8c			endm  
# End of macro DMARK
2f8c						CALLMONITOR 
2f8c cd 72 ee			call debug_vector  
2f8f				endm  
# End of macro CALLMONITOR
2f8f					endif 
2f8f cd 1c 21			call findnexttok  
2f92			 
2f92					if DEBUG_FORTH_WORDS 
2f92						DMARK "IF5" 
2f92 f5				push af  
2f93 3a a7 2f			ld a, (.dmark)  
2f96 32 6e ee			ld (debug_mark),a  
2f99 3a a8 2f			ld a, (.dmark+1)  
2f9c 32 6f ee			ld (debug_mark+1),a  
2f9f 3a a9 2f			ld a, (.dmark+2)  
2fa2 32 70 ee			ld (debug_mark+2),a  
2fa5 18 03			jr .pastdmark  
2fa7 ..			.dmark: db "IF5"  
2faa f1			.pastdmark: pop af  
2fab			endm  
# End of macro DMARK
2fab						CALLMONITOR 
2fab cd 72 ee			call debug_vector  
2fae				endm  
# End of macro CALLMONITOR
2fae					endif 
2fae				; TODO replace below with ; exec using tok_ptr 
2fae 22 c5 e5			ld (os_tok_ptr), hl 
2fb1 c3 92 20			jp exec1 
2fb4				NEXTW 
2fb4 c3 01 20			jp macro_next 
2fb7				endm 
# End of macro NEXTW
2fb7			 
2fb7 .. 00		.ifthen:  db "THEN",0 
2fbc			 
2fbc			.iftrue:		 
2fbc				; Exec next words normally 
2fbc			 
2fbc				; if true then exec following IF as normal 
2fbc					if DEBUG_FORTH_WORDS 
2fbc						DMARK "IFT" 
2fbc f5				push af  
2fbd 3a d1 2f			ld a, (.dmark)  
2fc0 32 6e ee			ld (debug_mark),a  
2fc3 3a d2 2f			ld a, (.dmark+1)  
2fc6 32 6f ee			ld (debug_mark+1),a  
2fc9 3a d3 2f			ld a, (.dmark+2)  
2fcc 32 70 ee			ld (debug_mark+2),a  
2fcf 18 03			jr .pastdmark  
2fd1 ..			.dmark: db "IFT"  
2fd4 f1			.pastdmark: pop af  
2fd5			endm  
# End of macro DMARK
2fd5						CALLMONITOR 
2fd5 cd 72 ee			call debug_vector  
2fd8				endm  
# End of macro CALLMONITOR
2fd8					endif 
2fd8			 
2fd8					NEXTW 
2fd8 c3 01 20			jp macro_next 
2fdb				endm 
# End of macro NEXTW
2fdb			.THEN: 
2fdb				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fdb 1f				db WORD_SYS_CORE+11             
2fdc 03 30			dw .ELSE            
2fde 05				db 4 + 1 
2fdf .. 00			db "THEN",0              
2fe4				endm 
# End of macro CWHEAD
2fe4			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fe4					if DEBUG_FORTH_WORDS_KEY 
2fe4						DMARK "THN" 
2fe4 f5				push af  
2fe5 3a f9 2f			ld a, (.dmark)  
2fe8 32 6e ee			ld (debug_mark),a  
2feb 3a fa 2f			ld a, (.dmark+1)  
2fee 32 6f ee			ld (debug_mark+1),a  
2ff1 3a fb 2f			ld a, (.dmark+2)  
2ff4 32 70 ee			ld (debug_mark+2),a  
2ff7 18 03			jr .pastdmark  
2ff9 ..			.dmark: db "THN"  
2ffc f1			.pastdmark: pop af  
2ffd			endm  
# End of macro DMARK
2ffd						CALLMONITOR 
2ffd cd 72 ee			call debug_vector  
3000				endm  
# End of macro CALLMONITOR
3000					endif 
3000					NEXTW 
3000 c3 01 20			jp macro_next 
3003				endm 
# End of macro NEXTW
3003			.ELSE: 
3003				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3003 20				db WORD_SYS_CORE+12             
3004 2b 30			dw .DO            
3006 03				db 2 + 1 
3007 .. 00			db "ELSE",0              
300c				endm 
# End of macro CWHEAD
300c			; | ELSE ( -- ) Not supported - does nothing | TODO 
300c			 
300c					if DEBUG_FORTH_WORDS_KEY 
300c						DMARK "ELS" 
300c f5				push af  
300d 3a 21 30			ld a, (.dmark)  
3010 32 6e ee			ld (debug_mark),a  
3013 3a 22 30			ld a, (.dmark+1)  
3016 32 6f ee			ld (debug_mark+1),a  
3019 3a 23 30			ld a, (.dmark+2)  
301c 32 70 ee			ld (debug_mark+2),a  
301f 18 03			jr .pastdmark  
3021 ..			.dmark: db "ELS"  
3024 f1			.pastdmark: pop af  
3025			endm  
# End of macro DMARK
3025						CALLMONITOR 
3025 cd 72 ee			call debug_vector  
3028				endm  
# End of macro CALLMONITOR
3028					endif 
3028			 
3028			 
3028					NEXTW 
3028 c3 01 20			jp macro_next 
302b				endm 
# End of macro NEXTW
302b			.DO: 
302b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
302b 21				db WORD_SYS_CORE+13             
302c 52 31			dw .LOOP            
302e 03				db 2 + 1 
302f .. 00			db "DO",0              
3032				endm 
# End of macro CWHEAD
3032			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3032			 
3032					if DEBUG_FORTH_WORDS_KEY 
3032						DMARK "DO." 
3032 f5				push af  
3033 3a 47 30			ld a, (.dmark)  
3036 32 6e ee			ld (debug_mark),a  
3039 3a 48 30			ld a, (.dmark+1)  
303c 32 6f ee			ld (debug_mark+1),a  
303f 3a 49 30			ld a, (.dmark+2)  
3042 32 70 ee			ld (debug_mark+2),a  
3045 18 03			jr .pastdmark  
3047 ..			.dmark: db "DO."  
304a f1			.pastdmark: pop af  
304b			endm  
# End of macro DMARK
304b						CALLMONITOR 
304b cd 72 ee			call debug_vector  
304e				endm  
# End of macro CALLMONITOR
304e					endif 
304e			;  push pc to rsp stack past the DO 
304e			 
304e 2a c5 e5				ld hl, (os_tok_ptr) 
3051 23					inc hl   ; D 
3052 23					inc hl  ; O 
3053 23					inc hl   ; null 
3054					if DEBUG_FORTH_WORDS 
3054						DMARK "DO2" 
3054 f5				push af  
3055 3a 69 30			ld a, (.dmark)  
3058 32 6e ee			ld (debug_mark),a  
305b 3a 6a 30			ld a, (.dmark+1)  
305e 32 6f ee			ld (debug_mark+1),a  
3061 3a 6b 30			ld a, (.dmark+2)  
3064 32 70 ee			ld (debug_mark+2),a  
3067 18 03			jr .pastdmark  
3069 ..			.dmark: db "DO2"  
306c f1			.pastdmark: pop af  
306d			endm  
# End of macro DMARK
306d						CALLMONITOR 
306d cd 72 ee			call debug_vector  
3070				endm  
# End of macro CALLMONITOR
3070					endif 
3070					FORTH_RSP_NEXT 
3070 cd fb 1b			call macro_forth_rsp_next 
3073				endm 
# End of macro FORTH_RSP_NEXT
3073					if DEBUG_FORTH_WORDS 
3073						DMARK "DO3" 
3073 f5				push af  
3074 3a 88 30			ld a, (.dmark)  
3077 32 6e ee			ld (debug_mark),a  
307a 3a 89 30			ld a, (.dmark+1)  
307d 32 6f ee			ld (debug_mark+1),a  
3080 3a 8a 30			ld a, (.dmark+2)  
3083 32 70 ee			ld (debug_mark+2),a  
3086 18 03			jr .pastdmark  
3088 ..			.dmark: db "DO3"  
308b f1			.pastdmark: pop af  
308c			endm  
# End of macro DMARK
308c						CALLMONITOR 
308c cd 72 ee			call debug_vector  
308f				endm  
# End of macro CALLMONITOR
308f					endif 
308f			 
308f					;if DEBUG_FORTH_WORDS 
308f				;		push hl 
308f			;		endif  
308f			 
308f			; get counters from data stack 
308f			 
308f			 
308f					FORTH_DSP_VALUEHL 
308f cd 4b 1e			call macro_dsp_valuehl 
3092				endm 
# End of macro FORTH_DSP_VALUEHL
3092 e5					push hl		 ; hl now has starting counter which needs to be tos 
3093			 
3093					if DEBUG_FORTH_WORDS 
3093						DMARK "DO4" 
3093 f5				push af  
3094 3a a8 30			ld a, (.dmark)  
3097 32 6e ee			ld (debug_mark),a  
309a 3a a9 30			ld a, (.dmark+1)  
309d 32 6f ee			ld (debug_mark+1),a  
30a0 3a aa 30			ld a, (.dmark+2)  
30a3 32 70 ee			ld (debug_mark+2),a  
30a6 18 03			jr .pastdmark  
30a8 ..			.dmark: db "DO4"  
30ab f1			.pastdmark: pop af  
30ac			endm  
# End of macro DMARK
30ac						CALLMONITOR 
30ac cd 72 ee			call debug_vector  
30af				endm  
# End of macro CALLMONITOR
30af					endif 
30af					FORTH_DSP_POP 
30af cd 03 1f			call macro_forth_dsp_pop 
30b2				endm 
# End of macro FORTH_DSP_POP
30b2			 
30b2					if DEBUG_FORTH_WORDS 
30b2						DMARK "DO5" 
30b2 f5				push af  
30b3 3a c7 30			ld a, (.dmark)  
30b6 32 6e ee			ld (debug_mark),a  
30b9 3a c8 30			ld a, (.dmark+1)  
30bc 32 6f ee			ld (debug_mark+1),a  
30bf 3a c9 30			ld a, (.dmark+2)  
30c2 32 70 ee			ld (debug_mark+2),a  
30c5 18 03			jr .pastdmark  
30c7 ..			.dmark: db "DO5"  
30ca f1			.pastdmark: pop af  
30cb			endm  
# End of macro DMARK
30cb						CALLMONITOR 
30cb cd 72 ee			call debug_vector  
30ce				endm  
# End of macro CALLMONITOR
30ce					endif 
30ce			 
30ce					FORTH_DSP_VALUEHL 
30ce cd 4b 1e			call macro_dsp_valuehl 
30d1				endm 
# End of macro FORTH_DSP_VALUEHL
30d1			;		push hl		 ; hl now has starting limit counter 
30d1			 
30d1					if DEBUG_FORTH_WORDS 
30d1						DMARK "DO6" 
30d1 f5				push af  
30d2 3a e6 30			ld a, (.dmark)  
30d5 32 6e ee			ld (debug_mark),a  
30d8 3a e7 30			ld a, (.dmark+1)  
30db 32 6f ee			ld (debug_mark+1),a  
30de 3a e8 30			ld a, (.dmark+2)  
30e1 32 70 ee			ld (debug_mark+2),a  
30e4 18 03			jr .pastdmark  
30e6 ..			.dmark: db "DO6"  
30e9 f1			.pastdmark: pop af  
30ea			endm  
# End of macro DMARK
30ea						CALLMONITOR 
30ea cd 72 ee			call debug_vector  
30ed				endm  
# End of macro CALLMONITOR
30ed					endif 
30ed					FORTH_DSP_POP 
30ed cd 03 1f			call macro_forth_dsp_pop 
30f0				endm 
# End of macro FORTH_DSP_POP
30f0			 
30f0			; put counters on the loop stack 
30f0			 
30f0			;		pop hl			 ; limit counter 
30f0 d1					pop de			; start counter 
30f1			 
30f1					; push limit counter 
30f1			 
30f1					if DEBUG_FORTH_WORDS 
30f1						DMARK "DO7" 
30f1 f5				push af  
30f2 3a 06 31			ld a, (.dmark)  
30f5 32 6e ee			ld (debug_mark),a  
30f8 3a 07 31			ld a, (.dmark+1)  
30fb 32 6f ee			ld (debug_mark+1),a  
30fe 3a 08 31			ld a, (.dmark+2)  
3101 32 70 ee			ld (debug_mark+2),a  
3104 18 03			jr .pastdmark  
3106 ..			.dmark: db "DO7"  
3109 f1			.pastdmark: pop af  
310a			endm  
# End of macro DMARK
310a						CALLMONITOR 
310a cd 72 ee			call debug_vector  
310d				endm  
# End of macro CALLMONITOR
310d					endif 
310d					FORTH_LOOP_NEXT 
310d cd 7c 1e			call macro_forth_loop_next 
3110				endm 
# End of macro FORTH_LOOP_NEXT
3110			 
3110					; push start counter 
3110			 
3110 eb					ex de, hl 
3111					if DEBUG_FORTH_WORDS 
3111						DMARK "DO7" 
3111 f5				push af  
3112 3a 26 31			ld a, (.dmark)  
3115 32 6e ee			ld (debug_mark),a  
3118 3a 27 31			ld a, (.dmark+1)  
311b 32 6f ee			ld (debug_mark+1),a  
311e 3a 28 31			ld a, (.dmark+2)  
3121 32 70 ee			ld (debug_mark+2),a  
3124 18 03			jr .pastdmark  
3126 ..			.dmark: db "DO7"  
3129 f1			.pastdmark: pop af  
312a			endm  
# End of macro DMARK
312a						CALLMONITOR 
312a cd 72 ee			call debug_vector  
312d				endm  
# End of macro CALLMONITOR
312d					endif 
312d					FORTH_LOOP_NEXT 
312d cd 7c 1e			call macro_forth_loop_next 
3130				endm 
# End of macro FORTH_LOOP_NEXT
3130			 
3130			 
3130					; init first round of I counter 
3130			 
3130 22 e9 e5				ld (os_current_i), hl 
3133			 
3133					if DEBUG_FORTH_WORDS 
3133						DMARK "DO8" 
3133 f5				push af  
3134 3a 48 31			ld a, (.dmark)  
3137 32 6e ee			ld (debug_mark),a  
313a 3a 49 31			ld a, (.dmark+1)  
313d 32 6f ee			ld (debug_mark+1),a  
3140 3a 4a 31			ld a, (.dmark+2)  
3143 32 70 ee			ld (debug_mark+2),a  
3146 18 03			jr .pastdmark  
3148 ..			.dmark: db "DO8"  
314b f1			.pastdmark: pop af  
314c			endm  
# End of macro DMARK
314c						CALLMONITOR 
314c cd 72 ee			call debug_vector  
314f				endm  
# End of macro CALLMONITOR
314f					endif 
314f			 
314f					NEXTW 
314f c3 01 20			jp macro_next 
3152				endm 
# End of macro NEXTW
3152			.LOOP: 
3152				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3152 22				db WORD_SYS_CORE+14             
3153 6a 32			dw .I            
3155 05				db 4 + 1 
3156 .. 00			db "LOOP",0              
315b				endm 
# End of macro CWHEAD
315b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
315b			 
315b				; pop tos as current loop count to hl 
315b			 
315b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
315b			 
315b				FORTH_LOOP_TOS 
315b cd af 1e			call macro_forth_loop_tos 
315e				endm 
# End of macro FORTH_LOOP_TOS
315e e5				push hl 
315f			 
315f					if DEBUG_FORTH_WORDS_KEY 
315f						DMARK "LOP" 
315f f5				push af  
3160 3a 74 31			ld a, (.dmark)  
3163 32 6e ee			ld (debug_mark),a  
3166 3a 75 31			ld a, (.dmark+1)  
3169 32 6f ee			ld (debug_mark+1),a  
316c 3a 76 31			ld a, (.dmark+2)  
316f 32 70 ee			ld (debug_mark+2),a  
3172 18 03			jr .pastdmark  
3174 ..			.dmark: db "LOP"  
3177 f1			.pastdmark: pop af  
3178			endm  
# End of macro DMARK
3178						CALLMONITOR 
3178 cd 72 ee			call debug_vector  
317b				endm  
# End of macro CALLMONITOR
317b					endif 
317b				; next item on the stack is the limit. get it 
317b			 
317b			 
317b				FORTH_LOOP_POP 
317b cd b9 1e			call macro_forth_loop_pop 
317e				endm 
# End of macro FORTH_LOOP_POP
317e			 
317e				FORTH_LOOP_TOS 
317e cd af 1e			call macro_forth_loop_tos 
3181				endm 
# End of macro FORTH_LOOP_TOS
3181			 
3181 d1				pop de		 ; de = i, hl = limit 
3182			 
3182					if DEBUG_FORTH_WORDS 
3182						DMARK "LP1" 
3182 f5				push af  
3183 3a 97 31			ld a, (.dmark)  
3186 32 6e ee			ld (debug_mark),a  
3189 3a 98 31			ld a, (.dmark+1)  
318c 32 6f ee			ld (debug_mark+1),a  
318f 3a 99 31			ld a, (.dmark+2)  
3192 32 70 ee			ld (debug_mark+2),a  
3195 18 03			jr .pastdmark  
3197 ..			.dmark: db "LP1"  
319a f1			.pastdmark: pop af  
319b			endm  
# End of macro DMARK
319b						CALLMONITOR 
319b cd 72 ee			call debug_vector  
319e				endm  
# End of macro CALLMONITOR
319e					endif 
319e			 
319e				; go back to previous word 
319e			 
319e d5				push de    ; save I for inc later 
319f			 
319f			 
319f				; get limit 
319f				;  is I at limit? 
319f			 
319f			 
319f					if DEBUG_FORTH_WORDS 
319f						DMARK "LP1" 
319f f5				push af  
31a0 3a b4 31			ld a, (.dmark)  
31a3 32 6e ee			ld (debug_mark),a  
31a6 3a b5 31			ld a, (.dmark+1)  
31a9 32 6f ee			ld (debug_mark+1),a  
31ac 3a b6 31			ld a, (.dmark+2)  
31af 32 70 ee			ld (debug_mark+2),a  
31b2 18 03			jr .pastdmark  
31b4 ..			.dmark: db "LP1"  
31b7 f1			.pastdmark: pop af  
31b8			endm  
# End of macro DMARK
31b8						CALLMONITOR 
31b8 cd 72 ee			call debug_vector  
31bb				endm  
# End of macro CALLMONITOR
31bb					endif 
31bb			 
31bb ed 52			sbc hl, de 
31bd			 
31bd			 
31bd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31bd			 
31bd 20 26				jr nz, .loopnotdone 
31bf			 
31bf e1				pop hl   ; get rid of saved I 
31c0				FORTH_LOOP_POP     ; get rid of limit 
31c0 cd b9 1e			call macro_forth_loop_pop 
31c3				endm 
# End of macro FORTH_LOOP_POP
31c3			 
31c3				FORTH_RSP_POP     ; get rid of DO ptr 
31c3 cd 1c 1c			call macro_forth_rsp_pop 
31c6				endm 
# End of macro FORTH_RSP_POP
31c6			 
31c6			if DEBUG_FORTH_WORDS 
31c6						DMARK "LP>" 
31c6 f5				push af  
31c7 3a db 31			ld a, (.dmark)  
31ca 32 6e ee			ld (debug_mark),a  
31cd 3a dc 31			ld a, (.dmark+1)  
31d0 32 6f ee			ld (debug_mark+1),a  
31d3 3a dd 31			ld a, (.dmark+2)  
31d6 32 70 ee			ld (debug_mark+2),a  
31d9 18 03			jr .pastdmark  
31db ..			.dmark: db "LP>"  
31de f1			.pastdmark: pop af  
31df			endm  
# End of macro DMARK
31df				CALLMONITOR 
31df cd 72 ee			call debug_vector  
31e2				endm  
# End of macro CALLMONITOR
31e2			endif 
31e2			 
31e2					NEXTW 
31e2 c3 01 20			jp macro_next 
31e5				endm 
# End of macro NEXTW
31e5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31e5			 
31e5			.loopnotdone: 
31e5			 
31e5 e1				pop hl    ; get I 
31e6 23				inc hl 
31e7			 
31e7			   	; save new I 
31e7			 
31e7			 
31e7					; set I counter 
31e7			 
31e7 22 e9 e5				ld (os_current_i), hl 
31ea			 
31ea					if DEBUG_FORTH_WORDS 
31ea						DMARK "LPN" 
31ea f5				push af  
31eb 3a ff 31			ld a, (.dmark)  
31ee 32 6e ee			ld (debug_mark),a  
31f1 3a 00 32			ld a, (.dmark+1)  
31f4 32 6f ee			ld (debug_mark+1),a  
31f7 3a 01 32			ld a, (.dmark+2)  
31fa 32 70 ee			ld (debug_mark+2),a  
31fd 18 03			jr .pastdmark  
31ff ..			.dmark: db "LPN"  
3202 f1			.pastdmark: pop af  
3203			endm  
# End of macro DMARK
3203					CALLMONITOR 
3203 cd 72 ee			call debug_vector  
3206				endm  
# End of macro CALLMONITOR
3206					endif 
3206					 
3206				FORTH_LOOP_NEXT 
3206 cd 7c 1e			call macro_forth_loop_next 
3209				endm 
# End of macro FORTH_LOOP_NEXT
3209			 
3209			 
3209					if DEBUG_FORTH_WORDS 
3209 eb						ex de,hl 
320a					endif 
320a			 
320a			;	; get DO ptr 
320a			; 
320a					if DEBUG_FORTH_WORDS 
320a						DMARK "LP7" 
320a f5				push af  
320b 3a 1f 32			ld a, (.dmark)  
320e 32 6e ee			ld (debug_mark),a  
3211 3a 20 32			ld a, (.dmark+1)  
3214 32 6f ee			ld (debug_mark+1),a  
3217 3a 21 32			ld a, (.dmark+2)  
321a 32 70 ee			ld (debug_mark+2),a  
321d 18 03			jr .pastdmark  
321f ..			.dmark: db "LP7"  
3222 f1			.pastdmark: pop af  
3223			endm  
# End of macro DMARK
3223					CALLMONITOR 
3223 cd 72 ee			call debug_vector  
3226				endm  
# End of macro CALLMONITOR
3226					endif 
3226				FORTH_RSP_TOS 
3226 cd 12 1c			call macro_forth_rsp_tos 
3229				endm 
# End of macro FORTH_RSP_TOS
3229			 
3229					if DEBUG_FORTH_WORDS 
3229						DMARK "LP8" 
3229 f5				push af  
322a 3a 3e 32			ld a, (.dmark)  
322d 32 6e ee			ld (debug_mark),a  
3230 3a 3f 32			ld a, (.dmark+1)  
3233 32 6f ee			ld (debug_mark+1),a  
3236 3a 40 32			ld a, (.dmark+2)  
3239 32 70 ee			ld (debug_mark+2),a  
323c 18 03			jr .pastdmark  
323e ..			.dmark: db "LP8"  
3241 f1			.pastdmark: pop af  
3242			endm  
# End of macro DMARK
3242					CALLMONITOR 
3242 cd 72 ee			call debug_vector  
3245				endm  
# End of macro CALLMONITOR
3245					endif 
3245				;push hl 
3245			 
3245				; not going to DO any more 
3245				; get rid of the RSP pointer as DO will add it back in 
3245				;FORTH_RSP_POP 
3245				;pop hl 
3245			 
3245				;ld hl,(cli_ret_sp) 
3245				;ld e, (hl) 
3245				;inc hl 
3245				;ld d, (hl) 
3245				;ex de,hl 
3245 22 c5 e5			ld (os_tok_ptr), hl 
3248					if DEBUG_FORTH_WORDS 
3248						DMARK "LP<" 
3248 f5				push af  
3249 3a 5d 32			ld a, (.dmark)  
324c 32 6e ee			ld (debug_mark),a  
324f 3a 5e 32			ld a, (.dmark+1)  
3252 32 6f ee			ld (debug_mark+1),a  
3255 3a 5f 32			ld a, (.dmark+2)  
3258 32 70 ee			ld (debug_mark+2),a  
325b 18 03			jr .pastdmark  
325d ..			.dmark: db "LP<"  
3260 f1			.pastdmark: pop af  
3261			endm  
# End of macro DMARK
3261					CALLMONITOR 
3261 cd 72 ee			call debug_vector  
3264				endm  
# End of macro CALLMONITOR
3264				endif 
3264 c3 92 20			jp exec1 
3267			 
3267					 
3267			 
3267			 
3267					NEXTW 
3267 c3 01 20			jp macro_next 
326a				endm 
# End of macro NEXTW
326a			.I:  
326a			 
326a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
326a 5e				db WORD_SYS_CORE+74             
326b 95 32			dw .DLOOP            
326d 02				db 1 + 1 
326e .. 00			db "I",0              
3270				endm 
# End of macro CWHEAD
3270			; | I ( -- ) Current loop counter | DONE 
3270					if DEBUG_FORTH_WORDS_KEY 
3270						DMARK "I.." 
3270 f5				push af  
3271 3a 85 32			ld a, (.dmark)  
3274 32 6e ee			ld (debug_mark),a  
3277 3a 86 32			ld a, (.dmark+1)  
327a 32 6f ee			ld (debug_mark+1),a  
327d 3a 87 32			ld a, (.dmark+2)  
3280 32 70 ee			ld (debug_mark+2),a  
3283 18 03			jr .pastdmark  
3285 ..			.dmark: db "I.."  
3288 f1			.pastdmark: pop af  
3289			endm  
# End of macro DMARK
3289						CALLMONITOR 
3289 cd 72 ee			call debug_vector  
328c				endm  
# End of macro CALLMONITOR
328c					endif 
328c			 
328c 2a e9 e5				ld hl,(os_current_i) 
328f cd 54 1c				call forth_push_numhl 
3292			 
3292					NEXTW 
3292 c3 01 20			jp macro_next 
3295				endm 
# End of macro NEXTW
3295			.DLOOP: 
3295				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3295 5f				db WORD_SYS_CORE+75             
3296 76 33			dw .REPEAT            
3298 06				db 5 + 1 
3299 .. 00			db "-LOOP",0              
329f				endm 
# End of macro CWHEAD
329f			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
329f				; pop tos as current loop count to hl 
329f					if DEBUG_FORTH_WORDS_KEY 
329f						DMARK "-LP" 
329f f5				push af  
32a0 3a b4 32			ld a, (.dmark)  
32a3 32 6e ee			ld (debug_mark),a  
32a6 3a b5 32			ld a, (.dmark+1)  
32a9 32 6f ee			ld (debug_mark+1),a  
32ac 3a b6 32			ld a, (.dmark+2)  
32af 32 70 ee			ld (debug_mark+2),a  
32b2 18 03			jr .pastdmark  
32b4 ..			.dmark: db "-LP"  
32b7 f1			.pastdmark: pop af  
32b8			endm  
# End of macro DMARK
32b8						CALLMONITOR 
32b8 cd 72 ee			call debug_vector  
32bb				endm  
# End of macro CALLMONITOR
32bb					endif 
32bb			 
32bb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32bb			 
32bb				FORTH_LOOP_TOS 
32bb cd af 1e			call macro_forth_loop_tos 
32be				endm 
# End of macro FORTH_LOOP_TOS
32be e5				push hl 
32bf			 
32bf					if DEBUG_FORTH_WORDS 
32bf						DMARK "-LP" 
32bf f5				push af  
32c0 3a d4 32			ld a, (.dmark)  
32c3 32 6e ee			ld (debug_mark),a  
32c6 3a d5 32			ld a, (.dmark+1)  
32c9 32 6f ee			ld (debug_mark+1),a  
32cc 3a d6 32			ld a, (.dmark+2)  
32cf 32 70 ee			ld (debug_mark+2),a  
32d2 18 03			jr .pastdmark  
32d4 ..			.dmark: db "-LP"  
32d7 f1			.pastdmark: pop af  
32d8			endm  
# End of macro DMARK
32d8						CALLMONITOR 
32d8 cd 72 ee			call debug_vector  
32db				endm  
# End of macro CALLMONITOR
32db					endif 
32db				; next item on the stack is the limit. get it 
32db			 
32db			 
32db				FORTH_LOOP_POP 
32db cd b9 1e			call macro_forth_loop_pop 
32de				endm 
# End of macro FORTH_LOOP_POP
32de			 
32de				FORTH_LOOP_TOS 
32de cd af 1e			call macro_forth_loop_tos 
32e1				endm 
# End of macro FORTH_LOOP_TOS
32e1			 
32e1 d1				pop de		 ; de = i, hl = limit 
32e2			 
32e2					if DEBUG_FORTH_WORDS 
32e2						DMARK "-L1" 
32e2 f5				push af  
32e3 3a f7 32			ld a, (.dmark)  
32e6 32 6e ee			ld (debug_mark),a  
32e9 3a f8 32			ld a, (.dmark+1)  
32ec 32 6f ee			ld (debug_mark+1),a  
32ef 3a f9 32			ld a, (.dmark+2)  
32f2 32 70 ee			ld (debug_mark+2),a  
32f5 18 03			jr .pastdmark  
32f7 ..			.dmark: db "-L1"  
32fa f1			.pastdmark: pop af  
32fb			endm  
# End of macro DMARK
32fb						CALLMONITOR 
32fb cd 72 ee			call debug_vector  
32fe				endm  
# End of macro CALLMONITOR
32fe					endif 
32fe			 
32fe				; go back to previous word 
32fe			 
32fe d5				push de    ; save I for inc later 
32ff			 
32ff			 
32ff				; get limit 
32ff				;  is I at limit? 
32ff			 
32ff			 
32ff					if DEBUG_FORTH_WORDS 
32ff						DMARK "-L1" 
32ff f5				push af  
3300 3a 14 33			ld a, (.dmark)  
3303 32 6e ee			ld (debug_mark),a  
3306 3a 15 33			ld a, (.dmark+1)  
3309 32 6f ee			ld (debug_mark+1),a  
330c 3a 16 33			ld a, (.dmark+2)  
330f 32 70 ee			ld (debug_mark+2),a  
3312 18 03			jr .pastdmark  
3314 ..			.dmark: db "-L1"  
3317 f1			.pastdmark: pop af  
3318			endm  
# End of macro DMARK
3318						CALLMONITOR 
3318 cd 72 ee			call debug_vector  
331b				endm  
# End of macro CALLMONITOR
331b					endif 
331b			 
331b ed 52			sbc hl, de 
331d			 
331d			 
331d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
331d			 
331d 20 26				jr nz, .mloopnotdone 
331f			 
331f e1				pop hl   ; get rid of saved I 
3320				FORTH_LOOP_POP     ; get rid of limit 
3320 cd b9 1e			call macro_forth_loop_pop 
3323				endm 
# End of macro FORTH_LOOP_POP
3323			 
3323				FORTH_RSP_POP     ; get rid of DO ptr 
3323 cd 1c 1c			call macro_forth_rsp_pop 
3326				endm 
# End of macro FORTH_RSP_POP
3326			 
3326			if DEBUG_FORTH_WORDS 
3326						DMARK "-L>" 
3326 f5				push af  
3327 3a 3b 33			ld a, (.dmark)  
332a 32 6e ee			ld (debug_mark),a  
332d 3a 3c 33			ld a, (.dmark+1)  
3330 32 6f ee			ld (debug_mark+1),a  
3333 3a 3d 33			ld a, (.dmark+2)  
3336 32 70 ee			ld (debug_mark+2),a  
3339 18 03			jr .pastdmark  
333b ..			.dmark: db "-L>"  
333e f1			.pastdmark: pop af  
333f			endm  
# End of macro DMARK
333f				CALLMONITOR 
333f cd 72 ee			call debug_vector  
3342				endm  
# End of macro CALLMONITOR
3342			endif 
3342			 
3342					NEXTW 
3342 c3 01 20			jp macro_next 
3345				endm 
# End of macro NEXTW
3345				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3345			 
3345			.mloopnotdone: 
3345			 
3345 e1				pop hl    ; get I 
3346 2b				dec hl 
3347			 
3347			   	; save new I 
3347			 
3347			 
3347					; set I counter 
3347			 
3347 22 e9 e5				ld (os_current_i), hl 
334a			 
334a					 
334a				FORTH_LOOP_NEXT 
334a cd 7c 1e			call macro_forth_loop_next 
334d				endm 
# End of macro FORTH_LOOP_NEXT
334d			 
334d			 
334d					if DEBUG_FORTH_WORDS 
334d eb						ex de,hl 
334e					endif 
334e			 
334e			;	; get DO ptr 
334e			; 
334e				FORTH_RSP_TOS 
334e cd 12 1c			call macro_forth_rsp_tos 
3351				endm 
# End of macro FORTH_RSP_TOS
3351			 
3351				;push hl 
3351			 
3351				; not going to DO any more 
3351				; get rid of the RSP pointer as DO will add it back in 
3351				;FORTH_RSP_POP 
3351				;pop hl 
3351			 
3351			 
3351 22 c5 e5			ld (os_tok_ptr), hl 
3354					if DEBUG_FORTH_WORDS 
3354						DMARK "-L<" 
3354 f5				push af  
3355 3a 69 33			ld a, (.dmark)  
3358 32 6e ee			ld (debug_mark),a  
335b 3a 6a 33			ld a, (.dmark+1)  
335e 32 6f ee			ld (debug_mark+1),a  
3361 3a 6b 33			ld a, (.dmark+2)  
3364 32 70 ee			ld (debug_mark+2),a  
3367 18 03			jr .pastdmark  
3369 ..			.dmark: db "-L<"  
336c f1			.pastdmark: pop af  
336d			endm  
# End of macro DMARK
336d					CALLMONITOR 
336d cd 72 ee			call debug_vector  
3370				endm  
# End of macro CALLMONITOR
3370				endif 
3370 c3 92 20			jp exec1 
3373			 
3373					 
3373			 
3373			 
3373			 
3373				NEXTW 
3373 c3 01 20			jp macro_next 
3376				endm 
# End of macro NEXTW
3376			 
3376			 
3376			 
3376			 
3376			.REPEAT: 
3376				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3376 71				db WORD_SYS_CORE+93             
3377 c9 33			dw .UNTIL            
3379 06				db 5 + 1 
337a .. 00			db "REPEAT",0              
3381				endm 
# End of macro CWHEAD
3381			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3381			;  push pc to rsp stack past the REPEAT 
3381					if DEBUG_FORTH_WORDS_KEY 
3381						DMARK "REP" 
3381 f5				push af  
3382 3a 96 33			ld a, (.dmark)  
3385 32 6e ee			ld (debug_mark),a  
3388 3a 97 33			ld a, (.dmark+1)  
338b 32 6f ee			ld (debug_mark+1),a  
338e 3a 98 33			ld a, (.dmark+2)  
3391 32 70 ee			ld (debug_mark+2),a  
3394 18 03			jr .pastdmark  
3396 ..			.dmark: db "REP"  
3399 f1			.pastdmark: pop af  
339a			endm  
# End of macro DMARK
339a						CALLMONITOR 
339a cd 72 ee			call debug_vector  
339d				endm  
# End of macro CALLMONITOR
339d					endif 
339d			 
339d 2a c5 e5				ld hl, (os_tok_ptr) 
33a0 23					inc hl   ; R 
33a1 23					inc hl  ; E 
33a2 23					inc hl   ; P 
33a3 23					inc hl   ; E 
33a4 23					inc hl   ; A 
33a5 23					inc hl   ; T 
33a6 23					inc hl   ; zero 
33a7					FORTH_RSP_NEXT 
33a7 cd fb 1b			call macro_forth_rsp_next 
33aa				endm 
# End of macro FORTH_RSP_NEXT
33aa			 
33aa			 
33aa					if DEBUG_FORTH_WORDS 
33aa						DMARK "REP" 
33aa f5				push af  
33ab 3a bf 33			ld a, (.dmark)  
33ae 32 6e ee			ld (debug_mark),a  
33b1 3a c0 33			ld a, (.dmark+1)  
33b4 32 6f ee			ld (debug_mark+1),a  
33b7 3a c1 33			ld a, (.dmark+2)  
33ba 32 70 ee			ld (debug_mark+2),a  
33bd 18 03			jr .pastdmark  
33bf ..			.dmark: db "REP"  
33c2 f1			.pastdmark: pop af  
33c3			endm  
# End of macro DMARK
33c3						;pop bc    ; TODO BUG ?????? what is this for???? 
33c3						CALLMONITOR 
33c3 cd 72 ee			call debug_vector  
33c6				endm  
# End of macro CALLMONITOR
33c6					endif 
33c6			 
33c6					NEXTW 
33c6 c3 01 20			jp macro_next 
33c9				endm 
# End of macro NEXTW
33c9			;	       NEXTW 
33c9			 
33c9			.UNTIL: 
33c9				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33c9 72				db WORD_SYS_CORE+94             
33ca 60 34			dw .ENDFLOW            
33cc 06				db 5 + 1 
33cd .. 00			db "UNTIL",0              
33d3				endm 
# End of macro CWHEAD
33d3			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33d3			 
33d3				; pop tos as check 
33d3			 
33d3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33d3			 
33d3				FORTH_DSP_VALUEHL 
33d3 cd 4b 1e			call macro_dsp_valuehl 
33d6				endm 
# End of macro FORTH_DSP_VALUEHL
33d6			 
33d6					if DEBUG_FORTH_WORDS_KEY 
33d6						DMARK "UNT" 
33d6 f5				push af  
33d7 3a eb 33			ld a, (.dmark)  
33da 32 6e ee			ld (debug_mark),a  
33dd 3a ec 33			ld a, (.dmark+1)  
33e0 32 6f ee			ld (debug_mark+1),a  
33e3 3a ed 33			ld a, (.dmark+2)  
33e6 32 70 ee			ld (debug_mark+2),a  
33e9 18 03			jr .pastdmark  
33eb ..			.dmark: db "UNT"  
33ee f1			.pastdmark: pop af  
33ef			endm  
# End of macro DMARK
33ef						CALLMONITOR 
33ef cd 72 ee			call debug_vector  
33f2				endm  
# End of macro CALLMONITOR
33f2					endif 
33f2			 
33f2			;	push hl 
33f2				FORTH_DSP_POP 
33f2 cd 03 1f			call macro_forth_dsp_pop 
33f5				endm 
# End of macro FORTH_DSP_POP
33f5			 
33f5			;	pop hl 
33f5			 
33f5				; test if true 
33f5			 
33f5 cd 10 0e			call ishlzero 
33f8			;	ld a,l 
33f8			;	add h 
33f8			; 
33f8			;	cp 0 
33f8			 
33f8 20 3e			jr nz, .untilnotdone 
33fa			 
33fa					if DEBUG_FORTH_WORDS 
33fa						DMARK "UNf" 
33fa f5				push af  
33fb 3a 0f 34			ld a, (.dmark)  
33fe 32 6e ee			ld (debug_mark),a  
3401 3a 10 34			ld a, (.dmark+1)  
3404 32 6f ee			ld (debug_mark+1),a  
3407 3a 11 34			ld a, (.dmark+2)  
340a 32 70 ee			ld (debug_mark+2),a  
340d 18 03			jr .pastdmark  
340f ..			.dmark: db "UNf"  
3412 f1			.pastdmark: pop af  
3413			endm  
# End of macro DMARK
3413						CALLMONITOR 
3413 cd 72 ee			call debug_vector  
3416				endm  
# End of macro CALLMONITOR
3416					endif 
3416			 
3416			 
3416			 
3416				FORTH_RSP_POP     ; get rid of DO ptr 
3416 cd 1c 1c			call macro_forth_rsp_pop 
3419				endm 
# End of macro FORTH_RSP_POP
3419			 
3419			if DEBUG_FORTH_WORDS 
3419						DMARK "UN>" 
3419 f5				push af  
341a 3a 2e 34			ld a, (.dmark)  
341d 32 6e ee			ld (debug_mark),a  
3420 3a 2f 34			ld a, (.dmark+1)  
3423 32 6f ee			ld (debug_mark+1),a  
3426 3a 30 34			ld a, (.dmark+2)  
3429 32 70 ee			ld (debug_mark+2),a  
342c 18 03			jr .pastdmark  
342e ..			.dmark: db "UN>"  
3431 f1			.pastdmark: pop af  
3432			endm  
# End of macro DMARK
3432				CALLMONITOR 
3432 cd 72 ee			call debug_vector  
3435				endm  
# End of macro CALLMONITOR
3435			endif 
3435			 
3435					NEXTW 
3435 c3 01 20			jp macro_next 
3438				endm 
# End of macro NEXTW
3438				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3438			 
3438			.untilnotdone: 
3438			 
3438			 
3438			;	; get DO ptr 
3438			; 
3438				FORTH_RSP_TOS 
3438 cd 12 1c			call macro_forth_rsp_tos 
343b				endm 
# End of macro FORTH_RSP_TOS
343b			 
343b				;push hl 
343b			 
343b				; not going to DO any more 
343b				; get rid of the RSP pointer as DO will add it back in 
343b				;FORTH_RSP_POP 
343b				;pop hl 
343b			 
343b			 
343b 22 c5 e5			ld (os_tok_ptr), hl 
343e					if DEBUG_FORTH_WORDS 
343e						DMARK "UN<" 
343e f5				push af  
343f 3a 53 34			ld a, (.dmark)  
3442 32 6e ee			ld (debug_mark),a  
3445 3a 54 34			ld a, (.dmark+1)  
3448 32 6f ee			ld (debug_mark+1),a  
344b 3a 55 34			ld a, (.dmark+2)  
344e 32 70 ee			ld (debug_mark+2),a  
3451 18 03			jr .pastdmark  
3453 ..			.dmark: db "UN<"  
3456 f1			.pastdmark: pop af  
3457			endm  
# End of macro DMARK
3457					CALLMONITOR 
3457 cd 72 ee			call debug_vector  
345a				endm  
# End of macro CALLMONITOR
345a				endif 
345a c3 92 20			jp exec1 
345d			 
345d					 
345d			 
345d			 
345d					NEXTW 
345d c3 01 20			jp macro_next 
3460				endm 
# End of macro NEXTW
3460			 
3460			 
3460			.ENDFLOW: 
3460			 
3460			; eof 
3460			 
# End of file forth_words_flow.asm
3460			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3460			include "forth_words_logic.asm" 
3460			 
3460			; | ## Logic Words 
3460			 
3460			.NOT: 
3460				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3460 2d				db WORD_SYS_CORE+25             
3461 a8 34			dw .IS            
3463 04				db 3 + 1 
3464 .. 00			db "NOT",0              
3468				endm 
# End of macro CWHEAD
3468			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3468					if DEBUG_FORTH_WORDS_KEY 
3468						DMARK "NOT" 
3468 f5				push af  
3469 3a 7d 34			ld a, (.dmark)  
346c 32 6e ee			ld (debug_mark),a  
346f 3a 7e 34			ld a, (.dmark+1)  
3472 32 6f ee			ld (debug_mark+1),a  
3475 3a 7f 34			ld a, (.dmark+2)  
3478 32 70 ee			ld (debug_mark+2),a  
347b 18 03			jr .pastdmark  
347d ..			.dmark: db "NOT"  
3480 f1			.pastdmark: pop af  
3481			endm  
# End of macro DMARK
3481						CALLMONITOR 
3481 cd 72 ee			call debug_vector  
3484				endm  
# End of macro CALLMONITOR
3484					endif 
3484					FORTH_DSP 
3484 cd 11 1e			call macro_forth_dsp 
3487				endm 
# End of macro FORTH_DSP
3487 7e					ld a,(hl)	; get type of value on TOS 
3488 fe 02				cp DS_TYPE_INUM  
348a 28 03				jr z, .noti 
348c					NEXTW 
348c c3 01 20			jp macro_next 
348f				endm 
# End of macro NEXTW
348f			.noti:          FORTH_DSP_VALUEHL 
348f cd 4b 1e			call macro_dsp_valuehl 
3492				endm 
# End of macro FORTH_DSP_VALUEHL
3492			;		push hl 
3492					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3492 cd 03 1f			call macro_forth_dsp_pop 
3495				endm 
# End of macro FORTH_DSP_POP
3495			;		pop hl 
3495 3e 00				ld a,0 
3497 bd					cp l 
3498 28 04				jr z, .not2t 
349a 2e 00				ld l, 0 
349c 18 02				jr .notip 
349e			 
349e 2e ff		.not2t:		ld l, 255 
34a0			 
34a0 26 00		.notip:		ld h, 0	 
34a2			 
34a2 cd 54 1c				call forth_push_numhl 
34a5					NEXTW 
34a5 c3 01 20			jp macro_next 
34a8				endm 
# End of macro NEXTW
34a8			 
34a8			.IS: 
34a8				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34a8 2d				db WORD_SYS_CORE+25             
34a9 ce 34			dw .LZERO            
34ab 03				db 2 + 1 
34ac .. 00			db "IS",0              
34af				endm 
# End of macro CWHEAD
34af			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34af					if DEBUG_FORTH_WORDS_KEY 
34af						DMARK "IS." 
34af f5				push af  
34b0 3a c4 34			ld a, (.dmark)  
34b3 32 6e ee			ld (debug_mark),a  
34b6 3a c5 34			ld a, (.dmark+1)  
34b9 32 6f ee			ld (debug_mark+1),a  
34bc 3a c6 34			ld a, (.dmark+2)  
34bf 32 70 ee			ld (debug_mark+2),a  
34c2 18 03			jr .pastdmark  
34c4 ..			.dmark: db "IS."  
34c7 f1			.pastdmark: pop af  
34c8			endm  
# End of macro DMARK
34c8						CALLMONITOR 
34c8 cd 72 ee			call debug_vector  
34cb				endm  
# End of macro CALLMONITOR
34cb					endif 
34cb					NEXTW 
34cb c3 01 20			jp macro_next 
34ce				endm 
# End of macro NEXTW
34ce			.LZERO: 
34ce				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34ce 2d				db WORD_SYS_CORE+25             
34cf d8 34			dw .TZERO            
34d1 03				db 2 + 1 
34d2 .. 00			db "0<",0              
34d5				endm 
# End of macro CWHEAD
34d5			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34d5					NEXTW 
34d5 c3 01 20			jp macro_next 
34d8				endm 
# End of macro NEXTW
34d8			.TZERO: 
34d8				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34d8 2e				db WORD_SYS_CORE+26             
34d9 1f 35			dw .LESS            
34db 03				db 2 + 1 
34dc .. 00			db "0=",0              
34df				endm 
# End of macro CWHEAD
34df			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34df				; TODO add floating point number detection 
34df					;v5 FORTH_DSP_VALUE 
34df					if DEBUG_FORTH_WORDS_KEY 
34df						DMARK "0=." 
34df f5				push af  
34e0 3a f4 34			ld a, (.dmark)  
34e3 32 6e ee			ld (debug_mark),a  
34e6 3a f5 34			ld a, (.dmark+1)  
34e9 32 6f ee			ld (debug_mark+1),a  
34ec 3a f6 34			ld a, (.dmark+2)  
34ef 32 70 ee			ld (debug_mark+2),a  
34f2 18 03			jr .pastdmark  
34f4 ..			.dmark: db "0=."  
34f7 f1			.pastdmark: pop af  
34f8			endm  
# End of macro DMARK
34f8						CALLMONITOR 
34f8 cd 72 ee			call debug_vector  
34fb				endm  
# End of macro CALLMONITOR
34fb					endif 
34fb					FORTH_DSP 
34fb cd 11 1e			call macro_forth_dsp 
34fe				endm 
# End of macro FORTH_DSP
34fe 7e					ld a,(hl)	; get type of value on TOS 
34ff fe 02				cp DS_TYPE_INUM  
3501 28 00				jr z, .tz_inum 
3503			 
3503				if FORTH_ENABLE_FLOATMATH 
3503					jr .tz_done 
3503			 
3503				endif 
3503					 
3503			 
3503			.tz_inum: 
3503					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3503 cd 4b 1e			call macro_dsp_valuehl 
3506				endm 
# End of macro FORTH_DSP_VALUEHL
3506			 
3506			;		push hl 
3506			 
3506					; destroy value TOS 
3506			 
3506					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3506 cd 03 1f			call macro_forth_dsp_pop 
3509				endm 
# End of macro FORTH_DSP_POP
3509			 
3509			;		pop hl 
3509			 
3509 3e 00				ld a,0 
350b			 
350b bd					cp l 
350c 20 08				jr nz, .tz_notzero 
350e			 
350e bc					cp h 
350f			 
350f 20 05				jr nz, .tz_notzero 
3511			 
3511			 
3511 21 01 00				ld hl, FORTH_TRUE 
3514 18 03				jr .tz_done 
3516			 
3516 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3519			 
3519					; push value back onto stack for another op etc 
3519			 
3519			.tz_done: 
3519 cd 54 1c				call forth_push_numhl 
351c			 
351c					NEXTW 
351c c3 01 20			jp macro_next 
351f				endm 
# End of macro NEXTW
351f			.LESS: 
351f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
351f 2f				db WORD_SYS_CORE+27             
3520 88 35			dw .GT            
3522 02				db 1 + 1 
3523 .. 00			db "<",0              
3525				endm 
# End of macro CWHEAD
3525			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3525				; TODO add floating point number detection 
3525					if DEBUG_FORTH_WORDS_KEY 
3525						DMARK "LES" 
3525 f5				push af  
3526 3a 3a 35			ld a, (.dmark)  
3529 32 6e ee			ld (debug_mark),a  
352c 3a 3b 35			ld a, (.dmark+1)  
352f 32 6f ee			ld (debug_mark+1),a  
3532 3a 3c 35			ld a, (.dmark+2)  
3535 32 70 ee			ld (debug_mark+2),a  
3538 18 03			jr .pastdmark  
353a ..			.dmark: db "LES"  
353d f1			.pastdmark: pop af  
353e			endm  
# End of macro DMARK
353e						CALLMONITOR 
353e cd 72 ee			call debug_vector  
3541				endm  
# End of macro CALLMONITOR
3541					endif 
3541					FORTH_DSP 
3541 cd 11 1e			call macro_forth_dsp 
3544				endm 
# End of macro FORTH_DSP
3544					;v5 FORTH_DSP_VALUE 
3544 7e					ld a,(hl)	; get type of value on TOS 
3545 fe 02				cp DS_TYPE_INUM  
3547 28 00				jr z, .less_inum 
3549			 
3549				if FORTH_ENABLE_FLOATMATH 
3549					jr .less_done 
3549			 
3549				endif 
3549					 
3549			 
3549			.less_inum: 
3549					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3549 cd 4b 1e			call macro_dsp_valuehl 
354c				endm 
# End of macro FORTH_DSP_VALUEHL
354c			 
354c e5					push hl  ; u2 
354d			 
354d					; destroy value TOS 
354d			 
354d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
354d cd 03 1f			call macro_forth_dsp_pop 
3550				endm 
# End of macro FORTH_DSP_POP
3550			 
3550			 
3550					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3550 cd 4b 1e			call macro_dsp_valuehl 
3553				endm 
# End of macro FORTH_DSP_VALUEHL
3553			 
3553 e5					push hl    ; u1 
3554			 
3554					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3554 cd 03 1f			call macro_forth_dsp_pop 
3557				endm 
# End of macro FORTH_DSP_POP
3557			 
3557			 
3557 b7			 or a      ;clear carry flag 
3558 01 00 00		 ld bc, FORTH_FALSE 
355b e1			  pop hl    ; u1 
355c d1			  pop de    ; u2 
355d ed 52		  sbc hl,de 
355f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3561			 
3561 01 01 00		 ld bc, FORTH_TRUE 
3564			.lscont:  
3564 c5					push bc 
3565 e1					pop hl 
3566			 
3566					if DEBUG_FORTH_WORDS 
3566						DMARK "LT1" 
3566 f5				push af  
3567 3a 7b 35			ld a, (.dmark)  
356a 32 6e ee			ld (debug_mark),a  
356d 3a 7c 35			ld a, (.dmark+1)  
3570 32 6f ee			ld (debug_mark+1),a  
3573 3a 7d 35			ld a, (.dmark+2)  
3576 32 70 ee			ld (debug_mark+2),a  
3579 18 03			jr .pastdmark  
357b ..			.dmark: db "LT1"  
357e f1			.pastdmark: pop af  
357f			endm  
# End of macro DMARK
357f						CALLMONITOR 
357f cd 72 ee			call debug_vector  
3582				endm  
# End of macro CALLMONITOR
3582					endif 
3582 cd 54 1c				call forth_push_numhl 
3585			 
3585					NEXTW 
3585 c3 01 20			jp macro_next 
3588				endm 
# End of macro NEXTW
3588			.GT: 
3588				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3588 30				db WORD_SYS_CORE+28             
3589 f1 35			dw .EQUAL            
358b 02				db 1 + 1 
358c .. 00			db ">",0              
358e				endm 
# End of macro CWHEAD
358e			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
358e				; TODO add floating point number detection 
358e					if DEBUG_FORTH_WORDS_KEY 
358e						DMARK "GRT" 
358e f5				push af  
358f 3a a3 35			ld a, (.dmark)  
3592 32 6e ee			ld (debug_mark),a  
3595 3a a4 35			ld a, (.dmark+1)  
3598 32 6f ee			ld (debug_mark+1),a  
359b 3a a5 35			ld a, (.dmark+2)  
359e 32 70 ee			ld (debug_mark+2),a  
35a1 18 03			jr .pastdmark  
35a3 ..			.dmark: db "GRT"  
35a6 f1			.pastdmark: pop af  
35a7			endm  
# End of macro DMARK
35a7						CALLMONITOR 
35a7 cd 72 ee			call debug_vector  
35aa				endm  
# End of macro CALLMONITOR
35aa					endif 
35aa					FORTH_DSP 
35aa cd 11 1e			call macro_forth_dsp 
35ad				endm 
# End of macro FORTH_DSP
35ad					;FORTH_DSP_VALUE 
35ad 7e					ld a,(hl)	; get type of value on TOS 
35ae fe 02				cp DS_TYPE_INUM  
35b0 28 00				jr z, .gt_inum 
35b2			 
35b2				if FORTH_ENABLE_FLOATMATH 
35b2					jr .gt_done 
35b2			 
35b2				endif 
35b2					 
35b2			 
35b2			.gt_inum: 
35b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b2 cd 4b 1e			call macro_dsp_valuehl 
35b5				endm 
# End of macro FORTH_DSP_VALUEHL
35b5			 
35b5 e5					push hl  ; u2 
35b6			 
35b6					; destroy value TOS 
35b6			 
35b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b6 cd 03 1f			call macro_forth_dsp_pop 
35b9				endm 
# End of macro FORTH_DSP_POP
35b9			 
35b9			 
35b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b9 cd 4b 1e			call macro_dsp_valuehl 
35bc				endm 
# End of macro FORTH_DSP_VALUEHL
35bc			 
35bc e5					push hl    ; u1 
35bd			 
35bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35bd cd 03 1f			call macro_forth_dsp_pop 
35c0				endm 
# End of macro FORTH_DSP_POP
35c0			 
35c0			 
35c0 b7			 or a      ;clear carry flag 
35c1 01 00 00		 ld bc, FORTH_FALSE 
35c4 e1			  pop hl    ; u1 
35c5 d1			  pop de    ; u2 
35c6 ed 52		  sbc hl,de 
35c8 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35ca			 
35ca 01 01 00		 ld bc, FORTH_TRUE 
35cd			.gtcont:  
35cd c5					push bc 
35ce e1					pop hl 
35cf			 
35cf					if DEBUG_FORTH_WORDS 
35cf						DMARK "GT1" 
35cf f5				push af  
35d0 3a e4 35			ld a, (.dmark)  
35d3 32 6e ee			ld (debug_mark),a  
35d6 3a e5 35			ld a, (.dmark+1)  
35d9 32 6f ee			ld (debug_mark+1),a  
35dc 3a e6 35			ld a, (.dmark+2)  
35df 32 70 ee			ld (debug_mark+2),a  
35e2 18 03			jr .pastdmark  
35e4 ..			.dmark: db "GT1"  
35e7 f1			.pastdmark: pop af  
35e8			endm  
# End of macro DMARK
35e8						CALLMONITOR 
35e8 cd 72 ee			call debug_vector  
35eb				endm  
# End of macro CALLMONITOR
35eb					endif 
35eb cd 54 1c				call forth_push_numhl 
35ee			 
35ee					NEXTW 
35ee c3 01 20			jp macro_next 
35f1				endm 
# End of macro NEXTW
35f1			.EQUAL: 
35f1				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35f1 31				db WORD_SYS_CORE+29             
35f2 5c 36			dw .ENDLOGIC            
35f4 02				db 1 + 1 
35f5 .. 00			db "=",0              
35f7				endm 
# End of macro CWHEAD
35f7			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35f7				; TODO add floating point number detection 
35f7					if DEBUG_FORTH_WORDS_KEY 
35f7						DMARK "EQ." 
35f7 f5				push af  
35f8 3a 0c 36			ld a, (.dmark)  
35fb 32 6e ee			ld (debug_mark),a  
35fe 3a 0d 36			ld a, (.dmark+1)  
3601 32 6f ee			ld (debug_mark+1),a  
3604 3a 0e 36			ld a, (.dmark+2)  
3607 32 70 ee			ld (debug_mark+2),a  
360a 18 03			jr .pastdmark  
360c ..			.dmark: db "EQ."  
360f f1			.pastdmark: pop af  
3610			endm  
# End of macro DMARK
3610						CALLMONITOR 
3610 cd 72 ee			call debug_vector  
3613				endm  
# End of macro CALLMONITOR
3613					endif 
3613					FORTH_DSP 
3613 cd 11 1e			call macro_forth_dsp 
3616				endm 
# End of macro FORTH_DSP
3616					;v5 FORTH_DSP_VALUE 
3616 7e					ld a,(hl)	; get type of value on TOS 
3617 fe 02				cp DS_TYPE_INUM  
3619 28 00				jr z, .eq_inum 
361b			 
361b				if FORTH_ENABLE_FLOATMATH 
361b					jr .eq_done 
361b			 
361b				endif 
361b					 
361b			 
361b			.eq_inum: 
361b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361b cd 4b 1e			call macro_dsp_valuehl 
361e				endm 
# End of macro FORTH_DSP_VALUEHL
361e			 
361e e5					push hl 
361f			 
361f					; destroy value TOS 
361f			 
361f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361f cd 03 1f			call macro_forth_dsp_pop 
3622				endm 
# End of macro FORTH_DSP_POP
3622			 
3622			 
3622					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3622 cd 4b 1e			call macro_dsp_valuehl 
3625				endm 
# End of macro FORTH_DSP_VALUEHL
3625			 
3625					; one value on hl get other one back 
3625			 
3625 e5					push hl 
3626			 
3626					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3626 cd 03 1f			call macro_forth_dsp_pop 
3629				endm 
# End of macro FORTH_DSP_POP
3629			 
3629 0e 00				ld c, FORTH_FALSE 
362b			 
362b e1					pop hl 
362c d1					pop de 
362d			 
362d 7b					ld a, e 
362e bd					cp l 
362f			 
362f 20 06				jr nz, .eq_done 
3631			 
3631 7a					ld a, d 
3632 bc					cp h 
3633			 
3633 20 02				jr nz, .eq_done 
3635			 
3635 0e 01				ld c, FORTH_TRUE 
3637					 
3637			 
3637			 
3637			.eq_done: 
3637			 
3637					; TODO push value back onto stack for another op etc 
3637			 
3637 26 00				ld h, 0 
3639 69					ld l, c 
363a					if DEBUG_FORTH_WORDS 
363a						DMARK "EQ1" 
363a f5				push af  
363b 3a 4f 36			ld a, (.dmark)  
363e 32 6e ee			ld (debug_mark),a  
3641 3a 50 36			ld a, (.dmark+1)  
3644 32 6f ee			ld (debug_mark+1),a  
3647 3a 51 36			ld a, (.dmark+2)  
364a 32 70 ee			ld (debug_mark+2),a  
364d 18 03			jr .pastdmark  
364f ..			.dmark: db "EQ1"  
3652 f1			.pastdmark: pop af  
3653			endm  
# End of macro DMARK
3653						CALLMONITOR 
3653 cd 72 ee			call debug_vector  
3656				endm  
# End of macro CALLMONITOR
3656					endif 
3656 cd 54 1c				call forth_push_numhl 
3659			 
3659					NEXTW 
3659 c3 01 20			jp macro_next 
365c				endm 
# End of macro NEXTW
365c			 
365c			 
365c			.ENDLOGIC: 
365c			; eof 
365c			 
365c			 
# End of file forth_words_logic.asm
365c			include "forth_words_maths.asm" 
365c			 
365c			; | ## Maths Words 
365c			 
365c			.PLUS:	 
365c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
365c 15				db WORD_SYS_CORE+1             
365d ba 36			dw .NEG            
365f 02				db 1 + 1 
3660 .. 00			db "+",0              
3662				endm 
# End of macro CWHEAD
3662			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3662					if DEBUG_FORTH_WORDS_KEY 
3662						DMARK "PLU" 
3662 f5				push af  
3663 3a 77 36			ld a, (.dmark)  
3666 32 6e ee			ld (debug_mark),a  
3669 3a 78 36			ld a, (.dmark+1)  
366c 32 6f ee			ld (debug_mark+1),a  
366f 3a 79 36			ld a, (.dmark+2)  
3672 32 70 ee			ld (debug_mark+2),a  
3675 18 03			jr .pastdmark  
3677 ..			.dmark: db "PLU"  
367a f1			.pastdmark: pop af  
367b			endm  
# End of macro DMARK
367b						CALLMONITOR 
367b cd 72 ee			call debug_vector  
367e				endm  
# End of macro CALLMONITOR
367e					endif 
367e					; add top two values and push back result 
367e			 
367e					;for v5 FORTH_DSP_VALUE 
367e					FORTH_DSP 
367e cd 11 1e			call macro_forth_dsp 
3681				endm 
# End of macro FORTH_DSP
3681 7e					ld a,(hl)	; get type of value on TOS 
3682 fe 02				cp DS_TYPE_INUM  
3684 28 03				jr z, .dot_inum 
3686			 
3686					NEXTW 
3686 c3 01 20			jp macro_next 
3689				endm 
# End of macro NEXTW
3689			 
3689			; float maths 
3689			 
3689				if FORTH_ENABLE_FLOATMATH 
3689						inc hl      ; now at start of numeric as string 
3689			 
3689					if DEBUG_FORTH_MATHS 
3689						DMARK "ADD" 
3689				CALLMONITOR 
3689					endif 
3689			 
3689					;ld ix, hl 
3689					call CON 
3689			 
3689			 
3689					push hl 
3689					 
3689					 
3689			 
3689						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3689			 
3689					; get next number 
3689			 
3689						FORTH_DSP_VALUE 
3689			 
3689						inc hl      ; now at start of numeric as string 
3689			 
3689					;ld ix, hl 
3689					call CON 
3689			 
3689					push hl 
3689			 
3689			 
3689						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3689			 
3689						; TODO do add 
3689			 
3689						call IADD 
3689			 
3689						; TODO get result back as ascii 
3689			 
3689						; TODO push result  
3689			 
3689			 
3689			 
3689						jr .dot_done 
3689				endif 
3689			 
3689			.dot_inum: 
3689			 
3689			 
3689					if DEBUG_FORTH_DOT 
3689						DMARK "+IT" 
3689 f5				push af  
368a 3a 9e 36			ld a, (.dmark)  
368d 32 6e ee			ld (debug_mark),a  
3690 3a 9f 36			ld a, (.dmark+1)  
3693 32 6f ee			ld (debug_mark+1),a  
3696 3a a0 36			ld a, (.dmark+2)  
3699 32 70 ee			ld (debug_mark+2),a  
369c 18 03			jr .pastdmark  
369e ..			.dmark: db "+IT"  
36a1 f1			.pastdmark: pop af  
36a2			endm  
# End of macro DMARK
36a2				CALLMONITOR 
36a2 cd 72 ee			call debug_vector  
36a5				endm  
# End of macro CALLMONITOR
36a5					endif 
36a5			 
36a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a5 cd 4b 1e			call macro_dsp_valuehl 
36a8				endm 
# End of macro FORTH_DSP_VALUEHL
36a8			 
36a8				; TODO add floating point number detection 
36a8			 
36a8 e5					push hl 
36a9			 
36a9					; destroy value TOS 
36a9			 
36a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a9 cd 03 1f			call macro_forth_dsp_pop 
36ac				endm 
# End of macro FORTH_DSP_POP
36ac			 
36ac			 
36ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ac cd 4b 1e			call macro_dsp_valuehl 
36af				endm 
# End of macro FORTH_DSP_VALUEHL
36af			 
36af					; one value on hl get other one back 
36af			 
36af d1					pop de 
36b0			 
36b0					; do the add 
36b0			 
36b0 19					add hl,de 
36b1			 
36b1					; save it 
36b1			 
36b1			;		push hl	 
36b1			 
36b1					; 
36b1			 
36b1					; destroy value TOS 
36b1			 
36b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b1 cd 03 1f			call macro_forth_dsp_pop 
36b4				endm 
# End of macro FORTH_DSP_POP
36b4			 
36b4					; TODO push value back onto stack for another op etc 
36b4			 
36b4			;		pop hl 
36b4			 
36b4			.dot_done: 
36b4 cd 54 1c				call forth_push_numhl 
36b7			 
36b7					NEXTW 
36b7 c3 01 20			jp macro_next 
36ba				endm 
# End of macro NEXTW
36ba			.NEG: 
36ba			 
36ba				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36ba 17				db WORD_SYS_CORE+3             
36bb fd 36			dw .DIV            
36bd 02				db 1 + 1 
36be .. 00			db "-",0              
36c0				endm 
# End of macro CWHEAD
36c0			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36c0					if DEBUG_FORTH_WORDS_KEY 
36c0						DMARK "SUB" 
36c0 f5				push af  
36c1 3a d5 36			ld a, (.dmark)  
36c4 32 6e ee			ld (debug_mark),a  
36c7 3a d6 36			ld a, (.dmark+1)  
36ca 32 6f ee			ld (debug_mark+1),a  
36cd 3a d7 36			ld a, (.dmark+2)  
36d0 32 70 ee			ld (debug_mark+2),a  
36d3 18 03			jr .pastdmark  
36d5 ..			.dmark: db "SUB"  
36d8 f1			.pastdmark: pop af  
36d9			endm  
# End of macro DMARK
36d9						CALLMONITOR 
36d9 cd 72 ee			call debug_vector  
36dc				endm  
# End of macro CALLMONITOR
36dc					endif 
36dc			 
36dc			 
36dc				; TODO add floating point number detection 
36dc					; v5 FORTH_DSP_VALUE 
36dc					FORTH_DSP 
36dc cd 11 1e			call macro_forth_dsp 
36df				endm 
# End of macro FORTH_DSP
36df 7e					ld a,(hl)	; get type of value on TOS 
36e0 fe 02				cp DS_TYPE_INUM  
36e2 28 03				jr z, .neg_inum 
36e4			 
36e4					NEXTW 
36e4 c3 01 20			jp macro_next 
36e7				endm 
# End of macro NEXTW
36e7			 
36e7			; float maths 
36e7			 
36e7				if FORTH_ENABLE_FLOATMATH 
36e7					jr .neg_done 
36e7			 
36e7				endif 
36e7					 
36e7			 
36e7			.neg_inum: 
36e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e7 cd 4b 1e			call macro_dsp_valuehl 
36ea				endm 
# End of macro FORTH_DSP_VALUEHL
36ea			 
36ea e5					push hl 
36eb			 
36eb					; destroy value TOS 
36eb			 
36eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36eb cd 03 1f			call macro_forth_dsp_pop 
36ee				endm 
# End of macro FORTH_DSP_POP
36ee			 
36ee			 
36ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ee cd 4b 1e			call macro_dsp_valuehl 
36f1				endm 
# End of macro FORTH_DSP_VALUEHL
36f1			 
36f1					; one value on hl get other one back 
36f1			 
36f1 d1					pop de 
36f2			 
36f2					; do the sub 
36f2			;		ex de, hl 
36f2			 
36f2 ed 52				sbc hl,de 
36f4			 
36f4					; save it 
36f4			 
36f4			;		push hl	 
36f4			 
36f4					; 
36f4			 
36f4					; destroy value TOS 
36f4			 
36f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f4 cd 03 1f			call macro_forth_dsp_pop 
36f7				endm 
# End of macro FORTH_DSP_POP
36f7			 
36f7					; TODO push value back onto stack for another op etc 
36f7			 
36f7			;		pop hl 
36f7			 
36f7 cd 54 1c				call forth_push_numhl 
36fa			.neg_done: 
36fa			 
36fa					NEXTW 
36fa c3 01 20			jp macro_next 
36fd				endm 
# End of macro NEXTW
36fd			.DIV: 
36fd				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36fd 18				db WORD_SYS_CORE+4             
36fe 4a 37			dw .MUL            
3700 02				db 1 + 1 
3701 .. 00			db "/",0              
3703				endm 
# End of macro CWHEAD
3703			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3703					if DEBUG_FORTH_WORDS_KEY 
3703						DMARK "DIV" 
3703 f5				push af  
3704 3a 18 37			ld a, (.dmark)  
3707 32 6e ee			ld (debug_mark),a  
370a 3a 19 37			ld a, (.dmark+1)  
370d 32 6f ee			ld (debug_mark+1),a  
3710 3a 1a 37			ld a, (.dmark+2)  
3713 32 70 ee			ld (debug_mark+2),a  
3716 18 03			jr .pastdmark  
3718 ..			.dmark: db "DIV"  
371b f1			.pastdmark: pop af  
371c			endm  
# End of macro DMARK
371c						CALLMONITOR 
371c cd 72 ee			call debug_vector  
371f				endm  
# End of macro CALLMONITOR
371f					endif 
371f				; TODO add floating point number detection 
371f					; v5 FORTH_DSP_VALUE 
371f					FORTH_DSP 
371f cd 11 1e			call macro_forth_dsp 
3722				endm 
# End of macro FORTH_DSP
3722 7e					ld a,(hl)	; get type of value on TOS 
3723 fe 02				cp DS_TYPE_INUM  
3725 28 03				jr z, .div_inum 
3727			 
3727				if FORTH_ENABLE_FLOATMATH 
3727					jr .div_done 
3727			 
3727				endif 
3727					NEXTW 
3727 c3 01 20			jp macro_next 
372a				endm 
# End of macro NEXTW
372a			.div_inum: 
372a			 
372a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372a cd 4b 1e			call macro_dsp_valuehl 
372d				endm 
# End of macro FORTH_DSP_VALUEHL
372d			 
372d e5					push hl    ; to go to bc 
372e			 
372e					; destroy value TOS 
372e			 
372e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372e cd 03 1f			call macro_forth_dsp_pop 
3731				endm 
# End of macro FORTH_DSP_POP
3731			 
3731			 
3731					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3731 cd 4b 1e			call macro_dsp_valuehl 
3734				endm 
# End of macro FORTH_DSP_VALUEHL
3734			 
3734					; hl to go to de 
3734			 
3734 e5					push hl 
3735			 
3735 c1					pop bc 
3736 d1					pop de		 
3737			 
3737			 
3737					if DEBUG_FORTH_MATHS 
3737						DMARK "DIV" 
3737				CALLMONITOR 
3737					endif 
3737					; one value on hl but move to a get other one back 
3737			 
3737			        
3737 cd 44 0d			call Div16 
373a			 
373a			;	push af	 
373a e5				push hl 
373b c5				push bc 
373c			 
373c					if DEBUG_FORTH_MATHS 
373c						DMARK "DI1" 
373c				CALLMONITOR 
373c					endif 
373c			 
373c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373c cd 03 1f			call macro_forth_dsp_pop 
373f				endm 
# End of macro FORTH_DSP_POP
373f			 
373f			 
373f			 
373f e1					pop hl    ; result 
3740			 
3740 cd 54 1c				call forth_push_numhl 
3743			 
3743 e1					pop hl    ; reminder 
3744			;		ld h,0 
3744			;		ld l,d 
3744			 
3744 cd 54 1c				call forth_push_numhl 
3747			.div_done: 
3747					NEXTW 
3747 c3 01 20			jp macro_next 
374a				endm 
# End of macro NEXTW
374a			.MUL: 
374a				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
374a 19				db WORD_SYS_CORE+5             
374b 8f 37			dw .MIN            
374d 02				db 1 + 1 
374e .. 00			db "*",0              
3750				endm 
# End of macro CWHEAD
3750			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3750				; TODO add floating point number detection 
3750					if DEBUG_FORTH_WORDS_KEY 
3750						DMARK "MUL" 
3750 f5				push af  
3751 3a 65 37			ld a, (.dmark)  
3754 32 6e ee			ld (debug_mark),a  
3757 3a 66 37			ld a, (.dmark+1)  
375a 32 6f ee			ld (debug_mark+1),a  
375d 3a 67 37			ld a, (.dmark+2)  
3760 32 70 ee			ld (debug_mark+2),a  
3763 18 03			jr .pastdmark  
3765 ..			.dmark: db "MUL"  
3768 f1			.pastdmark: pop af  
3769			endm  
# End of macro DMARK
3769						CALLMONITOR 
3769 cd 72 ee			call debug_vector  
376c				endm  
# End of macro CALLMONITOR
376c					endif 
376c					FORTH_DSP 
376c cd 11 1e			call macro_forth_dsp 
376f				endm 
# End of macro FORTH_DSP
376f					; v5 FORTH_DSP_VALUE 
376f 7e					ld a,(hl)	; get type of value on TOS 
3770 fe 02				cp DS_TYPE_INUM  
3772 28 03				jr z, .mul_inum 
3774			 
3774				if FORTH_ENABLE_FLOATMATH 
3774					jr .mul_done 
3774			 
3774				endif 
3774			 
3774					NEXTW 
3774 c3 01 20			jp macro_next 
3777				endm 
# End of macro NEXTW
3777			.mul_inum:	 
3777			 
3777					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3777 cd 4b 1e			call macro_dsp_valuehl 
377a				endm 
# End of macro FORTH_DSP_VALUEHL
377a			 
377a e5					push hl 
377b			 
377b					; destroy value TOS 
377b			 
377b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377b cd 03 1f			call macro_forth_dsp_pop 
377e				endm 
# End of macro FORTH_DSP_POP
377e			 
377e			 
377e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377e cd 4b 1e			call macro_dsp_valuehl 
3781				endm 
# End of macro FORTH_DSP_VALUEHL
3781			 
3781					; one value on hl but move to a get other one back 
3781			 
3781 7d					ld a, l 
3782			 
3782 d1					pop de 
3783			 
3783					; do the mull 
3783			;		ex de, hl 
3783			 
3783 cd 6a 0d				call Mult16 
3786					; save it 
3786			 
3786			;		push hl	 
3786			 
3786					; 
3786			 
3786					; destroy value TOS 
3786			 
3786					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3786 cd 03 1f			call macro_forth_dsp_pop 
3789				endm 
# End of macro FORTH_DSP_POP
3789			 
3789					; TODO push value back onto stack for another op etc 
3789			 
3789			;		pop hl 
3789			 
3789 cd 54 1c				call forth_push_numhl 
378c			 
378c			.mul_done: 
378c					NEXTW 
378c c3 01 20			jp macro_next 
378f				endm 
# End of macro NEXTW
378f			 
378f			 
378f			 
378f			 
378f			.MIN: 
378f				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
378f 49				db WORD_SYS_CORE+53             
3790 10 38			dw .MAX            
3792 04				db 3 + 1 
3793 .. 00			db "MIN",0              
3797				endm 
# End of macro CWHEAD
3797			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3797					if DEBUG_FORTH_WORDS_KEY 
3797						DMARK "MIN" 
3797 f5				push af  
3798 3a ac 37			ld a, (.dmark)  
379b 32 6e ee			ld (debug_mark),a  
379e 3a ad 37			ld a, (.dmark+1)  
37a1 32 6f ee			ld (debug_mark+1),a  
37a4 3a ae 37			ld a, (.dmark+2)  
37a7 32 70 ee			ld (debug_mark+2),a  
37aa 18 03			jr .pastdmark  
37ac ..			.dmark: db "MIN"  
37af f1			.pastdmark: pop af  
37b0			endm  
# End of macro DMARK
37b0						CALLMONITOR 
37b0 cd 72 ee			call debug_vector  
37b3				endm  
# End of macro CALLMONITOR
37b3					endif 
37b3					; get u2 
37b3			 
37b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b3 cd 4b 1e			call macro_dsp_valuehl 
37b6				endm 
# End of macro FORTH_DSP_VALUEHL
37b6			 
37b6 e5					push hl   ; u2 
37b7			 
37b7					; destroy value TOS 
37b7			 
37b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b7 cd 03 1f			call macro_forth_dsp_pop 
37ba				endm 
# End of macro FORTH_DSP_POP
37ba			 
37ba					; get u1 
37ba			 
37ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ba cd 4b 1e			call macro_dsp_valuehl 
37bd				endm 
# End of macro FORTH_DSP_VALUEHL
37bd			 
37bd e5					push hl  ; u1 
37be			 
37be					; destroy value TOS 
37be			 
37be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37be cd 03 1f			call macro_forth_dsp_pop 
37c1				endm 
# End of macro FORTH_DSP_POP
37c1			 
37c1 b7			 or a      ;clear carry flag 
37c2 e1			  pop hl    ; u1 
37c3 d1			  pop de    ; u2 
37c4 e5				push hl   ; saved in case hl is lowest 
37c5 ed 52		  sbc hl,de 
37c7 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37c9			 
37c9 e1				pop hl 
37ca					if DEBUG_FORTH_WORDS 
37ca						DMARK "MIN" 
37ca f5				push af  
37cb 3a df 37			ld a, (.dmark)  
37ce 32 6e ee			ld (debug_mark),a  
37d1 3a e0 37			ld a, (.dmark+1)  
37d4 32 6f ee			ld (debug_mark+1),a  
37d7 3a e1 37			ld a, (.dmark+2)  
37da 32 70 ee			ld (debug_mark+2),a  
37dd 18 03			jr .pastdmark  
37df ..			.dmark: db "MIN"  
37e2 f1			.pastdmark: pop af  
37e3			endm  
# End of macro DMARK
37e3						CALLMONITOR 
37e3 cd 72 ee			call debug_vector  
37e6				endm  
# End of macro CALLMONITOR
37e6					endif 
37e6 cd 54 1c				call forth_push_numhl 
37e9			 
37e9				       NEXTW 
37e9 c3 01 20			jp macro_next 
37ec				endm 
# End of macro NEXTW
37ec			 
37ec			.mincont:  
37ec c1				pop bc   ; tidy up 
37ed eb				ex de , hl  
37ee					if DEBUG_FORTH_WORDS 
37ee						DMARK "MI1" 
37ee f5				push af  
37ef 3a 03 38			ld a, (.dmark)  
37f2 32 6e ee			ld (debug_mark),a  
37f5 3a 04 38			ld a, (.dmark+1)  
37f8 32 6f ee			ld (debug_mark+1),a  
37fb 3a 05 38			ld a, (.dmark+2)  
37fe 32 70 ee			ld (debug_mark+2),a  
3801 18 03			jr .pastdmark  
3803 ..			.dmark: db "MI1"  
3806 f1			.pastdmark: pop af  
3807			endm  
# End of macro DMARK
3807						CALLMONITOR 
3807 cd 72 ee			call debug_vector  
380a				endm  
# End of macro CALLMONITOR
380a					endif 
380a cd 54 1c				call forth_push_numhl 
380d			 
380d				       NEXTW 
380d c3 01 20			jp macro_next 
3810				endm 
# End of macro NEXTW
3810			.MAX: 
3810				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3810 4a				db WORD_SYS_CORE+54             
3811 91 38			dw .RND16            
3813 04				db 3 + 1 
3814 .. 00			db "MAX",0              
3818				endm 
# End of macro CWHEAD
3818			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3818					if DEBUG_FORTH_WORDS_KEY 
3818						DMARK "MAX" 
3818 f5				push af  
3819 3a 2d 38			ld a, (.dmark)  
381c 32 6e ee			ld (debug_mark),a  
381f 3a 2e 38			ld a, (.dmark+1)  
3822 32 6f ee			ld (debug_mark+1),a  
3825 3a 2f 38			ld a, (.dmark+2)  
3828 32 70 ee			ld (debug_mark+2),a  
382b 18 03			jr .pastdmark  
382d ..			.dmark: db "MAX"  
3830 f1			.pastdmark: pop af  
3831			endm  
# End of macro DMARK
3831						CALLMONITOR 
3831 cd 72 ee			call debug_vector  
3834				endm  
# End of macro CALLMONITOR
3834					endif 
3834					; get u2 
3834			 
3834					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3834 cd 4b 1e			call macro_dsp_valuehl 
3837				endm 
# End of macro FORTH_DSP_VALUEHL
3837			 
3837 e5					push hl   ; u2 
3838			 
3838					; destroy value TOS 
3838			 
3838					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3838 cd 03 1f			call macro_forth_dsp_pop 
383b				endm 
# End of macro FORTH_DSP_POP
383b			 
383b					; get u1 
383b			 
383b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383b cd 4b 1e			call macro_dsp_valuehl 
383e				endm 
# End of macro FORTH_DSP_VALUEHL
383e			 
383e e5					push hl  ; u1 
383f			 
383f					; destroy value TOS 
383f			 
383f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383f cd 03 1f			call macro_forth_dsp_pop 
3842				endm 
# End of macro FORTH_DSP_POP
3842			 
3842 b7			 or a      ;clear carry flag 
3843 e1			  pop hl    ; u1 
3844 d1			  pop de    ; u2 
3845 e5				push hl   ; saved in case hl is lowest 
3846 ed 52		  sbc hl,de 
3848 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
384a			 
384a e1				pop hl 
384b					if DEBUG_FORTH_WORDS 
384b						DMARK "MAX" 
384b f5				push af  
384c 3a 60 38			ld a, (.dmark)  
384f 32 6e ee			ld (debug_mark),a  
3852 3a 61 38			ld a, (.dmark+1)  
3855 32 6f ee			ld (debug_mark+1),a  
3858 3a 62 38			ld a, (.dmark+2)  
385b 32 70 ee			ld (debug_mark+2),a  
385e 18 03			jr .pastdmark  
3860 ..			.dmark: db "MAX"  
3863 f1			.pastdmark: pop af  
3864			endm  
# End of macro DMARK
3864						CALLMONITOR 
3864 cd 72 ee			call debug_vector  
3867				endm  
# End of macro CALLMONITOR
3867					endif 
3867 cd 54 1c				call forth_push_numhl 
386a			 
386a				       NEXTW 
386a c3 01 20			jp macro_next 
386d				endm 
# End of macro NEXTW
386d			 
386d			.maxcont:  
386d c1				pop bc   ; tidy up 
386e eb				ex de , hl  
386f					if DEBUG_FORTH_WORDS 
386f						DMARK "MA1" 
386f f5				push af  
3870 3a 84 38			ld a, (.dmark)  
3873 32 6e ee			ld (debug_mark),a  
3876 3a 85 38			ld a, (.dmark+1)  
3879 32 6f ee			ld (debug_mark+1),a  
387c 3a 86 38			ld a, (.dmark+2)  
387f 32 70 ee			ld (debug_mark+2),a  
3882 18 03			jr .pastdmark  
3884 ..			.dmark: db "MA1"  
3887 f1			.pastdmark: pop af  
3888			endm  
# End of macro DMARK
3888						CALLMONITOR 
3888 cd 72 ee			call debug_vector  
388b				endm  
# End of macro CALLMONITOR
388b					endif 
388b cd 54 1c				call forth_push_numhl 
388e				       NEXTW 
388e c3 01 20			jp macro_next 
3891				endm 
# End of macro NEXTW
3891			 
3891			.RND16: 
3891				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3891 4e				db WORD_SYS_CORE+58             
3892 c0 38			dw .RND8            
3894 06				db 5 + 1 
3895 .. 00			db "RND16",0              
389b				endm 
# End of macro CWHEAD
389b			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
389b					if DEBUG_FORTH_WORDS_KEY 
389b						DMARK "R16" 
389b f5				push af  
389c 3a b0 38			ld a, (.dmark)  
389f 32 6e ee			ld (debug_mark),a  
38a2 3a b1 38			ld a, (.dmark+1)  
38a5 32 6f ee			ld (debug_mark+1),a  
38a8 3a b2 38			ld a, (.dmark+2)  
38ab 32 70 ee			ld (debug_mark+2),a  
38ae 18 03			jr .pastdmark  
38b0 ..			.dmark: db "R16"  
38b3 f1			.pastdmark: pop af  
38b4			endm  
# End of macro DMARK
38b4						CALLMONITOR 
38b4 cd 72 ee			call debug_vector  
38b7				endm  
# End of macro CALLMONITOR
38b7					endif 
38b7 cd 0e 0d				call prng16  
38ba cd 54 1c				call forth_push_numhl 
38bd				       NEXTW 
38bd c3 01 20			jp macro_next 
38c0				endm 
# End of macro NEXTW
38c0			.RND8: 
38c0				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38c0 60				db WORD_SYS_CORE+76             
38c1 f5 38			dw .RND            
38c3 05				db 4 + 1 
38c4 .. 00			db "RND8",0              
38c9				endm 
# End of macro CWHEAD
38c9			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38c9					if DEBUG_FORTH_WORDS_KEY 
38c9						DMARK "RN8" 
38c9 f5				push af  
38ca 3a de 38			ld a, (.dmark)  
38cd 32 6e ee			ld (debug_mark),a  
38d0 3a df 38			ld a, (.dmark+1)  
38d3 32 6f ee			ld (debug_mark+1),a  
38d6 3a e0 38			ld a, (.dmark+2)  
38d9 32 70 ee			ld (debug_mark+2),a  
38dc 18 03			jr .pastdmark  
38de ..			.dmark: db "RN8"  
38e1 f1			.pastdmark: pop af  
38e2			endm  
# End of macro DMARK
38e2						CALLMONITOR 
38e2 cd 72 ee			call debug_vector  
38e5				endm  
# End of macro CALLMONITOR
38e5					endif 
38e5 2a ac eb				ld hl,(xrandc) 
38e8 23					inc hl 
38e9 cd 28 0d				call xrnd 
38ec 6f					ld l,a	 
38ed 26 00				ld h,0 
38ef cd 54 1c				call forth_push_numhl 
38f2				       NEXTW 
38f2 c3 01 20			jp macro_next 
38f5				endm 
# End of macro NEXTW
38f5			.RND: 
38f5				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38f5 60				db WORD_SYS_CORE+76             
38f6 fb 39			dw .ENDMATHS            
38f8 04				db 3 + 1 
38f9 .. 00			db "RND",0              
38fd				endm 
# End of macro CWHEAD
38fd			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38fd			 
38fd					if DEBUG_FORTH_WORDS_KEY 
38fd						DMARK "RND" 
38fd f5				push af  
38fe 3a 12 39			ld a, (.dmark)  
3901 32 6e ee			ld (debug_mark),a  
3904 3a 13 39			ld a, (.dmark+1)  
3907 32 6f ee			ld (debug_mark+1),a  
390a 3a 14 39			ld a, (.dmark+2)  
390d 32 70 ee			ld (debug_mark+2),a  
3910 18 03			jr .pastdmark  
3912 ..			.dmark: db "RND"  
3915 f1			.pastdmark: pop af  
3916			endm  
# End of macro DMARK
3916						CALLMONITOR 
3916 cd 72 ee			call debug_vector  
3919				endm  
# End of macro CALLMONITOR
3919					endif 
3919					 
3919					FORTH_DSP_VALUEHL    ; upper range 
3919 cd 4b 1e			call macro_dsp_valuehl 
391c				endm 
# End of macro FORTH_DSP_VALUEHL
391c			 
391c 22 b0 eb				ld (LFSRSeed), hl	 
391f			 
391f					if DEBUG_FORTH_WORDS 
391f						DMARK "RN1" 
391f f5				push af  
3920 3a 34 39			ld a, (.dmark)  
3923 32 6e ee			ld (debug_mark),a  
3926 3a 35 39			ld a, (.dmark+1)  
3929 32 6f ee			ld (debug_mark+1),a  
392c 3a 36 39			ld a, (.dmark+2)  
392f 32 70 ee			ld (debug_mark+2),a  
3932 18 03			jr .pastdmark  
3934 ..			.dmark: db "RN1"  
3937 f1			.pastdmark: pop af  
3938			endm  
# End of macro DMARK
3938						CALLMONITOR 
3938 cd 72 ee			call debug_vector  
393b				endm  
# End of macro CALLMONITOR
393b					endif 
393b					FORTH_DSP_POP 
393b cd 03 1f			call macro_forth_dsp_pop 
393e				endm 
# End of macro FORTH_DSP_POP
393e			 
393e					FORTH_DSP_VALUEHL    ; low range 
393e cd 4b 1e			call macro_dsp_valuehl 
3941				endm 
# End of macro FORTH_DSP_VALUEHL
3941			 
3941					if DEBUG_FORTH_WORDS 
3941						DMARK "RN2" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 6e ee			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 6f ee			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 70 ee			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "RN2"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a						CALLMONITOR 
395a cd 72 ee			call debug_vector  
395d				endm  
# End of macro CALLMONITOR
395d					endif 
395d 22 b2 eb				ld (LFSRSeed+2), hl 
3960			 
3960					FORTH_DSP_POP 
3960 cd 03 1f			call macro_forth_dsp_pop 
3963				endm 
# End of macro FORTH_DSP_POP
3963			 
3963 e5					push hl 
3964			 
3964 e1			.inrange:	pop hl 
3965 cd 0e 0d				call prng16  
3968					if DEBUG_FORTH_WORDS 
3968						DMARK "RN3" 
3968 f5				push af  
3969 3a 7d 39			ld a, (.dmark)  
396c 32 6e ee			ld (debug_mark),a  
396f 3a 7e 39			ld a, (.dmark+1)  
3972 32 6f ee			ld (debug_mark+1),a  
3975 3a 7f 39			ld a, (.dmark+2)  
3978 32 70 ee			ld (debug_mark+2),a  
397b 18 03			jr .pastdmark  
397d ..			.dmark: db "RN3"  
3980 f1			.pastdmark: pop af  
3981			endm  
# End of macro DMARK
3981						CALLMONITOR 
3981 cd 72 ee			call debug_vector  
3984				endm  
# End of macro CALLMONITOR
3984					endif 
3984					 
3984					; if the range is 8bit knock out the high byte 
3984			 
3984 ed 5b b0 eb			ld de, (LFSRSeed)     ; check high level 
3988			 
3988 3e 00				ld a, 0 
398a ba					cp d  
398b 20 1e				jr nz, .hirange 
398d 26 00				ld h, 0   ; knock it down to 8bit 
398f			 
398f					if DEBUG_FORTH_WORDS 
398f						DMARK "RNk" 
398f f5				push af  
3990 3a a4 39			ld a, (.dmark)  
3993 32 6e ee			ld (debug_mark),a  
3996 3a a5 39			ld a, (.dmark+1)  
3999 32 6f ee			ld (debug_mark+1),a  
399c 3a a6 39			ld a, (.dmark+2)  
399f 32 70 ee			ld (debug_mark+2),a  
39a2 18 03			jr .pastdmark  
39a4 ..			.dmark: db "RNk"  
39a7 f1			.pastdmark: pop af  
39a8			endm  
# End of macro DMARK
39a8						CALLMONITOR 
39a8 cd 72 ee			call debug_vector  
39ab				endm  
# End of macro CALLMONITOR
39ab					endif 
39ab			.hirange:   
39ab e5					push hl  
39ac b7					or a  
39ad ed 52		                sbc hl, de 
39af			 
39af					;call cmp16 
39af			 
39af 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39b1 e1					pop hl 
39b2 e5					push hl 
39b3			 
39b3					if DEBUG_FORTH_WORDS 
39b3						DMARK "RN4" 
39b3 f5				push af  
39b4 3a c8 39			ld a, (.dmark)  
39b7 32 6e ee			ld (debug_mark),a  
39ba 3a c9 39			ld a, (.dmark+1)  
39bd 32 6f ee			ld (debug_mark+1),a  
39c0 3a ca 39			ld a, (.dmark+2)  
39c3 32 70 ee			ld (debug_mark+2),a  
39c6 18 03			jr .pastdmark  
39c8 ..			.dmark: db "RN4"  
39cb f1			.pastdmark: pop af  
39cc			endm  
# End of macro DMARK
39cc						CALLMONITOR 
39cc cd 72 ee			call debug_vector  
39cf				endm  
# End of macro CALLMONITOR
39cf					endif 
39cf ed 5b b2 eb			ld de, (LFSRSeed+2)   ; check low range 
39d3					;call cmp16 
39d3				 
39d3 b7					or a  
39d4 ed 52		                sbc hl, de 
39d6 38 8c				jr c, .inrange 
39d8			 
39d8 e1					pop hl 
39d9					 
39d9					if DEBUG_FORTH_WORDS 
39d9						DMARK "RNd" 
39d9 f5				push af  
39da 3a ee 39			ld a, (.dmark)  
39dd 32 6e ee			ld (debug_mark),a  
39e0 3a ef 39			ld a, (.dmark+1)  
39e3 32 6f ee			ld (debug_mark+1),a  
39e6 3a f0 39			ld a, (.dmark+2)  
39e9 32 70 ee			ld (debug_mark+2),a  
39ec 18 03			jr .pastdmark  
39ee ..			.dmark: db "RNd"  
39f1 f1			.pastdmark: pop af  
39f2			endm  
# End of macro DMARK
39f2						CALLMONITOR 
39f2 cd 72 ee			call debug_vector  
39f5				endm  
# End of macro CALLMONITOR
39f5					endif 
39f5			 
39f5			 
39f5 cd 54 1c				call forth_push_numhl 
39f8				       NEXTW 
39f8 c3 01 20			jp macro_next 
39fb				endm 
# End of macro NEXTW
39fb			 
39fb			.ENDMATHS: 
39fb			 
39fb			; eof 
39fb			 
# End of file forth_words_maths.asm
39fb			include "forth_words_display.asm" 
39fb			 
39fb			; | ## Display Words 
39fb			 
39fb			.ACT: 
39fb			 
39fb				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39fb 62				db WORD_SYS_CORE+78             
39fc 47 3a			dw .INFO            
39fe 07				db 6 + 1 
39ff .. 00			db "ACTIVE",0              
3a06				endm 
# End of macro CWHEAD
3a06			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a06			;  
3a06			; | | e.g. $ff $00 do active . $01 pause loop 
3a06			 
3a06					if DEBUG_FORTH_WORDS_KEY 
3a06						DMARK "ACT" 
3a06 f5				push af  
3a07 3a 1b 3a			ld a, (.dmark)  
3a0a 32 6e ee			ld (debug_mark),a  
3a0d 3a 1c 3a			ld a, (.dmark+1)  
3a10 32 6f ee			ld (debug_mark+1),a  
3a13 3a 1d 3a			ld a, (.dmark+2)  
3a16 32 70 ee			ld (debug_mark+2),a  
3a19 18 03			jr .pastdmark  
3a1b ..			.dmark: db "ACT"  
3a1e f1			.pastdmark: pop af  
3a1f			endm  
# End of macro DMARK
3a1f						CALLMONITOR 
3a1f cd 72 ee			call debug_vector  
3a22				endm  
# End of macro CALLMONITOR
3a22					endif 
3a22 cd 11 0b				call active 
3a25					if DEBUG_FORTH_WORDS 
3a25						DMARK "ACp" 
3a25 f5				push af  
3a26 3a 3a 3a			ld a, (.dmark)  
3a29 32 6e ee			ld (debug_mark),a  
3a2c 3a 3b 3a			ld a, (.dmark+1)  
3a2f 32 6f ee			ld (debug_mark+1),a  
3a32 3a 3c 3a			ld a, (.dmark+2)  
3a35 32 70 ee			ld (debug_mark+2),a  
3a38 18 03			jr .pastdmark  
3a3a ..			.dmark: db "ACp"  
3a3d f1			.pastdmark: pop af  
3a3e			endm  
# End of macro DMARK
3a3e						CALLMONITOR 
3a3e cd 72 ee			call debug_vector  
3a41				endm  
# End of macro CALLMONITOR
3a41					endif 
3a41 cd c2 1c				call forth_push_str 
3a44			 
3a44					NEXTW 
3a44 c3 01 20			jp macro_next 
3a47				endm 
# End of macro NEXTW
3a47			.INFO: 
3a47			 
3a47				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a47 62				db WORD_SYS_CORE+78             
3a48 64 3a			dw .ATP            
3a4a 05				db 4 + 1 
3a4b .. 00			db "INFO",0              
3a50				endm 
# End of macro CWHEAD
3a50			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a50					FORTH_DSP_VALUEHL 
3a50 cd 4b 1e			call macro_dsp_valuehl 
3a53				endm 
# End of macro FORTH_DSP_VALUEHL
3a53			 
3a53					FORTH_DSP_POP 
3a53 cd 03 1f			call macro_forth_dsp_pop 
3a56				endm 
# End of macro FORTH_DSP_POP
3a56			 
3a56 e5					push hl 
3a57			 
3a57					FORTH_DSP_VALUEHL 
3a57 cd 4b 1e			call macro_dsp_valuehl 
3a5a				endm 
# End of macro FORTH_DSP_VALUEHL
3a5a			 
3a5a					FORTH_DSP_POP 
3a5a cd 03 1f			call macro_forth_dsp_pop 
3a5d				endm 
# End of macro FORTH_DSP_POP
3a5d			 
3a5d d1					pop de 
3a5e			 
3a5e cd 4b 0b				call info_panel 
3a61			 
3a61			 
3a61					NEXTW 
3a61 c3 01 20			jp macro_next 
3a64				endm 
# End of macro NEXTW
3a64			.ATP: 
3a64				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a64 62				db WORD_SYS_CORE+78             
3a65 db 3a			dw .FB            
3a67 04				db 3 + 1 
3a68 .. 00			db "AT?",0              
3a6c				endm 
# End of macro CWHEAD
3a6c			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a6c					if DEBUG_FORTH_WORDS_KEY 
3a6c						DMARK "AT?" 
3a6c f5				push af  
3a6d 3a 81 3a			ld a, (.dmark)  
3a70 32 6e ee			ld (debug_mark),a  
3a73 3a 82 3a			ld a, (.dmark+1)  
3a76 32 6f ee			ld (debug_mark+1),a  
3a79 3a 83 3a			ld a, (.dmark+2)  
3a7c 32 70 ee			ld (debug_mark+2),a  
3a7f 18 03			jr .pastdmark  
3a81 ..			.dmark: db "AT?"  
3a84 f1			.pastdmark: pop af  
3a85			endm  
# End of macro DMARK
3a85						CALLMONITOR 
3a85 cd 72 ee			call debug_vector  
3a88				endm  
# End of macro CALLMONITOR
3a88					endif 
3a88 3a 61 ea				ld a, (f_cursor_ptr) 
3a8b			 
3a8b			if DEBUG_FORTH_WORDS 
3a8b				DMARK "AT?" 
3a8b f5				push af  
3a8c 3a a0 3a			ld a, (.dmark)  
3a8f 32 6e ee			ld (debug_mark),a  
3a92 3a a1 3a			ld a, (.dmark+1)  
3a95 32 6f ee			ld (debug_mark+1),a  
3a98 3a a2 3a			ld a, (.dmark+2)  
3a9b 32 70 ee			ld (debug_mark+2),a  
3a9e 18 03			jr .pastdmark  
3aa0 ..			.dmark: db "AT?"  
3aa3 f1			.pastdmark: pop af  
3aa4			endm  
# End of macro DMARK
3aa4				CALLMONITOR 
3aa4 cd 72 ee			call debug_vector  
3aa7				endm  
# End of macro CALLMONITOR
3aa7			endif	 
3aa7					; count the number of rows 
3aa7			 
3aa7 06 00				ld b, 0 
3aa9 4f			.atpr:		ld c, a    ; save in case we go below zero 
3aaa d6 28				sub display_cols 
3aac f2 b2 3a				jp p, .atprunder 
3aaf 04					inc b 
3ab0 18 f7				jr .atpr 
3ab2			.atprunder:	 
3ab2			if DEBUG_FORTH_WORDS 
3ab2				DMARK "A?2" 
3ab2 f5				push af  
3ab3 3a c7 3a			ld a, (.dmark)  
3ab6 32 6e ee			ld (debug_mark),a  
3ab9 3a c8 3a			ld a, (.dmark+1)  
3abc 32 6f ee			ld (debug_mark+1),a  
3abf 3a c9 3a			ld a, (.dmark+2)  
3ac2 32 70 ee			ld (debug_mark+2),a  
3ac5 18 03			jr .pastdmark  
3ac7 ..			.dmark: db "A?2"  
3aca f1			.pastdmark: pop af  
3acb			endm  
# End of macro DMARK
3acb				CALLMONITOR 
3acb cd 72 ee			call debug_vector  
3ace				endm  
# End of macro CALLMONITOR
3ace			endif	 
3ace 26 00				ld h, 0 
3ad0 69					ld l, c 
3ad1 cd 54 1c				call forth_push_numhl 
3ad4 68					ld l, b  
3ad5 cd 54 1c				call forth_push_numhl 
3ad8			 
3ad8			 
3ad8				NEXTW 
3ad8 c3 01 20			jp macro_next 
3adb				endm 
# End of macro NEXTW
3adb			 
3adb			.FB: 
3adb				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3adb 1b				db WORD_SYS_CORE+7             
3adc 29 3b			dw .EMIT            
3ade 03				db 2 + 1 
3adf .. 00			db "FB",0              
3ae2				endm 
# End of macro CWHEAD
3ae2			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ae2			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ae2			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ae2			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ae2					if DEBUG_FORTH_WORDS_KEY 
3ae2						DMARK "FB." 
3ae2 f5				push af  
3ae3 3a f7 3a			ld a, (.dmark)  
3ae6 32 6e ee			ld (debug_mark),a  
3ae9 3a f8 3a			ld a, (.dmark+1)  
3aec 32 6f ee			ld (debug_mark+1),a  
3aef 3a f9 3a			ld a, (.dmark+2)  
3af2 32 70 ee			ld (debug_mark+2),a  
3af5 18 03			jr .pastdmark  
3af7 ..			.dmark: db "FB."  
3afa f1			.pastdmark: pop af  
3afb			endm  
# End of macro DMARK
3afb						CALLMONITOR 
3afb cd 72 ee			call debug_vector  
3afe				endm  
# End of macro CALLMONITOR
3afe					endif 
3afe			 
3afe					FORTH_DSP_VALUEHL 
3afe cd 4b 1e			call macro_dsp_valuehl 
3b01				endm 
# End of macro FORTH_DSP_VALUEHL
3b01			 
3b01 7d					ld a, l 
3b02 fe 01				cp 1 
3b04 20 05				jr nz, .fbn1 
3b06 21 13 ed				ld hl, display_fb1 
3b09 18 15				jr .fbset 
3b0b fe 02		.fbn1:		cp 2 
3b0d 20 05				jr nz, .fbn2 
3b0f 21 d1 eb				ld hl, display_fb2 
3b12 18 0c				jr .fbset 
3b14 fe 03		.fbn2:		cp 3 
3b16 20 05				jr nz, .fbn3 
3b18 21 72 ec				ld hl, display_fb3 
3b1b 18 03				jr .fbset 
3b1d			.fbn3:		 ; if invalid number select first 
3b1d 21 13 ed				ld hl, display_fb1 
3b20 22 cf eb		.fbset:		ld (display_fb_active), hl 
3b23			 
3b23					FORTH_DSP_POP 
3b23 cd 03 1f			call macro_forth_dsp_pop 
3b26				endm 
# End of macro FORTH_DSP_POP
3b26			 
3b26					NEXTW 
3b26 c3 01 20			jp macro_next 
3b29				endm 
# End of macro NEXTW
3b29			 
3b29			 
3b29			.EMIT: 
3b29				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b29 1b				db WORD_SYS_CORE+7             
3b2a 7a 3b			dw .DOTH            
3b2c 05				db 4 + 1 
3b2d .. 00			db "EMIT",0              
3b32				endm 
# End of macro CWHEAD
3b32			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b32					; get value off TOS and display it 
3b32			 
3b32					if DEBUG_FORTH_WORDS_KEY 
3b32						DMARK "EMT" 
3b32 f5				push af  
3b33 3a 47 3b			ld a, (.dmark)  
3b36 32 6e ee			ld (debug_mark),a  
3b39 3a 48 3b			ld a, (.dmark+1)  
3b3c 32 6f ee			ld (debug_mark+1),a  
3b3f 3a 49 3b			ld a, (.dmark+2)  
3b42 32 70 ee			ld (debug_mark+2),a  
3b45 18 03			jr .pastdmark  
3b47 ..			.dmark: db "EMT"  
3b4a f1			.pastdmark: pop af  
3b4b			endm  
# End of macro DMARK
3b4b						CALLMONITOR 
3b4b cd 72 ee			call debug_vector  
3b4e				endm  
# End of macro CALLMONITOR
3b4e					endif 
3b4e			 
3b4e					FORTH_DSP_VALUEHL 
3b4e cd 4b 1e			call macro_dsp_valuehl 
3b51				endm 
# End of macro FORTH_DSP_VALUEHL
3b51			 
3b51 7d					ld a,l 
3b52			 
3b52					; TODO write to display 
3b52			 
3b52 32 c2 e4				ld (os_input), a 
3b55 3e 00				ld a, 0 
3b57 32 c3 e4				ld (os_input+1), a 
3b5a					 
3b5a 3a 61 ea				ld a, (f_cursor_ptr) 
3b5d 11 c2 e4				ld de, os_input 
3b60 cd cd 0b				call str_at_display 
3b63			 
3b63			 
3b63 3a 3f ea				ld a,(cli_autodisplay) 
3b66 fe 00				cp 0 
3b68 28 03				jr z, .enoupdate 
3b6a cd dd 0b						call update_display 
3b6d					.enoupdate: 
3b6d			 
3b6d 3a 61 ea				ld a, (f_cursor_ptr) 
3b70 3c					inc a 
3b71 32 61 ea				ld (f_cursor_ptr), a   ; save new pos 
3b74			 
3b74			 
3b74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b74 cd 03 1f			call macro_forth_dsp_pop 
3b77				endm 
# End of macro FORTH_DSP_POP
3b77			  
3b77			 
3b77					NEXTW 
3b77 c3 01 20			jp macro_next 
3b7a				endm 
# End of macro NEXTW
3b7a			.DOTH: 
3b7a				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b7a 1c				db WORD_SYS_CORE+8             
3b7b aa 3b			dw .DOTF            
3b7d 03				db 2 + 1 
3b7e .. 00			db ".-",0              
3b81				endm 
# End of macro CWHEAD
3b81			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b81					; get value off TOS and display it 
3b81					if DEBUG_FORTH_WORDS_KEY 
3b81						DMARK "DTD" 
3b81 f5				push af  
3b82 3a 96 3b			ld a, (.dmark)  
3b85 32 6e ee			ld (debug_mark),a  
3b88 3a 97 3b			ld a, (.dmark+1)  
3b8b 32 6f ee			ld (debug_mark+1),a  
3b8e 3a 98 3b			ld a, (.dmark+2)  
3b91 32 70 ee			ld (debug_mark+2),a  
3b94 18 03			jr .pastdmark  
3b96 ..			.dmark: db "DTD"  
3b99 f1			.pastdmark: pop af  
3b9a			endm  
# End of macro DMARK
3b9a						CALLMONITOR 
3b9a cd 72 ee			call debug_vector  
3b9d				endm  
# End of macro CALLMONITOR
3b9d					endif 
3b9d 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b9f 3e 00			ld a, 0 
3ba1 32 40 ea			ld (cli_mvdot), a 
3ba4 c3 01 3c			jp .dotgo 
3ba7				NEXTW 
3ba7 c3 01 20			jp macro_next 
3baa				endm 
# End of macro NEXTW
3baa			.DOTF: 
3baa				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3baa 1c				db WORD_SYS_CORE+8             
3bab d8 3b			dw .DOT            
3bad 03				db 2 + 1 
3bae .. 00			db ".>",0              
3bb1				endm 
# End of macro CWHEAD
3bb1			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bb1					; get value off TOS and display it 
3bb1			        ; TODO BUG adds extra spaces 
3bb1			        ; TODO BUG handle numerics? 
3bb1					if DEBUG_FORTH_WORDS_KEY 
3bb1						DMARK "DTC" 
3bb1 f5				push af  
3bb2 3a c6 3b			ld a, (.dmark)  
3bb5 32 6e ee			ld (debug_mark),a  
3bb8 3a c7 3b			ld a, (.dmark+1)  
3bbb 32 6f ee			ld (debug_mark+1),a  
3bbe 3a c8 3b			ld a, (.dmark+2)  
3bc1 32 70 ee			ld (debug_mark+2),a  
3bc4 18 03			jr .pastdmark  
3bc6 ..			.dmark: db "DTC"  
3bc9 f1			.pastdmark: pop af  
3bca			endm  
# End of macro DMARK
3bca						CALLMONITOR 
3bca cd 72 ee			call debug_vector  
3bcd				endm  
# End of macro CALLMONITOR
3bcd					endif 
3bcd 3e 01			ld a, 1 
3bcf 32 40 ea			ld (cli_mvdot), a 
3bd2 c3 01 3c			jp .dotgo 
3bd5				NEXTW 
3bd5 c3 01 20			jp macro_next 
3bd8				endm 
# End of macro NEXTW
3bd8			 
3bd8			.DOT: 
3bd8				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bd8 1c				db WORD_SYS_CORE+8             
3bd9 b4 3d			dw .CLS            
3bdb 02				db 1 + 1 
3bdc .. 00			db ".",0              
3bde				endm 
# End of macro CWHEAD
3bde			        ; | . ( u -- ) Display TOS | DONE 
3bde					; get value off TOS and display it 
3bde			 
3bde					if DEBUG_FORTH_WORDS_KEY 
3bde						DMARK "DOT" 
3bde f5				push af  
3bdf 3a f3 3b			ld a, (.dmark)  
3be2 32 6e ee			ld (debug_mark),a  
3be5 3a f4 3b			ld a, (.dmark+1)  
3be8 32 6f ee			ld (debug_mark+1),a  
3beb 3a f5 3b			ld a, (.dmark+2)  
3bee 32 70 ee			ld (debug_mark+2),a  
3bf1 18 03			jr .pastdmark  
3bf3 ..			.dmark: db "DOT"  
3bf6 f1			.pastdmark: pop af  
3bf7			endm  
# End of macro DMARK
3bf7						CALLMONITOR 
3bf7 cd 72 ee			call debug_vector  
3bfa				endm  
# End of macro CALLMONITOR
3bfa					endif 
3bfa 3e 00			ld a, 0 
3bfc 32 40 ea			ld (cli_mvdot), a 
3bff 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c01				 
3c01			 
3c01			.dotgo: 
3c01			 
3c01			; move up type to on stack for parserv5 
3c01					FORTH_DSP 
3c01 cd 11 1e			call macro_forth_dsp 
3c04				endm 
# End of macro FORTH_DSP
3c04				;FORTH_DSP_VALUE  
3c04			 
3c04			if DEBUG_FORTH_DOT 
3c04				DMARK "DOT" 
3c04 f5				push af  
3c05 3a 19 3c			ld a, (.dmark)  
3c08 32 6e ee			ld (debug_mark),a  
3c0b 3a 1a 3c			ld a, (.dmark+1)  
3c0e 32 6f ee			ld (debug_mark+1),a  
3c11 3a 1b 3c			ld a, (.dmark+2)  
3c14 32 70 ee			ld (debug_mark+2),a  
3c17 18 03			jr .pastdmark  
3c19 ..			.dmark: db "DOT"  
3c1c f1			.pastdmark: pop af  
3c1d			endm  
# End of macro DMARK
3c1d				CALLMONITOR 
3c1d cd 72 ee			call debug_vector  
3c20				endm  
# End of macro CALLMONITOR
3c20			endif	 
3c20			;		.print: 
3c20			 
3c20 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c21 23				inc hl   ; position to the actual value 
3c22 fe 01			cp DS_TYPE_STR 
3c24 20 06			jr nz, .dotnum1  
3c26			 
3c26			; display string 
3c26				FORTH_DSP_VALUE  
3c26 cd 34 1e			call macro_forth_dsp_value 
3c29				endm 
# End of macro FORTH_DSP_VALUE
3c29 eb				ex de,hl 
3c2a 18 49			jr .dotwrite 
3c2c			 
3c2c			.dotnum1: 
3c2c fe 02			cp DS_TYPE_INUM 
3c2e 20 44			jr nz, .dotflot 
3c30			 
3c30			 
3c30			; display number 
3c30			 
3c30			;	push hl 
3c30			;	call clear_display 
3c30			;	pop hl 
3c30			 
3c30 5e				ld e, (hl) 
3c31 23				inc hl 
3c32 56				ld d, (hl) 
3c33 21 c4 e2			ld hl, scratch 
3c36			if DEBUG_FORTH_DOT 
3c36				DMARK "DT1" 
3c36 f5				push af  
3c37 3a 4b 3c			ld a, (.dmark)  
3c3a 32 6e ee			ld (debug_mark),a  
3c3d 3a 4c 3c			ld a, (.dmark+1)  
3c40 32 6f ee			ld (debug_mark+1),a  
3c43 3a 4d 3c			ld a, (.dmark+2)  
3c46 32 70 ee			ld (debug_mark+2),a  
3c49 18 03			jr .pastdmark  
3c4b ..			.dmark: db "DT1"  
3c4e f1			.pastdmark: pop af  
3c4f			endm  
# End of macro DMARK
3c4f				CALLMONITOR 
3c4f cd 72 ee			call debug_vector  
3c52				endm  
# End of macro CALLMONITOR
3c52			endif	 
3c52			 
3c52 cd f4 11			call uitoa_16 
3c55 eb				ex de,hl 
3c56			 
3c56			if DEBUG_FORTH_DOT 
3c56				DMARK "DT2" 
3c56 f5				push af  
3c57 3a 6b 3c			ld a, (.dmark)  
3c5a 32 6e ee			ld (debug_mark),a  
3c5d 3a 6c 3c			ld a, (.dmark+1)  
3c60 32 6f ee			ld (debug_mark+1),a  
3c63 3a 6d 3c			ld a, (.dmark+2)  
3c66 32 70 ee			ld (debug_mark+2),a  
3c69 18 03			jr .pastdmark  
3c6b ..			.dmark: db "DT2"  
3c6e f1			.pastdmark: pop af  
3c6f			endm  
# End of macro DMARK
3c6f				CALLMONITOR 
3c6f cd 72 ee			call debug_vector  
3c72				endm  
# End of macro CALLMONITOR
3c72			endif	 
3c72			 
3c72			;	ld de, os_word_scratch 
3c72 18 01			jr .dotwrite 
3c74			 
3c74 00			.dotflot:   nop 
3c75			; TODO print floating point number 
3c75			 
3c75			.dotwrite:		 
3c75			 
3c75					; if c is set then set all '-' to spaces 
3c75					; need to also take into account .>  
3c75			 
3c75 3e 01				ld a, 1 
3c77 b9					cp c 
3c78 20 67				jr nz, .nodashswap 
3c7a			 
3c7a					; DE has the string to write, working with HL 
3c7a			 
3c7a 06 ff				ld b, 255 
3c7c d5					push de 
3c7d e1					pop hl 
3c7e			 
3c7e			if DEBUG_FORTH_DOT 
3c7e				DMARK "DT-" 
3c7e f5				push af  
3c7f 3a 93 3c			ld a, (.dmark)  
3c82 32 6e ee			ld (debug_mark),a  
3c85 3a 94 3c			ld a, (.dmark+1)  
3c88 32 6f ee			ld (debug_mark+1),a  
3c8b 3a 95 3c			ld a, (.dmark+2)  
3c8e 32 70 ee			ld (debug_mark+2),a  
3c91 18 03			jr .pastdmark  
3c93 ..			.dmark: db "DT-"  
3c96 f1			.pastdmark: pop af  
3c97			endm  
# End of macro DMARK
3c97				CALLMONITOR 
3c97 cd 72 ee			call debug_vector  
3c9a				endm  
# End of macro CALLMONITOR
3c9a			endif	 
3c9a 7e			.dashscan:	ld a, (hl) 
3c9b fe 00				cp 0 
3c9d 28 42				jr z, .nodashswap 
3c9f fe 2d				cp '-' 
3ca1 20 03				jr nz, .dashskip 
3ca3 3e 20				ld a, ' ' 
3ca5 77					ld (hl), a 
3ca6 23			.dashskip:	inc hl 
3ca7			if DEBUG_FORTH_DOT 
3ca7				DMARK "D-2" 
3ca7 f5				push af  
3ca8 3a bc 3c			ld a, (.dmark)  
3cab 32 6e ee			ld (debug_mark),a  
3cae 3a bd 3c			ld a, (.dmark+1)  
3cb1 32 6f ee			ld (debug_mark+1),a  
3cb4 3a be 3c			ld a, (.dmark+2)  
3cb7 32 70 ee			ld (debug_mark+2),a  
3cba 18 03			jr .pastdmark  
3cbc ..			.dmark: db "D-2"  
3cbf f1			.pastdmark: pop af  
3cc0			endm  
# End of macro DMARK
3cc0				CALLMONITOR 
3cc0 cd 72 ee			call debug_vector  
3cc3				endm  
# End of macro CALLMONITOR
3cc3			endif	 
3cc3 10 d5				djnz .dashscan 
3cc5			 
3cc5			if DEBUG_FORTH_DOT 
3cc5				DMARK "D-1" 
3cc5 f5				push af  
3cc6 3a da 3c			ld a, (.dmark)  
3cc9 32 6e ee			ld (debug_mark),a  
3ccc 3a db 3c			ld a, (.dmark+1)  
3ccf 32 6f ee			ld (debug_mark+1),a  
3cd2 3a dc 3c			ld a, (.dmark+2)  
3cd5 32 70 ee			ld (debug_mark+2),a  
3cd8 18 03			jr .pastdmark  
3cda ..			.dmark: db "D-1"  
3cdd f1			.pastdmark: pop af  
3cde			endm  
# End of macro DMARK
3cde				CALLMONITOR 
3cde cd 72 ee			call debug_vector  
3ce1				endm  
# End of macro CALLMONITOR
3ce1			endif	 
3ce1			 
3ce1			.nodashswap: 
3ce1			 
3ce1			if DEBUG_FORTH_DOT 
3ce1				DMARK "D-o" 
3ce1 f5				push af  
3ce2 3a f6 3c			ld a, (.dmark)  
3ce5 32 6e ee			ld (debug_mark),a  
3ce8 3a f7 3c			ld a, (.dmark+1)  
3ceb 32 6f ee			ld (debug_mark+1),a  
3cee 3a f8 3c			ld a, (.dmark+2)  
3cf1 32 70 ee			ld (debug_mark+2),a  
3cf4 18 03			jr .pastdmark  
3cf6 ..			.dmark: db "D-o"  
3cf9 f1			.pastdmark: pop af  
3cfa			endm  
# End of macro DMARK
3cfa				CALLMONITOR 
3cfa cd 72 ee			call debug_vector  
3cfd				endm  
# End of macro CALLMONITOR
3cfd			endif	 
3cfd			 
3cfd d5					push de   ; save string start in case we need to advance print 
3cfe			 
3cfe 3a 61 ea				ld a, (f_cursor_ptr) 
3d01 cd cd 0b				call str_at_display 
3d04 3a 3f ea				ld a,(cli_autodisplay) 
3d07 fe 00				cp 0 
3d09 28 03				jr z, .noupdate 
3d0b cd dd 0b						call update_display 
3d0e					.noupdate: 
3d0e			 
3d0e			 
3d0e					; see if we need to advance the print position 
3d0e			 
3d0e e1					pop hl   ; get back string 
3d0f			;		ex de,hl 
3d0f			 
3d0f 3a 40 ea				ld a, (cli_mvdot) 
3d12			if DEBUG_FORTH_DOT 
3d12			;		ld e,a 
3d12				DMARK "D>1" 
3d12 f5				push af  
3d13 3a 27 3d			ld a, (.dmark)  
3d16 32 6e ee			ld (debug_mark),a  
3d19 3a 28 3d			ld a, (.dmark+1)  
3d1c 32 6f ee			ld (debug_mark+1),a  
3d1f 3a 29 3d			ld a, (.dmark+2)  
3d22 32 70 ee			ld (debug_mark+2),a  
3d25 18 03			jr .pastdmark  
3d27 ..			.dmark: db "D>1"  
3d2a f1			.pastdmark: pop af  
3d2b			endm  
# End of macro DMARK
3d2b				CALLMONITOR 
3d2b cd 72 ee			call debug_vector  
3d2e				endm  
# End of macro CALLMONITOR
3d2e			endif	 
3d2e fe 00				cp 0 
3d30 28 44				jr z, .noadv 
3d32					; yes, lets advance the print position 
3d32 3e 00				ld a, 0 
3d34 cd 50 12				call strlent 
3d37			if DEBUG_FORTH_DOT 
3d37				DMARK "D-?" 
3d37 f5				push af  
3d38 3a 4c 3d			ld a, (.dmark)  
3d3b 32 6e ee			ld (debug_mark),a  
3d3e 3a 4d 3d			ld a, (.dmark+1)  
3d41 32 6f ee			ld (debug_mark+1),a  
3d44 3a 4e 3d			ld a, (.dmark+2)  
3d47 32 70 ee			ld (debug_mark+2),a  
3d4a 18 03			jr .pastdmark  
3d4c ..			.dmark: db "D-?"  
3d4f f1			.pastdmark: pop af  
3d50			endm  
# End of macro DMARK
3d50				CALLMONITOR 
3d50 cd 72 ee			call debug_vector  
3d53				endm  
# End of macro CALLMONITOR
3d53			endif	 
3d53 3a 61 ea				ld a, (f_cursor_ptr) 
3d56 85					add a,l 
3d57					;call addatohl 
3d57					;ld a, l 
3d57 32 61 ea				ld (f_cursor_ptr), a   ; save new pos 
3d5a			 
3d5a			if DEBUG_FORTH_DOT 
3d5a				DMARK "D->" 
3d5a f5				push af  
3d5b 3a 6f 3d			ld a, (.dmark)  
3d5e 32 6e ee			ld (debug_mark),a  
3d61 3a 70 3d			ld a, (.dmark+1)  
3d64 32 6f ee			ld (debug_mark+1),a  
3d67 3a 71 3d			ld a, (.dmark+2)  
3d6a 32 70 ee			ld (debug_mark+2),a  
3d6d 18 03			jr .pastdmark  
3d6f ..			.dmark: db "D->"  
3d72 f1			.pastdmark: pop af  
3d73			endm  
# End of macro DMARK
3d73				CALLMONITOR 
3d73 cd 72 ee			call debug_vector  
3d76				endm  
# End of macro CALLMONITOR
3d76			endif	 
3d76			 
3d76			.noadv:	 
3d76			 
3d76					if DEBUG_FORTH_DOT_WAIT 
3d76							call next_page_prompt 
3d76					endif	 
3d76			; TODO this pop off the stack causes a crash. i dont know why 
3d76			 
3d76			 
3d76			if DEBUG_FORTH_DOT 
3d76				DMARK "DTh" 
3d76 f5				push af  
3d77 3a 8b 3d			ld a, (.dmark)  
3d7a 32 6e ee			ld (debug_mark),a  
3d7d 3a 8c 3d			ld a, (.dmark+1)  
3d80 32 6f ee			ld (debug_mark+1),a  
3d83 3a 8d 3d			ld a, (.dmark+2)  
3d86 32 70 ee			ld (debug_mark+2),a  
3d89 18 03			jr .pastdmark  
3d8b ..			.dmark: db "DTh"  
3d8e f1			.pastdmark: pop af  
3d8f			endm  
# End of macro DMARK
3d8f				CALLMONITOR 
3d8f cd 72 ee			call debug_vector  
3d92				endm  
# End of macro CALLMONITOR
3d92			endif	 
3d92			 
3d92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d92 cd 03 1f			call macro_forth_dsp_pop 
3d95				endm 
# End of macro FORTH_DSP_POP
3d95			 
3d95			if DEBUG_FORTH_DOT 
3d95				DMARK "DTi" 
3d95 f5				push af  
3d96 3a aa 3d			ld a, (.dmark)  
3d99 32 6e ee			ld (debug_mark),a  
3d9c 3a ab 3d			ld a, (.dmark+1)  
3d9f 32 6f ee			ld (debug_mark+1),a  
3da2 3a ac 3d			ld a, (.dmark+2)  
3da5 32 70 ee			ld (debug_mark+2),a  
3da8 18 03			jr .pastdmark  
3daa ..			.dmark: db "DTi"  
3dad f1			.pastdmark: pop af  
3dae			endm  
# End of macro DMARK
3dae				CALLMONITOR 
3dae cd 72 ee			call debug_vector  
3db1				endm  
# End of macro CALLMONITOR
3db1			endif	 
3db1			 
3db1			 
3db1					NEXTW 
3db1 c3 01 20			jp macro_next 
3db4				endm 
# End of macro NEXTW
3db4			 
3db4			.CLS: 
3db4				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3db4 35				db WORD_SYS_CORE+33             
3db5 e1 3d			dw .DRAW            
3db7 04				db 3 + 1 
3db8 .. 00			db "CLS",0              
3dbc				endm 
# End of macro CWHEAD
3dbc			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3dbc					if DEBUG_FORTH_WORDS_KEY 
3dbc						DMARK "CLS" 
3dbc f5				push af  
3dbd 3a d1 3d			ld a, (.dmark)  
3dc0 32 6e ee			ld (debug_mark),a  
3dc3 3a d2 3d			ld a, (.dmark+1)  
3dc6 32 6f ee			ld (debug_mark+1),a  
3dc9 3a d3 3d			ld a, (.dmark+2)  
3dcc 32 70 ee			ld (debug_mark+2),a  
3dcf 18 03			jr .pastdmark  
3dd1 ..			.dmark: db "CLS"  
3dd4 f1			.pastdmark: pop af  
3dd5			endm  
# End of macro DMARK
3dd5						CALLMONITOR 
3dd5 cd 72 ee			call debug_vector  
3dd8				endm  
# End of macro CALLMONITOR
3dd8					endif 
3dd8 cd ba 0b				call clear_display 
3ddb c3 ef 3e				jp .home		; and home cursor 
3dde					NEXTW 
3dde c3 01 20			jp macro_next 
3de1				endm 
# End of macro NEXTW
3de1			 
3de1			.DRAW: 
3de1				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3de1 36				db WORD_SYS_CORE+34             
3de2 0c 3e			dw .DUMP            
3de4 05				db 4 + 1 
3de5 .. 00			db "DRAW",0              
3dea				endm 
# End of macro CWHEAD
3dea			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3dea					if DEBUG_FORTH_WORDS_KEY 
3dea						DMARK "DRW" 
3dea f5				push af  
3deb 3a ff 3d			ld a, (.dmark)  
3dee 32 6e ee			ld (debug_mark),a  
3df1 3a 00 3e			ld a, (.dmark+1)  
3df4 32 6f ee			ld (debug_mark+1),a  
3df7 3a 01 3e			ld a, (.dmark+2)  
3dfa 32 70 ee			ld (debug_mark+2),a  
3dfd 18 03			jr .pastdmark  
3dff ..			.dmark: db "DRW"  
3e02 f1			.pastdmark: pop af  
3e03			endm  
# End of macro DMARK
3e03						CALLMONITOR 
3e03 cd 72 ee			call debug_vector  
3e06				endm  
# End of macro CALLMONITOR
3e06					endif 
3e06 cd dd 0b				call update_display 
3e09					NEXTW 
3e09 c3 01 20			jp macro_next 
3e0c				endm 
# End of macro NEXTW
3e0c			 
3e0c			.DUMP: 
3e0c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e0c 37				db WORD_SYS_CORE+35             
3e0d 44 3e			dw .CDUMP            
3e0f 05				db 4 + 1 
3e10 .. 00			db "DUMP",0              
3e15				endm 
# End of macro CWHEAD
3e15			; | DUMP ( x -- ) With address x display dump   | DONE 
3e15			; TODO pop address to use off of the stack 
3e15					if DEBUG_FORTH_WORDS_KEY 
3e15						DMARK "DUM" 
3e15 f5				push af  
3e16 3a 2a 3e			ld a, (.dmark)  
3e19 32 6e ee			ld (debug_mark),a  
3e1c 3a 2b 3e			ld a, (.dmark+1)  
3e1f 32 6f ee			ld (debug_mark+1),a  
3e22 3a 2c 3e			ld a, (.dmark+2)  
3e25 32 70 ee			ld (debug_mark+2),a  
3e28 18 03			jr .pastdmark  
3e2a ..			.dmark: db "DUM"  
3e2d f1			.pastdmark: pop af  
3e2e			endm  
# End of macro DMARK
3e2e						CALLMONITOR 
3e2e cd 72 ee			call debug_vector  
3e31				endm  
# End of macro CALLMONITOR
3e31					endif 
3e31 cd ba 0b				call clear_display 
3e34			 
3e34					; get address 
3e34			 
3e34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e34 cd 4b 1e			call macro_dsp_valuehl 
3e37				endm 
# End of macro FORTH_DSP_VALUEHL
3e37				 
3e37					; save it for cdump 
3e37			 
3e37 22 e7 e5				ld (os_cur_ptr),hl 
3e3a			 
3e3a					; destroy value TOS 
3e3a			 
3e3a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3a cd 03 1f			call macro_forth_dsp_pop 
3e3d				endm 
# End of macro FORTH_DSP_POP
3e3d			 
3e3d cd d4 1a				call dumpcont	; skip old style of param parsing	 
3e40 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e41					NEXTW 
3e41 c3 01 20			jp macro_next 
3e44				endm 
# End of macro NEXTW
3e44			.CDUMP: 
3e44				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e44 38				db WORD_SYS_CORE+36             
3e45 74 3e			dw .DAT            
3e47 06				db 5 + 1 
3e48 .. 00			db "CDUMP",0              
3e4e				endm 
# End of macro CWHEAD
3e4e			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e4e					if DEBUG_FORTH_WORDS_KEY 
3e4e						DMARK "CDP" 
3e4e f5				push af  
3e4f 3a 63 3e			ld a, (.dmark)  
3e52 32 6e ee			ld (debug_mark),a  
3e55 3a 64 3e			ld a, (.dmark+1)  
3e58 32 6f ee			ld (debug_mark+1),a  
3e5b 3a 65 3e			ld a, (.dmark+2)  
3e5e 32 70 ee			ld (debug_mark+2),a  
3e61 18 03			jr .pastdmark  
3e63 ..			.dmark: db "CDP"  
3e66 f1			.pastdmark: pop af  
3e67			endm  
# End of macro DMARK
3e67						CALLMONITOR 
3e67 cd 72 ee			call debug_vector  
3e6a				endm  
# End of macro CALLMONITOR
3e6a					endif 
3e6a cd ba 0b				call clear_display 
3e6d cd d4 1a				call dumpcont	 
3e70 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e71					NEXTW 
3e71 c3 01 20			jp macro_next 
3e74				endm 
# End of macro NEXTW
3e74			 
3e74			 
3e74			 
3e74			 
3e74			.DAT: 
3e74				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e74 3d				db WORD_SYS_CORE+41             
3e75 ca 3e			dw .HOME            
3e77 03				db 2 + 1 
3e78 .. 00			db "AT",0              
3e7b				endm 
# End of macro CWHEAD
3e7b			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e7b					if DEBUG_FORTH_WORDS_KEY 
3e7b						DMARK "AT." 
3e7b f5				push af  
3e7c 3a 90 3e			ld a, (.dmark)  
3e7f 32 6e ee			ld (debug_mark),a  
3e82 3a 91 3e			ld a, (.dmark+1)  
3e85 32 6f ee			ld (debug_mark+1),a  
3e88 3a 92 3e			ld a, (.dmark+2)  
3e8b 32 70 ee			ld (debug_mark+2),a  
3e8e 18 03			jr .pastdmark  
3e90 ..			.dmark: db "AT."  
3e93 f1			.pastdmark: pop af  
3e94			endm  
# End of macro DMARK
3e94						CALLMONITOR 
3e94 cd 72 ee			call debug_vector  
3e97				endm  
# End of macro CALLMONITOR
3e97					endif 
3e97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e97 cd 4b 1e			call macro_dsp_valuehl 
3e9a				endm 
# End of macro FORTH_DSP_VALUEHL
3e9a			 
3e9a			 
3e9a					; TODO save cursor row 
3e9a 7d					ld a,l 
3e9b fe 02				cp 2 
3e9d 20 04				jr nz, .crow3 
3e9f 3e 28				ld a, display_row_2 
3ea1 18 12				jr .ccol1 
3ea3 fe 03		.crow3:		cp 3 
3ea5 20 04				jr nz, .crow4 
3ea7 3e 50				ld a, display_row_3 
3ea9 18 0a				jr .ccol1 
3eab fe 04		.crow4:		cp 4 
3ead 20 04				jr nz, .crow1 
3eaf 3e 78				ld a, display_row_4 
3eb1 18 02				jr .ccol1 
3eb3 3e 00		.crow1:		ld a,display_row_1 
3eb5 f5			.ccol1:		push af			; got row offset 
3eb6 6f					ld l,a 
3eb7 26 00				ld h,0 
3eb9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb9 cd 03 1f			call macro_forth_dsp_pop 
3ebc				endm 
# End of macro FORTH_DSP_POP
3ebc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ebc cd 4b 1e			call macro_dsp_valuehl 
3ebf				endm 
# End of macro FORTH_DSP_VALUEHL
3ebf					; TODO save cursor col 
3ebf f1					pop af 
3ec0 85					add l		; add col offset 
3ec1 32 61 ea				ld (f_cursor_ptr), a 
3ec4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec4 cd 03 1f			call macro_forth_dsp_pop 
3ec7				endm 
# End of macro FORTH_DSP_POP
3ec7			 
3ec7					; calculate  
3ec7			 
3ec7					NEXTW 
3ec7 c3 01 20			jp macro_next 
3eca				endm 
# End of macro NEXTW
3eca			 
3eca			 
3eca			.HOME: 
3eca				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3eca 41				db WORD_SYS_CORE+45             
3ecb f7 3e			dw .SPACE            
3ecd 05				db 4 + 1 
3ece .. 00			db "HOME",0              
3ed3				endm 
# End of macro CWHEAD
3ed3			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3ed3					if DEBUG_FORTH_WORDS_KEY 
3ed3						DMARK "HOM" 
3ed3 f5				push af  
3ed4 3a e8 3e			ld a, (.dmark)  
3ed7 32 6e ee			ld (debug_mark),a  
3eda 3a e9 3e			ld a, (.dmark+1)  
3edd 32 6f ee			ld (debug_mark+1),a  
3ee0 3a ea 3e			ld a, (.dmark+2)  
3ee3 32 70 ee			ld (debug_mark+2),a  
3ee6 18 03			jr .pastdmark  
3ee8 ..			.dmark: db "HOM"  
3eeb f1			.pastdmark: pop af  
3eec			endm  
# End of macro DMARK
3eec						CALLMONITOR 
3eec cd 72 ee			call debug_vector  
3eef				endm  
# End of macro CALLMONITOR
3eef					endif 
3eef 3e 00		.home:		ld a, 0		; and home cursor 
3ef1 32 61 ea				ld (f_cursor_ptr), a 
3ef4					NEXTW 
3ef4 c3 01 20			jp macro_next 
3ef7				endm 
# End of macro NEXTW
3ef7			 
3ef7			 
3ef7			.SPACE: 
3ef7				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3ef7 46				db WORD_SYS_CORE+50             
3ef8 2d 3f			dw .SPACES            
3efa 03				db 2 + 1 
3efb .. 00			db "BL",0              
3efe				endm 
# End of macro CWHEAD
3efe			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3efe					if DEBUG_FORTH_WORDS_KEY 
3efe						DMARK "BL." 
3efe f5				push af  
3eff 3a 13 3f			ld a, (.dmark)  
3f02 32 6e ee			ld (debug_mark),a  
3f05 3a 14 3f			ld a, (.dmark+1)  
3f08 32 6f ee			ld (debug_mark+1),a  
3f0b 3a 15 3f			ld a, (.dmark+2)  
3f0e 32 70 ee			ld (debug_mark+2),a  
3f11 18 03			jr .pastdmark  
3f13 ..			.dmark: db "BL."  
3f16 f1			.pastdmark: pop af  
3f17			endm  
# End of macro DMARK
3f17						CALLMONITOR 
3f17 cd 72 ee			call debug_vector  
3f1a				endm  
# End of macro CALLMONITOR
3f1a					endif 
3f1a 3e 20				ld a, " " 
3f1c 32 c4 e2				ld (scratch),a 
3f1f 3e 00				ld a, 0 
3f21 32 c5 e2				ld (scratch+1),a 
3f24 21 c4 e2				ld hl, scratch 
3f27 cd c2 1c				call forth_push_str 
3f2a					 
3f2a				       NEXTW 
3f2a c3 01 20			jp macro_next 
3f2d				endm 
# End of macro NEXTW
3f2d			 
3f2d			;.blstr: db " ", 0 
3f2d			 
3f2d			.SPACES: 
3f2d				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f2d 47				db WORD_SYS_CORE+51             
3f2e c8 3f			dw .SCROLL            
3f30 07				db 6 + 1 
3f31 .. 00			db "SPACES",0              
3f38				endm 
# End of macro CWHEAD
3f38			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f38					if DEBUG_FORTH_WORDS_KEY 
3f38						DMARK "SPS" 
3f38 f5				push af  
3f39 3a 4d 3f			ld a, (.dmark)  
3f3c 32 6e ee			ld (debug_mark),a  
3f3f 3a 4e 3f			ld a, (.dmark+1)  
3f42 32 6f ee			ld (debug_mark+1),a  
3f45 3a 4f 3f			ld a, (.dmark+2)  
3f48 32 70 ee			ld (debug_mark+2),a  
3f4b 18 03			jr .pastdmark  
3f4d ..			.dmark: db "SPS"  
3f50 f1			.pastdmark: pop af  
3f51			endm  
# End of macro DMARK
3f51						CALLMONITOR 
3f51 cd 72 ee			call debug_vector  
3f54				endm  
# End of macro CALLMONITOR
3f54					endif 
3f54			 
3f54			 
3f54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f54 cd 4b 1e			call macro_dsp_valuehl 
3f57				endm 
# End of macro FORTH_DSP_VALUEHL
3f57			 
3f57 e5					push hl    ; u 
3f58					if DEBUG_FORTH_WORDS 
3f58						DMARK "SPA" 
3f58 f5				push af  
3f59 3a 6d 3f			ld a, (.dmark)  
3f5c 32 6e ee			ld (debug_mark),a  
3f5f 3a 6e 3f			ld a, (.dmark+1)  
3f62 32 6f ee			ld (debug_mark+1),a  
3f65 3a 6f 3f			ld a, (.dmark+2)  
3f68 32 70 ee			ld (debug_mark+2),a  
3f6b 18 03			jr .pastdmark  
3f6d ..			.dmark: db "SPA"  
3f70 f1			.pastdmark: pop af  
3f71			endm  
# End of macro DMARK
3f71						CALLMONITOR 
3f71 cd 72 ee			call debug_vector  
3f74				endm  
# End of macro CALLMONITOR
3f74					endif 
3f74			 
3f74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f74 cd 03 1f			call macro_forth_dsp_pop 
3f77				endm 
# End of macro FORTH_DSP_POP
3f77 e1					pop hl 
3f78 0e 00				ld c, 0 
3f7a 45					ld b, l 
3f7b 21 c4 e2				ld hl, scratch  
3f7e			 
3f7e					if DEBUG_FORTH_WORDS 
3f7e						DMARK "SP2" 
3f7e f5				push af  
3f7f 3a 93 3f			ld a, (.dmark)  
3f82 32 6e ee			ld (debug_mark),a  
3f85 3a 94 3f			ld a, (.dmark+1)  
3f88 32 6f ee			ld (debug_mark+1),a  
3f8b 3a 95 3f			ld a, (.dmark+2)  
3f8e 32 70 ee			ld (debug_mark+2),a  
3f91 18 03			jr .pastdmark  
3f93 ..			.dmark: db "SP2"  
3f96 f1			.pastdmark: pop af  
3f97			endm  
# End of macro DMARK
3f97						CALLMONITOR 
3f97 cd 72 ee			call debug_vector  
3f9a				endm  
# End of macro CALLMONITOR
3f9a					endif 
3f9a 3e 20				ld a, ' ' 
3f9c			.spaces1:	 
3f9c 77					ld (hl),a 
3f9d 23					inc hl 
3f9e					 
3f9e 10 fc				djnz .spaces1 
3fa0 3e 00				ld a,0 
3fa2 77					ld (hl),a 
3fa3 21 c4 e2				ld hl, scratch 
3fa6					if DEBUG_FORTH_WORDS 
3fa6						DMARK "SP3" 
3fa6 f5				push af  
3fa7 3a bb 3f			ld a, (.dmark)  
3faa 32 6e ee			ld (debug_mark),a  
3fad 3a bc 3f			ld a, (.dmark+1)  
3fb0 32 6f ee			ld (debug_mark+1),a  
3fb3 3a bd 3f			ld a, (.dmark+2)  
3fb6 32 70 ee			ld (debug_mark+2),a  
3fb9 18 03			jr .pastdmark  
3fbb ..			.dmark: db "SP3"  
3fbe f1			.pastdmark: pop af  
3fbf			endm  
# End of macro DMARK
3fbf						CALLMONITOR 
3fbf cd 72 ee			call debug_vector  
3fc2				endm  
# End of macro CALLMONITOR
3fc2					endif 
3fc2 cd c2 1c				call forth_push_str 
3fc5			 
3fc5				       NEXTW 
3fc5 c3 01 20			jp macro_next 
3fc8				endm 
# End of macro NEXTW
3fc8			 
3fc8			 
3fc8			 
3fc8			.SCROLL: 
3fc8				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fc8 53				db WORD_SYS_CORE+63             
3fc9 f5 3f			dw .SCROLLD            
3fcb 07				db 6 + 1 
3fcc .. 00			db "SCROLL",0              
3fd3				endm 
# End of macro CWHEAD
3fd3			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3fd3					if DEBUG_FORTH_WORDS_KEY 
3fd3						DMARK "SCR" 
3fd3 f5				push af  
3fd4 3a e8 3f			ld a, (.dmark)  
3fd7 32 6e ee			ld (debug_mark),a  
3fda 3a e9 3f			ld a, (.dmark+1)  
3fdd 32 6f ee			ld (debug_mark+1),a  
3fe0 3a ea 3f			ld a, (.dmark+2)  
3fe3 32 70 ee			ld (debug_mark+2),a  
3fe6 18 03			jr .pastdmark  
3fe8 ..			.dmark: db "SCR"  
3feb f1			.pastdmark: pop af  
3fec			endm  
# End of macro DMARK
3fec						CALLMONITOR 
3fec cd 72 ee			call debug_vector  
3fef				endm  
# End of macro CALLMONITOR
3fef					endif 
3fef			 
3fef cd 7c 0b			call scroll_up 
3ff2			;	call update_display 
3ff2			 
3ff2					NEXTW 
3ff2 c3 01 20			jp macro_next 
3ff5				endm 
# End of macro NEXTW
3ff5			 
3ff5			 
3ff5			 
3ff5			;		; get dir 
3ff5			; 
3ff5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff5			; 
3ff5			;		push hl 
3ff5			; 
3ff5			;		; destroy value TOS 
3ff5			; 
3ff5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ff5			; 
3ff5			;		; get count 
3ff5			; 
3ff5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff5			; 
3ff5			;		push hl 
3ff5			; 
3ff5			;		; destroy value TOS 
3ff5			; 
3ff5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ff5			; 
3ff5			;		; one value on hl get other one back 
3ff5			; 
3ff5			;		pop bc    ; count 
3ff5			; 
3ff5			;		pop de   ; dir 
3ff5			; 
3ff5			; 
3ff5			;		ld b, c 
3ff5			; 
3ff5			;.scrolldir:     push bc 
3ff5			;		push de 
3ff5			; 
3ff5			;		ld a, 0 
3ff5			;		cp e 
3ff5			;		jr z, .scrollup  
3ff5			;		call scroll_down 
3ff5			;		jr .scrollnext 
3ff5			;.scrollup:	call scroll_up 
3ff5			; 
3ff5			;		 
3ff5			;.scrollnext: 
3ff5			;		pop de 
3ff5			;		pop bc 
3ff5			;		djnz .scrolldir 
3ff5			; 
3ff5			; 
3ff5			; 
3ff5			; 
3ff5			; 
3ff5			;		NEXTW 
3ff5			 
3ff5			.SCROLLD: 
3ff5				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ff5 53				db WORD_SYS_CORE+63             
3ff6 23 40			dw .ATQ            
3ff8 08				db 7 + 1 
3ff9 .. 00			db "SCROLLD",0              
4001				endm 
# End of macro CWHEAD
4001			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4001					if DEBUG_FORTH_WORDS_KEY 
4001						DMARK "SCD" 
4001 f5				push af  
4002 3a 16 40			ld a, (.dmark)  
4005 32 6e ee			ld (debug_mark),a  
4008 3a 17 40			ld a, (.dmark+1)  
400b 32 6f ee			ld (debug_mark+1),a  
400e 3a 18 40			ld a, (.dmark+2)  
4011 32 70 ee			ld (debug_mark+2),a  
4014 18 03			jr .pastdmark  
4016 ..			.dmark: db "SCD"  
4019 f1			.pastdmark: pop af  
401a			endm  
# End of macro DMARK
401a						CALLMONITOR 
401a cd 72 ee			call debug_vector  
401d				endm  
# End of macro CALLMONITOR
401d					endif 
401d			 
401d cd a0 0b			call scroll_down 
4020			;	call update_display 
4020			 
4020					NEXTW 
4020 c3 01 20			jp macro_next 
4023				endm 
# End of macro NEXTW
4023			 
4023			 
4023			.ATQ: 
4023				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4023 62				db WORD_SYS_CORE+78             
4024 81 40			dw .AUTODSP            
4026 04				db 3 + 1 
4027 .. 00			db "AT@",0              
402b				endm 
# End of macro CWHEAD
402b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
402b					if DEBUG_FORTH_WORDS_KEY 
402b						DMARK "ATA" 
402b f5				push af  
402c 3a 40 40			ld a, (.dmark)  
402f 32 6e ee			ld (debug_mark),a  
4032 3a 41 40			ld a, (.dmark+1)  
4035 32 6f ee			ld (debug_mark+1),a  
4038 3a 42 40			ld a, (.dmark+2)  
403b 32 70 ee			ld (debug_mark+2),a  
403e 18 03			jr .pastdmark  
4040 ..			.dmark: db "ATA"  
4043 f1			.pastdmark: pop af  
4044			endm  
# End of macro DMARK
4044						CALLMONITOR 
4044 cd 72 ee			call debug_vector  
4047				endm  
# End of macro CALLMONITOR
4047					endif 
4047			 
4047			 
4047					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4047 cd 4b 1e			call macro_dsp_valuehl 
404a				endm 
# End of macro FORTH_DSP_VALUEHL
404a			 
404a					; TODO save cursor row 
404a 7d					ld a,l 
404b fe 02				cp 2 
404d 20 04				jr nz, .crow3aq 
404f 3e 28				ld a, display_row_2 
4051 18 12				jr .ccol1aq 
4053 fe 03		.crow3aq:		cp 3 
4055 20 04				jr nz, .crow4aq 
4057 3e 50				ld a, display_row_3 
4059 18 0a				jr .ccol1aq 
405b fe 04		.crow4aq:		cp 4 
405d 20 04				jr nz, .crow1aq 
405f 3e 78				ld a, display_row_4 
4061 18 02				jr .ccol1aq 
4063 3e 00		.crow1aq:		ld a,display_row_1 
4065 f5			.ccol1aq:		push af			; got row offset 
4066 6f					ld l,a 
4067 26 00				ld h,0 
4069					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4069 cd 03 1f			call macro_forth_dsp_pop 
406c				endm 
# End of macro FORTH_DSP_POP
406c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
406c cd 4b 1e			call macro_dsp_valuehl 
406f				endm 
# End of macro FORTH_DSP_VALUEHL
406f					; TODO save cursor col 
406f f1					pop af 
4070 85					add l		; add col offset 
4071			 
4071					; add current frame buffer address 
4071 2a cf eb				ld hl, (display_fb_active) 
4074 cd e7 0d				call addatohl 
4077			 
4077			 
4077			 
4077			 
4077					; get char frame buffer location offset in hl 
4077			 
4077 7e					ld a,(hl) 
4078 26 00				ld h, 0 
407a 6f					ld l, a 
407b			 
407b cd 54 1c				call forth_push_numhl 
407e			 
407e			 
407e					NEXTW 
407e c3 01 20			jp macro_next 
4081				endm 
# End of macro NEXTW
4081			 
4081			.AUTODSP: 
4081				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4081 63				db WORD_SYS_CORE+79             
4082 97 40			dw .MENU            
4084 05				db 4 + 1 
4085 .. 00			db "ADSP",0              
408a				endm 
# End of macro CWHEAD
408a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
408a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
408a			 
408a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
408a cd 4b 1e			call macro_dsp_valuehl 
408d				endm 
# End of macro FORTH_DSP_VALUEHL
408d			 
408d			;		push hl 
408d			 
408d					; destroy value TOS 
408d			 
408d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
408d cd 03 1f			call macro_forth_dsp_pop 
4090				endm 
# End of macro FORTH_DSP_POP
4090			 
4090			;		pop hl 
4090			 
4090 7d					ld a,l 
4091 32 3f ea				ld (cli_autodisplay), a 
4094				       NEXTW 
4094 c3 01 20			jp macro_next 
4097				endm 
# End of macro NEXTW
4097			 
4097			.MENU: 
4097				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4097 70				db WORD_SYS_CORE+92             
4098 40 41			dw .ENDDISPLAY            
409a 05				db 4 + 1 
409b .. 00			db "MENU",0              
40a0				endm 
# End of macro CWHEAD
40a0			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
40a0			 
40a0			;		; get number of items on the stack 
40a0			; 
40a0				 
40a0					FORTH_DSP_VALUEHL 
40a0 cd 4b 1e			call macro_dsp_valuehl 
40a3				endm 
# End of macro FORTH_DSP_VALUEHL
40a3				 
40a3					if DEBUG_FORTH_WORDS_KEY 
40a3						DMARK "MNU" 
40a3 f5				push af  
40a4 3a b8 40			ld a, (.dmark)  
40a7 32 6e ee			ld (debug_mark),a  
40aa 3a b9 40			ld a, (.dmark+1)  
40ad 32 6f ee			ld (debug_mark+1),a  
40b0 3a ba 40			ld a, (.dmark+2)  
40b3 32 70 ee			ld (debug_mark+2),a  
40b6 18 03			jr .pastdmark  
40b8 ..			.dmark: db "MNU"  
40bb f1			.pastdmark: pop af  
40bc			endm  
# End of macro DMARK
40bc						CALLMONITOR 
40bc cd 72 ee			call debug_vector  
40bf				endm  
# End of macro CALLMONITOR
40bf					endif 
40bf			 
40bf 45					ld b, l	 
40c0 05					dec b 
40c1			 
40c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c1 cd 03 1f			call macro_forth_dsp_pop 
40c4				endm 
# End of macro FORTH_DSP_POP
40c4			 
40c4			 
40c4					; go directly through the stack to pluck out the string pointers and build an array 
40c4			 
40c4			;		FORTH_DSP 
40c4			 
40c4					; hl contains top most stack item 
40c4				 
40c4 11 c4 e2				ld de, scratch 
40c7			 
40c7			.mbuild: 
40c7			 
40c7					FORTH_DSP_VALUEHL 
40c7 cd 4b 1e			call macro_dsp_valuehl 
40ca				endm 
# End of macro FORTH_DSP_VALUEHL
40ca			 
40ca					if DEBUG_FORTH_WORDS 
40ca						DMARK "MN3" 
40ca f5				push af  
40cb 3a df 40			ld a, (.dmark)  
40ce 32 6e ee			ld (debug_mark),a  
40d1 3a e0 40			ld a, (.dmark+1)  
40d4 32 6f ee			ld (debug_mark+1),a  
40d7 3a e1 40			ld a, (.dmark+2)  
40da 32 70 ee			ld (debug_mark+2),a  
40dd 18 03			jr .pastdmark  
40df ..			.dmark: db "MN3"  
40e2 f1			.pastdmark: pop af  
40e3			endm  
# End of macro DMARK
40e3						CALLMONITOR 
40e3 cd 72 ee			call debug_vector  
40e6				endm  
# End of macro CALLMONITOR
40e6					endif 
40e6 eb					ex de, hl 
40e7 73					ld (hl), e 
40e8 23					inc hl 
40e9 72					ld (hl), d 
40ea 23					inc hl 
40eb eb					ex de, hl 
40ec			 
40ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ec cd 03 1f			call macro_forth_dsp_pop 
40ef				endm 
# End of macro FORTH_DSP_POP
40ef			 
40ef 10 d6				djnz .mbuild 
40f1			 
40f1					; done add term 
40f1			 
40f1 eb					ex de, hl 
40f2 36 00				ld (hl), 0 
40f4 23					inc hl 
40f5 36 00				ld (hl), 0 
40f7			 
40f7				 
40f7					 
40f7 21 c4 e2				ld hl, scratch 
40fa			 
40fa					if DEBUG_FORTH_WORDS 
40fa						DMARK "MNx" 
40fa f5				push af  
40fb 3a 0f 41			ld a, (.dmark)  
40fe 32 6e ee			ld (debug_mark),a  
4101 3a 10 41			ld a, (.dmark+1)  
4104 32 6f ee			ld (debug_mark+1),a  
4107 3a 11 41			ld a, (.dmark+2)  
410a 32 70 ee			ld (debug_mark+2),a  
410d 18 03			jr .pastdmark  
410f ..			.dmark: db "MNx"  
4112 f1			.pastdmark: pop af  
4113			endm  
# End of macro DMARK
4113						CALLMONITOR 
4113 cd 72 ee			call debug_vector  
4116				endm  
# End of macro CALLMONITOR
4116					endif 
4116			 
4116			 
4116			 
4116 3e 00				ld a, 0 
4118 cd eb 0b				call menu 
411b			 
411b			 
411b 6f					ld l, a 
411c 26 00				ld h, 0 
411e			 
411e					if DEBUG_FORTH_WORDS 
411e						DMARK "MNr" 
411e f5				push af  
411f 3a 33 41			ld a, (.dmark)  
4122 32 6e ee			ld (debug_mark),a  
4125 3a 34 41			ld a, (.dmark+1)  
4128 32 6f ee			ld (debug_mark+1),a  
412b 3a 35 41			ld a, (.dmark+2)  
412e 32 70 ee			ld (debug_mark+2),a  
4131 18 03			jr .pastdmark  
4133 ..			.dmark: db "MNr"  
4136 f1			.pastdmark: pop af  
4137			endm  
# End of macro DMARK
4137						CALLMONITOR 
4137 cd 72 ee			call debug_vector  
413a				endm  
# End of macro CALLMONITOR
413a					endif 
413a			 
413a cd 54 1c				call forth_push_numhl 
413d			 
413d			 
413d			 
413d			 
413d				       NEXTW 
413d c3 01 20			jp macro_next 
4140				endm 
# End of macro NEXTW
4140			 
4140			 
4140			.ENDDISPLAY: 
4140			 
4140			; eof 
# End of file forth_words_display.asm
4140			include "forth_words_str.asm" 
4140			 
4140			; | ## String Words 
4140			 
4140			.PTR:   
4140			 
4140				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4140 48				db WORD_SYS_CORE+52             
4141 6d 41			dw .STYPE            
4143 04				db 3 + 1 
4144 .. 00			db "PTR",0              
4148				endm 
# End of macro CWHEAD
4148			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4148			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4148			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4148			 
4148					if DEBUG_FORTH_WORDS_KEY 
4148						DMARK "PTR" 
4148 f5				push af  
4149 3a 5d 41			ld a, (.dmark)  
414c 32 6e ee			ld (debug_mark),a  
414f 3a 5e 41			ld a, (.dmark+1)  
4152 32 6f ee			ld (debug_mark+1),a  
4155 3a 5f 41			ld a, (.dmark+2)  
4158 32 70 ee			ld (debug_mark+2),a  
415b 18 03			jr .pastdmark  
415d ..			.dmark: db "PTR"  
4160 f1			.pastdmark: pop af  
4161			endm  
# End of macro DMARK
4161						CALLMONITOR 
4161 cd 72 ee			call debug_vector  
4164				endm  
# End of macro CALLMONITOR
4164					endif 
4164					FORTH_DSP_VALUEHL 
4164 cd 4b 1e			call macro_dsp_valuehl 
4167				endm 
# End of macro FORTH_DSP_VALUEHL
4167 cd 54 1c				call forth_push_numhl 
416a			 
416a			 
416a					NEXTW 
416a c3 01 20			jp macro_next 
416d				endm 
# End of macro NEXTW
416d			.STYPE: 
416d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
416d 48				db WORD_SYS_CORE+52             
416e bc 41			dw .UPPER            
4170 06				db 5 + 1 
4171 .. 00			db "STYPE",0              
4177				endm 
# End of macro CWHEAD
4177			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4177					if DEBUG_FORTH_WORDS_KEY 
4177						DMARK "STY" 
4177 f5				push af  
4178 3a 8c 41			ld a, (.dmark)  
417b 32 6e ee			ld (debug_mark),a  
417e 3a 8d 41			ld a, (.dmark+1)  
4181 32 6f ee			ld (debug_mark+1),a  
4184 3a 8e 41			ld a, (.dmark+2)  
4187 32 70 ee			ld (debug_mark+2),a  
418a 18 03			jr .pastdmark  
418c ..			.dmark: db "STY"  
418f f1			.pastdmark: pop af  
4190			endm  
# End of macro DMARK
4190						CALLMONITOR 
4190 cd 72 ee			call debug_vector  
4193				endm  
# End of macro CALLMONITOR
4193					endif 
4193					FORTH_DSP 
4193 cd 11 1e			call macro_forth_dsp 
4196				endm 
# End of macro FORTH_DSP
4196					;v5 FORTH_DSP_VALUE 
4196			 
4196 7e					ld a, (hl) 
4197			 
4197 f5					push af 
4198			 
4198			; Dont destroy TOS		FORTH_DSP_POP 
4198			 
4198 f1					pop af 
4199			 
4199 fe 01				cp DS_TYPE_STR 
419b 28 09				jr z, .typestr 
419d			 
419d fe 02				cp DS_TYPE_INUM 
419f 28 0a				jr z, .typeinum 
41a1			 
41a1 21 ba 41				ld hl, .tna 
41a4 18 0a				jr .tpush 
41a6			 
41a6 21 b6 41		.typestr:	ld hl, .tstr 
41a9 18 05				jr .tpush 
41ab 21 b8 41		.typeinum:	ld hl, .tinum 
41ae 18 00				jr .tpush 
41b0			 
41b0			.tpush: 
41b0			 
41b0 cd c2 1c				call forth_push_str 
41b3			 
41b3					NEXTW 
41b3 c3 01 20			jp macro_next 
41b6				endm 
# End of macro NEXTW
41b6 .. 00		.tstr:	db "s",0 
41b8 .. 00		.tinum:  db "i",0 
41ba .. 00		.tna:   db "?", 0 
41bc			 
41bc			 
41bc			.UPPER: 
41bc				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41bc 48				db WORD_SYS_CORE+52             
41bd f7 41			dw .LOWER            
41bf 06				db 5 + 1 
41c0 .. 00			db "UPPER",0              
41c6				endm 
# End of macro CWHEAD
41c6			; | UPPER ( s -- s ) Upper case string s  | DONE 
41c6					if DEBUG_FORTH_WORDS_KEY 
41c6						DMARK "UPR" 
41c6 f5				push af  
41c7 3a db 41			ld a, (.dmark)  
41ca 32 6e ee			ld (debug_mark),a  
41cd 3a dc 41			ld a, (.dmark+1)  
41d0 32 6f ee			ld (debug_mark+1),a  
41d3 3a dd 41			ld a, (.dmark+2)  
41d6 32 70 ee			ld (debug_mark+2),a  
41d9 18 03			jr .pastdmark  
41db ..			.dmark: db "UPR"  
41de f1			.pastdmark: pop af  
41df			endm  
# End of macro DMARK
41df						CALLMONITOR 
41df cd 72 ee			call debug_vector  
41e2				endm  
# End of macro CALLMONITOR
41e2					endif 
41e2			 
41e2					FORTH_DSP 
41e2 cd 11 1e			call macro_forth_dsp 
41e5				endm 
# End of macro FORTH_DSP
41e5					 
41e5			; TODO check is string type 
41e5			 
41e5					FORTH_DSP_VALUEHL 
41e5 cd 4b 1e			call macro_dsp_valuehl 
41e8				endm 
# End of macro FORTH_DSP_VALUEHL
41e8			; get pointer to string in hl 
41e8			 
41e8 7e			.toup:		ld a, (hl) 
41e9 fe 00				cp 0 
41eb 28 07				jr z, .toupdone 
41ed			 
41ed cd 54 11				call to_upper 
41f0			 
41f0 77					ld (hl), a 
41f1 23					inc hl 
41f2 18 f4				jr .toup 
41f4			 
41f4					 
41f4			 
41f4			 
41f4			; for each char convert to upper 
41f4					 
41f4			.toupdone: 
41f4			 
41f4			 
41f4					NEXTW 
41f4 c3 01 20			jp macro_next 
41f7				endm 
# End of macro NEXTW
41f7			.LOWER: 
41f7				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
41f7 48				db WORD_SYS_CORE+52             
41f8 32 42			dw .TCASE            
41fa 06				db 5 + 1 
41fb .. 00			db "LOWER",0              
4201				endm 
# End of macro CWHEAD
4201			; | LOWER ( s -- s ) Lower case string s  | DONE 
4201					if DEBUG_FORTH_WORDS_KEY 
4201						DMARK "LWR" 
4201 f5				push af  
4202 3a 16 42			ld a, (.dmark)  
4205 32 6e ee			ld (debug_mark),a  
4208 3a 17 42			ld a, (.dmark+1)  
420b 32 6f ee			ld (debug_mark+1),a  
420e 3a 18 42			ld a, (.dmark+2)  
4211 32 70 ee			ld (debug_mark+2),a  
4214 18 03			jr .pastdmark  
4216 ..			.dmark: db "LWR"  
4219 f1			.pastdmark: pop af  
421a			endm  
# End of macro DMARK
421a						CALLMONITOR 
421a cd 72 ee			call debug_vector  
421d				endm  
# End of macro CALLMONITOR
421d					endif 
421d			 
421d					FORTH_DSP 
421d cd 11 1e			call macro_forth_dsp 
4220				endm 
# End of macro FORTH_DSP
4220					 
4220			; TODO check is string type 
4220			 
4220					FORTH_DSP_VALUEHL 
4220 cd 4b 1e			call macro_dsp_valuehl 
4223				endm 
# End of macro FORTH_DSP_VALUEHL
4223			; get pointer to string in hl 
4223			 
4223 7e			.tolow:		ld a, (hl) 
4224 fe 00				cp 0 
4226 28 07				jr z, .tolowdone 
4228			 
4228 cd 5d 11				call to_lower 
422b			 
422b 77					ld (hl), a 
422c 23					inc hl 
422d 18 f4				jr .tolow 
422f			 
422f					 
422f			 
422f			 
422f			; for each char convert to low 
422f					 
422f			.tolowdone: 
422f					NEXTW 
422f c3 01 20			jp macro_next 
4232				endm 
# End of macro NEXTW
4232			.TCASE: 
4232				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4232 48				db WORD_SYS_CORE+52             
4233 68 43			dw .SUBSTR            
4235 06				db 5 + 1 
4236 .. 00			db "TCASE",0              
423c				endm 
# End of macro CWHEAD
423c			; | TCASE ( s -- s ) Title case string s  | DONE 
423c					if DEBUG_FORTH_WORDS_KEY 
423c						DMARK "TCS" 
423c f5				push af  
423d 3a 51 42			ld a, (.dmark)  
4240 32 6e ee			ld (debug_mark),a  
4243 3a 52 42			ld a, (.dmark+1)  
4246 32 6f ee			ld (debug_mark+1),a  
4249 3a 53 42			ld a, (.dmark+2)  
424c 32 70 ee			ld (debug_mark+2),a  
424f 18 03			jr .pastdmark  
4251 ..			.dmark: db "TCS"  
4254 f1			.pastdmark: pop af  
4255			endm  
# End of macro DMARK
4255						CALLMONITOR 
4255 cd 72 ee			call debug_vector  
4258				endm  
# End of macro CALLMONITOR
4258					endif 
4258			 
4258					FORTH_DSP 
4258 cd 11 1e			call macro_forth_dsp 
425b				endm 
# End of macro FORTH_DSP
425b					 
425b			; TODO check is string type 
425b			 
425b					FORTH_DSP_VALUEHL 
425b cd 4b 1e			call macro_dsp_valuehl 
425e				endm 
# End of macro FORTH_DSP_VALUEHL
425e			; get pointer to string in hl 
425e			 
425e					if DEBUG_FORTH_WORDS 
425e						DMARK "TC1" 
425e f5				push af  
425f 3a 73 42			ld a, (.dmark)  
4262 32 6e ee			ld (debug_mark),a  
4265 3a 74 42			ld a, (.dmark+1)  
4268 32 6f ee			ld (debug_mark+1),a  
426b 3a 75 42			ld a, (.dmark+2)  
426e 32 70 ee			ld (debug_mark+2),a  
4271 18 03			jr .pastdmark  
4273 ..			.dmark: db "TC1"  
4276 f1			.pastdmark: pop af  
4277			endm  
# End of macro DMARK
4277						CALLMONITOR 
4277 cd 72 ee			call debug_vector  
427a				endm  
# End of macro CALLMONITOR
427a					endif 
427a			 
427a					; first time in turn to upper case first char 
427a			 
427a 7e					ld a, (hl) 
427b c3 05 43				jp .totsiptou 
427e			 
427e			 
427e 7e			.tot:		ld a, (hl) 
427f fe 00				cp 0 
4281 ca 49 43				jp z, .totdone 
4284			 
4284					if DEBUG_FORTH_WORDS 
4284						DMARK "TC2" 
4284 f5				push af  
4285 3a 99 42			ld a, (.dmark)  
4288 32 6e ee			ld (debug_mark),a  
428b 3a 9a 42			ld a, (.dmark+1)  
428e 32 6f ee			ld (debug_mark+1),a  
4291 3a 9b 42			ld a, (.dmark+2)  
4294 32 70 ee			ld (debug_mark+2),a  
4297 18 03			jr .pastdmark  
4299 ..			.dmark: db "TC2"  
429c f1			.pastdmark: pop af  
429d			endm  
# End of macro DMARK
429d						CALLMONITOR 
429d cd 72 ee			call debug_vector  
42a0				endm  
# End of macro CALLMONITOR
42a0					endif 
42a0					; check to see if current char is a space 
42a0			 
42a0 fe 20				cp ' ' 
42a2 28 21				jr z, .totsp 
42a4 cd 5d 11				call to_lower 
42a7					if DEBUG_FORTH_WORDS 
42a7						DMARK "TC3" 
42a7 f5				push af  
42a8 3a bc 42			ld a, (.dmark)  
42ab 32 6e ee			ld (debug_mark),a  
42ae 3a bd 42			ld a, (.dmark+1)  
42b1 32 6f ee			ld (debug_mark+1),a  
42b4 3a be 42			ld a, (.dmark+2)  
42b7 32 70 ee			ld (debug_mark+2),a  
42ba 18 03			jr .pastdmark  
42bc ..			.dmark: db "TC3"  
42bf f1			.pastdmark: pop af  
42c0			endm  
# End of macro DMARK
42c0						CALLMONITOR 
42c0 cd 72 ee			call debug_vector  
42c3				endm  
# End of macro CALLMONITOR
42c3					endif 
42c3 18 63				jr .totnxt 
42c5			 
42c5			.totsp:         ; on a space, find next char which should be upper 
42c5			 
42c5					if DEBUG_FORTH_WORDS 
42c5						DMARK "TC4" 
42c5 f5				push af  
42c6 3a da 42			ld a, (.dmark)  
42c9 32 6e ee			ld (debug_mark),a  
42cc 3a db 42			ld a, (.dmark+1)  
42cf 32 6f ee			ld (debug_mark+1),a  
42d2 3a dc 42			ld a, (.dmark+2)  
42d5 32 70 ee			ld (debug_mark+2),a  
42d8 18 03			jr .pastdmark  
42da ..			.dmark: db "TC4"  
42dd f1			.pastdmark: pop af  
42de			endm  
# End of macro DMARK
42de						CALLMONITOR 
42de cd 72 ee			call debug_vector  
42e1				endm  
# End of macro CALLMONITOR
42e1					endif 
42e1					;; 
42e1			 
42e1 fe 20				cp ' ' 
42e3 20 20				jr nz, .totsiptou 
42e5 23					inc hl 
42e6 7e					ld a, (hl) 
42e7					if DEBUG_FORTH_WORDS 
42e7						DMARK "TC5" 
42e7 f5				push af  
42e8 3a fc 42			ld a, (.dmark)  
42eb 32 6e ee			ld (debug_mark),a  
42ee 3a fd 42			ld a, (.dmark+1)  
42f1 32 6f ee			ld (debug_mark+1),a  
42f4 3a fe 42			ld a, (.dmark+2)  
42f7 32 70 ee			ld (debug_mark+2),a  
42fa 18 03			jr .pastdmark  
42fc ..			.dmark: db "TC5"  
42ff f1			.pastdmark: pop af  
4300			endm  
# End of macro DMARK
4300						CALLMONITOR 
4300 cd 72 ee			call debug_vector  
4303				endm  
# End of macro CALLMONITOR
4303					endif 
4303 18 c0				jr .totsp 
4305 fe 00		.totsiptou:    cp 0 
4307 28 40				jr z, .totdone 
4309					; not space and not zero term so upper case it 
4309 cd 54 11				call to_upper 
430c			 
430c					if DEBUG_FORTH_WORDS 
430c						DMARK "TC6" 
430c f5				push af  
430d 3a 21 43			ld a, (.dmark)  
4310 32 6e ee			ld (debug_mark),a  
4313 3a 22 43			ld a, (.dmark+1)  
4316 32 6f ee			ld (debug_mark+1),a  
4319 3a 23 43			ld a, (.dmark+2)  
431c 32 70 ee			ld (debug_mark+2),a  
431f 18 03			jr .pastdmark  
4321 ..			.dmark: db "TC6"  
4324 f1			.pastdmark: pop af  
4325			endm  
# End of macro DMARK
4325						CALLMONITOR 
4325 cd 72 ee			call debug_vector  
4328				endm  
# End of macro CALLMONITOR
4328					endif 
4328			 
4328			 
4328			.totnxt: 
4328			 
4328 77					ld (hl), a 
4329 23					inc hl 
432a					if DEBUG_FORTH_WORDS 
432a						DMARK "TC7" 
432a f5				push af  
432b 3a 3f 43			ld a, (.dmark)  
432e 32 6e ee			ld (debug_mark),a  
4331 3a 40 43			ld a, (.dmark+1)  
4334 32 6f ee			ld (debug_mark+1),a  
4337 3a 41 43			ld a, (.dmark+2)  
433a 32 70 ee			ld (debug_mark+2),a  
433d 18 03			jr .pastdmark  
433f ..			.dmark: db "TC7"  
4342 f1			.pastdmark: pop af  
4343			endm  
# End of macro DMARK
4343						CALLMONITOR 
4343 cd 72 ee			call debug_vector  
4346				endm  
# End of macro CALLMONITOR
4346					endif 
4346 c3 7e 42				jp .tot 
4349			 
4349					 
4349			 
4349			 
4349			; for each char convert to low 
4349					 
4349			.totdone: 
4349					if DEBUG_FORTH_WORDS 
4349						DMARK "TCd" 
4349 f5				push af  
434a 3a 5e 43			ld a, (.dmark)  
434d 32 6e ee			ld (debug_mark),a  
4350 3a 5f 43			ld a, (.dmark+1)  
4353 32 6f ee			ld (debug_mark+1),a  
4356 3a 60 43			ld a, (.dmark+2)  
4359 32 70 ee			ld (debug_mark+2),a  
435c 18 03			jr .pastdmark  
435e ..			.dmark: db "TCd"  
4361 f1			.pastdmark: pop af  
4362			endm  
# End of macro DMARK
4362						CALLMONITOR 
4362 cd 72 ee			call debug_vector  
4365				endm  
# End of macro CALLMONITOR
4365					endif 
4365					NEXTW 
4365 c3 01 20			jp macro_next 
4368				endm 
# End of macro NEXTW
4368			 
4368			.SUBSTR: 
4368				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4368 48				db WORD_SYS_CORE+52             
4369 c6 43			dw .LEFT            
436b 07				db 6 + 1 
436c .. 00			db "SUBSTR",0              
4373				endm 
# End of macro CWHEAD
4373			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4373			 
4373					if DEBUG_FORTH_WORDS_KEY 
4373						DMARK "SST" 
4373 f5				push af  
4374 3a 88 43			ld a, (.dmark)  
4377 32 6e ee			ld (debug_mark),a  
437a 3a 89 43			ld a, (.dmark+1)  
437d 32 6f ee			ld (debug_mark+1),a  
4380 3a 8a 43			ld a, (.dmark+2)  
4383 32 70 ee			ld (debug_mark+2),a  
4386 18 03			jr .pastdmark  
4388 ..			.dmark: db "SST"  
438b f1			.pastdmark: pop af  
438c			endm  
# End of macro DMARK
438c						CALLMONITOR 
438c cd 72 ee			call debug_vector  
438f				endm  
# End of macro CALLMONITOR
438f					endif 
438f			; TODO check string type 
438f					FORTH_DSP_VALUEHL 
438f cd 4b 1e			call macro_dsp_valuehl 
4392				endm 
# End of macro FORTH_DSP_VALUEHL
4392			 
4392 e5					push hl      ; string length 
4393			 
4393					FORTH_DSP_POP 
4393 cd 03 1f			call macro_forth_dsp_pop 
4396				endm 
# End of macro FORTH_DSP_POP
4396			 
4396					FORTH_DSP_VALUEHL 
4396 cd 4b 1e			call macro_dsp_valuehl 
4399				endm 
# End of macro FORTH_DSP_VALUEHL
4399			 
4399 e5					push hl     ; start char 
439a			 
439a					FORTH_DSP_POP 
439a cd 03 1f			call macro_forth_dsp_pop 
439d				endm 
# End of macro FORTH_DSP_POP
439d			 
439d			 
439d					FORTH_DSP_VALUE 
439d cd 34 1e			call macro_forth_dsp_value 
43a0				endm 
# End of macro FORTH_DSP_VALUE
43a0			 
43a0 d1					pop de    ; get start post offset 
43a1			 
43a1 19					add hl, de    ; starting offset 
43a2			 
43a2 c1					pop bc 
43a3 c5					push bc      ; grab size of string 
43a4			 
43a4 e5					push hl    ; save string start  
43a5			 
43a5 26 00				ld h, 0 
43a7 69					ld l, c 
43a8 23					inc hl 
43a9 23					inc hl 
43aa			 
43aa cd ae 12				call malloc 
43ad				if DEBUG_FORTH_MALLOC_GUARD 
43ad cc 0e 4d				call z,malloc_error 
43b0				endif 
43b0			 
43b0 eb					ex de, hl      ; save malloc area for string copy 
43b1 e1					pop hl    ; get back source 
43b2 c1					pop bc    ; get length of string back 
43b3			 
43b3 d5					push de    ; save malloc area for after we push 
43b4 ed b0				ldir     ; copy substr 
43b6			 
43b6			 
43b6 eb					ex de, hl 
43b7 3e 00				ld a, 0 
43b9 77					ld (hl), a   ; term substr 
43ba			 
43ba					 
43ba e1					pop hl    ; get malloc so we can push it 
43bb e5					push hl   ; save so we can free it afterwards 
43bc			 
43bc cd c2 1c				call forth_push_str 
43bf			 
43bf e1					pop hl 
43c0 cd 78 13				call free 
43c3			 
43c3					 
43c3					 
43c3			 
43c3			 
43c3					NEXTW 
43c3 c3 01 20			jp macro_next 
43c6				endm 
# End of macro NEXTW
43c6			 
43c6			.LEFT: 
43c6				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43c6 48				db WORD_SYS_CORE+52             
43c7 ee 43			dw .RIGHT            
43c9 05				db 4 + 1 
43ca .. 00			db "LEFT",0              
43cf				endm 
# End of macro CWHEAD
43cf			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43cf					if DEBUG_FORTH_WORDS_KEY 
43cf						DMARK "LEF" 
43cf f5				push af  
43d0 3a e4 43			ld a, (.dmark)  
43d3 32 6e ee			ld (debug_mark),a  
43d6 3a e5 43			ld a, (.dmark+1)  
43d9 32 6f ee			ld (debug_mark+1),a  
43dc 3a e6 43			ld a, (.dmark+2)  
43df 32 70 ee			ld (debug_mark+2),a  
43e2 18 03			jr .pastdmark  
43e4 ..			.dmark: db "LEF"  
43e7 f1			.pastdmark: pop af  
43e8			endm  
# End of macro DMARK
43e8						CALLMONITOR 
43e8 cd 72 ee			call debug_vector  
43eb				endm  
# End of macro CALLMONITOR
43eb					endif 
43eb			 
43eb					NEXTW 
43eb c3 01 20			jp macro_next 
43ee				endm 
# End of macro NEXTW
43ee			.RIGHT: 
43ee				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
43ee 48				db WORD_SYS_CORE+52             
43ef 17 44			dw .STR2NUM            
43f1 06				db 5 + 1 
43f2 .. 00			db "RIGHT",0              
43f8				endm 
# End of macro CWHEAD
43f8			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
43f8					if DEBUG_FORTH_WORDS_KEY 
43f8						DMARK "RIG" 
43f8 f5				push af  
43f9 3a 0d 44			ld a, (.dmark)  
43fc 32 6e ee			ld (debug_mark),a  
43ff 3a 0e 44			ld a, (.dmark+1)  
4402 32 6f ee			ld (debug_mark+1),a  
4405 3a 0f 44			ld a, (.dmark+2)  
4408 32 70 ee			ld (debug_mark+2),a  
440b 18 03			jr .pastdmark  
440d ..			.dmark: db "RIG"  
4410 f1			.pastdmark: pop af  
4411			endm  
# End of macro DMARK
4411						CALLMONITOR 
4411 cd 72 ee			call debug_vector  
4414				endm  
# End of macro CALLMONITOR
4414					endif 
4414			 
4414					NEXTW 
4414 c3 01 20			jp macro_next 
4417				endm 
# End of macro NEXTW
4417			 
4417			 
4417			.STR2NUM: 
4417				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4417 48				db WORD_SYS_CORE+52             
4418 a3 44			dw .NUM2STR            
441a 08				db 7 + 1 
441b .. 00			db "STR2NUM",0              
4423				endm 
# End of macro CWHEAD
4423			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4423			 
4423			 
4423			; TODO STR type check to do 
4423					if DEBUG_FORTH_WORDS_KEY 
4423						DMARK "S2N" 
4423 f5				push af  
4424 3a 38 44			ld a, (.dmark)  
4427 32 6e ee			ld (debug_mark),a  
442a 3a 39 44			ld a, (.dmark+1)  
442d 32 6f ee			ld (debug_mark+1),a  
4430 3a 3a 44			ld a, (.dmark+2)  
4433 32 70 ee			ld (debug_mark+2),a  
4436 18 03			jr .pastdmark  
4438 ..			.dmark: db "S2N"  
443b f1			.pastdmark: pop af  
443c			endm  
# End of macro DMARK
443c						CALLMONITOR 
443c cd 72 ee			call debug_vector  
443f				endm  
# End of macro CALLMONITOR
443f					endif 
443f			 
443f					;FORTH_DSP 
443f					FORTH_DSP_VALUE 
443f cd 34 1e			call macro_forth_dsp_value 
4442				endm 
# End of macro FORTH_DSP_VALUE
4442					;inc hl 
4442			 
4442 eb					ex de, hl 
4443					if DEBUG_FORTH_WORDS 
4443						DMARK "S2a" 
4443 f5				push af  
4444 3a 58 44			ld a, (.dmark)  
4447 32 6e ee			ld (debug_mark),a  
444a 3a 59 44			ld a, (.dmark+1)  
444d 32 6f ee			ld (debug_mark+1),a  
4450 3a 5a 44			ld a, (.dmark+2)  
4453 32 70 ee			ld (debug_mark+2),a  
4456 18 03			jr .pastdmark  
4458 ..			.dmark: db "S2a"  
445b f1			.pastdmark: pop af  
445c			endm  
# End of macro DMARK
445c						CALLMONITOR 
445c cd 72 ee			call debug_vector  
445f				endm  
# End of macro CALLMONITOR
445f					endif 
445f cd dc 11				call string_to_uint16 
4462			 
4462					if DEBUG_FORTH_WORDS 
4462						DMARK "S2b" 
4462 f5				push af  
4463 3a 77 44			ld a, (.dmark)  
4466 32 6e ee			ld (debug_mark),a  
4469 3a 78 44			ld a, (.dmark+1)  
446c 32 6f ee			ld (debug_mark+1),a  
446f 3a 79 44			ld a, (.dmark+2)  
4472 32 70 ee			ld (debug_mark+2),a  
4475 18 03			jr .pastdmark  
4477 ..			.dmark: db "S2b"  
447a f1			.pastdmark: pop af  
447b			endm  
# End of macro DMARK
447b						CALLMONITOR 
447b cd 72 ee			call debug_vector  
447e				endm  
# End of macro CALLMONITOR
447e					endif 
447e			;		push hl 
447e					FORTH_DSP_POP 
447e cd 03 1f			call macro_forth_dsp_pop 
4481				endm 
# End of macro FORTH_DSP_POP
4481			;		pop hl 
4481					 
4481					if DEBUG_FORTH_WORDS 
4481						DMARK "S2b" 
4481 f5				push af  
4482 3a 96 44			ld a, (.dmark)  
4485 32 6e ee			ld (debug_mark),a  
4488 3a 97 44			ld a, (.dmark+1)  
448b 32 6f ee			ld (debug_mark+1),a  
448e 3a 98 44			ld a, (.dmark+2)  
4491 32 70 ee			ld (debug_mark+2),a  
4494 18 03			jr .pastdmark  
4496 ..			.dmark: db "S2b"  
4499 f1			.pastdmark: pop af  
449a			endm  
# End of macro DMARK
449a						CALLMONITOR 
449a cd 72 ee			call debug_vector  
449d				endm  
# End of macro CALLMONITOR
449d					endif 
449d cd 54 1c				call forth_push_numhl	 
44a0			 
44a0				 
44a0				       NEXTW 
44a0 c3 01 20			jp macro_next 
44a3				endm 
# End of macro NEXTW
44a3			.NUM2STR: 
44a3				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44a3 48				db WORD_SYS_CORE+52             
44a4 b2 44			dw .CONCAT            
44a6 08				db 7 + 1 
44a7 .. 00			db "NUM2STR",0              
44af				endm 
# End of macro CWHEAD
44af			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
44af			 
44af			;		; malloc a string to target 
44af			;		ld hl, 10     ; TODO max string size should be fine 
44af			;		call malloc 
44af			;		push hl    ; save malloc location 
44af			; 
44af			; 
44af			;; TODO check int type 
44af			;		FORTH_DSP_VALUEHL 
44af			;		ld a, l 
44af			;		call DispAToASCII   
44af			;;TODO need to chage above call to dump into string 
44af			; 
44af			; 
44af			 
44af				       NEXTW 
44af c3 01 20			jp macro_next 
44b2				endm 
# End of macro NEXTW
44b2			 
44b2			.CONCAT: 
44b2				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44b2 48				db WORD_SYS_CORE+52             
44b3 65 45			dw .FIND            
44b5 07				db 6 + 1 
44b6 .. 00			db "CONCAT",0              
44bd				endm 
# End of macro CWHEAD
44bd			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44bd			 
44bd			; TODO check string type 
44bd			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44bd			 
44bd					if DEBUG_FORTH_WORDS_KEY 
44bd						DMARK "CON" 
44bd f5				push af  
44be 3a d2 44			ld a, (.dmark)  
44c1 32 6e ee			ld (debug_mark),a  
44c4 3a d3 44			ld a, (.dmark+1)  
44c7 32 6f ee			ld (debug_mark+1),a  
44ca 3a d4 44			ld a, (.dmark+2)  
44cd 32 70 ee			ld (debug_mark+2),a  
44d0 18 03			jr .pastdmark  
44d2 ..			.dmark: db "CON"  
44d5 f1			.pastdmark: pop af  
44d6			endm  
# End of macro DMARK
44d6						CALLMONITOR 
44d6 cd 72 ee			call debug_vector  
44d9				endm  
# End of macro CALLMONITOR
44d9					endif 
44d9			 
44d9			 
44d9					FORTH_DSP_VALUE 
44d9 cd 34 1e			call macro_forth_dsp_value 
44dc				endm 
# End of macro FORTH_DSP_VALUE
44dc e5					push hl   ; s2 
44dd			 
44dd					FORTH_DSP_POP 
44dd cd 03 1f			call macro_forth_dsp_pop 
44e0				endm 
# End of macro FORTH_DSP_POP
44e0			 
44e0					FORTH_DSP_VALUE 
44e0 cd 34 1e			call macro_forth_dsp_value 
44e3				endm 
# End of macro FORTH_DSP_VALUE
44e3			 
44e3 e5					push hl   ; s1 
44e4			 
44e4					FORTH_DSP_POP 
44e4 cd 03 1f			call macro_forth_dsp_pop 
44e7				endm 
# End of macro FORTH_DSP_POP
44e7					 
44e7			 
44e7					; copy s1 
44e7			 
44e7				 
44e7					; save ptr 
44e7 e1					pop hl  
44e8 e5					push hl 
44e9 3e 00				ld a, 0 
44eb cd 50 12				call strlent 
44ee					;inc hl    ; zer0 
44ee 06 00				ld b, 0 
44f0 4d					ld c, l 
44f1 e1					pop hl		 
44f2 11 c4 e2				ld de, scratch	 
44f5					if DEBUG_FORTH_WORDS 
44f5						DMARK "CO1" 
44f5 f5				push af  
44f6 3a 0a 45			ld a, (.dmark)  
44f9 32 6e ee			ld (debug_mark),a  
44fc 3a 0b 45			ld a, (.dmark+1)  
44ff 32 6f ee			ld (debug_mark+1),a  
4502 3a 0c 45			ld a, (.dmark+2)  
4505 32 70 ee			ld (debug_mark+2),a  
4508 18 03			jr .pastdmark  
450a ..			.dmark: db "CO1"  
450d f1			.pastdmark: pop af  
450e			endm  
# End of macro DMARK
450e						CALLMONITOR 
450e cd 72 ee			call debug_vector  
4511				endm  
# End of macro CALLMONITOR
4511					endif 
4511 ed b0				ldir 
4513			 
4513 e1					pop hl 
4514 e5					push hl 
4515 d5					push de 
4516			 
4516			 
4516 3e 00				ld a, 0 
4518 cd 50 12				call strlent 
451b 23					inc hl    ; zer0 
451c 23					inc hl 
451d 06 00				ld b, 0 
451f 4d					ld c, l 
4520 d1					pop de 
4521 e1					pop hl		 
4522					if DEBUG_FORTH_WORDS 
4522						DMARK "CO2" 
4522 f5				push af  
4523 3a 37 45			ld a, (.dmark)  
4526 32 6e ee			ld (debug_mark),a  
4529 3a 38 45			ld a, (.dmark+1)  
452c 32 6f ee			ld (debug_mark+1),a  
452f 3a 39 45			ld a, (.dmark+2)  
4532 32 70 ee			ld (debug_mark+2),a  
4535 18 03			jr .pastdmark  
4537 ..			.dmark: db "CO2"  
453a f1			.pastdmark: pop af  
453b			endm  
# End of macro DMARK
453b						CALLMONITOR 
453b cd 72 ee			call debug_vector  
453e				endm  
# End of macro CALLMONITOR
453e					endif 
453e ed b0				ldir 
4540			 
4540			 
4540			 
4540 21 c4 e2				ld hl, scratch 
4543					if DEBUG_FORTH_WORDS 
4543						DMARK "CO5" 
4543 f5				push af  
4544 3a 58 45			ld a, (.dmark)  
4547 32 6e ee			ld (debug_mark),a  
454a 3a 59 45			ld a, (.dmark+1)  
454d 32 6f ee			ld (debug_mark+1),a  
4550 3a 5a 45			ld a, (.dmark+2)  
4553 32 70 ee			ld (debug_mark+2),a  
4556 18 03			jr .pastdmark  
4558 ..			.dmark: db "CO5"  
455b f1			.pastdmark: pop af  
455c			endm  
# End of macro DMARK
455c						CALLMONITOR 
455c cd 72 ee			call debug_vector  
455f				endm  
# End of macro CALLMONITOR
455f					endif 
455f			 
455f cd c2 1c				call forth_push_str 
4562			 
4562			 
4562			 
4562			 
4562				       NEXTW 
4562 c3 01 20			jp macro_next 
4565				endm 
# End of macro NEXTW
4565			 
4565			 
4565			.FIND: 
4565				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4565 4b				db WORD_SYS_CORE+55             
4566 23 46			dw .LEN            
4568 05				db 4 + 1 
4569 .. 00			db "FIND",0              
456e				endm 
# End of macro CWHEAD
456e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
456e			 
456e					if DEBUG_FORTH_WORDS_KEY 
456e						DMARK "FND" 
456e f5				push af  
456f 3a 83 45			ld a, (.dmark)  
4572 32 6e ee			ld (debug_mark),a  
4575 3a 84 45			ld a, (.dmark+1)  
4578 32 6f ee			ld (debug_mark+1),a  
457b 3a 85 45			ld a, (.dmark+2)  
457e 32 70 ee			ld (debug_mark+2),a  
4581 18 03			jr .pastdmark  
4583 ..			.dmark: db "FND"  
4586 f1			.pastdmark: pop af  
4587			endm  
# End of macro DMARK
4587						CALLMONITOR 
4587 cd 72 ee			call debug_vector  
458a				endm  
# End of macro CALLMONITOR
458a					endif 
458a			 
458a			; TODO check string type 
458a					FORTH_DSP_VALUE 
458a cd 34 1e			call macro_forth_dsp_value 
458d				endm 
# End of macro FORTH_DSP_VALUE
458d			 
458d e5					push hl    
458e 7e					ld a,(hl)    ; char to find   
458f			; TODO change char to substr 
458f			 
458f f5					push af 
4590					 
4590			 
4590			 
4590					if DEBUG_FORTH_WORDS 
4590						DMARK "FN1" 
4590 f5				push af  
4591 3a a5 45			ld a, (.dmark)  
4594 32 6e ee			ld (debug_mark),a  
4597 3a a6 45			ld a, (.dmark+1)  
459a 32 6f ee			ld (debug_mark+1),a  
459d 3a a7 45			ld a, (.dmark+2)  
45a0 32 70 ee			ld (debug_mark+2),a  
45a3 18 03			jr .pastdmark  
45a5 ..			.dmark: db "FN1"  
45a8 f1			.pastdmark: pop af  
45a9			endm  
# End of macro DMARK
45a9						CALLMONITOR 
45a9 cd 72 ee			call debug_vector  
45ac				endm  
# End of macro CALLMONITOR
45ac					endif 
45ac			 
45ac					FORTH_DSP_POP 
45ac cd 03 1f			call macro_forth_dsp_pop 
45af				endm 
# End of macro FORTH_DSP_POP
45af			 
45af					; string to search 
45af			 
45af					FORTH_DSP_VALUE 
45af cd 34 1e			call macro_forth_dsp_value 
45b2				endm 
# End of macro FORTH_DSP_VALUE
45b2			 
45b2 d1					pop de  ; d is char to find  
45b3			 
45b3					if DEBUG_FORTH_WORDS 
45b3						DMARK "FN2" 
45b3 f5				push af  
45b4 3a c8 45			ld a, (.dmark)  
45b7 32 6e ee			ld (debug_mark),a  
45ba 3a c9 45			ld a, (.dmark+1)  
45bd 32 6f ee			ld (debug_mark+1),a  
45c0 3a ca 45			ld a, (.dmark+2)  
45c3 32 70 ee			ld (debug_mark+2),a  
45c6 18 03			jr .pastdmark  
45c8 ..			.dmark: db "FN2"  
45cb f1			.pastdmark: pop af  
45cc			endm  
# End of macro DMARK
45cc						CALLMONITOR 
45cc cd 72 ee			call debug_vector  
45cf				endm  
# End of macro CALLMONITOR
45cf					endif 
45cf					 
45cf 01 00 00				ld bc, 0 
45d2 7e			.findchar:      ld a,(hl) 
45d3 fe 00				cp 0   		 
45d5 28 27				jr z, .finddone     
45d7 ba					cp d 
45d8 28 20				jr z, .foundchar 
45da 03					inc bc 
45db 23					inc hl 
45dc					if DEBUG_FORTH_WORDS 
45dc						DMARK "FN3" 
45dc f5				push af  
45dd 3a f1 45			ld a, (.dmark)  
45e0 32 6e ee			ld (debug_mark),a  
45e3 3a f2 45			ld a, (.dmark+1)  
45e6 32 6f ee			ld (debug_mark+1),a  
45e9 3a f3 45			ld a, (.dmark+2)  
45ec 32 70 ee			ld (debug_mark+2),a  
45ef 18 03			jr .pastdmark  
45f1 ..			.dmark: db "FN3"  
45f4 f1			.pastdmark: pop af  
45f5			endm  
# End of macro DMARK
45f5						CALLMONITOR 
45f5 cd 72 ee			call debug_vector  
45f8				endm  
# End of macro CALLMONITOR
45f8					endif 
45f8 18 d8				jr .findchar 
45fa			 
45fa			 
45fa c5			.foundchar:	push bc 
45fb e1					pop hl 
45fc 18 03				jr .findexit 
45fe			 
45fe			 
45fe							 
45fe			 
45fe			.finddone:     ; got to end of string with no find 
45fe 21 00 00				ld hl, 0 
4601			.findexit: 
4601			 
4601					if DEBUG_FORTH_WORDS 
4601						DMARK "FNd" 
4601 f5				push af  
4602 3a 16 46			ld a, (.dmark)  
4605 32 6e ee			ld (debug_mark),a  
4608 3a 17 46			ld a, (.dmark+1)  
460b 32 6f ee			ld (debug_mark+1),a  
460e 3a 18 46			ld a, (.dmark+2)  
4611 32 70 ee			ld (debug_mark+2),a  
4614 18 03			jr .pastdmark  
4616 ..			.dmark: db "FNd"  
4619 f1			.pastdmark: pop af  
461a			endm  
# End of macro DMARK
461a						CALLMONITOR 
461a cd 72 ee			call debug_vector  
461d				endm  
# End of macro CALLMONITOR
461d					endif 
461d cd 54 1c			call forth_push_numhl 
4620			 
4620				       NEXTW 
4620 c3 01 20			jp macro_next 
4623				endm 
# End of macro NEXTW
4623			 
4623			.LEN: 
4623				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4623 4c				db WORD_SYS_CORE+56             
4624 8d 46			dw .ASC            
4626 06				db 5 + 1 
4627 .. 00			db "COUNT",0              
462d				endm 
# End of macro CWHEAD
462d			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
462d			 
462d					if DEBUG_FORTH_WORDS_KEY 
462d						DMARK "CNT" 
462d f5				push af  
462e 3a 42 46			ld a, (.dmark)  
4631 32 6e ee			ld (debug_mark),a  
4634 3a 43 46			ld a, (.dmark+1)  
4637 32 6f ee			ld (debug_mark+1),a  
463a 3a 44 46			ld a, (.dmark+2)  
463d 32 70 ee			ld (debug_mark+2),a  
4640 18 03			jr .pastdmark  
4642 ..			.dmark: db "CNT"  
4645 f1			.pastdmark: pop af  
4646			endm  
# End of macro DMARK
4646						CALLMONITOR 
4646 cd 72 ee			call debug_vector  
4649				endm  
# End of macro CALLMONITOR
4649					endif 
4649			; TODO check string type 
4649					FORTH_DSP_VALUE 
4649 cd 34 1e			call macro_forth_dsp_value 
464c				endm 
# End of macro FORTH_DSP_VALUE
464c			 
464c			 
464c					if DEBUG_FORTH_WORDS 
464c						DMARK "CN?" 
464c f5				push af  
464d 3a 61 46			ld a, (.dmark)  
4650 32 6e ee			ld (debug_mark),a  
4653 3a 62 46			ld a, (.dmark+1)  
4656 32 6f ee			ld (debug_mark+1),a  
4659 3a 63 46			ld a, (.dmark+2)  
465c 32 70 ee			ld (debug_mark+2),a  
465f 18 03			jr .pastdmark  
4661 ..			.dmark: db "CN?"  
4664 f1			.pastdmark: pop af  
4665			endm  
# End of macro DMARK
4665						CALLMONITOR 
4665 cd 72 ee			call debug_vector  
4668				endm  
# End of macro CALLMONITOR
4668					endif 
4668 cd 45 12				call strlenz 
466b					if DEBUG_FORTH_WORDS 
466b						DMARK "CNl" 
466b f5				push af  
466c 3a 80 46			ld a, (.dmark)  
466f 32 6e ee			ld (debug_mark),a  
4672 3a 81 46			ld a, (.dmark+1)  
4675 32 6f ee			ld (debug_mark+1),a  
4678 3a 82 46			ld a, (.dmark+2)  
467b 32 70 ee			ld (debug_mark+2),a  
467e 18 03			jr .pastdmark  
4680 ..			.dmark: db "CNl"  
4683 f1			.pastdmark: pop af  
4684			endm  
# End of macro DMARK
4684						CALLMONITOR 
4684 cd 72 ee			call debug_vector  
4687				endm  
# End of macro CALLMONITOR
4687					endif 
4687			 
4687 cd 54 1c				call forth_push_numhl 
468a			 
468a			 
468a			 
468a				       NEXTW 
468a c3 01 20			jp macro_next 
468d				endm 
# End of macro NEXTW
468d			.ASC: 
468d				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
468d 4d				db WORD_SYS_CORE+57             
468e fb 46			dw .CHR            
4690 04				db 3 + 1 
4691 .. 00			db "ASC",0              
4695				endm 
# End of macro CWHEAD
4695			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4695					if DEBUG_FORTH_WORDS_KEY 
4695						DMARK "ASC" 
4695 f5				push af  
4696 3a aa 46			ld a, (.dmark)  
4699 32 6e ee			ld (debug_mark),a  
469c 3a ab 46			ld a, (.dmark+1)  
469f 32 6f ee			ld (debug_mark+1),a  
46a2 3a ac 46			ld a, (.dmark+2)  
46a5 32 70 ee			ld (debug_mark+2),a  
46a8 18 03			jr .pastdmark  
46aa ..			.dmark: db "ASC"  
46ad f1			.pastdmark: pop af  
46ae			endm  
# End of macro DMARK
46ae						CALLMONITOR 
46ae cd 72 ee			call debug_vector  
46b1				endm  
# End of macro CALLMONITOR
46b1					endif 
46b1					FORTH_DSP_VALUE 
46b1 cd 34 1e			call macro_forth_dsp_value 
46b4				endm 
# End of macro FORTH_DSP_VALUE
46b4					;v5 FORTH_DSP_VALUE 
46b4			;		inc hl      ; now at start of numeric as string 
46b4			 
46b4 e5					push hl 
46b5			 
46b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46b5 cd 03 1f			call macro_forth_dsp_pop 
46b8				endm 
# End of macro FORTH_DSP_POP
46b8			 
46b8 e1					pop hl 
46b9			 
46b9					if DEBUG_FORTH_WORDS 
46b9						DMARK "AS1" 
46b9 f5				push af  
46ba 3a ce 46			ld a, (.dmark)  
46bd 32 6e ee			ld (debug_mark),a  
46c0 3a cf 46			ld a, (.dmark+1)  
46c3 32 6f ee			ld (debug_mark+1),a  
46c6 3a d0 46			ld a, (.dmark+2)  
46c9 32 70 ee			ld (debug_mark+2),a  
46cc 18 03			jr .pastdmark  
46ce ..			.dmark: db "AS1"  
46d1 f1			.pastdmark: pop af  
46d2			endm  
# End of macro DMARK
46d2						CALLMONITOR 
46d2 cd 72 ee			call debug_vector  
46d5				endm  
# End of macro CALLMONITOR
46d5					endif 
46d5					; push the content of a onto the stack as a value 
46d5			 
46d5 7e					ld a,(hl)   ; get char 
46d6 26 00				ld h,0 
46d8 6f					ld l,a 
46d9					if DEBUG_FORTH_WORDS 
46d9						DMARK "AS2" 
46d9 f5				push af  
46da 3a ee 46			ld a, (.dmark)  
46dd 32 6e ee			ld (debug_mark),a  
46e0 3a ef 46			ld a, (.dmark+1)  
46e3 32 6f ee			ld (debug_mark+1),a  
46e6 3a f0 46			ld a, (.dmark+2)  
46e9 32 70 ee			ld (debug_mark+2),a  
46ec 18 03			jr .pastdmark  
46ee ..			.dmark: db "AS2"  
46f1 f1			.pastdmark: pop af  
46f2			endm  
# End of macro DMARK
46f2						CALLMONITOR 
46f2 cd 72 ee			call debug_vector  
46f5				endm  
# End of macro CALLMONITOR
46f5					endif 
46f5 cd 54 1c				call forth_push_numhl 
46f8			 
46f8				       NEXTW 
46f8 c3 01 20			jp macro_next 
46fb				endm 
# End of macro NEXTW
46fb			 
46fb			.CHR: 
46fb				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
46fb 4d				db WORD_SYS_CORE+57             
46fc 37 47			dw .ENDSTR            
46fe 04				db 3 + 1 
46ff .. 00			db "CHR",0              
4703				endm 
# End of macro CWHEAD
4703			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4703					if DEBUG_FORTH_WORDS_KEY 
4703						DMARK "CHR" 
4703 f5				push af  
4704 3a 18 47			ld a, (.dmark)  
4707 32 6e ee			ld (debug_mark),a  
470a 3a 19 47			ld a, (.dmark+1)  
470d 32 6f ee			ld (debug_mark+1),a  
4710 3a 1a 47			ld a, (.dmark+2)  
4713 32 70 ee			ld (debug_mark+2),a  
4716 18 03			jr .pastdmark  
4718 ..			.dmark: db "CHR"  
471b f1			.pastdmark: pop af  
471c			endm  
# End of macro DMARK
471c						CALLMONITOR 
471c cd 72 ee			call debug_vector  
471f				endm  
# End of macro CALLMONITOR
471f					endif 
471f					FORTH_DSP_VALUEHL 
471f cd 4b 1e			call macro_dsp_valuehl 
4722				endm 
# End of macro FORTH_DSP_VALUEHL
4722			 
4722					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4722 cd 03 1f			call macro_forth_dsp_pop 
4725				endm 
# End of macro FORTH_DSP_POP
4725			 
4725					; save asci byte as a zero term string and push string 
4725			 
4725 7d					ld a,l 
4726 32 c4 e2				ld (scratch), a 
4729			 
4729 3e 00				ld a, 0 
472b 32 c5 e2				ld (scratch+1), a 
472e			 
472e 21 c4 e2				ld hl, scratch 
4731 cd c2 1c				call forth_push_str 
4734			 
4734			 
4734				       NEXTW 
4734 c3 01 20			jp macro_next 
4737				endm 
# End of macro NEXTW
4737			 
4737			 
4737			 
4737			 
4737			.ENDSTR: 
4737			; eof 
4737			 
# End of file forth_words_str.asm
4737			include "forth_words_key.asm" 
4737			 
4737			; | ## Keyboard Words 
4737			 
4737			.KEY: 
4737				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4737 3e				db WORD_SYS_CORE+42             
4738 67 47			dw .WAITK            
473a 04				db 3 + 1 
473b .. 00			db "KEY",0              
473f				endm 
# End of macro CWHEAD
473f			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
473f			 
473f					if DEBUG_FORTH_WORDS_KEY 
473f						DMARK "KEY" 
473f f5				push af  
4740 3a 54 47			ld a, (.dmark)  
4743 32 6e ee			ld (debug_mark),a  
4746 3a 55 47			ld a, (.dmark+1)  
4749 32 6f ee			ld (debug_mark+1),a  
474c 3a 56 47			ld a, (.dmark+2)  
474f 32 70 ee			ld (debug_mark+2),a  
4752 18 03			jr .pastdmark  
4754 ..			.dmark: db "KEY"  
4757 f1			.pastdmark: pop af  
4758			endm  
# End of macro DMARK
4758						CALLMONITOR 
4758 cd 72 ee			call debug_vector  
475b				endm  
# End of macro CALLMONITOR
475b					endif 
475b			; TODO currently waits 
475b cd 95 64				call cin 
475e					;call cin_wait 
475e 6f					ld l, a 
475f 26 00				ld h, 0 
4761 cd 54 1c				call forth_push_numhl 
4764					NEXTW 
4764 c3 01 20			jp macro_next 
4767				endm 
# End of macro NEXTW
4767			.WAITK: 
4767				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4767 3f				db WORD_SYS_CORE+43             
4768 99 47			dw .ACCEPT            
476a 06				db 5 + 1 
476b .. 00			db "WAITK",0              
4771				endm 
# End of macro CWHEAD
4771			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4771					if DEBUG_FORTH_WORDS_KEY 
4771						DMARK "WAI" 
4771 f5				push af  
4772 3a 86 47			ld a, (.dmark)  
4775 32 6e ee			ld (debug_mark),a  
4778 3a 87 47			ld a, (.dmark+1)  
477b 32 6f ee			ld (debug_mark+1),a  
477e 3a 88 47			ld a, (.dmark+2)  
4781 32 70 ee			ld (debug_mark+2),a  
4784 18 03			jr .pastdmark  
4786 ..			.dmark: db "WAI"  
4789 f1			.pastdmark: pop af  
478a			endm  
# End of macro DMARK
478a						CALLMONITOR 
478a cd 72 ee			call debug_vector  
478d				endm  
# End of macro CALLMONITOR
478d					endif 
478d cd 8d 64				call cin_wait 
4790 6f					ld l, a 
4791 26 00				ld h, 0 
4793 cd 54 1c				call forth_push_numhl 
4796					NEXTW 
4796 c3 01 20			jp macro_next 
4799				endm 
# End of macro NEXTW
4799			.ACCEPT: 
4799				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4799 40				db WORD_SYS_CORE+44             
479a f7 47			dw .EDIT            
479c 07				db 6 + 1 
479d .. 00			db "ACCEPT",0              
47a4				endm 
# End of macro CWHEAD
47a4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47a4					; TODO crashes on push 
47a4					if DEBUG_FORTH_WORDS_KEY 
47a4						DMARK "ACC" 
47a4 f5				push af  
47a5 3a b9 47			ld a, (.dmark)  
47a8 32 6e ee			ld (debug_mark),a  
47ab 3a ba 47			ld a, (.dmark+1)  
47ae 32 6f ee			ld (debug_mark+1),a  
47b1 3a bb 47			ld a, (.dmark+2)  
47b4 32 70 ee			ld (debug_mark+2),a  
47b7 18 03			jr .pastdmark  
47b9 ..			.dmark: db "ACC"  
47bc f1			.pastdmark: pop af  
47bd			endm  
# End of macro DMARK
47bd						CALLMONITOR 
47bd cd 72 ee			call debug_vector  
47c0				endm  
# End of macro CALLMONITOR
47c0					endif 
47c0 21 c2 e4				ld hl, os_input 
47c3 3e 00				ld a, 0 
47c5 77					ld (hl),a 
47c6 3a 61 ea				ld a,(f_cursor_ptr) 
47c9 16 64				ld d, 100 
47cb 0e 00				ld c, 0 
47cd 1e 28				ld e, 40 
47cf cd 14 0e				call input_str 
47d2					; TODO perhaps do a type check and wrap in quotes if not a number 
47d2 21 c2 e4				ld hl, os_input 
47d5					if DEBUG_FORTH_WORDS 
47d5						DMARK "AC1" 
47d5 f5				push af  
47d6 3a ea 47			ld a, (.dmark)  
47d9 32 6e ee			ld (debug_mark),a  
47dc 3a eb 47			ld a, (.dmark+1)  
47df 32 6f ee			ld (debug_mark+1),a  
47e2 3a ec 47			ld a, (.dmark+2)  
47e5 32 70 ee			ld (debug_mark+2),a  
47e8 18 03			jr .pastdmark  
47ea ..			.dmark: db "AC1"  
47ed f1			.pastdmark: pop af  
47ee			endm  
# End of macro DMARK
47ee						CALLMONITOR 
47ee cd 72 ee			call debug_vector  
47f1				endm  
# End of macro CALLMONITOR
47f1					endif 
47f1 cd c2 1c				call forth_push_str 
47f4					NEXTW 
47f4 c3 01 20			jp macro_next 
47f7				endm 
# End of macro NEXTW
47f7			 
47f7			.EDIT: 
47f7				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
47f7 40				db WORD_SYS_CORE+44             
47f8 99 48			dw .DEDIT            
47fa 05				db 4 + 1 
47fb .. 00			db "EDIT",0              
4800				endm 
# End of macro CWHEAD
4800			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4800			 
4800					; TODO does not copy from stack 
4800					if DEBUG_FORTH_WORDS_KEY 
4800						DMARK "EDT" 
4800 f5				push af  
4801 3a 15 48			ld a, (.dmark)  
4804 32 6e ee			ld (debug_mark),a  
4807 3a 16 48			ld a, (.dmark+1)  
480a 32 6f ee			ld (debug_mark+1),a  
480d 3a 17 48			ld a, (.dmark+2)  
4810 32 70 ee			ld (debug_mark+2),a  
4813 18 03			jr .pastdmark  
4815 ..			.dmark: db "EDT"  
4818 f1			.pastdmark: pop af  
4819			endm  
# End of macro DMARK
4819						CALLMONITOR 
4819 cd 72 ee			call debug_vector  
481c				endm  
# End of macro CALLMONITOR
481c					endif 
481c			 
481c					;FORTH_DSP 
481c					FORTH_DSP_VALUEHL 
481c cd 4b 1e			call macro_dsp_valuehl 
481f				endm 
# End of macro FORTH_DSP_VALUEHL
481f			;		inc hl    ; TODO do type check 
481f			 
481f			;		call get_word_hl 
481f e5					push hl 
4820					if DEBUG_FORTH_WORDS 
4820						DMARK "EDp" 
4820 f5				push af  
4821 3a 35 48			ld a, (.dmark)  
4824 32 6e ee			ld (debug_mark),a  
4827 3a 36 48			ld a, (.dmark+1)  
482a 32 6f ee			ld (debug_mark+1),a  
482d 3a 37 48			ld a, (.dmark+2)  
4830 32 70 ee			ld (debug_mark+2),a  
4833 18 03			jr .pastdmark  
4835 ..			.dmark: db "EDp"  
4838 f1			.pastdmark: pop af  
4839			endm  
# End of macro DMARK
4839						CALLMONITOR 
4839 cd 72 ee			call debug_vector  
483c				endm  
# End of macro CALLMONITOR
483c					endif 
483c				;	ld a, 0 
483c cd 45 12				call strlenz 
483f 23					inc hl 
4840			 
4840 06 00				ld b, 0 
4842 4d					ld c, l 
4843			 
4843 e1					pop hl 
4844 11 c2 e4				ld de, os_input 
4847					if DEBUG_FORTH_WORDS_KEY 
4847						DMARK "EDc" 
4847 f5				push af  
4848 3a 5c 48			ld a, (.dmark)  
484b 32 6e ee			ld (debug_mark),a  
484e 3a 5d 48			ld a, (.dmark+1)  
4851 32 6f ee			ld (debug_mark+1),a  
4854 3a 5e 48			ld a, (.dmark+2)  
4857 32 70 ee			ld (debug_mark+2),a  
485a 18 03			jr .pastdmark  
485c ..			.dmark: db "EDc"  
485f f1			.pastdmark: pop af  
4860			endm  
# End of macro DMARK
4860						CALLMONITOR 
4860 cd 72 ee			call debug_vector  
4863				endm  
# End of macro CALLMONITOR
4863					endif 
4863 ed b0				ldir 
4865			 
4865			 
4865 21 c2 e4				ld hl, os_input 
4868					;ld a, 0 
4868					;ld (hl),a 
4868 3a 61 ea				ld a,(f_cursor_ptr) 
486b 16 64				ld d, 100 
486d 0e 00				ld c, 0 
486f 1e 28				ld e, 40 
4871 cd 14 0e				call input_str 
4874					; TODO perhaps do a type check and wrap in quotes if not a number 
4874 21 c2 e4				ld hl, os_input 
4877					if DEBUG_FORTH_WORDS 
4877						DMARK "ED1" 
4877 f5				push af  
4878 3a 8c 48			ld a, (.dmark)  
487b 32 6e ee			ld (debug_mark),a  
487e 3a 8d 48			ld a, (.dmark+1)  
4881 32 6f ee			ld (debug_mark+1),a  
4884 3a 8e 48			ld a, (.dmark+2)  
4887 32 70 ee			ld (debug_mark+2),a  
488a 18 03			jr .pastdmark  
488c ..			.dmark: db "ED1"  
488f f1			.pastdmark: pop af  
4890			endm  
# End of macro DMARK
4890						CALLMONITOR 
4890 cd 72 ee			call debug_vector  
4893				endm  
# End of macro CALLMONITOR
4893					endif 
4893 cd c2 1c				call forth_push_str 
4896					NEXTW 
4896 c3 01 20			jp macro_next 
4899				endm 
# End of macro NEXTW
4899			 
4899			.DEDIT: 
4899				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4899 40				db WORD_SYS_CORE+44             
489a fb 48			dw .ENDKEY            
489c 06				db 5 + 1 
489d .. 00			db "DEDIT",0              
48a3				endm 
# End of macro CWHEAD
48a3			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48a3			 
48a3					; TODO does not copy from stack 
48a3					if DEBUG_FORTH_WORDS_KEY 
48a3						DMARK "DED" 
48a3 f5				push af  
48a4 3a b8 48			ld a, (.dmark)  
48a7 32 6e ee			ld (debug_mark),a  
48aa 3a b9 48			ld a, (.dmark+1)  
48ad 32 6f ee			ld (debug_mark+1),a  
48b0 3a ba 48			ld a, (.dmark+2)  
48b3 32 70 ee			ld (debug_mark+2),a  
48b6 18 03			jr .pastdmark  
48b8 ..			.dmark: db "DED"  
48bb f1			.pastdmark: pop af  
48bc			endm  
# End of macro DMARK
48bc						CALLMONITOR 
48bc cd 72 ee			call debug_vector  
48bf				endm  
# End of macro CALLMONITOR
48bf					endif 
48bf			 
48bf					;FORTH_DSP 
48bf					FORTH_DSP_VALUEHL 
48bf cd 4b 1e			call macro_dsp_valuehl 
48c2				endm 
# End of macro FORTH_DSP_VALUEHL
48c2			;		inc hl    ; TODO do type check 
48c2			 
48c2			;		call get_word_hl 
48c2 e5					push hl 
48c3 e5					push hl 
48c4					FORTH_DSP_POP 
48c4 cd 03 1f			call macro_forth_dsp_pop 
48c7				endm 
# End of macro FORTH_DSP_POP
48c7 e1					pop hl 
48c8					if DEBUG_FORTH_WORDS 
48c8						DMARK "EDp" 
48c8 f5				push af  
48c9 3a dd 48			ld a, (.dmark)  
48cc 32 6e ee			ld (debug_mark),a  
48cf 3a de 48			ld a, (.dmark+1)  
48d2 32 6f ee			ld (debug_mark+1),a  
48d5 3a df 48			ld a, (.dmark+2)  
48d8 32 70 ee			ld (debug_mark+2),a  
48db 18 03			jr .pastdmark  
48dd ..			.dmark: db "EDp"  
48e0 f1			.pastdmark: pop af  
48e1			endm  
# End of macro DMARK
48e1						CALLMONITOR 
48e1 cd 72 ee			call debug_vector  
48e4				endm  
# End of macro CALLMONITOR
48e4					endif 
48e4				;	ld a, 0 
48e4 cd 45 12				call strlenz 
48e7 23					inc hl 
48e8			 
48e8 06 00				ld b, 0 
48ea 4d					ld c, l 
48eb			 
48eb e1					pop hl 
48ec			 
48ec					;ld a, 0 
48ec					;ld (hl),a 
48ec 3a 61 ea				ld a,(f_cursor_ptr) 
48ef 16 64				ld d, 100 
48f1 0e 00				ld c, 0 
48f3 1e 28				ld e, 40 
48f5 cd 14 0e				call input_str 
48f8					; TODO perhaps do a type check and wrap in quotes if not a number 
48f8					NEXTW 
48f8 c3 01 20			jp macro_next 
48fb				endm 
# End of macro NEXTW
48fb			 
48fb			 
48fb			.ENDKEY: 
48fb			; eof 
48fb			 
# End of file forth_words_key.asm
48fb			include "forth_words_const.asm" 
48fb			 
48fb			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
48fb			 
48fb			 
48fb			.SPITIME: 
48fb				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
48fb 77				db WORD_SYS_CORE+99             
48fc 10 49			dw .VA            
48fe 08				db 7 + 1 
48ff .. 00			db "SPITIME",0              
4907				endm 
# End of macro CWHEAD
4907			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4907			; 
4907			; | If using BANK devices then leave as is. 
4907			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4907			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4907			 
4907 21 67 ea				ld hl, spi_clktime  
490a cd 54 1c				call forth_push_numhl 
490d			 
490d					NEXTW 
490d c3 01 20			jp macro_next 
4910				endm 
# End of macro NEXTW
4910			 
4910			 
4910			.VA: 
4910				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4910 77				db WORD_SYS_CORE+99             
4911 20 49			dw .SYMBOL            
4913 03				db 2 + 1 
4914 .. 00			db "VA",0              
4917				endm 
# End of macro CWHEAD
4917			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4917 21 2b ea				ld hl, cli_var_array 
491a cd 54 1c				call forth_push_numhl 
491d			 
491d					NEXTW 
491d c3 01 20			jp macro_next 
4920				endm 
# End of macro NEXTW
4920			 
4920			.SYMBOL: 
4920				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4920 77				db WORD_SYS_CORE+99             
4921 58 4a			dw .ENDCONST            
4923 07				db 6 + 1 
4924 .. 00			db "SYMBOL",0              
492b				endm 
# End of macro CWHEAD
492b			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
492b			; | 
492b			; | The value is the number reference and the final address is pushed to stack 
492b			 
492b					if DEBUG_FORTH_WORDS_KEY 
492b						DMARK "SYM" 
492b f5				push af  
492c 3a 40 49			ld a, (.dmark)  
492f 32 6e ee			ld (debug_mark),a  
4932 3a 41 49			ld a, (.dmark+1)  
4935 32 6f ee			ld (debug_mark+1),a  
4938 3a 42 49			ld a, (.dmark+2)  
493b 32 70 ee			ld (debug_mark+2),a  
493e 18 03			jr .pastdmark  
4940 ..			.dmark: db "SYM"  
4943 f1			.pastdmark: pop af  
4944			endm  
# End of macro DMARK
4944						CALLMONITOR 
4944 cd 72 ee			call debug_vector  
4947				endm  
# End of macro CALLMONITOR
4947					endif 
4947			 
4947					FORTH_DSP_VALUEHL 
4947 cd 4b 1e			call macro_dsp_valuehl 
494a				endm 
# End of macro FORTH_DSP_VALUEHL
494a			 
494a 7d					ld a, l     
494b			 
494b			 
494b					if DEBUG_FORTH_WORDS 
494b						DMARK "SY1" 
494b f5				push af  
494c 3a 60 49			ld a, (.dmark)  
494f 32 6e ee			ld (debug_mark),a  
4952 3a 61 49			ld a, (.dmark+1)  
4955 32 6f ee			ld (debug_mark+1),a  
4958 3a 62 49			ld a, (.dmark+2)  
495b 32 70 ee			ld (debug_mark+2),a  
495e 18 03			jr .pastdmark  
4960 ..			.dmark: db "SY1"  
4963 f1			.pastdmark: pop af  
4964			endm  
# End of macro DMARK
4964						CALLMONITOR 
4964 cd 72 ee			call debug_vector  
4967				endm  
# End of macro CALLMONITOR
4967					endif 
4967					 
4967 f5					push af	 
4968					FORTH_DSP_POP 
4968 cd 03 1f			call macro_forth_dsp_pop 
496b				endm 
# End of macro FORTH_DSP_POP
496b f1					pop af 
496c			 
496c cb 27				sla a  
496e				 
496e					 
496e					if DEBUG_FORTH_WORDS 
496e						DMARK "SY" 
496e f5				push af  
496f 3a 83 49			ld a, (.dmark)  
4972 32 6e ee			ld (debug_mark),a  
4975 3a 84 49			ld a, (.dmark+1)  
4978 32 6f ee			ld (debug_mark+1),a  
497b 3a 85 49			ld a, (.dmark+2)  
497e 32 70 ee			ld (debug_mark+2),a  
4981 18 02			jr .pastdmark  
4983 ..			.dmark: db "SY"  
4985 f1			.pastdmark: pop af  
4986			endm  
# End of macro DMARK
4986						CALLMONITOR 
4986 cd 72 ee			call debug_vector  
4989				endm  
# End of macro CALLMONITOR
4989					endif 
4989			 
4989 21 98 49				ld hl, sym_table 
498c cd e7 0d				call addatohl 
498f cd 83 1f				call loadwordinhl 
4992 cd 54 1c				call forth_push_numhl 
4995			 
4995			 
4995				       NEXTW 
4995 c3 01 20			jp macro_next 
4998				endm 
# End of macro NEXTW
4998			 
4998			sym_table: 
4998			 
4998			; 0 
4998 3f ea		dw cli_autodisplay 
499a 4d ea		dw cli_buffer 
499c f1 e9		dw cli_data_sp 
499e 2b e8		dw cli_data_stack 
49a0 47 ea		dw cli_execword 
49a2 f3 e9		dw cli_loop_sp 
49a4 2d e9		dw cli_loop_stack 
49a6 40 ea		dw cli_mvdot 
49a8 45 ea		dw cli_nextword 
49aa 41 ea		dw cli_origptr 
49ac 4b ea		dw cli_origtoken 
49ae			; 11 
49ae 43 ea		dw cli_ptr 
49b0 f5 e9		dw cli_ret_sp 
49b2 af e9		dw cli_ret_stack 
49b4 49 ea		dw cli_token 
49b6 2b ea		dw cli_var_array 
49b8 c8 eb		dw cursor_col 
49ba c6 eb		dw cursor_ptr 
49bc c7 eb		dw cursor_row 
49be c4 eb		dw cursor_shape 
49c0 6e ee		dw debug_mark 
49c2			; 21 
49c2 b4 ed		dw display_fb0 
49c4 13 ed		dw display_fb1 
49c6 d1 eb		dw display_fb2 
49c8 72 ec		dw display_fb3 
49ca cf eb		dw display_fb_active 
49cc c3 e3		dw execscratch 
49ce 61 ea		dw f_cursor_ptr 
49d0 75 ee		dw hardware_word 
49d2 65 ee		dw input_at_cursor 
49d4 67 ee		dw input_at_pos 
49d6			; 31 
49d6 63 ee		dw input_cur_flash 
49d8 62 ee		dw input_cur_onoff 
49da 58 ee		dw input_cursor 
49dc 68 ee		dw input_display_size 
49de 5d ee		dw input_len 
49e0 6c ee		dw input_ptr 
49e2 69 ee		dw input_size 
49e4 6a ee		dw input_start 
49e6 14 0e		dw input_str 
49e8 66 ee		dw input_under_cursor 
49ea			; 41 
49ea 57 ee		dw key_actual_pressed 
49ec 85 ee		dw key_fa 
49ee 81 ee		dw key_face_held 
49f0 84 ee		dw key_fb 
49f2 83 ee		dw key_fc 
49f4 82 ee		dw key_fd 
49f6 8b ee		dw key_held 
49f8 8a ee		dw key_held_prev 
49fa 8c 64		dw key_init 
49fc 86 ee		dw key_repeat_ct 
49fe			; 51 
49fe 05 00		dw key_rows 
4a00 55 ee		dw key_shift 
4a02 56 ee		dw key_symbol 
4a04 8c ee		dw keyscan_scancol 
4a06 96 ee		dw keyscan_table 
4a08 f5 ee		dw keyscan_table_row1 
4a0a ea ee		dw keyscan_table_row2 
4a0c df ee		dw keyscan_table_row3 
4a0e d4 ee		dw keyscan_table_row4 
4a10 c9 ee		dw keyscan_table_row5 
4a12			; 61 
4a12 eb e5		dw os_cli_cmd 
4a14 e7 e5		dw os_cur_ptr 
4a16 e9 e5		dw os_current_i 
4a18 c2 e4		dw os_input 
4a1a ea e6		dw os_last_cmd 
4a1c c1 e5		dw os_last_new_uword 
4a1e			;dw os_view_disable 
4a1e 72 ee		dw debug_vector 
4a20 b2 e2		dw os_view_hl 
4a22 c9 e5		dw os_word_scratch 
4a24 c3 00		dw portbctl 
4a26			; 71 
4a26 c1 00		dw portbdata 
4a28 66 ea		dw spi_cartdev 
4a2a 65 ea		dw spi_cartdev2 
4a2c 67 ea		dw spi_clktime 
4a2e 63 ea		dw spi_device 
4a30 62 ea		dw spi_device_id 
4a32 64 ea		dw spi_portbyte 
4a34 aa eb		dw stackstore 
4a36			if STORAGE_SE 
4a36			dw storage_actl 
4a36			dw storage_adata 
4a36			else 
4a36 00 00		dw 0 
4a38 00 00		dw 0 
4a3a			endif 
4a3a			; 81 
4a3a 69 09		dw storage_append 
4a3c			if STORAGE_SE 
4a3c			dw storage_bctl 
4a3c			else 
4a3c 00 00		dw 0 
4a3e			endif 
4a3e 96 eb		dw store_bank_active 
4a40 6a ea		dw store_filecache 
4a42 78 ea		dw store_longread 
4a44 6e ea		dw store_openaddr 
4a46 6d ea		dw store_openext 
4a48 6c ea		dw store_openmaxext 
4a4a 7d ea		dw store_page 
4a4c 79 ea		dw store_readbuf 
4a4e			; 91 
4a4e 70 ea		dw store_readcont 
4a50 7b ea		dw store_readptr 
4a52 70 ea		dw store_tmpext 
4a54 71 ea		dw store_tmpid 
4a56 68 ea		dw store_tmppageid 
4a58			 
4a58			.ENDCONST: 
4a58			 
4a58			; eof 
4a58			 
4a58			 
# End of file forth_words_const.asm
4a58			 
4a58			if STORAGE_SE 
4a58			   	include "forth_words_storage.asm" 
4a58			endif 
4a58				include "forth_words_device.asm" 
4a58			; Device related words 
4a58			 
4a58			; | ## Device Words 
4a58			 
4a58			;if SOUND_ENABLE 
4a58			;.NOTE: 
4a58			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a58			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a58			;		if DEBUG_FORTH_WORDS_KEY 
4a58			;			DMARK "NTE" 
4a58			;			CALLMONITOR 
4a58			;		endif 
4a58			; 
4a58			;	 
4a58			; 
4a58			;		NEXTW 
4a58			;.AFTERSOUND: 
4a58			;endif 
4a58			 
4a58			 
4a58			USE_GPIO: equ 0 
4a58			 
4a58			if USE_GPIO 
4a58			.GP1: 
4a58				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a58			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a58					NEXTW 
4a58			.GP2: 
4a58				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a58			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a58			 
4a58					NEXTW 
4a58			 
4a58			.GP3: 
4a58				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a58			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a58			 
4a58					NEXTW 
4a58			 
4a58			.GP4: 
4a58				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a58			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a58			 
4a58					NEXTW 
4a58			.SIN: 
4a58			 
4a58			 
4a58			endif 
4a58			 
4a58			 
4a58				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a58 33				db WORD_SYS_CORE+31             
4a59 8d 4a			dw .SOUT            
4a5b 03				db 2 + 1 
4a5c .. 00			db "IN",0              
4a5f				endm 
# End of macro CWHEAD
4a5f			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a5f					if DEBUG_FORTH_WORDS_KEY 
4a5f						DMARK "IN." 
4a5f f5				push af  
4a60 3a 74 4a			ld a, (.dmark)  
4a63 32 6e ee			ld (debug_mark),a  
4a66 3a 75 4a			ld a, (.dmark+1)  
4a69 32 6f ee			ld (debug_mark+1),a  
4a6c 3a 76 4a			ld a, (.dmark+2)  
4a6f 32 70 ee			ld (debug_mark+2),a  
4a72 18 03			jr .pastdmark  
4a74 ..			.dmark: db "IN."  
4a77 f1			.pastdmark: pop af  
4a78			endm  
# End of macro DMARK
4a78						CALLMONITOR 
4a78 cd 72 ee			call debug_vector  
4a7b				endm  
# End of macro CALLMONITOR
4a7b					endif 
4a7b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a7b cd 4b 1e			call macro_dsp_valuehl 
4a7e				endm 
# End of macro FORTH_DSP_VALUEHL
4a7e			 
4a7e e5					push hl 
4a7f			 
4a7f					; destroy value TOS 
4a7f			 
4a7f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a7f cd 03 1f			call macro_forth_dsp_pop 
4a82				endm 
# End of macro FORTH_DSP_POP
4a82			 
4a82					; one value on hl get other one back 
4a82			 
4a82 c1					pop bc 
4a83			 
4a83					; do the sub 
4a83			;		ex de, hl 
4a83			 
4a83 ed 68				in l,(c) 
4a85			 
4a85					; save it 
4a85			 
4a85 26 00				ld h,0 
4a87			 
4a87					; TODO push value back onto stack for another op etc 
4a87			 
4a87 cd 54 1c				call forth_push_numhl 
4a8a					NEXTW 
4a8a c3 01 20			jp macro_next 
4a8d				endm 
# End of macro NEXTW
4a8d			.SOUT: 
4a8d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a8d 34				db WORD_SYS_CORE+32             
4a8e e0 4a			dw .SPIO            
4a90 04				db 3 + 1 
4a91 .. 00			db "OUT",0              
4a95				endm 
# End of macro CWHEAD
4a95			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a95					if DEBUG_FORTH_WORDS_KEY 
4a95						DMARK "OUT" 
4a95 f5				push af  
4a96 3a aa 4a			ld a, (.dmark)  
4a99 32 6e ee			ld (debug_mark),a  
4a9c 3a ab 4a			ld a, (.dmark+1)  
4a9f 32 6f ee			ld (debug_mark+1),a  
4aa2 3a ac 4a			ld a, (.dmark+2)  
4aa5 32 70 ee			ld (debug_mark+2),a  
4aa8 18 03			jr .pastdmark  
4aaa ..			.dmark: db "OUT"  
4aad f1			.pastdmark: pop af  
4aae			endm  
# End of macro DMARK
4aae						CALLMONITOR 
4aae cd 72 ee			call debug_vector  
4ab1				endm  
# End of macro CALLMONITOR
4ab1					endif 
4ab1			 
4ab1					; get port 
4ab1			 
4ab1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab1 cd 4b 1e			call macro_dsp_valuehl 
4ab4				endm 
# End of macro FORTH_DSP_VALUEHL
4ab4			 
4ab4 e5					push hl 
4ab5			 
4ab5					; destroy value TOS 
4ab5			 
4ab5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab5 cd 03 1f			call macro_forth_dsp_pop 
4ab8				endm 
# End of macro FORTH_DSP_POP
4ab8			 
4ab8					; get byte to send 
4ab8			 
4ab8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab8 cd 4b 1e			call macro_dsp_valuehl 
4abb				endm 
# End of macro FORTH_DSP_VALUEHL
4abb			 
4abb			;		push hl 
4abb			 
4abb					; destroy value TOS 
4abb			 
4abb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4abb cd 03 1f			call macro_forth_dsp_pop 
4abe				endm 
# End of macro FORTH_DSP_POP
4abe			 
4abe					; one value on hl get other one back 
4abe			 
4abe			;		pop hl 
4abe			 
4abe c1					pop bc 
4abf			 
4abf					if DEBUG_FORTH_WORDS 
4abf						DMARK "OUT" 
4abf f5				push af  
4ac0 3a d4 4a			ld a, (.dmark)  
4ac3 32 6e ee			ld (debug_mark),a  
4ac6 3a d5 4a			ld a, (.dmark+1)  
4ac9 32 6f ee			ld (debug_mark+1),a  
4acc 3a d6 4a			ld a, (.dmark+2)  
4acf 32 70 ee			ld (debug_mark+2),a  
4ad2 18 03			jr .pastdmark  
4ad4 ..			.dmark: db "OUT"  
4ad7 f1			.pastdmark: pop af  
4ad8			endm  
# End of macro DMARK
4ad8						CALLMONITOR 
4ad8 cd 72 ee			call debug_vector  
4adb				endm  
# End of macro CALLMONITOR
4adb					endif 
4adb			 
4adb ed 69				out (c), l 
4add			 
4add					NEXTW 
4add c3 01 20			jp macro_next 
4ae0				endm 
# End of macro NEXTW
4ae0			 
4ae0			 
4ae0			.SPIO: 
4ae0			 
4ae0			if STORAGE_SE 
4ae0				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ae0			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ae0			 
4ae0					call spi_ce_low 
4ae0			    NEXTW 
4ae0			 
4ae0			.SPICEH: 
4ae0				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ae0			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ae0			 
4ae0					call spi_ce_high 
4ae0			    NEXTW 
4ae0			 
4ae0			 
4ae0			.SPIOb: 
4ae0			 
4ae0				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ae0			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ae0			 
4ae0					if DEBUG_FORTH_WORDS_KEY 
4ae0						DMARK "SPo" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0					; get port 
4ae0			 
4ae0			 
4ae0					; get byte to send 
4ae0			 
4ae0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae0			 
4ae0			;		push hl    ; u1  
4ae0			 
4ae0					; destroy value TOS 
4ae0			 
4ae0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae0			 
4ae0					; one value on hl get other one back 
4ae0			 
4ae0			;		pop hl   ; u2 - addr 
4ae0			 
4ae0					; TODO Send SPI byte 
4ae0			 
4ae0			;		push hl 
4ae0			;		call spi_ce_low 
4ae0			;		pop hl 
4ae0					ld a, l 
4ae0					call spi_send_byte 
4ae0			;		call spi_ce_high 
4ae0			 
4ae0					NEXTW 
4ae0			 
4ae0			.SPII: 
4ae0				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ae0			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ae0					if DEBUG_FORTH_WORDS_KEY 
4ae0						DMARK "SPi" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0			 
4ae0					; TODO Get SPI byte 
4ae0			 
4ae0					call spi_read_byte 
4ae0			 
4ae0					if DEBUG_FORTH_WORDS 
4ae0						DMARK "Si2" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0					ld h, 0 
4ae0					ld l, a 
4ae0					if DEBUG_FORTH_WORDS 
4ae0						DMARK "Si3" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0					call forth_push_numhl 
4ae0			 
4ae0					NEXTW 
4ae0			 
4ae0			 
4ae0			 
4ae0			.SESEL: 
4ae0				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ae0			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ae0					if DEBUG_FORTH_WORDS_KEY 
4ae0						DMARK "BNK" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0			 
4ae0					ld a, 255 
4ae0					ld (spi_cartdev), a 
4ae0			 
4ae0					; get bank 
4ae0			 
4ae0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae0			 
4ae0			;		push hl 
4ae0			 
4ae0					; destroy value TOS 
4ae0			 
4ae0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae0			 
4ae0					; one value on hl get other one back 
4ae0			 
4ae0			;		pop hl 
4ae0			 
4ae0			 
4ae0					ld c, SPI_CE_HIGH 
4ae0					ld b, '0'    ; human readable bank number 
4ae0			 
4ae0					ld a, l 
4ae0			 
4ae0					if DEBUG_FORTH_WORDS 
4ae0						DMARK "BNK" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0			 
4ae0					; active low 
4ae0			 
4ae0					cp 0 
4ae0					jr z, .bset 
4ae0					cp 1 
4ae0					jr nz, .b2 
4ae0					res 0, c 
4ae0					ld b, '1'    ; human readable bank number 
4ae0			.b2:		cp 2 
4ae0					jr nz, .b3 
4ae0					res 1, c 
4ae0					ld b, '2'    ; human readable bank number 
4ae0			.b3:		cp 3 
4ae0					jr nz, .b4 
4ae0					res 2, c 
4ae0					ld b, '3'    ; human readable bank number 
4ae0			.b4:		cp 4 
4ae0					jr nz, .b5 
4ae0					res 3, c 
4ae0					ld b, '4'    ; human readable bank number 
4ae0			.b5:		cp 5 
4ae0					jr nz, .bset 
4ae0					res 4, c 
4ae0					ld b, '5'    ; human readable bank number 
4ae0			 
4ae0			.bset: 
4ae0					ld a, c 
4ae0					ld (spi_device),a 
4ae0					ld a, b 
4ae0					ld (spi_device_id),a 
4ae0					if DEBUG_FORTH_WORDS 
4ae0						DMARK "BN2" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0			 
4ae0					; set default SPI clk pulse time as disabled for BANK use 
4ae0			 
4ae0					ld a, 0 
4ae0					ld (spi_clktime), a 
4ae0			 
4ae0					NEXTW 
4ae0			 
4ae0			.CARTDEV: 
4ae0				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4ae0			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4ae0					if DEBUG_FORTH_WORDS_KEY 
4ae0						DMARK "CDV" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0			 
4ae0					; disable se storage bank selection 
4ae0			 
4ae0					ld a, SPI_CE_HIGH		; ce high 
4ae0					ld (spi_device), a 
4ae0			 
4ae0					; get bank 
4ae0			 
4ae0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae0			 
4ae0			;		push hl 
4ae0			 
4ae0					; destroy value TOS 
4ae0			 
4ae0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae0			 
4ae0					; one value on hl get other one back 
4ae0			 
4ae0			;		pop hl 
4ae0			 
4ae0					; active low 
4ae0			 
4ae0					ld c, 255 
4ae0			 
4ae0					ld a, l 
4ae0					if DEBUG_FORTH_WORDS 
4ae0						DMARK "CDV" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0					cp 0 
4ae0					jr z, .cset 
4ae0					cp 1 
4ae0					jr nz, .c2 
4ae0					res 0, c 
4ae0			.c2:		cp 2 
4ae0					jr nz, .c3 
4ae0					res 1, c 
4ae0			.c3:		cp 3 
4ae0					jr nz, .c4 
4ae0					res 2, c 
4ae0			.c4:		cp 4 
4ae0					jr nz, .c5 
4ae0					res 3, c 
4ae0			.c5:		cp 5 
4ae0					jr nz, .c6 
4ae0					res 4, c 
4ae0			.c6:		cp 6 
4ae0					jr nz, .c7 
4ae0					res 5, c 
4ae0			.c7:		cp 7 
4ae0					jr nz, .c8 
4ae0					res 6, c 
4ae0			.c8:		cp 8 
4ae0					jr nz, .cset 
4ae0					res 7, c 
4ae0			.cset:		ld a, c 
4ae0					ld (spi_cartdev),a 
4ae0			 
4ae0					if DEBUG_FORTH_WORDS 
4ae0						DMARK "CD2" 
4ae0						CALLMONITOR 
4ae0					endif 
4ae0			 
4ae0					; set default SPI clk pulse time as 10ms for CARTDEV use 
4ae0			 
4ae0					ld a, $0a 
4ae0					ld (spi_clktime), a 
4ae0					NEXTW 
4ae0			endif 
4ae0			 
4ae0			.ENDDEVICE: 
4ae0			; eof 
4ae0			 
# End of file forth_words_device.asm
4ae0			 
4ae0			; var handler 
4ae0			 
4ae0			 
4ae0			.VARS: 
4ae0				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4ae0 77				db WORD_SYS_CORE+99             
4ae1 91 4b			dw .V0            
4ae3 04				db 3 + 1 
4ae4 .. 00			db "VAR",0              
4ae8				endm 
# End of macro CWHEAD
4ae8			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4ae8			;| 
4ae8			;| The variable name should consist of a single letter. e.g. "a" 
4ae8			;! If a full string is passed then only the first char is looked at 
4ae8			;| Any other char could exceed bounds checks!  
4ae8			 
4ae8					if DEBUG_FORTH_WORDS_KEY 
4ae8						DMARK "VAR" 
4ae8 f5				push af  
4ae9 3a fd 4a			ld a, (.dmark)  
4aec 32 6e ee			ld (debug_mark),a  
4aef 3a fe 4a			ld a, (.dmark+1)  
4af2 32 6f ee			ld (debug_mark+1),a  
4af5 3a ff 4a			ld a, (.dmark+2)  
4af8 32 70 ee			ld (debug_mark+2),a  
4afb 18 03			jr .pastdmark  
4afd ..			.dmark: db "VAR"  
4b00 f1			.pastdmark: pop af  
4b01			endm  
# End of macro DMARK
4b01						CALLMONITOR 
4b01 cd 72 ee			call debug_vector  
4b04				endm  
# End of macro CALLMONITOR
4b04					endif 
4b04			 
4b04					FORTH_DSP_VALUEHL 
4b04 cd 4b 1e			call macro_dsp_valuehl 
4b07				endm 
# End of macro FORTH_DSP_VALUEHL
4b07			 
4b07 7e					ld a, (hl)    ; get first char on of the string 
4b08			 
4b08			 
4b08					if DEBUG_FORTH_WORDS 
4b08						DMARK "VR1" 
4b08 f5				push af  
4b09 3a 1d 4b			ld a, (.dmark)  
4b0c 32 6e ee			ld (debug_mark),a  
4b0f 3a 1e 4b			ld a, (.dmark+1)  
4b12 32 6f ee			ld (debug_mark+1),a  
4b15 3a 1f 4b			ld a, (.dmark+2)  
4b18 32 70 ee			ld (debug_mark+2),a  
4b1b 18 03			jr .pastdmark  
4b1d ..			.dmark: db "VR1"  
4b20 f1			.pastdmark: pop af  
4b21			endm  
# End of macro DMARK
4b21						CALLMONITOR 
4b21 cd 72 ee			call debug_vector  
4b24				endm  
# End of macro CALLMONITOR
4b24					endif 
4b24					 
4b24 f5					push af	 
4b25					FORTH_DSP_POP 
4b25 cd 03 1f			call macro_forth_dsp_pop 
4b28				endm 
# End of macro FORTH_DSP_POP
4b28 f1					pop af 
4b29			 
4b29					; convert to upper 
4b29			 
4b29 cd 54 11				call to_upper 
4b2c					if DEBUG_FORTH_WORDS 
4b2c						DMARK "Vaa" 
4b2c f5				push af  
4b2d 3a 41 4b			ld a, (.dmark)  
4b30 32 6e ee			ld (debug_mark),a  
4b33 3a 42 4b			ld a, (.dmark+1)  
4b36 32 6f ee			ld (debug_mark+1),a  
4b39 3a 43 4b			ld a, (.dmark+2)  
4b3c 32 70 ee			ld (debug_mark+2),a  
4b3f 18 03			jr .pastdmark  
4b41 ..			.dmark: db "Vaa"  
4b44 f1			.pastdmark: pop af  
4b45			endm  
# End of macro DMARK
4b45						CALLMONITOR 
4b45 cd 72 ee			call debug_vector  
4b48				endm  
# End of macro CALLMONITOR
4b48					endif 
4b48 06 41				ld b, 'A' 
4b4a 90					sub b			; set offset 
4b4b					if DEBUG_FORTH_WORDS 
4b4b						DMARK "Vbb" 
4b4b f5				push af  
4b4c 3a 60 4b			ld a, (.dmark)  
4b4f 32 6e ee			ld (debug_mark),a  
4b52 3a 61 4b			ld a, (.dmark+1)  
4b55 32 6f ee			ld (debug_mark+1),a  
4b58 3a 62 4b			ld a, (.dmark+2)  
4b5b 32 70 ee			ld (debug_mark+2),a  
4b5e 18 03			jr .pastdmark  
4b60 ..			.dmark: db "Vbb"  
4b63 f1			.pastdmark: pop af  
4b64			endm  
# End of macro DMARK
4b64						CALLMONITOR 
4b64 cd 72 ee			call debug_vector  
4b67				endm  
# End of macro CALLMONITOR
4b67					endif 
4b67 cb 27				sla a  
4b69				 
4b69					 
4b69					if DEBUG_FORTH_WORDS 
4b69						DMARK "VR2" 
4b69 f5				push af  
4b6a 3a 7e 4b			ld a, (.dmark)  
4b6d 32 6e ee			ld (debug_mark),a  
4b70 3a 7f 4b			ld a, (.dmark+1)  
4b73 32 6f ee			ld (debug_mark+1),a  
4b76 3a 80 4b			ld a, (.dmark+2)  
4b79 32 70 ee			ld (debug_mark+2),a  
4b7c 18 03			jr .pastdmark  
4b7e ..			.dmark: db "VR2"  
4b81 f1			.pastdmark: pop af  
4b82			endm  
# End of macro DMARK
4b82						CALLMONITOR 
4b82 cd 72 ee			call debug_vector  
4b85				endm  
# End of macro CALLMONITOR
4b85					endif 
4b85			 
4b85 21 f7 e9				ld hl, cli_var_array2 
4b88 cd e7 0d				call addatohl 
4b8b cd 54 1c				call forth_push_numhl 
4b8e			 
4b8e			 
4b8e				       NEXTW 
4b8e c3 01 20			jp macro_next 
4b91				endm 
# End of macro NEXTW
4b91			.V0: 
4b91				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b91 78				db WORD_SYS_CORE+100             
4b92 a9 4b			dw .V0Q            
4b94 04				db 3 + 1 
4b95 .. 00			db "V0!",0              
4b99				endm 
# End of macro CWHEAD
4b99			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b99			 
4b99					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b99 cd 4b 1e			call macro_dsp_valuehl 
4b9c				endm 
# End of macro FORTH_DSP_VALUEHL
4b9c			 
4b9c 11 2b ea				ld de, cli_var_array 
4b9f			 
4b9f eb					ex de, hl 
4ba0 73					ld (hl), e 
4ba1 23					inc hl 
4ba2 72					ld (hl), d 
4ba3			 
4ba3					; destroy value TOS 
4ba3			 
4ba3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ba3 cd 03 1f			call macro_forth_dsp_pop 
4ba6				endm 
# End of macro FORTH_DSP_POP
4ba6			 
4ba6				       NEXTW 
4ba6 c3 01 20			jp macro_next 
4ba9				endm 
# End of macro NEXTW
4ba9			.V0Q: 
4ba9				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4ba9 79				db WORD_SYS_CORE+101             
4baa ba 4b			dw .V1S            
4bac 04				db 3 + 1 
4bad .. 00			db "V0@",0              
4bb1				endm 
# End of macro CWHEAD
4bb1			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4bb1 2a 2b ea				ld hl, (cli_var_array) 
4bb4 cd 54 1c				call forth_push_numhl 
4bb7			 
4bb7				       NEXTW 
4bb7 c3 01 20			jp macro_next 
4bba				endm 
# End of macro NEXTW
4bba			.V1S: 
4bba				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bba 7a				db WORD_SYS_CORE+102             
4bbb d2 4b			dw .V1Q            
4bbd 04				db 3 + 1 
4bbe .. 00			db "V1!",0              
4bc2				endm 
# End of macro CWHEAD
4bc2			;| V1! ( u1 -- )  Store value to v1 | DONE 
4bc2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bc2 cd 4b 1e			call macro_dsp_valuehl 
4bc5				endm 
# End of macro FORTH_DSP_VALUEHL
4bc5			 
4bc5 11 2d ea				ld de, cli_var_array+2 
4bc8				 
4bc8 eb					ex de, hl 
4bc9 73					ld (hl), e 
4bca 23					inc hl 
4bcb 72					ld (hl), d 
4bcc			 
4bcc					; destroy value TOS 
4bcc			 
4bcc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bcc cd 03 1f			call macro_forth_dsp_pop 
4bcf				endm 
# End of macro FORTH_DSP_POP
4bcf				       NEXTW 
4bcf c3 01 20			jp macro_next 
4bd2				endm 
# End of macro NEXTW
4bd2			.V1Q: 
4bd2				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bd2 7b				db WORD_SYS_CORE+103             
4bd3 e3 4b			dw .V2S            
4bd5 04				db 3 + 1 
4bd6 .. 00			db "V1@",0              
4bda				endm 
# End of macro CWHEAD
4bda			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bda 2a 2d ea				ld hl, (cli_var_array+2) 
4bdd cd 54 1c				call forth_push_numhl 
4be0				       NEXTW 
4be0 c3 01 20			jp macro_next 
4be3				endm 
# End of macro NEXTW
4be3			.V2S: 
4be3				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4be3 7c				db WORD_SYS_CORE+104             
4be4 fb 4b			dw .V2Q            
4be6 04				db 3 + 1 
4be7 .. 00			db "V2!",0              
4beb				endm 
# End of macro CWHEAD
4beb			;| V2! ( u1 -- )  Store value to v2 | DONE 
4beb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4beb cd 4b 1e			call macro_dsp_valuehl 
4bee				endm 
# End of macro FORTH_DSP_VALUEHL
4bee			 
4bee 11 2f ea				ld de, cli_var_array+4 
4bf1				 
4bf1 eb					ex de, hl 
4bf2 73					ld (hl), e 
4bf3 23					inc hl 
4bf4 72					ld (hl), d 
4bf5			 
4bf5					; destroy value TOS 
4bf5			 
4bf5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf5 cd 03 1f			call macro_forth_dsp_pop 
4bf8				endm 
# End of macro FORTH_DSP_POP
4bf8				       NEXTW 
4bf8 c3 01 20			jp macro_next 
4bfb				endm 
# End of macro NEXTW
4bfb			.V2Q: 
4bfb				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4bfb 7d				db WORD_SYS_CORE+105             
4bfc 0c 4c			dw .V3S            
4bfe 04				db 3 + 1 
4bff .. 00			db "V2@",0              
4c03				endm 
# End of macro CWHEAD
4c03			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c03 2a 2f ea				ld hl, (cli_var_array+4) 
4c06 cd 54 1c				call forth_push_numhl 
4c09				       NEXTW 
4c09 c3 01 20			jp macro_next 
4c0c				endm 
# End of macro NEXTW
4c0c			.V3S: 
4c0c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c0c 7c				db WORD_SYS_CORE+104             
4c0d 24 4c			dw .V3Q            
4c0f 04				db 3 + 1 
4c10 .. 00			db "V3!",0              
4c14				endm 
# End of macro CWHEAD
4c14			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c14 cd 4b 1e			call macro_dsp_valuehl 
4c17				endm 
# End of macro FORTH_DSP_VALUEHL
4c17			 
4c17 11 31 ea				ld de, cli_var_array+6 
4c1a				 
4c1a eb					ex de, hl 
4c1b 73					ld (hl), e 
4c1c 23					inc hl 
4c1d 72					ld (hl), d 
4c1e			 
4c1e					; destroy value TOS 
4c1e			 
4c1e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c1e cd 03 1f			call macro_forth_dsp_pop 
4c21				endm 
# End of macro FORTH_DSP_POP
4c21				       NEXTW 
4c21 c3 01 20			jp macro_next 
4c24				endm 
# End of macro NEXTW
4c24			.V3Q: 
4c24				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c24 7d				db WORD_SYS_CORE+105             
4c25 35 4c			dw .END            
4c27 04				db 3 + 1 
4c28 .. 00			db "V3@",0              
4c2c				endm 
# End of macro CWHEAD
4c2c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c2c 2a 31 ea				ld hl, (cli_var_array+6) 
4c2f cd 54 1c				call forth_push_numhl 
4c32				       NEXTW 
4c32 c3 01 20			jp macro_next 
4c35				endm 
# End of macro NEXTW
4c35			 
4c35			 
4c35			 
4c35			 
4c35			 
4c35			; end of dict marker 
4c35			 
4c35 00			.END:    db WORD_SYS_END 
4c36 00 00			dw 0 
4c38 00				db 0 
4c39			 
4c39			; use to jp here for user dict words to save on macro expansion  
4c39			 
4c39			user_dict_next: 
4c39				NEXTW 
4c39 c3 01 20			jp macro_next 
4c3c				endm 
# End of macro NEXTW
4c3c			 
4c3c			 
4c3c			user_exec: 
4c3c				;    ld hl, <word code> 
4c3c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c3c				;    call forthexec 
4c3c				;    jp user_dict_next   (NEXT) 
4c3c			        ;    <word code bytes> 
4c3c eb				ex de, hl 
4c3d 2a c5 e5			ld hl,(os_tok_ptr) 
4c40				 
4c40				FORTH_RSP_NEXT 
4c40 cd fb 1b			call macro_forth_rsp_next 
4c43				endm 
# End of macro FORTH_RSP_NEXT
4c43			 
4c43			if DEBUG_FORTH_UWORD 
4c43						DMARK "UEX" 
4c43 f5				push af  
4c44 3a 58 4c			ld a, (.dmark)  
4c47 32 6e ee			ld (debug_mark),a  
4c4a 3a 59 4c			ld a, (.dmark+1)  
4c4d 32 6f ee			ld (debug_mark+1),a  
4c50 3a 5a 4c			ld a, (.dmark+2)  
4c53 32 70 ee			ld (debug_mark+2),a  
4c56 18 03			jr .pastdmark  
4c58 ..			.dmark: db "UEX"  
4c5b f1			.pastdmark: pop af  
4c5c			endm  
# End of macro DMARK
4c5c				CALLMONITOR 
4c5c cd 72 ee			call debug_vector  
4c5f				endm  
# End of macro CALLMONITOR
4c5f			endif 
4c5f			 
4c5f			 
4c5f			 
4c5f eb				ex de, hl 
4c60 22 c5 e5			ld (os_tok_ptr), hl 
4c63				 
4c63				; Don't use next - Skips the first word in uword. 
4c63			 
4c63 c3 92 20			jp exec1 
4c66			;	NEXT 
4c66			 
4c66			 
4c66			; eof 
# End of file forth_wordsv4.asm
4c66			endif 
4c66			;;;;;;;;;;;;;; Debug code 
4c66			 
4c66			 
4c66			;if DEBUG_FORTH_PARSE 
4c66 .. 00		.nowordfound: db "No match",0 
4c6f .. 00		.compword:	db "Comparing word ",0 
4c7f .. 00		.nextwordat:	db "Next word at",0 
4c8c .. 00		.charmatch:	db "Char match",0 
4c97			;endif 
4c97			if DEBUG_FORTH_JP 
4c97			.foundword:	db "Word match. Exec..",0 
4c97			endif 
4c97			;if DEBUG_FORTH_PUSH 
4c97 .. 00		.enddict:	db "Dict end. Push.",0 
4ca7 .. 00		.push_str:	db "Pushing string",0 
4cb6 .. 00		.push_num:	db "Pushing number",0 
4cc5 .. 00		.data_sp:	db "SP:",0 
4cc9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4cdb .. 00		.wordinde:	db "Word in DE (3/0):",0 
4ced .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4cff			;endif 
4cff			;if DEBUG_FORTH_MALLOC 
4cff .. 00		.push_malloc:	db "Malloc address",0 
4d0e			;endif 
4d0e			 
4d0e			 
4d0e			 
4d0e			; display malloc address and current data stack pointer  
4d0e			 
4d0e			malloc_error: 
4d0e d5				push de 
4d0f f5				push af 
4d10 e5				push hl 
4d11 cd ba 0b			call clear_display 
4d14 11 34 4d			ld de, .mallocerr 
4d17 3e 00			ld a,0 
4d19			;	ld de,os_word_scratch 
4d19 cd cd 0b			call str_at_display 
4d1c 3e 11			ld a, display_row_1+17 
4d1e 11 6e ee			ld de, debug_mark 
4d21 cd cd 0b			call str_at_display 
4d24 cd dd 0b			call update_display 
4d27				;call break_point_state 
4d27 cd 8d 64			call cin_wait 
4d2a			 
4d2a			;	ld a, ' ' 
4d2a			;	ld (os_view_disable), a 
4d2a cd dd 15			call bp_on 
4d2d e1				pop hl 
4d2e f1				pop af 
4d2f d1				pop de	 
4d30				CALLMONITOR 
4d30 cd 72 ee			call debug_vector  
4d33				endm  
# End of macro CALLMONITOR
4d33 c9				ret 
4d34			 
4d34 .. 00		.mallocerr: 	db "Malloc Error",0 
4d41			;if DEBUG_FORTH_PUSH 
4d41			display_data_sp: 
4d41 f5				push af 
4d42			 
4d42				; see if disabled 
4d42			 
4d42			 
4d42 3a 72 ee			ld a, (debug_vector) 
4d45 fe c9			cp $C9  ; RET 
4d47				;ld a, (os_view_disable) 
4d47				;cp '*' 
4d47 28 67			jr z, .skipdsp 
4d49			 
4d49 e5				push hl 
4d4a e5				push hl 
4d4b e5			push hl 
4d4c cd ba 0b			call clear_display 
4d4f e1			pop hl 
4d50 7c				ld a,h 
4d51 21 c9 e5			ld hl, os_word_scratch 
4d54 cd e8 10			call hexout 
4d57 e1				pop hl 
4d58 7d				ld a,l 
4d59 21 cb e5			ld hl, os_word_scratch+2 
4d5c cd e8 10			call hexout 
4d5f 21 cd e5			ld hl, os_word_scratch+4 
4d62 3e 00			ld a,0 
4d64 77				ld (hl),a 
4d65 11 c9 e5			ld de,os_word_scratch 
4d68 3e 28				ld a, display_row_2 
4d6a cd cd 0b				call str_at_display 
4d6d 11 c9 4c			ld de, .wordinhl 
4d70 3e 00			ld a, display_row_1 
4d72			 
4d72 cd cd 0b				call str_at_display 
4d75 11 6e ee			ld de, debug_mark 
4d78 3e 11			ld a, display_row_1+17 
4d7a			 
4d7a cd cd 0b				call str_at_display 
4d7d			 
4d7d				; display current data stack pointer 
4d7d 11 c5 4c			ld de,.data_sp 
4d80 3e 30				ld a, display_row_2 + 8 
4d82 cd cd 0b				call str_at_display 
4d85			 
4d85 2a f1 e9			ld hl,(cli_data_sp) 
4d88 e5				push hl 
4d89 7c				ld a,h 
4d8a 21 c9 e5			ld hl, os_word_scratch 
4d8d cd e8 10			call hexout 
4d90 e1				pop hl 
4d91 7d				ld a,l 
4d92 21 cb e5			ld hl, os_word_scratch+2 
4d95 cd e8 10			call hexout 
4d98 21 cd e5			ld hl, os_word_scratch+4 
4d9b 3e 00			ld a,0 
4d9d 77				ld (hl),a 
4d9e 11 c9 e5			ld de,os_word_scratch 
4da1 3e 33				ld a, display_row_2 + 11 
4da3 cd cd 0b				call str_at_display 
4da6			 
4da6			 
4da6 cd dd 0b			call update_display 
4da9 cd f2 0a			call delay1s 
4dac cd f2 0a			call delay1s 
4daf e1				pop hl 
4db0			.skipdsp: 
4db0 f1				pop af 
4db1 c9				ret 
4db2			 
4db2			display_data_malloc: 
4db2			 
4db2 f5				push af 
4db3 e5				push hl 
4db4 e5				push hl 
4db5 e5			push hl 
4db6 cd ba 0b			call clear_display 
4db9 e1			pop hl 
4dba 7c				ld a,h 
4dbb 21 c9 e5			ld hl, os_word_scratch 
4dbe cd e8 10			call hexout 
4dc1 e1				pop hl 
4dc2 7d				ld a,l 
4dc3 21 cb e5			ld hl, os_word_scratch+2 
4dc6 cd e8 10			call hexout 
4dc9 21 cd e5			ld hl, os_word_scratch+4 
4dcc 3e 00			ld a,0 
4dce 77				ld (hl),a 
4dcf 11 c9 e5			ld de,os_word_scratch 
4dd2 3e 28				ld a, display_row_2 
4dd4 cd cd 0b				call str_at_display 
4dd7 11 ff 4c			ld de, .push_malloc 
4dda 3e 00			ld a, display_row_1 
4ddc			 
4ddc cd cd 0b				call str_at_display 
4ddf			 
4ddf				; display current data stack pointer 
4ddf 11 c5 4c			ld de,.data_sp 
4de2 3e 30				ld a, display_row_2 + 8 
4de4 cd cd 0b				call str_at_display 
4de7			 
4de7 2a f1 e9			ld hl,(cli_data_sp) 
4dea e5				push hl 
4deb 7c				ld a,h 
4dec 21 c9 e5			ld hl, os_word_scratch 
4def cd e8 10			call hexout 
4df2 e1				pop hl 
4df3 7d				ld a,l 
4df4 21 cb e5			ld hl, os_word_scratch+2 
4df7 cd e8 10			call hexout 
4dfa 21 cd e5			ld hl, os_word_scratch+4 
4dfd 3e 00			ld a,0 
4dff 77				ld (hl),a 
4e00 11 c9 e5			ld de,os_word_scratch 
4e03 3e 33				ld a, display_row_2 + 11 
4e05 cd cd 0b				call str_at_display 
4e08			 
4e08 cd dd 0b			call update_display 
4e0b cd f2 0a			call delay1s 
4e0e cd f2 0a			call delay1s 
4e11 e1				pop hl 
4e12 f1				pop af 
4e13 c9				ret 
4e14			;endif 
4e14			 
4e14			include "forth_autostart.asm" 
4e14			; list of commands to perform at system start up 
4e14			 
4e14			startcmds: 
4e14			;	dw test11 
4e14			;	dw test12 
4e14			;	dw test13 
4e14			;	dw test14 
4e14			;	dw test15 
4e14			;	dw test16 
4e14			;	dw test17 
4e14			;	dw ifthtest1 
4e14			;	dw ifthtest2 
4e14			;	dw ifthtest3 
4e14			;	dw mmtest1 
4e14			;	dw mmtest2 
4e14			;	dw mmtest3 
4e14			;	dw mmtest4 
4e14			;	dw mmtest5 
4e14			;	dw mmtest6 
4e14			;	dw iftest1 
4e14			;	dw iftest2 
4e14			;	dw iftest3 
4e14			;	dw looptest1 
4e14			;	dw looptest2 
4e14			;	dw test1 
4e14			;	dw test2 
4e14			;	dw test3 
4e14			;	dw test4 
4e14			;	dw game2r 
4e14			;	dw game2b1 
4e14			;	dw game2b2 
4e14			 
4e14				; start up words that are actually useful 
4e14			 
4e14 1c 4f		    dw spi1 
4e16 75 4f		    dw spi2 
4e18 03 50		    dw spi3 
4e1a ab 4f		    dw spi4 
4e1c d6 4f		    dw spi5 
4e1e 69 50		    dw spi6 
4e20 be 50		    dw spi7 
4e22			 
4e22 16 51		    dw spi8 
4e24 35 51		    dw spi9 
4e26 8d 51		    dw spi10 
4e28			 
4e28			; file editor 
4e28 8e 4e			dw edit1 
4e2a af 4e			dw edit2 
4e2c e4 4e			dw edit3 
4e2e			 
4e2e 00 52			dw longread 
4e30 47 52			dw clrstack 
4e32 7a 52			dw type 
4e34 65 54			dw stest 
4e36 9e 52			dw strncpy 
4e38 fb 53			dw list 
4e3a ff 52			dw start1 
4e3c 0f 53			dw start2 
4e3e			;	dw start3 
4e3e 20 53			dw start3b 
4e40 9b 53			dw start3c 
4e42			 
4e42				; (unit) testing words 
4e42			 
4e42 dc 54			dw mtesta 
4e44 91 55			dw mtestb 
4e46 34 56			dw mtestc 
4e48 e9 56			dw mtestd 
4e4a 8d 57			dw mteste 
4e4c			 
4e4c				; demo/game words 
4e4c			 
4e4c 99 5e		        dw game3w 
4e4e c7 5e		        dw game3p 
4e50 e5 5e		        dw game3sc 
4e52 16 5f		        dw game3vsi 
4e54 42 5f		        dw game3vs 
4e56				 
4e56 8c 5c			dw game2b 
4e58 fa 5c			dw game2bf 
4e5a 44 5d			dw game2mba 
4e5c da 5d			dw game2mbas 
4e5e 1c 5e			dw game2mb 
4e60			 
4e60 4d 59			dw game1 
4e62 5e 59			dw game1a 
4e64 c0 59			dw game1b 
4e66 f5 59			dw game1c 
4e68 2b 5a			dw game1d 
4e6a 5c 5a			dw game1s 
4e6c 70 5a			dw game1t 
4e6e 85 5a			dw game1f 
4e70 b9 5a			dw game1z 
4e72 fd 5a			dw game1zz 
4e74			 
4e74 43 58			dw test5 
4e76 7b 58			dw test6 
4e78 b3 58			dw test7 
4e7a c7 58			dw test8 
4e7c f3 58			dw test9 
4e7e 09 59			dw test10 
4e80				 
4e80 d4 5b		        dw ssv5 
4e82 b8 5b		        dw ssv4 
4e84 9c 5b		        dw ssv3 
4e86 66 5b		        dw ssv2 
4e88 ed 5b		        dw ssv1 
4e8a 35 5c		        dw ssv1cpm 
4e8c			;	dw keyup 
4e8c			;	dw keydown 
4e8c			;	dw keyleft 
4e8c			;	dw keyright 
4e8c			;	dw 	keyf1 
4e8c			;	dw keyf2 
4e8c			;	dw keyf3 
4e8c			;	dw keyf4 
4e8c			;	dw keyf5 
4e8c			;	dw keyf6 
4e8c			;	dw keyf7 
4e8c			;	dw keyf8 
4e8c			;	dw keyf9 
4e8c			;	dw keyf10 
4e8c			;	dw keyf11 
4e8c			;	dw keyf12 
4e8c			;	dw keytab 
4e8c			;	dw keycr 
4e8c			;	dw keyhome 
4e8c			;	dw keyend 
4e8c			;	dw keybs 
4e8c 00 00			db 0, 0	 
4e8e			 
4e8e			 
4e8e			; File Editor 
4e8e			 
4e8e			; ( id - ) use 'e' to edit the displayed line 
4e8e .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4eaf .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ee4			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ee4 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f1c			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f1c			 
4f1c			; SPI Net support words 
4f1c			 
4f1c			; v0! = node to send to 
4f1c			; ( str count - ) 
4f1c .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f75			 
4f75			; spiputchr ( char node - ) 
4f75 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4fab			 
4fab			; spigetchr ( - n ) 
4fab .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4fd6			 
4fd6			; getnode ( - n ) 
4fd6 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5003			 
5003			; ( str node - )  
5003 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5069			; store string ( str i - ) 
5069			 
5069			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5069 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50be			 
50be			; get string ( addr i -  )    TO FIX 
50be			 
50be .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5116			 
5116			 
5116			; NETCHAT (TODO) 
5116			; Program to allow two nodes to chat with eachother 
5116			; 
5116			; v0 - target node 
5116			;  
5116			; accept input at 0,0 
5116			; if input is string send spitype to target node 
5116			; starting at row 2,0 , while spigetchr is not zero ->  
5116			; 
5116			; 
5116			; TODO add paging of get request 
5116			 
5116			; ( node - ) 
5116 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5135 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
518d .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
5200			 
5200			 
5200			; Long read of currently open file 
5200 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5247			 
5247			; clear stack  
5247			 
5247 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
527a			 
527a			; type ( addr count - ) 
527a .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
529e			 
529e			; some direct memory words 
529e			; strncpy ( len t f -- t ) 
529e			 
529e .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52ff			 
52ff .. 00		start1:     	db ": bpon $00 bp ;",0 
530f .. 00		start2:     	db ": bpoff $01 bp ;",0 
5320 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
539b .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53fb			 
53fb			 
53fb			; a handy word to list items on the stack 
53fb			 
53fb .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5465			 
5465			 
5465			; test stack  
5465			; rnd8 stest 
5465			 
5465 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54dc			 
54dc			; random malloc and free cycles 
54dc			 
54dc .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5591			 
5591			; fixed malloc and free cycles 
5591			 
5591 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5634			 
5634			; fixed double string push and drop cycle  
5634			 
5634 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56e9			 
56e9			; consistent fixed string push and drop cycle  
56e9			 
56e9 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
578d			 
578d .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5843			 
5843			;test1:		db ": aa 1 2 3 ;", 0 
5843			;test2:     	db "111 aa 888 999",0 
5843			;test3:     	db ": bb 77 ;",0 
5843			;test4:     	db "$02 $01 do i . loop bb",0 
5843			 
5843 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
587b .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58b3 .. 00		test7:     	db ": box hline vline ;",0 
58c7 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58f3 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5909 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
592e .. 00		test11:     	db "hello create .",0 
593d .. 00		test12:     	db "hello2 create .",0 
594d			 
594d			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
594d			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
594d			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
594d			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
594d			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
594d			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
594d			 
594d			;iftest1:     	db "$0001 IF cls .",0 
594d			;iftest2:     	db "$0000 IF cls .",0 
594d			;iftest3:     	db "$0002 $0003 - IF cls .",0 
594d			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
594d			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
594d			 
594d			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
594d			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
594d			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
594d			 
594d			 
594d			 
594d			; a small guess the number game 
594d			 
594d .. 00		game1:          db ": gsn rnd8 v1! ;",0 
595e .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
59c0			 
59c0 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
59f5 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5a2b .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5a5c .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5a70 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5a85 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ab9 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5afd			 
5afd			; Using 'ga' save a high score across multiple runs using external storage 
5afd			 
5afd .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5b66			 
5b66			 
5b66			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5b66			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b66			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b66			 
5b66			; simple screen saver to test code memory reuse to destruction 
5b66			 
5b66 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5b9c .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5bb8 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5bd4 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5bed .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c35 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5c8c			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c8c			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5c8c			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5c8c			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5c8c			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5c8c			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5c8c			 
5c8c			 
5c8c			 
5c8c			; minesweeper/battleship finding game 
5c8c			; draws a game board of random ship/mine positions 
5c8c			; user enters coords to see if it hits on 
5c8c			; game ends when all are hit 
5c8c			; when hit or miss says how many may be in the area 
5c8c			 
5c8c			; setup the game board and then hide it 
5c8c .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5cfa .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5d44			; prompt for where to target 
5d44 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5dda .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5dff			; TODO see if the entered coords hits or misses pushes char hit of miss 
5dff .. 00		game2mbht:      db ": mbckht nop ;",0 
5e0e .. 00		game2mbms:      db ": mbcms nop ;",0 
5e1c			; TODO how many might be near by 
5e1c .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5e99			 
5e99			; Game 3 
5e99			 
5e99			; Vert scroller ski game - avoid the trees! 
5e99			 
5e99			; v0 score (ie turns) 
5e99			; v1 player pos 
5e99			; v2 left wall 
5e99			; v3 right wall 
5e99			 
5e99			; Draw side walls randomly 
5e99			 
5e99 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5ec7			 
5ec7			; Draw player 
5ec7 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5ee5			 
5ee5			; TODO Get Key 
5ee5			 
5ee5			; TODO Move left right 
5ee5			 
5ee5			; scroll and move walls a bit 
5ee5			 
5ee5 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f16			 
5f16			; main game loop 
5f16			 
5f16 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5f42 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5f81			 
5f81			; key board defs 
5f81			 
5f81 .. 00		keyup:       db ": keyup $05 ;",0 
5f8f .. 00		keydown:       db ": keydown $0a ;",0 
5f9f .. 00		keyleft:       db ": keyleft $0b ;",0 
5faf .. 00		keyright:       db ": keyright $0c ;",0 
5fc0 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5fce .. 00		keyf2:       db ": keyf2 $11 ;",0 
5fdc .. 00		keyf3:       db ": keyf3 $12 ;",0 
5fea .. 00		keyf4:       db ": keyf4 $13 ;",0 
5ff8 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6006 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6014 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6022 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6030 .. 00		keyf9:       db ": keyf9 $18 ;",0 
603e .. 00		keyf10:       db ": keyf10 $19 ;",0 
604d .. 00		keyf11:       db ": keyf11 $1a ;",0 
605c .. 00		keyf12:       db ": keyf12 $1b ;",0 
606b			 
606b .. 00		keytab:       db ": keytab $09 ;",0 
607a .. 00		keycr:       db ": keycr $0d ;",0 
6088 .. 00		keyhome:       db ": keyhome $0e ;",0 
6098 .. 00		keyend:       db ": keyend $0f ;",0 
60a7 .. 00		keybs:       db ": keybs $08 ;",0 
60b5			 
60b5			   
60b5			 
60b5			 
60b5			 
60b5			; eof 
# End of file forth_autostart.asm
60b5			 
60b5			 
60b5			 
60b5			; stack over and underflow checks 
60b5			 
60b5			; init the words to detect the under/overflow 
60b5			 
60b5			chk_stk_init: 
60b5				; a vague random number to check so we dont get any "lucky" hits 
60b5 3e 2d			ld a, 45 
60b7 6f				ld l, a 
60b8 00				nop 
60b9 3e 17			ld a, 23 
60bb 67				ld h, a 
60bc			 
60bc 22 ac e2			ld (chk_word), hl     ; the word we need to check against 
60bf			 
60bf			;	ld (chk_stund), hl	; stack points.... 
60bf 22 00 ef			ld (chk_stovr), hl 
60c2 22 ef e9			ld (chk_ret_und), hl 
60c5 22 ad e9			ld (chk_ret_ovr), hl 
60c8 22 2b e9			ld (chk_loop_ovr), hl 
60cb 22 29 e8			ld (chk_data_ovr), hl 
60ce c9				ret 
60cf				 
60cf			check_stacks: 
60cf				; check all stack words 
60cf			 
60cf e5				push hl 
60d0 d5				push de 
60d1			 
60d1			;	ld de,(chk_word) 
60d1			;	ld hl, (chk_stund)	; stack points.... 
60d1			;	if DEBUG_STK_FAULT 
60d1			;		DMARK "FAa" 
60d1			;		CALLMONITOR 
60d1			;	endif 
60d1			;	call cmp16 
60d1			;	jp z, .chk_faulta 
60d1			; 
60d1			;	ld de, sfaultsu 
60d1			;	jp .chk_fault 
60d1			 
60d1 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
60d4 ed 5b ac e2		ld de,(chk_word) 
60d8				if DEBUG_STK_FAULT 
60d8					DMARK "FAb" 
60d8					CALLMONITOR 
60d8				endif 
60d8 cd 05 0e			call cmp16 
60db 28 06			jr z, .chk_fault1 
60dd 11 7e 61			ld de, sfaultso 
60e0 c3 32 61			jp .chk_fault 
60e3			.chk_fault1:  
60e3 2a ef e9			ld hl, (chk_ret_und) 
60e6 ed 5b ac e2		ld de,(chk_word) 
60ea				if DEBUG_STK_FAULT 
60ea					DMARK "FAU" 
60ea					CALLMONITOR 
60ea				endif 
60ea cd 05 0e			call cmp16 
60ed ca f6 60			jp z, .chk_fault2 
60f0 11 8e 61			ld de, sfaultru 
60f3 c3 32 61			jp .chk_fault 
60f6			.chk_fault2:  
60f6 2a ad e9			ld hl, (chk_ret_ovr) 
60f9 ed 5b ac e2		ld de,(chk_word) 
60fd				if DEBUG_STK_FAULT 
60fd					DMARK "FA1" 
60fd					CALLMONITOR 
60fd				endif 
60fd cd 05 0e			call cmp16 
6100 ca 09 61			jp z, .chk_fault3 
6103 11 9c 61			ld de, sfaultro 
6106 c3 32 61			jp .chk_fault 
6109			.chk_fault3:  
6109 2a 2b e9			ld hl, (chk_loop_ovr) 
610c ed 5b ac e2		ld de,(chk_word) 
6110				if DEBUG_STK_FAULT 
6110					DMARK "FA2" 
6110					CALLMONITOR 
6110				endif 
6110 cd 05 0e			call cmp16 
6113 ca 1c 61			jp z, .chk_fault4 
6116 11 b6 61			ld de, sfaultlo 
6119 c3 32 61			jp .chk_fault 
611c			.chk_fault4:  
611c 2a 29 e8			ld hl, (chk_data_ovr) 
611f ed 5b ac e2		ld de,(chk_word) 
6123				if DEBUG_STK_FAULT 
6123					DMARK "FA3" 
6123					CALLMONITOR 
6123				endif 
6123 cd 05 0e			call cmp16 
6126 ca 2f 61			jp z, .chk_fault5 
6129 11 d0 61			ld de, sfaultdo 
612c c3 32 61			jp .chk_fault 
612f			 
612f			 
612f			.chk_fault5:  
612f d1				pop de 
6130 e1				pop hl 
6131			 
6131 c9				ret 
6132			 
6132 cd ba 0b		.chk_fault: 	call clear_display 
6135 3e 28				ld a, display_row_2 
6137 cd cd 0b				call str_at_display 
613a 11 60 61				   ld de, .stackfault 
613d 3e 00				ld a, display_row_1 
613f cd cd 0b				call str_at_display 
6142 11 6e ee				    ld de, debug_mark 
6145 3e 11				ld a, display_row_1+17 
6147 cd cd 0b				call str_at_display 
614a cd dd 0b				call update_display 
614d			 
614d				; prompt before entering montior for investigating issue 
614d			 
614d 3e 78			ld a, display_row_4 
614f 11 46 19			ld de, endprog 
6152			 
6152 cd dd 0b			call update_display		 
6155			 
6155 cd cc 1b			call next_page_prompt 
6158			 
6158 d1				pop de 
6159 e1				pop hl 
615a cd 9a 19				call monitor 
615d c3 94 18				jp warmstart 
6160					;jp 0 
6160					;halt 
6160			 
6160			 
6160			 
6160 .. 00		.stackfault: 	db "Stack fault:",0 
616d			 
616d .. 00		sfaultsu: 	db	"Stack under flow",0 
617e .. 00		sfaultso: 	db	"Stack over flow",0 
618e .. 00		sfaultru:	db "RTS underflow",0 
619c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
61b6 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
61d0 .. 00		sfaultdo:	db "DTS overflow", 0 
61dd			 
61dd			 
61dd			fault_dsp_under: 
61dd 11 ef 61			ld de, .dsp_under 
61e0 c3 9f 62			jp .show_fault 
61e3			 
61e3			fault_rsp_under: 
61e3 11 fd 61			ld de, .rsp_under 
61e6 c3 9f 62			jp .show_fault 
61e9			fault_loop_under: 
61e9 11 0b 62			ld de, .loop_under 
61ec c3 9f 62			jp .show_fault 
61ef			 
61ef .. 00		.dsp_under: db "DSP Underflow",0 
61fd .. 00		.rsp_under: db "RSP Underflow",0 
620b .. 00		.loop_under: db "LOOP Underflow",0 
621a			 
621a			 
621a d5			type_faultn: 	push de 
621b e5					push hl 
621c cd ba 0b				call clear_display 
621f 11 46 62				   ld de, .typefaultn 
6222 3e 00				ld a, display_row_1 
6224 cd cd 0b				call str_at_display 
6227 11 6e ee				    ld de, debug_mark 
622a 3e 11				ld a, display_row_1+17 
622c cd cd 0b				call str_at_display 
622f cd dd 0b				call update_display 
6232			 
6232				; prompt before entering montior for investigating issue 
6232			 
6232 3e 78			ld a, display_row_4 
6234 11 46 19			ld de, endprog 
6237			 
6237 cd dd 0b			call update_display		 
623a			 
623a cd cc 1b			call next_page_prompt 
623d			 
623d e5					push hl 
623e d5					push de 
623f cd 9a 19				call monitor 
6242 c3 94 18				jp warmstart 
6245 76					halt 
6246			 
6246			 
6246 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
625d			 
625d d5			type_faults: 	push de 
625e e5					push hl 
625f cd ba 0b				call clear_display 
6262 11 88 62				   ld de, .typefaults 
6265 3e 00				ld a, display_row_1 
6267 cd cd 0b				call str_at_display 
626a 11 6e ee				    ld de, debug_mark 
626d 3e 11				ld a, display_row_1+17 
626f cd cd 0b				call str_at_display 
6272 cd dd 0b				call update_display 
6275			 
6275				; prompt before entering montior for investigating issue 
6275			 
6275 3e 78			ld a, display_row_4 
6277 11 46 19			ld de, endprog 
627a			 
627a cd dd 0b			call update_display		 
627d			 
627d cd cc 1b			call next_page_prompt 
6280			 
6280 e1					pop hl 
6281 d1					pop de 
6282 cd 9a 19				call monitor 
6285 c3 94 18				jp warmstart 
6288			 
6288			 
6288 .. 00		.typefaults: db "STR Type Expected TOS!",0 
629f			 
629f			.show_fault: 	 
629f d5					push de 
62a0 cd ba 0b				call clear_display 
62a3 d1					pop de 
62a4 3e 00				ld a, display_row_1 
62a6 cd cd 0b				call str_at_display 
62a9 11 6e ee				    ld de, debug_mark 
62ac 3e 11				ld a, display_row_1+17 
62ae cd cd 0b				call str_at_display 
62b1 cd dd 0b				call update_display 
62b4			 
62b4				; prompt before entering montior for investigating issue 
62b4			 
62b4 3e 78			ld a, display_row_4 
62b6 11 46 19			ld de, endprog 
62b9			 
62b9 cd dd 0b			call update_display		 
62bc			 
62bc cd cc 1b			call next_page_prompt 
62bf			 
62bf e1					pop hl 
62c0 d1					pop de 
62c1 cd 9a 19				call monitor 
62c4			; do a dump to cli and not warmstart so we preserve all of the uwords.  
62c4			; TODO Make optional fault restart to cli or warm boot? 
62c4					;jp warmstart 
62c4 c3 ec 18				jp cli 
62c7 76					halt 
62c8			 
62c8			; handle the auto run of code from files in storage 
62c8			 
62c8			 
62c8			include "forth_startup.asm" 
62c8			; Which startup method to use? 
62c8			; 
62c8			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
62c8			; followed by loading of a list of scripts in eeprom 
62c8			 
62c8			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
62c8			; from eeprom 
62c8			 
62c8			; Select with define in main stubs 
62c8			 
62c8			if STARTUP_V1 
62c8				include "forth_startupv1.asm" 
62c8			; Startup script loading version 1 
62c8			 
62c8			; If SE storage is available first stage is to use the selected file 
62c8			; then go through the eeprom list 
62c8			 
62c8 .. 00		sprompt1: db "Startup load...",0 
62d8 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
62ee			 
62ee			 
62ee			 
62ee			 
62ee			forth_startup: 
62ee 21 14 4e			ld hl, startcmds 
62f1 3e 00			ld a, 0 
62f3 32 ea e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
62f6			 
62f6 e5			.start1:	push hl 
62f7 cd ba 0b			call clear_display 
62fa 11 c8 62			ld de, sprompt1 
62fd 3e 00		        ld a, display_row_1 
62ff cd cd 0b			call str_at_display 
6302 11 d8 62			ld de, sprompt2 
6305 3e 28		        ld a, display_row_2 
6307 cd cd 0b			call str_at_display 
630a e1				pop hl 
630b e5				push hl 
630c 5e				ld e,(hl) 
630d 23				inc hl 
630e 56				ld d,(hl) 
630f 3e 50		        ld a, display_row_3 
6311 cd cd 0b			call str_at_display 
6314 cd dd 0b			call update_display 
6317			 
6317			 
6317 3a ea e6			ld a, (os_last_cmd) 
631a fe 00			cp 0 
631c 28 05			jr z, .startprompt 
631e cd e6 0a			call delay250ms 
6321 18 24			jr .startdo 
6323				 
6323				 
6323			 
6323			.startprompt: 
6323			 
6323 3e 9f			ld a,display_row_4 + display_cols - 1 
6325 11 ca 1b		        ld de, endprg 
6328 cd cd 0b			call str_at_display 
632b cd dd 0b			call update_display 
632e cd f2 0a			call delay1s 
6331 cd 8d 64			call cin_wait 
6334						 
6334 fe 2a			cp '*' 
6336 28 5e			jr z, .startupend1 
6338 fe 23			cp '#' 
633a 20 07			jr nz, .startno 
633c 3e 01			ld a, 1 
633e 32 ea e6			ld (os_last_cmd),a 
6341 18 04			jr .startdo 
6343 fe 31		.startno:	cp '1' 
6345 28 3a			jr z,.startnxt  
6347			 
6347				; exec startup line 
6347			.startdo:	 
6347 e1				pop hl 
6348 e5				push hl 
6349				 
6349 5e				ld e,(hl) 
634a 23				inc hl 
634b 56				ld d,(hl) 
634c eb				ex de,hl 
634d			 
634d e5				push hl 
634e			 
634e 3e 00			ld a, 0 
6350				;ld a, FORTH_END_BUFFER 
6350 cd 50 12			call strlent 
6353 23				inc hl   ; include zero term to copy 
6354 06 00			ld b,0 
6356 4d				ld c,l 
6357 e1				pop hl 
6358 11 c4 e2			ld de, scratch 
635b ed b0			ldir 
635d			 
635d			 
635d 21 c4 e2			ld hl, scratch 
6360 cd 4f 20			call forthparse 
6363 cd 8f 20			call forthexec 
6366 cd a1 1f			call forthexec_cleanup 
6369			 
6369 3e 78			ld a, display_row_4 
636b 11 46 19			ld de, endprog 
636e			 
636e cd dd 0b			call update_display		 
6371			 
6371 3a ea e6			ld a, (os_last_cmd) 
6374 fe 00			cp 0 
6376 20 09			jr nz, .startnxt 
6378 cd cc 1b			call next_page_prompt 
637b cd ba 0b		        call clear_display 
637e cd dd 0b			call update_display		 
6381			 
6381				; move onto next startup line? 
6381			.startnxt: 
6381			 
6381 cd e6 0a			call delay250ms 
6384 e1				pop hl 
6385			 
6385 23				inc hl 
6386 23				inc hl 
6387			 
6387 e5				push hl 
6388 5e				ld e, (hl) 
6389 23				inc hl 
638a 56				ld d, (hl) 
638b e1				pop hl 
638c				; TODO replace 0 test 
638c			 
638c eb				ex de, hl 
638d cd 10 0e			call ishlzero 
6390			;	ld a,e 
6390			;	add d 
6390			;	cp 0    ; any left to do? 
6390 eb				ex de, hl 
6391 c2 f6 62			jp nz, .start1 
6394 18 01			jr .startupend 
6396			 
6396 e1			.startupend1: pop hl 
6397			.startupend: 
6397			 
6397 cd ba 0b			call clear_display 
639a cd dd 0b			call update_display 
639d c9				ret 
639e			if STORAGE_SE 
639e			 
639e			sprompt3: db "Loading from start-up file?:",0 
639e			sprompt4: db "(Y=Any key/N=No)",0 
639e			 
639e			 
639e			forth_autoload: 
639e			 
639e				; load block 0 of store 1 
639e				 
639e				ld a, $fe      ; bit 0 clear 
639e				ld (spi_device), a 
639e			 
639e				call storage_get_block_0 
639e			 
639e				ld a, (store_page+STORE_0_AUTOFILE) 
639e			 
639e				cp 0 
639e				ret z     ; auto start not enabled 
639e			 
639e				call clear_display 
639e			 
639e				; set bank 
639e			 
639e					ld a, (store_page+STORE_0_BANKRUN) 
639e					ld (spi_device), a 
639e			 
639e				; get file id to load from and get the file name to display 
639e			 
639e					ld a, (store_page+STORE_0_FILERUN) 
639e			 
639e					ld l, 0 
639e					ld h, a 
639e					ld de, store_page 
639e			 
639e					if DEBUG_FORTH_WORDS 
639e						DMARK "ASp" 
639e						CALLMONITOR 
639e					endif 
639e					call storage_read 
639e			 
639e					if DEBUG_FORTH_WORDS 
639e						DMARK "ASr" 
639e						CALLMONITOR 
639e					endif 
639e			 
639e					call ishlzero 
639e					ret z             ; file not found 
639e			 
639e					ld a, display_row_2 + 10 
639e					ld de, store_page+3 
639e					call str_at_display 
639e				 
639e			; 
639e			 
639e				ld a, display_row_1+5 
639e				ld de, sprompt3 
639e				call str_at_display 
639e				ld a, display_row_3+15 
639e				ld de, sprompt4 
639e				call str_at_display 
639e			 
639e				call update_display 
639e			 
639e				call cin_wait 
639e				cp 'n' 
639e				ret z 
639e				cp 'N' 
639e				ret z 
639e			 
639e				call delay1s 
639e			 
639e				ld a, (store_page+2) 
639e				ld (store_openmaxext), a    ; save count of ext 
639e				ld a, 1  
639e				ld (store_openext), a    ; save count of ext 
639e			 
639e			.autof:  
639e				ld l , a 
639e				 
639e				ld a, (store_page) 
639e				ld h, a	 
639e				ld de, store_page 
639e					if DEBUG_FORTH_WORDS 
639e						DMARK "ASl" 
639e						CALLMONITOR 
639e					endif 
639e					call storage_read 
639e				call ishlzero 
639e				ret z 
639e			;	jr z, .autoend 
639e			 
639e					if DEBUG_FORTH_WORDS 
639e						DMARK "ASc" 
639e						CALLMONITOR 
639e					endif 
639e				ld de, store_page+2 
639e				ld a, display_row_4 
639e				call str_at_display 
639e			 
639e				call update_display 
639e				call delay250ms 
639e			 
639e			 
639e			 
639e				ld hl, store_page+2 
639e				call forthparse 
639e				call forthexec 
639e				call forthexec_cleanup 
639e			 
639e				 
639e				ld a, (store_openext) 
639e				inc a 
639e				ld (store_openext), a    ; save count of ext 
639e			 
639e				jr .autof 
639e			;.autofdone: 
639e			; 
639e			;		if DEBUG_FORTH_WORDS 
639e			;			DMARK "ASx" 
639e			;			CALLMONITOR 
639e			;		endif 
639e			;;	call clear_display 
639e			;	ret 
639e			 
639e			 
639e			 
639e			endif 
# End of file forth_startupv1.asm
639e			endif 
639e			if STARTUP_V2 
639e				include "forth_startupv2.asm" 
639e			endif 
639e			 
# End of file forth_startup.asm
639e			 
639e			; eof 
# End of file forth_kernel.asm
639e			;include "nascombasic.asm" 
639e			 
639e			 
639e			; find out where the code ends if loaded into RAM (for SC114) 
639e			;endofcode:  
639e			;	nop 
639e			 
639e			 
639e			; eof 
639e			 
# End of file main.asm
639e			;include "firmware_lcd_4x40.asm" 
639e			;;include "firmware_lcd_4x20.asm" 
639e			include "firmware_cpm_display.asm" 
639e			 
639e			; Serial display interface for SC114 
639e			 
639e			 
639e			display_row_1: equ 0 
639e			display_row_2: equ display_row_1+display_cols 
639e			display_row_3: equ display_row_2 + display_cols 
639e			display_row_4: equ display_row_3 + display_cols 
639e			 
639e			kLCDWidth:  EQU display_cols             ;Width in characters 
639e			kLCD_Line1: EQU 0x00  
639e			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
639e			; E1 
639e			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
639e			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
639e			 
639e			lcd_init: 
639e				; no init as handled by the SCM bios 
639e c9				ret 
639f			 
639f			 
639f			; low level functions for direct screen writes 
639f			 
639f			; output char at pos? 
639f			fLCD_Str: 
639f			        ;out (SC114_SIO_1_OUT),a 
639f c5				push bc 
63a0 d5				push de 
63a1 5f				ld e, a 
63a2			; TODO Replace with CP/M BIOS call 
63a2 0e 02			ld c, $02 
63a4 cd 05 00			call 5 
63a7 d1				pop de 
63a8 c1				pop bc 
63a9 c9				ret 
63aa			 
63aa			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
63aa			fLCD_Pos: 
63aa				; use ASCII escape to position 
63aa			        ;out (SC114_SIO_1_OUT),a 
63aa c5				push bc 
63ab d5				push de 
63ac 5f				ld e, a 
63ad 0e 02			ld c, $02 
63af			; TODO Replace with CP/M BIOS call 
63af cd 05 00			call 5 
63b2 d1				pop de 
63b3 c1				pop bc 
63b4			 
63b4 c9				ret 
63b5			 
63b5			; output char at pos 
63b5			fLCD_Data: 
63b5			      ;  out (SC114_SIO_1_OUT),a 
63b5 c5				push bc 
63b6 d5				push de 
63b7 0e 02			ld c, $02 
63b9 5f				ld e, a 
63ba			; TODO Replace with CP/M BIOS call 
63ba cd 05 00			call 5 
63bd d1				pop de 
63be c1				pop bc 
63bf			 
63bf c9				ret 
63c0			 
63c0			; ascii cls  
63c0			 
63c0 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
63c4			 
63c4 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
63db			;.clscpm: db 3, $3c,"$" 
63db			 
63db			; write the frame buffer given in hl to hardware  
63db			write_display: 
63db			 
63db			API: equ 0 
63db			 
63db			if API 
63db				push bc 
63db				ld b, 4 
63db			 
63db			        ld (display_write_tmp), hl 	  
63db			 
63db				; clear and home cursor 
63db			 
63db				ld c, 9 
63db				ld de, .cls 
63db			; TODO Replace with CP/M BIOS call 
63db				call 5 
63db			 
63db			 
63db			.writeln: 
63db			 
63db				ld de, (display_write_tmp) 
63db				ld c, 6 
63db			; TODO Replace with CP/M BIOS call 
63db				rst $30 
63db				ld c, 7 
63db				rst $30 
63db			 
63db				ld hl, (display_write_tmp) 
63db				ld de, display_cols 
63db				add hl,de 
63db				ld (display_write_tmp),hl 
63db			 
63db				djnz  .writeln 
63db			 
63db				pop bc 
63db			 
63db			 
63db				ret 
63db			endif 
63db e5				push hl 
63dc c5				push bc 
63dd d5				push de 
63de			 
63de			;	ld c, 2 
63de			;	;ld de, .cls 
63de			;	ld a, 27 
63de			;	rst $30 
63de			;	ld c, 2 
63de			;	;ld de, .cls 
63de			;	ld a, '[' 
63de			;	rst $30 
63de			; 
63de			;	ld c, 2 
63de			;	;ld de, .cls 
63de			;	ld a, 'H' 
63de			;	rst $30 
63de			; 
63de			 
63de			 
63de			; lots of CR/LF 
63de			;	ld c, 9 
63de			;	ld de, .clscpm 
63de			;	call 5 
63de			 
63de			; xterm cls 
63de 0e 02			ld c, 2 
63e0 1e 1b			ld e, 27 
63e2 cd 05 00			call 5 
63e5			; cls causes too much flicker 
63e5			;	ld c, 2 
63e5			;	ld e, 'c' 
63e5			;	call 5 
63e5			 
63e5			; use xterm home instead 
63e5 0e 02			ld c, 2 
63e7 1e 5b			ld e, '[' 
63e9 cd 05 00			call 5 
63ec 0e 02			ld c, 2 
63ee 1e 48			ld e, 'H' 
63f0 cd 05 00			call 5 
63f3			LLL: equ 0 
63f3			 
63f3			if LLL 
63f3			 
63f3				ld c, 2 
63f3				;ld de, .cls 
63f3				ld e, 27 
63f3			; TODO Replace with CP/M BIOS call 
63f3				call 5 
63f3			 
63f3			 
63f3				ld c, 2 
63f3				;ld de, .cls 
63f3				ld e, '[' 
63f3			; TODO Replace with CP/M BIOS call 
63f3				call 5 
63f3				ld c, 2 
63f3				;ld de, .cls 
63f3				ld e, '2' 
63f3			; TODO Replace with CP/M BIOS call 
63f3				call 5 
63f3				ld c, 2 
63f3				;ld de, .cls 
63f3				ld e, 'J' 
63f3			; TODO Replace with CP/M BIOS call 
63f3				call 5 
63f3			 
63f3			endif 
63f3			 
63f3 d1				pop de 
63f4 c1				pop bc 
63f5 e1				pop hl 
63f6			 
63f6			 
63f6 22 cc eb		        ld (display_write_tmp), hl 	  
63f9 3e 00			ld a, kLCD_Line1 
63fb			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
63fb 06 28			ld b, display_cols 
63fd ed 5b cc eb		ld de, (display_write_tmp) 
6401 cd 84 64			call write_len_string 
6404				 
6404			 
6404 e5			push hl 
6405 d5			push de 
6406 c5			push bc 
6407 0e 02			ld c, 2 
6409 1e 0a			ld e, 10 
640b cd 05 00			call 5 
640e 0e 02			ld c, 2 
6410 1e 0d			ld e, 13 
6412 cd 05 00			call 5 
6415			; TODO Replace with CP/M BIOS call 
6415				;rst $30 
6415 c1			pop bc 
6416 d1			pop de 
6417 e1			pop hl 
6418			 
6418				 
6418 2a cc eb			ld hl, (display_write_tmp) 
641b 11 28 00			ld de, display_cols 
641e 19				add hl,de 
641f 22 cc eb			ld (display_write_tmp),hl 
6422			 
6422				 
6422 3e 28			ld a, kLCD_Line2 
6424			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6424 06 28			ld b, display_cols 
6426 ed 5b cc eb		ld de, (display_write_tmp) 
642a cd 84 64			call write_len_string 
642d				 
642d 2a cc eb			ld hl, (display_write_tmp) 
6430 11 28 00			ld de, display_cols 
6433 19				add hl,de 
6434 22 cc eb			ld (display_write_tmp),hl 
6437			 
6437 e5			push hl 
6438 d5			push de 
6439 c5			push bc 
643a 0e 07			ld c, 7 
643c			; TODO Replace with CP/M BIOS call 
643c				;rst $30 
643c 0e 02			ld c, 2 
643e 1e 0a			ld e, 10 
6440 cd 05 00			call 5 
6443 0e 02			ld c, 2 
6445 1e 0d			ld e, 13 
6447 cd 05 00			call 5 
644a c1			pop bc 
644b d1			pop de 
644c e1			pop hl 
644d			 
644d				 
644d 3e 50			ld a, kLCD_Line3 
644f			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
644f 06 28			ld b, display_cols 
6451 ed 5b cc eb		ld de, (display_write_tmp) 
6455 cd 84 64			call write_len_string 
6458				 
6458 2a cc eb			ld hl, (display_write_tmp) 
645b 11 28 00			ld de, display_cols 
645e 19				add hl,de 
645f 22 cc eb			ld (display_write_tmp),hl 
6462			 
6462 e5			push hl 
6463 d5			push de 
6464 c5			push bc 
6465 0e 07			ld c, 7 
6467			; TODO Replace with CP/M BIOS call 
6467				;rst $30 
6467 0e 02			ld c, 2 
6469 1e 0a			ld e, 10 
646b cd 05 00			call 5 
646e 0e 02			ld c, 2 
6470 1e 0d			ld e, 13 
6472 cd 05 00			call 5 
6475 c1			pop bc 
6476 d1			pop de 
6477 e1			pop hl 
6478			 
6478				 
6478 3e 78			ld a, kLCD_Line4 
647a			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
647a 06 28			ld b, display_cols 
647c ed 5b cc eb		ld de, (display_write_tmp) 
6480 cd 84 64			call write_len_string 
6483 c9					ret 
6484			 
6484			 
6484				; write out a fixed length string given in b from de 
6484			 
6484 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6485 cd b5 63		            CALL fLCD_Data      ;Write character to display 
6488 13				inc de 
6489 10 f9			djnz write_len_string 
648b c9				ret 
648c			 
648c			 
648c			; eof 
# End of file firmware_cpm_display.asm
648c			;include "firmware_key_5x10.asm" 
648c			;;include "firmware_key_4x10.asm" 
648c			include "firmware_key_cpm.asm" 
648c			; Serial keyboard interface for SC114 
648c			 
648c			 
648c			key_init: 
648c				; no init as handled by the SCM bios 
648c c9				ret 
648d			 
648d			 
648d			cin_wait: 
648d			;	ld a, 0 
648d			;	ret 
648d			 
648d				;in a,(SC114_SIO_1_IN) 
648d			        ; Use SCM API to get from whatever console device we are using 
648d			 
648d			; TODO Replace with CP/M BIOS call 
648d c5				push bc 
648e 0e 01			ld c, $01 
6490 cd 05 00			call 5 
6493 c1				pop bc 
6494 c9				ret 
6495			 
6495			cin: 
6495			 
6495			 
6495 c5				push bc 
6496			 
6496				; any key waiting to process? 
6496			; TODO Replace with CP/M BIOS call 
6496 0e 06			ld c, $06 
6498 cd 05 00			call 5 
649b 28 0d			jr z, .cin_skip 
649d			 
649d				; yep, get it 
649d			 
649d 0e 01			ld c, $01 
649f			; TODO Replace with CP/M BIOS call 
649f cd 05 00			call 5 
64a2			 
64a2 fe 7f			cp $7f     ; back space 
64a4 20 02			jr nz, .skipbs 
64a6 3e 08			ld a, KEY_BS 
64a8			.skipbs: 
64a8			 
64a8 c1				pop bc 
64a9 c9				ret 
64aa			.cin_skip: 
64aa 3e 00			ld a, 0 
64ac c1				pop bc 
64ad c9				ret 
64ae			 
64ae			 
64ae			 
64ae			 
# End of file firmware_key_cpm.asm
64ae			endofcode:  
64ae			baseram:  
64ae 00				nop 
64af			 
64af			heap_start: equ baseram+15  ; Starting address of heap 
64af			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
64af			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
64af			;VDU:  EQU     endofcode           ; BASIC Work space 
64af			; eof 
64af			 
# End of file os_mega_cpm.asm
64af
