# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 bf 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-09-11 17:03' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			STORE_0_BANKRUNN: equ $25   ; human readable bank id  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
011f			  
011f			debug_umark: equ parse_vector - 6  ; current user mark  
011f			debug_mark: equ debug_umark - 4    ; internal word debug points  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 07 ed				ld hl, display_fb1  
0122 22 c3 eb				ld (display_fb_active), hl  
0125			  
0125 cd b7 0b				call clear_display  
0128			  
0128 21 c5 eb				ld hl, display_fb2  
012b 22 c3 eb				ld (display_fb_active), hl  
012e			  
012e cd b7 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 a8 ed				ld hl, display_fb0  
0134 22 c3 eb				ld (display_fb_active), hl  
0137			  
0137 cd b7 0b				call clear_display  
013a			  
013a			  
013a cd b9 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd a7 65			call key_init  
0140 cd ad 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd 89 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd d9 0b			call update_display  
0149 cd f0 0a			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd bc 0b			call fill_display  
0151 cd d9 0b			call update_display  
0154 cd f0 0a			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd bc 0b			call fill_display  
015c cd d9 0b			call update_display  
015f cd f0 0a			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd bc 0b			call fill_display  
0167 cd d9 0b			call update_display  
016a cd f0 0a			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 2c 16			ld de, prom_bootmsg  
0172 cd c9 0b			call str_at_display  
0175 cd d9 0b			call update_display  
0178			  
0178			  
0178 cd f0 0a			call delay1s  
017b cd f0 0a			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 41 16			ld de, prom_bootmsg1  
0183 cd c9 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd c9 0b			call str_at_display  
018e			  
018e cd d9 0b			call update_display  
0191 cd f0 0a			call delay1s  
0194 cd f0 0a			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 62 ee		ld (debug_mark),a  
019c 32 63 ee		ld (debug_mark+1),a  
019f 32 64 ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 65 ee		ld (debug_mark+3),a  
01a7 32 66 ee		ld (debug_umark),a  
01aa			  
01aa c9					ret  
01ab			  
01ab			  
01ab			;bootmsg2:	db "Firmware v0.1",0  
01ab			  
01ab			; a 4x20 lcd  
01ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ab			  
01ab			;if display_cols == 20  
01ab			;	include "firmware_lcd_4x20.asm"  
01ab			;endif  
01ab			  
01ab			;if display_cols == 40  
01ab			;	include "firmware_lcd_4x40.asm"  
01ab			;endif  
01ab			  
01ab			;  
01ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ab			; TODO abstract the bit bang video out interface for dual display  
01ab			; TODO wire video out to tx pin on rc2014 bus  
01ab			  
01ab			; must supply cin, and cin_wait for low level hardware abstraction   
01ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ab			; test scancode  
01ab			  
01ab			;;;;;  
01ab			;;;  
01ab			; Moved out to mini and maxi versions  
01ab			;  
01ab			; include "firmware_key_4x4.asm"  
01ab			; using existing 4 wire x 4 resistor array for input  
01ab			;include "firmware_key_4x10.asm"  
01ab			; need to mod the board for 5 rows due to resistor array  
01ab			;include "firmware_key_5x10.asm"  
01ab			  
01ab			; storage hardware interface  
01ab			  
01ab			; use microchip serial eeprom for storage  
01ab			  
01ab			  
01ab			if STORAGE_SE  
01ab				include "firmware_spi.asm"  
01ab				include "firmware_seeprom.asm"  
01ab			else  
01ab			   ; create some stubs for the labels  
01ab c9			se_readbyte: ret  
01ac c9			se_writebyte: ret  
01ad c9			storage_init: ret  
01ae			  
01ae			endif  
01ae			  
01ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ae			;include "firmware_cf.asm"  
01ae			  
01ae			; load up high level storage hardward abstractions  
01ae			include "firmware_storage.asm"  
01ae			 
01ae			; persisent storage hardware abstraction layer  
01ae			 
01ae			 
01ae			 
01ae			; Block 0 on storage is a config state 
01ae			 
01ae			 
01ae			 
01ae			; TODO add read phy block and write phy block functions 
01ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ae			 
01ae			; Abstraction layer  
01ae			 
01ae			; Logocial block size is same size as physical size - using tape concept 
01ae			 
01ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ae			 
01ae			 
01ae			 
01ae			; Filesystem layout (Logical layout) 
01ae			; 
01ae			; Block 0 - Bank config  
01ae			; 
01ae			;      Byte - 0 file id counter 
01ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ae			;      Byte - 3-20 zero terminated bank label 
01ae			; 
01ae			; Block 1 > File storage 
01ae			; 
01ae			;      Byte 0 file id    - block 0 file details 
01ae			;      Byte 1 block id - block 0 is file  
01ae			;            Byte 2-15 - File name 
01ae			; 
01ae			;       - to end of block data 
01ae			; 
01ae			 
01ae			; Get ID for the file named in pointer held HL 
01ae			; Returns ID in HL = 255 if no file found 
01ae			 
01ae			storage_getid: 
01ae			 
01ae 22 6a ea			ld (store_tmp1), hl 
01b1			 
01b1				if DEBUG_STORESE 
01b1					DMARK "SGI" 
01b1 f5				push af  
01b2 3a c6 01			ld a, (.dmark)  
01b5 32 62 ee			ld (debug_mark),a  
01b8 3a c7 01			ld a, (.dmark+1)  
01bb 32 63 ee			ld (debug_mark+1),a  
01be 3a c8 01			ld a, (.dmark+2)  
01c1 32 64 ee			ld (debug_mark+2),a  
01c4 18 03			jr .pastdmark  
01c6 ..			.dmark: db "SGI"  
01c9 f1			.pastdmark: pop af  
01ca			endm  
# End of macro DMARK
01ca					CALLMONITOR 
01ca cd 6f ee			call debug_vector  
01cd				endm  
# End of macro CALLMONITOR
01cd				endif 
01cd				; get block 0 and set counter for number of files to scan 
01cd			 
01cd cd 35 03			call storage_get_block_0 
01d0			 
01d0 3a 71 ea			ld a, (store_page) 
01d3 47				ld b, a 
01d4			 
01d4				; get extent 0 of each file id 
01d4			 
01d4				if DEBUG_STORESE 
01d4					DMARK "SGc" 
01d4 f5				push af  
01d5 3a e9 01			ld a, (.dmark)  
01d8 32 62 ee			ld (debug_mark),a  
01db 3a ea 01			ld a, (.dmark+1)  
01de 32 63 ee			ld (debug_mark+1),a  
01e1 3a eb 01			ld a, (.dmark+2)  
01e4 32 64 ee			ld (debug_mark+2),a  
01e7 18 03			jr .pastdmark  
01e9 ..			.dmark: db "SGc"  
01ec f1			.pastdmark: pop af  
01ed			endm  
# End of macro DMARK
01ed					CALLMONITOR 
01ed cd 6f ee			call debug_vector  
01f0				endm  
# End of macro CALLMONITOR
01f0				endif 
01f0 60			.getloop:	ld h, b 
01f1 2e 00				ld l, 0 
01f3 c5					push bc 
01f4			 
01f4 11 71 ea				ld de, store_page 
01f7				if DEBUG_STORESE 
01f7					DMARK "SGr" 
01f7 f5				push af  
01f8 3a 0c 02			ld a, (.dmark)  
01fb 32 62 ee			ld (debug_mark),a  
01fe 3a 0d 02			ld a, (.dmark+1)  
0201 32 63 ee			ld (debug_mark+1),a  
0204 3a 0e 02			ld a, (.dmark+2)  
0207 32 64 ee			ld (debug_mark+2),a  
020a 18 03			jr .pastdmark  
020c ..			.dmark: db "SGr"  
020f f1			.pastdmark: pop af  
0210			endm  
# End of macro DMARK
0210					CALLMONITOR 
0210 cd 6f ee			call debug_vector  
0213				endm  
# End of macro CALLMONITOR
0213				endif 
0213 cd d7 07				call storage_read 
0216 cd 0a 0e				call ishlzero 
0219 28 2d				jr z, .gap 
021b					 
021b					; have a file name read. Is it one we want. 
021b			 
021b 2a 6a ea				ld hl, (store_tmp1) 
021e 11 74 ea				ld de, store_page+3   ; file name 
0221			 
0221				if DEBUG_STORESE 
0221					DMARK "SGc" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 62 ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 63 ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 64 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGc"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 6f ee			call debug_vector  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d cd 71 11				call strcmp 
0240 20 06				jr nz, .gap   ; not this one 
0242			 
0242 c1				        pop bc 
0243			 
0243 26 00				ld h, 0 
0245 68					ld l, b 
0246 18 22				jr .getdone 
0248						 
0248			 
0248			 
0248			 
0248			.gap: 
0248				if DEBUG_STORESE 
0248					DMARK "SGg" 
0248 f5				push af  
0249 3a 5d 02			ld a, (.dmark)  
024c 32 62 ee			ld (debug_mark),a  
024f 3a 5e 02			ld a, (.dmark+1)  
0252 32 63 ee			ld (debug_mark+1),a  
0255 3a 5f 02			ld a, (.dmark+2)  
0258 32 64 ee			ld (debug_mark+2),a  
025b 18 03			jr .pastdmark  
025d ..			.dmark: db "SGg"  
0260 f1			.pastdmark: pop af  
0261			endm  
# End of macro DMARK
0261					CALLMONITOR 
0261 cd 6f ee			call debug_vector  
0264				endm  
# End of macro CALLMONITOR
0264				endif 
0264			 
0264 c1					pop bc 
0265 10 89				djnz .getloop 
0267 21 ff 00				ld hl, 255 
026a			.getdone: 
026a			 
026a				if DEBUG_STORESE 
026a					DMARK "SGe" 
026a f5				push af  
026b 3a 7f 02			ld a, (.dmark)  
026e 32 62 ee			ld (debug_mark),a  
0271 3a 80 02			ld a, (.dmark+1)  
0274 32 63 ee			ld (debug_mark+1),a  
0277 3a 81 02			ld a, (.dmark+2)  
027a 32 64 ee			ld (debug_mark+2),a  
027d 18 03			jr .pastdmark  
027f ..			.dmark: db "SGe"  
0282 f1			.pastdmark: pop af  
0283			endm  
# End of macro DMARK
0283					CALLMONITOR 
0283 cd 6f ee			call debug_vector  
0286				endm  
# End of macro CALLMONITOR
0286				endif 
0286			 
0286 c9				ret 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			; Read Block 
0287			; ---------- 
0287			; 
0287			; With current bank 
0287			;  
0287			; Get block number to read 
0287			; Load physical blocks starting at start block into buffer 
0287			 
0287			; de points to buffer to use 
0287			; hl holds logical block number  
0287			 
0287			storage_read_block: 
0287			 
0287				; TODO bank selection 
0287			 
0287				; for each of the physical blocks read it into the buffer 
0287 06 40			ld b, STORE_BLOCK_PHY 
0289			 
0289				if DEBUG_STORESE 
0289 d5					push de 
028a				endif 
028a				 
028a			.rl1:    
028a			 
028a				; read physical block at hl into de 
028a			        ; increment hl and de to next read position on exit 
028a			 
028a e5				push hl 
028b d5				push de	 
028c c5				push bc 
028d			;	if DEBUG_STORESE 
028d			;		push af 
028d			;		ld a, 'R' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d cd ab 01			call se_readbyte 
0290			;	if DEBUG_STORESE 
0290			;		ld a,(spi_portbyte) 
0290			;		ld l, a 
0290			;		push af 
0290			;		ld a, '1' 
0290			;		ld (debug_mark),a 
0290			;		pop af 
0290			;		CALLMONITOR 
0290			;	endif 
0290 c1				pop bc 
0291 d1				pop de 
0292 e1				pop hl 
0293 12				ld (de),a 
0294 23				inc hl 
0295 13				inc de 
0296			 
0296			;	if DEBUG_STORESE 
0296			;		push af 
0296			;		ld a, 'r' 
0296			;		ld (debug_mark),a 
0296			;		pop af 
0296			;		CALLMONITOR 
0296			;	endif 
0296			 
0296 10 f2			djnz .rl1 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SRB" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 62 ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 63 ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 64 ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SRB"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1 d1					pop de 
02b2			; 
02b2			;		push af 
02b2			;		ld a, 'R' 
02b2			;		ld (debug_mark),a 
02b2			;		pop af 
02b2					CALLMONITOR 
02b2 cd 6f ee			call debug_vector  
02b5				endm  
# End of macro CALLMONITOR
02b5				endif 
02b5 c9				ret	 
02b6				 
02b6			 
02b6			; File Size 
02b6			; --------- 
02b6			; 
02b6			;   hl file id 
02b6			; 
02b6			;  returns in hl the number of blocks 
02b6			 
02b6			storage_file_size: 
02b6 5d				ld e, l 
02b7 16 00			ld d, 0 
02b9 21 40 00			ld hl, STORE_BLOCK_PHY 
02bc					if DEBUG_FORTH_WORDS 
02bc						DMARK "SIZ" 
02bc f5				push af  
02bd 3a d1 02			ld a, (.dmark)  
02c0 32 62 ee			ld (debug_mark),a  
02c3 3a d2 02			ld a, (.dmark+1)  
02c6 32 63 ee			ld (debug_mark+1),a  
02c9 3a d3 02			ld a, (.dmark+2)  
02cc 32 64 ee			ld (debug_mark+2),a  
02cf 18 03			jr .pastdmark  
02d1 ..			.dmark: db "SIZ"  
02d4 f1			.pastdmark: pop af  
02d5			endm  
# End of macro DMARK
02d5						CALLMONITOR 
02d5 cd 6f ee			call debug_vector  
02d8				endm  
# End of macro CALLMONITOR
02d8					endif 
02d8 cd b3 05			call storage_findnextid 
02db			 
02db cd 0a 0e			call ishlzero 
02de			;	ld a, l 
02de			;	add h 
02de			;	cp 0 
02de c8				ret z			; block not found so EOF 
02df			 
02df 11 71 ea			ld de, store_page 
02e2 cd 87 02			call storage_read_block 
02e5			 
02e5 3a 73 ea			ld a, (store_page+2)	 ; get extent count 
02e8 6f				ld l, a 
02e9 26 00			ld h, 0 
02eb c9			 	ret 
02ec			 
02ec			 
02ec			; Write Block 
02ec			; ----------- 
02ec			; 
02ec			; With current bank 
02ec			;  
02ec			; Get block number to write 
02ec			; Write physical blocks starting at start block from buffer 
02ec			  
02ec			storage_write_block: 
02ec				; TODO bank selection 
02ec			 
02ec				; for each of the physical blocks read it into the buffer 
02ec 06 40			ld b, STORE_BLOCK_PHY 
02ee			 
02ee				if DEBUG_STORESE 
02ee					DMARK "SWB" 
02ee f5				push af  
02ef 3a 03 03			ld a, (.dmark)  
02f2 32 62 ee			ld (debug_mark),a  
02f5 3a 04 03			ld a, (.dmark+1)  
02f8 32 63 ee			ld (debug_mark+1),a  
02fb 3a 05 03			ld a, (.dmark+2)  
02fe 32 64 ee			ld (debug_mark+2),a  
0301 18 03			jr .pastdmark  
0303 ..			.dmark: db "SWB"  
0306 f1			.pastdmark: pop af  
0307			endm  
# End of macro DMARK
0307			 
0307					;push af 
0307					;ld a, 'W' 
0307					;ld (debug_mark),a 
0307					;pop af 
0307					CALLMONITOR 
0307 cd 6f ee			call debug_vector  
030a				endm  
# End of macro CALLMONITOR
030a				endif 
030a			 
030a			; might not be working 
030a			;	call se_writepage 
030a			 
030a			;	ret 
030a			; 
030a			 
030a			 
030a			 
030a			.wl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d 1a				ld a,(de) 
030e				;if DEBUG_STORESE 
030e			;		push af 
030e			;		ld a, 'W' 
030e			;		ld (debug_mark),a 
030e			;		pop af 
030e			;		CALLMONITOR 
030e			;	endif 
030e cd ac 01			call se_writebyte 
0311			;	call delay250ms 
0311			;	nop 
0311			;	nop 
0311			;	nop 
0311			;	if DEBUG_STORESE 
0311			;		push af 
0311			;		ld a, 'w' 
0311			;		ld (debug_mark),a 
0311			;		pop af 
0311			;		CALLMONITOR 
0311			;	endif 
0311 c1				pop bc 
0312 d1				pop de 
0313 e1				pop hl 
0314 23				inc hl 
0315 13				inc de 
0316			 
0316			 
0316 10 f2			djnz .wl1 
0318			 
0318				if DEBUG_STORESE 
0318					DMARK "SW2" 
0318 f5				push af  
0319 3a 2d 03			ld a, (.dmark)  
031c 32 62 ee			ld (debug_mark),a  
031f 3a 2e 03			ld a, (.dmark+1)  
0322 32 63 ee			ld (debug_mark+1),a  
0325 3a 2f 03			ld a, (.dmark+2)  
0328 32 64 ee			ld (debug_mark+2),a  
032b 18 03			jr .pastdmark  
032d ..			.dmark: db "SW2"  
0330 f1			.pastdmark: pop af  
0331			endm  
# End of macro DMARK
0331			 
0331					;push af 
0331					;ld a, 'W' 
0331					;ld (debug_mark),a 
0331					;pop af 
0331					CALLMONITOR 
0331 cd 6f ee			call debug_vector  
0334				endm  
# End of macro CALLMONITOR
0334				endif 
0334 c9				ret	 
0335			 
0335			; Init bank 
0335			; --------- 
0335			; 
0335			; With current bank 
0335			; 
0335			; Setup block 0 config 
0335			;     Set 0 file id counter 
0335			;     Set formatted byte pattern 
0335			;     Zero out bank label 
0335			;      
0335			; For every logical block write 0-1 byte as null 
0335			 
0335			storage_get_block_0: 
0335			 
0335				; TODO check presence 
0335			 
0335				; get block 0 config 
0335			 
0335 21 00 00			ld hl, 0 
0338 11 71 ea			ld de, store_page 
033b cd 87 02			call storage_read_block 
033e			 
033e				if DEBUG_STORESE 
033e					DMARK "SB0" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 62 ee			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 63 ee			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 64 ee			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SB0"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357 11 71 ea				ld de, store_page 
035a			;		push af 
035a			;		ld a, 'i' 
035a			;		ld (debug_mark),a 
035a			;		pop af 
035a					CALLMONITOR 
035a cd 6f ee			call debug_vector  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d			 
035d				; is this area formatted? 
035d			 
035d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
035d 2a 72 ea			ld hl, (store_page+1) 
0360 3e 80			ld a,0x80 
0362 bd				cp l 
0363 20 22			jr nz, .ininotformatted 
0365				; do a double check 
0365 3e 27			ld a, 0x27 
0367 bc				cp h 
0368 20 1d			jr nz, .ininotformatted 
036a			 
036a				; formatted then 
036a			 
036a				if DEBUG_STORESE 
036a					DMARK "SB1" 
036a f5				push af  
036b 3a 7f 03			ld a, (.dmark)  
036e 32 62 ee			ld (debug_mark),a  
0371 3a 80 03			ld a, (.dmark+1)  
0374 32 63 ee			ld (debug_mark+1),a  
0377 3a 81 03			ld a, (.dmark+2)  
037a 32 64 ee			ld (debug_mark+2),a  
037d 18 03			jr .pastdmark  
037f ..			.dmark: db "SB1"  
0382 f1			.pastdmark: pop af  
0383			endm  
# End of macro DMARK
0383					;push af 
0383					;ld a, 'I' 
0383					;ld (debug_mark),a 
0383					;pop af 
0383					CALLMONITOR 
0383 cd 6f ee			call debug_vector  
0386				endm  
# End of macro CALLMONITOR
0386				endif 
0386 c9				ret 
0387			 
0387			.ininotformatted: 
0387				; bank not formatted so poke various bits to make sure 
0387			 
0387				if DEBUG_STORESE 
0387					DMARK "SB2" 
0387 f5				push af  
0388 3a 9c 03			ld a, (.dmark)  
038b 32 62 ee			ld (debug_mark),a  
038e 3a 9d 03			ld a, (.dmark+1)  
0391 32 63 ee			ld (debug_mark+1),a  
0394 3a 9e 03			ld a, (.dmark+2)  
0397 32 64 ee			ld (debug_mark+2),a  
039a 18 03			jr .pastdmark  
039c ..			.dmark: db "SB2"  
039f f1			.pastdmark: pop af  
03a0			endm  
# End of macro DMARK
03a0					;push af 
03a0					;ld a, 'f' 
03a0					;ld (debug_mark),a 
03a0					;pop af 
03a0					CALLMONITOR 
03a0 cd 6f ee			call debug_vector  
03a3				endm  
# End of macro CALLMONITOR
03a3				endif 
03a3			 
03a3 cd b4 0a			call storage_clear_page 
03a6			 
03a6 21 71 ea			ld hl, store_page 
03a9			;	ld a, 0 
03a9				 
03a9 36 00			ld (hl),0   ; reset file counter 
03ab			 
03ab 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03ae 22 72 ea		 	ld (store_page+1), hl	 
03b1			 
03b1				; set default label 
03b1			 
03b1 21 4a 04			ld hl, .defaultbanklabl 
03b4 11 74 ea		 	ld de, store_page+3 
03b7 01 0f 00			ld bc, 15 
03ba ed b0			ldir 
03bc			 
03bc				; Append the current bank id 
03bc 21 7d ea			ld hl, store_page+3+9 
03bf 3a 56 ea			ld a, (spi_device_id) 
03c2 77				ld (hl), a 
03c3			 
03c3				; save default page 0 
03c3			 
03c3 21 00 00			ld hl, 0 
03c6 11 71 ea			ld de, store_page 
03c9				if DEBUG_STORESE 
03c9					DMARK "SB3" 
03c9 f5				push af  
03ca 3a de 03			ld a, (.dmark)  
03cd 32 62 ee			ld (debug_mark),a  
03d0 3a df 03			ld a, (.dmark+1)  
03d3 32 63 ee			ld (debug_mark+1),a  
03d6 3a e0 03			ld a, (.dmark+2)  
03d9 32 64 ee			ld (debug_mark+2),a  
03dc 18 03			jr .pastdmark  
03de ..			.dmark: db "SB3"  
03e1 f1			.pastdmark: pop af  
03e2			endm  
# End of macro DMARK
03e2			;		push af 
03e2			;		ld a, 'F' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 6f ee			call debug_vector  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5 cd ec 02			call storage_write_block 
03e8				if DEBUG_STORESE 
03e8					DMARK "SB4" 
03e8 f5				push af  
03e9 3a fd 03			ld a, (.dmark)  
03ec 32 62 ee			ld (debug_mark),a  
03ef 3a fe 03			ld a, (.dmark+1)  
03f2 32 63 ee			ld (debug_mark+1),a  
03f5 3a ff 03			ld a, (.dmark+2)  
03f8 32 64 ee			ld (debug_mark+2),a  
03fb 18 03			jr .pastdmark  
03fd ..			.dmark: db "SB4"  
0400 f1			.pastdmark: pop af  
0401			endm  
# End of macro DMARK
0401			;		push af 
0401			;		ld a, '>' 
0401			;		ld (debug_mark),a 
0401			;		pop af 
0401					CALLMONITOR 
0401 cd 6f ee			call debug_vector  
0404				endm  
# End of macro CALLMONITOR
0404				endif 
0404			 
0404			;	nop 
0404			;	nop 
0404			;	nop 
0404			 
0404				; now set 0 in every page to mark as a free block 
0404			 
0404 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0406 21 40 00			ld hl, STORE_BLOCK_PHY 
0409			 
0409 3e 00		.setmark1:   	ld a,0 
040b e5					push hl 
040c c5					push bc 
040d cd ac 01				call se_writebyte 
0410 3e 0a			ld a, 10 
0412 cd d5 0a			call aDelayInMS 
0415 23				inc hl 
0416 cd ac 01				call se_writebyte 
0419 3e 0a			ld a, 10 
041b cd d5 0a			call aDelayInMS 
041e 2b				dec hl 
041f c1					pop bc 
0420 e1					pop hl 
0421 3e 40				ld a, STORE_BLOCK_PHY 
0423 cd e1 0d				call addatohl 
0426 10 e1				djnz .setmark1 
0428			 
0428 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
042a 3e 00		.setmark2:   	ld a,0 
042c e5					push hl 
042d c5					push bc 
042e cd ac 01				call se_writebyte 
0431 3e 0a			ld a, 10 
0433 cd d5 0a			call aDelayInMS 
0436 23				inc hl 
0437 cd ac 01				call se_writebyte 
043a 3e 0a			ld a, 10 
043c cd d5 0a			call aDelayInMS 
043f 2b				dec hl 
0440 c1					pop bc 
0441 e1					pop hl 
0442 3e 40				ld a, STORE_BLOCK_PHY 
0444 cd e1 0d				call addatohl 
0447 10 e1				djnz .setmark2 
0449			 
0449					 
0449			 
0449			 
0449 c9				ret 
044a			 
044a			 
044a			 
044a			 
044a .. 00		.defaultbanklabl:   db "BankLabel_",0 
0455			 
0455			 
0455			 
0455			; Label Bank 
0455			; ---------- 
0455			; 
0455			; With current bank 
0455			; Read block 0 
0455			; Set label 
0455			; Write block 0 
0455			 
0455			; label str pointer in hl 
0455			 
0455			storage_label:     
0455			 
0455				if DEBUG_STORESE 
0455					DMARK "LBL" 
0455 f5				push af  
0456 3a 6a 04			ld a, (.dmark)  
0459 32 62 ee			ld (debug_mark),a  
045c 3a 6b 04			ld a, (.dmark+1)  
045f 32 63 ee			ld (debug_mark+1),a  
0462 3a 6c 04			ld a, (.dmark+2)  
0465 32 64 ee			ld (debug_mark+2),a  
0468 18 03			jr .pastdmark  
046a ..			.dmark: db "LBL"  
046d f1			.pastdmark: pop af  
046e			endm  
# End of macro DMARK
046e					CALLMONITOR 
046e cd 6f ee			call debug_vector  
0471				endm  
# End of macro CALLMONITOR
0471				endif 
0471			 
0471 e5				push hl 
0472			 
0472 cd 35 03			call storage_get_block_0 
0475			 
0475				; set default label 
0475			 
0475 e1				pop hl 
0476			 
0476 11 74 ea		 	ld de, store_page+3 
0479 01 0f 00			ld bc, 15 
047c				if DEBUG_STORESE 
047c					DMARK "LB3" 
047c f5				push af  
047d 3a 91 04			ld a, (.dmark)  
0480 32 62 ee			ld (debug_mark),a  
0483 3a 92 04			ld a, (.dmark+1)  
0486 32 63 ee			ld (debug_mark+1),a  
0489 3a 93 04			ld a, (.dmark+2)  
048c 32 64 ee			ld (debug_mark+2),a  
048f 18 03			jr .pastdmark  
0491 ..			.dmark: db "LB3"  
0494 f1			.pastdmark: pop af  
0495			endm  
# End of macro DMARK
0495					CALLMONITOR 
0495 cd 6f ee			call debug_vector  
0498				endm  
# End of macro CALLMONITOR
0498				endif 
0498 ed b0			ldir 
049a				; save default page 0 
049a			 
049a 21 00 00			ld hl, 0 
049d 11 71 ea			ld de, store_page 
04a0				if DEBUG_STORESE 
04a0					DMARK "LBW" 
04a0 f5				push af  
04a1 3a b5 04			ld a, (.dmark)  
04a4 32 62 ee			ld (debug_mark),a  
04a7 3a b6 04			ld a, (.dmark+1)  
04aa 32 63 ee			ld (debug_mark+1),a  
04ad 3a b7 04			ld a, (.dmark+2)  
04b0 32 64 ee			ld (debug_mark+2),a  
04b3 18 03			jr .pastdmark  
04b5 ..			.dmark: db "LBW"  
04b8 f1			.pastdmark: pop af  
04b9			endm  
# End of macro DMARK
04b9					CALLMONITOR 
04b9 cd 6f ee			call debug_vector  
04bc				endm  
# End of macro CALLMONITOR
04bc				endif 
04bc cd ec 02			call storage_write_block 
04bf			 
04bf c9				ret 
04c0			 
04c0			 
04c0			 
04c0			; Read Block 0 - Config 
04c0			; --------------------- 
04c0			; 
04c0			; With current bank 
04c0			; Call presence test 
04c0			;    If not present format/init bank  
04c0			; Read block 0  
04c0			;  
04c0			 
04c0			 
04c0			; Dir 
04c0			; --- 
04c0			; 
04c0			; With current bank 
04c0			; Load Block 0 Config 
04c0			; Get max file id number 
04c0			; For each logical block 
04c0			;    Read block read byte 2 
04c0			;      if first block of file 
04c0			;         Display file name 
04c0			;         Display type flags for file 
04c0			;        
04c0			 
04c0			; moving to words as this requires stack control 
04c0			 
04c0			 
04c0			; Delete File 
04c0			; ----------- 
04c0			; 
04c0			; With current bank 
04c0			; 
04c0			; Load Block 0 Config 
04c0			; Get max file id number 
04c0			; For each logical block 
04c0			;    Read block file id 
04c0			;      If first block of file and dont have file id 
04c0			;         if file to delete 
04c0			;         Save file id 
04c0			;         Null file id 
04c0			;         Write this block back 
04c0			;      If file id is one saved 
04c0			;         Null file id 
04c0			;         Write this block back 
04c0			 
04c0			 
04c0			.se_done: 
04c0 e1				pop hl 
04c1 c9				ret 
04c2			 
04c2			storage_erase: 
04c2			 
04c2				; hl contains the file id 
04c2			 
04c2 5d				ld e, l 
04c3 16 00			ld d, 0 
04c5 21 40 00			ld hl, STORE_BLOCK_PHY 
04c8					if DEBUG_FORTH_WORDS 
04c8						DMARK "ERA" 
04c8 f5				push af  
04c9 3a dd 04			ld a, (.dmark)  
04cc 32 62 ee			ld (debug_mark),a  
04cf 3a de 04			ld a, (.dmark+1)  
04d2 32 63 ee			ld (debug_mark+1),a  
04d5 3a df 04			ld a, (.dmark+2)  
04d8 32 64 ee			ld (debug_mark+2),a  
04db 18 03			jr .pastdmark  
04dd ..			.dmark: db "ERA"  
04e0 f1			.pastdmark: pop af  
04e1			endm  
# End of macro DMARK
04e1						CALLMONITOR 
04e1 cd 6f ee			call debug_vector  
04e4				endm  
# End of macro CALLMONITOR
04e4					endif 
04e4 cd b3 05			call storage_findnextid 
04e7 cd 0a 0e			call ishlzero 
04ea c8				ret z 
04eb			 
04eb e5				push hl 
04ec			 
04ec				; TODO check file not found 
04ec			 
04ec 11 71 ea			ld de, store_page 
04ef cd 87 02			call storage_read_block 
04f2			 
04f2 cd 0a 0e			call ishlzero 
04f5 ca c0 04			jp z,.se_done 
04f8			 
04f8					if DEBUG_FORTH_WORDS 
04f8						DMARK "ER1" 
04f8 f5				push af  
04f9 3a 0d 05			ld a, (.dmark)  
04fc 32 62 ee			ld (debug_mark),a  
04ff 3a 0e 05			ld a, (.dmark+1)  
0502 32 63 ee			ld (debug_mark+1),a  
0505 3a 0f 05			ld a, (.dmark+2)  
0508 32 64 ee			ld (debug_mark+2),a  
050b 18 03			jr .pastdmark  
050d ..			.dmark: db "ER1"  
0510 f1			.pastdmark: pop af  
0511			endm  
# End of macro DMARK
0511						CALLMONITOR 
0511 cd 6f ee			call debug_vector  
0514				endm  
# End of macro CALLMONITOR
0514					endif 
0514 3a 71 ea			ld a, (store_page)	; get file id 
0517 32 65 ea			ld (store_tmpid), a 
051a			 
051a 3a 73 ea			ld a, (store_page+2)    ; get count of extends 
051d 32 64 ea			ld (store_tmpext), a 
0520			 
0520				; wipe file header 
0520			 
0520 e1				pop hl 
0521 3e 00			ld a, 0 
0523 32 71 ea			ld (store_page), a 
0526 32 72 ea			ld (store_page+1),a 
0529 11 71 ea			ld de, store_page 
052c					if DEBUG_FORTH_WORDS 
052c						DMARK "ER2" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 62 ee			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 63 ee			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 64 ee			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "ER2"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545						CALLMONITOR 
0545 cd 6f ee			call debug_vector  
0548				endm  
# End of macro CALLMONITOR
0548					endif 
0548 cd ec 02			call storage_write_block 
054b			 
054b			 
054b				; wipe file extents 
054b			 
054b 3a 64 ea			ld a, (store_tmpext) 
054e 47				ld b, a 
054f			 
054f			.eraext:	  
054f c5				push bc 
0550			 
0550 21 40 00			ld hl, STORE_BLOCK_PHY 
0553 3a 65 ea			ld a,(store_tmpid) 
0556 5f				ld e, a 
0557 50				ld d, b	 
0558					if DEBUG_FORTH_WORDS 
0558						DMARK "ER3" 
0558 f5				push af  
0559 3a 6d 05			ld a, (.dmark)  
055c 32 62 ee			ld (debug_mark),a  
055f 3a 6e 05			ld a, (.dmark+1)  
0562 32 63 ee			ld (debug_mark+1),a  
0565 3a 6f 05			ld a, (.dmark+2)  
0568 32 64 ee			ld (debug_mark+2),a  
056b 18 03			jr .pastdmark  
056d ..			.dmark: db "ER3"  
0570 f1			.pastdmark: pop af  
0571			endm  
# End of macro DMARK
0571						CALLMONITOR 
0571 cd 6f ee			call debug_vector  
0574				endm  
# End of macro CALLMONITOR
0574					endif 
0574 cd b3 05			call storage_findnextid 
0577 cd 0a 0e			call ishlzero 
057a ca c0 04			jp z,.se_done 
057d			 
057d e5				push hl 
057e 11 71 ea			ld de, store_page 
0581 cd 87 02			call storage_read_block 
0584			 
0584				; free block	 
0584			 
0584 3e 00			ld a, 0 
0586 32 71 ea			ld (store_page), a 
0589 32 72 ea			ld (store_page+1),a 
058c 11 71 ea			ld de, store_page 
058f e1				pop hl 
0590					if DEBUG_FORTH_WORDS 
0590						DMARK "ER4" 
0590 f5				push af  
0591 3a a5 05			ld a, (.dmark)  
0594 32 62 ee			ld (debug_mark),a  
0597 3a a6 05			ld a, (.dmark+1)  
059a 32 63 ee			ld (debug_mark+1),a  
059d 3a a7 05			ld a, (.dmark+2)  
05a0 32 64 ee			ld (debug_mark+2),a  
05a3 18 03			jr .pastdmark  
05a5 ..			.dmark: db "ER4"  
05a8 f1			.pastdmark: pop af  
05a9			endm  
# End of macro DMARK
05a9						CALLMONITOR 
05a9 cd 6f ee			call debug_vector  
05ac				endm  
# End of macro CALLMONITOR
05ac					endif 
05ac cd ec 02			call storage_write_block 
05af			 
05af c1				pop bc 
05b0 10 9d			djnz .eraext 
05b2			 
05b2 c9				ret 
05b3			 
05b3			 
05b3			; Find Free Block 
05b3			; --------------- 
05b3			; 
05b3			; With current bank 
05b3			;  
05b3			; From given starting logical block 
05b3			;    Read block  
05b3			;    If no file id 
05b3			;         Return block id 
05b3			 
05b3			 
05b3			; hl starting page number 
05b3			; hl contains free page number or zero if no pages free 
05b3			; e contains the file id to locate 
05b3			; d contains the block number 
05b3			 
05b3			; TODO change to find file id and use zero for free block 
05b3			 
05b3			storage_findnextid: 
05b3			 
05b3				; now locate first 0 page to mark as a free block 
05b3			 
05b3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05b5			;	ld hl, STORE_BLOCK_PHY 
05b5			 
05b5					if DEBUG_FORTH_WORDS 
05b5					DMARK "FNI" 
05b5 f5				push af  
05b6 3a ca 05			ld a, (.dmark)  
05b9 32 62 ee			ld (debug_mark),a  
05bc 3a cb 05			ld a, (.dmark+1)  
05bf 32 63 ee			ld (debug_mark+1),a  
05c2 3a cc 05			ld a, (.dmark+2)  
05c5 32 64 ee			ld (debug_mark+2),a  
05c8 18 03			jr .pastdmark  
05ca ..			.dmark: db "FNI"  
05cd f1			.pastdmark: pop af  
05ce			endm  
# End of macro DMARK
05ce						CALLMONITOR 
05ce cd 6f ee			call debug_vector  
05d1				endm  
# End of macro CALLMONITOR
05d1					endif 
05d1			.ff1:   	 
05d1 e5					push hl 
05d2 c5					push bc 
05d3 d5					push de 
05d4 cd ab 01				call se_readbyte 
05d7 5f					ld e,a 
05d8 23					inc hl 
05d9 cd ab 01				call se_readbyte 
05dc 57					ld d, a 
05dd e1					pop hl 
05de e5					push hl 
05df cd ff 0d				call cmp16 
05e2 28 49				jr z, .fffound 
05e4			 
05e4 d1					pop de 
05e5 c1					pop bc 
05e6 e1					pop hl 
05e7			 
05e7					; is found? 
05e7					;cp e 
05e7					;ret z 
05e7			 
05e7 3e 40				ld a, STORE_BLOCK_PHY 
05e9 cd e1 0d				call addatohl 
05ec 10 e3				djnz .ff1 
05ee			 
05ee 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f0			.ff2:   	 
05f0			 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 d5					push de 
05f3 cd ab 01				call se_readbyte 
05f6 5f					ld e,a 
05f7 23					inc hl 
05f8 cd ab 01				call se_readbyte 
05fb 57					ld d, a 
05fc			 
05fc e1					pop hl 
05fd e5					push hl 
05fe cd ff 0d				call cmp16 
0601 28 2a				jr z, .fffound 
0603			 
0603 d1					pop de 
0604 c1					pop bc 
0605 e1					pop hl 
0606					; is found? 
0606					;cp e 
0606					;ret z 
0606			 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd e1 0d				call addatohl 
060b 10 e3				djnz .ff2 
060d			 
060d			 
060d					if DEBUG_FORTH_WORDS 
060d					DMARK "FN-" 
060d f5				push af  
060e 3a 22 06			ld a, (.dmark)  
0611 32 62 ee			ld (debug_mark),a  
0614 3a 23 06			ld a, (.dmark+1)  
0617 32 63 ee			ld (debug_mark+1),a  
061a 3a 24 06			ld a, (.dmark+2)  
061d 32 64 ee			ld (debug_mark+2),a  
0620 18 03			jr .pastdmark  
0622 ..			.dmark: db "FN-"  
0625 f1			.pastdmark: pop af  
0626			endm  
# End of macro DMARK
0626					;	push af 
0626					;	ld a, 'n' 
0626					;	ld (debug_mark),a 
0626					;	pop af 
0626						CALLMONITOR 
0626 cd 6f ee			call debug_vector  
0629				endm  
# End of macro CALLMONITOR
0629					endif 
0629				; no free marks! 
0629 21 00 00				ld hl, 0 
062c c9				ret 
062d			.fffound: 
062d				 
062d			 
062d d1					pop de 
062e c1					pop bc 
062f e1					pop hl 
0630					if DEBUG_FORTH_WORDS 
0630					DMARK "FNF" 
0630 f5				push af  
0631 3a 45 06			ld a, (.dmark)  
0634 32 62 ee			ld (debug_mark),a  
0637 3a 46 06			ld a, (.dmark+1)  
063a 32 63 ee			ld (debug_mark+1),a  
063d 3a 47 06			ld a, (.dmark+2)  
0640 32 64 ee			ld (debug_mark+2),a  
0643 18 03			jr .pastdmark  
0645 ..			.dmark: db "FNF"  
0648 f1			.pastdmark: pop af  
0649			endm  
# End of macro DMARK
0649					;	push af 
0649					;	ld a, 'n' 
0649					;	ld (debug_mark),a 
0649					;	pop af 
0649						CALLMONITOR 
0649 cd 6f ee			call debug_vector  
064c				endm  
# End of macro CALLMONITOR
064c					endif 
064c c9				ret 
064d			 
064d			 
064d			 
064d			; Free Space 
064d			; ---------- 
064d			; 
064d			; With current bank 
064d			; 
064d			; Set block count to zero 
064d			; Starting with first logical block 
064d			;      Find free block  
064d			;      If block id given, increment block count 
064d			; 
064d			;  
064d			 
064d			 
064d			; hl contains count of free blocks 
064d			 
064d			storage_freeblocks: 
064d			 
064d				; now locate first 0 page to mark as a free block 
064d			 
064d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
064f 21 40 00			ld hl, STORE_BLOCK_PHY 
0652 11 00 00			ld de, 0 
0655			 
0655			.fb1:   	 
0655 e5					push hl 
0656 c5					push bc 
0657 d5					push de 
0658 cd ab 01				call se_readbyte 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is free? 
065e			;		cp 0 
065e b7					or a 
065f 20 01				jr nz, .ff1cont 
0661 13					inc de 
0662			 
0662			.ff1cont: 
0662			 
0662			 
0662 3e 40				ld a, STORE_BLOCK_PHY 
0664 cd e1 0d				call addatohl 
0667 10 ec				djnz .fb1 
0669			 
0669 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066b			.fb2:   	 
066b e5					push hl 
066c c5					push bc 
066d d5					push de 
066e cd ab 01				call se_readbyte 
0671 d1					pop de 
0672 c1					pop bc 
0673 e1					pop hl 
0674			 
0674					; is free? 
0674			;		cp 0 
0674 b7					or a 
0675 20 01				jr nz, .ff2cont 
0677 13					inc de 
0678			 
0678			.ff2cont: 
0678			 
0678 3e 40				ld a, STORE_BLOCK_PHY 
067a cd e1 0d				call addatohl 
067d 10 ec				djnz .fb2 
067f			 
067f eb				ex de, hl 
0680 c9				ret 
0681			 
0681			; Get File ID 
0681			; ----------- 
0681			; 
0681			; With current bank 
0681			;  
0681			; Load Block 0 Config 
0681			; Get max file id number 
0681			; For each logical block 
0681			;    Read block file id 
0681			;      If first block of file and dont have file id 
0681			;         if file get id and exit 
0681			 
0681			 
0681			 
0681			 
0681			; Create File 
0681			; ----------- 
0681			; 
0681			; With current bank  
0681			; Load Block 0 Config 
0681			; Get max file id number 
0681			; Increment file id number 
0681			; Save Config 
0681			; Find free block 
0681			; Set buffer with file name and file id 
0681			; Write buffer to free block  
0681			 
0681			 
0681			; hl point to file name 
0681			; hl returns file id 
0681			 
0681			; file format: 
0681			; byte 0 - file id 
0681			; byte 1 - extent number 
0681			; byte 2-> data 
0681			 
0681			; format for extent number 0: 
0681			; 
0681			; byte 0 - file id 
0681			; byte 1 - extent 0 
0681			; byte 2 - extent count 
0681			; byte 3 -> file name and meta data 
0681			 
0681			 
0681			storage_create: 
0681				if DEBUG_STORESE 
0681					DMARK "SCR" 
0681 f5				push af  
0682 3a 96 06			ld a, (.dmark)  
0685 32 62 ee			ld (debug_mark),a  
0688 3a 97 06			ld a, (.dmark+1)  
068b 32 63 ee			ld (debug_mark+1),a  
068e 3a 98 06			ld a, (.dmark+2)  
0691 32 64 ee			ld (debug_mark+2),a  
0694 18 03			jr .pastdmark  
0696 ..			.dmark: db "SCR"  
0699 f1			.pastdmark: pop af  
069a			endm  
# End of macro DMARK
069a					CALLMONITOR 
069a cd 6f ee			call debug_vector  
069d				endm  
# End of macro CALLMONITOR
069d				endif 
069d			 
069d e5				push hl		; save file name pointer 
069e			 
069e cd 35 03			call storage_get_block_0 
06a1			 
06a1 3a 71 ea			ld a,(store_page)	; get current file id 
06a4 3c				inc a 
06a5 32 71 ea			ld (store_page),a 
06a8				 
06a8 32 65 ea			ld (store_tmpid),a			; save id 
06ab			 
06ab 21 00 00			ld hl, 0 
06ae 11 71 ea			ld de, store_page 
06b1				if DEBUG_STORESE 
06b1					DMARK "SCw" 
06b1 f5				push af  
06b2 3a c6 06			ld a, (.dmark)  
06b5 32 62 ee			ld (debug_mark),a  
06b8 3a c7 06			ld a, (.dmark+1)  
06bb 32 63 ee			ld (debug_mark+1),a  
06be 3a c8 06			ld a, (.dmark+2)  
06c1 32 64 ee			ld (debug_mark+2),a  
06c4 18 03			jr .pastdmark  
06c6 ..			.dmark: db "SCw"  
06c9 f1			.pastdmark: pop af  
06ca			endm  
# End of macro DMARK
06ca					CALLMONITOR 
06ca cd 6f ee			call debug_vector  
06cd				endm  
# End of macro CALLMONITOR
06cd				endif 
06cd cd ec 02			call storage_write_block	 ; save update 
06d0			 
06d0				if DEBUG_STORESE 
06d0 11 71 ea				ld de, store_page 
06d3					DMARK "SCC" 
06d3 f5				push af  
06d4 3a e8 06			ld a, (.dmark)  
06d7 32 62 ee			ld (debug_mark),a  
06da 3a e9 06			ld a, (.dmark+1)  
06dd 32 63 ee			ld (debug_mark+1),a  
06e0 3a ea 06			ld a, (.dmark+2)  
06e3 32 64 ee			ld (debug_mark+2),a  
06e6 18 03			jr .pastdmark  
06e8 ..			.dmark: db "SCC"  
06eb f1			.pastdmark: pop af  
06ec			endm  
# End of macro DMARK
06ec					CALLMONITOR 
06ec cd 6f ee			call debug_vector  
06ef				endm  
# End of macro CALLMONITOR
06ef				endif 
06ef				;  
06ef				 
06ef 21 40 00			ld hl, STORE_BLOCK_PHY 
06f2 11 00 00			ld de, 0 
06f5 cd b3 05			call storage_findnextid 
06f8			 
06f8 22 5c ea			ld (store_tmppageid), hl    ; save page to use  
06fb			 
06fb				; TODO detect 0 = no spare blocks 
06fb			 
06fb				; hl now contains the free page to use for the file header page 
06fb			 
06fb				if DEBUG_STORESE 
06fb				DMARK "SCF" 
06fb f5				push af  
06fc 3a 10 07			ld a, (.dmark)  
06ff 32 62 ee			ld (debug_mark),a  
0702 3a 11 07			ld a, (.dmark+1)  
0705 32 63 ee			ld (debug_mark+1),a  
0708 3a 12 07			ld a, (.dmark+2)  
070b 32 64 ee			ld (debug_mark+2),a  
070e 18 03			jr .pastdmark  
0710 ..			.dmark: db "SCF"  
0713 f1			.pastdmark: pop af  
0714			endm  
# End of macro DMARK
0714					CALLMONITOR 
0714 cd 6f ee			call debug_vector  
0717				endm  
# End of macro CALLMONITOR
0717				endif 
0717			 
0717 22 5c ea			ld (store_tmppageid), hl 
071a				 
071a 3a 65 ea			ld a,(store_tmpid)    ; get file id 
071d			;	ld a, (store_filecache)			; save to cache 
071d			 
071d 32 71 ea			ld (store_page),a    ; set page id 
0720 3e 00			ld a, 0			 ; extent 0 is file header 
0722 32 72 ea			ld (store_page+1), a   ; set file extent 
0725			 
0725 32 73 ea			ld (store_page+2), a   ; extent count for the file 
0728			 
0728			;	inc hl 		; init block 0 of file 
0728			;	inc hl   		; skip file and extent id 
0728			 ;       ld a, 0 
0728			;	ld (hl),a 
0728			;	ld a, (store_filecache+1)  	; save to cache 
0728			 
0728			;	inc hl    ; file name 
0728				 
0728				 
0728 11 74 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
072b				if DEBUG_STORESE 
072b					DMARK "SCc" 
072b f5				push af  
072c 3a 40 07			ld a, (.dmark)  
072f 32 62 ee			ld (debug_mark),a  
0732 3a 41 07			ld a, (.dmark+1)  
0735 32 63 ee			ld (debug_mark+1),a  
0738 3a 42 07			ld a, (.dmark+2)  
073b 32 64 ee			ld (debug_mark+2),a  
073e 18 03			jr .pastdmark  
0740 ..			.dmark: db "SCc"  
0743 f1			.pastdmark: pop af  
0744			endm  
# End of macro DMARK
0744					CALLMONITOR 
0744 cd 6f ee			call debug_vector  
0747				endm  
# End of macro CALLMONITOR
0747				endif 
0747 e1				pop hl    ; get zero term string 
0748 e5				push hl 
0749 3e 00			ld a, 0 
074b cd 44 11			call strlent 
074e 23				inc hl   ; cover zero term 
074f 06 00			ld b,0 
0751 4d				ld c,l 
0752 e1				pop hl 
0753				;ex de, hl 
0753				if DEBUG_STORESE 
0753					DMARK "SCa" 
0753 f5				push af  
0754 3a 68 07			ld a, (.dmark)  
0757 32 62 ee			ld (debug_mark),a  
075a 3a 69 07			ld a, (.dmark+1)  
075d 32 63 ee			ld (debug_mark+1),a  
0760 3a 6a 07			ld a, (.dmark+2)  
0763 32 64 ee			ld (debug_mark+2),a  
0766 18 03			jr .pastdmark  
0768 ..			.dmark: db "SCa"  
076b f1			.pastdmark: pop af  
076c			endm  
# End of macro DMARK
076c					;push af 
076c					;ld a, 'a' 
076c					;ld (debug_mark),a 
076c					;pop af 
076c					CALLMONITOR 
076c cd 6f ee			call debug_vector  
076f				endm  
# End of macro CALLMONITOR
076f				endif 
076f ed b0			ldir    ; copy zero term string 
0771				if DEBUG_STORESE 
0771					DMARK "SCA" 
0771 f5				push af  
0772 3a 86 07			ld a, (.dmark)  
0775 32 62 ee			ld (debug_mark),a  
0778 3a 87 07			ld a, (.dmark+1)  
077b 32 63 ee			ld (debug_mark+1),a  
077e 3a 88 07			ld a, (.dmark+2)  
0781 32 64 ee			ld (debug_mark+2),a  
0784 18 03			jr .pastdmark  
0786 ..			.dmark: db "SCA"  
0789 f1			.pastdmark: pop af  
078a			endm  
# End of macro DMARK
078a					CALLMONITOR 
078a cd 6f ee			call debug_vector  
078d				endm  
# End of macro CALLMONITOR
078d				endif 
078d			 
078d				; write file header page 
078d			 
078d 2a 5c ea			ld hl,(store_tmppageid) 
0790 11 71 ea			ld de, store_page 
0793				if DEBUG_STORESE 
0793					DMARK "SCb" 
0793 f5				push af  
0794 3a a8 07			ld a, (.dmark)  
0797 32 62 ee			ld (debug_mark),a  
079a 3a a9 07			ld a, (.dmark+1)  
079d 32 63 ee			ld (debug_mark+1),a  
07a0 3a aa 07			ld a, (.dmark+2)  
07a3 32 64 ee			ld (debug_mark+2),a  
07a6 18 03			jr .pastdmark  
07a8 ..			.dmark: db "SCb"  
07ab f1			.pastdmark: pop af  
07ac			endm  
# End of macro DMARK
07ac					;push af 
07ac					;ld a, 'b' 
07ac					;ld (debug_mark),a 
07ac					;pop af 
07ac					CALLMONITOR 
07ac cd 6f ee			call debug_vector  
07af				endm  
# End of macro CALLMONITOR
07af				endif 
07af cd ec 02			call storage_write_block 
07b2			 
07b2 3a 65 ea			ld a, (store_tmpid) 
07b5 6f				ld l, a 
07b6 26 00			ld h,0 
07b8				if DEBUG_STORESE 
07b8					DMARK "SCz" 
07b8 f5				push af  
07b9 3a cd 07			ld a, (.dmark)  
07bc 32 62 ee			ld (debug_mark),a  
07bf 3a ce 07			ld a, (.dmark+1)  
07c2 32 63 ee			ld (debug_mark+1),a  
07c5 3a cf 07			ld a, (.dmark+2)  
07c8 32 64 ee			ld (debug_mark+2),a  
07cb 18 03			jr .pastdmark  
07cd ..			.dmark: db "SCz"  
07d0 f1			.pastdmark: pop af  
07d1			endm  
# End of macro DMARK
07d1					CALLMONITOR 
07d1 cd 6f ee			call debug_vector  
07d4				endm  
# End of macro CALLMONITOR
07d4				endif 
07d4 c9				ret 
07d5				 
07d5			 
07d5			 
07d5			; 
07d5			; Read File 
07d5			; 
07d5			; h - file id to locate 
07d5			; l - extent to locate 
07d5			; de - pointer to string to read into 
07d5			; 
07d5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d5			 
07d5			.sr_fail: 
07d5 d1				pop de 
07d6 c9				ret 
07d7			 
07d7			storage_read: 
07d7			 
07d7			 
07d7 d5				push de 
07d8			 
07d8			; TODO BUG the above push is it popped before the RET Z? 
07d8			 
07d8			; TODO how to handle multiple part blocks 
07d8			 
07d8				; locate file extent to read 
07d8			 
07d8 5c				ld e, h 
07d9 55				ld d, l 
07da			 
07da			.srext: 
07da 22 6f ea			ld (store_readptr), hl     ; save the current extent to load 
07dd ed 53 6d ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07e1			 
07e1 21 40 00			ld hl, STORE_BLOCK_PHY 
07e4				if DEBUG_STORESE 
07e4					DMARK "sre" 
07e4 f5				push af  
07e5 3a f9 07			ld a, (.dmark)  
07e8 32 62 ee			ld (debug_mark),a  
07eb 3a fa 07			ld a, (.dmark+1)  
07ee 32 63 ee			ld (debug_mark+1),a  
07f1 3a fb 07			ld a, (.dmark+2)  
07f4 32 64 ee			ld (debug_mark+2),a  
07f7 18 03			jr .pastdmark  
07f9 ..			.dmark: db "sre"  
07fc f1			.pastdmark: pop af  
07fd			endm  
# End of macro DMARK
07fd					CALLMONITOR 
07fd cd 6f ee			call debug_vector  
0800				endm  
# End of macro CALLMONITOR
0800				endif 
0800 cd b3 05			call storage_findnextid 
0803			 
0803				if DEBUG_STORESE 
0803					DMARK "srf" 
0803 f5				push af  
0804 3a 18 08			ld a, (.dmark)  
0807 32 62 ee			ld (debug_mark),a  
080a 3a 19 08			ld a, (.dmark+1)  
080d 32 63 ee			ld (debug_mark+1),a  
0810 3a 1a 08			ld a, (.dmark+2)  
0813 32 64 ee			ld (debug_mark+2),a  
0816 18 03			jr .pastdmark  
0818 ..			.dmark: db "srf"  
081b f1			.pastdmark: pop af  
081c			endm  
# End of macro DMARK
081c					CALLMONITOR 
081c cd 6f ee			call debug_vector  
081f				endm  
# End of macro CALLMONITOR
081f				endif 
081f cd 0a 0e			call ishlzero 
0822			;	ld a, l 
0822			;	add h 
0822			;	cp 0 
0822 28 b1			jr z,.sr_fail			; block not found so EOF 
0824			 
0824				; save current address for use by higher level words etc 
0824			 
0824 22 62 ea			ld (store_openaddr),hl 
0827			 
0827			 
0827				; hl contains page number to load 
0827 d1				pop de   ; get storage 
0828 ed 53 6d ea		ld (store_readbuf), de     ; current buffer to load in to 
082c d5				push de 
082d				if DEBUG_STORESE 
082d					DMARK "srg" 
082d f5				push af  
082e 3a 42 08			ld a, (.dmark)  
0831 32 62 ee			ld (debug_mark),a  
0834 3a 43 08			ld a, (.dmark+1)  
0837 32 63 ee			ld (debug_mark+1),a  
083a 3a 44 08			ld a, (.dmark+2)  
083d 32 64 ee			ld (debug_mark+2),a  
0840 18 03			jr .pastdmark  
0842 ..			.dmark: db "srg"  
0845 f1			.pastdmark: pop af  
0846			endm  
# End of macro DMARK
0846					CALLMONITOR 
0846 cd 6f ee			call debug_vector  
0849				endm  
# End of macro CALLMONITOR
0849				endif 
0849 cd 87 02			call storage_read_block 
084c			 
084c				; if this a continuation read??? 
084c			 
084c 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084f			 
084f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0851 cd e1 0d			call addatohl 
0854 7e				ld a,(hl) 
0855			;	cp 0 
0855 b7				or a 
0856 28 02			jr z, .markiscont 
0858 3e ff			ld a, 255 
085a			 
085a			.markiscont: 
085a 32 64 ea			ld (store_readcont), a 
085d			 
085d				if DEBUG_STORESE 
085d					DMARK "srC" 
085d f5				push af  
085e 3a 72 08			ld a, (.dmark)  
0861 32 62 ee			ld (debug_mark),a  
0864 3a 73 08			ld a, (.dmark+1)  
0867 32 63 ee			ld (debug_mark+1),a  
086a 3a 74 08			ld a, (.dmark+2)  
086d 32 64 ee			ld (debug_mark+2),a  
0870 18 03			jr .pastdmark  
0872 ..			.dmark: db "srC"  
0875 f1			.pastdmark: pop af  
0876			endm  
# End of macro DMARK
0876					CALLMONITOR 
0876 cd 6f ee			call debug_vector  
0879				endm  
# End of macro CALLMONITOR
0879				endif 
0879				; only short reads enabled 
0879			 
0879 3a 6c ea			ld a, (store_longread) 
087c			;	cp 0 
087c b7				or a 
087d ca 49 09			jp z, .readdone 
0880			 
0880			; TODO if block has no zeros then need to read next block  
0880			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0880			; check last byte of physical block. 
0880			; if not zero then the next block needs to be loaded 
0880			 
0880			 
0880 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0883			 
0883 3e 3f			ld a, STORE_BLOCK_PHY-1 
0885 cd e1 0d			call addatohl 
0888				;dec hl 
0888 7e				ld a,(hl) 
0889				if DEBUG_STORESE 
0889					DMARK "sr?" 
0889 f5				push af  
088a 3a 9e 08			ld a, (.dmark)  
088d 32 62 ee			ld (debug_mark),a  
0890 3a 9f 08			ld a, (.dmark+1)  
0893 32 63 ee			ld (debug_mark+1),a  
0896 3a a0 08			ld a, (.dmark+2)  
0899 32 64 ee			ld (debug_mark+2),a  
089c 18 03			jr .pastdmark  
089e ..			.dmark: db "sr?"  
08a1 f1			.pastdmark: pop af  
08a2			endm  
# End of macro DMARK
08a2					CALLMONITOR 
08a2 cd 6f ee			call debug_vector  
08a5				endm  
# End of macro CALLMONITOR
08a5				endif 
08a5			;	cp 0 
08a5 b7				or a 
08a6 ca 49 09			jp z, .readdone 
08a9			 
08a9				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a9			 
08a9 23				inc hl 
08aa			 
08aa 22 6d ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ad			 
08ad ed 5b 6f ea		ld de, (store_readptr)     ; save the current extent to load 
08b1			 
08b1 eb				ex de, hl 
08b2			 
08b2				; next ext 
08b2			 
08b2 23				inc hl 
08b3 22 6f ea			ld  (store_readptr), hl     ; save the current extent to load 
08b6			 
08b6				if DEBUG_STORESE 
08b6					DMARK "sF2" 
08b6 f5				push af  
08b7 3a cb 08			ld a, (.dmark)  
08ba 32 62 ee			ld (debug_mark),a  
08bd 3a cc 08			ld a, (.dmark+1)  
08c0 32 63 ee			ld (debug_mark+1),a  
08c3 3a cd 08			ld a, (.dmark+2)  
08c6 32 64 ee			ld (debug_mark+2),a  
08c9 18 03			jr .pastdmark  
08cb ..			.dmark: db "sF2"  
08ce f1			.pastdmark: pop af  
08cf			endm  
# End of macro DMARK
08cf					CALLMONITOR 
08cf cd 6f ee			call debug_vector  
08d2				endm  
# End of macro CALLMONITOR
08d2				endif 
08d2			 
08d2				; get and load block 
08d2			 
08d2 cd b3 05			call storage_findnextid 
08d5			 
08d5				if DEBUG_STORESE 
08d5					DMARK "sf2" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 62 ee			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 63 ee			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 64 ee			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "sf2"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 6f ee			call debug_vector  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1 cd 0a 0e			call ishlzero 
08f4			;	ld a, l 
08f4			;	add h 
08f4			;	cp 0 
08f4 ca d5 07			jp z,.sr_fail			; block not found so EOF 
08f7				 
08f7				; save current address for use by higher level words etc 
08f7			 
08f7 22 62 ea			ld (store_openaddr),hl 
08fa			 
08fa cd 87 02			call storage_read_block 
08fd			 
08fd				; on a continuation block, we now have the file id and ext in the middle of the block 
08fd				; we need to pull everything back  
08fd			 
08fd ed 5b 6d ea		ld de, (store_readbuf)     ; current buffer to nudge into 
0901 2a 6d ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0904 23				inc hl 
0905 23				inc hl     ; skip id and ext 
0906 01 40 00			ld bc, STORE_BLOCK_PHY 
0909				if DEBUG_STORESE 
0909					DMARK "SR<" 
0909 f5				push af  
090a 3a 1e 09			ld a, (.dmark)  
090d 32 62 ee			ld (debug_mark),a  
0910 3a 1f 09			ld a, (.dmark+1)  
0913 32 63 ee			ld (debug_mark+1),a  
0916 3a 20 09			ld a, (.dmark+2)  
0919 32 64 ee			ld (debug_mark+2),a  
091c 18 03			jr .pastdmark  
091e ..			.dmark: db "SR<"  
0921 f1			.pastdmark: pop af  
0922			endm  
# End of macro DMARK
0922					CALLMONITOR 
0922 cd 6f ee			call debug_vector  
0925				endm  
# End of macro CALLMONITOR
0925				endif 
0925 ed b0			ldir     ; copy data 
0927			 
0927				; move the pointer back and pretend we have a full buffer for next recheck 
0927			 
0927 1b				dec de 
0928 1b				dec de 
0929			 
0929			; TODO do pop below now short circuit loop????? 
0929 c1				pop bc     ; get rid of spare de on stack 
092a				if DEBUG_STORESE 
092a					DMARK "SR>" 
092a f5				push af  
092b 3a 3f 09			ld a, (.dmark)  
092e 32 62 ee			ld (debug_mark),a  
0931 3a 40 09			ld a, (.dmark+1)  
0934 32 63 ee			ld (debug_mark+1),a  
0937 3a 41 09			ld a, (.dmark+2)  
093a 32 64 ee			ld (debug_mark+2),a  
093d 18 03			jr .pastdmark  
093f ..			.dmark: db "SR>"  
0942 f1			.pastdmark: pop af  
0943			endm  
# End of macro DMARK
0943					CALLMONITOR 
0943 cd 6f ee			call debug_vector  
0946				endm  
# End of macro CALLMONITOR
0946				endif 
0946 c3 da 07			jp .srext 
0949			 
0949			 
0949			 
0949			 
0949			 
0949			.readdone:		 
0949 e1				pop hl 		 ; return start of data to show as not EOF 
094a 23				inc hl   ; past file id 
094b 23				inc hl   ; past ext 
094c				if DEBUG_STORESE 
094c					DMARK "SRe" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 62 ee			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 63 ee			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 64 ee			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "SRe"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 6f ee			call debug_vector  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 c9					ret 
0969			 
0969			 
0969			 
0969			; 
0969			; Append File 
0969			; 
0969			; hl - file id to locate 
0969			; de - pointer to (multi block) string to write 
0969			 
0969			.sa_notfound: 
0969 d1				pop de 
096a c9				ret 
096b			 
096b			 
096b			storage_append: 
096b				; hl -  file id to append to 
096b				; de - string to append 
096b			 
096b d5				push de 
096c				 
096c				if DEBUG_STORESE 
096c					DMARK "AP1" 
096c f5				push af  
096d 3a 81 09			ld a, (.dmark)  
0970 32 62 ee			ld (debug_mark),a  
0973 3a 82 09			ld a, (.dmark+1)  
0976 32 63 ee			ld (debug_mark+1),a  
0979 3a 83 09			ld a, (.dmark+2)  
097c 32 64 ee			ld (debug_mark+2),a  
097f 18 03			jr .pastdmark  
0981 ..			.dmark: db "AP1"  
0984 f1			.pastdmark: pop af  
0985			endm  
# End of macro DMARK
0985					CALLMONITOR 
0985 cd 6f ee			call debug_vector  
0988				endm  
# End of macro CALLMONITOR
0988				endif 
0988			 
0988 7d				ld a, l 
0989 32 65 ea			ld (store_tmpid), a 
098c			 
098c				; get file header  
098c			 
098c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098e 3a 65 ea			ld a, (store_tmpid) 
0991 5f				ld e, a 
0992			 
0992 21 40 00				ld hl, STORE_BLOCK_PHY 
0995 cd b3 05				call storage_findnextid 
0998			 
0998 cd 0a 0e			call ishlzero 
099b 28 cc			jr z, .sa_notfound 
099d			 
099d 22 5c ea			ld (store_tmppageid), hl 
09a0			 
09a0				; TODO handle file id not found 
09a0			 
09a0				if DEBUG_STORESE 
09a0					DMARK "AP2" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 62 ee			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 63 ee			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 64 ee			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "AP2"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6f ee			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc			 
09bc				; update file extent count 
09bc			 
09bc 11 71 ea			ld de, store_page 
09bf			 
09bf cd 87 02			call storage_read_block 
09c2			 
09c2				if DEBUG_STORESE 
09c2					DMARK "AP3" 
09c2 f5				push af  
09c3 3a d7 09			ld a, (.dmark)  
09c6 32 62 ee			ld (debug_mark),a  
09c9 3a d8 09			ld a, (.dmark+1)  
09cc 32 63 ee			ld (debug_mark+1),a  
09cf 3a d9 09			ld a, (.dmark+2)  
09d2 32 64 ee			ld (debug_mark+2),a  
09d5 18 03			jr .pastdmark  
09d7 ..			.dmark: db "AP3"  
09da f1			.pastdmark: pop af  
09db			endm  
# End of macro DMARK
09db					CALLMONITOR 
09db cd 6f ee			call debug_vector  
09de				endm  
# End of macro CALLMONITOR
09de				endif 
09de			;	ld (store_tmppageid), hl 
09de			 
09de 3a 73 ea			ld a, (store_page+2) 
09e1 3c				inc a 
09e2 32 73 ea			ld (store_page+2), a 
09e5 32 64 ea			ld (store_tmpext), a 
09e8				 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP3" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 62 ee			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 63 ee			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 64 ee			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP3"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 6f ee			call debug_vector  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 2a 5c ea			ld hl, (store_tmppageid) 
0a07 11 71 ea			ld de, store_page 
0a0a cd ec 02			call storage_write_block 
0a0d			 
0a0d				; find free block 
0a0d			 
0a0d 11 00 00			ld de, 0			 ; file extent to locate 
0a10			 
0a10 21 40 00				ld hl, STORE_BLOCK_PHY 
0a13 cd b3 05				call storage_findnextid 
0a16 cd 0a 0e			call ishlzero 
0a19 ca 69 09			jp z, .sa_notfound 
0a1c			 
0a1c					; TODO handle no space left 
0a1c					 
0a1c 22 5c ea				ld (store_tmppageid), hl 
0a1f			 
0a1f				if DEBUG_STORESE 
0a1f					DMARK "AP4" 
0a1f f5				push af  
0a20 3a 34 0a			ld a, (.dmark)  
0a23 32 62 ee			ld (debug_mark),a  
0a26 3a 35 0a			ld a, (.dmark+1)  
0a29 32 63 ee			ld (debug_mark+1),a  
0a2c 3a 36 0a			ld a, (.dmark+2)  
0a2f 32 64 ee			ld (debug_mark+2),a  
0a32 18 03			jr .pastdmark  
0a34 ..			.dmark: db "AP4"  
0a37 f1			.pastdmark: pop af  
0a38			endm  
# End of macro DMARK
0a38					CALLMONITOR 
0a38 cd 6f ee			call debug_vector  
0a3b				endm  
# End of macro CALLMONITOR
0a3b				endif 
0a3b					; init the buffer with zeros so we can id if the buffer is full or not 
0a3b			 
0a3b e5					push hl 
0a3c c5					push bc 
0a3d			 
0a3d 21 71 ea				ld hl, store_page 
0a40 06 40				ld b, STORE_BLOCK_PHY 
0a42			;		ld a, 0 
0a42 36 00		.zeroblock:	ld (hl), 0 
0a44 23					inc hl 
0a45 10 fb				djnz .zeroblock 
0a47			 
0a47 c1					pop bc 
0a48 e1					pop hl 
0a49			 
0a49					; construct block 
0a49			 
0a49 3a 65 ea				ld a, (store_tmpid) 
0a4c 32 71 ea				ld (store_page), a   ; file id 
0a4f 3a 64 ea				ld a, (store_tmpext)   ; extent for this block 
0a52 32 72 ea				ld (store_page+1), a 
0a55			 
0a55 e1					pop hl    ; get string to write 
0a56 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a58 11 73 ea				ld de, store_page+2 
0a5b			 
0a5b				if DEBUG_STORESE 
0a5b					DMARK "AP5" 
0a5b f5				push af  
0a5c 3a 70 0a			ld a, (.dmark)  
0a5f 32 62 ee			ld (debug_mark),a  
0a62 3a 71 0a			ld a, (.dmark+1)  
0a65 32 63 ee			ld (debug_mark+1),a  
0a68 3a 72 0a			ld a, (.dmark+2)  
0a6b 32 64 ee			ld (debug_mark+2),a  
0a6e 18 03			jr .pastdmark  
0a70 ..			.dmark: db "AP5"  
0a73 f1			.pastdmark: pop af  
0a74			endm  
# End of macro DMARK
0a74					CALLMONITOR 
0a74 cd 6f ee			call debug_vector  
0a77				endm  
# End of macro CALLMONITOR
0a77				endif 
0a77			 
0a77			 
0a77			 
0a77					; fill buffer with data until end of string or full block 
0a77			 
0a77 7e			.appd:		ld a, (hl) 
0a78 12					ld (de), a 
0a79			;		cp 0 
0a79 b7					or a 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f7				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 5c ea			ld hl, (store_tmppageid) 
0a85 11 71 ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 62 ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 63 ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 64 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6f ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd ec 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9					;cp 0		 ; no, string was fully written 
0aa9 b7					or a 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 65 ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 6b 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4			;		ld a,0 
0ab4			.src:		ld (hl),0 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4			;	ld a, 0 
0ab4				ld (hl),0 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 71 ea			ld hl, store_page 
0aba			;	ld a, 0 
0aba 36 00			ld (hl), 0 
0abc			 
0abc 11 72 ea			ld de, store_page+1 
0abf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac2			 
0ac2 ed b0			ldir 
0ac4				 
0ac4 c1				pop bc 
0ac5 d1				pop de 
0ac6 e1				pop hl 
0ac7 c9				ret 
0ac8			 
0ac8			; eof 
# End of file firmware_storage.asm
0ac8			  
0ac8			; support routines for above hardware abstraction layer  
0ac8			  
0ac8			include "firmware_general.asm"        ; general support functions  
0ac8			 
0ac8			; word look up 
0ac8			 
0ac8			; in 
0ac8			; a is the index 
0ac8			; hl is pointer start of array 
0ac8			; 
0ac8			; returns 
0ac8			; hl to the word 
0ac8			; 
0ac8			 
0ac8			table_lookup:  
0ac8 d5					push de 
0ac9 eb					ex de, hl 
0aca			 
0aca 6f					ld l, a 
0acb 26 00				ld h, 0 
0acd 29					add hl, hl 
0ace 19					add hl, de 
0acf 7e					ld a, (hl) 
0ad0 23					inc hl 
0ad1 66					ld h,(hl) 
0ad2 6f					ld l, a 
0ad3			 
0ad3 d1					pop de 
0ad4 c9					ret 
0ad5			 
0ad5			; Delay loops 
0ad5			 
0ad5			 
0ad5			 
0ad5			aDelayInMS: 
0ad5 c5				push bc 
0ad6 47				ld b,a 
0ad7			msdelay: 
0ad7 c5				push bc 
0ad8				 
0ad8			 
0ad8 01 41 00			ld bc,041h 
0adb cd f3 0a			call delayloop 
0ade c1				pop bc 
0adf 05				dec b 
0ae0 20 f5			jr nz,msdelay 
0ae2			 
0ae2			;if CPU_CLOCK_8MHZ 
0ae2			;msdelay8: 
0ae2			;	push bc 
0ae2			;	 
0ae2			; 
0ae2			;	ld bc,041h 
0ae2			;	call delayloop 
0ae2			;	pop bc 
0ae2			;	dec b 
0ae2			;	jr nz,msdelay8 
0ae2			;endif 
0ae2			 
0ae2			 
0ae2 c1				pop bc 
0ae3 c9				ret 
0ae4			 
0ae4			 
0ae4			delay250ms: 
0ae4				;push de 
0ae4 01 00 40			ld bc, 04000h 
0ae7 c3 f3 0a			jp delayloop 
0aea			delay500ms: 
0aea				;push de 
0aea 01 00 80			ld bc, 08000h 
0aed c3 f3 0a			jp delayloop 
0af0			delay1s: 
0af0				;push bc 
0af0			   ; Clobbers A, d and e 
0af0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af3			delayloop: 
0af3 c5			    push bc 
0af4			 
0af4			if BASE_CPM 
0af4 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af7			.cpmloop: 
0af7 c5				push bc 
0af8			 
0af8			endif 
0af8			 
0af8			 
0af8			 
0af8			delayloopi: 
0af8			;	push bc 
0af8			;.dl: 
0af8 cb 47		    bit     0,a    	; 8 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe e6 ff		    and     255  	; 7 
0b00 0b			    dec     bc      	; 6 
0b01 79			    ld      a,c     	; 4 
0b02 b0			    or      b     	; 4 
0b03 c2 f8 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b06			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b06				;pop de 
0b06			;pop bc 
0b06			 
0b06			if BASE_CPM 
0b06 c1				pop bc 
0b07				 
0b07 0b			    dec     bc      	; 6 
0b08 79			    ld      a,c     	; 4 
0b09 b0			    or      b     	; 4 
0b0a c2 f7 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0d				 
0b0d			 
0b0d			endif 
0b0d			;if CPU_CLOCK_8MHZ 
0b0d			;    pop bc 
0b0d			;    push bc 
0b0d			;.dl8: 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    and     255  	; 7 
0b0d			;    dec     bc      	; 6 
0b0d			;    ld      a,c     	; 4 
0b0d			;    or      b     	; 4 
0b0d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0d			;endif 
0b0d			 
0b0d			;if CPU_CLOCK_10MHZ 
0b0d			;    pop bc 
0b0d			;    push bc 
0b0d			;.dl8: 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    and     255  	; 7 
0b0d			;    dec     bc      	; 6 
0b0d			;    ld      a,c     	; 4 
0b0d			;    or      b     	; 4 
0b0d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0d			;endif 
0b0d c1			    pop bc 
0b0e			 
0b0e c9				ret 
0b0f			 
0b0f			 
0b0f			 
0b0f			; eof 
# End of file firmware_general.asm
0b0f			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b0f			; display routines that use the physical hardware abstraction layer 
0b0f			 
0b0f			 
0b0f			; Display an activity indicator 
0b0f			; Each call returns the new char pointed to in hl 
0b0f			 
0b0f			active: 
0b0f 3a bd eb			ld a, (display_active) 
0b12 fe 06			cp 6 
0b14			 
0b14 20 02			jr nz, .sne 
0b16				; gone past the last one reset sequence 
0b16 3e ff			ld a, 255 
0b18			 
0b18			.sne:   
0b18				; get the next char in seq 
0b18 3c				inc a 
0b19 32 bd eb			ld (display_active), a 
0b1c			 
0b1c				; look up the string in the table 
0b1c 21 33 0b			ld hl, actseq 
0b1f cb 27			sla a 
0b21 cd e1 0d			call addatohl 
0b24 cd 3b 1e			call loadwordinhl 
0b27			 
0b27				; forth will write the to string when pushing so move from rom to ram 
0b27			 
0b27 11 be eb			ld de, display_active+1 
0b2a 01 02 00			ld bc, 2 
0b2d ed b0			ldir 
0b2f			 
0b2f 21 be eb			ld hl, display_active+1 
0b32 c9				ret 
0b33				 
0b33				 
0b33			 
0b33			 
0b33			;db "|/-\|-\" 
0b33			 
0b33			actseq: 
0b33			 
0b33 41 0b		dw spin0 
0b35 43 0b		dw spin1 
0b37 45 0b		dw spin2 
0b39 47 0b		dw spin3 
0b3b 45 0b		dw spin2 
0b3d 43 0b		dw spin1 
0b3f 41 0b		dw spin0 
0b41			 
0b41 .. 00		spin0: db " ", 0 
0b43 .. 00		spin1: db "-", 0 
0b45 .. 00		spin2: db "+", 0 
0b47 .. 00		spin3: db "#", 0 
0b49			 
0b49			 
0b49			; information window 
0b49			 
0b49			; pass hl with 1st string to display 
0b49			; pass de with 2nd string to display 
0b49			 
0b49			info_panel: 
0b49 e5				push hl 
0b4a			 
0b4a 2a c3 eb			ld hl, (display_fb_active) 
0b4d e5				push hl    ; future de destination 
0b4e 21 a8 ed				ld hl, display_fb0 
0b51 22 c3 eb				ld (display_fb_active), hl 
0b54			 
0b54			;	call clear_display 
0b54			 
0b54				if BASE_CPM 
0b54 3e 2e			ld a, '.' 
0b56				else 
0b56				ld a, 165 
0b56				endif 
0b56 cd bc 0b			call fill_display 
0b59			 
0b59			 
0b59 3e 55			ld a, display_row_3 + 5 
0b5b cd c9 0b			call str_at_display 
0b5e			 
0b5e e1				pop hl 
0b5f d1				pop de 
0b60			 
0b60 e5				push hl 
0b61			 
0b61			 
0b61 3e 2d			ld a, display_row_2 + 5 
0b63 cd c9 0b			call str_at_display 
0b66			 
0b66			 
0b66 cd d9 0b			call update_display 
0b69 cd 4a 1a			call next_page_prompt 
0b6c cd b7 0b			call clear_display 
0b6f			 
0b6f				 
0b6f 21 07 ed				ld hl, display_fb1 
0b72 22 c3 eb				ld (display_fb_active), hl 
0b75 cd d9 0b			call update_display 
0b78			 
0b78 e1				pop hl 
0b79			 
0b79 c9				ret 
0b7a			 
0b7a			 
0b7a			 
0b7a			 
0b7a			; TODO windowing? 
0b7a			 
0b7a			; TODO scroll line up 
0b7a			 
0b7a			scroll_up: 
0b7a			 
0b7a e5				push hl 
0b7b d5				push de 
0b7c c5				push bc 
0b7d			 
0b7d				; get frame buffer  
0b7d			 
0b7d 2a c3 eb			ld hl, (display_fb_active) 
0b80 e5				push hl    ; future de destination 
0b81			 
0b81 11 28 00			ld  de, display_cols 
0b84 19				add hl, de 
0b85			 
0b85 d1				pop de 
0b86			 
0b86				;ex de, hl 
0b86 01 9f 00			ld bc, display_fb_len -1  
0b89			;if DEBUG_FORTH_WORDS 
0b89			;	DMARK "SCL" 
0b89			;	CALLMONITOR 
0b89			;endif	 
0b89 ed b0			ldir 
0b8b			 
0b8b				; wipe bottom row 
0b8b			 
0b8b			 
0b8b 2a c3 eb			ld hl, (display_fb_active) 
0b8e 11 a0 00			ld de, display_cols*display_rows 
0b91 19				add hl, de 
0b92 06 28			ld b, display_cols 
0b94			;	ld a, ' ' 
0b94			.scwipe: 
0b94 36 20			ld (hl), ' ' 
0b96 2b				dec hl 
0b97 10 fb			djnz .scwipe 
0b99			 
0b99				;pop hl 
0b99			 
0b99 c1				pop bc 
0b9a d1				pop de 
0b9b e1				pop hl 
0b9c			 
0b9c c9				ret 
0b9d			 
0b9d			 
0b9d			;scroll_upo: 
0b9d			;	ld de, display_row_1 
0b9d			 ;	ld hl, display_row_2 
0b9d			;	ld bc, display_cols 
0b9d			;	ldir 
0b9d			;	ld de, display_row_2 
0b9d			 ;	ld hl, display_row_3 
0b9d			;	ld bc, display_cols 
0b9d			;	ldir 
0b9d			;	ld de, display_row_3 
0b9d			 ;	ld hl, display_row_4 
0b9d			;	ld bc, display_cols 
0b9d			;	ldir 
0b9d			 
0b9d			; TODO clear row 4 
0b9d			 
0b9d			;	ret 
0b9d			 
0b9d				 
0b9d			scroll_down: 
0b9d			 
0b9d e5				push hl 
0b9e d5				push de 
0b9f c5				push bc 
0ba0			 
0ba0				; get frame buffer  
0ba0			 
0ba0 2a c3 eb			ld hl, (display_fb_active) 
0ba3			 
0ba3 11 9f 00			ld de, display_fb_len - 1 
0ba6 19				add hl, de 
0ba7			 
0ba7 e5			push hl    ; future de destination 
0ba8			 
0ba8 11 28 00			ld  de, display_cols 
0bab ed 52			sbc hl, de 
0bad			 
0bad			 
0bad d1				pop de 
0bae			 
0bae			;	ex de, hl 
0bae 01 9f 00			ld bc, display_fb_len -1  
0bb1			 
0bb1			 
0bb1				 
0bb1			 
0bb1 ed b0			ldir 
0bb3			 
0bb3				; wipe bottom row 
0bb3			 
0bb3			 
0bb3			;	ld hl, (display_fb_active) 
0bb3			;;	ld de, display_cols*display_rows 
0bb3			;;	add hl, de 
0bb3			;	ld b, display_cols 
0bb3			;	ld a, ' ' 
0bb3			;.scwiped: 
0bb3			;	ld (hl), a 
0bb3			;	dec hl 
0bb3			;	djnz .scwiped 
0bb3			 
0bb3				;pop hl 
0bb3			 
0bb3 c1				pop bc 
0bb4 d1				pop de 
0bb5 e1				pop hl 
0bb6			 
0bb6 c9				ret 
0bb7			;scroll_down: 
0bb7			;	ld de, display_row_4 
0bb7			;	ld hl, display_row_3 
0bb7			;	ld bc, display_cols 
0bb7			;	ldir 
0bb7			;	ld de, display_row_3 
0bb7			; 	ld hl, display_row_2 
0bb7			;	ld bc, display_cols 
0bb7			;	ldir 
0bb7			;	ld de, display_row_2 
0bb7			;	ld hl, display_row_1 
0bb7			;	ld bc, display_cols 
0bb7			;	ldir 
0bb7			;;; TODO clear row 1 
0bb7			;	ret 
0bb7			 
0bb7			 
0bb7			 
0bb7			 
0bb7			 
0bb7			; clear active frame buffer 
0bb7			 
0bb7			clear_display: 
0bb7 3e 20			ld a, ' ' 
0bb9 c3 bc 0b			jp fill_display 
0bbc			 
0bbc			; fill active frame buffer with a char in A 
0bbc			 
0bbc			fill_display: 
0bbc 06 a0			ld b,display_fb_len 
0bbe 2a c3 eb			ld hl, (display_fb_active) 
0bc1 77			.fd1:	ld (hl),a 
0bc2 23				inc hl 
0bc3 10 fc			djnz .fd1 
0bc5 23				inc hl 
0bc6			;	ld a,0 
0bc6 36 00			ld (hl),0 
0bc8			 
0bc8			 
0bc8 c9				ret 
0bc9			; Write string (DE) at pos (A) to active frame buffer 
0bc9			 
0bc9 2a c3 eb		str_at_display:    ld hl,(display_fb_active) 
0bcc 06 00					ld b,0 
0bce 4f					ld c,a 
0bcf 09					add hl,bc 
0bd0 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd1 b7			            OR   A              ;Null terminator? 
0bd2 c8			            RET  Z              ;Yes, so finished 
0bd3 77					ld (hl),a 
0bd4 23				inc hl 
0bd5 13			            INC  DE             ;Point to next character 
0bd6 18 f8		            JR   .sad1     ;Repeat 
0bd8 c9					ret 
0bd9			 
0bd9			; using current frame buffer write to physical display 
0bd9			 
0bd9			update_display: 
0bd9 e5				push hl 
0bda 2a c3 eb			ld hl, (display_fb_active) 
0bdd cd f6 64			call write_display 
0be0 e1				pop hl 
0be1 c9				ret 
0be2			 
0be2			; TODO scrolling 
0be2			 
0be2			 
0be2			; move cursor right one char 
0be2			cursor_right: 
0be2			 
0be2				; TODO shift right 
0be2				; TODO if beyond max col 
0be2				; TODO       cursor_next_line 
0be2			 
0be2 c9				ret 
0be3			 
0be3			 
0be3			cursor_next_line: 
0be3				; TODO first char 
0be3				; TODO line down 
0be3				; TODO if past last row 
0be3				; TODO    scroll up 
0be3			 
0be3 c9				ret 
0be4			 
0be4			cursor_left: 
0be4				; TODO shift left 
0be4				; TODO if beyond left  
0be4				; TODO     cursor prev line 
0be4				 
0be4 c9				ret 
0be5			 
0be5			cursor_prev_line: 
0be5				; TODO last char 
0be5				; TODO line up 
0be5				; TODO if past first row 
0be5				; TODO   scroll down 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cout: 
0be6				; A - char 
0be6 c9				ret 
0be7			 
0be7			 
0be7			; Display a menu and allow item selection (optional toggle items) 
0be7			; 
0be7			; format: 
0be7			; hl pointer to word array with zero term for items 
0be7			; e.g.    db item1 
0be7			;         db .... 
0be7			;         db 0 
0be7			; 
0be7			; a = starting menu item  
0be7			; 
0be7			; de = pointer item toggle array   (todo) 
0be7			; 
0be7			; returns item selected in a 1-... 
0be7			; returns 0 if back button pressed 
0be7			; 
0be7			; NOTE: Uses system frame buffer to display 
0be7			; 
0be7			; LEFT, Q = go back 
0be7			; RIGHT, SPACE, CR = select 
0be7			; UP, A - Up 
0be7			; DOWN, Z - Down 
0be7			 
0be7			 
0be7			 
0be7			 
0be7			 
0be7			menu: 
0be7			 
0be7					; keep array pointer 
0be7			 
0be7 22 6a ea				ld (store_tmp1), hl 
0bea 32 68 ea				ld (store_tmp2), a 
0bed			 
0bed					; check for key bounce 
0bed			 
0bed			if BASE_KEV 
0bed			 
0bed			.mbounce:	call cin 
0bed			;		cp 0 
0bed					or a 
0bed					jr nz, .mbounce 
0bed			endif 
0bed					; for ease use ex 
0bed			 
0bed					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bed 21 a8 ed				ld hl, display_fb0 
0bf0 22 c3 eb				ld (display_fb_active), hl 
0bf3			 
0bf3 cd b7 0b		.mloop:		call clear_display 
0bf6 cd d9 0b				call update_display 
0bf9			 
0bf9					; draw selection id '>' at 1 
0bf9			 
0bf9					; init start of list display 
0bf9			 
0bf9 3e 05				ld a, 5 
0bfb 32 66 ea				ld (store_tmp3), a   ; display row count 
0bfe 3a 68 ea				ld a,( store_tmp2) 
0c01 32 69 ea				ld (store_tmp2+1), a   ; display item count 
0c04			 
0c04					 
0c04			.mitem:	 
0c04			 
0c04			 
0c04 3a 69 ea				ld a,(store_tmp2+1) 
0c07 6f					ld l, a 
0c08 26 00				ld h, 0 
0c0a 29					add hl, hl 
0c0b ed 5b 6a ea			ld de, (store_tmp1) 
0c0f 19					add hl, de 
0c10 7e					ld a, (hl) 
0c11 23					inc hl 
0c12 66					ld h,(hl) 
0c13 6f					ld l, a 
0c14			 
0c14 cd 0a 0e				call ishlzero 
0c17 28 1a				jr z, .mdone 
0c19			 
0c19 eb					ex de, hl 
0c1a 3a 66 ea				ld a, (store_tmp3) 
0c1d cd c9 0b				call str_at_display 
0c20					 
0c20			 
0c20					; next item 
0c20 3a 69 ea				ld a, (store_tmp2+1) 
0c23 3c					inc a 
0c24 32 69 ea				ld (store_tmp2+1), a   ; display item count 
0c27			 
0c27			 		; next row 
0c27			 
0c27 3a 66 ea				ld a, (store_tmp3) 
0c2a c6 28				add display_cols 
0c2c 32 66 ea				ld (store_tmp3), a 
0c2f			 
0c2f					; at end of screen? 
0c2f			 
0c2f fe 10				cp display_rows*4 
0c31 20 d1				jr nz, .mitem 
0c33			 
0c33			 
0c33			.mdone: 
0c33 cd 0a 0e				call ishlzero 
0c36 28 08				jr z, .nodn 
0c38			 
0c38 3e 78				ld a, display_row_4 
0c3a 11 b7 0c				ld de, .mdown 
0c3d cd c9 0b				call str_at_display 
0c40			 
0c40					; draw options to fill the screens with active item on line 1 
0c40					; if current option is 2 or more then display ^ in top 
0c40			 
0c40 3a 68 ea		.nodn:		ld a, (store_tmp2) 
0c43			;		cp 0 
0c43 b7					or a 
0c44 28 08				jr z, .noup 
0c46			 
0c46 3e 00				ld a, 0 
0c48 11 b5 0c				ld de, .mup 
0c4b cd c9 0b				call str_at_display 
0c4e			 
0c4e 3e 02		.noup:		ld a, 2 
0c50 11 b3 0c				ld de, .msel 
0c53 cd c9 0b				call str_at_display 
0c56			 
0c56					; if current option + 1 is not null then display V in bottom 
0c56					; get key 
0c56 cd d9 0b				call update_display 
0c59			 
0c59			 
0c59					; handle key 
0c59			 
0c59 cd a8 65				call cin_wait 
0c5c			 
0c5c fe 05				cp KEY_UP 
0c5e 28 2b				jr z, .mgoup 
0c60 fe 61				cp 'a' 
0c62 28 27				jr z, .mgoup 
0c64 fe 0a				cp KEY_DOWN 
0c66 28 31				jr z, .mgod 
0c68 fe 7a				cp 'z' 
0c6a 28 2d				jr z, .mgod 
0c6c fe 20				cp ' ' 
0c6e 28 33				jr z, .goend 
0c70 fe 0c				cp KEY_RIGHT 
0c72 28 2f				jr z, .goend 
0c74 fe 0d				cp KEY_CR 
0c76 28 2b				jr z, .goend 
0c78 fe 71				cp 'q' 
0c7a 28 0b				jr z, .goback 
0c7c			 
0c7c fe 0b				cp KEY_LEFT 
0c7e 28 07				jr z, .goback 
0c80 fe 08				cp KEY_BS 
0c82 28 03				jr z, .goback 
0c84 c3 f3 0b				jp .mloop 
0c87			 
0c87			.goback: 
0c87 3e 00			ld a, 0 
0c89 18 1c			jr .goend2 
0c8b			 
0c8b				; move up one 
0c8b			.mgoup: 
0c8b 3a 68 ea				ld a, (store_tmp2) 
0c8e			;		cp 0 
0c8e b7					or a 
0c8f ca f3 0b				jp z, .mloop 
0c92 3d					dec a 
0c93 32 68 ea				ld (store_tmp2), a 
0c96 c3 f3 0b				jp .mloop 
0c99			 
0c99				; move down one 
0c99			.mgod: 
0c99 3a 68 ea				ld a, (store_tmp2) 
0c9c 3c					inc a 
0c9d 32 68 ea				ld (store_tmp2), a 
0ca0 c3 f3 0b				jp .mloop 
0ca3			 
0ca3			 
0ca3			.goend: 
0ca3					; get selected item number 
0ca3			 
0ca3 3a 68 ea				ld a, (store_tmp2) 
0ca6 3c					inc a 
0ca7			 
0ca7			.goend2: 
0ca7 f5					push af 
0ca8			 
0ca8					; restore active fb 
0ca8					; TODO BUG assumes fb1 
0ca8			 
0ca8 21 07 ed				ld hl, display_fb1 
0cab 22 c3 eb				ld (display_fb_active), hl 
0cae			 
0cae					; restore main regs 
0cae			 
0cae			 
0cae cd d9 0b				call update_display 
0cb1			 
0cb1 f1					pop af 
0cb2			 
0cb2 c9				ret 
0cb3			 
0cb3 .. 00		.msel:   db ">",0 
0cb5 .. 00		.mup:   db "^",0 
0cb7 .. 00		.mdown:   db "v",0 
0cb9			 
0cb9			 
0cb9			; eof 
0cb9			 
# End of file firmware_display.asm
0cb9			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cb9			; random number generators 
0cb9			 
0cb9			 
0cb9			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cb9			 
0cb9			 
0cb9			;-----> Generate a random number 
0cb9			; output a=answer 0<=a<=255 
0cb9			; all registers are preserved except: af 
0cb9			random: 
0cb9 e5			        push    hl 
0cba d5			        push    de 
0cbb 2a a2 eb		        ld      hl,(randData) 
0cbe ed 5f		        ld      a,r 
0cc0 57			        ld      d,a 
0cc1 5e			        ld      e,(hl) 
0cc2 19			        add     hl,de 
0cc3 85			        add     a,l 
0cc4 ac			        xor     h 
0cc5 22 a2 eb		        ld      (randData),hl 
0cc8 d1			        pop     de 
0cc9 e1			        pop     hl 
0cca c9			        ret 
0ccb			 
0ccb			 
0ccb			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ccb			 
0ccb			 
0ccb			 
0ccb			;------LFSR------ 
0ccb			;James Montelongo 
0ccb			;optimized by Spencer Putt 
0ccb			;out: 
0ccb			; a = 8 bit random number 
0ccb			RandLFSR: 
0ccb 21 a8 eb		        ld hl,LFSRSeed+4 
0cce 5e			        ld e,(hl) 
0ccf 23			        inc hl 
0cd0 56			        ld d,(hl) 
0cd1 23			        inc hl 
0cd2 4e			        ld c,(hl) 
0cd3 23			        inc hl 
0cd4 7e			        ld a,(hl) 
0cd5 47			        ld b,a 
0cd6 cb 13		        rl e  
0cd8 cb 12			rl d 
0cda cb 11		        rl c  
0cdc 17				rla 
0cdd cb 13		        rl e  
0cdf cb 12			rl d 
0ce1 cb 11		        rl c  
0ce3 17				rla 
0ce4 cb 13		        rl e  
0ce6 cb 12			rl d 
0ce8 cb 11		        rl c  
0cea 17				rla 
0ceb 67			        ld h,a 
0cec cb 13		        rl e  
0cee cb 12			rl d 
0cf0 cb 11		        rl c  
0cf2 17				rla 
0cf3 a8			        xor b 
0cf4 cb 13		        rl e  
0cf6 cb 12			rl d 
0cf8 ac			        xor h 
0cf9 a9			        xor c 
0cfa aa			        xor d 
0cfb 21 aa eb		        ld hl,LFSRSeed+6 
0cfe 11 ab eb		        ld de,LFSRSeed+7 
0d01 01 07 00		        ld bc,7 
0d04 ed b8		        lddr 
0d06 12			        ld (de),a 
0d07 c9			        ret 
0d08			 
0d08			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d08			 
0d08			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d08			 
0d08			 
0d08			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d08			 
0d08			prng16: 
0d08			;Inputs: 
0d08			;   (seed1) contains a 16-bit seed value 
0d08			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d08			;Outputs: 
0d08			;   HL is the result 
0d08			;   BC is the result of the LCG, so not that great of quality 
0d08			;   DE is preserved 
0d08			;Destroys: 
0d08			;   AF 
0d08			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d08			;160cc 
0d08			;26 bytes 
0d08 2a 9c eb		    ld hl,(seed1) 
0d0b 44			    ld b,h 
0d0c 4d			    ld c,l 
0d0d 29			    add hl,hl 
0d0e 29			    add hl,hl 
0d0f 2c			    inc l 
0d10 09			    add hl,bc 
0d11 22 9c eb		    ld (seed1),hl 
0d14 2a 9a eb		    ld hl,(seed2) 
0d17 29			    add hl,hl 
0d18 9f			    sbc a,a 
0d19 e6 2d		    and %00101101 
0d1b ad			    xor l 
0d1c 6f			    ld l,a 
0d1d 22 9a eb		    ld (seed2),hl 
0d20 09			    add hl,bc 
0d21 c9			    ret 
0d22			 
0d22			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d22			 
0d22			rand32: 
0d22			;Inputs: 
0d22			;   (seed1_0) holds the lower 16 bits of the first seed 
0d22			;   (seed1_1) holds the upper 16 bits of the first seed 
0d22			;   (seed2_0) holds the lower 16 bits of the second seed 
0d22			;   (seed2_1) holds the upper 16 bits of the second seed 
0d22			;   **NOTE: seed2 must be non-zero 
0d22			;Outputs: 
0d22			;   HL is the result 
0d22			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d22			;Destroys: 
0d22			;   AF 
0d22			;Tested and passes all CAcert tests 
0d22			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d22			;it has a period of 18,446,744,069,414,584,320 
0d22			;roughly 18.4 quintillion. 
0d22			;LFSR taps: 0,2,6,7  = 11000101 
0d22			;291cc 
0d22			;seed1_0=$+1 
0d22			;    ld hl,12345 
0d22			;seed1_1=$+1 
0d22			;    ld de,6789 
0d22			;    ld b,h 
0d22			;    ld c,l 
0d22			;    add hl,hl \ rl e \ rl d 
0d22			;    add hl,hl \ rl e \ rl d 
0d22			;    inc l 
0d22			;    add hl,bc 
0d22			;    ld (seed1_0),hl 
0d22			;    ld hl,(seed1_1) 
0d22			;    adc hl,de 
0d22			;    ld (seed1_1),hl 
0d22			;    ex de,hl 
0d22			;seed2_0=$+1 
0d22			;    ld hl,9876 
0d22			;seed2_1=$+1 
0d22			;    ld bc,54321 
0d22			;    add hl,hl \ rl c \ rl b 
0d22			;    ld (seed2_1),bc 
0d22			;    sbc a,a 
0d22			;    and %11000101 
0d22			;    xor l 
0d22			;    ld l,a 
0d22			;    ld (seed2_0),hl 
0d22			;    ex de,hl 
0d22			;    add hl,bc 
0d22			;    ret 
0d22			; 
0d22			 
0d22			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d22			; 20 bytes, 86 cycles (excluding ret) 
0d22			 
0d22			; returns   hl = pseudorandom number 
0d22			; corrupts   a 
0d22			 
0d22			; generates 16-bit pseudorandom numbers with a period of 65535 
0d22			; using the xorshift method: 
0d22			 
0d22			; hl ^= hl << 7 
0d22			; hl ^= hl >> 9 
0d22			; hl ^= hl << 8 
0d22			 
0d22			; some alternative shift triplets which also perform well are: 
0d22			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d22			 
0d22			;  org 32768 
0d22			 
0d22			xrnd: 
0d22 2a a0 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d25 3e 00		  ld a,0 
0d27 bd			  cp l 
0d28 20 02		  jr nz, .xrnd1 
0d2a 2e 01		  ld l, 1 
0d2c			.xrnd1: 
0d2c			 
0d2c 7c			  ld a,h 
0d2d 1f			  rra 
0d2e 7d			  ld a,l 
0d2f 1f			  rra 
0d30 ac			  xor h 
0d31 67			  ld h,a 
0d32 7d			  ld a,l 
0d33 1f			  rra 
0d34 7c			  ld a,h 
0d35 1f			  rra 
0d36 ad			  xor l 
0d37 6f			  ld l,a 
0d38 ac			  xor h 
0d39 67			  ld h,a 
0d3a			 
0d3a 22 a0 eb		  ld (xrandc),hl 
0d3d			 
0d3d c9			  ret 
0d3e			;  
0d3e			 
0d3e			 
0d3e			;;;; int maths 
0d3e			 
0d3e			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d3e			; Divide 16-bit values (with 16-bit result) 
0d3e			; In: Divide BC by divider DE 
0d3e			; Out: BC = result, HL = rest 
0d3e			; 
0d3e			Div16: 
0d3e 21 00 00		    ld hl,0 
0d41 78			    ld a,b 
0d42 06 08		    ld b,8 
0d44			Div16_Loop1: 
0d44 17			    rla 
0d45 ed 6a		    adc hl,hl 
0d47 ed 52		    sbc hl,de 
0d49 30 01		    jr nc,Div16_NoAdd1 
0d4b 19			    add hl,de 
0d4c			Div16_NoAdd1: 
0d4c 10 f6		    djnz Div16_Loop1 
0d4e 17			    rla 
0d4f 2f			    cpl 
0d50 47			    ld b,a 
0d51 79			    ld a,c 
0d52 48			    ld c,b 
0d53 06 08		    ld b,8 
0d55			Div16_Loop2: 
0d55 17			    rla 
0d56 ed 6a		    adc hl,hl 
0d58 ed 52		    sbc hl,de 
0d5a 30 01		    jr nc,Div16_NoAdd2 
0d5c 19			    add hl,de 
0d5d			Div16_NoAdd2: 
0d5d 10 f6		    djnz Div16_Loop2 
0d5f 17			    rla 
0d60 2f			    cpl 
0d61 41			    ld b,c 
0d62 4f			    ld c,a 
0d63 c9			ret 
0d64			 
0d64			 
0d64			;http://z80-heaven.wikidot.com/math 
0d64			; 
0d64			;Inputs: 
0d64			;     DE and A are factors 
0d64			;Outputs: 
0d64			;     A is not changed 
0d64			;     B is 0 
0d64			;     C is not changed 
0d64			;     DE is not changed 
0d64			;     HL is the product 
0d64			;Time: 
0d64			;     342+6x 
0d64			; 
0d64			Mult16: 
0d64			 
0d64 06 08		     ld b,8          ;7           7 
0d66 21 00 00		     ld hl,0         ;10         10 
0d69 29			       add hl,hl     ;11*8       88 
0d6a 07			       rlca          ;4*8        32 
0d6b 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d6d 19			         add hl,de   ;--         -- 
0d6e 10 f9		       djnz $-5      ;13*7+8     99 
0d70 c9			ret 
0d71			 
0d71			; 
0d71			; Square root of 16-bit value 
0d71			; In:  HL = value 
0d71			; Out:  D = result (rounded down) 
0d71			; 
0d71			;Sqr16: 
0d71			;    ld de,#0040 
0d71			;    ld a,l 
0d71			;    ld l,h 
0d71			;    ld h,d 
0d71			;    or a 
0d71			;    ld b,8 
0d71			;Sqr16_Loop: 
0d71			;    sbc hl,de 
0d71			;    jr nc,Sqr16_Skip 
0d71			;    add hl,de 
0d71			;Sqr16_Skip: 
0d71			;    ccf 
0d71			;    rl d 
0d71			;    add a,a 
0d71			;    adc hl,hl 
0d71			;    add a,a 
0d71			;    adc hl,hl 
0d71			;    djnz Sqr16_Loop 
0d71			;    ret 
0d71			; 
0d71			; 
0d71			; Divide 8-bit values 
0d71			; In: Divide E by divider C 
0d71			; Out: A = result, B = rest 
0d71			; 
0d71			Div8: 
0d71 af			    xor a 
0d72 06 08		    ld b,8 
0d74			Div8_Loop: 
0d74 cb 13		    rl e 
0d76 17			    rla 
0d77 91			    sub c 
0d78 30 01		    jr nc,Div8_NoAdd 
0d7a 81			    add a,c 
0d7b			Div8_NoAdd: 
0d7b 10 f7		    djnz Div8_Loop 
0d7d 47			    ld b,a 
0d7e 7b			    ld a,e 
0d7f 17			    rla 
0d80 2f			    cpl 
0d81 c9			    ret 
0d82			 
0d82			; 
0d82			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d82			; In: Multiply A with DE 
0d82			; Out: HL = result 
0d82			; 
0d82			Mult12U: 
0d82 2e 00		    ld l,0 
0d84 87			    add a,a 
0d85 30 01		    jr nc,Mult12U_NoAdd0 
0d87 19			    add hl,de 
0d88			Mult12U_NoAdd0: 
0d88 29			    add hl,hl 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd1 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd1: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd2 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd2: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd3 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd3: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd4 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd4: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd5 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd5: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd6 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd6: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 d0			    ret nc 
0da9 19			    add hl,de 
0daa c9			    ret 
0dab			 
0dab			; 
0dab			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dab			; In: Multiply A with DE 
0dab			;      Put lowest value in A for most efficient calculation 
0dab			; Out: HL = result 
0dab			; 
0dab			Mult12R: 
0dab 21 00 00		    ld hl,0 
0dae			Mult12R_Loop: 
0dae cb 3f		    srl a 
0db0 30 01		    jr nc,Mult12R_NoAdd 
0db2 19			    add hl,de 
0db3			Mult12R_NoAdd: 
0db3 cb 23		    sla e 
0db5 cb 12		    rl d 
0db7 b7			    or a 
0db8 c2 ae 0d		    jp nz,Mult12R_Loop 
0dbb c9			    ret 
0dbc			 
0dbc			; 
0dbc			; Multiply 16-bit values (with 32-bit result) 
0dbc			; In: Multiply BC with DE 
0dbc			; Out: BCHL = result 
0dbc			; 
0dbc			Mult32: 
0dbc 79			    ld a,c 
0dbd 48			    ld c,b 
0dbe 21 00 00		    ld hl,0 
0dc1 06 10		    ld b,16 
0dc3			Mult32_Loop: 
0dc3 29			    add hl,hl 
0dc4 17			    rla 
0dc5 cb 11		    rl c 
0dc7 30 07		    jr nc,Mult32_NoAdd 
0dc9 19			    add hl,de 
0dca ce 00		    adc a,0 
0dcc d2 d0 0d		    jp nc,Mult32_NoAdd 
0dcf 0c			    inc c 
0dd0			Mult32_NoAdd: 
0dd0 10 f1		    djnz Mult32_Loop 
0dd2 41			    ld b,c 
0dd3 4f			    ld c,a 
0dd4 c9			    ret 
0dd5			 
0dd5			 
0dd5			 
0dd5			; 
0dd5			; Multiply 8-bit values 
0dd5			; In:  Multiply H with E 
0dd5			; Out: HL = result 
0dd5			; 
0dd5			Mult8: 
0dd5 16 00		    ld d,0 
0dd7 6a			    ld l,d 
0dd8 06 08		    ld b,8 
0dda			Mult8_Loop: 
0dda 29			    add hl,hl 
0ddb 30 01		    jr nc,Mult8_NoAdd 
0ddd 19			    add hl,de 
0dde			Mult8_NoAdd: 
0dde 10 fa		    djnz Mult8_Loop 
0de0 c9			    ret 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			;;http://z80-heaven.wikidot.com/math 
0de1			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de1			; 
0de1			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de1			;     ld a,16        ;7 
0de1			;     ld hl,0        ;10 
0de1			;     jp $+5         ;10 
0de1			;.DivLoop: 
0de1			;       add hl,bc    ;-- 
0de1			;       dec a        ;64 
0de1			;       jr z,.DivLoopEnd        ;86 
0de1			; 
0de1			;       sla e        ;128 
0de1			;       rl d         ;128 
0de1			;       adc hl,hl    ;240 
0de1			;       sbc hl,bc    ;240 
0de1			;       jr nc,.DivLoop ;23|21 
0de1			;       inc e        ;-- 
0de1			;       jp .DivLoop+1 
0de1			; 
0de1			;.DivLoopEnd: 
0de1			 
0de1			;HL_Div_C: 
0de1			;Inputs: 
0de1			;     HL is the numerator 
0de1			;     C is the denominator 
0de1			;Outputs: 
0de1			;     A is the remainder 
0de1			;     B is 0 
0de1			;     C is not changed 
0de1			;     DE is not changed 
0de1			;     HL is the quotient 
0de1			; 
0de1			;       ld b,16 
0de1			;       xor a 
0de1			;         add hl,hl 
0de1			;         rla 
0de1			;         cp c 
0de1			;         jr c,$+4 
0de1			;           inc l 
0de1			;           sub c 
0de1			;         djnz $-7 
0de1			 
0de1			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de1			 
0de1			addatohl: 
0de1 85			    add   a, l    ; A = A+L 
0de2 6f			    ld    l, a    ; L = A+L 
0de3 8c			    adc   a, h    ; A = A+L+H+carry 
0de4 95			    sub   l       ; A = H+carry 
0de5 67			    ld    h, a    ; H = H+carry 
0de6 c9			ret 
0de7			 
0de7			addatode: 
0de7 83			    add   a, e    ; A = A+L 
0de8 5f			    ld    e, a    ; L = A+L 
0de9 8a			    adc   a, d    ; A = A+L+H+carry 
0dea 93			    sub   e       ; A = H+carry 
0deb 57			    ld    d, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			 
0ded			addatobc: 
0ded 81			    add   a, c    ; A = A+L 
0dee 4f			    ld    c, a    ; L = A+L 
0def 88			    adc   a, b    ; A = A+L+H+carry 
0df0 91			    sub   c       ; A = H+carry 
0df1 47			    ld    b, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			subafromhl: 
0df3			   ; If A=0 do nothing 
0df3			    ; Otherwise flip A's sign. Since 
0df3			    ; the upper byte becomes -1, also 
0df3			    ; substract 1 from H. 
0df3 ed 44		    neg 
0df5 ca fe 0d		    jp    z, Skip 
0df8 25			    dec   h 
0df9			     
0df9			    ; Now add the low byte as usual 
0df9			    ; Two's complement takes care of 
0df9			    ; ensuring the result is correct 
0df9 85			    add   a, l 
0dfa 6f			    ld    l, a 
0dfb 8c			    adc   a, h 
0dfc 95			    sub   l 
0dfd 67			    ld    h, a 
0dfe			Skip: 
0dfe c9				ret 
0dff			 
0dff			 
0dff			; compare hl and de 
0dff			; returns:  
0dff			; if hl = de, z=1, s=0, c0=0 
0dff			; if hl > de, z=0, s=0, c=0 
0dff			; if hl < de, z=0, s=1, c=1 
0dff			cmp16:	 
0dff b7				or a 
0e00 ed 52			sbc hl,de 
0e02 e0				ret po 
0e03 7c				ld a,h 
0e04 1f				rra 
0e05 ee 40			xor 01000000B 
0e07 37				scf 
0e08 8f				adc a,a 
0e09 c9				ret 
0e0a			 
0e0a			 
0e0a			; test if hl contains zero   - A is destroyed 
0e0a			 
0e0a			ishlzero:    
0e0a b7				or a     ; reset flags 
0e0b 7c				ld a, h 
0e0c b5				or l        	 
0e0d			 
0e0d c9				ret 
0e0e			 
0e0e			 
0e0e			 
0e0e			 
0e0e			if FORTH_ENABLE_FLOATMATH 
0e0e			;include "float/bbcmath.z80" 
0e0e			include "float/lpfpcalc.asm" 
0e0e			endif 
0e0e			 
0e0e			 
0e0e			; eof 
0e0e			 
# End of file firmware_maths.asm
0e0e			include "firmware_strings.asm"   ; string handling  
0e0e			 
0e0e			 
0e0e			; TODO string len 
0e0e			; input text string, end on cr with zero term 
0e0e			; a offset into frame buffer to start prompt 
0e0e			; d is max length 
0e0e			; e is display size TODO 
0e0e			; c is current cursor position 
0e0e			; hl is ptr to where string will be stored and edited directly 
0e0e			 
0e0e			 
0e0e			; TODO check limit of buffer for new inserts 
0e0e			; TODO check insert does not push beyond buffer 
0e0e			; TODO scroll in a limited display area 
0e0e			; TODO scroll whole screen on page wrap 
0e0e			 
0e0e			 
0e0e			; TODO use LCD cursor? 
0e0e			 
0e0e			EDIT_V1: equ 0 
0e0e			EDIT_V2: equ 1 
0e0e			 
0e0e			 
0e0e			 
0e0e			if EDIT_V2 
0e0e			input_str: 
0e0e			 
0e0e 32 5b ee			    	ld (input_at_pos),a      ; save display position to start 
0e11			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e11 22 5e ee				ld (input_start), hl     ; save ptr to buffer 
0e14			;		ld a, c 
0e14			;		call addatohl 
0e14			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e14 7a					ld a,d 
0e15 32 5d ee			        ld (input_size), a       ; save length of input area 
0e18 79					ld a, c 
0e19 32 4c ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e1c 7b					ld a,e 
0e1d 32 5c ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e20			 
0e20			 
0e20					; add a trailing space to make screen refresh nicer 
0e20			 
0e20					;ld hl, (input_start) 
0e20					;push hl 
0e20					;ld a, 0 
0e20					;call strlent 
0e20					;ld a, l 
0e20					;pop hl 
0e20					;call addatohl 
0e20					;dec hl 
0e20					;ld a, ' ' 
0e20					;ld (hl), a 
0e20					;inc hl 
0e20					;ld (hl), a 
0e20					;inc hl 
0e20					;ld a, 0 
0e20					;ld (hl), a 
0e20			 
0e20			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e20					; init cursor shape if not set by the cin routines 
0e20 21 b8 eb				ld hl, cursor_shape 
0e23			if BASE_KEV 
0e23			;		ld a, 255 
0e23					ld (hl), 255 
0e23			else 
0e23					;ld a, '#' 
0e23 36 23				ld (hl), '#' 
0e25			endif 
0e25 23					inc hl 
0e26			;		ld a, 0 
0e26 36 00				ld (hl), 0 
0e28			 
0e28 3e 09				ld a, CUR_BLINK_RATE 
0e2a 32 57 ee				ld (input_cur_flash), a 
0e2d 3e 01				ld a, 1 
0e2f 32 56 ee				ld (input_cur_onoff),a 
0e32			.inmain:	 
0e32			 
0e32 cd 53 0f				call input_disp_ref 
0e35			 
0e35					; save current length of string 
0e35			 
0e35 2a 5e ee				ld hl, (input_start) 
0e38 3e 00				ld a, 0 
0e3a cd 44 11				call strlent 
0e3d 7d					ld a,l 
0e3e 32 51 ee				ld (input_len), a 
0e41			 
0e41					;call input_disp_oncur 
0e41			 
0e41					; display current state of input buffer 
0e41			 
0e41					; clean any backspace chars 
0e41			 
0e41 3e 20				ld a, " " 
0e43 32 b8 e2				ld (scratch),a 
0e46 3e 00				ld a, 0 
0e48 32 b9 e2				ld (scratch+1),a 
0e4b 3a 5b ee				ld a,(input_at_pos) 
0e4e 85					add l 
0e4f 11 b8 e2				ld de, scratch 
0e52 cd c9 0b				call str_at_display 
0e55			 
0e55					; pause 1ms 
0e55			 
0e55 3e 01				ld a, 1 
0e57 cd d5 0a				call aDelayInMS 
0e5a			 
0e5a			; display cursor if visible on this cycle 
0e5a			 
0e5a					; dec flash counter 
0e5a 3a 57 ee				ld a, (input_cur_flash) 
0e5d 3d					dec a 
0e5e 32 57 ee				ld (input_cur_flash), a 
0e61			;		cp 0 
0e61 b7					or a 
0e62 20 0d				jr nz, .inochgstate 
0e64			 
0e64			 
0e64					; reset on change of state 
0e64 3e 09				ld a, CUR_BLINK_RATE 
0e66 32 57 ee				ld (input_cur_flash), a 
0e69			 
0e69					; change state 
0e69 3a 56 ee				ld a,(input_cur_onoff) 
0e6c ed 44				neg 
0e6e 32 56 ee				ld (input_cur_onoff),a 
0e71			 
0e71			 
0e71			 
0e71			 
0e71					; TODO is cursor visible? 
0e71					; TODO if so then over write the char at curspos pos with the cursor shape 
0e71			 
0e71								 
0e71			 
0e71			.inochgstate: 
0e71 3a 56 ee				ld a,(input_cur_onoff) 
0e74 fe ff				cp 255 
0e76 28 0e				jr z, .skipcursor 
0e78 3a 5b ee				ld a, (input_at_pos) 
0e7b 47					ld b, a 
0e7c 3a 4c ee				ld a, (input_cursor) 
0e7f 80					add b 
0e80 11 b8 eb				ld de, cursor_shape 
0e83					 
0e83 cd c9 0b				call str_at_display 
0e86			 
0e86			.skipcursor: 
0e86				if DEBUG_INPUTV2 
0e86			 
0e86					ld a,(input_at_pos) 
0e86					ld hl, LFSRSeed 
0e86					call hexout 
0e86					ld a, (input_cursor) 
0e86					ld hl, LFSRSeed+2 
0e86					call hexout 
0e86					ld a,(input_size) 
0e86					ld hl, LFSRSeed+4 
0e86					call hexout 
0e86			 
0e86					ld a,(input_cur_onoff) 
0e86					ld hl, LFSRSeed+6 
0e86					call hexout 
0e86			 
0e86					ld a,(input_cur_flash) 
0e86					ld hl, LFSRSeed+8 
0e86					call hexout 
0e86			 
0e86					ld a,(input_len) 
0e86					ld hl, LFSRSeed+10 
0e86					call hexout 
0e86					ld hl, LFSRSeed+12 
0e86			;		ld a, 0 
0e86					ld (hl),0 
0e86					ld a, display_row_4 
0e86					ld de, LFSRSeed 
0e86					call str_at_display 
0e86				endif 
0e86 cd d9 0b				call update_display 
0e89			 
0e89					; TODO keyboard processing 
0e89			 
0e89			if BASE_CPM 
0e89 cd a8 65				call cin_wait 
0e8c			else 
0e8c					call cin    ; _wait 
0e8c			endif 
0e8c			;		cp 0 
0e8c b7					or a 
0e8d ca 32 0e				jp z, .inmain 
0e90			 
0e90 fe 0b				cp KEY_LEFT    ; cursor left 
0e92 ca 45 0f				jp z, input_left 
0e95				 
0e95 fe 0c				cp KEY_RIGHT      ; cursor right 
0e97 ca 4c 0f				jp z, input_right 
0e9a			 
0e9a fe 0d				cp KEY_CR 
0e9c c8					ret z 
0e9d			 
0e9d fe 08				cp KEY_BS 
0e9f ca b7 0f				jp z, input_delchar 
0ea2			 
0ea2 fe 06				cp KEY_NEXTWORD 
0ea4 ca cb 0e				jp z, input_nxtword 
0ea7			 
0ea7 fe 07				cp KEY_PREVWORD 
0ea9 ca f0 0e				jp z, input_prvword 
0eac			 
0eac fe 0e				cp KEY_HOME    ; jump to start of line 
0eae 20 08				jr nz, .ikh 
0eb0 3e 00				ld a, 0 
0eb2 32 4c ee				ld (input_cursor), a 
0eb5 ca 32 0e				jp z, .inmain 
0eb8			.ikh: 
0eb8			 
0eb8 fe 0f				cp KEY_END     ; jump to end of line 
0eba 20 09				jr nz, .ike 
0ebc 3a 51 ee				ld a, (input_len) 
0ebf 32 4c ee				ld (input_cursor),a 
0ec2 ca 32 0e				jp z, .inmain 
0ec5			.ike: 
0ec5 fe 05			        cp KEY_UP      ; recall last command 
0ec7 c8					ret z 
0ec8			;jr nz, .irec 
0ec8			; TODO next word 
0ec8			; TODO prev word 
0ec8			;  
0ec8			; 
0ec8			;	ld hl, scratch 
0ec8			;	ld de, os_last_cmd 
0ec8			;	call strcpy 
0ec8			;		jp  .inmain 
0ec8			.irec: 
0ec8			;		jr .instr1 
0ec8			 
0ec8			 
0ec8			 
0ec8					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ec8			 
0ec8			; TODO return if any special keys are given 
0ec8			;		ld l, a 
0ec8			;		ld a, 28 ; KEY_F12   ; 27 
0ec8			;		sub l 
0ec8			;		ret m 
0ec8			;		ld a, l 
0ec8					; if no special key then insert as a char 
0ec8			 
0ec8 c3 8c 0f				jp input_inschr 
0ecb			 
0ecb				 
0ecb			input_nxtword: 
0ecb				; jump to start next word after the cursor 
0ecb			 
0ecb			.insknwn:	 
0ecb cd 82 0f				call input_curptr	 
0ece 7e					ld a,(hl)	 
0ecf			;		cp 0 
0ecf b7					or a 
0ed0 ca 32 0e				jp z, .inmain    ; end of string 
0ed3			 
0ed3			; if we are on a word, then move off of it 
0ed3			 
0ed3 fe 20				cp ' ' 
0ed5 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ed7 21 4c ee				ld hl, input_cursor 
0eda 34					inc (hl) 
0edb 18 ee				jr .insknwn 
0edd			 
0edd			.inspace: 
0edd			 
0edd cd 82 0f				call input_curptr	 
0ee0 7e					ld a,(hl)	 
0ee1			;		cp 0 
0ee1 b7					or a 
0ee2 ca 32 0e				jp z, .inmain    ; end of string 
0ee5			 
0ee5			; if we are on a word, then move off of it 
0ee5			 
0ee5 fe 20				cp ' ' 
0ee7 c2 32 0e				jp nz, .inmain     ; we are on non space so at next word 
0eea 21 4c ee				ld hl, input_cursor 
0eed 34					inc (hl) 
0eee 18 ed				jr .inspace 
0ef0			 
0ef0			 
0ef0			 
0ef0			 
0ef0			input_prvword: 
0ef0				; jump to the start of previous word before the cursor 
0ef0			 
0ef0			; where are we to start with currently? 
0ef0			 
0ef0 cd 82 0f				call input_curptr	 
0ef3 7e					ld a, (hl) 
0ef4 fe 20				cp ' ' 
0ef6 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0ef8			 
0ef8			 
0ef8			 
0ef8			.inskpwn:	 
0ef8 3a 4c ee				ld a,(input_cursor) 
0efb			;		cp 0 
0efb b7					or a 
0efc ca 32 0e				jp z, .inmain    ; start of string 
0eff			 
0eff			;if we are on a word, then move off of it 
0eff			 
0eff cd 82 0f				call input_curptr	 
0f02 7e					ld a, (hl) 
0f03 fe 20				cp ' ' 
0f05 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f07					;jp z, .inmain    ; start of string 
0f07 21 4c ee				ld hl, input_cursor 
0f0a 35					dec (hl) 
0f0b 18 eb				jr .inskpwn 
0f0d			.iwstart: 
0f0d 21 4c ee				ld hl, input_cursor 
0f10 34					inc (hl) 
0f11 c3 32 0e				jp .inmain 
0f14					 
0f14			 
0f14			.inspacep: 
0f14			 
0f14					;jp .inmain    ; start of string 
0f14			 
0f14			 
0f14			 
0f14 3a 4c ee				ld a,(input_cursor) 
0f17			;		cp 0 
0f17 b7					or a 
0f18 ca 32 0e				jp z, .inmain    ; start of string 
0f1b			 
0f1b			; if we are on a word, then move off of it 
0f1b			 
0f1b cd 82 0f				call input_curptr	 
0f1e 7e					ld a, (hl) 
0f1f fe 20				cp ' ' 
0f21 c2 2a 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f24 21 4c ee				ld hl, input_cursor 
0f27 35					dec (hl) 
0f28 18 ea				jr .inspacep 
0f2a			 
0f2a			 
0f2a			.incharp:	 
0f2a					; eat the word to get to the start 
0f2a 3a 4c ee				ld a,(input_cursor) 
0f2d			;		cp 0 
0f2d b7					or a 
0f2e ca 32 0e				jp z, .inmain    ; start of string 
0f31			 
0f31			; if we are on a word, then move off of it 
0f31			 
0f31 cd 82 0f				call input_curptr	 
0f34 7e					ld a, (hl) 
0f35 fe 20				cp ' ' 
0f37 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f39 21 4c ee				ld hl, input_cursor 
0f3c 35					dec (hl) 
0f3d 18 eb				jr .incharp 
0f3f			.ipwordst: 
0f3f					; at space before the prev word so reposition over it 
0f3f 21 4c ee				ld hl, input_cursor 
0f42 34					inc (hl) 
0f43 18 b3				jr .inskpwn 
0f45					 
0f45			 
0f45			 
0f45			input_left: 
0f45				; move cursor left 
0f45 21 4c ee			ld hl, input_cursor 
0f48 35				dec (hl) 
0f49			;	cp 0 
0f49			;	jp z, .inmain    ; ignore left as at the start of the string 
0f49 c3 32 0e			jp .inmain 
0f4c			 
0f4c			input_right: 
0f4c				; move cursor right 
0f4c				 
0f4c				;ld a, (input_size) 
0f4c				;ld b, a 
0f4c 21 4c ee			ld hl, input_cursor 
0f4f 34				inc (hl) 
0f50				;dec b 
0f50				;cp 0 
0f50				;jp z, .inmain   ; ignore as at end of the string buffer 
0f50				;ld a, b 
0f50				;inc a 
0f50				;ld (input_cursor), a 
0f50 c3 32 0e			jp .inmain 
0f53			 
0f53			 
0f53			 
0f53			input_disp_ref: 
0f53				; display the text from start of buffer (ie full refresh) 
0f53 3a 5b ee			ld a, (input_at_pos) 
0f56 2a 5e ee			ld hl,(input_start) 
0f59 eb				ex de, hl 
0f5a cd c9 0b			call str_at_display  
0f5d c9				ret 
0f5e			input_disp_oncur: 
0f5e				; display the text from cursor position to end of buffer 
0f5e				; TODO position start of string at cursor position on screen 
0f5e				; TODO draw from that point on 
0f5e 3a 4c ee			ld a, (input_cursor) 
0f61 47				ld b, a 
0f62 3a 5b ee			ld a, (input_at_pos) 
0f65 80				add b 
0f66 48				ld c, b     ; save a 
0f67 78				ld a, b     ; inc string start for cursor 
0f68 2a 5e ee			ld hl,(input_start) 
0f6b cd e1 0d			call addatohl 
0f6e eb				ex de, hl 
0f6f 79				ld a, c 
0f70 cd c9 0b			call str_at_display  
0f73 c9				ret 
0f74			 
0f74			input_nxtw: 
0f74				; Find next word 
0f74 c9				ret 
0f75			 
0f75			input_prvw: 
0f75				; Find previous word 
0f75 c9				ret 
0f76			 
0f76			input_lenrem:   
0f76				; Calculate the length of string remaining from current cursor 
0f76				; position to end of buffer (exc null term) 
0f76				 
0f76 3a 4c ee			ld a, (input_cursor) 
0f79 4f				ld c, a 
0f7a 3a 5d ee			ld a, (input_size) 
0f7d 91				sub c 
0f7e 06 00			ld b, 0 
0f80 0d				dec c 
0f81 c9				ret	 
0f82			 
0f82			input_curptr: 
0f82				; calc address of the character under the cursor 
0f82				 
0f82 2a 5e ee			ld hl, (input_start) 
0f85 3a 4c ee			ld a, (input_cursor) 
0f88 cd e1 0d			call addatohl 
0f8b c9				ret 
0f8c			 
0f8c			input_inschr: 
0f8c				; Insert char at cursor position 
0f8c f5				push af   ; save char 
0f8d				;call input_lenrem    ; get bc length of remaining string 
0f8d			 
0f8d				 
0f8d cd 82 0f			call input_curptr 
0f90			;	ld hl, (input_start) 
0f90			;	ld a, (input_cursor) 
0f90			;	call addatohl 
0f90				;push hl   ; save to come back to 
0f90			 
0f90				; shift everything up one to end of buffer 
0f90			 
0f90				;push hl 
0f90				;dec de 
0f90				;inc de 
0f90			;	ldir 
0f90				 
0f90				;pop hl 
0f90			 
0f90				; are we adding to the end of line? 
0f90			 
0f90 3a 4c ee			ld a, (input_cursor) 
0f93 47				ld b, a 
0f94 3a 51 ee			ld a, (input_len) 
0f97 b8				cp b 
0f98 20 08			jr nz, .insmid   ; no, insert in middle of text 
0f9a			 
0f9a				; tack on the end of the line 
0f9a f1				pop af 
0f9b 77				ld (hl), a   ; save new char 
0f9c 23				inc hl 
0f9d			;	ld a, 0 
0f9d 36 00			ld (hl), 0 
0f9f c3 4c 0f			jp input_right 
0fa2				 
0fa2			.insmid: 
0fa2				; hl has insertion point so move everything up one to allow for insertion 
0fa2				;call input_shiftright 
0fa2 f1				pop af 
0fa3			 
0fa3			.shufinsmid: 
0fa3 47				ld b, a     ; b contains new char, c prev char at this position  
0fa4 7e				ld a, (hl) 
0fa5			 
0fa5			;	cp 0    ; at end of string need to then dump new char and add term 
0fa5 b7				or a 
0fa6 28 07			jr z, .endinsmid 
0fa8 4f				ld c, a 
0fa9 78				ld a, b 
0faa 77				ld (hl), a 
0fab 23				inc hl 
0fac 79				ld a, c 
0fad 18 f4			jr .shufinsmid 
0faf				 
0faf			 
0faf			 
0faf			 
0faf			.endinsmid: 
0faf 78				ld a, b 
0fb0 77				ld (hl), a 
0fb1 23				inc hl 
0fb2			;	ld a, 0 
0fb2 36 00			ld (hl), 0 
0fb4			 
0fb4			 
0fb4			;	ld (hl), a   ; save new char 
0fb4			 
0fb4 c3 4c 0f			jp input_right 
0fb7			 
0fb7			;input_shiftright: 
0fb7			;	; shift text right at cursor, hl has shift start 
0fb7			;	push hl 
0fb7			;	push de 
0fb7			;	push bc 
0fb7			; 
0fb7			; 
0fb7			;	; move to end of string past zero term 
0fb7			;	ld hl,(input_start) 
0fb7			;	ld a, (input_len) 
0fb7			;	call addatohl 
0fb7			;	inc hl 
0fb7			;;	inc hl 
0fb7			;;	inc hl 
0fb7			;	ld a, 0 
0fb7			;	ld (hl), a 
0fb7			;;	dec hl 
0fb7			;	 
0fb7			;;	ld (hl), a 
0fb7			;;	dec hl 
0fb7			; 
0fb7			;	push hl 
0fb7			;	pop de 
0fb7			;	inc de 
0fb7			;	 
0fb7			; 
0fb7			;;	ld hl,(input_start) 
0fb7			;;	ld a, (input_cursor) 
0fb7			;;	call addatohl 
0fb7			; 
0fb7			; 
0fb7			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fb7			;	call input_lenrem    ; get bc length of remaining string 
0fb7			;	;ld a, (input_cursor) 
0fb7			;	;ld c, a 
0fb7			;	ld a, (input_len) 
0fb7			;	cp 2 
0fb7			;	jr z, .iskipzero	 
0fb7			;	;sub c 
0fb7			;	;inc a 
0fb7			;	;ld c, a 
0fb7			;	;ld b, 0 
0fb7			;	inc c 
0fb7			;	inc c 
0fb7			;	; move data 
0fb7			;	lddr 
0fb7			;.iskipzero: 
0fb7			; 
0fb7			;	pop bc 
0fb7			;	pop de 
0fb7			;	pop hl 
0fb7			;	ret	 
0fb7			 
0fb7			input_delchar: 
0fb7				; Delete char at cursor position 
0fb7 cd 76 0f			call input_lenrem    ; get bc length of remaining string 
0fba 2a 5e ee			ld hl, (input_start) 
0fbd 3a 4c ee			ld a, (input_cursor) 
0fc0 cd e1 0d			call addatohl 
0fc3			 
0fc3 e5				push hl 
0fc4 d1				pop de 
0fc5 1b				dec de 
0fc6			 
0fc6			.dl:	 
0fc6 ed a0			ldi  
0fc8 7e				ld a, (hl) 
0fc9			;	cp 0 
0fc9 b7				or a 
0fca 28 02			jr z, .dldone 
0fcc 18 f8			jr .dl 
0fce			.dldone: 
0fce ed a0			ldi 
0fd0			 
0fd0 c3 45 0f			jp input_left 
0fd3			 
0fd3			 
0fd3			endif 
0fd3			 
0fd3			 
0fd3			 
0fd3			if EDIT_V1 
0fd3			input_str: 
0fd3			 
0fd3				    	ld (input_at_pos),a      ; save display position to start 
0fd3					add c 
0fd3					ld (input_at_cursor),a	; save draw pos of cursor 
0fd3					ld (input_start), hl     ; save ptr to buffer 
0fd3					ld a, c 
0fd3					call addatohl 
0fd3					ld (input_ptr), hl     ; save ptr to point under the cursor 
0fd3					ld a,d 
0fd3				        ld (input_size), a       ; save length of input area 
0fd3					ld a, c 
0fd3					ld (input_cursor),a      ; init cursor start position  
0fd3					ld a,e 
0fd3				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fd3					 
0fd3					 
0fd3			 
0fd3			;		ld a,(input_ptr) 
0fd3			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fd3			 
0fd3			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fd3					; init cursor shape if not set by the cin routines 
0fd3					ld hl, cursor_shape 
0fd3			if BASE_KEV 
0fd3					ld a, 255 
0fd3			else 
0fd3					ld a, '#' 
0fd3			endif 
0fd3					ld (hl), a 
0fd3					inc hl 
0fd3					ld a, 0 
0fd3					ld (hl), a 
0fd3			 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3					ld a, 1 
0fd3					ld (input_cur_onoff),a 
0fd3			 
0fd3			;	if DEBUG_INPUT 
0fd3			;		push af 
0fd3			;		ld a, 'I' 
0fd3			;		ld (debug_mark),a 
0fd3			;		pop af 
0fd3			;		CALLMONITOR 
0fd3			;	endif 
0fd3			.is1:		; main entry loop 
0fd3			 
0fd3			 
0fd3			 
0fd3					; pause 1ms 
0fd3			 
0fd3					ld a, 1 
0fd3					call aDelayInMS 
0fd3			 
0fd3					; dec flash counter 
0fd3					ld a, (input_cur_flash) 
0fd3					dec a 
0fd3					ld (input_cur_flash), a 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jr nz, .nochgstate 
0fd3			 
0fd3			 
0fd3					; change state 
0fd3					ld a,(input_cur_onoff) 
0fd3					neg 
0fd3					ld (input_cur_onoff),a 
0fd3			 
0fd3			 
0fd3					; reset on change of state 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3			.nochgstate: 
0fd3					 
0fd3					 
0fd3			 
0fd3					; display cursor  
0fd3			 
0fd3			;		ld hl, (input_start) 
0fd3			;		ld a, (input_cursor) 
0fd3			;		call addatohl 
0fd3			 
0fd3					; get char under cursor and replace with cursor 
0fd3			ld hl, (input_ptr) 
0fd3			;		ld a, (hl) 
0fd3			;		ld (input_under_cursor),a 
0fd3			;		ld a, '_' 
0fd3			;		ld (hl), a 
0fd3			 
0fd3					; display string 
0fd3			 
0fd3					ld de, (input_start) 
0fd3					ld a, (input_at_pos) 
0fd3					call str_at_display 
0fd3			;	        call update_display 
0fd3			 
0fd3					; find place to put the cursor 
0fd3			;		add h 
0fd3			;		ld l, display_row_1 
0fd3			;		sub l 
0fd3			; (input_at_pos) 
0fd3					;ld c, a 
0fd3			;		ld a, (input_cursor) 
0fd3			;		ld l, (input_at_pos) 
0fd3			;		;ld b, h 
0fd3			;		add l 
0fd3			;		ld (input_at_cursor),a 
0fd3					;ld l,h 
0fd3			 
0fd3			;		ld h, 0 
0fd3			;		ld l,(input_at_pos) 
0fd3			;		ld a, (input_cursor) 
0fd3			;		call addatohl 
0fd3			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd3			;		call subafromhl 
0fd3			;		ld a,l 
0fd3			;		ld (input_at_cursor), a 
0fd3			 
0fd3				if DEBUG_INPUT 
0fd3					ld a, (hardware_diag) 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jr z, .skip_input_diag 
0fd3			 
0fd3					ld a,(input_at_pos) 
0fd3					ld hl, LFSRSeed 
0fd3					call hexout 
0fd3					ld a, (input_cursor) 
0fd3					ld hl, LFSRSeed+2 
0fd3					call hexout 
0fd3					ld a,(input_at_cursor) 
0fd3					ld hl, LFSRSeed+4 
0fd3					call hexout 
0fd3			 
0fd3					ld a,(input_cur_onoff) 
0fd3					ld hl, LFSRSeed+6 
0fd3					call hexout 
0fd3			 
0fd3					ld a,(input_cur_flash) 
0fd3					ld hl, LFSRSeed+8 
0fd3					call hexout 
0fd3			 
0fd3					ld a,(input_len) 
0fd3					ld hl, LFSRSeed+10 
0fd3					call hexout 
0fd3					ld hl, LFSRSeed+12 
0fd3					ld a, 0 
0fd3					ld (hl),a 
0fd3					ld a, display_row_4 
0fd3					ld de, LFSRSeed 
0fd3					call str_at_display 
0fd3					.skip_input_diag: 
0fd3				endif 
0fd3			 
0fd3					; decide on if we are showing the cursor this time round 
0fd3			 
0fd3					ld a, (input_cur_onoff) 
0fd3					cp 255 
0fd3					jr z, .skipcur 
0fd3			 
0fd3			 
0fd3					ld a,(input_at_cursor) 
0fd3					ld de, cursor_shape 
0fd3					call str_at_display 
0fd3			 
0fd3					; save length of current input string 
0fd3					ld hl, (input_start) 
0fd3					ld a, 0 
0fd3					call strlent 
0fd3					ld a,l 
0fd3					ld (input_len),a 
0fd3			 
0fd3			.skipcur: 
0fd3			 
0fd3				        call update_display 
0fd3					 
0fd3			 
0fd3			 
0fd3					; wait 
0fd3				 
0fd3					; TODO loop without wait to flash the cursor and char under cursor	 
0fd3					call cin    ; _wait 
0fd3			 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1 
0fd3			 
0fd3					; get ptr to char to input into 
0fd3			 
0fd3					ld c,a 
0fd3					ld hl, (input_start) 
0fd3					ld a, (input_cursor) 
0fd3					call addatohl 
0fd3					ld (input_ptr), hl 
0fd3					ld a,c 
0fd3			 
0fd3					; replace char under cursor 
0fd3			 
0fd3			;		ld hl, (input_ptr) 
0fd3			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fd3			;		ld (hl), a 
0fd3			 
0fd3			;	if DEBUG_INPUT 
0fd3			;		push af 
0fd3			;		ld a, 'i' 
0fd3			;		ld (debug_mark),a 
0fd3			;		pop af 
0fd3			;		CALLMONITOR 
0fd3			;	endif 
0fd3					cp KEY_HOME 
0fd3					jr nz, .iske 
0fd3			 
0fd3					ld a, (input_at_pos) 
0fd3					ld (input_at_cursor),a 
0fd3					ld a, 0 
0fd3					ld (input_cursor), a 
0fd3					jp .is1 
0fd3					 
0fd3			.iske:		cp KEY_END 
0fd3					jr nz, .isknw 
0fd3					jp .is1 
0fd3			 
0fd3			.isknw:		cp KEY_NEXTWORD 
0fd3					jr nz, .iskpw 
0fd3			 
0fd3			.isknwm:	ld hl, (input_ptr) 
0fd3					ld a,(hl)	 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1    ; end of string 
0fd3					cp ' ' 
0fd3					jp z, .is1    ; end of word 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3					jr .isknwm 
0fd3			 
0fd3			.iskpw:		cp KEY_PREVWORD 
0fd3					jr nz, .iskl 
0fd3			.iskpwm:	 
0fd3					ld hl, (input_ptr) 
0fd3					ld a,(hl)	 
0fd3			;		cp 0  
0fd3					or a 
0fd3					jp z, .is1    ; end of string 
0fd3					cp ' ' 
0fd3					jp z, .is1    ; end of word 
0fd3					dec hl 
0fd3					ld (input_ptr), hl 
0fd3					ld a, (input_at_cursor) 
0fd3					dec a 
0fd3					ld (input_at_cursor), a 
0fd3					jr .iskpwm 
0fd3			 
0fd3			 
0fd3			.iskl:		cp KEY_LEFT 
0fd3					jr nz, .isk1 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3			 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1 		; at start of line to ignore  
0fd3			 
0fd3					dec  a 		; TODO check underflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					dec hl 
0fd3					ld (input_ptr), hl 
0fd3					 
0fd3					ld a, (input_at_cursor) 
0fd3					dec a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk1:		cp KEY_RIGHT 
0fd3					jr nz, .isk2 
0fd3			 
0fd3					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0fd3					ld e,a 
0fd3					ld a, (input_cursor) 
0fd3					cp e 
0fd3					jp z, .is1		; at the end of string so dont go right 
0fd3			 
0fd3					inc  a 		; TODO check overflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk2:		cp KEY_UP 
0fd3			 
0fd3					jr nz, .isk3 
0fd3			 
0fd3					; swap last command with the current on 
0fd3			 
0fd3					; move cursor to start of string 
0fd3					ld hl, (input_start) 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					ld a, (input_at_pos) 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld a, 0 
0fd3					ld (input_cursor), a 
0fd3					 
0fd3					; swap input and last command buffers 
0fd3			 
0fd3					ld hl, os_cli_cmd 
0fd3					ld de, os_last_cmd 
0fd3					ld b, 255 
0fd3			.swap1:		ld a, (hl) 
0fd3					ld c,a 
0fd3					ld a, (de) 
0fd3					ld (hl), a 
0fd3					ld a,c 
0fd3					ld (de),a 
0fd3					inc hl 
0fd3					inc de 
0fd3					djnz .swap1 
0fd3			 
0fd3			 
0fd3			 
0fd3			 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk3:		cp KEY_BS 
0fd3					jr nz, .isk4 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3			 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1 		; at start of line to ignore  
0fd3			 
0fd3					dec  a 		; TODO check underflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					; hl is source 
0fd3					; de needs to be source - 1 
0fd3			 
0fd3			;		ld a, 0 
0fd3			;		dec hl 
0fd3			;		ld (hl), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					dec hl 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					; shift all data 
0fd3			 
0fd3					push hl 
0fd3					inc hl 
0fd3					pop de 
0fd3					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0fd3					ld c,a 
0fd3					ld b,0 
0fd3					ldir  
0fd3			 
0fd3			 
0fd3			 
0fd3			 
0fd3					ld a, (input_at_cursor) 
0fd3					dec a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3			 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3					; remove char 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld de,.iblank 
0fd3					call str_at_display 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk4:		cp KEY_CR 
0fd3					jr z, .endinput 
0fd3			 
0fd3					; else add the key press to the end 
0fd3			 
0fd3					ld c, a			; save key pressed 
0fd3			 
0fd3					ld a,(hl)		; get what is currently under char 
0fd3			 
0fd3			;		cp 0			; we are at the end of the string 
0fd3					or a 
0fd3					jr nz, .onchar 
0fd3					 
0fd3					; add a char to the end of the string 
0fd3				 
0fd3					ld (hl),c 
0fd3					inc hl 
0fd3			;		ld a,' ' 
0fd3			;		ld (hl),a 
0fd3			;		inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3					dec hl 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3					inc a				; TODO check max string length and scroll  
0fd3					ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3			;	if DEBUG_INPUT 
0fd3			;		push af 
0fd3			;		ld a, '+' 
0fd3			;		ld (debug_mark),a 
0fd3			;		pop af 
0fd3			;		CALLMONITOR 
0fd3			;	endif 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3					jp .is1 
0fd3					 
0fd3			 
0fd3			 
0fd3					; if on a char then insert 
0fd3			.onchar: 
0fd3			 
0fd3					; TODO over flow check: make sure insert does not blow out buffer 
0fd3			 
0fd3					; need to do some maths to use lddr 
0fd3			 
0fd3					push hl   ; save char pos 
0fd3					push bc 
0fd3			 
0fd3					ld hl, (input_start) 
0fd3					ld a, (input_len) 
0fd3					call addatohl  		; end of string 
0fd3					inc hl 
0fd3					inc hl		; past zero term 
0fd3					push hl 
0fd3					inc hl 
0fd3					push hl  
0fd3			 
0fd3								; start and end of lddr set, now how much to move? 
0fd3			 
0fd3							 
0fd3					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fd3					ld b,a 
0fd3					ld a,(input_len) 
0fd3					ld e,a 
0fd3					sub b 
0fd3					inc a		;?? 
0fd3					inc a		;?? 
0fd3					inc a		;?? 
0fd3			 
0fd3					ld b,0 
0fd3					ld c,a 
0fd3			 
0fd3				if DEBUG_INPUT 
0fd3					push af 
0fd3					ld a, 'i' 
0fd3					ld (debug_mark),a 
0fd3					pop af 
0fd3			;		CALLMONITOR 
0fd3				endif 
0fd3					pop de 
0fd3					pop hl 
0fd3				if DEBUG_INPUT 
0fd3					push af 
0fd3					ld a, 'I' 
0fd3					ld (debug_mark),a 
0fd3					pop af 
0fd3			;		CALLMONITOR 
0fd3				endif 
0fd3					lddr 
0fd3				 
0fd3			 
0fd3			 
0fd3					; TODO have a key for insert/overwrite mode???? 
0fd3					pop bc 
0fd3					pop hl 
0fd3					ld (hl), c		; otherwise overwrite current char 
0fd3					 
0fd3			 
0fd3			 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3					inc  a 		; TODO check overflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.endinput:	; TODO look for end of string 
0fd3			 
0fd3					; add trailing space for end of token 
0fd3			 
0fd3					ld hl, (input_start) 
0fd3					ld a,(input_len) 
0fd3					call addatohl 
0fd3					ld a, ' ' 
0fd3					ld (hl),a 
0fd3					; TODO eof of parse marker 
0fd3			 
0fd3					inc hl 
0fd3					ld a, 0 
0fd3					ld (hl),a 
0fd3			 
0fd3			 
0fd3					ret 
0fd3			 
0fd3			.iblank: db " ",0 
0fd3			 
0fd3			 
0fd3			input_str_prev:	ld (input_at_pos), a 
0fd3					ld (input_start), hl 
0fd3					ld a,1			; add cursor 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3					ld (input_ptr), hl 
0fd3					ld a,d 
0fd3					ld (input_size), a 
0fd3					ld a,0 
0fd3					ld (input_cursor),a 
0fd3			.instr1:	 
0fd3			 
0fd3					; TODO do block cursor 
0fd3					; TODO switch cursor depending on the modifer key 
0fd3			 
0fd3					; update cursor shape change on key hold 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					dec hl 
0fd3					ld a,(cursor_shape) 
0fd3					ld (hl), a 
0fd3			 
0fd3					; display entered text 
0fd3					ld a,(input_at_pos) 
0fd3			            	CALL fLCD_Pos       ;Position cursor to location in A 
0fd3			            	LD   de, (input_start) 
0fd3			            	CALL fLCD_Str       ;Display string pointed to by DE 
0fd3			 
0fd3					call cin 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jr z, .instr1 
0fd3			 
0fd3					; proecess keyboard controls first 
0fd3			 
0fd3					ld hl,(input_ptr) 
0fd3			 
0fd3					cp KEY_CR	 ; pressing enter ends input 
0fd3					jr z, .instrcr 
0fd3			 
0fd3					cp KEY_BS 	; back space 
0fd3					jr nz, .instr2 
0fd3					; process back space 
0fd3			 
0fd3					; TODO stop back space if at start of string 
0fd3					dec hl 
0fd3					dec hl ; to over write cursor 
0fd3					ld a,(cursor_shape) 
0fd3					;ld a,0 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a," " 
0fd3					ld (hl),a 
0fd3					ld (input_ptr),hl 
0fd3					 
0fd3			 
0fd3					jr .instr1 
0fd3			 
0fd3			.instr2:	cp KEY_LEFT    ; cursor left 
0fd3					jr nz, .instr3 
0fd3					dec hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3				 
0fd3			.instr3:	cp KEY_RIGHT      ; cursor right 
0fd3					jr nz, .instr4 
0fd3					inc hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3			 
0fd3			.instr4:	cp KEY_HOME    ; jump to start of line 
0fd3					jr nz, .instr5 
0fd3					dec hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3			 
0fd3			.instr5:	cp KEY_END     ; jump to end of line 
0fd3					jr nz, .instr6 
0fd3					dec hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3			.instr6:        cp KEY_UP      ; recall last command 
0fd3					jr nz, .instrnew 
0fd3			 
0fd3				ld hl, scratch 
0fd3				ld de, os_last_cmd 
0fd3				call strcpy 
0fd3					jr .instr1 
0fd3			 
0fd3			 
0fd3			.instrnew:	; no special key pressed to see if we have room to store it 
0fd3			 
0fd3					; TODO do string size test 
0fd3			 
0fd3					dec hl ; to over write cursor 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,(cursor_shape) 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3			 
0fd3					ld (input_ptr),hl 
0fd3					 
0fd3					jr .instr1 
0fd3			.instrcr:	dec hl		; remove cursor 
0fd3					ld a,' '	; TODO add a trailing space for safety 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3			 
0fd3			 
0fd3					; if at end of line scroll up    
0fd3					; TODO detecting only end of line 4 for scroll up  
0fd3			 
0fd3					;ld   
0fd3			 
0fd3					ret 
0fd3			 
0fd3			 
0fd3			endif 
0fd3			; strcpy hl = dest, de source 
0fd3			 
0fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fd4 b7			            OR   A              ;Null terminator? 
0fd5 c8			            RET  Z              ;Yes, so finished 
0fd6 1a					ld a,(de) 
0fd7 77					ld (hl),a 
0fd8 13			            INC  DE             ;Point to next character 
0fd9 23					inc hl 
0fda 18 f7		            JR   strcpy       ;Repeat 
0fdc c9					ret 
0fdd			 
0fdd			 
0fdd			; TODO string_at  
0fdd			; pass string which starts with lcd offset address and then null term string 
0fdd			 
0fdd			; TODO string to dec 
0fdd			; TODO string to hex 
0fdd			; TODO byte to string hex 
0fdd			; TODO byte to string dec 
0fdd			 
0fdd			 
0fdd			 
0fdd			; from z80uartmonitor 
0fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fdd			; pass hl for where to put the text 
0fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fdd c5			hexout:	PUSH BC 
0fde f5					PUSH AF 
0fdf 47					LD B, A 
0fe0					; Upper nybble 
0fe0 cb 3f				SRL A 
0fe2 cb 3f				SRL A 
0fe4 cb 3f				SRL A 
0fe6 cb 3f				SRL A 
0fe8 cd f8 0f				CALL tohex 
0feb 77					ld (hl),a 
0fec 23					inc hl	 
0fed					 
0fed					; Lower nybble 
0fed 78					LD A, B 
0fee e6 0f				AND 0FH 
0ff0 cd f8 0f				CALL tohex 
0ff3 77					ld (hl),a 
0ff4 23					inc hl	 
0ff5					 
0ff5 f1					POP AF 
0ff6 c1					POP BC 
0ff7 c9					RET 
0ff8					 
0ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ff8			tohex: 
0ff8 e5					PUSH HL 
0ff9 d5					PUSH DE 
0ffa 16 00				LD D, 0 
0ffc 5f					LD E, A 
0ffd 21 05 10				LD HL, .DATA 
1000 19					ADD HL, DE 
1001 7e					LD A, (HL) 
1002 d1					POP DE 
1003 e1					POP HL 
1004 c9					RET 
1005			 
1005			.DATA: 
1005 30					DEFB	30h	; 0 
1006 31					DEFB	31h	; 1 
1007 32					DEFB	32h	; 2 
1008 33					DEFB	33h	; 3 
1009 34					DEFB	34h	; 4 
100a 35					DEFB	35h	; 5 
100b 36					DEFB	36h	; 6 
100c 37					DEFB	37h	; 7 
100d 38					DEFB	38h	; 8 
100e 39					DEFB	39h	; 9 
100f 41					DEFB	41h	; A 
1010 42					DEFB	42h	; B 
1011 43					DEFB	43h	; C 
1012 44					DEFB	44h	; D 
1013 45					DEFB	45h	; E 
1014 46					DEFB	46h	; F 
1015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1015			;;    subtract $30, if result > 9 then subtract $7 more 
1015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1015			atohex: 
1015 d6 30				SUB $30 
1017 fe 0a				CP 10 
1019 f8					RET M		; If result negative it was 0-9 so we're done 
101a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
101c c9					RET		 
101d			 
101d			 
101d			 
101d			 
101d			; Get 2 ASCII characters as hex byte from pointer in hl 
101d			 
101d			BYTERD: 
101d 16 00			LD	D,00h		;Set up 
101f cd 27 10			CALL	HEXCON		;Get byte and convert to hex 
1022 87				ADD	A,A		;First nibble so 
1023 87				ADD	A,A		;multiply by 16 
1024 87				ADD	A,A		; 
1025 87				ADD	A,A		; 
1026 57				LD	D,A		;Save hi nibble in D 
1027			HEXCON: 
1027 7e				ld a, (hl)		;Get next chr 
1028 23				inc hl 
1029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
102b fe 0a			CP	00Ah		;Is it 0-9 ? 
102d 38 02			JR	C,NALPHA	;If so miss next bit 
102f d6 07			SUB	007h		;Else convert alpha 
1031			NALPHA: 
1031 b2				OR	D		;Add hi nibble back 
1032 c9				RET			; 
1033			 
1033			 
1033			; 
1033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1033			; Since the routines get_byte and therefore get_nibble are called, only valid 
1033			; characters (0-9a-f) are accepted. 
1033			; 
1033			;get_word        push    af 
1033			;                call    get_byte        ; Get the upper byte 
1033			;                ld      h, a 
1033			;                call    get_byte        ; Get the lower byte 
1033			;                ld      l, a 
1033			;                pop     af 
1033			;                ret 
1033			; 
1033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1033			; the routine get_nibble is used only valid characters are accepted - the  
1033			; input routine only accepts characters 0-9a-f. 
1033			; 
1033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1034 7e					ld a,(hl) 
1035 23					inc hl 
1036 cd 5b 10		                call    nibble2val      ; Get upper nibble 
1039 cb 07		                rlc     a 
103b cb 07		                rlc     a 
103d cb 07		                rlc     a 
103f cb 07		                rlc     a 
1041 47			                ld      b, a            ; Save upper four bits 
1042 7e					ld a,(hl) 
1043 cd 5b 10		                call    nibble2val      ; Get lower nibble 
1046 b0			                or      b               ; Combine both nibbles 
1047 c1			                pop     bc              ; Restore B (and C) 
1048 c9			                ret 
1049			; 
1049			; Get a hexadecimal digit from the serial line. This routine blocks until 
1049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1049			; to the serial line interface. The lower 4 bits of A contain the value of  
1049			; that particular digit. 
1049			; 
1049			;get_nibble      ld a,(hl)           ; Read a character 
1049			;                call    to_upper        ; Convert to upper case 
1049			;                call    is_hex          ; Was it a hex digit? 
1049			;                jr      nc, get_nibble  ; No, get another character 
1049			 ;               call    nibble2val      ; Convert nibble to value 
1049			 ;               call    print_nibble 
1049			 ;               ret 
1049			; 
1049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1049			; A valid hexadecimal digit is denoted by a set C flag. 
1049			; 
1049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1049			;                ret     nc              ; Yes 
1049			;                cp      '0'             ; Less than '0'? 
1049			;                jr      nc, is_hex_1    ; No, continue 
1049			;                ccf                     ; Complement carry (i.e. clear it) 
1049			;                ret 
1049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1049			;                ret     c               ; Yes 
1049			;                cp      'A'             ; Less than 'A'? 
1049			;                jr      nc, is_hex_2    ; No, continue 
1049			;                ccf                     ; Yes - clear carry and return 
1049			;                ret 
1049			;is_hex_2        scf                     ; Set carry 
1049			;                ret 
1049			; 
1049			; Convert a single character contained in A to upper case: 
1049			; 
1049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
104b d8			                ret     c 
104c fe 7b		                cp      'z' + 1         ; > 'z'? 
104e d0			                ret     nc              ; Nothing to do, either 
104f e6 5f		                and     $5f             ; Convert to upper case 
1051 c9			                ret 
1052			 
1052			 
1052			to_lower: 
1052			 
1052			   ; if char is in [A-Z] make it lower case 
1052			 
1052			   ; enter : a = char 
1052			   ; exit  : a = lower case char 
1052			   ; uses  : af 
1052			 
1052 fe 41		   cp 'A' 
1054 d8			   ret c 
1055			    
1055 fe 5b		   cp 'Z'+1 
1057 d0			   ret nc 
1058			    
1058 f6 20		   or $20 
105a c9			   ret 
105b			 
105b			; 
105b			; Expects a hexadecimal digit (upper case!) in A and returns the 
105b			; corresponding value in A. 
105b			; 
105b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
105d 38 02		                jr      c, nibble2val_1 ; Yes 
105f d6 07		                sub     7               ; Adjust for A-F 
1061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1063 e6 0f		                and     $f              ; Only return lower 4 bits 
1065 c9			                ret 
1066			; 
1066			; Print_nibble prints a single hex nibble which is contained in the lower  
1066			; four bits of A: 
1066			; 
1066			;print_nibble    push    af              ; We won't destroy the contents of A 
1066			;                and     $f              ; Just in case... 
1066			;                add     a, '0'             ; If we have a digit we are done here. 
1066			;                cp      '9' + 1         ; Is the result > 9? 
1066			;                jr      c, print_nibble_1 
1066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1066			;print_nibble_1  call    putc            ; Print the nibble and 
1066			;                pop     af              ; restore the original value of A 
1066			;                ret 
1066			;; 
1066			;; Send a CR/LF pair: 
1066			; 
1066			;crlf            push    af 
1066			;                ld      a, cr 
1066			;                call    putc 
1066			;                ld      a, lf 
1066			;                call    putc 
1066			;                pop     af 
1066			;                ret 
1066			; 
1066			; Print_word prints the four hex digits of a word to the serial line. The  
1066			; word is expected to be in HL. 
1066			; 
1066			;print_word      push    hl 
1066			;                push    af 
1066			;                ld      a, h 
1066			;                call    print_byte 
1066			;                ld      a, l 
1066			;                call    print_byte 
1066			;                pop     af 
1066			;                pop     hl 
1066			;                ret 
1066			; 
1066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1066			; The byte to be printed is expected to be in A. 
1066			; 
1066			;print_byte      push    af              ; Save the contents of the registers 
1066			;                push    bc 
1066			;                ld      b, a 
1066			;                rrca 
1066			;                rrca 
1066			;                rrca 
1066			;                rrca 
1066			;                call    print_nibble    ; Print high nibble 
1066			;                ld      a, b 
1066			;                call    print_nibble    ; Print low nibble 
1066			;                pop     bc              ; Restore original register contents 
1066			;                pop     af 
1066			;                ret 
1066			 
1066			 
1066			 
1066			 
1066			 
1066			fourehexhl:  
1066 7e				ld a,(hl) 
1067 cd 15 10			call atohex 
106a cb 3f				SRL A 
106c cb 3f				SRL A 
106e cb 3f				SRL A 
1070 cb 3f				SRL A 
1072 47				ld b, a 
1073 23				inc hl 
1074 7e				ld a,(hl) 
1075 23				inc hl 
1076 cd 15 10			call atohex 
1079 80				add b 
107a 57				ld d,a 
107b 7e				ld a,(hl) 
107c cd 15 10			call atohex 
107f cb 3f				SRL A 
1081 cb 3f				SRL A 
1083 cb 3f				SRL A 
1085 cb 3f				SRL A 
1087 47				ld b, a 
1088 23				inc hl 
1089 7e				ld a,(hl) 
108a 23				inc hl 
108b cd 15 10			call atohex 
108e 80				add b 
108f 5f				ld e, a 
1090 d5				push de 
1091 e1				pop hl 
1092 c9				ret 
1093			 
1093			; pass hl. returns z set if the byte at hl is a digit 
1093			;isdigithl:  
1093			;	push bc 
1093			;	ld a,(hl) 
1093			;	cp ':' 
1093			;	jr nc, .isdf 		; > 
1093			;	cp '0' 
1093			;	jr c, .isdf		; < 
1093			; 
1093			;	; TODO find a better way to set z 
1093			; 
1093			;	ld b,a 
1093			;	cp b 
1093			;	pop bc 
1093			;	ret 
1093			; 
1093			;.isdf:	; not digit so clear z 
1093			; 
1093			;	; TODO find a better way to unset z 
1093			; 
1093			;	ld b,a 
1093			;	inc b 
1093			;	cp b 
1093			; 
1093			;	pop bc 
1093			;	ret 
1093				 
1093				 
1093			 
1093			 
1093			; pass hl as the four byte address to load 
1093			 
1093			get_word_hl:  
1093 e5				push hl 
1094 cd 33 10			call get_byte 
1097				 
1097 47				ld b, a 
1098			 
1098 e1				pop hl 
1099 23				inc hl 
109a 23				inc hl 
109b			 
109b			; TODO not able to handle a-f  
109b 7e				ld a,(hl) 
109c			;	;cp ':' 
109c			;	cp 'g' 
109c			;	jr nc, .single_byte_hl 		; > 
109c			;	cp 'G' 
109c			;	jr nc, .single_byte_hl 		; > 
109c			;	cp '0' 
109c			;	jr c, .single_byte_hl		; < 
109c			 
109c				;call isdigithl 
109c			;	cp 0 
109c b7				or a 
109d 28 06			jr z, .single_byte_hl 
109f			 
109f			.getwhln:   ; hex word so get next byte 
109f			 
109f cd 33 10			call get_byte 
10a2 6f				ld l, a 
10a3 60				ld h,b 
10a4 c9				ret 
10a5 68			.single_byte_hl:   ld l,b 
10a6 26 00				ld h,0 
10a8 c9					ret 
10a9			 
10a9			 
10a9			 
10a9			 
10a9 21 b1 17			ld hl,asc+1 
10ac			;	ld a, (hl) 
10ac			;	call nibble2val 
10ac cd 33 10			call get_byte 
10af			 
10af			;	call fourehexhl 
10af 32 ec e2			ld (scratch+52),a 
10b2				 
10b2 21 ea e2			ld hl,scratch+50 
10b5 22 db e5			ld (os_cur_ptr),hl 
10b8			 
10b8 c9				ret 
10b9			 
10b9			 
10b9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10b9			 
10b9			; Decimal Unsigned Version 
10b9			 
10b9			;Number in a to decimal ASCII 
10b9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10b9			;Example: display a=56 as "056" 
10b9			;input: a = number 
10b9			;Output: a=0,value of a in the screen 
10b9			;destroys af,bc (don't know about hl and de) 
10b9			DispAToASCII: 
10b9 0e 9c			ld	c,-100 
10bb cd c5 10			call	.Na1 
10be 0e f6			ld	c,-10 
10c0 cd c5 10			call	.Na1 
10c3 0e ff			ld	c,-1 
10c5 06 2f		.Na1:	ld	b,'0'-1 
10c7 04			.Na2:	inc	b 
10c8 81				add	a,c 
10c9 38 fc			jr	c,.Na2 
10cb 91				sub	c		;works as add 100/10/1 
10cc f5				push af		;safer than ld c,a 
10cd 78				ld	a,b		;char is in b 
10ce			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10ce f1				pop af		;safer than ld a,c 
10cf c9				ret 
10d0			 
10d0			; Decimal Signed Version 
10d0			 
10d0			; DispA 
10d0			; -------------------------------------------------------------- 
10d0			; Converts a signed integer value to a zero-terminated ASCII 
10d0			; string representative of that value (using radix 10). 
10d0			; -------------------------------------------------------------- 
10d0			; INPUTS: 
10d0			;     HL     Value to convert (two's complement integer). 
10d0			;     DE     Base address of string destination. (pointer). 
10d0			; -------------------------------------------------------------- 
10d0			; OUTPUTS: 
10d0			;     None 
10d0			; -------------------------------------------------------------- 
10d0			; REGISTERS/MEMORY DESTROYED 
10d0			; AF HL 
10d0			; -------------------------------------------------------------- 
10d0			 
10d0			;DispHLToASCII: 
10d0			;   push    de 
10d0			;   push    bc 
10d0			; 
10d0			;; Detect sign of HL. 
10d0			;    bit    7, h 
10d0			;    jr     z, ._DoConvert 
10d0			; 
10d0			;; HL is negative. Output '-' to string and negate HL. 
10d0			;    ld     a, '-' 
10d0			;    ld     (de), a 
10d0			;    inc    de 
10d0			; 
10d0			;; Negate HL (using two's complement) 
10d0			;    xor    a 
10d0			;    sub    l 
10d0			;    ld     l, a 
10d0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10d0			;    sbc    a, h 
10d0			;    ld     h, a 
10d0			; 
10d0			;; Convert HL to digit characters 
10d0			;._DoConvert: 
10d0			;    ld     b, 0     ; B will count character length of number 
10d0			;-   ld     a, 10 
10d0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10d0			;    push   af 
10d0			;    inc    b 
10d0			;    ld     a, h 
10d0			;    or     l 
10d0			;    jr     nz, - 
10d0			; 
10d0			;; Retrieve digits from stack 
10d0			;-   pop    af 
10d0			;    or     $30 
10d0			;    ld     (de), a 
10d0			;    inc    de 
10d0			;    djnz   - 
10d0			; 
10d0			;; Terminate string with NULL 
10d0			;    xor    a 
10d0			;    ld     (de), a 
10d0			; 
10d0			;    pop    bc 
10d0			;    pop    de 
10d0			;    ret 
10d0			 
10d0			;Comments 
10d0			; 
10d0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10d0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10d0			;    Note that the output string will not be fixed-width. 
10d0			; 
10d0			;Example Usage 
10d0			; 
10d0			;    ld    hl, -1004 
10d0			;    ld    de, OP1 
10d0			;    call  DispA 
10d0			;    ld    hl, OP1 
10d0			;    syscall  PutS 
10d0			 
10d0			 
10d0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10d0			 
10d0			 
10d0			;Converts an ASCII string to an unsigned 16-bit integer 
10d0			;Quits when it reaches a non-decimal digit 
10d0			 
10d0			string_to_uint16: 
10d0			atoui_16: 
10d0			;Input: 
10d0			;     DE points to the string 
10d0			;Outputs: 
10d0			;     HL is the result 
10d0			;     A is the 8-bit value of the number 
10d0			;     DE points to the byte after the number 
10d0			;Destroys: 
10d0			;     BC 
10d0			;       if the string is non-empty, BC is HL/10 
10d0			;Size:  24 bytes 
10d0			;Speed: 42+d(104+{0,9}) 
10d0			;       d is the number of digits in the number 
10d0			;       max is 640 cycles for a 5 digit number 
10d0			;Assuming no leading zeros: 
10d0			;1 digit:  146cc 
10d0			;2 digit:  250cc 
10d0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10d0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10d0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10d0			;avg: 544.81158447265625cc (544+13297/16384) 
10d0			;=============================================================== 
10d0 21 00 00		  ld hl,0 
10d3			.u16a: 
10d3 1a			  ld a,(de) 
10d4 d6 30		  sub 30h 
10d6 fe 0a		  cp 10 
10d8 d0			  ret nc 
10d9 13			  inc de 
10da 44			  ld b,h 
10db 4d			  ld c,l 
10dc 29			  add hl,hl 
10dd 29			  add hl,hl 
10de 09			  add hl,bc 
10df 29			  add hl,hl 
10e0 85			  add a,l 
10e1 6f			  ld l,a 
10e2 30 ef		  jr nc,.u16a 
10e4 24			  inc h 
10e5 c3 d3 10		  jp .u16a 
10e8			 
10e8			 
10e8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10e8			 
10e8			;written by Zeda 
10e8			;Converts a 16-bit unsigned integer to an ASCII string. 
10e8			 
10e8			uitoa_16: 
10e8			;Input: 
10e8			;   DE is the number to convert 
10e8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10e8			;Output: 
10e8			;   HL points to the null-terminated ASCII string 
10e8			;      NOTE: This isn't necessarily the same as the input HL. 
10e8 d5			  push de 
10e9 c5			  push bc 
10ea f5			  push af 
10eb eb			  ex de,hl 
10ec			 
10ec 01 f0 d8		  ld bc,-10000 
10ef 3e 2f		  ld a,'0'-1 
10f1 3c			  inc a 
10f2 09			  add hl,bc  
10f3 38 fc		   jr c,$-2 
10f5 12			  ld (de),a 
10f6 13			  inc de 
10f7			 
10f7 01 e8 03		  ld bc,1000 
10fa 3e 3a		  ld a,'9'+1 
10fc 3d			  dec a  
10fd 09			  add hl,bc  
10fe 30 fc		   jr nc,$-2 
1100 12			  ld (de),a 
1101 13			  inc de 
1102			 
1102 01 9c ff		  ld bc,-100 
1105 3e 2f		  ld a,'0'-1 
1107 3c			  inc a  
1108 09			  add hl,bc  
1109 38 fc		   jr c,$-2 
110b 12			  ld (de),a 
110c 13			  inc de 
110d			 
110d 7d			  ld a,l 
110e 26 3a		  ld h,'9'+1 
1110 25			  dec h  
1111 c6 0a		  add a,10  
1113 30 fb		   jr nc,$-3 
1115 c6 30		  add a,'0' 
1117 eb			  ex de,hl 
1118 72			  ld (hl),d 
1119 23			  inc hl 
111a 77			  ld (hl),a 
111b 23			  inc hl 
111c 36 00		  ld (hl),0 
111e			 
111e			;Now strip the leading zeros 
111e 0e fa		  ld c,-6 
1120 09			  add hl,bc 
1121 3e 30		  ld a,'0' 
1123 23			  inc hl  
1124 be			  cp (hl)  
1125 28 fc		  jr z,$-2 
1127			 
1127			;Make sure that the string is non-empty! 
1127 7e			  ld a,(hl) 
1128 b7			  or a 
1129 20 01		  jr nz,.atoub 
112b 2b			  dec hl 
112c			.atoub: 
112c			 
112c f1			  pop af 
112d c1			  pop bc 
112e d1			  pop de 
112f c9			  ret 
1130			 
1130			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1130			 
1130			toUpper: 
1130			;A is the char. 
1130			;If A is a lowercase letter, this sets it to the matching uppercase 
1130			;18cc or 30cc or 41cc 
1130			;avg: 26.75cc 
1130 fe 61		  cp 'a' 
1132 d8			  ret c 
1133 fe 7b		  cp 'z'+1 
1135 d0			  ret nc 
1136 d6 20		  sub 'a'-'A' 
1138 c9			  ret 
1139			 
1139			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1139			 
1139			; String Length 
1139			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1139			 
1139			; Get the length of the null-terminated string starting at $8000 hl 
1139			;    LD     HL, $8000 
1139			 
1139			strlenz: 
1139			 
1139 af			    XOR    A               ; Zero is the value we are looking for. 
113a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
113b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
113c			                           ; 65, 536 bytes (the entire addressable memory space). 
113c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
113e			 
113e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
113e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
113f 6f			    LD     L, A             ; number of bytes 
1140 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1142 2b			    DEC    HL              ; Compensate for null. 
1143 c9				ret 
1144			 
1144			; Get the length of the A terminated string starting at $8000 hl 
1144			;    LD     HL, $8000 
1144			 
1144			strlent: 
1144			 
1144			                  ; A is the value we are looking for. 
1144 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1146 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1148			                           ; 65, 536 bytes (the entire addressable memory space). 
1148 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
114a			 
114a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
114a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
114c 2e 00		    LD     L, 0             ; number of bytes 
114e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1150 2b			    DEC    HL              ; Compensate for null. 
1151 c9				ret 
1152			 
1152			 
1152			;Comparing Strings 
1152			 
1152			;IN    HL     Address of string1. 
1152			;      DE     Address of string2. 
1152			 
1152			; doc given but wrong??? 
1152			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1152			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1152			; tested 
1152			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1152			 
1152			strcmp_old: 
1152 e5			    PUSH   HL 
1153 d5			    PUSH   DE 
1154			 
1154 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1155 be			    CP     (HL)            ; (want to minimize work). 
1156 38 01		    JR     C, Str1IsBigger 
1158 7e			    LD     A, (HL) 
1159			 
1159			Str1IsBigger: 
1159 4f			    LD     C, A             ; Put length in BC 
115a 06 00		    LD     B, 0 
115c 13			    INC    DE              ; Increment pointers to meat of string. 
115d 23			    INC    HL 
115e			 
115e			CmpLoop: 
115e 1a			    LD     A, (DE)          ; Compare bytes. 
115f ed a1		    CPI 
1161 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1163 13			    INC    DE              ; Update pointer. 
1164 ea 5e 11		    JP     PE, CmpLoop 
1167			 
1167 d1			    POP    DE 
1168 e1			    POP    HL 
1169 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
116a be			    CP     (HL) 
116b c9			    RET 
116c			 
116c			NoMatch: 
116c 2b			    DEC    HL 
116d be			    CP     (HL)            ; Compare again to affect carry. 
116e d1			    POP    DE 
116f e1			    POP    HL 
1170 c9			    RET 
1171			 
1171			;; test strmp 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str2 
1171			;call strcmp 
1171			;jr z, .z1 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "NZ1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.z1: 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "ZZ1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str1 
1171			;call strcmp 
1171			;jr z, .z2 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "NZ2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.z2: 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "ZZ2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str2 
1171			;call strcmp 
1171			;jr c, .c1 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "Nc1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.c1: 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "cc1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str1 
1171			;call strcmp 
1171			;jr c, .c2 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "Nc2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.c2: 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "cc2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;	NEXTW 
1171			;.str1:   db "string1",0 
1171			;.str2:   db "string2",0 
1171			 
1171			; only care about direct match or not 
1171			; hl and de strings 
1171			; zero set if the same 
1171			 
1171			strcmp: 
1171 1a				ld a, (de) 
1172 be				cp (hl) 
1173 28 02			jr z, .ssame 
1175 b7				or a 
1176 c9				ret 
1177			 
1177			.ssame:  
1177			;	cp 0 
1177 b7				or a 
1178 c8				ret z 
1179			 
1179 23				inc hl 
117a 13				inc de 
117b 18 f4			jr strcmp 
117d				 
117d				 
117d			 
117d			;Copyright (c) 2014, Luke Maurits 
117d			;All rights reserved. 
117d			; 
117d			;Redistribution and use in source and binary forms, with or without 
117d			;modification, are permitted provided that the following conditions are met: 
117d			; 
117d			;* Redistributions of source code must retain the above copyright notice, this 
117d			;  list of conditions and the following disclaimer. 
117d			; 
117d			;* Redistributions in binary form must reproduce the above copyright notice, 
117d			;  this list of conditions and the following disclaimer in the documentation 
117d			;  and/or other materials provided with the distribution. 
117d			; 
117d			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
117d			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
117d			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
117d			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
117d			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
117d			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
117d			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
117d			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
117d			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
117d			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
117d			 
117d			; https://github.com/lmaurits/lm512/blob/master/string.z80 
117d			 
117d			StrictStrCmp: 
117d				; Load next chars of each string 
117d 1a				ld a, (de) 
117e 47				ld b, a 
117f 7e				ld a, (hl) 
1180				; Compare 
1180 b8				cp b 
1181				; Return non-zero if chars don't match 
1181 c0				ret nz 
1182				; Check for end of both strings 
1182 fe 00			cp "\0" 
1184				; Return if strings have ended 
1184 c8				ret z 
1185				; Otherwise, advance to next chars 
1185 23				inc hl 
1186 13				inc de 
1187 18 f4			jr StrictStrCmp 
1189			 
1189			;end 
1189			; eof 
1189			 
1189			 
1189			 
1189			 
1189			 
1189			 
# End of file firmware_strings.asm
1189			include "firmware_memory.asm"   ; malloc and free  
1189			 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189			.mallocsize: db "Wants malloc >256",0 
1189			.mallocasize: db "MALLOC gives >256",0 
1189			.malloczero: db "MALLOC gives zero",0 
1189			 
1189			malloc_guard_zerolen: 
1189				push hl 
1189				push de 
1189				push af 
1189			 
1189				ld de, 0 
1189			        call cmp16 
1189				jr nz, .lowalloz 
1189			 
1189				push hl 
1189				push de 
1189					ld hl, display_fb0 
1189					ld (display_fb_active), hl 
1189				call clear_display 
1189				ld a, 0 
1189				ld de, .malloczero 
1189				call str_at_display 
1189				call update_display 
1189				call delay1s 
1189				call delay1s 
1189				call bp_on 
1189			;	ld a, 0 
1189			;	ld (os_view_disable), a 
1189			 
1189				pop de 
1189				pop hl 
1189			 
1189				 
1189			 
1189				CALLMONITOR 
1189			.lowalloz: 
1189			 
1189			 
1189				pop af 
1189				pop de 
1189				pop hl 
1189			ret 
1189			 
1189			malloc_guard_entry: 
1189				push hl 
1189				push de 
1189				push af 
1189			 
1189			 	or a      ;clear carry flag 
1189				push hl 
1189				ld de, 255 
1189				sbc hl, de 
1189				jr c, .lowalloc 
1189			 
1189				push de 
1189					ld hl, display_fb0 
1189					ld (display_fb_active), hl 
1189				call clear_display 
1189				ld a, 0 
1189				ld de, .mallocsize 
1189				call str_at_display 
1189				call update_display 
1189				call delay1s 
1189				call delay1s 
1189			;	ld a, 0 
1189			;	ld (os_view_disable), a 
1189				call bp_on 
1189			 
1189				pop de 
1189				pop hl 
1189			 
1189				 
1189			 
1189				CALLMONITOR 
1189				jr .lowdone 
1189			.lowalloc: 
1189			 
1189			 
1189				pop hl 
1189			.lowdone:	pop af 
1189				pop de 
1189				pop hl 
1189			ret 
1189			 
1189			malloc_guard_exit: 
1189				push hl 
1189				push de 
1189				push af 
1189			 
1189			 	or a      ;clear carry flag 
1189				push hl 
1189				ld de, 255 
1189				sbc hl, de 
1189				jr c, .lowallocx 
1189			 
1189				push de 
1189					ld hl, display_fb0 
1189					ld (display_fb_active), hl 
1189				call clear_display 
1189				ld a, 0 
1189				ld de, .mallocasize 
1189				call str_at_display 
1189				call update_display 
1189				call delay1s 
1189				call delay1s 
1189			;	ld a, 0 
1189			;	ld (os_view_disable), a 
1189				call bp_on 
1189				pop de 
1189				pop hl 
1189			 
1189				CALLMONITOR 
1189				jr .lowdonex 
1189			.lowallocx: 
1189			 
1189				pop hl 
1189			.lowdonex:	pop af 
1189				pop de 
1189				pop hl 
1189			ret 
1189			endif 
1189			 
1189			if MALLOC_2 
1189			; Z80 Malloc and Free Functions 
1189			 
1189			; Malloc Function: 
1189			; Input: 
1189			;   HL: Size of block to allocate 
1189			; Output: 
1189			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1189			 
1189			malloc: 
1189				 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189			call malloc_guard_entry 
1189			endif 
1189			 
1189			 
1189			 
1189			 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "mal" 
1189						CALLMONITOR 
1189					endif 
1189			    push af            ; Save AF register 
1189			    ld a, l            ; Load low byte of size into A 
1189			    or h               ; Check if size is zero 
1189			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1189			 
1189			    ; Allocate memory 
1189			    ld hl, (heap_start) ; Load start of heap into HL 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "ma1" 
1189						CALLMONITOR 
1189					endif 
1189			    call malloc_internal ; Call internal malloc function 
1189			    pop af             ; Restore AF register 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret                ; Return 
1189			 
1189			; Free Function: 
1189			; Input: 
1189			;   HL: Pointer to memory block to free 
1189			; Output: 
1189			;   None 
1189			 
1189			free: 
1189			    push af            ; Save AF register 
1189			    ld a, l            ; Load low byte of pointer into A 
1189			    or h               ; Check if pointer is NULL 
1189			    jp z, free_exit    ; If pointer is NULL, exit 
1189			 
1189			    ; Free memory 
1189			    ld hl, (heap_start) ; Load start of heap into HL 
1189			    call free_internal  ; Call internal free function 
1189			    pop af             ; Restore AF register 
1189			    ret                ; Return 
1189			 
1189			; Internal Malloc Function: 
1189			; Input: 
1189			;   HL: Size of block to allocate 
1189			; Output: 
1189			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1189			 
1189			malloc_internal: 
1189			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1189			    add hl, bc         ; Add management overhead to requested size 
1189			    ex de, hl          ; Save total size in DE, and keep it in HL 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "ma2" 
1189						CALLMONITOR 
1189					endif 
1189			 
1189			    ; Search for free memory block 
1189			    ld de, (heap_end)  ; Load end of heap into DE 
1189			    ld bc, 0           ; Initialize counter 
1189			 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "ma2" 
1189						CALLMONITOR 
1189					endif 
1189			malloc_search_loop: 
1189			    ; Check if current block is free 
1189			    ld a, (hl)         ; Load current block's status (free or used) 
1189			;    cp 0               ; Compare with zero (free) 
1189				or a 
1189			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1189			 
1189			    ; Check if current block is large enough 
1189			    ld a, (hl+1)       ; Load high byte of block size 
1189			    cp l               ; Compare with low byte of requested size 
1189			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1189			 
1189			    ld a, (hl+2)       ; Load low byte of block size 
1189			    cp h               ; Compare with high byte of requested size 
1189			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1189			 
1189			    ; Mark block as used 
1189			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1189			 
1189			    ; Calculate remaining space in block 
1189			    ld bc, 0           ; Clear BC 
1189			    add hl, bc         ; Increment HL to point to start of data block 
1189			    add hl, de         ; HL = HL + DE (total size) 
1189			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1189			    add hl, bc         ; Add management overhead to start of data block 
1189			 
1189			    ; Save pointer to allocated block in HL 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189						DMARK "ma5" 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret 
1189			 
1189			malloc_skip_block_check: 
1189			    ; Move to the next block 
1189			    ld bc, 3           ; Size of management overhead 
1189			    add hl, bc         ; Move to the next block 
1189			    inc de             ; Increment counter 
1189			 
1189			    ; Check if we have reached the end of heap 
1189			    ld a, e            ; Load low byte of heap end address 
1189			    cp (hl)            ; Compare with low byte of current address 
1189			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1189			    ld a, d            ; Load high byte of heap end address 
1189			;    cp 0               ; Check if it's zero (end of memory) 
1189				or a 
1189			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1189			 
1189			    ; If we reached here, allocation failed 
1189			    xor a              ; Set result to NULL 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189						DMARK "ma6" 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret 
1189			malloc_exit: 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189						DMARK "ma7" 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret 
1189			 
1189			; Internal Free Function: 
1189			; Input: 
1189			;   HL: Pointer to memory block to free 
1189			; Output: 
1189			;   None 
1189			 
1189			free_internal: 
1189			    ld de, (heap_start) ; Load start of heap into DE 
1189			    ld bc, 0            ; Initialize counter 
1189			 
1189			free_search_loop: 
1189			    ; Check if current block contains the pointer 
1189			    ld a, l             ; Load low byte of pointer 
1189			    cp (hl+1)           ; Compare with high byte of current block's address 
1189			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1189			    ld a, h             ; Load high byte of pointer 
1189			    cp (hl+2)           ; Compare with low byte of current block's address 
1189			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1189			 
1189			    ; Mark block as free 
1189			    ld (hl), 0          ; Set status byte to indicate free block 
1189			    ret                 ; Return 
1189			 
1189			free_skip_block_check: 
1189			    ; Move to the next block 
1189			    ld bc, 3            ; Size of management overhead 
1189			    add hl, bc          ; Move to the next block 
1189			    inc de              ; Increment counter 
1189			 
1189			    ; Check if we have reached the end of heap 
1189			    ld a, e             ; Load low byte of heap end address 
1189			    cp (hl)             ; Compare with low byte of current address 
1189			    jr nz, free_search_loop  ; If not equal, continue searching 
1189			    ld a, d             ; Load high byte of heap end address 
1189			;    cp 0                ; Check if it's zero (end of memory) 
1189				or a 
1189			    jr nz, free_search_loop  ; If not zero, continue searching 
1189			 
1189			    ; If we reached here, pointer is not found in heap 
1189			    ret 
1189			 
1189			free_exit: 
1189			    ret                 ; Return 
1189			 
1189			; Define heap start and end addresses 
1189			;heap_start:    .dw 0xC000   ; Start of heap 
1189			;heap_end:      .dw 0xE000   ; End of heap 
1189			 
1189			endif 
1189			 
1189			 
1189			if MALLOC_1 
1189			 
1189			 
1189			 
1189			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1189			 
1189			;moved to firmware.asm 
1189			;heap_start        .equ  0x9000      ; Starting address of heap 
1189			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1189			 
1189			;      .org 0 
1189			;      jp    main 
1189			 
1189			 
1189			;      .org  0x100 
1189			;main: 
1189			;      ld    HL, 0x8100 
1189			;      ld    SP, HL 
1189			; 
1189			;      call  heap_init 
1189			; 
1189			;      ; Make some allocations 
1189			;      ld    HL, 12 
1189			;      call  malloc            ; Allocates 0x9004 
1189			; 
1189			;      ld    HL, 12 
1189			;      call  malloc            ; Allocates 0x9014 
1189			; 
1189			;      ld    HL, 12 
1189			;      call  malloc            ; Allocates 0x9024 
1189			; 
1189			;      ; Free some allocations 
1189			;      ld    HL, 0x9014 
1189			;      call  free 
1189			; 
1189			;      ld    HL, 0x9004 
1189			;      call  free 
1189			; 
1189			;      ld    HL, 0x9024 
1189			;      call  free 
1189			; 
1189			; 
1189			;      halt 
1189			 
1189			 
1189			;------------------------------------------------------------------------------ 
1189			;     heap_init                                                               : 
1189			;                                                                             : 
1189			; Description                                                                 : 
1189			;     Initialise the heap and make it ready for malloc and free operations.   : 
1189			;                                                                             : 
1189			;     The heap is maintained as a linked list, starting with an initial       : 
1189			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1189			;     the first free block in the heap. Each block then points to the next    : 
1189			;     free block within the heap, and the free list ends at the first block   : 
1189			;     with a null pointer to the next free block.                             : 
1189			;                                                                             : 
1189			; Parameters                                                                  : 
1189			;     Inputs are compile-time only. Two defines which specify the starting    : 
1189			;     address of the heap and its size are required, along with a memory      : 
1189			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1189			;     principally stores a pointer to the first free block in the heap.       : 
1189			;                                                                             : 
1189			; Returns                                                                     : 
1189			;     Nothing                                                                 : 
1189			;------------------------------------------------------------------------------ 
1189			heap_init: 
1189 e5			      push  HL 
118a			 
118a			      ; Initialise free list struct 
118a 21 d8 65		      ld    HL, heap_start 
118d 22 d3 65		      ld    (free_list), HL 
1190 21 00 00		      ld    HL, 0 
1193 22 d5 65		      ld    (free_list+2), HL 
1196			 
1196			      ; Insert first free block at bottom of heap, consumes entire heap 
1196 21 8f e2		      ld    HL, heap_start+heap_size-4 
1199 22 d8 65		      ld    (heap_start), HL        ; Next block (end of free list) 
119c 21 b7 7c		      ld    HL, heap_size-4 
119f 22 da 65		      ld    (heap_start+2), HL      ; Block size 
11a2			 
11a2			      ; Insert end of free list block at top of heap - two null words will 
11a2			      ; terminate the free list 
11a2 21 00 00		      ld    HL, 0 
11a5 22 91 e2		      ld    (heap_start+heap_size-2), HL 
11a8 22 8f e2		      ld    (heap_start+heap_size-4), HL 
11ab			 
11ab e1			      pop   HL 
11ac			 
11ac c9			      ret 
11ad			 
11ad			 
11ad			;------------------------------------------------------------------------------ 
11ad			;     malloc                                                                  : 
11ad			;                                                                             : 
11ad			; Description                                                                 : 
11ad			;     Allocates the wanted space from the heap and returns the address of the : 
11ad			;     first useable byte of the allocation.                                   : 
11ad			;                                                                             : 
11ad			;     Allocations can happen in one of two ways:                              : 
11ad			;                                                                             : 
11ad			;     1. A free block may be found which is the exact size wanted. In this    : 
11ad			;        case the block is removed from the free list and retuedn to the      : 
11ad			;        caller.                                                              : 
11ad			;     2. A free block may be found which is larger than the size wanted. In   : 
11ad			;        this case, the larger block is split into two. The first portion of  : 
11ad			;        this block will become the requested space by the malloc call and    : 
11ad			;        is returned to the caller. The second portion becomes a new free     : 
11ad			;        block, and the free list is adjusted to maintain continuity via this : 
11ad			;        newly created block.                                                 : 
11ad			;                                                                             : 
11ad			;     malloc does not set any initial value in the allocated space, the       : 
11ad			;     caller is required to do this as required.                              : 
11ad			;                                                                             : 
11ad			;     This implementation of malloc uses the stack exclusively, and is        : 
11ad			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11ad			;     advisable to disable interrupts before calling malloc, and recommended  : 
11ad			;     to avoid the use of malloc inside ISRs in general.                      : 
11ad			;                                                                             : 
11ad			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11ad			;                                                                             : 
11ad			; Parameters                                                                  : 
11ad			;     HL  Number of bytes wanted                                              : 
11ad			;                                                                             : 
11ad			; Returns                                                                     : 
11ad			;     HL  Address of the first useable byte of the allocation                 : 
11ad			;                                                                             : 
11ad			; Flags                                                                       : 
11ad			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11ad			;                                                                             : 
11ad			; Stack frame                                                                 : 
11ad			;       |             |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |     BC      |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |     DE      |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |     IX      |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |  prev_free  |                                                       : 
11ad			;   +4  +-------------+                                                       : 
11ad			;       |  this_free  |                                                       : 
11ad			;   +2  +-------------+                                                       : 
11ad			;       |  next_free  |                                                       : 
11ad			;   +0  +-------------+                                                       : 
11ad			;       |             |                                                       : 
11ad			;                                                                             : 
11ad			;------------------------------------------------------------------------------ 
11ad			 
11ad			 
11ad			;malloc: 
11ad			; 
11ad			;	SAVESP ON 1 
11ad			; 
11ad			;	call malloc_code 
11ad			; 
11ad			;	CHECKSP ON 1 
11ad			;	ret 
11ad			 
11ad			 
11ad			malloc: 
11ad c5			      push  BC 
11ae d5			      push  DE 
11af dd e5		      push  IX 
11b1			if DEBUG_FORTH_MALLOC_HIGH 
11b1			call malloc_guard_entry 
11b1			endif 
11b1			 
11b1					if DEBUG_FORTH_MALLOC 
11b1						DMARK "mal" 
11b1						CALLMONITOR 
11b1					endif 
11b1 7c			      ld    A, H                    ; Exit if no space requested 
11b2 b5			      or    L 
11b3 ca 72 12		      jp    Z, malloc_early_exit 
11b6			 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			; 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			 
11b6			 
11b6			 
11b6			 
11b6					if DEBUG_FORTH_MALLOC 
11b6						DMARK "maA" 
11b6						CALLMONITOR 
11b6					endif 
11b6			      ; Set up stack frame 
11b6 eb			      ex    DE, HL 
11b7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11ba 39			      add   HL, SP 
11bb f9			      ld    SP, HL 
11bc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11c0 dd 39		      add   IX, SP 
11c2			 
11c2			      ; Setup initial state 
11c2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11c5 19			      add   HL, DE 
11c6			 
11c6 44			      ld    B, H                    ; Move want to BC 
11c7 4d			      ld    C, L 
11c8			 
11c8 21 d3 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
11cb dd 75 04		      ld    (IX+4), L 
11ce dd 74 05		      ld    (IX+5), H 
11d1			 
11d1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11d2 23			      inc   HL 
11d3 56			      ld    D, (HL) 
11d4 dd 73 02		      ld    (IX+2), E 
11d7 dd 72 03		      ld    (IX+3), D 
11da eb			      ex    DE, HL                  ; this_free ptr into HL 
11db			 
11db					if DEBUG_FORTH_MALLOC 
11db						DMARK "maB" 
11db						CALLMONITOR 
11db					endif 
11db			      ; Loop through free block list to find some space 
11db			malloc_find_space: 
11db 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11dc 23			      inc   HL 
11dd 56			      ld    D, (HL) 
11de			 
11de 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11df b3			      or    E 
11e0 ca 6c 12		      jp    Z, malloc_no_space 
11e3			 
11e3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11e6 dd 72 01		      ld    (IX+1), D 
11e9			 
11e9			      ; Does this block have enough space to make the allocation? 
11e9 23			      inc   HL                      ; Load free block size into DE 
11ea 5e			      ld    E, (HL) 
11eb 23			      inc   HL 
11ec 56			      ld    D, (HL) 
11ed			 
11ed eb			      ex    DE, HL                  ; Check size of block against want 
11ee b7			      or    A                       ; Ensure carry flag clear 
11ef ed 42		      sbc   HL, BC 
11f1 e5			      push  HL                      ; Store the result for later (new block size) 
11f2			 
11f2 ca 41 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11f5 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11f7			 
11f7			      ; this_free block is not big enough, setup ptrs to test next free block 
11f7 e1			      pop   HL                      ; Discard previous result 
11f8			 
11f8 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11fb dd 66 03		      ld    H, (IX+3) 
11fe dd 75 04		      ld    (IX+4), L 
1201 dd 74 05		      ld    (IX+5), H 
1204			 
1204 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1207 dd 66 01		      ld    H, (IX+1) 
120a dd 75 02		      ld    (IX+2), L 
120d dd 74 03		      ld    (IX+3), H 
1210			 
1210					if DEBUG_FORTH_MALLOC 
1210						DMARK "MA>" 
1210						CALLMONITOR 
1210					endif 
1210 18 c9		      jr    malloc_find_space 
1212			 
1212			      ; split a bigger block into two - requested size and remaining size 
1212			malloc_alloc_split: 
1212					if DEBUG_FORTH_MALLOC 
1212						DMARK "MAs" 
1212						CALLMONITOR 
1212					endif 
1212 eb			      ex    DE, HL                  ; Calculate address of new free block 
1213 2b			      dec   HL 
1214 2b			      dec   HL 
1215 2b			      dec   HL 
1216 09			      add   HL, BC 
1217			 
1217			      ; Create a new block and point it at next_free 
1217 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
121a dd 56 01		      ld    D, (IX+1) 
121d			 
121d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
121e 23			      inc   HL 
121f 72			      ld    (HL), D 
1220			 
1220 d1			      pop   DE                      ; Store size of new block into new block 
1221 23			      inc   HL 
1222 73			      ld    (HL), E 
1223 23			      inc   HL 
1224 72			      ld    (HL), D 
1225			 
1225			      ; Update this_free ptr to point to new block 
1225 2b			      dec   HL 
1226 2b			      dec   HL 
1227 2b			      dec   HL 
1228			 
1228 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
122b dd 56 03		      ld    D, (IX+3) 
122e			 
122e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1231 dd 74 03		      ld    (IX+3), H 
1234			 
1234			      ; Modify this_free block to be allocation 
1234 eb			      ex    DE, HL 
1235 af			      xor   A                       ; Null the next block ptr of allocated block 
1236 77			      ld    (HL), A 
1237 23			      inc   HL 
1238 77			      ld    (HL), A 
1239			 
1239 23			      inc   HL                      ; Store want size into allocated block 
123a 71			      ld    (HL), C 
123b 23			      inc   HL 
123c 70			      ld    (HL), B 
123d 23			      inc   HL 
123e e5			      push  HL                      ; Address of allocation to return 
123f			 
123f 18 19		      jr    malloc_update_links 
1241			 
1241			malloc_alloc_fit: 
1241 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1242			 
1242					if DEBUG_FORTH_MALLOC 
1242						DMARK "MAf" 
1242						CALLMONITOR 
1242					endif 
1242			      ; Modify this_free block to be allocation 
1242 eb			      ex    DE, HL 
1243 2b			      dec   HL 
1244 2b			      dec   HL 
1245 2b			      dec   HL 
1246			 
1246 af			      xor   A                       ; Null the next block ptr of allocated block 
1247 77			      ld    (HL), A 
1248 23			      inc   HL 
1249 77			      ld    (HL), A 
124a			 
124a 23			      inc   HL                      ; Store address of allocation to return 
124b 23			      inc   HL 
124c 23			      inc   HL 
124d e5			      push  HL 
124e			 
124e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
124e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1251 dd 66 01		      ld    H, (IX+1) 
1254			 
1254 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1257 dd 74 03		      ld    (IX+3), H 
125a			 
125a			 
125a			malloc_update_links: 
125a			      ; Update prev_free ptr to point to this_free 
125a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
125d dd 66 05		      ld    H, (IX+5) 
1260			 
1260 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1263 dd 56 03		      ld    D, (IX+3) 
1266			 
1266 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1267 23			      inc   HL 
1268 72			      ld    (HL), D 
1269			 
1269					if DEBUG_FORTH_MALLOC 
1269						DMARK "Mul" 
1269						CALLMONITOR 
1269					endif 
1269			      ; Clear the Z flag to indicate successful allocation 
1269 7a			      ld    A, D 
126a b3			      or    E 
126b			 
126b d1			      pop   DE                      ; Address of allocation 
126c					if DEBUG_FORTH_MALLOC 
126c						DMARK "MAu" 
126c						CALLMONITOR 
126c					endif 
126c			 
126c			malloc_no_space: 
126c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
126f 39			      add   HL, SP 
1270 f9			      ld    SP, HL 
1271			 
1271 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1272					if DEBUG_FORTH_MALLOC 
1272						DMARK "MAN" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			malloc_early_exit: 
1272					if DEBUG_FORTH_MALLOC 
1272						DMARK "MAx" 
1272						CALLMONITOR 
1272					endif 
1272 dd e1		      pop   IX 
1274 d1			      pop   DE 
1275 c1			      pop   BC 
1276			 
1276			if DEBUG_FORTH_MALLOC_HIGH 
1276			call malloc_guard_exit 
1276			call malloc_guard_zerolen 
1276			endif 
1276 c9			      ret 
1277			 
1277			 
1277			;------------------------------------------------------------------------------ 
1277			;     free                                                                    : 
1277			;                                                                             : 
1277			; Description                                                                 : 
1277			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1277			;     returned by malloc, otherwise the behaviour is undefined.               : 
1277			;                                                                             : 
1277			;     Where possible, directly adjacent free blocks will be merged together   : 
1277			;     into larger blocks to help ensure that the heap does not become         : 
1277			;     excessively fragmented.                                                 : 
1277			;                                                                             : 
1277			;     free does not clear or set any other value into the freed space, and    : 
1277			;     therefore its contents may be visible through subsequent malloc's. The  : 
1277			;     caller should clear the freed space as required.                        : 
1277			;                                                                             : 
1277			;     This implementation of free uses the stack exclusively, and is          : 
1277			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1277			;     advisable to disable interrupts before calling free, and recommended    : 
1277			;     to avoid the use of free inside ISRs in general.                        : 
1277			;                                                                             : 
1277			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1277			;                                                                             : 
1277			; Parameters                                                                  : 
1277			;     HL  Pointer to address of first byte of allocation to be freed          : 
1277			;                                                                             : 
1277			; Returns                                                                     : 
1277			;     Nothing                                                                 : 
1277			;                                                                             : 
1277			; Stack frame                                                                 : 
1277			;       |             |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |     BC      |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |     DE      |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |     IX      |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |  prev_free  |                                                       : 
1277			;   +2  +-------------+                                                       : 
1277			;       |  next_free  |                                                       : 
1277			;   +0  +-------------+                                                       : 
1277			;       |             |                                                       : 
1277			;                                                                             : 
1277			;------------------------------------------------------------------------------ 
1277			free: 
1277 c5			      push  BC 
1278 d5			      push  DE 
1279 dd e5		      push  IX 
127b			 
127b 7c			      ld    A, H                    ; Exit if ptr is null 
127c b5			      or    L 
127d ca 41 13		      jp    Z, free_early_exit 
1280			 
1280			      ; Set up stack frame 
1280 eb			      ex    DE, HL 
1281 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1284 39			      add   HL, SP 
1285 f9			      ld    SP, HL 
1286 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
128a dd 39		      add   IX, SP 
128c			 
128c			      ; The address in HL points to the start of the useable allocated space, 
128c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
128c			      ; address of the block itself. 
128c eb			      ex    DE, HL 
128d 11 fc ff		      ld    DE, -4 
1290 19			      add   HL, DE 
1291			 
1291			      ; An allocated block must have a null next block pointer in it 
1291 7e			      ld    A, (HL) 
1292 23			      inc   HL 
1293 b6			      or    (HL) 
1294 c2 3c 13		      jp    NZ, free_done 
1297			 
1297 2b			      dec   HL 
1298			 
1298 44			      ld    B, H                    ; Copy HL to BC 
1299 4d			      ld    C, L 
129a			 
129a			      ; Loop through the free list to find the first block with an address 
129a			      ; higher than the block being freed 
129a 21 d3 65		      ld    HL, free_list 
129d			 
129d			free_find_higher_block: 
129d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
129e 23			      inc   HL 
129f 56			      ld    D, (HL) 
12a0 2b			      dec   HL 
12a1			 
12a1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12a4 dd 72 01		      ld    (IX+1), D 
12a7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12aa dd 74 03		      ld    (IX+3), H 
12ad			 
12ad 78			      ld    A, B                    ; Check if DE is greater than BC 
12ae ba			      cp    D                       ; Compare MSB first 
12af 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12b1 30 04		      jr    NC, free_find_higher_block_skip 
12b3 79			      ld    A, C 
12b4 bb			      cp    E                       ; Then compare LSB 
12b5 38 08		      jr    C, free_found_higher_block 
12b7			 
12b7			free_find_higher_block_skip: 
12b7 7a			      ld    A, D                    ; Reached the end of the free list? 
12b8 b3			      or    E 
12b9 ca 3c 13		      jp    Z, free_done 
12bc			 
12bc eb			      ex    DE, HL 
12bd			 
12bd 18 de		      jr    free_find_higher_block 
12bf			 
12bf			free_found_higher_block: 
12bf			      ; Insert freed block between prev and next free blocks 
12bf 71			      ld    (HL), C                 ; Point prev free block to freed block 
12c0 23			      inc   HL 
12c1 70			      ld    (HL), B 
12c2			 
12c2 60			      ld    H, B                    ; Point freed block at next free block 
12c3 69			      ld    L, C 
12c4 73			      ld    (HL), E 
12c5 23			      inc   HL 
12c6 72			      ld    (HL), D 
12c7			 
12c7			      ; Check if the freed block is adjacent to the next free block 
12c7 23			      inc   HL                      ; Load size of freed block into HL 
12c8 5e			      ld    E, (HL) 
12c9 23			      inc   HL 
12ca 56			      ld    D, (HL) 
12cb eb			      ex    DE, HL 
12cc			 
12cc 09			      add   HL, BC                  ; Add addr of freed block and its size 
12cd			 
12cd dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12d0 dd 56 01		      ld    D, (IX+1) 
12d3			 
12d3 b7			      or    A                       ; Clear the carry flag 
12d4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12d6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12d8			 
12d8			      ; Freed block is adjacent to next, merge into one bigger block 
12d8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12d9 5e			      ld    E, (HL) 
12da 23			      inc   HL 
12db 56			      ld    D, (HL) 
12dc e5			      push  HL                      ; Save ptr to next block for later 
12dd			 
12dd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12de 69			      ld    L, C 
12df 73			      ld    (HL), E 
12e0 23			      inc   HL 
12e1 72			      ld    (HL), D 
12e2			 
12e2 e1			      pop   HL                      ; Restore ptr to next block 
12e3 23			      inc   HL                      ; Load size of next block into DE 
12e4 5e			      ld    E, (HL) 
12e5 23			      inc   HL 
12e6 56			      ld    D, (HL) 
12e7 d5			      push  DE                      ; Save next block size for later 
12e8			 
12e8 60			      ld    H, B                    ; Load size of freed block into HL 
12e9 69			      ld    L, C 
12ea 23			      inc   HL 
12eb 23			      inc   HL 
12ec 5e			      ld    E, (HL) 
12ed 23			      inc   HL 
12ee 56			      ld    D, (HL) 
12ef eb			      ex    DE, HL 
12f0			 
12f0 d1			      pop   DE                      ; Restore size of next block 
12f1 19			      add   HL, DE                  ; Add sizes of both blocks 
12f2 eb			      ex    DE, HL 
12f3			 
12f3 60			      ld    H, B                    ; Store new bigger size into freed block 
12f4 69			      ld    L, C 
12f5 23			      inc   HL 
12f6 23			      inc   HL 
12f7 73			      ld    (HL), E 
12f8 23			      inc   HL 
12f9 72			      ld    (HL), D 
12fa			 
12fa			free_check_adjacent_to_prev: 
12fa			      ; Check if the freed block is adjacent to the prev free block 
12fa dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
12fd dd 66 03		      ld    H, (IX+3) 
1300			 
1300 23			      inc   HL                      ; Size of prev free block into DE 
1301 23			      inc   HL 
1302 5e			      ld    E, (HL) 
1303 23			      inc   HL 
1304 56			      ld    D, (HL) 
1305 2b			      dec   HL 
1306 2b			      dec   HL 
1307 2b			      dec   HL 
1308			 
1308 19			      add   HL, DE                  ; Add prev block addr and size 
1309			 
1309 b7			      or    A                       ; Clear the carry flag 
130a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
130c 20 2e		      jr    NZ, free_done 
130e			 
130e			      ; Freed block is adjacent to prev, merge into one bigger block 
130e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
130f 69			      ld    L, C 
1310 5e			      ld    E, (HL) 
1311 23			      inc   HL 
1312 56			      ld    D, (HL) 
1313 e5			      push  HL                      ; Save freed block ptr for later 
1314			 
1314 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1317 dd 66 03		      ld    H, (IX+3) 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d e1			      pop   HL                      ; Restore freed block ptr 
131e 23			      inc   HL                      ; Load size of freed block into DE 
131f 5e			      ld    E, (HL) 
1320 23			      inc   HL 
1321 56			      ld    D, (HL) 
1322 d5			      push  DE                      ; Save freed block size for later 
1323			 
1323 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1326 dd 66 03		      ld    H, (IX+3) 
1329 23			      inc   HL 
132a 23			      inc   HL 
132b 5e			      ld    E, (HL) 
132c 23			      inc   HL 
132d 56			      ld    D, (HL) 
132e			 
132e e1			      pop   HL                      ; Add sizes of both blocks 
132f 19			      add   HL, DE 
1330 eb			      ex    DE, HL 
1331			 
1331 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1334 dd 66 03		      ld    H, (IX+3) 
1337 23			      inc   HL 
1338 23			      inc   HL 
1339 73			      ld    (HL), E 
133a 23			      inc   HL 
133b 72			      ld    (HL), D 
133c			 
133c			free_done: 
133c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
133f 39			      add   HL, SP 
1340 f9			      ld    SP, HL 
1341			 
1341			free_early_exit: 
1341 dd e1		      pop   IX 
1343 d1			      pop   DE 
1344 c1			      pop   BC 
1345			 
1345 c9			      ret 
1346			 
1346			; moved to firmware.asm 
1346			; 
1346			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1346			;                  .dw   0 
1346			 
1346			 
1346			endif 
1346			 
1346			 
1346			if MALLOC_3 
1346			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1346			;heap_start        .equ  0x9000      ; Starting address of heap 
1346			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1346			; 
1346			 ;     .org 0 
1346			  ;    jp    main 
1346			; 
1346			; 
1346			 ;     .org  0x100 
1346			;main: 
1346			 ;     ld    HL, 0x8100 
1346			  ;    ld    SP, HL 
1346			; 
1346			;      call  heap_init 
1346			 
1346			      ; Make some allocations 
1346			;      ld    HL, 12 
1346			;      call  malloc            ; Allocates 0x9004 
1346			; 
1346			 ;     ld    HL, 12 
1346			;      call  malloc            ; Allocates 0x9014 
1346			 
1346			;      ld    HL, 12 
1346			;      call  malloc            ; Allocates 0x9024 
1346			 
1346			      ; Free some allocations 
1346			;      ld    HL, 0x9014 
1346			;      call  free 
1346			 
1346			;      ld    HL, 0x9004 
1346			;      call  free 
1346			; 
1346			;      ld    HL, 0x9024 
1346			;      call  free 
1346			 
1346			 
1346			 ;     halt 
1346			 
1346			 
1346			;------------------------------------------------------------------------------ 
1346			;     heap_init                                                               : 
1346			;                                                                             : 
1346			; Description                                                                 : 
1346			;     Initialise the heap and make it ready for malloc and free operations.   : 
1346			;                                                                             : 
1346			;     The heap is maintained as a linked list, starting with an initial       : 
1346			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1346			;     the first free block in the heap. Each block then points to the next    : 
1346			;     free block within the heap, and the free list ends at the first block   : 
1346			;     with a null pointer to the next free block.                             : 
1346			;                                                                             : 
1346			; Parameters                                                                  : 
1346			;     Inputs are compile-time only. Two defines which specify the starting    : 
1346			;     address of the heap and its size are required, along with a memory      : 
1346			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1346			;     principally stores a pointer to the first free block in the heap.       : 
1346			;                                                                             : 
1346			; Returns                                                                     : 
1346			;     Nothing                                                                 : 
1346			;------------------------------------------------------------------------------ 
1346			heap_init: 
1346			      push  HL 
1346			 
1346			      ; Initialise free list struct 
1346			      ld    HL, heap_start 
1346			      ld    (free_list), HL 
1346			      ld    HL, 0 
1346			      ld    (free_list+2), HL 
1346			 
1346			      ; Insert first free block at bottom of heap, consumes entire heap 
1346			      ld    HL, heap_start+heap_size-4 
1346			      ld    (heap_start), HL        ; Next block (end of free list) 
1346			      ld    HL, heap_size-4 
1346			      ld    (heap_start+2), HL      ; Block size 
1346			 
1346			      ; Insert end of free list block at top of heap - two null words will 
1346			      ; terminate the free list 
1346			      ld    HL, 0 
1346			      ld    (heap_start+heap_size-2), HL 
1346			      ld    (heap_start+heap_size-4), HL 
1346			 
1346			      pop   HL 
1346			 
1346			      ret 
1346			 
1346			 
1346			;------------------------------------------------------------------------------ 
1346			;     malloc                                                                  : 
1346			;                                                                             : 
1346			; Description                                                                 : 
1346			;     Allocates the wanted space from the heap and returns the address of the : 
1346			;     first useable byte of the allocation.                                   : 
1346			;                                                                             : 
1346			;     Allocations can happen in one of two ways:                              : 
1346			;                                                                             : 
1346			;     1. A free block may be found which is the exact size wanted. In this    : 
1346			;        case the block is removed from the free list and retuedn to the      : 
1346			;        caller.                                                              : 
1346			;     2. A free block may be found which is larger than the size wanted. In   : 
1346			;        this case, the larger block is split into two. The first portion of  : 
1346			;        this block will become the requested space by the malloc call and    : 
1346			;        is returned to the caller. The second portion becomes a new free     : 
1346			;        block, and the free list is adjusted to maintain continuity via this : 
1346			;        newly created block.                                                 : 
1346			;                                                                             : 
1346			;     malloc does not set any initial value in the allocated space, the       : 
1346			;     caller is required to do this as required.                              : 
1346			;                                                                             : 
1346			;     This implementation of malloc uses the stack exclusively, and is        : 
1346			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1346			;     advisable to disable interrupts before calling malloc, and recommended  : 
1346			;     to avoid the use of malloc inside ISRs in general.                      : 
1346			;                                                                             : 
1346			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1346			;                                                                             : 
1346			; Parameters                                                                  : 
1346			;     HL  Number of bytes wanted                                              : 
1346			;                                                                             : 
1346			; Returns                                                                     : 
1346			;     HL  Address of the first useable byte of the allocation                 : 
1346			;                                                                             : 
1346			; Flags                                                                       : 
1346			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1346			;                                                                             : 
1346			; Stack frame                                                                 : 
1346			;       |             |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     BC      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     DE      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     IX      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |  prev_free  |                                                       : 
1346			;   +4  +-------------+                                                       : 
1346			;       |  this_free  |                                                       : 
1346			;   +2  +-------------+                                                       : 
1346			;       |  next_free  |                                                       : 
1346			;   +0  +-------------+                                                       : 
1346			;       |             |                                                       : 
1346			;                                                                             : 
1346			;------------------------------------------------------------------------------ 
1346			malloc: 
1346			      push  BC 
1346			      push  DE 
1346			      push  IX 
1346			 
1346			      ld    A, H                    ; Exit if no space requested 
1346			      or    L 
1346			      jp    Z, malloc_early_exit 
1346			 
1346			      ; Set up stack frame 
1346			      ex    DE, HL 
1346			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			      ld    IX, 0                   ; Use IX as a frame pointer 
1346			      add   IX, SP 
1346			 
1346			      ; Setup initial state 
1346			      ld    HL, 4                   ; want must also include space used by block struct 
1346			      add   HL, DE 
1346			 
1346			      ld    B, H                    ; Move want to BC 
1346			      ld    C, L 
1346			 
1346			      ld    HL, free_list           ; Store prev_free ptr to stack 
1346			      ld    (IX+4), L 
1346			      ld    (IX+5), H 
1346			 
1346			      ld    E, (HL)                 ; Store this_free ptr to stack 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      ld    (IX+2), E 
1346			      ld    (IX+3), D 
1346			      ex    DE, HL                  ; this_free ptr into HL 
1346			 
1346			      ; Loop through free block list to find some space 
1346			malloc_find_space: 
1346			      ld    E, (HL)                 ; Load next_free ptr into DE 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			 
1346			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1346			      or    E 
1346			      jp    Z, malloc_no_space 
1346			 
1346			      ld    (IX+0), E               ; Store next_free ptr to stack 
1346			      ld    (IX+1), D 
1346			 
1346			      ; Does this block have enough space to make the allocation? 
1346			      inc   HL                      ; Load free block size into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			 
1346			      ex    DE, HL                  ; Check size of block against want 
1346			      or    A                       ; Ensure carry flag clear 
1346			      sbc   HL, BC 
1346			      push  HL                      ; Store the result for later (new block size) 
1346			 
1346			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1346			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1346			 
1346			      ; this_free block is not big enough, setup ptrs to test next free block 
1346			      pop   HL                      ; Discard previous result 
1346			 
1346			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1346			      ld    H, (IX+3) 
1346			      ld    (IX+4), L 
1346			      ld    (IX+5), H 
1346			 
1346			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1346			      ld    H, (IX+1) 
1346			      ld    (IX+2), L 
1346			      ld    (IX+3), H 
1346			 
1346			      jr    malloc_find_space 
1346			 
1346			      ; split a bigger block into two - requested size and remaining size 
1346			malloc_alloc_split: 
1346			      ex    DE, HL                  ; Calculate address of new free block 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			      add   HL, BC 
1346			 
1346			      ; Create a new block and point it at next_free 
1346			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1346			      ld    D, (IX+1) 
1346			 
1346			      ld    (HL), E                 ; Store next_free ptr into new block 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      pop   DE                      ; Store size of new block into new block 
1346			      inc   HL 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      ; Update this_free ptr to point to new block 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			 
1346			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1346			      ld    D, (IX+3) 
1346			 
1346			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1346			      ld    (IX+3), H 
1346			 
1346			      ; Modify this_free block to be allocation 
1346			      ex    DE, HL 
1346			      xor   A                       ; Null the next block ptr of allocated block 
1346			      ld    (HL), A 
1346			      inc   HL 
1346			      ld    (HL), A 
1346			 
1346			      inc   HL                      ; Store want size into allocated block 
1346			      ld    (HL), C 
1346			      inc   HL 
1346			      ld    (HL), B 
1346			      inc   HL 
1346			      push  HL                      ; Address of allocation to return 
1346			 
1346			      jr    malloc_update_links 
1346			 
1346			malloc_alloc_fit: 
1346			      pop   HL                      ; Dont need new block size, want is exact fit 
1346			 
1346			      ; Modify this_free block to be allocation 
1346			      ex    DE, HL 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			 
1346			      xor   A                       ; Null the next block ptr of allocated block 
1346			      ld    (HL), A 
1346			      inc   HL 
1346			      ld    (HL), A 
1346			 
1346			      inc   HL                      ; Store address of allocation to return 
1346			      inc   HL 
1346			      inc   HL 
1346			      push  HL 
1346			 
1346			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1346			      ld    L, (IX+0)               ; next_free to HL 
1346			      ld    H, (IX+1) 
1346			 
1346			      ld    (IX+2), L               ; HL to this_free 
1346			      ld    (IX+3), H 
1346			 
1346			 
1346			malloc_update_links: 
1346			      ; Update prev_free ptr to point to this_free 
1346			      ld    L, (IX+4)               ; prev_free ptr to HL 
1346			      ld    H, (IX+5) 
1346			 
1346			      ld    E, (IX+2)               ; this_free ptr to DE 
1346			      ld    D, (IX+3) 
1346			 
1346			      ld    (HL), E                 ; this_free ptr into prev_free 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      ; Clear the Z flag to indicate successful allocation 
1346			      ld    A, D 
1346			      or    E 
1346			 
1346			      pop   DE                      ; Address of allocation 
1346			 
1346			malloc_no_space: 
1346			      ld    HL, 6                   ; Clean up stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			 
1346			      ex    DE, HL                  ; Alloc addr into HL for return 
1346			 
1346			malloc_early_exit: 
1346			      pop   IX 
1346			      pop   DE 
1346			      pop   BC 
1346			 
1346			      ret 
1346			 
1346			 
1346			;------------------------------------------------------------------------------ 
1346			;     free                                                                    : 
1346			;                                                                             : 
1346			; Description                                                                 : 
1346			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1346			;     returned by malloc, otherwise the behaviour is undefined.               : 
1346			;                                                                             : 
1346			;     Where possible, directly adjacent free blocks will be merged together   : 
1346			;     into larger blocks to help ensure that the heap does not become         : 
1346			;     excessively fragmented.                                                 : 
1346			;                                                                             : 
1346			;     free does not clear or set any other value into the freed space, and    : 
1346			;     therefore its contents may be visible through subsequent malloc's. The  : 
1346			;     caller should clear the freed space as required.                        : 
1346			;                                                                             : 
1346			;     This implementation of free uses the stack exclusively, and is          : 
1346			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1346			;     advisable to disable interrupts before calling free, and recommended    : 
1346			;     to avoid the use of free inside ISRs in general.                        : 
1346			;                                                                             : 
1346			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1346			;                                                                             : 
1346			; Parameters                                                                  : 
1346			;     HL  Pointer to address of first byte of allocation to be freed          : 
1346			;                                                                             : 
1346			; Returns                                                                     : 
1346			;     Nothing                                                                 : 
1346			;                                                                             : 
1346			; Stack frame                                                                 : 
1346			;       |             |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     BC      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     DE      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     IX      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |  prev_free  |                                                       : 
1346			;   +2  +-------------+                                                       : 
1346			;       |  next_free  |                                                       : 
1346			;   +0  +-------------+                                                       : 
1346			;       |             |                                                       : 
1346			;                                                                             : 
1346			;------------------------------------------------------------------------------ 
1346			free: 
1346			      push  BC 
1346			      push  DE 
1346			      push  IX 
1346			 
1346			      ld    A, H                    ; Exit if ptr is null 
1346			      or    L 
1346			      jp    Z, free_early_exit 
1346			 
1346			      ; Set up stack frame 
1346			      ex    DE, HL 
1346			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			      ld    IX, 0                   ; Use IX as a frame pointer 
1346			      add   IX, SP 
1346			 
1346			      ; The address in HL points to the start of the useable allocated space, 
1346			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1346			      ; address of the block itself. 
1346			      ex    DE, HL 
1346			      ld    DE, -4 
1346			      add   HL, DE 
1346			 
1346			      ; An allocated block must have a null next block pointer in it 
1346			      ld    A, (HL) 
1346			      inc   HL 
1346			      or    (HL) 
1346			      jp    NZ, free_done 
1346			 
1346			      dec   HL 
1346			 
1346			      ld    B, H                    ; Copy HL to BC 
1346			      ld    C, L 
1346			 
1346			      ; Loop through the free list to find the first block with an address 
1346			      ; higher than the block being freed 
1346			      ld    HL, free_list 
1346			 
1346			free_find_higher_block: 
1346			      ld    E, (HL)                 ; Load next ptr from free block 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      dec   HL 
1346			 
1346			      ld    (IX+0), E               ; Save ptr to next free block 
1346			      ld    (IX+1), D 
1346			      ld    (IX+2), L               ; Save ptr to prev free block 
1346			      ld    (IX+3), H 
1346			 
1346			      ld    A, B                    ; Check if DE is greater than BC 
1346			      cp    D                       ; Compare MSB first 
1346			      jr    Z, $+4                  ; MSB the same, compare LSB 
1346			      jr    NC, free_find_higher_block_skip 
1346			      ld    A, C 
1346			      cp    E                       ; Then compare LSB 
1346			      jr    C, free_found_higher_block 
1346			 
1346			free_find_higher_block_skip: 
1346			      ld    A, D                    ; Reached the end of the free list? 
1346			      or    E 
1346			      jp    Z, free_done 
1346			 
1346			      ex    DE, HL 
1346			 
1346			      jr    free_find_higher_block 
1346			 
1346			free_found_higher_block: 
1346			      ; Insert freed block between prev and next free blocks 
1346			      ld    (HL), C                 ; Point prev free block to freed block 
1346			      inc   HL 
1346			      ld    (HL), B 
1346			 
1346			      ld    H, B                    ; Point freed block at next free block 
1346			      ld    L, C 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      ; Check if the freed block is adjacent to the next free block 
1346			      inc   HL                      ; Load size of freed block into HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      ex    DE, HL 
1346			 
1346			      add   HL, BC                  ; Add addr of freed block and its size 
1346			 
1346			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1346			      ld    D, (IX+1) 
1346			 
1346			      or    A                       ; Clear the carry flag 
1346			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1346			      jr    NZ, free_check_adjacent_to_prev 
1346			 
1346			      ; Freed block is adjacent to next, merge into one bigger block 
1346			      ex    DE, HL                  ; Load next ptr from next block into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  HL                      ; Save ptr to next block for later 
1346			 
1346			      ld    H, B                    ; Store ptr from next block into freed block 
1346			      ld    L, C 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      pop   HL                      ; Restore ptr to next block 
1346			      inc   HL                      ; Load size of next block into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  DE                      ; Save next block size for later 
1346			 
1346			      ld    H, B                    ; Load size of freed block into HL 
1346			      ld    L, C 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      ex    DE, HL 
1346			 
1346			      pop   DE                      ; Restore size of next block 
1346			      add   HL, DE                  ; Add sizes of both blocks 
1346			      ex    DE, HL 
1346			 
1346			      ld    H, B                    ; Store new bigger size into freed block 
1346			      ld    L, C 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			free_check_adjacent_to_prev: 
1346			      ; Check if the freed block is adjacent to the prev free block 
1346			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1346			      ld    H, (IX+3) 
1346			 
1346			      inc   HL                      ; Size of prev free block into DE 
1346			      inc   HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			 
1346			      add   HL, DE                  ; Add prev block addr and size 
1346			 
1346			      or    A                       ; Clear the carry flag 
1346			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1346			      jr    NZ, free_done 
1346			 
1346			      ; Freed block is adjacent to prev, merge into one bigger block 
1346			      ld    H, B                    ; Load next ptr from freed block into DE 
1346			      ld    L, C 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  HL                      ; Save freed block ptr for later 
1346			 
1346			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1346			      ld    H, (IX+3) 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      pop   HL                      ; Restore freed block ptr 
1346			      inc   HL                      ; Load size of freed block into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  DE                      ; Save freed block size for later 
1346			 
1346			      ld    L, (IX+2)               ; Load size of prev block into DE 
1346			      ld    H, (IX+3) 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			 
1346			      pop   HL                      ; Add sizes of both blocks 
1346			      add   HL, DE 
1346			      ex    DE, HL 
1346			 
1346			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1346			      ld    H, (IX+3) 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			free_done: 
1346			      ld    HL, 4                   ; Clean up stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			 
1346			free_early_exit: 
1346			      pop   IX 
1346			      pop   DE 
1346			      pop   BC 
1346			 
1346			      ret 
1346			 
1346			 
1346			;      .org 0x8000 
1346			; 
1346			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1346			 ;                 .dw   0 
1346			 
1346			endif 
1346			 
1346			 
1346			if MALLOC_4 
1346			 
1346			; My memory allocation code. Very very simple.... 
1346			; allocate space under 250 chars 
1346			 
1346			heap_init: 
1346				; init start of heap as zero 
1346				;  
1346			 
1346				ld hl, heap_start 
1346			;	ld a, 0 
1346				ld (hl), 0      ; empty block 
1346				inc hl 
1346			;	ld a, 0 
1346				ld (hl), 0      ; length of block 
1346				; write end of list 
1346				inc hl 
1346				ld a,(hl) 
1346				inc hl 
1346				ld a,(hl) 
1346				 
1346			 
1346				; init some malloc vars 
1346			 
1346				ld hl, 0 
1346				ld (free_list), hl       ; store last malloc location 
1346			 
1346				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1346			;	ld a, 0 
1346				ld (hl), 0 
1346			 
1346			 
1346				ld hl, heap_start 
1346				;  
1346				  
1346				ret 
1346			 
1346			 
1346			;    free block marker 
1346			;    requested size  
1346			;    pointer to next block 
1346			;    .... 
1346			;    next block marker 
1346			 
1346			 
1346			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1346			; 
1346			 
1346			 
1346			malloc:  
1346				push de 
1346				push bc 
1346				push af 
1346			 
1346				; hl space required 
1346				 
1346				ld c, l    ; hold space   (TODO only a max of 255) 
1346			 
1346			;	inc c     ; TODO BUG need to fix memory leak on push str 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			 
1346			 
1346			 
1346				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1346			 
1346				ld a, (free_list+3) 
1346			;	cp 0 
1346				or a 
1346				jr z, .contheap 
1346			 
1346				ld hl, (free_list)     ; get last alloc 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mrs" 
1346						CALLMONITOR 
1346					endif 
1346				jr .startalloc 
1346			 
1346			.contheap: 
1346				ld hl, heap_start 
1346			 
1346			.startalloc: 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mym" 
1346						CALLMONITOR 
1346					endif 
1346			.findblock: 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mmf" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346				ld a,(hl)  
1346				; if byte is zero then clear to use 
1346			 
1346			;	cp 0 
1346				or a 
1346				jr z, .foundemptyblock 
1346			 
1346				; if byte is not clear 
1346				;     then byte is offset to next block 
1346			 
1346				inc hl 
1346				ld a, (hl) ; get size 
1346			.nextblock:	inc hl 
1346					ld e, (hl) 
1346					inc hl 
1346					ld d, (hl) 
1346					ex de, hl 
1346			;	inc hl  ; move past the store space 
1346			;	inc hl  ; move past zero index  
1346			 
1346				; TODO detect no more space 
1346			 
1346				push hl 
1346				ld de, heap_end 
1346				call cmp16 
1346				pop hl 
1346				jr nc, .nospace 
1346			 
1346				jr .findblock 
1346			 
1346			.nospace: ld hl, 0 
1346				jp .exit 
1346			 
1346			 
1346			.foundemptyblock:	 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mme" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			; TODO has block enough space if reusing??? 
1346			 
1346				;  
1346			 
1346			; see if this block has been previously used 
1346				inc hl 
1346				ld a, (hl) 
1346				dec hl 
1346			;	cp 0 
1346				or a 
1346				jr z, .newblock 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "meR" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			; no reusing previously allocated block 
1346			 
1346			; is it smaller than previously used? 
1346				 
1346				inc hl    ; move to size 
1346				ld a, c 
1346				sub (hl)        ; we want c < (hl) 
1346				dec hl    ; move back to marker 
1346			        jr z, .findblock 
1346			 
1346				; update with the new size which should be lower 
1346			 
1346			        ;inc  hl   ; negate next move. move back to size  
1346			 
1346			.newblock: 
1346				; need to be at marker here 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "meN" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			 
1346				ld a, c 
1346			 
1346				ld (free_list+3), a	 ; flag resume from last malloc  
1346				ld (free_list), hl    ; save out last location 
1346			 
1346			 
1346				;inc a     ; space for length byte 
1346				ld (hl), a     ; save block in use marker 
1346			 
1346				inc hl   ; move to space marker 
1346				ld (hl), a    ; save new space 
1346			 
1346				inc hl   ; move to start of allocated area 
1346				 
1346			;	push hl     ; save where we are - 1  
1346			 
1346			;	inc hl  ; move past zero index  
1346				; skip space to set down new marker 
1346			 
1346				; provide some extra space for now 
1346			 
1346				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1346				inc a 
1346				inc a 
1346			 
1346				push hl   ; save where we are in the node block 
1346			 
1346				call addatohl 
1346			 
1346				; write linked list point 
1346			 
1346				pop de     ; get our node position 
1346				ex de, hl 
1346			 
1346				ld (hl), e 
1346				inc hl 
1346				ld (hl), d 
1346			 
1346				inc hl 
1346			 
1346				; now at start of allocated data so save pointer 
1346			 
1346				push hl 
1346			 
1346				; jump to position of next node and setup empty header in DE 
1346			 
1346				ex de, hl 
1346			 
1346			;	inc hl ; move past end of block 
1346			 
1346			;	ld a, 0 
1346				ld (hl), 0   ; empty marker 
1346				inc hl 
1346				ld (hl), 0   ; size 
1346				inc hl  
1346				ld (hl), 0   ; ptr 
1346				inc hl 
1346				ld (hl), 0   ; ptr 
1346			 
1346			 
1346				pop hl 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mmr" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			.exit: 
1346				pop af 
1346				pop bc 
1346				pop de  
1346				ret 
1346			 
1346			 
1346			 
1346			 
1346			free:  
1346				push hl 
1346				push af 
1346				; get address in hl 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "fre" 
1346						CALLMONITOR 
1346					endif 
1346				; data is at hl - move to block count 
1346				dec hl 
1346				dec hl    ; get past pointer 
1346				dec hl 
1346			 
1346				ld a, (hl)    ; need this for a validation check 
1346			 
1346				dec hl    ; move to block marker 
1346			 
1346				; now check that the block count and block marker are the same  
1346			        ; this checks that we are on a malloc node and not random memory 
1346			        ; OK a faint chance this could be a problem but rare - famous last words! 
1346			 
1346				ld c, a 
1346				ld a, (hl)    
1346			 
1346				cp c 
1346				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1346			 
1346				; yes good chance we are on a malloc node 
1346			 
1346			;	ld a, 0      
1346				ld (hl), 0   ; mark as free 
1346			 
1346				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1346			 
1346			.freeignore:  
1346			 
1346				pop af 
1346				pop hl 
1346			 
1346				ret 
1346			 
1346			 
1346			 
1346			endif 
1346			 
1346			; eof 
# End of file firmware_memory.asm
1346			  
1346			; device C  
1346			; Now handled by SPI  
1346			;if SOUND_ENABLE  
1346			;	include "firmware_sound.asm"  
1346			;endif  
1346			  
1346			include "firmware_diags.asm"  
1346			; Hardware diags menu 
1346			 
1346			 
1346			config: 
1346			 
1346 3e 00			ld a, 0 
1348 21 63 13			ld hl, .configmn 
134b cd e7 0b			call menu 
134e			 
134e fe 00			cp 0 
1350 c8				ret z 
1351			 
1351			;	cp 1 
1351			;	call z, .savetostore 
1351			 
1351 3d				dec a 
1352			if STARTUP_V1 
1352 cc 77 13			call z, .selautoload 
1355			endif 
1355			 
1355			if STARTUP_V2 
1355				call z, .enautoload 
1355			endif 
1355				;cp 2 
1355 3d				dec a 
1356 cc 6d 13			call z, .disautoload 
1359			if STARTUP_V2 
1359				dec a 
1359				call z, .selbank 
1359			endif 
1359			;	cp 3 
1359			;	call z, .selbank 
1359			;	cp 3 
1359 3d				dec a 
135a cc 95 13			call z, .debug_tog 
135d			;	cp 4 
135d 3d				dec a 
135e cc 63 14			call z, .bpsgo 
1361			;	cp 5 
1361			;	call z, hardware_diags 
1361			if STARTUP_V2 
1361			;	cp 5 
1361				dec a 
1361				call z, create_startup 
1361			endif 
1361 18 e3			jr config 
1363			 
1363			.configmn: 
1363			;	dw prom_c3 
1363 51 16			dw prom_c2 
1365 66 16			dw prom_c2a 
1367			if STARTUP_V2 
1367				dw prom_bsel  
1367			endif 
1367			;	dw prom_c2b 
1367			;	dw prom_c4 
1367 85 16			dw prom_m4 
1369 a0 16			dw prom_m4b 
136b			;	dw prom_c1 
136b			if STARTUP_V2 
136b				dw prom_c9 
136b			endif 
136b 00 00			dw 0 
136d				 
136d			 
136d			if STARTUP_V2 
136d			.enautoload: 
136d				if STORAGE_SE 
136d				ld a, $fe      ; bit 0 clear 
136d				ld (spi_device), a 
136d			 
136d				call storage_get_block_0 
136d			 
136d				ld a, 1 
136d				ld (store_page+STORE_0_AUTOFILE), a 
136d			 
136d					ld hl, 0 
136d					ld de, store_page 
136d				call storage_write_block	 ; save update 
136d				else 
136d			 
136d				ld hl, prom_notav 
136d				ld de, prom_empty 
136d				call info_panel 
136d				endif 
136d			 
136d			 
136d				ret 
136d			endif 
136d			 
136d			.disautoload: 
136d				if STORAGE_SE 
136d				ld a, $fe      ; bit 0 clear 
136d				ld (spi_device), a 
136d			 
136d				call storage_get_block_0 
136d			 
136d				ld a, 0 
136d				ld (store_page+STORE_0_AUTOFILE), a 
136d			 
136d					ld hl, 0 
136d					ld de, store_page 
136d				call storage_write_block	 ; save update 
136d				else 
136d			 
136d 21 a8 16			ld hl, prom_notav 
1370 11 be 16			ld de, prom_empty 
1373 cd 49 0b			call info_panel 
1376				endif 
1376			 
1376			 
1376 c9				ret 
1377			 
1377			if STARTUP_V1 
1377			 
1377			; Select auto start 
1377			 
1377			.selautoload: 
1377			 
1377				 
1377				if STORAGE_SE 
1377			 
1377					call config_dir 
1377				        ld hl, scratch 
1377					ld a, 0 
1377					call menu 
1377			 
1377					cp 0 
1377					ret z 
1377			 
1377					dec a 
1377			 
1377			 
1377					; locate menu option 
1377			 
1377					ld hl, scratch 
1377					call table_lookup 
1377			 
1377					if DEBUG_FORTH_WORDS 
1377						DMARK "ALl" 
1377						CALLMONITOR 
1377					endif 
1377					; with the pointer to the menu it, the byte following the zero term is the file id 
1377			 
1377					ld a, 0 
1377					ld bc, 50   ; max of bytes to look at 
1377					cpir  
1377			 
1377					if DEBUG_FORTH_WORDS 
1377						DMARK "ALb" 
1377						CALLMONITOR 
1377					endif 
1377					;inc hl 
1377			 
1377					ld a, (hl)   ; file id 
1377					 
1377				        ; save bank and file ids 
1377			 
1377					push af 
1377			 
1377			; TODO need to save to block 0 on bank 1	 
1377			 
1377					call storage_get_block_0 
1377			 
1377					if DEBUG_FORTH_WORDS 
1377						DMARK "AL0" 
1377						CALLMONITOR 
1377					endif 
1377					pop af 
1377			 
1377					ld (store_page+STORE_0_FILERUN),a 
1377					 
1377					; save bank id 
1377			 
1377					ld a,(spi_device) 
1377					ld (store_page+STORE_0_BANKRUN),a 
1377			 
1377					; enable auto run of store file 
1377			 
1377					ld a, 1 
1377					ld (store_page+STORE_0_AUTOFILE),a 
1377			 
1377					; save buffer 
1377			 
1377					ld hl, 0 
1377					ld de, store_page 
1377					if DEBUG_FORTH_WORDS 
1377						DMARK "ALw" 
1377						CALLMONITOR 
1377					endif 
1377				call storage_write_block	 ; save update 
1377			  
1377			 
1377			 
1377			 
1377					ld hl, scratch 
1377					call config_fdir 
1377			 
1377				else 
1377			 
1377 21 a8 16			ld hl, prom_notav 
137a 11 be 16			ld de, prom_empty 
137d cd 49 0b			call info_panel 
1380			 
1380				endif 
1380 c9				ret 
1381			endif 
1381			 
1381			 
1381			; Select storage bank 
1381			 
1381			.selbank: 
1381			 
1381			if STARTUP_V2 
1381			;	if STORAGE_SE 
1381			;	else 
1381			 
1381				ld hl, prom_banks 
1381				call menu 
1381				cp 0 
1381				ret z 
1381				 
1381				; set the bank number from the result 
1381			 
1381				 
1381					ld c, SPI_CE_HIGH 
1381					ld b, '0'    ; human readable bank number 
1381			 
1381			 
1381					; active low 
1381			 
1381			;		cp 0 
1381					or a 
1381					jr z, .bset 
1381					cp 1 
1381					jr nz, .b2 
1381					res 0, c 
1381					ld b, '1'    ; human readable bank number 
1381			.b2:		cp 2 
1381					jr nz, .b3 
1381					res 1, c 
1381					ld b, '2'    ; human readable bank number 
1381			.b3:		cp 3 
1381					jr nz, .b4 
1381					res 2, c 
1381					ld b, '3'    ; human readable bank number 
1381			.b4:		cp 4 
1381					jr nz, .b5 
1381					res 3, c 
1381					ld b, '4'    ; human readable bank number 
1381			.b5:		cp 5 
1381					jr nz, .bset 
1381					res 4, c 
1381					ld b, '5'    ; human readable bank number 
1381			 
1381			.bset: 
1381			 
1381					ld a, c 
1381			;		ld (spi_device),a 
1381					ld a, b 
1381			;		ld (spi_device_id),a 
1381					push bc 
1381			 
1381					; select bank 1 and load block 0  
1381			 
1381				ld a, $fe      ; bit 0 clear 
1381				ld (spi_device), a 
1381			 
1381				call storage_get_block_0 
1381			 
1381				pop bc 
1381				ld a,c 
1381				ld (store_page+STORE_0_BANKRUN), a 
1381				ld a,b 
1381				ld (store_page+STORE_0_BANKRUNN), a 
1381					ld hl, 0 
1381					ld de, store_page 
1381				call storage_write_block 
1381			 
1381			else 
1381 21 a8 16			ld hl, prom_notav 
1384 11 be 16			ld de, prom_empty 
1387 cd 49 0b			call info_panel 
138a			;	endif 
138a				 
138a			endif 
138a c9				ret 
138b			 
138b			if STORAGE_SE 
138b			 
138b			.config_ldir:   
138b				; Load storage bank labels into menu array 
138b			 
138b				 
138b			 
138b			 
138b				ret 
138b			 
138b			 
138b			endif 
138b			 
138b			 
138b			; Save user words to storage 
138b			 
138b			.savetostore: 
138b			 
138b			;	if STORAGE_SE 
138b			; 
138b			;		call config_dir 
138b			;	        ld hl, scratch 
138b			;		ld a, 0 
138b			;		call menu 
138b			;		 
138b			;		ld hl, scratch 
138b			;		call config_fdir 
138b			; 
138b			;	else 
138b			 
138b 21 a8 16			ld hl, prom_notav 
138e 11 be 16			ld de, prom_empty 
1391 cd 49 0b			call info_panel 
1394			 
1394			;	endif 
1394			 
1394 c9				ret 
1395			 
1395			if STARTUP_V2 
1395			 
1395			create_startup: 
1395			 
1395				ld a, 0 
1395				ld hl, .crstart 
1395				call menu 
1395			 
1395				cp 0 
1395				ret z 
1395			 
1395				cp 1 
1395				call z, .genlsword 
1395				cp 2 
1395				call z, .genedword 
1395			 
1395				cp 3 
1395				call z, .gendemword 
1395			 
1395				cp 4 
1395				call z, .genutlword 
1395				cp 5 
1395				call z, .genspiword 
1395				cp 6 
1395				call z, .genkeyword 
1395				cp 7 
1395				call z, .gensoundword 
1395				cp 8 
1395				call z, .genhwword 
1395				jr create_startup 
1395			 
1395			.genhwword: 
1395				ld hl, crs_hw 
1395				ld de, .hwworddef 
1395				call .genfile 
1395				ret 
1395			.gensoundword: 
1395				ld hl, crs_sound 
1395				ld de, .soundworddef 
1395				call .genfile 
1395				ret 
1395			.genlsword: 
1395				ld hl, crs_s1 
1395				ld de, .lsworddef 
1395				call .genfile 
1395				ret 
1395			 
1395			.genedword: 
1395				ld de, .edworddef 
1395				ld hl, crs_s2 
1395				call .genfile 
1395				ret 
1395			 
1395			.gendemword: 
1395				ld de, .demoworddef 
1395				ld hl, crs_s3 
1395				call .genfile 
1395				ret 
1395			 
1395			.genutlword: 
1395				ld hl, crs_s4 
1395				ld de, .utilwordef 
1395				call .genfile 
1395				ret 
1395			.genspiword: 
1395				ld hl, crs_s5 
1395				ld de, .spiworddef 
1395				call .genfile 
1395				ret 
1395			.genkeyword: 
1395				ld hl, crs_s6 
1395				ld de, .keyworddef 
1395				call .genfile 
1395				ret 
1395			 
1395			; hl - points to file name 
1395			; de - points to strings to add to file 
1395			 
1395			.genfile: 
1395				push hl 
1395				push de 
1395			 
1395				call clear_display 
1395				ld a, display_row_1 
1395				ld de, .genfiletxt 
1395				call str_at_display 
1395				call update_display 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395			 
1395				push de 
1395				call storage_create 
1395				; id in hl 
1395				pop de   ; table of strings to add 
1395			 
1395			.genloop: 
1395			 
1395				push hl ; save id for next time around 
1395				push de ; save de for next time around 
1395			 
1395				ex de, hl 
1395				call loadwordinhl 
1395				ex de, hl 
1395			 
1395				; need hl to be the id 
1395				; need de to be the string ptr 
1395				 
1395				call storage_append 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				inc de 
1395				inc de 
1395			 
1395				ld a,(de) 
1395				cp 0 
1395				jr nz, .genloop 
1395				inc de 
1395				ld a, (de) 
1395				dec de 
1395				cp 0 
1395				jr nz, .genloop	 
1395			 
1395				ret 
1395			 
1395			.genfiletxt:  db "Creating file...",0 
1395			 
1395			.hwworddef: 
1395				dw test5 
1395				dw test6 
1395				dw test7 
1395				dw test8 
1395				dw test9 
1395				dw test10 
1395				dw 0 
1395			 
1395			.soundworddef: 
1395				dw sound1 
1395				dw sound2 
1395				dw sound3 
1395				dw sound4 
1395				dw sound5 
1395				dw sound6 
1395				dw sound7 
1395				dw sound8 
1395				dw sound9 
1395				dw 0 
1395			 
1395			.utilwordef: 
1395				dw strncpy 
1395				dw type 
1395				dw tuck 
1395				dw clrstack 
1395				dw longread 
1395				dw start1 
1395				dw start2 
1395			; duplicated 
1395			;	dw start3b 
1395			;	dw start3c 
1395				dw list 
1395				dw 0 
1395			 
1395			.lsworddef: 
1395				dw start3b 
1395				dw 0 
1395			 
1395			.edworddef: 
1395				dw edit1 
1395				dw edit2 
1395				dw edit3 
1395				dw 0 
1395			 
1395			.demoworddef: 
1395				dw game1 
1395				dw game1a 
1395				dw game1b 
1395				dw game1c 
1395				dw game1d 
1395				dw game1s 
1395				dw game1t 
1395				dw game1f 
1395				dw game1z 
1395				dw game1zz 
1395				dw ssv2 
1395				dw ssv3 
1395				dw ssv4 
1395				dw ssv5 
1395				dw ssv1 
1395				dw ssv1cpm	 
1395			;	dw game2b 
1395			;	dw game2bf 
1395			;	dw game2mba 
1395			;	dw game2mbas	 
1395			;	dw game2mbht 
1395			;	dw game2mbms 
1395			;	dw game2mb 
1395			;	dw game3w 
1395			;	dw game3p 
1395			;	dw game3sc 
1395			;	dw game3vsi 
1395			;	dw game3vs 
1395				dw 0 
1395			 
1395			 
1395			.spiworddef: 
1395			 
1395			    dw spi1 
1395			    dw spi2 
1395			    dw spi2b 
1395			    dw spi3 
1395			    dw spi4 
1395			    dw spi5 
1395			;    dw spi6 
1395			;    dw spi7 
1395			 
1395			;    dw spi8 
1395			;    dw spi9 
1395			;    dw spi10 
1395			    dw 0 
1395			 
1395			.keyworddef: 
1395			 
1395				dw keyup 
1395				dw keydown 
1395				dw keyleft 
1395				dw keyright 
1395				dw 	keyf1 
1395				dw keyf2 
1395				dw keyf3 
1395				dw keyf4 
1395				dw keyf5 
1395				dw keyf6 
1395				dw keyf7 
1395				dw keyf8 
1395				dw keyf9 
1395				dw keyf10 
1395				dw keyf11 
1395				dw keyf12 
1395				dw keytab 
1395				dw keycr 
1395				dw keyhome 
1395				dw keyend 
1395				dw keybs 
1395				dw 0 
1395			 
1395			.crstart: 
1395				dw crs_s1 
1395				dw crs_s2 
1395				dw crs_s3 
1395				dw crs_s4 
1395				dw crs_s5 
1395				dw crs_s6 
1395				dw crs_sound 
1395				dw crs_hw 
1395				dw 0 
1395			 
1395			endif 
1395			 
1395			 
1395			if STORAGE_SE 
1395			 
1395			config_fdir: 
1395				; using the scratch dir go through and release the memory allocated for each string 
1395				 
1395				ld hl, scratch 
1395			.cfdir:	ld e,(hl) 
1395				inc hl 
1395				ld d,(hl) 
1395				inc hl 
1395			 
1395				ex de, hl 
1395				call ishlzero 
1395				ret z     ; return on null pointer 
1395				call free 
1395				ex de, hl 
1395				jr .cfdir 
1395			 
1395			 
1395				ret 
1395			 
1395			 
1395			config_dir: 
1395			 
1395				; for the config menus that need to build a directory of storage call this routine 
1395				; it will construct a menu in scratch to pass to menu 
1395			 
1395				; open storage device 
1395			 
1395				; execute DIR to build a list of files and their ids into scratch in menu format 
1395				; once the menu has finished then will need to call config_fdir to release the strings 
1395				 
1395				; c = number items 
1395			 
1395				 
1395				call storage_get_block_0 
1395			 
1395				ld hl, store_page     ; get current id count 
1395				ld b, (hl) 
1395				ld c, 0    ; count of files   
1395			 
1395			 
1395				ld hl, scratch 
1395				ld (store_tmp2), hl    ; location to poke strings 
1395			 
1395				; check for empty drive 
1395			 
1395				ld a, 0 
1395				cp b 
1395				jp z, .dirdone 
1395			 
1395				 
1395					if DEBUG_FORTH_WORDS 
1395						DMARK "Cdc" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			 
1395			.diritem:	 
1395				push bc 
1395				; for each of the current ids do a search for them and if found push to stack 
1395			 
1395					ld hl, STORE_BLOCK_PHY 
1395					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1395					ld e,b 
1395			 
1395					call storage_findnextid 
1395			 
1395			 
1395					; if found hl will be non zero 
1395			 
1395					call ishlzero 
1395					jr z, .dirnotfound 
1395			 
1395					; increase count 
1395			 
1395					pop bc	 
1395					inc c 
1395					push bc 
1395					 
1395			 
1395					; get file header and push the file name 
1395			 
1395					ld de, store_page 
1395					call storage_read_block 
1395			 
1395					; push file id to stack 
1395				 
1395					ld a, (store_page) 
1395					ld h, 0 
1395					ld l, a 
1395			 
1395					;call forth_push_numhl 
1395					; TODO store id 
1395			 
1395					push hl 
1395			 
1395					; push extent count to stack  
1395				 
1395					ld hl, store_page+3 
1395			 
1395					; get file name length 
1395			 
1395					call strlenz   
1395			 
1395					inc hl   ; cover zero term 
1395					inc hl  ; stick the id at the end of the area 
1395			 
1395					push hl 
1395					pop bc    ; move length to bc 
1395			 
1395					call malloc 
1395			 
1395					; TODO save malloc area to scratch 
1395			 
1395					ex de, hl 
1395					ld hl, (store_tmp2) 
1395					ld (hl), e 
1395					inc hl 
1395					ld (hl), d 
1395					inc hl 
1395					ld (store_tmp2), hl 
1395			 
1395					 
1395			 
1395					;pop hl   ; get source 
1395			;		ex de, hl    ; swap aronund	 
1395			 
1395					ld hl, store_page+3 
1395					if DEBUG_FORTH_WORDS 
1395						DMARK "CFd" 
1395						CALLMONITOR 
1395					endif 
1395					ldir 
1395			 
1395					; de is past string, move back one and store id 
1395					 
1395					dec de 
1395			 
1395					; store file id 
1395			 
1395					pop hl 
1395					ex de,hl 
1395					ld (hl), e 
1395			 
1395					if DEBUG_FORTH_WORDS 
1395						DMARK "Cdi" 
1395						CALLMONITOR 
1395					endif 
1395					 
1395			.dirnotfound: 
1395					pop bc     
1395					djnz .diritem 
1395				 
1395			.dirdone:	 
1395			 
1395			;		ld a, 0 
1395					ld hl, (store_tmp2) 
1395					ld (hl), 0 
1395					inc hl 
1395					ld (hl), 0 
1395					inc hl 
1395					; push a count of the dir items found 
1395			 
1395			;		ld h, 0 
1395			;		ld l, c 
1395			 
1395				ret 
1395			 
1395			endif 
1395			 
1395			 
1395			; Settings 
1395			; Run  
1395			 
1395			 
1395			 
1395			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1395			;;hd_menu2:   db "        2: Editor",0   
1395			;hd_menu2:   db "        2: Editor       6: Menu",0   
1395			;hd_menu3:   db "        3: Storage",0 
1395			;hd_menu4:   db "0=quit  4: Debug",0 
1395			;hd_don:     db "ON",0 
1395			;hd_doff:     db "OFF",0 
1395			; 
1395			; 
1395			; 
1395			;hardware_diags_old:       
1395			; 
1395			;.diagmenu: 
1395			;	call clear_display 
1395			;	ld a, display_row_1 
1395			;	ld de, hd_menu1 
1395			;	call str_at_display 
1395			; 
1395			;	ld a, display_row_2 
1395			;	ld de, hd_menu2 
1395			;	call str_at_display 
1395			; 
1395			;	ld a, display_row_3 
1395			;	ld de, hd_menu3 
1395			;	call str_at_display 
1395			; 
1395			;	ld a,  display_row_4 
1395			;	ld de, hd_menu4 
1395			;	call str_at_display 
1395			; 
1395			;	; display debug state 
1395			; 
1395			;	ld de, hd_don 
1395			;	ld a, (os_view_disable) 
1395			;	cp 0 
1395			;	jr z, .distog 
1395			;	ld de, hd_doff 
1395			;.distog: ld a, display_row_4+17 
1395			;	call str_at_display 
1395			; 
1395			;	call update_display 
1395			; 
1395			;	call cin_wait 
1395			; 
1395			; 
1395			; 
1395			;	cp '4' 
1395			;	jr nz, .diagn1 
1395			; 
1395			;	; debug toggle 
1395			; 
1395			;	ld a, (os_view_disable) 
1395			;	ld b, '*' 
1395			;	cp 0 
1395			;	jr z, .debtog 
1395			;	ld b, 0 
1395			;.debtog:	 
1395			;	ld a,b 
1395			;	ld (os_view_disable),a 
1395			; 
1395			;.diagn1: cp '0' 
1395			;	 ret z 
1395			; 
1395			;;	cp '1' 
1395			;;       jp z, matrix	 
1395			;;   TODO keyboard matrix test 
1395			; 
1395			;	cp '2' 
1395			;	jp z, .diagedit 
1395			; 
1395			;;	cp '6' 
1395			;;	jp z, .menutest 
1395			;;if ENABLE_BASIC 
1395			;;	cp '6' 
1395			;;	jp z, basic 
1395			;;endif 
1395			 ; 
1395			;	jp .diagmenu 
1395			; 
1395			; 
1395			;	ret 
1395			 
1395			 
1395			.debug_tog: 
1395 21 be 13			ld hl, .menudebug 
1398				 
1398			;	ld a, (os_view_disable) 
1398			;	cp '*' 
1398 3a 6f ee			ld a,(debug_vector) 
139b fe c9			cp $C9   ; RET 
139d 20 04			jr nz,.tdon  
139f 3e 01			ld a, 1 
13a1 18 02			jr .tog1 
13a3 3e 00		.tdon: ld a, 0 
13a5			 
13a5			.tog1: 
13a5 cd e7 0b			call menu 
13a8 fe 00			cp 0 
13aa c8				ret z 
13ab fe 01			cp 1    ; disable debug 
13ad 28 04			jr z, .dtog0 
13af 3e 2a			ld a, '*' 
13b1 18 05			jr .dtogset 
13b3			.dtog0:  
13b3				;ld a, 0 
13b3 cd 51 14			call bp_on 
13b6 18 dd			jr .debug_tog 
13b8			.dtogset:  
13b8				; ld (os_view_disable), a 
13b8 cd 5d 14			call bp_off 
13bb c3 95 13			jp .debug_tog 
13be			 
13be			 
13be			.menudebug: 
13be c4 13				dw .m6 
13c0 cd 13				dw .m7 
13c2 00 00				dw 0 
13c4 .. 00		.m6:   db "Debug ON",0 
13cd .. 00		.m7:   db "Debug OFF",0 
13d7			;hardware_diags:       
13d7			 
13d7			ENABLE_HDIAGS: equ 0 
13d7			 
13d7			if ENABLE_HDIAGS 
13d7			.diagm: 
13d7				ld hl, .menuitems 
13d7				ld a, 0 
13d7				call menu 
13d7			 
13d7			         cp 0 
13d7				 ret z 
13d7			 
13d7				cp 2 
13d7				jp z, .diagedit 
13d7			 
13d7			;	cp '6' 
13d7			;	jp z, .menutest 
13d7			;if ENABLE_BASIC 
13d7			;	cp '6' 
13d7			;	jp z, basic 
13d7			;endif 
13d7			  
13d7				jp .diagm 
13d7			 
13d7				 
13d7			.menuitems:   	dw .m1 
13d7					dw .m2 
13d7					dw .m3 
13d7					dw .m5 
13d7					dw .m5a 
13d7					dw .m5b 
13d7					dw 0 
13d7			 
13d7			 
13d7			.m1:   db "Key Matrix",0 
13d7			.m2:   db "Editor",0 
13d7			.m3:   db "Storage",0 
13d7			.m5:   db "Sound",0 
13d7			.m5a:  db "RAM Test",0 
13d7			.m5b:  db "LCD Test",0 
13d7			 
13d7			 
13d7			; debug editor 
13d7			 
13d7			.diagedit: 
13d7			 
13d7				ld hl, scratch 
13d7			;	ld bc, 250 
13d7			;	ldir 
13d7				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13d7			;	ld a, 0 
13d7				ld (hl), 0 
13d7				inc hl 
13d7				ld (hl), 0 
13d7				inc hl 
13d7				ld (hl), 0 
13d7			 
13d7			        call clear_display 
13d7				call update_display 
13d7				;ld a, 1 
13d7				;ld (hardware_diag), a 
13d7			.diloop: 
13d7				ld a, display_row_1 
13d7				ld c, 0 
13d7				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13d7				ld e, 40 
13d7			 
13d7				ld hl, scratch	 
13d7				call input_str 
13d7			 
13d7				ld a, display_row_2 
13d7				ld de, scratch 
13d7				call str_at_display 
13d7				call update_display 
13d7			 
13d7				jp .diloop 
13d7			endif 
13d7			 
13d7			; pass word in hl 
13d7			; a has display location 
13d7			display_word_at: 
13d7 f5				push af 
13d8 e5				push hl 
13d9 7c				ld a,h 
13da 21 bd e5			ld hl, os_word_scratch 
13dd cd dd 0f			call hexout 
13e0 e1				pop hl 
13e1 7d				ld a,l 
13e2 21 bf e5			ld hl, os_word_scratch+2 
13e5 cd dd 0f			call hexout 
13e8 21 c1 e5			ld hl, os_word_scratch+4 
13eb			;	ld a,0 
13eb 36 00			ld (hl),0 
13ed 11 bd e5			ld de,os_word_scratch 
13f0 f1				pop af 
13f1 cd c9 0b				call str_at_display 
13f4 c9				ret 
13f5			 
13f5			display_ptr_state: 
13f5			 
13f5				; to restore afterwards 
13f5			 
13f5 d5				push de 
13f6 c5				push bc 
13f7 e5				push hl 
13f8 f5				push af 
13f9			 
13f9				; for use in here 
13f9			 
13f9			;	push bc 
13f9			;	push de 
13f9			;	push hl 
13f9			;	push af 
13f9			 
13f9 cd b7 0b			call clear_display 
13fc			 
13fc 11 d4 15			ld de, .ptrstate 
13ff 3e 00			ld a, display_row_1 
1401 cd c9 0b			call str_at_display 
1404			 
1404				; display debug step 
1404			 
1404			 
1404 11 62 ee			ld de, debug_mark 
1407 3e 26			ld a, display_row_1+display_cols-2 
1409 cd c9 0b			call str_at_display 
140c			 
140c				; display a 
140c 11 de 15			ld de, .ptrcliptr 
140f 3e 28			ld a, display_row_2 
1411 cd c9 0b			call str_at_display 
1414			 
1414 f1				pop af 
1415 2a 37 ea			ld hl,(cli_ptr) 
1418 3e 30			ld a, display_row_2+8 
141a cd d7 13			call display_word_at 
141d			 
141d			 
141d				; display hl 
141d			 
141d			 
141d 11 e6 15			ld de, .ptrclioptr 
1420 3e 32			ld a, display_row_2+10 
1422 cd c9 0b			call str_at_display 
1425			; 
1425			;	pop hl 
1425 3e 35			ld a, display_row_2+13 
1427 2a 35 ea			ld hl,(cli_origptr) 
142a cd d7 13			call display_word_at 
142d			; 
142d			;	 
142d			;	; display de 
142d			 
142d			;	ld de, .regstatede 
142d			;	ld a, display_row_3 
142d			;	call str_at_display 
142d			 
142d			;	pop de 
142d			;	ld h,d 
142d			;	ld l, e 
142d			;	ld a, display_row_3+3 
142d			;	call display_word_at 
142d			 
142d			 
142d				; display bc 
142d			 
142d			;	ld de, .regstatebc 
142d			;	ld a, display_row_3+10 
142d			;	call str_at_display 
142d			 
142d			;	pop bc 
142d			;	ld h,b 
142d			;	ld l, c 
142d			;	ld a, display_row_3+13 
142d			;	call display_word_at 
142d			 
142d			 
142d				; display dsp 
142d			 
142d			;	ld de, .regstatedsp 
142d			;	ld a, display_row_4 
142d			;	call str_at_display 
142d			 
142d				 
142d			;	ld hl,(cli_data_sp) 
142d			;	ld a, display_row_4+4 
142d			;	call display_word_at 
142d			 
142d				; display rsp 
142d			 
142d 11 15 16			ld de, .regstatersp 
1430 3e 82			ld a, display_row_4+10 
1432 cd c9 0b			call str_at_display 
1435			 
1435				 
1435 2a e9 e9			ld hl,(cli_ret_sp) 
1438 3e 86			ld a, display_row_4+14 
143a cd d7 13			call display_word_at 
143d			 
143d cd d9 0b			call update_display 
1440			 
1440 cd f0 0a			call delay1s 
1443 cd f0 0a			call delay1s 
1446 cd f0 0a			call delay1s 
1449			 
1449			 
1449 cd 4a 1a			call next_page_prompt 
144c			 
144c				; restore  
144c			 
144c f1				pop af 
144d e1				pop hl 
144e c1				pop bc 
144f d1				pop de 
1450 c9				ret 
1451			 
1451			; Update the break point vector so that the user can hook a new routine 
1451			 
1451			bp_on: 
1451 3e c3			ld a, $c3    ; JP 
1453 32 6f ee			ld (debug_vector), a 
1456 21 63 14			ld hl, break_point_state 
1459 22 70 ee			ld (debug_vector+1), hl 
145c c9				ret 
145d			 
145d			bp_off: 
145d 3e c9			ld a, $c9    ; RET 
145f 32 6f ee			ld (debug_vector), a 
1462 c9				ret 
1463			 
1463			 
1463			break_point_state: 
1463			;	push af 
1463			; 
1463			;	; see if disabled 
1463			; 
1463			;	ld a, (os_view_disable) 
1463			;	cp '*' 
1463			;	jr nz, .bpsgo 
1463			;	pop af 
1463			;	ret 
1463			 
1463			.bpsgo: 
1463			;	pop af 
1463 f5				push af 
1464 22 9a e2			ld (os_view_hl), hl 
1467 ed 53 98 e2		ld (os_view_de), de 
146b ed 43 96 e2		ld (os_view_bc), bc 
146f e5				push hl 
1470 6f				ld l, a 
1471 26 00			ld h, 0 
1473 22 9c e2			ld (os_view_af),hl 
1476			 
1476 21 a8 ed				ld hl, display_fb0 
1479 22 c3 eb				ld (display_fb_active), hl 
147c e1				pop hl	 
147d			 
147d 3e 31			ld a, '1' 
147f fe 2a		.bps1:  cp '*' 
1481 cc 5d 14			call z, bp_off 
1484			;	jr nz, .bps1b 
1484			;	ld (os_view_disable),a 
1484 fe 31		.bps1b:  cp '1' 
1486 20 14			jr nz, .bps2 
1488			 
1488				; display reg 
1488			 
1488				 
1488			 
1488 3a 9c e2			ld a, (os_view_af) 
148b 2a 9a e2			ld hl, (os_view_hl) 
148e ed 5b 98 e2		ld de, (os_view_de) 
1492 ed 4b 96 e2		ld bc, (os_view_bc) 
1496 cd 30 15			call display_reg_state 
1499 c3 1c 15			jp .bpschk 
149c			 
149c fe 32		.bps2:  cp '2' 
149e 20 08			jr nz, .bps3 
14a0				 
14a0				; display hl 
14a0 2a 9a e2			ld hl, (os_view_hl) 
14a3 cd 1a 16			call display_dump_at_hl 
14a6			 
14a6 18 74			jr .bpschk 
14a8			 
14a8 fe 33		.bps3:  cp '3' 
14aa 20 08			jr nz, .bps4 
14ac			 
14ac			        ; display de 
14ac 2a 98 e2			ld hl, (os_view_de) 
14af cd 1a 16			call display_dump_at_hl 
14b2			 
14b2 18 68			jr .bpschk 
14b4 fe 34		.bps4:  cp '4' 
14b6 20 08			jr nz, .bps5 
14b8			 
14b8			        ; display bc 
14b8 2a 96 e2			ld hl, (os_view_bc) 
14bb cd 1a 16			call display_dump_at_hl 
14be			 
14be 18 5c			jr .bpschk 
14c0 fe 35		.bps5:  cp '5' 
14c2 20 08		        jr nz, .bps7 
14c4			 
14c4				; display cur ptr 
14c4 2a 37 ea			ld hl, (cli_ptr) 
14c7 cd 1a 16			call display_dump_at_hl 
14ca			 
14ca 18 50			jr .bpschk 
14cc fe 36		.bps7:  cp '6' 
14ce 20 08			jr nz, .bps8b 
14d0				 
14d0				; display cur orig ptr 
14d0 2a 35 ea			ld hl, (cli_origptr) 
14d3 cd 1a 16			call display_dump_at_hl 
14d6 18 44			jr .bpschk 
14d8 fe 37		.bps8b:  cp '7' 
14da 20 08			jr nz, .bps9 
14dc				 
14dc				; display dsp 
14dc 2a e5 e9			ld hl, (cli_data_sp) 
14df cd 1a 16			call display_dump_at_hl 
14e2			 
14e2 18 38			jr .bpschk 
14e4 fe 39		.bps9:  cp '9' 
14e6 20 05			jr nz, .bps8c 
14e8				 
14e8				; display SP 
14e8			;	ld hl, sp 
14e8 cd 1a 16			call display_dump_at_hl 
14eb			 
14eb 18 2f			jr .bpschk 
14ed fe 38		.bps8c:  cp '8' 
14ef 20 08			jr nz, .bps8d 
14f1				 
14f1				; display rsp 
14f1 2a e9 e9			ld hl, (cli_ret_sp) 
14f4 cd 1a 16			call display_dump_at_hl 
14f7			 
14f7 18 23			jr .bpschk 
14f9 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14fb 20 05			jr nz, .bps8 
14fd cd 08 18			call monitor 
1500			 
1500 18 1a			jr .bpschk 
1502 fe 30		.bps8:  cp '0' 
1504 20 16			jr nz, .bpschk 
1506			 
1506 21 07 ed				ld hl, display_fb1 
1509 22 c3 eb				ld (display_fb_active), hl 
150c cd d9 0b				call update_display 
150f			 
150f				;ld a, (os_view_af) 
150f 2a 9a e2			ld hl, (os_view_hl) 
1512 ed 5b 98 e2		ld de, (os_view_de) 
1516 ed 4b 96 e2		ld bc, (os_view_bc) 
151a f1				pop af 
151b c9				ret 
151c			 
151c			.bpschk:   
151c cd f0 0a			call delay1s 
151f 3e 9f		ld a,display_row_4 + display_cols - 1 
1521 11 48 1a		        ld de, endprg 
1524 cd c9 0b			call str_at_display 
1527 cd d9 0b			call update_display 
152a cd a8 65			call cin_wait 
152d			 
152d c3 7f 14			jp .bps1 
1530			 
1530			 
1530			display_reg_state: 
1530			 
1530				; to restore afterwards 
1530			 
1530 d5				push de 
1531 c5				push bc 
1532 e5				push hl 
1533 f5				push af 
1534			 
1534				; for use in here 
1534			 
1534 c5				push bc 
1535 d5				push de 
1536 e5				push hl 
1537 f5				push af 
1538			 
1538 cd b7 0b			call clear_display 
153b			 
153b 11 f0 15			ld de, .regstate 
153e 3e 00			ld a, display_row_1 
1540 cd c9 0b			call str_at_display 
1543			 
1543				; display debug step 
1543			 
1543			 
1543 11 62 ee			ld de, debug_mark 
1546 3e 25			ld a, display_row_1+display_cols-3 
1548 cd c9 0b			call str_at_display 
154b			 
154b				; display a 
154b 11 0c 16			ld de, .regstatea 
154e 3e 28			ld a, display_row_2 
1550 cd c9 0b			call str_at_display 
1553			 
1553 e1				pop hl 
1554			;	ld h,0 
1554			;	ld l, a 
1554 3e 2b			ld a, display_row_2+3 
1556 cd d7 13			call display_word_at 
1559			 
1559			 
1559				; display hl 
1559			 
1559			 
1559 11 00 16			ld de, .regstatehl 
155c 3e 32			ld a, display_row_2+10 
155e cd c9 0b			call str_at_display 
1561			 
1561 e1				pop hl 
1562 3e 35			ld a, display_row_2+13 
1564 cd d7 13			call display_word_at 
1567			 
1567				 
1567				; display de 
1567			 
1567 11 04 16			ld de, .regstatede 
156a 3e 50			ld a, display_row_3 
156c cd c9 0b			call str_at_display 
156f			 
156f e1				pop hl 
1570			;	ld h,d 
1570			;	ld l, e 
1570 3e 53			ld a, display_row_3+3 
1572 cd d7 13			call display_word_at 
1575			 
1575			 
1575				; display bc 
1575			 
1575 11 08 16			ld de, .regstatebc 
1578 3e 5a			ld a, display_row_3+10 
157a cd c9 0b			call str_at_display 
157d			 
157d e1				pop hl 
157e			;	ld h,b 
157e			;	ld l, c 
157e 3e 5d			ld a, display_row_3+13 
1580 cd d7 13			call display_word_at 
1583			 
1583			 
1583				; display dsp 
1583			 
1583 11 10 16			ld de, .regstatedsp 
1586 3e 78			ld a, display_row_4 
1588 cd c9 0b			call str_at_display 
158b			 
158b				 
158b 2a e5 e9			ld hl,(cli_data_sp) 
158e 3e 7c			ld a, display_row_4+4 
1590 cd d7 13			call display_word_at 
1593			 
1593				; display rsp 
1593			 
1593 11 15 16			ld de, .regstatersp 
1596 3e 82			ld a, display_row_4+10 
1598 cd c9 0b			call str_at_display 
159b			 
159b				 
159b 2a e9 e9			ld hl,(cli_ret_sp) 
159e 3e 86			ld a, display_row_4+14 
15a0 cd d7 13			call display_word_at 
15a3			 
15a3 cd d9 0b			call update_display 
15a6			 
15a6			;	call delay1s 
15a6			;	call delay1s 
15a6			;	call delay1s 
15a6			 
15a6			 
15a6			;	call next_page_prompt 
15a6			 
15a6				; restore  
15a6			 
15a6 f1				pop af 
15a7 e1				pop hl 
15a8 c1				pop bc 
15a9 d1				pop de 
15aa c9				ret 
15ab			 
15ab .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15bf .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15d4 .. 00		.ptrstate:	db "Ptr State",0 
15de .. 00		.ptrcliptr:     db "cli_ptr",0 
15e6 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15f0 .. 00		.regstate:	db "Reg State (1/0)",0 
1600 .. 00		.regstatehl:	db "HL:",0 
1604 .. 00		.regstatede:	db "DE:",0 
1608 .. 00		.regstatebc:	db "BC:",0 
160c .. 00		.regstatea:	db "A :",0 
1610 .. 00		.regstatedsp:	db "DSP:",0 
1615 .. 00		.regstatersp:	db "RSP:",0 
161a			 
161a			display_dump_at_hl: 
161a e5				push hl 
161b d5				push de 
161c c5				push bc 
161d f5				push af 
161e			 
161e 22 db e5			ld (os_cur_ptr),hl	 
1621 cd b7 0b			call clear_display 
1624 cd 56 19			call dumpcont 
1627			;	call delay1s 
1627			;	call next_page_prompt 
1627			 
1627			 
1627 f1				pop af 
1628 c1				pop bc 
1629 d1				pop de 
162a e1				pop hl 
162b c9				ret 
162c			 
162c			;if ENABLE_BASIC 
162c			;	include "nascombasic.asm" 
162c			;	basic: 
162c			;	include "forth/FORTH.ASM" 
162c			;endif 
162c			 
162c			; eof 
162c			 
162c			 
# End of file firmware_diags.asm
162c			  
162c			include "firmware_prompts.asm"  
162c			; Prompts  
162c			 
162c			; boot messages 
162c			 
162c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1641 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1651			 
1651			 
1651			; config menus 
1651			 
1651			;prom_c3: db "Add Dictionary To File",0 
1651			 
1651			if STARTUP_V1 
1651 .. 00		prom_c2: db "Select Autoload File",0 
1666 .. 00		prom_c2a: db "Disable Autoload File", 0 
167c			endif 
167c			 
167c			if STARTUP_V2 
167c			prom_c2: db "Enable Autoload Files",0 
167c			prom_c2a: db "Disable Autoload Files", 0 
167c			 
167c			crs_s1: db "*ls-word", 0 
167c			crs_s2: db "*ed-word", 0 
167c			crs_s3: db "*Demo-Games", 0 
167c			crs_s4: db "*Utils", 0 
167c			crs_s5: db "*SPI-Util", 0 
167c			crs_s6: db "*Key-Constants", 0 
167c			crs_sound: db "*Sound-Util", 0 
167c			crs_hw: db "*Hello-World",0 
167c			 
167c			 
167c			 
167c			endif 
167c			;prom_c2b: db "Select Storage Bank",0 
167c .. 00		prom_c4: db "Settings",0 
1685 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
16a0 .. 00		prom_m4b:   db "Monitor",0 
16a8			;prom_c1: db "Hardware Diags",0 
16a8			 
16a8			 
16a8			if STARTUP_V2 
16a8			prom_c9: db "Create Startup Files",0 
16a8			prom_bsel: db "Start From Bank...",0 
16a8			prom_bsel1: db "Bank 1",0 
16a8			prom_bsel2: db "Bank 2",0 
16a8			prom_bsel3: db "Bank 3",0 
16a8			prom_bsel4: db "Bank 4",0 
16a8			prom_bsel5: db "Bank 5",0 
16a8			 
16a8			prom_banks: 
16a8				dw prom_bsel1 
16a8				dw prom_bsel2 
16a8				dw prom_bsel3 
16a8				dw prom_bsel4 
16a8				dw prom_bsel5 
16a8				dw 0 
16a8			endif 
16a8			 
16a8 .. 00		prom_notav:    db "Feature not available",0 
16be .. 00		prom_empty:    db "",0 
16bf			 
16bf			; eof 
16bf			 
# End of file firmware_prompts.asm
16bf			  
16bf			; eof  
16bf			  
# End of file firmware.asm
16bf			 
16bf			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
16bf			;if BASE_KEV  
16bf			;baseram: equ 08000h 
16bf			;endif 
16bf			 
16bf			;if BASE_SC114 
16bf			;baseram:     equ    endofcode 
16bf			;endif 
16bf			 
16bf			 
16bf			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
16bf			 
16bf			; start system 
16bf			 
16bf			coldstart: 
16bf				; set sp 
16bf				; di/ei 
16bf			 
16bf f3				di 
16c0 31 00 f0			ld sp, tos 
16c3 cd a6 64			call init_nmi 
16c6			;	ei 
16c6			 
16c6				; init spinner 
16c6 3e 00			ld a,0 
16c8 32 bd eb			ld (display_active), a 
16cb			 
16cb				; disable breakpoint by default 
16cb			 
16cb				;ld a,'*' 
16cb			;	ld a,' ' 
16cb			;	ld (os_view_disable),a 
16cb			 
16cb				; set break point vector as new break point on or off 
16cb cd 5d 14			call bp_off 
16ce			 
16ce			 
16ce				; default the parse vector to just a RET 
16ce 3e c9			ld a, $c9 
16d0 32 6c ee			ld (parse_vector), a 
16d3			 
16d3				; init hardware 
16d3			 
16d3				; init keyboard and screen hardware 
16d3			 
16d3 cd 1f 01			call hardware_init 
16d6			 
16d6			 
16d6 cd f0 0a			call delay1s 
16d9 3e 58			ld a, display_row_3+8 
16db 11 03 01			ld de, buildtime 
16de cd c9 0b			call str_at_display 
16e1 cd d9 0b			call update_display 
16e4			 
16e4 cd f0 0a			call delay1s 
16e7 cd f0 0a			call delay1s 
16ea cd f0 0a			call delay1s 
16ed			 
16ed				; detect if any keys are held down to enable breakpoints at start up 
16ed			 
16ed cd b0 65			call cin  
16f0 fe 00			cp 0 
16f2 28 03			jr z, .nokeys 
16f4			 
16f4				;call hardware_diags 
16f4 cd 46 13			call config 
16f7			 
16f7			;	ld de, .bpen 
16f7			;	ld a, display_row_4 
16f7			;	call str_at_display 
16f7			;	call update_display 
16f7			; 
16f7			;	ld a,0 
16f7			;	ld (os_view_disable),a 
16f7			; 
16f7			;.bpwait: 
16f7			;	call cin 
16f7			;	cp 0 
16f7			;	jr z, .bpwait 
16f7			;	jr .nokeys 
16f7			; 
16f7			; 
16f7			;.bpen:  db "Break points enabled!",0 
16f7			 
16f7			 
16f7			 
16f7			 
16f7			 
16f7			 
16f7			.nokeys: 
16f7			 
16f7			 
16f7				 
16f7			 
16f7			;jp  testkey 
16f7			 
16f7			;call storage_get_block_0 
16f7			; 
16f7			;ld hl, 0 
16f7			;ld de, store_page 
16f7			;call storage_read_block 
16f7			 
16f7				 
16f7			;ld hl, 10 
16f7			;ld de, store_page 
16f7			;call storage_read_block 
16f7			 
16f7			 
16f7			 
16f7			 
16f7			 
16f7			;stop:	nop 
16f7			;	jp stop 
16f7			 
16f7			 
16f7			 
16f7			main: 
16f7 cd b7 0b			call clear_display 
16fa cd d9 0b			call update_display 
16fd			 
16fd			 
16fd			 
16fd			;	call testlcd 
16fd			 
16fd			 
16fd			 
16fd cd 85 1e			call forth_init 
1700			 
1700			 
1700			warmstart: 
1700 cd 5b 1e			call forth_warmstart 
1703			 
1703				; run startup word load 
1703			        ; TODO prevent this running at warmstart after crash  
1703			 
1703				if STARTUP_ENABLE 
1703			 
1703					if STARTUP_V1 
1703			 
1703						if STORAGE_SE 
1703							call forth_autoload 
1703						endif 
1703 cd f6 63					call forth_startup 
1706					endif 
1706			 
1706					if STARTUP_V2 
1706			 
1706						if STORAGE_SE 
1706							call forth_autoload 
1706						else 
1706							call forth_startup 
1706						endif 
1706			 
1706			 
1706					endif 
1706			 
1706				endif 
1706			 
1706			warmstart_afterauto: 
1706			 
1706				; show free memory after boot 
1706 11 a3 17			ld de, freeram 
1709 3e 00			ld a, display_row_1 
170b cd c9 0b			call str_at_display 
170e			 
170e				; get current heap start after loading any uwords 
170e			 
170e				;ld de, (os_last_new_uword) 
170e				;ex de, hl 
170e			 
170e			; Or use heap_size word???? 
170e				;ld hl, heap_end 
170e				;ld hl, heap_size 
170e				;ld de, topusermem 
170e				;ld de, heap_start 
170e ed 5b d3 65			ld de, (free_list )      
1712 21 93 e2				ld hl, heap_end 
1715 ed 52			sbc hl, de 
1717				;push hl 
1717				;ld a,h	         	 
1717				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1717				;call hexout 
1717			   	;pop hl 
1717			; 
1717			;	ld a,l 
1717			;	ld hl, os_word_scratch+2 
1717			;	call hexout 
1717			;	ld hl, os_word_scratch+4 
1717			;	ld a, 0 
1717			;	ld (hl),a 
1717 eb				ex de, hl 
1718 21 bd e5			ld hl, os_word_scratch 
171b cd e8 10			call uitoa_16 
171e			 
171e			 
171e 11 bd e5			ld de, os_word_scratch 
1721 3e 0d			ld a, display_row_1 + 13 
1723 cd c9 0b			call str_at_display 
1726 cd d9 0b			call update_display 
1729			 
1729			 
1729				;call demo 
1729			 
1729			 
1729				; init scratch input area for cli commands 
1729			 
1729 21 df e5			ld hl, os_cli_cmd 
172c			;	ld a,0 
172c 36 00			ld (hl),0 
172e 23				inc hl 
172f 36 00			ld (hl),0 
1731			 
1731 3e 00			ld a,0 
1733 32 de e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1736			 
1736 32 db e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1739 32 dc e5			ld (os_cur_ptr+1),a	 
173c			 
173c 32 bd e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
173f 32 be e5			ld (os_word_scratch+1),a	 
1742				 
1742			 
1742				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1742 21 df e5			ld hl, os_cli_cmd 
1745			 
1745			;	ld a, 0		 ; init cli input 
1745 36 00			ld (hl), 0 
1747 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1749			cli: 
1749				; show cli prompt 
1749				;push af 
1749				;ld a, 0 
1749				;ld de, prompt 
1749				;call str_at_display 
1749			 
1749				;call update_display 
1749				;pop af 
1749				;inc a 
1749				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1749			 
1749			.lastrecall: 
1749			 
1749 0e 00			ld c, 0 
174b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
174d 1e 28			ld e, 40 
174f			 
174f 21 df e5			ld hl, os_cli_cmd 
1752			 
1752				STACKFRAME OFF $fefe $9f9f 
1752				if DEBUG_STACK_IMB 
1752					if OFF 
1752						exx 
1752						ld de, $fefe 
1752						ld a, d 
1752						ld hl, curframe 
1752						call hexout 
1752						ld a, e 
1752						ld hl, curframe+2 
1752						call hexout 
1752						ld hl, $fefe 
1752						push hl 
1752						ld hl, $9f9f 
1752						push hl 
1752						exx 
1752					endif 
1752				endif 
1752			endm 
# End of macro STACKFRAME
1752			 
1752 cd 0e 0e			call input_str 
1755			 
1755				STACKFRAMECHK OFF $fefe $9f9f 
1755				if DEBUG_STACK_IMB 
1755					if OFF 
1755						exx 
1755						ld hl, $9f9f 
1755						pop de   ; $9f9f 
1755						call cmp16 
1755						jr nz, .spnosame 
1755						ld hl, $fefe 
1755						pop de   ; $fefe 
1755						call cmp16 
1755						jr z, .spfrsame 
1755						.spnosame: call showsperror 
1755						.spfrsame: nop 
1755						exx 
1755					endif 
1755				endif 
1755			endm 
# End of macro STACKFRAMECHK
1755			 
1755			 
1755				; check to see if last line recall has been requested 
1755			 
1755			if EDIT_V2 
1755 fe 05			cp KEY_UP 
1757 20 0f			jr nz, .noexecline 
1759			 
1759 11 df e5			ld de, os_cli_cmd 
175c 21 de e6			ld hl, os_last_cmd 
175f 01 ff 00			ld bc, 255 
1762 ed b0			ldir 
1764 3e 00			ld a, 0 
1766 18 e1			jr .lastrecall 
1768			endif 
1768			 
1768			.noexecline: 
1768				; no so exec the line		 
1768			 
1768				; copy input to last command 
1768			 
1768 21 df e5			ld hl, os_cli_cmd 
176b 11 de e6			ld de, os_last_cmd 
176e 01 ff 00			ld bc, 255 
1771 ed b0			ldir 
1773			 
1773				; wipe current buffer 
1773			 
1773			;	ld a, 0 
1773			;	ld hl, os_cli_cmd 
1773			;	ld de, os_cli_cmd+1 
1773			;	ld bc, 254 
1773			;	ldir 
1773				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1773			;	call strcpy 
1773			;	ld a, 0 
1773			;	ld (hl), a 
1773			;	inc hl 
1773			;	ld (hl), a 
1773			;	inc hl 
1773			;	ld (hl), a 
1773			 
1773				; switch frame buffer to program  
1773			 
1773 21 07 ed				ld hl, display_fb1 
1776 22 c3 eb				ld (display_fb_active), hl 
1779			 
1779			;	nop 
1779				STACKFRAME ON $fbfe $8f9f 
1779				if DEBUG_STACK_IMB 
1779					if ON 
1779						exx 
1779						ld de, $fbfe 
1779						ld a, d 
1779						ld hl, curframe 
1779						call hexout 
1779						ld a, e 
1779						ld hl, curframe+2 
1779						call hexout 
1779						ld hl, $fbfe 
1779						push hl 
1779						ld hl, $8f9f 
1779						push hl 
1779						exx 
1779					endif 
1779				endif 
1779			endm 
# End of macro STACKFRAME
1779				; first time into the parser so pass over the current scratch pad 
1779 21 df e5			ld hl,os_cli_cmd 
177c				; tokenise the entered statement(s) in HL 
177c cd fb 1e			call forthparse 
177f			        ; exec forth statements in top of return stack 
177f cd 33 1f			call forthexec 
1782				;call forthexec_cleanup 
1782			;	call parsenext 
1782			 
1782				STACKFRAMECHK ON $fbfe $8f9f 
1782				if DEBUG_STACK_IMB 
1782					if ON 
1782						exx 
1782						ld hl, $8f9f 
1782						pop de   ; $8f9f 
1782						call cmp16 
1782						jr nz, .spnosame 
1782						ld hl, $fbfe 
1782						pop de   ; $fbfe 
1782						call cmp16 
1782						jr z, .spfrsame 
1782						.spnosame: call showsperror 
1782						.spfrsame: nop 
1782						exx 
1782					endif 
1782				endif 
1782			endm 
# End of macro STACKFRAMECHK
1782				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1782			 
1782 3e 78			ld a, display_row_4 
1784 11 b4 17			ld de, endprog 
1787			 
1787 cd d9 0b			call update_display		 
178a			 
178a cd 4a 1a			call next_page_prompt 
178d			 
178d				; switch frame buffer to cli 
178d			 
178d 21 a8 ed				ld hl, display_fb0 
1790 22 c3 eb				ld (display_fb_active), hl 
1793			 
1793			 
1793 cd b7 0b		        call clear_display 
1796 cd d9 0b			call update_display		 
1799			 
1799 21 df e5			ld hl, os_cli_cmd 
179c			 
179c			;	ld a, 0		 ; init cli input 
179c 36 00			ld (hl), 0 
179e			 
179e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
179e			 
179e				; now on last line 
179e			 
179e				; TODO scroll screen up 
179e			 
179e				; TODO instead just clear screen and place at top of screen 
179e			 
179e			;	ld a, 0 
179e			;	ld (f_cursor_ptr),a 
179e			 
179e				;call clear_display 
179e				;call update_display 
179e			 
179e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
179e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17a0 c3 49 17			jp cli 
17a3			 
17a3 .. 00		freeram: db "Free bytes: ",0 
17b0 ..			asc: db "1A2F" 
17b4 .. 00		endprog: db "End prog...",0 
17c0			 
17c0			testenter2:   
17c0 21 ea e2			ld hl,scratch+50 
17c3 22 db e5			ld (os_cur_ptr),hl 
17c6 c3 49 17			jp cli 
17c9			 
17c9			testenter:  
17c9			 
17c9 21 b0 17			ld hl,asc 
17cc			;	ld a,(hl) 
17cc			;	call nibble2val 
17cc cd 33 10			call get_byte 
17cf			 
17cf			 
17cf			;	ld a,(hl) 
17cf			;	call atohex 
17cf			 
17cf			;	call fourehexhl 
17cf 32 ea e2			ld (scratch+50),a 
17d2			 
17d2			 
17d2			 
17d2 21 b2 17			ld hl,asc+2 
17d5			;	ld a, (hl) 
17d5			;	call nibble2val 
17d5 cd 33 10			call get_byte 
17d8			 
17d8			;	call fourehexhl 
17d8 32 ec e2			ld (scratch+52),a 
17db				 
17db 21 ea e2			ld hl,scratch+50 
17de 22 db e5			ld (os_cur_ptr),hl 
17e1 c3 49 17			jp cli 
17e4			 
17e4			enter:	 
17e4 3a bc e2			ld a,(scratch+4) 
17e7 fe 00			cp 0 
17e9 28 0c			jr z, .entercont 
17eb				; no, not a null term line so has an address to work out.... 
17eb			 
17eb 21 ba e2			ld hl,scratch+2 
17ee cd 93 10			call get_word_hl 
17f1			 
17f1 22 db e5			ld (os_cur_ptr),hl	 
17f4 c3 49 17			jp cli 
17f7			 
17f7			 
17f7			.entercont:  
17f7			 
17f7 21 ba e2			ld hl, scratch+2 
17fa cd 33 10			call get_byte 
17fd			 
17fd 2a db e5		   	ld hl,(os_cur_ptr) 
1800 77					ld (hl),a 
1801 23					inc hl 
1802 22 db e5				ld (os_cur_ptr),hl 
1805				 
1805			; get byte  
1805			 
1805			 
1805 c3 49 17			jp cli 
1808			 
1808			 
1808			; basic monitor support 
1808			 
1808			monitor: 
1808				;  
1808 cd b7 0b			call clear_display 
180b 3e 00			ld a, 0 
180d 11 61 18			ld de, .monprompt 
1810 cd c9 0b			call str_at_display 
1813 cd d9 0b			call update_display 
1816			 
1816				; get a monitor command 
1816			 
1816 0e 00			ld c, 0     ; entry at top left 
1818 16 64			ld d, 100   ; max buffer size 
181a 1e 0f			ld e, 15    ; input scroll area 
181c			;	ld a, 0     ; init string 
181c 21 b6 e4			ld hl, os_input 
181f 36 00			ld (hl), 0 
1821 23				inc hl 
1822 36 00			ld (hl), 0 
1824 21 b6 e4			ld hl, os_input 
1827 3e 01			ld a, 1     ; init string 
1829 cd 0e 0e			call input_str 
182c			 
182c cd b7 0b		        call clear_display 
182f cd d9 0b			call update_display		 
1832			 
1832 3a b6 e4			ld a, (os_input) 
1835 cd 30 11			call toUpper 
1838 fe 48		        cp 'H' 
183a ca d5 18		        jp z, .monhelp 
183d fe 44			cp 'D'		; dump 
183f ca 08 19			jp z, .mondump	 
1842 fe 43			cp 'C'		; dump 
1844 ca 22 19			jp z, .moncdump	 
1847 fe 4d			cp 'M'		; dump 
1849 ca 63 18			jp z, .moneditstart 
184c fe 55			cp 'U'		; dump 
184e ca 6f 18			jp z, .monedit	 
1851 fe 47			cp 'G'		; dump 
1853 ca fe 18			jp z, .monjump 
1856 fe 42			cp 'B'		; forth breakpoint 
1858 cc 63 14			call z, break_point_state 
185b fe 51			cp 'Q'		; dump 
185d c8				ret z	 
185e			 
185e			 
185e				; TODO "S" to access symbol by name and not need the address 
185e				; TODO "F" to find a string in memory 
185e			 
185e c3 08 18			jp monitor 
1861			 
1861 .. 00		.monprompt: db ">", 0 
1863			 
1863			.moneditstart: 
1863				; get starting address 
1863			 
1863 21 b8 e4			ld hl,os_input+2 
1866 cd 93 10			call get_word_hl 
1869			 
1869 22 db e5			ld (os_cur_ptr),hl	 
186c			 
186c c3 08 18			jp monitor 
186f			 
186f			.monedit: 
186f				; get byte to load 
186f			 
186f 21 b8 e4			ld hl,os_input+2 
1872 cd 33 10			call get_byte 
1875			 
1875				; get address to update 
1875 2a db e5			ld hl, (os_cur_ptr) 
1878			 
1878				; update byte 
1878			 
1878 77				ld (hl), a 
1879			 
1879				; move to next address and save it 
1879			 
1879 23				inc hl 
187a 22 db e5			ld (os_cur_ptr),hl	 
187d			 
187d c3 08 18			jp monitor 
1880			 
1880			 
1880 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1894 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
18b0 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
18ce .. 00		.monhelptext4:  db "Q-Quit",0 
18d5			        
18d5			.monhelp: 
18d5 3e 00			ld a, display_row_1 
18d7 11 80 18		        ld de, .monhelptext1 
18da			 
18da cd c9 0b			call str_at_display 
18dd 3e 28			ld a, display_row_2 
18df 11 94 18		        ld de, .monhelptext2 
18e2					 
18e2 cd c9 0b			call str_at_display 
18e5 3e 50			ld a, display_row_3 
18e7 11 b0 18		        ld de, .monhelptext3 
18ea					 
18ea cd c9 0b			call str_at_display 
18ed 3e 78			ld a, display_row_4 
18ef 11 ce 18		        ld de, .monhelptext4 
18f2 cd c9 0b			call str_at_display 
18f5			 
18f5 cd d9 0b			call update_display		 
18f8			 
18f8 cd 4a 1a			call next_page_prompt 
18fb c3 08 18			jp monitor 
18fe			 
18fe			.monjump:    
18fe 21 b8 e4			ld hl,os_input+2 
1901 cd 93 10			call get_word_hl 
1904			 
1904 e9				jp (hl) 
1905 c3 08 18			jp monitor 
1908			 
1908			.mondump:    
1908 21 b8 e4			ld hl,os_input+2 
190b cd 93 10			call get_word_hl 
190e			 
190e 22 db e5			ld (os_cur_ptr),hl	 
1911 cd 56 19			call dumpcont 
1914 3e 78			ld a, display_row_4 
1916 11 b4 17			ld de, endprog 
1919			 
1919 cd d9 0b			call update_display		 
191c			 
191c cd 4a 1a			call next_page_prompt 
191f c3 08 18			jp monitor 
1922			.moncdump: 
1922 cd 56 19			call dumpcont 
1925 3e 78			ld a, display_row_4 
1927 11 b4 17			ld de, endprog 
192a			 
192a cd d9 0b			call update_display		 
192d			 
192d cd 4a 1a			call next_page_prompt 
1930 c3 08 18			jp monitor 
1933			 
1933			 
1933			; TODO symbol access  
1933			 
1933			.symbols:     ;; A list of symbols that can be called up  
1933 a8 ed			dw display_fb0 
1935 .. 00			db "fb0",0  
1939 71 ea		     	dw store_page 
193b .. 00			db "store_page",0 
1946			 
1946			 
1946			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1946			 
1946 3a b9 e2			ld a,(scratch+1) 
1949 fe 00			cp 0 
194b 28 09			jr z, dumpcont 
194d			 
194d				; no, not a null term line so has an address to work out.... 
194d			 
194d 21 ba e2			ld hl,scratch+2 
1950 cd 93 10			call get_word_hl 
1953			 
1953 22 db e5			ld (os_cur_ptr),hl	 
1956			 
1956			 
1956			 
1956			dumpcont: 
1956			 
1956				; dump bytes at ptr 
1956			 
1956			 
1956 3e 00			ld a, display_row_1 
1958 2a c3 eb			ld hl, (display_fb_active) 
195b cd e1 0d			call addatohl 
195e cd 86 19			call .dumpbyterow 
1961			 
1961 3e 28			ld a, display_row_2 
1963 2a c3 eb			ld hl, (display_fb_active) 
1966 cd e1 0d			call addatohl 
1969 cd 86 19			call .dumpbyterow 
196c			 
196c			 
196c 3e 50			ld a, display_row_3 
196e 2a c3 eb			ld hl, (display_fb_active) 
1971 cd e1 0d			call addatohl 
1974 cd 86 19			call .dumpbyterow 
1977			 
1977 3e 78			ld a, display_row_4 
1979 2a c3 eb			ld hl, (display_fb_active) 
197c cd e1 0d			call addatohl 
197f cd 86 19			call .dumpbyterow 
1982			 
1982 cd d9 0b			call update_display 
1985			;		jp cli 
1985 c9				ret 
1986			 
1986			.dumpbyterow: 
1986			 
1986				;push af 
1986			 
1986 e5				push hl 
1987			 
1987				; calc where to poke the ascii 
1987			if display_cols == 20 
1987				ld a, 16 
1987			else 
1987 3e 1f			ld a, 31 
1989			endif 
1989			 
1989 cd e1 0d			call addatohl 
198c 22 bd e5			ld (os_word_scratch),hl  		; save pos for later 
198f			 
198f			 
198f			; display decoding address 
198f 2a db e5		   	ld hl,(os_cur_ptr) 
1992			 
1992 7c				ld a,h 
1993 e1				pop hl 
1994 e5				push hl 
1995			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1995 cd dd 0f			call hexout 
1998 2a db e5		   	ld hl,(os_cur_ptr) 
199b			 
199b 7d				ld a,l 
199c e1				pop hl 
199d 23				inc hl 
199e 23				inc hl 
199f e5				push hl 
19a0			;	ld hl, os_word_scratch+2 
19a0 cd dd 0f			call hexout 
19a3 e1				pop hl 
19a4 23				inc hl 
19a5 23				inc hl 
19a6				;ld hl, os_word_scratch+4 
19a6			;	ld a, ':' 
19a6 36 3a			ld (hl),':' 
19a8 23				inc hl 
19a9				;ld a, 0 
19a9				;ld (hl),a 
19a9				;ld de, os_word_scratch 
19a9				;pop af 
19a9				;push af 
19a9			;		ld a, display_row_2 
19a9			;		call str_at_display 
19a9			;		call update_display 
19a9			 
19a9			 
19a9			;pop af 
19a9			;	add 5 
19a9			 
19a9			if display_cols == 20 
19a9				ld b, 4 
19a9			else 
19a9 06 08			ld b, 8 
19ab			endif	 
19ab			 
19ab			.dumpbyte: 
19ab c5				push bc 
19ac e5				push hl 
19ad			 
19ad			 
19ad 2a db e5		   	ld hl,(os_cur_ptr) 
19b0 7e					ld a,(hl) 
19b1			 
19b1					; poke the ascii to display 
19b1 2a bd e5				ld hl,(os_word_scratch) 
19b4 77					ld (hl),a 
19b5 23					inc hl 
19b6 22 bd e5				ld (os_word_scratch),hl 
19b9			 
19b9					 
19b9			 
19b9			 
19b9 e1					pop hl 
19ba e5					push hl 
19bb			 
19bb cd dd 0f				call hexout 
19be			 
19be					 
19be 2a db e5		   	ld hl,(os_cur_ptr) 
19c1 23				inc hl 
19c2 22 db e5		   	ld (os_cur_ptr),hl 
19c5			 
19c5 e1					pop hl 
19c6 23					inc hl 
19c7 23					inc hl 
19c8 23					inc hl 
19c9			 
19c9			 
19c9			 
19c9					;ld a,0 
19c9					;ld (os_word_scratch+2),a 
19c9					;pop af 
19c9					;push af 
19c9			 
19c9					;ld de, os_word_scratch 
19c9					;call str_at_display 
19c9			;		call update_display 
19c9			;		pop af 
19c9 c1					pop bc 
19ca c6 03				add 3 
19cc 10 dd			djnz .dumpbyte 
19ce			 
19ce				 
19ce			 
19ce c9				ret 
19cf			 
19cf			jump:	 
19cf			 
19cf 21 ba e2			ld hl,scratch+2 
19d2 cd 93 10			call get_word_hl 
19d5				;ld hl,(scratch+2) 
19d5				;call fourehexhl 
19d5			 
19d5 22 db e5			ld (os_cur_ptr),hl	 
19d8			 
19d8 e9				jp (hl) 
19d9			 
19d9			 
19d9			 
19d9			; TODO implement a basic monitor mode to start with 
19d9			 
19d9			 
19d9			 
19d9			 
19d9			 
19d9			 
19d9			 
19d9			 
19d9			 
19d9			; testing and demo code during development 
19d9			 
19d9			 
19d9 .. 00		str1: db "Enter some text...",0 
19ec .. 00		clear: db "                    ",0 
1a01			 
1a01			demo: 
1a01			 
1a01			 
1a01			 
1a01			;	call update_display 
1a01			 
1a01				; init scratch input area for testing 
1a01 21 b8 e2			ld hl, scratch	 
1a04			;	ld a,0 
1a04 36 00			ld (hl),0 
1a06			 
1a06			 
1a06 3e 28		            LD   A, display_row_2 
1a08			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a08 11 d9 19		            LD   DE, str1 
1a0b cd c9 0b			call str_at_display 
1a0e			 
1a0e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a0e			cloop:	 
1a0e 3e 50		            LD   A, display_row_3 
1a10			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a10 11 ec 19		            LD   DE, clear 
1a13			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1a13 cd c9 0b				call str_at_display 
1a16 3e 78			ld a, display_row_4 
1a18 11 46 1a			ld de, prompt 
1a1b			 
1a1b cd c9 0b				call str_at_display 
1a1e cd d9 0b			call update_display 
1a21			 
1a21 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a23 16 0a			ld d, 10 
1a25 21 b8 e2			ld hl, scratch	 
1a28 cd 0e 0e			call input_str 
1a2b			 
1a2b			;	call clear_display 
1a2b			;'	call update_display 
1a2b			 
1a2b 3e 00		            LD   A, display_row_1 
1a2d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a2d 11 ec 19		            LD   DE, clear 
1a30 cd c9 0b				call str_at_display 
1a33			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a33 3e 00		            LD   A, display_row_1 
1a35			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a35 11 b8 e2		            LD   DE, scratch 
1a38			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a38 cd c9 0b				call str_at_display 
1a3b cd d9 0b			call update_display 
1a3e			 
1a3e			;		ld a,0 
1a3e 21 b8 e2			ld hl, scratch 
1a41 36 00			ld (hl),0 
1a43			 
1a43			;	nop 
1a43 c3 0e 1a			jp cloop 
1a46			 
1a46			 
1a46			 
1a46			; OS Prompt 
1a46			 
1a46 .. 00		prompt: db ">",0 
1a48 .. 00		endprg: db "?",0 
1a4a			 
1a4a			 
1a4a			; handy next page prompt 
1a4a			next_page_prompt: 
1a4a e5				push hl 
1a4b d5				push de 
1a4c f5				push af 
1a4d c5				push bc 
1a4e			 
1a4e 3e 9f			ld a,display_row_4 + display_cols - 1 
1a50 11 48 1a		        ld de, endprg 
1a53 cd c9 0b			call str_at_display 
1a56 cd d9 0b			call update_display 
1a59 cd a8 65			call cin_wait 
1a5c c1				pop bc 
1a5d f1				pop af 
1a5e d1				pop de 
1a5f e1				pop hl 
1a60			 
1a60			 
1a60 c9				ret 
1a61			 
1a61			 
1a61			; forth parser 
1a61			 
1a61			; My forth kernel 
1a61			include "forth_kernel.asm" 
1a61			; 
1a61			; kernel to the forth OS 
1a61			 
1a61			DS_TYPE_STR: equ 1     ; string type 
1a61			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1a61			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1a61			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
1a61			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1a61			 
1a61			FORTH_PARSEV1: equ 0 
1a61			FORTH_PARSEV2: equ 0 
1a61			FORTH_PARSEV3: equ 0 
1a61			FORTH_PARSEV4: equ 0 
1a61			FORTH_PARSEV5: equ 0 
1a61			FORTH_PARSEV6: equ 1 
1a61			 
1a61			;if FORTH_PARSEV5 
1a61			;	FORTH_END_BUFFER: equ 0 
1a61			;else 
1a61			FORTH_END_BUFFER: equ 127 
1a61			;endif 
1a61			 
1a61			FORTH_TRUE: equ 1 
1a61			FORTH_FALSE: equ 0 
1a61			 
1a61			if FORTH_PARSEV4 
1a61			include "forth_stackops.asm" 
1a61			endif 
1a61			 
1a61			if FORTH_PARSEV5 
1a61			include "forth_stackopsv5.asm" 
1a61			endif 
1a61			 
1a61			if FORTH_PARSEV6 
1a61			include "forth_stackopsv5.asm" 
1a61			 
1a61			; Stack operations for v5 parser on wards 
1a61			; * DATA stack 
1a61			; * LOOP stack 
1a61			; * RETURN stack 
1a61			 
1a61			 
1a61			 
1a61			FORTH_CHK_DSP_UNDER: macro 
1a61				push hl 
1a61				push de 
1a61				ld hl,(cli_data_sp) 
1a61				ld de, cli_data_stack 
1a61				call cmp16 
1a61				jp c, fault_dsp_under 
1a61				pop de 
1a61				pop hl 
1a61				endm 
1a61			 
1a61			 
1a61			FORTH_CHK_RSP_UNDER: macro 
1a61				push hl 
1a61				push de 
1a61				ld hl,(cli_ret_sp) 
1a61				ld de, cli_ret_stack 
1a61				call cmp16 
1a61				jp c, fault_rsp_under 
1a61				pop de 
1a61				pop hl 
1a61				endm 
1a61			 
1a61			FORTH_CHK_LOOP_UNDER: macro 
1a61				push hl 
1a61				push de 
1a61				ld hl,(cli_loop_sp) 
1a61				ld de, cli_loop_stack 
1a61				call cmp16 
1a61				jp c, fault_loop_under 
1a61				pop de 
1a61				pop hl 
1a61				endm 
1a61			 
1a61			FORTH_ERR_TOS_NOTSTR: macro 
1a61				; TOSO might need more for checks when used 
1a61				push af 
1a61				ld a,(hl) 
1a61				cp DS_TYPE_STR 
1a61				jp nz, type_faultn   
1a61				pop af 
1a61				endm 
1a61			 
1a61			FORTH_ERR_TOS_NOTNUM: macro 
1a61				push af 
1a61				ld a,(hl) 
1a61				cp DS_TYPE_INUM 
1a61				jp nz, type_faultn   
1a61				pop af 
1a61				endm 
1a61			 
1a61			 
1a61			; increase data stack pointer and save hl to it 
1a61				 
1a61			FORTH_DSP_NEXT: macro 
1a61				call macro_forth_dsp_next 
1a61				endm 
1a61			 
1a61			 
1a61			macro_forth_dsp_next: 
1a61				if DEBUG_FORTH_STACK_GUARD 
1a61 cd ce 61				call check_stacks 
1a64				endif 
1a64 e5				push hl 
1a65 d5				push de 
1a66 eb				ex de,hl 
1a67 2a e5 e9			ld hl,(cli_data_sp) 
1a6a 23				inc hl 
1a6b 23				inc hl 
1a6c			 
1a6c			; PARSEV5 
1a6c 23				inc hl 
1a6d 22 e5 e9			ld (cli_data_sp),hl 
1a70 73				ld (hl), e 
1a71 23				inc hl 
1a72 72				ld (hl), d 
1a73 d1				pop de 
1a74 e1				pop hl 
1a75				if DEBUG_FORTH_STACK_GUARD 
1a75 cd ce 61				call check_stacks 
1a78				endif 
1a78 c9				ret 
1a79			 
1a79			 
1a79			; increase ret stack pointer and save hl to it 
1a79				 
1a79			FORTH_RSP_NEXT: macro 
1a79				call macro_forth_rsp_next 
1a79				endm 
1a79			 
1a79			macro_forth_rsp_next: 
1a79				if DEBUG_FORTH_STACK_GUARD 
1a79 cd ce 61				call check_stacks 
1a7c				endif 
1a7c e5				push hl 
1a7d d5				push de 
1a7e eb				ex de,hl 
1a7f 2a e9 e9			ld hl,(cli_ret_sp) 
1a82 23				inc hl 
1a83 23				inc hl 
1a84 22 e9 e9			ld (cli_ret_sp),hl 
1a87 73				ld (hl), e 
1a88 23				inc hl 
1a89 72				ld (hl), d 
1a8a d1				pop de 
1a8b e1				pop hl 
1a8c				if DEBUG_FORTH_STACK_GUARD 
1a8c cd ce 61				call check_stacks 
1a8f				endif 
1a8f c9				ret 
1a90			 
1a90			; get current ret stack pointer and save to hl  
1a90				 
1a90			FORTH_RSP_TOS: macro 
1a90				call macro_forth_rsp_tos 
1a90				endm 
1a90			 
1a90			macro_forth_rsp_tos: 
1a90				;push de 
1a90 2a e9 e9			ld hl,(cli_ret_sp) 
1a93 cd cb 1a			call loadhlptrtohl 
1a96				;ld e, (hl) 
1a96				;inc hl 
1a96				;ld d, (hl) 
1a96				;ex de, hl 
1a96					if DEBUG_FORTH_WORDS 
1a96			;			DMARK "RST" 
1a96						CALLMONITOR 
1a96 cd 6f ee			call debug_vector  
1a99				endm  
# End of macro CALLMONITOR
1a99					endif 
1a99				;pop de 
1a99 c9				ret 
1a9a			 
1a9a			; pop ret stack pointer 
1a9a				 
1a9a			FORTH_RSP_POP: macro 
1a9a				call macro_forth_rsp_pop 
1a9a				endm 
1a9a			 
1a9a			 
1a9a			macro_forth_rsp_pop: 
1a9a				if DEBUG_FORTH_STACK_GUARD 
1a9a			;		DMARK "RPP" 
1a9a cd ce 61				call check_stacks 
1a9d					FORTH_CHK_RSP_UNDER 
1a9d e5				push hl 
1a9e d5				push de 
1a9f 2a e9 e9			ld hl,(cli_ret_sp) 
1aa2 11 a3 e9			ld de, cli_ret_stack 
1aa5 cd ff 0d			call cmp16 
1aa8 da e5 62			jp c, fault_rsp_under 
1aab d1				pop de 
1aac e1				pop hl 
1aad				endm 
# End of macro FORTH_CHK_RSP_UNDER
1aad				endif 
1aad e5				push hl 
1aae 2a e9 e9			ld hl,(cli_ret_sp) 
1ab1			 
1ab1			 
1ab1				if FORTH_ENABLE_FREE 
1ab1			 
1ab1					; get pointer 
1ab1			 
1ab1					push de 
1ab1					push hl 
1ab1			 
1ab1					ld e, (hl) 
1ab1					inc hl 
1ab1					ld d, (hl) 
1ab1			 
1ab1					ex de, hl 
1ab1					call free 
1ab1			 
1ab1					pop hl 
1ab1					pop de 
1ab1			 
1ab1			 
1ab1				endif 
1ab1			 
1ab1			 
1ab1 2b				dec hl 
1ab2 2b				dec hl 
1ab3 22 e9 e9			ld (cli_ret_sp), hl 
1ab6				; do stack underflow checks 
1ab6 e1				pop hl 
1ab7				if DEBUG_FORTH_STACK_GUARD 
1ab7 cd ce 61				call check_stacks 
1aba					FORTH_CHK_RSP_UNDER 
1aba e5				push hl 
1abb d5				push de 
1abc 2a e9 e9			ld hl,(cli_ret_sp) 
1abf 11 a3 e9			ld de, cli_ret_stack 
1ac2 cd ff 0d			call cmp16 
1ac5 da e5 62			jp c, fault_rsp_under 
1ac8 d1				pop de 
1ac9 e1				pop hl 
1aca				endm 
# End of macro FORTH_CHK_RSP_UNDER
1aca				endif 
1aca c9				ret 
1acb			 
1acb			 
1acb			 
1acb			; routine to load word pointed to by hl into hl 
1acb			 
1acb			loadhlptrtohl: 
1acb			 
1acb d5				push de 
1acc 5e				ld e, (hl) 
1acd 23				inc hl 
1ace 56				ld d, (hl) 
1acf eb				ex de, hl 
1ad0 d1				pop de 
1ad1			 
1ad1 c9				ret 
1ad2			 
1ad2			 
1ad2			 
1ad2			 
1ad2			 
1ad2			; push a number held in HL onto the data stack 
1ad2			; entry point for pushing a value when already in hl used in function above 
1ad2			 
1ad2			forth_push_numhl: 
1ad2			 
1ad2 e5				push hl    ; save value to push 
1ad3			 
1ad3			if DEBUG_FORTH_PUSH 
1ad3				; see if disabled 
1ad3			 
1ad3			 
1ad3 f5				push af 
1ad4 3a 6f ee			ld a,(debug_vector) 
1ad7 fe c9			cp $c9   ; ret 
1ad9			;	ld a, (os_view_disable) 
1ad9			;	cp '*' 
1ad9 28 33			jr z, .pskip2 
1adb e5				push hl 
1adc e5			push hl 
1add cd b7 0b			call clear_display 
1ae0 e1			pop hl 
1ae1 7c				ld a,h 
1ae2 21 bd e5			ld hl, os_word_scratch 
1ae5 cd dd 0f			call hexout 
1ae8 e1				pop hl 
1ae9 7d				ld a,l 
1aea 21 bf e5			ld hl, os_word_scratch+2 
1aed cd dd 0f			call hexout 
1af0			 
1af0 21 c1 e5			ld hl, os_word_scratch+4 
1af3			;	ld a,0 
1af3 36 00			ld (hl),0 
1af5 11 bd e5			ld de,os_word_scratch 
1af8 3e 28				ld a, display_row_2 
1afa cd c9 0b				call str_at_display 
1afd 11 cb 53			ld de, .push_num 
1b00 3e 00			ld a, display_row_1 
1b02			 
1b02 cd c9 0b				call str_at_display 
1b05			 
1b05			 
1b05 cd d9 0b			call update_display 
1b08 cd f0 0a			call delay1s 
1b0b cd f0 0a			call delay1s 
1b0e			.pskip2:  
1b0e			 
1b0e f1				pop af 
1b0f			endif	 
1b0f			 
1b0f			 
1b0f				FORTH_DSP_NEXT 
1b0f cd 61 1a			call macro_forth_dsp_next 
1b12				endm 
# End of macro FORTH_DSP_NEXT
1b12			 
1b12 2a e5 e9			ld hl, (cli_data_sp) 
1b15			 
1b15				; save item type 
1b15			;	ld a,  DS_TYPE_INUM 
1b15 36 02			ld (hl), DS_TYPE_INUM 
1b17 23				inc hl 
1b18			 
1b18				; get word off stack 
1b18 d1				pop de 
1b19				;ld a,e 
1b19 73				ld (hl), e 
1b1a 23				inc hl 
1b1b			;	ld a,d 
1b1b 72				ld (hl), d 
1b1c			 
1b1c			if DEBUG_FORTH_PUSH 
1b1c 2b				dec hl 
1b1d 2b				dec hl 
1b1e 2b				dec hl 
1b1f						DMARK "PH5" 
1b1f f5				push af  
1b20 3a 34 1b			ld a, (.dmark)  
1b23 32 62 ee			ld (debug_mark),a  
1b26 3a 35 1b			ld a, (.dmark+1)  
1b29 32 63 ee			ld (debug_mark+1),a  
1b2c 3a 36 1b			ld a, (.dmark+2)  
1b2f 32 64 ee			ld (debug_mark+2),a  
1b32 18 03			jr .pastdmark  
1b34 ..			.dmark: db "PH5"  
1b37 f1			.pastdmark: pop af  
1b38			endm  
# End of macro DMARK
1b38				CALLMONITOR 
1b38 cd 6f ee			call debug_vector  
1b3b				endm  
# End of macro CALLMONITOR
1b3b			endif	 
1b3b			 
1b3b c9				ret 
1b3c			 
1b3c			 
1b3c			; Push a string to stack pointed to by hl 
1b3c			 
1b3c			forth_push_str: 
1b3c			 
1b3c			if DEBUG_FORTH_PUSH 
1b3c						DMARK "PSQ" 
1b3c f5				push af  
1b3d 3a 51 1b			ld a, (.dmark)  
1b40 32 62 ee			ld (debug_mark),a  
1b43 3a 52 1b			ld a, (.dmark+1)  
1b46 32 63 ee			ld (debug_mark+1),a  
1b49 3a 53 1b			ld a, (.dmark+2)  
1b4c 32 64 ee			ld (debug_mark+2),a  
1b4f 18 03			jr .pastdmark  
1b51 ..			.dmark: db "PSQ"  
1b54 f1			.pastdmark: pop af  
1b55			endm  
# End of macro DMARK
1b55				CALLMONITOR 
1b55 cd 6f ee			call debug_vector  
1b58				endm  
# End of macro CALLMONITOR
1b58			endif	 
1b58			 
1b58			 
1b58			    
1b58 e5				push hl 
1b59 e5				push hl 
1b5a			 
1b5a			;	ld a, 0   ; find end of string 
1b5a cd 39 11			call strlenz 
1b5d			if DEBUG_FORTH_PUSH 
1b5d						DMARK "PQ2" 
1b5d f5				push af  
1b5e 3a 72 1b			ld a, (.dmark)  
1b61 32 62 ee			ld (debug_mark),a  
1b64 3a 73 1b			ld a, (.dmark+1)  
1b67 32 63 ee			ld (debug_mark+1),a  
1b6a 3a 74 1b			ld a, (.dmark+2)  
1b6d 32 64 ee			ld (debug_mark+2),a  
1b70 18 03			jr .pastdmark  
1b72 ..			.dmark: db "PQ2"  
1b75 f1			.pastdmark: pop af  
1b76			endm  
# End of macro DMARK
1b76				CALLMONITOR 
1b76 cd 6f ee			call debug_vector  
1b79				endm  
# End of macro CALLMONITOR
1b79			endif	 
1b79 eb				ex de, hl 
1b7a e1				pop hl   ; get ptr to start of string 
1b7b			if DEBUG_FORTH_PUSH 
1b7b						DMARK "PQ3" 
1b7b f5				push af  
1b7c 3a 90 1b			ld a, (.dmark)  
1b7f 32 62 ee			ld (debug_mark),a  
1b82 3a 91 1b			ld a, (.dmark+1)  
1b85 32 63 ee			ld (debug_mark+1),a  
1b88 3a 92 1b			ld a, (.dmark+2)  
1b8b 32 64 ee			ld (debug_mark+2),a  
1b8e 18 03			jr .pastdmark  
1b90 ..			.dmark: db "PQ3"  
1b93 f1			.pastdmark: pop af  
1b94			endm  
# End of macro DMARK
1b94				CALLMONITOR 
1b94 cd 6f ee			call debug_vector  
1b97				endm  
# End of macro CALLMONITOR
1b97			endif	 
1b97 19				add hl,de 
1b98			if DEBUG_FORTH_PUSH 
1b98						DMARK "PQE" 
1b98 f5				push af  
1b99 3a ad 1b			ld a, (.dmark)  
1b9c 32 62 ee			ld (debug_mark),a  
1b9f 3a ae 1b			ld a, (.dmark+1)  
1ba2 32 63 ee			ld (debug_mark+1),a  
1ba5 3a af 1b			ld a, (.dmark+2)  
1ba8 32 64 ee			ld (debug_mark+2),a  
1bab 18 03			jr .pastdmark  
1bad ..			.dmark: db "PQE"  
1bb0 f1			.pastdmark: pop af  
1bb1			endm  
# End of macro DMARK
1bb1				CALLMONITOR 
1bb1 cd 6f ee			call debug_vector  
1bb4				endm  
# End of macro CALLMONITOR
1bb4			endif	 
1bb4			 
1bb4 2b				dec hl    ; see if there is an optional trailing double quote 
1bb5 7e				ld a,(hl) 
1bb6 fe 22			cp '"' 
1bb8 20 02			jr nz, .strnoq 
1bba			;	ld a, 0      ; get rid of double quote 
1bba 36 00			ld (hl), 0 
1bbc 23			.strnoq: inc hl 
1bbd			 
1bbd			;	ld a, 0 
1bbd 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
1bbf			 
1bbf 13				inc de ; add one for the type string 
1bc0 13				inc de ; add one for null term??? 
1bc1			 
1bc1				; tos is get string pointer again 
1bc1				; de contains space to allocate 
1bc1				 
1bc1 d5				push de 
1bc2			 
1bc2 eb				ex de, hl 
1bc3			 
1bc3				;push af 
1bc3			 
1bc3			if DEBUG_FORTH_PUSH 
1bc3						DMARK "PHm" 
1bc3 f5				push af  
1bc4 3a d8 1b			ld a, (.dmark)  
1bc7 32 62 ee			ld (debug_mark),a  
1bca 3a d9 1b			ld a, (.dmark+1)  
1bcd 32 63 ee			ld (debug_mark+1),a  
1bd0 3a da 1b			ld a, (.dmark+2)  
1bd3 32 64 ee			ld (debug_mark+2),a  
1bd6 18 03			jr .pastdmark  
1bd8 ..			.dmark: db "PHm"  
1bdb f1			.pastdmark: pop af  
1bdc			endm  
# End of macro DMARK
1bdc				CALLMONITOR 
1bdc cd 6f ee			call debug_vector  
1bdf				endm  
# End of macro CALLMONITOR
1bdf			endif	 
1bdf cd ad 11			call malloc	; on ret hl now contains allocated memory 
1be2				if DEBUG_FORTH_MALLOC_GUARD 
1be2 cc 23 54				call z,malloc_error 
1be5				endif 
1be5			 
1be5				 
1be5 c1				pop bc    ; get length 
1be6 d1				pop de   ;  get string start    
1be7			 
1be7				; hl has destination from malloc 
1be7			 
1be7 eb				ex de, hl    ; prep for ldir 
1be8			 
1be8 d5				push de   ; save malloc area for DSP later 
1be9				;push hl   ; save malloc area for DSP later 
1be9			 
1be9			if DEBUG_FORTH_PUSH 
1be9						DMARK "PHc" 
1be9 f5				push af  
1bea 3a fe 1b			ld a, (.dmark)  
1bed 32 62 ee			ld (debug_mark),a  
1bf0 3a ff 1b			ld a, (.dmark+1)  
1bf3 32 63 ee			ld (debug_mark+1),a  
1bf6 3a 00 1c			ld a, (.dmark+2)  
1bf9 32 64 ee			ld (debug_mark+2),a  
1bfc 18 03			jr .pastdmark  
1bfe ..			.dmark: db "PHc"  
1c01 f1			.pastdmark: pop af  
1c02			endm  
# End of macro DMARK
1c02				CALLMONITOR 
1c02 cd 6f ee			call debug_vector  
1c05				endm  
# End of macro CALLMONITOR
1c05			endif	 
1c05			 
1c05			 
1c05 ed b0			ldir 
1c07			 
1c07			 
1c07				; push malloc to data stack     macro?????  
1c07			 
1c07				FORTH_DSP_NEXT 
1c07 cd 61 1a			call macro_forth_dsp_next 
1c0a				endm 
# End of macro FORTH_DSP_NEXT
1c0a			 
1c0a				; save value and type 
1c0a			 
1c0a 2a e5 e9			ld hl, (cli_data_sp) 
1c0d			 
1c0d				; save item type 
1c0d			;	ld a,  DS_TYPE_STR 
1c0d 36 01			ld (hl), DS_TYPE_STR 
1c0f 23				inc hl 
1c10			 
1c10				; get malloc word off stack 
1c10 d1				pop de 
1c11 73				ld (hl), e 
1c12 23				inc hl 
1c13 72				ld (hl), d 
1c14			 
1c14			 
1c14			 
1c14			if DEBUG_FORTH_PUSH 
1c14 2a e5 e9			ld hl, (cli_data_sp) 
1c17						DMARK "PHS" 
1c17 f5				push af  
1c18 3a 2c 1c			ld a, (.dmark)  
1c1b 32 62 ee			ld (debug_mark),a  
1c1e 3a 2d 1c			ld a, (.dmark+1)  
1c21 32 63 ee			ld (debug_mark+1),a  
1c24 3a 2e 1c			ld a, (.dmark+2)  
1c27 32 64 ee			ld (debug_mark+2),a  
1c2a 18 03			jr .pastdmark  
1c2c ..			.dmark: db "PHS"  
1c2f f1			.pastdmark: pop af  
1c30			endm  
# End of macro DMARK
1c30				CALLMONITOR 
1c30 cd 6f ee			call debug_vector  
1c33				endm  
# End of macro CALLMONITOR
1c33			;	ex de,hl 
1c33			endif	 
1c33				; in case of spaces, skip the ptr past the copied string 
1c33				;pop af 
1c33				;ld (cli_origptr),hl 
1c33			 
1c33 c9				ret 
1c34			 
1c34			 
1c34			 
1c34			; TODO ascii push input onto stack given hl to start of input 
1c34			 
1c34			; identify type 
1c34			; if starts with a " then a string 
1c34			; otherwise it is a number 
1c34			;  
1c34			; if a string 
1c34			;     scan for ending " to get length of string to malloc for + 1 
1c34			;     malloc 
1c34			;     put pointer to string on stack first byte flags as string 
1c34			; 
1c34			; else a number 
1c34			;    look for number format identifier 
1c34			;    $xx hex 
1c34			;    %xxxxx bin 
1c34			;    xxxxx decimal 
1c34			;    convert number to 16bit word.  
1c34			;    malloc word + 1 with flag to identiy as num 
1c34			;    put pointer to number on stack 
1c34			;   
1c34			;  
1c34			  
1c34			forth_apush: 
1c34				; kernel push 
1c34			 
1c34			if DEBUG_FORTH_PUSH 
1c34						DMARK "PSH" 
1c34 f5				push af  
1c35 3a 49 1c			ld a, (.dmark)  
1c38 32 62 ee			ld (debug_mark),a  
1c3b 3a 4a 1c			ld a, (.dmark+1)  
1c3e 32 63 ee			ld (debug_mark+1),a  
1c41 3a 4b 1c			ld a, (.dmark+2)  
1c44 32 64 ee			ld (debug_mark+2),a  
1c47 18 03			jr .pastdmark  
1c49 ..			.dmark: db "PSH"  
1c4c f1			.pastdmark: pop af  
1c4d			endm  
# End of macro DMARK
1c4d				CALLMONITOR 
1c4d cd 6f ee			call debug_vector  
1c50				endm  
# End of macro CALLMONITOR
1c50			endif	 
1c50				; identify input type 
1c50			 
1c50 7e				ld a,(hl) 
1c51			 
1c51 fe 23			cp '#' 
1c53 ca 8b 1c			jp z, .fapdec 
1c56			 
1c56			 
1c56 fe 22			cp '"' 
1c58 28 0a			jr z, .fapstr 
1c5a fe 24			cp '$' 
1c5c ca 83 1c			jp z, .faphex 
1c5f fe 25			cp '%' 
1c61 ca 6c 1c			jp z, .fapbin 
1c64			;	cp 'b' 
1c64			;	jp z, .fabin 
1c64				; else decimal 
1c64			 
1c64				; TODO do decimal conversion 
1c64				; decimal is stored as a 16bit word 
1c64			 
1c64				; by default everything is a string if type is not detected 
1c64			.fapstr: ; 
1c64 fe 22			cp '"' 
1c66 20 01			jr nz, .strnoqu 
1c68 23				inc hl 
1c69			.strnoqu: 
1c69 c3 3c 1b			jp forth_push_str 
1c6c			 
1c6c			 
1c6c			 
1c6c			.fapbin:    ; push a binary string.  
1c6c 11 00 00			ld de, 0   ; hold a 16bit value 
1c6f			 
1c6f 23			.fapbinshift:	inc hl  
1c70 7e				ld a,(hl) 
1c71			;	cp 0     ; done scanning  
1c71 b7				or a 
1c72 28 0b			jr z, .fapbdone  	; got it in HL so push  
1c74			 
1c74				; left shift de 
1c74 eb				ex de, hl	 
1c75 29				add hl, hl 
1c76			 
1c76				; is 1 
1c76 fe 31			cp '1' 
1c78 20 02			jr nz, .binzero 
1c7a cb 4d			bit 1, l 
1c7c			.binzero: 
1c7c eb				ex de, hl	 ; save current de 
1c7d 18 f0			jr .fapbinshift 
1c7f			 
1c7f			.fapbdone: 
1c7f eb				ex de, hl 
1c80 c3 d2 1a			jp forth_push_numhl 
1c83			 
1c83			 
1c83			.faphex:   ; hex is always stored as a 16bit word 
1c83				; skip number prefix 
1c83 23				inc hl 
1c84				; turn ascii into number 
1c84 cd 93 10			call get_word_hl	; ret 16bit word in hl 
1c87			 
1c87 c3 d2 1a			jp forth_push_numhl 
1c8a			 
1c8a			;	 nop 
1c8a			 
1c8a			.fabin:   ; TODO bin conversion 
1c8a			 
1c8a			 
1c8a c9				ret 
1c8b			.fapdec:	 
1c8b				; string to dec conversion 
1c8b 23				inc hl 
1c8c eb				ex de, hl 
1c8d cd d0 10			call string_to_uint16 
1c90 c3 d2 1a			jp forth_push_numhl 
1c93 c9				ret 
1c94				 
1c94			;atoui_16: 
1c94			 
1c94			; get either a string ptr or a 16bit word from the data stack 
1c94			 
1c94			FORTH_DSP: macro 
1c94				call macro_forth_dsp 
1c94				endm 
1c94			 
1c94			macro_forth_dsp: 
1c94				; data stack pointer points to current word on tos 
1c94			 
1c94 2a e5 e9			ld hl,(cli_data_sp) 
1c97			 
1c97				if DEBUG_FORTH_PUSH 
1c97						DMARK "DSP" 
1c97 f5				push af  
1c98 3a ac 1c			ld a, (.dmark)  
1c9b 32 62 ee			ld (debug_mark),a  
1c9e 3a ad 1c			ld a, (.dmark+1)  
1ca1 32 63 ee			ld (debug_mark+1),a  
1ca4 3a ae 1c			ld a, (.dmark+2)  
1ca7 32 64 ee			ld (debug_mark+2),a  
1caa 18 03			jr .pastdmark  
1cac ..			.dmark: db "DSP"  
1caf f1			.pastdmark: pop af  
1cb0			endm  
# End of macro DMARK
1cb0			 
1cb0 cd 56 54				call display_data_sp 
1cb3				;call break_point_state 
1cb3				;rst 030h 
1cb3				CALLMONITOR 
1cb3 cd 6f ee			call debug_vector  
1cb6				endm  
# End of macro CALLMONITOR
1cb6				endif 
1cb6			 
1cb6 c9				ret 
1cb7			 
1cb7			; return hl to start of value on stack 
1cb7			 
1cb7			FORTH_DSP_VALUE: macro 
1cb7				call macro_forth_dsp_value 
1cb7				endm 
1cb7			 
1cb7			macro_forth_dsp_value: 
1cb7			 
1cb7				FORTH_DSP 
1cb7 cd 94 1c			call macro_forth_dsp 
1cba				endm 
# End of macro FORTH_DSP
1cba			 
1cba d5				push de 
1cbb			 
1cbb 23				inc hl ; skip type 
1cbc			 
1cbc 5e				ld e, (hl) 
1cbd 23				inc hl 
1cbe 56				ld d, (hl) 
1cbf eb				ex de,hl  
1cc0			 
1cc0 d1				pop de 
1cc1			 
1cc1 c9				ret 
1cc2			 
1cc2			; return hl to start of value to second item on stack 
1cc2			 
1cc2			FORTH_DSP_VALUEM1: macro 
1cc2				call macro_forth_dsp_value_m1 
1cc2				endm 
1cc2			 
1cc2			macro_forth_dsp_value_m1: 
1cc2			 
1cc2				FORTH_DSP 
1cc2 cd 94 1c			call macro_forth_dsp 
1cc5				endm 
# End of macro FORTH_DSP
1cc5			 
1cc5 2b				dec hl 
1cc6 2b				dec hl 
1cc7			;	dec hl 
1cc7			 
1cc7 d5				push de 
1cc8			 
1cc8 5e				ld e, (hl) 
1cc9 23				inc hl 
1cca 56				ld d, (hl) 
1ccb eb				ex de,hl  
1ccc			 
1ccc d1				pop de 
1ccd			 
1ccd c9				ret 
1cce			 
1cce				 
1cce			 
1cce			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1cce			 
1cce			FORTH_DSP_POP: macro 
1cce				call macro_forth_dsp_pop 
1cce				endm 
1cce			 
1cce			 
1cce			; get the tos data type 
1cce			 
1cce			FORTH_DSP_TYPE:   macro 
1cce			 
1cce				;FORTH_DSP_VALUE 
1cce				FORTH_DSP 
1cce				 
1cce				; hl points to value 
1cce				; check type 
1cce			 
1cce				ld a,(hl) 
1cce			 
1cce				endm 
1cce			 
1cce			; load the tos value into hl 
1cce			 
1cce			 
1cce			FORTH_DSP_VALUEHL:  macro 
1cce				call macro_dsp_valuehl 
1cce				endm 
1cce			 
1cce			 
1cce			 
1cce			macro_dsp_valuehl: 
1cce				FORTH_DSP_VALUE 
1cce cd b7 1c			call macro_forth_dsp_value 
1cd1				endm 
# End of macro FORTH_DSP_VALUE
1cd1			 
1cd1				;FORTH_ERR_TOS_NOTNUM 
1cd1			 
1cd1				;inc hl   ; skip type id 
1cd1			 
1cd1			;	push de 
1cd1			; 
1cd1			;	ld e, (hl) 
1cd1			;	inc hl 
1cd1			;	ld d, (hl) 
1cd1			;	ex de,hl  
1cd1			 
1cd1			;	pop de 
1cd1			 
1cd1				if DEBUG_FORTH_PUSH 
1cd1						DMARK "DVL" 
1cd1 f5				push af  
1cd2 3a e6 1c			ld a, (.dmark)  
1cd5 32 62 ee			ld (debug_mark),a  
1cd8 3a e7 1c			ld a, (.dmark+1)  
1cdb 32 63 ee			ld (debug_mark+1),a  
1cde 3a e8 1c			ld a, (.dmark+2)  
1ce1 32 64 ee			ld (debug_mark+2),a  
1ce4 18 03			jr .pastdmark  
1ce6 ..			.dmark: db "DVL"  
1ce9 f1			.pastdmark: pop af  
1cea			endm  
# End of macro DMARK
1cea				CALLMONITOR 
1cea cd 6f ee			call debug_vector  
1ced				endm  
# End of macro CALLMONITOR
1ced				endif 
1ced c9				ret 
1cee			 
1cee			forth_apushstrhl:      
1cee				; push of string requires use of cli_origptr 
1cee				; bodge use 
1cee			 
1cee				; get current cli_origptr, save, update with temp pointer  
1cee ed 5b 35 ea		ld de, (cli_origptr) 
1cf2 22 35 ea			ld (cli_origptr), hl 
1cf5 d5				push de 
1cf6 cd 34 1c			call forth_apush 
1cf9 d1				pop de 
1cfa ed 53 35 ea		ld (cli_origptr), de 
1cfe c9			        ret	 
1cff			 
1cff			 
1cff			; increase loop stack pointer and save hl to it 
1cff				 
1cff			FORTH_LOOP_NEXT: macro 
1cff				call macro_forth_loop_next 
1cff				;nop 
1cff				endm 
1cff			 
1cff			macro_forth_loop_next: 
1cff				if DEBUG_FORTH_STACK_GUARD 
1cff cd ce 61				call check_stacks 
1d02				endif 
1d02 e5				push hl 
1d03 d5				push de 
1d04 eb				ex de,hl 
1d05 2a e7 e9			ld hl,(cli_loop_sp) 
1d08 23				inc hl 
1d09 23				inc hl 
1d0a					if DEBUG_FORTH_WORDS 
1d0a						DMARK "LNX" 
1d0a f5				push af  
1d0b 3a 1f 1d			ld a, (.dmark)  
1d0e 32 62 ee			ld (debug_mark),a  
1d11 3a 20 1d			ld a, (.dmark+1)  
1d14 32 63 ee			ld (debug_mark+1),a  
1d17 3a 21 1d			ld a, (.dmark+2)  
1d1a 32 64 ee			ld (debug_mark+2),a  
1d1d 18 03			jr .pastdmark  
1d1f ..			.dmark: db "LNX"  
1d22 f1			.pastdmark: pop af  
1d23			endm  
# End of macro DMARK
1d23						CALLMONITOR 
1d23 cd 6f ee			call debug_vector  
1d26				endm  
# End of macro CALLMONITOR
1d26					endif 
1d26 22 e7 e9			ld (cli_loop_sp),hl 
1d29 73				ld (hl), e 
1d2a 23				inc hl 
1d2b 72				ld (hl), d 
1d2c d1				pop de    ; been reversed so save a swap on restore 
1d2d e1				pop hl 
1d2e				if DEBUG_FORTH_STACK_GUARD 
1d2e cd ce 61				call check_stacks 
1d31				endif 
1d31 c9				ret 
1d32			 
1d32			; get current ret stack pointer and save to hl  
1d32				 
1d32			FORTH_LOOP_TOS: macro 
1d32				call macro_forth_loop_tos 
1d32				endm 
1d32			 
1d32			macro_forth_loop_tos: 
1d32 d5				push de 
1d33 2a e7 e9			ld hl,(cli_loop_sp) 
1d36 5e				ld e, (hl) 
1d37 23				inc hl 
1d38 56				ld d, (hl) 
1d39 eb				ex de, hl 
1d3a d1				pop de 
1d3b c9				ret 
1d3c			 
1d3c			; pop loop stack pointer 
1d3c				 
1d3c			FORTH_LOOP_POP: macro 
1d3c				call macro_forth_loop_pop 
1d3c				endm 
1d3c			 
1d3c			 
1d3c			macro_forth_loop_pop: 
1d3c				if DEBUG_FORTH_STACK_GUARD 
1d3c					DMARK "LPP" 
1d3c f5				push af  
1d3d 3a 51 1d			ld a, (.dmark)  
1d40 32 62 ee			ld (debug_mark),a  
1d43 3a 52 1d			ld a, (.dmark+1)  
1d46 32 63 ee			ld (debug_mark+1),a  
1d49 3a 53 1d			ld a, (.dmark+2)  
1d4c 32 64 ee			ld (debug_mark+2),a  
1d4f 18 03			jr .pastdmark  
1d51 ..			.dmark: db "LPP"  
1d54 f1			.pastdmark: pop af  
1d55			endm  
# End of macro DMARK
1d55 cd ce 61				call check_stacks 
1d58					FORTH_CHK_LOOP_UNDER 
1d58 e5				push hl 
1d59 d5				push de 
1d5a 2a e7 e9			ld hl,(cli_loop_sp) 
1d5d 11 21 e9			ld de, cli_loop_stack 
1d60 cd ff 0d			call cmp16 
1d63 da eb 62			jp c, fault_loop_under 
1d66 d1				pop de 
1d67 e1				pop hl 
1d68				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d68				endif 
1d68 e5				push hl 
1d69 2a e7 e9			ld hl,(cli_loop_sp) 
1d6c 2b				dec hl 
1d6d 2b				dec hl 
1d6e 22 e7 e9			ld (cli_loop_sp), hl 
1d71				; TODO do stack underflow checks 
1d71 e1				pop hl 
1d72				if DEBUG_FORTH_STACK_GUARD 
1d72 cd ce 61				call check_stacks 
1d75					FORTH_CHK_LOOP_UNDER 
1d75 e5				push hl 
1d76 d5				push de 
1d77 2a e7 e9			ld hl,(cli_loop_sp) 
1d7a 11 21 e9			ld de, cli_loop_stack 
1d7d cd ff 0d			call cmp16 
1d80 da eb 62			jp c, fault_loop_under 
1d83 d1				pop de 
1d84 e1				pop hl 
1d85				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d85				endif 
1d85 c9				ret 
1d86			 
1d86			macro_forth_dsp_pop: 
1d86			 
1d86 e5				push hl 
1d87			 
1d87				; release malloc data 
1d87			 
1d87				if DEBUG_FORTH_STACK_GUARD 
1d87 cd ce 61				call check_stacks 
1d8a					FORTH_CHK_DSP_UNDER 
1d8a e5				push hl 
1d8b d5				push de 
1d8c 2a e5 e9			ld hl,(cli_data_sp) 
1d8f 11 1f e8			ld de, cli_data_stack 
1d92 cd ff 0d			call cmp16 
1d95 da df 62			jp c, fault_dsp_under 
1d98 d1				pop de 
1d99 e1				pop hl 
1d9a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1d9a				endif 
1d9a				;ld hl,(cli_data_sp) 
1d9a			if DEBUG_FORTH_DOT 
1d9a				DMARK "DPP" 
1d9a f5				push af  
1d9b 3a af 1d			ld a, (.dmark)  
1d9e 32 62 ee			ld (debug_mark),a  
1da1 3a b0 1d			ld a, (.dmark+1)  
1da4 32 63 ee			ld (debug_mark+1),a  
1da7 3a b1 1d			ld a, (.dmark+2)  
1daa 32 64 ee			ld (debug_mark+2),a  
1dad 18 03			jr .pastdmark  
1daf ..			.dmark: db "DPP"  
1db2 f1			.pastdmark: pop af  
1db3			endm  
# End of macro DMARK
1db3				CALLMONITOR 
1db3 cd 6f ee			call debug_vector  
1db6				endm  
# End of macro CALLMONITOR
1db6			endif	 
1db6			 
1db6			 
1db6			if FORTH_ENABLE_DSPPOPFREE 
1db6			 
1db6				FORTH_DSP 
1db6 cd 94 1c			call macro_forth_dsp 
1db9				endm 
# End of macro FORTH_DSP
1db9			 
1db9 7e				ld a, (hl) 
1dba fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
1dbc 20 22			jr nz, .skippopfree 
1dbe			 
1dbe				FORTH_DSP_VALUEHL 
1dbe cd ce 1c			call macro_dsp_valuehl 
1dc1				endm 
# End of macro FORTH_DSP_VALUEHL
1dc1			;	nop 
1dc1			if DEBUG_FORTH_DOT 
1dc1				DMARK "DPf" 
1dc1 f5				push af  
1dc2 3a d6 1d			ld a, (.dmark)  
1dc5 32 62 ee			ld (debug_mark),a  
1dc8 3a d7 1d			ld a, (.dmark+1)  
1dcb 32 63 ee			ld (debug_mark+1),a  
1dce 3a d8 1d			ld a, (.dmark+2)  
1dd1 32 64 ee			ld (debug_mark+2),a  
1dd4 18 03			jr .pastdmark  
1dd6 ..			.dmark: db "DPf"  
1dd9 f1			.pastdmark: pop af  
1dda			endm  
# End of macro DMARK
1dda				CALLMONITOR 
1dda cd 6f ee			call debug_vector  
1ddd				endm  
# End of macro CALLMONITOR
1ddd			endif	 
1ddd cd 77 12			call free 
1de0			.skippopfree: 
1de0				 
1de0			 
1de0			endif 
1de0			 
1de0			if DEBUG_FORTH_DOT_KEY 
1de0				DMARK "DP2" 
1de0				CALLMONITOR 
1de0			endif	 
1de0			 
1de0				; move pointer down 
1de0			 
1de0 2a e5 e9			ld hl,(cli_data_sp) 
1de3 2b				dec hl 
1de4 2b				dec hl 
1de5			; PARSEV5 
1de5 2b				dec hl 
1de6 22 e5 e9			ld (cli_data_sp), hl 
1de9			 
1de9				if DEBUG_FORTH_STACK_GUARD 
1de9 cd ce 61				call check_stacks 
1dec					FORTH_CHK_DSP_UNDER 
1dec e5				push hl 
1ded d5				push de 
1dee 2a e5 e9			ld hl,(cli_data_sp) 
1df1 11 1f e8			ld de, cli_data_stack 
1df4 cd ff 0d			call cmp16 
1df7 da df 62			jp c, fault_dsp_under 
1dfa d1				pop de 
1dfb e1				pop hl 
1dfc				endm 
# End of macro FORTH_CHK_DSP_UNDER
1dfc				endif 
1dfc			 
1dfc e1				pop hl 
1dfd			 
1dfd c9				ret 
1dfe			 
1dfe			getwordathl: 
1dfe				; hl points to an address 
1dfe				; load hl with the word at that address 
1dfe			 
1dfe d5				push de 
1dff			 
1dff 5e				ld e, (hl) 
1e00 23				inc hl 
1e01 56				ld d, (hl) 
1e02 eb				ex de, hl 
1e03			 
1e03 d1				pop de 
1e04 c9				ret 
1e05			 
1e05			 
1e05			; functions to manuplite stack pointers 
1e05			 
1e05			; generate fragment to set hl to be pointer to a stack item 
1e05			 
1e05			FORTH_DSP_PTR: macro  x 
1e05				ld hl,(cli_data_sp) 
1e05				ld de, x * 3 
1e05				sbc hl, de 
1e05				endm 
1e05			 
1e05			 
1e05			 
1e05			; copy point in hl to stack tmp storage slots 1-4 
1e05			hltostack1: 
1e05 11 b5 e2			ld de, os_stack_1  
1e08 c3 33 1e			jp hltostackmv 
1e0b			 
1e0b			hltostack2:  
1e0b 11 b2 e2			ld de, os_stack_2 
1e0e c3 33 1e			jp hltostackmv 
1e11			 
1e11			hltostack3:  
1e11 11 af e2			ld de, os_stack_3 
1e14 c3 33 1e			jp hltostackmv 
1e17			 
1e17			hltostack4:  
1e17 11 ac e2			ld de, os_stack_4  
1e1a c3 33 1e			jp hltostackmv 
1e1d			 
1e1d			; copy to point in hl from stack tmp storage slots 1-4 
1e1d			hlfromstack1: 
1e1d 11 b5 e2			ld de, os_stack_1 
1e20 c3 32 1e			jp hlfromsttackmv 
1e23			 
1e23			hlfromstack2:  
1e23 11 b2 e2			ld de, os_stack_2 
1e26 c3 32 1e			jp hlfromsttackmv 
1e29			 
1e29			hlfromstack3:  
1e29 11 af e2			ld de, os_stack_3 
1e2c c3 32 1e			jp hlfromsttackmv 
1e2f			 
1e2f			hlfromstack4:  
1e2f 11 ac e2			ld de, os_stack_4 
1e32			 
1e32			hlfromsttackmv: 
1e32 eb				ex de, hl 
1e33			 
1e33			hltostackmv: 
1e33			 
1e33				; do stack move 
1e33 c5				push bc 
1e34 01 03 00			ld bc, 3 
1e37 ed b0			ldir  
1e39 c1				pop bc	 
1e3a c9				ret 
1e3b			 
1e3b			; eof 
1e3b			 
# End of file forth_stackopsv5.asm
1e3b			endif 
1e3b			loadwordinhl:	 
1e3b			 
1e3b d5				push de 
1e3c			 
1e3c 5e				ld e, (hl) 
1e3d 23				inc hl 
1e3e 56				ld d, (hl) 
1e3f eb				ex de,hl  
1e40			 
1e40 d1				pop de 
1e41			 
1e41 c9				ret 
1e42			 
1e42			user_word_eol:  
1e42				; hl contains the pointer to where to create a linked list item from the end 
1e42				; of the user dict to continue on at the system word dict 
1e42				 
1e42				; poke the stub of the word list linked list to repoint to rom words 
1e42			 
1e42				; stub format 
1e42				; db   word id 
1e42				; dw    link to next word 
1e42			        ; db char length of token 
1e42				; db string + 0 term 
1e42				; db exec code....  
1e42			 
1e42			;	ld a, WORD_SYS_ROOT     ; root word 
1e42 36 00			ld (hl), WORD_SYS_ROOT		; word id 
1e44 23				inc hl 
1e45			 
1e45 11 ee 1f			ld de, sysdict 
1e48 73				ld (hl), e		; next word link ie system dict 
1e49 23				inc hl 
1e4a 72				ld (hl), d		; next word link ie system dict 
1e4b 23				inc hl	 
1e4c			 
1e4c			;	ld (hl), sysdict		; next word link ie system dict 
1e4c			;	inc hl 
1e4c			;	inc hl 
1e4c			 
1e4c			;	inc hl 
1e4c			;	inc hl 
1e4c			 
1e4c			;	ld a, 2			; word length is 0 
1e4c 36 02			ld (hl), 2 
1e4e 23				inc hl 
1e4f			 
1e4f			;	ld a, '~'			; word length is 0 
1e4f 36 7e			ld (hl), '~' 
1e51 23				inc hl 
1e52			;	ld a, 0			; save empty word 
1e52 36 00			ld (hl), 0 
1e54			 
1e54 c9				ret 
1e55			 
1e55				 
1e55			 
1e55			forthexec_cleanup: 
1e55				FORTH_RSP_POP 
1e55 cd 9a 1a			call macro_forth_rsp_pop 
1e58				endm 
# End of macro FORTH_RSP_POP
1e58 c9				ret 
1e59			 
1e59			forth_call_hl: 
1e59				; taking hl 
1e59 e5				push hl 
1e5a c9				ret 
1e5b			 
1e5b			; this is called to reset Forth system but keep existing uwords etc 
1e5b			 
1e5b			forth_warmstart: 
1e5b				; setup stack over/under flow checks 
1e5b				if DEBUG_FORTH_STACK_GUARD 
1e5b cd b4 61				call chk_stk_init 
1e5e				endif 
1e5e			 
1e5e				; init stack pointers  - * these stacks go upwards *  
1e5e 21 a3 e9			ld hl, cli_ret_stack 
1e61 22 e9 e9			ld (cli_ret_sp), hl	 
1e64				; set bottom of stack 
1e64			;	ld a,0 
1e64 36 00			ld (hl),0 
1e66 23				inc hl 
1e67 36 00			ld (hl),0 
1e69			 
1e69 21 1f e8			ld hl, cli_data_stack 
1e6c 22 e5 e9			ld (cli_data_sp), hl	 
1e6f				; set bottom of stack 
1e6f			;	ld a,0 
1e6f 36 00			ld (hl),0 
1e71 23				inc hl 
1e72 36 00			ld (hl),0 
1e74			 
1e74 21 21 e9			ld hl, cli_loop_stack 
1e77 22 e7 e9			ld (cli_loop_sp), hl	 
1e7a				; set bottom of stack 
1e7a			;	ld a,0 
1e7a 36 00			ld (hl),0 
1e7c 23				inc hl 
1e7d 36 00			ld (hl),0 
1e7f			 
1e7f				; init extent of current open file 
1e7f			 
1e7f 3e 00			ld a, 0 
1e81 32 61 ea			ld (store_openext), a 
1e84			 
1e84 c9				ret 
1e85			 
1e85			 
1e85			 
1e85			; Cold Start - this is called to setup the whole Forth system 
1e85			 
1e85			forth_init: 
1e85			 
1e85				; setup stack over/under flow checks 
1e85			 
1e85			;	if DEBUG_FORTH_STACK_GUARD 
1e85			;		call chk_stk_init 
1e85			;	endif 
1e85			 
1e85				; enable auto display updates (slow.....) 
1e85			 
1e85 3e 01			ld a, 1 
1e87 32 33 ea			ld (cli_autodisplay), a 
1e8a			 
1e8a				; if storage is in use disable long reads for now 
1e8a 3e 00			ld a, 0 
1e8c 32 6c ea			ld (store_longread), a 
1e8f			 
1e8f			 
1e8f				; show start up screen 
1e8f			 
1e8f cd b7 0b			call clear_display 
1e92			 
1e92 3e 00			ld a,0 
1e94 32 55 ea			ld (f_cursor_ptr), a 
1e97			 
1e97				; set start of word list in start of ram - for use when creating user words 
1e97			 
1e97 21 c9 65			ld hl, baseram 
1e9a 22 b5 e5			ld (os_last_new_uword), hl 
1e9d cd 42 1e			call user_word_eol 
1ea0				 
1ea0			;		call display_data_sp 
1ea0			;		call next_page_prompt 
1ea0			 
1ea0			 
1ea0			 
1ea0			 
1ea0 c9				ret 
1ea1			 
1ea1 .. 00		.bootforth: db " Forth Kernel Init ",0 
1eb5			 
1eb5			; TODO push to stack 
1eb5			 
1eb5			;  
1eb5			 
1eb5			if FORTH_PARSEV2 
1eb5			 
1eb5			 
1eb5				include "forth_parserv2.asm" 
1eb5			 
1eb5			endif 
1eb5			 
1eb5			 
1eb5			; parse cli version 1 
1eb5			 
1eb5			if FORTH_PARSEV1 
1eb5			 
1eb5			 
1eb5			 
1eb5			      include "forth_parserv1.asm" 
1eb5			endif 
1eb5				 
1eb5			if FORTH_PARSEV3 
1eb5			      include "forth_parserv3.asm" 
1eb5				include "forth_wordsv3.asm" 
1eb5			endif 
1eb5			 
1eb5			if FORTH_PARSEV4 
1eb5			      include "forth_parserv4.asm" 
1eb5				include "forth_wordsv4.asm" 
1eb5			endif 
1eb5			 
1eb5			if FORTH_PARSEV5 
1eb5			      include "forth_parserv5.asm" 
1eb5				include "forth_wordsv4.asm" 
1eb5			endif 
1eb5			 
1eb5			if FORTH_PARSEV6 
1eb5			      include "forth_parserv6.asm" 
1eb5			 
1eb5			 
1eb5			; A better parser without using malloc and string copies all over the place.  
1eb5			; Exec in situ should be faster 
1eb5			 
1eb5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1eb5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1eb5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1eb5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1eb5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1eb5			WORD_SYS_END: equ 0   ; Opcode for all user words 
1eb5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1eb5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1eb5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1eb5			 
1eb5			; Core word preamble macro 
1eb5			 
1eb5			CWHEAD:   macro nxtword opcode lit len opflags 
1eb5				db WORD_SYS_CORE+opcode             
1eb5				; internal op code number 
1eb5				dw nxtword            
1eb5				; link to next dict word block 
1eb5				db len + 1 
1eb5				; literal length of dict word inc zero term 
1eb5				db lit,0              
1eb5				; literal dict word 
1eb5			        ; TODO db opflags        
1eb5				endm 
1eb5			 
1eb5			 
1eb5			NEXTW: macro  
1eb5				call parse_vector 
1eb5				jp macro_next 
1eb5				endm 
1eb5			 
1eb5			macro_next: 
1eb5			if DEBUG_FORTH_PARSE_EXEC 
1eb5				DMARK "NXT" 
1eb5				CALLMONITOR 
1eb5			endif	 
1eb5			;	inc hl  ; skip token null term  
1eb5 ed 4b 37 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1eb9 ed 5b 35 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ebd 2a b9 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ec0			if DEBUG_FORTH_PARSE_EXEC 
1ec0				DMARK "}AA" 
1ec0				CALLMONITOR 
1ec0			endif	 
1ec0 c3 a5 1f			jp execnext 
1ec3				;jp exec1 
1ec3			       
1ec3			 
1ec3			 
1ec3			; Another go at the parser to compile  
1ec3			 
1ec3			 
1ec3			; TODO rework parser to change all of the string words to byte tokens 
1ec3			; TODO do a search for  
1ec3			 
1ec3			; TODO first run normal parser to zero term sections 
1ec3			; TODO for each word do a token look up to get the op code 
1ec3			; TODO need some means to flag to the exec that this is a byte code form    
1ec3			 
1ec3			 
1ec3			forthcompile: 
1ec3			 
1ec3			; 
1ec3			; line parse: 
1ec3			;       parse raw input buffer 
1ec3			;       tokenise the words 
1ec3			;       malloc new copy (for looping etc) 
1ec3			;       copy to malloc + current pc in line to start of string and add line term 
1ec3			;       save on new rsp 
1ec3			; 
1ec3			 
1ec3			; hl to point to the line to tokenise 
1ec3			 
1ec3			;	push hl 
1ec3 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1ec6			 
1ec6			;	ld a,0		; string term on input 
1ec6			;	call strlent 
1ec6			 
1ec6			;	ld (os_tok_len), hl	 ; save string length 
1ec6			 
1ec6			;if DEBUG_FORTH_TOK 
1ec6			;	ex de,hl		 
1ec6			;endif 
1ec6			 
1ec6			;	pop hl 		; get back string pointer 
1ec6			 
1ec6			if DEBUG_FORTH_TOK 
1ec6						DMARK "TOc" 
1ec6				CALLMONITOR 
1ec6			endif 
1ec6 7e			.cptoken2:    ld a,(hl) 
1ec7 23				inc hl 
1ec8 fe 7f			cp FORTH_END_BUFFER 
1eca 28 26			jr z, .cptokendone2 
1ecc			;	cp 0 
1ecc b7				or a 
1ecd 28 23			jr z, .cptokendone2 
1ecf fe 22			cp '"' 
1ed1 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1ed3 fe 20			cp ' ' 
1ed5 20 ef			jr nz,  .cptoken2 
1ed7			 
1ed7			; TODO consume comments held between ( and ) 
1ed7			 
1ed7				; we have a space so change to zero term for dict match later 
1ed7 2b				dec hl 
1ed8			;	ld a,0 
1ed8 36 00			ld (hl), 0 
1eda 23				inc hl 
1edb 18 e9			jr .cptoken2 
1edd				 
1edd			 
1edd			.cptokenstr2: 
1edd				; skip all white space until either eol (because forgot to term) or end double quote 
1edd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1edd				;inc hl ; skip current double quote 
1edd 7e				ld a,(hl) 
1ede 23				inc hl 
1edf fe 22			cp '"' 
1ee1 28 e3			jr z, .cptoken2 
1ee3 fe 7f			cp FORTH_END_BUFFER 
1ee5 28 0b			jr z, .cptokendone2 
1ee7			;	cp 0 
1ee7 b7				or a 
1ee8 28 08			jr z, .cptokendone2 
1eea fe 20			cp ' ' 
1eec 28 02			jr z, .cptmp2 
1eee 18 ed			jr .cptokenstr2 
1ef0			 
1ef0			.cptmp2:	; we have a space so change to zero term for dict match later 
1ef0				;dec hl 
1ef0				;ld a,"-"	; TODO remove this when working 
1ef0				;ld (hl), a 
1ef0				;inc hl 
1ef0 18 eb			jr .cptokenstr2 
1ef2			 
1ef2			.cptokendone2: 
1ef2				;inc hl 
1ef2			;	ld a, FORTH_END_BUFFER 
1ef2 36 7f			ld (hl),FORTH_END_BUFFER 
1ef4			;	inc hl 
1ef4			;	ld a, '!' 
1ef4			;	ld (hl),a 
1ef4			 
1ef4 2a b9 e5			ld hl,(os_tok_ptr) 
1ef7			         
1ef7			if DEBUG_FORTH_TOK 
1ef7						DMARK "Tc1" 
1ef7				CALLMONITOR 
1ef7			endif 
1ef7			 
1ef7				; push exec string to top of return stack 
1ef7				FORTH_RSP_NEXT 
1ef7 cd 79 1a			call macro_forth_rsp_next 
1efa				endm 
# End of macro FORTH_RSP_NEXT
1efa c9				ret 
1efb			 
1efb			; Another go at the parser need to simplify the process 
1efb			 
1efb			forthparse: 
1efb			 
1efb			; 
1efb			; line parse: 
1efb			;       parse raw input buffer 
1efb			;       tokenise the words 
1efb			;       malloc new copy (for looping etc) 
1efb			;       copy to malloc + current pc in line to start of string and add line term 
1efb			;       save on new rsp 
1efb			; 
1efb			 
1efb			; hl to point to the line to tokenise 
1efb			 
1efb			;	push hl 
1efb 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1efe			 
1efe			;	ld a,0		; string term on input 
1efe			;	call strlent 
1efe			 
1efe			;	ld (os_tok_len), hl	 ; save string length 
1efe			 
1efe			;if DEBUG_FORTH_TOK 
1efe			;	ex de,hl		 
1efe			;endif 
1efe			 
1efe			;	pop hl 		; get back string pointer 
1efe			 
1efe			if DEBUG_FORTH_TOK 
1efe						DMARK "TOK" 
1efe				CALLMONITOR 
1efe			endif 
1efe 7e			.ptoken2:    ld a,(hl) 
1eff 23				inc hl 
1f00 fe 7f			cp FORTH_END_BUFFER 
1f02 28 26			jr z, .ptokendone2 
1f04			;	cp 0 
1f04 b7				or a 
1f05 28 23			jr z, .ptokendone2 
1f07 fe 22			cp '"' 
1f09 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f0b fe 20			cp ' ' 
1f0d 20 ef			jr nz,  .ptoken2 
1f0f			 
1f0f			; TODO consume comments held between ( and ) 
1f0f			 
1f0f				; we have a space so change to zero term for dict match later 
1f0f 2b				dec hl 
1f10			;	ld a,0 
1f10 36 00			ld (hl), 0 
1f12 23				inc hl 
1f13 18 e9			jr .ptoken2 
1f15				 
1f15			 
1f15			.ptokenstr2: 
1f15				; skip all white space until either eol (because forgot to term) or end double quote 
1f15			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f15				;inc hl ; skip current double quote 
1f15 7e				ld a,(hl) 
1f16 23				inc hl 
1f17 fe 22			cp '"' 
1f19 28 e3			jr z, .ptoken2 
1f1b fe 7f			cp FORTH_END_BUFFER 
1f1d 28 0b			jr z, .ptokendone2 
1f1f			;	cp 0 
1f1f b7				or a 
1f20 28 08			jr z, .ptokendone2 
1f22 fe 20			cp ' ' 
1f24 28 02			jr z, .ptmp2 
1f26 18 ed			jr .ptokenstr2 
1f28			 
1f28			.ptmp2:	; we have a space so change to zero term for dict match later 
1f28				;dec hl 
1f28				;ld a,"-"	; TODO remove this when working 
1f28				;ld (hl), a 
1f28				;inc hl 
1f28 18 eb			jr .ptokenstr2 
1f2a			 
1f2a			.ptokendone2: 
1f2a				;inc hl 
1f2a			;	ld a, FORTH_END_BUFFER 
1f2a 36 7f			ld (hl),FORTH_END_BUFFER 
1f2c			;	inc hl 
1f2c			;	ld a, '!' 
1f2c			;	ld (hl),a 
1f2c			 
1f2c 2a b9 e5			ld hl,(os_tok_ptr) 
1f2f			         
1f2f			if DEBUG_FORTH_TOK 
1f2f						DMARK "TK1" 
1f2f				CALLMONITOR 
1f2f			endif 
1f2f			 
1f2f				; push exec string to top of return stack 
1f2f				FORTH_RSP_NEXT 
1f2f cd 79 1a			call macro_forth_rsp_next 
1f32				endm 
# End of macro FORTH_RSP_NEXT
1f32 c9				ret 
1f33			 
1f33			; 
1f33			;	; malloc size + buffer pointer + if is loop flag 
1f33			;	ld hl,(os_tok_len) 		 ; get string length 
1f33			; 
1f33			;	ld a,l 
1f33			; 
1f33			;	cp 0			; we dont want to use a null string 
1f33			;	ret z 
1f33			; 
1f33			;;	add 3    ; prefix malloc with buffer for current word ptr 
1f33			; 
1f33			;	add 5     ; TODO when certain not over writing memory remove 
1f33			; 
1f33			;		 
1f33			; 
1f33			;if DEBUG_FORTH_TOK 
1f33			;			DMARK "TKE" 
1f33			;	CALLMONITOR 
1f33			;endif 
1f33			; 
1f33			;	ld l,a 
1f33			;	ld h,0 
1f33			;;	push hl   ; save required space for the copy later 
1f33			;	call malloc 
1f33			;if DEBUG_FORTH_TOK 
1f33			;			DMARK "TKM" 
1f33			;	CALLMONITOR 
1f33			;endif 
1f33			;	if DEBUG_FORTH_MALLOC_GUARD 
1f33			;		push af 
1f33			;		call ishlzero 
1f33			;;		ld a, l 
1f33			;;		add h 
1f33			;;		cp 0 
1f33			;		pop af 
1f33			;		 
1f33			;		call z,malloc_error 
1f33			;	endif 
1f33			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1f33			; 
1f33			; 
1f33			;if DEBUG_FORTH_TOK 
1f33			;			DMARK "TKR" 
1f33			;	CALLMONITOR 
1f33			;endif 
1f33			; 
1f33			;	FORTH_RSP_NEXT 
1f33			; 
1f33			;	;inc hl	 ; go past current buffer pointer 
1f33			;	;inc hl 
1f33			;	;inc hl   ; and past if loop flag 
1f33			;		; TODO Need to set flag  
1f33			; 
1f33			;	 
1f33			;	 
1f33			;	ex de,hl	; malloc is dest 
1f33			;	ld hl, (os_tok_len) 
1f33			;;	pop bc 
1f33			;	ld c, l                
1f33			;	ld b,0 
1f33			;	ld hl, (os_tok_ptr) 
1f33			; 
1f33			;if DEBUG_FORTH_TOK 
1f33			;			DMARK "TKT" 
1f33			;	CALLMONITOR 
1f33			;endif 
1f33			; 
1f33			;	; do str cpy 
1f33			; 
1f33			;	ldir      ; copy byte in hl to de 
1f33			; 
1f33			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1f33			; 
1f33			;if DEBUG_FORTH_TOK 
1f33			; 
1f33			;			DMARK "TKY" 
1f33			;	CALLMONITOR 
1f33			;endif 
1f33			;	;ld a,0 
1f33			;	;ld a,FORTH_END_BUFFER 
1f33			;	ex de, hl 
1f33			;	;dec hl			 ; go back over the space delim at the end of word 
1f33			;	;ld (hl),a 
1f33			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1f33			;	ld a,FORTH_END_BUFFER 
1f33			;	ld (hl),a 
1f33			;	inc hl 
1f33			;	ld a,FORTH_END_BUFFER 
1f33			;	ld (hl),a 
1f33			; 
1f33			;	; init the malloc area data 
1f33			;	; set pc for in current area 
1f33			;	;ld hl, (os_tok_malloc) 
1f33			;	;inc hl 
1f33			;	;inc hl 
1f33			;	;inc hl 
1f33			;	;ex de,hl 
1f33			;	;ld hl, (os_tok_malloc) 
1f33			;	;ld (hl),e 
1f33			;	;inc hl 
1f33			;	;ld (hl),d 
1f33			; 
1f33			; 
1f33			;	ld hl,(os_tok_malloc) 
1f33			;if DEBUG_FORTH_PARSE_KEY 
1f33			;			DMARK "TKU" 
1f33			;	CALLMONITOR 
1f33			;endif 
1f33			; 
1f33			;	ret 
1f33			 
1f33			forthexec: 
1f33			 
1f33			; line exec: 
1f33			; forth parser 
1f33			 
1f33			; 
1f33			;       get current exec line on rsp 
1f33			 
1f33				FORTH_RSP_TOS 
1f33 cd 90 1a			call macro_forth_rsp_tos 
1f36				endm 
# End of macro FORTH_RSP_TOS
1f36			 
1f36			;       restore current pc - hl points to malloc of data 
1f36			 
1f36				;ld e, (hl) 
1f36				;inc hl 
1f36				;ld d, (hl) 
1f36				;ex de,hl 
1f36			 
1f36			 
1f36			exec1: 
1f36 22 b9 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
1f39			 
1f39				; copy our PC to working vars  
1f39 22 37 ea			ld (cli_ptr), hl                    ; here 
1f3c 22 35 ea			ld (cli_origptr), hl                ; here 
1f3f			 
1f3f 7e				ld a,(hl)                           ; here make hl be the ram ptr 
1f40 fe 7f			cp FORTH_END_BUFFER 
1f42 c8				ret z 
1f43			 
1f43				; skip any nulls 
1f43			 
1f43			;	cp 0 
1f43 b7				or a 
1f44 20 03			jr nz, .execword 
1f46 23				inc hl 
1f47 18 ed			jr exec1 
1f49			 
1f49			 
1f49			.execword: 
1f49			 
1f49			 
1f49			 
1f49			if DEBUG_FORTH_PARSE_EXEC 
1f49						DMARK "KYQ" 
1f49				CALLMONITOR 
1f49			endif 
1f49			;       while at start of word: 
1f49			; get start of dict (in user area first) 
1f49			 
1f49 21 c9 65		ld hl, baseram 
1f4c			;ld hl, sysdict 
1f4c 22 39 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
1f4f			;           match word at pc 
1f4f			;           exec word 
1f4f			;           or push to dsp 
1f4f			;           forward to next token 
1f4f			;           if line term pop rsp and exit 
1f4f			;        
1f4f			 
1f4f			if DEBUG_FORTH_PARSE_EXEC 
1f4f						DMARK "KYq" 
1f4f				CALLMONITOR 
1f4f			endif 
1f4f			 
1f4f			; 
1f4f			; word comp 
1f4f			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1f4f			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1f4f			;    move to start of word  
1f4f			;    compare word to cli_token 
1f4f			 
1f4f			.execpnword:	; HL at start of a word in the dictionary to check 
1f4f			 
1f4f 2a 39 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
1f52			 
1f52 cd e7 1f			call forth_tok_next 
1f55			; tok next end here 
1f55 22 39 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1f58 eb				ex de, hl 
1f59			 
1f59			 
1f59				; save the pointer of the current token - 1 to check against 
1f59				 
1f59 22 3d ea			ld (cli_token), hl   
1f5c				; TODO maybe remove below save if no debug 
1f5c				; save token string ptr for any debug later 
1f5c 23				inc hl  
1f5d 22 3f ea			ld (cli_origtoken), hl 
1f60 2b				dec hl 
1f61				; save pointer to the start of the next dictionay word 
1f61 7e				ld a,(hl)   ; get string length 
1f62 47				ld b,a 
1f63			.execpnwordinc:  
1f63 23				inc hl 
1f64 10 fd			djnz .execpnwordinc 
1f66 22 3b ea			ld (cli_execword), hl      ; save start of this words code 
1f69			 
1f69				; now check the word token against the string being parsed 
1f69			 
1f69 2a 3d ea			ld hl,(cli_token) 
1f6c 23				inc hl     ; skip string length (use zero term instead to end) 
1f6d				;ld (cli_token), hl 
1f6d			 
1f6d			.execpnchar:    ; compare char between token and string to parse 
1f6d			 
1f6d			 
1f6d				;ld hl, (cli_token)     ; the dict word  
1f6d ed 5b 37 ea		ld de, (cli_ptr)     ; cli to parse 
1f71			 
1f71			 
1f71			.execpncharl:    ; compare char between token and string to parse (loop) 
1f71			 
1f71 1a				ld a,(de) 
1f72 cd 30 11			call toUpper 		; make sure the input string matches case 
1f75 be				cp (hl) 
1f76			 
1f76 c2 8e 1f			jp nz, .execpnskipword	 ; no match so move to next word 
1f79				 
1f79			;    if same 
1f79			;       scan for string terms 0 for token and 32 for input 
1f79 46				ld b,(hl) 
1f7a 80				add b			 
1f7b 23				inc hl 
1f7c 13				inc de 
1f7d b7				or a 
1f7e			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1f7e							; TODO need to make sure last word in zero term string is accounted for 
1f7e 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
1f80			 
1f80			 
1f80				; at end of both strings so both are exact match 
1f80			 
1f80			;       skip ptr for next word 
1f80			 
1f80 2a 37 ea			ld hl,(cli_ptr) 	; at input string term 
1f83 23				inc hl			 ; at next char 
1f84 22 37 ea			ld (cli_ptr), hl     ; save for next round of the parser 
1f87 22 35 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1f8a				 
1f8a				 
1f8a			 
1f8a			 
1f8a			 
1f8a			;       exec code block 
1f8a			if DEBUG_FORTH_JP 
1f8a				call clear_display 
1f8a				call update_display 
1f8a				call delay1s 
1f8a				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f8a				ld a,h 
1f8a				ld hl, os_word_scratch 
1f8a				call hexout 
1f8a				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f8a				ld a,l 
1f8a				ld hl, os_word_scratch+2 
1f8a				call hexout 
1f8a				ld hl, os_word_scratch+4 
1f8a			;	ld a,0 
1f8a				ld (hl),0 
1f8a				ld de,os_word_scratch 
1f8a				call str_at_display 
1f8a					ld a, display_row_2 
1f8a					call str_at_display 
1f8a				ld de, (cli_origtoken) 
1f8a				ld a, display_row_1+10 
1f8a					call str_at_display 
1f8a			 
1f8a				ld a,display_row_1 
1f8a				ld de, .foundword 
1f8a				ld a, display_row_3 
1f8a				call str_at_display 
1f8a				call update_display 
1f8a				call delay1s 
1f8a				call delay1s 
1f8a				call delay1s 
1f8a			endif 
1f8a			 
1f8a			if DEBUG_FORTH_PARSE_EXEC 
1f8a						DMARK "KYj" 
1f8a			endif 
1f8a				; TODO save the word pointer in this exec 
1f8a			 
1f8a 2a 3b ea			ld hl,(cli_execword) 
1f8d e9				jp (hl) 
1f8e			 
1f8e			 
1f8e			;    if not same 
1f8e			;	scan for zero term 
1f8e			;	get ptr for next word 
1f8e			;	goto word comp 
1f8e			 
1f8e			.execpnskipword:	; get pointer to next word 
1f8e 2a 39 ea			ld hl,(cli_nextword) 
1f91			 
1f91 7e				ld a,(hl) 
1f92 fe 00			cp WORD_SYS_END 
1f94			;	cp 0 
1f94 28 09			jr z, .execendofdict			 ; at end of words 
1f96			 
1f96			if DEBUG_FORTH_PARSE_EXEC 
1f96						DMARK "KY4" 
1f96			endif 
1f96			if DEBUG_FORTH_PARSE_EXEC 
1f96			 
1f96				; see if disabled 
1f96			 
1f96			;	ld a, (os_view_disable) 
1f96			;	cp '*' 
1f96				ld a,(debug_vector) 
1f96				cp $c9   ; RET 
1f96				jr z, .noskip 
1f96			 
1f96			 
1f96				ld de, .nowordfound 
1f96				ld a, display_row_3 
1f96				call str_at_display 
1f96				call update_display 
1f96				ld a, 100 
1f96				call aDelayInMS 
1f96				 
1f96				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f96					call delay250ms 
1f96				endif 
1f96			.noskip:  
1f96			 
1f96			endif	 
1f96			 
1f96 2a 35 ea			ld hl,(cli_origptr) 
1f99 22 37 ea			ld (cli_ptr),hl 
1f9c			 
1f9c			if DEBUG_FORTH_PARSE_EXEC 
1f9c						DMARK "KY5" 
1f9c			endif 
1f9c c3 4f 1f			jp .execpnword			; else go to next word 
1f9f			 
1f9f			.execendofdict:  
1f9f			 
1f9f			if DEBUG_FORTH_PARSE_EXEC 
1f9f						DMARK "KYe" 
1f9f			endif 
1f9f			if DEBUG_FORTH_PARSE_EXEC 
1f9f				; see if disabled 
1f9f			 
1f9f			;	ld a, (os_view_disable) 
1f9f			;	cp '*' 
1f9f				ld a,(debug_vector) 
1f9f				cp $c9   ; ret 
1f9f				jr z, .ispskip 
1f9f			 
1f9f				call clear_display 
1f9f				call update_display 
1f9f				call delay1s 
1f9f				ld de, (cli_origptr) 
1f9f				ld a, display_row_1 
1f9f				call str_at_display 
1f9f				 
1f9f				ld de, .enddict 
1f9f				ld a, display_row_3 
1f9f				call str_at_display 
1f9f				call update_display 
1f9f				ld a, 100 
1f9f				call aDelayInMS 
1f9f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f9f				call delay1s 
1f9f				call delay1s 
1f9f				call delay1s 
1f9f				endif 
1f9f			.ispskip:  
1f9f				 
1f9f			endif	 
1f9f			 
1f9f			 
1f9f			 
1f9f				; if the word is not a keyword then must be a literal so push it to stack 
1f9f			 
1f9f			; push token to stack to end of word 
1f9f			 
1f9f				STACKFRAME ON $1efe $2f9f 
1f9f				if DEBUG_STACK_IMB 
1f9f					if ON 
1f9f						exx 
1f9f						ld de, $1efe 
1f9f						ld a, d 
1f9f						ld hl, curframe 
1f9f						call hexout 
1f9f						ld a, e 
1f9f						ld hl, curframe+2 
1f9f						call hexout 
1f9f						ld hl, $1efe 
1f9f						push hl 
1f9f						ld hl, $2f9f 
1f9f						push hl 
1f9f						exx 
1f9f					endif 
1f9f				endif 
1f9f			endm 
# End of macro STACKFRAME
1f9f			 
1f9f 2a b9 e5		ld hl,(os_tok_ptr) 
1fa2 cd 34 1c		call forth_apush 
1fa5			 
1fa5				STACKFRAMECHK ON $1efe $2f9f 
1fa5				if DEBUG_STACK_IMB 
1fa5					if ON 
1fa5						exx 
1fa5						ld hl, $2f9f 
1fa5						pop de   ; $2f9f 
1fa5						call cmp16 
1fa5						jr nz, .spnosame 
1fa5						ld hl, $1efe 
1fa5						pop de   ; $1efe 
1fa5						call cmp16 
1fa5						jr z, .spfrsame 
1fa5						.spnosame: call showsperror 
1fa5						.spfrsame: nop 
1fa5						exx 
1fa5					endif 
1fa5				endif 
1fa5			endm 
# End of macro STACKFRAMECHK
1fa5			 
1fa5			execnext: 
1fa5			 
1fa5			if DEBUG_FORTH_PARSE_EXEC 
1fa5						DMARK "KY>" 
1fa5			endif 
1fa5			; move past token to next word 
1fa5			 
1fa5 2a b9 e5		ld hl, (os_tok_ptr) 
1fa8 3e 00		ld a, 0 
1faa 01 ff 00		ld bc, 255     ; input buffer size 
1fad ed b1		cpir 
1faf			 
1faf			if DEBUG_FORTH_PARSE_EXEC 
1faf						DMARK "KY!" 
1faf				CALLMONITOR 
1faf			endif	 
1faf			; TODO this might place hl on the null, so will need to forward on??? 
1faf			;inc hl   ; see if this gets onto the next item 
1faf			 
1faf			 
1faf			; TODO pass a pointer to the buffer to push 
1faf			; TODO call function to push 
1faf			 
1faf			; look for end of input 
1faf			 
1faf			;inc hl 
1faf			;ld a,(hl) 
1faf			;cp FORTH_END_BUFFER 
1faf			;ret z 
1faf			 
1faf			 
1faf c3 36 1f		jp exec1 
1fb2			 
1fb2			 
1fb2			 
1fb2			 
1fb2			 
1fb2			 
1fb2			 
1fb2			 
1fb2			 
1fb2			findnexttok: 
1fb2			 
1fb2				; hl is pointer to move 
1fb2				; de is the token to locate 
1fb2			 
1fb2					if DEBUG_FORTH 
1fb2						DMARK "NTK" 
1fb2						CALLMONITOR 
1fb2					endif 
1fb2 d5				push de 
1fb3			 
1fb3			.fnt1:	 
1fb3				; find first char of token to locate 
1fb3			 
1fb3 1a				ld a, (de) 
1fb4 4f				ld c,a 
1fb5 7e				ld a,(hl) 
1fb6 cd 30 11			call toUpper 
1fb9					if DEBUG_FORTH 
1fb9						DMARK "NT1" 
1fb9						CALLMONITOR 
1fb9					endif 
1fb9 b9				cp c 
1fba			 
1fba 28 03			jr z, .fnt2cmpmorefirst	 
1fbc			 
1fbc				; first char not found move to next char 
1fbc			 
1fbc 23				inc hl 
1fbd 18 f4			jr .fnt1 
1fbf			 
1fbf			.fnt2cmpmorefirst:	 
1fbf				; first char of token found.  
1fbf			 
1fbf e5				push hl     ; save start of token just in case it is the right one 
1fc0 d9				exx 
1fc1 e1				pop hl        ; save it to hl' 
1fc2 d9				exx 
1fc3			 
1fc3			 
1fc3			.fnt2cmpmore:	 
1fc3				; compare the rest 
1fc3				 
1fc3 23				inc hl 
1fc4 13				inc de 
1fc5				 
1fc5 1a				ld a, (de) 
1fc6 4f				ld c,a 
1fc7 7e				ld a,(hl) 
1fc8 cd 30 11			call toUpper 
1fcb			 
1fcb					if DEBUG_FORTH 
1fcb						DMARK "NT2" 
1fcb						CALLMONITOR 
1fcb					endif 
1fcb				; c has the token to find char 
1fcb				; a has the mem to scan char 
1fcb			 
1fcb b9				cp c 
1fcc 28 04			jr z,.fntmatch1 
1fce			 
1fce				; they are not the same 
1fce			 
1fce					if DEBUG_FORTH 
1fce						DMARK "NT3" 
1fce						CALLMONITOR 
1fce					endif 
1fce d1				pop de	; reset de token to look for 
1fcf d5				push de 
1fd0 18 e1			jr .fnt1 
1fd2				 
1fd2			.fntmatch1: 
1fd2			 
1fd2				; is the same char a null which means we might have a full hit? 
1fd2					if DEBUG_FORTH 
1fd2						DMARK "NT4" 
1fd2						CALLMONITOR 
1fd2					endif 
1fd2			 
1fd2			;	cp 0 
1fd2 b7				or a 
1fd3 28 0b			jr z, .fntmatchyes 
1fd5			 
1fd5				; are we at the end of the token to find? 
1fd5			 
1fd5					if DEBUG_FORTH 
1fd5						DMARK "NT5" 
1fd5						CALLMONITOR 
1fd5					endif 
1fd5 3e 00			ld a, 0 
1fd7 b9				cp c 
1fd8			 
1fd8 c2 c3 1f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1fdb			 
1fdb					if DEBUG_FORTH 
1fdb						DMARK "NT6" 
1fdb						CALLMONITOR 
1fdb					endif 
1fdb				; token to find is exhusted but no match to stream 
1fdb			 
1fdb				; restore tok pointer and continue on 
1fdb d1				pop de 
1fdc d5				push de 
1fdd c3 b3 1f			jp .fnt1 
1fe0			 
1fe0			 
1fe0			.fntmatchyes: 
1fe0			 
1fe0				; hl now contains the end of the found token 
1fe0			 
1fe0				; get rid of saved token pointer to find 
1fe0			 
1fe0 d1				pop de 
1fe1			 
1fe1					if DEBUG_FORTH 
1fe1						DMARK "NT9" 
1fe1						CALLMONITOR 
1fe1					endif 
1fe1			 
1fe1				; hl will be on the null term so forward on 
1fe1			 
1fe1				; get back the saved start of the token 
1fe1			 
1fe1 d9				exx 
1fe2 e5				push hl     ; save start of token just in case it is the right one 
1fe3 d9				exx 
1fe4 e1				pop hl        ; save it to hl 
1fe5			 
1fe5 c9				ret 
1fe6			 
1fe6			 
1fe6			; LIST needs to find a specific token   
1fe6			; FORGET needs to find a spefici token 
1fe6			 
1fe6			; SAVE needs to find all tokens by flag 
1fe6			; WORDS just needs to scan through all  by flag 
1fe6			; UWORDS needs to scan through all by flag 
1fe6			 
1fe6			 
1fe6			; given hl as pointer to start of dict look up string 
1fe6			; return hl as pointer to start of word block 
1fe6			; or 0 if not found 
1fe6			 
1fe6			forth_find_tok: 
1fe6 c9				ret 
1fe7			 
1fe7			; given hl as pointer to dict structure 
1fe7			; move to the next dict block structure 
1fe7			 
1fe7			forth_tok_next: 
1fe7				; hl now points to the address of the next word pointer  
1fe7				; TODO skip compiled symbol for now 
1fe7			;	push de 
1fe7 23				inc hl 
1fe8 5e				ld e, (hl) 
1fe9 23				inc hl 
1fea 56				ld d, (hl) 
1feb 23				inc hl 
1fec			 
1fec eb				ex de,hl 
1fed			if DEBUG_FORTH_PARSE_NEXTWORD 
1fed				push bc 
1fed				ld bc, (cli_nextword) 
1fed						DMARK "NXW" 
1fed				CALLMONITOR 
1fed				pop bc 
1fed			endif 
1fed			;	pop de	 
1fed c9				ret 
1fee			 
1fee			 
1fee			 
1fee			; eof 
# End of file forth_parserv6.asm
1fee				include "forth_wordsv4.asm" 
1fee			 
1fee			; the core word dictionary v4 
1fee			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1fee			 
1fee			; this is a linked list for each of the system words used 
1fee			; user defined words will follow the same format but will be in ram 
1fee			 
1fee			 
1fee			; 
1fee			; 
1fee			; define linked list: 
1fee			; 
1fee			; 1. compiled byte op code 
1fee			; 2. len of text word 
1fee			; 3. text word 
1fee			; 4. ptr to next dictionary word 
1fee			; 5. asm, calls etc for the word 
1fee			; 
1fee			;  if 1 == 0 then last word in dict  
1fee			;   
1fee			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1fee			;  
1fee			;  
1fee			; create basic standard set of words 
1fee			; 
1fee			;  
1fee			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1fee			; 2DUP 2DROP 2SWAP  
1fee			; @ C@ - get byte  
1fee			; ! C! - store byte 
1fee			; 0< true if less than zero 
1fee			; 0= true if zero 
1fee			; < >  
1fee			; = true if same 
1fee			; variables 
1fee			 
1fee			 
1fee			; Hardware specific words I may need 
1fee			; 
1fee			; IN OUT  
1fee			; calls to key util functions 
1fee			; calls to hardward abstraction stuff 
1fee			; easy control of frame buffers and lcd i/o 
1fee			; keyboard  
1fee			 
1fee			 
1fee			;DICT: macro 
1fee			; op_code, len, word, next 
1fee			;    word: 
1fee			;    db op_code 
1fee			;    ds word zero term 
1fee			;    dw next 
1fee			;    endm 
1fee			 
1fee			 
1fee			 
1fee			 
1fee			; op code 1 is a flag for user define words which are to be handled differently 
1fee			 
1fee			 
1fee			; 
1fee			; 
1fee			;    TODO on entry to a word this should be the expected environment 
1fee			;    hl - tos value if number then held, if string this is the ptr 
1fee			;    de -  
1fee			 
1fee			 
1fee			; opcode ranges 
1fee			; 0 - end of word dict 
1fee			; 255 - user define words 
1fee			 
1fee			sysdict: 
1fee			include "forth_opcodes.asm" 
1fee			; op codes for forth keywords 
1fee			 
1fee			; Changing use of opcodes to flag is the word exists in compiled form or not.  
1fee			; This provides a means to compile uwords if required for higher performance 
1fee			; by avoiding the use of the keyword parser and just jumping directly to the code 
1fee			; Actually there is already a flag for if the code exists as binary thinking about it... 
1fee			 
1fee			 
1fee			 
1fee			 
1fee			 
1fee			; free to use code 0  
1fee				OPCODE_HEAP: equ  1 
1fee				OPCODE_EXEC: equ 2 
1fee				OPCODE_DUP: equ 3 
1fee				OPCODE_SWAP: equ 4 
1fee				OPCODE_COLN: equ 5 
1fee				OPCODE_SCOLN: equ 6 
1fee				OPCODE_DROP: equ 7 
1fee				OPCODE_DUP2: equ 8 
1fee				OPCODE_DROP2: equ 9 
1fee				OPCODE_SWAP2: equ 10 
1fee				OPCODE_AT: equ 11 
1fee				OPCODE_CAT: equ 12 
1fee				OPCODE_BANG: equ 13 
1fee				OPCODE_CBANG: equ 14 
1fee				OPCODE_SCALL: equ 15 
1fee				OPCODE_DEPTH: equ 16 
1fee				OPCODE_OVER: equ 17 
1fee				OPCODE_PAUSE: equ 18 
1fee				OPCODE_PAUSES: equ 19 
1fee				OPCODE_ROT: equ 20 
1fee			;free to reuse	OPCODE_WORDS: equ 21 
1fee			        OPCODE_NOT: equ 21 
1fee				OPCODE_UWORDS: equ 22 
1fee				OPCODE_BP: equ 23 
1fee				OPCODE_MONITOR: equ 24  
1fee				OPCODE_MALLOC: equ 25 
1fee				OPCODE_FREE: equ 26 
1fee				OPCODE_LIST: equ 27 
1fee				OPCODE_FORGET: equ 28 
1fee				OPCODE_NOP: equ 29 
1fee				OPCODE_COMO: equ 30 
1fee				OPCODE_COMC: equ 31 
1fee			;free to reuse	OPCODE_ENDCORE: equ 32 
1fee				OPCODE_AFTERSOUND: equ 33 
1fee				OPCODE_GP2: equ 34 
1fee				OPCODE_GP3: equ 35 
1fee				OPCODE_GP4: equ 36 
1fee				OPCODE_SIN: equ 37 
1fee				OPCODE_SOUT: equ 38 
1fee				OPCODE_SPIO: equ 39 
1fee				OPCODE_SPICEH: equ 40 
1fee				OPCODE_SPIOb: equ 41 
1fee				OPCODE_SPII: equ 42 
1fee				OPCODE_SESEL: equ 43 
1fee				OPCODE_CARTDEV: equ 44 
1fee			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1fee				OPCODE_FB: equ 46 
1fee				OPCODE_EMIT: equ 47 
1fee				OPCODE_DOTH: equ 48 
1fee				OPCODE_DOTF: equ 49 
1fee				OPCODE_DOT: equ 50 
1fee				OPCODE_CLS: equ 51 
1fee				OPCODE_DRAW: equ 52 
1fee				OPCODE_DUMP: equ 53 
1fee				OPCODE_CDUMP: equ 54 
1fee				OPCODE_DAT: equ 55 
1fee				OPCODE_HOME: equ 56 
1fee				OPCODE_SPACE: equ 57 
1fee				OPCODE_SPACES: equ 58 
1fee				OPCODE_SCROLL: equ 59 
1fee				OPCODE_ATQ: equ 60 
1fee				OPCODE_AUTODSP: equ 61 
1fee				OPCODE_MENU: equ 62 
1fee			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1fee				OPCODE_THEN: equ 64 
1fee				OPCODE_ELSE: equ 65 
1fee				OPCODE_DO: equ 66 
1fee				OPCODE_LOOP: equ 67 
1fee				OPCODE_I: equ 68 
1fee				OPCODE_DLOOP: equ 69  
1fee				OPCODE_REPEAT: equ 70  
1fee				OPCODE_UNTIL: equ 71 
1fee				OPCODE_ENDFLOW: equ 72 
1fee				OPCODE_WAITK: equ 73 
1fee				OPCODE_ACCEPT: equ 74 
1fee				OPCODE_EDIT: equ 75 
1fee			;free to reuse	OPCODE_ENDKEY: equ 76 
1fee				OPCODE_LZERO: equ 77 
1fee				OPCODE_TZERO: equ 78 
1fee				OPCODE_LESS: equ 79 
1fee				OPCODE_GT: equ 80 
1fee				OPCODE_EQUAL: equ 81  
1fee			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1fee				OPCODE_NEG: equ 83 
1fee				OPCODE_DIV: equ 84 
1fee				OPCODE_MUL: equ 85 
1fee				OPCODE_MIN: equ 86 
1fee				OPCODE_MAX: equ 87 
1fee				OPCODE_RND16: equ 88 
1fee				OPCODE_RND8: equ 89 
1fee				OPCODE_RND: equ 90 
1fee			;free to reuse	OPCODE_ENDMATHS: equ 91  
1fee				OPCODE_BYNAME: equ 92 
1fee				OPCODE_DIR: equ 93 
1fee				OPCODE_SAVE: equ 94 
1fee				OPCODE_LOAD: equ 95 
1fee				OPCODE_BSAVE: equ 96 
1fee				OPCODE_BLOAD: equ 97 
1fee				OPCODE_SEO: equ 98  
1fee				OPCODE_SEI: equ 99 
1fee				OPCODE_SFREE: equ 100 
1fee				OPCODE_SIZE: equ 101 
1fee				OPCODE_CREATE: equ 102 
1fee				OPCODE_APPEND: equ 103 
1fee				OPCODE_SDEL: equ 104 
1fee				OPCODE_OPEN: equ 105 
1fee				OPCODE_READ: equ 106 
1fee				OPCODE_EOF: equ 106 
1fee				OPCODE_FORMAT: equ 107 
1fee				OPCODE_LABEL: equ 108 
1fee				OPCODE_LABELS: equ 109 
1fee			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1fee				OPCODE_UPPER: equ 111 
1fee				OPCODE_LOWER: equ 112 
1fee				OPCODE_SUBSTR: equ 113 
1fee				OPCODE_LEFT: equ 114 
1fee				OPCODE_RIGHT: equ 115 
1fee				OPCODE_STR2NUM: equ 116 
1fee				OPCODE_NUM2STR: equ 117 
1fee				OPCODE_CONCAT: equ 118 
1fee				OPCODE_FIND: equ 119 
1fee				OPCODE_LEN: equ 120 
1fee				OPCODE_CHAR: equ 121 
1fee			; free to reuse	OPCODE_STRLEN: equ 122 
1fee			; free to reuse	OPCODE_ENDSTR: equ 123 
1fee				OPCODE_V0S: equ 124 
1fee				OPCODE_V0Q: equ 125 
1fee				OPCODE_V1S: equ 126 
1fee				OPCODE_V1Q: equ 127 
1fee				OPCODE_V2S: equ 128 
1fee				OPCODE_V2Q: equ 129 
1fee				OPCODE_V3S: equ 130 
1fee				OPCODE_V3Q: equ 131 
1fee			;free to reuse	OPCODE_END: equ 132 
1fee				OPCODE_ZDUP: equ 133 
1fee			 
1fee			; eof 
# End of file forth_opcodes.asm
1fee			 
1fee			include "forth_words_core.asm" 
1fee			 
1fee			; | ## Core Words 
1fee			 
1fee			;if MALLOC_4 
1fee			 
1fee			.HEAP: 
1fee			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1fee 15				db WORD_SYS_CORE+OPCODE_HEAP             
1fef 30 20			dw .EXEC            
1ff1 05				db 4 + 1 
1ff2 .. 00			db "HEAP",0              
1ff7				endm 
# End of macro CWHEAD
1ff7			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1ff7			; | | u1 - Current number of bytes in the heap 
1ff7			; | | u2 - Remaining bytes left on the heap 
1ff7			; | |  
1ff7			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1ff7			 
1ff7			 
1ff7				if DEBUG_FORTH_WORDS_KEY 
1ff7					DMARK "HEP" 
1ff7 f5				push af  
1ff8 3a 0c 20			ld a, (.dmark)  
1ffb 32 62 ee			ld (debug_mark),a  
1ffe 3a 0d 20			ld a, (.dmark+1)  
2001 32 63 ee			ld (debug_mark+1),a  
2004 3a 0e 20			ld a, (.dmark+2)  
2007 32 64 ee			ld (debug_mark+2),a  
200a 18 03			jr .pastdmark  
200c ..			.dmark: db "HEP"  
200f f1			.pastdmark: pop af  
2010			endm  
# End of macro DMARK
2010					CALLMONITOR 
2010 cd 6f ee			call debug_vector  
2013				endm  
# End of macro CALLMONITOR
2013				endif 
2013 2a d3 65			ld hl, (free_list )      
2016 11 d8 65			ld de, heap_start 
2019			 
2019 ed 52			sbc hl, de  
201b			 
201b cd d2 1a			call forth_push_numhl 
201e			 
201e			 
201e ed 5b d3 65		ld de, (free_list )      
2022 21 93 e2			ld hl, heap_end 
2025			 
2025 ed 52			sbc hl, de 
2027			 
2027 cd d2 1a			call forth_push_numhl 
202a				 
202a			 
202a				 
202a			 
202a			 
202a			 
202a				NEXTW 
202a cd 6c ee			call parse_vector 
202d c3 b5 1e			jp macro_next 
2030				endm 
# End of macro NEXTW
2030			;endif 
2030			 
2030			.EXEC: 
2030			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2030			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2030			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2030			;; > > 
2030			;; > >   
2030			;	STACKFRAME OFF $5efe $5f9f 
2030			; 
2030			;		if DEBUG_FORTH_WORDS_KEY 
2030			;			DMARK "EXE" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			; 
2030			;	FORTH_DSP_VALUEHL 
2030			; 
2030			;	FORTH_DSP_POP 
2030			; 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EX1" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;;	ld e,(hl) 
2030			;;	inc hl 
2030			;;	ld d,(hl) 
2030			;;	ex de,hl 
2030			; 
2030			;;		if DEBUG_FORTH_WORDS 
2030			;;			DMARK "EX2" 
2030			;;			CALLMONITOR 
2030			;;		endif 
2030			;	push hl 
2030			; 
2030			;	;ld a, 0 
2030			;	;ld a, FORTH_END_BUFFER 
2030			;	call strlenz 
2030			;	inc hl   ; include zero term to copy 
2030			;	inc hl   ; include term 
2030			;	inc hl   ; include term 
2030			;	ld b,0 
2030			;	ld c,l 
2030			;	pop hl 
2030			;	ld de, execscratch 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EX3" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;	ldir 
2030			; 
2030			; 
2030			;	ld hl, execscratch 
2030			; 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EXe" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			; 
2030			;	call forthparse 
2030			;	call forthexec 
2030			;;	call forthexec_cleanup 
2030			;;	call forthparse 
2030			;;	call forthexec 
2030			; 
2030			;	STACKFRAMECHK OFF $5efe $5f9f 
2030			; 
2030			;	; an immediate word so no need to process any more words 
2030			;	ret 
2030			;	NEXTW 
2030			 
2030			; dead code - old version  
2030			;	FORTH_RSP_NEXT 
2030			 
2030			;  
2030			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2030			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2030			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2030			;	push hl 
2030			;	push de 
2030			;	push bc 
2030			; 
2030			; 
2030			;		if DEBUG_FORTH_WORDS_KEY 
2030			;			DMARK "EXR" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			; 
2030			; 
2030			; 
2030			;	;v5 FORTH_DSP_VALUE 
2030			;	FORTH_DSP_VALUEHL 
2030			; 
2030			;	; TODO do string type checks 
2030			; 
2030			;;v5	inc hl   ; skip type 
2030			; 
2030			;	push hl  ; source code  
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EX1" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;	ld a, 0 
2030			;	call strlent 
2030			; 
2030			;	inc hl 
2030			;	inc hl 
2030			;	inc hl 
2030			;	inc hl 
2030			; 
2030			;	push hl    ; size 
2030			; 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EX2" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;	call malloc 
2030			; 
2030			;	ex de, hl    ; de now contains malloc area 
2030			;	pop bc   	; get byte count 
2030			;	pop hl      ; get string to copy 
2030			; 
2030			;	push de     ; save malloc for free later 
2030			; 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EX3" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;	ldir       ; duplicate string 
2030			; 
2030			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2030			;	 
2030			;	; TODO fix the parse would be better than this...  
2030			;	ex de, hl 
2030			;	dec hl 
2030			;	ld a, 0 
2030			;	ld (hl), a 
2030			;	dec hl 
2030			;	ld a, ' ' 
2030			;	ld (hl), a 
2030			;	dec hl 
2030			;	ld (hl), a 
2030			; 
2030			;	dec hl 
2030			;	ld (hl), a 
2030			; 
2030			; 
2030			;	FORTH_DSP_POP  
2030			; 
2030			;	pop hl     
2030			;	push hl    ; save malloc area 
2030			; 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EX4" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			; 
2030			;	call forthparse 
2030			;	call forthexec 
2030			;	 
2030			;	pop hl 
2030			;	if DEBUG_FORTH_WORDS 
2030			;		DMARK "EX5" 
2030			;		CALLMONITOR 
2030			;	endif 
2030			; 
2030			;	if FORTH_ENABLE_FREE 
2030			;	call free 
2030			;	endif 
2030			; 
2030			;	if DEBUG_FORTH_WORDS 
2030			;		DMARK "EX6" 
2030			;		CALLMONITOR 
2030			;	endif 
2030			; 
2030			;	pop bc 
2030			;	pop de 
2030			;	pop hl 
2030			;;	FORTH_RSP_POP	  
2030			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2030			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2030			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2030			; 
2030			;	if DEBUG_FORTH_WORDS 
2030			;		DMARK "EX7" 
2030			;		CALLMONITOR 
2030			;	endif 
2030			;	NEXTW 
2030			 
2030			;.STKEXEC: 
2030			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2030			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2030			; 
2030			; 
2030			;		if DEBUG_FORTH_WORDS_KEY 
2030			;			DMARK "STX" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			; 
2030			;	FORTH_DSP_VALUEHL 
2030			; 
2030			;	ld (store_tmp1), hl    ; count 
2030			; 
2030			;	FORTH_DSP_POP 
2030			;.stkexec1: 
2030			;	ld hl, (store_tmp1)   ; count 
2030			;	ld a, 0 
2030			;	cp l 
2030			;	ret z 
2030			; 
2030			;	dec hl 
2030			;	ld (store_tmp1), hl    ; count 
2030			;	 
2030			;	FORTH_DSP_VALUEHL 
2030			;	push hl 
2030			;	 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EXp" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;	FORTH_DSP_POP 
2030			; 
2030			;	call strlenz 
2030			;	inc hl   ; include zero term to copy 
2030			;	inc hl   ; include zero term to copy 
2030			;	inc hl   ; include zero term to copy 
2030			;	ld b,0 
2030			;	ld c,l 
2030			;	pop hl 
2030			;	ld de, execscratch 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EX3" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;	ldir 
2030			; 
2030			; 
2030			;	ld hl, execscratch 
2030			; 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EXP" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			; 
2030			;	call forthparse 
2030			;	ld hl, execscratch 
2030			;		if DEBUG_FORTH_WORDS 
2030			;			DMARK "EXx" 
2030			;			CALLMONITOR 
2030			;		endif 
2030			;	call forthexec 
2030			; 
2030			;	jp .stkexec1 
2030			; 
2030			;	ret 
2030			 
2030			 
2030			.DUP: 
2030			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2030 17				db WORD_SYS_CORE+OPCODE_DUP             
2031 ac 20			dw .ZDUP            
2033 04				db 3 + 1 
2034 .. 00			db "DUP",0              
2038				endm 
# End of macro CWHEAD
2038			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2038			; | | >[!NOTE] 
2038			; | | > If the duplicated item is a string it is safely duplicated 
2038			 
2038				if DEBUG_FORTH_WORDS_KEY 
2038					DMARK "DUP" 
2038 f5				push af  
2039 3a 4d 20			ld a, (.dmark)  
203c 32 62 ee			ld (debug_mark),a  
203f 3a 4e 20			ld a, (.dmark+1)  
2042 32 63 ee			ld (debug_mark+1),a  
2045 3a 4f 20			ld a, (.dmark+2)  
2048 32 64 ee			ld (debug_mark+2),a  
204b 18 03			jr .pastdmark  
204d ..			.dmark: db "DUP"  
2050 f1			.pastdmark: pop af  
2051			endm  
# End of macro DMARK
2051					CALLMONITOR 
2051 cd 6f ee			call debug_vector  
2054				endm  
# End of macro CALLMONITOR
2054				endif 
2054			 
2054				FORTH_DSP 
2054 cd 94 1c			call macro_forth_dsp 
2057				endm 
# End of macro FORTH_DSP
2057			 
2057 7e				ld a, (HL) 
2058 fe 01			cp DS_TYPE_STR 
205a 20 28			jr nz, .dupinum 
205c			 
205c				; push another string 
205c			 
205c				FORTH_DSP_VALUEHL     		 
205c cd ce 1c			call macro_dsp_valuehl 
205f				endm 
# End of macro FORTH_DSP_VALUEHL
205f			 
205f			if DEBUG_FORTH_WORDS 
205f				DMARK "DUs" 
205f f5				push af  
2060 3a 74 20			ld a, (.dmark)  
2063 32 62 ee			ld (debug_mark),a  
2066 3a 75 20			ld a, (.dmark+1)  
2069 32 63 ee			ld (debug_mark+1),a  
206c 3a 76 20			ld a, (.dmark+2)  
206f 32 64 ee			ld (debug_mark+2),a  
2072 18 03			jr .pastdmark  
2074 ..			.dmark: db "DUs"  
2077 f1			.pastdmark: pop af  
2078			endm  
# End of macro DMARK
2078				CALLMONITOR 
2078 cd 6f ee			call debug_vector  
207b				endm  
# End of macro CALLMONITOR
207b			endif 
207b cd 3c 1b			call forth_push_str 
207e			 
207e				NEXTW 
207e cd 6c ee			call parse_vector 
2081 c3 b5 1e			jp macro_next 
2084				endm 
# End of macro NEXTW
2084			 
2084			 
2084			.dupinum: 
2084				 
2084			 
2084			 
2084				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2084 cd ce 1c			call macro_dsp_valuehl 
2087				endm 
# End of macro FORTH_DSP_VALUEHL
2087			 
2087			; TODO add floating point number detection 
2087			 
2087			if DEBUG_FORTH_WORDS 
2087				DMARK "DUi" 
2087 f5				push af  
2088 3a 9c 20			ld a, (.dmark)  
208b 32 62 ee			ld (debug_mark),a  
208e 3a 9d 20			ld a, (.dmark+1)  
2091 32 63 ee			ld (debug_mark+1),a  
2094 3a 9e 20			ld a, (.dmark+2)  
2097 32 64 ee			ld (debug_mark+2),a  
209a 18 03			jr .pastdmark  
209c ..			.dmark: db "DUi"  
209f f1			.pastdmark: pop af  
20a0			endm  
# End of macro DMARK
20a0				CALLMONITOR 
20a0 cd 6f ee			call debug_vector  
20a3				endm  
# End of macro CALLMONITOR
20a3			endif 
20a3			 
20a3 cd d2 1a			call forth_push_numhl 
20a6				NEXTW 
20a6 cd 6c ee			call parse_vector 
20a9 c3 b5 1e			jp macro_next 
20ac				endm 
# End of macro NEXTW
20ac			.ZDUP: 
20ac			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
20ac 99				db WORD_SYS_CORE+OPCODE_ZDUP             
20ad e6 20			dw .DMRK            
20af 05				db 4 + 1 
20b0 .. 00			db "?DUP",0              
20b5				endm 
# End of macro CWHEAD
20b5			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
20b5			; | | >[!NOTE] 
20b5			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
20b5			 
20b5				if DEBUG_FORTH_WORDS_KEY 
20b5					DMARK "qDU" 
20b5 f5				push af  
20b6 3a ca 20			ld a, (.dmark)  
20b9 32 62 ee			ld (debug_mark),a  
20bc 3a cb 20			ld a, (.dmark+1)  
20bf 32 63 ee			ld (debug_mark+1),a  
20c2 3a cc 20			ld a, (.dmark+2)  
20c5 32 64 ee			ld (debug_mark+2),a  
20c8 18 03			jr .pastdmark  
20ca ..			.dmark: db "qDU"  
20cd f1			.pastdmark: pop af  
20ce			endm  
# End of macro DMARK
20ce					CALLMONITOR 
20ce cd 6f ee			call debug_vector  
20d1				endm  
# End of macro CALLMONITOR
20d1				endif 
20d1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20d1 cd ce 1c			call macro_dsp_valuehl 
20d4				endm 
# End of macro FORTH_DSP_VALUEHL
20d4			 
20d4 e5				push hl 
20d5			 
20d5				; is it a zero? 
20d5			 
20d5 3e 00			ld a, 0 
20d7 84				add h 
20d8 85				add l 
20d9			 
20d9 e1				pop hl 
20da			 
20da			;	cp 0 
20da b7				or a 
20db 28 03			jr z, .dup2orig 
20dd			 
20dd			 
20dd cd d2 1a			call forth_push_numhl 
20e0			 
20e0			 
20e0			; TODO add floating point number detection 
20e0			 
20e0			.dup2orig: 
20e0			 
20e0				NEXTW 
20e0 cd 6c ee			call parse_vector 
20e3 c3 b5 1e			jp macro_next 
20e6				endm 
# End of macro NEXTW
20e6			.DMRK: 
20e6			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
20e6 99				db WORD_SYS_CORE+OPCODE_ZDUP             
20e7 26 21			dw .LSHIFT            
20e9 06				db 5 + 1 
20ea .. 00			db "DMARK",0              
20f0				endm 
# End of macro CWHEAD
20f0			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
20f0			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
20f0				if DEBUG_FORTH_WORDS_KEY 
20f0					DMARK "DMK" 
20f0 f5				push af  
20f1 3a 05 21			ld a, (.dmark)  
20f4 32 62 ee			ld (debug_mark),a  
20f7 3a 06 21			ld a, (.dmark+1)  
20fa 32 63 ee			ld (debug_mark+1),a  
20fd 3a 07 21			ld a, (.dmark+2)  
2100 32 64 ee			ld (debug_mark+2),a  
2103 18 03			jr .pastdmark  
2105 ..			.dmark: db "DMK"  
2108 f1			.pastdmark: pop af  
2109			endm  
# End of macro DMARK
2109					CALLMONITOR 
2109 cd 6f ee			call debug_vector  
210c				endm  
# End of macro CALLMONITOR
210c				endif 
210c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
210c cd ce 1c			call macro_dsp_valuehl 
210f				endm 
# End of macro FORTH_DSP_VALUEHL
210f			 
210f 7e				ld a, (hl) 
2110 32 62 ee			ld (debug_mark),a 
2113 23				inc hl 
2114 7e				ld a, (hl) 
2115 32 63 ee			ld (debug_mark+1),a 
2118 23				inc hl 
2119 7e				ld a, (hl) 
211a 32 64 ee			ld (debug_mark+2),a 
211d			 
211d			 
211d				FORTH_DSP_POP 
211d cd 86 1d			call macro_forth_dsp_pop 
2120				endm 
# End of macro FORTH_DSP_POP
2120				NEXTW 
2120 cd 6c ee			call parse_vector 
2123 c3 b5 1e			jp macro_next 
2126				endm 
# End of macro NEXTW
2126			.LSHIFT: 
2126			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
2126 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2127 5d 21			dw .RSHIFT            
2129 07				db 6 + 1 
212a .. 00			db "LSHIFT",0              
2131				endm 
# End of macro CWHEAD
2131			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2131				if DEBUG_FORTH_WORDS_KEY 
2131					DMARK "LSH" 
2131 f5				push af  
2132 3a 46 21			ld a, (.dmark)  
2135 32 62 ee			ld (debug_mark),a  
2138 3a 47 21			ld a, (.dmark+1)  
213b 32 63 ee			ld (debug_mark+1),a  
213e 3a 48 21			ld a, (.dmark+2)  
2141 32 64 ee			ld (debug_mark+2),a  
2144 18 03			jr .pastdmark  
2146 ..			.dmark: db "LSH"  
2149 f1			.pastdmark: pop af  
214a			endm  
# End of macro DMARK
214a					CALLMONITOR 
214a cd 6f ee			call debug_vector  
214d				endm  
# End of macro CALLMONITOR
214d				endif 
214d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
214d cd ce 1c			call macro_dsp_valuehl 
2150				endm 
# End of macro FORTH_DSP_VALUEHL
2150				FORTH_DSP_POP 
2150 cd 86 1d			call macro_forth_dsp_pop 
2153				endm 
# End of macro FORTH_DSP_POP
2153			 
2153 29				add hl, hl 
2154 cd d2 1a			call forth_push_numhl 
2157				NEXTW 
2157 cd 6c ee			call parse_vector 
215a c3 b5 1e			jp macro_next 
215d				endm 
# End of macro NEXTW
215d			.RSHIFT: 
215d			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
215d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
215e 97 21			dw .SWAP            
2160 07				db 6 + 1 
2161 .. 00			db "RSHIFT",0              
2168				endm 
# End of macro CWHEAD
2168			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
2168				if DEBUG_FORTH_WORDS_KEY 
2168					DMARK "RSH" 
2168 f5				push af  
2169 3a 7d 21			ld a, (.dmark)  
216c 32 62 ee			ld (debug_mark),a  
216f 3a 7e 21			ld a, (.dmark+1)  
2172 32 63 ee			ld (debug_mark+1),a  
2175 3a 7f 21			ld a, (.dmark+2)  
2178 32 64 ee			ld (debug_mark+2),a  
217b 18 03			jr .pastdmark  
217d ..			.dmark: db "RSH"  
2180 f1			.pastdmark: pop af  
2181			endm  
# End of macro DMARK
2181					CALLMONITOR 
2181 cd 6f ee			call debug_vector  
2184				endm  
# End of macro CALLMONITOR
2184				endif 
2184				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2184 cd ce 1c			call macro_dsp_valuehl 
2187				endm 
# End of macro FORTH_DSP_VALUEHL
2187				FORTH_DSP_POP 
2187 cd 86 1d			call macro_forth_dsp_pop 
218a				endm 
# End of macro FORTH_DSP_POP
218a cb 3c			srl h 
218c cb 1d			rr l 
218e cd d2 1a			call forth_push_numhl 
2191				NEXTW 
2191 cd 6c ee			call parse_vector 
2194 c3 b5 1e			jp macro_next 
2197				endm 
# End of macro NEXTW
2197			.SWAP: 
2197			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2197 18				db WORD_SYS_CORE+OPCODE_SWAP             
2198 ee 21			dw .COLN            
219a 05				db 4 + 1 
219b .. 00			db "SWAP",0              
21a0				endm 
# End of macro CWHEAD
21a0			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21a0				if DEBUG_FORTH_WORDS_KEY 
21a0					DMARK "SWP" 
21a0 f5				push af  
21a1 3a b5 21			ld a, (.dmark)  
21a4 32 62 ee			ld (debug_mark),a  
21a7 3a b6 21			ld a, (.dmark+1)  
21aa 32 63 ee			ld (debug_mark+1),a  
21ad 3a b7 21			ld a, (.dmark+2)  
21b0 32 64 ee			ld (debug_mark+2),a  
21b3 18 03			jr .pastdmark  
21b5 ..			.dmark: db "SWP"  
21b8 f1			.pastdmark: pop af  
21b9			endm  
# End of macro DMARK
21b9					CALLMONITOR 
21b9 cd 6f ee			call debug_vector  
21bc				endm  
# End of macro CALLMONITOR
21bc				endif 
21bc			 
21bc			; DONE Use os stack swap memory 
21bc			 
21bc				FORTH_DSP_PTR 0     ; TOS 
21bc 2a e5 e9			ld hl,(cli_data_sp) 
21bf 11 00 00			ld de, 0 * 3 
21c2 ed 52			sbc hl, de 
21c4				endm 
# End of macro FORTH_DSP_PTR
21c4 cd 05 1e			call hltostack1 
21c7			  
21c7				FORTH_DSP_PTR 1     ; TOS 
21c7 2a e5 e9			ld hl,(cli_data_sp) 
21ca 11 03 00			ld de, 1 * 3 
21cd ed 52			sbc hl, de 
21cf				endm 
# End of macro FORTH_DSP_PTR
21cf cd 0b 1e			call hltostack2 
21d2			 
21d2				FORTH_DSP_PTR 0     ; TOS 
21d2 2a e5 e9			ld hl,(cli_data_sp) 
21d5 11 00 00			ld de, 0 * 3 
21d8 ed 52			sbc hl, de 
21da				endm 
# End of macro FORTH_DSP_PTR
21da cd 23 1e			call hlfromstack2 
21dd			 
21dd				FORTH_DSP_PTR 1     ; TOS 
21dd 2a e5 e9			ld hl,(cli_data_sp) 
21e0 11 03 00			ld de, 1 * 3 
21e3 ed 52			sbc hl, de 
21e5				endm 
# End of macro FORTH_DSP_PTR
21e5 cd 1d 1e			call hlfromstack1 
21e8			;	FORTH_DSP_VALUEHL 
21e8			;	push hl     ; w2 
21e8			; 
21e8			;	FORTH_DSP_POP 
21e8			; 
21e8			;	FORTH_DSP_VALUEHL 
21e8			; 
21e8			;	FORTH_DSP_POP 
21e8			; 
21e8			;	pop de     ; w2	, hl = w1 
21e8			; 
21e8			;	ex de, hl 
21e8			;	push de 
21e8			; 
21e8			;	call forth_push_numhl 
21e8			; 
21e8			;	pop hl 
21e8			; 
21e8			;	call forth_push_numhl 
21e8				 
21e8			 
21e8				NEXTW 
21e8 cd 6c ee			call parse_vector 
21eb c3 b5 1e			jp macro_next 
21ee				endm 
# End of macro NEXTW
21ee			.COLN: 
21ee			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21ee 19				db WORD_SYS_CORE+OPCODE_COLN             
21ef 79 23			dw .SCOLN            
21f1 02				db 1 + 1 
21f2 .. 00			db ":",0              
21f4				endm 
# End of macro CWHEAD
21f4			; | : ( -- )         Create new word | DONE 
21f4			 
21f4				if DEBUG_FORTH_WORDS_KEY 
21f4					DMARK "CLN" 
21f4 f5				push af  
21f5 3a 09 22			ld a, (.dmark)  
21f8 32 62 ee			ld (debug_mark),a  
21fb 3a 0a 22			ld a, (.dmark+1)  
21fe 32 63 ee			ld (debug_mark+1),a  
2201 3a 0b 22			ld a, (.dmark+2)  
2204 32 64 ee			ld (debug_mark+2),a  
2207 18 03			jr .pastdmark  
2209 ..			.dmark: db "CLN"  
220c f1			.pastdmark: pop af  
220d			endm  
# End of macro DMARK
220d					CALLMONITOR 
220d cd 6f ee			call debug_vector  
2210				endm  
# End of macro CALLMONITOR
2210				endif 
2210			STACKFRAME OFF $8efe $989f 
2210				if DEBUG_STACK_IMB 
2210					if OFF 
2210						exx 
2210						ld de, $8efe 
2210						ld a, d 
2210						ld hl, curframe 
2210						call hexout 
2210						ld a, e 
2210						ld hl, curframe+2 
2210						call hexout 
2210						ld hl, $8efe 
2210						push hl 
2210						ld hl, $989f 
2210						push hl 
2210						exx 
2210					endif 
2210				endif 
2210			endm 
# End of macro STACKFRAME
2210			; get parser buffer length  of new word 
2210			 
2210			 
2210			 
2210				; move tok past this to start of name defintition 
2210				; TODO get word to define 
2210				; TODO Move past word token 
2210				; TODO get length of string up to the ';' 
2210			 
2210 2a b9 e5		ld hl, (os_tok_ptr) 
2213 23			inc hl 
2214 23			inc hl 
2215			 
2215 3e 3b		ld a, ';' 
2217 cd 44 11		call strlent 
221a			 
221a 7d			ld a,l 
221b 32 a8 e2		ld (os_new_parse_len), a 
221e			 
221e			 
221e			if DEBUG_FORTH_UWORD 
221e ed 5b b9 e5	ld de, (os_tok_ptr) 
2222					DMARK ":01" 
2222 f5				push af  
2223 3a 37 22			ld a, (.dmark)  
2226 32 62 ee			ld (debug_mark),a  
2229 3a 38 22			ld a, (.dmark+1)  
222c 32 63 ee			ld (debug_mark+1),a  
222f 3a 39 22			ld a, (.dmark+2)  
2232 32 64 ee			ld (debug_mark+2),a  
2235 18 03			jr .pastdmark  
2237 ..			.dmark: db ":01"  
223a f1			.pastdmark: pop af  
223b			endm  
# End of macro DMARK
223b			CALLMONITOR 
223b cd 6f ee			call debug_vector  
223e				endm  
# End of macro CALLMONITOR
223e			endif 
223e			 
223e			; 
223e			;  new word memory layout: 
223e			;  
223e			;    : adg 6666 ;  
223e			; 
223e			;    db   1     ; user defined word  
223e 23			inc hl    
223f			;    dw   sysdict 
223f 23			inc hl 
2240 23			inc hl 
2241			;    db <word len>+1 (for null) 
2241 23			inc hl 
2242			;    db .... <word> 
2242			; 
2242			 
2242 23			inc hl    ; some extras for the word preamble before the above 
2243 23			inc hl 
2244 23			inc hl 
2245 23			inc hl 
2246 23			inc hl 
2247 23			inc hl 
2248 23			inc hl  
2249 23			inc hl 
224a 23			inc hl 
224b 23			inc hl 
224c 23			inc hl 
224d 23			inc hl 
224e 23			inc hl 
224f 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2250			;       exec word buffer 
2250			;	<ptr word>   
2250 23			inc hl 
2251 23			inc hl 
2252			;       <word list><null term> 7F final term 
2252			 
2252			 
2252			if DEBUG_FORTH_UWORD 
2252					DMARK ":02" 
2252 f5				push af  
2253 3a 67 22			ld a, (.dmark)  
2256 32 62 ee			ld (debug_mark),a  
2259 3a 68 22			ld a, (.dmark+1)  
225c 32 63 ee			ld (debug_mark+1),a  
225f 3a 69 22			ld a, (.dmark+2)  
2262 32 64 ee			ld (debug_mark+2),a  
2265 18 03			jr .pastdmark  
2267 ..			.dmark: db ":02"  
226a f1			.pastdmark: pop af  
226b			endm  
# End of macro DMARK
226b			CALLMONITOR 
226b cd 6f ee			call debug_vector  
226e				endm  
# End of macro CALLMONITOR
226e			endif 
226e			 
226e			 
226e				; malloc the size 
226e			 
226e cd ad 11			call malloc 
2271 22 aa e2			ld (os_new_malloc), hl     ; save malloc start 
2274			 
2274			;    db   1     ; user defined word  
2274			;	ld a, WORD_SYS_UWORD  
2274 36 01			ld (hl), WORD_SYS_UWORD 
2276			 
2276 23			inc hl    
2277			;    dw   sysdict 
2277 11 ee 1f		ld de, sysdict       ; continue on with the scan to the system dict 
227a 73			ld (hl), e 
227b 23			inc hl 
227c 72			ld (hl), d 
227d 23			inc hl 
227e			 
227e			 
227e			;    Setup dict word 
227e			 
227e 23			inc hl 
227f 22 a4 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2282			 
2282			; 1. get length of dict word 
2282			 
2282			 
2282 2a b9 e5		ld hl, (os_tok_ptr) 
2285 23			inc hl 
2286 23			inc hl    ; position to start of dict word 
2287 3e 00		ld a, 0 
2289 cd 44 11		call strlent 
228c			 
228c			 
228c 23			inc hl    ; to include null??? 
228d			 
228d			; write length of dict word 
228d			 
228d ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2291 1b			dec de 
2292 eb			ex de, hl 
2293 73			ld (hl), e 
2294 eb			ex de, hl 
2295			 
2295			 
2295			 
2295			; copy  
2295 4d			ld c, l 
2296 06 00		ld b, 0 
2298 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
229c 2a b9 e5		ld hl, (os_tok_ptr) 
229f 23			inc hl 
22a0 23			inc hl    ; position to start of dict word 
22a1			 
22a1			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22a1			 
22a1			; TODO need to convert word to upper case 
22a1			 
22a1			ucasetok:	 
22a1 7e			ld a,(hl) 
22a2 cd 30 11		call toUpper 
22a5 77			ld (hl),a 
22a6 ed a0		ldi 
22a8 f2 a1 22		jp p, ucasetok 
22ab			 
22ab			 
22ab			 
22ab			; de now points to start of where the word body code should be placed 
22ab ed 53 a4 e2	ld (os_new_work_ptr), de 
22af			; hl now points to the words to throw at forthexec which needs to be copied 
22af 22 a2 e2		ld (os_new_src_ptr), hl 
22b2			 
22b2			; TODO add 'call to forthexec' 
22b2			 
22b2			if DEBUG_FORTH_UWORD 
22b2 c5			push bc 
22b3 ed 4b aa e2	ld bc, (os_new_malloc) 
22b7					DMARK ":0x" 
22b7 f5				push af  
22b8 3a cc 22			ld a, (.dmark)  
22bb 32 62 ee			ld (debug_mark),a  
22be 3a cd 22			ld a, (.dmark+1)  
22c1 32 63 ee			ld (debug_mark+1),a  
22c4 3a ce 22			ld a, (.dmark+2)  
22c7 32 64 ee			ld (debug_mark+2),a  
22ca 18 03			jr .pastdmark  
22cc ..			.dmark: db ":0x"  
22cf f1			.pastdmark: pop af  
22d0			endm  
# End of macro DMARK
22d0			CALLMONITOR 
22d0 cd 6f ee			call debug_vector  
22d3				endm  
# End of macro CALLMONITOR
22d3 c1			pop bc 
22d4			endif 
22d4			 
22d4			 
22d4			; create word preamble which should be: 
22d4			 
22d4			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
22d4			 
22d4			;    ld hl, <word code> 
22d4			;    jp user_exec 
22d4			;    <word code bytes> 
22d4			 
22d4			 
22d4			;	inc de     ; TODO ??? or are we already past the word's null 
22d4 eb			ex de, hl 
22d5			 
22d5 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22d7			 
22d7 23			inc hl 
22d8 22 9e e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22db 23			inc hl 
22dc			 
22dc 23			inc hl 
22dd 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22df			 
22df 01 51 53		ld bc, user_exec 
22e2 23			inc hl 
22e3 71			ld (hl), c     ; poke address of user_exec 
22e4 23			inc hl 
22e5 70			ld (hl), b     
22e6			; 
22e6			;	inc hl 
22e6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22e6			; 
22e6			; 
22e6			;	ld bc, macro_forth_rsp_next 
22e6			;	inc hl 
22e6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22e6			;	inc hl 
22e6			;	ld (hl), b     
22e6			; 
22e6			;	inc hl 
22e6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22e6			; 
22e6			; 
22e6			;	inc hl 
22e6			;	ld bc, forthexec 
22e6			;	ld (hl), c     ; poke address of forthexec 
22e6			;	inc hl 
22e6			;	ld (hl), b      
22e6			; 
22e6			;	inc hl 
22e6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22e6			; 
22e6			;	ld bc, user_dict_next 
22e6			;	inc hl 
22e6			;	ld (hl), c     ; poke address of forthexec 
22e6			;	inc hl 
22e6			;	ld (hl), b      
22e6			 
22e6			; hl is now where we need to copy the word byte data to save this 
22e6			 
22e6 23			inc hl 
22e7 22 a0 e2		ld (os_new_exec), hl 
22ea			 
22ea			; copy definition 
22ea			 
22ea eb			ex de, hl 
22eb			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22eb			;	inc de    ; skip the PC for this parse 
22eb 3a a8 e2		ld a, (os_new_parse_len) 
22ee 4f			ld c, a 
22ef 06 00		ld b, 0 
22f1 ed b0		ldir		 ; copy defintion 
22f3			 
22f3			 
22f3			; poke the address of where the new word bytes live for forthexec 
22f3			 
22f3 2a 9e e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22f6			 
22f6 ed 5b a0 e2	ld de, (os_new_exec)      
22fa			 
22fa 73			ld (hl), e 
22fb 23			inc hl 
22fc 72			ld (hl), d 
22fd			 
22fd				; TODO copy last user dict word next link to this word 
22fd				; TODO update last user dict word to point to this word 
22fd			; 
22fd			; hl f923 de 812a ; bc 811a 
22fd			 
22fd			if DEBUG_FORTH_UWORD 
22fd c5			push bc 
22fe ed 4b aa e2	ld bc, (os_new_malloc) 
2302					DMARK ":0A" 
2302 f5				push af  
2303 3a 17 23			ld a, (.dmark)  
2306 32 62 ee			ld (debug_mark),a  
2309 3a 18 23			ld a, (.dmark+1)  
230c 32 63 ee			ld (debug_mark+1),a  
230f 3a 19 23			ld a, (.dmark+2)  
2312 32 64 ee			ld (debug_mark+2),a  
2315 18 03			jr .pastdmark  
2317 ..			.dmark: db ":0A"  
231a f1			.pastdmark: pop af  
231b			endm  
# End of macro DMARK
231b			CALLMONITOR 
231b cd 6f ee			call debug_vector  
231e				endm  
# End of macro CALLMONITOR
231e c1			pop bc 
231f			endif 
231f			if DEBUG_FORTH_UWORD 
231f c5			push bc 
2320 ed 4b aa e2	ld bc, (os_new_malloc) 
2324 03			inc bc 
2325 03			inc bc 
2326 03			inc bc 
2327 03			inc bc 
2328 03			inc bc 
2329 03			inc bc 
232a 03			inc bc 
232b 03			inc bc 
232c			 
232c					DMARK ":0B" 
232c f5				push af  
232d 3a 41 23			ld a, (.dmark)  
2330 32 62 ee			ld (debug_mark),a  
2333 3a 42 23			ld a, (.dmark+1)  
2336 32 63 ee			ld (debug_mark+1),a  
2339 3a 43 23			ld a, (.dmark+2)  
233c 32 64 ee			ld (debug_mark+2),a  
233f 18 03			jr .pastdmark  
2341 ..			.dmark: db ":0B"  
2344 f1			.pastdmark: pop af  
2345			endm  
# End of macro DMARK
2345			CALLMONITOR 
2345 cd 6f ee			call debug_vector  
2348				endm  
# End of macro CALLMONITOR
2348 c1			pop bc 
2349			endif 
2349			 
2349			; update word dict linked list for new word 
2349			 
2349			 
2349 2a b5 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
234c 23			inc hl     ; move to next work linked list ptr 
234d			 
234d ed 5b aa e2	ld de, (os_new_malloc)		 ; new next word 
2351 73			ld (hl), e 
2352 23			inc hl 
2353 72			ld (hl), d 
2354			 
2354			if DEBUG_FORTH_UWORD 
2354 ed 4b b5 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2358			endif 
2358			 
2358 ed 53 b5 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
235c			 
235c			 
235c			if DEBUG_FORTH_UWORD 
235c					DMARK ":0+" 
235c f5				push af  
235d 3a 71 23			ld a, (.dmark)  
2360 32 62 ee			ld (debug_mark),a  
2363 3a 72 23			ld a, (.dmark+1)  
2366 32 63 ee			ld (debug_mark+1),a  
2369 3a 73 23			ld a, (.dmark+2)  
236c 32 64 ee			ld (debug_mark+2),a  
236f 18 03			jr .pastdmark  
2371 ..			.dmark: db ":0+"  
2374 f1			.pastdmark: pop af  
2375			endm  
# End of macro DMARK
2375			CALLMONITOR 
2375 cd 6f ee			call debug_vector  
2378				endm  
# End of macro CALLMONITOR
2378			endif 
2378			 
2378			STACKFRAMECHK OFF $8efe $989f 
2378				if DEBUG_STACK_IMB 
2378					if OFF 
2378						exx 
2378						ld hl, $989f 
2378						pop de   ; $989f 
2378						call cmp16 
2378						jr nz, .spnosame 
2378						ld hl, $8efe 
2378						pop de   ; $8efe 
2378						call cmp16 
2378						jr z, .spfrsame 
2378						.spnosame: call showsperror 
2378						.spfrsame: nop 
2378						exx 
2378					endif 
2378				endif 
2378			endm 
# End of macro STACKFRAMECHK
2378			 
2378 c9			ret    ; dont process any remaining parser tokens as they form new word 
2379			 
2379			 
2379			 
2379			 
2379			;		NEXT 
2379			.SCOLN: 
2379			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2379 06			db OPCODE_SCOLN 
237a c8 23		dw .DROP 
237c 02			db 2 
237d .. 00		db ";",0           
237f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
237f				if DEBUG_FORTH_WORDS_KEY 
237f					DMARK "SCN" 
237f f5				push af  
2380 3a 94 23			ld a, (.dmark)  
2383 32 62 ee			ld (debug_mark),a  
2386 3a 95 23			ld a, (.dmark+1)  
2389 32 63 ee			ld (debug_mark+1),a  
238c 3a 96 23			ld a, (.dmark+2)  
238f 32 64 ee			ld (debug_mark+2),a  
2392 18 03			jr .pastdmark  
2394 ..			.dmark: db "SCN"  
2397 f1			.pastdmark: pop af  
2398			endm  
# End of macro DMARK
2398					CALLMONITOR 
2398 cd 6f ee			call debug_vector  
239b				endm  
# End of macro CALLMONITOR
239b				endif 
239b				FORTH_RSP_TOS 
239b cd 90 1a			call macro_forth_rsp_tos 
239e				endm 
# End of macro FORTH_RSP_TOS
239e e5				push hl 
239f				FORTH_RSP_POP 
239f cd 9a 1a			call macro_forth_rsp_pop 
23a2				endm 
# End of macro FORTH_RSP_POP
23a2 e1				pop hl 
23a3			;		ex de,hl 
23a3 22 b9 e5			ld (os_tok_ptr),hl 
23a6			 
23a6			if DEBUG_FORTH_UWORD 
23a6					DMARK "SCL" 
23a6 f5				push af  
23a7 3a bb 23			ld a, (.dmark)  
23aa 32 62 ee			ld (debug_mark),a  
23ad 3a bc 23			ld a, (.dmark+1)  
23b0 32 63 ee			ld (debug_mark+1),a  
23b3 3a bd 23			ld a, (.dmark+2)  
23b6 32 64 ee			ld (debug_mark+2),a  
23b9 18 03			jr .pastdmark  
23bb ..			.dmark: db "SCL"  
23be f1			.pastdmark: pop af  
23bf			endm  
# End of macro DMARK
23bf			CALLMONITOR 
23bf cd 6f ee			call debug_vector  
23c2				endm  
# End of macro CALLMONITOR
23c2			endif 
23c2				NEXTW 
23c2 cd 6c ee			call parse_vector 
23c5 c3 b5 1e			jp macro_next 
23c8				endm 
# End of macro NEXTW
23c8			 
23c8			.DROP: 
23c8			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23c8 1b				db WORD_SYS_CORE+OPCODE_DROP             
23c9 f6 23			dw .DUP2            
23cb 05				db 4 + 1 
23cc .. 00			db "DROP",0              
23d1				endm 
# End of macro CWHEAD
23d1			; | DROP ( w -- )   drop the TOS item   | DONE 
23d1				if DEBUG_FORTH_WORDS_KEY 
23d1					DMARK "DRP" 
23d1 f5				push af  
23d2 3a e6 23			ld a, (.dmark)  
23d5 32 62 ee			ld (debug_mark),a  
23d8 3a e7 23			ld a, (.dmark+1)  
23db 32 63 ee			ld (debug_mark+1),a  
23de 3a e8 23			ld a, (.dmark+2)  
23e1 32 64 ee			ld (debug_mark+2),a  
23e4 18 03			jr .pastdmark  
23e6 ..			.dmark: db "DRP"  
23e9 f1			.pastdmark: pop af  
23ea			endm  
# End of macro DMARK
23ea					CALLMONITOR 
23ea cd 6f ee			call debug_vector  
23ed				endm  
# End of macro CALLMONITOR
23ed				endif 
23ed				FORTH_DSP_POP 
23ed cd 86 1d			call macro_forth_dsp_pop 
23f0				endm 
# End of macro FORTH_DSP_POP
23f0				NEXTW 
23f0 cd 6c ee			call parse_vector 
23f3 c3 b5 1e			jp macro_next 
23f6				endm 
# End of macro NEXTW
23f6			.DUP2: 
23f6			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23f6 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23f7 3e 24			dw .DROP2            
23f9 05				db 4 + 1 
23fa .. 00			db "2DUP",0              
23ff				endm 
# End of macro CWHEAD
23ff			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
23ff			; | | >[!NOTE] 
23ff			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
23ff				if DEBUG_FORTH_WORDS_KEY 
23ff					DMARK "2DU" 
23ff f5				push af  
2400 3a 14 24			ld a, (.dmark)  
2403 32 62 ee			ld (debug_mark),a  
2406 3a 15 24			ld a, (.dmark+1)  
2409 32 63 ee			ld (debug_mark+1),a  
240c 3a 16 24			ld a, (.dmark+2)  
240f 32 64 ee			ld (debug_mark+2),a  
2412 18 03			jr .pastdmark  
2414 ..			.dmark: db "2DU"  
2417 f1			.pastdmark: pop af  
2418			endm  
# End of macro DMARK
2418					CALLMONITOR 
2418 cd 6f ee			call debug_vector  
241b				endm  
# End of macro CALLMONITOR
241b				endif 
241b				FORTH_DSP_VALUEHL 
241b cd ce 1c			call macro_dsp_valuehl 
241e				endm 
# End of macro FORTH_DSP_VALUEHL
241e e5				push hl      ; 2 
241f			 
241f				FORTH_DSP_POP 
241f cd 86 1d			call macro_forth_dsp_pop 
2422				endm 
# End of macro FORTH_DSP_POP
2422				 
2422				FORTH_DSP_VALUEHL 
2422 cd ce 1c			call macro_dsp_valuehl 
2425				endm 
# End of macro FORTH_DSP_VALUEHL
2425			;		push hl      ; 1 
2425			 
2425				FORTH_DSP_POP 
2425 cd 86 1d			call macro_forth_dsp_pop 
2428				endm 
# End of macro FORTH_DSP_POP
2428			 
2428			;		pop hl       ; 1 
2428 d1				pop de       ; 2 
2429			 
2429 cd d2 1a			call forth_push_numhl 
242c eb				ex de, hl 
242d cd d2 1a			call forth_push_numhl 
2430			 
2430				 
2430 eb				ex de, hl 
2431			 
2431 cd d2 1a			call forth_push_numhl 
2434 eb				ex de, hl 
2435 cd d2 1a			call forth_push_numhl 
2438			 
2438			 
2438				NEXTW 
2438 cd 6c ee			call parse_vector 
243b c3 b5 1e			jp macro_next 
243e				endm 
# End of macro NEXTW
243e			.DROP2: 
243e			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
243e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
243f 70 24			dw .PICK            
2441 06				db 5 + 1 
2442 .. 00			db "2DROP",0              
2448				endm 
# End of macro CWHEAD
2448			; | 2DROP ( w w -- )    Double drop | DONE 
2448				if DEBUG_FORTH_WORDS_KEY 
2448					DMARK "2DR" 
2448 f5				push af  
2449 3a 5d 24			ld a, (.dmark)  
244c 32 62 ee			ld (debug_mark),a  
244f 3a 5e 24			ld a, (.dmark+1)  
2452 32 63 ee			ld (debug_mark+1),a  
2455 3a 5f 24			ld a, (.dmark+2)  
2458 32 64 ee			ld (debug_mark+2),a  
245b 18 03			jr .pastdmark  
245d ..			.dmark: db "2DR"  
2460 f1			.pastdmark: pop af  
2461			endm  
# End of macro DMARK
2461					CALLMONITOR 
2461 cd 6f ee			call debug_vector  
2464				endm  
# End of macro CALLMONITOR
2464				endif 
2464				FORTH_DSP_POP 
2464 cd 86 1d			call macro_forth_dsp_pop 
2467				endm 
# End of macro FORTH_DSP_POP
2467				FORTH_DSP_POP 
2467 cd 86 1d			call macro_forth_dsp_pop 
246a				endm 
# End of macro FORTH_DSP_POP
246a				NEXTW 
246a cd 6c ee			call parse_vector 
246d c3 b5 1e			jp macro_next 
2470				endm 
# End of macro NEXTW
2470			.PICK: 
2470			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2470 77				db WORD_SYS_CORE+99             
2471 0d 25			dw .SWAP2            
2473 05				db 4 + 1 
2474 .. 00			db "PICK",0              
2479				endm 
# End of macro CWHEAD
2479			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
2479			; | | >[!NOTE] 
2479			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
2479				if DEBUG_FORTH_WORDS_KEY 
2479					DMARK "PIK" 
2479 f5				push af  
247a 3a 8e 24			ld a, (.dmark)  
247d 32 62 ee			ld (debug_mark),a  
2480 3a 8f 24			ld a, (.dmark+1)  
2483 32 63 ee			ld (debug_mark+1),a  
2486 3a 90 24			ld a, (.dmark+2)  
2489 32 64 ee			ld (debug_mark+2),a  
248c 18 03			jr .pastdmark  
248e ..			.dmark: db "PIK"  
2491 f1			.pastdmark: pop af  
2492			endm  
# End of macro DMARK
2492					CALLMONITOR 
2492 cd 6f ee			call debug_vector  
2495				endm  
# End of macro CALLMONITOR
2495				endif 
2495			 
2495				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2495 cd ce 1c			call macro_dsp_valuehl 
2498				endm 
# End of macro FORTH_DSP_VALUEHL
2498				 
2498				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2498 cd 86 1d			call macro_forth_dsp_pop 
249b				endm 
# End of macro FORTH_DSP_POP
249b			 
249b				; init from TOS 
249b e5				push hl 
249c				FORTH_DSP 
249c cd 94 1c			call macro_forth_dsp 
249f				endm 
# End of macro FORTH_DSP
249f			;	ld hl, cli_data_sp 
249f				if DEBUG_FORTH_WORDS 
249f					DMARK "PK1" 
249f f5				push af  
24a0 3a b4 24			ld a, (.dmark)  
24a3 32 62 ee			ld (debug_mark),a  
24a6 3a b5 24			ld a, (.dmark+1)  
24a9 32 63 ee			ld (debug_mark+1),a  
24ac 3a b6 24			ld a, (.dmark+2)  
24af 32 64 ee			ld (debug_mark+2),a  
24b2 18 03			jr .pastdmark  
24b4 ..			.dmark: db "PK1"  
24b7 f1			.pastdmark: pop af  
24b8			endm  
# End of macro DMARK
24b8					CALLMONITOR 
24b8 cd 6f ee			call debug_vector  
24bb				endm  
# End of macro CALLMONITOR
24bb				endif 
24bb c1				pop bc 
24bc 41				ld b,c 
24bd 3e 00			ld a, 0 
24bf b8				cp b 
24c0 28 21			jr z, .pdone	 
24c2			.pkl: 
24c2 2b				dec hl 
24c3 2b				dec hl 
24c4 2b				dec hl 
24c5			 
24c5				if DEBUG_FORTH_WORDS 
24c5					DMARK "PKl" 
24c5 f5				push af  
24c6 3a da 24			ld a, (.dmark)  
24c9 32 62 ee			ld (debug_mark),a  
24cc 3a db 24			ld a, (.dmark+1)  
24cf 32 63 ee			ld (debug_mark+1),a  
24d2 3a dc 24			ld a, (.dmark+2)  
24d5 32 64 ee			ld (debug_mark+2),a  
24d8 18 03			jr .pastdmark  
24da ..			.dmark: db "PKl"  
24dd f1			.pastdmark: pop af  
24de			endm  
# End of macro DMARK
24de					CALLMONITOR 
24de cd 6f ee			call debug_vector  
24e1				endm  
# End of macro CALLMONITOR
24e1				endif 
24e1 10 df			djnz .pkl 
24e3			.pdone: 
24e3				 
24e3				; TODO do type check with correct push 
24e3			 
24e3 23				inc hl 
24e4				;call loadwordinhl 
24e4 5e				ld e, (hl) 
24e5 23				inc hl 
24e6 56				ld d, (hl) 
24e7 eb				ex de,hl 
24e8				if DEBUG_FORTH_WORDS 
24e8					DMARK "PKp" 
24e8 f5				push af  
24e9 3a fd 24			ld a, (.dmark)  
24ec 32 62 ee			ld (debug_mark),a  
24ef 3a fe 24			ld a, (.dmark+1)  
24f2 32 63 ee			ld (debug_mark+1),a  
24f5 3a ff 24			ld a, (.dmark+2)  
24f8 32 64 ee			ld (debug_mark+2),a  
24fb 18 03			jr .pastdmark  
24fd ..			.dmark: db "PKp"  
2500 f1			.pastdmark: pop af  
2501			endm  
# End of macro DMARK
2501					CALLMONITOR 
2501 cd 6f ee			call debug_vector  
2504				endm  
# End of macro CALLMONITOR
2504				endif 
2504 cd d2 1a			call forth_push_numhl 
2507			 
2507				NEXTW 
2507 cd 6c ee			call parse_vector 
250a c3 b5 1e			jp macro_next 
250d				endm 
# End of macro NEXTW
250d			.SWAP2: 
250d			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
250d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
250e 91 25			dw .AT            
2510 06				db 5 + 1 
2511 .. 00			db "2SWAP",0              
2517				endm 
# End of macro CWHEAD
2517			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
2517				if DEBUG_FORTH_WORDS_KEY 
2517					DMARK "2SW" 
2517 f5				push af  
2518 3a 2c 25			ld a, (.dmark)  
251b 32 62 ee			ld (debug_mark),a  
251e 3a 2d 25			ld a, (.dmark+1)  
2521 32 63 ee			ld (debug_mark+1),a  
2524 3a 2e 25			ld a, (.dmark+2)  
2527 32 64 ee			ld (debug_mark+2),a  
252a 18 03			jr .pastdmark  
252c ..			.dmark: db "2SW"  
252f f1			.pastdmark: pop af  
2530			endm  
# End of macro DMARK
2530					CALLMONITOR 
2530 cd 6f ee			call debug_vector  
2533				endm  
# End of macro CALLMONITOR
2533				endif 
2533			; TODO Use os stack swap memory 
2533			 
2533				FORTH_DSP_PTR 0     ; TOS    w4 
2533 2a e5 e9			ld hl,(cli_data_sp) 
2536 11 00 00			ld de, 0 * 3 
2539 ed 52			sbc hl, de 
253b				endm 
# End of macro FORTH_DSP_PTR
253b cd 05 1e			call hltostack1 
253e			  
253e				FORTH_DSP_PTR 1     ; TOS    w3 
253e 2a e5 e9			ld hl,(cli_data_sp) 
2541 11 03 00			ld de, 1 * 3 
2544 ed 52			sbc hl, de 
2546				endm 
# End of macro FORTH_DSP_PTR
2546 cd 0b 1e			call hltostack2 
2549			 
2549			 
2549			 
2549				FORTH_DSP_PTR 2     ; TOS    w2 
2549 2a e5 e9			ld hl,(cli_data_sp) 
254c 11 06 00			ld de, 2 * 3 
254f ed 52			sbc hl, de 
2551				endm 
# End of macro FORTH_DSP_PTR
2551 cd 11 1e			call hltostack3 
2554			 
2554				FORTH_DSP_PTR 3     ; TOS   w1 
2554 2a e5 e9			ld hl,(cli_data_sp) 
2557 11 09 00			ld de, 3 * 3 
255a ed 52			sbc hl, de 
255c				endm 
# End of macro FORTH_DSP_PTR
255c cd 17 1e			call hltostack4 
255f			 
255f			 
255f			 
255f			 
255f				FORTH_DSP_PTR 0     ; TOS 
255f 2a e5 e9			ld hl,(cli_data_sp) 
2562 11 00 00			ld de, 0 * 3 
2565 ed 52			sbc hl, de 
2567				endm 
# End of macro FORTH_DSP_PTR
2567 cd 29 1e			call hlfromstack3 
256a			 
256a				FORTH_DSP_PTR 1     ; TOS 
256a 2a e5 e9			ld hl,(cli_data_sp) 
256d 11 03 00			ld de, 1 * 3 
2570 ed 52			sbc hl, de 
2572				endm 
# End of macro FORTH_DSP_PTR
2572 cd 2f 1e			call hlfromstack4 
2575			 
2575			 
2575			 
2575				FORTH_DSP_PTR 2     ; TOS 
2575 2a e5 e9			ld hl,(cli_data_sp) 
2578 11 06 00			ld de, 2 * 3 
257b ed 52			sbc hl, de 
257d				endm 
# End of macro FORTH_DSP_PTR
257d cd 1d 1e			call hlfromstack1 
2580			 
2580				FORTH_DSP_PTR 3     ; TOS 
2580 2a e5 e9			ld hl,(cli_data_sp) 
2583 11 09 00			ld de, 3 * 3 
2586 ed 52			sbc hl, de 
2588				endm 
# End of macro FORTH_DSP_PTR
2588 cd 23 1e			call hlfromstack2 
258b			 
258b				NEXTW 
258b cd 6c ee			call parse_vector 
258e c3 b5 1e			jp macro_next 
2591				endm 
# End of macro NEXTW
2591			.AT: 
2591			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2591 1f				db WORD_SYS_CORE+OPCODE_AT             
2592 c6 25			dw .CAT            
2594 02				db 1 + 1 
2595 .. 00			db "@",0              
2597				endm 
# End of macro CWHEAD
2597			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2597			 
2597				if DEBUG_FORTH_WORDS_KEY 
2597					DMARK "AT." 
2597 f5				push af  
2598 3a ac 25			ld a, (.dmark)  
259b 32 62 ee			ld (debug_mark),a  
259e 3a ad 25			ld a, (.dmark+1)  
25a1 32 63 ee			ld (debug_mark+1),a  
25a4 3a ae 25			ld a, (.dmark+2)  
25a7 32 64 ee			ld (debug_mark+2),a  
25aa 18 03			jr .pastdmark  
25ac ..			.dmark: db "AT."  
25af f1			.pastdmark: pop af  
25b0			endm  
# End of macro DMARK
25b0					CALLMONITOR 
25b0 cd 6f ee			call debug_vector  
25b3				endm  
# End of macro CALLMONITOR
25b3				endif 
25b3			.getbyteat:	 
25b3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b3 cd ce 1c			call macro_dsp_valuehl 
25b6				endm 
# End of macro FORTH_DSP_VALUEHL
25b6				 
25b6			;		push hl 
25b6			 
25b6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25b6 cd 86 1d			call macro_forth_dsp_pop 
25b9				endm 
# End of macro FORTH_DSP_POP
25b9			 
25b9			;		pop hl 
25b9			 
25b9 7e				ld a, (hl) 
25ba			 
25ba 6f				ld l, a 
25bb 26 00			ld h, 0 
25bd cd d2 1a			call forth_push_numhl 
25c0			 
25c0				NEXTW 
25c0 cd 6c ee			call parse_vector 
25c3 c3 b5 1e			jp macro_next 
25c6				endm 
# End of macro NEXTW
25c6			.CAT: 
25c6			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25c6 20				db WORD_SYS_CORE+OPCODE_CAT             
25c7 f2 25			dw .BANG            
25c9 03				db 2 + 1 
25ca .. 00			db "C@",0              
25cd				endm 
# End of macro CWHEAD
25cd			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25cd				if DEBUG_FORTH_WORDS_KEY 
25cd					DMARK "CAA" 
25cd f5				push af  
25ce 3a e2 25			ld a, (.dmark)  
25d1 32 62 ee			ld (debug_mark),a  
25d4 3a e3 25			ld a, (.dmark+1)  
25d7 32 63 ee			ld (debug_mark+1),a  
25da 3a e4 25			ld a, (.dmark+2)  
25dd 32 64 ee			ld (debug_mark+2),a  
25e0 18 03			jr .pastdmark  
25e2 ..			.dmark: db "CAA"  
25e5 f1			.pastdmark: pop af  
25e6			endm  
# End of macro DMARK
25e6					CALLMONITOR 
25e6 cd 6f ee			call debug_vector  
25e9				endm  
# End of macro CALLMONITOR
25e9				endif 
25e9 c3 b3 25			jp .getbyteat 
25ec				NEXTW 
25ec cd 6c ee			call parse_vector 
25ef c3 b5 1e			jp macro_next 
25f2				endm 
# End of macro NEXTW
25f2			.BANG: 
25f2			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25f2 21				db WORD_SYS_CORE+OPCODE_BANG             
25f3 2b 26			dw .CBANG            
25f5 02				db 1 + 1 
25f6 .. 00			db "!",0              
25f8				endm 
# End of macro CWHEAD
25f8			; | ! ( x w -- ) Store x at address w      | DONE 
25f8				if DEBUG_FORTH_WORDS_KEY 
25f8					DMARK "BNG" 
25f8 f5				push af  
25f9 3a 0d 26			ld a, (.dmark)  
25fc 32 62 ee			ld (debug_mark),a  
25ff 3a 0e 26			ld a, (.dmark+1)  
2602 32 63 ee			ld (debug_mark+1),a  
2605 3a 0f 26			ld a, (.dmark+2)  
2608 32 64 ee			ld (debug_mark+2),a  
260b 18 03			jr .pastdmark  
260d ..			.dmark: db "BNG"  
2610 f1			.pastdmark: pop af  
2611			endm  
# End of macro DMARK
2611					CALLMONITOR 
2611 cd 6f ee			call debug_vector  
2614				endm  
# End of macro CALLMONITOR
2614				endif 
2614			 
2614			.storebyteat:		 
2614				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2614 cd ce 1c			call macro_dsp_valuehl 
2617				endm 
# End of macro FORTH_DSP_VALUEHL
2617				 
2617 e5				push hl 
2618			 
2618				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2618 cd 86 1d			call macro_forth_dsp_pop 
261b				endm 
# End of macro FORTH_DSP_POP
261b			 
261b				; get byte to poke 
261b			 
261b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
261b cd ce 1c			call macro_dsp_valuehl 
261e				endm 
# End of macro FORTH_DSP_VALUEHL
261e e5				push hl 
261f			 
261f			 
261f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261f cd 86 1d			call macro_forth_dsp_pop 
2622				endm 
# End of macro FORTH_DSP_POP
2622			 
2622			 
2622 d1				pop de 
2623 e1				pop hl 
2624			 
2624 73				ld (hl),e 
2625			 
2625			 
2625				NEXTW 
2625 cd 6c ee			call parse_vector 
2628 c3 b5 1e			jp macro_next 
262b				endm 
# End of macro NEXTW
262b			.CBANG: 
262b			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
262b 22				db WORD_SYS_CORE+OPCODE_CBANG             
262c 57 26			dw .SCALL            
262e 03				db 2 + 1 
262f .. 00			db "C!",0              
2632				endm 
# End of macro CWHEAD
2632			; | C!  ( x w -- ) Store x at address w  | DONE 
2632				if DEBUG_FORTH_WORDS_KEY 
2632					DMARK "CBA" 
2632 f5				push af  
2633 3a 47 26			ld a, (.dmark)  
2636 32 62 ee			ld (debug_mark),a  
2639 3a 48 26			ld a, (.dmark+1)  
263c 32 63 ee			ld (debug_mark+1),a  
263f 3a 49 26			ld a, (.dmark+2)  
2642 32 64 ee			ld (debug_mark+2),a  
2645 18 03			jr .pastdmark  
2647 ..			.dmark: db "CBA"  
264a f1			.pastdmark: pop af  
264b			endm  
# End of macro DMARK
264b					CALLMONITOR 
264b cd 6f ee			call debug_vector  
264e				endm  
# End of macro CALLMONITOR
264e				endif 
264e c3 14 26			jp .storebyteat 
2651				NEXTW 
2651 cd 6c ee			call parse_vector 
2654 c3 b5 1e			jp macro_next 
2657				endm 
# End of macro NEXTW
2657			.SCALL: 
2657			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2657 23				db WORD_SYS_CORE+OPCODE_SCALL             
2658 8e 26			dw .DEPTH            
265a 05				db 4 + 1 
265b .. 00			db "CALL",0              
2660				endm 
# End of macro CWHEAD
2660			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2660				if DEBUG_FORTH_WORDS_KEY 
2660					DMARK "CLL" 
2660 f5				push af  
2661 3a 75 26			ld a, (.dmark)  
2664 32 62 ee			ld (debug_mark),a  
2667 3a 76 26			ld a, (.dmark+1)  
266a 32 63 ee			ld (debug_mark+1),a  
266d 3a 77 26			ld a, (.dmark+2)  
2670 32 64 ee			ld (debug_mark+2),a  
2673 18 03			jr .pastdmark  
2675 ..			.dmark: db "CLL"  
2678 f1			.pastdmark: pop af  
2679			endm  
# End of macro DMARK
2679					CALLMONITOR 
2679 cd 6f ee			call debug_vector  
267c				endm  
# End of macro CALLMONITOR
267c				endif 
267c			 
267c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267c cd ce 1c			call macro_dsp_valuehl 
267f				endm 
# End of macro FORTH_DSP_VALUEHL
267f			 
267f			;		push hl 
267f			 
267f				; destroy value TOS 
267f			 
267f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
267f cd 86 1d			call macro_forth_dsp_pop 
2682				endm 
# End of macro FORTH_DSP_POP
2682			 
2682					 
2682			;		pop hl 
2682			 
2682				; how to do a call with hl???? save SP? 
2682 cd 59 1e			call forth_call_hl 
2685			 
2685			 
2685				; TODO push value back onto stack for another op etc 
2685			 
2685 cd d2 1a			call forth_push_numhl 
2688				NEXTW 
2688 cd 6c ee			call parse_vector 
268b c3 b5 1e			jp macro_next 
268e				endm 
# End of macro NEXTW
268e			.DEPTH: 
268e			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
268e 24				db WORD_SYS_CORE+OPCODE_DEPTH             
268f ce 26			dw .OVER            
2691 06				db 5 + 1 
2692 .. 00			db "DEPTH",0              
2698				endm 
# End of macro CWHEAD
2698			; | DEPTH ( -- u ) Push count of stack | DONE 
2698				; take current TOS and remove from base value div by two to get count 
2698				if DEBUG_FORTH_WORDS_KEY 
2698					DMARK "DEP" 
2698 f5				push af  
2699 3a ad 26			ld a, (.dmark)  
269c 32 62 ee			ld (debug_mark),a  
269f 3a ae 26			ld a, (.dmark+1)  
26a2 32 63 ee			ld (debug_mark+1),a  
26a5 3a af 26			ld a, (.dmark+2)  
26a8 32 64 ee			ld (debug_mark+2),a  
26ab 18 03			jr .pastdmark  
26ad ..			.dmark: db "DEP"  
26b0 f1			.pastdmark: pop af  
26b1			endm  
# End of macro DMARK
26b1					CALLMONITOR 
26b1 cd 6f ee			call debug_vector  
26b4				endm  
# End of macro CALLMONITOR
26b4				endif 
26b4			 
26b4			 
26b4 2a e5 e9		ld hl, (cli_data_sp) 
26b7 11 1f e8		ld de, cli_data_stack 
26ba ed 52		sbc hl,de 
26bc			 
26bc			; div by size of stack item 
26bc			 
26bc 5d			ld e,l 
26bd 0e 03		ld c, 3 
26bf cd 71 0d		call Div8 
26c2			 
26c2 6f			ld l,a 
26c3 26 00		ld h,0 
26c5			 
26c5			;srl h 
26c5			;rr l 
26c5			 
26c5 cd d2 1a			call forth_push_numhl 
26c8				NEXTW 
26c8 cd 6c ee			call parse_vector 
26cb c3 b5 1e			jp macro_next 
26ce				endm 
# End of macro NEXTW
26ce			.OVER: 
26ce			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26ce 42				db WORD_SYS_CORE+46             
26cf 1e 27			dw .PAUSE            
26d1 05				db 4 + 1 
26d2 .. 00			db "OVER",0              
26d7				endm 
# End of macro CWHEAD
26d7			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26d7			; | | >[!NOTE] 
26d7			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
26d7				if DEBUG_FORTH_WORDS_KEY 
26d7					DMARK "OVR" 
26d7 f5				push af  
26d8 3a ec 26			ld a, (.dmark)  
26db 32 62 ee			ld (debug_mark),a  
26de 3a ed 26			ld a, (.dmark+1)  
26e1 32 63 ee			ld (debug_mark+1),a  
26e4 3a ee 26			ld a, (.dmark+2)  
26e7 32 64 ee			ld (debug_mark+2),a  
26ea 18 03			jr .pastdmark  
26ec ..			.dmark: db "OVR"  
26ef f1			.pastdmark: pop af  
26f0			endm  
# End of macro DMARK
26f0					CALLMONITOR 
26f0 cd 6f ee			call debug_vector  
26f3				endm  
# End of macro CALLMONITOR
26f3				endif 
26f3			 
26f3			; TODO Use os stack swap memory 
26f3			 
26f3				; work out what type we are looking at 
26f3			 
26f3				FORTH_DSP_PTR 1 
26f3 2a e5 e9			ld hl,(cli_data_sp) 
26f6 11 03 00			ld de, 1 * 3 
26f9 ed 52			sbc hl, de 
26fb				endm 
# End of macro FORTH_DSP_PTR
26fb			 
26fb 7e				ld a, (hl) 
26fc				 
26fc f5				push af 
26fd				; whatever the type lets get the pointer or word 
26fd 23				inc hl 
26fe			;; 
26fe			 
26fe				; type check now to decide on how to push  
26fe			 
26fe cd 3b 1e			call loadwordinhl 
2701 f1				pop af 
2702 fe 01			cp DS_TYPE_STR 
2704 28 09			jr z, .ovstr 
2706			 
2706				; we have a numeric so load the word and push 
2706			;	ld e, (hl) 
2706			;	inc hl 
2706			;	ld d, (hl) 
2706			;	ex de, hl 
2706 cd d2 1a			call forth_push_numhl 
2709				NEXTW 
2709 cd 6c ee			call parse_vector 
270c c3 b5 1e			jp macro_next 
270f				endm 
# End of macro NEXTW
270f			 
270f			.ovstr: 
270f				; ok, a string so get the pointer and push as a string 
270f			 
270f			;	call loadwordinhl 
270f cd 3c 1b			call forth_push_str 
2712				NEXTW 
2712 cd 6c ee			call parse_vector 
2715 c3 b5 1e			jp macro_next 
2718				endm 
# End of macro NEXTW
2718			 
2718			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2718			;	push hl    ; n2 
2718			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2718			; 
2718			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2718			;	push hl    ; n1 
2718			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2718			; 
2718			;	pop de     ; n1 
2718			;	pop hl     ; n2 
2718			; 
2718			;	push de 
2718			;	push hl 
2718			;	push de 
2718			 
2718				; push back  
2718			 
2718			;	pop hl 
2718			;	call forth_push_numhl 
2718			;	pop hl 
2718			;	call forth_push_numhl 
2718			;	pop hl 
2718			;	call forth_push_numhl 
2718				NEXTW 
2718 cd 6c ee			call parse_vector 
271b c3 b5 1e			jp macro_next 
271e				endm 
# End of macro NEXTW
271e			 
271e			.PAUSE: 
271e			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
271e 43				db WORD_SYS_CORE+47             
271f 56 27			dw .PAUSES            
2721 08				db 7 + 1 
2722 .. 00			db "PAUSEMS",0              
272a				endm 
# End of macro CWHEAD
272a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
272a				if DEBUG_FORTH_WORDS_KEY 
272a					DMARK "PMS" 
272a f5				push af  
272b 3a 3f 27			ld a, (.dmark)  
272e 32 62 ee			ld (debug_mark),a  
2731 3a 40 27			ld a, (.dmark+1)  
2734 32 63 ee			ld (debug_mark+1),a  
2737 3a 41 27			ld a, (.dmark+2)  
273a 32 64 ee			ld (debug_mark+2),a  
273d 18 03			jr .pastdmark  
273f ..			.dmark: db "PMS"  
2742 f1			.pastdmark: pop af  
2743			endm  
# End of macro DMARK
2743					CALLMONITOR 
2743 cd 6f ee			call debug_vector  
2746				endm  
# End of macro CALLMONITOR
2746				endif 
2746				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2746 cd ce 1c			call macro_dsp_valuehl 
2749				endm 
# End of macro FORTH_DSP_VALUEHL
2749			;		push hl    ; n2 
2749				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2749 cd 86 1d			call macro_forth_dsp_pop 
274c				endm 
# End of macro FORTH_DSP_POP
274c			;		pop hl 
274c			 
274c 7d				ld a, l 
274d cd d5 0a			call aDelayInMS 
2750			       NEXTW 
2750 cd 6c ee			call parse_vector 
2753 c3 b5 1e			jp macro_next 
2756				endm 
# End of macro NEXTW
2756			.PAUSES:  
2756			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2756 44				db WORD_SYS_CORE+48             
2757 c8 27			dw .ROT            
2759 06				db 5 + 1 
275a .. 00			db "PAUSE",0              
2760				endm 
# End of macro CWHEAD
2760			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2760				if DEBUG_FORTH_WORDS_KEY 
2760					DMARK "PAU" 
2760 f5				push af  
2761 3a 75 27			ld a, (.dmark)  
2764 32 62 ee			ld (debug_mark),a  
2767 3a 76 27			ld a, (.dmark+1)  
276a 32 63 ee			ld (debug_mark+1),a  
276d 3a 77 27			ld a, (.dmark+2)  
2770 32 64 ee			ld (debug_mark+2),a  
2773 18 03			jr .pastdmark  
2775 ..			.dmark: db "PAU"  
2778 f1			.pastdmark: pop af  
2779			endm  
# End of macro DMARK
2779					CALLMONITOR 
2779 cd 6f ee			call debug_vector  
277c				endm  
# End of macro CALLMONITOR
277c				endif 
277c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
277c cd ce 1c			call macro_dsp_valuehl 
277f				endm 
# End of macro FORTH_DSP_VALUEHL
277f			;		push hl    ; n2 
277f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
277f cd 86 1d			call macro_forth_dsp_pop 
2782				endm 
# End of macro FORTH_DSP_POP
2782			;		pop hl 
2782 45				ld b, l 
2783				if DEBUG_FORTH_WORDS 
2783					DMARK "PAU" 
2783 f5				push af  
2784 3a 98 27			ld a, (.dmark)  
2787 32 62 ee			ld (debug_mark),a  
278a 3a 99 27			ld a, (.dmark+1)  
278d 32 63 ee			ld (debug_mark+1),a  
2790 3a 9a 27			ld a, (.dmark+2)  
2793 32 64 ee			ld (debug_mark+2),a  
2796 18 03			jr .pastdmark  
2798 ..			.dmark: db "PAU"  
279b f1			.pastdmark: pop af  
279c			endm  
# End of macro DMARK
279c					CALLMONITOR 
279c cd 6f ee			call debug_vector  
279f				endm  
# End of macro CALLMONITOR
279f				endif 
279f c5			.pauses1:	push bc 
27a0 cd f0 0a			call delay1s 
27a3 c1				pop bc 
27a4				if DEBUG_FORTH_WORDS 
27a4					DMARK "PA1" 
27a4 f5				push af  
27a5 3a b9 27			ld a, (.dmark)  
27a8 32 62 ee			ld (debug_mark),a  
27ab 3a ba 27			ld a, (.dmark+1)  
27ae 32 63 ee			ld (debug_mark+1),a  
27b1 3a bb 27			ld a, (.dmark+2)  
27b4 32 64 ee			ld (debug_mark+2),a  
27b7 18 03			jr .pastdmark  
27b9 ..			.dmark: db "PA1"  
27bc f1			.pastdmark: pop af  
27bd			endm  
# End of macro DMARK
27bd					CALLMONITOR 
27bd cd 6f ee			call debug_vector  
27c0				endm  
# End of macro CALLMONITOR
27c0				endif 
27c0 10 dd			djnz .pauses1 
27c2			 
27c2			       NEXTW 
27c2 cd 6c ee			call parse_vector 
27c5 c3 b5 1e			jp macro_next 
27c8				endm 
# End of macro NEXTW
27c8			.ROT: 
27c8			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
27c8 45				db WORD_SYS_CORE+49             
27c9 34 28			dw .UWORDS            
27cb 04				db 3 + 1 
27cc .. 00			db "ROT",0              
27d0				endm 
# End of macro CWHEAD
27d0			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
27d0				if DEBUG_FORTH_WORDS_KEY 
27d0					DMARK "ROT" 
27d0 f5				push af  
27d1 3a e5 27			ld a, (.dmark)  
27d4 32 62 ee			ld (debug_mark),a  
27d7 3a e6 27			ld a, (.dmark+1)  
27da 32 63 ee			ld (debug_mark+1),a  
27dd 3a e7 27			ld a, (.dmark+2)  
27e0 32 64 ee			ld (debug_mark+2),a  
27e3 18 03			jr .pastdmark  
27e5 ..			.dmark: db "ROT"  
27e8 f1			.pastdmark: pop af  
27e9			endm  
# End of macro DMARK
27e9					CALLMONITOR 
27e9 cd 6f ee			call debug_vector  
27ec				endm  
# End of macro CALLMONITOR
27ec				endif 
27ec			 
27ec			; DONE Use os stack swap memory 
27ec			 
27ec				FORTH_DSP_PTR 0     ; u3 
27ec 2a e5 e9			ld hl,(cli_data_sp) 
27ef 11 00 00			ld de, 0 * 3 
27f2 ed 52			sbc hl, de 
27f4				endm 
# End of macro FORTH_DSP_PTR
27f4 cd 05 1e			call hltostack1     
27f7			  
27f7				FORTH_DSP_PTR 1     ; u2 
27f7 2a e5 e9			ld hl,(cli_data_sp) 
27fa 11 03 00			ld de, 1 * 3 
27fd ed 52			sbc hl, de 
27ff				endm 
# End of macro FORTH_DSP_PTR
27ff cd 0b 1e			call hltostack2      
2802			 
2802				FORTH_DSP_PTR 2     ; u1 
2802 2a e5 e9			ld hl,(cli_data_sp) 
2805 11 06 00			ld de, 2 * 3 
2808 ed 52			sbc hl, de 
280a				endm 
# End of macro FORTH_DSP_PTR
280a cd 11 1e			call hltostack3 
280d			 
280d			 
280d				FORTH_DSP_PTR 0     ;  
280d 2a e5 e9			ld hl,(cli_data_sp) 
2810 11 00 00			ld de, 0 * 3 
2813 ed 52			sbc hl, de 
2815				endm 
# End of macro FORTH_DSP_PTR
2815 cd 29 1e			call hlfromstack3 
2818			 
2818				FORTH_DSP_PTR 1     ; TOS 
2818 2a e5 e9			ld hl,(cli_data_sp) 
281b 11 03 00			ld de, 1 * 3 
281e ed 52			sbc hl, de 
2820				endm 
# End of macro FORTH_DSP_PTR
2820 cd 1d 1e			call hlfromstack1 
2823			 
2823				FORTH_DSP_PTR 2     ; TOS 
2823 2a e5 e9			ld hl,(cli_data_sp) 
2826 11 06 00			ld de, 2 * 3 
2829 ed 52			sbc hl, de 
282b				endm 
# End of macro FORTH_DSP_PTR
282b cd 23 1e			call hlfromstack2 
282e			 
282e			 
282e			;	FORTH_DSP_VALUEHL 
282e			;	push hl    ; u3  
282e			; 
282e			;	FORTH_DSP_POP 
282e			; 
282e			;	FORTH_DSP_VALUEHL 
282e			;	push hl     ; u2 
282e			; 
282e			;	FORTH_DSP_POP 
282e			; 
282e			;	FORTH_DSP_VALUEHL 
282e			;	push hl     ; u1 
282e			; 
282e			;	FORTH_DSP_POP 
282e			; 
282e			;	pop bc      ; u1 
282e			;	pop hl      ; u2 
282e			;	pop de      ; u3 
282e			; 
282e			; 
282e			;	push bc 
282e			;	push de 
282e			;	push hl 
282e			; 
282e			; 
282e			;	pop hl 
282e			;	call forth_push_numhl 
282e			; 
282e			;	pop hl 
282e			;	call forth_push_numhl 
282e			; 
282e			;	pop hl 
282e			;	call forth_push_numhl 
282e				 
282e			 
282e			 
282e			 
282e			 
282e			 
282e			       NEXTW 
282e cd 6c ee			call parse_vector 
2831 c3 b5 1e			jp macro_next 
2834				endm 
# End of macro NEXTW
2834			 
2834			.UWORDS: 
2834			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2834 50				db WORD_SYS_CORE+60             
2835 f9 28			dw .BP            
2837 07				db 6 + 1 
2838 .. 00			db "UWORDS",0              
283f				endm 
# End of macro CWHEAD
283f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
283f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
283f			; | | Following the count are the individual words. 
283f			; | | 
283f			; | | e.g. UWORDS 
283f			; | | BOX DIRLIST 2 
283f			; | |  
283f			; | | Can be used to save the words to storage via: 
283f			; | | UWORDS $01 DO $01 APPEND LOOP 
283f			if DEBUG_FORTH_WORDS_KEY 
283f				DMARK "UWR" 
283f f5				push af  
2840 3a 54 28			ld a, (.dmark)  
2843 32 62 ee			ld (debug_mark),a  
2846 3a 55 28			ld a, (.dmark+1)  
2849 32 63 ee			ld (debug_mark+1),a  
284c 3a 56 28			ld a, (.dmark+2)  
284f 32 64 ee			ld (debug_mark+2),a  
2852 18 03			jr .pastdmark  
2854 ..			.dmark: db "UWR"  
2857 f1			.pastdmark: pop af  
2858			endm  
# End of macro DMARK
2858				CALLMONITOR 
2858 cd 6f ee			call debug_vector  
285b				endm  
# End of macro CALLMONITOR
285b			endif 
285b 21 c9 65			ld hl, baseram 
285e				;ld hl, baseusermem 
285e 01 00 00			ld bc, 0    ; start a counter 
2861			 
2861			; skip dict stub 
2861			 
2861 cd e7 1f			call forth_tok_next 
2864			 
2864			 
2864			; while we have words to look for 
2864			 
2864 7e			.douscan:	ld a, (hl)      
2865			if DEBUG_FORTH_WORDS 
2865				DMARK "UWs" 
2865 f5				push af  
2866 3a 7a 28			ld a, (.dmark)  
2869 32 62 ee			ld (debug_mark),a  
286c 3a 7b 28			ld a, (.dmark+1)  
286f 32 63 ee			ld (debug_mark+1),a  
2872 3a 7c 28			ld a, (.dmark+2)  
2875 32 64 ee			ld (debug_mark+2),a  
2878 18 03			jr .pastdmark  
287a ..			.dmark: db "UWs"  
287d f1			.pastdmark: pop af  
287e			endm  
# End of macro DMARK
287e				CALLMONITOR 
287e cd 6f ee			call debug_vector  
2881				endm  
# End of macro CALLMONITOR
2881			endif 
2881 fe 00			cp WORD_SYS_END 
2883 28 4d			jr z, .udone 
2885 fe 01			cp WORD_SYS_UWORD 
2887 20 44			jr nz, .nuword 
2889			 
2889			if DEBUG_FORTH_WORDS 
2889				DMARK "UWu" 
2889 f5				push af  
288a 3a 9e 28			ld a, (.dmark)  
288d 32 62 ee			ld (debug_mark),a  
2890 3a 9f 28			ld a, (.dmark+1)  
2893 32 63 ee			ld (debug_mark+1),a  
2896 3a a0 28			ld a, (.dmark+2)  
2899 32 64 ee			ld (debug_mark+2),a  
289c 18 03			jr .pastdmark  
289e ..			.dmark: db "UWu"  
28a1 f1			.pastdmark: pop af  
28a2			endm  
# End of macro DMARK
28a2				CALLMONITOR 
28a2 cd 6f ee			call debug_vector  
28a5				endm  
# End of macro CALLMONITOR
28a5			endif 
28a5				; we have a uword so push its name to the stack 
28a5			 
28a5 e5				push hl  ; save so we can move to next dict block 
28a6			 
28a6				; skip opcode 
28a6 23				inc hl  
28a7				; skip next ptr 
28a7 23				inc hl  
28a8 23				inc hl 
28a9				; skip len 
28a9 23				inc hl 
28aa			if DEBUG_FORTH_WORDS 
28aa				DMARK "UWt" 
28aa f5				push af  
28ab 3a bf 28			ld a, (.dmark)  
28ae 32 62 ee			ld (debug_mark),a  
28b1 3a c0 28			ld a, (.dmark+1)  
28b4 32 63 ee			ld (debug_mark+1),a  
28b7 3a c1 28			ld a, (.dmark+2)  
28ba 32 64 ee			ld (debug_mark+2),a  
28bd 18 03			jr .pastdmark  
28bf ..			.dmark: db "UWt"  
28c2 f1			.pastdmark: pop af  
28c3			endm  
# End of macro DMARK
28c3				CALLMONITOR 
28c3 cd 6f ee			call debug_vector  
28c6				endm  
# End of macro CALLMONITOR
28c6			endif 
28c6 03				inc bc 
28c7			 
28c7 c5				push bc 
28c8 cd 3c 1b			call forth_push_str 
28cb c1				pop bc 
28cc			 
28cc e1				pop hl 	 
28cd			 
28cd cd e7 1f		.nuword:	call forth_tok_next 
28d0 18 92			jr .douscan  
28d2			 
28d2			.udone:		 ; push count of uwords found 
28d2 c5				push bc 
28d3 e1				pop hl 
28d4			 
28d4			if DEBUG_FORTH_WORDS 
28d4				DMARK "UWc" 
28d4 f5				push af  
28d5 3a e9 28			ld a, (.dmark)  
28d8 32 62 ee			ld (debug_mark),a  
28db 3a ea 28			ld a, (.dmark+1)  
28de 32 63 ee			ld (debug_mark+1),a  
28e1 3a eb 28			ld a, (.dmark+2)  
28e4 32 64 ee			ld (debug_mark+2),a  
28e7 18 03			jr .pastdmark  
28e9 ..			.dmark: db "UWc"  
28ec f1			.pastdmark: pop af  
28ed			endm  
# End of macro DMARK
28ed				CALLMONITOR 
28ed cd 6f ee			call debug_vector  
28f0				endm  
# End of macro CALLMONITOR
28f0			endif 
28f0 cd d2 1a			call forth_push_numhl 
28f3			 
28f3			 
28f3			       NEXTW 
28f3 cd 6c ee			call parse_vector 
28f6 c3 b5 1e			jp macro_next 
28f9				endm 
# End of macro NEXTW
28f9			 
28f9			.BP: 
28f9			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
28f9 54				db WORD_SYS_CORE+64             
28fa 39 29			dw .MONITOR            
28fc 03				db 2 + 1 
28fd .. 00			db "BP",0              
2900				endm 
# End of macro CWHEAD
2900			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2900			; | | $00 Will enable the break points within specific code paths 
2900			; | | $01 Will disable break points 
2900			; | |  
2900			; | | By default break points are off. Either the above can be used to enable them 
2900			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2900			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2900			; | | can disable break points. Exiting will then continue boot process. 
2900				; get byte count 
2900				if DEBUG_FORTH_WORDS_KEY 
2900					DMARK "BP." 
2900 f5				push af  
2901 3a 15 29			ld a, (.dmark)  
2904 32 62 ee			ld (debug_mark),a  
2907 3a 16 29			ld a, (.dmark+1)  
290a 32 63 ee			ld (debug_mark+1),a  
290d 3a 17 29			ld a, (.dmark+2)  
2910 32 64 ee			ld (debug_mark+2),a  
2913 18 03			jr .pastdmark  
2915 ..			.dmark: db "BP."  
2918 f1			.pastdmark: pop af  
2919			endm  
# End of macro DMARK
2919					CALLMONITOR 
2919 cd 6f ee			call debug_vector  
291c				endm  
# End of macro CALLMONITOR
291c				endif 
291c			 
291c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
291c cd ce 1c			call macro_dsp_valuehl 
291f				endm 
# End of macro FORTH_DSP_VALUEHL
291f			 
291f			;		push hl 
291f			 
291f				; destroy value TOS 
291f			 
291f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291f cd 86 1d			call macro_forth_dsp_pop 
2922				endm 
# End of macro FORTH_DSP_POP
2922			 
2922			;		pop hl 
2922			 
2922 3e 00			ld a,0 
2924 bd				cp l 
2925 28 09			jr z, .bpset 
2927			;		ld a, '*' 
2927 cd 5d 14			call bp_off 
292a				NEXTW 
292a cd 6c ee			call parse_vector 
292d c3 b5 1e			jp macro_next 
2930				endm 
# End of macro NEXTW
2930			 
2930			.bpset:	 
2930				;	ld (os_view_disable), a 
2930 cd 51 14			call bp_on 
2933			 
2933			 
2933				NEXTW 
2933 cd 6c ee			call parse_vector 
2936 c3 b5 1e			jp macro_next 
2939				endm 
# End of macro NEXTW
2939			 
2939			 
2939			.MONITOR: 
2939			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2939 55				db WORD_SYS_CORE+65             
293a 6d 29			dw .MALLOC            
293c 08				db 7 + 1 
293d .. 00			db "MONITOR",0              
2945				endm 
# End of macro CWHEAD
2945			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2945			; | | At start the current various registers will be displayed with contents. 
2945			; | | Top right corner will show the most recent debug marker seen. 
2945			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2945			; | | and the return stack pointer (RSP). 
2945			; | | Pressing: 
2945			; | |  
2945			; | |    1 - Initial screen 
2945			; | |  
2945			; | |    2 - Display a data dump of HL 
2945			; | |  
2945			; | |    3 - Display a data dump of DE 
2945			; | |  
2945			; | |    4 - Display a data dump of BC 
2945			; | |  
2945			; | |    5 - Display a data dump of HL 
2945			; | |  
2945			; | |    6 - Display a data dump of DSP 
2945			; | |  
2945			; | |    7 - Display a data dump of RSP 
2945			; | |  
2945			; | |    8 - Display a data dump of what is at DSP 
2945			; | |  
2945			; | |    9 - Display a data dump of what is at RSP 
2945			; | |  
2945			; | |    0 - Exit monitor and continue running. This will also enable break points 
2945			; | |  
2945			; | |    * - Disable break points 
2945			; | |  
2945			; | |    # - Enter traditional monitor mode 
2945			; | |  
2945			; | | 
2945			; | | Monitor Mode 
2945			; | | ------------ 
2945			; | | A prompt of '>' will be shown for various commands: 
2945			; | |  
2945			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2945			; | |  
2945			; | |    C - Continue display a data dump from the last set address 
2945			; | |  
2945			; | |    M xxxx - Set start of memory edit at address xx 
2945			; | |  
2945			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2945			; | |  
2945			; | |    G xxxx - Exec code at specific address 
2945			; | |  
2945			; | |    Q - Return to previous 
2945				if DEBUG_FORTH_WORDS_KEY 
2945					DMARK "MON" 
2945 f5				push af  
2946 3a 5a 29			ld a, (.dmark)  
2949 32 62 ee			ld (debug_mark),a  
294c 3a 5b 29			ld a, (.dmark+1)  
294f 32 63 ee			ld (debug_mark+1),a  
2952 3a 5c 29			ld a, (.dmark+2)  
2955 32 64 ee			ld (debug_mark+2),a  
2958 18 03			jr .pastdmark  
295a ..			.dmark: db "MON"  
295d f1			.pastdmark: pop af  
295e			endm  
# End of macro DMARK
295e					CALLMONITOR 
295e cd 6f ee			call debug_vector  
2961				endm  
# End of macro CALLMONITOR
2961				endif 
2961			;		ld a, 0 
2961			;		ld (os_view_disable), a 
2961 cd 51 14			call bp_on 
2964			 
2964				CALLMONITOR 
2964 cd 6f ee			call debug_vector  
2967				endm  
# End of macro CALLMONITOR
2967			 
2967			;	call monitor 
2967			 
2967				NEXTW 
2967 cd 6c ee			call parse_vector 
296a c3 b5 1e			jp macro_next 
296d				endm 
# End of macro NEXTW
296d			 
296d			 
296d			.MALLOC: 
296d			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
296d 56				db WORD_SYS_CORE+66             
296e 96 29			dw .MALLOC2            
2970 06				db 5 + 1 
2971 .. 00			db "ALLOT",0              
2977				endm 
# End of macro CWHEAD
2977			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2977				if DEBUG_FORTH_WORDS_KEY 
2977					DMARK "ALL" 
2977 f5				push af  
2978 3a 8c 29			ld a, (.dmark)  
297b 32 62 ee			ld (debug_mark),a  
297e 3a 8d 29			ld a, (.dmark+1)  
2981 32 63 ee			ld (debug_mark+1),a  
2984 3a 8e 29			ld a, (.dmark+2)  
2987 32 64 ee			ld (debug_mark+2),a  
298a 18 03			jr .pastdmark  
298c ..			.dmark: db "ALL"  
298f f1			.pastdmark: pop af  
2990			endm  
# End of macro DMARK
2990					CALLMONITOR 
2990 cd 6f ee			call debug_vector  
2993				endm  
# End of macro CALLMONITOR
2993				endif 
2993 c3 bd 29			jp .mallocc 
2996			.MALLOC2: 
2996			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2996 56				db WORD_SYS_CORE+66             
2997 d7 29			dw .FREE            
2999 07				db 6 + 1 
299a .. 00			db "MALLOC",0              
29a1				endm 
# End of macro CWHEAD
29a1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29a1				; get byte count 
29a1				if DEBUG_FORTH_WORDS_KEY 
29a1					DMARK "MAL" 
29a1 f5				push af  
29a2 3a b6 29			ld a, (.dmark)  
29a5 32 62 ee			ld (debug_mark),a  
29a8 3a b7 29			ld a, (.dmark+1)  
29ab 32 63 ee			ld (debug_mark+1),a  
29ae 3a b8 29			ld a, (.dmark+2)  
29b1 32 64 ee			ld (debug_mark+2),a  
29b4 18 03			jr .pastdmark  
29b6 ..			.dmark: db "MAL"  
29b9 f1			.pastdmark: pop af  
29ba			endm  
# End of macro DMARK
29ba					CALLMONITOR 
29ba cd 6f ee			call debug_vector  
29bd				endm  
# End of macro CALLMONITOR
29bd				endif 
29bd			.mallocc: 
29bd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29bd cd ce 1c			call macro_dsp_valuehl 
29c0				endm 
# End of macro FORTH_DSP_VALUEHL
29c0			 
29c0			;		push hl 
29c0			 
29c0				; destroy value TOS 
29c0			 
29c0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c0 cd 86 1d			call macro_forth_dsp_pop 
29c3				endm 
# End of macro FORTH_DSP_POP
29c3			 
29c3			;		pop hl 
29c3 cd ad 11			call malloc 
29c6			if DEBUG_FORTH_MALLOC_GUARD 
29c6 f5				push af 
29c7 cd 0a 0e			call ishlzero 
29ca			;		ld a, l 
29ca			;		add h 
29ca			;		cp 0 
29ca f1				pop af 
29cb				 
29cb cc 23 54			call z,malloc_error 
29ce			endif 
29ce			 
29ce cd d2 1a			call forth_push_numhl 
29d1				NEXTW 
29d1 cd 6c ee			call parse_vector 
29d4 c3 b5 1e			jp macro_next 
29d7				endm 
# End of macro NEXTW
29d7			 
29d7			.FREE: 
29d7			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
29d7 57				db WORD_SYS_CORE+67             
29d8 0b 2a			dw .UPTR            
29da 05				db 4 + 1 
29db .. 00			db "FREE",0              
29e0				endm 
# End of macro CWHEAD
29e0			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
29e0				if DEBUG_FORTH_WORDS_KEY 
29e0					DMARK "FRE" 
29e0 f5				push af  
29e1 3a f5 29			ld a, (.dmark)  
29e4 32 62 ee			ld (debug_mark),a  
29e7 3a f6 29			ld a, (.dmark+1)  
29ea 32 63 ee			ld (debug_mark+1),a  
29ed 3a f7 29			ld a, (.dmark+2)  
29f0 32 64 ee			ld (debug_mark+2),a  
29f3 18 03			jr .pastdmark  
29f5 ..			.dmark: db "FRE"  
29f8 f1			.pastdmark: pop af  
29f9			endm  
# End of macro DMARK
29f9					CALLMONITOR 
29f9 cd 6f ee			call debug_vector  
29fc				endm  
# End of macro CALLMONITOR
29fc				endif 
29fc				; get address 
29fc			 
29fc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29fc cd ce 1c			call macro_dsp_valuehl 
29ff				endm 
# End of macro FORTH_DSP_VALUEHL
29ff			 
29ff			;		push hl 
29ff			 
29ff				; destroy value TOS 
29ff			 
29ff				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29ff cd 86 1d			call macro_forth_dsp_pop 
2a02				endm 
# End of macro FORTH_DSP_POP
2a02			 
2a02			;		pop hl 
2a02			if FORTH_ENABLE_MALLOCFREE 
2a02 cd 77 12			call free 
2a05			endif 
2a05				NEXTW 
2a05 cd 6c ee			call parse_vector 
2a08 c3 b5 1e			jp macro_next 
2a0b				endm 
# End of macro NEXTW
2a0b			.UPTR: 
2a0b			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2a0b 57				db WORD_SYS_CORE+67             
2a0c 11 2b			dw .LIST            
2a0e 05				db 4 + 1 
2a0f .. 00			db "UPTR",0              
2a14				endm 
# End of macro CWHEAD
2a14			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2a14				if DEBUG_FORTH_WORDS_KEY 
2a14					DMARK "UPT" 
2a14 f5				push af  
2a15 3a 29 2a			ld a, (.dmark)  
2a18 32 62 ee			ld (debug_mark),a  
2a1b 3a 2a 2a			ld a, (.dmark+1)  
2a1e 32 63 ee			ld (debug_mark+1),a  
2a21 3a 2b 2a			ld a, (.dmark+2)  
2a24 32 64 ee			ld (debug_mark+2),a  
2a27 18 03			jr .pastdmark  
2a29 ..			.dmark: db "UPT"  
2a2c f1			.pastdmark: pop af  
2a2d			endm  
# End of macro DMARK
2a2d					CALLMONITOR 
2a2d cd 6f ee			call debug_vector  
2a30				endm  
# End of macro CALLMONITOR
2a30				endif 
2a30				FORTH_DSP_VALUEHL 
2a30 cd ce 1c			call macro_dsp_valuehl 
2a33				endm 
# End of macro FORTH_DSP_VALUEHL
2a33			 
2a33 e5				push hl 
2a34				FORTH_DSP_POP 
2a34 cd 86 1d			call macro_forth_dsp_pop 
2a37				endm 
# End of macro FORTH_DSP_POP
2a37 c1				pop bc 
2a38			 
2a38			 
2a38				; Get ptr to the word we need to look up 
2a38			 
2a38			;		FORTH_DSP_VALUEHL 
2a38				;v5 FORTH_DSP_VALUE 
2a38			; TODO type check 
2a38			;		inc hl    ; Skip type check  
2a38			;		push hl 
2a38			;		ex de, hl    ; put into DE 
2a38			 
2a38			 
2a38 21 c9 65			ld hl, baseram 
2a3b				;ld hl, baseusermem 
2a3b			 
2a3b e5			push hl   ; sacreifical push 
2a3c			 
2a3c			.uldouscanm: 
2a3c e1			pop hl 
2a3d			.uldouscan: 
2a3d			if DEBUG_FORTH_WORDS 
2a3d				DMARK "LSs" 
2a3d f5				push af  
2a3e 3a 52 2a			ld a, (.dmark)  
2a41 32 62 ee			ld (debug_mark),a  
2a44 3a 53 2a			ld a, (.dmark+1)  
2a47 32 63 ee			ld (debug_mark+1),a  
2a4a 3a 54 2a			ld a, (.dmark+2)  
2a4d 32 64 ee			ld (debug_mark+2),a  
2a50 18 03			jr .pastdmark  
2a52 ..			.dmark: db "LSs"  
2a55 f1			.pastdmark: pop af  
2a56			endm  
# End of macro DMARK
2a56				CALLMONITOR 
2a56 cd 6f ee			call debug_vector  
2a59				endm  
# End of macro CALLMONITOR
2a59			endif 
2a59			; skip dict stub 
2a59 cd e7 1f			call forth_tok_next 
2a5c			 
2a5c			 
2a5c			; while we have words to look for 
2a5c			 
2a5c 7e			ld a, (hl)      
2a5d			if DEBUG_FORTH_WORDS 
2a5d				DMARK "LSk" 
2a5d f5				push af  
2a5e 3a 72 2a			ld a, (.dmark)  
2a61 32 62 ee			ld (debug_mark),a  
2a64 3a 73 2a			ld a, (.dmark+1)  
2a67 32 63 ee			ld (debug_mark+1),a  
2a6a 3a 74 2a			ld a, (.dmark+2)  
2a6d 32 64 ee			ld (debug_mark+2),a  
2a70 18 03			jr .pastdmark  
2a72 ..			.dmark: db "LSk"  
2a75 f1			.pastdmark: pop af  
2a76			endm  
# End of macro DMARK
2a76				CALLMONITOR 
2a76 cd 6f ee			call debug_vector  
2a79				endm  
# End of macro CALLMONITOR
2a79			endif 
2a79				;cp WORD_SYS_END 
2a79				;jp z, .lunotfound 
2a79			 
2a79					; if we hit non uwords then gone too far 
2a79 fe 01				cp WORD_SYS_UWORD 
2a7b c2 08 2b				jp nz, .ulunotfound 
2a7e			 
2a7e				if DEBUG_FORTH_WORDS 
2a7e					DMARK "LSu" 
2a7e f5				push af  
2a7f 3a 93 2a			ld a, (.dmark)  
2a82 32 62 ee			ld (debug_mark),a  
2a85 3a 94 2a			ld a, (.dmark+1)  
2a88 32 63 ee			ld (debug_mark+1),a  
2a8b 3a 95 2a			ld a, (.dmark+2)  
2a8e 32 64 ee			ld (debug_mark+2),a  
2a91 18 03			jr .pastdmark  
2a93 ..			.dmark: db "LSu"  
2a96 f1			.pastdmark: pop af  
2a97			endm  
# End of macro DMARK
2a97					CALLMONITOR 
2a97 cd 6f ee			call debug_vector  
2a9a				endm  
# End of macro CALLMONITOR
2a9a				endif 
2a9a			 
2a9a					; found a uword but is it the one we want... 
2a9a			 
2a9a c5					push bc     ; uword to find is on bc 
2a9b d1					pop de 
2a9c			 
2a9c e5					push hl  ; to save the ptr 
2a9d			 
2a9d					; skip opcode 
2a9d 23					inc hl  
2a9e					; skip next ptr 
2a9e 23					inc hl  
2a9f 23					inc hl 
2aa0					; skip len 
2aa0 23					inc hl 
2aa1			 
2aa1				if DEBUG_FORTH_WORDS 
2aa1					DMARK "LSc" 
2aa1 f5				push af  
2aa2 3a b6 2a			ld a, (.dmark)  
2aa5 32 62 ee			ld (debug_mark),a  
2aa8 3a b7 2a			ld a, (.dmark+1)  
2aab 32 63 ee			ld (debug_mark+1),a  
2aae 3a b8 2a			ld a, (.dmark+2)  
2ab1 32 64 ee			ld (debug_mark+2),a  
2ab4 18 03			jr .pastdmark  
2ab6 ..			.dmark: db "LSc"  
2ab9 f1			.pastdmark: pop af  
2aba			endm  
# End of macro DMARK
2aba					CALLMONITOR 
2aba cd 6f ee			call debug_vector  
2abd				endm  
# End of macro CALLMONITOR
2abd				endif 
2abd			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2abd			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2abd			; Nope that has gone the other way. It needs to be exact not on first zero 
2abd			;		call strcmp 
2abd c5					push bc 
2abe cd 7d 11				call StrictStrCmp 
2ac1 c1					pop bc 
2ac2 c2 3c 2a				jp nz, .uldouscanm 
2ac5				 
2ac5			 
2ac5			 
2ac5					; we have a uword so push its name to the stack 
2ac5			 
2ac5			;	   	push hl  ; save so we can move to next dict block 
2ac5 e1			pop hl 
2ac6			 
2ac6				if DEBUG_FORTH_WORDS 
2ac6					DMARK "LSm" 
2ac6 f5				push af  
2ac7 3a db 2a			ld a, (.dmark)  
2aca 32 62 ee			ld (debug_mark),a  
2acd 3a dc 2a			ld a, (.dmark+1)  
2ad0 32 63 ee			ld (debug_mark+1),a  
2ad3 3a dd 2a			ld a, (.dmark+2)  
2ad6 32 64 ee			ld (debug_mark+2),a  
2ad9 18 03			jr .pastdmark  
2adb ..			.dmark: db "LSm"  
2ade f1			.pastdmark: pop af  
2adf			endm  
# End of macro DMARK
2adf					CALLMONITOR 
2adf cd 6f ee			call debug_vector  
2ae2				endm  
# End of macro CALLMONITOR
2ae2				endif 
2ae2			 
2ae2					; skip opcode 
2ae2 23					inc hl  
2ae3					; skip next ptr 
2ae3 23					inc hl  
2ae4 23					inc hl 
2ae5					; skip len 
2ae5 7e					ld a, (hl)   ; save length to add 
2ae6				if DEBUG_FORTH_WORDS 
2ae6					DMARK "LS2" 
2ae6 f5				push af  
2ae7 3a fb 2a			ld a, (.dmark)  
2aea 32 62 ee			ld (debug_mark),a  
2aed 3a fc 2a			ld a, (.dmark+1)  
2af0 32 63 ee			ld (debug_mark+1),a  
2af3 3a fd 2a			ld a, (.dmark+2)  
2af6 32 64 ee			ld (debug_mark+2),a  
2af9 18 03			jr .pastdmark  
2afb ..			.dmark: db "LS2"  
2afe f1			.pastdmark: pop af  
2aff			endm  
# End of macro DMARK
2aff					CALLMONITOR 
2aff cd 6f ee			call debug_vector  
2b02				endm  
# End of macro CALLMONITOR
2b02				endif 
2b02			 
2b02				; skip zero term and other uword defs to position right at the exec code 
2b02 06 04			ld b, 4 
2b04 80				add a,b 
2b05			 
2b05 cd e1 0d			call addatohl 
2b08					; save this location 
2b08				 
2b08			.ulunotfound: 
2b08 cd d2 1a			call forth_push_numhl 
2b0b						 
2b0b				NEXTW 
2b0b cd 6c ee			call parse_vector 
2b0e c3 b5 1e			jp macro_next 
2b11				endm 
# End of macro NEXTW
2b11			.LIST: 
2b11			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2b11 5c				db WORD_SYS_CORE+72             
2b12 13 2d			dw .FORGET            
2b14 05				db 4 + 1 
2b15 .. 00			db "LIST",0              
2b1a				endm 
# End of macro CWHEAD
2b1a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2b1a			; | | The quoted word must be in upper case. 
2b1a			if DEBUG_FORTH_WORDS_KEY 
2b1a				DMARK "LST" 
2b1a f5				push af  
2b1b 3a 2f 2b			ld a, (.dmark)  
2b1e 32 62 ee			ld (debug_mark),a  
2b21 3a 30 2b			ld a, (.dmark+1)  
2b24 32 63 ee			ld (debug_mark+1),a  
2b27 3a 31 2b			ld a, (.dmark+2)  
2b2a 32 64 ee			ld (debug_mark+2),a  
2b2d 18 03			jr .pastdmark  
2b2f ..			.dmark: db "LST"  
2b32 f1			.pastdmark: pop af  
2b33			endm  
# End of macro DMARK
2b33				CALLMONITOR 
2b33 cd 6f ee			call debug_vector  
2b36				endm  
# End of macro CALLMONITOR
2b36			endif 
2b36			 
2b36				FORTH_DSP_VALUEHL 
2b36 cd ce 1c			call macro_dsp_valuehl 
2b39				endm 
# End of macro FORTH_DSP_VALUEHL
2b39			 
2b39 e5				push hl 
2b3a				FORTH_DSP_POP 
2b3a cd 86 1d			call macro_forth_dsp_pop 
2b3d				endm 
# End of macro FORTH_DSP_POP
2b3d c1				pop bc 
2b3e			 
2b3e			; Start format of scratch string 
2b3e			 
2b3e 21 b8 e2			ld hl, scratch 
2b41			 
2b41			;	ld a, ':' 
2b41 36 3a			ld (hl),':' 
2b43 23				inc hl 
2b44			;	ld a, ' ' 
2b44 36 20			ld (hl), ' ' 
2b46			 
2b46				; Get ptr to the word we need to look up 
2b46			 
2b46			;		FORTH_DSP_VALUEHL 
2b46				;v5 FORTH_DSP_VALUE 
2b46			; TODO type check 
2b46			;		inc hl    ; Skip type check  
2b46			;		push hl 
2b46			;		ex de, hl    ; put into DE 
2b46			 
2b46			 
2b46 21 c9 65			ld hl, baseram 
2b49				;ld hl, baseusermem 
2b49			 
2b49 e5			push hl   ; sacreifical push 
2b4a			 
2b4a			.ldouscanm: 
2b4a e1			pop hl 
2b4b			.ldouscan: 
2b4b			if DEBUG_FORTH_WORDS 
2b4b				DMARK "LSs" 
2b4b f5				push af  
2b4c 3a 60 2b			ld a, (.dmark)  
2b4f 32 62 ee			ld (debug_mark),a  
2b52 3a 61 2b			ld a, (.dmark+1)  
2b55 32 63 ee			ld (debug_mark+1),a  
2b58 3a 62 2b			ld a, (.dmark+2)  
2b5b 32 64 ee			ld (debug_mark+2),a  
2b5e 18 03			jr .pastdmark  
2b60 ..			.dmark: db "LSs"  
2b63 f1			.pastdmark: pop af  
2b64			endm  
# End of macro DMARK
2b64				CALLMONITOR 
2b64 cd 6f ee			call debug_vector  
2b67				endm  
# End of macro CALLMONITOR
2b67			endif 
2b67			; skip dict stub 
2b67 cd e7 1f			call forth_tok_next 
2b6a			 
2b6a			 
2b6a			; while we have words to look for 
2b6a			 
2b6a 7e			ld a, (hl)      
2b6b			if DEBUG_FORTH_WORDS 
2b6b				DMARK "LSk" 
2b6b f5				push af  
2b6c 3a 80 2b			ld a, (.dmark)  
2b6f 32 62 ee			ld (debug_mark),a  
2b72 3a 81 2b			ld a, (.dmark+1)  
2b75 32 63 ee			ld (debug_mark+1),a  
2b78 3a 82 2b			ld a, (.dmark+2)  
2b7b 32 64 ee			ld (debug_mark+2),a  
2b7e 18 03			jr .pastdmark  
2b80 ..			.dmark: db "LSk"  
2b83 f1			.pastdmark: pop af  
2b84			endm  
# End of macro DMARK
2b84				CALLMONITOR 
2b84 cd 6f ee			call debug_vector  
2b87				endm  
# End of macro CALLMONITOR
2b87			endif 
2b87				;cp WORD_SYS_END 
2b87				;jp z, .lunotfound 
2b87			 
2b87					; if we hit non uwords then gone too far 
2b87 fe 01				cp WORD_SYS_UWORD 
2b89 c2 c6 2c				jp nz, .lunotfound 
2b8c			 
2b8c				if DEBUG_FORTH_WORDS 
2b8c					DMARK "LSu" 
2b8c f5				push af  
2b8d 3a a1 2b			ld a, (.dmark)  
2b90 32 62 ee			ld (debug_mark),a  
2b93 3a a2 2b			ld a, (.dmark+1)  
2b96 32 63 ee			ld (debug_mark+1),a  
2b99 3a a3 2b			ld a, (.dmark+2)  
2b9c 32 64 ee			ld (debug_mark+2),a  
2b9f 18 03			jr .pastdmark  
2ba1 ..			.dmark: db "LSu"  
2ba4 f1			.pastdmark: pop af  
2ba5			endm  
# End of macro DMARK
2ba5					CALLMONITOR 
2ba5 cd 6f ee			call debug_vector  
2ba8				endm  
# End of macro CALLMONITOR
2ba8				endif 
2ba8			 
2ba8					; found a uword but is it the one we want... 
2ba8			 
2ba8 c5					push bc     ; uword to find is on bc 
2ba9 d1					pop de 
2baa			 
2baa e5					push hl  ; to save the ptr 
2bab			 
2bab					; skip opcode 
2bab 23					inc hl  
2bac					; skip next ptr 
2bac 23					inc hl  
2bad 23					inc hl 
2bae					; skip len 
2bae 23					inc hl 
2baf			 
2baf				if DEBUG_FORTH_WORDS 
2baf					DMARK "LSc" 
2baf f5				push af  
2bb0 3a c4 2b			ld a, (.dmark)  
2bb3 32 62 ee			ld (debug_mark),a  
2bb6 3a c5 2b			ld a, (.dmark+1)  
2bb9 32 63 ee			ld (debug_mark+1),a  
2bbc 3a c6 2b			ld a, (.dmark+2)  
2bbf 32 64 ee			ld (debug_mark+2),a  
2bc2 18 03			jr .pastdmark  
2bc4 ..			.dmark: db "LSc"  
2bc7 f1			.pastdmark: pop af  
2bc8			endm  
# End of macro DMARK
2bc8					CALLMONITOR 
2bc8 cd 6f ee			call debug_vector  
2bcb				endm  
# End of macro CALLMONITOR
2bcb				endif 
2bcb			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2bcb			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2bcb			; Nope that has gone the other way. It needs to be exact not on first zero 
2bcb			;		call strcmp 
2bcb c5					push bc 
2bcc cd 7d 11				call StrictStrCmp 
2bcf c1					pop bc 
2bd0 c2 4a 2b				jp nz, .ldouscanm 
2bd3				 
2bd3			 
2bd3			 
2bd3					; we have a uword so push its name to the stack 
2bd3			 
2bd3			;	   	push hl  ; save so we can move to next dict block 
2bd3 e1			pop hl 
2bd4			 
2bd4				if DEBUG_FORTH_WORDS 
2bd4					DMARK "LSm" 
2bd4 f5				push af  
2bd5 3a e9 2b			ld a, (.dmark)  
2bd8 32 62 ee			ld (debug_mark),a  
2bdb 3a ea 2b			ld a, (.dmark+1)  
2bde 32 63 ee			ld (debug_mark+1),a  
2be1 3a eb 2b			ld a, (.dmark+2)  
2be4 32 64 ee			ld (debug_mark+2),a  
2be7 18 03			jr .pastdmark  
2be9 ..			.dmark: db "LSm"  
2bec f1			.pastdmark: pop af  
2bed			endm  
# End of macro DMARK
2bed					CALLMONITOR 
2bed cd 6f ee			call debug_vector  
2bf0				endm  
# End of macro CALLMONITOR
2bf0				endif 
2bf0			 
2bf0					; skip opcode 
2bf0 23					inc hl  
2bf1					; skip next ptr 
2bf1 23					inc hl  
2bf2 23					inc hl 
2bf3					; skip len 
2bf3 7e					ld a, (hl)   ; save length to add 
2bf4				if DEBUG_FORTH_WORDS 
2bf4					DMARK "LS2" 
2bf4 f5				push af  
2bf5 3a 09 2c			ld a, (.dmark)  
2bf8 32 62 ee			ld (debug_mark),a  
2bfb 3a 0a 2c			ld a, (.dmark+1)  
2bfe 32 63 ee			ld (debug_mark+1),a  
2c01 3a 0b 2c			ld a, (.dmark+2)  
2c04 32 64 ee			ld (debug_mark+2),a  
2c07 18 03			jr .pastdmark  
2c09 ..			.dmark: db "LS2"  
2c0c f1			.pastdmark: pop af  
2c0d			endm  
# End of macro DMARK
2c0d					CALLMONITOR 
2c0d cd 6f ee			call debug_vector  
2c10				endm  
# End of macro CALLMONITOR
2c10				endif 
2c10			 
2c10					; save this location 
2c10				 
2c10 e5					push hl 
2c11			 
2c11 23					inc hl 
2c12 11 ba e2				ld de, scratch+2 
2c15 4f					ld c, a 
2c16 06 00				ld b, 0 
2c18			 
2c18				if DEBUG_FORTH_WORDS 
2c18					DMARK "LSn" 
2c18 f5				push af  
2c19 3a 2d 2c			ld a, (.dmark)  
2c1c 32 62 ee			ld (debug_mark),a  
2c1f 3a 2e 2c			ld a, (.dmark+1)  
2c22 32 63 ee			ld (debug_mark+1),a  
2c25 3a 2f 2c			ld a, (.dmark+2)  
2c28 32 64 ee			ld (debug_mark+2),a  
2c2b 18 03			jr .pastdmark  
2c2d ..			.dmark: db "LSn"  
2c30 f1			.pastdmark: pop af  
2c31			endm  
# End of macro DMARK
2c31					CALLMONITOR 
2c31 cd 6f ee			call debug_vector  
2c34				endm  
# End of macro CALLMONITOR
2c34				endif 
2c34			 
2c34					; copy uword name to scratch 
2c34			 
2c34			;		ldir 
2c34			.licplw:	; copy uword name to scratch converting to lower case as we go 
2c34 ed a0				ldi 
2c36 1b					dec de 
2c37 1a					ld a, (de) 
2c38 cd 52 10				call to_lower 
2c3b 12					ld (de),a 
2c3c 13					inc de 
2c3d 3e 00				ld a, 0 
2c3f b9					cp c 
2c40 20 f2				jr nz, .licplw 
2c42			 
2c42			 
2c42			 
2c42 1b					dec de 
2c43 3e 20				ld a, ' '    ; change null to space 
2c45 12					ld (de), a 
2c46			 
2c46 13					inc de 
2c47			 
2c47 d5					push de 
2c48 c1					pop bc     ; move scratch pointer to end of word name and save it 
2c49			 
2c49 e1					pop hl 
2c4a 7e					ld a, (hl) 
2c4b					;inc hl 
2c4b					; skip word string 
2c4b cd e1 0d				call addatohl 
2c4e			 
2c4e 23					inc hl 
2c4f			 
2c4f				if DEBUG_FORTH_WORDS 
2c4f					DMARK "LS3" 
2c4f f5				push af  
2c50 3a 64 2c			ld a, (.dmark)  
2c53 32 62 ee			ld (debug_mark),a  
2c56 3a 65 2c			ld a, (.dmark+1)  
2c59 32 63 ee			ld (debug_mark+1),a  
2c5c 3a 66 2c			ld a, (.dmark+2)  
2c5f 32 64 ee			ld (debug_mark+2),a  
2c62 18 03			jr .pastdmark  
2c64 ..			.dmark: db "LS3"  
2c67 f1			.pastdmark: pop af  
2c68			endm  
# End of macro DMARK
2c68					CALLMONITOR 
2c68 cd 6f ee			call debug_vector  
2c6b				endm  
# End of macro CALLMONITOR
2c6b				endif 
2c6b					; should now be at the start of the machine code to setup the eval of the uword 
2c6b					; now locate the ptr to the string defintion 
2c6b			 
2c6b					; skip ld hl, 
2c6b					; then load the ptr 
2c6b			; TODO use get from hl ptr 
2c6b 23					inc hl 
2c6c 5e					ld e, (hl) 
2c6d 23					inc hl 
2c6e 56					ld d, (hl) 
2c6f eb					ex de, hl 
2c70			 
2c70			 
2c70				if DEBUG_FORTH_WORDS 
2c70					DMARK "LSt" 
2c70 f5				push af  
2c71 3a 85 2c			ld a, (.dmark)  
2c74 32 62 ee			ld (debug_mark),a  
2c77 3a 86 2c			ld a, (.dmark+1)  
2c7a 32 63 ee			ld (debug_mark+1),a  
2c7d 3a 87 2c			ld a, (.dmark+2)  
2c80 32 64 ee			ld (debug_mark+2),a  
2c83 18 03			jr .pastdmark  
2c85 ..			.dmark: db "LSt"  
2c88 f1			.pastdmark: pop af  
2c89			endm  
# End of macro DMARK
2c89					CALLMONITOR 
2c89 cd 6f ee			call debug_vector  
2c8c				endm  
# End of macro CALLMONITOR
2c8c				endif 
2c8c			 
2c8c			; cant push right now due to tokenised strings  
2c8c			 
2c8c			; get the destination of where to copy this definition to. 
2c8c			 
2c8c c5					push bc 
2c8d d1					pop de 
2c8e			 
2c8e 7e			.listl:         ld a,(hl) 
2c8f			;		cp 0 
2c8f b7					or a 
2c90 28 09				jr z, .lreplsp     ; replace zero with space 
2c92					;cp FORTH_END_BUFFER 
2c92 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2c94 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c96				 
2c96					; just copy this char as is then 
2c96			 
2c96 12					ld (de), a 
2c97			 
2c97 23			.listnxt:	inc hl 
2c98 13					inc de 
2c99 18 f3				jr .listl 
2c9b			 
2c9b 3e 20		.lreplsp:	ld a,' ' 
2c9d 12					ld (de), a 
2c9e 18 f7				jr .listnxt 
2ca0			 
2ca0			; close up uword def 
2ca0			 
2ca0			.listdone: 
2ca0 12					ld (de), a 
2ca1 13					inc de 
2ca2 3e 00				ld a, 0 
2ca4 12					ld (de), a 
2ca5			 
2ca5			; now have def so clean up and push to stack 
2ca5			 
2ca5 21 b8 e2				ld hl, scratch 
2ca8				if DEBUG_FORTH_WORDS 
2ca8					DMARK "Ltp" 
2ca8 f5				push af  
2ca9 3a bd 2c			ld a, (.dmark)  
2cac 32 62 ee			ld (debug_mark),a  
2caf 3a be 2c			ld a, (.dmark+1)  
2cb2 32 63 ee			ld (debug_mark+1),a  
2cb5 3a bf 2c			ld a, (.dmark+2)  
2cb8 32 64 ee			ld (debug_mark+2),a  
2cbb 18 03			jr .pastdmark  
2cbd ..			.dmark: db "Ltp"  
2cc0 f1			.pastdmark: pop af  
2cc1			endm  
# End of macro DMARK
2cc1					CALLMONITOR 
2cc1 cd 6f ee			call debug_vector  
2cc4				endm  
# End of macro CALLMONITOR
2cc4				endif 
2cc4			 
2cc4 18 22			jr .listpush 
2cc6			 
2cc6			;.lnuword:	pop hl 
2cc6			;		call forth_tok_next 
2cc6			;		jp .ldouscan  
2cc6			 
2cc6			.lunotfound:		  
2cc6			 
2cc6				if DEBUG_FORTH_WORDS 
2cc6					DMARK "LSn" 
2cc6 f5				push af  
2cc7 3a db 2c			ld a, (.dmark)  
2cca 32 62 ee			ld (debug_mark),a  
2ccd 3a dc 2c			ld a, (.dmark+1)  
2cd0 32 63 ee			ld (debug_mark+1),a  
2cd3 3a dd 2c			ld a, (.dmark+2)  
2cd6 32 64 ee			ld (debug_mark+2),a  
2cd9 18 03			jr .pastdmark  
2cdb ..			.dmark: db "LSn"  
2cde f1			.pastdmark: pop af  
2cdf			endm  
# End of macro DMARK
2cdf					CALLMONITOR 
2cdf cd 6f ee			call debug_vector  
2ce2				endm  
# End of macro CALLMONITOR
2ce2				endif 
2ce2			 
2ce2					 
2ce2			;		FORTH_DSP_POP 
2ce2			;		ld hl, .luno 
2ce2			 
2ce2					NEXTW			 
2ce2 cd 6c ee			call parse_vector 
2ce5 c3 b5 1e			jp macro_next 
2ce8				endm 
# End of macro NEXTW
2ce8			 
2ce8			.listpush: 
2ce8				if DEBUG_FORTH_WORDS 
2ce8					DMARK "LS>" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 62 ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 63 ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 64 ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "LS>"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01					CALLMONITOR 
2d01 cd 6f ee			call debug_vector  
2d04				endm  
# End of macro CALLMONITOR
2d04				endif 
2d04 cd 3c 1b				call forth_push_str 
2d07			 
2d07			 
2d07			 
2d07					NEXTW 
2d07 cd 6c ee			call parse_vector 
2d0a c3 b5 1e			jp macro_next 
2d0d				endm 
# End of macro NEXTW
2d0d			 
2d0d			;.luno:    db "Word not found",0 
2d0d			 
2d0d			 
2d0d			 
2d0d			 
2d0d			 
2d0d			;		push hl   ; save pointer to start of uword def string 
2d0d			; 
2d0d			;; look for FORTH_EOL_LINE 
2d0d			;		ld a, FORTH_END_BUFFER 
2d0d			;		call strlent 
2d0d			; 
2d0d			;		inc hl		 ; space for coln def 
2d0d			;		inc hl 
2d0d			;		inc hl          ; space for terms 
2d0d			;		inc hl 
2d0d			; 
2d0d			;		ld a, 20   ; TODO get actual length 
2d0d			;		call addatohl    ; include a random amount of room for the uword name 
2d0d			; 
2d0d			;		 
2d0d			;	if DEBUG_FORTH_WORDS 
2d0d			;		DMARK "Lt1" 
2d0d			;		CALLMONITOR 
2d0d			;	endif 
2d0d			;		 
2d0d			; 
2d0d			;; malloc space for the string because we cant change it 
2d0d			; 
2d0d			;		call malloc 
2d0d			;	if DEBUG_FORTH_MALLOC_GUARD 
2d0d			;		push af 
2d0d			;		call ishlzero 
2d0d			;		pop af 
2d0d			;		 
2d0d			;		call z,malloc_error 
2d0d			;	endif 
2d0d			; 
2d0d			;	if DEBUG_FORTH_WORDS 
2d0d			;		DMARK "Lt2" 
2d0d			;		CALLMONITOR 
2d0d			;	endif 
2d0d			;		pop de 
2d0d			;		push hl    ; push the malloc to release later 
2d0d			;		push hl   ;  push back a copy for the later stack push 
2d0d			;		 
2d0d			;; copy the string swapping out the zero terms for spaces 
2d0d			; 
2d0d			;		; de has our source 
2d0d			;		; hl has our dest 
2d0d			; 
2d0d			;; add the coln def 
2d0d			; 
2d0d			;		ld a, ':' 
2d0d			;		ld (hl), a 
2d0d			;		inc hl 
2d0d			;		ld a, ' ' 
2d0d			;		ld (hl), a 
2d0d			;		inc hl 
2d0d			; 
2d0d			;; add the uname word 
2d0d			;		push de   ; save our string for now 
2d0d			;		ex de, hl 
2d0d			; 
2d0d			;		FORTH_DSP_VALUE 
2d0d			;		;v5 FORTH_DSP_VALUE 
2d0d			; 
2d0d			;		inc hl   ; skip type but we know by now this is OK 
2d0d			; 
2d0d			;.luword:	ld a,(hl) 
2d0d			;		cp 0 
2d0d			;		jr z, .luword2 
2d0d			;		ld (de), a 
2d0d			;		inc de 
2d0d			;		inc hl 
2d0d			;		jr .luword 
2d0d			; 
2d0d			;.luword2:	ld a, ' ' 
2d0d			;		ld (de), a 
2d0d			;;		inc hl 
2d0d			;;		inc de 
2d0d			;;		ld (de), a 
2d0d			;;		inc hl 
2d0d			;		inc de 
2d0d			; 
2d0d			;		ex de, hl 
2d0d			;		pop de 
2d0d			;		 
2d0d			;		 
2d0d			; 
2d0d			;; detoken that string and copy it 
2d0d			; 
2d0d			;	if DEBUG_FORTH_WORDS 
2d0d			;		DMARK "Lt2" 
2d0d			;		CALLMONITOR 
2d0d			;	endif 
2d0d			;.ldetok:	ld a, (de) 
2d0d			;		cp FORTH_END_BUFFER 
2d0d			;		jr z, .ldetokend 
2d0d			;		; swap out any zero term for space 
2d0d			;		cp 0 
2d0d			;		jr nz, .ldetoknext 
2d0d			;		ld a, ' ' 
2d0d			; 
2d0d			;	if DEBUG_FORTH_WORDS 
2d0d			;		DMARK "LtS" 
2d0d			;		CALLMONITOR 
2d0d			;	endif 
2d0d			;.ldetoknext:	ld (hl), a 
2d0d			;		inc de 
2d0d			;		inc hl 
2d0d			;		jr .ldetok 
2d0d			; 
2d0d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d0d			;		ld (hl), a  
2d0d			; 
2d0d			;; free that temp malloc 
2d0d			; 
2d0d			;		pop hl    
2d0d			; 
2d0d			;	if DEBUG_FORTH_WORDS 
2d0d			;		DMARK "Lt4" 
2d0d			;		CALLMONITOR 
2d0d			;	endif 
2d0d			;		call forth_apushstrhl 
2d0d			; 
2d0d			;		; get rid of temp malloc area 
2d0d			; 
2d0d			;		pop hl 
2d0d			;		call free 
2d0d			; 
2d0d			;		jr .ludone 
2d0d			; 
2d0d			;.lnuword:	pop hl 
2d0d			;		call forth_tok_next 
2d0d			;		jp .ldouscan  
2d0d			; 
2d0d			;.ludone:		 pop hl 
2d0d			; 
2d0d					NEXTW 
2d0d cd 6c ee			call parse_vector 
2d10 c3 b5 1e			jp macro_next 
2d13				endm 
# End of macro NEXTW
2d13			 
2d13			.FORGET: 
2d13				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d13 5d				db WORD_SYS_CORE+73             
2d14 8e 2d			dw .NOP            
2d16 07				db 6 + 1 
2d17 .. 00			db "FORGET",0              
2d1e				endm 
# End of macro CWHEAD
2d1e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d1e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2d1e			; | |  
2d1e			; | | e.g. "MORE" forget 
2d1e					if DEBUG_FORTH_WORDS_KEY 
2d1e						DMARK "FRG" 
2d1e f5				push af  
2d1f 3a 33 2d			ld a, (.dmark)  
2d22 32 62 ee			ld (debug_mark),a  
2d25 3a 34 2d			ld a, (.dmark+1)  
2d28 32 63 ee			ld (debug_mark+1),a  
2d2b 3a 35 2d			ld a, (.dmark+2)  
2d2e 32 64 ee			ld (debug_mark+2),a  
2d31 18 03			jr .pastdmark  
2d33 ..			.dmark: db "FRG"  
2d36 f1			.pastdmark: pop af  
2d37			endm  
# End of macro DMARK
2d37						CALLMONITOR 
2d37 cd 6f ee			call debug_vector  
2d3a				endm  
# End of macro CALLMONITOR
2d3a					endif 
2d3a			 
2d3a				; find uword 
2d3a			        ; update start of word with "_" 
2d3a				; replace uword with deleted flag 
2d3a			 
2d3a			 
2d3a			;	if DEBUG_FORTH_WORDS 
2d3a			;		DMARK "FOG" 
2d3a			;		CALLMONITOR 
2d3a			;	endif 
2d3a			 
2d3a			 
2d3a					; Get ptr to the word we need to look up 
2d3a			 
2d3a					FORTH_DSP_VALUEHL 
2d3a cd ce 1c			call macro_dsp_valuehl 
2d3d				endm 
# End of macro FORTH_DSP_VALUEHL
2d3d					;v5 FORTH_DSP_VALUE 
2d3d				; TODO type check 
2d3d			;		inc hl    ; Skip type check  
2d3d e5					push hl 
2d3e c1					pop bc 
2d3f			;		ex de, hl    ; put into DE 
2d3f			 
2d3f			 
2d3f 21 c9 65				ld hl, baseram 
2d42					;ld hl, baseusermem 
2d42			 
2d42				; skip dict stub 
2d42			;	call forth_tok_next 
2d42 e5			push hl   ; sacreifical push 
2d43			 
2d43			.fldouscanm: 
2d43 e1				pop hl 
2d44			.fldouscan: 
2d44			;	if DEBUG_FORTH_WORDS 
2d44			;		DMARK "LSs" 
2d44			;		CALLMONITOR 
2d44			;	endif 
2d44				; skip dict stub 
2d44 cd e7 1f				call forth_tok_next 
2d47			 
2d47			 
2d47			; while we have words to look for 
2d47			 
2d47 7e				ld a, (hl)      
2d48			;	if DEBUG_FORTH_WORDS 
2d48			;		DMARK "LSk" 
2d48			;		CALLMONITOR 
2d48			;	endif 
2d48 fe 00				cp WORD_SYS_END 
2d4a ca 85 2d				jp z, .flunotfound 
2d4d fe 01				cp WORD_SYS_UWORD 
2d4f c2 44 2d				jp nz, .fldouscan 
2d52			 
2d52			;	if DEBUG_FORTH_WORDS 
2d52			;		DMARK "LSu" 
2d52			;		CALLMONITOR 
2d52			;	endif 
2d52			 
2d52					; found a uword but is it the one we want... 
2d52			 
2d52 c5					push bc     ; uword to find is on bc 
2d53 d1					pop de 
2d54			 
2d54 e5					push hl  ; to save the ptr 
2d55			 
2d55					; skip opcode 
2d55 23					inc hl  
2d56					; skip next ptr 
2d56 23					inc hl  
2d57 23					inc hl 
2d58					; skip len 
2d58 23					inc hl 
2d59			 
2d59			;	if DEBUG_FORTH_WORDS 
2d59			;		DMARK "LSc" 
2d59			;		CALLMONITOR 
2d59			;	endif 
2d59 cd 71 11				call strcmp 
2d5c c2 43 2d				jp nz, .fldouscanm 
2d5f			; 
2d5f			; 
2d5f			;; while we have words to look for 
2d5f			; 
2d5f			;.fdouscan:	ld a, (hl)      
2d5f			;	if DEBUG_FORTH_WORDS 
2d5f			;		DMARK "LSs" 
2d5f			;		CALLMONITOR 
2d5f			;	endif 
2d5f			;		cp WORD_SYS_END 
2d5f			;		jp z, .fudone 
2d5f			;		cp WORD_SYS_UWORD 
2d5f			;		jp nz, .fnuword 
2d5f			; 
2d5f			;	if DEBUG_FORTH_WORDS 
2d5f			;		DMARK "FGu" 
2d5f			;		CALLMONITOR 
2d5f			;	endif 
2d5f			; 
2d5f			;		; found a uword but is it the one we want... 
2d5f			; 
2d5f			; 
2d5f			;	        pop de   ; get back the dsp name 
2d5f			;		push de 
2d5f			; 
2d5f			;		push hl  ; to save the ptr 
2d5f			; 
2d5f			;		; skip opcode 
2d5f			;		inc hl  
2d5f			;		; skip next ptr 
2d5f			;		inc hl  
2d5f			;		inc hl 
2d5f			;		; skip len 
2d5f			;		inc hl 
2d5f			; 
2d5f			;	if DEBUG_FORTH_WORDS 
2d5f			;		DMARK "FGc" 
2d5f			;		CALLMONITOR 
2d5f			;	endif 
2d5f			;		call strcmp 
2d5f			;		jp nz, .fnuword 
2d5f			 
2d5f			 
2d5f e1			pop hl 
2d60			 
2d60				 
2d60				if DEBUG_FORTH_WORDS 
2d60					DMARK "FGm" 
2d60 f5				push af  
2d61 3a 75 2d			ld a, (.dmark)  
2d64 32 62 ee			ld (debug_mark),a  
2d67 3a 76 2d			ld a, (.dmark+1)  
2d6a 32 63 ee			ld (debug_mark+1),a  
2d6d 3a 77 2d			ld a, (.dmark+2)  
2d70 32 64 ee			ld (debug_mark+2),a  
2d73 18 03			jr .pastdmark  
2d75 ..			.dmark: db "FGm"  
2d78 f1			.pastdmark: pop af  
2d79			endm  
# End of macro DMARK
2d79					CALLMONITOR 
2d79 cd 6f ee			call debug_vector  
2d7c				endm  
# End of macro CALLMONITOR
2d7c				endif 
2d7c			 
2d7c			 
2d7c			 
2d7c					; we have a uword so push its name to the stack 
2d7c			 
2d7c			;	   	push hl  ; save so we can move to next dict block 
2d7c			;pop hl 
2d7c			 
2d7c					; update opcode to deleted 
2d7c			;		ld a, WORD_SYS_DELETED 
2d7c 36 03				ld (hl), WORD_SYS_DELETED 
2d7e			 
2d7e 23					inc hl  
2d7f					; skip next ptr 
2d7f 23					inc hl  
2d80 23					inc hl 
2d81					; skip len 
2d81 23					inc hl 
2d82			 
2d82					; TODO change parser to skip deleted words but for now mark it out 
2d82 3e 5f				ld a, "_" 
2d84 77					ld  (hl),a 
2d85			 
2d85			;		jr .fudone 
2d85			; 
2d85			;.fnuword:	pop hl 
2d85			;		call forth_tok_next 
2d85			;		jp .fdouscan  
2d85			 
2d85			.flunotfound:		  
2d85			 
2d85			 
2d85					 
2d85					FORTH_DSP_POP 
2d85 cd 86 1d			call macro_forth_dsp_pop 
2d88				endm 
# End of macro FORTH_DSP_POP
2d88			;		ld hl, .luno 
2d88			;.fudone:		 pop hl 
2d88					NEXTW 
2d88 cd 6c ee			call parse_vector 
2d8b c3 b5 1e			jp macro_next 
2d8e				endm 
# End of macro NEXTW
2d8e			.NOP: 
2d8e				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2d8e 61				db WORD_SYS_CORE+77             
2d8f b8 2d			dw .COMO            
2d91 04				db 3 + 1 
2d92 .. 00			db "NOP",0              
2d96				endm 
# End of macro CWHEAD
2d96			; | NOP (  --  ) Do nothing | DONE 
2d96					if DEBUG_FORTH_WORDS_KEY 
2d96						DMARK "NOP" 
2d96 f5				push af  
2d97 3a ab 2d			ld a, (.dmark)  
2d9a 32 62 ee			ld (debug_mark),a  
2d9d 3a ac 2d			ld a, (.dmark+1)  
2da0 32 63 ee			ld (debug_mark+1),a  
2da3 3a ad 2d			ld a, (.dmark+2)  
2da6 32 64 ee			ld (debug_mark+2),a  
2da9 18 03			jr .pastdmark  
2dab ..			.dmark: db "NOP"  
2dae f1			.pastdmark: pop af  
2daf			endm  
# End of macro DMARK
2daf						CALLMONITOR 
2daf cd 6f ee			call debug_vector  
2db2				endm  
# End of macro CALLMONITOR
2db2					endif 
2db2				       NEXTW 
2db2 cd 6c ee			call parse_vector 
2db5 c3 b5 1e			jp macro_next 
2db8				endm 
# End of macro NEXTW
2db8			.COMO: 
2db8				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2db8 6e				db WORD_SYS_CORE+90             
2db9 0d 2e			dw .COMC            
2dbb 02				db 1 + 1 
2dbc .. 00			db "(",0              
2dbe				endm 
# End of macro CWHEAD
2dbe			; | ( ( -- )  Start of comment | DONE 
2dbe			 
2dbe			 
2dbe 2a b9 e5				ld hl, ( os_tok_ptr) 
2dc1 11 05 2e			ld de, .closepar 
2dc4					 
2dc4					if DEBUG_FORTH_WORDS 
2dc4						DMARK ").." 
2dc4 f5				push af  
2dc5 3a d9 2d			ld a, (.dmark)  
2dc8 32 62 ee			ld (debug_mark),a  
2dcb 3a da 2d			ld a, (.dmark+1)  
2dce 32 63 ee			ld (debug_mark+1),a  
2dd1 3a db 2d			ld a, (.dmark+2)  
2dd4 32 64 ee			ld (debug_mark+2),a  
2dd7 18 03			jr .pastdmark  
2dd9 ..			.dmark: db ").."  
2ddc f1			.pastdmark: pop af  
2ddd			endm  
# End of macro DMARK
2ddd						CALLMONITOR 
2ddd cd 6f ee			call debug_vector  
2de0				endm  
# End of macro CALLMONITOR
2de0					endif 
2de0 cd b2 1f			call findnexttok  
2de3			 
2de3					if DEBUG_FORTH_WORDS 
2de3						DMARK "IF5" 
2de3 f5				push af  
2de4 3a f8 2d			ld a, (.dmark)  
2de7 32 62 ee			ld (debug_mark),a  
2dea 3a f9 2d			ld a, (.dmark+1)  
2ded 32 63 ee			ld (debug_mark+1),a  
2df0 3a fa 2d			ld a, (.dmark+2)  
2df3 32 64 ee			ld (debug_mark+2),a  
2df6 18 03			jr .pastdmark  
2df8 ..			.dmark: db "IF5"  
2dfb f1			.pastdmark: pop af  
2dfc			endm  
# End of macro DMARK
2dfc						CALLMONITOR 
2dfc cd 6f ee			call debug_vector  
2dff				endm  
# End of macro CALLMONITOR
2dff					endif 
2dff				; replace below with ) exec using tok_ptr 
2dff 22 b9 e5			ld (os_tok_ptr), hl 
2e02 c3 36 1f			jp exec1 
2e05			 
2e05 .. 00			.closepar:   db ")",0 
2e07			 
2e07				       NEXTW 
2e07 cd 6c ee			call parse_vector 
2e0a c3 b5 1e			jp macro_next 
2e0d				endm 
# End of macro NEXTW
2e0d			.COMC: 
2e0d				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e0d 6f				db WORD_SYS_CORE+91             
2e0e 19 2e			dw .SCRATCH            
2e10 02				db 1 + 1 
2e11 .. 00			db ")",0              
2e13				endm 
# End of macro CWHEAD
2e13			; | ) ( -- )  End of comment |  DONE  
2e13				       NEXTW 
2e13 cd 6c ee			call parse_vector 
2e16 c3 b5 1e			jp macro_next 
2e19				endm 
# End of macro NEXTW
2e19			 
2e19			.SCRATCH: 
2e19				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e19 6f				db WORD_SYS_CORE+91             
2e1a 57 2e			dw .INC            
2e1c 08				db 7 + 1 
2e1d .. 00			db "SCRATCH",0              
2e25				endm 
# End of macro CWHEAD
2e25			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e25			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e25			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e25			; | |  
2e25			; | | e.g.    : score $00 scratch ; 
2e25			; | |  
2e25			; | | $00 score ! 
2e25			; | | $01 score +! 
2e25			; | |  
2e25			; | | e.g.   : varword $0a scratch ;  
2e25			; | | 
2e25			; | | $8000 varword ! 
2e25					if DEBUG_FORTH_WORDS_KEY 
2e25						DMARK "SCR" 
2e25 f5				push af  
2e26 3a 3a 2e			ld a, (.dmark)  
2e29 32 62 ee			ld (debug_mark),a  
2e2c 3a 3b 2e			ld a, (.dmark+1)  
2e2f 32 63 ee			ld (debug_mark+1),a  
2e32 3a 3c 2e			ld a, (.dmark+2)  
2e35 32 64 ee			ld (debug_mark+2),a  
2e38 18 03			jr .pastdmark  
2e3a ..			.dmark: db "SCR"  
2e3d f1			.pastdmark: pop af  
2e3e			endm  
# End of macro DMARK
2e3e						CALLMONITOR 
2e3e cd 6f ee			call debug_vector  
2e41				endm  
# End of macro CALLMONITOR
2e41					endif 
2e41			 
2e41					FORTH_DSP_VALUEHL 
2e41 cd ce 1c			call macro_dsp_valuehl 
2e44				endm 
# End of macro FORTH_DSP_VALUEHL
2e44				 
2e44					FORTH_DSP_POP 
2e44 cd 86 1d			call macro_forth_dsp_pop 
2e47				endm 
# End of macro FORTH_DSP_POP
2e47			 
2e47 7d					ld a, l 
2e48 21 dd e7				ld hl, os_var_array 
2e4b cd e1 0d				call addatohl 
2e4e			 
2e4e cd d2 1a				call forth_push_numhl 
2e51			 
2e51				       NEXTW 
2e51 cd 6c ee			call parse_vector 
2e54 c3 b5 1e			jp macro_next 
2e57				endm 
# End of macro NEXTW
2e57			 
2e57			.INC: 
2e57				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2e57 6f				db WORD_SYS_CORE+91             
2e58 b0 2e			dw .DEC            
2e5a 03				db 2 + 1 
2e5b .. 00			db "+!",0              
2e5e				endm 
# End of macro CWHEAD
2e5e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2e5e					if DEBUG_FORTH_WORDS_KEY 
2e5e						DMARK "+s_" 
2e5e f5				push af  
2e5f 3a 73 2e			ld a, (.dmark)  
2e62 32 62 ee			ld (debug_mark),a  
2e65 3a 74 2e			ld a, (.dmark+1)  
2e68 32 63 ee			ld (debug_mark+1),a  
2e6b 3a 75 2e			ld a, (.dmark+2)  
2e6e 32 64 ee			ld (debug_mark+2),a  
2e71 18 03			jr .pastdmark  
2e73 ..			.dmark: db "+s_"  
2e76 f1			.pastdmark: pop af  
2e77			endm  
# End of macro DMARK
2e77						CALLMONITOR 
2e77 cd 6f ee			call debug_vector  
2e7a				endm  
# End of macro CALLMONITOR
2e7a					endif 
2e7a			 
2e7a					FORTH_DSP_VALUEHL 
2e7a cd ce 1c			call macro_dsp_valuehl 
2e7d				endm 
# End of macro FORTH_DSP_VALUEHL
2e7d			 
2e7d e5					push hl   ; save address 
2e7e			 
2e7e					FORTH_DSP_POP 
2e7e cd 86 1d			call macro_forth_dsp_pop 
2e81				endm 
# End of macro FORTH_DSP_POP
2e81			 
2e81					FORTH_DSP_VALUEHL 
2e81 cd ce 1c			call macro_dsp_valuehl 
2e84				endm 
# End of macro FORTH_DSP_VALUEHL
2e84			 
2e84 e5					push hl 
2e85					FORTH_DSP_POP 
2e85 cd 86 1d			call macro_forth_dsp_pop 
2e88				endm 
# End of macro FORTH_DSP_POP
2e88 e1					pop hl 
2e89			 
2e89					; hl contains value to add to byte at a 
2e89				 
2e89 eb					ex de, hl 
2e8a			 
2e8a e1					pop hl 
2e8b			 
2e8b					if DEBUG_FORTH_WORDS 
2e8b						DMARK "INC" 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 62 ee			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 63 ee			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 64 ee			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "INC"  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4						CALLMONITOR 
2ea4 cd 6f ee			call debug_vector  
2ea7				endm  
# End of macro CALLMONITOR
2ea7					endif 
2ea7			 
2ea7 7e					ld a,(hl) 
2ea8 83					add e 
2ea9 77					ld (hl),a 
2eaa			 
2eaa			 
2eaa			 
2eaa				       NEXTW 
2eaa cd 6c ee			call parse_vector 
2ead c3 b5 1e			jp macro_next 
2eb0				endm 
# End of macro NEXTW
2eb0			 
2eb0			.DEC: 
2eb0				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2eb0 6f				db WORD_SYS_CORE+91             
2eb1 07 2f			dw .INC2            
2eb3 03				db 2 + 1 
2eb4 .. 00			db "-!",0              
2eb7				endm 
# End of macro CWHEAD
2eb7			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2eb7					if DEBUG_FORTH_WORDS_KEY 
2eb7						DMARK "-s_" 
2eb7 f5				push af  
2eb8 3a cc 2e			ld a, (.dmark)  
2ebb 32 62 ee			ld (debug_mark),a  
2ebe 3a cd 2e			ld a, (.dmark+1)  
2ec1 32 63 ee			ld (debug_mark+1),a  
2ec4 3a ce 2e			ld a, (.dmark+2)  
2ec7 32 64 ee			ld (debug_mark+2),a  
2eca 18 03			jr .pastdmark  
2ecc ..			.dmark: db "-s_"  
2ecf f1			.pastdmark: pop af  
2ed0			endm  
# End of macro DMARK
2ed0						CALLMONITOR 
2ed0 cd 6f ee			call debug_vector  
2ed3				endm  
# End of macro CALLMONITOR
2ed3					endif 
2ed3			 
2ed3					FORTH_DSP_VALUEHL 
2ed3 cd ce 1c			call macro_dsp_valuehl 
2ed6				endm 
# End of macro FORTH_DSP_VALUEHL
2ed6			 
2ed6 e5					push hl   ; save address 
2ed7			 
2ed7					FORTH_DSP_POP 
2ed7 cd 86 1d			call macro_forth_dsp_pop 
2eda				endm 
# End of macro FORTH_DSP_POP
2eda			 
2eda					FORTH_DSP_VALUEHL 
2eda cd ce 1c			call macro_dsp_valuehl 
2edd				endm 
# End of macro FORTH_DSP_VALUEHL
2edd			 
2edd					; hl contains value to add to byte at a 
2edd				 
2edd eb					ex de, hl 
2ede			 
2ede e1					pop hl 
2edf			 
2edf					if DEBUG_FORTH_WORDS 
2edf						DMARK "DEC" 
2edf f5				push af  
2ee0 3a f4 2e			ld a, (.dmark)  
2ee3 32 62 ee			ld (debug_mark),a  
2ee6 3a f5 2e			ld a, (.dmark+1)  
2ee9 32 63 ee			ld (debug_mark+1),a  
2eec 3a f6 2e			ld a, (.dmark+2)  
2eef 32 64 ee			ld (debug_mark+2),a  
2ef2 18 03			jr .pastdmark  
2ef4 ..			.dmark: db "DEC"  
2ef7 f1			.pastdmark: pop af  
2ef8			endm  
# End of macro DMARK
2ef8						CALLMONITOR 
2ef8 cd 6f ee			call debug_vector  
2efb				endm  
# End of macro CALLMONITOR
2efb					endif 
2efb			 
2efb 7e					ld a,(hl) 
2efc 93					sub e 
2efd 77					ld (hl),a 
2efe			 
2efe			 
2efe					FORTH_DSP_POP 
2efe cd 86 1d			call macro_forth_dsp_pop 
2f01				endm 
# End of macro FORTH_DSP_POP
2f01			 
2f01				       NEXTW 
2f01 cd 6c ee			call parse_vector 
2f04 c3 b5 1e			jp macro_next 
2f07				endm 
# End of macro NEXTW
2f07			 
2f07			.INC2: 
2f07				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f07 6f				db WORD_SYS_CORE+91             
2f08 b7 2f			dw .DEC2            
2f0a 04				db 3 + 1 
2f0b .. 00			db "+2!",0              
2f0f				endm 
# End of macro CWHEAD
2f0f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f0f			 
2f0f					if DEBUG_FORTH_WORDS_KEY 
2f0f						DMARK "+2s" 
2f0f f5				push af  
2f10 3a 24 2f			ld a, (.dmark)  
2f13 32 62 ee			ld (debug_mark),a  
2f16 3a 25 2f			ld a, (.dmark+1)  
2f19 32 63 ee			ld (debug_mark+1),a  
2f1c 3a 26 2f			ld a, (.dmark+2)  
2f1f 32 64 ee			ld (debug_mark+2),a  
2f22 18 03			jr .pastdmark  
2f24 ..			.dmark: db "+2s"  
2f27 f1			.pastdmark: pop af  
2f28			endm  
# End of macro DMARK
2f28						CALLMONITOR 
2f28 cd 6f ee			call debug_vector  
2f2b				endm  
# End of macro CALLMONITOR
2f2b					endif 
2f2b			 
2f2b					; Address 
2f2b			 
2f2b					FORTH_DSP_VALUEHL 
2f2b cd ce 1c			call macro_dsp_valuehl 
2f2e				endm 
# End of macro FORTH_DSP_VALUEHL
2f2e			 
2f2e e5					push hl    ; save address 
2f2f			 
2f2f					; load content into de 
2f2f			 
2f2f 5e					ld e,(hl) 
2f30 23					inc hl 
2f31 56					ld d, (hl) 
2f32			 
2f32					if DEBUG_FORTH_WORDS 
2f32						DMARK "+2a" 
2f32 f5				push af  
2f33 3a 47 2f			ld a, (.dmark)  
2f36 32 62 ee			ld (debug_mark),a  
2f39 3a 48 2f			ld a, (.dmark+1)  
2f3c 32 63 ee			ld (debug_mark+1),a  
2f3f 3a 49 2f			ld a, (.dmark+2)  
2f42 32 64 ee			ld (debug_mark+2),a  
2f45 18 03			jr .pastdmark  
2f47 ..			.dmark: db "+2a"  
2f4a f1			.pastdmark: pop af  
2f4b			endm  
# End of macro DMARK
2f4b						CALLMONITOR 
2f4b cd 6f ee			call debug_vector  
2f4e				endm  
# End of macro CALLMONITOR
2f4e					endif 
2f4e			 
2f4e					FORTH_DSP_POP 
2f4e cd 86 1d			call macro_forth_dsp_pop 
2f51				endm 
# End of macro FORTH_DSP_POP
2f51			 
2f51					; Get value to add 
2f51			 
2f51					FORTH_DSP_VALUE 
2f51 cd b7 1c			call macro_forth_dsp_value 
2f54				endm 
# End of macro FORTH_DSP_VALUE
2f54			 
2f54					if DEBUG_FORTH_WORDS 
2f54						DMARK "+2v" 
2f54 f5				push af  
2f55 3a 69 2f			ld a, (.dmark)  
2f58 32 62 ee			ld (debug_mark),a  
2f5b 3a 6a 2f			ld a, (.dmark+1)  
2f5e 32 63 ee			ld (debug_mark+1),a  
2f61 3a 6b 2f			ld a, (.dmark+2)  
2f64 32 64 ee			ld (debug_mark+2),a  
2f67 18 03			jr .pastdmark  
2f69 ..			.dmark: db "+2v"  
2f6c f1			.pastdmark: pop af  
2f6d			endm  
# End of macro DMARK
2f6d						CALLMONITOR 
2f6d cd 6f ee			call debug_vector  
2f70				endm  
# End of macro CALLMONITOR
2f70					endif 
2f70			 
2f70 19					add hl, de 
2f71			 
2f71					if DEBUG_FORTH_WORDS 
2f71						DMARK "+2+" 
2f71 f5				push af  
2f72 3a 86 2f			ld a, (.dmark)  
2f75 32 62 ee			ld (debug_mark),a  
2f78 3a 87 2f			ld a, (.dmark+1)  
2f7b 32 63 ee			ld (debug_mark+1),a  
2f7e 3a 88 2f			ld a, (.dmark+2)  
2f81 32 64 ee			ld (debug_mark+2),a  
2f84 18 03			jr .pastdmark  
2f86 ..			.dmark: db "+2+"  
2f89 f1			.pastdmark: pop af  
2f8a			endm  
# End of macro DMARK
2f8a						CALLMONITOR 
2f8a cd 6f ee			call debug_vector  
2f8d				endm  
# End of macro CALLMONITOR
2f8d					endif 
2f8d			 
2f8d					; move result to de 
2f8d			 
2f8d eb					ex de, hl 
2f8e			 
2f8e					; Address 
2f8e			 
2f8e e1					pop hl 
2f8f			 
2f8f					; save it back 
2f8f			 
2f8f 73					ld (hl), e 
2f90 23					inc hl 
2f91 72					ld (hl), d 
2f92			 
2f92					if DEBUG_FORTH_WORDS 
2f92						DMARK "+2e" 
2f92 f5				push af  
2f93 3a a7 2f			ld a, (.dmark)  
2f96 32 62 ee			ld (debug_mark),a  
2f99 3a a8 2f			ld a, (.dmark+1)  
2f9c 32 63 ee			ld (debug_mark+1),a  
2f9f 3a a9 2f			ld a, (.dmark+2)  
2fa2 32 64 ee			ld (debug_mark+2),a  
2fa5 18 03			jr .pastdmark  
2fa7 ..			.dmark: db "+2e"  
2faa f1			.pastdmark: pop af  
2fab			endm  
# End of macro DMARK
2fab						CALLMONITOR 
2fab cd 6f ee			call debug_vector  
2fae				endm  
# End of macro CALLMONITOR
2fae					endif 
2fae			 
2fae			 
2fae			 
2fae					FORTH_DSP_POP 
2fae cd 86 1d			call macro_forth_dsp_pop 
2fb1				endm 
# End of macro FORTH_DSP_POP
2fb1			 
2fb1			 
2fb1				       NEXTW 
2fb1 cd 6c ee			call parse_vector 
2fb4 c3 b5 1e			jp macro_next 
2fb7				endm 
# End of macro NEXTW
2fb7			 
2fb7			.DEC2: 
2fb7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2fb7 6f				db WORD_SYS_CORE+91             
2fb8 69 30			dw .GET2            
2fba 04				db 3 + 1 
2fbb .. 00			db "-2!",0              
2fbf				endm 
# End of macro CWHEAD
2fbf			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2fbf			 
2fbf			 
2fbf					if DEBUG_FORTH_WORDS_KEY 
2fbf						DMARK "-2s" 
2fbf f5				push af  
2fc0 3a d4 2f			ld a, (.dmark)  
2fc3 32 62 ee			ld (debug_mark),a  
2fc6 3a d5 2f			ld a, (.dmark+1)  
2fc9 32 63 ee			ld (debug_mark+1),a  
2fcc 3a d6 2f			ld a, (.dmark+2)  
2fcf 32 64 ee			ld (debug_mark+2),a  
2fd2 18 03			jr .pastdmark  
2fd4 ..			.dmark: db "-2s"  
2fd7 f1			.pastdmark: pop af  
2fd8			endm  
# End of macro DMARK
2fd8						CALLMONITOR 
2fd8 cd 6f ee			call debug_vector  
2fdb				endm  
# End of macro CALLMONITOR
2fdb					endif 
2fdb			 
2fdb					; Address 
2fdb			 
2fdb					FORTH_DSP_VALUEHL 
2fdb cd ce 1c			call macro_dsp_valuehl 
2fde				endm 
# End of macro FORTH_DSP_VALUEHL
2fde			 
2fde e5					push hl    ; save address 
2fdf			 
2fdf					; load content into de 
2fdf			 
2fdf 5e					ld e,(hl) 
2fe0 23					inc hl 
2fe1 56					ld d, (hl) 
2fe2			 
2fe2					if DEBUG_FORTH_WORDS 
2fe2						DMARK "-2a" 
2fe2 f5				push af  
2fe3 3a f7 2f			ld a, (.dmark)  
2fe6 32 62 ee			ld (debug_mark),a  
2fe9 3a f8 2f			ld a, (.dmark+1)  
2fec 32 63 ee			ld (debug_mark+1),a  
2fef 3a f9 2f			ld a, (.dmark+2)  
2ff2 32 64 ee			ld (debug_mark+2),a  
2ff5 18 03			jr .pastdmark  
2ff7 ..			.dmark: db "-2a"  
2ffa f1			.pastdmark: pop af  
2ffb			endm  
# End of macro DMARK
2ffb						CALLMONITOR 
2ffb cd 6f ee			call debug_vector  
2ffe				endm  
# End of macro CALLMONITOR
2ffe					endif 
2ffe			 
2ffe					FORTH_DSP_POP 
2ffe cd 86 1d			call macro_forth_dsp_pop 
3001				endm 
# End of macro FORTH_DSP_POP
3001			 
3001					; Get value to remove 
3001			 
3001					FORTH_DSP_VALUE 
3001 cd b7 1c			call macro_forth_dsp_value 
3004				endm 
# End of macro FORTH_DSP_VALUE
3004			 
3004					if DEBUG_FORTH_WORDS 
3004						DMARK "-2v" 
3004 f5				push af  
3005 3a 19 30			ld a, (.dmark)  
3008 32 62 ee			ld (debug_mark),a  
300b 3a 1a 30			ld a, (.dmark+1)  
300e 32 63 ee			ld (debug_mark+1),a  
3011 3a 1b 30			ld a, (.dmark+2)  
3014 32 64 ee			ld (debug_mark+2),a  
3017 18 03			jr .pastdmark  
3019 ..			.dmark: db "-2v"  
301c f1			.pastdmark: pop af  
301d			endm  
# End of macro DMARK
301d						CALLMONITOR 
301d cd 6f ee			call debug_vector  
3020				endm  
# End of macro CALLMONITOR
3020					endif 
3020			 
3020 eb					ex de, hl 
3021 ed 52				sbc hl, de 
3023			 
3023					if DEBUG_FORTH_WORDS 
3023						DMARK "-2d" 
3023 f5				push af  
3024 3a 38 30			ld a, (.dmark)  
3027 32 62 ee			ld (debug_mark),a  
302a 3a 39 30			ld a, (.dmark+1)  
302d 32 63 ee			ld (debug_mark+1),a  
3030 3a 3a 30			ld a, (.dmark+2)  
3033 32 64 ee			ld (debug_mark+2),a  
3036 18 03			jr .pastdmark  
3038 ..			.dmark: db "-2d"  
303b f1			.pastdmark: pop af  
303c			endm  
# End of macro DMARK
303c						CALLMONITOR 
303c cd 6f ee			call debug_vector  
303f				endm  
# End of macro CALLMONITOR
303f					endif 
303f			 
303f					; move result to de 
303f			 
303f eb					ex de, hl 
3040			 
3040					; Address 
3040			 
3040 e1					pop hl 
3041			 
3041					; save it back 
3041			 
3041 73					ld (hl), e 
3042 23					inc hl 
3043 72					ld (hl), d 
3044			 
3044					if DEBUG_FORTH_WORDS 
3044						DMARK "-2e" 
3044 f5				push af  
3045 3a 59 30			ld a, (.dmark)  
3048 32 62 ee			ld (debug_mark),a  
304b 3a 5a 30			ld a, (.dmark+1)  
304e 32 63 ee			ld (debug_mark+1),a  
3051 3a 5b 30			ld a, (.dmark+2)  
3054 32 64 ee			ld (debug_mark+2),a  
3057 18 03			jr .pastdmark  
3059 ..			.dmark: db "-2e"  
305c f1			.pastdmark: pop af  
305d			endm  
# End of macro DMARK
305d						CALLMONITOR 
305d cd 6f ee			call debug_vector  
3060				endm  
# End of macro CALLMONITOR
3060					endif 
3060			 
3060			 
3060					FORTH_DSP_POP 
3060 cd 86 1d			call macro_forth_dsp_pop 
3063				endm 
# End of macro FORTH_DSP_POP
3063			 
3063			 
3063			 
3063				       NEXTW 
3063 cd 6c ee			call parse_vector 
3066 c3 b5 1e			jp macro_next 
3069				endm 
# End of macro NEXTW
3069			.GET2: 
3069				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3069 6f				db WORD_SYS_CORE+91             
306a a1 30			dw .BANG2            
306c 03				db 2 + 1 
306d .. 00			db "2@",0              
3070				endm 
# End of macro CWHEAD
3070			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3070					if DEBUG_FORTH_WORDS_KEY 
3070						DMARK "2A_" 
3070 f5				push af  
3071 3a 85 30			ld a, (.dmark)  
3074 32 62 ee			ld (debug_mark),a  
3077 3a 86 30			ld a, (.dmark+1)  
307a 32 63 ee			ld (debug_mark+1),a  
307d 3a 87 30			ld a, (.dmark+2)  
3080 32 64 ee			ld (debug_mark+2),a  
3083 18 03			jr .pastdmark  
3085 ..			.dmark: db "2A_"  
3088 f1			.pastdmark: pop af  
3089			endm  
# End of macro DMARK
3089						CALLMONITOR 
3089 cd 6f ee			call debug_vector  
308c				endm  
# End of macro CALLMONITOR
308c					endif 
308c			 
308c					FORTH_DSP_VALUEHL 
308c cd ce 1c			call macro_dsp_valuehl 
308f				endm 
# End of macro FORTH_DSP_VALUEHL
308f			 
308f e5					push hl   ; save address 
3090			 
3090					FORTH_DSP_POP 
3090 cd 86 1d			call macro_forth_dsp_pop 
3093				endm 
# End of macro FORTH_DSP_POP
3093			 
3093 e1					pop hl 
3094			 
3094 5e					ld e, (hl) 
3095 23					inc hl 
3096 56					ld d, (hl) 
3097			 
3097 eb					ex de, hl 
3098			 
3098 cd d2 1a				call forth_push_numhl 
309b			 
309b				       NEXTW 
309b cd 6c ee			call parse_vector 
309e c3 b5 1e			jp macro_next 
30a1				endm 
# End of macro NEXTW
30a1			.BANG2: 
30a1				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30a1 6f				db WORD_SYS_CORE+91             
30a2 dc 30			dw .CONFIG            
30a4 03				db 2 + 1 
30a5 .. 00			db "2!",0              
30a8				endm 
# End of macro CWHEAD
30a8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30a8					if DEBUG_FORTH_WORDS_KEY 
30a8						DMARK "2S_" 
30a8 f5				push af  
30a9 3a bd 30			ld a, (.dmark)  
30ac 32 62 ee			ld (debug_mark),a  
30af 3a be 30			ld a, (.dmark+1)  
30b2 32 63 ee			ld (debug_mark+1),a  
30b5 3a bf 30			ld a, (.dmark+2)  
30b8 32 64 ee			ld (debug_mark+2),a  
30bb 18 03			jr .pastdmark  
30bd ..			.dmark: db "2S_"  
30c0 f1			.pastdmark: pop af  
30c1			endm  
# End of macro DMARK
30c1						CALLMONITOR 
30c1 cd 6f ee			call debug_vector  
30c4				endm  
# End of macro CALLMONITOR
30c4					endif 
30c4			 
30c4					FORTH_DSP_VALUEHL 
30c4 cd ce 1c			call macro_dsp_valuehl 
30c7				endm 
# End of macro FORTH_DSP_VALUEHL
30c7			 
30c7 e5					push hl   ; save address 
30c8			 
30c8			 
30c8					FORTH_DSP_POP 
30c8 cd 86 1d			call macro_forth_dsp_pop 
30cb				endm 
# End of macro FORTH_DSP_POP
30cb			 
30cb					 
30cb					FORTH_DSP_VALUEHL 
30cb cd ce 1c			call macro_dsp_valuehl 
30ce				endm 
# End of macro FORTH_DSP_VALUEHL
30ce			 
30ce					FORTH_DSP_POP 
30ce cd 86 1d			call macro_forth_dsp_pop 
30d1				endm 
# End of macro FORTH_DSP_POP
30d1			 
30d1 eb					ex de, hl    ; value now in de 
30d2			 
30d2 e1					pop hl 
30d3			 
30d3 73					ld (hl), e 
30d4			 
30d4 23					inc hl 
30d5			 
30d5 72					ld (hl), d 
30d6			 
30d6			 
30d6				       NEXTW 
30d6 cd 6c ee			call parse_vector 
30d9 c3 b5 1e			jp macro_next 
30dc				endm 
# End of macro NEXTW
30dc			.CONFIG: 
30dc				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
30dc 6f				db WORD_SYS_CORE+91             
30dd f0 30			dw .ADTOS            
30df 07				db 6 + 1 
30e0 .. 00			db "CONFIG",0              
30e7				endm 
# End of macro CWHEAD
30e7			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
30e7			 
30e7 cd 46 13				call config 
30ea					NEXTW 
30ea cd 6c ee			call parse_vector 
30ed c3 b5 1e			jp macro_next 
30f0				endm 
# End of macro NEXTW
30f0			 
30f0			.ADTOS: 
30f0				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
30f0 6f				db WORD_SYS_CORE+91             
30f1 09 31			dw .SBTOS            
30f3 03				db 2 + 1 
30f4 .. 00			db "1+",0              
30f7				endm 
# End of macro CWHEAD
30f7			; | 1+ ( u -- u )  Increment value on TOS | DONE 
30f7			 
30f7					FORTH_DSP_VALUEHL 
30f7 cd ce 1c			call macro_dsp_valuehl 
30fa				endm 
# End of macro FORTH_DSP_VALUEHL
30fa e5					push hl 
30fb			 
30fb					FORTH_DSP_POP 
30fb cd 86 1d			call macro_forth_dsp_pop 
30fe				endm 
# End of macro FORTH_DSP_POP
30fe e1					pop hl 
30ff			 
30ff 23					inc hl 
3100 cd d2 1a				call forth_push_numhl 
3103					 
3103					NEXTW 
3103 cd 6c ee			call parse_vector 
3106 c3 b5 1e			jp macro_next 
3109				endm 
# End of macro NEXTW
3109			.SBTOS: 
3109				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3109 6f				db WORD_SYS_CORE+91             
310a 22 31			dw .ADSTORE            
310c 03				db 2 + 1 
310d .. 00			db "1-",0              
3110				endm 
# End of macro CWHEAD
3110			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3110			 
3110					FORTH_DSP_VALUEHL 
3110 cd ce 1c			call macro_dsp_valuehl 
3113				endm 
# End of macro FORTH_DSP_VALUEHL
3113 e5					push hl 
3114			 
3114					FORTH_DSP_POP 
3114 cd 86 1d			call macro_forth_dsp_pop 
3117				endm 
# End of macro FORTH_DSP_POP
3117 e1					pop hl 
3118			 
3118 2b					dec hl 
3119 cd d2 1a				call forth_push_numhl 
311c					 
311c					NEXTW 
311c cd 6c ee			call parse_vector 
311f c3 b5 1e			jp macro_next 
3122				endm 
# End of macro NEXTW
3122			.ADSTORE: 
3122				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3122 6f				db WORD_SYS_CORE+91             
3123 3b 31			dw .ADWSTORE            
3125 04				db 3 + 1 
3126 .. 00			db "1+!",0              
312a				endm 
# End of macro CWHEAD
312a			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
312a			 
312a					FORTH_DSP_VALUEHL 
312a cd ce 1c			call macro_dsp_valuehl 
312d				endm 
# End of macro FORTH_DSP_VALUEHL
312d e5					push hl 
312e			 
312e					FORTH_DSP_POP 
312e cd 86 1d			call macro_forth_dsp_pop 
3131				endm 
# End of macro FORTH_DSP_POP
3131 e1					pop hl 
3132			 
3132 7e					ld a, (hl) 
3133 3c					inc a 
3134 77					ld (hl), a 
3135					 
3135					NEXTW 
3135 cd 6c ee			call parse_vector 
3138 c3 b5 1e			jp macro_next 
313b				endm 
# End of macro NEXTW
313b			.ADWSTORE: 
313b				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
313b 6f				db WORD_SYS_CORE+91             
313c 5c 31			dw .SBSTORE            
313e 05				db 4 + 1 
313f .. 00			db "1+2!",0              
3144				endm 
# End of macro CWHEAD
3144			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3144			 
3144					FORTH_DSP_VALUEHL 
3144 cd ce 1c			call macro_dsp_valuehl 
3147				endm 
# End of macro FORTH_DSP_VALUEHL
3147 e5					push hl 
3148			 
3148					FORTH_DSP_POP 
3148 cd 86 1d			call macro_forth_dsp_pop 
314b				endm 
# End of macro FORTH_DSP_POP
314b e1					pop hl 
314c			 
314c e5					push hl 
314d			 
314d cd 3b 1e				call loadwordinhl 
3150 23					inc hl 
3151			 
3151 d1					pop de 
3152 eb					ex de, hl 
3153 73					ld (hl), e 
3154 23					inc hl 
3155 72					ld (hl), d 
3156					 
3156					NEXTW 
3156 cd 6c ee			call parse_vector 
3159 c3 b5 1e			jp macro_next 
315c				endm 
# End of macro NEXTW
315c			.SBSTORE: 
315c				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
315c 6f				db WORD_SYS_CORE+91             
315d 75 31			dw .SBWSTORE            
315f 04				db 3 + 1 
3160 .. 00			db "1-!",0              
3164				endm 
# End of macro CWHEAD
3164			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3164			 
3164					FORTH_DSP_VALUEHL 
3164 cd ce 1c			call macro_dsp_valuehl 
3167				endm 
# End of macro FORTH_DSP_VALUEHL
3167 e5					push hl 
3168			 
3168					FORTH_DSP_POP 
3168 cd 86 1d			call macro_forth_dsp_pop 
316b				endm 
# End of macro FORTH_DSP_POP
316b e1					pop hl 
316c			 
316c 7e					ld a, (hl) 
316d 3d					dec a 
316e 77					ld (hl), a 
316f					 
316f					NEXTW 
316f cd 6c ee			call parse_vector 
3172 c3 b5 1e			jp macro_next 
3175				endm 
# End of macro NEXTW
3175			.SBWSTORE: 
3175				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3175 6f				db WORD_SYS_CORE+91             
3176 96 31			dw .ENDCORE            
3178 05				db 4 + 1 
3179 .. 00			db "1-2!",0              
317e				endm 
# End of macro CWHEAD
317e			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
317e			 
317e					FORTH_DSP_VALUEHL 
317e cd ce 1c			call macro_dsp_valuehl 
3181				endm 
# End of macro FORTH_DSP_VALUEHL
3181 e5					push hl 
3182			 
3182					FORTH_DSP_POP 
3182 cd 86 1d			call macro_forth_dsp_pop 
3185				endm 
# End of macro FORTH_DSP_POP
3185 e1					pop hl 
3186			 
3186 e5					push hl 
3187			 
3187 cd 3b 1e				call loadwordinhl 
318a 2b					dec hl 
318b			 
318b d1					pop de 
318c eb					ex de, hl 
318d 73					ld (hl), e 
318e 23					inc hl 
318f 72					ld (hl), d 
3190					 
3190					NEXTW 
3190 cd 6c ee			call parse_vector 
3193 c3 b5 1e			jp macro_next 
3196				endm 
# End of macro NEXTW
3196			.ENDCORE: 
3196			 
3196			; eof 
3196			 
3196			 
# End of file forth_words_core.asm
3196			include "forth_words_flow.asm" 
3196			 
3196			; | ## Program Flow Words 
3196			 
3196			.IF: 
3196				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3196 1e				db WORD_SYS_CORE+10             
3197 91 32			dw .THEN            
3199 03				db 2 + 1 
319a .. 00			db "IF",0              
319d				endm 
# End of macro CWHEAD
319d			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
319d			; | | Note: currently not supporting ELSE or nested IF 
319d			; 
319d					if DEBUG_FORTH_WORDS_KEY 
319d						DMARK "IF." 
319d f5				push af  
319e 3a b2 31			ld a, (.dmark)  
31a1 32 62 ee			ld (debug_mark),a  
31a4 3a b3 31			ld a, (.dmark+1)  
31a7 32 63 ee			ld (debug_mark+1),a  
31aa 3a b4 31			ld a, (.dmark+2)  
31ad 32 64 ee			ld (debug_mark+2),a  
31b0 18 03			jr .pastdmark  
31b2 ..			.dmark: db "IF."  
31b5 f1			.pastdmark: pop af  
31b6			endm  
# End of macro DMARK
31b6						CALLMONITOR 
31b6 cd 6f ee			call debug_vector  
31b9				endm  
# End of macro CALLMONITOR
31b9					endif 
31b9			; eval TOS 
31b9			 
31b9				FORTH_DSP_VALUEHL 
31b9 cd ce 1c			call macro_dsp_valuehl 
31bc				endm 
# End of macro FORTH_DSP_VALUEHL
31bc			 
31bc			;	push hl 
31bc				FORTH_DSP_POP 
31bc cd 86 1d			call macro_forth_dsp_pop 
31bf				endm 
# End of macro FORTH_DSP_POP
31bf			;	pop hl 
31bf			 
31bf					if DEBUG_FORTH_WORDS 
31bf						DMARK "IF1" 
31bf f5				push af  
31c0 3a d4 31			ld a, (.dmark)  
31c3 32 62 ee			ld (debug_mark),a  
31c6 3a d5 31			ld a, (.dmark+1)  
31c9 32 63 ee			ld (debug_mark+1),a  
31cc 3a d6 31			ld a, (.dmark+2)  
31cf 32 64 ee			ld (debug_mark+2),a  
31d2 18 03			jr .pastdmark  
31d4 ..			.dmark: db "IF1"  
31d7 f1			.pastdmark: pop af  
31d8			endm  
# End of macro DMARK
31d8						CALLMONITOR 
31d8 cd 6f ee			call debug_vector  
31db				endm  
# End of macro CALLMONITOR
31db					endif 
31db b7				or a        ; clear carry flag 
31dc 11 00 00			ld de, 0 
31df eb				ex de,hl 
31e0 ed 52			sbc hl, de 
31e2 c2 6f 32			jp nz, .iftrue 
31e5			 
31e5					if DEBUG_FORTH_WORDS 
31e5						DMARK "IF2" 
31e5 f5				push af  
31e6 3a fa 31			ld a, (.dmark)  
31e9 32 62 ee			ld (debug_mark),a  
31ec 3a fb 31			ld a, (.dmark+1)  
31ef 32 63 ee			ld (debug_mark+1),a  
31f2 3a fc 31			ld a, (.dmark+2)  
31f5 32 64 ee			ld (debug_mark+2),a  
31f8 18 03			jr .pastdmark  
31fa ..			.dmark: db "IF2"  
31fd f1			.pastdmark: pop af  
31fe			endm  
# End of macro DMARK
31fe						CALLMONITOR 
31fe cd 6f ee			call debug_vector  
3201				endm  
# End of macro CALLMONITOR
3201					endif 
3201			 
3201			; if not true then skip to THEN 
3201			 
3201				; TODO get tok_ptr 
3201				; TODO consume toks until we get to THEN 
3201			 
3201 2a b9 e5			ld hl, (os_tok_ptr) 
3204					if DEBUG_FORTH_WORDS 
3204						DMARK "IF3" 
3204 f5				push af  
3205 3a 19 32			ld a, (.dmark)  
3208 32 62 ee			ld (debug_mark),a  
320b 3a 1a 32			ld a, (.dmark+1)  
320e 32 63 ee			ld (debug_mark+1),a  
3211 3a 1b 32			ld a, (.dmark+2)  
3214 32 64 ee			ld (debug_mark+2),a  
3217 18 03			jr .pastdmark  
3219 ..			.dmark: db "IF3"  
321c f1			.pastdmark: pop af  
321d			endm  
# End of macro DMARK
321d						CALLMONITOR 
321d cd 6f ee			call debug_vector  
3220				endm  
# End of macro CALLMONITOR
3220						 
3220					endif 
3220 11 6a 32			ld de, .ifthen 
3223					if DEBUG_FORTH_WORDS 
3223						DMARK "IF4" 
3223 f5				push af  
3224 3a 38 32			ld a, (.dmark)  
3227 32 62 ee			ld (debug_mark),a  
322a 3a 39 32			ld a, (.dmark+1)  
322d 32 63 ee			ld (debug_mark+1),a  
3230 3a 3a 32			ld a, (.dmark+2)  
3233 32 64 ee			ld (debug_mark+2),a  
3236 18 03			jr .pastdmark  
3238 ..			.dmark: db "IF4"  
323b f1			.pastdmark: pop af  
323c			endm  
# End of macro DMARK
323c						CALLMONITOR 
323c cd 6f ee			call debug_vector  
323f				endm  
# End of macro CALLMONITOR
323f					endif 
323f cd b2 1f			call findnexttok  
3242			 
3242					if DEBUG_FORTH_WORDS 
3242						DMARK "IF5" 
3242 f5				push af  
3243 3a 57 32			ld a, (.dmark)  
3246 32 62 ee			ld (debug_mark),a  
3249 3a 58 32			ld a, (.dmark+1)  
324c 32 63 ee			ld (debug_mark+1),a  
324f 3a 59 32			ld a, (.dmark+2)  
3252 32 64 ee			ld (debug_mark+2),a  
3255 18 03			jr .pastdmark  
3257 ..			.dmark: db "IF5"  
325a f1			.pastdmark: pop af  
325b			endm  
# End of macro DMARK
325b						CALLMONITOR 
325b cd 6f ee			call debug_vector  
325e				endm  
# End of macro CALLMONITOR
325e					endif 
325e				; TODO replace below with ; exec using tok_ptr 
325e 22 b9 e5			ld (os_tok_ptr), hl 
3261 c3 36 1f			jp exec1 
3264				NEXTW 
3264 cd 6c ee			call parse_vector 
3267 c3 b5 1e			jp macro_next 
326a				endm 
# End of macro NEXTW
326a			 
326a .. 00		.ifthen:  db "THEN",0 
326f			 
326f			.iftrue:		 
326f				; Exec next words normally 
326f			 
326f				; if true then exec following IF as normal 
326f					if DEBUG_FORTH_WORDS 
326f						DMARK "IFT" 
326f f5				push af  
3270 3a 84 32			ld a, (.dmark)  
3273 32 62 ee			ld (debug_mark),a  
3276 3a 85 32			ld a, (.dmark+1)  
3279 32 63 ee			ld (debug_mark+1),a  
327c 3a 86 32			ld a, (.dmark+2)  
327f 32 64 ee			ld (debug_mark+2),a  
3282 18 03			jr .pastdmark  
3284 ..			.dmark: db "IFT"  
3287 f1			.pastdmark: pop af  
3288			endm  
# End of macro DMARK
3288						CALLMONITOR 
3288 cd 6f ee			call debug_vector  
328b				endm  
# End of macro CALLMONITOR
328b					endif 
328b			 
328b					NEXTW 
328b cd 6c ee			call parse_vector 
328e c3 b5 1e			jp macro_next 
3291				endm 
# End of macro NEXTW
3291			.THEN: 
3291				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3291 1f				db WORD_SYS_CORE+11             
3292 bc 32			dw .ELSE            
3294 05				db 4 + 1 
3295 .. 00			db "THEN",0              
329a				endm 
# End of macro CWHEAD
329a			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
329a					if DEBUG_FORTH_WORDS_KEY 
329a						DMARK "THN" 
329a f5				push af  
329b 3a af 32			ld a, (.dmark)  
329e 32 62 ee			ld (debug_mark),a  
32a1 3a b0 32			ld a, (.dmark+1)  
32a4 32 63 ee			ld (debug_mark+1),a  
32a7 3a b1 32			ld a, (.dmark+2)  
32aa 32 64 ee			ld (debug_mark+2),a  
32ad 18 03			jr .pastdmark  
32af ..			.dmark: db "THN"  
32b2 f1			.pastdmark: pop af  
32b3			endm  
# End of macro DMARK
32b3						CALLMONITOR 
32b3 cd 6f ee			call debug_vector  
32b6				endm  
# End of macro CALLMONITOR
32b6					endif 
32b6					NEXTW 
32b6 cd 6c ee			call parse_vector 
32b9 c3 b5 1e			jp macro_next 
32bc				endm 
# End of macro NEXTW
32bc			.ELSE: 
32bc				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32bc 20				db WORD_SYS_CORE+12             
32bd e7 32			dw .DO            
32bf 03				db 2 + 1 
32c0 .. 00			db "ELSE",0              
32c5				endm 
# End of macro CWHEAD
32c5			; | ELSE ( -- ) Not supported - does nothing | TODO 
32c5			 
32c5					if DEBUG_FORTH_WORDS_KEY 
32c5						DMARK "ELS" 
32c5 f5				push af  
32c6 3a da 32			ld a, (.dmark)  
32c9 32 62 ee			ld (debug_mark),a  
32cc 3a db 32			ld a, (.dmark+1)  
32cf 32 63 ee			ld (debug_mark+1),a  
32d2 3a dc 32			ld a, (.dmark+2)  
32d5 32 64 ee			ld (debug_mark+2),a  
32d8 18 03			jr .pastdmark  
32da ..			.dmark: db "ELS"  
32dd f1			.pastdmark: pop af  
32de			endm  
# End of macro DMARK
32de						CALLMONITOR 
32de cd 6f ee			call debug_vector  
32e1				endm  
# End of macro CALLMONITOR
32e1					endif 
32e1			 
32e1			 
32e1					NEXTW 
32e1 cd 6c ee			call parse_vector 
32e4 c3 b5 1e			jp macro_next 
32e7				endm 
# End of macro NEXTW
32e7			.DO: 
32e7				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32e7 21				db WORD_SYS_CORE+13             
32e8 11 34			dw .LOOP            
32ea 03				db 2 + 1 
32eb .. 00			db "DO",0              
32ee				endm 
# End of macro CWHEAD
32ee			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
32ee			 
32ee					if DEBUG_FORTH_WORDS_KEY 
32ee						DMARK "DO." 
32ee f5				push af  
32ef 3a 03 33			ld a, (.dmark)  
32f2 32 62 ee			ld (debug_mark),a  
32f5 3a 04 33			ld a, (.dmark+1)  
32f8 32 63 ee			ld (debug_mark+1),a  
32fb 3a 05 33			ld a, (.dmark+2)  
32fe 32 64 ee			ld (debug_mark+2),a  
3301 18 03			jr .pastdmark  
3303 ..			.dmark: db "DO."  
3306 f1			.pastdmark: pop af  
3307			endm  
# End of macro DMARK
3307						CALLMONITOR 
3307 cd 6f ee			call debug_vector  
330a				endm  
# End of macro CALLMONITOR
330a					endif 
330a			;  push pc to rsp stack past the DO 
330a			 
330a 2a b9 e5				ld hl, (os_tok_ptr) 
330d 23					inc hl   ; D 
330e 23					inc hl  ; O 
330f 23					inc hl   ; null 
3310					if DEBUG_FORTH_WORDS 
3310						DMARK "DO2" 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 62 ee			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 63 ee			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 64 ee			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "DO2"  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329						CALLMONITOR 
3329 cd 6f ee			call debug_vector  
332c				endm  
# End of macro CALLMONITOR
332c					endif 
332c					FORTH_RSP_NEXT 
332c cd 79 1a			call macro_forth_rsp_next 
332f				endm 
# End of macro FORTH_RSP_NEXT
332f					if DEBUG_FORTH_WORDS 
332f						DMARK "DO3" 
332f f5				push af  
3330 3a 44 33			ld a, (.dmark)  
3333 32 62 ee			ld (debug_mark),a  
3336 3a 45 33			ld a, (.dmark+1)  
3339 32 63 ee			ld (debug_mark+1),a  
333c 3a 46 33			ld a, (.dmark+2)  
333f 32 64 ee			ld (debug_mark+2),a  
3342 18 03			jr .pastdmark  
3344 ..			.dmark: db "DO3"  
3347 f1			.pastdmark: pop af  
3348			endm  
# End of macro DMARK
3348						CALLMONITOR 
3348 cd 6f ee			call debug_vector  
334b				endm  
# End of macro CALLMONITOR
334b					endif 
334b			 
334b					;if DEBUG_FORTH_WORDS 
334b				;		push hl 
334b			;		endif  
334b			 
334b			; get counters from data stack 
334b			 
334b			 
334b					FORTH_DSP_VALUEHL 
334b cd ce 1c			call macro_dsp_valuehl 
334e				endm 
# End of macro FORTH_DSP_VALUEHL
334e e5					push hl		 ; hl now has starting counter which needs to be tos 
334f			 
334f					if DEBUG_FORTH_WORDS 
334f						DMARK "DO4" 
334f f5				push af  
3350 3a 64 33			ld a, (.dmark)  
3353 32 62 ee			ld (debug_mark),a  
3356 3a 65 33			ld a, (.dmark+1)  
3359 32 63 ee			ld (debug_mark+1),a  
335c 3a 66 33			ld a, (.dmark+2)  
335f 32 64 ee			ld (debug_mark+2),a  
3362 18 03			jr .pastdmark  
3364 ..			.dmark: db "DO4"  
3367 f1			.pastdmark: pop af  
3368			endm  
# End of macro DMARK
3368						CALLMONITOR 
3368 cd 6f ee			call debug_vector  
336b				endm  
# End of macro CALLMONITOR
336b					endif 
336b					FORTH_DSP_POP 
336b cd 86 1d			call macro_forth_dsp_pop 
336e				endm 
# End of macro FORTH_DSP_POP
336e			 
336e					if DEBUG_FORTH_WORDS 
336e						DMARK "DO5" 
336e f5				push af  
336f 3a 83 33			ld a, (.dmark)  
3372 32 62 ee			ld (debug_mark),a  
3375 3a 84 33			ld a, (.dmark+1)  
3378 32 63 ee			ld (debug_mark+1),a  
337b 3a 85 33			ld a, (.dmark+2)  
337e 32 64 ee			ld (debug_mark+2),a  
3381 18 03			jr .pastdmark  
3383 ..			.dmark: db "DO5"  
3386 f1			.pastdmark: pop af  
3387			endm  
# End of macro DMARK
3387						CALLMONITOR 
3387 cd 6f ee			call debug_vector  
338a				endm  
# End of macro CALLMONITOR
338a					endif 
338a			 
338a					FORTH_DSP_VALUEHL 
338a cd ce 1c			call macro_dsp_valuehl 
338d				endm 
# End of macro FORTH_DSP_VALUEHL
338d			;		push hl		 ; hl now has starting limit counter 
338d			 
338d					if DEBUG_FORTH_WORDS 
338d						DMARK "DO6" 
338d f5				push af  
338e 3a a2 33			ld a, (.dmark)  
3391 32 62 ee			ld (debug_mark),a  
3394 3a a3 33			ld a, (.dmark+1)  
3397 32 63 ee			ld (debug_mark+1),a  
339a 3a a4 33			ld a, (.dmark+2)  
339d 32 64 ee			ld (debug_mark+2),a  
33a0 18 03			jr .pastdmark  
33a2 ..			.dmark: db "DO6"  
33a5 f1			.pastdmark: pop af  
33a6			endm  
# End of macro DMARK
33a6						CALLMONITOR 
33a6 cd 6f ee			call debug_vector  
33a9				endm  
# End of macro CALLMONITOR
33a9					endif 
33a9					FORTH_DSP_POP 
33a9 cd 86 1d			call macro_forth_dsp_pop 
33ac				endm 
# End of macro FORTH_DSP_POP
33ac			 
33ac			; put counters on the loop stack 
33ac			 
33ac			;		pop hl			 ; limit counter 
33ac d1					pop de			; start counter 
33ad			 
33ad					; push limit counter 
33ad			 
33ad					if DEBUG_FORTH_WORDS 
33ad						DMARK "DO7" 
33ad f5				push af  
33ae 3a c2 33			ld a, (.dmark)  
33b1 32 62 ee			ld (debug_mark),a  
33b4 3a c3 33			ld a, (.dmark+1)  
33b7 32 63 ee			ld (debug_mark+1),a  
33ba 3a c4 33			ld a, (.dmark+2)  
33bd 32 64 ee			ld (debug_mark+2),a  
33c0 18 03			jr .pastdmark  
33c2 ..			.dmark: db "DO7"  
33c5 f1			.pastdmark: pop af  
33c6			endm  
# End of macro DMARK
33c6						CALLMONITOR 
33c6 cd 6f ee			call debug_vector  
33c9				endm  
# End of macro CALLMONITOR
33c9					endif 
33c9					FORTH_LOOP_NEXT 
33c9 cd ff 1c			call macro_forth_loop_next 
33cc				endm 
# End of macro FORTH_LOOP_NEXT
33cc			 
33cc					; push start counter 
33cc			 
33cc eb					ex de, hl 
33cd					if DEBUG_FORTH_WORDS 
33cd						DMARK "DO7" 
33cd f5				push af  
33ce 3a e2 33			ld a, (.dmark)  
33d1 32 62 ee			ld (debug_mark),a  
33d4 3a e3 33			ld a, (.dmark+1)  
33d7 32 63 ee			ld (debug_mark+1),a  
33da 3a e4 33			ld a, (.dmark+2)  
33dd 32 64 ee			ld (debug_mark+2),a  
33e0 18 03			jr .pastdmark  
33e2 ..			.dmark: db "DO7"  
33e5 f1			.pastdmark: pop af  
33e6			endm  
# End of macro DMARK
33e6						CALLMONITOR 
33e6 cd 6f ee			call debug_vector  
33e9				endm  
# End of macro CALLMONITOR
33e9					endif 
33e9					FORTH_LOOP_NEXT 
33e9 cd ff 1c			call macro_forth_loop_next 
33ec				endm 
# End of macro FORTH_LOOP_NEXT
33ec			 
33ec			 
33ec					; init first round of I counter 
33ec			 
33ec 22 dd e5				ld (os_current_i), hl 
33ef			 
33ef					if DEBUG_FORTH_WORDS 
33ef						DMARK "DO8" 
33ef f5				push af  
33f0 3a 04 34			ld a, (.dmark)  
33f3 32 62 ee			ld (debug_mark),a  
33f6 3a 05 34			ld a, (.dmark+1)  
33f9 32 63 ee			ld (debug_mark+1),a  
33fc 3a 06 34			ld a, (.dmark+2)  
33ff 32 64 ee			ld (debug_mark+2),a  
3402 18 03			jr .pastdmark  
3404 ..			.dmark: db "DO8"  
3407 f1			.pastdmark: pop af  
3408			endm  
# End of macro DMARK
3408						CALLMONITOR 
3408 cd 6f ee			call debug_vector  
340b				endm  
# End of macro CALLMONITOR
340b					endif 
340b			 
340b					NEXTW 
340b cd 6c ee			call parse_vector 
340e c3 b5 1e			jp macro_next 
3411				endm 
# End of macro NEXTW
3411			.LOOP: 
3411				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3411 22				db WORD_SYS_CORE+14             
3412 2f 35			dw .I            
3414 05				db 4 + 1 
3415 .. 00			db "LOOP",0              
341a				endm 
# End of macro CWHEAD
341a			; | LOOP ( -- ) Increment and test loop counter  | DONE 
341a			 
341a				; pop tos as current loop count to hl 
341a			 
341a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
341a			 
341a				FORTH_LOOP_TOS 
341a cd 32 1d			call macro_forth_loop_tos 
341d				endm 
# End of macro FORTH_LOOP_TOS
341d e5				push hl 
341e			 
341e					if DEBUG_FORTH_WORDS_KEY 
341e						DMARK "LOP" 
341e f5				push af  
341f 3a 33 34			ld a, (.dmark)  
3422 32 62 ee			ld (debug_mark),a  
3425 3a 34 34			ld a, (.dmark+1)  
3428 32 63 ee			ld (debug_mark+1),a  
342b 3a 35 34			ld a, (.dmark+2)  
342e 32 64 ee			ld (debug_mark+2),a  
3431 18 03			jr .pastdmark  
3433 ..			.dmark: db "LOP"  
3436 f1			.pastdmark: pop af  
3437			endm  
# End of macro DMARK
3437						CALLMONITOR 
3437 cd 6f ee			call debug_vector  
343a				endm  
# End of macro CALLMONITOR
343a					endif 
343a				; next item on the stack is the limit. get it 
343a			 
343a			 
343a				FORTH_LOOP_POP 
343a cd 3c 1d			call macro_forth_loop_pop 
343d				endm 
# End of macro FORTH_LOOP_POP
343d			 
343d				FORTH_LOOP_TOS 
343d cd 32 1d			call macro_forth_loop_tos 
3440				endm 
# End of macro FORTH_LOOP_TOS
3440			 
3440 d1				pop de		 ; de = i, hl = limit 
3441			 
3441					if DEBUG_FORTH_WORDS 
3441						DMARK "LP1" 
3441 f5				push af  
3442 3a 56 34			ld a, (.dmark)  
3445 32 62 ee			ld (debug_mark),a  
3448 3a 57 34			ld a, (.dmark+1)  
344b 32 63 ee			ld (debug_mark+1),a  
344e 3a 58 34			ld a, (.dmark+2)  
3451 32 64 ee			ld (debug_mark+2),a  
3454 18 03			jr .pastdmark  
3456 ..			.dmark: db "LP1"  
3459 f1			.pastdmark: pop af  
345a			endm  
# End of macro DMARK
345a						CALLMONITOR 
345a cd 6f ee			call debug_vector  
345d				endm  
# End of macro CALLMONITOR
345d					endif 
345d			 
345d				; go back to previous word 
345d			 
345d d5				push de    ; save I for inc later 
345e			 
345e			 
345e				; get limit 
345e				;  is I at limit? 
345e			 
345e			 
345e					if DEBUG_FORTH_WORDS 
345e						DMARK "LP1" 
345e f5				push af  
345f 3a 73 34			ld a, (.dmark)  
3462 32 62 ee			ld (debug_mark),a  
3465 3a 74 34			ld a, (.dmark+1)  
3468 32 63 ee			ld (debug_mark+1),a  
346b 3a 75 34			ld a, (.dmark+2)  
346e 32 64 ee			ld (debug_mark+2),a  
3471 18 03			jr .pastdmark  
3473 ..			.dmark: db "LP1"  
3476 f1			.pastdmark: pop af  
3477			endm  
# End of macro DMARK
3477						CALLMONITOR 
3477 cd 6f ee			call debug_vector  
347a				endm  
# End of macro CALLMONITOR
347a					endif 
347a			 
347a ed 52			sbc hl, de 
347c			 
347c			 
347c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
347c			 
347c 20 29				jr nz, .loopnotdone 
347e			 
347e e1				pop hl   ; get rid of saved I 
347f				FORTH_LOOP_POP     ; get rid of limit 
347f cd 3c 1d			call macro_forth_loop_pop 
3482				endm 
# End of macro FORTH_LOOP_POP
3482			 
3482				FORTH_RSP_POP     ; get rid of DO ptr 
3482 cd 9a 1a			call macro_forth_rsp_pop 
3485				endm 
# End of macro FORTH_RSP_POP
3485			 
3485			if DEBUG_FORTH_WORDS 
3485						DMARK "LP>" 
3485 f5				push af  
3486 3a 9a 34			ld a, (.dmark)  
3489 32 62 ee			ld (debug_mark),a  
348c 3a 9b 34			ld a, (.dmark+1)  
348f 32 63 ee			ld (debug_mark+1),a  
3492 3a 9c 34			ld a, (.dmark+2)  
3495 32 64 ee			ld (debug_mark+2),a  
3498 18 03			jr .pastdmark  
349a ..			.dmark: db "LP>"  
349d f1			.pastdmark: pop af  
349e			endm  
# End of macro DMARK
349e				CALLMONITOR 
349e cd 6f ee			call debug_vector  
34a1				endm  
# End of macro CALLMONITOR
34a1			endif 
34a1			 
34a1					NEXTW 
34a1 cd 6c ee			call parse_vector 
34a4 c3 b5 1e			jp macro_next 
34a7				endm 
# End of macro NEXTW
34a7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34a7			 
34a7			.loopnotdone: 
34a7			 
34a7 e1				pop hl    ; get I 
34a8 23				inc hl 
34a9			 
34a9			   	; save new I 
34a9			 
34a9			 
34a9					; set I counter 
34a9			 
34a9 22 dd e5				ld (os_current_i), hl 
34ac			 
34ac					if DEBUG_FORTH_WORDS 
34ac						DMARK "LPN" 
34ac f5				push af  
34ad 3a c1 34			ld a, (.dmark)  
34b0 32 62 ee			ld (debug_mark),a  
34b3 3a c2 34			ld a, (.dmark+1)  
34b6 32 63 ee			ld (debug_mark+1),a  
34b9 3a c3 34			ld a, (.dmark+2)  
34bc 32 64 ee			ld (debug_mark+2),a  
34bf 18 03			jr .pastdmark  
34c1 ..			.dmark: db "LPN"  
34c4 f1			.pastdmark: pop af  
34c5			endm  
# End of macro DMARK
34c5					CALLMONITOR 
34c5 cd 6f ee			call debug_vector  
34c8				endm  
# End of macro CALLMONITOR
34c8					endif 
34c8					 
34c8				FORTH_LOOP_NEXT 
34c8 cd ff 1c			call macro_forth_loop_next 
34cb				endm 
# End of macro FORTH_LOOP_NEXT
34cb			 
34cb			 
34cb					if DEBUG_FORTH_WORDS 
34cb eb						ex de,hl 
34cc					endif 
34cc			 
34cc			;	; get DO ptr 
34cc			; 
34cc					if DEBUG_FORTH_WORDS 
34cc						DMARK "LP7" 
34cc f5				push af  
34cd 3a e1 34			ld a, (.dmark)  
34d0 32 62 ee			ld (debug_mark),a  
34d3 3a e2 34			ld a, (.dmark+1)  
34d6 32 63 ee			ld (debug_mark+1),a  
34d9 3a e3 34			ld a, (.dmark+2)  
34dc 32 64 ee			ld (debug_mark+2),a  
34df 18 03			jr .pastdmark  
34e1 ..			.dmark: db "LP7"  
34e4 f1			.pastdmark: pop af  
34e5			endm  
# End of macro DMARK
34e5					CALLMONITOR 
34e5 cd 6f ee			call debug_vector  
34e8				endm  
# End of macro CALLMONITOR
34e8					endif 
34e8				FORTH_RSP_TOS 
34e8 cd 90 1a			call macro_forth_rsp_tos 
34eb				endm 
# End of macro FORTH_RSP_TOS
34eb			 
34eb					if DEBUG_FORTH_WORDS 
34eb						DMARK "LP8" 
34eb f5				push af  
34ec 3a 00 35			ld a, (.dmark)  
34ef 32 62 ee			ld (debug_mark),a  
34f2 3a 01 35			ld a, (.dmark+1)  
34f5 32 63 ee			ld (debug_mark+1),a  
34f8 3a 02 35			ld a, (.dmark+2)  
34fb 32 64 ee			ld (debug_mark+2),a  
34fe 18 03			jr .pastdmark  
3500 ..			.dmark: db "LP8"  
3503 f1			.pastdmark: pop af  
3504			endm  
# End of macro DMARK
3504					CALLMONITOR 
3504 cd 6f ee			call debug_vector  
3507				endm  
# End of macro CALLMONITOR
3507					endif 
3507				;push hl 
3507			 
3507				; not going to DO any more 
3507				; get rid of the RSP pointer as DO will add it back in 
3507				;FORTH_RSP_POP 
3507				;pop hl 
3507			 
3507				;ld hl,(cli_ret_sp) 
3507				;ld e, (hl) 
3507				;inc hl 
3507				;ld d, (hl) 
3507				;ex de,hl 
3507 22 b9 e5			ld (os_tok_ptr), hl 
350a					if DEBUG_FORTH_WORDS 
350a						DMARK "LP<" 
350a f5				push af  
350b 3a 1f 35			ld a, (.dmark)  
350e 32 62 ee			ld (debug_mark),a  
3511 3a 20 35			ld a, (.dmark+1)  
3514 32 63 ee			ld (debug_mark+1),a  
3517 3a 21 35			ld a, (.dmark+2)  
351a 32 64 ee			ld (debug_mark+2),a  
351d 18 03			jr .pastdmark  
351f ..			.dmark: db "LP<"  
3522 f1			.pastdmark: pop af  
3523			endm  
# End of macro DMARK
3523					CALLMONITOR 
3523 cd 6f ee			call debug_vector  
3526				endm  
# End of macro CALLMONITOR
3526				endif 
3526 c3 36 1f			jp exec1 
3529			 
3529					 
3529			 
3529			 
3529					NEXTW 
3529 cd 6c ee			call parse_vector 
352c c3 b5 1e			jp macro_next 
352f				endm 
# End of macro NEXTW
352f			.I:  
352f			 
352f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
352f 5e				db WORD_SYS_CORE+74             
3530 5d 35			dw .DLOOP            
3532 02				db 1 + 1 
3533 .. 00			db "I",0              
3535				endm 
# End of macro CWHEAD
3535			; | I ( -- ) Current loop counter | DONE 
3535					if DEBUG_FORTH_WORDS_KEY 
3535						DMARK "I.." 
3535 f5				push af  
3536 3a 4a 35			ld a, (.dmark)  
3539 32 62 ee			ld (debug_mark),a  
353c 3a 4b 35			ld a, (.dmark+1)  
353f 32 63 ee			ld (debug_mark+1),a  
3542 3a 4c 35			ld a, (.dmark+2)  
3545 32 64 ee			ld (debug_mark+2),a  
3548 18 03			jr .pastdmark  
354a ..			.dmark: db "I.."  
354d f1			.pastdmark: pop af  
354e			endm  
# End of macro DMARK
354e						CALLMONITOR 
354e cd 6f ee			call debug_vector  
3551				endm  
# End of macro CALLMONITOR
3551					endif 
3551			 
3551 2a dd e5				ld hl,(os_current_i) 
3554 cd d2 1a				call forth_push_numhl 
3557			 
3557					NEXTW 
3557 cd 6c ee			call parse_vector 
355a c3 b5 1e			jp macro_next 
355d				endm 
# End of macro NEXTW
355d			.DLOOP: 
355d				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
355d 5f				db WORD_SYS_CORE+75             
355e 44 36			dw .REPEAT            
3560 06				db 5 + 1 
3561 .. 00			db "-LOOP",0              
3567				endm 
# End of macro CWHEAD
3567			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3567				; pop tos as current loop count to hl 
3567					if DEBUG_FORTH_WORDS_KEY 
3567						DMARK "-LP" 
3567 f5				push af  
3568 3a 7c 35			ld a, (.dmark)  
356b 32 62 ee			ld (debug_mark),a  
356e 3a 7d 35			ld a, (.dmark+1)  
3571 32 63 ee			ld (debug_mark+1),a  
3574 3a 7e 35			ld a, (.dmark+2)  
3577 32 64 ee			ld (debug_mark+2),a  
357a 18 03			jr .pastdmark  
357c ..			.dmark: db "-LP"  
357f f1			.pastdmark: pop af  
3580			endm  
# End of macro DMARK
3580						CALLMONITOR 
3580 cd 6f ee			call debug_vector  
3583				endm  
# End of macro CALLMONITOR
3583					endif 
3583			 
3583				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3583			 
3583				FORTH_LOOP_TOS 
3583 cd 32 1d			call macro_forth_loop_tos 
3586				endm 
# End of macro FORTH_LOOP_TOS
3586 e5				push hl 
3587			 
3587					if DEBUG_FORTH_WORDS 
3587						DMARK "-LP" 
3587 f5				push af  
3588 3a 9c 35			ld a, (.dmark)  
358b 32 62 ee			ld (debug_mark),a  
358e 3a 9d 35			ld a, (.dmark+1)  
3591 32 63 ee			ld (debug_mark+1),a  
3594 3a 9e 35			ld a, (.dmark+2)  
3597 32 64 ee			ld (debug_mark+2),a  
359a 18 03			jr .pastdmark  
359c ..			.dmark: db "-LP"  
359f f1			.pastdmark: pop af  
35a0			endm  
# End of macro DMARK
35a0						CALLMONITOR 
35a0 cd 6f ee			call debug_vector  
35a3				endm  
# End of macro CALLMONITOR
35a3					endif 
35a3				; next item on the stack is the limit. get it 
35a3			 
35a3			 
35a3				FORTH_LOOP_POP 
35a3 cd 3c 1d			call macro_forth_loop_pop 
35a6				endm 
# End of macro FORTH_LOOP_POP
35a6			 
35a6				FORTH_LOOP_TOS 
35a6 cd 32 1d			call macro_forth_loop_tos 
35a9				endm 
# End of macro FORTH_LOOP_TOS
35a9			 
35a9 d1				pop de		 ; de = i, hl = limit 
35aa			 
35aa					if DEBUG_FORTH_WORDS 
35aa						DMARK "-L1" 
35aa f5				push af  
35ab 3a bf 35			ld a, (.dmark)  
35ae 32 62 ee			ld (debug_mark),a  
35b1 3a c0 35			ld a, (.dmark+1)  
35b4 32 63 ee			ld (debug_mark+1),a  
35b7 3a c1 35			ld a, (.dmark+2)  
35ba 32 64 ee			ld (debug_mark+2),a  
35bd 18 03			jr .pastdmark  
35bf ..			.dmark: db "-L1"  
35c2 f1			.pastdmark: pop af  
35c3			endm  
# End of macro DMARK
35c3						CALLMONITOR 
35c3 cd 6f ee			call debug_vector  
35c6				endm  
# End of macro CALLMONITOR
35c6					endif 
35c6			 
35c6				; go back to previous word 
35c6			 
35c6 d5				push de    ; save I for inc later 
35c7			 
35c7			 
35c7				; get limit 
35c7				;  is I at limit? 
35c7			 
35c7			 
35c7					if DEBUG_FORTH_WORDS 
35c7						DMARK "-L1" 
35c7 f5				push af  
35c8 3a dc 35			ld a, (.dmark)  
35cb 32 62 ee			ld (debug_mark),a  
35ce 3a dd 35			ld a, (.dmark+1)  
35d1 32 63 ee			ld (debug_mark+1),a  
35d4 3a de 35			ld a, (.dmark+2)  
35d7 32 64 ee			ld (debug_mark+2),a  
35da 18 03			jr .pastdmark  
35dc ..			.dmark: db "-L1"  
35df f1			.pastdmark: pop af  
35e0			endm  
# End of macro DMARK
35e0						CALLMONITOR 
35e0 cd 6f ee			call debug_vector  
35e3				endm  
# End of macro CALLMONITOR
35e3					endif 
35e3			 
35e3 ed 52			sbc hl, de 
35e5			 
35e5			 
35e5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35e5			 
35e5 20 29				jr nz, .mloopnotdone 
35e7			 
35e7 e1				pop hl   ; get rid of saved I 
35e8				FORTH_LOOP_POP     ; get rid of limit 
35e8 cd 3c 1d			call macro_forth_loop_pop 
35eb				endm 
# End of macro FORTH_LOOP_POP
35eb			 
35eb				FORTH_RSP_POP     ; get rid of DO ptr 
35eb cd 9a 1a			call macro_forth_rsp_pop 
35ee				endm 
# End of macro FORTH_RSP_POP
35ee			 
35ee			if DEBUG_FORTH_WORDS 
35ee						DMARK "-L>" 
35ee f5				push af  
35ef 3a 03 36			ld a, (.dmark)  
35f2 32 62 ee			ld (debug_mark),a  
35f5 3a 04 36			ld a, (.dmark+1)  
35f8 32 63 ee			ld (debug_mark+1),a  
35fb 3a 05 36			ld a, (.dmark+2)  
35fe 32 64 ee			ld (debug_mark+2),a  
3601 18 03			jr .pastdmark  
3603 ..			.dmark: db "-L>"  
3606 f1			.pastdmark: pop af  
3607			endm  
# End of macro DMARK
3607				CALLMONITOR 
3607 cd 6f ee			call debug_vector  
360a				endm  
# End of macro CALLMONITOR
360a			endif 
360a			 
360a					NEXTW 
360a cd 6c ee			call parse_vector 
360d c3 b5 1e			jp macro_next 
3610				endm 
# End of macro NEXTW
3610				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3610			 
3610			.mloopnotdone: 
3610			 
3610 e1				pop hl    ; get I 
3611 2b				dec hl 
3612			 
3612			   	; save new I 
3612			 
3612			 
3612					; set I counter 
3612			 
3612 22 dd e5				ld (os_current_i), hl 
3615			 
3615					 
3615				FORTH_LOOP_NEXT 
3615 cd ff 1c			call macro_forth_loop_next 
3618				endm 
# End of macro FORTH_LOOP_NEXT
3618			 
3618			 
3618					if DEBUG_FORTH_WORDS 
3618 eb						ex de,hl 
3619					endif 
3619			 
3619			;	; get DO ptr 
3619			; 
3619				FORTH_RSP_TOS 
3619 cd 90 1a			call macro_forth_rsp_tos 
361c				endm 
# End of macro FORTH_RSP_TOS
361c			 
361c				;push hl 
361c			 
361c				; not going to DO any more 
361c				; get rid of the RSP pointer as DO will add it back in 
361c				;FORTH_RSP_POP 
361c				;pop hl 
361c			 
361c			 
361c 22 b9 e5			ld (os_tok_ptr), hl 
361f					if DEBUG_FORTH_WORDS 
361f						DMARK "-L<" 
361f f5				push af  
3620 3a 34 36			ld a, (.dmark)  
3623 32 62 ee			ld (debug_mark),a  
3626 3a 35 36			ld a, (.dmark+1)  
3629 32 63 ee			ld (debug_mark+1),a  
362c 3a 36 36			ld a, (.dmark+2)  
362f 32 64 ee			ld (debug_mark+2),a  
3632 18 03			jr .pastdmark  
3634 ..			.dmark: db "-L<"  
3637 f1			.pastdmark: pop af  
3638			endm  
# End of macro DMARK
3638					CALLMONITOR 
3638 cd 6f ee			call debug_vector  
363b				endm  
# End of macro CALLMONITOR
363b				endif 
363b c3 36 1f			jp exec1 
363e			 
363e					 
363e			 
363e			 
363e			 
363e				NEXTW 
363e cd 6c ee			call parse_vector 
3641 c3 b5 1e			jp macro_next 
3644				endm 
# End of macro NEXTW
3644			 
3644			 
3644			 
3644			 
3644			.REPEAT: 
3644				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3644 71				db WORD_SYS_CORE+93             
3645 9a 36			dw .UNTIL            
3647 06				db 5 + 1 
3648 .. 00			db "REPEAT",0              
364f				endm 
# End of macro CWHEAD
364f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
364f			;  push pc to rsp stack past the REPEAT 
364f					if DEBUG_FORTH_WORDS_KEY 
364f						DMARK "REP" 
364f f5				push af  
3650 3a 64 36			ld a, (.dmark)  
3653 32 62 ee			ld (debug_mark),a  
3656 3a 65 36			ld a, (.dmark+1)  
3659 32 63 ee			ld (debug_mark+1),a  
365c 3a 66 36			ld a, (.dmark+2)  
365f 32 64 ee			ld (debug_mark+2),a  
3662 18 03			jr .pastdmark  
3664 ..			.dmark: db "REP"  
3667 f1			.pastdmark: pop af  
3668			endm  
# End of macro DMARK
3668						CALLMONITOR 
3668 cd 6f ee			call debug_vector  
366b				endm  
# End of macro CALLMONITOR
366b					endif 
366b			 
366b 2a b9 e5				ld hl, (os_tok_ptr) 
366e 23					inc hl   ; R 
366f 23					inc hl  ; E 
3670 23					inc hl   ; P 
3671 23					inc hl   ; E 
3672 23					inc hl   ; A 
3673 23					inc hl   ; T 
3674 23					inc hl   ; zero 
3675					FORTH_RSP_NEXT 
3675 cd 79 1a			call macro_forth_rsp_next 
3678				endm 
# End of macro FORTH_RSP_NEXT
3678			 
3678			 
3678					if DEBUG_FORTH_WORDS 
3678						DMARK "REP" 
3678 f5				push af  
3679 3a 8d 36			ld a, (.dmark)  
367c 32 62 ee			ld (debug_mark),a  
367f 3a 8e 36			ld a, (.dmark+1)  
3682 32 63 ee			ld (debug_mark+1),a  
3685 3a 8f 36			ld a, (.dmark+2)  
3688 32 64 ee			ld (debug_mark+2),a  
368b 18 03			jr .pastdmark  
368d ..			.dmark: db "REP"  
3690 f1			.pastdmark: pop af  
3691			endm  
# End of macro DMARK
3691						;pop bc    ; TODO BUG ?????? what is this for???? 
3691						CALLMONITOR 
3691 cd 6f ee			call debug_vector  
3694				endm  
# End of macro CALLMONITOR
3694					endif 
3694			 
3694					NEXTW 
3694 cd 6c ee			call parse_vector 
3697 c3 b5 1e			jp macro_next 
369a				endm 
# End of macro NEXTW
369a			;	       NEXTW 
369a			 
369a			.UNTIL: 
369a				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
369a 72				db WORD_SYS_CORE+94             
369b 37 37			dw .ENDFLOW            
369d 06				db 5 + 1 
369e .. 00			db "UNTIL",0              
36a4				endm 
# End of macro CWHEAD
36a4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36a4			 
36a4				; pop tos as check 
36a4			 
36a4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36a4			 
36a4				FORTH_DSP_VALUEHL 
36a4 cd ce 1c			call macro_dsp_valuehl 
36a7				endm 
# End of macro FORTH_DSP_VALUEHL
36a7			 
36a7					if DEBUG_FORTH_WORDS_KEY 
36a7						DMARK "UNT" 
36a7 f5				push af  
36a8 3a bc 36			ld a, (.dmark)  
36ab 32 62 ee			ld (debug_mark),a  
36ae 3a bd 36			ld a, (.dmark+1)  
36b1 32 63 ee			ld (debug_mark+1),a  
36b4 3a be 36			ld a, (.dmark+2)  
36b7 32 64 ee			ld (debug_mark+2),a  
36ba 18 03			jr .pastdmark  
36bc ..			.dmark: db "UNT"  
36bf f1			.pastdmark: pop af  
36c0			endm  
# End of macro DMARK
36c0						CALLMONITOR 
36c0 cd 6f ee			call debug_vector  
36c3				endm  
# End of macro CALLMONITOR
36c3					endif 
36c3			 
36c3			;	push hl 
36c3				FORTH_DSP_POP 
36c3 cd 86 1d			call macro_forth_dsp_pop 
36c6				endm 
# End of macro FORTH_DSP_POP
36c6			 
36c6			;	pop hl 
36c6			 
36c6				; test if true 
36c6			 
36c6 cd 0a 0e			call ishlzero 
36c9			;	ld a,l 
36c9			;	add h 
36c9			; 
36c9			;	cp 0 
36c9			 
36c9 20 41			jr nz, .untilnotdone 
36cb			 
36cb					if DEBUG_FORTH_WORDS 
36cb						DMARK "UNf" 
36cb f5				push af  
36cc 3a e0 36			ld a, (.dmark)  
36cf 32 62 ee			ld (debug_mark),a  
36d2 3a e1 36			ld a, (.dmark+1)  
36d5 32 63 ee			ld (debug_mark+1),a  
36d8 3a e2 36			ld a, (.dmark+2)  
36db 32 64 ee			ld (debug_mark+2),a  
36de 18 03			jr .pastdmark  
36e0 ..			.dmark: db "UNf"  
36e3 f1			.pastdmark: pop af  
36e4			endm  
# End of macro DMARK
36e4						CALLMONITOR 
36e4 cd 6f ee			call debug_vector  
36e7				endm  
# End of macro CALLMONITOR
36e7					endif 
36e7			 
36e7			 
36e7			 
36e7				FORTH_RSP_POP     ; get rid of DO ptr 
36e7 cd 9a 1a			call macro_forth_rsp_pop 
36ea				endm 
# End of macro FORTH_RSP_POP
36ea			 
36ea			if DEBUG_FORTH_WORDS 
36ea						DMARK "UN>" 
36ea f5				push af  
36eb 3a ff 36			ld a, (.dmark)  
36ee 32 62 ee			ld (debug_mark),a  
36f1 3a 00 37			ld a, (.dmark+1)  
36f4 32 63 ee			ld (debug_mark+1),a  
36f7 3a 01 37			ld a, (.dmark+2)  
36fa 32 64 ee			ld (debug_mark+2),a  
36fd 18 03			jr .pastdmark  
36ff ..			.dmark: db "UN>"  
3702 f1			.pastdmark: pop af  
3703			endm  
# End of macro DMARK
3703				CALLMONITOR 
3703 cd 6f ee			call debug_vector  
3706				endm  
# End of macro CALLMONITOR
3706			endif 
3706			 
3706					NEXTW 
3706 cd 6c ee			call parse_vector 
3709 c3 b5 1e			jp macro_next 
370c				endm 
# End of macro NEXTW
370c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
370c			 
370c			.untilnotdone: 
370c			 
370c			 
370c			;	; get DO ptr 
370c			; 
370c				FORTH_RSP_TOS 
370c cd 90 1a			call macro_forth_rsp_tos 
370f				endm 
# End of macro FORTH_RSP_TOS
370f			 
370f				;push hl 
370f			 
370f				; not going to DO any more 
370f				; get rid of the RSP pointer as DO will add it back in 
370f				;FORTH_RSP_POP 
370f				;pop hl 
370f			 
370f			 
370f 22 b9 e5			ld (os_tok_ptr), hl 
3712					if DEBUG_FORTH_WORDS 
3712						DMARK "UN<" 
3712 f5				push af  
3713 3a 27 37			ld a, (.dmark)  
3716 32 62 ee			ld (debug_mark),a  
3719 3a 28 37			ld a, (.dmark+1)  
371c 32 63 ee			ld (debug_mark+1),a  
371f 3a 29 37			ld a, (.dmark+2)  
3722 32 64 ee			ld (debug_mark+2),a  
3725 18 03			jr .pastdmark  
3727 ..			.dmark: db "UN<"  
372a f1			.pastdmark: pop af  
372b			endm  
# End of macro DMARK
372b					CALLMONITOR 
372b cd 6f ee			call debug_vector  
372e				endm  
# End of macro CALLMONITOR
372e				endif 
372e c3 36 1f			jp exec1 
3731			 
3731					 
3731			 
3731			 
3731					NEXTW 
3731 cd 6c ee			call parse_vector 
3734 c3 b5 1e			jp macro_next 
3737				endm 
# End of macro NEXTW
3737			 
3737			 
3737			.ENDFLOW: 
3737			 
3737			; eof 
3737			 
# End of file forth_words_flow.asm
3737			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3737			include "forth_words_logic.asm" 
3737			 
3737			; | ## Logic Words 
3737			 
3737			.NOT: 
3737				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3737 2d				db WORD_SYS_CORE+25             
3738 85 37			dw .IS            
373a 04				db 3 + 1 
373b .. 00			db "NOT",0              
373f				endm 
# End of macro CWHEAD
373f			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
373f					if DEBUG_FORTH_WORDS_KEY 
373f						DMARK "NOT" 
373f f5				push af  
3740 3a 54 37			ld a, (.dmark)  
3743 32 62 ee			ld (debug_mark),a  
3746 3a 55 37			ld a, (.dmark+1)  
3749 32 63 ee			ld (debug_mark+1),a  
374c 3a 56 37			ld a, (.dmark+2)  
374f 32 64 ee			ld (debug_mark+2),a  
3752 18 03			jr .pastdmark  
3754 ..			.dmark: db "NOT"  
3757 f1			.pastdmark: pop af  
3758			endm  
# End of macro DMARK
3758						CALLMONITOR 
3758 cd 6f ee			call debug_vector  
375b				endm  
# End of macro CALLMONITOR
375b					endif 
375b					FORTH_DSP 
375b cd 94 1c			call macro_forth_dsp 
375e				endm 
# End of macro FORTH_DSP
375e 7e					ld a,(hl)	; get type of value on TOS 
375f fe 02				cp DS_TYPE_INUM  
3761 28 06				jr z, .noti 
3763					NEXTW 
3763 cd 6c ee			call parse_vector 
3766 c3 b5 1e			jp macro_next 
3769				endm 
# End of macro NEXTW
3769			.noti:          FORTH_DSP_VALUEHL 
3769 cd ce 1c			call macro_dsp_valuehl 
376c				endm 
# End of macro FORTH_DSP_VALUEHL
376c			;		push hl 
376c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376c cd 86 1d			call macro_forth_dsp_pop 
376f				endm 
# End of macro FORTH_DSP_POP
376f			;		pop hl 
376f 3e 00				ld a,0 
3771 bd					cp l 
3772 28 04				jr z, .not2t 
3774 2e 00				ld l, 0 
3776 18 02				jr .notip 
3778			 
3778 2e ff		.not2t:		ld l, 255 
377a			 
377a 26 00		.notip:		ld h, 0	 
377c			 
377c cd d2 1a				call forth_push_numhl 
377f					NEXTW 
377f cd 6c ee			call parse_vector 
3782 c3 b5 1e			jp macro_next 
3785				endm 
# End of macro NEXTW
3785			 
3785			.IS: 
3785				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3785 2d				db WORD_SYS_CORE+25             
3786 c9 37			dw .LZERO            
3788 08				db 7 + 1 
3789 .. 00			db "COMPARE",0              
3791				endm 
# End of macro CWHEAD
3791			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3791					if DEBUG_FORTH_WORDS_KEY 
3791						DMARK "CMP" 
3791 f5				push af  
3792 3a a6 37			ld a, (.dmark)  
3795 32 62 ee			ld (debug_mark),a  
3798 3a a7 37			ld a, (.dmark+1)  
379b 32 63 ee			ld (debug_mark+1),a  
379e 3a a8 37			ld a, (.dmark+2)  
37a1 32 64 ee			ld (debug_mark+2),a  
37a4 18 03			jr .pastdmark  
37a6 ..			.dmark: db "CMP"  
37a9 f1			.pastdmark: pop af  
37aa			endm  
# End of macro DMARK
37aa						CALLMONITOR 
37aa cd 6f ee			call debug_vector  
37ad				endm  
# End of macro CALLMONITOR
37ad					endif 
37ad			 
37ad					FORTH_DSP_VALUEHL 
37ad cd ce 1c			call macro_dsp_valuehl 
37b0				endm 
# End of macro FORTH_DSP_VALUEHL
37b0			 
37b0 e5					push hl 
37b1			 
37b1					FORTH_DSP_VALUEM1 
37b1 cd c2 1c			call macro_forth_dsp_value_m1 
37b4				endm 
# End of macro FORTH_DSP_VALUEM1
37b4			 
37b4 d1					pop de 
37b5			 
37b5					; got pointers to both. Now check. 
37b5			 
37b5 cd 71 11				call strcmp 
37b8				 
37b8 26 00				ld h, 0 
37ba 2e 00				ld l, 0 
37bc 20 02				jr nz, .compnsame 
37be 2e 01				ld l, 1	 
37c0			.compnsame: 
37c0 cd d2 1a				call forth_push_numhl 
37c3			 
37c3					NEXTW 
37c3 cd 6c ee			call parse_vector 
37c6 c3 b5 1e			jp macro_next 
37c9				endm 
# End of macro NEXTW
37c9			.LZERO: 
37c9				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37c9 2d				db WORD_SYS_CORE+25             
37ca d6 37			dw .TZERO            
37cc 03				db 2 + 1 
37cd .. 00			db "0<",0              
37d0				endm 
# End of macro CWHEAD
37d0			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37d0					NEXTW 
37d0 cd 6c ee			call parse_vector 
37d3 c3 b5 1e			jp macro_next 
37d6				endm 
# End of macro NEXTW
37d6			.TZERO: 
37d6				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37d6 2e				db WORD_SYS_CORE+26             
37d7 20 38			dw .LESS            
37d9 03				db 2 + 1 
37da .. 00			db "0=",0              
37dd				endm 
# End of macro CWHEAD
37dd			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
37dd				; TODO add floating point number detection 
37dd					;v5 FORTH_DSP_VALUE 
37dd					if DEBUG_FORTH_WORDS_KEY 
37dd						DMARK "0=." 
37dd f5				push af  
37de 3a f2 37			ld a, (.dmark)  
37e1 32 62 ee			ld (debug_mark),a  
37e4 3a f3 37			ld a, (.dmark+1)  
37e7 32 63 ee			ld (debug_mark+1),a  
37ea 3a f4 37			ld a, (.dmark+2)  
37ed 32 64 ee			ld (debug_mark+2),a  
37f0 18 03			jr .pastdmark  
37f2 ..			.dmark: db "0=."  
37f5 f1			.pastdmark: pop af  
37f6			endm  
# End of macro DMARK
37f6						CALLMONITOR 
37f6 cd 6f ee			call debug_vector  
37f9				endm  
# End of macro CALLMONITOR
37f9					endif 
37f9					FORTH_DSP 
37f9 cd 94 1c			call macro_forth_dsp 
37fc				endm 
# End of macro FORTH_DSP
37fc 7e					ld a,(hl)	; get type of value on TOS 
37fd fe 02				cp DS_TYPE_INUM  
37ff 28 00				jr z, .tz_inum 
3801			 
3801				if FORTH_ENABLE_FLOATMATH 
3801					jr .tz_done 
3801			 
3801				endif 
3801					 
3801			 
3801			.tz_inum: 
3801					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3801 cd ce 1c			call macro_dsp_valuehl 
3804				endm 
# End of macro FORTH_DSP_VALUEHL
3804			 
3804			;		push hl 
3804			 
3804					; destroy value TOS 
3804			 
3804					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3804 cd 86 1d			call macro_forth_dsp_pop 
3807				endm 
# End of macro FORTH_DSP_POP
3807			 
3807			;		pop hl 
3807			 
3807 3e 00				ld a,0 
3809			 
3809 bd					cp l 
380a 20 08				jr nz, .tz_notzero 
380c			 
380c bc					cp h 
380d			 
380d 20 05				jr nz, .tz_notzero 
380f			 
380f			 
380f 21 01 00				ld hl, FORTH_TRUE 
3812 18 03				jr .tz_done 
3814			 
3814 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3817			 
3817					; push value back onto stack for another op etc 
3817			 
3817			.tz_done: 
3817 cd d2 1a				call forth_push_numhl 
381a			 
381a					NEXTW 
381a cd 6c ee			call parse_vector 
381d c3 b5 1e			jp macro_next 
3820				endm 
# End of macro NEXTW
3820			.LESS: 
3820				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3820 2f				db WORD_SYS_CORE+27             
3821 8c 38			dw .GT            
3823 02				db 1 + 1 
3824 .. 00			db "<",0              
3826				endm 
# End of macro CWHEAD
3826			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3826				; TODO add floating point number detection 
3826					if DEBUG_FORTH_WORDS_KEY 
3826						DMARK "LES" 
3826 f5				push af  
3827 3a 3b 38			ld a, (.dmark)  
382a 32 62 ee			ld (debug_mark),a  
382d 3a 3c 38			ld a, (.dmark+1)  
3830 32 63 ee			ld (debug_mark+1),a  
3833 3a 3d 38			ld a, (.dmark+2)  
3836 32 64 ee			ld (debug_mark+2),a  
3839 18 03			jr .pastdmark  
383b ..			.dmark: db "LES"  
383e f1			.pastdmark: pop af  
383f			endm  
# End of macro DMARK
383f						CALLMONITOR 
383f cd 6f ee			call debug_vector  
3842				endm  
# End of macro CALLMONITOR
3842					endif 
3842					FORTH_DSP 
3842 cd 94 1c			call macro_forth_dsp 
3845				endm 
# End of macro FORTH_DSP
3845					;v5 FORTH_DSP_VALUE 
3845 7e					ld a,(hl)	; get type of value on TOS 
3846 fe 02				cp DS_TYPE_INUM  
3848 28 00				jr z, .less_inum 
384a			 
384a				if FORTH_ENABLE_FLOATMATH 
384a					jr .less_done 
384a			 
384a				endif 
384a					 
384a			 
384a			.less_inum: 
384a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
384a cd ce 1c			call macro_dsp_valuehl 
384d				endm 
# End of macro FORTH_DSP_VALUEHL
384d			 
384d e5					push hl  ; u2 
384e			 
384e					; destroy value TOS 
384e			 
384e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
384e cd 86 1d			call macro_forth_dsp_pop 
3851				endm 
# End of macro FORTH_DSP_POP
3851			 
3851			 
3851					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3851 cd ce 1c			call macro_dsp_valuehl 
3854				endm 
# End of macro FORTH_DSP_VALUEHL
3854			 
3854 e5					push hl    ; u1 
3855			 
3855					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3855 cd 86 1d			call macro_forth_dsp_pop 
3858				endm 
# End of macro FORTH_DSP_POP
3858			 
3858			 
3858 b7			 or a      ;clear carry flag 
3859 01 00 00		 ld bc, FORTH_FALSE 
385c e1			  pop hl    ; u1 
385d d1			  pop de    ; u2 
385e ed 52		  sbc hl,de 
3860 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3862			 
3862 01 01 00		 ld bc, FORTH_TRUE 
3865			.lscont:  
3865 c5					push bc 
3866 e1					pop hl 
3867			 
3867					if DEBUG_FORTH_WORDS 
3867						DMARK "LT1" 
3867 f5				push af  
3868 3a 7c 38			ld a, (.dmark)  
386b 32 62 ee			ld (debug_mark),a  
386e 3a 7d 38			ld a, (.dmark+1)  
3871 32 63 ee			ld (debug_mark+1),a  
3874 3a 7e 38			ld a, (.dmark+2)  
3877 32 64 ee			ld (debug_mark+2),a  
387a 18 03			jr .pastdmark  
387c ..			.dmark: db "LT1"  
387f f1			.pastdmark: pop af  
3880			endm  
# End of macro DMARK
3880						CALLMONITOR 
3880 cd 6f ee			call debug_vector  
3883				endm  
# End of macro CALLMONITOR
3883					endif 
3883 cd d2 1a				call forth_push_numhl 
3886			 
3886					NEXTW 
3886 cd 6c ee			call parse_vector 
3889 c3 b5 1e			jp macro_next 
388c				endm 
# End of macro NEXTW
388c			.GT: 
388c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
388c 30				db WORD_SYS_CORE+28             
388d f8 38			dw .EQUAL            
388f 02				db 1 + 1 
3890 .. 00			db ">",0              
3892				endm 
# End of macro CWHEAD
3892			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3892				; TODO add floating point number detection 
3892					if DEBUG_FORTH_WORDS_KEY 
3892						DMARK "GRT" 
3892 f5				push af  
3893 3a a7 38			ld a, (.dmark)  
3896 32 62 ee			ld (debug_mark),a  
3899 3a a8 38			ld a, (.dmark+1)  
389c 32 63 ee			ld (debug_mark+1),a  
389f 3a a9 38			ld a, (.dmark+2)  
38a2 32 64 ee			ld (debug_mark+2),a  
38a5 18 03			jr .pastdmark  
38a7 ..			.dmark: db "GRT"  
38aa f1			.pastdmark: pop af  
38ab			endm  
# End of macro DMARK
38ab						CALLMONITOR 
38ab cd 6f ee			call debug_vector  
38ae				endm  
# End of macro CALLMONITOR
38ae					endif 
38ae					FORTH_DSP 
38ae cd 94 1c			call macro_forth_dsp 
38b1				endm 
# End of macro FORTH_DSP
38b1					;FORTH_DSP_VALUE 
38b1 7e					ld a,(hl)	; get type of value on TOS 
38b2 fe 02				cp DS_TYPE_INUM  
38b4 28 00				jr z, .gt_inum 
38b6			 
38b6				if FORTH_ENABLE_FLOATMATH 
38b6					jr .gt_done 
38b6			 
38b6				endif 
38b6					 
38b6			 
38b6			.gt_inum: 
38b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b6 cd ce 1c			call macro_dsp_valuehl 
38b9				endm 
# End of macro FORTH_DSP_VALUEHL
38b9			 
38b9 e5					push hl  ; u2 
38ba			 
38ba					; destroy value TOS 
38ba			 
38ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ba cd 86 1d			call macro_forth_dsp_pop 
38bd				endm 
# End of macro FORTH_DSP_POP
38bd			 
38bd			 
38bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38bd cd ce 1c			call macro_dsp_valuehl 
38c0				endm 
# End of macro FORTH_DSP_VALUEHL
38c0			 
38c0 e5					push hl    ; u1 
38c1			 
38c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c1 cd 86 1d			call macro_forth_dsp_pop 
38c4				endm 
# End of macro FORTH_DSP_POP
38c4			 
38c4			 
38c4 b7			 or a      ;clear carry flag 
38c5 01 00 00		 ld bc, FORTH_FALSE 
38c8 e1			  pop hl    ; u1 
38c9 d1			  pop de    ; u2 
38ca ed 52		  sbc hl,de 
38cc 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38ce			 
38ce 01 01 00		 ld bc, FORTH_TRUE 
38d1			.gtcont:  
38d1 c5					push bc 
38d2 e1					pop hl 
38d3			 
38d3					if DEBUG_FORTH_WORDS 
38d3						DMARK "GT1" 
38d3 f5				push af  
38d4 3a e8 38			ld a, (.dmark)  
38d7 32 62 ee			ld (debug_mark),a  
38da 3a e9 38			ld a, (.dmark+1)  
38dd 32 63 ee			ld (debug_mark+1),a  
38e0 3a ea 38			ld a, (.dmark+2)  
38e3 32 64 ee			ld (debug_mark+2),a  
38e6 18 03			jr .pastdmark  
38e8 ..			.dmark: db "GT1"  
38eb f1			.pastdmark: pop af  
38ec			endm  
# End of macro DMARK
38ec						CALLMONITOR 
38ec cd 6f ee			call debug_vector  
38ef				endm  
# End of macro CALLMONITOR
38ef					endif 
38ef cd d2 1a				call forth_push_numhl 
38f2			 
38f2					NEXTW 
38f2 cd 6c ee			call parse_vector 
38f5 c3 b5 1e			jp macro_next 
38f8				endm 
# End of macro NEXTW
38f8			.EQUAL: 
38f8				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38f8 31				db WORD_SYS_CORE+29             
38f9 66 39			dw .ENDLOGIC            
38fb 02				db 1 + 1 
38fc .. 00			db "=",0              
38fe				endm 
# End of macro CWHEAD
38fe			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
38fe				; TODO add floating point number detection 
38fe					if DEBUG_FORTH_WORDS_KEY 
38fe						DMARK "EQ." 
38fe f5				push af  
38ff 3a 13 39			ld a, (.dmark)  
3902 32 62 ee			ld (debug_mark),a  
3905 3a 14 39			ld a, (.dmark+1)  
3908 32 63 ee			ld (debug_mark+1),a  
390b 3a 15 39			ld a, (.dmark+2)  
390e 32 64 ee			ld (debug_mark+2),a  
3911 18 03			jr .pastdmark  
3913 ..			.dmark: db "EQ."  
3916 f1			.pastdmark: pop af  
3917			endm  
# End of macro DMARK
3917						CALLMONITOR 
3917 cd 6f ee			call debug_vector  
391a				endm  
# End of macro CALLMONITOR
391a					endif 
391a					FORTH_DSP 
391a cd 94 1c			call macro_forth_dsp 
391d				endm 
# End of macro FORTH_DSP
391d					;v5 FORTH_DSP_VALUE 
391d 7e					ld a,(hl)	; get type of value on TOS 
391e fe 02				cp DS_TYPE_INUM  
3920 28 00				jr z, .eq_inum 
3922			 
3922				if FORTH_ENABLE_FLOATMATH 
3922					jr .eq_done 
3922			 
3922				endif 
3922					 
3922			 
3922			.eq_inum: 
3922					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3922 cd ce 1c			call macro_dsp_valuehl 
3925				endm 
# End of macro FORTH_DSP_VALUEHL
3925			 
3925 e5					push hl 
3926			 
3926					; destroy value TOS 
3926			 
3926					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3926 cd 86 1d			call macro_forth_dsp_pop 
3929				endm 
# End of macro FORTH_DSP_POP
3929			 
3929			 
3929					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3929 cd ce 1c			call macro_dsp_valuehl 
392c				endm 
# End of macro FORTH_DSP_VALUEHL
392c			 
392c					; one value on hl get other one back 
392c			 
392c e5					push hl 
392d			 
392d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392d cd 86 1d			call macro_forth_dsp_pop 
3930				endm 
# End of macro FORTH_DSP_POP
3930			 
3930 0e 00				ld c, FORTH_FALSE 
3932			 
3932 e1					pop hl 
3933 d1					pop de 
3934			 
3934 7b					ld a, e 
3935 bd					cp l 
3936			 
3936 20 06				jr nz, .eq_done 
3938			 
3938 7a					ld a, d 
3939 bc					cp h 
393a			 
393a 20 02				jr nz, .eq_done 
393c			 
393c 0e 01				ld c, FORTH_TRUE 
393e					 
393e			 
393e			 
393e			.eq_done: 
393e			 
393e					; TODO push value back onto stack for another op etc 
393e			 
393e 26 00				ld h, 0 
3940 69					ld l, c 
3941					if DEBUG_FORTH_WORDS 
3941						DMARK "EQ1" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 62 ee			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 63 ee			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 64 ee			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "EQ1"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a						CALLMONITOR 
395a cd 6f ee			call debug_vector  
395d				endm  
# End of macro CALLMONITOR
395d					endif 
395d cd d2 1a				call forth_push_numhl 
3960			 
3960					NEXTW 
3960 cd 6c ee			call parse_vector 
3963 c3 b5 1e			jp macro_next 
3966				endm 
# End of macro NEXTW
3966			 
3966			 
3966			.ENDLOGIC: 
3966			; eof 
3966			 
3966			 
# End of file forth_words_logic.asm
3966			include "forth_words_maths.asm" 
3966			 
3966			; | ## Maths Words 
3966			 
3966			.PLUS:	 
3966				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3966 15				db WORD_SYS_CORE+1             
3967 ca 39			dw .NEG            
3969 02				db 1 + 1 
396a .. 00			db "+",0              
396c				endm 
# End of macro CWHEAD
396c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
396c					if DEBUG_FORTH_WORDS_KEY 
396c						DMARK "PLU" 
396c f5				push af  
396d 3a 81 39			ld a, (.dmark)  
3970 32 62 ee			ld (debug_mark),a  
3973 3a 82 39			ld a, (.dmark+1)  
3976 32 63 ee			ld (debug_mark+1),a  
3979 3a 83 39			ld a, (.dmark+2)  
397c 32 64 ee			ld (debug_mark+2),a  
397f 18 03			jr .pastdmark  
3981 ..			.dmark: db "PLU"  
3984 f1			.pastdmark: pop af  
3985			endm  
# End of macro DMARK
3985						CALLMONITOR 
3985 cd 6f ee			call debug_vector  
3988				endm  
# End of macro CALLMONITOR
3988					endif 
3988					; add top two values and push back result 
3988			 
3988					;for v5 FORTH_DSP_VALUE 
3988					FORTH_DSP 
3988 cd 94 1c			call macro_forth_dsp 
398b				endm 
# End of macro FORTH_DSP
398b 7e					ld a,(hl)	; get type of value on TOS 
398c fe 02				cp DS_TYPE_INUM  
398e 28 06				jr z, .dot_inum 
3990			 
3990					NEXTW 
3990 cd 6c ee			call parse_vector 
3993 c3 b5 1e			jp macro_next 
3996				endm 
# End of macro NEXTW
3996			 
3996			; float maths 
3996			 
3996				if FORTH_ENABLE_FLOATMATH 
3996						inc hl      ; now at start of numeric as string 
3996			 
3996					if DEBUG_FORTH_MATHS 
3996						DMARK "ADD" 
3996				CALLMONITOR 
3996					endif 
3996			 
3996					;ld ix, hl 
3996					call CON 
3996			 
3996			 
3996					push hl 
3996					 
3996					 
3996			 
3996						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3996			 
3996					; get next number 
3996			 
3996						FORTH_DSP_VALUE 
3996			 
3996						inc hl      ; now at start of numeric as string 
3996			 
3996					;ld ix, hl 
3996					call CON 
3996			 
3996					push hl 
3996			 
3996			 
3996						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3996			 
3996						; TODO do add 
3996			 
3996						call IADD 
3996			 
3996						; TODO get result back as ascii 
3996			 
3996						; TODO push result  
3996			 
3996			 
3996			 
3996						jr .dot_done 
3996				endif 
3996			 
3996			.dot_inum: 
3996			 
3996			 
3996					if DEBUG_FORTH_DOT 
3996						DMARK "+IT" 
3996 f5				push af  
3997 3a ab 39			ld a, (.dmark)  
399a 32 62 ee			ld (debug_mark),a  
399d 3a ac 39			ld a, (.dmark+1)  
39a0 32 63 ee			ld (debug_mark+1),a  
39a3 3a ad 39			ld a, (.dmark+2)  
39a6 32 64 ee			ld (debug_mark+2),a  
39a9 18 03			jr .pastdmark  
39ab ..			.dmark: db "+IT"  
39ae f1			.pastdmark: pop af  
39af			endm  
# End of macro DMARK
39af				CALLMONITOR 
39af cd 6f ee			call debug_vector  
39b2				endm  
# End of macro CALLMONITOR
39b2					endif 
39b2			 
39b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b2 cd ce 1c			call macro_dsp_valuehl 
39b5				endm 
# End of macro FORTH_DSP_VALUEHL
39b5			 
39b5				; TODO add floating point number detection 
39b5			 
39b5 e5					push hl 
39b6			 
39b6					; destroy value TOS 
39b6			 
39b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b6 cd 86 1d			call macro_forth_dsp_pop 
39b9				endm 
# End of macro FORTH_DSP_POP
39b9			 
39b9			 
39b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b9 cd ce 1c			call macro_dsp_valuehl 
39bc				endm 
# End of macro FORTH_DSP_VALUEHL
39bc			 
39bc					; one value on hl get other one back 
39bc			 
39bc d1					pop de 
39bd			 
39bd					; do the add 
39bd			 
39bd 19					add hl,de 
39be			 
39be					; save it 
39be			 
39be			;		push hl	 
39be			 
39be					; 
39be			 
39be					; destroy value TOS 
39be			 
39be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39be cd 86 1d			call macro_forth_dsp_pop 
39c1				endm 
# End of macro FORTH_DSP_POP
39c1			 
39c1					; TODO push value back onto stack for another op etc 
39c1			 
39c1			;		pop hl 
39c1			 
39c1			.dot_done: 
39c1 cd d2 1a				call forth_push_numhl 
39c4			 
39c4					NEXTW 
39c4 cd 6c ee			call parse_vector 
39c7 c3 b5 1e			jp macro_next 
39ca				endm 
# End of macro NEXTW
39ca			.NEG: 
39ca			 
39ca				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
39ca 17				db WORD_SYS_CORE+3             
39cb 13 3a			dw .DIV            
39cd 02				db 1 + 1 
39ce .. 00			db "-",0              
39d0				endm 
# End of macro CWHEAD
39d0			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39d0					if DEBUG_FORTH_WORDS_KEY 
39d0						DMARK "SUB" 
39d0 f5				push af  
39d1 3a e5 39			ld a, (.dmark)  
39d4 32 62 ee			ld (debug_mark),a  
39d7 3a e6 39			ld a, (.dmark+1)  
39da 32 63 ee			ld (debug_mark+1),a  
39dd 3a e7 39			ld a, (.dmark+2)  
39e0 32 64 ee			ld (debug_mark+2),a  
39e3 18 03			jr .pastdmark  
39e5 ..			.dmark: db "SUB"  
39e8 f1			.pastdmark: pop af  
39e9			endm  
# End of macro DMARK
39e9						CALLMONITOR 
39e9 cd 6f ee			call debug_vector  
39ec				endm  
# End of macro CALLMONITOR
39ec					endif 
39ec			 
39ec			 
39ec				; TODO add floating point number detection 
39ec					; v5 FORTH_DSP_VALUE 
39ec					FORTH_DSP 
39ec cd 94 1c			call macro_forth_dsp 
39ef				endm 
# End of macro FORTH_DSP
39ef 7e					ld a,(hl)	; get type of value on TOS 
39f0 fe 02				cp DS_TYPE_INUM  
39f2 28 06				jr z, .neg_inum 
39f4			 
39f4					NEXTW 
39f4 cd 6c ee			call parse_vector 
39f7 c3 b5 1e			jp macro_next 
39fa				endm 
# End of macro NEXTW
39fa			 
39fa			; float maths 
39fa			 
39fa				if FORTH_ENABLE_FLOATMATH 
39fa					jr .neg_done 
39fa			 
39fa				endif 
39fa					 
39fa			 
39fa			.neg_inum: 
39fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39fa cd ce 1c			call macro_dsp_valuehl 
39fd				endm 
# End of macro FORTH_DSP_VALUEHL
39fd			 
39fd e5					push hl 
39fe			 
39fe					; destroy value TOS 
39fe			 
39fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39fe cd 86 1d			call macro_forth_dsp_pop 
3a01				endm 
# End of macro FORTH_DSP_POP
3a01			 
3a01			 
3a01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a01 cd ce 1c			call macro_dsp_valuehl 
3a04				endm 
# End of macro FORTH_DSP_VALUEHL
3a04			 
3a04					; one value on hl get other one back 
3a04			 
3a04 d1					pop de 
3a05			 
3a05					; do the sub 
3a05			;		ex de, hl 
3a05			 
3a05 ed 52				sbc hl,de 
3a07			 
3a07					; save it 
3a07			 
3a07			;		push hl	 
3a07			 
3a07					; 
3a07			 
3a07					; destroy value TOS 
3a07			 
3a07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a07 cd 86 1d			call macro_forth_dsp_pop 
3a0a				endm 
# End of macro FORTH_DSP_POP
3a0a			 
3a0a					; TODO push value back onto stack for another op etc 
3a0a			 
3a0a			;		pop hl 
3a0a			 
3a0a cd d2 1a				call forth_push_numhl 
3a0d			.neg_done: 
3a0d			 
3a0d					NEXTW 
3a0d cd 6c ee			call parse_vector 
3a10 c3 b5 1e			jp macro_next 
3a13				endm 
# End of macro NEXTW
3a13			.DIV: 
3a13				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a13 18				db WORD_SYS_CORE+4             
3a14 66 3a			dw .MUL            
3a16 02				db 1 + 1 
3a17 .. 00			db "/",0              
3a19				endm 
# End of macro CWHEAD
3a19			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a19					if DEBUG_FORTH_WORDS_KEY 
3a19						DMARK "DIV" 
3a19 f5				push af  
3a1a 3a 2e 3a			ld a, (.dmark)  
3a1d 32 62 ee			ld (debug_mark),a  
3a20 3a 2f 3a			ld a, (.dmark+1)  
3a23 32 63 ee			ld (debug_mark+1),a  
3a26 3a 30 3a			ld a, (.dmark+2)  
3a29 32 64 ee			ld (debug_mark+2),a  
3a2c 18 03			jr .pastdmark  
3a2e ..			.dmark: db "DIV"  
3a31 f1			.pastdmark: pop af  
3a32			endm  
# End of macro DMARK
3a32						CALLMONITOR 
3a32 cd 6f ee			call debug_vector  
3a35				endm  
# End of macro CALLMONITOR
3a35					endif 
3a35				; TODO add floating point number detection 
3a35					; v5 FORTH_DSP_VALUE 
3a35					FORTH_DSP 
3a35 cd 94 1c			call macro_forth_dsp 
3a38				endm 
# End of macro FORTH_DSP
3a38 7e					ld a,(hl)	; get type of value on TOS 
3a39 fe 02				cp DS_TYPE_INUM  
3a3b 28 06				jr z, .div_inum 
3a3d			 
3a3d				if FORTH_ENABLE_FLOATMATH 
3a3d					jr .div_done 
3a3d			 
3a3d				endif 
3a3d					NEXTW 
3a3d cd 6c ee			call parse_vector 
3a40 c3 b5 1e			jp macro_next 
3a43				endm 
# End of macro NEXTW
3a43			.div_inum: 
3a43			 
3a43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a43 cd ce 1c			call macro_dsp_valuehl 
3a46				endm 
# End of macro FORTH_DSP_VALUEHL
3a46			 
3a46 e5					push hl    ; to go to bc 
3a47			 
3a47					; destroy value TOS 
3a47			 
3a47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a47 cd 86 1d			call macro_forth_dsp_pop 
3a4a				endm 
# End of macro FORTH_DSP_POP
3a4a			 
3a4a			 
3a4a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4a cd ce 1c			call macro_dsp_valuehl 
3a4d				endm 
# End of macro FORTH_DSP_VALUEHL
3a4d			 
3a4d					; hl to go to de 
3a4d			 
3a4d e5					push hl 
3a4e			 
3a4e c1					pop bc 
3a4f d1					pop de		 
3a50			 
3a50			 
3a50					if DEBUG_FORTH_MATHS 
3a50						DMARK "DIV" 
3a50				CALLMONITOR 
3a50					endif 
3a50					; one value on hl but move to a get other one back 
3a50			 
3a50			        
3a50 cd 3e 0d			call Div16 
3a53			 
3a53			;	push af	 
3a53 e5				push hl 
3a54 c5				push bc 
3a55			 
3a55					if DEBUG_FORTH_MATHS 
3a55						DMARK "DI1" 
3a55				CALLMONITOR 
3a55					endif 
3a55			 
3a55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a55 cd 86 1d			call macro_forth_dsp_pop 
3a58				endm 
# End of macro FORTH_DSP_POP
3a58			 
3a58			 
3a58			 
3a58 e1					pop hl    ; result 
3a59			 
3a59 cd d2 1a				call forth_push_numhl 
3a5c			 
3a5c e1					pop hl    ; reminder 
3a5d			;		ld h,0 
3a5d			;		ld l,d 
3a5d			 
3a5d cd d2 1a				call forth_push_numhl 
3a60			.div_done: 
3a60					NEXTW 
3a60 cd 6c ee			call parse_vector 
3a63 c3 b5 1e			jp macro_next 
3a66				endm 
# End of macro NEXTW
3a66			.MUL: 
3a66				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a66 19				db WORD_SYS_CORE+5             
3a67 b1 3a			dw .MIN            
3a69 02				db 1 + 1 
3a6a .. 00			db "*",0              
3a6c				endm 
# End of macro CWHEAD
3a6c			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a6c				; TODO add floating point number detection 
3a6c					if DEBUG_FORTH_WORDS_KEY 
3a6c						DMARK "MUL" 
3a6c f5				push af  
3a6d 3a 81 3a			ld a, (.dmark)  
3a70 32 62 ee			ld (debug_mark),a  
3a73 3a 82 3a			ld a, (.dmark+1)  
3a76 32 63 ee			ld (debug_mark+1),a  
3a79 3a 83 3a			ld a, (.dmark+2)  
3a7c 32 64 ee			ld (debug_mark+2),a  
3a7f 18 03			jr .pastdmark  
3a81 ..			.dmark: db "MUL"  
3a84 f1			.pastdmark: pop af  
3a85			endm  
# End of macro DMARK
3a85						CALLMONITOR 
3a85 cd 6f ee			call debug_vector  
3a88				endm  
# End of macro CALLMONITOR
3a88					endif 
3a88					FORTH_DSP 
3a88 cd 94 1c			call macro_forth_dsp 
3a8b				endm 
# End of macro FORTH_DSP
3a8b					; v5 FORTH_DSP_VALUE 
3a8b 7e					ld a,(hl)	; get type of value on TOS 
3a8c fe 02				cp DS_TYPE_INUM  
3a8e 28 06				jr z, .mul_inum 
3a90			 
3a90				if FORTH_ENABLE_FLOATMATH 
3a90					jr .mul_done 
3a90			 
3a90				endif 
3a90			 
3a90					NEXTW 
3a90 cd 6c ee			call parse_vector 
3a93 c3 b5 1e			jp macro_next 
3a96				endm 
# End of macro NEXTW
3a96			.mul_inum:	 
3a96			 
3a96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a96 cd ce 1c			call macro_dsp_valuehl 
3a99				endm 
# End of macro FORTH_DSP_VALUEHL
3a99			 
3a99 e5					push hl 
3a9a			 
3a9a					; destroy value TOS 
3a9a			 
3a9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9a cd 86 1d			call macro_forth_dsp_pop 
3a9d				endm 
# End of macro FORTH_DSP_POP
3a9d			 
3a9d			 
3a9d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9d cd ce 1c			call macro_dsp_valuehl 
3aa0				endm 
# End of macro FORTH_DSP_VALUEHL
3aa0			 
3aa0					; one value on hl but move to a get other one back 
3aa0			 
3aa0 7d					ld a, l 
3aa1			 
3aa1 d1					pop de 
3aa2			 
3aa2					; do the mull 
3aa2			;		ex de, hl 
3aa2			 
3aa2 cd 64 0d				call Mult16 
3aa5					; save it 
3aa5			 
3aa5			;		push hl	 
3aa5			 
3aa5					; 
3aa5			 
3aa5					; destroy value TOS 
3aa5			 
3aa5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa5 cd 86 1d			call macro_forth_dsp_pop 
3aa8				endm 
# End of macro FORTH_DSP_POP
3aa8			 
3aa8					; TODO push value back onto stack for another op etc 
3aa8			 
3aa8			;		pop hl 
3aa8			 
3aa8 cd d2 1a				call forth_push_numhl 
3aab			 
3aab			.mul_done: 
3aab					NEXTW 
3aab cd 6c ee			call parse_vector 
3aae c3 b5 1e			jp macro_next 
3ab1				endm 
# End of macro NEXTW
3ab1			 
3ab1			 
3ab1			 
3ab1			 
3ab1			.MIN: 
3ab1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ab1 49				db WORD_SYS_CORE+53             
3ab2 38 3b			dw .MAX            
3ab4 04				db 3 + 1 
3ab5 .. 00			db "MIN",0              
3ab9				endm 
# End of macro CWHEAD
3ab9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3ab9					if DEBUG_FORTH_WORDS_KEY 
3ab9						DMARK "MIN" 
3ab9 f5				push af  
3aba 3a ce 3a			ld a, (.dmark)  
3abd 32 62 ee			ld (debug_mark),a  
3ac0 3a cf 3a			ld a, (.dmark+1)  
3ac3 32 63 ee			ld (debug_mark+1),a  
3ac6 3a d0 3a			ld a, (.dmark+2)  
3ac9 32 64 ee			ld (debug_mark+2),a  
3acc 18 03			jr .pastdmark  
3ace ..			.dmark: db "MIN"  
3ad1 f1			.pastdmark: pop af  
3ad2			endm  
# End of macro DMARK
3ad2						CALLMONITOR 
3ad2 cd 6f ee			call debug_vector  
3ad5				endm  
# End of macro CALLMONITOR
3ad5					endif 
3ad5					; get u2 
3ad5			 
3ad5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad5 cd ce 1c			call macro_dsp_valuehl 
3ad8				endm 
# End of macro FORTH_DSP_VALUEHL
3ad8			 
3ad8 e5					push hl   ; u2 
3ad9			 
3ad9					; destroy value TOS 
3ad9			 
3ad9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad9 cd 86 1d			call macro_forth_dsp_pop 
3adc				endm 
# End of macro FORTH_DSP_POP
3adc			 
3adc					; get u1 
3adc			 
3adc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3adc cd ce 1c			call macro_dsp_valuehl 
3adf				endm 
# End of macro FORTH_DSP_VALUEHL
3adf			 
3adf e5					push hl  ; u1 
3ae0			 
3ae0					; destroy value TOS 
3ae0			 
3ae0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ae0 cd 86 1d			call macro_forth_dsp_pop 
3ae3				endm 
# End of macro FORTH_DSP_POP
3ae3			 
3ae3 b7			 or a      ;clear carry flag 
3ae4 e1			  pop hl    ; u1 
3ae5 d1			  pop de    ; u2 
3ae6 e5				push hl   ; saved in case hl is lowest 
3ae7 ed 52		  sbc hl,de 
3ae9 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3aeb			 
3aeb e1				pop hl 
3aec					if DEBUG_FORTH_WORDS 
3aec						DMARK "MIN" 
3aec f5				push af  
3aed 3a 01 3b			ld a, (.dmark)  
3af0 32 62 ee			ld (debug_mark),a  
3af3 3a 02 3b			ld a, (.dmark+1)  
3af6 32 63 ee			ld (debug_mark+1),a  
3af9 3a 03 3b			ld a, (.dmark+2)  
3afc 32 64 ee			ld (debug_mark+2),a  
3aff 18 03			jr .pastdmark  
3b01 ..			.dmark: db "MIN"  
3b04 f1			.pastdmark: pop af  
3b05			endm  
# End of macro DMARK
3b05						CALLMONITOR 
3b05 cd 6f ee			call debug_vector  
3b08				endm  
# End of macro CALLMONITOR
3b08					endif 
3b08 cd d2 1a				call forth_push_numhl 
3b0b			 
3b0b				       NEXTW 
3b0b cd 6c ee			call parse_vector 
3b0e c3 b5 1e			jp macro_next 
3b11				endm 
# End of macro NEXTW
3b11			 
3b11			.mincont:  
3b11 c1				pop bc   ; tidy up 
3b12 eb				ex de , hl  
3b13					if DEBUG_FORTH_WORDS 
3b13						DMARK "MI1" 
3b13 f5				push af  
3b14 3a 28 3b			ld a, (.dmark)  
3b17 32 62 ee			ld (debug_mark),a  
3b1a 3a 29 3b			ld a, (.dmark+1)  
3b1d 32 63 ee			ld (debug_mark+1),a  
3b20 3a 2a 3b			ld a, (.dmark+2)  
3b23 32 64 ee			ld (debug_mark+2),a  
3b26 18 03			jr .pastdmark  
3b28 ..			.dmark: db "MI1"  
3b2b f1			.pastdmark: pop af  
3b2c			endm  
# End of macro DMARK
3b2c						CALLMONITOR 
3b2c cd 6f ee			call debug_vector  
3b2f				endm  
# End of macro CALLMONITOR
3b2f					endif 
3b2f cd d2 1a				call forth_push_numhl 
3b32			 
3b32				       NEXTW 
3b32 cd 6c ee			call parse_vector 
3b35 c3 b5 1e			jp macro_next 
3b38				endm 
# End of macro NEXTW
3b38			.MAX: 
3b38				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b38 4a				db WORD_SYS_CORE+54             
3b39 bf 3b			dw .RND16            
3b3b 04				db 3 + 1 
3b3c .. 00			db "MAX",0              
3b40				endm 
# End of macro CWHEAD
3b40			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b40					if DEBUG_FORTH_WORDS_KEY 
3b40						DMARK "MAX" 
3b40 f5				push af  
3b41 3a 55 3b			ld a, (.dmark)  
3b44 32 62 ee			ld (debug_mark),a  
3b47 3a 56 3b			ld a, (.dmark+1)  
3b4a 32 63 ee			ld (debug_mark+1),a  
3b4d 3a 57 3b			ld a, (.dmark+2)  
3b50 32 64 ee			ld (debug_mark+2),a  
3b53 18 03			jr .pastdmark  
3b55 ..			.dmark: db "MAX"  
3b58 f1			.pastdmark: pop af  
3b59			endm  
# End of macro DMARK
3b59						CALLMONITOR 
3b59 cd 6f ee			call debug_vector  
3b5c				endm  
# End of macro CALLMONITOR
3b5c					endif 
3b5c					; get u2 
3b5c			 
3b5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b5c cd ce 1c			call macro_dsp_valuehl 
3b5f				endm 
# End of macro FORTH_DSP_VALUEHL
3b5f			 
3b5f e5					push hl   ; u2 
3b60			 
3b60					; destroy value TOS 
3b60			 
3b60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b60 cd 86 1d			call macro_forth_dsp_pop 
3b63				endm 
# End of macro FORTH_DSP_POP
3b63			 
3b63					; get u1 
3b63			 
3b63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b63 cd ce 1c			call macro_dsp_valuehl 
3b66				endm 
# End of macro FORTH_DSP_VALUEHL
3b66			 
3b66 e5					push hl  ; u1 
3b67			 
3b67					; destroy value TOS 
3b67			 
3b67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b67 cd 86 1d			call macro_forth_dsp_pop 
3b6a				endm 
# End of macro FORTH_DSP_POP
3b6a			 
3b6a b7			 or a      ;clear carry flag 
3b6b e1			  pop hl    ; u1 
3b6c d1			  pop de    ; u2 
3b6d e5				push hl   ; saved in case hl is lowest 
3b6e ed 52		  sbc hl,de 
3b70 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b72			 
3b72 e1				pop hl 
3b73					if DEBUG_FORTH_WORDS 
3b73						DMARK "MAX" 
3b73 f5				push af  
3b74 3a 88 3b			ld a, (.dmark)  
3b77 32 62 ee			ld (debug_mark),a  
3b7a 3a 89 3b			ld a, (.dmark+1)  
3b7d 32 63 ee			ld (debug_mark+1),a  
3b80 3a 8a 3b			ld a, (.dmark+2)  
3b83 32 64 ee			ld (debug_mark+2),a  
3b86 18 03			jr .pastdmark  
3b88 ..			.dmark: db "MAX"  
3b8b f1			.pastdmark: pop af  
3b8c			endm  
# End of macro DMARK
3b8c						CALLMONITOR 
3b8c cd 6f ee			call debug_vector  
3b8f				endm  
# End of macro CALLMONITOR
3b8f					endif 
3b8f cd d2 1a				call forth_push_numhl 
3b92			 
3b92				       NEXTW 
3b92 cd 6c ee			call parse_vector 
3b95 c3 b5 1e			jp macro_next 
3b98				endm 
# End of macro NEXTW
3b98			 
3b98			.maxcont:  
3b98 c1				pop bc   ; tidy up 
3b99 eb				ex de , hl  
3b9a					if DEBUG_FORTH_WORDS 
3b9a						DMARK "MA1" 
3b9a f5				push af  
3b9b 3a af 3b			ld a, (.dmark)  
3b9e 32 62 ee			ld (debug_mark),a  
3ba1 3a b0 3b			ld a, (.dmark+1)  
3ba4 32 63 ee			ld (debug_mark+1),a  
3ba7 3a b1 3b			ld a, (.dmark+2)  
3baa 32 64 ee			ld (debug_mark+2),a  
3bad 18 03			jr .pastdmark  
3baf ..			.dmark: db "MA1"  
3bb2 f1			.pastdmark: pop af  
3bb3			endm  
# End of macro DMARK
3bb3						CALLMONITOR 
3bb3 cd 6f ee			call debug_vector  
3bb6				endm  
# End of macro CALLMONITOR
3bb6					endif 
3bb6 cd d2 1a				call forth_push_numhl 
3bb9				       NEXTW 
3bb9 cd 6c ee			call parse_vector 
3bbc c3 b5 1e			jp macro_next 
3bbf				endm 
# End of macro NEXTW
3bbf			 
3bbf			.RND16: 
3bbf				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3bbf 4e				db WORD_SYS_CORE+58             
3bc0 f1 3b			dw .RND8            
3bc2 06				db 5 + 1 
3bc3 .. 00			db "RND16",0              
3bc9				endm 
# End of macro CWHEAD
3bc9			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3bc9					if DEBUG_FORTH_WORDS_KEY 
3bc9						DMARK "R16" 
3bc9 f5				push af  
3bca 3a de 3b			ld a, (.dmark)  
3bcd 32 62 ee			ld (debug_mark),a  
3bd0 3a df 3b			ld a, (.dmark+1)  
3bd3 32 63 ee			ld (debug_mark+1),a  
3bd6 3a e0 3b			ld a, (.dmark+2)  
3bd9 32 64 ee			ld (debug_mark+2),a  
3bdc 18 03			jr .pastdmark  
3bde ..			.dmark: db "R16"  
3be1 f1			.pastdmark: pop af  
3be2			endm  
# End of macro DMARK
3be2						CALLMONITOR 
3be2 cd 6f ee			call debug_vector  
3be5				endm  
# End of macro CALLMONITOR
3be5					endif 
3be5 cd 08 0d				call prng16  
3be8 cd d2 1a				call forth_push_numhl 
3beb				       NEXTW 
3beb cd 6c ee			call parse_vector 
3bee c3 b5 1e			jp macro_next 
3bf1				endm 
# End of macro NEXTW
3bf1			.RND8: 
3bf1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3bf1 60				db WORD_SYS_CORE+76             
3bf2 29 3c			dw .RND            
3bf4 05				db 4 + 1 
3bf5 .. 00			db "RND8",0              
3bfa				endm 
# End of macro CWHEAD
3bfa			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bfa					if DEBUG_FORTH_WORDS_KEY 
3bfa						DMARK "RN8" 
3bfa f5				push af  
3bfb 3a 0f 3c			ld a, (.dmark)  
3bfe 32 62 ee			ld (debug_mark),a  
3c01 3a 10 3c			ld a, (.dmark+1)  
3c04 32 63 ee			ld (debug_mark+1),a  
3c07 3a 11 3c			ld a, (.dmark+2)  
3c0a 32 64 ee			ld (debug_mark+2),a  
3c0d 18 03			jr .pastdmark  
3c0f ..			.dmark: db "RN8"  
3c12 f1			.pastdmark: pop af  
3c13			endm  
# End of macro DMARK
3c13						CALLMONITOR 
3c13 cd 6f ee			call debug_vector  
3c16				endm  
# End of macro CALLMONITOR
3c16					endif 
3c16 2a a0 eb				ld hl,(xrandc) 
3c19 23					inc hl 
3c1a cd 22 0d				call xrnd 
3c1d 6f					ld l,a	 
3c1e 26 00				ld h,0 
3c20 cd d2 1a				call forth_push_numhl 
3c23				       NEXTW 
3c23 cd 6c ee			call parse_vector 
3c26 c3 b5 1e			jp macro_next 
3c29				endm 
# End of macro NEXTW
3c29			.RND: 
3c29				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3c29 60				db WORD_SYS_CORE+76             
3c2a 32 3d			dw .ENDMATHS            
3c2c 04				db 3 + 1 
3c2d .. 00			db "RND",0              
3c31				endm 
# End of macro CWHEAD
3c31			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c31			 
3c31					if DEBUG_FORTH_WORDS_KEY 
3c31						DMARK "RND" 
3c31 f5				push af  
3c32 3a 46 3c			ld a, (.dmark)  
3c35 32 62 ee			ld (debug_mark),a  
3c38 3a 47 3c			ld a, (.dmark+1)  
3c3b 32 63 ee			ld (debug_mark+1),a  
3c3e 3a 48 3c			ld a, (.dmark+2)  
3c41 32 64 ee			ld (debug_mark+2),a  
3c44 18 03			jr .pastdmark  
3c46 ..			.dmark: db "RND"  
3c49 f1			.pastdmark: pop af  
3c4a			endm  
# End of macro DMARK
3c4a						CALLMONITOR 
3c4a cd 6f ee			call debug_vector  
3c4d				endm  
# End of macro CALLMONITOR
3c4d					endif 
3c4d					 
3c4d					FORTH_DSP_VALUEHL    ; upper range 
3c4d cd ce 1c			call macro_dsp_valuehl 
3c50				endm 
# End of macro FORTH_DSP_VALUEHL
3c50			 
3c50 22 a4 eb				ld (LFSRSeed), hl	 
3c53			 
3c53					if DEBUG_FORTH_WORDS 
3c53						DMARK "RN1" 
3c53 f5				push af  
3c54 3a 68 3c			ld a, (.dmark)  
3c57 32 62 ee			ld (debug_mark),a  
3c5a 3a 69 3c			ld a, (.dmark+1)  
3c5d 32 63 ee			ld (debug_mark+1),a  
3c60 3a 6a 3c			ld a, (.dmark+2)  
3c63 32 64 ee			ld (debug_mark+2),a  
3c66 18 03			jr .pastdmark  
3c68 ..			.dmark: db "RN1"  
3c6b f1			.pastdmark: pop af  
3c6c			endm  
# End of macro DMARK
3c6c						CALLMONITOR 
3c6c cd 6f ee			call debug_vector  
3c6f				endm  
# End of macro CALLMONITOR
3c6f					endif 
3c6f					FORTH_DSP_POP 
3c6f cd 86 1d			call macro_forth_dsp_pop 
3c72				endm 
# End of macro FORTH_DSP_POP
3c72			 
3c72					FORTH_DSP_VALUEHL    ; low range 
3c72 cd ce 1c			call macro_dsp_valuehl 
3c75				endm 
# End of macro FORTH_DSP_VALUEHL
3c75			 
3c75					if DEBUG_FORTH_WORDS 
3c75						DMARK "RN2" 
3c75 f5				push af  
3c76 3a 8a 3c			ld a, (.dmark)  
3c79 32 62 ee			ld (debug_mark),a  
3c7c 3a 8b 3c			ld a, (.dmark+1)  
3c7f 32 63 ee			ld (debug_mark+1),a  
3c82 3a 8c 3c			ld a, (.dmark+2)  
3c85 32 64 ee			ld (debug_mark+2),a  
3c88 18 03			jr .pastdmark  
3c8a ..			.dmark: db "RN2"  
3c8d f1			.pastdmark: pop af  
3c8e			endm  
# End of macro DMARK
3c8e						CALLMONITOR 
3c8e cd 6f ee			call debug_vector  
3c91				endm  
# End of macro CALLMONITOR
3c91					endif 
3c91 22 a6 eb				ld (LFSRSeed+2), hl 
3c94			 
3c94					FORTH_DSP_POP 
3c94 cd 86 1d			call macro_forth_dsp_pop 
3c97				endm 
# End of macro FORTH_DSP_POP
3c97			 
3c97 e5					push hl 
3c98			 
3c98 e1			.inrange:	pop hl 
3c99 cd 08 0d				call prng16  
3c9c					if DEBUG_FORTH_WORDS 
3c9c						DMARK "RN3" 
3c9c f5				push af  
3c9d 3a b1 3c			ld a, (.dmark)  
3ca0 32 62 ee			ld (debug_mark),a  
3ca3 3a b2 3c			ld a, (.dmark+1)  
3ca6 32 63 ee			ld (debug_mark+1),a  
3ca9 3a b3 3c			ld a, (.dmark+2)  
3cac 32 64 ee			ld (debug_mark+2),a  
3caf 18 03			jr .pastdmark  
3cb1 ..			.dmark: db "RN3"  
3cb4 f1			.pastdmark: pop af  
3cb5			endm  
# End of macro DMARK
3cb5						CALLMONITOR 
3cb5 cd 6f ee			call debug_vector  
3cb8				endm  
# End of macro CALLMONITOR
3cb8					endif 
3cb8					 
3cb8					; if the range is 8bit knock out the high byte 
3cb8			 
3cb8 ed 5b a4 eb			ld de, (LFSRSeed)     ; check high level 
3cbc			 
3cbc 3e 00				ld a, 0 
3cbe ba					cp d  
3cbf 20 1e				jr nz, .hirange 
3cc1 26 00				ld h, 0   ; knock it down to 8bit 
3cc3			 
3cc3					if DEBUG_FORTH_WORDS 
3cc3						DMARK "RNk" 
3cc3 f5				push af  
3cc4 3a d8 3c			ld a, (.dmark)  
3cc7 32 62 ee			ld (debug_mark),a  
3cca 3a d9 3c			ld a, (.dmark+1)  
3ccd 32 63 ee			ld (debug_mark+1),a  
3cd0 3a da 3c			ld a, (.dmark+2)  
3cd3 32 64 ee			ld (debug_mark+2),a  
3cd6 18 03			jr .pastdmark  
3cd8 ..			.dmark: db "RNk"  
3cdb f1			.pastdmark: pop af  
3cdc			endm  
# End of macro DMARK
3cdc						CALLMONITOR 
3cdc cd 6f ee			call debug_vector  
3cdf				endm  
# End of macro CALLMONITOR
3cdf					endif 
3cdf			.hirange:   
3cdf e5					push hl  
3ce0 b7					or a  
3ce1 ed 52		                sbc hl, de 
3ce3			 
3ce3					;call cmp16 
3ce3			 
3ce3 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ce5 e1					pop hl 
3ce6 e5					push hl 
3ce7			 
3ce7					if DEBUG_FORTH_WORDS 
3ce7						DMARK "RN4" 
3ce7 f5				push af  
3ce8 3a fc 3c			ld a, (.dmark)  
3ceb 32 62 ee			ld (debug_mark),a  
3cee 3a fd 3c			ld a, (.dmark+1)  
3cf1 32 63 ee			ld (debug_mark+1),a  
3cf4 3a fe 3c			ld a, (.dmark+2)  
3cf7 32 64 ee			ld (debug_mark+2),a  
3cfa 18 03			jr .pastdmark  
3cfc ..			.dmark: db "RN4"  
3cff f1			.pastdmark: pop af  
3d00			endm  
# End of macro DMARK
3d00						CALLMONITOR 
3d00 cd 6f ee			call debug_vector  
3d03				endm  
# End of macro CALLMONITOR
3d03					endif 
3d03 ed 5b a6 eb			ld de, (LFSRSeed+2)   ; check low range 
3d07					;call cmp16 
3d07				 
3d07 b7					or a  
3d08 ed 52		                sbc hl, de 
3d0a 38 8c				jr c, .inrange 
3d0c			 
3d0c e1					pop hl 
3d0d					 
3d0d					if DEBUG_FORTH_WORDS 
3d0d						DMARK "RNd" 
3d0d f5				push af  
3d0e 3a 22 3d			ld a, (.dmark)  
3d11 32 62 ee			ld (debug_mark),a  
3d14 3a 23 3d			ld a, (.dmark+1)  
3d17 32 63 ee			ld (debug_mark+1),a  
3d1a 3a 24 3d			ld a, (.dmark+2)  
3d1d 32 64 ee			ld (debug_mark+2),a  
3d20 18 03			jr .pastdmark  
3d22 ..			.dmark: db "RNd"  
3d25 f1			.pastdmark: pop af  
3d26			endm  
# End of macro DMARK
3d26						CALLMONITOR 
3d26 cd 6f ee			call debug_vector  
3d29				endm  
# End of macro CALLMONITOR
3d29					endif 
3d29			 
3d29			 
3d29 cd d2 1a				call forth_push_numhl 
3d2c				       NEXTW 
3d2c cd 6c ee			call parse_vector 
3d2f c3 b5 1e			jp macro_next 
3d32				endm 
# End of macro NEXTW
3d32			 
3d32			.ENDMATHS: 
3d32			 
3d32			; eof 
3d32			 
# End of file forth_words_maths.asm
3d32			include "forth_words_display.asm" 
3d32			 
3d32			; | ## Display Words 
3d32			 
3d32			.ACT: 
3d32			 
3d32				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3d32 62				db WORD_SYS_CORE+78             
3d33 81 3d			dw .INFO            
3d35 07				db 6 + 1 
3d36 .. 00			db "ACTIVE",0              
3d3d				endm 
# End of macro CWHEAD
3d3d			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3d3d			;  
3d3d			; | | To display a pulsing activity indicator in a processing loop do this... 
3d3d			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3d3d			 
3d3d					if DEBUG_FORTH_WORDS_KEY 
3d3d						DMARK "ACT" 
3d3d f5				push af  
3d3e 3a 52 3d			ld a, (.dmark)  
3d41 32 62 ee			ld (debug_mark),a  
3d44 3a 53 3d			ld a, (.dmark+1)  
3d47 32 63 ee			ld (debug_mark+1),a  
3d4a 3a 54 3d			ld a, (.dmark+2)  
3d4d 32 64 ee			ld (debug_mark+2),a  
3d50 18 03			jr .pastdmark  
3d52 ..			.dmark: db "ACT"  
3d55 f1			.pastdmark: pop af  
3d56			endm  
# End of macro DMARK
3d56						CALLMONITOR 
3d56 cd 6f ee			call debug_vector  
3d59				endm  
# End of macro CALLMONITOR
3d59					endif 
3d59 cd 0f 0b				call active 
3d5c					if DEBUG_FORTH_WORDS 
3d5c						DMARK "ACp" 
3d5c f5				push af  
3d5d 3a 71 3d			ld a, (.dmark)  
3d60 32 62 ee			ld (debug_mark),a  
3d63 3a 72 3d			ld a, (.dmark+1)  
3d66 32 63 ee			ld (debug_mark+1),a  
3d69 3a 73 3d			ld a, (.dmark+2)  
3d6c 32 64 ee			ld (debug_mark+2),a  
3d6f 18 03			jr .pastdmark  
3d71 ..			.dmark: db "ACp"  
3d74 f1			.pastdmark: pop af  
3d75			endm  
# End of macro DMARK
3d75						CALLMONITOR 
3d75 cd 6f ee			call debug_vector  
3d78				endm  
# End of macro CALLMONITOR
3d78					endif 
3d78 cd 3c 1b				call forth_push_str 
3d7b			 
3d7b					NEXTW 
3d7b cd 6c ee			call parse_vector 
3d7e c3 b5 1e			jp macro_next 
3d81				endm 
# End of macro NEXTW
3d81			.INFO: 
3d81			 
3d81				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d81 62				db WORD_SYS_CORE+78             
3d82 a1 3d			dw .ATP            
3d84 05				db 4 + 1 
3d85 .. 00			db "INFO",0              
3d8a				endm 
# End of macro CWHEAD
3d8a			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d8a					FORTH_DSP_VALUEHL 
3d8a cd ce 1c			call macro_dsp_valuehl 
3d8d				endm 
# End of macro FORTH_DSP_VALUEHL
3d8d			 
3d8d					FORTH_DSP_POP 
3d8d cd 86 1d			call macro_forth_dsp_pop 
3d90				endm 
# End of macro FORTH_DSP_POP
3d90			 
3d90 e5					push hl 
3d91			 
3d91					FORTH_DSP_VALUEHL 
3d91 cd ce 1c			call macro_dsp_valuehl 
3d94				endm 
# End of macro FORTH_DSP_VALUEHL
3d94			 
3d94					FORTH_DSP_POP 
3d94 cd 86 1d			call macro_forth_dsp_pop 
3d97				endm 
# End of macro FORTH_DSP_POP
3d97			 
3d97 d1					pop de 
3d98			 
3d98 cd 49 0b				call info_panel 
3d9b			 
3d9b			 
3d9b					NEXTW 
3d9b cd 6c ee			call parse_vector 
3d9e c3 b5 1e			jp macro_next 
3da1				endm 
# End of macro NEXTW
3da1			.ATP: 
3da1				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3da1 62				db WORD_SYS_CORE+78             
3da2 1b 3e			dw .FB            
3da4 04				db 3 + 1 
3da5 .. 00			db "AT?",0              
3da9				endm 
# End of macro CWHEAD
3da9			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3da9					if DEBUG_FORTH_WORDS_KEY 
3da9						DMARK "AT?" 
3da9 f5				push af  
3daa 3a be 3d			ld a, (.dmark)  
3dad 32 62 ee			ld (debug_mark),a  
3db0 3a bf 3d			ld a, (.dmark+1)  
3db3 32 63 ee			ld (debug_mark+1),a  
3db6 3a c0 3d			ld a, (.dmark+2)  
3db9 32 64 ee			ld (debug_mark+2),a  
3dbc 18 03			jr .pastdmark  
3dbe ..			.dmark: db "AT?"  
3dc1 f1			.pastdmark: pop af  
3dc2			endm  
# End of macro DMARK
3dc2						CALLMONITOR 
3dc2 cd 6f ee			call debug_vector  
3dc5				endm  
# End of macro CALLMONITOR
3dc5					endif 
3dc5 3a 55 ea				ld a, (f_cursor_ptr) 
3dc8			 
3dc8			if DEBUG_FORTH_WORDS 
3dc8				DMARK "AT?" 
3dc8 f5				push af  
3dc9 3a dd 3d			ld a, (.dmark)  
3dcc 32 62 ee			ld (debug_mark),a  
3dcf 3a de 3d			ld a, (.dmark+1)  
3dd2 32 63 ee			ld (debug_mark+1),a  
3dd5 3a df 3d			ld a, (.dmark+2)  
3dd8 32 64 ee			ld (debug_mark+2),a  
3ddb 18 03			jr .pastdmark  
3ddd ..			.dmark: db "AT?"  
3de0 f1			.pastdmark: pop af  
3de1			endm  
# End of macro DMARK
3de1				CALLMONITOR 
3de1 cd 6f ee			call debug_vector  
3de4				endm  
# End of macro CALLMONITOR
3de4			endif	 
3de4					; count the number of rows 
3de4			 
3de4 06 00				ld b, 0 
3de6 4f			.atpr:		ld c, a    ; save in case we go below zero 
3de7 d6 28				sub display_cols 
3de9 f2 ef 3d				jp p, .atprunder 
3dec 04					inc b 
3ded 18 f7				jr .atpr 
3def			.atprunder:	 
3def			if DEBUG_FORTH_WORDS 
3def				DMARK "A?2" 
3def f5				push af  
3df0 3a 04 3e			ld a, (.dmark)  
3df3 32 62 ee			ld (debug_mark),a  
3df6 3a 05 3e			ld a, (.dmark+1)  
3df9 32 63 ee			ld (debug_mark+1),a  
3dfc 3a 06 3e			ld a, (.dmark+2)  
3dff 32 64 ee			ld (debug_mark+2),a  
3e02 18 03			jr .pastdmark  
3e04 ..			.dmark: db "A?2"  
3e07 f1			.pastdmark: pop af  
3e08			endm  
# End of macro DMARK
3e08				CALLMONITOR 
3e08 cd 6f ee			call debug_vector  
3e0b				endm  
# End of macro CALLMONITOR
3e0b			endif	 
3e0b 26 00				ld h, 0 
3e0d 69					ld l, c 
3e0e cd d2 1a				call forth_push_numhl 
3e11 68					ld l, b  
3e12 cd d2 1a				call forth_push_numhl 
3e15			 
3e15			 
3e15				NEXTW 
3e15 cd 6c ee			call parse_vector 
3e18 c3 b5 1e			jp macro_next 
3e1b				endm 
# End of macro NEXTW
3e1b			 
3e1b			.FB: 
3e1b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3e1b 1b				db WORD_SYS_CORE+7             
3e1c 6c 3e			dw .EMIT            
3e1e 03				db 2 + 1 
3e1f .. 00			db "FB",0              
3e22				endm 
# End of macro CWHEAD
3e22			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3e22			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3e22			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3e22			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3e22					if DEBUG_FORTH_WORDS_KEY 
3e22						DMARK "FB." 
3e22 f5				push af  
3e23 3a 37 3e			ld a, (.dmark)  
3e26 32 62 ee			ld (debug_mark),a  
3e29 3a 38 3e			ld a, (.dmark+1)  
3e2c 32 63 ee			ld (debug_mark+1),a  
3e2f 3a 39 3e			ld a, (.dmark+2)  
3e32 32 64 ee			ld (debug_mark+2),a  
3e35 18 03			jr .pastdmark  
3e37 ..			.dmark: db "FB."  
3e3a f1			.pastdmark: pop af  
3e3b			endm  
# End of macro DMARK
3e3b						CALLMONITOR 
3e3b cd 6f ee			call debug_vector  
3e3e				endm  
# End of macro CALLMONITOR
3e3e					endif 
3e3e			 
3e3e					FORTH_DSP_VALUEHL 
3e3e cd ce 1c			call macro_dsp_valuehl 
3e41				endm 
# End of macro FORTH_DSP_VALUEHL
3e41			 
3e41 7d					ld a, l 
3e42 fe 01				cp 1 
3e44 20 05				jr nz, .fbn1 
3e46 21 07 ed				ld hl, display_fb1 
3e49 18 15				jr .fbset 
3e4b fe 02		.fbn1:		cp 2 
3e4d 20 05				jr nz, .fbn2 
3e4f 21 c5 eb				ld hl, display_fb2 
3e52 18 0c				jr .fbset 
3e54 fe 03		.fbn2:		cp 3 
3e56 20 05				jr nz, .fbn3 
3e58 21 66 ec				ld hl, display_fb3 
3e5b 18 03				jr .fbset 
3e5d			.fbn3:		 ; if invalid number select first 
3e5d 21 07 ed				ld hl, display_fb1 
3e60 22 c3 eb		.fbset:		ld (display_fb_active), hl 
3e63			 
3e63					FORTH_DSP_POP 
3e63 cd 86 1d			call macro_forth_dsp_pop 
3e66				endm 
# End of macro FORTH_DSP_POP
3e66			 
3e66					NEXTW 
3e66 cd 6c ee			call parse_vector 
3e69 c3 b5 1e			jp macro_next 
3e6c				endm 
# End of macro NEXTW
3e6c			 
3e6c			 
3e6c			.EMIT: 
3e6c				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3e6c 1b				db WORD_SYS_CORE+7             
3e6d bf 3e			dw .DOTH            
3e6f 05				db 4 + 1 
3e70 .. 00			db "EMIT",0              
3e75				endm 
# End of macro CWHEAD
3e75			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3e75					; get value off TOS and display it 
3e75			 
3e75					if DEBUG_FORTH_WORDS_KEY 
3e75						DMARK "EMT" 
3e75 f5				push af  
3e76 3a 8a 3e			ld a, (.dmark)  
3e79 32 62 ee			ld (debug_mark),a  
3e7c 3a 8b 3e			ld a, (.dmark+1)  
3e7f 32 63 ee			ld (debug_mark+1),a  
3e82 3a 8c 3e			ld a, (.dmark+2)  
3e85 32 64 ee			ld (debug_mark+2),a  
3e88 18 03			jr .pastdmark  
3e8a ..			.dmark: db "EMT"  
3e8d f1			.pastdmark: pop af  
3e8e			endm  
# End of macro DMARK
3e8e						CALLMONITOR 
3e8e cd 6f ee			call debug_vector  
3e91				endm  
# End of macro CALLMONITOR
3e91					endif 
3e91			 
3e91					FORTH_DSP_VALUEHL 
3e91 cd ce 1c			call macro_dsp_valuehl 
3e94				endm 
# End of macro FORTH_DSP_VALUEHL
3e94			 
3e94 7d					ld a,l 
3e95			 
3e95					; TODO write to display 
3e95			 
3e95 32 b6 e4				ld (os_input), a 
3e98 3e 00				ld a, 0 
3e9a 32 b7 e4				ld (os_input+1), a 
3e9d					 
3e9d 3a 55 ea				ld a, (f_cursor_ptr) 
3ea0 11 b6 e4				ld de, os_input 
3ea3 cd c9 0b				call str_at_display 
3ea6			 
3ea6			 
3ea6 3a 33 ea				ld a,(cli_autodisplay) 
3ea9			;		cp 0 
3ea9 b7					or a 
3eaa 28 03				jr z, .enoupdate 
3eac cd d9 0b						call update_display 
3eaf					.enoupdate: 
3eaf			 
3eaf 3a 55 ea				ld a, (f_cursor_ptr) 
3eb2 3c					inc a 
3eb3 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
3eb6			 
3eb6			 
3eb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb6 cd 86 1d			call macro_forth_dsp_pop 
3eb9				endm 
# End of macro FORTH_DSP_POP
3eb9			  
3eb9			 
3eb9					NEXTW 
3eb9 cd 6c ee			call parse_vector 
3ebc c3 b5 1e			jp macro_next 
3ebf				endm 
# End of macro NEXTW
3ebf			.DOTH: 
3ebf				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3ebf 1c				db WORD_SYS_CORE+8             
3ec0 f2 3e			dw .DOTF            
3ec2 03				db 2 + 1 
3ec3 .. 00			db ".-",0              
3ec6				endm 
# End of macro CWHEAD
3ec6			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3ec6					; get value off TOS and display it 
3ec6					if DEBUG_FORTH_WORDS_KEY 
3ec6						DMARK "DTD" 
3ec6 f5				push af  
3ec7 3a db 3e			ld a, (.dmark)  
3eca 32 62 ee			ld (debug_mark),a  
3ecd 3a dc 3e			ld a, (.dmark+1)  
3ed0 32 63 ee			ld (debug_mark+1),a  
3ed3 3a dd 3e			ld a, (.dmark+2)  
3ed6 32 64 ee			ld (debug_mark+2),a  
3ed9 18 03			jr .pastdmark  
3edb ..			.dmark: db "DTD"  
3ede f1			.pastdmark: pop af  
3edf			endm  
# End of macro DMARK
3edf						CALLMONITOR 
3edf cd 6f ee			call debug_vector  
3ee2				endm  
# End of macro CALLMONITOR
3ee2					endif 
3ee2 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ee4 3e 00			ld a, 0 
3ee6 32 34 ea			ld (cli_mvdot), a 
3ee9 c3 4c 3f			jp .dotgo 
3eec				NEXTW 
3eec cd 6c ee			call parse_vector 
3eef c3 b5 1e			jp macro_next 
3ef2				endm 
# End of macro NEXTW
3ef2			.DOTF: 
3ef2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3ef2 1c				db WORD_SYS_CORE+8             
3ef3 23 3f			dw .DOT            
3ef5 03				db 2 + 1 
3ef6 .. 00			db ".>",0              
3ef9				endm 
# End of macro CWHEAD
3ef9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3ef9					; get value off TOS and display it 
3ef9			        ; TODO BUG adds extra spaces 
3ef9			        ; TODO BUG handle numerics? 
3ef9					if DEBUG_FORTH_WORDS_KEY 
3ef9						DMARK "DTC" 
3ef9 f5				push af  
3efa 3a 0e 3f			ld a, (.dmark)  
3efd 32 62 ee			ld (debug_mark),a  
3f00 3a 0f 3f			ld a, (.dmark+1)  
3f03 32 63 ee			ld (debug_mark+1),a  
3f06 3a 10 3f			ld a, (.dmark+2)  
3f09 32 64 ee			ld (debug_mark+2),a  
3f0c 18 03			jr .pastdmark  
3f0e ..			.dmark: db "DTC"  
3f11 f1			.pastdmark: pop af  
3f12			endm  
# End of macro DMARK
3f12						CALLMONITOR 
3f12 cd 6f ee			call debug_vector  
3f15				endm  
# End of macro CALLMONITOR
3f15					endif 
3f15 3e 01			ld a, 1 
3f17 32 34 ea			ld (cli_mvdot), a 
3f1a c3 4c 3f			jp .dotgo 
3f1d				NEXTW 
3f1d cd 6c ee			call parse_vector 
3f20 c3 b5 1e			jp macro_next 
3f23				endm 
# End of macro NEXTW
3f23			 
3f23			.DOT: 
3f23				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3f23 1c				db WORD_SYS_CORE+8             
3f24 fe 40			dw .CLS            
3f26 02				db 1 + 1 
3f27 .. 00			db ".",0              
3f29				endm 
# End of macro CWHEAD
3f29			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3f29					; get value off TOS and display it 
3f29			 
3f29					if DEBUG_FORTH_WORDS_KEY 
3f29						DMARK "DOT" 
3f29 f5				push af  
3f2a 3a 3e 3f			ld a, (.dmark)  
3f2d 32 62 ee			ld (debug_mark),a  
3f30 3a 3f 3f			ld a, (.dmark+1)  
3f33 32 63 ee			ld (debug_mark+1),a  
3f36 3a 40 3f			ld a, (.dmark+2)  
3f39 32 64 ee			ld (debug_mark+2),a  
3f3c 18 03			jr .pastdmark  
3f3e ..			.dmark: db "DOT"  
3f41 f1			.pastdmark: pop af  
3f42			endm  
# End of macro DMARK
3f42						CALLMONITOR 
3f42 cd 6f ee			call debug_vector  
3f45				endm  
# End of macro CALLMONITOR
3f45					endif 
3f45 3e 00			ld a, 0 
3f47 32 34 ea			ld (cli_mvdot), a 
3f4a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3f4c				 
3f4c			 
3f4c			.dotgo: 
3f4c			 
3f4c			; move up type to on stack for parserv5 
3f4c					FORTH_DSP 
3f4c cd 94 1c			call macro_forth_dsp 
3f4f				endm 
# End of macro FORTH_DSP
3f4f				;FORTH_DSP_VALUE  
3f4f			 
3f4f			if DEBUG_FORTH_DOT 
3f4f				DMARK "DOT" 
3f4f f5				push af  
3f50 3a 64 3f			ld a, (.dmark)  
3f53 32 62 ee			ld (debug_mark),a  
3f56 3a 65 3f			ld a, (.dmark+1)  
3f59 32 63 ee			ld (debug_mark+1),a  
3f5c 3a 66 3f			ld a, (.dmark+2)  
3f5f 32 64 ee			ld (debug_mark+2),a  
3f62 18 03			jr .pastdmark  
3f64 ..			.dmark: db "DOT"  
3f67 f1			.pastdmark: pop af  
3f68			endm  
# End of macro DMARK
3f68				CALLMONITOR 
3f68 cd 6f ee			call debug_vector  
3f6b				endm  
# End of macro CALLMONITOR
3f6b			endif	 
3f6b			;		.print: 
3f6b			 
3f6b 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3f6c 23				inc hl   ; position to the actual value 
3f6d fe 01			cp DS_TYPE_STR 
3f6f 20 06			jr nz, .dotnum1  
3f71			 
3f71			; display string 
3f71				FORTH_DSP_VALUE  
3f71 cd b7 1c			call macro_forth_dsp_value 
3f74				endm 
# End of macro FORTH_DSP_VALUE
3f74 eb				ex de,hl 
3f75 18 49			jr .dotwrite 
3f77			 
3f77			.dotnum1: 
3f77 fe 02			cp DS_TYPE_INUM 
3f79 20 44			jr nz, .dotflot 
3f7b			 
3f7b			 
3f7b			; display number 
3f7b			 
3f7b			;	push hl 
3f7b			;	call clear_display 
3f7b			;	pop hl 
3f7b			 
3f7b 5e				ld e, (hl) 
3f7c 23				inc hl 
3f7d 56				ld d, (hl) 
3f7e 21 b8 e2			ld hl, scratch 
3f81			if DEBUG_FORTH_DOT 
3f81				DMARK "DT1" 
3f81 f5				push af  
3f82 3a 96 3f			ld a, (.dmark)  
3f85 32 62 ee			ld (debug_mark),a  
3f88 3a 97 3f			ld a, (.dmark+1)  
3f8b 32 63 ee			ld (debug_mark+1),a  
3f8e 3a 98 3f			ld a, (.dmark+2)  
3f91 32 64 ee			ld (debug_mark+2),a  
3f94 18 03			jr .pastdmark  
3f96 ..			.dmark: db "DT1"  
3f99 f1			.pastdmark: pop af  
3f9a			endm  
# End of macro DMARK
3f9a				CALLMONITOR 
3f9a cd 6f ee			call debug_vector  
3f9d				endm  
# End of macro CALLMONITOR
3f9d			endif	 
3f9d			 
3f9d cd e8 10			call uitoa_16 
3fa0 eb				ex de,hl 
3fa1			 
3fa1			if DEBUG_FORTH_DOT 
3fa1				DMARK "DT2" 
3fa1 f5				push af  
3fa2 3a b6 3f			ld a, (.dmark)  
3fa5 32 62 ee			ld (debug_mark),a  
3fa8 3a b7 3f			ld a, (.dmark+1)  
3fab 32 63 ee			ld (debug_mark+1),a  
3fae 3a b8 3f			ld a, (.dmark+2)  
3fb1 32 64 ee			ld (debug_mark+2),a  
3fb4 18 03			jr .pastdmark  
3fb6 ..			.dmark: db "DT2"  
3fb9 f1			.pastdmark: pop af  
3fba			endm  
# End of macro DMARK
3fba				CALLMONITOR 
3fba cd 6f ee			call debug_vector  
3fbd				endm  
# End of macro CALLMONITOR
3fbd			endif	 
3fbd			 
3fbd			;	ld de, os_word_scratch 
3fbd 18 01			jr .dotwrite 
3fbf			 
3fbf 00			.dotflot:   nop 
3fc0			; TODO print floating point number 
3fc0			 
3fc0			.dotwrite:		 
3fc0			 
3fc0					; if c is set then set all '-' to spaces 
3fc0					; need to also take into account .>  
3fc0			 
3fc0 3e 01				ld a, 1 
3fc2 b9					cp c 
3fc3 20 65				jr nz, .nodashswap 
3fc5			 
3fc5					; DE has the string to write, working with HL 
3fc5			 
3fc5 06 ff				ld b, 255 
3fc7 d5					push de 
3fc8 e1					pop hl 
3fc9			 
3fc9			if DEBUG_FORTH_DOT 
3fc9				DMARK "DT-" 
3fc9 f5				push af  
3fca 3a de 3f			ld a, (.dmark)  
3fcd 32 62 ee			ld (debug_mark),a  
3fd0 3a df 3f			ld a, (.dmark+1)  
3fd3 32 63 ee			ld (debug_mark+1),a  
3fd6 3a e0 3f			ld a, (.dmark+2)  
3fd9 32 64 ee			ld (debug_mark+2),a  
3fdc 18 03			jr .pastdmark  
3fde ..			.dmark: db "DT-"  
3fe1 f1			.pastdmark: pop af  
3fe2			endm  
# End of macro DMARK
3fe2				CALLMONITOR 
3fe2 cd 6f ee			call debug_vector  
3fe5				endm  
# End of macro CALLMONITOR
3fe5			endif	 
3fe5 7e			.dashscan:	ld a, (hl) 
3fe6			;		cp 0 
3fe6 b7					or a 
3fe7 28 41				jr z, .nodashswap 
3fe9 fe 2d				cp '-' 
3feb 20 02				jr nz, .dashskip 
3fed			;		ld a, ' ' 
3fed 36 20				ld (hl), ' ' 
3fef 23			.dashskip:	inc hl 
3ff0			if DEBUG_FORTH_DOT 
3ff0				DMARK "D-2" 
3ff0 f5				push af  
3ff1 3a 05 40			ld a, (.dmark)  
3ff4 32 62 ee			ld (debug_mark),a  
3ff7 3a 06 40			ld a, (.dmark+1)  
3ffa 32 63 ee			ld (debug_mark+1),a  
3ffd 3a 07 40			ld a, (.dmark+2)  
4000 32 64 ee			ld (debug_mark+2),a  
4003 18 03			jr .pastdmark  
4005 ..			.dmark: db "D-2"  
4008 f1			.pastdmark: pop af  
4009			endm  
# End of macro DMARK
4009				CALLMONITOR 
4009 cd 6f ee			call debug_vector  
400c				endm  
# End of macro CALLMONITOR
400c			endif	 
400c 10 d7				djnz .dashscan 
400e			 
400e			if DEBUG_FORTH_DOT 
400e				DMARK "D-1" 
400e f5				push af  
400f 3a 23 40			ld a, (.dmark)  
4012 32 62 ee			ld (debug_mark),a  
4015 3a 24 40			ld a, (.dmark+1)  
4018 32 63 ee			ld (debug_mark+1),a  
401b 3a 25 40			ld a, (.dmark+2)  
401e 32 64 ee			ld (debug_mark+2),a  
4021 18 03			jr .pastdmark  
4023 ..			.dmark: db "D-1"  
4026 f1			.pastdmark: pop af  
4027			endm  
# End of macro DMARK
4027				CALLMONITOR 
4027 cd 6f ee			call debug_vector  
402a				endm  
# End of macro CALLMONITOR
402a			endif	 
402a			 
402a			.nodashswap: 
402a			 
402a			if DEBUG_FORTH_DOT 
402a				DMARK "D-o" 
402a f5				push af  
402b 3a 3f 40			ld a, (.dmark)  
402e 32 62 ee			ld (debug_mark),a  
4031 3a 40 40			ld a, (.dmark+1)  
4034 32 63 ee			ld (debug_mark+1),a  
4037 3a 41 40			ld a, (.dmark+2)  
403a 32 64 ee			ld (debug_mark+2),a  
403d 18 03			jr .pastdmark  
403f ..			.dmark: db "D-o"  
4042 f1			.pastdmark: pop af  
4043			endm  
# End of macro DMARK
4043				CALLMONITOR 
4043 cd 6f ee			call debug_vector  
4046				endm  
# End of macro CALLMONITOR
4046			endif	 
4046			 
4046 d5					push de   ; save string start in case we need to advance print 
4047			 
4047 3a 55 ea				ld a, (f_cursor_ptr) 
404a cd c9 0b				call str_at_display 
404d 3a 33 ea				ld a,(cli_autodisplay) 
4050			;		cp 0 
4050 b7					or a 
4051 28 03				jr z, .noupdate 
4053 cd d9 0b						call update_display 
4056					.noupdate: 
4056			 
4056			 
4056					; see if we need to advance the print position 
4056			 
4056 e1					pop hl   ; get back string 
4057			;		ex de,hl 
4057			 
4057 3a 34 ea				ld a, (cli_mvdot) 
405a			if DEBUG_FORTH_DOT 
405a			;		ld e,a 
405a				DMARK "D>1" 
405a f5				push af  
405b 3a 6f 40			ld a, (.dmark)  
405e 32 62 ee			ld (debug_mark),a  
4061 3a 70 40			ld a, (.dmark+1)  
4064 32 63 ee			ld (debug_mark+1),a  
4067 3a 71 40			ld a, (.dmark+2)  
406a 32 64 ee			ld (debug_mark+2),a  
406d 18 03			jr .pastdmark  
406f ..			.dmark: db "D>1"  
4072 f1			.pastdmark: pop af  
4073			endm  
# End of macro DMARK
4073				CALLMONITOR 
4073 cd 6f ee			call debug_vector  
4076				endm  
# End of macro CALLMONITOR
4076			endif	 
4076			;		cp 0 
4076 b7					or a 
4077 28 44				jr z, .noadv 
4079					; yes, lets advance the print position 
4079 3e 00				ld a, 0 
407b cd 44 11				call strlent 
407e			if DEBUG_FORTH_DOT 
407e				DMARK "D-?" 
407e f5				push af  
407f 3a 93 40			ld a, (.dmark)  
4082 32 62 ee			ld (debug_mark),a  
4085 3a 94 40			ld a, (.dmark+1)  
4088 32 63 ee			ld (debug_mark+1),a  
408b 3a 95 40			ld a, (.dmark+2)  
408e 32 64 ee			ld (debug_mark+2),a  
4091 18 03			jr .pastdmark  
4093 ..			.dmark: db "D-?"  
4096 f1			.pastdmark: pop af  
4097			endm  
# End of macro DMARK
4097				CALLMONITOR 
4097 cd 6f ee			call debug_vector  
409a				endm  
# End of macro CALLMONITOR
409a			endif	 
409a 3a 55 ea				ld a, (f_cursor_ptr) 
409d 85					add a,l 
409e					;call addatohl 
409e					;ld a, l 
409e 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
40a1			 
40a1			if DEBUG_FORTH_DOT 
40a1				DMARK "D->" 
40a1 f5				push af  
40a2 3a b6 40			ld a, (.dmark)  
40a5 32 62 ee			ld (debug_mark),a  
40a8 3a b7 40			ld a, (.dmark+1)  
40ab 32 63 ee			ld (debug_mark+1),a  
40ae 3a b8 40			ld a, (.dmark+2)  
40b1 32 64 ee			ld (debug_mark+2),a  
40b4 18 03			jr .pastdmark  
40b6 ..			.dmark: db "D->"  
40b9 f1			.pastdmark: pop af  
40ba			endm  
# End of macro DMARK
40ba				CALLMONITOR 
40ba cd 6f ee			call debug_vector  
40bd				endm  
# End of macro CALLMONITOR
40bd			endif	 
40bd			 
40bd			.noadv:	 
40bd			 
40bd					if DEBUG_FORTH_DOT_WAIT 
40bd							call next_page_prompt 
40bd					endif	 
40bd			; TODO this pop off the stack causes a crash. i dont know why 
40bd			 
40bd			 
40bd			if DEBUG_FORTH_DOT 
40bd				DMARK "DTh" 
40bd f5				push af  
40be 3a d2 40			ld a, (.dmark)  
40c1 32 62 ee			ld (debug_mark),a  
40c4 3a d3 40			ld a, (.dmark+1)  
40c7 32 63 ee			ld (debug_mark+1),a  
40ca 3a d4 40			ld a, (.dmark+2)  
40cd 32 64 ee			ld (debug_mark+2),a  
40d0 18 03			jr .pastdmark  
40d2 ..			.dmark: db "DTh"  
40d5 f1			.pastdmark: pop af  
40d6			endm  
# End of macro DMARK
40d6				CALLMONITOR 
40d6 cd 6f ee			call debug_vector  
40d9				endm  
# End of macro CALLMONITOR
40d9			endif	 
40d9			 
40d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d9 cd 86 1d			call macro_forth_dsp_pop 
40dc				endm 
# End of macro FORTH_DSP_POP
40dc			 
40dc			if DEBUG_FORTH_DOT 
40dc				DMARK "DTi" 
40dc f5				push af  
40dd 3a f1 40			ld a, (.dmark)  
40e0 32 62 ee			ld (debug_mark),a  
40e3 3a f2 40			ld a, (.dmark+1)  
40e6 32 63 ee			ld (debug_mark+1),a  
40e9 3a f3 40			ld a, (.dmark+2)  
40ec 32 64 ee			ld (debug_mark+2),a  
40ef 18 03			jr .pastdmark  
40f1 ..			.dmark: db "DTi"  
40f4 f1			.pastdmark: pop af  
40f5			endm  
# End of macro DMARK
40f5				CALLMONITOR 
40f5 cd 6f ee			call debug_vector  
40f8				endm  
# End of macro CALLMONITOR
40f8			endif	 
40f8			 
40f8			 
40f8					NEXTW 
40f8 cd 6c ee			call parse_vector 
40fb c3 b5 1e			jp macro_next 
40fe				endm 
# End of macro NEXTW
40fe			 
40fe			.CLS: 
40fe				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
40fe 35				db WORD_SYS_CORE+33             
40ff 2e 41			dw .DRAW            
4101 04				db 3 + 1 
4102 .. 00			db "CLS",0              
4106				endm 
# End of macro CWHEAD
4106			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4106					if DEBUG_FORTH_WORDS_KEY 
4106						DMARK "CLS" 
4106 f5				push af  
4107 3a 1b 41			ld a, (.dmark)  
410a 32 62 ee			ld (debug_mark),a  
410d 3a 1c 41			ld a, (.dmark+1)  
4110 32 63 ee			ld (debug_mark+1),a  
4113 3a 1d 41			ld a, (.dmark+2)  
4116 32 64 ee			ld (debug_mark+2),a  
4119 18 03			jr .pastdmark  
411b ..			.dmark: db "CLS"  
411e f1			.pastdmark: pop af  
411f			endm  
# End of macro DMARK
411f						CALLMONITOR 
411f cd 6f ee			call debug_vector  
4122				endm  
# End of macro CALLMONITOR
4122					endif 
4122 cd b7 0b				call clear_display 
4125 c3 48 42				jp .home		; and home cursor 
4128					NEXTW 
4128 cd 6c ee			call parse_vector 
412b c3 b5 1e			jp macro_next 
412e				endm 
# End of macro NEXTW
412e			 
412e			.DRAW: 
412e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
412e 36				db WORD_SYS_CORE+34             
412f 5c 41			dw .DUMP            
4131 05				db 4 + 1 
4132 .. 00			db "DRAW",0              
4137				endm 
# End of macro CWHEAD
4137			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4137					if DEBUG_FORTH_WORDS_KEY 
4137						DMARK "DRW" 
4137 f5				push af  
4138 3a 4c 41			ld a, (.dmark)  
413b 32 62 ee			ld (debug_mark),a  
413e 3a 4d 41			ld a, (.dmark+1)  
4141 32 63 ee			ld (debug_mark+1),a  
4144 3a 4e 41			ld a, (.dmark+2)  
4147 32 64 ee			ld (debug_mark+2),a  
414a 18 03			jr .pastdmark  
414c ..			.dmark: db "DRW"  
414f f1			.pastdmark: pop af  
4150			endm  
# End of macro DMARK
4150						CALLMONITOR 
4150 cd 6f ee			call debug_vector  
4153				endm  
# End of macro CALLMONITOR
4153					endif 
4153 cd d9 0b				call update_display 
4156					NEXTW 
4156 cd 6c ee			call parse_vector 
4159 c3 b5 1e			jp macro_next 
415c				endm 
# End of macro NEXTW
415c			 
415c			.DUMP: 
415c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
415c 37				db WORD_SYS_CORE+35             
415d 97 41			dw .CDUMP            
415f 05				db 4 + 1 
4160 .. 00			db "DUMP",0              
4165				endm 
# End of macro CWHEAD
4165			; | DUMP ( x -- ) With address x display dump   | DONE 
4165			; TODO pop address to use off of the stack 
4165					if DEBUG_FORTH_WORDS_KEY 
4165						DMARK "DUM" 
4165 f5				push af  
4166 3a 7a 41			ld a, (.dmark)  
4169 32 62 ee			ld (debug_mark),a  
416c 3a 7b 41			ld a, (.dmark+1)  
416f 32 63 ee			ld (debug_mark+1),a  
4172 3a 7c 41			ld a, (.dmark+2)  
4175 32 64 ee			ld (debug_mark+2),a  
4178 18 03			jr .pastdmark  
417a ..			.dmark: db "DUM"  
417d f1			.pastdmark: pop af  
417e			endm  
# End of macro DMARK
417e						CALLMONITOR 
417e cd 6f ee			call debug_vector  
4181				endm  
# End of macro CALLMONITOR
4181					endif 
4181 cd b7 0b				call clear_display 
4184			 
4184					; get address 
4184			 
4184					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4184 cd ce 1c			call macro_dsp_valuehl 
4187				endm 
# End of macro FORTH_DSP_VALUEHL
4187				 
4187					; save it for cdump 
4187			 
4187 22 db e5				ld (os_cur_ptr),hl 
418a			 
418a					; destroy value TOS 
418a			 
418a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
418a cd 86 1d			call macro_forth_dsp_pop 
418d				endm 
# End of macro FORTH_DSP_POP
418d			 
418d cd 56 19				call dumpcont	; skip old style of param parsing	 
4190 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4191					NEXTW 
4191 cd 6c ee			call parse_vector 
4194 c3 b5 1e			jp macro_next 
4197				endm 
# End of macro NEXTW
4197			.CDUMP: 
4197				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4197 38				db WORD_SYS_CORE+36             
4198 ca 41			dw .DAT            
419a 06				db 5 + 1 
419b .. 00			db "CDUMP",0              
41a1				endm 
# End of macro CWHEAD
41a1			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
41a1					if DEBUG_FORTH_WORDS_KEY 
41a1						DMARK "CDP" 
41a1 f5				push af  
41a2 3a b6 41			ld a, (.dmark)  
41a5 32 62 ee			ld (debug_mark),a  
41a8 3a b7 41			ld a, (.dmark+1)  
41ab 32 63 ee			ld (debug_mark+1),a  
41ae 3a b8 41			ld a, (.dmark+2)  
41b1 32 64 ee			ld (debug_mark+2),a  
41b4 18 03			jr .pastdmark  
41b6 ..			.dmark: db "CDP"  
41b9 f1			.pastdmark: pop af  
41ba			endm  
# End of macro DMARK
41ba						CALLMONITOR 
41ba cd 6f ee			call debug_vector  
41bd				endm  
# End of macro CALLMONITOR
41bd					endif 
41bd cd b7 0b				call clear_display 
41c0 cd 56 19				call dumpcont	 
41c3 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
41c4					NEXTW 
41c4 cd 6c ee			call parse_vector 
41c7 c3 b5 1e			jp macro_next 
41ca				endm 
# End of macro NEXTW
41ca			 
41ca			 
41ca			 
41ca			 
41ca			.DAT: 
41ca				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
41ca 3d				db WORD_SYS_CORE+41             
41cb 23 42			dw .HOME            
41cd 03				db 2 + 1 
41ce .. 00			db "AT",0              
41d1				endm 
# End of macro CWHEAD
41d1			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
41d1					if DEBUG_FORTH_WORDS_KEY 
41d1						DMARK "AT." 
41d1 f5				push af  
41d2 3a e6 41			ld a, (.dmark)  
41d5 32 62 ee			ld (debug_mark),a  
41d8 3a e7 41			ld a, (.dmark+1)  
41db 32 63 ee			ld (debug_mark+1),a  
41de 3a e8 41			ld a, (.dmark+2)  
41e1 32 64 ee			ld (debug_mark+2),a  
41e4 18 03			jr .pastdmark  
41e6 ..			.dmark: db "AT."  
41e9 f1			.pastdmark: pop af  
41ea			endm  
# End of macro DMARK
41ea						CALLMONITOR 
41ea cd 6f ee			call debug_vector  
41ed				endm  
# End of macro CALLMONITOR
41ed					endif 
41ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41ed cd ce 1c			call macro_dsp_valuehl 
41f0				endm 
# End of macro FORTH_DSP_VALUEHL
41f0			 
41f0			 
41f0					; TODO save cursor row 
41f0 7d					ld a,l 
41f1 fe 02				cp 2 
41f3 20 04				jr nz, .crow3 
41f5 3e 28				ld a, display_row_2 
41f7 18 12				jr .ccol1 
41f9 fe 03		.crow3:		cp 3 
41fb 20 04				jr nz, .crow4 
41fd 3e 50				ld a, display_row_3 
41ff 18 0a				jr .ccol1 
4201 fe 04		.crow4:		cp 4 
4203 20 04				jr nz, .crow1 
4205 3e 78				ld a, display_row_4 
4207 18 02				jr .ccol1 
4209 3e 00		.crow1:		ld a,display_row_1 
420b f5			.ccol1:		push af			; got row offset 
420c 6f					ld l,a 
420d 26 00				ld h,0 
420f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
420f cd 86 1d			call macro_forth_dsp_pop 
4212				endm 
# End of macro FORTH_DSP_POP
4212					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4212 cd ce 1c			call macro_dsp_valuehl 
4215				endm 
# End of macro FORTH_DSP_VALUEHL
4215					; TODO save cursor col 
4215 f1					pop af 
4216 85					add l		; add col offset 
4217 32 55 ea				ld (f_cursor_ptr), a 
421a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
421a cd 86 1d			call macro_forth_dsp_pop 
421d				endm 
# End of macro FORTH_DSP_POP
421d			 
421d					; calculate  
421d			 
421d					NEXTW 
421d cd 6c ee			call parse_vector 
4220 c3 b5 1e			jp macro_next 
4223				endm 
# End of macro NEXTW
4223			 
4223			 
4223			.HOME: 
4223				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4223 41				db WORD_SYS_CORE+45             
4224 53 42			dw .CR            
4226 05				db 4 + 1 
4227 .. 00			db "HOME",0              
422c				endm 
# End of macro CWHEAD
422c			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
422c					if DEBUG_FORTH_WORDS_KEY 
422c						DMARK "HOM" 
422c f5				push af  
422d 3a 41 42			ld a, (.dmark)  
4230 32 62 ee			ld (debug_mark),a  
4233 3a 42 42			ld a, (.dmark+1)  
4236 32 63 ee			ld (debug_mark+1),a  
4239 3a 43 42			ld a, (.dmark+2)  
423c 32 64 ee			ld (debug_mark+2),a  
423f 18 03			jr .pastdmark  
4241 ..			.dmark: db "HOM"  
4244 f1			.pastdmark: pop af  
4245			endm  
# End of macro DMARK
4245						CALLMONITOR 
4245 cd 6f ee			call debug_vector  
4248				endm  
# End of macro CALLMONITOR
4248					endif 
4248 3e 00		.home:		ld a, 0		; and home cursor 
424a 32 55 ea				ld (f_cursor_ptr), a 
424d					NEXTW 
424d cd 6c ee			call parse_vector 
4250 c3 b5 1e			jp macro_next 
4253				endm 
# End of macro NEXTW
4253			 
4253			 
4253			.CR: 
4253				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4253 46				db WORD_SYS_CORE+50             
4254 91 42			dw .SPACE            
4256 03				db 2 + 1 
4257 .. 00			db "CR",0              
425a				endm 
# End of macro CWHEAD
425a			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
425a					if DEBUG_FORTH_WORDS_KEY 
425a						DMARK "CR." 
425a f5				push af  
425b 3a 6f 42			ld a, (.dmark)  
425e 32 62 ee			ld (debug_mark),a  
4261 3a 70 42			ld a, (.dmark+1)  
4264 32 63 ee			ld (debug_mark+1),a  
4267 3a 71 42			ld a, (.dmark+2)  
426a 32 64 ee			ld (debug_mark+2),a  
426d 18 03			jr .pastdmark  
426f ..			.dmark: db "CR."  
4272 f1			.pastdmark: pop af  
4273			endm  
# End of macro DMARK
4273						CALLMONITOR 
4273 cd 6f ee			call debug_vector  
4276				endm  
# End of macro CALLMONITOR
4276					endif 
4276 3e 0d				ld a, 13 
4278 32 b8 e2				ld (scratch),a 
427b 3e 0a				ld a, 10 
427d 32 b9 e2				ld (scratch+1),a 
4280 3e 00				ld a, 0 
4282 32 ba e2				ld (scratch+2),a 
4285 21 b8 e2				ld hl, scratch 
4288 cd 3c 1b				call forth_push_str 
428b					 
428b				       NEXTW 
428b cd 6c ee			call parse_vector 
428e c3 b5 1e			jp macro_next 
4291				endm 
# End of macro NEXTW
4291			.SPACE: 
4291				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4291 46				db WORD_SYS_CORE+50             
4292 ca 42			dw .SPACES            
4294 03				db 2 + 1 
4295 .. 00			db "BL",0              
4298				endm 
# End of macro CWHEAD
4298			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4298					if DEBUG_FORTH_WORDS_KEY 
4298						DMARK "BL." 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 62 ee			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 63 ee			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 64 ee			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "BL."  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd 6f ee			call debug_vector  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4 3e 20				ld a, " " 
42b6 32 b8 e2				ld (scratch),a 
42b9 3e 00				ld a, 0 
42bb 32 b9 e2				ld (scratch+1),a 
42be 21 b8 e2				ld hl, scratch 
42c1 cd 3c 1b				call forth_push_str 
42c4					 
42c4				       NEXTW 
42c4 cd 6c ee			call parse_vector 
42c7 c3 b5 1e			jp macro_next 
42ca				endm 
# End of macro NEXTW
42ca			 
42ca			;.blstr: db " ", 0 
42ca			 
42ca			.SPACES: 
42ca				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
42ca 47				db WORD_SYS_CORE+51             
42cb 66 43			dw .SCROLL            
42cd 07				db 6 + 1 
42ce .. 00			db "SPACES",0              
42d5				endm 
# End of macro CWHEAD
42d5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
42d5					if DEBUG_FORTH_WORDS_KEY 
42d5						DMARK "SPS" 
42d5 f5				push af  
42d6 3a ea 42			ld a, (.dmark)  
42d9 32 62 ee			ld (debug_mark),a  
42dc 3a eb 42			ld a, (.dmark+1)  
42df 32 63 ee			ld (debug_mark+1),a  
42e2 3a ec 42			ld a, (.dmark+2)  
42e5 32 64 ee			ld (debug_mark+2),a  
42e8 18 03			jr .pastdmark  
42ea ..			.dmark: db "SPS"  
42ed f1			.pastdmark: pop af  
42ee			endm  
# End of macro DMARK
42ee						CALLMONITOR 
42ee cd 6f ee			call debug_vector  
42f1				endm  
# End of macro CALLMONITOR
42f1					endif 
42f1			 
42f1			 
42f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42f1 cd ce 1c			call macro_dsp_valuehl 
42f4				endm 
# End of macro FORTH_DSP_VALUEHL
42f4			 
42f4 e5					push hl    ; u 
42f5					if DEBUG_FORTH_WORDS 
42f5						DMARK "SPA" 
42f5 f5				push af  
42f6 3a 0a 43			ld a, (.dmark)  
42f9 32 62 ee			ld (debug_mark),a  
42fc 3a 0b 43			ld a, (.dmark+1)  
42ff 32 63 ee			ld (debug_mark+1),a  
4302 3a 0c 43			ld a, (.dmark+2)  
4305 32 64 ee			ld (debug_mark+2),a  
4308 18 03			jr .pastdmark  
430a ..			.dmark: db "SPA"  
430d f1			.pastdmark: pop af  
430e			endm  
# End of macro DMARK
430e						CALLMONITOR 
430e cd 6f ee			call debug_vector  
4311				endm  
# End of macro CALLMONITOR
4311					endif 
4311			 
4311					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4311 cd 86 1d			call macro_forth_dsp_pop 
4314				endm 
# End of macro FORTH_DSP_POP
4314 e1					pop hl 
4315 0e 00				ld c, 0 
4317 45					ld b, l 
4318 21 b8 e2				ld hl, scratch  
431b			 
431b					if DEBUG_FORTH_WORDS 
431b						DMARK "SP2" 
431b f5				push af  
431c 3a 30 43			ld a, (.dmark)  
431f 32 62 ee			ld (debug_mark),a  
4322 3a 31 43			ld a, (.dmark+1)  
4325 32 63 ee			ld (debug_mark+1),a  
4328 3a 32 43			ld a, (.dmark+2)  
432b 32 64 ee			ld (debug_mark+2),a  
432e 18 03			jr .pastdmark  
4330 ..			.dmark: db "SP2"  
4333 f1			.pastdmark: pop af  
4334			endm  
# End of macro DMARK
4334						CALLMONITOR 
4334 cd 6f ee			call debug_vector  
4337				endm  
# End of macro CALLMONITOR
4337					endif 
4337			;		ld a, ' ' 
4337			.spaces1:	 
4337 36 20				ld (hl),' ' 
4339 23					inc hl 
433a					 
433a 10 fb				djnz .spaces1 
433c			;		ld a,0 
433c 36 00				ld (hl),0 
433e 21 b8 e2				ld hl, scratch 
4341					if DEBUG_FORTH_WORDS 
4341						DMARK "SP3" 
4341 f5				push af  
4342 3a 56 43			ld a, (.dmark)  
4345 32 62 ee			ld (debug_mark),a  
4348 3a 57 43			ld a, (.dmark+1)  
434b 32 63 ee			ld (debug_mark+1),a  
434e 3a 58 43			ld a, (.dmark+2)  
4351 32 64 ee			ld (debug_mark+2),a  
4354 18 03			jr .pastdmark  
4356 ..			.dmark: db "SP3"  
4359 f1			.pastdmark: pop af  
435a			endm  
# End of macro DMARK
435a						CALLMONITOR 
435a cd 6f ee			call debug_vector  
435d				endm  
# End of macro CALLMONITOR
435d					endif 
435d cd 3c 1b				call forth_push_str 
4360			 
4360				       NEXTW 
4360 cd 6c ee			call parse_vector 
4363 c3 b5 1e			jp macro_next 
4366				endm 
# End of macro NEXTW
4366			 
4366			 
4366			 
4366			.SCROLL: 
4366				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4366 53				db WORD_SYS_CORE+63             
4367 96 43			dw .SCROLLD            
4369 07				db 6 + 1 
436a .. 00			db "SCROLL",0              
4371				endm 
# End of macro CWHEAD
4371			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4371					if DEBUG_FORTH_WORDS_KEY 
4371						DMARK "SCR" 
4371 f5				push af  
4372 3a 86 43			ld a, (.dmark)  
4375 32 62 ee			ld (debug_mark),a  
4378 3a 87 43			ld a, (.dmark+1)  
437b 32 63 ee			ld (debug_mark+1),a  
437e 3a 88 43			ld a, (.dmark+2)  
4381 32 64 ee			ld (debug_mark+2),a  
4384 18 03			jr .pastdmark  
4386 ..			.dmark: db "SCR"  
4389 f1			.pastdmark: pop af  
438a			endm  
# End of macro DMARK
438a						CALLMONITOR 
438a cd 6f ee			call debug_vector  
438d				endm  
# End of macro CALLMONITOR
438d					endif 
438d			 
438d cd 7a 0b			call scroll_up 
4390			;	call update_display 
4390			 
4390					NEXTW 
4390 cd 6c ee			call parse_vector 
4393 c3 b5 1e			jp macro_next 
4396				endm 
# End of macro NEXTW
4396			 
4396			 
4396			 
4396			;		; get dir 
4396			; 
4396			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4396			; 
4396			;		push hl 
4396			; 
4396			;		; destroy value TOS 
4396			; 
4396			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4396			; 
4396			;		; get count 
4396			; 
4396			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4396			; 
4396			;		push hl 
4396			; 
4396			;		; destroy value TOS 
4396			; 
4396			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4396			; 
4396			;		; one value on hl get other one back 
4396			; 
4396			;		pop bc    ; count 
4396			; 
4396			;		pop de   ; dir 
4396			; 
4396			; 
4396			;		ld b, c 
4396			; 
4396			;.scrolldir:     push bc 
4396			;		push de 
4396			; 
4396			;		ld a, 0 
4396			;		cp e 
4396			;		jr z, .scrollup  
4396			;		call scroll_down 
4396			;		jr .scrollnext 
4396			;.scrollup:	call scroll_up 
4396			; 
4396			;		 
4396			;.scrollnext: 
4396			;		pop de 
4396			;		pop bc 
4396			;		djnz .scrolldir 
4396			; 
4396			; 
4396			; 
4396			; 
4396			; 
4396			;		NEXTW 
4396			 
4396			.SCROLLD: 
4396				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4396 53				db WORD_SYS_CORE+63             
4397 c7 43			dw .ATQ            
4399 08				db 7 + 1 
439a .. 00			db "SCROLLD",0              
43a2				endm 
# End of macro CWHEAD
43a2			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
43a2					if DEBUG_FORTH_WORDS_KEY 
43a2						DMARK "SCD" 
43a2 f5				push af  
43a3 3a b7 43			ld a, (.dmark)  
43a6 32 62 ee			ld (debug_mark),a  
43a9 3a b8 43			ld a, (.dmark+1)  
43ac 32 63 ee			ld (debug_mark+1),a  
43af 3a b9 43			ld a, (.dmark+2)  
43b2 32 64 ee			ld (debug_mark+2),a  
43b5 18 03			jr .pastdmark  
43b7 ..			.dmark: db "SCD"  
43ba f1			.pastdmark: pop af  
43bb			endm  
# End of macro DMARK
43bb						CALLMONITOR 
43bb cd 6f ee			call debug_vector  
43be				endm  
# End of macro CALLMONITOR
43be					endif 
43be			 
43be cd 9d 0b			call scroll_down 
43c1			;	call update_display 
43c1			 
43c1					NEXTW 
43c1 cd 6c ee			call parse_vector 
43c4 c3 b5 1e			jp macro_next 
43c7				endm 
# End of macro NEXTW
43c7			 
43c7			 
43c7			.ATQ: 
43c7				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
43c7 62				db WORD_SYS_CORE+78             
43c8 28 44			dw .AUTODSP            
43ca 04				db 3 + 1 
43cb .. 00			db "AT@",0              
43cf				endm 
# End of macro CWHEAD
43cf			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
43cf					if DEBUG_FORTH_WORDS_KEY 
43cf						DMARK "ATA" 
43cf f5				push af  
43d0 3a e4 43			ld a, (.dmark)  
43d3 32 62 ee			ld (debug_mark),a  
43d6 3a e5 43			ld a, (.dmark+1)  
43d9 32 63 ee			ld (debug_mark+1),a  
43dc 3a e6 43			ld a, (.dmark+2)  
43df 32 64 ee			ld (debug_mark+2),a  
43e2 18 03			jr .pastdmark  
43e4 ..			.dmark: db "ATA"  
43e7 f1			.pastdmark: pop af  
43e8			endm  
# End of macro DMARK
43e8						CALLMONITOR 
43e8 cd 6f ee			call debug_vector  
43eb				endm  
# End of macro CALLMONITOR
43eb					endif 
43eb			 
43eb			 
43eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43eb cd ce 1c			call macro_dsp_valuehl 
43ee				endm 
# End of macro FORTH_DSP_VALUEHL
43ee			 
43ee					; TODO save cursor row 
43ee 7d					ld a,l 
43ef fe 02				cp 2 
43f1 20 04				jr nz, .crow3aq 
43f3 3e 28				ld a, display_row_2 
43f5 18 12				jr .ccol1aq 
43f7 fe 03		.crow3aq:		cp 3 
43f9 20 04				jr nz, .crow4aq 
43fb 3e 50				ld a, display_row_3 
43fd 18 0a				jr .ccol1aq 
43ff fe 04		.crow4aq:		cp 4 
4401 20 04				jr nz, .crow1aq 
4403 3e 78				ld a, display_row_4 
4405 18 02				jr .ccol1aq 
4407 3e 00		.crow1aq:		ld a,display_row_1 
4409 f5			.ccol1aq:		push af			; got row offset 
440a 6f					ld l,a 
440b 26 00				ld h,0 
440d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
440d cd 86 1d			call macro_forth_dsp_pop 
4410				endm 
# End of macro FORTH_DSP_POP
4410					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4410 cd ce 1c			call macro_dsp_valuehl 
4413				endm 
# End of macro FORTH_DSP_VALUEHL
4413					; TODO save cursor col 
4413 f1					pop af 
4414 85					add l		; add col offset 
4415			 
4415					; add current frame buffer address 
4415 2a c3 eb				ld hl, (display_fb_active) 
4418 cd e1 0d				call addatohl 
441b			 
441b			 
441b			 
441b			 
441b					; get char frame buffer location offset in hl 
441b			 
441b 7e					ld a,(hl) 
441c 26 00				ld h, 0 
441e 6f					ld l, a 
441f			 
441f cd d2 1a				call forth_push_numhl 
4422			 
4422			 
4422					NEXTW 
4422 cd 6c ee			call parse_vector 
4425 c3 b5 1e			jp macro_next 
4428				endm 
# End of macro NEXTW
4428			 
4428			.AUTODSP: 
4428				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4428 63				db WORD_SYS_CORE+79             
4429 41 44			dw .MENU            
442b 05				db 4 + 1 
442c .. 00			db "ADSP",0              
4431				endm 
# End of macro CWHEAD
4431			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4431			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4431			 
4431					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4431 cd ce 1c			call macro_dsp_valuehl 
4434				endm 
# End of macro FORTH_DSP_VALUEHL
4434			 
4434			;		push hl 
4434			 
4434					; destroy value TOS 
4434			 
4434					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4434 cd 86 1d			call macro_forth_dsp_pop 
4437				endm 
# End of macro FORTH_DSP_POP
4437			 
4437			;		pop hl 
4437			 
4437 7d					ld a,l 
4438 32 33 ea				ld (cli_autodisplay), a 
443b				       NEXTW 
443b cd 6c ee			call parse_vector 
443e c3 b5 1e			jp macro_next 
4441				endm 
# End of macro NEXTW
4441			 
4441			.MENU: 
4441				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4441 70				db WORD_SYS_CORE+92             
4442 ed 44			dw .ENDDISPLAY            
4444 05				db 4 + 1 
4445 .. 00			db "MENU",0              
444a				endm 
# End of macro CWHEAD
444a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
444a			 
444a			;		; get number of items on the stack 
444a			; 
444a				 
444a					FORTH_DSP_VALUEHL 
444a cd ce 1c			call macro_dsp_valuehl 
444d				endm 
# End of macro FORTH_DSP_VALUEHL
444d				 
444d					if DEBUG_FORTH_WORDS_KEY 
444d						DMARK "MNU" 
444d f5				push af  
444e 3a 62 44			ld a, (.dmark)  
4451 32 62 ee			ld (debug_mark),a  
4454 3a 63 44			ld a, (.dmark+1)  
4457 32 63 ee			ld (debug_mark+1),a  
445a 3a 64 44			ld a, (.dmark+2)  
445d 32 64 ee			ld (debug_mark+2),a  
4460 18 03			jr .pastdmark  
4462 ..			.dmark: db "MNU"  
4465 f1			.pastdmark: pop af  
4466			endm  
# End of macro DMARK
4466						CALLMONITOR 
4466 cd 6f ee			call debug_vector  
4469				endm  
# End of macro CALLMONITOR
4469					endif 
4469			 
4469 45					ld b, l	 
446a 05					dec b 
446b			 
446b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
446b cd 86 1d			call macro_forth_dsp_pop 
446e				endm 
# End of macro FORTH_DSP_POP
446e			 
446e			 
446e					; go directly through the stack to pluck out the string pointers and build an array 
446e			 
446e			;		FORTH_DSP 
446e			 
446e					; hl contains top most stack item 
446e				 
446e 11 b8 e2				ld de, scratch 
4471			 
4471			.mbuild: 
4471			 
4471					FORTH_DSP_VALUEHL 
4471 cd ce 1c			call macro_dsp_valuehl 
4474				endm 
# End of macro FORTH_DSP_VALUEHL
4474			 
4474					if DEBUG_FORTH_WORDS 
4474						DMARK "MN3" 
4474 f5				push af  
4475 3a 89 44			ld a, (.dmark)  
4478 32 62 ee			ld (debug_mark),a  
447b 3a 8a 44			ld a, (.dmark+1)  
447e 32 63 ee			ld (debug_mark+1),a  
4481 3a 8b 44			ld a, (.dmark+2)  
4484 32 64 ee			ld (debug_mark+2),a  
4487 18 03			jr .pastdmark  
4489 ..			.dmark: db "MN3"  
448c f1			.pastdmark: pop af  
448d			endm  
# End of macro DMARK
448d						CALLMONITOR 
448d cd 6f ee			call debug_vector  
4490				endm  
# End of macro CALLMONITOR
4490					endif 
4490 eb					ex de, hl 
4491 73					ld (hl), e 
4492 23					inc hl 
4493 72					ld (hl), d 
4494 23					inc hl 
4495 eb					ex de, hl 
4496			 
4496					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4496 cd 86 1d			call macro_forth_dsp_pop 
4499				endm 
# End of macro FORTH_DSP_POP
4499			 
4499 10 d6				djnz .mbuild 
449b			 
449b					; done add term 
449b			 
449b eb					ex de, hl 
449c 36 00				ld (hl), 0 
449e 23					inc hl 
449f 36 00				ld (hl), 0 
44a1			 
44a1				 
44a1					 
44a1 21 b8 e2				ld hl, scratch 
44a4			 
44a4					if DEBUG_FORTH_WORDS 
44a4						DMARK "MNx" 
44a4 f5				push af  
44a5 3a b9 44			ld a, (.dmark)  
44a8 32 62 ee			ld (debug_mark),a  
44ab 3a ba 44			ld a, (.dmark+1)  
44ae 32 63 ee			ld (debug_mark+1),a  
44b1 3a bb 44			ld a, (.dmark+2)  
44b4 32 64 ee			ld (debug_mark+2),a  
44b7 18 03			jr .pastdmark  
44b9 ..			.dmark: db "MNx"  
44bc f1			.pastdmark: pop af  
44bd			endm  
# End of macro DMARK
44bd						CALLMONITOR 
44bd cd 6f ee			call debug_vector  
44c0				endm  
# End of macro CALLMONITOR
44c0					endif 
44c0			 
44c0			 
44c0			 
44c0 3e 00				ld a, 0 
44c2 cd e7 0b				call menu 
44c5			 
44c5			 
44c5 6f					ld l, a 
44c6 26 00				ld h, 0 
44c8			 
44c8					if DEBUG_FORTH_WORDS 
44c8						DMARK "MNr" 
44c8 f5				push af  
44c9 3a dd 44			ld a, (.dmark)  
44cc 32 62 ee			ld (debug_mark),a  
44cf 3a de 44			ld a, (.dmark+1)  
44d2 32 63 ee			ld (debug_mark+1),a  
44d5 3a df 44			ld a, (.dmark+2)  
44d8 32 64 ee			ld (debug_mark+2),a  
44db 18 03			jr .pastdmark  
44dd ..			.dmark: db "MNr"  
44e0 f1			.pastdmark: pop af  
44e1			endm  
# End of macro DMARK
44e1						CALLMONITOR 
44e1 cd 6f ee			call debug_vector  
44e4				endm  
# End of macro CALLMONITOR
44e4					endif 
44e4			 
44e4 cd d2 1a				call forth_push_numhl 
44e7			 
44e7			 
44e7			 
44e7			 
44e7				       NEXTW 
44e7 cd 6c ee			call parse_vector 
44ea c3 b5 1e			jp macro_next 
44ed				endm 
# End of macro NEXTW
44ed			 
44ed			 
44ed			.ENDDISPLAY: 
44ed			 
44ed			; eof 
# End of file forth_words_display.asm
44ed			include "forth_words_str.asm" 
44ed			 
44ed			; | ## String Words 
44ed			 
44ed			.CONST: 
44ed				 
44ed				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
44ed 48				db WORD_SYS_CORE+52             
44ee 02 45			dw .MOVE            
44f0 06				db 5 + 1 
44f1 .. 00			db "CONST",0              
44f7				endm 
# End of macro CWHEAD
44f7			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
44f7					FORTH_DSP 
44f7 cd 94 1c			call macro_forth_dsp 
44fa				endm 
# End of macro FORTH_DSP
44fa 36 04				ld (hl), DS_TYPE_CONST 
44fc					NEXTW 
44fc cd 6c ee			call parse_vector 
44ff c3 b5 1e			jp macro_next 
4502				endm 
# End of macro NEXTW
4502			 
4502			.MOVE:   
4502			 
4502				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
4502 48				db WORD_SYS_CORE+52             
4503 29 45			dw .ZMOVE            
4505 05				db 4 + 1 
4506 .. 00			db "MOVE",0              
450b				endm 
# End of macro CWHEAD
450b			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
450b			 
450b					FORTH_DSP_VALUEHL 
450b cd ce 1c			call macro_dsp_valuehl 
450e				endm 
# End of macro FORTH_DSP_VALUEHL
450e e5					push hl    ; push count 
450f			 
450f					FORTH_DSP_POP 
450f cd 86 1d			call macro_forth_dsp_pop 
4512				endm 
# End of macro FORTH_DSP_POP
4512			 
4512					FORTH_DSP_VALUEHL 
4512 cd ce 1c			call macro_dsp_valuehl 
4515				endm 
# End of macro FORTH_DSP_VALUEHL
4515 e5					push hl    ; dest 
4516			 
4516					FORTH_DSP_POP 
4516 cd 86 1d			call macro_forth_dsp_pop 
4519				endm 
# End of macro FORTH_DSP_POP
4519			 
4519					FORTH_DSP_VALUEHL 
4519 cd ce 1c			call macro_dsp_valuehl 
451c				endm 
# End of macro FORTH_DSP_VALUEHL
451c			 
451c					FORTH_DSP_POP 
451c cd 86 1d			call macro_forth_dsp_pop 
451f				endm 
# End of macro FORTH_DSP_POP
451f			 
451f d1					pop de 
4520 c1					pop bc 
4521				 
4521 ed b0				ldir 
4523				NEXTW 
4523 cd 6c ee			call parse_vector 
4526 c3 b5 1e			jp macro_next 
4529				endm 
# End of macro NEXTW
4529			.ZMOVE:   
4529			 
4529				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
4529 48				db WORD_SYS_CORE+52             
452a 52 45			dw .TABLE            
452c 06				db 5 + 1 
452d .. 00			db "ZMOVE",0              
4533				endm 
# End of macro CWHEAD
4533					 
4533			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
4533			; | | Ensure you have enough space! 
4533			 
4533			 
4533					FORTH_DSP_VALUEHL 
4533 cd ce 1c			call macro_dsp_valuehl 
4536				endm 
# End of macro FORTH_DSP_VALUEHL
4536 e5					push hl    ; dest 
4537			 
4537					FORTH_DSP_POP 
4537 cd 86 1d			call macro_forth_dsp_pop 
453a				endm 
# End of macro FORTH_DSP_POP
453a			 
453a					FORTH_DSP_VALUEHL 
453a cd ce 1c			call macro_dsp_valuehl 
453d				endm 
# End of macro FORTH_DSP_VALUEHL
453d			 
453d					FORTH_DSP_POP 
453d cd 86 1d			call macro_forth_dsp_pop 
4540				endm 
# End of macro FORTH_DSP_POP
4540			 
4540 d1					pop de 
4541			 
4541 01 ff 00				ld bc, 255 
4544 ed a0		.zmovel:	ldi 
4546 2b					dec hl 
4547 7e					ld a,(hl) 
4548 23					inc hl 
4549 b7					or a  
454a 20 f8				jr nz, .zmovel    
454c					 
454c			 
454c				NEXTW 
454c cd 6c ee			call parse_vector 
454f c3 b5 1e			jp macro_next 
4552				endm 
# End of macro NEXTW
4552			 
4552			.TABLE:   
4552			 
4552				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
4552 48				db WORD_SYS_CORE+52             
4553 b7 45			dw .SPLIT            
4555 06				db 5 + 1 
4556 .. 00			db "TABLE",0              
455c				endm 
# End of macro CWHEAD
455c					 
455c			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
455c			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
455c			; | | in any kind of lookup or iteration.  
455c			; | | Last item in the array will be a zero pointer for ease of iteration 
455c			 
455c			 
455c				; get the count of strings 
455c			 
455c					FORTH_DSP_VALUEHL 
455c cd ce 1c			call macro_dsp_valuehl 
455f				endm 
# End of macro FORTH_DSP_VALUEHL
455f			 
455f					FORTH_DSP_POP 
455f cd 86 1d			call macro_forth_dsp_pop 
4562				endm 
# End of macro FORTH_DSP_POP
4562			 
4562				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
4562			 
4562					; l contains count 
4562			 
4562 7d					ld a,l 
4563 32 b8 e2				ld (scratch), a     ; save it for the loading loop 
4566			 
4566 2c					inc l  ; for zero pointer 
4567 eb					ex de, hl 
4568 3e 02				ld a, 2 
456a cd 64 0d				call Mult16 
456d			 
456d					; hl is the size of block to allocate 
456d			 
456d cd ad 11				call malloc 
4570				if DEBUG_FORTH_MALLOC_GUARD 
4570 cc 23 54				call z,malloc_error 
4573				endif 
4573					; hl is the pointer to the array block 
4573						 
4573 22 b9 e2				ld (scratch+1), hl    ; save the base for later push to stack 
4576 22 bb e2				ld (scratch+3), hl    ; save the base for current string to push 
4579			 
4579 3a b8 e2				ld a, (scratch) 
457c 47					ld b, a 
457d			 
457d				; for each string 
457d			 
457d			.tablelop: 
457d			 
457d c5					push bc 
457e			 
457e				;     get string pointer 
457e			 
457e					FORTH_DSP_VALUEHL 
457e cd ce 1c			call macro_dsp_valuehl 
4581				endm 
# End of macro FORTH_DSP_VALUEHL
4581			 
4581 e5					push hl 
4582			 
4582				;     get string length 
4582			 
4582 3e 00				ld a,0 
4584 cd 44 11				call strlent 
4587			 
4587 23					inc hl 
4588 e5					push hl 
4589			 
4589				;     allocate string length 
4589			 
4589 cd ad 11				call malloc 
458c			 
458c			        ;     copy string to block 
458c			 
458c c1					pop bc 
458d eb					ex de, hl 
458e e1					pop hl 
458f d5					push de 
4590			 
4590 ed b0				ldir 
4592			 
4592			 
4592			        ;     add pointer to string to array block 
4592			 
4592 2a bb e2				ld hl, (scratch+3)    ; save the base for current string to push 
4595			 
4595 d1					pop de     ; the pointer to the newly copied string to add to the array 
4596 73					ld (hl), e 
4597 23					inc hl 
4598 72					ld (hl), d	 
4599 23					inc hl 
459a				 
459a 22 bb e2				ld (scratch+3), hl    ; save the base for current string to push 
459d			 
459d					FORTH_DSP_POP 
459d cd 86 1d			call macro_forth_dsp_pop 
45a0				endm 
# End of macro FORTH_DSP_POP
45a0			 
45a0 c1					pop bc 
45a1 10 da				djnz .tablelop 
45a3			 
45a3			        ;  push array block pointer 
45a3			 
45a3 2a bb e2				ld hl, (scratch+3)    ; save the base for current string to push 
45a6 36 00				ld (hl), 0 
45a8 23					inc hl 
45a9 36 00				ld (hl), 0 
45ab			 
45ab			 
45ab				 
45ab 2a b9 e2				ld hl, (scratch+1)    ; save the base for current string to push 
45ae cd d2 1a				call forth_push_numhl 
45b1			 
45b1				NEXTW 
45b1 cd 6c ee			call parse_vector 
45b4 c3 b5 1e			jp macro_next 
45b7				endm 
# End of macro NEXTW
45b7			 
45b7			.SPLIT:   
45b7			 
45b7				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
45b7 48				db WORD_SYS_CORE+52             
45b8 ae 46			dw .PTR            
45ba 06				db 5 + 1 
45bb .. 00			db "SPLIT",0              
45c1				endm 
# End of macro CWHEAD
45c1			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
45c1					if DEBUG_FORTH_WORDS_KEY 
45c1						DMARK "SPT" 
45c1 f5				push af  
45c2 3a d6 45			ld a, (.dmark)  
45c5 32 62 ee			ld (debug_mark),a  
45c8 3a d7 45			ld a, (.dmark+1)  
45cb 32 63 ee			ld (debug_mark+1),a  
45ce 3a d8 45			ld a, (.dmark+2)  
45d1 32 64 ee			ld (debug_mark+2),a  
45d4 18 03			jr .pastdmark  
45d6 ..			.dmark: db "SPT"  
45d9 f1			.pastdmark: pop af  
45da			endm  
# End of macro DMARK
45da						CALLMONITOR 
45da cd 6f ee			call debug_vector  
45dd				endm  
# End of macro CALLMONITOR
45dd					endif 
45dd			 
45dd					; get delim 
45dd					FORTH_DSP_VALUEHL 
45dd cd ce 1c			call macro_dsp_valuehl 
45e0				endm 
# End of macro FORTH_DSP_VALUEHL
45e0			 
45e0					FORTH_DSP_POP 
45e0 cd 86 1d			call macro_forth_dsp_pop 
45e3				endm 
# End of macro FORTH_DSP_POP
45e3					 
45e3			 
45e3 45					ld b, l    ; move delim to b 
45e4 0e 01				ld c, 1   ; count of poritions 
45e6			 
45e6 c5					push bc 
45e7			 
45e7					if DEBUG_FORTH_WORDS 
45e7						DMARK "SPa" 
45e7 f5				push af  
45e8 3a fc 45			ld a, (.dmark)  
45eb 32 62 ee			ld (debug_mark),a  
45ee 3a fd 45			ld a, (.dmark+1)  
45f1 32 63 ee			ld (debug_mark+1),a  
45f4 3a fe 45			ld a, (.dmark+2)  
45f7 32 64 ee			ld (debug_mark+2),a  
45fa 18 03			jr .pastdmark  
45fc ..			.dmark: db "SPa"  
45ff f1			.pastdmark: pop af  
4600			endm  
# End of macro DMARK
4600						CALLMONITOR 
4600 cd 6f ee			call debug_vector  
4603				endm  
# End of macro CALLMONITOR
4603					endif 
4603					; get pointer to string to chop up 
4603					FORTH_DSP_VALUEHL 
4603 cd ce 1c			call macro_dsp_valuehl 
4606				endm 
# End of macro FORTH_DSP_VALUEHL
4606			 
4606			;		push hl 
4606 11 b8 e2				ld de, scratch 
4609			.spllop: 
4609 c1					pop bc 
460a c5					push bc 
460b			;		pop hl 
460b					if DEBUG_FORTH_WORDS 
460b						DMARK "SPl" 
460b f5				push af  
460c 3a 20 46			ld a, (.dmark)  
460f 32 62 ee			ld (debug_mark),a  
4612 3a 21 46			ld a, (.dmark+1)  
4615 32 63 ee			ld (debug_mark+1),a  
4618 3a 22 46			ld a, (.dmark+2)  
461b 32 64 ee			ld (debug_mark+2),a  
461e 18 03			jr .pastdmark  
4620 ..			.dmark: db "SPl"  
4623 f1			.pastdmark: pop af  
4624			endm  
# End of macro DMARK
4624						CALLMONITOR 
4624 cd 6f ee			call debug_vector  
4627				endm  
# End of macro CALLMONITOR
4627					endif 
4627 7e					ld a, (hl) 
4628 b8					cp b 
4629 28 07				jr z, .splnxt 
462b			;		cp 0 
462b b7					or a 
462c 28 34				jr z, .splend 
462e ed a0				ldi 
4630 18 d7				jr .spllop 
4632			 
4632					; hit dlim 
4632			 
4632			.splnxt: 
4632					if DEBUG_FORTH_WORDS 
4632						DMARK "SPx" 
4632 f5				push af  
4633 3a 47 46			ld a, (.dmark)  
4636 32 62 ee			ld (debug_mark),a  
4639 3a 48 46			ld a, (.dmark+1)  
463c 32 63 ee			ld (debug_mark+1),a  
463f 3a 49 46			ld a, (.dmark+2)  
4642 32 64 ee			ld (debug_mark+2),a  
4645 18 03			jr .pastdmark  
4647 ..			.dmark: db "SPx"  
464a f1			.pastdmark: pop af  
464b			endm  
# End of macro DMARK
464b						CALLMONITOR 
464b cd 6f ee			call debug_vector  
464e				endm  
# End of macro CALLMONITOR
464e					endif 
464e 3e 00				ld a, 0 
4650 12					ld (de), a 
4651					;ex de, hl 
4651 e5					push hl 
4652 21 b8 e2				ld hl, scratch 
4655 cd 3c 1b				call forth_push_str 
4658 e1					pop hl 
4659					;ex de, hl 
4659 23					inc hl 
465a c1					pop bc 
465b 0c					inc c 
465c c5					push bc 
465d 11 b8 e2				ld de, scratch 
4660 18 a7				jr .spllop 
4662			 
4662			.splend:		 
4662					if DEBUG_FORTH_WORDS 
4662						DMARK "SPe" 
4662 f5				push af  
4663 3a 77 46			ld a, (.dmark)  
4666 32 62 ee			ld (debug_mark),a  
4669 3a 78 46			ld a, (.dmark+1)  
466c 32 63 ee			ld (debug_mark+1),a  
466f 3a 79 46			ld a, (.dmark+2)  
4672 32 64 ee			ld (debug_mark+2),a  
4675 18 03			jr .pastdmark  
4677 ..			.dmark: db "SPe"  
467a f1			.pastdmark: pop af  
467b			endm  
# End of macro DMARK
467b						CALLMONITOR 
467b cd 6f ee			call debug_vector  
467e				endm  
# End of macro CALLMONITOR
467e					endif 
467e 12					ld (de), a 
467f eb					ex de, hl 
4680			;		push hl 
4680 21 b8 e2				ld hl, scratch 
4683 cd 3c 1b				call forth_push_str 
4686					 
4686					if DEBUG_FORTH_WORDS 
4686						DMARK "SPc" 
4686 f5				push af  
4687 3a 9b 46			ld a, (.dmark)  
468a 32 62 ee			ld (debug_mark),a  
468d 3a 9c 46			ld a, (.dmark+1)  
4690 32 63 ee			ld (debug_mark+1),a  
4693 3a 9d 46			ld a, (.dmark+2)  
4696 32 64 ee			ld (debug_mark+2),a  
4699 18 03			jr .pastdmark  
469b ..			.dmark: db "SPc"  
469e f1			.pastdmark: pop af  
469f			endm  
# End of macro DMARK
469f						CALLMONITOR 
469f cd 6f ee			call debug_vector  
46a2				endm  
# End of macro CALLMONITOR
46a2					endif 
46a2			 
46a2 e1					pop hl    ; get counter from bc which has been push 
46a3 26 00				ld h, 0 
46a5			;		ld l, c 
46a5 cd d2 1a				call forth_push_numhl 
46a8			 
46a8			 
46a8				NEXTW 
46a8 cd 6c ee			call parse_vector 
46ab c3 b5 1e			jp macro_next 
46ae				endm 
# End of macro NEXTW
46ae			.PTR:   
46ae			 
46ae				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
46ae 48				db WORD_SYS_CORE+52             
46af de 46			dw .STYPE            
46b1 04				db 3 + 1 
46b2 .. 00			db "PTR",0              
46b6				endm 
# End of macro CWHEAD
46b6			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
46b6			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
46b6			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
46b6			 
46b6					if DEBUG_FORTH_WORDS_KEY 
46b6						DMARK "PTR" 
46b6 f5				push af  
46b7 3a cb 46			ld a, (.dmark)  
46ba 32 62 ee			ld (debug_mark),a  
46bd 3a cc 46			ld a, (.dmark+1)  
46c0 32 63 ee			ld (debug_mark+1),a  
46c3 3a cd 46			ld a, (.dmark+2)  
46c6 32 64 ee			ld (debug_mark+2),a  
46c9 18 03			jr .pastdmark  
46cb ..			.dmark: db "PTR"  
46ce f1			.pastdmark: pop af  
46cf			endm  
# End of macro DMARK
46cf						CALLMONITOR 
46cf cd 6f ee			call debug_vector  
46d2				endm  
# End of macro CALLMONITOR
46d2					endif 
46d2					FORTH_DSP_VALUEHL 
46d2 cd ce 1c			call macro_dsp_valuehl 
46d5				endm 
# End of macro FORTH_DSP_VALUEHL
46d5 cd d2 1a				call forth_push_numhl 
46d8			 
46d8			 
46d8					NEXTW 
46d8 cd 6c ee			call parse_vector 
46db c3 b5 1e			jp macro_next 
46de				endm 
# End of macro NEXTW
46de			.STYPE: 
46de				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
46de 48				db WORD_SYS_CORE+52             
46df 3b 47			dw .UPPER            
46e1 06				db 5 + 1 
46e2 .. 00			db "STYPE",0              
46e8				endm 
# End of macro CWHEAD
46e8			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
46e8			; | | 's' string or 'i' integer or 'c' const 
46e8					if DEBUG_FORTH_WORDS_KEY 
46e8						DMARK "STY" 
46e8 f5				push af  
46e9 3a fd 46			ld a, (.dmark)  
46ec 32 62 ee			ld (debug_mark),a  
46ef 3a fe 46			ld a, (.dmark+1)  
46f2 32 63 ee			ld (debug_mark+1),a  
46f5 3a ff 46			ld a, (.dmark+2)  
46f8 32 64 ee			ld (debug_mark+2),a  
46fb 18 03			jr .pastdmark  
46fd ..			.dmark: db "STY"  
4700 f1			.pastdmark: pop af  
4701			endm  
# End of macro DMARK
4701						CALLMONITOR 
4701 cd 6f ee			call debug_vector  
4704				endm  
# End of macro CALLMONITOR
4704					endif 
4704					FORTH_DSP 
4704 cd 94 1c			call macro_forth_dsp 
4707				endm 
# End of macro FORTH_DSP
4707					;v5 FORTH_DSP_VALUE 
4707			 
4707 7e					ld a, (hl) 
4708			 
4708 f5					push af 
4709			 
4709			; Dont destroy TOS		FORTH_DSP_POP 
4709			 
4709 f1					pop af 
470a			 
470a fe 01				cp DS_TYPE_STR 
470c 28 12				jr z, .typestr 
470e fe 04				cp DS_TYPE_CONST 
4710 28 09				jr z, .typeconst 
4712			 
4712 fe 02				cp DS_TYPE_INUM 
4714 28 0f				jr z, .typeinum 
4716			 
4716 21 39 47				ld hl, .tna 
4719 18 0f				jr .tpush 
471b			 
471b 21 35 47		.typeconst:	ld hl, .tconst 
471e 18 0a				jr .tpush 
4720 21 33 47		.typestr:	ld hl, .tstr 
4723 18 05				jr .tpush 
4725 21 37 47		.typeinum:	ld hl, .tinum 
4728 18 00				jr .tpush 
472a			 
472a			.tpush: 
472a			 
472a cd 3c 1b				call forth_push_str 
472d			 
472d					NEXTW 
472d cd 6c ee			call parse_vector 
4730 c3 b5 1e			jp macro_next 
4733				endm 
# End of macro NEXTW
4733 .. 00		.tstr:	db "s",0 
4735 .. 00		.tconst:	db "c",0 
4737 .. 00		.tinum:  db "i",0 
4739 .. 00		.tna:   db "?", 0 
473b			 
473b			 
473b			.UPPER: 
473b				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
473b 48				db WORD_SYS_CORE+52             
473c 78 47			dw .LOWER            
473e 06				db 5 + 1 
473f .. 00			db "UPPER",0              
4745				endm 
# End of macro CWHEAD
4745			; | UPPER ( s -- s ) Upper case string s  | DONE 
4745					if DEBUG_FORTH_WORDS_KEY 
4745						DMARK "UPR" 
4745 f5				push af  
4746 3a 5a 47			ld a, (.dmark)  
4749 32 62 ee			ld (debug_mark),a  
474c 3a 5b 47			ld a, (.dmark+1)  
474f 32 63 ee			ld (debug_mark+1),a  
4752 3a 5c 47			ld a, (.dmark+2)  
4755 32 64 ee			ld (debug_mark+2),a  
4758 18 03			jr .pastdmark  
475a ..			.dmark: db "UPR"  
475d f1			.pastdmark: pop af  
475e			endm  
# End of macro DMARK
475e						CALLMONITOR 
475e cd 6f ee			call debug_vector  
4761				endm  
# End of macro CALLMONITOR
4761					endif 
4761			 
4761					FORTH_DSP 
4761 cd 94 1c			call macro_forth_dsp 
4764				endm 
# End of macro FORTH_DSP
4764					 
4764			; TODO check is string type 
4764			 
4764					FORTH_DSP_VALUEHL 
4764 cd ce 1c			call macro_dsp_valuehl 
4767				endm 
# End of macro FORTH_DSP_VALUEHL
4767			; get pointer to string in hl 
4767			 
4767 7e			.toup:		ld a, (hl) 
4768			;		cp 0 
4768 b7					or a 
4769 28 07				jr z, .toupdone 
476b			 
476b cd 49 10				call to_upper 
476e			 
476e 77					ld (hl), a 
476f 23					inc hl 
4770 18 f5				jr .toup 
4772			 
4772					 
4772			 
4772			 
4772			; for each char convert to upper 
4772					 
4772			.toupdone: 
4772			 
4772			 
4772					NEXTW 
4772 cd 6c ee			call parse_vector 
4775 c3 b5 1e			jp macro_next 
4778				endm 
# End of macro NEXTW
4778			.LOWER: 
4778				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4778 48				db WORD_SYS_CORE+52             
4779 b5 47			dw .TCASE            
477b 06				db 5 + 1 
477c .. 00			db "LOWER",0              
4782				endm 
# End of macro CWHEAD
4782			; | LOWER ( s -- s ) Lower case string s  | DONE 
4782					if DEBUG_FORTH_WORDS_KEY 
4782						DMARK "LWR" 
4782 f5				push af  
4783 3a 97 47			ld a, (.dmark)  
4786 32 62 ee			ld (debug_mark),a  
4789 3a 98 47			ld a, (.dmark+1)  
478c 32 63 ee			ld (debug_mark+1),a  
478f 3a 99 47			ld a, (.dmark+2)  
4792 32 64 ee			ld (debug_mark+2),a  
4795 18 03			jr .pastdmark  
4797 ..			.dmark: db "LWR"  
479a f1			.pastdmark: pop af  
479b			endm  
# End of macro DMARK
479b						CALLMONITOR 
479b cd 6f ee			call debug_vector  
479e				endm  
# End of macro CALLMONITOR
479e					endif 
479e			 
479e					FORTH_DSP 
479e cd 94 1c			call macro_forth_dsp 
47a1				endm 
# End of macro FORTH_DSP
47a1					 
47a1			; TODO check is string type 
47a1			 
47a1					FORTH_DSP_VALUEHL 
47a1 cd ce 1c			call macro_dsp_valuehl 
47a4				endm 
# End of macro FORTH_DSP_VALUEHL
47a4			; get pointer to string in hl 
47a4			 
47a4 7e			.tolow:		ld a, (hl) 
47a5			;		cp 0 
47a5 b7					or a 
47a6 28 07				jr z, .tolowdone 
47a8			 
47a8 cd 52 10				call to_lower 
47ab			 
47ab 77					ld (hl), a 
47ac 23					inc hl 
47ad 18 f5				jr .tolow 
47af			 
47af					 
47af			 
47af			 
47af			; for each char convert to low 
47af					 
47af			.tolowdone: 
47af					NEXTW 
47af cd 6c ee			call parse_vector 
47b2 c3 b5 1e			jp macro_next 
47b5				endm 
# End of macro NEXTW
47b5			.TCASE: 
47b5				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
47b5 48				db WORD_SYS_CORE+52             
47b6 ec 48			dw .SUBSTR            
47b8 06				db 5 + 1 
47b9 .. 00			db "TCASE",0              
47bf				endm 
# End of macro CWHEAD
47bf			; | TCASE ( s -- s ) Title case string s  | DONE 
47bf					if DEBUG_FORTH_WORDS_KEY 
47bf						DMARK "TCS" 
47bf f5				push af  
47c0 3a d4 47			ld a, (.dmark)  
47c3 32 62 ee			ld (debug_mark),a  
47c6 3a d5 47			ld a, (.dmark+1)  
47c9 32 63 ee			ld (debug_mark+1),a  
47cc 3a d6 47			ld a, (.dmark+2)  
47cf 32 64 ee			ld (debug_mark+2),a  
47d2 18 03			jr .pastdmark  
47d4 ..			.dmark: db "TCS"  
47d7 f1			.pastdmark: pop af  
47d8			endm  
# End of macro DMARK
47d8						CALLMONITOR 
47d8 cd 6f ee			call debug_vector  
47db				endm  
# End of macro CALLMONITOR
47db					endif 
47db			 
47db					FORTH_DSP 
47db cd 94 1c			call macro_forth_dsp 
47de				endm 
# End of macro FORTH_DSP
47de					 
47de			; TODO check is string type 
47de			 
47de					FORTH_DSP_VALUEHL 
47de cd ce 1c			call macro_dsp_valuehl 
47e1				endm 
# End of macro FORTH_DSP_VALUEHL
47e1			; get pointer to string in hl 
47e1			 
47e1					if DEBUG_FORTH_WORDS 
47e1						DMARK "TC1" 
47e1 f5				push af  
47e2 3a f6 47			ld a, (.dmark)  
47e5 32 62 ee			ld (debug_mark),a  
47e8 3a f7 47			ld a, (.dmark+1)  
47eb 32 63 ee			ld (debug_mark+1),a  
47ee 3a f8 47			ld a, (.dmark+2)  
47f1 32 64 ee			ld (debug_mark+2),a  
47f4 18 03			jr .pastdmark  
47f6 ..			.dmark: db "TC1"  
47f9 f1			.pastdmark: pop af  
47fa			endm  
# End of macro DMARK
47fa						CALLMONITOR 
47fa cd 6f ee			call debug_vector  
47fd				endm  
# End of macro CALLMONITOR
47fd					endif 
47fd			 
47fd					; first time in turn to upper case first char 
47fd			 
47fd 7e					ld a, (hl) 
47fe c3 87 48				jp .totsiptou 
4801			 
4801			 
4801 7e			.tot:		ld a, (hl) 
4802			;		cp 0 
4802 b7					or a 
4803 ca ca 48				jp z, .totdone 
4806			 
4806					if DEBUG_FORTH_WORDS 
4806						DMARK "TC2" 
4806 f5				push af  
4807 3a 1b 48			ld a, (.dmark)  
480a 32 62 ee			ld (debug_mark),a  
480d 3a 1c 48			ld a, (.dmark+1)  
4810 32 63 ee			ld (debug_mark+1),a  
4813 3a 1d 48			ld a, (.dmark+2)  
4816 32 64 ee			ld (debug_mark+2),a  
4819 18 03			jr .pastdmark  
481b ..			.dmark: db "TC2"  
481e f1			.pastdmark: pop af  
481f			endm  
# End of macro DMARK
481f						CALLMONITOR 
481f cd 6f ee			call debug_vector  
4822				endm  
# End of macro CALLMONITOR
4822					endif 
4822					; check to see if current char is a space 
4822			 
4822 fe 20				cp ' ' 
4824 28 21				jr z, .totsp 
4826 cd 52 10				call to_lower 
4829					if DEBUG_FORTH_WORDS 
4829						DMARK "TC3" 
4829 f5				push af  
482a 3a 3e 48			ld a, (.dmark)  
482d 32 62 ee			ld (debug_mark),a  
4830 3a 3f 48			ld a, (.dmark+1)  
4833 32 63 ee			ld (debug_mark+1),a  
4836 3a 40 48			ld a, (.dmark+2)  
4839 32 64 ee			ld (debug_mark+2),a  
483c 18 03			jr .pastdmark  
483e ..			.dmark: db "TC3"  
4841 f1			.pastdmark: pop af  
4842			endm  
# End of macro DMARK
4842						CALLMONITOR 
4842 cd 6f ee			call debug_vector  
4845				endm  
# End of macro CALLMONITOR
4845					endif 
4845 18 62				jr .totnxt 
4847			 
4847			.totsp:         ; on a space, find next char which should be upper 
4847			 
4847					if DEBUG_FORTH_WORDS 
4847						DMARK "TC4" 
4847 f5				push af  
4848 3a 5c 48			ld a, (.dmark)  
484b 32 62 ee			ld (debug_mark),a  
484e 3a 5d 48			ld a, (.dmark+1)  
4851 32 63 ee			ld (debug_mark+1),a  
4854 3a 5e 48			ld a, (.dmark+2)  
4857 32 64 ee			ld (debug_mark+2),a  
485a 18 03			jr .pastdmark  
485c ..			.dmark: db "TC4"  
485f f1			.pastdmark: pop af  
4860			endm  
# End of macro DMARK
4860						CALLMONITOR 
4860 cd 6f ee			call debug_vector  
4863				endm  
# End of macro CALLMONITOR
4863					endif 
4863					;; 
4863			 
4863 fe 20				cp ' ' 
4865 20 20				jr nz, .totsiptou 
4867 23					inc hl 
4868 7e					ld a, (hl) 
4869					if DEBUG_FORTH_WORDS 
4869						DMARK "TC5" 
4869 f5				push af  
486a 3a 7e 48			ld a, (.dmark)  
486d 32 62 ee			ld (debug_mark),a  
4870 3a 7f 48			ld a, (.dmark+1)  
4873 32 63 ee			ld (debug_mark+1),a  
4876 3a 80 48			ld a, (.dmark+2)  
4879 32 64 ee			ld (debug_mark+2),a  
487c 18 03			jr .pastdmark  
487e ..			.dmark: db "TC5"  
4881 f1			.pastdmark: pop af  
4882			endm  
# End of macro DMARK
4882						CALLMONITOR 
4882 cd 6f ee			call debug_vector  
4885				endm  
# End of macro CALLMONITOR
4885					endif 
4885 18 c0				jr .totsp 
4887			.totsiptou:     
4887					;cp 0 
4887 b7					or a 
4888 28 40				jr z, .totdone 
488a					; not space and not zero term so upper case it 
488a cd 49 10				call to_upper 
488d			 
488d					if DEBUG_FORTH_WORDS 
488d						DMARK "TC6" 
488d f5				push af  
488e 3a a2 48			ld a, (.dmark)  
4891 32 62 ee			ld (debug_mark),a  
4894 3a a3 48			ld a, (.dmark+1)  
4897 32 63 ee			ld (debug_mark+1),a  
489a 3a a4 48			ld a, (.dmark+2)  
489d 32 64 ee			ld (debug_mark+2),a  
48a0 18 03			jr .pastdmark  
48a2 ..			.dmark: db "TC6"  
48a5 f1			.pastdmark: pop af  
48a6			endm  
# End of macro DMARK
48a6						CALLMONITOR 
48a6 cd 6f ee			call debug_vector  
48a9				endm  
# End of macro CALLMONITOR
48a9					endif 
48a9			 
48a9			 
48a9			.totnxt: 
48a9			 
48a9 77					ld (hl), a 
48aa 23					inc hl 
48ab					if DEBUG_FORTH_WORDS 
48ab						DMARK "TC7" 
48ab f5				push af  
48ac 3a c0 48			ld a, (.dmark)  
48af 32 62 ee			ld (debug_mark),a  
48b2 3a c1 48			ld a, (.dmark+1)  
48b5 32 63 ee			ld (debug_mark+1),a  
48b8 3a c2 48			ld a, (.dmark+2)  
48bb 32 64 ee			ld (debug_mark+2),a  
48be 18 03			jr .pastdmark  
48c0 ..			.dmark: db "TC7"  
48c3 f1			.pastdmark: pop af  
48c4			endm  
# End of macro DMARK
48c4						CALLMONITOR 
48c4 cd 6f ee			call debug_vector  
48c7				endm  
# End of macro CALLMONITOR
48c7					endif 
48c7 c3 01 48				jp .tot 
48ca			 
48ca					 
48ca			 
48ca			 
48ca			; for each char convert to low 
48ca					 
48ca			.totdone: 
48ca					if DEBUG_FORTH_WORDS 
48ca						DMARK "TCd" 
48ca f5				push af  
48cb 3a df 48			ld a, (.dmark)  
48ce 32 62 ee			ld (debug_mark),a  
48d1 3a e0 48			ld a, (.dmark+1)  
48d4 32 63 ee			ld (debug_mark+1),a  
48d7 3a e1 48			ld a, (.dmark+2)  
48da 32 64 ee			ld (debug_mark+2),a  
48dd 18 03			jr .pastdmark  
48df ..			.dmark: db "TCd"  
48e2 f1			.pastdmark: pop af  
48e3			endm  
# End of macro DMARK
48e3						CALLMONITOR 
48e3 cd 6f ee			call debug_vector  
48e6				endm  
# End of macro CALLMONITOR
48e6					endif 
48e6					NEXTW 
48e6 cd 6c ee			call parse_vector 
48e9 c3 b5 1e			jp macro_next 
48ec				endm 
# End of macro NEXTW
48ec			 
48ec			.SUBSTR: 
48ec				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
48ec 48				db WORD_SYS_CORE+52             
48ed 4c 49			dw .LEFT            
48ef 07				db 6 + 1 
48f0 .. 00			db "SUBSTR",0              
48f7				endm 
# End of macro CWHEAD
48f7			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
48f7			 
48f7					if DEBUG_FORTH_WORDS_KEY 
48f7						DMARK "SST" 
48f7 f5				push af  
48f8 3a 0c 49			ld a, (.dmark)  
48fb 32 62 ee			ld (debug_mark),a  
48fe 3a 0d 49			ld a, (.dmark+1)  
4901 32 63 ee			ld (debug_mark+1),a  
4904 3a 0e 49			ld a, (.dmark+2)  
4907 32 64 ee			ld (debug_mark+2),a  
490a 18 03			jr .pastdmark  
490c ..			.dmark: db "SST"  
490f f1			.pastdmark: pop af  
4910			endm  
# End of macro DMARK
4910						CALLMONITOR 
4910 cd 6f ee			call debug_vector  
4913				endm  
# End of macro CALLMONITOR
4913					endif 
4913			; TODO check string type 
4913					FORTH_DSP_VALUEHL 
4913 cd ce 1c			call macro_dsp_valuehl 
4916				endm 
# End of macro FORTH_DSP_VALUEHL
4916			 
4916 e5					push hl      ; string length 
4917			 
4917					FORTH_DSP_POP 
4917 cd 86 1d			call macro_forth_dsp_pop 
491a				endm 
# End of macro FORTH_DSP_POP
491a			 
491a					FORTH_DSP_VALUEHL 
491a cd ce 1c			call macro_dsp_valuehl 
491d				endm 
# End of macro FORTH_DSP_VALUEHL
491d			 
491d e5					push hl     ; start char 
491e			 
491e					FORTH_DSP_POP 
491e cd 86 1d			call macro_forth_dsp_pop 
4921				endm 
# End of macro FORTH_DSP_POP
4921			 
4921			 
4921					FORTH_DSP_VALUE 
4921 cd b7 1c			call macro_forth_dsp_value 
4924				endm 
# End of macro FORTH_DSP_VALUE
4924			 
4924 d1					pop de    ; get start post offset 
4925			 
4925 19					add hl, de    ; starting offset 
4926			 
4926 c1					pop bc 
4927 c5					push bc      ; grab size of string 
4928			 
4928 e5					push hl    ; save string start  
4929			 
4929 26 00				ld h, 0 
492b 69					ld l, c 
492c 23					inc hl 
492d 23					inc hl 
492e			 
492e cd ad 11				call malloc 
4931				if DEBUG_FORTH_MALLOC_GUARD 
4931 cc 23 54				call z,malloc_error 
4934				endif 
4934			 
4934 eb					ex de, hl      ; save malloc area for string copy 
4935 e1					pop hl    ; get back source 
4936 c1					pop bc    ; get length of string back 
4937			 
4937 d5					push de    ; save malloc area for after we push 
4938 ed b0				ldir     ; copy substr 
493a			 
493a			 
493a eb					ex de, hl 
493b			;		ld a, 0 
493b 36 00				ld (hl), 0   ; term substr 
493d			 
493d					 
493d e1					pop hl    ; get malloc so we can push it 
493e e5					push hl   ; save so we can free it afterwards 
493f			 
493f cd 3c 1b				call forth_push_str 
4942			 
4942 e1					pop hl 
4943 cd 77 12				call free 
4946			 
4946					 
4946					 
4946			 
4946			 
4946					NEXTW 
4946 cd 6c ee			call parse_vector 
4949 c3 b5 1e			jp macro_next 
494c				endm 
# End of macro NEXTW
494c			 
494c			.LEFT: 
494c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
494c 48				db WORD_SYS_CORE+52             
494d 90 49			dw .RIGHT            
494f 05				db 4 + 1 
4950 .. 00			db "LEFT",0              
4955				endm 
# End of macro CWHEAD
4955			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4955					if DEBUG_FORTH_WORDS_KEY 
4955						DMARK "LEF" 
4955 f5				push af  
4956 3a 6a 49			ld a, (.dmark)  
4959 32 62 ee			ld (debug_mark),a  
495c 3a 6b 49			ld a, (.dmark+1)  
495f 32 63 ee			ld (debug_mark+1),a  
4962 3a 6c 49			ld a, (.dmark+2)  
4965 32 64 ee			ld (debug_mark+2),a  
4968 18 03			jr .pastdmark  
496a ..			.dmark: db "LEF"  
496d f1			.pastdmark: pop af  
496e			endm  
# End of macro DMARK
496e						CALLMONITOR 
496e cd 6f ee			call debug_vector  
4971				endm  
# End of macro CALLMONITOR
4971					endif 
4971			 
4971					 
4971			; TODO check string type 
4971					FORTH_DSP_VALUEHL 
4971 cd ce 1c			call macro_dsp_valuehl 
4974				endm 
# End of macro FORTH_DSP_VALUEHL
4974			 
4974 e5					push hl      ; string length 
4975			 
4975					FORTH_DSP_POP 
4975 cd 86 1d			call macro_forth_dsp_pop 
4978				endm 
# End of macro FORTH_DSP_POP
4978			 
4978					FORTH_DSP_VALUEHL 
4978 cd ce 1c			call macro_dsp_valuehl 
497b				endm 
# End of macro FORTH_DSP_VALUEHL
497b			 
497b c1					pop bc 
497c			 
497c 11 b8 e2				ld de, scratch 
497f ed b0				ldir 
4981 3e 00				ld a, 0 
4983 12					ld (de), a 
4984					 
4984 21 b8 e2				ld hl, scratch 
4987 cd 3c 1b				call forth_push_str 
498a			 
498a					NEXTW 
498a cd 6c ee			call parse_vector 
498d c3 b5 1e			jp macro_next 
4990				endm 
# End of macro NEXTW
4990			.RIGHT: 
4990				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4990 48				db WORD_SYS_CORE+52             
4991 51 4a			dw .STR2NUM            
4993 06				db 5 + 1 
4994 .. 00			db "RIGHT",0              
499a				endm 
# End of macro CWHEAD
499a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
499a					if DEBUG_FORTH_WORDS_KEY 
499a						DMARK "RIG" 
499a f5				push af  
499b 3a af 49			ld a, (.dmark)  
499e 32 62 ee			ld (debug_mark),a  
49a1 3a b0 49			ld a, (.dmark+1)  
49a4 32 63 ee			ld (debug_mark+1),a  
49a7 3a b1 49			ld a, (.dmark+2)  
49aa 32 64 ee			ld (debug_mark+2),a  
49ad 18 03			jr .pastdmark  
49af ..			.dmark: db "RIG"  
49b2 f1			.pastdmark: pop af  
49b3			endm  
# End of macro DMARK
49b3						CALLMONITOR 
49b3 cd 6f ee			call debug_vector  
49b6				endm  
# End of macro CALLMONITOR
49b6					endif 
49b6			 
49b6			; TODO check string type 
49b6					FORTH_DSP_VALUEHL 
49b6 cd ce 1c			call macro_dsp_valuehl 
49b9				endm 
# End of macro FORTH_DSP_VALUEHL
49b9			 
49b9 e5					push hl      ; string length 
49ba			 
49ba					FORTH_DSP_POP 
49ba cd 86 1d			call macro_forth_dsp_pop 
49bd				endm 
# End of macro FORTH_DSP_POP
49bd			 
49bd					FORTH_DSP_VALUEHL 
49bd cd ce 1c			call macro_dsp_valuehl 
49c0				endm 
# End of macro FORTH_DSP_VALUEHL
49c0			 
49c0					if DEBUG_FORTH_WORDS 
49c0						DMARK "RI1" 
49c0 f5				push af  
49c1 3a d5 49			ld a, (.dmark)  
49c4 32 62 ee			ld (debug_mark),a  
49c7 3a d6 49			ld a, (.dmark+1)  
49ca 32 63 ee			ld (debug_mark+1),a  
49cd 3a d7 49			ld a, (.dmark+2)  
49d0 32 64 ee			ld (debug_mark+2),a  
49d3 18 03			jr .pastdmark  
49d5 ..			.dmark: db "RI1"  
49d8 f1			.pastdmark: pop af  
49d9			endm  
# End of macro DMARK
49d9						CALLMONITOR 
49d9 cd 6f ee			call debug_vector  
49dc				endm  
# End of macro CALLMONITOR
49dc					endif 
49dc					; from the pointer to string get to the end of string 
49dc			 
49dc 01 ff 00				ld bc, 255 
49df 3e 00				ld a, 0 
49e1 ed b1				cpir 
49e3 2b					dec hl 
49e4			 
49e4					;  
49e4			 
49e4					if DEBUG_FORTH_WORDS 
49e4						DMARK "RI2" 
49e4 f5				push af  
49e5 3a f9 49			ld a, (.dmark)  
49e8 32 62 ee			ld (debug_mark),a  
49eb 3a fa 49			ld a, (.dmark+1)  
49ee 32 63 ee			ld (debug_mark+1),a  
49f1 3a fb 49			ld a, (.dmark+2)  
49f4 32 64 ee			ld (debug_mark+2),a  
49f7 18 03			jr .pastdmark  
49f9 ..			.dmark: db "RI2"  
49fc f1			.pastdmark: pop af  
49fd			endm  
# End of macro DMARK
49fd						CALLMONITOR 
49fd cd 6f ee			call debug_vector  
4a00				endm  
# End of macro CALLMONITOR
4a00					endif 
4a00			 
4a00 c1					pop bc    ;  length of string to copy 
4a01			 
4a01 79					ld a, c 
4a02 eb					ex de, hl 
4a03 21 b8 e2				ld hl, scratch  
4a06 cd e1 0d				call addatohl 
4a09			 
4a09 eb					ex de, hl 
4a0a			 
4a0a					if DEBUG_FORTH_WORDS 
4a0a						DMARK "RI3" 
4a0a f5				push af  
4a0b 3a 1f 4a			ld a, (.dmark)  
4a0e 32 62 ee			ld (debug_mark),a  
4a11 3a 20 4a			ld a, (.dmark+1)  
4a14 32 63 ee			ld (debug_mark+1),a  
4a17 3a 21 4a			ld a, (.dmark+2)  
4a1a 32 64 ee			ld (debug_mark+2),a  
4a1d 18 03			jr .pastdmark  
4a1f ..			.dmark: db "RI3"  
4a22 f1			.pastdmark: pop af  
4a23			endm  
# End of macro DMARK
4a23						CALLMONITOR 
4a23 cd 6f ee			call debug_vector  
4a26				endm  
# End of macro CALLMONITOR
4a26					endif 
4a26			 
4a26 03					inc bc 
4a27 ed b8				lddr 
4a29					 
4a29 21 b8 e2				ld hl, scratch 
4a2c					if DEBUG_FORTH_WORDS 
4a2c						DMARK "RI4" 
4a2c f5				push af  
4a2d 3a 41 4a			ld a, (.dmark)  
4a30 32 62 ee			ld (debug_mark),a  
4a33 3a 42 4a			ld a, (.dmark+1)  
4a36 32 63 ee			ld (debug_mark+1),a  
4a39 3a 43 4a			ld a, (.dmark+2)  
4a3c 32 64 ee			ld (debug_mark+2),a  
4a3f 18 03			jr .pastdmark  
4a41 ..			.dmark: db "RI4"  
4a44 f1			.pastdmark: pop af  
4a45			endm  
# End of macro DMARK
4a45						CALLMONITOR 
4a45 cd 6f ee			call debug_vector  
4a48				endm  
# End of macro CALLMONITOR
4a48					endif 
4a48 cd 3c 1b				call forth_push_str 
4a4b			 
4a4b			 
4a4b					NEXTW 
4a4b cd 6c ee			call parse_vector 
4a4e c3 b5 1e			jp macro_next 
4a51				endm 
# End of macro NEXTW
4a51			 
4a51			 
4a51			.STR2NUM: 
4a51				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4a51 48				db WORD_SYS_CORE+52             
4a52 e0 4a			dw .NUM2STR            
4a54 08				db 7 + 1 
4a55 .. 00			db "STR2NUM",0              
4a5d				endm 
# End of macro CWHEAD
4a5d			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4a5d			 
4a5d			 
4a5d			; TODO STR type check to do 
4a5d					if DEBUG_FORTH_WORDS_KEY 
4a5d						DMARK "S2N" 
4a5d f5				push af  
4a5e 3a 72 4a			ld a, (.dmark)  
4a61 32 62 ee			ld (debug_mark),a  
4a64 3a 73 4a			ld a, (.dmark+1)  
4a67 32 63 ee			ld (debug_mark+1),a  
4a6a 3a 74 4a			ld a, (.dmark+2)  
4a6d 32 64 ee			ld (debug_mark+2),a  
4a70 18 03			jr .pastdmark  
4a72 ..			.dmark: db "S2N"  
4a75 f1			.pastdmark: pop af  
4a76			endm  
# End of macro DMARK
4a76						CALLMONITOR 
4a76 cd 6f ee			call debug_vector  
4a79				endm  
# End of macro CALLMONITOR
4a79					endif 
4a79			 
4a79					;FORTH_DSP 
4a79					FORTH_DSP_VALUE 
4a79 cd b7 1c			call macro_forth_dsp_value 
4a7c				endm 
# End of macro FORTH_DSP_VALUE
4a7c					;inc hl 
4a7c			 
4a7c eb					ex de, hl 
4a7d					if DEBUG_FORTH_WORDS 
4a7d						DMARK "S2a" 
4a7d f5				push af  
4a7e 3a 92 4a			ld a, (.dmark)  
4a81 32 62 ee			ld (debug_mark),a  
4a84 3a 93 4a			ld a, (.dmark+1)  
4a87 32 63 ee			ld (debug_mark+1),a  
4a8a 3a 94 4a			ld a, (.dmark+2)  
4a8d 32 64 ee			ld (debug_mark+2),a  
4a90 18 03			jr .pastdmark  
4a92 ..			.dmark: db "S2a"  
4a95 f1			.pastdmark: pop af  
4a96			endm  
# End of macro DMARK
4a96						CALLMONITOR 
4a96 cd 6f ee			call debug_vector  
4a99				endm  
# End of macro CALLMONITOR
4a99					endif 
4a99 cd d0 10				call string_to_uint16 
4a9c			 
4a9c					if DEBUG_FORTH_WORDS 
4a9c						DMARK "S2b" 
4a9c f5				push af  
4a9d 3a b1 4a			ld a, (.dmark)  
4aa0 32 62 ee			ld (debug_mark),a  
4aa3 3a b2 4a			ld a, (.dmark+1)  
4aa6 32 63 ee			ld (debug_mark+1),a  
4aa9 3a b3 4a			ld a, (.dmark+2)  
4aac 32 64 ee			ld (debug_mark+2),a  
4aaf 18 03			jr .pastdmark  
4ab1 ..			.dmark: db "S2b"  
4ab4 f1			.pastdmark: pop af  
4ab5			endm  
# End of macro DMARK
4ab5						CALLMONITOR 
4ab5 cd 6f ee			call debug_vector  
4ab8				endm  
# End of macro CALLMONITOR
4ab8					endif 
4ab8			;		push hl 
4ab8					FORTH_DSP_POP 
4ab8 cd 86 1d			call macro_forth_dsp_pop 
4abb				endm 
# End of macro FORTH_DSP_POP
4abb			;		pop hl 
4abb					 
4abb					if DEBUG_FORTH_WORDS 
4abb						DMARK "S2b" 
4abb f5				push af  
4abc 3a d0 4a			ld a, (.dmark)  
4abf 32 62 ee			ld (debug_mark),a  
4ac2 3a d1 4a			ld a, (.dmark+1)  
4ac5 32 63 ee			ld (debug_mark+1),a  
4ac8 3a d2 4a			ld a, (.dmark+2)  
4acb 32 64 ee			ld (debug_mark+2),a  
4ace 18 03			jr .pastdmark  
4ad0 ..			.dmark: db "S2b"  
4ad3 f1			.pastdmark: pop af  
4ad4			endm  
# End of macro DMARK
4ad4						CALLMONITOR 
4ad4 cd 6f ee			call debug_vector  
4ad7				endm  
# End of macro CALLMONITOR
4ad7					endif 
4ad7 cd d2 1a				call forth_push_numhl	 
4ada			 
4ada				 
4ada				       NEXTW 
4ada cd 6c ee			call parse_vector 
4add c3 b5 1e			jp macro_next 
4ae0				endm 
# End of macro NEXTW
4ae0			.NUM2STR: 
4ae0				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4ae0 48				db WORD_SYS_CORE+52             
4ae1 75 4b			dw .CONCAT            
4ae3 08				db 7 + 1 
4ae4 .. 00			db "NUM2STR",0              
4aec				endm 
# End of macro CWHEAD
4aec			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4aec			 
4aec			;		; malloc a string to target 
4aec			;		ld hl, 10     ; TODO max string size should be fine 
4aec			;		call malloc 
4aec			;		push hl    ; save malloc location 
4aec			; 
4aec			; 
4aec			;; TODO check int type 
4aec					if DEBUG_FORTH_WORDS_KEY 
4aec						DMARK "N2S" 
4aec f5				push af  
4aed 3a 01 4b			ld a, (.dmark)  
4af0 32 62 ee			ld (debug_mark),a  
4af3 3a 02 4b			ld a, (.dmark+1)  
4af6 32 63 ee			ld (debug_mark+1),a  
4af9 3a 03 4b			ld a, (.dmark+2)  
4afc 32 64 ee			ld (debug_mark+2),a  
4aff 18 03			jr .pastdmark  
4b01 ..			.dmark: db "N2S"  
4b04 f1			.pastdmark: pop af  
4b05			endm  
# End of macro DMARK
4b05						CALLMONITOR 
4b05 cd 6f ee			call debug_vector  
4b08				endm  
# End of macro CALLMONITOR
4b08					endif 
4b08			 
4b08					FORTH_DSP_VALUEHL 
4b08 cd ce 1c			call macro_dsp_valuehl 
4b0b				endm 
# End of macro FORTH_DSP_VALUEHL
4b0b			 
4b0b					if DEBUG_FORTH_WORDS 
4b0b						DMARK "NS1" 
4b0b f5				push af  
4b0c 3a 20 4b			ld a, (.dmark)  
4b0f 32 62 ee			ld (debug_mark),a  
4b12 3a 21 4b			ld a, (.dmark+1)  
4b15 32 63 ee			ld (debug_mark+1),a  
4b18 3a 22 4b			ld a, (.dmark+2)  
4b1b 32 64 ee			ld (debug_mark+2),a  
4b1e 18 03			jr .pastdmark  
4b20 ..			.dmark: db "NS1"  
4b23 f1			.pastdmark: pop af  
4b24			endm  
# End of macro DMARK
4b24						CALLMONITOR 
4b24 cd 6f ee			call debug_vector  
4b27				endm  
# End of macro CALLMONITOR
4b27					endif 
4b27					FORTH_DSP_POP 
4b27 cd 86 1d			call macro_forth_dsp_pop 
4b2a				endm 
# End of macro FORTH_DSP_POP
4b2a			 
4b2a eb					ex de, hl 
4b2b 21 b8 e2				ld hl, scratch 
4b2e					if DEBUG_FORTH_WORDS 
4b2e						DMARK "NS2" 
4b2e f5				push af  
4b2f 3a 43 4b			ld a, (.dmark)  
4b32 32 62 ee			ld (debug_mark),a  
4b35 3a 44 4b			ld a, (.dmark+1)  
4b38 32 63 ee			ld (debug_mark+1),a  
4b3b 3a 45 4b			ld a, (.dmark+2)  
4b3e 32 64 ee			ld (debug_mark+2),a  
4b41 18 03			jr .pastdmark  
4b43 ..			.dmark: db "NS2"  
4b46 f1			.pastdmark: pop af  
4b47			endm  
# End of macro DMARK
4b47						CALLMONITOR 
4b47 cd 6f ee			call debug_vector  
4b4a				endm  
# End of macro CALLMONITOR
4b4a					endif 
4b4a cd e8 10				call uitoa_16 
4b4d 21 b8 e2				ld hl, scratch 
4b50					if DEBUG_FORTH_WORDS 
4b50						DMARK "NS3" 
4b50 f5				push af  
4b51 3a 65 4b			ld a, (.dmark)  
4b54 32 62 ee			ld (debug_mark),a  
4b57 3a 66 4b			ld a, (.dmark+1)  
4b5a 32 63 ee			ld (debug_mark+1),a  
4b5d 3a 67 4b			ld a, (.dmark+2)  
4b60 32 64 ee			ld (debug_mark+2),a  
4b63 18 03			jr .pastdmark  
4b65 ..			.dmark: db "NS3"  
4b68 f1			.pastdmark: pop af  
4b69			endm  
# End of macro DMARK
4b69						CALLMONITOR 
4b69 cd 6f ee			call debug_vector  
4b6c				endm  
# End of macro CALLMONITOR
4b6c					endif 
4b6c cd 3c 1b				call forth_push_str 
4b6f			;		ld a, l 
4b6f			;		call DispAToASCII   
4b6f			;;TODO need to chage above call to dump into string 
4b6f			; 
4b6f			; 
4b6f			 
4b6f				       NEXTW 
4b6f cd 6c ee			call parse_vector 
4b72 c3 b5 1e			jp macro_next 
4b75				endm 
# End of macro NEXTW
4b75			 
4b75			.CONCAT: 
4b75				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4b75 48				db WORD_SYS_CORE+52             
4b76 2b 4c			dw .FIND            
4b78 07				db 6 + 1 
4b79 .. 00			db "CONCAT",0              
4b80				endm 
# End of macro CWHEAD
4b80			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4b80			 
4b80			; TODO check string type 
4b80			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4b80			 
4b80					if DEBUG_FORTH_WORDS_KEY 
4b80						DMARK "CON" 
4b80 f5				push af  
4b81 3a 95 4b			ld a, (.dmark)  
4b84 32 62 ee			ld (debug_mark),a  
4b87 3a 96 4b			ld a, (.dmark+1)  
4b8a 32 63 ee			ld (debug_mark+1),a  
4b8d 3a 97 4b			ld a, (.dmark+2)  
4b90 32 64 ee			ld (debug_mark+2),a  
4b93 18 03			jr .pastdmark  
4b95 ..			.dmark: db "CON"  
4b98 f1			.pastdmark: pop af  
4b99			endm  
# End of macro DMARK
4b99						CALLMONITOR 
4b99 cd 6f ee			call debug_vector  
4b9c				endm  
# End of macro CALLMONITOR
4b9c					endif 
4b9c			 
4b9c			 
4b9c					FORTH_DSP_VALUE 
4b9c cd b7 1c			call macro_forth_dsp_value 
4b9f				endm 
# End of macro FORTH_DSP_VALUE
4b9f e5					push hl   ; s2 
4ba0			 
4ba0					FORTH_DSP_POP 
4ba0 cd 86 1d			call macro_forth_dsp_pop 
4ba3				endm 
# End of macro FORTH_DSP_POP
4ba3			 
4ba3					FORTH_DSP_VALUE 
4ba3 cd b7 1c			call macro_forth_dsp_value 
4ba6				endm 
# End of macro FORTH_DSP_VALUE
4ba6			 
4ba6 e5					push hl   ; s1 
4ba7			 
4ba7					FORTH_DSP_POP 
4ba7 cd 86 1d			call macro_forth_dsp_pop 
4baa				endm 
# End of macro FORTH_DSP_POP
4baa					 
4baa			 
4baa					; copy s1 
4baa			 
4baa				 
4baa					; save ptr 
4baa e1					pop hl  
4bab e5					push hl 
4bac 3e 00				ld a, 0 
4bae cd 44 11				call strlent 
4bb1					;inc hl    ; zer0 
4bb1 06 00				ld b, 0 
4bb3 4d					ld c, l 
4bb4 e1					pop hl		 
4bb5 11 b8 e2				ld de, scratch	 
4bb8					if DEBUG_FORTH_WORDS 
4bb8						DMARK "CO1" 
4bb8 f5				push af  
4bb9 3a cd 4b			ld a, (.dmark)  
4bbc 32 62 ee			ld (debug_mark),a  
4bbf 3a ce 4b			ld a, (.dmark+1)  
4bc2 32 63 ee			ld (debug_mark+1),a  
4bc5 3a cf 4b			ld a, (.dmark+2)  
4bc8 32 64 ee			ld (debug_mark+2),a  
4bcb 18 03			jr .pastdmark  
4bcd ..			.dmark: db "CO1"  
4bd0 f1			.pastdmark: pop af  
4bd1			endm  
# End of macro DMARK
4bd1						CALLMONITOR 
4bd1 cd 6f ee			call debug_vector  
4bd4				endm  
# End of macro CALLMONITOR
4bd4					endif 
4bd4 ed b0				ldir 
4bd6			 
4bd6 e1					pop hl 
4bd7 e5					push hl 
4bd8 d5					push de 
4bd9			 
4bd9			 
4bd9 3e 00				ld a, 0 
4bdb cd 44 11				call strlent 
4bde 23					inc hl    ; zer0 
4bdf 23					inc hl 
4be0 06 00				ld b, 0 
4be2 4d					ld c, l 
4be3 d1					pop de 
4be4 e1					pop hl		 
4be5					if DEBUG_FORTH_WORDS 
4be5						DMARK "CO2" 
4be5 f5				push af  
4be6 3a fa 4b			ld a, (.dmark)  
4be9 32 62 ee			ld (debug_mark),a  
4bec 3a fb 4b			ld a, (.dmark+1)  
4bef 32 63 ee			ld (debug_mark+1),a  
4bf2 3a fc 4b			ld a, (.dmark+2)  
4bf5 32 64 ee			ld (debug_mark+2),a  
4bf8 18 03			jr .pastdmark  
4bfa ..			.dmark: db "CO2"  
4bfd f1			.pastdmark: pop af  
4bfe			endm  
# End of macro DMARK
4bfe						CALLMONITOR 
4bfe cd 6f ee			call debug_vector  
4c01				endm  
# End of macro CALLMONITOR
4c01					endif 
4c01 ed b0				ldir 
4c03			 
4c03			 
4c03			 
4c03 21 b8 e2				ld hl, scratch 
4c06					if DEBUG_FORTH_WORDS 
4c06						DMARK "CO5" 
4c06 f5				push af  
4c07 3a 1b 4c			ld a, (.dmark)  
4c0a 32 62 ee			ld (debug_mark),a  
4c0d 3a 1c 4c			ld a, (.dmark+1)  
4c10 32 63 ee			ld (debug_mark+1),a  
4c13 3a 1d 4c			ld a, (.dmark+2)  
4c16 32 64 ee			ld (debug_mark+2),a  
4c19 18 03			jr .pastdmark  
4c1b ..			.dmark: db "CO5"  
4c1e f1			.pastdmark: pop af  
4c1f			endm  
# End of macro DMARK
4c1f						CALLMONITOR 
4c1f cd 6f ee			call debug_vector  
4c22				endm  
# End of macro CALLMONITOR
4c22					endif 
4c22			 
4c22 cd 3c 1b				call forth_push_str 
4c25			 
4c25			 
4c25			 
4c25			 
4c25				       NEXTW 
4c25 cd 6c ee			call parse_vector 
4c28 c3 b5 1e			jp macro_next 
4c2b				endm 
# End of macro NEXTW
4c2b			 
4c2b			 
4c2b			.FIND: 
4c2b				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4c2b 4b				db WORD_SYS_CORE+55             
4c2c eb 4c			dw .LEN            
4c2e 05				db 4 + 1 
4c2f .. 00			db "FIND",0              
4c34				endm 
# End of macro CWHEAD
4c34			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4c34			 
4c34					if DEBUG_FORTH_WORDS_KEY 
4c34						DMARK "FND" 
4c34 f5				push af  
4c35 3a 49 4c			ld a, (.dmark)  
4c38 32 62 ee			ld (debug_mark),a  
4c3b 3a 4a 4c			ld a, (.dmark+1)  
4c3e 32 63 ee			ld (debug_mark+1),a  
4c41 3a 4b 4c			ld a, (.dmark+2)  
4c44 32 64 ee			ld (debug_mark+2),a  
4c47 18 03			jr .pastdmark  
4c49 ..			.dmark: db "FND"  
4c4c f1			.pastdmark: pop af  
4c4d			endm  
# End of macro DMARK
4c4d						CALLMONITOR 
4c4d cd 6f ee			call debug_vector  
4c50				endm  
# End of macro CALLMONITOR
4c50					endif 
4c50			 
4c50			; TODO check string type 
4c50					FORTH_DSP_VALUE 
4c50 cd b7 1c			call macro_forth_dsp_value 
4c53				endm 
# End of macro FORTH_DSP_VALUE
4c53			 
4c53 e5					push hl    
4c54 7e					ld a,(hl)    ; char to find   
4c55			; TODO change char to substr 
4c55			 
4c55 f5					push af 
4c56					 
4c56			 
4c56			 
4c56					if DEBUG_FORTH_WORDS 
4c56						DMARK "FN1" 
4c56 f5				push af  
4c57 3a 6b 4c			ld a, (.dmark)  
4c5a 32 62 ee			ld (debug_mark),a  
4c5d 3a 6c 4c			ld a, (.dmark+1)  
4c60 32 63 ee			ld (debug_mark+1),a  
4c63 3a 6d 4c			ld a, (.dmark+2)  
4c66 32 64 ee			ld (debug_mark+2),a  
4c69 18 03			jr .pastdmark  
4c6b ..			.dmark: db "FN1"  
4c6e f1			.pastdmark: pop af  
4c6f			endm  
# End of macro DMARK
4c6f						CALLMONITOR 
4c6f cd 6f ee			call debug_vector  
4c72				endm  
# End of macro CALLMONITOR
4c72					endif 
4c72			 
4c72					FORTH_DSP_POP 
4c72 cd 86 1d			call macro_forth_dsp_pop 
4c75				endm 
# End of macro FORTH_DSP_POP
4c75			 
4c75					; string to search 
4c75			 
4c75					FORTH_DSP_VALUE 
4c75 cd b7 1c			call macro_forth_dsp_value 
4c78				endm 
# End of macro FORTH_DSP_VALUE
4c78			 
4c78 d1					pop de  ; d is char to find  
4c79			 
4c79					if DEBUG_FORTH_WORDS 
4c79						DMARK "FN2" 
4c79 f5				push af  
4c7a 3a 8e 4c			ld a, (.dmark)  
4c7d 32 62 ee			ld (debug_mark),a  
4c80 3a 8f 4c			ld a, (.dmark+1)  
4c83 32 63 ee			ld (debug_mark+1),a  
4c86 3a 90 4c			ld a, (.dmark+2)  
4c89 32 64 ee			ld (debug_mark+2),a  
4c8c 18 03			jr .pastdmark  
4c8e ..			.dmark: db "FN2"  
4c91 f1			.pastdmark: pop af  
4c92			endm  
# End of macro DMARK
4c92						CALLMONITOR 
4c92 cd 6f ee			call debug_vector  
4c95				endm  
# End of macro CALLMONITOR
4c95					endif 
4c95					 
4c95 01 00 00				ld bc, 0 
4c98 7e			.findchar:      ld a,(hl) 
4c99			;		cp 0   		 
4c99 b7					or a 
4c9a 28 27				jr z, .finddone     
4c9c ba					cp d 
4c9d 28 20				jr z, .foundchar 
4c9f 03					inc bc 
4ca0 23					inc hl 
4ca1					if DEBUG_FORTH_WORDS 
4ca1						DMARK "FN3" 
4ca1 f5				push af  
4ca2 3a b6 4c			ld a, (.dmark)  
4ca5 32 62 ee			ld (debug_mark),a  
4ca8 3a b7 4c			ld a, (.dmark+1)  
4cab 32 63 ee			ld (debug_mark+1),a  
4cae 3a b8 4c			ld a, (.dmark+2)  
4cb1 32 64 ee			ld (debug_mark+2),a  
4cb4 18 03			jr .pastdmark  
4cb6 ..			.dmark: db "FN3"  
4cb9 f1			.pastdmark: pop af  
4cba			endm  
# End of macro DMARK
4cba						CALLMONITOR 
4cba cd 6f ee			call debug_vector  
4cbd				endm  
# End of macro CALLMONITOR
4cbd					endif 
4cbd 18 d9				jr .findchar 
4cbf			 
4cbf			 
4cbf c5			.foundchar:	push bc 
4cc0 e1					pop hl 
4cc1 18 03				jr .findexit 
4cc3			 
4cc3			 
4cc3							 
4cc3			 
4cc3			.finddone:     ; got to end of string with no find 
4cc3 21 00 00				ld hl, 0 
4cc6			.findexit: 
4cc6			 
4cc6					if DEBUG_FORTH_WORDS 
4cc6						DMARK "FNd" 
4cc6 f5				push af  
4cc7 3a db 4c			ld a, (.dmark)  
4cca 32 62 ee			ld (debug_mark),a  
4ccd 3a dc 4c			ld a, (.dmark+1)  
4cd0 32 63 ee			ld (debug_mark+1),a  
4cd3 3a dd 4c			ld a, (.dmark+2)  
4cd6 32 64 ee			ld (debug_mark+2),a  
4cd9 18 03			jr .pastdmark  
4cdb ..			.dmark: db "FNd"  
4cde f1			.pastdmark: pop af  
4cdf			endm  
# End of macro DMARK
4cdf						CALLMONITOR 
4cdf cd 6f ee			call debug_vector  
4ce2				endm  
# End of macro CALLMONITOR
4ce2					endif 
4ce2 cd d2 1a			call forth_push_numhl 
4ce5			 
4ce5				       NEXTW 
4ce5 cd 6c ee			call parse_vector 
4ce8 c3 b5 1e			jp macro_next 
4ceb				endm 
# End of macro NEXTW
4ceb			 
4ceb			.LEN: 
4ceb				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4ceb 4c				db WORD_SYS_CORE+56             
4cec 58 4d			dw .ASC            
4cee 06				db 5 + 1 
4cef .. 00			db "COUNT",0              
4cf5				endm 
# End of macro CWHEAD
4cf5			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4cf5			 
4cf5					if DEBUG_FORTH_WORDS_KEY 
4cf5						DMARK "CNT" 
4cf5 f5				push af  
4cf6 3a 0a 4d			ld a, (.dmark)  
4cf9 32 62 ee			ld (debug_mark),a  
4cfc 3a 0b 4d			ld a, (.dmark+1)  
4cff 32 63 ee			ld (debug_mark+1),a  
4d02 3a 0c 4d			ld a, (.dmark+2)  
4d05 32 64 ee			ld (debug_mark+2),a  
4d08 18 03			jr .pastdmark  
4d0a ..			.dmark: db "CNT"  
4d0d f1			.pastdmark: pop af  
4d0e			endm  
# End of macro DMARK
4d0e						CALLMONITOR 
4d0e cd 6f ee			call debug_vector  
4d11				endm  
# End of macro CALLMONITOR
4d11					endif 
4d11			; TODO check string type 
4d11					FORTH_DSP_VALUE 
4d11 cd b7 1c			call macro_forth_dsp_value 
4d14				endm 
# End of macro FORTH_DSP_VALUE
4d14			 
4d14			 
4d14					if DEBUG_FORTH_WORDS 
4d14						DMARK "CN?" 
4d14 f5				push af  
4d15 3a 29 4d			ld a, (.dmark)  
4d18 32 62 ee			ld (debug_mark),a  
4d1b 3a 2a 4d			ld a, (.dmark+1)  
4d1e 32 63 ee			ld (debug_mark+1),a  
4d21 3a 2b 4d			ld a, (.dmark+2)  
4d24 32 64 ee			ld (debug_mark+2),a  
4d27 18 03			jr .pastdmark  
4d29 ..			.dmark: db "CN?"  
4d2c f1			.pastdmark: pop af  
4d2d			endm  
# End of macro DMARK
4d2d						CALLMONITOR 
4d2d cd 6f ee			call debug_vector  
4d30				endm  
# End of macro CALLMONITOR
4d30					endif 
4d30 cd 39 11				call strlenz 
4d33					if DEBUG_FORTH_WORDS 
4d33						DMARK "CNl" 
4d33 f5				push af  
4d34 3a 48 4d			ld a, (.dmark)  
4d37 32 62 ee			ld (debug_mark),a  
4d3a 3a 49 4d			ld a, (.dmark+1)  
4d3d 32 63 ee			ld (debug_mark+1),a  
4d40 3a 4a 4d			ld a, (.dmark+2)  
4d43 32 64 ee			ld (debug_mark+2),a  
4d46 18 03			jr .pastdmark  
4d48 ..			.dmark: db "CNl"  
4d4b f1			.pastdmark: pop af  
4d4c			endm  
# End of macro DMARK
4d4c						CALLMONITOR 
4d4c cd 6f ee			call debug_vector  
4d4f				endm  
# End of macro CALLMONITOR
4d4f					endif 
4d4f			 
4d4f cd d2 1a				call forth_push_numhl 
4d52			 
4d52			 
4d52			 
4d52				       NEXTW 
4d52 cd 6c ee			call parse_vector 
4d55 c3 b5 1e			jp macro_next 
4d58				endm 
# End of macro NEXTW
4d58			.ASC: 
4d58				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4d58 4d				db WORD_SYS_CORE+57             
4d59 c9 4d			dw .CHR            
4d5b 04				db 3 + 1 
4d5c .. 00			db "ASC",0              
4d60				endm 
# End of macro CWHEAD
4d60			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4d60					if DEBUG_FORTH_WORDS_KEY 
4d60						DMARK "ASC" 
4d60 f5				push af  
4d61 3a 75 4d			ld a, (.dmark)  
4d64 32 62 ee			ld (debug_mark),a  
4d67 3a 76 4d			ld a, (.dmark+1)  
4d6a 32 63 ee			ld (debug_mark+1),a  
4d6d 3a 77 4d			ld a, (.dmark+2)  
4d70 32 64 ee			ld (debug_mark+2),a  
4d73 18 03			jr .pastdmark  
4d75 ..			.dmark: db "ASC"  
4d78 f1			.pastdmark: pop af  
4d79			endm  
# End of macro DMARK
4d79						CALLMONITOR 
4d79 cd 6f ee			call debug_vector  
4d7c				endm  
# End of macro CALLMONITOR
4d7c					endif 
4d7c					FORTH_DSP_VALUE 
4d7c cd b7 1c			call macro_forth_dsp_value 
4d7f				endm 
# End of macro FORTH_DSP_VALUE
4d7f					;v5 FORTH_DSP_VALUE 
4d7f			;		inc hl      ; now at start of numeric as string 
4d7f			 
4d7f e5					push hl 
4d80			 
4d80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d80 cd 86 1d			call macro_forth_dsp_pop 
4d83				endm 
# End of macro FORTH_DSP_POP
4d83			 
4d83 e1					pop hl 
4d84			 
4d84					if DEBUG_FORTH_WORDS 
4d84						DMARK "AS1" 
4d84 f5				push af  
4d85 3a 99 4d			ld a, (.dmark)  
4d88 32 62 ee			ld (debug_mark),a  
4d8b 3a 9a 4d			ld a, (.dmark+1)  
4d8e 32 63 ee			ld (debug_mark+1),a  
4d91 3a 9b 4d			ld a, (.dmark+2)  
4d94 32 64 ee			ld (debug_mark+2),a  
4d97 18 03			jr .pastdmark  
4d99 ..			.dmark: db "AS1"  
4d9c f1			.pastdmark: pop af  
4d9d			endm  
# End of macro DMARK
4d9d						CALLMONITOR 
4d9d cd 6f ee			call debug_vector  
4da0				endm  
# End of macro CALLMONITOR
4da0					endif 
4da0					; push the content of a onto the stack as a value 
4da0			 
4da0 7e					ld a,(hl)   ; get char 
4da1 26 00				ld h,0 
4da3 6f					ld l,a 
4da4					if DEBUG_FORTH_WORDS 
4da4						DMARK "AS2" 
4da4 f5				push af  
4da5 3a b9 4d			ld a, (.dmark)  
4da8 32 62 ee			ld (debug_mark),a  
4dab 3a ba 4d			ld a, (.dmark+1)  
4dae 32 63 ee			ld (debug_mark+1),a  
4db1 3a bb 4d			ld a, (.dmark+2)  
4db4 32 64 ee			ld (debug_mark+2),a  
4db7 18 03			jr .pastdmark  
4db9 ..			.dmark: db "AS2"  
4dbc f1			.pastdmark: pop af  
4dbd			endm  
# End of macro DMARK
4dbd						CALLMONITOR 
4dbd cd 6f ee			call debug_vector  
4dc0				endm  
# End of macro CALLMONITOR
4dc0					endif 
4dc0 cd d2 1a				call forth_push_numhl 
4dc3			 
4dc3				       NEXTW 
4dc3 cd 6c ee			call parse_vector 
4dc6 c3 b5 1e			jp macro_next 
4dc9				endm 
# End of macro NEXTW
4dc9			 
4dc9			.CHR: 
4dc9				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4dc9 4d				db WORD_SYS_CORE+57             
4dca 08 4e			dw .ENDSTR            
4dcc 04				db 3 + 1 
4dcd .. 00			db "CHR",0              
4dd1				endm 
# End of macro CWHEAD
4dd1			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4dd1					if DEBUG_FORTH_WORDS_KEY 
4dd1						DMARK "CHR" 
4dd1 f5				push af  
4dd2 3a e6 4d			ld a, (.dmark)  
4dd5 32 62 ee			ld (debug_mark),a  
4dd8 3a e7 4d			ld a, (.dmark+1)  
4ddb 32 63 ee			ld (debug_mark+1),a  
4dde 3a e8 4d			ld a, (.dmark+2)  
4de1 32 64 ee			ld (debug_mark+2),a  
4de4 18 03			jr .pastdmark  
4de6 ..			.dmark: db "CHR"  
4de9 f1			.pastdmark: pop af  
4dea			endm  
# End of macro DMARK
4dea						CALLMONITOR 
4dea cd 6f ee			call debug_vector  
4ded				endm  
# End of macro CALLMONITOR
4ded					endif 
4ded					FORTH_DSP_VALUEHL 
4ded cd ce 1c			call macro_dsp_valuehl 
4df0				endm 
# End of macro FORTH_DSP_VALUEHL
4df0			 
4df0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4df0 cd 86 1d			call macro_forth_dsp_pop 
4df3				endm 
# End of macro FORTH_DSP_POP
4df3			 
4df3					; save asci byte as a zero term string and push string 
4df3			 
4df3 7d					ld a,l 
4df4 32 b8 e2				ld (scratch), a 
4df7			 
4df7 3e 00				ld a, 0 
4df9 32 b9 e2				ld (scratch+1), a 
4dfc			 
4dfc 21 b8 e2				ld hl, scratch 
4dff cd 3c 1b				call forth_push_str 
4e02			 
4e02			 
4e02				       NEXTW 
4e02 cd 6c ee			call parse_vector 
4e05 c3 b5 1e			jp macro_next 
4e08				endm 
# End of macro NEXTW
4e08			 
4e08			 
4e08			 
4e08			 
4e08			.ENDSTR: 
4e08			; eof 
4e08			 
# End of file forth_words_str.asm
4e08			include "forth_words_key.asm" 
4e08			 
4e08			; | ## Keyboard Words 
4e08			 
4e08			.KEY: 
4e08				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
4e08 3e				db WORD_SYS_CORE+42             
4e09 3b 4e			dw .KEYDB            
4e0b 04				db 3 + 1 
4e0c .. 00			db "KEY",0              
4e10				endm 
# End of macro CWHEAD
4e10			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4e10			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4e10			; | | Can use something like this to process: 
4e10			; | | > repeat active . key ?dup if emit then #1 until  
4e10			 
4e10					if DEBUG_FORTH_WORDS_KEY 
4e10						DMARK "KEY" 
4e10 f5				push af  
4e11 3a 25 4e			ld a, (.dmark)  
4e14 32 62 ee			ld (debug_mark),a  
4e17 3a 26 4e			ld a, (.dmark+1)  
4e1a 32 63 ee			ld (debug_mark+1),a  
4e1d 3a 27 4e			ld a, (.dmark+2)  
4e20 32 64 ee			ld (debug_mark+2),a  
4e23 18 03			jr .pastdmark  
4e25 ..			.dmark: db "KEY"  
4e28 f1			.pastdmark: pop af  
4e29			endm  
# End of macro DMARK
4e29						CALLMONITOR 
4e29 cd 6f ee			call debug_vector  
4e2c				endm  
# End of macro CALLMONITOR
4e2c					endif 
4e2c			; TODO currently waits 
4e2c cd b0 65				call cinndb 
4e2f					;call cin_wait 
4e2f 6f					ld l, a 
4e30 26 00				ld h, 0 
4e32 cd d2 1a				call forth_push_numhl 
4e35					NEXTW 
4e35 cd 6c ee			call parse_vector 
4e38 c3 b5 1e			jp macro_next 
4e3b				endm 
# End of macro NEXTW
4e3b			.KEYDB: 
4e3b				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
4e3b 3e				db WORD_SYS_CORE+42             
4e3c 70 4e			dw .WAITK            
4e3e 06				db 5 + 1 
4e3f .. 00			db "KEYDB",0              
4e45				endm 
# End of macro CWHEAD
4e45			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
4e45			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4e45			; | | Can use something like this to process: 
4e45			; | | > repeat active . key ?dup if emit then #1 until  
4e45			 
4e45					if DEBUG_FORTH_WORDS_KEY 
4e45						DMARK "KEB" 
4e45 f5				push af  
4e46 3a 5a 4e			ld a, (.dmark)  
4e49 32 62 ee			ld (debug_mark),a  
4e4c 3a 5b 4e			ld a, (.dmark+1)  
4e4f 32 63 ee			ld (debug_mark+1),a  
4e52 3a 5c 4e			ld a, (.dmark+2)  
4e55 32 64 ee			ld (debug_mark+2),a  
4e58 18 03			jr .pastdmark  
4e5a ..			.dmark: db "KEB"  
4e5d f1			.pastdmark: pop af  
4e5e			endm  
# End of macro DMARK
4e5e						CALLMONITOR 
4e5e cd 6f ee			call debug_vector  
4e61				endm  
# End of macro CALLMONITOR
4e61					endif 
4e61			; TODO currently waits 
4e61 cd b0 65				call cin 
4e64					;call cin_wait 
4e64 6f					ld l, a 
4e65 26 00				ld h, 0 
4e67 cd d2 1a				call forth_push_numhl 
4e6a					NEXTW 
4e6a cd 6c ee			call parse_vector 
4e6d c3 b5 1e			jp macro_next 
4e70				endm 
# End of macro NEXTW
4e70			.WAITK: 
4e70				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4e70 3f				db WORD_SYS_CORE+43             
4e71 a5 4e			dw .ACCEPT            
4e73 06				db 5 + 1 
4e74 .. 00			db "WAITK",0              
4e7a				endm 
# End of macro CWHEAD
4e7a			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4e7a					if DEBUG_FORTH_WORDS_KEY 
4e7a						DMARK "WAI" 
4e7a f5				push af  
4e7b 3a 8f 4e			ld a, (.dmark)  
4e7e 32 62 ee			ld (debug_mark),a  
4e81 3a 90 4e			ld a, (.dmark+1)  
4e84 32 63 ee			ld (debug_mark+1),a  
4e87 3a 91 4e			ld a, (.dmark+2)  
4e8a 32 64 ee			ld (debug_mark+2),a  
4e8d 18 03			jr .pastdmark  
4e8f ..			.dmark: db "WAI"  
4e92 f1			.pastdmark: pop af  
4e93			endm  
# End of macro DMARK
4e93						CALLMONITOR 
4e93 cd 6f ee			call debug_vector  
4e96				endm  
# End of macro CALLMONITOR
4e96					endif 
4e96 cd a8 65				call cin_wait 
4e99 6f					ld l, a 
4e9a 26 00				ld h, 0 
4e9c cd d2 1a				call forth_push_numhl 
4e9f					NEXTW 
4e9f cd 6c ee			call parse_vector 
4ea2 c3 b5 1e			jp macro_next 
4ea5				endm 
# End of macro NEXTW
4ea5			.ACCEPT: 
4ea5				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4ea5 40				db WORD_SYS_CORE+44             
4ea6 05 4f			dw .EDIT            
4ea8 07				db 6 + 1 
4ea9 .. 00			db "ACCEPT",0              
4eb0				endm 
# End of macro CWHEAD
4eb0			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4eb0					; TODO crashes on push 
4eb0					if DEBUG_FORTH_WORDS_KEY 
4eb0						DMARK "ACC" 
4eb0 f5				push af  
4eb1 3a c5 4e			ld a, (.dmark)  
4eb4 32 62 ee			ld (debug_mark),a  
4eb7 3a c6 4e			ld a, (.dmark+1)  
4eba 32 63 ee			ld (debug_mark+1),a  
4ebd 3a c7 4e			ld a, (.dmark+2)  
4ec0 32 64 ee			ld (debug_mark+2),a  
4ec3 18 03			jr .pastdmark  
4ec5 ..			.dmark: db "ACC"  
4ec8 f1			.pastdmark: pop af  
4ec9			endm  
# End of macro DMARK
4ec9						CALLMONITOR 
4ec9 cd 6f ee			call debug_vector  
4ecc				endm  
# End of macro CALLMONITOR
4ecc					endif 
4ecc 21 b6 e4				ld hl, os_input 
4ecf			;		ld a, 0 
4ecf 36 00				ld (hl),0 
4ed1 3a 55 ea				ld a,(f_cursor_ptr) 
4ed4 16 64				ld d, 100 
4ed6 0e 00				ld c, 0 
4ed8 1e 28				ld e, 40 
4eda cd 0e 0e				call input_str 
4edd					; TODO perhaps do a type check and wrap in quotes if not a number 
4edd 21 b6 e4				ld hl, os_input 
4ee0					if DEBUG_FORTH_WORDS 
4ee0						DMARK "AC1" 
4ee0 f5				push af  
4ee1 3a f5 4e			ld a, (.dmark)  
4ee4 32 62 ee			ld (debug_mark),a  
4ee7 3a f6 4e			ld a, (.dmark+1)  
4eea 32 63 ee			ld (debug_mark+1),a  
4eed 3a f7 4e			ld a, (.dmark+2)  
4ef0 32 64 ee			ld (debug_mark+2),a  
4ef3 18 03			jr .pastdmark  
4ef5 ..			.dmark: db "AC1"  
4ef8 f1			.pastdmark: pop af  
4ef9			endm  
# End of macro DMARK
4ef9						CALLMONITOR 
4ef9 cd 6f ee			call debug_vector  
4efc				endm  
# End of macro CALLMONITOR
4efc					endif 
4efc cd 3c 1b				call forth_push_str 
4eff					NEXTW 
4eff cd 6c ee			call parse_vector 
4f02 c3 b5 1e			jp macro_next 
4f05				endm 
# End of macro NEXTW
4f05			 
4f05			.EDIT: 
4f05				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4f05 40				db WORD_SYS_CORE+44             
4f06 aa 4f			dw .DEDIT            
4f08 05				db 4 + 1 
4f09 .. 00			db "EDIT",0              
4f0e				endm 
# End of macro CWHEAD
4f0e			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4f0e			 
4f0e					; TODO does not copy from stack 
4f0e					if DEBUG_FORTH_WORDS_KEY 
4f0e						DMARK "EDT" 
4f0e f5				push af  
4f0f 3a 23 4f			ld a, (.dmark)  
4f12 32 62 ee			ld (debug_mark),a  
4f15 3a 24 4f			ld a, (.dmark+1)  
4f18 32 63 ee			ld (debug_mark+1),a  
4f1b 3a 25 4f			ld a, (.dmark+2)  
4f1e 32 64 ee			ld (debug_mark+2),a  
4f21 18 03			jr .pastdmark  
4f23 ..			.dmark: db "EDT"  
4f26 f1			.pastdmark: pop af  
4f27			endm  
# End of macro DMARK
4f27						CALLMONITOR 
4f27 cd 6f ee			call debug_vector  
4f2a				endm  
# End of macro CALLMONITOR
4f2a					endif 
4f2a			 
4f2a					;FORTH_DSP 
4f2a					FORTH_DSP_VALUEHL 
4f2a cd ce 1c			call macro_dsp_valuehl 
4f2d				endm 
# End of macro FORTH_DSP_VALUEHL
4f2d			;		inc hl    ; TODO do type check 
4f2d			 
4f2d			;		call get_word_hl 
4f2d e5					push hl 
4f2e					if DEBUG_FORTH_WORDS 
4f2e						DMARK "EDp" 
4f2e f5				push af  
4f2f 3a 43 4f			ld a, (.dmark)  
4f32 32 62 ee			ld (debug_mark),a  
4f35 3a 44 4f			ld a, (.dmark+1)  
4f38 32 63 ee			ld (debug_mark+1),a  
4f3b 3a 45 4f			ld a, (.dmark+2)  
4f3e 32 64 ee			ld (debug_mark+2),a  
4f41 18 03			jr .pastdmark  
4f43 ..			.dmark: db "EDp"  
4f46 f1			.pastdmark: pop af  
4f47			endm  
# End of macro DMARK
4f47						CALLMONITOR 
4f47 cd 6f ee			call debug_vector  
4f4a				endm  
# End of macro CALLMONITOR
4f4a					endif 
4f4a				;	ld a, 0 
4f4a cd 39 11				call strlenz 
4f4d 23					inc hl 
4f4e			 
4f4e 06 00				ld b, 0 
4f50 4d					ld c, l 
4f51			 
4f51 e1					pop hl 
4f52 11 b6 e4				ld de, os_input 
4f55					if DEBUG_FORTH_WORDS_KEY 
4f55						DMARK "EDc" 
4f55 f5				push af  
4f56 3a 6a 4f			ld a, (.dmark)  
4f59 32 62 ee			ld (debug_mark),a  
4f5c 3a 6b 4f			ld a, (.dmark+1)  
4f5f 32 63 ee			ld (debug_mark+1),a  
4f62 3a 6c 4f			ld a, (.dmark+2)  
4f65 32 64 ee			ld (debug_mark+2),a  
4f68 18 03			jr .pastdmark  
4f6a ..			.dmark: db "EDc"  
4f6d f1			.pastdmark: pop af  
4f6e			endm  
# End of macro DMARK
4f6e						CALLMONITOR 
4f6e cd 6f ee			call debug_vector  
4f71				endm  
# End of macro CALLMONITOR
4f71					endif 
4f71 ed b0				ldir 
4f73			 
4f73			 
4f73 21 b6 e4				ld hl, os_input 
4f76					;ld a, 0 
4f76					;ld (hl),a 
4f76 3a 55 ea				ld a,(f_cursor_ptr) 
4f79 16 64				ld d, 100 
4f7b 0e 00				ld c, 0 
4f7d 1e 28				ld e, 40 
4f7f cd 0e 0e				call input_str 
4f82					; TODO perhaps do a type check and wrap in quotes if not a number 
4f82 21 b6 e4				ld hl, os_input 
4f85					if DEBUG_FORTH_WORDS 
4f85						DMARK "ED1" 
4f85 f5				push af  
4f86 3a 9a 4f			ld a, (.dmark)  
4f89 32 62 ee			ld (debug_mark),a  
4f8c 3a 9b 4f			ld a, (.dmark+1)  
4f8f 32 63 ee			ld (debug_mark+1),a  
4f92 3a 9c 4f			ld a, (.dmark+2)  
4f95 32 64 ee			ld (debug_mark+2),a  
4f98 18 03			jr .pastdmark  
4f9a ..			.dmark: db "ED1"  
4f9d f1			.pastdmark: pop af  
4f9e			endm  
# End of macro DMARK
4f9e						CALLMONITOR 
4f9e cd 6f ee			call debug_vector  
4fa1				endm  
# End of macro CALLMONITOR
4fa1					endif 
4fa1 cd 3c 1b				call forth_push_str 
4fa4					NEXTW 
4fa4 cd 6c ee			call parse_vector 
4fa7 c3 b5 1e			jp macro_next 
4faa				endm 
# End of macro NEXTW
4faa			 
4faa			.DEDIT: 
4faa				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4faa 40				db WORD_SYS_CORE+44             
4fab 0f 50			dw .ENDKEY            
4fad 06				db 5 + 1 
4fae .. 00			db "DEDIT",0              
4fb4				endm 
# End of macro CWHEAD
4fb4			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
4fb4			 
4fb4					; TODO does not copy from stack 
4fb4					if DEBUG_FORTH_WORDS_KEY 
4fb4						DMARK "DED" 
4fb4 f5				push af  
4fb5 3a c9 4f			ld a, (.dmark)  
4fb8 32 62 ee			ld (debug_mark),a  
4fbb 3a ca 4f			ld a, (.dmark+1)  
4fbe 32 63 ee			ld (debug_mark+1),a  
4fc1 3a cb 4f			ld a, (.dmark+2)  
4fc4 32 64 ee			ld (debug_mark+2),a  
4fc7 18 03			jr .pastdmark  
4fc9 ..			.dmark: db "DED"  
4fcc f1			.pastdmark: pop af  
4fcd			endm  
# End of macro DMARK
4fcd						CALLMONITOR 
4fcd cd 6f ee			call debug_vector  
4fd0				endm  
# End of macro CALLMONITOR
4fd0					endif 
4fd0			 
4fd0					;FORTH_DSP 
4fd0					FORTH_DSP_VALUEHL 
4fd0 cd ce 1c			call macro_dsp_valuehl 
4fd3				endm 
# End of macro FORTH_DSP_VALUEHL
4fd3			;		inc hl    ; TODO do type check 
4fd3			 
4fd3			;		call get_word_hl 
4fd3 e5					push hl 
4fd4 e5					push hl 
4fd5					FORTH_DSP_POP 
4fd5 cd 86 1d			call macro_forth_dsp_pop 
4fd8				endm 
# End of macro FORTH_DSP_POP
4fd8 e1					pop hl 
4fd9					if DEBUG_FORTH_WORDS 
4fd9						DMARK "EDp" 
4fd9 f5				push af  
4fda 3a ee 4f			ld a, (.dmark)  
4fdd 32 62 ee			ld (debug_mark),a  
4fe0 3a ef 4f			ld a, (.dmark+1)  
4fe3 32 63 ee			ld (debug_mark+1),a  
4fe6 3a f0 4f			ld a, (.dmark+2)  
4fe9 32 64 ee			ld (debug_mark+2),a  
4fec 18 03			jr .pastdmark  
4fee ..			.dmark: db "EDp"  
4ff1 f1			.pastdmark: pop af  
4ff2			endm  
# End of macro DMARK
4ff2						CALLMONITOR 
4ff2 cd 6f ee			call debug_vector  
4ff5				endm  
# End of macro CALLMONITOR
4ff5					endif 
4ff5				;	ld a, 0 
4ff5 cd 39 11				call strlenz 
4ff8 23					inc hl 
4ff9			 
4ff9 06 00				ld b, 0 
4ffb 4d					ld c, l 
4ffc			 
4ffc e1					pop hl 
4ffd			 
4ffd					;ld a, 0 
4ffd					;ld (hl),a 
4ffd 3a 55 ea				ld a,(f_cursor_ptr) 
5000 16 64				ld d, 100 
5002 0e 00				ld c, 0 
5004 1e 28				ld e, 40 
5006 cd 0e 0e				call input_str 
5009					; TODO perhaps do a type check and wrap in quotes if not a number 
5009					NEXTW 
5009 cd 6c ee			call parse_vector 
500c c3 b5 1e			jp macro_next 
500f				endm 
# End of macro NEXTW
500f			 
500f			 
500f			.ENDKEY: 
500f			; eof 
500f			 
# End of file forth_words_key.asm
500f			include "forth_words_const.asm" 
500f			 
500f			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
500f			 
500f			 
500f			.SPITIME: 
500f				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
500f 77				db WORD_SYS_CORE+99             
5010 27 50			dw .VA            
5012 08				db 7 + 1 
5013 .. 00			db "SPITIME",0              
501b				endm 
# End of macro CWHEAD
501b			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
501b			; 
501b			; | | If using BANK devices then leave as is. 
501b			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
501b			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
501b			 
501b 21 5b ea				ld hl, spi_clktime  
501e cd d2 1a				call forth_push_numhl 
5021			 
5021					NEXTW 
5021 cd 6c ee			call parse_vector 
5024 c3 b5 1e			jp macro_next 
5027				endm 
# End of macro NEXTW
5027			 
5027			 
5027			.VA: 
5027				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
5027 77				db WORD_SYS_CORE+99             
5028 3a 50			dw .SYMBOL            
502a 03				db 2 + 1 
502b .. 00			db "VA",0              
502e				endm 
# End of macro CWHEAD
502e			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
502e 21 1f ea				ld hl, cli_var_array 
5031 cd d2 1a				call forth_push_numhl 
5034			 
5034					NEXTW 
5034 cd 6c ee			call parse_vector 
5037 c3 b5 1e			jp macro_next 
503a				endm 
# End of macro NEXTW
503a			 
503a			.SYMBOL: 
503a				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
503a 77				db WORD_SYS_CORE+99             
503b 49 51			dw .ENDCONST            
503d 07				db 6 + 1 
503e .. 00			db "SYMBOL",0              
5045				endm 
# End of macro CWHEAD
5045			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
5045			; | 
5045			; | | The value is the number reference and the final address is pushed to stack 
5045			 
5045			; | | ``` 
5045			; | | dw sym_table 
5045			; | | dw nmi_vector 
5045			; | | dw cli_autodisplay 
5045			; | | dw cli_data_sp 
5045			; | | dw cli_data_stack 
5045			; | | dw cli_loop_sp 
5045			; | | dw cli_loop_stack 
5045			; | | dw cli_var_array 
5045			; | | dw cursor_col 
5045			; | | dw cursor_ptr 
5045			; | | ; 10 
5045			; | | dw cursor_row 
5045			; | | dw debug_mark 
5045			; | | dw display_fb0 
5045			; | | dw display_fb1 
5045			; | | dw display_fb2 
5045			; | | dw display_fb3 
5045			; | | dw display_fb_active 
5045			; | | dw execscratch 
5045			; | | dw f_cursor_ptr 
5045			; | | dw hardware_word 
5045			; | | ;20 
5045			; | | dw input_at_cursor 
5045			; | | dw input_at_pos 
5045			; | | dw input_cur_flash 
5045			; | | dw input_cur_onoff 
5045			; | | dw input_cursor 
5045			; | | dw input_display_size 
5045			; | | dw input_len 
5045			; | | dw input_ptr 
5045			; | | dw input_size 
5045			; | | dw input_start 
5045			; | | ; 30 
5045			; | | dw input_str 
5045			; | | dw input_under_cursor 
5045			; | | dw os_cli_cmd 
5045			; | | dw os_cur_ptr 
5045			; | | dw os_current_i 
5045			; | | dw os_input 
5045			; | | dw os_last_cmd 
5045			; | | dw os_last_new_uword 
5045			; | | dw debug_vector 
5045			; | | dw os_view_hl 
5045			; | | ;40 
5045			; | | dw os_word_scratch 
5045			; | | dw portbctl 
5045			; | | dw portbdata 
5045			; | | dw spi_cartdev 
5045			; | | dw spi_cartdev2 
5045			; | | dw spi_clktime 
5045			; | | dw spi_device 
5045			; | | dw spi_device_id 
5045			; | | dw spi_portbyte 
5045			; | | dw stackstore 
5045			; | | ; 50 
5045			; | | if STORAGE_SE 
5045			; | | dw storage_actl 
5045			; | | dw storage_adata 
5045			; | | else 
5045			; | | dw 0 
5045			; | | dw 0 
5045			; | | endif 
5045			; | | dw storage_append 
5045			; | | if STORAGE_SE 
5045			; | | dw storage_bctl 
5045			; | | else 
5045			; | | dw 0 
5045			; | | endif 
5045			; | | dw store_bank_active 
5045			; | | dw store_filecache 
5045			; | | dw store_longread 
5045			; | | dw store_openaddr 
5045			; | | dw store_openext 
5045			; | | dw store_openmaxext 
5045			; | | ; 60 
5045			; | | dw store_page 
5045			; | | dw store_readbuf 
5045			; | | dw store_readcont 
5045			; | | dw store_readptr 
5045			; | | dw store_tmpext 
5045			; | | dw store_tmpid 
5045			; | | dw store_tmppageid 
5045			; | | dw malloc 
5045			; | | dw free 
5045			; | | dw cin 
5045			; | | ; 70 
5045			; | | dw cin_wait 
5045			; | | dw forth_push_numhl 
5045			; | | dw forth_push_str 
5045			; | | dw parse_vector 
5045			; | | ``` 
5045			 
5045					if DEBUG_FORTH_WORDS_KEY 
5045						DMARK "SYM" 
5045 f5				push af  
5046 3a 5a 50			ld a, (.dmark)  
5049 32 62 ee			ld (debug_mark),a  
504c 3a 5b 50			ld a, (.dmark+1)  
504f 32 63 ee			ld (debug_mark+1),a  
5052 3a 5c 50			ld a, (.dmark+2)  
5055 32 64 ee			ld (debug_mark+2),a  
5058 18 03			jr .pastdmark  
505a ..			.dmark: db "SYM"  
505d f1			.pastdmark: pop af  
505e			endm  
# End of macro DMARK
505e						CALLMONITOR 
505e cd 6f ee			call debug_vector  
5061				endm  
# End of macro CALLMONITOR
5061					endif 
5061			 
5061					FORTH_DSP_VALUEHL 
5061 cd ce 1c			call macro_dsp_valuehl 
5064				endm 
# End of macro FORTH_DSP_VALUEHL
5064			 
5064 7d					ld a, l     
5065			 
5065			 
5065					if DEBUG_FORTH_WORDS 
5065						DMARK "SY1" 
5065 f5				push af  
5066 3a 7a 50			ld a, (.dmark)  
5069 32 62 ee			ld (debug_mark),a  
506c 3a 7b 50			ld a, (.dmark+1)  
506f 32 63 ee			ld (debug_mark+1),a  
5072 3a 7c 50			ld a, (.dmark+2)  
5075 32 64 ee			ld (debug_mark+2),a  
5078 18 03			jr .pastdmark  
507a ..			.dmark: db "SY1"  
507d f1			.pastdmark: pop af  
507e			endm  
# End of macro DMARK
507e						CALLMONITOR 
507e cd 6f ee			call debug_vector  
5081				endm  
# End of macro CALLMONITOR
5081					endif 
5081					 
5081 f5					push af	 
5082					FORTH_DSP_POP 
5082 cd 86 1d			call macro_forth_dsp_pop 
5085				endm 
# End of macro FORTH_DSP_POP
5085 f1					pop af 
5086			 
5086 cb 27				sla a  
5088				 
5088					 
5088					if DEBUG_FORTH_WORDS 
5088						DMARK "SY" 
5088 f5				push af  
5089 3a 9d 50			ld a, (.dmark)  
508c 32 62 ee			ld (debug_mark),a  
508f 3a 9e 50			ld a, (.dmark+1)  
5092 32 63 ee			ld (debug_mark+1),a  
5095 3a 9f 50			ld a, (.dmark+2)  
5098 32 64 ee			ld (debug_mark+2),a  
509b 18 02			jr .pastdmark  
509d ..			.dmark: db "SY"  
509f f1			.pastdmark: pop af  
50a0			endm  
# End of macro DMARK
50a0						CALLMONITOR 
50a0 cd 6f ee			call debug_vector  
50a3				endm  
# End of macro CALLMONITOR
50a3					endif 
50a3			 
50a3 21 b5 50				ld hl, sym_table 
50a6 cd e1 0d				call addatohl 
50a9 cd 3b 1e				call loadwordinhl 
50ac cd d2 1a				call forth_push_numhl 
50af			 
50af			 
50af				       NEXTW 
50af cd 6c ee			call parse_vector 
50b2 c3 b5 1e			jp macro_next 
50b5				endm 
# End of macro NEXTW
50b5			 
50b5			sym_table: 
50b5			 
50b5			; 0 
50b5 b5 50		dw sym_table 
50b7 72 ee		dw nmi_vector 
50b9 33 ea		dw cli_autodisplay 
50bb e5 e9		dw cli_data_sp 
50bd 1f e8		dw cli_data_stack 
50bf e7 e9		dw cli_loop_sp 
50c1 21 e9		dw cli_loop_stack 
50c3 1f ea		dw cli_var_array 
50c5 bc eb		dw cursor_col 
50c7 ba eb		dw cursor_ptr 
50c9			; 10 
50c9 bb eb		dw cursor_row 
50cb 62 ee		dw debug_mark 
50cd a8 ed		dw display_fb0 
50cf 07 ed		dw display_fb1 
50d1 c5 eb		dw display_fb2 
50d3 66 ec		dw display_fb3 
50d5 c3 eb		dw display_fb_active 
50d7 b7 e3		dw execscratch 
50d9 55 ea		dw f_cursor_ptr 
50db 75 ee		dw hardware_word 
50dd			;20 
50dd 59 ee		dw input_at_cursor 
50df 5b ee		dw input_at_pos 
50e1 57 ee		dw input_cur_flash 
50e3 56 ee		dw input_cur_onoff 
50e5 4c ee		dw input_cursor 
50e7 5c ee		dw input_display_size 
50e9 51 ee		dw input_len 
50eb 60 ee		dw input_ptr 
50ed 5d ee		dw input_size 
50ef 5e ee		dw input_start 
50f1			; 30 
50f1 0e 0e		dw input_str 
50f3 5a ee		dw input_under_cursor 
50f5 df e5		dw os_cli_cmd 
50f7 db e5		dw os_cur_ptr 
50f9 dd e5		dw os_current_i 
50fb b6 e4		dw os_input 
50fd de e6		dw os_last_cmd 
50ff b5 e5		dw os_last_new_uword 
5101 6f ee		dw debug_vector 
5103 9a e2		dw os_view_hl 
5105			;40 
5105 bd e5		dw os_word_scratch 
5107 c3 00		dw portbctl 
5109 c1 00		dw portbdata 
510b 5a ea		dw spi_cartdev 
510d 59 ea		dw spi_cartdev2 
510f 5b ea		dw spi_clktime 
5111 57 ea		dw spi_device 
5113 56 ea		dw spi_device_id 
5115 58 ea		dw spi_portbyte 
5117 9e eb		dw stackstore 
5119			; 50 
5119			if STORAGE_SE 
5119			dw storage_actl 
5119			dw storage_adata 
5119			else 
5119 00 00		dw 0 
511b 00 00		dw 0 
511d			endif 
511d 6b 09		dw storage_append 
511f			if STORAGE_SE 
511f			dw storage_bctl 
511f			else 
511f 00 00		dw 0 
5121			endif 
5121 8a eb		dw store_bank_active 
5123 5e ea		dw store_filecache 
5125 6c ea		dw store_longread 
5127 62 ea		dw store_openaddr 
5129 61 ea		dw store_openext 
512b 60 ea		dw store_openmaxext 
512d			; 60 
512d 71 ea		dw store_page 
512f 6d ea		dw store_readbuf 
5131 64 ea		dw store_readcont 
5133 6f ea		dw store_readptr 
5135 64 ea		dw store_tmpext 
5137 65 ea		dw store_tmpid 
5139 5c ea		dw store_tmppageid 
513b ad 11		dw malloc 
513d 77 12		dw free 
513f b0 65		dw cin 
5141			; 70 
5141 a8 65		dw cin_wait 
5143 d2 1a		dw forth_push_numhl 
5145 3c 1b		dw forth_push_str 
5147 6c ee		dw parse_vector 
5149			 
5149			.ENDCONST: 
5149			 
5149			; eof 
5149			 
5149			 
# End of file forth_words_const.asm
5149			 
5149			if STORAGE_SE 
5149			   	include "forth_words_storage.asm" 
5149			endif 
5149				include "forth_words_device.asm" 
5149			; Device related words 
5149			 
5149			; | ## Device Words 
5149			 
5149			;if SOUND_ENABLE 
5149			;.NOTE: 
5149			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5149			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5149			;		if DEBUG_FORTH_WORDS_KEY 
5149			;			DMARK "NTE" 
5149			;			CALLMONITOR 
5149			;		endif 
5149			; 
5149			;	 
5149			; 
5149			;		NEXTW 
5149			;.AFTERSOUND: 
5149			;endif 
5149			 
5149			 
5149			USE_GPIO: equ 0 
5149			 
5149			if USE_GPIO 
5149			.GP1: 
5149				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5149			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5149					NEXTW 
5149			.GP2: 
5149				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5149			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5149			 
5149					NEXTW 
5149			 
5149			.GP3: 
5149				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5149			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5149			 
5149					NEXTW 
5149			 
5149			.GP4: 
5149				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5149			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5149			 
5149					NEXTW 
5149			.SIN: 
5149			 
5149			 
5149			endif 
5149			 
5149			 
5149				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5149 33				db WORD_SYS_CORE+31             
514a 81 51			dw .SOUT            
514c 03				db 2 + 1 
514d .. 00			db "IN",0              
5150				endm 
# End of macro CWHEAD
5150			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5150					if DEBUG_FORTH_WORDS_KEY 
5150						DMARK "IN." 
5150 f5				push af  
5151 3a 65 51			ld a, (.dmark)  
5154 32 62 ee			ld (debug_mark),a  
5157 3a 66 51			ld a, (.dmark+1)  
515a 32 63 ee			ld (debug_mark+1),a  
515d 3a 67 51			ld a, (.dmark+2)  
5160 32 64 ee			ld (debug_mark+2),a  
5163 18 03			jr .pastdmark  
5165 ..			.dmark: db "IN."  
5168 f1			.pastdmark: pop af  
5169			endm  
# End of macro DMARK
5169						CALLMONITOR 
5169 cd 6f ee			call debug_vector  
516c				endm  
# End of macro CALLMONITOR
516c					endif 
516c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
516c cd ce 1c			call macro_dsp_valuehl 
516f				endm 
# End of macro FORTH_DSP_VALUEHL
516f			 
516f e5					push hl 
5170			 
5170					; destroy value TOS 
5170			 
5170					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5170 cd 86 1d			call macro_forth_dsp_pop 
5173				endm 
# End of macro FORTH_DSP_POP
5173			 
5173					; one value on hl get other one back 
5173			 
5173 c1					pop bc 
5174			 
5174					; do the sub 
5174			;		ex de, hl 
5174			 
5174 ed 68				in l,(c) 
5176			 
5176					; save it 
5176			 
5176 26 00				ld h,0 
5178			 
5178					; TODO push value back onto stack for another op etc 
5178			 
5178 cd d2 1a				call forth_push_numhl 
517b					NEXTW 
517b cd 6c ee			call parse_vector 
517e c3 b5 1e			jp macro_next 
5181				endm 
# End of macro NEXTW
5181			.SOUT: 
5181				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5181 34				db WORD_SYS_CORE+32             
5182 d7 51			dw .SPIO            
5184 04				db 3 + 1 
5185 .. 00			db "OUT",0              
5189				endm 
# End of macro CWHEAD
5189			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5189					if DEBUG_FORTH_WORDS_KEY 
5189						DMARK "OUT" 
5189 f5				push af  
518a 3a 9e 51			ld a, (.dmark)  
518d 32 62 ee			ld (debug_mark),a  
5190 3a 9f 51			ld a, (.dmark+1)  
5193 32 63 ee			ld (debug_mark+1),a  
5196 3a a0 51			ld a, (.dmark+2)  
5199 32 64 ee			ld (debug_mark+2),a  
519c 18 03			jr .pastdmark  
519e ..			.dmark: db "OUT"  
51a1 f1			.pastdmark: pop af  
51a2			endm  
# End of macro DMARK
51a2						CALLMONITOR 
51a2 cd 6f ee			call debug_vector  
51a5				endm  
# End of macro CALLMONITOR
51a5					endif 
51a5			 
51a5					; get port 
51a5			 
51a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51a5 cd ce 1c			call macro_dsp_valuehl 
51a8				endm 
# End of macro FORTH_DSP_VALUEHL
51a8			 
51a8 e5					push hl 
51a9			 
51a9					; destroy value TOS 
51a9			 
51a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51a9 cd 86 1d			call macro_forth_dsp_pop 
51ac				endm 
# End of macro FORTH_DSP_POP
51ac			 
51ac					; get byte to send 
51ac			 
51ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51ac cd ce 1c			call macro_dsp_valuehl 
51af				endm 
# End of macro FORTH_DSP_VALUEHL
51af			 
51af			;		push hl 
51af			 
51af					; destroy value TOS 
51af			 
51af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51af cd 86 1d			call macro_forth_dsp_pop 
51b2				endm 
# End of macro FORTH_DSP_POP
51b2			 
51b2					; one value on hl get other one back 
51b2			 
51b2			;		pop hl 
51b2			 
51b2 c1					pop bc 
51b3			 
51b3					if DEBUG_FORTH_WORDS 
51b3						DMARK "OUT" 
51b3 f5				push af  
51b4 3a c8 51			ld a, (.dmark)  
51b7 32 62 ee			ld (debug_mark),a  
51ba 3a c9 51			ld a, (.dmark+1)  
51bd 32 63 ee			ld (debug_mark+1),a  
51c0 3a ca 51			ld a, (.dmark+2)  
51c3 32 64 ee			ld (debug_mark+2),a  
51c6 18 03			jr .pastdmark  
51c8 ..			.dmark: db "OUT"  
51cb f1			.pastdmark: pop af  
51cc			endm  
# End of macro DMARK
51cc						CALLMONITOR 
51cc cd 6f ee			call debug_vector  
51cf				endm  
# End of macro CALLMONITOR
51cf					endif 
51cf			 
51cf ed 69				out (c), l 
51d1			 
51d1					NEXTW 
51d1 cd 6c ee			call parse_vector 
51d4 c3 b5 1e			jp macro_next 
51d7				endm 
# End of macro NEXTW
51d7			 
51d7			 
51d7			.SPIO: 
51d7			 
51d7			if STORAGE_SE 
51d7				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
51d7			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
51d7			 
51d7					call spi_ce_low 
51d7			    NEXTW 
51d7			 
51d7			.SPICEH: 
51d7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
51d7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
51d7			 
51d7					call spi_ce_high 
51d7			    NEXTW 
51d7			 
51d7			 
51d7			.SPIOb: 
51d7			 
51d7				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
51d7			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
51d7			 
51d7					if DEBUG_FORTH_WORDS_KEY 
51d7						DMARK "SPo" 
51d7						CALLMONITOR 
51d7					endif 
51d7					; get port 
51d7			 
51d7			 
51d7					; get byte to send 
51d7			 
51d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51d7			 
51d7			;		push hl    ; u1  
51d7			 
51d7					; destroy value TOS 
51d7			 
51d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51d7			 
51d7					; one value on hl get other one back 
51d7			 
51d7			;		pop hl   ; u2 - addr 
51d7			 
51d7					; TODO Send SPI byte 
51d7			 
51d7			;		push hl 
51d7			;		call spi_ce_low 
51d7			;		pop hl 
51d7					ld a, l 
51d7					call spi_send_byte 
51d7			;		call spi_ce_high 
51d7			 
51d7					NEXTW 
51d7			 
51d7			.SPII: 
51d7				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
51d7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
51d7					if DEBUG_FORTH_WORDS_KEY 
51d7						DMARK "SPi" 
51d7						CALLMONITOR 
51d7					endif 
51d7			 
51d7					; TODO Get SPI byte 
51d7			 
51d7					call spi_read_byte 
51d7			 
51d7					if DEBUG_FORTH_WORDS 
51d7						DMARK "Si2" 
51d7						CALLMONITOR 
51d7					endif 
51d7					ld h, 0 
51d7					ld l, a 
51d7					if DEBUG_FORTH_WORDS 
51d7						DMARK "Si3" 
51d7						CALLMONITOR 
51d7					endif 
51d7					call forth_push_numhl 
51d7			 
51d7					NEXTW 
51d7			 
51d7			 
51d7			 
51d7			.SESEL: 
51d7				CWHEAD .SESELS 82 "BANK?" 5 WORD_FLAG_CODE 
51d7			; | BANK? ( -- u ) Reports on the serial EEPROM Bank Device at bank address u1 1-5.  | DONE 
51d7			; | | Zero is disabled storage. 
51d7					if DEBUG_FORTH_WORDS_KEY 
51d7						DMARK "BN?" 
51d7						CALLMONITOR 
51d7					endif 
51d7					ld a, (spi_device_id) 
51d7					sub '0' 
51d7					ld h, 0 
51d7					ld l, a 
51d7					call forth_push_numhl 
51d7					NEXTW 
51d7			.SESELS: 
51d7				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
51d7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
51d7			; | | Set to zero to disable storage. 
51d7					if DEBUG_FORTH_WORDS_KEY 
51d7						DMARK "BNK" 
51d7						CALLMONITOR 
51d7					endif 
51d7			 
51d7					ld a, 255 
51d7					ld (spi_cartdev), a 
51d7			 
51d7					; get bank 
51d7			 
51d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51d7			 
51d7			;		push hl 
51d7			 
51d7					; destroy value TOS 
51d7			 
51d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51d7			 
51d7					; one value on hl get other one back 
51d7			 
51d7			;		pop hl 
51d7			 
51d7			 
51d7					ld c, SPI_CE_HIGH 
51d7					ld b, '0'    ; human readable bank number 
51d7			 
51d7					ld a, l 
51d7			 
51d7					if DEBUG_FORTH_WORDS 
51d7						DMARK "BNK" 
51d7						CALLMONITOR 
51d7					endif 
51d7			 
51d7					; active low 
51d7			 
51d7			;		cp 0 
51d7					or a 
51d7					jr z, .bset 
51d7					cp 1 
51d7					jr nz, .b2 
51d7					res 0, c 
51d7					ld b, '1'    ; human readable bank number 
51d7			.b2:		cp 2 
51d7					jr nz, .b3 
51d7					res 1, c 
51d7					ld b, '2'    ; human readable bank number 
51d7			.b3:		cp 3 
51d7					jr nz, .b4 
51d7					res 2, c 
51d7					ld b, '3'    ; human readable bank number 
51d7			.b4:		cp 4 
51d7					jr nz, .b5 
51d7					res 3, c 
51d7					ld b, '4'    ; human readable bank number 
51d7			.b5:		cp 5 
51d7					jr nz, .bset 
51d7					res 4, c 
51d7					ld b, '5'    ; human readable bank number 
51d7			 
51d7			.bset: 
51d7					ld a, c 
51d7					ld (spi_device),a 
51d7					ld a, b 
51d7					ld (spi_device_id),a 
51d7					if DEBUG_FORTH_WORDS 
51d7						DMARK "BN2" 
51d7						CALLMONITOR 
51d7					endif 
51d7			 
51d7					; set default SPI clk pulse time as disabled for BANK use 
51d7			 
51d7					ld a, 0 
51d7					ld (spi_clktime), a 
51d7			 
51d7					NEXTW 
51d7			 
51d7			.CARTDEV: 
51d7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
51d7			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
51d7			; | | Set to zero to disable devices. 
51d7					if DEBUG_FORTH_WORDS_KEY 
51d7						DMARK "CDV" 
51d7						CALLMONITOR 
51d7					endif 
51d7			 
51d7					; disable se storage bank selection 
51d7			 
51d7					ld a, SPI_CE_HIGH		; ce high 
51d7					ld (spi_device), a 
51d7			 
51d7					; get bank 
51d7			 
51d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51d7			 
51d7			;		push hl 
51d7			 
51d7					; destroy value TOS 
51d7			 
51d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51d7			 
51d7					; one value on hl get other one back 
51d7			 
51d7			;		pop hl 
51d7			 
51d7					; active low 
51d7			 
51d7					ld c, 255 
51d7			 
51d7					ld a, l 
51d7					if DEBUG_FORTH_WORDS 
51d7						DMARK "CDV" 
51d7						CALLMONITOR 
51d7					endif 
51d7			;		cp 0 
51d7					or a 
51d7					jr z, .cset 
51d7					cp 1 
51d7					jr nz, .c2 
51d7					res 0, c 
51d7			.c2:		cp 2 
51d7					jr nz, .c3 
51d7					res 1, c 
51d7			.c3:		cp 3 
51d7					jr nz, .c4 
51d7					res 2, c 
51d7			.c4:		cp 4 
51d7					jr nz, .c5 
51d7					res 3, c 
51d7			.c5:		cp 5 
51d7					jr nz, .c6 
51d7					res 4, c 
51d7			.c6:		cp 6 
51d7					jr nz, .c7 
51d7					res 5, c 
51d7			.c7:		cp 7 
51d7					jr nz, .c8 
51d7					res 6, c 
51d7			.c8:		cp 8 
51d7					jr nz, .cset 
51d7					res 7, c 
51d7			.cset:		ld a, c 
51d7					ld (spi_cartdev),a 
51d7			 
51d7					if DEBUG_FORTH_WORDS 
51d7						DMARK "CD2" 
51d7						CALLMONITOR 
51d7					endif 
51d7			 
51d7					; set default SPI clk pulse time as 10ms for CARTDEV use 
51d7			 
51d7					ld a, $0a 
51d7					ld (spi_clktime), a 
51d7					NEXTW 
51d7			endif 
51d7			 
51d7			.ENDDEVICE: 
51d7			; eof 
51d7			 
# End of file forth_words_device.asm
51d7			 
51d7			; var handler 
51d7			 
51d7			 
51d7			.VARS: 
51d7				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
51d7 77				db WORD_SYS_CORE+99             
51d8 8b 52			dw .V0            
51da 04				db 3 + 1 
51db .. 00			db "VAR",0              
51df				endm 
# End of macro CWHEAD
51df			; | VAR ( u1 -- )  Get the address of the (word) variable referenced on TOS  | DONE 
51df			; | 
51df			; | | The variable name should consist of a single letter (a-z). e.g. "a" 
51df			; | |  
51df			; | | e.g. 
51df			; | |         #30 a var ! 
51df			; | |         a var @ . 
51df			; | |   
51df			; | |     Displays the number 30 
51df			; | | 
51df			; | | Each variable pointer is a word so can use for any words that use that:  
51df			; | |  
51df			; | | e.g. 
51df			; | |  
51df			; | |         #30 a var 2! 
51df			; | |         a var 2@ . 
51df			; | |   
51df			; | |     Displays the number 30 
51df			; | |  
51df			; | | > [!NOTE]  
51df			; ! | > If a full string is passed then only the first char is looked at 
51df			; | | > Any other char could exceed bounds checks!  
51df			; | | > 
51df			; | | > Each variable location follows the previous. Watch you don't clobber any others. 
51df			 
51df					if DEBUG_FORTH_WORDS_KEY 
51df						DMARK "VAR" 
51df f5				push af  
51e0 3a f4 51			ld a, (.dmark)  
51e3 32 62 ee			ld (debug_mark),a  
51e6 3a f5 51			ld a, (.dmark+1)  
51e9 32 63 ee			ld (debug_mark+1),a  
51ec 3a f6 51			ld a, (.dmark+2)  
51ef 32 64 ee			ld (debug_mark+2),a  
51f2 18 03			jr .pastdmark  
51f4 ..			.dmark: db "VAR"  
51f7 f1			.pastdmark: pop af  
51f8			endm  
# End of macro DMARK
51f8						CALLMONITOR 
51f8 cd 6f ee			call debug_vector  
51fb				endm  
# End of macro CALLMONITOR
51fb					endif 
51fb			 
51fb					FORTH_DSP_VALUEHL 
51fb cd ce 1c			call macro_dsp_valuehl 
51fe				endm 
# End of macro FORTH_DSP_VALUEHL
51fe			 
51fe 7e					ld a, (hl)    ; get first char on of the string 
51ff			 
51ff			 
51ff					if DEBUG_FORTH_WORDS 
51ff						DMARK "VR1" 
51ff f5				push af  
5200 3a 14 52			ld a, (.dmark)  
5203 32 62 ee			ld (debug_mark),a  
5206 3a 15 52			ld a, (.dmark+1)  
5209 32 63 ee			ld (debug_mark+1),a  
520c 3a 16 52			ld a, (.dmark+2)  
520f 32 64 ee			ld (debug_mark+2),a  
5212 18 03			jr .pastdmark  
5214 ..			.dmark: db "VR1"  
5217 f1			.pastdmark: pop af  
5218			endm  
# End of macro DMARK
5218						CALLMONITOR 
5218 cd 6f ee			call debug_vector  
521b				endm  
# End of macro CALLMONITOR
521b					endif 
521b					 
521b f5					push af	 
521c					FORTH_DSP_POP 
521c cd 86 1d			call macro_forth_dsp_pop 
521f				endm 
# End of macro FORTH_DSP_POP
521f f1					pop af 
5220			 
5220					; convert to upper 
5220			 
5220 cd 49 10				call to_upper 
5223					if DEBUG_FORTH_WORDS 
5223						DMARK "Vaa" 
5223 f5				push af  
5224 3a 38 52			ld a, (.dmark)  
5227 32 62 ee			ld (debug_mark),a  
522a 3a 39 52			ld a, (.dmark+1)  
522d 32 63 ee			ld (debug_mark+1),a  
5230 3a 3a 52			ld a, (.dmark+2)  
5233 32 64 ee			ld (debug_mark+2),a  
5236 18 03			jr .pastdmark  
5238 ..			.dmark: db "Vaa"  
523b f1			.pastdmark: pop af  
523c			endm  
# End of macro DMARK
523c						CALLMONITOR 
523c cd 6f ee			call debug_vector  
523f				endm  
# End of macro CALLMONITOR
523f					endif 
523f 06 41				ld b, 'A' 
5241 90					sub b			; set offset 
5242					if DEBUG_FORTH_WORDS 
5242						DMARK "Vbb" 
5242 f5				push af  
5243 3a 57 52			ld a, (.dmark)  
5246 32 62 ee			ld (debug_mark),a  
5249 3a 58 52			ld a, (.dmark+1)  
524c 32 63 ee			ld (debug_mark+1),a  
524f 3a 59 52			ld a, (.dmark+2)  
5252 32 64 ee			ld (debug_mark+2),a  
5255 18 03			jr .pastdmark  
5257 ..			.dmark: db "Vbb"  
525a f1			.pastdmark: pop af  
525b			endm  
# End of macro DMARK
525b						CALLMONITOR 
525b cd 6f ee			call debug_vector  
525e				endm  
# End of macro CALLMONITOR
525e					endif 
525e cb 27				sla a  
5260				 
5260					 
5260					if DEBUG_FORTH_WORDS 
5260						DMARK "VR2" 
5260 f5				push af  
5261 3a 75 52			ld a, (.dmark)  
5264 32 62 ee			ld (debug_mark),a  
5267 3a 76 52			ld a, (.dmark+1)  
526a 32 63 ee			ld (debug_mark+1),a  
526d 3a 77 52			ld a, (.dmark+2)  
5270 32 64 ee			ld (debug_mark+2),a  
5273 18 03			jr .pastdmark  
5275 ..			.dmark: db "VR2"  
5278 f1			.pastdmark: pop af  
5279			endm  
# End of macro DMARK
5279						CALLMONITOR 
5279 cd 6f ee			call debug_vector  
527c				endm  
# End of macro CALLMONITOR
527c					endif 
527c			 
527c 21 eb e9				ld hl, cli_var_array2 
527f cd e1 0d				call addatohl 
5282 cd d2 1a				call forth_push_numhl 
5285			 
5285			 
5285				       NEXTW 
5285 cd 6c ee			call parse_vector 
5288 c3 b5 1e			jp macro_next 
528b				endm 
# End of macro NEXTW
528b			.V0: 
528b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
528b 78				db WORD_SYS_CORE+100             
528c a6 52			dw .V0Q            
528e 04				db 3 + 1 
528f .. 00			db "V0!",0              
5293				endm 
# End of macro CWHEAD
5293			;| V0! ( u1 -- )  Store value to v0  | DONE 
5293			 
5293					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5293 cd ce 1c			call macro_dsp_valuehl 
5296				endm 
# End of macro FORTH_DSP_VALUEHL
5296			 
5296 11 1f ea				ld de, cli_var_array 
5299			 
5299 eb					ex de, hl 
529a 73					ld (hl), e 
529b 23					inc hl 
529c 72					ld (hl), d 
529d			 
529d					; destroy value TOS 
529d			 
529d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
529d cd 86 1d			call macro_forth_dsp_pop 
52a0				endm 
# End of macro FORTH_DSP_POP
52a0			 
52a0				       NEXTW 
52a0 cd 6c ee			call parse_vector 
52a3 c3 b5 1e			jp macro_next 
52a6				endm 
# End of macro NEXTW
52a6			.V0Q: 
52a6				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
52a6 79				db WORD_SYS_CORE+101             
52a7 ba 52			dw .V1S            
52a9 04				db 3 + 1 
52aa .. 00			db "V0@",0              
52ae				endm 
# End of macro CWHEAD
52ae			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
52ae 2a 1f ea				ld hl, (cli_var_array) 
52b1 cd d2 1a				call forth_push_numhl 
52b4			 
52b4				       NEXTW 
52b4 cd 6c ee			call parse_vector 
52b7 c3 b5 1e			jp macro_next 
52ba				endm 
# End of macro NEXTW
52ba			.V1S: 
52ba				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
52ba 7a				db WORD_SYS_CORE+102             
52bb d5 52			dw .V1Q            
52bd 04				db 3 + 1 
52be .. 00			db "V1!",0              
52c2				endm 
# End of macro CWHEAD
52c2			;| V1! ( u1 -- )  Store value to v1 | DONE 
52c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52c2 cd ce 1c			call macro_dsp_valuehl 
52c5				endm 
# End of macro FORTH_DSP_VALUEHL
52c5			 
52c5 11 21 ea				ld de, cli_var_array+2 
52c8				 
52c8 eb					ex de, hl 
52c9 73					ld (hl), e 
52ca 23					inc hl 
52cb 72					ld (hl), d 
52cc			 
52cc					; destroy value TOS 
52cc			 
52cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52cc cd 86 1d			call macro_forth_dsp_pop 
52cf				endm 
# End of macro FORTH_DSP_POP
52cf				       NEXTW 
52cf cd 6c ee			call parse_vector 
52d2 c3 b5 1e			jp macro_next 
52d5				endm 
# End of macro NEXTW
52d5			.V1Q: 
52d5				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
52d5 7b				db WORD_SYS_CORE+103             
52d6 e9 52			dw .V2S            
52d8 04				db 3 + 1 
52d9 .. 00			db "V1@",0              
52dd				endm 
# End of macro CWHEAD
52dd			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
52dd 2a 21 ea				ld hl, (cli_var_array+2) 
52e0 cd d2 1a				call forth_push_numhl 
52e3				       NEXTW 
52e3 cd 6c ee			call parse_vector 
52e6 c3 b5 1e			jp macro_next 
52e9				endm 
# End of macro NEXTW
52e9			.V2S: 
52e9				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
52e9 7c				db WORD_SYS_CORE+104             
52ea 04 53			dw .V2Q            
52ec 04				db 3 + 1 
52ed .. 00			db "V2!",0              
52f1				endm 
# End of macro CWHEAD
52f1			;| V2! ( u1 -- )  Store value to v2 | DONE 
52f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52f1 cd ce 1c			call macro_dsp_valuehl 
52f4				endm 
# End of macro FORTH_DSP_VALUEHL
52f4			 
52f4 11 23 ea				ld de, cli_var_array+4 
52f7				 
52f7 eb					ex de, hl 
52f8 73					ld (hl), e 
52f9 23					inc hl 
52fa 72					ld (hl), d 
52fb			 
52fb					; destroy value TOS 
52fb			 
52fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52fb cd 86 1d			call macro_forth_dsp_pop 
52fe				endm 
# End of macro FORTH_DSP_POP
52fe				       NEXTW 
52fe cd 6c ee			call parse_vector 
5301 c3 b5 1e			jp macro_next 
5304				endm 
# End of macro NEXTW
5304			.V2Q: 
5304				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5304 7d				db WORD_SYS_CORE+105             
5305 18 53			dw .V3S            
5307 04				db 3 + 1 
5308 .. 00			db "V2@",0              
530c				endm 
# End of macro CWHEAD
530c			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
530c 2a 23 ea				ld hl, (cli_var_array+4) 
530f cd d2 1a				call forth_push_numhl 
5312				       NEXTW 
5312 cd 6c ee			call parse_vector 
5315 c3 b5 1e			jp macro_next 
5318				endm 
# End of macro NEXTW
5318			.V3S: 
5318				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5318 7c				db WORD_SYS_CORE+104             
5319 33 53			dw .V3Q            
531b 04				db 3 + 1 
531c .. 00			db "V3!",0              
5320				endm 
# End of macro CWHEAD
5320			;| V3! ( u1 -- )  Store value to v3 | DONE 
5320					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5320 cd ce 1c			call macro_dsp_valuehl 
5323				endm 
# End of macro FORTH_DSP_VALUEHL
5323			 
5323 11 25 ea				ld de, cli_var_array+6 
5326				 
5326 eb					ex de, hl 
5327 73					ld (hl), e 
5328 23					inc hl 
5329 72					ld (hl), d 
532a			 
532a					; destroy value TOS 
532a			 
532a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
532a cd 86 1d			call macro_forth_dsp_pop 
532d				endm 
# End of macro FORTH_DSP_POP
532d				       NEXTW 
532d cd 6c ee			call parse_vector 
5330 c3 b5 1e			jp macro_next 
5333				endm 
# End of macro NEXTW
5333			.V3Q: 
5333				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5333 7d				db WORD_SYS_CORE+105             
5334 47 53			dw .END            
5336 04				db 3 + 1 
5337 .. 00			db "V3@",0              
533b				endm 
# End of macro CWHEAD
533b			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
533b 2a 25 ea				ld hl, (cli_var_array+6) 
533e cd d2 1a				call forth_push_numhl 
5341				       NEXTW 
5341 cd 6c ee			call parse_vector 
5344 c3 b5 1e			jp macro_next 
5347				endm 
# End of macro NEXTW
5347			 
5347			 
5347			 
5347			 
5347			 
5347			; end of dict marker 
5347			 
5347 00			.END:    db WORD_SYS_END 
5348 00 00			dw 0 
534a 00				db 0 
534b			 
534b			; use to jp here for user dict words to save on macro expansion  
534b			 
534b			user_dict_next: 
534b				NEXTW 
534b cd 6c ee			call parse_vector 
534e c3 b5 1e			jp macro_next 
5351				endm 
# End of macro NEXTW
5351			 
5351			 
5351			user_exec: 
5351				;    ld hl, <word code> 
5351				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5351				;    call forthexec 
5351				;    jp user_dict_next   (NEXT) 
5351			        ;    <word code bytes> 
5351 eb				ex de, hl 
5352 2a b9 e5			ld hl,(os_tok_ptr) 
5355				 
5355				FORTH_RSP_NEXT 
5355 cd 79 1a			call macro_forth_rsp_next 
5358				endm 
# End of macro FORTH_RSP_NEXT
5358			 
5358			if DEBUG_FORTH_UWORD 
5358						DMARK "UEX" 
5358 f5				push af  
5359 3a 6d 53			ld a, (.dmark)  
535c 32 62 ee			ld (debug_mark),a  
535f 3a 6e 53			ld a, (.dmark+1)  
5362 32 63 ee			ld (debug_mark+1),a  
5365 3a 6f 53			ld a, (.dmark+2)  
5368 32 64 ee			ld (debug_mark+2),a  
536b 18 03			jr .pastdmark  
536d ..			.dmark: db "UEX"  
5370 f1			.pastdmark: pop af  
5371			endm  
# End of macro DMARK
5371				CALLMONITOR 
5371 cd 6f ee			call debug_vector  
5374				endm  
# End of macro CALLMONITOR
5374			endif 
5374			 
5374			 
5374			 
5374 eb				ex de, hl 
5375 22 b9 e5			ld (os_tok_ptr), hl 
5378				 
5378				; Don't use next - Skips the first word in uword. 
5378			 
5378 c3 36 1f			jp exec1 
537b			;	NEXT 
537b			 
537b			 
537b			; eof 
# End of file forth_wordsv4.asm
537b			endif 
537b			;;;;;;;;;;;;;; Debug code 
537b			 
537b			 
537b			;if DEBUG_FORTH_PARSE 
537b .. 00		.nowordfound: db "No match",0 
5384 .. 00		.compword:	db "Comparing word ",0 
5394 .. 00		.nextwordat:	db "Next word at",0 
53a1 .. 00		.charmatch:	db "Char match",0 
53ac			;endif 
53ac			if DEBUG_FORTH_JP 
53ac			.foundword:	db "Word match. Exec..",0 
53ac			endif 
53ac			;if DEBUG_FORTH_PUSH 
53ac .. 00		.enddict:	db "Dict end. Push.",0 
53bc .. 00		.push_str:	db "Pushing string",0 
53cb .. 00		.push_num:	db "Pushing number",0 
53da .. 00		.data_sp:	db "SP:",0 
53de .. 00		.wordinhl:	db "Word in HL (2/0):",0 
53f0 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5402 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5414			;endif 
5414			;if DEBUG_FORTH_MALLOC 
5414 .. 00		.push_malloc:	db "Malloc address",0 
5423			;endif 
5423			 
5423			 
5423			 
5423			; display malloc address and current data stack pointer  
5423			 
5423			malloc_error: 
5423 d5				push de 
5424 f5				push af 
5425 e5				push hl 
5426 cd b7 0b			call clear_display 
5429 11 49 54			ld de, .mallocerr 
542c 3e 00			ld a,0 
542e			;	ld de,os_word_scratch 
542e cd c9 0b			call str_at_display 
5431 3e 11			ld a, display_row_1+17 
5433 11 62 ee			ld de, debug_mark 
5436 cd c9 0b			call str_at_display 
5439 cd d9 0b			call update_display 
543c				;call break_point_state 
543c cd a8 65			call cin_wait 
543f			 
543f			;	ld a, ' ' 
543f			;	ld (os_view_disable), a 
543f cd 51 14			call bp_on 
5442 e1				pop hl 
5443 f1				pop af 
5444 d1				pop de	 
5445				CALLMONITOR 
5445 cd 6f ee			call debug_vector  
5448				endm  
# End of macro CALLMONITOR
5448 c9				ret 
5449			 
5449 .. 00		.mallocerr: 	db "Malloc Error",0 
5456			;if DEBUG_FORTH_PUSH 
5456			display_data_sp: 
5456 f5				push af 
5457			 
5457				; see if disabled 
5457			 
5457			 
5457 3a 6f ee			ld a, (debug_vector) 
545a fe c9			cp $C9  ; RET 
545c				;ld a, (os_view_disable) 
545c				;cp '*' 
545c 28 65			jr z, .skipdsp 
545e			 
545e e5				push hl 
545f e5				push hl 
5460 e5			push hl 
5461 cd b7 0b			call clear_display 
5464 e1			pop hl 
5465 7c				ld a,h 
5466 21 bd e5			ld hl, os_word_scratch 
5469 cd dd 0f			call hexout 
546c e1				pop hl 
546d 7d				ld a,l 
546e 21 bf e5			ld hl, os_word_scratch+2 
5471 cd dd 0f			call hexout 
5474 21 c1 e5			ld hl, os_word_scratch+4 
5477			;	ld a,0 
5477 36 00			ld (hl),0 
5479 11 bd e5			ld de,os_word_scratch 
547c 3e 28				ld a, display_row_2 
547e cd c9 0b				call str_at_display 
5481 11 de 53			ld de, .wordinhl 
5484 3e 00			ld a, display_row_1 
5486			 
5486 cd c9 0b				call str_at_display 
5489 11 62 ee			ld de, debug_mark 
548c 3e 11			ld a, display_row_1+17 
548e			 
548e cd c9 0b				call str_at_display 
5491			 
5491				; display current data stack pointer 
5491 11 da 53			ld de,.data_sp 
5494 3e 30				ld a, display_row_2 + 8 
5496 cd c9 0b				call str_at_display 
5499			 
5499 2a e5 e9			ld hl,(cli_data_sp) 
549c e5				push hl 
549d 7c				ld a,h 
549e 21 bd e5			ld hl, os_word_scratch 
54a1 cd dd 0f			call hexout 
54a4 e1				pop hl 
54a5 7d				ld a,l 
54a6 21 bf e5			ld hl, os_word_scratch+2 
54a9 cd dd 0f			call hexout 
54ac 21 c1 e5			ld hl, os_word_scratch+4 
54af			;	ld a,0 
54af 36 00			ld (hl),0 
54b1 11 bd e5			ld de,os_word_scratch 
54b4 3e 33				ld a, display_row_2 + 11 
54b6 cd c9 0b				call str_at_display 
54b9			 
54b9			 
54b9 cd d9 0b			call update_display 
54bc cd f0 0a			call delay1s 
54bf cd f0 0a			call delay1s 
54c2 e1				pop hl 
54c3			.skipdsp: 
54c3 f1				pop af 
54c4 c9				ret 
54c5			 
54c5			display_data_malloc: 
54c5			 
54c5 f5				push af 
54c6 e5				push hl 
54c7 e5				push hl 
54c8 e5			push hl 
54c9 cd b7 0b			call clear_display 
54cc e1			pop hl 
54cd 7c				ld a,h 
54ce 21 bd e5			ld hl, os_word_scratch 
54d1 cd dd 0f			call hexout 
54d4 e1				pop hl 
54d5 7d				ld a,l 
54d6 21 bf e5			ld hl, os_word_scratch+2 
54d9 cd dd 0f			call hexout 
54dc 21 c1 e5			ld hl, os_word_scratch+4 
54df			;	ld a,0 
54df 36 00			ld (hl),0 
54e1 11 bd e5			ld de,os_word_scratch 
54e4 3e 28				ld a, display_row_2 
54e6 cd c9 0b				call str_at_display 
54e9 11 14 54			ld de, .push_malloc 
54ec 3e 00			ld a, display_row_1 
54ee			 
54ee cd c9 0b				call str_at_display 
54f1			 
54f1				; display current data stack pointer 
54f1 11 da 53			ld de,.data_sp 
54f4 3e 30				ld a, display_row_2 + 8 
54f6 cd c9 0b				call str_at_display 
54f9			 
54f9 2a e5 e9			ld hl,(cli_data_sp) 
54fc e5				push hl 
54fd 7c				ld a,h 
54fe 21 bd e5			ld hl, os_word_scratch 
5501 cd dd 0f			call hexout 
5504 e1				pop hl 
5505 7d				ld a,l 
5506 21 bf e5			ld hl, os_word_scratch+2 
5509 cd dd 0f			call hexout 
550c 21 c1 e5			ld hl, os_word_scratch+4 
550f			;	ld a,0 
550f 36 00			ld (hl),0 
5511 11 bd e5			ld de,os_word_scratch 
5514 3e 33				ld a, display_row_2 + 11 
5516 cd c9 0b				call str_at_display 
5519			 
5519 cd d9 0b			call update_display 
551c cd f0 0a			call delay1s 
551f cd f0 0a			call delay1s 
5522 e1				pop hl 
5523 f1				pop af 
5524 c9				ret 
5525			;endif 
5525			 
5525			include "forth_autostart.asm" 
5525			; list of commands to perform at system start up 
5525			 
5525			startcmds: 
5525			;	dw test11 
5525			;	dw test12 
5525			;	dw test13 
5525			;	dw test14 
5525			;	dw test15 
5525			;	dw test16 
5525			;	dw test17 
5525			;	dw ifthtest1 
5525			;	dw ifthtest2 
5525			;	dw ifthtest3 
5525			;	dw mmtest1 
5525			;	dw mmtest2 
5525			;	dw mmtest3 
5525			;	dw mmtest4 
5525			;	dw mmtest5 
5525			;	dw mmtest6 
5525			;	dw iftest1 
5525			;	dw iftest2 
5525			;	dw iftest3 
5525			;	dw looptest1 
5525			;	dw looptest2 
5525			;	dw test1 
5525			;	dw test2 
5525			;	dw test3 
5525			;	dw test4 
5525			;	dw game2r 
5525			;	dw game2b1 
5525			;	dw game2b2 
5525			 
5525				; start up words that are actually useful 
5525			 
5525			;    dw spi1 
5525			;    dw spi2 
5525			;    dw spi3 
5525			;    dw spi4 
5525			;    dw spi5 
5525			;    dw spi6 
5525			;    dw spi7 
5525			; 
5525			;    dw spi8 
5525			;    dw spi9 
5525			;    dw spi10 
5525			 
5525			; file editor 
5525			;	dw edit1 
5525			;	dw edit2 
5525			;	dw edit3 
5525			 
5525			;	dw longread 
5525 47 59			dw clrstack 
5527 7b 59			dw type 
5529			;	dw stest 
5529 a0 59			dw strncpy 
552b 10 5b			dw list 
552d 01 5a			dw start1 
552f 11 5a			dw start2 
5531			;	dw start3 
5531			;	dw start3b 
5531			;	dw start3c 
5531			 
5531				; (unit) testing words 
5531			 
5531			;	dw mtesta 
5531			;	dw mtestb 
5531			;	dw mtestc 
5531			;	dw mtestd 
5531			;	dw mteste 
5531			 
5531				; demo/game words 
5531			 
5531			;        dw game3w 
5531			;        dw game3p 
5531			;        dw game3sc 
5531			;        dw game3vsi 
5531			;        dw game3vs 
5531				 
5531			;	dw game2b 
5531			;	dw game2bf 
5531			;	dw game2mba 
5531			;	dw game2mbas 
5531			;	dw game2mb 
5531			 
5531 41 5d			dw game1 
5533 52 5d			dw game1a 
5535 b4 5d			dw game1b 
5537 e9 5d			dw game1c 
5539 1f 5e			dw game1d 
553b 50 5e			dw game1s 
553d 64 5e			dw game1t 
553f 79 5e			dw game1f 
5541 ad 5e			dw game1z 
5543 f1 5e			dw game1zz 
5545			 
5545 7a 5b			dw test5 
5547 b2 5b			dw test6 
5549 ea 5b			dw test7 
554b fe 5b			dw test8 
554d 2a 5c			dw test9 
554f 40 5c			dw test10 
5551				 
5551 c8 5f		        dw ssv5 
5553 ac 5f		        dw ssv4 
5555 90 5f		        dw ssv3 
5557 5a 5f		        dw ssv2 
5559 e1 5f		        dw ssv1 
555b 29 60		        dw ssv1cpm 
555d			;	dw keyup 
555d			;	dw keydown 
555d			;	dw keyleft 
555d			;	dw keyright 
555d			;	dw 	keyf1 
555d			;	dw keyf2 
555d			;	dw keyf3 
555d			;	dw keyf4 
555d			;	dw keyf5 
555d			;	dw keyf6 
555d			;	dw keyf7 
555d			;	dw keyf8 
555d			;	dw keyf9 
555d			;	dw keyf10 
555d			;	dw keyf11 
555d			;	dw keyf12 
555d			;	dw keytab 
555d			;	dw keycr 
555d			;	dw keyhome 
555d			;	dw keyend 
555d			;	dw keybs 
555d 00 00			db 0, 0	 
555f			 
555f			 
555f			; File Editor 
555f			 
555f			; ( id - ) use 'e' to edit the displayed line 
555f .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5580 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
55b5			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
55b5 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
55ed			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
55ed			 
55ed			; SPI Net support words 
55ed			 
55ed			; v0! = node to send to 
55ed			; ( str count - ) 
55ed .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5646			 
5646			; spiputc ( char node - ) 
5646 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
567a			; spiputc ( u node - ) 
567a .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
56a8			 
56a8			; spigetc ( - n ) 
56a8 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
56d1			 
56d1			; getnode ( - n ) 
56d1 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
56fe			 
56fe			; ( str node - )  
56fe .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5764			; store string ( str i - ) 
5764			 
5764			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5764 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
57b9			 
57b9			; get string ( addr i -  )    TO FIX 
57b9			 
57b9 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5811			 
5811			 
5811			; NETCHAT (TODO) 
5811			; Program to allow two nodes to chat with eachother 
5811			; 
5811			; v0 - target node 
5811			;  
5811			; accept input at 0,0 
5811			; if input is string send spitype to target node 
5811			; starting at row 2,0 , while spigetchr is not zero ->  
5811			; 
5811			; 
5811			; TODO add paging of get request 
5811			 
5811			; ( node - ) 
5811 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5830 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5888 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5900			 
5900			 
5900			; Long read of currently open file 
5900 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5947			 
5947			; clear stack  
5947			 
5947 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
597b			 
597b			; type ( addr count - ) 
597b .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
59a0			 
59a0			; some direct memory words 
59a0			; strncpy ( len t f -- t ) 
59a0			 
59a0 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5a01			 
5a01 .. 00		start1:     	db ": bpon $00 bp ;",0 
5a11 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5a22 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5a9d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5afd			 
5afd .. 00		tuck:         db ": tuck swap over ;", 0 
5b10			 
5b10			; a handy word to list items on the stack 
5b10			 
5b10 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5b7a			 
5b7a			 
5b7a			; test stack  
5b7a			; rnd8 stest 
5b7a			 
5b7a			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5b7a			 
5b7a			; random malloc and free cycles 
5b7a			 
5b7a			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b7a			 
5b7a			; fixed malloc and free cycles 
5b7a			 
5b7a			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b7a			 
5b7a			; fixed double string push and drop cycle  
5b7a			 
5b7a			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5b7a			 
5b7a			; consistent fixed string push and drop cycle  
5b7a			 
5b7a			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b7a			 
5b7a			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b7a			 
5b7a			;test1:		db ": aa 1 2 3 ;", 0 
5b7a			;test2:     	db "111 aa 888 999",0 
5b7a			;test3:     	db ": bb 77 ;",0 
5b7a			;test4:     	db "$02 $01 do i . loop bb",0 
5b7a			 
5b7a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5bb2 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5bea .. 00		test7:     	db ": box hline vline ;",0 
5bfe .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5c2a .. 00		test9:     	db ": sw $01 adsp world ;",0 
5c40 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5c65			;test11:     	db "hello create .",0 
5c65			;test12:     	db "hello2 create .",0 
5c65			 
5c65			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5c65			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5c65			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5c65			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5c65			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5c65			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5c65			 
5c65			;iftest1:     	db "$0001 IF cls .",0 
5c65			;iftest2:     	db "$0000 IF cls .",0 
5c65			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5c65			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5c65			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5c65			 
5c65			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c65			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c65			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c65			 
5c65			 
5c65 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5c89 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5cb9 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5cde .. 00		sound4: db ": cha $00 ; ",0 
5ceb .. 00		sound5: db ": chb $20 ; ",0 
5cf8 .. 00		sound6: db ": chc $40 ; ",0 
5d05 .. 00		sound7: db ": chd $60 ; ",0 
5d12 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5d2a .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5d41			 
5d41			 
5d41			 
5d41			 
5d41			; a small guess the number game 
5d41			 
5d41 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5d52 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5db4			 
5db4 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5de9 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5e1f .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5e50 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5e64 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5e79 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ead .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5ef1			 
5ef1			; Using 'ga' save a high score across multiple runs using external storage 
5ef1			 
5ef1 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5f5a			 
5f5a			 
5f5a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5f5a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f5a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f5a			 
5f5a			; simple screen saver to test code memory reuse to destruction 
5f5a			 
5f5a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5f90 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5fac .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5fc8 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5fe1 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6029 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6080			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6080			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6080			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6080			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6080			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6080			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6080			 
6080			 
6080			 
6080			; minesweeper/battleship finding game 
6080			; draws a game board of random ship/mine positions 
6080			; user enters coords to see if it hits on 
6080			; game ends when all are hit 
6080			; when hit or miss says how many may be in the area 
6080			 
6080			; setup the game board and then hide it 
6080			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6080			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6080			;; prompt for where to target 
6080			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6080			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6080			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6080			;game2mbht:      db ": mbckht nop ;",0 
6080			;game2mbms:      db ": mbcms nop ;",0 
6080			; TODO how many might be near by 
6080			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6080			 
6080			; Game 3 
6080			 
6080			; Vert scroller ski game - avoid the trees! 
6080			 
6080			; v0 score (ie turns) 
6080			; v1 player pos 
6080			; v2 left wall 
6080			; v3 right wall 
6080			 
6080			; Draw side walls randomly 
6080			 
6080			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6080			 
6080			; Draw player 
6080			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6080			 
6080			; TODO Get Key 
6080			 
6080			; TODO Move left right 
6080			 
6080			; scroll and move walls a bit 
6080			 
6080			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6080			 
6080			; main game loop 
6080			 
6080			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6080			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6080			 
6080			; key board defs 
6080			 
6080 .. 00		keyup:       db ": keyup $05 ;",0 
608e .. 00		keydown:       db ": keydown $0a ;",0 
609e .. 00		keyleft:       db ": keyleft $0b ;",0 
60ae .. 00		keyright:       db ": keyright $0c ;",0 
60bf .. 00		keyf1:       db ": keyf1 $10 ;",0 
60cd .. 00		keyf2:       db ": keyf2 $11 ;",0 
60db .. 00		keyf3:       db ": keyf3 $12 ;",0 
60e9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60f7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6105 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6113 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6121 .. 00		keyf8:       db ": keyf8 $17 ;",0 
612f .. 00		keyf9:       db ": keyf9 $18 ;",0 
613d .. 00		keyf10:       db ": keyf10 $19 ;",0 
614c .. 00		keyf11:       db ": keyf11 $1a ;",0 
615b .. 00		keyf12:       db ": keyf12 $1b ;",0 
616a			 
616a .. 00		keytab:       db ": keytab $09 ;",0 
6179 .. 00		keycr:       db ": keycr $0d ;",0 
6187 .. 00		keyhome:       db ": keyhome $0e ;",0 
6197 .. 00		keyend:       db ": keyend $0f ;",0 
61a6 .. 00		keybs:       db ": keybs $08 ;",0 
61b4			 
61b4			   
61b4			 
61b4			 
61b4			 
61b4			; eof 
# End of file forth_autostart.asm
61b4			 
61b4			 
61b4			 
61b4			; stack over and underflow checks 
61b4			 
61b4			; init the words to detect the under/overflow 
61b4			 
61b4			chk_stk_init: 
61b4				; a vague random number to check so we dont get any "lucky" hits 
61b4 3e 2d			ld a, 45 
61b6 6f				ld l, a 
61b7 00				nop 
61b8 3e 17			ld a, 23 
61ba 67				ld h, a 
61bb			 
61bb 22 94 e2			ld (chk_word), hl     ; the word we need to check against 
61be			 
61be			;	ld (chk_stund), hl	; stack points.... 
61be 22 00 ef			ld (chk_stovr), hl 
61c1 22 e3 e9			ld (chk_ret_und), hl 
61c4 22 a1 e9			ld (chk_ret_ovr), hl 
61c7 22 1f e9			ld (chk_loop_ovr), hl 
61ca 22 1d e8			ld (chk_data_ovr), hl 
61cd c9				ret 
61ce				 
61ce			check_stacks: 
61ce				; check all stack words 
61ce			 
61ce e5				push hl 
61cf d5				push de 
61d0			 
61d0			;	ld de,(chk_word) 
61d0			;	ld hl, (chk_stund)	; stack points.... 
61d0			;	if DEBUG_STK_FAULT 
61d0			;		DMARK "FAa" 
61d0			;		CALLMONITOR 
61d0			;	endif 
61d0			;	call cmp16 
61d0			;	jp z, .chk_faulta 
61d0			; 
61d0			;	ld de, sfaultsu 
61d0			;	jp .chk_fault 
61d0			 
61d0 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61d3 ed 5b 94 e2		ld de,(chk_word) 
61d7				if DEBUG_STK_FAULT 
61d7					DMARK "FAb" 
61d7					CALLMONITOR 
61d7				endif 
61d7 cd ff 0d			call cmp16 
61da 28 06			jr z, .chk_fault1 
61dc 11 80 62			ld de, sfaultso 
61df c3 31 62			jp .chk_fault 
61e2			.chk_fault1:  
61e2 2a e3 e9			ld hl, (chk_ret_und) 
61e5 ed 5b 94 e2		ld de,(chk_word) 
61e9				if DEBUG_STK_FAULT 
61e9					DMARK "FAU" 
61e9					CALLMONITOR 
61e9				endif 
61e9 cd ff 0d			call cmp16 
61ec ca f5 61			jp z, .chk_fault2 
61ef 11 90 62			ld de, sfaultru 
61f2 c3 31 62			jp .chk_fault 
61f5			.chk_fault2:  
61f5 2a a1 e9			ld hl, (chk_ret_ovr) 
61f8 ed 5b 94 e2		ld de,(chk_word) 
61fc				if DEBUG_STK_FAULT 
61fc					DMARK "FA1" 
61fc					CALLMONITOR 
61fc				endif 
61fc cd ff 0d			call cmp16 
61ff ca 08 62			jp z, .chk_fault3 
6202 11 9e 62			ld de, sfaultro 
6205 c3 31 62			jp .chk_fault 
6208			.chk_fault3:  
6208 2a 1f e9			ld hl, (chk_loop_ovr) 
620b ed 5b 94 e2		ld de,(chk_word) 
620f				if DEBUG_STK_FAULT 
620f					DMARK "FA2" 
620f					CALLMONITOR 
620f				endif 
620f cd ff 0d			call cmp16 
6212 ca 1b 62			jp z, .chk_fault4 
6215 11 b8 62			ld de, sfaultlo 
6218 c3 31 62			jp .chk_fault 
621b			.chk_fault4:  
621b 2a 1d e8			ld hl, (chk_data_ovr) 
621e ed 5b 94 e2		ld de,(chk_word) 
6222				if DEBUG_STK_FAULT 
6222					DMARK "FA3" 
6222					CALLMONITOR 
6222				endif 
6222 cd ff 0d			call cmp16 
6225 ca 2e 62			jp z, .chk_fault5 
6228 11 d2 62			ld de, sfaultdo 
622b c3 31 62			jp .chk_fault 
622e			 
622e			 
622e			.chk_fault5:  
622e d1				pop de 
622f e1				pop hl 
6230			 
6230 c9				ret 
6231			 
6231 cd b7 0b		.chk_fault: 	call clear_display 
6234 3e 28				ld a, display_row_2 
6236 cd c9 0b				call str_at_display 
6239 11 62 62				   ld de, .stackfault 
623c 3e 00				ld a, display_row_1 
623e cd c9 0b				call str_at_display 
6241 11 62 ee				    ld de, debug_mark 
6244 3e 11				ld a, display_row_1+17 
6246 cd c9 0b				call str_at_display 
6249 cd d9 0b				call update_display 
624c			 
624c				; prompt before entering montior for investigating issue 
624c			 
624c 3e 78			ld a, display_row_4 
624e 11 b4 17			ld de, endprog 
6251			 
6251 cd d9 0b			call update_display		 
6254			 
6254 cd 4a 1a			call next_page_prompt 
6257			 
6257 d1				pop de 
6258 e1				pop hl 
6259 cd 08 18				call monitor 
625c cd 5b 1e				call forth_warmstart 
625f c3 06 17				jp warmstart_afterauto 
6262					;jp 0 
6262					;halt 
6262			 
6262			 
6262			 
6262 .. 00		.stackfault: 	db "Stack fault:",0 
626f			 
626f .. 00		sfaultsu: 	db	"Stack under flow",0 
6280 .. 00		sfaultso: 	db	"Stack over flow",0 
6290 .. 00		sfaultru:	db "RTS underflow",0 
629e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
62b8 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62d2 .. 00		sfaultdo:	db "DTS overflow", 0 
62df			 
62df			 
62df			fault_dsp_under: 
62df 11 f1 62			ld de, .dsp_under 
62e2 c3 a7 63			jp .show_fault 
62e5			 
62e5			fault_rsp_under: 
62e5 11 ff 62			ld de, .rsp_under 
62e8 c3 a7 63			jp .show_fault 
62eb			fault_loop_under: 
62eb 11 0d 63			ld de, .loop_under 
62ee c3 a7 63			jp .show_fault 
62f1			 
62f1 .. 00		.dsp_under: db "DSP Underflow",0 
62ff .. 00		.rsp_under: db "RSP Underflow",0 
630d .. 00		.loop_under: db "LOOP Underflow",0 
631c			 
631c			 
631c d5			type_faultn: 	push de 
631d e5					push hl 
631e cd b7 0b				call clear_display 
6321 11 4b 63				   ld de, .typefaultn 
6324 3e 00				ld a, display_row_1 
6326 cd c9 0b				call str_at_display 
6329 11 62 ee				    ld de, debug_mark 
632c 3e 11				ld a, display_row_1+17 
632e cd c9 0b				call str_at_display 
6331 cd d9 0b				call update_display 
6334			 
6334				; prompt before entering montior for investigating issue 
6334			 
6334 3e 78			ld a, display_row_4 
6336 11 b4 17			ld de, endprog 
6339			 
6339 cd d9 0b			call update_display		 
633c			 
633c cd 4a 1a			call next_page_prompt 
633f			 
633f e5					push hl 
6340 d5					push de 
6341 cd 08 18				call monitor 
6344 cd 5b 1e				call forth_warmstart 
6347 c3 06 17				jp warmstart_afterauto 
634a 76					halt 
634b			 
634b			 
634b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6362			 
6362 d5			type_faults: 	push de 
6363 e5					push hl 
6364 cd b7 0b				call clear_display 
6367 11 90 63				   ld de, .typefaults 
636a 3e 00				ld a, display_row_1 
636c cd c9 0b				call str_at_display 
636f 11 62 ee				    ld de, debug_mark 
6372 3e 11				ld a, display_row_1+17 
6374 cd c9 0b				call str_at_display 
6377 cd d9 0b				call update_display 
637a			 
637a				; prompt before entering montior for investigating issue 
637a			 
637a 3e 78			ld a, display_row_4 
637c 11 b4 17			ld de, endprog 
637f			 
637f cd d9 0b			call update_display		 
6382			 
6382 cd 4a 1a			call next_page_prompt 
6385			 
6385 e1					pop hl 
6386 d1					pop de 
6387 cd 08 18				call monitor 
638a cd 5b 1e				call forth_warmstart 
638d c3 06 17				jp warmstart_afterauto 
6390			 
6390			 
6390 .. 00		.typefaults: db "STR Type Expected TOS!",0 
63a7			 
63a7			.show_fault: 	 
63a7 d5					push de 
63a8 cd b7 0b				call clear_display 
63ab d1					pop de 
63ac 3e 00				ld a, display_row_1 
63ae cd c9 0b				call str_at_display 
63b1 11 62 ee				    ld de, debug_mark 
63b4 3e 11				ld a, display_row_1+17 
63b6 cd c9 0b				call str_at_display 
63b9 cd d9 0b				call update_display 
63bc			 
63bc				; prompt before entering montior for investigating issue 
63bc			 
63bc 3e 78			ld a, display_row_4 
63be 11 b4 17			ld de, endprog 
63c1			 
63c1 cd d9 0b			call update_display		 
63c4			 
63c4 cd 4a 1a			call next_page_prompt 
63c7			 
63c7 e1					pop hl 
63c8 d1					pop de 
63c9 cd 08 18				call monitor 
63cc			; do a dump to cli and not warmstart so we preserve all of the uwords.  
63cc			; TODO Make optional fault restart to cli or warm boot? 
63cc					;jp warmstart 
63cc c3 49 17				jp cli 
63cf 76					halt 
63d0			 
63d0			 
63d0			; handle the auto run of code from files in storage 
63d0			 
63d0			 
63d0			include "forth_startup.asm" 
63d0			; Which startup method to use? 
63d0			; 
63d0			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
63d0			; followed by loading of a list of scripts in eeprom 
63d0			 
63d0			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
63d0			; from eeprom 
63d0			 
63d0			; Select with define in main stubs 
63d0			 
63d0			if STARTUP_V1 
63d0				include "forth_startupv1.asm" 
63d0			; Startup script loading version 1 
63d0			 
63d0			; If SE storage is available first stage is to use the selected file 
63d0			; then go through the eeprom list 
63d0			 
63d0 .. 00		sprompt1: db "Startup load...",0 
63e0 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63f6			 
63f6			 
63f6			 
63f6			 
63f6			forth_startup: 
63f6 21 25 55			ld hl, startcmds 
63f9 3e 00			ld a, 0 
63fb 32 de e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63fe			 
63fe e5			.start1:	push hl 
63ff cd b7 0b			call clear_display 
6402 11 d0 63			ld de, sprompt1 
6405 3e 00		        ld a, display_row_1 
6407 cd c9 0b			call str_at_display 
640a 11 e0 63			ld de, sprompt2 
640d 3e 28		        ld a, display_row_2 
640f cd c9 0b			call str_at_display 
6412 e1				pop hl 
6413 e5				push hl 
6414 5e				ld e,(hl) 
6415 23				inc hl 
6416 56				ld d,(hl) 
6417 3e 50		        ld a, display_row_3 
6419 cd c9 0b			call str_at_display 
641c cd d9 0b			call update_display 
641f			 
641f			 
641f 3a de e6			ld a, (os_last_cmd) 
6422 fe 00			cp 0 
6424 28 05			jr z, .startprompt 
6426 cd e4 0a			call delay250ms 
6429 18 24			jr .startdo 
642b				 
642b				 
642b			 
642b			.startprompt: 
642b			 
642b 3e 9f			ld a,display_row_4 + display_cols - 1 
642d 11 48 1a		        ld de, endprg 
6430 cd c9 0b			call str_at_display 
6433 cd d9 0b			call update_display 
6436 cd f0 0a			call delay1s 
6439 cd a8 65			call cin_wait 
643c						 
643c fe 2a			cp '*' 
643e 28 5e			jr z, .startupend1 
6440 fe 23			cp '#' 
6442 20 07			jr nz, .startno 
6444 3e 01			ld a, 1 
6446 32 de e6			ld (os_last_cmd),a 
6449 18 04			jr .startdo 
644b fe 31		.startno:	cp '1' 
644d 28 3a			jr z,.startnxt  
644f			 
644f				; exec startup line 
644f			.startdo:	 
644f e1				pop hl 
6450 e5				push hl 
6451				 
6451 5e				ld e,(hl) 
6452 23				inc hl 
6453 56				ld d,(hl) 
6454 eb				ex de,hl 
6455			 
6455 e5				push hl 
6456			 
6456 3e 00			ld a, 0 
6458				;ld a, FORTH_END_BUFFER 
6458 cd 44 11			call strlent 
645b 23				inc hl   ; include zero term to copy 
645c 06 00			ld b,0 
645e 4d				ld c,l 
645f e1				pop hl 
6460 11 b8 e2			ld de, scratch 
6463 ed b0			ldir 
6465			 
6465			 
6465 21 b8 e2			ld hl, scratch 
6468 cd fb 1e			call forthparse 
646b cd 33 1f			call forthexec 
646e cd 55 1e			call forthexec_cleanup 
6471			 
6471 3e 78			ld a, display_row_4 
6473 11 b4 17			ld de, endprog 
6476			 
6476 cd d9 0b			call update_display		 
6479			 
6479 3a de e6			ld a, (os_last_cmd) 
647c fe 00			cp 0 
647e 20 09			jr nz, .startnxt 
6480 cd 4a 1a			call next_page_prompt 
6483 cd b7 0b		        call clear_display 
6486 cd d9 0b			call update_display		 
6489			 
6489				; move onto next startup line? 
6489			.startnxt: 
6489			 
6489 cd e4 0a			call delay250ms 
648c e1				pop hl 
648d			 
648d 23				inc hl 
648e 23				inc hl 
648f			 
648f e5				push hl 
6490 5e				ld e, (hl) 
6491 23				inc hl 
6492 56				ld d, (hl) 
6493 e1				pop hl 
6494				; TODO replace 0 test 
6494			 
6494 eb				ex de, hl 
6495 cd 0a 0e			call ishlzero 
6498			;	ld a,e 
6498			;	add d 
6498			;	cp 0    ; any left to do? 
6498 eb				ex de, hl 
6499 c2 fe 63			jp nz, .start1 
649c 18 01			jr .startupend 
649e			 
649e e1			.startupend1: pop hl 
649f			.startupend: 
649f			 
649f cd b7 0b			call clear_display 
64a2 cd d9 0b			call update_display 
64a5 c9				ret 
64a6			if STORAGE_SE 
64a6			 
64a6			sprompt3: db "Loading from start-up file?:",0 
64a6			sprompt4: db "(Y=Any key/N=No)",0 
64a6			 
64a6			 
64a6			forth_autoload: 
64a6			 
64a6				; load block 0 of store 1 
64a6				 
64a6				ld a, $fe      ; bit 0 clear 
64a6				ld (spi_device), a 
64a6			 
64a6				call storage_get_block_0 
64a6			 
64a6				ld a, (store_page+STORE_0_AUTOFILE) 
64a6			 
64a6				cp 0 
64a6				ret z     ; auto start not enabled 
64a6			 
64a6				call clear_display 
64a6			 
64a6				; set bank 
64a6			 
64a6					ld a, (store_page+STORE_0_BANKRUN) 
64a6					ld (spi_device), a 
64a6			 
64a6				; get file id to load from and get the file name to display 
64a6			 
64a6					ld a, (store_page+STORE_0_FILERUN) 
64a6			 
64a6					ld l, 0 
64a6					ld h, a 
64a6					ld de, store_page 
64a6			 
64a6					if DEBUG_FORTH_WORDS 
64a6						DMARK "ASp" 
64a6						CALLMONITOR 
64a6					endif 
64a6					call storage_read 
64a6			 
64a6					if DEBUG_FORTH_WORDS 
64a6						DMARK "ASr" 
64a6						CALLMONITOR 
64a6					endif 
64a6			 
64a6					call ishlzero 
64a6					ret z             ; file not found 
64a6			 
64a6					ld a, display_row_2 + 10 
64a6					ld de, store_page+3 
64a6					call str_at_display 
64a6				 
64a6			; 
64a6			 
64a6				ld a, display_row_1+5 
64a6				ld de, sprompt3 
64a6				call str_at_display 
64a6				ld a, display_row_3+15 
64a6				ld de, sprompt4 
64a6				call str_at_display 
64a6			 
64a6				call update_display 
64a6			 
64a6				call cin_wait 
64a6				cp 'n' 
64a6				ret z 
64a6				cp 'N' 
64a6				ret z 
64a6			 
64a6				call delay1s 
64a6			 
64a6				ld a, (store_page+2) 
64a6				ld (store_openmaxext), a    ; save count of ext 
64a6				ld a, 1  
64a6				ld (store_openext), a    ; save count of ext 
64a6			 
64a6			.autof:  
64a6				ld l , a 
64a6				 
64a6				ld a, (store_page) 
64a6				ld h, a	 
64a6				ld de, store_page 
64a6					if DEBUG_FORTH_WORDS 
64a6						DMARK "ASl" 
64a6						CALLMONITOR 
64a6					endif 
64a6					call storage_read 
64a6				call ishlzero 
64a6				ret z 
64a6			;	jr z, .autoend 
64a6			 
64a6					if DEBUG_FORTH_WORDS 
64a6						DMARK "ASc" 
64a6						CALLMONITOR 
64a6					endif 
64a6				ld de, store_page+2 
64a6				ld a, display_row_4 
64a6				call str_at_display 
64a6			 
64a6				call update_display 
64a6				call delay250ms 
64a6			 
64a6			 
64a6			 
64a6				ld hl, store_page+2 
64a6				call forthparse 
64a6				call forthexec 
64a6				call forthexec_cleanup 
64a6			 
64a6				 
64a6				ld a, (store_openext) 
64a6				inc a 
64a6				ld (store_openext), a    ; save count of ext 
64a6			 
64a6				jr .autof 
64a6			;.autofdone: 
64a6			; 
64a6			;		if DEBUG_FORTH_WORDS 
64a6			;			DMARK "ASx" 
64a6			;			CALLMONITOR 
64a6			;		endif 
64a6			;;	call clear_display 
64a6			;	ret 
64a6			 
64a6			 
64a6			 
64a6			endif 
# End of file forth_startupv1.asm
64a6			endif 
64a6			if STARTUP_V2 
64a6				include "forth_startupv2.asm" 
64a6			endif 
64a6			 
# End of file forth_startup.asm
64a6			 
64a6			; eof 
# End of file forth_kernel.asm
64a6			;include "nascombasic.asm" 
64a6			;include "basicZ80.asm" 
64a6			 
64a6			 
64a6			 
64a6			; find out where the code ends if loaded into RAM (for SC114) 
64a6			;endofcode:  
64a6			;	nop 
64a6			 
64a6			 
64a6			; jump to nmi vector 
64a6			 
64a6			init_nmi: 
64a6 3e c9			ld a, $c9   ; RET 
64a8 32 72 ee			ld (nmi_vector), a 
64ab c9				ret 
64ac			nmi: 
64ac e5				push hl 
64ad d5				push de 
64ae c5				push bc 
64af f5				push af 
64b0 cd 72 ee			call nmi_vector 
64b3 f5				push af 
64b4 c5				push bc 
64b5 d5				push de 
64b6 e5				push hl 
64b7 ed 4d			reti 
64b9			 
64b9			 
64b9			; eof 
64b9			 
# End of file main.asm
64b9			;include "firmware_lcd_4x40.asm" 
64b9			;;include "firmware_lcd_4x20.asm" 
64b9			include "firmware_cpm_display.asm" 
64b9			 
64b9			; Serial display interface for SC114 
64b9			 
64b9			 
64b9			display_row_1: equ 0 
64b9			display_row_2: equ display_row_1+display_cols 
64b9			display_row_3: equ display_row_2 + display_cols 
64b9			display_row_4: equ display_row_3 + display_cols 
64b9			 
64b9			kLCDWidth:  EQU display_cols             ;Width in characters 
64b9			kLCD_Line1: EQU 0x00  
64b9			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
64b9			; E1 
64b9			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
64b9			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
64b9			 
64b9			lcd_init: 
64b9				; no init as handled by the SCM bios 
64b9 c9				ret 
64ba			 
64ba			 
64ba			; low level functions for direct screen writes 
64ba			 
64ba			; output char at pos? 
64ba			fLCD_Str: 
64ba			        ;out (SC114_SIO_1_OUT),a 
64ba c5				push bc 
64bb d5				push de 
64bc 5f				ld e, a 
64bd			; TODO Replace with CP/M BIOS call 
64bd 0e 02			ld c, $02 
64bf cd 05 00			call 5 
64c2 d1				pop de 
64c3 c1				pop bc 
64c4 c9				ret 
64c5			 
64c5			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
64c5			fLCD_Pos: 
64c5				; use ASCII escape to position 
64c5			        ;out (SC114_SIO_1_OUT),a 
64c5 c5				push bc 
64c6 d5				push de 
64c7 5f				ld e, a 
64c8 0e 02			ld c, $02 
64ca			; TODO Replace with CP/M BIOS call 
64ca cd 05 00			call 5 
64cd d1				pop de 
64ce c1				pop bc 
64cf			 
64cf c9				ret 
64d0			 
64d0			; output char at pos 
64d0			fLCD_Data: 
64d0			      ;  out (SC114_SIO_1_OUT),a 
64d0 c5				push bc 
64d1 d5				push de 
64d2 0e 02			ld c, $02 
64d4 5f				ld e, a 
64d5			; TODO Replace with CP/M BIOS call 
64d5 cd 05 00			call 5 
64d8 d1				pop de 
64d9 c1				pop bc 
64da			 
64da c9				ret 
64db			 
64db			; ascii cls  
64db			 
64db 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64df			 
64df 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
64f6			;.clscpm: db 3, $3c,"$" 
64f6			 
64f6			; write the frame buffer given in hl to hardware  
64f6			write_display: 
64f6			 
64f6			API: equ 0 
64f6			 
64f6			if API 
64f6				push bc 
64f6				ld b, 4 
64f6			 
64f6			        ld (display_write_tmp), hl 	  
64f6			 
64f6				; clear and home cursor 
64f6			 
64f6				ld c, 9 
64f6				ld de, .cls 
64f6			; TODO Replace with CP/M BIOS call 
64f6				call 5 
64f6			 
64f6			 
64f6			.writeln: 
64f6			 
64f6				ld de, (display_write_tmp) 
64f6				ld c, 6 
64f6			; TODO Replace with CP/M BIOS call 
64f6				rst $30 
64f6				ld c, 7 
64f6				rst $30 
64f6			 
64f6				ld hl, (display_write_tmp) 
64f6				ld de, display_cols 
64f6				add hl,de 
64f6				ld (display_write_tmp),hl 
64f6			 
64f6				djnz  .writeln 
64f6			 
64f6				pop bc 
64f6			 
64f6			 
64f6				ret 
64f6			endif 
64f6 e5				push hl 
64f7 c5				push bc 
64f8 d5				push de 
64f9			 
64f9			;	ld c, 2 
64f9			;	;ld de, .cls 
64f9			;	ld a, 27 
64f9			;	rst $30 
64f9			;	ld c, 2 
64f9			;	;ld de, .cls 
64f9			;	ld a, '[' 
64f9			;	rst $30 
64f9			; 
64f9			;	ld c, 2 
64f9			;	;ld de, .cls 
64f9			;	ld a, 'H' 
64f9			;	rst $30 
64f9			; 
64f9			 
64f9			 
64f9			; lots of CR/LF 
64f9			;	ld c, 9 
64f9			;	ld de, .clscpm 
64f9			;	call 5 
64f9			 
64f9			; xterm cls 
64f9 0e 02			ld c, 2 
64fb 1e 1b			ld e, 27 
64fd cd 05 00			call 5 
6500			; cls causes too much flicker 
6500			;	ld c, 2 
6500			;	ld e, 'c' 
6500			;	call 5 
6500			 
6500			; use xterm home instead 
6500 0e 02			ld c, 2 
6502 1e 5b			ld e, '[' 
6504 cd 05 00			call 5 
6507 0e 02			ld c, 2 
6509 1e 48			ld e, 'H' 
650b cd 05 00			call 5 
650e			LLL: equ 0 
650e			 
650e			if LLL 
650e			 
650e				ld c, 2 
650e				;ld de, .cls 
650e				ld e, 27 
650e			; TODO Replace with CP/M BIOS call 
650e				call 5 
650e			 
650e			 
650e				ld c, 2 
650e				;ld de, .cls 
650e				ld e, '[' 
650e			; TODO Replace with CP/M BIOS call 
650e				call 5 
650e				ld c, 2 
650e				;ld de, .cls 
650e				ld e, '2' 
650e			; TODO Replace with CP/M BIOS call 
650e				call 5 
650e				ld c, 2 
650e				;ld de, .cls 
650e				ld e, 'J' 
650e			; TODO Replace with CP/M BIOS call 
650e				call 5 
650e			 
650e			endif 
650e			 
650e d1				pop de 
650f c1				pop bc 
6510 e1				pop hl 
6511			 
6511			 
6511 22 c0 eb		        ld (display_write_tmp), hl 	  
6514 3e 00			ld a, kLCD_Line1 
6516			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6516 06 28			ld b, display_cols 
6518 ed 5b c0 eb		ld de, (display_write_tmp) 
651c cd 9f 65			call write_len_string 
651f				 
651f			 
651f e5			push hl 
6520 d5			push de 
6521 c5			push bc 
6522 0e 02			ld c, 2 
6524 1e 0a			ld e, 10 
6526 cd 05 00			call 5 
6529 0e 02			ld c, 2 
652b 1e 0d			ld e, 13 
652d cd 05 00			call 5 
6530			; TODO Replace with CP/M BIOS call 
6530				;rst $30 
6530 c1			pop bc 
6531 d1			pop de 
6532 e1			pop hl 
6533			 
6533				 
6533 2a c0 eb			ld hl, (display_write_tmp) 
6536 11 28 00			ld de, display_cols 
6539 19				add hl,de 
653a 22 c0 eb			ld (display_write_tmp),hl 
653d			 
653d				 
653d 3e 28			ld a, kLCD_Line2 
653f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
653f 06 28			ld b, display_cols 
6541 ed 5b c0 eb		ld de, (display_write_tmp) 
6545 cd 9f 65			call write_len_string 
6548				 
6548 2a c0 eb			ld hl, (display_write_tmp) 
654b 11 28 00			ld de, display_cols 
654e 19				add hl,de 
654f 22 c0 eb			ld (display_write_tmp),hl 
6552			 
6552 e5			push hl 
6553 d5			push de 
6554 c5			push bc 
6555 0e 07			ld c, 7 
6557			; TODO Replace with CP/M BIOS call 
6557				;rst $30 
6557 0e 02			ld c, 2 
6559 1e 0a			ld e, 10 
655b cd 05 00			call 5 
655e 0e 02			ld c, 2 
6560 1e 0d			ld e, 13 
6562 cd 05 00			call 5 
6565 c1			pop bc 
6566 d1			pop de 
6567 e1			pop hl 
6568			 
6568				 
6568 3e 50			ld a, kLCD_Line3 
656a			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
656a 06 28			ld b, display_cols 
656c ed 5b c0 eb		ld de, (display_write_tmp) 
6570 cd 9f 65			call write_len_string 
6573				 
6573 2a c0 eb			ld hl, (display_write_tmp) 
6576 11 28 00			ld de, display_cols 
6579 19				add hl,de 
657a 22 c0 eb			ld (display_write_tmp),hl 
657d			 
657d e5			push hl 
657e d5			push de 
657f c5			push bc 
6580 0e 07			ld c, 7 
6582			; TODO Replace with CP/M BIOS call 
6582				;rst $30 
6582 0e 02			ld c, 2 
6584 1e 0a			ld e, 10 
6586 cd 05 00			call 5 
6589 0e 02			ld c, 2 
658b 1e 0d			ld e, 13 
658d cd 05 00			call 5 
6590 c1			pop bc 
6591 d1			pop de 
6592 e1			pop hl 
6593			 
6593				 
6593 3e 78			ld a, kLCD_Line4 
6595			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
6595 06 28			ld b, display_cols 
6597 ed 5b c0 eb		ld de, (display_write_tmp) 
659b cd 9f 65			call write_len_string 
659e c9					ret 
659f			 
659f			 
659f				; write out a fixed length string given in b from de 
659f			 
659f 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
65a0 cd d0 64		            CALL fLCD_Data      ;Write character to display 
65a3 13				inc de 
65a4 10 f9			djnz write_len_string 
65a6 c9				ret 
65a7			 
65a7			 
65a7			; eof 
# End of file firmware_cpm_display.asm
65a7			;include "firmware_key_5x10.asm" 
65a7			;;include "firmware_key_4x10.asm" 
65a7			include "firmware_key_cpm.asm" 
65a7			; Serial keyboard interface for SC114 
65a7			 
65a7			 
65a7			key_init: 
65a7				; no init as handled by the SCM bios 
65a7 c9				ret 
65a8			 
65a8			 
65a8			cin_wait: 
65a8			;	ld a, 0 
65a8			;	ret 
65a8			 
65a8				;in a,(SC114_SIO_1_IN) 
65a8			        ; Use SCM API to get from whatever console device we are using 
65a8			 
65a8			; TODO Replace with CP/M BIOS call 
65a8 c5				push bc 
65a9 0e 01			ld c, $01 
65ab cd 05 00			call 5 
65ae c1				pop bc 
65af c9				ret 
65b0			 
65b0			cinndb:  
65b0			cin: 
65b0			 
65b0			 
65b0 c5				push bc 
65b1			 
65b1				; any key waiting to process? 
65b1			; TODO Replace with CP/M BIOS call 
65b1 0e 06			ld c, $06 
65b3 cd 05 00			call 5 
65b6 28 0d			jr z, .cin_skip 
65b8			 
65b8				; yep, get it 
65b8			 
65b8 0e 01			ld c, $01 
65ba			; TODO Replace with CP/M BIOS call 
65ba cd 05 00			call 5 
65bd			 
65bd fe 7f			cp $7f     ; back space 
65bf 20 02			jr nz, .skipbs 
65c1 3e 08			ld a, KEY_BS 
65c3			.skipbs: 
65c3			 
65c3 c1				pop bc 
65c4 c9				ret 
65c5			.cin_skip: 
65c5 3e 00			ld a, 0 
65c7 c1				pop bc 
65c8 c9				ret 
65c9			 
65c9			 
65c9			 
65c9			 
# End of file firmware_key_cpm.asm
65c9			endofcode:  
65c9			baseram:  
65c9 00				nop 
65ca			 
65ca			heap_start: equ baseram+15  ; Starting address of heap 
65ca			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
65ca			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
65ca			;VDU:  EQU     endofcode           ; BASIC Work space 
65ca			; eof 
65ca			 
# End of file os_mega_cpm.asm
65ca
