# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 f7 94			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 c6 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 05 ee				ld hl, display_fb1  
800b 22 61 ed				ld (display_fb_active), hl  
800e			  
800e cd 7a 88				call clear_display  
8011			  
8011 21 63 ed				ld hl, display_fb2  
8014 22 61 ed				ld (display_fb_active), hl  
8017			  
8017 cd 7a 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 56 ee				ld hl, display_fb0  
801d 22 61 ed				ld (display_fb_active), hl  
8020			  
8020 cd 7a 88				call clear_display  
8023			  
8023			  
8023 cd 7b d6				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 1d d7			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 4a 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 9d 88			call update_display  
8032 cd fa 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 7f 88			call fill_display  
803a cd 9d 88			call update_display  
803d cd fa 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 7f 88			call fill_display  
8045 cd 9d 88			call update_display  
8048 cd fa 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 7f 88			call fill_display  
8050 cd 9d 88			call update_display  
8053 cd fa 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056 3e 00		        ld a, display_row_1    
8058			else  
8058			        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 8d 88			call str_at_display  
805e cd 9d 88			call update_display  
8061			  
8061			  
8061 cd fa 87			call delay1s  
8064 cd fa 87			call delay1s  
8067			if display_cols == 20	  
8067 3e 2a		            LD   A, display_row_3+2  
8069			else  
8069			            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 8d 88			call str_at_display  
806f cd 9d 88			call update_display  
8072 cd fa 87			call delay1s  
8075 cd fa 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 c0 ee		ld (debug_mark),a  
807d 32 c1 ee		ld (debug_mark+1),a  
8080 32 c2 ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 c3 ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 c0 ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 c1 ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 c2 ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 21 93			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 c0 ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 c1 ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 c2 ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 21 93			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd d2 83			call storage_findnextid 
8105			 
8105 cd d0 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 eb ec			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a ed ec			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 c0 ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 c1 ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 c2 ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 21 93			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 c0 ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 c1 ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 c2 ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 21 93			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 eb ec			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 c0 ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 c1 ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 c2 ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 eb ec				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 21 93			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a ec ec			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 c0 ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 c1 ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 c2 ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 21 93			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 c0 ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 c1 ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 c2 ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 21 93			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 cd bd 87			call storage_clear_page 
81d3			 
81d3 21 eb ec			ld hl, store_page 
81d6 3e 00			ld a, 0 
81d8				 
81d8 77				ld (hl),a   ; reset file counter 
81d9			 
81d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81dc 22 ec ec		 	ld (store_page+1), hl	 
81df			 
81df				; set default label 
81df			 
81df 21 7b 82			ld hl, .defaultbanklabl 
81e2 11 ee ec		 	ld de, store_page+3 
81e5 01 0f 00			ld bc, 15 
81e8 ed b0			ldir 
81ea			 
81ea				; Append the current bank id 
81ea 21 f7 ec			ld hl, store_page+3+9 
81ed 3a d0 ec			ld a, (spi_device_id) 
81f0 77				ld (hl), a 
81f1			 
81f1				; save default page 0 
81f1			 
81f1 21 00 00			ld hl, 0 
81f4 11 eb ec			ld de, store_page 
81f7				if DEBUG_STORESE 
81f7					DMARK "SB3" 
81f7 f5				push af  
81f8 3a 0c 82			ld a, (.dmark)  
81fb 32 c0 ee			ld (debug_mark),a  
81fe 3a 0d 82			ld a, (.dmark+1)  
8201 32 c1 ee			ld (debug_mark+1),a  
8204 3a 0e 82			ld a, (.dmark+2)  
8207 32 c2 ee			ld (debug_mark+2),a  
820a 18 03			jr .pastdmark  
820c ..			.dmark: db "SB3"  
820f f1			.pastdmark: pop af  
8210			endm  
# End of macro DMARK
8210			;		push af 
8210			;		ld a, 'F' 
8210			;		ld (debug_mark),a 
8210			;		pop af 
8210					CALLMONITOR 
8210 cd 21 93			call break_point_state  
8213				endm  
# End of macro CALLMONITOR
8213				endif 
8213 cd 16 81			call storage_write_block 
8216				if DEBUG_STORESE 
8216					DMARK "SB4" 
8216 f5				push af  
8217 3a 2b 82			ld a, (.dmark)  
821a 32 c0 ee			ld (debug_mark),a  
821d 3a 2c 82			ld a, (.dmark+1)  
8220 32 c1 ee			ld (debug_mark+1),a  
8223 3a 2d 82			ld a, (.dmark+2)  
8226 32 c2 ee			ld (debug_mark+2),a  
8229 18 03			jr .pastdmark  
822b ..			.dmark: db "SB4"  
822e f1			.pastdmark: pop af  
822f			endm  
# End of macro DMARK
822f			;		push af 
822f			;		ld a, '>' 
822f			;		ld (debug_mark),a 
822f			;		pop af 
822f					CALLMONITOR 
822f cd 21 93			call break_point_state  
8232				endm  
# End of macro CALLMONITOR
8232				endif 
8232			 
8232 00				nop 
8233 00				nop 
8234 00				nop 
8235			 
8235				; now set 0 in every page to mark as a free block 
8235			 
8235 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8237 21 40 00			ld hl, STORE_BLOCK_PHY 
823a			 
823a 3e 00		.setmark1:   	ld a,0 
823c e5					push hl 
823d c5					push bc 
823e cd af 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd df 87			call aDelayInMS 
8246 23				inc hl 
8247 cd af 80				call se_writebyte 
824a 3e 0a			ld a, 10 
824c cd df 87			call aDelayInMS 
824f 2b				dec hl 
8250 c1					pop bc 
8251 e1					pop hl 
8252 3e 40				ld a, STORE_BLOCK_PHY 
8254 cd a7 8a				call addatohl 
8257 10 e1				djnz .setmark1 
8259			 
8259 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
825b 3e 00		.setmark2:   	ld a,0 
825d e5					push hl 
825e c5					push bc 
825f cd af 80				call se_writebyte 
8262 3e 0a			ld a, 10 
8264 cd df 87			call aDelayInMS 
8267 23				inc hl 
8268 cd af 80				call se_writebyte 
826b 3e 0a			ld a, 10 
826d cd df 87			call aDelayInMS 
8270 2b				dec hl 
8271 c1					pop bc 
8272 e1					pop hl 
8273 3e 40				ld a, STORE_BLOCK_PHY 
8275 cd a7 8a				call addatohl 
8278 10 e1				djnz .setmark2 
827a			 
827a					 
827a			 
827a			 
827a c9				ret 
827b			 
827b			 
827b			 
827b			 
827b .. 00		.defaultbanklabl:   db "BankLabel_",0 
8286			 
8286			 
8286			 
8286			; Label Bank 
8286			; ---------- 
8286			; 
8286			; With current bank 
8286			; Read block 0 
8286			; Set label 
8286			; Write block 0 
8286			 
8286			; label str pointer in hl 
8286			 
8286			storage_label:     
8286			 
8286				if DEBUG_STORESE 
8286					DMARK "LBL" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 c0 ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 c1 ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 c2 ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LBL"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd 21 93			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2			 
82a2 e5				push hl 
82a3			 
82a3 cd 62 81			call storage_get_block_0 
82a6			 
82a6				; set default label 
82a6			 
82a6 e1				pop hl 
82a7			 
82a7 11 ee ec		 	ld de, store_page+3 
82aa 01 0f 00			ld bc, 15 
82ad				if DEBUG_STORESE 
82ad					DMARK "LB3" 
82ad f5				push af  
82ae 3a c2 82			ld a, (.dmark)  
82b1 32 c0 ee			ld (debug_mark),a  
82b4 3a c3 82			ld a, (.dmark+1)  
82b7 32 c1 ee			ld (debug_mark+1),a  
82ba 3a c4 82			ld a, (.dmark+2)  
82bd 32 c2 ee			ld (debug_mark+2),a  
82c0 18 03			jr .pastdmark  
82c2 ..			.dmark: db "LB3"  
82c5 f1			.pastdmark: pop af  
82c6			endm  
# End of macro DMARK
82c6					CALLMONITOR 
82c6 cd 21 93			call break_point_state  
82c9				endm  
# End of macro CALLMONITOR
82c9				endif 
82c9 ed b0			ldir 
82cb				; save default page 0 
82cb			 
82cb 21 00 00			ld hl, 0 
82ce 11 eb ec			ld de, store_page 
82d1				if DEBUG_STORESE 
82d1					DMARK "LBW" 
82d1 f5				push af  
82d2 3a e6 82			ld a, (.dmark)  
82d5 32 c0 ee			ld (debug_mark),a  
82d8 3a e7 82			ld a, (.dmark+1)  
82db 32 c1 ee			ld (debug_mark+1),a  
82de 3a e8 82			ld a, (.dmark+2)  
82e1 32 c2 ee			ld (debug_mark+2),a  
82e4 18 03			jr .pastdmark  
82e6 ..			.dmark: db "LBW"  
82e9 f1			.pastdmark: pop af  
82ea			endm  
# End of macro DMARK
82ea					CALLMONITOR 
82ea cd 21 93			call break_point_state  
82ed				endm  
# End of macro CALLMONITOR
82ed				endif 
82ed cd 16 81			call storage_write_block 
82f0			 
82f0 c9				ret 
82f1			 
82f1			 
82f1			 
82f1			; Read Block 0 - Config 
82f1			; --------------------- 
82f1			; 
82f1			; With current bank 
82f1			; Call presence test 
82f1			;    If not present format/init bank  
82f1			; Read block 0  
82f1			;  
82f1			 
82f1			 
82f1			; Dir 
82f1			; --- 
82f1			; 
82f1			; With current bank 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block read byte 2 
82f1			;      if first block of file 
82f1			;         Display file name 
82f1			;         Display type flags for file 
82f1			;        
82f1			 
82f1			; moving to words as this requires stack control 
82f1			 
82f1			 
82f1			; Delete File 
82f1			; ----------- 
82f1			; 
82f1			; With current bank 
82f1			; 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block file id 
82f1			;      If first block of file and dont have file id 
82f1			;         if file to delete 
82f1			;         Save file id 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			;      If file id is one saved 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			 
82f1			storage_erase: 
82f1			 
82f1				; hl contains the file id 
82f1			 
82f1 5d				ld e, l 
82f2 16 00			ld d, 0 
82f4 21 40 00			ld hl, STORE_BLOCK_PHY 
82f7					if DEBUG_FORTH_WORDS 
82f7						DMARK "ERA" 
82f7 f5				push af  
82f8 3a 0c 83			ld a, (.dmark)  
82fb 32 c0 ee			ld (debug_mark),a  
82fe 3a 0d 83			ld a, (.dmark+1)  
8301 32 c1 ee			ld (debug_mark+1),a  
8304 3a 0e 83			ld a, (.dmark+2)  
8307 32 c2 ee			ld (debug_mark+2),a  
830a 18 03			jr .pastdmark  
830c ..			.dmark: db "ERA"  
830f f1			.pastdmark: pop af  
8310			endm  
# End of macro DMARK
8310						CALLMONITOR 
8310 cd 21 93			call break_point_state  
8313				endm  
# End of macro CALLMONITOR
8313					endif 
8313 cd d2 83			call storage_findnextid 
8316			 
8316 e5				push hl 
8317			 
8317				; TODO check file not found 
8317			 
8317 11 eb ec			ld de, store_page 
831a cd b1 80			call storage_read_block 
831d			 
831d					if DEBUG_FORTH_WORDS 
831d						DMARK "ER1" 
831d f5				push af  
831e 3a 32 83			ld a, (.dmark)  
8321 32 c0 ee			ld (debug_mark),a  
8324 3a 33 83			ld a, (.dmark+1)  
8327 32 c1 ee			ld (debug_mark+1),a  
832a 3a 34 83			ld a, (.dmark+2)  
832d 32 c2 ee			ld (debug_mark+2),a  
8330 18 03			jr .pastdmark  
8332 ..			.dmark: db "ER1"  
8335 f1			.pastdmark: pop af  
8336			endm  
# End of macro DMARK
8336						CALLMONITOR 
8336 cd 21 93			call break_point_state  
8339				endm  
# End of macro CALLMONITOR
8339					endif 
8339 3a eb ec			ld a, (store_page)	; get file id 
833c 32 e4 ec			ld (store_tmpid), a 
833f			 
833f 3a ed ec			ld a, (store_page+2)    ; get count of extends 
8342 32 e3 ec			ld (store_tmpext), a 
8345			 
8345				; wipe file header 
8345			 
8345 e1				pop hl 
8346 3e 00			ld a, 0 
8348 32 eb ec			ld (store_page), a 
834b 32 ec ec			ld (store_page+1),a 
834e 11 eb ec			ld de, store_page 
8351					if DEBUG_FORTH_WORDS 
8351						DMARK "ER2" 
8351 f5				push af  
8352 3a 66 83			ld a, (.dmark)  
8355 32 c0 ee			ld (debug_mark),a  
8358 3a 67 83			ld a, (.dmark+1)  
835b 32 c1 ee			ld (debug_mark+1),a  
835e 3a 68 83			ld a, (.dmark+2)  
8361 32 c2 ee			ld (debug_mark+2),a  
8364 18 03			jr .pastdmark  
8366 ..			.dmark: db "ER2"  
8369 f1			.pastdmark: pop af  
836a			endm  
# End of macro DMARK
836a						CALLMONITOR 
836a cd 21 93			call break_point_state  
836d				endm  
# End of macro CALLMONITOR
836d					endif 
836d cd 16 81			call storage_write_block 
8370			 
8370			 
8370				; wipe file extents 
8370			 
8370 3a e3 ec			ld a, (store_tmpext) 
8373 47				ld b, a 
8374			 
8374			.eraext:	  
8374 c5				push bc 
8375			 
8375 21 40 00			ld hl, STORE_BLOCK_PHY 
8378 3a e4 ec			ld a,(store_tmpid) 
837b 5f				ld e, a 
837c 50				ld d, b	 
837d					if DEBUG_FORTH_WORDS 
837d						DMARK "ER3" 
837d f5				push af  
837e 3a 92 83			ld a, (.dmark)  
8381 32 c0 ee			ld (debug_mark),a  
8384 3a 93 83			ld a, (.dmark+1)  
8387 32 c1 ee			ld (debug_mark+1),a  
838a 3a 94 83			ld a, (.dmark+2)  
838d 32 c2 ee			ld (debug_mark+2),a  
8390 18 03			jr .pastdmark  
8392 ..			.dmark: db "ER3"  
8395 f1			.pastdmark: pop af  
8396			endm  
# End of macro DMARK
8396						CALLMONITOR 
8396 cd 21 93			call break_point_state  
8399				endm  
# End of macro CALLMONITOR
8399					endif 
8399 cd d2 83			call storage_findnextid 
839c			 
839c e5				push hl 
839d 11 eb ec			ld de, store_page 
83a0 cd b1 80			call storage_read_block 
83a3			 
83a3				; free block	 
83a3			 
83a3 3e 00			ld a, 0 
83a5 32 eb ec			ld (store_page), a 
83a8 32 ec ec			ld (store_page+1),a 
83ab 11 eb ec			ld de, store_page 
83ae e1				pop hl 
83af					if DEBUG_FORTH_WORDS 
83af						DMARK "ER4" 
83af f5				push af  
83b0 3a c4 83			ld a, (.dmark)  
83b3 32 c0 ee			ld (debug_mark),a  
83b6 3a c5 83			ld a, (.dmark+1)  
83b9 32 c1 ee			ld (debug_mark+1),a  
83bc 3a c6 83			ld a, (.dmark+2)  
83bf 32 c2 ee			ld (debug_mark+2),a  
83c2 18 03			jr .pastdmark  
83c4 ..			.dmark: db "ER4"  
83c7 f1			.pastdmark: pop af  
83c8			endm  
# End of macro DMARK
83c8						CALLMONITOR 
83c8 cd 21 93			call break_point_state  
83cb				endm  
# End of macro CALLMONITOR
83cb					endif 
83cb cd 16 81			call storage_write_block 
83ce			 
83ce c1				pop bc 
83cf 10 a3			djnz .eraext 
83d1			 
83d1 c9				ret 
83d2			 
83d2			 
83d2			; Find Free Block 
83d2			; --------------- 
83d2			; 
83d2			; With current bank 
83d2			;  
83d2			; From given starting logical block 
83d2			;    Read block  
83d2			;    If no file id 
83d2			;         Return block id 
83d2			 
83d2			 
83d2			; hl starting page number 
83d2			; hl contains free page number or zero if no pages free 
83d2			; e contains the file id to locate 
83d2			; d contains the block number 
83d2			 
83d2			; TODO change to find file id and use zero for free block 
83d2			 
83d2			storage_findnextid: 
83d2			 
83d2				; now locate first 0 page to mark as a free block 
83d2			 
83d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d4			;	ld hl, STORE_BLOCK_PHY 
83d4			 
83d4					if DEBUG_FORTH_WORDS 
83d4					DMARK "FNI" 
83d4 f5				push af  
83d5 3a e9 83			ld a, (.dmark)  
83d8 32 c0 ee			ld (debug_mark),a  
83db 3a ea 83			ld a, (.dmark+1)  
83de 32 c1 ee			ld (debug_mark+1),a  
83e1 3a eb 83			ld a, (.dmark+2)  
83e4 32 c2 ee			ld (debug_mark+2),a  
83e7 18 03			jr .pastdmark  
83e9 ..			.dmark: db "FNI"  
83ec f1			.pastdmark: pop af  
83ed			endm  
# End of macro DMARK
83ed						CALLMONITOR 
83ed cd 21 93			call break_point_state  
83f0				endm  
# End of macro CALLMONITOR
83f0					endif 
83f0			.ff1:   	 
83f0 e5					push hl 
83f1 c5					push bc 
83f2 d5					push de 
83f3 cd ae 80				call se_readbyte 
83f6 5f					ld e,a 
83f7 23					inc hl 
83f8 cd ae 80				call se_readbyte 
83fb 57					ld d, a 
83fc e1					pop hl 
83fd e5					push hl 
83fe cd c5 8a				call cmp16 
8401 28 49				jr z, .fffound 
8403			 
8403 d1					pop de 
8404 c1					pop bc 
8405 e1					pop hl 
8406			 
8406					; is found? 
8406					;cp e 
8406					;ret z 
8406			 
8406 3e 40				ld a, STORE_BLOCK_PHY 
8408 cd a7 8a				call addatohl 
840b 10 e3				djnz .ff1 
840d			 
840d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
840f			.ff2:   	 
840f			 
840f e5					push hl 
8410 c5					push bc 
8411 d5					push de 
8412 cd ae 80				call se_readbyte 
8415 5f					ld e,a 
8416 23					inc hl 
8417 cd ae 80				call se_readbyte 
841a 57					ld d, a 
841b			 
841b e1					pop hl 
841c e5					push hl 
841d cd c5 8a				call cmp16 
8420 28 2a				jr z, .fffound 
8422			 
8422 d1					pop de 
8423 c1					pop bc 
8424 e1					pop hl 
8425					; is found? 
8425					;cp e 
8425					;ret z 
8425			 
8425 3e 40				ld a, STORE_BLOCK_PHY 
8427 cd a7 8a				call addatohl 
842a 10 e3				djnz .ff2 
842c			 
842c			 
842c					if DEBUG_FORTH_WORDS 
842c					DMARK "FN-" 
842c f5				push af  
842d 3a 41 84			ld a, (.dmark)  
8430 32 c0 ee			ld (debug_mark),a  
8433 3a 42 84			ld a, (.dmark+1)  
8436 32 c1 ee			ld (debug_mark+1),a  
8439 3a 43 84			ld a, (.dmark+2)  
843c 32 c2 ee			ld (debug_mark+2),a  
843f 18 03			jr .pastdmark  
8441 ..			.dmark: db "FN-"  
8444 f1			.pastdmark: pop af  
8445			endm  
# End of macro DMARK
8445					;	push af 
8445					;	ld a, 'n' 
8445					;	ld (debug_mark),a 
8445					;	pop af 
8445						CALLMONITOR 
8445 cd 21 93			call break_point_state  
8448				endm  
# End of macro CALLMONITOR
8448					endif 
8448				; no free marks! 
8448 21 00 00				ld hl, 0 
844b c9				ret 
844c			.fffound: 
844c				 
844c			 
844c d1					pop de 
844d c1					pop bc 
844e e1					pop hl 
844f					if DEBUG_FORTH_WORDS 
844f					DMARK "FNF" 
844f f5				push af  
8450 3a 64 84			ld a, (.dmark)  
8453 32 c0 ee			ld (debug_mark),a  
8456 3a 65 84			ld a, (.dmark+1)  
8459 32 c1 ee			ld (debug_mark+1),a  
845c 3a 66 84			ld a, (.dmark+2)  
845f 32 c2 ee			ld (debug_mark+2),a  
8462 18 03			jr .pastdmark  
8464 ..			.dmark: db "FNF"  
8467 f1			.pastdmark: pop af  
8468			endm  
# End of macro DMARK
8468					;	push af 
8468					;	ld a, 'n' 
8468					;	ld (debug_mark),a 
8468					;	pop af 
8468						CALLMONITOR 
8468 cd 21 93			call break_point_state  
846b				endm  
# End of macro CALLMONITOR
846b					endif 
846b c9				ret 
846c			 
846c			 
846c			 
846c			; Free Space 
846c			; ---------- 
846c			; 
846c			; With current bank 
846c			; 
846c			; Set block count to zero 
846c			; Starting with first logical block 
846c			;      Find free block  
846c			;      If block id given, increment block count 
846c			; 
846c			;  
846c			 
846c			 
846c			; hl contains count of free blocks 
846c			 
846c			storage_freeblocks: 
846c			 
846c				; now locate first 0 page to mark as a free block 
846c			 
846c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
846e 21 40 00			ld hl, STORE_BLOCK_PHY 
8471 11 00 00			ld de, 0 
8474			 
8474			.fb1:   	 
8474 e5					push hl 
8475 c5					push bc 
8476 d5					push de 
8477 cd ae 80				call se_readbyte 
847a d1					pop de 
847b c1					pop bc 
847c e1					pop hl 
847d			 
847d					; is free? 
847d fe 00				cp 0 
847f 20 01				jr nz, .ff1cont 
8481 13					inc de 
8482			 
8482			.ff1cont: 
8482			 
8482			 
8482 3e 40				ld a, STORE_BLOCK_PHY 
8484 cd a7 8a				call addatohl 
8487 10 eb				djnz .fb1 
8489			 
8489 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848b			.fb2:   	 
848b e5					push hl 
848c c5					push bc 
848d d5					push de 
848e cd ae 80				call se_readbyte 
8491 d1					pop de 
8492 c1					pop bc 
8493 e1					pop hl 
8494			 
8494					; is free? 
8494 fe 00				cp 0 
8496 20 01				jr nz, .ff2cont 
8498 13					inc de 
8499			 
8499			.ff2cont: 
8499			 
8499 3e 40				ld a, STORE_BLOCK_PHY 
849b cd a7 8a				call addatohl 
849e 10 eb				djnz .fb2 
84a0			 
84a0 eb				ex de, hl 
84a1 c9				ret 
84a2			 
84a2			; Get File ID 
84a2			; ----------- 
84a2			; 
84a2			; With current bank 
84a2			;  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; For each logical block 
84a2			;    Read block file id 
84a2			;      If first block of file and dont have file id 
84a2			;         if file get id and exit 
84a2			 
84a2			 
84a2			 
84a2			 
84a2			; Create File 
84a2			; ----------- 
84a2			; 
84a2			; With current bank  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; Increment file id number 
84a2			; Save Config 
84a2			; Find free block 
84a2			; Set buffer with file name and file id 
84a2			; Write buffer to free block  
84a2			 
84a2			 
84a2			; hl point to file name 
84a2			; hl returns file id 
84a2			 
84a2			; file format: 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent number 
84a2			; byte 2-> data 
84a2			 
84a2			; format for extent number 0: 
84a2			; 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent 0 
84a2			; byte 2 - extent count 
84a2			; byte 3 -> file name and meta data 
84a2			 
84a2			 
84a2			storage_create: 
84a2				if DEBUG_STORESE 
84a2					DMARK "SCR" 
84a2 f5				push af  
84a3 3a b7 84			ld a, (.dmark)  
84a6 32 c0 ee			ld (debug_mark),a  
84a9 3a b8 84			ld a, (.dmark+1)  
84ac 32 c1 ee			ld (debug_mark+1),a  
84af 3a b9 84			ld a, (.dmark+2)  
84b2 32 c2 ee			ld (debug_mark+2),a  
84b5 18 03			jr .pastdmark  
84b7 ..			.dmark: db "SCR"  
84ba f1			.pastdmark: pop af  
84bb			endm  
# End of macro DMARK
84bb					CALLMONITOR 
84bb cd 21 93			call break_point_state  
84be				endm  
# End of macro CALLMONITOR
84be				endif 
84be			 
84be e5				push hl		; save file name pointer 
84bf			 
84bf cd 62 81			call storage_get_block_0 
84c2			 
84c2 3a eb ec			ld a,(store_page)	; get current file id 
84c5 3c				inc a 
84c6 32 eb ec			ld (store_page),a 
84c9				 
84c9 32 e4 ec			ld (store_tmpid),a			; save id 
84cc			 
84cc 21 00 00			ld hl, 0 
84cf 11 eb ec			ld de, store_page 
84d2				if DEBUG_STORESE 
84d2					DMARK "SCw" 
84d2 f5				push af  
84d3 3a e7 84			ld a, (.dmark)  
84d6 32 c0 ee			ld (debug_mark),a  
84d9 3a e8 84			ld a, (.dmark+1)  
84dc 32 c1 ee			ld (debug_mark+1),a  
84df 3a e9 84			ld a, (.dmark+2)  
84e2 32 c2 ee			ld (debug_mark+2),a  
84e5 18 03			jr .pastdmark  
84e7 ..			.dmark: db "SCw"  
84ea f1			.pastdmark: pop af  
84eb			endm  
# End of macro DMARK
84eb					CALLMONITOR 
84eb cd 21 93			call break_point_state  
84ee				endm  
# End of macro CALLMONITOR
84ee				endif 
84ee cd 16 81			call storage_write_block	 ; save update 
84f1			 
84f1				if DEBUG_STORESE 
84f1 11 eb ec				ld de, store_page 
84f4					DMARK "SCC" 
84f4 f5				push af  
84f5 3a 09 85			ld a, (.dmark)  
84f8 32 c0 ee			ld (debug_mark),a  
84fb 3a 0a 85			ld a, (.dmark+1)  
84fe 32 c1 ee			ld (debug_mark+1),a  
8501 3a 0b 85			ld a, (.dmark+2)  
8504 32 c2 ee			ld (debug_mark+2),a  
8507 18 03			jr .pastdmark  
8509 ..			.dmark: db "SCC"  
850c f1			.pastdmark: pop af  
850d			endm  
# End of macro DMARK
850d					CALLMONITOR 
850d cd 21 93			call break_point_state  
8510				endm  
# End of macro CALLMONITOR
8510				endif 
8510				;  
8510				 
8510 21 40 00			ld hl, STORE_BLOCK_PHY 
8513 11 00 00			ld de, 0 
8516 cd d2 83			call storage_findnextid 
8519			 
8519 22 d5 ec			ld (store_tmppageid), hl    ; save page to use  
851c			 
851c				; TODO detect 0 = no spare blocks 
851c			 
851c				; hl now contains the free page to use for the file header page 
851c			 
851c				if DEBUG_STORESE 
851c				DMARK "SCF" 
851c f5				push af  
851d 3a 31 85			ld a, (.dmark)  
8520 32 c0 ee			ld (debug_mark),a  
8523 3a 32 85			ld a, (.dmark+1)  
8526 32 c1 ee			ld (debug_mark+1),a  
8529 3a 33 85			ld a, (.dmark+2)  
852c 32 c2 ee			ld (debug_mark+2),a  
852f 18 03			jr .pastdmark  
8531 ..			.dmark: db "SCF"  
8534 f1			.pastdmark: pop af  
8535			endm  
# End of macro DMARK
8535					CALLMONITOR 
8535 cd 21 93			call break_point_state  
8538				endm  
# End of macro CALLMONITOR
8538				endif 
8538			 
8538 22 d5 ec			ld (store_tmppageid), hl 
853b				 
853b 3a e4 ec			ld a,(store_tmpid)    ; get file id 
853e			;	ld a, (store_filecache)			; save to cache 
853e			 
853e 32 eb ec			ld (store_page),a    ; set page id 
8541 3e 00			ld a, 0			 ; extent 0 is file header 
8543 32 ec ec			ld (store_page+1), a   ; set file extent 
8546			 
8546 32 ed ec			ld (store_page+2), a   ; extent count for the file 
8549			 
8549			;	inc hl 		; init block 0 of file 
8549			;	inc hl   		; skip file and extent id 
8549			 ;       ld a, 0 
8549			;	ld (hl),a 
8549			;	ld a, (store_filecache+1)  	; save to cache 
8549			 
8549			;	inc hl    ; file name 
8549				 
8549				 
8549 11 ee ec			ld de, store_page+3    ; get buffer for term string to use as file name 
854c				if DEBUG_STORESE 
854c					DMARK "SCc" 
854c f5				push af  
854d 3a 61 85			ld a, (.dmark)  
8550 32 c0 ee			ld (debug_mark),a  
8553 3a 62 85			ld a, (.dmark+1)  
8556 32 c1 ee			ld (debug_mark+1),a  
8559 3a 63 85			ld a, (.dmark+2)  
855c 32 c2 ee			ld (debug_mark+2),a  
855f 18 03			jr .pastdmark  
8561 ..			.dmark: db "SCc"  
8564 f1			.pastdmark: pop af  
8565			endm  
# End of macro DMARK
8565					CALLMONITOR 
8565 cd 21 93			call break_point_state  
8568				endm  
# End of macro CALLMONITOR
8568				endif 
8568 e1				pop hl    ; get zero term string 
8569 e5				push hl 
856a 3e 00			ld a, 0 
856c cd 10 8f			call strlent 
856f 23				inc hl   ; cover zero term 
8570 06 00			ld b,0 
8572 4d				ld c,l 
8573 e1				pop hl 
8574				;ex de, hl 
8574				if DEBUG_STORESE 
8574					DMARK "SCa" 
8574 f5				push af  
8575 3a 89 85			ld a, (.dmark)  
8578 32 c0 ee			ld (debug_mark),a  
857b 3a 8a 85			ld a, (.dmark+1)  
857e 32 c1 ee			ld (debug_mark+1),a  
8581 3a 8b 85			ld a, (.dmark+2)  
8584 32 c2 ee			ld (debug_mark+2),a  
8587 18 03			jr .pastdmark  
8589 ..			.dmark: db "SCa"  
858c f1			.pastdmark: pop af  
858d			endm  
# End of macro DMARK
858d					;push af 
858d					;ld a, 'a' 
858d					;ld (debug_mark),a 
858d					;pop af 
858d					CALLMONITOR 
858d cd 21 93			call break_point_state  
8590				endm  
# End of macro CALLMONITOR
8590				endif 
8590 ed b0			ldir    ; copy zero term string 
8592				if DEBUG_STORESE 
8592					DMARK "SCA" 
8592 f5				push af  
8593 3a a7 85			ld a, (.dmark)  
8596 32 c0 ee			ld (debug_mark),a  
8599 3a a8 85			ld a, (.dmark+1)  
859c 32 c1 ee			ld (debug_mark+1),a  
859f 3a a9 85			ld a, (.dmark+2)  
85a2 32 c2 ee			ld (debug_mark+2),a  
85a5 18 03			jr .pastdmark  
85a7 ..			.dmark: db "SCA"  
85aa f1			.pastdmark: pop af  
85ab			endm  
# End of macro DMARK
85ab					CALLMONITOR 
85ab cd 21 93			call break_point_state  
85ae				endm  
# End of macro CALLMONITOR
85ae				endif 
85ae			 
85ae				; write file header page 
85ae			 
85ae 2a d5 ec			ld hl,(store_tmppageid) 
85b1 11 eb ec			ld de, store_page 
85b4				if DEBUG_STORESE 
85b4					DMARK "SCb" 
85b4 f5				push af  
85b5 3a c9 85			ld a, (.dmark)  
85b8 32 c0 ee			ld (debug_mark),a  
85bb 3a ca 85			ld a, (.dmark+1)  
85be 32 c1 ee			ld (debug_mark+1),a  
85c1 3a cb 85			ld a, (.dmark+2)  
85c4 32 c2 ee			ld (debug_mark+2),a  
85c7 18 03			jr .pastdmark  
85c9 ..			.dmark: db "SCb"  
85cc f1			.pastdmark: pop af  
85cd			endm  
# End of macro DMARK
85cd					;push af 
85cd					;ld a, 'b' 
85cd					;ld (debug_mark),a 
85cd					;pop af 
85cd					CALLMONITOR 
85cd cd 21 93			call break_point_state  
85d0				endm  
# End of macro CALLMONITOR
85d0				endif 
85d0 cd 16 81			call storage_write_block 
85d3			 
85d3 3a e4 ec			ld a, (store_tmpid) 
85d6 6f				ld l, a 
85d7 26 00			ld h,0 
85d9				if DEBUG_STORESE 
85d9					DMARK "SCz" 
85d9 f5				push af  
85da 3a ee 85			ld a, (.dmark)  
85dd 32 c0 ee			ld (debug_mark),a  
85e0 3a ef 85			ld a, (.dmark+1)  
85e3 32 c1 ee			ld (debug_mark+1),a  
85e6 3a f0 85			ld a, (.dmark+2)  
85e9 32 c2 ee			ld (debug_mark+2),a  
85ec 18 03			jr .pastdmark  
85ee ..			.dmark: db "SCz"  
85f1 f1			.pastdmark: pop af  
85f2			endm  
# End of macro DMARK
85f2					CALLMONITOR 
85f2 cd 21 93			call break_point_state  
85f5				endm  
# End of macro CALLMONITOR
85f5				endif 
85f5 c9				ret 
85f6				 
85f6			 
85f6			 
85f6			; 
85f6			; Read File 
85f6			; 
85f6			; h - file id to locate 
85f6			; l - extent to locate 
85f6			; de - pointer to string to read into 
85f6			; 
85f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85f6			storage_read: 
85f6 d5				push de 
85f7			 
85f7			; TODO BUG the above push is it popped before the RET Z? 
85f7			 
85f7			; TODO how to handle multiple part blocks 
85f7			 
85f7				; locate file extent to read 
85f7			 
85f7 5c				ld e, h 
85f8 55				ld d, l 
85f9 21 40 00			ld hl, STORE_BLOCK_PHY 
85fc				if DEBUG_STORESE 
85fc					DMARK "SRE" 
85fc f5				push af  
85fd 3a 11 86			ld a, (.dmark)  
8600 32 c0 ee			ld (debug_mark),a  
8603 3a 12 86			ld a, (.dmark+1)  
8606 32 c1 ee			ld (debug_mark+1),a  
8609 3a 13 86			ld a, (.dmark+2)  
860c 32 c2 ee			ld (debug_mark+2),a  
860f 18 03			jr .pastdmark  
8611 ..			.dmark: db "SRE"  
8614 f1			.pastdmark: pop af  
8615			endm  
# End of macro DMARK
8615					CALLMONITOR 
8615 cd 21 93			call break_point_state  
8618				endm  
# End of macro CALLMONITOR
8618				endif 
8618 cd d2 83			call storage_findnextid 
861b			 
861b				if DEBUG_STORESE 
861b					DMARK "SRf" 
861b f5				push af  
861c 3a 30 86			ld a, (.dmark)  
861f 32 c0 ee			ld (debug_mark),a  
8622 3a 31 86			ld a, (.dmark+1)  
8625 32 c1 ee			ld (debug_mark+1),a  
8628 3a 32 86			ld a, (.dmark+2)  
862b 32 c2 ee			ld (debug_mark+2),a  
862e 18 03			jr .pastdmark  
8630 ..			.dmark: db "SRf"  
8633 f1			.pastdmark: pop af  
8634			endm  
# End of macro DMARK
8634					CALLMONITOR 
8634 cd 21 93			call break_point_state  
8637				endm  
# End of macro CALLMONITOR
8637				endif 
8637 cd d0 8a			call ishlzero 
863a			;	ld a, l 
863a			;	add h 
863a			;	cp 0 
863a c8				ret z			; block not found so EOF 
863b			 
863b				; hl contains page number to load 
863b d1				pop de   ; get storage 
863c d5				push de 
863d				if DEBUG_STORESE 
863d					DMARK "SRg" 
863d f5				push af  
863e 3a 52 86			ld a, (.dmark)  
8641 32 c0 ee			ld (debug_mark),a  
8644 3a 53 86			ld a, (.dmark+1)  
8647 32 c1 ee			ld (debug_mark+1),a  
864a 3a 54 86			ld a, (.dmark+2)  
864d 32 c2 ee			ld (debug_mark+2),a  
8650 18 03			jr .pastdmark  
8652 ..			.dmark: db "SRg"  
8655 f1			.pastdmark: pop af  
8656			endm  
# End of macro DMARK
8656					CALLMONITOR 
8656 cd 21 93			call break_point_state  
8659				endm  
# End of macro CALLMONITOR
8659				endif 
8659 cd b1 80			call storage_read_block 
865c			 
865c			 
865c			; TODO if block has no zeros then need to read next block  
865c			 
865c			 
865c					 
865c e1				pop hl 		 ; return start of data to show as not EOF 
865d 23				inc hl   ; past file id 
865e 23				inc hl   ; past ext 
865f				if DEBUG_STORESE 
865f					DMARK "SRe" 
865f f5				push af  
8660 3a 74 86			ld a, (.dmark)  
8663 32 c0 ee			ld (debug_mark),a  
8666 3a 75 86			ld a, (.dmark+1)  
8669 32 c1 ee			ld (debug_mark+1),a  
866c 3a 76 86			ld a, (.dmark+2)  
866f 32 c2 ee			ld (debug_mark+2),a  
8672 18 03			jr .pastdmark  
8674 ..			.dmark: db "SRe"  
8677 f1			.pastdmark: pop af  
8678			endm  
# End of macro DMARK
8678					CALLMONITOR 
8678 cd 21 93			call break_point_state  
867b				endm  
# End of macro CALLMONITOR
867b				endif 
867b c9					ret 
867c			 
867c			 
867c			 
867c			; 
867c			; Append File 
867c			; 
867c			; hl - file id to locate 
867c			; de - pointer to (multi block) string to write 
867c			 
867c			 
867c			storage_append: 
867c				; hl -  file id to append to 
867c				; de - string to append 
867c			 
867c d5				push de 
867d				 
867d				if DEBUG_STORESE 
867d					DMARK "AP1" 
867d f5				push af  
867e 3a 92 86			ld a, (.dmark)  
8681 32 c0 ee			ld (debug_mark),a  
8684 3a 93 86			ld a, (.dmark+1)  
8687 32 c1 ee			ld (debug_mark+1),a  
868a 3a 94 86			ld a, (.dmark+2)  
868d 32 c2 ee			ld (debug_mark+2),a  
8690 18 03			jr .pastdmark  
8692 ..			.dmark: db "AP1"  
8695 f1			.pastdmark: pop af  
8696			endm  
# End of macro DMARK
8696					CALLMONITOR 
8696 cd 21 93			call break_point_state  
8699				endm  
# End of macro CALLMONITOR
8699				endif 
8699			 
8699 7d				ld a, l 
869a 32 e4 ec			ld (store_tmpid), a 
869d			 
869d				; get file header  
869d			 
869d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
869f 3a e4 ec			ld a, (store_tmpid) 
86a2 5f				ld e, a 
86a3			 
86a3 21 40 00				ld hl, STORE_BLOCK_PHY 
86a6 cd d2 83				call storage_findnextid 
86a9			 
86a9 22 d5 ec			ld (store_tmppageid), hl 
86ac			 
86ac				; TODO handle file id not found 
86ac			 
86ac				if DEBUG_STORESE 
86ac					DMARK "AP2" 
86ac f5				push af  
86ad 3a c1 86			ld a, (.dmark)  
86b0 32 c0 ee			ld (debug_mark),a  
86b3 3a c2 86			ld a, (.dmark+1)  
86b6 32 c1 ee			ld (debug_mark+1),a  
86b9 3a c3 86			ld a, (.dmark+2)  
86bc 32 c2 ee			ld (debug_mark+2),a  
86bf 18 03			jr .pastdmark  
86c1 ..			.dmark: db "AP2"  
86c4 f1			.pastdmark: pop af  
86c5			endm  
# End of macro DMARK
86c5					CALLMONITOR 
86c5 cd 21 93			call break_point_state  
86c8				endm  
# End of macro CALLMONITOR
86c8				endif 
86c8			 
86c8				; update file extent count 
86c8			 
86c8 11 eb ec			ld de, store_page 
86cb			 
86cb cd b1 80			call storage_read_block 
86ce			 
86ce				if DEBUG_STORESE 
86ce					DMARK "AP3" 
86ce f5				push af  
86cf 3a e3 86			ld a, (.dmark)  
86d2 32 c0 ee			ld (debug_mark),a  
86d5 3a e4 86			ld a, (.dmark+1)  
86d8 32 c1 ee			ld (debug_mark+1),a  
86db 3a e5 86			ld a, (.dmark+2)  
86de 32 c2 ee			ld (debug_mark+2),a  
86e1 18 03			jr .pastdmark  
86e3 ..			.dmark: db "AP3"  
86e6 f1			.pastdmark: pop af  
86e7			endm  
# End of macro DMARK
86e7					CALLMONITOR 
86e7 cd 21 93			call break_point_state  
86ea				endm  
# End of macro CALLMONITOR
86ea				endif 
86ea			;	ld (store_tmppageid), hl 
86ea			 
86ea 3a ed ec			ld a, (store_page+2) 
86ed 3c				inc a 
86ee 32 ed ec			ld (store_page+2), a 
86f1 32 e3 ec			ld (store_tmpext), a 
86f4				 
86f4				if DEBUG_STORESE 
86f4					DMARK "AP3" 
86f4 f5				push af  
86f5 3a 09 87			ld a, (.dmark)  
86f8 32 c0 ee			ld (debug_mark),a  
86fb 3a 0a 87			ld a, (.dmark+1)  
86fe 32 c1 ee			ld (debug_mark+1),a  
8701 3a 0b 87			ld a, (.dmark+2)  
8704 32 c2 ee			ld (debug_mark+2),a  
8707 18 03			jr .pastdmark  
8709 ..			.dmark: db "AP3"  
870c f1			.pastdmark: pop af  
870d			endm  
# End of macro DMARK
870d					CALLMONITOR 
870d cd 21 93			call break_point_state  
8710				endm  
# End of macro CALLMONITOR
8710				endif 
8710 2a d5 ec			ld hl, (store_tmppageid) 
8713 11 eb ec			ld de, store_page 
8716 cd 16 81			call storage_write_block 
8719			 
8719				; find free block 
8719			 
8719 11 00 00			ld de, 0			 ; file extent to locate 
871c			 
871c 21 40 00				ld hl, STORE_BLOCK_PHY 
871f cd d2 83				call storage_findnextid 
8722			 
8722					; TODO handle no space left 
8722					 
8722 22 d5 ec				ld (store_tmppageid), hl 
8725			 
8725				if DEBUG_STORESE 
8725					DMARK "AP4" 
8725 f5				push af  
8726 3a 3a 87			ld a, (.dmark)  
8729 32 c0 ee			ld (debug_mark),a  
872c 3a 3b 87			ld a, (.dmark+1)  
872f 32 c1 ee			ld (debug_mark+1),a  
8732 3a 3c 87			ld a, (.dmark+2)  
8735 32 c2 ee			ld (debug_mark+2),a  
8738 18 03			jr .pastdmark  
873a ..			.dmark: db "AP4"  
873d f1			.pastdmark: pop af  
873e			endm  
# End of macro DMARK
873e					CALLMONITOR 
873e cd 21 93			call break_point_state  
8741				endm  
# End of macro CALLMONITOR
8741				endif 
8741					; init the buffer with zeros so we can id if the buffer is full or not 
8741			 
8741 e5					push hl 
8742 c5					push bc 
8743			 
8743 21 eb ec				ld hl, store_page 
8746 06 40				ld b, STORE_BLOCK_PHY 
8748 3e 00				ld a, 0 
874a 77			.zeroblock:	ld (hl), a 
874b 23					inc hl 
874c 10 fc				djnz .zeroblock 
874e			 
874e c1					pop bc 
874f e1					pop hl 
8750			 
8750					; construct block 
8750			 
8750 3a e4 ec				ld a, (store_tmpid) 
8753 32 eb ec				ld (store_page), a   ; file id 
8756 3a e3 ec				ld a, (store_tmpext)   ; extent for this block 
8759 32 ec ec				ld (store_page+1), a 
875c			 
875c e1					pop hl    ; get string to write 
875d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
875f 11 ed ec				ld de, store_page+2 
8762			 
8762				if DEBUG_STORESE 
8762					DMARK "AP5" 
8762 f5				push af  
8763 3a 77 87			ld a, (.dmark)  
8766 32 c0 ee			ld (debug_mark),a  
8769 3a 78 87			ld a, (.dmark+1)  
876c 32 c1 ee			ld (debug_mark+1),a  
876f 3a 79 87			ld a, (.dmark+2)  
8772 32 c2 ee			ld (debug_mark+2),a  
8775 18 03			jr .pastdmark  
8777 ..			.dmark: db "AP5"  
877a f1			.pastdmark: pop af  
877b			endm  
# End of macro DMARK
877b					CALLMONITOR 
877b cd 21 93			call break_point_state  
877e				endm  
# End of macro CALLMONITOR
877e				endif 
877e			 
877e			 
877e			 
877e					; fill buffer with data until end of string or full block 
877e			 
877e 7e			.appd:		ld a, (hl) 
877f 12					ld (de), a 
8780 fe 00				cp 0 
8782 28 04				jr z, .appdone 
8784 23					inc hl 
8785 13					inc de 
8786 10 f6				djnz .appd 
8788			 
8788 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8789 f5					push af   		; save last byte dumped 
878a			 
878a			 
878a 2a d5 ec			ld hl, (store_tmppageid) 
878d 11 eb ec			ld de, store_page 
8790				if DEBUG_STORESE 
8790					DMARK "AP6" 
8790 f5				push af  
8791 3a a5 87			ld a, (.dmark)  
8794 32 c0 ee			ld (debug_mark),a  
8797 3a a6 87			ld a, (.dmark+1)  
879a 32 c1 ee			ld (debug_mark+1),a  
879d 3a a7 87			ld a, (.dmark+2)  
87a0 32 c2 ee			ld (debug_mark+2),a  
87a3 18 03			jr .pastdmark  
87a5 ..			.dmark: db "AP6"  
87a8 f1			.pastdmark: pop af  
87a9			endm  
# End of macro DMARK
87a9					CALLMONITOR 
87a9 cd 21 93			call break_point_state  
87ac				endm  
# End of macro CALLMONITOR
87ac				endif 
87ac cd 16 81				call storage_write_block 
87af			 
87af			 
87af				; was that a full block of data written? 
87af				; any more to write out? 
87af			 
87af				; if yes then set vars and jump to start of function again 
87af			 
87af f1					pop af 
87b0 d1					pop de 
87b1			 
87b1 fe 00				cp 0		 ; no, string was fully written 
87b3 c8					ret z 
87b4			 
87b4					; setup vars for next cycle 
87b4			 
87b4 3a e4 ec				ld a, (store_tmpid) 
87b7 6f					ld l, a 
87b8 26 00				ld h, 0 
87ba			 
87ba c3 7c 86			 	jp storage_append	 ; yes, need to write out some more 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			if DEBUG_STORECF 
87bd			storageput:	 
87bd					ret 
87bd			storageread: 
87bd					ld hl, store_page 
87bd					ld b, 200 
87bd					ld a,0 
87bd			.src:		ld (hl),a 
87bd					inc hl 
87bd					djnz .src 
87bd					 
87bd			 
87bd					ld de, 0 
87bd					ld bc, 1 
87bd					ld hl, store_page 
87bd					call cfRead 
87bd			 
87bd				call cfGetError 
87bd				ld hl,scratch 
87bd				call hexout 
87bd				ld hl, scratch+2 
87bd				ld a, 0 
87bd				ld (hl),a 
87bd				ld de, scratch 
87bd				ld a,display_row_1 
87bd				call str_at_display 
87bd				call update_display 
87bd			 
87bd					ld hl, store_page 
87bd					ld (os_cur_ptr),hl 
87bd			 
87bd					ret 
87bd			endif 
87bd			 
87bd			 
87bd			; Clear out the main buffer store (used to remove junk before writing a new block) 
87bd			 
87bd			storage_clear_page: 
87bd e5				push hl 
87be d5				push de 
87bf c5				push bc 
87c0 21 eb ec			ld hl, store_page 
87c3 3e 00			ld a, 0 
87c5 77				ld (hl), a 
87c6			 
87c6 11 ec ec			ld de, store_page+1 
87c9 01 40 00			ld bc, STORE_BLOCK_PHY 
87cc			 
87cc ed b0			ldir 
87ce				 
87ce c1				pop bc 
87cf d1				pop de 
87d0 e1				pop hl 
87d1 c9				ret 
87d2			 
87d2			; eof 
# End of file firmware_storage.asm
87d2			  
87d2			; support routines for above hardware abstraction layer  
87d2			  
87d2			include "firmware_general.asm"        ; general support functions  
87d2			 
87d2			; word look up 
87d2			 
87d2			; in 
87d2			; a is the index 
87d2			; hl is pointer start of array 
87d2			; 
87d2			; returns 
87d2			; hl to the word 
87d2			; 
87d2			 
87d2			table_lookup:  
87d2 d5					push de 
87d3 eb					ex de, hl 
87d4			 
87d4 6f					ld l, a 
87d5 26 00				ld h, 0 
87d7 29					add hl, hl 
87d8 19					add hl, de 
87d9 7e					ld a, (hl) 
87da 23					inc hl 
87db 66					ld h,(hl) 
87dc 6f					ld l, a 
87dd			 
87dd d1					pop de 
87de c9					ret 
87df			 
87df			; Delay loops 
87df			 
87df			 
87df			 
87df			aDelayInMS: 
87df c5				push bc 
87e0 47				ld b,a 
87e1			msdelay: 
87e1 c5				push bc 
87e2				 
87e2			 
87e2 01 41 00			ld bc,041h 
87e5 cd fd 87			call delayloop 
87e8 c1				pop bc 
87e9 05				dec b 
87ea 20 f5			jr nz,msdelay 
87ec			 
87ec			;if CPU_CLOCK_8MHZ 
87ec			;msdelay8: 
87ec			;	push bc 
87ec			;	 
87ec			; 
87ec			;	ld bc,041h 
87ec			;	call delayloop 
87ec			;	pop bc 
87ec			;	dec b 
87ec			;	jr nz,msdelay8 
87ec			;endif 
87ec			 
87ec			 
87ec c1				pop bc 
87ed c9				ret 
87ee			 
87ee			 
87ee			delay250ms: 
87ee				;push de 
87ee 01 00 40			ld bc, 04000h 
87f1 c3 fd 87			jp delayloop 
87f4			delay500ms: 
87f4				;push de 
87f4 01 00 80			ld bc, 08000h 
87f7 c3 fd 87			jp delayloop 
87fa			delay1s: 
87fa				;push bc 
87fa			   ; Clobbers A, d and e 
87fa 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87fd			delayloop: 
87fd c5			    push bc 
87fe			 
87fe			if BASE_CPM 
87fe				ld bc, CPM_DELAY_TUNE 
87fe			.cpmloop: 
87fe				push bc 
87fe			 
87fe			endif 
87fe			 
87fe			 
87fe			 
87fe			delayloopi: 
87fe			;	push bc 
87fe			;.dl: 
87fe cb 47		    bit     0,a    	; 8 
8800 cb 47		    bit     0,a    	; 8 
8802 cb 47		    bit     0,a    	; 8 
8804 e6 ff		    and     255  	; 7 
8806 0b			    dec     bc      	; 6 
8807 79			    ld      a,c     	; 4 
8808 b0			    or      b     	; 4 
8809 c2 fe 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
880c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
880c				;pop de 
880c			;pop bc 
880c			 
880c			if BASE_CPM 
880c				pop bc 
880c				 
880c			    dec     bc      	; 6 
880c			    ld      a,c     	; 4 
880c			    or      b     	; 4 
880c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
880c				 
880c			 
880c			endif 
880c			;if CPU_CLOCK_8MHZ 
880c			;    pop bc 
880c			;    push bc 
880c			;.dl8: 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    and     255  	; 7 
880c			;    dec     bc      	; 6 
880c			;    ld      a,c     	; 4 
880c			;    or      b     	; 4 
880c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880c			;endif 
880c			 
880c			;if CPU_CLOCK_10MHZ 
880c			;    pop bc 
880c			;    push bc 
880c			;.dl8: 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    and     255  	; 7 
880c			;    dec     bc      	; 6 
880c			;    ld      a,c     	; 4 
880c			;    or      b     	; 4 
880c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880c			;endif 
880c c1			    pop bc 
880d			 
880d c9				ret 
880e			 
880e			 
880e			 
880e			; eof 
# End of file firmware_general.asm
880e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
880e			; display routines that use the physical hardware abstraction layer 
880e			 
880e			 
880e			; information window 
880e			 
880e			; pass hl with 1st string to display 
880e			; pass de with 2nd string to display 
880e			 
880e			info_panel: 
880e e5				push hl 
880f			 
880f 2a 61 ed			ld hl, (display_fb_active) 
8812 e5				push hl    ; future de destination 
8813 21 56 ee				ld hl, display_fb0 
8816 22 61 ed				ld (display_fb_active), hl 
8819			 
8819 cd 7a 88			call clear_display 
881c			 
881c			 
881c 3e 2d			ld a, display_row_3 + 5 
881e cd 8d 88			call str_at_display 
8821			 
8821 e1				pop hl 
8822 d1				pop de 
8823			 
8823 e5				push hl 
8824			 
8824			 
8824 3e 19			ld a, display_row_2 + 5 
8826 cd 8d 88			call str_at_display 
8829			 
8829			 
8829 cd 9d 88			call update_display 
882c cd 26 98			call next_page_prompt 
882f cd 7a 88			call clear_display 
8832			 
8832				 
8832 21 05 ee				ld hl, display_fb1 
8835 22 61 ed				ld (display_fb_active), hl 
8838 cd 9d 88			call update_display 
883b			 
883b			 
883b c9				ret 
883c			 
883c			 
883c			 
883c			 
883c			; TODO windowing? 
883c			 
883c			; TODO scroll line up 
883c			 
883c			scroll_up: 
883c			 
883c e5				push hl 
883d d5				push de 
883e c5				push bc 
883f			 
883f				; get frame buffer  
883f			 
883f 2a 61 ed			ld hl, (display_fb_active) 
8842 e5				push hl    ; future de destination 
8843			 
8843 11 14 00			ld  de, display_cols 
8846 19				add hl, de 
8847			 
8847 d1				pop de 
8848			 
8848				;ex de, hl 
8848 01 4f 00			ld bc, display_fb_len -1  
884b			;if DEBUG_FORTH_WORDS 
884b			;	DMARK "SCL" 
884b			;	CALLMONITOR 
884b			;endif	 
884b ed b0			ldir 
884d			 
884d				; wipe bottom row 
884d			 
884d			 
884d 2a 61 ed			ld hl, (display_fb_active) 
8850 11 50 00			ld de, display_cols*display_rows 
8853 19				add hl, de 
8854 06 14			ld b, display_cols 
8856 3e 20			ld a, ' ' 
8858			.scwipe: 
8858 77				ld (hl), a 
8859 2b				dec hl 
885a 10 fc			djnz .scwipe 
885c			 
885c				;pop hl 
885c			 
885c c1				pop bc 
885d d1				pop de 
885e e1				pop hl 
885f			 
885f c9				ret 
8860			 
8860			 
8860			;scroll_upo: 
8860			;	ld de, display_row_1 
8860			 ;	ld hl, display_row_2 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			;	ld de, display_row_2 
8860			 ;	ld hl, display_row_3 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			;	ld de, display_row_3 
8860			 ;	ld hl, display_row_4 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			 
8860			; TODO clear row 4 
8860			 
8860			;	ret 
8860			 
8860				 
8860			scroll_down: 
8860			 
8860 e5				push hl 
8861 d5				push de 
8862 c5				push bc 
8863			 
8863				; get frame buffer  
8863			 
8863 2a 61 ed			ld hl, (display_fb_active) 
8866			 
8866 11 4f 00			ld de, display_fb_len - 1 
8869 19				add hl, de 
886a			 
886a e5			push hl    ; future de destination 
886b			 
886b 11 14 00			ld  de, display_cols 
886e ed 52			sbc hl, de 
8870			 
8870			 
8870 d1				pop de 
8871			 
8871			;	ex de, hl 
8871 01 4f 00			ld bc, display_fb_len -1  
8874			 
8874			 
8874				 
8874			 
8874 ed b0			ldir 
8876			 
8876				; wipe bottom row 
8876			 
8876			 
8876			;	ld hl, (display_fb_active) 
8876			;;	ld de, display_cols*display_rows 
8876			;;	add hl, de 
8876			;	ld b, display_cols 
8876			;	ld a, ' ' 
8876			;.scwiped: 
8876			;	ld (hl), a 
8876			;	dec hl 
8876			;	djnz .scwiped 
8876			 
8876				;pop hl 
8876			 
8876 c1				pop bc 
8877 d1				pop de 
8878 e1				pop hl 
8879			 
8879 c9				ret 
887a			;scroll_down: 
887a			;	ld de, display_row_4 
887a			;	ld hl, display_row_3 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;	ld de, display_row_3 
887a			; 	ld hl, display_row_2 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;	ld de, display_row_2 
887a			;	ld hl, display_row_1 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;;; TODO clear row 1 
887a			;	ret 
887a			 
887a			 
887a			 
887a			 
887a			 
887a			; clear active frame buffer 
887a			 
887a			clear_display: 
887a 3e 20			ld a, ' ' 
887c c3 7f 88			jp fill_display 
887f			 
887f			; fill active frame buffer with a char in A 
887f			 
887f			fill_display: 
887f 06 50			ld b,display_fb_len 
8881 2a 61 ed			ld hl, (display_fb_active) 
8884 77			.fd1:	ld (hl),a 
8885 23				inc hl 
8886 10 fc			djnz .fd1 
8888 23				inc hl 
8889 3e 00			ld a,0 
888b 77				ld (hl),a 
888c			 
888c			 
888c c9				ret 
888d			; Write string (DE) at pos (A) to active frame buffer 
888d			 
888d 2a 61 ed		str_at_display:    ld hl,(display_fb_active) 
8890 06 00					ld b,0 
8892 4f					ld c,a 
8893 09					add hl,bc 
8894 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8895 b7			            OR   A              ;Null terminator? 
8896 c8			            RET  Z              ;Yes, so finished 
8897 77					ld (hl),a 
8898 23				inc hl 
8899 13			            INC  DE             ;Point to next character 
889a 18 f8		            JR   .sad1     ;Repeat 
889c c9					ret 
889d			 
889d			; using current frame buffer write to physical display 
889d			 
889d			update_display: 
889d e5				push hl 
889e 2a 61 ed			ld hl, (display_fb_active) 
88a1 cd 92 d6			call write_display 
88a4 e1				pop hl 
88a5 c9				ret 
88a6			 
88a6			; TODO scrolling 
88a6			 
88a6			 
88a6			; move cursor right one char 
88a6			cursor_right: 
88a6			 
88a6				; TODO shift right 
88a6				; TODO if beyond max col 
88a6				; TODO       cursor_next_line 
88a6			 
88a6 c9				ret 
88a7			 
88a7			 
88a7			cursor_next_line: 
88a7				; TODO first char 
88a7				; TODO line down 
88a7				; TODO if past last row 
88a7				; TODO    scroll up 
88a7			 
88a7 c9				ret 
88a8			 
88a8			cursor_left: 
88a8				; TODO shift left 
88a8				; TODO if beyond left  
88a8				; TODO     cursor prev line 
88a8				 
88a8 c9				ret 
88a9			 
88a9			cursor_prev_line: 
88a9				; TODO last char 
88a9				; TODO line up 
88a9				; TODO if past first row 
88a9				; TODO   scroll down 
88a9			 
88a9 c9				ret 
88aa			 
88aa			 
88aa			cout: 
88aa				; A - char 
88aa c9				ret 
88ab			 
88ab			 
88ab			; Display a menu and allow item selection (optional toggle items) 
88ab			; 
88ab			; format: 
88ab			; hl pointer to word array with zero term for items 
88ab			; e.g.    db item1 
88ab			;         db .... 
88ab			;         db 0 
88ab			; 
88ab			; a = starting menu item  
88ab			; 
88ab			; de = pointer item toggle array   (todo) 
88ab			; 
88ab			; returns item selected in a 1-... 
88ab			; returns 0 if back button pressed 
88ab			; 
88ab			; NOTE: Uses system frame buffer to display 
88ab			; 
88ab			; LEFT, Q = go back 
88ab			; RIGHT, SPACE, CR = select 
88ab			; UP, A - Up 
88ab			; DOWN, Z - Down 
88ab			 
88ab			 
88ab			 
88ab			 
88ab			 
88ab			menu: 
88ab			 
88ab					; keep array pointer 
88ab			 
88ab 22 e9 ec				ld (store_tmp1), hl 
88ae 32 e7 ec				ld (store_tmp2), a 
88b1			 
88b1					; check for key bounce 
88b1			 
88b1			if BASE_KEV 
88b1			 
88b1			.mbounce:	call cin 
88b1					cp 0 
88b1					jr nz, .mbounce 
88b1			endif 
88b1					; for ease use ex 
88b1			 
88b1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88b1 21 56 ee				ld hl, display_fb0 
88b4 22 61 ed				ld (display_fb_active), hl 
88b7			 
88b7 cd 7a 88		.mloop:		call clear_display 
88ba cd 9d 88				call update_display 
88bd			 
88bd					; draw selection id '>' at 1 
88bd			 
88bd					; init start of list display 
88bd			 
88bd 3e 05				ld a, 5 
88bf 32 e5 ec				ld (store_tmp3), a   ; display row count 
88c2 3a e7 ec				ld a,( store_tmp2) 
88c5 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88c8			 
88c8					 
88c8			.mitem:	 
88c8			 
88c8			 
88c8 3a e8 ec				ld a,(store_tmp2+1) 
88cb 6f					ld l, a 
88cc 26 00				ld h, 0 
88ce 29					add hl, hl 
88cf ed 5b e9 ec			ld de, (store_tmp1) 
88d3 19					add hl, de 
88d4 7e					ld a, (hl) 
88d5 23					inc hl 
88d6 66					ld h,(hl) 
88d7 6f					ld l, a 
88d8			 
88d8 cd d0 8a				call ishlzero 
88db 28 1a				jr z, .mdone 
88dd			 
88dd eb					ex de, hl 
88de 3a e5 ec				ld a, (store_tmp3) 
88e1 cd 8d 88				call str_at_display 
88e4					 
88e4			 
88e4					; next item 
88e4 3a e8 ec				ld a, (store_tmp2+1) 
88e7 3c					inc a 
88e8 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88eb			 
88eb			 		; next row 
88eb			 
88eb 3a e5 ec				ld a, (store_tmp3) 
88ee c6 14				add display_cols 
88f0 32 e5 ec				ld (store_tmp3), a 
88f3			 
88f3					; at end of screen? 
88f3			 
88f3 fe 10				cp display_rows*4 
88f5 20 d1				jr nz, .mitem 
88f7			 
88f7			 
88f7			.mdone: 
88f7 cd d0 8a				call ishlzero 
88fa 28 08				jr z, .nodn 
88fc			 
88fc 3e 3c				ld a, display_row_4 
88fe 11 7d 89				ld de, .mdown 
8901 cd 8d 88				call str_at_display 
8904			 
8904					; draw options to fill the screens with active item on line 1 
8904					; if current option is 2 or more then display ^ in top 
8904			 
8904 3a e7 ec		.nodn:		ld a, (store_tmp2) 
8907 fe 00				cp 0 
8909 28 08				jr z, .noup 
890b			 
890b 3e 00				ld a, 0 
890d 11 7b 89				ld de, .mup 
8910 cd 8d 88				call str_at_display 
8913			 
8913 3e 02		.noup:		ld a, 2 
8915 11 79 89				ld de, .msel 
8918 cd 8d 88				call str_at_display 
891b			 
891b					; if current option + 1 is not null then display V in bottom 
891b					; get key 
891b cd 9d 88				call update_display 
891e			 
891e			 
891e					; handle key 
891e			 
891e cd 1e d7				call cin_wait 
8921			 
8921 fe 05				cp KEY_UP 
8923 28 2b				jr z, .mgoup 
8925 fe 61				cp 'a' 
8927 28 27				jr z, .mgoup 
8929 fe 0a				cp KEY_DOWN 
892b 28 32				jr z, .mgod 
892d fe 7a				cp 'z' 
892f 28 2e				jr z, .mgod 
8931 fe 20				cp ' ' 
8933 28 34				jr z, .goend 
8935 fe 0c				cp KEY_RIGHT 
8937 28 30				jr z, .goend 
8939 fe 0d				cp KEY_CR 
893b 28 2c				jr z, .goend 
893d fe 71				cp 'q' 
893f 28 0b				jr z, .goback 
8941			 
8941 fe 0b				cp KEY_LEFT 
8943 28 07				jr z, .goback 
8945 fe 08				cp KEY_BS 
8947 28 03				jr z, .goback 
8949 c3 b7 88				jp .mloop 
894c			 
894c			.goback: 
894c 3e 00			ld a, 0 
894e 18 1d			jr .goend2 
8950			 
8950				; move up one 
8950			.mgoup: 
8950 3a e7 ec				ld a, (store_tmp2) 
8953 fe 00				cp 0 
8955 ca b7 88				jp z, .mloop 
8958 3d					dec a 
8959 32 e7 ec				ld (store_tmp2), a 
895c c3 b7 88				jp .mloop 
895f			 
895f				; move down one 
895f			.mgod: 
895f 3a e7 ec				ld a, (store_tmp2) 
8962 3c					inc a 
8963 32 e7 ec				ld (store_tmp2), a 
8966 c3 b7 88				jp .mloop 
8969			 
8969			 
8969			.goend: 
8969					; get selected item number 
8969			 
8969 3a e7 ec				ld a, (store_tmp2) 
896c 3c					inc a 
896d			 
896d			.goend2: 
896d f5					push af 
896e			 
896e					; restore active fb 
896e					; TODO BUG assumes fb1 
896e			 
896e 21 05 ee				ld hl, display_fb1 
8971 22 61 ed				ld (display_fb_active), hl 
8974			 
8974					; restore main regs 
8974			 
8974			 
8974 cd 9d 88				call update_display 
8977			 
8977 f1					pop af 
8978			 
8978 c9				ret 
8979			 
8979 .. 00		.msel:   db ">",0 
897b .. 00		.mup:   db "^",0 
897d .. 00		.mdown:   db "v",0 
897f			 
897f			 
897f			; eof 
897f			 
# End of file firmware_display.asm
897f			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
897f			; random number generators 
897f			 
897f			 
897f			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
897f			 
897f			 
897f			;-----> Generate a random number 
897f			; output a=answer 0<=a<=255 
897f			; all registers are preserved except: af 
897f			random: 
897f e5			        push    hl 
8980 d5			        push    de 
8981 2a 43 ed		        ld      hl,(randData) 
8984 ed 5f		        ld      a,r 
8986 57			        ld      d,a 
8987 5e			        ld      e,(hl) 
8988 19			        add     hl,de 
8989 85			        add     a,l 
898a ac			        xor     h 
898b 22 43 ed		        ld      (randData),hl 
898e d1			        pop     de 
898f e1			        pop     hl 
8990 c9			        ret 
8991			 
8991			 
8991			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8991			 
8991			 
8991			 
8991			;------LFSR------ 
8991			;James Montelongo 
8991			;optimized by Spencer Putt 
8991			;out: 
8991			; a = 8 bit random number 
8991			RandLFSR: 
8991 21 49 ed		        ld hl,LFSRSeed+4 
8994 5e			        ld e,(hl) 
8995 23			        inc hl 
8996 56			        ld d,(hl) 
8997 23			        inc hl 
8998 4e			        ld c,(hl) 
8999 23			        inc hl 
899a 7e			        ld a,(hl) 
899b 47			        ld b,a 
899c cb 13		        rl e  
899e cb 12			rl d 
89a0 cb 11		        rl c  
89a2 17				rla 
89a3 cb 13		        rl e  
89a5 cb 12			rl d 
89a7 cb 11		        rl c  
89a9 17				rla 
89aa cb 13		        rl e  
89ac cb 12			rl d 
89ae cb 11		        rl c  
89b0 17				rla 
89b1 67			        ld h,a 
89b2 cb 13		        rl e  
89b4 cb 12			rl d 
89b6 cb 11		        rl c  
89b8 17				rla 
89b9 a8			        xor b 
89ba cb 13		        rl e  
89bc cb 12			rl d 
89be ac			        xor h 
89bf a9			        xor c 
89c0 aa			        xor d 
89c1 21 4b ed		        ld hl,LFSRSeed+6 
89c4 11 4c ed		        ld de,LFSRSeed+7 
89c7 01 07 00		        ld bc,7 
89ca ed b8		        lddr 
89cc 12			        ld (de),a 
89cd c9			        ret 
89ce			 
89ce			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89ce			 
89ce			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89ce			 
89ce			 
89ce			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89ce			 
89ce			prng16: 
89ce			;Inputs: 
89ce			;   (seed1) contains a 16-bit seed value 
89ce			;   (seed2) contains a NON-ZERO 16-bit seed value 
89ce			;Outputs: 
89ce			;   HL is the result 
89ce			;   BC is the result of the LCG, so not that great of quality 
89ce			;   DE is preserved 
89ce			;Destroys: 
89ce			;   AF 
89ce			;cycle: 4,294,901,760 (almost 4.3 billion) 
89ce			;160cc 
89ce			;26 bytes 
89ce 2a 3d ed		    ld hl,(seed1) 
89d1 44			    ld b,h 
89d2 4d			    ld c,l 
89d3 29			    add hl,hl 
89d4 29			    add hl,hl 
89d5 2c			    inc l 
89d6 09			    add hl,bc 
89d7 22 3d ed		    ld (seed1),hl 
89da 2a 3b ed		    ld hl,(seed2) 
89dd 29			    add hl,hl 
89de 9f			    sbc a,a 
89df e6 2d		    and %00101101 
89e1 ad			    xor l 
89e2 6f			    ld l,a 
89e3 22 3b ed		    ld (seed2),hl 
89e6 09			    add hl,bc 
89e7 c9			    ret 
89e8			 
89e8			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89e8			 
89e8			rand32: 
89e8			;Inputs: 
89e8			;   (seed1_0) holds the lower 16 bits of the first seed 
89e8			;   (seed1_1) holds the upper 16 bits of the first seed 
89e8			;   (seed2_0) holds the lower 16 bits of the second seed 
89e8			;   (seed2_1) holds the upper 16 bits of the second seed 
89e8			;   **NOTE: seed2 must be non-zero 
89e8			;Outputs: 
89e8			;   HL is the result 
89e8			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89e8			;Destroys: 
89e8			;   AF 
89e8			;Tested and passes all CAcert tests 
89e8			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89e8			;it has a period of 18,446,744,069,414,584,320 
89e8			;roughly 18.4 quintillion. 
89e8			;LFSR taps: 0,2,6,7  = 11000101 
89e8			;291cc 
89e8			;seed1_0=$+1 
89e8			;    ld hl,12345 
89e8			;seed1_1=$+1 
89e8			;    ld de,6789 
89e8			;    ld b,h 
89e8			;    ld c,l 
89e8			;    add hl,hl \ rl e \ rl d 
89e8			;    add hl,hl \ rl e \ rl d 
89e8			;    inc l 
89e8			;    add hl,bc 
89e8			;    ld (seed1_0),hl 
89e8			;    ld hl,(seed1_1) 
89e8			;    adc hl,de 
89e8			;    ld (seed1_1),hl 
89e8			;    ex de,hl 
89e8			;seed2_0=$+1 
89e8			;    ld hl,9876 
89e8			;seed2_1=$+1 
89e8			;    ld bc,54321 
89e8			;    add hl,hl \ rl c \ rl b 
89e8			;    ld (seed2_1),bc 
89e8			;    sbc a,a 
89e8			;    and %11000101 
89e8			;    xor l 
89e8			;    ld l,a 
89e8			;    ld (seed2_0),hl 
89e8			;    ex de,hl 
89e8			;    add hl,bc 
89e8			;    ret 
89e8			; 
89e8			 
89e8			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89e8			; 20 bytes, 86 cycles (excluding ret) 
89e8			 
89e8			; returns   hl = pseudorandom number 
89e8			; corrupts   a 
89e8			 
89e8			; generates 16-bit pseudorandom numbers with a period of 65535 
89e8			; using the xorshift method: 
89e8			 
89e8			; hl ^= hl << 7 
89e8			; hl ^= hl >> 9 
89e8			; hl ^= hl << 8 
89e8			 
89e8			; some alternative shift triplets which also perform well are: 
89e8			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89e8			 
89e8			;  org 32768 
89e8			 
89e8			xrnd: 
89e8 2a 41 ed		  ld hl,(xrandc)       ; seed must not be 0 
89eb 3e 00		  ld a,0 
89ed bd			  cp l 
89ee 20 02		  jr nz, .xrnd1 
89f0 2e 01		  ld l, 1 
89f2			.xrnd1: 
89f2			 
89f2 7c			  ld a,h 
89f3 1f			  rra 
89f4 7d			  ld a,l 
89f5 1f			  rra 
89f6 ac			  xor h 
89f7 67			  ld h,a 
89f8 7d			  ld a,l 
89f9 1f			  rra 
89fa 7c			  ld a,h 
89fb 1f			  rra 
89fc ad			  xor l 
89fd 6f			  ld l,a 
89fe ac			  xor h 
89ff 67			  ld h,a 
8a00			 
8a00 22 41 ed		  ld (xrandc),hl 
8a03			 
8a03 c9			  ret 
8a04			;  
8a04			 
8a04			 
8a04			;;;; int maths 
8a04			 
8a04			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a04			; Divide 16-bit values (with 16-bit result) 
8a04			; In: Divide BC by divider DE 
8a04			; Out: BC = result, HL = rest 
8a04			; 
8a04			Div16: 
8a04 21 00 00		    ld hl,0 
8a07 78			    ld a,b 
8a08 06 08		    ld b,8 
8a0a			Div16_Loop1: 
8a0a 17			    rla 
8a0b ed 6a		    adc hl,hl 
8a0d ed 52		    sbc hl,de 
8a0f 30 01		    jr nc,Div16_NoAdd1 
8a11 19			    add hl,de 
8a12			Div16_NoAdd1: 
8a12 10 f6		    djnz Div16_Loop1 
8a14 17			    rla 
8a15 2f			    cpl 
8a16 47			    ld b,a 
8a17 79			    ld a,c 
8a18 48			    ld c,b 
8a19 06 08		    ld b,8 
8a1b			Div16_Loop2: 
8a1b 17			    rla 
8a1c ed 6a		    adc hl,hl 
8a1e ed 52		    sbc hl,de 
8a20 30 01		    jr nc,Div16_NoAdd2 
8a22 19			    add hl,de 
8a23			Div16_NoAdd2: 
8a23 10 f6		    djnz Div16_Loop2 
8a25 17			    rla 
8a26 2f			    cpl 
8a27 41			    ld b,c 
8a28 4f			    ld c,a 
8a29 c9			ret 
8a2a			 
8a2a			 
8a2a			;http://z80-heaven.wikidot.com/math 
8a2a			; 
8a2a			;Inputs: 
8a2a			;     DE and A are factors 
8a2a			;Outputs: 
8a2a			;     A is not changed 
8a2a			;     B is 0 
8a2a			;     C is not changed 
8a2a			;     DE is not changed 
8a2a			;     HL is the product 
8a2a			;Time: 
8a2a			;     342+6x 
8a2a			; 
8a2a			Mult16: 
8a2a			 
8a2a 06 08		     ld b,8          ;7           7 
8a2c 21 00 00		     ld hl,0         ;10         10 
8a2f 29			       add hl,hl     ;11*8       88 
8a30 07			       rlca          ;4*8        32 
8a31 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a33 19			         add hl,de   ;--         -- 
8a34 10 f9		       djnz $-5      ;13*7+8     99 
8a36 c9			ret 
8a37			 
8a37			; 
8a37			; Square root of 16-bit value 
8a37			; In:  HL = value 
8a37			; Out:  D = result (rounded down) 
8a37			; 
8a37			;Sqr16: 
8a37			;    ld de,#0040 
8a37			;    ld a,l 
8a37			;    ld l,h 
8a37			;    ld h,d 
8a37			;    or a 
8a37			;    ld b,8 
8a37			;Sqr16_Loop: 
8a37			;    sbc hl,de 
8a37			;    jr nc,Sqr16_Skip 
8a37			;    add hl,de 
8a37			;Sqr16_Skip: 
8a37			;    ccf 
8a37			;    rl d 
8a37			;    add a,a 
8a37			;    adc hl,hl 
8a37			;    add a,a 
8a37			;    adc hl,hl 
8a37			;    djnz Sqr16_Loop 
8a37			;    ret 
8a37			; 
8a37			; 
8a37			; Divide 8-bit values 
8a37			; In: Divide E by divider C 
8a37			; Out: A = result, B = rest 
8a37			; 
8a37			Div8: 
8a37 af			    xor a 
8a38 06 08		    ld b,8 
8a3a			Div8_Loop: 
8a3a cb 13		    rl e 
8a3c 17			    rla 
8a3d 91			    sub c 
8a3e 30 01		    jr nc,Div8_NoAdd 
8a40 81			    add a,c 
8a41			Div8_NoAdd: 
8a41 10 f7		    djnz Div8_Loop 
8a43 47			    ld b,a 
8a44 7b			    ld a,e 
8a45 17			    rla 
8a46 2f			    cpl 
8a47 c9			    ret 
8a48			 
8a48			; 
8a48			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a48			; In: Multiply A with DE 
8a48			; Out: HL = result 
8a48			; 
8a48			Mult12U: 
8a48 2e 00		    ld l,0 
8a4a 87			    add a,a 
8a4b 30 01		    jr nc,Mult12U_NoAdd0 
8a4d 19			    add hl,de 
8a4e			Mult12U_NoAdd0: 
8a4e 29			    add hl,hl 
8a4f 87			    add a,a 
8a50 30 01		    jr nc,Mult12U_NoAdd1 
8a52 19			    add hl,de 
8a53			Mult12U_NoAdd1: 
8a53 29			    add hl,hl 
8a54 87			    add a,a 
8a55 30 01		    jr nc,Mult12U_NoAdd2 
8a57 19			    add hl,de 
8a58			Mult12U_NoAdd2: 
8a58 29			    add hl,hl 
8a59 87			    add a,a 
8a5a 30 01		    jr nc,Mult12U_NoAdd3 
8a5c 19			    add hl,de 
8a5d			Mult12U_NoAdd3: 
8a5d 29			    add hl,hl 
8a5e 87			    add a,a 
8a5f 30 01		    jr nc,Mult12U_NoAdd4 
8a61 19			    add hl,de 
8a62			Mult12U_NoAdd4: 
8a62 29			    add hl,hl 
8a63 87			    add a,a 
8a64 30 01		    jr nc,Mult12U_NoAdd5 
8a66 19			    add hl,de 
8a67			Mult12U_NoAdd5: 
8a67 29			    add hl,hl 
8a68 87			    add a,a 
8a69 30 01		    jr nc,Mult12U_NoAdd6 
8a6b 19			    add hl,de 
8a6c			Mult12U_NoAdd6: 
8a6c 29			    add hl,hl 
8a6d 87			    add a,a 
8a6e d0			    ret nc 
8a6f 19			    add hl,de 
8a70 c9			    ret 
8a71			 
8a71			; 
8a71			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a71			; In: Multiply A with DE 
8a71			;      Put lowest value in A for most efficient calculation 
8a71			; Out: HL = result 
8a71			; 
8a71			Mult12R: 
8a71 21 00 00		    ld hl,0 
8a74			Mult12R_Loop: 
8a74 cb 3f		    srl a 
8a76 30 01		    jr nc,Mult12R_NoAdd 
8a78 19			    add hl,de 
8a79			Mult12R_NoAdd: 
8a79 cb 23		    sla e 
8a7b cb 12		    rl d 
8a7d b7			    or a 
8a7e c2 74 8a		    jp nz,Mult12R_Loop 
8a81 c9			    ret 
8a82			 
8a82			; 
8a82			; Multiply 16-bit values (with 32-bit result) 
8a82			; In: Multiply BC with DE 
8a82			; Out: BCHL = result 
8a82			; 
8a82			Mult32: 
8a82 79			    ld a,c 
8a83 48			    ld c,b 
8a84 21 00 00		    ld hl,0 
8a87 06 10		    ld b,16 
8a89			Mult32_Loop: 
8a89 29			    add hl,hl 
8a8a 17			    rla 
8a8b cb 11		    rl c 
8a8d 30 07		    jr nc,Mult32_NoAdd 
8a8f 19			    add hl,de 
8a90 ce 00		    adc a,0 
8a92 d2 96 8a		    jp nc,Mult32_NoAdd 
8a95 0c			    inc c 
8a96			Mult32_NoAdd: 
8a96 10 f1		    djnz Mult32_Loop 
8a98 41			    ld b,c 
8a99 4f			    ld c,a 
8a9a c9			    ret 
8a9b			 
8a9b			 
8a9b			 
8a9b			; 
8a9b			; Multiply 8-bit values 
8a9b			; In:  Multiply H with E 
8a9b			; Out: HL = result 
8a9b			; 
8a9b			Mult8: 
8a9b 16 00		    ld d,0 
8a9d 6a			    ld l,d 
8a9e 06 08		    ld b,8 
8aa0			Mult8_Loop: 
8aa0 29			    add hl,hl 
8aa1 30 01		    jr nc,Mult8_NoAdd 
8aa3 19			    add hl,de 
8aa4			Mult8_NoAdd: 
8aa4 10 fa		    djnz Mult8_Loop 
8aa6 c9			    ret 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			;;http://z80-heaven.wikidot.com/math 
8aa7			;;This divides DE by BC, storing the result in DE, remainder in HL 
8aa7			; 
8aa7			;DE_Div_BC:          ;1281-2x, x is at most 16 
8aa7			;     ld a,16        ;7 
8aa7			;     ld hl,0        ;10 
8aa7			;     jp $+5         ;10 
8aa7			;.DivLoop: 
8aa7			;       add hl,bc    ;-- 
8aa7			;       dec a        ;64 
8aa7			;       jr z,.DivLoopEnd        ;86 
8aa7			; 
8aa7			;       sla e        ;128 
8aa7			;       rl d         ;128 
8aa7			;       adc hl,hl    ;240 
8aa7			;       sbc hl,bc    ;240 
8aa7			;       jr nc,.DivLoop ;23|21 
8aa7			;       inc e        ;-- 
8aa7			;       jp .DivLoop+1 
8aa7			; 
8aa7			;.DivLoopEnd: 
8aa7			 
8aa7			;HL_Div_C: 
8aa7			;Inputs: 
8aa7			;     HL is the numerator 
8aa7			;     C is the denominator 
8aa7			;Outputs: 
8aa7			;     A is the remainder 
8aa7			;     B is 0 
8aa7			;     C is not changed 
8aa7			;     DE is not changed 
8aa7			;     HL is the quotient 
8aa7			; 
8aa7			;       ld b,16 
8aa7			;       xor a 
8aa7			;         add hl,hl 
8aa7			;         rla 
8aa7			;         cp c 
8aa7			;         jr c,$+4 
8aa7			;           inc l 
8aa7			;           sub c 
8aa7			;         djnz $-7 
8aa7			 
8aa7			; https://plutiedev.com/z80-add-8bit-to-16bit 
8aa7			 
8aa7			addatohl: 
8aa7 85			    add   a, l    ; A = A+L 
8aa8 6f			    ld    l, a    ; L = A+L 
8aa9 8c			    adc   a, h    ; A = A+L+H+carry 
8aaa 95			    sub   l       ; A = H+carry 
8aab 67			    ld    h, a    ; H = H+carry 
8aac c9			ret 
8aad			 
8aad			addatode: 
8aad 83			    add   a, e    ; A = A+L 
8aae 5f			    ld    e, a    ; L = A+L 
8aaf 8a			    adc   a, d    ; A = A+L+H+carry 
8ab0 93			    sub   e       ; A = H+carry 
8ab1 57			    ld    d, a    ; H = H+carry 
8ab2 c9			ret 
8ab3			 
8ab3			 
8ab3			addatobc: 
8ab3 81			    add   a, c    ; A = A+L 
8ab4 4f			    ld    c, a    ; L = A+L 
8ab5 88			    adc   a, b    ; A = A+L+H+carry 
8ab6 91			    sub   c       ; A = H+carry 
8ab7 47			    ld    b, a    ; H = H+carry 
8ab8 c9			ret 
8ab9			 
8ab9			subafromhl: 
8ab9			   ; If A=0 do nothing 
8ab9			    ; Otherwise flip A's sign. Since 
8ab9			    ; the upper byte becomes -1, also 
8ab9			    ; substract 1 from H. 
8ab9 ed 44		    neg 
8abb ca c4 8a		    jp    z, Skip 
8abe 25			    dec   h 
8abf			     
8abf			    ; Now add the low byte as usual 
8abf			    ; Two's complement takes care of 
8abf			    ; ensuring the result is correct 
8abf 85			    add   a, l 
8ac0 6f			    ld    l, a 
8ac1 8c			    adc   a, h 
8ac2 95			    sub   l 
8ac3 67			    ld    h, a 
8ac4			Skip: 
8ac4 c9				ret 
8ac5			 
8ac5			 
8ac5			; compare hl and de 
8ac5			; returns:  
8ac5			; if hl = de, z=1, s=0, c0=0 
8ac5			; if hl > de, z=0, s=0, c=0 
8ac5			; if hl < de, z=0, s=1, c=1 
8ac5			cmp16:	 
8ac5 b7				or a 
8ac6 ed 52			sbc hl,de 
8ac8 e0				ret po 
8ac9 7c				ld a,h 
8aca 1f				rra 
8acb ee 40			xor 01000000B 
8acd 37				scf 
8ace 8f				adc a,a 
8acf c9				ret 
8ad0			 
8ad0			 
8ad0			; test if hl contains zero   - A is destroyed 
8ad0			 
8ad0			ishlzero:    
8ad0 b7				or a     ; reset flags 
8ad1 7c				ld a, h 
8ad2 b5				or l        	 
8ad3			 
8ad3 c9				ret 
8ad4			 
8ad4			 
8ad4			 
8ad4			 
8ad4			if FORTH_ENABLE_FLOATMATH 
8ad4			;include "float/bbcmath.z80" 
8ad4			include "float/lpfpcalc.asm" 
8ad4			endif 
8ad4			 
8ad4			 
8ad4			; eof 
8ad4			 
# End of file firmware_maths.asm
8ad4			include "firmware_strings.asm"   ; string handling  
8ad4			 
8ad4			 
8ad4			; TODO string len 
8ad4			; input text string, end on cr with zero term 
8ad4			; a offset into frame buffer to start prompt 
8ad4			; d is max length 
8ad4			; e is display size TODO 
8ad4			; c is current cursor position 
8ad4			; hl is ptr to where string will be stored 
8ad4			 
8ad4			 
8ad4			; TODO check limit of buffer for new inserts 
8ad4			; TODO check insert does not push beyond buffer 
8ad4			; TODO scroll in a limited display area 
8ad4			; TODO scroll whole screen on page wrap 
8ad4			 
8ad4			 
8ad4			; TODO handle KEY_PREVWORD 
8ad4			; TODO handle KEY_NEXTWORD 
8ad4			; TODO handle KEY_HOME 
8ad4			; TODO handle KEY_END 
8ad4			; TODO use LCD cursor? 
8ad4			 
8ad4 32 b9 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8ad7 81					add c 
8ad8 32 b7 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8adb 22 bc ee				ld (input_start), hl     ; save ptr to buffer 
8ade 79					ld a, c 
8adf cd a7 8a				call addatohl 
8ae2 22 be ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ae5 7a					ld a,d 
8ae6 32 bb ee			        ld (input_size), a       ; save length of input area 
8ae9 79					ld a, c 
8aea 32 aa ee				ld (input_cursor),a      ; init cursor start position  
8aed 7b					ld a,e 
8aee 32 ba ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8af1					 
8af1					 
8af1			 
8af1			;		ld a,(input_ptr) 
8af1			;		ld (input_under_cursor),a 	; save what is under the cursor 
8af1			 
8af1			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8af1					; init cursor shape if not set by the cin routines 
8af1 21 59 ed				ld hl, cursor_shape 
8af4 3e ff				ld a, 255 
8af6 77					ld (hl), a 
8af7 23					inc hl 
8af8 3e 00				ld a, 0 
8afa 77					ld (hl), a 
8afb			 
8afb 3e 0f				ld a, CUR_BLINK_RATE 
8afd 32 b5 ee				ld (input_cur_flash), a 
8b00 3e 01				ld a, 1 
8b02 32 b4 ee				ld (input_cur_onoff),a 
8b05			 
8b05			;	if DEBUG_INPUT 
8b05			;		push af 
8b05			;		ld a, 'I' 
8b05			;		ld (debug_mark),a 
8b05			;		pop af 
8b05			;		CALLMONITOR 
8b05			;	endif 
8b05			.is1:		; main entry loop 
8b05			 
8b05			 
8b05			 
8b05					; pause 1ms 
8b05			 
8b05 3e 01				ld a, 1 
8b07 cd df 87				call aDelayInMS 
8b0a			 
8b0a					; dec flash counter 
8b0a 3a b5 ee				ld a, (input_cur_flash) 
8b0d 3d					dec a 
8b0e 32 b5 ee				ld (input_cur_flash), a 
8b11 fe 00				cp 0 
8b13 20 0d				jr nz, .nochgstate 
8b15			 
8b15			 
8b15					; change state 
8b15 3a b4 ee				ld a,(input_cur_onoff) 
8b18 ed 44				neg 
8b1a 32 b4 ee				ld (input_cur_onoff),a 
8b1d			 
8b1d			 
8b1d					; reset on change of state 
8b1d 3e 0f				ld a, CUR_BLINK_RATE 
8b1f 32 b5 ee				ld (input_cur_flash), a 
8b22			 
8b22			.nochgstate: 
8b22					 
8b22					 
8b22			 
8b22					; display cursor  
8b22			 
8b22			;		ld hl, (input_start) 
8b22			;		ld a, (input_cursor) 
8b22			;		call addatohl 
8b22			 
8b22					; get char under cursor and replace with cursor 
8b22 2a be ee		ld hl, (input_ptr) 
8b25			;		ld a, (hl) 
8b25			;		ld (input_under_cursor),a 
8b25			;		ld a, '_' 
8b25			;		ld (hl), a 
8b25			 
8b25					; display string 
8b25			 
8b25 ed 5b bc ee			ld de, (input_start) 
8b29 3a b9 ee				ld a, (input_at_pos) 
8b2c cd 8d 88				call str_at_display 
8b2f			;	        call update_display 
8b2f			 
8b2f					; find place to put the cursor 
8b2f			;		add h 
8b2f			;		ld l, display_row_1 
8b2f			;		sub l 
8b2f			; (input_at_pos) 
8b2f					;ld c, a 
8b2f			;		ld a, (input_cursor) 
8b2f			;		ld l, (input_at_pos) 
8b2f			;		;ld b, h 
8b2f			;		add l 
8b2f			;		ld (input_at_cursor),a 
8b2f					;ld l,h 
8b2f			 
8b2f			;		ld h, 0 
8b2f			;		ld l,(input_at_pos) 
8b2f			;		ld a, (input_cursor) 
8b2f			;		call addatohl 
8b2f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b2f			;		call subafromhl 
8b2f			;		ld a,l 
8b2f			;		ld (input_at_cursor), a 
8b2f			 
8b2f				if DEBUG_INPUT 
8b2f					ld a, (hardware_diag) 
8b2f					cp 0 
8b2f					jr z, .skip_input_diag 
8b2f			 
8b2f					ld a,(input_at_pos) 
8b2f					ld hl, LFSRSeed 
8b2f					call hexout 
8b2f					ld a, (input_cursor) 
8b2f					ld hl, LFSRSeed+2 
8b2f					call hexout 
8b2f					ld a,(input_at_cursor) 
8b2f					ld hl, LFSRSeed+4 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_cur_onoff) 
8b2f					ld hl, LFSRSeed+6 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_cur_flash) 
8b2f					ld hl, LFSRSeed+8 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_len) 
8b2f					ld hl, LFSRSeed+10 
8b2f					call hexout 
8b2f					ld hl, LFSRSeed+12 
8b2f					ld a, 0 
8b2f					ld (hl),a 
8b2f					ld a, display_row_4 
8b2f					ld de, LFSRSeed 
8b2f					call str_at_display 
8b2f					.skip_input_diag: 
8b2f				endif 
8b2f			 
8b2f					; decide on if we are showing the cursor this time round 
8b2f			 
8b2f 3a b4 ee				ld a, (input_cur_onoff) 
8b32 fe ff				cp 255 
8b34 28 13				jr z, .skipcur 
8b36			 
8b36			 
8b36 3a b7 ee				ld a,(input_at_cursor) 
8b39 11 59 ed				ld de, cursor_shape 
8b3c cd 8d 88				call str_at_display 
8b3f			 
8b3f					; save length of current input string 
8b3f 2a bc ee				ld hl, (input_start) 
8b42 cd 05 8f				call strlenz 
8b45 7d					ld a,l 
8b46 32 af ee				ld (input_len),a 
8b49			 
8b49			.skipcur: 
8b49			 
8b49 cd 9d 88			        call update_display 
8b4c					 
8b4c			 
8b4c			 
8b4c					; wait 
8b4c				 
8b4c					; TODO loop without wait to flash the cursor and char under cursor	 
8b4c cd 24 d7				call cin    ; _wait 
8b4f			 
8b4f fe 00				cp 0 
8b51 ca 05 8b				jp z, .is1 
8b54			 
8b54					; get ptr to char to input into 
8b54			 
8b54 4f					ld c,a 
8b55 2a bc ee				ld hl, (input_start) 
8b58 3a aa ee				ld a, (input_cursor) 
8b5b cd a7 8a				call addatohl 
8b5e 22 be ee				ld (input_ptr), hl 
8b61 79					ld a,c 
8b62			 
8b62					; replace char under cursor 
8b62			 
8b62			;		ld hl, (input_ptr) 
8b62			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b62			;		ld (hl), a 
8b62			 
8b62			;	if DEBUG_INPUT 
8b62			;		push af 
8b62			;		ld a, 'i' 
8b62			;		ld (debug_mark),a 
8b62			;		pop af 
8b62			;		CALLMONITOR 
8b62			;	endif 
8b62 fe 0e				cp KEY_HOME 
8b64 20 0e				jr nz, .iske 
8b66			 
8b66 3a b9 ee				ld a, (input_at_pos) 
8b69 32 b7 ee				ld (input_at_cursor),a 
8b6c 3e 00				ld a, 0 
8b6e 32 aa ee				ld (input_cursor), a 
8b71 c3 05 8b				jp .is1 
8b74					 
8b74 fe 0f		.iske:		cp KEY_END 
8b76 20 03				jr nz, .isknw 
8b78 c3 05 8b				jp .is1 
8b7b			 
8b7b fe 06		.isknw:		cp KEY_NEXTWORD 
8b7d 20 1b				jr nz, .iskpw 
8b7f			 
8b7f 2a be ee		.isknwm:	ld hl, (input_ptr) 
8b82 7e					ld a,(hl)	 
8b83 fe 00				cp 0 
8b85 ca 05 8b				jp z, .is1    ; end of string 
8b88 fe 20				cp ' ' 
8b8a ca 05 8b				jp z, .is1    ; end of word 
8b8d 23					inc hl 
8b8e 22 be ee				ld (input_ptr), hl 
8b91 3a b7 ee				ld a, (input_at_cursor) 
8b94 3c					inc a 
8b95 32 b7 ee				ld (input_at_cursor), a 
8b98 18 e5				jr .isknwm 
8b9a			 
8b9a fe 07		.iskpw:		cp KEY_PREVWORD 
8b9c 20 1b				jr nz, .iskl 
8b9e			.iskpwm:	 
8b9e 2a be ee				ld hl, (input_ptr) 
8ba1 7e					ld a,(hl)	 
8ba2 fe 00				cp 0  
8ba4 ca 05 8b				jp z, .is1    ; end of string 
8ba7 fe 20				cp ' ' 
8ba9 ca 05 8b				jp z, .is1    ; end of word 
8bac 2b					dec hl 
8bad 22 be ee				ld (input_ptr), hl 
8bb0 3a b7 ee				ld a, (input_at_cursor) 
8bb3 3d					dec a 
8bb4 32 b7 ee				ld (input_at_cursor), a 
8bb7 18 e5				jr .iskpwm 
8bb9			 
8bb9			 
8bb9 fe 0b		.iskl:		cp KEY_LEFT 
8bbb 20 27				jr nz, .isk1 
8bbd			 
8bbd 3a aa ee				ld a, (input_cursor) 
8bc0			 
8bc0 fe 00				cp 0 
8bc2 ca 05 8b				jp z, .is1 		; at start of line to ignore  
8bc5			 
8bc5 3d					dec  a 		; TODO check underflow 
8bc6 32 aa ee				ld (input_cursor), a 
8bc9			 
8bc9 2a be ee				ld hl, (input_ptr) 
8bcc 2b					dec hl 
8bcd 22 be ee				ld (input_ptr), hl 
8bd0					 
8bd0 3a b7 ee				ld a, (input_at_cursor) 
8bd3 3d					dec a 
8bd4 32 b7 ee				ld (input_at_cursor), a 
8bd7			 
8bd7 3e 01				ld a, 1		; show cursor moving 
8bd9 32 b4 ee				ld (input_cur_onoff),a 
8bdc 3e 0f				ld a, CUR_BLINK_RATE 
8bde 32 b5 ee				ld (input_cur_flash), a 
8be1			 
8be1 c3 05 8b				jp .is1 
8be4			 
8be4 fe 0c		.isk1:		cp KEY_RIGHT 
8be6 20 2a				jr nz, .isk2 
8be8			 
8be8 3a af ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8beb 5f					ld e,a 
8bec 3a aa ee				ld a, (input_cursor) 
8bef bb					cp e 
8bf0 ca 05 8b				jp z, .is1		; at the end of string so dont go right 
8bf3			 
8bf3 3c					inc  a 		; TODO check overflow 
8bf4 32 aa ee				ld (input_cursor), a 
8bf7			 
8bf7 3a b7 ee				ld a, (input_at_cursor) 
8bfa 3c					inc a 
8bfb 32 b7 ee				ld (input_at_cursor), a 
8bfe			 
8bfe 2a be ee				ld hl, (input_ptr) 
8c01 23					inc hl 
8c02 22 be ee				ld (input_ptr), hl 
8c05			 
8c05 3e 01				ld a, 1		; show cursor moving 
8c07 32 b4 ee				ld (input_cur_onoff),a 
8c0a 3e 0f				ld a, CUR_BLINK_RATE 
8c0c 32 b5 ee				ld (input_cur_flash), a 
8c0f			 
8c0f c3 05 8b				jp .is1 
8c12			 
8c12 fe 05		.isk2:		cp KEY_UP 
8c14			 
8c14 20 26				jr nz, .isk3 
8c16			 
8c16					; swap last command with the current on 
8c16			 
8c16					; move cursor to start of string 
8c16 2a bc ee				ld hl, (input_start) 
8c19 22 be ee				ld (input_ptr), hl 
8c1c			 
8c1c 3a b9 ee				ld a, (input_at_pos) 
8c1f 32 b7 ee				ld (input_at_cursor), a 
8c22			 
8c22 3e 00				ld a, 0 
8c24 32 aa ee				ld (input_cursor), a 
8c27					 
8c27					; swap input and last command buffers 
8c27			 
8c27 21 0d e8				ld hl, os_cli_cmd 
8c2a 11 0c e9				ld de, os_last_cmd 
8c2d 06 ff				ld b, 255 
8c2f 7e			.swap1:		ld a, (hl) 
8c30 4f					ld c,a 
8c31 1a					ld a, (de) 
8c32 77					ld (hl), a 
8c33 79					ld a,c 
8c34 12					ld (de),a 
8c35 23					inc hl 
8c36 13					inc de 
8c37 10 f6				djnz .swap1 
8c39			 
8c39			 
8c39			 
8c39			 
8c39			 
8c39 c3 05 8b				jp .is1 
8c3c			 
8c3c fe 08		.isk3:		cp KEY_BS 
8c3e 20 3c				jr nz, .isk4 
8c40			 
8c40 3a aa ee				ld a, (input_cursor) 
8c43			 
8c43 fe 00				cp 0 
8c45 ca 05 8b				jp z, .is1 		; at start of line to ignore  
8c48			 
8c48 3d					dec  a 		; TODO check underflow 
8c49 32 aa ee				ld (input_cursor), a 
8c4c			 
8c4c					; hl is source 
8c4c					; de needs to be source - 1 
8c4c			 
8c4c			;		ld a, 0 
8c4c			;		dec hl 
8c4c			;		ld (hl), a 
8c4c			 
8c4c 2a be ee				ld hl, (input_ptr) 
8c4f 2b					dec hl 
8c50 22 be ee				ld (input_ptr), hl 
8c53			 
8c53					; shift all data 
8c53			 
8c53 e5					push hl 
8c54 23					inc hl 
8c55 d1					pop de 
8c56 3a af ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c59 4f					ld c,a 
8c5a 06 00				ld b,0 
8c5c ed b0				ldir  
8c5e			 
8c5e			 
8c5e			 
8c5e			 
8c5e 3a b7 ee				ld a, (input_at_cursor) 
8c61 3d					dec a 
8c62 32 b7 ee				ld (input_at_cursor), a 
8c65			 
8c65			 
8c65 3e 01				ld a, 1		; show cursor moving 
8c67 32 b4 ee				ld (input_cur_onoff),a 
8c6a 3e 0f				ld a, CUR_BLINK_RATE 
8c6c 32 b5 ee				ld (input_cur_flash), a 
8c6f			 
8c6f					; remove char 
8c6f 3a b7 ee				ld a, (input_at_cursor) 
8c72 3c					inc a 
8c73 11 fd 8c				ld de,.iblank 
8c76 cd 8d 88				call str_at_display 
8c79			 
8c79 c3 05 8b				jp .is1 
8c7c			 
8c7c fe 0d		.isk4:		cp KEY_CR 
8c7e 28 6c				jr z, .endinput 
8c80			 
8c80					; else add the key press to the end 
8c80			 
8c80 4f					ld c, a			; save key pressed 
8c81			 
8c81 7e					ld a,(hl)		; get what is currently under char 
8c82			 
8c82 fe 00				cp 0			; we are at the end of the string 
8c84 20 2f				jr nz, .onchar 
8c86					 
8c86					; add a char to the end of the string 
8c86				 
8c86 71					ld (hl),c 
8c87 23					inc hl 
8c88			;		ld a,' ' 
8c88			;		ld (hl),a 
8c88			;		inc hl 
8c88 3e 00				ld a,0 
8c8a 77					ld (hl),a 
8c8b 2b					dec hl 
8c8c			 
8c8c 3a aa ee				ld a, (input_cursor) 
8c8f 3c					inc a				; TODO check max string length and scroll  
8c90 32 aa ee				ld (input_cursor), a		; inc cursor pos 
8c93							 
8c93 3a b7 ee				ld a, (input_at_cursor) 
8c96 3c					inc a 
8c97 32 b7 ee				ld (input_at_cursor), a 
8c9a			 
8c9a 2a be ee				ld hl, (input_ptr) 
8c9d 23					inc hl 
8c9e 22 be ee				ld (input_ptr), hl 
8ca1			 
8ca1 2a be ee				ld hl, (input_ptr) 
8ca4 23					inc hl 
8ca5 22 be ee				ld (input_ptr), hl 
8ca8			;	if DEBUG_INPUT 
8ca8			;		push af 
8ca8			;		ld a, '+' 
8ca8			;		ld (debug_mark),a 
8ca8			;		pop af 
8ca8			;		CALLMONITOR 
8ca8			;	endif 
8ca8 3e 01				ld a, 1		; show cursor moving 
8caa 32 b4 ee				ld (input_cur_onoff),a 
8cad 3e 0f				ld a, CUR_BLINK_RATE 
8caf 32 b5 ee				ld (input_cur_flash), a 
8cb2 c3 05 8b				jp .is1 
8cb5					 
8cb5			 
8cb5			 
8cb5					; if on a char then insert 
8cb5			.onchar: 
8cb5			 
8cb5					; TODO over flow check: make sure insert does not blow out buffer 
8cb5			 
8cb5					; need to do some maths to use lddr 
8cb5			 
8cb5 e5					push hl   ; save char pos 
8cb6 c5					push bc 
8cb7			 
8cb7 2a bc ee				ld hl, (input_start) 
8cba 3a af ee				ld a, (input_len) 
8cbd cd a7 8a				call addatohl  		; end of string 
8cc0 23					inc hl 
8cc1 23					inc hl		; past zero term 
8cc2 e5					push hl 
8cc3 23					inc hl 
8cc4 e5					push hl  
8cc5			 
8cc5								; start and end of lddr set, now how much to move? 
8cc5			 
8cc5							 
8cc5 3a aa ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cc8 47					ld b,a 
8cc9 3a af ee				ld a,(input_len) 
8ccc 5f					ld e,a 
8ccd 90					sub b 
8cce 3c					inc a		;?? 
8ccf 3c					inc a		;?? 
8cd0 3c					inc a		;?? 
8cd1			 
8cd1 06 00				ld b,0 
8cd3 4f					ld c,a 
8cd4			 
8cd4				if DEBUG_INPUT 
8cd4					push af 
8cd4					ld a, 'i' 
8cd4					ld (debug_mark),a 
8cd4					pop af 
8cd4			;		CALLMONITOR 
8cd4				endif 
8cd4 d1					pop de 
8cd5 e1					pop hl 
8cd6				if DEBUG_INPUT 
8cd6					push af 
8cd6					ld a, 'I' 
8cd6					ld (debug_mark),a 
8cd6					pop af 
8cd6			;		CALLMONITOR 
8cd6				endif 
8cd6 ed b8				lddr 
8cd8				 
8cd8			 
8cd8			 
8cd8					; TODO have a key for insert/overwrite mode???? 
8cd8 c1					pop bc 
8cd9 e1					pop hl 
8cda 71					ld (hl), c		; otherwise overwrite current char 
8cdb					 
8cdb			 
8cdb			 
8cdb			 
8cdb 3a aa ee				ld a, (input_cursor) 
8cde 3c					inc  a 		; TODO check overflow 
8cdf 32 aa ee				ld (input_cursor), a 
8ce2			 
8ce2 3a b7 ee				ld a, (input_at_cursor) 
8ce5 3c					inc a 
8ce6 32 b7 ee				ld (input_at_cursor), a 
8ce9			 
8ce9 c3 05 8b				jp .is1 
8cec			 
8cec			.endinput:	; TODO look for end of string 
8cec			 
8cec					; add trailing space for end of token 
8cec			 
8cec 2a bc ee				ld hl, (input_start) 
8cef 3a af ee				ld a,(input_len) 
8cf2 cd a7 8a				call addatohl 
8cf5 3e 20				ld a, ' ' 
8cf7 77					ld (hl),a 
8cf8					; TODO eof of parse marker 
8cf8			 
8cf8 23					inc hl 
8cf9 3e 00				ld a, 0 
8cfb 77					ld (hl),a 
8cfc			 
8cfc			 
8cfc c9					ret 
8cfd			 
8cfd .. 00		.iblank: db " ",0 
8cff			 
8cff			 
8cff 32 b9 ee		input_str_prev:	ld (input_at_pos), a 
8d02 22 bc ee				ld (input_start), hl 
8d05 3e 01				ld a,1			; add cursor 
8d07 77					ld (hl),a 
8d08 23					inc hl 
8d09 3e 00				ld a,0 
8d0b 77					ld (hl),a 
8d0c 22 be ee				ld (input_ptr), hl 
8d0f 7a					ld a,d 
8d10 32 bb ee				ld (input_size), a 
8d13 3e 00				ld a,0 
8d15 32 aa ee				ld (input_cursor),a 
8d18			.instr1:	 
8d18			 
8d18					; TODO do block cursor 
8d18					; TODO switch cursor depending on the modifer key 
8d18			 
8d18					; update cursor shape change on key hold 
8d18			 
8d18 2a be ee				ld hl, (input_ptr) 
8d1b 2b					dec hl 
8d1c 3a 59 ed				ld a,(cursor_shape) 
8d1f 77					ld (hl), a 
8d20			 
8d20					; display entered text 
8d20 3a b9 ee				ld a,(input_at_pos) 
8d23 cd 82 d6		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d26 ed 5b bc ee	            	LD   de, (input_start) 
8d2a cd 7c d6		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d2d			 
8d2d cd 24 d7				call cin 
8d30 fe 00				cp 0 
8d32 28 e4				jr z, .instr1 
8d34			 
8d34					; proecess keyboard controls first 
8d34			 
8d34 2a be ee				ld hl,(input_ptr) 
8d37			 
8d37 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d39 28 5a				jr z, .instrcr 
8d3b			 
8d3b fe 08				cp KEY_BS 	; back space 
8d3d 20 0f				jr nz, .instr2 
8d3f					; process back space 
8d3f			 
8d3f					; TODO stop back space if at start of string 
8d3f 2b					dec hl 
8d40 2b					dec hl ; to over write cursor 
8d41 3a 59 ed				ld a,(cursor_shape) 
8d44					;ld a,0 
8d44 77					ld (hl),a 
8d45 23					inc hl 
8d46 3e 20				ld a," " 
8d48 77					ld (hl),a 
8d49 22 be ee				ld (input_ptr),hl 
8d4c					 
8d4c			 
8d4c 18 ca				jr .instr1 
8d4e			 
8d4e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d50 20 06				jr nz, .instr3 
8d52 2b					dec hl 
8d53 22 be ee				ld (input_ptr),hl 
8d56 18 c0				jr .instr1 
8d58				 
8d58 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d5a 20 06				jr nz, .instr4 
8d5c 23					inc hl 
8d5d 22 be ee				ld (input_ptr),hl 
8d60 18 b6				jr .instr1 
8d62			 
8d62 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d64 20 06				jr nz, .instr5 
8d66 2b					dec hl 
8d67 22 be ee				ld (input_ptr),hl 
8d6a 18 ac				jr .instr1 
8d6c			 
8d6c fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d6e 20 06				jr nz, .instr6 
8d70 2b					dec hl 
8d71 22 be ee				ld (input_ptr),hl 
8d74 18 a2				jr .instr1 
8d76 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d78 20 0b				jr nz, .instrnew 
8d7a			 
8d7a 21 e6 e4			ld hl, scratch 
8d7d 11 0c e9			ld de, os_last_cmd 
8d80 cd 9e 8d			call strcpy 
8d83 18 93				jr .instr1 
8d85			 
8d85			 
8d85			.instrnew:	; no special key pressed to see if we have room to store it 
8d85			 
8d85					; TODO do string size test 
8d85			 
8d85 2b					dec hl ; to over write cursor 
8d86 77					ld (hl),a 
8d87 23					inc hl 
8d88 3a 59 ed				ld a,(cursor_shape) 
8d8b 77					ld (hl),a 
8d8c 23					inc hl 
8d8d 3e 00				ld a,0 
8d8f 77					ld (hl),a 
8d90			 
8d90 22 be ee				ld (input_ptr),hl 
8d93					 
8d93 18 83				jr .instr1 
8d95 2b			.instrcr:	dec hl		; remove cursor 
8d96 3e 20				ld a,' '	; TODO add a trailing space for safety 
8d98 77					ld (hl),a 
8d99 23					inc hl 
8d9a 3e 00				ld a,0 
8d9c 77					ld (hl),a 
8d9d			 
8d9d			 
8d9d					; if at end of line scroll up    
8d9d					; TODO detecting only end of line 4 for scroll up  
8d9d			 
8d9d					;ld   
8d9d			 
8d9d c9					ret 
8d9e			 
8d9e			 
8d9e			; strcpy hl = dest, de source 
8d9e			 
8d9e 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8d9f b7			            OR   A              ;Null terminator? 
8da0 c8			            RET  Z              ;Yes, so finished 
8da1 1a					ld a,(de) 
8da2 77					ld (hl),a 
8da3 13			            INC  DE             ;Point to next character 
8da4 23					inc hl 
8da5 18 f7		            JR   strcpy       ;Repeat 
8da7 c9					ret 
8da8			 
8da8			 
8da8			; TODO string_at  
8da8			; pass string which starts with lcd offset address and then null term string 
8da8			 
8da8			; TODO string to dec 
8da8			; TODO string to hex 
8da8			; TODO byte to string hex 
8da8			; TODO byte to string dec 
8da8			 
8da8			 
8da8			 
8da8			; from z80uartmonitor 
8da8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8da8			; pass hl for where to put the text 
8da8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da8 c5			hexout:	PUSH BC 
8da9 f5					PUSH AF 
8daa 47					LD B, A 
8dab					; Upper nybble 
8dab cb 3f				SRL A 
8dad cb 3f				SRL A 
8daf cb 3f				SRL A 
8db1 cb 3f				SRL A 
8db3 cd c3 8d				CALL tohex 
8db6 77					ld (hl),a 
8db7 23					inc hl	 
8db8					 
8db8					; Lower nybble 
8db8 78					LD A, B 
8db9 e6 0f				AND 0FH 
8dbb cd c3 8d				CALL tohex 
8dbe 77					ld (hl),a 
8dbf 23					inc hl	 
8dc0					 
8dc0 f1					POP AF 
8dc1 c1					POP BC 
8dc2 c9					RET 
8dc3					 
8dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc3			tohex: 
8dc3 e5					PUSH HL 
8dc4 d5					PUSH DE 
8dc5 16 00				LD D, 0 
8dc7 5f					LD E, A 
8dc8 21 d0 8d				LD HL, .DATA 
8dcb 19					ADD HL, DE 
8dcc 7e					LD A, (HL) 
8dcd d1					POP DE 
8dce e1					POP HL 
8dcf c9					RET 
8dd0			 
8dd0			.DATA: 
8dd0 30					DEFB	30h	; 0 
8dd1 31					DEFB	31h	; 1 
8dd2 32					DEFB	32h	; 2 
8dd3 33					DEFB	33h	; 3 
8dd4 34					DEFB	34h	; 4 
8dd5 35					DEFB	35h	; 5 
8dd6 36					DEFB	36h	; 6 
8dd7 37					DEFB	37h	; 7 
8dd8 38					DEFB	38h	; 8 
8dd9 39					DEFB	39h	; 9 
8dda 41					DEFB	41h	; A 
8ddb 42					DEFB	42h	; B 
8ddc 43					DEFB	43h	; C 
8ddd 44					DEFB	44h	; D 
8dde 45					DEFB	45h	; E 
8ddf 46					DEFB	46h	; F 
8de0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8de0			;;    subtract $30, if result > 9 then subtract $7 more 
8de0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de0			atohex: 
8de0 d6 30				SUB $30 
8de2 fe 0a				CP 10 
8de4 f8					RET M		; If result negative it was 0-9 so we're done 
8de5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8de7 c9					RET		 
8de8			 
8de8			 
8de8			 
8de8			 
8de8			; Get 2 ASCII characters as hex byte from pointer in hl 
8de8			 
8de8			BYTERD: 
8de8 16 00			LD	D,00h		;Set up 
8dea cd f2 8d			CALL	HEXCON		;Get byte and convert to hex 
8ded 87				ADD	A,A		;First nibble so 
8dee 87				ADD	A,A		;multiply by 16 
8def 87				ADD	A,A		; 
8df0 87				ADD	A,A		; 
8df1 57				LD	D,A		;Save hi nibble in D 
8df2			HEXCON: 
8df2 7e				ld a, (hl)		;Get next chr 
8df3 23				inc hl 
8df4 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8df6 fe 0a			CP	00Ah		;Is it 0-9 ? 
8df8 38 02			JR	C,NALPHA	;If so miss next bit 
8dfa d6 07			SUB	007h		;Else convert alpha 
8dfc			NALPHA: 
8dfc b2				OR	D		;Add hi nibble back 
8dfd c9				RET			; 
8dfe			 
8dfe			 
8dfe			; 
8dfe			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8dfe			; Since the routines get_byte and therefore get_nibble are called, only valid 
8dfe			; characters (0-9a-f) are accepted. 
8dfe			; 
8dfe			;get_word        push    af 
8dfe			;                call    get_byte        ; Get the upper byte 
8dfe			;                ld      h, a 
8dfe			;                call    get_byte        ; Get the lower byte 
8dfe			;                ld      l, a 
8dfe			;                pop     af 
8dfe			;                ret 
8dfe			; 
8dfe			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8dfe			; the routine get_nibble is used only valid characters are accepted - the  
8dfe			; input routine only accepts characters 0-9a-f. 
8dfe			; 
8dfe c5			get_byte:        push    bc              ; Save contents of B (and C) 
8dff 7e					ld a,(hl) 
8e00 23					inc hl 
8e01 cd 26 8e		                call    nibble2val      ; Get upper nibble 
8e04 cb 07		                rlc     a 
8e06 cb 07		                rlc     a 
8e08 cb 07		                rlc     a 
8e0a cb 07		                rlc     a 
8e0c 47			                ld      b, a            ; Save upper four bits 
8e0d 7e					ld a,(hl) 
8e0e cd 26 8e		                call    nibble2val      ; Get lower nibble 
8e11 b0			                or      b               ; Combine both nibbles 
8e12 c1			                pop     bc              ; Restore B (and C) 
8e13 c9			                ret 
8e14			; 
8e14			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e14			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e14			; to the serial line interface. The lower 4 bits of A contain the value of  
8e14			; that particular digit. 
8e14			; 
8e14			;get_nibble      ld a,(hl)           ; Read a character 
8e14			;                call    to_upper        ; Convert to upper case 
8e14			;                call    is_hex          ; Was it a hex digit? 
8e14			;                jr      nc, get_nibble  ; No, get another character 
8e14			 ;               call    nibble2val      ; Convert nibble to value 
8e14			 ;               call    print_nibble 
8e14			 ;               ret 
8e14			; 
8e14			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e14			; A valid hexadecimal digit is denoted by a set C flag. 
8e14			; 
8e14			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e14			;                ret     nc              ; Yes 
8e14			;                cp      '0'             ; Less than '0'? 
8e14			;                jr      nc, is_hex_1    ; No, continue 
8e14			;                ccf                     ; Complement carry (i.e. clear it) 
8e14			;                ret 
8e14			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e14			;                ret     c               ; Yes 
8e14			;                cp      'A'             ; Less than 'A'? 
8e14			;                jr      nc, is_hex_2    ; No, continue 
8e14			;                ccf                     ; Yes - clear carry and return 
8e14			;                ret 
8e14			;is_hex_2        scf                     ; Set carry 
8e14			;                ret 
8e14			; 
8e14			; Convert a single character contained in A to upper case: 
8e14			; 
8e14 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e16 d8			                ret     c 
8e17 fe 7b		                cp      'z' + 1         ; > 'z'? 
8e19 d0			                ret     nc              ; Nothing to do, either 
8e1a e6 5f		                and     $5f             ; Convert to upper case 
8e1c c9			                ret 
8e1d			 
8e1d			 
8e1d			to_lower: 
8e1d			 
8e1d			   ; if char is in [A-Z] make it lower case 
8e1d			 
8e1d			   ; enter : a = char 
8e1d			   ; exit  : a = lower case char 
8e1d			   ; uses  : af 
8e1d			 
8e1d fe 41		   cp 'A' 
8e1f d8			   ret c 
8e20			    
8e20 fe 5b		   cp 'Z'+1 
8e22 d0			   ret nc 
8e23			    
8e23 f6 20		   or $20 
8e25 c9			   ret 
8e26			 
8e26			; 
8e26			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e26			; corresponding value in A. 
8e26			; 
8e26 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e28 38 02		                jr      c, nibble2val_1 ; Yes 
8e2a d6 07		                sub     7               ; Adjust for A-F 
8e2c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e2e e6 0f		                and     $f              ; Only return lower 4 bits 
8e30 c9			                ret 
8e31			; 
8e31			; Print_nibble prints a single hex nibble which is contained in the lower  
8e31			; four bits of A: 
8e31			; 
8e31			;print_nibble    push    af              ; We won't destroy the contents of A 
8e31			;                and     $f              ; Just in case... 
8e31			;                add     a, '0'             ; If we have a digit we are done here. 
8e31			;                cp      '9' + 1         ; Is the result > 9? 
8e31			;                jr      c, print_nibble_1 
8e31			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e31			;print_nibble_1  call    putc            ; Print the nibble and 
8e31			;                pop     af              ; restore the original value of A 
8e31			;                ret 
8e31			;; 
8e31			;; Send a CR/LF pair: 
8e31			; 
8e31			;crlf            push    af 
8e31			;                ld      a, cr 
8e31			;                call    putc 
8e31			;                ld      a, lf 
8e31			;                call    putc 
8e31			;                pop     af 
8e31			;                ret 
8e31			; 
8e31			; Print_word prints the four hex digits of a word to the serial line. The  
8e31			; word is expected to be in HL. 
8e31			; 
8e31			;print_word      push    hl 
8e31			;                push    af 
8e31			;                ld      a, h 
8e31			;                call    print_byte 
8e31			;                ld      a, l 
8e31			;                call    print_byte 
8e31			;                pop     af 
8e31			;                pop     hl 
8e31			;                ret 
8e31			; 
8e31			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e31			; The byte to be printed is expected to be in A. 
8e31			; 
8e31			;print_byte      push    af              ; Save the contents of the registers 
8e31			;                push    bc 
8e31			;                ld      b, a 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                call    print_nibble    ; Print high nibble 
8e31			;                ld      a, b 
8e31			;                call    print_nibble    ; Print low nibble 
8e31			;                pop     bc              ; Restore original register contents 
8e31			;                pop     af 
8e31			;                ret 
8e31			 
8e31			 
8e31			 
8e31			 
8e31			 
8e31			fourehexhl:  
8e31 7e				ld a,(hl) 
8e32 cd e0 8d			call atohex 
8e35 cb 3f				SRL A 
8e37 cb 3f				SRL A 
8e39 cb 3f				SRL A 
8e3b cb 3f				SRL A 
8e3d 47				ld b, a 
8e3e 23				inc hl 
8e3f 7e				ld a,(hl) 
8e40 23				inc hl 
8e41 cd e0 8d			call atohex 
8e44 80				add b 
8e45 57				ld d,a 
8e46 7e				ld a,(hl) 
8e47 cd e0 8d			call atohex 
8e4a cb 3f				SRL A 
8e4c cb 3f				SRL A 
8e4e cb 3f				SRL A 
8e50 cb 3f				SRL A 
8e52 47				ld b, a 
8e53 23				inc hl 
8e54 7e				ld a,(hl) 
8e55 23				inc hl 
8e56 cd e0 8d			call atohex 
8e59 80				add b 
8e5a 5f				ld e, a 
8e5b d5				push de 
8e5c e1				pop hl 
8e5d c9				ret 
8e5e			 
8e5e			; pass hl. returns z set if the byte at hl is a digit 
8e5e			;isdigithl:  
8e5e			;	push bc 
8e5e			;	ld a,(hl) 
8e5e			;	cp ':' 
8e5e			;	jr nc, .isdf 		; > 
8e5e			;	cp '0' 
8e5e			;	jr c, .isdf		; < 
8e5e			; 
8e5e			;	; TODO find a better way to set z 
8e5e			; 
8e5e			;	ld b,a 
8e5e			;	cp b 
8e5e			;	pop bc 
8e5e			;	ret 
8e5e			; 
8e5e			;.isdf:	; not digit so clear z 
8e5e			; 
8e5e			;	; TODO find a better way to unset z 
8e5e			; 
8e5e			;	ld b,a 
8e5e			;	inc b 
8e5e			;	cp b 
8e5e			; 
8e5e			;	pop bc 
8e5e			;	ret 
8e5e				 
8e5e				 
8e5e			 
8e5e			 
8e5e			; pass hl as the four byte address to load 
8e5e			 
8e5e			get_word_hl:  
8e5e e5				push hl 
8e5f cd fe 8d			call get_byte 
8e62				 
8e62 47				ld b, a 
8e63			 
8e63 e1				pop hl 
8e64 23				inc hl 
8e65 23				inc hl 
8e66			 
8e66			; TODO not able to handle a-f  
8e66 7e				ld a,(hl) 
8e67			;	;cp ':' 
8e67			;	cp 'g' 
8e67			;	jr nc, .single_byte_hl 		; > 
8e67			;	cp 'G' 
8e67			;	jr nc, .single_byte_hl 		; > 
8e67			;	cp '0' 
8e67			;	jr c, .single_byte_hl		; < 
8e67			 
8e67				;call isdigithl 
8e67 fe 00			cp 0 
8e69 28 06			jr z, .single_byte_hl 
8e6b			 
8e6b			.getwhln:   ; hex word so get next byte 
8e6b			 
8e6b cd fe 8d			call get_byte 
8e6e 6f				ld l, a 
8e6f 60				ld h,b 
8e70 c9				ret 
8e71 68			.single_byte_hl:   ld l,b 
8e72 26 00				ld h,0 
8e74 c9					ret 
8e75			 
8e75			 
8e75			 
8e75			 
8e75 21 c5 95			ld hl,asc+1 
8e78			;	ld a, (hl) 
8e78			;	call nibble2val 
8e78 cd fe 8d			call get_byte 
8e7b			 
8e7b			;	call fourehexhl 
8e7b 32 1a e5			ld (scratch+52),a 
8e7e				 
8e7e 21 18 e5			ld hl,scratch+50 
8e81 22 09 e8			ld (os_cur_ptr),hl 
8e84			 
8e84 c9				ret 
8e85			 
8e85			 
8e85			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e85			 
8e85			; Decimal Unsigned Version 
8e85			 
8e85			;Number in a to decimal ASCII 
8e85			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e85			;Example: display a=56 as "056" 
8e85			;input: a = number 
8e85			;Output: a=0,value of a in the screen 
8e85			;destroys af,bc (don't know about hl and de) 
8e85			DispAToASCII: 
8e85 0e 9c			ld	c,-100 
8e87 cd 91 8e			call	.Na1 
8e8a 0e f6			ld	c,-10 
8e8c cd 91 8e			call	.Na1 
8e8f 0e ff			ld	c,-1 
8e91 06 2f		.Na1:	ld	b,'0'-1 
8e93 04			.Na2:	inc	b 
8e94 81				add	a,c 
8e95 38 fc			jr	c,.Na2 
8e97 91				sub	c		;works as add 100/10/1 
8e98 f5				push af		;safer than ld c,a 
8e99 78				ld	a,b		;char is in b 
8e9a			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8e9a f1				pop af		;safer than ld a,c 
8e9b c9				ret 
8e9c			 
8e9c			; Decimal Signed Version 
8e9c			 
8e9c			; DispA 
8e9c			; -------------------------------------------------------------- 
8e9c			; Converts a signed integer value to a zero-terminated ASCII 
8e9c			; string representative of that value (using radix 10). 
8e9c			; -------------------------------------------------------------- 
8e9c			; INPUTS: 
8e9c			;     HL     Value to convert (two's complement integer). 
8e9c			;     DE     Base address of string destination. (pointer). 
8e9c			; -------------------------------------------------------------- 
8e9c			; OUTPUTS: 
8e9c			;     None 
8e9c			; -------------------------------------------------------------- 
8e9c			; REGISTERS/MEMORY DESTROYED 
8e9c			; AF HL 
8e9c			; -------------------------------------------------------------- 
8e9c			 
8e9c			;DispHLToASCII: 
8e9c			;   push    de 
8e9c			;   push    bc 
8e9c			; 
8e9c			;; Detect sign of HL. 
8e9c			;    bit    7, h 
8e9c			;    jr     z, ._DoConvert 
8e9c			; 
8e9c			;; HL is negative. Output '-' to string and negate HL. 
8e9c			;    ld     a, '-' 
8e9c			;    ld     (de), a 
8e9c			;    inc    de 
8e9c			; 
8e9c			;; Negate HL (using two's complement) 
8e9c			;    xor    a 
8e9c			;    sub    l 
8e9c			;    ld     l, a 
8e9c			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8e9c			;    sbc    a, h 
8e9c			;    ld     h, a 
8e9c			; 
8e9c			;; Convert HL to digit characters 
8e9c			;._DoConvert: 
8e9c			;    ld     b, 0     ; B will count character length of number 
8e9c			;-   ld     a, 10 
8e9c			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8e9c			;    push   af 
8e9c			;    inc    b 
8e9c			;    ld     a, h 
8e9c			;    or     l 
8e9c			;    jr     nz, - 
8e9c			; 
8e9c			;; Retrieve digits from stack 
8e9c			;-   pop    af 
8e9c			;    or     $30 
8e9c			;    ld     (de), a 
8e9c			;    inc    de 
8e9c			;    djnz   - 
8e9c			; 
8e9c			;; Terminate string with NULL 
8e9c			;    xor    a 
8e9c			;    ld     (de), a 
8e9c			; 
8e9c			;    pop    bc 
8e9c			;    pop    de 
8e9c			;    ret 
8e9c			 
8e9c			;Comments 
8e9c			; 
8e9c			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8e9c			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8e9c			;    Note that the output string will not be fixed-width. 
8e9c			; 
8e9c			;Example Usage 
8e9c			; 
8e9c			;    ld    hl, -1004 
8e9c			;    ld    de, OP1 
8e9c			;    call  DispA 
8e9c			;    ld    hl, OP1 
8e9c			;    syscall  PutS 
8e9c			 
8e9c			 
8e9c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e9c			 
8e9c			 
8e9c			;Converts an ASCII string to an unsigned 16-bit integer 
8e9c			;Quits when it reaches a non-decimal digit 
8e9c			 
8e9c			string_to_uint16: 
8e9c			atoui_16: 
8e9c			;Input: 
8e9c			;     DE points to the string 
8e9c			;Outputs: 
8e9c			;     HL is the result 
8e9c			;     A is the 8-bit value of the number 
8e9c			;     DE points to the byte after the number 
8e9c			;Destroys: 
8e9c			;     BC 
8e9c			;       if the string is non-empty, BC is HL/10 
8e9c			;Size:  24 bytes 
8e9c			;Speed: 42+d(104+{0,9}) 
8e9c			;       d is the number of digits in the number 
8e9c			;       max is 640 cycles for a 5 digit number 
8e9c			;Assuming no leading zeros: 
8e9c			;1 digit:  146cc 
8e9c			;2 digit:  250cc 
8e9c			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8e9c			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8e9c			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8e9c			;avg: 544.81158447265625cc (544+13297/16384) 
8e9c			;=============================================================== 
8e9c 21 00 00		  ld hl,0 
8e9f			.u16a: 
8e9f 1a			  ld a,(de) 
8ea0 d6 30		  sub 30h 
8ea2 fe 0a		  cp 10 
8ea4 d0			  ret nc 
8ea5 13			  inc de 
8ea6 44			  ld b,h 
8ea7 4d			  ld c,l 
8ea8 29			  add hl,hl 
8ea9 29			  add hl,hl 
8eaa 09			  add hl,bc 
8eab 29			  add hl,hl 
8eac 85			  add a,l 
8ead 6f			  ld l,a 
8eae 30 ef		  jr nc,.u16a 
8eb0 24			  inc h 
8eb1 c3 9f 8e		  jp .u16a 
8eb4			 
8eb4			 
8eb4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eb4			 
8eb4			;written by Zeda 
8eb4			;Converts a 16-bit unsigned integer to an ASCII string. 
8eb4			 
8eb4			uitoa_16: 
8eb4			;Input: 
8eb4			;   DE is the number to convert 
8eb4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8eb4			;Output: 
8eb4			;   HL points to the null-terminated ASCII string 
8eb4			;      NOTE: This isn't necessarily the same as the input HL. 
8eb4 d5			  push de 
8eb5 c5			  push bc 
8eb6 f5			  push af 
8eb7 eb			  ex de,hl 
8eb8			 
8eb8 01 f0 d8		  ld bc,-10000 
8ebb 3e 2f		  ld a,'0'-1 
8ebd 3c			  inc a 
8ebe 09			  add hl,bc  
8ebf 38 fc		   jr c,$-2 
8ec1 12			  ld (de),a 
8ec2 13			  inc de 
8ec3			 
8ec3 01 e8 03		  ld bc,1000 
8ec6 3e 3a		  ld a,'9'+1 
8ec8 3d			  dec a  
8ec9 09			  add hl,bc  
8eca 30 fc		   jr nc,$-2 
8ecc 12			  ld (de),a 
8ecd 13			  inc de 
8ece			 
8ece 01 9c ff		  ld bc,-100 
8ed1 3e 2f		  ld a,'0'-1 
8ed3 3c			  inc a  
8ed4 09			  add hl,bc  
8ed5 38 fc		   jr c,$-2 
8ed7 12			  ld (de),a 
8ed8 13			  inc de 
8ed9			 
8ed9 7d			  ld a,l 
8eda 26 3a		  ld h,'9'+1 
8edc 25			  dec h  
8edd c6 0a		  add a,10  
8edf 30 fb		   jr nc,$-3 
8ee1 c6 30		  add a,'0' 
8ee3 eb			  ex de,hl 
8ee4 72			  ld (hl),d 
8ee5 23			  inc hl 
8ee6 77			  ld (hl),a 
8ee7 23			  inc hl 
8ee8 36 00		  ld (hl),0 
8eea			 
8eea			;Now strip the leading zeros 
8eea 0e fa		  ld c,-6 
8eec 09			  add hl,bc 
8eed 3e 30		  ld a,'0' 
8eef 23			  inc hl  
8ef0 be			  cp (hl)  
8ef1 28 fc		  jr z,$-2 
8ef3			 
8ef3			;Make sure that the string is non-empty! 
8ef3 7e			  ld a,(hl) 
8ef4 b7			  or a 
8ef5 20 01		  jr nz,.atoub 
8ef7 2b			  dec hl 
8ef8			.atoub: 
8ef8			 
8ef8 f1			  pop af 
8ef9 c1			  pop bc 
8efa d1			  pop de 
8efb c9			  ret 
8efc			 
8efc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8efc			 
8efc			toUpper: 
8efc			;A is the char. 
8efc			;If A is a lowercase letter, this sets it to the matching uppercase 
8efc			;18cc or 30cc or 41cc 
8efc			;avg: 26.75cc 
8efc fe 61		  cp 'a' 
8efe d8			  ret c 
8eff fe 7b		  cp 'z'+1 
8f01 d0			  ret nc 
8f02 d6 20		  sub 'a'-'A' 
8f04 c9			  ret 
8f05			 
8f05			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f05			 
8f05			; String Length 
8f05			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f05			 
8f05			; Get the length of the null-terminated string starting at $8000 hl 
8f05			;    LD     HL, $8000 
8f05			 
8f05			strlenz: 
8f05			 
8f05 af			    XOR    A               ; Zero is the value we are looking for. 
8f06 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f07 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f08			                           ; 65, 536 bytes (the entire addressable memory space). 
8f08 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f0a			 
8f0a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f0a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f0b 6f			    LD     L, A             ; number of bytes 
8f0c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f0e 2b			    DEC    HL              ; Compensate for null. 
8f0f c9				ret 
8f10			 
8f10			; Get the length of the A terminated string starting at $8000 hl 
8f10			;    LD     HL, $8000 
8f10			 
8f10			strlent: 
8f10			 
8f10			                  ; A is the value we are looking for. 
8f10 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f12 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f14			                           ; 65, 536 bytes (the entire addressable memory space). 
8f14 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f16			 
8f16			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f16 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f18 2e 00		    LD     L, 0             ; number of bytes 
8f1a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f1c 2b			    DEC    HL              ; Compensate for null. 
8f1d c9				ret 
8f1e			 
8f1e			 
8f1e			;Comparing Strings 
8f1e			 
8f1e			;IN    HL     Address of string1. 
8f1e			;      DE     Address of string2. 
8f1e			 
8f1e			; doc given but wrong??? 
8f1e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f1e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f1e			; tested 
8f1e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f1e			 
8f1e			strcmp_old: 
8f1e e5			    PUSH   HL 
8f1f d5			    PUSH   DE 
8f20			 
8f20 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f21 be			    CP     (HL)            ; (want to minimize work). 
8f22 38 01		    JR     C, Str1IsBigger 
8f24 7e			    LD     A, (HL) 
8f25			 
8f25			Str1IsBigger: 
8f25 4f			    LD     C, A             ; Put length in BC 
8f26 06 00		    LD     B, 0 
8f28 13			    INC    DE              ; Increment pointers to meat of string. 
8f29 23			    INC    HL 
8f2a			 
8f2a			CmpLoop: 
8f2a 1a			    LD     A, (DE)          ; Compare bytes. 
8f2b ed a1		    CPI 
8f2d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f2f 13			    INC    DE              ; Update pointer. 
8f30 ea 2a 8f		    JP     PE, CmpLoop 
8f33			 
8f33 d1			    POP    DE 
8f34 e1			    POP    HL 
8f35 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f36 be			    CP     (HL) 
8f37 c9			    RET 
8f38			 
8f38			NoMatch: 
8f38 2b			    DEC    HL 
8f39 be			    CP     (HL)            ; Compare again to affect carry. 
8f3a d1			    POP    DE 
8f3b e1			    POP    HL 
8f3c c9			    RET 
8f3d			 
8f3d			;; test strmp 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str2 
8f3d			;call strcmp 
8f3d			;jr z, .z1 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "NZ1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.z1: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "ZZ1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str1 
8f3d			;call strcmp 
8f3d			;jr z, .z2 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "NZ2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.z2: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "ZZ2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str2 
8f3d			;call strcmp 
8f3d			;jr c, .c1 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "Nc1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.c1: 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "cc1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str1 
8f3d			;call strcmp 
8f3d			;jr c, .c2 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "Nc2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.c2: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "cc2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;	NEXTW 
8f3d			;.str1:   db "string1",0 
8f3d			;.str2:   db "string2",0 
8f3d			 
8f3d			; only care about direct match or not 
8f3d			; hl and de strings 
8f3d			; zero set if the same 
8f3d			 
8f3d			strcmp: 
8f3d 1a				ld a, (de) 
8f3e be				cp (hl) 
8f3f 28 02			jr z, .ssame 
8f41 b7				or a 
8f42 c9				ret 
8f43			 
8f43			.ssame:  
8f43 fe 00			cp 0 
8f45 c8				ret z 
8f46			 
8f46 23				inc hl 
8f47 13				inc de 
8f48 18 f3			jr strcmp 
8f4a				 
8f4a				 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			; eof 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
# End of file firmware_strings.asm
8f4a			include "firmware_memory.asm"   ; malloc and free  
8f4a			 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			.mallocsize: db "Wants malloc >256",0 
8f4a			.mallocasize: db "MALLOC gives >256",0 
8f4a			.malloczero: db "MALLOC gives zero",0 
8f4a			 
8f4a			malloc_guard_zerolen: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a				ld de, 0 
8f4a			        call cmp16 
8f4a				jr nz, .lowalloz 
8f4a			 
8f4a				push hl 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .malloczero 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a			 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				 
8f4a			 
8f4a				CALLMONITOR 
8f4a			.lowalloz: 
8f4a			 
8f4a			 
8f4a				pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			 
8f4a			malloc_guard_entry: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a			 	or a      ;clear carry flag 
8f4a				push hl 
8f4a				ld de, 255 
8f4a				sbc hl, de 
8f4a				jr c, .lowalloc 
8f4a			 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .mallocsize 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a			 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				 
8f4a			 
8f4a				CALLMONITOR 
8f4a				jr .lowdone 
8f4a			.lowalloc: 
8f4a			 
8f4a			 
8f4a				pop hl 
8f4a			.lowdone:	pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			 
8f4a			malloc_guard_exit: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a			 	or a      ;clear carry flag 
8f4a				push hl 
8f4a				ld de, 255 
8f4a				sbc hl, de 
8f4a				jr c, .lowallocx 
8f4a			 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .mallocasize 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				CALLMONITOR 
8f4a				jr .lowdonex 
8f4a			.lowallocx: 
8f4a			 
8f4a				pop hl 
8f4a			.lowdonex:	pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			endif 
8f4a			 
8f4a			if MALLOC_2 
8f4a			; Z80 Malloc and Free Functions 
8f4a			 
8f4a			; Malloc Function: 
8f4a			; Input: 
8f4a			;   HL: Size of block to allocate 
8f4a			; Output: 
8f4a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4a			 
8f4a			malloc: 
8f4a				 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			call malloc_guard_entry 
8f4a			endif 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "mal" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			    push af            ; Save AF register 
8f4a			    ld a, l            ; Load low byte of size into A 
8f4a			    or h               ; Check if size is zero 
8f4a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f4a			 
8f4a			    ; Allocate memory 
8f4a			    ld hl, (heap_start) ; Load start of heap into HL 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma1" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			    call malloc_internal ; Call internal malloc function 
8f4a			    pop af             ; Restore AF register 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret                ; Return 
8f4a			 
8f4a			; Free Function: 
8f4a			; Input: 
8f4a			;   HL: Pointer to memory block to free 
8f4a			; Output: 
8f4a			;   None 
8f4a			 
8f4a			free: 
8f4a			    push af            ; Save AF register 
8f4a			    ld a, l            ; Load low byte of pointer into A 
8f4a			    or h               ; Check if pointer is NULL 
8f4a			    jp z, free_exit    ; If pointer is NULL, exit 
8f4a			 
8f4a			    ; Free memory 
8f4a			    ld hl, (heap_start) ; Load start of heap into HL 
8f4a			    call free_internal  ; Call internal free function 
8f4a			    pop af             ; Restore AF register 
8f4a			    ret                ; Return 
8f4a			 
8f4a			; Internal Malloc Function: 
8f4a			; Input: 
8f4a			;   HL: Size of block to allocate 
8f4a			; Output: 
8f4a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4a			 
8f4a			malloc_internal: 
8f4a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f4a			    add hl, bc         ; Add management overhead to requested size 
8f4a			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma2" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			 
8f4a			    ; Search for free memory block 
8f4a			    ld de, (heap_end)  ; Load end of heap into DE 
8f4a			    ld bc, 0           ; Initialize counter 
8f4a			 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma2" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			malloc_search_loop: 
8f4a			    ; Check if current block is free 
8f4a			    ld a, (hl)         ; Load current block's status (free or used) 
8f4a			    cp 0               ; Compare with zero (free) 
8f4a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f4a			 
8f4a			    ; Check if current block is large enough 
8f4a			    ld a, (hl+1)       ; Load high byte of block size 
8f4a			    cp l               ; Compare with low byte of requested size 
8f4a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f4a			 
8f4a			    ld a, (hl+2)       ; Load low byte of block size 
8f4a			    cp h               ; Compare with high byte of requested size 
8f4a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f4a			 
8f4a			    ; Mark block as used 
8f4a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f4a			 
8f4a			    ; Calculate remaining space in block 
8f4a			    ld bc, 0           ; Clear BC 
8f4a			    add hl, bc         ; Increment HL to point to start of data block 
8f4a			    add hl, de         ; HL = HL + DE (total size) 
8f4a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f4a			    add hl, bc         ; Add management overhead to start of data block 
8f4a			 
8f4a			    ; Save pointer to allocated block in HL 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma5" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			 
8f4a			malloc_skip_block_check: 
8f4a			    ; Move to the next block 
8f4a			    ld bc, 3           ; Size of management overhead 
8f4a			    add hl, bc         ; Move to the next block 
8f4a			    inc de             ; Increment counter 
8f4a			 
8f4a			    ; Check if we have reached the end of heap 
8f4a			    ld a, e            ; Load low byte of heap end address 
8f4a			    cp (hl)            ; Compare with low byte of current address 
8f4a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f4a			    ld a, d            ; Load high byte of heap end address 
8f4a			    cp 0               ; Check if it's zero (end of memory) 
8f4a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f4a			 
8f4a			    ; If we reached here, allocation failed 
8f4a			    xor a              ; Set result to NULL 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma6" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			malloc_exit: 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma7" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			 
8f4a			; Internal Free Function: 
8f4a			; Input: 
8f4a			;   HL: Pointer to memory block to free 
8f4a			; Output: 
8f4a			;   None 
8f4a			 
8f4a			free_internal: 
8f4a			    ld de, (heap_start) ; Load start of heap into DE 
8f4a			    ld bc, 0            ; Initialize counter 
8f4a			 
8f4a			free_search_loop: 
8f4a			    ; Check if current block contains the pointer 
8f4a			    ld a, l             ; Load low byte of pointer 
8f4a			    cp (hl+1)           ; Compare with high byte of current block's address 
8f4a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4a			    ld a, h             ; Load high byte of pointer 
8f4a			    cp (hl+2)           ; Compare with low byte of current block's address 
8f4a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4a			 
8f4a			    ; Mark block as free 
8f4a			    ld (hl), 0          ; Set status byte to indicate free block 
8f4a			    ret                 ; Return 
8f4a			 
8f4a			free_skip_block_check: 
8f4a			    ; Move to the next block 
8f4a			    ld bc, 3            ; Size of management overhead 
8f4a			    add hl, bc          ; Move to the next block 
8f4a			    inc de              ; Increment counter 
8f4a			 
8f4a			    ; Check if we have reached the end of heap 
8f4a			    ld a, e             ; Load low byte of heap end address 
8f4a			    cp (hl)             ; Compare with low byte of current address 
8f4a			    jr nz, free_search_loop  ; If not equal, continue searching 
8f4a			    ld a, d             ; Load high byte of heap end address 
8f4a			    cp 0                ; Check if it's zero (end of memory) 
8f4a			    jr nz, free_search_loop  ; If not zero, continue searching 
8f4a			 
8f4a			    ; If we reached here, pointer is not found in heap 
8f4a			    ret 
8f4a			 
8f4a			free_exit: 
8f4a			    ret                 ; Return 
8f4a			 
8f4a			; Define heap start and end addresses 
8f4a			;heap_start:    .dw 0xC000   ; Start of heap 
8f4a			;heap_end:      .dw 0xE000   ; End of heap 
8f4a			 
8f4a			endif 
8f4a			 
8f4a			 
8f4a			if MALLOC_1 
8f4a			 
8f4a			 
8f4a			 
8f4a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f4a			 
8f4a			;moved to firmware.asm 
8f4a			;heap_start        .equ  0x9000      ; Starting address of heap 
8f4a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f4a			 
8f4a			;      .org 0 
8f4a			;      jp    main 
8f4a			 
8f4a			 
8f4a			;      .org  0x100 
8f4a			;main: 
8f4a			;      ld    HL, 0x8100 
8f4a			;      ld    SP, HL 
8f4a			; 
8f4a			;      call  heap_init 
8f4a			; 
8f4a			;      ; Make some allocations 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9004 
8f4a			; 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9014 
8f4a			; 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9024 
8f4a			; 
8f4a			;      ; Free some allocations 
8f4a			;      ld    HL, 0x9014 
8f4a			;      call  free 
8f4a			; 
8f4a			;      ld    HL, 0x9004 
8f4a			;      call  free 
8f4a			; 
8f4a			;      ld    HL, 0x9024 
8f4a			;      call  free 
8f4a			; 
8f4a			; 
8f4a			;      halt 
8f4a			 
8f4a			 
8f4a			;------------------------------------------------------------------------------ 
8f4a			;     heap_init                                                               : 
8f4a			;                                                                             : 
8f4a			; Description                                                                 : 
8f4a			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f4a			;                                                                             : 
8f4a			;     The heap is maintained as a linked list, starting with an initial       : 
8f4a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f4a			;     the first free block in the heap. Each block then points to the next    : 
8f4a			;     free block within the heap, and the free list ends at the first block   : 
8f4a			;     with a null pointer to the next free block.                             : 
8f4a			;                                                                             : 
8f4a			; Parameters                                                                  : 
8f4a			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f4a			;     address of the heap and its size are required, along with a memory      : 
8f4a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f4a			;     principally stores a pointer to the first free block in the heap.       : 
8f4a			;                                                                             : 
8f4a			; Returns                                                                     : 
8f4a			;     Nothing                                                                 : 
8f4a			;------------------------------------------------------------------------------ 
8f4a			heap_init: 
8f4a e5			      push  HL 
8f4b			 
8f4b			      ; Initialise free list struct 
8f4b 21 42 d7		      ld    HL, heap_start 
8f4e 22 3d d7		      ld    (free_list), HL 
8f51 21 00 00		      ld    HL, 0 
8f54 22 3f d7		      ld    (free_list+2), HL 
8f57			 
8f57			      ; Insert first free block at bottom of heap, consumes entire heap 
8f57 21 c8 e4		      ld    HL, heap_start+heap_size-4 
8f5a 22 42 d7		      ld    (heap_start), HL        ; Next block (end of free list) 
8f5d 21 86 0d		      ld    HL, heap_size-4 
8f60 22 44 d7		      ld    (heap_start+2), HL      ; Block size 
8f63			 
8f63			      ; Insert end of free list block at top of heap - two null words will 
8f63			      ; terminate the free list 
8f63 21 00 00		      ld    HL, 0 
8f66 22 ca e4		      ld    (heap_start+heap_size-2), HL 
8f69 22 c8 e4		      ld    (heap_start+heap_size-4), HL 
8f6c			 
8f6c e1			      pop   HL 
8f6d			 
8f6d c9			      ret 
8f6e			 
8f6e			 
8f6e			;------------------------------------------------------------------------------ 
8f6e			;     malloc                                                                  : 
8f6e			;                                                                             : 
8f6e			; Description                                                                 : 
8f6e			;     Allocates the wanted space from the heap and returns the address of the : 
8f6e			;     first useable byte of the allocation.                                   : 
8f6e			;                                                                             : 
8f6e			;     Allocations can happen in one of two ways:                              : 
8f6e			;                                                                             : 
8f6e			;     1. A free block may be found which is the exact size wanted. In this    : 
8f6e			;        case the block is removed from the free list and retuedn to the      : 
8f6e			;        caller.                                                              : 
8f6e			;     2. A free block may be found which is larger than the size wanted. In   : 
8f6e			;        this case, the larger block is split into two. The first portion of  : 
8f6e			;        this block will become the requested space by the malloc call and    : 
8f6e			;        is returned to the caller. The second portion becomes a new free     : 
8f6e			;        block, and the free list is adjusted to maintain continuity via this : 
8f6e			;        newly created block.                                                 : 
8f6e			;                                                                             : 
8f6e			;     malloc does not set any initial value in the allocated space, the       : 
8f6e			;     caller is required to do this as required.                              : 
8f6e			;                                                                             : 
8f6e			;     This implementation of malloc uses the stack exclusively, and is        : 
8f6e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f6e			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f6e			;     to avoid the use of malloc inside ISRs in general.                      : 
8f6e			;                                                                             : 
8f6e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f6e			;                                                                             : 
8f6e			; Parameters                                                                  : 
8f6e			;     HL  Number of bytes wanted                                              : 
8f6e			;                                                                             : 
8f6e			; Returns                                                                     : 
8f6e			;     HL  Address of the first useable byte of the allocation                 : 
8f6e			;                                                                             : 
8f6e			; Flags                                                                       : 
8f6e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f6e			;                                                                             : 
8f6e			; Stack frame                                                                 : 
8f6e			;       |             |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     BC      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     DE      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     IX      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |  prev_free  |                                                       : 
8f6e			;   +4  +-------------+                                                       : 
8f6e			;       |  this_free  |                                                       : 
8f6e			;   +2  +-------------+                                                       : 
8f6e			;       |  next_free  |                                                       : 
8f6e			;   +0  +-------------+                                                       : 
8f6e			;       |             |                                                       : 
8f6e			;                                                                             : 
8f6e			;------------------------------------------------------------------------------ 
8f6e			 
8f6e			 
8f6e			;malloc: 
8f6e			; 
8f6e			;	SAVESP ON 1 
8f6e			; 
8f6e			;	call malloc_code 
8f6e			; 
8f6e			;	CHECKSP ON 1 
8f6e			;	ret 
8f6e			 
8f6e			 
8f6e			malloc: 
8f6e c5			      push  BC 
8f6f d5			      push  DE 
8f70 dd e5		      push  IX 
8f72			if DEBUG_FORTH_MALLOC_HIGH 
8f72			call malloc_guard_entry 
8f72			endif 
8f72			 
8f72					if DEBUG_FORTH_MALLOC 
8f72						DMARK "mal" 
8f72						CALLMONITOR 
8f72					endif 
8f72 7c			      ld    A, H                    ; Exit if no space requested 
8f73 b5			      or    L 
8f74 ca 33 90		      jp    Z, malloc_early_exit 
8f77			 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			; 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			 
8f77			 
8f77			 
8f77			 
8f77					if DEBUG_FORTH_MALLOC 
8f77						DMARK "maA" 
8f77						CALLMONITOR 
8f77					endif 
8f77			      ; Set up stack frame 
8f77 eb			      ex    DE, HL 
8f78 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f7b 39			      add   HL, SP 
8f7c f9			      ld    SP, HL 
8f7d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f81 dd 39		      add   IX, SP 
8f83			 
8f83			      ; Setup initial state 
8f83 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f86 19			      add   HL, DE 
8f87			 
8f87 44			      ld    B, H                    ; Move want to BC 
8f88 4d			      ld    C, L 
8f89			 
8f89 21 3d d7		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f8c dd 75 04		      ld    (IX+4), L 
8f8f dd 74 05		      ld    (IX+5), H 
8f92			 
8f92 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f93 23			      inc   HL 
8f94 56			      ld    D, (HL) 
8f95 dd 73 02		      ld    (IX+2), E 
8f98 dd 72 03		      ld    (IX+3), D 
8f9b eb			      ex    DE, HL                  ; this_free ptr into HL 
8f9c			 
8f9c					if DEBUG_FORTH_MALLOC 
8f9c						DMARK "maB" 
8f9c						CALLMONITOR 
8f9c					endif 
8f9c			      ; Loop through free block list to find some space 
8f9c			malloc_find_space: 
8f9c 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8f9d 23			      inc   HL 
8f9e 56			      ld    D, (HL) 
8f9f			 
8f9f 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fa0 b3			      or    E 
8fa1 ca 2d 90		      jp    Z, malloc_no_space 
8fa4			 
8fa4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fa7 dd 72 01		      ld    (IX+1), D 
8faa			 
8faa			      ; Does this block have enough space to make the allocation? 
8faa 23			      inc   HL                      ; Load free block size into DE 
8fab 5e			      ld    E, (HL) 
8fac 23			      inc   HL 
8fad 56			      ld    D, (HL) 
8fae			 
8fae eb			      ex    DE, HL                  ; Check size of block against want 
8faf b7			      or    A                       ; Ensure carry flag clear 
8fb0 ed 42		      sbc   HL, BC 
8fb2 e5			      push  HL                      ; Store the result for later (new block size) 
8fb3			 
8fb3 ca 02 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fb6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fb8			 
8fb8			      ; this_free block is not big enough, setup ptrs to test next free block 
8fb8 e1			      pop   HL                      ; Discard previous result 
8fb9			 
8fb9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fbc dd 66 03		      ld    H, (IX+3) 
8fbf dd 75 04		      ld    (IX+4), L 
8fc2 dd 74 05		      ld    (IX+5), H 
8fc5			 
8fc5 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fc8 dd 66 01		      ld    H, (IX+1) 
8fcb dd 75 02		      ld    (IX+2), L 
8fce dd 74 03		      ld    (IX+3), H 
8fd1			 
8fd1					if DEBUG_FORTH_MALLOC 
8fd1						DMARK "MA>" 
8fd1						CALLMONITOR 
8fd1					endif 
8fd1 18 c9		      jr    malloc_find_space 
8fd3			 
8fd3			      ; split a bigger block into two - requested size and remaining size 
8fd3			malloc_alloc_split: 
8fd3					if DEBUG_FORTH_MALLOC 
8fd3						DMARK "MAs" 
8fd3						CALLMONITOR 
8fd3					endif 
8fd3 eb			      ex    DE, HL                  ; Calculate address of new free block 
8fd4 2b			      dec   HL 
8fd5 2b			      dec   HL 
8fd6 2b			      dec   HL 
8fd7 09			      add   HL, BC 
8fd8			 
8fd8			      ; Create a new block and point it at next_free 
8fd8 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fdb dd 56 01		      ld    D, (IX+1) 
8fde			 
8fde 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8fdf 23			      inc   HL 
8fe0 72			      ld    (HL), D 
8fe1			 
8fe1 d1			      pop   DE                      ; Store size of new block into new block 
8fe2 23			      inc   HL 
8fe3 73			      ld    (HL), E 
8fe4 23			      inc   HL 
8fe5 72			      ld    (HL), D 
8fe6			 
8fe6			      ; Update this_free ptr to point to new block 
8fe6 2b			      dec   HL 
8fe7 2b			      dec   HL 
8fe8 2b			      dec   HL 
8fe9			 
8fe9 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8fec dd 56 03		      ld    D, (IX+3) 
8fef			 
8fef dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8ff2 dd 74 03		      ld    (IX+3), H 
8ff5			 
8ff5			      ; Modify this_free block to be allocation 
8ff5 eb			      ex    DE, HL 
8ff6 af			      xor   A                       ; Null the next block ptr of allocated block 
8ff7 77			      ld    (HL), A 
8ff8 23			      inc   HL 
8ff9 77			      ld    (HL), A 
8ffa			 
8ffa 23			      inc   HL                      ; Store want size into allocated block 
8ffb 71			      ld    (HL), C 
8ffc 23			      inc   HL 
8ffd 70			      ld    (HL), B 
8ffe 23			      inc   HL 
8fff e5			      push  HL                      ; Address of allocation to return 
9000			 
9000 18 19		      jr    malloc_update_links 
9002			 
9002			malloc_alloc_fit: 
9002 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9003			 
9003					if DEBUG_FORTH_MALLOC 
9003						DMARK "MAf" 
9003						CALLMONITOR 
9003					endif 
9003			      ; Modify this_free block to be allocation 
9003 eb			      ex    DE, HL 
9004 2b			      dec   HL 
9005 2b			      dec   HL 
9006 2b			      dec   HL 
9007			 
9007 af			      xor   A                       ; Null the next block ptr of allocated block 
9008 77			      ld    (HL), A 
9009 23			      inc   HL 
900a 77			      ld    (HL), A 
900b			 
900b 23			      inc   HL                      ; Store address of allocation to return 
900c 23			      inc   HL 
900d 23			      inc   HL 
900e e5			      push  HL 
900f			 
900f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
900f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9012 dd 66 01		      ld    H, (IX+1) 
9015			 
9015 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9018 dd 74 03		      ld    (IX+3), H 
901b			 
901b			 
901b			malloc_update_links: 
901b			      ; Update prev_free ptr to point to this_free 
901b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
901e dd 66 05		      ld    H, (IX+5) 
9021			 
9021 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9024 dd 56 03		      ld    D, (IX+3) 
9027			 
9027 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9028 23			      inc   HL 
9029 72			      ld    (HL), D 
902a			 
902a					if DEBUG_FORTH_MALLOC 
902a						DMARK "Mul" 
902a						CALLMONITOR 
902a					endif 
902a			      ; Clear the Z flag to indicate successful allocation 
902a 7a			      ld    A, D 
902b b3			      or    E 
902c			 
902c d1			      pop   DE                      ; Address of allocation 
902d					if DEBUG_FORTH_MALLOC 
902d						DMARK "MAu" 
902d						CALLMONITOR 
902d					endif 
902d			 
902d			malloc_no_space: 
902d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9030 39			      add   HL, SP 
9031 f9			      ld    SP, HL 
9032			 
9032 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9033					if DEBUG_FORTH_MALLOC 
9033						DMARK "MAN" 
9033						CALLMONITOR 
9033					endif 
9033			 
9033			malloc_early_exit: 
9033					if DEBUG_FORTH_MALLOC 
9033						DMARK "MAx" 
9033						CALLMONITOR 
9033					endif 
9033 dd e1		      pop   IX 
9035 d1			      pop   DE 
9036 c1			      pop   BC 
9037			 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037			call malloc_guard_exit 
9037			call malloc_guard_zerolen 
9037			endif 
9037 c9			      ret 
9038			 
9038			 
9038			;------------------------------------------------------------------------------ 
9038			;     free                                                                    : 
9038			;                                                                             : 
9038			; Description                                                                 : 
9038			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9038			;     returned by malloc, otherwise the behaviour is undefined.               : 
9038			;                                                                             : 
9038			;     Where possible, directly adjacent free blocks will be merged together   : 
9038			;     into larger blocks to help ensure that the heap does not become         : 
9038			;     excessively fragmented.                                                 : 
9038			;                                                                             : 
9038			;     free does not clear or set any other value into the freed space, and    : 
9038			;     therefore its contents may be visible through subsequent malloc's. The  : 
9038			;     caller should clear the freed space as required.                        : 
9038			;                                                                             : 
9038			;     This implementation of free uses the stack exclusively, and is          : 
9038			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9038			;     advisable to disable interrupts before calling free, and recommended    : 
9038			;     to avoid the use of free inside ISRs in general.                        : 
9038			;                                                                             : 
9038			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9038			;                                                                             : 
9038			; Parameters                                                                  : 
9038			;     HL  Pointer to address of first byte of allocation to be freed          : 
9038			;                                                                             : 
9038			; Returns                                                                     : 
9038			;     Nothing                                                                 : 
9038			;                                                                             : 
9038			; Stack frame                                                                 : 
9038			;       |             |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     BC      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     DE      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     IX      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |  prev_free  |                                                       : 
9038			;   +2  +-------------+                                                       : 
9038			;       |  next_free  |                                                       : 
9038			;   +0  +-------------+                                                       : 
9038			;       |             |                                                       : 
9038			;                                                                             : 
9038			;------------------------------------------------------------------------------ 
9038			free: 
9038 c5			      push  BC 
9039 d5			      push  DE 
903a dd e5		      push  IX 
903c			 
903c 7c			      ld    A, H                    ; Exit if ptr is null 
903d b5			      or    L 
903e ca 02 91		      jp    Z, free_early_exit 
9041			 
9041			      ; Set up stack frame 
9041 eb			      ex    DE, HL 
9042 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9045 39			      add   HL, SP 
9046 f9			      ld    SP, HL 
9047 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
904b dd 39		      add   IX, SP 
904d			 
904d			      ; The address in HL points to the start of the useable allocated space, 
904d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
904d			      ; address of the block itself. 
904d eb			      ex    DE, HL 
904e 11 fc ff		      ld    DE, -4 
9051 19			      add   HL, DE 
9052			 
9052			      ; An allocated block must have a null next block pointer in it 
9052 7e			      ld    A, (HL) 
9053 23			      inc   HL 
9054 b6			      or    (HL) 
9055 c2 fd 90		      jp    NZ, free_done 
9058			 
9058 2b			      dec   HL 
9059			 
9059 44			      ld    B, H                    ; Copy HL to BC 
905a 4d			      ld    C, L 
905b			 
905b			      ; Loop through the free list to find the first block with an address 
905b			      ; higher than the block being freed 
905b 21 3d d7		      ld    HL, free_list 
905e			 
905e			free_find_higher_block: 
905e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
905f 23			      inc   HL 
9060 56			      ld    D, (HL) 
9061 2b			      dec   HL 
9062			 
9062 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9065 dd 72 01		      ld    (IX+1), D 
9068 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
906b dd 74 03		      ld    (IX+3), H 
906e			 
906e 78			      ld    A, B                    ; Check if DE is greater than BC 
906f ba			      cp    D                       ; Compare MSB first 
9070 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9072 30 04		      jr    NC, free_find_higher_block_skip 
9074 79			      ld    A, C 
9075 bb			      cp    E                       ; Then compare LSB 
9076 38 08		      jr    C, free_found_higher_block 
9078			 
9078			free_find_higher_block_skip: 
9078 7a			      ld    A, D                    ; Reached the end of the free list? 
9079 b3			      or    E 
907a ca fd 90		      jp    Z, free_done 
907d			 
907d eb			      ex    DE, HL 
907e			 
907e 18 de		      jr    free_find_higher_block 
9080			 
9080			free_found_higher_block: 
9080			      ; Insert freed block between prev and next free blocks 
9080 71			      ld    (HL), C                 ; Point prev free block to freed block 
9081 23			      inc   HL 
9082 70			      ld    (HL), B 
9083			 
9083 60			      ld    H, B                    ; Point freed block at next free block 
9084 69			      ld    L, C 
9085 73			      ld    (HL), E 
9086 23			      inc   HL 
9087 72			      ld    (HL), D 
9088			 
9088			      ; Check if the freed block is adjacent to the next free block 
9088 23			      inc   HL                      ; Load size of freed block into HL 
9089 5e			      ld    E, (HL) 
908a 23			      inc   HL 
908b 56			      ld    D, (HL) 
908c eb			      ex    DE, HL 
908d			 
908d 09			      add   HL, BC                  ; Add addr of freed block and its size 
908e			 
908e dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9091 dd 56 01		      ld    D, (IX+1) 
9094			 
9094 b7			      or    A                       ; Clear the carry flag 
9095 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9097 20 22		      jr    NZ, free_check_adjacent_to_prev 
9099			 
9099			      ; Freed block is adjacent to next, merge into one bigger block 
9099 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
909a 5e			      ld    E, (HL) 
909b 23			      inc   HL 
909c 56			      ld    D, (HL) 
909d e5			      push  HL                      ; Save ptr to next block for later 
909e			 
909e 60			      ld    H, B                    ; Store ptr from next block into freed block 
909f 69			      ld    L, C 
90a0 73			      ld    (HL), E 
90a1 23			      inc   HL 
90a2 72			      ld    (HL), D 
90a3			 
90a3 e1			      pop   HL                      ; Restore ptr to next block 
90a4 23			      inc   HL                      ; Load size of next block into DE 
90a5 5e			      ld    E, (HL) 
90a6 23			      inc   HL 
90a7 56			      ld    D, (HL) 
90a8 d5			      push  DE                      ; Save next block size for later 
90a9			 
90a9 60			      ld    H, B                    ; Load size of freed block into HL 
90aa 69			      ld    L, C 
90ab 23			      inc   HL 
90ac 23			      inc   HL 
90ad 5e			      ld    E, (HL) 
90ae 23			      inc   HL 
90af 56			      ld    D, (HL) 
90b0 eb			      ex    DE, HL 
90b1			 
90b1 d1			      pop   DE                      ; Restore size of next block 
90b2 19			      add   HL, DE                  ; Add sizes of both blocks 
90b3 eb			      ex    DE, HL 
90b4			 
90b4 60			      ld    H, B                    ; Store new bigger size into freed block 
90b5 69			      ld    L, C 
90b6 23			      inc   HL 
90b7 23			      inc   HL 
90b8 73			      ld    (HL), E 
90b9 23			      inc   HL 
90ba 72			      ld    (HL), D 
90bb			 
90bb			free_check_adjacent_to_prev: 
90bb			      ; Check if the freed block is adjacent to the prev free block 
90bb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90be dd 66 03		      ld    H, (IX+3) 
90c1			 
90c1 23			      inc   HL                      ; Size of prev free block into DE 
90c2 23			      inc   HL 
90c3 5e			      ld    E, (HL) 
90c4 23			      inc   HL 
90c5 56			      ld    D, (HL) 
90c6 2b			      dec   HL 
90c7 2b			      dec   HL 
90c8 2b			      dec   HL 
90c9			 
90c9 19			      add   HL, DE                  ; Add prev block addr and size 
90ca			 
90ca b7			      or    A                       ; Clear the carry flag 
90cb ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90cd 20 2e		      jr    NZ, free_done 
90cf			 
90cf			      ; Freed block is adjacent to prev, merge into one bigger block 
90cf 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90d0 69			      ld    L, C 
90d1 5e			      ld    E, (HL) 
90d2 23			      inc   HL 
90d3 56			      ld    D, (HL) 
90d4 e5			      push  HL                      ; Save freed block ptr for later 
90d5			 
90d5 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90d8 dd 66 03		      ld    H, (IX+3) 
90db 73			      ld    (HL), E 
90dc 23			      inc   HL 
90dd 72			      ld    (HL), D 
90de			 
90de e1			      pop   HL                      ; Restore freed block ptr 
90df 23			      inc   HL                      ; Load size of freed block into DE 
90e0 5e			      ld    E, (HL) 
90e1 23			      inc   HL 
90e2 56			      ld    D, (HL) 
90e3 d5			      push  DE                      ; Save freed block size for later 
90e4			 
90e4 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90e7 dd 66 03		      ld    H, (IX+3) 
90ea 23			      inc   HL 
90eb 23			      inc   HL 
90ec 5e			      ld    E, (HL) 
90ed 23			      inc   HL 
90ee 56			      ld    D, (HL) 
90ef			 
90ef e1			      pop   HL                      ; Add sizes of both blocks 
90f0 19			      add   HL, DE 
90f1 eb			      ex    DE, HL 
90f2			 
90f2 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
90f5 dd 66 03		      ld    H, (IX+3) 
90f8 23			      inc   HL 
90f9 23			      inc   HL 
90fa 73			      ld    (HL), E 
90fb 23			      inc   HL 
90fc 72			      ld    (HL), D 
90fd			 
90fd			free_done: 
90fd 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9100 39			      add   HL, SP 
9101 f9			      ld    SP, HL 
9102			 
9102			free_early_exit: 
9102 dd e1		      pop   IX 
9104 d1			      pop   DE 
9105 c1			      pop   BC 
9106			 
9106 c9			      ret 
9107			 
9107			; moved to firmware.asm 
9107			; 
9107			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9107			;                  .dw   0 
9107			 
9107			 
9107			endif 
9107			 
9107			 
9107			if MALLOC_3 
9107			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9107			;heap_start        .equ  0x9000      ; Starting address of heap 
9107			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9107			; 
9107			 ;     .org 0 
9107			  ;    jp    main 
9107			; 
9107			; 
9107			 ;     .org  0x100 
9107			;main: 
9107			 ;     ld    HL, 0x8100 
9107			  ;    ld    SP, HL 
9107			; 
9107			;      call  heap_init 
9107			 
9107			      ; Make some allocations 
9107			;      ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9004 
9107			; 
9107			 ;     ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9014 
9107			 
9107			;      ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9024 
9107			 
9107			      ; Free some allocations 
9107			;      ld    HL, 0x9014 
9107			;      call  free 
9107			 
9107			;      ld    HL, 0x9004 
9107			;      call  free 
9107			; 
9107			;      ld    HL, 0x9024 
9107			;      call  free 
9107			 
9107			 
9107			 ;     halt 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     heap_init                                                               : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Initialise the heap and make it ready for malloc and free operations.   : 
9107			;                                                                             : 
9107			;     The heap is maintained as a linked list, starting with an initial       : 
9107			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9107			;     the first free block in the heap. Each block then points to the next    : 
9107			;     free block within the heap, and the free list ends at the first block   : 
9107			;     with a null pointer to the next free block.                             : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     Inputs are compile-time only. Two defines which specify the starting    : 
9107			;     address of the heap and its size are required, along with a memory      : 
9107			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9107			;     principally stores a pointer to the first free block in the heap.       : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     Nothing                                                                 : 
9107			;------------------------------------------------------------------------------ 
9107			heap_init: 
9107			      push  HL 
9107			 
9107			      ; Initialise free list struct 
9107			      ld    HL, heap_start 
9107			      ld    (free_list), HL 
9107			      ld    HL, 0 
9107			      ld    (free_list+2), HL 
9107			 
9107			      ; Insert first free block at bottom of heap, consumes entire heap 
9107			      ld    HL, heap_start+heap_size-4 
9107			      ld    (heap_start), HL        ; Next block (end of free list) 
9107			      ld    HL, heap_size-4 
9107			      ld    (heap_start+2), HL      ; Block size 
9107			 
9107			      ; Insert end of free list block at top of heap - two null words will 
9107			      ; terminate the free list 
9107			      ld    HL, 0 
9107			      ld    (heap_start+heap_size-2), HL 
9107			      ld    (heap_start+heap_size-4), HL 
9107			 
9107			      pop   HL 
9107			 
9107			      ret 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     malloc                                                                  : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Allocates the wanted space from the heap and returns the address of the : 
9107			;     first useable byte of the allocation.                                   : 
9107			;                                                                             : 
9107			;     Allocations can happen in one of two ways:                              : 
9107			;                                                                             : 
9107			;     1. A free block may be found which is the exact size wanted. In this    : 
9107			;        case the block is removed from the free list and retuedn to the      : 
9107			;        caller.                                                              : 
9107			;     2. A free block may be found which is larger than the size wanted. In   : 
9107			;        this case, the larger block is split into two. The first portion of  : 
9107			;        this block will become the requested space by the malloc call and    : 
9107			;        is returned to the caller. The second portion becomes a new free     : 
9107			;        block, and the free list is adjusted to maintain continuity via this : 
9107			;        newly created block.                                                 : 
9107			;                                                                             : 
9107			;     malloc does not set any initial value in the allocated space, the       : 
9107			;     caller is required to do this as required.                              : 
9107			;                                                                             : 
9107			;     This implementation of malloc uses the stack exclusively, and is        : 
9107			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9107			;     advisable to disable interrupts before calling malloc, and recommended  : 
9107			;     to avoid the use of malloc inside ISRs in general.                      : 
9107			;                                                                             : 
9107			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     HL  Number of bytes wanted                                              : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     HL  Address of the first useable byte of the allocation                 : 
9107			;                                                                             : 
9107			; Flags                                                                       : 
9107			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9107			;                                                                             : 
9107			; Stack frame                                                                 : 
9107			;       |             |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     BC      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     DE      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     IX      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |  prev_free  |                                                       : 
9107			;   +4  +-------------+                                                       : 
9107			;       |  this_free  |                                                       : 
9107			;   +2  +-------------+                                                       : 
9107			;       |  next_free  |                                                       : 
9107			;   +0  +-------------+                                                       : 
9107			;       |             |                                                       : 
9107			;                                                                             : 
9107			;------------------------------------------------------------------------------ 
9107			malloc: 
9107			      push  BC 
9107			      push  DE 
9107			      push  IX 
9107			 
9107			      ld    A, H                    ; Exit if no space requested 
9107			      or    L 
9107			      jp    Z, malloc_early_exit 
9107			 
9107			      ; Set up stack frame 
9107			      ex    DE, HL 
9107			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			      ld    IX, 0                   ; Use IX as a frame pointer 
9107			      add   IX, SP 
9107			 
9107			      ; Setup initial state 
9107			      ld    HL, 4                   ; want must also include space used by block struct 
9107			      add   HL, DE 
9107			 
9107			      ld    B, H                    ; Move want to BC 
9107			      ld    C, L 
9107			 
9107			      ld    HL, free_list           ; Store prev_free ptr to stack 
9107			      ld    (IX+4), L 
9107			      ld    (IX+5), H 
9107			 
9107			      ld    E, (HL)                 ; Store this_free ptr to stack 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ld    (IX+2), E 
9107			      ld    (IX+3), D 
9107			      ex    DE, HL                  ; this_free ptr into HL 
9107			 
9107			      ; Loop through free block list to find some space 
9107			malloc_find_space: 
9107			      ld    E, (HL)                 ; Load next_free ptr into DE 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9107			      or    E 
9107			      jp    Z, malloc_no_space 
9107			 
9107			      ld    (IX+0), E               ; Store next_free ptr to stack 
9107			      ld    (IX+1), D 
9107			 
9107			      ; Does this block have enough space to make the allocation? 
9107			      inc   HL                      ; Load free block size into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      ex    DE, HL                  ; Check size of block against want 
9107			      or    A                       ; Ensure carry flag clear 
9107			      sbc   HL, BC 
9107			      push  HL                      ; Store the result for later (new block size) 
9107			 
9107			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9107			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9107			 
9107			      ; this_free block is not big enough, setup ptrs to test next free block 
9107			      pop   HL                      ; Discard previous result 
9107			 
9107			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9107			      ld    H, (IX+3) 
9107			      ld    (IX+4), L 
9107			      ld    (IX+5), H 
9107			 
9107			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9107			      ld    H, (IX+1) 
9107			      ld    (IX+2), L 
9107			      ld    (IX+3), H 
9107			 
9107			      jr    malloc_find_space 
9107			 
9107			      ; split a bigger block into two - requested size and remaining size 
9107			malloc_alloc_split: 
9107			      ex    DE, HL                  ; Calculate address of new free block 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			      add   HL, BC 
9107			 
9107			      ; Create a new block and point it at next_free 
9107			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9107			      ld    D, (IX+1) 
9107			 
9107			      ld    (HL), E                 ; Store next_free ptr into new block 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   DE                      ; Store size of new block into new block 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Update this_free ptr to point to new block 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9107			      ld    D, (IX+3) 
9107			 
9107			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9107			      ld    (IX+3), H 
9107			 
9107			      ; Modify this_free block to be allocation 
9107			      ex    DE, HL 
9107			      xor   A                       ; Null the next block ptr of allocated block 
9107			      ld    (HL), A 
9107			      inc   HL 
9107			      ld    (HL), A 
9107			 
9107			      inc   HL                      ; Store want size into allocated block 
9107			      ld    (HL), C 
9107			      inc   HL 
9107			      ld    (HL), B 
9107			      inc   HL 
9107			      push  HL                      ; Address of allocation to return 
9107			 
9107			      jr    malloc_update_links 
9107			 
9107			malloc_alloc_fit: 
9107			      pop   HL                      ; Dont need new block size, want is exact fit 
9107			 
9107			      ; Modify this_free block to be allocation 
9107			      ex    DE, HL 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      xor   A                       ; Null the next block ptr of allocated block 
9107			      ld    (HL), A 
9107			      inc   HL 
9107			      ld    (HL), A 
9107			 
9107			      inc   HL                      ; Store address of allocation to return 
9107			      inc   HL 
9107			      inc   HL 
9107			      push  HL 
9107			 
9107			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9107			      ld    L, (IX+0)               ; next_free to HL 
9107			      ld    H, (IX+1) 
9107			 
9107			      ld    (IX+2), L               ; HL to this_free 
9107			      ld    (IX+3), H 
9107			 
9107			 
9107			malloc_update_links: 
9107			      ; Update prev_free ptr to point to this_free 
9107			      ld    L, (IX+4)               ; prev_free ptr to HL 
9107			      ld    H, (IX+5) 
9107			 
9107			      ld    E, (IX+2)               ; this_free ptr to DE 
9107			      ld    D, (IX+3) 
9107			 
9107			      ld    (HL), E                 ; this_free ptr into prev_free 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Clear the Z flag to indicate successful allocation 
9107			      ld    A, D 
9107			      or    E 
9107			 
9107			      pop   DE                      ; Address of allocation 
9107			 
9107			malloc_no_space: 
9107			      ld    HL, 6                   ; Clean up stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			 
9107			      ex    DE, HL                  ; Alloc addr into HL for return 
9107			 
9107			malloc_early_exit: 
9107			      pop   IX 
9107			      pop   DE 
9107			      pop   BC 
9107			 
9107			      ret 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     free                                                                    : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9107			;     returned by malloc, otherwise the behaviour is undefined.               : 
9107			;                                                                             : 
9107			;     Where possible, directly adjacent free blocks will be merged together   : 
9107			;     into larger blocks to help ensure that the heap does not become         : 
9107			;     excessively fragmented.                                                 : 
9107			;                                                                             : 
9107			;     free does not clear or set any other value into the freed space, and    : 
9107			;     therefore its contents may be visible through subsequent malloc's. The  : 
9107			;     caller should clear the freed space as required.                        : 
9107			;                                                                             : 
9107			;     This implementation of free uses the stack exclusively, and is          : 
9107			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9107			;     advisable to disable interrupts before calling free, and recommended    : 
9107			;     to avoid the use of free inside ISRs in general.                        : 
9107			;                                                                             : 
9107			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     HL  Pointer to address of first byte of allocation to be freed          : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     Nothing                                                                 : 
9107			;                                                                             : 
9107			; Stack frame                                                                 : 
9107			;       |             |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     BC      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     DE      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     IX      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |  prev_free  |                                                       : 
9107			;   +2  +-------------+                                                       : 
9107			;       |  next_free  |                                                       : 
9107			;   +0  +-------------+                                                       : 
9107			;       |             |                                                       : 
9107			;                                                                             : 
9107			;------------------------------------------------------------------------------ 
9107			free: 
9107			      push  BC 
9107			      push  DE 
9107			      push  IX 
9107			 
9107			      ld    A, H                    ; Exit if ptr is null 
9107			      or    L 
9107			      jp    Z, free_early_exit 
9107			 
9107			      ; Set up stack frame 
9107			      ex    DE, HL 
9107			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			      ld    IX, 0                   ; Use IX as a frame pointer 
9107			      add   IX, SP 
9107			 
9107			      ; The address in HL points to the start of the useable allocated space, 
9107			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9107			      ; address of the block itself. 
9107			      ex    DE, HL 
9107			      ld    DE, -4 
9107			      add   HL, DE 
9107			 
9107			      ; An allocated block must have a null next block pointer in it 
9107			      ld    A, (HL) 
9107			      inc   HL 
9107			      or    (HL) 
9107			      jp    NZ, free_done 
9107			 
9107			      dec   HL 
9107			 
9107			      ld    B, H                    ; Copy HL to BC 
9107			      ld    C, L 
9107			 
9107			      ; Loop through the free list to find the first block with an address 
9107			      ; higher than the block being freed 
9107			      ld    HL, free_list 
9107			 
9107			free_find_higher_block: 
9107			      ld    E, (HL)                 ; Load next ptr from free block 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      dec   HL 
9107			 
9107			      ld    (IX+0), E               ; Save ptr to next free block 
9107			      ld    (IX+1), D 
9107			      ld    (IX+2), L               ; Save ptr to prev free block 
9107			      ld    (IX+3), H 
9107			 
9107			      ld    A, B                    ; Check if DE is greater than BC 
9107			      cp    D                       ; Compare MSB first 
9107			      jr    Z, $+4                  ; MSB the same, compare LSB 
9107			      jr    NC, free_find_higher_block_skip 
9107			      ld    A, C 
9107			      cp    E                       ; Then compare LSB 
9107			      jr    C, free_found_higher_block 
9107			 
9107			free_find_higher_block_skip: 
9107			      ld    A, D                    ; Reached the end of the free list? 
9107			      or    E 
9107			      jp    Z, free_done 
9107			 
9107			      ex    DE, HL 
9107			 
9107			      jr    free_find_higher_block 
9107			 
9107			free_found_higher_block: 
9107			      ; Insert freed block between prev and next free blocks 
9107			      ld    (HL), C                 ; Point prev free block to freed block 
9107			      inc   HL 
9107			      ld    (HL), B 
9107			 
9107			      ld    H, B                    ; Point freed block at next free block 
9107			      ld    L, C 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Check if the freed block is adjacent to the next free block 
9107			      inc   HL                      ; Load size of freed block into HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ex    DE, HL 
9107			 
9107			      add   HL, BC                  ; Add addr of freed block and its size 
9107			 
9107			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9107			      ld    D, (IX+1) 
9107			 
9107			      or    A                       ; Clear the carry flag 
9107			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9107			      jr    NZ, free_check_adjacent_to_prev 
9107			 
9107			      ; Freed block is adjacent to next, merge into one bigger block 
9107			      ex    DE, HL                  ; Load next ptr from next block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  HL                      ; Save ptr to next block for later 
9107			 
9107			      ld    H, B                    ; Store ptr from next block into freed block 
9107			      ld    L, C 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   HL                      ; Restore ptr to next block 
9107			      inc   HL                      ; Load size of next block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  DE                      ; Save next block size for later 
9107			 
9107			      ld    H, B                    ; Load size of freed block into HL 
9107			      ld    L, C 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ex    DE, HL 
9107			 
9107			      pop   DE                      ; Restore size of next block 
9107			      add   HL, DE                  ; Add sizes of both blocks 
9107			      ex    DE, HL 
9107			 
9107			      ld    H, B                    ; Store new bigger size into freed block 
9107			      ld    L, C 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			free_check_adjacent_to_prev: 
9107			      ; Check if the freed block is adjacent to the prev free block 
9107			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9107			      ld    H, (IX+3) 
9107			 
9107			      inc   HL                      ; Size of prev free block into DE 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      add   HL, DE                  ; Add prev block addr and size 
9107			 
9107			      or    A                       ; Clear the carry flag 
9107			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9107			      jr    NZ, free_done 
9107			 
9107			      ; Freed block is adjacent to prev, merge into one bigger block 
9107			      ld    H, B                    ; Load next ptr from freed block into DE 
9107			      ld    L, C 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  HL                      ; Save freed block ptr for later 
9107			 
9107			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9107			      ld    H, (IX+3) 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   HL                      ; Restore freed block ptr 
9107			      inc   HL                      ; Load size of freed block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  DE                      ; Save freed block size for later 
9107			 
9107			      ld    L, (IX+2)               ; Load size of prev block into DE 
9107			      ld    H, (IX+3) 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      pop   HL                      ; Add sizes of both blocks 
9107			      add   HL, DE 
9107			      ex    DE, HL 
9107			 
9107			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9107			      ld    H, (IX+3) 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			free_done: 
9107			      ld    HL, 4                   ; Clean up stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			 
9107			free_early_exit: 
9107			      pop   IX 
9107			      pop   DE 
9107			      pop   BC 
9107			 
9107			      ret 
9107			 
9107			 
9107			;      .org 0x8000 
9107			; 
9107			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9107			 ;                 .dw   0 
9107			 
9107			endif 
9107			 
9107			 
9107			if MALLOC_4 
9107			 
9107			; My memory allocation code. Very very simple.... 
9107			; allocate space under 250 chars 
9107			 
9107			heap_init: 
9107				; init start of heap as zero 
9107				;  
9107			 
9107				ld hl, heap_start 
9107				ld a, 0 
9107				ld (hl), a      ; empty block 
9107				inc hl 
9107				ld a, 0 
9107				ld (hl), a      ; length of block 
9107				; write end of list 
9107				inc hl 
9107				ld a,(hl) 
9107				inc hl 
9107				ld a,(hl) 
9107				 
9107			 
9107				; init some malloc vars 
9107			 
9107				ld hl, 0 
9107				ld (free_list), hl       ; store last malloc location 
9107			 
9107				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9107				ld a, 0 
9107				ld (hl), a 
9107			 
9107			 
9107				ld hl, heap_start 
9107				;  
9107				  
9107				ret 
9107			 
9107			 
9107			;    free block marker 
9107			;    requested size  
9107			;    pointer to next block 
9107			;    .... 
9107			;    next block marker 
9107			 
9107			 
9107			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9107			; 
9107			 
9107			 
9107			malloc:  
9107				push de 
9107				push bc 
9107				push af 
9107			 
9107				; hl space required 
9107				 
9107				ld c, l    ; hold space   (TODO only a max of 255) 
9107			 
9107			;	inc c     ; TODO BUG need to fix memory leak on push str 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			 
9107			 
9107			 
9107				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9107			 
9107				ld a, (free_list+3) 
9107				cp 0 
9107				jr z, .contheap 
9107			 
9107				ld hl, (free_list)     ; get last alloc 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mrs" 
9107						CALLMONITOR 
9107					endif 
9107				jr .startalloc 
9107			 
9107			.contheap: 
9107				ld hl, heap_start 
9107			 
9107			.startalloc: 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mym" 
9107						CALLMONITOR 
9107					endif 
9107			.findblock: 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mmf" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107				ld a,(hl)  
9107				; if byte is zero then clear to use 
9107			 
9107				cp 0 
9107				jr z, .foundemptyblock 
9107			 
9107				; if byte is not clear 
9107				;     then byte is offset to next block 
9107			 
9107				inc hl 
9107				ld a, (hl) ; get size 
9107			.nextblock:	inc hl 
9107					ld e, (hl) 
9107					inc hl 
9107					ld d, (hl) 
9107					ex de, hl 
9107			;	inc hl  ; move past the store space 
9107			;	inc hl  ; move past zero index  
9107			 
9107				; TODO detect no more space 
9107			 
9107				push hl 
9107				ld de, heap_end 
9107				call cmp16 
9107				pop hl 
9107				jr nc, .nospace 
9107			 
9107				jr .findblock 
9107			 
9107			.nospace: ld hl, 0 
9107				jp .exit 
9107			 
9107			 
9107			.foundemptyblock:	 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mme" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			; TODO has block enough space if reusing??? 
9107			 
9107				;  
9107			 
9107			; see if this block has been previously used 
9107				inc hl 
9107				ld a, (hl) 
9107				dec hl 
9107				cp 0 
9107				jr z, .newblock 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "meR" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			; no reusing previously allocated block 
9107			 
9107			; is it smaller than previously used? 
9107				 
9107				inc hl    ; move to size 
9107				ld a, c 
9107				sub (hl)        ; we want c < (hl) 
9107				dec hl    ; move back to marker 
9107			        jr z, .findblock 
9107			 
9107				; update with the new size which should be lower 
9107			 
9107			        ;inc  hl   ; negate next move. move back to size  
9107			 
9107			.newblock: 
9107				; need to be at marker here 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "meN" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			 
9107				ld a, c 
9107			 
9107				ld (free_list+3), a	 ; flag resume from last malloc  
9107				ld (free_list), hl    ; save out last location 
9107			 
9107			 
9107				;inc a     ; space for length byte 
9107				ld (hl), a     ; save block in use marker 
9107			 
9107				inc hl   ; move to space marker 
9107				ld (hl), a    ; save new space 
9107			 
9107				inc hl   ; move to start of allocated area 
9107				 
9107			;	push hl     ; save where we are - 1  
9107			 
9107			;	inc hl  ; move past zero index  
9107				; skip space to set down new marker 
9107			 
9107				; provide some extra space for now 
9107			 
9107				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9107				inc a 
9107				inc a 
9107			 
9107				push hl   ; save where we are in the node block 
9107			 
9107				call addatohl 
9107			 
9107				; write linked list point 
9107			 
9107				pop de     ; get our node position 
9107				ex de, hl 
9107			 
9107				ld (hl), e 
9107				inc hl 
9107				ld (hl), d 
9107			 
9107				inc hl 
9107			 
9107				; now at start of allocated data so save pointer 
9107			 
9107				push hl 
9107			 
9107				; jump to position of next node and setup empty header in DE 
9107			 
9107				ex de, hl 
9107			 
9107			;	inc hl ; move past end of block 
9107			 
9107				ld a, 0 
9107				ld (hl), a   ; empty marker 
9107				inc hl 
9107				ld (hl), a   ; size 
9107				inc hl  
9107				ld (hl), a   ; ptr 
9107				inc hl 
9107				ld (hl), a   ; ptr 
9107			 
9107			 
9107				pop hl 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mmr" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			.exit: 
9107				pop af 
9107				pop bc 
9107				pop de  
9107				ret 
9107			 
9107			 
9107			 
9107			 
9107			free:  
9107				push hl 
9107				push af 
9107				; get address in hl 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "fre" 
9107						CALLMONITOR 
9107					endif 
9107				; data is at hl - move to block count 
9107				dec hl 
9107				dec hl    ; get past pointer 
9107				dec hl 
9107			 
9107				ld a, (hl)    ; need this for a validation check 
9107			 
9107				dec hl    ; move to block marker 
9107			 
9107				; now check that the block count and block marker are the same  
9107			        ; this checks that we are on a malloc node and not random memory 
9107			        ; OK a faint chance this could be a problem but rare - famous last words! 
9107			 
9107				ld c, a 
9107				ld a, (hl)    
9107			 
9107				cp c 
9107				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9107			 
9107				; yes good chance we are on a malloc node 
9107			 
9107				ld a, 0      
9107				ld (hl), a   ; mark as free 
9107			 
9107				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9107			 
9107			.freeignore:  
9107			 
9107				pop af 
9107				pop hl 
9107			 
9107				ret 
9107			 
9107			 
9107			 
9107			endif 
9107			 
9107			; eof 
# End of file firmware_memory.asm
9107			  
9107			; device C  
9107			if SOUND_ENABLE  
9107				include "firmware_sound.asm"  
9107			endif  
9107			  
9107			include "firmware_diags.asm"  
9107			; Hardware diags menu 
9107			 
9107			 
9107			config: 
9107			 
9107 3e 00			ld a, 0 
9109 21 37 91			ld hl, .configmn 
910c cd ab 88			call menu 
910f			 
910f fe 00			cp 0 
9111 c8				ret z 
9112			 
9112 fe 01			cp 1 
9114 cc e2 91			call z, .savetostore 
9117			 
9117 fe 02			cp 2 
9119 cc e0 91			call z, .selautoload 
911c fe 03			cp 3 
911e cc df 91			call z, .disautoload 
9121 fe 04			cp 4 
9123 cc e1 91			call z, .selbank 
9126 fe 06			cp 6 
9128 cc e3 91			call z, .debug_tog 
912b fe 07			cp 7 
912d cc 2b 93			call z, .bpsgo 
9130 fe 08			cp 8 
9132 cc 09 92			call z, hardware_diags 
9135			 
9135 18 d0			jr config 
9137			 
9137			.configmn: 
9137 49 91			dw .c3 
9139 65 91			dw .c2 
913b 7a 91			dw .c2a 
913d 90 91			dw .c2b 
913f a4 91			dw .c4 
9141 ad 91			dw .m4 
9143 c8 91			dw .m4b 
9145 d0 91			dw .c1 
9147 00 00			dw 0 
9149				 
9149			 
9149 .. 00		.c3: db "Add User Dictionary To File",0 
9165 .. 00		.c2: db "Select Autoload File",0 
917a .. 00		.c2a: db "Disable Autoload File", 0 
9190 .. 00		.c2b: db "Select Storage Bank",0 
91a4 .. 00		.c4: db "Settings",0 
91ad .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91c8 .. 00		.m4b:   db "Monitor",0 
91d0 .. 00		.c1: db "Hardware Diags",0 
91df			 
91df			 
91df			.disautoload: 
91df				if STORAGE_SE 
91df				ld a, $fe      ; bit 0 clear 
91df				ld (spi_device), a 
91df			 
91df				call storage_get_block_0 
91df			 
91df				ld a, 0 
91df				ld (store_page+STORE_0_AUTOFILE), a 
91df			 
91df					ld hl, 0 
91df					ld de, store_page 
91df				call storage_write_block	 ; save update 
91df				endif 
91df			 
91df			 
91df c9				ret 
91e0			 
91e0			 
91e0			 
91e0			; Select auto start 
91e0			 
91e0			.selautoload: 
91e0			 
91e0				 
91e0				if STORAGE_SE 
91e0			 
91e0					call config_dir 
91e0				        ld hl, scratch 
91e0					ld a, 0 
91e0					call menu 
91e0			 
91e0					cp 0 
91e0					ret z 
91e0			 
91e0					dec a 
91e0			 
91e0			 
91e0					; locate menu option 
91e0			 
91e0					ld hl, scratch 
91e0					call table_lookup 
91e0			 
91e0					if DEBUG_FORTH_WORDS 
91e0						DMARK "ALl" 
91e0						CALLMONITOR 
91e0					endif 
91e0					; with the pointer to the menu it, the byte following the zero term is the file id 
91e0			 
91e0					ld a, 0 
91e0					ld bc, 50   ; max of bytes to look at 
91e0					cpir  
91e0			 
91e0					if DEBUG_FORTH_WORDS 
91e0						DMARK "ALb" 
91e0						CALLMONITOR 
91e0					endif 
91e0					;inc hl 
91e0			 
91e0					ld a, (hl)   ; file id 
91e0					 
91e0				        ; save bank and file ids 
91e0			 
91e0					push af 
91e0			 
91e0			; TODO need to save to block 0 on bank 1	 
91e0			 
91e0					call storage_get_block_0 
91e0			 
91e0					if DEBUG_FORTH_WORDS 
91e0						DMARK "AL0" 
91e0						CALLMONITOR 
91e0					endif 
91e0					pop af 
91e0			 
91e0					ld (store_page+STORE_0_FILERUN),a 
91e0					 
91e0					; save bank id 
91e0			 
91e0					ld a,(spi_device) 
91e0					ld (store_page+STORE_0_BANKRUN),a 
91e0			 
91e0					; enable auto run of store file 
91e0			 
91e0					ld a, 1 
91e0					ld (store_page+STORE_0_AUTOFILE),a 
91e0			 
91e0					; save buffer 
91e0			 
91e0					ld hl, 0 
91e0					ld de, store_page 
91e0					if DEBUG_FORTH_WORDS 
91e0						DMARK "ALw" 
91e0						CALLMONITOR 
91e0					endif 
91e0				call storage_write_block	 ; save update 
91e0			  
91e0			 
91e0			 
91e0			 
91e0					ld hl, scratch 
91e0					call config_fdir 
91e0			 
91e0			 
91e0				endif 
91e0 c9				ret 
91e1			 
91e1			 
91e1			 
91e1			; Select storage bank 
91e1			 
91e1			.selbank: 
91e1			 
91e1				if STORAGE_SE 
91e1				endif 
91e1				 
91e1 c9				ret 
91e2			 
91e2			if STORAGE_SE 
91e2			 
91e2			.config_ldir:   
91e2				; Load storage bank labels into menu array 
91e2			 
91e2				 
91e2			 
91e2			 
91e2				ret 
91e2			 
91e2			 
91e2			endif 
91e2			 
91e2			 
91e2			; Save user words to storage 
91e2			 
91e2			.savetostore: 
91e2			 
91e2				if STORAGE_SE 
91e2			 
91e2					call config_dir 
91e2				        ld hl, scratch 
91e2					ld a, 0 
91e2					call menu 
91e2					 
91e2					ld hl, scratch 
91e2					call config_fdir 
91e2			 
91e2			 
91e2				endif 
91e2			 
91e2 c9				ret 
91e3			 
91e3			 
91e3			 
91e3			if STORAGE_SE 
91e3			 
91e3			config_fdir: 
91e3				; using the scratch dir go through and release the memory allocated for each string 
91e3				 
91e3				ld hl, scratch 
91e3			.cfdir:	ld e,(hl) 
91e3				inc hl 
91e3				ld d,(hl) 
91e3				inc hl 
91e3			 
91e3				ex de, hl 
91e3				call ishlzero 
91e3				ret z     ; return on null pointer 
91e3				call free 
91e3				ex de, hl 
91e3				jr .cfdir 
91e3			 
91e3			 
91e3				ret 
91e3			 
91e3			 
91e3			config_dir: 
91e3			 
91e3				; for the config menus that need to build a directory of storage call this routine 
91e3				; it will construct a menu in scratch to pass to menu 
91e3			 
91e3				; open storage device 
91e3			 
91e3				; execute DIR to build a list of files and their ids into scratch in menu format 
91e3				; once the menu has finished then will need to call config_fdir to release the strings 
91e3				 
91e3				; c = number items 
91e3			 
91e3				 
91e3				call storage_get_block_0 
91e3			 
91e3				ld hl, store_page     ; get current id count 
91e3				ld b, (hl) 
91e3				ld c, 0    ; count of files   
91e3			 
91e3			 
91e3				ld hl, scratch 
91e3				ld (store_tmp2), hl    ; location to poke strings 
91e3			 
91e3				; check for empty drive 
91e3			 
91e3				ld a, 0 
91e3				cp b 
91e3				jp z, .dirdone 
91e3			 
91e3				 
91e3					if DEBUG_FORTH_WORDS 
91e3						DMARK "Cdc" 
91e3						CALLMONITOR 
91e3					endif 
91e3			 
91e3			 
91e3			.diritem:	 
91e3				push bc 
91e3				; for each of the current ids do a search for them and if found push to stack 
91e3			 
91e3					ld hl, STORE_BLOCK_PHY 
91e3					ld d, 0		 ; look for extent 0 of block id as this contains file name 
91e3					ld e,b 
91e3			 
91e3					call storage_findnextid 
91e3			 
91e3			 
91e3					; if found hl will be non zero 
91e3			 
91e3					call ishlzero 
91e3					jr z, .dirnotfound 
91e3			 
91e3					; increase count 
91e3			 
91e3					pop bc	 
91e3					inc c 
91e3					push bc 
91e3					 
91e3			 
91e3					; get file header and push the file name 
91e3			 
91e3					ld de, store_page 
91e3					call storage_read_block 
91e3			 
91e3					; push file id to stack 
91e3				 
91e3					ld a, (store_page) 
91e3					ld h, 0 
91e3					ld l, a 
91e3			 
91e3					;call forth_push_numhl 
91e3					; TODO store id 
91e3			 
91e3					push hl 
91e3			 
91e3					; push extent count to stack  
91e3				 
91e3					ld hl, store_page+3 
91e3			 
91e3					; get file name length 
91e3			 
91e3					call strlenz   
91e3			 
91e3					inc hl   ; cover zero term 
91e3					inc hl  ; stick the id at the end of the area 
91e3			 
91e3					push hl 
91e3					pop bc    ; move length to bc 
91e3			 
91e3					call malloc 
91e3			 
91e3					; TODO save malloc area to scratch 
91e3			 
91e3					ex de, hl 
91e3					ld hl, (store_tmp2) 
91e3					ld (hl), e 
91e3					inc hl 
91e3					ld (hl), d 
91e3					inc hl 
91e3					ld (store_tmp2), hl 
91e3			 
91e3					 
91e3			 
91e3					;pop hl   ; get source 
91e3			;		ex de, hl    ; swap aronund	 
91e3			 
91e3					ld hl, store_page+3 
91e3					if DEBUG_FORTH_WORDS 
91e3						DMARK "CFd" 
91e3						CALLMONITOR 
91e3					endif 
91e3					ldir 
91e3			 
91e3					; de is past string, move back one and store id 
91e3					 
91e3					dec de 
91e3			 
91e3					; store file id 
91e3			 
91e3					pop hl 
91e3					ex de,hl 
91e3					ld (hl), e 
91e3			 
91e3					if DEBUG_FORTH_WORDS 
91e3						DMARK "Cdi" 
91e3						CALLMONITOR 
91e3					endif 
91e3					 
91e3			.dirnotfound: 
91e3					pop bc     
91e3					djnz .diritem 
91e3				 
91e3			.dirdone:	 
91e3			 
91e3					ld a, 0 
91e3					ld hl, (store_tmp2) 
91e3					ld (hl), a 
91e3					inc hl 
91e3					ld (hl), a 
91e3					inc hl 
91e3					; push a count of the dir items found 
91e3			 
91e3			;		ld h, 0 
91e3			;		ld l, c 
91e3			 
91e3				ret 
91e3			 
91e3			endif 
91e3			 
91e3			 
91e3			; Settings 
91e3			; Run  
91e3			 
91e3			 
91e3			 
91e3			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
91e3			;;hd_menu2:   db "        2: Editor",0   
91e3			;hd_menu2:   db "        2: Editor       6: Menu",0   
91e3			;hd_menu3:   db "        3: Storage",0 
91e3			;hd_menu4:   db "0=quit  4: Debug",0 
91e3			;hd_don:     db "ON",0 
91e3			;hd_doff:     db "OFF",0 
91e3			; 
91e3			; 
91e3			; 
91e3			;hardware_diags_old:       
91e3			; 
91e3			;.diagmenu: 
91e3			;	call clear_display 
91e3			;	ld a, display_row_1 
91e3			;	ld de, hd_menu1 
91e3			;	call str_at_display 
91e3			; 
91e3			;	ld a, display_row_2 
91e3			;	ld de, hd_menu2 
91e3			;	call str_at_display 
91e3			; 
91e3			;	ld a, display_row_3 
91e3			;	ld de, hd_menu3 
91e3			;	call str_at_display 
91e3			; 
91e3			;	ld a,  display_row_4 
91e3			;	ld de, hd_menu4 
91e3			;	call str_at_display 
91e3			; 
91e3			;	; display debug state 
91e3			; 
91e3			;	ld de, hd_don 
91e3			;	ld a, (os_view_disable) 
91e3			;	cp 0 
91e3			;	jr z, .distog 
91e3			;	ld de, hd_doff 
91e3			;.distog: ld a, display_row_4+17 
91e3			;	call str_at_display 
91e3			; 
91e3			;	call update_display 
91e3			; 
91e3			;	call cin_wait 
91e3			; 
91e3			; 
91e3			; 
91e3			;	cp '4' 
91e3			;	jr nz, .diagn1 
91e3			; 
91e3			;	; debug toggle 
91e3			; 
91e3			;	ld a, (os_view_disable) 
91e3			;	ld b, '*' 
91e3			;	cp 0 
91e3			;	jr z, .debtog 
91e3			;	ld b, 0 
91e3			;.debtog:	 
91e3			;	ld a,b 
91e3			;	ld (os_view_disable),a 
91e3			; 
91e3			;.diagn1: cp '0' 
91e3			;	 ret z 
91e3			; 
91e3			;;	cp '1' 
91e3			;;       jp z, matrix	 
91e3			;;   TODO keyboard matrix test 
91e3			; 
91e3			;	cp '2' 
91e3			;	jp z, .diagedit 
91e3			; 
91e3			;;	cp '6' 
91e3			;;	jp z, .menutest 
91e3			;;if ENABLE_BASIC 
91e3			;;	cp '6' 
91e3			;;	jp z, basic 
91e3			;;endif 
91e3			 ; 
91e3			;	jp .diagmenu 
91e3			; 
91e3			; 
91e3			;	ret 
91e3			 
91e3			 
91e3			.debug_tog: 
91e3 21 2a 92			ld hl, .menudebug 
91e6				 
91e6 3a d7 e4			ld a, (os_view_disable) 
91e9 fe 2a			cp '*' 
91eb 20 04			jr nz,.tdon  
91ed 3e 01			ld a, 1 
91ef 18 02			jr .tog1 
91f1 3e 00		.tdon: ld a, 0 
91f3			 
91f3			.tog1: 
91f3 cd ab 88			call menu 
91f6 fe 00			cp 0 
91f8 c8				ret z 
91f9 fe 01			cp 1    ; disable debug 
91fb 28 04			jr z, .dtog0 
91fd 3e 2a			ld a, '*' 
91ff 18 02			jr .dtogset 
9201 3e 00		.dtog0: ld a, 0 
9203 32 d7 e4		.dtogset:  ld (os_view_disable), a 
9206 c3 e3 91			jp .debug_tog 
9209			 
9209			 
9209			hardware_diags:       
9209			 
9209			.diagm: 
9209 21 1c 92			ld hl, .menuitems 
920c 3e 00			ld a, 0 
920e cd ab 88			call menu 
9211			 
9211 fe 00		         cp 0 
9213 c8				 ret z 
9214			 
9214 fe 02			cp 2 
9216 ca 75 92			jp z, .diagedit 
9219			 
9219			;	cp '6' 
9219			;	jp z, .menutest 
9219			;if ENABLE_BASIC 
9219			;	cp '6' 
9219			;	jp z, basic 
9219			;endif 
9219			  
9219 c3 09 92			jp .diagm 
921c			 
921c				 
921c 30 92		.menuitems:   	dw .m1 
921e 3b 92				dw .m2 
9220 42 92				dw .m3 
9222 4a 92				dw .m5 
9224 50 92				dw .m5a 
9226 59 92				dw .m5b 
9228 00 00				dw 0 
922a			 
922a			.menudebug: 
922a 62 92				dw .m6 
922c 6b 92				dw .m7 
922e 00 00				dw 0 
9230			 
9230 .. 00		.m1:   db "Key Matrix",0 
923b .. 00		.m2:   db "Editor",0 
9242 .. 00		.m3:   db "Storage",0 
924a .. 00		.m5:   db "Sound",0 
9250 .. 00		.m5a:  db "RAM Test",0 
9259 .. 00		.m5b:  db "LCD Test",0 
9262			 
9262 .. 00		.m6:   db "Debug ON",0 
926b .. 00		.m7:   db "Debug OFF",0 
9275			 
9275			; debug editor 
9275			 
9275			.diagedit: 
9275			 
9275 21 e6 e4			ld hl, scratch 
9278			;	ld bc, 250 
9278			;	ldir 
9278				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9278 3e 00			ld a, 0 
927a 77				ld (hl), a 
927b 23				inc hl 
927c 77				ld (hl), a 
927d 23				inc hl 
927e 77				ld (hl), a 
927f			 
927f cd 7a 88		        call clear_display 
9282 cd 9d 88			call update_display 
9285 3e 01			ld a, 1 
9287 32 c6 ee			ld (hardware_diag), a 
928a			.diloop: 
928a 3e 00			ld a, display_row_1 
928c 0e 00			ld c, 0 
928e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9290 1e 28			ld e, 40 
9292			 
9292 21 e6 e4			ld hl, scratch	 
9295 cd d4 8a			call input_str 
9298			 
9298 3e 14			ld a, display_row_2 
929a 11 e6 e4			ld de, scratch 
929d cd 8d 88			call str_at_display 
92a0 cd 9d 88			call update_display 
92a3			 
92a3 c3 8a 92			jp .diloop 
92a6			 
92a6			 
92a6			; pass word in hl 
92a6			; a has display location 
92a6			display_word_at: 
92a6 f5				push af 
92a7 e5				push hl 
92a8 7c				ld a,h 
92a9 21 eb e7			ld hl, os_word_scratch 
92ac cd a8 8d			call hexout 
92af e1				pop hl 
92b0 7d				ld a,l 
92b1 21 ed e7			ld hl, os_word_scratch+2 
92b4 cd a8 8d			call hexout 
92b7 21 ef e7			ld hl, os_word_scratch+4 
92ba 3e 00			ld a,0 
92bc 77				ld (hl),a 
92bd 11 eb e7			ld de,os_word_scratch 
92c0 f1				pop af 
92c1 cd 8d 88				call str_at_display 
92c4 c9				ret 
92c5			 
92c5			display_ptr_state: 
92c5			 
92c5				; to restore afterwards 
92c5			 
92c5 d5				push de 
92c6 c5				push bc 
92c7 e5				push hl 
92c8 f5				push af 
92c9			 
92c9				; for use in here 
92c9			 
92c9			;	push bc 
92c9			;	push de 
92c9			;	push hl 
92c9			;	push af 
92c9			 
92c9 cd 7a 88			call clear_display 
92cc			 
92cc 11 9f 94			ld de, .ptrstate 
92cf 3e 00			ld a, display_row_1 
92d1 cd 8d 88			call str_at_display 
92d4			 
92d4				; display debug step 
92d4			 
92d4			 
92d4 11 c0 ee			ld de, debug_mark 
92d7 3e 12			ld a, display_row_1+display_cols-2 
92d9 cd 8d 88			call str_at_display 
92dc			 
92dc				; display a 
92dc 11 a9 94			ld de, .ptrcliptr 
92df 3e 14			ld a, display_row_2 
92e1 cd 8d 88			call str_at_display 
92e4			 
92e4 f1				pop af 
92e5 2a b1 ec			ld hl,(cli_ptr) 
92e8 3e 1c			ld a, display_row_2+8 
92ea cd a6 92			call display_word_at 
92ed			 
92ed			 
92ed				; display hl 
92ed			 
92ed			 
92ed 11 b1 94			ld de, .ptrclioptr 
92f0 3e 1e			ld a, display_row_2+10 
92f2 cd 8d 88			call str_at_display 
92f5			; 
92f5			;	pop hl 
92f5 3e 21			ld a, display_row_2+13 
92f7 2a af ec			ld hl,(cli_origptr) 
92fa cd a6 92			call display_word_at 
92fd			; 
92fd			;	 
92fd			;	; display de 
92fd			 
92fd			;	ld de, .regstatede 
92fd			;	ld a, display_row_3 
92fd			;	call str_at_display 
92fd			 
92fd			;	pop de 
92fd			;	ld h,d 
92fd			;	ld l, e 
92fd			;	ld a, display_row_3+3 
92fd			;	call display_word_at 
92fd			 
92fd			 
92fd				; display bc 
92fd			 
92fd			;	ld de, .regstatebc 
92fd			;	ld a, display_row_3+10 
92fd			;	call str_at_display 
92fd			 
92fd			;	pop bc 
92fd			;	ld h,b 
92fd			;	ld l, c 
92fd			;	ld a, display_row_3+13 
92fd			;	call display_word_at 
92fd			 
92fd			 
92fd				; display dsp 
92fd			 
92fd			;	ld de, .regstatedsp 
92fd			;	ld a, display_row_4 
92fd			;	call str_at_display 
92fd			 
92fd				 
92fd			;	ld hl,(cli_data_sp) 
92fd			;	ld a, display_row_4+4 
92fd			;	call display_word_at 
92fd			 
92fd				; display rsp 
92fd			 
92fd 11 e0 94			ld de, .regstatersp 
9300 3e 46			ld a, display_row_4+10 
9302 cd 8d 88			call str_at_display 
9305			 
9305				 
9305 2a 97 ec			ld hl,(cli_ret_sp) 
9308 3e 4a			ld a, display_row_4+14 
930a cd a6 92			call display_word_at 
930d			 
930d cd 9d 88			call update_display 
9310			 
9310 cd fa 87			call delay1s 
9313 cd fa 87			call delay1s 
9316 cd fa 87			call delay1s 
9319			 
9319			 
9319 cd 26 98			call next_page_prompt 
931c			 
931c				; restore  
931c			 
931c f1				pop af 
931d e1				pop hl 
931e c1				pop bc 
931f d1				pop de 
9320 c9				ret 
9321			 
9321			break_point_state: 
9321 f5				push af 
9322			 
9322				; see if disabled 
9322			 
9322 3a d7 e4			ld a, (os_view_disable) 
9325 fe 2a			cp '*' 
9327 20 02			jr nz, .bpsgo 
9329 f1				pop af 
932a c9				ret 
932b			 
932b			.bpsgo: 
932b f1				pop af 
932c f5				push af 
932d 22 d3 e4			ld (os_view_hl), hl 
9330 ed 53 d1 e4		ld (os_view_de), de 
9334 ed 43 cf e4		ld (os_view_bc), bc 
9338 e5				push hl 
9339 6f				ld l, a 
933a 26 00			ld h, 0 
933c 22 d5 e4			ld (os_view_af),hl 
933f			 
933f 21 56 ee				ld hl, display_fb0 
9342 22 61 ed				ld (display_fb_active), hl 
9345 e1				pop hl	 
9346			 
9346 3e 31			ld a, '1' 
9348 fe 2a		.bps1:  cp '*' 
934a 20 03			jr nz, .bps1b 
934c 32 d7 e4			ld (os_view_disable),a 
934f fe 31		.bps1b:  cp '1' 
9351 20 14			jr nz, .bps2 
9353			 
9353				; display reg 
9353			 
9353				 
9353			 
9353 3a d5 e4			ld a, (os_view_af) 
9356 2a d3 e4			ld hl, (os_view_hl) 
9359 ed 5b d1 e4		ld de, (os_view_de) 
935d ed 4b cf e4		ld bc, (os_view_bc) 
9361 cd fb 93			call display_reg_state 
9364 c3 e7 93			jp .bpschk 
9367			 
9367 fe 32		.bps2:  cp '2' 
9369 20 08			jr nz, .bps3 
936b				 
936b				; display hl 
936b 2a d3 e4			ld hl, (os_view_hl) 
936e cd e5 94			call display_dump_at_hl 
9371			 
9371 18 74			jr .bpschk 
9373			 
9373 fe 33		.bps3:  cp '3' 
9375 20 08			jr nz, .bps4 
9377			 
9377			        ; display de 
9377 2a d1 e4			ld hl, (os_view_de) 
937a cd e5 94			call display_dump_at_hl 
937d			 
937d 18 68			jr .bpschk 
937f fe 34		.bps4:  cp '4' 
9381 20 08			jr nz, .bps5 
9383			 
9383			        ; display bc 
9383 2a cf e4			ld hl, (os_view_bc) 
9386 cd e5 94			call display_dump_at_hl 
9389			 
9389 18 5c			jr .bpschk 
938b fe 35		.bps5:  cp '5' 
938d 20 08		        jr nz, .bps7 
938f			 
938f				; display cur ptr 
938f 2a b1 ec			ld hl, (cli_ptr) 
9392 cd e5 94			call display_dump_at_hl 
9395			 
9395 18 50			jr .bpschk 
9397 fe 36		.bps7:  cp '6' 
9399 20 08			jr nz, .bps8b 
939b				 
939b				; display cur orig ptr 
939b 2a af ec			ld hl, (cli_origptr) 
939e cd e5 94			call display_dump_at_hl 
93a1 18 44			jr .bpschk 
93a3 fe 37		.bps8b:  cp '7' 
93a5 20 08			jr nz, .bps9 
93a7				 
93a7				; display dsp 
93a7 2a 93 ec			ld hl, (cli_data_sp) 
93aa cd e5 94			call display_dump_at_hl 
93ad			 
93ad 18 38			jr .bpschk 
93af fe 39		.bps9:  cp '9' 
93b1 20 05			jr nz, .bps8c 
93b3				 
93b3				; display SP 
93b3			;	ld hl, sp 
93b3 cd e5 94			call display_dump_at_hl 
93b6			 
93b6 18 2f			jr .bpschk 
93b8 fe 38		.bps8c:  cp '8' 
93ba 20 08			jr nz, .bps8d 
93bc				 
93bc				; display rsp 
93bc 2a 97 ec			ld hl, (cli_ret_sp) 
93bf cd e5 94			call display_dump_at_hl 
93c2			 
93c2 18 23			jr .bpschk 
93c4 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93c6 20 05			jr nz, .bps8 
93c8 cd 1c 96			call monitor 
93cb			 
93cb 18 1a			jr .bpschk 
93cd fe 30		.bps8:  cp '0' 
93cf 20 16			jr nz, .bpschk 
93d1			 
93d1 21 05 ee				ld hl, display_fb1 
93d4 22 61 ed				ld (display_fb_active), hl 
93d7 cd 9d 88				call update_display 
93da			 
93da				;ld a, (os_view_af) 
93da 2a d3 e4			ld hl, (os_view_hl) 
93dd ed 5b d1 e4		ld de, (os_view_de) 
93e1 ed 4b cf e4		ld bc, (os_view_bc) 
93e5 f1				pop af 
93e6 c9				ret 
93e7			 
93e7			.bpschk:   
93e7 cd fa 87			call delay1s 
93ea 3e 4f		ld a,display_row_4 + display_cols - 1 
93ec 11 24 98		        ld de, endprg 
93ef cd 8d 88			call str_at_display 
93f2 cd 9d 88			call update_display 
93f5 cd 1e d7			call cin_wait 
93f8			 
93f8 c3 48 93			jp .bps1 
93fb			 
93fb			 
93fb			display_reg_state: 
93fb			 
93fb				; to restore afterwards 
93fb			 
93fb d5				push de 
93fc c5				push bc 
93fd e5				push hl 
93fe f5				push af 
93ff			 
93ff				; for use in here 
93ff			 
93ff c5				push bc 
9400 d5				push de 
9401 e5				push hl 
9402 f5				push af 
9403			 
9403 cd 7a 88			call clear_display 
9406			 
9406 11 bb 94			ld de, .regstate 
9409 3e 00			ld a, display_row_1 
940b cd 8d 88			call str_at_display 
940e			 
940e				; display debug step 
940e			 
940e			 
940e 11 c0 ee			ld de, debug_mark 
9411 3e 11			ld a, display_row_1+display_cols-3 
9413 cd 8d 88			call str_at_display 
9416			 
9416				; display a 
9416 11 d7 94			ld de, .regstatea 
9419 3e 14			ld a, display_row_2 
941b cd 8d 88			call str_at_display 
941e			 
941e e1				pop hl 
941f			;	ld h,0 
941f			;	ld l, a 
941f 3e 17			ld a, display_row_2+3 
9421 cd a6 92			call display_word_at 
9424			 
9424			 
9424				; display hl 
9424			 
9424			 
9424 11 cb 94			ld de, .regstatehl 
9427 3e 1e			ld a, display_row_2+10 
9429 cd 8d 88			call str_at_display 
942c			 
942c e1				pop hl 
942d 3e 21			ld a, display_row_2+13 
942f cd a6 92			call display_word_at 
9432			 
9432				 
9432				; display de 
9432			 
9432 11 cf 94			ld de, .regstatede 
9435 3e 28			ld a, display_row_3 
9437 cd 8d 88			call str_at_display 
943a			 
943a e1				pop hl 
943b			;	ld h,d 
943b			;	ld l, e 
943b 3e 2b			ld a, display_row_3+3 
943d cd a6 92			call display_word_at 
9440			 
9440			 
9440				; display bc 
9440			 
9440 11 d3 94			ld de, .regstatebc 
9443 3e 32			ld a, display_row_3+10 
9445 cd 8d 88			call str_at_display 
9448			 
9448 e1				pop hl 
9449			;	ld h,b 
9449			;	ld l, c 
9449 3e 35			ld a, display_row_3+13 
944b cd a6 92			call display_word_at 
944e			 
944e			 
944e				; display dsp 
944e			 
944e 11 db 94			ld de, .regstatedsp 
9451 3e 3c			ld a, display_row_4 
9453 cd 8d 88			call str_at_display 
9456			 
9456				 
9456 2a 93 ec			ld hl,(cli_data_sp) 
9459 3e 40			ld a, display_row_4+4 
945b cd a6 92			call display_word_at 
945e			 
945e				; display rsp 
945e			 
945e 11 e0 94			ld de, .regstatersp 
9461 3e 46			ld a, display_row_4+10 
9463 cd 8d 88			call str_at_display 
9466			 
9466				 
9466 2a 97 ec			ld hl,(cli_ret_sp) 
9469 3e 4a			ld a, display_row_4+14 
946b cd a6 92			call display_word_at 
946e			 
946e cd 9d 88			call update_display 
9471			 
9471			;	call delay1s 
9471			;	call delay1s 
9471			;	call delay1s 
9471			 
9471			 
9471			;	call next_page_prompt 
9471			 
9471				; restore  
9471			 
9471 f1				pop af 
9472 e1				pop hl 
9473 c1				pop bc 
9474 d1				pop de 
9475 c9				ret 
9476			 
9476 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
948a .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
949f .. 00		.ptrstate:	db "Ptr State",0 
94a9 .. 00		.ptrcliptr:     db "cli_ptr",0 
94b1 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94bb .. 00		.regstate:	db "Reg State (1/0)",0 
94cb .. 00		.regstatehl:	db "HL:",0 
94cf .. 00		.regstatede:	db "DE:",0 
94d3 .. 00		.regstatebc:	db "BC:",0 
94d7 .. 00		.regstatea:	db "A :",0 
94db .. 00		.regstatedsp:	db "DSP:",0 
94e0 .. 00		.regstatersp:	db "RSP:",0 
94e5			 
94e5			display_dump_at_hl: 
94e5 e5				push hl 
94e6 d5				push de 
94e7 c5				push bc 
94e8 f5				push af 
94e9			 
94e9 22 09 e8			ld (os_cur_ptr),hl	 
94ec cd 7a 88			call clear_display 
94ef cd 2e 97			call dumpcont 
94f2			;	call delay1s 
94f2			;	call next_page_prompt 
94f2			 
94f2			 
94f2 f1				pop af 
94f3 c1				pop bc 
94f4 d1				pop de 
94f5 e1				pop hl 
94f6 c9				ret 
94f7			 
94f7			;if ENABLE_BASIC 
94f7			;	include "nascombasic.asm" 
94f7			;	basic: 
94f7			;	include "forth/FORTH.ASM" 
94f7			;endif 
94f7			 
94f7			; eof 
94f7			 
94f7			 
# End of file firmware_diags.asm
94f7			  
94f7			  
94f7			  
94f7			  
94f7			; eof  
94f7			  
# End of file firmware.asm
94f7			 
94f7			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
94f7			;if BASE_KEV  
94f7			;baseram: equ 08000h 
94f7			;endif 
94f7			 
94f7			;if BASE_SC114 
94f7			;baseram:     equ    endofcode 
94f7			;endif 
94f7			 
94f7			 
94f7			; start system 
94f7			 
94f7			coldstart: 
94f7				; set sp 
94f7				; di/ei 
94f7			 
94f7 f3				di 
94f8 31 00 f0			ld sp, tos 
94fb			;	ei 
94fb			 
94fb			 
94fb				; disable breakpoint by default 
94fb			 
94fb 3e 2a			ld a,'*' 
94fd 32 d7 e4			ld (os_view_disable),a 
9500			 
9500				; init hardware 
9500			 
9500				; init keyboard and screen hardware 
9500			 
9500 cd 03 80			call hardware_init 
9503			 
9503			 
9503				; detect if any keys are held down to enable breakpoints at start up 
9503			 
9503 cd 24 d7			call cin  
9506 fe 00			cp 0 
9508 28 03			jr z, .nokeys 
950a			 
950a				;call hardware_diags 
950a cd 07 91			call config 
950d			 
950d			;	ld de, .bpen 
950d			;	ld a, display_row_4 
950d			;	call str_at_display 
950d			;	call update_display 
950d			; 
950d			;	ld a,0 
950d			;	ld (os_view_disable),a 
950d			; 
950d			;.bpwait: 
950d			;	call cin 
950d			;	cp 0 
950d			;	jr z, .bpwait 
950d			;	jr .nokeys 
950d			; 
950d			; 
950d			;.bpen:  db "Break points enabled!",0 
950d			 
950d			 
950d			 
950d			 
950d			 
950d			 
950d			.nokeys: 
950d			 
950d			 
950d				 
950d			 
950d			;jp  testkey 
950d			 
950d			;call storage_get_block_0 
950d			; 
950d			;ld hl, 0 
950d			;ld de, store_page 
950d			;call storage_read_block 
950d			 
950d				 
950d			;ld hl, 10 
950d			;ld de, store_page 
950d			;call storage_read_block 
950d			 
950d			 
950d			 
950d			 
950d			 
950d			;stop:	nop 
950d			;	jp stop 
950d			 
950d			 
950d			 
950d			main: 
950d cd 7a 88			call clear_display 
9510 cd 9d 88			call update_display 
9513			 
9513			 
9513			 
9513			;	call testlcd 
9513			 
9513			 
9513			 
9513 cd ec 9b			call forth_init 
9516			 
9516			 
9516			warmstart: 
9516 cd c2 9b			call forth_warmstart 
9519			 
9519				; run startup word load 
9519			        ; TODO prevent this running at warmstart after crash  
9519			 
9519				if STARTUP_ENABLE 
9519					if STORAGE_SE 
9519						call forth_autoload 
9519					endif 
9519 cd b8 d3				call forth_startup 
951c			 
951c			 
951c				endif 
951c			 
951c				; show free memory after boot 
951c 11 b6 95			ld de, freeram 
951f 3e 00			ld a, display_row_1 
9521 cd 8d 88			call str_at_display 
9524			 
9524			; Or use heap_size word???? 
9524 21 cc e4			ld hl, heap_end 
9527 11 42 d7			ld de, heap_start 
952a ed 52			sbc hl, de 
952c e5				push hl 
952d 7c				ld a,h	         	 
952e 21 eb e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9531 cd a8 8d			call hexout 
9534 e1			   	pop hl 
9535			 
9535 7d				ld a,l 
9536 21 ed e7			ld hl, os_word_scratch+2 
9539 cd a8 8d			call hexout 
953c 21 ef e7			ld hl, os_word_scratch+4 
953f 3e 00			ld a, 0 
9541 77				ld (hl),a 
9542 11 eb e7			ld de, os_word_scratch 
9545 3e 0d			ld a, display_row_1 + 13 
9547 cd 8d 88			call str_at_display 
954a cd 9d 88			call update_display 
954d			 
954d			 
954d				;call demo 
954d			 
954d			 
954d				; init scratch input area for cli commands 
954d			 
954d 21 0d e8			ld hl, os_cli_cmd 
9550 3e 00			ld a,0 
9552 77				ld (hl),a 
9553 23				inc hl 
9554 77				ld (hl),a 
9555			 
9555 3e 00			ld a,0 
9557 32 0c e9			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
955a			 
955a 32 09 e8			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
955d 32 0a e8			ld (os_cur_ptr+1),a	 
9560			 
9560 32 eb e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9563 32 ec e7			ld (os_word_scratch+1),a	 
9566				 
9566			 
9566				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9566 21 0d e8			ld hl, os_cli_cmd 
9569			 
9569 3e 00			ld a, 0		 ; init cli input 
956b 77				ld (hl), a 
956c 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
956e			cli: 
956e				; show cli prompt 
956e				;push af 
956e				;ld a, 0 
956e				;ld de, prompt 
956e				;call str_at_display 
956e			 
956e				;call update_display 
956e				;pop af 
956e				;inc a 
956e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
956e 0e 00			ld c, 0 
9570 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9572 1e 28			ld e, 40 
9574			 
9574 21 0d e8			ld hl, os_cli_cmd 
9577			 
9577				STACKFRAME OFF $fefe $9f9f 
9577				if DEBUG_STACK_IMB 
9577					if OFF 
9577						exx 
9577						ld de, $fefe 
9577						ld a, d 
9577						ld hl, curframe 
9577						call hexout 
9577						ld a, e 
9577						ld hl, curframe+2 
9577						call hexout 
9577						ld hl, $fefe 
9577						push hl 
9577						ld hl, $9f9f 
9577						push hl 
9577						exx 
9577					endif 
9577				endif 
9577			endm 
# End of macro STACKFRAME
9577			 
9577 cd d4 8a			call input_str 
957a			 
957a				STACKFRAMECHK OFF $fefe $9f9f 
957a				if DEBUG_STACK_IMB 
957a					if OFF 
957a						exx 
957a						ld hl, $9f9f 
957a						pop de   ; $9f9f 
957a						call cmp16 
957a						jr nz, .spnosame 
957a						ld hl, $fefe 
957a						pop de   ; $fefe 
957a						call cmp16 
957a						jr z, .spfrsame 
957a						.spnosame: call showsperror 
957a						.spfrsame: nop 
957a						exx 
957a					endif 
957a				endif 
957a			endm 
# End of macro STACKFRAMECHK
957a			 
957a				; copy input to last command 
957a			 
957a 21 0d e8			ld hl, os_cli_cmd 
957d 11 0c e9			ld de, os_last_cmd 
9580 01 ff 00			ld bc, 255 
9583 ed b0			ldir 
9585			 
9585				; wipe current buffer 
9585			 
9585			;	ld a, 0 
9585			;	ld hl, os_cli_cmd 
9585			;	ld de, os_cli_cmd+1 
9585			;	ld bc, 254 
9585			;	ldir 
9585				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9585			;	call strcpy 
9585			;	ld a, 0 
9585			;	ld (hl), a 
9585			;	inc hl 
9585			;	ld (hl), a 
9585			;	inc hl 
9585			;	ld (hl), a 
9585			 
9585				; switch frame buffer to program  
9585			 
9585 21 05 ee				ld hl, display_fb1 
9588 22 61 ed				ld (display_fb_active), hl 
958b			 
958b			;	nop 
958b				STACKFRAME ON $fbfe $8f9f 
958b				if DEBUG_STACK_IMB 
958b					if ON 
958b						exx 
958b						ld de, $fbfe 
958b						ld a, d 
958b						ld hl, curframe 
958b						call hexout 
958b						ld a, e 
958b						ld hl, curframe+2 
958b						call hexout 
958b						ld hl, $fbfe 
958b						push hl 
958b						ld hl, $8f9f 
958b						push hl 
958b						exx 
958b					endif 
958b				endif 
958b			endm 
# End of macro STACKFRAME
958b				; first time into the parser so pass over the current scratch pad 
958b 21 0d e8			ld hl,os_cli_cmd 
958e				; tokenise the entered statement(s) in HL 
958e cd 65 9c			call forthparse 
9591			        ; exec forth statements in top of return stack 
9591 cd a5 9c			call forthexec 
9594				;call forthexec_cleanup 
9594			;	call parsenext 
9594			 
9594				STACKFRAMECHK ON $fbfe $8f9f 
9594				if DEBUG_STACK_IMB 
9594					if ON 
9594						exx 
9594						ld hl, $8f9f 
9594						pop de   ; $8f9f 
9594						call cmp16 
9594						jr nz, .spnosame 
9594						ld hl, $fbfe 
9594						pop de   ; $fbfe 
9594						call cmp16 
9594						jr z, .spfrsame 
9594						.spnosame: call showsperror 
9594						.spfrsame: nop 
9594						exx 
9594					endif 
9594				endif 
9594			endm 
# End of macro STACKFRAMECHK
9594				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9594			 
9594 3e 3c			ld a, display_row_4 
9596 11 c8 95			ld de, endprog 
9599			 
9599 cd 9d 88			call update_display		 
959c			 
959c cd 26 98			call next_page_prompt 
959f			 
959f				; switch frame buffer to cli 
959f			 
959f 21 56 ee				ld hl, display_fb0 
95a2 22 61 ed				ld (display_fb_active), hl 
95a5			 
95a5			 
95a5 cd 7a 88		        call clear_display 
95a8 cd 9d 88			call update_display		 
95ab			 
95ab 21 0d e8			ld hl, os_cli_cmd 
95ae			 
95ae 3e 00			ld a, 0		 ; init cli input 
95b0 77				ld (hl), a 
95b1			 
95b1				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
95b1			 
95b1				; now on last line 
95b1			 
95b1				; TODO scroll screen up 
95b1			 
95b1				; TODO instead just clear screen and place at top of screen 
95b1			 
95b1			;	ld a, 0 
95b1			;	ld (f_cursor_ptr),a 
95b1			 
95b1				;call clear_display 
95b1				;call update_display 
95b1			 
95b1				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95b1 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95b3 c3 6e 95			jp cli 
95b6			 
95b6 .. 00		freeram: db "Free bytes: $",0 
95c4 ..			asc: db "1A2F" 
95c8 .. 00		endprog: db "End prog...",0 
95d4			 
95d4			testenter2:   
95d4 21 18 e5			ld hl,scratch+50 
95d7 22 09 e8			ld (os_cur_ptr),hl 
95da c3 6e 95			jp cli 
95dd			 
95dd			testenter:  
95dd			 
95dd 21 c4 95			ld hl,asc 
95e0			;	ld a,(hl) 
95e0			;	call nibble2val 
95e0 cd fe 8d			call get_byte 
95e3			 
95e3			 
95e3			;	ld a,(hl) 
95e3			;	call atohex 
95e3			 
95e3			;	call fourehexhl 
95e3 32 18 e5			ld (scratch+50),a 
95e6			 
95e6			 
95e6			 
95e6 21 c6 95			ld hl,asc+2 
95e9			;	ld a, (hl) 
95e9			;	call nibble2val 
95e9 cd fe 8d			call get_byte 
95ec			 
95ec			;	call fourehexhl 
95ec 32 1a e5			ld (scratch+52),a 
95ef				 
95ef 21 18 e5			ld hl,scratch+50 
95f2 22 09 e8			ld (os_cur_ptr),hl 
95f5 c3 6e 95			jp cli 
95f8			 
95f8			enter:	 
95f8 3a ea e4			ld a,(scratch+4) 
95fb fe 00			cp 0 
95fd 28 0c			jr z, .entercont 
95ff				; no, not a null term line so has an address to work out.... 
95ff			 
95ff 21 e8 e4			ld hl,scratch+2 
9602 cd 5e 8e			call get_word_hl 
9605			 
9605 22 09 e8			ld (os_cur_ptr),hl	 
9608 c3 6e 95			jp cli 
960b			 
960b			 
960b			.entercont:  
960b			 
960b 21 e8 e4			ld hl, scratch+2 
960e cd fe 8d			call get_byte 
9611			 
9611 2a 09 e8		   	ld hl,(os_cur_ptr) 
9614 77					ld (hl),a 
9615 23					inc hl 
9616 22 09 e8				ld (os_cur_ptr),hl 
9619				 
9619			; get byte  
9619			 
9619			 
9619 c3 6e 95			jp cli 
961c			 
961c			 
961c			; basic monitor support 
961c			 
961c			monitor: 
961c				;  
961c cd 7a 88			call clear_display 
961f 3e 00			ld a, 0 
9621 11 69 96			ld de, .monprompt 
9624 cd 8d 88			call str_at_display 
9627 cd 9d 88			call update_display 
962a			 
962a				; get a monitor command 
962a			 
962a 0e 00			ld c, 0     ; entry at top left 
962c 16 64			ld d, 100   ; max buffer size 
962e 1e 0f			ld e, 15    ; input scroll area 
9630 3e 00			ld a, 0     ; init string 
9632 21 e4 e6			ld hl, os_input 
9635 77				ld (hl), a 
9636 23				inc hl 
9637 77				ld (hl), a 
9638 21 e4 e6			ld hl, os_input 
963b 3e 01			ld a, 1     ; init string 
963d cd d4 8a			call input_str 
9640			 
9640 cd 7a 88		        call clear_display 
9643 cd 9d 88			call update_display		 
9646			 
9646 3a e4 e6			ld a, (os_input) 
9649 cd fc 8e			call toUpper 
964c fe 48		        cp 'H' 
964e 28 6f		        jr z, .monhelp 
9650 fe 44			cp 'D'		; dump 
9652 ca e0 96			jp z, .mondump	 
9655 fe 43			cp 'C'		; dump 
9657 ca fa 96			jp z, .moncdump	 
965a fe 4d			cp 'M'		; dump 
965c ca 6b 96			jp z, .moneditstart 
965f fe 55			cp 'U'		; dump 
9661 28 14			jr z, .monedit	 
9663 fe 51			cp 'Q'		; dump 
9665 c8				ret z	 
9666			 
9666			 
9666				; TODO "S" to access symbol by name and not need the address 
9666				; TODO "F" to find a string in memory 
9666			 
9666 c3 1c 96			jp monitor 
9669			 
9669 .. 00		.monprompt: db ">", 0 
966b			 
966b			.moneditstart: 
966b				; get starting address 
966b			 
966b 21 e6 e6			ld hl,os_input+2 
966e cd 5e 8e			call get_word_hl 
9671			 
9671 22 09 e8			ld (os_cur_ptr),hl	 
9674			 
9674 c3 1c 96			jp monitor 
9677			 
9677			.monedit: 
9677				; get byte to load 
9677			 
9677 21 e6 e6			ld hl,os_input+2 
967a cd fe 8d			call get_byte 
967d			 
967d				; get address to update 
967d 2a 09 e8			ld hl, (os_cur_ptr) 
9680			 
9680				; update byte 
9680			 
9680 77				ld (hl), a 
9681			 
9681				; move to next address and save it 
9681			 
9681 23				inc hl 
9682 22 09 e8			ld (os_cur_ptr),hl	 
9685			 
9685 c3 1c 96			jp monitor 
9688			 
9688			 
9688 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
969c .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
96b8 .. 00		.monhelptext3:  db "Q-Quit",0 
96bf			        
96bf			.monhelp: 
96bf 3e 00			ld a, display_row_1 
96c1 11 88 96		        ld de, .monhelptext1 
96c4			 
96c4 cd 8d 88			call str_at_display 
96c7 3e 14			ld a, display_row_2 
96c9 11 9c 96		        ld de, .monhelptext2 
96cc					 
96cc cd 8d 88			call str_at_display 
96cf 3e 28			ld a, display_row_3 
96d1 11 b8 96		        ld de, .monhelptext3 
96d4					 
96d4 cd 8d 88			call str_at_display 
96d7 cd 9d 88			call update_display		 
96da			 
96da cd 26 98			call next_page_prompt 
96dd c3 1c 96			jp monitor 
96e0			 
96e0			.mondump:    
96e0 21 e6 e6			ld hl,os_input+2 
96e3 cd 5e 8e			call get_word_hl 
96e6			 
96e6 22 09 e8			ld (os_cur_ptr),hl	 
96e9 cd 2e 97			call dumpcont 
96ec 3e 3c			ld a, display_row_4 
96ee 11 c8 95			ld de, endprog 
96f1			 
96f1 cd 9d 88			call update_display		 
96f4			 
96f4 cd 26 98			call next_page_prompt 
96f7 c3 1c 96			jp monitor 
96fa			.moncdump: 
96fa cd 2e 97			call dumpcont 
96fd 3e 3c			ld a, display_row_4 
96ff 11 c8 95			ld de, endprog 
9702			 
9702 cd 9d 88			call update_display		 
9705			 
9705 cd 26 98			call next_page_prompt 
9708 c3 1c 96			jp monitor 
970b			 
970b			 
970b			; TODO symbol access  
970b			 
970b			.symbols:     ;; A list of symbols that can be called up  
970b 56 ee			dw display_fb0 
970d .. 00			db "fb0",0  
9711 eb ec		     	dw store_page 
9713 .. 00			db "store_page",0 
971e			 
971e			 
971e			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
971e			 
971e 3a e7 e4			ld a,(scratch+1) 
9721 fe 00			cp 0 
9723 28 09			jr z, dumpcont 
9725			 
9725				; no, not a null term line so has an address to work out.... 
9725			 
9725 21 e8 e4			ld hl,scratch+2 
9728 cd 5e 8e			call get_word_hl 
972b			 
972b 22 09 e8			ld (os_cur_ptr),hl	 
972e			 
972e			 
972e			 
972e			dumpcont: 
972e			 
972e				; dump bytes at ptr 
972e			 
972e			 
972e 3e 00			ld a, display_row_1 
9730 2a 61 ed			ld hl, (display_fb_active) 
9733 cd a7 8a			call addatohl 
9736 cd 5e 97			call .dumpbyterow 
9739			 
9739 3e 14			ld a, display_row_2 
973b 2a 61 ed			ld hl, (display_fb_active) 
973e cd a7 8a			call addatohl 
9741 cd 5e 97			call .dumpbyterow 
9744			 
9744			 
9744 3e 28			ld a, display_row_3 
9746 2a 61 ed			ld hl, (display_fb_active) 
9749 cd a7 8a			call addatohl 
974c cd 5e 97			call .dumpbyterow 
974f			 
974f 3e 3c			ld a, display_row_4 
9751 2a 61 ed			ld hl, (display_fb_active) 
9754 cd a7 8a			call addatohl 
9757 cd 5e 97			call .dumpbyterow 
975a			 
975a cd 9d 88			call update_display 
975d			;		jp cli 
975d c9				ret 
975e			 
975e			.dumpbyterow: 
975e			 
975e				;push af 
975e			 
975e e5				push hl 
975f			 
975f				; calc where to poke the ascii 
975f			if display_cols == 20 
975f 3e 10			ld a, 16 
9761			else 
9761				ld a, 31 
9761			endif 
9761			 
9761 cd a7 8a			call addatohl 
9764 22 eb e7			ld (os_word_scratch),hl  		; save pos for later 
9767			 
9767			 
9767			; display decoding address 
9767 2a 09 e8		   	ld hl,(os_cur_ptr) 
976a			 
976a 7c				ld a,h 
976b e1				pop hl 
976c e5				push hl 
976d			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
976d cd a8 8d			call hexout 
9770 2a 09 e8		   	ld hl,(os_cur_ptr) 
9773			 
9773 7d				ld a,l 
9774 e1				pop hl 
9775 23				inc hl 
9776 23				inc hl 
9777 e5				push hl 
9778			;	ld hl, os_word_scratch+2 
9778 cd a8 8d			call hexout 
977b e1				pop hl 
977c 23				inc hl 
977d 23				inc hl 
977e				;ld hl, os_word_scratch+4 
977e 3e 3a			ld a, ':' 
9780 77				ld (hl),a 
9781 23				inc hl 
9782				;ld a, 0 
9782				;ld (hl),a 
9782				;ld de, os_word_scratch 
9782				;pop af 
9782				;push af 
9782			;		ld a, display_row_2 
9782			;		call str_at_display 
9782			;		call update_display 
9782			 
9782			 
9782			;pop af 
9782			;	add 5 
9782			 
9782			if display_cols == 20 
9782 06 04			ld b, 4 
9784			else 
9784				ld b, 8 
9784			endif	 
9784			 
9784			.dumpbyte: 
9784 c5				push bc 
9785 e5				push hl 
9786			 
9786			 
9786 2a 09 e8		   	ld hl,(os_cur_ptr) 
9789 7e					ld a,(hl) 
978a			 
978a					; poke the ascii to display 
978a 2a eb e7				ld hl,(os_word_scratch) 
978d 77					ld (hl),a 
978e 23					inc hl 
978f 22 eb e7				ld (os_word_scratch),hl 
9792			 
9792					 
9792			 
9792			 
9792 e1					pop hl 
9793 e5					push hl 
9794			 
9794 cd a8 8d				call hexout 
9797			 
9797					 
9797 2a 09 e8		   	ld hl,(os_cur_ptr) 
979a 23				inc hl 
979b 22 09 e8		   	ld (os_cur_ptr),hl 
979e			 
979e e1					pop hl 
979f 23					inc hl 
97a0 23					inc hl 
97a1 23					inc hl 
97a2			 
97a2			 
97a2			 
97a2					;ld a,0 
97a2					;ld (os_word_scratch+2),a 
97a2					;pop af 
97a2					;push af 
97a2			 
97a2					;ld de, os_word_scratch 
97a2					;call str_at_display 
97a2			;		call update_display 
97a2			;		pop af 
97a2 c1					pop bc 
97a3 c6 03				add 3 
97a5 10 dd			djnz .dumpbyte 
97a7			 
97a7				 
97a7			 
97a7 c9				ret 
97a8			 
97a8			jump:	 
97a8			 
97a8 21 e8 e4			ld hl,scratch+2 
97ab cd 5e 8e			call get_word_hl 
97ae				;ld hl,(scratch+2) 
97ae				;call fourehexhl 
97ae			 
97ae 22 09 e8			ld (os_cur_ptr),hl	 
97b1			 
97b1 e9				jp (hl) 
97b2			 
97b2			 
97b2			 
97b2			; TODO implement a basic monitor mode to start with 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			; testing and demo code during development 
97b2			 
97b2			 
97b2 .. 00		str1: db "Enter some text...",0 
97c5 .. 00		clear: db "                    ",0 
97da			 
97da			demo: 
97da			 
97da			 
97da			 
97da			;	call update_display 
97da			 
97da				; init scratch input area for testing 
97da 21 e6 e4			ld hl, scratch	 
97dd 3e 00			ld a,0 
97df 77				ld (hl),a 
97e0			 
97e0			 
97e0 3e 14		            LD   A, display_row_2 
97e2			;            CALL fLCD_Pos       ;Position cursor to location in A 
97e2 11 b2 97		            LD   DE, str1 
97e5 cd 8d 88			call str_at_display 
97e8			 
97e8			;            CALL fLCD_Str       ;Display string pointed to by DE 
97e8			cloop:	 
97e8 3e 28		            LD   A, display_row_3 
97ea			;            CALL fLCD_Pos       ;Position cursor to location in A 
97ea 11 c5 97		            LD   DE, clear 
97ed			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
97ed cd 8d 88				call str_at_display 
97f0 3e 3c			ld a, display_row_4 
97f2 11 22 98			ld de, prompt 
97f5			 
97f5 cd 8d 88				call str_at_display 
97f8 cd 9d 88			call update_display 
97fb			 
97fb 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97fd 16 0a			ld d, 10 
97ff 21 e6 e4			ld hl, scratch	 
9802 cd d4 8a			call input_str 
9805			 
9805			;	call clear_display 
9805			;'	call update_display 
9805			 
9805 3e 00		            LD   A, display_row_1 
9807			;            CALL fLCD_Pos       ;Position cursor to location in A 
9807 11 c5 97		            LD   DE, clear 
980a cd 8d 88				call str_at_display 
980d			;            CALL fLCD_Str       ;Display string pointed to by DE 
980d 3e 00		            LD   A, display_row_1 
980f			;            CALL fLCD_Pos       ;Position cursor to location in A 
980f 11 e6 e4		            LD   DE, scratch 
9812			;            CALL fLCD_Str       ;Display string pointed to by DE 
9812 cd 8d 88				call str_at_display 
9815 cd 9d 88			call update_display 
9818			 
9818 3e 00				ld a,0 
981a 21 e6 e4			ld hl, scratch 
981d 77				ld (hl),a 
981e			 
981e 00				nop 
981f c3 e8 97			jp cloop 
9822			 
9822			 
9822			 
9822			; OS Prompt 
9822			 
9822 .. 00		prompt: db ">",0 
9824 .. 00		endprg: db "?",0 
9826			 
9826			 
9826			; handy next page prompt 
9826			next_page_prompt: 
9826 e5				push hl 
9827 d5				push de 
9828 f5				push af 
9829 c5				push bc 
982a			 
982a 3e 4f			ld a,display_row_4 + display_cols - 1 
982c 11 24 98		        ld de, endprg 
982f cd 8d 88			call str_at_display 
9832 cd 9d 88			call update_display 
9835 cd 1e d7			call cin_wait 
9838 c1				pop bc 
9839 f1				pop af 
983a d1				pop de 
983b e1				pop hl 
983c			 
983c			 
983c c9				ret 
983d			 
983d			 
983d			; forth parser 
983d			 
983d			; My forth kernel 
983d			include "forth_kernel.asm" 
983d			; 
983d			; kernel to the forth OS 
983d			 
983d			DS_TYPE_STR: equ 1     ; string type 
983d			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
983d			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
983d			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
983d			 
983d			FORTH_PARSEV1: equ 0 
983d			FORTH_PARSEV2: equ 0 
983d			FORTH_PARSEV3: equ 0 
983d			FORTH_PARSEV4: equ 0 
983d			FORTH_PARSEV5: equ 1 
983d			 
983d			;if FORTH_PARSEV5 
983d			;	FORTH_END_BUFFER: equ 0 
983d			;else 
983d			FORTH_END_BUFFER: equ 127 
983d			;endif 
983d			 
983d			FORTH_TRUE: equ 1 
983d			FORTH_FALSE: equ 0 
983d			 
983d			if FORTH_PARSEV4 
983d			include "forth_stackops.asm" 
983d			endif 
983d			 
983d			if FORTH_PARSEV5 
983d			include "forth_stackopsv5.asm" 
983d			 
983d			; Stack operations for v5 parser on wards 
983d			; * DATA stack 
983d			; * LOOP stack 
983d			; * RETURN stack 
983d			 
983d			 
983d			 
983d			FORTH_CHK_DSP_UNDER: macro 
983d				push hl 
983d				push de 
983d				ld hl,(cli_data_sp) 
983d				ld de, cli_data_stack 
983d				call cmp16 
983d				jp c, fault_dsp_under 
983d				pop de 
983d				pop hl 
983d				endm 
983d			 
983d			 
983d			FORTH_CHK_RSP_UNDER: macro 
983d				push hl 
983d				push de 
983d				ld hl,(cli_ret_sp) 
983d				ld de, cli_ret_stack 
983d				call cmp16 
983d				jp c, fault_rsp_under 
983d				pop de 
983d				pop hl 
983d				endm 
983d			 
983d			FORTH_CHK_LOOP_UNDER: macro 
983d				push hl 
983d				push de 
983d				ld hl,(cli_loop_sp) 
983d				ld de, cli_loop_stack 
983d				call cmp16 
983d				jp c, fault_loop_under 
983d				pop de 
983d				pop hl 
983d				endm 
983d			 
983d			FORTH_ERR_TOS_NOTSTR: macro 
983d				; TOSO might need more for checks when used 
983d				push af 
983d				ld a,(hl) 
983d				cp DS_TYPE_STR 
983d				jp nz, type_faultn   
983d				pop af 
983d				endm 
983d			 
983d			FORTH_ERR_TOS_NOTNUM: macro 
983d				push af 
983d				ld a,(hl) 
983d				cp DS_TYPE_INUM 
983d				jp nz, type_faultn   
983d				pop af 
983d				endm 
983d			 
983d			 
983d			; increase data stack pointer and save hl to it 
983d				 
983d			FORTH_DSP_NEXT: macro 
983d				call macro_forth_dsp_next 
983d				endm 
983d			 
983d			 
983d			macro_forth_dsp_next: 
983d				if DEBUG_FORTH_STACK_GUARD 
983d cd 82 d4				call check_stacks 
9840				endif 
9840 e5				push hl 
9841 d5				push de 
9842 eb				ex de,hl 
9843 2a 93 ec			ld hl,(cli_data_sp) 
9846 23				inc hl 
9847 23				inc hl 
9848			 
9848			; PARSEV5 
9848 23				inc hl 
9849 22 93 ec			ld (cli_data_sp),hl 
984c 73				ld (hl), e 
984d 23				inc hl 
984e 72				ld (hl), d 
984f d1				pop de 
9850 e1				pop hl 
9851				if DEBUG_FORTH_STACK_GUARD 
9851 cd 82 d4				call check_stacks 
9854				endif 
9854 c9				ret 
9855			 
9855			 
9855			; increase ret stack pointer and save hl to it 
9855				 
9855			FORTH_RSP_NEXT: macro 
9855				call macro_forth_rsp_next 
9855				endm 
9855			 
9855			macro_forth_rsp_next: 
9855				if DEBUG_FORTH_STACK_GUARD 
9855 cd 82 d4				call check_stacks 
9858				endif 
9858 e5				push hl 
9859 d5				push de 
985a eb				ex de,hl 
985b 2a 97 ec			ld hl,(cli_ret_sp) 
985e 23				inc hl 
985f 23				inc hl 
9860 22 97 ec			ld (cli_ret_sp),hl 
9863 73				ld (hl), e 
9864 23				inc hl 
9865 72				ld (hl), d 
9866 d1				pop de 
9867 e1				pop hl 
9868				if DEBUG_FORTH_STACK_GUARD 
9868 cd 82 d4				call check_stacks 
986b				endif 
986b c9				ret 
986c			 
986c			; get current ret stack pointer and save to hl  
986c				 
986c			FORTH_RSP_TOS: macro 
986c				call macro_forth_rsp_tos 
986c				endm 
986c			 
986c			macro_forth_rsp_tos: 
986c				;push de 
986c 2a 97 ec			ld hl,(cli_ret_sp) 
986f cd a7 98			call loadhlptrtohl 
9872				;ld e, (hl) 
9872				;inc hl 
9872				;ld d, (hl) 
9872				;ex de, hl 
9872					if DEBUG_FORTH_WORDS 
9872			;			DMARK "RST" 
9872						CALLMONITOR 
9872 cd 21 93			call break_point_state  
9875				endm  
# End of macro CALLMONITOR
9875					endif 
9875				;pop de 
9875 c9				ret 
9876			 
9876			; pop ret stack pointer 
9876				 
9876			FORTH_RSP_POP: macro 
9876				call macro_forth_rsp_pop 
9876				endm 
9876			 
9876			 
9876			macro_forth_rsp_pop: 
9876				if DEBUG_FORTH_STACK_GUARD 
9876			;		DMARK "RPP" 
9876 cd 82 d4				call check_stacks 
9879					FORTH_CHK_RSP_UNDER 
9879 e5				push hl 
987a d5				push de 
987b 2a 97 ec			ld hl,(cli_ret_sp) 
987e 11 51 ec			ld de, cli_ret_stack 
9881 cd c5 8a			call cmp16 
9884 da 96 d5			jp c, fault_rsp_under 
9887 d1				pop de 
9888 e1				pop hl 
9889				endm 
# End of macro FORTH_CHK_RSP_UNDER
9889				endif 
9889 e5				push hl 
988a 2a 97 ec			ld hl,(cli_ret_sp) 
988d			 
988d			 
988d				if FORTH_ENABLE_FREE 
988d			 
988d					; get pointer 
988d			 
988d					push de 
988d					push hl 
988d			 
988d					ld e, (hl) 
988d					inc hl 
988d					ld d, (hl) 
988d			 
988d					ex de, hl 
988d					call free 
988d			 
988d					pop hl 
988d					pop de 
988d			 
988d			 
988d				endif 
988d			 
988d			 
988d 2b				dec hl 
988e 2b				dec hl 
988f 22 97 ec			ld (cli_ret_sp), hl 
9892				; do stack underflow checks 
9892 e1				pop hl 
9893				if DEBUG_FORTH_STACK_GUARD 
9893 cd 82 d4				call check_stacks 
9896					FORTH_CHK_RSP_UNDER 
9896 e5				push hl 
9897 d5				push de 
9898 2a 97 ec			ld hl,(cli_ret_sp) 
989b 11 51 ec			ld de, cli_ret_stack 
989e cd c5 8a			call cmp16 
98a1 da 96 d5			jp c, fault_rsp_under 
98a4 d1				pop de 
98a5 e1				pop hl 
98a6				endm 
# End of macro FORTH_CHK_RSP_UNDER
98a6				endif 
98a6 c9				ret 
98a7			 
98a7			 
98a7			 
98a7			; routine to load word pointed to by hl into hl 
98a7			 
98a7			loadhlptrtohl: 
98a7			 
98a7 d5				push de 
98a8 5e				ld e, (hl) 
98a9 23				inc hl 
98aa 56				ld d, (hl) 
98ab eb				ex de, hl 
98ac d1				pop de 
98ad			 
98ad c9				ret 
98ae			 
98ae			 
98ae			 
98ae			 
98ae			 
98ae			; push a number held in HL onto the data stack 
98ae			; entry point for pushing a value when already in hl used in function above 
98ae			 
98ae			forth_push_numhl: 
98ae			 
98ae e5				push hl    ; save value to push 
98af			 
98af			if DEBUG_FORTH_PUSH 
98af				; see if disabled 
98af			 
98af			 
98af f5				push af 
98b0 3a d7 e4			ld a, (os_view_disable) 
98b3 fe 2a			cp '*' 
98b5 28 34			jr z, .pskip2 
98b7 e5				push hl 
98b8 e5			push hl 
98b9 cd 7a 88			call clear_display 
98bc e1			pop hl 
98bd 7c				ld a,h 
98be 21 eb e7			ld hl, os_word_scratch 
98c1 cd a8 8d			call hexout 
98c4 e1				pop hl 
98c5 7d				ld a,l 
98c6 21 ed e7			ld hl, os_word_scratch+2 
98c9 cd a8 8d			call hexout 
98cc			 
98cc 21 ef e7			ld hl, os_word_scratch+4 
98cf 3e 00			ld a,0 
98d1 77				ld (hl),a 
98d2 11 eb e7			ld de,os_word_scratch 
98d5 3e 14				ld a, display_row_2 
98d7 cd 8d 88				call str_at_display 
98da 11 90 c3			ld de, .push_num 
98dd 3e 00			ld a, display_row_1 
98df			 
98df cd 8d 88				call str_at_display 
98e2			 
98e2			 
98e2 cd 9d 88			call update_display 
98e5 cd fa 87			call delay1s 
98e8 cd fa 87			call delay1s 
98eb			.pskip2:  
98eb			 
98eb f1				pop af 
98ec			endif	 
98ec			 
98ec			 
98ec				FORTH_DSP_NEXT 
98ec cd 3d 98			call macro_forth_dsp_next 
98ef				endm 
# End of macro FORTH_DSP_NEXT
98ef			 
98ef 2a 93 ec			ld hl, (cli_data_sp) 
98f2			 
98f2				; save item type 
98f2 3e 02			ld a,  DS_TYPE_INUM 
98f4 77				ld (hl), a 
98f5 23				inc hl 
98f6			 
98f6				; get word off stack 
98f6 d1				pop de 
98f7 7b				ld a,e 
98f8 77				ld (hl), a 
98f9 23				inc hl 
98fa 7a				ld a,d 
98fb 77				ld (hl), a 
98fc			 
98fc			if DEBUG_FORTH_PUSH 
98fc 2b				dec hl 
98fd 2b				dec hl 
98fe 2b				dec hl 
98ff						DMARK "PH5" 
98ff f5				push af  
9900 3a 14 99			ld a, (.dmark)  
9903 32 c0 ee			ld (debug_mark),a  
9906 3a 15 99			ld a, (.dmark+1)  
9909 32 c1 ee			ld (debug_mark+1),a  
990c 3a 16 99			ld a, (.dmark+2)  
990f 32 c2 ee			ld (debug_mark+2),a  
9912 18 03			jr .pastdmark  
9914 ..			.dmark: db "PH5"  
9917 f1			.pastdmark: pop af  
9918			endm  
# End of macro DMARK
9918				CALLMONITOR 
9918 cd 21 93			call break_point_state  
991b				endm  
# End of macro CALLMONITOR
991b			endif	 
991b			 
991b c9				ret 
991c			 
991c			 
991c			; Push a string to stack pointed to by hl 
991c			 
991c			forth_push_str: 
991c			 
991c			if DEBUG_FORTH_PUSH 
991c						DMARK "PSQ" 
991c f5				push af  
991d 3a 31 99			ld a, (.dmark)  
9920 32 c0 ee			ld (debug_mark),a  
9923 3a 32 99			ld a, (.dmark+1)  
9926 32 c1 ee			ld (debug_mark+1),a  
9929 3a 33 99			ld a, (.dmark+2)  
992c 32 c2 ee			ld (debug_mark+2),a  
992f 18 03			jr .pastdmark  
9931 ..			.dmark: db "PSQ"  
9934 f1			.pastdmark: pop af  
9935			endm  
# End of macro DMARK
9935				CALLMONITOR 
9935 cd 21 93			call break_point_state  
9938				endm  
# End of macro CALLMONITOR
9938			endif	 
9938			    
9938 e5				push hl 
9939 e5				push hl 
993a			 
993a			;	ld a, 0   ; find end of string 
993a cd 05 8f			call strlenz 
993d			if DEBUG_FORTH_PUSH 
993d						DMARK "PQ2" 
993d f5				push af  
993e 3a 52 99			ld a, (.dmark)  
9941 32 c0 ee			ld (debug_mark),a  
9944 3a 53 99			ld a, (.dmark+1)  
9947 32 c1 ee			ld (debug_mark+1),a  
994a 3a 54 99			ld a, (.dmark+2)  
994d 32 c2 ee			ld (debug_mark+2),a  
9950 18 03			jr .pastdmark  
9952 ..			.dmark: db "PQ2"  
9955 f1			.pastdmark: pop af  
9956			endm  
# End of macro DMARK
9956				CALLMONITOR 
9956 cd 21 93			call break_point_state  
9959				endm  
# End of macro CALLMONITOR
9959			endif	 
9959 eb				ex de, hl 
995a e1				pop hl   ; get ptr to start of string 
995b			if DEBUG_FORTH_PUSH 
995b						DMARK "PQ3" 
995b f5				push af  
995c 3a 70 99			ld a, (.dmark)  
995f 32 c0 ee			ld (debug_mark),a  
9962 3a 71 99			ld a, (.dmark+1)  
9965 32 c1 ee			ld (debug_mark+1),a  
9968 3a 72 99			ld a, (.dmark+2)  
996b 32 c2 ee			ld (debug_mark+2),a  
996e 18 03			jr .pastdmark  
9970 ..			.dmark: db "PQ3"  
9973 f1			.pastdmark: pop af  
9974			endm  
# End of macro DMARK
9974				CALLMONITOR 
9974 cd 21 93			call break_point_state  
9977				endm  
# End of macro CALLMONITOR
9977			endif	 
9977 19				add hl,de 
9978			if DEBUG_FORTH_PUSH 
9978						DMARK "PQE" 
9978 f5				push af  
9979 3a 8d 99			ld a, (.dmark)  
997c 32 c0 ee			ld (debug_mark),a  
997f 3a 8e 99			ld a, (.dmark+1)  
9982 32 c1 ee			ld (debug_mark+1),a  
9985 3a 8f 99			ld a, (.dmark+2)  
9988 32 c2 ee			ld (debug_mark+2),a  
998b 18 03			jr .pastdmark  
998d ..			.dmark: db "PQE"  
9990 f1			.pastdmark: pop af  
9991			endm  
# End of macro DMARK
9991				CALLMONITOR 
9991 cd 21 93			call break_point_state  
9994				endm  
# End of macro CALLMONITOR
9994			endif	 
9994			 
9994 2b				dec hl    ; see if there is an optional trailing double quote 
9995 7e				ld a,(hl) 
9996 fe 22			cp '"' 
9998 20 03			jr nz, .strnoq 
999a 3e 00			ld a, 0      ; get rid of double quote 
999c 77				ld (hl), a 
999d 23			.strnoq: inc hl 
999e			 
999e 3e 00			ld a, 0 
99a0 77				ld (hl), a     ; add null term and get rid of trailing double quote 
99a1			 
99a1 13				inc de ; add one for the type string 
99a2 13				inc de ; add one for null term??? 
99a3			 
99a3				; tos is get string pointer again 
99a3				; de contains space to allocate 
99a3				 
99a3 d5				push de 
99a4			 
99a4 eb				ex de, hl 
99a5			 
99a5				;push af 
99a5			 
99a5			if DEBUG_FORTH_PUSH 
99a5						DMARK "PHm" 
99a5 f5				push af  
99a6 3a ba 99			ld a, (.dmark)  
99a9 32 c0 ee			ld (debug_mark),a  
99ac 3a bb 99			ld a, (.dmark+1)  
99af 32 c1 ee			ld (debug_mark+1),a  
99b2 3a bc 99			ld a, (.dmark+2)  
99b5 32 c2 ee			ld (debug_mark+2),a  
99b8 18 03			jr .pastdmark  
99ba ..			.dmark: db "PHm"  
99bd f1			.pastdmark: pop af  
99be			endm  
# End of macro DMARK
99be				CALLMONITOR 
99be cd 21 93			call break_point_state  
99c1				endm  
# End of macro CALLMONITOR
99c1			endif	 
99c1 cd 6e 8f			call malloc	; on ret hl now contains allocated memory 
99c4				if DEBUG_FORTH_MALLOC_GUARD 
99c4 cc e8 c3				call z,malloc_error 
99c7				endif 
99c7			 
99c7				 
99c7 c1				pop bc    ; get length 
99c8 d1				pop de   ;  get string start    
99c9			 
99c9				; hl has destination from malloc 
99c9			 
99c9 eb				ex de, hl    ; prep for ldir 
99ca			 
99ca d5				push de   ; save malloc area for DSP later 
99cb				;push hl   ; save malloc area for DSP later 
99cb			 
99cb			if DEBUG_FORTH_PUSH 
99cb						DMARK "PHc" 
99cb f5				push af  
99cc 3a e0 99			ld a, (.dmark)  
99cf 32 c0 ee			ld (debug_mark),a  
99d2 3a e1 99			ld a, (.dmark+1)  
99d5 32 c1 ee			ld (debug_mark+1),a  
99d8 3a e2 99			ld a, (.dmark+2)  
99db 32 c2 ee			ld (debug_mark+2),a  
99de 18 03			jr .pastdmark  
99e0 ..			.dmark: db "PHc"  
99e3 f1			.pastdmark: pop af  
99e4			endm  
# End of macro DMARK
99e4				CALLMONITOR 
99e4 cd 21 93			call break_point_state  
99e7				endm  
# End of macro CALLMONITOR
99e7			endif	 
99e7			 
99e7			 
99e7 ed b0			ldir 
99e9			 
99e9			 
99e9				; push malloc to data stack     macro?????  
99e9			 
99e9				FORTH_DSP_NEXT 
99e9 cd 3d 98			call macro_forth_dsp_next 
99ec				endm 
# End of macro FORTH_DSP_NEXT
99ec			 
99ec				; save value and type 
99ec			 
99ec 2a 93 ec			ld hl, (cli_data_sp) 
99ef			 
99ef				; save item type 
99ef 3e 01			ld a,  DS_TYPE_STR 
99f1 77				ld (hl), a 
99f2 23				inc hl 
99f3			 
99f3				; get malloc word off stack 
99f3 d1				pop de 
99f4 73				ld (hl), e 
99f5 23				inc hl 
99f6 72				ld (hl), d 
99f7			 
99f7			 
99f7			 
99f7			if DEBUG_FORTH_PUSH 
99f7 2a 93 ec			ld hl, (cli_data_sp) 
99fa						DMARK "PHS" 
99fa f5				push af  
99fb 3a 0f 9a			ld a, (.dmark)  
99fe 32 c0 ee			ld (debug_mark),a  
9a01 3a 10 9a			ld a, (.dmark+1)  
9a04 32 c1 ee			ld (debug_mark+1),a  
9a07 3a 11 9a			ld a, (.dmark+2)  
9a0a 32 c2 ee			ld (debug_mark+2),a  
9a0d 18 03			jr .pastdmark  
9a0f ..			.dmark: db "PHS"  
9a12 f1			.pastdmark: pop af  
9a13			endm  
# End of macro DMARK
9a13				CALLMONITOR 
9a13 cd 21 93			call break_point_state  
9a16				endm  
# End of macro CALLMONITOR
9a16			;	ex de,hl 
9a16			endif	 
9a16				; in case of spaces, skip the ptr past the copied string 
9a16				;pop af 
9a16				;ld (cli_origptr),hl 
9a16			 
9a16 c9				ret 
9a17			 
9a17			 
9a17			 
9a17			; TODO ascii push input onto stack given hl to start of input 
9a17			 
9a17			; identify type 
9a17			; if starts with a " then a string 
9a17			; otherwise it is a number 
9a17			;  
9a17			; if a string 
9a17			;     scan for ending " to get length of string to malloc for + 1 
9a17			;     malloc 
9a17			;     put pointer to string on stack first byte flags as string 
9a17			; 
9a17			; else a number 
9a17			;    look for number format identifier 
9a17			;    $xx hex 
9a17			;    %xxxxx bin 
9a17			;    xxxxx decimal 
9a17			;    convert number to 16bit word.  
9a17			;    malloc word + 1 with flag to identiy as num 
9a17			;    put pointer to number on stack 
9a17			;   
9a17			;  
9a17			  
9a17			forth_apush: 
9a17				; kernel push 
9a17			 
9a17			if DEBUG_FORTH_PUSH 
9a17						DMARK "PSH" 
9a17 f5				push af  
9a18 3a 2c 9a			ld a, (.dmark)  
9a1b 32 c0 ee			ld (debug_mark),a  
9a1e 3a 2d 9a			ld a, (.dmark+1)  
9a21 32 c1 ee			ld (debug_mark+1),a  
9a24 3a 2e 9a			ld a, (.dmark+2)  
9a27 32 c2 ee			ld (debug_mark+2),a  
9a2a 18 03			jr .pastdmark  
9a2c ..			.dmark: db "PSH"  
9a2f f1			.pastdmark: pop af  
9a30			endm  
# End of macro DMARK
9a30				CALLMONITOR 
9a30 cd 21 93			call break_point_state  
9a33				endm  
# End of macro CALLMONITOR
9a33			endif	 
9a33				; identify input type 
9a33			 
9a33 7e				ld a,(hl) 
9a34 fe 22			cp '"' 
9a36 28 0a			jr z, .fapstr 
9a38 fe 24			cp '$' 
9a3a ca 62 9a			jp z, .faphex 
9a3d fe 25			cp '%' 
9a3f ca 4a 9a			jp z, .fapbin 
9a42			;	cp 'b' 
9a42			;	jp z, .fabin 
9a42				; else decimal 
9a42			 
9a42				; TODO do decimal conversion 
9a42				; decimal is stored as a 16bit word 
9a42			 
9a42				; by default everything is a string if type is not detected 
9a42			.fapstr: ; 
9a42 fe 22			cp '"' 
9a44 20 01			jr nz, .strnoqu 
9a46 23				inc hl 
9a47			.strnoqu: 
9a47 c3 1c 99			jp forth_push_str 
9a4a			 
9a4a			 
9a4a			 
9a4a			.fapbin:    ; push a binary string.  
9a4a 11 00 00			ld de, 0   ; hold a 16bit value 
9a4d			 
9a4d 23			.fapbinshift:	inc hl  
9a4e 7e				ld a,(hl) 
9a4f fe 00			cp 0     ; done scanning  
9a51 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a53			 
9a53				; left shift de 
9a53 eb				ex de, hl	 
9a54 29				add hl, hl 
9a55			 
9a55				; is 1 
9a55 fe 31			cp '1' 
9a57 20 02			jr nz, .binzero 
9a59 cb 4d			bit 1, l 
9a5b			.binzero: 
9a5b eb				ex de, hl	 ; save current de 
9a5c 18 ef			jr .fapbinshift 
9a5e			 
9a5e			.fapbdone: 
9a5e eb				ex de, hl 
9a5f c3 ae 98			jp forth_push_numhl 
9a62			 
9a62			 
9a62			.faphex:   ; hex is always stored as a 16bit word 
9a62				; skip number prefix 
9a62 23				inc hl 
9a63				; turn ascii into number 
9a63 cd 5e 8e			call get_word_hl	; ret 16bit word in hl 
9a66			 
9a66 c3 ae 98			jp forth_push_numhl 
9a69			 
9a69 00				 nop 
9a6a			 
9a6a			.fabin:   ; TODO bin conversion 
9a6a			 
9a6a			 
9a6a c9				ret 
9a6b			 
9a6b			 
9a6b			; get either a string ptr or a 16bit word from the data stack 
9a6b			 
9a6b			FORTH_DSP: macro 
9a6b				call macro_forth_dsp 
9a6b				endm 
9a6b			 
9a6b			macro_forth_dsp: 
9a6b				; data stack pointer points to current word on tos 
9a6b			 
9a6b 2a 93 ec			ld hl,(cli_data_sp) 
9a6e			 
9a6e				if DEBUG_FORTH_PUSH 
9a6e						DMARK "DSP" 
9a6e f5				push af  
9a6f 3a 83 9a			ld a, (.dmark)  
9a72 32 c0 ee			ld (debug_mark),a  
9a75 3a 84 9a			ld a, (.dmark+1)  
9a78 32 c1 ee			ld (debug_mark+1),a  
9a7b 3a 85 9a			ld a, (.dmark+2)  
9a7e 32 c2 ee			ld (debug_mark+2),a  
9a81 18 03			jr .pastdmark  
9a83 ..			.dmark: db "DSP"  
9a86 f1			.pastdmark: pop af  
9a87			endm  
# End of macro DMARK
9a87			 
9a87 cd 1d c4				call display_data_sp 
9a8a				;call break_point_state 
9a8a				;rst 030h 
9a8a				CALLMONITOR 
9a8a cd 21 93			call break_point_state  
9a8d				endm  
# End of macro CALLMONITOR
9a8d				endif 
9a8d			 
9a8d c9				ret 
9a8e			 
9a8e			; return hl to start of value on stack 
9a8e			 
9a8e			FORTH_DSP_VALUE: macro 
9a8e				call macro_forth_dsp_value 
9a8e				endm 
9a8e			 
9a8e			macro_forth_dsp_value: 
9a8e			 
9a8e				FORTH_DSP 
9a8e cd 6b 9a			call macro_forth_dsp 
9a91				endm 
# End of macro FORTH_DSP
9a91			 
9a91 d5				push de 
9a92			 
9a92 23				inc hl ; skip type 
9a93			 
9a93 5e				ld e, (hl) 
9a94 23				inc hl 
9a95 56				ld d, (hl) 
9a96 eb				ex de,hl  
9a97			 
9a97 d1				pop de 
9a98			 
9a98 c9				ret 
9a99			 
9a99			; return hl to start of value to second item on stack 
9a99			 
9a99			FORTH_DSP_VALUEM1: macro 
9a99				call macro_forth_dsp_value_m1 
9a99				endm 
9a99			 
9a99			macro_forth_dsp_value_m1: 
9a99			 
9a99				FORTH_DSP 
9a99 cd 6b 9a			call macro_forth_dsp 
9a9c				endm 
# End of macro FORTH_DSP
9a9c			 
9a9c 2b				dec hl 
9a9d 2b				dec hl 
9a9e			;	dec hl 
9a9e			 
9a9e d5				push de 
9a9f			 
9a9f 5e				ld e, (hl) 
9aa0 23				inc hl 
9aa1 56				ld d, (hl) 
9aa2 eb				ex de,hl  
9aa3			 
9aa3 d1				pop de 
9aa4			 
9aa4 c9				ret 
9aa5			 
9aa5				 
9aa5			 
9aa5			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9aa5			 
9aa5			FORTH_DSP_POP: macro 
9aa5				call macro_forth_dsp_pop 
9aa5				endm 
9aa5			 
9aa5			 
9aa5			; get the tos data type 
9aa5			 
9aa5			FORTH_DSP_TYPE:   macro 
9aa5			 
9aa5				;FORTH_DSP_VALUE 
9aa5				FORTH_DSP 
9aa5				 
9aa5				; hl points to value 
9aa5				; check type 
9aa5			 
9aa5				ld a,(hl) 
9aa5			 
9aa5				endm 
9aa5			 
9aa5			; load the tos value into hl 
9aa5			 
9aa5			 
9aa5			FORTH_DSP_VALUEHL:  macro 
9aa5				call macro_dsp_valuehl 
9aa5				endm 
9aa5			 
9aa5			 
9aa5			 
9aa5			macro_dsp_valuehl: 
9aa5				FORTH_DSP_VALUE 
9aa5 cd 8e 9a			call macro_forth_dsp_value 
9aa8				endm 
# End of macro FORTH_DSP_VALUE
9aa8			 
9aa8				;FORTH_ERR_TOS_NOTNUM 
9aa8			 
9aa8				;inc hl   ; skip type id 
9aa8			 
9aa8			;	push de 
9aa8			; 
9aa8			;	ld e, (hl) 
9aa8			;	inc hl 
9aa8			;	ld d, (hl) 
9aa8			;	ex de,hl  
9aa8			 
9aa8			;	pop de 
9aa8			 
9aa8				if DEBUG_FORTH_PUSH 
9aa8						DMARK "DVL" 
9aa8 f5				push af  
9aa9 3a bd 9a			ld a, (.dmark)  
9aac 32 c0 ee			ld (debug_mark),a  
9aaf 3a be 9a			ld a, (.dmark+1)  
9ab2 32 c1 ee			ld (debug_mark+1),a  
9ab5 3a bf 9a			ld a, (.dmark+2)  
9ab8 32 c2 ee			ld (debug_mark+2),a  
9abb 18 03			jr .pastdmark  
9abd ..			.dmark: db "DVL"  
9ac0 f1			.pastdmark: pop af  
9ac1			endm  
# End of macro DMARK
9ac1				CALLMONITOR 
9ac1 cd 21 93			call break_point_state  
9ac4				endm  
# End of macro CALLMONITOR
9ac4				endif 
9ac4 c9				ret 
9ac5			 
9ac5			forth_apushstrhl:      
9ac5				; push of string requires use of cli_origptr 
9ac5				; bodge use 
9ac5			 
9ac5				; get current cli_origptr, save, update with temp pointer  
9ac5 ed 5b af ec		ld de, (cli_origptr) 
9ac9 22 af ec			ld (cli_origptr), hl 
9acc d5				push de 
9acd cd 17 9a			call forth_apush 
9ad0 d1				pop de 
9ad1 ed 53 af ec		ld (cli_origptr), de 
9ad5 c9			        ret	 
9ad6			 
9ad6			 
9ad6			; increase loop stack pointer and save hl to it 
9ad6				 
9ad6			FORTH_LOOP_NEXT: macro 
9ad6				call macro_forth_loop_next 
9ad6				;nop 
9ad6				endm 
9ad6			 
9ad6			macro_forth_loop_next: 
9ad6				if DEBUG_FORTH_STACK_GUARD 
9ad6 cd 82 d4				call check_stacks 
9ad9				endif 
9ad9 e5				push hl 
9ada d5				push de 
9adb eb				ex de,hl 
9adc 2a 95 ec			ld hl,(cli_loop_sp) 
9adf 23				inc hl 
9ae0 23				inc hl 
9ae1					if DEBUG_FORTH_WORDS 
9ae1						DMARK "LNX" 
9ae1 f5				push af  
9ae2 3a f6 9a			ld a, (.dmark)  
9ae5 32 c0 ee			ld (debug_mark),a  
9ae8 3a f7 9a			ld a, (.dmark+1)  
9aeb 32 c1 ee			ld (debug_mark+1),a  
9aee 3a f8 9a			ld a, (.dmark+2)  
9af1 32 c2 ee			ld (debug_mark+2),a  
9af4 18 03			jr .pastdmark  
9af6 ..			.dmark: db "LNX"  
9af9 f1			.pastdmark: pop af  
9afa			endm  
# End of macro DMARK
9afa						CALLMONITOR 
9afa cd 21 93			call break_point_state  
9afd				endm  
# End of macro CALLMONITOR
9afd					endif 
9afd 22 95 ec			ld (cli_loop_sp),hl 
9b00 73				ld (hl), e 
9b01 23				inc hl 
9b02 72				ld (hl), d 
9b03 d1				pop de    ; been reversed so save a swap on restore 
9b04 e1				pop hl 
9b05				if DEBUG_FORTH_STACK_GUARD 
9b05 cd 82 d4				call check_stacks 
9b08				endif 
9b08 c9				ret 
9b09			 
9b09			; get current ret stack pointer and save to hl  
9b09				 
9b09			FORTH_LOOP_TOS: macro 
9b09				call macro_forth_loop_tos 
9b09				endm 
9b09			 
9b09			macro_forth_loop_tos: 
9b09 d5				push de 
9b0a 2a 95 ec			ld hl,(cli_loop_sp) 
9b0d 5e				ld e, (hl) 
9b0e 23				inc hl 
9b0f 56				ld d, (hl) 
9b10 eb				ex de, hl 
9b11 d1				pop de 
9b12 c9				ret 
9b13			 
9b13			; pop loop stack pointer 
9b13				 
9b13			FORTH_LOOP_POP: macro 
9b13				call macro_forth_loop_pop 
9b13				endm 
9b13			 
9b13			 
9b13			macro_forth_loop_pop: 
9b13				if DEBUG_FORTH_STACK_GUARD 
9b13					DMARK "LPP" 
9b13 f5				push af  
9b14 3a 28 9b			ld a, (.dmark)  
9b17 32 c0 ee			ld (debug_mark),a  
9b1a 3a 29 9b			ld a, (.dmark+1)  
9b1d 32 c1 ee			ld (debug_mark+1),a  
9b20 3a 2a 9b			ld a, (.dmark+2)  
9b23 32 c2 ee			ld (debug_mark+2),a  
9b26 18 03			jr .pastdmark  
9b28 ..			.dmark: db "LPP"  
9b2b f1			.pastdmark: pop af  
9b2c			endm  
# End of macro DMARK
9b2c cd 82 d4				call check_stacks 
9b2f					FORTH_CHK_LOOP_UNDER 
9b2f e5				push hl 
9b30 d5				push de 
9b31 2a 95 ec			ld hl,(cli_loop_sp) 
9b34 11 4f eb			ld de, cli_loop_stack 
9b37 cd c5 8a			call cmp16 
9b3a da 9c d5			jp c, fault_loop_under 
9b3d d1				pop de 
9b3e e1				pop hl 
9b3f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b3f				endif 
9b3f e5				push hl 
9b40 2a 95 ec			ld hl,(cli_loop_sp) 
9b43 2b				dec hl 
9b44 2b				dec hl 
9b45 22 95 ec			ld (cli_loop_sp), hl 
9b48				; TODO do stack underflow checks 
9b48 e1				pop hl 
9b49				if DEBUG_FORTH_STACK_GUARD 
9b49 cd 82 d4				call check_stacks 
9b4c					FORTH_CHK_LOOP_UNDER 
9b4c e5				push hl 
9b4d d5				push de 
9b4e 2a 95 ec			ld hl,(cli_loop_sp) 
9b51 11 4f eb			ld de, cli_loop_stack 
9b54 cd c5 8a			call cmp16 
9b57 da 9c d5			jp c, fault_loop_under 
9b5a d1				pop de 
9b5b e1				pop hl 
9b5c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b5c				endif 
9b5c c9				ret 
9b5d			 
9b5d			macro_forth_dsp_pop: 
9b5d			 
9b5d e5				push hl 
9b5e			 
9b5e				; release malloc data 
9b5e			 
9b5e				if DEBUG_FORTH_STACK_GUARD 
9b5e cd 82 d4				call check_stacks 
9b61					FORTH_CHK_DSP_UNDER 
9b61 e5				push hl 
9b62 d5				push de 
9b63 2a 93 ec			ld hl,(cli_data_sp) 
9b66 11 4d ea			ld de, cli_data_stack 
9b69 cd c5 8a			call cmp16 
9b6c da 90 d5			jp c, fault_dsp_under 
9b6f d1				pop de 
9b70 e1				pop hl 
9b71				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b71				endif 
9b71				;ld hl,(cli_data_sp) 
9b71			if DEBUG_FORTH_DOT 
9b71				DMARK "DPP" 
9b71				CALLMONITOR 
9b71			endif	 
9b71			 
9b71			 
9b71			if FORTH_ENABLE_DSPPOPFREE 
9b71			 
9b71				FORTH_DSP 
9b71 cd 6b 9a			call macro_forth_dsp 
9b74				endm 
# End of macro FORTH_DSP
9b74			 
9b74 7e				ld a, (hl) 
9b75 fe 01			cp DS_TYPE_STR 
9b77 20 07			jr nz, .skippopfree 
9b79			 
9b79				FORTH_DSP_VALUEHL 
9b79 cd a5 9a			call macro_dsp_valuehl 
9b7c				endm 
# End of macro FORTH_DSP_VALUEHL
9b7c 00				nop 
9b7d			if DEBUG_FORTH_DOT 
9b7d				DMARK "DPf" 
9b7d				CALLMONITOR 
9b7d			endif	 
9b7d cd 38 90			call free 
9b80			.skippopfree: 
9b80				 
9b80			 
9b80			endif 
9b80			 
9b80			if DEBUG_FORTH_DOT_KEY 
9b80				DMARK "DP2" 
9b80				CALLMONITOR 
9b80			endif	 
9b80			 
9b80				; move pointer down 
9b80			 
9b80 2a 93 ec			ld hl,(cli_data_sp) 
9b83 2b				dec hl 
9b84 2b				dec hl 
9b85			; PARSEV5 
9b85 2b				dec hl 
9b86 22 93 ec			ld (cli_data_sp), hl 
9b89			 
9b89				if DEBUG_FORTH_STACK_GUARD 
9b89 cd 82 d4				call check_stacks 
9b8c					FORTH_CHK_DSP_UNDER 
9b8c e5				push hl 
9b8d d5				push de 
9b8e 2a 93 ec			ld hl,(cli_data_sp) 
9b91 11 4d ea			ld de, cli_data_stack 
9b94 cd c5 8a			call cmp16 
9b97 da 90 d5			jp c, fault_dsp_under 
9b9a d1				pop de 
9b9b e1				pop hl 
9b9c				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b9c				endif 
9b9c			 
9b9c e1				pop hl 
9b9d			 
9b9d c9				ret 
9b9e			 
9b9e			getwordathl: 
9b9e				; hl points to an address 
9b9e				; load hl with the word at that address 
9b9e			 
9b9e d5				push de 
9b9f			 
9b9f 5e				ld e, (hl) 
9ba0 23				inc hl 
9ba1 56				ld d, (hl) 
9ba2 eb				ex de, hl 
9ba3			 
9ba3 d1				pop de 
9ba4 c9				ret 
9ba5			 
9ba5			 
9ba5			 
9ba5			 
9ba5			 
9ba5			; eof 
9ba5			 
# End of file forth_stackopsv5.asm
9ba5			endif 
9ba5			 
9ba5			user_word_eol:  
9ba5				; hl contains the pointer to where to create a linked list item from the end 
9ba5				; of the user dict to continue on at the system word dict 
9ba5				 
9ba5				; poke the stub of the word list linked list to repoint to rom words 
9ba5			 
9ba5				; stub format 
9ba5				; db   word id 
9ba5				; dw    link to next word 
9ba5			        ; db char length of token 
9ba5				; db string + 0 term 
9ba5				; db exec code....  
9ba5			 
9ba5 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9ba7 77				ld (hl), a		; word id 
9ba8 23				inc hl 
9ba9			 
9ba9 11 6f 9d			ld de, sysdict 
9bac 73				ld (hl), e		; next word link ie system dict 
9bad 23				inc hl 
9bae 72				ld (hl), d		; next word link ie system dict 
9baf 23				inc hl	 
9bb0			 
9bb0			;	ld (hl), sysdict		; next word link ie system dict 
9bb0			;	inc hl 
9bb0			;	inc hl 
9bb0			 
9bb0			;	inc hl 
9bb0			;	inc hl 
9bb0			 
9bb0 3e 02			ld a, 2			; word length is 0 
9bb2 77				ld (hl), a	 
9bb3 23				inc hl 
9bb4			 
9bb4 3e 7e			ld a, '~'			; word length is 0 
9bb6 77				ld (hl), a	 
9bb7 23				inc hl 
9bb8 3e 00			ld a, 0			; save empty word 
9bba 77				ld (hl), a 
9bbb			 
9bbb c9				ret 
9bbc			 
9bbc				 
9bbc			 
9bbc			forthexec_cleanup: 
9bbc				FORTH_RSP_POP 
9bbc cd 76 98			call macro_forth_rsp_pop 
9bbf				endm 
# End of macro FORTH_RSP_POP
9bbf c9				ret 
9bc0			 
9bc0			forth_call_hl: 
9bc0				; taking hl 
9bc0 e5				push hl 
9bc1 c9				ret 
9bc2			 
9bc2			; this is called to reset Forth system but keep existing uwords etc 
9bc2			 
9bc2			forth_warmstart: 
9bc2				; setup stack over/under flow checks 
9bc2				if DEBUG_FORTH_STACK_GUARD 
9bc2 cd 68 d4				call chk_stk_init 
9bc5				endif 
9bc5			 
9bc5				; init stack pointers  - * these stacks go upwards *  
9bc5 21 51 ec			ld hl, cli_ret_stack 
9bc8 22 97 ec			ld (cli_ret_sp), hl	 
9bcb				; set bottom of stack 
9bcb 3e 00			ld a,0 
9bcd 77				ld (hl),a 
9bce 23				inc hl 
9bcf 77				ld (hl),a 
9bd0			 
9bd0 21 4d ea			ld hl, cli_data_stack 
9bd3 22 93 ec			ld (cli_data_sp), hl	 
9bd6				; set bottom of stack 
9bd6 3e 00			ld a,0 
9bd8 77				ld (hl),a 
9bd9 23				inc hl 
9bda 77				ld (hl),a 
9bdb			 
9bdb 21 4f eb			ld hl, cli_loop_stack 
9bde 22 95 ec			ld (cli_loop_sp), hl	 
9be1				; set bottom of stack 
9be1 3e 00			ld a,0 
9be3 77				ld (hl),a 
9be4 23				inc hl 
9be5 77				ld (hl),a 
9be6			 
9be6				; init extent of current open file 
9be6			 
9be6 3e 00			ld a, 0 
9be8 32 e2 ec			ld (store_openext), a 
9beb			 
9beb c9				ret 
9bec			 
9bec			 
9bec			; Cold Start - this is called to setup the whole Forth system 
9bec			 
9bec			forth_init: 
9bec			 
9bec				; setup stack over/under flow checks 
9bec			 
9bec			;	if DEBUG_FORTH_STACK_GUARD 
9bec			;		call chk_stk_init 
9bec			;	endif 
9bec			 
9bec				; enable auto display updates (slow.....) 
9bec			 
9bec 3e 01			ld a, 1 
9bee 32 ad ec			ld (cli_autodisplay), a 
9bf1			 
9bf1			 
9bf1			 
9bf1				; show start up screen 
9bf1			 
9bf1 cd 7a 88			call clear_display 
9bf4			 
9bf4 3e 00			ld a,0 
9bf6 32 cf ec			ld (f_cursor_ptr), a 
9bf9			 
9bf9				; set start of word list in start of ram - for use when creating user words 
9bf9			 
9bf9 21 33 d7			ld hl, baseram 
9bfc 22 e3 e7			ld (os_last_new_uword), hl 
9bff cd a5 9b			call user_word_eol 
9c02				 
9c02			;		call display_data_sp 
9c02			;		call next_page_prompt 
9c02			 
9c02			 
9c02			 
9c02			 
9c02 c9				ret 
9c03			 
9c03 .. 00		.bootforth: db " Forth Kernel Init ",0 
9c17			 
9c17			; TODO push to stack 
9c17			 
9c17			;  
9c17			 
9c17			if FORTH_PARSEV2 
9c17			 
9c17			 
9c17				include "forth_parserv2.asm" 
9c17			 
9c17			endif 
9c17			 
9c17			 
9c17			; parse cli version 1 
9c17			 
9c17			if FORTH_PARSEV1 
9c17			 
9c17			 
9c17			 
9c17			      include "forth_parserv1.asm" 
9c17			endif 
9c17				 
9c17			if FORTH_PARSEV3 
9c17			 
9c17			 
9c17			 
9c17			      include "forth_parserv3.asm" 
9c17				include "forth_wordsv3.asm" 
9c17			endif 
9c17			 
9c17			if FORTH_PARSEV4 
9c17			 
9c17			 
9c17			 
9c17			      include "forth_parserv4.asm" 
9c17				include "forth_wordsv4.asm" 
9c17			endif 
9c17			 
9c17			if FORTH_PARSEV5 
9c17			 
9c17			 
9c17			 
9c17			      include "forth_parserv5.asm" 
9c17			 
9c17			 
9c17			; A better parser without using malloc and string copies all over the place.  
9c17			; Exec in situ should be faster 
9c17			 
9c17			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9c17			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9c17			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9c17			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9c17			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9c17			WORD_SYS_END: equ 0   ; Opcode for all user words 
9c17			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9c17			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9c17			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9c17			 
9c17			; Core word preamble macro 
9c17			 
9c17			CWHEAD:   macro nxtword opcode lit len opflags 
9c17				db WORD_SYS_CORE+opcode             
9c17				; internal op code number 
9c17				dw nxtword            
9c17				; link to next dict word block 
9c17				db len + 1 
9c17				; literal length of dict word inc zero term 
9c17				db lit,0              
9c17				; literal dict word 
9c17			        ; TODO db opflags        
9c17				endm 
9c17			 
9c17			 
9c17			NEXTW: macro  
9c17				jp macro_next 
9c17				endm 
9c17			 
9c17			macro_next: 
9c17			if DEBUG_FORTH_PARSE_KEY 
9c17				DMARK "NXT" 
9c17				CALLMONITOR 
9c17			endif	 
9c17			;	inc hl  ; skip token null term  
9c17 ed 4b b1 ec		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c1b ed 5b af ec		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c1f 2a e7 e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c22			if DEBUG_FORTH_PARSE_KEY 
9c22				DMARK "}AA" 
9c22				CALLMONITOR 
9c22			endif	 
9c22 c3 25 9d			jp execnext 
9c25				;jp exec1 
9c25			       
9c25			 
9c25			 
9c25			; Another go at the parser to compile  
9c25			 
9c25			 
9c25			; TODO rework parser to change all of the string words to byte tokens 
9c25			; TODO do a search for  
9c25			 
9c25			; TODO first run normal parser to zero term sections 
9c25			; TODO for each word do a token look up to get the op code 
9c25			; TODO need some means to flag to the exec that this is a byte code form    
9c25			 
9c25			 
9c25			forthcompile: 
9c25			 
9c25			; 
9c25			; line parse: 
9c25			;       parse raw input buffer 
9c25			;       tokenise the words 
9c25			;       malloc new copy (for looping etc) 
9c25			;       copy to malloc + current pc in line to start of string and add line term 
9c25			;       save on new rsp 
9c25			; 
9c25			 
9c25			; hl to point to the line to tokenise 
9c25			 
9c25			;	push hl 
9c25 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c28			 
9c28			;	ld a,0		; string term on input 
9c28			;	call strlent 
9c28			 
9c28			;	ld (os_tok_len), hl	 ; save string length 
9c28			 
9c28			;if DEBUG_FORTH_TOK 
9c28			;	ex de,hl		 
9c28			;endif 
9c28			 
9c28			;	pop hl 		; get back string pointer 
9c28			 
9c28			if DEBUG_FORTH_TOK 
9c28						DMARK "TOc" 
9c28				CALLMONITOR 
9c28			endif 
9c28 7e			.cptoken2:    ld a,(hl) 
9c29 23				inc hl 
9c2a fe 7f			cp FORTH_END_BUFFER 
9c2c 28 29			jr z, .cptokendone2 
9c2e fe 00			cp 0 
9c30 28 25			jr z, .cptokendone2 
9c32 fe 22			cp '"' 
9c34 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c36 fe 20			cp ' ' 
9c38 20 ee			jr nz,  .cptoken2 
9c3a			 
9c3a			; TODO consume comments held between ( and ) 
9c3a			 
9c3a				; we have a space so change to zero term for dict match later 
9c3a 2b				dec hl 
9c3b 3e 00			ld a,0 
9c3d 77				ld (hl), a 
9c3e 23				inc hl 
9c3f 18 e7			jr .cptoken2 
9c41				 
9c41			 
9c41			.cptokenstr2: 
9c41				; skip all white space until either eol (because forgot to term) or end double quote 
9c41			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c41				;inc hl ; skip current double quote 
9c41 7e				ld a,(hl) 
9c42 23				inc hl 
9c43 fe 22			cp '"' 
9c45 28 e1			jr z, .cptoken2 
9c47 fe 7f			cp FORTH_END_BUFFER 
9c49 28 0c			jr z, .cptokendone2 
9c4b fe 00			cp 0 
9c4d 28 08			jr z, .cptokendone2 
9c4f fe 20			cp ' ' 
9c51 28 02			jr z, .cptmp2 
9c53 18 ec			jr .cptokenstr2 
9c55			 
9c55			.cptmp2:	; we have a space so change to zero term for dict match later 
9c55				;dec hl 
9c55				;ld a,"-"	; TODO remove this when working 
9c55				;ld (hl), a 
9c55				;inc hl 
9c55 18 ea			jr .cptokenstr2 
9c57			 
9c57			.cptokendone2: 
9c57				;inc hl 
9c57 3e 7f			ld a, FORTH_END_BUFFER 
9c59 77				ld (hl),a 
9c5a 23				inc hl 
9c5b 3e 21			ld a, '!' 
9c5d 77				ld (hl),a 
9c5e			 
9c5e 2a e7 e7			ld hl,(os_tok_ptr) 
9c61			         
9c61			if DEBUG_FORTH_TOK 
9c61						DMARK "Tc1" 
9c61				CALLMONITOR 
9c61			endif 
9c61			 
9c61				; push exec string to top of return stack 
9c61				FORTH_RSP_NEXT 
9c61 cd 55 98			call macro_forth_rsp_next 
9c64				endm 
# End of macro FORTH_RSP_NEXT
9c64 c9				ret 
9c65			 
9c65			; Another go at the parser need to simplify the process 
9c65			 
9c65			forthparse: 
9c65			 
9c65			; 
9c65			; line parse: 
9c65			;       parse raw input buffer 
9c65			;       tokenise the words 
9c65			;       malloc new copy (for looping etc) 
9c65			;       copy to malloc + current pc in line to start of string and add line term 
9c65			;       save on new rsp 
9c65			; 
9c65			 
9c65			; hl to point to the line to tokenise 
9c65			 
9c65			;	push hl 
9c65 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c68			 
9c68			;	ld a,0		; string term on input 
9c68			;	call strlent 
9c68			 
9c68			;	ld (os_tok_len), hl	 ; save string length 
9c68			 
9c68			;if DEBUG_FORTH_TOK 
9c68			;	ex de,hl		 
9c68			;endif 
9c68			 
9c68			;	pop hl 		; get back string pointer 
9c68			 
9c68			if DEBUG_FORTH_TOK 
9c68						DMARK "TOK" 
9c68				CALLMONITOR 
9c68			endif 
9c68 7e			.ptoken2:    ld a,(hl) 
9c69 23				inc hl 
9c6a fe 7f			cp FORTH_END_BUFFER 
9c6c 28 29			jr z, .ptokendone2 
9c6e fe 00			cp 0 
9c70 28 25			jr z, .ptokendone2 
9c72 fe 22			cp '"' 
9c74 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9c76 fe 20			cp ' ' 
9c78 20 ee			jr nz,  .ptoken2 
9c7a			 
9c7a			; TODO consume comments held between ( and ) 
9c7a			 
9c7a				; we have a space so change to zero term for dict match later 
9c7a 2b				dec hl 
9c7b 3e 00			ld a,0 
9c7d 77				ld (hl), a 
9c7e 23				inc hl 
9c7f 18 e7			jr .ptoken2 
9c81				 
9c81			 
9c81			.ptokenstr2: 
9c81				; skip all white space until either eol (because forgot to term) or end double quote 
9c81			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c81				;inc hl ; skip current double quote 
9c81 7e				ld a,(hl) 
9c82 23				inc hl 
9c83 fe 22			cp '"' 
9c85 28 e1			jr z, .ptoken2 
9c87 fe 7f			cp FORTH_END_BUFFER 
9c89 28 0c			jr z, .ptokendone2 
9c8b fe 00			cp 0 
9c8d 28 08			jr z, .ptokendone2 
9c8f fe 20			cp ' ' 
9c91 28 02			jr z, .ptmp2 
9c93 18 ec			jr .ptokenstr2 
9c95			 
9c95			.ptmp2:	; we have a space so change to zero term for dict match later 
9c95				;dec hl 
9c95				;ld a,"-"	; TODO remove this when working 
9c95				;ld (hl), a 
9c95				;inc hl 
9c95 18 ea			jr .ptokenstr2 
9c97			 
9c97			.ptokendone2: 
9c97				;inc hl 
9c97 3e 7f			ld a, FORTH_END_BUFFER 
9c99 77				ld (hl),a 
9c9a 23				inc hl 
9c9b 3e 21			ld a, '!' 
9c9d 77				ld (hl),a 
9c9e			 
9c9e 2a e7 e7			ld hl,(os_tok_ptr) 
9ca1			         
9ca1			if DEBUG_FORTH_TOK 
9ca1						DMARK "TK1" 
9ca1				CALLMONITOR 
9ca1			endif 
9ca1			 
9ca1				; push exec string to top of return stack 
9ca1				FORTH_RSP_NEXT 
9ca1 cd 55 98			call macro_forth_rsp_next 
9ca4				endm 
# End of macro FORTH_RSP_NEXT
9ca4 c9				ret 
9ca5			 
9ca5			; 
9ca5			;	; malloc size + buffer pointer + if is loop flag 
9ca5			;	ld hl,(os_tok_len) 		 ; get string length 
9ca5			; 
9ca5			;	ld a,l 
9ca5			; 
9ca5			;	cp 0			; we dont want to use a null string 
9ca5			;	ret z 
9ca5			; 
9ca5			;;	add 3    ; prefix malloc with buffer for current word ptr 
9ca5			; 
9ca5			;	add 5     ; TODO when certain not over writing memory remove 
9ca5			; 
9ca5			;		 
9ca5			; 
9ca5			;if DEBUG_FORTH_TOK 
9ca5			;			DMARK "TKE" 
9ca5			;	CALLMONITOR 
9ca5			;endif 
9ca5			; 
9ca5			;	ld l,a 
9ca5			;	ld h,0 
9ca5			;;	push hl   ; save required space for the copy later 
9ca5			;	call malloc 
9ca5			;if DEBUG_FORTH_TOK 
9ca5			;			DMARK "TKM" 
9ca5			;	CALLMONITOR 
9ca5			;endif 
9ca5			;	if DEBUG_FORTH_MALLOC_GUARD 
9ca5			;		push af 
9ca5			;		call ishlzero 
9ca5			;;		ld a, l 
9ca5			;;		add h 
9ca5			;;		cp 0 
9ca5			;		pop af 
9ca5			;		 
9ca5			;		call z,malloc_error 
9ca5			;	endif 
9ca5			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9ca5			; 
9ca5			; 
9ca5			;if DEBUG_FORTH_TOK 
9ca5			;			DMARK "TKR" 
9ca5			;	CALLMONITOR 
9ca5			;endif 
9ca5			; 
9ca5			;	FORTH_RSP_NEXT 
9ca5			; 
9ca5			;	;inc hl	 ; go past current buffer pointer 
9ca5			;	;inc hl 
9ca5			;	;inc hl   ; and past if loop flag 
9ca5			;		; TODO Need to set flag  
9ca5			; 
9ca5			;	 
9ca5			;	 
9ca5			;	ex de,hl	; malloc is dest 
9ca5			;	ld hl, (os_tok_len) 
9ca5			;;	pop bc 
9ca5			;	ld c, l                
9ca5			;	ld b,0 
9ca5			;	ld hl, (os_tok_ptr) 
9ca5			; 
9ca5			;if DEBUG_FORTH_TOK 
9ca5			;			DMARK "TKT" 
9ca5			;	CALLMONITOR 
9ca5			;endif 
9ca5			; 
9ca5			;	; do str cpy 
9ca5			; 
9ca5			;	ldir      ; copy byte in hl to de 
9ca5			; 
9ca5			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9ca5			; 
9ca5			;if DEBUG_FORTH_TOK 
9ca5			; 
9ca5			;			DMARK "TKY" 
9ca5			;	CALLMONITOR 
9ca5			;endif 
9ca5			;	;ld a,0 
9ca5			;	;ld a,FORTH_END_BUFFER 
9ca5			;	ex de, hl 
9ca5			;	;dec hl			 ; go back over the space delim at the end of word 
9ca5			;	;ld (hl),a 
9ca5			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9ca5			;	ld a,FORTH_END_BUFFER 
9ca5			;	ld (hl),a 
9ca5			;	inc hl 
9ca5			;	ld a,FORTH_END_BUFFER 
9ca5			;	ld (hl),a 
9ca5			; 
9ca5			;	; init the malloc area data 
9ca5			;	; set pc for in current area 
9ca5			;	;ld hl, (os_tok_malloc) 
9ca5			;	;inc hl 
9ca5			;	;inc hl 
9ca5			;	;inc hl 
9ca5			;	;ex de,hl 
9ca5			;	;ld hl, (os_tok_malloc) 
9ca5			;	;ld (hl),e 
9ca5			;	;inc hl 
9ca5			;	;ld (hl),d 
9ca5			; 
9ca5			; 
9ca5			;	ld hl,(os_tok_malloc) 
9ca5			;if DEBUG_FORTH_PARSE_KEY 
9ca5			;			DMARK "TKU" 
9ca5			;	CALLMONITOR 
9ca5			;endif 
9ca5			; 
9ca5			;	ret 
9ca5			 
9ca5			forthexec: 
9ca5			 
9ca5			; line exec: 
9ca5			; forth parser 
9ca5			 
9ca5			; 
9ca5			;       get current exec line on rsp 
9ca5			 
9ca5				FORTH_RSP_TOS 
9ca5 cd 6c 98			call macro_forth_rsp_tos 
9ca8				endm 
# End of macro FORTH_RSP_TOS
9ca8			 
9ca8			;       restore current pc - hl points to malloc of data 
9ca8			 
9ca8				;ld e, (hl) 
9ca8				;inc hl 
9ca8				;ld d, (hl) 
9ca8				;ex de,hl 
9ca8			 
9ca8			 
9ca8			exec1: 
9ca8 22 e7 e7			ld (os_tok_ptr), hl 
9cab			 
9cab				; copy our PC to working vars  
9cab 22 b1 ec			ld (cli_ptr), hl 
9cae 22 af ec			ld (cli_origptr), hl 
9cb1			 
9cb1 7e				ld a,(hl) 
9cb2 fe 7f			cp FORTH_END_BUFFER 
9cb4 c8				ret z 
9cb5			 
9cb5				; skip any nulls 
9cb5			 
9cb5 fe 00			cp 0 
9cb7 20 03			jr nz, .execword 
9cb9 23				inc hl 
9cba 18 ec			jr exec1 
9cbc			 
9cbc			 
9cbc			.execword: 
9cbc			 
9cbc			 
9cbc			 
9cbc			if DEBUG_FORTH_PARSE_KEY 
9cbc						DMARK "KYQ" 
9cbc				CALLMONITOR 
9cbc			endif 
9cbc			;       while at start of word: 
9cbc			; get start of dict (in user area first) 
9cbc			 
9cbc 21 33 d7		ld hl, baseram 
9cbf			;ld hl, sysdict 
9cbf 22 b3 ec		ld (cli_nextword),hl 
9cc2			;           match word at pc 
9cc2			;           exec word 
9cc2			;           or push to dsp 
9cc2			;           forward to next token 
9cc2			;           if line term pop rsp and exit 
9cc2			;        
9cc2			 
9cc2			if DEBUG_FORTH_PARSE_KEY 
9cc2						DMARK "KYq" 
9cc2				CALLMONITOR 
9cc2			endif 
9cc2			 
9cc2			; 
9cc2			; word comp 
9cc2			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9cc2			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9cc2			;    move to start of word  
9cc2			;    compare word to cli_token 
9cc2			 
9cc2			.execpnword:	; HL at start of a word in the dictionary to check 
9cc2			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9cc2			;	ld (cli_ptr), hl 
9cc2			 
9cc2 2a b3 ec			ld hl,(cli_nextword) 
9cc5			 
9cc5 cd 68 9d			call forth_tok_next 
9cc8			; tok next start here 
9cc8			;	; TODO skip compiled symbol for now 
9cc8			;	inc hl 
9cc8			; 
9cc8			;	; save pointer to next word 
9cc8			; 
9cc8			;	; hl now points to the address of the next word pointer  
9cc8			;	ld e, (hl) 
9cc8			;	inc hl 
9cc8			;	ld d, (hl) 
9cc8			;	inc l 
9cc8			; 
9cc8			;	ex de,hl 
9cc8			;if DEBUG_FORTH_PARSE_NEXTWORD 
9cc8			;	push bc 
9cc8			;	ld bc, (cli_nextword) 
9cc8			;			DMARK "NXW" 
9cc8			;	CALLMONITOR 
9cc8			;	pop bc 
9cc8			;endif 
9cc8			; tok next end here 
9cc8 22 b3 ec			ld (cli_nextword), hl     ; save for next check if no match on this word 
9ccb eb				ex de, hl 
9ccc			 
9ccc			 
9ccc				; save the pointer of the current token - 1 to check against 
9ccc				 
9ccc 22 b7 ec			ld (cli_token), hl   
9ccf				; TODO maybe remove below save if no debug 
9ccf				; save token string ptr for any debug later 
9ccf 23				inc hl  
9cd0 22 b9 ec			ld (cli_origtoken), hl 
9cd3 2b				dec hl 
9cd4				; save pointer to the start of the next dictionay word 
9cd4 7e				ld a,(hl)   ; get string length 
9cd5 47				ld b,a 
9cd6			.execpnwordinc:  
9cd6 23				inc hl 
9cd7 10 fd			djnz .execpnwordinc 
9cd9 22 b5 ec			ld (cli_execword), hl      ; save start of this words code 
9cdc			 
9cdc				; now check the word token against the string being parsed 
9cdc			 
9cdc 2a b7 ec			ld hl,(cli_token) 
9cdf 23				inc hl     ; skip string length (use zero term instead to end) 
9ce0 22 b7 ec			ld (cli_token), hl 
9ce3			 
9ce3			if DEBUG_FORTH_PARSE_KEY 
9ce3						DMARK "KY2" 
9ce3			endif 
9ce3			if DEBUG_FORTH_PARSE_EXEC 
9ce3				; see if disabled 
9ce3			 
9ce3				ld a, (os_view_disable) 
9ce3				cp '*' 
9ce3				jr z, .skip 
9ce3			 
9ce3				push hl 
9ce3				push hl 
9ce3				call clear_display 
9ce3				ld de, .compword 
9ce3				ld a, display_row_1 
9ce3				call str_at_display 
9ce3				pop de 
9ce3				ld a, display_row_2 
9ce3				call str_at_display 
9ce3				ld hl,(cli_ptr) 
9ce3				ld a,(hl) 
9ce3			        ld hl, os_word_scratch 
9ce3				ld (hl),a 
9ce3				ld a,0 
9ce3				inc hl 
9ce3				ld (hl),a 	 
9ce3				ld de, os_word_scratch 
9ce3				ld a, display_row_2+10 
9ce3				call str_at_display 
9ce3				call update_display 
9ce3				ld a, 100 
9ce3				call aDelayInMS 
9ce3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ce3				call delay250ms 
9ce3				endif 
9ce3				pop hl 
9ce3			.skip:  
9ce3			endif	 
9ce3			.execpnchar:    ; compare char between token and string to parse 
9ce3			 
9ce3			if DEBUG_FORTH_PARSE_KEY 
9ce3						DMARK "Ky3" 
9ce3			endif 
9ce3			if DEBUG_FORTH_PARSE_EXEC 
9ce3				; see if disabled 
9ce3			 
9ce3				ld a, (os_view_disable) 
9ce3				cp '*' 
9ce3				jr z, .skip2 
9ce3			 
9ce3			;	call clear_display 
9ce3			ld hl,(cli_token) 
9ce3			ld a,(hl) 
9ce3			ld (os_word_scratch),a 
9ce3				ld hl,(cli_ptr) 
9ce3			ld a,(hl) 
9ce3				ld (os_word_scratch+1),a 
9ce3				ld a,0 
9ce3				ld (os_word_scratch+2),a 
9ce3				ld de,os_word_scratch 
9ce3				ld a,display_row_4 
9ce3				call str_at_display 
9ce3				call update_display 
9ce3			.skip2:  
9ce3			endif 
9ce3 2a b7 ec			ld hl,(cli_token) 
9ce6 7e				ld a, (hl)	 ; char in word token 
9ce7 23				inc hl 		; move to next char 
9ce8 22 b7 ec			ld (cli_token), hl ; and save it 
9ceb 47				ld b,a 
9cec			 
9cec 2a b1 ec			ld hl,(cli_ptr) ;	get the char from the string to parse 
9cef 7e				ld a,(hl) 
9cf0 23				inc hl 
9cf1 22 b1 ec			ld (cli_ptr), hl		; move to next char 
9cf4 cd fc 8e			call toUpper 		; make sure the input string matches case 
9cf7			 
9cf7			if DEBUG_FORTH_PARSE 
9cf7			endif 
9cf7			 
9cf7				; input stream end of token is a space so get rid of it 
9cf7			 
9cf7			;	cp ' ' 
9cf7			;	jr nz, .pnskipspace 
9cf7			; 
9cf7			;	ld a, 0		; make same term as word token term 
9cf7			; 
9cf7			;.pnskipspace: 
9cf7			 
9cf7			if DEBUG_FORTH_PARSE_KEY 
9cf7						DMARK "KY7" 
9cf7			endif 
9cf7 b8				cp b 
9cf8 c2 0e 9d			jp nz, .execpnskipword	 ; no match so move to next word 
9cfb				 
9cfb			;    if same 
9cfb			;       scan for string terms 0 for token and 32 for input 
9cfb			 
9cfb				 
9cfb			if DEBUG_FORTH_PARSE_KEY 
9cfb						DMARK "KY8" 
9cfb			endif 
9cfb			 
9cfb 80				add b			 
9cfc fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9cfe							; TODO need to make sure last word in zero term string is accounted for 
9cfe 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9d00			 
9d00			 
9d00				; at end of both strings so both are exact match 
9d00			 
9d00			;       skip ptr for next word 
9d00			 
9d00 2a b1 ec			ld hl,(cli_ptr) 	; at input string term 
9d03 23				inc hl			 ; at next char 
9d04 22 b1 ec			ld (cli_ptr), hl     ; save for next round of the parser 
9d07 22 af ec			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9d0a				 
9d0a				 
9d0a			if DEBUG_FORTH_PARSE_KEY 
9d0a						DMARK "KY3" 
9d0a			endif 
9d0a			 
9d0a			 
9d0a			 
9d0a			;       exec code block 
9d0a			if DEBUG_FORTH_JP 
9d0a				call clear_display 
9d0a				call update_display 
9d0a				call delay1s 
9d0a				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d0a				ld a,h 
9d0a				ld hl, os_word_scratch 
9d0a				call hexout 
9d0a				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d0a				ld a,l 
9d0a				ld hl, os_word_scratch+2 
9d0a				call hexout 
9d0a				ld hl, os_word_scratch+4 
9d0a				ld a,0 
9d0a				ld (hl),a 
9d0a				ld de,os_word_scratch 
9d0a				call str_at_display 
9d0a					ld a, display_row_2 
9d0a					call str_at_display 
9d0a				ld de, (cli_origtoken) 
9d0a				ld a, display_row_1+10 
9d0a					call str_at_display 
9d0a			 
9d0a				ld a,display_row_1 
9d0a				ld de, .foundword 
9d0a				ld a, display_row_3 
9d0a				call str_at_display 
9d0a				call update_display 
9d0a				call delay1s 
9d0a				call delay1s 
9d0a				call delay1s 
9d0a			endif 
9d0a			 
9d0a			if DEBUG_FORTH_PARSE_KEY 
9d0a						DMARK "KYj" 
9d0a			endif 
9d0a				; TODO save the word pointer in this exec 
9d0a			 
9d0a 2a b5 ec			ld hl,(cli_execword) 
9d0d e9				jp (hl) 
9d0e			 
9d0e			 
9d0e			;    if not same 
9d0e			;	scan for zero term 
9d0e			;	get ptr for next word 
9d0e			;	goto word comp 
9d0e			 
9d0e			.execpnskipword:	; get pointer to next word 
9d0e 2a b3 ec			ld hl,(cli_nextword) 
9d11			 
9d11 7e				ld a,(hl) 
9d12 fe 00			cp WORD_SYS_END 
9d14			;	cp 0 
9d14 28 09			jr z, .execendofdict			 ; at end of words 
9d16			 
9d16			if DEBUG_FORTH_PARSE_KEY 
9d16						DMARK "KY4" 
9d16			endif 
9d16			if DEBUG_FORTH_PARSE_EXEC 
9d16			 
9d16				; see if disabled 
9d16			 
9d16				ld a, (os_view_disable) 
9d16				cp '*' 
9d16				jr z, .noskip 
9d16			 
9d16			 
9d16				ld de, .nowordfound 
9d16				ld a, display_row_3 
9d16				call str_at_display 
9d16				call update_display 
9d16				ld a, 100 
9d16				call aDelayInMS 
9d16				 
9d16				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d16					call delay250ms 
9d16				endif 
9d16			.noskip:  
9d16			 
9d16			endif	 
9d16			 
9d16 2a af ec			ld hl,(cli_origptr) 
9d19 22 b1 ec			ld (cli_ptr),hl 
9d1c			 
9d1c			if DEBUG_FORTH_PARSE_KEY 
9d1c						DMARK "KY5" 
9d1c			endif 
9d1c c3 c2 9c			jp .execpnword			; else go to next word 
9d1f			 
9d1f			.execendofdict:  
9d1f			 
9d1f			if DEBUG_FORTH_PARSE_KEY 
9d1f						DMARK "KYe" 
9d1f			endif 
9d1f			if DEBUG_FORTH_PARSE_EXEC 
9d1f				; see if disabled 
9d1f			 
9d1f				ld a, (os_view_disable) 
9d1f				cp '*' 
9d1f				jr z, .ispskip 
9d1f			 
9d1f				call clear_display 
9d1f				call update_display 
9d1f				call delay1s 
9d1f				ld de, (cli_origptr) 
9d1f				ld a, display_row_1 
9d1f				call str_at_display 
9d1f				 
9d1f				ld de, .enddict 
9d1f				ld a, display_row_3 
9d1f				call str_at_display 
9d1f				call update_display 
9d1f				ld a, 100 
9d1f				call aDelayInMS 
9d1f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d1f				call delay1s 
9d1f				call delay1s 
9d1f				call delay1s 
9d1f				endif 
9d1f			.ispskip:  
9d1f				 
9d1f			endif	 
9d1f			 
9d1f			 
9d1f			 
9d1f				; if the word is not a keyword then must be a literal so push it to stack 
9d1f			 
9d1f			; push token to stack to end of word 
9d1f			 
9d1f				STACKFRAME ON $1efe $2f9f 
9d1f				if DEBUG_STACK_IMB 
9d1f					if ON 
9d1f						exx 
9d1f						ld de, $1efe 
9d1f						ld a, d 
9d1f						ld hl, curframe 
9d1f						call hexout 
9d1f						ld a, e 
9d1f						ld hl, curframe+2 
9d1f						call hexout 
9d1f						ld hl, $1efe 
9d1f						push hl 
9d1f						ld hl, $2f9f 
9d1f						push hl 
9d1f						exx 
9d1f					endif 
9d1f				endif 
9d1f			endm 
# End of macro STACKFRAME
9d1f			 
9d1f 2a e7 e7		ld hl,(os_tok_ptr) 
9d22 cd 17 9a		call forth_apush 
9d25			 
9d25				STACKFRAMECHK ON $1efe $2f9f 
9d25				if DEBUG_STACK_IMB 
9d25					if ON 
9d25						exx 
9d25						ld hl, $2f9f 
9d25						pop de   ; $2f9f 
9d25						call cmp16 
9d25						jr nz, .spnosame 
9d25						ld hl, $1efe 
9d25						pop de   ; $1efe 
9d25						call cmp16 
9d25						jr z, .spfrsame 
9d25						.spnosame: call showsperror 
9d25						.spfrsame: nop 
9d25						exx 
9d25					endif 
9d25				endif 
9d25			endm 
# End of macro STACKFRAMECHK
9d25			 
9d25			execnext: 
9d25			 
9d25			if DEBUG_FORTH_PARSE_KEY 
9d25						DMARK "KY>" 
9d25			endif 
9d25			; move past token to next word 
9d25			 
9d25 2a e7 e7		ld hl, (os_tok_ptr) 
9d28 3e 00		ld a, 0 
9d2a 01 ff 00		ld bc, 255     ; input buffer size 
9d2d ed b1		cpir 
9d2f			 
9d2f			if DEBUG_FORTH_PARSE_KEY 
9d2f						DMARK "KY!" 
9d2f				CALLMONITOR 
9d2f			endif	 
9d2f			; TODO this might place hl on the null, so will need to forward on??? 
9d2f			;inc hl   ; see if this gets onto the next item 
9d2f			 
9d2f			 
9d2f			; TODO pass a pointer to the buffer to push 
9d2f			; TODO call function to push 
9d2f			 
9d2f			; look for end of input 
9d2f			 
9d2f			;inc hl 
9d2f			;ld a,(hl) 
9d2f			;cp FORTH_END_BUFFER 
9d2f			;ret z 
9d2f			 
9d2f			 
9d2f c3 a8 9c		jp exec1 
9d32			 
9d32			 
9d32			 
9d32			 
9d32			 
9d32			 
9d32			 
9d32			 
9d32			 
9d32			findnexttok: 
9d32			 
9d32				; hl is pointer to move 
9d32				; de is the token to locate 
9d32			 
9d32					if DEBUG_FORTH 
9d32						DMARK "NTK" 
9d32						CALLMONITOR 
9d32					endif 
9d32 d5				push de 
9d33			 
9d33			.fnt1:	 
9d33				; find first char of token to locate 
9d33			 
9d33 1a				ld a, (de) 
9d34 4f				ld c,a 
9d35 7e				ld a,(hl) 
9d36 cd fc 8e			call toUpper 
9d39					if DEBUG_FORTH 
9d39						DMARK "NT1" 
9d39						CALLMONITOR 
9d39					endif 
9d39 b9				cp c 
9d3a			 
9d3a 28 03			jr z, .fnt2cmpmorefirst	 
9d3c			 
9d3c				; first char not found move to next char 
9d3c			 
9d3c 23				inc hl 
9d3d 18 f4			jr .fnt1 
9d3f			 
9d3f			.fnt2cmpmorefirst:	 
9d3f				; first char of token found.  
9d3f			 
9d3f e5				push hl     ; save start of token just in case it is the right one 
9d40 d9				exx 
9d41 e1				pop hl        ; save it to hl' 
9d42 d9				exx 
9d43			 
9d43			 
9d43			.fnt2cmpmore:	 
9d43				; compare the rest 
9d43				 
9d43 23				inc hl 
9d44 13				inc de 
9d45				 
9d45 1a				ld a, (de) 
9d46 4f				ld c,a 
9d47 7e				ld a,(hl) 
9d48 cd fc 8e			call toUpper 
9d4b			 
9d4b					if DEBUG_FORTH 
9d4b						DMARK "NT2" 
9d4b						CALLMONITOR 
9d4b					endif 
9d4b				; c has the token to find char 
9d4b				; a has the mem to scan char 
9d4b			 
9d4b b9				cp c 
9d4c 28 04			jr z,.fntmatch1 
9d4e			 
9d4e				; they are not the same 
9d4e			 
9d4e					if DEBUG_FORTH 
9d4e						DMARK "NT3" 
9d4e						CALLMONITOR 
9d4e					endif 
9d4e d1				pop de	; reset de token to look for 
9d4f d5				push de 
9d50 18 e1			jr .fnt1 
9d52				 
9d52			.fntmatch1: 
9d52			 
9d52				; is the same char a null which means we might have a full hit? 
9d52					if DEBUG_FORTH 
9d52						DMARK "NT4" 
9d52						CALLMONITOR 
9d52					endif 
9d52			 
9d52 fe 00			cp 0 
9d54 28 0b			jr z, .fntmatchyes 
9d56			 
9d56				; are we at the end of the token to find? 
9d56			 
9d56					if DEBUG_FORTH 
9d56						DMARK "NT5" 
9d56						CALLMONITOR 
9d56					endif 
9d56 3e 00			ld a, 0 
9d58 b9				cp c 
9d59			 
9d59 c2 43 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9d5c			 
9d5c					if DEBUG_FORTH 
9d5c						DMARK "NT6" 
9d5c						CALLMONITOR 
9d5c					endif 
9d5c				; token to find is exhusted but no match to stream 
9d5c			 
9d5c				; restore tok pointer and continue on 
9d5c d1				pop de 
9d5d d5				push de 
9d5e c3 33 9d			jp .fnt1 
9d61			 
9d61			 
9d61			.fntmatchyes: 
9d61			 
9d61				; hl now contains the end of the found token 
9d61			 
9d61				; get rid of saved token pointer to find 
9d61			 
9d61 d1				pop de 
9d62			 
9d62					if DEBUG_FORTH 
9d62						DMARK "NT9" 
9d62						CALLMONITOR 
9d62					endif 
9d62			 
9d62				; hl will be on the null term so forward on 
9d62			 
9d62				; get back the saved start of the token 
9d62			 
9d62 d9				exx 
9d63 e5				push hl     ; save start of token just in case it is the right one 
9d64 d9				exx 
9d65 e1				pop hl        ; save it to hl 
9d66			 
9d66 c9				ret 
9d67			 
9d67			 
9d67			; LIST needs to find a specific token   
9d67			; FORGET needs to find a spefici token 
9d67			 
9d67			; SAVE needs to find all tokens by flag 
9d67			; WORDS just needs to scan through all  by flag 
9d67			; UWORDS needs to scan through all by flag 
9d67			 
9d67			 
9d67			; given hl as pointer to start of dict look up string 
9d67			; return hl as pointer to start of word block 
9d67			; or 0 if not found 
9d67			 
9d67			forth_find_tok: 
9d67 c9				ret 
9d68			 
9d68			; given hl as pointer to dict structure 
9d68			; move to the next dict block structure 
9d68			 
9d68			forth_tok_next: 
9d68				; hl now points to the address of the next word pointer  
9d68				; TODO skip compiled symbol for now 
9d68			;	push de 
9d68 23				inc hl 
9d69 5e				ld e, (hl) 
9d6a 23				inc hl 
9d6b 56				ld d, (hl) 
9d6c 23				inc hl 
9d6d			 
9d6d eb				ex de,hl 
9d6e			if DEBUG_FORTH_PARSE_NEXTWORD 
9d6e				push bc 
9d6e				ld bc, (cli_nextword) 
9d6e						DMARK "NXW" 
9d6e				CALLMONITOR 
9d6e				pop bc 
9d6e			endif 
9d6e			;	pop de	 
9d6e c9				ret 
9d6f			 
9d6f			 
9d6f			 
9d6f			; eof 
# End of file forth_parserv5.asm
9d6f				include "forth_wordsv4.asm" 
9d6f			 
9d6f			; the core word dictionary v4 
9d6f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9d6f			 
9d6f			; this is a linked list for each of the system words used 
9d6f			; user defined words will follow the same format but will be in ram 
9d6f			 
9d6f			 
9d6f			; 
9d6f			; 
9d6f			; define linked list: 
9d6f			; 
9d6f			; 1. compiled byte op code 
9d6f			; 2. len of text word 
9d6f			; 3. text word 
9d6f			; 4. ptr to next dictionary word 
9d6f			; 5. asm, calls etc for the word 
9d6f			; 
9d6f			;  if 1 == 0 then last word in dict  
9d6f			;   
9d6f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9d6f			;  
9d6f			;  
9d6f			; create basic standard set of words 
9d6f			; 
9d6f			;  
9d6f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9d6f			; 2DUP 2DROP 2SWAP  
9d6f			; @ C@ - get byte  
9d6f			; ! C! - store byte 
9d6f			; 0< true if less than zero 
9d6f			; 0= true if zero 
9d6f			; < >  
9d6f			; = true if same 
9d6f			; variables 
9d6f			 
9d6f			 
9d6f			; Hardware specific words I may need 
9d6f			; 
9d6f			; IN OUT  
9d6f			; calls to key util functions 
9d6f			; calls to hardward abstraction stuff 
9d6f			; easy control of frame buffers and lcd i/o 
9d6f			; keyboard  
9d6f			 
9d6f			 
9d6f			;DICT: macro 
9d6f			; op_code, len, word, next 
9d6f			;    word: 
9d6f			;    db op_code 
9d6f			;    ds word zero term 
9d6f			;    dw next 
9d6f			;    endm 
9d6f			 
9d6f			 
9d6f			 
9d6f			 
9d6f			; op code 1 is a flag for user define words which are to be handled differently 
9d6f			 
9d6f			 
9d6f			; 
9d6f			; 
9d6f			;    TODO on entry to a word this should be the expected environment 
9d6f			;    hl - tos value if number then held, if string this is the ptr 
9d6f			;    de -  
9d6f			 
9d6f			 
9d6f			; opcode ranges 
9d6f			; 0 - end of word dict 
9d6f			; 255 - user define words 
9d6f			 
9d6f			sysdict: 
9d6f			include "forth_opcodes.asm" 
9d6f			; op codes for forth keywords 
9d6f			; free to use code 0  
9d6f				OPCODE_HEAP: equ  1 
9d6f				OPCODE_EXEC: equ 2 
9d6f				OPCODE_DUP: equ 3 
9d6f				OPCODE_SWAP: equ 4 
9d6f				OPCODE_COLN: equ 5 
9d6f				OPCODE_SCOLN: equ 6 
9d6f				OPCODE_DROP: equ 7 
9d6f				OPCODE_DUP2: equ 8 
9d6f				OPCODE_DROP2: equ 9 
9d6f				OPCODE_SWAP2: equ 10 
9d6f				OPCODE_AT: equ 11 
9d6f				OPCODE_CAT: equ 12 
9d6f				OPCODE_BANG: equ 13 
9d6f				OPCODE_CBANG: equ 14 
9d6f				OPCODE_SCALL: equ 15 
9d6f				OPCODE_DEPTH: equ 16 
9d6f				OPCODE_OVER: equ 17 
9d6f				OPCODE_PAUSE: equ 18 
9d6f				OPCODE_PAUSES: equ 19 
9d6f				OPCODE_ROT: equ 20 
9d6f			;free to reuse	OPCODE_WORDS: equ 21 
9d6f			        OPCODE_NOT: equ 21 
9d6f				OPCODE_UWORDS: equ 22 
9d6f				OPCODE_BP: equ 23 
9d6f				OPCODE_MONITOR: equ 24  
9d6f				OPCODE_MALLOC: equ 25 
9d6f				OPCODE_FREE: equ 26 
9d6f				OPCODE_LIST: equ 27 
9d6f				OPCODE_FORGET: equ 28 
9d6f				OPCODE_NOP: equ 29 
9d6f				OPCODE_COMO: equ 30 
9d6f				OPCODE_COMC: equ 31 
9d6f			;free to reuse	OPCODE_ENDCORE: equ 32 
9d6f				OPCODE_AFTERSOUND: equ 33 
9d6f				OPCODE_GP2: equ 34 
9d6f				OPCODE_GP3: equ 35 
9d6f				OPCODE_GP4: equ 36 
9d6f				OPCODE_SIN: equ 37 
9d6f				OPCODE_SOUT: equ 38 
9d6f				OPCODE_SPIO: equ 39 
9d6f				OPCODE_SPICEH: equ 40 
9d6f				OPCODE_SPIOb: equ 41 
9d6f				OPCODE_SPII: equ 42 
9d6f				OPCODE_SESEL: equ 43 
9d6f				OPCODE_CARTDEV: equ 44 
9d6f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9d6f				OPCODE_FB: equ 46 
9d6f				OPCODE_EMIT: equ 47 
9d6f				OPCODE_DOTH: equ 48 
9d6f				OPCODE_DOTF: equ 49 
9d6f				OPCODE_DOT: equ 50 
9d6f				OPCODE_CLS: equ 51 
9d6f				OPCODE_DRAW: equ 52 
9d6f				OPCODE_DUMP: equ 53 
9d6f				OPCODE_CDUMP: equ 54 
9d6f				OPCODE_DAT: equ 55 
9d6f				OPCODE_HOME: equ 56 
9d6f				OPCODE_SPACE: equ 57 
9d6f				OPCODE_SPACES: equ 58 
9d6f				OPCODE_SCROLL: equ 59 
9d6f				OPCODE_ATQ: equ 60 
9d6f				OPCODE_AUTODSP: equ 61 
9d6f				OPCODE_MENU: equ 62 
9d6f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9d6f				OPCODE_THEN: equ 64 
9d6f				OPCODE_ELSE: equ 65 
9d6f				OPCODE_DO: equ 66 
9d6f				OPCODE_LOOP: equ 67 
9d6f				OPCODE_I: equ 68 
9d6f				OPCODE_DLOOP: equ 69  
9d6f				OPCODE_REPEAT: equ 70  
9d6f				OPCODE_UNTIL: equ 71 
9d6f				OPCODE_ENDFLOW: equ 72 
9d6f				OPCODE_WAITK: equ 73 
9d6f				OPCODE_ACCEPT: equ 74 
9d6f				OPCODE_EDIT: equ 75 
9d6f			;free to reuse	OPCODE_ENDKEY: equ 76 
9d6f				OPCODE_LZERO: equ 77 
9d6f				OPCODE_TZERO: equ 78 
9d6f				OPCODE_LESS: equ 79 
9d6f				OPCODE_GT: equ 80 
9d6f				OPCODE_EQUAL: equ 81  
9d6f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9d6f				OPCODE_NEG: equ 83 
9d6f				OPCODE_DIV: equ 84 
9d6f				OPCODE_MUL: equ 85 
9d6f				OPCODE_MIN: equ 86 
9d6f				OPCODE_MAX: equ 87 
9d6f				OPCODE_RND16: equ 88 
9d6f				OPCODE_RND8: equ 89 
9d6f				OPCODE_RND: equ 90 
9d6f			;free to reuse	OPCODE_ENDMATHS: equ 91  
9d6f				OPCODE_BYNAME: equ 92 
9d6f				OPCODE_DIR: equ 93 
9d6f				OPCODE_SAVE: equ 94 
9d6f				OPCODE_LOAD: equ 95 
9d6f				OPCODE_BSAVE: equ 96 
9d6f				OPCODE_BLOAD: equ 97 
9d6f				OPCODE_SEO: equ 98  
9d6f				OPCODE_SEI: equ 99 
9d6f				OPCODE_SFREE: equ 100 
9d6f				OPCODE_SIZE: equ 101 
9d6f				OPCODE_CREATE: equ 102 
9d6f				OPCODE_APPEND: equ 103 
9d6f				OPCODE_SDEL: equ 104 
9d6f				OPCODE_OPEN: equ 105 
9d6f				OPCODE_READ: equ 106 
9d6f				OPCODE_EOF: equ 106 
9d6f				OPCODE_FORMAT: equ 107 
9d6f				OPCODE_LABEL: equ 108 
9d6f				OPCODE_LABELS: equ 109 
9d6f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9d6f				OPCODE_UPPER: equ 111 
9d6f				OPCODE_LOWER: equ 112 
9d6f				OPCODE_SUBSTR: equ 113 
9d6f				OPCODE_LEFT: equ 114 
9d6f				OPCODE_RIGHT: equ 115 
9d6f				OPCODE_STR2NUM: equ 116 
9d6f				OPCODE_NUM2STR: equ 117 
9d6f				OPCODE_CONCAT: equ 118 
9d6f				OPCODE_FIND: equ 119 
9d6f				OPCODE_LEN: equ 120 
9d6f				OPCODE_CHAR: equ 121 
9d6f			; free to reuse	OPCODE_STRLEN: equ 122 
9d6f			; free to reuse	OPCODE_ENDSTR: equ 123 
9d6f				OPCODE_V0S: equ 124 
9d6f				OPCODE_V0Q: equ 125 
9d6f				OPCODE_V1S: equ 126 
9d6f				OPCODE_V1Q: equ 127 
9d6f				OPCODE_V2S: equ 128 
9d6f				OPCODE_V2Q: equ 129 
9d6f				OPCODE_V3S: equ 130 
9d6f				OPCODE_V3Q: equ 131 
9d6f			;free to reuse	OPCODE_END: equ 132 
9d6f				OPCODE_ZDUP: equ 133 
9d6f			 
9d6f			; eof 
# End of file forth_opcodes.asm
9d6f			 
9d6f			include "forth_words_core.asm" 
9d6f			 
9d6f			; | ## Core Words 
9d6f			 
9d6f			;if MALLOC_4 
9d6f			 
9d6f			.HEAP: 
9d6f				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9d6f 15				db WORD_SYS_CORE+OPCODE_HEAP             
9d70 ae 9d			dw .EXEC            
9d72 05				db 4 + 1 
9d73 .. 00			db "HEAP",0              
9d78				endm 
# End of macro CWHEAD
9d78			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9d78			; | | u1 - Current number of bytes in the heap 
9d78			; | | u2 - Remaining bytes left on the heap 
9d78			; | |  
9d78			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9d78			 
9d78			 
9d78					if DEBUG_FORTH_WORDS_KEY 
9d78						DMARK "HEP" 
9d78 f5				push af  
9d79 3a 8d 9d			ld a, (.dmark)  
9d7c 32 c0 ee			ld (debug_mark),a  
9d7f 3a 8e 9d			ld a, (.dmark+1)  
9d82 32 c1 ee			ld (debug_mark+1),a  
9d85 3a 8f 9d			ld a, (.dmark+2)  
9d88 32 c2 ee			ld (debug_mark+2),a  
9d8b 18 03			jr .pastdmark  
9d8d ..			.dmark: db "HEP"  
9d90 f1			.pastdmark: pop af  
9d91			endm  
# End of macro DMARK
9d91						CALLMONITOR 
9d91 cd 21 93			call break_point_state  
9d94				endm  
# End of macro CALLMONITOR
9d94					endif 
9d94 2a 3d d7				ld hl, (free_list )      
9d97 11 42 d7				ld de, heap_start 
9d9a			 
9d9a ed 52				sbc hl, de  
9d9c			 
9d9c cd ae 98				call forth_push_numhl 
9d9f			 
9d9f			 
9d9f ed 5b 3d d7			ld de, (free_list )      
9da3 21 cc e4				ld hl, heap_end 
9da6			 
9da6 ed 52				sbc hl, de 
9da8			 
9da8 cd ae 98				call forth_push_numhl 
9dab					 
9dab			 
9dab					 
9dab			 
9dab			 
9dab			 
9dab					NEXTW 
9dab c3 17 9c			jp macro_next 
9dae				endm 
# End of macro NEXTW
9dae			;endif 
9dae			 
9dae			.EXEC: 
9dae			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9dae			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9dae			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9dae			;; > > 
9dae			;; > >   
9dae			;	STACKFRAME OFF $5efe $5f9f 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS_KEY 
9dae			;			DMARK "EXE" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			; 
9dae			;	FORTH_DSP_VALUEHL 
9dae			; 
9dae			;	FORTH_DSP_POP 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EX1" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;;	ld e,(hl) 
9dae			;;	inc hl 
9dae			;;	ld d,(hl) 
9dae			;;	ex de,hl 
9dae			; 
9dae			;;		if DEBUG_FORTH_WORDS 
9dae			;;			DMARK "EX2" 
9dae			;;			CALLMONITOR 
9dae			;;		endif 
9dae			;	push hl 
9dae			; 
9dae			;	;ld a, 0 
9dae			;	;ld a, FORTH_END_BUFFER 
9dae			;	call strlenz 
9dae			;	inc hl   ; include zero term to copy 
9dae			;	inc hl   ; include term 
9dae			;	inc hl   ; include term 
9dae			;	ld b,0 
9dae			;	ld c,l 
9dae			;	pop hl 
9dae			;	ld de, execscratch 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EX3" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;	ldir 
9dae			; 
9dae			; 
9dae			;	ld hl, execscratch 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EXe" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			; 
9dae			;	call forthparse 
9dae			;	call forthexec 
9dae			;;	call forthexec_cleanup 
9dae			;;	call forthparse 
9dae			;;	call forthexec 
9dae			; 
9dae			;	STACKFRAMECHK OFF $5efe $5f9f 
9dae			; 
9dae			;	; an immediate word so no need to process any more words 
9dae			;	ret 
9dae			;	NEXTW 
9dae			 
9dae			; dead code - old version  
9dae			;	FORTH_RSP_NEXT 
9dae			 
9dae			;  
9dae			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9dae			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9dae			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9dae			;	push hl 
9dae			;	push de 
9dae			;	push bc 
9dae			; 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS_KEY 
9dae			;			DMARK "EXR" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			; 
9dae			; 
9dae			; 
9dae			;	;v5 FORTH_DSP_VALUE 
9dae			;	FORTH_DSP_VALUEHL 
9dae			; 
9dae			;	; TODO do string type checks 
9dae			; 
9dae			;;v5	inc hl   ; skip type 
9dae			; 
9dae			;	push hl  ; source code  
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EX1" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;	ld a, 0 
9dae			;	call strlent 
9dae			; 
9dae			;	inc hl 
9dae			;	inc hl 
9dae			;	inc hl 
9dae			;	inc hl 
9dae			; 
9dae			;	push hl    ; size 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EX2" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;	call malloc 
9dae			; 
9dae			;	ex de, hl    ; de now contains malloc area 
9dae			;	pop bc   	; get byte count 
9dae			;	pop hl      ; get string to copy 
9dae			; 
9dae			;	push de     ; save malloc for free later 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EX3" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;	ldir       ; duplicate string 
9dae			; 
9dae			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9dae			;	 
9dae			;	; TODO fix the parse would be better than this...  
9dae			;	ex de, hl 
9dae			;	dec hl 
9dae			;	ld a, 0 
9dae			;	ld (hl), a 
9dae			;	dec hl 
9dae			;	ld a, ' ' 
9dae			;	ld (hl), a 
9dae			;	dec hl 
9dae			;	ld (hl), a 
9dae			; 
9dae			;	dec hl 
9dae			;	ld (hl), a 
9dae			; 
9dae			; 
9dae			;	FORTH_DSP_POP  
9dae			; 
9dae			;	pop hl     
9dae			;	push hl    ; save malloc area 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EX4" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			; 
9dae			;	call forthparse 
9dae			;	call forthexec 
9dae			;	 
9dae			;	pop hl 
9dae			;	if DEBUG_FORTH_WORDS 
9dae			;		DMARK "EX5" 
9dae			;		CALLMONITOR 
9dae			;	endif 
9dae			; 
9dae			;	if FORTH_ENABLE_FREE 
9dae			;	call free 
9dae			;	endif 
9dae			; 
9dae			;	if DEBUG_FORTH_WORDS 
9dae			;		DMARK "EX6" 
9dae			;		CALLMONITOR 
9dae			;	endif 
9dae			; 
9dae			;	pop bc 
9dae			;	pop de 
9dae			;	pop hl 
9dae			;;	FORTH_RSP_POP	  
9dae			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9dae			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9dae			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9dae			; 
9dae			;	if DEBUG_FORTH_WORDS 
9dae			;		DMARK "EX7" 
9dae			;		CALLMONITOR 
9dae			;	endif 
9dae			;	NEXTW 
9dae			 
9dae			;.STKEXEC: 
9dae			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9dae			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9dae			; 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS_KEY 
9dae			;			DMARK "STX" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			; 
9dae			;	FORTH_DSP_VALUEHL 
9dae			; 
9dae			;	ld (store_tmp1), hl    ; count 
9dae			; 
9dae			;	FORTH_DSP_POP 
9dae			;.stkexec1: 
9dae			;	ld hl, (store_tmp1)   ; count 
9dae			;	ld a, 0 
9dae			;	cp l 
9dae			;	ret z 
9dae			; 
9dae			;	dec hl 
9dae			;	ld (store_tmp1), hl    ; count 
9dae			;	 
9dae			;	FORTH_DSP_VALUEHL 
9dae			;	push hl 
9dae			;	 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EXp" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;	FORTH_DSP_POP 
9dae			; 
9dae			;	call strlenz 
9dae			;	inc hl   ; include zero term to copy 
9dae			;	inc hl   ; include zero term to copy 
9dae			;	inc hl   ; include zero term to copy 
9dae			;	ld b,0 
9dae			;	ld c,l 
9dae			;	pop hl 
9dae			;	ld de, execscratch 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EX3" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;	ldir 
9dae			; 
9dae			; 
9dae			;	ld hl, execscratch 
9dae			; 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EXP" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			; 
9dae			;	call forthparse 
9dae			;	ld hl, execscratch 
9dae			;		if DEBUG_FORTH_WORDS 
9dae			;			DMARK "EXx" 
9dae			;			CALLMONITOR 
9dae			;		endif 
9dae			;	call forthexec 
9dae			; 
9dae			;	jp .stkexec1 
9dae			; 
9dae			;	ret 
9dae			 
9dae			 
9dae			.DUP: 
9dae				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9dae 17				db WORD_SYS_CORE+OPCODE_DUP             
9daf 24 9e			dw .ZDUP            
9db1 04				db 3 + 1 
9db2 .. 00			db "DUP",0              
9db6				endm 
# End of macro CWHEAD
9db6			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9db6			 
9db6					if DEBUG_FORTH_WORDS_KEY 
9db6						DMARK "DUP" 
9db6 f5				push af  
9db7 3a cb 9d			ld a, (.dmark)  
9dba 32 c0 ee			ld (debug_mark),a  
9dbd 3a cc 9d			ld a, (.dmark+1)  
9dc0 32 c1 ee			ld (debug_mark+1),a  
9dc3 3a cd 9d			ld a, (.dmark+2)  
9dc6 32 c2 ee			ld (debug_mark+2),a  
9dc9 18 03			jr .pastdmark  
9dcb ..			.dmark: db "DUP"  
9dce f1			.pastdmark: pop af  
9dcf			endm  
# End of macro DMARK
9dcf						CALLMONITOR 
9dcf cd 21 93			call break_point_state  
9dd2				endm  
# End of macro CALLMONITOR
9dd2					endif 
9dd2			 
9dd2					FORTH_DSP 
9dd2 cd 6b 9a			call macro_forth_dsp 
9dd5				endm 
# End of macro FORTH_DSP
9dd5			 
9dd5 7e					ld a, (HL) 
9dd6 fe 01				cp DS_TYPE_STR 
9dd8 20 25				jr nz, .dupinum 
9dda			 
9dda					; push another string 
9dda			 
9dda					FORTH_DSP_VALUEHL     		 
9dda cd a5 9a			call macro_dsp_valuehl 
9ddd				endm 
# End of macro FORTH_DSP_VALUEHL
9ddd			 
9ddd				if DEBUG_FORTH_WORDS 
9ddd					DMARK "DUs" 
9ddd f5				push af  
9dde 3a f2 9d			ld a, (.dmark)  
9de1 32 c0 ee			ld (debug_mark),a  
9de4 3a f3 9d			ld a, (.dmark+1)  
9de7 32 c1 ee			ld (debug_mark+1),a  
9dea 3a f4 9d			ld a, (.dmark+2)  
9ded 32 c2 ee			ld (debug_mark+2),a  
9df0 18 03			jr .pastdmark  
9df2 ..			.dmark: db "DUs"  
9df5 f1			.pastdmark: pop af  
9df6			endm  
# End of macro DMARK
9df6					CALLMONITOR 
9df6 cd 21 93			call break_point_state  
9df9				endm  
# End of macro CALLMONITOR
9df9				endif 
9df9 cd 1c 99				call forth_push_str 
9dfc			 
9dfc					NEXTW 
9dfc c3 17 9c			jp macro_next 
9dff				endm 
# End of macro NEXTW
9dff			 
9dff			 
9dff			.dupinum: 
9dff					 
9dff			 
9dff			 
9dff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9dff cd a5 9a			call macro_dsp_valuehl 
9e02				endm 
# End of macro FORTH_DSP_VALUEHL
9e02			 
9e02				; TODO add floating point number detection 
9e02			 
9e02				if DEBUG_FORTH_WORDS 
9e02					DMARK "DUi" 
9e02 f5				push af  
9e03 3a 17 9e			ld a, (.dmark)  
9e06 32 c0 ee			ld (debug_mark),a  
9e09 3a 18 9e			ld a, (.dmark+1)  
9e0c 32 c1 ee			ld (debug_mark+1),a  
9e0f 3a 19 9e			ld a, (.dmark+2)  
9e12 32 c2 ee			ld (debug_mark+2),a  
9e15 18 03			jr .pastdmark  
9e17 ..			.dmark: db "DUi"  
9e1a f1			.pastdmark: pop af  
9e1b			endm  
# End of macro DMARK
9e1b					CALLMONITOR 
9e1b cd 21 93			call break_point_state  
9e1e				endm  
# End of macro CALLMONITOR
9e1e				endif 
9e1e			 
9e1e cd ae 98				call forth_push_numhl 
9e21					NEXTW 
9e21 c3 17 9c			jp macro_next 
9e24				endm 
# End of macro NEXTW
9e24			.ZDUP: 
9e24				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9e24 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9e25 5c 9e			dw .SWAP            
9e27 05				db 4 + 1 
9e28 .. 00			db "?DUP",0              
9e2d				endm 
# End of macro CWHEAD
9e2d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9e2d			 
9e2d					if DEBUG_FORTH_WORDS_KEY 
9e2d						DMARK "qDU" 
9e2d f5				push af  
9e2e 3a 42 9e			ld a, (.dmark)  
9e31 32 c0 ee			ld (debug_mark),a  
9e34 3a 43 9e			ld a, (.dmark+1)  
9e37 32 c1 ee			ld (debug_mark+1),a  
9e3a 3a 44 9e			ld a, (.dmark+2)  
9e3d 32 c2 ee			ld (debug_mark+2),a  
9e40 18 03			jr .pastdmark  
9e42 ..			.dmark: db "qDU"  
9e45 f1			.pastdmark: pop af  
9e46			endm  
# End of macro DMARK
9e46						CALLMONITOR 
9e46 cd 21 93			call break_point_state  
9e49				endm  
# End of macro CALLMONITOR
9e49					endif 
9e49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e49 cd a5 9a			call macro_dsp_valuehl 
9e4c				endm 
# End of macro FORTH_DSP_VALUEHL
9e4c			 
9e4c e5					push hl 
9e4d			 
9e4d					; is it a zero? 
9e4d			 
9e4d 3e 00				ld a, 0 
9e4f 84					add h 
9e50 85					add l 
9e51			 
9e51 e1					pop hl 
9e52			 
9e52 fe 00				cp 0 
9e54 28 03				jr z, .dup2orig 
9e56			 
9e56			 
9e56 cd ae 98				call forth_push_numhl 
9e59			 
9e59			 
9e59				; TODO add floating point number detection 
9e59			 
9e59			.dup2orig: 
9e59			 
9e59					NEXTW 
9e59 c3 17 9c			jp macro_next 
9e5c				endm 
# End of macro NEXTW
9e5c			.SWAP: 
9e5c				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9e5c 18				db WORD_SYS_CORE+OPCODE_SWAP             
9e5d 9b 9e			dw .COLN            
9e5f 05				db 4 + 1 
9e60 .. 00			db "SWAP",0              
9e65				endm 
# End of macro CWHEAD
9e65			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9e65					if DEBUG_FORTH_WORDS_KEY 
9e65						DMARK "SWP" 
9e65 f5				push af  
9e66 3a 7a 9e			ld a, (.dmark)  
9e69 32 c0 ee			ld (debug_mark),a  
9e6c 3a 7b 9e			ld a, (.dmark+1)  
9e6f 32 c1 ee			ld (debug_mark+1),a  
9e72 3a 7c 9e			ld a, (.dmark+2)  
9e75 32 c2 ee			ld (debug_mark+2),a  
9e78 18 03			jr .pastdmark  
9e7a ..			.dmark: db "SWP"  
9e7d f1			.pastdmark: pop af  
9e7e			endm  
# End of macro DMARK
9e7e						CALLMONITOR 
9e7e cd 21 93			call break_point_state  
9e81				endm  
# End of macro CALLMONITOR
9e81					endif 
9e81			 
9e81					FORTH_DSP_VALUEHL 
9e81 cd a5 9a			call macro_dsp_valuehl 
9e84				endm 
# End of macro FORTH_DSP_VALUEHL
9e84 e5					push hl     ; w2 
9e85			 
9e85					FORTH_DSP_POP 
9e85 cd 5d 9b			call macro_forth_dsp_pop 
9e88				endm 
# End of macro FORTH_DSP_POP
9e88			 
9e88					FORTH_DSP_VALUEHL 
9e88 cd a5 9a			call macro_dsp_valuehl 
9e8b				endm 
# End of macro FORTH_DSP_VALUEHL
9e8b			 
9e8b					FORTH_DSP_POP 
9e8b cd 5d 9b			call macro_forth_dsp_pop 
9e8e				endm 
# End of macro FORTH_DSP_POP
9e8e			 
9e8e d1					pop de     ; w2	, hl = w1 
9e8f			 
9e8f eb					ex de, hl 
9e90 d5					push de 
9e91			 
9e91 cd ae 98				call forth_push_numhl 
9e94			 
9e94 e1					pop hl 
9e95			 
9e95 cd ae 98				call forth_push_numhl 
9e98					 
9e98			 
9e98					NEXTW 
9e98 c3 17 9c			jp macro_next 
9e9b				endm 
# End of macro NEXTW
9e9b			.COLN: 
9e9b				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9e9b 19				db WORD_SYS_CORE+OPCODE_COLN             
9e9c 27 a0			dw .SCOLN            
9e9e 02				db 1 + 1 
9e9f .. 00			db ":",0              
9ea1				endm 
# End of macro CWHEAD
9ea1			; | : ( -- )         Create new word | DONE 
9ea1			 
9ea1					if DEBUG_FORTH_WORDS_KEY 
9ea1						DMARK "CLN" 
9ea1 f5				push af  
9ea2 3a b6 9e			ld a, (.dmark)  
9ea5 32 c0 ee			ld (debug_mark),a  
9ea8 3a b7 9e			ld a, (.dmark+1)  
9eab 32 c1 ee			ld (debug_mark+1),a  
9eae 3a b8 9e			ld a, (.dmark+2)  
9eb1 32 c2 ee			ld (debug_mark+2),a  
9eb4 18 03			jr .pastdmark  
9eb6 ..			.dmark: db "CLN"  
9eb9 f1			.pastdmark: pop af  
9eba			endm  
# End of macro DMARK
9eba						CALLMONITOR 
9eba cd 21 93			call break_point_state  
9ebd				endm  
# End of macro CALLMONITOR
9ebd					endif 
9ebd				STACKFRAME OFF $8efe $989f 
9ebd				if DEBUG_STACK_IMB 
9ebd					if OFF 
9ebd						exx 
9ebd						ld de, $8efe 
9ebd						ld a, d 
9ebd						ld hl, curframe 
9ebd						call hexout 
9ebd						ld a, e 
9ebd						ld hl, curframe+2 
9ebd						call hexout 
9ebd						ld hl, $8efe 
9ebd						push hl 
9ebd						ld hl, $989f 
9ebd						push hl 
9ebd						exx 
9ebd					endif 
9ebd				endif 
9ebd			endm 
# End of macro STACKFRAME
9ebd				; get parser buffer length  of new word 
9ebd			 
9ebd				 
9ebd			 
9ebd					; move tok past this to start of name defintition 
9ebd					; TODO get word to define 
9ebd					; TODO Move past word token 
9ebd					; TODO get length of string up to the ';' 
9ebd			 
9ebd 2a e7 e7			ld hl, (os_tok_ptr) 
9ec0 23				inc hl 
9ec1 23				inc hl 
9ec2			 
9ec2 3e 3b			ld a, ';' 
9ec4 cd 10 8f			call strlent 
9ec7			 
9ec7 7d				ld a,l 
9ec8 32 e2 e4			ld (os_new_parse_len), a 
9ecb			 
9ecb			 
9ecb			if DEBUG_FORTH_UWORD 
9ecb ed 5b e7 e7		ld de, (os_tok_ptr) 
9ecf						DMARK ":01" 
9ecf f5				push af  
9ed0 3a e4 9e			ld a, (.dmark)  
9ed3 32 c0 ee			ld (debug_mark),a  
9ed6 3a e5 9e			ld a, (.dmark+1)  
9ed9 32 c1 ee			ld (debug_mark+1),a  
9edc 3a e6 9e			ld a, (.dmark+2)  
9edf 32 c2 ee			ld (debug_mark+2),a  
9ee2 18 03			jr .pastdmark  
9ee4 ..			.dmark: db ":01"  
9ee7 f1			.pastdmark: pop af  
9ee8			endm  
# End of macro DMARK
9ee8				CALLMONITOR 
9ee8 cd 21 93			call break_point_state  
9eeb				endm  
# End of macro CALLMONITOR
9eeb			endif 
9eeb			 
9eeb			; 
9eeb			;  new word memory layout: 
9eeb			;  
9eeb			;    : adg 6666 ;  
9eeb			; 
9eeb			;    db   1     ; user defined word  
9eeb 23				inc hl    
9eec			;    dw   sysdict 
9eec 23				inc hl 
9eed 23				inc hl 
9eee			;    db <word len>+1 (for null) 
9eee 23				inc hl 
9eef			;    db .... <word> 
9eef			; 
9eef			 
9eef 23				inc hl    ; some extras for the word preamble before the above 
9ef0 23				inc hl 
9ef1 23				inc hl 
9ef2 23				inc hl 
9ef3 23				inc hl 
9ef4 23				inc hl 
9ef5 23				inc hl  
9ef6 23				inc hl 
9ef7 23				inc hl 
9ef8 23				inc hl 
9ef9 23				inc hl 
9efa 23				inc hl 
9efb 23				inc hl 
9efc 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9efd			;       exec word buffer 
9efd			;	<ptr word>   
9efd 23				inc hl 
9efe 23				inc hl 
9eff			;       <word list><null term> 7F final term 
9eff			 
9eff			 
9eff			if DEBUG_FORTH_UWORD 
9eff						DMARK ":02" 
9eff f5				push af  
9f00 3a 14 9f			ld a, (.dmark)  
9f03 32 c0 ee			ld (debug_mark),a  
9f06 3a 15 9f			ld a, (.dmark+1)  
9f09 32 c1 ee			ld (debug_mark+1),a  
9f0c 3a 16 9f			ld a, (.dmark+2)  
9f0f 32 c2 ee			ld (debug_mark+2),a  
9f12 18 03			jr .pastdmark  
9f14 ..			.dmark: db ":02"  
9f17 f1			.pastdmark: pop af  
9f18			endm  
# End of macro DMARK
9f18				CALLMONITOR 
9f18 cd 21 93			call break_point_state  
9f1b				endm  
# End of macro CALLMONITOR
9f1b			endif 
9f1b			 
9f1b				 
9f1b					; malloc the size 
9f1b			 
9f1b cd 6e 8f				call malloc 
9f1e 22 e4 e4				ld (os_new_malloc), hl     ; save malloc start 
9f21			 
9f21			;    db   1     ; user defined word  
9f21 3e 01				ld a, WORD_SYS_UWORD  
9f23 77					ld (hl), a 
9f24				 
9f24 23				inc hl    
9f25			;    dw   sysdict 
9f25 11 6f 9d			ld de, sysdict       ; continue on with the scan to the system dict 
9f28 73				ld (hl), e 
9f29 23				inc hl 
9f2a 72				ld (hl), d 
9f2b 23				inc hl 
9f2c			 
9f2c			 
9f2c			;    Setup dict word 
9f2c			 
9f2c 23				inc hl 
9f2d 22 de e4			ld (os_new_work_ptr), hl     ; save start of dict word  
9f30			 
9f30				; 1. get length of dict word 
9f30			 
9f30			 
9f30 2a e7 e7			ld hl, (os_tok_ptr) 
9f33 23				inc hl 
9f34 23				inc hl    ; position to start of dict word 
9f35 3e 00			ld a, 0 
9f37 cd 10 8f			call strlent 
9f3a			 
9f3a			 
9f3a 23				inc hl    ; to include null??? 
9f3b			 
9f3b				; write length of dict word 
9f3b			 
9f3b ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f3f 1b				dec de 
9f40 eb				ex de, hl 
9f41 73				ld (hl), e 
9f42 eb				ex de, hl 
9f43			 
9f43				 
9f43			 
9f43				; copy  
9f43 4d				ld c, l 
9f44 06 00			ld b, 0 
9f46 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f4a 2a e7 e7			ld hl, (os_tok_ptr) 
9f4d 23				inc hl 
9f4e 23				inc hl    ; position to start of dict word 
9f4f				 
9f4f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9f4f				 
9f4f				; TODO need to convert word to upper case 
9f4f			 
9f4f			ucasetok:	 
9f4f 7e				ld a,(hl) 
9f50 cd fc 8e			call toUpper 
9f53 77				ld (hl),a 
9f54 ed a0			ldi 
9f56 f2 4f 9f		 	jp p, ucasetok 
9f59			 
9f59			 
9f59			 
9f59				; de now points to start of where the word body code should be placed 
9f59 ed 53 de e4		ld (os_new_work_ptr), de 
9f5d				; hl now points to the words to throw at forthexec which needs to be copied 
9f5d 22 dc e4			ld (os_new_src_ptr), hl 
9f60			 
9f60				; TODO add 'call to forthexec' 
9f60			 
9f60			if DEBUG_FORTH_UWORD 
9f60 c5				push bc 
9f61 ed 4b e4 e4		ld bc, (os_new_malloc) 
9f65						DMARK ":0x" 
9f65 f5				push af  
9f66 3a 7a 9f			ld a, (.dmark)  
9f69 32 c0 ee			ld (debug_mark),a  
9f6c 3a 7b 9f			ld a, (.dmark+1)  
9f6f 32 c1 ee			ld (debug_mark+1),a  
9f72 3a 7c 9f			ld a, (.dmark+2)  
9f75 32 c2 ee			ld (debug_mark+2),a  
9f78 18 03			jr .pastdmark  
9f7a ..			.dmark: db ":0x"  
9f7d f1			.pastdmark: pop af  
9f7e			endm  
# End of macro DMARK
9f7e				CALLMONITOR 
9f7e cd 21 93			call break_point_state  
9f81				endm  
# End of macro CALLMONITOR
9f81 c1				pop bc 
9f82			endif 
9f82			 
9f82			 
9f82				; create word preamble which should be: 
9f82			 
9f82			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9f82			 
9f82				;    ld hl, <word code> 
9f82				;    jp user_exec 
9f82			        ;    <word code bytes> 
9f82			 
9f82			 
9f82			;	inc de     ; TODO ??? or are we already past the word's null 
9f82 eb				ex de, hl 
9f83			 
9f83 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9f85			 
9f85 23				inc hl 
9f86 22 d8 e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9f89 23				inc hl 
9f8a			 
9f8a 23				inc hl 
9f8b 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9f8d			 
9f8d 01 16 c3			ld bc, user_exec 
9f90 23				inc hl 
9f91 71				ld (hl), c     ; poke address of user_exec 
9f92 23				inc hl 
9f93 70				ld (hl), b     
9f94			 ; 
9f94			;	inc hl 
9f94			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9f94			; 
9f94			; 
9f94			;	ld bc, macro_forth_rsp_next 
9f94			;	inc hl 
9f94			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9f94			;	inc hl 
9f94			;	ld (hl), b     
9f94			 ; 
9f94			;	inc hl 
9f94			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9f94			; 
9f94			; 
9f94			;	inc hl 
9f94			;	ld bc, forthexec 
9f94			;	ld (hl), c     ; poke address of forthexec 
9f94			;	inc hl 
9f94			;	ld (hl), b      
9f94			; 
9f94			;	inc hl 
9f94			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9f94			; 
9f94			;	ld bc, user_dict_next 
9f94			;	inc hl 
9f94			;	ld (hl), c     ; poke address of forthexec 
9f94			;	inc hl 
9f94			;	ld (hl), b      
9f94			 
9f94				; hl is now where we need to copy the word byte data to save this 
9f94			 
9f94 23				inc hl 
9f95 22 da e4			ld (os_new_exec), hl 
9f98				 
9f98				; copy definition 
9f98			 
9f98 eb				ex de, hl 
9f99			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9f99			;	inc de    ; skip the PC for this parse 
9f99 3a e2 e4			ld a, (os_new_parse_len) 
9f9c 4f				ld c, a 
9f9d 06 00			ld b, 0 
9f9f ed b0			ldir		 ; copy defintion 
9fa1			 
9fa1			 
9fa1				; poke the address of where the new word bytes live for forthexec 
9fa1			 
9fa1 2a d8 e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9fa4			 
9fa4 ed 5b da e4		ld de, (os_new_exec)      
9fa8				 
9fa8 73				ld (hl), e 
9fa9 23				inc hl 
9faa 72				ld (hl), d 
9fab			 
9fab					; TODO copy last user dict word next link to this word 
9fab					; TODO update last user dict word to point to this word 
9fab			; 
9fab			; hl f923 de 812a ; bc 811a 
9fab			 
9fab			if DEBUG_FORTH_UWORD 
9fab c5				push bc 
9fac ed 4b e4 e4		ld bc, (os_new_malloc) 
9fb0						DMARK ":0A" 
9fb0 f5				push af  
9fb1 3a c5 9f			ld a, (.dmark)  
9fb4 32 c0 ee			ld (debug_mark),a  
9fb7 3a c6 9f			ld a, (.dmark+1)  
9fba 32 c1 ee			ld (debug_mark+1),a  
9fbd 3a c7 9f			ld a, (.dmark+2)  
9fc0 32 c2 ee			ld (debug_mark+2),a  
9fc3 18 03			jr .pastdmark  
9fc5 ..			.dmark: db ":0A"  
9fc8 f1			.pastdmark: pop af  
9fc9			endm  
# End of macro DMARK
9fc9				CALLMONITOR 
9fc9 cd 21 93			call break_point_state  
9fcc				endm  
# End of macro CALLMONITOR
9fcc c1				pop bc 
9fcd			endif 
9fcd			if DEBUG_FORTH_UWORD 
9fcd c5				push bc 
9fce ed 4b e4 e4		ld bc, (os_new_malloc) 
9fd2 03				inc bc 
9fd3 03				inc bc 
9fd4 03				inc bc 
9fd5 03				inc bc 
9fd6 03				inc bc 
9fd7 03				inc bc 
9fd8 03				inc bc 
9fd9 03				inc bc 
9fda			 
9fda						DMARK ":0B" 
9fda f5				push af  
9fdb 3a ef 9f			ld a, (.dmark)  
9fde 32 c0 ee			ld (debug_mark),a  
9fe1 3a f0 9f			ld a, (.dmark+1)  
9fe4 32 c1 ee			ld (debug_mark+1),a  
9fe7 3a f1 9f			ld a, (.dmark+2)  
9fea 32 c2 ee			ld (debug_mark+2),a  
9fed 18 03			jr .pastdmark  
9fef ..			.dmark: db ":0B"  
9ff2 f1			.pastdmark: pop af  
9ff3			endm  
# End of macro DMARK
9ff3				CALLMONITOR 
9ff3 cd 21 93			call break_point_state  
9ff6				endm  
# End of macro CALLMONITOR
9ff6 c1				pop bc 
9ff7			endif 
9ff7			 
9ff7			; update word dict linked list for new word 
9ff7			 
9ff7			 
9ff7 2a e3 e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
9ffa 23			inc hl     ; move to next work linked list ptr 
9ffb			 
9ffb ed 5b e4 e4	ld de, (os_new_malloc)		 ; new next word 
9fff 73			ld (hl), e 
a000 23			inc hl 
a001 72			ld (hl), d 
a002			 
a002			if DEBUG_FORTH_UWORD 
a002 ed 4b e3 e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a006			endif 
a006			 
a006 ed 53 e3 e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a00a			 
a00a			 
a00a			if DEBUG_FORTH_UWORD 
a00a						DMARK ":0+" 
a00a f5				push af  
a00b 3a 1f a0			ld a, (.dmark)  
a00e 32 c0 ee			ld (debug_mark),a  
a011 3a 20 a0			ld a, (.dmark+1)  
a014 32 c1 ee			ld (debug_mark+1),a  
a017 3a 21 a0			ld a, (.dmark+2)  
a01a 32 c2 ee			ld (debug_mark+2),a  
a01d 18 03			jr .pastdmark  
a01f ..			.dmark: db ":0+"  
a022 f1			.pastdmark: pop af  
a023			endm  
# End of macro DMARK
a023				CALLMONITOR 
a023 cd 21 93			call break_point_state  
a026				endm  
# End of macro CALLMONITOR
a026			endif 
a026			 
a026				STACKFRAMECHK OFF $8efe $989f 
a026				if DEBUG_STACK_IMB 
a026					if OFF 
a026						exx 
a026						ld hl, $989f 
a026						pop de   ; $989f 
a026						call cmp16 
a026						jr nz, .spnosame 
a026						ld hl, $8efe 
a026						pop de   ; $8efe 
a026						call cmp16 
a026						jr z, .spfrsame 
a026						.spnosame: call showsperror 
a026						.spfrsame: nop 
a026						exx 
a026					endif 
a026				endif 
a026			endm 
# End of macro STACKFRAMECHK
a026			 
a026 c9			ret    ; dont process any remaining parser tokens as they form new word 
a027			 
a027			 
a027			 
a027			 
a027			;		NEXT 
a027			.SCOLN: 
a027			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a027 06				db OPCODE_SCOLN 
a028 73 a0			dw .DROP 
a02a 02				db 2 
a02b .. 00			db ";",0           
a02d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a02d					if DEBUG_FORTH_WORDS_KEY 
a02d						DMARK "SCN" 
a02d f5				push af  
a02e 3a 42 a0			ld a, (.dmark)  
a031 32 c0 ee			ld (debug_mark),a  
a034 3a 43 a0			ld a, (.dmark+1)  
a037 32 c1 ee			ld (debug_mark+1),a  
a03a 3a 44 a0			ld a, (.dmark+2)  
a03d 32 c2 ee			ld (debug_mark+2),a  
a040 18 03			jr .pastdmark  
a042 ..			.dmark: db "SCN"  
a045 f1			.pastdmark: pop af  
a046			endm  
# End of macro DMARK
a046						CALLMONITOR 
a046 cd 21 93			call break_point_state  
a049				endm  
# End of macro CALLMONITOR
a049					endif 
a049					FORTH_RSP_TOS 
a049 cd 6c 98			call macro_forth_rsp_tos 
a04c				endm 
# End of macro FORTH_RSP_TOS
a04c e5					push hl 
a04d					FORTH_RSP_POP 
a04d cd 76 98			call macro_forth_rsp_pop 
a050				endm 
# End of macro FORTH_RSP_POP
a050 e1					pop hl 
a051			;		ex de,hl 
a051 22 e7 e7				ld (os_tok_ptr),hl 
a054			 
a054			if DEBUG_FORTH_UWORD 
a054						DMARK "SCL" 
a054 f5				push af  
a055 3a 69 a0			ld a, (.dmark)  
a058 32 c0 ee			ld (debug_mark),a  
a05b 3a 6a a0			ld a, (.dmark+1)  
a05e 32 c1 ee			ld (debug_mark+1),a  
a061 3a 6b a0			ld a, (.dmark+2)  
a064 32 c2 ee			ld (debug_mark+2),a  
a067 18 03			jr .pastdmark  
a069 ..			.dmark: db "SCL"  
a06c f1			.pastdmark: pop af  
a06d			endm  
# End of macro DMARK
a06d				CALLMONITOR 
a06d cd 21 93			call break_point_state  
a070				endm  
# End of macro CALLMONITOR
a070			endif 
a070					NEXTW 
a070 c3 17 9c			jp macro_next 
a073				endm 
# End of macro NEXTW
a073			 
a073			.DROP: 
a073				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a073 1b				db WORD_SYS_CORE+OPCODE_DROP             
a074 9e a0			dw .DUP2            
a076 05				db 4 + 1 
a077 .. 00			db "DROP",0              
a07c				endm 
# End of macro CWHEAD
a07c			; | DROP ( w -- )   drop the TOS item   | DONE 
a07c					if DEBUG_FORTH_WORDS_KEY 
a07c						DMARK "DRP" 
a07c f5				push af  
a07d 3a 91 a0			ld a, (.dmark)  
a080 32 c0 ee			ld (debug_mark),a  
a083 3a 92 a0			ld a, (.dmark+1)  
a086 32 c1 ee			ld (debug_mark+1),a  
a089 3a 93 a0			ld a, (.dmark+2)  
a08c 32 c2 ee			ld (debug_mark+2),a  
a08f 18 03			jr .pastdmark  
a091 ..			.dmark: db "DRP"  
a094 f1			.pastdmark: pop af  
a095			endm  
# End of macro DMARK
a095						CALLMONITOR 
a095 cd 21 93			call break_point_state  
a098				endm  
# End of macro CALLMONITOR
a098					endif 
a098					FORTH_DSP_POP 
a098 cd 5d 9b			call macro_forth_dsp_pop 
a09b				endm 
# End of macro FORTH_DSP_POP
a09b					NEXTW 
a09b c3 17 9c			jp macro_next 
a09e				endm 
# End of macro NEXTW
a09e			.DUP2: 
a09e				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a09e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a09f e3 a0			dw .DROP2            
a0a1 05				db 4 + 1 
a0a2 .. 00			db "2DUP",0              
a0a7				endm 
# End of macro CWHEAD
a0a7			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a0a7					if DEBUG_FORTH_WORDS_KEY 
a0a7						DMARK "2DU" 
a0a7 f5				push af  
a0a8 3a bc a0			ld a, (.dmark)  
a0ab 32 c0 ee			ld (debug_mark),a  
a0ae 3a bd a0			ld a, (.dmark+1)  
a0b1 32 c1 ee			ld (debug_mark+1),a  
a0b4 3a be a0			ld a, (.dmark+2)  
a0b7 32 c2 ee			ld (debug_mark+2),a  
a0ba 18 03			jr .pastdmark  
a0bc ..			.dmark: db "2DU"  
a0bf f1			.pastdmark: pop af  
a0c0			endm  
# End of macro DMARK
a0c0						CALLMONITOR 
a0c0 cd 21 93			call break_point_state  
a0c3				endm  
# End of macro CALLMONITOR
a0c3					endif 
a0c3					FORTH_DSP_VALUEHL 
a0c3 cd a5 9a			call macro_dsp_valuehl 
a0c6				endm 
# End of macro FORTH_DSP_VALUEHL
a0c6 e5					push hl      ; 2 
a0c7			 
a0c7					FORTH_DSP_POP 
a0c7 cd 5d 9b			call macro_forth_dsp_pop 
a0ca				endm 
# End of macro FORTH_DSP_POP
a0ca					 
a0ca					FORTH_DSP_VALUEHL 
a0ca cd a5 9a			call macro_dsp_valuehl 
a0cd				endm 
# End of macro FORTH_DSP_VALUEHL
a0cd			;		push hl      ; 1 
a0cd			 
a0cd					FORTH_DSP_POP 
a0cd cd 5d 9b			call macro_forth_dsp_pop 
a0d0				endm 
# End of macro FORTH_DSP_POP
a0d0			 
a0d0			;		pop hl       ; 1 
a0d0 d1					pop de       ; 2 
a0d1			 
a0d1 cd ae 98				call forth_push_numhl 
a0d4 eb					ex de, hl 
a0d5 cd ae 98				call forth_push_numhl 
a0d8			 
a0d8					 
a0d8 eb					ex de, hl 
a0d9			 
a0d9 cd ae 98				call forth_push_numhl 
a0dc eb					ex de, hl 
a0dd cd ae 98				call forth_push_numhl 
a0e0			 
a0e0			 
a0e0					NEXTW 
a0e0 c3 17 9c			jp macro_next 
a0e3				endm 
# End of macro NEXTW
a0e3			.DROP2: 
a0e3				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a0e3 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a0e4 12 a1			dw .SWAP2            
a0e6 06				db 5 + 1 
a0e7 .. 00			db "2DROP",0              
a0ed				endm 
# End of macro CWHEAD
a0ed			; | 2DROP ( w w -- )    Double drop | DONE 
a0ed					if DEBUG_FORTH_WORDS_KEY 
a0ed						DMARK "2DR" 
a0ed f5				push af  
a0ee 3a 02 a1			ld a, (.dmark)  
a0f1 32 c0 ee			ld (debug_mark),a  
a0f4 3a 03 a1			ld a, (.dmark+1)  
a0f7 32 c1 ee			ld (debug_mark+1),a  
a0fa 3a 04 a1			ld a, (.dmark+2)  
a0fd 32 c2 ee			ld (debug_mark+2),a  
a100 18 03			jr .pastdmark  
a102 ..			.dmark: db "2DR"  
a105 f1			.pastdmark: pop af  
a106			endm  
# End of macro DMARK
a106						CALLMONITOR 
a106 cd 21 93			call break_point_state  
a109				endm  
# End of macro CALLMONITOR
a109					endif 
a109					FORTH_DSP_POP 
a109 cd 5d 9b			call macro_forth_dsp_pop 
a10c				endm 
# End of macro FORTH_DSP_POP
a10c					FORTH_DSP_POP 
a10c cd 5d 9b			call macro_forth_dsp_pop 
a10f				endm 
# End of macro FORTH_DSP_POP
a10f					NEXTW 
a10f c3 17 9c			jp macro_next 
a112				endm 
# End of macro NEXTW
a112			.SWAP2: 
a112				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a112 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a113 3b a1			dw .AT            
a115 06				db 5 + 1 
a116 .. 00			db "2SWAP",0              
a11c				endm 
# End of macro CWHEAD
a11c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a11c					if DEBUG_FORTH_WORDS_KEY 
a11c						DMARK "2SW" 
a11c f5				push af  
a11d 3a 31 a1			ld a, (.dmark)  
a120 32 c0 ee			ld (debug_mark),a  
a123 3a 32 a1			ld a, (.dmark+1)  
a126 32 c1 ee			ld (debug_mark+1),a  
a129 3a 33 a1			ld a, (.dmark+2)  
a12c 32 c2 ee			ld (debug_mark+2),a  
a12f 18 03			jr .pastdmark  
a131 ..			.dmark: db "2SW"  
a134 f1			.pastdmark: pop af  
a135			endm  
# End of macro DMARK
a135						CALLMONITOR 
a135 cd 21 93			call break_point_state  
a138				endm  
# End of macro CALLMONITOR
a138					endif 
a138					NEXTW 
a138 c3 17 9c			jp macro_next 
a13b				endm 
# End of macro NEXTW
a13b			.AT: 
a13b				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a13b 1f				db WORD_SYS_CORE+OPCODE_AT             
a13c 6d a1			dw .CAT            
a13e 02				db 1 + 1 
a13f .. 00			db "@",0              
a141				endm 
# End of macro CWHEAD
a141			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a141			 
a141					if DEBUG_FORTH_WORDS_KEY 
a141						DMARK "AT." 
a141 f5				push af  
a142 3a 56 a1			ld a, (.dmark)  
a145 32 c0 ee			ld (debug_mark),a  
a148 3a 57 a1			ld a, (.dmark+1)  
a14b 32 c1 ee			ld (debug_mark+1),a  
a14e 3a 58 a1			ld a, (.dmark+2)  
a151 32 c2 ee			ld (debug_mark+2),a  
a154 18 03			jr .pastdmark  
a156 ..			.dmark: db "AT."  
a159 f1			.pastdmark: pop af  
a15a			endm  
# End of macro DMARK
a15a						CALLMONITOR 
a15a cd 21 93			call break_point_state  
a15d				endm  
# End of macro CALLMONITOR
a15d					endif 
a15d			.getbyteat:	 
a15d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a15d cd a5 9a			call macro_dsp_valuehl 
a160				endm 
# End of macro FORTH_DSP_VALUEHL
a160					 
a160			;		push hl 
a160				 
a160					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a160 cd 5d 9b			call macro_forth_dsp_pop 
a163				endm 
# End of macro FORTH_DSP_POP
a163			 
a163			;		pop hl 
a163			 
a163 7e					ld a, (hl) 
a164			 
a164 6f					ld l, a 
a165 26 00				ld h, 0 
a167 cd ae 98				call forth_push_numhl 
a16a			 
a16a					NEXTW 
a16a c3 17 9c			jp macro_next 
a16d				endm 
# End of macro NEXTW
a16d			.CAT: 
a16d				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a16d 20				db WORD_SYS_CORE+OPCODE_CAT             
a16e 96 a1			dw .BANG            
a170 03				db 2 + 1 
a171 .. 00			db "C@",0              
a174				endm 
# End of macro CWHEAD
a174			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a174					if DEBUG_FORTH_WORDS_KEY 
a174						DMARK "CAA" 
a174 f5				push af  
a175 3a 89 a1			ld a, (.dmark)  
a178 32 c0 ee			ld (debug_mark),a  
a17b 3a 8a a1			ld a, (.dmark+1)  
a17e 32 c1 ee			ld (debug_mark+1),a  
a181 3a 8b a1			ld a, (.dmark+2)  
a184 32 c2 ee			ld (debug_mark+2),a  
a187 18 03			jr .pastdmark  
a189 ..			.dmark: db "CAA"  
a18c f1			.pastdmark: pop af  
a18d			endm  
# End of macro DMARK
a18d						CALLMONITOR 
a18d cd 21 93			call break_point_state  
a190				endm  
# End of macro CALLMONITOR
a190					endif 
a190 c3 5d a1				jp .getbyteat 
a193					NEXTW 
a193 c3 17 9c			jp macro_next 
a196				endm 
# End of macro NEXTW
a196			.BANG: 
a196				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a196 21				db WORD_SYS_CORE+OPCODE_BANG             
a197 cc a1			dw .CBANG            
a199 02				db 1 + 1 
a19a .. 00			db "!",0              
a19c				endm 
# End of macro CWHEAD
a19c			; | ! ( x w -- ) Store x at address w      | DONE 
a19c					if DEBUG_FORTH_WORDS_KEY 
a19c						DMARK "BNG" 
a19c f5				push af  
a19d 3a b1 a1			ld a, (.dmark)  
a1a0 32 c0 ee			ld (debug_mark),a  
a1a3 3a b2 a1			ld a, (.dmark+1)  
a1a6 32 c1 ee			ld (debug_mark+1),a  
a1a9 3a b3 a1			ld a, (.dmark+2)  
a1ac 32 c2 ee			ld (debug_mark+2),a  
a1af 18 03			jr .pastdmark  
a1b1 ..			.dmark: db "BNG"  
a1b4 f1			.pastdmark: pop af  
a1b5			endm  
# End of macro DMARK
a1b5						CALLMONITOR 
a1b5 cd 21 93			call break_point_state  
a1b8				endm  
# End of macro CALLMONITOR
a1b8					endif 
a1b8			 
a1b8			.storebyteat:		 
a1b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1b8 cd a5 9a			call macro_dsp_valuehl 
a1bb				endm 
# End of macro FORTH_DSP_VALUEHL
a1bb					 
a1bb e5					push hl 
a1bc				 
a1bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1bc cd 5d 9b			call macro_forth_dsp_pop 
a1bf				endm 
# End of macro FORTH_DSP_POP
a1bf			 
a1bf					; get byte to poke 
a1bf			 
a1bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1bf cd a5 9a			call macro_dsp_valuehl 
a1c2				endm 
# End of macro FORTH_DSP_VALUEHL
a1c2 e5					push hl 
a1c3			 
a1c3			 
a1c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1c3 cd 5d 9b			call macro_forth_dsp_pop 
a1c6				endm 
# End of macro FORTH_DSP_POP
a1c6			 
a1c6			 
a1c6 d1					pop de 
a1c7 e1					pop hl 
a1c8			 
a1c8 73					ld (hl),e 
a1c9			 
a1c9			 
a1c9					NEXTW 
a1c9 c3 17 9c			jp macro_next 
a1cc				endm 
# End of macro NEXTW
a1cc			.CBANG: 
a1cc				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a1cc 22				db WORD_SYS_CORE+OPCODE_CBANG             
a1cd f5 a1			dw .SCALL            
a1cf 03				db 2 + 1 
a1d0 .. 00			db "C!",0              
a1d3				endm 
# End of macro CWHEAD
a1d3			; | C!  ( x w -- ) Store x at address w  | DONE 
a1d3					if DEBUG_FORTH_WORDS_KEY 
a1d3						DMARK "CBA" 
a1d3 f5				push af  
a1d4 3a e8 a1			ld a, (.dmark)  
a1d7 32 c0 ee			ld (debug_mark),a  
a1da 3a e9 a1			ld a, (.dmark+1)  
a1dd 32 c1 ee			ld (debug_mark+1),a  
a1e0 3a ea a1			ld a, (.dmark+2)  
a1e3 32 c2 ee			ld (debug_mark+2),a  
a1e6 18 03			jr .pastdmark  
a1e8 ..			.dmark: db "CBA"  
a1eb f1			.pastdmark: pop af  
a1ec			endm  
# End of macro DMARK
a1ec						CALLMONITOR 
a1ec cd 21 93			call break_point_state  
a1ef				endm  
# End of macro CALLMONITOR
a1ef					endif 
a1ef c3 b8 a1				jp .storebyteat 
a1f2					NEXTW 
a1f2 c3 17 9c			jp macro_next 
a1f5				endm 
# End of macro NEXTW
a1f5			.SCALL: 
a1f5				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a1f5 23				db WORD_SYS_CORE+OPCODE_SCALL             
a1f6 29 a2			dw .DEPTH            
a1f8 05				db 4 + 1 
a1f9 .. 00			db "CALL",0              
a1fe				endm 
# End of macro CWHEAD
a1fe			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a1fe					if DEBUG_FORTH_WORDS_KEY 
a1fe						DMARK "CLL" 
a1fe f5				push af  
a1ff 3a 13 a2			ld a, (.dmark)  
a202 32 c0 ee			ld (debug_mark),a  
a205 3a 14 a2			ld a, (.dmark+1)  
a208 32 c1 ee			ld (debug_mark+1),a  
a20b 3a 15 a2			ld a, (.dmark+2)  
a20e 32 c2 ee			ld (debug_mark+2),a  
a211 18 03			jr .pastdmark  
a213 ..			.dmark: db "CLL"  
a216 f1			.pastdmark: pop af  
a217			endm  
# End of macro DMARK
a217						CALLMONITOR 
a217 cd 21 93			call break_point_state  
a21a				endm  
# End of macro CALLMONITOR
a21a					endif 
a21a			 
a21a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a21a cd a5 9a			call macro_dsp_valuehl 
a21d				endm 
# End of macro FORTH_DSP_VALUEHL
a21d			 
a21d			;		push hl 
a21d			 
a21d					; destroy value TOS 
a21d			 
a21d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a21d cd 5d 9b			call macro_forth_dsp_pop 
a220				endm 
# End of macro FORTH_DSP_POP
a220			 
a220						 
a220			;		pop hl 
a220			 
a220					; how to do a call with hl???? save SP? 
a220 cd c0 9b				call forth_call_hl 
a223			 
a223			 
a223					; TODO push value back onto stack for another op etc 
a223			 
a223 cd ae 98				call forth_push_numhl 
a226					NEXTW 
a226 c3 17 9c			jp macro_next 
a229				endm 
# End of macro NEXTW
a229			.DEPTH: 
a229				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a229 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a22a 66 a2			dw .OVER            
a22c 06				db 5 + 1 
a22d .. 00			db "DEPTH",0              
a233				endm 
# End of macro CWHEAD
a233			; | DEPTH ( -- u ) Push count of stack | DONE 
a233					; take current TOS and remove from base value div by two to get count 
a233					if DEBUG_FORTH_WORDS_KEY 
a233						DMARK "DEP" 
a233 f5				push af  
a234 3a 48 a2			ld a, (.dmark)  
a237 32 c0 ee			ld (debug_mark),a  
a23a 3a 49 a2			ld a, (.dmark+1)  
a23d 32 c1 ee			ld (debug_mark+1),a  
a240 3a 4a a2			ld a, (.dmark+2)  
a243 32 c2 ee			ld (debug_mark+2),a  
a246 18 03			jr .pastdmark  
a248 ..			.dmark: db "DEP"  
a24b f1			.pastdmark: pop af  
a24c			endm  
# End of macro DMARK
a24c						CALLMONITOR 
a24c cd 21 93			call break_point_state  
a24f				endm  
# End of macro CALLMONITOR
a24f					endif 
a24f			 
a24f			 
a24f 2a 93 ec			ld hl, (cli_data_sp) 
a252 11 4d ea			ld de, cli_data_stack 
a255 ed 52			sbc hl,de 
a257				 
a257				; div by size of stack item 
a257			 
a257 5d				ld e,l 
a258 0e 03			ld c, 3 
a25a cd 37 8a			call Div8 
a25d			 
a25d 6f				ld l,a 
a25e 26 00			ld h,0 
a260			 
a260				;srl h 
a260				;rr l 
a260			 
a260 cd ae 98				call forth_push_numhl 
a263					NEXTW 
a263 c3 17 9c			jp macro_next 
a266				endm 
# End of macro NEXTW
a266			.OVER: 
a266				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a266 42				db WORD_SYS_CORE+46             
a267 ad a2			dw .PAUSE            
a269 05				db 4 + 1 
a26a .. 00			db "OVER",0              
a26f				endm 
# End of macro CWHEAD
a26f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a26f					if DEBUG_FORTH_WORDS_KEY 
a26f						DMARK "OVR" 
a26f f5				push af  
a270 3a 84 a2			ld a, (.dmark)  
a273 32 c0 ee			ld (debug_mark),a  
a276 3a 85 a2			ld a, (.dmark+1)  
a279 32 c1 ee			ld (debug_mark+1),a  
a27c 3a 86 a2			ld a, (.dmark+2)  
a27f 32 c2 ee			ld (debug_mark+2),a  
a282 18 03			jr .pastdmark  
a284 ..			.dmark: db "OVR"  
a287 f1			.pastdmark: pop af  
a288			endm  
# End of macro DMARK
a288						CALLMONITOR 
a288 cd 21 93			call break_point_state  
a28b				endm  
# End of macro CALLMONITOR
a28b					endif 
a28b			 
a28b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a28b cd a5 9a			call macro_dsp_valuehl 
a28e				endm 
# End of macro FORTH_DSP_VALUEHL
a28e e5					push hl    ; n2 
a28f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a28f cd 5d 9b			call macro_forth_dsp_pop 
a292				endm 
# End of macro FORTH_DSP_POP
a292			 
a292					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a292 cd a5 9a			call macro_dsp_valuehl 
a295				endm 
# End of macro FORTH_DSP_VALUEHL
a295 e5					push hl    ; n1 
a296					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a296 cd 5d 9b			call macro_forth_dsp_pop 
a299				endm 
# End of macro FORTH_DSP_POP
a299			 
a299 d1					pop de     ; n1 
a29a e1					pop hl     ; n2 
a29b			 
a29b d5					push de 
a29c e5					push hl 
a29d d5					push de 
a29e			 
a29e					; push back  
a29e			 
a29e e1					pop hl 
a29f cd ae 98				call forth_push_numhl 
a2a2 e1					pop hl 
a2a3 cd ae 98				call forth_push_numhl 
a2a6 e1					pop hl 
a2a7 cd ae 98				call forth_push_numhl 
a2aa					NEXTW 
a2aa c3 17 9c			jp macro_next 
a2ad				endm 
# End of macro NEXTW
a2ad			 
a2ad			.PAUSE: 
a2ad				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a2ad 43				db WORD_SYS_CORE+47             
a2ae e2 a2			dw .PAUSES            
a2b0 08				db 7 + 1 
a2b1 .. 00			db "PAUSEMS",0              
a2b9				endm 
# End of macro CWHEAD
a2b9			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a2b9					if DEBUG_FORTH_WORDS_KEY 
a2b9						DMARK "PMS" 
a2b9 f5				push af  
a2ba 3a ce a2			ld a, (.dmark)  
a2bd 32 c0 ee			ld (debug_mark),a  
a2c0 3a cf a2			ld a, (.dmark+1)  
a2c3 32 c1 ee			ld (debug_mark+1),a  
a2c6 3a d0 a2			ld a, (.dmark+2)  
a2c9 32 c2 ee			ld (debug_mark+2),a  
a2cc 18 03			jr .pastdmark  
a2ce ..			.dmark: db "PMS"  
a2d1 f1			.pastdmark: pop af  
a2d2			endm  
# End of macro DMARK
a2d2						CALLMONITOR 
a2d2 cd 21 93			call break_point_state  
a2d5				endm  
# End of macro CALLMONITOR
a2d5					endif 
a2d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2d5 cd a5 9a			call macro_dsp_valuehl 
a2d8				endm 
# End of macro FORTH_DSP_VALUEHL
a2d8			;		push hl    ; n2 
a2d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2d8 cd 5d 9b			call macro_forth_dsp_pop 
a2db				endm 
# End of macro FORTH_DSP_POP
a2db			;		pop hl 
a2db			 
a2db 7d					ld a, l 
a2dc cd df 87				call aDelayInMS 
a2df				       NEXTW 
a2df c3 17 9c			jp macro_next 
a2e2				endm 
# End of macro NEXTW
a2e2			.PAUSES:  
a2e2				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a2e2 44				db WORD_SYS_CORE+48             
a2e3 51 a3			dw .ROT            
a2e5 06				db 5 + 1 
a2e6 .. 00			db "PAUSE",0              
a2ec				endm 
# End of macro CWHEAD
a2ec			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a2ec					if DEBUG_FORTH_WORDS_KEY 
a2ec						DMARK "PAU" 
a2ec f5				push af  
a2ed 3a 01 a3			ld a, (.dmark)  
a2f0 32 c0 ee			ld (debug_mark),a  
a2f3 3a 02 a3			ld a, (.dmark+1)  
a2f6 32 c1 ee			ld (debug_mark+1),a  
a2f9 3a 03 a3			ld a, (.dmark+2)  
a2fc 32 c2 ee			ld (debug_mark+2),a  
a2ff 18 03			jr .pastdmark  
a301 ..			.dmark: db "PAU"  
a304 f1			.pastdmark: pop af  
a305			endm  
# End of macro DMARK
a305						CALLMONITOR 
a305 cd 21 93			call break_point_state  
a308				endm  
# End of macro CALLMONITOR
a308					endif 
a308					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a308 cd a5 9a			call macro_dsp_valuehl 
a30b				endm 
# End of macro FORTH_DSP_VALUEHL
a30b			;		push hl    ; n2 
a30b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a30b cd 5d 9b			call macro_forth_dsp_pop 
a30e				endm 
# End of macro FORTH_DSP_POP
a30e			;		pop hl 
a30e 45					ld b, l 
a30f					if DEBUG_FORTH_WORDS 
a30f						DMARK "PAU" 
a30f f5				push af  
a310 3a 24 a3			ld a, (.dmark)  
a313 32 c0 ee			ld (debug_mark),a  
a316 3a 25 a3			ld a, (.dmark+1)  
a319 32 c1 ee			ld (debug_mark+1),a  
a31c 3a 26 a3			ld a, (.dmark+2)  
a31f 32 c2 ee			ld (debug_mark+2),a  
a322 18 03			jr .pastdmark  
a324 ..			.dmark: db "PAU"  
a327 f1			.pastdmark: pop af  
a328			endm  
# End of macro DMARK
a328						CALLMONITOR 
a328 cd 21 93			call break_point_state  
a32b				endm  
# End of macro CALLMONITOR
a32b					endif 
a32b c5			.pauses1:	push bc 
a32c cd fa 87				call delay1s 
a32f c1					pop bc 
a330					if DEBUG_FORTH_WORDS 
a330						DMARK "PA1" 
a330 f5				push af  
a331 3a 45 a3			ld a, (.dmark)  
a334 32 c0 ee			ld (debug_mark),a  
a337 3a 46 a3			ld a, (.dmark+1)  
a33a 32 c1 ee			ld (debug_mark+1),a  
a33d 3a 47 a3			ld a, (.dmark+2)  
a340 32 c2 ee			ld (debug_mark+2),a  
a343 18 03			jr .pastdmark  
a345 ..			.dmark: db "PA1"  
a348 f1			.pastdmark: pop af  
a349			endm  
# End of macro DMARK
a349						CALLMONITOR 
a349 cd 21 93			call break_point_state  
a34c				endm  
# End of macro CALLMONITOR
a34c					endif 
a34c 10 dd				djnz .pauses1 
a34e			 
a34e				       NEXTW 
a34e c3 17 9c			jp macro_next 
a351				endm 
# End of macro NEXTW
a351			.ROT: 
a351				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a351 45				db WORD_SYS_CORE+49             
a352 9f a3			dw .UWORDS            
a354 04				db 3 + 1 
a355 .. 00			db "ROT",0              
a359				endm 
# End of macro CWHEAD
a359			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a359					if DEBUG_FORTH_WORDS_KEY 
a359						DMARK "ROT" 
a359 f5				push af  
a35a 3a 6e a3			ld a, (.dmark)  
a35d 32 c0 ee			ld (debug_mark),a  
a360 3a 6f a3			ld a, (.dmark+1)  
a363 32 c1 ee			ld (debug_mark+1),a  
a366 3a 70 a3			ld a, (.dmark+2)  
a369 32 c2 ee			ld (debug_mark+2),a  
a36c 18 03			jr .pastdmark  
a36e ..			.dmark: db "ROT"  
a371 f1			.pastdmark: pop af  
a372			endm  
# End of macro DMARK
a372						CALLMONITOR 
a372 cd 21 93			call break_point_state  
a375				endm  
# End of macro CALLMONITOR
a375					endif 
a375			 
a375					FORTH_DSP_VALUEHL 
a375 cd a5 9a			call macro_dsp_valuehl 
a378				endm 
# End of macro FORTH_DSP_VALUEHL
a378 e5					push hl    ; u3  
a379			 
a379					FORTH_DSP_POP 
a379 cd 5d 9b			call macro_forth_dsp_pop 
a37c				endm 
# End of macro FORTH_DSP_POP
a37c			   
a37c					FORTH_DSP_VALUEHL 
a37c cd a5 9a			call macro_dsp_valuehl 
a37f				endm 
# End of macro FORTH_DSP_VALUEHL
a37f e5					push hl     ; u2 
a380			 
a380					FORTH_DSP_POP 
a380 cd 5d 9b			call macro_forth_dsp_pop 
a383				endm 
# End of macro FORTH_DSP_POP
a383			 
a383					FORTH_DSP_VALUEHL 
a383 cd a5 9a			call macro_dsp_valuehl 
a386				endm 
# End of macro FORTH_DSP_VALUEHL
a386 e5					push hl     ; u1 
a387			 
a387					FORTH_DSP_POP 
a387 cd 5d 9b			call macro_forth_dsp_pop 
a38a				endm 
# End of macro FORTH_DSP_POP
a38a			 
a38a c1					pop bc      ; u1 
a38b e1					pop hl      ; u2 
a38c d1					pop de      ; u3 
a38d			 
a38d			 
a38d c5					push bc 
a38e d5					push de 
a38f e5					push hl 
a390			 
a390			 
a390 e1					pop hl 
a391 cd ae 98				call forth_push_numhl 
a394			 
a394 e1					pop hl 
a395 cd ae 98				call forth_push_numhl 
a398			 
a398 e1					pop hl 
a399 cd ae 98				call forth_push_numhl 
a39c					 
a39c			 
a39c			 
a39c			 
a39c			 
a39c			 
a39c				       NEXTW 
a39c c3 17 9c			jp macro_next 
a39f				endm 
# End of macro NEXTW
a39f			 
a39f			.UWORDS: 
a39f				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a39f 50				db WORD_SYS_CORE+60             
a3a0 61 a4			dw .BP            
a3a2 07				db 6 + 1 
a3a3 .. 00			db "UWORDS",0              
a3aa				endm 
# End of macro CWHEAD
a3aa			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a3aa			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a3aa			; | | Following the count are the individual words. 
a3aa			; | | 
a3aa			; | | e.g. UWORDS 
a3aa			; | | BOX DIRLIST 2 
a3aa			; | |  
a3aa			; | | Can be used to save the words to storage via: 
a3aa			; | | UWORDS $01 DO $01 APPEND LOOP 
a3aa				if DEBUG_FORTH_WORDS_KEY 
a3aa					DMARK "UWR" 
a3aa f5				push af  
a3ab 3a bf a3			ld a, (.dmark)  
a3ae 32 c0 ee			ld (debug_mark),a  
a3b1 3a c0 a3			ld a, (.dmark+1)  
a3b4 32 c1 ee			ld (debug_mark+1),a  
a3b7 3a c1 a3			ld a, (.dmark+2)  
a3ba 32 c2 ee			ld (debug_mark+2),a  
a3bd 18 03			jr .pastdmark  
a3bf ..			.dmark: db "UWR"  
a3c2 f1			.pastdmark: pop af  
a3c3			endm  
# End of macro DMARK
a3c3					CALLMONITOR 
a3c3 cd 21 93			call break_point_state  
a3c6				endm  
# End of macro CALLMONITOR
a3c6				endif 
a3c6 21 33 d7				ld hl, baseram 
a3c9					;ld hl, baseusermem 
a3c9 01 00 00				ld bc, 0    ; start a counter 
a3cc			 
a3cc				; skip dict stub 
a3cc			 
a3cc cd 68 9d				call forth_tok_next 
a3cf			 
a3cf			 
a3cf			; while we have words to look for 
a3cf			 
a3cf 7e			.douscan:	ld a, (hl)      
a3d0				if DEBUG_FORTH_WORDS 
a3d0					DMARK "UWs" 
a3d0 f5				push af  
a3d1 3a e5 a3			ld a, (.dmark)  
a3d4 32 c0 ee			ld (debug_mark),a  
a3d7 3a e6 a3			ld a, (.dmark+1)  
a3da 32 c1 ee			ld (debug_mark+1),a  
a3dd 3a e7 a3			ld a, (.dmark+2)  
a3e0 32 c2 ee			ld (debug_mark+2),a  
a3e3 18 03			jr .pastdmark  
a3e5 ..			.dmark: db "UWs"  
a3e8 f1			.pastdmark: pop af  
a3e9			endm  
# End of macro DMARK
a3e9					CALLMONITOR 
a3e9 cd 21 93			call break_point_state  
a3ec				endm  
# End of macro CALLMONITOR
a3ec				endif 
a3ec fe 00				cp WORD_SYS_END 
a3ee 28 4d				jr z, .udone 
a3f0 fe 01				cp WORD_SYS_UWORD 
a3f2 20 44				jr nz, .nuword 
a3f4			 
a3f4				if DEBUG_FORTH_WORDS 
a3f4					DMARK "UWu" 
a3f4 f5				push af  
a3f5 3a 09 a4			ld a, (.dmark)  
a3f8 32 c0 ee			ld (debug_mark),a  
a3fb 3a 0a a4			ld a, (.dmark+1)  
a3fe 32 c1 ee			ld (debug_mark+1),a  
a401 3a 0b a4			ld a, (.dmark+2)  
a404 32 c2 ee			ld (debug_mark+2),a  
a407 18 03			jr .pastdmark  
a409 ..			.dmark: db "UWu"  
a40c f1			.pastdmark: pop af  
a40d			endm  
# End of macro DMARK
a40d					CALLMONITOR 
a40d cd 21 93			call break_point_state  
a410				endm  
# End of macro CALLMONITOR
a410				endif 
a410					; we have a uword so push its name to the stack 
a410			 
a410 e5				   	push hl  ; save so we can move to next dict block 
a411			 
a411					; skip opcode 
a411 23					inc hl  
a412					; skip next ptr 
a412 23					inc hl  
a413 23					inc hl 
a414					; skip len 
a414 23					inc hl 
a415				if DEBUG_FORTH_WORDS 
a415					DMARK "UWt" 
a415 f5				push af  
a416 3a 2a a4			ld a, (.dmark)  
a419 32 c0 ee			ld (debug_mark),a  
a41c 3a 2b a4			ld a, (.dmark+1)  
a41f 32 c1 ee			ld (debug_mark+1),a  
a422 3a 2c a4			ld a, (.dmark+2)  
a425 32 c2 ee			ld (debug_mark+2),a  
a428 18 03			jr .pastdmark  
a42a ..			.dmark: db "UWt"  
a42d f1			.pastdmark: pop af  
a42e			endm  
# End of macro DMARK
a42e					CALLMONITOR 
a42e cd 21 93			call break_point_state  
a431				endm  
# End of macro CALLMONITOR
a431				endif 
a431 03					inc bc 
a432			 
a432 c5					push bc 
a433 cd 1c 99				call forth_push_str 
a436 c1					pop bc 
a437			 
a437 e1					pop hl 	 
a438			 
a438 cd 68 9d		.nuword:	call forth_tok_next 
a43b 18 92				jr .douscan  
a43d			 
a43d			.udone:		 ; push count of uwords found 
a43d c5					push bc 
a43e e1					pop hl 
a43f			 
a43f				if DEBUG_FORTH_WORDS 
a43f					DMARK "UWc" 
a43f f5				push af  
a440 3a 54 a4			ld a, (.dmark)  
a443 32 c0 ee			ld (debug_mark),a  
a446 3a 55 a4			ld a, (.dmark+1)  
a449 32 c1 ee			ld (debug_mark+1),a  
a44c 3a 56 a4			ld a, (.dmark+2)  
a44f 32 c2 ee			ld (debug_mark+2),a  
a452 18 03			jr .pastdmark  
a454 ..			.dmark: db "UWc"  
a457 f1			.pastdmark: pop af  
a458			endm  
# End of macro DMARK
a458					CALLMONITOR 
a458 cd 21 93			call break_point_state  
a45b				endm  
# End of macro CALLMONITOR
a45b				endif 
a45b cd ae 98				call forth_push_numhl 
a45e			 
a45e			 
a45e				       NEXTW 
a45e c3 17 9c			jp macro_next 
a461				endm 
# End of macro NEXTW
a461			 
a461			.BP: 
a461				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a461 54				db WORD_SYS_CORE+64             
a462 97 a4			dw .MONITOR            
a464 03				db 2 + 1 
a465 .. 00			db "BP",0              
a468				endm 
# End of macro CWHEAD
a468			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a468			; | | $00 Will enable the break points within specific code paths 
a468			; | | $01 Will disable break points 
a468			; | |  
a468			; | | By default break points are off. Either the above can be used to enable them 
a468			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a468			; | | and on release of the pressed key a message will be disaplayed to notify 
a468			; | | that break points are enabled. Pressing any key will then continue boot process. 
a468					; get byte count 
a468					if DEBUG_FORTH_WORDS_KEY 
a468						DMARK "BP." 
a468 f5				push af  
a469 3a 7d a4			ld a, (.dmark)  
a46c 32 c0 ee			ld (debug_mark),a  
a46f 3a 7e a4			ld a, (.dmark+1)  
a472 32 c1 ee			ld (debug_mark+1),a  
a475 3a 7f a4			ld a, (.dmark+2)  
a478 32 c2 ee			ld (debug_mark+2),a  
a47b 18 03			jr .pastdmark  
a47d ..			.dmark: db "BP."  
a480 f1			.pastdmark: pop af  
a481			endm  
# End of macro DMARK
a481						CALLMONITOR 
a481 cd 21 93			call break_point_state  
a484				endm  
# End of macro CALLMONITOR
a484					endif 
a484			 
a484					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a484 cd a5 9a			call macro_dsp_valuehl 
a487				endm 
# End of macro FORTH_DSP_VALUEHL
a487			 
a487			;		push hl 
a487			 
a487					; destroy value TOS 
a487			 
a487					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a487 cd 5d 9b			call macro_forth_dsp_pop 
a48a				endm 
# End of macro FORTH_DSP_POP
a48a			 
a48a			;		pop hl 
a48a			 
a48a 3e 00				ld a,0 
a48c bd					cp l 
a48d 28 02				jr z, .bpset 
a48f 3e 2a				ld a, '*' 
a491			 
a491 32 d7 e4		.bpset:		ld (os_view_disable), a 
a494			 
a494			 
a494					NEXTW 
a494 c3 17 9c			jp macro_next 
a497				endm 
# End of macro NEXTW
a497			 
a497			 
a497			.MONITOR: 
a497				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a497 55				db WORD_SYS_CORE+65             
a498 ca a4			dw .MALLOC            
a49a 08				db 7 + 1 
a49b .. 00			db "MONITOR",0              
a4a3				endm 
# End of macro CWHEAD
a4a3			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a4a3			; | | At start the current various registers will be displayed with contents. 
a4a3			; | | Top right corner will show the most recent debug marker seen. 
a4a3			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a4a3			; | | and the return stack pointer (RSP). 
a4a3			; | | Pressing: 
a4a3			; | |    1 - Initial screen 
a4a3			; | |    2 - Display a data dump of HL 
a4a3			; | |    3 - Display a data dump of DE 
a4a3			; | |    4 - Display a data dump of BC 
a4a3			; | |    5 - Display a data dump of HL 
a4a3			; | |    6 - Display a data dump of DSP 
a4a3			; | |    7 - Display a data dump of RSP 
a4a3			; | |    8 - Display a data dump of what is at DSP 
a4a3			; | |    9 - Display a data dump of what is at RSP 
a4a3			; | |    0 - Exit monitor and continue running. This will also enable break points 
a4a3			; | |    * - Disable break points 
a4a3			; | |    # - Enter traditional monitor mode 
a4a3			; | | 
a4a3			; | | Monitor Mode 
a4a3			; | | ------------ 
a4a3			; | | A prompt of '>' will be shown for various commands: 
a4a3			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a4a3			; | |    C - Continue display a data dump from the last set address 
a4a3			; | |    M xxxx - Set start of memory edit at address xx 
a4a3			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a4a3			; | |    Q - Return to previous 
a4a3					if DEBUG_FORTH_WORDS_KEY 
a4a3						DMARK "MON" 
a4a3 f5				push af  
a4a4 3a b8 a4			ld a, (.dmark)  
a4a7 32 c0 ee			ld (debug_mark),a  
a4aa 3a b9 a4			ld a, (.dmark+1)  
a4ad 32 c1 ee			ld (debug_mark+1),a  
a4b0 3a ba a4			ld a, (.dmark+2)  
a4b3 32 c2 ee			ld (debug_mark+2),a  
a4b6 18 03			jr .pastdmark  
a4b8 ..			.dmark: db "MON"  
a4bb f1			.pastdmark: pop af  
a4bc			endm  
# End of macro DMARK
a4bc						CALLMONITOR 
a4bc cd 21 93			call break_point_state  
a4bf				endm  
# End of macro CALLMONITOR
a4bf					endif 
a4bf 3e 00				ld a, 0 
a4c1 32 d7 e4				ld (os_view_disable), a 
a4c4			 
a4c4					CALLMONITOR 
a4c4 cd 21 93			call break_point_state  
a4c7				endm  
# End of macro CALLMONITOR
a4c7			 
a4c7			;	call monitor 
a4c7			 
a4c7					NEXTW 
a4c7 c3 17 9c			jp macro_next 
a4ca				endm 
# End of macro NEXTW
a4ca			 
a4ca			 
a4ca			.MALLOC: 
a4ca				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a4ca 56				db WORD_SYS_CORE+66             
a4cb f3 a4			dw .MALLOC2            
a4cd 06				db 5 + 1 
a4ce .. 00			db "ALLOT",0              
a4d4				endm 
# End of macro CWHEAD
a4d4			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a4d4					if DEBUG_FORTH_WORDS_KEY 
a4d4						DMARK "ALL" 
a4d4 f5				push af  
a4d5 3a e9 a4			ld a, (.dmark)  
a4d8 32 c0 ee			ld (debug_mark),a  
a4db 3a ea a4			ld a, (.dmark+1)  
a4de 32 c1 ee			ld (debug_mark+1),a  
a4e1 3a eb a4			ld a, (.dmark+2)  
a4e4 32 c2 ee			ld (debug_mark+2),a  
a4e7 18 03			jr .pastdmark  
a4e9 ..			.dmark: db "ALL"  
a4ec f1			.pastdmark: pop af  
a4ed			endm  
# End of macro DMARK
a4ed						CALLMONITOR 
a4ed cd 21 93			call break_point_state  
a4f0				endm  
# End of macro CALLMONITOR
a4f0					endif 
a4f0 c3 1a a5				jp .mallocc 
a4f3			.MALLOC2: 
a4f3				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a4f3 56				db WORD_SYS_CORE+66             
a4f4 31 a5			dw .FREE            
a4f6 07				db 6 + 1 
a4f7 .. 00			db "MALLOC",0              
a4fe				endm 
# End of macro CWHEAD
a4fe			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a4fe					; get byte count 
a4fe					if DEBUG_FORTH_WORDS_KEY 
a4fe						DMARK "MAL" 
a4fe f5				push af  
a4ff 3a 13 a5			ld a, (.dmark)  
a502 32 c0 ee			ld (debug_mark),a  
a505 3a 14 a5			ld a, (.dmark+1)  
a508 32 c1 ee			ld (debug_mark+1),a  
a50b 3a 15 a5			ld a, (.dmark+2)  
a50e 32 c2 ee			ld (debug_mark+2),a  
a511 18 03			jr .pastdmark  
a513 ..			.dmark: db "MAL"  
a516 f1			.pastdmark: pop af  
a517			endm  
# End of macro DMARK
a517						CALLMONITOR 
a517 cd 21 93			call break_point_state  
a51a				endm  
# End of macro CALLMONITOR
a51a					endif 
a51a			.mallocc: 
a51a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a51a cd a5 9a			call macro_dsp_valuehl 
a51d				endm 
# End of macro FORTH_DSP_VALUEHL
a51d			 
a51d			;		push hl 
a51d			 
a51d					; destroy value TOS 
a51d			 
a51d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a51d cd 5d 9b			call macro_forth_dsp_pop 
a520				endm 
# End of macro FORTH_DSP_POP
a520			 
a520			;		pop hl 
a520 cd 6e 8f				call malloc 
a523				if DEBUG_FORTH_MALLOC_GUARD 
a523 f5					push af 
a524 cd d0 8a				call ishlzero 
a527			;		ld a, l 
a527			;		add h 
a527			;		cp 0 
a527 f1					pop af 
a528					 
a528 cc e8 c3				call z,malloc_error 
a52b				endif 
a52b			 
a52b cd ae 98				call forth_push_numhl 
a52e					NEXTW 
a52e c3 17 9c			jp macro_next 
a531				endm 
# End of macro NEXTW
a531			 
a531			.FREE: 
a531				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a531 57				db WORD_SYS_CORE+67             
a532 62 a5			dw .LIST            
a534 05				db 4 + 1 
a535 .. 00			db "FREE",0              
a53a				endm 
# End of macro CWHEAD
a53a			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a53a					if DEBUG_FORTH_WORDS_KEY 
a53a						DMARK "FRE" 
a53a f5				push af  
a53b 3a 4f a5			ld a, (.dmark)  
a53e 32 c0 ee			ld (debug_mark),a  
a541 3a 50 a5			ld a, (.dmark+1)  
a544 32 c1 ee			ld (debug_mark+1),a  
a547 3a 51 a5			ld a, (.dmark+2)  
a54a 32 c2 ee			ld (debug_mark+2),a  
a54d 18 03			jr .pastdmark  
a54f ..			.dmark: db "FRE"  
a552 f1			.pastdmark: pop af  
a553			endm  
# End of macro DMARK
a553						CALLMONITOR 
a553 cd 21 93			call break_point_state  
a556				endm  
# End of macro CALLMONITOR
a556					endif 
a556					; get address 
a556			 
a556					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a556 cd a5 9a			call macro_dsp_valuehl 
a559				endm 
# End of macro FORTH_DSP_VALUEHL
a559			 
a559			;		push hl 
a559			 
a559					; destroy value TOS 
a559			 
a559					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a559 cd 5d 9b			call macro_forth_dsp_pop 
a55c				endm 
# End of macro FORTH_DSP_POP
a55c			 
a55c			;		pop hl 
a55c			if FORTH_ENABLE_MALLOCFREE 
a55c cd 38 90				call free 
a55f			endif 
a55f					NEXTW 
a55f c3 17 9c			jp macro_next 
a562				endm 
# End of macro NEXTW
a562			.LIST: 
a562				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a562 5c				db WORD_SYS_CORE+72             
a563 25 a7			dw .FORGET            
a565 05				db 4 + 1 
a566 .. 00			db "LIST",0              
a56b				endm 
# End of macro CWHEAD
a56b			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a56b			; | | The quoted word must be in upper case. 
a56b				if DEBUG_FORTH_WORDS_KEY 
a56b					DMARK "LST" 
a56b f5				push af  
a56c 3a 80 a5			ld a, (.dmark)  
a56f 32 c0 ee			ld (debug_mark),a  
a572 3a 81 a5			ld a, (.dmark+1)  
a575 32 c1 ee			ld (debug_mark+1),a  
a578 3a 82 a5			ld a, (.dmark+2)  
a57b 32 c2 ee			ld (debug_mark+2),a  
a57e 18 03			jr .pastdmark  
a580 ..			.dmark: db "LST"  
a583 f1			.pastdmark: pop af  
a584			endm  
# End of macro DMARK
a584					CALLMONITOR 
a584 cd 21 93			call break_point_state  
a587				endm  
# End of macro CALLMONITOR
a587				endif 
a587			 
a587					FORTH_DSP_VALUEHL 
a587 cd a5 9a			call macro_dsp_valuehl 
a58a				endm 
# End of macro FORTH_DSP_VALUEHL
a58a			 
a58a e5					push hl 
a58b c1					pop bc 
a58c			 
a58c			; Start format of scratch string 
a58c			 
a58c 21 e6 e4				ld hl, scratch 
a58f			 
a58f 3e 3a				ld a, ':' 
a591 77					ld (hl),a 
a592 23					inc hl 
a593 3e 20				ld a, ' ' 
a595 77					ld (hl), a 
a596			 
a596					; Get ptr to the word we need to look up 
a596			 
a596			;		FORTH_DSP_VALUEHL 
a596					;v5 FORTH_DSP_VALUE 
a596				; TODO type check 
a596			;		inc hl    ; Skip type check  
a596			;		push hl 
a596			;		ex de, hl    ; put into DE 
a596			 
a596			 
a596 21 33 d7				ld hl, baseram 
a599					;ld hl, baseusermem 
a599			 
a599 e5			push hl   ; sacreifical push 
a59a			 
a59a			.ldouscanm: 
a59a e1				pop hl 
a59b			.ldouscan: 
a59b				if DEBUG_FORTH_WORDS 
a59b					DMARK "LSs" 
a59b f5				push af  
a59c 3a b0 a5			ld a, (.dmark)  
a59f 32 c0 ee			ld (debug_mark),a  
a5a2 3a b1 a5			ld a, (.dmark+1)  
a5a5 32 c1 ee			ld (debug_mark+1),a  
a5a8 3a b2 a5			ld a, (.dmark+2)  
a5ab 32 c2 ee			ld (debug_mark+2),a  
a5ae 18 03			jr .pastdmark  
a5b0 ..			.dmark: db "LSs"  
a5b3 f1			.pastdmark: pop af  
a5b4			endm  
# End of macro DMARK
a5b4					CALLMONITOR 
a5b4 cd 21 93			call break_point_state  
a5b7				endm  
# End of macro CALLMONITOR
a5b7				endif 
a5b7				; skip dict stub 
a5b7 cd 68 9d				call forth_tok_next 
a5ba			 
a5ba			 
a5ba			; while we have words to look for 
a5ba			 
a5ba 7e				ld a, (hl)      
a5bb				if DEBUG_FORTH_WORDS 
a5bb					DMARK "LSk" 
a5bb f5				push af  
a5bc 3a d0 a5			ld a, (.dmark)  
a5bf 32 c0 ee			ld (debug_mark),a  
a5c2 3a d1 a5			ld a, (.dmark+1)  
a5c5 32 c1 ee			ld (debug_mark+1),a  
a5c8 3a d2 a5			ld a, (.dmark+2)  
a5cb 32 c2 ee			ld (debug_mark+2),a  
a5ce 18 03			jr .pastdmark  
a5d0 ..			.dmark: db "LSk"  
a5d3 f1			.pastdmark: pop af  
a5d4			endm  
# End of macro DMARK
a5d4					CALLMONITOR 
a5d4 cd 21 93			call break_point_state  
a5d7				endm  
# End of macro CALLMONITOR
a5d7				endif 
a5d7 fe 00				cp WORD_SYS_END 
a5d9 ca 0c a7				jp z, .lunotfound 
a5dc fe 01				cp WORD_SYS_UWORD 
a5de c2 9b a5				jp nz, .ldouscan 
a5e1			 
a5e1				if DEBUG_FORTH_WORDS 
a5e1					DMARK "LSu" 
a5e1 f5				push af  
a5e2 3a f6 a5			ld a, (.dmark)  
a5e5 32 c0 ee			ld (debug_mark),a  
a5e8 3a f7 a5			ld a, (.dmark+1)  
a5eb 32 c1 ee			ld (debug_mark+1),a  
a5ee 3a f8 a5			ld a, (.dmark+2)  
a5f1 32 c2 ee			ld (debug_mark+2),a  
a5f4 18 03			jr .pastdmark  
a5f6 ..			.dmark: db "LSu"  
a5f9 f1			.pastdmark: pop af  
a5fa			endm  
# End of macro DMARK
a5fa					CALLMONITOR 
a5fa cd 21 93			call break_point_state  
a5fd				endm  
# End of macro CALLMONITOR
a5fd				endif 
a5fd			 
a5fd					; found a uword but is it the one we want... 
a5fd			 
a5fd c5					push bc     ; uword to find is on bc 
a5fe d1					pop de 
a5ff			 
a5ff e5					push hl  ; to save the ptr 
a600			 
a600					; skip opcode 
a600 23					inc hl  
a601					; skip next ptr 
a601 23					inc hl  
a602 23					inc hl 
a603					; skip len 
a603 23					inc hl 
a604			 
a604				if DEBUG_FORTH_WORDS 
a604					DMARK "LSc" 
a604 f5				push af  
a605 3a 19 a6			ld a, (.dmark)  
a608 32 c0 ee			ld (debug_mark),a  
a60b 3a 1a a6			ld a, (.dmark+1)  
a60e 32 c1 ee			ld (debug_mark+1),a  
a611 3a 1b a6			ld a, (.dmark+2)  
a614 32 c2 ee			ld (debug_mark+2),a  
a617 18 03			jr .pastdmark  
a619 ..			.dmark: db "LSc"  
a61c f1			.pastdmark: pop af  
a61d			endm  
# End of macro DMARK
a61d					CALLMONITOR 
a61d cd 21 93			call break_point_state  
a620				endm  
# End of macro CALLMONITOR
a620				endif 
a620 cd 3d 8f				call strcmp 
a623 c2 9a a5				jp nz, .ldouscanm 
a626				 
a626			 
a626			 
a626					; we have a uword so push its name to the stack 
a626			 
a626			;	   	push hl  ; save so we can move to next dict block 
a626 e1			pop hl 
a627			 
a627				if DEBUG_FORTH_WORDS 
a627					DMARK "LSm" 
a627 f5				push af  
a628 3a 3c a6			ld a, (.dmark)  
a62b 32 c0 ee			ld (debug_mark),a  
a62e 3a 3d a6			ld a, (.dmark+1)  
a631 32 c1 ee			ld (debug_mark+1),a  
a634 3a 3e a6			ld a, (.dmark+2)  
a637 32 c2 ee			ld (debug_mark+2),a  
a63a 18 03			jr .pastdmark  
a63c ..			.dmark: db "LSm"  
a63f f1			.pastdmark: pop af  
a640			endm  
# End of macro DMARK
a640					CALLMONITOR 
a640 cd 21 93			call break_point_state  
a643				endm  
# End of macro CALLMONITOR
a643				endif 
a643			 
a643					; skip opcode 
a643 23					inc hl  
a644					; skip next ptr 
a644 23					inc hl  
a645 23					inc hl 
a646					; skip len 
a646 7e					ld a, (hl)   ; save length to add 
a647				if DEBUG_FORTH_WORDS 
a647					DMARK "LS2" 
a647 f5				push af  
a648 3a 5c a6			ld a, (.dmark)  
a64b 32 c0 ee			ld (debug_mark),a  
a64e 3a 5d a6			ld a, (.dmark+1)  
a651 32 c1 ee			ld (debug_mark+1),a  
a654 3a 5e a6			ld a, (.dmark+2)  
a657 32 c2 ee			ld (debug_mark+2),a  
a65a 18 03			jr .pastdmark  
a65c ..			.dmark: db "LS2"  
a65f f1			.pastdmark: pop af  
a660			endm  
# End of macro DMARK
a660					CALLMONITOR 
a660 cd 21 93			call break_point_state  
a663				endm  
# End of macro CALLMONITOR
a663				endif 
a663			 
a663					; save this location 
a663				 
a663 e5					push hl 
a664			 
a664 23					inc hl 
a665 11 e8 e4				ld de, scratch+2 
a668 4f					ld c, a 
a669 06 00				ld b, 0 
a66b			 
a66b				if DEBUG_FORTH_WORDS 
a66b					DMARK "LSn" 
a66b f5				push af  
a66c 3a 80 a6			ld a, (.dmark)  
a66f 32 c0 ee			ld (debug_mark),a  
a672 3a 81 a6			ld a, (.dmark+1)  
a675 32 c1 ee			ld (debug_mark+1),a  
a678 3a 82 a6			ld a, (.dmark+2)  
a67b 32 c2 ee			ld (debug_mark+2),a  
a67e 18 03			jr .pastdmark  
a680 ..			.dmark: db "LSn"  
a683 f1			.pastdmark: pop af  
a684			endm  
# End of macro DMARK
a684					CALLMONITOR 
a684 cd 21 93			call break_point_state  
a687				endm  
# End of macro CALLMONITOR
a687				endif 
a687			 
a687					; copy uword name to scratch 
a687			 
a687 ed b0				ldir 
a689			 
a689 1b					dec de 
a68a 3e 20				ld a, ' '    ; change null to space 
a68c 12					ld (de), a 
a68d			 
a68d 13					inc de 
a68e			 
a68e d5					push de 
a68f c1					pop bc     ; move scratch pointer to end of word name and save it 
a690			 
a690 e1					pop hl 
a691 7e					ld a, (hl) 
a692					;inc hl 
a692					; skip word string 
a692 cd a7 8a				call addatohl 
a695			 
a695 23					inc hl 
a696			 
a696				if DEBUG_FORTH_WORDS 
a696					DMARK "LS3" 
a696 f5				push af  
a697 3a ab a6			ld a, (.dmark)  
a69a 32 c0 ee			ld (debug_mark),a  
a69d 3a ac a6			ld a, (.dmark+1)  
a6a0 32 c1 ee			ld (debug_mark+1),a  
a6a3 3a ad a6			ld a, (.dmark+2)  
a6a6 32 c2 ee			ld (debug_mark+2),a  
a6a9 18 03			jr .pastdmark  
a6ab ..			.dmark: db "LS3"  
a6ae f1			.pastdmark: pop af  
a6af			endm  
# End of macro DMARK
a6af					CALLMONITOR 
a6af cd 21 93			call break_point_state  
a6b2				endm  
# End of macro CALLMONITOR
a6b2				endif 
a6b2					; should now be at the start of the machine code to setup the eval of the uword 
a6b2					; now locate the ptr to the string defintion 
a6b2			 
a6b2					; skip ld hl, 
a6b2					; then load the ptr 
a6b2			 
a6b2 23					inc hl 
a6b3 5e					ld e, (hl) 
a6b4 23					inc hl 
a6b5 56					ld d, (hl) 
a6b6 eb					ex de, hl 
a6b7			 
a6b7			 
a6b7				if DEBUG_FORTH_WORDS 
a6b7					DMARK "LSt" 
a6b7 f5				push af  
a6b8 3a cc a6			ld a, (.dmark)  
a6bb 32 c0 ee			ld (debug_mark),a  
a6be 3a cd a6			ld a, (.dmark+1)  
a6c1 32 c1 ee			ld (debug_mark+1),a  
a6c4 3a ce a6			ld a, (.dmark+2)  
a6c7 32 c2 ee			ld (debug_mark+2),a  
a6ca 18 03			jr .pastdmark  
a6cc ..			.dmark: db "LSt"  
a6cf f1			.pastdmark: pop af  
a6d0			endm  
# End of macro DMARK
a6d0					CALLMONITOR 
a6d0 cd 21 93			call break_point_state  
a6d3				endm  
# End of macro CALLMONITOR
a6d3				endif 
a6d3			 
a6d3			; cant push right now due to tokenised strings  
a6d3			 
a6d3			; get the destination of where to copy this definition to. 
a6d3			 
a6d3 c5					push bc 
a6d4 d1					pop de 
a6d5			 
a6d5 7e			.listl:         ld a,(hl) 
a6d6 fe 00				cp 0 
a6d8 28 09				jr z, .lreplsp     ; replace zero with space 
a6da fe 7f				cp FORTH_END_BUFFER 
a6dc 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a6de				 
a6de					; just copy this char as is then 
a6de			 
a6de 12					ld (de), a 
a6df			 
a6df 23			.listnxt:	inc hl 
a6e0 13					inc de 
a6e1 18 f2				jr .listl 
a6e3			 
a6e3 3e 20		.lreplsp:	ld a,' ' 
a6e5 12					ld (de), a 
a6e6 18 f7				jr .listnxt 
a6e8			 
a6e8			; close up uword def 
a6e8			 
a6e8			.listdone: 
a6e8 3e 00				ld a, 0 
a6ea 12					ld (de), a 
a6eb			 
a6eb			; now have def so clean up and push to stack 
a6eb			 
a6eb 21 e6 e4				ld hl, scratch 
a6ee				if DEBUG_FORTH_WORDS 
a6ee					DMARK "Ltp" 
a6ee f5				push af  
a6ef 3a 03 a7			ld a, (.dmark)  
a6f2 32 c0 ee			ld (debug_mark),a  
a6f5 3a 04 a7			ld a, (.dmark+1)  
a6f8 32 c1 ee			ld (debug_mark+1),a  
a6fb 3a 05 a7			ld a, (.dmark+2)  
a6fe 32 c2 ee			ld (debug_mark+2),a  
a701 18 03			jr .pastdmark  
a703 ..			.dmark: db "Ltp"  
a706 f1			.pastdmark: pop af  
a707			endm  
# End of macro DMARK
a707					CALLMONITOR 
a707 cd 21 93			call break_point_state  
a70a				endm  
# End of macro CALLMONITOR
a70a				endif 
a70a			 
a70a 18 06			jr .listpush 
a70c			 
a70c			;.lnuword:	pop hl 
a70c			;		call forth_tok_next 
a70c			;		jp .ldouscan  
a70c			 
a70c			.lunotfound:		  
a70c			 
a70c			 
a70c					 
a70c					FORTH_DSP_POP 
a70c cd 5d 9b			call macro_forth_dsp_pop 
a70f				endm 
# End of macro FORTH_DSP_POP
a70f 21 18 a7				ld hl, .luno 
a712						 
a712			 
a712			.listpush: 
a712 cd 1c 99				call forth_push_str 
a715			 
a715			 
a715			 
a715					NEXTW 
a715 c3 17 9c			jp macro_next 
a718				endm 
# End of macro NEXTW
a718			 
a718 .. 00		.luno:    db "Not found",0 
a722			 
a722			 
a722			 
a722			 
a722			 
a722			;		push hl   ; save pointer to start of uword def string 
a722			; 
a722			;; look for FORTH_EOL_LINE 
a722			;		ld a, FORTH_END_BUFFER 
a722			;		call strlent 
a722			; 
a722			;		inc hl		 ; space for coln def 
a722			;		inc hl 
a722			;		inc hl          ; space for terms 
a722			;		inc hl 
a722			; 
a722			;		ld a, 20   ; TODO get actual length 
a722			;		call addatohl    ; include a random amount of room for the uword name 
a722			; 
a722			;		 
a722			;	if DEBUG_FORTH_WORDS 
a722			;		DMARK "Lt1" 
a722			;		CALLMONITOR 
a722			;	endif 
a722			;		 
a722			; 
a722			;; malloc space for the string because we cant change it 
a722			; 
a722			;		call malloc 
a722			;	if DEBUG_FORTH_MALLOC_GUARD 
a722			;		push af 
a722			;		call ishlzero 
a722			;		pop af 
a722			;		 
a722			;		call z,malloc_error 
a722			;	endif 
a722			; 
a722			;	if DEBUG_FORTH_WORDS 
a722			;		DMARK "Lt2" 
a722			;		CALLMONITOR 
a722			;	endif 
a722			;		pop de 
a722			;		push hl    ; push the malloc to release later 
a722			;		push hl   ;  push back a copy for the later stack push 
a722			;		 
a722			;; copy the string swapping out the zero terms for spaces 
a722			; 
a722			;		; de has our source 
a722			;		; hl has our dest 
a722			; 
a722			;; add the coln def 
a722			; 
a722			;		ld a, ':' 
a722			;		ld (hl), a 
a722			;		inc hl 
a722			;		ld a, ' ' 
a722			;		ld (hl), a 
a722			;		inc hl 
a722			; 
a722			;; add the uname word 
a722			;		push de   ; save our string for now 
a722			;		ex de, hl 
a722			; 
a722			;		FORTH_DSP_VALUE 
a722			;		;v5 FORTH_DSP_VALUE 
a722			; 
a722			;		inc hl   ; skip type but we know by now this is OK 
a722			; 
a722			;.luword:	ld a,(hl) 
a722			;		cp 0 
a722			;		jr z, .luword2 
a722			;		ld (de), a 
a722			;		inc de 
a722			;		inc hl 
a722			;		jr .luword 
a722			; 
a722			;.luword2:	ld a, ' ' 
a722			;		ld (de), a 
a722			;;		inc hl 
a722			;;		inc de 
a722			;;		ld (de), a 
a722			;;		inc hl 
a722			;		inc de 
a722			; 
a722			;		ex de, hl 
a722			;		pop de 
a722			;		 
a722			;		 
a722			; 
a722			;; detoken that string and copy it 
a722			; 
a722			;	if DEBUG_FORTH_WORDS 
a722			;		DMARK "Lt2" 
a722			;		CALLMONITOR 
a722			;	endif 
a722			;.ldetok:	ld a, (de) 
a722			;		cp FORTH_END_BUFFER 
a722			;		jr z, .ldetokend 
a722			;		; swap out any zero term for space 
a722			;		cp 0 
a722			;		jr nz, .ldetoknext 
a722			;		ld a, ' ' 
a722			; 
a722			;	if DEBUG_FORTH_WORDS 
a722			;		DMARK "LtS" 
a722			;		CALLMONITOR 
a722			;	endif 
a722			;.ldetoknext:	ld (hl), a 
a722			;		inc de 
a722			;		inc hl 
a722			;		jr .ldetok 
a722			; 
a722			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a722			;		ld (hl), a  
a722			; 
a722			;; free that temp malloc 
a722			; 
a722			;		pop hl    
a722			; 
a722			;	if DEBUG_FORTH_WORDS 
a722			;		DMARK "Lt4" 
a722			;		CALLMONITOR 
a722			;	endif 
a722			;		call forth_apushstrhl 
a722			; 
a722			;		; get rid of temp malloc area 
a722			; 
a722			;		pop hl 
a722			;		call free 
a722			; 
a722			;		jr .ludone 
a722			; 
a722			;.lnuword:	pop hl 
a722			;		call forth_tok_next 
a722			;		jp .ldouscan  
a722			; 
a722			;.ludone:		 pop hl 
a722			; 
a722					NEXTW 
a722 c3 17 9c			jp macro_next 
a725				endm 
# End of macro NEXTW
a725			 
a725			.FORGET: 
a725				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a725 5d				db WORD_SYS_CORE+73             
a726 9e a7			dw .NOP            
a728 07				db 6 + 1 
a729 .. 00			db "FORGET",0              
a730				endm 
# End of macro CWHEAD
a730			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a730			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a730			; | |  
a730			; | | e.g. "MORE" forget 
a730					if DEBUG_FORTH_WORDS_KEY 
a730						DMARK "FRG" 
a730 f5				push af  
a731 3a 45 a7			ld a, (.dmark)  
a734 32 c0 ee			ld (debug_mark),a  
a737 3a 46 a7			ld a, (.dmark+1)  
a73a 32 c1 ee			ld (debug_mark+1),a  
a73d 3a 47 a7			ld a, (.dmark+2)  
a740 32 c2 ee			ld (debug_mark+2),a  
a743 18 03			jr .pastdmark  
a745 ..			.dmark: db "FRG"  
a748 f1			.pastdmark: pop af  
a749			endm  
# End of macro DMARK
a749						CALLMONITOR 
a749 cd 21 93			call break_point_state  
a74c				endm  
# End of macro CALLMONITOR
a74c					endif 
a74c			 
a74c				; find uword 
a74c			        ; update start of word with "_" 
a74c				; replace uword with deleted flag 
a74c			 
a74c			 
a74c			;	if DEBUG_FORTH_WORDS 
a74c			;		DMARK "FOG" 
a74c			;		CALLMONITOR 
a74c			;	endif 
a74c			 
a74c			 
a74c					; Get ptr to the word we need to look up 
a74c			 
a74c					FORTH_DSP_VALUEHL 
a74c cd a5 9a			call macro_dsp_valuehl 
a74f				endm 
# End of macro FORTH_DSP_VALUEHL
a74f					;v5 FORTH_DSP_VALUE 
a74f				; TODO type check 
a74f			;		inc hl    ; Skip type check  
a74f e5					push hl 
a750 c1					pop bc 
a751			;		ex de, hl    ; put into DE 
a751			 
a751			 
a751 21 33 d7				ld hl, baseram 
a754					;ld hl, baseusermem 
a754			 
a754				; skip dict stub 
a754			;	call forth_tok_next 
a754 e5			push hl   ; sacreifical push 
a755			 
a755			.fldouscanm: 
a755 e1				pop hl 
a756			.fldouscan: 
a756			;	if DEBUG_FORTH_WORDS 
a756			;		DMARK "LSs" 
a756			;		CALLMONITOR 
a756			;	endif 
a756				; skip dict stub 
a756 cd 68 9d				call forth_tok_next 
a759			 
a759			 
a759			; while we have words to look for 
a759			 
a759 7e				ld a, (hl)      
a75a			;	if DEBUG_FORTH_WORDS 
a75a			;		DMARK "LSk" 
a75a			;		CALLMONITOR 
a75a			;	endif 
a75a fe 00				cp WORD_SYS_END 
a75c ca 98 a7				jp z, .flunotfound 
a75f fe 01				cp WORD_SYS_UWORD 
a761 c2 56 a7				jp nz, .fldouscan 
a764			 
a764			;	if DEBUG_FORTH_WORDS 
a764			;		DMARK "LSu" 
a764			;		CALLMONITOR 
a764			;	endif 
a764			 
a764					; found a uword but is it the one we want... 
a764			 
a764 c5					push bc     ; uword to find is on bc 
a765 d1					pop de 
a766			 
a766 e5					push hl  ; to save the ptr 
a767			 
a767					; skip opcode 
a767 23					inc hl  
a768					; skip next ptr 
a768 23					inc hl  
a769 23					inc hl 
a76a					; skip len 
a76a 23					inc hl 
a76b			 
a76b			;	if DEBUG_FORTH_WORDS 
a76b			;		DMARK "LSc" 
a76b			;		CALLMONITOR 
a76b			;	endif 
a76b cd 3d 8f				call strcmp 
a76e c2 55 a7				jp nz, .fldouscanm 
a771			; 
a771			; 
a771			;; while we have words to look for 
a771			; 
a771			;.fdouscan:	ld a, (hl)      
a771			;	if DEBUG_FORTH_WORDS 
a771			;		DMARK "LSs" 
a771			;		CALLMONITOR 
a771			;	endif 
a771			;		cp WORD_SYS_END 
a771			;		jp z, .fudone 
a771			;		cp WORD_SYS_UWORD 
a771			;		jp nz, .fnuword 
a771			; 
a771			;	if DEBUG_FORTH_WORDS 
a771			;		DMARK "FGu" 
a771			;		CALLMONITOR 
a771			;	endif 
a771			; 
a771			;		; found a uword but is it the one we want... 
a771			; 
a771			; 
a771			;	        pop de   ; get back the dsp name 
a771			;		push de 
a771			; 
a771			;		push hl  ; to save the ptr 
a771			; 
a771			;		; skip opcode 
a771			;		inc hl  
a771			;		; skip next ptr 
a771			;		inc hl  
a771			;		inc hl 
a771			;		; skip len 
a771			;		inc hl 
a771			; 
a771			;	if DEBUG_FORTH_WORDS 
a771			;		DMARK "FGc" 
a771			;		CALLMONITOR 
a771			;	endif 
a771			;		call strcmp 
a771			;		jp nz, .fnuword 
a771			 
a771			 
a771 e1			pop hl 
a772			 
a772				 
a772				if DEBUG_FORTH_WORDS 
a772					DMARK "FGm" 
a772 f5				push af  
a773 3a 87 a7			ld a, (.dmark)  
a776 32 c0 ee			ld (debug_mark),a  
a779 3a 88 a7			ld a, (.dmark+1)  
a77c 32 c1 ee			ld (debug_mark+1),a  
a77f 3a 89 a7			ld a, (.dmark+2)  
a782 32 c2 ee			ld (debug_mark+2),a  
a785 18 03			jr .pastdmark  
a787 ..			.dmark: db "FGm"  
a78a f1			.pastdmark: pop af  
a78b			endm  
# End of macro DMARK
a78b					CALLMONITOR 
a78b cd 21 93			call break_point_state  
a78e				endm  
# End of macro CALLMONITOR
a78e				endif 
a78e			 
a78e			 
a78e			 
a78e					; we have a uword so push its name to the stack 
a78e			 
a78e			;	   	push hl  ; save so we can move to next dict block 
a78e			;pop hl 
a78e			 
a78e					; update opcode to deleted 
a78e 3e 03				ld a, WORD_SYS_DELETED 
a790 77					ld (hl), a 
a791			 
a791 23					inc hl  
a792					; skip next ptr 
a792 23					inc hl  
a793 23					inc hl 
a794					; skip len 
a794 23					inc hl 
a795			 
a795					; TODO change parser to skip deleted words but for now mark it out 
a795 3e 5f				ld a, "_" 
a797 77					ld  (hl),a 
a798			 
a798			;		jr .fudone 
a798			; 
a798			;.fnuword:	pop hl 
a798			;		call forth_tok_next 
a798			;		jp .fdouscan  
a798			 
a798			.flunotfound:		  
a798			 
a798			 
a798					 
a798					FORTH_DSP_POP 
a798 cd 5d 9b			call macro_forth_dsp_pop 
a79b				endm 
# End of macro FORTH_DSP_POP
a79b			;		ld hl, .luno 
a79b			;.fudone:		 pop hl 
a79b					NEXTW 
a79b c3 17 9c			jp macro_next 
a79e				endm 
# End of macro NEXTW
a79e			.NOP: 
a79e				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a79e 61				db WORD_SYS_CORE+77             
a79f c5 a7			dw .COMO            
a7a1 04				db 3 + 1 
a7a2 .. 00			db "NOP",0              
a7a6				endm 
# End of macro CWHEAD
a7a6			; | NOP (  --  ) Do nothing | DONE 
a7a6					if DEBUG_FORTH_WORDS_KEY 
a7a6						DMARK "NOP" 
a7a6 f5				push af  
a7a7 3a bb a7			ld a, (.dmark)  
a7aa 32 c0 ee			ld (debug_mark),a  
a7ad 3a bc a7			ld a, (.dmark+1)  
a7b0 32 c1 ee			ld (debug_mark+1),a  
a7b3 3a bd a7			ld a, (.dmark+2)  
a7b6 32 c2 ee			ld (debug_mark+2),a  
a7b9 18 03			jr .pastdmark  
a7bb ..			.dmark: db "NOP"  
a7be f1			.pastdmark: pop af  
a7bf			endm  
# End of macro DMARK
a7bf						CALLMONITOR 
a7bf cd 21 93			call break_point_state  
a7c2				endm  
# End of macro CALLMONITOR
a7c2					endif 
a7c2				       NEXTW 
a7c2 c3 17 9c			jp macro_next 
a7c5				endm 
# End of macro NEXTW
a7c5			.COMO: 
a7c5				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a7c5 6e				db WORD_SYS_CORE+90             
a7c6 17 a8			dw .COMC            
a7c8 02				db 1 + 1 
a7c9 .. 00			db "(",0              
a7cb				endm 
# End of macro CWHEAD
a7cb			; | ( ( -- )  Start of comment | DONE 
a7cb			 
a7cb			 
a7cb 2a e7 e7				ld hl, ( os_tok_ptr) 
a7ce 11 12 a8			ld de, .closepar 
a7d1					 
a7d1					if DEBUG_FORTH_WORDS 
a7d1						DMARK ").." 
a7d1 f5				push af  
a7d2 3a e6 a7			ld a, (.dmark)  
a7d5 32 c0 ee			ld (debug_mark),a  
a7d8 3a e7 a7			ld a, (.dmark+1)  
a7db 32 c1 ee			ld (debug_mark+1),a  
a7de 3a e8 a7			ld a, (.dmark+2)  
a7e1 32 c2 ee			ld (debug_mark+2),a  
a7e4 18 03			jr .pastdmark  
a7e6 ..			.dmark: db ").."  
a7e9 f1			.pastdmark: pop af  
a7ea			endm  
# End of macro DMARK
a7ea						CALLMONITOR 
a7ea cd 21 93			call break_point_state  
a7ed				endm  
# End of macro CALLMONITOR
a7ed					endif 
a7ed cd 32 9d			call findnexttok  
a7f0			 
a7f0					if DEBUG_FORTH_WORDS 
a7f0						DMARK "IF5" 
a7f0 f5				push af  
a7f1 3a 05 a8			ld a, (.dmark)  
a7f4 32 c0 ee			ld (debug_mark),a  
a7f7 3a 06 a8			ld a, (.dmark+1)  
a7fa 32 c1 ee			ld (debug_mark+1),a  
a7fd 3a 07 a8			ld a, (.dmark+2)  
a800 32 c2 ee			ld (debug_mark+2),a  
a803 18 03			jr .pastdmark  
a805 ..			.dmark: db "IF5"  
a808 f1			.pastdmark: pop af  
a809			endm  
# End of macro DMARK
a809						CALLMONITOR 
a809 cd 21 93			call break_point_state  
a80c				endm  
# End of macro CALLMONITOR
a80c					endif 
a80c				; replace below with ) exec using tok_ptr 
a80c 22 e7 e7			ld (os_tok_ptr), hl 
a80f c3 a8 9c			jp exec1 
a812			 
a812 .. 00			.closepar:   db ")",0 
a814			 
a814				       NEXTW 
a814 c3 17 9c			jp macro_next 
a817				endm 
# End of macro NEXTW
a817			.COMC: 
a817				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a817 6f				db WORD_SYS_CORE+91             
a818 20 a8			dw .SCRATCH            
a81a 02				db 1 + 1 
a81b .. 00			db ")",0              
a81d				endm 
# End of macro CWHEAD
a81d			; | ) ( -- )  End of comment |  DONE  
a81d				       NEXTW 
a81d c3 17 9c			jp macro_next 
a820				endm 
# End of macro NEXTW
a820			 
a820			.SCRATCH: 
a820				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a820 6f				db WORD_SYS_CORE+91             
a821 5b a8			dw .INC            
a823 08				db 7 + 1 
a824 .. 00			db "SCRATCH",0              
a82c				endm 
# End of macro CWHEAD
a82c			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a82c			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a82c			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a82c			; | |  
a82c			; | | e.g.    : score $00 scratch ; 
a82c			; | |  
a82c			; | | $00 score ! 
a82c			; | | $01 score +! 
a82c			; | |  
a82c			; | | e.g.   : varword $0a scratch ;  
a82c			; | | 
a82c			; | | $8000 varword ! 
a82c					if DEBUG_FORTH_WORDS_KEY 
a82c						DMARK "SCR" 
a82c f5				push af  
a82d 3a 41 a8			ld a, (.dmark)  
a830 32 c0 ee			ld (debug_mark),a  
a833 3a 42 a8			ld a, (.dmark+1)  
a836 32 c1 ee			ld (debug_mark+1),a  
a839 3a 43 a8			ld a, (.dmark+2)  
a83c 32 c2 ee			ld (debug_mark+2),a  
a83f 18 03			jr .pastdmark  
a841 ..			.dmark: db "SCR"  
a844 f1			.pastdmark: pop af  
a845			endm  
# End of macro DMARK
a845						CALLMONITOR 
a845 cd 21 93			call break_point_state  
a848				endm  
# End of macro CALLMONITOR
a848					endif 
a848			 
a848					FORTH_DSP_VALUEHL 
a848 cd a5 9a			call macro_dsp_valuehl 
a84b				endm 
# End of macro FORTH_DSP_VALUEHL
a84b				 
a84b					FORTH_DSP_POP 
a84b cd 5d 9b			call macro_forth_dsp_pop 
a84e				endm 
# End of macro FORTH_DSP_POP
a84e			 
a84e 7d					ld a, l 
a84f 21 0b ea				ld hl, os_var_array 
a852 cd a7 8a				call addatohl 
a855			 
a855 cd ae 98				call forth_push_numhl 
a858			 
a858				       NEXTW 
a858 c3 17 9c			jp macro_next 
a85b				endm 
# End of macro NEXTW
a85b			 
a85b			.INC: 
a85b				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a85b 6f				db WORD_SYS_CORE+91             
a85c af a8			dw .DEC            
a85e 03				db 2 + 1 
a85f .. 00			db "+!",0              
a862				endm 
# End of macro CWHEAD
a862			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a862					if DEBUG_FORTH_WORDS_KEY 
a862						DMARK "+s_" 
a862 f5				push af  
a863 3a 77 a8			ld a, (.dmark)  
a866 32 c0 ee			ld (debug_mark),a  
a869 3a 78 a8			ld a, (.dmark+1)  
a86c 32 c1 ee			ld (debug_mark+1),a  
a86f 3a 79 a8			ld a, (.dmark+2)  
a872 32 c2 ee			ld (debug_mark+2),a  
a875 18 03			jr .pastdmark  
a877 ..			.dmark: db "+s_"  
a87a f1			.pastdmark: pop af  
a87b			endm  
# End of macro DMARK
a87b						CALLMONITOR 
a87b cd 21 93			call break_point_state  
a87e				endm  
# End of macro CALLMONITOR
a87e					endif 
a87e			 
a87e					FORTH_DSP_VALUEHL 
a87e cd a5 9a			call macro_dsp_valuehl 
a881				endm 
# End of macro FORTH_DSP_VALUEHL
a881			 
a881 e5					push hl   ; save address 
a882			 
a882					FORTH_DSP_POP 
a882 cd 5d 9b			call macro_forth_dsp_pop 
a885				endm 
# End of macro FORTH_DSP_POP
a885			 
a885					FORTH_DSP_VALUEHL 
a885 cd a5 9a			call macro_dsp_valuehl 
a888				endm 
# End of macro FORTH_DSP_VALUEHL
a888			 
a888					FORTH_DSP_POP 
a888 cd 5d 9b			call macro_forth_dsp_pop 
a88b				endm 
# End of macro FORTH_DSP_POP
a88b			 
a88b					; hl contains value to add to byte at a 
a88b				 
a88b eb					ex de, hl 
a88c			 
a88c e1					pop hl 
a88d			 
a88d					if DEBUG_FORTH_WORDS 
a88d						DMARK "INC" 
a88d f5				push af  
a88e 3a a2 a8			ld a, (.dmark)  
a891 32 c0 ee			ld (debug_mark),a  
a894 3a a3 a8			ld a, (.dmark+1)  
a897 32 c1 ee			ld (debug_mark+1),a  
a89a 3a a4 a8			ld a, (.dmark+2)  
a89d 32 c2 ee			ld (debug_mark+2),a  
a8a0 18 03			jr .pastdmark  
a8a2 ..			.dmark: db "INC"  
a8a5 f1			.pastdmark: pop af  
a8a6			endm  
# End of macro DMARK
a8a6						CALLMONITOR 
a8a6 cd 21 93			call break_point_state  
a8a9				endm  
# End of macro CALLMONITOR
a8a9					endif 
a8a9			 
a8a9 7e					ld a,(hl) 
a8aa 83					add e 
a8ab 77					ld (hl),a 
a8ac			 
a8ac			 
a8ac			 
a8ac				       NEXTW 
a8ac c3 17 9c			jp macro_next 
a8af				endm 
# End of macro NEXTW
a8af			 
a8af			.DEC: 
a8af				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a8af 6f				db WORD_SYS_CORE+91             
a8b0 00 a9			dw .INC2            
a8b2 03				db 2 + 1 
a8b3 .. 00			db "-!",0              
a8b6				endm 
# End of macro CWHEAD
a8b6			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a8b6					if DEBUG_FORTH_WORDS_KEY 
a8b6						DMARK "-s_" 
a8b6 f5				push af  
a8b7 3a cb a8			ld a, (.dmark)  
a8ba 32 c0 ee			ld (debug_mark),a  
a8bd 3a cc a8			ld a, (.dmark+1)  
a8c0 32 c1 ee			ld (debug_mark+1),a  
a8c3 3a cd a8			ld a, (.dmark+2)  
a8c6 32 c2 ee			ld (debug_mark+2),a  
a8c9 18 03			jr .pastdmark  
a8cb ..			.dmark: db "-s_"  
a8ce f1			.pastdmark: pop af  
a8cf			endm  
# End of macro DMARK
a8cf						CALLMONITOR 
a8cf cd 21 93			call break_point_state  
a8d2				endm  
# End of macro CALLMONITOR
a8d2					endif 
a8d2			 
a8d2					FORTH_DSP_VALUEHL 
a8d2 cd a5 9a			call macro_dsp_valuehl 
a8d5				endm 
# End of macro FORTH_DSP_VALUEHL
a8d5			 
a8d5 e5					push hl   ; save address 
a8d6			 
a8d6					FORTH_DSP_POP 
a8d6 cd 5d 9b			call macro_forth_dsp_pop 
a8d9				endm 
# End of macro FORTH_DSP_POP
a8d9			 
a8d9					FORTH_DSP_VALUEHL 
a8d9 cd a5 9a			call macro_dsp_valuehl 
a8dc				endm 
# End of macro FORTH_DSP_VALUEHL
a8dc			 
a8dc					; hl contains value to add to byte at a 
a8dc				 
a8dc eb					ex de, hl 
a8dd			 
a8dd e1					pop hl 
a8de			 
a8de					if DEBUG_FORTH_WORDS 
a8de						DMARK "DEC" 
a8de f5				push af  
a8df 3a f3 a8			ld a, (.dmark)  
a8e2 32 c0 ee			ld (debug_mark),a  
a8e5 3a f4 a8			ld a, (.dmark+1)  
a8e8 32 c1 ee			ld (debug_mark+1),a  
a8eb 3a f5 a8			ld a, (.dmark+2)  
a8ee 32 c2 ee			ld (debug_mark+2),a  
a8f1 18 03			jr .pastdmark  
a8f3 ..			.dmark: db "DEC"  
a8f6 f1			.pastdmark: pop af  
a8f7			endm  
# End of macro DMARK
a8f7						CALLMONITOR 
a8f7 cd 21 93			call break_point_state  
a8fa				endm  
# End of macro CALLMONITOR
a8fa					endif 
a8fa			 
a8fa 7e					ld a,(hl) 
a8fb 93					sub e 
a8fc 77					ld (hl),a 
a8fd			 
a8fd			 
a8fd			 
a8fd				       NEXTW 
a8fd c3 17 9c			jp macro_next 
a900				endm 
# End of macro NEXTW
a900			 
a900			.INC2: 
a900				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a900 6f				db WORD_SYS_CORE+91             
a901 aa a9			dw .DEC2            
a903 04				db 3 + 1 
a904 .. 00			db "+2!",0              
a908				endm 
# End of macro CWHEAD
a908			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a908			 
a908					if DEBUG_FORTH_WORDS_KEY 
a908						DMARK "+2s" 
a908 f5				push af  
a909 3a 1d a9			ld a, (.dmark)  
a90c 32 c0 ee			ld (debug_mark),a  
a90f 3a 1e a9			ld a, (.dmark+1)  
a912 32 c1 ee			ld (debug_mark+1),a  
a915 3a 1f a9			ld a, (.dmark+2)  
a918 32 c2 ee			ld (debug_mark+2),a  
a91b 18 03			jr .pastdmark  
a91d ..			.dmark: db "+2s"  
a920 f1			.pastdmark: pop af  
a921			endm  
# End of macro DMARK
a921						CALLMONITOR 
a921 cd 21 93			call break_point_state  
a924				endm  
# End of macro CALLMONITOR
a924					endif 
a924			 
a924					; Address 
a924			 
a924					FORTH_DSP_VALUEHL 
a924 cd a5 9a			call macro_dsp_valuehl 
a927				endm 
# End of macro FORTH_DSP_VALUEHL
a927			 
a927 e5					push hl    ; save address 
a928			 
a928					; load content into de 
a928			 
a928 5e					ld e,(hl) 
a929 23					inc hl 
a92a 56					ld d, (hl) 
a92b			 
a92b					if DEBUG_FORTH_WORDS 
a92b						DMARK "+2a" 
a92b f5				push af  
a92c 3a 40 a9			ld a, (.dmark)  
a92f 32 c0 ee			ld (debug_mark),a  
a932 3a 41 a9			ld a, (.dmark+1)  
a935 32 c1 ee			ld (debug_mark+1),a  
a938 3a 42 a9			ld a, (.dmark+2)  
a93b 32 c2 ee			ld (debug_mark+2),a  
a93e 18 03			jr .pastdmark  
a940 ..			.dmark: db "+2a"  
a943 f1			.pastdmark: pop af  
a944			endm  
# End of macro DMARK
a944						CALLMONITOR 
a944 cd 21 93			call break_point_state  
a947				endm  
# End of macro CALLMONITOR
a947					endif 
a947			 
a947					FORTH_DSP_POP 
a947 cd 5d 9b			call macro_forth_dsp_pop 
a94a				endm 
# End of macro FORTH_DSP_POP
a94a			 
a94a					; Get value to add 
a94a			 
a94a					FORTH_DSP_VALUE 
a94a cd 8e 9a			call macro_forth_dsp_value 
a94d				endm 
# End of macro FORTH_DSP_VALUE
a94d			 
a94d					if DEBUG_FORTH_WORDS 
a94d						DMARK "+2v" 
a94d f5				push af  
a94e 3a 62 a9			ld a, (.dmark)  
a951 32 c0 ee			ld (debug_mark),a  
a954 3a 63 a9			ld a, (.dmark+1)  
a957 32 c1 ee			ld (debug_mark+1),a  
a95a 3a 64 a9			ld a, (.dmark+2)  
a95d 32 c2 ee			ld (debug_mark+2),a  
a960 18 03			jr .pastdmark  
a962 ..			.dmark: db "+2v"  
a965 f1			.pastdmark: pop af  
a966			endm  
# End of macro DMARK
a966						CALLMONITOR 
a966 cd 21 93			call break_point_state  
a969				endm  
# End of macro CALLMONITOR
a969					endif 
a969			 
a969 19					add hl, de 
a96a			 
a96a					if DEBUG_FORTH_WORDS 
a96a						DMARK "+2+" 
a96a f5				push af  
a96b 3a 7f a9			ld a, (.dmark)  
a96e 32 c0 ee			ld (debug_mark),a  
a971 3a 80 a9			ld a, (.dmark+1)  
a974 32 c1 ee			ld (debug_mark+1),a  
a977 3a 81 a9			ld a, (.dmark+2)  
a97a 32 c2 ee			ld (debug_mark+2),a  
a97d 18 03			jr .pastdmark  
a97f ..			.dmark: db "+2+"  
a982 f1			.pastdmark: pop af  
a983			endm  
# End of macro DMARK
a983						CALLMONITOR 
a983 cd 21 93			call break_point_state  
a986				endm  
# End of macro CALLMONITOR
a986					endif 
a986			 
a986					; move result to de 
a986			 
a986 eb					ex de, hl 
a987			 
a987					; Address 
a987			 
a987 e1					pop hl 
a988			 
a988					; save it back 
a988			 
a988 73					ld (hl), e 
a989 23					inc hl 
a98a 72					ld (hl), d 
a98b			 
a98b					if DEBUG_FORTH_WORDS 
a98b						DMARK "+2e" 
a98b f5				push af  
a98c 3a a0 a9			ld a, (.dmark)  
a98f 32 c0 ee			ld (debug_mark),a  
a992 3a a1 a9			ld a, (.dmark+1)  
a995 32 c1 ee			ld (debug_mark+1),a  
a998 3a a2 a9			ld a, (.dmark+2)  
a99b 32 c2 ee			ld (debug_mark+2),a  
a99e 18 03			jr .pastdmark  
a9a0 ..			.dmark: db "+2e"  
a9a3 f1			.pastdmark: pop af  
a9a4			endm  
# End of macro DMARK
a9a4						CALLMONITOR 
a9a4 cd 21 93			call break_point_state  
a9a7				endm  
# End of macro CALLMONITOR
a9a7					endif 
a9a7			 
a9a7			 
a9a7			 
a9a7			 
a9a7			 
a9a7				       NEXTW 
a9a7 c3 17 9c			jp macro_next 
a9aa				endm 
# End of macro NEXTW
a9aa			 
a9aa			.DEC2: 
a9aa				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a9aa 6f				db WORD_SYS_CORE+91             
a9ab 56 aa			dw .GET2            
a9ad 04				db 3 + 1 
a9ae .. 00			db "-2!",0              
a9b2				endm 
# End of macro CWHEAD
a9b2			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a9b2			 
a9b2			 
a9b2					if DEBUG_FORTH_WORDS_KEY 
a9b2						DMARK "-2s" 
a9b2 f5				push af  
a9b3 3a c7 a9			ld a, (.dmark)  
a9b6 32 c0 ee			ld (debug_mark),a  
a9b9 3a c8 a9			ld a, (.dmark+1)  
a9bc 32 c1 ee			ld (debug_mark+1),a  
a9bf 3a c9 a9			ld a, (.dmark+2)  
a9c2 32 c2 ee			ld (debug_mark+2),a  
a9c5 18 03			jr .pastdmark  
a9c7 ..			.dmark: db "-2s"  
a9ca f1			.pastdmark: pop af  
a9cb			endm  
# End of macro DMARK
a9cb						CALLMONITOR 
a9cb cd 21 93			call break_point_state  
a9ce				endm  
# End of macro CALLMONITOR
a9ce					endif 
a9ce			 
a9ce					; Address 
a9ce			 
a9ce					FORTH_DSP_VALUEHL 
a9ce cd a5 9a			call macro_dsp_valuehl 
a9d1				endm 
# End of macro FORTH_DSP_VALUEHL
a9d1			 
a9d1 e5					push hl    ; save address 
a9d2			 
a9d2					; load content into de 
a9d2			 
a9d2 5e					ld e,(hl) 
a9d3 23					inc hl 
a9d4 56					ld d, (hl) 
a9d5			 
a9d5					if DEBUG_FORTH_WORDS 
a9d5						DMARK "-2a" 
a9d5 f5				push af  
a9d6 3a ea a9			ld a, (.dmark)  
a9d9 32 c0 ee			ld (debug_mark),a  
a9dc 3a eb a9			ld a, (.dmark+1)  
a9df 32 c1 ee			ld (debug_mark+1),a  
a9e2 3a ec a9			ld a, (.dmark+2)  
a9e5 32 c2 ee			ld (debug_mark+2),a  
a9e8 18 03			jr .pastdmark  
a9ea ..			.dmark: db "-2a"  
a9ed f1			.pastdmark: pop af  
a9ee			endm  
# End of macro DMARK
a9ee						CALLMONITOR 
a9ee cd 21 93			call break_point_state  
a9f1				endm  
# End of macro CALLMONITOR
a9f1					endif 
a9f1			 
a9f1					FORTH_DSP_POP 
a9f1 cd 5d 9b			call macro_forth_dsp_pop 
a9f4				endm 
# End of macro FORTH_DSP_POP
a9f4			 
a9f4					; Get value to remove 
a9f4			 
a9f4					FORTH_DSP_VALUE 
a9f4 cd 8e 9a			call macro_forth_dsp_value 
a9f7				endm 
# End of macro FORTH_DSP_VALUE
a9f7			 
a9f7					if DEBUG_FORTH_WORDS 
a9f7						DMARK "-2v" 
a9f7 f5				push af  
a9f8 3a 0c aa			ld a, (.dmark)  
a9fb 32 c0 ee			ld (debug_mark),a  
a9fe 3a 0d aa			ld a, (.dmark+1)  
aa01 32 c1 ee			ld (debug_mark+1),a  
aa04 3a 0e aa			ld a, (.dmark+2)  
aa07 32 c2 ee			ld (debug_mark+2),a  
aa0a 18 03			jr .pastdmark  
aa0c ..			.dmark: db "-2v"  
aa0f f1			.pastdmark: pop af  
aa10			endm  
# End of macro DMARK
aa10						CALLMONITOR 
aa10 cd 21 93			call break_point_state  
aa13				endm  
# End of macro CALLMONITOR
aa13					endif 
aa13			 
aa13 eb					ex de, hl 
aa14 ed 52				sbc hl, de 
aa16			 
aa16					if DEBUG_FORTH_WORDS 
aa16						DMARK "-2d" 
aa16 f5				push af  
aa17 3a 2b aa			ld a, (.dmark)  
aa1a 32 c0 ee			ld (debug_mark),a  
aa1d 3a 2c aa			ld a, (.dmark+1)  
aa20 32 c1 ee			ld (debug_mark+1),a  
aa23 3a 2d aa			ld a, (.dmark+2)  
aa26 32 c2 ee			ld (debug_mark+2),a  
aa29 18 03			jr .pastdmark  
aa2b ..			.dmark: db "-2d"  
aa2e f1			.pastdmark: pop af  
aa2f			endm  
# End of macro DMARK
aa2f						CALLMONITOR 
aa2f cd 21 93			call break_point_state  
aa32				endm  
# End of macro CALLMONITOR
aa32					endif 
aa32			 
aa32					; move result to de 
aa32			 
aa32 eb					ex de, hl 
aa33			 
aa33					; Address 
aa33			 
aa33 e1					pop hl 
aa34			 
aa34					; save it back 
aa34			 
aa34 73					ld (hl), e 
aa35 23					inc hl 
aa36 72					ld (hl), d 
aa37			 
aa37					if DEBUG_FORTH_WORDS 
aa37						DMARK "-2e" 
aa37 f5				push af  
aa38 3a 4c aa			ld a, (.dmark)  
aa3b 32 c0 ee			ld (debug_mark),a  
aa3e 3a 4d aa			ld a, (.dmark+1)  
aa41 32 c1 ee			ld (debug_mark+1),a  
aa44 3a 4e aa			ld a, (.dmark+2)  
aa47 32 c2 ee			ld (debug_mark+2),a  
aa4a 18 03			jr .pastdmark  
aa4c ..			.dmark: db "-2e"  
aa4f f1			.pastdmark: pop af  
aa50			endm  
# End of macro DMARK
aa50						CALLMONITOR 
aa50 cd 21 93			call break_point_state  
aa53				endm  
# End of macro CALLMONITOR
aa53					endif 
aa53			 
aa53			 
aa53			 
aa53			 
aa53			 
aa53				       NEXTW 
aa53 c3 17 9c			jp macro_next 
aa56				endm 
# End of macro NEXTW
aa56			.GET2: 
aa56				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aa56 6f				db WORD_SYS_CORE+91             
aa57 86 aa			dw .BANG2            
aa59 03				db 2 + 1 
aa5a .. 00			db "2@",0              
aa5d				endm 
# End of macro CWHEAD
aa5d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aa5d					if DEBUG_FORTH_WORDS_KEY 
aa5d						DMARK "2A_" 
aa5d f5				push af  
aa5e 3a 72 aa			ld a, (.dmark)  
aa61 32 c0 ee			ld (debug_mark),a  
aa64 3a 73 aa			ld a, (.dmark+1)  
aa67 32 c1 ee			ld (debug_mark+1),a  
aa6a 3a 74 aa			ld a, (.dmark+2)  
aa6d 32 c2 ee			ld (debug_mark+2),a  
aa70 18 03			jr .pastdmark  
aa72 ..			.dmark: db "2A_"  
aa75 f1			.pastdmark: pop af  
aa76			endm  
# End of macro DMARK
aa76						CALLMONITOR 
aa76 cd 21 93			call break_point_state  
aa79				endm  
# End of macro CALLMONITOR
aa79					endif 
aa79			 
aa79					FORTH_DSP_VALUEHL 
aa79 cd a5 9a			call macro_dsp_valuehl 
aa7c				endm 
# End of macro FORTH_DSP_VALUEHL
aa7c			 
aa7c 5e					ld e, (hl) 
aa7d 23					inc hl 
aa7e 56					ld d, (hl) 
aa7f			 
aa7f eb					ex de, hl 
aa80			 
aa80 cd ae 98				call forth_push_numhl 
aa83			 
aa83				       NEXTW 
aa83 c3 17 9c			jp macro_next 
aa86				endm 
# End of macro NEXTW
aa86			.BANG2: 
aa86				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
aa86 6f				db WORD_SYS_CORE+91             
aa87 be aa			dw .CONFIG            
aa89 03				db 2 + 1 
aa8a .. 00			db "2!",0              
aa8d				endm 
# End of macro CWHEAD
aa8d			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
aa8d					if DEBUG_FORTH_WORDS_KEY 
aa8d						DMARK "2S_" 
aa8d f5				push af  
aa8e 3a a2 aa			ld a, (.dmark)  
aa91 32 c0 ee			ld (debug_mark),a  
aa94 3a a3 aa			ld a, (.dmark+1)  
aa97 32 c1 ee			ld (debug_mark+1),a  
aa9a 3a a4 aa			ld a, (.dmark+2)  
aa9d 32 c2 ee			ld (debug_mark+2),a  
aaa0 18 03			jr .pastdmark  
aaa2 ..			.dmark: db "2S_"  
aaa5 f1			.pastdmark: pop af  
aaa6			endm  
# End of macro DMARK
aaa6						CALLMONITOR 
aaa6 cd 21 93			call break_point_state  
aaa9				endm  
# End of macro CALLMONITOR
aaa9					endif 
aaa9			 
aaa9					FORTH_DSP_VALUEHL 
aaa9 cd a5 9a			call macro_dsp_valuehl 
aaac				endm 
# End of macro FORTH_DSP_VALUEHL
aaac			 
aaac e5					push hl   ; save address 
aaad			 
aaad			 
aaad					FORTH_DSP_POP 
aaad cd 5d 9b			call macro_forth_dsp_pop 
aab0				endm 
# End of macro FORTH_DSP_POP
aab0			 
aab0					 
aab0					FORTH_DSP_VALUEHL 
aab0 cd a5 9a			call macro_dsp_valuehl 
aab3				endm 
# End of macro FORTH_DSP_VALUEHL
aab3			 
aab3					FORTH_DSP_POP 
aab3 cd 5d 9b			call macro_forth_dsp_pop 
aab6				endm 
# End of macro FORTH_DSP_POP
aab6			 
aab6 eb					ex de, hl    ; value now in de 
aab7			 
aab7 e1					pop hl 
aab8			 
aab8 73					ld (hl), e 
aab9			 
aab9 23					inc hl 
aaba			 
aaba 72					ld (hl), d 
aabb			 
aabb			 
aabb				       NEXTW 
aabb c3 17 9c			jp macro_next 
aabe				endm 
# End of macro NEXTW
aabe			.CONFIG: 
aabe				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
aabe 6f				db WORD_SYS_CORE+91             
aabf cf aa			dw .ENDCORE            
aac1 07				db 6 + 1 
aac2 .. 00			db "CONFIG",0              
aac9				endm 
# End of macro CWHEAD
aac9			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
aac9			 
aac9 cd 07 91				call config 
aacc					NEXTW 
aacc c3 17 9c			jp macro_next 
aacf				endm 
# End of macro NEXTW
aacf			.ENDCORE: 
aacf			 
aacf			; eof 
aacf			 
aacf			 
# End of file forth_words_core.asm
aacf			include "forth_words_flow.asm" 
aacf			 
aacf			; | ## Program Flow Words 
aacf			 
aacf			.IF: 
aacf				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
aacf 1e				db WORD_SYS_CORE+10             
aad0 c4 ab			dw .THEN            
aad2 03				db 2 + 1 
aad3 .. 00			db "IF",0              
aad6				endm 
# End of macro CWHEAD
aad6			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
aad6			; 
aad6					if DEBUG_FORTH_WORDS_KEY 
aad6						DMARK "IF." 
aad6 f5				push af  
aad7 3a eb aa			ld a, (.dmark)  
aada 32 c0 ee			ld (debug_mark),a  
aadd 3a ec aa			ld a, (.dmark+1)  
aae0 32 c1 ee			ld (debug_mark+1),a  
aae3 3a ed aa			ld a, (.dmark+2)  
aae6 32 c2 ee			ld (debug_mark+2),a  
aae9 18 03			jr .pastdmark  
aaeb ..			.dmark: db "IF."  
aaee f1			.pastdmark: pop af  
aaef			endm  
# End of macro DMARK
aaef						CALLMONITOR 
aaef cd 21 93			call break_point_state  
aaf2				endm  
# End of macro CALLMONITOR
aaf2					endif 
aaf2			; eval TOS 
aaf2			 
aaf2				FORTH_DSP_VALUEHL 
aaf2 cd a5 9a			call macro_dsp_valuehl 
aaf5				endm 
# End of macro FORTH_DSP_VALUEHL
aaf5			 
aaf5			;	push hl 
aaf5				FORTH_DSP_POP 
aaf5 cd 5d 9b			call macro_forth_dsp_pop 
aaf8				endm 
# End of macro FORTH_DSP_POP
aaf8			;	pop hl 
aaf8			 
aaf8					if DEBUG_FORTH_WORDS 
aaf8						DMARK "IF1" 
aaf8 f5				push af  
aaf9 3a 0d ab			ld a, (.dmark)  
aafc 32 c0 ee			ld (debug_mark),a  
aaff 3a 0e ab			ld a, (.dmark+1)  
ab02 32 c1 ee			ld (debug_mark+1),a  
ab05 3a 0f ab			ld a, (.dmark+2)  
ab08 32 c2 ee			ld (debug_mark+2),a  
ab0b 18 03			jr .pastdmark  
ab0d ..			.dmark: db "IF1"  
ab10 f1			.pastdmark: pop af  
ab11			endm  
# End of macro DMARK
ab11						CALLMONITOR 
ab11 cd 21 93			call break_point_state  
ab14				endm  
# End of macro CALLMONITOR
ab14					endif 
ab14 b7				or a        ; clear carry flag 
ab15 11 00 00			ld de, 0 
ab18 eb				ex de,hl 
ab19 ed 52			sbc hl, de 
ab1b c2 a5 ab			jp nz, .iftrue 
ab1e			 
ab1e					if DEBUG_FORTH_WORDS 
ab1e						DMARK "IF2" 
ab1e f5				push af  
ab1f 3a 33 ab			ld a, (.dmark)  
ab22 32 c0 ee			ld (debug_mark),a  
ab25 3a 34 ab			ld a, (.dmark+1)  
ab28 32 c1 ee			ld (debug_mark+1),a  
ab2b 3a 35 ab			ld a, (.dmark+2)  
ab2e 32 c2 ee			ld (debug_mark+2),a  
ab31 18 03			jr .pastdmark  
ab33 ..			.dmark: db "IF2"  
ab36 f1			.pastdmark: pop af  
ab37			endm  
# End of macro DMARK
ab37						CALLMONITOR 
ab37 cd 21 93			call break_point_state  
ab3a				endm  
# End of macro CALLMONITOR
ab3a					endif 
ab3a			 
ab3a			; if not true then skip to THEN 
ab3a			 
ab3a				; TODO get tok_ptr 
ab3a				; TODO consume toks until we get to THEN 
ab3a			 
ab3a 2a e7 e7			ld hl, (os_tok_ptr) 
ab3d					if DEBUG_FORTH_WORDS 
ab3d						DMARK "IF3" 
ab3d f5				push af  
ab3e 3a 52 ab			ld a, (.dmark)  
ab41 32 c0 ee			ld (debug_mark),a  
ab44 3a 53 ab			ld a, (.dmark+1)  
ab47 32 c1 ee			ld (debug_mark+1),a  
ab4a 3a 54 ab			ld a, (.dmark+2)  
ab4d 32 c2 ee			ld (debug_mark+2),a  
ab50 18 03			jr .pastdmark  
ab52 ..			.dmark: db "IF3"  
ab55 f1			.pastdmark: pop af  
ab56			endm  
# End of macro DMARK
ab56						CALLMONITOR 
ab56 cd 21 93			call break_point_state  
ab59				endm  
# End of macro CALLMONITOR
ab59						 
ab59					endif 
ab59 11 a0 ab			ld de, .ifthen 
ab5c					if DEBUG_FORTH_WORDS 
ab5c						DMARK "IF4" 
ab5c f5				push af  
ab5d 3a 71 ab			ld a, (.dmark)  
ab60 32 c0 ee			ld (debug_mark),a  
ab63 3a 72 ab			ld a, (.dmark+1)  
ab66 32 c1 ee			ld (debug_mark+1),a  
ab69 3a 73 ab			ld a, (.dmark+2)  
ab6c 32 c2 ee			ld (debug_mark+2),a  
ab6f 18 03			jr .pastdmark  
ab71 ..			.dmark: db "IF4"  
ab74 f1			.pastdmark: pop af  
ab75			endm  
# End of macro DMARK
ab75						CALLMONITOR 
ab75 cd 21 93			call break_point_state  
ab78				endm  
# End of macro CALLMONITOR
ab78					endif 
ab78 cd 32 9d			call findnexttok  
ab7b			 
ab7b					if DEBUG_FORTH_WORDS 
ab7b						DMARK "IF5" 
ab7b f5				push af  
ab7c 3a 90 ab			ld a, (.dmark)  
ab7f 32 c0 ee			ld (debug_mark),a  
ab82 3a 91 ab			ld a, (.dmark+1)  
ab85 32 c1 ee			ld (debug_mark+1),a  
ab88 3a 92 ab			ld a, (.dmark+2)  
ab8b 32 c2 ee			ld (debug_mark+2),a  
ab8e 18 03			jr .pastdmark  
ab90 ..			.dmark: db "IF5"  
ab93 f1			.pastdmark: pop af  
ab94			endm  
# End of macro DMARK
ab94						CALLMONITOR 
ab94 cd 21 93			call break_point_state  
ab97				endm  
# End of macro CALLMONITOR
ab97					endif 
ab97				; TODO replace below with ; exec using tok_ptr 
ab97 22 e7 e7			ld (os_tok_ptr), hl 
ab9a c3 a8 9c			jp exec1 
ab9d				NEXTW 
ab9d c3 17 9c			jp macro_next 
aba0				endm 
# End of macro NEXTW
aba0			 
aba0 .. 00		.ifthen:  db "THEN",0 
aba5			 
aba5			.iftrue:		 
aba5				; Exec next words normally 
aba5			 
aba5				; if true then exec following IF as normal 
aba5					if DEBUG_FORTH_WORDS 
aba5						DMARK "IFT" 
aba5 f5				push af  
aba6 3a ba ab			ld a, (.dmark)  
aba9 32 c0 ee			ld (debug_mark),a  
abac 3a bb ab			ld a, (.dmark+1)  
abaf 32 c1 ee			ld (debug_mark+1),a  
abb2 3a bc ab			ld a, (.dmark+2)  
abb5 32 c2 ee			ld (debug_mark+2),a  
abb8 18 03			jr .pastdmark  
abba ..			.dmark: db "IFT"  
abbd f1			.pastdmark: pop af  
abbe			endm  
# End of macro DMARK
abbe						CALLMONITOR 
abbe cd 21 93			call break_point_state  
abc1				endm  
# End of macro CALLMONITOR
abc1					endif 
abc1			 
abc1					NEXTW 
abc1 c3 17 9c			jp macro_next 
abc4				endm 
# End of macro NEXTW
abc4			.THEN: 
abc4				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
abc4 1f				db WORD_SYS_CORE+11             
abc5 ec ab			dw .ELSE            
abc7 05				db 4 + 1 
abc8 .. 00			db "THEN",0              
abcd				endm 
# End of macro CWHEAD
abcd			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
abcd					if DEBUG_FORTH_WORDS_KEY 
abcd						DMARK "THN" 
abcd f5				push af  
abce 3a e2 ab			ld a, (.dmark)  
abd1 32 c0 ee			ld (debug_mark),a  
abd4 3a e3 ab			ld a, (.dmark+1)  
abd7 32 c1 ee			ld (debug_mark+1),a  
abda 3a e4 ab			ld a, (.dmark+2)  
abdd 32 c2 ee			ld (debug_mark+2),a  
abe0 18 03			jr .pastdmark  
abe2 ..			.dmark: db "THN"  
abe5 f1			.pastdmark: pop af  
abe6			endm  
# End of macro DMARK
abe6						CALLMONITOR 
abe6 cd 21 93			call break_point_state  
abe9				endm  
# End of macro CALLMONITOR
abe9					endif 
abe9					NEXTW 
abe9 c3 17 9c			jp macro_next 
abec				endm 
# End of macro NEXTW
abec			.ELSE: 
abec				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
abec 20				db WORD_SYS_CORE+12             
abed 14 ac			dw .DO            
abef 03				db 2 + 1 
abf0 .. 00			db "ELSE",0              
abf5				endm 
# End of macro CWHEAD
abf5			; | ELSE ( -- ) Not supported - does nothing | TODO 
abf5			 
abf5					if DEBUG_FORTH_WORDS_KEY 
abf5						DMARK "ELS" 
abf5 f5				push af  
abf6 3a 0a ac			ld a, (.dmark)  
abf9 32 c0 ee			ld (debug_mark),a  
abfc 3a 0b ac			ld a, (.dmark+1)  
abff 32 c1 ee			ld (debug_mark+1),a  
ac02 3a 0c ac			ld a, (.dmark+2)  
ac05 32 c2 ee			ld (debug_mark+2),a  
ac08 18 03			jr .pastdmark  
ac0a ..			.dmark: db "ELS"  
ac0d f1			.pastdmark: pop af  
ac0e			endm  
# End of macro DMARK
ac0e						CALLMONITOR 
ac0e cd 21 93			call break_point_state  
ac11				endm  
# End of macro CALLMONITOR
ac11					endif 
ac11			 
ac11			 
ac11					NEXTW 
ac11 c3 17 9c			jp macro_next 
ac14				endm 
# End of macro NEXTW
ac14			.DO: 
ac14				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ac14 21				db WORD_SYS_CORE+13             
ac15 3b ad			dw .LOOP            
ac17 03				db 2 + 1 
ac18 .. 00			db "DO",0              
ac1b				endm 
# End of macro CWHEAD
ac1b			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ac1b			 
ac1b					if DEBUG_FORTH_WORDS_KEY 
ac1b						DMARK "DO." 
ac1b f5				push af  
ac1c 3a 30 ac			ld a, (.dmark)  
ac1f 32 c0 ee			ld (debug_mark),a  
ac22 3a 31 ac			ld a, (.dmark+1)  
ac25 32 c1 ee			ld (debug_mark+1),a  
ac28 3a 32 ac			ld a, (.dmark+2)  
ac2b 32 c2 ee			ld (debug_mark+2),a  
ac2e 18 03			jr .pastdmark  
ac30 ..			.dmark: db "DO."  
ac33 f1			.pastdmark: pop af  
ac34			endm  
# End of macro DMARK
ac34						CALLMONITOR 
ac34 cd 21 93			call break_point_state  
ac37				endm  
# End of macro CALLMONITOR
ac37					endif 
ac37			;  push pc to rsp stack past the DO 
ac37			 
ac37 2a e7 e7				ld hl, (os_tok_ptr) 
ac3a 23					inc hl   ; D 
ac3b 23					inc hl  ; O 
ac3c 23					inc hl   ; null 
ac3d					if DEBUG_FORTH_WORDS 
ac3d						DMARK "DO2" 
ac3d f5				push af  
ac3e 3a 52 ac			ld a, (.dmark)  
ac41 32 c0 ee			ld (debug_mark),a  
ac44 3a 53 ac			ld a, (.dmark+1)  
ac47 32 c1 ee			ld (debug_mark+1),a  
ac4a 3a 54 ac			ld a, (.dmark+2)  
ac4d 32 c2 ee			ld (debug_mark+2),a  
ac50 18 03			jr .pastdmark  
ac52 ..			.dmark: db "DO2"  
ac55 f1			.pastdmark: pop af  
ac56			endm  
# End of macro DMARK
ac56						CALLMONITOR 
ac56 cd 21 93			call break_point_state  
ac59				endm  
# End of macro CALLMONITOR
ac59					endif 
ac59					FORTH_RSP_NEXT 
ac59 cd 55 98			call macro_forth_rsp_next 
ac5c				endm 
# End of macro FORTH_RSP_NEXT
ac5c					if DEBUG_FORTH_WORDS 
ac5c						DMARK "DO3" 
ac5c f5				push af  
ac5d 3a 71 ac			ld a, (.dmark)  
ac60 32 c0 ee			ld (debug_mark),a  
ac63 3a 72 ac			ld a, (.dmark+1)  
ac66 32 c1 ee			ld (debug_mark+1),a  
ac69 3a 73 ac			ld a, (.dmark+2)  
ac6c 32 c2 ee			ld (debug_mark+2),a  
ac6f 18 03			jr .pastdmark  
ac71 ..			.dmark: db "DO3"  
ac74 f1			.pastdmark: pop af  
ac75			endm  
# End of macro DMARK
ac75						CALLMONITOR 
ac75 cd 21 93			call break_point_state  
ac78				endm  
# End of macro CALLMONITOR
ac78					endif 
ac78			 
ac78					;if DEBUG_FORTH_WORDS 
ac78				;		push hl 
ac78			;		endif  
ac78			 
ac78			; get counters from data stack 
ac78			 
ac78			 
ac78					FORTH_DSP_VALUEHL 
ac78 cd a5 9a			call macro_dsp_valuehl 
ac7b				endm 
# End of macro FORTH_DSP_VALUEHL
ac7b e5					push hl		 ; hl now has starting counter which needs to be tos 
ac7c			 
ac7c					if DEBUG_FORTH_WORDS 
ac7c						DMARK "DO4" 
ac7c f5				push af  
ac7d 3a 91 ac			ld a, (.dmark)  
ac80 32 c0 ee			ld (debug_mark),a  
ac83 3a 92 ac			ld a, (.dmark+1)  
ac86 32 c1 ee			ld (debug_mark+1),a  
ac89 3a 93 ac			ld a, (.dmark+2)  
ac8c 32 c2 ee			ld (debug_mark+2),a  
ac8f 18 03			jr .pastdmark  
ac91 ..			.dmark: db "DO4"  
ac94 f1			.pastdmark: pop af  
ac95			endm  
# End of macro DMARK
ac95						CALLMONITOR 
ac95 cd 21 93			call break_point_state  
ac98				endm  
# End of macro CALLMONITOR
ac98					endif 
ac98					FORTH_DSP_POP 
ac98 cd 5d 9b			call macro_forth_dsp_pop 
ac9b				endm 
# End of macro FORTH_DSP_POP
ac9b			 
ac9b					if DEBUG_FORTH_WORDS 
ac9b						DMARK "DO5" 
ac9b f5				push af  
ac9c 3a b0 ac			ld a, (.dmark)  
ac9f 32 c0 ee			ld (debug_mark),a  
aca2 3a b1 ac			ld a, (.dmark+1)  
aca5 32 c1 ee			ld (debug_mark+1),a  
aca8 3a b2 ac			ld a, (.dmark+2)  
acab 32 c2 ee			ld (debug_mark+2),a  
acae 18 03			jr .pastdmark  
acb0 ..			.dmark: db "DO5"  
acb3 f1			.pastdmark: pop af  
acb4			endm  
# End of macro DMARK
acb4						CALLMONITOR 
acb4 cd 21 93			call break_point_state  
acb7				endm  
# End of macro CALLMONITOR
acb7					endif 
acb7			 
acb7					FORTH_DSP_VALUEHL 
acb7 cd a5 9a			call macro_dsp_valuehl 
acba				endm 
# End of macro FORTH_DSP_VALUEHL
acba			;		push hl		 ; hl now has starting limit counter 
acba			 
acba					if DEBUG_FORTH_WORDS 
acba						DMARK "DO6" 
acba f5				push af  
acbb 3a cf ac			ld a, (.dmark)  
acbe 32 c0 ee			ld (debug_mark),a  
acc1 3a d0 ac			ld a, (.dmark+1)  
acc4 32 c1 ee			ld (debug_mark+1),a  
acc7 3a d1 ac			ld a, (.dmark+2)  
acca 32 c2 ee			ld (debug_mark+2),a  
accd 18 03			jr .pastdmark  
accf ..			.dmark: db "DO6"  
acd2 f1			.pastdmark: pop af  
acd3			endm  
# End of macro DMARK
acd3						CALLMONITOR 
acd3 cd 21 93			call break_point_state  
acd6				endm  
# End of macro CALLMONITOR
acd6					endif 
acd6					FORTH_DSP_POP 
acd6 cd 5d 9b			call macro_forth_dsp_pop 
acd9				endm 
# End of macro FORTH_DSP_POP
acd9			 
acd9			; put counters on the loop stack 
acd9			 
acd9			;		pop hl			 ; limit counter 
acd9 d1					pop de			; start counter 
acda			 
acda					; push limit counter 
acda			 
acda					if DEBUG_FORTH_WORDS 
acda						DMARK "DO7" 
acda f5				push af  
acdb 3a ef ac			ld a, (.dmark)  
acde 32 c0 ee			ld (debug_mark),a  
ace1 3a f0 ac			ld a, (.dmark+1)  
ace4 32 c1 ee			ld (debug_mark+1),a  
ace7 3a f1 ac			ld a, (.dmark+2)  
acea 32 c2 ee			ld (debug_mark+2),a  
aced 18 03			jr .pastdmark  
acef ..			.dmark: db "DO7"  
acf2 f1			.pastdmark: pop af  
acf3			endm  
# End of macro DMARK
acf3						CALLMONITOR 
acf3 cd 21 93			call break_point_state  
acf6				endm  
# End of macro CALLMONITOR
acf6					endif 
acf6					FORTH_LOOP_NEXT 
acf6 cd d6 9a			call macro_forth_loop_next 
acf9				endm 
# End of macro FORTH_LOOP_NEXT
acf9			 
acf9					; push start counter 
acf9			 
acf9 eb					ex de, hl 
acfa					if DEBUG_FORTH_WORDS 
acfa						DMARK "DO7" 
acfa f5				push af  
acfb 3a 0f ad			ld a, (.dmark)  
acfe 32 c0 ee			ld (debug_mark),a  
ad01 3a 10 ad			ld a, (.dmark+1)  
ad04 32 c1 ee			ld (debug_mark+1),a  
ad07 3a 11 ad			ld a, (.dmark+2)  
ad0a 32 c2 ee			ld (debug_mark+2),a  
ad0d 18 03			jr .pastdmark  
ad0f ..			.dmark: db "DO7"  
ad12 f1			.pastdmark: pop af  
ad13			endm  
# End of macro DMARK
ad13						CALLMONITOR 
ad13 cd 21 93			call break_point_state  
ad16				endm  
# End of macro CALLMONITOR
ad16					endif 
ad16					FORTH_LOOP_NEXT 
ad16 cd d6 9a			call macro_forth_loop_next 
ad19				endm 
# End of macro FORTH_LOOP_NEXT
ad19			 
ad19			 
ad19					; init first round of I counter 
ad19			 
ad19 22 0b e8				ld (os_current_i), hl 
ad1c			 
ad1c					if DEBUG_FORTH_WORDS 
ad1c						DMARK "DO8" 
ad1c f5				push af  
ad1d 3a 31 ad			ld a, (.dmark)  
ad20 32 c0 ee			ld (debug_mark),a  
ad23 3a 32 ad			ld a, (.dmark+1)  
ad26 32 c1 ee			ld (debug_mark+1),a  
ad29 3a 33 ad			ld a, (.dmark+2)  
ad2c 32 c2 ee			ld (debug_mark+2),a  
ad2f 18 03			jr .pastdmark  
ad31 ..			.dmark: db "DO8"  
ad34 f1			.pastdmark: pop af  
ad35			endm  
# End of macro DMARK
ad35						CALLMONITOR 
ad35 cd 21 93			call break_point_state  
ad38				endm  
# End of macro CALLMONITOR
ad38					endif 
ad38			 
ad38					NEXTW 
ad38 c3 17 9c			jp macro_next 
ad3b				endm 
# End of macro NEXTW
ad3b			.LOOP: 
ad3b				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ad3b 22				db WORD_SYS_CORE+14             
ad3c 53 ae			dw .I            
ad3e 05				db 4 + 1 
ad3f .. 00			db "LOOP",0              
ad44				endm 
# End of macro CWHEAD
ad44			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ad44			 
ad44				; pop tos as current loop count to hl 
ad44			 
ad44				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ad44			 
ad44				FORTH_LOOP_TOS 
ad44 cd 09 9b			call macro_forth_loop_tos 
ad47				endm 
# End of macro FORTH_LOOP_TOS
ad47 e5				push hl 
ad48			 
ad48					if DEBUG_FORTH_WORDS_KEY 
ad48						DMARK "LOP" 
ad48 f5				push af  
ad49 3a 5d ad			ld a, (.dmark)  
ad4c 32 c0 ee			ld (debug_mark),a  
ad4f 3a 5e ad			ld a, (.dmark+1)  
ad52 32 c1 ee			ld (debug_mark+1),a  
ad55 3a 5f ad			ld a, (.dmark+2)  
ad58 32 c2 ee			ld (debug_mark+2),a  
ad5b 18 03			jr .pastdmark  
ad5d ..			.dmark: db "LOP"  
ad60 f1			.pastdmark: pop af  
ad61			endm  
# End of macro DMARK
ad61						CALLMONITOR 
ad61 cd 21 93			call break_point_state  
ad64				endm  
# End of macro CALLMONITOR
ad64					endif 
ad64				; next item on the stack is the limit. get it 
ad64			 
ad64			 
ad64				FORTH_LOOP_POP 
ad64 cd 13 9b			call macro_forth_loop_pop 
ad67				endm 
# End of macro FORTH_LOOP_POP
ad67			 
ad67				FORTH_LOOP_TOS 
ad67 cd 09 9b			call macro_forth_loop_tos 
ad6a				endm 
# End of macro FORTH_LOOP_TOS
ad6a			 
ad6a d1				pop de		 ; de = i, hl = limit 
ad6b			 
ad6b					if DEBUG_FORTH_WORDS 
ad6b						DMARK "LP1" 
ad6b f5				push af  
ad6c 3a 80 ad			ld a, (.dmark)  
ad6f 32 c0 ee			ld (debug_mark),a  
ad72 3a 81 ad			ld a, (.dmark+1)  
ad75 32 c1 ee			ld (debug_mark+1),a  
ad78 3a 82 ad			ld a, (.dmark+2)  
ad7b 32 c2 ee			ld (debug_mark+2),a  
ad7e 18 03			jr .pastdmark  
ad80 ..			.dmark: db "LP1"  
ad83 f1			.pastdmark: pop af  
ad84			endm  
# End of macro DMARK
ad84						CALLMONITOR 
ad84 cd 21 93			call break_point_state  
ad87				endm  
# End of macro CALLMONITOR
ad87					endif 
ad87			 
ad87				; go back to previous word 
ad87			 
ad87 d5				push de    ; save I for inc later 
ad88			 
ad88			 
ad88				; get limit 
ad88				;  is I at limit? 
ad88			 
ad88			 
ad88					if DEBUG_FORTH_WORDS 
ad88						DMARK "LP1" 
ad88 f5				push af  
ad89 3a 9d ad			ld a, (.dmark)  
ad8c 32 c0 ee			ld (debug_mark),a  
ad8f 3a 9e ad			ld a, (.dmark+1)  
ad92 32 c1 ee			ld (debug_mark+1),a  
ad95 3a 9f ad			ld a, (.dmark+2)  
ad98 32 c2 ee			ld (debug_mark+2),a  
ad9b 18 03			jr .pastdmark  
ad9d ..			.dmark: db "LP1"  
ada0 f1			.pastdmark: pop af  
ada1			endm  
# End of macro DMARK
ada1						CALLMONITOR 
ada1 cd 21 93			call break_point_state  
ada4				endm  
# End of macro CALLMONITOR
ada4					endif 
ada4			 
ada4 ed 52			sbc hl, de 
ada6			 
ada6			 
ada6				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ada6			 
ada6 20 26				jr nz, .loopnotdone 
ada8			 
ada8 e1				pop hl   ; get rid of saved I 
ada9				FORTH_LOOP_POP     ; get rid of limit 
ada9 cd 13 9b			call macro_forth_loop_pop 
adac				endm 
# End of macro FORTH_LOOP_POP
adac			 
adac				FORTH_RSP_POP     ; get rid of DO ptr 
adac cd 76 98			call macro_forth_rsp_pop 
adaf				endm 
# End of macro FORTH_RSP_POP
adaf			 
adaf			if DEBUG_FORTH_WORDS 
adaf						DMARK "LP>" 
adaf f5				push af  
adb0 3a c4 ad			ld a, (.dmark)  
adb3 32 c0 ee			ld (debug_mark),a  
adb6 3a c5 ad			ld a, (.dmark+1)  
adb9 32 c1 ee			ld (debug_mark+1),a  
adbc 3a c6 ad			ld a, (.dmark+2)  
adbf 32 c2 ee			ld (debug_mark+2),a  
adc2 18 03			jr .pastdmark  
adc4 ..			.dmark: db "LP>"  
adc7 f1			.pastdmark: pop af  
adc8			endm  
# End of macro DMARK
adc8				CALLMONITOR 
adc8 cd 21 93			call break_point_state  
adcb				endm  
# End of macro CALLMONITOR
adcb			endif 
adcb			 
adcb					NEXTW 
adcb c3 17 9c			jp macro_next 
adce				endm 
# End of macro NEXTW
adce				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
adce			 
adce			.loopnotdone: 
adce			 
adce e1				pop hl    ; get I 
adcf 23				inc hl 
add0			 
add0			   	; save new I 
add0			 
add0			 
add0					; set I counter 
add0			 
add0 22 0b e8				ld (os_current_i), hl 
add3			 
add3					if DEBUG_FORTH_WORDS 
add3						DMARK "LPN" 
add3 f5				push af  
add4 3a e8 ad			ld a, (.dmark)  
add7 32 c0 ee			ld (debug_mark),a  
adda 3a e9 ad			ld a, (.dmark+1)  
addd 32 c1 ee			ld (debug_mark+1),a  
ade0 3a ea ad			ld a, (.dmark+2)  
ade3 32 c2 ee			ld (debug_mark+2),a  
ade6 18 03			jr .pastdmark  
ade8 ..			.dmark: db "LPN"  
adeb f1			.pastdmark: pop af  
adec			endm  
# End of macro DMARK
adec					CALLMONITOR 
adec cd 21 93			call break_point_state  
adef				endm  
# End of macro CALLMONITOR
adef					endif 
adef					 
adef				FORTH_LOOP_NEXT 
adef cd d6 9a			call macro_forth_loop_next 
adf2				endm 
# End of macro FORTH_LOOP_NEXT
adf2			 
adf2			 
adf2					if DEBUG_FORTH_WORDS 
adf2 eb						ex de,hl 
adf3					endif 
adf3			 
adf3			;	; get DO ptr 
adf3			; 
adf3					if DEBUG_FORTH_WORDS 
adf3						DMARK "LP7" 
adf3 f5				push af  
adf4 3a 08 ae			ld a, (.dmark)  
adf7 32 c0 ee			ld (debug_mark),a  
adfa 3a 09 ae			ld a, (.dmark+1)  
adfd 32 c1 ee			ld (debug_mark+1),a  
ae00 3a 0a ae			ld a, (.dmark+2)  
ae03 32 c2 ee			ld (debug_mark+2),a  
ae06 18 03			jr .pastdmark  
ae08 ..			.dmark: db "LP7"  
ae0b f1			.pastdmark: pop af  
ae0c			endm  
# End of macro DMARK
ae0c					CALLMONITOR 
ae0c cd 21 93			call break_point_state  
ae0f				endm  
# End of macro CALLMONITOR
ae0f					endif 
ae0f				FORTH_RSP_TOS 
ae0f cd 6c 98			call macro_forth_rsp_tos 
ae12				endm 
# End of macro FORTH_RSP_TOS
ae12			 
ae12					if DEBUG_FORTH_WORDS 
ae12						DMARK "LP8" 
ae12 f5				push af  
ae13 3a 27 ae			ld a, (.dmark)  
ae16 32 c0 ee			ld (debug_mark),a  
ae19 3a 28 ae			ld a, (.dmark+1)  
ae1c 32 c1 ee			ld (debug_mark+1),a  
ae1f 3a 29 ae			ld a, (.dmark+2)  
ae22 32 c2 ee			ld (debug_mark+2),a  
ae25 18 03			jr .pastdmark  
ae27 ..			.dmark: db "LP8"  
ae2a f1			.pastdmark: pop af  
ae2b			endm  
# End of macro DMARK
ae2b					CALLMONITOR 
ae2b cd 21 93			call break_point_state  
ae2e				endm  
# End of macro CALLMONITOR
ae2e					endif 
ae2e				;push hl 
ae2e			 
ae2e				; not going to DO any more 
ae2e				; get rid of the RSP pointer as DO will add it back in 
ae2e				;FORTH_RSP_POP 
ae2e				;pop hl 
ae2e			 
ae2e				;ld hl,(cli_ret_sp) 
ae2e				;ld e, (hl) 
ae2e				;inc hl 
ae2e				;ld d, (hl) 
ae2e				;ex de,hl 
ae2e 22 e7 e7			ld (os_tok_ptr), hl 
ae31					if DEBUG_FORTH_WORDS 
ae31						DMARK "LP<" 
ae31 f5				push af  
ae32 3a 46 ae			ld a, (.dmark)  
ae35 32 c0 ee			ld (debug_mark),a  
ae38 3a 47 ae			ld a, (.dmark+1)  
ae3b 32 c1 ee			ld (debug_mark+1),a  
ae3e 3a 48 ae			ld a, (.dmark+2)  
ae41 32 c2 ee			ld (debug_mark+2),a  
ae44 18 03			jr .pastdmark  
ae46 ..			.dmark: db "LP<"  
ae49 f1			.pastdmark: pop af  
ae4a			endm  
# End of macro DMARK
ae4a					CALLMONITOR 
ae4a cd 21 93			call break_point_state  
ae4d				endm  
# End of macro CALLMONITOR
ae4d				endif 
ae4d c3 a8 9c			jp exec1 
ae50			 
ae50					 
ae50			 
ae50			 
ae50					NEXTW 
ae50 c3 17 9c			jp macro_next 
ae53				endm 
# End of macro NEXTW
ae53			.I:  
ae53			 
ae53				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
ae53 5e				db WORD_SYS_CORE+74             
ae54 7e ae			dw .DLOOP            
ae56 02				db 1 + 1 
ae57 .. 00			db "I",0              
ae59				endm 
# End of macro CWHEAD
ae59			; | I ( -- ) Current loop counter | DONE 
ae59					if DEBUG_FORTH_WORDS_KEY 
ae59						DMARK "I.." 
ae59 f5				push af  
ae5a 3a 6e ae			ld a, (.dmark)  
ae5d 32 c0 ee			ld (debug_mark),a  
ae60 3a 6f ae			ld a, (.dmark+1)  
ae63 32 c1 ee			ld (debug_mark+1),a  
ae66 3a 70 ae			ld a, (.dmark+2)  
ae69 32 c2 ee			ld (debug_mark+2),a  
ae6c 18 03			jr .pastdmark  
ae6e ..			.dmark: db "I.."  
ae71 f1			.pastdmark: pop af  
ae72			endm  
# End of macro DMARK
ae72						CALLMONITOR 
ae72 cd 21 93			call break_point_state  
ae75				endm  
# End of macro CALLMONITOR
ae75					endif 
ae75			 
ae75 2a 0b e8				ld hl,(os_current_i) 
ae78 cd ae 98				call forth_push_numhl 
ae7b			 
ae7b					NEXTW 
ae7b c3 17 9c			jp macro_next 
ae7e				endm 
# End of macro NEXTW
ae7e			.DLOOP: 
ae7e				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
ae7e 5f				db WORD_SYS_CORE+75             
ae7f 5f af			dw .REPEAT            
ae81 06				db 5 + 1 
ae82 .. 00			db "-LOOP",0              
ae88				endm 
# End of macro CWHEAD
ae88			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
ae88				; pop tos as current loop count to hl 
ae88					if DEBUG_FORTH_WORDS_KEY 
ae88						DMARK "-LP" 
ae88 f5				push af  
ae89 3a 9d ae			ld a, (.dmark)  
ae8c 32 c0 ee			ld (debug_mark),a  
ae8f 3a 9e ae			ld a, (.dmark+1)  
ae92 32 c1 ee			ld (debug_mark+1),a  
ae95 3a 9f ae			ld a, (.dmark+2)  
ae98 32 c2 ee			ld (debug_mark+2),a  
ae9b 18 03			jr .pastdmark  
ae9d ..			.dmark: db "-LP"  
aea0 f1			.pastdmark: pop af  
aea1			endm  
# End of macro DMARK
aea1						CALLMONITOR 
aea1 cd 21 93			call break_point_state  
aea4				endm  
# End of macro CALLMONITOR
aea4					endif 
aea4			 
aea4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aea4			 
aea4				FORTH_LOOP_TOS 
aea4 cd 09 9b			call macro_forth_loop_tos 
aea7				endm 
# End of macro FORTH_LOOP_TOS
aea7 e5				push hl 
aea8			 
aea8					if DEBUG_FORTH_WORDS 
aea8						DMARK "-LP" 
aea8 f5				push af  
aea9 3a bd ae			ld a, (.dmark)  
aeac 32 c0 ee			ld (debug_mark),a  
aeaf 3a be ae			ld a, (.dmark+1)  
aeb2 32 c1 ee			ld (debug_mark+1),a  
aeb5 3a bf ae			ld a, (.dmark+2)  
aeb8 32 c2 ee			ld (debug_mark+2),a  
aebb 18 03			jr .pastdmark  
aebd ..			.dmark: db "-LP"  
aec0 f1			.pastdmark: pop af  
aec1			endm  
# End of macro DMARK
aec1						CALLMONITOR 
aec1 cd 21 93			call break_point_state  
aec4				endm  
# End of macro CALLMONITOR
aec4					endif 
aec4				; next item on the stack is the limit. get it 
aec4			 
aec4			 
aec4				FORTH_LOOP_POP 
aec4 cd 13 9b			call macro_forth_loop_pop 
aec7				endm 
# End of macro FORTH_LOOP_POP
aec7			 
aec7				FORTH_LOOP_TOS 
aec7 cd 09 9b			call macro_forth_loop_tos 
aeca				endm 
# End of macro FORTH_LOOP_TOS
aeca			 
aeca d1				pop de		 ; de = i, hl = limit 
aecb			 
aecb					if DEBUG_FORTH_WORDS 
aecb						DMARK "-L1" 
aecb f5				push af  
aecc 3a e0 ae			ld a, (.dmark)  
aecf 32 c0 ee			ld (debug_mark),a  
aed2 3a e1 ae			ld a, (.dmark+1)  
aed5 32 c1 ee			ld (debug_mark+1),a  
aed8 3a e2 ae			ld a, (.dmark+2)  
aedb 32 c2 ee			ld (debug_mark+2),a  
aede 18 03			jr .pastdmark  
aee0 ..			.dmark: db "-L1"  
aee3 f1			.pastdmark: pop af  
aee4			endm  
# End of macro DMARK
aee4						CALLMONITOR 
aee4 cd 21 93			call break_point_state  
aee7				endm  
# End of macro CALLMONITOR
aee7					endif 
aee7			 
aee7				; go back to previous word 
aee7			 
aee7 d5				push de    ; save I for inc later 
aee8			 
aee8			 
aee8				; get limit 
aee8				;  is I at limit? 
aee8			 
aee8			 
aee8					if DEBUG_FORTH_WORDS 
aee8						DMARK "-L1" 
aee8 f5				push af  
aee9 3a fd ae			ld a, (.dmark)  
aeec 32 c0 ee			ld (debug_mark),a  
aeef 3a fe ae			ld a, (.dmark+1)  
aef2 32 c1 ee			ld (debug_mark+1),a  
aef5 3a ff ae			ld a, (.dmark+2)  
aef8 32 c2 ee			ld (debug_mark+2),a  
aefb 18 03			jr .pastdmark  
aefd ..			.dmark: db "-L1"  
af00 f1			.pastdmark: pop af  
af01			endm  
# End of macro DMARK
af01						CALLMONITOR 
af01 cd 21 93			call break_point_state  
af04				endm  
# End of macro CALLMONITOR
af04					endif 
af04			 
af04 ed 52			sbc hl, de 
af06			 
af06			 
af06				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af06			 
af06 20 26				jr nz, .mloopnotdone 
af08			 
af08 e1				pop hl   ; get rid of saved I 
af09				FORTH_LOOP_POP     ; get rid of limit 
af09 cd 13 9b			call macro_forth_loop_pop 
af0c				endm 
# End of macro FORTH_LOOP_POP
af0c			 
af0c				FORTH_RSP_POP     ; get rid of DO ptr 
af0c cd 76 98			call macro_forth_rsp_pop 
af0f				endm 
# End of macro FORTH_RSP_POP
af0f			 
af0f			if DEBUG_FORTH_WORDS 
af0f						DMARK "-L>" 
af0f f5				push af  
af10 3a 24 af			ld a, (.dmark)  
af13 32 c0 ee			ld (debug_mark),a  
af16 3a 25 af			ld a, (.dmark+1)  
af19 32 c1 ee			ld (debug_mark+1),a  
af1c 3a 26 af			ld a, (.dmark+2)  
af1f 32 c2 ee			ld (debug_mark+2),a  
af22 18 03			jr .pastdmark  
af24 ..			.dmark: db "-L>"  
af27 f1			.pastdmark: pop af  
af28			endm  
# End of macro DMARK
af28				CALLMONITOR 
af28 cd 21 93			call break_point_state  
af2b				endm  
# End of macro CALLMONITOR
af2b			endif 
af2b			 
af2b					NEXTW 
af2b c3 17 9c			jp macro_next 
af2e				endm 
# End of macro NEXTW
af2e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af2e			 
af2e			.mloopnotdone: 
af2e			 
af2e e1				pop hl    ; get I 
af2f 2b				dec hl 
af30			 
af30			   	; save new I 
af30			 
af30			 
af30					; set I counter 
af30			 
af30 22 0b e8				ld (os_current_i), hl 
af33			 
af33					 
af33				FORTH_LOOP_NEXT 
af33 cd d6 9a			call macro_forth_loop_next 
af36				endm 
# End of macro FORTH_LOOP_NEXT
af36			 
af36			 
af36					if DEBUG_FORTH_WORDS 
af36 eb						ex de,hl 
af37					endif 
af37			 
af37			;	; get DO ptr 
af37			; 
af37				FORTH_RSP_TOS 
af37 cd 6c 98			call macro_forth_rsp_tos 
af3a				endm 
# End of macro FORTH_RSP_TOS
af3a			 
af3a				;push hl 
af3a			 
af3a				; not going to DO any more 
af3a				; get rid of the RSP pointer as DO will add it back in 
af3a				;FORTH_RSP_POP 
af3a				;pop hl 
af3a			 
af3a			 
af3a 22 e7 e7			ld (os_tok_ptr), hl 
af3d					if DEBUG_FORTH_WORDS 
af3d						DMARK "-L<" 
af3d f5				push af  
af3e 3a 52 af			ld a, (.dmark)  
af41 32 c0 ee			ld (debug_mark),a  
af44 3a 53 af			ld a, (.dmark+1)  
af47 32 c1 ee			ld (debug_mark+1),a  
af4a 3a 54 af			ld a, (.dmark+2)  
af4d 32 c2 ee			ld (debug_mark+2),a  
af50 18 03			jr .pastdmark  
af52 ..			.dmark: db "-L<"  
af55 f1			.pastdmark: pop af  
af56			endm  
# End of macro DMARK
af56					CALLMONITOR 
af56 cd 21 93			call break_point_state  
af59				endm  
# End of macro CALLMONITOR
af59				endif 
af59 c3 a8 9c			jp exec1 
af5c			 
af5c					 
af5c			 
af5c			 
af5c			 
af5c				NEXTW 
af5c c3 17 9c			jp macro_next 
af5f				endm 
# End of macro NEXTW
af5f			 
af5f			 
af5f			 
af5f			 
af5f			.REPEAT: 
af5f				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
af5f 71				db WORD_SYS_CORE+93             
af60 b2 af			dw .UNTIL            
af62 06				db 5 + 1 
af63 .. 00			db "REPEAT",0              
af6a				endm 
# End of macro CWHEAD
af6a			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
af6a			;  push pc to rsp stack past the REPEAT 
af6a					if DEBUG_FORTH_WORDS_KEY 
af6a						DMARK "REP" 
af6a f5				push af  
af6b 3a 7f af			ld a, (.dmark)  
af6e 32 c0 ee			ld (debug_mark),a  
af71 3a 80 af			ld a, (.dmark+1)  
af74 32 c1 ee			ld (debug_mark+1),a  
af77 3a 81 af			ld a, (.dmark+2)  
af7a 32 c2 ee			ld (debug_mark+2),a  
af7d 18 03			jr .pastdmark  
af7f ..			.dmark: db "REP"  
af82 f1			.pastdmark: pop af  
af83			endm  
# End of macro DMARK
af83						CALLMONITOR 
af83 cd 21 93			call break_point_state  
af86				endm  
# End of macro CALLMONITOR
af86					endif 
af86			 
af86 2a e7 e7				ld hl, (os_tok_ptr) 
af89 23					inc hl   ; R 
af8a 23					inc hl  ; E 
af8b 23					inc hl   ; P 
af8c 23					inc hl   ; E 
af8d 23					inc hl   ; A 
af8e 23					inc hl   ; T 
af8f 23					inc hl   ; zero 
af90					FORTH_RSP_NEXT 
af90 cd 55 98			call macro_forth_rsp_next 
af93				endm 
# End of macro FORTH_RSP_NEXT
af93			 
af93			 
af93					if DEBUG_FORTH_WORDS 
af93						DMARK "REP" 
af93 f5				push af  
af94 3a a8 af			ld a, (.dmark)  
af97 32 c0 ee			ld (debug_mark),a  
af9a 3a a9 af			ld a, (.dmark+1)  
af9d 32 c1 ee			ld (debug_mark+1),a  
afa0 3a aa af			ld a, (.dmark+2)  
afa3 32 c2 ee			ld (debug_mark+2),a  
afa6 18 03			jr .pastdmark  
afa8 ..			.dmark: db "REP"  
afab f1			.pastdmark: pop af  
afac			endm  
# End of macro DMARK
afac						;pop bc    ; TODO BUG ?????? what is this for???? 
afac						CALLMONITOR 
afac cd 21 93			call break_point_state  
afaf				endm  
# End of macro CALLMONITOR
afaf					endif 
afaf			 
afaf					NEXTW 
afaf c3 17 9c			jp macro_next 
afb2				endm 
# End of macro NEXTW
afb2			;	       NEXTW 
afb2			 
afb2			.UNTIL: 
afb2				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
afb2 72				db WORD_SYS_CORE+94             
afb3 49 b0			dw .ENDFLOW            
afb5 06				db 5 + 1 
afb6 .. 00			db "UNTIL",0              
afbc				endm 
# End of macro CWHEAD
afbc			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
afbc			 
afbc				; pop tos as check 
afbc			 
afbc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afbc			 
afbc				FORTH_DSP_VALUEHL 
afbc cd a5 9a			call macro_dsp_valuehl 
afbf				endm 
# End of macro FORTH_DSP_VALUEHL
afbf			 
afbf					if DEBUG_FORTH_WORDS_KEY 
afbf						DMARK "UNT" 
afbf f5				push af  
afc0 3a d4 af			ld a, (.dmark)  
afc3 32 c0 ee			ld (debug_mark),a  
afc6 3a d5 af			ld a, (.dmark+1)  
afc9 32 c1 ee			ld (debug_mark+1),a  
afcc 3a d6 af			ld a, (.dmark+2)  
afcf 32 c2 ee			ld (debug_mark+2),a  
afd2 18 03			jr .pastdmark  
afd4 ..			.dmark: db "UNT"  
afd7 f1			.pastdmark: pop af  
afd8			endm  
# End of macro DMARK
afd8						CALLMONITOR 
afd8 cd 21 93			call break_point_state  
afdb				endm  
# End of macro CALLMONITOR
afdb					endif 
afdb			 
afdb			;	push hl 
afdb				FORTH_DSP_POP 
afdb cd 5d 9b			call macro_forth_dsp_pop 
afde				endm 
# End of macro FORTH_DSP_POP
afde			 
afde			;	pop hl 
afde			 
afde				; test if true 
afde			 
afde cd d0 8a			call ishlzero 
afe1			;	ld a,l 
afe1			;	add h 
afe1			; 
afe1			;	cp 0 
afe1			 
afe1 20 3e			jr nz, .untilnotdone 
afe3			 
afe3					if DEBUG_FORTH_WORDS 
afe3						DMARK "UNf" 
afe3 f5				push af  
afe4 3a f8 af			ld a, (.dmark)  
afe7 32 c0 ee			ld (debug_mark),a  
afea 3a f9 af			ld a, (.dmark+1)  
afed 32 c1 ee			ld (debug_mark+1),a  
aff0 3a fa af			ld a, (.dmark+2)  
aff3 32 c2 ee			ld (debug_mark+2),a  
aff6 18 03			jr .pastdmark  
aff8 ..			.dmark: db "UNf"  
affb f1			.pastdmark: pop af  
affc			endm  
# End of macro DMARK
affc						CALLMONITOR 
affc cd 21 93			call break_point_state  
afff				endm  
# End of macro CALLMONITOR
afff					endif 
afff			 
afff			 
afff			 
afff				FORTH_RSP_POP     ; get rid of DO ptr 
afff cd 76 98			call macro_forth_rsp_pop 
b002				endm 
# End of macro FORTH_RSP_POP
b002			 
b002			if DEBUG_FORTH_WORDS 
b002						DMARK "UN>" 
b002 f5				push af  
b003 3a 17 b0			ld a, (.dmark)  
b006 32 c0 ee			ld (debug_mark),a  
b009 3a 18 b0			ld a, (.dmark+1)  
b00c 32 c1 ee			ld (debug_mark+1),a  
b00f 3a 19 b0			ld a, (.dmark+2)  
b012 32 c2 ee			ld (debug_mark+2),a  
b015 18 03			jr .pastdmark  
b017 ..			.dmark: db "UN>"  
b01a f1			.pastdmark: pop af  
b01b			endm  
# End of macro DMARK
b01b				CALLMONITOR 
b01b cd 21 93			call break_point_state  
b01e				endm  
# End of macro CALLMONITOR
b01e			endif 
b01e			 
b01e					NEXTW 
b01e c3 17 9c			jp macro_next 
b021				endm 
# End of macro NEXTW
b021				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b021			 
b021			.untilnotdone: 
b021			 
b021			 
b021			;	; get DO ptr 
b021			; 
b021				FORTH_RSP_TOS 
b021 cd 6c 98			call macro_forth_rsp_tos 
b024				endm 
# End of macro FORTH_RSP_TOS
b024			 
b024				;push hl 
b024			 
b024				; not going to DO any more 
b024				; get rid of the RSP pointer as DO will add it back in 
b024				;FORTH_RSP_POP 
b024				;pop hl 
b024			 
b024			 
b024 22 e7 e7			ld (os_tok_ptr), hl 
b027					if DEBUG_FORTH_WORDS 
b027						DMARK "UN<" 
b027 f5				push af  
b028 3a 3c b0			ld a, (.dmark)  
b02b 32 c0 ee			ld (debug_mark),a  
b02e 3a 3d b0			ld a, (.dmark+1)  
b031 32 c1 ee			ld (debug_mark+1),a  
b034 3a 3e b0			ld a, (.dmark+2)  
b037 32 c2 ee			ld (debug_mark+2),a  
b03a 18 03			jr .pastdmark  
b03c ..			.dmark: db "UN<"  
b03f f1			.pastdmark: pop af  
b040			endm  
# End of macro DMARK
b040					CALLMONITOR 
b040 cd 21 93			call break_point_state  
b043				endm  
# End of macro CALLMONITOR
b043				endif 
b043 c3 a8 9c			jp exec1 
b046			 
b046					 
b046			 
b046			 
b046					NEXTW 
b046 c3 17 9c			jp macro_next 
b049				endm 
# End of macro NEXTW
b049			 
b049			 
b049			.ENDFLOW: 
b049			 
b049			; eof 
b049			 
# End of file forth_words_flow.asm
b049			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b049			include "forth_words_logic.asm" 
b049			 
b049			; | ## Logic Words 
b049			 
b049			.NOT: 
b049				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b049 2d				db WORD_SYS_CORE+25             
b04a 91 b0			dw .IS            
b04c 04				db 3 + 1 
b04d .. 00			db "NOT",0              
b051				endm 
# End of macro CWHEAD
b051			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b051					if DEBUG_FORTH_WORDS_KEY 
b051						DMARK "NOT" 
b051 f5				push af  
b052 3a 66 b0			ld a, (.dmark)  
b055 32 c0 ee			ld (debug_mark),a  
b058 3a 67 b0			ld a, (.dmark+1)  
b05b 32 c1 ee			ld (debug_mark+1),a  
b05e 3a 68 b0			ld a, (.dmark+2)  
b061 32 c2 ee			ld (debug_mark+2),a  
b064 18 03			jr .pastdmark  
b066 ..			.dmark: db "NOT"  
b069 f1			.pastdmark: pop af  
b06a			endm  
# End of macro DMARK
b06a						CALLMONITOR 
b06a cd 21 93			call break_point_state  
b06d				endm  
# End of macro CALLMONITOR
b06d					endif 
b06d					FORTH_DSP 
b06d cd 6b 9a			call macro_forth_dsp 
b070				endm 
# End of macro FORTH_DSP
b070 7e					ld a,(hl)	; get type of value on TOS 
b071 fe 02				cp DS_TYPE_INUM  
b073 28 03				jr z, .noti 
b075					NEXTW 
b075 c3 17 9c			jp macro_next 
b078				endm 
# End of macro NEXTW
b078			.noti:          FORTH_DSP_VALUEHL 
b078 cd a5 9a			call macro_dsp_valuehl 
b07b				endm 
# End of macro FORTH_DSP_VALUEHL
b07b			;		push hl 
b07b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b07b cd 5d 9b			call macro_forth_dsp_pop 
b07e				endm 
# End of macro FORTH_DSP_POP
b07e			;		pop hl 
b07e 3e 00				ld a,0 
b080 bd					cp l 
b081 28 04				jr z, .not2t 
b083 2e 00				ld l, 0 
b085 18 02				jr .notip 
b087			 
b087 2e ff		.not2t:		ld l, 255 
b089			 
b089 26 00		.notip:		ld h, 0	 
b08b			 
b08b cd ae 98				call forth_push_numhl 
b08e					NEXTW 
b08e c3 17 9c			jp macro_next 
b091				endm 
# End of macro NEXTW
b091			 
b091			.IS: 
b091				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b091 2d				db WORD_SYS_CORE+25             
b092 b7 b0			dw .LZERO            
b094 03				db 2 + 1 
b095 .. 00			db "IS",0              
b098				endm 
# End of macro CWHEAD
b098			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b098					if DEBUG_FORTH_WORDS_KEY 
b098						DMARK "IS." 
b098 f5				push af  
b099 3a ad b0			ld a, (.dmark)  
b09c 32 c0 ee			ld (debug_mark),a  
b09f 3a ae b0			ld a, (.dmark+1)  
b0a2 32 c1 ee			ld (debug_mark+1),a  
b0a5 3a af b0			ld a, (.dmark+2)  
b0a8 32 c2 ee			ld (debug_mark+2),a  
b0ab 18 03			jr .pastdmark  
b0ad ..			.dmark: db "IS."  
b0b0 f1			.pastdmark: pop af  
b0b1			endm  
# End of macro DMARK
b0b1						CALLMONITOR 
b0b1 cd 21 93			call break_point_state  
b0b4				endm  
# End of macro CALLMONITOR
b0b4					endif 
b0b4					NEXTW 
b0b4 c3 17 9c			jp macro_next 
b0b7				endm 
# End of macro NEXTW
b0b7			.LZERO: 
b0b7				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b0b7 2d				db WORD_SYS_CORE+25             
b0b8 c1 b0			dw .TZERO            
b0ba 03				db 2 + 1 
b0bb .. 00			db "0<",0              
b0be				endm 
# End of macro CWHEAD
b0be			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b0be					NEXTW 
b0be c3 17 9c			jp macro_next 
b0c1				endm 
# End of macro NEXTW
b0c1			.TZERO: 
b0c1				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b0c1 2e				db WORD_SYS_CORE+26             
b0c2 08 b1			dw .LESS            
b0c4 03				db 2 + 1 
b0c5 .. 00			db "0=",0              
b0c8				endm 
# End of macro CWHEAD
b0c8			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b0c8				; TODO add floating point number detection 
b0c8					;v5 FORTH_DSP_VALUE 
b0c8					if DEBUG_FORTH_WORDS_KEY 
b0c8						DMARK "0=." 
b0c8 f5				push af  
b0c9 3a dd b0			ld a, (.dmark)  
b0cc 32 c0 ee			ld (debug_mark),a  
b0cf 3a de b0			ld a, (.dmark+1)  
b0d2 32 c1 ee			ld (debug_mark+1),a  
b0d5 3a df b0			ld a, (.dmark+2)  
b0d8 32 c2 ee			ld (debug_mark+2),a  
b0db 18 03			jr .pastdmark  
b0dd ..			.dmark: db "0=."  
b0e0 f1			.pastdmark: pop af  
b0e1			endm  
# End of macro DMARK
b0e1						CALLMONITOR 
b0e1 cd 21 93			call break_point_state  
b0e4				endm  
# End of macro CALLMONITOR
b0e4					endif 
b0e4					FORTH_DSP 
b0e4 cd 6b 9a			call macro_forth_dsp 
b0e7				endm 
# End of macro FORTH_DSP
b0e7 7e					ld a,(hl)	; get type of value on TOS 
b0e8 fe 02				cp DS_TYPE_INUM  
b0ea 28 00				jr z, .tz_inum 
b0ec			 
b0ec				if FORTH_ENABLE_FLOATMATH 
b0ec					jr .tz_done 
b0ec			 
b0ec				endif 
b0ec					 
b0ec			 
b0ec			.tz_inum: 
b0ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0ec cd a5 9a			call macro_dsp_valuehl 
b0ef				endm 
# End of macro FORTH_DSP_VALUEHL
b0ef			 
b0ef			;		push hl 
b0ef			 
b0ef					; destroy value TOS 
b0ef			 
b0ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0ef cd 5d 9b			call macro_forth_dsp_pop 
b0f2				endm 
# End of macro FORTH_DSP_POP
b0f2			 
b0f2			;		pop hl 
b0f2			 
b0f2 3e 00				ld a,0 
b0f4			 
b0f4 bd					cp l 
b0f5 20 08				jr nz, .tz_notzero 
b0f7			 
b0f7 bc					cp h 
b0f8			 
b0f8 20 05				jr nz, .tz_notzero 
b0fa			 
b0fa			 
b0fa 21 01 00				ld hl, FORTH_TRUE 
b0fd 18 03				jr .tz_done 
b0ff			 
b0ff 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b102			 
b102					; push value back onto stack for another op etc 
b102			 
b102			.tz_done: 
b102 cd ae 98				call forth_push_numhl 
b105			 
b105					NEXTW 
b105 c3 17 9c			jp macro_next 
b108				endm 
# End of macro NEXTW
b108			.LESS: 
b108				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b108 2f				db WORD_SYS_CORE+27             
b109 71 b1			dw .GT            
b10b 02				db 1 + 1 
b10c .. 00			db "<",0              
b10e				endm 
# End of macro CWHEAD
b10e			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b10e				; TODO add floating point number detection 
b10e					if DEBUG_FORTH_WORDS_KEY 
b10e						DMARK "LES" 
b10e f5				push af  
b10f 3a 23 b1			ld a, (.dmark)  
b112 32 c0 ee			ld (debug_mark),a  
b115 3a 24 b1			ld a, (.dmark+1)  
b118 32 c1 ee			ld (debug_mark+1),a  
b11b 3a 25 b1			ld a, (.dmark+2)  
b11e 32 c2 ee			ld (debug_mark+2),a  
b121 18 03			jr .pastdmark  
b123 ..			.dmark: db "LES"  
b126 f1			.pastdmark: pop af  
b127			endm  
# End of macro DMARK
b127						CALLMONITOR 
b127 cd 21 93			call break_point_state  
b12a				endm  
# End of macro CALLMONITOR
b12a					endif 
b12a					FORTH_DSP 
b12a cd 6b 9a			call macro_forth_dsp 
b12d				endm 
# End of macro FORTH_DSP
b12d					;v5 FORTH_DSP_VALUE 
b12d 7e					ld a,(hl)	; get type of value on TOS 
b12e fe 02				cp DS_TYPE_INUM  
b130 28 00				jr z, .less_inum 
b132			 
b132				if FORTH_ENABLE_FLOATMATH 
b132					jr .less_done 
b132			 
b132				endif 
b132					 
b132			 
b132			.less_inum: 
b132					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b132 cd a5 9a			call macro_dsp_valuehl 
b135				endm 
# End of macro FORTH_DSP_VALUEHL
b135			 
b135 e5					push hl  ; u2 
b136			 
b136					; destroy value TOS 
b136			 
b136					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b136 cd 5d 9b			call macro_forth_dsp_pop 
b139				endm 
# End of macro FORTH_DSP_POP
b139			 
b139			 
b139					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b139 cd a5 9a			call macro_dsp_valuehl 
b13c				endm 
# End of macro FORTH_DSP_VALUEHL
b13c			 
b13c e5					push hl    ; u1 
b13d			 
b13d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b13d cd 5d 9b			call macro_forth_dsp_pop 
b140				endm 
# End of macro FORTH_DSP_POP
b140			 
b140			 
b140 b7			 or a      ;clear carry flag 
b141 01 00 00		 ld bc, FORTH_FALSE 
b144 e1			  pop hl    ; u1 
b145 d1			  pop de    ; u2 
b146 ed 52		  sbc hl,de 
b148 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b14a			 
b14a 01 01 00		 ld bc, FORTH_TRUE 
b14d			.lscont:  
b14d c5					push bc 
b14e e1					pop hl 
b14f			 
b14f					if DEBUG_FORTH_WORDS 
b14f						DMARK "LT1" 
b14f f5				push af  
b150 3a 64 b1			ld a, (.dmark)  
b153 32 c0 ee			ld (debug_mark),a  
b156 3a 65 b1			ld a, (.dmark+1)  
b159 32 c1 ee			ld (debug_mark+1),a  
b15c 3a 66 b1			ld a, (.dmark+2)  
b15f 32 c2 ee			ld (debug_mark+2),a  
b162 18 03			jr .pastdmark  
b164 ..			.dmark: db "LT1"  
b167 f1			.pastdmark: pop af  
b168			endm  
# End of macro DMARK
b168						CALLMONITOR 
b168 cd 21 93			call break_point_state  
b16b				endm  
# End of macro CALLMONITOR
b16b					endif 
b16b cd ae 98				call forth_push_numhl 
b16e			 
b16e					NEXTW 
b16e c3 17 9c			jp macro_next 
b171				endm 
# End of macro NEXTW
b171			.GT: 
b171				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b171 30				db WORD_SYS_CORE+28             
b172 da b1			dw .EQUAL            
b174 02				db 1 + 1 
b175 .. 00			db ">",0              
b177				endm 
# End of macro CWHEAD
b177			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b177				; TODO add floating point number detection 
b177					if DEBUG_FORTH_WORDS_KEY 
b177						DMARK "GRT" 
b177 f5				push af  
b178 3a 8c b1			ld a, (.dmark)  
b17b 32 c0 ee			ld (debug_mark),a  
b17e 3a 8d b1			ld a, (.dmark+1)  
b181 32 c1 ee			ld (debug_mark+1),a  
b184 3a 8e b1			ld a, (.dmark+2)  
b187 32 c2 ee			ld (debug_mark+2),a  
b18a 18 03			jr .pastdmark  
b18c ..			.dmark: db "GRT"  
b18f f1			.pastdmark: pop af  
b190			endm  
# End of macro DMARK
b190						CALLMONITOR 
b190 cd 21 93			call break_point_state  
b193				endm  
# End of macro CALLMONITOR
b193					endif 
b193					FORTH_DSP 
b193 cd 6b 9a			call macro_forth_dsp 
b196				endm 
# End of macro FORTH_DSP
b196					;FORTH_DSP_VALUE 
b196 7e					ld a,(hl)	; get type of value on TOS 
b197 fe 02				cp DS_TYPE_INUM  
b199 28 00				jr z, .gt_inum 
b19b			 
b19b				if FORTH_ENABLE_FLOATMATH 
b19b					jr .gt_done 
b19b			 
b19b				endif 
b19b					 
b19b			 
b19b			.gt_inum: 
b19b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b19b cd a5 9a			call macro_dsp_valuehl 
b19e				endm 
# End of macro FORTH_DSP_VALUEHL
b19e			 
b19e e5					push hl  ; u2 
b19f			 
b19f					; destroy value TOS 
b19f			 
b19f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b19f cd 5d 9b			call macro_forth_dsp_pop 
b1a2				endm 
# End of macro FORTH_DSP_POP
b1a2			 
b1a2			 
b1a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1a2 cd a5 9a			call macro_dsp_valuehl 
b1a5				endm 
# End of macro FORTH_DSP_VALUEHL
b1a5			 
b1a5 e5					push hl    ; u1 
b1a6			 
b1a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1a6 cd 5d 9b			call macro_forth_dsp_pop 
b1a9				endm 
# End of macro FORTH_DSP_POP
b1a9			 
b1a9			 
b1a9 b7			 or a      ;clear carry flag 
b1aa 01 00 00		 ld bc, FORTH_FALSE 
b1ad e1			  pop hl    ; u1 
b1ae d1			  pop de    ; u2 
b1af ed 52		  sbc hl,de 
b1b1 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b1b3			 
b1b3 01 01 00		 ld bc, FORTH_TRUE 
b1b6			.gtcont:  
b1b6 c5					push bc 
b1b7 e1					pop hl 
b1b8			 
b1b8					if DEBUG_FORTH_WORDS 
b1b8						DMARK "GT1" 
b1b8 f5				push af  
b1b9 3a cd b1			ld a, (.dmark)  
b1bc 32 c0 ee			ld (debug_mark),a  
b1bf 3a ce b1			ld a, (.dmark+1)  
b1c2 32 c1 ee			ld (debug_mark+1),a  
b1c5 3a cf b1			ld a, (.dmark+2)  
b1c8 32 c2 ee			ld (debug_mark+2),a  
b1cb 18 03			jr .pastdmark  
b1cd ..			.dmark: db "GT1"  
b1d0 f1			.pastdmark: pop af  
b1d1			endm  
# End of macro DMARK
b1d1						CALLMONITOR 
b1d1 cd 21 93			call break_point_state  
b1d4				endm  
# End of macro CALLMONITOR
b1d4					endif 
b1d4 cd ae 98				call forth_push_numhl 
b1d7			 
b1d7					NEXTW 
b1d7 c3 17 9c			jp macro_next 
b1da				endm 
# End of macro NEXTW
b1da			.EQUAL: 
b1da				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b1da 31				db WORD_SYS_CORE+29             
b1db 45 b2			dw .ENDLOGIC            
b1dd 02				db 1 + 1 
b1de .. 00			db "=",0              
b1e0				endm 
# End of macro CWHEAD
b1e0			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b1e0				; TODO add floating point number detection 
b1e0					if DEBUG_FORTH_WORDS_KEY 
b1e0						DMARK "EQ." 
b1e0 f5				push af  
b1e1 3a f5 b1			ld a, (.dmark)  
b1e4 32 c0 ee			ld (debug_mark),a  
b1e7 3a f6 b1			ld a, (.dmark+1)  
b1ea 32 c1 ee			ld (debug_mark+1),a  
b1ed 3a f7 b1			ld a, (.dmark+2)  
b1f0 32 c2 ee			ld (debug_mark+2),a  
b1f3 18 03			jr .pastdmark  
b1f5 ..			.dmark: db "EQ."  
b1f8 f1			.pastdmark: pop af  
b1f9			endm  
# End of macro DMARK
b1f9						CALLMONITOR 
b1f9 cd 21 93			call break_point_state  
b1fc				endm  
# End of macro CALLMONITOR
b1fc					endif 
b1fc					FORTH_DSP 
b1fc cd 6b 9a			call macro_forth_dsp 
b1ff				endm 
# End of macro FORTH_DSP
b1ff					;v5 FORTH_DSP_VALUE 
b1ff 7e					ld a,(hl)	; get type of value on TOS 
b200 fe 02				cp DS_TYPE_INUM  
b202 28 00				jr z, .eq_inum 
b204			 
b204				if FORTH_ENABLE_FLOATMATH 
b204					jr .eq_done 
b204			 
b204				endif 
b204					 
b204			 
b204			.eq_inum: 
b204					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b204 cd a5 9a			call macro_dsp_valuehl 
b207				endm 
# End of macro FORTH_DSP_VALUEHL
b207			 
b207 e5					push hl 
b208			 
b208					; destroy value TOS 
b208			 
b208					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b208 cd 5d 9b			call macro_forth_dsp_pop 
b20b				endm 
# End of macro FORTH_DSP_POP
b20b			 
b20b			 
b20b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b20b cd a5 9a			call macro_dsp_valuehl 
b20e				endm 
# End of macro FORTH_DSP_VALUEHL
b20e			 
b20e					; one value on hl get other one back 
b20e			 
b20e e5					push hl 
b20f			 
b20f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b20f cd 5d 9b			call macro_forth_dsp_pop 
b212				endm 
# End of macro FORTH_DSP_POP
b212			 
b212 0e 00				ld c, FORTH_FALSE 
b214			 
b214 e1					pop hl 
b215 d1					pop de 
b216			 
b216 7b					ld a, e 
b217 bd					cp l 
b218			 
b218 20 06				jr nz, .eq_done 
b21a			 
b21a 7a					ld a, d 
b21b bc					cp h 
b21c			 
b21c 20 02				jr nz, .eq_done 
b21e			 
b21e 0e 01				ld c, FORTH_TRUE 
b220					 
b220			 
b220			 
b220			.eq_done: 
b220			 
b220					; TODO push value back onto stack for another op etc 
b220			 
b220 26 00				ld h, 0 
b222 69					ld l, c 
b223					if DEBUG_FORTH_WORDS 
b223						DMARK "EQ1" 
b223 f5				push af  
b224 3a 38 b2			ld a, (.dmark)  
b227 32 c0 ee			ld (debug_mark),a  
b22a 3a 39 b2			ld a, (.dmark+1)  
b22d 32 c1 ee			ld (debug_mark+1),a  
b230 3a 3a b2			ld a, (.dmark+2)  
b233 32 c2 ee			ld (debug_mark+2),a  
b236 18 03			jr .pastdmark  
b238 ..			.dmark: db "EQ1"  
b23b f1			.pastdmark: pop af  
b23c			endm  
# End of macro DMARK
b23c						CALLMONITOR 
b23c cd 21 93			call break_point_state  
b23f				endm  
# End of macro CALLMONITOR
b23f					endif 
b23f cd ae 98				call forth_push_numhl 
b242			 
b242					NEXTW 
b242 c3 17 9c			jp macro_next 
b245				endm 
# End of macro NEXTW
b245			 
b245			 
b245			.ENDLOGIC: 
b245			; eof 
b245			 
b245			 
# End of file forth_words_logic.asm
b245			include "forth_words_maths.asm" 
b245			 
b245			; | ## Maths Words 
b245			 
b245			.PLUS:	 
b245				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b245 15				db WORD_SYS_CORE+1             
b246 87 b2			dw .NEG            
b248 02				db 1 + 1 
b249 .. 00			db "+",0              
b24b				endm 
# End of macro CWHEAD
b24b			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b24b					if DEBUG_FORTH_WORDS_KEY 
b24b						DMARK "PLU" 
b24b f5				push af  
b24c 3a 60 b2			ld a, (.dmark)  
b24f 32 c0 ee			ld (debug_mark),a  
b252 3a 61 b2			ld a, (.dmark+1)  
b255 32 c1 ee			ld (debug_mark+1),a  
b258 3a 62 b2			ld a, (.dmark+2)  
b25b 32 c2 ee			ld (debug_mark+2),a  
b25e 18 03			jr .pastdmark  
b260 ..			.dmark: db "PLU"  
b263 f1			.pastdmark: pop af  
b264			endm  
# End of macro DMARK
b264						CALLMONITOR 
b264 cd 21 93			call break_point_state  
b267				endm  
# End of macro CALLMONITOR
b267					endif 
b267					; add top two values and push back result 
b267			 
b267					;for v5 FORTH_DSP_VALUE 
b267					FORTH_DSP 
b267 cd 6b 9a			call macro_forth_dsp 
b26a				endm 
# End of macro FORTH_DSP
b26a 7e					ld a,(hl)	; get type of value on TOS 
b26b fe 02				cp DS_TYPE_INUM  
b26d 28 03				jr z, .dot_inum 
b26f			 
b26f					NEXTW 
b26f c3 17 9c			jp macro_next 
b272				endm 
# End of macro NEXTW
b272			 
b272			; float maths 
b272			 
b272				if FORTH_ENABLE_FLOATMATH 
b272						inc hl      ; now at start of numeric as string 
b272			 
b272					if DEBUG_FORTH_MATHS 
b272						DMARK "ADD" 
b272				CALLMONITOR 
b272					endif 
b272			 
b272					;ld ix, hl 
b272					call CON 
b272			 
b272			 
b272					push hl 
b272					 
b272					 
b272			 
b272						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b272			 
b272					; get next number 
b272			 
b272						FORTH_DSP_VALUE 
b272			 
b272						inc hl      ; now at start of numeric as string 
b272			 
b272					;ld ix, hl 
b272					call CON 
b272			 
b272					push hl 
b272			 
b272			 
b272						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b272			 
b272						; TODO do add 
b272			 
b272						call IADD 
b272			 
b272						; TODO get result back as ascii 
b272			 
b272						; TODO push result  
b272			 
b272			 
b272			 
b272						jr .dot_done 
b272				endif 
b272			 
b272			.dot_inum: 
b272			 
b272			 
b272					if DEBUG_FORTH_DOT 
b272						DMARK "+IT" 
b272				CALLMONITOR 
b272					endif 
b272			 
b272					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b272 cd a5 9a			call macro_dsp_valuehl 
b275				endm 
# End of macro FORTH_DSP_VALUEHL
b275			 
b275				; TODO add floating point number detection 
b275			 
b275 e5					push hl 
b276			 
b276					; destroy value TOS 
b276			 
b276					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b276 cd 5d 9b			call macro_forth_dsp_pop 
b279				endm 
# End of macro FORTH_DSP_POP
b279			 
b279			 
b279					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b279 cd a5 9a			call macro_dsp_valuehl 
b27c				endm 
# End of macro FORTH_DSP_VALUEHL
b27c			 
b27c					; one value on hl get other one back 
b27c			 
b27c d1					pop de 
b27d			 
b27d					; do the add 
b27d			 
b27d 19					add hl,de 
b27e			 
b27e					; save it 
b27e			 
b27e			;		push hl	 
b27e			 
b27e					; 
b27e			 
b27e					; destroy value TOS 
b27e			 
b27e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b27e cd 5d 9b			call macro_forth_dsp_pop 
b281				endm 
# End of macro FORTH_DSP_POP
b281			 
b281					; TODO push value back onto stack for another op etc 
b281			 
b281			;		pop hl 
b281			 
b281			.dot_done: 
b281 cd ae 98				call forth_push_numhl 
b284			 
b284					NEXTW 
b284 c3 17 9c			jp macro_next 
b287				endm 
# End of macro NEXTW
b287			.NEG: 
b287			 
b287				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b287 17				db WORD_SYS_CORE+3             
b288 ca b2			dw .DIV            
b28a 02				db 1 + 1 
b28b .. 00			db "-",0              
b28d				endm 
# End of macro CWHEAD
b28d			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b28d					if DEBUG_FORTH_WORDS_KEY 
b28d						DMARK "SUB" 
b28d f5				push af  
b28e 3a a2 b2			ld a, (.dmark)  
b291 32 c0 ee			ld (debug_mark),a  
b294 3a a3 b2			ld a, (.dmark+1)  
b297 32 c1 ee			ld (debug_mark+1),a  
b29a 3a a4 b2			ld a, (.dmark+2)  
b29d 32 c2 ee			ld (debug_mark+2),a  
b2a0 18 03			jr .pastdmark  
b2a2 ..			.dmark: db "SUB"  
b2a5 f1			.pastdmark: pop af  
b2a6			endm  
# End of macro DMARK
b2a6						CALLMONITOR 
b2a6 cd 21 93			call break_point_state  
b2a9				endm  
# End of macro CALLMONITOR
b2a9					endif 
b2a9			 
b2a9			 
b2a9				; TODO add floating point number detection 
b2a9					; v5 FORTH_DSP_VALUE 
b2a9					FORTH_DSP 
b2a9 cd 6b 9a			call macro_forth_dsp 
b2ac				endm 
# End of macro FORTH_DSP
b2ac 7e					ld a,(hl)	; get type of value on TOS 
b2ad fe 02				cp DS_TYPE_INUM  
b2af 28 03				jr z, .neg_inum 
b2b1			 
b2b1					NEXTW 
b2b1 c3 17 9c			jp macro_next 
b2b4				endm 
# End of macro NEXTW
b2b4			 
b2b4			; float maths 
b2b4			 
b2b4				if FORTH_ENABLE_FLOATMATH 
b2b4					jr .neg_done 
b2b4			 
b2b4				endif 
b2b4					 
b2b4			 
b2b4			.neg_inum: 
b2b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2b4 cd a5 9a			call macro_dsp_valuehl 
b2b7				endm 
# End of macro FORTH_DSP_VALUEHL
b2b7			 
b2b7 e5					push hl 
b2b8			 
b2b8					; destroy value TOS 
b2b8			 
b2b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2b8 cd 5d 9b			call macro_forth_dsp_pop 
b2bb				endm 
# End of macro FORTH_DSP_POP
b2bb			 
b2bb			 
b2bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2bb cd a5 9a			call macro_dsp_valuehl 
b2be				endm 
# End of macro FORTH_DSP_VALUEHL
b2be			 
b2be					; one value on hl get other one back 
b2be			 
b2be d1					pop de 
b2bf			 
b2bf					; do the sub 
b2bf			;		ex de, hl 
b2bf			 
b2bf ed 52				sbc hl,de 
b2c1			 
b2c1					; save it 
b2c1			 
b2c1			;		push hl	 
b2c1			 
b2c1					; 
b2c1			 
b2c1					; destroy value TOS 
b2c1			 
b2c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2c1 cd 5d 9b			call macro_forth_dsp_pop 
b2c4				endm 
# End of macro FORTH_DSP_POP
b2c4			 
b2c4					; TODO push value back onto stack for another op etc 
b2c4			 
b2c4			;		pop hl 
b2c4			 
b2c4 cd ae 98				call forth_push_numhl 
b2c7			.neg_done: 
b2c7			 
b2c7					NEXTW 
b2c7 c3 17 9c			jp macro_next 
b2ca				endm 
# End of macro NEXTW
b2ca			.DIV: 
b2ca				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b2ca 18				db WORD_SYS_CORE+4             
b2cb 17 b3			dw .MUL            
b2cd 02				db 1 + 1 
b2ce .. 00			db "/",0              
b2d0				endm 
# End of macro CWHEAD
b2d0			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b2d0					if DEBUG_FORTH_WORDS_KEY 
b2d0						DMARK "DIV" 
b2d0 f5				push af  
b2d1 3a e5 b2			ld a, (.dmark)  
b2d4 32 c0 ee			ld (debug_mark),a  
b2d7 3a e6 b2			ld a, (.dmark+1)  
b2da 32 c1 ee			ld (debug_mark+1),a  
b2dd 3a e7 b2			ld a, (.dmark+2)  
b2e0 32 c2 ee			ld (debug_mark+2),a  
b2e3 18 03			jr .pastdmark  
b2e5 ..			.dmark: db "DIV"  
b2e8 f1			.pastdmark: pop af  
b2e9			endm  
# End of macro DMARK
b2e9						CALLMONITOR 
b2e9 cd 21 93			call break_point_state  
b2ec				endm  
# End of macro CALLMONITOR
b2ec					endif 
b2ec				; TODO add floating point number detection 
b2ec					; v5 FORTH_DSP_VALUE 
b2ec					FORTH_DSP 
b2ec cd 6b 9a			call macro_forth_dsp 
b2ef				endm 
# End of macro FORTH_DSP
b2ef 7e					ld a,(hl)	; get type of value on TOS 
b2f0 fe 02				cp DS_TYPE_INUM  
b2f2 28 03				jr z, .div_inum 
b2f4			 
b2f4				if FORTH_ENABLE_FLOATMATH 
b2f4					jr .div_done 
b2f4			 
b2f4				endif 
b2f4					NEXTW 
b2f4 c3 17 9c			jp macro_next 
b2f7				endm 
# End of macro NEXTW
b2f7			.div_inum: 
b2f7			 
b2f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2f7 cd a5 9a			call macro_dsp_valuehl 
b2fa				endm 
# End of macro FORTH_DSP_VALUEHL
b2fa			 
b2fa e5					push hl    ; to go to bc 
b2fb			 
b2fb					; destroy value TOS 
b2fb			 
b2fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2fb cd 5d 9b			call macro_forth_dsp_pop 
b2fe				endm 
# End of macro FORTH_DSP_POP
b2fe			 
b2fe			 
b2fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2fe cd a5 9a			call macro_dsp_valuehl 
b301				endm 
# End of macro FORTH_DSP_VALUEHL
b301			 
b301					; hl to go to de 
b301			 
b301 e5					push hl 
b302			 
b302 c1					pop bc 
b303 d1					pop de		 
b304			 
b304			 
b304					if DEBUG_FORTH_MATHS 
b304						DMARK "DIV" 
b304				CALLMONITOR 
b304					endif 
b304					; one value on hl but move to a get other one back 
b304			 
b304			        
b304 cd 04 8a			call Div16 
b307			 
b307			;	push af	 
b307 e5				push hl 
b308 c5				push bc 
b309			 
b309					if DEBUG_FORTH_MATHS 
b309						DMARK "DI1" 
b309				CALLMONITOR 
b309					endif 
b309			 
b309					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b309 cd 5d 9b			call macro_forth_dsp_pop 
b30c				endm 
# End of macro FORTH_DSP_POP
b30c			 
b30c			 
b30c			 
b30c e1					pop hl    ; result 
b30d			 
b30d cd ae 98				call forth_push_numhl 
b310			 
b310 e1					pop hl    ; reminder 
b311			;		ld h,0 
b311			;		ld l,d 
b311			 
b311 cd ae 98				call forth_push_numhl 
b314			.div_done: 
b314					NEXTW 
b314 c3 17 9c			jp macro_next 
b317				endm 
# End of macro NEXTW
b317			.MUL: 
b317				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b317 19				db WORD_SYS_CORE+5             
b318 5c b3			dw .MIN            
b31a 02				db 1 + 1 
b31b .. 00			db "*",0              
b31d				endm 
# End of macro CWHEAD
b31d			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b31d				; TODO add floating point number detection 
b31d					if DEBUG_FORTH_WORDS_KEY 
b31d						DMARK "MUL" 
b31d f5				push af  
b31e 3a 32 b3			ld a, (.dmark)  
b321 32 c0 ee			ld (debug_mark),a  
b324 3a 33 b3			ld a, (.dmark+1)  
b327 32 c1 ee			ld (debug_mark+1),a  
b32a 3a 34 b3			ld a, (.dmark+2)  
b32d 32 c2 ee			ld (debug_mark+2),a  
b330 18 03			jr .pastdmark  
b332 ..			.dmark: db "MUL"  
b335 f1			.pastdmark: pop af  
b336			endm  
# End of macro DMARK
b336						CALLMONITOR 
b336 cd 21 93			call break_point_state  
b339				endm  
# End of macro CALLMONITOR
b339					endif 
b339					FORTH_DSP 
b339 cd 6b 9a			call macro_forth_dsp 
b33c				endm 
# End of macro FORTH_DSP
b33c					; v5 FORTH_DSP_VALUE 
b33c 7e					ld a,(hl)	; get type of value on TOS 
b33d fe 02				cp DS_TYPE_INUM  
b33f 28 03				jr z, .mul_inum 
b341			 
b341				if FORTH_ENABLE_FLOATMATH 
b341					jr .mul_done 
b341			 
b341				endif 
b341			 
b341					NEXTW 
b341 c3 17 9c			jp macro_next 
b344				endm 
# End of macro NEXTW
b344			.mul_inum:	 
b344			 
b344					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b344 cd a5 9a			call macro_dsp_valuehl 
b347				endm 
# End of macro FORTH_DSP_VALUEHL
b347			 
b347 e5					push hl 
b348			 
b348					; destroy value TOS 
b348			 
b348					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b348 cd 5d 9b			call macro_forth_dsp_pop 
b34b				endm 
# End of macro FORTH_DSP_POP
b34b			 
b34b			 
b34b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b34b cd a5 9a			call macro_dsp_valuehl 
b34e				endm 
# End of macro FORTH_DSP_VALUEHL
b34e			 
b34e					; one value on hl but move to a get other one back 
b34e			 
b34e 7d					ld a, l 
b34f			 
b34f d1					pop de 
b350			 
b350					; do the mull 
b350			;		ex de, hl 
b350			 
b350 cd 2a 8a				call Mult16 
b353					; save it 
b353			 
b353			;		push hl	 
b353			 
b353					; 
b353			 
b353					; destroy value TOS 
b353			 
b353					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b353 cd 5d 9b			call macro_forth_dsp_pop 
b356				endm 
# End of macro FORTH_DSP_POP
b356			 
b356					; TODO push value back onto stack for another op etc 
b356			 
b356			;		pop hl 
b356			 
b356 cd ae 98				call forth_push_numhl 
b359			 
b359			.mul_done: 
b359					NEXTW 
b359 c3 17 9c			jp macro_next 
b35c				endm 
# End of macro NEXTW
b35c			 
b35c			 
b35c			 
b35c			 
b35c			.MIN: 
b35c				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b35c 49				db WORD_SYS_CORE+53             
b35d dd b3			dw .MAX            
b35f 04				db 3 + 1 
b360 .. 00			db "MIN",0              
b364				endm 
# End of macro CWHEAD
b364			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b364					if DEBUG_FORTH_WORDS_KEY 
b364						DMARK "MIN" 
b364 f5				push af  
b365 3a 79 b3			ld a, (.dmark)  
b368 32 c0 ee			ld (debug_mark),a  
b36b 3a 7a b3			ld a, (.dmark+1)  
b36e 32 c1 ee			ld (debug_mark+1),a  
b371 3a 7b b3			ld a, (.dmark+2)  
b374 32 c2 ee			ld (debug_mark+2),a  
b377 18 03			jr .pastdmark  
b379 ..			.dmark: db "MIN"  
b37c f1			.pastdmark: pop af  
b37d			endm  
# End of macro DMARK
b37d						CALLMONITOR 
b37d cd 21 93			call break_point_state  
b380				endm  
# End of macro CALLMONITOR
b380					endif 
b380					; get u2 
b380			 
b380					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b380 cd a5 9a			call macro_dsp_valuehl 
b383				endm 
# End of macro FORTH_DSP_VALUEHL
b383			 
b383 e5					push hl   ; u2 
b384			 
b384					; destroy value TOS 
b384			 
b384					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b384 cd 5d 9b			call macro_forth_dsp_pop 
b387				endm 
# End of macro FORTH_DSP_POP
b387			 
b387					; get u1 
b387			 
b387					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b387 cd a5 9a			call macro_dsp_valuehl 
b38a				endm 
# End of macro FORTH_DSP_VALUEHL
b38a			 
b38a e5					push hl  ; u1 
b38b			 
b38b					; destroy value TOS 
b38b			 
b38b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b38b cd 5d 9b			call macro_forth_dsp_pop 
b38e				endm 
# End of macro FORTH_DSP_POP
b38e			 
b38e b7			 or a      ;clear carry flag 
b38f e1			  pop hl    ; u1 
b390 d1			  pop de    ; u2 
b391 e5				push hl   ; saved in case hl is lowest 
b392 ed 52		  sbc hl,de 
b394 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b396			 
b396 e1				pop hl 
b397					if DEBUG_FORTH_WORDS 
b397						DMARK "MIN" 
b397 f5				push af  
b398 3a ac b3			ld a, (.dmark)  
b39b 32 c0 ee			ld (debug_mark),a  
b39e 3a ad b3			ld a, (.dmark+1)  
b3a1 32 c1 ee			ld (debug_mark+1),a  
b3a4 3a ae b3			ld a, (.dmark+2)  
b3a7 32 c2 ee			ld (debug_mark+2),a  
b3aa 18 03			jr .pastdmark  
b3ac ..			.dmark: db "MIN"  
b3af f1			.pastdmark: pop af  
b3b0			endm  
# End of macro DMARK
b3b0						CALLMONITOR 
b3b0 cd 21 93			call break_point_state  
b3b3				endm  
# End of macro CALLMONITOR
b3b3					endif 
b3b3 cd ae 98				call forth_push_numhl 
b3b6			 
b3b6				       NEXTW 
b3b6 c3 17 9c			jp macro_next 
b3b9				endm 
# End of macro NEXTW
b3b9			 
b3b9			.mincont:  
b3b9 c1				pop bc   ; tidy up 
b3ba eb				ex de , hl  
b3bb					if DEBUG_FORTH_WORDS 
b3bb						DMARK "MI1" 
b3bb f5				push af  
b3bc 3a d0 b3			ld a, (.dmark)  
b3bf 32 c0 ee			ld (debug_mark),a  
b3c2 3a d1 b3			ld a, (.dmark+1)  
b3c5 32 c1 ee			ld (debug_mark+1),a  
b3c8 3a d2 b3			ld a, (.dmark+2)  
b3cb 32 c2 ee			ld (debug_mark+2),a  
b3ce 18 03			jr .pastdmark  
b3d0 ..			.dmark: db "MI1"  
b3d3 f1			.pastdmark: pop af  
b3d4			endm  
# End of macro DMARK
b3d4						CALLMONITOR 
b3d4 cd 21 93			call break_point_state  
b3d7				endm  
# End of macro CALLMONITOR
b3d7					endif 
b3d7 cd ae 98				call forth_push_numhl 
b3da			 
b3da				       NEXTW 
b3da c3 17 9c			jp macro_next 
b3dd				endm 
# End of macro NEXTW
b3dd			.MAX: 
b3dd				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b3dd 4a				db WORD_SYS_CORE+54             
b3de 5e b4			dw .RND16            
b3e0 04				db 3 + 1 
b3e1 .. 00			db "MAX",0              
b3e5				endm 
# End of macro CWHEAD
b3e5			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b3e5					if DEBUG_FORTH_WORDS_KEY 
b3e5						DMARK "MAX" 
b3e5 f5				push af  
b3e6 3a fa b3			ld a, (.dmark)  
b3e9 32 c0 ee			ld (debug_mark),a  
b3ec 3a fb b3			ld a, (.dmark+1)  
b3ef 32 c1 ee			ld (debug_mark+1),a  
b3f2 3a fc b3			ld a, (.dmark+2)  
b3f5 32 c2 ee			ld (debug_mark+2),a  
b3f8 18 03			jr .pastdmark  
b3fa ..			.dmark: db "MAX"  
b3fd f1			.pastdmark: pop af  
b3fe			endm  
# End of macro DMARK
b3fe						CALLMONITOR 
b3fe cd 21 93			call break_point_state  
b401				endm  
# End of macro CALLMONITOR
b401					endif 
b401					; get u2 
b401			 
b401					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b401 cd a5 9a			call macro_dsp_valuehl 
b404				endm 
# End of macro FORTH_DSP_VALUEHL
b404			 
b404 e5					push hl   ; u2 
b405			 
b405					; destroy value TOS 
b405			 
b405					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b405 cd 5d 9b			call macro_forth_dsp_pop 
b408				endm 
# End of macro FORTH_DSP_POP
b408			 
b408					; get u1 
b408			 
b408					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b408 cd a5 9a			call macro_dsp_valuehl 
b40b				endm 
# End of macro FORTH_DSP_VALUEHL
b40b			 
b40b e5					push hl  ; u1 
b40c			 
b40c					; destroy value TOS 
b40c			 
b40c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b40c cd 5d 9b			call macro_forth_dsp_pop 
b40f				endm 
# End of macro FORTH_DSP_POP
b40f			 
b40f b7			 or a      ;clear carry flag 
b410 e1			  pop hl    ; u1 
b411 d1			  pop de    ; u2 
b412 e5				push hl   ; saved in case hl is lowest 
b413 ed 52		  sbc hl,de 
b415 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b417			 
b417 e1				pop hl 
b418					if DEBUG_FORTH_WORDS 
b418						DMARK "MAX" 
b418 f5				push af  
b419 3a 2d b4			ld a, (.dmark)  
b41c 32 c0 ee			ld (debug_mark),a  
b41f 3a 2e b4			ld a, (.dmark+1)  
b422 32 c1 ee			ld (debug_mark+1),a  
b425 3a 2f b4			ld a, (.dmark+2)  
b428 32 c2 ee			ld (debug_mark+2),a  
b42b 18 03			jr .pastdmark  
b42d ..			.dmark: db "MAX"  
b430 f1			.pastdmark: pop af  
b431			endm  
# End of macro DMARK
b431						CALLMONITOR 
b431 cd 21 93			call break_point_state  
b434				endm  
# End of macro CALLMONITOR
b434					endif 
b434 cd ae 98				call forth_push_numhl 
b437			 
b437				       NEXTW 
b437 c3 17 9c			jp macro_next 
b43a				endm 
# End of macro NEXTW
b43a			 
b43a			.maxcont:  
b43a c1				pop bc   ; tidy up 
b43b eb				ex de , hl  
b43c					if DEBUG_FORTH_WORDS 
b43c						DMARK "MA1" 
b43c f5				push af  
b43d 3a 51 b4			ld a, (.dmark)  
b440 32 c0 ee			ld (debug_mark),a  
b443 3a 52 b4			ld a, (.dmark+1)  
b446 32 c1 ee			ld (debug_mark+1),a  
b449 3a 53 b4			ld a, (.dmark+2)  
b44c 32 c2 ee			ld (debug_mark+2),a  
b44f 18 03			jr .pastdmark  
b451 ..			.dmark: db "MA1"  
b454 f1			.pastdmark: pop af  
b455			endm  
# End of macro DMARK
b455						CALLMONITOR 
b455 cd 21 93			call break_point_state  
b458				endm  
# End of macro CALLMONITOR
b458					endif 
b458 cd ae 98				call forth_push_numhl 
b45b				       NEXTW 
b45b c3 17 9c			jp macro_next 
b45e				endm 
# End of macro NEXTW
b45e			 
b45e			.RND16: 
b45e				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b45e 4e				db WORD_SYS_CORE+58             
b45f 8d b4			dw .RND8            
b461 06				db 5 + 1 
b462 .. 00			db "RND16",0              
b468				endm 
# End of macro CWHEAD
b468			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b468					if DEBUG_FORTH_WORDS_KEY 
b468						DMARK "R16" 
b468 f5				push af  
b469 3a 7d b4			ld a, (.dmark)  
b46c 32 c0 ee			ld (debug_mark),a  
b46f 3a 7e b4			ld a, (.dmark+1)  
b472 32 c1 ee			ld (debug_mark+1),a  
b475 3a 7f b4			ld a, (.dmark+2)  
b478 32 c2 ee			ld (debug_mark+2),a  
b47b 18 03			jr .pastdmark  
b47d ..			.dmark: db "R16"  
b480 f1			.pastdmark: pop af  
b481			endm  
# End of macro DMARK
b481						CALLMONITOR 
b481 cd 21 93			call break_point_state  
b484				endm  
# End of macro CALLMONITOR
b484					endif 
b484 cd ce 89				call prng16  
b487 cd ae 98				call forth_push_numhl 
b48a				       NEXTW 
b48a c3 17 9c			jp macro_next 
b48d				endm 
# End of macro NEXTW
b48d			.RND8: 
b48d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b48d 60				db WORD_SYS_CORE+76             
b48e c2 b4			dw .RND            
b490 05				db 4 + 1 
b491 .. 00			db "RND8",0              
b496				endm 
# End of macro CWHEAD
b496			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b496					if DEBUG_FORTH_WORDS_KEY 
b496						DMARK "RN8" 
b496 f5				push af  
b497 3a ab b4			ld a, (.dmark)  
b49a 32 c0 ee			ld (debug_mark),a  
b49d 3a ac b4			ld a, (.dmark+1)  
b4a0 32 c1 ee			ld (debug_mark+1),a  
b4a3 3a ad b4			ld a, (.dmark+2)  
b4a6 32 c2 ee			ld (debug_mark+2),a  
b4a9 18 03			jr .pastdmark  
b4ab ..			.dmark: db "RN8"  
b4ae f1			.pastdmark: pop af  
b4af			endm  
# End of macro DMARK
b4af						CALLMONITOR 
b4af cd 21 93			call break_point_state  
b4b2				endm  
# End of macro CALLMONITOR
b4b2					endif 
b4b2 2a 41 ed				ld hl,(xrandc) 
b4b5 23					inc hl 
b4b6 cd e8 89				call xrnd 
b4b9 6f					ld l,a	 
b4ba 26 00				ld h,0 
b4bc cd ae 98				call forth_push_numhl 
b4bf				       NEXTW 
b4bf c3 17 9c			jp macro_next 
b4c2				endm 
# End of macro NEXTW
b4c2			.RND: 
b4c2				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b4c2 60				db WORD_SYS_CORE+76             
b4c3 c8 b5			dw .ENDMATHS            
b4c5 04				db 3 + 1 
b4c6 .. 00			db "RND",0              
b4ca				endm 
# End of macro CWHEAD
b4ca			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b4ca			 
b4ca					if DEBUG_FORTH_WORDS_KEY 
b4ca						DMARK "RND" 
b4ca f5				push af  
b4cb 3a df b4			ld a, (.dmark)  
b4ce 32 c0 ee			ld (debug_mark),a  
b4d1 3a e0 b4			ld a, (.dmark+1)  
b4d4 32 c1 ee			ld (debug_mark+1),a  
b4d7 3a e1 b4			ld a, (.dmark+2)  
b4da 32 c2 ee			ld (debug_mark+2),a  
b4dd 18 03			jr .pastdmark  
b4df ..			.dmark: db "RND"  
b4e2 f1			.pastdmark: pop af  
b4e3			endm  
# End of macro DMARK
b4e3						CALLMONITOR 
b4e3 cd 21 93			call break_point_state  
b4e6				endm  
# End of macro CALLMONITOR
b4e6					endif 
b4e6					 
b4e6					FORTH_DSP_VALUEHL    ; upper range 
b4e6 cd a5 9a			call macro_dsp_valuehl 
b4e9				endm 
# End of macro FORTH_DSP_VALUEHL
b4e9			 
b4e9 22 45 ed				ld (LFSRSeed), hl	 
b4ec			 
b4ec					if DEBUG_FORTH_WORDS 
b4ec						DMARK "RN1" 
b4ec f5				push af  
b4ed 3a 01 b5			ld a, (.dmark)  
b4f0 32 c0 ee			ld (debug_mark),a  
b4f3 3a 02 b5			ld a, (.dmark+1)  
b4f6 32 c1 ee			ld (debug_mark+1),a  
b4f9 3a 03 b5			ld a, (.dmark+2)  
b4fc 32 c2 ee			ld (debug_mark+2),a  
b4ff 18 03			jr .pastdmark  
b501 ..			.dmark: db "RN1"  
b504 f1			.pastdmark: pop af  
b505			endm  
# End of macro DMARK
b505						CALLMONITOR 
b505 cd 21 93			call break_point_state  
b508				endm  
# End of macro CALLMONITOR
b508					endif 
b508					FORTH_DSP_POP 
b508 cd 5d 9b			call macro_forth_dsp_pop 
b50b				endm 
# End of macro FORTH_DSP_POP
b50b			 
b50b					FORTH_DSP_VALUEHL    ; low range 
b50b cd a5 9a			call macro_dsp_valuehl 
b50e				endm 
# End of macro FORTH_DSP_VALUEHL
b50e			 
b50e					if DEBUG_FORTH_WORDS 
b50e						DMARK "RN2" 
b50e f5				push af  
b50f 3a 23 b5			ld a, (.dmark)  
b512 32 c0 ee			ld (debug_mark),a  
b515 3a 24 b5			ld a, (.dmark+1)  
b518 32 c1 ee			ld (debug_mark+1),a  
b51b 3a 25 b5			ld a, (.dmark+2)  
b51e 32 c2 ee			ld (debug_mark+2),a  
b521 18 03			jr .pastdmark  
b523 ..			.dmark: db "RN2"  
b526 f1			.pastdmark: pop af  
b527			endm  
# End of macro DMARK
b527						CALLMONITOR 
b527 cd 21 93			call break_point_state  
b52a				endm  
# End of macro CALLMONITOR
b52a					endif 
b52a 22 47 ed				ld (LFSRSeed+2), hl 
b52d			 
b52d					FORTH_DSP_POP 
b52d cd 5d 9b			call macro_forth_dsp_pop 
b530				endm 
# End of macro FORTH_DSP_POP
b530			 
b530 e5					push hl 
b531			 
b531 e1			.inrange:	pop hl 
b532 cd ce 89				call prng16  
b535					if DEBUG_FORTH_WORDS 
b535						DMARK "RN3" 
b535 f5				push af  
b536 3a 4a b5			ld a, (.dmark)  
b539 32 c0 ee			ld (debug_mark),a  
b53c 3a 4b b5			ld a, (.dmark+1)  
b53f 32 c1 ee			ld (debug_mark+1),a  
b542 3a 4c b5			ld a, (.dmark+2)  
b545 32 c2 ee			ld (debug_mark+2),a  
b548 18 03			jr .pastdmark  
b54a ..			.dmark: db "RN3"  
b54d f1			.pastdmark: pop af  
b54e			endm  
# End of macro DMARK
b54e						CALLMONITOR 
b54e cd 21 93			call break_point_state  
b551				endm  
# End of macro CALLMONITOR
b551					endif 
b551					 
b551					; if the range is 8bit knock out the high byte 
b551			 
b551 ed 5b 45 ed			ld de, (LFSRSeed)     ; check high level 
b555			 
b555 3e 00				ld a, 0 
b557 ba					cp d  
b558 20 1e				jr nz, .hirange 
b55a 26 00				ld h, 0   ; knock it down to 8bit 
b55c			 
b55c					if DEBUG_FORTH_WORDS 
b55c						DMARK "RNk" 
b55c f5				push af  
b55d 3a 71 b5			ld a, (.dmark)  
b560 32 c0 ee			ld (debug_mark),a  
b563 3a 72 b5			ld a, (.dmark+1)  
b566 32 c1 ee			ld (debug_mark+1),a  
b569 3a 73 b5			ld a, (.dmark+2)  
b56c 32 c2 ee			ld (debug_mark+2),a  
b56f 18 03			jr .pastdmark  
b571 ..			.dmark: db "RNk"  
b574 f1			.pastdmark: pop af  
b575			endm  
# End of macro DMARK
b575						CALLMONITOR 
b575 cd 21 93			call break_point_state  
b578				endm  
# End of macro CALLMONITOR
b578					endif 
b578			.hirange:   
b578 e5					push hl  
b579 b7					or a  
b57a ed 52		                sbc hl, de 
b57c			 
b57c					;call cmp16 
b57c			 
b57c 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b57e e1					pop hl 
b57f e5					push hl 
b580			 
b580					if DEBUG_FORTH_WORDS 
b580						DMARK "RN4" 
b580 f5				push af  
b581 3a 95 b5			ld a, (.dmark)  
b584 32 c0 ee			ld (debug_mark),a  
b587 3a 96 b5			ld a, (.dmark+1)  
b58a 32 c1 ee			ld (debug_mark+1),a  
b58d 3a 97 b5			ld a, (.dmark+2)  
b590 32 c2 ee			ld (debug_mark+2),a  
b593 18 03			jr .pastdmark  
b595 ..			.dmark: db "RN4"  
b598 f1			.pastdmark: pop af  
b599			endm  
# End of macro DMARK
b599						CALLMONITOR 
b599 cd 21 93			call break_point_state  
b59c				endm  
# End of macro CALLMONITOR
b59c					endif 
b59c ed 5b 47 ed			ld de, (LFSRSeed+2)   ; check low range 
b5a0					;call cmp16 
b5a0				 
b5a0 b7					or a  
b5a1 ed 52		                sbc hl, de 
b5a3 38 8c				jr c, .inrange 
b5a5			 
b5a5 e1					pop hl 
b5a6					 
b5a6					if DEBUG_FORTH_WORDS 
b5a6						DMARK "RNd" 
b5a6 f5				push af  
b5a7 3a bb b5			ld a, (.dmark)  
b5aa 32 c0 ee			ld (debug_mark),a  
b5ad 3a bc b5			ld a, (.dmark+1)  
b5b0 32 c1 ee			ld (debug_mark+1),a  
b5b3 3a bd b5			ld a, (.dmark+2)  
b5b6 32 c2 ee			ld (debug_mark+2),a  
b5b9 18 03			jr .pastdmark  
b5bb ..			.dmark: db "RNd"  
b5be f1			.pastdmark: pop af  
b5bf			endm  
# End of macro DMARK
b5bf						CALLMONITOR 
b5bf cd 21 93			call break_point_state  
b5c2				endm  
# End of macro CALLMONITOR
b5c2					endif 
b5c2			 
b5c2			 
b5c2 cd ae 98				call forth_push_numhl 
b5c5				       NEXTW 
b5c5 c3 17 9c			jp macro_next 
b5c8				endm 
# End of macro NEXTW
b5c8			 
b5c8			.ENDMATHS: 
b5c8			 
b5c8			; eof 
b5c8			 
# End of file forth_words_maths.asm
b5c8			include "forth_words_display.asm" 
b5c8			 
b5c8			; | ## Display Words 
b5c8			 
b5c8			.ATP: 
b5c8				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b5c8 62				db WORD_SYS_CORE+78             
b5c9 3f b6			dw .FB            
b5cb 04				db 3 + 1 
b5cc .. 00			db "AT?",0              
b5d0				endm 
# End of macro CWHEAD
b5d0			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b5d0					if DEBUG_FORTH_WORDS_KEY 
b5d0						DMARK "AT?" 
b5d0 f5				push af  
b5d1 3a e5 b5			ld a, (.dmark)  
b5d4 32 c0 ee			ld (debug_mark),a  
b5d7 3a e6 b5			ld a, (.dmark+1)  
b5da 32 c1 ee			ld (debug_mark+1),a  
b5dd 3a e7 b5			ld a, (.dmark+2)  
b5e0 32 c2 ee			ld (debug_mark+2),a  
b5e3 18 03			jr .pastdmark  
b5e5 ..			.dmark: db "AT?"  
b5e8 f1			.pastdmark: pop af  
b5e9			endm  
# End of macro DMARK
b5e9						CALLMONITOR 
b5e9 cd 21 93			call break_point_state  
b5ec				endm  
# End of macro CALLMONITOR
b5ec					endif 
b5ec 3a cf ec				ld a, (f_cursor_ptr) 
b5ef			 
b5ef			if DEBUG_FORTH_WORDS 
b5ef				DMARK "AT?" 
b5ef f5				push af  
b5f0 3a 04 b6			ld a, (.dmark)  
b5f3 32 c0 ee			ld (debug_mark),a  
b5f6 3a 05 b6			ld a, (.dmark+1)  
b5f9 32 c1 ee			ld (debug_mark+1),a  
b5fc 3a 06 b6			ld a, (.dmark+2)  
b5ff 32 c2 ee			ld (debug_mark+2),a  
b602 18 03			jr .pastdmark  
b604 ..			.dmark: db "AT?"  
b607 f1			.pastdmark: pop af  
b608			endm  
# End of macro DMARK
b608				CALLMONITOR 
b608 cd 21 93			call break_point_state  
b60b				endm  
# End of macro CALLMONITOR
b60b			endif	 
b60b					; count the number of rows 
b60b			 
b60b 06 00				ld b, 0 
b60d 4f			.atpr:		ld c, a    ; save in case we go below zero 
b60e d6 14				sub display_cols 
b610 f2 16 b6				jp p, .atprunder 
b613 04					inc b 
b614 18 f7				jr .atpr 
b616			.atprunder:	 
b616			if DEBUG_FORTH_WORDS 
b616				DMARK "A?2" 
b616 f5				push af  
b617 3a 2b b6			ld a, (.dmark)  
b61a 32 c0 ee			ld (debug_mark),a  
b61d 3a 2c b6			ld a, (.dmark+1)  
b620 32 c1 ee			ld (debug_mark+1),a  
b623 3a 2d b6			ld a, (.dmark+2)  
b626 32 c2 ee			ld (debug_mark+2),a  
b629 18 03			jr .pastdmark  
b62b ..			.dmark: db "A?2"  
b62e f1			.pastdmark: pop af  
b62f			endm  
# End of macro DMARK
b62f				CALLMONITOR 
b62f cd 21 93			call break_point_state  
b632				endm  
# End of macro CALLMONITOR
b632			endif	 
b632 26 00				ld h, 0 
b634 69					ld l, c 
b635 cd ae 98				call forth_push_numhl 
b638 68					ld l, b  
b639 cd ae 98				call forth_push_numhl 
b63c			 
b63c			 
b63c				NEXTW 
b63c c3 17 9c			jp macro_next 
b63f				endm 
# End of macro NEXTW
b63f			 
b63f			.FB: 
b63f				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b63f 1b				db WORD_SYS_CORE+7             
b640 8d b6			dw .EMIT            
b642 03				db 2 + 1 
b643 .. 00			db "FB",0              
b646				endm 
# End of macro CWHEAD
b646			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b646			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b646			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b646			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b646					if DEBUG_FORTH_WORDS_KEY 
b646						DMARK "FB." 
b646 f5				push af  
b647 3a 5b b6			ld a, (.dmark)  
b64a 32 c0 ee			ld (debug_mark),a  
b64d 3a 5c b6			ld a, (.dmark+1)  
b650 32 c1 ee			ld (debug_mark+1),a  
b653 3a 5d b6			ld a, (.dmark+2)  
b656 32 c2 ee			ld (debug_mark+2),a  
b659 18 03			jr .pastdmark  
b65b ..			.dmark: db "FB."  
b65e f1			.pastdmark: pop af  
b65f			endm  
# End of macro DMARK
b65f						CALLMONITOR 
b65f cd 21 93			call break_point_state  
b662				endm  
# End of macro CALLMONITOR
b662					endif 
b662			 
b662					FORTH_DSP_VALUEHL 
b662 cd a5 9a			call macro_dsp_valuehl 
b665				endm 
# End of macro FORTH_DSP_VALUEHL
b665			 
b665 7d					ld a, l 
b666 fe 01				cp 1 
b668 20 05				jr nz, .fbn1 
b66a 21 05 ee				ld hl, display_fb1 
b66d 18 15				jr .fbset 
b66f fe 02		.fbn1:		cp 2 
b671 20 05				jr nz, .fbn2 
b673 21 63 ed				ld hl, display_fb2 
b676 18 0c				jr .fbset 
b678 fe 03		.fbn2:		cp 3 
b67a 20 05				jr nz, .fbn3 
b67c 21 b4 ed				ld hl, display_fb3 
b67f 18 03				jr .fbset 
b681			.fbn3:		 ; if invalid number select first 
b681 21 05 ee				ld hl, display_fb1 
b684 22 61 ed		.fbset:		ld (display_fb_active), hl 
b687			 
b687					FORTH_DSP_POP 
b687 cd 5d 9b			call macro_forth_dsp_pop 
b68a				endm 
# End of macro FORTH_DSP_POP
b68a			 
b68a					NEXTW 
b68a c3 17 9c			jp macro_next 
b68d				endm 
# End of macro NEXTW
b68d			 
b68d			 
b68d			.EMIT: 
b68d				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b68d 1b				db WORD_SYS_CORE+7             
b68e de b6			dw .DOTH            
b690 05				db 4 + 1 
b691 .. 00			db "EMIT",0              
b696				endm 
# End of macro CWHEAD
b696			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b696					; get value off TOS and display it 
b696			 
b696					if DEBUG_FORTH_WORDS_KEY 
b696						DMARK "EMT" 
b696 f5				push af  
b697 3a ab b6			ld a, (.dmark)  
b69a 32 c0 ee			ld (debug_mark),a  
b69d 3a ac b6			ld a, (.dmark+1)  
b6a0 32 c1 ee			ld (debug_mark+1),a  
b6a3 3a ad b6			ld a, (.dmark+2)  
b6a6 32 c2 ee			ld (debug_mark+2),a  
b6a9 18 03			jr .pastdmark  
b6ab ..			.dmark: db "EMT"  
b6ae f1			.pastdmark: pop af  
b6af			endm  
# End of macro DMARK
b6af						CALLMONITOR 
b6af cd 21 93			call break_point_state  
b6b2				endm  
# End of macro CALLMONITOR
b6b2					endif 
b6b2			 
b6b2					FORTH_DSP_VALUEHL 
b6b2 cd a5 9a			call macro_dsp_valuehl 
b6b5				endm 
# End of macro FORTH_DSP_VALUEHL
b6b5			 
b6b5 7d					ld a,l 
b6b6			 
b6b6					; TODO write to display 
b6b6			 
b6b6 32 e4 e6				ld (os_input), a 
b6b9 3e 00				ld a, 0 
b6bb 32 e5 e6				ld (os_input+1), a 
b6be					 
b6be 3a cf ec				ld a, (f_cursor_ptr) 
b6c1 11 e4 e6				ld de, os_input 
b6c4 cd 8d 88				call str_at_display 
b6c7			 
b6c7			 
b6c7 3a ad ec				ld a,(cli_autodisplay) 
b6ca fe 00				cp 0 
b6cc 28 03				jr z, .enoupdate 
b6ce cd 9d 88						call update_display 
b6d1					.enoupdate: 
b6d1			 
b6d1 3a cf ec				ld a, (f_cursor_ptr) 
b6d4 3c					inc a 
b6d5 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b6d8			 
b6d8			 
b6d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6d8 cd 5d 9b			call macro_forth_dsp_pop 
b6db				endm 
# End of macro FORTH_DSP_POP
b6db			  
b6db			 
b6db					NEXTW 
b6db c3 17 9c			jp macro_next 
b6de				endm 
# End of macro NEXTW
b6de			.DOTH: 
b6de				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b6de 1c				db WORD_SYS_CORE+8             
b6df 0e b7			dw .DOTF            
b6e1 03				db 2 + 1 
b6e2 .. 00			db ".-",0              
b6e5				endm 
# End of macro CWHEAD
b6e5			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b6e5					; get value off TOS and display it 
b6e5					if DEBUG_FORTH_WORDS_KEY 
b6e5						DMARK "DTD" 
b6e5 f5				push af  
b6e6 3a fa b6			ld a, (.dmark)  
b6e9 32 c0 ee			ld (debug_mark),a  
b6ec 3a fb b6			ld a, (.dmark+1)  
b6ef 32 c1 ee			ld (debug_mark+1),a  
b6f2 3a fc b6			ld a, (.dmark+2)  
b6f5 32 c2 ee			ld (debug_mark+2),a  
b6f8 18 03			jr .pastdmark  
b6fa ..			.dmark: db "DTD"  
b6fd f1			.pastdmark: pop af  
b6fe			endm  
# End of macro DMARK
b6fe						CALLMONITOR 
b6fe cd 21 93			call break_point_state  
b701				endm  
# End of macro CALLMONITOR
b701					endif 
b701 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b703 3e 00			ld a, 0 
b705 32 ae ec			ld (cli_mvdot), a 
b708 c3 65 b7			jp .dotgo 
b70b				NEXTW 
b70b c3 17 9c			jp macro_next 
b70e				endm 
# End of macro NEXTW
b70e			.DOTF: 
b70e				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b70e 1c				db WORD_SYS_CORE+8             
b70f 3c b7			dw .DOT            
b711 03				db 2 + 1 
b712 .. 00			db ".>",0              
b715				endm 
# End of macro CWHEAD
b715			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b715					; get value off TOS and display it 
b715			        ; TODO BUG adds extra spaces 
b715			        ; TODO BUG handle numerics? 
b715					if DEBUG_FORTH_WORDS_KEY 
b715						DMARK "DTC" 
b715 f5				push af  
b716 3a 2a b7			ld a, (.dmark)  
b719 32 c0 ee			ld (debug_mark),a  
b71c 3a 2b b7			ld a, (.dmark+1)  
b71f 32 c1 ee			ld (debug_mark+1),a  
b722 3a 2c b7			ld a, (.dmark+2)  
b725 32 c2 ee			ld (debug_mark+2),a  
b728 18 03			jr .pastdmark  
b72a ..			.dmark: db "DTC"  
b72d f1			.pastdmark: pop af  
b72e			endm  
# End of macro DMARK
b72e						CALLMONITOR 
b72e cd 21 93			call break_point_state  
b731				endm  
# End of macro CALLMONITOR
b731					endif 
b731 3e 01			ld a, 1 
b733 32 ae ec			ld (cli_mvdot), a 
b736 c3 65 b7			jp .dotgo 
b739				NEXTW 
b739 c3 17 9c			jp macro_next 
b73c				endm 
# End of macro NEXTW
b73c			 
b73c			.DOT: 
b73c				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b73c 1c				db WORD_SYS_CORE+8             
b73d c8 b7			dw .CLS            
b73f 02				db 1 + 1 
b740 .. 00			db ".",0              
b742				endm 
# End of macro CWHEAD
b742			        ; | . ( u -- ) Display TOS | DONE 
b742					; get value off TOS and display it 
b742			 
b742					if DEBUG_FORTH_WORDS_KEY 
b742						DMARK "DOT" 
b742 f5				push af  
b743 3a 57 b7			ld a, (.dmark)  
b746 32 c0 ee			ld (debug_mark),a  
b749 3a 58 b7			ld a, (.dmark+1)  
b74c 32 c1 ee			ld (debug_mark+1),a  
b74f 3a 59 b7			ld a, (.dmark+2)  
b752 32 c2 ee			ld (debug_mark+2),a  
b755 18 03			jr .pastdmark  
b757 ..			.dmark: db "DOT"  
b75a f1			.pastdmark: pop af  
b75b			endm  
# End of macro DMARK
b75b						CALLMONITOR 
b75b cd 21 93			call break_point_state  
b75e				endm  
# End of macro CALLMONITOR
b75e					endif 
b75e 3e 00			ld a, 0 
b760 32 ae ec			ld (cli_mvdot), a 
b763 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b765				 
b765			 
b765			.dotgo: 
b765			 
b765			; move up type to on stack for parserv5 
b765					FORTH_DSP 
b765 cd 6b 9a			call macro_forth_dsp 
b768				endm 
# End of macro FORTH_DSP
b768				;FORTH_DSP_VALUE  
b768			 
b768			if DEBUG_FORTH_DOT 
b768				DMARK "DOT" 
b768				CALLMONITOR 
b768			endif	 
b768			;		.print: 
b768			 
b768 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b769 23				inc hl   ; position to the actual value 
b76a fe 01			cp DS_TYPE_STR 
b76c 20 06			jr nz, .dotnum1  
b76e			 
b76e			; display string 
b76e				FORTH_DSP_VALUE  
b76e cd 8e 9a			call macro_forth_dsp_value 
b771				endm 
# End of macro FORTH_DSP_VALUE
b771 eb				ex de,hl 
b772 18 11			jr .dotwrite 
b774			 
b774			.dotnum1: 
b774 fe 02			cp DS_TYPE_INUM 
b776 20 0c			jr nz, .dotflot 
b778			 
b778			 
b778			; display number 
b778			 
b778			;	push hl 
b778			;	call clear_display 
b778			;	pop hl 
b778			 
b778 5e				ld e, (hl) 
b779 23				inc hl 
b77a 56				ld d, (hl) 
b77b 21 e6 e4			ld hl, scratch 
b77e			if DEBUG_FORTH_DOT 
b77e				DMARK "DT1" 
b77e				CALLMONITOR 
b77e			endif	 
b77e			 
b77e cd b4 8e			call uitoa_16 
b781 eb				ex de,hl 
b782			 
b782			if DEBUG_FORTH_DOT 
b782				DMARK "DT2" 
b782				CALLMONITOR 
b782			endif	 
b782			 
b782			;	ld de, os_word_scratch 
b782 18 01			jr .dotwrite 
b784			 
b784 00			.dotflot:   nop 
b785			; TODO print floating point number 
b785			 
b785			.dotwrite:		 
b785			 
b785					; if c is set then set all '-' to spaces 
b785					; need to also take into account .>  
b785			 
b785 3e 01				ld a, 1 
b787 b9					cp c 
b788 20 13				jr nz, .nodashswap 
b78a			 
b78a					; DE has the string to write, working with HL 
b78a			 
b78a 06 ff				ld b, 255 
b78c d5					push de 
b78d e1					pop hl 
b78e			 
b78e			if DEBUG_FORTH_DOT 
b78e				DMARK "DT-" 
b78e				CALLMONITOR 
b78e			endif	 
b78e 7e			.dashscan:	ld a, (hl) 
b78f fe 00				cp 0 
b791 28 0a				jr z, .nodashswap 
b793 fe 2d				cp '-' 
b795 20 03				jr nz, .dashskip 
b797 3e 20				ld a, ' ' 
b799 77					ld (hl), a 
b79a 23			.dashskip:	inc hl 
b79b			if DEBUG_FORTH_DOT 
b79b				DMARK "D-2" 
b79b				CALLMONITOR 
b79b			endif	 
b79b 10 f1				djnz .dashscan 
b79d			 
b79d			if DEBUG_FORTH_DOT 
b79d				DMARK "D-1" 
b79d				CALLMONITOR 
b79d			endif	 
b79d			 
b79d			.nodashswap: 
b79d			 
b79d e5					push hl   ; save string start in case we need to advance print 
b79e			 
b79e 3a cf ec				ld a, (f_cursor_ptr) 
b7a1 cd 8d 88				call str_at_display 
b7a4 3a ad ec				ld a,(cli_autodisplay) 
b7a7 fe 00				cp 0 
b7a9 28 03				jr z, .noupdate 
b7ab cd 9d 88						call update_display 
b7ae					.noupdate: 
b7ae			 
b7ae			 
b7ae					; see if we need to advance the print position 
b7ae			 
b7ae e1					pop hl   ; get back string 
b7af			 
b7af 3a ae ec				ld a, (cli_mvdot) 
b7b2			if DEBUG_FORTH_DOT 
b7b2					ld e,a 
b7b2				DMARK "D>1" 
b7b2				CALLMONITOR 
b7b2			endif	 
b7b2 fe 00				cp 0 
b7b4 28 0c				jr z, .noadv 
b7b6					; yes, lets advance the print position 
b7b6 3e 00				ld a, 0 
b7b8 cd 10 8f				call strlent 
b7bb 3a cf ec				ld a, (f_cursor_ptr) 
b7be 85					add a,l 
b7bf					;call addatohl 
b7bf					;ld a, l 
b7bf 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b7c2			 
b7c2			if DEBUG_FORTH_DOT 
b7c2				DMARK "D->" 
b7c2				CALLMONITOR 
b7c2			endif	 
b7c2			 
b7c2			.noadv:	 
b7c2			 
b7c2					if DEBUG_FORTH_DOT_WAIT 
b7c2							call next_page_prompt 
b7c2					endif	 
b7c2			; TODO this pop off the stack causes a crash. i dont know why 
b7c2			 
b7c2			 
b7c2			if DEBUG_FORTH_DOT 
b7c2				DMARK "DTh" 
b7c2				CALLMONITOR 
b7c2			endif	 
b7c2			 
b7c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7c2 cd 5d 9b			call macro_forth_dsp_pop 
b7c5				endm 
# End of macro FORTH_DSP_POP
b7c5			 
b7c5			if DEBUG_FORTH_DOT 
b7c5				DMARK "DTi" 
b7c5				CALLMONITOR 
b7c5			endif	 
b7c5			 
b7c5			 
b7c5					NEXTW 
b7c5 c3 17 9c			jp macro_next 
b7c8				endm 
# End of macro NEXTW
b7c8			 
b7c8			.CLS: 
b7c8				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b7c8 35				db WORD_SYS_CORE+33             
b7c9 f5 b7			dw .DRAW            
b7cb 04				db 3 + 1 
b7cc .. 00			db "CLS",0              
b7d0				endm 
# End of macro CWHEAD
b7d0			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b7d0					if DEBUG_FORTH_WORDS_KEY 
b7d0						DMARK "CLS" 
b7d0 f5				push af  
b7d1 3a e5 b7			ld a, (.dmark)  
b7d4 32 c0 ee			ld (debug_mark),a  
b7d7 3a e6 b7			ld a, (.dmark+1)  
b7da 32 c1 ee			ld (debug_mark+1),a  
b7dd 3a e7 b7			ld a, (.dmark+2)  
b7e0 32 c2 ee			ld (debug_mark+2),a  
b7e3 18 03			jr .pastdmark  
b7e5 ..			.dmark: db "CLS"  
b7e8 f1			.pastdmark: pop af  
b7e9			endm  
# End of macro DMARK
b7e9						CALLMONITOR 
b7e9 cd 21 93			call break_point_state  
b7ec				endm  
# End of macro CALLMONITOR
b7ec					endif 
b7ec cd 7a 88				call clear_display 
b7ef c3 03 b9				jp .home		; and home cursor 
b7f2					NEXTW 
b7f2 c3 17 9c			jp macro_next 
b7f5				endm 
# End of macro NEXTW
b7f5			 
b7f5			.DRAW: 
b7f5				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b7f5 36				db WORD_SYS_CORE+34             
b7f6 20 b8			dw .DUMP            
b7f8 05				db 4 + 1 
b7f9 .. 00			db "DRAW",0              
b7fe				endm 
# End of macro CWHEAD
b7fe			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b7fe					if DEBUG_FORTH_WORDS_KEY 
b7fe						DMARK "DRW" 
b7fe f5				push af  
b7ff 3a 13 b8			ld a, (.dmark)  
b802 32 c0 ee			ld (debug_mark),a  
b805 3a 14 b8			ld a, (.dmark+1)  
b808 32 c1 ee			ld (debug_mark+1),a  
b80b 3a 15 b8			ld a, (.dmark+2)  
b80e 32 c2 ee			ld (debug_mark+2),a  
b811 18 03			jr .pastdmark  
b813 ..			.dmark: db "DRW"  
b816 f1			.pastdmark: pop af  
b817			endm  
# End of macro DMARK
b817						CALLMONITOR 
b817 cd 21 93			call break_point_state  
b81a				endm  
# End of macro CALLMONITOR
b81a					endif 
b81a cd 9d 88				call update_display 
b81d					NEXTW 
b81d c3 17 9c			jp macro_next 
b820				endm 
# End of macro NEXTW
b820			 
b820			.DUMP: 
b820				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b820 37				db WORD_SYS_CORE+35             
b821 58 b8			dw .CDUMP            
b823 05				db 4 + 1 
b824 .. 00			db "DUMP",0              
b829				endm 
# End of macro CWHEAD
b829			; | DUMP ( x -- ) With address x display dump   | DONE 
b829			; TODO pop address to use off of the stack 
b829					if DEBUG_FORTH_WORDS_KEY 
b829						DMARK "DUM" 
b829 f5				push af  
b82a 3a 3e b8			ld a, (.dmark)  
b82d 32 c0 ee			ld (debug_mark),a  
b830 3a 3f b8			ld a, (.dmark+1)  
b833 32 c1 ee			ld (debug_mark+1),a  
b836 3a 40 b8			ld a, (.dmark+2)  
b839 32 c2 ee			ld (debug_mark+2),a  
b83c 18 03			jr .pastdmark  
b83e ..			.dmark: db "DUM"  
b841 f1			.pastdmark: pop af  
b842			endm  
# End of macro DMARK
b842						CALLMONITOR 
b842 cd 21 93			call break_point_state  
b845				endm  
# End of macro CALLMONITOR
b845					endif 
b845 cd 7a 88				call clear_display 
b848			 
b848					; get address 
b848			 
b848					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b848 cd a5 9a			call macro_dsp_valuehl 
b84b				endm 
# End of macro FORTH_DSP_VALUEHL
b84b				 
b84b					; save it for cdump 
b84b			 
b84b 22 09 e8				ld (os_cur_ptr),hl 
b84e			 
b84e					; destroy value TOS 
b84e			 
b84e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b84e cd 5d 9b			call macro_forth_dsp_pop 
b851				endm 
# End of macro FORTH_DSP_POP
b851			 
b851 cd 2e 97				call dumpcont	; skip old style of param parsing	 
b854 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b855					NEXTW 
b855 c3 17 9c			jp macro_next 
b858				endm 
# End of macro NEXTW
b858			.CDUMP: 
b858				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b858 38				db WORD_SYS_CORE+36             
b859 88 b8			dw .DAT            
b85b 06				db 5 + 1 
b85c .. 00			db "CDUMP",0              
b862				endm 
# End of macro CWHEAD
b862			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b862					if DEBUG_FORTH_WORDS_KEY 
b862						DMARK "CDP" 
b862 f5				push af  
b863 3a 77 b8			ld a, (.dmark)  
b866 32 c0 ee			ld (debug_mark),a  
b869 3a 78 b8			ld a, (.dmark+1)  
b86c 32 c1 ee			ld (debug_mark+1),a  
b86f 3a 79 b8			ld a, (.dmark+2)  
b872 32 c2 ee			ld (debug_mark+2),a  
b875 18 03			jr .pastdmark  
b877 ..			.dmark: db "CDP"  
b87a f1			.pastdmark: pop af  
b87b			endm  
# End of macro DMARK
b87b						CALLMONITOR 
b87b cd 21 93			call break_point_state  
b87e				endm  
# End of macro CALLMONITOR
b87e					endif 
b87e cd 7a 88				call clear_display 
b881 cd 2e 97				call dumpcont	 
b884 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b885					NEXTW 
b885 c3 17 9c			jp macro_next 
b888				endm 
# End of macro NEXTW
b888			 
b888			 
b888			 
b888			 
b888			.DAT: 
b888				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b888 3d				db WORD_SYS_CORE+41             
b889 de b8			dw .HOME            
b88b 03				db 2 + 1 
b88c .. 00			db "AT",0              
b88f				endm 
# End of macro CWHEAD
b88f			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b88f					if DEBUG_FORTH_WORDS_KEY 
b88f						DMARK "AT." 
b88f f5				push af  
b890 3a a4 b8			ld a, (.dmark)  
b893 32 c0 ee			ld (debug_mark),a  
b896 3a a5 b8			ld a, (.dmark+1)  
b899 32 c1 ee			ld (debug_mark+1),a  
b89c 3a a6 b8			ld a, (.dmark+2)  
b89f 32 c2 ee			ld (debug_mark+2),a  
b8a2 18 03			jr .pastdmark  
b8a4 ..			.dmark: db "AT."  
b8a7 f1			.pastdmark: pop af  
b8a8			endm  
# End of macro DMARK
b8a8						CALLMONITOR 
b8a8 cd 21 93			call break_point_state  
b8ab				endm  
# End of macro CALLMONITOR
b8ab					endif 
b8ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8ab cd a5 9a			call macro_dsp_valuehl 
b8ae				endm 
# End of macro FORTH_DSP_VALUEHL
b8ae			 
b8ae			 
b8ae					; TODO save cursor row 
b8ae 7d					ld a,l 
b8af fe 02				cp 2 
b8b1 20 04				jr nz, .crow3 
b8b3 3e 14				ld a, display_row_2 
b8b5 18 12				jr .ccol1 
b8b7 fe 03		.crow3:		cp 3 
b8b9 20 04				jr nz, .crow4 
b8bb 3e 28				ld a, display_row_3 
b8bd 18 0a				jr .ccol1 
b8bf fe 04		.crow4:		cp 4 
b8c1 20 04				jr nz, .crow1 
b8c3 3e 3c				ld a, display_row_4 
b8c5 18 02				jr .ccol1 
b8c7 3e 00		.crow1:		ld a,display_row_1 
b8c9 f5			.ccol1:		push af			; got row offset 
b8ca 6f					ld l,a 
b8cb 26 00				ld h,0 
b8cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8cd cd 5d 9b			call macro_forth_dsp_pop 
b8d0				endm 
# End of macro FORTH_DSP_POP
b8d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8d0 cd a5 9a			call macro_dsp_valuehl 
b8d3				endm 
# End of macro FORTH_DSP_VALUEHL
b8d3					; TODO save cursor col 
b8d3 f1					pop af 
b8d4 85					add l		; add col offset 
b8d5 32 cf ec				ld (f_cursor_ptr), a 
b8d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8d8 cd 5d 9b			call macro_forth_dsp_pop 
b8db				endm 
# End of macro FORTH_DSP_POP
b8db			 
b8db					; calculate  
b8db			 
b8db					NEXTW 
b8db c3 17 9c			jp macro_next 
b8de				endm 
# End of macro NEXTW
b8de			 
b8de			 
b8de			.HOME: 
b8de				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b8de 41				db WORD_SYS_CORE+45             
b8df 0b b9			dw .SPACE            
b8e1 05				db 4 + 1 
b8e2 .. 00			db "HOME",0              
b8e7				endm 
# End of macro CWHEAD
b8e7			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b8e7					if DEBUG_FORTH_WORDS_KEY 
b8e7						DMARK "HOM" 
b8e7 f5				push af  
b8e8 3a fc b8			ld a, (.dmark)  
b8eb 32 c0 ee			ld (debug_mark),a  
b8ee 3a fd b8			ld a, (.dmark+1)  
b8f1 32 c1 ee			ld (debug_mark+1),a  
b8f4 3a fe b8			ld a, (.dmark+2)  
b8f7 32 c2 ee			ld (debug_mark+2),a  
b8fa 18 03			jr .pastdmark  
b8fc ..			.dmark: db "HOM"  
b8ff f1			.pastdmark: pop af  
b900			endm  
# End of macro DMARK
b900						CALLMONITOR 
b900 cd 21 93			call break_point_state  
b903				endm  
# End of macro CALLMONITOR
b903					endif 
b903 3e 00		.home:		ld a, 0		; and home cursor 
b905 32 cf ec				ld (f_cursor_ptr), a 
b908					NEXTW 
b908 c3 17 9c			jp macro_next 
b90b				endm 
# End of macro NEXTW
b90b			 
b90b			 
b90b			.SPACE: 
b90b				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b90b 46				db WORD_SYS_CORE+50             
b90c 39 b9			dw .SPACES            
b90e 03				db 2 + 1 
b90f .. 00			db "BL",0              
b912				endm 
# End of macro CWHEAD
b912			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b912					if DEBUG_FORTH_WORDS_KEY 
b912						DMARK "BL." 
b912 f5				push af  
b913 3a 27 b9			ld a, (.dmark)  
b916 32 c0 ee			ld (debug_mark),a  
b919 3a 28 b9			ld a, (.dmark+1)  
b91c 32 c1 ee			ld (debug_mark+1),a  
b91f 3a 29 b9			ld a, (.dmark+2)  
b922 32 c2 ee			ld (debug_mark+2),a  
b925 18 03			jr .pastdmark  
b927 ..			.dmark: db "BL."  
b92a f1			.pastdmark: pop af  
b92b			endm  
# End of macro DMARK
b92b						CALLMONITOR 
b92b cd 21 93			call break_point_state  
b92e				endm  
# End of macro CALLMONITOR
b92e					endif 
b92e 21 37 b9				ld hl, .blstr 
b931 cd 1c 99				call forth_push_str 
b934					 
b934				       NEXTW 
b934 c3 17 9c			jp macro_next 
b937				endm 
# End of macro NEXTW
b937			 
b937 .. 00		.blstr: db " ", 0 
b939			 
b939			.SPACES: 
b939				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b939 47				db WORD_SYS_CORE+51             
b93a d4 b9			dw .SCROLL            
b93c 07				db 6 + 1 
b93d .. 00			db "SPACES",0              
b944				endm 
# End of macro CWHEAD
b944			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b944					if DEBUG_FORTH_WORDS_KEY 
b944						DMARK "SPS" 
b944 f5				push af  
b945 3a 59 b9			ld a, (.dmark)  
b948 32 c0 ee			ld (debug_mark),a  
b94b 3a 5a b9			ld a, (.dmark+1)  
b94e 32 c1 ee			ld (debug_mark+1),a  
b951 3a 5b b9			ld a, (.dmark+2)  
b954 32 c2 ee			ld (debug_mark+2),a  
b957 18 03			jr .pastdmark  
b959 ..			.dmark: db "SPS"  
b95c f1			.pastdmark: pop af  
b95d			endm  
# End of macro DMARK
b95d						CALLMONITOR 
b95d cd 21 93			call break_point_state  
b960				endm  
# End of macro CALLMONITOR
b960					endif 
b960			 
b960			 
b960					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b960 cd a5 9a			call macro_dsp_valuehl 
b963				endm 
# End of macro FORTH_DSP_VALUEHL
b963			 
b963			;		push hl    ; u 
b963					if DEBUG_FORTH_WORDS 
b963						DMARK "SPA" 
b963 f5				push af  
b964 3a 78 b9			ld a, (.dmark)  
b967 32 c0 ee			ld (debug_mark),a  
b96a 3a 79 b9			ld a, (.dmark+1)  
b96d 32 c1 ee			ld (debug_mark+1),a  
b970 3a 7a b9			ld a, (.dmark+2)  
b973 32 c2 ee			ld (debug_mark+2),a  
b976 18 03			jr .pastdmark  
b978 ..			.dmark: db "SPA"  
b97b f1			.pastdmark: pop af  
b97c			endm  
# End of macro DMARK
b97c						CALLMONITOR 
b97c cd 21 93			call break_point_state  
b97f				endm  
# End of macro CALLMONITOR
b97f					endif 
b97f			 
b97f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b97f cd 5d 9b			call macro_forth_dsp_pop 
b982				endm 
# End of macro FORTH_DSP_POP
b982			;		pop hl 
b982 4d					ld c, l 
b983 06 00				ld b, 0 
b985 21 e6 e4				ld hl, scratch  
b988			 
b988					if DEBUG_FORTH_WORDS 
b988						DMARK "SP2" 
b988 f5				push af  
b989 3a 9d b9			ld a, (.dmark)  
b98c 32 c0 ee			ld (debug_mark),a  
b98f 3a 9e b9			ld a, (.dmark+1)  
b992 32 c1 ee			ld (debug_mark+1),a  
b995 3a 9f b9			ld a, (.dmark+2)  
b998 32 c2 ee			ld (debug_mark+2),a  
b99b 18 03			jr .pastdmark  
b99d ..			.dmark: db "SP2"  
b9a0 f1			.pastdmark: pop af  
b9a1			endm  
# End of macro DMARK
b9a1						CALLMONITOR 
b9a1 cd 21 93			call break_point_state  
b9a4				endm  
# End of macro CALLMONITOR
b9a4					endif 
b9a4 3e 20				ld a, ' ' 
b9a6 c5			.spaces1:	push bc 
b9a7 77					ld (hl),a 
b9a8 23					inc hl 
b9a9 c1					pop bc 
b9aa 10 fa				djnz .spaces1 
b9ac 3e 00				ld a,0 
b9ae 77					ld (hl),a 
b9af 21 e6 e4				ld hl, scratch 
b9b2					if DEBUG_FORTH_WORDS 
b9b2						DMARK "SP3" 
b9b2 f5				push af  
b9b3 3a c7 b9			ld a, (.dmark)  
b9b6 32 c0 ee			ld (debug_mark),a  
b9b9 3a c8 b9			ld a, (.dmark+1)  
b9bc 32 c1 ee			ld (debug_mark+1),a  
b9bf 3a c9 b9			ld a, (.dmark+2)  
b9c2 32 c2 ee			ld (debug_mark+2),a  
b9c5 18 03			jr .pastdmark  
b9c7 ..			.dmark: db "SP3"  
b9ca f1			.pastdmark: pop af  
b9cb			endm  
# End of macro DMARK
b9cb						CALLMONITOR 
b9cb cd 21 93			call break_point_state  
b9ce				endm  
# End of macro CALLMONITOR
b9ce					endif 
b9ce cd 17 9a				call forth_apush 
b9d1			 
b9d1				       NEXTW 
b9d1 c3 17 9c			jp macro_next 
b9d4				endm 
# End of macro NEXTW
b9d4			 
b9d4			 
b9d4			 
b9d4			.SCROLL: 
b9d4				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
b9d4 53				db WORD_SYS_CORE+63             
b9d5 01 ba			dw .SCROLLD            
b9d7 07				db 6 + 1 
b9d8 .. 00			db "SCROLL",0              
b9df				endm 
# End of macro CWHEAD
b9df			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
b9df					if DEBUG_FORTH_WORDS_KEY 
b9df						DMARK "SCR" 
b9df f5				push af  
b9e0 3a f4 b9			ld a, (.dmark)  
b9e3 32 c0 ee			ld (debug_mark),a  
b9e6 3a f5 b9			ld a, (.dmark+1)  
b9e9 32 c1 ee			ld (debug_mark+1),a  
b9ec 3a f6 b9			ld a, (.dmark+2)  
b9ef 32 c2 ee			ld (debug_mark+2),a  
b9f2 18 03			jr .pastdmark  
b9f4 ..			.dmark: db "SCR"  
b9f7 f1			.pastdmark: pop af  
b9f8			endm  
# End of macro DMARK
b9f8						CALLMONITOR 
b9f8 cd 21 93			call break_point_state  
b9fb				endm  
# End of macro CALLMONITOR
b9fb					endif 
b9fb			 
b9fb cd 3c 88			call scroll_up 
b9fe			;	call update_display 
b9fe			 
b9fe					NEXTW 
b9fe c3 17 9c			jp macro_next 
ba01				endm 
# End of macro NEXTW
ba01			 
ba01			 
ba01			 
ba01			;		; get dir 
ba01			; 
ba01			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba01			; 
ba01			;		push hl 
ba01			; 
ba01			;		; destroy value TOS 
ba01			; 
ba01			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba01			; 
ba01			;		; get count 
ba01			; 
ba01			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba01			; 
ba01			;		push hl 
ba01			; 
ba01			;		; destroy value TOS 
ba01			; 
ba01			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba01			; 
ba01			;		; one value on hl get other one back 
ba01			; 
ba01			;		pop bc    ; count 
ba01			; 
ba01			;		pop de   ; dir 
ba01			; 
ba01			; 
ba01			;		ld b, c 
ba01			; 
ba01			;.scrolldir:     push bc 
ba01			;		push de 
ba01			; 
ba01			;		ld a, 0 
ba01			;		cp e 
ba01			;		jr z, .scrollup  
ba01			;		call scroll_down 
ba01			;		jr .scrollnext 
ba01			;.scrollup:	call scroll_up 
ba01			; 
ba01			;		 
ba01			;.scrollnext: 
ba01			;		pop de 
ba01			;		pop bc 
ba01			;		djnz .scrolldir 
ba01			; 
ba01			; 
ba01			; 
ba01			; 
ba01			; 
ba01			;		NEXTW 
ba01			 
ba01			.SCROLLD: 
ba01				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
ba01 53				db WORD_SYS_CORE+63             
ba02 2f ba			dw .ATQ            
ba04 08				db 7 + 1 
ba05 .. 00			db "SCROLLD",0              
ba0d				endm 
# End of macro CWHEAD
ba0d			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
ba0d					if DEBUG_FORTH_WORDS_KEY 
ba0d						DMARK "SCD" 
ba0d f5				push af  
ba0e 3a 22 ba			ld a, (.dmark)  
ba11 32 c0 ee			ld (debug_mark),a  
ba14 3a 23 ba			ld a, (.dmark+1)  
ba17 32 c1 ee			ld (debug_mark+1),a  
ba1a 3a 24 ba			ld a, (.dmark+2)  
ba1d 32 c2 ee			ld (debug_mark+2),a  
ba20 18 03			jr .pastdmark  
ba22 ..			.dmark: db "SCD"  
ba25 f1			.pastdmark: pop af  
ba26			endm  
# End of macro DMARK
ba26						CALLMONITOR 
ba26 cd 21 93			call break_point_state  
ba29				endm  
# End of macro CALLMONITOR
ba29					endif 
ba29			 
ba29 cd 60 88			call scroll_down 
ba2c			;	call update_display 
ba2c			 
ba2c					NEXTW 
ba2c c3 17 9c			jp macro_next 
ba2f				endm 
# End of macro NEXTW
ba2f			 
ba2f			 
ba2f			.ATQ: 
ba2f				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
ba2f 62				db WORD_SYS_CORE+78             
ba30 8d ba			dw .AUTODSP            
ba32 04				db 3 + 1 
ba33 .. 00			db "AT@",0              
ba37				endm 
# End of macro CWHEAD
ba37			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
ba37					if DEBUG_FORTH_WORDS_KEY 
ba37						DMARK "ATA" 
ba37 f5				push af  
ba38 3a 4c ba			ld a, (.dmark)  
ba3b 32 c0 ee			ld (debug_mark),a  
ba3e 3a 4d ba			ld a, (.dmark+1)  
ba41 32 c1 ee			ld (debug_mark+1),a  
ba44 3a 4e ba			ld a, (.dmark+2)  
ba47 32 c2 ee			ld (debug_mark+2),a  
ba4a 18 03			jr .pastdmark  
ba4c ..			.dmark: db "ATA"  
ba4f f1			.pastdmark: pop af  
ba50			endm  
# End of macro DMARK
ba50						CALLMONITOR 
ba50 cd 21 93			call break_point_state  
ba53				endm  
# End of macro CALLMONITOR
ba53					endif 
ba53			 
ba53			 
ba53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba53 cd a5 9a			call macro_dsp_valuehl 
ba56				endm 
# End of macro FORTH_DSP_VALUEHL
ba56			 
ba56					; TODO save cursor row 
ba56 7d					ld a,l 
ba57 fe 02				cp 2 
ba59 20 04				jr nz, .crow3aq 
ba5b 3e 14				ld a, display_row_2 
ba5d 18 12				jr .ccol1aq 
ba5f fe 03		.crow3aq:		cp 3 
ba61 20 04				jr nz, .crow4aq 
ba63 3e 28				ld a, display_row_3 
ba65 18 0a				jr .ccol1aq 
ba67 fe 04		.crow4aq:		cp 4 
ba69 20 04				jr nz, .crow1aq 
ba6b 3e 3c				ld a, display_row_4 
ba6d 18 02				jr .ccol1aq 
ba6f 3e 00		.crow1aq:		ld a,display_row_1 
ba71 f5			.ccol1aq:		push af			; got row offset 
ba72 6f					ld l,a 
ba73 26 00				ld h,0 
ba75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba75 cd 5d 9b			call macro_forth_dsp_pop 
ba78				endm 
# End of macro FORTH_DSP_POP
ba78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba78 cd a5 9a			call macro_dsp_valuehl 
ba7b				endm 
# End of macro FORTH_DSP_VALUEHL
ba7b					; TODO save cursor col 
ba7b f1					pop af 
ba7c 85					add l		; add col offset 
ba7d			 
ba7d					; add current frame buffer address 
ba7d 2a 61 ed				ld hl, (display_fb_active) 
ba80 cd a7 8a				call addatohl 
ba83			 
ba83			 
ba83			 
ba83			 
ba83					; get char frame buffer location offset in hl 
ba83			 
ba83 7e					ld a,(hl) 
ba84 26 00				ld h, 0 
ba86 6f					ld l, a 
ba87			 
ba87 cd ae 98				call forth_push_numhl 
ba8a			 
ba8a			 
ba8a					NEXTW 
ba8a c3 17 9c			jp macro_next 
ba8d				endm 
# End of macro NEXTW
ba8d			 
ba8d			.AUTODSP: 
ba8d				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
ba8d 63				db WORD_SYS_CORE+79             
ba8e a3 ba			dw .MENU            
ba90 05				db 4 + 1 
ba91 .. 00			db "ADSP",0              
ba96				endm 
# End of macro CWHEAD
ba96			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
ba96			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
ba96			 
ba96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba96 cd a5 9a			call macro_dsp_valuehl 
ba99				endm 
# End of macro FORTH_DSP_VALUEHL
ba99			 
ba99			;		push hl 
ba99			 
ba99					; destroy value TOS 
ba99			 
ba99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba99 cd 5d 9b			call macro_forth_dsp_pop 
ba9c				endm 
# End of macro FORTH_DSP_POP
ba9c			 
ba9c			;		pop hl 
ba9c			 
ba9c 7d					ld a,l 
ba9d 32 ad ec				ld (cli_autodisplay), a 
baa0				       NEXTW 
baa0 c3 17 9c			jp macro_next 
baa3				endm 
# End of macro NEXTW
baa3			 
baa3			.MENU: 
baa3				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
baa3 70				db WORD_SYS_CORE+92             
baa4 4c bb			dw .ENDDISPLAY            
baa6 05				db 4 + 1 
baa7 .. 00			db "MENU",0              
baac				endm 
# End of macro CWHEAD
baac			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
baac			 
baac			;		; get number of items on the stack 
baac			; 
baac				 
baac					FORTH_DSP_VALUEHL 
baac cd a5 9a			call macro_dsp_valuehl 
baaf				endm 
# End of macro FORTH_DSP_VALUEHL
baaf				 
baaf					if DEBUG_FORTH_WORDS_KEY 
baaf						DMARK "MNU" 
baaf f5				push af  
bab0 3a c4 ba			ld a, (.dmark)  
bab3 32 c0 ee			ld (debug_mark),a  
bab6 3a c5 ba			ld a, (.dmark+1)  
bab9 32 c1 ee			ld (debug_mark+1),a  
babc 3a c6 ba			ld a, (.dmark+2)  
babf 32 c2 ee			ld (debug_mark+2),a  
bac2 18 03			jr .pastdmark  
bac4 ..			.dmark: db "MNU"  
bac7 f1			.pastdmark: pop af  
bac8			endm  
# End of macro DMARK
bac8						CALLMONITOR 
bac8 cd 21 93			call break_point_state  
bacb				endm  
# End of macro CALLMONITOR
bacb					endif 
bacb			 
bacb 45					ld b, l	 
bacc 05					dec b 
bacd			 
bacd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bacd cd 5d 9b			call macro_forth_dsp_pop 
bad0				endm 
# End of macro FORTH_DSP_POP
bad0			 
bad0			 
bad0					; go directly through the stack to pluck out the string pointers and build an array 
bad0			 
bad0			;		FORTH_DSP 
bad0			 
bad0					; hl contains top most stack item 
bad0				 
bad0 11 e6 e4				ld de, scratch 
bad3			 
bad3			.mbuild: 
bad3			 
bad3					FORTH_DSP_VALUEHL 
bad3 cd a5 9a			call macro_dsp_valuehl 
bad6				endm 
# End of macro FORTH_DSP_VALUEHL
bad6			 
bad6					if DEBUG_FORTH_WORDS 
bad6						DMARK "MN3" 
bad6 f5				push af  
bad7 3a eb ba			ld a, (.dmark)  
bada 32 c0 ee			ld (debug_mark),a  
badd 3a ec ba			ld a, (.dmark+1)  
bae0 32 c1 ee			ld (debug_mark+1),a  
bae3 3a ed ba			ld a, (.dmark+2)  
bae6 32 c2 ee			ld (debug_mark+2),a  
bae9 18 03			jr .pastdmark  
baeb ..			.dmark: db "MN3"  
baee f1			.pastdmark: pop af  
baef			endm  
# End of macro DMARK
baef						CALLMONITOR 
baef cd 21 93			call break_point_state  
baf2				endm  
# End of macro CALLMONITOR
baf2					endif 
baf2 eb					ex de, hl 
baf3 73					ld (hl), e 
baf4 23					inc hl 
baf5 72					ld (hl), d 
baf6 23					inc hl 
baf7 eb					ex de, hl 
baf8			 
baf8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baf8 cd 5d 9b			call macro_forth_dsp_pop 
bafb				endm 
# End of macro FORTH_DSP_POP
bafb			 
bafb 10 d6				djnz .mbuild 
bafd			 
bafd					; done add term 
bafd			 
bafd eb					ex de, hl 
bafe 36 00				ld (hl), 0 
bb00 23					inc hl 
bb01 36 00				ld (hl), 0 
bb03			 
bb03				 
bb03					 
bb03 21 e6 e4				ld hl, scratch 
bb06			 
bb06					if DEBUG_FORTH_WORDS 
bb06						DMARK "MNx" 
bb06 f5				push af  
bb07 3a 1b bb			ld a, (.dmark)  
bb0a 32 c0 ee			ld (debug_mark),a  
bb0d 3a 1c bb			ld a, (.dmark+1)  
bb10 32 c1 ee			ld (debug_mark+1),a  
bb13 3a 1d bb			ld a, (.dmark+2)  
bb16 32 c2 ee			ld (debug_mark+2),a  
bb19 18 03			jr .pastdmark  
bb1b ..			.dmark: db "MNx"  
bb1e f1			.pastdmark: pop af  
bb1f			endm  
# End of macro DMARK
bb1f						CALLMONITOR 
bb1f cd 21 93			call break_point_state  
bb22				endm  
# End of macro CALLMONITOR
bb22					endif 
bb22			 
bb22			 
bb22			 
bb22 3e 00				ld a, 0 
bb24 cd ab 88				call menu 
bb27			 
bb27			 
bb27 6f					ld l, a 
bb28 26 00				ld h, 0 
bb2a			 
bb2a					if DEBUG_FORTH_WORDS 
bb2a						DMARK "MNr" 
bb2a f5				push af  
bb2b 3a 3f bb			ld a, (.dmark)  
bb2e 32 c0 ee			ld (debug_mark),a  
bb31 3a 40 bb			ld a, (.dmark+1)  
bb34 32 c1 ee			ld (debug_mark+1),a  
bb37 3a 41 bb			ld a, (.dmark+2)  
bb3a 32 c2 ee			ld (debug_mark+2),a  
bb3d 18 03			jr .pastdmark  
bb3f ..			.dmark: db "MNr"  
bb42 f1			.pastdmark: pop af  
bb43			endm  
# End of macro DMARK
bb43						CALLMONITOR 
bb43 cd 21 93			call break_point_state  
bb46				endm  
# End of macro CALLMONITOR
bb46					endif 
bb46			 
bb46 cd ae 98				call forth_push_numhl 
bb49			 
bb49			 
bb49			 
bb49			 
bb49				       NEXTW 
bb49 c3 17 9c			jp macro_next 
bb4c				endm 
# End of macro NEXTW
bb4c			 
bb4c			 
bb4c			.ENDDISPLAY: 
bb4c			 
bb4c			; eof 
# End of file forth_words_display.asm
bb4c			include "forth_words_str.asm" 
bb4c			 
bb4c			; | ## String Words 
bb4c			 
bb4c			.PTR:   
bb4c			 
bb4c				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bb4c 48				db WORD_SYS_CORE+52             
bb4d 79 bb			dw .STYPE            
bb4f 04				db 3 + 1 
bb50 .. 00			db "PTR",0              
bb54				endm 
# End of macro CWHEAD
bb54			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bb54			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bb54			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bb54			 
bb54					if DEBUG_FORTH_WORDS_KEY 
bb54						DMARK "PTR" 
bb54 f5				push af  
bb55 3a 69 bb			ld a, (.dmark)  
bb58 32 c0 ee			ld (debug_mark),a  
bb5b 3a 6a bb			ld a, (.dmark+1)  
bb5e 32 c1 ee			ld (debug_mark+1),a  
bb61 3a 6b bb			ld a, (.dmark+2)  
bb64 32 c2 ee			ld (debug_mark+2),a  
bb67 18 03			jr .pastdmark  
bb69 ..			.dmark: db "PTR"  
bb6c f1			.pastdmark: pop af  
bb6d			endm  
# End of macro DMARK
bb6d						CALLMONITOR 
bb6d cd 21 93			call break_point_state  
bb70				endm  
# End of macro CALLMONITOR
bb70					endif 
bb70					FORTH_DSP_VALUEHL 
bb70 cd a5 9a			call macro_dsp_valuehl 
bb73				endm 
# End of macro FORTH_DSP_VALUEHL
bb73 cd ae 98				call forth_push_numhl 
bb76			 
bb76			 
bb76					NEXTW 
bb76 c3 17 9c			jp macro_next 
bb79				endm 
# End of macro NEXTW
bb79			.STYPE: 
bb79				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bb79 48				db WORD_SYS_CORE+52             
bb7a c8 bb			dw .UPPER            
bb7c 06				db 5 + 1 
bb7d .. 00			db "STYPE",0              
bb83				endm 
# End of macro CWHEAD
bb83			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bb83					if DEBUG_FORTH_WORDS_KEY 
bb83						DMARK "STY" 
bb83 f5				push af  
bb84 3a 98 bb			ld a, (.dmark)  
bb87 32 c0 ee			ld (debug_mark),a  
bb8a 3a 99 bb			ld a, (.dmark+1)  
bb8d 32 c1 ee			ld (debug_mark+1),a  
bb90 3a 9a bb			ld a, (.dmark+2)  
bb93 32 c2 ee			ld (debug_mark+2),a  
bb96 18 03			jr .pastdmark  
bb98 ..			.dmark: db "STY"  
bb9b f1			.pastdmark: pop af  
bb9c			endm  
# End of macro DMARK
bb9c						CALLMONITOR 
bb9c cd 21 93			call break_point_state  
bb9f				endm  
# End of macro CALLMONITOR
bb9f					endif 
bb9f					FORTH_DSP 
bb9f cd 6b 9a			call macro_forth_dsp 
bba2				endm 
# End of macro FORTH_DSP
bba2					;v5 FORTH_DSP_VALUE 
bba2			 
bba2 7e					ld a, (hl) 
bba3			 
bba3 f5					push af 
bba4			 
bba4			; Dont destroy TOS		FORTH_DSP_POP 
bba4			 
bba4 f1					pop af 
bba5			 
bba5 fe 01				cp DS_TYPE_STR 
bba7 28 09				jr z, .typestr 
bba9			 
bba9 fe 02				cp DS_TYPE_INUM 
bbab 28 0a				jr z, .typeinum 
bbad			 
bbad 21 c6 bb				ld hl, .tna 
bbb0 18 0a				jr .tpush 
bbb2			 
bbb2 21 c2 bb		.typestr:	ld hl, .tstr 
bbb5 18 05				jr .tpush 
bbb7 21 c4 bb		.typeinum:	ld hl, .tinum 
bbba 18 00				jr .tpush 
bbbc			 
bbbc			.tpush: 
bbbc			 
bbbc cd 1c 99				call forth_push_str 
bbbf			 
bbbf					NEXTW 
bbbf c3 17 9c			jp macro_next 
bbc2				endm 
# End of macro NEXTW
bbc2 .. 00		.tstr:	db "s",0 
bbc4 .. 00		.tinum:  db "i",0 
bbc6 .. 00		.tna:   db "?", 0 
bbc8			 
bbc8			 
bbc8			.UPPER: 
bbc8				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bbc8 48				db WORD_SYS_CORE+52             
bbc9 03 bc			dw .LOWER            
bbcb 06				db 5 + 1 
bbcc .. 00			db "UPPER",0              
bbd2				endm 
# End of macro CWHEAD
bbd2			; | UPPER ( s -- s ) Upper case string s  | DONE 
bbd2					if DEBUG_FORTH_WORDS_KEY 
bbd2						DMARK "UPR" 
bbd2 f5				push af  
bbd3 3a e7 bb			ld a, (.dmark)  
bbd6 32 c0 ee			ld (debug_mark),a  
bbd9 3a e8 bb			ld a, (.dmark+1)  
bbdc 32 c1 ee			ld (debug_mark+1),a  
bbdf 3a e9 bb			ld a, (.dmark+2)  
bbe2 32 c2 ee			ld (debug_mark+2),a  
bbe5 18 03			jr .pastdmark  
bbe7 ..			.dmark: db "UPR"  
bbea f1			.pastdmark: pop af  
bbeb			endm  
# End of macro DMARK
bbeb						CALLMONITOR 
bbeb cd 21 93			call break_point_state  
bbee				endm  
# End of macro CALLMONITOR
bbee					endif 
bbee			 
bbee					FORTH_DSP 
bbee cd 6b 9a			call macro_forth_dsp 
bbf1				endm 
# End of macro FORTH_DSP
bbf1					 
bbf1			; TODO check is string type 
bbf1			 
bbf1					FORTH_DSP_VALUEHL 
bbf1 cd a5 9a			call macro_dsp_valuehl 
bbf4				endm 
# End of macro FORTH_DSP_VALUEHL
bbf4			; get pointer to string in hl 
bbf4			 
bbf4 7e			.toup:		ld a, (hl) 
bbf5 fe 00				cp 0 
bbf7 28 07				jr z, .toupdone 
bbf9			 
bbf9 cd 14 8e				call to_upper 
bbfc			 
bbfc 77					ld (hl), a 
bbfd 23					inc hl 
bbfe 18 f4				jr .toup 
bc00			 
bc00					 
bc00			 
bc00			 
bc00			; for each char convert to upper 
bc00					 
bc00			.toupdone: 
bc00			 
bc00			 
bc00					NEXTW 
bc00 c3 17 9c			jp macro_next 
bc03				endm 
# End of macro NEXTW
bc03			.LOWER: 
bc03				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bc03 48				db WORD_SYS_CORE+52             
bc04 3e bc			dw .TCASE            
bc06 06				db 5 + 1 
bc07 .. 00			db "LOWER",0              
bc0d				endm 
# End of macro CWHEAD
bc0d			; | LOWER ( s -- s ) Lower case string s  | DONE 
bc0d					if DEBUG_FORTH_WORDS_KEY 
bc0d						DMARK "LWR" 
bc0d f5				push af  
bc0e 3a 22 bc			ld a, (.dmark)  
bc11 32 c0 ee			ld (debug_mark),a  
bc14 3a 23 bc			ld a, (.dmark+1)  
bc17 32 c1 ee			ld (debug_mark+1),a  
bc1a 3a 24 bc			ld a, (.dmark+2)  
bc1d 32 c2 ee			ld (debug_mark+2),a  
bc20 18 03			jr .pastdmark  
bc22 ..			.dmark: db "LWR"  
bc25 f1			.pastdmark: pop af  
bc26			endm  
# End of macro DMARK
bc26						CALLMONITOR 
bc26 cd 21 93			call break_point_state  
bc29				endm  
# End of macro CALLMONITOR
bc29					endif 
bc29			 
bc29					FORTH_DSP 
bc29 cd 6b 9a			call macro_forth_dsp 
bc2c				endm 
# End of macro FORTH_DSP
bc2c					 
bc2c			; TODO check is string type 
bc2c			 
bc2c					FORTH_DSP_VALUEHL 
bc2c cd a5 9a			call macro_dsp_valuehl 
bc2f				endm 
# End of macro FORTH_DSP_VALUEHL
bc2f			; get pointer to string in hl 
bc2f			 
bc2f 7e			.tolow:		ld a, (hl) 
bc30 fe 00				cp 0 
bc32 28 07				jr z, .tolowdone 
bc34			 
bc34 cd 1d 8e				call to_lower 
bc37			 
bc37 77					ld (hl), a 
bc38 23					inc hl 
bc39 18 f4				jr .tolow 
bc3b			 
bc3b					 
bc3b			 
bc3b			 
bc3b			; for each char convert to low 
bc3b					 
bc3b			.tolowdone: 
bc3b					NEXTW 
bc3b c3 17 9c			jp macro_next 
bc3e				endm 
# End of macro NEXTW
bc3e			.TCASE: 
bc3e				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bc3e 48				db WORD_SYS_CORE+52             
bc3f 74 bd			dw .SUBSTR            
bc41 06				db 5 + 1 
bc42 .. 00			db "TCASE",0              
bc48				endm 
# End of macro CWHEAD
bc48			; | TCASE ( s -- s ) Title case string s  | DONE 
bc48					if DEBUG_FORTH_WORDS_KEY 
bc48						DMARK "TCS" 
bc48 f5				push af  
bc49 3a 5d bc			ld a, (.dmark)  
bc4c 32 c0 ee			ld (debug_mark),a  
bc4f 3a 5e bc			ld a, (.dmark+1)  
bc52 32 c1 ee			ld (debug_mark+1),a  
bc55 3a 5f bc			ld a, (.dmark+2)  
bc58 32 c2 ee			ld (debug_mark+2),a  
bc5b 18 03			jr .pastdmark  
bc5d ..			.dmark: db "TCS"  
bc60 f1			.pastdmark: pop af  
bc61			endm  
# End of macro DMARK
bc61						CALLMONITOR 
bc61 cd 21 93			call break_point_state  
bc64				endm  
# End of macro CALLMONITOR
bc64					endif 
bc64			 
bc64					FORTH_DSP 
bc64 cd 6b 9a			call macro_forth_dsp 
bc67				endm 
# End of macro FORTH_DSP
bc67					 
bc67			; TODO check is string type 
bc67			 
bc67					FORTH_DSP_VALUEHL 
bc67 cd a5 9a			call macro_dsp_valuehl 
bc6a				endm 
# End of macro FORTH_DSP_VALUEHL
bc6a			; get pointer to string in hl 
bc6a			 
bc6a					if DEBUG_FORTH_WORDS 
bc6a						DMARK "TC1" 
bc6a f5				push af  
bc6b 3a 7f bc			ld a, (.dmark)  
bc6e 32 c0 ee			ld (debug_mark),a  
bc71 3a 80 bc			ld a, (.dmark+1)  
bc74 32 c1 ee			ld (debug_mark+1),a  
bc77 3a 81 bc			ld a, (.dmark+2)  
bc7a 32 c2 ee			ld (debug_mark+2),a  
bc7d 18 03			jr .pastdmark  
bc7f ..			.dmark: db "TC1"  
bc82 f1			.pastdmark: pop af  
bc83			endm  
# End of macro DMARK
bc83						CALLMONITOR 
bc83 cd 21 93			call break_point_state  
bc86				endm  
# End of macro CALLMONITOR
bc86					endif 
bc86			 
bc86					; first time in turn to upper case first char 
bc86			 
bc86 7e					ld a, (hl) 
bc87 c3 11 bd				jp .totsiptou 
bc8a			 
bc8a			 
bc8a 7e			.tot:		ld a, (hl) 
bc8b fe 00				cp 0 
bc8d ca 55 bd				jp z, .totdone 
bc90			 
bc90					if DEBUG_FORTH_WORDS 
bc90						DMARK "TC2" 
bc90 f5				push af  
bc91 3a a5 bc			ld a, (.dmark)  
bc94 32 c0 ee			ld (debug_mark),a  
bc97 3a a6 bc			ld a, (.dmark+1)  
bc9a 32 c1 ee			ld (debug_mark+1),a  
bc9d 3a a7 bc			ld a, (.dmark+2)  
bca0 32 c2 ee			ld (debug_mark+2),a  
bca3 18 03			jr .pastdmark  
bca5 ..			.dmark: db "TC2"  
bca8 f1			.pastdmark: pop af  
bca9			endm  
# End of macro DMARK
bca9						CALLMONITOR 
bca9 cd 21 93			call break_point_state  
bcac				endm  
# End of macro CALLMONITOR
bcac					endif 
bcac					; check to see if current char is a space 
bcac			 
bcac fe 20				cp ' ' 
bcae 28 21				jr z, .totsp 
bcb0 cd 1d 8e				call to_lower 
bcb3					if DEBUG_FORTH_WORDS 
bcb3						DMARK "TC3" 
bcb3 f5				push af  
bcb4 3a c8 bc			ld a, (.dmark)  
bcb7 32 c0 ee			ld (debug_mark),a  
bcba 3a c9 bc			ld a, (.dmark+1)  
bcbd 32 c1 ee			ld (debug_mark+1),a  
bcc0 3a ca bc			ld a, (.dmark+2)  
bcc3 32 c2 ee			ld (debug_mark+2),a  
bcc6 18 03			jr .pastdmark  
bcc8 ..			.dmark: db "TC3"  
bccb f1			.pastdmark: pop af  
bccc			endm  
# End of macro DMARK
bccc						CALLMONITOR 
bccc cd 21 93			call break_point_state  
bccf				endm  
# End of macro CALLMONITOR
bccf					endif 
bccf 18 63				jr .totnxt 
bcd1			 
bcd1			.totsp:         ; on a space, find next char which should be upper 
bcd1			 
bcd1					if DEBUG_FORTH_WORDS 
bcd1						DMARK "TC4" 
bcd1 f5				push af  
bcd2 3a e6 bc			ld a, (.dmark)  
bcd5 32 c0 ee			ld (debug_mark),a  
bcd8 3a e7 bc			ld a, (.dmark+1)  
bcdb 32 c1 ee			ld (debug_mark+1),a  
bcde 3a e8 bc			ld a, (.dmark+2)  
bce1 32 c2 ee			ld (debug_mark+2),a  
bce4 18 03			jr .pastdmark  
bce6 ..			.dmark: db "TC4"  
bce9 f1			.pastdmark: pop af  
bcea			endm  
# End of macro DMARK
bcea						CALLMONITOR 
bcea cd 21 93			call break_point_state  
bced				endm  
# End of macro CALLMONITOR
bced					endif 
bced					;; 
bced			 
bced fe 20				cp ' ' 
bcef 20 20				jr nz, .totsiptou 
bcf1 23					inc hl 
bcf2 7e					ld a, (hl) 
bcf3					if DEBUG_FORTH_WORDS 
bcf3						DMARK "TC5" 
bcf3 f5				push af  
bcf4 3a 08 bd			ld a, (.dmark)  
bcf7 32 c0 ee			ld (debug_mark),a  
bcfa 3a 09 bd			ld a, (.dmark+1)  
bcfd 32 c1 ee			ld (debug_mark+1),a  
bd00 3a 0a bd			ld a, (.dmark+2)  
bd03 32 c2 ee			ld (debug_mark+2),a  
bd06 18 03			jr .pastdmark  
bd08 ..			.dmark: db "TC5"  
bd0b f1			.pastdmark: pop af  
bd0c			endm  
# End of macro DMARK
bd0c						CALLMONITOR 
bd0c cd 21 93			call break_point_state  
bd0f				endm  
# End of macro CALLMONITOR
bd0f					endif 
bd0f 18 c0				jr .totsp 
bd11 fe 00		.totsiptou:    cp 0 
bd13 28 40				jr z, .totdone 
bd15					; not space and not zero term so upper case it 
bd15 cd 14 8e				call to_upper 
bd18			 
bd18					if DEBUG_FORTH_WORDS 
bd18						DMARK "TC6" 
bd18 f5				push af  
bd19 3a 2d bd			ld a, (.dmark)  
bd1c 32 c0 ee			ld (debug_mark),a  
bd1f 3a 2e bd			ld a, (.dmark+1)  
bd22 32 c1 ee			ld (debug_mark+1),a  
bd25 3a 2f bd			ld a, (.dmark+2)  
bd28 32 c2 ee			ld (debug_mark+2),a  
bd2b 18 03			jr .pastdmark  
bd2d ..			.dmark: db "TC6"  
bd30 f1			.pastdmark: pop af  
bd31			endm  
# End of macro DMARK
bd31						CALLMONITOR 
bd31 cd 21 93			call break_point_state  
bd34				endm  
# End of macro CALLMONITOR
bd34					endif 
bd34			 
bd34			 
bd34			.totnxt: 
bd34			 
bd34 77					ld (hl), a 
bd35 23					inc hl 
bd36					if DEBUG_FORTH_WORDS 
bd36						DMARK "TC7" 
bd36 f5				push af  
bd37 3a 4b bd			ld a, (.dmark)  
bd3a 32 c0 ee			ld (debug_mark),a  
bd3d 3a 4c bd			ld a, (.dmark+1)  
bd40 32 c1 ee			ld (debug_mark+1),a  
bd43 3a 4d bd			ld a, (.dmark+2)  
bd46 32 c2 ee			ld (debug_mark+2),a  
bd49 18 03			jr .pastdmark  
bd4b ..			.dmark: db "TC7"  
bd4e f1			.pastdmark: pop af  
bd4f			endm  
# End of macro DMARK
bd4f						CALLMONITOR 
bd4f cd 21 93			call break_point_state  
bd52				endm  
# End of macro CALLMONITOR
bd52					endif 
bd52 c3 8a bc				jp .tot 
bd55			 
bd55					 
bd55			 
bd55			 
bd55			; for each char convert to low 
bd55					 
bd55			.totdone: 
bd55					if DEBUG_FORTH_WORDS 
bd55						DMARK "TCd" 
bd55 f5				push af  
bd56 3a 6a bd			ld a, (.dmark)  
bd59 32 c0 ee			ld (debug_mark),a  
bd5c 3a 6b bd			ld a, (.dmark+1)  
bd5f 32 c1 ee			ld (debug_mark+1),a  
bd62 3a 6c bd			ld a, (.dmark+2)  
bd65 32 c2 ee			ld (debug_mark+2),a  
bd68 18 03			jr .pastdmark  
bd6a ..			.dmark: db "TCd"  
bd6d f1			.pastdmark: pop af  
bd6e			endm  
# End of macro DMARK
bd6e						CALLMONITOR 
bd6e cd 21 93			call break_point_state  
bd71				endm  
# End of macro CALLMONITOR
bd71					endif 
bd71					NEXTW 
bd71 c3 17 9c			jp macro_next 
bd74				endm 
# End of macro NEXTW
bd74			 
bd74			.SUBSTR: 
bd74				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bd74 48				db WORD_SYS_CORE+52             
bd75 d2 bd			dw .LEFT            
bd77 07				db 6 + 1 
bd78 .. 00			db "SUBSTR",0              
bd7f				endm 
# End of macro CWHEAD
bd7f			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bd7f			 
bd7f					if DEBUG_FORTH_WORDS_KEY 
bd7f						DMARK "SST" 
bd7f f5				push af  
bd80 3a 94 bd			ld a, (.dmark)  
bd83 32 c0 ee			ld (debug_mark),a  
bd86 3a 95 bd			ld a, (.dmark+1)  
bd89 32 c1 ee			ld (debug_mark+1),a  
bd8c 3a 96 bd			ld a, (.dmark+2)  
bd8f 32 c2 ee			ld (debug_mark+2),a  
bd92 18 03			jr .pastdmark  
bd94 ..			.dmark: db "SST"  
bd97 f1			.pastdmark: pop af  
bd98			endm  
# End of macro DMARK
bd98						CALLMONITOR 
bd98 cd 21 93			call break_point_state  
bd9b				endm  
# End of macro CALLMONITOR
bd9b					endif 
bd9b			; TODO check string type 
bd9b					FORTH_DSP_VALUEHL 
bd9b cd a5 9a			call macro_dsp_valuehl 
bd9e				endm 
# End of macro FORTH_DSP_VALUEHL
bd9e			 
bd9e e5					push hl      ; string length 
bd9f			 
bd9f					FORTH_DSP_POP 
bd9f cd 5d 9b			call macro_forth_dsp_pop 
bda2				endm 
# End of macro FORTH_DSP_POP
bda2			 
bda2					FORTH_DSP_VALUEHL 
bda2 cd a5 9a			call macro_dsp_valuehl 
bda5				endm 
# End of macro FORTH_DSP_VALUEHL
bda5			 
bda5 e5					push hl     ; start char 
bda6			 
bda6					FORTH_DSP_POP 
bda6 cd 5d 9b			call macro_forth_dsp_pop 
bda9				endm 
# End of macro FORTH_DSP_POP
bda9			 
bda9			 
bda9					FORTH_DSP_VALUE 
bda9 cd 8e 9a			call macro_forth_dsp_value 
bdac				endm 
# End of macro FORTH_DSP_VALUE
bdac			 
bdac d1					pop de    ; get start post offset 
bdad			 
bdad 19					add hl, de    ; starting offset 
bdae			 
bdae c1					pop bc 
bdaf c5					push bc      ; grab size of string 
bdb0			 
bdb0 e5					push hl    ; save string start  
bdb1			 
bdb1 26 00				ld h, 0 
bdb3 69					ld l, c 
bdb4 23					inc hl 
bdb5 23					inc hl 
bdb6			 
bdb6 cd 6e 8f				call malloc 
bdb9				if DEBUG_FORTH_MALLOC_GUARD 
bdb9 cc e8 c3				call z,malloc_error 
bdbc				endif 
bdbc			 
bdbc eb					ex de, hl      ; save malloc area for string copy 
bdbd e1					pop hl    ; get back source 
bdbe c1					pop bc    ; get length of string back 
bdbf			 
bdbf d5					push de    ; save malloc area for after we push 
bdc0 ed b0				ldir     ; copy substr 
bdc2			 
bdc2			 
bdc2 eb					ex de, hl 
bdc3 3e 00				ld a, 0 
bdc5 77					ld (hl), a   ; term substr 
bdc6			 
bdc6					 
bdc6 e1					pop hl    ; get malloc so we can push it 
bdc7 e5					push hl   ; save so we can free it afterwards 
bdc8			 
bdc8 cd 1c 99				call forth_push_str 
bdcb			 
bdcb e1					pop hl 
bdcc cd 38 90				call free 
bdcf			 
bdcf					 
bdcf					 
bdcf			 
bdcf			 
bdcf					NEXTW 
bdcf c3 17 9c			jp macro_next 
bdd2				endm 
# End of macro NEXTW
bdd2			 
bdd2			.LEFT: 
bdd2				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bdd2 48				db WORD_SYS_CORE+52             
bdd3 fa bd			dw .RIGHT            
bdd5 05				db 4 + 1 
bdd6 .. 00			db "LEFT",0              
bddb				endm 
# End of macro CWHEAD
bddb			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bddb					if DEBUG_FORTH_WORDS_KEY 
bddb						DMARK "LEF" 
bddb f5				push af  
bddc 3a f0 bd			ld a, (.dmark)  
bddf 32 c0 ee			ld (debug_mark),a  
bde2 3a f1 bd			ld a, (.dmark+1)  
bde5 32 c1 ee			ld (debug_mark+1),a  
bde8 3a f2 bd			ld a, (.dmark+2)  
bdeb 32 c2 ee			ld (debug_mark+2),a  
bdee 18 03			jr .pastdmark  
bdf0 ..			.dmark: db "LEF"  
bdf3 f1			.pastdmark: pop af  
bdf4			endm  
# End of macro DMARK
bdf4						CALLMONITOR 
bdf4 cd 21 93			call break_point_state  
bdf7				endm  
# End of macro CALLMONITOR
bdf7					endif 
bdf7			 
bdf7					NEXTW 
bdf7 c3 17 9c			jp macro_next 
bdfa				endm 
# End of macro NEXTW
bdfa			.RIGHT: 
bdfa				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bdfa 48				db WORD_SYS_CORE+52             
bdfb 23 be			dw .STR2NUM            
bdfd 06				db 5 + 1 
bdfe .. 00			db "RIGHT",0              
be04				endm 
# End of macro CWHEAD
be04			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
be04					if DEBUG_FORTH_WORDS_KEY 
be04						DMARK "RIG" 
be04 f5				push af  
be05 3a 19 be			ld a, (.dmark)  
be08 32 c0 ee			ld (debug_mark),a  
be0b 3a 1a be			ld a, (.dmark+1)  
be0e 32 c1 ee			ld (debug_mark+1),a  
be11 3a 1b be			ld a, (.dmark+2)  
be14 32 c2 ee			ld (debug_mark+2),a  
be17 18 03			jr .pastdmark  
be19 ..			.dmark: db "RIG"  
be1c f1			.pastdmark: pop af  
be1d			endm  
# End of macro DMARK
be1d						CALLMONITOR 
be1d cd 21 93			call break_point_state  
be20				endm  
# End of macro CALLMONITOR
be20					endif 
be20			 
be20					NEXTW 
be20 c3 17 9c			jp macro_next 
be23				endm 
# End of macro NEXTW
be23			 
be23			 
be23			.STR2NUM: 
be23				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
be23 48				db WORD_SYS_CORE+52             
be24 af be			dw .NUM2STR            
be26 08				db 7 + 1 
be27 .. 00			db "STR2NUM",0              
be2f				endm 
# End of macro CWHEAD
be2f			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
be2f			 
be2f			 
be2f			; TODO STR type check to do 
be2f					if DEBUG_FORTH_WORDS_KEY 
be2f						DMARK "S2N" 
be2f f5				push af  
be30 3a 44 be			ld a, (.dmark)  
be33 32 c0 ee			ld (debug_mark),a  
be36 3a 45 be			ld a, (.dmark+1)  
be39 32 c1 ee			ld (debug_mark+1),a  
be3c 3a 46 be			ld a, (.dmark+2)  
be3f 32 c2 ee			ld (debug_mark+2),a  
be42 18 03			jr .pastdmark  
be44 ..			.dmark: db "S2N"  
be47 f1			.pastdmark: pop af  
be48			endm  
# End of macro DMARK
be48						CALLMONITOR 
be48 cd 21 93			call break_point_state  
be4b				endm  
# End of macro CALLMONITOR
be4b					endif 
be4b			 
be4b					;FORTH_DSP 
be4b					FORTH_DSP_VALUE 
be4b cd 8e 9a			call macro_forth_dsp_value 
be4e				endm 
# End of macro FORTH_DSP_VALUE
be4e					;inc hl 
be4e			 
be4e eb					ex de, hl 
be4f					if DEBUG_FORTH_WORDS 
be4f						DMARK "S2a" 
be4f f5				push af  
be50 3a 64 be			ld a, (.dmark)  
be53 32 c0 ee			ld (debug_mark),a  
be56 3a 65 be			ld a, (.dmark+1)  
be59 32 c1 ee			ld (debug_mark+1),a  
be5c 3a 66 be			ld a, (.dmark+2)  
be5f 32 c2 ee			ld (debug_mark+2),a  
be62 18 03			jr .pastdmark  
be64 ..			.dmark: db "S2a"  
be67 f1			.pastdmark: pop af  
be68			endm  
# End of macro DMARK
be68						CALLMONITOR 
be68 cd 21 93			call break_point_state  
be6b				endm  
# End of macro CALLMONITOR
be6b					endif 
be6b cd 9c 8e				call string_to_uint16 
be6e			 
be6e					if DEBUG_FORTH_WORDS 
be6e						DMARK "S2b" 
be6e f5				push af  
be6f 3a 83 be			ld a, (.dmark)  
be72 32 c0 ee			ld (debug_mark),a  
be75 3a 84 be			ld a, (.dmark+1)  
be78 32 c1 ee			ld (debug_mark+1),a  
be7b 3a 85 be			ld a, (.dmark+2)  
be7e 32 c2 ee			ld (debug_mark+2),a  
be81 18 03			jr .pastdmark  
be83 ..			.dmark: db "S2b"  
be86 f1			.pastdmark: pop af  
be87			endm  
# End of macro DMARK
be87						CALLMONITOR 
be87 cd 21 93			call break_point_state  
be8a				endm  
# End of macro CALLMONITOR
be8a					endif 
be8a			;		push hl 
be8a					FORTH_DSP_POP 
be8a cd 5d 9b			call macro_forth_dsp_pop 
be8d				endm 
# End of macro FORTH_DSP_POP
be8d			;		pop hl 
be8d					 
be8d					if DEBUG_FORTH_WORDS 
be8d						DMARK "S2b" 
be8d f5				push af  
be8e 3a a2 be			ld a, (.dmark)  
be91 32 c0 ee			ld (debug_mark),a  
be94 3a a3 be			ld a, (.dmark+1)  
be97 32 c1 ee			ld (debug_mark+1),a  
be9a 3a a4 be			ld a, (.dmark+2)  
be9d 32 c2 ee			ld (debug_mark+2),a  
bea0 18 03			jr .pastdmark  
bea2 ..			.dmark: db "S2b"  
bea5 f1			.pastdmark: pop af  
bea6			endm  
# End of macro DMARK
bea6						CALLMONITOR 
bea6 cd 21 93			call break_point_state  
bea9				endm  
# End of macro CALLMONITOR
bea9					endif 
bea9 cd ae 98				call forth_push_numhl	 
beac			 
beac				 
beac				       NEXTW 
beac c3 17 9c			jp macro_next 
beaf				endm 
# End of macro NEXTW
beaf			.NUM2STR: 
beaf				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
beaf 48				db WORD_SYS_CORE+52             
beb0 be be			dw .CONCAT            
beb2 08				db 7 + 1 
beb3 .. 00			db "NUM2STR",0              
bebb				endm 
# End of macro CWHEAD
bebb			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bebb			 
bebb			;		; malloc a string to target 
bebb			;		ld hl, 10     ; TODO max string size should be fine 
bebb			;		call malloc 
bebb			;		push hl    ; save malloc location 
bebb			; 
bebb			; 
bebb			;; TODO check int type 
bebb			;		FORTH_DSP_VALUEHL 
bebb			;		ld a, l 
bebb			;		call DispAToASCII   
bebb			;;TODO need to chage above call to dump into string 
bebb			; 
bebb			; 
bebb			 
bebb				       NEXTW 
bebb c3 17 9c			jp macro_next 
bebe				endm 
# End of macro NEXTW
bebe			 
bebe			.CONCAT: 
bebe				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bebe 48				db WORD_SYS_CORE+52             
bebf 71 bf			dw .FIND            
bec1 07				db 6 + 1 
bec2 .. 00			db "CONCAT",0              
bec9				endm 
# End of macro CWHEAD
bec9			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bec9			 
bec9			; TODO check string type 
bec9			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bec9			 
bec9					if DEBUG_FORTH_WORDS_KEY 
bec9						DMARK "CON" 
bec9 f5				push af  
beca 3a de be			ld a, (.dmark)  
becd 32 c0 ee			ld (debug_mark),a  
bed0 3a df be			ld a, (.dmark+1)  
bed3 32 c1 ee			ld (debug_mark+1),a  
bed6 3a e0 be			ld a, (.dmark+2)  
bed9 32 c2 ee			ld (debug_mark+2),a  
bedc 18 03			jr .pastdmark  
bede ..			.dmark: db "CON"  
bee1 f1			.pastdmark: pop af  
bee2			endm  
# End of macro DMARK
bee2						CALLMONITOR 
bee2 cd 21 93			call break_point_state  
bee5				endm  
# End of macro CALLMONITOR
bee5					endif 
bee5			 
bee5			 
bee5					FORTH_DSP_VALUE 
bee5 cd 8e 9a			call macro_forth_dsp_value 
bee8				endm 
# End of macro FORTH_DSP_VALUE
bee8 e5					push hl   ; s2 
bee9			 
bee9					FORTH_DSP_POP 
bee9 cd 5d 9b			call macro_forth_dsp_pop 
beec				endm 
# End of macro FORTH_DSP_POP
beec			 
beec					FORTH_DSP_VALUE 
beec cd 8e 9a			call macro_forth_dsp_value 
beef				endm 
# End of macro FORTH_DSP_VALUE
beef			 
beef e5					push hl   ; s1 
bef0			 
bef0					FORTH_DSP_POP 
bef0 cd 5d 9b			call macro_forth_dsp_pop 
bef3				endm 
# End of macro FORTH_DSP_POP
bef3					 
bef3			 
bef3					; copy s1 
bef3			 
bef3				 
bef3					; save ptr 
bef3 e1					pop hl  
bef4 e5					push hl 
bef5 3e 00				ld a, 0 
bef7 cd 10 8f				call strlent 
befa					;inc hl    ; zer0 
befa 06 00				ld b, 0 
befc 4d					ld c, l 
befd e1					pop hl		 
befe 11 e6 e4				ld de, scratch	 
bf01					if DEBUG_FORTH_WORDS 
bf01						DMARK "CO1" 
bf01 f5				push af  
bf02 3a 16 bf			ld a, (.dmark)  
bf05 32 c0 ee			ld (debug_mark),a  
bf08 3a 17 bf			ld a, (.dmark+1)  
bf0b 32 c1 ee			ld (debug_mark+1),a  
bf0e 3a 18 bf			ld a, (.dmark+2)  
bf11 32 c2 ee			ld (debug_mark+2),a  
bf14 18 03			jr .pastdmark  
bf16 ..			.dmark: db "CO1"  
bf19 f1			.pastdmark: pop af  
bf1a			endm  
# End of macro DMARK
bf1a						CALLMONITOR 
bf1a cd 21 93			call break_point_state  
bf1d				endm  
# End of macro CALLMONITOR
bf1d					endif 
bf1d ed b0				ldir 
bf1f			 
bf1f e1					pop hl 
bf20 e5					push hl 
bf21 d5					push de 
bf22			 
bf22			 
bf22 3e 00				ld a, 0 
bf24 cd 10 8f				call strlent 
bf27 23					inc hl    ; zer0 
bf28 23					inc hl 
bf29 06 00				ld b, 0 
bf2b 4d					ld c, l 
bf2c d1					pop de 
bf2d e1					pop hl		 
bf2e					if DEBUG_FORTH_WORDS 
bf2e						DMARK "CO2" 
bf2e f5				push af  
bf2f 3a 43 bf			ld a, (.dmark)  
bf32 32 c0 ee			ld (debug_mark),a  
bf35 3a 44 bf			ld a, (.dmark+1)  
bf38 32 c1 ee			ld (debug_mark+1),a  
bf3b 3a 45 bf			ld a, (.dmark+2)  
bf3e 32 c2 ee			ld (debug_mark+2),a  
bf41 18 03			jr .pastdmark  
bf43 ..			.dmark: db "CO2"  
bf46 f1			.pastdmark: pop af  
bf47			endm  
# End of macro DMARK
bf47						CALLMONITOR 
bf47 cd 21 93			call break_point_state  
bf4a				endm  
# End of macro CALLMONITOR
bf4a					endif 
bf4a ed b0				ldir 
bf4c			 
bf4c			 
bf4c			 
bf4c 21 e6 e4				ld hl, scratch 
bf4f					if DEBUG_FORTH_WORDS 
bf4f						DMARK "CO5" 
bf4f f5				push af  
bf50 3a 64 bf			ld a, (.dmark)  
bf53 32 c0 ee			ld (debug_mark),a  
bf56 3a 65 bf			ld a, (.dmark+1)  
bf59 32 c1 ee			ld (debug_mark+1),a  
bf5c 3a 66 bf			ld a, (.dmark+2)  
bf5f 32 c2 ee			ld (debug_mark+2),a  
bf62 18 03			jr .pastdmark  
bf64 ..			.dmark: db "CO5"  
bf67 f1			.pastdmark: pop af  
bf68			endm  
# End of macro DMARK
bf68						CALLMONITOR 
bf68 cd 21 93			call break_point_state  
bf6b				endm  
# End of macro CALLMONITOR
bf6b					endif 
bf6b			 
bf6b cd 1c 99				call forth_push_str 
bf6e			 
bf6e			 
bf6e			 
bf6e			 
bf6e				       NEXTW 
bf6e c3 17 9c			jp macro_next 
bf71				endm 
# End of macro NEXTW
bf71			 
bf71			 
bf71			.FIND: 
bf71				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bf71 4b				db WORD_SYS_CORE+55             
bf72 2f c0			dw .LEN            
bf74 05				db 4 + 1 
bf75 .. 00			db "FIND",0              
bf7a				endm 
# End of macro CWHEAD
bf7a			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
bf7a			 
bf7a					if DEBUG_FORTH_WORDS_KEY 
bf7a						DMARK "FND" 
bf7a f5				push af  
bf7b 3a 8f bf			ld a, (.dmark)  
bf7e 32 c0 ee			ld (debug_mark),a  
bf81 3a 90 bf			ld a, (.dmark+1)  
bf84 32 c1 ee			ld (debug_mark+1),a  
bf87 3a 91 bf			ld a, (.dmark+2)  
bf8a 32 c2 ee			ld (debug_mark+2),a  
bf8d 18 03			jr .pastdmark  
bf8f ..			.dmark: db "FND"  
bf92 f1			.pastdmark: pop af  
bf93			endm  
# End of macro DMARK
bf93						CALLMONITOR 
bf93 cd 21 93			call break_point_state  
bf96				endm  
# End of macro CALLMONITOR
bf96					endif 
bf96			 
bf96			; TODO check string type 
bf96					FORTH_DSP_VALUE 
bf96 cd 8e 9a			call macro_forth_dsp_value 
bf99				endm 
# End of macro FORTH_DSP_VALUE
bf99			 
bf99 e5					push hl    
bf9a 7e					ld a,(hl)    ; char to find   
bf9b			; TODO change char to substr 
bf9b			 
bf9b f5					push af 
bf9c					 
bf9c			 
bf9c			 
bf9c					if DEBUG_FORTH_WORDS 
bf9c						DMARK "FN1" 
bf9c f5				push af  
bf9d 3a b1 bf			ld a, (.dmark)  
bfa0 32 c0 ee			ld (debug_mark),a  
bfa3 3a b2 bf			ld a, (.dmark+1)  
bfa6 32 c1 ee			ld (debug_mark+1),a  
bfa9 3a b3 bf			ld a, (.dmark+2)  
bfac 32 c2 ee			ld (debug_mark+2),a  
bfaf 18 03			jr .pastdmark  
bfb1 ..			.dmark: db "FN1"  
bfb4 f1			.pastdmark: pop af  
bfb5			endm  
# End of macro DMARK
bfb5						CALLMONITOR 
bfb5 cd 21 93			call break_point_state  
bfb8				endm  
# End of macro CALLMONITOR
bfb8					endif 
bfb8			 
bfb8					FORTH_DSP_POP 
bfb8 cd 5d 9b			call macro_forth_dsp_pop 
bfbb				endm 
# End of macro FORTH_DSP_POP
bfbb			 
bfbb					; string to search 
bfbb			 
bfbb					FORTH_DSP_VALUE 
bfbb cd 8e 9a			call macro_forth_dsp_value 
bfbe				endm 
# End of macro FORTH_DSP_VALUE
bfbe			 
bfbe d1					pop de  ; d is char to find  
bfbf			 
bfbf					if DEBUG_FORTH_WORDS 
bfbf						DMARK "FN2" 
bfbf f5				push af  
bfc0 3a d4 bf			ld a, (.dmark)  
bfc3 32 c0 ee			ld (debug_mark),a  
bfc6 3a d5 bf			ld a, (.dmark+1)  
bfc9 32 c1 ee			ld (debug_mark+1),a  
bfcc 3a d6 bf			ld a, (.dmark+2)  
bfcf 32 c2 ee			ld (debug_mark+2),a  
bfd2 18 03			jr .pastdmark  
bfd4 ..			.dmark: db "FN2"  
bfd7 f1			.pastdmark: pop af  
bfd8			endm  
# End of macro DMARK
bfd8						CALLMONITOR 
bfd8 cd 21 93			call break_point_state  
bfdb				endm  
# End of macro CALLMONITOR
bfdb					endif 
bfdb					 
bfdb 01 00 00				ld bc, 0 
bfde 7e			.findchar:      ld a,(hl) 
bfdf fe 00				cp 0   		 
bfe1 28 27				jr z, .finddone     
bfe3 ba					cp d 
bfe4 28 20				jr z, .foundchar 
bfe6 03					inc bc 
bfe7 23					inc hl 
bfe8					if DEBUG_FORTH_WORDS 
bfe8						DMARK "FN3" 
bfe8 f5				push af  
bfe9 3a fd bf			ld a, (.dmark)  
bfec 32 c0 ee			ld (debug_mark),a  
bfef 3a fe bf			ld a, (.dmark+1)  
bff2 32 c1 ee			ld (debug_mark+1),a  
bff5 3a ff bf			ld a, (.dmark+2)  
bff8 32 c2 ee			ld (debug_mark+2),a  
bffb 18 03			jr .pastdmark  
bffd ..			.dmark: db "FN3"  
c000 f1			.pastdmark: pop af  
c001			endm  
# End of macro DMARK
c001						CALLMONITOR 
c001 cd 21 93			call break_point_state  
c004				endm  
# End of macro CALLMONITOR
c004					endif 
c004 18 d8				jr .findchar 
c006			 
c006			 
c006 c5			.foundchar:	push bc 
c007 e1					pop hl 
c008 18 03				jr .findexit 
c00a			 
c00a			 
c00a							 
c00a			 
c00a			.finddone:     ; got to end of string with no find 
c00a 21 00 00				ld hl, 0 
c00d			.findexit: 
c00d			 
c00d					if DEBUG_FORTH_WORDS 
c00d						DMARK "FNd" 
c00d f5				push af  
c00e 3a 22 c0			ld a, (.dmark)  
c011 32 c0 ee			ld (debug_mark),a  
c014 3a 23 c0			ld a, (.dmark+1)  
c017 32 c1 ee			ld (debug_mark+1),a  
c01a 3a 24 c0			ld a, (.dmark+2)  
c01d 32 c2 ee			ld (debug_mark+2),a  
c020 18 03			jr .pastdmark  
c022 ..			.dmark: db "FNd"  
c025 f1			.pastdmark: pop af  
c026			endm  
# End of macro DMARK
c026						CALLMONITOR 
c026 cd 21 93			call break_point_state  
c029				endm  
# End of macro CALLMONITOR
c029					endif 
c029 cd ae 98			call forth_push_numhl 
c02c			 
c02c				       NEXTW 
c02c c3 17 9c			jp macro_next 
c02f				endm 
# End of macro NEXTW
c02f			 
c02f			.LEN: 
c02f				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c02f 4c				db WORD_SYS_CORE+56             
c030 64 c0			dw .CHAR            
c032 06				db 5 + 1 
c033 .. 00			db "COUNT",0              
c039				endm 
# End of macro CWHEAD
c039			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c039			 
c039					if DEBUG_FORTH_WORDS_KEY 
c039						DMARK "CNT" 
c039 f5				push af  
c03a 3a 4e c0			ld a, (.dmark)  
c03d 32 c0 ee			ld (debug_mark),a  
c040 3a 4f c0			ld a, (.dmark+1)  
c043 32 c1 ee			ld (debug_mark+1),a  
c046 3a 50 c0			ld a, (.dmark+2)  
c049 32 c2 ee			ld (debug_mark+2),a  
c04c 18 03			jr .pastdmark  
c04e ..			.dmark: db "CNT"  
c051 f1			.pastdmark: pop af  
c052			endm  
# End of macro DMARK
c052						CALLMONITOR 
c052 cd 21 93			call break_point_state  
c055				endm  
# End of macro CALLMONITOR
c055					endif 
c055			; TODO check string type 
c055					FORTH_DSP 
c055 cd 6b 9a			call macro_forth_dsp 
c058				endm 
# End of macro FORTH_DSP
c058					;v5FORTH_DSP_VALUE 
c058			 
c058 23					inc hl 
c059			 
c059 3e 00				ld a, 0 
c05b cd 10 8f				call strlent 
c05e			 
c05e cd ae 98				call forth_push_numhl 
c061			 
c061			 
c061			 
c061				       NEXTW 
c061 c3 17 9c			jp macro_next 
c064				endm 
# End of macro NEXTW
c064			.CHAR: 
c064				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c064 4d				db WORD_SYS_CORE+57             
c065 9a c0			dw .ENDSTR            
c067 05				db 4 + 1 
c068 .. 00			db "CHAR",0              
c06d				endm 
# End of macro CWHEAD
c06d			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c06d					if DEBUG_FORTH_WORDS_KEY 
c06d						DMARK "CHR" 
c06d f5				push af  
c06e 3a 82 c0			ld a, (.dmark)  
c071 32 c0 ee			ld (debug_mark),a  
c074 3a 83 c0			ld a, (.dmark+1)  
c077 32 c1 ee			ld (debug_mark+1),a  
c07a 3a 84 c0			ld a, (.dmark+2)  
c07d 32 c2 ee			ld (debug_mark+2),a  
c080 18 03			jr .pastdmark  
c082 ..			.dmark: db "CHR"  
c085 f1			.pastdmark: pop af  
c086			endm  
# End of macro DMARK
c086						CALLMONITOR 
c086 cd 21 93			call break_point_state  
c089				endm  
# End of macro CALLMONITOR
c089					endif 
c089					FORTH_DSP 
c089 cd 6b 9a			call macro_forth_dsp 
c08c				endm 
# End of macro FORTH_DSP
c08c					;v5 FORTH_DSP_VALUE 
c08c 23					inc hl      ; now at start of numeric as string 
c08d			 
c08d			;		push hl 
c08d			 
c08d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c08d cd 5d 9b			call macro_forth_dsp_pop 
c090				endm 
# End of macro FORTH_DSP_POP
c090			 
c090			;		pop hl 
c090			 
c090					; push the content of a onto the stack as a value 
c090			 
c090 7e					ld a,(hl)   ; get char 
c091 26 00				ld h,0 
c093 6f					ld l,a 
c094 cd ae 98				call forth_push_numhl 
c097			 
c097				       NEXTW 
c097 c3 17 9c			jp macro_next 
c09a				endm 
# End of macro NEXTW
c09a			 
c09a			 
c09a			 
c09a			 
c09a			.ENDSTR: 
c09a			; eof 
c09a			 
# End of file forth_words_str.asm
c09a			include "forth_words_key.asm" 
c09a			 
c09a			; | ## Keyboard Words 
c09a			 
c09a			.KEY: 
c09a				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c09a 3e				db WORD_SYS_CORE+42             
c09b ca c0			dw .WAITK            
c09d 04				db 3 + 1 
c09e .. 00			db "KEY",0              
c0a2				endm 
# End of macro CWHEAD
c0a2			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c0a2			 
c0a2					if DEBUG_FORTH_WORDS_KEY 
c0a2						DMARK "KEY" 
c0a2 f5				push af  
c0a3 3a b7 c0			ld a, (.dmark)  
c0a6 32 c0 ee			ld (debug_mark),a  
c0a9 3a b8 c0			ld a, (.dmark+1)  
c0ac 32 c1 ee			ld (debug_mark+1),a  
c0af 3a b9 c0			ld a, (.dmark+2)  
c0b2 32 c2 ee			ld (debug_mark+2),a  
c0b5 18 03			jr .pastdmark  
c0b7 ..			.dmark: db "KEY"  
c0ba f1			.pastdmark: pop af  
c0bb			endm  
# End of macro DMARK
c0bb						CALLMONITOR 
c0bb cd 21 93			call break_point_state  
c0be				endm  
# End of macro CALLMONITOR
c0be					endif 
c0be			; TODO currently waits 
c0be cd 24 d7				call cin 
c0c1					;call cin_wait 
c0c1 6f					ld l, a 
c0c2 26 00				ld h, 0 
c0c4 cd ae 98				call forth_push_numhl 
c0c7					NEXTW 
c0c7 c3 17 9c			jp macro_next 
c0ca				endm 
# End of macro NEXTW
c0ca			.WAITK: 
c0ca				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c0ca 3f				db WORD_SYS_CORE+43             
c0cb fc c0			dw .ACCEPT            
c0cd 06				db 5 + 1 
c0ce .. 00			db "WAITK",0              
c0d4				endm 
# End of macro CWHEAD
c0d4			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c0d4					if DEBUG_FORTH_WORDS_KEY 
c0d4						DMARK "WAI" 
c0d4 f5				push af  
c0d5 3a e9 c0			ld a, (.dmark)  
c0d8 32 c0 ee			ld (debug_mark),a  
c0db 3a ea c0			ld a, (.dmark+1)  
c0de 32 c1 ee			ld (debug_mark+1),a  
c0e1 3a eb c0			ld a, (.dmark+2)  
c0e4 32 c2 ee			ld (debug_mark+2),a  
c0e7 18 03			jr .pastdmark  
c0e9 ..			.dmark: db "WAI"  
c0ec f1			.pastdmark: pop af  
c0ed			endm  
# End of macro DMARK
c0ed						CALLMONITOR 
c0ed cd 21 93			call break_point_state  
c0f0				endm  
# End of macro CALLMONITOR
c0f0					endif 
c0f0 cd 1e d7				call cin_wait 
c0f3 6f					ld l, a 
c0f4 26 00				ld h, 0 
c0f6 cd ae 98				call forth_push_numhl 
c0f9					NEXTW 
c0f9 c3 17 9c			jp macro_next 
c0fc				endm 
# End of macro NEXTW
c0fc			.ACCEPT: 
c0fc				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c0fc 40				db WORD_SYS_CORE+44             
c0fd 5a c1			dw .EDIT            
c0ff 07				db 6 + 1 
c100 .. 00			db "ACCEPT",0              
c107				endm 
# End of macro CWHEAD
c107			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c107					; TODO crashes on push 
c107					if DEBUG_FORTH_WORDS_KEY 
c107						DMARK "ACC" 
c107 f5				push af  
c108 3a 1c c1			ld a, (.dmark)  
c10b 32 c0 ee			ld (debug_mark),a  
c10e 3a 1d c1			ld a, (.dmark+1)  
c111 32 c1 ee			ld (debug_mark+1),a  
c114 3a 1e c1			ld a, (.dmark+2)  
c117 32 c2 ee			ld (debug_mark+2),a  
c11a 18 03			jr .pastdmark  
c11c ..			.dmark: db "ACC"  
c11f f1			.pastdmark: pop af  
c120			endm  
# End of macro DMARK
c120						CALLMONITOR 
c120 cd 21 93			call break_point_state  
c123				endm  
# End of macro CALLMONITOR
c123					endif 
c123 21 e4 e6				ld hl, os_input 
c126 3e 00				ld a, 0 
c128 77					ld (hl),a 
c129 3a cf ec				ld a,(f_cursor_ptr) 
c12c 16 64				ld d, 100 
c12e 0e 00				ld c, 0 
c130 1e 28				ld e, 40 
c132 cd d4 8a				call input_str 
c135					; TODO perhaps do a type check and wrap in quotes if not a number 
c135 21 e4 e6				ld hl, os_input 
c138					if DEBUG_FORTH_WORDS 
c138						DMARK "AC1" 
c138 f5				push af  
c139 3a 4d c1			ld a, (.dmark)  
c13c 32 c0 ee			ld (debug_mark),a  
c13f 3a 4e c1			ld a, (.dmark+1)  
c142 32 c1 ee			ld (debug_mark+1),a  
c145 3a 4f c1			ld a, (.dmark+2)  
c148 32 c2 ee			ld (debug_mark+2),a  
c14b 18 03			jr .pastdmark  
c14d ..			.dmark: db "AC1"  
c150 f1			.pastdmark: pop af  
c151			endm  
# End of macro DMARK
c151						CALLMONITOR 
c151 cd 21 93			call break_point_state  
c154				endm  
# End of macro CALLMONITOR
c154					endif 
c154 cd 1c 99				call forth_push_str 
c157					NEXTW 
c157 c3 17 9c			jp macro_next 
c15a				endm 
# End of macro NEXTW
c15a			 
c15a			.EDIT: 
c15a				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c15a 40				db WORD_SYS_CORE+44             
c15b e3 c1			dw .ENDKEY            
c15d 05				db 4 + 1 
c15e .. 00			db "EDIT",0              
c163				endm 
# End of macro CWHEAD
c163			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c163			 
c163					; TODO does not copy from stack 
c163					if DEBUG_FORTH_WORDS_KEY 
c163						DMARK "EDT" 
c163 f5				push af  
c164 3a 78 c1			ld a, (.dmark)  
c167 32 c0 ee			ld (debug_mark),a  
c16a 3a 79 c1			ld a, (.dmark+1)  
c16d 32 c1 ee			ld (debug_mark+1),a  
c170 3a 7a c1			ld a, (.dmark+2)  
c173 32 c2 ee			ld (debug_mark+2),a  
c176 18 03			jr .pastdmark  
c178 ..			.dmark: db "EDT"  
c17b f1			.pastdmark: pop af  
c17c			endm  
# End of macro DMARK
c17c						CALLMONITOR 
c17c cd 21 93			call break_point_state  
c17f				endm  
# End of macro CALLMONITOR
c17f					endif 
c17f			 
c17f					FORTH_DSP 
c17f cd 6b 9a			call macro_forth_dsp 
c182				endm 
# End of macro FORTH_DSP
c182					;v5 FORTH_DSP_VALUE 
c182 23					inc hl    ; TODO do type check 
c183			 
c183 e5					push hl 
c184 3e 00				ld a, 0 
c186 cd 10 8f				call strlent 
c189 23					inc hl 
c18a			 
c18a 06 00				ld b, 0 
c18c 4d					ld c, l 
c18d			 
c18d e1					pop hl 
c18e 11 e4 e6				ld de, os_input 
c191					if DEBUG_FORTH_WORDS_KEY 
c191						DMARK "EDc" 
c191 f5				push af  
c192 3a a6 c1			ld a, (.dmark)  
c195 32 c0 ee			ld (debug_mark),a  
c198 3a a7 c1			ld a, (.dmark+1)  
c19b 32 c1 ee			ld (debug_mark+1),a  
c19e 3a a8 c1			ld a, (.dmark+2)  
c1a1 32 c2 ee			ld (debug_mark+2),a  
c1a4 18 03			jr .pastdmark  
c1a6 ..			.dmark: db "EDc"  
c1a9 f1			.pastdmark: pop af  
c1aa			endm  
# End of macro DMARK
c1aa						CALLMONITOR 
c1aa cd 21 93			call break_point_state  
c1ad				endm  
# End of macro CALLMONITOR
c1ad					endif 
c1ad ed b0				ldir 
c1af			 
c1af			 
c1af 21 e4 e6				ld hl, os_input 
c1b2					;ld a, 0 
c1b2					;ld (hl),a 
c1b2 3a cf ec				ld a,(f_cursor_ptr) 
c1b5 16 64				ld d, 100 
c1b7 0e 00				ld c, 0 
c1b9 1e 28				ld e, 40 
c1bb cd d4 8a				call input_str 
c1be					; TODO perhaps do a type check and wrap in quotes if not a number 
c1be 21 e4 e6				ld hl, os_input 
c1c1					if DEBUG_FORTH_WORDS 
c1c1						DMARK "ED1" 
c1c1 f5				push af  
c1c2 3a d6 c1			ld a, (.dmark)  
c1c5 32 c0 ee			ld (debug_mark),a  
c1c8 3a d7 c1			ld a, (.dmark+1)  
c1cb 32 c1 ee			ld (debug_mark+1),a  
c1ce 3a d8 c1			ld a, (.dmark+2)  
c1d1 32 c2 ee			ld (debug_mark+2),a  
c1d4 18 03			jr .pastdmark  
c1d6 ..			.dmark: db "ED1"  
c1d9 f1			.pastdmark: pop af  
c1da			endm  
# End of macro DMARK
c1da						CALLMONITOR 
c1da cd 21 93			call break_point_state  
c1dd				endm  
# End of macro CALLMONITOR
c1dd					endif 
c1dd cd 1c 99				call forth_push_str 
c1e0					NEXTW 
c1e0 c3 17 9c			jp macro_next 
c1e3				endm 
# End of macro NEXTW
c1e3			 
c1e3			 
c1e3			 
c1e3			.ENDKEY: 
c1e3			; eof 
c1e3			 
# End of file forth_words_key.asm
c1e3			 
c1e3			if STORAGE_SE 
c1e3			   	include "forth_words_storage.asm" 
c1e3			endif 
c1e3				include "forth_words_device.asm" 
c1e3			; Device related words 
c1e3			 
c1e3			; | ## Device Words 
c1e3			 
c1e3			if SOUND_ENABLE 
c1e3			.NOTE: 
c1e3				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c1e3			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c1e3					if DEBUG_FORTH_WORDS_KEY 
c1e3						DMARK "NTE" 
c1e3						CALLMONITOR 
c1e3					endif 
c1e3			 
c1e3				 
c1e3			 
c1e3					NEXTW 
c1e3			.AFTERSOUND: 
c1e3			endif 
c1e3			 
c1e3			 
c1e3			USE_GPIO: equ 0 
c1e3			 
c1e3			if USE_GPIO 
c1e3			.GP1: 
c1e3				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c1e3			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c1e3					NEXTW 
c1e3			.GP2: 
c1e3				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c1e3			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c1e3			 
c1e3					NEXTW 
c1e3			 
c1e3			.GP3: 
c1e3				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c1e3			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c1e3			 
c1e3					NEXTW 
c1e3			 
c1e3			.GP4: 
c1e3				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c1e3			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c1e3			 
c1e3					NEXTW 
c1e3			.SIN: 
c1e3			 
c1e3			 
c1e3			endif 
c1e3			 
c1e3			 
c1e3				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c1e3 33				db WORD_SYS_CORE+31             
c1e4 18 c2			dw .SOUT            
c1e6 03				db 2 + 1 
c1e7 .. 00			db "IN",0              
c1ea				endm 
# End of macro CWHEAD
c1ea			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c1ea					if DEBUG_FORTH_WORDS_KEY 
c1ea						DMARK "IN." 
c1ea f5				push af  
c1eb 3a ff c1			ld a, (.dmark)  
c1ee 32 c0 ee			ld (debug_mark),a  
c1f1 3a 00 c2			ld a, (.dmark+1)  
c1f4 32 c1 ee			ld (debug_mark+1),a  
c1f7 3a 01 c2			ld a, (.dmark+2)  
c1fa 32 c2 ee			ld (debug_mark+2),a  
c1fd 18 03			jr .pastdmark  
c1ff ..			.dmark: db "IN."  
c202 f1			.pastdmark: pop af  
c203			endm  
# End of macro DMARK
c203						CALLMONITOR 
c203 cd 21 93			call break_point_state  
c206				endm  
# End of macro CALLMONITOR
c206					endif 
c206					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c206 cd a5 9a			call macro_dsp_valuehl 
c209				endm 
# End of macro FORTH_DSP_VALUEHL
c209			 
c209 e5					push hl 
c20a			 
c20a					; destroy value TOS 
c20a			 
c20a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c20a cd 5d 9b			call macro_forth_dsp_pop 
c20d				endm 
# End of macro FORTH_DSP_POP
c20d			 
c20d					; one value on hl get other one back 
c20d			 
c20d c1					pop bc 
c20e			 
c20e					; do the sub 
c20e			;		ex de, hl 
c20e			 
c20e ed 68				in l,(c) 
c210			 
c210					; save it 
c210			 
c210 26 00				ld h,0 
c212			 
c212					; TODO push value back onto stack for another op etc 
c212			 
c212 cd ae 98				call forth_push_numhl 
c215					NEXTW 
c215 c3 17 9c			jp macro_next 
c218				endm 
# End of macro NEXTW
c218			.SOUT: 
c218				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c218 34				db WORD_SYS_CORE+32             
c219 6b c2			dw .SPIO            
c21b 04				db 3 + 1 
c21c .. 00			db "OUT",0              
c220				endm 
# End of macro CWHEAD
c220			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c220					if DEBUG_FORTH_WORDS_KEY 
c220						DMARK "OUT" 
c220 f5				push af  
c221 3a 35 c2			ld a, (.dmark)  
c224 32 c0 ee			ld (debug_mark),a  
c227 3a 36 c2			ld a, (.dmark+1)  
c22a 32 c1 ee			ld (debug_mark+1),a  
c22d 3a 37 c2			ld a, (.dmark+2)  
c230 32 c2 ee			ld (debug_mark+2),a  
c233 18 03			jr .pastdmark  
c235 ..			.dmark: db "OUT"  
c238 f1			.pastdmark: pop af  
c239			endm  
# End of macro DMARK
c239						CALLMONITOR 
c239 cd 21 93			call break_point_state  
c23c				endm  
# End of macro CALLMONITOR
c23c					endif 
c23c			 
c23c					; get port 
c23c			 
c23c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c23c cd a5 9a			call macro_dsp_valuehl 
c23f				endm 
# End of macro FORTH_DSP_VALUEHL
c23f			 
c23f e5					push hl 
c240			 
c240					; destroy value TOS 
c240			 
c240					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c240 cd 5d 9b			call macro_forth_dsp_pop 
c243				endm 
# End of macro FORTH_DSP_POP
c243			 
c243					; get byte to send 
c243			 
c243					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c243 cd a5 9a			call macro_dsp_valuehl 
c246				endm 
# End of macro FORTH_DSP_VALUEHL
c246			 
c246			;		push hl 
c246			 
c246					; destroy value TOS 
c246			 
c246					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c246 cd 5d 9b			call macro_forth_dsp_pop 
c249				endm 
# End of macro FORTH_DSP_POP
c249			 
c249					; one value on hl get other one back 
c249			 
c249			;		pop hl 
c249			 
c249 c1					pop bc 
c24a			 
c24a					if DEBUG_FORTH_WORDS 
c24a						DMARK "OUT" 
c24a f5				push af  
c24b 3a 5f c2			ld a, (.dmark)  
c24e 32 c0 ee			ld (debug_mark),a  
c251 3a 60 c2			ld a, (.dmark+1)  
c254 32 c1 ee			ld (debug_mark+1),a  
c257 3a 61 c2			ld a, (.dmark+2)  
c25a 32 c2 ee			ld (debug_mark+2),a  
c25d 18 03			jr .pastdmark  
c25f ..			.dmark: db "OUT"  
c262 f1			.pastdmark: pop af  
c263			endm  
# End of macro DMARK
c263						CALLMONITOR 
c263 cd 21 93			call break_point_state  
c266				endm  
# End of macro CALLMONITOR
c266					endif 
c266			 
c266 ed 69				out (c), l 
c268			 
c268					NEXTW 
c268 c3 17 9c			jp macro_next 
c26b				endm 
# End of macro NEXTW
c26b			 
c26b			 
c26b			.SPIO: 
c26b			 
c26b			if STORAGE_SE 
c26b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c26b			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c26b			 
c26b					call spi_ce_low 
c26b			    NEXTW 
c26b			 
c26b			.SPICEH: 
c26b				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c26b			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c26b			 
c26b					call spi_ce_high 
c26b			    NEXTW 
c26b			 
c26b			 
c26b			.SPIOb: 
c26b			 
c26b				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c26b			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c26b			 
c26b					; get port 
c26b			 
c26b			 
c26b					; get byte to send 
c26b			 
c26b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c26b			 
c26b			;		push hl    ; u1  
c26b			 
c26b					; destroy value TOS 
c26b			 
c26b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c26b			 
c26b					; one value on hl get other one back 
c26b			 
c26b			;		pop hl   ; u2 - addr 
c26b			 
c26b					; TODO Send SPI byte 
c26b			 
c26b					ld a, l 
c26b					call spi_send_byte 
c26b			 
c26b					NEXTW 
c26b			 
c26b			.SPII: 
c26b				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c26b			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c26b			 
c26b					; TODO Get SPI byte 
c26b			 
c26b					call spi_read_byte 
c26b			 
c26b					ld h, 0 
c26b					ld l, a 
c26b					call forth_push_numhl 
c26b			 
c26b					NEXTW 
c26b			 
c26b			 
c26b			 
c26b			.SESEL: 
c26b				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c26b			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c26b					if DEBUG_FORTH_WORDS_KEY 
c26b						DMARK "BNK" 
c26b						CALLMONITOR 
c26b					endif 
c26b			 
c26b					ld a, 255 
c26b					ld (spi_cartdev), a 
c26b			 
c26b					; get bank 
c26b			 
c26b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c26b			 
c26b			;		push hl 
c26b			 
c26b					; destroy value TOS 
c26b			 
c26b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c26b			 
c26b					; one value on hl get other one back 
c26b			 
c26b			;		pop hl 
c26b			 
c26b			 
c26b					ld c, SPI_CE_HIGH 
c26b					ld b, '0'    ; human readable bank number 
c26b			 
c26b					ld a, l 
c26b			 
c26b					if DEBUG_FORTH_WORDS 
c26b						DMARK "BNK" 
c26b						CALLMONITOR 
c26b					endif 
c26b			 
c26b					; active low 
c26b			 
c26b					cp 0 
c26b					jr z, .bset 
c26b					cp 1 
c26b					jr nz, .b2 
c26b					res 0, c 
c26b					ld b, '1'    ; human readable bank number 
c26b			.b2:		cp 2 
c26b					jr nz, .b3 
c26b					res 1, c 
c26b					ld b, '2'    ; human readable bank number 
c26b			.b3:		cp 3 
c26b					jr nz, .b4 
c26b					res 2, c 
c26b					ld b, '3'    ; human readable bank number 
c26b			.b4:		cp 4 
c26b					jr nz, .b5 
c26b					res 3, c 
c26b					ld b, '4'    ; human readable bank number 
c26b			.b5:		cp 5 
c26b					jr nz, .bset 
c26b					res 4, c 
c26b					ld b, '5'    ; human readable bank number 
c26b			 
c26b			.bset: 
c26b					ld a, c 
c26b					ld (spi_device),a 
c26b					ld a, b 
c26b					ld (spi_device_id),a 
c26b					if DEBUG_FORTH_WORDS 
c26b						DMARK "BN2" 
c26b						CALLMONITOR 
c26b					endif 
c26b			 
c26b					NEXTW 
c26b			 
c26b			.CARTDEV: 
c26b				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c26b			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c26b					if DEBUG_FORTH_WORDS_KEY 
c26b						DMARK "CDV" 
c26b						CALLMONITOR 
c26b					endif 
c26b			 
c26b					; disable se storage bank selection 
c26b			 
c26b					ld a, SPI_CE_HIGH		; ce high 
c26b					ld (spi_device), a 
c26b			 
c26b					; get bank 
c26b			 
c26b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c26b			 
c26b			;		push hl 
c26b			 
c26b					; destroy value TOS 
c26b			 
c26b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c26b			 
c26b					; one value on hl get other one back 
c26b			 
c26b			;		pop hl 
c26b			 
c26b					; active low 
c26b			 
c26b					ld c, 255 
c26b			 
c26b					ld a, l 
c26b					if DEBUG_FORTH_WORDS 
c26b						DMARK "CDV" 
c26b						CALLMONITOR 
c26b					endif 
c26b					cp 0 
c26b					jr z, .cset 
c26b					cp 1 
c26b					jr nz, .c2 
c26b					res 0, c 
c26b			.c2:		cp 2 
c26b					jr nz, .c3 
c26b					res 1, c 
c26b			.c3:		cp 3 
c26b					jr nz, .c4 
c26b					res 2, c 
c26b			.c4:		cp 4 
c26b					jr nz, .c5 
c26b					res 3, c 
c26b			.c5:		cp 5 
c26b					jr nz, .c6 
c26b					res 4, c 
c26b			.c6:		cp 6 
c26b					jr nz, .c7 
c26b					res 5, c 
c26b			.c7:		cp 7 
c26b					jr nz, .c8 
c26b					res 6, c 
c26b			.c8:		cp 8 
c26b					jr nz, .cset 
c26b					res 7, c 
c26b			.cset:		ld a, c 
c26b					ld (spi_cartdev),a 
c26b			 
c26b					if DEBUG_FORTH_WORDS 
c26b						DMARK "CD2" 
c26b						CALLMONITOR 
c26b					endif 
c26b					NEXTW 
c26b			endif 
c26b			 
c26b			.ENDDEVICE: 
c26b			; eof 
c26b			 
# End of file forth_words_device.asm
c26b			 
c26b			; var handler 
c26b			 
c26b			 
c26b			.VARS: 
c26b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c26b 78				db WORD_SYS_CORE+100             
c26c 83 c2			dw .V0Q            
c26e 04				db 3 + 1 
c26f .. 00			db "V0!",0              
c273				endm 
# End of macro CWHEAD
c273			;| V0! ( u1 -- )  Store value to v0  | DONE 
c273			 
c273					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c273 cd a5 9a			call macro_dsp_valuehl 
c276				endm 
# End of macro FORTH_DSP_VALUEHL
c276			 
c276 11 99 ec				ld de, cli_var_array 
c279			 
c279 eb					ex de, hl 
c27a 73					ld (hl), e 
c27b 23					inc hl 
c27c 72					ld (hl), d 
c27d			 
c27d					; destroy value TOS 
c27d			 
c27d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c27d cd 5d 9b			call macro_forth_dsp_pop 
c280				endm 
# End of macro FORTH_DSP_POP
c280			 
c280				       NEXTW 
c280 c3 17 9c			jp macro_next 
c283				endm 
# End of macro NEXTW
c283			.V0Q: 
c283				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c283 79				db WORD_SYS_CORE+101             
c284 94 c2			dw .V1S            
c286 04				db 3 + 1 
c287 .. 00			db "V0@",0              
c28b				endm 
# End of macro CWHEAD
c28b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c28b 2a 99 ec				ld hl, (cli_var_array) 
c28e cd ae 98				call forth_push_numhl 
c291			 
c291				       NEXTW 
c291 c3 17 9c			jp macro_next 
c294				endm 
# End of macro NEXTW
c294			.V1S: 
c294				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c294 7a				db WORD_SYS_CORE+102             
c295 ac c2			dw .V1Q            
c297 04				db 3 + 1 
c298 .. 00			db "V1!",0              
c29c				endm 
# End of macro CWHEAD
c29c			;| V1! ( u1 -- )  Store value to v1 | DONE 
c29c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c29c cd a5 9a			call macro_dsp_valuehl 
c29f				endm 
# End of macro FORTH_DSP_VALUEHL
c29f			 
c29f 11 9b ec				ld de, cli_var_array+2 
c2a2				 
c2a2 eb					ex de, hl 
c2a3 73					ld (hl), e 
c2a4 23					inc hl 
c2a5 72					ld (hl), d 
c2a6			 
c2a6					; destroy value TOS 
c2a6			 
c2a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2a6 cd 5d 9b			call macro_forth_dsp_pop 
c2a9				endm 
# End of macro FORTH_DSP_POP
c2a9				       NEXTW 
c2a9 c3 17 9c			jp macro_next 
c2ac				endm 
# End of macro NEXTW
c2ac			.V1Q: 
c2ac				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c2ac 7b				db WORD_SYS_CORE+103             
c2ad bd c2			dw .V2S            
c2af 04				db 3 + 1 
c2b0 .. 00			db "V1@",0              
c2b4				endm 
# End of macro CWHEAD
c2b4			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c2b4 2a 9b ec				ld hl, (cli_var_array+2) 
c2b7 cd ae 98				call forth_push_numhl 
c2ba				       NEXTW 
c2ba c3 17 9c			jp macro_next 
c2bd				endm 
# End of macro NEXTW
c2bd			.V2S: 
c2bd				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c2bd 7c				db WORD_SYS_CORE+104             
c2be d5 c2			dw .V2Q            
c2c0 04				db 3 + 1 
c2c1 .. 00			db "V2!",0              
c2c5				endm 
# End of macro CWHEAD
c2c5			;| V2! ( u1 -- )  Store value to v2 | DONE 
c2c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2c5 cd a5 9a			call macro_dsp_valuehl 
c2c8				endm 
# End of macro FORTH_DSP_VALUEHL
c2c8			 
c2c8 11 9d ec				ld de, cli_var_array+4 
c2cb				 
c2cb eb					ex de, hl 
c2cc 73					ld (hl), e 
c2cd 23					inc hl 
c2ce 72					ld (hl), d 
c2cf			 
c2cf					; destroy value TOS 
c2cf			 
c2cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2cf cd 5d 9b			call macro_forth_dsp_pop 
c2d2				endm 
# End of macro FORTH_DSP_POP
c2d2				       NEXTW 
c2d2 c3 17 9c			jp macro_next 
c2d5				endm 
# End of macro NEXTW
c2d5			.V2Q: 
c2d5				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c2d5 7d				db WORD_SYS_CORE+105             
c2d6 e6 c2			dw .V3S            
c2d8 04				db 3 + 1 
c2d9 .. 00			db "V2@",0              
c2dd				endm 
# End of macro CWHEAD
c2dd			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c2dd 2a 9d ec				ld hl, (cli_var_array+4) 
c2e0 cd ae 98				call forth_push_numhl 
c2e3				       NEXTW 
c2e3 c3 17 9c			jp macro_next 
c2e6				endm 
# End of macro NEXTW
c2e6			.V3S: 
c2e6				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c2e6 7c				db WORD_SYS_CORE+104             
c2e7 fe c2			dw .V3Q            
c2e9 04				db 3 + 1 
c2ea .. 00			db "V3!",0              
c2ee				endm 
# End of macro CWHEAD
c2ee			;| V3! ( u1 -- )  Store value to v3 | DONE 
c2ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2ee cd a5 9a			call macro_dsp_valuehl 
c2f1				endm 
# End of macro FORTH_DSP_VALUEHL
c2f1			 
c2f1 11 9f ec				ld de, cli_var_array+6 
c2f4				 
c2f4 eb					ex de, hl 
c2f5 73					ld (hl), e 
c2f6 23					inc hl 
c2f7 72					ld (hl), d 
c2f8			 
c2f8					; destroy value TOS 
c2f8			 
c2f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2f8 cd 5d 9b			call macro_forth_dsp_pop 
c2fb				endm 
# End of macro FORTH_DSP_POP
c2fb				       NEXTW 
c2fb c3 17 9c			jp macro_next 
c2fe				endm 
# End of macro NEXTW
c2fe			.V3Q: 
c2fe				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c2fe 7d				db WORD_SYS_CORE+105             
c2ff 0f c3			dw .END            
c301 04				db 3 + 1 
c302 .. 00			db "V3@",0              
c306				endm 
# End of macro CWHEAD
c306			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c306 2a 9f ec				ld hl, (cli_var_array+6) 
c309 cd ae 98				call forth_push_numhl 
c30c				       NEXTW 
c30c c3 17 9c			jp macro_next 
c30f				endm 
# End of macro NEXTW
c30f			 
c30f			 
c30f			 
c30f			 
c30f			 
c30f			; end of dict marker 
c30f			 
c30f 00			.END:    db WORD_SYS_END 
c310 00 00			dw 0 
c312 00				db 0 
c313			 
c313			; use to jp here for user dict words to save on macro expansion  
c313			 
c313			user_dict_next: 
c313				NEXTW 
c313 c3 17 9c			jp macro_next 
c316				endm 
# End of macro NEXTW
c316			 
c316			 
c316			user_exec: 
c316				;    ld hl, <word code> 
c316				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c316				;    call forthexec 
c316				;    jp user_dict_next   (NEXT) 
c316			        ;    <word code bytes> 
c316 eb				ex de, hl 
c317 2a e7 e7			ld hl,(os_tok_ptr) 
c31a				 
c31a				FORTH_RSP_NEXT 
c31a cd 55 98			call macro_forth_rsp_next 
c31d				endm 
# End of macro FORTH_RSP_NEXT
c31d			 
c31d			if DEBUG_FORTH_UWORD 
c31d						DMARK "UEX" 
c31d f5				push af  
c31e 3a 32 c3			ld a, (.dmark)  
c321 32 c0 ee			ld (debug_mark),a  
c324 3a 33 c3			ld a, (.dmark+1)  
c327 32 c1 ee			ld (debug_mark+1),a  
c32a 3a 34 c3			ld a, (.dmark+2)  
c32d 32 c2 ee			ld (debug_mark+2),a  
c330 18 03			jr .pastdmark  
c332 ..			.dmark: db "UEX"  
c335 f1			.pastdmark: pop af  
c336			endm  
# End of macro DMARK
c336				CALLMONITOR 
c336 cd 21 93			call break_point_state  
c339				endm  
# End of macro CALLMONITOR
c339			endif 
c339			 
c339			 
c339			 
c339 eb				ex de, hl 
c33a 22 e7 e7			ld (os_tok_ptr), hl 
c33d				 
c33d				; Don't use next - Skips the first word in uword. 
c33d			 
c33d c3 a8 9c			jp exec1 
c340			;	NEXT 
c340			 
c340			 
c340			; eof 
# End of file forth_wordsv4.asm
c340			endif 
c340			;;;;;;;;;;;;;; Debug code 
c340			 
c340			 
c340			;if DEBUG_FORTH_PARSE 
c340 .. 00		.nowordfound: db "No match",0 
c349 .. 00		.compword:	db "Comparing word ",0 
c359 .. 00		.nextwordat:	db "Next word at",0 
c366 .. 00		.charmatch:	db "Char match",0 
c371			;endif 
c371			if DEBUG_FORTH_JP 
c371			.foundword:	db "Word match. Exec..",0 
c371			endif 
c371			;if DEBUG_FORTH_PUSH 
c371 .. 00		.enddict:	db "Dict end. Push.",0 
c381 .. 00		.push_str:	db "Pushing string",0 
c390 .. 00		.push_num:	db "Pushing number",0 
c39f .. 00		.data_sp:	db "SP:",0 
c3a3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c3b5 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c3c7 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c3d9			;endif 
c3d9			;if DEBUG_FORTH_MALLOC 
c3d9 .. 00		.push_malloc:	db "Malloc address",0 
c3e8			;endif 
c3e8			 
c3e8			 
c3e8			 
c3e8			; display malloc address and current data stack pointer  
c3e8			 
c3e8			malloc_error: 
c3e8 d5				push de 
c3e9 f5				push af 
c3ea e5				push hl 
c3eb cd 7a 88			call clear_display 
c3ee 11 10 c4			ld de, .mallocerr 
c3f1 3e 00			ld a,0 
c3f3			;	ld de,os_word_scratch 
c3f3 cd 8d 88			call str_at_display 
c3f6 3e 11			ld a, display_row_1+17 
c3f8 11 c0 ee			ld de, debug_mark 
c3fb cd 8d 88			call str_at_display 
c3fe cd 9d 88			call update_display 
c401				;call break_point_state 
c401 cd 1e d7			call cin_wait 
c404			 
c404 3e 20			ld a, ' ' 
c406 32 d7 e4			ld (os_view_disable), a 
c409 e1				pop hl 
c40a f1				pop af 
c40b d1				pop de	 
c40c				CALLMONITOR 
c40c cd 21 93			call break_point_state  
c40f				endm  
# End of macro CALLMONITOR
c40f c9				ret 
c410			 
c410 .. 00		.mallocerr: 	db "Malloc Error",0 
c41d			;if DEBUG_FORTH_PUSH 
c41d			display_data_sp: 
c41d f5				push af 
c41e			 
c41e				; see if disabled 
c41e			 
c41e 3a d7 e4			ld a, (os_view_disable) 
c421 fe 2a			cp '*' 
c423 28 67			jr z, .skipdsp 
c425			 
c425 e5				push hl 
c426 e5				push hl 
c427 e5			push hl 
c428 cd 7a 88			call clear_display 
c42b e1			pop hl 
c42c 7c				ld a,h 
c42d 21 eb e7			ld hl, os_word_scratch 
c430 cd a8 8d			call hexout 
c433 e1				pop hl 
c434 7d				ld a,l 
c435 21 ed e7			ld hl, os_word_scratch+2 
c438 cd a8 8d			call hexout 
c43b 21 ef e7			ld hl, os_word_scratch+4 
c43e 3e 00			ld a,0 
c440 77				ld (hl),a 
c441 11 eb e7			ld de,os_word_scratch 
c444 3e 14				ld a, display_row_2 
c446 cd 8d 88				call str_at_display 
c449 11 a3 c3			ld de, .wordinhl 
c44c 3e 00			ld a, display_row_1 
c44e			 
c44e cd 8d 88				call str_at_display 
c451 11 c0 ee			ld de, debug_mark 
c454 3e 11			ld a, display_row_1+17 
c456			 
c456 cd 8d 88				call str_at_display 
c459			 
c459				; display current data stack pointer 
c459 11 9f c3			ld de,.data_sp 
c45c 3e 1c				ld a, display_row_2 + 8 
c45e cd 8d 88				call str_at_display 
c461			 
c461 2a 93 ec			ld hl,(cli_data_sp) 
c464 e5				push hl 
c465 7c				ld a,h 
c466 21 eb e7			ld hl, os_word_scratch 
c469 cd a8 8d			call hexout 
c46c e1				pop hl 
c46d 7d				ld a,l 
c46e 21 ed e7			ld hl, os_word_scratch+2 
c471 cd a8 8d			call hexout 
c474 21 ef e7			ld hl, os_word_scratch+4 
c477 3e 00			ld a,0 
c479 77				ld (hl),a 
c47a 11 eb e7			ld de,os_word_scratch 
c47d 3e 1f				ld a, display_row_2 + 11 
c47f cd 8d 88				call str_at_display 
c482			 
c482			 
c482 cd 9d 88			call update_display 
c485 cd fa 87			call delay1s 
c488 cd fa 87			call delay1s 
c48b e1				pop hl 
c48c			.skipdsp: 
c48c f1				pop af 
c48d c9				ret 
c48e			 
c48e			display_data_malloc: 
c48e			 
c48e f5				push af 
c48f e5				push hl 
c490 e5				push hl 
c491 e5			push hl 
c492 cd 7a 88			call clear_display 
c495 e1			pop hl 
c496 7c				ld a,h 
c497 21 eb e7			ld hl, os_word_scratch 
c49a cd a8 8d			call hexout 
c49d e1				pop hl 
c49e 7d				ld a,l 
c49f 21 ed e7			ld hl, os_word_scratch+2 
c4a2 cd a8 8d			call hexout 
c4a5 21 ef e7			ld hl, os_word_scratch+4 
c4a8 3e 00			ld a,0 
c4aa 77				ld (hl),a 
c4ab 11 eb e7			ld de,os_word_scratch 
c4ae 3e 14				ld a, display_row_2 
c4b0 cd 8d 88				call str_at_display 
c4b3 11 d9 c3			ld de, .push_malloc 
c4b6 3e 00			ld a, display_row_1 
c4b8			 
c4b8 cd 8d 88				call str_at_display 
c4bb			 
c4bb				; display current data stack pointer 
c4bb 11 9f c3			ld de,.data_sp 
c4be 3e 1c				ld a, display_row_2 + 8 
c4c0 cd 8d 88				call str_at_display 
c4c3			 
c4c3 2a 93 ec			ld hl,(cli_data_sp) 
c4c6 e5				push hl 
c4c7 7c				ld a,h 
c4c8 21 eb e7			ld hl, os_word_scratch 
c4cb cd a8 8d			call hexout 
c4ce e1				pop hl 
c4cf 7d				ld a,l 
c4d0 21 ed e7			ld hl, os_word_scratch+2 
c4d3 cd a8 8d			call hexout 
c4d6 21 ef e7			ld hl, os_word_scratch+4 
c4d9 3e 00			ld a,0 
c4db 77				ld (hl),a 
c4dc 11 eb e7			ld de,os_word_scratch 
c4df 3e 1f				ld a, display_row_2 + 11 
c4e1 cd 8d 88				call str_at_display 
c4e4			 
c4e4 cd 9d 88			call update_display 
c4e7 cd fa 87			call delay1s 
c4ea cd fa 87			call delay1s 
c4ed e1				pop hl 
c4ee f1				pop af 
c4ef c9				ret 
c4f0			;endif 
c4f0			 
c4f0			include "forth_autostart.asm" 
c4f0			; list of commands to perform at system start up 
c4f0			 
c4f0			startcmds: 
c4f0			;	dw test11 
c4f0			;	dw test12 
c4f0			;	dw test13 
c4f0			;	dw test14 
c4f0			;	dw test15 
c4f0			;	dw test16 
c4f0			;	dw test17 
c4f0			;	dw ifthtest1 
c4f0			;	dw ifthtest2 
c4f0			;	dw ifthtest3 
c4f0			;	dw mmtest1 
c4f0			;	dw mmtest2 
c4f0			;	dw mmtest3 
c4f0			;	dw mmtest4 
c4f0			;	dw mmtest5 
c4f0			;	dw mmtest6 
c4f0			;	dw iftest1 
c4f0			;	dw iftest2 
c4f0			;	dw iftest3 
c4f0			;	dw looptest1 
c4f0			;	dw looptest2 
c4f0			;	dw test1 
c4f0			;	dw test2 
c4f0			;	dw test3 
c4f0			;	dw test4 
c4f0			;	dw game2r 
c4f0			;	dw game2b1 
c4f0			;	dw game2b2 
c4f0			 
c4f0				; start up words that are actually useful 
c4f0			 
c4f0 4e c5			dw clrstack 
c4f2 81 c5			dw type 
c4f4 42 c7			dw stest 
c4f6 a5 c5			dw strncpy 
c4f8 e3 c6			dw list 
c4fa 06 c6			dw start1 
c4fc 18 c6			dw start2 
c4fe			;	dw start3 
c4fe 2b c6			dw start3b 
c500 83 c6			dw start3c 
c502			 
c502				; (unit) testing words 
c502			 
c502 b9 c7			dw mtesta 
c504 6e c8			dw mtestb 
c506 11 c9			dw mtestc 
c508 c6 c9			dw mtestd 
c50a 6a ca			dw mteste 
c50c			 
c50c				; demo/game words 
c50c			 
c50c 76 d1		        dw game3w 
c50e a4 d1		        dw game3p 
c510 c2 d1		        dw game3sc 
c512 f3 d1		        dw game3vsi 
c514 1f d2		        dw game3vs 
c516				 
c516 69 cf			dw game2b 
c518 d7 cf			dw game2bf 
c51a 21 d0			dw game2mba 
c51c b7 d0			dw game2mbas 
c51e f9 d0			dw game2mb 
c520			 
c520 2a cc			dw game1 
c522 3b cc			dw game1a 
c524 9d cc			dw game1b 
c526 d2 cc			dw game1c 
c528 08 cd			dw game1d 
c52a 39 cd			dw game1s 
c52c 4d cd			dw game1t 
c52e 62 cd			dw game1f 
c530 96 cd			dw game1z 
c532 da cd			dw game1zz 
c534			 
c534 20 cb			dw test5 
c536 58 cb			dw test6 
c538 90 cb			dw test7 
c53a a4 cb			dw test8 
c53c d0 cb			dw test9 
c53e e6 cb			dw test10 
c540				 
c540 b1 ce		        dw ssv5 
c542 95 ce		        dw ssv4 
c544 79 ce		        dw ssv3 
c546 43 ce		        dw ssv2 
c548 ca ce		        dw ssv1 
c54a 12 cf		        dw ssv1cpm 
c54c			;	dw keyup 
c54c			;	dw keydown 
c54c			;	dw keyleft 
c54c			;	dw keyright 
c54c			;	dw 	keyf1 
c54c			;	dw keyf2 
c54c			;	dw keyf3 
c54c			;	dw keyf4 
c54c			;	dw keyf5 
c54c			;	dw keyf6 
c54c			;	dw keyf7 
c54c			;	dw keyf8 
c54c			;	dw keyf9 
c54c			;	dw keyf10 
c54c			;	dw keyf11 
c54c			;	dw keyf12 
c54c			;	dw keytab 
c54c			;	dw keycr 
c54c			;	dw keyhome 
c54c			;	dw keyend 
c54c			;	dw keybs 
c54c 00 00			db 0, 0	 
c54e			 
c54e			 
c54e			; clear stack  
c54e			 
c54e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c581			 
c581			; type ( addr count - ) 
c581 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c5a5			 
c5a5			; some direct memory words 
c5a5			; strncpy ( len t f -- t ) 
c5a5			 
c5a5 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c606			 
c606 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c618 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c62b			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c62b .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c683 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c6e3			 
c6e3			 
c6e3			; a handy word to list items on the stack 
c6e3			 
c6e3 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c742			 
c742			 
c742			; test stack  
c742			; rnd8 stest 
c742			 
c742 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c7b9			 
c7b9			; random malloc and free cycles 
c7b9			 
c7b9 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c86e			 
c86e			; fixed malloc and free cycles 
c86e			 
c86e .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c911			 
c911			; fixed double string push and drop cycle  
c911			 
c911 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
c9c6			 
c9c6			; consistent fixed string push and drop cycle  
c9c6			 
c9c6 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ca6a			 
ca6a .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb20			 
cb20			;test1:		db ": aa 1 2 3 ;", 0 
cb20			;test2:     	db "111 aa 888 999",0 
cb20			;test3:     	db ": bb 77 ;",0 
cb20			;test4:     	db "$02 $01 do i . loop bb",0 
cb20			 
cb20 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cb58 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cb90 .. 00		test7:     	db ": box hline vline ;",0 
cba4 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cbd0 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cbe6 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cc0b .. 00		test11:     	db "hello create .",0 
cc1a .. 00		test12:     	db "hello2 create .",0 
cc2a			 
cc2a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cc2a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cc2a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cc2a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cc2a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cc2a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cc2a			 
cc2a			;iftest1:     	db "$0001 IF cls .",0 
cc2a			;iftest2:     	db "$0000 IF cls .",0 
cc2a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cc2a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cc2a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cc2a			 
cc2a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc2a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc2a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc2a			 
cc2a			 
cc2a			 
cc2a			; a small guess the number game 
cc2a			 
cc2a .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cc3b .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cc9d			 
cc9d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
ccd2 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cd08 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cd39 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cd4d .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cd62 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cd96 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cdda			 
cdda			; Using 'ga' save a high score across multiple runs using external storage 
cdda			 
cdda .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
ce43			 
ce43			 
ce43			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
ce43			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce43			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce43			 
ce43			; simple screen saver to test code memory reuse to destruction 
ce43			 
ce43 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
ce79 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
ce95 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
ceb1 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
ceca .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cf12 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
cf69			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
cf69			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
cf69			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
cf69			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
cf69			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
cf69			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
cf69			 
cf69			 
cf69			 
cf69			; minesweeper/battleship finding game 
cf69			; draws a game board of random ship/mine positions 
cf69			; user enters coords to see if it hits on 
cf69			; game ends when all are hit 
cf69			; when hit or miss says how many may be in the area 
cf69			 
cf69			; setup the game board and then hide it 
cf69 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
cfd7 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d021			; prompt for where to target 
d021 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d0b7 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d0dc			; TODO see if the entered coords hits or misses pushes char hit of miss 
d0dc .. 00		game2mbht:      db ": mbckht nop ;",0 
d0eb .. 00		game2mbms:      db ": mbcms nop ;",0 
d0f9			; TODO how many might be near by 
d0f9 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d176			 
d176			; Game 3 
d176			 
d176			; Vert scroller ski game - avoid the trees! 
d176			 
d176			; v0 score (ie turns) 
d176			; v1 player pos 
d176			; v2 left wall 
d176			; v3 right wall 
d176			 
d176			; Draw side walls randomly 
d176			 
d176 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d1a4			 
d1a4			; Draw player 
d1a4 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d1c2			 
d1c2			; TODO Get Key 
d1c2			 
d1c2			; TODO Move left right 
d1c2			 
d1c2			; scroll and move walls a bit 
d1c2			 
d1c2 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d1f3			 
d1f3			; main game loop 
d1f3			 
d1f3 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d21f .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d25e			 
d25e			; key board defs 
d25e			 
d25e .. 00		keyup:       db ": keyup $05 ;",0 
d26c .. 00		keydown:       db ": keydown $0a ;",0 
d27c .. 00		keyleft:       db ": keyleft $0b ;",0 
d28c .. 00		keyright:       db ": keyright $0c ;",0 
d29d .. 00		keyf1:       db ": keyf1 $10 ;",0 
d2ab .. 00		keyf2:       db ": keyf2 $11 ;",0 
d2b9 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d2c7 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d2d5 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d2e3 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d2f1 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d2ff .. 00		keyf8:       db ": keyf8 $17 ;",0 
d30d .. 00		keyf9:       db ": keyf9 $18 ;",0 
d31b .. 00		keyf10:       db ": keyf10 $19 ;",0 
d32a .. 00		keyf11:       db ": keyf11 $1a ;",0 
d339 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d348			 
d348 .. 00		keytab:       db ": keytab $09 ;",0 
d357 .. 00		keycr:       db ": keycr $0d ;",0 
d365 .. 00		keyhome:       db ": keyhome $0e ;",0 
d375 .. 00		keyend:       db ": keyend $0f ;",0 
d384 .. 00		keybs:       db ": keybs $08 ;",0 
d392			 
d392			   
d392			 
d392			 
d392			 
d392			; eof 
# End of file forth_autostart.asm
d392			 
d392 .. 00		sprompt1: db "Startup load...",0 
d3a2 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d3b8			 
d3b8			 
d3b8			 
d3b8			 
d3b8			forth_startup: 
d3b8 21 f0 c4			ld hl, startcmds 
d3bb 3e 00			ld a, 0 
d3bd 32 0c e9			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d3c0			 
d3c0 e5			.start1:	push hl 
d3c1 cd 7a 88			call clear_display 
d3c4 11 92 d3			ld de, sprompt1 
d3c7 3e 00		        ld a, display_row_1 
d3c9 cd 8d 88			call str_at_display 
d3cc 11 a2 d3			ld de, sprompt2 
d3cf 3e 14		        ld a, display_row_2 
d3d1 cd 8d 88			call str_at_display 
d3d4 e1				pop hl 
d3d5 e5				push hl 
d3d6 5e				ld e,(hl) 
d3d7 23				inc hl 
d3d8 56				ld d,(hl) 
d3d9 3e 28		        ld a, display_row_3 
d3db cd 8d 88			call str_at_display 
d3de cd 9d 88			call update_display 
d3e1			 
d3e1			 
d3e1 3a 0c e9			ld a, (os_last_cmd) 
d3e4 fe 00			cp 0 
d3e6 28 05			jr z, .startprompt 
d3e8 cd ee 87			call delay250ms 
d3eb 18 24			jr .startdo 
d3ed				 
d3ed				 
d3ed			 
d3ed			.startprompt: 
d3ed			 
d3ed 3e 4f			ld a,display_row_4 + display_cols - 1 
d3ef 11 24 98		        ld de, endprg 
d3f2 cd 8d 88			call str_at_display 
d3f5 cd 9d 88			call update_display 
d3f8 cd fa 87			call delay1s 
d3fb cd 1e d7			call cin_wait 
d3fe						 
d3fe fe 2a			cp '*' 
d400 28 5e			jr z, .startupend1 
d402 fe 23			cp '#' 
d404 20 07			jr nz, .startno 
d406 3e 01			ld a, 1 
d408 32 0c e9			ld (os_last_cmd),a 
d40b 18 04			jr .startdo 
d40d fe 31		.startno:	cp '1' 
d40f 28 3a			jr z,.startnxt  
d411			 
d411				; exec startup line 
d411			.startdo:	 
d411 e1				pop hl 
d412 e5				push hl 
d413				 
d413 5e				ld e,(hl) 
d414 23				inc hl 
d415 56				ld d,(hl) 
d416 eb				ex de,hl 
d417			 
d417 e5				push hl 
d418			 
d418 3e 00			ld a, 0 
d41a				;ld a, FORTH_END_BUFFER 
d41a cd 10 8f			call strlent 
d41d 23				inc hl   ; include zero term to copy 
d41e 06 00			ld b,0 
d420 4d				ld c,l 
d421 e1				pop hl 
d422 11 e6 e4			ld de, scratch 
d425 ed b0			ldir 
d427			 
d427			 
d427 21 e6 e4			ld hl, scratch 
d42a cd 65 9c			call forthparse 
d42d cd a5 9c			call forthexec 
d430 cd bc 9b			call forthexec_cleanup 
d433			 
d433 3e 3c			ld a, display_row_4 
d435 11 c8 95			ld de, endprog 
d438			 
d438 cd 9d 88			call update_display		 
d43b			 
d43b 3a 0c e9			ld a, (os_last_cmd) 
d43e fe 00			cp 0 
d440 20 09			jr nz, .startnxt 
d442 cd 26 98			call next_page_prompt 
d445 cd 7a 88		        call clear_display 
d448 cd 9d 88			call update_display		 
d44b			 
d44b				; move onto next startup line? 
d44b			.startnxt: 
d44b			 
d44b cd ee 87			call delay250ms 
d44e e1				pop hl 
d44f			 
d44f 23				inc hl 
d450 23				inc hl 
d451			 
d451 e5				push hl 
d452 5e				ld e, (hl) 
d453 23				inc hl 
d454 56				ld d, (hl) 
d455 e1				pop hl 
d456				; TODO replace 0 test 
d456			 
d456 eb				ex de, hl 
d457 cd d0 8a			call ishlzero 
d45a			;	ld a,e 
d45a			;	add d 
d45a			;	cp 0    ; any left to do? 
d45a eb				ex de, hl 
d45b c2 c0 d3			jp nz, .start1 
d45e 18 01			jr .startupend 
d460			 
d460 e1			.startupend1: pop hl 
d461			.startupend: 
d461			 
d461 cd 7a 88			call clear_display 
d464 cd 9d 88			call update_display 
d467 c9				ret 
d468			 
d468			 
d468			; stack over and underflow checks 
d468			 
d468			; init the words to detect the under/overflow 
d468			 
d468			chk_stk_init: 
d468				; a vague random number to check so we dont get any "lucky" hits 
d468 3e 2d			ld a, 45 
d46a 6f				ld l, a 
d46b 00				nop 
d46c 3e 17			ld a, 23 
d46e 67				ld h, a 
d46f			 
d46f 22 cd e4			ld (chk_word), hl     ; the word we need to check against 
d472			 
d472			;	ld (chk_stund), hl	; stack points.... 
d472 22 00 ef			ld (chk_stovr), hl 
d475 22 91 ec			ld (chk_ret_und), hl 
d478 22 4f ec			ld (chk_ret_ovr), hl 
d47b 22 4d eb			ld (chk_loop_ovr), hl 
d47e 22 4b ea			ld (chk_data_ovr), hl 
d481 c9				ret 
d482				 
d482			check_stacks: 
d482				; check all stack words 
d482			 
d482 e5				push hl 
d483 d5				push de 
d484			 
d484			;	ld de,(chk_word) 
d484			;	ld hl, (chk_stund)	; stack points.... 
d484			;	if DEBUG_STK_FAULT 
d484			;		DMARK "FAa" 
d484			;		CALLMONITOR 
d484			;	endif 
d484			;	call cmp16 
d484			;	jp z, .chk_faulta 
d484			; 
d484			;	ld de, sfaultsu 
d484			;	jp .chk_fault 
d484			 
d484 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d487 ed 5b cd e4		ld de,(chk_word) 
d48b				if DEBUG_STK_FAULT 
d48b					DMARK "FAb" 
d48b					CALLMONITOR 
d48b				endif 
d48b cd c5 8a			call cmp16 
d48e 28 06			jr z, .chk_fault1 
d490 11 31 d5			ld de, sfaultso 
d493 c3 e5 d4			jp .chk_fault 
d496			.chk_fault1:  
d496 2a 91 ec			ld hl, (chk_ret_und) 
d499 ed 5b cd e4		ld de,(chk_word) 
d49d				if DEBUG_STK_FAULT 
d49d					DMARK "FAU" 
d49d					CALLMONITOR 
d49d				endif 
d49d cd c5 8a			call cmp16 
d4a0 ca a9 d4			jp z, .chk_fault2 
d4a3 11 41 d5			ld de, sfaultru 
d4a6 c3 e5 d4			jp .chk_fault 
d4a9			.chk_fault2:  
d4a9 2a 4f ec			ld hl, (chk_ret_ovr) 
d4ac ed 5b cd e4		ld de,(chk_word) 
d4b0				if DEBUG_STK_FAULT 
d4b0					DMARK "FA1" 
d4b0					CALLMONITOR 
d4b0				endif 
d4b0 cd c5 8a			call cmp16 
d4b3 ca bc d4			jp z, .chk_fault3 
d4b6 11 4f d5			ld de, sfaultro 
d4b9 c3 e5 d4			jp .chk_fault 
d4bc			.chk_fault3:  
d4bc 2a 4d eb			ld hl, (chk_loop_ovr) 
d4bf ed 5b cd e4		ld de,(chk_word) 
d4c3				if DEBUG_STK_FAULT 
d4c3					DMARK "FA2" 
d4c3					CALLMONITOR 
d4c3				endif 
d4c3 cd c5 8a			call cmp16 
d4c6 ca cf d4			jp z, .chk_fault4 
d4c9 11 69 d5			ld de, sfaultlo 
d4cc c3 e5 d4			jp .chk_fault 
d4cf			.chk_fault4:  
d4cf 2a 4b ea			ld hl, (chk_data_ovr) 
d4d2 ed 5b cd e4		ld de,(chk_word) 
d4d6				if DEBUG_STK_FAULT 
d4d6					DMARK "FA3" 
d4d6					CALLMONITOR 
d4d6				endif 
d4d6 cd c5 8a			call cmp16 
d4d9 ca e2 d4			jp z, .chk_fault5 
d4dc 11 83 d5			ld de, sfaultdo 
d4df c3 e5 d4			jp .chk_fault 
d4e2			 
d4e2			 
d4e2			.chk_fault5:  
d4e2 d1				pop de 
d4e3 e1				pop hl 
d4e4			 
d4e4 c9				ret 
d4e5			 
d4e5 cd 7a 88		.chk_fault: 	call clear_display 
d4e8 3e 14				ld a, display_row_2 
d4ea cd 8d 88				call str_at_display 
d4ed 11 13 d5				   ld de, .stackfault 
d4f0 3e 00				ld a, display_row_1 
d4f2 cd 8d 88				call str_at_display 
d4f5 11 c0 ee				    ld de, debug_mark 
d4f8 3e 11				ld a, display_row_1+17 
d4fa cd 8d 88				call str_at_display 
d4fd cd 9d 88				call update_display 
d500			 
d500				; prompt before entering montior for investigating issue 
d500			 
d500 3e 3c			ld a, display_row_4 
d502 11 c8 95			ld de, endprog 
d505			 
d505 cd 9d 88			call update_display		 
d508			 
d508 cd 26 98			call next_page_prompt 
d50b			 
d50b d1				pop de 
d50c e1				pop hl 
d50d cd 1c 96				call monitor 
d510 c3 16 95				jp warmstart 
d513					;jp 0 
d513					;halt 
d513			 
d513			 
d513			 
d513 .. 00		.stackfault: 	db "Stack fault:",0 
d520			 
d520 .. 00		sfaultsu: 	db	"Stack under flow",0 
d531 .. 00		sfaultso: 	db	"Stack over flow",0 
d541 .. 00		sfaultru:	db "RTS underflow",0 
d54f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d569 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d583 .. 00		sfaultdo:	db "DTS overflow", 0 
d590			 
d590			 
d590			fault_dsp_under: 
d590 11 a2 d5			ld de, .dsp_under 
d593 c3 52 d6			jp .show_fault 
d596			 
d596			fault_rsp_under: 
d596 11 b0 d5			ld de, .rsp_under 
d599 c3 52 d6			jp .show_fault 
d59c			fault_loop_under: 
d59c 11 be d5			ld de, .loop_under 
d59f c3 52 d6			jp .show_fault 
d5a2			 
d5a2 .. 00		.dsp_under: db "DSP Underflow",0 
d5b0 .. 00		.rsp_under: db "RSP Underflow",0 
d5be .. 00		.loop_under: db "LOOP Underflow",0 
d5cd			 
d5cd			 
d5cd d5			type_faultn: 	push de 
d5ce e5					push hl 
d5cf cd 7a 88				call clear_display 
d5d2 11 f9 d5				   ld de, .typefaultn 
d5d5 3e 00				ld a, display_row_1 
d5d7 cd 8d 88				call str_at_display 
d5da 11 c0 ee				    ld de, debug_mark 
d5dd 3e 11				ld a, display_row_1+17 
d5df cd 8d 88				call str_at_display 
d5e2 cd 9d 88				call update_display 
d5e5			 
d5e5				; prompt before entering montior for investigating issue 
d5e5			 
d5e5 3e 3c			ld a, display_row_4 
d5e7 11 c8 95			ld de, endprog 
d5ea			 
d5ea cd 9d 88			call update_display		 
d5ed			 
d5ed cd 26 98			call next_page_prompt 
d5f0			 
d5f0 e5					push hl 
d5f1 d5					push de 
d5f2 cd 1c 96				call monitor 
d5f5 c3 16 95				jp warmstart 
d5f8 76					halt 
d5f9			 
d5f9			 
d5f9 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d610			 
d610 d5			type_faults: 	push de 
d611 e5					push hl 
d612 cd 7a 88				call clear_display 
d615 11 3b d6				   ld de, .typefaults 
d618 3e 00				ld a, display_row_1 
d61a cd 8d 88				call str_at_display 
d61d 11 c0 ee				    ld de, debug_mark 
d620 3e 11				ld a, display_row_1+17 
d622 cd 8d 88				call str_at_display 
d625 cd 9d 88				call update_display 
d628			 
d628				; prompt before entering montior for investigating issue 
d628			 
d628 3e 3c			ld a, display_row_4 
d62a 11 c8 95			ld de, endprog 
d62d			 
d62d cd 9d 88			call update_display		 
d630			 
d630 cd 26 98			call next_page_prompt 
d633			 
d633 e1					pop hl 
d634 d1					pop de 
d635 cd 1c 96				call monitor 
d638 c3 16 95				jp warmstart 
d63b			 
d63b			 
d63b .. 00		.typefaults: db "STR Type Expected TOS!",0 
d652			 
d652			.show_fault: 	 
d652 d5					push de 
d653 cd 7a 88				call clear_display 
d656 d1					pop de 
d657 3e 00				ld a, display_row_1 
d659 cd 8d 88				call str_at_display 
d65c 11 c0 ee				    ld de, debug_mark 
d65f 3e 11				ld a, display_row_1+17 
d661 cd 8d 88				call str_at_display 
d664 cd 9d 88				call update_display 
d667			 
d667				; prompt before entering montior for investigating issue 
d667			 
d667 3e 3c			ld a, display_row_4 
d669 11 c8 95			ld de, endprog 
d66c			 
d66c cd 9d 88			call update_display		 
d66f			 
d66f cd 26 98			call next_page_prompt 
d672			 
d672 e1					pop hl 
d673 d1					pop de 
d674 cd 1c 96				call monitor 
d677			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d677			; TODO Make optional fault restart to cli or warm boot? 
d677					;jp warmstart 
d677 c3 6e 95				jp cli 
d67a 76					halt 
d67b			 
d67b			; handle the auto run of code from files in storage 
d67b			 
d67b			 
d67b			if STORAGE_SE 
d67b			 
d67b			sprompt3: db "Loading from start-up file?:",0 
d67b			sprompt4: db "(Y=Any key/N=No)",0 
d67b			 
d67b			 
d67b			forth_autoload: 
d67b			 
d67b				; load block 0 of store 1 
d67b				 
d67b				ld a, $fe      ; bit 0 clear 
d67b				ld (spi_device), a 
d67b			 
d67b				call storage_get_block_0 
d67b			 
d67b				ld a, (store_page+STORE_0_AUTOFILE) 
d67b			 
d67b				cp 0 
d67b				ret z     ; auto start not enabled 
d67b			 
d67b				call clear_display 
d67b			 
d67b				; set bank 
d67b			 
d67b					ld a, (store_page+STORE_0_BANKRUN) 
d67b					ld (spi_device), a 
d67b			 
d67b				; get file id to load from and get the file name to display 
d67b			 
d67b					ld a, (store_page+STORE_0_FILERUN) 
d67b			 
d67b					ld l, 0 
d67b					ld h, a 
d67b					ld de, store_page 
d67b			 
d67b					if DEBUG_FORTH_WORDS 
d67b						DMARK "ASp" 
d67b						CALLMONITOR 
d67b					endif 
d67b					call storage_read 
d67b			 
d67b					if DEBUG_FORTH_WORDS 
d67b						DMARK "ASr" 
d67b						CALLMONITOR 
d67b					endif 
d67b			 
d67b					call ishlzero 
d67b					ret z             ; file not found 
d67b			 
d67b					ld a, display_row_2 + 10 
d67b					ld de, store_page+3 
d67b					call str_at_display 
d67b				 
d67b			; 
d67b			 
d67b				ld a, display_row_1+5 
d67b				ld de, sprompt3 
d67b				call str_at_display 
d67b				ld a, display_row_3+15 
d67b				ld de, sprompt4 
d67b				call str_at_display 
d67b			 
d67b				call update_display 
d67b			 
d67b				call cin_wait 
d67b				cp 'n' 
d67b				ret z 
d67b				cp 'N' 
d67b				ret z 
d67b			 
d67b				call delay1s 
d67b			 
d67b				ld a, (store_page+2) 
d67b				ld (store_openmaxext), a    ; save count of ext 
d67b				ld a, 1  
d67b				ld (store_openext), a    ; save count of ext 
d67b			 
d67b			.autof:  
d67b				ld l , a 
d67b				 
d67b				ld a, (store_page) 
d67b				ld h, a	 
d67b				ld de, store_page 
d67b					if DEBUG_FORTH_WORDS 
d67b						DMARK "ASl" 
d67b						CALLMONITOR 
d67b					endif 
d67b					call storage_read 
d67b				call ishlzero 
d67b				ret z 
d67b			 
d67b					if DEBUG_FORTH_WORDS 
d67b						DMARK "ASc" 
d67b						CALLMONITOR 
d67b					endif 
d67b				ld de, store_page+2 
d67b				ld a, display_row_4 
d67b				call str_at_display 
d67b			 
d67b				call update_display 
d67b				call delay250ms 
d67b			 
d67b			 
d67b			 
d67b				ld hl, store_page+2 
d67b				call forthparse 
d67b				call forthexec 
d67b				call forthexec_cleanup 
d67b			 
d67b				 
d67b				ld a, (store_openext) 
d67b				inc a 
d67b				ld (store_openext), a    ; save count of ext 
d67b			 
d67b				jr .autof 
d67b			 
d67b			;.autofdone: 
d67b			; 
d67b			;		if DEBUG_FORTH_WORDS 
d67b			;			DMARK "ASx" 
d67b			;			CALLMONITOR 
d67b			;		endif 
d67b			;;	call clear_display 
d67b			;	ret 
d67b			 
d67b			 
d67b			 
d67b			endif 
d67b			 
d67b			 
d67b			; eof 
# End of file forth_kernel.asm
d67b			;include "nascombasic.asm" 
d67b			 
d67b			 
d67b			; find out where the code ends if loaded into RAM (for SC114) 
d67b			;endofcode:  
d67b			;	nop 
d67b			 
d67b			 
d67b			; eof 
d67b			 
# End of file main.asm
d67b			;include "firmware_lcd_4x20.asm" 
d67b			;include "firmware_key_4x4.asm" 
d67b			include "firmware_serial_display.asm" 
d67b			 
d67b			; Serial display interface for SC114 
d67b			 
d67b			 
d67b			display_row_1: equ 0 
d67b			display_row_2: equ display_row_1+display_cols 
d67b			display_row_3: equ display_row_2 + display_cols 
d67b			display_row_4: equ display_row_3 + display_cols 
d67b			 
d67b			kLCDWidth:  EQU display_cols             ;Width in characters 
d67b			kLCD_Line1: EQU 0x00  
d67b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d67b			; E1 
d67b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d67b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d67b			 
d67b			lcd_init: 
d67b				; no init as handled by the SCM bios 
d67b c9				ret 
d67c			 
d67c			 
d67c			; low level functions for direct screen writes 
d67c			 
d67c			; output char at pos? 
d67c			fLCD_Str: 
d67c			        ;out (SC114_SIO_1_OUT),a 
d67c c5				push bc 
d67d 0e 02			ld c, $02 
d67f f7				rst $30 
d680 c1				pop bc 
d681 c9				ret 
d682			 
d682			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d682			fLCD_Pos: 
d682				; use ASCII escape to position 
d682			        ;out (SC114_SIO_1_OUT),a 
d682 c5				push bc 
d683 0e 02			ld c, $02 
d685 f7				rst $30 
d686 c1				pop bc 
d687			 
d687 c9				ret 
d688			 
d688			; output char at pos 
d688			fLCD_Data: 
d688			      ;  out (SC114_SIO_1_OUT),a 
d688 c5				push bc 
d689 0e 02			ld c, $02 
d68b f7				rst $30 
d68c c1				pop bc 
d68d			 
d68d c9				ret 
d68e			 
d68e			; ascii cls  
d68e			 
d68e 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d692			 
d692			; write the frame buffer given in hl to hardware  
d692			write_display: 
d692			 
d692			API: equ 0 
d692			 
d692			if API 
d692				push bc 
d692				ld b, 4 
d692			 
d692			        ld (display_write_tmp), hl 	  
d692			 
d692				; clear and home cursor 
d692			 
d692				ld c, 6 
d692				ld de, .cls 
d692				rst $30 
d692			 
d692			 
d692			.writeln: 
d692			 
d692				ld de, (display_write_tmp) 
d692				ld c, 6 
d692				rst $30 
d692				ld c, 7 
d692				rst $30 
d692			 
d692				ld hl, (display_write_tmp) 
d692				ld de, display_cols 
d692				add hl,de 
d692				ld (display_write_tmp),hl 
d692			 
d692				djnz  .writeln 
d692			 
d692				pop bc 
d692			 
d692			 
d692				ret 
d692			endif 
d692 e5				push hl 
d693 c5				push bc 
d694 d5				push de 
d695			 
d695			;	ld c, 2 
d695			;	;ld de, .cls 
d695			;	ld a, 27 
d695			;	rst $30 
d695			;	ld c, 2 
d695			;	;ld de, .cls 
d695			;	ld a, '[' 
d695			;	rst $30 
d695			; 
d695			;	ld c, 2 
d695			;	;ld de, .cls 
d695			;	ld a, 'H' 
d695			;	rst $30 
d695			; 
d695			 
d695 0e 02			ld c, 2 
d697				;ld de, .cls 
d697 3e 1b			ld a, 27 
d699 f7				rst $30 
d69a			 
d69a			 
d69a 0e 02			ld c, 2 
d69c				;ld de, .cls 
d69c 3e 5b			ld a, '[' 
d69e f7				rst $30 
d69f 0e 02			ld c, 2 
d6a1				;ld de, .cls 
d6a1 3e 32			ld a, '2' 
d6a3 f7				rst $30 
d6a4 0e 02			ld c, 2 
d6a6				;ld de, .cls 
d6a6 3e 4a			ld a, 'J' 
d6a8 f7				rst $30 
d6a9 d1				pop de 
d6aa c1				pop bc 
d6ab e1				pop hl 
d6ac			 
d6ac			 
d6ac 22 5e ed		        ld (display_write_tmp), hl 	  
d6af 3e 00			ld a, kLCD_Line1 
d6b1			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d6b1 06 14			ld b, display_cols 
d6b3 ed 5b 5e ed		ld de, (display_write_tmp) 
d6b7 cd 15 d7			call write_len_string 
d6ba				 
d6ba			 
d6ba e5			push hl 
d6bb d5			push de 
d6bc c5			push bc 
d6bd 0e 07			ld c, 7 
d6bf f7				rst $30 
d6c0 c1			pop bc 
d6c1 d1			pop de 
d6c2 e1			pop hl 
d6c3			 
d6c3				 
d6c3 2a 5e ed			ld hl, (display_write_tmp) 
d6c6 11 14 00			ld de, display_cols 
d6c9 19				add hl,de 
d6ca 22 5e ed			ld (display_write_tmp),hl 
d6cd			 
d6cd				 
d6cd 3e 14			ld a, kLCD_Line2 
d6cf			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d6cf 06 14			ld b, display_cols 
d6d1 ed 5b 5e ed		ld de, (display_write_tmp) 
d6d5 cd 15 d7			call write_len_string 
d6d8				 
d6d8 2a 5e ed			ld hl, (display_write_tmp) 
d6db 11 14 00			ld de, display_cols 
d6de 19				add hl,de 
d6df 22 5e ed			ld (display_write_tmp),hl 
d6e2			 
d6e2 e5			push hl 
d6e3 d5			push de 
d6e4 c5			push bc 
d6e5 0e 07			ld c, 7 
d6e7 f7				rst $30 
d6e8 c1			pop bc 
d6e9 d1			pop de 
d6ea e1			pop hl 
d6eb			 
d6eb				 
d6eb 3e 28			ld a, kLCD_Line3 
d6ed			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d6ed 06 14			ld b, display_cols 
d6ef ed 5b 5e ed		ld de, (display_write_tmp) 
d6f3 cd 15 d7			call write_len_string 
d6f6				 
d6f6 2a 5e ed			ld hl, (display_write_tmp) 
d6f9 11 14 00			ld de, display_cols 
d6fc 19				add hl,de 
d6fd 22 5e ed			ld (display_write_tmp),hl 
d700			 
d700 e5			push hl 
d701 d5			push de 
d702 c5			push bc 
d703 0e 07			ld c, 7 
d705 f7				rst $30 
d706 c1			pop bc 
d707 d1			pop de 
d708 e1			pop hl 
d709			 
d709				 
d709 3e 3c			ld a, kLCD_Line4 
d70b			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d70b 06 14			ld b, display_cols 
d70d ed 5b 5e ed		ld de, (display_write_tmp) 
d711 cd 15 d7			call write_len_string 
d714 c9					ret 
d715			 
d715			 
d715				; write out a fixed length string given in b from de 
d715			 
d715 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d716 cd 88 d6		            CALL fLCD_Data      ;Write character to display 
d719 13				inc de 
d71a 10 f9			djnz write_len_string 
d71c c9				ret 
d71d			 
d71d			 
d71d			; eof 
# End of file firmware_serial_display.asm
d71d			include "firmware_key_serial.asm" 
d71d			; Serial keyboard interface for SC114 
d71d			 
d71d			key_init: 
d71d				; no init as handled by the SCM bios 
d71d c9				ret 
d71e			 
d71e			 
d71e			cin_wait: 
d71e			;	ld a, 0 
d71e			;	ret 
d71e			 
d71e				;in a,(SC114_SIO_1_IN) 
d71e			        ; Use SCM API to get from whatever console device we are using 
d71e c5				push bc 
d71f 0e 01			ld c, $01 
d721 f7				rst $30 
d722 c1				pop bc 
d723 c9				ret 
d724			 
d724			cin: 
d724			 
d724			 
d724 c5				push bc 
d725			 
d725				; any key waiting to process? 
d725 0e 03			ld c, $03 
d727 f7				rst $30 
d728 28 05			jr z, .cin_skip 
d72a			 
d72a				; yep, get it 
d72a			 
d72a 0e 01			ld c, $01 
d72c f7				rst $30 
d72d c1				pop bc 
d72e c9				ret 
d72f			.cin_skip: 
d72f 3e 00			ld a, 0 
d731 c1				pop bc 
d732 c9				ret 
d733			 
d733			 
d733			 
d733			 
# End of file firmware_key_serial.asm
d733			 
d733			baseram:  
d733			endofcode: 
d733 00				nop 
d734			 
d734			heap_start: equ baseram+15  ; Starting address of heap 
d734			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d734			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d734			; 
d734			 
# End of file os_mini_sc114.asm
d734
