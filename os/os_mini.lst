# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 c0 17			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3c holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_FILERUN: equ $3c  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $3c  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd 94 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd 94 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd 94 0a				call clear_display  
0023			  
0023			  
0023 cd 06 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 4f 65			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd 6b 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd b7 0a			call update_display  
0032 cd 42 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd 99 0a			call fill_display  
003a cd b7 0a			call update_display  
003d cd 42 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd 99 0a			call fill_display  
0045 cd b7 0a			call update_display  
0048 cd 42 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd 99 0a			call fill_display  
0050 cd b7 0a			call update_display  
0053 cd 42 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd a7 0a			call str_at_display  
005e cd b7 0a			call update_display  
0061			  
0061			  
0061 cd 42 0a			call delay1s  
0064 cd 42 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd a7 0a			call str_at_display  
006f cd b7 0a			call update_display  
0072 cd 42 0a			call delay1s  
0075 cd 42 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 27 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 27 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd 7f 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd ea 15			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd ea 15			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 27 06			call storage_findnextid 
035d			 
035d cd f1 0c			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd ea 15			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd ea 15			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd ea 15			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd ea 15			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd ea 15			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 21 e8 f9			ld hl, store_page 
042b 3e 00			ld a, 0 
042d				 
042d 77				ld (hl),a   ; reset file counter 
042e			 
042e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0431 22 e9 f9		 	ld (store_page+1), hl	 
0434			 
0434				; set default label 
0434			 
0434 21 d0 04			ld hl, .defaultbanklabl 
0437 11 eb f9		 	ld de, store_page+3 
043a 01 0f 00			ld bc, 15 
043d ed b0			ldir 
043f			 
043f				; Append the current bank id 
043f 21 f4 f9			ld hl, store_page+3+9 
0442 3a cd f9			ld a, (spi_device_id) 
0445 77				ld (hl), a 
0446			 
0446				; save default page 0 
0446			 
0446 21 00 00			ld hl, 0 
0449 11 e8 f9			ld de, store_page 
044c				if DEBUG_STORESE 
044c					DMARK "SB3" 
044c f5				push af  
044d 3a 61 04			ld a, (.dmark)  
0450 32 bd fb			ld (debug_mark),a  
0453 3a 62 04			ld a, (.dmark+1)  
0456 32 be fb			ld (debug_mark+1),a  
0459 3a 63 04			ld a, (.dmark+2)  
045c 32 bf fb			ld (debug_mark+2),a  
045f 18 03			jr .pastdmark  
0461 ..			.dmark: db "SB3"  
0464 f1			.pastdmark: pop af  
0465			endm  
# End of macro DMARK
0465			;		push af 
0465			;		ld a, 'F' 
0465			;		ld (debug_mark),a 
0465			;		pop af 
0465					CALLMONITOR 
0465 cd ea 15			call break_point_state  
0468				endm  
# End of macro CALLMONITOR
0468				endif 
0468 cd 6e 03			call storage_write_block 
046b				if DEBUG_STORESE 
046b					DMARK "SB4" 
046b f5				push af  
046c 3a 80 04			ld a, (.dmark)  
046f 32 bd fb			ld (debug_mark),a  
0472 3a 81 04			ld a, (.dmark+1)  
0475 32 be fb			ld (debug_mark+1),a  
0478 3a 82 04			ld a, (.dmark+2)  
047b 32 bf fb			ld (debug_mark+2),a  
047e 18 03			jr .pastdmark  
0480 ..			.dmark: db "SB4"  
0483 f1			.pastdmark: pop af  
0484			endm  
# End of macro DMARK
0484			;		push af 
0484			;		ld a, '>' 
0484			;		ld (debug_mark),a 
0484			;		pop af 
0484					CALLMONITOR 
0484 cd ea 15			call break_point_state  
0487				endm  
# End of macro CALLMONITOR
0487				endif 
0487			 
0487 00				nop 
0488 00				nop 
0489 00				nop 
048a			 
048a				; now set 0 in every page to mark as a free block 
048a			 
048a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048c 21 40 00			ld hl, STORE_BLOCK_PHY 
048f			 
048f 3e 00		.setmark1:   	ld a,0 
0491 e5					push hl 
0492 c5					push bc 
0493 cd e7 01				call se_writebyte 
0496 3e 0a			ld a, 10 
0498 cd 27 0a			call aDelayInMS 
049b 23				inc hl 
049c cd e7 01				call se_writebyte 
049f 3e 0a			ld a, 10 
04a1 cd 27 0a			call aDelayInMS 
04a4 2b				dec hl 
04a5 c1					pop bc 
04a6 e1					pop hl 
04a7 3e 40				ld a, STORE_BLOCK_PHY 
04a9 cd c8 0c				call addatohl 
04ac 10 e1				djnz .setmark1 
04ae			 
04ae 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b0 3e 00		.setmark2:   	ld a,0 
04b2 e5					push hl 
04b3 c5					push bc 
04b4 cd e7 01				call se_writebyte 
04b7 3e 0a			ld a, 10 
04b9 cd 27 0a			call aDelayInMS 
04bc 23				inc hl 
04bd cd e7 01				call se_writebyte 
04c0 3e 0a			ld a, 10 
04c2 cd 27 0a			call aDelayInMS 
04c5 2b				dec hl 
04c6 c1					pop bc 
04c7 e1					pop hl 
04c8 3e 40				ld a, STORE_BLOCK_PHY 
04ca cd c8 0c				call addatohl 
04cd 10 e1				djnz .setmark2 
04cf			 
04cf					 
04cf			 
04cf			 
04cf c9				ret 
04d0			 
04d0			 
04d0			 
04d0			 
04d0 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04db			 
04db			 
04db			 
04db			; Label Bank 
04db			; ---------- 
04db			; 
04db			; With current bank 
04db			; Read block 0 
04db			; Set label 
04db			; Write block 0 
04db			 
04db			; label str pointer in hl 
04db			 
04db			storage_label:     
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "LBL" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 bd fb			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 be fb			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 bf fb			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "LBL"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4					CALLMONITOR 
04f4 cd ea 15			call break_point_state  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7 e5				push hl 
04f8			 
04f8 cd ba 03			call storage_get_block_0 
04fb			 
04fb				; set default label 
04fb			 
04fb e1				pop hl 
04fc			 
04fc 11 eb f9		 	ld de, store_page+3 
04ff 01 0f 00			ld bc, 15 
0502				if DEBUG_STORESE 
0502					DMARK "LB3" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 bd fb			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 be fb			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 bf fb			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "LB3"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					CALLMONITOR 
051b cd ea 15			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e ed b0			ldir 
0520				; save default page 0 
0520			 
0520 21 00 00			ld hl, 0 
0523 11 e8 f9			ld de, store_page 
0526				if DEBUG_STORESE 
0526					DMARK "LBW" 
0526 f5				push af  
0527 3a 3b 05			ld a, (.dmark)  
052a 32 bd fb			ld (debug_mark),a  
052d 3a 3c 05			ld a, (.dmark+1)  
0530 32 be fb			ld (debug_mark+1),a  
0533 3a 3d 05			ld a, (.dmark+2)  
0536 32 bf fb			ld (debug_mark+2),a  
0539 18 03			jr .pastdmark  
053b ..			.dmark: db "LBW"  
053e f1			.pastdmark: pop af  
053f			endm  
# End of macro DMARK
053f					CALLMONITOR 
053f cd ea 15			call break_point_state  
0542				endm  
# End of macro CALLMONITOR
0542				endif 
0542 cd 6e 03			call storage_write_block 
0545			 
0545 c9				ret 
0546			 
0546			 
0546			 
0546			; Read Block 0 - Config 
0546			; --------------------- 
0546			; 
0546			; With current bank 
0546			; Call presence test 
0546			;    If not present format/init bank  
0546			; Read block 0  
0546			;  
0546			 
0546			 
0546			; Dir 
0546			; --- 
0546			; 
0546			; With current bank 
0546			; Load Block 0 Config 
0546			; Get max file id number 
0546			; For each logical block 
0546			;    Read block read byte 2 
0546			;      if first block of file 
0546			;         Display file name 
0546			;         Display type flags for file 
0546			;        
0546			 
0546			; moving to words as this requires stack control 
0546			 
0546			 
0546			; Delete File 
0546			; ----------- 
0546			; 
0546			; With current bank 
0546			; 
0546			; Load Block 0 Config 
0546			; Get max file id number 
0546			; For each logical block 
0546			;    Read block file id 
0546			;      If first block of file and dont have file id 
0546			;         if file to delete 
0546			;         Save file id 
0546			;         Null file id 
0546			;         Write this block back 
0546			;      If file id is one saved 
0546			;         Null file id 
0546			;         Write this block back 
0546			 
0546			storage_erase: 
0546			 
0546				; hl contains the file id 
0546			 
0546 5d				ld e, l 
0547 16 00			ld d, 0 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c					if DEBUG_FORTH_WORDS 
054c						DMARK "ERA" 
054c f5				push af  
054d 3a 61 05			ld a, (.dmark)  
0550 32 bd fb			ld (debug_mark),a  
0553 3a 62 05			ld a, (.dmark+1)  
0556 32 be fb			ld (debug_mark+1),a  
0559 3a 63 05			ld a, (.dmark+2)  
055c 32 bf fb			ld (debug_mark+2),a  
055f 18 03			jr .pastdmark  
0561 ..			.dmark: db "ERA"  
0564 f1			.pastdmark: pop af  
0565			endm  
# End of macro DMARK
0565						CALLMONITOR 
0565 cd ea 15			call break_point_state  
0568				endm  
# End of macro CALLMONITOR
0568					endif 
0568 cd 27 06			call storage_findnextid 
056b			 
056b e5				push hl 
056c			 
056c				; TODO check file not found 
056c			 
056c 11 e8 f9			ld de, store_page 
056f cd 09 03			call storage_read_block 
0572			 
0572					if DEBUG_FORTH_WORDS 
0572						DMARK "ER1" 
0572 f5				push af  
0573 3a 87 05			ld a, (.dmark)  
0576 32 bd fb			ld (debug_mark),a  
0579 3a 88 05			ld a, (.dmark+1)  
057c 32 be fb			ld (debug_mark+1),a  
057f 3a 89 05			ld a, (.dmark+2)  
0582 32 bf fb			ld (debug_mark+2),a  
0585 18 03			jr .pastdmark  
0587 ..			.dmark: db "ER1"  
058a f1			.pastdmark: pop af  
058b			endm  
# End of macro DMARK
058b						CALLMONITOR 
058b cd ea 15			call break_point_state  
058e				endm  
# End of macro CALLMONITOR
058e					endif 
058e 3a e8 f9			ld a, (store_page)	; get file id 
0591 32 e1 f9			ld (store_tmpid), a 
0594			 
0594 3a ea f9			ld a, (store_page+2)    ; get count of extends 
0597 32 e0 f9			ld (store_tmpext), a 
059a			 
059a				; wipe file header 
059a			 
059a e1				pop hl 
059b 3e 00			ld a, 0 
059d 32 e8 f9			ld (store_page), a 
05a0 32 e9 f9			ld (store_page+1),a 
05a3 11 e8 f9			ld de, store_page 
05a6					if DEBUG_FORTH_WORDS 
05a6						DMARK "ER2" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 bd fb			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 be fb			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 bf fb			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "ER2"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf						CALLMONITOR 
05bf cd ea 15			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2					endif 
05c2 cd 6e 03			call storage_write_block 
05c5			 
05c5			 
05c5				; wipe file extents 
05c5			 
05c5 3a e0 f9			ld a, (store_tmpext) 
05c8 47				ld b, a 
05c9			 
05c9			.eraext:	  
05c9 c5				push bc 
05ca			 
05ca 21 40 00			ld hl, STORE_BLOCK_PHY 
05cd 3a e1 f9			ld a,(store_tmpid) 
05d0 5f				ld e, a 
05d1 50				ld d, b	 
05d2					if DEBUG_FORTH_WORDS 
05d2						DMARK "ER3" 
05d2 f5				push af  
05d3 3a e7 05			ld a, (.dmark)  
05d6 32 bd fb			ld (debug_mark),a  
05d9 3a e8 05			ld a, (.dmark+1)  
05dc 32 be fb			ld (debug_mark+1),a  
05df 3a e9 05			ld a, (.dmark+2)  
05e2 32 bf fb			ld (debug_mark+2),a  
05e5 18 03			jr .pastdmark  
05e7 ..			.dmark: db "ER3"  
05ea f1			.pastdmark: pop af  
05eb			endm  
# End of macro DMARK
05eb						CALLMONITOR 
05eb cd ea 15			call break_point_state  
05ee				endm  
# End of macro CALLMONITOR
05ee					endif 
05ee cd 27 06			call storage_findnextid 
05f1			 
05f1 e5				push hl 
05f2 11 e8 f9			ld de, store_page 
05f5 cd 09 03			call storage_read_block 
05f8			 
05f8				; free block	 
05f8			 
05f8 3e 00			ld a, 0 
05fa 32 e8 f9			ld (store_page), a 
05fd 32 e9 f9			ld (store_page+1),a 
0600 11 e8 f9			ld de, store_page 
0603 e1				pop hl 
0604					if DEBUG_FORTH_WORDS 
0604						DMARK "ER4" 
0604 f5				push af  
0605 3a 19 06			ld a, (.dmark)  
0608 32 bd fb			ld (debug_mark),a  
060b 3a 1a 06			ld a, (.dmark+1)  
060e 32 be fb			ld (debug_mark+1),a  
0611 3a 1b 06			ld a, (.dmark+2)  
0614 32 bf fb			ld (debug_mark+2),a  
0617 18 03			jr .pastdmark  
0619 ..			.dmark: db "ER4"  
061c f1			.pastdmark: pop af  
061d			endm  
# End of macro DMARK
061d						CALLMONITOR 
061d cd ea 15			call break_point_state  
0620				endm  
# End of macro CALLMONITOR
0620					endif 
0620 cd 6e 03			call storage_write_block 
0623			 
0623 c1				pop bc 
0624 10 a3			djnz .eraext 
0626			 
0626 c9				ret 
0627			 
0627			 
0627			; Find Free Block 
0627			; --------------- 
0627			; 
0627			; With current bank 
0627			;  
0627			; From given starting logical block 
0627			;    Read block  
0627			;    If no file id 
0627			;         Return block id 
0627			 
0627			 
0627			; hl starting page number 
0627			; hl contains free page number or zero if no pages free 
0627			; e contains the file id to locate 
0627			; d contains the block number 
0627			 
0627			; TODO change to find file id and use zero for free block 
0627			 
0627			storage_findnextid: 
0627			 
0627				; now locate first 0 page to mark as a free block 
0627			 
0627 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0629			;	ld hl, STORE_BLOCK_PHY 
0629			 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNI" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 bd fb			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 be fb			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 bf fb			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNI"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642						CALLMONITOR 
0642 cd ea 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645			.ff1:   	 
0645 e5					push hl 
0646 c5					push bc 
0647 d5					push de 
0648 cd 89 02				call se_readbyte 
064b 5f					ld e,a 
064c 23					inc hl 
064d cd 89 02				call se_readbyte 
0650 57					ld d, a 
0651 e1					pop hl 
0652 e5					push hl 
0653 cd e6 0c				call cmp16 
0656 28 49				jr z, .fffound 
0658			 
0658 d1					pop de 
0659 c1					pop bc 
065a e1					pop hl 
065b			 
065b					; is found? 
065b					;cp e 
065b					;ret z 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd c8 0c				call addatohl 
0660 10 e3				djnz .ff1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.ff2:   	 
0664			 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 89 02				call se_readbyte 
066a 5f					ld e,a 
066b 23					inc hl 
066c cd 89 02				call se_readbyte 
066f 57					ld d, a 
0670			 
0670 e1					pop hl 
0671 e5					push hl 
0672 cd e6 0c				call cmp16 
0675 28 2a				jr z, .fffound 
0677			 
0677 d1					pop de 
0678 c1					pop bc 
0679 e1					pop hl 
067a					; is found? 
067a					;cp e 
067a					;ret z 
067a			 
067a 3e 40				ld a, STORE_BLOCK_PHY 
067c cd c8 0c				call addatohl 
067f 10 e3				djnz .ff2 
0681			 
0681			 
0681					if DEBUG_FORTH_WORDS 
0681					DMARK "FN-" 
0681 f5				push af  
0682 3a 96 06			ld a, (.dmark)  
0685 32 bd fb			ld (debug_mark),a  
0688 3a 97 06			ld a, (.dmark+1)  
068b 32 be fb			ld (debug_mark+1),a  
068e 3a 98 06			ld a, (.dmark+2)  
0691 32 bf fb			ld (debug_mark+2),a  
0694 18 03			jr .pastdmark  
0696 ..			.dmark: db "FN-"  
0699 f1			.pastdmark: pop af  
069a			endm  
# End of macro DMARK
069a					;	push af 
069a					;	ld a, 'n' 
069a					;	ld (debug_mark),a 
069a					;	pop af 
069a						CALLMONITOR 
069a cd ea 15			call break_point_state  
069d				endm  
# End of macro CALLMONITOR
069d					endif 
069d				; no free marks! 
069d 21 00 00				ld hl, 0 
06a0 c9				ret 
06a1			.fffound: 
06a1				 
06a1			 
06a1 d1					pop de 
06a2 c1					pop bc 
06a3 e1					pop hl 
06a4					if DEBUG_FORTH_WORDS 
06a4					DMARK "FNF" 
06a4 f5				push af  
06a5 3a b9 06			ld a, (.dmark)  
06a8 32 bd fb			ld (debug_mark),a  
06ab 3a ba 06			ld a, (.dmark+1)  
06ae 32 be fb			ld (debug_mark+1),a  
06b1 3a bb 06			ld a, (.dmark+2)  
06b4 32 bf fb			ld (debug_mark+2),a  
06b7 18 03			jr .pastdmark  
06b9 ..			.dmark: db "FNF"  
06bc f1			.pastdmark: pop af  
06bd			endm  
# End of macro DMARK
06bd					;	push af 
06bd					;	ld a, 'n' 
06bd					;	ld (debug_mark),a 
06bd					;	pop af 
06bd						CALLMONITOR 
06bd cd ea 15			call break_point_state  
06c0				endm  
# End of macro CALLMONITOR
06c0					endif 
06c0 c9				ret 
06c1			 
06c1			 
06c1			 
06c1			; Free Space 
06c1			; ---------- 
06c1			; 
06c1			; With current bank 
06c1			; 
06c1			; Set block count to zero 
06c1			; Starting with first logical block 
06c1			;      Find free block  
06c1			;      If block id given, increment block count 
06c1			; 
06c1			;  
06c1			 
06c1			 
06c1			; hl contains count of free blocks 
06c1			 
06c1			storage_freeblocks: 
06c1			 
06c1				; now locate first 0 page to mark as a free block 
06c1			 
06c1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c3 21 40 00			ld hl, STORE_BLOCK_PHY 
06c6 11 00 00			ld de, 0 
06c9			 
06c9			.fb1:   	 
06c9 e5					push hl 
06ca c5					push bc 
06cb d5					push de 
06cc cd 89 02				call se_readbyte 
06cf d1					pop de 
06d0 c1					pop bc 
06d1 e1					pop hl 
06d2			 
06d2					; is free? 
06d2 fe 00				cp 0 
06d4 20 01				jr nz, .ff1cont 
06d6 13					inc de 
06d7			 
06d7			.ff1cont: 
06d7			 
06d7			 
06d7 3e 40				ld a, STORE_BLOCK_PHY 
06d9 cd c8 0c				call addatohl 
06dc 10 eb				djnz .fb1 
06de			 
06de 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e0			.fb2:   	 
06e0 e5					push hl 
06e1 c5					push bc 
06e2 d5					push de 
06e3 cd 89 02				call se_readbyte 
06e6 d1					pop de 
06e7 c1					pop bc 
06e8 e1					pop hl 
06e9			 
06e9					; is free? 
06e9 fe 00				cp 0 
06eb 20 01				jr nz, .ff2cont 
06ed 13					inc de 
06ee			 
06ee			.ff2cont: 
06ee			 
06ee 3e 40				ld a, STORE_BLOCK_PHY 
06f0 cd c8 0c				call addatohl 
06f3 10 eb				djnz .fb2 
06f5			 
06f5 eb				ex de, hl 
06f6 c9				ret 
06f7			 
06f7			; Get File ID 
06f7			; ----------- 
06f7			; 
06f7			; With current bank 
06f7			;  
06f7			; Load Block 0 Config 
06f7			; Get max file id number 
06f7			; For each logical block 
06f7			;    Read block file id 
06f7			;      If first block of file and dont have file id 
06f7			;         if file get id and exit 
06f7			 
06f7			 
06f7			 
06f7			 
06f7			; Create File 
06f7			; ----------- 
06f7			; 
06f7			; With current bank  
06f7			; Load Block 0 Config 
06f7			; Get max file id number 
06f7			; Increment file id number 
06f7			; Save Config 
06f7			; Find free block 
06f7			; Set buffer with file name and file id 
06f7			; Write buffer to free block  
06f7			 
06f7			 
06f7			; hl point to file name 
06f7			; hl returns file id 
06f7			 
06f7			; file format: 
06f7			; byte 0 - file id 
06f7			; byte 1 - extent number 
06f7			; byte 2-> data 
06f7			 
06f7			; format for extent number 0: 
06f7			; 
06f7			; byte 0 - file id 
06f7			; byte 1 - extent 0 
06f7			; byte 2 - extent count 
06f7			; byte 3 -> file name and meta data 
06f7			 
06f7			 
06f7			storage_create: 
06f7				if DEBUG_STORESE 
06f7					DMARK "SCR" 
06f7 f5				push af  
06f8 3a 0c 07			ld a, (.dmark)  
06fb 32 bd fb			ld (debug_mark),a  
06fe 3a 0d 07			ld a, (.dmark+1)  
0701 32 be fb			ld (debug_mark+1),a  
0704 3a 0e 07			ld a, (.dmark+2)  
0707 32 bf fb			ld (debug_mark+2),a  
070a 18 03			jr .pastdmark  
070c ..			.dmark: db "SCR"  
070f f1			.pastdmark: pop af  
0710			endm  
# End of macro DMARK
0710					CALLMONITOR 
0710 cd ea 15			call break_point_state  
0713				endm  
# End of macro CALLMONITOR
0713				endif 
0713			 
0713 e5				push hl		; save file name pointer 
0714			 
0714 cd ba 03			call storage_get_block_0 
0717			 
0717 3a e8 f9			ld a,(store_page)	; get current file id 
071a 3c				inc a 
071b 32 e8 f9			ld (store_page),a 
071e				 
071e 32 e1 f9			ld (store_tmpid),a			; save id 
0721			 
0721 21 00 00			ld hl, 0 
0724 11 e8 f9			ld de, store_page 
0727				if DEBUG_STORESE 
0727					DMARK "SCw" 
0727 f5				push af  
0728 3a 3c 07			ld a, (.dmark)  
072b 32 bd fb			ld (debug_mark),a  
072e 3a 3d 07			ld a, (.dmark+1)  
0731 32 be fb			ld (debug_mark+1),a  
0734 3a 3e 07			ld a, (.dmark+2)  
0737 32 bf fb			ld (debug_mark+2),a  
073a 18 03			jr .pastdmark  
073c ..			.dmark: db "SCw"  
073f f1			.pastdmark: pop af  
0740			endm  
# End of macro DMARK
0740					CALLMONITOR 
0740 cd ea 15			call break_point_state  
0743				endm  
# End of macro CALLMONITOR
0743				endif 
0743 cd 6e 03			call storage_write_block	 ; save update 
0746			 
0746				if DEBUG_STORESE 
0746 11 e8 f9				ld de, store_page 
0749					DMARK "SCC" 
0749 f5				push af  
074a 3a 5e 07			ld a, (.dmark)  
074d 32 bd fb			ld (debug_mark),a  
0750 3a 5f 07			ld a, (.dmark+1)  
0753 32 be fb			ld (debug_mark+1),a  
0756 3a 60 07			ld a, (.dmark+2)  
0759 32 bf fb			ld (debug_mark+2),a  
075c 18 03			jr .pastdmark  
075e ..			.dmark: db "SCC"  
0761 f1			.pastdmark: pop af  
0762			endm  
# End of macro DMARK
0762					CALLMONITOR 
0762 cd ea 15			call break_point_state  
0765				endm  
# End of macro CALLMONITOR
0765				endif 
0765				;  
0765				 
0765 21 40 00			ld hl, STORE_BLOCK_PHY 
0768 11 00 00			ld de, 0 
076b cd 27 06			call storage_findnextid 
076e			 
076e 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0771			 
0771				; TODO detect 0 = no spare blocks 
0771			 
0771				; hl now contains the free page to use for the file header page 
0771			 
0771				if DEBUG_STORESE 
0771				DMARK "SCF" 
0771 f5				push af  
0772 3a 86 07			ld a, (.dmark)  
0775 32 bd fb			ld (debug_mark),a  
0778 3a 87 07			ld a, (.dmark+1)  
077b 32 be fb			ld (debug_mark+1),a  
077e 3a 88 07			ld a, (.dmark+2)  
0781 32 bf fb			ld (debug_mark+2),a  
0784 18 03			jr .pastdmark  
0786 ..			.dmark: db "SCF"  
0789 f1			.pastdmark: pop af  
078a			endm  
# End of macro DMARK
078a					CALLMONITOR 
078a cd ea 15			call break_point_state  
078d				endm  
# End of macro CALLMONITOR
078d				endif 
078d			 
078d 22 d2 f9			ld (store_tmppageid), hl 
0790				 
0790 3a e1 f9			ld a,(store_tmpid)    ; get file id 
0793			;	ld a, (store_filecache)			; save to cache 
0793			 
0793 32 e8 f9			ld (store_page),a    ; set page id 
0796 3e 00			ld a, 0			 ; extent 0 is file header 
0798 32 e9 f9			ld (store_page+1), a   ; set file extent 
079b			 
079b 32 ea f9			ld (store_page+2), a   ; extent count for the file 
079e			 
079e			;	inc hl 		; init block 0 of file 
079e			;	inc hl   		; skip file and extent id 
079e			 ;       ld a, 0 
079e			;	ld (hl),a 
079e			;	ld a, (store_filecache+1)  	; save to cache 
079e			 
079e			;	inc hl    ; file name 
079e				 
079e				 
079e 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a1				if DEBUG_STORESE 
07a1					DMARK "SCc" 
07a1 f5				push af  
07a2 3a b6 07			ld a, (.dmark)  
07a5 32 bd fb			ld (debug_mark),a  
07a8 3a b7 07			ld a, (.dmark+1)  
07ab 32 be fb			ld (debug_mark+1),a  
07ae 3a b8 07			ld a, (.dmark+2)  
07b1 32 bf fb			ld (debug_mark+2),a  
07b4 18 03			jr .pastdmark  
07b6 ..			.dmark: db "SCc"  
07b9 f1			.pastdmark: pop af  
07ba			endm  
# End of macro DMARK
07ba					CALLMONITOR 
07ba cd ea 15			call break_point_state  
07bd				endm  
# End of macro CALLMONITOR
07bd				endif 
07bd e1				pop hl    ; get zero term string 
07be e5				push hl 
07bf 3e 00			ld a, 0 
07c1 cd 31 11			call strlent 
07c4 23				inc hl   ; cover zero term 
07c5 06 00			ld b,0 
07c7 4d				ld c,l 
07c8 e1				pop hl 
07c9				;ex de, hl 
07c9				if DEBUG_STORESE 
07c9					DMARK "SCa" 
07c9 f5				push af  
07ca 3a de 07			ld a, (.dmark)  
07cd 32 bd fb			ld (debug_mark),a  
07d0 3a df 07			ld a, (.dmark+1)  
07d3 32 be fb			ld (debug_mark+1),a  
07d6 3a e0 07			ld a, (.dmark+2)  
07d9 32 bf fb			ld (debug_mark+2),a  
07dc 18 03			jr .pastdmark  
07de ..			.dmark: db "SCa"  
07e1 f1			.pastdmark: pop af  
07e2			endm  
# End of macro DMARK
07e2					;push af 
07e2					;ld a, 'a' 
07e2					;ld (debug_mark),a 
07e2					;pop af 
07e2					CALLMONITOR 
07e2 cd ea 15			call break_point_state  
07e5				endm  
# End of macro CALLMONITOR
07e5				endif 
07e5 ed b0			ldir    ; copy zero term string 
07e7				if DEBUG_STORESE 
07e7					DMARK "SCA" 
07e7 f5				push af  
07e8 3a fc 07			ld a, (.dmark)  
07eb 32 bd fb			ld (debug_mark),a  
07ee 3a fd 07			ld a, (.dmark+1)  
07f1 32 be fb			ld (debug_mark+1),a  
07f4 3a fe 07			ld a, (.dmark+2)  
07f7 32 bf fb			ld (debug_mark+2),a  
07fa 18 03			jr .pastdmark  
07fc ..			.dmark: db "SCA"  
07ff f1			.pastdmark: pop af  
0800			endm  
# End of macro DMARK
0800					CALLMONITOR 
0800 cd ea 15			call break_point_state  
0803				endm  
# End of macro CALLMONITOR
0803				endif 
0803			 
0803				; write file header page 
0803			 
0803 2a d2 f9			ld hl,(store_tmppageid) 
0806 11 e8 f9			ld de, store_page 
0809				if DEBUG_STORESE 
0809					DMARK "SCb" 
0809 f5				push af  
080a 3a 1e 08			ld a, (.dmark)  
080d 32 bd fb			ld (debug_mark),a  
0810 3a 1f 08			ld a, (.dmark+1)  
0813 32 be fb			ld (debug_mark+1),a  
0816 3a 20 08			ld a, (.dmark+2)  
0819 32 bf fb			ld (debug_mark+2),a  
081c 18 03			jr .pastdmark  
081e ..			.dmark: db "SCb"  
0821 f1			.pastdmark: pop af  
0822			endm  
# End of macro DMARK
0822					;push af 
0822					;ld a, 'b' 
0822					;ld (debug_mark),a 
0822					;pop af 
0822					CALLMONITOR 
0822 cd ea 15			call break_point_state  
0825				endm  
# End of macro CALLMONITOR
0825				endif 
0825 cd 6e 03			call storage_write_block 
0828			 
0828 3a e1 f9			ld a, (store_tmpid) 
082b 6f				ld l, a 
082c 26 00			ld h,0 
082e				if DEBUG_STORESE 
082e					DMARK "SCz" 
082e f5				push af  
082f 3a 43 08			ld a, (.dmark)  
0832 32 bd fb			ld (debug_mark),a  
0835 3a 44 08			ld a, (.dmark+1)  
0838 32 be fb			ld (debug_mark+1),a  
083b 3a 45 08			ld a, (.dmark+2)  
083e 32 bf fb			ld (debug_mark+2),a  
0841 18 03			jr .pastdmark  
0843 ..			.dmark: db "SCz"  
0846 f1			.pastdmark: pop af  
0847			endm  
# End of macro DMARK
0847					CALLMONITOR 
0847 cd ea 15			call break_point_state  
084a				endm  
# End of macro CALLMONITOR
084a				endif 
084a c9				ret 
084b				 
084b			 
084b			 
084b			; 
084b			; Read File 
084b			; 
084b			; h - file id to locate 
084b			; l - extent to locate 
084b			; de - pointer to string to read into 
084b			; 
084b			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084b			storage_read: 
084b d5				push de 
084c			 
084c			; TODO BUG the above push is it popped before the RET Z? 
084c			 
084c			; TODO how to handle multiple part blocks 
084c			 
084c				; locate file extent to read 
084c			 
084c 5c				ld e, h 
084d 55				ld d, l 
084e 21 40 00			ld hl, STORE_BLOCK_PHY 
0851				if DEBUG_STORESE 
0851					DMARK "SRE" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 bd fb			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 be fb			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 bf fb			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SRE"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd ea 15			call break_point_state  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d cd 27 06			call storage_findnextid 
0870			 
0870				if DEBUG_STORESE 
0870					DMARK "SRf" 
0870 f5				push af  
0871 3a 85 08			ld a, (.dmark)  
0874 32 bd fb			ld (debug_mark),a  
0877 3a 86 08			ld a, (.dmark+1)  
087a 32 be fb			ld (debug_mark+1),a  
087d 3a 87 08			ld a, (.dmark+2)  
0880 32 bf fb			ld (debug_mark+2),a  
0883 18 03			jr .pastdmark  
0885 ..			.dmark: db "SRf"  
0888 f1			.pastdmark: pop af  
0889			endm  
# End of macro DMARK
0889					CALLMONITOR 
0889 cd ea 15			call break_point_state  
088c				endm  
# End of macro CALLMONITOR
088c				endif 
088c cd f1 0c			call ishlzero 
088f			;	ld a, l 
088f			;	add h 
088f			;	cp 0 
088f c8				ret z			; block not found so EOF 
0890			 
0890				; hl contains page number to load 
0890 d1				pop de   ; get storage 
0891 d5				push de 
0892				if DEBUG_STORESE 
0892					DMARK "SRg" 
0892 f5				push af  
0893 3a a7 08			ld a, (.dmark)  
0896 32 bd fb			ld (debug_mark),a  
0899 3a a8 08			ld a, (.dmark+1)  
089c 32 be fb			ld (debug_mark+1),a  
089f 3a a9 08			ld a, (.dmark+2)  
08a2 32 bf fb			ld (debug_mark+2),a  
08a5 18 03			jr .pastdmark  
08a7 ..			.dmark: db "SRg"  
08aa f1			.pastdmark: pop af  
08ab			endm  
# End of macro DMARK
08ab					CALLMONITOR 
08ab cd ea 15			call break_point_state  
08ae				endm  
# End of macro CALLMONITOR
08ae				endif 
08ae cd 09 03			call storage_read_block 
08b1			 
08b1			 
08b1			; TODO if block has no zeros then need to read next block  
08b1			 
08b1			 
08b1					 
08b1 e1				pop hl 		 ; return start of data to show as not EOF 
08b2 23				inc hl   ; past file id 
08b3 23				inc hl   ; past ext 
08b4				if DEBUG_STORESE 
08b4					DMARK "SRe" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 bd fb			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 be fb			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 bf fb			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "SRe"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd ea 15			call break_point_state  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0 c9					ret 
08d1			 
08d1			 
08d1			 
08d1			; 
08d1			; Append File 
08d1			; 
08d1			; hl - file id to locate 
08d1			; de - pointer to (multi block) string to write 
08d1			 
08d1			 
08d1			storage_append: 
08d1				; hl -  file id to append to 
08d1				; de - string to append 
08d1			 
08d1 d5				push de 
08d2				 
08d2				if DEBUG_STORESE 
08d2					DMARK "AP1" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 bd fb			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 be fb			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 bf fb			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "AP1"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd ea 15			call break_point_state  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee			 
08ee 7d				ld a, l 
08ef 32 e1 f9			ld (store_tmpid), a 
08f2			 
08f2				; get file header  
08f2			 
08f2 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08f4 3a e1 f9			ld a, (store_tmpid) 
08f7 5f				ld e, a 
08f8			 
08f8 21 40 00				ld hl, STORE_BLOCK_PHY 
08fb cd 27 06				call storage_findnextid 
08fe			 
08fe 22 d2 f9			ld (store_tmppageid), hl 
0901			 
0901				; TODO handle file id not found 
0901			 
0901				if DEBUG_STORESE 
0901					DMARK "AP2" 
0901 f5				push af  
0902 3a 16 09			ld a, (.dmark)  
0905 32 bd fb			ld (debug_mark),a  
0908 3a 17 09			ld a, (.dmark+1)  
090b 32 be fb			ld (debug_mark+1),a  
090e 3a 18 09			ld a, (.dmark+2)  
0911 32 bf fb			ld (debug_mark+2),a  
0914 18 03			jr .pastdmark  
0916 ..			.dmark: db "AP2"  
0919 f1			.pastdmark: pop af  
091a			endm  
# End of macro DMARK
091a					CALLMONITOR 
091a cd ea 15			call break_point_state  
091d				endm  
# End of macro CALLMONITOR
091d				endif 
091d			 
091d				; update file extent count 
091d			 
091d 11 e8 f9			ld de, store_page 
0920			 
0920 cd 09 03			call storage_read_block 
0923			 
0923				if DEBUG_STORESE 
0923					DMARK "AP3" 
0923 f5				push af  
0924 3a 38 09			ld a, (.dmark)  
0927 32 bd fb			ld (debug_mark),a  
092a 3a 39 09			ld a, (.dmark+1)  
092d 32 be fb			ld (debug_mark+1),a  
0930 3a 3a 09			ld a, (.dmark+2)  
0933 32 bf fb			ld (debug_mark+2),a  
0936 18 03			jr .pastdmark  
0938 ..			.dmark: db "AP3"  
093b f1			.pastdmark: pop af  
093c			endm  
# End of macro DMARK
093c					CALLMONITOR 
093c cd ea 15			call break_point_state  
093f				endm  
# End of macro CALLMONITOR
093f				endif 
093f			;	ld (store_tmppageid), hl 
093f			 
093f 3a ea f9			ld a, (store_page+2) 
0942 3c				inc a 
0943 32 ea f9			ld (store_page+2), a 
0946 32 e0 f9			ld (store_tmpext), a 
0949				 
0949				if DEBUG_STORESE 
0949					DMARK "AP3" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 bd fb			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 be fb			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 bf fb			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "AP3"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd ea 15			call break_point_state  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 2a d2 f9			ld hl, (store_tmppageid) 
0968 11 e8 f9			ld de, store_page 
096b cd 6e 03			call storage_write_block 
096e			 
096e				; find free block 
096e			 
096e 11 00 00			ld de, 0			 ; file extent to locate 
0971			 
0971 21 40 00				ld hl, STORE_BLOCK_PHY 
0974 cd 27 06				call storage_findnextid 
0977			 
0977					; TODO handle no space left 
0977					 
0977 22 d2 f9				ld (store_tmppageid), hl 
097a			 
097a				if DEBUG_STORESE 
097a					DMARK "AP4" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 bd fb			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 be fb			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 bf fb			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "AP4"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					CALLMONITOR 
0993 cd ea 15			call break_point_state  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996					; init the buffer with zeros so we can id if the buffer is full or not 
0996			 
0996 e5					push hl 
0997 c5					push bc 
0998			 
0998 21 e8 f9				ld hl, store_page 
099b 06 40				ld b, STORE_BLOCK_PHY 
099d 3e 00				ld a, 0 
099f 77			.zeroblock:	ld (hl), a 
09a0 23					inc hl 
09a1 10 fc				djnz .zeroblock 
09a3			 
09a3 c1					pop bc 
09a4 e1					pop hl 
09a5			 
09a5					; construct block 
09a5			 
09a5 3a e1 f9				ld a, (store_tmpid) 
09a8 32 e8 f9				ld (store_page), a   ; file id 
09ab 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09ae 32 e9 f9				ld (store_page+1), a 
09b1			 
09b1 e1					pop hl    ; get string to write 
09b2 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b4 11 ea f9				ld de, store_page+2 
09b7			 
09b7				if DEBUG_STORESE 
09b7					DMARK "AP5" 
09b7 f5				push af  
09b8 3a cc 09			ld a, (.dmark)  
09bb 32 bd fb			ld (debug_mark),a  
09be 3a cd 09			ld a, (.dmark+1)  
09c1 32 be fb			ld (debug_mark+1),a  
09c4 3a ce 09			ld a, (.dmark+2)  
09c7 32 bf fb			ld (debug_mark+2),a  
09ca 18 03			jr .pastdmark  
09cc ..			.dmark: db "AP5"  
09cf f1			.pastdmark: pop af  
09d0			endm  
# End of macro DMARK
09d0					CALLMONITOR 
09d0 cd ea 15			call break_point_state  
09d3				endm  
# End of macro CALLMONITOR
09d3				endif 
09d3			 
09d3			 
09d3			 
09d3					; fill buffer with data until end of string or full block 
09d3			 
09d3 7e			.appd:		ld a, (hl) 
09d4 12					ld (de), a 
09d5 fe 00				cp 0 
09d7 28 04				jr z, .appdone 
09d9 23					inc hl 
09da 13					inc de 
09db 10 f6				djnz .appd 
09dd			 
09dd e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09de f5					push af   		; save last byte dumped 
09df			 
09df			 
09df 2a d2 f9			ld hl, (store_tmppageid) 
09e2 11 e8 f9			ld de, store_page 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP6" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 bd fb			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 be fb			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 bf fb			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP6"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd ea 15			call break_point_state  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 cd 6e 03				call storage_write_block 
0a04			 
0a04			 
0a04				; was that a full block of data written? 
0a04				; any more to write out? 
0a04			 
0a04				; if yes then set vars and jump to start of function again 
0a04			 
0a04 f1					pop af 
0a05 d1					pop de 
0a06			 
0a06 fe 00				cp 0		 ; no, string was fully written 
0a08 c8					ret z 
0a09			 
0a09					; setup vars for next cycle 
0a09			 
0a09 3a e1 f9				ld a, (store_tmpid) 
0a0c 6f					ld l, a 
0a0d 26 00				ld h, 0 
0a0f			 
0a0f c3 d1 08			 	jp storage_append	 ; yes, need to write out some more 
0a12			 
0a12			 
0a12			 
0a12			 
0a12			 
0a12			 
0a12			 
0a12			if DEBUG_STORECF 
0a12			storageput:	 
0a12					ret 
0a12			storageread: 
0a12					ld hl, store_page 
0a12					ld b, 200 
0a12					ld a,0 
0a12			.src:		ld (hl),a 
0a12					inc hl 
0a12					djnz .src 
0a12					 
0a12			 
0a12					ld de, 0 
0a12					ld bc, 1 
0a12					ld hl, store_page 
0a12					call cfRead 
0a12			 
0a12				call cfGetError 
0a12				ld hl,scratch 
0a12				call hexout 
0a12				ld hl, scratch+2 
0a12				ld a, 0 
0a12				ld (hl),a 
0a12				ld de, scratch 
0a12				ld a,display_row_1 
0a12				call str_at_display 
0a12				call update_display 
0a12			 
0a12					ld hl, store_page 
0a12					ld (os_cur_ptr),hl 
0a12			 
0a12					ret 
0a12			endif 
0a12			 
0a12			 
0a12			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a12			 
0a12			storage_clear_page: 
0a12 e5				push hl 
0a13 d5				push de 
0a14 c5				push bc 
0a15 21 e8 f9			ld hl, store_page 
0a18 3e 00			ld a, 0 
0a1a 77				ld (hl), a 
0a1b			 
0a1b 11 e9 f9			ld de, store_page+1 
0a1e 01 40 00			ld bc, STORE_BLOCK_PHY 
0a21			 
0a21 ed b0			ldir 
0a23				 
0a23 c1				pop bc 
0a24 d1				pop de 
0a25 e1				pop hl 
0a26 c9				ret 
0a27			 
0a27			; eof 
# End of file firmware_storage.asm
0a27			  
0a27			; support routines for above hardware abstraction layer  
0a27			  
0a27			include "firmware_general.asm"        ; general support functions  
0a27			 
0a27			 
0a27			 
0a27			; Delay loops 
0a27			 
0a27			 
0a27			 
0a27			aDelayInMS: 
0a27 c5				push bc 
0a28 47				ld b,a 
0a29			msdelay: 
0a29 c5				push bc 
0a2a				 
0a2a			 
0a2a 01 41 00			ld bc,041h 
0a2d cd 45 0a			call delayloop 
0a30 c1				pop bc 
0a31 05				dec b 
0a32 20 f5			jr nz,msdelay 
0a34			 
0a34			;if CPU_CLOCK_8MHZ 
0a34			;msdelay8: 
0a34			;	push bc 
0a34			;	 
0a34			; 
0a34			;	ld bc,041h 
0a34			;	call delayloop 
0a34			;	pop bc 
0a34			;	dec b 
0a34			;	jr nz,msdelay8 
0a34			;endif 
0a34			 
0a34			 
0a34 c1				pop bc 
0a35 c9				ret 
0a36			 
0a36			 
0a36			delay250ms: 
0a36				;push de 
0a36 01 00 40			ld bc, 04000h 
0a39 c3 45 0a			jp delayloop 
0a3c			delay500ms: 
0a3c				;push de 
0a3c 01 00 80			ld bc, 08000h 
0a3f c3 45 0a			jp delayloop 
0a42			delay1s: 
0a42				;push bc 
0a42			   ; Clobbers A, d and e 
0a42 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a45			delayloop: 
0a45 c5			    push bc 
0a46			 
0a46			if BASE_CPM 
0a46				ld bc, CPM_DELAY_TUNE 
0a46			.cpmloop: 
0a46				push bc 
0a46			 
0a46			endif 
0a46			 
0a46			 
0a46			 
0a46			delayloopi: 
0a46			;	push bc 
0a46			;.dl: 
0a46 cb 47		    bit     0,a    	; 8 
0a48 cb 47		    bit     0,a    	; 8 
0a4a cb 47		    bit     0,a    	; 8 
0a4c e6 ff		    and     255  	; 7 
0a4e 0b			    dec     bc      	; 6 
0a4f 79			    ld      a,c     	; 4 
0a50 b0			    or      b     	; 4 
0a51 c2 46 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a54			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a54				;pop de 
0a54			;pop bc 
0a54			 
0a54			if BASE_CPM 
0a54				pop bc 
0a54				 
0a54			    dec     bc      	; 6 
0a54			    ld      a,c     	; 4 
0a54			    or      b     	; 4 
0a54			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a54				 
0a54			 
0a54			endif 
0a54			;if CPU_CLOCK_8MHZ 
0a54			;    pop bc 
0a54			;    push bc 
0a54			;.dl8: 
0a54			;    bit     0,a    	; 8 
0a54			;    bit     0,a    	; 8 
0a54			;    bit     0,a    	; 8 
0a54			;    and     255  	; 7 
0a54			;    dec     bc      	; 6 
0a54			;    ld      a,c     	; 4 
0a54			;    or      b     	; 4 
0a54			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a54			;endif 
0a54			 
0a54			;if CPU_CLOCK_10MHZ 
0a54			;    pop bc 
0a54			;    push bc 
0a54			;.dl8: 
0a54			;    bit     0,a    	; 8 
0a54			;    bit     0,a    	; 8 
0a54			;    bit     0,a    	; 8 
0a54			;    and     255  	; 7 
0a54			;    dec     bc      	; 6 
0a54			;    ld      a,c     	; 4 
0a54			;    or      b     	; 4 
0a54			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a54			;endif 
0a54 c1			    pop bc 
0a55			 
0a55 c9				ret 
0a56			 
0a56			 
0a56			 
0a56			; eof 
# End of file firmware_general.asm
0a56			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a56			; display routines that use the physical hardware abstraction layer 
0a56			 
0a56			 
0a56			; TODO windowing? 
0a56			 
0a56			; TODO scroll line up 
0a56			 
0a56			scroll_up: 
0a56			 
0a56 e5				push hl 
0a57 d5				push de 
0a58 c5				push bc 
0a59			 
0a59				; get frame buffer  
0a59			 
0a59 2a 5e fa			ld hl, (display_fb_active) 
0a5c e5				push hl    ; future de destination 
0a5d			 
0a5d 11 14 00			ld  de, display_cols 
0a60 19				add hl, de 
0a61			 
0a61 d1				pop de 
0a62			 
0a62				;ex de, hl 
0a62 01 4f 00			ld bc, display_fb_len -1  
0a65			;if DEBUG_FORTH_WORDS 
0a65			;	DMARK "SCL" 
0a65			;	CALLMONITOR 
0a65			;endif	 
0a65 ed b0			ldir 
0a67			 
0a67				; wipe bottom row 
0a67			 
0a67			 
0a67 2a 5e fa			ld hl, (display_fb_active) 
0a6a 11 50 00			ld de, display_cols*display_rows 
0a6d 19				add hl, de 
0a6e 06 14			ld b, display_cols 
0a70 3e 20			ld a, ' ' 
0a72			.scwipe: 
0a72 77				ld (hl), a 
0a73 2b				dec hl 
0a74 10 fc			djnz .scwipe 
0a76			 
0a76				;pop hl 
0a76			 
0a76 c1				pop bc 
0a77 d1				pop de 
0a78 e1				pop hl 
0a79			 
0a79 c9				ret 
0a7a			 
0a7a			 
0a7a			;scroll_upo: 
0a7a			;	ld de, display_row_1 
0a7a			 ;	ld hl, display_row_2 
0a7a			;	ld bc, display_cols 
0a7a			;	ldir 
0a7a			;	ld de, display_row_2 
0a7a			 ;	ld hl, display_row_3 
0a7a			;	ld bc, display_cols 
0a7a			;	ldir 
0a7a			;	ld de, display_row_3 
0a7a			 ;	ld hl, display_row_4 
0a7a			;	ld bc, display_cols 
0a7a			;	ldir 
0a7a			 
0a7a			; TODO clear row 4 
0a7a			 
0a7a			;	ret 
0a7a			 
0a7a				 
0a7a			scroll_down: 
0a7a			 
0a7a e5				push hl 
0a7b d5				push de 
0a7c c5				push bc 
0a7d			 
0a7d				; get frame buffer  
0a7d			 
0a7d 2a 5e fa			ld hl, (display_fb_active) 
0a80			 
0a80 11 4f 00			ld de, display_fb_len - 1 
0a83 19				add hl, de 
0a84			 
0a84 e5			push hl    ; future de destination 
0a85			 
0a85 11 14 00			ld  de, display_cols 
0a88 ed 52			sbc hl, de 
0a8a			 
0a8a			 
0a8a d1				pop de 
0a8b			 
0a8b			;	ex de, hl 
0a8b 01 4f 00			ld bc, display_fb_len -1  
0a8e			 
0a8e			 
0a8e				 
0a8e			 
0a8e ed b0			ldir 
0a90			 
0a90				; wipe bottom row 
0a90			 
0a90			 
0a90			;	ld hl, (display_fb_active) 
0a90			;;	ld de, display_cols*display_rows 
0a90			;;	add hl, de 
0a90			;	ld b, display_cols 
0a90			;	ld a, ' ' 
0a90			;.scwiped: 
0a90			;	ld (hl), a 
0a90			;	dec hl 
0a90			;	djnz .scwiped 
0a90			 
0a90				;pop hl 
0a90			 
0a90 c1				pop bc 
0a91 d1				pop de 
0a92 e1				pop hl 
0a93			 
0a93 c9				ret 
0a94			;scroll_down: 
0a94			;	ld de, display_row_4 
0a94			;	ld hl, display_row_3 
0a94			;	ld bc, display_cols 
0a94			;	ldir 
0a94			;	ld de, display_row_3 
0a94			; 	ld hl, display_row_2 
0a94			;	ld bc, display_cols 
0a94			;	ldir 
0a94			;	ld de, display_row_2 
0a94			;	ld hl, display_row_1 
0a94			;	ld bc, display_cols 
0a94			;	ldir 
0a94			;;; TODO clear row 1 
0a94			;	ret 
0a94			 
0a94			 
0a94			 
0a94			 
0a94			 
0a94			; clear active frame buffer 
0a94			 
0a94			clear_display: 
0a94 3e 20			ld a, ' ' 
0a96 c3 99 0a			jp fill_display 
0a99			 
0a99			; fill active frame buffer with a char in A 
0a99			 
0a99			fill_display: 
0a99 06 50			ld b,display_fb_len 
0a9b 2a 5e fa			ld hl, (display_fb_active) 
0a9e 77			.fd1:	ld (hl),a 
0a9f 23				inc hl 
0aa0 10 fc			djnz .fd1 
0aa2 23				inc hl 
0aa3 3e 00			ld a,0 
0aa5 77				ld (hl),a 
0aa6			 
0aa6			 
0aa6 c9				ret 
0aa7			; Write string (DE) at pos (A) to active frame buffer 
0aa7			 
0aa7 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0aaa 06 00					ld b,0 
0aac 4f					ld c,a 
0aad 09					add hl,bc 
0aae 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aaf b7			            OR   A              ;Null terminator? 
0ab0 c8			            RET  Z              ;Yes, so finished 
0ab1 77					ld (hl),a 
0ab2 23				inc hl 
0ab3 13			            INC  DE             ;Point to next character 
0ab4 18 f8		            JR   .sad1     ;Repeat 
0ab6 c9					ret 
0ab7			 
0ab7			; using current frame buffer write to physical display 
0ab7			 
0ab7			update_display: 
0ab7 e5				push hl 
0ab8 2a 5e fa			ld hl, (display_fb_active) 
0abb cd 25 64			call write_display 
0abe e1				pop hl 
0abf c9				ret 
0ac0			 
0ac0			; TODO scrolling 
0ac0			 
0ac0			 
0ac0			; move cursor right one char 
0ac0			cursor_right: 
0ac0			 
0ac0				; TODO shift right 
0ac0				; TODO if beyond max col 
0ac0				; TODO       cursor_next_line 
0ac0			 
0ac0 c9				ret 
0ac1			 
0ac1			 
0ac1			cursor_next_line: 
0ac1				; TODO first char 
0ac1				; TODO line down 
0ac1				; TODO if past last row 
0ac1				; TODO    scroll up 
0ac1			 
0ac1 c9				ret 
0ac2			 
0ac2			cursor_left: 
0ac2				; TODO shift left 
0ac2				; TODO if beyond left  
0ac2				; TODO     cursor prev line 
0ac2				 
0ac2 c9				ret 
0ac3			 
0ac3			cursor_prev_line: 
0ac3				; TODO last char 
0ac3				; TODO line up 
0ac3				; TODO if past first row 
0ac3				; TODO   scroll down 
0ac3			 
0ac3 c9				ret 
0ac4			 
0ac4			 
0ac4			cout: 
0ac4				; A - char 
0ac4 c9				ret 
0ac5			 
0ac5			 
0ac5			; Display a menu and allow item selection (optional toggle items) 
0ac5			; 
0ac5			; format: 
0ac5			; hl pointer to word array with zero term for items 
0ac5			; e.g.    db item1 
0ac5			;         db .... 
0ac5			;         db 0 
0ac5			; 
0ac5			; a = starting menu item  
0ac5			; 
0ac5			; de = pointer item toggle array   (todo) 
0ac5			; 
0ac5			; returns item selected in a 1-... 
0ac5			; returns 0 if back button pressed 
0ac5			; 
0ac5			; NOTE: Uses system frame buffer to display 
0ac5			; 
0ac5			; LEFT, Q = go back 
0ac5			; RIGHT, SPACE, CR = select 
0ac5			; UP, A - Up 
0ac5			; DOWN, Z - Down 
0ac5			 
0ac5			 
0ac5			 
0ac5			 
0ac5			 
0ac5			menu: 
0ac5			 
0ac5					; keep array pointer 
0ac5			 
0ac5 22 e6 f9				ld (store_tmp1), hl 
0ac8 32 e4 f9				ld (store_tmp2), a 
0acb			 
0acb					; check for key bounce 
0acb			 
0acb			if BASE_KEV 
0acb			 
0acb cd da 65		.mbounce:	call cin 
0ace fe 00				cp 0 
0ad0 20 f9				jr nz, .mbounce 
0ad2			endif 
0ad2					; for ease use ex 
0ad2			 
0ad2					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0ad2 21 53 fb				ld hl, display_fb0 
0ad5 22 5e fa				ld (display_fb_active), hl 
0ad8			 
0ad8 cd 94 0a		.mloop:		call clear_display 
0adb cd b7 0a				call update_display 
0ade			 
0ade					; draw selection id '>' at 1 
0ade			 
0ade					; init start of list display 
0ade			 
0ade 3e 05				ld a, 5 
0ae0 32 e2 f9				ld (store_tmp3), a   ; display row count 
0ae3 3a e4 f9				ld a,( store_tmp2) 
0ae6 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0ae9			 
0ae9					 
0ae9			.mitem:	 
0ae9			 
0ae9			 
0ae9 3a e5 f9				ld a,(store_tmp2+1) 
0aec 6f					ld l, a 
0aed 26 00				ld h, 0 
0aef 29					add hl, hl 
0af0 ed 5b e6 f9			ld de, (store_tmp1) 
0af4 19					add hl, de 
0af5 7e					ld a, (hl) 
0af6 23					inc hl 
0af7 66					ld h,(hl) 
0af8 6f					ld l, a 
0af9			 
0af9 cd f1 0c				call ishlzero 
0afc 28 1a				jr z, .mdone 
0afe			 
0afe eb					ex de, hl 
0aff 3a e2 f9				ld a, (store_tmp3) 
0b02 cd a7 0a				call str_at_display 
0b05					 
0b05			 
0b05					; next item 
0b05 3a e5 f9				ld a, (store_tmp2+1) 
0b08 3c					inc a 
0b09 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b0c			 
0b0c			 		; next row 
0b0c			 
0b0c 3a e2 f9				ld a, (store_tmp3) 
0b0f c6 14				add display_cols 
0b11 32 e2 f9				ld (store_tmp3), a 
0b14			 
0b14					; at end of screen? 
0b14			 
0b14 fe 10				cp display_rows*4 
0b16 20 d1				jr nz, .mitem 
0b18			 
0b18			 
0b18			.mdone: 
0b18 cd f1 0c				call ishlzero 
0b1b 28 08				jr z, .nodn 
0b1d			 
0b1d 3e 3c				ld a, display_row_4 
0b1f 11 9e 0b				ld de, .mdown 
0b22 cd a7 0a				call str_at_display 
0b25			 
0b25					; draw options to fill the screens with active item on line 1 
0b25					; if current option is 2 or more then display ^ in top 
0b25			 
0b25 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b28 fe 00				cp 0 
0b2a 28 08				jr z, .noup 
0b2c			 
0b2c 3e 00				ld a, 0 
0b2e 11 9c 0b				ld de, .mup 
0b31 cd a7 0a				call str_at_display 
0b34			 
0b34 3e 02		.noup:		ld a, 2 
0b36 11 9a 0b				ld de, .msel 
0b39 cd a7 0a				call str_at_display 
0b3c			 
0b3c					; if current option + 1 is not null then display V in bottom 
0b3c					; get key 
0b3c cd b7 0a				call update_display 
0b3f			 
0b3f			 
0b3f					; handle key 
0b3f			 
0b3f cd c9 65				call cin_wait 
0b42			 
0b42 fe 05				cp KEY_UP 
0b44 28 2b				jr z, .mgoup 
0b46 fe 61				cp 'a' 
0b48 28 27				jr z, .mgoup 
0b4a fe 0a				cp KEY_DOWN 
0b4c 28 32				jr z, .mgod 
0b4e fe 7a				cp 'z' 
0b50 28 2e				jr z, .mgod 
0b52 fe 20				cp ' ' 
0b54 28 34				jr z, .goend 
0b56 fe 0c				cp KEY_RIGHT 
0b58 28 30				jr z, .goend 
0b5a fe 0d				cp KEY_CR 
0b5c 28 2c				jr z, .goend 
0b5e fe 71				cp 'q' 
0b60 28 0b				jr z, .goback 
0b62			 
0b62 fe 0b				cp KEY_LEFT 
0b64 28 07				jr z, .goback 
0b66 fe 08				cp KEY_BS 
0b68 28 03				jr z, .goback 
0b6a c3 d8 0a				jp .mloop 
0b6d			 
0b6d			.goback: 
0b6d 3e 00			ld a, 0 
0b6f 18 1d			jr .goend2 
0b71			 
0b71				; move up one 
0b71			.mgoup: 
0b71 3a e4 f9				ld a, (store_tmp2) 
0b74 fe 00				cp 0 
0b76 ca d8 0a				jp z, .mloop 
0b79 3d					dec a 
0b7a 32 e4 f9				ld (store_tmp2), a 
0b7d c3 d8 0a				jp .mloop 
0b80			 
0b80				; move down one 
0b80			.mgod: 
0b80 3a e4 f9				ld a, (store_tmp2) 
0b83 3c					inc a 
0b84 32 e4 f9				ld (store_tmp2), a 
0b87 c3 d8 0a				jp .mloop 
0b8a			 
0b8a			 
0b8a			.goend: 
0b8a					; get selected item number 
0b8a			 
0b8a 3a e4 f9				ld a, (store_tmp2) 
0b8d 3c					inc a 
0b8e			 
0b8e			.goend2: 
0b8e f5					push af 
0b8f			 
0b8f					; restore active fb 
0b8f					; TODO BUG assumes fb1 
0b8f			 
0b8f 21 02 fb				ld hl, display_fb1 
0b92 22 5e fa				ld (display_fb_active), hl 
0b95			 
0b95					; restore main regs 
0b95			 
0b95			 
0b95 cd b7 0a				call update_display 
0b98			 
0b98 f1					pop af 
0b99			 
0b99 c9				ret 
0b9a			 
0b9a .. 00		.msel:   db ">",0 
0b9c .. 00		.mup:   db "^",0 
0b9e .. 00		.mdown:   db "v",0 
0ba0			 
0ba0			 
0ba0			; eof 
0ba0			 
# End of file firmware_display.asm
0ba0			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ba0			; random number generators 
0ba0			 
0ba0			 
0ba0			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ba0			 
0ba0			 
0ba0			;-----> Generate a random number 
0ba0			; output a=answer 0<=a<=255 
0ba0			; all registers are preserved except: af 
0ba0			random: 
0ba0 e5			        push    hl 
0ba1 d5			        push    de 
0ba2 2a 40 fa		        ld      hl,(randData) 
0ba5 ed 5f		        ld      a,r 
0ba7 57			        ld      d,a 
0ba8 5e			        ld      e,(hl) 
0ba9 19			        add     hl,de 
0baa 85			        add     a,l 
0bab ac			        xor     h 
0bac 22 40 fa		        ld      (randData),hl 
0baf d1			        pop     de 
0bb0 e1			        pop     hl 
0bb1 c9			        ret 
0bb2			 
0bb2			 
0bb2			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bb2			 
0bb2			 
0bb2			 
0bb2			;------LFSR------ 
0bb2			;James Montelongo 
0bb2			;optimized by Spencer Putt 
0bb2			;out: 
0bb2			; a = 8 bit random number 
0bb2			RandLFSR: 
0bb2 21 46 fa		        ld hl,LFSRSeed+4 
0bb5 5e			        ld e,(hl) 
0bb6 23			        inc hl 
0bb7 56			        ld d,(hl) 
0bb8 23			        inc hl 
0bb9 4e			        ld c,(hl) 
0bba 23			        inc hl 
0bbb 7e			        ld a,(hl) 
0bbc 47			        ld b,a 
0bbd cb 13		        rl e  
0bbf cb 12			rl d 
0bc1 cb 11		        rl c  
0bc3 17				rla 
0bc4 cb 13		        rl e  
0bc6 cb 12			rl d 
0bc8 cb 11		        rl c  
0bca 17				rla 
0bcb cb 13		        rl e  
0bcd cb 12			rl d 
0bcf cb 11		        rl c  
0bd1 17				rla 
0bd2 67			        ld h,a 
0bd3 cb 13		        rl e  
0bd5 cb 12			rl d 
0bd7 cb 11		        rl c  
0bd9 17				rla 
0bda a8			        xor b 
0bdb cb 13		        rl e  
0bdd cb 12			rl d 
0bdf ac			        xor h 
0be0 a9			        xor c 
0be1 aa			        xor d 
0be2 21 48 fa		        ld hl,LFSRSeed+6 
0be5 11 49 fa		        ld de,LFSRSeed+7 
0be8 01 07 00		        ld bc,7 
0beb ed b8		        lddr 
0bed 12			        ld (de),a 
0bee c9			        ret 
0bef			 
0bef			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0bef			 
0bef			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0bef			 
0bef			 
0bef			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0bef			 
0bef			prng16: 
0bef			;Inputs: 
0bef			;   (seed1) contains a 16-bit seed value 
0bef			;   (seed2) contains a NON-ZERO 16-bit seed value 
0bef			;Outputs: 
0bef			;   HL is the result 
0bef			;   BC is the result of the LCG, so not that great of quality 
0bef			;   DE is preserved 
0bef			;Destroys: 
0bef			;   AF 
0bef			;cycle: 4,294,901,760 (almost 4.3 billion) 
0bef			;160cc 
0bef			;26 bytes 
0bef 2a 3a fa		    ld hl,(seed1) 
0bf2 44			    ld b,h 
0bf3 4d			    ld c,l 
0bf4 29			    add hl,hl 
0bf5 29			    add hl,hl 
0bf6 2c			    inc l 
0bf7 09			    add hl,bc 
0bf8 22 3a fa		    ld (seed1),hl 
0bfb 2a 38 fa		    ld hl,(seed2) 
0bfe 29			    add hl,hl 
0bff 9f			    sbc a,a 
0c00 e6 2d		    and %00101101 
0c02 ad			    xor l 
0c03 6f			    ld l,a 
0c04 22 38 fa		    ld (seed2),hl 
0c07 09			    add hl,bc 
0c08 c9			    ret 
0c09			 
0c09			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c09			 
0c09			rand32: 
0c09			;Inputs: 
0c09			;   (seed1_0) holds the lower 16 bits of the first seed 
0c09			;   (seed1_1) holds the upper 16 bits of the first seed 
0c09			;   (seed2_0) holds the lower 16 bits of the second seed 
0c09			;   (seed2_1) holds the upper 16 bits of the second seed 
0c09			;   **NOTE: seed2 must be non-zero 
0c09			;Outputs: 
0c09			;   HL is the result 
0c09			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c09			;Destroys: 
0c09			;   AF 
0c09			;Tested and passes all CAcert tests 
0c09			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c09			;it has a period of 18,446,744,069,414,584,320 
0c09			;roughly 18.4 quintillion. 
0c09			;LFSR taps: 0,2,6,7  = 11000101 
0c09			;291cc 
0c09			;seed1_0=$+1 
0c09			;    ld hl,12345 
0c09			;seed1_1=$+1 
0c09			;    ld de,6789 
0c09			;    ld b,h 
0c09			;    ld c,l 
0c09			;    add hl,hl \ rl e \ rl d 
0c09			;    add hl,hl \ rl e \ rl d 
0c09			;    inc l 
0c09			;    add hl,bc 
0c09			;    ld (seed1_0),hl 
0c09			;    ld hl,(seed1_1) 
0c09			;    adc hl,de 
0c09			;    ld (seed1_1),hl 
0c09			;    ex de,hl 
0c09			;seed2_0=$+1 
0c09			;    ld hl,9876 
0c09			;seed2_1=$+1 
0c09			;    ld bc,54321 
0c09			;    add hl,hl \ rl c \ rl b 
0c09			;    ld (seed2_1),bc 
0c09			;    sbc a,a 
0c09			;    and %11000101 
0c09			;    xor l 
0c09			;    ld l,a 
0c09			;    ld (seed2_0),hl 
0c09			;    ex de,hl 
0c09			;    add hl,bc 
0c09			;    ret 
0c09			; 
0c09			 
0c09			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c09			; 20 bytes, 86 cycles (excluding ret) 
0c09			 
0c09			; returns   hl = pseudorandom number 
0c09			; corrupts   a 
0c09			 
0c09			; generates 16-bit pseudorandom numbers with a period of 65535 
0c09			; using the xorshift method: 
0c09			 
0c09			; hl ^= hl << 7 
0c09			; hl ^= hl >> 9 
0c09			; hl ^= hl << 8 
0c09			 
0c09			; some alternative shift triplets which also perform well are: 
0c09			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c09			 
0c09			;  org 32768 
0c09			 
0c09			xrnd: 
0c09 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c0c 3e 00		  ld a,0 
0c0e bd			  cp l 
0c0f 20 02		  jr nz, .xrnd1 
0c11 2e 01		  ld l, 1 
0c13			.xrnd1: 
0c13			 
0c13 7c			  ld a,h 
0c14 1f			  rra 
0c15 7d			  ld a,l 
0c16 1f			  rra 
0c17 ac			  xor h 
0c18 67			  ld h,a 
0c19 7d			  ld a,l 
0c1a 1f			  rra 
0c1b 7c			  ld a,h 
0c1c 1f			  rra 
0c1d ad			  xor l 
0c1e 6f			  ld l,a 
0c1f ac			  xor h 
0c20 67			  ld h,a 
0c21			 
0c21 22 3e fa		  ld (xrandc),hl 
0c24			 
0c24 c9			  ret 
0c25			;  
0c25			 
0c25			 
0c25			;;;; int maths 
0c25			 
0c25			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c25			; Divide 16-bit values (with 16-bit result) 
0c25			; In: Divide BC by divider DE 
0c25			; Out: BC = result, HL = rest 
0c25			; 
0c25			Div16: 
0c25 21 00 00		    ld hl,0 
0c28 78			    ld a,b 
0c29 06 08		    ld b,8 
0c2b			Div16_Loop1: 
0c2b 17			    rla 
0c2c ed 6a		    adc hl,hl 
0c2e ed 52		    sbc hl,de 
0c30 30 01		    jr nc,Div16_NoAdd1 
0c32 19			    add hl,de 
0c33			Div16_NoAdd1: 
0c33 10 f6		    djnz Div16_Loop1 
0c35 17			    rla 
0c36 2f			    cpl 
0c37 47			    ld b,a 
0c38 79			    ld a,c 
0c39 48			    ld c,b 
0c3a 06 08		    ld b,8 
0c3c			Div16_Loop2: 
0c3c 17			    rla 
0c3d ed 6a		    adc hl,hl 
0c3f ed 52		    sbc hl,de 
0c41 30 01		    jr nc,Div16_NoAdd2 
0c43 19			    add hl,de 
0c44			Div16_NoAdd2: 
0c44 10 f6		    djnz Div16_Loop2 
0c46 17			    rla 
0c47 2f			    cpl 
0c48 41			    ld b,c 
0c49 4f			    ld c,a 
0c4a c9			ret 
0c4b			 
0c4b			 
0c4b			;http://z80-heaven.wikidot.com/math 
0c4b			; 
0c4b			;Inputs: 
0c4b			;     DE and A are factors 
0c4b			;Outputs: 
0c4b			;     A is not changed 
0c4b			;     B is 0 
0c4b			;     C is not changed 
0c4b			;     DE is not changed 
0c4b			;     HL is the product 
0c4b			;Time: 
0c4b			;     342+6x 
0c4b			; 
0c4b			Mult16: 
0c4b			 
0c4b 06 08		     ld b,8          ;7           7 
0c4d 21 00 00		     ld hl,0         ;10         10 
0c50 29			       add hl,hl     ;11*8       88 
0c51 07			       rlca          ;4*8        32 
0c52 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c54 19			         add hl,de   ;--         -- 
0c55 10 f9		       djnz $-5      ;13*7+8     99 
0c57 c9			ret 
0c58			 
0c58			; 
0c58			; Square root of 16-bit value 
0c58			; In:  HL = value 
0c58			; Out:  D = result (rounded down) 
0c58			; 
0c58			;Sqr16: 
0c58			;    ld de,#0040 
0c58			;    ld a,l 
0c58			;    ld l,h 
0c58			;    ld h,d 
0c58			;    or a 
0c58			;    ld b,8 
0c58			;Sqr16_Loop: 
0c58			;    sbc hl,de 
0c58			;    jr nc,Sqr16_Skip 
0c58			;    add hl,de 
0c58			;Sqr16_Skip: 
0c58			;    ccf 
0c58			;    rl d 
0c58			;    add a,a 
0c58			;    adc hl,hl 
0c58			;    add a,a 
0c58			;    adc hl,hl 
0c58			;    djnz Sqr16_Loop 
0c58			;    ret 
0c58			; 
0c58			; 
0c58			; Divide 8-bit values 
0c58			; In: Divide E by divider C 
0c58			; Out: A = result, B = rest 
0c58			; 
0c58			Div8: 
0c58 af			    xor a 
0c59 06 08		    ld b,8 
0c5b			Div8_Loop: 
0c5b cb 13		    rl e 
0c5d 17			    rla 
0c5e 91			    sub c 
0c5f 30 01		    jr nc,Div8_NoAdd 
0c61 81			    add a,c 
0c62			Div8_NoAdd: 
0c62 10 f7		    djnz Div8_Loop 
0c64 47			    ld b,a 
0c65 7b			    ld a,e 
0c66 17			    rla 
0c67 2f			    cpl 
0c68 c9			    ret 
0c69			 
0c69			; 
0c69			; Multiply 8-bit value with a 16-bit value (unrolled) 
0c69			; In: Multiply A with DE 
0c69			; Out: HL = result 
0c69			; 
0c69			Mult12U: 
0c69 2e 00		    ld l,0 
0c6b 87			    add a,a 
0c6c 30 01		    jr nc,Mult12U_NoAdd0 
0c6e 19			    add hl,de 
0c6f			Mult12U_NoAdd0: 
0c6f 29			    add hl,hl 
0c70 87			    add a,a 
0c71 30 01		    jr nc,Mult12U_NoAdd1 
0c73 19			    add hl,de 
0c74			Mult12U_NoAdd1: 
0c74 29			    add hl,hl 
0c75 87			    add a,a 
0c76 30 01		    jr nc,Mult12U_NoAdd2 
0c78 19			    add hl,de 
0c79			Mult12U_NoAdd2: 
0c79 29			    add hl,hl 
0c7a 87			    add a,a 
0c7b 30 01		    jr nc,Mult12U_NoAdd3 
0c7d 19			    add hl,de 
0c7e			Mult12U_NoAdd3: 
0c7e 29			    add hl,hl 
0c7f 87			    add a,a 
0c80 30 01		    jr nc,Mult12U_NoAdd4 
0c82 19			    add hl,de 
0c83			Mult12U_NoAdd4: 
0c83 29			    add hl,hl 
0c84 87			    add a,a 
0c85 30 01		    jr nc,Mult12U_NoAdd5 
0c87 19			    add hl,de 
0c88			Mult12U_NoAdd5: 
0c88 29			    add hl,hl 
0c89 87			    add a,a 
0c8a 30 01		    jr nc,Mult12U_NoAdd6 
0c8c 19			    add hl,de 
0c8d			Mult12U_NoAdd6: 
0c8d 29			    add hl,hl 
0c8e 87			    add a,a 
0c8f d0			    ret nc 
0c90 19			    add hl,de 
0c91 c9			    ret 
0c92			 
0c92			; 
0c92			; Multiply 8-bit value with a 16-bit value (right rotating) 
0c92			; In: Multiply A with DE 
0c92			;      Put lowest value in A for most efficient calculation 
0c92			; Out: HL = result 
0c92			; 
0c92			Mult12R: 
0c92 21 00 00		    ld hl,0 
0c95			Mult12R_Loop: 
0c95 cb 3f		    srl a 
0c97 30 01		    jr nc,Mult12R_NoAdd 
0c99 19			    add hl,de 
0c9a			Mult12R_NoAdd: 
0c9a cb 23		    sla e 
0c9c cb 12		    rl d 
0c9e b7			    or a 
0c9f c2 95 0c		    jp nz,Mult12R_Loop 
0ca2 c9			    ret 
0ca3			 
0ca3			; 
0ca3			; Multiply 16-bit values (with 32-bit result) 
0ca3			; In: Multiply BC with DE 
0ca3			; Out: BCHL = result 
0ca3			; 
0ca3			Mult32: 
0ca3 79			    ld a,c 
0ca4 48			    ld c,b 
0ca5 21 00 00		    ld hl,0 
0ca8 06 10		    ld b,16 
0caa			Mult32_Loop: 
0caa 29			    add hl,hl 
0cab 17			    rla 
0cac cb 11		    rl c 
0cae 30 07		    jr nc,Mult32_NoAdd 
0cb0 19			    add hl,de 
0cb1 ce 00		    adc a,0 
0cb3 d2 b7 0c		    jp nc,Mult32_NoAdd 
0cb6 0c			    inc c 
0cb7			Mult32_NoAdd: 
0cb7 10 f1		    djnz Mult32_Loop 
0cb9 41			    ld b,c 
0cba 4f			    ld c,a 
0cbb c9			    ret 
0cbc			 
0cbc			 
0cbc			 
0cbc			; 
0cbc			; Multiply 8-bit values 
0cbc			; In:  Multiply H with E 
0cbc			; Out: HL = result 
0cbc			; 
0cbc			Mult8: 
0cbc 16 00		    ld d,0 
0cbe 6a			    ld l,d 
0cbf 06 08		    ld b,8 
0cc1			Mult8_Loop: 
0cc1 29			    add hl,hl 
0cc2 30 01		    jr nc,Mult8_NoAdd 
0cc4 19			    add hl,de 
0cc5			Mult8_NoAdd: 
0cc5 10 fa		    djnz Mult8_Loop 
0cc7 c9			    ret 
0cc8			 
0cc8			 
0cc8			 
0cc8			 
0cc8			 
0cc8			 
0cc8			 
0cc8			 
0cc8			;;http://z80-heaven.wikidot.com/math 
0cc8			;;This divides DE by BC, storing the result in DE, remainder in HL 
0cc8			; 
0cc8			;DE_Div_BC:          ;1281-2x, x is at most 16 
0cc8			;     ld a,16        ;7 
0cc8			;     ld hl,0        ;10 
0cc8			;     jp $+5         ;10 
0cc8			;.DivLoop: 
0cc8			;       add hl,bc    ;-- 
0cc8			;       dec a        ;64 
0cc8			;       jr z,.DivLoopEnd        ;86 
0cc8			; 
0cc8			;       sla e        ;128 
0cc8			;       rl d         ;128 
0cc8			;       adc hl,hl    ;240 
0cc8			;       sbc hl,bc    ;240 
0cc8			;       jr nc,.DivLoop ;23|21 
0cc8			;       inc e        ;-- 
0cc8			;       jp .DivLoop+1 
0cc8			; 
0cc8			;.DivLoopEnd: 
0cc8			 
0cc8			;HL_Div_C: 
0cc8			;Inputs: 
0cc8			;     HL is the numerator 
0cc8			;     C is the denominator 
0cc8			;Outputs: 
0cc8			;     A is the remainder 
0cc8			;     B is 0 
0cc8			;     C is not changed 
0cc8			;     DE is not changed 
0cc8			;     HL is the quotient 
0cc8			; 
0cc8			;       ld b,16 
0cc8			;       xor a 
0cc8			;         add hl,hl 
0cc8			;         rla 
0cc8			;         cp c 
0cc8			;         jr c,$+4 
0cc8			;           inc l 
0cc8			;           sub c 
0cc8			;         djnz $-7 
0cc8			 
0cc8			; https://plutiedev.com/z80-add-8bit-to-16bit 
0cc8			 
0cc8			addatohl: 
0cc8 85			    add   a, l    ; A = A+L 
0cc9 6f			    ld    l, a    ; L = A+L 
0cca 8c			    adc   a, h    ; A = A+L+H+carry 
0ccb 95			    sub   l       ; A = H+carry 
0ccc 67			    ld    h, a    ; H = H+carry 
0ccd c9			ret 
0cce			 
0cce			addatode: 
0cce 83			    add   a, e    ; A = A+L 
0ccf 5f			    ld    e, a    ; L = A+L 
0cd0 8a			    adc   a, d    ; A = A+L+H+carry 
0cd1 93			    sub   e       ; A = H+carry 
0cd2 57			    ld    d, a    ; H = H+carry 
0cd3 c9			ret 
0cd4			 
0cd4			 
0cd4			addatobc: 
0cd4 81			    add   a, c    ; A = A+L 
0cd5 4f			    ld    c, a    ; L = A+L 
0cd6 88			    adc   a, b    ; A = A+L+H+carry 
0cd7 91			    sub   c       ; A = H+carry 
0cd8 47			    ld    b, a    ; H = H+carry 
0cd9 c9			ret 
0cda			 
0cda			subafromhl: 
0cda			   ; If A=0 do nothing 
0cda			    ; Otherwise flip A's sign. Since 
0cda			    ; the upper byte becomes -1, also 
0cda			    ; substract 1 from H. 
0cda ed 44		    neg 
0cdc ca e5 0c		    jp    z, Skip 
0cdf 25			    dec   h 
0ce0			     
0ce0			    ; Now add the low byte as usual 
0ce0			    ; Two's complement takes care of 
0ce0			    ; ensuring the result is correct 
0ce0 85			    add   a, l 
0ce1 6f			    ld    l, a 
0ce2 8c			    adc   a, h 
0ce3 95			    sub   l 
0ce4 67			    ld    h, a 
0ce5			Skip: 
0ce5 c9				ret 
0ce6			 
0ce6			 
0ce6			; compare hl and de 
0ce6			; returns:  
0ce6			; if hl = de, z=1, s=0, c0=0 
0ce6			; if hl > de, z=0, s=0, c=0 
0ce6			; if hl < de, z=0, s=1, c=1 
0ce6			cmp16:	 
0ce6 b7				or a 
0ce7 ed 52			sbc hl,de 
0ce9 e0				ret po 
0cea 7c				ld a,h 
0ceb 1f				rra 
0cec ee 40			xor 01000000B 
0cee 37				scf 
0cef 8f				adc a,a 
0cf0 c9				ret 
0cf1			 
0cf1			 
0cf1			; test if hl contains zero   - A is destroyed 
0cf1			 
0cf1			ishlzero:    
0cf1 b7				or a     ; reset flags 
0cf2 7c				ld a, h 
0cf3 b5				or l        	 
0cf4			 
0cf4 c9				ret 
0cf5			 
0cf5			 
0cf5			 
0cf5			 
0cf5			if FORTH_ENABLE_FLOATMATH 
0cf5			;include "float/bbcmath.z80" 
0cf5			include "float/lpfpcalc.asm" 
0cf5			endif 
0cf5			 
0cf5			 
0cf5			; eof 
0cf5			 
# End of file firmware_maths.asm
0cf5			include "firmware_strings.asm"   ; string handling  
0cf5			 
0cf5			 
0cf5			; TODO string len 
0cf5			; input text string, end on cr with zero term 
0cf5			; a offset into frame buffer to start prompt 
0cf5			; d is max length 
0cf5			; e is display size TODO 
0cf5			; c is current cursor position 
0cf5			; hl is ptr to where string will be stored 
0cf5			 
0cf5			 
0cf5			; TODO check limit of buffer for new inserts 
0cf5			; TODO check insert does not push beyond buffer 
0cf5			; TODO scroll in a limited display area 
0cf5			; TODO scroll whole screen on page wrap 
0cf5			 
0cf5			 
0cf5			; TODO handle KEY_PREVWORD 
0cf5			; TODO handle KEY_NEXTWORD 
0cf5			; TODO handle KEY_HOME 
0cf5			; TODO handle KEY_END 
0cf5			; TODO use LCD cursor? 
0cf5			 
0cf5 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0cf8 81					add c 
0cf9 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0cfc 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0cff 79					ld a, c 
0d00 cd c8 0c				call addatohl 
0d03 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d06 7a					ld a,d 
0d07 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d0a 79					ld a, c 
0d0b 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d0e 7b					ld a,e 
0d0f 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d12					 
0d12					 
0d12			 
0d12			;		ld a,(input_ptr) 
0d12			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d12			 
0d12			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d12					; init cursor shape if not set by the cin routines 
0d12 21 56 fa				ld hl, cursor_shape 
0d15 3e ff				ld a, 255 
0d17 77					ld (hl), a 
0d18 23					inc hl 
0d19 3e 00				ld a, 0 
0d1b 77					ld (hl), a 
0d1c			 
0d1c 3e 0f				ld a, CUR_BLINK_RATE 
0d1e 32 b2 fb				ld (input_cur_flash), a 
0d21 3e 01				ld a, 1 
0d23 32 b1 fb				ld (input_cur_onoff),a 
0d26			 
0d26			;	if DEBUG_INPUT 
0d26			;		push af 
0d26			;		ld a, 'I' 
0d26			;		ld (debug_mark),a 
0d26			;		pop af 
0d26			;		CALLMONITOR 
0d26			;	endif 
0d26			.is1:		; main entry loop 
0d26			 
0d26			 
0d26			 
0d26					; pause 1ms 
0d26			 
0d26 3e 01				ld a, 1 
0d28 cd 27 0a				call aDelayInMS 
0d2b			 
0d2b					; dec flash counter 
0d2b 3a b2 fb				ld a, (input_cur_flash) 
0d2e 3d					dec a 
0d2f 32 b2 fb				ld (input_cur_flash), a 
0d32 fe 00				cp 0 
0d34 20 0d				jr nz, .nochgstate 
0d36			 
0d36			 
0d36					; change state 
0d36 3a b1 fb				ld a,(input_cur_onoff) 
0d39 ed 44				neg 
0d3b 32 b1 fb				ld (input_cur_onoff),a 
0d3e			 
0d3e			 
0d3e					; reset on change of state 
0d3e 3e 0f				ld a, CUR_BLINK_RATE 
0d40 32 b2 fb				ld (input_cur_flash), a 
0d43			 
0d43			.nochgstate: 
0d43					 
0d43					 
0d43			 
0d43					; display cursor  
0d43			 
0d43			;		ld hl, (input_start) 
0d43			;		ld a, (input_cursor) 
0d43			;		call addatohl 
0d43			 
0d43					; get char under cursor and replace with cursor 
0d43 2a bb fb		ld hl, (input_ptr) 
0d46			;		ld a, (hl) 
0d46			;		ld (input_under_cursor),a 
0d46			;		ld a, '_' 
0d46			;		ld (hl), a 
0d46			 
0d46					; display string 
0d46			 
0d46 ed 5b b9 fb			ld de, (input_start) 
0d4a 3a b6 fb				ld a, (input_at_pos) 
0d4d cd a7 0a				call str_at_display 
0d50			;	        call update_display 
0d50			 
0d50					; find place to put the cursor 
0d50			;		add h 
0d50			;		ld l, display_row_1 
0d50			;		sub l 
0d50			; (input_at_pos) 
0d50					;ld c, a 
0d50			;		ld a, (input_cursor) 
0d50			;		ld l, (input_at_pos) 
0d50			;		;ld b, h 
0d50			;		add l 
0d50			;		ld (input_at_cursor),a 
0d50					;ld l,h 
0d50			 
0d50			;		ld h, 0 
0d50			;		ld l,(input_at_pos) 
0d50			;		ld a, (input_cursor) 
0d50			;		call addatohl 
0d50			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d50			;		call subafromhl 
0d50			;		ld a,l 
0d50			;		ld (input_at_cursor), a 
0d50			 
0d50				if DEBUG_INPUT 
0d50					ld a, (hardware_diag) 
0d50					cp 0 
0d50					jr z, .skip_input_diag 
0d50			 
0d50					ld a,(input_at_pos) 
0d50					ld hl, LFSRSeed 
0d50					call hexout 
0d50					ld a, (input_cursor) 
0d50					ld hl, LFSRSeed+2 
0d50					call hexout 
0d50					ld a,(input_at_cursor) 
0d50					ld hl, LFSRSeed+4 
0d50					call hexout 
0d50			 
0d50					ld a,(input_cur_onoff) 
0d50					ld hl, LFSRSeed+6 
0d50					call hexout 
0d50			 
0d50					ld a,(input_cur_flash) 
0d50					ld hl, LFSRSeed+8 
0d50					call hexout 
0d50			 
0d50					ld a,(input_len) 
0d50					ld hl, LFSRSeed+10 
0d50					call hexout 
0d50					ld hl, LFSRSeed+12 
0d50					ld a, 0 
0d50					ld (hl),a 
0d50					ld a, display_row_4 
0d50					ld de, LFSRSeed 
0d50					call str_at_display 
0d50					.skip_input_diag: 
0d50				endif 
0d50			 
0d50					; decide on if we are showing the cursor this time round 
0d50			 
0d50 3a b1 fb				ld a, (input_cur_onoff) 
0d53 fe ff				cp 255 
0d55 28 13				jr z, .skipcur 
0d57			 
0d57			 
0d57 3a b4 fb				ld a,(input_at_cursor) 
0d5a 11 56 fa				ld de, cursor_shape 
0d5d cd a7 0a				call str_at_display 
0d60			 
0d60					; save length of current input string 
0d60 2a b9 fb				ld hl, (input_start) 
0d63 cd 26 11				call strlenz 
0d66 7d					ld a,l 
0d67 32 ac fb				ld (input_len),a 
0d6a			 
0d6a			.skipcur: 
0d6a			 
0d6a cd b7 0a			        call update_display 
0d6d					 
0d6d			 
0d6d			 
0d6d					; wait 
0d6d				 
0d6d					; TODO loop without wait to flash the cursor and char under cursor	 
0d6d cd da 65				call cin    ; _wait 
0d70			 
0d70 fe 00				cp 0 
0d72 ca 26 0d				jp z, .is1 
0d75			 
0d75					; get ptr to char to input into 
0d75			 
0d75 4f					ld c,a 
0d76 2a b9 fb				ld hl, (input_start) 
0d79 3a a7 fb				ld a, (input_cursor) 
0d7c cd c8 0c				call addatohl 
0d7f 22 bb fb				ld (input_ptr), hl 
0d82 79					ld a,c 
0d83			 
0d83					; replace char under cursor 
0d83			 
0d83			;		ld hl, (input_ptr) 
0d83			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0d83			;		ld (hl), a 
0d83			 
0d83			;	if DEBUG_INPUT 
0d83			;		push af 
0d83			;		ld a, 'i' 
0d83			;		ld (debug_mark),a 
0d83			;		pop af 
0d83			;		CALLMONITOR 
0d83			;	endif 
0d83 fe 0e				cp KEY_HOME 
0d85 20 0e				jr nz, .iske 
0d87			 
0d87 3a b6 fb				ld a, (input_at_pos) 
0d8a 32 b4 fb				ld (input_at_cursor),a 
0d8d 3e 00				ld a, 0 
0d8f 32 a7 fb				ld (input_cursor), a 
0d92 c3 26 0d				jp .is1 
0d95					 
0d95 fe 0f		.iske:		cp KEY_END 
0d97 20 03				jr nz, .isknw 
0d99 c3 26 0d				jp .is1 
0d9c			 
0d9c fe 06		.isknw:		cp KEY_NEXTWORD 
0d9e 20 1b				jr nz, .iskpw 
0da0			 
0da0 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0da3 7e					ld a,(hl)	 
0da4 fe 00				cp 0 
0da6 ca 26 0d				jp z, .is1    ; end of string 
0da9 fe 20				cp ' ' 
0dab ca 26 0d				jp z, .is1    ; end of word 
0dae 23					inc hl 
0daf 22 bb fb				ld (input_ptr), hl 
0db2 3a b4 fb				ld a, (input_at_cursor) 
0db5 3c					inc a 
0db6 32 b4 fb				ld (input_at_cursor), a 
0db9 18 e5				jr .isknwm 
0dbb			 
0dbb fe 07		.iskpw:		cp KEY_PREVWORD 
0dbd 20 1b				jr nz, .iskl 
0dbf			.iskpwm:	 
0dbf 2a bb fb				ld hl, (input_ptr) 
0dc2 7e					ld a,(hl)	 
0dc3 fe 00				cp 0  
0dc5 ca 26 0d				jp z, .is1    ; end of string 
0dc8 fe 20				cp ' ' 
0dca ca 26 0d				jp z, .is1    ; end of word 
0dcd 2b					dec hl 
0dce 22 bb fb				ld (input_ptr), hl 
0dd1 3a b4 fb				ld a, (input_at_cursor) 
0dd4 3d					dec a 
0dd5 32 b4 fb				ld (input_at_cursor), a 
0dd8 18 e5				jr .iskpwm 
0dda			 
0dda			 
0dda fe 0b		.iskl:		cp KEY_LEFT 
0ddc 20 27				jr nz, .isk1 
0dde			 
0dde 3a a7 fb				ld a, (input_cursor) 
0de1			 
0de1 fe 00				cp 0 
0de3 ca 26 0d				jp z, .is1 		; at start of line to ignore  
0de6			 
0de6 3d					dec  a 		; TODO check underflow 
0de7 32 a7 fb				ld (input_cursor), a 
0dea			 
0dea 2a bb fb				ld hl, (input_ptr) 
0ded 2b					dec hl 
0dee 22 bb fb				ld (input_ptr), hl 
0df1					 
0df1 3a b4 fb				ld a, (input_at_cursor) 
0df4 3d					dec a 
0df5 32 b4 fb				ld (input_at_cursor), a 
0df8			 
0df8 3e 01				ld a, 1		; show cursor moving 
0dfa 32 b1 fb				ld (input_cur_onoff),a 
0dfd 3e 0f				ld a, CUR_BLINK_RATE 
0dff 32 b2 fb				ld (input_cur_flash), a 
0e02			 
0e02 c3 26 0d				jp .is1 
0e05			 
0e05 fe 0c		.isk1:		cp KEY_RIGHT 
0e07 20 2a				jr nz, .isk2 
0e09			 
0e09 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e0c 5f					ld e,a 
0e0d 3a a7 fb				ld a, (input_cursor) 
0e10 bb					cp e 
0e11 ca 26 0d				jp z, .is1		; at the end of string so dont go right 
0e14			 
0e14 3c					inc  a 		; TODO check overflow 
0e15 32 a7 fb				ld (input_cursor), a 
0e18			 
0e18 3a b4 fb				ld a, (input_at_cursor) 
0e1b 3c					inc a 
0e1c 32 b4 fb				ld (input_at_cursor), a 
0e1f			 
0e1f 2a bb fb				ld hl, (input_ptr) 
0e22 23					inc hl 
0e23 22 bb fb				ld (input_ptr), hl 
0e26			 
0e26 3e 01				ld a, 1		; show cursor moving 
0e28 32 b1 fb				ld (input_cur_onoff),a 
0e2b 3e 0f				ld a, CUR_BLINK_RATE 
0e2d 32 b2 fb				ld (input_cur_flash), a 
0e30			 
0e30 c3 26 0d				jp .is1 
0e33			 
0e33 fe 05		.isk2:		cp KEY_UP 
0e35			 
0e35 20 26				jr nz, .isk3 
0e37			 
0e37					; swap last command with the current on 
0e37			 
0e37					; move cursor to start of string 
0e37 2a b9 fb				ld hl, (input_start) 
0e3a 22 bb fb				ld (input_ptr), hl 
0e3d			 
0e3d 3a b6 fb				ld a, (input_at_pos) 
0e40 32 b4 fb				ld (input_at_cursor), a 
0e43			 
0e43 3e 00				ld a, 0 
0e45 32 a7 fb				ld (input_cursor), a 
0e48					 
0e48					; swap input and last command buffers 
0e48			 
0e48 21 ca f2				ld hl, os_cli_cmd 
0e4b 11 c9 f3				ld de, os_last_cmd 
0e4e 06 ff				ld b, 255 
0e50 7e			.swap1:		ld a, (hl) 
0e51 4f					ld c,a 
0e52 1a					ld a, (de) 
0e53 77					ld (hl), a 
0e54 79					ld a,c 
0e55 12					ld (de),a 
0e56 23					inc hl 
0e57 13					inc de 
0e58 10 f6				djnz .swap1 
0e5a			 
0e5a			 
0e5a			 
0e5a			 
0e5a			 
0e5a c3 26 0d				jp .is1 
0e5d			 
0e5d fe 08		.isk3:		cp KEY_BS 
0e5f 20 3c				jr nz, .isk4 
0e61			 
0e61 3a a7 fb				ld a, (input_cursor) 
0e64			 
0e64 fe 00				cp 0 
0e66 ca 26 0d				jp z, .is1 		; at start of line to ignore  
0e69			 
0e69 3d					dec  a 		; TODO check underflow 
0e6a 32 a7 fb				ld (input_cursor), a 
0e6d			 
0e6d					; hl is source 
0e6d					; de needs to be source - 1 
0e6d			 
0e6d			;		ld a, 0 
0e6d			;		dec hl 
0e6d			;		ld (hl), a 
0e6d			 
0e6d 2a bb fb				ld hl, (input_ptr) 
0e70 2b					dec hl 
0e71 22 bb fb				ld (input_ptr), hl 
0e74			 
0e74					; shift all data 
0e74			 
0e74 e5					push hl 
0e75 23					inc hl 
0e76 d1					pop de 
0e77 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0e7a 4f					ld c,a 
0e7b 06 00				ld b,0 
0e7d ed b0				ldir  
0e7f			 
0e7f			 
0e7f			 
0e7f			 
0e7f 3a b4 fb				ld a, (input_at_cursor) 
0e82 3d					dec a 
0e83 32 b4 fb				ld (input_at_cursor), a 
0e86			 
0e86			 
0e86 3e 01				ld a, 1		; show cursor moving 
0e88 32 b1 fb				ld (input_cur_onoff),a 
0e8b 3e 0f				ld a, CUR_BLINK_RATE 
0e8d 32 b2 fb				ld (input_cur_flash), a 
0e90			 
0e90					; remove char 
0e90 3a b4 fb				ld a, (input_at_cursor) 
0e93 3c					inc a 
0e94 11 1e 0f				ld de,.iblank 
0e97 cd a7 0a				call str_at_display 
0e9a			 
0e9a c3 26 0d				jp .is1 
0e9d			 
0e9d fe 0d		.isk4:		cp KEY_CR 
0e9f 28 6c				jr z, .endinput 
0ea1			 
0ea1					; else add the key press to the end 
0ea1			 
0ea1 4f					ld c, a			; save key pressed 
0ea2			 
0ea2 7e					ld a,(hl)		; get what is currently under char 
0ea3			 
0ea3 fe 00				cp 0			; we are at the end of the string 
0ea5 20 2f				jr nz, .onchar 
0ea7					 
0ea7					; add a char to the end of the string 
0ea7				 
0ea7 71					ld (hl),c 
0ea8 23					inc hl 
0ea9			;		ld a,' ' 
0ea9			;		ld (hl),a 
0ea9			;		inc hl 
0ea9 3e 00				ld a,0 
0eab 77					ld (hl),a 
0eac 2b					dec hl 
0ead			 
0ead 3a a7 fb				ld a, (input_cursor) 
0eb0 3c					inc a				; TODO check max string length and scroll  
0eb1 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0eb4							 
0eb4 3a b4 fb				ld a, (input_at_cursor) 
0eb7 3c					inc a 
0eb8 32 b4 fb				ld (input_at_cursor), a 
0ebb			 
0ebb 2a bb fb				ld hl, (input_ptr) 
0ebe 23					inc hl 
0ebf 22 bb fb				ld (input_ptr), hl 
0ec2			 
0ec2 2a bb fb				ld hl, (input_ptr) 
0ec5 23					inc hl 
0ec6 22 bb fb				ld (input_ptr), hl 
0ec9			;	if DEBUG_INPUT 
0ec9			;		push af 
0ec9			;		ld a, '+' 
0ec9			;		ld (debug_mark),a 
0ec9			;		pop af 
0ec9			;		CALLMONITOR 
0ec9			;	endif 
0ec9 3e 01				ld a, 1		; show cursor moving 
0ecb 32 b1 fb				ld (input_cur_onoff),a 
0ece 3e 0f				ld a, CUR_BLINK_RATE 
0ed0 32 b2 fb				ld (input_cur_flash), a 
0ed3 c3 26 0d				jp .is1 
0ed6					 
0ed6			 
0ed6			 
0ed6					; if on a char then insert 
0ed6			.onchar: 
0ed6			 
0ed6					; TODO over flow check: make sure insert does not blow out buffer 
0ed6			 
0ed6					; need to do some maths to use lddr 
0ed6			 
0ed6 e5					push hl   ; save char pos 
0ed7 c5					push bc 
0ed8			 
0ed8 2a b9 fb				ld hl, (input_start) 
0edb 3a ac fb				ld a, (input_len) 
0ede cd c8 0c				call addatohl  		; end of string 
0ee1 23					inc hl 
0ee2 23					inc hl		; past zero term 
0ee3 e5					push hl 
0ee4 23					inc hl 
0ee5 e5					push hl  
0ee6			 
0ee6								; start and end of lddr set, now how much to move? 
0ee6			 
0ee6							 
0ee6 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ee9 47					ld b,a 
0eea 3a ac fb				ld a,(input_len) 
0eed 5f					ld e,a 
0eee 90					sub b 
0eef 3c					inc a		;?? 
0ef0 3c					inc a		;?? 
0ef1 3c					inc a		;?? 
0ef2			 
0ef2 06 00				ld b,0 
0ef4 4f					ld c,a 
0ef5			 
0ef5				if DEBUG_INPUT 
0ef5					push af 
0ef5					ld a, 'i' 
0ef5					ld (debug_mark),a 
0ef5					pop af 
0ef5			;		CALLMONITOR 
0ef5				endif 
0ef5 d1					pop de 
0ef6 e1					pop hl 
0ef7				if DEBUG_INPUT 
0ef7					push af 
0ef7					ld a, 'I' 
0ef7					ld (debug_mark),a 
0ef7					pop af 
0ef7			;		CALLMONITOR 
0ef7				endif 
0ef7 ed b8				lddr 
0ef9				 
0ef9			 
0ef9			 
0ef9					; TODO have a key for insert/overwrite mode???? 
0ef9 c1					pop bc 
0efa e1					pop hl 
0efb 71					ld (hl), c		; otherwise overwrite current char 
0efc					 
0efc			 
0efc			 
0efc			 
0efc 3a a7 fb				ld a, (input_cursor) 
0eff 3c					inc  a 		; TODO check overflow 
0f00 32 a7 fb				ld (input_cursor), a 
0f03			 
0f03 3a b4 fb				ld a, (input_at_cursor) 
0f06 3c					inc a 
0f07 32 b4 fb				ld (input_at_cursor), a 
0f0a			 
0f0a c3 26 0d				jp .is1 
0f0d			 
0f0d			.endinput:	; TODO look for end of string 
0f0d			 
0f0d					; add trailing space for end of token 
0f0d			 
0f0d 2a b9 fb				ld hl, (input_start) 
0f10 3a ac fb				ld a,(input_len) 
0f13 cd c8 0c				call addatohl 
0f16 3e 20				ld a, ' ' 
0f18 77					ld (hl),a 
0f19					; TODO eof of parse marker 
0f19			 
0f19 23					inc hl 
0f1a 3e 00				ld a, 0 
0f1c 77					ld (hl),a 
0f1d			 
0f1d			 
0f1d c9					ret 
0f1e			 
0f1e .. 00		.iblank: db " ",0 
0f20			 
0f20			 
0f20 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f23 22 b9 fb				ld (input_start), hl 
0f26 3e 01				ld a,1			; add cursor 
0f28 77					ld (hl),a 
0f29 23					inc hl 
0f2a 3e 00				ld a,0 
0f2c 77					ld (hl),a 
0f2d 22 bb fb				ld (input_ptr), hl 
0f30 7a					ld a,d 
0f31 32 b8 fb				ld (input_size), a 
0f34 3e 00				ld a,0 
0f36 32 a7 fb				ld (input_cursor),a 
0f39			.instr1:	 
0f39			 
0f39					; TODO do block cursor 
0f39					; TODO switch cursor depending on the modifer key 
0f39			 
0f39					; update cursor shape change on key hold 
0f39			 
0f39 2a bb fb				ld hl, (input_ptr) 
0f3c 2b					dec hl 
0f3d 3a 56 fa				ld a,(cursor_shape) 
0f40 77					ld (hl), a 
0f41			 
0f41					; display entered text 
0f41 3a b6 fb				ld a,(input_at_pos) 
0f44 cd f8 64		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f47 ed 5b b9 fb	            	LD   de, (input_start) 
0f4b cd 00 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f4e			 
0f4e cd da 65				call cin 
0f51 fe 00				cp 0 
0f53 28 e4				jr z, .instr1 
0f55			 
0f55					; proecess keyboard controls first 
0f55			 
0f55 2a bb fb				ld hl,(input_ptr) 
0f58			 
0f58 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f5a 28 5a				jr z, .instrcr 
0f5c			 
0f5c fe 08				cp KEY_BS 	; back space 
0f5e 20 0f				jr nz, .instr2 
0f60					; process back space 
0f60			 
0f60					; TODO stop back space if at start of string 
0f60 2b					dec hl 
0f61 2b					dec hl ; to over write cursor 
0f62 3a 56 fa				ld a,(cursor_shape) 
0f65					;ld a,0 
0f65 77					ld (hl),a 
0f66 23					inc hl 
0f67 3e 20				ld a," " 
0f69 77					ld (hl),a 
0f6a 22 bb fb				ld (input_ptr),hl 
0f6d					 
0f6d			 
0f6d 18 ca				jr .instr1 
0f6f			 
0f6f fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0f71 20 06				jr nz, .instr3 
0f73 2b					dec hl 
0f74 22 bb fb				ld (input_ptr),hl 
0f77 18 c0				jr .instr1 
0f79				 
0f79 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0f7b 20 06				jr nz, .instr4 
0f7d 23					inc hl 
0f7e 22 bb fb				ld (input_ptr),hl 
0f81 18 b6				jr .instr1 
0f83			 
0f83 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0f85 20 06				jr nz, .instr5 
0f87 2b					dec hl 
0f88 22 bb fb				ld (input_ptr),hl 
0f8b 18 ac				jr .instr1 
0f8d			 
0f8d fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0f8f 20 06				jr nz, .instr6 
0f91 2b					dec hl 
0f92 22 bb fb				ld (input_ptr),hl 
0f95 18 a2				jr .instr1 
0f97 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0f99 20 0b				jr nz, .instrnew 
0f9b			 
0f9b 21 a3 ef			ld hl, scratch 
0f9e 11 c9 f3			ld de, os_last_cmd 
0fa1 cd bf 0f			call strcpy 
0fa4 18 93				jr .instr1 
0fa6			 
0fa6			 
0fa6			.instrnew:	; no special key pressed to see if we have room to store it 
0fa6			 
0fa6					; TODO do string size test 
0fa6			 
0fa6 2b					dec hl ; to over write cursor 
0fa7 77					ld (hl),a 
0fa8 23					inc hl 
0fa9 3a 56 fa				ld a,(cursor_shape) 
0fac 77					ld (hl),a 
0fad 23					inc hl 
0fae 3e 00				ld a,0 
0fb0 77					ld (hl),a 
0fb1			 
0fb1 22 bb fb				ld (input_ptr),hl 
0fb4					 
0fb4 18 83				jr .instr1 
0fb6 2b			.instrcr:	dec hl		; remove cursor 
0fb7 3e 20				ld a,' '	; TODO add a trailing space for safety 
0fb9 77					ld (hl),a 
0fba 23					inc hl 
0fbb 3e 00				ld a,0 
0fbd 77					ld (hl),a 
0fbe			 
0fbe			 
0fbe					; if at end of line scroll up    
0fbe					; TODO detecting only end of line 4 for scroll up  
0fbe			 
0fbe					;ld   
0fbe			 
0fbe c9					ret 
0fbf			 
0fbf			 
0fbf			; strcpy hl = dest, de source 
0fbf			 
0fbf 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fc0 b7			            OR   A              ;Null terminator? 
0fc1 c8			            RET  Z              ;Yes, so finished 
0fc2 1a					ld a,(de) 
0fc3 77					ld (hl),a 
0fc4 13			            INC  DE             ;Point to next character 
0fc5 23					inc hl 
0fc6 18 f7		            JR   strcpy       ;Repeat 
0fc8 c9					ret 
0fc9			 
0fc9			 
0fc9			; TODO string_at  
0fc9			; pass string which starts with lcd offset address and then null term string 
0fc9			 
0fc9			; TODO string to dec 
0fc9			; TODO string to hex 
0fc9			; TODO byte to string hex 
0fc9			; TODO byte to string dec 
0fc9			 
0fc9			 
0fc9			 
0fc9			; from z80uartmonitor 
0fc9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fc9			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fc9			; pass hl for where to put the text 
0fc9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fc9 c5			hexout:	PUSH BC 
0fca f5					PUSH AF 
0fcb 47					LD B, A 
0fcc					; Upper nybble 
0fcc cb 3f				SRL A 
0fce cb 3f				SRL A 
0fd0 cb 3f				SRL A 
0fd2 cb 3f				SRL A 
0fd4 cd e4 0f				CALL tohex 
0fd7 77					ld (hl),a 
0fd8 23					inc hl	 
0fd9					 
0fd9					; Lower nybble 
0fd9 78					LD A, B 
0fda e6 0f				AND 0FH 
0fdc cd e4 0f				CALL tohex 
0fdf 77					ld (hl),a 
0fe0 23					inc hl	 
0fe1					 
0fe1 f1					POP AF 
0fe2 c1					POP BC 
0fe3 c9					RET 
0fe4					 
0fe4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fe4			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0fe4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fe4			tohex: 
0fe4 e5					PUSH HL 
0fe5 d5					PUSH DE 
0fe6 16 00				LD D, 0 
0fe8 5f					LD E, A 
0fe9 21 f1 0f				LD HL, .DATA 
0fec 19					ADD HL, DE 
0fed 7e					LD A, (HL) 
0fee d1					POP DE 
0fef e1					POP HL 
0ff0 c9					RET 
0ff1			 
0ff1			.DATA: 
0ff1 30					DEFB	30h	; 0 
0ff2 31					DEFB	31h	; 1 
0ff3 32					DEFB	32h	; 2 
0ff4 33					DEFB	33h	; 3 
0ff5 34					DEFB	34h	; 4 
0ff6 35					DEFB	35h	; 5 
0ff7 36					DEFB	36h	; 6 
0ff8 37					DEFB	37h	; 7 
0ff9 38					DEFB	38h	; 8 
0ffa 39					DEFB	39h	; 9 
0ffb 41					DEFB	41h	; A 
0ffc 42					DEFB	42h	; B 
0ffd 43					DEFB	43h	; C 
0ffe 44					DEFB	44h	; D 
0fff 45					DEFB	45h	; E 
1000 46					DEFB	46h	; F 
1001			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1001			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1001			;;    subtract $30, if result > 9 then subtract $7 more 
1001			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1001			atohex: 
1001 d6 30				SUB $30 
1003 fe 0a				CP 10 
1005 f8					RET M		; If result negative it was 0-9 so we're done 
1006 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1008 c9					RET		 
1009			 
1009			 
1009			 
1009			 
1009			; Get 2 ASCII characters as hex byte from pointer in hl 
1009			 
1009			BYTERD: 
1009 16 00			LD	D,00h		;Set up 
100b cd 13 10			CALL	HEXCON		;Get byte and convert to hex 
100e 87				ADD	A,A		;First nibble so 
100f 87				ADD	A,A		;multiply by 16 
1010 87				ADD	A,A		; 
1011 87				ADD	A,A		; 
1012 57				LD	D,A		;Save hi nibble in D 
1013			HEXCON: 
1013 7e				ld a, (hl)		;Get next chr 
1014 23				inc hl 
1015 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1017 fe 0a			CP	00Ah		;Is it 0-9 ? 
1019 38 02			JR	C,NALPHA	;If so miss next bit 
101b d6 07			SUB	007h		;Else convert alpha 
101d			NALPHA: 
101d b2				OR	D		;Add hi nibble back 
101e c9				RET			; 
101f			 
101f			 
101f			; 
101f			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
101f			; Since the routines get_byte and therefore get_nibble are called, only valid 
101f			; characters (0-9a-f) are accepted. 
101f			; 
101f			;get_word        push    af 
101f			;                call    get_byte        ; Get the upper byte 
101f			;                ld      h, a 
101f			;                call    get_byte        ; Get the lower byte 
101f			;                ld      l, a 
101f			;                pop     af 
101f			;                ret 
101f			; 
101f			; Get a byte in hexadecimal notation. The result is returned in A. Since 
101f			; the routine get_nibble is used only valid characters are accepted - the  
101f			; input routine only accepts characters 0-9a-f. 
101f			; 
101f c5			get_byte:        push    bc              ; Save contents of B (and C) 
1020 7e					ld a,(hl) 
1021 23					inc hl 
1022 cd 47 10		                call    nibble2val      ; Get upper nibble 
1025 cb 07		                rlc     a 
1027 cb 07		                rlc     a 
1029 cb 07		                rlc     a 
102b cb 07		                rlc     a 
102d 47			                ld      b, a            ; Save upper four bits 
102e 7e					ld a,(hl) 
102f cd 47 10		                call    nibble2val      ; Get lower nibble 
1032 b0			                or      b               ; Combine both nibbles 
1033 c1			                pop     bc              ; Restore B (and C) 
1034 c9			                ret 
1035			; 
1035			; Get a hexadecimal digit from the serial line. This routine blocks until 
1035			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1035			; to the serial line interface. The lower 4 bits of A contain the value of  
1035			; that particular digit. 
1035			; 
1035			;get_nibble      ld a,(hl)           ; Read a character 
1035			;                call    to_upper        ; Convert to upper case 
1035			;                call    is_hex          ; Was it a hex digit? 
1035			;                jr      nc, get_nibble  ; No, get another character 
1035			 ;               call    nibble2val      ; Convert nibble to value 
1035			 ;               call    print_nibble 
1035			 ;               ret 
1035			; 
1035			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1035			; A valid hexadecimal digit is denoted by a set C flag. 
1035			; 
1035			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1035			;                ret     nc              ; Yes 
1035			;                cp      '0'             ; Less than '0'? 
1035			;                jr      nc, is_hex_1    ; No, continue 
1035			;                ccf                     ; Complement carry (i.e. clear it) 
1035			;                ret 
1035			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1035			;                ret     c               ; Yes 
1035			;                cp      'A'             ; Less than 'A'? 
1035			;                jr      nc, is_hex_2    ; No, continue 
1035			;                ccf                     ; Yes - clear carry and return 
1035			;                ret 
1035			;is_hex_2        scf                     ; Set carry 
1035			;                ret 
1035			; 
1035			; Convert a single character contained in A to upper case: 
1035			; 
1035 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1037 d8			                ret     c 
1038 fe 7b		                cp      'z' + 1         ; > 'z'? 
103a d0			                ret     nc              ; Nothing to do, either 
103b e6 5f		                and     $5f             ; Convert to upper case 
103d c9			                ret 
103e			 
103e			 
103e			to_lower: 
103e			 
103e			   ; if char is in [A-Z] make it lower case 
103e			 
103e			   ; enter : a = char 
103e			   ; exit  : a = lower case char 
103e			   ; uses  : af 
103e			 
103e fe 41		   cp 'A' 
1040 d8			   ret c 
1041			    
1041 fe 5b		   cp 'Z'+1 
1043 d0			   ret nc 
1044			    
1044 f6 20		   or $20 
1046 c9			   ret 
1047			 
1047			; 
1047			; Expects a hexadecimal digit (upper case!) in A and returns the 
1047			; corresponding value in A. 
1047			; 
1047 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1049 38 02		                jr      c, nibble2val_1 ; Yes 
104b d6 07		                sub     7               ; Adjust for A-F 
104d d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
104f e6 0f		                and     $f              ; Only return lower 4 bits 
1051 c9			                ret 
1052			; 
1052			; Print_nibble prints a single hex nibble which is contained in the lower  
1052			; four bits of A: 
1052			; 
1052			;print_nibble    push    af              ; We won't destroy the contents of A 
1052			;                and     $f              ; Just in case... 
1052			;                add     a, '0'             ; If we have a digit we are done here. 
1052			;                cp      '9' + 1         ; Is the result > 9? 
1052			;                jr      c, print_nibble_1 
1052			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1052			;print_nibble_1  call    putc            ; Print the nibble and 
1052			;                pop     af              ; restore the original value of A 
1052			;                ret 
1052			;; 
1052			;; Send a CR/LF pair: 
1052			; 
1052			;crlf            push    af 
1052			;                ld      a, cr 
1052			;                call    putc 
1052			;                ld      a, lf 
1052			;                call    putc 
1052			;                pop     af 
1052			;                ret 
1052			; 
1052			; Print_word prints the four hex digits of a word to the serial line. The  
1052			; word is expected to be in HL. 
1052			; 
1052			;print_word      push    hl 
1052			;                push    af 
1052			;                ld      a, h 
1052			;                call    print_byte 
1052			;                ld      a, l 
1052			;                call    print_byte 
1052			;                pop     af 
1052			;                pop     hl 
1052			;                ret 
1052			; 
1052			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1052			; The byte to be printed is expected to be in A. 
1052			; 
1052			;print_byte      push    af              ; Save the contents of the registers 
1052			;                push    bc 
1052			;                ld      b, a 
1052			;                rrca 
1052			;                rrca 
1052			;                rrca 
1052			;                rrca 
1052			;                call    print_nibble    ; Print high nibble 
1052			;                ld      a, b 
1052			;                call    print_nibble    ; Print low nibble 
1052			;                pop     bc              ; Restore original register contents 
1052			;                pop     af 
1052			;                ret 
1052			 
1052			 
1052			 
1052			 
1052			 
1052			fourehexhl:  
1052 7e				ld a,(hl) 
1053 cd 01 10			call atohex 
1056 cb 3f				SRL A 
1058 cb 3f				SRL A 
105a cb 3f				SRL A 
105c cb 3f				SRL A 
105e 47				ld b, a 
105f 23				inc hl 
1060 7e				ld a,(hl) 
1061 23				inc hl 
1062 cd 01 10			call atohex 
1065 80				add b 
1066 57				ld d,a 
1067 7e				ld a,(hl) 
1068 cd 01 10			call atohex 
106b cb 3f				SRL A 
106d cb 3f				SRL A 
106f cb 3f				SRL A 
1071 cb 3f				SRL A 
1073 47				ld b, a 
1074 23				inc hl 
1075 7e				ld a,(hl) 
1076 23				inc hl 
1077 cd 01 10			call atohex 
107a 80				add b 
107b 5f				ld e, a 
107c d5				push de 
107d e1				pop hl 
107e c9				ret 
107f			 
107f			; pass hl. returns z set if the byte at hl is a digit 
107f			;isdigithl:  
107f			;	push bc 
107f			;	ld a,(hl) 
107f			;	cp ':' 
107f			;	jr nc, .isdf 		; > 
107f			;	cp '0' 
107f			;	jr c, .isdf		; < 
107f			; 
107f			;	; TODO find a better way to set z 
107f			; 
107f			;	ld b,a 
107f			;	cp b 
107f			;	pop bc 
107f			;	ret 
107f			; 
107f			;.isdf:	; not digit so clear z 
107f			; 
107f			;	; TODO find a better way to unset z 
107f			; 
107f			;	ld b,a 
107f			;	inc b 
107f			;	cp b 
107f			; 
107f			;	pop bc 
107f			;	ret 
107f				 
107f				 
107f			 
107f			 
107f			; pass hl as the four byte address to load 
107f			 
107f			get_word_hl:  
107f e5				push hl 
1080 cd 1f 10			call get_byte 
1083				 
1083 47				ld b, a 
1084			 
1084 e1				pop hl 
1085 23				inc hl 
1086 23				inc hl 
1087			 
1087			; TODO not able to handle a-f  
1087 7e				ld a,(hl) 
1088			;	;cp ':' 
1088			;	cp 'g' 
1088			;	jr nc, .single_byte_hl 		; > 
1088			;	cp 'G' 
1088			;	jr nc, .single_byte_hl 		; > 
1088			;	cp '0' 
1088			;	jr c, .single_byte_hl		; < 
1088			 
1088				;call isdigithl 
1088 fe 00			cp 0 
108a 28 06			jr z, .single_byte_hl 
108c			 
108c			.getwhln:   ; hex word so get next byte 
108c			 
108c cd 1f 10			call get_byte 
108f 6f				ld l, a 
1090 60				ld h,b 
1091 c9				ret 
1092 68			.single_byte_hl:   ld l,b 
1093 26 00				ld h,0 
1095 c9					ret 
1096			 
1096			 
1096			 
1096			 
1096 21 8e 18			ld hl,asc+1 
1099			;	ld a, (hl) 
1099			;	call nibble2val 
1099 cd 1f 10			call get_byte 
109c			 
109c			;	call fourehexhl 
109c 32 d7 ef			ld (scratch+52),a 
109f				 
109f 21 d5 ef			ld hl,scratch+50 
10a2 22 c6 f2			ld (os_cur_ptr),hl 
10a5			 
10a5 c9				ret 
10a6			 
10a6			 
10a6			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10a6			 
10a6			; Decimal Unsigned Version 
10a6			 
10a6			;Number in a to decimal ASCII 
10a6			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10a6			;Example: display a=56 as "056" 
10a6			;input: a = number 
10a6			;Output: a=0,value of a in the screen 
10a6			;destroys af,bc (don't know about hl and de) 
10a6			DispAToASCII: 
10a6 0e 9c			ld	c,-100 
10a8 cd b2 10			call	.Na1 
10ab 0e f6			ld	c,-10 
10ad cd b2 10			call	.Na1 
10b0 0e ff			ld	c,-1 
10b2 06 2f		.Na1:	ld	b,'0'-1 
10b4 04			.Na2:	inc	b 
10b5 81				add	a,c 
10b6 38 fc			jr	c,.Na2 
10b8 91				sub	c		;works as add 100/10/1 
10b9 f5				push af		;safer than ld c,a 
10ba 78				ld	a,b		;char is in b 
10bb			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10bb f1				pop af		;safer than ld a,c 
10bc c9				ret 
10bd			 
10bd			; Decimal Signed Version 
10bd			 
10bd			; DispA 
10bd			; -------------------------------------------------------------- 
10bd			; Converts a signed integer value to a zero-terminated ASCII 
10bd			; string representative of that value (using radix 10). 
10bd			; -------------------------------------------------------------- 
10bd			; INPUTS: 
10bd			;     HL     Value to convert (two's complement integer). 
10bd			;     DE     Base address of string destination. (pointer). 
10bd			; -------------------------------------------------------------- 
10bd			; OUTPUTS: 
10bd			;     None 
10bd			; -------------------------------------------------------------- 
10bd			; REGISTERS/MEMORY DESTROYED 
10bd			; AF HL 
10bd			; -------------------------------------------------------------- 
10bd			 
10bd			;DispHLToASCII: 
10bd			;   push    de 
10bd			;   push    bc 
10bd			; 
10bd			;; Detect sign of HL. 
10bd			;    bit    7, h 
10bd			;    jr     z, ._DoConvert 
10bd			; 
10bd			;; HL is negative. Output '-' to string and negate HL. 
10bd			;    ld     a, '-' 
10bd			;    ld     (de), a 
10bd			;    inc    de 
10bd			; 
10bd			;; Negate HL (using two's complement) 
10bd			;    xor    a 
10bd			;    sub    l 
10bd			;    ld     l, a 
10bd			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10bd			;    sbc    a, h 
10bd			;    ld     h, a 
10bd			; 
10bd			;; Convert HL to digit characters 
10bd			;._DoConvert: 
10bd			;    ld     b, 0     ; B will count character length of number 
10bd			;-   ld     a, 10 
10bd			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10bd			;    push   af 
10bd			;    inc    b 
10bd			;    ld     a, h 
10bd			;    or     l 
10bd			;    jr     nz, - 
10bd			; 
10bd			;; Retrieve digits from stack 
10bd			;-   pop    af 
10bd			;    or     $30 
10bd			;    ld     (de), a 
10bd			;    inc    de 
10bd			;    djnz   - 
10bd			; 
10bd			;; Terminate string with NULL 
10bd			;    xor    a 
10bd			;    ld     (de), a 
10bd			; 
10bd			;    pop    bc 
10bd			;    pop    de 
10bd			;    ret 
10bd			 
10bd			;Comments 
10bd			; 
10bd			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10bd			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10bd			;    Note that the output string will not be fixed-width. 
10bd			; 
10bd			;Example Usage 
10bd			; 
10bd			;    ld    hl, -1004 
10bd			;    ld    de, OP1 
10bd			;    call  DispA 
10bd			;    ld    hl, OP1 
10bd			;    syscall  PutS 
10bd			 
10bd			 
10bd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10bd			 
10bd			 
10bd			;Converts an ASCII string to an unsigned 16-bit integer 
10bd			;Quits when it reaches a non-decimal digit 
10bd			 
10bd			string_to_uint16: 
10bd			atoui_16: 
10bd			;Input: 
10bd			;     DE points to the string 
10bd			;Outputs: 
10bd			;     HL is the result 
10bd			;     A is the 8-bit value of the number 
10bd			;     DE points to the byte after the number 
10bd			;Destroys: 
10bd			;     BC 
10bd			;       if the string is non-empty, BC is HL/10 
10bd			;Size:  24 bytes 
10bd			;Speed: 42+d(104+{0,9}) 
10bd			;       d is the number of digits in the number 
10bd			;       max is 640 cycles for a 5 digit number 
10bd			;Assuming no leading zeros: 
10bd			;1 digit:  146cc 
10bd			;2 digit:  250cc 
10bd			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10bd			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10bd			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10bd			;avg: 544.81158447265625cc (544+13297/16384) 
10bd			;=============================================================== 
10bd 21 00 00		  ld hl,0 
10c0			.u16a: 
10c0 1a			  ld a,(de) 
10c1 d6 30		  sub 30h 
10c3 fe 0a		  cp 10 
10c5 d0			  ret nc 
10c6 13			  inc de 
10c7 44			  ld b,h 
10c8 4d			  ld c,l 
10c9 29			  add hl,hl 
10ca 29			  add hl,hl 
10cb 09			  add hl,bc 
10cc 29			  add hl,hl 
10cd 85			  add a,l 
10ce 6f			  ld l,a 
10cf 30 ef		  jr nc,.u16a 
10d1 24			  inc h 
10d2 c3 c0 10		  jp .u16a 
10d5			 
10d5			 
10d5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10d5			 
10d5			;written by Zeda 
10d5			;Converts a 16-bit unsigned integer to an ASCII string. 
10d5			 
10d5			uitoa_16: 
10d5			;Input: 
10d5			;   DE is the number to convert 
10d5			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10d5			;Output: 
10d5			;   HL points to the null-terminated ASCII string 
10d5			;      NOTE: This isn't necessarily the same as the input HL. 
10d5 d5			  push de 
10d6 c5			  push bc 
10d7 f5			  push af 
10d8 eb			  ex de,hl 
10d9			 
10d9 01 f0 d8		  ld bc,-10000 
10dc 3e 2f		  ld a,'0'-1 
10de 3c			  inc a 
10df 09			  add hl,bc  
10e0 38 fc		   jr c,$-2 
10e2 12			  ld (de),a 
10e3 13			  inc de 
10e4			 
10e4 01 e8 03		  ld bc,1000 
10e7 3e 3a		  ld a,'9'+1 
10e9 3d			  dec a  
10ea 09			  add hl,bc  
10eb 30 fc		   jr nc,$-2 
10ed 12			  ld (de),a 
10ee 13			  inc de 
10ef			 
10ef 01 9c ff		  ld bc,-100 
10f2 3e 2f		  ld a,'0'-1 
10f4 3c			  inc a  
10f5 09			  add hl,bc  
10f6 38 fc		   jr c,$-2 
10f8 12			  ld (de),a 
10f9 13			  inc de 
10fa			 
10fa 7d			  ld a,l 
10fb 26 3a		  ld h,'9'+1 
10fd 25			  dec h  
10fe c6 0a		  add a,10  
1100 30 fb		   jr nc,$-3 
1102 c6 30		  add a,'0' 
1104 eb			  ex de,hl 
1105 72			  ld (hl),d 
1106 23			  inc hl 
1107 77			  ld (hl),a 
1108 23			  inc hl 
1109 36 00		  ld (hl),0 
110b			 
110b			;Now strip the leading zeros 
110b 0e fa		  ld c,-6 
110d 09			  add hl,bc 
110e 3e 30		  ld a,'0' 
1110 23			  inc hl  
1111 be			  cp (hl)  
1112 28 fc		  jr z,$-2 
1114			 
1114			;Make sure that the string is non-empty! 
1114 7e			  ld a,(hl) 
1115 b7			  or a 
1116 20 01		  jr nz,.atoub 
1118 2b			  dec hl 
1119			.atoub: 
1119			 
1119 f1			  pop af 
111a c1			  pop bc 
111b d1			  pop de 
111c c9			  ret 
111d			 
111d			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
111d			 
111d			toUpper: 
111d			;A is the char. 
111d			;If A is a lowercase letter, this sets it to the matching uppercase 
111d			;18cc or 30cc or 41cc 
111d			;avg: 26.75cc 
111d fe 61		  cp 'a' 
111f d8			  ret c 
1120 fe 7b		  cp 'z'+1 
1122 d0			  ret nc 
1123 d6 20		  sub 'a'-'A' 
1125 c9			  ret 
1126			 
1126			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1126			 
1126			; String Length 
1126			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1126			 
1126			; Get the length of the null-terminated string starting at $8000 hl 
1126			;    LD     HL, $8000 
1126			 
1126			strlenz: 
1126			 
1126 af			    XOR    A               ; Zero is the value we are looking for. 
1127 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1128 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1129			                           ; 65, 536 bytes (the entire addressable memory space). 
1129 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
112b			 
112b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
112b 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
112c 6f			    LD     L, A             ; number of bytes 
112d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
112f 2b			    DEC    HL              ; Compensate for null. 
1130 c9				ret 
1131			 
1131			; Get the length of the A terminated string starting at $8000 hl 
1131			;    LD     HL, $8000 
1131			 
1131			strlent: 
1131			 
1131			                  ; A is the value we are looking for. 
1131 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1133 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1135			                           ; 65, 536 bytes (the entire addressable memory space). 
1135 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1137			 
1137			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1137 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1139 2e 00		    LD     L, 0             ; number of bytes 
113b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
113d 2b			    DEC    HL              ; Compensate for null. 
113e c9				ret 
113f			 
113f			 
113f			;Comparing Strings 
113f			 
113f			;IN    HL     Address of string1. 
113f			;      DE     Address of string2. 
113f			 
113f			; doc given but wrong??? 
113f			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
113f			;      carry  Set if string1 > string2, reset if string1 <= string2. 
113f			; tested 
113f			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
113f			 
113f			strcmp_old: 
113f e5			    PUSH   HL 
1140 d5			    PUSH   DE 
1141			 
1141 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1142 be			    CP     (HL)            ; (want to minimize work). 
1143 38 01		    JR     C, Str1IsBigger 
1145 7e			    LD     A, (HL) 
1146			 
1146			Str1IsBigger: 
1146 4f			    LD     C, A             ; Put length in BC 
1147 06 00		    LD     B, 0 
1149 13			    INC    DE              ; Increment pointers to meat of string. 
114a 23			    INC    HL 
114b			 
114b			CmpLoop: 
114b 1a			    LD     A, (DE)          ; Compare bytes. 
114c ed a1		    CPI 
114e 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1150 13			    INC    DE              ; Update pointer. 
1151 ea 4b 11		    JP     PE, CmpLoop 
1154			 
1154 d1			    POP    DE 
1155 e1			    POP    HL 
1156 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1157 be			    CP     (HL) 
1158 c9			    RET 
1159			 
1159			NoMatch: 
1159 2b			    DEC    HL 
115a be			    CP     (HL)            ; Compare again to affect carry. 
115b d1			    POP    DE 
115c e1			    POP    HL 
115d c9			    RET 
115e			 
115e			;; test strmp 
115e			; 
115e			;ld de, .str1 
115e			;ld hl, .str2 
115e			;call strcmp 
115e			;jr z, .z1 
115e			;;this 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "NZ1" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			;.z1: 
115e			; 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "ZZ1" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			; 
115e			;ld de, .str1 
115e			;ld hl, .str1 
115e			;call strcmp 
115e			;jr z, .z2 
115e			;;this 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "NZ2" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			;.z2: 
115e			; 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "ZZ2" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			; 
115e			;ld de, .str1 
115e			;ld hl, .str2 
115e			;call strcmp 
115e			;jr c, .c1 
115e			; 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "Nc1" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			;.c1: 
115e			;;this 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "cc1" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			; 
115e			;ld de, .str1 
115e			;ld hl, .str1 
115e			;call strcmp 
115e			;jr c, .c2 
115e			;;this 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "Nc2" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			;.c2: 
115e			; 
115e			;	if DEBUG_FORTH_WORDS 
115e			;		DMARK "cc2" 
115e			;		CALLMONITOR 
115e			;	endif 
115e			;	NEXTW 
115e			;.str1:   db "string1",0 
115e			;.str2:   db "string2",0 
115e			 
115e			; only care about direct match or not 
115e			; hl and de strings 
115e			; zero set if the same 
115e			 
115e			strcmp: 
115e 1a				ld a, (de) 
115f be				cp (hl) 
1160 28 02			jr z, .ssame 
1162 b7				or a 
1163 c9				ret 
1164			 
1164			.ssame:  
1164 fe 00			cp 0 
1166 c8				ret z 
1167			 
1167 23				inc hl 
1168 13				inc de 
1169 18 f3			jr strcmp 
116b				 
116b				 
116b			 
116b			 
116b			 
116b			 
116b			; eof 
116b			 
116b			 
116b			 
116b			 
116b			 
116b			 
# End of file firmware_strings.asm
116b			include "firmware_memory.asm"   ; malloc and free  
116b			 
116b			if DEBUG_FORTH_MALLOC_HIGH 
116b			.mallocsize: db "Wants malloc >256",0 
116b			.mallocasize: db "MALLOC gives >256",0 
116b			.malloczero: db "MALLOC gives zero",0 
116b			 
116b			malloc_guard_zerolen: 
116b				push hl 
116b				push de 
116b				push af 
116b			 
116b				ld de, 0 
116b			        call cmp16 
116b				jr nz, .lowalloz 
116b			 
116b				push hl 
116b				push de 
116b					ld hl, display_fb0 
116b					ld (display_fb_active), hl 
116b				call clear_display 
116b				ld a, 0 
116b				ld de, .malloczero 
116b				call str_at_display 
116b				call update_display 
116b				call delay1s 
116b				call delay1s 
116b				ld a, 0 
116b				ld (os_view_disable), a 
116b			 
116b				pop de 
116b				pop hl 
116b			 
116b				 
116b			 
116b				CALLMONITOR 
116b			.lowalloz: 
116b			 
116b			 
116b				pop af 
116b				pop de 
116b				pop hl 
116b			ret 
116b			 
116b			malloc_guard_entry: 
116b				push hl 
116b				push de 
116b				push af 
116b			 
116b			 	or a      ;clear carry flag 
116b				push hl 
116b				ld de, 255 
116b				sbc hl, de 
116b				jr c, .lowalloc 
116b			 
116b				push de 
116b					ld hl, display_fb0 
116b					ld (display_fb_active), hl 
116b				call clear_display 
116b				ld a, 0 
116b				ld de, .mallocsize 
116b				call str_at_display 
116b				call update_display 
116b				call delay1s 
116b				call delay1s 
116b				ld a, 0 
116b				ld (os_view_disable), a 
116b			 
116b				pop de 
116b				pop hl 
116b			 
116b				 
116b			 
116b				CALLMONITOR 
116b				jr .lowdone 
116b			.lowalloc: 
116b			 
116b			 
116b				pop hl 
116b			.lowdone:	pop af 
116b				pop de 
116b				pop hl 
116b			ret 
116b			 
116b			malloc_guard_exit: 
116b				push hl 
116b				push de 
116b				push af 
116b			 
116b			 	or a      ;clear carry flag 
116b				push hl 
116b				ld de, 255 
116b				sbc hl, de 
116b				jr c, .lowallocx 
116b			 
116b				push de 
116b					ld hl, display_fb0 
116b					ld (display_fb_active), hl 
116b				call clear_display 
116b				ld a, 0 
116b				ld de, .mallocasize 
116b				call str_at_display 
116b				call update_display 
116b				call delay1s 
116b				call delay1s 
116b				ld a, 0 
116b				ld (os_view_disable), a 
116b				pop de 
116b				pop hl 
116b			 
116b				CALLMONITOR 
116b				jr .lowdonex 
116b			.lowallocx: 
116b			 
116b				pop hl 
116b			.lowdonex:	pop af 
116b				pop de 
116b				pop hl 
116b			ret 
116b			endif 
116b			 
116b			if MALLOC_2 
116b			; Z80 Malloc and Free Functions 
116b			 
116b			; Malloc Function: 
116b			; Input: 
116b			;   HL: Size of block to allocate 
116b			; Output: 
116b			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
116b			 
116b			malloc: 
116b				 
116b			if DEBUG_FORTH_MALLOC_HIGH 
116b			call malloc_guard_entry 
116b			endif 
116b			 
116b			 
116b			 
116b			 
116b					if DEBUG_FORTH_MALLOC 
116b						DMARK "mal" 
116b						CALLMONITOR 
116b					endif 
116b			    push af            ; Save AF register 
116b			    ld a, l            ; Load low byte of size into A 
116b			    or h               ; Check if size is zero 
116b			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
116b			 
116b			    ; Allocate memory 
116b			    ld hl, (heap_start) ; Load start of heap into HL 
116b					if DEBUG_FORTH_MALLOC 
116b						DMARK "ma1" 
116b						CALLMONITOR 
116b					endif 
116b			    call malloc_internal ; Call internal malloc function 
116b			    pop af             ; Restore AF register 
116b			if DEBUG_FORTH_MALLOC_HIGH 
116b			call malloc_guard_exit 
116b			call malloc_guard_zerolen 
116b			endif 
116b			    ret                ; Return 
116b			 
116b			; Free Function: 
116b			; Input: 
116b			;   HL: Pointer to memory block to free 
116b			; Output: 
116b			;   None 
116b			 
116b			free: 
116b			    push af            ; Save AF register 
116b			    ld a, l            ; Load low byte of pointer into A 
116b			    or h               ; Check if pointer is NULL 
116b			    jp z, free_exit    ; If pointer is NULL, exit 
116b			 
116b			    ; Free memory 
116b			    ld hl, (heap_start) ; Load start of heap into HL 
116b			    call free_internal  ; Call internal free function 
116b			    pop af             ; Restore AF register 
116b			    ret                ; Return 
116b			 
116b			; Internal Malloc Function: 
116b			; Input: 
116b			;   HL: Size of block to allocate 
116b			; Output: 
116b			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
116b			 
116b			malloc_internal: 
116b			    ld bc, 2           ; Number of bytes to allocate for management overhead 
116b			    add hl, bc         ; Add management overhead to requested size 
116b			    ex de, hl          ; Save total size in DE, and keep it in HL 
116b					if DEBUG_FORTH_MALLOC 
116b						DMARK "ma2" 
116b						CALLMONITOR 
116b					endif 
116b			 
116b			    ; Search for free memory block 
116b			    ld de, (heap_end)  ; Load end of heap into DE 
116b			    ld bc, 0           ; Initialize counter 
116b			 
116b					if DEBUG_FORTH_MALLOC 
116b						DMARK "ma2" 
116b						CALLMONITOR 
116b					endif 
116b			malloc_search_loop: 
116b			    ; Check if current block is free 
116b			    ld a, (hl)         ; Load current block's status (free or used) 
116b			    cp 0               ; Compare with zero (free) 
116b			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
116b			 
116b			    ; Check if current block is large enough 
116b			    ld a, (hl+1)       ; Load high byte of block size 
116b			    cp l               ; Compare with low byte of requested size 
116b			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
116b			 
116b			    ld a, (hl+2)       ; Load low byte of block size 
116b			    cp h               ; Compare with high byte of requested size 
116b			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
116b			 
116b			    ; Mark block as used 
116b			    ld (hl), 0xFF      ; Set status byte to indicate used block 
116b			 
116b			    ; Calculate remaining space in block 
116b			    ld bc, 0           ; Clear BC 
116b			    add hl, bc         ; Increment HL to point to start of data block 
116b			    add hl, de         ; HL = HL + DE (total size) 
116b			    ld bc, 1           ; Number of bytes to allocate for management overhead 
116b			    add hl, bc         ; Add management overhead to start of data block 
116b			 
116b			    ; Save pointer to allocated block in HL 
116b			if DEBUG_FORTH_MALLOC_HIGH 
116b						DMARK "ma5" 
116b			call malloc_guard_exit 
116b			call malloc_guard_zerolen 
116b			endif 
116b			    ret 
116b			 
116b			malloc_skip_block_check: 
116b			    ; Move to the next block 
116b			    ld bc, 3           ; Size of management overhead 
116b			    add hl, bc         ; Move to the next block 
116b			    inc de             ; Increment counter 
116b			 
116b			    ; Check if we have reached the end of heap 
116b			    ld a, e            ; Load low byte of heap end address 
116b			    cp (hl)            ; Compare with low byte of current address 
116b			    jr nz, malloc_search_loop  ; If not equal, continue searching 
116b			    ld a, d            ; Load high byte of heap end address 
116b			    cp 0               ; Check if it's zero (end of memory) 
116b			    jr nz, malloc_search_loop  ; If not zero, continue searching 
116b			 
116b			    ; If we reached here, allocation failed 
116b			    xor a              ; Set result to NULL 
116b			if DEBUG_FORTH_MALLOC_HIGH 
116b						DMARK "ma6" 
116b			call malloc_guard_exit 
116b			call malloc_guard_zerolen 
116b			endif 
116b			    ret 
116b			malloc_exit: 
116b			if DEBUG_FORTH_MALLOC_HIGH 
116b						DMARK "ma7" 
116b			call malloc_guard_exit 
116b			call malloc_guard_zerolen 
116b			endif 
116b			    ret 
116b			 
116b			; Internal Free Function: 
116b			; Input: 
116b			;   HL: Pointer to memory block to free 
116b			; Output: 
116b			;   None 
116b			 
116b			free_internal: 
116b			    ld de, (heap_start) ; Load start of heap into DE 
116b			    ld bc, 0            ; Initialize counter 
116b			 
116b			free_search_loop: 
116b			    ; Check if current block contains the pointer 
116b			    ld a, l             ; Load low byte of pointer 
116b			    cp (hl+1)           ; Compare with high byte of current block's address 
116b			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
116b			    ld a, h             ; Load high byte of pointer 
116b			    cp (hl+2)           ; Compare with low byte of current block's address 
116b			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
116b			 
116b			    ; Mark block as free 
116b			    ld (hl), 0          ; Set status byte to indicate free block 
116b			    ret                 ; Return 
116b			 
116b			free_skip_block_check: 
116b			    ; Move to the next block 
116b			    ld bc, 3            ; Size of management overhead 
116b			    add hl, bc          ; Move to the next block 
116b			    inc de              ; Increment counter 
116b			 
116b			    ; Check if we have reached the end of heap 
116b			    ld a, e             ; Load low byte of heap end address 
116b			    cp (hl)             ; Compare with low byte of current address 
116b			    jr nz, free_search_loop  ; If not equal, continue searching 
116b			    ld a, d             ; Load high byte of heap end address 
116b			    cp 0                ; Check if it's zero (end of memory) 
116b			    jr nz, free_search_loop  ; If not zero, continue searching 
116b			 
116b			    ; If we reached here, pointer is not found in heap 
116b			    ret 
116b			 
116b			free_exit: 
116b			    ret                 ; Return 
116b			 
116b			; Define heap start and end addresses 
116b			;heap_start:    .dw 0xC000   ; Start of heap 
116b			;heap_end:      .dw 0xE000   ; End of heap 
116b			 
116b			endif 
116b			 
116b			 
116b			if MALLOC_1 
116b			 
116b			 
116b			 
116b			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
116b			 
116b			;moved to firmware.asm 
116b			;heap_start        .equ  0x9000      ; Starting address of heap 
116b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
116b			 
116b			;      .org 0 
116b			;      jp    main 
116b			 
116b			 
116b			;      .org  0x100 
116b			;main: 
116b			;      ld    HL, 0x8100 
116b			;      ld    SP, HL 
116b			; 
116b			;      call  heap_init 
116b			; 
116b			;      ; Make some allocations 
116b			;      ld    HL, 12 
116b			;      call  malloc            ; Allocates 0x9004 
116b			; 
116b			;      ld    HL, 12 
116b			;      call  malloc            ; Allocates 0x9014 
116b			; 
116b			;      ld    HL, 12 
116b			;      call  malloc            ; Allocates 0x9024 
116b			; 
116b			;      ; Free some allocations 
116b			;      ld    HL, 0x9014 
116b			;      call  free 
116b			; 
116b			;      ld    HL, 0x9004 
116b			;      call  free 
116b			; 
116b			;      ld    HL, 0x9024 
116b			;      call  free 
116b			; 
116b			; 
116b			;      halt 
116b			 
116b			 
116b			;------------------------------------------------------------------------------ 
116b			;     heap_init                                                               : 
116b			;                                                                             : 
116b			; Description                                                                 : 
116b			;     Initialise the heap and make it ready for malloc and free operations.   : 
116b			;                                                                             : 
116b			;     The heap is maintained as a linked list, starting with an initial       : 
116b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
116b			;     the first free block in the heap. Each block then points to the next    : 
116b			;     free block within the heap, and the free list ends at the first block   : 
116b			;     with a null pointer to the next free block.                             : 
116b			;                                                                             : 
116b			; Parameters                                                                  : 
116b			;     Inputs are compile-time only. Two defines which specify the starting    : 
116b			;     address of the heap and its size are required, along with a memory      : 
116b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
116b			;     principally stores a pointer to the first free block in the heap.       : 
116b			;                                                                             : 
116b			; Returns                                                                     : 
116b			;     Nothing                                                                 : 
116b			;------------------------------------------------------------------------------ 
116b			heap_init: 
116b e5			      push  HL 
116c			 
116c			      ; Initialise free list struct 
116c 21 0e 80		      ld    HL, heap_start 
116f 22 0a 80		      ld    (free_list), HL 
1172 21 00 00		      ld    HL, 0 
1175 22 0c 80		      ld    (free_list+2), HL 
1178			 
1178			      ; Insert first free block at bottom of heap, consumes entire heap 
1178 21 0a 80		      ld    HL, heap_start+heap_size-4 
117b 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
117e 21 fc ff		      ld    HL, heap_size-4 
1181 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1184			 
1184			      ; Insert end of free list block at top of heap - two null words will 
1184			      ; terminate the free list 
1184 21 00 00		      ld    HL, 0 
1187 22 0c 80		      ld    (heap_start+heap_size-2), HL 
118a 22 0a 80		      ld    (heap_start+heap_size-4), HL 
118d			 
118d e1			      pop   HL 
118e			 
118e c9			      ret 
118f			 
118f			 
118f			;------------------------------------------------------------------------------ 
118f			;     malloc                                                                  : 
118f			;                                                                             : 
118f			; Description                                                                 : 
118f			;     Allocates the wanted space from the heap and returns the address of the : 
118f			;     first useable byte of the allocation.                                   : 
118f			;                                                                             : 
118f			;     Allocations can happen in one of two ways:                              : 
118f			;                                                                             : 
118f			;     1. A free block may be found which is the exact size wanted. In this    : 
118f			;        case the block is removed from the free list and retuedn to the      : 
118f			;        caller.                                                              : 
118f			;     2. A free block may be found which is larger than the size wanted. In   : 
118f			;        this case, the larger block is split into two. The first portion of  : 
118f			;        this block will become the requested space by the malloc call and    : 
118f			;        is returned to the caller. The second portion becomes a new free     : 
118f			;        block, and the free list is adjusted to maintain continuity via this : 
118f			;        newly created block.                                                 : 
118f			;                                                                             : 
118f			;     malloc does not set any initial value in the allocated space, the       : 
118f			;     caller is required to do this as required.                              : 
118f			;                                                                             : 
118f			;     This implementation of malloc uses the stack exclusively, and is        : 
118f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
118f			;     advisable to disable interrupts before calling malloc, and recommended  : 
118f			;     to avoid the use of malloc inside ISRs in general.                      : 
118f			;                                                                             : 
118f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
118f			;                                                                             : 
118f			; Parameters                                                                  : 
118f			;     HL  Number of bytes wanted                                              : 
118f			;                                                                             : 
118f			; Returns                                                                     : 
118f			;     HL  Address of the first useable byte of the allocation                 : 
118f			;                                                                             : 
118f			; Flags                                                                       : 
118f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
118f			;                                                                             : 
118f			; Stack frame                                                                 : 
118f			;       |             |                                                       : 
118f			;       +-------------+                                                       : 
118f			;       |     BC      |                                                       : 
118f			;       +-------------+                                                       : 
118f			;       |     DE      |                                                       : 
118f			;       +-------------+                                                       : 
118f			;       |     IX      |                                                       : 
118f			;       +-------------+                                                       : 
118f			;       |  prev_free  |                                                       : 
118f			;   +4  +-------------+                                                       : 
118f			;       |  this_free  |                                                       : 
118f			;   +2  +-------------+                                                       : 
118f			;       |  next_free  |                                                       : 
118f			;   +0  +-------------+                                                       : 
118f			;       |             |                                                       : 
118f			;                                                                             : 
118f			;------------------------------------------------------------------------------ 
118f			 
118f			 
118f			;malloc: 
118f			; 
118f			;	SAVESP ON 1 
118f			; 
118f			;	call malloc_code 
118f			; 
118f			;	CHECKSP ON 1 
118f			;	ret 
118f			 
118f			 
118f			malloc: 
118f c5			      push  BC 
1190 d5			      push  DE 
1191 dd e5		      push  IX 
1193			if DEBUG_FORTH_MALLOC_HIGH 
1193			call malloc_guard_entry 
1193			endif 
1193			 
1193					if DEBUG_FORTH_MALLOC 
1193						DMARK "mal" 
1193						CALLMONITOR 
1193					endif 
1193 7c			      ld    A, H                    ; Exit if no space requested 
1194 b5			      or    L 
1195 ca 54 12		      jp    Z, malloc_early_exit 
1198			 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			; 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			;inc hl 
1198			 
1198			 
1198			 
1198			 
1198					if DEBUG_FORTH_MALLOC 
1198						DMARK "maA" 
1198						CALLMONITOR 
1198					endif 
1198			      ; Set up stack frame 
1198 eb			      ex    DE, HL 
1199 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
119c 39			      add   HL, SP 
119d f9			      ld    SP, HL 
119e dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11a2 dd 39		      add   IX, SP 
11a4			 
11a4			      ; Setup initial state 
11a4 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11a7 19			      add   HL, DE 
11a8			 
11a8 44			      ld    B, H                    ; Move want to BC 
11a9 4d			      ld    C, L 
11aa			 
11aa 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ad dd 75 04		      ld    (IX+4), L 
11b0 dd 74 05		      ld    (IX+5), H 
11b3			 
11b3 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11b4 23			      inc   HL 
11b5 56			      ld    D, (HL) 
11b6 dd 73 02		      ld    (IX+2), E 
11b9 dd 72 03		      ld    (IX+3), D 
11bc eb			      ex    DE, HL                  ; this_free ptr into HL 
11bd			 
11bd					if DEBUG_FORTH_MALLOC 
11bd						DMARK "maB" 
11bd						CALLMONITOR 
11bd					endif 
11bd			      ; Loop through free block list to find some space 
11bd			malloc_find_space: 
11bd 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11be 23			      inc   HL 
11bf 56			      ld    D, (HL) 
11c0			 
11c0 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11c1 b3			      or    E 
11c2 ca 4e 12		      jp    Z, malloc_no_space 
11c5			 
11c5 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11c8 dd 72 01		      ld    (IX+1), D 
11cb			 
11cb			      ; Does this block have enough space to make the allocation? 
11cb 23			      inc   HL                      ; Load free block size into DE 
11cc 5e			      ld    E, (HL) 
11cd 23			      inc   HL 
11ce 56			      ld    D, (HL) 
11cf			 
11cf eb			      ex    DE, HL                  ; Check size of block against want 
11d0 b7			      or    A                       ; Ensure carry flag clear 
11d1 ed 42		      sbc   HL, BC 
11d3 e5			      push  HL                      ; Store the result for later (new block size) 
11d4			 
11d4 ca 23 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11d7 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11d9			 
11d9			      ; this_free block is not big enough, setup ptrs to test next free block 
11d9 e1			      pop   HL                      ; Discard previous result 
11da			 
11da dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11dd dd 66 03		      ld    H, (IX+3) 
11e0 dd 75 04		      ld    (IX+4), L 
11e3 dd 74 05		      ld    (IX+5), H 
11e6			 
11e6 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11e9 dd 66 01		      ld    H, (IX+1) 
11ec dd 75 02		      ld    (IX+2), L 
11ef dd 74 03		      ld    (IX+3), H 
11f2			 
11f2					if DEBUG_FORTH_MALLOC 
11f2						DMARK "MA>" 
11f2						CALLMONITOR 
11f2					endif 
11f2 18 c9		      jr    malloc_find_space 
11f4			 
11f4			      ; split a bigger block into two - requested size and remaining size 
11f4			malloc_alloc_split: 
11f4					if DEBUG_FORTH_MALLOC 
11f4						DMARK "MAs" 
11f4						CALLMONITOR 
11f4					endif 
11f4 eb			      ex    DE, HL                  ; Calculate address of new free block 
11f5 2b			      dec   HL 
11f6 2b			      dec   HL 
11f7 2b			      dec   HL 
11f8 09			      add   HL, BC 
11f9			 
11f9			      ; Create a new block and point it at next_free 
11f9 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
11fc dd 56 01		      ld    D, (IX+1) 
11ff			 
11ff 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1200 23			      inc   HL 
1201 72			      ld    (HL), D 
1202			 
1202 d1			      pop   DE                      ; Store size of new block into new block 
1203 23			      inc   HL 
1204 73			      ld    (HL), E 
1205 23			      inc   HL 
1206 72			      ld    (HL), D 
1207			 
1207			      ; Update this_free ptr to point to new block 
1207 2b			      dec   HL 
1208 2b			      dec   HL 
1209 2b			      dec   HL 
120a			 
120a dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
120d dd 56 03		      ld    D, (IX+3) 
1210			 
1210 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1213 dd 74 03		      ld    (IX+3), H 
1216			 
1216			      ; Modify this_free block to be allocation 
1216 eb			      ex    DE, HL 
1217 af			      xor   A                       ; Null the next block ptr of allocated block 
1218 77			      ld    (HL), A 
1219 23			      inc   HL 
121a 77			      ld    (HL), A 
121b			 
121b 23			      inc   HL                      ; Store want size into allocated block 
121c 71			      ld    (HL), C 
121d 23			      inc   HL 
121e 70			      ld    (HL), B 
121f 23			      inc   HL 
1220 e5			      push  HL                      ; Address of allocation to return 
1221			 
1221 18 19		      jr    malloc_update_links 
1223			 
1223			malloc_alloc_fit: 
1223 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1224			 
1224					if DEBUG_FORTH_MALLOC 
1224						DMARK "MAf" 
1224						CALLMONITOR 
1224					endif 
1224			      ; Modify this_free block to be allocation 
1224 eb			      ex    DE, HL 
1225 2b			      dec   HL 
1226 2b			      dec   HL 
1227 2b			      dec   HL 
1228			 
1228 af			      xor   A                       ; Null the next block ptr of allocated block 
1229 77			      ld    (HL), A 
122a 23			      inc   HL 
122b 77			      ld    (HL), A 
122c			 
122c 23			      inc   HL                      ; Store address of allocation to return 
122d 23			      inc   HL 
122e 23			      inc   HL 
122f e5			      push  HL 
1230			 
1230			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1230 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1233 dd 66 01		      ld    H, (IX+1) 
1236			 
1236 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1239 dd 74 03		      ld    (IX+3), H 
123c			 
123c			 
123c			malloc_update_links: 
123c			      ; Update prev_free ptr to point to this_free 
123c dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
123f dd 66 05		      ld    H, (IX+5) 
1242			 
1242 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1245 dd 56 03		      ld    D, (IX+3) 
1248			 
1248 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1249 23			      inc   HL 
124a 72			      ld    (HL), D 
124b			 
124b					if DEBUG_FORTH_MALLOC 
124b						DMARK "Mul" 
124b						CALLMONITOR 
124b					endif 
124b			      ; Clear the Z flag to indicate successful allocation 
124b 7a			      ld    A, D 
124c b3			      or    E 
124d			 
124d d1			      pop   DE                      ; Address of allocation 
124e					if DEBUG_FORTH_MALLOC 
124e						DMARK "MAu" 
124e						CALLMONITOR 
124e					endif 
124e			 
124e			malloc_no_space: 
124e 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1251 39			      add   HL, SP 
1252 f9			      ld    SP, HL 
1253			 
1253 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1254					if DEBUG_FORTH_MALLOC 
1254						DMARK "MAN" 
1254						CALLMONITOR 
1254					endif 
1254			 
1254			malloc_early_exit: 
1254					if DEBUG_FORTH_MALLOC 
1254						DMARK "MAx" 
1254						CALLMONITOR 
1254					endif 
1254 dd e1		      pop   IX 
1256 d1			      pop   DE 
1257 c1			      pop   BC 
1258			 
1258			if DEBUG_FORTH_MALLOC_HIGH 
1258			call malloc_guard_exit 
1258			call malloc_guard_zerolen 
1258			endif 
1258 c9			      ret 
1259			 
1259			 
1259			;------------------------------------------------------------------------------ 
1259			;     free                                                                    : 
1259			;                                                                             : 
1259			; Description                                                                 : 
1259			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1259			;     returned by malloc, otherwise the behaviour is undefined.               : 
1259			;                                                                             : 
1259			;     Where possible, directly adjacent free blocks will be merged together   : 
1259			;     into larger blocks to help ensure that the heap does not become         : 
1259			;     excessively fragmented.                                                 : 
1259			;                                                                             : 
1259			;     free does not clear or set any other value into the freed space, and    : 
1259			;     therefore its contents may be visible through subsequent malloc's. The  : 
1259			;     caller should clear the freed space as required.                        : 
1259			;                                                                             : 
1259			;     This implementation of free uses the stack exclusively, and is          : 
1259			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1259			;     advisable to disable interrupts before calling free, and recommended    : 
1259			;     to avoid the use of free inside ISRs in general.                        : 
1259			;                                                                             : 
1259			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1259			;                                                                             : 
1259			; Parameters                                                                  : 
1259			;     HL  Pointer to address of first byte of allocation to be freed          : 
1259			;                                                                             : 
1259			; Returns                                                                     : 
1259			;     Nothing                                                                 : 
1259			;                                                                             : 
1259			; Stack frame                                                                 : 
1259			;       |             |                                                       : 
1259			;       +-------------+                                                       : 
1259			;       |     BC      |                                                       : 
1259			;       +-------------+                                                       : 
1259			;       |     DE      |                                                       : 
1259			;       +-------------+                                                       : 
1259			;       |     IX      |                                                       : 
1259			;       +-------------+                                                       : 
1259			;       |  prev_free  |                                                       : 
1259			;   +2  +-------------+                                                       : 
1259			;       |  next_free  |                                                       : 
1259			;   +0  +-------------+                                                       : 
1259			;       |             |                                                       : 
1259			;                                                                             : 
1259			;------------------------------------------------------------------------------ 
1259			free: 
1259 c5			      push  BC 
125a d5			      push  DE 
125b dd e5		      push  IX 
125d			 
125d 7c			      ld    A, H                    ; Exit if ptr is null 
125e b5			      or    L 
125f ca 23 13		      jp    Z, free_early_exit 
1262			 
1262			      ; Set up stack frame 
1262 eb			      ex    DE, HL 
1263 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1266 39			      add   HL, SP 
1267 f9			      ld    SP, HL 
1268 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
126c dd 39		      add   IX, SP 
126e			 
126e			      ; The address in HL points to the start of the useable allocated space, 
126e			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
126e			      ; address of the block itself. 
126e eb			      ex    DE, HL 
126f 11 fc ff		      ld    DE, -4 
1272 19			      add   HL, DE 
1273			 
1273			      ; An allocated block must have a null next block pointer in it 
1273 7e			      ld    A, (HL) 
1274 23			      inc   HL 
1275 b6			      or    (HL) 
1276 c2 1e 13		      jp    NZ, free_done 
1279			 
1279 2b			      dec   HL 
127a			 
127a 44			      ld    B, H                    ; Copy HL to BC 
127b 4d			      ld    C, L 
127c			 
127c			      ; Loop through the free list to find the first block with an address 
127c			      ; higher than the block being freed 
127c 21 0a 80		      ld    HL, free_list 
127f			 
127f			free_find_higher_block: 
127f 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1280 23			      inc   HL 
1281 56			      ld    D, (HL) 
1282 2b			      dec   HL 
1283			 
1283 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1286 dd 72 01		      ld    (IX+1), D 
1289 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
128c dd 74 03		      ld    (IX+3), H 
128f			 
128f 78			      ld    A, B                    ; Check if DE is greater than BC 
1290 ba			      cp    D                       ; Compare MSB first 
1291 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1293 30 04		      jr    NC, free_find_higher_block_skip 
1295 79			      ld    A, C 
1296 bb			      cp    E                       ; Then compare LSB 
1297 38 08		      jr    C, free_found_higher_block 
1299			 
1299			free_find_higher_block_skip: 
1299 7a			      ld    A, D                    ; Reached the end of the free list? 
129a b3			      or    E 
129b ca 1e 13		      jp    Z, free_done 
129e			 
129e eb			      ex    DE, HL 
129f			 
129f 18 de		      jr    free_find_higher_block 
12a1			 
12a1			free_found_higher_block: 
12a1			      ; Insert freed block between prev and next free blocks 
12a1 71			      ld    (HL), C                 ; Point prev free block to freed block 
12a2 23			      inc   HL 
12a3 70			      ld    (HL), B 
12a4			 
12a4 60			      ld    H, B                    ; Point freed block at next free block 
12a5 69			      ld    L, C 
12a6 73			      ld    (HL), E 
12a7 23			      inc   HL 
12a8 72			      ld    (HL), D 
12a9			 
12a9			      ; Check if the freed block is adjacent to the next free block 
12a9 23			      inc   HL                      ; Load size of freed block into HL 
12aa 5e			      ld    E, (HL) 
12ab 23			      inc   HL 
12ac 56			      ld    D, (HL) 
12ad eb			      ex    DE, HL 
12ae			 
12ae 09			      add   HL, BC                  ; Add addr of freed block and its size 
12af			 
12af dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12b2 dd 56 01		      ld    D, (IX+1) 
12b5			 
12b5 b7			      or    A                       ; Clear the carry flag 
12b6 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12b8 20 22		      jr    NZ, free_check_adjacent_to_prev 
12ba			 
12ba			      ; Freed block is adjacent to next, merge into one bigger block 
12ba eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12bb 5e			      ld    E, (HL) 
12bc 23			      inc   HL 
12bd 56			      ld    D, (HL) 
12be e5			      push  HL                      ; Save ptr to next block for later 
12bf			 
12bf 60			      ld    H, B                    ; Store ptr from next block into freed block 
12c0 69			      ld    L, C 
12c1 73			      ld    (HL), E 
12c2 23			      inc   HL 
12c3 72			      ld    (HL), D 
12c4			 
12c4 e1			      pop   HL                      ; Restore ptr to next block 
12c5 23			      inc   HL                      ; Load size of next block into DE 
12c6 5e			      ld    E, (HL) 
12c7 23			      inc   HL 
12c8 56			      ld    D, (HL) 
12c9 d5			      push  DE                      ; Save next block size for later 
12ca			 
12ca 60			      ld    H, B                    ; Load size of freed block into HL 
12cb 69			      ld    L, C 
12cc 23			      inc   HL 
12cd 23			      inc   HL 
12ce 5e			      ld    E, (HL) 
12cf 23			      inc   HL 
12d0 56			      ld    D, (HL) 
12d1 eb			      ex    DE, HL 
12d2			 
12d2 d1			      pop   DE                      ; Restore size of next block 
12d3 19			      add   HL, DE                  ; Add sizes of both blocks 
12d4 eb			      ex    DE, HL 
12d5			 
12d5 60			      ld    H, B                    ; Store new bigger size into freed block 
12d6 69			      ld    L, C 
12d7 23			      inc   HL 
12d8 23			      inc   HL 
12d9 73			      ld    (HL), E 
12da 23			      inc   HL 
12db 72			      ld    (HL), D 
12dc			 
12dc			free_check_adjacent_to_prev: 
12dc			      ; Check if the freed block is adjacent to the prev free block 
12dc dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
12df dd 66 03		      ld    H, (IX+3) 
12e2			 
12e2 23			      inc   HL                      ; Size of prev free block into DE 
12e3 23			      inc   HL 
12e4 5e			      ld    E, (HL) 
12e5 23			      inc   HL 
12e6 56			      ld    D, (HL) 
12e7 2b			      dec   HL 
12e8 2b			      dec   HL 
12e9 2b			      dec   HL 
12ea			 
12ea 19			      add   HL, DE                  ; Add prev block addr and size 
12eb			 
12eb b7			      or    A                       ; Clear the carry flag 
12ec ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12ee 20 2e		      jr    NZ, free_done 
12f0			 
12f0			      ; Freed block is adjacent to prev, merge into one bigger block 
12f0 60			      ld    H, B                    ; Load next ptr from freed block into DE 
12f1 69			      ld    L, C 
12f2 5e			      ld    E, (HL) 
12f3 23			      inc   HL 
12f4 56			      ld    D, (HL) 
12f5 e5			      push  HL                      ; Save freed block ptr for later 
12f6			 
12f6 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12f9 dd 66 03		      ld    H, (IX+3) 
12fc 73			      ld    (HL), E 
12fd 23			      inc   HL 
12fe 72			      ld    (HL), D 
12ff			 
12ff e1			      pop   HL                      ; Restore freed block ptr 
1300 23			      inc   HL                      ; Load size of freed block into DE 
1301 5e			      ld    E, (HL) 
1302 23			      inc   HL 
1303 56			      ld    D, (HL) 
1304 d5			      push  DE                      ; Save freed block size for later 
1305			 
1305 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1308 dd 66 03		      ld    H, (IX+3) 
130b 23			      inc   HL 
130c 23			      inc   HL 
130d 5e			      ld    E, (HL) 
130e 23			      inc   HL 
130f 56			      ld    D, (HL) 
1310			 
1310 e1			      pop   HL                      ; Add sizes of both blocks 
1311 19			      add   HL, DE 
1312 eb			      ex    DE, HL 
1313			 
1313 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1316 dd 66 03		      ld    H, (IX+3) 
1319 23			      inc   HL 
131a 23			      inc   HL 
131b 73			      ld    (HL), E 
131c 23			      inc   HL 
131d 72			      ld    (HL), D 
131e			 
131e			free_done: 
131e 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1321 39			      add   HL, SP 
1322 f9			      ld    SP, HL 
1323			 
1323			free_early_exit: 
1323 dd e1		      pop   IX 
1325 d1			      pop   DE 
1326 c1			      pop   BC 
1327			 
1327 c9			      ret 
1328			 
1328			; moved to firmware.asm 
1328			; 
1328			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1328			;                  .dw   0 
1328			 
1328			 
1328			endif 
1328			 
1328			 
1328			if MALLOC_3 
1328			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1328			;heap_start        .equ  0x9000      ; Starting address of heap 
1328			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1328			; 
1328			 ;     .org 0 
1328			  ;    jp    main 
1328			; 
1328			; 
1328			 ;     .org  0x100 
1328			;main: 
1328			 ;     ld    HL, 0x8100 
1328			  ;    ld    SP, HL 
1328			; 
1328			;      call  heap_init 
1328			 
1328			      ; Make some allocations 
1328			;      ld    HL, 12 
1328			;      call  malloc            ; Allocates 0x9004 
1328			; 
1328			 ;     ld    HL, 12 
1328			;      call  malloc            ; Allocates 0x9014 
1328			 
1328			;      ld    HL, 12 
1328			;      call  malloc            ; Allocates 0x9024 
1328			 
1328			      ; Free some allocations 
1328			;      ld    HL, 0x9014 
1328			;      call  free 
1328			 
1328			;      ld    HL, 0x9004 
1328			;      call  free 
1328			; 
1328			;      ld    HL, 0x9024 
1328			;      call  free 
1328			 
1328			 
1328			 ;     halt 
1328			 
1328			 
1328			;------------------------------------------------------------------------------ 
1328			;     heap_init                                                               : 
1328			;                                                                             : 
1328			; Description                                                                 : 
1328			;     Initialise the heap and make it ready for malloc and free operations.   : 
1328			;                                                                             : 
1328			;     The heap is maintained as a linked list, starting with an initial       : 
1328			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1328			;     the first free block in the heap. Each block then points to the next    : 
1328			;     free block within the heap, and the free list ends at the first block   : 
1328			;     with a null pointer to the next free block.                             : 
1328			;                                                                             : 
1328			; Parameters                                                                  : 
1328			;     Inputs are compile-time only. Two defines which specify the starting    : 
1328			;     address of the heap and its size are required, along with a memory      : 
1328			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1328			;     principally stores a pointer to the first free block in the heap.       : 
1328			;                                                                             : 
1328			; Returns                                                                     : 
1328			;     Nothing                                                                 : 
1328			;------------------------------------------------------------------------------ 
1328			heap_init: 
1328			      push  HL 
1328			 
1328			      ; Initialise free list struct 
1328			      ld    HL, heap_start 
1328			      ld    (free_list), HL 
1328			      ld    HL, 0 
1328			      ld    (free_list+2), HL 
1328			 
1328			      ; Insert first free block at bottom of heap, consumes entire heap 
1328			      ld    HL, heap_start+heap_size-4 
1328			      ld    (heap_start), HL        ; Next block (end of free list) 
1328			      ld    HL, heap_size-4 
1328			      ld    (heap_start+2), HL      ; Block size 
1328			 
1328			      ; Insert end of free list block at top of heap - two null words will 
1328			      ; terminate the free list 
1328			      ld    HL, 0 
1328			      ld    (heap_start+heap_size-2), HL 
1328			      ld    (heap_start+heap_size-4), HL 
1328			 
1328			      pop   HL 
1328			 
1328			      ret 
1328			 
1328			 
1328			;------------------------------------------------------------------------------ 
1328			;     malloc                                                                  : 
1328			;                                                                             : 
1328			; Description                                                                 : 
1328			;     Allocates the wanted space from the heap and returns the address of the : 
1328			;     first useable byte of the allocation.                                   : 
1328			;                                                                             : 
1328			;     Allocations can happen in one of two ways:                              : 
1328			;                                                                             : 
1328			;     1. A free block may be found which is the exact size wanted. In this    : 
1328			;        case the block is removed from the free list and retuedn to the      : 
1328			;        caller.                                                              : 
1328			;     2. A free block may be found which is larger than the size wanted. In   : 
1328			;        this case, the larger block is split into two. The first portion of  : 
1328			;        this block will become the requested space by the malloc call and    : 
1328			;        is returned to the caller. The second portion becomes a new free     : 
1328			;        block, and the free list is adjusted to maintain continuity via this : 
1328			;        newly created block.                                                 : 
1328			;                                                                             : 
1328			;     malloc does not set any initial value in the allocated space, the       : 
1328			;     caller is required to do this as required.                              : 
1328			;                                                                             : 
1328			;     This implementation of malloc uses the stack exclusively, and is        : 
1328			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1328			;     advisable to disable interrupts before calling malloc, and recommended  : 
1328			;     to avoid the use of malloc inside ISRs in general.                      : 
1328			;                                                                             : 
1328			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1328			;                                                                             : 
1328			; Parameters                                                                  : 
1328			;     HL  Number of bytes wanted                                              : 
1328			;                                                                             : 
1328			; Returns                                                                     : 
1328			;     HL  Address of the first useable byte of the allocation                 : 
1328			;                                                                             : 
1328			; Flags                                                                       : 
1328			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1328			;                                                                             : 
1328			; Stack frame                                                                 : 
1328			;       |             |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |     BC      |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |     DE      |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |     IX      |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |  prev_free  |                                                       : 
1328			;   +4  +-------------+                                                       : 
1328			;       |  this_free  |                                                       : 
1328			;   +2  +-------------+                                                       : 
1328			;       |  next_free  |                                                       : 
1328			;   +0  +-------------+                                                       : 
1328			;       |             |                                                       : 
1328			;                                                                             : 
1328			;------------------------------------------------------------------------------ 
1328			malloc: 
1328			      push  BC 
1328			      push  DE 
1328			      push  IX 
1328			 
1328			      ld    A, H                    ; Exit if no space requested 
1328			      or    L 
1328			      jp    Z, malloc_early_exit 
1328			 
1328			      ; Set up stack frame 
1328			      ex    DE, HL 
1328			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1328			      add   HL, SP 
1328			      ld    SP, HL 
1328			      ld    IX, 0                   ; Use IX as a frame pointer 
1328			      add   IX, SP 
1328			 
1328			      ; Setup initial state 
1328			      ld    HL, 4                   ; want must also include space used by block struct 
1328			      add   HL, DE 
1328			 
1328			      ld    B, H                    ; Move want to BC 
1328			      ld    C, L 
1328			 
1328			      ld    HL, free_list           ; Store prev_free ptr to stack 
1328			      ld    (IX+4), L 
1328			      ld    (IX+5), H 
1328			 
1328			      ld    E, (HL)                 ; Store this_free ptr to stack 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      ld    (IX+2), E 
1328			      ld    (IX+3), D 
1328			      ex    DE, HL                  ; this_free ptr into HL 
1328			 
1328			      ; Loop through free block list to find some space 
1328			malloc_find_space: 
1328			      ld    E, (HL)                 ; Load next_free ptr into DE 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			 
1328			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1328			      or    E 
1328			      jp    Z, malloc_no_space 
1328			 
1328			      ld    (IX+0), E               ; Store next_free ptr to stack 
1328			      ld    (IX+1), D 
1328			 
1328			      ; Does this block have enough space to make the allocation? 
1328			      inc   HL                      ; Load free block size into DE 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			 
1328			      ex    DE, HL                  ; Check size of block against want 
1328			      or    A                       ; Ensure carry flag clear 
1328			      sbc   HL, BC 
1328			      push  HL                      ; Store the result for later (new block size) 
1328			 
1328			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1328			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1328			 
1328			      ; this_free block is not big enough, setup ptrs to test next free block 
1328			      pop   HL                      ; Discard previous result 
1328			 
1328			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1328			      ld    H, (IX+3) 
1328			      ld    (IX+4), L 
1328			      ld    (IX+5), H 
1328			 
1328			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1328			      ld    H, (IX+1) 
1328			      ld    (IX+2), L 
1328			      ld    (IX+3), H 
1328			 
1328			      jr    malloc_find_space 
1328			 
1328			      ; split a bigger block into two - requested size and remaining size 
1328			malloc_alloc_split: 
1328			      ex    DE, HL                  ; Calculate address of new free block 
1328			      dec   HL 
1328			      dec   HL 
1328			      dec   HL 
1328			      add   HL, BC 
1328			 
1328			      ; Create a new block and point it at next_free 
1328			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1328			      ld    D, (IX+1) 
1328			 
1328			      ld    (HL), E                 ; Store next_free ptr into new block 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			      pop   DE                      ; Store size of new block into new block 
1328			      inc   HL 
1328			      ld    (HL), E 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			      ; Update this_free ptr to point to new block 
1328			      dec   HL 
1328			      dec   HL 
1328			      dec   HL 
1328			 
1328			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1328			      ld    D, (IX+3) 
1328			 
1328			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1328			      ld    (IX+3), H 
1328			 
1328			      ; Modify this_free block to be allocation 
1328			      ex    DE, HL 
1328			      xor   A                       ; Null the next block ptr of allocated block 
1328			      ld    (HL), A 
1328			      inc   HL 
1328			      ld    (HL), A 
1328			 
1328			      inc   HL                      ; Store want size into allocated block 
1328			      ld    (HL), C 
1328			      inc   HL 
1328			      ld    (HL), B 
1328			      inc   HL 
1328			      push  HL                      ; Address of allocation to return 
1328			 
1328			      jr    malloc_update_links 
1328			 
1328			malloc_alloc_fit: 
1328			      pop   HL                      ; Dont need new block size, want is exact fit 
1328			 
1328			      ; Modify this_free block to be allocation 
1328			      ex    DE, HL 
1328			      dec   HL 
1328			      dec   HL 
1328			      dec   HL 
1328			 
1328			      xor   A                       ; Null the next block ptr of allocated block 
1328			      ld    (HL), A 
1328			      inc   HL 
1328			      ld    (HL), A 
1328			 
1328			      inc   HL                      ; Store address of allocation to return 
1328			      inc   HL 
1328			      inc   HL 
1328			      push  HL 
1328			 
1328			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1328			      ld    L, (IX+0)               ; next_free to HL 
1328			      ld    H, (IX+1) 
1328			 
1328			      ld    (IX+2), L               ; HL to this_free 
1328			      ld    (IX+3), H 
1328			 
1328			 
1328			malloc_update_links: 
1328			      ; Update prev_free ptr to point to this_free 
1328			      ld    L, (IX+4)               ; prev_free ptr to HL 
1328			      ld    H, (IX+5) 
1328			 
1328			      ld    E, (IX+2)               ; this_free ptr to DE 
1328			      ld    D, (IX+3) 
1328			 
1328			      ld    (HL), E                 ; this_free ptr into prev_free 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			      ; Clear the Z flag to indicate successful allocation 
1328			      ld    A, D 
1328			      or    E 
1328			 
1328			      pop   DE                      ; Address of allocation 
1328			 
1328			malloc_no_space: 
1328			      ld    HL, 6                   ; Clean up stack frame 
1328			      add   HL, SP 
1328			      ld    SP, HL 
1328			 
1328			      ex    DE, HL                  ; Alloc addr into HL for return 
1328			 
1328			malloc_early_exit: 
1328			      pop   IX 
1328			      pop   DE 
1328			      pop   BC 
1328			 
1328			      ret 
1328			 
1328			 
1328			;------------------------------------------------------------------------------ 
1328			;     free                                                                    : 
1328			;                                                                             : 
1328			; Description                                                                 : 
1328			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1328			;     returned by malloc, otherwise the behaviour is undefined.               : 
1328			;                                                                             : 
1328			;     Where possible, directly adjacent free blocks will be merged together   : 
1328			;     into larger blocks to help ensure that the heap does not become         : 
1328			;     excessively fragmented.                                                 : 
1328			;                                                                             : 
1328			;     free does not clear or set any other value into the freed space, and    : 
1328			;     therefore its contents may be visible through subsequent malloc's. The  : 
1328			;     caller should clear the freed space as required.                        : 
1328			;                                                                             : 
1328			;     This implementation of free uses the stack exclusively, and is          : 
1328			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1328			;     advisable to disable interrupts before calling free, and recommended    : 
1328			;     to avoid the use of free inside ISRs in general.                        : 
1328			;                                                                             : 
1328			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1328			;                                                                             : 
1328			; Parameters                                                                  : 
1328			;     HL  Pointer to address of first byte of allocation to be freed          : 
1328			;                                                                             : 
1328			; Returns                                                                     : 
1328			;     Nothing                                                                 : 
1328			;                                                                             : 
1328			; Stack frame                                                                 : 
1328			;       |             |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |     BC      |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |     DE      |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |     IX      |                                                       : 
1328			;       +-------------+                                                       : 
1328			;       |  prev_free  |                                                       : 
1328			;   +2  +-------------+                                                       : 
1328			;       |  next_free  |                                                       : 
1328			;   +0  +-------------+                                                       : 
1328			;       |             |                                                       : 
1328			;                                                                             : 
1328			;------------------------------------------------------------------------------ 
1328			free: 
1328			      push  BC 
1328			      push  DE 
1328			      push  IX 
1328			 
1328			      ld    A, H                    ; Exit if ptr is null 
1328			      or    L 
1328			      jp    Z, free_early_exit 
1328			 
1328			      ; Set up stack frame 
1328			      ex    DE, HL 
1328			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1328			      add   HL, SP 
1328			      ld    SP, HL 
1328			      ld    IX, 0                   ; Use IX as a frame pointer 
1328			      add   IX, SP 
1328			 
1328			      ; The address in HL points to the start of the useable allocated space, 
1328			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1328			      ; address of the block itself. 
1328			      ex    DE, HL 
1328			      ld    DE, -4 
1328			      add   HL, DE 
1328			 
1328			      ; An allocated block must have a null next block pointer in it 
1328			      ld    A, (HL) 
1328			      inc   HL 
1328			      or    (HL) 
1328			      jp    NZ, free_done 
1328			 
1328			      dec   HL 
1328			 
1328			      ld    B, H                    ; Copy HL to BC 
1328			      ld    C, L 
1328			 
1328			      ; Loop through the free list to find the first block with an address 
1328			      ; higher than the block being freed 
1328			      ld    HL, free_list 
1328			 
1328			free_find_higher_block: 
1328			      ld    E, (HL)                 ; Load next ptr from free block 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      dec   HL 
1328			 
1328			      ld    (IX+0), E               ; Save ptr to next free block 
1328			      ld    (IX+1), D 
1328			      ld    (IX+2), L               ; Save ptr to prev free block 
1328			      ld    (IX+3), H 
1328			 
1328			      ld    A, B                    ; Check if DE is greater than BC 
1328			      cp    D                       ; Compare MSB first 
1328			      jr    Z, $+4                  ; MSB the same, compare LSB 
1328			      jr    NC, free_find_higher_block_skip 
1328			      ld    A, C 
1328			      cp    E                       ; Then compare LSB 
1328			      jr    C, free_found_higher_block 
1328			 
1328			free_find_higher_block_skip: 
1328			      ld    A, D                    ; Reached the end of the free list? 
1328			      or    E 
1328			      jp    Z, free_done 
1328			 
1328			      ex    DE, HL 
1328			 
1328			      jr    free_find_higher_block 
1328			 
1328			free_found_higher_block: 
1328			      ; Insert freed block between prev and next free blocks 
1328			      ld    (HL), C                 ; Point prev free block to freed block 
1328			      inc   HL 
1328			      ld    (HL), B 
1328			 
1328			      ld    H, B                    ; Point freed block at next free block 
1328			      ld    L, C 
1328			      ld    (HL), E 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			      ; Check if the freed block is adjacent to the next free block 
1328			      inc   HL                      ; Load size of freed block into HL 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      ex    DE, HL 
1328			 
1328			      add   HL, BC                  ; Add addr of freed block and its size 
1328			 
1328			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1328			      ld    D, (IX+1) 
1328			 
1328			      or    A                       ; Clear the carry flag 
1328			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1328			      jr    NZ, free_check_adjacent_to_prev 
1328			 
1328			      ; Freed block is adjacent to next, merge into one bigger block 
1328			      ex    DE, HL                  ; Load next ptr from next block into DE 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      push  HL                      ; Save ptr to next block for later 
1328			 
1328			      ld    H, B                    ; Store ptr from next block into freed block 
1328			      ld    L, C 
1328			      ld    (HL), E 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			      pop   HL                      ; Restore ptr to next block 
1328			      inc   HL                      ; Load size of next block into DE 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      push  DE                      ; Save next block size for later 
1328			 
1328			      ld    H, B                    ; Load size of freed block into HL 
1328			      ld    L, C 
1328			      inc   HL 
1328			      inc   HL 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      ex    DE, HL 
1328			 
1328			      pop   DE                      ; Restore size of next block 
1328			      add   HL, DE                  ; Add sizes of both blocks 
1328			      ex    DE, HL 
1328			 
1328			      ld    H, B                    ; Store new bigger size into freed block 
1328			      ld    L, C 
1328			      inc   HL 
1328			      inc   HL 
1328			      ld    (HL), E 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			free_check_adjacent_to_prev: 
1328			      ; Check if the freed block is adjacent to the prev free block 
1328			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1328			      ld    H, (IX+3) 
1328			 
1328			      inc   HL                      ; Size of prev free block into DE 
1328			      inc   HL 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      dec   HL 
1328			      dec   HL 
1328			      dec   HL 
1328			 
1328			      add   HL, DE                  ; Add prev block addr and size 
1328			 
1328			      or    A                       ; Clear the carry flag 
1328			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1328			      jr    NZ, free_done 
1328			 
1328			      ; Freed block is adjacent to prev, merge into one bigger block 
1328			      ld    H, B                    ; Load next ptr from freed block into DE 
1328			      ld    L, C 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      push  HL                      ; Save freed block ptr for later 
1328			 
1328			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1328			      ld    H, (IX+3) 
1328			      ld    (HL), E 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			      pop   HL                      ; Restore freed block ptr 
1328			      inc   HL                      ; Load size of freed block into DE 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			      push  DE                      ; Save freed block size for later 
1328			 
1328			      ld    L, (IX+2)               ; Load size of prev block into DE 
1328			      ld    H, (IX+3) 
1328			      inc   HL 
1328			      inc   HL 
1328			      ld    E, (HL) 
1328			      inc   HL 
1328			      ld    D, (HL) 
1328			 
1328			      pop   HL                      ; Add sizes of both blocks 
1328			      add   HL, DE 
1328			      ex    DE, HL 
1328			 
1328			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1328			      ld    H, (IX+3) 
1328			      inc   HL 
1328			      inc   HL 
1328			      ld    (HL), E 
1328			      inc   HL 
1328			      ld    (HL), D 
1328			 
1328			free_done: 
1328			      ld    HL, 4                   ; Clean up stack frame 
1328			      add   HL, SP 
1328			      ld    SP, HL 
1328			 
1328			free_early_exit: 
1328			      pop   IX 
1328			      pop   DE 
1328			      pop   BC 
1328			 
1328			      ret 
1328			 
1328			 
1328			;      .org 0x8000 
1328			; 
1328			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1328			 ;                 .dw   0 
1328			 
1328			endif 
1328			 
1328			 
1328			if MALLOC_4 
1328			 
1328			; My memory allocation code. Very very simple.... 
1328			; allocate space under 250 chars 
1328			 
1328			heap_init: 
1328				; init start of heap as zero 
1328				;  
1328			 
1328				ld hl, heap_start 
1328				ld a, 0 
1328				ld (hl), a      ; empty block 
1328				inc hl 
1328				ld a, 0 
1328				ld (hl), a      ; length of block 
1328				; write end of list 
1328				inc hl 
1328				ld a,(hl) 
1328				inc hl 
1328				ld a,(hl) 
1328				 
1328			 
1328				; init some malloc vars 
1328			 
1328				ld hl, 0 
1328				ld (free_list), hl       ; store last malloc location 
1328			 
1328				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1328				ld a, 0 
1328				ld (hl), a 
1328			 
1328			 
1328				ld hl, heap_start 
1328				;  
1328				  
1328				ret 
1328			 
1328			 
1328			;    free block marker 
1328			;    requested size  
1328			;    pointer to next block 
1328			;    .... 
1328			;    next block marker 
1328			 
1328			 
1328			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1328			; 
1328			 
1328			 
1328			malloc:  
1328				push de 
1328				push bc 
1328				push af 
1328			 
1328				; hl space required 
1328				 
1328				ld c, l    ; hold space   (TODO only a max of 255) 
1328			 
1328			;	inc c     ; TODO BUG need to fix memory leak on push str 
1328			;	inc c 
1328			;	inc c 
1328			;	inc c 
1328			;	inc c 
1328			;	inc c 
1328			;	inc c 
1328			 
1328			 
1328			 
1328				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1328			 
1328				ld a, (free_list+3) 
1328				cp 0 
1328				jr z, .contheap 
1328			 
1328				ld hl, (free_list)     ; get last alloc 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "mrs" 
1328						CALLMONITOR 
1328					endif 
1328				jr .startalloc 
1328			 
1328			.contheap: 
1328				ld hl, heap_start 
1328			 
1328			.startalloc: 
1328			 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "mym" 
1328						CALLMONITOR 
1328					endif 
1328			.findblock: 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "mmf" 
1328						CALLMONITOR 
1328					endif 
1328			 
1328				ld a,(hl)  
1328				; if byte is zero then clear to use 
1328			 
1328				cp 0 
1328				jr z, .foundemptyblock 
1328			 
1328				; if byte is not clear 
1328				;     then byte is offset to next block 
1328			 
1328				inc hl 
1328				ld a, (hl) ; get size 
1328			.nextblock:	inc hl 
1328					ld e, (hl) 
1328					inc hl 
1328					ld d, (hl) 
1328					ex de, hl 
1328			;	inc hl  ; move past the store space 
1328			;	inc hl  ; move past zero index  
1328			 
1328				; TODO detect no more space 
1328			 
1328				push hl 
1328				ld de, heap_end 
1328				call cmp16 
1328				pop hl 
1328				jr nc, .nospace 
1328			 
1328				jr .findblock 
1328			 
1328			.nospace: ld hl, 0 
1328				jp .exit 
1328			 
1328			 
1328			.foundemptyblock:	 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "mme" 
1328						CALLMONITOR 
1328					endif 
1328			 
1328			; TODO has block enough space if reusing??? 
1328			 
1328				;  
1328			 
1328			; see if this block has been previously used 
1328				inc hl 
1328				ld a, (hl) 
1328				dec hl 
1328				cp 0 
1328				jr z, .newblock 
1328			 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "meR" 
1328						CALLMONITOR 
1328					endif 
1328			 
1328			; no reusing previously allocated block 
1328			 
1328			; is it smaller than previously used? 
1328				 
1328				inc hl    ; move to size 
1328				ld a, c 
1328				sub (hl)        ; we want c < (hl) 
1328				dec hl    ; move back to marker 
1328			        jr z, .findblock 
1328			 
1328				; update with the new size which should be lower 
1328			 
1328			        ;inc  hl   ; negate next move. move back to size  
1328			 
1328			.newblock: 
1328				; need to be at marker here 
1328			 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "meN" 
1328						CALLMONITOR 
1328					endif 
1328			 
1328			 
1328				ld a, c 
1328			 
1328				ld (free_list+3), a	 ; flag resume from last malloc  
1328				ld (free_list), hl    ; save out last location 
1328			 
1328			 
1328				;inc a     ; space for length byte 
1328				ld (hl), a     ; save block in use marker 
1328			 
1328				inc hl   ; move to space marker 
1328				ld (hl), a    ; save new space 
1328			 
1328				inc hl   ; move to start of allocated area 
1328				 
1328			;	push hl     ; save where we are - 1  
1328			 
1328			;	inc hl  ; move past zero index  
1328				; skip space to set down new marker 
1328			 
1328				; provide some extra space for now 
1328			 
1328				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1328				inc a 
1328				inc a 
1328			 
1328				push hl   ; save where we are in the node block 
1328			 
1328				call addatohl 
1328			 
1328				; write linked list point 
1328			 
1328				pop de     ; get our node position 
1328				ex de, hl 
1328			 
1328				ld (hl), e 
1328				inc hl 
1328				ld (hl), d 
1328			 
1328				inc hl 
1328			 
1328				; now at start of allocated data so save pointer 
1328			 
1328				push hl 
1328			 
1328				; jump to position of next node and setup empty header in DE 
1328			 
1328				ex de, hl 
1328			 
1328			;	inc hl ; move past end of block 
1328			 
1328				ld a, 0 
1328				ld (hl), a   ; empty marker 
1328				inc hl 
1328				ld (hl), a   ; size 
1328				inc hl  
1328				ld (hl), a   ; ptr 
1328				inc hl 
1328				ld (hl), a   ; ptr 
1328			 
1328			 
1328				pop hl 
1328			 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "mmr" 
1328						CALLMONITOR 
1328					endif 
1328			 
1328			.exit: 
1328				pop af 
1328				pop bc 
1328				pop de  
1328				ret 
1328			 
1328			 
1328			 
1328			 
1328			free:  
1328				push hl 
1328				push af 
1328				; get address in hl 
1328			 
1328					if DEBUG_FORTH_MALLOC_INT 
1328						DMARK "fre" 
1328						CALLMONITOR 
1328					endif 
1328				; data is at hl - move to block count 
1328				dec hl 
1328				dec hl    ; get past pointer 
1328				dec hl 
1328			 
1328				ld a, (hl)    ; need this for a validation check 
1328			 
1328				dec hl    ; move to block marker 
1328			 
1328				; now check that the block count and block marker are the same  
1328			        ; this checks that we are on a malloc node and not random memory 
1328			        ; OK a faint chance this could be a problem but rare - famous last words! 
1328			 
1328				ld c, a 
1328				ld a, (hl)    
1328			 
1328				cp c 
1328				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1328			 
1328				; yes good chance we are on a malloc node 
1328			 
1328				ld a, 0      
1328				ld (hl), a   ; mark as free 
1328			 
1328				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1328			 
1328			.freeignore:  
1328			 
1328				pop af 
1328				pop hl 
1328			 
1328				ret 
1328			 
1328			 
1328			 
1328			endif 
1328			 
1328			; eof 
# End of file firmware_memory.asm
1328			  
1328			; device C  
1328			if SOUND_ENABLE  
1328				include "firmware_sound.asm"  
1328			endif  
1328			  
1328			include "firmware_diags.asm"  
1328			; Hardware diags menu 
1328			 
1328			 
1328			config: 
1328			 
1328 3e 00			ld a, 0 
132a 21 49 13			ld hl, .configmn 
132d cd c5 0a			call menu 
1330			 
1330 fe 00			cp 0 
1332 c8				ret z 
1333			 
1333 fe 01			cp 1 
1335 cc d1 13			call z, .savetostore 
1338			 
1338 fe 03			cp 3 
133a cc cf 13			call z, .selbank 
133d fe 05			cp 5 
133f cc ac 14			call z, .debug_tog 
1342 fe 06			cp 6 
1344 cc d2 14			call z, hardware_diags 
1347			 
1347 18 df			jr config 
1349			 
1349			.configmn: 
1349 57 13			dw .c3 
134b 73 13			dw .c2 
134d 88 13			dw .c2b 
134f 9c 13			dw .c4 
1351 a5 13			dw .m4 
1353 c0 13			dw .c1 
1355 00 00			dw 0 
1357				 
1357			 
1357 .. 00		.c3: db "Add User Dictionary To File",0 
1373 .. 00		.c2: db "Select Autoload File",0 
1388 .. 00		.c2b: db "Select Storage Bank",0 
139c .. 00		.c4: db "Settings",0 
13a5 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
13c0 .. 00		.c1: db "Hardware Diags",0 
13cf			 
13cf			; Select storage bank 
13cf			 
13cf			.selbank: 
13cf			 
13cf				if STORAGE_SE 
13cf				endif 
13cf				 
13cf c9				ret 
13d0			 
13d0			if STORAGE_SE 
13d0			 
13d0			.config_ldir:   
13d0				; Load storage bank labels into menu array 
13d0			 
13d0				 
13d0			 
13d0			 
13d0 c9				ret 
13d1			 
13d1			 
13d1			endif 
13d1			 
13d1			 
13d1			; Save user words to storage 
13d1			 
13d1			.savetostore: 
13d1			 
13d1				if STORAGE_SE 
13d1			 
13d1 cd f6 13				call config_dir 
13d4 21 a3 ef			        ld hl, scratch 
13d7 3e 00				ld a, 0 
13d9 cd c5 0a				call menu 
13dc					 
13dc 21 a3 ef				ld hl, scratch 
13df cd e3 13				call config_fdir 
13e2			 
13e2			 
13e2				endif 
13e2			 
13e2 c9				ret 
13e3			 
13e3			 
13e3			 
13e3			if STORAGE_SE 
13e3			 
13e3			config_fdir: 
13e3				; using the scratch dir go through and release the memory allocated for each string 
13e3				 
13e3 21 a3 ef			ld hl, scratch 
13e6 5e			.cfdir:	ld e,(hl) 
13e7 23				inc hl 
13e8 56				ld d,(hl) 
13e9 23				inc hl 
13ea			 
13ea eb				ex de, hl 
13eb cd f1 0c			call ishlzero 
13ee c8				ret z     ; return on null pointer 
13ef cd 59 12			call free 
13f2 eb				ex de, hl 
13f3 18 f1			jr .cfdir 
13f5			 
13f5			 
13f5 c9				ret 
13f6			 
13f6			 
13f6			config_dir: 
13f6			 
13f6				; for the config menus that need to build a directory of storage call this routine 
13f6				; it will construct a menu in scratch to pass to menu 
13f6			 
13f6				; open storage device 
13f6			 
13f6				; execute DIR to build a list of files and their ids into scratch in menu format 
13f6				; once the menu has finished then will need to call config_fdir to release the strings 
13f6				 
13f6				; c = number items 
13f6			 
13f6				 
13f6 cd ba 03			call storage_get_block_0 
13f9			 
13f9 21 e8 f9			ld hl, store_page     ; get current id count 
13fc 46				ld b, (hl) 
13fd 0e 00			ld c, 0    ; count of files   
13ff			 
13ff			 
13ff 21 a3 ef			ld hl, scratch 
1402 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1405			 
1405				; check for empty drive 
1405			 
1405 3e 00			ld a, 0 
1407 b8				cp b 
1408 ca a2 14			jp z, .dirdone 
140b			 
140b				 
140b					if DEBUG_FORTH_WORDS 
140b						DMARK "Cdc" 
140b f5				push af  
140c 3a 20 14			ld a, (.dmark)  
140f 32 bd fb			ld (debug_mark),a  
1412 3a 21 14			ld a, (.dmark+1)  
1415 32 be fb			ld (debug_mark+1),a  
1418 3a 22 14			ld a, (.dmark+2)  
141b 32 bf fb			ld (debug_mark+2),a  
141e 18 03			jr .pastdmark  
1420 ..			.dmark: db "Cdc"  
1423 f1			.pastdmark: pop af  
1424			endm  
# End of macro DMARK
1424						CALLMONITOR 
1424 cd ea 15			call break_point_state  
1427				endm  
# End of macro CALLMONITOR
1427					endif 
1427			 
1427			 
1427			.diritem:	 
1427 c5				push bc 
1428				; for each of the current ids do a search for them and if found push to stack 
1428			 
1428 21 40 00				ld hl, STORE_BLOCK_PHY 
142b 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
142d 58					ld e,b 
142e			 
142e cd 27 06				call storage_findnextid 
1431			 
1431			 
1431					; if found hl will be non zero 
1431			 
1431 cd f1 0c				call ishlzero 
1434 28 69				jr z, .dirnotfound 
1436			 
1436					; increase count 
1436			 
1436 c1					pop bc	 
1437 0c					inc c 
1438 c5					push bc 
1439					 
1439			 
1439					; get file header and push the file name 
1439			 
1439 11 e8 f9				ld de, store_page 
143c cd 09 03				call storage_read_block 
143f			 
143f					; push file id to stack 
143f				 
143f 3a e8 f9				ld a, (store_page) 
1442 26 00				ld h, 0 
1444 6f					ld l, a 
1445			 
1445					;call forth_push_numhl 
1445					; TODO store id 
1445			 
1445 e5					push hl 
1446			 
1446					; push extent count to stack  
1446				 
1446 21 eb f9				ld hl, store_page+3 
1449			 
1449					; get file name length 
1449			 
1449 cd 26 11				call strlenz   
144c			 
144c 23					inc hl   ; cover zero term 
144d 23					inc hl  ; stick the id at the end of the area 
144e			 
144e e5					push hl 
144f c1					pop bc    ; move length to bc 
1450			 
1450 cd 8f 11				call malloc 
1453			 
1453					; TODO save malloc area to scratch 
1453			 
1453 eb					ex de, hl 
1454 2a e4 f9				ld hl, (store_tmp2) 
1457 73					ld (hl), e 
1458 23					inc hl 
1459 72					ld (hl), d 
145a 23					inc hl 
145b 22 e4 f9				ld (store_tmp2), hl 
145e			 
145e					 
145e			 
145e					;pop hl   ; get source 
145e			;		ex de, hl    ; swap aronund	 
145e			 
145e 21 eb f9				ld hl, store_page+3 
1461					if DEBUG_FORTH_WORDS 
1461						DMARK "CFd" 
1461 f5				push af  
1462 3a 76 14			ld a, (.dmark)  
1465 32 bd fb			ld (debug_mark),a  
1468 3a 77 14			ld a, (.dmark+1)  
146b 32 be fb			ld (debug_mark+1),a  
146e 3a 78 14			ld a, (.dmark+2)  
1471 32 bf fb			ld (debug_mark+2),a  
1474 18 03			jr .pastdmark  
1476 ..			.dmark: db "CFd"  
1479 f1			.pastdmark: pop af  
147a			endm  
# End of macro DMARK
147a						CALLMONITOR 
147a cd ea 15			call break_point_state  
147d				endm  
# End of macro CALLMONITOR
147d					endif 
147d ed b0				ldir 
147f			 
147f					; de is past string, move back one and store id 
147f					 
147f 1b					dec de 
1480			 
1480					; store file id 
1480			 
1480 e1					pop hl 
1481 eb					ex de,hl 
1482 73					ld (hl), e 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "Cdi" 
1483 f5				push af  
1484 3a 98 14			ld a, (.dmark)  
1487 32 bd fb			ld (debug_mark),a  
148a 3a 99 14			ld a, (.dmark+1)  
148d 32 be fb			ld (debug_mark+1),a  
1490 3a 9a 14			ld a, (.dmark+2)  
1493 32 bf fb			ld (debug_mark+2),a  
1496 18 03			jr .pastdmark  
1498 ..			.dmark: db "Cdi"  
149b f1			.pastdmark: pop af  
149c			endm  
# End of macro DMARK
149c						CALLMONITOR 
149c cd ea 15			call break_point_state  
149f				endm  
# End of macro CALLMONITOR
149f					endif 
149f					 
149f			.dirnotfound: 
149f c1					pop bc     
14a0 10 85				djnz .diritem 
14a2				 
14a2			.dirdone:	 
14a2			 
14a2 3e 00				ld a, 0 
14a4 2a e4 f9				ld hl, (store_tmp2) 
14a7 77					ld (hl), a 
14a8 23					inc hl 
14a9 77					ld (hl), a 
14aa 23					inc hl 
14ab					; push a count of the dir items found 
14ab			 
14ab			;		ld h, 0 
14ab			;		ld l, c 
14ab			 
14ab c9				ret 
14ac			 
14ac			endif 
14ac			 
14ac			 
14ac			; Settings 
14ac			; Run  
14ac			 
14ac			 
14ac			 
14ac			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14ac			;;hd_menu2:   db "        2: Editor",0   
14ac			;hd_menu2:   db "        2: Editor       6: Menu",0   
14ac			;hd_menu3:   db "        3: Storage",0 
14ac			;hd_menu4:   db "0=quit  4: Debug",0 
14ac			;hd_don:     db "ON",0 
14ac			;hd_doff:     db "OFF",0 
14ac			; 
14ac			; 
14ac			; 
14ac			;hardware_diags_old:       
14ac			; 
14ac			;.diagmenu: 
14ac			;	call clear_display 
14ac			;	ld a, display_row_1 
14ac			;	ld de, hd_menu1 
14ac			;	call str_at_display 
14ac			; 
14ac			;	ld a, display_row_2 
14ac			;	ld de, hd_menu2 
14ac			;	call str_at_display 
14ac			; 
14ac			;	ld a, display_row_3 
14ac			;	ld de, hd_menu3 
14ac			;	call str_at_display 
14ac			; 
14ac			;	ld a,  display_row_4 
14ac			;	ld de, hd_menu4 
14ac			;	call str_at_display 
14ac			; 
14ac			;	; display debug state 
14ac			; 
14ac			;	ld de, hd_don 
14ac			;	ld a, (os_view_disable) 
14ac			;	cp 0 
14ac			;	jr z, .distog 
14ac			;	ld de, hd_doff 
14ac			;.distog: ld a, display_row_4+17 
14ac			;	call str_at_display 
14ac			; 
14ac			;	call update_display 
14ac			; 
14ac			;	call cin_wait 
14ac			; 
14ac			; 
14ac			; 
14ac			;	cp '4' 
14ac			;	jr nz, .diagn1 
14ac			; 
14ac			;	; debug toggle 
14ac			; 
14ac			;	ld a, (os_view_disable) 
14ac			;	ld b, '*' 
14ac			;	cp 0 
14ac			;	jr z, .debtog 
14ac			;	ld b, 0 
14ac			;.debtog:	 
14ac			;	ld a,b 
14ac			;	ld (os_view_disable),a 
14ac			; 
14ac			;.diagn1: cp '0' 
14ac			;	 ret z 
14ac			; 
14ac			;;	cp '1' 
14ac			;;       jp z, matrix	 
14ac			;;   TODO keyboard matrix test 
14ac			; 
14ac			;	cp '2' 
14ac			;	jp z, .diagedit 
14ac			; 
14ac			;;	cp '6' 
14ac			;;	jp z, .menutest 
14ac			;;if ENABLE_BASIC 
14ac			;;	cp '6' 
14ac			;;	jp z, basic 
14ac			;;endif 
14ac			 ; 
14ac			;	jp .diagmenu 
14ac			; 
14ac			; 
14ac			;	ret 
14ac			 
14ac			 
14ac			.debug_tog: 
14ac 21 f3 14			ld hl, .menudebug 
14af				 
14af 3a 94 ef			ld a, (os_view_disable) 
14b2 fe 2a			cp '*' 
14b4 20 04			jr nz,.tdon  
14b6 3e 01			ld a, 1 
14b8 18 02			jr .tog1 
14ba 3e 00		.tdon: ld a, 0 
14bc			 
14bc			.tog1: 
14bc cd c5 0a			call menu 
14bf fe 00			cp 0 
14c1 c8				ret z 
14c2 fe 01			cp 1    ; disable debug 
14c4 28 04			jr z, .dtog0 
14c6 3e 2a			ld a, '*' 
14c8 18 02			jr .dtogset 
14ca 3e 00		.dtog0: ld a, 0 
14cc 32 94 ef		.dtogset:  ld (os_view_disable), a 
14cf c3 ac 14			jp .debug_tog 
14d2			 
14d2			 
14d2			hardware_diags:       
14d2			 
14d2			.diagm: 
14d2 21 e5 14			ld hl, .menuitems 
14d5 3e 00			ld a, 0 
14d7 cd c5 0a			call menu 
14da			 
14da fe 00		         cp 0 
14dc c8				 ret z 
14dd			 
14dd fe 02			cp 2 
14df ca 3e 15			jp z, .diagedit 
14e2			 
14e2			;	cp '6' 
14e2			;	jp z, .menutest 
14e2			;if ENABLE_BASIC 
14e2			;	cp '6' 
14e2			;	jp z, basic 
14e2			;endif 
14e2			  
14e2 c3 d2 14			jp .diagm 
14e5			 
14e5				 
14e5 f9 14		.menuitems:   	dw .m1 
14e7 04 15				dw .m2 
14e9 0b 15				dw .m3 
14eb 13 15				dw .m5 
14ed 19 15				dw .m5a 
14ef 22 15				dw .m5b 
14f1 00 00				dw 0 
14f3			 
14f3			.menudebug: 
14f3 2b 15				dw .m6 
14f5 34 15				dw .m7 
14f7 00 00				dw 0 
14f9			 
14f9 .. 00		.m1:   db "Key Matrix",0 
1504 .. 00		.m2:   db "Editor",0 
150b .. 00		.m3:   db "Storage",0 
1513 .. 00		.m5:   db "Sound",0 
1519 .. 00		.m5a:  db "RAM Test",0 
1522 .. 00		.m5b:  db "LCD Test",0 
152b			 
152b .. 00		.m6:   db "Debug ON",0 
1534 .. 00		.m7:   db "Debug OFF",0 
153e			 
153e			; debug editor 
153e			 
153e			.diagedit: 
153e			 
153e 21 a3 ef			ld hl, scratch 
1541			;	ld bc, 250 
1541			;	ldir 
1541				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1541 3e 00			ld a, 0 
1543 77				ld (hl), a 
1544 23				inc hl 
1545 77				ld (hl), a 
1546 23				inc hl 
1547 77				ld (hl), a 
1548			 
1548 cd 94 0a		        call clear_display 
154b cd b7 0a			call update_display 
154e 3e 01			ld a, 1 
1550 32 c3 fb			ld (hardware_diag), a 
1553			.diloop: 
1553 3e 00			ld a, display_row_1 
1555 0e 00			ld c, 0 
1557 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1559 1e 28			ld e, 40 
155b			 
155b 21 a3 ef			ld hl, scratch	 
155e cd f5 0c			call input_str 
1561			 
1561 3e 14			ld a, display_row_2 
1563 11 a3 ef			ld de, scratch 
1566 cd a7 0a			call str_at_display 
1569 cd b7 0a			call update_display 
156c			 
156c c3 53 15			jp .diloop 
156f			 
156f			 
156f			; pass word in hl 
156f			; a has display location 
156f			display_word_at: 
156f f5				push af 
1570 e5				push hl 
1571 7c				ld a,h 
1572 21 a8 f2			ld hl, os_word_scratch 
1575 cd c9 0f			call hexout 
1578 e1				pop hl 
1579 7d				ld a,l 
157a 21 aa f2			ld hl, os_word_scratch+2 
157d cd c9 0f			call hexout 
1580 21 ac f2			ld hl, os_word_scratch+4 
1583 3e 00			ld a,0 
1585 77				ld (hl),a 
1586 11 a8 f2			ld de,os_word_scratch 
1589 f1				pop af 
158a cd a7 0a				call str_at_display 
158d c9				ret 
158e			 
158e			display_ptr_state: 
158e			 
158e				; to restore afterwards 
158e			 
158e d5				push de 
158f c5				push bc 
1590 e5				push hl 
1591 f5				push af 
1592			 
1592				; for use in here 
1592			 
1592			;	push bc 
1592			;	push de 
1592			;	push hl 
1592			;	push af 
1592			 
1592 cd 94 0a			call clear_display 
1595			 
1595 11 68 17			ld de, .ptrstate 
1598 3e 00			ld a, display_row_1 
159a cd a7 0a			call str_at_display 
159d			 
159d				; display debug step 
159d			 
159d			 
159d 11 bd fb			ld de, debug_mark 
15a0 3e 12			ld a, display_row_1+display_cols-2 
15a2 cd a7 0a			call str_at_display 
15a5			 
15a5				; display a 
15a5 11 72 17			ld de, .ptrcliptr 
15a8 3e 14			ld a, display_row_2 
15aa cd a7 0a			call str_at_display 
15ad			 
15ad f1				pop af 
15ae 2a ae f9			ld hl,(cli_ptr) 
15b1 3e 1c			ld a, display_row_2+8 
15b3 cd 6f 15			call display_word_at 
15b6			 
15b6			 
15b6				; display hl 
15b6			 
15b6			 
15b6 11 7a 17			ld de, .ptrclioptr 
15b9 3e 1e			ld a, display_row_2+10 
15bb cd a7 0a			call str_at_display 
15be			; 
15be			;	pop hl 
15be 3e 21			ld a, display_row_2+13 
15c0 2a ac f9			ld hl,(cli_origptr) 
15c3 cd 6f 15			call display_word_at 
15c6			; 
15c6			;	 
15c6			;	; display de 
15c6			 
15c6			;	ld de, .regstatede 
15c6			;	ld a, display_row_3 
15c6			;	call str_at_display 
15c6			 
15c6			;	pop de 
15c6			;	ld h,d 
15c6			;	ld l, e 
15c6			;	ld a, display_row_3+3 
15c6			;	call display_word_at 
15c6			 
15c6			 
15c6				; display bc 
15c6			 
15c6			;	ld de, .regstatebc 
15c6			;	ld a, display_row_3+10 
15c6			;	call str_at_display 
15c6			 
15c6			;	pop bc 
15c6			;	ld h,b 
15c6			;	ld l, c 
15c6			;	ld a, display_row_3+13 
15c6			;	call display_word_at 
15c6			 
15c6			 
15c6				; display dsp 
15c6			 
15c6			;	ld de, .regstatedsp 
15c6			;	ld a, display_row_4 
15c6			;	call str_at_display 
15c6			 
15c6				 
15c6			;	ld hl,(cli_data_sp) 
15c6			;	ld a, display_row_4+4 
15c6			;	call display_word_at 
15c6			 
15c6				; display rsp 
15c6			 
15c6 11 a9 17			ld de, .regstatersp 
15c9 3e 46			ld a, display_row_4+10 
15cb cd a7 0a			call str_at_display 
15ce			 
15ce				 
15ce 2a 94 f9			ld hl,(cli_ret_sp) 
15d1 3e 4a			ld a, display_row_4+14 
15d3 cd 6f 15			call display_word_at 
15d6			 
15d6 cd b7 0a			call update_display 
15d9			 
15d9 cd 42 0a			call delay1s 
15dc cd 42 0a			call delay1s 
15df cd 42 0a			call delay1s 
15e2			 
15e2			 
15e2 cd ef 1a			call next_page_prompt 
15e5			 
15e5				; restore  
15e5			 
15e5 f1				pop af 
15e6 e1				pop hl 
15e7 c1				pop bc 
15e8 d1				pop de 
15e9 c9				ret 
15ea			 
15ea			break_point_state: 
15ea f5				push af 
15eb			 
15eb				; see if disabled 
15eb			 
15eb 3a 94 ef			ld a, (os_view_disable) 
15ee fe 2a			cp '*' 
15f0 20 02			jr nz, .bpsgo 
15f2 f1				pop af 
15f3 c9				ret 
15f4			 
15f4			.bpsgo: 
15f4 f1				pop af 
15f5 f5				push af 
15f6 22 90 ef			ld (os_view_hl), hl 
15f9 ed 53 8e ef		ld (os_view_de), de 
15fd ed 43 8c ef		ld (os_view_bc), bc 
1601 e5				push hl 
1602 6f				ld l, a 
1603 26 00			ld h, 0 
1605 22 92 ef			ld (os_view_af),hl 
1608			 
1608 21 53 fb				ld hl, display_fb0 
160b 22 5e fa				ld (display_fb_active), hl 
160e e1				pop hl	 
160f			 
160f 3e 31			ld a, '1' 
1611 fe 2a		.bps1:  cp '*' 
1613 20 03			jr nz, .bps1b 
1615 32 94 ef			ld (os_view_disable),a 
1618 fe 31		.bps1b:  cp '1' 
161a 20 14			jr nz, .bps2 
161c			 
161c				; display reg 
161c			 
161c				 
161c			 
161c 3a 92 ef			ld a, (os_view_af) 
161f 2a 90 ef			ld hl, (os_view_hl) 
1622 ed 5b 8e ef		ld de, (os_view_de) 
1626 ed 4b 8c ef		ld bc, (os_view_bc) 
162a cd c4 16			call display_reg_state 
162d c3 b0 16			jp .bpschk 
1630			 
1630 fe 32		.bps2:  cp '2' 
1632 20 08			jr nz, .bps3 
1634				 
1634				; display hl 
1634 2a 90 ef			ld hl, (os_view_hl) 
1637 cd ae 17			call display_dump_at_hl 
163a			 
163a 18 74			jr .bpschk 
163c			 
163c fe 33		.bps3:  cp '3' 
163e 20 08			jr nz, .bps4 
1640			 
1640			        ; display de 
1640 2a 8e ef			ld hl, (os_view_de) 
1643 cd ae 17			call display_dump_at_hl 
1646			 
1646 18 68			jr .bpschk 
1648 fe 34		.bps4:  cp '4' 
164a 20 08			jr nz, .bps5 
164c			 
164c			        ; display bc 
164c 2a 8c ef			ld hl, (os_view_bc) 
164f cd ae 17			call display_dump_at_hl 
1652			 
1652 18 5c			jr .bpschk 
1654 fe 35		.bps5:  cp '5' 
1656 20 08		        jr nz, .bps7 
1658			 
1658				; display cur ptr 
1658 2a ae f9			ld hl, (cli_ptr) 
165b cd ae 17			call display_dump_at_hl 
165e			 
165e 18 50			jr .bpschk 
1660 fe 36		.bps7:  cp '6' 
1662 20 08			jr nz, .bps8b 
1664				 
1664				; display cur orig ptr 
1664 2a ac f9			ld hl, (cli_origptr) 
1667 cd ae 17			call display_dump_at_hl 
166a 18 44			jr .bpschk 
166c fe 37		.bps8b:  cp '7' 
166e 20 08			jr nz, .bps9 
1670				 
1670				; display dsp 
1670 2a 90 f9			ld hl, (cli_data_sp) 
1673 cd ae 17			call display_dump_at_hl 
1676			 
1676 18 38			jr .bpschk 
1678 fe 39		.bps9:  cp '9' 
167a 20 05			jr nz, .bps8c 
167c				 
167c				; display SP 
167c			;	ld hl, sp 
167c cd ae 17			call display_dump_at_hl 
167f			 
167f 18 2f			jr .bpschk 
1681 fe 38		.bps8c:  cp '8' 
1683 20 08			jr nz, .bps8d 
1685				 
1685				; display rsp 
1685 2a 94 f9			ld hl, (cli_ret_sp) 
1688 cd ae 17			call display_dump_at_hl 
168b			 
168b 18 23			jr .bpschk 
168d fe 23		.bps8d:  cp '#'     ; access monitor sub system 
168f 20 05			jr nz, .bps8 
1691 cd e5 18			call monitor 
1694			 
1694 18 1a			jr .bpschk 
1696 fe 30		.bps8:  cp '0' 
1698 20 16			jr nz, .bpschk 
169a			 
169a 21 02 fb				ld hl, display_fb1 
169d 22 5e fa				ld (display_fb_active), hl 
16a0 cd b7 0a				call update_display 
16a3			 
16a3				;ld a, (os_view_af) 
16a3 2a 90 ef			ld hl, (os_view_hl) 
16a6 ed 5b 8e ef		ld de, (os_view_de) 
16aa ed 4b 8c ef		ld bc, (os_view_bc) 
16ae f1				pop af 
16af c9				ret 
16b0			 
16b0			.bpschk:   
16b0 cd 42 0a			call delay1s 
16b3 3e 4f		ld a,display_row_4 + display_cols - 1 
16b5 11 ed 1a		        ld de, endprg 
16b8 cd a7 0a			call str_at_display 
16bb cd b7 0a			call update_display 
16be cd c9 65			call cin_wait 
16c1			 
16c1 c3 11 16			jp .bps1 
16c4			 
16c4			 
16c4			display_reg_state: 
16c4			 
16c4				; to restore afterwards 
16c4			 
16c4 d5				push de 
16c5 c5				push bc 
16c6 e5				push hl 
16c7 f5				push af 
16c8			 
16c8				; for use in here 
16c8			 
16c8 c5				push bc 
16c9 d5				push de 
16ca e5				push hl 
16cb f5				push af 
16cc			 
16cc cd 94 0a			call clear_display 
16cf			 
16cf 11 84 17			ld de, .regstate 
16d2 3e 00			ld a, display_row_1 
16d4 cd a7 0a			call str_at_display 
16d7			 
16d7				; display debug step 
16d7			 
16d7			 
16d7 11 bd fb			ld de, debug_mark 
16da 3e 11			ld a, display_row_1+display_cols-3 
16dc cd a7 0a			call str_at_display 
16df			 
16df				; display a 
16df 11 a0 17			ld de, .regstatea 
16e2 3e 14			ld a, display_row_2 
16e4 cd a7 0a			call str_at_display 
16e7			 
16e7 e1				pop hl 
16e8			;	ld h,0 
16e8			;	ld l, a 
16e8 3e 17			ld a, display_row_2+3 
16ea cd 6f 15			call display_word_at 
16ed			 
16ed			 
16ed				; display hl 
16ed			 
16ed			 
16ed 11 94 17			ld de, .regstatehl 
16f0 3e 1e			ld a, display_row_2+10 
16f2 cd a7 0a			call str_at_display 
16f5			 
16f5 e1				pop hl 
16f6 3e 21			ld a, display_row_2+13 
16f8 cd 6f 15			call display_word_at 
16fb			 
16fb				 
16fb				; display de 
16fb			 
16fb 11 98 17			ld de, .regstatede 
16fe 3e 28			ld a, display_row_3 
1700 cd a7 0a			call str_at_display 
1703			 
1703 e1				pop hl 
1704			;	ld h,d 
1704			;	ld l, e 
1704 3e 2b			ld a, display_row_3+3 
1706 cd 6f 15			call display_word_at 
1709			 
1709			 
1709				; display bc 
1709			 
1709 11 9c 17			ld de, .regstatebc 
170c 3e 32			ld a, display_row_3+10 
170e cd a7 0a			call str_at_display 
1711			 
1711 e1				pop hl 
1712			;	ld h,b 
1712			;	ld l, c 
1712 3e 35			ld a, display_row_3+13 
1714 cd 6f 15			call display_word_at 
1717			 
1717			 
1717				; display dsp 
1717			 
1717 11 a4 17			ld de, .regstatedsp 
171a 3e 3c			ld a, display_row_4 
171c cd a7 0a			call str_at_display 
171f			 
171f				 
171f 2a 90 f9			ld hl,(cli_data_sp) 
1722 3e 40			ld a, display_row_4+4 
1724 cd 6f 15			call display_word_at 
1727			 
1727				; display rsp 
1727			 
1727 11 a9 17			ld de, .regstatersp 
172a 3e 46			ld a, display_row_4+10 
172c cd a7 0a			call str_at_display 
172f			 
172f				 
172f 2a 94 f9			ld hl,(cli_ret_sp) 
1732 3e 4a			ld a, display_row_4+14 
1734 cd 6f 15			call display_word_at 
1737			 
1737 cd b7 0a			call update_display 
173a			 
173a			;	call delay1s 
173a			;	call delay1s 
173a			;	call delay1s 
173a			 
173a			 
173a			;	call next_page_prompt 
173a			 
173a				; restore  
173a			 
173a f1				pop af 
173b e1				pop hl 
173c c1				pop bc 
173d d1				pop de 
173e c9				ret 
173f			 
173f .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1753 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1768 .. 00		.ptrstate:	db "Ptr State",0 
1772 .. 00		.ptrcliptr:     db "cli_ptr",0 
177a .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1784 .. 00		.regstate:	db "Reg State (1/0)",0 
1794 .. 00		.regstatehl:	db "HL:",0 
1798 .. 00		.regstatede:	db "DE:",0 
179c .. 00		.regstatebc:	db "BC:",0 
17a0 .. 00		.regstatea:	db "A :",0 
17a4 .. 00		.regstatedsp:	db "DSP:",0 
17a9 .. 00		.regstatersp:	db "RSP:",0 
17ae			 
17ae			display_dump_at_hl: 
17ae e5				push hl 
17af d5				push de 
17b0 c5				push bc 
17b1 f5				push af 
17b2			 
17b2 22 c6 f2			ld (os_cur_ptr),hl	 
17b5 cd 94 0a			call clear_display 
17b8 cd f7 19			call dumpcont 
17bb			;	call delay1s 
17bb			;	call next_page_prompt 
17bb			 
17bb			 
17bb f1				pop af 
17bc c1				pop bc 
17bd d1				pop de 
17be e1				pop hl 
17bf c9				ret 
17c0			 
17c0			;if ENABLE_BASIC 
17c0			;	include "nascombasic.asm" 
17c0			;	basic: 
17c0			;	include "forth/FORTH.ASM" 
17c0			;endif 
17c0			 
17c0			; eof 
17c0			 
17c0			 
# End of file firmware_diags.asm
17c0			  
17c0			  
17c0			  
17c0			  
17c0			; eof  
17c0			  
# End of file firmware.asm
17c0			 
17c0			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
17c0			;if BASE_KEV  
17c0			;baseram: equ 08000h 
17c0			;endif 
17c0			 
17c0			;if BASE_SC114 
17c0			;baseram:     equ    endofcode 
17c0			;endif 
17c0			 
17c0			 
17c0			; start system 
17c0			 
17c0			coldstart: 
17c0				; set sp 
17c0				; di/ei 
17c0			 
17c0 f3				di 
17c1 31 fd ff			ld sp, tos 
17c4			;	ei 
17c4			 
17c4			 
17c4				; disable breakpoint by default 
17c4			 
17c4 3e 2a			ld a,'*' 
17c6 32 94 ef			ld (os_view_disable),a 
17c9			 
17c9				; init hardware 
17c9			 
17c9				; init keyboard and screen hardware 
17c9			 
17c9 cd 03 00			call hardware_init 
17cc			 
17cc			 
17cc				; detect if any keys are held down to enable breakpoints at start up 
17cc			 
17cc cd da 65			call cin  
17cf fe 00			cp 0 
17d1 28 03			jr z, .nokeys 
17d3			 
17d3				;call hardware_diags 
17d3 cd 28 13			call config 
17d6			 
17d6			;	ld de, .bpen 
17d6			;	ld a, display_row_4 
17d6			;	call str_at_display 
17d6			;	call update_display 
17d6			; 
17d6			;	ld a,0 
17d6			;	ld (os_view_disable),a 
17d6			; 
17d6			;.bpwait: 
17d6			;	call cin 
17d6			;	cp 0 
17d6			;	jr z, .bpwait 
17d6			;	jr .nokeys 
17d6			; 
17d6			; 
17d6			;.bpen:  db "Break points enabled!",0 
17d6			 
17d6			 
17d6			 
17d6			 
17d6			 
17d6			 
17d6			.nokeys: 
17d6			 
17d6			 
17d6				 
17d6			 
17d6			;jp  testkey 
17d6			 
17d6			;call storage_get_block_0 
17d6			; 
17d6			;ld hl, 0 
17d6			;ld de, store_page 
17d6			;call storage_read_block 
17d6			 
17d6				 
17d6			;ld hl, 10 
17d6			;ld de, store_page 
17d6			;call storage_read_block 
17d6			 
17d6			 
17d6			 
17d6			 
17d6			 
17d6			;stop:	nop 
17d6			;	jp stop 
17d6			 
17d6			 
17d6			 
17d6			main: 
17d6 cd 94 0a			call clear_display 
17d9 cd b7 0a			call update_display 
17dc			 
17dc			 
17dc			 
17dc			;	call testlcd 
17dc			 
17dc			 
17dc			 
17dc cd b5 1e			call forth_init 
17df			 
17df			 
17df			warmstart: 
17df cd 8b 1e			call forth_warmstart 
17e2			 
17e2				; run startup word load 
17e2			        ; TODO prevent this running at warmstart after crash  
17e2			 
17e2				if STARTUP_ENABLE 
17e2 cd 43 61				call forth_startup 
17e5				endif 
17e5			 
17e5				; show free memory after boot 
17e5 11 7f 18			ld de, freeram 
17e8 3e 00			ld a, display_row_1 
17ea cd a7 0a			call str_at_display 
17ed			 
17ed			; Or use heap_size word???? 
17ed 21 89 ef			ld hl, heap_end 
17f0 11 0e 80			ld de, heap_start 
17f3 ed 52			sbc hl, de 
17f5 e5				push hl 
17f6 7c				ld a,h	         	 
17f7 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17fa cd c9 0f			call hexout 
17fd e1			   	pop hl 
17fe			 
17fe 7d				ld a,l 
17ff 21 aa f2			ld hl, os_word_scratch+2 
1802 cd c9 0f			call hexout 
1805 21 ac f2			ld hl, os_word_scratch+4 
1808 3e 00			ld a, 0 
180a 77				ld (hl),a 
180b 11 a8 f2			ld de, os_word_scratch 
180e 3e 0d			ld a, display_row_1 + 13 
1810 cd a7 0a			call str_at_display 
1813 cd b7 0a			call update_display 
1816			 
1816			 
1816				;call demo 
1816			 
1816			 
1816				; init scratch input area for cli commands 
1816			 
1816 21 ca f2			ld hl, os_cli_cmd 
1819 3e 00			ld a,0 
181b 77				ld (hl),a 
181c 23				inc hl 
181d 77				ld (hl),a 
181e			 
181e 3e 00			ld a,0 
1820 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1823			 
1823 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1826 32 c7 f2			ld (os_cur_ptr+1),a	 
1829			 
1829 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
182c 32 a9 f2			ld (os_word_scratch+1),a	 
182f				 
182f			 
182f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
182f 21 ca f2			ld hl, os_cli_cmd 
1832			 
1832 3e 00			ld a, 0		 ; init cli input 
1834 77				ld (hl), a 
1835 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1837			cli: 
1837				; show cli prompt 
1837				;push af 
1837				;ld a, 0 
1837				;ld de, prompt 
1837				;call str_at_display 
1837			 
1837				;call update_display 
1837				;pop af 
1837				;inc a 
1837				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1837 0e 00			ld c, 0 
1839 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
183b 1e 28			ld e, 40 
183d			 
183d 21 ca f2			ld hl, os_cli_cmd 
1840			 
1840				STACKFRAME OFF $fefe $9f9f 
1840				if DEBUG_STACK_IMB 
1840					if OFF 
1840						exx 
1840						ld de, $fefe 
1840						ld a, d 
1840						ld hl, curframe 
1840						call hexout 
1840						ld a, e 
1840						ld hl, curframe+2 
1840						call hexout 
1840						ld hl, $fefe 
1840						push hl 
1840						ld hl, $9f9f 
1840						push hl 
1840						exx 
1840					endif 
1840				endif 
1840			endm 
# End of macro STACKFRAME
1840			 
1840 cd f5 0c			call input_str 
1843			 
1843				STACKFRAMECHK OFF $fefe $9f9f 
1843				if DEBUG_STACK_IMB 
1843					if OFF 
1843						exx 
1843						ld hl, $9f9f 
1843						pop de   ; $9f9f 
1843						call cmp16 
1843						jr nz, .spnosame 
1843						ld hl, $fefe 
1843						pop de   ; $fefe 
1843						call cmp16 
1843						jr z, .spfrsame 
1843						.spnosame: call showsperror 
1843						.spfrsame: nop 
1843						exx 
1843					endif 
1843				endif 
1843			endm 
# End of macro STACKFRAMECHK
1843			 
1843				; copy input to last command 
1843			 
1843 21 ca f2			ld hl, os_cli_cmd 
1846 11 c9 f3			ld de, os_last_cmd 
1849 01 ff 00			ld bc, 255 
184c ed b0			ldir 
184e			 
184e				; wipe current buffer 
184e			 
184e			;	ld a, 0 
184e			;	ld hl, os_cli_cmd 
184e			;	ld de, os_cli_cmd+1 
184e			;	ld bc, 254 
184e			;	ldir 
184e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
184e			;	call strcpy 
184e			;	ld a, 0 
184e			;	ld (hl), a 
184e			;	inc hl 
184e			;	ld (hl), a 
184e			;	inc hl 
184e			;	ld (hl), a 
184e			 
184e				; switch frame buffer to program  
184e			 
184e 21 02 fb				ld hl, display_fb1 
1851 22 5e fa				ld (display_fb_active), hl 
1854			 
1854			;	nop 
1854				STACKFRAME ON $fbfe $8f9f 
1854				if DEBUG_STACK_IMB 
1854					if ON 
1854						exx 
1854						ld de, $fbfe 
1854						ld a, d 
1854						ld hl, curframe 
1854						call hexout 
1854						ld a, e 
1854						ld hl, curframe+2 
1854						call hexout 
1854						ld hl, $fbfe 
1854						push hl 
1854						ld hl, $8f9f 
1854						push hl 
1854						exx 
1854					endif 
1854				endif 
1854			endm 
# End of macro STACKFRAME
1854				; first time into the parser so pass over the current scratch pad 
1854 21 ca f2			ld hl,os_cli_cmd 
1857				; tokenise the entered statement(s) in HL 
1857 cd 2e 1f			call forthparse 
185a			        ; exec forth statements in top of return stack 
185a cd 6e 1f			call forthexec 
185d				;call forthexec_cleanup 
185d			;	call parsenext 
185d			 
185d				STACKFRAMECHK ON $fbfe $8f9f 
185d				if DEBUG_STACK_IMB 
185d					if ON 
185d						exx 
185d						ld hl, $8f9f 
185d						pop de   ; $8f9f 
185d						call cmp16 
185d						jr nz, .spnosame 
185d						ld hl, $fbfe 
185d						pop de   ; $fbfe 
185d						call cmp16 
185d						jr z, .spfrsame 
185d						.spnosame: call showsperror 
185d						.spfrsame: nop 
185d						exx 
185d					endif 
185d				endif 
185d			endm 
# End of macro STACKFRAMECHK
185d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
185d			 
185d 3e 3c			ld a, display_row_4 
185f 11 91 18			ld de, endprog 
1862			 
1862 cd b7 0a			call update_display		 
1865			 
1865 cd ef 1a			call next_page_prompt 
1868			 
1868				; switch frame buffer to cli 
1868			 
1868 21 53 fb				ld hl, display_fb0 
186b 22 5e fa				ld (display_fb_active), hl 
186e			 
186e			 
186e cd 94 0a		        call clear_display 
1871 cd b7 0a			call update_display		 
1874			 
1874 21 ca f2			ld hl, os_cli_cmd 
1877			 
1877 3e 00			ld a, 0		 ; init cli input 
1879 77				ld (hl), a 
187a			 
187a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
187a			 
187a				; now on last line 
187a			 
187a				; TODO scroll screen up 
187a			 
187a				; TODO instead just clear screen and place at top of screen 
187a			 
187a			;	ld a, 0 
187a			;	ld (f_cursor_ptr),a 
187a			 
187a				;call clear_display 
187a				;call update_display 
187a			 
187a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
187a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
187c c3 37 18			jp cli 
187f			 
187f .. 00		freeram: db "Free bytes: $",0 
188d ..			asc: db "1A2F" 
1891 .. 00		endprog: db "End prog...",0 
189d			 
189d			testenter2:   
189d 21 d5 ef			ld hl,scratch+50 
18a0 22 c6 f2			ld (os_cur_ptr),hl 
18a3 c3 37 18			jp cli 
18a6			 
18a6			testenter:  
18a6			 
18a6 21 8d 18			ld hl,asc 
18a9			;	ld a,(hl) 
18a9			;	call nibble2val 
18a9 cd 1f 10			call get_byte 
18ac			 
18ac			 
18ac			;	ld a,(hl) 
18ac			;	call atohex 
18ac			 
18ac			;	call fourehexhl 
18ac 32 d5 ef			ld (scratch+50),a 
18af			 
18af			 
18af			 
18af 21 8f 18			ld hl,asc+2 
18b2			;	ld a, (hl) 
18b2			;	call nibble2val 
18b2 cd 1f 10			call get_byte 
18b5			 
18b5			;	call fourehexhl 
18b5 32 d7 ef			ld (scratch+52),a 
18b8				 
18b8 21 d5 ef			ld hl,scratch+50 
18bb 22 c6 f2			ld (os_cur_ptr),hl 
18be c3 37 18			jp cli 
18c1			 
18c1			enter:	 
18c1 3a a7 ef			ld a,(scratch+4) 
18c4 fe 00			cp 0 
18c6 28 0c			jr z, .entercont 
18c8				; no, not a null term line so has an address to work out.... 
18c8			 
18c8 21 a5 ef			ld hl,scratch+2 
18cb cd 7f 10			call get_word_hl 
18ce			 
18ce 22 c6 f2			ld (os_cur_ptr),hl	 
18d1 c3 37 18			jp cli 
18d4			 
18d4			 
18d4			.entercont:  
18d4			 
18d4 21 a5 ef			ld hl, scratch+2 
18d7 cd 1f 10			call get_byte 
18da			 
18da 2a c6 f2		   	ld hl,(os_cur_ptr) 
18dd 77					ld (hl),a 
18de 23					inc hl 
18df 22 c6 f2				ld (os_cur_ptr),hl 
18e2				 
18e2			; get byte  
18e2			 
18e2			 
18e2 c3 37 18			jp cli 
18e5			 
18e5			 
18e5			; basic monitor support 
18e5			 
18e5			monitor: 
18e5				;  
18e5 cd 94 0a			call clear_display 
18e8 3e 00			ld a, 0 
18ea 11 32 19			ld de, .monprompt 
18ed cd a7 0a			call str_at_display 
18f0 cd b7 0a			call update_display 
18f3			 
18f3				; get a monitor command 
18f3			 
18f3 0e 00			ld c, 0     ; entry at top left 
18f5 16 64			ld d, 100   ; max buffer size 
18f7 1e 0f			ld e, 15    ; input scroll area 
18f9 3e 00			ld a, 0     ; init string 
18fb 21 a1 f1			ld hl, os_input 
18fe 77				ld (hl), a 
18ff 23				inc hl 
1900 77				ld (hl), a 
1901 21 a1 f1			ld hl, os_input 
1904 3e 01			ld a, 1     ; init string 
1906 cd f5 0c			call input_str 
1909			 
1909 cd 94 0a		        call clear_display 
190c cd b7 0a			call update_display		 
190f			 
190f 3a a1 f1			ld a, (os_input) 
1912 cd 1d 11			call toUpper 
1915 fe 48		        cp 'H' 
1917 28 6f		        jr z, .monhelp 
1919 fe 44			cp 'D'		; dump 
191b ca a9 19			jp z, .mondump	 
191e fe 43			cp 'C'		; dump 
1920 ca c3 19			jp z, .moncdump	 
1923 fe 4d			cp 'M'		; dump 
1925 ca 34 19			jp z, .moneditstart 
1928 fe 55			cp 'U'		; dump 
192a 28 14			jr z, .monedit	 
192c fe 51			cp 'Q'		; dump 
192e c8				ret z	 
192f			 
192f			 
192f				; TODO "S" to access symbol by name and not need the address 
192f				; TODO "F" to find a string in memory 
192f			 
192f c3 e5 18			jp monitor 
1932			 
1932 .. 00		.monprompt: db ">", 0 
1934			 
1934			.moneditstart: 
1934				; get starting address 
1934			 
1934 21 a3 f1			ld hl,os_input+2 
1937 cd 7f 10			call get_word_hl 
193a			 
193a 22 c6 f2			ld (os_cur_ptr),hl	 
193d			 
193d c3 e5 18			jp monitor 
1940			 
1940			.monedit: 
1940				; get byte to load 
1940			 
1940 21 a3 f1			ld hl,os_input+2 
1943 cd 1f 10			call get_byte 
1946			 
1946				; get address to update 
1946 2a c6 f2			ld hl, (os_cur_ptr) 
1949			 
1949				; update byte 
1949			 
1949 77				ld (hl), a 
194a			 
194a				; move to next address and save it 
194a			 
194a 23				inc hl 
194b 22 c6 f2			ld (os_cur_ptr),hl	 
194e			 
194e c3 e5 18			jp monitor 
1951			 
1951			 
1951 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1965 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1981 .. 00		.monhelptext3:  db "Q-Quit",0 
1988			        
1988			.monhelp: 
1988 3e 00			ld a, display_row_1 
198a 11 51 19		        ld de, .monhelptext1 
198d			 
198d cd a7 0a			call str_at_display 
1990 3e 14			ld a, display_row_2 
1992 11 65 19		        ld de, .monhelptext2 
1995					 
1995 cd a7 0a			call str_at_display 
1998 3e 28			ld a, display_row_3 
199a 11 81 19		        ld de, .monhelptext3 
199d					 
199d cd a7 0a			call str_at_display 
19a0 cd b7 0a			call update_display		 
19a3			 
19a3 cd ef 1a			call next_page_prompt 
19a6 c3 e5 18			jp monitor 
19a9			 
19a9			.mondump:    
19a9 21 a3 f1			ld hl,os_input+2 
19ac cd 7f 10			call get_word_hl 
19af			 
19af 22 c6 f2			ld (os_cur_ptr),hl	 
19b2 cd f7 19			call dumpcont 
19b5 3e 3c			ld a, display_row_4 
19b7 11 91 18			ld de, endprog 
19ba			 
19ba cd b7 0a			call update_display		 
19bd			 
19bd cd ef 1a			call next_page_prompt 
19c0 c3 e5 18			jp monitor 
19c3			.moncdump: 
19c3 cd f7 19			call dumpcont 
19c6 3e 3c			ld a, display_row_4 
19c8 11 91 18			ld de, endprog 
19cb			 
19cb cd b7 0a			call update_display		 
19ce			 
19ce cd ef 1a			call next_page_prompt 
19d1 c3 e5 18			jp monitor 
19d4			 
19d4			 
19d4			; TODO symbol access  
19d4			 
19d4			.symbols:     ;; A list of symbols that can be called up  
19d4 53 fb			dw display_fb0 
19d6 .. 00			db "fb0",0  
19da e8 f9		     	dw store_page 
19dc .. 00			db "store_page",0 
19e7			 
19e7			 
19e7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
19e7			 
19e7 3a a4 ef			ld a,(scratch+1) 
19ea fe 00			cp 0 
19ec 28 09			jr z, dumpcont 
19ee			 
19ee				; no, not a null term line so has an address to work out.... 
19ee			 
19ee 21 a5 ef			ld hl,scratch+2 
19f1 cd 7f 10			call get_word_hl 
19f4			 
19f4 22 c6 f2			ld (os_cur_ptr),hl	 
19f7			 
19f7			 
19f7			 
19f7			dumpcont: 
19f7			 
19f7				; dump bytes at ptr 
19f7			 
19f7			 
19f7 3e 00			ld a, display_row_1 
19f9 2a 5e fa			ld hl, (display_fb_active) 
19fc cd c8 0c			call addatohl 
19ff cd 27 1a			call .dumpbyterow 
1a02			 
1a02 3e 14			ld a, display_row_2 
1a04 2a 5e fa			ld hl, (display_fb_active) 
1a07 cd c8 0c			call addatohl 
1a0a cd 27 1a			call .dumpbyterow 
1a0d			 
1a0d			 
1a0d 3e 28			ld a, display_row_3 
1a0f 2a 5e fa			ld hl, (display_fb_active) 
1a12 cd c8 0c			call addatohl 
1a15 cd 27 1a			call .dumpbyterow 
1a18			 
1a18 3e 3c			ld a, display_row_4 
1a1a 2a 5e fa			ld hl, (display_fb_active) 
1a1d cd c8 0c			call addatohl 
1a20 cd 27 1a			call .dumpbyterow 
1a23			 
1a23 cd b7 0a			call update_display 
1a26			;		jp cli 
1a26 c9				ret 
1a27			 
1a27			.dumpbyterow: 
1a27			 
1a27				;push af 
1a27			 
1a27 e5				push hl 
1a28			 
1a28				; calc where to poke the ascii 
1a28			if display_cols == 20 
1a28 3e 10			ld a, 16 
1a2a			else 
1a2a				ld a, 31 
1a2a			endif 
1a2a			 
1a2a cd c8 0c			call addatohl 
1a2d 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1a30			 
1a30			 
1a30			; display decoding address 
1a30 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a33			 
1a33 7c				ld a,h 
1a34 e1				pop hl 
1a35 e5				push hl 
1a36			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a36 cd c9 0f			call hexout 
1a39 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a3c			 
1a3c 7d				ld a,l 
1a3d e1				pop hl 
1a3e 23				inc hl 
1a3f 23				inc hl 
1a40 e5				push hl 
1a41			;	ld hl, os_word_scratch+2 
1a41 cd c9 0f			call hexout 
1a44 e1				pop hl 
1a45 23				inc hl 
1a46 23				inc hl 
1a47				;ld hl, os_word_scratch+4 
1a47 3e 3a			ld a, ':' 
1a49 77				ld (hl),a 
1a4a 23				inc hl 
1a4b				;ld a, 0 
1a4b				;ld (hl),a 
1a4b				;ld de, os_word_scratch 
1a4b				;pop af 
1a4b				;push af 
1a4b			;		ld a, display_row_2 
1a4b			;		call str_at_display 
1a4b			;		call update_display 
1a4b			 
1a4b			 
1a4b			;pop af 
1a4b			;	add 5 
1a4b			 
1a4b			if display_cols == 20 
1a4b 06 04			ld b, 4 
1a4d			else 
1a4d				ld b, 8 
1a4d			endif	 
1a4d			 
1a4d			.dumpbyte: 
1a4d c5				push bc 
1a4e e5				push hl 
1a4f			 
1a4f			 
1a4f 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a52 7e					ld a,(hl) 
1a53			 
1a53					; poke the ascii to display 
1a53 2a a8 f2				ld hl,(os_word_scratch) 
1a56 77					ld (hl),a 
1a57 23					inc hl 
1a58 22 a8 f2				ld (os_word_scratch),hl 
1a5b			 
1a5b					 
1a5b			 
1a5b			 
1a5b e1					pop hl 
1a5c e5					push hl 
1a5d			 
1a5d cd c9 0f				call hexout 
1a60			 
1a60					 
1a60 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a63 23				inc hl 
1a64 22 c6 f2		   	ld (os_cur_ptr),hl 
1a67			 
1a67 e1					pop hl 
1a68 23					inc hl 
1a69 23					inc hl 
1a6a 23					inc hl 
1a6b			 
1a6b			 
1a6b			 
1a6b					;ld a,0 
1a6b					;ld (os_word_scratch+2),a 
1a6b					;pop af 
1a6b					;push af 
1a6b			 
1a6b					;ld de, os_word_scratch 
1a6b					;call str_at_display 
1a6b			;		call update_display 
1a6b			;		pop af 
1a6b c1					pop bc 
1a6c c6 03				add 3 
1a6e 10 dd			djnz .dumpbyte 
1a70			 
1a70				 
1a70			 
1a70 c9				ret 
1a71			 
1a71			jump:	 
1a71			 
1a71 21 a5 ef			ld hl,scratch+2 
1a74 cd 7f 10			call get_word_hl 
1a77				;ld hl,(scratch+2) 
1a77				;call fourehexhl 
1a77			 
1a77 22 c6 f2			ld (os_cur_ptr),hl	 
1a7a			 
1a7a e9				jp (hl) 
1a7b			 
1a7b			 
1a7b			 
1a7b			; TODO implement a basic monitor mode to start with 
1a7b			 
1a7b			 
1a7b			 
1a7b			 
1a7b			 
1a7b			 
1a7b			 
1a7b			 
1a7b			 
1a7b			; testing and demo code during development 
1a7b			 
1a7b			 
1a7b .. 00		str1: db "Enter some text...",0 
1a8e .. 00		clear: db "                    ",0 
1aa3			 
1aa3			demo: 
1aa3			 
1aa3			 
1aa3			 
1aa3			;	call update_display 
1aa3			 
1aa3				; init scratch input area for testing 
1aa3 21 a3 ef			ld hl, scratch	 
1aa6 3e 00			ld a,0 
1aa8 77				ld (hl),a 
1aa9			 
1aa9			 
1aa9 3e 14		            LD   A, display_row_2 
1aab			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aab 11 7b 1a		            LD   DE, str1 
1aae cd a7 0a			call str_at_display 
1ab1			 
1ab1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ab1			cloop:	 
1ab1 3e 28		            LD   A, display_row_3 
1ab3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ab3 11 8e 1a		            LD   DE, clear 
1ab6			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ab6 cd a7 0a				call str_at_display 
1ab9 3e 3c			ld a, display_row_4 
1abb 11 eb 1a			ld de, prompt 
1abe			 
1abe cd a7 0a				call str_at_display 
1ac1 cd b7 0a			call update_display 
1ac4			 
1ac4 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ac6 16 0a			ld d, 10 
1ac8 21 a3 ef			ld hl, scratch	 
1acb cd f5 0c			call input_str 
1ace			 
1ace			;	call clear_display 
1ace			;'	call update_display 
1ace			 
1ace 3e 00		            LD   A, display_row_1 
1ad0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ad0 11 8e 1a		            LD   DE, clear 
1ad3 cd a7 0a				call str_at_display 
1ad6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ad6 3e 00		            LD   A, display_row_1 
1ad8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ad8 11 a3 ef		            LD   DE, scratch 
1adb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1adb cd a7 0a				call str_at_display 
1ade cd b7 0a			call update_display 
1ae1			 
1ae1 3e 00				ld a,0 
1ae3 21 a3 ef			ld hl, scratch 
1ae6 77				ld (hl),a 
1ae7			 
1ae7 00				nop 
1ae8 c3 b1 1a			jp cloop 
1aeb			 
1aeb			 
1aeb			 
1aeb			; OS Prompt 
1aeb			 
1aeb .. 00		prompt: db ">",0 
1aed .. 00		endprg: db "?",0 
1aef			 
1aef			 
1aef			; handy next page prompt 
1aef			next_page_prompt: 
1aef e5				push hl 
1af0 d5				push de 
1af1 f5				push af 
1af2 c5				push bc 
1af3			 
1af3 3e 4f			ld a,display_row_4 + display_cols - 1 
1af5 11 ed 1a		        ld de, endprg 
1af8 cd a7 0a			call str_at_display 
1afb cd b7 0a			call update_display 
1afe cd c9 65			call cin_wait 
1b01 c1				pop bc 
1b02 f1				pop af 
1b03 d1				pop de 
1b04 e1				pop hl 
1b05			 
1b05			 
1b05 c9				ret 
1b06			 
1b06			 
1b06			; forth parser 
1b06			 
1b06			; My forth kernel 
1b06			include "forth_kernel.asm" 
1b06			; 
1b06			; kernel to the forth OS 
1b06			 
1b06			DS_TYPE_STR: equ 1     ; string type 
1b06			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b06			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b06			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b06			 
1b06			FORTH_PARSEV1: equ 0 
1b06			FORTH_PARSEV2: equ 0 
1b06			FORTH_PARSEV3: equ 0 
1b06			FORTH_PARSEV4: equ 0 
1b06			FORTH_PARSEV5: equ 1 
1b06			 
1b06			;if FORTH_PARSEV5 
1b06			;	FORTH_END_BUFFER: equ 0 
1b06			;else 
1b06			FORTH_END_BUFFER: equ 127 
1b06			;endif 
1b06			 
1b06			FORTH_TRUE: equ 1 
1b06			FORTH_FALSE: equ 0 
1b06			 
1b06			if FORTH_PARSEV4 
1b06			include "forth_stackops.asm" 
1b06			endif 
1b06			 
1b06			if FORTH_PARSEV5 
1b06			include "forth_stackopsv5.asm" 
1b06			 
1b06			; Stack operations for v5 parser on wards 
1b06			; * DATA stack 
1b06			; * LOOP stack 
1b06			; * RETURN stack 
1b06			 
1b06			 
1b06			 
1b06			FORTH_CHK_DSP_UNDER: macro 
1b06				push hl 
1b06				push de 
1b06				ld hl,(cli_data_sp) 
1b06				ld de, cli_data_stack 
1b06				call cmp16 
1b06				jp c, fault_dsp_under 
1b06				pop de 
1b06				pop hl 
1b06				endm 
1b06			 
1b06			 
1b06			FORTH_CHK_RSP_UNDER: macro 
1b06				push hl 
1b06				push de 
1b06				ld hl,(cli_ret_sp) 
1b06				ld de, cli_ret_stack 
1b06				call cmp16 
1b06				jp c, fault_rsp_under 
1b06				pop de 
1b06				pop hl 
1b06				endm 
1b06			 
1b06			FORTH_CHK_LOOP_UNDER: macro 
1b06				push hl 
1b06				push de 
1b06				ld hl,(cli_loop_sp) 
1b06				ld de, cli_loop_stack 
1b06				call cmp16 
1b06				jp c, fault_loop_under 
1b06				pop de 
1b06				pop hl 
1b06				endm 
1b06			 
1b06			FORTH_ERR_TOS_NOTSTR: macro 
1b06				; TOSO might need more for checks when used 
1b06				push af 
1b06				ld a,(hl) 
1b06				cp DS_TYPE_STR 
1b06				jp nz, type_faultn   
1b06				pop af 
1b06				endm 
1b06			 
1b06			FORTH_ERR_TOS_NOTNUM: macro 
1b06				push af 
1b06				ld a,(hl) 
1b06				cp DS_TYPE_INUM 
1b06				jp nz, type_faultn   
1b06				pop af 
1b06				endm 
1b06			 
1b06			 
1b06			; increase data stack pointer and save hl to it 
1b06				 
1b06			FORTH_DSP_NEXT: macro 
1b06				call macro_forth_dsp_next 
1b06				endm 
1b06			 
1b06			 
1b06			macro_forth_dsp_next: 
1b06				if DEBUG_FORTH_STACK_GUARD 
1b06 cd 0d 62				call check_stacks 
1b09				endif 
1b09 e5				push hl 
1b0a d5				push de 
1b0b eb				ex de,hl 
1b0c 2a 90 f9			ld hl,(cli_data_sp) 
1b0f 23				inc hl 
1b10 23				inc hl 
1b11			 
1b11			; PARSEV5 
1b11 23				inc hl 
1b12 22 90 f9			ld (cli_data_sp),hl 
1b15 73				ld (hl), e 
1b16 23				inc hl 
1b17 72				ld (hl), d 
1b18 d1				pop de 
1b19 e1				pop hl 
1b1a				if DEBUG_FORTH_STACK_GUARD 
1b1a cd 0d 62				call check_stacks 
1b1d				endif 
1b1d c9				ret 
1b1e			 
1b1e			 
1b1e			; increase ret stack pointer and save hl to it 
1b1e				 
1b1e			FORTH_RSP_NEXT: macro 
1b1e				call macro_forth_rsp_next 
1b1e				endm 
1b1e			 
1b1e			macro_forth_rsp_next: 
1b1e				if DEBUG_FORTH_STACK_GUARD 
1b1e cd 0d 62				call check_stacks 
1b21				endif 
1b21 e5				push hl 
1b22 d5				push de 
1b23 eb				ex de,hl 
1b24 2a 94 f9			ld hl,(cli_ret_sp) 
1b27 23				inc hl 
1b28 23				inc hl 
1b29 22 94 f9			ld (cli_ret_sp),hl 
1b2c 73				ld (hl), e 
1b2d 23				inc hl 
1b2e 72				ld (hl), d 
1b2f d1				pop de 
1b30 e1				pop hl 
1b31				if DEBUG_FORTH_STACK_GUARD 
1b31 cd 0d 62				call check_stacks 
1b34				endif 
1b34 c9				ret 
1b35			 
1b35			; get current ret stack pointer and save to hl  
1b35				 
1b35			FORTH_RSP_TOS: macro 
1b35				call macro_forth_rsp_tos 
1b35				endm 
1b35			 
1b35			macro_forth_rsp_tos: 
1b35				;push de 
1b35 2a 94 f9			ld hl,(cli_ret_sp) 
1b38 cd 70 1b			call loadhlptrtohl 
1b3b				;ld e, (hl) 
1b3b				;inc hl 
1b3b				;ld d, (hl) 
1b3b				;ex de, hl 
1b3b					if DEBUG_FORTH_WORDS 
1b3b			;			DMARK "RST" 
1b3b						CALLMONITOR 
1b3b cd ea 15			call break_point_state  
1b3e				endm  
# End of macro CALLMONITOR
1b3e					endif 
1b3e				;pop de 
1b3e c9				ret 
1b3f			 
1b3f			; pop ret stack pointer 
1b3f				 
1b3f			FORTH_RSP_POP: macro 
1b3f				call macro_forth_rsp_pop 
1b3f				endm 
1b3f			 
1b3f			 
1b3f			macro_forth_rsp_pop: 
1b3f				if DEBUG_FORTH_STACK_GUARD 
1b3f			;		DMARK "RPP" 
1b3f cd 0d 62				call check_stacks 
1b42					FORTH_CHK_RSP_UNDER 
1b42 e5				push hl 
1b43 d5				push de 
1b44 2a 94 f9			ld hl,(cli_ret_sp) 
1b47 11 0e f9			ld de, cli_ret_stack 
1b4a cd e6 0c			call cmp16 
1b4d da 21 63			jp c, fault_rsp_under 
1b50 d1				pop de 
1b51 e1				pop hl 
1b52				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b52				endif 
1b52 e5				push hl 
1b53 2a 94 f9			ld hl,(cli_ret_sp) 
1b56			 
1b56			 
1b56				if FORTH_ENABLE_FREE 
1b56			 
1b56					; get pointer 
1b56			 
1b56					push de 
1b56					push hl 
1b56			 
1b56					ld e, (hl) 
1b56					inc hl 
1b56					ld d, (hl) 
1b56			 
1b56					ex de, hl 
1b56					call free 
1b56			 
1b56					pop hl 
1b56					pop de 
1b56			 
1b56			 
1b56				endif 
1b56			 
1b56			 
1b56 2b				dec hl 
1b57 2b				dec hl 
1b58 22 94 f9			ld (cli_ret_sp), hl 
1b5b				; do stack underflow checks 
1b5b e1				pop hl 
1b5c				if DEBUG_FORTH_STACK_GUARD 
1b5c cd 0d 62				call check_stacks 
1b5f					FORTH_CHK_RSP_UNDER 
1b5f e5				push hl 
1b60 d5				push de 
1b61 2a 94 f9			ld hl,(cli_ret_sp) 
1b64 11 0e f9			ld de, cli_ret_stack 
1b67 cd e6 0c			call cmp16 
1b6a da 21 63			jp c, fault_rsp_under 
1b6d d1				pop de 
1b6e e1				pop hl 
1b6f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b6f				endif 
1b6f c9				ret 
1b70			 
1b70			 
1b70			 
1b70			; routine to load word pointed to by hl into hl 
1b70			 
1b70			loadhlptrtohl: 
1b70			 
1b70 d5				push de 
1b71 5e				ld e, (hl) 
1b72 23				inc hl 
1b73 56				ld d, (hl) 
1b74 eb				ex de, hl 
1b75 d1				pop de 
1b76			 
1b76 c9				ret 
1b77			 
1b77			 
1b77			 
1b77			 
1b77			 
1b77			; push a number held in HL onto the data stack 
1b77			; entry point for pushing a value when already in hl used in function above 
1b77			 
1b77			forth_push_numhl: 
1b77			 
1b77 e5				push hl    ; save value to push 
1b78			 
1b78			if DEBUG_FORTH_PUSH 
1b78				; see if disabled 
1b78			 
1b78			 
1b78 f5				push af 
1b79 3a 94 ef			ld a, (os_view_disable) 
1b7c fe 2a			cp '*' 
1b7e 28 34			jr z, .pskip2 
1b80 e5				push hl 
1b81 e5			push hl 
1b82 cd 94 0a			call clear_display 
1b85 e1			pop hl 
1b86 7c				ld a,h 
1b87 21 a8 f2			ld hl, os_word_scratch 
1b8a cd c9 0f			call hexout 
1b8d e1				pop hl 
1b8e 7d				ld a,l 
1b8f 21 aa f2			ld hl, os_word_scratch+2 
1b92 cd c9 0f			call hexout 
1b95			 
1b95 21 ac f2			ld hl, os_word_scratch+4 
1b98 3e 00			ld a,0 
1b9a 77				ld (hl),a 
1b9b 11 a8 f2			ld de,os_word_scratch 
1b9e 3e 14				ld a, display_row_2 
1ba0 cd a7 0a				call str_at_display 
1ba3 11 1b 51			ld de, .push_num 
1ba6 3e 00			ld a, display_row_1 
1ba8			 
1ba8 cd a7 0a				call str_at_display 
1bab			 
1bab			 
1bab cd b7 0a			call update_display 
1bae cd 42 0a			call delay1s 
1bb1 cd 42 0a			call delay1s 
1bb4			.pskip2:  
1bb4			 
1bb4 f1				pop af 
1bb5			endif	 
1bb5			 
1bb5			 
1bb5				FORTH_DSP_NEXT 
1bb5 cd 06 1b			call macro_forth_dsp_next 
1bb8				endm 
# End of macro FORTH_DSP_NEXT
1bb8			 
1bb8 2a 90 f9			ld hl, (cli_data_sp) 
1bbb			 
1bbb				; save item type 
1bbb 3e 02			ld a,  DS_TYPE_INUM 
1bbd 77				ld (hl), a 
1bbe 23				inc hl 
1bbf			 
1bbf				; get word off stack 
1bbf d1				pop de 
1bc0 7b				ld a,e 
1bc1 77				ld (hl), a 
1bc2 23				inc hl 
1bc3 7a				ld a,d 
1bc4 77				ld (hl), a 
1bc5			 
1bc5			if DEBUG_FORTH_PUSH 
1bc5 2b				dec hl 
1bc6 2b				dec hl 
1bc7 2b				dec hl 
1bc8						DMARK "PH5" 
1bc8 f5				push af  
1bc9 3a dd 1b			ld a, (.dmark)  
1bcc 32 bd fb			ld (debug_mark),a  
1bcf 3a de 1b			ld a, (.dmark+1)  
1bd2 32 be fb			ld (debug_mark+1),a  
1bd5 3a df 1b			ld a, (.dmark+2)  
1bd8 32 bf fb			ld (debug_mark+2),a  
1bdb 18 03			jr .pastdmark  
1bdd ..			.dmark: db "PH5"  
1be0 f1			.pastdmark: pop af  
1be1			endm  
# End of macro DMARK
1be1				CALLMONITOR 
1be1 cd ea 15			call break_point_state  
1be4				endm  
# End of macro CALLMONITOR
1be4			endif	 
1be4			 
1be4 c9				ret 
1be5			 
1be5			 
1be5			; Push a string to stack pointed to by hl 
1be5			 
1be5			forth_push_str: 
1be5			 
1be5			if DEBUG_FORTH_PUSH 
1be5						DMARK "PSQ" 
1be5 f5				push af  
1be6 3a fa 1b			ld a, (.dmark)  
1be9 32 bd fb			ld (debug_mark),a  
1bec 3a fb 1b			ld a, (.dmark+1)  
1bef 32 be fb			ld (debug_mark+1),a  
1bf2 3a fc 1b			ld a, (.dmark+2)  
1bf5 32 bf fb			ld (debug_mark+2),a  
1bf8 18 03			jr .pastdmark  
1bfa ..			.dmark: db "PSQ"  
1bfd f1			.pastdmark: pop af  
1bfe			endm  
# End of macro DMARK
1bfe				CALLMONITOR 
1bfe cd ea 15			call break_point_state  
1c01				endm  
# End of macro CALLMONITOR
1c01			endif	 
1c01			    
1c01 e5				push hl 
1c02 e5				push hl 
1c03			 
1c03			;	ld a, 0   ; find end of string 
1c03 cd 26 11			call strlenz 
1c06			if DEBUG_FORTH_PUSH 
1c06						DMARK "PQ2" 
1c06 f5				push af  
1c07 3a 1b 1c			ld a, (.dmark)  
1c0a 32 bd fb			ld (debug_mark),a  
1c0d 3a 1c 1c			ld a, (.dmark+1)  
1c10 32 be fb			ld (debug_mark+1),a  
1c13 3a 1d 1c			ld a, (.dmark+2)  
1c16 32 bf fb			ld (debug_mark+2),a  
1c19 18 03			jr .pastdmark  
1c1b ..			.dmark: db "PQ2"  
1c1e f1			.pastdmark: pop af  
1c1f			endm  
# End of macro DMARK
1c1f				CALLMONITOR 
1c1f cd ea 15			call break_point_state  
1c22				endm  
# End of macro CALLMONITOR
1c22			endif	 
1c22 eb				ex de, hl 
1c23 e1				pop hl   ; get ptr to start of string 
1c24			if DEBUG_FORTH_PUSH 
1c24						DMARK "PQ3" 
1c24 f5				push af  
1c25 3a 39 1c			ld a, (.dmark)  
1c28 32 bd fb			ld (debug_mark),a  
1c2b 3a 3a 1c			ld a, (.dmark+1)  
1c2e 32 be fb			ld (debug_mark+1),a  
1c31 3a 3b 1c			ld a, (.dmark+2)  
1c34 32 bf fb			ld (debug_mark+2),a  
1c37 18 03			jr .pastdmark  
1c39 ..			.dmark: db "PQ3"  
1c3c f1			.pastdmark: pop af  
1c3d			endm  
# End of macro DMARK
1c3d				CALLMONITOR 
1c3d cd ea 15			call break_point_state  
1c40				endm  
# End of macro CALLMONITOR
1c40			endif	 
1c40 19				add hl,de 
1c41			if DEBUG_FORTH_PUSH 
1c41						DMARK "PQE" 
1c41 f5				push af  
1c42 3a 56 1c			ld a, (.dmark)  
1c45 32 bd fb			ld (debug_mark),a  
1c48 3a 57 1c			ld a, (.dmark+1)  
1c4b 32 be fb			ld (debug_mark+1),a  
1c4e 3a 58 1c			ld a, (.dmark+2)  
1c51 32 bf fb			ld (debug_mark+2),a  
1c54 18 03			jr .pastdmark  
1c56 ..			.dmark: db "PQE"  
1c59 f1			.pastdmark: pop af  
1c5a			endm  
# End of macro DMARK
1c5a				CALLMONITOR 
1c5a cd ea 15			call break_point_state  
1c5d				endm  
# End of macro CALLMONITOR
1c5d			endif	 
1c5d			 
1c5d 2b				dec hl    ; see if there is an optional trailing double quote 
1c5e 7e				ld a,(hl) 
1c5f fe 22			cp '"' 
1c61 20 03			jr nz, .strnoq 
1c63 3e 00			ld a, 0      ; get rid of double quote 
1c65 77				ld (hl), a 
1c66 23			.strnoq: inc hl 
1c67			 
1c67 3e 00			ld a, 0 
1c69 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c6a			 
1c6a 13				inc de ; add one for the type string 
1c6b 13				inc de ; add one for null term??? 
1c6c			 
1c6c				; tos is get string pointer again 
1c6c				; de contains space to allocate 
1c6c				 
1c6c d5				push de 
1c6d			 
1c6d eb				ex de, hl 
1c6e			 
1c6e				;push af 
1c6e			 
1c6e			if DEBUG_FORTH_PUSH 
1c6e						DMARK "PHm" 
1c6e f5				push af  
1c6f 3a 83 1c			ld a, (.dmark)  
1c72 32 bd fb			ld (debug_mark),a  
1c75 3a 84 1c			ld a, (.dmark+1)  
1c78 32 be fb			ld (debug_mark+1),a  
1c7b 3a 85 1c			ld a, (.dmark+2)  
1c7e 32 bf fb			ld (debug_mark+2),a  
1c81 18 03			jr .pastdmark  
1c83 ..			.dmark: db "PHm"  
1c86 f1			.pastdmark: pop af  
1c87			endm  
# End of macro DMARK
1c87				CALLMONITOR 
1c87 cd ea 15			call break_point_state  
1c8a				endm  
# End of macro CALLMONITOR
1c8a			endif	 
1c8a cd 8f 11			call malloc	; on ret hl now contains allocated memory 
1c8d				if DEBUG_FORTH_MALLOC_GUARD 
1c8d cc 73 51				call z,malloc_error 
1c90				endif 
1c90			 
1c90				 
1c90 c1				pop bc    ; get length 
1c91 d1				pop de   ;  get string start    
1c92			 
1c92				; hl has destination from malloc 
1c92			 
1c92 eb				ex de, hl    ; prep for ldir 
1c93			 
1c93 d5				push de   ; save malloc area for DSP later 
1c94				;push hl   ; save malloc area for DSP later 
1c94			 
1c94			if DEBUG_FORTH_PUSH 
1c94						DMARK "PHc" 
1c94 f5				push af  
1c95 3a a9 1c			ld a, (.dmark)  
1c98 32 bd fb			ld (debug_mark),a  
1c9b 3a aa 1c			ld a, (.dmark+1)  
1c9e 32 be fb			ld (debug_mark+1),a  
1ca1 3a ab 1c			ld a, (.dmark+2)  
1ca4 32 bf fb			ld (debug_mark+2),a  
1ca7 18 03			jr .pastdmark  
1ca9 ..			.dmark: db "PHc"  
1cac f1			.pastdmark: pop af  
1cad			endm  
# End of macro DMARK
1cad				CALLMONITOR 
1cad cd ea 15			call break_point_state  
1cb0				endm  
# End of macro CALLMONITOR
1cb0			endif	 
1cb0			 
1cb0			 
1cb0 ed b0			ldir 
1cb2			 
1cb2			 
1cb2				; push malloc to data stack     macro?????  
1cb2			 
1cb2				FORTH_DSP_NEXT 
1cb2 cd 06 1b			call macro_forth_dsp_next 
1cb5				endm 
# End of macro FORTH_DSP_NEXT
1cb5			 
1cb5				; save value and type 
1cb5			 
1cb5 2a 90 f9			ld hl, (cli_data_sp) 
1cb8			 
1cb8				; save item type 
1cb8 3e 01			ld a,  DS_TYPE_STR 
1cba 77				ld (hl), a 
1cbb 23				inc hl 
1cbc			 
1cbc				; get malloc word off stack 
1cbc d1				pop de 
1cbd 73				ld (hl), e 
1cbe 23				inc hl 
1cbf 72				ld (hl), d 
1cc0			 
1cc0			 
1cc0			 
1cc0			if DEBUG_FORTH_PUSH 
1cc0 2a 90 f9			ld hl, (cli_data_sp) 
1cc3						DMARK "PHS" 
1cc3 f5				push af  
1cc4 3a d8 1c			ld a, (.dmark)  
1cc7 32 bd fb			ld (debug_mark),a  
1cca 3a d9 1c			ld a, (.dmark+1)  
1ccd 32 be fb			ld (debug_mark+1),a  
1cd0 3a da 1c			ld a, (.dmark+2)  
1cd3 32 bf fb			ld (debug_mark+2),a  
1cd6 18 03			jr .pastdmark  
1cd8 ..			.dmark: db "PHS"  
1cdb f1			.pastdmark: pop af  
1cdc			endm  
# End of macro DMARK
1cdc				CALLMONITOR 
1cdc cd ea 15			call break_point_state  
1cdf				endm  
# End of macro CALLMONITOR
1cdf			;	ex de,hl 
1cdf			endif	 
1cdf				; in case of spaces, skip the ptr past the copied string 
1cdf				;pop af 
1cdf				;ld (cli_origptr),hl 
1cdf			 
1cdf c9				ret 
1ce0			 
1ce0			 
1ce0			 
1ce0			; TODO ascii push input onto stack given hl to start of input 
1ce0			 
1ce0			; identify type 
1ce0			; if starts with a " then a string 
1ce0			; otherwise it is a number 
1ce0			;  
1ce0			; if a string 
1ce0			;     scan for ending " to get length of string to malloc for + 1 
1ce0			;     malloc 
1ce0			;     put pointer to string on stack first byte flags as string 
1ce0			; 
1ce0			; else a number 
1ce0			;    look for number format identifier 
1ce0			;    $xx hex 
1ce0			;    %xxxxx bin 
1ce0			;    xxxxx decimal 
1ce0			;    convert number to 16bit word.  
1ce0			;    malloc word + 1 with flag to identiy as num 
1ce0			;    put pointer to number on stack 
1ce0			;   
1ce0			;  
1ce0			  
1ce0			forth_apush: 
1ce0				; kernel push 
1ce0			 
1ce0			if DEBUG_FORTH_PUSH 
1ce0						DMARK "PSH" 
1ce0 f5				push af  
1ce1 3a f5 1c			ld a, (.dmark)  
1ce4 32 bd fb			ld (debug_mark),a  
1ce7 3a f6 1c			ld a, (.dmark+1)  
1cea 32 be fb			ld (debug_mark+1),a  
1ced 3a f7 1c			ld a, (.dmark+2)  
1cf0 32 bf fb			ld (debug_mark+2),a  
1cf3 18 03			jr .pastdmark  
1cf5 ..			.dmark: db "PSH"  
1cf8 f1			.pastdmark: pop af  
1cf9			endm  
# End of macro DMARK
1cf9				CALLMONITOR 
1cf9 cd ea 15			call break_point_state  
1cfc				endm  
# End of macro CALLMONITOR
1cfc			endif	 
1cfc				; identify input type 
1cfc			 
1cfc 7e				ld a,(hl) 
1cfd fe 22			cp '"' 
1cff 28 0a			jr z, .fapstr 
1d01 fe 24			cp '$' 
1d03 ca 2b 1d			jp z, .faphex 
1d06 fe 25			cp '%' 
1d08 ca 13 1d			jp z, .fapbin 
1d0b			;	cp 'b' 
1d0b			;	jp z, .fabin 
1d0b				; else decimal 
1d0b			 
1d0b				; TODO do decimal conversion 
1d0b				; decimal is stored as a 16bit word 
1d0b			 
1d0b				; by default everything is a string if type is not detected 
1d0b			.fapstr: ; 
1d0b fe 22			cp '"' 
1d0d 20 01			jr nz, .strnoqu 
1d0f 23				inc hl 
1d10			.strnoqu: 
1d10 c3 e5 1b			jp forth_push_str 
1d13			 
1d13			 
1d13			 
1d13			.fapbin:    ; push a binary string.  
1d13 11 00 00			ld de, 0   ; hold a 16bit value 
1d16			 
1d16 23			.fapbinshift:	inc hl  
1d17 7e				ld a,(hl) 
1d18 fe 00			cp 0     ; done scanning  
1d1a 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d1c			 
1d1c				; left shift de 
1d1c eb				ex de, hl	 
1d1d 29				add hl, hl 
1d1e			 
1d1e				; is 1 
1d1e fe 31			cp '1' 
1d20 20 02			jr nz, .binzero 
1d22 cb 4d			bit 1, l 
1d24			.binzero: 
1d24 eb				ex de, hl	 ; save current de 
1d25 18 ef			jr .fapbinshift 
1d27			 
1d27			.fapbdone: 
1d27 eb				ex de, hl 
1d28 c3 77 1b			jp forth_push_numhl 
1d2b			 
1d2b			 
1d2b			.faphex:   ; hex is always stored as a 16bit word 
1d2b				; skip number prefix 
1d2b 23				inc hl 
1d2c				; turn ascii into number 
1d2c cd 7f 10			call get_word_hl	; ret 16bit word in hl 
1d2f			 
1d2f c3 77 1b			jp forth_push_numhl 
1d32			 
1d32 00				 nop 
1d33			 
1d33			.fabin:   ; TODO bin conversion 
1d33			 
1d33			 
1d33 c9				ret 
1d34			 
1d34			 
1d34			; get either a string ptr or a 16bit word from the data stack 
1d34			 
1d34			FORTH_DSP: macro 
1d34				call macro_forth_dsp 
1d34				endm 
1d34			 
1d34			macro_forth_dsp: 
1d34				; data stack pointer points to current word on tos 
1d34			 
1d34 2a 90 f9			ld hl,(cli_data_sp) 
1d37			 
1d37				if DEBUG_FORTH_PUSH 
1d37						DMARK "DSP" 
1d37 f5				push af  
1d38 3a 4c 1d			ld a, (.dmark)  
1d3b 32 bd fb			ld (debug_mark),a  
1d3e 3a 4d 1d			ld a, (.dmark+1)  
1d41 32 be fb			ld (debug_mark+1),a  
1d44 3a 4e 1d			ld a, (.dmark+2)  
1d47 32 bf fb			ld (debug_mark+2),a  
1d4a 18 03			jr .pastdmark  
1d4c ..			.dmark: db "DSP"  
1d4f f1			.pastdmark: pop af  
1d50			endm  
# End of macro DMARK
1d50			 
1d50 cd a8 51				call display_data_sp 
1d53				;call break_point_state 
1d53				;rst 030h 
1d53				CALLMONITOR 
1d53 cd ea 15			call break_point_state  
1d56				endm  
# End of macro CALLMONITOR
1d56				endif 
1d56			 
1d56 c9				ret 
1d57			 
1d57			; return hl to start of value on stack 
1d57			 
1d57			FORTH_DSP_VALUE: macro 
1d57				call macro_forth_dsp_value 
1d57				endm 
1d57			 
1d57			macro_forth_dsp_value: 
1d57			 
1d57				FORTH_DSP 
1d57 cd 34 1d			call macro_forth_dsp 
1d5a				endm 
# End of macro FORTH_DSP
1d5a			 
1d5a d5				push de 
1d5b			 
1d5b 23				inc hl ; skip type 
1d5c			 
1d5c 5e				ld e, (hl) 
1d5d 23				inc hl 
1d5e 56				ld d, (hl) 
1d5f eb				ex de,hl  
1d60			 
1d60 d1				pop de 
1d61			 
1d61 c9				ret 
1d62			 
1d62			; return hl to start of value to second item on stack 
1d62			 
1d62			FORTH_DSP_VALUEM1: macro 
1d62				call macro_forth_dsp_value_m1 
1d62				endm 
1d62			 
1d62			macro_forth_dsp_value_m1: 
1d62			 
1d62				FORTH_DSP 
1d62 cd 34 1d			call macro_forth_dsp 
1d65				endm 
# End of macro FORTH_DSP
1d65			 
1d65 2b				dec hl 
1d66 2b				dec hl 
1d67			;	dec hl 
1d67			 
1d67 d5				push de 
1d68			 
1d68 5e				ld e, (hl) 
1d69 23				inc hl 
1d6a 56				ld d, (hl) 
1d6b eb				ex de,hl  
1d6c			 
1d6c d1				pop de 
1d6d			 
1d6d c9				ret 
1d6e			 
1d6e				 
1d6e			 
1d6e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d6e			 
1d6e			FORTH_DSP_POP: macro 
1d6e				call macro_forth_dsp_pop 
1d6e				endm 
1d6e			 
1d6e			 
1d6e			; get the tos data type 
1d6e			 
1d6e			FORTH_DSP_TYPE:   macro 
1d6e			 
1d6e				;FORTH_DSP_VALUE 
1d6e				FORTH_DSP 
1d6e				 
1d6e				; hl points to value 
1d6e				; check type 
1d6e			 
1d6e				ld a,(hl) 
1d6e			 
1d6e				endm 
1d6e			 
1d6e			; load the tos value into hl 
1d6e			 
1d6e			 
1d6e			FORTH_DSP_VALUEHL:  macro 
1d6e				call macro_dsp_valuehl 
1d6e				endm 
1d6e			 
1d6e			 
1d6e			 
1d6e			macro_dsp_valuehl: 
1d6e				FORTH_DSP_VALUE 
1d6e cd 57 1d			call macro_forth_dsp_value 
1d71				endm 
# End of macro FORTH_DSP_VALUE
1d71			 
1d71				;FORTH_ERR_TOS_NOTNUM 
1d71			 
1d71				;inc hl   ; skip type id 
1d71			 
1d71			;	push de 
1d71			; 
1d71			;	ld e, (hl) 
1d71			;	inc hl 
1d71			;	ld d, (hl) 
1d71			;	ex de,hl  
1d71			 
1d71			;	pop de 
1d71			 
1d71				if DEBUG_FORTH_PUSH 
1d71						DMARK "DVL" 
1d71 f5				push af  
1d72 3a 86 1d			ld a, (.dmark)  
1d75 32 bd fb			ld (debug_mark),a  
1d78 3a 87 1d			ld a, (.dmark+1)  
1d7b 32 be fb			ld (debug_mark+1),a  
1d7e 3a 88 1d			ld a, (.dmark+2)  
1d81 32 bf fb			ld (debug_mark+2),a  
1d84 18 03			jr .pastdmark  
1d86 ..			.dmark: db "DVL"  
1d89 f1			.pastdmark: pop af  
1d8a			endm  
# End of macro DMARK
1d8a				CALLMONITOR 
1d8a cd ea 15			call break_point_state  
1d8d				endm  
# End of macro CALLMONITOR
1d8d				endif 
1d8d c9				ret 
1d8e			 
1d8e			forth_apushstrhl:      
1d8e				; push of string requires use of cli_origptr 
1d8e				; bodge use 
1d8e			 
1d8e				; get current cli_origptr, save, update with temp pointer  
1d8e ed 5b ac f9		ld de, (cli_origptr) 
1d92 22 ac f9			ld (cli_origptr), hl 
1d95 d5				push de 
1d96 cd e0 1c			call forth_apush 
1d99 d1				pop de 
1d9a ed 53 ac f9		ld (cli_origptr), de 
1d9e c9			        ret	 
1d9f			 
1d9f			 
1d9f			; increase loop stack pointer and save hl to it 
1d9f				 
1d9f			FORTH_LOOP_NEXT: macro 
1d9f				call macro_forth_loop_next 
1d9f				;nop 
1d9f				endm 
1d9f			 
1d9f			macro_forth_loop_next: 
1d9f				if DEBUG_FORTH_STACK_GUARD 
1d9f cd 0d 62				call check_stacks 
1da2				endif 
1da2 e5				push hl 
1da3 d5				push de 
1da4 eb				ex de,hl 
1da5 2a 92 f9			ld hl,(cli_loop_sp) 
1da8 23				inc hl 
1da9 23				inc hl 
1daa					if DEBUG_FORTH_WORDS 
1daa						DMARK "LNX" 
1daa f5				push af  
1dab 3a bf 1d			ld a, (.dmark)  
1dae 32 bd fb			ld (debug_mark),a  
1db1 3a c0 1d			ld a, (.dmark+1)  
1db4 32 be fb			ld (debug_mark+1),a  
1db7 3a c1 1d			ld a, (.dmark+2)  
1dba 32 bf fb			ld (debug_mark+2),a  
1dbd 18 03			jr .pastdmark  
1dbf ..			.dmark: db "LNX"  
1dc2 f1			.pastdmark: pop af  
1dc3			endm  
# End of macro DMARK
1dc3						CALLMONITOR 
1dc3 cd ea 15			call break_point_state  
1dc6				endm  
# End of macro CALLMONITOR
1dc6					endif 
1dc6 22 92 f9			ld (cli_loop_sp),hl 
1dc9 73				ld (hl), e 
1dca 23				inc hl 
1dcb 72				ld (hl), d 
1dcc d1				pop de    ; been reversed so save a swap on restore 
1dcd e1				pop hl 
1dce				if DEBUG_FORTH_STACK_GUARD 
1dce cd 0d 62				call check_stacks 
1dd1				endif 
1dd1 c9				ret 
1dd2			 
1dd2			; get current ret stack pointer and save to hl  
1dd2				 
1dd2			FORTH_LOOP_TOS: macro 
1dd2				call macro_forth_loop_tos 
1dd2				endm 
1dd2			 
1dd2			macro_forth_loop_tos: 
1dd2 d5				push de 
1dd3 2a 92 f9			ld hl,(cli_loop_sp) 
1dd6 5e				ld e, (hl) 
1dd7 23				inc hl 
1dd8 56				ld d, (hl) 
1dd9 eb				ex de, hl 
1dda d1				pop de 
1ddb c9				ret 
1ddc			 
1ddc			; pop loop stack pointer 
1ddc				 
1ddc			FORTH_LOOP_POP: macro 
1ddc				call macro_forth_loop_pop 
1ddc				endm 
1ddc			 
1ddc			 
1ddc			macro_forth_loop_pop: 
1ddc				if DEBUG_FORTH_STACK_GUARD 
1ddc					DMARK "LPP" 
1ddc f5				push af  
1ddd 3a f1 1d			ld a, (.dmark)  
1de0 32 bd fb			ld (debug_mark),a  
1de3 3a f2 1d			ld a, (.dmark+1)  
1de6 32 be fb			ld (debug_mark+1),a  
1de9 3a f3 1d			ld a, (.dmark+2)  
1dec 32 bf fb			ld (debug_mark+2),a  
1def 18 03			jr .pastdmark  
1df1 ..			.dmark: db "LPP"  
1df4 f1			.pastdmark: pop af  
1df5			endm  
# End of macro DMARK
1df5 cd 0d 62				call check_stacks 
1df8					FORTH_CHK_LOOP_UNDER 
1df8 e5				push hl 
1df9 d5				push de 
1dfa 2a 92 f9			ld hl,(cli_loop_sp) 
1dfd 11 0c f7			ld de, cli_loop_stack 
1e00 cd e6 0c			call cmp16 
1e03 da 27 63			jp c, fault_loop_under 
1e06 d1				pop de 
1e07 e1				pop hl 
1e08				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e08				endif 
1e08 e5				push hl 
1e09 2a 92 f9			ld hl,(cli_loop_sp) 
1e0c 2b				dec hl 
1e0d 2b				dec hl 
1e0e 22 92 f9			ld (cli_loop_sp), hl 
1e11				; TODO do stack underflow checks 
1e11 e1				pop hl 
1e12				if DEBUG_FORTH_STACK_GUARD 
1e12 cd 0d 62				call check_stacks 
1e15					FORTH_CHK_LOOP_UNDER 
1e15 e5				push hl 
1e16 d5				push de 
1e17 2a 92 f9			ld hl,(cli_loop_sp) 
1e1a 11 0c f7			ld de, cli_loop_stack 
1e1d cd e6 0c			call cmp16 
1e20 da 27 63			jp c, fault_loop_under 
1e23 d1				pop de 
1e24 e1				pop hl 
1e25				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e25				endif 
1e25 c9				ret 
1e26			 
1e26			macro_forth_dsp_pop: 
1e26			 
1e26 e5				push hl 
1e27			 
1e27				; release malloc data 
1e27			 
1e27				if DEBUG_FORTH_STACK_GUARD 
1e27 cd 0d 62				call check_stacks 
1e2a					FORTH_CHK_DSP_UNDER 
1e2a e5				push hl 
1e2b d5				push de 
1e2c 2a 90 f9			ld hl,(cli_data_sp) 
1e2f 11 0a f5			ld de, cli_data_stack 
1e32 cd e6 0c			call cmp16 
1e35 da 1b 63			jp c, fault_dsp_under 
1e38 d1				pop de 
1e39 e1				pop hl 
1e3a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e3a				endif 
1e3a				;ld hl,(cli_data_sp) 
1e3a			if DEBUG_FORTH_DOT 
1e3a				DMARK "DPP" 
1e3a				CALLMONITOR 
1e3a			endif	 
1e3a			 
1e3a			 
1e3a			if FORTH_ENABLE_DSPPOPFREE 
1e3a			 
1e3a				FORTH_DSP 
1e3a cd 34 1d			call macro_forth_dsp 
1e3d				endm 
# End of macro FORTH_DSP
1e3d			 
1e3d 7e				ld a, (hl) 
1e3e fe 01			cp DS_TYPE_STR 
1e40 20 07			jr nz, .skippopfree 
1e42			 
1e42				FORTH_DSP_VALUEHL 
1e42 cd 6e 1d			call macro_dsp_valuehl 
1e45				endm 
# End of macro FORTH_DSP_VALUEHL
1e45 00				nop 
1e46			if DEBUG_FORTH_DOT 
1e46				DMARK "DPf" 
1e46				CALLMONITOR 
1e46			endif	 
1e46 cd 59 12			call free 
1e49			.skippopfree: 
1e49				 
1e49			 
1e49			endif 
1e49			 
1e49			if DEBUG_FORTH_DOT_KEY 
1e49				DMARK "DP2" 
1e49				CALLMONITOR 
1e49			endif	 
1e49			 
1e49				; move pointer down 
1e49			 
1e49 2a 90 f9			ld hl,(cli_data_sp) 
1e4c 2b				dec hl 
1e4d 2b				dec hl 
1e4e			; PARSEV5 
1e4e 2b				dec hl 
1e4f 22 90 f9			ld (cli_data_sp), hl 
1e52			 
1e52				if DEBUG_FORTH_STACK_GUARD 
1e52 cd 0d 62				call check_stacks 
1e55					FORTH_CHK_DSP_UNDER 
1e55 e5				push hl 
1e56 d5				push de 
1e57 2a 90 f9			ld hl,(cli_data_sp) 
1e5a 11 0a f5			ld de, cli_data_stack 
1e5d cd e6 0c			call cmp16 
1e60 da 1b 63			jp c, fault_dsp_under 
1e63 d1				pop de 
1e64 e1				pop hl 
1e65				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e65				endif 
1e65			 
1e65 e1				pop hl 
1e66			 
1e66 c9				ret 
1e67			 
1e67			getwordathl: 
1e67				; hl points to an address 
1e67				; load hl with the word at that address 
1e67			 
1e67 d5				push de 
1e68			 
1e68 5e				ld e, (hl) 
1e69 23				inc hl 
1e6a 56				ld d, (hl) 
1e6b eb				ex de, hl 
1e6c			 
1e6c d1				pop de 
1e6d c9				ret 
1e6e			 
1e6e			 
1e6e			 
1e6e			 
1e6e			 
1e6e			; eof 
1e6e			 
# End of file forth_stackopsv5.asm
1e6e			endif 
1e6e			 
1e6e			user_word_eol:  
1e6e				; hl contains the pointer to where to create a linked list item from the end 
1e6e				; of the user dict to continue on at the system word dict 
1e6e				 
1e6e				; poke the stub of the word list linked list to repoint to rom words 
1e6e			 
1e6e				; stub format 
1e6e				; db   word id 
1e6e				; dw    link to next word 
1e6e			        ; db char length of token 
1e6e				; db string + 0 term 
1e6e				; db exec code....  
1e6e			 
1e6e 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1e70 77				ld (hl), a		; word id 
1e71 23				inc hl 
1e72			 
1e72 11 38 20			ld de, sysdict 
1e75 73				ld (hl), e		; next word link ie system dict 
1e76 23				inc hl 
1e77 72				ld (hl), d		; next word link ie system dict 
1e78 23				inc hl	 
1e79			 
1e79			;	ld (hl), sysdict		; next word link ie system dict 
1e79			;	inc hl 
1e79			;	inc hl 
1e79			 
1e79			;	inc hl 
1e79			;	inc hl 
1e79			 
1e79 3e 02			ld a, 2			; word length is 0 
1e7b 77				ld (hl), a	 
1e7c 23				inc hl 
1e7d			 
1e7d 3e 7e			ld a, '~'			; word length is 0 
1e7f 77				ld (hl), a	 
1e80 23				inc hl 
1e81 3e 00			ld a, 0			; save empty word 
1e83 77				ld (hl), a 
1e84			 
1e84 c9				ret 
1e85			 
1e85				 
1e85			 
1e85			forthexec_cleanup: 
1e85				FORTH_RSP_POP 
1e85 cd 3f 1b			call macro_forth_rsp_pop 
1e88				endm 
# End of macro FORTH_RSP_POP
1e88 c9				ret 
1e89			 
1e89			forth_call_hl: 
1e89				; taking hl 
1e89 e5				push hl 
1e8a c9				ret 
1e8b			 
1e8b			; this is called to reset Forth system but keep existing uwords etc 
1e8b			 
1e8b			forth_warmstart: 
1e8b				; setup stack over/under flow checks 
1e8b				if DEBUG_FORTH_STACK_GUARD 
1e8b cd f3 61				call chk_stk_init 
1e8e				endif 
1e8e			 
1e8e				; init stack pointers  - * these stacks go upwards *  
1e8e 21 0e f9			ld hl, cli_ret_stack 
1e91 22 94 f9			ld (cli_ret_sp), hl	 
1e94				; set bottom of stack 
1e94 3e 00			ld a,0 
1e96 77				ld (hl),a 
1e97 23				inc hl 
1e98 77				ld (hl),a 
1e99			 
1e99 21 0a f5			ld hl, cli_data_stack 
1e9c 22 90 f9			ld (cli_data_sp), hl	 
1e9f				; set bottom of stack 
1e9f 3e 00			ld a,0 
1ea1 77				ld (hl),a 
1ea2 23				inc hl 
1ea3 77				ld (hl),a 
1ea4			 
1ea4 21 0c f7			ld hl, cli_loop_stack 
1ea7 22 92 f9			ld (cli_loop_sp), hl	 
1eaa				; set bottom of stack 
1eaa 3e 00			ld a,0 
1eac 77				ld (hl),a 
1ead 23				inc hl 
1eae 77				ld (hl),a 
1eaf			 
1eaf				; init extent of current open file 
1eaf			 
1eaf 3e 00			ld a, 0 
1eb1 32 df f9			ld (store_openext), a 
1eb4			 
1eb4 c9				ret 
1eb5			 
1eb5			 
1eb5			; Cold Start - this is called to setup the whole Forth system 
1eb5			 
1eb5			forth_init: 
1eb5			 
1eb5				; setup stack over/under flow checks 
1eb5			 
1eb5			;	if DEBUG_FORTH_STACK_GUARD 
1eb5			;		call chk_stk_init 
1eb5			;	endif 
1eb5			 
1eb5				; enable auto display updates (slow.....) 
1eb5			 
1eb5 3e 01			ld a, 1 
1eb7 32 aa f9			ld (cli_autodisplay), a 
1eba			 
1eba			 
1eba			 
1eba				; show start up screen 
1eba			 
1eba cd 94 0a			call clear_display 
1ebd			 
1ebd 3e 00			ld a,0 
1ebf 32 cc f9			ld (f_cursor_ptr), a 
1ec2			 
1ec2				; set start of word list in start of ram - for use when creating user words 
1ec2			 
1ec2 21 00 80			ld hl, baseram 
1ec5 22 a0 f2			ld (os_last_new_uword), hl 
1ec8 cd 6e 1e			call user_word_eol 
1ecb				 
1ecb			;		call display_data_sp 
1ecb			;		call next_page_prompt 
1ecb			 
1ecb			 
1ecb			 
1ecb			 
1ecb c9				ret 
1ecc			 
1ecc .. 00		.bootforth: db " Forth Kernel Init ",0 
1ee0			 
1ee0			; TODO push to stack 
1ee0			 
1ee0			;  
1ee0			 
1ee0			if FORTH_PARSEV2 
1ee0			 
1ee0			 
1ee0				include "forth_parserv2.asm" 
1ee0			 
1ee0			endif 
1ee0			 
1ee0			 
1ee0			; parse cli version 1 
1ee0			 
1ee0			if FORTH_PARSEV1 
1ee0			 
1ee0			 
1ee0			 
1ee0			      include "forth_parserv1.asm" 
1ee0			endif 
1ee0				 
1ee0			if FORTH_PARSEV3 
1ee0			 
1ee0			 
1ee0			 
1ee0			      include "forth_parserv3.asm" 
1ee0				include "forth_wordsv3.asm" 
1ee0			endif 
1ee0			 
1ee0			if FORTH_PARSEV4 
1ee0			 
1ee0			 
1ee0			 
1ee0			      include "forth_parserv4.asm" 
1ee0				include "forth_wordsv4.asm" 
1ee0			endif 
1ee0			 
1ee0			if FORTH_PARSEV5 
1ee0			 
1ee0			 
1ee0			 
1ee0			      include "forth_parserv5.asm" 
1ee0			 
1ee0			 
1ee0			; A better parser without using malloc and string copies all over the place.  
1ee0			; Exec in situ should be faster 
1ee0			 
1ee0			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1ee0			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1ee0			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1ee0			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1ee0			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1ee0			WORD_SYS_END: equ 0   ; Opcode for all user words 
1ee0			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1ee0			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1ee0			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1ee0			 
1ee0			; Core word preamble macro 
1ee0			 
1ee0			CWHEAD:   macro nxtword opcode lit len opflags 
1ee0				db WORD_SYS_CORE+opcode             
1ee0				; internal op code number 
1ee0				dw nxtword            
1ee0				; link to next dict word block 
1ee0				db len + 1 
1ee0				; literal length of dict word inc zero term 
1ee0				db lit,0              
1ee0				; literal dict word 
1ee0			        ; TODO db opflags        
1ee0				endm 
1ee0			 
1ee0			 
1ee0			NEXTW: macro  
1ee0				jp macro_next 
1ee0				endm 
1ee0			 
1ee0			macro_next: 
1ee0			if DEBUG_FORTH_PARSE_KEY 
1ee0				DMARK "NXT" 
1ee0				CALLMONITOR 
1ee0			endif	 
1ee0			;	inc hl  ; skip token null term  
1ee0 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ee4 ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ee8 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1eeb			if DEBUG_FORTH_PARSE_KEY 
1eeb				DMARK "}AA" 
1eeb				CALLMONITOR 
1eeb			endif	 
1eeb c3 ee 1f			jp execnext 
1eee				;jp exec1 
1eee			       
1eee			 
1eee			 
1eee			; Another go at the parser to compile  
1eee			 
1eee			 
1eee			; TODO rework parser to change all of the string words to byte tokens 
1eee			; TODO do a search for  
1eee			 
1eee			; TODO first run normal parser to zero term sections 
1eee			; TODO for each word do a token look up to get the op code 
1eee			; TODO need some means to flag to the exec that this is a byte code form    
1eee			 
1eee			 
1eee			forthcompile: 
1eee			 
1eee			; 
1eee			; line parse: 
1eee			;       parse raw input buffer 
1eee			;       tokenise the words 
1eee			;       malloc new copy (for looping etc) 
1eee			;       copy to malloc + current pc in line to start of string and add line term 
1eee			;       save on new rsp 
1eee			; 
1eee			 
1eee			; hl to point to the line to tokenise 
1eee			 
1eee			;	push hl 
1eee 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1ef1			 
1ef1			;	ld a,0		; string term on input 
1ef1			;	call strlent 
1ef1			 
1ef1			;	ld (os_tok_len), hl	 ; save string length 
1ef1			 
1ef1			;if DEBUG_FORTH_TOK 
1ef1			;	ex de,hl		 
1ef1			;endif 
1ef1			 
1ef1			;	pop hl 		; get back string pointer 
1ef1			 
1ef1			if DEBUG_FORTH_TOK 
1ef1						DMARK "TOc" 
1ef1				CALLMONITOR 
1ef1			endif 
1ef1 7e			.cptoken2:    ld a,(hl) 
1ef2 23				inc hl 
1ef3 fe 7f			cp FORTH_END_BUFFER 
1ef5 28 29			jr z, .cptokendone2 
1ef7 fe 00			cp 0 
1ef9 28 25			jr z, .cptokendone2 
1efb fe 22			cp '"' 
1efd 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1eff fe 20			cp ' ' 
1f01 20 ee			jr nz,  .cptoken2 
1f03			 
1f03			; TODO consume comments held between ( and ) 
1f03			 
1f03				; we have a space so change to zero term for dict match later 
1f03 2b				dec hl 
1f04 3e 00			ld a,0 
1f06 77				ld (hl), a 
1f07 23				inc hl 
1f08 18 e7			jr .cptoken2 
1f0a				 
1f0a			 
1f0a			.cptokenstr2: 
1f0a				; skip all white space until either eol (because forgot to term) or end double quote 
1f0a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f0a				;inc hl ; skip current double quote 
1f0a 7e				ld a,(hl) 
1f0b 23				inc hl 
1f0c fe 22			cp '"' 
1f0e 28 e1			jr z, .cptoken2 
1f10 fe 7f			cp FORTH_END_BUFFER 
1f12 28 0c			jr z, .cptokendone2 
1f14 fe 00			cp 0 
1f16 28 08			jr z, .cptokendone2 
1f18 fe 20			cp ' ' 
1f1a 28 02			jr z, .cptmp2 
1f1c 18 ec			jr .cptokenstr2 
1f1e			 
1f1e			.cptmp2:	; we have a space so change to zero term for dict match later 
1f1e				;dec hl 
1f1e				;ld a,"-"	; TODO remove this when working 
1f1e				;ld (hl), a 
1f1e				;inc hl 
1f1e 18 ea			jr .cptokenstr2 
1f20			 
1f20			.cptokendone2: 
1f20				;inc hl 
1f20 3e 7f			ld a, FORTH_END_BUFFER 
1f22 77				ld (hl),a 
1f23 23				inc hl 
1f24 3e 21			ld a, '!' 
1f26 77				ld (hl),a 
1f27			 
1f27 2a a4 f2			ld hl,(os_tok_ptr) 
1f2a			         
1f2a			if DEBUG_FORTH_TOK 
1f2a						DMARK "Tc1" 
1f2a				CALLMONITOR 
1f2a			endif 
1f2a			 
1f2a				; push exec string to top of return stack 
1f2a				FORTH_RSP_NEXT 
1f2a cd 1e 1b			call macro_forth_rsp_next 
1f2d				endm 
# End of macro FORTH_RSP_NEXT
1f2d c9				ret 
1f2e			 
1f2e			; Another go at the parser need to simplify the process 
1f2e			 
1f2e			forthparse: 
1f2e			 
1f2e			; 
1f2e			; line parse: 
1f2e			;       parse raw input buffer 
1f2e			;       tokenise the words 
1f2e			;       malloc new copy (for looping etc) 
1f2e			;       copy to malloc + current pc in line to start of string and add line term 
1f2e			;       save on new rsp 
1f2e			; 
1f2e			 
1f2e			; hl to point to the line to tokenise 
1f2e			 
1f2e			;	push hl 
1f2e 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1f31			 
1f31			;	ld a,0		; string term on input 
1f31			;	call strlent 
1f31			 
1f31			;	ld (os_tok_len), hl	 ; save string length 
1f31			 
1f31			;if DEBUG_FORTH_TOK 
1f31			;	ex de,hl		 
1f31			;endif 
1f31			 
1f31			;	pop hl 		; get back string pointer 
1f31			 
1f31			if DEBUG_FORTH_TOK 
1f31						DMARK "TOK" 
1f31				CALLMONITOR 
1f31			endif 
1f31 7e			.ptoken2:    ld a,(hl) 
1f32 23				inc hl 
1f33 fe 7f			cp FORTH_END_BUFFER 
1f35 28 29			jr z, .ptokendone2 
1f37 fe 00			cp 0 
1f39 28 25			jr z, .ptokendone2 
1f3b fe 22			cp '"' 
1f3d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f3f fe 20			cp ' ' 
1f41 20 ee			jr nz,  .ptoken2 
1f43			 
1f43			; TODO consume comments held between ( and ) 
1f43			 
1f43				; we have a space so change to zero term for dict match later 
1f43 2b				dec hl 
1f44 3e 00			ld a,0 
1f46 77				ld (hl), a 
1f47 23				inc hl 
1f48 18 e7			jr .ptoken2 
1f4a				 
1f4a			 
1f4a			.ptokenstr2: 
1f4a				; skip all white space until either eol (because forgot to term) or end double quote 
1f4a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f4a				;inc hl ; skip current double quote 
1f4a 7e				ld a,(hl) 
1f4b 23				inc hl 
1f4c fe 22			cp '"' 
1f4e 28 e1			jr z, .ptoken2 
1f50 fe 7f			cp FORTH_END_BUFFER 
1f52 28 0c			jr z, .ptokendone2 
1f54 fe 00			cp 0 
1f56 28 08			jr z, .ptokendone2 
1f58 fe 20			cp ' ' 
1f5a 28 02			jr z, .ptmp2 
1f5c 18 ec			jr .ptokenstr2 
1f5e			 
1f5e			.ptmp2:	; we have a space so change to zero term for dict match later 
1f5e				;dec hl 
1f5e				;ld a,"-"	; TODO remove this when working 
1f5e				;ld (hl), a 
1f5e				;inc hl 
1f5e 18 ea			jr .ptokenstr2 
1f60			 
1f60			.ptokendone2: 
1f60				;inc hl 
1f60 3e 7f			ld a, FORTH_END_BUFFER 
1f62 77				ld (hl),a 
1f63 23				inc hl 
1f64 3e 21			ld a, '!' 
1f66 77				ld (hl),a 
1f67			 
1f67 2a a4 f2			ld hl,(os_tok_ptr) 
1f6a			         
1f6a			if DEBUG_FORTH_TOK 
1f6a						DMARK "TK1" 
1f6a				CALLMONITOR 
1f6a			endif 
1f6a			 
1f6a				; push exec string to top of return stack 
1f6a				FORTH_RSP_NEXT 
1f6a cd 1e 1b			call macro_forth_rsp_next 
1f6d				endm 
# End of macro FORTH_RSP_NEXT
1f6d c9				ret 
1f6e			 
1f6e			; 
1f6e			;	; malloc size + buffer pointer + if is loop flag 
1f6e			;	ld hl,(os_tok_len) 		 ; get string length 
1f6e			; 
1f6e			;	ld a,l 
1f6e			; 
1f6e			;	cp 0			; we dont want to use a null string 
1f6e			;	ret z 
1f6e			; 
1f6e			;;	add 3    ; prefix malloc with buffer for current word ptr 
1f6e			; 
1f6e			;	add 5     ; TODO when certain not over writing memory remove 
1f6e			; 
1f6e			;		 
1f6e			; 
1f6e			;if DEBUG_FORTH_TOK 
1f6e			;			DMARK "TKE" 
1f6e			;	CALLMONITOR 
1f6e			;endif 
1f6e			; 
1f6e			;	ld l,a 
1f6e			;	ld h,0 
1f6e			;;	push hl   ; save required space for the copy later 
1f6e			;	call malloc 
1f6e			;if DEBUG_FORTH_TOK 
1f6e			;			DMARK "TKM" 
1f6e			;	CALLMONITOR 
1f6e			;endif 
1f6e			;	if DEBUG_FORTH_MALLOC_GUARD 
1f6e			;		push af 
1f6e			;		call ishlzero 
1f6e			;;		ld a, l 
1f6e			;;		add h 
1f6e			;;		cp 0 
1f6e			;		pop af 
1f6e			;		 
1f6e			;		call z,malloc_error 
1f6e			;	endif 
1f6e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1f6e			; 
1f6e			; 
1f6e			;if DEBUG_FORTH_TOK 
1f6e			;			DMARK "TKR" 
1f6e			;	CALLMONITOR 
1f6e			;endif 
1f6e			; 
1f6e			;	FORTH_RSP_NEXT 
1f6e			; 
1f6e			;	;inc hl	 ; go past current buffer pointer 
1f6e			;	;inc hl 
1f6e			;	;inc hl   ; and past if loop flag 
1f6e			;		; TODO Need to set flag  
1f6e			; 
1f6e			;	 
1f6e			;	 
1f6e			;	ex de,hl	; malloc is dest 
1f6e			;	ld hl, (os_tok_len) 
1f6e			;;	pop bc 
1f6e			;	ld c, l                
1f6e			;	ld b,0 
1f6e			;	ld hl, (os_tok_ptr) 
1f6e			; 
1f6e			;if DEBUG_FORTH_TOK 
1f6e			;			DMARK "TKT" 
1f6e			;	CALLMONITOR 
1f6e			;endif 
1f6e			; 
1f6e			;	; do str cpy 
1f6e			; 
1f6e			;	ldir      ; copy byte in hl to de 
1f6e			; 
1f6e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1f6e			; 
1f6e			;if DEBUG_FORTH_TOK 
1f6e			; 
1f6e			;			DMARK "TKY" 
1f6e			;	CALLMONITOR 
1f6e			;endif 
1f6e			;	;ld a,0 
1f6e			;	;ld a,FORTH_END_BUFFER 
1f6e			;	ex de, hl 
1f6e			;	;dec hl			 ; go back over the space delim at the end of word 
1f6e			;	;ld (hl),a 
1f6e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1f6e			;	ld a,FORTH_END_BUFFER 
1f6e			;	ld (hl),a 
1f6e			;	inc hl 
1f6e			;	ld a,FORTH_END_BUFFER 
1f6e			;	ld (hl),a 
1f6e			; 
1f6e			;	; init the malloc area data 
1f6e			;	; set pc for in current area 
1f6e			;	;ld hl, (os_tok_malloc) 
1f6e			;	;inc hl 
1f6e			;	;inc hl 
1f6e			;	;inc hl 
1f6e			;	;ex de,hl 
1f6e			;	;ld hl, (os_tok_malloc) 
1f6e			;	;ld (hl),e 
1f6e			;	;inc hl 
1f6e			;	;ld (hl),d 
1f6e			; 
1f6e			; 
1f6e			;	ld hl,(os_tok_malloc) 
1f6e			;if DEBUG_FORTH_PARSE_KEY 
1f6e			;			DMARK "TKU" 
1f6e			;	CALLMONITOR 
1f6e			;endif 
1f6e			; 
1f6e			;	ret 
1f6e			 
1f6e			forthexec: 
1f6e			 
1f6e			; line exec: 
1f6e			; forth parser 
1f6e			 
1f6e			; 
1f6e			;       get current exec line on rsp 
1f6e			 
1f6e				FORTH_RSP_TOS 
1f6e cd 35 1b			call macro_forth_rsp_tos 
1f71				endm 
# End of macro FORTH_RSP_TOS
1f71			 
1f71			;       restore current pc - hl points to malloc of data 
1f71			 
1f71				;ld e, (hl) 
1f71				;inc hl 
1f71				;ld d, (hl) 
1f71				;ex de,hl 
1f71			 
1f71			 
1f71			exec1: 
1f71 22 a4 f2			ld (os_tok_ptr), hl 
1f74			 
1f74				; copy our PC to working vars  
1f74 22 ae f9			ld (cli_ptr), hl 
1f77 22 ac f9			ld (cli_origptr), hl 
1f7a			 
1f7a 7e				ld a,(hl) 
1f7b fe 7f			cp FORTH_END_BUFFER 
1f7d c8				ret z 
1f7e			 
1f7e				; skip any nulls 
1f7e			 
1f7e fe 00			cp 0 
1f80 20 03			jr nz, .execword 
1f82 23				inc hl 
1f83 18 ec			jr exec1 
1f85			 
1f85			 
1f85			.execword: 
1f85			 
1f85			 
1f85			 
1f85			if DEBUG_FORTH_PARSE_KEY 
1f85						DMARK "KYQ" 
1f85				CALLMONITOR 
1f85			endif 
1f85			;       while at start of word: 
1f85			; get start of dict (in user area first) 
1f85			 
1f85 21 00 80		ld hl, baseram 
1f88			;ld hl, sysdict 
1f88 22 b0 f9		ld (cli_nextword),hl 
1f8b			;           match word at pc 
1f8b			;           exec word 
1f8b			;           or push to dsp 
1f8b			;           forward to next token 
1f8b			;           if line term pop rsp and exit 
1f8b			;        
1f8b			 
1f8b			if DEBUG_FORTH_PARSE_KEY 
1f8b						DMARK "KYq" 
1f8b				CALLMONITOR 
1f8b			endif 
1f8b			 
1f8b			; 
1f8b			; word comp 
1f8b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1f8b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1f8b			;    move to start of word  
1f8b			;    compare word to cli_token 
1f8b			 
1f8b			.execpnword:	; HL at start of a word in the dictionary to check 
1f8b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1f8b			;	ld (cli_ptr), hl 
1f8b			 
1f8b 2a b0 f9			ld hl,(cli_nextword) 
1f8e			 
1f8e cd 31 20			call forth_tok_next 
1f91			; tok next start here 
1f91			;	; TODO skip compiled symbol for now 
1f91			;	inc hl 
1f91			; 
1f91			;	; save pointer to next word 
1f91			; 
1f91			;	; hl now points to the address of the next word pointer  
1f91			;	ld e, (hl) 
1f91			;	inc hl 
1f91			;	ld d, (hl) 
1f91			;	inc l 
1f91			; 
1f91			;	ex de,hl 
1f91			;if DEBUG_FORTH_PARSE_NEXTWORD 
1f91			;	push bc 
1f91			;	ld bc, (cli_nextword) 
1f91			;			DMARK "NXW" 
1f91			;	CALLMONITOR 
1f91			;	pop bc 
1f91			;endif 
1f91			; tok next end here 
1f91 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
1f94 eb				ex de, hl 
1f95			 
1f95			 
1f95				; save the pointer of the current token - 1 to check against 
1f95				 
1f95 22 b4 f9			ld (cli_token), hl   
1f98				; TODO maybe remove below save if no debug 
1f98				; save token string ptr for any debug later 
1f98 23				inc hl  
1f99 22 b6 f9			ld (cli_origtoken), hl 
1f9c 2b				dec hl 
1f9d				; save pointer to the start of the next dictionay word 
1f9d 7e				ld a,(hl)   ; get string length 
1f9e 47				ld b,a 
1f9f			.execpnwordinc:  
1f9f 23				inc hl 
1fa0 10 fd			djnz .execpnwordinc 
1fa2 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
1fa5			 
1fa5				; now check the word token against the string being parsed 
1fa5			 
1fa5 2a b4 f9			ld hl,(cli_token) 
1fa8 23				inc hl     ; skip string length (use zero term instead to end) 
1fa9 22 b4 f9			ld (cli_token), hl 
1fac			 
1fac			if DEBUG_FORTH_PARSE_KEY 
1fac						DMARK "KY2" 
1fac			endif 
1fac			if DEBUG_FORTH_PARSE_EXEC 
1fac				; see if disabled 
1fac			 
1fac				ld a, (os_view_disable) 
1fac				cp '*' 
1fac				jr z, .skip 
1fac			 
1fac				push hl 
1fac				push hl 
1fac				call clear_display 
1fac				ld de, .compword 
1fac				ld a, display_row_1 
1fac				call str_at_display 
1fac				pop de 
1fac				ld a, display_row_2 
1fac				call str_at_display 
1fac				ld hl,(cli_ptr) 
1fac				ld a,(hl) 
1fac			        ld hl, os_word_scratch 
1fac				ld (hl),a 
1fac				ld a,0 
1fac				inc hl 
1fac				ld (hl),a 	 
1fac				ld de, os_word_scratch 
1fac				ld a, display_row_2+10 
1fac				call str_at_display 
1fac				call update_display 
1fac				ld a, 100 
1fac				call aDelayInMS 
1fac				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fac				call delay250ms 
1fac				endif 
1fac				pop hl 
1fac			.skip:  
1fac			endif	 
1fac			.execpnchar:    ; compare char between token and string to parse 
1fac			 
1fac			if DEBUG_FORTH_PARSE_KEY 
1fac						DMARK "Ky3" 
1fac			endif 
1fac			if DEBUG_FORTH_PARSE_EXEC 
1fac				; see if disabled 
1fac			 
1fac				ld a, (os_view_disable) 
1fac				cp '*' 
1fac				jr z, .skip2 
1fac			 
1fac			;	call clear_display 
1fac			ld hl,(cli_token) 
1fac			ld a,(hl) 
1fac			ld (os_word_scratch),a 
1fac				ld hl,(cli_ptr) 
1fac			ld a,(hl) 
1fac				ld (os_word_scratch+1),a 
1fac				ld a,0 
1fac				ld (os_word_scratch+2),a 
1fac				ld de,os_word_scratch 
1fac				ld a,display_row_4 
1fac				call str_at_display 
1fac				call update_display 
1fac			.skip2:  
1fac			endif 
1fac 2a b4 f9			ld hl,(cli_token) 
1faf 7e				ld a, (hl)	 ; char in word token 
1fb0 23				inc hl 		; move to next char 
1fb1 22 b4 f9			ld (cli_token), hl ; and save it 
1fb4 47				ld b,a 
1fb5			 
1fb5 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
1fb8 7e				ld a,(hl) 
1fb9 23				inc hl 
1fba 22 ae f9			ld (cli_ptr), hl		; move to next char 
1fbd cd 1d 11			call toUpper 		; make sure the input string matches case 
1fc0			 
1fc0			if DEBUG_FORTH_PARSE 
1fc0			endif 
1fc0			 
1fc0				; input stream end of token is a space so get rid of it 
1fc0			 
1fc0			;	cp ' ' 
1fc0			;	jr nz, .pnskipspace 
1fc0			; 
1fc0			;	ld a, 0		; make same term as word token term 
1fc0			; 
1fc0			;.pnskipspace: 
1fc0			 
1fc0			if DEBUG_FORTH_PARSE_KEY 
1fc0						DMARK "KY7" 
1fc0			endif 
1fc0 b8				cp b 
1fc1 c2 d7 1f			jp nz, .execpnskipword	 ; no match so move to next word 
1fc4				 
1fc4			;    if same 
1fc4			;       scan for string terms 0 for token and 32 for input 
1fc4			 
1fc4				 
1fc4			if DEBUG_FORTH_PARSE_KEY 
1fc4						DMARK "KY8" 
1fc4			endif 
1fc4			 
1fc4 80				add b			 
1fc5 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1fc7							; TODO need to make sure last word in zero term string is accounted for 
1fc7 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1fc9			 
1fc9			 
1fc9				; at end of both strings so both are exact match 
1fc9			 
1fc9			;       skip ptr for next word 
1fc9			 
1fc9 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
1fcc 23				inc hl			 ; at next char 
1fcd 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
1fd0 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1fd3				 
1fd3				 
1fd3			if DEBUG_FORTH_PARSE_KEY 
1fd3						DMARK "KY3" 
1fd3			endif 
1fd3			 
1fd3			 
1fd3			 
1fd3			;       exec code block 
1fd3			if DEBUG_FORTH_JP 
1fd3				call clear_display 
1fd3				call update_display 
1fd3				call delay1s 
1fd3				ld hl, (cli_execword)     ; save for next check if no match on this word 
1fd3				ld a,h 
1fd3				ld hl, os_word_scratch 
1fd3				call hexout 
1fd3				ld hl, (cli_execword)     ; save for next check if no match on this word 
1fd3				ld a,l 
1fd3				ld hl, os_word_scratch+2 
1fd3				call hexout 
1fd3				ld hl, os_word_scratch+4 
1fd3				ld a,0 
1fd3				ld (hl),a 
1fd3				ld de,os_word_scratch 
1fd3				call str_at_display 
1fd3					ld a, display_row_2 
1fd3					call str_at_display 
1fd3				ld de, (cli_origtoken) 
1fd3				ld a, display_row_1+10 
1fd3					call str_at_display 
1fd3			 
1fd3				ld a,display_row_1 
1fd3				ld de, .foundword 
1fd3				ld a, display_row_3 
1fd3				call str_at_display 
1fd3				call update_display 
1fd3				call delay1s 
1fd3				call delay1s 
1fd3				call delay1s 
1fd3			endif 
1fd3			 
1fd3			if DEBUG_FORTH_PARSE_KEY 
1fd3						DMARK "KYj" 
1fd3			endif 
1fd3				; TODO save the word pointer in this exec 
1fd3			 
1fd3 2a b2 f9			ld hl,(cli_execword) 
1fd6 e9				jp (hl) 
1fd7			 
1fd7			 
1fd7			;    if not same 
1fd7			;	scan for zero term 
1fd7			;	get ptr for next word 
1fd7			;	goto word comp 
1fd7			 
1fd7			.execpnskipword:	; get pointer to next word 
1fd7 2a b0 f9			ld hl,(cli_nextword) 
1fda			 
1fda 7e				ld a,(hl) 
1fdb fe 00			cp WORD_SYS_END 
1fdd			;	cp 0 
1fdd 28 09			jr z, .execendofdict			 ; at end of words 
1fdf			 
1fdf			if DEBUG_FORTH_PARSE_KEY 
1fdf						DMARK "KY4" 
1fdf			endif 
1fdf			if DEBUG_FORTH_PARSE_EXEC 
1fdf			 
1fdf				; see if disabled 
1fdf			 
1fdf				ld a, (os_view_disable) 
1fdf				cp '*' 
1fdf				jr z, .noskip 
1fdf			 
1fdf			 
1fdf				ld de, .nowordfound 
1fdf				ld a, display_row_3 
1fdf				call str_at_display 
1fdf				call update_display 
1fdf				ld a, 100 
1fdf				call aDelayInMS 
1fdf				 
1fdf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fdf					call delay250ms 
1fdf				endif 
1fdf			.noskip:  
1fdf			 
1fdf			endif	 
1fdf			 
1fdf 2a ac f9			ld hl,(cli_origptr) 
1fe2 22 ae f9			ld (cli_ptr),hl 
1fe5			 
1fe5			if DEBUG_FORTH_PARSE_KEY 
1fe5						DMARK "KY5" 
1fe5			endif 
1fe5 c3 8b 1f			jp .execpnword			; else go to next word 
1fe8			 
1fe8			.execendofdict:  
1fe8			 
1fe8			if DEBUG_FORTH_PARSE_KEY 
1fe8						DMARK "KYe" 
1fe8			endif 
1fe8			if DEBUG_FORTH_PARSE_EXEC 
1fe8				; see if disabled 
1fe8			 
1fe8				ld a, (os_view_disable) 
1fe8				cp '*' 
1fe8				jr z, .ispskip 
1fe8			 
1fe8				call clear_display 
1fe8				call update_display 
1fe8				call delay1s 
1fe8				ld de, (cli_origptr) 
1fe8				ld a, display_row_1 
1fe8				call str_at_display 
1fe8				 
1fe8				ld de, .enddict 
1fe8				ld a, display_row_3 
1fe8				call str_at_display 
1fe8				call update_display 
1fe8				ld a, 100 
1fe8				call aDelayInMS 
1fe8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fe8				call delay1s 
1fe8				call delay1s 
1fe8				call delay1s 
1fe8				endif 
1fe8			.ispskip:  
1fe8				 
1fe8			endif	 
1fe8			 
1fe8			 
1fe8			 
1fe8				; if the word is not a keyword then must be a literal so push it to stack 
1fe8			 
1fe8			; push token to stack to end of word 
1fe8			 
1fe8				STACKFRAME ON $1efe $2f9f 
1fe8				if DEBUG_STACK_IMB 
1fe8					if ON 
1fe8						exx 
1fe8						ld de, $1efe 
1fe8						ld a, d 
1fe8						ld hl, curframe 
1fe8						call hexout 
1fe8						ld a, e 
1fe8						ld hl, curframe+2 
1fe8						call hexout 
1fe8						ld hl, $1efe 
1fe8						push hl 
1fe8						ld hl, $2f9f 
1fe8						push hl 
1fe8						exx 
1fe8					endif 
1fe8				endif 
1fe8			endm 
# End of macro STACKFRAME
1fe8			 
1fe8 2a a4 f2		ld hl,(os_tok_ptr) 
1feb cd e0 1c		call forth_apush 
1fee			 
1fee				STACKFRAMECHK ON $1efe $2f9f 
1fee				if DEBUG_STACK_IMB 
1fee					if ON 
1fee						exx 
1fee						ld hl, $2f9f 
1fee						pop de   ; $2f9f 
1fee						call cmp16 
1fee						jr nz, .spnosame 
1fee						ld hl, $1efe 
1fee						pop de   ; $1efe 
1fee						call cmp16 
1fee						jr z, .spfrsame 
1fee						.spnosame: call showsperror 
1fee						.spfrsame: nop 
1fee						exx 
1fee					endif 
1fee				endif 
1fee			endm 
# End of macro STACKFRAMECHK
1fee			 
1fee			execnext: 
1fee			 
1fee			if DEBUG_FORTH_PARSE_KEY 
1fee						DMARK "KY>" 
1fee			endif 
1fee			; move past token to next word 
1fee			 
1fee 2a a4 f2		ld hl, (os_tok_ptr) 
1ff1 3e 00		ld a, 0 
1ff3 01 ff 00		ld bc, 255     ; input buffer size 
1ff6 ed b1		cpir 
1ff8			 
1ff8			if DEBUG_FORTH_PARSE_KEY 
1ff8						DMARK "KY!" 
1ff8				CALLMONITOR 
1ff8			endif	 
1ff8			; TODO this might place hl on the null, so will need to forward on??? 
1ff8			;inc hl   ; see if this gets onto the next item 
1ff8			 
1ff8			 
1ff8			; TODO pass a pointer to the buffer to push 
1ff8			; TODO call function to push 
1ff8			 
1ff8			; look for end of input 
1ff8			 
1ff8			;inc hl 
1ff8			;ld a,(hl) 
1ff8			;cp FORTH_END_BUFFER 
1ff8			;ret z 
1ff8			 
1ff8			 
1ff8 c3 71 1f		jp exec1 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			findnexttok: 
1ffb			 
1ffb				; hl is pointer to move 
1ffb				; de is the token to locate 
1ffb			 
1ffb					if DEBUG_FORTH 
1ffb						DMARK "NTK" 
1ffb						CALLMONITOR 
1ffb					endif 
1ffb d5				push de 
1ffc			 
1ffc			.fnt1:	 
1ffc				; find first char of token to locate 
1ffc			 
1ffc 1a				ld a, (de) 
1ffd 4f				ld c,a 
1ffe 7e				ld a,(hl) 
1fff cd 1d 11			call toUpper 
2002					if DEBUG_FORTH 
2002						DMARK "NT1" 
2002						CALLMONITOR 
2002					endif 
2002 b9				cp c 
2003			 
2003 28 03			jr z, .fnt2cmpmorefirst	 
2005			 
2005				; first char not found move to next char 
2005			 
2005 23				inc hl 
2006 18 f4			jr .fnt1 
2008			 
2008			.fnt2cmpmorefirst:	 
2008				; first char of token found.  
2008			 
2008 e5				push hl     ; save start of token just in case it is the right one 
2009 d9				exx 
200a e1				pop hl        ; save it to hl' 
200b d9				exx 
200c			 
200c			 
200c			.fnt2cmpmore:	 
200c				; compare the rest 
200c				 
200c 23				inc hl 
200d 13				inc de 
200e				 
200e 1a				ld a, (de) 
200f 4f				ld c,a 
2010 7e				ld a,(hl) 
2011 cd 1d 11			call toUpper 
2014			 
2014					if DEBUG_FORTH 
2014						DMARK "NT2" 
2014						CALLMONITOR 
2014					endif 
2014				; c has the token to find char 
2014				; a has the mem to scan char 
2014			 
2014 b9				cp c 
2015 28 04			jr z,.fntmatch1 
2017			 
2017				; they are not the same 
2017			 
2017					if DEBUG_FORTH 
2017						DMARK "NT3" 
2017						CALLMONITOR 
2017					endif 
2017 d1				pop de	; reset de token to look for 
2018 d5				push de 
2019 18 e1			jr .fnt1 
201b				 
201b			.fntmatch1: 
201b			 
201b				; is the same char a null which means we might have a full hit? 
201b					if DEBUG_FORTH 
201b						DMARK "NT4" 
201b						CALLMONITOR 
201b					endif 
201b			 
201b fe 00			cp 0 
201d 28 0b			jr z, .fntmatchyes 
201f			 
201f				; are we at the end of the token to find? 
201f			 
201f					if DEBUG_FORTH 
201f						DMARK "NT5" 
201f						CALLMONITOR 
201f					endif 
201f 3e 00			ld a, 0 
2021 b9				cp c 
2022			 
2022 c2 0c 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2025			 
2025					if DEBUG_FORTH 
2025						DMARK "NT6" 
2025						CALLMONITOR 
2025					endif 
2025				; token to find is exhusted but no match to stream 
2025			 
2025				; restore tok pointer and continue on 
2025 d1				pop de 
2026 d5				push de 
2027 c3 fc 1f			jp .fnt1 
202a			 
202a			 
202a			.fntmatchyes: 
202a			 
202a				; hl now contains the end of the found token 
202a			 
202a				; get rid of saved token pointer to find 
202a			 
202a d1				pop de 
202b			 
202b					if DEBUG_FORTH 
202b						DMARK "NT9" 
202b						CALLMONITOR 
202b					endif 
202b			 
202b				; hl will be on the null term so forward on 
202b			 
202b				; get back the saved start of the token 
202b			 
202b d9				exx 
202c e5				push hl     ; save start of token just in case it is the right one 
202d d9				exx 
202e e1				pop hl        ; save it to hl 
202f			 
202f c9				ret 
2030			 
2030			 
2030			; LIST needs to find a specific token   
2030			; FORGET needs to find a spefici token 
2030			 
2030			; SAVE needs to find all tokens by flag 
2030			; WORDS just needs to scan through all  by flag 
2030			; UWORDS needs to scan through all by flag 
2030			 
2030			 
2030			; given hl as pointer to start of dict look up string 
2030			; return hl as pointer to start of word block 
2030			; or 0 if not found 
2030			 
2030			forth_find_tok: 
2030 c9				ret 
2031			 
2031			; given hl as pointer to dict structure 
2031			; move to the next dict block structure 
2031			 
2031			forth_tok_next: 
2031				; hl now points to the address of the next word pointer  
2031				; TODO skip compiled symbol for now 
2031			;	push de 
2031 23				inc hl 
2032 5e				ld e, (hl) 
2033 23				inc hl 
2034 56				ld d, (hl) 
2035 23				inc hl 
2036			 
2036 eb				ex de,hl 
2037			if DEBUG_FORTH_PARSE_NEXTWORD 
2037				push bc 
2037				ld bc, (cli_nextword) 
2037						DMARK "NXW" 
2037				CALLMONITOR 
2037				pop bc 
2037			endif 
2037			;	pop de	 
2037 c9				ret 
2038			 
2038			 
2038			 
2038			; eof 
# End of file forth_parserv5.asm
2038				include "forth_wordsv4.asm" 
2038			 
2038			; the core word dictionary v4 
2038			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2038			 
2038			; this is a linked list for each of the system words used 
2038			; user defined words will follow the same format but will be in ram 
2038			 
2038			 
2038			; 
2038			; 
2038			; define linked list: 
2038			; 
2038			; 1. compiled byte op code 
2038			; 2. len of text word 
2038			; 3. text word 
2038			; 4. ptr to next dictionary word 
2038			; 5. asm, calls etc for the word 
2038			; 
2038			;  if 1 == 0 then last word in dict  
2038			;   
2038			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2038			;  
2038			;  
2038			; create basic standard set of words 
2038			; 
2038			;  
2038			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2038			; 2DUP 2DROP 2SWAP  
2038			; @ C@ - get byte  
2038			; ! C! - store byte 
2038			; 0< true if less than zero 
2038			; 0= true if zero 
2038			; < >  
2038			; = true if same 
2038			; variables 
2038			 
2038			 
2038			; Hardware specific words I may need 
2038			; 
2038			; IN OUT  
2038			; calls to key util functions 
2038			; calls to hardward abstraction stuff 
2038			; easy control of frame buffers and lcd i/o 
2038			; keyboard  
2038			 
2038			 
2038			;DICT: macro 
2038			; op_code, len, word, next 
2038			;    word: 
2038			;    db op_code 
2038			;    ds word zero term 
2038			;    dw next 
2038			;    endm 
2038			 
2038			 
2038			 
2038			 
2038			; op code 1 is a flag for user define words which are to be handled differently 
2038			 
2038			 
2038			; 
2038			; 
2038			;    TODO on entry to a word this should be the expected environment 
2038			;    hl - tos value if number then held, if string this is the ptr 
2038			;    de -  
2038			 
2038			 
2038			; opcode ranges 
2038			; 0 - end of word dict 
2038			; 255 - user define words 
2038			 
2038			sysdict: 
2038			include "forth_opcodes.asm" 
2038			; op codes for forth keywords 
2038			; free to use code 0  
2038				OPCODE_HEAP: equ  1 
2038				OPCODE_EXEC: equ 2 
2038				OPCODE_DUP: equ 3 
2038				OPCODE_SWAP: equ 4 
2038				OPCODE_COLN: equ 5 
2038				OPCODE_SCOLN: equ 6 
2038				OPCODE_DROP: equ 7 
2038				OPCODE_DUP2: equ 8 
2038				OPCODE_DROP2: equ 9 
2038				OPCODE_SWAP2: equ 10 
2038				OPCODE_AT: equ 11 
2038				OPCODE_CAT: equ 12 
2038				OPCODE_BANG: equ 13 
2038				OPCODE_CBANG: equ 14 
2038				OPCODE_SCALL: equ 15 
2038				OPCODE_DEPTH: equ 16 
2038				OPCODE_OVER: equ 17 
2038				OPCODE_PAUSE: equ 18 
2038				OPCODE_PAUSES: equ 19 
2038				OPCODE_ROT: equ 20 
2038			;free to reuse	OPCODE_WORDS: equ 21 
2038			        OPCODE_NOT: equ 21 
2038				OPCODE_UWORDS: equ 22 
2038				OPCODE_BP: equ 23 
2038				OPCODE_MONITOR: equ 24  
2038				OPCODE_MALLOC: equ 25 
2038				OPCODE_FREE: equ 26 
2038				OPCODE_LIST: equ 27 
2038				OPCODE_FORGET: equ 28 
2038				OPCODE_NOP: equ 29 
2038				OPCODE_COMO: equ 30 
2038				OPCODE_COMC: equ 31 
2038			;free to reuse	OPCODE_ENDCORE: equ 32 
2038				OPCODE_AFTERSOUND: equ 33 
2038				OPCODE_GP2: equ 34 
2038				OPCODE_GP3: equ 35 
2038				OPCODE_GP4: equ 36 
2038				OPCODE_SIN: equ 37 
2038				OPCODE_SOUT: equ 38 
2038				OPCODE_SPIO: equ 39 
2038				OPCODE_SPICEH: equ 40 
2038				OPCODE_SPIOb: equ 41 
2038				OPCODE_SPII: equ 42 
2038				OPCODE_SESEL: equ 43 
2038				OPCODE_CARTDEV: equ 44 
2038			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2038				OPCODE_FB: equ 46 
2038				OPCODE_EMIT: equ 47 
2038				OPCODE_DOTH: equ 48 
2038				OPCODE_DOTF: equ 49 
2038				OPCODE_DOT: equ 50 
2038				OPCODE_CLS: equ 51 
2038				OPCODE_DRAW: equ 52 
2038				OPCODE_DUMP: equ 53 
2038				OPCODE_CDUMP: equ 54 
2038				OPCODE_DAT: equ 55 
2038				OPCODE_HOME: equ 56 
2038				OPCODE_SPACE: equ 57 
2038				OPCODE_SPACES: equ 58 
2038				OPCODE_SCROLL: equ 59 
2038				OPCODE_ATQ: equ 60 
2038				OPCODE_AUTODSP: equ 61 
2038				OPCODE_MENU: equ 62 
2038			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2038				OPCODE_THEN: equ 64 
2038				OPCODE_ELSE: equ 65 
2038				OPCODE_DO: equ 66 
2038				OPCODE_LOOP: equ 67 
2038				OPCODE_I: equ 68 
2038				OPCODE_DLOOP: equ 69  
2038				OPCODE_REPEAT: equ 70  
2038				OPCODE_UNTIL: equ 71 
2038				OPCODE_ENDFLOW: equ 72 
2038				OPCODE_WAITK: equ 73 
2038				OPCODE_ACCEPT: equ 74 
2038				OPCODE_EDIT: equ 75 
2038			;free to reuse	OPCODE_ENDKEY: equ 76 
2038				OPCODE_LZERO: equ 77 
2038				OPCODE_TZERO: equ 78 
2038				OPCODE_LESS: equ 79 
2038				OPCODE_GT: equ 80 
2038				OPCODE_EQUAL: equ 81  
2038			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2038				OPCODE_NEG: equ 83 
2038				OPCODE_DIV: equ 84 
2038				OPCODE_MUL: equ 85 
2038				OPCODE_MIN: equ 86 
2038				OPCODE_MAX: equ 87 
2038				OPCODE_RND16: equ 88 
2038				OPCODE_RND8: equ 89 
2038				OPCODE_RND: equ 90 
2038			;free to reuse	OPCODE_ENDMATHS: equ 91  
2038				OPCODE_BYNAME: equ 92 
2038				OPCODE_DIR: equ 93 
2038				OPCODE_SAVE: equ 94 
2038				OPCODE_LOAD: equ 95 
2038				OPCODE_BSAVE: equ 96 
2038				OPCODE_BLOAD: equ 97 
2038				OPCODE_SEO: equ 98  
2038				OPCODE_SEI: equ 99 
2038				OPCODE_SFREE: equ 100 
2038				OPCODE_SIZE: equ 101 
2038				OPCODE_CREATE: equ 102 
2038				OPCODE_APPEND: equ 103 
2038				OPCODE_SDEL: equ 104 
2038				OPCODE_OPEN: equ 105 
2038				OPCODE_READ: equ 106 
2038				OPCODE_EOF: equ 106 
2038				OPCODE_FORMAT: equ 107 
2038				OPCODE_LABEL: equ 108 
2038				OPCODE_LABELS: equ 109 
2038			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2038				OPCODE_UPPER: equ 111 
2038				OPCODE_LOWER: equ 112 
2038				OPCODE_SUBSTR: equ 113 
2038				OPCODE_LEFT: equ 114 
2038				OPCODE_RIGHT: equ 115 
2038				OPCODE_STR2NUM: equ 116 
2038				OPCODE_NUM2STR: equ 117 
2038				OPCODE_CONCAT: equ 118 
2038				OPCODE_FIND: equ 119 
2038				OPCODE_LEN: equ 120 
2038				OPCODE_CHAR: equ 121 
2038			; free to reuse	OPCODE_STRLEN: equ 122 
2038			; free to reuse	OPCODE_ENDSTR: equ 123 
2038				OPCODE_V0S: equ 124 
2038				OPCODE_V0Q: equ 125 
2038				OPCODE_V1S: equ 126 
2038				OPCODE_V1Q: equ 127 
2038				OPCODE_V2S: equ 128 
2038				OPCODE_V2Q: equ 129 
2038				OPCODE_V3S: equ 130 
2038				OPCODE_V3Q: equ 131 
2038			;free to reuse	OPCODE_END: equ 132 
2038				OPCODE_ZDUP: equ 133 
2038			 
2038			; eof 
# End of file forth_opcodes.asm
2038			 
2038			include "forth_words_core.asm" 
2038			 
2038			; | ## Core Words 
2038			 
2038			;if MALLOC_4 
2038			 
2038			.HEAP: 
2038				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2038 15				db WORD_SYS_CORE+OPCODE_HEAP             
2039 77 20			dw .EXEC            
203b 05				db 4 + 1 
203c .. 00			db "HEAP",0              
2041				endm 
# End of macro CWHEAD
2041			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2041			; | | u1 - Current number of bytes in the heap 
2041			; | | u2 - Remaining bytes left on the heap 
2041			; | |  
2041			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2041			 
2041			 
2041					if DEBUG_FORTH_WORDS_KEY 
2041						DMARK "HEP" 
2041 f5				push af  
2042 3a 56 20			ld a, (.dmark)  
2045 32 bd fb			ld (debug_mark),a  
2048 3a 57 20			ld a, (.dmark+1)  
204b 32 be fb			ld (debug_mark+1),a  
204e 3a 58 20			ld a, (.dmark+2)  
2051 32 bf fb			ld (debug_mark+2),a  
2054 18 03			jr .pastdmark  
2056 ..			.dmark: db "HEP"  
2059 f1			.pastdmark: pop af  
205a			endm  
# End of macro DMARK
205a						CALLMONITOR 
205a cd ea 15			call break_point_state  
205d				endm  
# End of macro CALLMONITOR
205d					endif 
205d 2a 0a 80				ld hl, (free_list )      
2060 11 0e 80				ld de, heap_start 
2063			 
2063 ed 52				sbc hl, de  
2065			 
2065 cd 77 1b				call forth_push_numhl 
2068			 
2068			 
2068 ed 5b 0a 80			ld de, (free_list )      
206c 21 89 ef				ld hl, heap_end 
206f			 
206f ed 52				sbc hl, de 
2071			 
2071 cd 77 1b				call forth_push_numhl 
2074					 
2074			 
2074					 
2074			 
2074			 
2074			 
2074					NEXTW 
2074 c3 e0 1e			jp macro_next 
2077				endm 
# End of macro NEXTW
2077			;endif 
2077			 
2077			.EXEC: 
2077				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2077 16				db WORD_SYS_CORE+OPCODE_EXEC             
2078 13 21			dw .STKEXEC            
207a 05				db 4 + 1 
207b .. 00			db "EXEC",0              
2080				endm 
# End of macro CWHEAD
2080			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
2080			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2080			; | | 
2080			; | |   
2080				STACKFRAME OFF $5efe $5f9f 
2080				if DEBUG_STACK_IMB 
2080					if OFF 
2080						exx 
2080						ld de, $5efe 
2080						ld a, d 
2080						ld hl, curframe 
2080						call hexout 
2080						ld a, e 
2080						ld hl, curframe+2 
2080						call hexout 
2080						ld hl, $5efe 
2080						push hl 
2080						ld hl, $5f9f 
2080						push hl 
2080						exx 
2080					endif 
2080				endif 
2080			endm 
# End of macro STACKFRAME
2080			 
2080					if DEBUG_FORTH_WORDS_KEY 
2080						DMARK "EXE" 
2080 f5				push af  
2081 3a 95 20			ld a, (.dmark)  
2084 32 bd fb			ld (debug_mark),a  
2087 3a 96 20			ld a, (.dmark+1)  
208a 32 be fb			ld (debug_mark+1),a  
208d 3a 97 20			ld a, (.dmark+2)  
2090 32 bf fb			ld (debug_mark+2),a  
2093 18 03			jr .pastdmark  
2095 ..			.dmark: db "EXE"  
2098 f1			.pastdmark: pop af  
2099			endm  
# End of macro DMARK
2099						CALLMONITOR 
2099 cd ea 15			call break_point_state  
209c				endm  
# End of macro CALLMONITOR
209c					endif 
209c			 
209c				FORTH_DSP_VALUEHL 
209c cd 6e 1d			call macro_dsp_valuehl 
209f				endm 
# End of macro FORTH_DSP_VALUEHL
209f			 
209f				FORTH_DSP_POP 
209f cd 26 1e			call macro_forth_dsp_pop 
20a2				endm 
# End of macro FORTH_DSP_POP
20a2			 
20a2					if DEBUG_FORTH_WORDS 
20a2						DMARK "EX1" 
20a2 f5				push af  
20a3 3a b7 20			ld a, (.dmark)  
20a6 32 bd fb			ld (debug_mark),a  
20a9 3a b8 20			ld a, (.dmark+1)  
20ac 32 be fb			ld (debug_mark+1),a  
20af 3a b9 20			ld a, (.dmark+2)  
20b2 32 bf fb			ld (debug_mark+2),a  
20b5 18 03			jr .pastdmark  
20b7 ..			.dmark: db "EX1"  
20ba f1			.pastdmark: pop af  
20bb			endm  
# End of macro DMARK
20bb						CALLMONITOR 
20bb cd ea 15			call break_point_state  
20be				endm  
# End of macro CALLMONITOR
20be					endif 
20be			;	ld e,(hl) 
20be			;	inc hl 
20be			;	ld d,(hl) 
20be			;	ex de,hl 
20be			 
20be			;		if DEBUG_FORTH_WORDS 
20be			;			DMARK "EX2" 
20be			;			CALLMONITOR 
20be			;		endif 
20be e5				push hl 
20bf			 
20bf				;ld a, 0 
20bf				;ld a, FORTH_END_BUFFER 
20bf cd 26 11			call strlenz 
20c2 23				inc hl   ; include zero term to copy 
20c3 23				inc hl   ; include term 
20c4 23				inc hl   ; include term 
20c5 06 00			ld b,0 
20c7 4d				ld c,l 
20c8 e1				pop hl 
20c9 11 a2 f0			ld de, execscratch 
20cc					if DEBUG_FORTH_WORDS 
20cc						DMARK "EX3" 
20cc f5				push af  
20cd 3a e1 20			ld a, (.dmark)  
20d0 32 bd fb			ld (debug_mark),a  
20d3 3a e2 20			ld a, (.dmark+1)  
20d6 32 be fb			ld (debug_mark+1),a  
20d9 3a e3 20			ld a, (.dmark+2)  
20dc 32 bf fb			ld (debug_mark+2),a  
20df 18 03			jr .pastdmark  
20e1 ..			.dmark: db "EX3"  
20e4 f1			.pastdmark: pop af  
20e5			endm  
# End of macro DMARK
20e5						CALLMONITOR 
20e5 cd ea 15			call break_point_state  
20e8				endm  
# End of macro CALLMONITOR
20e8					endif 
20e8 ed b0			ldir 
20ea			 
20ea			 
20ea 21 a2 f0			ld hl, execscratch 
20ed			 
20ed					if DEBUG_FORTH_WORDS 
20ed						DMARK "EXe" 
20ed f5				push af  
20ee 3a 02 21			ld a, (.dmark)  
20f1 32 bd fb			ld (debug_mark),a  
20f4 3a 03 21			ld a, (.dmark+1)  
20f7 32 be fb			ld (debug_mark+1),a  
20fa 3a 04 21			ld a, (.dmark+2)  
20fd 32 bf fb			ld (debug_mark+2),a  
2100 18 03			jr .pastdmark  
2102 ..			.dmark: db "EXe"  
2105 f1			.pastdmark: pop af  
2106			endm  
# End of macro DMARK
2106						CALLMONITOR 
2106 cd ea 15			call break_point_state  
2109				endm  
# End of macro CALLMONITOR
2109					endif 
2109			 
2109 cd 2e 1f			call forthparse 
210c cd 6e 1f			call forthexec 
210f			;	call forthexec_cleanup 
210f			;	call forthparse 
210f			;	call forthexec 
210f			 
210f				STACKFRAMECHK OFF $5efe $5f9f 
210f				if DEBUG_STACK_IMB 
210f					if OFF 
210f						exx 
210f						ld hl, $5f9f 
210f						pop de   ; $5f9f 
210f						call cmp16 
210f						jr nz, .spnosame 
210f						ld hl, $5efe 
210f						pop de   ; $5efe 
210f						call cmp16 
210f						jr z, .spfrsame 
210f						.spnosame: call showsperror 
210f						.spfrsame: nop 
210f						exx 
210f					endif 
210f				endif 
210f			endm 
# End of macro STACKFRAMECHK
210f			 
210f				; an immediate word so no need to process any more words 
210f c9				ret 
2110				NEXTW 
2110 c3 e0 1e			jp macro_next 
2113				endm 
# End of macro NEXTW
2113			 
2113			; dead code - old version  
2113			;	FORTH_RSP_NEXT 
2113			 
2113			;  
2113			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2113			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2113			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2113			;	push hl 
2113			;	push de 
2113			;	push bc 
2113			; 
2113			; 
2113			;		if DEBUG_FORTH_WORDS_KEY 
2113			;			DMARK "EXR" 
2113			;			CALLMONITOR 
2113			;		endif 
2113			; 
2113			; 
2113			; 
2113			;	;v5 FORTH_DSP_VALUE 
2113			;	FORTH_DSP_VALUEHL 
2113			; 
2113			;	; TODO do string type checks 
2113			; 
2113			;;v5	inc hl   ; skip type 
2113			; 
2113			;	push hl  ; source code  
2113			;		if DEBUG_FORTH_WORDS 
2113			;			DMARK "EX1" 
2113			;			CALLMONITOR 
2113			;		endif 
2113			;	ld a, 0 
2113			;	call strlent 
2113			; 
2113			;	inc hl 
2113			;	inc hl 
2113			;	inc hl 
2113			;	inc hl 
2113			; 
2113			;	push hl    ; size 
2113			; 
2113			;		if DEBUG_FORTH_WORDS 
2113			;			DMARK "EX2" 
2113			;			CALLMONITOR 
2113			;		endif 
2113			;	call malloc 
2113			; 
2113			;	ex de, hl    ; de now contains malloc area 
2113			;	pop bc   	; get byte count 
2113			;	pop hl      ; get string to copy 
2113			; 
2113			;	push de     ; save malloc for free later 
2113			; 
2113			;		if DEBUG_FORTH_WORDS 
2113			;			DMARK "EX3" 
2113			;			CALLMONITOR 
2113			;		endif 
2113			;	ldir       ; duplicate string 
2113			; 
2113			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2113			;	 
2113			;	; TODO fix the parse would be better than this...  
2113			;	ex de, hl 
2113			;	dec hl 
2113			;	ld a, 0 
2113			;	ld (hl), a 
2113			;	dec hl 
2113			;	ld a, ' ' 
2113			;	ld (hl), a 
2113			;	dec hl 
2113			;	ld (hl), a 
2113			; 
2113			;	dec hl 
2113			;	ld (hl), a 
2113			; 
2113			; 
2113			;	FORTH_DSP_POP  
2113			; 
2113			;	pop hl     
2113			;	push hl    ; save malloc area 
2113			; 
2113			;		if DEBUG_FORTH_WORDS 
2113			;			DMARK "EX4" 
2113			;			CALLMONITOR 
2113			;		endif 
2113			; 
2113			;	call forthparse 
2113			;	call forthexec 
2113			;	 
2113			;	pop hl 
2113			;	if DEBUG_FORTH_WORDS 
2113			;		DMARK "EX5" 
2113			;		CALLMONITOR 
2113			;	endif 
2113			; 
2113			;	if FORTH_ENABLE_FREE 
2113			;	call free 
2113			;	endif 
2113			; 
2113			;	if DEBUG_FORTH_WORDS 
2113			;		DMARK "EX6" 
2113			;		CALLMONITOR 
2113			;	endif 
2113			; 
2113			;	pop bc 
2113			;	pop de 
2113			;	pop hl 
2113			;;	FORTH_RSP_POP	  
2113			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2113			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2113			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2113			; 
2113			;	if DEBUG_FORTH_WORDS 
2113			;		DMARK "EX7" 
2113			;		CALLMONITOR 
2113			;	endif 
2113			;	NEXTW 
2113			 
2113			.STKEXEC: 
2113				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2113 3f				db WORD_SYS_CORE+43             
2114 5b 22			dw .ZDUP            
2116 08				db 7 + 1 
2117 .. 00			db "STKEXEC",0              
211f				endm 
# End of macro CWHEAD
211f			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
211f			 
211f			 
211f					if DEBUG_FORTH_WORDS_KEY 
211f						DMARK "STX" 
211f f5				push af  
2120 3a 34 21			ld a, (.dmark)  
2123 32 bd fb			ld (debug_mark),a  
2126 3a 35 21			ld a, (.dmark+1)  
2129 32 be fb			ld (debug_mark+1),a  
212c 3a 36 21			ld a, (.dmark+2)  
212f 32 bf fb			ld (debug_mark+2),a  
2132 18 03			jr .pastdmark  
2134 ..			.dmark: db "STX"  
2137 f1			.pastdmark: pop af  
2138			endm  
# End of macro DMARK
2138						CALLMONITOR 
2138 cd ea 15			call break_point_state  
213b				endm  
# End of macro CALLMONITOR
213b					endif 
213b			 
213b				FORTH_DSP_VALUEHL 
213b cd 6e 1d			call macro_dsp_valuehl 
213e				endm 
# End of macro FORTH_DSP_VALUEHL
213e			 
213e 22 e6 f9			ld (store_tmp1), hl    ; count 
2141			 
2141				FORTH_DSP_POP 
2141 cd 26 1e			call macro_forth_dsp_pop 
2144				endm 
# End of macro FORTH_DSP_POP
2144			.stkexec1: 
2144 2a e6 f9			ld hl, (store_tmp1)   ; count 
2147 3e 00			ld a, 0 
2149 bd				cp l 
214a c8				ret z 
214b			 
214b 2b				dec hl 
214c 22 e6 f9			ld (store_tmp1), hl    ; count 
214f				 
214f				FORTH_DSP_VALUEHL 
214f cd 6e 1d			call macro_dsp_valuehl 
2152				endm 
# End of macro FORTH_DSP_VALUEHL
2152 e5				push hl 
2153				 
2153					if DEBUG_FORTH_WORDS 
2153						DMARK "EXp" 
2153 f5				push af  
2154 3a 68 21			ld a, (.dmark)  
2157 32 bd fb			ld (debug_mark),a  
215a 3a 69 21			ld a, (.dmark+1)  
215d 32 be fb			ld (debug_mark+1),a  
2160 3a 6a 21			ld a, (.dmark+2)  
2163 32 bf fb			ld (debug_mark+2),a  
2166 18 03			jr .pastdmark  
2168 ..			.dmark: db "EXp"  
216b f1			.pastdmark: pop af  
216c			endm  
# End of macro DMARK
216c						CALLMONITOR 
216c cd ea 15			call break_point_state  
216f				endm  
# End of macro CALLMONITOR
216f					endif 
216f				FORTH_DSP_POP 
216f cd 26 1e			call macro_forth_dsp_pop 
2172				endm 
# End of macro FORTH_DSP_POP
2172			 
2172 cd 26 11			call strlenz 
2175 23				inc hl   ; include zero term to copy 
2176 23				inc hl   ; include zero term to copy 
2177 23				inc hl   ; include zero term to copy 
2178 06 00			ld b,0 
217a 4d				ld c,l 
217b e1				pop hl 
217c 11 a2 f0			ld de, execscratch 
217f					if DEBUG_FORTH_WORDS 
217f						DMARK "EX3" 
217f f5				push af  
2180 3a 94 21			ld a, (.dmark)  
2183 32 bd fb			ld (debug_mark),a  
2186 3a 95 21			ld a, (.dmark+1)  
2189 32 be fb			ld (debug_mark+1),a  
218c 3a 96 21			ld a, (.dmark+2)  
218f 32 bf fb			ld (debug_mark+2),a  
2192 18 03			jr .pastdmark  
2194 ..			.dmark: db "EX3"  
2197 f1			.pastdmark: pop af  
2198			endm  
# End of macro DMARK
2198						CALLMONITOR 
2198 cd ea 15			call break_point_state  
219b				endm  
# End of macro CALLMONITOR
219b					endif 
219b ed b0			ldir 
219d			 
219d			 
219d 21 a2 f0			ld hl, execscratch 
21a0			 
21a0					if DEBUG_FORTH_WORDS 
21a0						DMARK "EXP" 
21a0 f5				push af  
21a1 3a b5 21			ld a, (.dmark)  
21a4 32 bd fb			ld (debug_mark),a  
21a7 3a b6 21			ld a, (.dmark+1)  
21aa 32 be fb			ld (debug_mark+1),a  
21ad 3a b7 21			ld a, (.dmark+2)  
21b0 32 bf fb			ld (debug_mark+2),a  
21b3 18 03			jr .pastdmark  
21b5 ..			.dmark: db "EXP"  
21b8 f1			.pastdmark: pop af  
21b9			endm  
# End of macro DMARK
21b9						CALLMONITOR 
21b9 cd ea 15			call break_point_state  
21bc				endm  
# End of macro CALLMONITOR
21bc					endif 
21bc			 
21bc cd 2e 1f			call forthparse 
21bf 21 a2 f0			ld hl, execscratch 
21c2					if DEBUG_FORTH_WORDS 
21c2						DMARK "EXx" 
21c2 f5				push af  
21c3 3a d7 21			ld a, (.dmark)  
21c6 32 bd fb			ld (debug_mark),a  
21c9 3a d8 21			ld a, (.dmark+1)  
21cc 32 be fb			ld (debug_mark+1),a  
21cf 3a d9 21			ld a, (.dmark+2)  
21d2 32 bf fb			ld (debug_mark+2),a  
21d5 18 03			jr .pastdmark  
21d7 ..			.dmark: db "EXx"  
21da f1			.pastdmark: pop af  
21db			endm  
# End of macro DMARK
21db						CALLMONITOR 
21db cd ea 15			call break_point_state  
21de				endm  
# End of macro CALLMONITOR
21de					endif 
21de cd 6e 1f			call forthexec 
21e1			 
21e1 c3 44 21			jp .stkexec1 
21e4			 
21e4 c9				ret 
21e5			 
21e5			 
21e5			.DUP: 
21e5				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21e5 17				db WORD_SYS_CORE+OPCODE_DUP             
21e6 5b 22			dw .ZDUP            
21e8 04				db 3 + 1 
21e9 .. 00			db "DUP",0              
21ed				endm 
# End of macro CWHEAD
21ed			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21ed			 
21ed					if DEBUG_FORTH_WORDS_KEY 
21ed						DMARK "DUP" 
21ed f5				push af  
21ee 3a 02 22			ld a, (.dmark)  
21f1 32 bd fb			ld (debug_mark),a  
21f4 3a 03 22			ld a, (.dmark+1)  
21f7 32 be fb			ld (debug_mark+1),a  
21fa 3a 04 22			ld a, (.dmark+2)  
21fd 32 bf fb			ld (debug_mark+2),a  
2200 18 03			jr .pastdmark  
2202 ..			.dmark: db "DUP"  
2205 f1			.pastdmark: pop af  
2206			endm  
# End of macro DMARK
2206						CALLMONITOR 
2206 cd ea 15			call break_point_state  
2209				endm  
# End of macro CALLMONITOR
2209					endif 
2209			 
2209					FORTH_DSP 
2209 cd 34 1d			call macro_forth_dsp 
220c				endm 
# End of macro FORTH_DSP
220c			 
220c 7e					ld a, (HL) 
220d fe 01				cp DS_TYPE_STR 
220f 20 25				jr nz, .dupinum 
2211			 
2211					; push another string 
2211			 
2211					FORTH_DSP_VALUEHL     		 
2211 cd 6e 1d			call macro_dsp_valuehl 
2214				endm 
# End of macro FORTH_DSP_VALUEHL
2214			 
2214				if DEBUG_FORTH_WORDS 
2214					DMARK "DUs" 
2214 f5				push af  
2215 3a 29 22			ld a, (.dmark)  
2218 32 bd fb			ld (debug_mark),a  
221b 3a 2a 22			ld a, (.dmark+1)  
221e 32 be fb			ld (debug_mark+1),a  
2221 3a 2b 22			ld a, (.dmark+2)  
2224 32 bf fb			ld (debug_mark+2),a  
2227 18 03			jr .pastdmark  
2229 ..			.dmark: db "DUs"  
222c f1			.pastdmark: pop af  
222d			endm  
# End of macro DMARK
222d					CALLMONITOR 
222d cd ea 15			call break_point_state  
2230				endm  
# End of macro CALLMONITOR
2230				endif 
2230 cd e5 1b				call forth_push_str 
2233			 
2233					NEXTW 
2233 c3 e0 1e			jp macro_next 
2236				endm 
# End of macro NEXTW
2236			 
2236			 
2236			.dupinum: 
2236					 
2236			 
2236			 
2236					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2236 cd 6e 1d			call macro_dsp_valuehl 
2239				endm 
# End of macro FORTH_DSP_VALUEHL
2239			 
2239				; TODO add floating point number detection 
2239			 
2239				if DEBUG_FORTH_WORDS 
2239					DMARK "DUi" 
2239 f5				push af  
223a 3a 4e 22			ld a, (.dmark)  
223d 32 bd fb			ld (debug_mark),a  
2240 3a 4f 22			ld a, (.dmark+1)  
2243 32 be fb			ld (debug_mark+1),a  
2246 3a 50 22			ld a, (.dmark+2)  
2249 32 bf fb			ld (debug_mark+2),a  
224c 18 03			jr .pastdmark  
224e ..			.dmark: db "DUi"  
2251 f1			.pastdmark: pop af  
2252			endm  
# End of macro DMARK
2252					CALLMONITOR 
2252 cd ea 15			call break_point_state  
2255				endm  
# End of macro CALLMONITOR
2255				endif 
2255			 
2255 cd 77 1b				call forth_push_numhl 
2258					NEXTW 
2258 c3 e0 1e			jp macro_next 
225b				endm 
# End of macro NEXTW
225b			.ZDUP: 
225b				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
225b 99				db WORD_SYS_CORE+OPCODE_ZDUP             
225c 93 22			dw .SWAP            
225e 05				db 4 + 1 
225f .. 00			db "?DUP",0              
2264				endm 
# End of macro CWHEAD
2264			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2264			 
2264					if DEBUG_FORTH_WORDS_KEY 
2264						DMARK "qDU" 
2264 f5				push af  
2265 3a 79 22			ld a, (.dmark)  
2268 32 bd fb			ld (debug_mark),a  
226b 3a 7a 22			ld a, (.dmark+1)  
226e 32 be fb			ld (debug_mark+1),a  
2271 3a 7b 22			ld a, (.dmark+2)  
2274 32 bf fb			ld (debug_mark+2),a  
2277 18 03			jr .pastdmark  
2279 ..			.dmark: db "qDU"  
227c f1			.pastdmark: pop af  
227d			endm  
# End of macro DMARK
227d						CALLMONITOR 
227d cd ea 15			call break_point_state  
2280				endm  
# End of macro CALLMONITOR
2280					endif 
2280					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2280 cd 6e 1d			call macro_dsp_valuehl 
2283				endm 
# End of macro FORTH_DSP_VALUEHL
2283			 
2283 e5					push hl 
2284			 
2284					; is it a zero? 
2284			 
2284 3e 00				ld a, 0 
2286 84					add h 
2287 85					add l 
2288			 
2288 e1					pop hl 
2289			 
2289 fe 00				cp 0 
228b 28 03				jr z, .dup2orig 
228d			 
228d			 
228d cd 77 1b				call forth_push_numhl 
2290			 
2290			 
2290				; TODO add floating point number detection 
2290			 
2290			.dup2orig: 
2290			 
2290					NEXTW 
2290 c3 e0 1e			jp macro_next 
2293				endm 
# End of macro NEXTW
2293			.SWAP: 
2293				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2293 18				db WORD_SYS_CORE+OPCODE_SWAP             
2294 d2 22			dw .COLN            
2296 05				db 4 + 1 
2297 .. 00			db "SWAP",0              
229c				endm 
# End of macro CWHEAD
229c			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
229c					if DEBUG_FORTH_WORDS_KEY 
229c						DMARK "SWP" 
229c f5				push af  
229d 3a b1 22			ld a, (.dmark)  
22a0 32 bd fb			ld (debug_mark),a  
22a3 3a b2 22			ld a, (.dmark+1)  
22a6 32 be fb			ld (debug_mark+1),a  
22a9 3a b3 22			ld a, (.dmark+2)  
22ac 32 bf fb			ld (debug_mark+2),a  
22af 18 03			jr .pastdmark  
22b1 ..			.dmark: db "SWP"  
22b4 f1			.pastdmark: pop af  
22b5			endm  
# End of macro DMARK
22b5						CALLMONITOR 
22b5 cd ea 15			call break_point_state  
22b8				endm  
# End of macro CALLMONITOR
22b8					endif 
22b8			 
22b8					FORTH_DSP_VALUEHL 
22b8 cd 6e 1d			call macro_dsp_valuehl 
22bb				endm 
# End of macro FORTH_DSP_VALUEHL
22bb e5					push hl     ; w2 
22bc			 
22bc					FORTH_DSP_POP 
22bc cd 26 1e			call macro_forth_dsp_pop 
22bf				endm 
# End of macro FORTH_DSP_POP
22bf			 
22bf					FORTH_DSP_VALUEHL 
22bf cd 6e 1d			call macro_dsp_valuehl 
22c2				endm 
# End of macro FORTH_DSP_VALUEHL
22c2			 
22c2					FORTH_DSP_POP 
22c2 cd 26 1e			call macro_forth_dsp_pop 
22c5				endm 
# End of macro FORTH_DSP_POP
22c5			 
22c5 d1					pop de     ; w2	, hl = w1 
22c6			 
22c6 eb					ex de, hl 
22c7 d5					push de 
22c8			 
22c8 cd 77 1b				call forth_push_numhl 
22cb			 
22cb e1					pop hl 
22cc			 
22cc cd 77 1b				call forth_push_numhl 
22cf					 
22cf			 
22cf					NEXTW 
22cf c3 e0 1e			jp macro_next 
22d2				endm 
# End of macro NEXTW
22d2			.COLN: 
22d2				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22d2 19				db WORD_SYS_CORE+OPCODE_COLN             
22d3 5e 24			dw .SCOLN            
22d5 02				db 1 + 1 
22d6 .. 00			db ":",0              
22d8				endm 
# End of macro CWHEAD
22d8			; | : ( -- )         Create new word | DONE 
22d8			 
22d8					if DEBUG_FORTH_WORDS_KEY 
22d8						DMARK "CLN" 
22d8 f5				push af  
22d9 3a ed 22			ld a, (.dmark)  
22dc 32 bd fb			ld (debug_mark),a  
22df 3a ee 22			ld a, (.dmark+1)  
22e2 32 be fb			ld (debug_mark+1),a  
22e5 3a ef 22			ld a, (.dmark+2)  
22e8 32 bf fb			ld (debug_mark+2),a  
22eb 18 03			jr .pastdmark  
22ed ..			.dmark: db "CLN"  
22f0 f1			.pastdmark: pop af  
22f1			endm  
# End of macro DMARK
22f1						CALLMONITOR 
22f1 cd ea 15			call break_point_state  
22f4				endm  
# End of macro CALLMONITOR
22f4					endif 
22f4				STACKFRAME OFF $8efe $989f 
22f4				if DEBUG_STACK_IMB 
22f4					if OFF 
22f4						exx 
22f4						ld de, $8efe 
22f4						ld a, d 
22f4						ld hl, curframe 
22f4						call hexout 
22f4						ld a, e 
22f4						ld hl, curframe+2 
22f4						call hexout 
22f4						ld hl, $8efe 
22f4						push hl 
22f4						ld hl, $989f 
22f4						push hl 
22f4						exx 
22f4					endif 
22f4				endif 
22f4			endm 
# End of macro STACKFRAME
22f4				; get parser buffer length  of new word 
22f4			 
22f4				 
22f4			 
22f4					; move tok past this to start of name defintition 
22f4					; TODO get word to define 
22f4					; TODO Move past word token 
22f4					; TODO get length of string up to the ';' 
22f4			 
22f4 2a a4 f2			ld hl, (os_tok_ptr) 
22f7 23				inc hl 
22f8 23				inc hl 
22f9			 
22f9 3e 3b			ld a, ';' 
22fb cd 31 11			call strlent 
22fe			 
22fe 7d				ld a,l 
22ff 32 9f ef			ld (os_new_parse_len), a 
2302			 
2302			 
2302			if DEBUG_FORTH_UWORD 
2302 ed 5b a4 f2		ld de, (os_tok_ptr) 
2306						DMARK ":01" 
2306 f5				push af  
2307 3a 1b 23			ld a, (.dmark)  
230a 32 bd fb			ld (debug_mark),a  
230d 3a 1c 23			ld a, (.dmark+1)  
2310 32 be fb			ld (debug_mark+1),a  
2313 3a 1d 23			ld a, (.dmark+2)  
2316 32 bf fb			ld (debug_mark+2),a  
2319 18 03			jr .pastdmark  
231b ..			.dmark: db ":01"  
231e f1			.pastdmark: pop af  
231f			endm  
# End of macro DMARK
231f				CALLMONITOR 
231f cd ea 15			call break_point_state  
2322				endm  
# End of macro CALLMONITOR
2322			endif 
2322			 
2322			; 
2322			;  new word memory layout: 
2322			;  
2322			;    : adg 6666 ;  
2322			; 
2322			;    db   1     ; user defined word  
2322 23				inc hl    
2323			;    dw   sysdict 
2323 23				inc hl 
2324 23				inc hl 
2325			;    db <word len>+1 (for null) 
2325 23				inc hl 
2326			;    db .... <word> 
2326			; 
2326			 
2326 23				inc hl    ; some extras for the word preamble before the above 
2327 23				inc hl 
2328 23				inc hl 
2329 23				inc hl 
232a 23				inc hl 
232b 23				inc hl 
232c 23				inc hl  
232d 23				inc hl 
232e 23				inc hl 
232f 23				inc hl 
2330 23				inc hl 
2331 23				inc hl 
2332 23				inc hl 
2333 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2334			;       exec word buffer 
2334			;	<ptr word>   
2334 23				inc hl 
2335 23				inc hl 
2336			;       <word list><null term> 7F final term 
2336			 
2336			 
2336			if DEBUG_FORTH_UWORD 
2336						DMARK ":02" 
2336 f5				push af  
2337 3a 4b 23			ld a, (.dmark)  
233a 32 bd fb			ld (debug_mark),a  
233d 3a 4c 23			ld a, (.dmark+1)  
2340 32 be fb			ld (debug_mark+1),a  
2343 3a 4d 23			ld a, (.dmark+2)  
2346 32 bf fb			ld (debug_mark+2),a  
2349 18 03			jr .pastdmark  
234b ..			.dmark: db ":02"  
234e f1			.pastdmark: pop af  
234f			endm  
# End of macro DMARK
234f				CALLMONITOR 
234f cd ea 15			call break_point_state  
2352				endm  
# End of macro CALLMONITOR
2352			endif 
2352			 
2352				 
2352					; malloc the size 
2352			 
2352 cd 8f 11				call malloc 
2355 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
2358			 
2358			;    db   1     ; user defined word  
2358 3e 01				ld a, WORD_SYS_UWORD  
235a 77					ld (hl), a 
235b				 
235b 23				inc hl    
235c			;    dw   sysdict 
235c 11 38 20			ld de, sysdict       ; continue on with the scan to the system dict 
235f 73				ld (hl), e 
2360 23				inc hl 
2361 72				ld (hl), d 
2362 23				inc hl 
2363			 
2363			 
2363			;    Setup dict word 
2363			 
2363 23				inc hl 
2364 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
2367			 
2367				; 1. get length of dict word 
2367			 
2367			 
2367 2a a4 f2			ld hl, (os_tok_ptr) 
236a 23				inc hl 
236b 23				inc hl    ; position to start of dict word 
236c 3e 00			ld a, 0 
236e cd 31 11			call strlent 
2371			 
2371			 
2371 23				inc hl    ; to include null??? 
2372			 
2372				; write length of dict word 
2372			 
2372 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2376 1b				dec de 
2377 eb				ex de, hl 
2378 73				ld (hl), e 
2379 eb				ex de, hl 
237a			 
237a				 
237a			 
237a				; copy  
237a 4d				ld c, l 
237b 06 00			ld b, 0 
237d ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2381 2a a4 f2			ld hl, (os_tok_ptr) 
2384 23				inc hl 
2385 23				inc hl    ; position to start of dict word 
2386				 
2386			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2386				 
2386				; TODO need to convert word to upper case 
2386			 
2386			ucasetok:	 
2386 7e				ld a,(hl) 
2387 cd 1d 11			call toUpper 
238a 77				ld (hl),a 
238b ed a0			ldi 
238d f2 86 23		 	jp p, ucasetok 
2390			 
2390			 
2390			 
2390				; de now points to start of where the word body code should be placed 
2390 ed 53 9b ef		ld (os_new_work_ptr), de 
2394				; hl now points to the words to throw at forthexec which needs to be copied 
2394 22 99 ef			ld (os_new_src_ptr), hl 
2397			 
2397				; TODO add 'call to forthexec' 
2397			 
2397			if DEBUG_FORTH_UWORD 
2397 c5				push bc 
2398 ed 4b a1 ef		ld bc, (os_new_malloc) 
239c						DMARK ":0x" 
239c f5				push af  
239d 3a b1 23			ld a, (.dmark)  
23a0 32 bd fb			ld (debug_mark),a  
23a3 3a b2 23			ld a, (.dmark+1)  
23a6 32 be fb			ld (debug_mark+1),a  
23a9 3a b3 23			ld a, (.dmark+2)  
23ac 32 bf fb			ld (debug_mark+2),a  
23af 18 03			jr .pastdmark  
23b1 ..			.dmark: db ":0x"  
23b4 f1			.pastdmark: pop af  
23b5			endm  
# End of macro DMARK
23b5				CALLMONITOR 
23b5 cd ea 15			call break_point_state  
23b8				endm  
# End of macro CALLMONITOR
23b8 c1				pop bc 
23b9			endif 
23b9			 
23b9			 
23b9				; create word preamble which should be: 
23b9			 
23b9			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23b9			 
23b9				;    ld hl, <word code> 
23b9				;    jp user_exec 
23b9			        ;    <word code bytes> 
23b9			 
23b9			 
23b9			;	inc de     ; TODO ??? or are we already past the word's null 
23b9 eb				ex de, hl 
23ba			 
23ba 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23bc			 
23bc 23				inc hl 
23bd 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23c0 23				inc hl 
23c1			 
23c1 23				inc hl 
23c2 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23c4			 
23c4 01 a1 50			ld bc, user_exec 
23c7 23				inc hl 
23c8 71				ld (hl), c     ; poke address of user_exec 
23c9 23				inc hl 
23ca 70				ld (hl), b     
23cb			 ; 
23cb			;	inc hl 
23cb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23cb			; 
23cb			; 
23cb			;	ld bc, macro_forth_rsp_next 
23cb			;	inc hl 
23cb			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23cb			;	inc hl 
23cb			;	ld (hl), b     
23cb			 ; 
23cb			;	inc hl 
23cb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23cb			; 
23cb			; 
23cb			;	inc hl 
23cb			;	ld bc, forthexec 
23cb			;	ld (hl), c     ; poke address of forthexec 
23cb			;	inc hl 
23cb			;	ld (hl), b      
23cb			; 
23cb			;	inc hl 
23cb			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23cb			; 
23cb			;	ld bc, user_dict_next 
23cb			;	inc hl 
23cb			;	ld (hl), c     ; poke address of forthexec 
23cb			;	inc hl 
23cb			;	ld (hl), b      
23cb			 
23cb				; hl is now where we need to copy the word byte data to save this 
23cb			 
23cb 23				inc hl 
23cc 22 97 ef			ld (os_new_exec), hl 
23cf				 
23cf				; copy definition 
23cf			 
23cf eb				ex de, hl 
23d0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23d0			;	inc de    ; skip the PC for this parse 
23d0 3a 9f ef			ld a, (os_new_parse_len) 
23d3 4f				ld c, a 
23d4 06 00			ld b, 0 
23d6 ed b0			ldir		 ; copy defintion 
23d8			 
23d8			 
23d8				; poke the address of where the new word bytes live for forthexec 
23d8			 
23d8 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23db			 
23db ed 5b 97 ef		ld de, (os_new_exec)      
23df				 
23df 73				ld (hl), e 
23e0 23				inc hl 
23e1 72				ld (hl), d 
23e2			 
23e2					; TODO copy last user dict word next link to this word 
23e2					; TODO update last user dict word to point to this word 
23e2			; 
23e2			; hl f923 de 812a ; bc 811a 
23e2			 
23e2			if DEBUG_FORTH_UWORD 
23e2 c5				push bc 
23e3 ed 4b a1 ef		ld bc, (os_new_malloc) 
23e7						DMARK ":0A" 
23e7 f5				push af  
23e8 3a fc 23			ld a, (.dmark)  
23eb 32 bd fb			ld (debug_mark),a  
23ee 3a fd 23			ld a, (.dmark+1)  
23f1 32 be fb			ld (debug_mark+1),a  
23f4 3a fe 23			ld a, (.dmark+2)  
23f7 32 bf fb			ld (debug_mark+2),a  
23fa 18 03			jr .pastdmark  
23fc ..			.dmark: db ":0A"  
23ff f1			.pastdmark: pop af  
2400			endm  
# End of macro DMARK
2400				CALLMONITOR 
2400 cd ea 15			call break_point_state  
2403				endm  
# End of macro CALLMONITOR
2403 c1				pop bc 
2404			endif 
2404			if DEBUG_FORTH_UWORD 
2404 c5				push bc 
2405 ed 4b a1 ef		ld bc, (os_new_malloc) 
2409 03				inc bc 
240a 03				inc bc 
240b 03				inc bc 
240c 03				inc bc 
240d 03				inc bc 
240e 03				inc bc 
240f 03				inc bc 
2410 03				inc bc 
2411			 
2411						DMARK ":0B" 
2411 f5				push af  
2412 3a 26 24			ld a, (.dmark)  
2415 32 bd fb			ld (debug_mark),a  
2418 3a 27 24			ld a, (.dmark+1)  
241b 32 be fb			ld (debug_mark+1),a  
241e 3a 28 24			ld a, (.dmark+2)  
2421 32 bf fb			ld (debug_mark+2),a  
2424 18 03			jr .pastdmark  
2426 ..			.dmark: db ":0B"  
2429 f1			.pastdmark: pop af  
242a			endm  
# End of macro DMARK
242a				CALLMONITOR 
242a cd ea 15			call break_point_state  
242d				endm  
# End of macro CALLMONITOR
242d c1				pop bc 
242e			endif 
242e			 
242e			; update word dict linked list for new word 
242e			 
242e			 
242e 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2431 23			inc hl     ; move to next work linked list ptr 
2432			 
2432 ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
2436 73			ld (hl), e 
2437 23			inc hl 
2438 72			ld (hl), d 
2439			 
2439			if DEBUG_FORTH_UWORD 
2439 ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
243d			endif 
243d			 
243d ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
2441			 
2441			 
2441			if DEBUG_FORTH_UWORD 
2441						DMARK ":0+" 
2441 f5				push af  
2442 3a 56 24			ld a, (.dmark)  
2445 32 bd fb			ld (debug_mark),a  
2448 3a 57 24			ld a, (.dmark+1)  
244b 32 be fb			ld (debug_mark+1),a  
244e 3a 58 24			ld a, (.dmark+2)  
2451 32 bf fb			ld (debug_mark+2),a  
2454 18 03			jr .pastdmark  
2456 ..			.dmark: db ":0+"  
2459 f1			.pastdmark: pop af  
245a			endm  
# End of macro DMARK
245a				CALLMONITOR 
245a cd ea 15			call break_point_state  
245d				endm  
# End of macro CALLMONITOR
245d			endif 
245d			 
245d				STACKFRAMECHK OFF $8efe $989f 
245d				if DEBUG_STACK_IMB 
245d					if OFF 
245d						exx 
245d						ld hl, $989f 
245d						pop de   ; $989f 
245d						call cmp16 
245d						jr nz, .spnosame 
245d						ld hl, $8efe 
245d						pop de   ; $8efe 
245d						call cmp16 
245d						jr z, .spfrsame 
245d						.spnosame: call showsperror 
245d						.spfrsame: nop 
245d						exx 
245d					endif 
245d				endif 
245d			endm 
# End of macro STACKFRAMECHK
245d			 
245d c9			ret    ; dont process any remaining parser tokens as they form new word 
245e			 
245e			 
245e			 
245e			 
245e			;		NEXT 
245e			.SCOLN: 
245e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
245e 06				db OPCODE_SCOLN 
245f aa 24			dw .DROP 
2461 02				db 2 
2462 .. 00			db ";",0           
2464			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2464					if DEBUG_FORTH_WORDS_KEY 
2464						DMARK "SCN" 
2464 f5				push af  
2465 3a 79 24			ld a, (.dmark)  
2468 32 bd fb			ld (debug_mark),a  
246b 3a 7a 24			ld a, (.dmark+1)  
246e 32 be fb			ld (debug_mark+1),a  
2471 3a 7b 24			ld a, (.dmark+2)  
2474 32 bf fb			ld (debug_mark+2),a  
2477 18 03			jr .pastdmark  
2479 ..			.dmark: db "SCN"  
247c f1			.pastdmark: pop af  
247d			endm  
# End of macro DMARK
247d						CALLMONITOR 
247d cd ea 15			call break_point_state  
2480				endm  
# End of macro CALLMONITOR
2480					endif 
2480					FORTH_RSP_TOS 
2480 cd 35 1b			call macro_forth_rsp_tos 
2483				endm 
# End of macro FORTH_RSP_TOS
2483 e5					push hl 
2484					FORTH_RSP_POP 
2484 cd 3f 1b			call macro_forth_rsp_pop 
2487				endm 
# End of macro FORTH_RSP_POP
2487 e1					pop hl 
2488			;		ex de,hl 
2488 22 a4 f2				ld (os_tok_ptr),hl 
248b			 
248b			if DEBUG_FORTH_UWORD 
248b						DMARK "SCL" 
248b f5				push af  
248c 3a a0 24			ld a, (.dmark)  
248f 32 bd fb			ld (debug_mark),a  
2492 3a a1 24			ld a, (.dmark+1)  
2495 32 be fb			ld (debug_mark+1),a  
2498 3a a2 24			ld a, (.dmark+2)  
249b 32 bf fb			ld (debug_mark+2),a  
249e 18 03			jr .pastdmark  
24a0 ..			.dmark: db "SCL"  
24a3 f1			.pastdmark: pop af  
24a4			endm  
# End of macro DMARK
24a4				CALLMONITOR 
24a4 cd ea 15			call break_point_state  
24a7				endm  
# End of macro CALLMONITOR
24a7			endif 
24a7					NEXTW 
24a7 c3 e0 1e			jp macro_next 
24aa				endm 
# End of macro NEXTW
24aa			 
24aa			.DROP: 
24aa				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24aa 1b				db WORD_SYS_CORE+OPCODE_DROP             
24ab d5 24			dw .DUP2            
24ad 05				db 4 + 1 
24ae .. 00			db "DROP",0              
24b3				endm 
# End of macro CWHEAD
24b3			; | DROP ( w -- )   drop the TOS item   | DONE 
24b3					if DEBUG_FORTH_WORDS_KEY 
24b3						DMARK "DRP" 
24b3 f5				push af  
24b4 3a c8 24			ld a, (.dmark)  
24b7 32 bd fb			ld (debug_mark),a  
24ba 3a c9 24			ld a, (.dmark+1)  
24bd 32 be fb			ld (debug_mark+1),a  
24c0 3a ca 24			ld a, (.dmark+2)  
24c3 32 bf fb			ld (debug_mark+2),a  
24c6 18 03			jr .pastdmark  
24c8 ..			.dmark: db "DRP"  
24cb f1			.pastdmark: pop af  
24cc			endm  
# End of macro DMARK
24cc						CALLMONITOR 
24cc cd ea 15			call break_point_state  
24cf				endm  
# End of macro CALLMONITOR
24cf					endif 
24cf					FORTH_DSP_POP 
24cf cd 26 1e			call macro_forth_dsp_pop 
24d2				endm 
# End of macro FORTH_DSP_POP
24d2					NEXTW 
24d2 c3 e0 1e			jp macro_next 
24d5				endm 
# End of macro NEXTW
24d5			.DUP2: 
24d5				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24d5 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24d6 1a 25			dw .DROP2            
24d8 05				db 4 + 1 
24d9 .. 00			db "2DUP",0              
24de				endm 
# End of macro CWHEAD
24de			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24de					if DEBUG_FORTH_WORDS_KEY 
24de						DMARK "2DU" 
24de f5				push af  
24df 3a f3 24			ld a, (.dmark)  
24e2 32 bd fb			ld (debug_mark),a  
24e5 3a f4 24			ld a, (.dmark+1)  
24e8 32 be fb			ld (debug_mark+1),a  
24eb 3a f5 24			ld a, (.dmark+2)  
24ee 32 bf fb			ld (debug_mark+2),a  
24f1 18 03			jr .pastdmark  
24f3 ..			.dmark: db "2DU"  
24f6 f1			.pastdmark: pop af  
24f7			endm  
# End of macro DMARK
24f7						CALLMONITOR 
24f7 cd ea 15			call break_point_state  
24fa				endm  
# End of macro CALLMONITOR
24fa					endif 
24fa					FORTH_DSP_VALUEHL 
24fa cd 6e 1d			call macro_dsp_valuehl 
24fd				endm 
# End of macro FORTH_DSP_VALUEHL
24fd e5					push hl      ; 2 
24fe			 
24fe					FORTH_DSP_POP 
24fe cd 26 1e			call macro_forth_dsp_pop 
2501				endm 
# End of macro FORTH_DSP_POP
2501					 
2501					FORTH_DSP_VALUEHL 
2501 cd 6e 1d			call macro_dsp_valuehl 
2504				endm 
# End of macro FORTH_DSP_VALUEHL
2504			;		push hl      ; 1 
2504			 
2504					FORTH_DSP_POP 
2504 cd 26 1e			call macro_forth_dsp_pop 
2507				endm 
# End of macro FORTH_DSP_POP
2507			 
2507			;		pop hl       ; 1 
2507 d1					pop de       ; 2 
2508			 
2508 cd 77 1b				call forth_push_numhl 
250b eb					ex de, hl 
250c cd 77 1b				call forth_push_numhl 
250f			 
250f					 
250f eb					ex de, hl 
2510			 
2510 cd 77 1b				call forth_push_numhl 
2513 eb					ex de, hl 
2514 cd 77 1b				call forth_push_numhl 
2517			 
2517			 
2517					NEXTW 
2517 c3 e0 1e			jp macro_next 
251a				endm 
# End of macro NEXTW
251a			.DROP2: 
251a				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
251a 1d				db WORD_SYS_CORE+OPCODE_DROP2             
251b 49 25			dw .SWAP2            
251d 06				db 5 + 1 
251e .. 00			db "2DROP",0              
2524				endm 
# End of macro CWHEAD
2524			; | 2DROP ( w w -- )    Double drop | DONE 
2524					if DEBUG_FORTH_WORDS_KEY 
2524						DMARK "2DR" 
2524 f5				push af  
2525 3a 39 25			ld a, (.dmark)  
2528 32 bd fb			ld (debug_mark),a  
252b 3a 3a 25			ld a, (.dmark+1)  
252e 32 be fb			ld (debug_mark+1),a  
2531 3a 3b 25			ld a, (.dmark+2)  
2534 32 bf fb			ld (debug_mark+2),a  
2537 18 03			jr .pastdmark  
2539 ..			.dmark: db "2DR"  
253c f1			.pastdmark: pop af  
253d			endm  
# End of macro DMARK
253d						CALLMONITOR 
253d cd ea 15			call break_point_state  
2540				endm  
# End of macro CALLMONITOR
2540					endif 
2540					FORTH_DSP_POP 
2540 cd 26 1e			call macro_forth_dsp_pop 
2543				endm 
# End of macro FORTH_DSP_POP
2543					FORTH_DSP_POP 
2543 cd 26 1e			call macro_forth_dsp_pop 
2546				endm 
# End of macro FORTH_DSP_POP
2546					NEXTW 
2546 c3 e0 1e			jp macro_next 
2549				endm 
# End of macro NEXTW
2549			.SWAP2: 
2549				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2549 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
254a 72 25			dw .AT            
254c 06				db 5 + 1 
254d .. 00			db "2SWAP",0              
2553				endm 
# End of macro CWHEAD
2553			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2553					if DEBUG_FORTH_WORDS_KEY 
2553						DMARK "2SW" 
2553 f5				push af  
2554 3a 68 25			ld a, (.dmark)  
2557 32 bd fb			ld (debug_mark),a  
255a 3a 69 25			ld a, (.dmark+1)  
255d 32 be fb			ld (debug_mark+1),a  
2560 3a 6a 25			ld a, (.dmark+2)  
2563 32 bf fb			ld (debug_mark+2),a  
2566 18 03			jr .pastdmark  
2568 ..			.dmark: db "2SW"  
256b f1			.pastdmark: pop af  
256c			endm  
# End of macro DMARK
256c						CALLMONITOR 
256c cd ea 15			call break_point_state  
256f				endm  
# End of macro CALLMONITOR
256f					endif 
256f					NEXTW 
256f c3 e0 1e			jp macro_next 
2572				endm 
# End of macro NEXTW
2572			.AT: 
2572				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2572 1f				db WORD_SYS_CORE+OPCODE_AT             
2573 a4 25			dw .CAT            
2575 02				db 1 + 1 
2576 .. 00			db "@",0              
2578				endm 
# End of macro CWHEAD
2578			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2578			 
2578					if DEBUG_FORTH_WORDS_KEY 
2578						DMARK "AT." 
2578 f5				push af  
2579 3a 8d 25			ld a, (.dmark)  
257c 32 bd fb			ld (debug_mark),a  
257f 3a 8e 25			ld a, (.dmark+1)  
2582 32 be fb			ld (debug_mark+1),a  
2585 3a 8f 25			ld a, (.dmark+2)  
2588 32 bf fb			ld (debug_mark+2),a  
258b 18 03			jr .pastdmark  
258d ..			.dmark: db "AT."  
2590 f1			.pastdmark: pop af  
2591			endm  
# End of macro DMARK
2591						CALLMONITOR 
2591 cd ea 15			call break_point_state  
2594				endm  
# End of macro CALLMONITOR
2594					endif 
2594			.getbyteat:	 
2594					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2594 cd 6e 1d			call macro_dsp_valuehl 
2597				endm 
# End of macro FORTH_DSP_VALUEHL
2597					 
2597			;		push hl 
2597				 
2597					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2597 cd 26 1e			call macro_forth_dsp_pop 
259a				endm 
# End of macro FORTH_DSP_POP
259a			 
259a			;		pop hl 
259a			 
259a 7e					ld a, (hl) 
259b			 
259b 6f					ld l, a 
259c 26 00				ld h, 0 
259e cd 77 1b				call forth_push_numhl 
25a1			 
25a1					NEXTW 
25a1 c3 e0 1e			jp macro_next 
25a4				endm 
# End of macro NEXTW
25a4			.CAT: 
25a4				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25a4 20				db WORD_SYS_CORE+OPCODE_CAT             
25a5 cd 25			dw .BANG            
25a7 03				db 2 + 1 
25a8 .. 00			db "C@",0              
25ab				endm 
# End of macro CWHEAD
25ab			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25ab					if DEBUG_FORTH_WORDS_KEY 
25ab						DMARK "CAA" 
25ab f5				push af  
25ac 3a c0 25			ld a, (.dmark)  
25af 32 bd fb			ld (debug_mark),a  
25b2 3a c1 25			ld a, (.dmark+1)  
25b5 32 be fb			ld (debug_mark+1),a  
25b8 3a c2 25			ld a, (.dmark+2)  
25bb 32 bf fb			ld (debug_mark+2),a  
25be 18 03			jr .pastdmark  
25c0 ..			.dmark: db "CAA"  
25c3 f1			.pastdmark: pop af  
25c4			endm  
# End of macro DMARK
25c4						CALLMONITOR 
25c4 cd ea 15			call break_point_state  
25c7				endm  
# End of macro CALLMONITOR
25c7					endif 
25c7 c3 94 25				jp .getbyteat 
25ca					NEXTW 
25ca c3 e0 1e			jp macro_next 
25cd				endm 
# End of macro NEXTW
25cd			.BANG: 
25cd				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25cd 21				db WORD_SYS_CORE+OPCODE_BANG             
25ce 03 26			dw .CBANG            
25d0 02				db 1 + 1 
25d1 .. 00			db "!",0              
25d3				endm 
# End of macro CWHEAD
25d3			; | ! ( x w -- ) Store x at address w      | DONE 
25d3					if DEBUG_FORTH_WORDS_KEY 
25d3						DMARK "BNG" 
25d3 f5				push af  
25d4 3a e8 25			ld a, (.dmark)  
25d7 32 bd fb			ld (debug_mark),a  
25da 3a e9 25			ld a, (.dmark+1)  
25dd 32 be fb			ld (debug_mark+1),a  
25e0 3a ea 25			ld a, (.dmark+2)  
25e3 32 bf fb			ld (debug_mark+2),a  
25e6 18 03			jr .pastdmark  
25e8 ..			.dmark: db "BNG"  
25eb f1			.pastdmark: pop af  
25ec			endm  
# End of macro DMARK
25ec						CALLMONITOR 
25ec cd ea 15			call break_point_state  
25ef				endm  
# End of macro CALLMONITOR
25ef					endif 
25ef			 
25ef			.storebyteat:		 
25ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ef cd 6e 1d			call macro_dsp_valuehl 
25f2				endm 
# End of macro FORTH_DSP_VALUEHL
25f2					 
25f2 e5					push hl 
25f3				 
25f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f3 cd 26 1e			call macro_forth_dsp_pop 
25f6				endm 
# End of macro FORTH_DSP_POP
25f6			 
25f6					; get byte to poke 
25f6			 
25f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f6 cd 6e 1d			call macro_dsp_valuehl 
25f9				endm 
# End of macro FORTH_DSP_VALUEHL
25f9 e5					push hl 
25fa			 
25fa			 
25fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25fa cd 26 1e			call macro_forth_dsp_pop 
25fd				endm 
# End of macro FORTH_DSP_POP
25fd			 
25fd			 
25fd d1					pop de 
25fe e1					pop hl 
25ff			 
25ff 73					ld (hl),e 
2600			 
2600			 
2600					NEXTW 
2600 c3 e0 1e			jp macro_next 
2603				endm 
# End of macro NEXTW
2603			.CBANG: 
2603				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2603 22				db WORD_SYS_CORE+OPCODE_CBANG             
2604 2c 26			dw .SCALL            
2606 03				db 2 + 1 
2607 .. 00			db "C!",0              
260a				endm 
# End of macro CWHEAD
260a			; | C!  ( x w -- ) Store x at address w  | DONE 
260a					if DEBUG_FORTH_WORDS_KEY 
260a						DMARK "CBA" 
260a f5				push af  
260b 3a 1f 26			ld a, (.dmark)  
260e 32 bd fb			ld (debug_mark),a  
2611 3a 20 26			ld a, (.dmark+1)  
2614 32 be fb			ld (debug_mark+1),a  
2617 3a 21 26			ld a, (.dmark+2)  
261a 32 bf fb			ld (debug_mark+2),a  
261d 18 03			jr .pastdmark  
261f ..			.dmark: db "CBA"  
2622 f1			.pastdmark: pop af  
2623			endm  
# End of macro DMARK
2623						CALLMONITOR 
2623 cd ea 15			call break_point_state  
2626				endm  
# End of macro CALLMONITOR
2626					endif 
2626 c3 ef 25				jp .storebyteat 
2629					NEXTW 
2629 c3 e0 1e			jp macro_next 
262c				endm 
# End of macro NEXTW
262c			.SCALL: 
262c				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
262c 23				db WORD_SYS_CORE+OPCODE_SCALL             
262d 60 26			dw .DEPTH            
262f 05				db 4 + 1 
2630 .. 00			db "CALL",0              
2635				endm 
# End of macro CWHEAD
2635			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2635					if DEBUG_FORTH_WORDS_KEY 
2635						DMARK "CLL" 
2635 f5				push af  
2636 3a 4a 26			ld a, (.dmark)  
2639 32 bd fb			ld (debug_mark),a  
263c 3a 4b 26			ld a, (.dmark+1)  
263f 32 be fb			ld (debug_mark+1),a  
2642 3a 4c 26			ld a, (.dmark+2)  
2645 32 bf fb			ld (debug_mark+2),a  
2648 18 03			jr .pastdmark  
264a ..			.dmark: db "CLL"  
264d f1			.pastdmark: pop af  
264e			endm  
# End of macro DMARK
264e						CALLMONITOR 
264e cd ea 15			call break_point_state  
2651				endm  
# End of macro CALLMONITOR
2651					endif 
2651			 
2651					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2651 cd 6e 1d			call macro_dsp_valuehl 
2654				endm 
# End of macro FORTH_DSP_VALUEHL
2654			 
2654			;		push hl 
2654			 
2654					; destroy value TOS 
2654			 
2654					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2654 cd 26 1e			call macro_forth_dsp_pop 
2657				endm 
# End of macro FORTH_DSP_POP
2657			 
2657						 
2657			;		pop hl 
2657			 
2657					; how to do a call with hl???? save SP? 
2657 cd 89 1e				call forth_call_hl 
265a			 
265a			 
265a					; TODO push value back onto stack for another op etc 
265a			 
265a cd 77 1b				call forth_push_numhl 
265d					NEXTW 
265d c3 e0 1e			jp macro_next 
2660				endm 
# End of macro NEXTW
2660			.DEPTH: 
2660				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2660 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2661 9d 26			dw .OVER            
2663 06				db 5 + 1 
2664 .. 00			db "DEPTH",0              
266a				endm 
# End of macro CWHEAD
266a			; | DEPTH ( -- u ) Push count of stack | DONE 
266a					; take current TOS and remove from base value div by two to get count 
266a					if DEBUG_FORTH_WORDS_KEY 
266a						DMARK "DEP" 
266a f5				push af  
266b 3a 7f 26			ld a, (.dmark)  
266e 32 bd fb			ld (debug_mark),a  
2671 3a 80 26			ld a, (.dmark+1)  
2674 32 be fb			ld (debug_mark+1),a  
2677 3a 81 26			ld a, (.dmark+2)  
267a 32 bf fb			ld (debug_mark+2),a  
267d 18 03			jr .pastdmark  
267f ..			.dmark: db "DEP"  
2682 f1			.pastdmark: pop af  
2683			endm  
# End of macro DMARK
2683						CALLMONITOR 
2683 cd ea 15			call break_point_state  
2686				endm  
# End of macro CALLMONITOR
2686					endif 
2686			 
2686			 
2686 2a 90 f9			ld hl, (cli_data_sp) 
2689 11 0a f5			ld de, cli_data_stack 
268c ed 52			sbc hl,de 
268e				 
268e				; div by size of stack item 
268e			 
268e 5d				ld e,l 
268f 0e 03			ld c, 3 
2691 cd 58 0c			call Div8 
2694			 
2694 6f				ld l,a 
2695 26 00			ld h,0 
2697			 
2697				;srl h 
2697				;rr l 
2697			 
2697 cd 77 1b				call forth_push_numhl 
269a					NEXTW 
269a c3 e0 1e			jp macro_next 
269d				endm 
# End of macro NEXTW
269d			.OVER: 
269d				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
269d 42				db WORD_SYS_CORE+46             
269e e4 26			dw .PAUSE            
26a0 05				db 4 + 1 
26a1 .. 00			db "OVER",0              
26a6				endm 
# End of macro CWHEAD
26a6			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26a6					if DEBUG_FORTH_WORDS_KEY 
26a6						DMARK "OVR" 
26a6 f5				push af  
26a7 3a bb 26			ld a, (.dmark)  
26aa 32 bd fb			ld (debug_mark),a  
26ad 3a bc 26			ld a, (.dmark+1)  
26b0 32 be fb			ld (debug_mark+1),a  
26b3 3a bd 26			ld a, (.dmark+2)  
26b6 32 bf fb			ld (debug_mark+2),a  
26b9 18 03			jr .pastdmark  
26bb ..			.dmark: db "OVR"  
26be f1			.pastdmark: pop af  
26bf			endm  
# End of macro DMARK
26bf						CALLMONITOR 
26bf cd ea 15			call break_point_state  
26c2				endm  
# End of macro CALLMONITOR
26c2					endif 
26c2			 
26c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c2 cd 6e 1d			call macro_dsp_valuehl 
26c5				endm 
# End of macro FORTH_DSP_VALUEHL
26c5 e5					push hl    ; n2 
26c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c6 cd 26 1e			call macro_forth_dsp_pop 
26c9				endm 
# End of macro FORTH_DSP_POP
26c9			 
26c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c9 cd 6e 1d			call macro_dsp_valuehl 
26cc				endm 
# End of macro FORTH_DSP_VALUEHL
26cc e5					push hl    ; n1 
26cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26cd cd 26 1e			call macro_forth_dsp_pop 
26d0				endm 
# End of macro FORTH_DSP_POP
26d0			 
26d0 d1					pop de     ; n1 
26d1 e1					pop hl     ; n2 
26d2			 
26d2 d5					push de 
26d3 e5					push hl 
26d4 d5					push de 
26d5			 
26d5					; push back  
26d5			 
26d5 e1					pop hl 
26d6 cd 77 1b				call forth_push_numhl 
26d9 e1					pop hl 
26da cd 77 1b				call forth_push_numhl 
26dd e1					pop hl 
26de cd 77 1b				call forth_push_numhl 
26e1					NEXTW 
26e1 c3 e0 1e			jp macro_next 
26e4				endm 
# End of macro NEXTW
26e4			 
26e4			.PAUSE: 
26e4				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26e4 43				db WORD_SYS_CORE+47             
26e5 19 27			dw .PAUSES            
26e7 08				db 7 + 1 
26e8 .. 00			db "PAUSEMS",0              
26f0				endm 
# End of macro CWHEAD
26f0			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26f0					if DEBUG_FORTH_WORDS_KEY 
26f0						DMARK "PMS" 
26f0 f5				push af  
26f1 3a 05 27			ld a, (.dmark)  
26f4 32 bd fb			ld (debug_mark),a  
26f7 3a 06 27			ld a, (.dmark+1)  
26fa 32 be fb			ld (debug_mark+1),a  
26fd 3a 07 27			ld a, (.dmark+2)  
2700 32 bf fb			ld (debug_mark+2),a  
2703 18 03			jr .pastdmark  
2705 ..			.dmark: db "PMS"  
2708 f1			.pastdmark: pop af  
2709			endm  
# End of macro DMARK
2709						CALLMONITOR 
2709 cd ea 15			call break_point_state  
270c				endm  
# End of macro CALLMONITOR
270c					endif 
270c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
270c cd 6e 1d			call macro_dsp_valuehl 
270f				endm 
# End of macro FORTH_DSP_VALUEHL
270f			;		push hl    ; n2 
270f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
270f cd 26 1e			call macro_forth_dsp_pop 
2712				endm 
# End of macro FORTH_DSP_POP
2712			;		pop hl 
2712			 
2712 7d					ld a, l 
2713 cd 27 0a				call aDelayInMS 
2716				       NEXTW 
2716 c3 e0 1e			jp macro_next 
2719				endm 
# End of macro NEXTW
2719			.PAUSES:  
2719				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2719 44				db WORD_SYS_CORE+48             
271a 88 27			dw .ROT            
271c 06				db 5 + 1 
271d .. 00			db "PAUSE",0              
2723				endm 
# End of macro CWHEAD
2723			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2723					if DEBUG_FORTH_WORDS_KEY 
2723						DMARK "PAU" 
2723 f5				push af  
2724 3a 38 27			ld a, (.dmark)  
2727 32 bd fb			ld (debug_mark),a  
272a 3a 39 27			ld a, (.dmark+1)  
272d 32 be fb			ld (debug_mark+1),a  
2730 3a 3a 27			ld a, (.dmark+2)  
2733 32 bf fb			ld (debug_mark+2),a  
2736 18 03			jr .pastdmark  
2738 ..			.dmark: db "PAU"  
273b f1			.pastdmark: pop af  
273c			endm  
# End of macro DMARK
273c						CALLMONITOR 
273c cd ea 15			call break_point_state  
273f				endm  
# End of macro CALLMONITOR
273f					endif 
273f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
273f cd 6e 1d			call macro_dsp_valuehl 
2742				endm 
# End of macro FORTH_DSP_VALUEHL
2742			;		push hl    ; n2 
2742					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2742 cd 26 1e			call macro_forth_dsp_pop 
2745				endm 
# End of macro FORTH_DSP_POP
2745			;		pop hl 
2745 45					ld b, l 
2746					if DEBUG_FORTH_WORDS 
2746						DMARK "PAU" 
2746 f5				push af  
2747 3a 5b 27			ld a, (.dmark)  
274a 32 bd fb			ld (debug_mark),a  
274d 3a 5c 27			ld a, (.dmark+1)  
2750 32 be fb			ld (debug_mark+1),a  
2753 3a 5d 27			ld a, (.dmark+2)  
2756 32 bf fb			ld (debug_mark+2),a  
2759 18 03			jr .pastdmark  
275b ..			.dmark: db "PAU"  
275e f1			.pastdmark: pop af  
275f			endm  
# End of macro DMARK
275f						CALLMONITOR 
275f cd ea 15			call break_point_state  
2762				endm  
# End of macro CALLMONITOR
2762					endif 
2762 c5			.pauses1:	push bc 
2763 cd 42 0a				call delay1s 
2766 c1					pop bc 
2767					if DEBUG_FORTH_WORDS 
2767						DMARK "PA1" 
2767 f5				push af  
2768 3a 7c 27			ld a, (.dmark)  
276b 32 bd fb			ld (debug_mark),a  
276e 3a 7d 27			ld a, (.dmark+1)  
2771 32 be fb			ld (debug_mark+1),a  
2774 3a 7e 27			ld a, (.dmark+2)  
2777 32 bf fb			ld (debug_mark+2),a  
277a 18 03			jr .pastdmark  
277c ..			.dmark: db "PA1"  
277f f1			.pastdmark: pop af  
2780			endm  
# End of macro DMARK
2780						CALLMONITOR 
2780 cd ea 15			call break_point_state  
2783				endm  
# End of macro CALLMONITOR
2783					endif 
2783 10 dd				djnz .pauses1 
2785			 
2785				       NEXTW 
2785 c3 e0 1e			jp macro_next 
2788				endm 
# End of macro NEXTW
2788			.ROT: 
2788				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2788 45				db WORD_SYS_CORE+49             
2789 d6 27			dw .UWORDS            
278b 04				db 3 + 1 
278c .. 00			db "ROT",0              
2790				endm 
# End of macro CWHEAD
2790			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2790					if DEBUG_FORTH_WORDS_KEY 
2790						DMARK "ROT" 
2790 f5				push af  
2791 3a a5 27			ld a, (.dmark)  
2794 32 bd fb			ld (debug_mark),a  
2797 3a a6 27			ld a, (.dmark+1)  
279a 32 be fb			ld (debug_mark+1),a  
279d 3a a7 27			ld a, (.dmark+2)  
27a0 32 bf fb			ld (debug_mark+2),a  
27a3 18 03			jr .pastdmark  
27a5 ..			.dmark: db "ROT"  
27a8 f1			.pastdmark: pop af  
27a9			endm  
# End of macro DMARK
27a9						CALLMONITOR 
27a9 cd ea 15			call break_point_state  
27ac				endm  
# End of macro CALLMONITOR
27ac					endif 
27ac			 
27ac					FORTH_DSP_VALUEHL 
27ac cd 6e 1d			call macro_dsp_valuehl 
27af				endm 
# End of macro FORTH_DSP_VALUEHL
27af e5					push hl    ; u3  
27b0			 
27b0					FORTH_DSP_POP 
27b0 cd 26 1e			call macro_forth_dsp_pop 
27b3				endm 
# End of macro FORTH_DSP_POP
27b3			   
27b3					FORTH_DSP_VALUEHL 
27b3 cd 6e 1d			call macro_dsp_valuehl 
27b6				endm 
# End of macro FORTH_DSP_VALUEHL
27b6 e5					push hl     ; u2 
27b7			 
27b7					FORTH_DSP_POP 
27b7 cd 26 1e			call macro_forth_dsp_pop 
27ba				endm 
# End of macro FORTH_DSP_POP
27ba			 
27ba					FORTH_DSP_VALUEHL 
27ba cd 6e 1d			call macro_dsp_valuehl 
27bd				endm 
# End of macro FORTH_DSP_VALUEHL
27bd e5					push hl     ; u1 
27be			 
27be					FORTH_DSP_POP 
27be cd 26 1e			call macro_forth_dsp_pop 
27c1				endm 
# End of macro FORTH_DSP_POP
27c1			 
27c1 c1					pop bc      ; u1 
27c2 e1					pop hl      ; u2 
27c3 d1					pop de      ; u3 
27c4			 
27c4			 
27c4 c5					push bc 
27c5 d5					push de 
27c6 e5					push hl 
27c7			 
27c7			 
27c7 e1					pop hl 
27c8 cd 77 1b				call forth_push_numhl 
27cb			 
27cb e1					pop hl 
27cc cd 77 1b				call forth_push_numhl 
27cf			 
27cf e1					pop hl 
27d0 cd 77 1b				call forth_push_numhl 
27d3					 
27d3			 
27d3			 
27d3			 
27d3			 
27d3			 
27d3				       NEXTW 
27d3 c3 e0 1e			jp macro_next 
27d6				endm 
# End of macro NEXTW
27d6			 
27d6			.UWORDS: 
27d6				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27d6 50				db WORD_SYS_CORE+60             
27d7 98 28			dw .BP            
27d9 07				db 6 + 1 
27da .. 00			db "UWORDS",0              
27e1				endm 
# End of macro CWHEAD
27e1			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27e1			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27e1			; | | Following the count are the individual words. 
27e1			; | | 
27e1			; | | e.g. UWORDS 
27e1			; | | BOX DIRLIST 2 
27e1			; | |  
27e1			; | | Can be used to save the words to storage via: 
27e1			; | | UWORDS $01 DO $01 APPEND LOOP 
27e1				if DEBUG_FORTH_WORDS_KEY 
27e1					DMARK "UWR" 
27e1 f5				push af  
27e2 3a f6 27			ld a, (.dmark)  
27e5 32 bd fb			ld (debug_mark),a  
27e8 3a f7 27			ld a, (.dmark+1)  
27eb 32 be fb			ld (debug_mark+1),a  
27ee 3a f8 27			ld a, (.dmark+2)  
27f1 32 bf fb			ld (debug_mark+2),a  
27f4 18 03			jr .pastdmark  
27f6 ..			.dmark: db "UWR"  
27f9 f1			.pastdmark: pop af  
27fa			endm  
# End of macro DMARK
27fa					CALLMONITOR 
27fa cd ea 15			call break_point_state  
27fd				endm  
# End of macro CALLMONITOR
27fd				endif 
27fd 21 00 80				ld hl, baseram 
2800					;ld hl, baseusermem 
2800 01 00 00				ld bc, 0    ; start a counter 
2803			 
2803				; skip dict stub 
2803			 
2803 cd 31 20				call forth_tok_next 
2806			 
2806			 
2806			; while we have words to look for 
2806			 
2806 7e			.douscan:	ld a, (hl)      
2807				if DEBUG_FORTH_WORDS 
2807					DMARK "UWs" 
2807 f5				push af  
2808 3a 1c 28			ld a, (.dmark)  
280b 32 bd fb			ld (debug_mark),a  
280e 3a 1d 28			ld a, (.dmark+1)  
2811 32 be fb			ld (debug_mark+1),a  
2814 3a 1e 28			ld a, (.dmark+2)  
2817 32 bf fb			ld (debug_mark+2),a  
281a 18 03			jr .pastdmark  
281c ..			.dmark: db "UWs"  
281f f1			.pastdmark: pop af  
2820			endm  
# End of macro DMARK
2820					CALLMONITOR 
2820 cd ea 15			call break_point_state  
2823				endm  
# End of macro CALLMONITOR
2823				endif 
2823 fe 00				cp WORD_SYS_END 
2825 28 4d				jr z, .udone 
2827 fe 01				cp WORD_SYS_UWORD 
2829 20 44				jr nz, .nuword 
282b			 
282b				if DEBUG_FORTH_WORDS 
282b					DMARK "UWu" 
282b f5				push af  
282c 3a 40 28			ld a, (.dmark)  
282f 32 bd fb			ld (debug_mark),a  
2832 3a 41 28			ld a, (.dmark+1)  
2835 32 be fb			ld (debug_mark+1),a  
2838 3a 42 28			ld a, (.dmark+2)  
283b 32 bf fb			ld (debug_mark+2),a  
283e 18 03			jr .pastdmark  
2840 ..			.dmark: db "UWu"  
2843 f1			.pastdmark: pop af  
2844			endm  
# End of macro DMARK
2844					CALLMONITOR 
2844 cd ea 15			call break_point_state  
2847				endm  
# End of macro CALLMONITOR
2847				endif 
2847					; we have a uword so push its name to the stack 
2847			 
2847 e5				   	push hl  ; save so we can move to next dict block 
2848			 
2848					; skip opcode 
2848 23					inc hl  
2849					; skip next ptr 
2849 23					inc hl  
284a 23					inc hl 
284b					; skip len 
284b 23					inc hl 
284c				if DEBUG_FORTH_WORDS 
284c					DMARK "UWt" 
284c f5				push af  
284d 3a 61 28			ld a, (.dmark)  
2850 32 bd fb			ld (debug_mark),a  
2853 3a 62 28			ld a, (.dmark+1)  
2856 32 be fb			ld (debug_mark+1),a  
2859 3a 63 28			ld a, (.dmark+2)  
285c 32 bf fb			ld (debug_mark+2),a  
285f 18 03			jr .pastdmark  
2861 ..			.dmark: db "UWt"  
2864 f1			.pastdmark: pop af  
2865			endm  
# End of macro DMARK
2865					CALLMONITOR 
2865 cd ea 15			call break_point_state  
2868				endm  
# End of macro CALLMONITOR
2868				endif 
2868 03					inc bc 
2869			 
2869 c5					push bc 
286a cd e5 1b				call forth_push_str 
286d c1					pop bc 
286e			 
286e e1					pop hl 	 
286f			 
286f cd 31 20		.nuword:	call forth_tok_next 
2872 18 92				jr .douscan  
2874			 
2874			.udone:		 ; push count of uwords found 
2874 c5					push bc 
2875 e1					pop hl 
2876			 
2876				if DEBUG_FORTH_WORDS 
2876					DMARK "UWc" 
2876 f5				push af  
2877 3a 8b 28			ld a, (.dmark)  
287a 32 bd fb			ld (debug_mark),a  
287d 3a 8c 28			ld a, (.dmark+1)  
2880 32 be fb			ld (debug_mark+1),a  
2883 3a 8d 28			ld a, (.dmark+2)  
2886 32 bf fb			ld (debug_mark+2),a  
2889 18 03			jr .pastdmark  
288b ..			.dmark: db "UWc"  
288e f1			.pastdmark: pop af  
288f			endm  
# End of macro DMARK
288f					CALLMONITOR 
288f cd ea 15			call break_point_state  
2892				endm  
# End of macro CALLMONITOR
2892				endif 
2892 cd 77 1b				call forth_push_numhl 
2895			 
2895			 
2895				       NEXTW 
2895 c3 e0 1e			jp macro_next 
2898				endm 
# End of macro NEXTW
2898			 
2898			.BP: 
2898				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2898 54				db WORD_SYS_CORE+64             
2899 ce 28			dw .MONITOR            
289b 03				db 2 + 1 
289c .. 00			db "BP",0              
289f				endm 
# End of macro CWHEAD
289f			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
289f			; | | $00 Will enable the break points within specific code paths 
289f			; | | $01 Will disable break points 
289f			; | |  
289f			; | | By default break points are off. Either the above can be used to enable them 
289f			; | | or if a key is held down during start up the spashscreen will appear to freeze 
289f			; | | and on release of the pressed key a message will be disaplayed to notify 
289f			; | | that break points are enabled. Pressing any key will then continue boot process. 
289f					; get byte count 
289f					if DEBUG_FORTH_WORDS_KEY 
289f						DMARK "BP." 
289f f5				push af  
28a0 3a b4 28			ld a, (.dmark)  
28a3 32 bd fb			ld (debug_mark),a  
28a6 3a b5 28			ld a, (.dmark+1)  
28a9 32 be fb			ld (debug_mark+1),a  
28ac 3a b6 28			ld a, (.dmark+2)  
28af 32 bf fb			ld (debug_mark+2),a  
28b2 18 03			jr .pastdmark  
28b4 ..			.dmark: db "BP."  
28b7 f1			.pastdmark: pop af  
28b8			endm  
# End of macro DMARK
28b8						CALLMONITOR 
28b8 cd ea 15			call break_point_state  
28bb				endm  
# End of macro CALLMONITOR
28bb					endif 
28bb			 
28bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28bb cd 6e 1d			call macro_dsp_valuehl 
28be				endm 
# End of macro FORTH_DSP_VALUEHL
28be			 
28be			;		push hl 
28be			 
28be					; destroy value TOS 
28be			 
28be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28be cd 26 1e			call macro_forth_dsp_pop 
28c1				endm 
# End of macro FORTH_DSP_POP
28c1			 
28c1			;		pop hl 
28c1			 
28c1 3e 00				ld a,0 
28c3 bd					cp l 
28c4 28 02				jr z, .bpset 
28c6 3e 2a				ld a, '*' 
28c8			 
28c8 32 94 ef		.bpset:		ld (os_view_disable), a 
28cb			 
28cb			 
28cb					NEXTW 
28cb c3 e0 1e			jp macro_next 
28ce				endm 
# End of macro NEXTW
28ce			 
28ce			 
28ce			.MONITOR: 
28ce				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28ce 55				db WORD_SYS_CORE+65             
28cf 01 29			dw .MALLOC            
28d1 08				db 7 + 1 
28d2 .. 00			db "MONITOR",0              
28da				endm 
# End of macro CWHEAD
28da			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28da			; | | At start the current various registers will be displayed with contents. 
28da			; | | Top right corner will show the most recent debug marker seen. 
28da			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28da			; | | and the return stack pointer (RSP). 
28da			; | | Pressing: 
28da			; | |    1 - Initial screen 
28da			; | |    2 - Display a data dump of HL 
28da			; | |    3 - Display a data dump of DE 
28da			; | |    4 - Display a data dump of BC 
28da			; | |    5 - Display a data dump of HL 
28da			; | |    6 - Display a data dump of DSP 
28da			; | |    7 - Display a data dump of RSP 
28da			; | |    8 - Display a data dump of what is at DSP 
28da			; | |    9 - Display a data dump of what is at RSP 
28da			; | |    0 - Exit monitor and continue running. This will also enable break points 
28da			; | |    * - Disable break points 
28da			; | |    # - Enter traditional monitor mode 
28da			; | | 
28da			; | | Monitor Mode 
28da			; | | ------------ 
28da			; | | A prompt of '>' will be shown for various commands: 
28da			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28da			; | |    C - Continue display a data dump from the last set address 
28da			; | |    M xxxx - Set start of memory edit at address xx 
28da			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28da			; | |    Q - Return to previous 
28da					if DEBUG_FORTH_WORDS_KEY 
28da						DMARK "MON" 
28da f5				push af  
28db 3a ef 28			ld a, (.dmark)  
28de 32 bd fb			ld (debug_mark),a  
28e1 3a f0 28			ld a, (.dmark+1)  
28e4 32 be fb			ld (debug_mark+1),a  
28e7 3a f1 28			ld a, (.dmark+2)  
28ea 32 bf fb			ld (debug_mark+2),a  
28ed 18 03			jr .pastdmark  
28ef ..			.dmark: db "MON"  
28f2 f1			.pastdmark: pop af  
28f3			endm  
# End of macro DMARK
28f3						CALLMONITOR 
28f3 cd ea 15			call break_point_state  
28f6				endm  
# End of macro CALLMONITOR
28f6					endif 
28f6 3e 00				ld a, 0 
28f8 32 94 ef				ld (os_view_disable), a 
28fb			 
28fb					CALLMONITOR 
28fb cd ea 15			call break_point_state  
28fe				endm  
# End of macro CALLMONITOR
28fe			 
28fe			;	call monitor 
28fe			 
28fe					NEXTW 
28fe c3 e0 1e			jp macro_next 
2901				endm 
# End of macro NEXTW
2901			 
2901			 
2901			.MALLOC: 
2901				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2901 56				db WORD_SYS_CORE+66             
2902 2a 29			dw .MALLOC2            
2904 06				db 5 + 1 
2905 .. 00			db "ALLOT",0              
290b				endm 
# End of macro CWHEAD
290b			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
290b					if DEBUG_FORTH_WORDS_KEY 
290b						DMARK "ALL" 
290b f5				push af  
290c 3a 20 29			ld a, (.dmark)  
290f 32 bd fb			ld (debug_mark),a  
2912 3a 21 29			ld a, (.dmark+1)  
2915 32 be fb			ld (debug_mark+1),a  
2918 3a 22 29			ld a, (.dmark+2)  
291b 32 bf fb			ld (debug_mark+2),a  
291e 18 03			jr .pastdmark  
2920 ..			.dmark: db "ALL"  
2923 f1			.pastdmark: pop af  
2924			endm  
# End of macro DMARK
2924						CALLMONITOR 
2924 cd ea 15			call break_point_state  
2927				endm  
# End of macro CALLMONITOR
2927					endif 
2927 c3 51 29				jp .mallocc 
292a			.MALLOC2: 
292a				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
292a 56				db WORD_SYS_CORE+66             
292b 68 29			dw .FREE            
292d 07				db 6 + 1 
292e .. 00			db "MALLOC",0              
2935				endm 
# End of macro CWHEAD
2935			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2935					; get byte count 
2935					if DEBUG_FORTH_WORDS_KEY 
2935						DMARK "MAL" 
2935 f5				push af  
2936 3a 4a 29			ld a, (.dmark)  
2939 32 bd fb			ld (debug_mark),a  
293c 3a 4b 29			ld a, (.dmark+1)  
293f 32 be fb			ld (debug_mark+1),a  
2942 3a 4c 29			ld a, (.dmark+2)  
2945 32 bf fb			ld (debug_mark+2),a  
2948 18 03			jr .pastdmark  
294a ..			.dmark: db "MAL"  
294d f1			.pastdmark: pop af  
294e			endm  
# End of macro DMARK
294e						CALLMONITOR 
294e cd ea 15			call break_point_state  
2951				endm  
# End of macro CALLMONITOR
2951					endif 
2951			.mallocc: 
2951					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2951 cd 6e 1d			call macro_dsp_valuehl 
2954				endm 
# End of macro FORTH_DSP_VALUEHL
2954			 
2954			;		push hl 
2954			 
2954					; destroy value TOS 
2954			 
2954					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2954 cd 26 1e			call macro_forth_dsp_pop 
2957				endm 
# End of macro FORTH_DSP_POP
2957			 
2957			;		pop hl 
2957 cd 8f 11				call malloc 
295a				if DEBUG_FORTH_MALLOC_GUARD 
295a f5					push af 
295b cd f1 0c				call ishlzero 
295e			;		ld a, l 
295e			;		add h 
295e			;		cp 0 
295e f1					pop af 
295f					 
295f cc 73 51				call z,malloc_error 
2962				endif 
2962			 
2962 cd 77 1b				call forth_push_numhl 
2965					NEXTW 
2965 c3 e0 1e			jp macro_next 
2968				endm 
# End of macro NEXTW
2968			 
2968			.FREE: 
2968				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2968 57				db WORD_SYS_CORE+67             
2969 99 29			dw .LIST            
296b 05				db 4 + 1 
296c .. 00			db "FREE",0              
2971				endm 
# End of macro CWHEAD
2971			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2971					if DEBUG_FORTH_WORDS_KEY 
2971						DMARK "FRE" 
2971 f5				push af  
2972 3a 86 29			ld a, (.dmark)  
2975 32 bd fb			ld (debug_mark),a  
2978 3a 87 29			ld a, (.dmark+1)  
297b 32 be fb			ld (debug_mark+1),a  
297e 3a 88 29			ld a, (.dmark+2)  
2981 32 bf fb			ld (debug_mark+2),a  
2984 18 03			jr .pastdmark  
2986 ..			.dmark: db "FRE"  
2989 f1			.pastdmark: pop af  
298a			endm  
# End of macro DMARK
298a						CALLMONITOR 
298a cd ea 15			call break_point_state  
298d				endm  
# End of macro CALLMONITOR
298d					endif 
298d					; get address 
298d			 
298d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
298d cd 6e 1d			call macro_dsp_valuehl 
2990				endm 
# End of macro FORTH_DSP_VALUEHL
2990			 
2990			;		push hl 
2990			 
2990					; destroy value TOS 
2990			 
2990					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2990 cd 26 1e			call macro_forth_dsp_pop 
2993				endm 
# End of macro FORTH_DSP_POP
2993			 
2993			;		pop hl 
2993			if FORTH_ENABLE_MALLOCFREE 
2993 cd 59 12				call free 
2996			endif 
2996					NEXTW 
2996 c3 e0 1e			jp macro_next 
2999				endm 
# End of macro NEXTW
2999			.LIST: 
2999				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2999 5c				db WORD_SYS_CORE+72             
299a 5c 2b			dw .FORGET            
299c 05				db 4 + 1 
299d .. 00			db "LIST",0              
29a2				endm 
# End of macro CWHEAD
29a2			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
29a2			; | | The quoted word must be in upper case. 
29a2				if DEBUG_FORTH_WORDS_KEY 
29a2					DMARK "LST" 
29a2 f5				push af  
29a3 3a b7 29			ld a, (.dmark)  
29a6 32 bd fb			ld (debug_mark),a  
29a9 3a b8 29			ld a, (.dmark+1)  
29ac 32 be fb			ld (debug_mark+1),a  
29af 3a b9 29			ld a, (.dmark+2)  
29b2 32 bf fb			ld (debug_mark+2),a  
29b5 18 03			jr .pastdmark  
29b7 ..			.dmark: db "LST"  
29ba f1			.pastdmark: pop af  
29bb			endm  
# End of macro DMARK
29bb					CALLMONITOR 
29bb cd ea 15			call break_point_state  
29be				endm  
# End of macro CALLMONITOR
29be				endif 
29be			 
29be					FORTH_DSP_VALUEHL 
29be cd 6e 1d			call macro_dsp_valuehl 
29c1				endm 
# End of macro FORTH_DSP_VALUEHL
29c1			 
29c1 e5					push hl 
29c2 c1					pop bc 
29c3			 
29c3			; Start format of scratch string 
29c3			 
29c3 21 a3 ef				ld hl, scratch 
29c6			 
29c6 3e 3a				ld a, ':' 
29c8 77					ld (hl),a 
29c9 23					inc hl 
29ca 3e 20				ld a, ' ' 
29cc 77					ld (hl), a 
29cd			 
29cd					; Get ptr to the word we need to look up 
29cd			 
29cd			;		FORTH_DSP_VALUEHL 
29cd					;v5 FORTH_DSP_VALUE 
29cd				; TODO type check 
29cd			;		inc hl    ; Skip type check  
29cd			;		push hl 
29cd			;		ex de, hl    ; put into DE 
29cd			 
29cd			 
29cd 21 00 80				ld hl, baseram 
29d0					;ld hl, baseusermem 
29d0			 
29d0 e5			push hl   ; sacreifical push 
29d1			 
29d1			.ldouscanm: 
29d1 e1				pop hl 
29d2			.ldouscan: 
29d2				if DEBUG_FORTH_WORDS 
29d2					DMARK "LSs" 
29d2 f5				push af  
29d3 3a e7 29			ld a, (.dmark)  
29d6 32 bd fb			ld (debug_mark),a  
29d9 3a e8 29			ld a, (.dmark+1)  
29dc 32 be fb			ld (debug_mark+1),a  
29df 3a e9 29			ld a, (.dmark+2)  
29e2 32 bf fb			ld (debug_mark+2),a  
29e5 18 03			jr .pastdmark  
29e7 ..			.dmark: db "LSs"  
29ea f1			.pastdmark: pop af  
29eb			endm  
# End of macro DMARK
29eb					CALLMONITOR 
29eb cd ea 15			call break_point_state  
29ee				endm  
# End of macro CALLMONITOR
29ee				endif 
29ee				; skip dict stub 
29ee cd 31 20				call forth_tok_next 
29f1			 
29f1			 
29f1			; while we have words to look for 
29f1			 
29f1 7e				ld a, (hl)      
29f2				if DEBUG_FORTH_WORDS 
29f2					DMARK "LSk" 
29f2 f5				push af  
29f3 3a 07 2a			ld a, (.dmark)  
29f6 32 bd fb			ld (debug_mark),a  
29f9 3a 08 2a			ld a, (.dmark+1)  
29fc 32 be fb			ld (debug_mark+1),a  
29ff 3a 09 2a			ld a, (.dmark+2)  
2a02 32 bf fb			ld (debug_mark+2),a  
2a05 18 03			jr .pastdmark  
2a07 ..			.dmark: db "LSk"  
2a0a f1			.pastdmark: pop af  
2a0b			endm  
# End of macro DMARK
2a0b					CALLMONITOR 
2a0b cd ea 15			call break_point_state  
2a0e				endm  
# End of macro CALLMONITOR
2a0e				endif 
2a0e fe 00				cp WORD_SYS_END 
2a10 ca 43 2b				jp z, .lunotfound 
2a13 fe 01				cp WORD_SYS_UWORD 
2a15 c2 d2 29				jp nz, .ldouscan 
2a18			 
2a18				if DEBUG_FORTH_WORDS 
2a18					DMARK "LSu" 
2a18 f5				push af  
2a19 3a 2d 2a			ld a, (.dmark)  
2a1c 32 bd fb			ld (debug_mark),a  
2a1f 3a 2e 2a			ld a, (.dmark+1)  
2a22 32 be fb			ld (debug_mark+1),a  
2a25 3a 2f 2a			ld a, (.dmark+2)  
2a28 32 bf fb			ld (debug_mark+2),a  
2a2b 18 03			jr .pastdmark  
2a2d ..			.dmark: db "LSu"  
2a30 f1			.pastdmark: pop af  
2a31			endm  
# End of macro DMARK
2a31					CALLMONITOR 
2a31 cd ea 15			call break_point_state  
2a34				endm  
# End of macro CALLMONITOR
2a34				endif 
2a34			 
2a34					; found a uword but is it the one we want... 
2a34			 
2a34 c5					push bc     ; uword to find is on bc 
2a35 d1					pop de 
2a36			 
2a36 e5					push hl  ; to save the ptr 
2a37			 
2a37					; skip opcode 
2a37 23					inc hl  
2a38					; skip next ptr 
2a38 23					inc hl  
2a39 23					inc hl 
2a3a					; skip len 
2a3a 23					inc hl 
2a3b			 
2a3b				if DEBUG_FORTH_WORDS 
2a3b					DMARK "LSc" 
2a3b f5				push af  
2a3c 3a 50 2a			ld a, (.dmark)  
2a3f 32 bd fb			ld (debug_mark),a  
2a42 3a 51 2a			ld a, (.dmark+1)  
2a45 32 be fb			ld (debug_mark+1),a  
2a48 3a 52 2a			ld a, (.dmark+2)  
2a4b 32 bf fb			ld (debug_mark+2),a  
2a4e 18 03			jr .pastdmark  
2a50 ..			.dmark: db "LSc"  
2a53 f1			.pastdmark: pop af  
2a54			endm  
# End of macro DMARK
2a54					CALLMONITOR 
2a54 cd ea 15			call break_point_state  
2a57				endm  
# End of macro CALLMONITOR
2a57				endif 
2a57 cd 5e 11				call strcmp 
2a5a c2 d1 29				jp nz, .ldouscanm 
2a5d				 
2a5d			 
2a5d			 
2a5d					; we have a uword so push its name to the stack 
2a5d			 
2a5d			;	   	push hl  ; save so we can move to next dict block 
2a5d e1			pop hl 
2a5e			 
2a5e				if DEBUG_FORTH_WORDS 
2a5e					DMARK "LSm" 
2a5e f5				push af  
2a5f 3a 73 2a			ld a, (.dmark)  
2a62 32 bd fb			ld (debug_mark),a  
2a65 3a 74 2a			ld a, (.dmark+1)  
2a68 32 be fb			ld (debug_mark+1),a  
2a6b 3a 75 2a			ld a, (.dmark+2)  
2a6e 32 bf fb			ld (debug_mark+2),a  
2a71 18 03			jr .pastdmark  
2a73 ..			.dmark: db "LSm"  
2a76 f1			.pastdmark: pop af  
2a77			endm  
# End of macro DMARK
2a77					CALLMONITOR 
2a77 cd ea 15			call break_point_state  
2a7a				endm  
# End of macro CALLMONITOR
2a7a				endif 
2a7a			 
2a7a					; skip opcode 
2a7a 23					inc hl  
2a7b					; skip next ptr 
2a7b 23					inc hl  
2a7c 23					inc hl 
2a7d					; skip len 
2a7d 7e					ld a, (hl)   ; save length to add 
2a7e				if DEBUG_FORTH_WORDS 
2a7e					DMARK "LS2" 
2a7e f5				push af  
2a7f 3a 93 2a			ld a, (.dmark)  
2a82 32 bd fb			ld (debug_mark),a  
2a85 3a 94 2a			ld a, (.dmark+1)  
2a88 32 be fb			ld (debug_mark+1),a  
2a8b 3a 95 2a			ld a, (.dmark+2)  
2a8e 32 bf fb			ld (debug_mark+2),a  
2a91 18 03			jr .pastdmark  
2a93 ..			.dmark: db "LS2"  
2a96 f1			.pastdmark: pop af  
2a97			endm  
# End of macro DMARK
2a97					CALLMONITOR 
2a97 cd ea 15			call break_point_state  
2a9a				endm  
# End of macro CALLMONITOR
2a9a				endif 
2a9a			 
2a9a					; save this location 
2a9a				 
2a9a e5					push hl 
2a9b			 
2a9b 23					inc hl 
2a9c 11 a5 ef				ld de, scratch+2 
2a9f 4f					ld c, a 
2aa0 06 00				ld b, 0 
2aa2			 
2aa2				if DEBUG_FORTH_WORDS 
2aa2					DMARK "LSn" 
2aa2 f5				push af  
2aa3 3a b7 2a			ld a, (.dmark)  
2aa6 32 bd fb			ld (debug_mark),a  
2aa9 3a b8 2a			ld a, (.dmark+1)  
2aac 32 be fb			ld (debug_mark+1),a  
2aaf 3a b9 2a			ld a, (.dmark+2)  
2ab2 32 bf fb			ld (debug_mark+2),a  
2ab5 18 03			jr .pastdmark  
2ab7 ..			.dmark: db "LSn"  
2aba f1			.pastdmark: pop af  
2abb			endm  
# End of macro DMARK
2abb					CALLMONITOR 
2abb cd ea 15			call break_point_state  
2abe				endm  
# End of macro CALLMONITOR
2abe				endif 
2abe			 
2abe					; copy uword name to scratch 
2abe			 
2abe ed b0				ldir 
2ac0			 
2ac0 1b					dec de 
2ac1 3e 20				ld a, ' '    ; change null to space 
2ac3 12					ld (de), a 
2ac4			 
2ac4 13					inc de 
2ac5			 
2ac5 d5					push de 
2ac6 c1					pop bc     ; move scratch pointer to end of word name and save it 
2ac7			 
2ac7 e1					pop hl 
2ac8 7e					ld a, (hl) 
2ac9					;inc hl 
2ac9					; skip word string 
2ac9 cd c8 0c				call addatohl 
2acc			 
2acc 23					inc hl 
2acd			 
2acd				if DEBUG_FORTH_WORDS 
2acd					DMARK "LS3" 
2acd f5				push af  
2ace 3a e2 2a			ld a, (.dmark)  
2ad1 32 bd fb			ld (debug_mark),a  
2ad4 3a e3 2a			ld a, (.dmark+1)  
2ad7 32 be fb			ld (debug_mark+1),a  
2ada 3a e4 2a			ld a, (.dmark+2)  
2add 32 bf fb			ld (debug_mark+2),a  
2ae0 18 03			jr .pastdmark  
2ae2 ..			.dmark: db "LS3"  
2ae5 f1			.pastdmark: pop af  
2ae6			endm  
# End of macro DMARK
2ae6					CALLMONITOR 
2ae6 cd ea 15			call break_point_state  
2ae9				endm  
# End of macro CALLMONITOR
2ae9				endif 
2ae9					; should now be at the start of the machine code to setup the eval of the uword 
2ae9					; now locate the ptr to the string defintion 
2ae9			 
2ae9					; skip ld hl, 
2ae9					; then load the ptr 
2ae9			 
2ae9 23					inc hl 
2aea 5e					ld e, (hl) 
2aeb 23					inc hl 
2aec 56					ld d, (hl) 
2aed eb					ex de, hl 
2aee			 
2aee			 
2aee				if DEBUG_FORTH_WORDS 
2aee					DMARK "LSt" 
2aee f5				push af  
2aef 3a 03 2b			ld a, (.dmark)  
2af2 32 bd fb			ld (debug_mark),a  
2af5 3a 04 2b			ld a, (.dmark+1)  
2af8 32 be fb			ld (debug_mark+1),a  
2afb 3a 05 2b			ld a, (.dmark+2)  
2afe 32 bf fb			ld (debug_mark+2),a  
2b01 18 03			jr .pastdmark  
2b03 ..			.dmark: db "LSt"  
2b06 f1			.pastdmark: pop af  
2b07			endm  
# End of macro DMARK
2b07					CALLMONITOR 
2b07 cd ea 15			call break_point_state  
2b0a				endm  
# End of macro CALLMONITOR
2b0a				endif 
2b0a			 
2b0a			; cant push right now due to tokenised strings  
2b0a			 
2b0a			; get the destination of where to copy this definition to. 
2b0a			 
2b0a c5					push bc 
2b0b d1					pop de 
2b0c			 
2b0c 7e			.listl:         ld a,(hl) 
2b0d fe 00				cp 0 
2b0f 28 09				jr z, .lreplsp     ; replace zero with space 
2b11 fe 7f				cp FORTH_END_BUFFER 
2b13 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b15				 
2b15					; just copy this char as is then 
2b15			 
2b15 12					ld (de), a 
2b16			 
2b16 23			.listnxt:	inc hl 
2b17 13					inc de 
2b18 18 f2				jr .listl 
2b1a			 
2b1a 3e 20		.lreplsp:	ld a,' ' 
2b1c 12					ld (de), a 
2b1d 18 f7				jr .listnxt 
2b1f			 
2b1f			; close up uword def 
2b1f			 
2b1f			.listdone: 
2b1f 3e 00				ld a, 0 
2b21 12					ld (de), a 
2b22			 
2b22			; now have def so clean up and push to stack 
2b22			 
2b22 21 a3 ef				ld hl, scratch 
2b25				if DEBUG_FORTH_WORDS 
2b25					DMARK "Ltp" 
2b25 f5				push af  
2b26 3a 3a 2b			ld a, (.dmark)  
2b29 32 bd fb			ld (debug_mark),a  
2b2c 3a 3b 2b			ld a, (.dmark+1)  
2b2f 32 be fb			ld (debug_mark+1),a  
2b32 3a 3c 2b			ld a, (.dmark+2)  
2b35 32 bf fb			ld (debug_mark+2),a  
2b38 18 03			jr .pastdmark  
2b3a ..			.dmark: db "Ltp"  
2b3d f1			.pastdmark: pop af  
2b3e			endm  
# End of macro DMARK
2b3e					CALLMONITOR 
2b3e cd ea 15			call break_point_state  
2b41				endm  
# End of macro CALLMONITOR
2b41				endif 
2b41			 
2b41 18 06			jr .listpush 
2b43			 
2b43			;.lnuword:	pop hl 
2b43			;		call forth_tok_next 
2b43			;		jp .ldouscan  
2b43			 
2b43			.lunotfound:		  
2b43			 
2b43			 
2b43					 
2b43					FORTH_DSP_POP 
2b43 cd 26 1e			call macro_forth_dsp_pop 
2b46				endm 
# End of macro FORTH_DSP_POP
2b46 21 4f 2b				ld hl, .luno 
2b49						 
2b49			 
2b49			.listpush: 
2b49 cd e5 1b				call forth_push_str 
2b4c			 
2b4c			 
2b4c			 
2b4c					NEXTW 
2b4c c3 e0 1e			jp macro_next 
2b4f				endm 
# End of macro NEXTW
2b4f			 
2b4f .. 00		.luno:    db "Not found",0 
2b59			 
2b59			 
2b59			 
2b59			 
2b59			 
2b59			;		push hl   ; save pointer to start of uword def string 
2b59			; 
2b59			;; look for FORTH_EOL_LINE 
2b59			;		ld a, FORTH_END_BUFFER 
2b59			;		call strlent 
2b59			; 
2b59			;		inc hl		 ; space for coln def 
2b59			;		inc hl 
2b59			;		inc hl          ; space for terms 
2b59			;		inc hl 
2b59			; 
2b59			;		ld a, 20   ; TODO get actual length 
2b59			;		call addatohl    ; include a random amount of room for the uword name 
2b59			; 
2b59			;		 
2b59			;	if DEBUG_FORTH_WORDS 
2b59			;		DMARK "Lt1" 
2b59			;		CALLMONITOR 
2b59			;	endif 
2b59			;		 
2b59			; 
2b59			;; malloc space for the string because we cant change it 
2b59			; 
2b59			;		call malloc 
2b59			;	if DEBUG_FORTH_MALLOC_GUARD 
2b59			;		push af 
2b59			;		call ishlzero 
2b59			;		pop af 
2b59			;		 
2b59			;		call z,malloc_error 
2b59			;	endif 
2b59			; 
2b59			;	if DEBUG_FORTH_WORDS 
2b59			;		DMARK "Lt2" 
2b59			;		CALLMONITOR 
2b59			;	endif 
2b59			;		pop de 
2b59			;		push hl    ; push the malloc to release later 
2b59			;		push hl   ;  push back a copy for the later stack push 
2b59			;		 
2b59			;; copy the string swapping out the zero terms for spaces 
2b59			; 
2b59			;		; de has our source 
2b59			;		; hl has our dest 
2b59			; 
2b59			;; add the coln def 
2b59			; 
2b59			;		ld a, ':' 
2b59			;		ld (hl), a 
2b59			;		inc hl 
2b59			;		ld a, ' ' 
2b59			;		ld (hl), a 
2b59			;		inc hl 
2b59			; 
2b59			;; add the uname word 
2b59			;		push de   ; save our string for now 
2b59			;		ex de, hl 
2b59			; 
2b59			;		FORTH_DSP_VALUE 
2b59			;		;v5 FORTH_DSP_VALUE 
2b59			; 
2b59			;		inc hl   ; skip type but we know by now this is OK 
2b59			; 
2b59			;.luword:	ld a,(hl) 
2b59			;		cp 0 
2b59			;		jr z, .luword2 
2b59			;		ld (de), a 
2b59			;		inc de 
2b59			;		inc hl 
2b59			;		jr .luword 
2b59			; 
2b59			;.luword2:	ld a, ' ' 
2b59			;		ld (de), a 
2b59			;;		inc hl 
2b59			;;		inc de 
2b59			;;		ld (de), a 
2b59			;;		inc hl 
2b59			;		inc de 
2b59			; 
2b59			;		ex de, hl 
2b59			;		pop de 
2b59			;		 
2b59			;		 
2b59			; 
2b59			;; detoken that string and copy it 
2b59			; 
2b59			;	if DEBUG_FORTH_WORDS 
2b59			;		DMARK "Lt2" 
2b59			;		CALLMONITOR 
2b59			;	endif 
2b59			;.ldetok:	ld a, (de) 
2b59			;		cp FORTH_END_BUFFER 
2b59			;		jr z, .ldetokend 
2b59			;		; swap out any zero term for space 
2b59			;		cp 0 
2b59			;		jr nz, .ldetoknext 
2b59			;		ld a, ' ' 
2b59			; 
2b59			;	if DEBUG_FORTH_WORDS 
2b59			;		DMARK "LtS" 
2b59			;		CALLMONITOR 
2b59			;	endif 
2b59			;.ldetoknext:	ld (hl), a 
2b59			;		inc de 
2b59			;		inc hl 
2b59			;		jr .ldetok 
2b59			; 
2b59			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b59			;		ld (hl), a  
2b59			; 
2b59			;; free that temp malloc 
2b59			; 
2b59			;		pop hl    
2b59			; 
2b59			;	if DEBUG_FORTH_WORDS 
2b59			;		DMARK "Lt4" 
2b59			;		CALLMONITOR 
2b59			;	endif 
2b59			;		call forth_apushstrhl 
2b59			; 
2b59			;		; get rid of temp malloc area 
2b59			; 
2b59			;		pop hl 
2b59			;		call free 
2b59			; 
2b59			;		jr .ludone 
2b59			; 
2b59			;.lnuword:	pop hl 
2b59			;		call forth_tok_next 
2b59			;		jp .ldouscan  
2b59			; 
2b59			;.ludone:		 pop hl 
2b59			; 
2b59					NEXTW 
2b59 c3 e0 1e			jp macro_next 
2b5c				endm 
# End of macro NEXTW
2b5c			 
2b5c			.FORGET: 
2b5c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b5c 5d				db WORD_SYS_CORE+73             
2b5d d5 2b			dw .NOP            
2b5f 07				db 6 + 1 
2b60 .. 00			db "FORGET",0              
2b67				endm 
# End of macro CWHEAD
2b67			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b67			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b67			; | |  
2b67			; | | e.g. "MORE" forget 
2b67					if DEBUG_FORTH_WORDS_KEY 
2b67						DMARK "FRG" 
2b67 f5				push af  
2b68 3a 7c 2b			ld a, (.dmark)  
2b6b 32 bd fb			ld (debug_mark),a  
2b6e 3a 7d 2b			ld a, (.dmark+1)  
2b71 32 be fb			ld (debug_mark+1),a  
2b74 3a 7e 2b			ld a, (.dmark+2)  
2b77 32 bf fb			ld (debug_mark+2),a  
2b7a 18 03			jr .pastdmark  
2b7c ..			.dmark: db "FRG"  
2b7f f1			.pastdmark: pop af  
2b80			endm  
# End of macro DMARK
2b80						CALLMONITOR 
2b80 cd ea 15			call break_point_state  
2b83				endm  
# End of macro CALLMONITOR
2b83					endif 
2b83			 
2b83				; find uword 
2b83			        ; update start of word with "_" 
2b83				; replace uword with deleted flag 
2b83			 
2b83			 
2b83			;	if DEBUG_FORTH_WORDS 
2b83			;		DMARK "FOG" 
2b83			;		CALLMONITOR 
2b83			;	endif 
2b83			 
2b83			 
2b83					; Get ptr to the word we need to look up 
2b83			 
2b83					FORTH_DSP_VALUEHL 
2b83 cd 6e 1d			call macro_dsp_valuehl 
2b86				endm 
# End of macro FORTH_DSP_VALUEHL
2b86					;v5 FORTH_DSP_VALUE 
2b86				; TODO type check 
2b86			;		inc hl    ; Skip type check  
2b86 e5					push hl 
2b87 c1					pop bc 
2b88			;		ex de, hl    ; put into DE 
2b88			 
2b88			 
2b88 21 00 80				ld hl, baseram 
2b8b					;ld hl, baseusermem 
2b8b			 
2b8b				; skip dict stub 
2b8b			;	call forth_tok_next 
2b8b e5			push hl   ; sacreifical push 
2b8c			 
2b8c			.fldouscanm: 
2b8c e1				pop hl 
2b8d			.fldouscan: 
2b8d			;	if DEBUG_FORTH_WORDS 
2b8d			;		DMARK "LSs" 
2b8d			;		CALLMONITOR 
2b8d			;	endif 
2b8d				; skip dict stub 
2b8d cd 31 20				call forth_tok_next 
2b90			 
2b90			 
2b90			; while we have words to look for 
2b90			 
2b90 7e				ld a, (hl)      
2b91			;	if DEBUG_FORTH_WORDS 
2b91			;		DMARK "LSk" 
2b91			;		CALLMONITOR 
2b91			;	endif 
2b91 fe 00				cp WORD_SYS_END 
2b93 ca cf 2b				jp z, .flunotfound 
2b96 fe 01				cp WORD_SYS_UWORD 
2b98 c2 8d 2b				jp nz, .fldouscan 
2b9b			 
2b9b			;	if DEBUG_FORTH_WORDS 
2b9b			;		DMARK "LSu" 
2b9b			;		CALLMONITOR 
2b9b			;	endif 
2b9b			 
2b9b					; found a uword but is it the one we want... 
2b9b			 
2b9b c5					push bc     ; uword to find is on bc 
2b9c d1					pop de 
2b9d			 
2b9d e5					push hl  ; to save the ptr 
2b9e			 
2b9e					; skip opcode 
2b9e 23					inc hl  
2b9f					; skip next ptr 
2b9f 23					inc hl  
2ba0 23					inc hl 
2ba1					; skip len 
2ba1 23					inc hl 
2ba2			 
2ba2			;	if DEBUG_FORTH_WORDS 
2ba2			;		DMARK "LSc" 
2ba2			;		CALLMONITOR 
2ba2			;	endif 
2ba2 cd 5e 11				call strcmp 
2ba5 c2 8c 2b				jp nz, .fldouscanm 
2ba8			; 
2ba8			; 
2ba8			;; while we have words to look for 
2ba8			; 
2ba8			;.fdouscan:	ld a, (hl)      
2ba8			;	if DEBUG_FORTH_WORDS 
2ba8			;		DMARK "LSs" 
2ba8			;		CALLMONITOR 
2ba8			;	endif 
2ba8			;		cp WORD_SYS_END 
2ba8			;		jp z, .fudone 
2ba8			;		cp WORD_SYS_UWORD 
2ba8			;		jp nz, .fnuword 
2ba8			; 
2ba8			;	if DEBUG_FORTH_WORDS 
2ba8			;		DMARK "FGu" 
2ba8			;		CALLMONITOR 
2ba8			;	endif 
2ba8			; 
2ba8			;		; found a uword but is it the one we want... 
2ba8			; 
2ba8			; 
2ba8			;	        pop de   ; get back the dsp name 
2ba8			;		push de 
2ba8			; 
2ba8			;		push hl  ; to save the ptr 
2ba8			; 
2ba8			;		; skip opcode 
2ba8			;		inc hl  
2ba8			;		; skip next ptr 
2ba8			;		inc hl  
2ba8			;		inc hl 
2ba8			;		; skip len 
2ba8			;		inc hl 
2ba8			; 
2ba8			;	if DEBUG_FORTH_WORDS 
2ba8			;		DMARK "FGc" 
2ba8			;		CALLMONITOR 
2ba8			;	endif 
2ba8			;		call strcmp 
2ba8			;		jp nz, .fnuword 
2ba8			 
2ba8			 
2ba8 e1			pop hl 
2ba9			 
2ba9				 
2ba9				if DEBUG_FORTH_WORDS 
2ba9					DMARK "FGm" 
2ba9 f5				push af  
2baa 3a be 2b			ld a, (.dmark)  
2bad 32 bd fb			ld (debug_mark),a  
2bb0 3a bf 2b			ld a, (.dmark+1)  
2bb3 32 be fb			ld (debug_mark+1),a  
2bb6 3a c0 2b			ld a, (.dmark+2)  
2bb9 32 bf fb			ld (debug_mark+2),a  
2bbc 18 03			jr .pastdmark  
2bbe ..			.dmark: db "FGm"  
2bc1 f1			.pastdmark: pop af  
2bc2			endm  
# End of macro DMARK
2bc2					CALLMONITOR 
2bc2 cd ea 15			call break_point_state  
2bc5				endm  
# End of macro CALLMONITOR
2bc5				endif 
2bc5			 
2bc5			 
2bc5			 
2bc5					; we have a uword so push its name to the stack 
2bc5			 
2bc5			;	   	push hl  ; save so we can move to next dict block 
2bc5			;pop hl 
2bc5			 
2bc5					; update opcode to deleted 
2bc5 3e 03				ld a, WORD_SYS_DELETED 
2bc7 77					ld (hl), a 
2bc8			 
2bc8 23					inc hl  
2bc9					; skip next ptr 
2bc9 23					inc hl  
2bca 23					inc hl 
2bcb					; skip len 
2bcb 23					inc hl 
2bcc			 
2bcc					; TODO change parser to skip deleted words but for now mark it out 
2bcc 3e 5f				ld a, "_" 
2bce 77					ld  (hl),a 
2bcf			 
2bcf			;		jr .fudone 
2bcf			; 
2bcf			;.fnuword:	pop hl 
2bcf			;		call forth_tok_next 
2bcf			;		jp .fdouscan  
2bcf			 
2bcf			.flunotfound:		  
2bcf			 
2bcf			 
2bcf					 
2bcf					FORTH_DSP_POP 
2bcf cd 26 1e			call macro_forth_dsp_pop 
2bd2				endm 
# End of macro FORTH_DSP_POP
2bd2			;		ld hl, .luno 
2bd2			;.fudone:		 pop hl 
2bd2					NEXTW 
2bd2 c3 e0 1e			jp macro_next 
2bd5				endm 
# End of macro NEXTW
2bd5			.NOP: 
2bd5				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bd5 61				db WORD_SYS_CORE+77             
2bd6 fc 2b			dw .COMO            
2bd8 04				db 3 + 1 
2bd9 .. 00			db "NOP",0              
2bdd				endm 
# End of macro CWHEAD
2bdd			; | NOP (  --  ) Do nothing | DONE 
2bdd					if DEBUG_FORTH_WORDS_KEY 
2bdd						DMARK "NOP" 
2bdd f5				push af  
2bde 3a f2 2b			ld a, (.dmark)  
2be1 32 bd fb			ld (debug_mark),a  
2be4 3a f3 2b			ld a, (.dmark+1)  
2be7 32 be fb			ld (debug_mark+1),a  
2bea 3a f4 2b			ld a, (.dmark+2)  
2bed 32 bf fb			ld (debug_mark+2),a  
2bf0 18 03			jr .pastdmark  
2bf2 ..			.dmark: db "NOP"  
2bf5 f1			.pastdmark: pop af  
2bf6			endm  
# End of macro DMARK
2bf6						CALLMONITOR 
2bf6 cd ea 15			call break_point_state  
2bf9				endm  
# End of macro CALLMONITOR
2bf9					endif 
2bf9				       NEXTW 
2bf9 c3 e0 1e			jp macro_next 
2bfc				endm 
# End of macro NEXTW
2bfc			.COMO: 
2bfc				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bfc 6e				db WORD_SYS_CORE+90             
2bfd 4e 2c			dw .COMC            
2bff 02				db 1 + 1 
2c00 .. 00			db "(",0              
2c02				endm 
# End of macro CWHEAD
2c02			; | ( ( -- )  Start of comment | DONE 
2c02			 
2c02			 
2c02 2a a4 f2				ld hl, ( os_tok_ptr) 
2c05 11 49 2c			ld de, .closepar 
2c08					 
2c08					if DEBUG_FORTH_WORDS 
2c08						DMARK ").." 
2c08 f5				push af  
2c09 3a 1d 2c			ld a, (.dmark)  
2c0c 32 bd fb			ld (debug_mark),a  
2c0f 3a 1e 2c			ld a, (.dmark+1)  
2c12 32 be fb			ld (debug_mark+1),a  
2c15 3a 1f 2c			ld a, (.dmark+2)  
2c18 32 bf fb			ld (debug_mark+2),a  
2c1b 18 03			jr .pastdmark  
2c1d ..			.dmark: db ").."  
2c20 f1			.pastdmark: pop af  
2c21			endm  
# End of macro DMARK
2c21						CALLMONITOR 
2c21 cd ea 15			call break_point_state  
2c24				endm  
# End of macro CALLMONITOR
2c24					endif 
2c24 cd fb 1f			call findnexttok  
2c27			 
2c27					if DEBUG_FORTH_WORDS 
2c27						DMARK "IF5" 
2c27 f5				push af  
2c28 3a 3c 2c			ld a, (.dmark)  
2c2b 32 bd fb			ld (debug_mark),a  
2c2e 3a 3d 2c			ld a, (.dmark+1)  
2c31 32 be fb			ld (debug_mark+1),a  
2c34 3a 3e 2c			ld a, (.dmark+2)  
2c37 32 bf fb			ld (debug_mark+2),a  
2c3a 18 03			jr .pastdmark  
2c3c ..			.dmark: db "IF5"  
2c3f f1			.pastdmark: pop af  
2c40			endm  
# End of macro DMARK
2c40						CALLMONITOR 
2c40 cd ea 15			call break_point_state  
2c43				endm  
# End of macro CALLMONITOR
2c43					endif 
2c43				; replace below with ) exec using tok_ptr 
2c43 22 a4 f2			ld (os_tok_ptr), hl 
2c46 c3 71 1f			jp exec1 
2c49			 
2c49 .. 00			.closepar:   db ")",0 
2c4b			 
2c4b				       NEXTW 
2c4b c3 e0 1e			jp macro_next 
2c4e				endm 
# End of macro NEXTW
2c4e			.COMC: 
2c4e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c4e 6f				db WORD_SYS_CORE+91             
2c4f 57 2c			dw .SCRATCH            
2c51 02				db 1 + 1 
2c52 .. 00			db ")",0              
2c54				endm 
# End of macro CWHEAD
2c54			; | ) ( -- )  End of comment |  DONE  
2c54				       NEXTW 
2c54 c3 e0 1e			jp macro_next 
2c57				endm 
# End of macro NEXTW
2c57			 
2c57			.SCRATCH: 
2c57				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c57 6f				db WORD_SYS_CORE+91             
2c58 92 2c			dw .INC            
2c5a 08				db 7 + 1 
2c5b .. 00			db "SCRATCH",0              
2c63				endm 
# End of macro CWHEAD
2c63			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c63			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c63			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c63			; | |  
2c63			; | | e.g.    : score $00 scratch ; 
2c63			; | |  
2c63			; | | $00 score ! 
2c63			; | | $01 score +! 
2c63			; | |  
2c63			; | | e.g.   : varword $0a scratch ;  
2c63			; | | 
2c63			; | | $8000 varword ! 
2c63					if DEBUG_FORTH_WORDS_KEY 
2c63						DMARK "SCR" 
2c63 f5				push af  
2c64 3a 78 2c			ld a, (.dmark)  
2c67 32 bd fb			ld (debug_mark),a  
2c6a 3a 79 2c			ld a, (.dmark+1)  
2c6d 32 be fb			ld (debug_mark+1),a  
2c70 3a 7a 2c			ld a, (.dmark+2)  
2c73 32 bf fb			ld (debug_mark+2),a  
2c76 18 03			jr .pastdmark  
2c78 ..			.dmark: db "SCR"  
2c7b f1			.pastdmark: pop af  
2c7c			endm  
# End of macro DMARK
2c7c						CALLMONITOR 
2c7c cd ea 15			call break_point_state  
2c7f				endm  
# End of macro CALLMONITOR
2c7f					endif 
2c7f			 
2c7f					FORTH_DSP_VALUEHL 
2c7f cd 6e 1d			call macro_dsp_valuehl 
2c82				endm 
# End of macro FORTH_DSP_VALUEHL
2c82				 
2c82					FORTH_DSP_POP 
2c82 cd 26 1e			call macro_forth_dsp_pop 
2c85				endm 
# End of macro FORTH_DSP_POP
2c85			 
2c85 7d					ld a, l 
2c86 21 c8 f4				ld hl, os_var_array 
2c89 cd c8 0c				call addatohl 
2c8c			 
2c8c cd 77 1b				call forth_push_numhl 
2c8f			 
2c8f				       NEXTW 
2c8f c3 e0 1e			jp macro_next 
2c92				endm 
# End of macro NEXTW
2c92			 
2c92			.INC: 
2c92				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c92 6f				db WORD_SYS_CORE+91             
2c93 e6 2c			dw .DEC            
2c95 03				db 2 + 1 
2c96 .. 00			db "+!",0              
2c99				endm 
# End of macro CWHEAD
2c99			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c99					if DEBUG_FORTH_WORDS_KEY 
2c99						DMARK "+s_" 
2c99 f5				push af  
2c9a 3a ae 2c			ld a, (.dmark)  
2c9d 32 bd fb			ld (debug_mark),a  
2ca0 3a af 2c			ld a, (.dmark+1)  
2ca3 32 be fb			ld (debug_mark+1),a  
2ca6 3a b0 2c			ld a, (.dmark+2)  
2ca9 32 bf fb			ld (debug_mark+2),a  
2cac 18 03			jr .pastdmark  
2cae ..			.dmark: db "+s_"  
2cb1 f1			.pastdmark: pop af  
2cb2			endm  
# End of macro DMARK
2cb2						CALLMONITOR 
2cb2 cd ea 15			call break_point_state  
2cb5				endm  
# End of macro CALLMONITOR
2cb5					endif 
2cb5			 
2cb5					FORTH_DSP_VALUEHL 
2cb5 cd 6e 1d			call macro_dsp_valuehl 
2cb8				endm 
# End of macro FORTH_DSP_VALUEHL
2cb8			 
2cb8 e5					push hl   ; save address 
2cb9			 
2cb9					FORTH_DSP_POP 
2cb9 cd 26 1e			call macro_forth_dsp_pop 
2cbc				endm 
# End of macro FORTH_DSP_POP
2cbc			 
2cbc					FORTH_DSP_VALUEHL 
2cbc cd 6e 1d			call macro_dsp_valuehl 
2cbf				endm 
# End of macro FORTH_DSP_VALUEHL
2cbf			 
2cbf					FORTH_DSP_POP 
2cbf cd 26 1e			call macro_forth_dsp_pop 
2cc2				endm 
# End of macro FORTH_DSP_POP
2cc2			 
2cc2					; hl contains value to add to byte at a 
2cc2				 
2cc2 eb					ex de, hl 
2cc3			 
2cc3 e1					pop hl 
2cc4			 
2cc4					if DEBUG_FORTH_WORDS 
2cc4						DMARK "INC" 
2cc4 f5				push af  
2cc5 3a d9 2c			ld a, (.dmark)  
2cc8 32 bd fb			ld (debug_mark),a  
2ccb 3a da 2c			ld a, (.dmark+1)  
2cce 32 be fb			ld (debug_mark+1),a  
2cd1 3a db 2c			ld a, (.dmark+2)  
2cd4 32 bf fb			ld (debug_mark+2),a  
2cd7 18 03			jr .pastdmark  
2cd9 ..			.dmark: db "INC"  
2cdc f1			.pastdmark: pop af  
2cdd			endm  
# End of macro DMARK
2cdd						CALLMONITOR 
2cdd cd ea 15			call break_point_state  
2ce0				endm  
# End of macro CALLMONITOR
2ce0					endif 
2ce0			 
2ce0 7e					ld a,(hl) 
2ce1 83					add e 
2ce2 77					ld (hl),a 
2ce3			 
2ce3			 
2ce3			 
2ce3				       NEXTW 
2ce3 c3 e0 1e			jp macro_next 
2ce6				endm 
# End of macro NEXTW
2ce6			 
2ce6			.DEC: 
2ce6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2ce6 6f				db WORD_SYS_CORE+91             
2ce7 37 2d			dw .INC2            
2ce9 03				db 2 + 1 
2cea .. 00			db "-!",0              
2ced				endm 
# End of macro CWHEAD
2ced			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ced					if DEBUG_FORTH_WORDS_KEY 
2ced						DMARK "-s_" 
2ced f5				push af  
2cee 3a 02 2d			ld a, (.dmark)  
2cf1 32 bd fb			ld (debug_mark),a  
2cf4 3a 03 2d			ld a, (.dmark+1)  
2cf7 32 be fb			ld (debug_mark+1),a  
2cfa 3a 04 2d			ld a, (.dmark+2)  
2cfd 32 bf fb			ld (debug_mark+2),a  
2d00 18 03			jr .pastdmark  
2d02 ..			.dmark: db "-s_"  
2d05 f1			.pastdmark: pop af  
2d06			endm  
# End of macro DMARK
2d06						CALLMONITOR 
2d06 cd ea 15			call break_point_state  
2d09				endm  
# End of macro CALLMONITOR
2d09					endif 
2d09			 
2d09					FORTH_DSP_VALUEHL 
2d09 cd 6e 1d			call macro_dsp_valuehl 
2d0c				endm 
# End of macro FORTH_DSP_VALUEHL
2d0c			 
2d0c e5					push hl   ; save address 
2d0d			 
2d0d					FORTH_DSP_POP 
2d0d cd 26 1e			call macro_forth_dsp_pop 
2d10				endm 
# End of macro FORTH_DSP_POP
2d10			 
2d10					FORTH_DSP_VALUEHL 
2d10 cd 6e 1d			call macro_dsp_valuehl 
2d13				endm 
# End of macro FORTH_DSP_VALUEHL
2d13			 
2d13					; hl contains value to add to byte at a 
2d13				 
2d13 eb					ex de, hl 
2d14			 
2d14 e1					pop hl 
2d15			 
2d15					if DEBUG_FORTH_WORDS 
2d15						DMARK "DEC" 
2d15 f5				push af  
2d16 3a 2a 2d			ld a, (.dmark)  
2d19 32 bd fb			ld (debug_mark),a  
2d1c 3a 2b 2d			ld a, (.dmark+1)  
2d1f 32 be fb			ld (debug_mark+1),a  
2d22 3a 2c 2d			ld a, (.dmark+2)  
2d25 32 bf fb			ld (debug_mark+2),a  
2d28 18 03			jr .pastdmark  
2d2a ..			.dmark: db "DEC"  
2d2d f1			.pastdmark: pop af  
2d2e			endm  
# End of macro DMARK
2d2e						CALLMONITOR 
2d2e cd ea 15			call break_point_state  
2d31				endm  
# End of macro CALLMONITOR
2d31					endif 
2d31			 
2d31 7e					ld a,(hl) 
2d32 93					sub e 
2d33 77					ld (hl),a 
2d34			 
2d34			 
2d34			 
2d34				       NEXTW 
2d34 c3 e0 1e			jp macro_next 
2d37				endm 
# End of macro NEXTW
2d37			 
2d37			.INC2: 
2d37				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d37 6f				db WORD_SYS_CORE+91             
2d38 e1 2d			dw .DEC2            
2d3a 04				db 3 + 1 
2d3b .. 00			db "+2!",0              
2d3f				endm 
# End of macro CWHEAD
2d3f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d3f			 
2d3f					if DEBUG_FORTH_WORDS_KEY 
2d3f						DMARK "+2s" 
2d3f f5				push af  
2d40 3a 54 2d			ld a, (.dmark)  
2d43 32 bd fb			ld (debug_mark),a  
2d46 3a 55 2d			ld a, (.dmark+1)  
2d49 32 be fb			ld (debug_mark+1),a  
2d4c 3a 56 2d			ld a, (.dmark+2)  
2d4f 32 bf fb			ld (debug_mark+2),a  
2d52 18 03			jr .pastdmark  
2d54 ..			.dmark: db "+2s"  
2d57 f1			.pastdmark: pop af  
2d58			endm  
# End of macro DMARK
2d58						CALLMONITOR 
2d58 cd ea 15			call break_point_state  
2d5b				endm  
# End of macro CALLMONITOR
2d5b					endif 
2d5b			 
2d5b					; Address 
2d5b			 
2d5b					FORTH_DSP_VALUEHL 
2d5b cd 6e 1d			call macro_dsp_valuehl 
2d5e				endm 
# End of macro FORTH_DSP_VALUEHL
2d5e			 
2d5e e5					push hl    ; save address 
2d5f			 
2d5f					; load content into de 
2d5f			 
2d5f 5e					ld e,(hl) 
2d60 23					inc hl 
2d61 56					ld d, (hl) 
2d62			 
2d62					if DEBUG_FORTH_WORDS 
2d62						DMARK "+2a" 
2d62 f5				push af  
2d63 3a 77 2d			ld a, (.dmark)  
2d66 32 bd fb			ld (debug_mark),a  
2d69 3a 78 2d			ld a, (.dmark+1)  
2d6c 32 be fb			ld (debug_mark+1),a  
2d6f 3a 79 2d			ld a, (.dmark+2)  
2d72 32 bf fb			ld (debug_mark+2),a  
2d75 18 03			jr .pastdmark  
2d77 ..			.dmark: db "+2a"  
2d7a f1			.pastdmark: pop af  
2d7b			endm  
# End of macro DMARK
2d7b						CALLMONITOR 
2d7b cd ea 15			call break_point_state  
2d7e				endm  
# End of macro CALLMONITOR
2d7e					endif 
2d7e			 
2d7e					FORTH_DSP_POP 
2d7e cd 26 1e			call macro_forth_dsp_pop 
2d81				endm 
# End of macro FORTH_DSP_POP
2d81			 
2d81					; Get value to add 
2d81			 
2d81					FORTH_DSP_VALUE 
2d81 cd 57 1d			call macro_forth_dsp_value 
2d84				endm 
# End of macro FORTH_DSP_VALUE
2d84			 
2d84					if DEBUG_FORTH_WORDS 
2d84						DMARK "+2v" 
2d84 f5				push af  
2d85 3a 99 2d			ld a, (.dmark)  
2d88 32 bd fb			ld (debug_mark),a  
2d8b 3a 9a 2d			ld a, (.dmark+1)  
2d8e 32 be fb			ld (debug_mark+1),a  
2d91 3a 9b 2d			ld a, (.dmark+2)  
2d94 32 bf fb			ld (debug_mark+2),a  
2d97 18 03			jr .pastdmark  
2d99 ..			.dmark: db "+2v"  
2d9c f1			.pastdmark: pop af  
2d9d			endm  
# End of macro DMARK
2d9d						CALLMONITOR 
2d9d cd ea 15			call break_point_state  
2da0				endm  
# End of macro CALLMONITOR
2da0					endif 
2da0			 
2da0 19					add hl, de 
2da1			 
2da1					if DEBUG_FORTH_WORDS 
2da1						DMARK "+2+" 
2da1 f5				push af  
2da2 3a b6 2d			ld a, (.dmark)  
2da5 32 bd fb			ld (debug_mark),a  
2da8 3a b7 2d			ld a, (.dmark+1)  
2dab 32 be fb			ld (debug_mark+1),a  
2dae 3a b8 2d			ld a, (.dmark+2)  
2db1 32 bf fb			ld (debug_mark+2),a  
2db4 18 03			jr .pastdmark  
2db6 ..			.dmark: db "+2+"  
2db9 f1			.pastdmark: pop af  
2dba			endm  
# End of macro DMARK
2dba						CALLMONITOR 
2dba cd ea 15			call break_point_state  
2dbd				endm  
# End of macro CALLMONITOR
2dbd					endif 
2dbd			 
2dbd					; move result to de 
2dbd			 
2dbd eb					ex de, hl 
2dbe			 
2dbe					; Address 
2dbe			 
2dbe e1					pop hl 
2dbf			 
2dbf					; save it back 
2dbf			 
2dbf 73					ld (hl), e 
2dc0 23					inc hl 
2dc1 72					ld (hl), d 
2dc2			 
2dc2					if DEBUG_FORTH_WORDS 
2dc2						DMARK "+2e" 
2dc2 f5				push af  
2dc3 3a d7 2d			ld a, (.dmark)  
2dc6 32 bd fb			ld (debug_mark),a  
2dc9 3a d8 2d			ld a, (.dmark+1)  
2dcc 32 be fb			ld (debug_mark+1),a  
2dcf 3a d9 2d			ld a, (.dmark+2)  
2dd2 32 bf fb			ld (debug_mark+2),a  
2dd5 18 03			jr .pastdmark  
2dd7 ..			.dmark: db "+2e"  
2dda f1			.pastdmark: pop af  
2ddb			endm  
# End of macro DMARK
2ddb						CALLMONITOR 
2ddb cd ea 15			call break_point_state  
2dde				endm  
# End of macro CALLMONITOR
2dde					endif 
2dde			 
2dde			 
2dde			 
2dde			 
2dde			 
2dde				       NEXTW 
2dde c3 e0 1e			jp macro_next 
2de1				endm 
# End of macro NEXTW
2de1			 
2de1			.DEC2: 
2de1				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2de1 6f				db WORD_SYS_CORE+91             
2de2 8d 2e			dw .GET2            
2de4 04				db 3 + 1 
2de5 .. 00			db "-2!",0              
2de9				endm 
# End of macro CWHEAD
2de9			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2de9			 
2de9			 
2de9					if DEBUG_FORTH_WORDS_KEY 
2de9						DMARK "-2s" 
2de9 f5				push af  
2dea 3a fe 2d			ld a, (.dmark)  
2ded 32 bd fb			ld (debug_mark),a  
2df0 3a ff 2d			ld a, (.dmark+1)  
2df3 32 be fb			ld (debug_mark+1),a  
2df6 3a 00 2e			ld a, (.dmark+2)  
2df9 32 bf fb			ld (debug_mark+2),a  
2dfc 18 03			jr .pastdmark  
2dfe ..			.dmark: db "-2s"  
2e01 f1			.pastdmark: pop af  
2e02			endm  
# End of macro DMARK
2e02						CALLMONITOR 
2e02 cd ea 15			call break_point_state  
2e05				endm  
# End of macro CALLMONITOR
2e05					endif 
2e05			 
2e05					; Address 
2e05			 
2e05					FORTH_DSP_VALUEHL 
2e05 cd 6e 1d			call macro_dsp_valuehl 
2e08				endm 
# End of macro FORTH_DSP_VALUEHL
2e08			 
2e08 e5					push hl    ; save address 
2e09			 
2e09					; load content into de 
2e09			 
2e09 5e					ld e,(hl) 
2e0a 23					inc hl 
2e0b 56					ld d, (hl) 
2e0c			 
2e0c					if DEBUG_FORTH_WORDS 
2e0c						DMARK "-2a" 
2e0c f5				push af  
2e0d 3a 21 2e			ld a, (.dmark)  
2e10 32 bd fb			ld (debug_mark),a  
2e13 3a 22 2e			ld a, (.dmark+1)  
2e16 32 be fb			ld (debug_mark+1),a  
2e19 3a 23 2e			ld a, (.dmark+2)  
2e1c 32 bf fb			ld (debug_mark+2),a  
2e1f 18 03			jr .pastdmark  
2e21 ..			.dmark: db "-2a"  
2e24 f1			.pastdmark: pop af  
2e25			endm  
# End of macro DMARK
2e25						CALLMONITOR 
2e25 cd ea 15			call break_point_state  
2e28				endm  
# End of macro CALLMONITOR
2e28					endif 
2e28			 
2e28					FORTH_DSP_POP 
2e28 cd 26 1e			call macro_forth_dsp_pop 
2e2b				endm 
# End of macro FORTH_DSP_POP
2e2b			 
2e2b					; Get value to remove 
2e2b			 
2e2b					FORTH_DSP_VALUE 
2e2b cd 57 1d			call macro_forth_dsp_value 
2e2e				endm 
# End of macro FORTH_DSP_VALUE
2e2e			 
2e2e					if DEBUG_FORTH_WORDS 
2e2e						DMARK "-2v" 
2e2e f5				push af  
2e2f 3a 43 2e			ld a, (.dmark)  
2e32 32 bd fb			ld (debug_mark),a  
2e35 3a 44 2e			ld a, (.dmark+1)  
2e38 32 be fb			ld (debug_mark+1),a  
2e3b 3a 45 2e			ld a, (.dmark+2)  
2e3e 32 bf fb			ld (debug_mark+2),a  
2e41 18 03			jr .pastdmark  
2e43 ..			.dmark: db "-2v"  
2e46 f1			.pastdmark: pop af  
2e47			endm  
# End of macro DMARK
2e47						CALLMONITOR 
2e47 cd ea 15			call break_point_state  
2e4a				endm  
# End of macro CALLMONITOR
2e4a					endif 
2e4a			 
2e4a eb					ex de, hl 
2e4b ed 52				sbc hl, de 
2e4d			 
2e4d					if DEBUG_FORTH_WORDS 
2e4d						DMARK "-2d" 
2e4d f5				push af  
2e4e 3a 62 2e			ld a, (.dmark)  
2e51 32 bd fb			ld (debug_mark),a  
2e54 3a 63 2e			ld a, (.dmark+1)  
2e57 32 be fb			ld (debug_mark+1),a  
2e5a 3a 64 2e			ld a, (.dmark+2)  
2e5d 32 bf fb			ld (debug_mark+2),a  
2e60 18 03			jr .pastdmark  
2e62 ..			.dmark: db "-2d"  
2e65 f1			.pastdmark: pop af  
2e66			endm  
# End of macro DMARK
2e66						CALLMONITOR 
2e66 cd ea 15			call break_point_state  
2e69				endm  
# End of macro CALLMONITOR
2e69					endif 
2e69			 
2e69					; move result to de 
2e69			 
2e69 eb					ex de, hl 
2e6a			 
2e6a					; Address 
2e6a			 
2e6a e1					pop hl 
2e6b			 
2e6b					; save it back 
2e6b			 
2e6b 73					ld (hl), e 
2e6c 23					inc hl 
2e6d 72					ld (hl), d 
2e6e			 
2e6e					if DEBUG_FORTH_WORDS 
2e6e						DMARK "-2e" 
2e6e f5				push af  
2e6f 3a 83 2e			ld a, (.dmark)  
2e72 32 bd fb			ld (debug_mark),a  
2e75 3a 84 2e			ld a, (.dmark+1)  
2e78 32 be fb			ld (debug_mark+1),a  
2e7b 3a 85 2e			ld a, (.dmark+2)  
2e7e 32 bf fb			ld (debug_mark+2),a  
2e81 18 03			jr .pastdmark  
2e83 ..			.dmark: db "-2e"  
2e86 f1			.pastdmark: pop af  
2e87			endm  
# End of macro DMARK
2e87						CALLMONITOR 
2e87 cd ea 15			call break_point_state  
2e8a				endm  
# End of macro CALLMONITOR
2e8a					endif 
2e8a			 
2e8a			 
2e8a			 
2e8a			 
2e8a			 
2e8a				       NEXTW 
2e8a c3 e0 1e			jp macro_next 
2e8d				endm 
# End of macro NEXTW
2e8d			.GET2: 
2e8d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e8d 6f				db WORD_SYS_CORE+91             
2e8e bd 2e			dw .BANG2            
2e90 03				db 2 + 1 
2e91 .. 00			db "2@",0              
2e94				endm 
# End of macro CWHEAD
2e94			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e94					if DEBUG_FORTH_WORDS_KEY 
2e94						DMARK "2A_" 
2e94 f5				push af  
2e95 3a a9 2e			ld a, (.dmark)  
2e98 32 bd fb			ld (debug_mark),a  
2e9b 3a aa 2e			ld a, (.dmark+1)  
2e9e 32 be fb			ld (debug_mark+1),a  
2ea1 3a ab 2e			ld a, (.dmark+2)  
2ea4 32 bf fb			ld (debug_mark+2),a  
2ea7 18 03			jr .pastdmark  
2ea9 ..			.dmark: db "2A_"  
2eac f1			.pastdmark: pop af  
2ead			endm  
# End of macro DMARK
2ead						CALLMONITOR 
2ead cd ea 15			call break_point_state  
2eb0				endm  
# End of macro CALLMONITOR
2eb0					endif 
2eb0			 
2eb0					FORTH_DSP_VALUEHL 
2eb0 cd 6e 1d			call macro_dsp_valuehl 
2eb3				endm 
# End of macro FORTH_DSP_VALUEHL
2eb3			 
2eb3 5e					ld e, (hl) 
2eb4 23					inc hl 
2eb5 56					ld d, (hl) 
2eb6			 
2eb6 eb					ex de, hl 
2eb7			 
2eb7 cd 77 1b				call forth_push_numhl 
2eba			 
2eba				       NEXTW 
2eba c3 e0 1e			jp macro_next 
2ebd				endm 
# End of macro NEXTW
2ebd			.BANG2: 
2ebd				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ebd 6f				db WORD_SYS_CORE+91             
2ebe f5 2e			dw .CONFIG            
2ec0 03				db 2 + 1 
2ec1 .. 00			db "2!",0              
2ec4				endm 
# End of macro CWHEAD
2ec4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ec4					if DEBUG_FORTH_WORDS_KEY 
2ec4						DMARK "2S_" 
2ec4 f5				push af  
2ec5 3a d9 2e			ld a, (.dmark)  
2ec8 32 bd fb			ld (debug_mark),a  
2ecb 3a da 2e			ld a, (.dmark+1)  
2ece 32 be fb			ld (debug_mark+1),a  
2ed1 3a db 2e			ld a, (.dmark+2)  
2ed4 32 bf fb			ld (debug_mark+2),a  
2ed7 18 03			jr .pastdmark  
2ed9 ..			.dmark: db "2S_"  
2edc f1			.pastdmark: pop af  
2edd			endm  
# End of macro DMARK
2edd						CALLMONITOR 
2edd cd ea 15			call break_point_state  
2ee0				endm  
# End of macro CALLMONITOR
2ee0					endif 
2ee0			 
2ee0					FORTH_DSP_VALUEHL 
2ee0 cd 6e 1d			call macro_dsp_valuehl 
2ee3				endm 
# End of macro FORTH_DSP_VALUEHL
2ee3			 
2ee3 e5					push hl   ; save address 
2ee4			 
2ee4			 
2ee4					FORTH_DSP_POP 
2ee4 cd 26 1e			call macro_forth_dsp_pop 
2ee7				endm 
# End of macro FORTH_DSP_POP
2ee7			 
2ee7					 
2ee7					FORTH_DSP_VALUEHL 
2ee7 cd 6e 1d			call macro_dsp_valuehl 
2eea				endm 
# End of macro FORTH_DSP_VALUEHL
2eea			 
2eea					FORTH_DSP_POP 
2eea cd 26 1e			call macro_forth_dsp_pop 
2eed				endm 
# End of macro FORTH_DSP_POP
2eed			 
2eed eb					ex de, hl    ; value now in de 
2eee			 
2eee e1					pop hl 
2eef			 
2eef 73					ld (hl), e 
2ef0			 
2ef0 23					inc hl 
2ef1			 
2ef1 72					ld (hl), d 
2ef2			 
2ef2			 
2ef2				       NEXTW 
2ef2 c3 e0 1e			jp macro_next 
2ef5				endm 
# End of macro NEXTW
2ef5			.CONFIG: 
2ef5				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ef5 6f				db WORD_SYS_CORE+91             
2ef6 06 2f			dw .ENDCORE            
2ef8 07				db 6 + 1 
2ef9 .. 00			db "CONFIG",0              
2f00				endm 
# End of macro CWHEAD
2f00			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2f00			 
2f00 cd 28 13				call config 
2f03					NEXTW 
2f03 c3 e0 1e			jp macro_next 
2f06				endm 
# End of macro NEXTW
2f06			.ENDCORE: 
2f06			 
2f06			; eof 
2f06			 
2f06			 
# End of file forth_words_core.asm
2f06			include "forth_words_flow.asm" 
2f06			 
2f06			; | ## Program Flow Words 
2f06			 
2f06			.IF: 
2f06				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f06 1e				db WORD_SYS_CORE+10             
2f07 fb 2f			dw .THEN            
2f09 03				db 2 + 1 
2f0a .. 00			db "IF",0              
2f0d				endm 
# End of macro CWHEAD
2f0d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f0d			; 
2f0d					if DEBUG_FORTH_WORDS_KEY 
2f0d						DMARK "IF." 
2f0d f5				push af  
2f0e 3a 22 2f			ld a, (.dmark)  
2f11 32 bd fb			ld (debug_mark),a  
2f14 3a 23 2f			ld a, (.dmark+1)  
2f17 32 be fb			ld (debug_mark+1),a  
2f1a 3a 24 2f			ld a, (.dmark+2)  
2f1d 32 bf fb			ld (debug_mark+2),a  
2f20 18 03			jr .pastdmark  
2f22 ..			.dmark: db "IF."  
2f25 f1			.pastdmark: pop af  
2f26			endm  
# End of macro DMARK
2f26						CALLMONITOR 
2f26 cd ea 15			call break_point_state  
2f29				endm  
# End of macro CALLMONITOR
2f29					endif 
2f29			; eval TOS 
2f29			 
2f29				FORTH_DSP_VALUEHL 
2f29 cd 6e 1d			call macro_dsp_valuehl 
2f2c				endm 
# End of macro FORTH_DSP_VALUEHL
2f2c			 
2f2c			;	push hl 
2f2c				FORTH_DSP_POP 
2f2c cd 26 1e			call macro_forth_dsp_pop 
2f2f				endm 
# End of macro FORTH_DSP_POP
2f2f			;	pop hl 
2f2f			 
2f2f					if DEBUG_FORTH_WORDS 
2f2f						DMARK "IF1" 
2f2f f5				push af  
2f30 3a 44 2f			ld a, (.dmark)  
2f33 32 bd fb			ld (debug_mark),a  
2f36 3a 45 2f			ld a, (.dmark+1)  
2f39 32 be fb			ld (debug_mark+1),a  
2f3c 3a 46 2f			ld a, (.dmark+2)  
2f3f 32 bf fb			ld (debug_mark+2),a  
2f42 18 03			jr .pastdmark  
2f44 ..			.dmark: db "IF1"  
2f47 f1			.pastdmark: pop af  
2f48			endm  
# End of macro DMARK
2f48						CALLMONITOR 
2f48 cd ea 15			call break_point_state  
2f4b				endm  
# End of macro CALLMONITOR
2f4b					endif 
2f4b b7				or a        ; clear carry flag 
2f4c 11 00 00			ld de, 0 
2f4f eb				ex de,hl 
2f50 ed 52			sbc hl, de 
2f52 c2 dc 2f			jp nz, .iftrue 
2f55			 
2f55					if DEBUG_FORTH_WORDS 
2f55						DMARK "IF2" 
2f55 f5				push af  
2f56 3a 6a 2f			ld a, (.dmark)  
2f59 32 bd fb			ld (debug_mark),a  
2f5c 3a 6b 2f			ld a, (.dmark+1)  
2f5f 32 be fb			ld (debug_mark+1),a  
2f62 3a 6c 2f			ld a, (.dmark+2)  
2f65 32 bf fb			ld (debug_mark+2),a  
2f68 18 03			jr .pastdmark  
2f6a ..			.dmark: db "IF2"  
2f6d f1			.pastdmark: pop af  
2f6e			endm  
# End of macro DMARK
2f6e						CALLMONITOR 
2f6e cd ea 15			call break_point_state  
2f71				endm  
# End of macro CALLMONITOR
2f71					endif 
2f71			 
2f71			; if not true then skip to THEN 
2f71			 
2f71				; TODO get tok_ptr 
2f71				; TODO consume toks until we get to THEN 
2f71			 
2f71 2a a4 f2			ld hl, (os_tok_ptr) 
2f74					if DEBUG_FORTH_WORDS 
2f74						DMARK "IF3" 
2f74 f5				push af  
2f75 3a 89 2f			ld a, (.dmark)  
2f78 32 bd fb			ld (debug_mark),a  
2f7b 3a 8a 2f			ld a, (.dmark+1)  
2f7e 32 be fb			ld (debug_mark+1),a  
2f81 3a 8b 2f			ld a, (.dmark+2)  
2f84 32 bf fb			ld (debug_mark+2),a  
2f87 18 03			jr .pastdmark  
2f89 ..			.dmark: db "IF3"  
2f8c f1			.pastdmark: pop af  
2f8d			endm  
# End of macro DMARK
2f8d						CALLMONITOR 
2f8d cd ea 15			call break_point_state  
2f90				endm  
# End of macro CALLMONITOR
2f90						 
2f90					endif 
2f90 11 d7 2f			ld de, .ifthen 
2f93					if DEBUG_FORTH_WORDS 
2f93						DMARK "IF4" 
2f93 f5				push af  
2f94 3a a8 2f			ld a, (.dmark)  
2f97 32 bd fb			ld (debug_mark),a  
2f9a 3a a9 2f			ld a, (.dmark+1)  
2f9d 32 be fb			ld (debug_mark+1),a  
2fa0 3a aa 2f			ld a, (.dmark+2)  
2fa3 32 bf fb			ld (debug_mark+2),a  
2fa6 18 03			jr .pastdmark  
2fa8 ..			.dmark: db "IF4"  
2fab f1			.pastdmark: pop af  
2fac			endm  
# End of macro DMARK
2fac						CALLMONITOR 
2fac cd ea 15			call break_point_state  
2faf				endm  
# End of macro CALLMONITOR
2faf					endif 
2faf cd fb 1f			call findnexttok  
2fb2			 
2fb2					if DEBUG_FORTH_WORDS 
2fb2						DMARK "IF5" 
2fb2 f5				push af  
2fb3 3a c7 2f			ld a, (.dmark)  
2fb6 32 bd fb			ld (debug_mark),a  
2fb9 3a c8 2f			ld a, (.dmark+1)  
2fbc 32 be fb			ld (debug_mark+1),a  
2fbf 3a c9 2f			ld a, (.dmark+2)  
2fc2 32 bf fb			ld (debug_mark+2),a  
2fc5 18 03			jr .pastdmark  
2fc7 ..			.dmark: db "IF5"  
2fca f1			.pastdmark: pop af  
2fcb			endm  
# End of macro DMARK
2fcb						CALLMONITOR 
2fcb cd ea 15			call break_point_state  
2fce				endm  
# End of macro CALLMONITOR
2fce					endif 
2fce				; TODO replace below with ; exec using tok_ptr 
2fce 22 a4 f2			ld (os_tok_ptr), hl 
2fd1 c3 71 1f			jp exec1 
2fd4				NEXTW 
2fd4 c3 e0 1e			jp macro_next 
2fd7				endm 
# End of macro NEXTW
2fd7			 
2fd7 .. 00		.ifthen:  db "THEN",0 
2fdc			 
2fdc			.iftrue:		 
2fdc				; Exec next words normally 
2fdc			 
2fdc				; if true then exec following IF as normal 
2fdc					if DEBUG_FORTH_WORDS 
2fdc						DMARK "IFT" 
2fdc f5				push af  
2fdd 3a f1 2f			ld a, (.dmark)  
2fe0 32 bd fb			ld (debug_mark),a  
2fe3 3a f2 2f			ld a, (.dmark+1)  
2fe6 32 be fb			ld (debug_mark+1),a  
2fe9 3a f3 2f			ld a, (.dmark+2)  
2fec 32 bf fb			ld (debug_mark+2),a  
2fef 18 03			jr .pastdmark  
2ff1 ..			.dmark: db "IFT"  
2ff4 f1			.pastdmark: pop af  
2ff5			endm  
# End of macro DMARK
2ff5						CALLMONITOR 
2ff5 cd ea 15			call break_point_state  
2ff8				endm  
# End of macro CALLMONITOR
2ff8					endif 
2ff8			 
2ff8					NEXTW 
2ff8 c3 e0 1e			jp macro_next 
2ffb				endm 
# End of macro NEXTW
2ffb			.THEN: 
2ffb				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2ffb 1f				db WORD_SYS_CORE+11             
2ffc 23 30			dw .ELSE            
2ffe 05				db 4 + 1 
2fff .. 00			db "THEN",0              
3004				endm 
# End of macro CWHEAD
3004			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3004					if DEBUG_FORTH_WORDS_KEY 
3004						DMARK "THN" 
3004 f5				push af  
3005 3a 19 30			ld a, (.dmark)  
3008 32 bd fb			ld (debug_mark),a  
300b 3a 1a 30			ld a, (.dmark+1)  
300e 32 be fb			ld (debug_mark+1),a  
3011 3a 1b 30			ld a, (.dmark+2)  
3014 32 bf fb			ld (debug_mark+2),a  
3017 18 03			jr .pastdmark  
3019 ..			.dmark: db "THN"  
301c f1			.pastdmark: pop af  
301d			endm  
# End of macro DMARK
301d						CALLMONITOR 
301d cd ea 15			call break_point_state  
3020				endm  
# End of macro CALLMONITOR
3020					endif 
3020					NEXTW 
3020 c3 e0 1e			jp macro_next 
3023				endm 
# End of macro NEXTW
3023			.ELSE: 
3023				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3023 20				db WORD_SYS_CORE+12             
3024 4b 30			dw .DO            
3026 03				db 2 + 1 
3027 .. 00			db "ELSE",0              
302c				endm 
# End of macro CWHEAD
302c			; | ELSE ( -- ) Not supported - does nothing | TODO 
302c			 
302c					if DEBUG_FORTH_WORDS_KEY 
302c						DMARK "ELS" 
302c f5				push af  
302d 3a 41 30			ld a, (.dmark)  
3030 32 bd fb			ld (debug_mark),a  
3033 3a 42 30			ld a, (.dmark+1)  
3036 32 be fb			ld (debug_mark+1),a  
3039 3a 43 30			ld a, (.dmark+2)  
303c 32 bf fb			ld (debug_mark+2),a  
303f 18 03			jr .pastdmark  
3041 ..			.dmark: db "ELS"  
3044 f1			.pastdmark: pop af  
3045			endm  
# End of macro DMARK
3045						CALLMONITOR 
3045 cd ea 15			call break_point_state  
3048				endm  
# End of macro CALLMONITOR
3048					endif 
3048			 
3048			 
3048					NEXTW 
3048 c3 e0 1e			jp macro_next 
304b				endm 
# End of macro NEXTW
304b			.DO: 
304b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
304b 21				db WORD_SYS_CORE+13             
304c 72 31			dw .LOOP            
304e 03				db 2 + 1 
304f .. 00			db "DO",0              
3052				endm 
# End of macro CWHEAD
3052			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3052			 
3052					if DEBUG_FORTH_WORDS_KEY 
3052						DMARK "DO." 
3052 f5				push af  
3053 3a 67 30			ld a, (.dmark)  
3056 32 bd fb			ld (debug_mark),a  
3059 3a 68 30			ld a, (.dmark+1)  
305c 32 be fb			ld (debug_mark+1),a  
305f 3a 69 30			ld a, (.dmark+2)  
3062 32 bf fb			ld (debug_mark+2),a  
3065 18 03			jr .pastdmark  
3067 ..			.dmark: db "DO."  
306a f1			.pastdmark: pop af  
306b			endm  
# End of macro DMARK
306b						CALLMONITOR 
306b cd ea 15			call break_point_state  
306e				endm  
# End of macro CALLMONITOR
306e					endif 
306e			;  push pc to rsp stack past the DO 
306e			 
306e 2a a4 f2				ld hl, (os_tok_ptr) 
3071 23					inc hl   ; D 
3072 23					inc hl  ; O 
3073 23					inc hl   ; null 
3074					if DEBUG_FORTH_WORDS 
3074						DMARK "DO2" 
3074 f5				push af  
3075 3a 89 30			ld a, (.dmark)  
3078 32 bd fb			ld (debug_mark),a  
307b 3a 8a 30			ld a, (.dmark+1)  
307e 32 be fb			ld (debug_mark+1),a  
3081 3a 8b 30			ld a, (.dmark+2)  
3084 32 bf fb			ld (debug_mark+2),a  
3087 18 03			jr .pastdmark  
3089 ..			.dmark: db "DO2"  
308c f1			.pastdmark: pop af  
308d			endm  
# End of macro DMARK
308d						CALLMONITOR 
308d cd ea 15			call break_point_state  
3090				endm  
# End of macro CALLMONITOR
3090					endif 
3090					FORTH_RSP_NEXT 
3090 cd 1e 1b			call macro_forth_rsp_next 
3093				endm 
# End of macro FORTH_RSP_NEXT
3093					if DEBUG_FORTH_WORDS 
3093						DMARK "DO3" 
3093 f5				push af  
3094 3a a8 30			ld a, (.dmark)  
3097 32 bd fb			ld (debug_mark),a  
309a 3a a9 30			ld a, (.dmark+1)  
309d 32 be fb			ld (debug_mark+1),a  
30a0 3a aa 30			ld a, (.dmark+2)  
30a3 32 bf fb			ld (debug_mark+2),a  
30a6 18 03			jr .pastdmark  
30a8 ..			.dmark: db "DO3"  
30ab f1			.pastdmark: pop af  
30ac			endm  
# End of macro DMARK
30ac						CALLMONITOR 
30ac cd ea 15			call break_point_state  
30af				endm  
# End of macro CALLMONITOR
30af					endif 
30af			 
30af					;if DEBUG_FORTH_WORDS 
30af				;		push hl 
30af			;		endif  
30af			 
30af			; get counters from data stack 
30af			 
30af			 
30af					FORTH_DSP_VALUEHL 
30af cd 6e 1d			call macro_dsp_valuehl 
30b2				endm 
# End of macro FORTH_DSP_VALUEHL
30b2 e5					push hl		 ; hl now has starting counter which needs to be tos 
30b3			 
30b3					if DEBUG_FORTH_WORDS 
30b3						DMARK "DO4" 
30b3 f5				push af  
30b4 3a c8 30			ld a, (.dmark)  
30b7 32 bd fb			ld (debug_mark),a  
30ba 3a c9 30			ld a, (.dmark+1)  
30bd 32 be fb			ld (debug_mark+1),a  
30c0 3a ca 30			ld a, (.dmark+2)  
30c3 32 bf fb			ld (debug_mark+2),a  
30c6 18 03			jr .pastdmark  
30c8 ..			.dmark: db "DO4"  
30cb f1			.pastdmark: pop af  
30cc			endm  
# End of macro DMARK
30cc						CALLMONITOR 
30cc cd ea 15			call break_point_state  
30cf				endm  
# End of macro CALLMONITOR
30cf					endif 
30cf					FORTH_DSP_POP 
30cf cd 26 1e			call macro_forth_dsp_pop 
30d2				endm 
# End of macro FORTH_DSP_POP
30d2			 
30d2					if DEBUG_FORTH_WORDS 
30d2						DMARK "DO5" 
30d2 f5				push af  
30d3 3a e7 30			ld a, (.dmark)  
30d6 32 bd fb			ld (debug_mark),a  
30d9 3a e8 30			ld a, (.dmark+1)  
30dc 32 be fb			ld (debug_mark+1),a  
30df 3a e9 30			ld a, (.dmark+2)  
30e2 32 bf fb			ld (debug_mark+2),a  
30e5 18 03			jr .pastdmark  
30e7 ..			.dmark: db "DO5"  
30ea f1			.pastdmark: pop af  
30eb			endm  
# End of macro DMARK
30eb						CALLMONITOR 
30eb cd ea 15			call break_point_state  
30ee				endm  
# End of macro CALLMONITOR
30ee					endif 
30ee			 
30ee					FORTH_DSP_VALUEHL 
30ee cd 6e 1d			call macro_dsp_valuehl 
30f1				endm 
# End of macro FORTH_DSP_VALUEHL
30f1			;		push hl		 ; hl now has starting limit counter 
30f1			 
30f1					if DEBUG_FORTH_WORDS 
30f1						DMARK "DO6" 
30f1 f5				push af  
30f2 3a 06 31			ld a, (.dmark)  
30f5 32 bd fb			ld (debug_mark),a  
30f8 3a 07 31			ld a, (.dmark+1)  
30fb 32 be fb			ld (debug_mark+1),a  
30fe 3a 08 31			ld a, (.dmark+2)  
3101 32 bf fb			ld (debug_mark+2),a  
3104 18 03			jr .pastdmark  
3106 ..			.dmark: db "DO6"  
3109 f1			.pastdmark: pop af  
310a			endm  
# End of macro DMARK
310a						CALLMONITOR 
310a cd ea 15			call break_point_state  
310d				endm  
# End of macro CALLMONITOR
310d					endif 
310d					FORTH_DSP_POP 
310d cd 26 1e			call macro_forth_dsp_pop 
3110				endm 
# End of macro FORTH_DSP_POP
3110			 
3110			; put counters on the loop stack 
3110			 
3110			;		pop hl			 ; limit counter 
3110 d1					pop de			; start counter 
3111			 
3111					; push limit counter 
3111			 
3111					if DEBUG_FORTH_WORDS 
3111						DMARK "DO7" 
3111 f5				push af  
3112 3a 26 31			ld a, (.dmark)  
3115 32 bd fb			ld (debug_mark),a  
3118 3a 27 31			ld a, (.dmark+1)  
311b 32 be fb			ld (debug_mark+1),a  
311e 3a 28 31			ld a, (.dmark+2)  
3121 32 bf fb			ld (debug_mark+2),a  
3124 18 03			jr .pastdmark  
3126 ..			.dmark: db "DO7"  
3129 f1			.pastdmark: pop af  
312a			endm  
# End of macro DMARK
312a						CALLMONITOR 
312a cd ea 15			call break_point_state  
312d				endm  
# End of macro CALLMONITOR
312d					endif 
312d					FORTH_LOOP_NEXT 
312d cd 9f 1d			call macro_forth_loop_next 
3130				endm 
# End of macro FORTH_LOOP_NEXT
3130			 
3130					; push start counter 
3130			 
3130 eb					ex de, hl 
3131					if DEBUG_FORTH_WORDS 
3131						DMARK "DO7" 
3131 f5				push af  
3132 3a 46 31			ld a, (.dmark)  
3135 32 bd fb			ld (debug_mark),a  
3138 3a 47 31			ld a, (.dmark+1)  
313b 32 be fb			ld (debug_mark+1),a  
313e 3a 48 31			ld a, (.dmark+2)  
3141 32 bf fb			ld (debug_mark+2),a  
3144 18 03			jr .pastdmark  
3146 ..			.dmark: db "DO7"  
3149 f1			.pastdmark: pop af  
314a			endm  
# End of macro DMARK
314a						CALLMONITOR 
314a cd ea 15			call break_point_state  
314d				endm  
# End of macro CALLMONITOR
314d					endif 
314d					FORTH_LOOP_NEXT 
314d cd 9f 1d			call macro_forth_loop_next 
3150				endm 
# End of macro FORTH_LOOP_NEXT
3150			 
3150			 
3150					; init first round of I counter 
3150			 
3150 22 c8 f2				ld (os_current_i), hl 
3153			 
3153					if DEBUG_FORTH_WORDS 
3153						DMARK "DO8" 
3153 f5				push af  
3154 3a 68 31			ld a, (.dmark)  
3157 32 bd fb			ld (debug_mark),a  
315a 3a 69 31			ld a, (.dmark+1)  
315d 32 be fb			ld (debug_mark+1),a  
3160 3a 6a 31			ld a, (.dmark+2)  
3163 32 bf fb			ld (debug_mark+2),a  
3166 18 03			jr .pastdmark  
3168 ..			.dmark: db "DO8"  
316b f1			.pastdmark: pop af  
316c			endm  
# End of macro DMARK
316c						CALLMONITOR 
316c cd ea 15			call break_point_state  
316f				endm  
# End of macro CALLMONITOR
316f					endif 
316f			 
316f					NEXTW 
316f c3 e0 1e			jp macro_next 
3172				endm 
# End of macro NEXTW
3172			.LOOP: 
3172				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3172 22				db WORD_SYS_CORE+14             
3173 8a 32			dw .I            
3175 05				db 4 + 1 
3176 .. 00			db "LOOP",0              
317b				endm 
# End of macro CWHEAD
317b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
317b			 
317b				; pop tos as current loop count to hl 
317b			 
317b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
317b			 
317b				FORTH_LOOP_TOS 
317b cd d2 1d			call macro_forth_loop_tos 
317e				endm 
# End of macro FORTH_LOOP_TOS
317e e5				push hl 
317f			 
317f					if DEBUG_FORTH_WORDS_KEY 
317f						DMARK "LOP" 
317f f5				push af  
3180 3a 94 31			ld a, (.dmark)  
3183 32 bd fb			ld (debug_mark),a  
3186 3a 95 31			ld a, (.dmark+1)  
3189 32 be fb			ld (debug_mark+1),a  
318c 3a 96 31			ld a, (.dmark+2)  
318f 32 bf fb			ld (debug_mark+2),a  
3192 18 03			jr .pastdmark  
3194 ..			.dmark: db "LOP"  
3197 f1			.pastdmark: pop af  
3198			endm  
# End of macro DMARK
3198						CALLMONITOR 
3198 cd ea 15			call break_point_state  
319b				endm  
# End of macro CALLMONITOR
319b					endif 
319b				; next item on the stack is the limit. get it 
319b			 
319b			 
319b				FORTH_LOOP_POP 
319b cd dc 1d			call macro_forth_loop_pop 
319e				endm 
# End of macro FORTH_LOOP_POP
319e			 
319e				FORTH_LOOP_TOS 
319e cd d2 1d			call macro_forth_loop_tos 
31a1				endm 
# End of macro FORTH_LOOP_TOS
31a1			 
31a1 d1				pop de		 ; de = i, hl = limit 
31a2			 
31a2					if DEBUG_FORTH_WORDS 
31a2						DMARK "LP1" 
31a2 f5				push af  
31a3 3a b7 31			ld a, (.dmark)  
31a6 32 bd fb			ld (debug_mark),a  
31a9 3a b8 31			ld a, (.dmark+1)  
31ac 32 be fb			ld (debug_mark+1),a  
31af 3a b9 31			ld a, (.dmark+2)  
31b2 32 bf fb			ld (debug_mark+2),a  
31b5 18 03			jr .pastdmark  
31b7 ..			.dmark: db "LP1"  
31ba f1			.pastdmark: pop af  
31bb			endm  
# End of macro DMARK
31bb						CALLMONITOR 
31bb cd ea 15			call break_point_state  
31be				endm  
# End of macro CALLMONITOR
31be					endif 
31be			 
31be				; go back to previous word 
31be			 
31be d5				push de    ; save I for inc later 
31bf			 
31bf			 
31bf				; get limit 
31bf				;  is I at limit? 
31bf			 
31bf			 
31bf					if DEBUG_FORTH_WORDS 
31bf						DMARK "LP1" 
31bf f5				push af  
31c0 3a d4 31			ld a, (.dmark)  
31c3 32 bd fb			ld (debug_mark),a  
31c6 3a d5 31			ld a, (.dmark+1)  
31c9 32 be fb			ld (debug_mark+1),a  
31cc 3a d6 31			ld a, (.dmark+2)  
31cf 32 bf fb			ld (debug_mark+2),a  
31d2 18 03			jr .pastdmark  
31d4 ..			.dmark: db "LP1"  
31d7 f1			.pastdmark: pop af  
31d8			endm  
# End of macro DMARK
31d8						CALLMONITOR 
31d8 cd ea 15			call break_point_state  
31db				endm  
# End of macro CALLMONITOR
31db					endif 
31db			 
31db ed 52			sbc hl, de 
31dd			 
31dd			 
31dd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31dd			 
31dd 20 26				jr nz, .loopnotdone 
31df			 
31df e1				pop hl   ; get rid of saved I 
31e0				FORTH_LOOP_POP     ; get rid of limit 
31e0 cd dc 1d			call macro_forth_loop_pop 
31e3				endm 
# End of macro FORTH_LOOP_POP
31e3			 
31e3				FORTH_RSP_POP     ; get rid of DO ptr 
31e3 cd 3f 1b			call macro_forth_rsp_pop 
31e6				endm 
# End of macro FORTH_RSP_POP
31e6			 
31e6			if DEBUG_FORTH_WORDS 
31e6						DMARK "LP>" 
31e6 f5				push af  
31e7 3a fb 31			ld a, (.dmark)  
31ea 32 bd fb			ld (debug_mark),a  
31ed 3a fc 31			ld a, (.dmark+1)  
31f0 32 be fb			ld (debug_mark+1),a  
31f3 3a fd 31			ld a, (.dmark+2)  
31f6 32 bf fb			ld (debug_mark+2),a  
31f9 18 03			jr .pastdmark  
31fb ..			.dmark: db "LP>"  
31fe f1			.pastdmark: pop af  
31ff			endm  
# End of macro DMARK
31ff				CALLMONITOR 
31ff cd ea 15			call break_point_state  
3202				endm  
# End of macro CALLMONITOR
3202			endif 
3202			 
3202					NEXTW 
3202 c3 e0 1e			jp macro_next 
3205				endm 
# End of macro NEXTW
3205				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3205			 
3205			.loopnotdone: 
3205			 
3205 e1				pop hl    ; get I 
3206 23				inc hl 
3207			 
3207			   	; save new I 
3207			 
3207			 
3207					; set I counter 
3207			 
3207 22 c8 f2				ld (os_current_i), hl 
320a			 
320a					if DEBUG_FORTH_WORDS 
320a						DMARK "LPN" 
320a f5				push af  
320b 3a 1f 32			ld a, (.dmark)  
320e 32 bd fb			ld (debug_mark),a  
3211 3a 20 32			ld a, (.dmark+1)  
3214 32 be fb			ld (debug_mark+1),a  
3217 3a 21 32			ld a, (.dmark+2)  
321a 32 bf fb			ld (debug_mark+2),a  
321d 18 03			jr .pastdmark  
321f ..			.dmark: db "LPN"  
3222 f1			.pastdmark: pop af  
3223			endm  
# End of macro DMARK
3223					CALLMONITOR 
3223 cd ea 15			call break_point_state  
3226				endm  
# End of macro CALLMONITOR
3226					endif 
3226					 
3226				FORTH_LOOP_NEXT 
3226 cd 9f 1d			call macro_forth_loop_next 
3229				endm 
# End of macro FORTH_LOOP_NEXT
3229			 
3229			 
3229					if DEBUG_FORTH_WORDS 
3229 eb						ex de,hl 
322a					endif 
322a			 
322a			;	; get DO ptr 
322a			; 
322a					if DEBUG_FORTH_WORDS 
322a						DMARK "LP7" 
322a f5				push af  
322b 3a 3f 32			ld a, (.dmark)  
322e 32 bd fb			ld (debug_mark),a  
3231 3a 40 32			ld a, (.dmark+1)  
3234 32 be fb			ld (debug_mark+1),a  
3237 3a 41 32			ld a, (.dmark+2)  
323a 32 bf fb			ld (debug_mark+2),a  
323d 18 03			jr .pastdmark  
323f ..			.dmark: db "LP7"  
3242 f1			.pastdmark: pop af  
3243			endm  
# End of macro DMARK
3243					CALLMONITOR 
3243 cd ea 15			call break_point_state  
3246				endm  
# End of macro CALLMONITOR
3246					endif 
3246				FORTH_RSP_TOS 
3246 cd 35 1b			call macro_forth_rsp_tos 
3249				endm 
# End of macro FORTH_RSP_TOS
3249			 
3249					if DEBUG_FORTH_WORDS 
3249						DMARK "LP8" 
3249 f5				push af  
324a 3a 5e 32			ld a, (.dmark)  
324d 32 bd fb			ld (debug_mark),a  
3250 3a 5f 32			ld a, (.dmark+1)  
3253 32 be fb			ld (debug_mark+1),a  
3256 3a 60 32			ld a, (.dmark+2)  
3259 32 bf fb			ld (debug_mark+2),a  
325c 18 03			jr .pastdmark  
325e ..			.dmark: db "LP8"  
3261 f1			.pastdmark: pop af  
3262			endm  
# End of macro DMARK
3262					CALLMONITOR 
3262 cd ea 15			call break_point_state  
3265				endm  
# End of macro CALLMONITOR
3265					endif 
3265				;push hl 
3265			 
3265				; not going to DO any more 
3265				; get rid of the RSP pointer as DO will add it back in 
3265				;FORTH_RSP_POP 
3265				;pop hl 
3265			 
3265				;ld hl,(cli_ret_sp) 
3265				;ld e, (hl) 
3265				;inc hl 
3265				;ld d, (hl) 
3265				;ex de,hl 
3265 22 a4 f2			ld (os_tok_ptr), hl 
3268					if DEBUG_FORTH_WORDS 
3268						DMARK "LP<" 
3268 f5				push af  
3269 3a 7d 32			ld a, (.dmark)  
326c 32 bd fb			ld (debug_mark),a  
326f 3a 7e 32			ld a, (.dmark+1)  
3272 32 be fb			ld (debug_mark+1),a  
3275 3a 7f 32			ld a, (.dmark+2)  
3278 32 bf fb			ld (debug_mark+2),a  
327b 18 03			jr .pastdmark  
327d ..			.dmark: db "LP<"  
3280 f1			.pastdmark: pop af  
3281			endm  
# End of macro DMARK
3281					CALLMONITOR 
3281 cd ea 15			call break_point_state  
3284				endm  
# End of macro CALLMONITOR
3284				endif 
3284 c3 71 1f			jp exec1 
3287			 
3287					 
3287			 
3287			 
3287					NEXTW 
3287 c3 e0 1e			jp macro_next 
328a				endm 
# End of macro NEXTW
328a			.I:  
328a			 
328a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
328a 5e				db WORD_SYS_CORE+74             
328b b5 32			dw .DLOOP            
328d 02				db 1 + 1 
328e .. 00			db "I",0              
3290				endm 
# End of macro CWHEAD
3290			; | I ( -- ) Current loop counter | DONE 
3290					if DEBUG_FORTH_WORDS_KEY 
3290						DMARK "I.." 
3290 f5				push af  
3291 3a a5 32			ld a, (.dmark)  
3294 32 bd fb			ld (debug_mark),a  
3297 3a a6 32			ld a, (.dmark+1)  
329a 32 be fb			ld (debug_mark+1),a  
329d 3a a7 32			ld a, (.dmark+2)  
32a0 32 bf fb			ld (debug_mark+2),a  
32a3 18 03			jr .pastdmark  
32a5 ..			.dmark: db "I.."  
32a8 f1			.pastdmark: pop af  
32a9			endm  
# End of macro DMARK
32a9						CALLMONITOR 
32a9 cd ea 15			call break_point_state  
32ac				endm  
# End of macro CALLMONITOR
32ac					endif 
32ac			 
32ac 2a c8 f2				ld hl,(os_current_i) 
32af cd 77 1b				call forth_push_numhl 
32b2			 
32b2					NEXTW 
32b2 c3 e0 1e			jp macro_next 
32b5				endm 
# End of macro NEXTW
32b5			.DLOOP: 
32b5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32b5 5f				db WORD_SYS_CORE+75             
32b6 96 33			dw .REPEAT            
32b8 06				db 5 + 1 
32b9 .. 00			db "-LOOP",0              
32bf				endm 
# End of macro CWHEAD
32bf			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32bf				; pop tos as current loop count to hl 
32bf					if DEBUG_FORTH_WORDS_KEY 
32bf						DMARK "-LP" 
32bf f5				push af  
32c0 3a d4 32			ld a, (.dmark)  
32c3 32 bd fb			ld (debug_mark),a  
32c6 3a d5 32			ld a, (.dmark+1)  
32c9 32 be fb			ld (debug_mark+1),a  
32cc 3a d6 32			ld a, (.dmark+2)  
32cf 32 bf fb			ld (debug_mark+2),a  
32d2 18 03			jr .pastdmark  
32d4 ..			.dmark: db "-LP"  
32d7 f1			.pastdmark: pop af  
32d8			endm  
# End of macro DMARK
32d8						CALLMONITOR 
32d8 cd ea 15			call break_point_state  
32db				endm  
# End of macro CALLMONITOR
32db					endif 
32db			 
32db				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32db			 
32db				FORTH_LOOP_TOS 
32db cd d2 1d			call macro_forth_loop_tos 
32de				endm 
# End of macro FORTH_LOOP_TOS
32de e5				push hl 
32df			 
32df					if DEBUG_FORTH_WORDS 
32df						DMARK "-LP" 
32df f5				push af  
32e0 3a f4 32			ld a, (.dmark)  
32e3 32 bd fb			ld (debug_mark),a  
32e6 3a f5 32			ld a, (.dmark+1)  
32e9 32 be fb			ld (debug_mark+1),a  
32ec 3a f6 32			ld a, (.dmark+2)  
32ef 32 bf fb			ld (debug_mark+2),a  
32f2 18 03			jr .pastdmark  
32f4 ..			.dmark: db "-LP"  
32f7 f1			.pastdmark: pop af  
32f8			endm  
# End of macro DMARK
32f8						CALLMONITOR 
32f8 cd ea 15			call break_point_state  
32fb				endm  
# End of macro CALLMONITOR
32fb					endif 
32fb				; next item on the stack is the limit. get it 
32fb			 
32fb			 
32fb				FORTH_LOOP_POP 
32fb cd dc 1d			call macro_forth_loop_pop 
32fe				endm 
# End of macro FORTH_LOOP_POP
32fe			 
32fe				FORTH_LOOP_TOS 
32fe cd d2 1d			call macro_forth_loop_tos 
3301				endm 
# End of macro FORTH_LOOP_TOS
3301			 
3301 d1				pop de		 ; de = i, hl = limit 
3302			 
3302					if DEBUG_FORTH_WORDS 
3302						DMARK "-L1" 
3302 f5				push af  
3303 3a 17 33			ld a, (.dmark)  
3306 32 bd fb			ld (debug_mark),a  
3309 3a 18 33			ld a, (.dmark+1)  
330c 32 be fb			ld (debug_mark+1),a  
330f 3a 19 33			ld a, (.dmark+2)  
3312 32 bf fb			ld (debug_mark+2),a  
3315 18 03			jr .pastdmark  
3317 ..			.dmark: db "-L1"  
331a f1			.pastdmark: pop af  
331b			endm  
# End of macro DMARK
331b						CALLMONITOR 
331b cd ea 15			call break_point_state  
331e				endm  
# End of macro CALLMONITOR
331e					endif 
331e			 
331e				; go back to previous word 
331e			 
331e d5				push de    ; save I for inc later 
331f			 
331f			 
331f				; get limit 
331f				;  is I at limit? 
331f			 
331f			 
331f					if DEBUG_FORTH_WORDS 
331f						DMARK "-L1" 
331f f5				push af  
3320 3a 34 33			ld a, (.dmark)  
3323 32 bd fb			ld (debug_mark),a  
3326 3a 35 33			ld a, (.dmark+1)  
3329 32 be fb			ld (debug_mark+1),a  
332c 3a 36 33			ld a, (.dmark+2)  
332f 32 bf fb			ld (debug_mark+2),a  
3332 18 03			jr .pastdmark  
3334 ..			.dmark: db "-L1"  
3337 f1			.pastdmark: pop af  
3338			endm  
# End of macro DMARK
3338						CALLMONITOR 
3338 cd ea 15			call break_point_state  
333b				endm  
# End of macro CALLMONITOR
333b					endif 
333b			 
333b ed 52			sbc hl, de 
333d			 
333d			 
333d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
333d			 
333d 20 26				jr nz, .mloopnotdone 
333f			 
333f e1				pop hl   ; get rid of saved I 
3340				FORTH_LOOP_POP     ; get rid of limit 
3340 cd dc 1d			call macro_forth_loop_pop 
3343				endm 
# End of macro FORTH_LOOP_POP
3343			 
3343				FORTH_RSP_POP     ; get rid of DO ptr 
3343 cd 3f 1b			call macro_forth_rsp_pop 
3346				endm 
# End of macro FORTH_RSP_POP
3346			 
3346			if DEBUG_FORTH_WORDS 
3346						DMARK "-L>" 
3346 f5				push af  
3347 3a 5b 33			ld a, (.dmark)  
334a 32 bd fb			ld (debug_mark),a  
334d 3a 5c 33			ld a, (.dmark+1)  
3350 32 be fb			ld (debug_mark+1),a  
3353 3a 5d 33			ld a, (.dmark+2)  
3356 32 bf fb			ld (debug_mark+2),a  
3359 18 03			jr .pastdmark  
335b ..			.dmark: db "-L>"  
335e f1			.pastdmark: pop af  
335f			endm  
# End of macro DMARK
335f				CALLMONITOR 
335f cd ea 15			call break_point_state  
3362				endm  
# End of macro CALLMONITOR
3362			endif 
3362			 
3362					NEXTW 
3362 c3 e0 1e			jp macro_next 
3365				endm 
# End of macro NEXTW
3365				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3365			 
3365			.mloopnotdone: 
3365			 
3365 e1				pop hl    ; get I 
3366 2b				dec hl 
3367			 
3367			   	; save new I 
3367			 
3367			 
3367					; set I counter 
3367			 
3367 22 c8 f2				ld (os_current_i), hl 
336a			 
336a					 
336a				FORTH_LOOP_NEXT 
336a cd 9f 1d			call macro_forth_loop_next 
336d				endm 
# End of macro FORTH_LOOP_NEXT
336d			 
336d			 
336d					if DEBUG_FORTH_WORDS 
336d eb						ex de,hl 
336e					endif 
336e			 
336e			;	; get DO ptr 
336e			; 
336e				FORTH_RSP_TOS 
336e cd 35 1b			call macro_forth_rsp_tos 
3371				endm 
# End of macro FORTH_RSP_TOS
3371			 
3371				;push hl 
3371			 
3371				; not going to DO any more 
3371				; get rid of the RSP pointer as DO will add it back in 
3371				;FORTH_RSP_POP 
3371				;pop hl 
3371			 
3371			 
3371 22 a4 f2			ld (os_tok_ptr), hl 
3374					if DEBUG_FORTH_WORDS 
3374						DMARK "-L<" 
3374 f5				push af  
3375 3a 89 33			ld a, (.dmark)  
3378 32 bd fb			ld (debug_mark),a  
337b 3a 8a 33			ld a, (.dmark+1)  
337e 32 be fb			ld (debug_mark+1),a  
3381 3a 8b 33			ld a, (.dmark+2)  
3384 32 bf fb			ld (debug_mark+2),a  
3387 18 03			jr .pastdmark  
3389 ..			.dmark: db "-L<"  
338c f1			.pastdmark: pop af  
338d			endm  
# End of macro DMARK
338d					CALLMONITOR 
338d cd ea 15			call break_point_state  
3390				endm  
# End of macro CALLMONITOR
3390				endif 
3390 c3 71 1f			jp exec1 
3393			 
3393					 
3393			 
3393			 
3393			 
3393				NEXTW 
3393 c3 e0 1e			jp macro_next 
3396				endm 
# End of macro NEXTW
3396			 
3396			 
3396			 
3396			 
3396			.REPEAT: 
3396				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3396 71				db WORD_SYS_CORE+93             
3397 e9 33			dw .UNTIL            
3399 06				db 5 + 1 
339a .. 00			db "REPEAT",0              
33a1				endm 
# End of macro CWHEAD
33a1			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33a1			;  push pc to rsp stack past the REPEAT 
33a1					if DEBUG_FORTH_WORDS_KEY 
33a1						DMARK "REP" 
33a1 f5				push af  
33a2 3a b6 33			ld a, (.dmark)  
33a5 32 bd fb			ld (debug_mark),a  
33a8 3a b7 33			ld a, (.dmark+1)  
33ab 32 be fb			ld (debug_mark+1),a  
33ae 3a b8 33			ld a, (.dmark+2)  
33b1 32 bf fb			ld (debug_mark+2),a  
33b4 18 03			jr .pastdmark  
33b6 ..			.dmark: db "REP"  
33b9 f1			.pastdmark: pop af  
33ba			endm  
# End of macro DMARK
33ba						CALLMONITOR 
33ba cd ea 15			call break_point_state  
33bd				endm  
# End of macro CALLMONITOR
33bd					endif 
33bd			 
33bd 2a a4 f2				ld hl, (os_tok_ptr) 
33c0 23					inc hl   ; R 
33c1 23					inc hl  ; E 
33c2 23					inc hl   ; P 
33c3 23					inc hl   ; E 
33c4 23					inc hl   ; A 
33c5 23					inc hl   ; T 
33c6 23					inc hl   ; zero 
33c7					FORTH_RSP_NEXT 
33c7 cd 1e 1b			call macro_forth_rsp_next 
33ca				endm 
# End of macro FORTH_RSP_NEXT
33ca			 
33ca			 
33ca					if DEBUG_FORTH_WORDS 
33ca						DMARK "REP" 
33ca f5				push af  
33cb 3a df 33			ld a, (.dmark)  
33ce 32 bd fb			ld (debug_mark),a  
33d1 3a e0 33			ld a, (.dmark+1)  
33d4 32 be fb			ld (debug_mark+1),a  
33d7 3a e1 33			ld a, (.dmark+2)  
33da 32 bf fb			ld (debug_mark+2),a  
33dd 18 03			jr .pastdmark  
33df ..			.dmark: db "REP"  
33e2 f1			.pastdmark: pop af  
33e3			endm  
# End of macro DMARK
33e3						;pop bc    ; TODO BUG ?????? what is this for???? 
33e3						CALLMONITOR 
33e3 cd ea 15			call break_point_state  
33e6				endm  
# End of macro CALLMONITOR
33e6					endif 
33e6			 
33e6					NEXTW 
33e6 c3 e0 1e			jp macro_next 
33e9				endm 
# End of macro NEXTW
33e9			;	       NEXTW 
33e9			 
33e9			.UNTIL: 
33e9				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33e9 72				db WORD_SYS_CORE+94             
33ea 80 34			dw .ENDFLOW            
33ec 06				db 5 + 1 
33ed .. 00			db "UNTIL",0              
33f3				endm 
# End of macro CWHEAD
33f3			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33f3			 
33f3				; pop tos as check 
33f3			 
33f3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33f3			 
33f3				FORTH_DSP_VALUEHL 
33f3 cd 6e 1d			call macro_dsp_valuehl 
33f6				endm 
# End of macro FORTH_DSP_VALUEHL
33f6			 
33f6					if DEBUG_FORTH_WORDS_KEY 
33f6						DMARK "UNT" 
33f6 f5				push af  
33f7 3a 0b 34			ld a, (.dmark)  
33fa 32 bd fb			ld (debug_mark),a  
33fd 3a 0c 34			ld a, (.dmark+1)  
3400 32 be fb			ld (debug_mark+1),a  
3403 3a 0d 34			ld a, (.dmark+2)  
3406 32 bf fb			ld (debug_mark+2),a  
3409 18 03			jr .pastdmark  
340b ..			.dmark: db "UNT"  
340e f1			.pastdmark: pop af  
340f			endm  
# End of macro DMARK
340f						CALLMONITOR 
340f cd ea 15			call break_point_state  
3412				endm  
# End of macro CALLMONITOR
3412					endif 
3412			 
3412			;	push hl 
3412				FORTH_DSP_POP 
3412 cd 26 1e			call macro_forth_dsp_pop 
3415				endm 
# End of macro FORTH_DSP_POP
3415			 
3415			;	pop hl 
3415			 
3415				; test if true 
3415			 
3415 cd f1 0c			call ishlzero 
3418			;	ld a,l 
3418			;	add h 
3418			; 
3418			;	cp 0 
3418			 
3418 20 3e			jr nz, .untilnotdone 
341a			 
341a					if DEBUG_FORTH_WORDS 
341a						DMARK "UNf" 
341a f5				push af  
341b 3a 2f 34			ld a, (.dmark)  
341e 32 bd fb			ld (debug_mark),a  
3421 3a 30 34			ld a, (.dmark+1)  
3424 32 be fb			ld (debug_mark+1),a  
3427 3a 31 34			ld a, (.dmark+2)  
342a 32 bf fb			ld (debug_mark+2),a  
342d 18 03			jr .pastdmark  
342f ..			.dmark: db "UNf"  
3432 f1			.pastdmark: pop af  
3433			endm  
# End of macro DMARK
3433						CALLMONITOR 
3433 cd ea 15			call break_point_state  
3436				endm  
# End of macro CALLMONITOR
3436					endif 
3436			 
3436			 
3436			 
3436				FORTH_RSP_POP     ; get rid of DO ptr 
3436 cd 3f 1b			call macro_forth_rsp_pop 
3439				endm 
# End of macro FORTH_RSP_POP
3439			 
3439			if DEBUG_FORTH_WORDS 
3439						DMARK "UN>" 
3439 f5				push af  
343a 3a 4e 34			ld a, (.dmark)  
343d 32 bd fb			ld (debug_mark),a  
3440 3a 4f 34			ld a, (.dmark+1)  
3443 32 be fb			ld (debug_mark+1),a  
3446 3a 50 34			ld a, (.dmark+2)  
3449 32 bf fb			ld (debug_mark+2),a  
344c 18 03			jr .pastdmark  
344e ..			.dmark: db "UN>"  
3451 f1			.pastdmark: pop af  
3452			endm  
# End of macro DMARK
3452				CALLMONITOR 
3452 cd ea 15			call break_point_state  
3455				endm  
# End of macro CALLMONITOR
3455			endif 
3455			 
3455					NEXTW 
3455 c3 e0 1e			jp macro_next 
3458				endm 
# End of macro NEXTW
3458				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3458			 
3458			.untilnotdone: 
3458			 
3458			 
3458			;	; get DO ptr 
3458			; 
3458				FORTH_RSP_TOS 
3458 cd 35 1b			call macro_forth_rsp_tos 
345b				endm 
# End of macro FORTH_RSP_TOS
345b			 
345b				;push hl 
345b			 
345b				; not going to DO any more 
345b				; get rid of the RSP pointer as DO will add it back in 
345b				;FORTH_RSP_POP 
345b				;pop hl 
345b			 
345b			 
345b 22 a4 f2			ld (os_tok_ptr), hl 
345e					if DEBUG_FORTH_WORDS 
345e						DMARK "UN<" 
345e f5				push af  
345f 3a 73 34			ld a, (.dmark)  
3462 32 bd fb			ld (debug_mark),a  
3465 3a 74 34			ld a, (.dmark+1)  
3468 32 be fb			ld (debug_mark+1),a  
346b 3a 75 34			ld a, (.dmark+2)  
346e 32 bf fb			ld (debug_mark+2),a  
3471 18 03			jr .pastdmark  
3473 ..			.dmark: db "UN<"  
3476 f1			.pastdmark: pop af  
3477			endm  
# End of macro DMARK
3477					CALLMONITOR 
3477 cd ea 15			call break_point_state  
347a				endm  
# End of macro CALLMONITOR
347a				endif 
347a c3 71 1f			jp exec1 
347d			 
347d					 
347d			 
347d			 
347d					NEXTW 
347d c3 e0 1e			jp macro_next 
3480				endm 
# End of macro NEXTW
3480			 
3480			 
3480			.ENDFLOW: 
3480			 
3480			; eof 
3480			 
# End of file forth_words_flow.asm
3480			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3480			include "forth_words_logic.asm" 
3480			 
3480			; | ## Logic Words 
3480			 
3480			.NOT: 
3480				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3480 2d				db WORD_SYS_CORE+25             
3481 c8 34			dw .IS            
3483 04				db 3 + 1 
3484 .. 00			db "NOT",0              
3488				endm 
# End of macro CWHEAD
3488			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3488					if DEBUG_FORTH_WORDS_KEY 
3488						DMARK "NOT" 
3488 f5				push af  
3489 3a 9d 34			ld a, (.dmark)  
348c 32 bd fb			ld (debug_mark),a  
348f 3a 9e 34			ld a, (.dmark+1)  
3492 32 be fb			ld (debug_mark+1),a  
3495 3a 9f 34			ld a, (.dmark+2)  
3498 32 bf fb			ld (debug_mark+2),a  
349b 18 03			jr .pastdmark  
349d ..			.dmark: db "NOT"  
34a0 f1			.pastdmark: pop af  
34a1			endm  
# End of macro DMARK
34a1						CALLMONITOR 
34a1 cd ea 15			call break_point_state  
34a4				endm  
# End of macro CALLMONITOR
34a4					endif 
34a4					FORTH_DSP 
34a4 cd 34 1d			call macro_forth_dsp 
34a7				endm 
# End of macro FORTH_DSP
34a7 7e					ld a,(hl)	; get type of value on TOS 
34a8 fe 02				cp DS_TYPE_INUM  
34aa 28 03				jr z, .noti 
34ac					NEXTW 
34ac c3 e0 1e			jp macro_next 
34af				endm 
# End of macro NEXTW
34af			.noti:          FORTH_DSP_VALUEHL 
34af cd 6e 1d			call macro_dsp_valuehl 
34b2				endm 
# End of macro FORTH_DSP_VALUEHL
34b2			;		push hl 
34b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34b2 cd 26 1e			call macro_forth_dsp_pop 
34b5				endm 
# End of macro FORTH_DSP_POP
34b5			;		pop hl 
34b5 3e 00				ld a,0 
34b7 bd					cp l 
34b8 28 04				jr z, .not2t 
34ba 2e 00				ld l, 0 
34bc 18 02				jr .notip 
34be			 
34be 2e ff		.not2t:		ld l, 255 
34c0			 
34c0 26 00		.notip:		ld h, 0	 
34c2			 
34c2 cd 77 1b				call forth_push_numhl 
34c5					NEXTW 
34c5 c3 e0 1e			jp macro_next 
34c8				endm 
# End of macro NEXTW
34c8			 
34c8			.IS: 
34c8				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34c8 2d				db WORD_SYS_CORE+25             
34c9 ee 34			dw .LZERO            
34cb 03				db 2 + 1 
34cc .. 00			db "IS",0              
34cf				endm 
# End of macro CWHEAD
34cf			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34cf					if DEBUG_FORTH_WORDS_KEY 
34cf						DMARK "IS." 
34cf f5				push af  
34d0 3a e4 34			ld a, (.dmark)  
34d3 32 bd fb			ld (debug_mark),a  
34d6 3a e5 34			ld a, (.dmark+1)  
34d9 32 be fb			ld (debug_mark+1),a  
34dc 3a e6 34			ld a, (.dmark+2)  
34df 32 bf fb			ld (debug_mark+2),a  
34e2 18 03			jr .pastdmark  
34e4 ..			.dmark: db "IS."  
34e7 f1			.pastdmark: pop af  
34e8			endm  
# End of macro DMARK
34e8						CALLMONITOR 
34e8 cd ea 15			call break_point_state  
34eb				endm  
# End of macro CALLMONITOR
34eb					endif 
34eb					NEXTW 
34eb c3 e0 1e			jp macro_next 
34ee				endm 
# End of macro NEXTW
34ee			.LZERO: 
34ee				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34ee 2d				db WORD_SYS_CORE+25             
34ef f8 34			dw .TZERO            
34f1 03				db 2 + 1 
34f2 .. 00			db "0<",0              
34f5				endm 
# End of macro CWHEAD
34f5			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34f5					NEXTW 
34f5 c3 e0 1e			jp macro_next 
34f8				endm 
# End of macro NEXTW
34f8			.TZERO: 
34f8				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34f8 2e				db WORD_SYS_CORE+26             
34f9 3f 35			dw .LESS            
34fb 03				db 2 + 1 
34fc .. 00			db "0=",0              
34ff				endm 
# End of macro CWHEAD
34ff			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34ff				; TODO add floating point number detection 
34ff					;v5 FORTH_DSP_VALUE 
34ff					if DEBUG_FORTH_WORDS_KEY 
34ff						DMARK "0=." 
34ff f5				push af  
3500 3a 14 35			ld a, (.dmark)  
3503 32 bd fb			ld (debug_mark),a  
3506 3a 15 35			ld a, (.dmark+1)  
3509 32 be fb			ld (debug_mark+1),a  
350c 3a 16 35			ld a, (.dmark+2)  
350f 32 bf fb			ld (debug_mark+2),a  
3512 18 03			jr .pastdmark  
3514 ..			.dmark: db "0=."  
3517 f1			.pastdmark: pop af  
3518			endm  
# End of macro DMARK
3518						CALLMONITOR 
3518 cd ea 15			call break_point_state  
351b				endm  
# End of macro CALLMONITOR
351b					endif 
351b					FORTH_DSP 
351b cd 34 1d			call macro_forth_dsp 
351e				endm 
# End of macro FORTH_DSP
351e 7e					ld a,(hl)	; get type of value on TOS 
351f fe 02				cp DS_TYPE_INUM  
3521 28 00				jr z, .tz_inum 
3523			 
3523				if FORTH_ENABLE_FLOATMATH 
3523					jr .tz_done 
3523			 
3523				endif 
3523					 
3523			 
3523			.tz_inum: 
3523					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3523 cd 6e 1d			call macro_dsp_valuehl 
3526				endm 
# End of macro FORTH_DSP_VALUEHL
3526			 
3526			;		push hl 
3526			 
3526					; destroy value TOS 
3526			 
3526					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3526 cd 26 1e			call macro_forth_dsp_pop 
3529				endm 
# End of macro FORTH_DSP_POP
3529			 
3529			;		pop hl 
3529			 
3529 3e 00				ld a,0 
352b			 
352b bd					cp l 
352c 20 08				jr nz, .tz_notzero 
352e			 
352e bc					cp h 
352f			 
352f 20 05				jr nz, .tz_notzero 
3531			 
3531			 
3531 21 01 00				ld hl, FORTH_TRUE 
3534 18 03				jr .tz_done 
3536			 
3536 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3539			 
3539					; push value back onto stack for another op etc 
3539			 
3539			.tz_done: 
3539 cd 77 1b				call forth_push_numhl 
353c			 
353c					NEXTW 
353c c3 e0 1e			jp macro_next 
353f				endm 
# End of macro NEXTW
353f			.LESS: 
353f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
353f 2f				db WORD_SYS_CORE+27             
3540 a8 35			dw .GT            
3542 02				db 1 + 1 
3543 .. 00			db "<",0              
3545				endm 
# End of macro CWHEAD
3545			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3545				; TODO add floating point number detection 
3545					if DEBUG_FORTH_WORDS_KEY 
3545						DMARK "LES" 
3545 f5				push af  
3546 3a 5a 35			ld a, (.dmark)  
3549 32 bd fb			ld (debug_mark),a  
354c 3a 5b 35			ld a, (.dmark+1)  
354f 32 be fb			ld (debug_mark+1),a  
3552 3a 5c 35			ld a, (.dmark+2)  
3555 32 bf fb			ld (debug_mark+2),a  
3558 18 03			jr .pastdmark  
355a ..			.dmark: db "LES"  
355d f1			.pastdmark: pop af  
355e			endm  
# End of macro DMARK
355e						CALLMONITOR 
355e cd ea 15			call break_point_state  
3561				endm  
# End of macro CALLMONITOR
3561					endif 
3561					FORTH_DSP 
3561 cd 34 1d			call macro_forth_dsp 
3564				endm 
# End of macro FORTH_DSP
3564					;v5 FORTH_DSP_VALUE 
3564 7e					ld a,(hl)	; get type of value on TOS 
3565 fe 02				cp DS_TYPE_INUM  
3567 28 00				jr z, .less_inum 
3569			 
3569				if FORTH_ENABLE_FLOATMATH 
3569					jr .less_done 
3569			 
3569				endif 
3569					 
3569			 
3569			.less_inum: 
3569					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3569 cd 6e 1d			call macro_dsp_valuehl 
356c				endm 
# End of macro FORTH_DSP_VALUEHL
356c			 
356c e5					push hl  ; u2 
356d			 
356d					; destroy value TOS 
356d			 
356d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
356d cd 26 1e			call macro_forth_dsp_pop 
3570				endm 
# End of macro FORTH_DSP_POP
3570			 
3570			 
3570					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3570 cd 6e 1d			call macro_dsp_valuehl 
3573				endm 
# End of macro FORTH_DSP_VALUEHL
3573			 
3573 e5					push hl    ; u1 
3574			 
3574					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3574 cd 26 1e			call macro_forth_dsp_pop 
3577				endm 
# End of macro FORTH_DSP_POP
3577			 
3577			 
3577 b7			 or a      ;clear carry flag 
3578 01 00 00		 ld bc, FORTH_FALSE 
357b e1			  pop hl    ; u1 
357c d1			  pop de    ; u2 
357d ed 52		  sbc hl,de 
357f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3581			 
3581 01 01 00		 ld bc, FORTH_TRUE 
3584			.lscont:  
3584 c5					push bc 
3585 e1					pop hl 
3586			 
3586					if DEBUG_FORTH_WORDS 
3586						DMARK "LT1" 
3586 f5				push af  
3587 3a 9b 35			ld a, (.dmark)  
358a 32 bd fb			ld (debug_mark),a  
358d 3a 9c 35			ld a, (.dmark+1)  
3590 32 be fb			ld (debug_mark+1),a  
3593 3a 9d 35			ld a, (.dmark+2)  
3596 32 bf fb			ld (debug_mark+2),a  
3599 18 03			jr .pastdmark  
359b ..			.dmark: db "LT1"  
359e f1			.pastdmark: pop af  
359f			endm  
# End of macro DMARK
359f						CALLMONITOR 
359f cd ea 15			call break_point_state  
35a2				endm  
# End of macro CALLMONITOR
35a2					endif 
35a2 cd 77 1b				call forth_push_numhl 
35a5			 
35a5					NEXTW 
35a5 c3 e0 1e			jp macro_next 
35a8				endm 
# End of macro NEXTW
35a8			.GT: 
35a8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35a8 30				db WORD_SYS_CORE+28             
35a9 11 36			dw .EQUAL            
35ab 02				db 1 + 1 
35ac .. 00			db ">",0              
35ae				endm 
# End of macro CWHEAD
35ae			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35ae				; TODO add floating point number detection 
35ae					if DEBUG_FORTH_WORDS_KEY 
35ae						DMARK "GRT" 
35ae f5				push af  
35af 3a c3 35			ld a, (.dmark)  
35b2 32 bd fb			ld (debug_mark),a  
35b5 3a c4 35			ld a, (.dmark+1)  
35b8 32 be fb			ld (debug_mark+1),a  
35bb 3a c5 35			ld a, (.dmark+2)  
35be 32 bf fb			ld (debug_mark+2),a  
35c1 18 03			jr .pastdmark  
35c3 ..			.dmark: db "GRT"  
35c6 f1			.pastdmark: pop af  
35c7			endm  
# End of macro DMARK
35c7						CALLMONITOR 
35c7 cd ea 15			call break_point_state  
35ca				endm  
# End of macro CALLMONITOR
35ca					endif 
35ca					FORTH_DSP 
35ca cd 34 1d			call macro_forth_dsp 
35cd				endm 
# End of macro FORTH_DSP
35cd					;FORTH_DSP_VALUE 
35cd 7e					ld a,(hl)	; get type of value on TOS 
35ce fe 02				cp DS_TYPE_INUM  
35d0 28 00				jr z, .gt_inum 
35d2			 
35d2				if FORTH_ENABLE_FLOATMATH 
35d2					jr .gt_done 
35d2			 
35d2				endif 
35d2					 
35d2			 
35d2			.gt_inum: 
35d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d2 cd 6e 1d			call macro_dsp_valuehl 
35d5				endm 
# End of macro FORTH_DSP_VALUEHL
35d5			 
35d5 e5					push hl  ; u2 
35d6			 
35d6					; destroy value TOS 
35d6			 
35d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d6 cd 26 1e			call macro_forth_dsp_pop 
35d9				endm 
# End of macro FORTH_DSP_POP
35d9			 
35d9			 
35d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d9 cd 6e 1d			call macro_dsp_valuehl 
35dc				endm 
# End of macro FORTH_DSP_VALUEHL
35dc			 
35dc e5					push hl    ; u1 
35dd			 
35dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35dd cd 26 1e			call macro_forth_dsp_pop 
35e0				endm 
# End of macro FORTH_DSP_POP
35e0			 
35e0			 
35e0 b7			 or a      ;clear carry flag 
35e1 01 00 00		 ld bc, FORTH_FALSE 
35e4 e1			  pop hl    ; u1 
35e5 d1			  pop de    ; u2 
35e6 ed 52		  sbc hl,de 
35e8 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35ea			 
35ea 01 01 00		 ld bc, FORTH_TRUE 
35ed			.gtcont:  
35ed c5					push bc 
35ee e1					pop hl 
35ef			 
35ef					if DEBUG_FORTH_WORDS 
35ef						DMARK "GT1" 
35ef f5				push af  
35f0 3a 04 36			ld a, (.dmark)  
35f3 32 bd fb			ld (debug_mark),a  
35f6 3a 05 36			ld a, (.dmark+1)  
35f9 32 be fb			ld (debug_mark+1),a  
35fc 3a 06 36			ld a, (.dmark+2)  
35ff 32 bf fb			ld (debug_mark+2),a  
3602 18 03			jr .pastdmark  
3604 ..			.dmark: db "GT1"  
3607 f1			.pastdmark: pop af  
3608			endm  
# End of macro DMARK
3608						CALLMONITOR 
3608 cd ea 15			call break_point_state  
360b				endm  
# End of macro CALLMONITOR
360b					endif 
360b cd 77 1b				call forth_push_numhl 
360e			 
360e					NEXTW 
360e c3 e0 1e			jp macro_next 
3611				endm 
# End of macro NEXTW
3611			.EQUAL: 
3611				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3611 31				db WORD_SYS_CORE+29             
3612 7c 36			dw .ENDLOGIC            
3614 02				db 1 + 1 
3615 .. 00			db "=",0              
3617				endm 
# End of macro CWHEAD
3617			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3617				; TODO add floating point number detection 
3617					if DEBUG_FORTH_WORDS_KEY 
3617						DMARK "EQ." 
3617 f5				push af  
3618 3a 2c 36			ld a, (.dmark)  
361b 32 bd fb			ld (debug_mark),a  
361e 3a 2d 36			ld a, (.dmark+1)  
3621 32 be fb			ld (debug_mark+1),a  
3624 3a 2e 36			ld a, (.dmark+2)  
3627 32 bf fb			ld (debug_mark+2),a  
362a 18 03			jr .pastdmark  
362c ..			.dmark: db "EQ."  
362f f1			.pastdmark: pop af  
3630			endm  
# End of macro DMARK
3630						CALLMONITOR 
3630 cd ea 15			call break_point_state  
3633				endm  
# End of macro CALLMONITOR
3633					endif 
3633					FORTH_DSP 
3633 cd 34 1d			call macro_forth_dsp 
3636				endm 
# End of macro FORTH_DSP
3636					;v5 FORTH_DSP_VALUE 
3636 7e					ld a,(hl)	; get type of value on TOS 
3637 fe 02				cp DS_TYPE_INUM  
3639 28 00				jr z, .eq_inum 
363b			 
363b				if FORTH_ENABLE_FLOATMATH 
363b					jr .eq_done 
363b			 
363b				endif 
363b					 
363b			 
363b			.eq_inum: 
363b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
363b cd 6e 1d			call macro_dsp_valuehl 
363e				endm 
# End of macro FORTH_DSP_VALUEHL
363e			 
363e e5					push hl 
363f			 
363f					; destroy value TOS 
363f			 
363f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
363f cd 26 1e			call macro_forth_dsp_pop 
3642				endm 
# End of macro FORTH_DSP_POP
3642			 
3642			 
3642					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3642 cd 6e 1d			call macro_dsp_valuehl 
3645				endm 
# End of macro FORTH_DSP_VALUEHL
3645			 
3645					; one value on hl get other one back 
3645			 
3645 e5					push hl 
3646			 
3646					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3646 cd 26 1e			call macro_forth_dsp_pop 
3649				endm 
# End of macro FORTH_DSP_POP
3649			 
3649 0e 00				ld c, FORTH_FALSE 
364b			 
364b e1					pop hl 
364c d1					pop de 
364d			 
364d 7b					ld a, e 
364e bd					cp l 
364f			 
364f 20 06				jr nz, .eq_done 
3651			 
3651 7a					ld a, d 
3652 bc					cp h 
3653			 
3653 20 02				jr nz, .eq_done 
3655			 
3655 0e 01				ld c, FORTH_TRUE 
3657					 
3657			 
3657			 
3657			.eq_done: 
3657			 
3657					; TODO push value back onto stack for another op etc 
3657			 
3657 26 00				ld h, 0 
3659 69					ld l, c 
365a					if DEBUG_FORTH_WORDS 
365a						DMARK "EQ1" 
365a f5				push af  
365b 3a 6f 36			ld a, (.dmark)  
365e 32 bd fb			ld (debug_mark),a  
3661 3a 70 36			ld a, (.dmark+1)  
3664 32 be fb			ld (debug_mark+1),a  
3667 3a 71 36			ld a, (.dmark+2)  
366a 32 bf fb			ld (debug_mark+2),a  
366d 18 03			jr .pastdmark  
366f ..			.dmark: db "EQ1"  
3672 f1			.pastdmark: pop af  
3673			endm  
# End of macro DMARK
3673						CALLMONITOR 
3673 cd ea 15			call break_point_state  
3676				endm  
# End of macro CALLMONITOR
3676					endif 
3676 cd 77 1b				call forth_push_numhl 
3679			 
3679					NEXTW 
3679 c3 e0 1e			jp macro_next 
367c				endm 
# End of macro NEXTW
367c			 
367c			 
367c			.ENDLOGIC: 
367c			; eof 
367c			 
367c			 
# End of file forth_words_logic.asm
367c			include "forth_words_maths.asm" 
367c			 
367c			; | ## Maths Words 
367c			 
367c			.PLUS:	 
367c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
367c 15				db WORD_SYS_CORE+1             
367d be 36			dw .NEG            
367f 02				db 1 + 1 
3680 .. 00			db "+",0              
3682				endm 
# End of macro CWHEAD
3682			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3682					if DEBUG_FORTH_WORDS_KEY 
3682						DMARK "PLU" 
3682 f5				push af  
3683 3a 97 36			ld a, (.dmark)  
3686 32 bd fb			ld (debug_mark),a  
3689 3a 98 36			ld a, (.dmark+1)  
368c 32 be fb			ld (debug_mark+1),a  
368f 3a 99 36			ld a, (.dmark+2)  
3692 32 bf fb			ld (debug_mark+2),a  
3695 18 03			jr .pastdmark  
3697 ..			.dmark: db "PLU"  
369a f1			.pastdmark: pop af  
369b			endm  
# End of macro DMARK
369b						CALLMONITOR 
369b cd ea 15			call break_point_state  
369e				endm  
# End of macro CALLMONITOR
369e					endif 
369e					; add top two values and push back result 
369e			 
369e					;for v5 FORTH_DSP_VALUE 
369e					FORTH_DSP 
369e cd 34 1d			call macro_forth_dsp 
36a1				endm 
# End of macro FORTH_DSP
36a1 7e					ld a,(hl)	; get type of value on TOS 
36a2 fe 02				cp DS_TYPE_INUM  
36a4 28 03				jr z, .dot_inum 
36a6			 
36a6					NEXTW 
36a6 c3 e0 1e			jp macro_next 
36a9				endm 
# End of macro NEXTW
36a9			 
36a9			; float maths 
36a9			 
36a9				if FORTH_ENABLE_FLOATMATH 
36a9						inc hl      ; now at start of numeric as string 
36a9			 
36a9					if DEBUG_FORTH_MATHS 
36a9						DMARK "ADD" 
36a9				CALLMONITOR 
36a9					endif 
36a9			 
36a9					;ld ix, hl 
36a9					call CON 
36a9			 
36a9			 
36a9					push hl 
36a9					 
36a9					 
36a9			 
36a9						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36a9			 
36a9					; get next number 
36a9			 
36a9						FORTH_DSP_VALUE 
36a9			 
36a9						inc hl      ; now at start of numeric as string 
36a9			 
36a9					;ld ix, hl 
36a9					call CON 
36a9			 
36a9					push hl 
36a9			 
36a9			 
36a9						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a9			 
36a9						; TODO do add 
36a9			 
36a9						call IADD 
36a9			 
36a9						; TODO get result back as ascii 
36a9			 
36a9						; TODO push result  
36a9			 
36a9			 
36a9			 
36a9						jr .dot_done 
36a9				endif 
36a9			 
36a9			.dot_inum: 
36a9			 
36a9			 
36a9					if DEBUG_FORTH_DOT 
36a9						DMARK "+IT" 
36a9				CALLMONITOR 
36a9					endif 
36a9			 
36a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a9 cd 6e 1d			call macro_dsp_valuehl 
36ac				endm 
# End of macro FORTH_DSP_VALUEHL
36ac			 
36ac				; TODO add floating point number detection 
36ac			 
36ac e5					push hl 
36ad			 
36ad					; destroy value TOS 
36ad			 
36ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ad cd 26 1e			call macro_forth_dsp_pop 
36b0				endm 
# End of macro FORTH_DSP_POP
36b0			 
36b0			 
36b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b0 cd 6e 1d			call macro_dsp_valuehl 
36b3				endm 
# End of macro FORTH_DSP_VALUEHL
36b3			 
36b3					; one value on hl get other one back 
36b3			 
36b3 d1					pop de 
36b4			 
36b4					; do the add 
36b4			 
36b4 19					add hl,de 
36b5			 
36b5					; save it 
36b5			 
36b5			;		push hl	 
36b5			 
36b5					; 
36b5			 
36b5					; destroy value TOS 
36b5			 
36b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b5 cd 26 1e			call macro_forth_dsp_pop 
36b8				endm 
# End of macro FORTH_DSP_POP
36b8			 
36b8					; TODO push value back onto stack for another op etc 
36b8			 
36b8			;		pop hl 
36b8			 
36b8			.dot_done: 
36b8 cd 77 1b				call forth_push_numhl 
36bb			 
36bb					NEXTW 
36bb c3 e0 1e			jp macro_next 
36be				endm 
# End of macro NEXTW
36be			.NEG: 
36be			 
36be				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36be 17				db WORD_SYS_CORE+3             
36bf 01 37			dw .DIV            
36c1 02				db 1 + 1 
36c2 .. 00			db "-",0              
36c4				endm 
# End of macro CWHEAD
36c4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36c4					if DEBUG_FORTH_WORDS_KEY 
36c4						DMARK "SUB" 
36c4 f5				push af  
36c5 3a d9 36			ld a, (.dmark)  
36c8 32 bd fb			ld (debug_mark),a  
36cb 3a da 36			ld a, (.dmark+1)  
36ce 32 be fb			ld (debug_mark+1),a  
36d1 3a db 36			ld a, (.dmark+2)  
36d4 32 bf fb			ld (debug_mark+2),a  
36d7 18 03			jr .pastdmark  
36d9 ..			.dmark: db "SUB"  
36dc f1			.pastdmark: pop af  
36dd			endm  
# End of macro DMARK
36dd						CALLMONITOR 
36dd cd ea 15			call break_point_state  
36e0				endm  
# End of macro CALLMONITOR
36e0					endif 
36e0			 
36e0			 
36e0				; TODO add floating point number detection 
36e0					; v5 FORTH_DSP_VALUE 
36e0					FORTH_DSP 
36e0 cd 34 1d			call macro_forth_dsp 
36e3				endm 
# End of macro FORTH_DSP
36e3 7e					ld a,(hl)	; get type of value on TOS 
36e4 fe 02				cp DS_TYPE_INUM  
36e6 28 03				jr z, .neg_inum 
36e8			 
36e8					NEXTW 
36e8 c3 e0 1e			jp macro_next 
36eb				endm 
# End of macro NEXTW
36eb			 
36eb			; float maths 
36eb			 
36eb				if FORTH_ENABLE_FLOATMATH 
36eb					jr .neg_done 
36eb			 
36eb				endif 
36eb					 
36eb			 
36eb			.neg_inum: 
36eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36eb cd 6e 1d			call macro_dsp_valuehl 
36ee				endm 
# End of macro FORTH_DSP_VALUEHL
36ee			 
36ee e5					push hl 
36ef			 
36ef					; destroy value TOS 
36ef			 
36ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ef cd 26 1e			call macro_forth_dsp_pop 
36f2				endm 
# End of macro FORTH_DSP_POP
36f2			 
36f2			 
36f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f2 cd 6e 1d			call macro_dsp_valuehl 
36f5				endm 
# End of macro FORTH_DSP_VALUEHL
36f5			 
36f5					; one value on hl get other one back 
36f5			 
36f5 d1					pop de 
36f6			 
36f6					; do the sub 
36f6			;		ex de, hl 
36f6			 
36f6 ed 52				sbc hl,de 
36f8			 
36f8					; save it 
36f8			 
36f8			;		push hl	 
36f8			 
36f8					; 
36f8			 
36f8					; destroy value TOS 
36f8			 
36f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f8 cd 26 1e			call macro_forth_dsp_pop 
36fb				endm 
# End of macro FORTH_DSP_POP
36fb			 
36fb					; TODO push value back onto stack for another op etc 
36fb			 
36fb			;		pop hl 
36fb			 
36fb cd 77 1b				call forth_push_numhl 
36fe			.neg_done: 
36fe			 
36fe					NEXTW 
36fe c3 e0 1e			jp macro_next 
3701				endm 
# End of macro NEXTW
3701			.DIV: 
3701				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3701 18				db WORD_SYS_CORE+4             
3702 4e 37			dw .MUL            
3704 02				db 1 + 1 
3705 .. 00			db "/",0              
3707				endm 
# End of macro CWHEAD
3707			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3707					if DEBUG_FORTH_WORDS_KEY 
3707						DMARK "DIV" 
3707 f5				push af  
3708 3a 1c 37			ld a, (.dmark)  
370b 32 bd fb			ld (debug_mark),a  
370e 3a 1d 37			ld a, (.dmark+1)  
3711 32 be fb			ld (debug_mark+1),a  
3714 3a 1e 37			ld a, (.dmark+2)  
3717 32 bf fb			ld (debug_mark+2),a  
371a 18 03			jr .pastdmark  
371c ..			.dmark: db "DIV"  
371f f1			.pastdmark: pop af  
3720			endm  
# End of macro DMARK
3720						CALLMONITOR 
3720 cd ea 15			call break_point_state  
3723				endm  
# End of macro CALLMONITOR
3723					endif 
3723				; TODO add floating point number detection 
3723					; v5 FORTH_DSP_VALUE 
3723					FORTH_DSP 
3723 cd 34 1d			call macro_forth_dsp 
3726				endm 
# End of macro FORTH_DSP
3726 7e					ld a,(hl)	; get type of value on TOS 
3727 fe 02				cp DS_TYPE_INUM  
3729 28 03				jr z, .div_inum 
372b			 
372b				if FORTH_ENABLE_FLOATMATH 
372b					jr .div_done 
372b			 
372b				endif 
372b					NEXTW 
372b c3 e0 1e			jp macro_next 
372e				endm 
# End of macro NEXTW
372e			.div_inum: 
372e			 
372e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372e cd 6e 1d			call macro_dsp_valuehl 
3731				endm 
# End of macro FORTH_DSP_VALUEHL
3731			 
3731 e5					push hl    ; to go to bc 
3732			 
3732					; destroy value TOS 
3732			 
3732					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3732 cd 26 1e			call macro_forth_dsp_pop 
3735				endm 
# End of macro FORTH_DSP_POP
3735			 
3735			 
3735					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3735 cd 6e 1d			call macro_dsp_valuehl 
3738				endm 
# End of macro FORTH_DSP_VALUEHL
3738			 
3738					; hl to go to de 
3738			 
3738 e5					push hl 
3739			 
3739 c1					pop bc 
373a d1					pop de		 
373b			 
373b			 
373b					if DEBUG_FORTH_MATHS 
373b						DMARK "DIV" 
373b				CALLMONITOR 
373b					endif 
373b					; one value on hl but move to a get other one back 
373b			 
373b			        
373b cd 25 0c			call Div16 
373e			 
373e			;	push af	 
373e e5				push hl 
373f c5				push bc 
3740			 
3740					if DEBUG_FORTH_MATHS 
3740						DMARK "DI1" 
3740				CALLMONITOR 
3740					endif 
3740			 
3740					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3740 cd 26 1e			call macro_forth_dsp_pop 
3743				endm 
# End of macro FORTH_DSP_POP
3743			 
3743			 
3743			 
3743 e1					pop hl    ; result 
3744			 
3744 cd 77 1b				call forth_push_numhl 
3747			 
3747 e1					pop hl    ; reminder 
3748			;		ld h,0 
3748			;		ld l,d 
3748			 
3748 cd 77 1b				call forth_push_numhl 
374b			.div_done: 
374b					NEXTW 
374b c3 e0 1e			jp macro_next 
374e				endm 
# End of macro NEXTW
374e			.MUL: 
374e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
374e 19				db WORD_SYS_CORE+5             
374f 93 37			dw .MIN            
3751 02				db 1 + 1 
3752 .. 00			db "*",0              
3754				endm 
# End of macro CWHEAD
3754			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3754				; TODO add floating point number detection 
3754					if DEBUG_FORTH_WORDS_KEY 
3754						DMARK "MUL" 
3754 f5				push af  
3755 3a 69 37			ld a, (.dmark)  
3758 32 bd fb			ld (debug_mark),a  
375b 3a 6a 37			ld a, (.dmark+1)  
375e 32 be fb			ld (debug_mark+1),a  
3761 3a 6b 37			ld a, (.dmark+2)  
3764 32 bf fb			ld (debug_mark+2),a  
3767 18 03			jr .pastdmark  
3769 ..			.dmark: db "MUL"  
376c f1			.pastdmark: pop af  
376d			endm  
# End of macro DMARK
376d						CALLMONITOR 
376d cd ea 15			call break_point_state  
3770				endm  
# End of macro CALLMONITOR
3770					endif 
3770					FORTH_DSP 
3770 cd 34 1d			call macro_forth_dsp 
3773				endm 
# End of macro FORTH_DSP
3773					; v5 FORTH_DSP_VALUE 
3773 7e					ld a,(hl)	; get type of value on TOS 
3774 fe 02				cp DS_TYPE_INUM  
3776 28 03				jr z, .mul_inum 
3778			 
3778				if FORTH_ENABLE_FLOATMATH 
3778					jr .mul_done 
3778			 
3778				endif 
3778			 
3778					NEXTW 
3778 c3 e0 1e			jp macro_next 
377b				endm 
# End of macro NEXTW
377b			.mul_inum:	 
377b			 
377b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377b cd 6e 1d			call macro_dsp_valuehl 
377e				endm 
# End of macro FORTH_DSP_VALUEHL
377e			 
377e e5					push hl 
377f			 
377f					; destroy value TOS 
377f			 
377f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377f cd 26 1e			call macro_forth_dsp_pop 
3782				endm 
# End of macro FORTH_DSP_POP
3782			 
3782			 
3782					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3782 cd 6e 1d			call macro_dsp_valuehl 
3785				endm 
# End of macro FORTH_DSP_VALUEHL
3785			 
3785					; one value on hl but move to a get other one back 
3785			 
3785 7d					ld a, l 
3786			 
3786 d1					pop de 
3787			 
3787					; do the mull 
3787			;		ex de, hl 
3787			 
3787 cd 4b 0c				call Mult16 
378a					; save it 
378a			 
378a			;		push hl	 
378a			 
378a					; 
378a			 
378a					; destroy value TOS 
378a			 
378a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378a cd 26 1e			call macro_forth_dsp_pop 
378d				endm 
# End of macro FORTH_DSP_POP
378d			 
378d					; TODO push value back onto stack for another op etc 
378d			 
378d			;		pop hl 
378d			 
378d cd 77 1b				call forth_push_numhl 
3790			 
3790			.mul_done: 
3790					NEXTW 
3790 c3 e0 1e			jp macro_next 
3793				endm 
# End of macro NEXTW
3793			 
3793			 
3793			 
3793			 
3793			.MIN: 
3793				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3793 49				db WORD_SYS_CORE+53             
3794 14 38			dw .MAX            
3796 04				db 3 + 1 
3797 .. 00			db "MIN",0              
379b				endm 
# End of macro CWHEAD
379b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
379b					if DEBUG_FORTH_WORDS_KEY 
379b						DMARK "MIN" 
379b f5				push af  
379c 3a b0 37			ld a, (.dmark)  
379f 32 bd fb			ld (debug_mark),a  
37a2 3a b1 37			ld a, (.dmark+1)  
37a5 32 be fb			ld (debug_mark+1),a  
37a8 3a b2 37			ld a, (.dmark+2)  
37ab 32 bf fb			ld (debug_mark+2),a  
37ae 18 03			jr .pastdmark  
37b0 ..			.dmark: db "MIN"  
37b3 f1			.pastdmark: pop af  
37b4			endm  
# End of macro DMARK
37b4						CALLMONITOR 
37b4 cd ea 15			call break_point_state  
37b7				endm  
# End of macro CALLMONITOR
37b7					endif 
37b7					; get u2 
37b7			 
37b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b7 cd 6e 1d			call macro_dsp_valuehl 
37ba				endm 
# End of macro FORTH_DSP_VALUEHL
37ba			 
37ba e5					push hl   ; u2 
37bb			 
37bb					; destroy value TOS 
37bb			 
37bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37bb cd 26 1e			call macro_forth_dsp_pop 
37be				endm 
# End of macro FORTH_DSP_POP
37be			 
37be					; get u1 
37be			 
37be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37be cd 6e 1d			call macro_dsp_valuehl 
37c1				endm 
# End of macro FORTH_DSP_VALUEHL
37c1			 
37c1 e5					push hl  ; u1 
37c2			 
37c2					; destroy value TOS 
37c2			 
37c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c2 cd 26 1e			call macro_forth_dsp_pop 
37c5				endm 
# End of macro FORTH_DSP_POP
37c5			 
37c5 b7			 or a      ;clear carry flag 
37c6 e1			  pop hl    ; u1 
37c7 d1			  pop de    ; u2 
37c8 e5				push hl   ; saved in case hl is lowest 
37c9 ed 52		  sbc hl,de 
37cb 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37cd			 
37cd e1				pop hl 
37ce					if DEBUG_FORTH_WORDS 
37ce						DMARK "MIN" 
37ce f5				push af  
37cf 3a e3 37			ld a, (.dmark)  
37d2 32 bd fb			ld (debug_mark),a  
37d5 3a e4 37			ld a, (.dmark+1)  
37d8 32 be fb			ld (debug_mark+1),a  
37db 3a e5 37			ld a, (.dmark+2)  
37de 32 bf fb			ld (debug_mark+2),a  
37e1 18 03			jr .pastdmark  
37e3 ..			.dmark: db "MIN"  
37e6 f1			.pastdmark: pop af  
37e7			endm  
# End of macro DMARK
37e7						CALLMONITOR 
37e7 cd ea 15			call break_point_state  
37ea				endm  
# End of macro CALLMONITOR
37ea					endif 
37ea cd 77 1b				call forth_push_numhl 
37ed			 
37ed				       NEXTW 
37ed c3 e0 1e			jp macro_next 
37f0				endm 
# End of macro NEXTW
37f0			 
37f0			.mincont:  
37f0 c1				pop bc   ; tidy up 
37f1 eb				ex de , hl  
37f2					if DEBUG_FORTH_WORDS 
37f2						DMARK "MI1" 
37f2 f5				push af  
37f3 3a 07 38			ld a, (.dmark)  
37f6 32 bd fb			ld (debug_mark),a  
37f9 3a 08 38			ld a, (.dmark+1)  
37fc 32 be fb			ld (debug_mark+1),a  
37ff 3a 09 38			ld a, (.dmark+2)  
3802 32 bf fb			ld (debug_mark+2),a  
3805 18 03			jr .pastdmark  
3807 ..			.dmark: db "MI1"  
380a f1			.pastdmark: pop af  
380b			endm  
# End of macro DMARK
380b						CALLMONITOR 
380b cd ea 15			call break_point_state  
380e				endm  
# End of macro CALLMONITOR
380e					endif 
380e cd 77 1b				call forth_push_numhl 
3811			 
3811				       NEXTW 
3811 c3 e0 1e			jp macro_next 
3814				endm 
# End of macro NEXTW
3814			.MAX: 
3814				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3814 4a				db WORD_SYS_CORE+54             
3815 95 38			dw .RND16            
3817 04				db 3 + 1 
3818 .. 00			db "MAX",0              
381c				endm 
# End of macro CWHEAD
381c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
381c					if DEBUG_FORTH_WORDS_KEY 
381c						DMARK "MAX" 
381c f5				push af  
381d 3a 31 38			ld a, (.dmark)  
3820 32 bd fb			ld (debug_mark),a  
3823 3a 32 38			ld a, (.dmark+1)  
3826 32 be fb			ld (debug_mark+1),a  
3829 3a 33 38			ld a, (.dmark+2)  
382c 32 bf fb			ld (debug_mark+2),a  
382f 18 03			jr .pastdmark  
3831 ..			.dmark: db "MAX"  
3834 f1			.pastdmark: pop af  
3835			endm  
# End of macro DMARK
3835						CALLMONITOR 
3835 cd ea 15			call break_point_state  
3838				endm  
# End of macro CALLMONITOR
3838					endif 
3838					; get u2 
3838			 
3838					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3838 cd 6e 1d			call macro_dsp_valuehl 
383b				endm 
# End of macro FORTH_DSP_VALUEHL
383b			 
383b e5					push hl   ; u2 
383c			 
383c					; destroy value TOS 
383c			 
383c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383c cd 26 1e			call macro_forth_dsp_pop 
383f				endm 
# End of macro FORTH_DSP_POP
383f			 
383f					; get u1 
383f			 
383f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383f cd 6e 1d			call macro_dsp_valuehl 
3842				endm 
# End of macro FORTH_DSP_VALUEHL
3842			 
3842 e5					push hl  ; u1 
3843			 
3843					; destroy value TOS 
3843			 
3843					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3843 cd 26 1e			call macro_forth_dsp_pop 
3846				endm 
# End of macro FORTH_DSP_POP
3846			 
3846 b7			 or a      ;clear carry flag 
3847 e1			  pop hl    ; u1 
3848 d1			  pop de    ; u2 
3849 e5				push hl   ; saved in case hl is lowest 
384a ed 52		  sbc hl,de 
384c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
384e			 
384e e1				pop hl 
384f					if DEBUG_FORTH_WORDS 
384f						DMARK "MAX" 
384f f5				push af  
3850 3a 64 38			ld a, (.dmark)  
3853 32 bd fb			ld (debug_mark),a  
3856 3a 65 38			ld a, (.dmark+1)  
3859 32 be fb			ld (debug_mark+1),a  
385c 3a 66 38			ld a, (.dmark+2)  
385f 32 bf fb			ld (debug_mark+2),a  
3862 18 03			jr .pastdmark  
3864 ..			.dmark: db "MAX"  
3867 f1			.pastdmark: pop af  
3868			endm  
# End of macro DMARK
3868						CALLMONITOR 
3868 cd ea 15			call break_point_state  
386b				endm  
# End of macro CALLMONITOR
386b					endif 
386b cd 77 1b				call forth_push_numhl 
386e			 
386e				       NEXTW 
386e c3 e0 1e			jp macro_next 
3871				endm 
# End of macro NEXTW
3871			 
3871			.maxcont:  
3871 c1				pop bc   ; tidy up 
3872 eb				ex de , hl  
3873					if DEBUG_FORTH_WORDS 
3873						DMARK "MA1" 
3873 f5				push af  
3874 3a 88 38			ld a, (.dmark)  
3877 32 bd fb			ld (debug_mark),a  
387a 3a 89 38			ld a, (.dmark+1)  
387d 32 be fb			ld (debug_mark+1),a  
3880 3a 8a 38			ld a, (.dmark+2)  
3883 32 bf fb			ld (debug_mark+2),a  
3886 18 03			jr .pastdmark  
3888 ..			.dmark: db "MA1"  
388b f1			.pastdmark: pop af  
388c			endm  
# End of macro DMARK
388c						CALLMONITOR 
388c cd ea 15			call break_point_state  
388f				endm  
# End of macro CALLMONITOR
388f					endif 
388f cd 77 1b				call forth_push_numhl 
3892				       NEXTW 
3892 c3 e0 1e			jp macro_next 
3895				endm 
# End of macro NEXTW
3895			 
3895			.RND16: 
3895				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3895 4e				db WORD_SYS_CORE+58             
3896 c4 38			dw .RND8            
3898 06				db 5 + 1 
3899 .. 00			db "RND16",0              
389f				endm 
# End of macro CWHEAD
389f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
389f					if DEBUG_FORTH_WORDS_KEY 
389f						DMARK "R16" 
389f f5				push af  
38a0 3a b4 38			ld a, (.dmark)  
38a3 32 bd fb			ld (debug_mark),a  
38a6 3a b5 38			ld a, (.dmark+1)  
38a9 32 be fb			ld (debug_mark+1),a  
38ac 3a b6 38			ld a, (.dmark+2)  
38af 32 bf fb			ld (debug_mark+2),a  
38b2 18 03			jr .pastdmark  
38b4 ..			.dmark: db "R16"  
38b7 f1			.pastdmark: pop af  
38b8			endm  
# End of macro DMARK
38b8						CALLMONITOR 
38b8 cd ea 15			call break_point_state  
38bb				endm  
# End of macro CALLMONITOR
38bb					endif 
38bb cd ef 0b				call prng16  
38be cd 77 1b				call forth_push_numhl 
38c1				       NEXTW 
38c1 c3 e0 1e			jp macro_next 
38c4				endm 
# End of macro NEXTW
38c4			.RND8: 
38c4				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38c4 60				db WORD_SYS_CORE+76             
38c5 f9 38			dw .RND            
38c7 05				db 4 + 1 
38c8 .. 00			db "RND8",0              
38cd				endm 
# End of macro CWHEAD
38cd			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38cd					if DEBUG_FORTH_WORDS_KEY 
38cd						DMARK "RN8" 
38cd f5				push af  
38ce 3a e2 38			ld a, (.dmark)  
38d1 32 bd fb			ld (debug_mark),a  
38d4 3a e3 38			ld a, (.dmark+1)  
38d7 32 be fb			ld (debug_mark+1),a  
38da 3a e4 38			ld a, (.dmark+2)  
38dd 32 bf fb			ld (debug_mark+2),a  
38e0 18 03			jr .pastdmark  
38e2 ..			.dmark: db "RN8"  
38e5 f1			.pastdmark: pop af  
38e6			endm  
# End of macro DMARK
38e6						CALLMONITOR 
38e6 cd ea 15			call break_point_state  
38e9				endm  
# End of macro CALLMONITOR
38e9					endif 
38e9 2a 3e fa				ld hl,(xrandc) 
38ec 23					inc hl 
38ed cd 09 0c				call xrnd 
38f0 6f					ld l,a	 
38f1 26 00				ld h,0 
38f3 cd 77 1b				call forth_push_numhl 
38f6				       NEXTW 
38f6 c3 e0 1e			jp macro_next 
38f9				endm 
# End of macro NEXTW
38f9			.RND: 
38f9				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38f9 60				db WORD_SYS_CORE+76             
38fa ff 39			dw .ENDMATHS            
38fc 04				db 3 + 1 
38fd .. 00			db "RND",0              
3901				endm 
# End of macro CWHEAD
3901			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3901			 
3901					if DEBUG_FORTH_WORDS_KEY 
3901						DMARK "RND" 
3901 f5				push af  
3902 3a 16 39			ld a, (.dmark)  
3905 32 bd fb			ld (debug_mark),a  
3908 3a 17 39			ld a, (.dmark+1)  
390b 32 be fb			ld (debug_mark+1),a  
390e 3a 18 39			ld a, (.dmark+2)  
3911 32 bf fb			ld (debug_mark+2),a  
3914 18 03			jr .pastdmark  
3916 ..			.dmark: db "RND"  
3919 f1			.pastdmark: pop af  
391a			endm  
# End of macro DMARK
391a						CALLMONITOR 
391a cd ea 15			call break_point_state  
391d				endm  
# End of macro CALLMONITOR
391d					endif 
391d					 
391d					FORTH_DSP_VALUEHL    ; upper range 
391d cd 6e 1d			call macro_dsp_valuehl 
3920				endm 
# End of macro FORTH_DSP_VALUEHL
3920			 
3920 22 42 fa				ld (LFSRSeed), hl	 
3923			 
3923					if DEBUG_FORTH_WORDS 
3923						DMARK "RN1" 
3923 f5				push af  
3924 3a 38 39			ld a, (.dmark)  
3927 32 bd fb			ld (debug_mark),a  
392a 3a 39 39			ld a, (.dmark+1)  
392d 32 be fb			ld (debug_mark+1),a  
3930 3a 3a 39			ld a, (.dmark+2)  
3933 32 bf fb			ld (debug_mark+2),a  
3936 18 03			jr .pastdmark  
3938 ..			.dmark: db "RN1"  
393b f1			.pastdmark: pop af  
393c			endm  
# End of macro DMARK
393c						CALLMONITOR 
393c cd ea 15			call break_point_state  
393f				endm  
# End of macro CALLMONITOR
393f					endif 
393f					FORTH_DSP_POP 
393f cd 26 1e			call macro_forth_dsp_pop 
3942				endm 
# End of macro FORTH_DSP_POP
3942			 
3942					FORTH_DSP_VALUEHL    ; low range 
3942 cd 6e 1d			call macro_dsp_valuehl 
3945				endm 
# End of macro FORTH_DSP_VALUEHL
3945			 
3945					if DEBUG_FORTH_WORDS 
3945						DMARK "RN2" 
3945 f5				push af  
3946 3a 5a 39			ld a, (.dmark)  
3949 32 bd fb			ld (debug_mark),a  
394c 3a 5b 39			ld a, (.dmark+1)  
394f 32 be fb			ld (debug_mark+1),a  
3952 3a 5c 39			ld a, (.dmark+2)  
3955 32 bf fb			ld (debug_mark+2),a  
3958 18 03			jr .pastdmark  
395a ..			.dmark: db "RN2"  
395d f1			.pastdmark: pop af  
395e			endm  
# End of macro DMARK
395e						CALLMONITOR 
395e cd ea 15			call break_point_state  
3961				endm  
# End of macro CALLMONITOR
3961					endif 
3961 22 44 fa				ld (LFSRSeed+2), hl 
3964			 
3964					FORTH_DSP_POP 
3964 cd 26 1e			call macro_forth_dsp_pop 
3967				endm 
# End of macro FORTH_DSP_POP
3967			 
3967 e5					push hl 
3968			 
3968 e1			.inrange:	pop hl 
3969 cd ef 0b				call prng16  
396c					if DEBUG_FORTH_WORDS 
396c						DMARK "RN3" 
396c f5				push af  
396d 3a 81 39			ld a, (.dmark)  
3970 32 bd fb			ld (debug_mark),a  
3973 3a 82 39			ld a, (.dmark+1)  
3976 32 be fb			ld (debug_mark+1),a  
3979 3a 83 39			ld a, (.dmark+2)  
397c 32 bf fb			ld (debug_mark+2),a  
397f 18 03			jr .pastdmark  
3981 ..			.dmark: db "RN3"  
3984 f1			.pastdmark: pop af  
3985			endm  
# End of macro DMARK
3985						CALLMONITOR 
3985 cd ea 15			call break_point_state  
3988				endm  
# End of macro CALLMONITOR
3988					endif 
3988					 
3988					; if the range is 8bit knock out the high byte 
3988			 
3988 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
398c			 
398c 3e 00				ld a, 0 
398e ba					cp d  
398f 20 1e				jr nz, .hirange 
3991 26 00				ld h, 0   ; knock it down to 8bit 
3993			 
3993					if DEBUG_FORTH_WORDS 
3993						DMARK "RNk" 
3993 f5				push af  
3994 3a a8 39			ld a, (.dmark)  
3997 32 bd fb			ld (debug_mark),a  
399a 3a a9 39			ld a, (.dmark+1)  
399d 32 be fb			ld (debug_mark+1),a  
39a0 3a aa 39			ld a, (.dmark+2)  
39a3 32 bf fb			ld (debug_mark+2),a  
39a6 18 03			jr .pastdmark  
39a8 ..			.dmark: db "RNk"  
39ab f1			.pastdmark: pop af  
39ac			endm  
# End of macro DMARK
39ac						CALLMONITOR 
39ac cd ea 15			call break_point_state  
39af				endm  
# End of macro CALLMONITOR
39af					endif 
39af			.hirange:   
39af e5					push hl  
39b0 b7					or a  
39b1 ed 52		                sbc hl, de 
39b3			 
39b3					;call cmp16 
39b3			 
39b3 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39b5 e1					pop hl 
39b6 e5					push hl 
39b7			 
39b7					if DEBUG_FORTH_WORDS 
39b7						DMARK "RN4" 
39b7 f5				push af  
39b8 3a cc 39			ld a, (.dmark)  
39bb 32 bd fb			ld (debug_mark),a  
39be 3a cd 39			ld a, (.dmark+1)  
39c1 32 be fb			ld (debug_mark+1),a  
39c4 3a ce 39			ld a, (.dmark+2)  
39c7 32 bf fb			ld (debug_mark+2),a  
39ca 18 03			jr .pastdmark  
39cc ..			.dmark: db "RN4"  
39cf f1			.pastdmark: pop af  
39d0			endm  
# End of macro DMARK
39d0						CALLMONITOR 
39d0 cd ea 15			call break_point_state  
39d3				endm  
# End of macro CALLMONITOR
39d3					endif 
39d3 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
39d7					;call cmp16 
39d7				 
39d7 b7					or a  
39d8 ed 52		                sbc hl, de 
39da 38 8c				jr c, .inrange 
39dc			 
39dc e1					pop hl 
39dd					 
39dd					if DEBUG_FORTH_WORDS 
39dd						DMARK "RNd" 
39dd f5				push af  
39de 3a f2 39			ld a, (.dmark)  
39e1 32 bd fb			ld (debug_mark),a  
39e4 3a f3 39			ld a, (.dmark+1)  
39e7 32 be fb			ld (debug_mark+1),a  
39ea 3a f4 39			ld a, (.dmark+2)  
39ed 32 bf fb			ld (debug_mark+2),a  
39f0 18 03			jr .pastdmark  
39f2 ..			.dmark: db "RNd"  
39f5 f1			.pastdmark: pop af  
39f6			endm  
# End of macro DMARK
39f6						CALLMONITOR 
39f6 cd ea 15			call break_point_state  
39f9				endm  
# End of macro CALLMONITOR
39f9					endif 
39f9			 
39f9			 
39f9 cd 77 1b				call forth_push_numhl 
39fc				       NEXTW 
39fc c3 e0 1e			jp macro_next 
39ff				endm 
# End of macro NEXTW
39ff			 
39ff			.ENDMATHS: 
39ff			 
39ff			; eof 
39ff			 
# End of file forth_words_maths.asm
39ff			include "forth_words_display.asm" 
39ff			 
39ff			; | ## Display Words 
39ff			 
39ff			.ATP: 
39ff				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
39ff 62				db WORD_SYS_CORE+78             
3a00 76 3a			dw .FB            
3a02 04				db 3 + 1 
3a03 .. 00			db "AT?",0              
3a07				endm 
# End of macro CWHEAD
3a07			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a07					if DEBUG_FORTH_WORDS_KEY 
3a07						DMARK "AT?" 
3a07 f5				push af  
3a08 3a 1c 3a			ld a, (.dmark)  
3a0b 32 bd fb			ld (debug_mark),a  
3a0e 3a 1d 3a			ld a, (.dmark+1)  
3a11 32 be fb			ld (debug_mark+1),a  
3a14 3a 1e 3a			ld a, (.dmark+2)  
3a17 32 bf fb			ld (debug_mark+2),a  
3a1a 18 03			jr .pastdmark  
3a1c ..			.dmark: db "AT?"  
3a1f f1			.pastdmark: pop af  
3a20			endm  
# End of macro DMARK
3a20						CALLMONITOR 
3a20 cd ea 15			call break_point_state  
3a23				endm  
# End of macro CALLMONITOR
3a23					endif 
3a23 3a cc f9				ld a, (f_cursor_ptr) 
3a26			 
3a26			if DEBUG_FORTH_WORDS 
3a26				DMARK "AT?" 
3a26 f5				push af  
3a27 3a 3b 3a			ld a, (.dmark)  
3a2a 32 bd fb			ld (debug_mark),a  
3a2d 3a 3c 3a			ld a, (.dmark+1)  
3a30 32 be fb			ld (debug_mark+1),a  
3a33 3a 3d 3a			ld a, (.dmark+2)  
3a36 32 bf fb			ld (debug_mark+2),a  
3a39 18 03			jr .pastdmark  
3a3b ..			.dmark: db "AT?"  
3a3e f1			.pastdmark: pop af  
3a3f			endm  
# End of macro DMARK
3a3f				CALLMONITOR 
3a3f cd ea 15			call break_point_state  
3a42				endm  
# End of macro CALLMONITOR
3a42			endif	 
3a42					; count the number of rows 
3a42			 
3a42 06 00				ld b, 0 
3a44 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a45 d6 14				sub display_cols 
3a47 f2 4d 3a				jp p, .atprunder 
3a4a 04					inc b 
3a4b 18 f7				jr .atpr 
3a4d			.atprunder:	 
3a4d			if DEBUG_FORTH_WORDS 
3a4d				DMARK "A?2" 
3a4d f5				push af  
3a4e 3a 62 3a			ld a, (.dmark)  
3a51 32 bd fb			ld (debug_mark),a  
3a54 3a 63 3a			ld a, (.dmark+1)  
3a57 32 be fb			ld (debug_mark+1),a  
3a5a 3a 64 3a			ld a, (.dmark+2)  
3a5d 32 bf fb			ld (debug_mark+2),a  
3a60 18 03			jr .pastdmark  
3a62 ..			.dmark: db "A?2"  
3a65 f1			.pastdmark: pop af  
3a66			endm  
# End of macro DMARK
3a66				CALLMONITOR 
3a66 cd ea 15			call break_point_state  
3a69				endm  
# End of macro CALLMONITOR
3a69			endif	 
3a69 26 00				ld h, 0 
3a6b 69					ld l, c 
3a6c cd 77 1b				call forth_push_numhl 
3a6f 68					ld l, b  
3a70 cd 77 1b				call forth_push_numhl 
3a73			 
3a73			 
3a73				NEXTW 
3a73 c3 e0 1e			jp macro_next 
3a76				endm 
# End of macro NEXTW
3a76			 
3a76			.FB: 
3a76				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a76 1b				db WORD_SYS_CORE+7             
3a77 c4 3a			dw .EMIT            
3a79 03				db 2 + 1 
3a7a .. 00			db "FB",0              
3a7d				endm 
# End of macro CWHEAD
3a7d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a7d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a7d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a7d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a7d					if DEBUG_FORTH_WORDS_KEY 
3a7d						DMARK "FB." 
3a7d f5				push af  
3a7e 3a 92 3a			ld a, (.dmark)  
3a81 32 bd fb			ld (debug_mark),a  
3a84 3a 93 3a			ld a, (.dmark+1)  
3a87 32 be fb			ld (debug_mark+1),a  
3a8a 3a 94 3a			ld a, (.dmark+2)  
3a8d 32 bf fb			ld (debug_mark+2),a  
3a90 18 03			jr .pastdmark  
3a92 ..			.dmark: db "FB."  
3a95 f1			.pastdmark: pop af  
3a96			endm  
# End of macro DMARK
3a96						CALLMONITOR 
3a96 cd ea 15			call break_point_state  
3a99				endm  
# End of macro CALLMONITOR
3a99					endif 
3a99			 
3a99					FORTH_DSP_VALUEHL 
3a99 cd 6e 1d			call macro_dsp_valuehl 
3a9c				endm 
# End of macro FORTH_DSP_VALUEHL
3a9c			 
3a9c 7d					ld a, l 
3a9d fe 01				cp 1 
3a9f 20 05				jr nz, .fbn1 
3aa1 21 02 fb				ld hl, display_fb1 
3aa4 18 15				jr .fbset 
3aa6 fe 02		.fbn1:		cp 2 
3aa8 20 05				jr nz, .fbn2 
3aaa 21 60 fa				ld hl, display_fb2 
3aad 18 0c				jr .fbset 
3aaf fe 03		.fbn2:		cp 3 
3ab1 20 05				jr nz, .fbn3 
3ab3 21 b1 fa				ld hl, display_fb3 
3ab6 18 03				jr .fbset 
3ab8			.fbn3:		 ; if invalid number select first 
3ab8 21 02 fb				ld hl, display_fb1 
3abb 22 5e fa		.fbset:		ld (display_fb_active), hl 
3abe			 
3abe					FORTH_DSP_POP 
3abe cd 26 1e			call macro_forth_dsp_pop 
3ac1				endm 
# End of macro FORTH_DSP_POP
3ac1			 
3ac1					NEXTW 
3ac1 c3 e0 1e			jp macro_next 
3ac4				endm 
# End of macro NEXTW
3ac4			 
3ac4			 
3ac4			.EMIT: 
3ac4				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3ac4 1b				db WORD_SYS_CORE+7             
3ac5 15 3b			dw .DOTH            
3ac7 05				db 4 + 1 
3ac8 .. 00			db "EMIT",0              
3acd				endm 
# End of macro CWHEAD
3acd			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3acd					; get value off TOS and display it 
3acd			 
3acd					if DEBUG_FORTH_WORDS_KEY 
3acd						DMARK "EMT" 
3acd f5				push af  
3ace 3a e2 3a			ld a, (.dmark)  
3ad1 32 bd fb			ld (debug_mark),a  
3ad4 3a e3 3a			ld a, (.dmark+1)  
3ad7 32 be fb			ld (debug_mark+1),a  
3ada 3a e4 3a			ld a, (.dmark+2)  
3add 32 bf fb			ld (debug_mark+2),a  
3ae0 18 03			jr .pastdmark  
3ae2 ..			.dmark: db "EMT"  
3ae5 f1			.pastdmark: pop af  
3ae6			endm  
# End of macro DMARK
3ae6						CALLMONITOR 
3ae6 cd ea 15			call break_point_state  
3ae9				endm  
# End of macro CALLMONITOR
3ae9					endif 
3ae9			 
3ae9					FORTH_DSP_VALUEHL 
3ae9 cd 6e 1d			call macro_dsp_valuehl 
3aec				endm 
# End of macro FORTH_DSP_VALUEHL
3aec			 
3aec 7d					ld a,l 
3aed			 
3aed					; TODO write to display 
3aed			 
3aed 32 a1 f1				ld (os_input), a 
3af0 3e 00				ld a, 0 
3af2 32 a2 f1				ld (os_input+1), a 
3af5					 
3af5 3a cc f9				ld a, (f_cursor_ptr) 
3af8 11 a1 f1				ld de, os_input 
3afb cd a7 0a				call str_at_display 
3afe			 
3afe			 
3afe 3a aa f9				ld a,(cli_autodisplay) 
3b01 fe 00				cp 0 
3b03 28 03				jr z, .enoupdate 
3b05 cd b7 0a						call update_display 
3b08					.enoupdate: 
3b08			 
3b08 3a cc f9				ld a, (f_cursor_ptr) 
3b0b 3c					inc a 
3b0c 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3b0f			 
3b0f			 
3b0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0f cd 26 1e			call macro_forth_dsp_pop 
3b12				endm 
# End of macro FORTH_DSP_POP
3b12			  
3b12			 
3b12					NEXTW 
3b12 c3 e0 1e			jp macro_next 
3b15				endm 
# End of macro NEXTW
3b15			.DOTH: 
3b15				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b15 1c				db WORD_SYS_CORE+8             
3b16 45 3b			dw .DOTF            
3b18 03				db 2 + 1 
3b19 .. 00			db ".-",0              
3b1c				endm 
# End of macro CWHEAD
3b1c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b1c					; get value off TOS and display it 
3b1c					if DEBUG_FORTH_WORDS_KEY 
3b1c						DMARK "DTD" 
3b1c f5				push af  
3b1d 3a 31 3b			ld a, (.dmark)  
3b20 32 bd fb			ld (debug_mark),a  
3b23 3a 32 3b			ld a, (.dmark+1)  
3b26 32 be fb			ld (debug_mark+1),a  
3b29 3a 33 3b			ld a, (.dmark+2)  
3b2c 32 bf fb			ld (debug_mark+2),a  
3b2f 18 03			jr .pastdmark  
3b31 ..			.dmark: db "DTD"  
3b34 f1			.pastdmark: pop af  
3b35			endm  
# End of macro DMARK
3b35						CALLMONITOR 
3b35 cd ea 15			call break_point_state  
3b38				endm  
# End of macro CALLMONITOR
3b38					endif 
3b38 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b3a 3e 00			ld a, 0 
3b3c 32 ab f9			ld (cli_mvdot), a 
3b3f c3 9c 3b			jp .dotgo 
3b42				NEXTW 
3b42 c3 e0 1e			jp macro_next 
3b45				endm 
# End of macro NEXTW
3b45			.DOTF: 
3b45				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b45 1c				db WORD_SYS_CORE+8             
3b46 73 3b			dw .DOT            
3b48 03				db 2 + 1 
3b49 .. 00			db ".>",0              
3b4c				endm 
# End of macro CWHEAD
3b4c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b4c					; get value off TOS and display it 
3b4c			        ; TODO BUG adds extra spaces 
3b4c			        ; TODO BUG handle numerics? 
3b4c					if DEBUG_FORTH_WORDS_KEY 
3b4c						DMARK "DTC" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 bd fb			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 be fb			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 bf fb			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "DTC"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						CALLMONITOR 
3b65 cd ea 15			call break_point_state  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68 3e 01			ld a, 1 
3b6a 32 ab f9			ld (cli_mvdot), a 
3b6d c3 9c 3b			jp .dotgo 
3b70				NEXTW 
3b70 c3 e0 1e			jp macro_next 
3b73				endm 
# End of macro NEXTW
3b73			 
3b73			.DOT: 
3b73				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b73 1c				db WORD_SYS_CORE+8             
3b74 ff 3b			dw .CLS            
3b76 02				db 1 + 1 
3b77 .. 00			db ".",0              
3b79				endm 
# End of macro CWHEAD
3b79			        ; | . ( u -- ) Display TOS | DONE 
3b79					; get value off TOS and display it 
3b79			 
3b79					if DEBUG_FORTH_WORDS_KEY 
3b79						DMARK "DOT" 
3b79 f5				push af  
3b7a 3a 8e 3b			ld a, (.dmark)  
3b7d 32 bd fb			ld (debug_mark),a  
3b80 3a 8f 3b			ld a, (.dmark+1)  
3b83 32 be fb			ld (debug_mark+1),a  
3b86 3a 90 3b			ld a, (.dmark+2)  
3b89 32 bf fb			ld (debug_mark+2),a  
3b8c 18 03			jr .pastdmark  
3b8e ..			.dmark: db "DOT"  
3b91 f1			.pastdmark: pop af  
3b92			endm  
# End of macro DMARK
3b92						CALLMONITOR 
3b92 cd ea 15			call break_point_state  
3b95				endm  
# End of macro CALLMONITOR
3b95					endif 
3b95 3e 00			ld a, 0 
3b97 32 ab f9			ld (cli_mvdot), a 
3b9a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b9c				 
3b9c			 
3b9c			.dotgo: 
3b9c			 
3b9c			; move up type to on stack for parserv5 
3b9c					FORTH_DSP 
3b9c cd 34 1d			call macro_forth_dsp 
3b9f				endm 
# End of macro FORTH_DSP
3b9f				;FORTH_DSP_VALUE  
3b9f			 
3b9f			if DEBUG_FORTH_DOT 
3b9f				DMARK "DOT" 
3b9f				CALLMONITOR 
3b9f			endif	 
3b9f			;		.print: 
3b9f			 
3b9f 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3ba0 23				inc hl   ; position to the actual value 
3ba1 fe 01			cp DS_TYPE_STR 
3ba3 20 06			jr nz, .dotnum1  
3ba5			 
3ba5			; display string 
3ba5				FORTH_DSP_VALUE  
3ba5 cd 57 1d			call macro_forth_dsp_value 
3ba8				endm 
# End of macro FORTH_DSP_VALUE
3ba8 eb				ex de,hl 
3ba9 18 11			jr .dotwrite 
3bab			 
3bab			.dotnum1: 
3bab fe 02			cp DS_TYPE_INUM 
3bad 20 0c			jr nz, .dotflot 
3baf			 
3baf			 
3baf			; display number 
3baf			 
3baf			;	push hl 
3baf			;	call clear_display 
3baf			;	pop hl 
3baf			 
3baf 5e				ld e, (hl) 
3bb0 23				inc hl 
3bb1 56				ld d, (hl) 
3bb2 21 a3 ef			ld hl, scratch 
3bb5			if DEBUG_FORTH_DOT 
3bb5				DMARK "DT1" 
3bb5				CALLMONITOR 
3bb5			endif	 
3bb5			 
3bb5 cd d5 10			call uitoa_16 
3bb8 eb				ex de,hl 
3bb9			 
3bb9			if DEBUG_FORTH_DOT 
3bb9				DMARK "DT2" 
3bb9				CALLMONITOR 
3bb9			endif	 
3bb9			 
3bb9			;	ld de, os_word_scratch 
3bb9 18 01			jr .dotwrite 
3bbb			 
3bbb 00			.dotflot:   nop 
3bbc			; TODO print floating point number 
3bbc			 
3bbc			.dotwrite:		 
3bbc			 
3bbc					; if c is set then set all '-' to spaces 
3bbc					; need to also take into account .>  
3bbc			 
3bbc 3e 01				ld a, 1 
3bbe b9					cp c 
3bbf 20 13				jr nz, .nodashswap 
3bc1			 
3bc1					; DE has the string to write, working with HL 
3bc1			 
3bc1 06 ff				ld b, 255 
3bc3 d5					push de 
3bc4 e1					pop hl 
3bc5			 
3bc5			if DEBUG_FORTH_DOT 
3bc5				DMARK "DT-" 
3bc5				CALLMONITOR 
3bc5			endif	 
3bc5 7e			.dashscan:	ld a, (hl) 
3bc6 fe 00				cp 0 
3bc8 28 0a				jr z, .nodashswap 
3bca fe 2d				cp '-' 
3bcc 20 03				jr nz, .dashskip 
3bce 3e 20				ld a, ' ' 
3bd0 77					ld (hl), a 
3bd1 23			.dashskip:	inc hl 
3bd2			if DEBUG_FORTH_DOT 
3bd2				DMARK "D-2" 
3bd2				CALLMONITOR 
3bd2			endif	 
3bd2 10 f1				djnz .dashscan 
3bd4			 
3bd4			if DEBUG_FORTH_DOT 
3bd4				DMARK "D-1" 
3bd4				CALLMONITOR 
3bd4			endif	 
3bd4			 
3bd4			.nodashswap: 
3bd4			 
3bd4 e5					push hl   ; save string start in case we need to advance print 
3bd5			 
3bd5 3a cc f9				ld a, (f_cursor_ptr) 
3bd8 cd a7 0a				call str_at_display 
3bdb 3a aa f9				ld a,(cli_autodisplay) 
3bde fe 00				cp 0 
3be0 28 03				jr z, .noupdate 
3be2 cd b7 0a						call update_display 
3be5					.noupdate: 
3be5			 
3be5			 
3be5					; see if we need to advance the print position 
3be5			 
3be5 e1					pop hl   ; get back string 
3be6			 
3be6 3a ab f9				ld a, (cli_mvdot) 
3be9			if DEBUG_FORTH_DOT 
3be9					ld e,a 
3be9				DMARK "D>1" 
3be9				CALLMONITOR 
3be9			endif	 
3be9 fe 00				cp 0 
3beb 28 0c				jr z, .noadv 
3bed					; yes, lets advance the print position 
3bed 3e 00				ld a, 0 
3bef cd 31 11				call strlent 
3bf2 3a cc f9				ld a, (f_cursor_ptr) 
3bf5 85					add a,l 
3bf6					;call addatohl 
3bf6					;ld a, l 
3bf6 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3bf9			 
3bf9			if DEBUG_FORTH_DOT 
3bf9				DMARK "D->" 
3bf9				CALLMONITOR 
3bf9			endif	 
3bf9			 
3bf9			.noadv:	 
3bf9			 
3bf9					if DEBUG_FORTH_DOT_WAIT 
3bf9							call next_page_prompt 
3bf9					endif	 
3bf9			; TODO this pop off the stack causes a crash. i dont know why 
3bf9			 
3bf9			 
3bf9			if DEBUG_FORTH_DOT 
3bf9				DMARK "DTh" 
3bf9				CALLMONITOR 
3bf9			endif	 
3bf9			 
3bf9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf9 cd 26 1e			call macro_forth_dsp_pop 
3bfc				endm 
# End of macro FORTH_DSP_POP
3bfc			 
3bfc			if DEBUG_FORTH_DOT 
3bfc				DMARK "DTi" 
3bfc				CALLMONITOR 
3bfc			endif	 
3bfc			 
3bfc			 
3bfc					NEXTW 
3bfc c3 e0 1e			jp macro_next 
3bff				endm 
# End of macro NEXTW
3bff			 
3bff			.CLS: 
3bff				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3bff 35				db WORD_SYS_CORE+33             
3c00 2c 3c			dw .DRAW            
3c02 04				db 3 + 1 
3c03 .. 00			db "CLS",0              
3c07				endm 
# End of macro CWHEAD
3c07			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c07					if DEBUG_FORTH_WORDS_KEY 
3c07						DMARK "CLS" 
3c07 f5				push af  
3c08 3a 1c 3c			ld a, (.dmark)  
3c0b 32 bd fb			ld (debug_mark),a  
3c0e 3a 1d 3c			ld a, (.dmark+1)  
3c11 32 be fb			ld (debug_mark+1),a  
3c14 3a 1e 3c			ld a, (.dmark+2)  
3c17 32 bf fb			ld (debug_mark+2),a  
3c1a 18 03			jr .pastdmark  
3c1c ..			.dmark: db "CLS"  
3c1f f1			.pastdmark: pop af  
3c20			endm  
# End of macro DMARK
3c20						CALLMONITOR 
3c20 cd ea 15			call break_point_state  
3c23				endm  
# End of macro CALLMONITOR
3c23					endif 
3c23 cd 94 0a				call clear_display 
3c26 c3 3a 3d				jp .home		; and home cursor 
3c29					NEXTW 
3c29 c3 e0 1e			jp macro_next 
3c2c				endm 
# End of macro NEXTW
3c2c			 
3c2c			.DRAW: 
3c2c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c2c 36				db WORD_SYS_CORE+34             
3c2d 57 3c			dw .DUMP            
3c2f 05				db 4 + 1 
3c30 .. 00			db "DRAW",0              
3c35				endm 
# End of macro CWHEAD
3c35			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c35					if DEBUG_FORTH_WORDS_KEY 
3c35						DMARK "DRW" 
3c35 f5				push af  
3c36 3a 4a 3c			ld a, (.dmark)  
3c39 32 bd fb			ld (debug_mark),a  
3c3c 3a 4b 3c			ld a, (.dmark+1)  
3c3f 32 be fb			ld (debug_mark+1),a  
3c42 3a 4c 3c			ld a, (.dmark+2)  
3c45 32 bf fb			ld (debug_mark+2),a  
3c48 18 03			jr .pastdmark  
3c4a ..			.dmark: db "DRW"  
3c4d f1			.pastdmark: pop af  
3c4e			endm  
# End of macro DMARK
3c4e						CALLMONITOR 
3c4e cd ea 15			call break_point_state  
3c51				endm  
# End of macro CALLMONITOR
3c51					endif 
3c51 cd b7 0a				call update_display 
3c54					NEXTW 
3c54 c3 e0 1e			jp macro_next 
3c57				endm 
# End of macro NEXTW
3c57			 
3c57			.DUMP: 
3c57				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c57 37				db WORD_SYS_CORE+35             
3c58 8f 3c			dw .CDUMP            
3c5a 05				db 4 + 1 
3c5b .. 00			db "DUMP",0              
3c60				endm 
# End of macro CWHEAD
3c60			; | DUMP ( x -- ) With address x display dump   | DONE 
3c60			; TODO pop address to use off of the stack 
3c60					if DEBUG_FORTH_WORDS_KEY 
3c60						DMARK "DUM" 
3c60 f5				push af  
3c61 3a 75 3c			ld a, (.dmark)  
3c64 32 bd fb			ld (debug_mark),a  
3c67 3a 76 3c			ld a, (.dmark+1)  
3c6a 32 be fb			ld (debug_mark+1),a  
3c6d 3a 77 3c			ld a, (.dmark+2)  
3c70 32 bf fb			ld (debug_mark+2),a  
3c73 18 03			jr .pastdmark  
3c75 ..			.dmark: db "DUM"  
3c78 f1			.pastdmark: pop af  
3c79			endm  
# End of macro DMARK
3c79						CALLMONITOR 
3c79 cd ea 15			call break_point_state  
3c7c				endm  
# End of macro CALLMONITOR
3c7c					endif 
3c7c cd 94 0a				call clear_display 
3c7f			 
3c7f					; get address 
3c7f			 
3c7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c7f cd 6e 1d			call macro_dsp_valuehl 
3c82				endm 
# End of macro FORTH_DSP_VALUEHL
3c82				 
3c82					; save it for cdump 
3c82			 
3c82 22 c6 f2				ld (os_cur_ptr),hl 
3c85			 
3c85					; destroy value TOS 
3c85			 
3c85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c85 cd 26 1e			call macro_forth_dsp_pop 
3c88				endm 
# End of macro FORTH_DSP_POP
3c88			 
3c88 cd f7 19				call dumpcont	; skip old style of param parsing	 
3c8b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c8c					NEXTW 
3c8c c3 e0 1e			jp macro_next 
3c8f				endm 
# End of macro NEXTW
3c8f			.CDUMP: 
3c8f				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c8f 38				db WORD_SYS_CORE+36             
3c90 bf 3c			dw .DAT            
3c92 06				db 5 + 1 
3c93 .. 00			db "CDUMP",0              
3c99				endm 
# End of macro CWHEAD
3c99			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c99					if DEBUG_FORTH_WORDS_KEY 
3c99						DMARK "CDP" 
3c99 f5				push af  
3c9a 3a ae 3c			ld a, (.dmark)  
3c9d 32 bd fb			ld (debug_mark),a  
3ca0 3a af 3c			ld a, (.dmark+1)  
3ca3 32 be fb			ld (debug_mark+1),a  
3ca6 3a b0 3c			ld a, (.dmark+2)  
3ca9 32 bf fb			ld (debug_mark+2),a  
3cac 18 03			jr .pastdmark  
3cae ..			.dmark: db "CDP"  
3cb1 f1			.pastdmark: pop af  
3cb2			endm  
# End of macro DMARK
3cb2						CALLMONITOR 
3cb2 cd ea 15			call break_point_state  
3cb5				endm  
# End of macro CALLMONITOR
3cb5					endif 
3cb5 cd 94 0a				call clear_display 
3cb8 cd f7 19				call dumpcont	 
3cbb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cbc					NEXTW 
3cbc c3 e0 1e			jp macro_next 
3cbf				endm 
# End of macro NEXTW
3cbf			 
3cbf			 
3cbf			 
3cbf			 
3cbf			.DAT: 
3cbf				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cbf 3d				db WORD_SYS_CORE+41             
3cc0 15 3d			dw .HOME            
3cc2 03				db 2 + 1 
3cc3 .. 00			db "AT",0              
3cc6				endm 
# End of macro CWHEAD
3cc6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3cc6					if DEBUG_FORTH_WORDS_KEY 
3cc6						DMARK "AT." 
3cc6 f5				push af  
3cc7 3a db 3c			ld a, (.dmark)  
3cca 32 bd fb			ld (debug_mark),a  
3ccd 3a dc 3c			ld a, (.dmark+1)  
3cd0 32 be fb			ld (debug_mark+1),a  
3cd3 3a dd 3c			ld a, (.dmark+2)  
3cd6 32 bf fb			ld (debug_mark+2),a  
3cd9 18 03			jr .pastdmark  
3cdb ..			.dmark: db "AT."  
3cde f1			.pastdmark: pop af  
3cdf			endm  
# End of macro DMARK
3cdf						CALLMONITOR 
3cdf cd ea 15			call break_point_state  
3ce2				endm  
# End of macro CALLMONITOR
3ce2					endif 
3ce2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce2 cd 6e 1d			call macro_dsp_valuehl 
3ce5				endm 
# End of macro FORTH_DSP_VALUEHL
3ce5			 
3ce5			 
3ce5					; TODO save cursor row 
3ce5 7d					ld a,l 
3ce6 fe 02				cp 2 
3ce8 20 04				jr nz, .crow3 
3cea 3e 14				ld a, display_row_2 
3cec 18 12				jr .ccol1 
3cee fe 03		.crow3:		cp 3 
3cf0 20 04				jr nz, .crow4 
3cf2 3e 28				ld a, display_row_3 
3cf4 18 0a				jr .ccol1 
3cf6 fe 04		.crow4:		cp 4 
3cf8 20 04				jr nz, .crow1 
3cfa 3e 3c				ld a, display_row_4 
3cfc 18 02				jr .ccol1 
3cfe 3e 00		.crow1:		ld a,display_row_1 
3d00 f5			.ccol1:		push af			; got row offset 
3d01 6f					ld l,a 
3d02 26 00				ld h,0 
3d04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d04 cd 26 1e			call macro_forth_dsp_pop 
3d07				endm 
# End of macro FORTH_DSP_POP
3d07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d07 cd 6e 1d			call macro_dsp_valuehl 
3d0a				endm 
# End of macro FORTH_DSP_VALUEHL
3d0a					; TODO save cursor col 
3d0a f1					pop af 
3d0b 85					add l		; add col offset 
3d0c 32 cc f9				ld (f_cursor_ptr), a 
3d0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d0f cd 26 1e			call macro_forth_dsp_pop 
3d12				endm 
# End of macro FORTH_DSP_POP
3d12			 
3d12					; calculate  
3d12			 
3d12					NEXTW 
3d12 c3 e0 1e			jp macro_next 
3d15				endm 
# End of macro NEXTW
3d15			 
3d15			 
3d15			.HOME: 
3d15				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d15 41				db WORD_SYS_CORE+45             
3d16 42 3d			dw .SPACE            
3d18 05				db 4 + 1 
3d19 .. 00			db "HOME",0              
3d1e				endm 
# End of macro CWHEAD
3d1e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d1e					if DEBUG_FORTH_WORDS_KEY 
3d1e						DMARK "HOM" 
3d1e f5				push af  
3d1f 3a 33 3d			ld a, (.dmark)  
3d22 32 bd fb			ld (debug_mark),a  
3d25 3a 34 3d			ld a, (.dmark+1)  
3d28 32 be fb			ld (debug_mark+1),a  
3d2b 3a 35 3d			ld a, (.dmark+2)  
3d2e 32 bf fb			ld (debug_mark+2),a  
3d31 18 03			jr .pastdmark  
3d33 ..			.dmark: db "HOM"  
3d36 f1			.pastdmark: pop af  
3d37			endm  
# End of macro DMARK
3d37						CALLMONITOR 
3d37 cd ea 15			call break_point_state  
3d3a				endm  
# End of macro CALLMONITOR
3d3a					endif 
3d3a 3e 00		.home:		ld a, 0		; and home cursor 
3d3c 32 cc f9				ld (f_cursor_ptr), a 
3d3f					NEXTW 
3d3f c3 e0 1e			jp macro_next 
3d42				endm 
# End of macro NEXTW
3d42			 
3d42			 
3d42			.SPACE: 
3d42				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d42 46				db WORD_SYS_CORE+50             
3d43 70 3d			dw .SPACES            
3d45 03				db 2 + 1 
3d46 .. 00			db "BL",0              
3d49				endm 
# End of macro CWHEAD
3d49			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d49					if DEBUG_FORTH_WORDS_KEY 
3d49						DMARK "BL." 
3d49 f5				push af  
3d4a 3a 5e 3d			ld a, (.dmark)  
3d4d 32 bd fb			ld (debug_mark),a  
3d50 3a 5f 3d			ld a, (.dmark+1)  
3d53 32 be fb			ld (debug_mark+1),a  
3d56 3a 60 3d			ld a, (.dmark+2)  
3d59 32 bf fb			ld (debug_mark+2),a  
3d5c 18 03			jr .pastdmark  
3d5e ..			.dmark: db "BL."  
3d61 f1			.pastdmark: pop af  
3d62			endm  
# End of macro DMARK
3d62						CALLMONITOR 
3d62 cd ea 15			call break_point_state  
3d65				endm  
# End of macro CALLMONITOR
3d65					endif 
3d65 21 6e 3d				ld hl, .blstr 
3d68 cd e5 1b				call forth_push_str 
3d6b					 
3d6b				       NEXTW 
3d6b c3 e0 1e			jp macro_next 
3d6e				endm 
# End of macro NEXTW
3d6e			 
3d6e .. 00		.blstr: db " ", 0 
3d70			 
3d70			.SPACES: 
3d70				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3d70 47				db WORD_SYS_CORE+51             
3d71 0b 3e			dw .SCROLL            
3d73 07				db 6 + 1 
3d74 .. 00			db "SPACES",0              
3d7b				endm 
# End of macro CWHEAD
3d7b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3d7b					if DEBUG_FORTH_WORDS_KEY 
3d7b						DMARK "SPS" 
3d7b f5				push af  
3d7c 3a 90 3d			ld a, (.dmark)  
3d7f 32 bd fb			ld (debug_mark),a  
3d82 3a 91 3d			ld a, (.dmark+1)  
3d85 32 be fb			ld (debug_mark+1),a  
3d88 3a 92 3d			ld a, (.dmark+2)  
3d8b 32 bf fb			ld (debug_mark+2),a  
3d8e 18 03			jr .pastdmark  
3d90 ..			.dmark: db "SPS"  
3d93 f1			.pastdmark: pop af  
3d94			endm  
# End of macro DMARK
3d94						CALLMONITOR 
3d94 cd ea 15			call break_point_state  
3d97				endm  
# End of macro CALLMONITOR
3d97					endif 
3d97			 
3d97			 
3d97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d97 cd 6e 1d			call macro_dsp_valuehl 
3d9a				endm 
# End of macro FORTH_DSP_VALUEHL
3d9a			 
3d9a			;		push hl    ; u 
3d9a					if DEBUG_FORTH_WORDS 
3d9a						DMARK "SPA" 
3d9a f5				push af  
3d9b 3a af 3d			ld a, (.dmark)  
3d9e 32 bd fb			ld (debug_mark),a  
3da1 3a b0 3d			ld a, (.dmark+1)  
3da4 32 be fb			ld (debug_mark+1),a  
3da7 3a b1 3d			ld a, (.dmark+2)  
3daa 32 bf fb			ld (debug_mark+2),a  
3dad 18 03			jr .pastdmark  
3daf ..			.dmark: db "SPA"  
3db2 f1			.pastdmark: pop af  
3db3			endm  
# End of macro DMARK
3db3						CALLMONITOR 
3db3 cd ea 15			call break_point_state  
3db6				endm  
# End of macro CALLMONITOR
3db6					endif 
3db6			 
3db6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db6 cd 26 1e			call macro_forth_dsp_pop 
3db9				endm 
# End of macro FORTH_DSP_POP
3db9			;		pop hl 
3db9 4d					ld c, l 
3dba 06 00				ld b, 0 
3dbc 21 a3 ef				ld hl, scratch  
3dbf			 
3dbf					if DEBUG_FORTH_WORDS 
3dbf						DMARK "SP2" 
3dbf f5				push af  
3dc0 3a d4 3d			ld a, (.dmark)  
3dc3 32 bd fb			ld (debug_mark),a  
3dc6 3a d5 3d			ld a, (.dmark+1)  
3dc9 32 be fb			ld (debug_mark+1),a  
3dcc 3a d6 3d			ld a, (.dmark+2)  
3dcf 32 bf fb			ld (debug_mark+2),a  
3dd2 18 03			jr .pastdmark  
3dd4 ..			.dmark: db "SP2"  
3dd7 f1			.pastdmark: pop af  
3dd8			endm  
# End of macro DMARK
3dd8						CALLMONITOR 
3dd8 cd ea 15			call break_point_state  
3ddb				endm  
# End of macro CALLMONITOR
3ddb					endif 
3ddb 3e 20				ld a, ' ' 
3ddd c5			.spaces1:	push bc 
3dde 77					ld (hl),a 
3ddf 23					inc hl 
3de0 c1					pop bc 
3de1 10 fa				djnz .spaces1 
3de3 3e 00				ld a,0 
3de5 77					ld (hl),a 
3de6 21 a3 ef				ld hl, scratch 
3de9					if DEBUG_FORTH_WORDS 
3de9						DMARK "SP3" 
3de9 f5				push af  
3dea 3a fe 3d			ld a, (.dmark)  
3ded 32 bd fb			ld (debug_mark),a  
3df0 3a ff 3d			ld a, (.dmark+1)  
3df3 32 be fb			ld (debug_mark+1),a  
3df6 3a 00 3e			ld a, (.dmark+2)  
3df9 32 bf fb			ld (debug_mark+2),a  
3dfc 18 03			jr .pastdmark  
3dfe ..			.dmark: db "SP3"  
3e01 f1			.pastdmark: pop af  
3e02			endm  
# End of macro DMARK
3e02						CALLMONITOR 
3e02 cd ea 15			call break_point_state  
3e05				endm  
# End of macro CALLMONITOR
3e05					endif 
3e05 cd e0 1c				call forth_apush 
3e08			 
3e08				       NEXTW 
3e08 c3 e0 1e			jp macro_next 
3e0b				endm 
# End of macro NEXTW
3e0b			 
3e0b			 
3e0b			 
3e0b			.SCROLL: 
3e0b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e0b 53				db WORD_SYS_CORE+63             
3e0c 38 3e			dw .SCROLLD            
3e0e 07				db 6 + 1 
3e0f .. 00			db "SCROLL",0              
3e16				endm 
# End of macro CWHEAD
3e16			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e16					if DEBUG_FORTH_WORDS_KEY 
3e16						DMARK "SCR" 
3e16 f5				push af  
3e17 3a 2b 3e			ld a, (.dmark)  
3e1a 32 bd fb			ld (debug_mark),a  
3e1d 3a 2c 3e			ld a, (.dmark+1)  
3e20 32 be fb			ld (debug_mark+1),a  
3e23 3a 2d 3e			ld a, (.dmark+2)  
3e26 32 bf fb			ld (debug_mark+2),a  
3e29 18 03			jr .pastdmark  
3e2b ..			.dmark: db "SCR"  
3e2e f1			.pastdmark: pop af  
3e2f			endm  
# End of macro DMARK
3e2f						CALLMONITOR 
3e2f cd ea 15			call break_point_state  
3e32				endm  
# End of macro CALLMONITOR
3e32					endif 
3e32			 
3e32 cd 56 0a			call scroll_up 
3e35			;	call update_display 
3e35			 
3e35					NEXTW 
3e35 c3 e0 1e			jp macro_next 
3e38				endm 
# End of macro NEXTW
3e38			 
3e38			 
3e38			 
3e38			;		; get dir 
3e38			; 
3e38			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e38			; 
3e38			;		push hl 
3e38			; 
3e38			;		; destroy value TOS 
3e38			; 
3e38			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e38			; 
3e38			;		; get count 
3e38			; 
3e38			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e38			; 
3e38			;		push hl 
3e38			; 
3e38			;		; destroy value TOS 
3e38			; 
3e38			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e38			; 
3e38			;		; one value on hl get other one back 
3e38			; 
3e38			;		pop bc    ; count 
3e38			; 
3e38			;		pop de   ; dir 
3e38			; 
3e38			; 
3e38			;		ld b, c 
3e38			; 
3e38			;.scrolldir:     push bc 
3e38			;		push de 
3e38			; 
3e38			;		ld a, 0 
3e38			;		cp e 
3e38			;		jr z, .scrollup  
3e38			;		call scroll_down 
3e38			;		jr .scrollnext 
3e38			;.scrollup:	call scroll_up 
3e38			; 
3e38			;		 
3e38			;.scrollnext: 
3e38			;		pop de 
3e38			;		pop bc 
3e38			;		djnz .scrolldir 
3e38			; 
3e38			; 
3e38			; 
3e38			; 
3e38			; 
3e38			;		NEXTW 
3e38			 
3e38			.SCROLLD: 
3e38				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e38 53				db WORD_SYS_CORE+63             
3e39 66 3e			dw .ATQ            
3e3b 08				db 7 + 1 
3e3c .. 00			db "SCROLLD",0              
3e44				endm 
# End of macro CWHEAD
3e44			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e44					if DEBUG_FORTH_WORDS_KEY 
3e44						DMARK "SCD" 
3e44 f5				push af  
3e45 3a 59 3e			ld a, (.dmark)  
3e48 32 bd fb			ld (debug_mark),a  
3e4b 3a 5a 3e			ld a, (.dmark+1)  
3e4e 32 be fb			ld (debug_mark+1),a  
3e51 3a 5b 3e			ld a, (.dmark+2)  
3e54 32 bf fb			ld (debug_mark+2),a  
3e57 18 03			jr .pastdmark  
3e59 ..			.dmark: db "SCD"  
3e5c f1			.pastdmark: pop af  
3e5d			endm  
# End of macro DMARK
3e5d						CALLMONITOR 
3e5d cd ea 15			call break_point_state  
3e60				endm  
# End of macro CALLMONITOR
3e60					endif 
3e60			 
3e60 cd 7a 0a			call scroll_down 
3e63			;	call update_display 
3e63			 
3e63					NEXTW 
3e63 c3 e0 1e			jp macro_next 
3e66				endm 
# End of macro NEXTW
3e66			 
3e66			 
3e66			.ATQ: 
3e66				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e66 62				db WORD_SYS_CORE+78             
3e67 c4 3e			dw .AUTODSP            
3e69 04				db 3 + 1 
3e6a .. 00			db "AT@",0              
3e6e				endm 
# End of macro CWHEAD
3e6e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e6e					if DEBUG_FORTH_WORDS_KEY 
3e6e						DMARK "ATA" 
3e6e f5				push af  
3e6f 3a 83 3e			ld a, (.dmark)  
3e72 32 bd fb			ld (debug_mark),a  
3e75 3a 84 3e			ld a, (.dmark+1)  
3e78 32 be fb			ld (debug_mark+1),a  
3e7b 3a 85 3e			ld a, (.dmark+2)  
3e7e 32 bf fb			ld (debug_mark+2),a  
3e81 18 03			jr .pastdmark  
3e83 ..			.dmark: db "ATA"  
3e86 f1			.pastdmark: pop af  
3e87			endm  
# End of macro DMARK
3e87						CALLMONITOR 
3e87 cd ea 15			call break_point_state  
3e8a				endm  
# End of macro CALLMONITOR
3e8a					endif 
3e8a			 
3e8a			 
3e8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e8a cd 6e 1d			call macro_dsp_valuehl 
3e8d				endm 
# End of macro FORTH_DSP_VALUEHL
3e8d			 
3e8d					; TODO save cursor row 
3e8d 7d					ld a,l 
3e8e fe 02				cp 2 
3e90 20 04				jr nz, .crow3aq 
3e92 3e 14				ld a, display_row_2 
3e94 18 12				jr .ccol1aq 
3e96 fe 03		.crow3aq:		cp 3 
3e98 20 04				jr nz, .crow4aq 
3e9a 3e 28				ld a, display_row_3 
3e9c 18 0a				jr .ccol1aq 
3e9e fe 04		.crow4aq:		cp 4 
3ea0 20 04				jr nz, .crow1aq 
3ea2 3e 3c				ld a, display_row_4 
3ea4 18 02				jr .ccol1aq 
3ea6 3e 00		.crow1aq:		ld a,display_row_1 
3ea8 f5			.ccol1aq:		push af			; got row offset 
3ea9 6f					ld l,a 
3eaa 26 00				ld h,0 
3eac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eac cd 26 1e			call macro_forth_dsp_pop 
3eaf				endm 
# End of macro FORTH_DSP_POP
3eaf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eaf cd 6e 1d			call macro_dsp_valuehl 
3eb2				endm 
# End of macro FORTH_DSP_VALUEHL
3eb2					; TODO save cursor col 
3eb2 f1					pop af 
3eb3 85					add l		; add col offset 
3eb4			 
3eb4					; add current frame buffer address 
3eb4 2a 5e fa				ld hl, (display_fb_active) 
3eb7 cd c8 0c				call addatohl 
3eba			 
3eba			 
3eba			 
3eba			 
3eba					; get char frame buffer location offset in hl 
3eba			 
3eba 7e					ld a,(hl) 
3ebb 26 00				ld h, 0 
3ebd 6f					ld l, a 
3ebe			 
3ebe cd 77 1b				call forth_push_numhl 
3ec1			 
3ec1			 
3ec1					NEXTW 
3ec1 c3 e0 1e			jp macro_next 
3ec4				endm 
# End of macro NEXTW
3ec4			 
3ec4			.AUTODSP: 
3ec4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ec4 63				db WORD_SYS_CORE+79             
3ec5 da 3e			dw .MENU            
3ec7 05				db 4 + 1 
3ec8 .. 00			db "ADSP",0              
3ecd				endm 
# End of macro CWHEAD
3ecd			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3ecd			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3ecd			 
3ecd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ecd cd 6e 1d			call macro_dsp_valuehl 
3ed0				endm 
# End of macro FORTH_DSP_VALUEHL
3ed0			 
3ed0			;		push hl 
3ed0			 
3ed0					; destroy value TOS 
3ed0			 
3ed0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ed0 cd 26 1e			call macro_forth_dsp_pop 
3ed3				endm 
# End of macro FORTH_DSP_POP
3ed3			 
3ed3			;		pop hl 
3ed3			 
3ed3 7d					ld a,l 
3ed4 32 aa f9				ld (cli_autodisplay), a 
3ed7				       NEXTW 
3ed7 c3 e0 1e			jp macro_next 
3eda				endm 
# End of macro NEXTW
3eda			 
3eda			.MENU: 
3eda				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3eda 70				db WORD_SYS_CORE+92             
3edb 83 3f			dw .ENDDISPLAY            
3edd 05				db 4 + 1 
3ede .. 00			db "MENU",0              
3ee3				endm 
# End of macro CWHEAD
3ee3			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3ee3			 
3ee3			;		; get number of items on the stack 
3ee3			; 
3ee3				 
3ee3					FORTH_DSP_VALUEHL 
3ee3 cd 6e 1d			call macro_dsp_valuehl 
3ee6				endm 
# End of macro FORTH_DSP_VALUEHL
3ee6				 
3ee6					if DEBUG_FORTH_WORDS_KEY 
3ee6						DMARK "MNU" 
3ee6 f5				push af  
3ee7 3a fb 3e			ld a, (.dmark)  
3eea 32 bd fb			ld (debug_mark),a  
3eed 3a fc 3e			ld a, (.dmark+1)  
3ef0 32 be fb			ld (debug_mark+1),a  
3ef3 3a fd 3e			ld a, (.dmark+2)  
3ef6 32 bf fb			ld (debug_mark+2),a  
3ef9 18 03			jr .pastdmark  
3efb ..			.dmark: db "MNU"  
3efe f1			.pastdmark: pop af  
3eff			endm  
# End of macro DMARK
3eff						CALLMONITOR 
3eff cd ea 15			call break_point_state  
3f02				endm  
# End of macro CALLMONITOR
3f02					endif 
3f02			 
3f02 45					ld b, l	 
3f03 05					dec b 
3f04			 
3f04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f04 cd 26 1e			call macro_forth_dsp_pop 
3f07				endm 
# End of macro FORTH_DSP_POP
3f07			 
3f07			 
3f07					; go directly through the stack to pluck out the string pointers and build an array 
3f07			 
3f07			;		FORTH_DSP 
3f07			 
3f07					; hl contains top most stack item 
3f07				 
3f07 11 a3 ef				ld de, scratch 
3f0a			 
3f0a			.mbuild: 
3f0a			 
3f0a					FORTH_DSP_VALUEHL 
3f0a cd 6e 1d			call macro_dsp_valuehl 
3f0d				endm 
# End of macro FORTH_DSP_VALUEHL
3f0d			 
3f0d					if DEBUG_FORTH_WORDS 
3f0d						DMARK "MN3" 
3f0d f5				push af  
3f0e 3a 22 3f			ld a, (.dmark)  
3f11 32 bd fb			ld (debug_mark),a  
3f14 3a 23 3f			ld a, (.dmark+1)  
3f17 32 be fb			ld (debug_mark+1),a  
3f1a 3a 24 3f			ld a, (.dmark+2)  
3f1d 32 bf fb			ld (debug_mark+2),a  
3f20 18 03			jr .pastdmark  
3f22 ..			.dmark: db "MN3"  
3f25 f1			.pastdmark: pop af  
3f26			endm  
# End of macro DMARK
3f26						CALLMONITOR 
3f26 cd ea 15			call break_point_state  
3f29				endm  
# End of macro CALLMONITOR
3f29					endif 
3f29 eb					ex de, hl 
3f2a 73					ld (hl), e 
3f2b 23					inc hl 
3f2c 72					ld (hl), d 
3f2d 23					inc hl 
3f2e eb					ex de, hl 
3f2f			 
3f2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f2f cd 26 1e			call macro_forth_dsp_pop 
3f32				endm 
# End of macro FORTH_DSP_POP
3f32			 
3f32 10 d6				djnz .mbuild 
3f34			 
3f34					; done add term 
3f34			 
3f34 eb					ex de, hl 
3f35 36 00				ld (hl), 0 
3f37 23					inc hl 
3f38 36 00				ld (hl), 0 
3f3a			 
3f3a				 
3f3a					 
3f3a 21 a3 ef				ld hl, scratch 
3f3d			 
3f3d					if DEBUG_FORTH_WORDS 
3f3d						DMARK "MNx" 
3f3d f5				push af  
3f3e 3a 52 3f			ld a, (.dmark)  
3f41 32 bd fb			ld (debug_mark),a  
3f44 3a 53 3f			ld a, (.dmark+1)  
3f47 32 be fb			ld (debug_mark+1),a  
3f4a 3a 54 3f			ld a, (.dmark+2)  
3f4d 32 bf fb			ld (debug_mark+2),a  
3f50 18 03			jr .pastdmark  
3f52 ..			.dmark: db "MNx"  
3f55 f1			.pastdmark: pop af  
3f56			endm  
# End of macro DMARK
3f56						CALLMONITOR 
3f56 cd ea 15			call break_point_state  
3f59				endm  
# End of macro CALLMONITOR
3f59					endif 
3f59			 
3f59			 
3f59			 
3f59 3e 00				ld a, 0 
3f5b cd c5 0a				call menu 
3f5e			 
3f5e			 
3f5e 6f					ld l, a 
3f5f 26 00				ld h, 0 
3f61			 
3f61					if DEBUG_FORTH_WORDS 
3f61						DMARK "MNr" 
3f61 f5				push af  
3f62 3a 76 3f			ld a, (.dmark)  
3f65 32 bd fb			ld (debug_mark),a  
3f68 3a 77 3f			ld a, (.dmark+1)  
3f6b 32 be fb			ld (debug_mark+1),a  
3f6e 3a 78 3f			ld a, (.dmark+2)  
3f71 32 bf fb			ld (debug_mark+2),a  
3f74 18 03			jr .pastdmark  
3f76 ..			.dmark: db "MNr"  
3f79 f1			.pastdmark: pop af  
3f7a			endm  
# End of macro DMARK
3f7a						CALLMONITOR 
3f7a cd ea 15			call break_point_state  
3f7d				endm  
# End of macro CALLMONITOR
3f7d					endif 
3f7d			 
3f7d cd 77 1b				call forth_push_numhl 
3f80			 
3f80			 
3f80			 
3f80			 
3f80				       NEXTW 
3f80 c3 e0 1e			jp macro_next 
3f83				endm 
# End of macro NEXTW
3f83			 
3f83			 
3f83			.ENDDISPLAY: 
3f83			 
3f83			; eof 
# End of file forth_words_display.asm
3f83			include "forth_words_str.asm" 
3f83			 
3f83			; | ## String Words 
3f83			 
3f83			.PTR:   
3f83			 
3f83				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f83 48				db WORD_SYS_CORE+52             
3f84 b0 3f			dw .STYPE            
3f86 04				db 3 + 1 
3f87 .. 00			db "PTR",0              
3f8b				endm 
# End of macro CWHEAD
3f8b			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f8b			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f8b			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f8b			 
3f8b					if DEBUG_FORTH_WORDS_KEY 
3f8b						DMARK "PTR" 
3f8b f5				push af  
3f8c 3a a0 3f			ld a, (.dmark)  
3f8f 32 bd fb			ld (debug_mark),a  
3f92 3a a1 3f			ld a, (.dmark+1)  
3f95 32 be fb			ld (debug_mark+1),a  
3f98 3a a2 3f			ld a, (.dmark+2)  
3f9b 32 bf fb			ld (debug_mark+2),a  
3f9e 18 03			jr .pastdmark  
3fa0 ..			.dmark: db "PTR"  
3fa3 f1			.pastdmark: pop af  
3fa4			endm  
# End of macro DMARK
3fa4						CALLMONITOR 
3fa4 cd ea 15			call break_point_state  
3fa7				endm  
# End of macro CALLMONITOR
3fa7					endif 
3fa7					FORTH_DSP_VALUEHL 
3fa7 cd 6e 1d			call macro_dsp_valuehl 
3faa				endm 
# End of macro FORTH_DSP_VALUEHL
3faa cd 77 1b				call forth_push_numhl 
3fad			 
3fad			 
3fad					NEXTW 
3fad c3 e0 1e			jp macro_next 
3fb0				endm 
# End of macro NEXTW
3fb0			.STYPE: 
3fb0				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fb0 48				db WORD_SYS_CORE+52             
3fb1 ff 3f			dw .UPPER            
3fb3 06				db 5 + 1 
3fb4 .. 00			db "STYPE",0              
3fba				endm 
# End of macro CWHEAD
3fba			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3fba					if DEBUG_FORTH_WORDS_KEY 
3fba						DMARK "STY" 
3fba f5				push af  
3fbb 3a cf 3f			ld a, (.dmark)  
3fbe 32 bd fb			ld (debug_mark),a  
3fc1 3a d0 3f			ld a, (.dmark+1)  
3fc4 32 be fb			ld (debug_mark+1),a  
3fc7 3a d1 3f			ld a, (.dmark+2)  
3fca 32 bf fb			ld (debug_mark+2),a  
3fcd 18 03			jr .pastdmark  
3fcf ..			.dmark: db "STY"  
3fd2 f1			.pastdmark: pop af  
3fd3			endm  
# End of macro DMARK
3fd3						CALLMONITOR 
3fd3 cd ea 15			call break_point_state  
3fd6				endm  
# End of macro CALLMONITOR
3fd6					endif 
3fd6					FORTH_DSP 
3fd6 cd 34 1d			call macro_forth_dsp 
3fd9				endm 
# End of macro FORTH_DSP
3fd9					;v5 FORTH_DSP_VALUE 
3fd9			 
3fd9 7e					ld a, (hl) 
3fda			 
3fda f5					push af 
3fdb			 
3fdb			; Dont destroy TOS		FORTH_DSP_POP 
3fdb			 
3fdb f1					pop af 
3fdc			 
3fdc fe 01				cp DS_TYPE_STR 
3fde 28 09				jr z, .typestr 
3fe0			 
3fe0 fe 02				cp DS_TYPE_INUM 
3fe2 28 0a				jr z, .typeinum 
3fe4			 
3fe4 21 fd 3f				ld hl, .tna 
3fe7 18 0a				jr .tpush 
3fe9			 
3fe9 21 f9 3f		.typestr:	ld hl, .tstr 
3fec 18 05				jr .tpush 
3fee 21 fb 3f		.typeinum:	ld hl, .tinum 
3ff1 18 00				jr .tpush 
3ff3			 
3ff3			.tpush: 
3ff3			 
3ff3 cd e5 1b				call forth_push_str 
3ff6			 
3ff6					NEXTW 
3ff6 c3 e0 1e			jp macro_next 
3ff9				endm 
# End of macro NEXTW
3ff9 .. 00		.tstr:	db "s",0 
3ffb .. 00		.tinum:  db "i",0 
3ffd .. 00		.tna:   db "?", 0 
3fff			 
3fff			 
3fff			.UPPER: 
3fff				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3fff 48				db WORD_SYS_CORE+52             
4000 3a 40			dw .LOWER            
4002 06				db 5 + 1 
4003 .. 00			db "UPPER",0              
4009				endm 
# End of macro CWHEAD
4009			; | UPPER ( s -- s ) Upper case string s  | DONE 
4009					if DEBUG_FORTH_WORDS_KEY 
4009						DMARK "UPR" 
4009 f5				push af  
400a 3a 1e 40			ld a, (.dmark)  
400d 32 bd fb			ld (debug_mark),a  
4010 3a 1f 40			ld a, (.dmark+1)  
4013 32 be fb			ld (debug_mark+1),a  
4016 3a 20 40			ld a, (.dmark+2)  
4019 32 bf fb			ld (debug_mark+2),a  
401c 18 03			jr .pastdmark  
401e ..			.dmark: db "UPR"  
4021 f1			.pastdmark: pop af  
4022			endm  
# End of macro DMARK
4022						CALLMONITOR 
4022 cd ea 15			call break_point_state  
4025				endm  
# End of macro CALLMONITOR
4025					endif 
4025			 
4025					FORTH_DSP 
4025 cd 34 1d			call macro_forth_dsp 
4028				endm 
# End of macro FORTH_DSP
4028					 
4028			; TODO check is string type 
4028			 
4028					FORTH_DSP_VALUEHL 
4028 cd 6e 1d			call macro_dsp_valuehl 
402b				endm 
# End of macro FORTH_DSP_VALUEHL
402b			; get pointer to string in hl 
402b			 
402b 7e			.toup:		ld a, (hl) 
402c fe 00				cp 0 
402e 28 07				jr z, .toupdone 
4030			 
4030 cd 35 10				call to_upper 
4033			 
4033 77					ld (hl), a 
4034 23					inc hl 
4035 18 f4				jr .toup 
4037			 
4037					 
4037			 
4037			 
4037			; for each char convert to upper 
4037					 
4037			.toupdone: 
4037			 
4037			 
4037					NEXTW 
4037 c3 e0 1e			jp macro_next 
403a				endm 
# End of macro NEXTW
403a			.LOWER: 
403a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
403a 48				db WORD_SYS_CORE+52             
403b 75 40			dw .TCASE            
403d 06				db 5 + 1 
403e .. 00			db "LOWER",0              
4044				endm 
# End of macro CWHEAD
4044			; | LOWER ( s -- s ) Lower case string s  | DONE 
4044					if DEBUG_FORTH_WORDS_KEY 
4044						DMARK "LWR" 
4044 f5				push af  
4045 3a 59 40			ld a, (.dmark)  
4048 32 bd fb			ld (debug_mark),a  
404b 3a 5a 40			ld a, (.dmark+1)  
404e 32 be fb			ld (debug_mark+1),a  
4051 3a 5b 40			ld a, (.dmark+2)  
4054 32 bf fb			ld (debug_mark+2),a  
4057 18 03			jr .pastdmark  
4059 ..			.dmark: db "LWR"  
405c f1			.pastdmark: pop af  
405d			endm  
# End of macro DMARK
405d						CALLMONITOR 
405d cd ea 15			call break_point_state  
4060				endm  
# End of macro CALLMONITOR
4060					endif 
4060			 
4060					FORTH_DSP 
4060 cd 34 1d			call macro_forth_dsp 
4063				endm 
# End of macro FORTH_DSP
4063					 
4063			; TODO check is string type 
4063			 
4063					FORTH_DSP_VALUEHL 
4063 cd 6e 1d			call macro_dsp_valuehl 
4066				endm 
# End of macro FORTH_DSP_VALUEHL
4066			; get pointer to string in hl 
4066			 
4066 7e			.tolow:		ld a, (hl) 
4067 fe 00				cp 0 
4069 28 07				jr z, .tolowdone 
406b			 
406b cd 3e 10				call to_lower 
406e			 
406e 77					ld (hl), a 
406f 23					inc hl 
4070 18 f4				jr .tolow 
4072			 
4072					 
4072			 
4072			 
4072			; for each char convert to low 
4072					 
4072			.tolowdone: 
4072					NEXTW 
4072 c3 e0 1e			jp macro_next 
4075				endm 
# End of macro NEXTW
4075			.TCASE: 
4075				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4075 48				db WORD_SYS_CORE+52             
4076 ab 41			dw .SUBSTR            
4078 06				db 5 + 1 
4079 .. 00			db "TCASE",0              
407f				endm 
# End of macro CWHEAD
407f			; | TCASE ( s -- s ) Title case string s  | DONE 
407f					if DEBUG_FORTH_WORDS_KEY 
407f						DMARK "TCS" 
407f f5				push af  
4080 3a 94 40			ld a, (.dmark)  
4083 32 bd fb			ld (debug_mark),a  
4086 3a 95 40			ld a, (.dmark+1)  
4089 32 be fb			ld (debug_mark+1),a  
408c 3a 96 40			ld a, (.dmark+2)  
408f 32 bf fb			ld (debug_mark+2),a  
4092 18 03			jr .pastdmark  
4094 ..			.dmark: db "TCS"  
4097 f1			.pastdmark: pop af  
4098			endm  
# End of macro DMARK
4098						CALLMONITOR 
4098 cd ea 15			call break_point_state  
409b				endm  
# End of macro CALLMONITOR
409b					endif 
409b			 
409b					FORTH_DSP 
409b cd 34 1d			call macro_forth_dsp 
409e				endm 
# End of macro FORTH_DSP
409e					 
409e			; TODO check is string type 
409e			 
409e					FORTH_DSP_VALUEHL 
409e cd 6e 1d			call macro_dsp_valuehl 
40a1				endm 
# End of macro FORTH_DSP_VALUEHL
40a1			; get pointer to string in hl 
40a1			 
40a1					if DEBUG_FORTH_WORDS 
40a1						DMARK "TC1" 
40a1 f5				push af  
40a2 3a b6 40			ld a, (.dmark)  
40a5 32 bd fb			ld (debug_mark),a  
40a8 3a b7 40			ld a, (.dmark+1)  
40ab 32 be fb			ld (debug_mark+1),a  
40ae 3a b8 40			ld a, (.dmark+2)  
40b1 32 bf fb			ld (debug_mark+2),a  
40b4 18 03			jr .pastdmark  
40b6 ..			.dmark: db "TC1"  
40b9 f1			.pastdmark: pop af  
40ba			endm  
# End of macro DMARK
40ba						CALLMONITOR 
40ba cd ea 15			call break_point_state  
40bd				endm  
# End of macro CALLMONITOR
40bd					endif 
40bd			 
40bd					; first time in turn to upper case first char 
40bd			 
40bd 7e					ld a, (hl) 
40be c3 48 41				jp .totsiptou 
40c1			 
40c1			 
40c1 7e			.tot:		ld a, (hl) 
40c2 fe 00				cp 0 
40c4 ca 8c 41				jp z, .totdone 
40c7			 
40c7					if DEBUG_FORTH_WORDS 
40c7						DMARK "TC2" 
40c7 f5				push af  
40c8 3a dc 40			ld a, (.dmark)  
40cb 32 bd fb			ld (debug_mark),a  
40ce 3a dd 40			ld a, (.dmark+1)  
40d1 32 be fb			ld (debug_mark+1),a  
40d4 3a de 40			ld a, (.dmark+2)  
40d7 32 bf fb			ld (debug_mark+2),a  
40da 18 03			jr .pastdmark  
40dc ..			.dmark: db "TC2"  
40df f1			.pastdmark: pop af  
40e0			endm  
# End of macro DMARK
40e0						CALLMONITOR 
40e0 cd ea 15			call break_point_state  
40e3				endm  
# End of macro CALLMONITOR
40e3					endif 
40e3					; check to see if current char is a space 
40e3			 
40e3 fe 20				cp ' ' 
40e5 28 21				jr z, .totsp 
40e7 cd 3e 10				call to_lower 
40ea					if DEBUG_FORTH_WORDS 
40ea						DMARK "TC3" 
40ea f5				push af  
40eb 3a ff 40			ld a, (.dmark)  
40ee 32 bd fb			ld (debug_mark),a  
40f1 3a 00 41			ld a, (.dmark+1)  
40f4 32 be fb			ld (debug_mark+1),a  
40f7 3a 01 41			ld a, (.dmark+2)  
40fa 32 bf fb			ld (debug_mark+2),a  
40fd 18 03			jr .pastdmark  
40ff ..			.dmark: db "TC3"  
4102 f1			.pastdmark: pop af  
4103			endm  
# End of macro DMARK
4103						CALLMONITOR 
4103 cd ea 15			call break_point_state  
4106				endm  
# End of macro CALLMONITOR
4106					endif 
4106 18 63				jr .totnxt 
4108			 
4108			.totsp:         ; on a space, find next char which should be upper 
4108			 
4108					if DEBUG_FORTH_WORDS 
4108						DMARK "TC4" 
4108 f5				push af  
4109 3a 1d 41			ld a, (.dmark)  
410c 32 bd fb			ld (debug_mark),a  
410f 3a 1e 41			ld a, (.dmark+1)  
4112 32 be fb			ld (debug_mark+1),a  
4115 3a 1f 41			ld a, (.dmark+2)  
4118 32 bf fb			ld (debug_mark+2),a  
411b 18 03			jr .pastdmark  
411d ..			.dmark: db "TC4"  
4120 f1			.pastdmark: pop af  
4121			endm  
# End of macro DMARK
4121						CALLMONITOR 
4121 cd ea 15			call break_point_state  
4124				endm  
# End of macro CALLMONITOR
4124					endif 
4124					;; 
4124			 
4124 fe 20				cp ' ' 
4126 20 20				jr nz, .totsiptou 
4128 23					inc hl 
4129 7e					ld a, (hl) 
412a					if DEBUG_FORTH_WORDS 
412a						DMARK "TC5" 
412a f5				push af  
412b 3a 3f 41			ld a, (.dmark)  
412e 32 bd fb			ld (debug_mark),a  
4131 3a 40 41			ld a, (.dmark+1)  
4134 32 be fb			ld (debug_mark+1),a  
4137 3a 41 41			ld a, (.dmark+2)  
413a 32 bf fb			ld (debug_mark+2),a  
413d 18 03			jr .pastdmark  
413f ..			.dmark: db "TC5"  
4142 f1			.pastdmark: pop af  
4143			endm  
# End of macro DMARK
4143						CALLMONITOR 
4143 cd ea 15			call break_point_state  
4146				endm  
# End of macro CALLMONITOR
4146					endif 
4146 18 c0				jr .totsp 
4148 fe 00		.totsiptou:    cp 0 
414a 28 40				jr z, .totdone 
414c					; not space and not zero term so upper case it 
414c cd 35 10				call to_upper 
414f			 
414f					if DEBUG_FORTH_WORDS 
414f						DMARK "TC6" 
414f f5				push af  
4150 3a 64 41			ld a, (.dmark)  
4153 32 bd fb			ld (debug_mark),a  
4156 3a 65 41			ld a, (.dmark+1)  
4159 32 be fb			ld (debug_mark+1),a  
415c 3a 66 41			ld a, (.dmark+2)  
415f 32 bf fb			ld (debug_mark+2),a  
4162 18 03			jr .pastdmark  
4164 ..			.dmark: db "TC6"  
4167 f1			.pastdmark: pop af  
4168			endm  
# End of macro DMARK
4168						CALLMONITOR 
4168 cd ea 15			call break_point_state  
416b				endm  
# End of macro CALLMONITOR
416b					endif 
416b			 
416b			 
416b			.totnxt: 
416b			 
416b 77					ld (hl), a 
416c 23					inc hl 
416d					if DEBUG_FORTH_WORDS 
416d						DMARK "TC7" 
416d f5				push af  
416e 3a 82 41			ld a, (.dmark)  
4171 32 bd fb			ld (debug_mark),a  
4174 3a 83 41			ld a, (.dmark+1)  
4177 32 be fb			ld (debug_mark+1),a  
417a 3a 84 41			ld a, (.dmark+2)  
417d 32 bf fb			ld (debug_mark+2),a  
4180 18 03			jr .pastdmark  
4182 ..			.dmark: db "TC7"  
4185 f1			.pastdmark: pop af  
4186			endm  
# End of macro DMARK
4186						CALLMONITOR 
4186 cd ea 15			call break_point_state  
4189				endm  
# End of macro CALLMONITOR
4189					endif 
4189 c3 c1 40				jp .tot 
418c			 
418c					 
418c			 
418c			 
418c			; for each char convert to low 
418c					 
418c			.totdone: 
418c					if DEBUG_FORTH_WORDS 
418c						DMARK "TCd" 
418c f5				push af  
418d 3a a1 41			ld a, (.dmark)  
4190 32 bd fb			ld (debug_mark),a  
4193 3a a2 41			ld a, (.dmark+1)  
4196 32 be fb			ld (debug_mark+1),a  
4199 3a a3 41			ld a, (.dmark+2)  
419c 32 bf fb			ld (debug_mark+2),a  
419f 18 03			jr .pastdmark  
41a1 ..			.dmark: db "TCd"  
41a4 f1			.pastdmark: pop af  
41a5			endm  
# End of macro DMARK
41a5						CALLMONITOR 
41a5 cd ea 15			call break_point_state  
41a8				endm  
# End of macro CALLMONITOR
41a8					endif 
41a8					NEXTW 
41a8 c3 e0 1e			jp macro_next 
41ab				endm 
# End of macro NEXTW
41ab			 
41ab			.SUBSTR: 
41ab				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41ab 48				db WORD_SYS_CORE+52             
41ac 09 42			dw .LEFT            
41ae 07				db 6 + 1 
41af .. 00			db "SUBSTR",0              
41b6				endm 
# End of macro CWHEAD
41b6			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41b6			 
41b6					if DEBUG_FORTH_WORDS_KEY 
41b6						DMARK "SST" 
41b6 f5				push af  
41b7 3a cb 41			ld a, (.dmark)  
41ba 32 bd fb			ld (debug_mark),a  
41bd 3a cc 41			ld a, (.dmark+1)  
41c0 32 be fb			ld (debug_mark+1),a  
41c3 3a cd 41			ld a, (.dmark+2)  
41c6 32 bf fb			ld (debug_mark+2),a  
41c9 18 03			jr .pastdmark  
41cb ..			.dmark: db "SST"  
41ce f1			.pastdmark: pop af  
41cf			endm  
# End of macro DMARK
41cf						CALLMONITOR 
41cf cd ea 15			call break_point_state  
41d2				endm  
# End of macro CALLMONITOR
41d2					endif 
41d2			; TODO check string type 
41d2					FORTH_DSP_VALUEHL 
41d2 cd 6e 1d			call macro_dsp_valuehl 
41d5				endm 
# End of macro FORTH_DSP_VALUEHL
41d5			 
41d5 e5					push hl      ; string length 
41d6			 
41d6					FORTH_DSP_POP 
41d6 cd 26 1e			call macro_forth_dsp_pop 
41d9				endm 
# End of macro FORTH_DSP_POP
41d9			 
41d9					FORTH_DSP_VALUEHL 
41d9 cd 6e 1d			call macro_dsp_valuehl 
41dc				endm 
# End of macro FORTH_DSP_VALUEHL
41dc			 
41dc e5					push hl     ; start char 
41dd			 
41dd					FORTH_DSP_POP 
41dd cd 26 1e			call macro_forth_dsp_pop 
41e0				endm 
# End of macro FORTH_DSP_POP
41e0			 
41e0			 
41e0					FORTH_DSP_VALUE 
41e0 cd 57 1d			call macro_forth_dsp_value 
41e3				endm 
# End of macro FORTH_DSP_VALUE
41e3			 
41e3 d1					pop de    ; get start post offset 
41e4			 
41e4 19					add hl, de    ; starting offset 
41e5			 
41e5 c1					pop bc 
41e6 c5					push bc      ; grab size of string 
41e7			 
41e7 e5					push hl    ; save string start  
41e8			 
41e8 26 00				ld h, 0 
41ea 69					ld l, c 
41eb 23					inc hl 
41ec 23					inc hl 
41ed			 
41ed cd 8f 11				call malloc 
41f0				if DEBUG_FORTH_MALLOC_GUARD 
41f0 cc 73 51				call z,malloc_error 
41f3				endif 
41f3			 
41f3 eb					ex de, hl      ; save malloc area for string copy 
41f4 e1					pop hl    ; get back source 
41f5 c1					pop bc    ; get length of string back 
41f6			 
41f6 d5					push de    ; save malloc area for after we push 
41f7 ed b0				ldir     ; copy substr 
41f9			 
41f9			 
41f9 eb					ex de, hl 
41fa 3e 00				ld a, 0 
41fc 77					ld (hl), a   ; term substr 
41fd			 
41fd					 
41fd e1					pop hl    ; get malloc so we can push it 
41fe e5					push hl   ; save so we can free it afterwards 
41ff			 
41ff cd e5 1b				call forth_push_str 
4202			 
4202 e1					pop hl 
4203 cd 59 12				call free 
4206			 
4206					 
4206					 
4206			 
4206			 
4206					NEXTW 
4206 c3 e0 1e			jp macro_next 
4209				endm 
# End of macro NEXTW
4209			 
4209			.LEFT: 
4209				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4209 48				db WORD_SYS_CORE+52             
420a 31 42			dw .RIGHT            
420c 05				db 4 + 1 
420d .. 00			db "LEFT",0              
4212				endm 
# End of macro CWHEAD
4212			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4212					if DEBUG_FORTH_WORDS_KEY 
4212						DMARK "LEF" 
4212 f5				push af  
4213 3a 27 42			ld a, (.dmark)  
4216 32 bd fb			ld (debug_mark),a  
4219 3a 28 42			ld a, (.dmark+1)  
421c 32 be fb			ld (debug_mark+1),a  
421f 3a 29 42			ld a, (.dmark+2)  
4222 32 bf fb			ld (debug_mark+2),a  
4225 18 03			jr .pastdmark  
4227 ..			.dmark: db "LEF"  
422a f1			.pastdmark: pop af  
422b			endm  
# End of macro DMARK
422b						CALLMONITOR 
422b cd ea 15			call break_point_state  
422e				endm  
# End of macro CALLMONITOR
422e					endif 
422e			 
422e					NEXTW 
422e c3 e0 1e			jp macro_next 
4231				endm 
# End of macro NEXTW
4231			.RIGHT: 
4231				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4231 48				db WORD_SYS_CORE+52             
4232 5a 42			dw .STR2NUM            
4234 06				db 5 + 1 
4235 .. 00			db "RIGHT",0              
423b				endm 
# End of macro CWHEAD
423b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
423b					if DEBUG_FORTH_WORDS_KEY 
423b						DMARK "RIG" 
423b f5				push af  
423c 3a 50 42			ld a, (.dmark)  
423f 32 bd fb			ld (debug_mark),a  
4242 3a 51 42			ld a, (.dmark+1)  
4245 32 be fb			ld (debug_mark+1),a  
4248 3a 52 42			ld a, (.dmark+2)  
424b 32 bf fb			ld (debug_mark+2),a  
424e 18 03			jr .pastdmark  
4250 ..			.dmark: db "RIG"  
4253 f1			.pastdmark: pop af  
4254			endm  
# End of macro DMARK
4254						CALLMONITOR 
4254 cd ea 15			call break_point_state  
4257				endm  
# End of macro CALLMONITOR
4257					endif 
4257			 
4257					NEXTW 
4257 c3 e0 1e			jp macro_next 
425a				endm 
# End of macro NEXTW
425a			 
425a			 
425a			.STR2NUM: 
425a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
425a 48				db WORD_SYS_CORE+52             
425b e6 42			dw .NUM2STR            
425d 08				db 7 + 1 
425e .. 00			db "STR2NUM",0              
4266				endm 
# End of macro CWHEAD
4266			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4266			 
4266			 
4266			; TODO STR type check to do 
4266					if DEBUG_FORTH_WORDS_KEY 
4266						DMARK "S2N" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 bd fb			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 be fb			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 bf fb			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "S2N"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f						CALLMONITOR 
427f cd ea 15			call break_point_state  
4282				endm  
# End of macro CALLMONITOR
4282					endif 
4282			 
4282					;FORTH_DSP 
4282					FORTH_DSP_VALUE 
4282 cd 57 1d			call macro_forth_dsp_value 
4285				endm 
# End of macro FORTH_DSP_VALUE
4285					;inc hl 
4285			 
4285 eb					ex de, hl 
4286					if DEBUG_FORTH_WORDS 
4286						DMARK "S2a" 
4286 f5				push af  
4287 3a 9b 42			ld a, (.dmark)  
428a 32 bd fb			ld (debug_mark),a  
428d 3a 9c 42			ld a, (.dmark+1)  
4290 32 be fb			ld (debug_mark+1),a  
4293 3a 9d 42			ld a, (.dmark+2)  
4296 32 bf fb			ld (debug_mark+2),a  
4299 18 03			jr .pastdmark  
429b ..			.dmark: db "S2a"  
429e f1			.pastdmark: pop af  
429f			endm  
# End of macro DMARK
429f						CALLMONITOR 
429f cd ea 15			call break_point_state  
42a2				endm  
# End of macro CALLMONITOR
42a2					endif 
42a2 cd bd 10				call string_to_uint16 
42a5			 
42a5					if DEBUG_FORTH_WORDS 
42a5						DMARK "S2b" 
42a5 f5				push af  
42a6 3a ba 42			ld a, (.dmark)  
42a9 32 bd fb			ld (debug_mark),a  
42ac 3a bb 42			ld a, (.dmark+1)  
42af 32 be fb			ld (debug_mark+1),a  
42b2 3a bc 42			ld a, (.dmark+2)  
42b5 32 bf fb			ld (debug_mark+2),a  
42b8 18 03			jr .pastdmark  
42ba ..			.dmark: db "S2b"  
42bd f1			.pastdmark: pop af  
42be			endm  
# End of macro DMARK
42be						CALLMONITOR 
42be cd ea 15			call break_point_state  
42c1				endm  
# End of macro CALLMONITOR
42c1					endif 
42c1			;		push hl 
42c1					FORTH_DSP_POP 
42c1 cd 26 1e			call macro_forth_dsp_pop 
42c4				endm 
# End of macro FORTH_DSP_POP
42c4			;		pop hl 
42c4					 
42c4					if DEBUG_FORTH_WORDS 
42c4						DMARK "S2b" 
42c4 f5				push af  
42c5 3a d9 42			ld a, (.dmark)  
42c8 32 bd fb			ld (debug_mark),a  
42cb 3a da 42			ld a, (.dmark+1)  
42ce 32 be fb			ld (debug_mark+1),a  
42d1 3a db 42			ld a, (.dmark+2)  
42d4 32 bf fb			ld (debug_mark+2),a  
42d7 18 03			jr .pastdmark  
42d9 ..			.dmark: db "S2b"  
42dc f1			.pastdmark: pop af  
42dd			endm  
# End of macro DMARK
42dd						CALLMONITOR 
42dd cd ea 15			call break_point_state  
42e0				endm  
# End of macro CALLMONITOR
42e0					endif 
42e0 cd 77 1b				call forth_push_numhl	 
42e3			 
42e3				 
42e3				       NEXTW 
42e3 c3 e0 1e			jp macro_next 
42e6				endm 
# End of macro NEXTW
42e6			.NUM2STR: 
42e6				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
42e6 48				db WORD_SYS_CORE+52             
42e7 f5 42			dw .CONCAT            
42e9 08				db 7 + 1 
42ea .. 00			db "NUM2STR",0              
42f2				endm 
# End of macro CWHEAD
42f2			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
42f2			 
42f2			;		; malloc a string to target 
42f2			;		ld hl, 10     ; TODO max string size should be fine 
42f2			;		call malloc 
42f2			;		push hl    ; save malloc location 
42f2			; 
42f2			; 
42f2			;; TODO check int type 
42f2			;		FORTH_DSP_VALUEHL 
42f2			;		ld a, l 
42f2			;		call DispAToASCII   
42f2			;;TODO need to chage above call to dump into string 
42f2			; 
42f2			; 
42f2			 
42f2				       NEXTW 
42f2 c3 e0 1e			jp macro_next 
42f5				endm 
# End of macro NEXTW
42f5			 
42f5			.CONCAT: 
42f5				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
42f5 48				db WORD_SYS_CORE+52             
42f6 a8 43			dw .FIND            
42f8 07				db 6 + 1 
42f9 .. 00			db "CONCAT",0              
4300				endm 
# End of macro CWHEAD
4300			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4300			 
4300			; TODO check string type 
4300			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4300			 
4300					if DEBUG_FORTH_WORDS_KEY 
4300						DMARK "CON" 
4300 f5				push af  
4301 3a 15 43			ld a, (.dmark)  
4304 32 bd fb			ld (debug_mark),a  
4307 3a 16 43			ld a, (.dmark+1)  
430a 32 be fb			ld (debug_mark+1),a  
430d 3a 17 43			ld a, (.dmark+2)  
4310 32 bf fb			ld (debug_mark+2),a  
4313 18 03			jr .pastdmark  
4315 ..			.dmark: db "CON"  
4318 f1			.pastdmark: pop af  
4319			endm  
# End of macro DMARK
4319						CALLMONITOR 
4319 cd ea 15			call break_point_state  
431c				endm  
# End of macro CALLMONITOR
431c					endif 
431c			 
431c			 
431c					FORTH_DSP_VALUE 
431c cd 57 1d			call macro_forth_dsp_value 
431f				endm 
# End of macro FORTH_DSP_VALUE
431f e5					push hl   ; s2 
4320			 
4320					FORTH_DSP_POP 
4320 cd 26 1e			call macro_forth_dsp_pop 
4323				endm 
# End of macro FORTH_DSP_POP
4323			 
4323					FORTH_DSP_VALUE 
4323 cd 57 1d			call macro_forth_dsp_value 
4326				endm 
# End of macro FORTH_DSP_VALUE
4326			 
4326 e5					push hl   ; s1 
4327			 
4327					FORTH_DSP_POP 
4327 cd 26 1e			call macro_forth_dsp_pop 
432a				endm 
# End of macro FORTH_DSP_POP
432a					 
432a			 
432a					; copy s1 
432a			 
432a				 
432a					; save ptr 
432a e1					pop hl  
432b e5					push hl 
432c 3e 00				ld a, 0 
432e cd 31 11				call strlent 
4331					;inc hl    ; zer0 
4331 06 00				ld b, 0 
4333 4d					ld c, l 
4334 e1					pop hl		 
4335 11 a3 ef				ld de, scratch	 
4338					if DEBUG_FORTH_WORDS 
4338						DMARK "CO1" 
4338 f5				push af  
4339 3a 4d 43			ld a, (.dmark)  
433c 32 bd fb			ld (debug_mark),a  
433f 3a 4e 43			ld a, (.dmark+1)  
4342 32 be fb			ld (debug_mark+1),a  
4345 3a 4f 43			ld a, (.dmark+2)  
4348 32 bf fb			ld (debug_mark+2),a  
434b 18 03			jr .pastdmark  
434d ..			.dmark: db "CO1"  
4350 f1			.pastdmark: pop af  
4351			endm  
# End of macro DMARK
4351						CALLMONITOR 
4351 cd ea 15			call break_point_state  
4354				endm  
# End of macro CALLMONITOR
4354					endif 
4354 ed b0				ldir 
4356			 
4356 e1					pop hl 
4357 e5					push hl 
4358 d5					push de 
4359			 
4359			 
4359 3e 00				ld a, 0 
435b cd 31 11				call strlent 
435e 23					inc hl    ; zer0 
435f 23					inc hl 
4360 06 00				ld b, 0 
4362 4d					ld c, l 
4363 d1					pop de 
4364 e1					pop hl		 
4365					if DEBUG_FORTH_WORDS 
4365						DMARK "CO2" 
4365 f5				push af  
4366 3a 7a 43			ld a, (.dmark)  
4369 32 bd fb			ld (debug_mark),a  
436c 3a 7b 43			ld a, (.dmark+1)  
436f 32 be fb			ld (debug_mark+1),a  
4372 3a 7c 43			ld a, (.dmark+2)  
4375 32 bf fb			ld (debug_mark+2),a  
4378 18 03			jr .pastdmark  
437a ..			.dmark: db "CO2"  
437d f1			.pastdmark: pop af  
437e			endm  
# End of macro DMARK
437e						CALLMONITOR 
437e cd ea 15			call break_point_state  
4381				endm  
# End of macro CALLMONITOR
4381					endif 
4381 ed b0				ldir 
4383			 
4383			 
4383			 
4383 21 a3 ef				ld hl, scratch 
4386					if DEBUG_FORTH_WORDS 
4386						DMARK "CO5" 
4386 f5				push af  
4387 3a 9b 43			ld a, (.dmark)  
438a 32 bd fb			ld (debug_mark),a  
438d 3a 9c 43			ld a, (.dmark+1)  
4390 32 be fb			ld (debug_mark+1),a  
4393 3a 9d 43			ld a, (.dmark+2)  
4396 32 bf fb			ld (debug_mark+2),a  
4399 18 03			jr .pastdmark  
439b ..			.dmark: db "CO5"  
439e f1			.pastdmark: pop af  
439f			endm  
# End of macro DMARK
439f						CALLMONITOR 
439f cd ea 15			call break_point_state  
43a2				endm  
# End of macro CALLMONITOR
43a2					endif 
43a2			 
43a2 cd e5 1b				call forth_push_str 
43a5			 
43a5			 
43a5			 
43a5			 
43a5				       NEXTW 
43a5 c3 e0 1e			jp macro_next 
43a8				endm 
# End of macro NEXTW
43a8			 
43a8			 
43a8			.FIND: 
43a8				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43a8 4b				db WORD_SYS_CORE+55             
43a9 66 44			dw .LEN            
43ab 05				db 4 + 1 
43ac .. 00			db "FIND",0              
43b1				endm 
# End of macro CWHEAD
43b1			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43b1			 
43b1					if DEBUG_FORTH_WORDS_KEY 
43b1						DMARK "FND" 
43b1 f5				push af  
43b2 3a c6 43			ld a, (.dmark)  
43b5 32 bd fb			ld (debug_mark),a  
43b8 3a c7 43			ld a, (.dmark+1)  
43bb 32 be fb			ld (debug_mark+1),a  
43be 3a c8 43			ld a, (.dmark+2)  
43c1 32 bf fb			ld (debug_mark+2),a  
43c4 18 03			jr .pastdmark  
43c6 ..			.dmark: db "FND"  
43c9 f1			.pastdmark: pop af  
43ca			endm  
# End of macro DMARK
43ca						CALLMONITOR 
43ca cd ea 15			call break_point_state  
43cd				endm  
# End of macro CALLMONITOR
43cd					endif 
43cd			 
43cd			; TODO check string type 
43cd					FORTH_DSP_VALUE 
43cd cd 57 1d			call macro_forth_dsp_value 
43d0				endm 
# End of macro FORTH_DSP_VALUE
43d0			 
43d0 e5					push hl    
43d1 7e					ld a,(hl)    ; char to find   
43d2			; TODO change char to substr 
43d2			 
43d2 f5					push af 
43d3					 
43d3			 
43d3			 
43d3					if DEBUG_FORTH_WORDS 
43d3						DMARK "FN1" 
43d3 f5				push af  
43d4 3a e8 43			ld a, (.dmark)  
43d7 32 bd fb			ld (debug_mark),a  
43da 3a e9 43			ld a, (.dmark+1)  
43dd 32 be fb			ld (debug_mark+1),a  
43e0 3a ea 43			ld a, (.dmark+2)  
43e3 32 bf fb			ld (debug_mark+2),a  
43e6 18 03			jr .pastdmark  
43e8 ..			.dmark: db "FN1"  
43eb f1			.pastdmark: pop af  
43ec			endm  
# End of macro DMARK
43ec						CALLMONITOR 
43ec cd ea 15			call break_point_state  
43ef				endm  
# End of macro CALLMONITOR
43ef					endif 
43ef			 
43ef					FORTH_DSP_POP 
43ef cd 26 1e			call macro_forth_dsp_pop 
43f2				endm 
# End of macro FORTH_DSP_POP
43f2			 
43f2					; string to search 
43f2			 
43f2					FORTH_DSP_VALUE 
43f2 cd 57 1d			call macro_forth_dsp_value 
43f5				endm 
# End of macro FORTH_DSP_VALUE
43f5			 
43f5 d1					pop de  ; d is char to find  
43f6			 
43f6					if DEBUG_FORTH_WORDS 
43f6						DMARK "FN2" 
43f6 f5				push af  
43f7 3a 0b 44			ld a, (.dmark)  
43fa 32 bd fb			ld (debug_mark),a  
43fd 3a 0c 44			ld a, (.dmark+1)  
4400 32 be fb			ld (debug_mark+1),a  
4403 3a 0d 44			ld a, (.dmark+2)  
4406 32 bf fb			ld (debug_mark+2),a  
4409 18 03			jr .pastdmark  
440b ..			.dmark: db "FN2"  
440e f1			.pastdmark: pop af  
440f			endm  
# End of macro DMARK
440f						CALLMONITOR 
440f cd ea 15			call break_point_state  
4412				endm  
# End of macro CALLMONITOR
4412					endif 
4412					 
4412 01 00 00				ld bc, 0 
4415 7e			.findchar:      ld a,(hl) 
4416 fe 00				cp 0   		 
4418 28 27				jr z, .finddone     
441a ba					cp d 
441b 28 20				jr z, .foundchar 
441d 03					inc bc 
441e 23					inc hl 
441f					if DEBUG_FORTH_WORDS 
441f						DMARK "FN3" 
441f f5				push af  
4420 3a 34 44			ld a, (.dmark)  
4423 32 bd fb			ld (debug_mark),a  
4426 3a 35 44			ld a, (.dmark+1)  
4429 32 be fb			ld (debug_mark+1),a  
442c 3a 36 44			ld a, (.dmark+2)  
442f 32 bf fb			ld (debug_mark+2),a  
4432 18 03			jr .pastdmark  
4434 ..			.dmark: db "FN3"  
4437 f1			.pastdmark: pop af  
4438			endm  
# End of macro DMARK
4438						CALLMONITOR 
4438 cd ea 15			call break_point_state  
443b				endm  
# End of macro CALLMONITOR
443b					endif 
443b 18 d8				jr .findchar 
443d			 
443d			 
443d c5			.foundchar:	push bc 
443e e1					pop hl 
443f 18 03				jr .findexit 
4441			 
4441			 
4441							 
4441			 
4441			.finddone:     ; got to end of string with no find 
4441 21 00 00				ld hl, 0 
4444			.findexit: 
4444			 
4444					if DEBUG_FORTH_WORDS 
4444						DMARK "FNd" 
4444 f5				push af  
4445 3a 59 44			ld a, (.dmark)  
4448 32 bd fb			ld (debug_mark),a  
444b 3a 5a 44			ld a, (.dmark+1)  
444e 32 be fb			ld (debug_mark+1),a  
4451 3a 5b 44			ld a, (.dmark+2)  
4454 32 bf fb			ld (debug_mark+2),a  
4457 18 03			jr .pastdmark  
4459 ..			.dmark: db "FNd"  
445c f1			.pastdmark: pop af  
445d			endm  
# End of macro DMARK
445d						CALLMONITOR 
445d cd ea 15			call break_point_state  
4460				endm  
# End of macro CALLMONITOR
4460					endif 
4460 cd 77 1b			call forth_push_numhl 
4463			 
4463				       NEXTW 
4463 c3 e0 1e			jp macro_next 
4466				endm 
# End of macro NEXTW
4466			 
4466			.LEN: 
4466				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4466 4c				db WORD_SYS_CORE+56             
4467 9b 44			dw .CHAR            
4469 06				db 5 + 1 
446a .. 00			db "COUNT",0              
4470				endm 
# End of macro CWHEAD
4470			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4470			 
4470					if DEBUG_FORTH_WORDS_KEY 
4470						DMARK "CNT" 
4470 f5				push af  
4471 3a 85 44			ld a, (.dmark)  
4474 32 bd fb			ld (debug_mark),a  
4477 3a 86 44			ld a, (.dmark+1)  
447a 32 be fb			ld (debug_mark+1),a  
447d 3a 87 44			ld a, (.dmark+2)  
4480 32 bf fb			ld (debug_mark+2),a  
4483 18 03			jr .pastdmark  
4485 ..			.dmark: db "CNT"  
4488 f1			.pastdmark: pop af  
4489			endm  
# End of macro DMARK
4489						CALLMONITOR 
4489 cd ea 15			call break_point_state  
448c				endm  
# End of macro CALLMONITOR
448c					endif 
448c			; TODO check string type 
448c					FORTH_DSP 
448c cd 34 1d			call macro_forth_dsp 
448f				endm 
# End of macro FORTH_DSP
448f					;v5FORTH_DSP_VALUE 
448f			 
448f 23					inc hl 
4490			 
4490 3e 00				ld a, 0 
4492 cd 31 11				call strlent 
4495			 
4495 cd 77 1b				call forth_push_numhl 
4498			 
4498			 
4498			 
4498				       NEXTW 
4498 c3 e0 1e			jp macro_next 
449b				endm 
# End of macro NEXTW
449b			.CHAR: 
449b				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
449b 4d				db WORD_SYS_CORE+57             
449c d1 44			dw .ENDSTR            
449e 05				db 4 + 1 
449f .. 00			db "CHAR",0              
44a4				endm 
# End of macro CWHEAD
44a4			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
44a4					if DEBUG_FORTH_WORDS_KEY 
44a4						DMARK "CHR" 
44a4 f5				push af  
44a5 3a b9 44			ld a, (.dmark)  
44a8 32 bd fb			ld (debug_mark),a  
44ab 3a ba 44			ld a, (.dmark+1)  
44ae 32 be fb			ld (debug_mark+1),a  
44b1 3a bb 44			ld a, (.dmark+2)  
44b4 32 bf fb			ld (debug_mark+2),a  
44b7 18 03			jr .pastdmark  
44b9 ..			.dmark: db "CHR"  
44bc f1			.pastdmark: pop af  
44bd			endm  
# End of macro DMARK
44bd						CALLMONITOR 
44bd cd ea 15			call break_point_state  
44c0				endm  
# End of macro CALLMONITOR
44c0					endif 
44c0					FORTH_DSP 
44c0 cd 34 1d			call macro_forth_dsp 
44c3				endm 
# End of macro FORTH_DSP
44c3					;v5 FORTH_DSP_VALUE 
44c3 23					inc hl      ; now at start of numeric as string 
44c4			 
44c4			;		push hl 
44c4			 
44c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c4 cd 26 1e			call macro_forth_dsp_pop 
44c7				endm 
# End of macro FORTH_DSP_POP
44c7			 
44c7			;		pop hl 
44c7			 
44c7					; push the content of a onto the stack as a value 
44c7			 
44c7 7e					ld a,(hl)   ; get char 
44c8 26 00				ld h,0 
44ca 6f					ld l,a 
44cb cd 77 1b				call forth_push_numhl 
44ce			 
44ce				       NEXTW 
44ce c3 e0 1e			jp macro_next 
44d1				endm 
# End of macro NEXTW
44d1			 
44d1			 
44d1			 
44d1			 
44d1			.ENDSTR: 
44d1			; eof 
44d1			 
# End of file forth_words_str.asm
44d1			include "forth_words_key.asm" 
44d1			 
44d1			; | ## Keyboard Words 
44d1			 
44d1			.KEY: 
44d1				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
44d1 3e				db WORD_SYS_CORE+42             
44d2 01 45			dw .WAITK            
44d4 04				db 3 + 1 
44d5 .. 00			db "KEY",0              
44d9				endm 
# End of macro CWHEAD
44d9			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
44d9			 
44d9					if DEBUG_FORTH_WORDS_KEY 
44d9						DMARK "KEY" 
44d9 f5				push af  
44da 3a ee 44			ld a, (.dmark)  
44dd 32 bd fb			ld (debug_mark),a  
44e0 3a ef 44			ld a, (.dmark+1)  
44e3 32 be fb			ld (debug_mark+1),a  
44e6 3a f0 44			ld a, (.dmark+2)  
44e9 32 bf fb			ld (debug_mark+2),a  
44ec 18 03			jr .pastdmark  
44ee ..			.dmark: db "KEY"  
44f1 f1			.pastdmark: pop af  
44f2			endm  
# End of macro DMARK
44f2						CALLMONITOR 
44f2 cd ea 15			call break_point_state  
44f5				endm  
# End of macro CALLMONITOR
44f5					endif 
44f5			; TODO currently waits 
44f5 cd da 65				call cin 
44f8					;call cin_wait 
44f8 6f					ld l, a 
44f9 26 00				ld h, 0 
44fb cd 77 1b				call forth_push_numhl 
44fe					NEXTW 
44fe c3 e0 1e			jp macro_next 
4501				endm 
# End of macro NEXTW
4501			.WAITK: 
4501				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4501 3f				db WORD_SYS_CORE+43             
4502 33 45			dw .ACCEPT            
4504 06				db 5 + 1 
4505 .. 00			db "WAITK",0              
450b				endm 
# End of macro CWHEAD
450b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
450b					if DEBUG_FORTH_WORDS_KEY 
450b						DMARK "WAI" 
450b f5				push af  
450c 3a 20 45			ld a, (.dmark)  
450f 32 bd fb			ld (debug_mark),a  
4512 3a 21 45			ld a, (.dmark+1)  
4515 32 be fb			ld (debug_mark+1),a  
4518 3a 22 45			ld a, (.dmark+2)  
451b 32 bf fb			ld (debug_mark+2),a  
451e 18 03			jr .pastdmark  
4520 ..			.dmark: db "WAI"  
4523 f1			.pastdmark: pop af  
4524			endm  
# End of macro DMARK
4524						CALLMONITOR 
4524 cd ea 15			call break_point_state  
4527				endm  
# End of macro CALLMONITOR
4527					endif 
4527 cd c9 65				call cin_wait 
452a 6f					ld l, a 
452b 26 00				ld h, 0 
452d cd 77 1b				call forth_push_numhl 
4530					NEXTW 
4530 c3 e0 1e			jp macro_next 
4533				endm 
# End of macro NEXTW
4533			.ACCEPT: 
4533				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4533 40				db WORD_SYS_CORE+44             
4534 91 45			dw .EDIT            
4536 07				db 6 + 1 
4537 .. 00			db "ACCEPT",0              
453e				endm 
# End of macro CWHEAD
453e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
453e					; TODO crashes on push 
453e					if DEBUG_FORTH_WORDS_KEY 
453e						DMARK "ACC" 
453e f5				push af  
453f 3a 53 45			ld a, (.dmark)  
4542 32 bd fb			ld (debug_mark),a  
4545 3a 54 45			ld a, (.dmark+1)  
4548 32 be fb			ld (debug_mark+1),a  
454b 3a 55 45			ld a, (.dmark+2)  
454e 32 bf fb			ld (debug_mark+2),a  
4551 18 03			jr .pastdmark  
4553 ..			.dmark: db "ACC"  
4556 f1			.pastdmark: pop af  
4557			endm  
# End of macro DMARK
4557						CALLMONITOR 
4557 cd ea 15			call break_point_state  
455a				endm  
# End of macro CALLMONITOR
455a					endif 
455a 21 a1 f1				ld hl, os_input 
455d 3e 00				ld a, 0 
455f 77					ld (hl),a 
4560 3a cc f9				ld a,(f_cursor_ptr) 
4563 16 64				ld d, 100 
4565 0e 00				ld c, 0 
4567 1e 28				ld e, 40 
4569 cd f5 0c				call input_str 
456c					; TODO perhaps do a type check and wrap in quotes if not a number 
456c 21 a1 f1				ld hl, os_input 
456f					if DEBUG_FORTH_WORDS 
456f						DMARK "AC1" 
456f f5				push af  
4570 3a 84 45			ld a, (.dmark)  
4573 32 bd fb			ld (debug_mark),a  
4576 3a 85 45			ld a, (.dmark+1)  
4579 32 be fb			ld (debug_mark+1),a  
457c 3a 86 45			ld a, (.dmark+2)  
457f 32 bf fb			ld (debug_mark+2),a  
4582 18 03			jr .pastdmark  
4584 ..			.dmark: db "AC1"  
4587 f1			.pastdmark: pop af  
4588			endm  
# End of macro DMARK
4588						CALLMONITOR 
4588 cd ea 15			call break_point_state  
458b				endm  
# End of macro CALLMONITOR
458b					endif 
458b cd e5 1b				call forth_push_str 
458e					NEXTW 
458e c3 e0 1e			jp macro_next 
4591				endm 
# End of macro NEXTW
4591			 
4591			.EDIT: 
4591				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4591 40				db WORD_SYS_CORE+44             
4592 1a 46			dw .ENDKEY            
4594 05				db 4 + 1 
4595 .. 00			db "EDIT",0              
459a				endm 
# End of macro CWHEAD
459a			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
459a			 
459a					; TODO does not copy from stack 
459a					if DEBUG_FORTH_WORDS_KEY 
459a						DMARK "EDT" 
459a f5				push af  
459b 3a af 45			ld a, (.dmark)  
459e 32 bd fb			ld (debug_mark),a  
45a1 3a b0 45			ld a, (.dmark+1)  
45a4 32 be fb			ld (debug_mark+1),a  
45a7 3a b1 45			ld a, (.dmark+2)  
45aa 32 bf fb			ld (debug_mark+2),a  
45ad 18 03			jr .pastdmark  
45af ..			.dmark: db "EDT"  
45b2 f1			.pastdmark: pop af  
45b3			endm  
# End of macro DMARK
45b3						CALLMONITOR 
45b3 cd ea 15			call break_point_state  
45b6				endm  
# End of macro CALLMONITOR
45b6					endif 
45b6			 
45b6					FORTH_DSP 
45b6 cd 34 1d			call macro_forth_dsp 
45b9				endm 
# End of macro FORTH_DSP
45b9					;v5 FORTH_DSP_VALUE 
45b9 23					inc hl    ; TODO do type check 
45ba			 
45ba e5					push hl 
45bb 3e 00				ld a, 0 
45bd cd 31 11				call strlent 
45c0 23					inc hl 
45c1			 
45c1 06 00				ld b, 0 
45c3 4d					ld c, l 
45c4			 
45c4 e1					pop hl 
45c5 11 a1 f1				ld de, os_input 
45c8					if DEBUG_FORTH_WORDS_KEY 
45c8						DMARK "EDc" 
45c8 f5				push af  
45c9 3a dd 45			ld a, (.dmark)  
45cc 32 bd fb			ld (debug_mark),a  
45cf 3a de 45			ld a, (.dmark+1)  
45d2 32 be fb			ld (debug_mark+1),a  
45d5 3a df 45			ld a, (.dmark+2)  
45d8 32 bf fb			ld (debug_mark+2),a  
45db 18 03			jr .pastdmark  
45dd ..			.dmark: db "EDc"  
45e0 f1			.pastdmark: pop af  
45e1			endm  
# End of macro DMARK
45e1						CALLMONITOR 
45e1 cd ea 15			call break_point_state  
45e4				endm  
# End of macro CALLMONITOR
45e4					endif 
45e4 ed b0				ldir 
45e6			 
45e6			 
45e6 21 a1 f1				ld hl, os_input 
45e9					;ld a, 0 
45e9					;ld (hl),a 
45e9 3a cc f9				ld a,(f_cursor_ptr) 
45ec 16 64				ld d, 100 
45ee 0e 00				ld c, 0 
45f0 1e 28				ld e, 40 
45f2 cd f5 0c				call input_str 
45f5					; TODO perhaps do a type check and wrap in quotes if not a number 
45f5 21 a1 f1				ld hl, os_input 
45f8					if DEBUG_FORTH_WORDS 
45f8						DMARK "ED1" 
45f8 f5				push af  
45f9 3a 0d 46			ld a, (.dmark)  
45fc 32 bd fb			ld (debug_mark),a  
45ff 3a 0e 46			ld a, (.dmark+1)  
4602 32 be fb			ld (debug_mark+1),a  
4605 3a 0f 46			ld a, (.dmark+2)  
4608 32 bf fb			ld (debug_mark+2),a  
460b 18 03			jr .pastdmark  
460d ..			.dmark: db "ED1"  
4610 f1			.pastdmark: pop af  
4611			endm  
# End of macro DMARK
4611						CALLMONITOR 
4611 cd ea 15			call break_point_state  
4614				endm  
# End of macro CALLMONITOR
4614					endif 
4614 cd e5 1b				call forth_push_str 
4617					NEXTW 
4617 c3 e0 1e			jp macro_next 
461a				endm 
# End of macro NEXTW
461a			 
461a			 
461a			 
461a			.ENDKEY: 
461a			; eof 
461a			 
# End of file forth_words_key.asm
461a			 
461a			if STORAGE_SE 
461a			   	include "forth_words_storage.asm" 
461a			 
461a			; | ## Fixed Storage Words 
461a			 
461a			 
461a			.BREAD: 
461a			  
461a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
461a 3a				db WORD_SYS_CORE+38             
461b 93 46			dw .BWRITE            
461d 06				db 5 + 1 
461e .. 00			db "BREAD",0              
4624				endm 
# End of macro CWHEAD
4624			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4624				 
4624					if DEBUG_FORTH_WORDS_KEY 
4624						DMARK "BRD" 
4624 f5				push af  
4625 3a 39 46			ld a, (.dmark)  
4628 32 bd fb			ld (debug_mark),a  
462b 3a 3a 46			ld a, (.dmark+1)  
462e 32 be fb			ld (debug_mark+1),a  
4631 3a 3b 46			ld a, (.dmark+2)  
4634 32 bf fb			ld (debug_mark+2),a  
4637 18 03			jr .pastdmark  
4639 ..			.dmark: db "BRD"  
463c f1			.pastdmark: pop af  
463d			endm  
# End of macro DMARK
463d						CALLMONITOR 
463d cd ea 15			call break_point_state  
4640				endm  
# End of macro CALLMONITOR
4640					endif 
4640			 
4640				FORTH_DSP_VALUEHL 
4640 cd 6e 1d			call macro_dsp_valuehl 
4643				endm 
# End of macro FORTH_DSP_VALUEHL
4643			 
4643				FORTH_DSP_POP 
4643 cd 26 1e			call macro_forth_dsp_pop 
4646				endm 
# End of macro FORTH_DSP_POP
4646			 
4646				; calc block address 
4646			 
4646 eb				ex de, hl 
4647 3e 40			ld a, STORE_BLOCK_PHY 
4649 cd 4b 0c			call Mult16 
464c			 
464c			 
464c 11 e8 f9			ld de, store_page 
464f			 
464f					if DEBUG_FORTH_WORDS 
464f						DMARK "BR1" 
464f f5				push af  
4650 3a 64 46			ld a, (.dmark)  
4653 32 bd fb			ld (debug_mark),a  
4656 3a 65 46			ld a, (.dmark+1)  
4659 32 be fb			ld (debug_mark+1),a  
465c 3a 66 46			ld a, (.dmark+2)  
465f 32 bf fb			ld (debug_mark+2),a  
4662 18 03			jr .pastdmark  
4664 ..			.dmark: db "BR1"  
4667 f1			.pastdmark: pop af  
4668			endm  
# End of macro DMARK
4668						CALLMONITOR 
4668 cd ea 15			call break_point_state  
466b				endm  
# End of macro CALLMONITOR
466b					endif 
466b			 
466b cd 09 03			call storage_read_block 
466e			 
466e 21 ea f9		        ld hl, store_page+2 
4671					if DEBUG_FORTH_WORDS 
4671						DMARK "BR2" 
4671 f5				push af  
4672 3a 86 46			ld a, (.dmark)  
4675 32 bd fb			ld (debug_mark),a  
4678 3a 87 46			ld a, (.dmark+1)  
467b 32 be fb			ld (debug_mark+1),a  
467e 3a 88 46			ld a, (.dmark+2)  
4681 32 bf fb			ld (debug_mark+2),a  
4684 18 03			jr .pastdmark  
4686 ..			.dmark: db "BR2"  
4689 f1			.pastdmark: pop af  
468a			endm  
# End of macro DMARK
468a						CALLMONITOR 
468a cd ea 15			call break_point_state  
468d				endm  
# End of macro CALLMONITOR
468d					endif 
468d cd e5 1b			call forth_push_str 
4690			 
4690			 
4690					NEXTW 
4690 c3 e0 1e			jp macro_next 
4693				endm 
# End of macro NEXTW
4693			.BWRITE: 
4693				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4693 3a				db WORD_SYS_CORE+38             
4694 28 47			dw .BUPD            
4696 07				db 6 + 1 
4697 .. 00			db "BWRITE",0              
469e				endm 
# End of macro CWHEAD
469e			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
469e			 
469e					if DEBUG_FORTH_WORDS_KEY 
469e						DMARK "BWR" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 bd fb			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 be fb			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 bf fb			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "BWR"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7						CALLMONITOR 
46b7 cd ea 15			call break_point_state  
46ba				endm  
# End of macro CALLMONITOR
46ba					endif 
46ba			 
46ba				FORTH_DSP_VALUEHL 
46ba cd 6e 1d			call macro_dsp_valuehl 
46bd				endm 
# End of macro FORTH_DSP_VALUEHL
46bd			 
46bd				; calc block address 
46bd			 
46bd eb				ex de, hl 
46be 3e 40			ld a, STORE_BLOCK_PHY 
46c0 cd 4b 0c			call Mult16 
46c3			 
46c3 e5				push hl         ; address 
46c4			 
46c4				FORTH_DSP_POP 
46c4 cd 26 1e			call macro_forth_dsp_pop 
46c7				endm 
# End of macro FORTH_DSP_POP
46c7			 
46c7				FORTH_DSP_VALUEHL 
46c7 cd 6e 1d			call macro_dsp_valuehl 
46ca				endm 
# End of macro FORTH_DSP_VALUEHL
46ca			 
46ca				FORTH_DSP_POP 
46ca cd 26 1e			call macro_forth_dsp_pop 
46cd				endm 
# End of macro FORTH_DSP_POP
46cd			 
46cd cd 12 0a			call storage_clear_page 
46d0			 
46d0				; copy string to store page 
46d0			 
46d0 e5				push hl     ; save string address 
46d1			 
46d1 3e 00			ld a, 0 
46d3 cd 31 11			call strlent 
46d6			 
46d6 23				inc hl 
46d7			 
46d7 4d				ld c, l 
46d8 06 00			ld b, 0 
46da			 
46da e1				pop hl 
46db 11 ea f9			ld de, store_page + 2 
46de					if DEBUG_FORTH_WORDS 
46de						DMARK "BW1" 
46de f5				push af  
46df 3a f3 46			ld a, (.dmark)  
46e2 32 bd fb			ld (debug_mark),a  
46e5 3a f4 46			ld a, (.dmark+1)  
46e8 32 be fb			ld (debug_mark+1),a  
46eb 3a f5 46			ld a, (.dmark+2)  
46ee 32 bf fb			ld (debug_mark+2),a  
46f1 18 03			jr .pastdmark  
46f3 ..			.dmark: db "BW1"  
46f6 f1			.pastdmark: pop af  
46f7			endm  
# End of macro DMARK
46f7						CALLMONITOR 
46f7 cd ea 15			call break_point_state  
46fa				endm  
# End of macro CALLMONITOR
46fa					endif 
46fa ed b0			ldir 
46fc			 
46fc			 
46fc				; poke the start of the block with flags to prevent high level file ops hitting the block 
46fc			 
46fc 21 ff ff			ld hl, $ffff 
46ff			 
46ff 22 e8 f9			ld (store_page), hl	 
4702				 
4702 e1				pop hl    ; get address 
4703 11 e8 f9			ld de, store_page 
4706			 
4706					if DEBUG_FORTH_WORDS 
4706						DMARK "BW2" 
4706 f5				push af  
4707 3a 1b 47			ld a, (.dmark)  
470a 32 bd fb			ld (debug_mark),a  
470d 3a 1c 47			ld a, (.dmark+1)  
4710 32 be fb			ld (debug_mark+1),a  
4713 3a 1d 47			ld a, (.dmark+2)  
4716 32 bf fb			ld (debug_mark+2),a  
4719 18 03			jr .pastdmark  
471b ..			.dmark: db "BW2"  
471e f1			.pastdmark: pop af  
471f			endm  
# End of macro DMARK
471f						CALLMONITOR 
471f cd ea 15			call break_point_state  
4722				endm  
# End of macro CALLMONITOR
4722					endif 
4722			 
4722 cd 6e 03			call storage_write_block 
4725			 
4725					NEXTW 
4725 c3 e0 1e			jp macro_next 
4728				endm 
# End of macro NEXTW
4728			 
4728			.BUPD: 
4728				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4728 3a				db WORD_SYS_CORE+38             
4729 7e 47			dw .BYID            
472b 05				db 4 + 1 
472c .. 00			db "BUPD",0              
4731				endm 
# End of macro CWHEAD
4731			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4731			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4731			; | | or completely different file system structure. 
4731			 
4731					if DEBUG_FORTH_WORDS_KEY 
4731						DMARK "BUD" 
4731 f5				push af  
4732 3a 46 47			ld a, (.dmark)  
4735 32 bd fb			ld (debug_mark),a  
4738 3a 47 47			ld a, (.dmark+1)  
473b 32 be fb			ld (debug_mark+1),a  
473e 3a 48 47			ld a, (.dmark+2)  
4741 32 bf fb			ld (debug_mark+2),a  
4744 18 03			jr .pastdmark  
4746 ..			.dmark: db "BUD"  
4749 f1			.pastdmark: pop af  
474a			endm  
# End of macro DMARK
474a						CALLMONITOR 
474a cd ea 15			call break_point_state  
474d				endm  
# End of macro CALLMONITOR
474d					endif 
474d			 
474d				FORTH_DSP_VALUEHL 
474d cd 6e 1d			call macro_dsp_valuehl 
4750				endm 
# End of macro FORTH_DSP_VALUEHL
4750			 
4750				; calc block address 
4750			 
4750 eb				ex de, hl 
4751 3e 40			ld a, STORE_BLOCK_PHY 
4753 cd 4b 0c			call Mult16 
4756			 
4756				FORTH_DSP_POP 
4756 cd 26 1e			call macro_forth_dsp_pop 
4759				endm 
# End of macro FORTH_DSP_POP
4759			 
4759			 
4759 11 e8 f9			ld de, store_page 
475c			 
475c					if DEBUG_FORTH_WORDS 
475c						DMARK "BUe" 
475c f5				push af  
475d 3a 71 47			ld a, (.dmark)  
4760 32 bd fb			ld (debug_mark),a  
4763 3a 72 47			ld a, (.dmark+1)  
4766 32 be fb			ld (debug_mark+1),a  
4769 3a 73 47			ld a, (.dmark+2)  
476c 32 bf fb			ld (debug_mark+2),a  
476f 18 03			jr .pastdmark  
4771 ..			.dmark: db "BUe"  
4774 f1			.pastdmark: pop af  
4775			endm  
# End of macro DMARK
4775						CALLMONITOR 
4775 cd ea 15			call break_point_state  
4778				endm  
# End of macro CALLMONITOR
4778					endif 
4778			 
4778 cd 6e 03			call storage_write_block 
477b			 
477b					NEXTW 
477b c3 e0 1e			jp macro_next 
477e				endm 
# End of macro NEXTW
477e			 
477e			.BYID: 
477e			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
477e			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
477e			; 
477e			;		 
477e			;		if DEBUG_FORTH_WORDS_KEY 
477e			;			DMARK "BYID" 
477e			;			CALLMONITOR 
477e			;		endif 
477e			; 
477e			;		; get direct address 
477e			; 
477e			;		FORTH_DSP_VALUEHL 
477e			; 
477e			;		FORTH_DSP_POP 
477e			; 
477e			;	; calc block address 
477e			; 
477e			;	ex de, hl 
477e			;	ld a, STORE_BLOCK_PHY 
477e			;	call Mult16 
477e			;	;	do BREAD with number as param 
477e			;	; push the file name	 
477e			;	ld de, store_page 
477e			;	call storage_read_block 
477e			 ;       ld hl, store_page+2 
477e			; 
477e			; 
477e			;		NEXTW 
477e			;.BYNAME: 
477e			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
477e			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
477e			;		NEXTW 
477e			; 
477e			.DIR: 
477e				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
477e 3a				db WORD_SYS_CORE+38             
477f 82 48			dw .SAVE            
4781 04				db 3 + 1 
4782 .. 00			db "DIR",0              
4786				endm 
# End of macro CWHEAD
4786			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4786			 
4786					if DEBUG_FORTH_WORDS_KEY 
4786						DMARK "DIR" 
4786 f5				push af  
4787 3a 9b 47			ld a, (.dmark)  
478a 32 bd fb			ld (debug_mark),a  
478d 3a 9c 47			ld a, (.dmark+1)  
4790 32 be fb			ld (debug_mark+1),a  
4793 3a 9d 47			ld a, (.dmark+2)  
4796 32 bf fb			ld (debug_mark+2),a  
4799 18 03			jr .pastdmark  
479b ..			.dmark: db "DIR"  
479e f1			.pastdmark: pop af  
479f			endm  
# End of macro DMARK
479f						CALLMONITOR 
479f cd ea 15			call break_point_state  
47a2				endm  
# End of macro CALLMONITOR
47a2					endif 
47a2 cd ba 03			call storage_get_block_0 
47a5			 
47a5 21 e8 f9			ld hl, store_page     ; get current id count 
47a8 46				ld b, (hl) 
47a9 0e 00			ld c, 0    ; count of files   
47ab					if DEBUG_FORTH_WORDS 
47ab						DMARK "DI1" 
47ab f5				push af  
47ac 3a c0 47			ld a, (.dmark)  
47af 32 bd fb			ld (debug_mark),a  
47b2 3a c1 47			ld a, (.dmark+1)  
47b5 32 be fb			ld (debug_mark+1),a  
47b8 3a c2 47			ld a, (.dmark+2)  
47bb 32 bf fb			ld (debug_mark+2),a  
47be 18 03			jr .pastdmark  
47c0 ..			.dmark: db "DI1"  
47c3 f1			.pastdmark: pop af  
47c4			endm  
# End of macro DMARK
47c4						CALLMONITOR 
47c4 cd ea 15			call break_point_state  
47c7				endm  
# End of macro CALLMONITOR
47c7					endif 
47c7			 
47c7				; check for empty drive 
47c7			 
47c7 3e 00			ld a, 0 
47c9 b8				cp b 
47ca ca 38 48			jp z, .dirdone 
47cd			 
47cd				; for each of the current ids do a search for them and if found push to stack 
47cd			 
47cd c5			.diritem:	push bc 
47ce 21 40 00				ld hl, STORE_BLOCK_PHY 
47d1 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
47d3 58					ld e,b 
47d4			 
47d4			;		if DEBUG_FORTH_WORDS 
47d4			;			DMARK "DI2" 
47d4			;			CALLMONITOR 
47d4			;		endif 
47d4			 
47d4 cd 27 06				call storage_findnextid 
47d7			 
47d7			;		if DEBUG_FORTH_WORDS 
47d7			;			DMARK "DI3" 
47d7			;			CALLMONITOR 
47d7			;		endif 
47d7			 
47d7					; if found hl will be non zero 
47d7			 
47d7 cd f1 0c				call ishlzero 
47da			;		ld a, l 
47da			;		add h 
47da			; 
47da			;		cp 0 
47da 28 59				jr z, .dirnotfound 
47dc			 
47dc					; increase count 
47dc			 
47dc c1					pop bc	 
47dd 0c					inc c 
47de c5					push bc 
47df					 
47df			 
47df					; get file header and push the file name 
47df			 
47df 11 e8 f9				ld de, store_page 
47e2 cd 09 03				call storage_read_block 
47e5			 
47e5					; push file id to stack 
47e5				 
47e5 3a e8 f9				ld a, (store_page) 
47e8 26 00				ld h, 0 
47ea 6f					ld l, a 
47eb cd 77 1b				call forth_push_numhl 
47ee			 
47ee					; push extent count to stack  
47ee				 
47ee 3a ea f9				ld a, (store_page+2) 
47f1 26 00				ld h, 0 
47f3 6f					ld l, a 
47f4 cd 77 1b				call forth_push_numhl 
47f7			 
47f7					; push file name 
47f7			 
47f7 21 eb f9				ld hl, store_page+3 
47fa					if DEBUG_FORTH_WORDS 
47fa						DMARK "DI5" 
47fa f5				push af  
47fb 3a 0f 48			ld a, (.dmark)  
47fe 32 bd fb			ld (debug_mark),a  
4801 3a 10 48			ld a, (.dmark+1)  
4804 32 be fb			ld (debug_mark+1),a  
4807 3a 11 48			ld a, (.dmark+2)  
480a 32 bf fb			ld (debug_mark+2),a  
480d 18 03			jr .pastdmark  
480f ..			.dmark: db "DI5"  
4812 f1			.pastdmark: pop af  
4813			endm  
# End of macro DMARK
4813						CALLMONITOR 
4813 cd ea 15			call break_point_state  
4816				endm  
# End of macro CALLMONITOR
4816					endif 
4816 cd e5 1b				call forth_push_str 
4819					if DEBUG_FORTH_WORDS 
4819						DMARK "DI6" 
4819 f5				push af  
481a 3a 2e 48			ld a, (.dmark)  
481d 32 bd fb			ld (debug_mark),a  
4820 3a 2f 48			ld a, (.dmark+1)  
4823 32 be fb			ld (debug_mark+1),a  
4826 3a 30 48			ld a, (.dmark+2)  
4829 32 bf fb			ld (debug_mark+2),a  
482c 18 03			jr .pastdmark  
482e ..			.dmark: db "DI6"  
4831 f1			.pastdmark: pop af  
4832			endm  
# End of macro DMARK
4832						CALLMONITOR 
4832 cd ea 15			call break_point_state  
4835				endm  
# End of macro CALLMONITOR
4835					endif 
4835			.dirnotfound: 
4835 c1					pop bc     
4836 10 95				djnz .diritem 
4838				 
4838			.dirdone:	 
4838					if DEBUG_FORTH_WORDS 
4838						DMARK "DI7" 
4838 f5				push af  
4839 3a 4d 48			ld a, (.dmark)  
483c 32 bd fb			ld (debug_mark),a  
483f 3a 4e 48			ld a, (.dmark+1)  
4842 32 be fb			ld (debug_mark+1),a  
4845 3a 4f 48			ld a, (.dmark+2)  
4848 32 bf fb			ld (debug_mark+2),a  
484b 18 03			jr .pastdmark  
484d ..			.dmark: db "DI7"  
4850 f1			.pastdmark: pop af  
4851			endm  
# End of macro DMARK
4851						CALLMONITOR 
4851 cd ea 15			call break_point_state  
4854				endm  
# End of macro CALLMONITOR
4854					endif 
4854			 
4854					; push a count of the dir items found 
4854			 
4854 26 00				ld h, 0 
4856 69					ld l, c 
4857 cd 77 1b				call forth_push_numhl 
485a			 
485a					; push the bank label 
485a			 
485a cd ba 03				call storage_get_block_0 
485d			 
485d				 
485d 21 eb f9		 		ld hl, store_page+3 
4860			 
4860					if DEBUG_FORTH_WORDS 
4860						DMARK "DI8" 
4860 f5				push af  
4861 3a 75 48			ld a, (.dmark)  
4864 32 bd fb			ld (debug_mark),a  
4867 3a 76 48			ld a, (.dmark+1)  
486a 32 be fb			ld (debug_mark+1),a  
486d 3a 77 48			ld a, (.dmark+2)  
4870 32 bf fb			ld (debug_mark+2),a  
4873 18 03			jr .pastdmark  
4875 ..			.dmark: db "DI8"  
4878 f1			.pastdmark: pop af  
4879			endm  
# End of macro DMARK
4879						CALLMONITOR 
4879 cd ea 15			call break_point_state  
487c				endm  
# End of macro CALLMONITOR
487c					endif 
487c cd e5 1b				call forth_push_str 
487f			 
487f			 
487f				 
487f					NEXTW 
487f c3 e0 1e			jp macro_next 
4882				endm 
# End of macro NEXTW
4882			.SAVE: 
4882			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4882			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4882			;		NEXTW 
4882			;.LOAD: 
4882			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4882			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4882			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4882			;; > > The LOAD command can not be used in any user words or compound lines. 
4882			; 
4882			;		; store_openext use it. If zero it is EOF 
4882			; 
4882			;		; read block from current stream id 
4882			;		; if the block does not contain zero term keep reading blocks until zero found 
4882			;		; push the block to stack 
4882			;		; save the block id to stream 
4882			; 
4882			; 
4882			;		FORTH_DSP_VALUEHL 
4882			; 
4882			;;		push hl 
4882			; 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LOA" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			;		FORTH_DSP_POP 
4882			; 
4882			;;		pop hl 
4882			; 
4882			;		ld h, l 
4882			;		ld l, 0 
4882			; 
4882			;		push hl     ; stack holds current file id and extent to work with 
4882			; 
4882			; 
4882			;		ld de, store_page      ; get block zero of file 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LO0" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			;		call storage_read 
4882			; 
4882			;		ld a, (store_page+2)    ; max extents for this file 
4882			;		ld  (store_openmaxext),a   ; get our limit 
4882			; 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LOE" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			; 
4882			;; TODO dont know why max extents are not present 
4882			;;		cp 0 
4882			;;		jp z, .loadeof     ; dont read past eof 
4882			; 
4882			;;		ld a, 1   ; start from the head of the file 
4882			; 
4882			;.loadline:	pop hl 
4882			;		inc hl 
4882			;		ld  a, (store_openmaxext)   ; get our limit 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LOx" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			;		inc a 
4882			;		cp l 
4882			;		jp z, .loadeof 
4882			;		push hl    ; save current extent 
4882			; 
4882			;		ld de, store_page 
4882			; 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LO1" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			;		call storage_read 
4882			; 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LO2" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			;	call ishlzero 
4882			;	ld a, l 
4882			;	add h 
4882			;	cp 0 
4882			;	jr z, .loadeof 
4882			; 
4882			;	; not eof so hl should point to data to exec 
4882			; 
4882			;	; will need to add the FORTH_END_BUFFER flag 
4882			 ; 
4882			;	ld hl, store_page+2 
4882			;	ld bc, 255 
4882			;	ld a, 0 
4882			;	cpir 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LOt" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			;	dec hl 
4882			;	ld a, ' ' 
4882			;	ld (hl), a 
4882			;	inc hl 
4882			;	ld (hl), a 
4882			;	inc hl 
4882			;	ld (hl), a 
4882			;	inc hl 
4882			;	ld a, FORTH_END_BUFFER 
4882			;	ld (hl), a 
4882			; 
4882			;	; TODO handle more than a single block read 
4882			; 
4882			; 
4882			;	ld hl, store_page+2 
4882			; 
4882			;	ld (os_tok_ptr), hl 
4882			; 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LO3" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			; 
4882			;	call forthparse 
4882			;	call forthexec 
4882			;	call forthexec_cleanup 
4882			; 
4882			;	; go to next extent 
4882			; 
4882			;	; get next block  or mark as eof 
4882			;	jp .loadline 
4882			; 
4882			; 
4882			; 
4882			;	       NEXTW 
4882			;.loadeof:	ld a, 0 
4882			;		ld (store_openext), a 
4882			; 
4882			;	if DEBUG_STORESE 
4882			;		DMARK "LOF" 
4882			;		CALLMONITOR 
4882			;	endif 
4882			;		ret 
4882			;		;NEXTW 
4882			;.BSAVE:   
4882			; 
4882			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4882			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4882			;		NEXTW 
4882			;.BLOAD: 
4882			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4882			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4882			;		NEXTW 
4882			;;;; counter gap 
4882			 
4882			 
4882			.SEO: 
4882				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4882 64				db WORD_SYS_CORE+80             
4883 a1 48			dw .SEI            
4885 04				db 3 + 1 
4886 .. 00			db "SEO",0              
488a				endm 
# End of macro CWHEAD
488a			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
488a			 
488a					; get port 
488a			 
488a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
488a cd 6e 1d			call macro_dsp_valuehl 
488d				endm 
# End of macro FORTH_DSP_VALUEHL
488d			 
488d e5					push hl    ; u2 - byte 
488e			 
488e					; destroy value TOS 
488e			 
488e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
488e cd 26 1e			call macro_forth_dsp_pop 
4891				endm 
# End of macro FORTH_DSP_POP
4891			 
4891					; get byte to send 
4891			 
4891					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4891 cd 6e 1d			call macro_dsp_valuehl 
4894				endm 
# End of macro FORTH_DSP_VALUEHL
4894			 
4894 e5					push hl    ; u1 - addr 
4895			 
4895					; destroy value TOS 
4895			 
4895					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4895 cd 26 1e			call macro_forth_dsp_pop 
4898				endm 
# End of macro FORTH_DSP_POP
4898			 
4898					; one value on hl get other one back 
4898			 
4898 d1					pop de   ; u1 - byte 
4899			 
4899 e1					pop hl   ; u2 - addr 
489a			 
489a					; TODO Send SPI byte 
489a			 
489a			 
489a 7b					ld a, e 
489b cd e7 01				call se_writebyte 
489e			 
489e					 
489e			 
489e					NEXTW 
489e c3 e0 1e			jp macro_next 
48a1				endm 
# End of macro NEXTW
48a1			 
48a1			.SEI: 
48a1				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
48a1 65				db WORD_SYS_CORE+81             
48a2 bb 48			dw .SFREE            
48a4 04				db 3 + 1 
48a5 .. 00			db "SEI",0              
48a9				endm 
# End of macro CWHEAD
48a9			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
48a9			 
48a9					; get port 
48a9			 
48a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48a9 cd 6e 1d			call macro_dsp_valuehl 
48ac				endm 
# End of macro FORTH_DSP_VALUEHL
48ac			 
48ac			;		push hl 
48ac			 
48ac					; destroy value TOS 
48ac			 
48ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48ac cd 26 1e			call macro_forth_dsp_pop 
48af				endm 
# End of macro FORTH_DSP_POP
48af			 
48af					; one value on hl get other one back 
48af			 
48af			;		pop hl 
48af			 
48af			 
48af					; TODO Get SPI byte 
48af			 
48af cd 89 02				call se_readbyte 
48b2			 
48b2 26 00				ld h, 0 
48b4 6f					ld l, a 
48b5 cd 77 1b				call forth_push_numhl 
48b8			 
48b8					NEXTW 
48b8 c3 e0 1e			jp macro_next 
48bb				endm 
# End of macro NEXTW
48bb			 
48bb			.SFREE: 
48bb				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
48bb 67				db WORD_SYS_CORE+83             
48bc ea 48			dw .SIZE            
48be 06				db 5 + 1 
48bf .. 00			db "FFREE",0              
48c5				endm 
# End of macro CWHEAD
48c5			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
48c5					if DEBUG_FORTH_WORDS_KEY 
48c5						DMARK "FFR" 
48c5 f5				push af  
48c6 3a da 48			ld a, (.dmark)  
48c9 32 bd fb			ld (debug_mark),a  
48cc 3a db 48			ld a, (.dmark+1)  
48cf 32 be fb			ld (debug_mark+1),a  
48d2 3a dc 48			ld a, (.dmark+2)  
48d5 32 bf fb			ld (debug_mark+2),a  
48d8 18 03			jr .pastdmark  
48da ..			.dmark: db "FFR"  
48dd f1			.pastdmark: pop af  
48de			endm  
# End of macro DMARK
48de						CALLMONITOR 
48de cd ea 15			call break_point_state  
48e1				endm  
# End of macro CALLMONITOR
48e1					endif 
48e1			 
48e1 cd c1 06				call storage_freeblocks 
48e4			 
48e4 cd 77 1b				call forth_push_numhl 
48e7			 
48e7				       NEXTW 
48e7 c3 e0 1e			jp macro_next 
48ea				endm 
# End of macro NEXTW
48ea			.SIZE: 
48ea				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
48ea 67				db WORD_SYS_CORE+83             
48eb 1e 49			dw .CREATE            
48ed 05				db 4 + 1 
48ee .. 00			db "SIZE",0              
48f3				endm 
# End of macro CWHEAD
48f3			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
48f3					if DEBUG_FORTH_WORDS_KEY 
48f3						DMARK "SIZ" 
48f3 f5				push af  
48f4 3a 08 49			ld a, (.dmark)  
48f7 32 bd fb			ld (debug_mark),a  
48fa 3a 09 49			ld a, (.dmark+1)  
48fd 32 be fb			ld (debug_mark+1),a  
4900 3a 0a 49			ld a, (.dmark+2)  
4903 32 bf fb			ld (debug_mark+2),a  
4906 18 03			jr .pastdmark  
4908 ..			.dmark: db "SIZ"  
490b f1			.pastdmark: pop af  
490c			endm  
# End of macro DMARK
490c						CALLMONITOR 
490c cd ea 15			call break_point_state  
490f				endm  
# End of macro CALLMONITOR
490f					endif 
490f			 
490f					FORTH_DSP_VALUEHL 
490f cd 6e 1d			call macro_dsp_valuehl 
4912				endm 
# End of macro FORTH_DSP_VALUEHL
4912			;		push hl 
4912					FORTH_DSP_POP 
4912 cd 26 1e			call macro_forth_dsp_pop 
4915				endm 
# End of macro FORTH_DSP_POP
4915			;		pop hl 
4915 cd 38 03				call storage_file_size 
4918			 
4918 cd 77 1b				call forth_push_numhl 
491b			  
491b			 
491b				       NEXTW 
491b c3 e0 1e			jp macro_next 
491e				endm 
# End of macro NEXTW
491e			 
491e			.CREATE: 
491e				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
491e 68				db WORD_SYS_CORE+84             
491f 8c 49			dw .APPEND            
4921 07				db 6 + 1 
4922 .. 00			db "CREATE",0              
4929				endm 
# End of macro CWHEAD
4929			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4929			; | | e.g.  
4929			; | | TestProgram CREATE 
4929			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4929			; | |  
4929			; | | Max file IDs are 255. 
4929			; | |  
4929					 
4929					if DEBUG_FORTH_WORDS_KEY 
4929						DMARK "CRT" 
4929 f5				push af  
492a 3a 3e 49			ld a, (.dmark)  
492d 32 bd fb			ld (debug_mark),a  
4930 3a 3f 49			ld a, (.dmark+1)  
4933 32 be fb			ld (debug_mark+1),a  
4936 3a 40 49			ld a, (.dmark+2)  
4939 32 bf fb			ld (debug_mark+2),a  
493c 18 03			jr .pastdmark  
493e ..			.dmark: db "CRT"  
4941 f1			.pastdmark: pop af  
4942			endm  
# End of macro DMARK
4942						CALLMONITOR 
4942 cd ea 15			call break_point_state  
4945				endm  
# End of macro CALLMONITOR
4945					endif 
4945			;		call storage_get_block_0 
4945			 
4945					; TODO pop hl 
4945			 
4945					;v5 FORTH_DSP_VALUE 
4945					FORTH_DSP_VALUE 
4945 cd 57 1d			call macro_forth_dsp_value 
4948				endm 
# End of macro FORTH_DSP_VALUE
4948			 
4948				if DEBUG_STORESE 
4948					DMARK "CR1" 
4948 f5				push af  
4949 3a 5d 49			ld a, (.dmark)  
494c 32 bd fb			ld (debug_mark),a  
494f 3a 5e 49			ld a, (.dmark+1)  
4952 32 be fb			ld (debug_mark+1),a  
4955 3a 5f 49			ld a, (.dmark+2)  
4958 32 bf fb			ld (debug_mark+2),a  
495b 18 03			jr .pastdmark  
495d ..			.dmark: db "CR1"  
4960 f1			.pastdmark: pop af  
4961			endm  
# End of macro DMARK
4961					CALLMONITOR 
4961 cd ea 15			call break_point_state  
4964				endm  
# End of macro CALLMONITOR
4964				endif 
4964			;		push hl 
4964			;		FORTH_DSP_POP 
4964			;		pop hl 
4964			 
4964			;		inc hl   ; move past the type marker 
4964			 
4964 cd f7 06				call storage_create 
4967			 
4967				if DEBUG_STORESE 
4967					DMARK "CT1" 
4967 f5				push af  
4968 3a 7c 49			ld a, (.dmark)  
496b 32 bd fb			ld (debug_mark),a  
496e 3a 7d 49			ld a, (.dmark+1)  
4971 32 be fb			ld (debug_mark+1),a  
4974 3a 7e 49			ld a, (.dmark+2)  
4977 32 bf fb			ld (debug_mark+2),a  
497a 18 03			jr .pastdmark  
497c ..			.dmark: db "CT1"  
497f f1			.pastdmark: pop af  
4980			endm  
# End of macro DMARK
4980					CALLMONITOR 
4980 cd ea 15			call break_point_state  
4983				endm  
# End of macro CALLMONITOR
4983				endif 
4983			;		push hl 
4983					FORTH_DSP_POP 
4983 cd 26 1e			call macro_forth_dsp_pop 
4986				endm 
# End of macro FORTH_DSP_POP
4986			;		pop hl 
4986					; push file id to stack 
4986 cd 77 1b				call forth_push_numhl 
4989			 
4989			 
4989			 
4989				       NEXTW 
4989 c3 e0 1e			jp macro_next 
498c				endm 
# End of macro NEXTW
498c			 
498c			.APPEND: 
498c				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
498c 69				db WORD_SYS_CORE+85             
498d 1d 4a			dw .SDEL            
498f 07				db 6 + 1 
4990 .. 00			db "APPEND",0              
4997				endm 
# End of macro CWHEAD
4997			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4997			; | | e.g. 
4997			; | | Test CREATE      -> $01 
4997			; | | "A string to add to file" $01 APPEND 
4997			; | |  
4997			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4997					if DEBUG_FORTH_WORDS_KEY 
4997						DMARK "APP" 
4997 f5				push af  
4998 3a ac 49			ld a, (.dmark)  
499b 32 bd fb			ld (debug_mark),a  
499e 3a ad 49			ld a, (.dmark+1)  
49a1 32 be fb			ld (debug_mark+1),a  
49a4 3a ae 49			ld a, (.dmark+2)  
49a7 32 bf fb			ld (debug_mark+2),a  
49aa 18 03			jr .pastdmark  
49ac ..			.dmark: db "APP"  
49af f1			.pastdmark: pop af  
49b0			endm  
# End of macro DMARK
49b0						CALLMONITOR 
49b0 cd ea 15			call break_point_state  
49b3				endm  
# End of macro CALLMONITOR
49b3					endif 
49b3			 
49b3					FORTH_DSP_VALUEHL 
49b3 cd 6e 1d			call macro_dsp_valuehl 
49b6				endm 
# End of macro FORTH_DSP_VALUEHL
49b6 e5					push hl 	; save file id 
49b7			 
49b7				if DEBUG_STORESE 
49b7					DMARK "AP1" 
49b7 f5				push af  
49b8 3a cc 49			ld a, (.dmark)  
49bb 32 bd fb			ld (debug_mark),a  
49be 3a cd 49			ld a, (.dmark+1)  
49c1 32 be fb			ld (debug_mark+1),a  
49c4 3a ce 49			ld a, (.dmark+2)  
49c7 32 bf fb			ld (debug_mark+2),a  
49ca 18 03			jr .pastdmark  
49cc ..			.dmark: db "AP1"  
49cf f1			.pastdmark: pop af  
49d0			endm  
# End of macro DMARK
49d0					CALLMONITOR 
49d0 cd ea 15			call break_point_state  
49d3				endm  
# End of macro CALLMONITOR
49d3				endif 
49d3					FORTH_DSP_POP 
49d3 cd 26 1e			call macro_forth_dsp_pop 
49d6				endm 
# End of macro FORTH_DSP_POP
49d6			 
49d6					FORTH_DSP_VALUEHL 
49d6 cd 6e 1d			call macro_dsp_valuehl 
49d9				endm 
# End of macro FORTH_DSP_VALUEHL
49d9					;v5 FORTH_DSP_VALUE 
49d9 e5					push hl 	; save ptr to string to save 
49da			 
49da				if DEBUG_STORESE 
49da					DMARK "AP1" 
49da f5				push af  
49db 3a ef 49			ld a, (.dmark)  
49de 32 bd fb			ld (debug_mark),a  
49e1 3a f0 49			ld a, (.dmark+1)  
49e4 32 be fb			ld (debug_mark+1),a  
49e7 3a f1 49			ld a, (.dmark+2)  
49ea 32 bf fb			ld (debug_mark+2),a  
49ed 18 03			jr .pastdmark  
49ef ..			.dmark: db "AP1"  
49f2 f1			.pastdmark: pop af  
49f3			endm  
# End of macro DMARK
49f3					CALLMONITOR 
49f3 cd ea 15			call break_point_state  
49f6				endm  
# End of macro CALLMONITOR
49f6				endif 
49f6					FORTH_DSP_POP 
49f6 cd 26 1e			call macro_forth_dsp_pop 
49f9				endm 
# End of macro FORTH_DSP_POP
49f9			 
49f9 d1					pop de 
49fa e1					pop hl 
49fb				if DEBUG_STORESE 
49fb					DMARK "AP2" 
49fb f5				push af  
49fc 3a 10 4a			ld a, (.dmark)  
49ff 32 bd fb			ld (debug_mark),a  
4a02 3a 11 4a			ld a, (.dmark+1)  
4a05 32 be fb			ld (debug_mark+1),a  
4a08 3a 12 4a			ld a, (.dmark+2)  
4a0b 32 bf fb			ld (debug_mark+2),a  
4a0e 18 03			jr .pastdmark  
4a10 ..			.dmark: db "AP2"  
4a13 f1			.pastdmark: pop af  
4a14			endm  
# End of macro DMARK
4a14					CALLMONITOR 
4a14 cd ea 15			call break_point_state  
4a17				endm  
# End of macro CALLMONITOR
4a17				endif 
4a17					;inc de ; skip var type indicator 
4a17			 
4a17					; TODO how to append numerics???? 
4a17			 
4a17 cd d1 08				call storage_append		 
4a1a			 
4a1a				       NEXTW 
4a1a c3 e0 1e			jp macro_next 
4a1d				endm 
# End of macro NEXTW
4a1d			.SDEL: 
4a1d				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a1d 6a				db WORD_SYS_CORE+86             
4a1e 69 4a			dw .OPEN            
4a20 05				db 4 + 1 
4a21 .. 00			db "ERA",0              
4a25				endm 
# End of macro CWHEAD
4a25			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a25					FORTH_DSP_VALUEHL 
4a25 cd 6e 1d			call macro_dsp_valuehl 
4a28				endm 
# End of macro FORTH_DSP_VALUEHL
4a28			;		push hl 	; save file id 
4a28			 
4a28					if DEBUG_FORTH_WORDS_KEY 
4a28						DMARK "ERA" 
4a28 f5				push af  
4a29 3a 3d 4a			ld a, (.dmark)  
4a2c 32 bd fb			ld (debug_mark),a  
4a2f 3a 3e 4a			ld a, (.dmark+1)  
4a32 32 be fb			ld (debug_mark+1),a  
4a35 3a 3f 4a			ld a, (.dmark+2)  
4a38 32 bf fb			ld (debug_mark+2),a  
4a3b 18 03			jr .pastdmark  
4a3d ..			.dmark: db "ERA"  
4a40 f1			.pastdmark: pop af  
4a41			endm  
# End of macro DMARK
4a41						CALLMONITOR 
4a41 cd ea 15			call break_point_state  
4a44				endm  
# End of macro CALLMONITOR
4a44					endif 
4a44				if DEBUG_STORESE 
4a44					DMARK "ER1" 
4a44 f5				push af  
4a45 3a 59 4a			ld a, (.dmark)  
4a48 32 bd fb			ld (debug_mark),a  
4a4b 3a 5a 4a			ld a, (.dmark+1)  
4a4e 32 be fb			ld (debug_mark+1),a  
4a51 3a 5b 4a			ld a, (.dmark+2)  
4a54 32 bf fb			ld (debug_mark+2),a  
4a57 18 03			jr .pastdmark  
4a59 ..			.dmark: db "ER1"  
4a5c f1			.pastdmark: pop af  
4a5d			endm  
# End of macro DMARK
4a5d					CALLMONITOR 
4a5d cd ea 15			call break_point_state  
4a60				endm  
# End of macro CALLMONITOR
4a60				endif 
4a60					FORTH_DSP_POP 
4a60 cd 26 1e			call macro_forth_dsp_pop 
4a63				endm 
# End of macro FORTH_DSP_POP
4a63			 
4a63			;		pop hl 
4a63			 
4a63 cd 46 05				call storage_erase 
4a66				       NEXTW 
4a66 c3 e0 1e			jp macro_next 
4a69				endm 
# End of macro NEXTW
4a69			 
4a69			.OPEN: 
4a69				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4a69 6b				db WORD_SYS_CORE+87             
4a6a f0 4a			dw .READ            
4a6c 05				db 4 + 1 
4a6d .. 00			db "OPEN",0              
4a72				endm 
# End of macro CWHEAD
4a72			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4a72			; | | e.g. 
4a72			; | | $01 OPEN $01 DO $01 READ . LOOP 
4a72			 
4a72					if DEBUG_FORTH_WORDS_KEY 
4a72						DMARK "OPN" 
4a72 f5				push af  
4a73 3a 87 4a			ld a, (.dmark)  
4a76 32 bd fb			ld (debug_mark),a  
4a79 3a 88 4a			ld a, (.dmark+1)  
4a7c 32 be fb			ld (debug_mark+1),a  
4a7f 3a 89 4a			ld a, (.dmark+2)  
4a82 32 bf fb			ld (debug_mark+2),a  
4a85 18 03			jr .pastdmark  
4a87 ..			.dmark: db "OPN"  
4a8a f1			.pastdmark: pop af  
4a8b			endm  
# End of macro DMARK
4a8b						CALLMONITOR 
4a8b cd ea 15			call break_point_state  
4a8e				endm  
# End of macro CALLMONITOR
4a8e					endif 
4a8e					; TODO handle multiple file opens 
4a8e			 
4a8e 3e 01			       	ld a, 1 
4a90 32 df f9				ld (store_openext), a 
4a93			 
4a93					; get max extents for this file 
4a93				 
4a93								 
4a93					FORTH_DSP_VALUEHL 
4a93 cd 6e 1d			call macro_dsp_valuehl 
4a96				endm 
# End of macro FORTH_DSP_VALUEHL
4a96			 
4a96 65					ld h, l 
4a97 2e 00				ld l, 0 
4a99			 
4a99				if DEBUG_STORESE 
4a99					DMARK "OPN" 
4a99 f5				push af  
4a9a 3a ae 4a			ld a, (.dmark)  
4a9d 32 bd fb			ld (debug_mark),a  
4aa0 3a af 4a			ld a, (.dmark+1)  
4aa3 32 be fb			ld (debug_mark+1),a  
4aa6 3a b0 4a			ld a, (.dmark+2)  
4aa9 32 bf fb			ld (debug_mark+2),a  
4aac 18 03			jr .pastdmark  
4aae ..			.dmark: db "OPN"  
4ab1 f1			.pastdmark: pop af  
4ab2			endm  
# End of macro DMARK
4ab2					CALLMONITOR 
4ab2 cd ea 15			call break_point_state  
4ab5				endm  
# End of macro CALLMONITOR
4ab5				endif 
4ab5			;		push hl 
4ab5					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4ab5 cd 26 1e			call macro_forth_dsp_pop 
4ab8				endm 
# End of macro FORTH_DSP_POP
4ab8			;		pop hl 
4ab8						 
4ab8 11 e8 f9				ld de, store_page      ; get block zero of file 
4abb cd 4b 08				call storage_read 
4abe			 
4abe			 
4abe 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4ac1 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4ac4					 
4ac4				if DEBUG_STORESE 
4ac4					DMARK "OPx" 
4ac4 f5				push af  
4ac5 3a d9 4a			ld a, (.dmark)  
4ac8 32 bd fb			ld (debug_mark),a  
4acb 3a da 4a			ld a, (.dmark+1)  
4ace 32 be fb			ld (debug_mark+1),a  
4ad1 3a db 4a			ld a, (.dmark+2)  
4ad4 32 bf fb			ld (debug_mark+2),a  
4ad7 18 03			jr .pastdmark  
4ad9 ..			.dmark: db "OPx"  
4adc f1			.pastdmark: pop af  
4add			endm  
# End of macro DMARK
4add					CALLMONITOR 
4add cd ea 15			call break_point_state  
4ae0				endm  
# End of macro CALLMONITOR
4ae0				endif 
4ae0 fe 00				cp 0 
4ae2 20 03				jr nz, .skipopeneof 
4ae4					; have opened an empty file 
4ae4					 
4ae4 32 df f9				ld (store_openext), a 
4ae7			 
4ae7			.skipopeneof: 
4ae7			 
4ae7 6f					ld l, a 
4ae8 26 00				ld h, 0 
4aea cd 77 1b				call forth_push_numhl 
4aed			 
4aed			 
4aed				       NEXTW 
4aed c3 e0 1e			jp macro_next 
4af0				endm 
# End of macro NEXTW
4af0			.READ: 
4af0				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4af0 6c				db WORD_SYS_CORE+88             
4af1 37 4c			dw .EOF            
4af3 05				db 4 + 1 
4af4 .. 00			db "READ",0              
4af9				endm 
# End of macro CWHEAD
4af9			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4af9			; | | e.g. 
4af9			; | | $01 OPEN $01 DO $01 READ . LOOP 
4af9			 
4af9					if DEBUG_FORTH_WORDS_KEY 
4af9						DMARK "REA" 
4af9 f5				push af  
4afa 3a 0e 4b			ld a, (.dmark)  
4afd 32 bd fb			ld (debug_mark),a  
4b00 3a 0f 4b			ld a, (.dmark+1)  
4b03 32 be fb			ld (debug_mark+1),a  
4b06 3a 10 4b			ld a, (.dmark+2)  
4b09 32 bf fb			ld (debug_mark+2),a  
4b0c 18 03			jr .pastdmark  
4b0e ..			.dmark: db "REA"  
4b11 f1			.pastdmark: pop af  
4b12			endm  
# End of macro DMARK
4b12						CALLMONITOR 
4b12 cd ea 15			call break_point_state  
4b15				endm  
# End of macro CALLMONITOR
4b15					endif 
4b15					; store_openext use it. If zero it is EOF 
4b15			 
4b15					; read block from current stream id 
4b15					; if the block does not contain zero term keep reading blocks until zero found 
4b15					; push the block to stack 
4b15					; save the block id to stream 
4b15			 
4b15			 
4b15					FORTH_DSP_VALUEHL 
4b15 cd 6e 1d			call macro_dsp_valuehl 
4b18				endm 
# End of macro FORTH_DSP_VALUEHL
4b18			 
4b18			;		push hl 
4b18			 
4b18				if DEBUG_STORESE 
4b18					DMARK "REA" 
4b18 f5				push af  
4b19 3a 2d 4b			ld a, (.dmark)  
4b1c 32 bd fb			ld (debug_mark),a  
4b1f 3a 2e 4b			ld a, (.dmark+1)  
4b22 32 be fb			ld (debug_mark+1),a  
4b25 3a 2f 4b			ld a, (.dmark+2)  
4b28 32 bf fb			ld (debug_mark+2),a  
4b2b 18 03			jr .pastdmark  
4b2d ..			.dmark: db "REA"  
4b30 f1			.pastdmark: pop af  
4b31			endm  
# End of macro DMARK
4b31					CALLMONITOR 
4b31 cd ea 15			call break_point_state  
4b34				endm  
# End of macro CALLMONITOR
4b34				endif 
4b34					FORTH_DSP_POP 
4b34 cd 26 1e			call macro_forth_dsp_pop 
4b37				endm 
# End of macro FORTH_DSP_POP
4b37			 
4b37			;		pop hl 
4b37				 
4b37 65					ld h,l 
4b38			 
4b38 3a df f9				ld a, (store_openext) 
4b3b 6f					ld l, a 
4b3c					 
4b3c fe 00				cp 0 
4b3e ca 09 4c				jp z, .ateof     ; dont read past eof 
4b41			 
4b41			 
4b41 11 e8 f9				ld de, store_page 
4b44				if DEBUG_STORESE 
4b44					DMARK "RE1" 
4b44 f5				push af  
4b45 3a 59 4b			ld a, (.dmark)  
4b48 32 bd fb			ld (debug_mark),a  
4b4b 3a 5a 4b			ld a, (.dmark+1)  
4b4e 32 be fb			ld (debug_mark+1),a  
4b51 3a 5b 4b			ld a, (.dmark+2)  
4b54 32 bf fb			ld (debug_mark+2),a  
4b57 18 03			jr .pastdmark  
4b59 ..			.dmark: db "RE1"  
4b5c f1			.pastdmark: pop af  
4b5d			endm  
# End of macro DMARK
4b5d					CALLMONITOR 
4b5d cd ea 15			call break_point_state  
4b60				endm  
# End of macro CALLMONITOR
4b60				endif 
4b60 cd 4b 08				call storage_read 
4b63			 
4b63				if DEBUG_STORESE 
4b63					DMARK "RE2" 
4b63 f5				push af  
4b64 3a 78 4b			ld a, (.dmark)  
4b67 32 bd fb			ld (debug_mark),a  
4b6a 3a 79 4b			ld a, (.dmark+1)  
4b6d 32 be fb			ld (debug_mark+1),a  
4b70 3a 7a 4b			ld a, (.dmark+2)  
4b73 32 bf fb			ld (debug_mark+2),a  
4b76 18 03			jr .pastdmark  
4b78 ..			.dmark: db "RE2"  
4b7b f1			.pastdmark: pop af  
4b7c			endm  
# End of macro DMARK
4b7c					CALLMONITOR 
4b7c cd ea 15			call break_point_state  
4b7f				endm  
# End of macro CALLMONITOR
4b7f				endif 
4b7f cd f1 0c			call ishlzero 
4b82			;	ld a, l 
4b82			;	add h 
4b82			;	cp 0 
4b82 ca 0f 4c			jp z, .readeof 
4b85			 
4b85				; not eof so hl should point to data to push to stack 
4b85			 
4b85				if DEBUG_STORESE 
4b85					DMARK "RE3" 
4b85 f5				push af  
4b86 3a 9a 4b			ld a, (.dmark)  
4b89 32 bd fb			ld (debug_mark),a  
4b8c 3a 9b 4b			ld a, (.dmark+1)  
4b8f 32 be fb			ld (debug_mark+1),a  
4b92 3a 9c 4b			ld a, (.dmark+2)  
4b95 32 bf fb			ld (debug_mark+2),a  
4b98 18 03			jr .pastdmark  
4b9a ..			.dmark: db "RE3"  
4b9d f1			.pastdmark: pop af  
4b9e			endm  
# End of macro DMARK
4b9e					CALLMONITOR 
4b9e cd ea 15			call break_point_state  
4ba1				endm  
# End of macro CALLMONITOR
4ba1				endif 
4ba1 cd e5 1b			call forth_push_str 
4ba4			 
4ba4				if DEBUG_STORESE 
4ba4					DMARK "RE4" 
4ba4 f5				push af  
4ba5 3a b9 4b			ld a, (.dmark)  
4ba8 32 bd fb			ld (debug_mark),a  
4bab 3a ba 4b			ld a, (.dmark+1)  
4bae 32 be fb			ld (debug_mark+1),a  
4bb1 3a bb 4b			ld a, (.dmark+2)  
4bb4 32 bf fb			ld (debug_mark+2),a  
4bb7 18 03			jr .pastdmark  
4bb9 ..			.dmark: db "RE4"  
4bbc f1			.pastdmark: pop af  
4bbd			endm  
# End of macro DMARK
4bbd					CALLMONITOR 
4bbd cd ea 15			call break_point_state  
4bc0				endm  
# End of macro CALLMONITOR
4bc0				endif 
4bc0				; get next block  or mark as eof 
4bc0			 
4bc0 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4bc3 4f				ld c, a	 
4bc4 3a df f9			ld a, (store_openext) 
4bc7			 
4bc7				if DEBUG_STORESE 
4bc7					DMARK "RE5" 
4bc7 f5				push af  
4bc8 3a dc 4b			ld a, (.dmark)  
4bcb 32 bd fb			ld (debug_mark),a  
4bce 3a dd 4b			ld a, (.dmark+1)  
4bd1 32 be fb			ld (debug_mark+1),a  
4bd4 3a de 4b			ld a, (.dmark+2)  
4bd7 32 bf fb			ld (debug_mark+2),a  
4bda 18 03			jr .pastdmark  
4bdc ..			.dmark: db "RE5"  
4bdf f1			.pastdmark: pop af  
4be0			endm  
# End of macro DMARK
4be0					CALLMONITOR 
4be0 cd ea 15			call break_point_state  
4be3				endm  
# End of macro CALLMONITOR
4be3				endif 
4be3 b9				cp c 
4be4 28 29			jr z, .readeof     ; at last extent 
4be6			 
4be6 3c					inc a 
4be7 32 df f9				ld (store_openext), a 
4bea			 
4bea				if DEBUG_STORESE 
4bea					DMARK "RE6" 
4bea f5				push af  
4beb 3a ff 4b			ld a, (.dmark)  
4bee 32 bd fb			ld (debug_mark),a  
4bf1 3a 00 4c			ld a, (.dmark+1)  
4bf4 32 be fb			ld (debug_mark+1),a  
4bf7 3a 01 4c			ld a, (.dmark+2)  
4bfa 32 bf fb			ld (debug_mark+2),a  
4bfd 18 03			jr .pastdmark  
4bff ..			.dmark: db "RE6"  
4c02 f1			.pastdmark: pop af  
4c03			endm  
# End of macro DMARK
4c03					CALLMONITOR 
4c03 cd ea 15			call break_point_state  
4c06				endm  
# End of macro CALLMONITOR
4c06				endif 
4c06			 
4c06			 
4c06				       NEXTW 
4c06 c3 e0 1e			jp macro_next 
4c09				endm 
# End of macro NEXTW
4c09			.ateof: 
4c09 21 33 4c				ld hl, .showeof 
4c0c cd e5 1b				call forth_push_str 
4c0f 3e 00		.readeof:	ld a, 0 
4c11 32 df f9				ld (store_openext), a 
4c14			 
4c14					 
4c14				if DEBUG_STORESE 
4c14					DMARK "REF" 
4c14 f5				push af  
4c15 3a 29 4c			ld a, (.dmark)  
4c18 32 bd fb			ld (debug_mark),a  
4c1b 3a 2a 4c			ld a, (.dmark+1)  
4c1e 32 be fb			ld (debug_mark+1),a  
4c21 3a 2b 4c			ld a, (.dmark+2)  
4c24 32 bf fb			ld (debug_mark+2),a  
4c27 18 03			jr .pastdmark  
4c29 ..			.dmark: db "REF"  
4c2c f1			.pastdmark: pop af  
4c2d			endm  
# End of macro DMARK
4c2d					CALLMONITOR 
4c2d cd ea 15			call break_point_state  
4c30				endm  
# End of macro CALLMONITOR
4c30				endif 
4c30				       NEXTW 
4c30 c3 e0 1e			jp macro_next 
4c33				endm 
# End of macro NEXTW
4c33			 
4c33 .. 00		.showeof:   db "eof", 0 
4c37			 
4c37			 
4c37			.EOF: 
4c37				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c37 6d				db WORD_SYS_CORE+89             
4c38 78 4c			dw .FORMAT            
4c3a 04				db 3 + 1 
4c3b .. 00			db "EOF",0              
4c3f				endm 
# End of macro CWHEAD
4c3f			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c3f			; | | e.g. 
4c3f			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c3f					; TODO if current block id for stream is zero then push true else false 
4c3f			 
4c3f					if DEBUG_FORTH_WORDS_KEY 
4c3f						DMARK "EOF" 
4c3f f5				push af  
4c40 3a 54 4c			ld a, (.dmark)  
4c43 32 bd fb			ld (debug_mark),a  
4c46 3a 55 4c			ld a, (.dmark+1)  
4c49 32 be fb			ld (debug_mark+1),a  
4c4c 3a 56 4c			ld a, (.dmark+2)  
4c4f 32 bf fb			ld (debug_mark+2),a  
4c52 18 03			jr .pastdmark  
4c54 ..			.dmark: db "EOF"  
4c57 f1			.pastdmark: pop af  
4c58			endm  
# End of macro DMARK
4c58						CALLMONITOR 
4c58 cd ea 15			call break_point_state  
4c5b				endm  
# End of macro CALLMONITOR
4c5b					endif 
4c5b			 
4c5b					; TODO handlue multiple file streams 
4c5b			 
4c5b					FORTH_DSP_POP     ; for now just get rid of stream id 
4c5b cd 26 1e			call macro_forth_dsp_pop 
4c5e				endm 
# End of macro FORTH_DSP_POP
4c5e			 
4c5e 2e 01				ld l, 1 
4c60 3a de f9				ld a, (store_openmaxext) 
4c63 fe 00				cp 0 
4c65 28 09				jr  z, .eofdone   ; empty file 
4c67 3a df f9				ld a, (store_openext) 
4c6a fe 00				cp 0 
4c6c 28 02				jr  z, .eofdone 
4c6e 2e 00				ld l, 0 
4c70 26 00		.eofdone:	ld h, 0 
4c72 cd 77 1b				call forth_push_numhl 
4c75			 
4c75			 
4c75				       NEXTW 
4c75 c3 e0 1e			jp macro_next 
4c78				endm 
# End of macro NEXTW
4c78			 
4c78			.FORMAT: 
4c78				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4c78 6d				db WORD_SYS_CORE+89             
4c79 c9 4c			dw .LABEL            
4c7b 07				db 6 + 1 
4c7c .. 00			db "FORMAT",0              
4c83				endm 
# End of macro CWHEAD
4c83			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4c83					; TODO if current block id for stream is zero then push true else false 
4c83				 
4c83				if DEBUG_STORESE 
4c83					DMARK "FOR" 
4c83 f5				push af  
4c84 3a 98 4c			ld a, (.dmark)  
4c87 32 bd fb			ld (debug_mark),a  
4c8a 3a 99 4c			ld a, (.dmark+1)  
4c8d 32 be fb			ld (debug_mark+1),a  
4c90 3a 9a 4c			ld a, (.dmark+2)  
4c93 32 bf fb			ld (debug_mark+2),a  
4c96 18 03			jr .pastdmark  
4c98 ..			.dmark: db "FOR"  
4c9b f1			.pastdmark: pop af  
4c9c			endm  
# End of macro DMARK
4c9c					CALLMONITOR 
4c9c cd ea 15			call break_point_state  
4c9f				endm  
# End of macro CALLMONITOR
4c9f				endif 
4c9f					; Wipes the bank check flags to cause a reformat on next block 0 read 
4c9f			 
4c9f 21 01 00				ld hl, 1 
4ca2 3e 00				ld a, 0 
4ca4 cd e7 01				call se_writebyte 
4ca7			 
4ca7				if DEBUG_STORESE 
4ca7					DMARK "FO0" 
4ca7 f5				push af  
4ca8 3a bc 4c			ld a, (.dmark)  
4cab 32 bd fb			ld (debug_mark),a  
4cae 3a bd 4c			ld a, (.dmark+1)  
4cb1 32 be fb			ld (debug_mark+1),a  
4cb4 3a be 4c			ld a, (.dmark+2)  
4cb7 32 bf fb			ld (debug_mark+2),a  
4cba 18 03			jr .pastdmark  
4cbc ..			.dmark: db "FO0"  
4cbf f1			.pastdmark: pop af  
4cc0			endm  
# End of macro DMARK
4cc0					CALLMONITOR 
4cc0 cd ea 15			call break_point_state  
4cc3				endm  
# End of macro CALLMONITOR
4cc3				endif 
4cc3					; force bank init 
4cc3			 
4cc3 cd ba 03				call storage_get_block_0 
4cc6					 
4cc6				       NEXTW 
4cc6 c3 e0 1e			jp macro_next 
4cc9				endm 
# End of macro NEXTW
4cc9			.LABEL: 
4cc9				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4cc9 6d				db WORD_SYS_CORE+89             
4cca 17 4d			dw .STOREPAGE            
4ccc 06				db 5 + 1 
4ccd .. 00			db "LABEL",0              
4cd3				endm 
# End of macro CWHEAD
4cd3			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4cd3					; TODO test to see if bank is selected 
4cd3				 
4cd3					if DEBUG_FORTH_WORDS_KEY 
4cd3						DMARK "LBL" 
4cd3 f5				push af  
4cd4 3a e8 4c			ld a, (.dmark)  
4cd7 32 bd fb			ld (debug_mark),a  
4cda 3a e9 4c			ld a, (.dmark+1)  
4cdd 32 be fb			ld (debug_mark+1),a  
4ce0 3a ea 4c			ld a, (.dmark+2)  
4ce3 32 bf fb			ld (debug_mark+2),a  
4ce6 18 03			jr .pastdmark  
4ce8 ..			.dmark: db "LBL"  
4ceb f1			.pastdmark: pop af  
4cec			endm  
# End of macro DMARK
4cec						CALLMONITOR 
4cec cd ea 15			call break_point_state  
4cef				endm  
# End of macro CALLMONITOR
4cef					endif 
4cef			;	if DEBUG_STORESE 
4cef			;		DMARK "LBL" 
4cef			;		CALLMONITOR 
4cef			;	endif 
4cef					FORTH_DSP_VALUEHL 
4cef cd 6e 1d			call macro_dsp_valuehl 
4cf2				endm 
# End of macro FORTH_DSP_VALUEHL
4cf2					;v5FORTH_DSP_VALUE 
4cf2					 
4cf2			;		push hl 
4cf2					FORTH_DSP_POP 
4cf2 cd 26 1e			call macro_forth_dsp_pop 
4cf5				endm 
# End of macro FORTH_DSP_POP
4cf5			;		pop hl 
4cf5			 
4cf5			;v5		inc hl   ; move past the type marker 
4cf5			 
4cf5				if DEBUG_STORESE 
4cf5					DMARK "LBl" 
4cf5 f5				push af  
4cf6 3a 0a 4d			ld a, (.dmark)  
4cf9 32 bd fb			ld (debug_mark),a  
4cfc 3a 0b 4d			ld a, (.dmark+1)  
4cff 32 be fb			ld (debug_mark+1),a  
4d02 3a 0c 4d			ld a, (.dmark+2)  
4d05 32 bf fb			ld (debug_mark+2),a  
4d08 18 03			jr .pastdmark  
4d0a ..			.dmark: db "LBl"  
4d0d f1			.pastdmark: pop af  
4d0e			endm  
# End of macro DMARK
4d0e					CALLMONITOR 
4d0e cd ea 15			call break_point_state  
4d11				endm  
# End of macro CALLMONITOR
4d11				endif 
4d11 cd db 04				call storage_label 
4d14			 
4d14				       NEXTW 
4d14 c3 e0 1e			jp macro_next 
4d17				endm 
# End of macro NEXTW
4d17			.STOREPAGE: 
4d17				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d17 6d				db WORD_SYS_CORE+89             
4d18 4a 4d			dw .LABELS            
4d1a 0a				db 9 + 1 
4d1b .. 00			db "STOREPAGE",0              
4d25				endm 
# End of macro CWHEAD
4d25			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d25					; TODO test to see if bank is selected 
4d25				 
4d25					if DEBUG_FORTH_WORDS_KEY 
4d25						DMARK "STP" 
4d25 f5				push af  
4d26 3a 3a 4d			ld a, (.dmark)  
4d29 32 bd fb			ld (debug_mark),a  
4d2c 3a 3b 4d			ld a, (.dmark+1)  
4d2f 32 be fb			ld (debug_mark+1),a  
4d32 3a 3c 4d			ld a, (.dmark+2)  
4d35 32 bf fb			ld (debug_mark+2),a  
4d38 18 03			jr .pastdmark  
4d3a ..			.dmark: db "STP"  
4d3d f1			.pastdmark: pop af  
4d3e			endm  
# End of macro DMARK
4d3e						CALLMONITOR 
4d3e cd ea 15			call break_point_state  
4d41				endm  
# End of macro CALLMONITOR
4d41					endif 
4d41			;	if DEBUG_STORESE 
4d41			;		DMARK "STP" 
4d41			;		CALLMONITOR 
4d41			;	endif 
4d41			 
4d41 21 e8 f9			ld hl, store_page 
4d44 cd 77 1b			call forth_push_numhl 
4d47			 
4d47			 
4d47				       NEXTW 
4d47 c3 e0 1e			jp macro_next 
4d4a				endm 
# End of macro NEXTW
4d4a			.LABELS: 
4d4a				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4d4a 6d				db WORD_SYS_CORE+89             
4d4b d4 4d			dw .ENDSTORAGE            
4d4d 07				db 6 + 1 
4d4e .. 00			db "LABELS",0              
4d55				endm 
# End of macro CWHEAD
4d55			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4d55					;  
4d55			 
4d55					; save the current device selected to restore afterwards 
4d55				 
4d55 3a ce f9				ld a, (spi_device) 
4d58 f5					push af 
4d59			 
4d59			 
4d59					; run through each of the banks 
4d59			 
4d59 21 01 00				ld hl, 1 
4d5c cd 77 1b				call forth_push_numhl 
4d5f 3e ff				ld a, SPI_CE_HIGH 
4d61 cb 87				res SPI_CE0, a 
4d63 32 ce f9				ld (spi_device), a 
4d66 cd ba 03				call storage_get_block_0 
4d69 21 eb f9				ld hl, store_page+3 
4d6c cd e5 1b				call forth_push_str 
4d6f			 
4d6f					 
4d6f 21 02 00				ld hl, 2 
4d72 cd 77 1b				call forth_push_numhl 
4d75 3e ff				ld a, SPI_CE_HIGH 
4d77 cb 8f				res SPI_CE1, a 
4d79 32 ce f9				ld (spi_device), a 
4d7c cd ba 03				call storage_get_block_0 
4d7f 21 eb f9				ld hl, store_page+3 
4d82 cd e5 1b				call forth_push_str 
4d85			 
4d85					 
4d85 21 03 00				ld hl, 3 
4d88 cd 77 1b				call forth_push_numhl 
4d8b 3e ff				ld a, SPI_CE_HIGH 
4d8d cb 97				res SPI_CE2, a 
4d8f 32 ce f9				ld (spi_device), a 
4d92 cd ba 03				call storage_get_block_0 
4d95 21 eb f9				ld hl, store_page+3 
4d98 cd e5 1b				call forth_push_str 
4d9b			 
4d9b			 
4d9b 21 04 00				ld hl, 4 
4d9e cd 77 1b				call forth_push_numhl 
4da1 3e ff				ld a, SPI_CE_HIGH 
4da3 cb 9f				res SPI_CE3, a 
4da5 32 ce f9				ld (spi_device), a 
4da8 cd ba 03				call storage_get_block_0 
4dab 21 eb f9				ld hl, store_page+3 
4dae cd e5 1b				call forth_push_str 
4db1			 
4db1					 
4db1			 
4db1 21 05 00				ld hl, 5 
4db4 cd 77 1b				call forth_push_numhl 
4db7 3e ff				ld a, SPI_CE_HIGH 
4db9 cb a7				res SPI_CE4, a 
4dbb 32 ce f9				ld (spi_device), a 
4dbe cd ba 03				call storage_get_block_0 
4dc1 21 eb f9				ld hl, store_page+3 
4dc4 cd e5 1b				call forth_push_str 
4dc7			 
4dc7					 
4dc7					; push fixed count of storage devices (on board) for now 
4dc7			 
4dc7 21 05 00				ld hl, 5 
4dca cd 77 1b				call forth_push_numhl 
4dcd			 
4dcd					; restore selected device  
4dcd				 
4dcd f1					pop af 
4dce 32 ce f9				ld (spi_device), a 
4dd1			 
4dd1				       NEXTW 
4dd1 c3 e0 1e			jp macro_next 
4dd4				endm 
# End of macro NEXTW
4dd4			 
4dd4			.ENDSTORAGE: 
4dd4			; eof 
# End of file forth_words_storage.asm
4dd4			endif 
4dd4				include "forth_words_device.asm" 
4dd4			; Device related words 
4dd4			 
4dd4			; | ## Device Words 
4dd4			 
4dd4			if SOUND_ENABLE 
4dd4			.NOTE: 
4dd4				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4dd4			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4dd4					if DEBUG_FORTH_WORDS_KEY 
4dd4						DMARK "NTE" 
4dd4						CALLMONITOR 
4dd4					endif 
4dd4			 
4dd4				 
4dd4			 
4dd4					NEXTW 
4dd4			.AFTERSOUND: 
4dd4			endif 
4dd4			 
4dd4			 
4dd4			USE_GPIO: equ 0 
4dd4			 
4dd4			if USE_GPIO 
4dd4			.GP1: 
4dd4				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4dd4			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4dd4					NEXTW 
4dd4			.GP2: 
4dd4				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4dd4			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4dd4			 
4dd4					NEXTW 
4dd4			 
4dd4			.GP3: 
4dd4				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4dd4			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4dd4			 
4dd4					NEXTW 
4dd4			 
4dd4			.GP4: 
4dd4				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4dd4			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4dd4			 
4dd4					NEXTW 
4dd4			.SIN: 
4dd4			 
4dd4			 
4dd4			endif 
4dd4			 
4dd4			 
4dd4				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4dd4 33				db WORD_SYS_CORE+31             
4dd5 09 4e			dw .SOUT            
4dd7 03				db 2 + 1 
4dd8 .. 00			db "IN",0              
4ddb				endm 
# End of macro CWHEAD
4ddb			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4ddb					if DEBUG_FORTH_WORDS_KEY 
4ddb						DMARK "IN." 
4ddb f5				push af  
4ddc 3a f0 4d			ld a, (.dmark)  
4ddf 32 bd fb			ld (debug_mark),a  
4de2 3a f1 4d			ld a, (.dmark+1)  
4de5 32 be fb			ld (debug_mark+1),a  
4de8 3a f2 4d			ld a, (.dmark+2)  
4deb 32 bf fb			ld (debug_mark+2),a  
4dee 18 03			jr .pastdmark  
4df0 ..			.dmark: db "IN."  
4df3 f1			.pastdmark: pop af  
4df4			endm  
# End of macro DMARK
4df4						CALLMONITOR 
4df4 cd ea 15			call break_point_state  
4df7				endm  
# End of macro CALLMONITOR
4df7					endif 
4df7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4df7 cd 6e 1d			call macro_dsp_valuehl 
4dfa				endm 
# End of macro FORTH_DSP_VALUEHL
4dfa			 
4dfa e5					push hl 
4dfb			 
4dfb					; destroy value TOS 
4dfb			 
4dfb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dfb cd 26 1e			call macro_forth_dsp_pop 
4dfe				endm 
# End of macro FORTH_DSP_POP
4dfe			 
4dfe					; one value on hl get other one back 
4dfe			 
4dfe c1					pop bc 
4dff			 
4dff					; do the sub 
4dff			;		ex de, hl 
4dff			 
4dff ed 68				in l,(c) 
4e01			 
4e01					; save it 
4e01			 
4e01 26 00				ld h,0 
4e03			 
4e03					; TODO push value back onto stack for another op etc 
4e03			 
4e03 cd 77 1b				call forth_push_numhl 
4e06					NEXTW 
4e06 c3 e0 1e			jp macro_next 
4e09				endm 
# End of macro NEXTW
4e09			.SOUT: 
4e09				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e09 34				db WORD_SYS_CORE+32             
4e0a 5c 4e			dw .SPIO            
4e0c 04				db 3 + 1 
4e0d .. 00			db "OUT",0              
4e11				endm 
# End of macro CWHEAD
4e11			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e11					if DEBUG_FORTH_WORDS_KEY 
4e11						DMARK "OUT" 
4e11 f5				push af  
4e12 3a 26 4e			ld a, (.dmark)  
4e15 32 bd fb			ld (debug_mark),a  
4e18 3a 27 4e			ld a, (.dmark+1)  
4e1b 32 be fb			ld (debug_mark+1),a  
4e1e 3a 28 4e			ld a, (.dmark+2)  
4e21 32 bf fb			ld (debug_mark+2),a  
4e24 18 03			jr .pastdmark  
4e26 ..			.dmark: db "OUT"  
4e29 f1			.pastdmark: pop af  
4e2a			endm  
# End of macro DMARK
4e2a						CALLMONITOR 
4e2a cd ea 15			call break_point_state  
4e2d				endm  
# End of macro CALLMONITOR
4e2d					endif 
4e2d			 
4e2d					; get port 
4e2d			 
4e2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e2d cd 6e 1d			call macro_dsp_valuehl 
4e30				endm 
# End of macro FORTH_DSP_VALUEHL
4e30			 
4e30 e5					push hl 
4e31			 
4e31					; destroy value TOS 
4e31			 
4e31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e31 cd 26 1e			call macro_forth_dsp_pop 
4e34				endm 
# End of macro FORTH_DSP_POP
4e34			 
4e34					; get byte to send 
4e34			 
4e34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e34 cd 6e 1d			call macro_dsp_valuehl 
4e37				endm 
# End of macro FORTH_DSP_VALUEHL
4e37			 
4e37			;		push hl 
4e37			 
4e37					; destroy value TOS 
4e37			 
4e37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e37 cd 26 1e			call macro_forth_dsp_pop 
4e3a				endm 
# End of macro FORTH_DSP_POP
4e3a			 
4e3a					; one value on hl get other one back 
4e3a			 
4e3a			;		pop hl 
4e3a			 
4e3a c1					pop bc 
4e3b			 
4e3b					if DEBUG_FORTH_WORDS 
4e3b						DMARK "OUT" 
4e3b f5				push af  
4e3c 3a 50 4e			ld a, (.dmark)  
4e3f 32 bd fb			ld (debug_mark),a  
4e42 3a 51 4e			ld a, (.dmark+1)  
4e45 32 be fb			ld (debug_mark+1),a  
4e48 3a 52 4e			ld a, (.dmark+2)  
4e4b 32 bf fb			ld (debug_mark+2),a  
4e4e 18 03			jr .pastdmark  
4e50 ..			.dmark: db "OUT"  
4e53 f1			.pastdmark: pop af  
4e54			endm  
# End of macro DMARK
4e54						CALLMONITOR 
4e54 cd ea 15			call break_point_state  
4e57				endm  
# End of macro CALLMONITOR
4e57					endif 
4e57			 
4e57 ed 69				out (c), l 
4e59			 
4e59					NEXTW 
4e59 c3 e0 1e			jp macro_next 
4e5c				endm 
# End of macro NEXTW
4e5c			 
4e5c			 
4e5c			.SPIO: 
4e5c			 
4e5c			if STORAGE_SE 
4e5c				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4e5c 51				db WORD_SYS_CORE+61             
4e5d 6d 4e			dw .SPICEH            
4e5f 07				db 6 + 1 
4e60 .. 00			db "SPICEL",0              
4e67				endm 
# End of macro CWHEAD
4e67			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4e67			 
4e67 cd 95 01				call spi_ce_low 
4e6a			    NEXTW 
4e6a c3 e0 1e			jp macro_next 
4e6d				endm 
# End of macro NEXTW
4e6d			 
4e6d			.SPICEH: 
4e6d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4e6d 51				db WORD_SYS_CORE+61             
4e6e 7e 4e			dw .SPIOb            
4e70 07				db 6 + 1 
4e71 .. 00			db "SPICEH",0              
4e78				endm 
# End of macro CWHEAD
4e78			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4e78			 
4e78 cd 84 01				call spi_ce_high 
4e7b			    NEXTW 
4e7b c3 e0 1e			jp macro_next 
4e7e				endm 
# End of macro NEXTW
4e7e			 
4e7e			 
4e7e			.SPIOb: 
4e7e			 
4e7e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4e7e 51				db WORD_SYS_CORE+61             
4e7f 94 4e			dw .SPII            
4e81 05				db 4 + 1 
4e82 .. 00			db "SPIO",0              
4e87				endm 
# End of macro CWHEAD
4e87			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4e87			 
4e87					; get port 
4e87			 
4e87			 
4e87					; get byte to send 
4e87			 
4e87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e87 cd 6e 1d			call macro_dsp_valuehl 
4e8a				endm 
# End of macro FORTH_DSP_VALUEHL
4e8a			 
4e8a			;		push hl    ; u1  
4e8a			 
4e8a					; destroy value TOS 
4e8a			 
4e8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e8a cd 26 1e			call macro_forth_dsp_pop 
4e8d				endm 
# End of macro FORTH_DSP_POP
4e8d			 
4e8d					; one value on hl get other one back 
4e8d			 
4e8d			;		pop hl   ; u2 - addr 
4e8d			 
4e8d					; TODO Send SPI byte 
4e8d			 
4e8d 7d					ld a, l 
4e8e cd b9 00				call spi_send_byte 
4e91			 
4e91					NEXTW 
4e91 c3 e0 1e			jp macro_next 
4e94				endm 
# End of macro NEXTW
4e94			 
4e94			.SPII: 
4e94				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4e94 52				db WORD_SYS_CORE+62             
4e95 a9 4e			dw .SESEL            
4e97 06				db 5 + 1 
4e98 .. 00			db "SPII",0              
4e9d				endm 
# End of macro CWHEAD
4e9d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4e9d			 
4e9d					; TODO Get SPI byte 
4e9d			 
4e9d cd da 00				call spi_read_byte 
4ea0			 
4ea0 26 00				ld h, 0 
4ea2 6f					ld l, a 
4ea3 cd 77 1b				call forth_push_numhl 
4ea6			 
4ea6					NEXTW 
4ea6 c3 e0 1e			jp macro_next 
4ea9				endm 
# End of macro NEXTW
4ea9			 
4ea9			 
4ea9			 
4ea9			.SESEL: 
4ea9				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ea9 66				db WORD_SYS_CORE+82             
4eaa 4d 4f			dw .CARTDEV            
4eac 05				db 4 + 1 
4ead .. 00			db "BANK",0              
4eb2				endm 
# End of macro CWHEAD
4eb2			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4eb2					if DEBUG_FORTH_WORDS_KEY 
4eb2						DMARK "BNK" 
4eb2 f5				push af  
4eb3 3a c7 4e			ld a, (.dmark)  
4eb6 32 bd fb			ld (debug_mark),a  
4eb9 3a c8 4e			ld a, (.dmark+1)  
4ebc 32 be fb			ld (debug_mark+1),a  
4ebf 3a c9 4e			ld a, (.dmark+2)  
4ec2 32 bf fb			ld (debug_mark+2),a  
4ec5 18 03			jr .pastdmark  
4ec7 ..			.dmark: db "BNK"  
4eca f1			.pastdmark: pop af  
4ecb			endm  
# End of macro DMARK
4ecb						CALLMONITOR 
4ecb cd ea 15			call break_point_state  
4ece				endm  
# End of macro CALLMONITOR
4ece					endif 
4ece			 
4ece 3e ff				ld a, 255 
4ed0 32 d1 f9				ld (spi_cartdev), a 
4ed3			 
4ed3					; get bank 
4ed3			 
4ed3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ed3 cd 6e 1d			call macro_dsp_valuehl 
4ed6				endm 
# End of macro FORTH_DSP_VALUEHL
4ed6			 
4ed6			;		push hl 
4ed6			 
4ed6					; destroy value TOS 
4ed6			 
4ed6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ed6 cd 26 1e			call macro_forth_dsp_pop 
4ed9				endm 
# End of macro FORTH_DSP_POP
4ed9			 
4ed9					; one value on hl get other one back 
4ed9			 
4ed9			;		pop hl 
4ed9			 
4ed9			 
4ed9 0e ff				ld c, SPI_CE_HIGH 
4edb 06 30				ld b, '0'    ; human readable bank number 
4edd			 
4edd 7d					ld a, l 
4ede			 
4ede					if DEBUG_FORTH_WORDS 
4ede						DMARK "BNK" 
4ede f5				push af  
4edf 3a f3 4e			ld a, (.dmark)  
4ee2 32 bd fb			ld (debug_mark),a  
4ee5 3a f4 4e			ld a, (.dmark+1)  
4ee8 32 be fb			ld (debug_mark+1),a  
4eeb 3a f5 4e			ld a, (.dmark+2)  
4eee 32 bf fb			ld (debug_mark+2),a  
4ef1 18 03			jr .pastdmark  
4ef3 ..			.dmark: db "BNK"  
4ef6 f1			.pastdmark: pop af  
4ef7			endm  
# End of macro DMARK
4ef7						CALLMONITOR 
4ef7 cd ea 15			call break_point_state  
4efa				endm  
# End of macro CALLMONITOR
4efa					endif 
4efa			 
4efa					; active low 
4efa			 
4efa fe 00				cp 0 
4efc 28 28				jr z, .bset 
4efe fe 01				cp 1 
4f00 20 04				jr nz, .b2 
4f02 cb 81				res 0, c 
4f04 06 31				ld b, '1'    ; human readable bank number 
4f06 fe 02		.b2:		cp 2 
4f08 20 04				jr nz, .b3 
4f0a cb 89				res 1, c 
4f0c 06 32				ld b, '2'    ; human readable bank number 
4f0e fe 03		.b3:		cp 3 
4f10 20 04				jr nz, .b4 
4f12 cb 91				res 2, c 
4f14 06 33				ld b, '3'    ; human readable bank number 
4f16 fe 04		.b4:		cp 4 
4f18 20 04				jr nz, .b5 
4f1a cb 99				res 3, c 
4f1c 06 34				ld b, '4'    ; human readable bank number 
4f1e fe 05		.b5:		cp 5 
4f20 20 04				jr nz, .bset 
4f22 cb a1				res 4, c 
4f24 06 35				ld b, '5'    ; human readable bank number 
4f26			 
4f26			.bset: 
4f26 79					ld a, c 
4f27 32 ce f9				ld (spi_device),a 
4f2a 78					ld a, b 
4f2b 32 cd f9				ld (spi_device_id),a 
4f2e					if DEBUG_FORTH_WORDS 
4f2e						DMARK "BN2" 
4f2e f5				push af  
4f2f 3a 43 4f			ld a, (.dmark)  
4f32 32 bd fb			ld (debug_mark),a  
4f35 3a 44 4f			ld a, (.dmark+1)  
4f38 32 be fb			ld (debug_mark+1),a  
4f3b 3a 45 4f			ld a, (.dmark+2)  
4f3e 32 bf fb			ld (debug_mark+2),a  
4f41 18 03			jr .pastdmark  
4f43 ..			.dmark: db "BN2"  
4f46 f1			.pastdmark: pop af  
4f47			endm  
# End of macro DMARK
4f47						CALLMONITOR 
4f47 cd ea 15			call break_point_state  
4f4a				endm  
# End of macro CALLMONITOR
4f4a					endif 
4f4a			 
4f4a					NEXTW 
4f4a c3 e0 1e			jp macro_next 
4f4d				endm 
# End of macro NEXTW
4f4d			 
4f4d			.CARTDEV: 
4f4d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4f4d 66				db WORD_SYS_CORE+82             
4f4e f6 4f			dw .ENDDEVICE            
4f50 08				db 7 + 1 
4f51 .. 00			db "CARTDEV",0              
4f59				endm 
# End of macro CWHEAD
4f59			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4f59					if DEBUG_FORTH_WORDS_KEY 
4f59						DMARK "CDV" 
4f59 f5				push af  
4f5a 3a 6e 4f			ld a, (.dmark)  
4f5d 32 bd fb			ld (debug_mark),a  
4f60 3a 6f 4f			ld a, (.dmark+1)  
4f63 32 be fb			ld (debug_mark+1),a  
4f66 3a 70 4f			ld a, (.dmark+2)  
4f69 32 bf fb			ld (debug_mark+2),a  
4f6c 18 03			jr .pastdmark  
4f6e ..			.dmark: db "CDV"  
4f71 f1			.pastdmark: pop af  
4f72			endm  
# End of macro DMARK
4f72						CALLMONITOR 
4f72 cd ea 15			call break_point_state  
4f75				endm  
# End of macro CALLMONITOR
4f75					endif 
4f75			 
4f75					; disable se storage bank selection 
4f75			 
4f75 3e ff				ld a, SPI_CE_HIGH		; ce high 
4f77 32 ce f9				ld (spi_device), a 
4f7a			 
4f7a					; get bank 
4f7a			 
4f7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f7a cd 6e 1d			call macro_dsp_valuehl 
4f7d				endm 
# End of macro FORTH_DSP_VALUEHL
4f7d			 
4f7d			;		push hl 
4f7d			 
4f7d					; destroy value TOS 
4f7d			 
4f7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f7d cd 26 1e			call macro_forth_dsp_pop 
4f80				endm 
# End of macro FORTH_DSP_POP
4f80			 
4f80					; one value on hl get other one back 
4f80			 
4f80			;		pop hl 
4f80			 
4f80					; active low 
4f80			 
4f80 0e ff				ld c, 255 
4f82			 
4f82 7d					ld a, l 
4f83					if DEBUG_FORTH_WORDS 
4f83						DMARK "CDV" 
4f83 f5				push af  
4f84 3a 98 4f			ld a, (.dmark)  
4f87 32 bd fb			ld (debug_mark),a  
4f8a 3a 99 4f			ld a, (.dmark+1)  
4f8d 32 be fb			ld (debug_mark+1),a  
4f90 3a 9a 4f			ld a, (.dmark+2)  
4f93 32 bf fb			ld (debug_mark+2),a  
4f96 18 03			jr .pastdmark  
4f98 ..			.dmark: db "CDV"  
4f9b f1			.pastdmark: pop af  
4f9c			endm  
# End of macro DMARK
4f9c						CALLMONITOR 
4f9c cd ea 15			call break_point_state  
4f9f				endm  
# End of macro CALLMONITOR
4f9f					endif 
4f9f fe 00				cp 0 
4fa1 28 30				jr z, .cset 
4fa3 fe 01				cp 1 
4fa5 20 02				jr nz, .c2 
4fa7 cb 81				res 0, c 
4fa9 fe 02		.c2:		cp 2 
4fab 20 02				jr nz, .c3 
4fad cb 89				res 1, c 
4faf fe 03		.c3:		cp 3 
4fb1 20 02				jr nz, .c4 
4fb3 cb 91				res 2, c 
4fb5 fe 04		.c4:		cp 4 
4fb7 20 02				jr nz, .c5 
4fb9 cb 99				res 3, c 
4fbb fe 05		.c5:		cp 5 
4fbd 20 02				jr nz, .c6 
4fbf cb a1				res 4, c 
4fc1 fe 06		.c6:		cp 6 
4fc3 20 02				jr nz, .c7 
4fc5 cb a9				res 5, c 
4fc7 fe 07		.c7:		cp 7 
4fc9 20 02				jr nz, .c8 
4fcb cb b1				res 6, c 
4fcd fe 08		.c8:		cp 8 
4fcf 20 02				jr nz, .cset 
4fd1 cb b9				res 7, c 
4fd3 79			.cset:		ld a, c 
4fd4 32 d1 f9				ld (spi_cartdev),a 
4fd7			 
4fd7					if DEBUG_FORTH_WORDS 
4fd7						DMARK "CD2" 
4fd7 f5				push af  
4fd8 3a ec 4f			ld a, (.dmark)  
4fdb 32 bd fb			ld (debug_mark),a  
4fde 3a ed 4f			ld a, (.dmark+1)  
4fe1 32 be fb			ld (debug_mark+1),a  
4fe4 3a ee 4f			ld a, (.dmark+2)  
4fe7 32 bf fb			ld (debug_mark+2),a  
4fea 18 03			jr .pastdmark  
4fec ..			.dmark: db "CD2"  
4fef f1			.pastdmark: pop af  
4ff0			endm  
# End of macro DMARK
4ff0						CALLMONITOR 
4ff0 cd ea 15			call break_point_state  
4ff3				endm  
# End of macro CALLMONITOR
4ff3					endif 
4ff3					NEXTW 
4ff3 c3 e0 1e			jp macro_next 
4ff6				endm 
# End of macro NEXTW
4ff6			endif 
4ff6			 
4ff6			.ENDDEVICE: 
4ff6			; eof 
4ff6			 
# End of file forth_words_device.asm
4ff6			 
4ff6			; var handler 
4ff6			 
4ff6			 
4ff6			.VARS: 
4ff6				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4ff6 78				db WORD_SYS_CORE+100             
4ff7 0e 50			dw .V0Q            
4ff9 04				db 3 + 1 
4ffa .. 00			db "V0!",0              
4ffe				endm 
# End of macro CWHEAD
4ffe			;| V0! ( u1 -- )  Store value to v0  | DONE 
4ffe			 
4ffe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ffe cd 6e 1d			call macro_dsp_valuehl 
5001				endm 
# End of macro FORTH_DSP_VALUEHL
5001			 
5001 11 96 f9				ld de, cli_var_array 
5004			 
5004 eb					ex de, hl 
5005 73					ld (hl), e 
5006 23					inc hl 
5007 72					ld (hl), d 
5008			 
5008					; destroy value TOS 
5008			 
5008					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5008 cd 26 1e			call macro_forth_dsp_pop 
500b				endm 
# End of macro FORTH_DSP_POP
500b			 
500b				       NEXTW 
500b c3 e0 1e			jp macro_next 
500e				endm 
# End of macro NEXTW
500e			.V0Q: 
500e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
500e 79				db WORD_SYS_CORE+101             
500f 1f 50			dw .V1S            
5011 04				db 3 + 1 
5012 .. 00			db "V0@",0              
5016				endm 
# End of macro CWHEAD
5016			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5016 2a 96 f9				ld hl, (cli_var_array) 
5019 cd 77 1b				call forth_push_numhl 
501c			 
501c				       NEXTW 
501c c3 e0 1e			jp macro_next 
501f				endm 
# End of macro NEXTW
501f			.V1S: 
501f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
501f 7a				db WORD_SYS_CORE+102             
5020 37 50			dw .V1Q            
5022 04				db 3 + 1 
5023 .. 00			db "V1!",0              
5027				endm 
# End of macro CWHEAD
5027			;| V1! ( u1 -- )  Store value to v1 | DONE 
5027					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5027 cd 6e 1d			call macro_dsp_valuehl 
502a				endm 
# End of macro FORTH_DSP_VALUEHL
502a			 
502a 11 98 f9				ld de, cli_var_array+2 
502d				 
502d eb					ex de, hl 
502e 73					ld (hl), e 
502f 23					inc hl 
5030 72					ld (hl), d 
5031			 
5031					; destroy value TOS 
5031			 
5031					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5031 cd 26 1e			call macro_forth_dsp_pop 
5034				endm 
# End of macro FORTH_DSP_POP
5034				       NEXTW 
5034 c3 e0 1e			jp macro_next 
5037				endm 
# End of macro NEXTW
5037			.V1Q: 
5037				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5037 7b				db WORD_SYS_CORE+103             
5038 48 50			dw .V2S            
503a 04				db 3 + 1 
503b .. 00			db "V1@",0              
503f				endm 
# End of macro CWHEAD
503f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
503f 2a 98 f9				ld hl, (cli_var_array+2) 
5042 cd 77 1b				call forth_push_numhl 
5045				       NEXTW 
5045 c3 e0 1e			jp macro_next 
5048				endm 
# End of macro NEXTW
5048			.V2S: 
5048				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5048 7c				db WORD_SYS_CORE+104             
5049 60 50			dw .V2Q            
504b 04				db 3 + 1 
504c .. 00			db "V2!",0              
5050				endm 
# End of macro CWHEAD
5050			;| V2! ( u1 -- )  Store value to v2 | DONE 
5050					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5050 cd 6e 1d			call macro_dsp_valuehl 
5053				endm 
# End of macro FORTH_DSP_VALUEHL
5053			 
5053 11 9a f9				ld de, cli_var_array+4 
5056				 
5056 eb					ex de, hl 
5057 73					ld (hl), e 
5058 23					inc hl 
5059 72					ld (hl), d 
505a			 
505a					; destroy value TOS 
505a			 
505a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
505a cd 26 1e			call macro_forth_dsp_pop 
505d				endm 
# End of macro FORTH_DSP_POP
505d				       NEXTW 
505d c3 e0 1e			jp macro_next 
5060				endm 
# End of macro NEXTW
5060			.V2Q: 
5060				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5060 7d				db WORD_SYS_CORE+105             
5061 71 50			dw .V3S            
5063 04				db 3 + 1 
5064 .. 00			db "V2@",0              
5068				endm 
# End of macro CWHEAD
5068			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5068 2a 9a f9				ld hl, (cli_var_array+4) 
506b cd 77 1b				call forth_push_numhl 
506e				       NEXTW 
506e c3 e0 1e			jp macro_next 
5071				endm 
# End of macro NEXTW
5071			.V3S: 
5071				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5071 7c				db WORD_SYS_CORE+104             
5072 89 50			dw .V3Q            
5074 04				db 3 + 1 
5075 .. 00			db "V3!",0              
5079				endm 
# End of macro CWHEAD
5079			;| V3! ( u1 -- )  Store value to v3 | DONE 
5079					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5079 cd 6e 1d			call macro_dsp_valuehl 
507c				endm 
# End of macro FORTH_DSP_VALUEHL
507c			 
507c 11 9c f9				ld de, cli_var_array+6 
507f				 
507f eb					ex de, hl 
5080 73					ld (hl), e 
5081 23					inc hl 
5082 72					ld (hl), d 
5083			 
5083					; destroy value TOS 
5083			 
5083					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5083 cd 26 1e			call macro_forth_dsp_pop 
5086				endm 
# End of macro FORTH_DSP_POP
5086				       NEXTW 
5086 c3 e0 1e			jp macro_next 
5089				endm 
# End of macro NEXTW
5089			.V3Q: 
5089				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5089 7d				db WORD_SYS_CORE+105             
508a 9a 50			dw .END            
508c 04				db 3 + 1 
508d .. 00			db "V3@",0              
5091				endm 
# End of macro CWHEAD
5091			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5091 2a 9c f9				ld hl, (cli_var_array+6) 
5094 cd 77 1b				call forth_push_numhl 
5097				       NEXTW 
5097 c3 e0 1e			jp macro_next 
509a				endm 
# End of macro NEXTW
509a			 
509a			 
509a			 
509a			 
509a			 
509a			; end of dict marker 
509a			 
509a 00			.END:    db WORD_SYS_END 
509b 00 00			dw 0 
509d 00				db 0 
509e			 
509e			; use to jp here for user dict words to save on macro expansion  
509e			 
509e			user_dict_next: 
509e				NEXTW 
509e c3 e0 1e			jp macro_next 
50a1				endm 
# End of macro NEXTW
50a1			 
50a1			 
50a1			user_exec: 
50a1				;    ld hl, <word code> 
50a1				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
50a1				;    call forthexec 
50a1				;    jp user_dict_next   (NEXT) 
50a1			        ;    <word code bytes> 
50a1 eb				ex de, hl 
50a2 2a a4 f2			ld hl,(os_tok_ptr) 
50a5				 
50a5				FORTH_RSP_NEXT 
50a5 cd 1e 1b			call macro_forth_rsp_next 
50a8				endm 
# End of macro FORTH_RSP_NEXT
50a8			 
50a8			if DEBUG_FORTH_UWORD 
50a8						DMARK "UEX" 
50a8 f5				push af  
50a9 3a bd 50			ld a, (.dmark)  
50ac 32 bd fb			ld (debug_mark),a  
50af 3a be 50			ld a, (.dmark+1)  
50b2 32 be fb			ld (debug_mark+1),a  
50b5 3a bf 50			ld a, (.dmark+2)  
50b8 32 bf fb			ld (debug_mark+2),a  
50bb 18 03			jr .pastdmark  
50bd ..			.dmark: db "UEX"  
50c0 f1			.pastdmark: pop af  
50c1			endm  
# End of macro DMARK
50c1				CALLMONITOR 
50c1 cd ea 15			call break_point_state  
50c4				endm  
# End of macro CALLMONITOR
50c4			endif 
50c4			 
50c4			 
50c4			 
50c4 eb				ex de, hl 
50c5 22 a4 f2			ld (os_tok_ptr), hl 
50c8				 
50c8				; Don't use next - Skips the first word in uword. 
50c8			 
50c8 c3 71 1f			jp exec1 
50cb			;	NEXT 
50cb			 
50cb			 
50cb			; eof 
# End of file forth_wordsv4.asm
50cb			endif 
50cb			;;;;;;;;;;;;;; Debug code 
50cb			 
50cb			 
50cb			;if DEBUG_FORTH_PARSE 
50cb .. 00		.nowordfound: db "No match",0 
50d4 .. 00		.compword:	db "Comparing word ",0 
50e4 .. 00		.nextwordat:	db "Next word at",0 
50f1 .. 00		.charmatch:	db "Char match",0 
50fc			;endif 
50fc			if DEBUG_FORTH_JP 
50fc			.foundword:	db "Word match. Exec..",0 
50fc			endif 
50fc			;if DEBUG_FORTH_PUSH 
50fc .. 00		.enddict:	db "Dict end. Push.",0 
510c .. 00		.push_str:	db "Pushing string",0 
511b .. 00		.push_num:	db "Pushing number",0 
512a .. 00		.data_sp:	db "SP:",0 
512e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5140 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5152 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5164			;endif 
5164			;if DEBUG_FORTH_MALLOC 
5164 .. 00		.push_malloc:	db "Malloc address",0 
5173			;endif 
5173			 
5173			 
5173			 
5173			; display malloc address and current data stack pointer  
5173			 
5173			malloc_error: 
5173 d5				push de 
5174 f5				push af 
5175 e5				push hl 
5176 cd 94 0a			call clear_display 
5179 11 9b 51			ld de, .mallocerr 
517c 3e 00			ld a,0 
517e			;	ld de,os_word_scratch 
517e cd a7 0a			call str_at_display 
5181 3e 11			ld a, display_row_1+17 
5183 11 bd fb			ld de, debug_mark 
5186 cd a7 0a			call str_at_display 
5189 cd b7 0a			call update_display 
518c				;call break_point_state 
518c cd c9 65			call cin_wait 
518f			 
518f 3e 20			ld a, ' ' 
5191 32 94 ef			ld (os_view_disable), a 
5194 e1				pop hl 
5195 f1				pop af 
5196 d1				pop de	 
5197				CALLMONITOR 
5197 cd ea 15			call break_point_state  
519a				endm  
# End of macro CALLMONITOR
519a c9				ret 
519b			 
519b .. 00		.mallocerr: 	db "Malloc Error",0 
51a8			;if DEBUG_FORTH_PUSH 
51a8			display_data_sp: 
51a8 f5				push af 
51a9			 
51a9				; see if disabled 
51a9			 
51a9 3a 94 ef			ld a, (os_view_disable) 
51ac fe 2a			cp '*' 
51ae 28 67			jr z, .skipdsp 
51b0			 
51b0 e5				push hl 
51b1 e5				push hl 
51b2 e5			push hl 
51b3 cd 94 0a			call clear_display 
51b6 e1			pop hl 
51b7 7c				ld a,h 
51b8 21 a8 f2			ld hl, os_word_scratch 
51bb cd c9 0f			call hexout 
51be e1				pop hl 
51bf 7d				ld a,l 
51c0 21 aa f2			ld hl, os_word_scratch+2 
51c3 cd c9 0f			call hexout 
51c6 21 ac f2			ld hl, os_word_scratch+4 
51c9 3e 00			ld a,0 
51cb 77				ld (hl),a 
51cc 11 a8 f2			ld de,os_word_scratch 
51cf 3e 14				ld a, display_row_2 
51d1 cd a7 0a				call str_at_display 
51d4 11 2e 51			ld de, .wordinhl 
51d7 3e 00			ld a, display_row_1 
51d9			 
51d9 cd a7 0a				call str_at_display 
51dc 11 bd fb			ld de, debug_mark 
51df 3e 11			ld a, display_row_1+17 
51e1			 
51e1 cd a7 0a				call str_at_display 
51e4			 
51e4				; display current data stack pointer 
51e4 11 2a 51			ld de,.data_sp 
51e7 3e 1c				ld a, display_row_2 + 8 
51e9 cd a7 0a				call str_at_display 
51ec			 
51ec 2a 90 f9			ld hl,(cli_data_sp) 
51ef e5				push hl 
51f0 7c				ld a,h 
51f1 21 a8 f2			ld hl, os_word_scratch 
51f4 cd c9 0f			call hexout 
51f7 e1				pop hl 
51f8 7d				ld a,l 
51f9 21 aa f2			ld hl, os_word_scratch+2 
51fc cd c9 0f			call hexout 
51ff 21 ac f2			ld hl, os_word_scratch+4 
5202 3e 00			ld a,0 
5204 77				ld (hl),a 
5205 11 a8 f2			ld de,os_word_scratch 
5208 3e 1f				ld a, display_row_2 + 11 
520a cd a7 0a				call str_at_display 
520d			 
520d			 
520d cd b7 0a			call update_display 
5210 cd 42 0a			call delay1s 
5213 cd 42 0a			call delay1s 
5216 e1				pop hl 
5217			.skipdsp: 
5217 f1				pop af 
5218 c9				ret 
5219			 
5219			display_data_malloc: 
5219			 
5219 f5				push af 
521a e5				push hl 
521b e5				push hl 
521c e5			push hl 
521d cd 94 0a			call clear_display 
5220 e1			pop hl 
5221 7c				ld a,h 
5222 21 a8 f2			ld hl, os_word_scratch 
5225 cd c9 0f			call hexout 
5228 e1				pop hl 
5229 7d				ld a,l 
522a 21 aa f2			ld hl, os_word_scratch+2 
522d cd c9 0f			call hexout 
5230 21 ac f2			ld hl, os_word_scratch+4 
5233 3e 00			ld a,0 
5235 77				ld (hl),a 
5236 11 a8 f2			ld de,os_word_scratch 
5239 3e 14				ld a, display_row_2 
523b cd a7 0a				call str_at_display 
523e 11 64 51			ld de, .push_malloc 
5241 3e 00			ld a, display_row_1 
5243			 
5243 cd a7 0a				call str_at_display 
5246			 
5246				; display current data stack pointer 
5246 11 2a 51			ld de,.data_sp 
5249 3e 1c				ld a, display_row_2 + 8 
524b cd a7 0a				call str_at_display 
524e			 
524e 2a 90 f9			ld hl,(cli_data_sp) 
5251 e5				push hl 
5252 7c				ld a,h 
5253 21 a8 f2			ld hl, os_word_scratch 
5256 cd c9 0f			call hexout 
5259 e1				pop hl 
525a 7d				ld a,l 
525b 21 aa f2			ld hl, os_word_scratch+2 
525e cd c9 0f			call hexout 
5261 21 ac f2			ld hl, os_word_scratch+4 
5264 3e 00			ld a,0 
5266 77				ld (hl),a 
5267 11 a8 f2			ld de,os_word_scratch 
526a 3e 1f				ld a, display_row_2 + 11 
526c cd a7 0a				call str_at_display 
526f			 
526f cd b7 0a			call update_display 
5272 cd 42 0a			call delay1s 
5275 cd 42 0a			call delay1s 
5278 e1				pop hl 
5279 f1				pop af 
527a c9				ret 
527b			;endif 
527b			 
527b			include "forth_autostart.asm" 
527b			; list of commands to perform at system start up 
527b			 
527b			startcmds: 
527b			;	dw test11 
527b			;	dw test12 
527b			;	dw test13 
527b			;	dw test14 
527b			;	dw test15 
527b			;	dw test16 
527b			;	dw test17 
527b			;	dw ifthtest1 
527b			;	dw ifthtest2 
527b			;	dw ifthtest3 
527b			;	dw mmtest1 
527b			;	dw mmtest2 
527b			;	dw mmtest3 
527b			;	dw mmtest4 
527b			;	dw mmtest5 
527b			;	dw mmtest6 
527b			;	dw iftest1 
527b			;	dw iftest2 
527b			;	dw iftest3 
527b			;	dw looptest1 
527b			;	dw looptest2 
527b			;	dw test1 
527b			;	dw test2 
527b			;	dw test3 
527b			;	dw test4 
527b			;	dw game2r 
527b			;	dw game2b1 
527b			;	dw game2b2 
527b			 
527b				; start up words that are actually useful 
527b			 
527b d9 52			dw clrstack 
527d 0c 53			dw type 
527f cd 54			dw stest 
5281 30 53			dw strncpy 
5283 6e 54			dw list 
5285 91 53			dw start1 
5287 a3 53			dw start2 
5289			;	dw start3 
5289 b6 53			dw start3b 
528b 0e 54			dw start3c 
528d			 
528d				; (unit) testing words 
528d			 
528d 44 55			dw mtesta 
528f f9 55			dw mtestb 
5291 9c 56			dw mtestc 
5293 51 57			dw mtestd 
5295 f5 57			dw mteste 
5297			 
5297				; demo/game words 
5297			 
5297 01 5f		        dw game3w 
5299 2f 5f		        dw game3p 
529b 4d 5f		        dw game3sc 
529d 7e 5f		        dw game3vsi 
529f aa 5f		        dw game3vs 
52a1				 
52a1 f4 5c			dw game2b 
52a3 62 5d			dw game2bf 
52a5 ac 5d			dw game2mba 
52a7 42 5e			dw game2mbas 
52a9 84 5e			dw game2mb 
52ab			 
52ab b5 59			dw game1 
52ad c6 59			dw game1a 
52af 28 5a			dw game1b 
52b1 5d 5a			dw game1c 
52b3 93 5a			dw game1d 
52b5 c4 5a			dw game1s 
52b7 d8 5a			dw game1t 
52b9 ed 5a			dw game1f 
52bb 21 5b			dw game1z 
52bd 65 5b			dw game1zz 
52bf			 
52bf ab 58			dw test5 
52c1 e3 58			dw test6 
52c3 1b 59			dw test7 
52c5 2f 59			dw test8 
52c7 5b 59			dw test9 
52c9 71 59			dw test10 
52cb				 
52cb 3c 5c		        dw ssv5 
52cd 20 5c		        dw ssv4 
52cf 04 5c		        dw ssv3 
52d1 ce 5b		        dw ssv2 
52d3 55 5c		        dw ssv1 
52d5 9d 5c		        dw ssv1cpm 
52d7			;	dw keyup 
52d7			;	dw keydown 
52d7			;	dw keyleft 
52d7			;	dw keyright 
52d7			;	dw 	keyf1 
52d7			;	dw keyf2 
52d7			;	dw keyf3 
52d7			;	dw keyf4 
52d7			;	dw keyf5 
52d7			;	dw keyf6 
52d7			;	dw keyf7 
52d7			;	dw keyf8 
52d7			;	dw keyf9 
52d7			;	dw keyf10 
52d7			;	dw keyf11 
52d7			;	dw keyf12 
52d7			;	dw keytab 
52d7			;	dw keycr 
52d7			;	dw keyhome 
52d7			;	dw keyend 
52d7			;	dw keybs 
52d7 00 00			db 0, 0	 
52d9			 
52d9			 
52d9			; clear stack  
52d9			 
52d9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
530c			 
530c			; type ( addr count - ) 
530c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5330			 
5330			; some direct memory words 
5330			; strncpy ( len t f -- t ) 
5330			 
5330 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5391			 
5391 .. 00		start1:     	db ": bpon $0000 bp ;",0 
53a3 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
53b6			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
53b6 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
540e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
546e			 
546e			 
546e			; a handy word to list items on the stack 
546e			 
546e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
54cd			 
54cd			 
54cd			; test stack  
54cd			; rnd8 stest 
54cd			 
54cd .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5544			 
5544			; random malloc and free cycles 
5544			 
5544 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55f9			 
55f9			; fixed malloc and free cycles 
55f9			 
55f9 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
569c			 
569c			; fixed double string push and drop cycle  
569c			 
569c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5751			 
5751			; consistent fixed string push and drop cycle  
5751			 
5751 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
57f5			 
57f5 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58ab			 
58ab			;test1:		db ": aa 1 2 3 ;", 0 
58ab			;test2:     	db "111 aa 888 999",0 
58ab			;test3:     	db ": bb 77 ;",0 
58ab			;test4:     	db "$02 $01 do i . loop bb",0 
58ab			 
58ab .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
58e3 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
591b .. 00		test7:     	db ": box hline vline ;",0 
592f .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
595b .. 00		test9:     	db ": sw $01 adsp world ;",0 
5971 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5996 .. 00		test11:     	db "hello create .",0 
59a5 .. 00		test12:     	db "hello2 create .",0 
59b5			 
59b5			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
59b5			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
59b5			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
59b5			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
59b5			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
59b5			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
59b5			 
59b5			;iftest1:     	db "$0001 IF cls .",0 
59b5			;iftest2:     	db "$0000 IF cls .",0 
59b5			;iftest3:     	db "$0002 $0003 - IF cls .",0 
59b5			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
59b5			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
59b5			 
59b5			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59b5			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59b5			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59b5			 
59b5			 
59b5			 
59b5			; a small guess the number game 
59b5			 
59b5 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
59c6 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a28			 
5a28 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a5d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5a93 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5ac4 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5ad8 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5aed .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b21 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b65			 
5b65			; Using 'ga' save a high score across multiple runs using external storage 
5b65			 
5b65 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5bce			 
5bce			 
5bce			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5bce			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5bce			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5bce			 
5bce			; simple screen saver to test code memory reuse to destruction 
5bce			 
5bce .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c04 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c20 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c3c .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c55 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c9d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5cf4			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cf4			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5cf4			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5cf4			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5cf4			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5cf4			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5cf4			 
5cf4			 
5cf4			 
5cf4			; minesweeper/battleship finding game 
5cf4			; draws a game board of random ship/mine positions 
5cf4			; user enters coords to see if it hits on 
5cf4			; game ends when all are hit 
5cf4			; when hit or miss says how many may be in the area 
5cf4			 
5cf4			; setup the game board and then hide it 
5cf4 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d62 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5dac			; prompt for where to target 
5dac .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e42 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e67			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e67 .. 00		game2mbht:      db ": mbckht nop ;",0 
5e76 .. 00		game2mbms:      db ": mbcms nop ;",0 
5e84			; TODO how many might be near by 
5e84 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f01			 
5f01			; Game 3 
5f01			 
5f01			; Vert scroller ski game - avoid the trees! 
5f01			 
5f01			; v0 score (ie turns) 
5f01			; v1 player pos 
5f01			; v2 left wall 
5f01			; v3 right wall 
5f01			 
5f01			; Draw side walls randomly 
5f01			 
5f01 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f2f			 
5f2f			; Draw player 
5f2f .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f4d			 
5f4d			; TODO Get Key 
5f4d			 
5f4d			; TODO Move left right 
5f4d			 
5f4d			; scroll and move walls a bit 
5f4d			 
5f4d .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f7e			 
5f7e			; main game loop 
5f7e			 
5f7e .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5faa .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5fe9			 
5fe9			; key board defs 
5fe9			 
5fe9 .. 00		keyup:       db ": keyup $05 ;",0 
5ff7 .. 00		keydown:       db ": keydown $0a ;",0 
6007 .. 00		keyleft:       db ": keyleft $0b ;",0 
6017 .. 00		keyright:       db ": keyright $0c ;",0 
6028 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6036 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6044 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6052 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6060 .. 00		keyf5:       db ": keyf5 $14 ;",0 
606e .. 00		keyf6:       db ": keyf6 $15 ;",0 
607c .. 00		keyf7:       db ": keyf7 $16 ;",0 
608a .. 00		keyf8:       db ": keyf8 $17 ;",0 
6098 .. 00		keyf9:       db ": keyf9 $18 ;",0 
60a6 .. 00		keyf10:       db ": keyf10 $19 ;",0 
60b5 .. 00		keyf11:       db ": keyf11 $1a ;",0 
60c4 .. 00		keyf12:       db ": keyf12 $1b ;",0 
60d3			 
60d3 .. 00		keytab:       db ": keytab $09 ;",0 
60e2 .. 00		keycr:       db ": keycr $0d ;",0 
60f0 .. 00		keyhome:       db ": keyhome $0e ;",0 
6100 .. 00		keyend:       db ": keyend $0f ;",0 
610f .. 00		keybs:       db ": keybs $08 ;",0 
611d			 
611d			   
611d			 
611d			 
611d			 
611d			; eof 
# End of file forth_autostart.asm
611d			 
611d .. 00		sprompt1: db "Startup load...",0 
612d .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6143			 
6143			forth_startup: 
6143 21 7b 52			ld hl, startcmds 
6146 3e 00			ld a, 0 
6148 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
614b			 
614b e5			.start1:	push hl 
614c cd 94 0a			call clear_display 
614f 11 1d 61			ld de, sprompt1 
6152 3e 00		        ld a, display_row_1 
6154 cd a7 0a			call str_at_display 
6157 11 2d 61			ld de, sprompt2 
615a 3e 14		        ld a, display_row_2 
615c cd a7 0a			call str_at_display 
615f e1				pop hl 
6160 e5				push hl 
6161 5e				ld e,(hl) 
6162 23				inc hl 
6163 56				ld d,(hl) 
6164 3e 28		        ld a, display_row_3 
6166 cd a7 0a			call str_at_display 
6169 cd b7 0a			call update_display 
616c			 
616c			 
616c 3a c9 f3			ld a, (os_last_cmd) 
616f fe 00			cp 0 
6171 28 05			jr z, .startprompt 
6173 cd 36 0a			call delay250ms 
6176 18 24			jr .startdo 
6178				 
6178				 
6178			 
6178			.startprompt: 
6178			 
6178 3e 4f			ld a,display_row_4 + display_cols - 1 
617a 11 ed 1a		        ld de, endprg 
617d cd a7 0a			call str_at_display 
6180 cd b7 0a			call update_display 
6183 cd 42 0a			call delay1s 
6186 cd c9 65			call cin_wait 
6189						 
6189 fe 2a			cp '*' 
618b 28 5e			jr z, .startupend1 
618d fe 23			cp '#' 
618f 20 07			jr nz, .startno 
6191 3e 01			ld a, 1 
6193 32 c9 f3			ld (os_last_cmd),a 
6196 18 04			jr .startdo 
6198 fe 31		.startno:	cp '1' 
619a 28 3a			jr z,.startnxt  
619c			 
619c				; exec startup line 
619c			.startdo:	 
619c e1				pop hl 
619d e5				push hl 
619e				 
619e 5e				ld e,(hl) 
619f 23				inc hl 
61a0 56				ld d,(hl) 
61a1 eb				ex de,hl 
61a2			 
61a2 e5				push hl 
61a3			 
61a3 3e 00			ld a, 0 
61a5				;ld a, FORTH_END_BUFFER 
61a5 cd 31 11			call strlent 
61a8 23				inc hl   ; include zero term to copy 
61a9 06 00			ld b,0 
61ab 4d				ld c,l 
61ac e1				pop hl 
61ad 11 a3 ef			ld de, scratch 
61b0 ed b0			ldir 
61b2			 
61b2			 
61b2 21 a3 ef			ld hl, scratch 
61b5 cd 2e 1f			call forthparse 
61b8 cd 6e 1f			call forthexec 
61bb cd 85 1e			call forthexec_cleanup 
61be			 
61be 3e 3c			ld a, display_row_4 
61c0 11 91 18			ld de, endprog 
61c3			 
61c3 cd b7 0a			call update_display		 
61c6			 
61c6 3a c9 f3			ld a, (os_last_cmd) 
61c9 fe 00			cp 0 
61cb 20 09			jr nz, .startnxt 
61cd cd ef 1a			call next_page_prompt 
61d0 cd 94 0a		        call clear_display 
61d3 cd b7 0a			call update_display		 
61d6			 
61d6				; move onto next startup line? 
61d6			.startnxt: 
61d6			 
61d6 cd 36 0a			call delay250ms 
61d9 e1				pop hl 
61da			 
61da 23				inc hl 
61db 23				inc hl 
61dc			 
61dc e5				push hl 
61dd 5e				ld e, (hl) 
61de 23				inc hl 
61df 56				ld d, (hl) 
61e0 e1				pop hl 
61e1				; TODO replace 0 test 
61e1			 
61e1 eb				ex de, hl 
61e2 cd f1 0c			call ishlzero 
61e5			;	ld a,e 
61e5			;	add d 
61e5			;	cp 0    ; any left to do? 
61e5 eb				ex de, hl 
61e6 c2 4b 61			jp nz, .start1 
61e9 18 01			jr .startupend 
61eb			 
61eb e1			.startupend1: pop hl 
61ec			.startupend: 
61ec			 
61ec cd 94 0a			call clear_display 
61ef cd b7 0a			call update_display 
61f2 c9				ret 
61f3			 
61f3			 
61f3			; stack over and underflow checks 
61f3			 
61f3			; init the words to detect the under/overflow 
61f3			 
61f3			chk_stk_init: 
61f3				; a vague random number to check so we dont get any "lucky" hits 
61f3 3e 2d			ld a, 45 
61f5 6f				ld l, a 
61f6 00				nop 
61f7 3e 17			ld a, 23 
61f9 67				ld h, a 
61fa			 
61fa 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
61fd			 
61fd			;	ld (chk_stund), hl	; stack points.... 
61fd 22 fd fb			ld (chk_stovr), hl 
6200 22 8e f9			ld (chk_ret_und), hl 
6203 22 0c f9			ld (chk_ret_ovr), hl 
6206 22 0a f7			ld (chk_loop_ovr), hl 
6209 22 08 f5			ld (chk_data_ovr), hl 
620c c9				ret 
620d				 
620d			check_stacks: 
620d				; check all stack words 
620d			 
620d e5				push hl 
620e d5				push de 
620f			 
620f			;	ld de,(chk_word) 
620f			;	ld hl, (chk_stund)	; stack points.... 
620f			;	if DEBUG_STK_FAULT 
620f			;		DMARK "FAa" 
620f			;		CALLMONITOR 
620f			;	endif 
620f			;	call cmp16 
620f			;	jp z, .chk_faulta 
620f			; 
620f			;	ld de, sfaultsu 
620f			;	jp .chk_fault 
620f			 
620f 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6212 ed 5b 8a ef		ld de,(chk_word) 
6216				if DEBUG_STK_FAULT 
6216					DMARK "FAb" 
6216					CALLMONITOR 
6216				endif 
6216 cd e6 0c			call cmp16 
6219 28 06			jr z, .chk_fault1 
621b 11 bc 62			ld de, sfaultso 
621e c3 70 62			jp .chk_fault 
6221			.chk_fault1:  
6221 2a 8e f9			ld hl, (chk_ret_und) 
6224 ed 5b 8a ef		ld de,(chk_word) 
6228				if DEBUG_STK_FAULT 
6228					DMARK "FAU" 
6228					CALLMONITOR 
6228				endif 
6228 cd e6 0c			call cmp16 
622b ca 34 62			jp z, .chk_fault2 
622e 11 cc 62			ld de, sfaultru 
6231 c3 70 62			jp .chk_fault 
6234			.chk_fault2:  
6234 2a 0c f9			ld hl, (chk_ret_ovr) 
6237 ed 5b 8a ef		ld de,(chk_word) 
623b				if DEBUG_STK_FAULT 
623b					DMARK "FA1" 
623b					CALLMONITOR 
623b				endif 
623b cd e6 0c			call cmp16 
623e ca 47 62			jp z, .chk_fault3 
6241 11 da 62			ld de, sfaultro 
6244 c3 70 62			jp .chk_fault 
6247			.chk_fault3:  
6247 2a 0a f7			ld hl, (chk_loop_ovr) 
624a ed 5b 8a ef		ld de,(chk_word) 
624e				if DEBUG_STK_FAULT 
624e					DMARK "FA2" 
624e					CALLMONITOR 
624e				endif 
624e cd e6 0c			call cmp16 
6251 ca 5a 62			jp z, .chk_fault4 
6254 11 f4 62			ld de, sfaultlo 
6257 c3 70 62			jp .chk_fault 
625a			.chk_fault4:  
625a 2a 08 f5			ld hl, (chk_data_ovr) 
625d ed 5b 8a ef		ld de,(chk_word) 
6261				if DEBUG_STK_FAULT 
6261					DMARK "FA3" 
6261					CALLMONITOR 
6261				endif 
6261 cd e6 0c			call cmp16 
6264 ca 6d 62			jp z, .chk_fault5 
6267 11 0e 63			ld de, sfaultdo 
626a c3 70 62			jp .chk_fault 
626d			 
626d			 
626d			.chk_fault5:  
626d d1				pop de 
626e e1				pop hl 
626f			 
626f c9				ret 
6270			 
6270 cd 94 0a		.chk_fault: 	call clear_display 
6273 3e 14				ld a, display_row_2 
6275 cd a7 0a				call str_at_display 
6278 11 9e 62				   ld de, .stackfault 
627b 3e 00				ld a, display_row_1 
627d cd a7 0a				call str_at_display 
6280 11 bd fb				    ld de, debug_mark 
6283 3e 11				ld a, display_row_1+17 
6285 cd a7 0a				call str_at_display 
6288 cd b7 0a				call update_display 
628b			 
628b				; prompt before entering montior for investigating issue 
628b			 
628b 3e 3c			ld a, display_row_4 
628d 11 91 18			ld de, endprog 
6290			 
6290 cd b7 0a			call update_display		 
6293			 
6293 cd ef 1a			call next_page_prompt 
6296			 
6296 d1				pop de 
6297 e1				pop hl 
6298 cd e5 18				call monitor 
629b c3 df 17				jp warmstart 
629e					;jp 0 
629e					;halt 
629e			 
629e			 
629e			 
629e .. 00		.stackfault: 	db "Stack fault:",0 
62ab			 
62ab .. 00		sfaultsu: 	db	"Stack under flow",0 
62bc .. 00		sfaultso: 	db	"Stack over flow",0 
62cc .. 00		sfaultru:	db "RTS underflow",0 
62da .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
62f4 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
630e .. 00		sfaultdo:	db "DTS overflow", 0 
631b			 
631b			 
631b			fault_dsp_under: 
631b 11 2d 63			ld de, .dsp_under 
631e c3 dd 63			jp .show_fault 
6321			 
6321			fault_rsp_under: 
6321 11 3b 63			ld de, .rsp_under 
6324 c3 dd 63			jp .show_fault 
6327			fault_loop_under: 
6327 11 49 63			ld de, .loop_under 
632a c3 dd 63			jp .show_fault 
632d			 
632d .. 00		.dsp_under: db "DSP Underflow",0 
633b .. 00		.rsp_under: db "RSP Underflow",0 
6349 .. 00		.loop_under: db "LOOP Underflow",0 
6358			 
6358			 
6358 d5			type_faultn: 	push de 
6359 e5					push hl 
635a cd 94 0a				call clear_display 
635d 11 84 63				   ld de, .typefaultn 
6360 3e 00				ld a, display_row_1 
6362 cd a7 0a				call str_at_display 
6365 11 bd fb				    ld de, debug_mark 
6368 3e 11				ld a, display_row_1+17 
636a cd a7 0a				call str_at_display 
636d cd b7 0a				call update_display 
6370			 
6370				; prompt before entering montior for investigating issue 
6370			 
6370 3e 3c			ld a, display_row_4 
6372 11 91 18			ld de, endprog 
6375			 
6375 cd b7 0a			call update_display		 
6378			 
6378 cd ef 1a			call next_page_prompt 
637b			 
637b e5					push hl 
637c d5					push de 
637d cd e5 18				call monitor 
6380 c3 df 17				jp warmstart 
6383 76					halt 
6384			 
6384			 
6384 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
639b			 
639b d5			type_faults: 	push de 
639c e5					push hl 
639d cd 94 0a				call clear_display 
63a0 11 c6 63				   ld de, .typefaults 
63a3 3e 00				ld a, display_row_1 
63a5 cd a7 0a				call str_at_display 
63a8 11 bd fb				    ld de, debug_mark 
63ab 3e 11				ld a, display_row_1+17 
63ad cd a7 0a				call str_at_display 
63b0 cd b7 0a				call update_display 
63b3			 
63b3				; prompt before entering montior for investigating issue 
63b3			 
63b3 3e 3c			ld a, display_row_4 
63b5 11 91 18			ld de, endprog 
63b8			 
63b8 cd b7 0a			call update_display		 
63bb			 
63bb cd ef 1a			call next_page_prompt 
63be			 
63be e1					pop hl 
63bf d1					pop de 
63c0 cd e5 18				call monitor 
63c3 c3 df 17				jp warmstart 
63c6			 
63c6			 
63c6 .. 00		.typefaults: db "STR Type Expected TOS!",0 
63dd			 
63dd			.show_fault: 	 
63dd d5					push de 
63de cd 94 0a				call clear_display 
63e1 d1					pop de 
63e2 3e 00				ld a, display_row_1 
63e4 cd a7 0a				call str_at_display 
63e7 11 bd fb				    ld de, debug_mark 
63ea 3e 11				ld a, display_row_1+17 
63ec cd a7 0a				call str_at_display 
63ef cd b7 0a				call update_display 
63f2			 
63f2				; prompt before entering montior for investigating issue 
63f2			 
63f2 3e 3c			ld a, display_row_4 
63f4 11 91 18			ld de, endprog 
63f7			 
63f7 cd b7 0a			call update_display		 
63fa			 
63fa cd ef 1a			call next_page_prompt 
63fd			 
63fd e1					pop hl 
63fe d1					pop de 
63ff cd e5 18				call monitor 
6402			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6402			; TODO Make optional fault restart to cli or warm boot? 
6402					;jp warmstart 
6402 c3 37 18				jp cli 
6405 76					halt 
6406			; eof 
# End of file forth_kernel.asm
6406			;include "nascombasic.asm" 
6406			 
6406			 
6406			; find out where the code ends if loaded into RAM (for SC114) 
6406			;endofcode:  
6406			;	nop 
6406			 
6406			 
6406			; eof 
6406			 
# End of file main.asm
6406			include "firmware_lcd_4x20.asm" 
6406			; **********************************************************************  
6406			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6406			; **********************************************************************  
6406			;  
6406			; **  Written as a Small Computer Monitor App  
6406			; **  www.scc.me.uk  
6406			;  
6406			; History  
6406			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6406			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6406			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6406			;  
6406			; **********************************************************************  
6406			;  
6406			; This program is an example of one of the methods of interfacing an   
6406			; alphanumeric LCD module.   
6406			;  
6406			; In this example the display is connected to either a Z80 PIO or a   
6406			; simple 8-bit output port.   
6406			;  
6406			; This interfacing method uses 4-bit data mode and uses time delays  
6406			; rather than polling the display's ready status. As a result the   
6406			; interface only requires 6 simple output lines:  
6406			;   Output bit 0 = not used  
6406			;   Output bit 1 = not used  
6406			;   Output bit 2 = RS         High = data, Low = instruction  
6406			;   Output bit 3 = E          Active high  
6406			;   Output bit 4 = DB4  
6406			;   Output bit 5 = DB5  
6406			;   Output bit 6 = DB6  
6406			;   Output bit 7 = DB7  
6406			; Display's R/W is connected to 0v so it is always in write mode  
6406			;  
6406			; This set up should work with any system supporting the RC2014 bus  
6406			  
6406			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6406			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6406			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6406			;  
6406			; **********************************************************************  
6406			  
6406			; **********************************************************************  
6406			; **  Constants  
6406			; **********************************************************************  
6406			; LCD constants required by LCD support module  
6406			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6406			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6406			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6406			kLCDWidth:  EQU display_cols             ;Width in characters  
6406			  
6406			; **********************************************************************  
6406			; **  Code library usage  
6406			; **********************************************************************  
6406			  
6406			; send character to current cursor position  
6406			; wraps and/or scrolls screen automatically  
6406			  
6406			  
6406			lcd_init:  
6406			  
6406			; SCMonAPI functions used  
6406			  
6406			; Alphanumeric LCD functions used  
6406			; no need to specify specific functions for this module  
6406			  
6406 3e cf		            LD   A, 11001111b  
6408 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
640a 3e 00		            LD   A, 00000000b  
640c d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
640e			  
640e			; Initialise alphanumeric LCD module  
640e cd 87 64		            CALL fLCD_Init      ;Initialise LCD module  
6411			  
6411 c9				ret  
6412			  
6412			;  
6412			;;  
6412			; lcd functions  
6412			;  
6412			;  
6412			  
6412			; what is at cursor position   
6412			  
6412			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6412			;		call curptr  
6412			;		ret  
6412			  
6412			  
6412			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6412			  
6412			curptr:  
6412 c5				push bc  
6413 21 53 fb			ld hl, display_fb0  
6416			cpr:	  
6416				; loop for cursor whole row  
6416 0e 14			ld c, display_cols  
6418 23			cpr1:	inc hl  
6419 0d				dec c  
641a 20 fc			jr nz, cpr1  
641c 05				dec b  
641d 20 f7			jr nz, cpr  
641f			  
641f				; add col	  
641f			  
641f 23			cpr2:	inc hl  
6420 1d				dec e  
6421 20 fc			jr nz, cpr2  
6423			  
6423 c1				pop bc  
6424 c9				ret  
6425				  
6425			  
6425			  
6425			  
6425			  
6425			; write the frame buffer given in hl to hardware   
6425 22 5b fa		write_display: ld (display_write_tmp), hl 	   
6428 3e 00			ld a, kLCD_Line1  
642a cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
642d 06 14			ld b, display_cols  
642f ed 5b 5b fa		ld de, (display_write_tmp)  
6433 cd 7f 64			call write_len_string  
6436				  
6436				  
6436 2a 5b fa			ld hl, (display_write_tmp)  
6439 11 14 00			ld de, display_cols  
643c 19				add hl,de  
643d 22 5b fa			ld (display_write_tmp),hl  
6440			  
6440				  
6440 3e 40			ld a, kLCD_Line2  
6442 cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
6445 06 14			ld b, display_cols  
6447 ed 5b 5b fa		ld de, (display_write_tmp)  
644b cd 7f 64			call write_len_string  
644e				  
644e 2a 5b fa			ld hl, (display_write_tmp)  
6451 11 14 00			ld de, display_cols  
6454 19				add hl,de  
6455 22 5b fa			ld (display_write_tmp),hl  
6458			  
6458				  
6458 3e 14			ld a, kLCD_Line3  
645a cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
645d 06 14			ld b, display_cols  
645f ed 5b 5b fa		ld de, (display_write_tmp)  
6463 cd 7f 64			call write_len_string  
6466				  
6466 2a 5b fa			ld hl, (display_write_tmp)  
6469 11 14 00			ld de, display_cols  
646c 19				add hl,de  
646d 22 5b fa			ld (display_write_tmp),hl  
6470			  
6470				  
6470 3e 54			ld a, kLCD_Line4  
6472 cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
6475 06 14			ld b, display_cols  
6477 ed 5b 5b fa		ld de, (display_write_tmp)  
647b cd 7f 64			call write_len_string  
647e c9					ret  
647f				  
647f				; write out a fixed length string given in b from de  
647f			  
647f 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6480 cd d1 64		            CALL fLCD_Data      ;Write character to display  
6483 13				inc de  
6484 10 f9			djnz write_len_string  
6486 c9				ret  
6487			  
6487			; Some other things to do  
6487			;            LD   A, kLCD_Clear ;Display clear  
6487			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6487			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6487			;            LD   A, kLCD_On     ;Display on with no cursor  
6487			;            ;LD   A, kLCD_Off   ;Display off  
6487			;            CALL fLCD_Inst      ;Send instruction to display  
6487			;  
6487			;  
6487			;            halt  
6487			;  
6487			;  
6487			;MsgHello:   DB  "Hello World!",0  
6487			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6487			  
6487			; Custom characters 5 pixels wide by 8 pixels high  
6487			; Up to 8 custom characters can be defined  
6487			;BitMaps:      
6487			;; Character 0x00 = Battery icon  
6487			;            DB  01110b  
6487			;            DB  11011b  
6487			;            DB  10001b  
6487			;            DB  10001b  
6487			;            DB  11111b  
6487			;            DB  11111b  
6487			;            DB  11111b  
6487			;            DB  11111b  
6487			;; Character 0x01 = Bluetooth icon  
6487			;            DB  01100b  
6487			;            DB  01010b  
6487			;            DB  11100b  
6487			;            DB  01000b  
6487			;            DB  11100b  
6487			;            DB  01010b  
6487			;            DB  01100b  
6487			;            DB  00000b  
6487			;  
6487			  
6487			  
6487			; **********************************************************************  
6487			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6487			; **********************************************************************  
6487			;  
6487			; **  Written as a Small Computer Monitor App   
6487			; **  Version 0.1 SCC 2018-05-16  
6487			; **  www.scc.me.uk  
6487			;  
6487			; **********************************************************************  
6487			;  
6487			; This module provides support for alphanumeric LCD modules using with  
6487			; *  HD44780 (or compatible) controller  
6487			; *  5 x 7 pixel fonts  
6487			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6487			; *  Interface via six digital outputs to the display (see below)  
6487			;  
6487			; LCD module pinout:  
6487			;   1  Vss   0v supply  
6487			;   2  Vdd   5v supply  
6487			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6487			;   4  RS    High = data, Low = instruction  
6487			;   5  R/W   High = Read, Low = Write  
6487			;   6  E     Enable signal (active high)  
6487			;   7  DB0   Data bit 0  
6487			;   8  DB1   Data bit 1  
6487			;   9  DB2   Data bit 2  
6487			;  10  DB3   Data bit 3  
6487			;  11  DB4   Data bit 4  
6487			;  12  DB5   Data bit 5  
6487			;  13  DB6   Data bit 6  
6487			;  14  DB7   Data bit 7  
6487			;  15  A     Backlight anode (+)  
6487			;  16  K     Backlight cathode (-)  
6487			;  
6487			; This interfacing method uses 4-bit data mode and uses time delays  
6487			; rather than polling the display's ready status. As a result the   
6487			; interface only requires 6 simple output lines:  
6487			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6487			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6487			;   LCD DB4 = Microcomputer output port bit 4  
6487			;   LCD DB5 = Microcomputer output port bit 5  
6487			;   LCD DB6 = Microcomputer output port bit 6  
6487			;   LCD DB7 = Microcomputer output port bit 7  
6487			; Display's R/W is connected to 0v so it is always in write mode  
6487			; All 6 connections must be on the same port address <kLCDPrt>  
6487			; This method also allows a decent length of cable from micro to LCD  
6487			;  
6487			; **********************************************************************  
6487			;  
6487			; To include the code for any given function provided by this module,   
6487			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6487			; the parent source file.  
6487			; For example:  #REQUIRES   uHexPrefix  
6487			;  
6487			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6487			; in the parent source file.  
6487			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6487			;  
6487			; These are the function names provided by this module:  
6487			; fLCD_Init                     ;Initialise LCD  
6487			; fLCD_Inst                     ;Send instruction to LCD  
6487			; fLCD_Data                     ;Send data byte to LCD  
6487			; fLCD_Pos                      ;Position cursor  
6487			; fLCD_Str                      ;Display string  
6487			; fLCD_Def                      ;Define custom character  
6487			;  
6487			; **********************************************************************  
6487			;  
6487			; Requires SCMonAPI.asm to also be included in the project  
6487			;  
6487			  
6487			  
6487			; **********************************************************************  
6487			; **  Constants  
6487			; **********************************************************************  
6487			  
6487			; Constants that must be defined externally  
6487			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6487			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6487			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6487			;kLCDWidth: EQU 20             ;Width in characters  
6487			  
6487			; general line offsets in any frame buffer  
6487			  
6487			  
6487			display_row_1: equ 0  
6487			display_row_2: equ display_row_1+display_cols  
6487			display_row_3: equ display_row_2 + display_cols  
6487			display_row_4: equ display_row_3 + display_cols  
6487			;display_row_4_eol:   
6487			  
6487			  
6487			; Cursor position values for the start of each line  
6487			kLCD_Line1: EQU 0x00   
6487			kLCD_Line2: EQU 0x40    
6487			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6487			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6487			  
6487			; Instructions to send as A register to fLCD_Inst  
6487			kLCD_Clear: EQU 00000001b     ;LCD clear  
6487			kLCD_Off:   EQU 00001000b     ;LCD off  
6487			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6487			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6487			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6487			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6487			  
6487			; Constants used by this code module  
6487			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6487			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6487			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6487			  
6487			  
6487			  
6487			; **********************************************************************  
6487			; **  LCD support functions  
6487			; **********************************************************************  
6487			  
6487			; Initialise alphanumeric LCD module  
6487			; LCD control register codes:  
6487			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6487			;   N    0 = 1-line mode       1 = 2-line mode  
6487			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6487			;   D    0 = Display off       1 = Display on  
6487			;   C    0 = Cursor off        1 = Cursor on  
6487			;   B    0 = Blinking off      1 = Blinking on  
6487			;   ID   0 = Decrement mode    1 = Increment mode  
6487			;   SH   0 = Entire shift off  1 = Entire shift on  
6487 3e 28		fLCD_Init:  LD   A, 40  
6489 cd 3e 65		            CALL LCDDelay       ;Delay 40ms after power up  
648c			; For reliable reset set 8-bit mode - 3 times  
648c cd 28 65		            CALL WrFn8bit       ;Function = 8-bit mode  
648f cd 28 65		            CALL WrFn8bit       ;Function = 8-bit mode  
6492 cd 28 65		            CALL WrFn8bit       ;Function = 8-bit mode  
6495			; Set 4-bit mode  
6495 cd 24 65		            CALL WrFn4bit       ;Function = 4-bit mode  
6498 cd 3c 65		            CALL LCDDelay1      ;Delay 37 us or more  
649b			; Function set  
649b 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
649d cd b0 64		            CALL fLCD_Inst      ;2 line, display on  
64a0			; Display On/Off control  
64a0 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
64a2 cd b0 64		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
64a5			; Display Clear  
64a5 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
64a7 cd b0 64		            CALL fLCD_Inst      ;Clear display  
64aa			; Entry mode  
64aa 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
64ac cd b0 64		            CALL fLCD_Inst      ;Increment mode, shift off  
64af			; Display module now initialised  
64af c9			            RET  
64b0			; ok to here  
64b0			  
64b0			; Write instruction to LCD  
64b0			;   On entry: A = Instruction byte to be written  
64b0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
64b0 f5			fLCD_Inst:  PUSH AF  
64b1 f5			            PUSH AF  
64b2 cd c4 64		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
64b5 f1			            POP  AF  
64b6 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
64b7 17			            RLA  
64b8 17			            RLA  
64b9 17			            RLA  
64ba cd c4 64		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
64bd 3e 02		            LD   A, 2  
64bf cd 3e 65		            CALL LCDDelay       ;Delay 2 ms to complete   
64c2 f1			            POP  AF  
64c3 c9			            RET  
64c4 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
64c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
64c8 cb df		            SET  kLCDBitE, A  
64ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
64cc cb 9f		            RES  kLCDBitE, A  
64ce d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
64d0 c9			            RET  
64d1			  
64d1			  
64d1			; Write data to LCD  
64d1			;   On entry: A = Data byte to be written  
64d1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
64d1 f5			fLCD_Data:  PUSH AF  
64d2 f5			            PUSH AF  
64d3 cd e5 64		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
64d6 f1			            POP  AF  
64d7 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
64d8 17			            RLA  
64d9 17			            RLA  
64da 17			            RLA  
64db cd e5 64		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
64de 3e 96		            LD   A, 150  
64e0 3d			Wait:      DEC  A              ;Wait a while to allow data   
64e1 20 fd		            JR   NZ, Wait      ;  write to complete  
64e3 f1			            POP  AF  
64e4 c9			            RET  
64e5 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
64e7 cb d7		            SET  kLCDBitRS, A  
64e9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
64eb cb df		            SET  kLCDBitE, A  
64ed d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
64ef cb 9f		            RES  kLCDBitE, A  
64f1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
64f3 cb 97		            RES  kLCDBitRS, A  
64f5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
64f7 c9			            RET  
64f8			  
64f8			  
64f8			; Position cursor to specified location  
64f8			;   On entry: A = Cursor position  
64f8			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
64f8 f5			fLCD_Pos:   PUSH AF  
64f9 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
64fb cd b0 64		            CALL fLCD_Inst      ;Write instruction to LCD  
64fe f1			            POP  AF  
64ff c9			            RET  
6500			  
6500			  
6500			; Output text string to LCD  
6500			;   On entry: DE = Pointer to null terminated text string  
6500			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6500 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6501 b7			            OR   A              ;Null terminator?  
6502 c8			            RET  Z              ;Yes, so finished  
6503 cd d1 64		            CALL fLCD_Data      ;Write character to display  
6506 13			            INC  DE             ;Point to next character  
6507 18 f7		            JR   fLCD_Str       ;Repeat  
6509 c9					ret  
650a			  
650a			; Define custom character  
650a			;   On entry: A = Character number (0 to 7)  
650a			;             DE = Pointer to character bitmap data  
650a			;   On exit:  A = Next character number  
650a			;             DE = Next location following bitmap  
650a			;             BC HL IX IY I AF' BC' DE' HL' preserved  
650a			; Character is   
650a c5			fLCD_Def:   PUSH BC  
650b f5			            PUSH AF  
650c 07			            RLCA                ;Calculate location  
650d 07			            RLCA                ;  for bitmap data  
650e 07			            RLCA                ;  = 8 x CharacterNumber  
650f f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6511 cd b0 64		            CALL fLCD_Inst      ;Write instruction to LCD  
6514 06 00		            LD   B, 0  
6516 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6517 cd d1 64		            CALL fLCD_Data      ;Write byte to display  
651a 13			            INC  DE             ;Point to next byte  
651b 04			            INC  B              ;Count bytes  
651c cb 58		            BIT  3, B           ;Finish all 8 bytes?  
651e 28 f6		            JR   Z, Loop       ;No, so repeat  
6520 f1			            POP  AF  
6521 3c			            INC  A              ;Increment character number  
6522 c1			            POP  BC  
6523 c9			            RET  
6524			  
6524			  
6524			; **********************************************************************  
6524			; **  Private functions  
6524			; **********************************************************************  
6524			  
6524			; Write function to LCD  
6524			;   On entry: A = Function byte to be written  
6524			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6524 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6526 18 02		            JR   WrFunc  
6528 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
652a f5			WrFunc:     PUSH AF  
652b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
652d cb df		            SET  kLCDBitE, A  
652f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6531 cb 9f		            RES  kLCDBitE, A  
6533 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6535 3e 05		            LD   A, 5  
6537 cd 3e 65		            CALL LCDDelay       ;Delay 5 ms to complete  
653a f1			            POP  AF  
653b c9			            RET  
653c			  
653c			  
653c			; Delay in milliseconds  
653c			;   On entry: A = Number of milliseconds delay  
653c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
653c 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
653e d5			LCDDelay:   PUSH DE  
653f 5f			            LD   E, A           ;Delay by 'A' ms  
6540 16 00		            LD   D, 0  
6542 cd 27 0a		            CALL aDelayInMS  
6545 d1			            POP  DE  
6546 c9			            RET  
6547			  
6547			  
6547			  
6547			  
6547			; eof  
6547			  
# End of file firmware_lcd_4x20.asm
6547			include "firmware_key_4x4.asm" 
6547			  
6547			  
6547			; bit mask for each scan column and row for teing the matrix  
6547			  
6547			; out   
6547 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
654b			; in  
654b 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
654f			  
654f			; row/col to character map  
654f			  
654f			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
654f			;    
654f			  
654f			; physical key matrix map to face of key  
654f			  
654f			  
654f			;      	1	2	3	A  
654f			;   	abc”	def&	ghi$	s1  
654f			;			  
654f			;	4	5	6	B  
654f			; 	jkl,	mno.	pqr:	s2  
654f			;			  
654f			; 	7	8	9	C  
654f			;	stu;	vwx@	yz?!	s3  
654f			;			  
654f			; 	*	0	#	D  
654f			; 	shift lck '	Space < >	Enter ( )	s4  
654f			;       tab bs 		  
654f			  
654f			  
654f			  
654f			  
654f			key_init:  
654f			  
654f			; SCMonAPI functions used  
654f			  
654f			; Alphanumeric LCD functions used  
654f			; no need to specify specific functions for this module  
654f			  
654f			  
654f 3e cf		            LD   A, 11001111b  
6551 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6553			;            LD   A, 00000000b  
6553 3e 0f		            LD   A, 00001111b  
6555 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6557			  
6557			  
6557				; TODO Configure cursor shapes  
6557			  
6557				; Load cursor shapes   
6557 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6559 11 69 65		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
655c 06 02		            LD   B, 2           ;Number of characters to define  
655e cd 0a 65		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6561 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6563			  
6563 3e 01				ld a, 1  
6565 32 56 fa			ld (cursor_shape),a  
6568 c9				ret  
6569			  
6569			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6569			; Up to 8 custom characters can be defined  
6569			.cursor_shapes:      
6569			;; Character 0x00 = Normal  
6569 1f			            DB  11111b  
656a 1f			            DB  11111b  
656b 1f			            DB  11111b  
656c 1f			            DB  11111b  
656d 1f			            DB  11111b  
656e 1f			            DB  11111b  
656f 1f			            DB  11111b  
6570 1f			            DB  11111b  
6571			;; Character 0x01 = Modifier  
6571 1f			            DB  11111b  
6572 1b			            DB  11011b  
6573 1b			            DB  11011b  
6574 1b			            DB  11011b  
6575 1b			            DB  11011b  
6576 1f			            DB  11111b  
6577 1b			            DB  11011b  
6578 1f			            DB  11111b  
6579			  
6579			  
6579			  
6579			  
6579			; Display custom character 0  
6579			;            LD   A, kLCD_Line1+14  
6579			;            CALL fLCD_Pos       ;Position cursor to location in A  
6579			;            LD   A, 0  
6579			;            CALL fLCD_Data      ;Write character in A at cursor  
6579			  
6579			; Display custom character 1  
6579			;            LD   A, kLCD_Line2+14  
6579			;            CALL fLCD_Pos      ;Position cursor to location in A  
6579			;            LD   A, 1  
6579			;            CALL fLCD_Data     ;Write character in A at cursor  
6579			  
6579			; keyboard scanning   
6579			  
6579			  
6579			; key_rows: equ 4  
6579			; key_cols: equ 4  
6579			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6579			  
6579			; key_scanr: equ key_row_bitmask  
6579			; key_scanc: equ key_col_bitmask  
6579			  
6579			; key_char_map: equ key_map  
6579			  
6579			  
6579			  
6579			; character in from keyboard  
6579			  
6579 ..			.matrix_to_char: db "D#0*C987B654A321"  
6589			  
6589			  
6589			; map the physical key to a char dependant on state  
6589			  
6589			.key_map_fa:   
6589			  
6589 ..					db 'D'  
658a 0d					db KEY_CR    ; cr  
658b ..					db ' '  
658c 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
658d ..					db 'C'  
658e ..					db 'y'  
658f ..					db 'v'  
6590 ..					db 's'  
6591 ..					db 'B'  
6592 ..					db 'p'  
6593 ..					db 'm'  
6594 ..					db 'j'  
6595 ..					db 'A'  
6596 ..					db 'g'  
6597 ..					db 'd'  
6598 ..					db 'a'  
6599			  
6599			.key_map_fb:  
6599			  
6599 ..					db 'A'  
659a ..					db '+'   
659b ..					db '<'  
659c ..					db  "'"    
659d			  
659d ..					db 'A'  
659e ..					db 'z'  
659f ..					db 'w'  
65a0 ..					db 't'  
65a1 ..					db 'A'  
65a2 ..					db 'q'  
65a3 ..					db 'n'  
65a4 ..					db 'k'  
65a5 ..					db 'A'  
65a6 ..					db 'h'  
65a7 ..					db 'e'  
65a8 ..			 		db 'b'  
65a9			  
65a9			.key_map_fc:   
65a9			  
65a9			  
65a9 ..					db 'A'  
65aa ..					db '-'   
65ab ..					db '>'  
65ac ..					db  '='   	  
65ad ..					db 'A'  
65ae ..					db '?'  
65af ..					db 'x'  
65b0 ..					db 'u'  
65b1 ..					db 'A'  
65b2 ..					db 'r'  
65b3 ..					db 'o'  
65b4 ..					db 'l'  
65b5 ..					db 'A'  
65b6 ..					db 'i'  
65b7 ..					db 'f'  
65b8 ..					db 'c'  
65b9			  
65b9				  
65b9			.key_map_fd:  
65b9			  
65b9 ..					db 'A'  
65ba ..					db '/'   
65bb ..					db '%'   
65bc 08					db KEY_BS  ; back space  
65bd ..					db 'A'  
65be ..					db '!'  
65bf ..					db '@'  
65c0 ..					db ';'  
65c1 ..					db 'A'  
65c2 ..					db ':'  
65c3 ..					db '.'  
65c4 ..					db ','  
65c5 ..					db 'A'  
65c6 ..					db '$'  
65c7 ..					db '&'  
65c8 ..				 	db '"'  
65c9			  
65c9					  
65c9				  
65c9			  
65c9			; add cin and cin_wait  
65c9			  
65c9 cd da 65		cin_wait: 	call cin  
65cc fe 00			cp 0  
65ce 28 f9			jr z, cin_wait   ; block until key press  
65d0			  
65d0 f5				push af   ; save key pressed  
65d1			  
65d1 cd da 65		.cin_wait1:	call cin  
65d4 fe 00			cp 0  
65d6 20 f9			jr nz, .cin_wait1  	; wait for key release  
65d8			  
65d8 f1				pop af   ; get key  
65d9 c9				ret  
65da			  
65da			  
65da cd eb 65		cin: 	call .mtoc  
65dd			  
65dd				; no key held  
65dd fe 00			cp 0  
65df c8				ret z  
65e0			  
65e0				; stop key bounce  
65e0			  
65e0			;	ld (key_held),a		 ; save it  
65e0 47				ld b, a  
65e1			  
65e1 c5			.cina1:	push bc  
65e2 cd eb 65			call .mtoc  
65e5 c1				pop bc  
65e6 b8				cp b  
65e7 28 f8			jr z, .cina1  
65e9 78				ld a,b		  
65ea c9				ret  
65eb			  
65eb			; detect keyboard modifier key press and apply new overlay to the face key held  
65eb			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
65eb			  
65eb			;.cin_map_modifier:   
65eb			;	ld a, (hl)  
65eb			;	and 255  
65eb			;	ret NZ		; modifier key not flagged  
65eb			;  
65eb			;	; get key face  
65eb			;  
65eb			;	ld b,(key_face_held)  
65eb			;  
65eb			;	ld b, key_cols * key_rows  
65eb			;  
65eb			;	push de  
65eb			;	pop hl  
65eb			;  
65eb			;.mmod1: ld a,(hl)   ; get map test  
65eb			;	cp b  
65eb			;	jr z, .mmod2  
65eb			;  
65eb			;  
65eb			;  
65eb			;.mmod2: inc hl    ;   
65eb			;  
65eb			;	  
65eb			;  
65eb			;	  
65eb			;  
65eb			;	ld hl,key_actual_pressed  
65eb			;	ld (hl),a,  
65eb			;	ret  
65eb			  
65eb				  
65eb			  
65eb			; map matrix key held to char on face of key  
65eb			  
65eb			.mtoc:  
65eb			  
65eb			  
65eb				; TODO optimise the code....  
65eb			  
65eb			; scan keyboard row 1  
65eb 3e 80			ld a, 128  
65ed 21 d3 fb			ld hl, keyscan_table  
65f0 cd d2 66			call .rowscan  
65f3			  
65f3				   
65f3			  
65f3 3e 40			ld a, 64  
65f5 21 d7 fb			ld hl, keyscan_table+key_cols  
65f8 cd d2 66			call .rowscan  
65fb			  
65fb			  
65fb			  
65fb			  
65fb 3e 20			ld a, 32  
65fd 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6600 cd d2 66			call .rowscan  
6603			  
6603			  
6603			  
6603 3e 10			ld a, 16  
6605 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6608 cd d2 66			call .rowscan  
660b			  
660b			  
660b				; flag if key D is held down and remove from reporting  
660b 01 b9 65			ld bc, .key_map_fd    
660e 21 d3 fb			ld hl, keyscan_table  
6611 11 c5 fb			ld de, key_fd  
6614 cd 64 66			call .key_shift_hold  
6617 fe ff			cp 255  
6619 28 33			jr z, .cinmap  
661b				; flag if key C is held down and remove from reporting  
661b 01 a9 65			ld bc, .key_map_fc    
661e 21 d7 fb			ld hl, keyscan_table+key_cols  
6621 11 c6 fb			ld de, key_fc  
6624 cd 64 66			call .key_shift_hold  
6627 fe ff			cp 255  
6629 28 23			jr z, .cinmap  
662b				; flag if key B is held down and remove from reporting  
662b 01 99 65			ld bc, .key_map_fb    
662e 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6631 11 c7 fb			ld de, key_fb  
6634 cd 64 66			call .key_shift_hold  
6637 fe ff			cp 255  
6639 28 13			jr z, .cinmap  
663b				; flag if key A is held down and remove from reporting  
663b 01 89 65			ld bc, .key_map_fa    
663e 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6641 11 c8 fb			ld de, key_fa  
6644 cd 64 66			call .key_shift_hold  
6647 fe ff			cp 255  
6649 28 03			jr z, .cinmap  
664b			  
664b 11 79 65			ld de, .matrix_to_char  
664e			  
664e			  
664e			.cinmap:   
664e				if DEBUG_KEY  
664e			            LD   A, kLCD_Line4  
664e			            CALL fLCD_Pos       ;Position cursor to location in A  
664e					push de  
664e			            LD   DE, keyscan_table  
664e			            CALL fLCD_Str       ;Display string pointed to by DE  
664e					pop de  
664e				endif  
664e			  
664e				; scan key matrix table for any held key  
664e			  
664e				; de holds either the default matrix or one selected above  
664e			  
664e 21 d3 fb			ld hl, keyscan_table  
6651 06 10			ld b,key_cols*key_rows  
6653			  
6653 7e			.cin1:	ld a,(hl)  
6654 fe 23			cp '#'  
6656 28 08			jr z, .cinhit  
6658 23				inc hl  
6659 13				inc de  
665a 05				dec b  
665b 20 f6			jr nz, .cin1  
665d				; no key found held  
665d 3e 00			ld a,0  
665f c9				ret  
6660 d5			.cinhit: push de  
6661 e1				pop hl  
6662 7e				ld a,(hl)  
6663 c9				ret  
6664			  
6664			; flag a control key is held   
6664			; hl is key pin, de is flag indicator  
6664			  
6664			.key_shift_hold:  
6664 c5				push bc  
6665 3e 01			ld a, 1  
6667 32 56 fa			ld (cursor_shape),a  
666a 06 00			ld b, 0  
666c 7e				ld a, (hl)  
666d fe 2e			cp '.'  
666f 28 0a			jr z, .key_shift1  
6671 06 ff			ld b, 255  
6673 3e 2b			ld a, '+'    ; hide key from later scans  
6675 77				ld (hl),a  
6676 3e 02			ld a, 2  
6678 32 56 fa			ld (cursor_shape),a  
667b			.key_shift1:  
667b				; write flag indicator  
667b 78				ld a,b  
667c 12				ld (de),a  
667d			  
667d d1				pop de    ; de now holds the key map ptr  
667e c9				ret  
667f			  
667f				  
667f				  
667f			  
667f			  
667f			  
667f			  
667f			  
667f			  
667f			  
667f			  
667f			  
667f			  
667f c9				ret  
6680			  
6680			;	push hl  
6680			;	push de  
6680			;	push bc  
6680			;	call keyscan  
6680			;	; map key matrix to ascii value of key face  
6680			;  
6680			;	ld hl, key_face_map  
6680			;	ld de, keyscan_table  
6680			;  
6680			;	; get how many keys to look at  
6680			;	ld b, keyscan_table_len  
6680			;	  
6680			;  
6680			;	; at this stage fall out on first key hit  
6680			;	; TODO handle multiple key press  
6680			;  
6680			;map1:	ld a,(hl)  
6680			;	cp '#'  
6680			;	jr z, keyhit  
6680			;	inc hl  
6680			;	inc de  
6680			;	dec b  
6680			;	jr nz, map1  
6680			;nohit:	ld a, 0  
6680			;	jr keydone  
6680			;keyhit: push de  
6680			;	pop hl  
6680			;	ld a,(hl)  
6680			;keydone:  
6680			;	push bc  
6680			;	push de  
6680			; 	push hl  
6680			;	ret   
6680			;  
6680			  
6680			  
6680			  
6680			  
6680			; scan physical key matrix  
6680			  
6680			  
6680			;keyscan:  
6680			;  
6680			;; for each key_row use keyscanr bit mask for out  
6680			;; then read in for keyscanc bitmask  
6680			;; save result of row scan to keyscantable  
6680			;  
6680			;; scan keyboard row 1  
6680			;  
6680			;	ld b, key_rows  
6680			;	ld hl, key_scanr  
6680			;	ld de, keyscan_table  
6680			;  
6680			;rowloop:  
6680			;  
6680			;	ld a,(hl)		; out bit mask to energise keyboard row  
6680			;	call rowscan  
6680			;	inc hl  
6680			;	dec b  
6680			;	jr nz, rowloop  
6680			;  
6680			;	ret  
6680			;  
6680			;  
6680			;; pass a out bitmask, b row number  
6680			;arowscan:   
6680			;	push bc  
6680			;  
6680			;	ld d, b  
6680			;  
6680			;	; calculate buffer location for this row  
6680			;  
6680			;	ld hl, keyscan_table	  
6680			;kbufr:  ld e, key_cols  
6680			;kbufc:	inc hl  
6680			;	dec e  
6680			;	jr nz, kbufc  
6680			;	dec d  
6680			;	jr nz, kbufr  
6680			;  
6680			;	; energise row and read columns  
6680			;  
6680			;	out (portbdata),a  
6680			;	in a,(portbdata)  
6680			;	ld c,a  
6680			;  
6680			;  
6680			;	; save buffer loc  
6680			;  
6680			;	ld (keybufptr), hl  
6680			;  
6680			;	ld hl, key_scanc  
6680			;	ld d, key_cols  
6680			;  
6680			;	; for each column check each bit mask  
6680			;  
6680			;colloop:  
6680			;	  
6680			;  
6680			;	; reset flags for the row   
6680			;  
6680			;	ld b,'.'  
6680			;	and (hl)  
6680			;	jr z, maskskip  
6680			;	ld b,'#'  
6680			;maskskip:  
6680			;	; save  key state  
6680			;	push hl  
6680			;	ld hl, (keybufptr)  
6680			;	ld (hl), b  
6680			;	inc hl  
6680			;	ld (keybufptr), hl  
6680			;  
6680			;	; move to next bit mask  
6680			;	pop hl  
6680			;	inc hl  
6680			;  
6680			;	dec d  
6680			;	jr nz, colloop  
6680			;  
6680			;	ret  
6680			;  
6680			;  
6680			;;  
6680			; lcd functions  
6680			;  
6680			;  
6680			  
6680			;if DEBUG_KEY_MATRIX  
6680			  
6680			; test function to display hardware view of matrix state  
6680			  
6680			matrix:  
6680			  
6680			  
6680			  
6680			; scan keyboard row 1  
6680 3e 80			ld a, 128  
6682 21 f8 fb			ld hl, keyscan_table_row1  
6685 cd d2 66			call .rowscan  
6688			  
6688 3e 40			ld a, 64  
668a 21 f3 fb			ld hl, keyscan_table_row2  
668d cd d2 66			call .rowscan  
6690			  
6690 3e 20			ld a, 32  
6692 21 ee fb			ld hl, keyscan_table_row3  
6695 cd d2 66			call .rowscan  
6698			  
6698 3e 10			ld a, 16  
669a 21 e9 fb			ld hl, keyscan_table_row4  
669d cd d2 66			call .rowscan  
66a0			  
66a0			; Display text on first line  
66a0 3e 00		            LD   A, kLCD_Line1  
66a2 cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
66a5 11 f8 fb		            LD   DE, keyscan_table_row1  
66a8			            ;LD   DE, MsgHello  
66a8 cd 00 65		            CALL fLCD_Str       ;Display string pointed to by DE  
66ab			  
66ab			; Display text on second line  
66ab 3e 40		            LD   A, kLCD_Line2  
66ad cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
66b0 11 f3 fb		            LD   DE, keyscan_table_row2  
66b3 cd 00 65		            CALL fLCD_Str       ;Display string pointed to by DE  
66b6 3e 14		            LD   A, kLCD_Line3  
66b8 cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
66bb 11 ee fb		            LD   DE, keyscan_table_row3  
66be cd 00 65		            CALL fLCD_Str       ;Display string pointed to by DE  
66c1 3e 54		            LD   A, kLCD_Line4  
66c3 cd f8 64		            CALL fLCD_Pos       ;Position cursor to location in A  
66c6 11 e9 fb		            LD   DE, keyscan_table_row4  
66c9 cd 00 65		            CALL fLCD_Str       ;Display string pointed to by DE  
66cc			  
66cc cd 36 0a			call delay250ms  
66cf c3 80 66			jp matrix  
66d2			  
66d2			; pass de as row display flags  
66d2			.rowscan:   
66d2 d3 c1			out (portbdata),a  
66d4 db c1			in a,(portbdata)  
66d6 4f				ld c,a  
66d7				; reset flags for the row   
66d7 06 2e			ld b,'.'  
66d9 e6 01			and 1  
66db 28 02			jr z, .p1on  
66dd 06 23			ld b,'#'  
66df			.p1on:  
66df 70				ld (hl), b  
66e0 23				inc hl  
66e1			  
66e1 06 2e			ld b,'.'  
66e3 79				ld a,c  
66e4 e6 02			and 2  
66e6			;	bit 0,a  
66e6 28 02			jr z, .p2on  
66e8 06 23			ld b,'#'  
66ea			.p2on:  
66ea 70				ld (hl), b  
66eb 23				inc hl  
66ec			;  
66ec 06 2e			ld b,'.'  
66ee 79				ld a,c  
66ef e6 04			and 4  
66f1			;;	bit 0,a  
66f1 28 02			jr z, .p3on  
66f3 06 23			ld b,'#'  
66f5			.p3on:  
66f5 70				ld (hl), b  
66f6 23				inc hl  
66f7			;;  
66f7 06 2e			ld b,'.'  
66f9			;;	bit 0,a  
66f9 79				ld a,c  
66fa e6 08			and 8  
66fc 28 02			jr z, .p4on  
66fe 06 23			ld b,'#'  
6700			.p4on:  
6700 70				ld (hl), b  
6701 23				inc hl  
6702			  
6702			; zero term  
6702 06 00			ld b,0  
6704 70				ld (hl), b  
6705			  
6705 c9			.rscandone: ret  
6706			  
6706			  
6706			  
6706			;endif  
6706			  
6706			  
6706			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6706
