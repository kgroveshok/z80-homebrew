# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 69 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd 15 0d				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd 15 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd 15 0d				call clear_display  
0037			  
0037			  
0037 cd 66 71				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd af 72			call key_init  
003d cd fb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ec 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd 38 0d			call update_display  
0046 cd 92 0c			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd 1a 0d			call fill_display  
004e cd 38 0d			call update_display  
0051 cd 92 0c			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd 1a 0d			call fill_display  
0059 cd 38 0d			call update_display  
005c cd 92 0c			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd 1a 0d			call fill_display  
0064 cd 38 0d			call update_display  
0067 cd 92 0c			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 9c 1a			ld de, prom_bootmsg  
006f cd 28 0d			call str_at_display  
0072 cd 38 0d			call update_display  
0075			  
0075			  
0075 cd 92 0c			call delay1s  
0078 cd 92 0c			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 b1 1a			ld de, prom_bootmsg1  
0080 cd 28 0d			call str_at_display  
0083 cd 38 0d			call update_display  
0086 cd 92 0c			call delay1s  
0089 cd 92 0c			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			;  Perform SCLK wait pulse 
009d			 
009d			spi_clk: 
009d f5				push af 
009e 3a f1 fb			ld a, (spi_clktime) 
00a1 fe 00			cp 0 
00a3 28 03			jr z, .scskip 
00a5 cd 77 0c			call aDelayInMS 
00a8			.scskip: 
00a8 f1				pop af 
00a9 c9				ret 
00aa			 
00aa			 
00aa			 
00aa			; TODO store port id for spi device ie dev c 
00aa			; TODO store pin for SO 
00aa			; TODO store pin for SI 
00aa			; TODO store pin for SCLK 
00aa			 
00aa			; 
00aa			 
00aa			; ensure that spi bus is in a stable state with default pins  
00aa			 
00aa			se_stable_spi:   
00aa			 
00aa				 ; set DI high, CE high , SCLK low 
00aa				;ld a, SPI_DI | SPI_CE0 
00aa 3e 07			ld a, SPI_DI  
00ac cd b6 01			call spi_ce_high 
00af d3 80			 out (storage_adata),a 
00b1 32 ee fb			ld (spi_portbyte),a 
00b4			 
00b4				if DEBUG_SPI 
00b4					push hl 
00b4					ld l, a 
00b4					DMARK "SPI" 
00b4					CALLMONITOR 
00b4					pop hl 
00b4				endif 
00b4 c9				ret 
00b5			 
00b5			; byte to send in a 
00b5			 
00b5			spi_send_byte: 
00b5				; save byte to send for bit mask shift out 
00b5 4f			        ld c,a 
00b6 3a ee fb			ld a,(spi_portbyte) 
00b9				  
00b9				; clock out	each bit of the byte msb first 
00b9			 
00b9 06 08			ld b, 8 
00bb			.ssb1: 
00bb				; clear so bit  
00bb cb bf			res SPI_DI, a 
00bd cb 11			rl c 
00bf				; if bit 7 is set then carry is set 
00bf 30 02			jr nc, .ssb2 
00c1 cb ff			set SPI_DI,a 
00c3			.ssb2:  ; output bit to ensure it is stable 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6				; clock bit high 
00c6 cb ef			set SPI_SCLK,a 
00c8 d3 80			out (storage_adata),a 
00ca 00				nop 
00cb cd 9d 00			call spi_clk 
00ce				; then low 
00ce cb af			res SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3 cd 9d 00			call spi_clk 
00d6 10 e3			djnz .ssb1 
00d8			 
00d8 32 ee fb			ld (spi_portbyte),a 
00db c9				ret 
00dc			 
00dc			; TODO low level get byte into A on spi 
00dc			 
00dc			spi_read_byte:  
00dc			 
00dc				; save byte to send for bit mask shift out 
00dc 0e 00		    ld c,0 
00de 3a ee fb			ld a,(spi_portbyte) 
00e1				  
00e1				; clock out	each bit of the byte msb first 
00e1			 
00e1			 
00e1				; clock bit high 
00e1 cb ef			set SPI_SCLK,a 
00e3 d3 80			out (storage_adata),a 
00e5 00				nop 
00e6 cd 9d 00			call spi_clk 
00e9			 
00e9			    ; read DO  
00e9			 
00e9 cb f9		    set 7,c 
00eb db 80			in a,(storage_adata) 
00ed cb 77		    bit SPI_DO,a 
00ef 20 02		    jr nz, .b7 
00f1 cb b9		    res 7,c 
00f3			.b7: 
00f3				; then low 
00f3 cb af			res SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8 cd 9d 00			call spi_clk 
00fb			     
00fb			 
00fb				; clock bit high 
00fb cb ef			set SPI_SCLK,a 
00fd d3 80			out (storage_adata),a 
00ff 00				nop 
0100 cd 9d 00			call spi_clk 
0103			 
0103			    ; read DO  
0103			 
0103 cb f1		    set 6,c 
0105 db 80			in a,(storage_adata) 
0107 cb 77		    bit SPI_DO,a 
0109 20 02		    jr nz, .b6 
010b cb b1		    res 6,c 
010d			.b6: 
010d				; then low 
010d cb af			res SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112 cd 9d 00			call spi_clk 
0115			 
0115				; clock bit high 
0115 cb ef			set SPI_SCLK,a 
0117 d3 80			out (storage_adata),a 
0119 00				nop 
011a cd 9d 00			call spi_clk 
011d			 
011d			 
011d			    ; read DO  
011d			 
011d cb e9		    set 5,c 
011f db 80			in a,(storage_adata) 
0121 cb 77		    bit SPI_DO,a 
0123 20 02		    jr nz, .b5 
0125 cb a9		    res 5,c 
0127			.b5: 
0127				; then low 
0127 cb af			res SPI_SCLK,a 
0129 d3 80			out (storage_adata),a 
012b 00				nop 
012c cd 9d 00			call spi_clk 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134 cd 9d 00			call spi_clk 
0137			 
0137			    ; read DO  
0137			 
0137 cb e1		    set 4,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b4 
013f cb a1		    res 4,c 
0141			.b4: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146 cd 9d 00			call spi_clk 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e cd 9d 00			call spi_clk 
0151			 
0151			    ; read DO  
0151			 
0151 cb d9		    set 3,c 
0153 db 80			in a,(storage_adata) 
0155 cb 77		    bit SPI_DO,a 
0157 20 02		    jr nz, .b3 
0159 cb 99		    res 3,c 
015b			.b3: 
015b				; then low 
015b cb af			res SPI_SCLK,a 
015d d3 80			out (storage_adata),a 
015f 00				nop 
0160 cd 9d 00			call spi_clk 
0163				; clock bit high 
0163 cb ef			set SPI_SCLK,a 
0165 d3 80			out (storage_adata),a 
0167 00				nop 
0168 cd 9d 00			call spi_clk 
016b			 
016b			    ; read DO  
016b			 
016b cb d1		    set 2,c 
016d db 80			in a,(storage_adata) 
016f cb 77		    bit SPI_DO,a 
0171 20 02		    jr nz, .b2 
0173 cb 91		    res 2,c 
0175			.b2: 
0175				; then low 
0175 cb af			res SPI_SCLK,a 
0177 d3 80			out (storage_adata),a 
0179 00				nop 
017a cd 9d 00			call spi_clk 
017d				; clock bit high 
017d cb ef			set SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182 cd 9d 00			call spi_clk 
0185			 
0185			    ; read DO  
0185			 
0185 cb c9		    set 1,c 
0187 db 80			in a,(storage_adata) 
0189 cb 77		    bit SPI_DO,a 
018b 20 02		    jr nz, .b1 
018d cb 89		    res 1,c 
018f			.b1: 
018f				; then low 
018f cb af			res SPI_SCLK,a 
0191 d3 80			out (storage_adata),a 
0193 00				nop 
0194 cd 9d 00			call spi_clk 
0197				; clock bit high 
0197 cb ef			set SPI_SCLK,a 
0199 d3 80			out (storage_adata),a 
019b 00				nop 
019c cd 9d 00			call spi_clk 
019f			 
019f			    ; read DO  
019f			 
019f cb c1		    set 0,c 
01a1 db 80			in a,(storage_adata) 
01a3 cb 77		    bit SPI_DO,a 
01a5 20 02		    jr nz, .b0 
01a7 cb 81		    res 0,c 
01a9			.b0: 
01a9				; then low 
01a9 cb af			res SPI_SCLK,a 
01ab d3 80			out (storage_adata),a 
01ad 00				nop 
01ae cd 9d 00			call spi_clk 
01b1			 
01b1			 
01b1 32 ee fb			ld (spi_portbyte),a 
01b4			 
01b4			    ; return byte 
01b4 79			    ld a,c 
01b5			 
01b5			 
01b5 c9				ret 
01b6			 
01b6			 
01b6			 
01b6			spi_ce_high: 
01b6			 
01b6				if DEBUG_SPI_HARD_CE0 
01b6			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b6					ret 
01b6			 
01b6				endif 
01b6			 
01b6			 
01b6 f5				push af 
01b7			 
01b7				; send direct ce to port b 
01b7 3e ff			ld a, 255 
01b9 d3 81			out (storage_bdata), a 
01bb			 
01bb f1				pop af 
01bc			 
01bc				; for port a that shares with spi lines AND the mask 
01bc			  
01bc				if DEBUG_SPI 
01bc					push hl 
01bc					ld h, a 
01bc				endif 
01bc			;	ld c, SPI_CE_HIGH 
01bc			;	and c 
01bc cb c7			set SPI_CE0, a 
01be cb cf			set SPI_CE1, a 
01c0 cb d7			set SPI_CE2, a 
01c2 cb df			set SPI_CE3, a 
01c4 cb e7			set SPI_CE4, a 
01c6			 
01c6				if DEBUG_SPI 
01c6					ld l, a 
01c6					DMARK "CEh" 
01c6					CALLMONITOR 
01c6					pop hl 
01c6				endif 
01c6 c9				ret 
01c7			 
01c7			 
01c7			spi_ce_low: 
01c7			 
01c7				if DEBUG_SPI_HARD_CE0 
01c7			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c7					ret 
01c7			 
01c7				endif 
01c7			 
01c7 c5				push bc 
01c8 f5				push af 
01c9			 
01c9				; send direct ce to port b 
01c9 3a f0 fb			ld a, (spi_cartdev) 
01cc d3 81			out (storage_bdata), a 
01ce			 
01ce			 
01ce			 
01ce				; for port a that shares with spi lines AND the mask 
01ce			 
01ce 3a ed fb			ld a, (spi_device)  
01d1 4f				ld c, a 
01d2			 
01d2 f1				pop af 
01d3			 
01d3				; detect CEx 
01d3			 
01d3				if DEBUG_SPI 
01d3					push hl 
01d3					ld h, a 
01d3				endif 
01d3			 
01d3 cb 41			bit SPI_CE0, c 
01d5 20 04			jr nz, .cel1 
01d7 cb 87			res SPI_CE0, a 
01d9 18 1e			jr .celn 
01db			.cel1: 
01db cb 49			bit SPI_CE1, c 
01dd 20 04			jr nz, .cel2 
01df cb 8f			res SPI_CE1, a 
01e1 18 16			jr .celn 
01e3			.cel2: 
01e3 cb 51			bit SPI_CE2, c 
01e5 20 04			jr nz, .cel3 
01e7 cb 97			res SPI_CE2, a 
01e9 18 0e			jr .celn 
01eb			.cel3: 
01eb cb 59			bit SPI_CE3, c 
01ed 20 04			jr nz, .cel4 
01ef cb 9f			res SPI_CE3, a 
01f1 18 06			jr .celn 
01f3			.cel4: 
01f3 cb 61			bit SPI_CE4, c 
01f5 20 02			jr nz, .celn 
01f7 cb a7			res SPI_CE4, a 
01f9			.celn: 
01f9			 
01f9			 
01f9			 
01f9			;	add c 
01f9			 
01f9				if DEBUG_SPI 
01f9					ld l, a 
01f9					DMARK "CEl" 
01f9					CALLMONITOR 
01f9					pop hl 
01f9				endif 
01f9 c1				pop bc 
01fa c9				ret 
01fb			 
01fb			 
01fb			 
01fb			; eof 
01fb			 
01fb			 
01fb			 
01fb			 
01fb			 
# End of file firmware_spi.asm
01fb				include "firmware_seeprom.asm"  
01fb			; 
01fb			; persisent storage interface via microchip serial eeprom 
01fb			 
01fb			; port a pio 2 
01fb			; pa 7 - si 
01fb			; pa 6 - sclk  
01fb			; pa 5 - so 
01fb			; pa 4 - cs 
01fb			; pa 3 - cs 
01fb			; pa 2 - cs 
01fb			; pa 1 - cs 
01fb			; pa 0 - cs 
01fb			; 
01fb			; TODO get block 
01fb			; TODO save block 
01fb			; TODO load file 
01fb			; TODO save file 
01fb			; TODO get dir  
01fb			 
01fb			;  
01fb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fb			storage_actl: equ Device_C+2     ; device c port a 
01fb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fb			storage_bctl: equ Device_C+3     ; device c port b 
01fb			 
01fb			 
01fb			; TODO move these to hardware driver file 
01fb			 
01fb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fb			; storage bank file system format 
01fb			; 
01fb			; first page of bank: 
01fb			; 	addr 0 - status check 
01fb			;       addr 1 - write protect flag 
01fb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fb			;         TODO see if scanning whole of for available next file id is fast enough 
01fb			;	addr 4 > zero term string of bank label 
01fb			; 
01fb			;        
01fb			;  
01fb			; first page of any file: 
01fb			;      byte 0 - file id  
01fb			;      byte 1-17 - fixed file name  
01fb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fb			; 
01fb			; other pages of any file: 
01fb			;      byte 0 - file id 
01fb			;      byte 1> - file data 
01fb			; 
01fb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fb			;  
01fb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fb			 
01fb			 
01fb			;storage_so_bit: 5 
01fb			;storage_si_bit: 7 
01fb			;storage_sclk_bit: 6 
01fb			  
01fb			 
01fb			; init storage pio 
01fb			 
01fb			storage_init: 
01fb			 
01fb			 
01fb					; set default SPI clk pulse time as disabled 
01fb			 
01fb 3e 00				ld a, 0 
01fd 32 f1 fb				ld (spi_clktime), a 
0200			 
0200					; init hardware 
0200			 
0200 3e cf		            LD   A, 11001111b 
0202 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0204 3e 00		            LD   A, 00000000b 
0206 cb f7			set SPI_DO,a 
0208			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0208 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020a			 
020a 3e cf		            LD   A, 11001111b 
020c d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
020e 3e 00		            LD   A, 00000000b 
0210 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0212			 
0212				; set all external spi devices off  
0212 3e ff			ld a, 255 
0214 32 ed fb			ld (spi_device), a 
0217 32 f0 fb			ld (spi_cartdev), a 
021a			 
021a					; ensure the spi bus is in a default stable state 
021a cd aa 00				call se_stable_spi 
021d			 
021d			; TODO scan spi bus and gather which storage banks are present 
021d			 
021d			; populate store_bank_active  
021d			; for each ce line activate and attempt to write first byte of bank and read back 
021d			; if zero is returned then bank is empty 
021d			;   
021d			; 
021d			 
021d					; init file extent cache to save on slow reads 
021d			 
021d			;	ld hl, store_filecache 
021d			;	ld de, 0 
021d			;	ld hl,(de)	 
021d			 
021d			 
021d c9			    ret 
021e			 
021e			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
021e			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
021e			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
021e			 
021e			; INSTRUCTION SET 
021e			; READ 0000 0011 Read data from memory array beginning at selected address 
021e			; WRITE 0000 0010 Write data to memory array beginning at selected address 
021e			; WREN 0000 0110 Set the write enable latch (enable write operations) 
021e			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
021e			; RDSR 0000 0101 Read STATUS register 
021e			; WRSR 0000 0001 Write STATUS register 
021e			; PE 0100 0010 Page Erase – erase one page in memory array 
021e			; SE 1101 1000 Sector Erase – erase one sector in memory array 
021e			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
021e			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
021e			 
021e			; TODO send byte steam for page without setting the address for every single byte 
021e			; TODO read byte  
021e			 
021e			; byte in a 
021e			; address in hl  
021e			se_writebyte: 
021e			        
021e			    ;   ld c, a 
021e f5			        push af 
021f e5			        push hl 
0220			 
0220			    ; initi write mode 
0220			    ; 
0220			    ;CS low 
0220			 
0220 3a ee fb		       ld a,(spi_portbyte) 
0223 cd c7 01			call spi_ce_low 
0226			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0226 d3 80		       out (storage_adata),a 
0228 32 ee fb		       ld (spi_portbyte), a 
022b			 
022b			    ;clock out wren instruction 
022b			 
022b 3e 06		    ld a, store_wren_ins 
022d cd b5 00		    call spi_send_byte  
0230			 
0230			    ;cs high to enable write latch 
0230			 
0230 3a ee fb		       ld a,(spi_portbyte) 
0233 cd b6 01			call spi_ce_high 
0236			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0236 d3 80		       out (storage_adata),a 
0238 32 ee fb		       ld (spi_portbyte), a 
023b			 
023b 00				nop 
023c			    ; 
023c			    ; intial write data 
023c			    ; 
023c			    ; cs low 
023c			     
023c 3a ee fb		       ld a,(spi_portbyte) 
023f cd c7 01			call spi_ce_low 
0242			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0242 d3 80		       out (storage_adata),a 
0244 32 ee fb		       ld (spi_portbyte), a 
0247			 
0247			    ; clock out write instruction 
0247			     
0247 3e 02		    ld a, store_write_ins  
0249 cd b5 00		    call spi_send_byte  
024c			 
024c			    ; clock out address (depending on address size) 
024c			     
024c e1			    pop hl 
024d 7c			    ld a,h    ; address out msb first 
024e cd b5 00		    call spi_send_byte  
0251 7d			    ld a,l 
0252 cd b5 00		    call spi_send_byte  
0255			 
0255			    ; clock out byte(s) for page 
0255			 
0255 f1			    pop af 
0256 cd b5 00		    call spi_send_byte  
0259			 
0259			    ; end write with ce high 
0259 3a ee fb		       ld a,(spi_portbyte) 
025c			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025c cd b6 01			call spi_ce_high 
025f d3 80		       out (storage_adata),a 
0261 32 ee fb		       ld (spi_portbyte), a 
0264			 
0264				; pause for internal write cycle 
0264 3e 0a			ld a, 10 
0266 cd 77 0c			call aDelayInMS 
0269 c9			    ret 
026a			 
026a			; buffer to write in de 
026a			; address in hl  
026a			se_writepage: 
026a			        
026a			    ;   ld c, a 
026a d5				push de 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a ee fb		       ld a,(spi_portbyte) 
026f cd c7 01			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 ee fb		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd b5 00		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a ee fb		       ld a,(spi_portbyte) 
027f cd b6 01			call spi_ce_high 
0282			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 ee fb		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a ee fb		       ld a,(spi_portbyte) 
028b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028b cd c7 01			call spi_ce_low 
028e d3 80		       out (storage_adata),a 
0290 32 ee fb		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd b5 00		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd b5 00		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd b5 00		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 e1				pop hl 
02a2 06 40			ld b, STORE_BLOCK_PHY 
02a4			.bytewrite: 
02a4			 
02a4 7e				ld a,(hl) 
02a5 e5			    push hl 
02a6 c5				push bc 
02a7 cd b5 00		    call spi_send_byte  
02aa c1				pop bc 
02ab e1				pop hl 
02ac			 
02ac			    ; end write with ce high 
02ac 3a ee fb		       ld a,(spi_portbyte) 
02af cd b6 01			call spi_ce_high 
02b2			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b2 d3 80		       out (storage_adata),a 
02b4 32 ee fb		       ld (spi_portbyte), a 
02b7			 
02b7 23				inc hl 
02b8 10 ea			djnz .bytewrite 
02ba			 
02ba				; pause for internal write cycle 
02ba 3e 64			ld a, 100 
02bc cd 77 0c			call aDelayInMS 
02bf c9			    ret 
02c0			; returns byte in a 
02c0			; address in hl  
02c0			se_readbyte: 
02c0 d5				push de 
02c1 c5				push bc 
02c2			 
02c2			    ;   ld c, a 
02c2 e5			        push hl 
02c3			 
02c3			    ; initi write mode 
02c3			    ; 
02c3			    ;CS low 
02c3			 
02c3 3a ee fb		       ld a,(spi_portbyte) 
02c6 cd c7 01			call spi_ce_low 
02c9			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02c9 d3 80		       out (storage_adata),a 
02cb 32 ee fb		       ld (spi_portbyte), a 
02ce			 
02ce			    ;clock out wren instruction 
02ce			 
02ce 3e 03		    ld a, store_read_ins 
02d0 cd b5 00		    call spi_send_byte  
02d3			 
02d3			 
02d3			    ; clock out address (depending on address size) 
02d3			     
02d3 e1			    pop hl 
02d4 7c			    ld a,h    ; address out msb first 
02d5 cd b5 00		    call spi_send_byte  
02d8 7d			    ld a,l 
02d9 cd b5 00		    call spi_send_byte  
02dc			 
02dc			    ; clock in byte(s) for page 
02dc			 
02dc cd dc 00		    call spi_read_byte  
02df f5				push af 
02e0			 
02e0			    ; end write with ce high 
02e0 3a ee fb		       ld a,(spi_portbyte) 
02e3			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e3 cd b6 01			call spi_ce_high 
02e6 d3 80		       out (storage_adata),a 
02e8 32 ee fb		       ld (spi_portbyte), a 
02eb			 
02eb f1				pop af 
02ec			 
02ec c1				pop bc 
02ed d1				pop de 
02ee			 
02ee c9			    ret 
02ef			 
02ef			if DEBUG_STORESE 
02ef			 
02ef			storageput:  
02ef			 
02ef			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02ef			 
02ef 21 50 f3			ld hl,scratch+2 
02f2 cd 00 13			call get_word_hl 
02f5			 
02f5				; stuff it here for the moment as it will be overwritten later anyway 
02f5			 
02f5 22 71 f6			ld (os_cur_ptr),hl	 
02f8			 
02f8			 
02f8			; get pointer to start of string 
02f8			 
02f8 21 55 f3			ld hl, scratch+7 
02fb			 
02fb			; loop writing char of string to eeprom 
02fb			 
02fb 7e			.writestr:	ld a,(hl) 
02fc fe 00				cp 0 
02fe 28 12				jr z, .wsdone		; done writing 
0300 e5					push hl 
0301 2a 71 f6				ld hl,(os_cur_ptr) 
0304 cd 1e 02				call se_writebyte 
0307			 
0307 2a 71 f6				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030a 23					inc hl 
030b 22 71 f6				ld (os_cur_ptr),hl 
030e			 
030e					; restore string pointer and get next char 
030e			 
030e e1					pop hl 
030f 23					inc hl 
0310 18 e9				jr .writestr 
0312			 
0312			 
0312			 
0312			.wsdone: 
0312			 
0312			 
0312			; when done load first page into a buffer  
0312			 
0312 21 00 80				ld hl,08000h		; start in ram 
0315 22 71 f6				ld (os_cur_ptr),hl 
0318 21 00 00				ld hl, 0		 ; start of page 
031b 22 76 f3				ld (scratch+40),hl	; hang on to it 
031e			 
031e 06 80				ld b, 128		; actually get more then one page 
0320 c5			.wsload:	push bc 
0321 2a 76 f3				ld hl,(scratch+40) 
0324 e5					push hl 
0325 cd c0 02				call se_readbyte 
0328			 
0328					; a now as the byte 
0328			 
0328 2a 71 f6				ld hl,(os_cur_ptr) 
032b 77					ld (hl),a 
032c					; inc next buffer area 
032c 23					inc hl 
032d 22 71 f6				ld (os_cur_ptr),hl 
0330			 
0330					; get eeprom position, inc and save for next round 
0330 e1					pop hl		 
0331 23					inc hl 
0332 22 76 f3				ld (scratch+40),hl 
0335 c1					pop bc 
0336 10 e8				djnz .wsload 
0338			 
0338			; set 'd' pointer to start of buffer 
0338			 
0338 21 00 80				ld hl,08000h 
033b 22 71 f6				ld (os_cur_ptr),hl 
033e			 
033e			 
033e c9			ret 
033f			 
033f			 
033f c9			storageread: ret 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			endif 
0340			 
0340			 
0340			 
# End of file firmware_seeprom.asm
0340			else  
0340			   ; create some stubs for the labels  
0340			se_readbyte: ret  
0340			se_writebyte: ret  
0340			storage_init: ret  
0340			  
0340			endif  
0340			  
0340			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0340			;include "firmware_cf.asm"  
0340			  
0340			; load up high level storage hardward abstractions  
0340			include "firmware_storage.asm"  
0340			 
0340			; persisent storage hardware abstraction layer  
0340			 
0340			 
0340			 
0340			; Block 0 on storage is a config state 
0340			 
0340			 
0340			 
0340			; TODO add read phy block and write phy block functions 
0340			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0340			 
0340			; Abstraction layer  
0340			 
0340			; Logocial block size is same size as physical size - using tape concept 
0340			 
0340			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0340			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0340			 
0340			 
0340			 
0340			; Filesystem layout (Logical layout) 
0340			; 
0340			; Block 0 - Bank config  
0340			; 
0340			;      Byte - 0 file id counter 
0340			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0340			;      Byte - 3-20 zero terminated bank label 
0340			; 
0340			; Block 1 > File storage 
0340			; 
0340			;      Byte 0 file id    - block 0 file details 
0340			;      Byte 1 block id - block 0 is file  
0340			;            Byte 2-15 - File name 
0340			; 
0340			;       - to end of block data 
0340			; 
0340			 
0340			; Get ID for the file named in pointer held HL 
0340			; Returns ID in HL = 255 if no file found 
0340			 
0340			storage_getid: 
0340			 
0340 22 00 fc			ld (store_tmp1), hl 
0343			 
0343				if DEBUG_STORESE 
0343					DMARK "SGI" 
0343 f5				push af  
0344 3a 58 03			ld a, (.dmark)  
0347 32 b4 fe			ld (debug_mark),a  
034a 3a 59 03			ld a, (.dmark+1)  
034d 32 b5 fe			ld (debug_mark+1),a  
0350 3a 5a 03			ld a, (.dmark+2)  
0353 32 b6 fe			ld (debug_mark+2),a  
0356 18 03			jr .pastdmark  
0358 ..			.dmark: db "SGI"  
035b f1			.pastdmark: pop af  
035c			endm  
# End of macro DMARK
035c					CALLMONITOR 
035c cd c6 18			call break_point_state  
035f				endm  
# End of macro CALLMONITOR
035f				endif 
035f				; get block 0 and set counter for number of files to scan 
035f			 
035f cd ca 04			call storage_get_block_0 
0362			 
0362 3a 07 fc			ld a, (store_page) 
0365 47				ld b, a 
0366			 
0366				; get extent 0 of each file id 
0366			 
0366				if DEBUG_STORESE 
0366					DMARK "SGc" 
0366 f5				push af  
0367 3a 7b 03			ld a, (.dmark)  
036a 32 b4 fe			ld (debug_mark),a  
036d 3a 7c 03			ld a, (.dmark+1)  
0370 32 b5 fe			ld (debug_mark+1),a  
0373 3a 7d 03			ld a, (.dmark+2)  
0376 32 b6 fe			ld (debug_mark+2),a  
0379 18 03			jr .pastdmark  
037b ..			.dmark: db "SGc"  
037e f1			.pastdmark: pop af  
037f			endm  
# End of macro DMARK
037f					CALLMONITOR 
037f cd c6 18			call break_point_state  
0382				endm  
# End of macro CALLMONITOR
0382				endif 
0382 60			.getloop:	ld h, b 
0383 2e 00				ld l, 0 
0385 c5					push bc 
0386			 
0386 11 07 fc				ld de, store_page 
0389				if DEBUG_STORESE 
0389					DMARK "SGr" 
0389 f5				push af  
038a 3a 9e 03			ld a, (.dmark)  
038d 32 b4 fe			ld (debug_mark),a  
0390 3a 9f 03			ld a, (.dmark+1)  
0393 32 b5 fe			ld (debug_mark+1),a  
0396 3a a0 03			ld a, (.dmark+2)  
0399 32 b6 fe			ld (debug_mark+2),a  
039c 18 03			jr .pastdmark  
039e ..			.dmark: db "SGr"  
03a1 f1			.pastdmark: pop af  
03a2			endm  
# End of macro DMARK
03a2					CALLMONITOR 
03a2 cd c6 18			call break_point_state  
03a5				endm  
# End of macro CALLMONITOR
03a5				endif 
03a5 cd 72 09				call storage_read 
03a8 cd 72 0f				call ishlzero 
03ab 28 2d				jr z, .gap 
03ad					 
03ad					; have a file name read. Is it one we want. 
03ad			 
03ad 2a 00 fc				ld hl, (store_tmp1) 
03b0 11 0a fc				ld de, store_page+3   ; file name 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 b4 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 b5 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 b6 fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd c6 18			call break_point_state  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf cd df 13				call strcmp 
03d2 20 06				jr nz, .gap   ; not this one 
03d4			 
03d4 c1				        pop bc 
03d5			 
03d5 26 00				ld h, 0 
03d7 68					ld l, b 
03d8 18 22				jr .getdone 
03da						 
03da			 
03da			 
03da			 
03da			.gap: 
03da				if DEBUG_STORESE 
03da					DMARK "SGg" 
03da f5				push af  
03db 3a ef 03			ld a, (.dmark)  
03de 32 b4 fe			ld (debug_mark),a  
03e1 3a f0 03			ld a, (.dmark+1)  
03e4 32 b5 fe			ld (debug_mark+1),a  
03e7 3a f1 03			ld a, (.dmark+2)  
03ea 32 b6 fe			ld (debug_mark+2),a  
03ed 18 03			jr .pastdmark  
03ef ..			.dmark: db "SGg"  
03f2 f1			.pastdmark: pop af  
03f3			endm  
# End of macro DMARK
03f3					CALLMONITOR 
03f3 cd c6 18			call break_point_state  
03f6				endm  
# End of macro CALLMONITOR
03f6				endif 
03f6			 
03f6 c1					pop bc 
03f7 10 89				djnz .getloop 
03f9 21 ff 00				ld hl, 255 
03fc			.getdone: 
03fc			 
03fc				if DEBUG_STORESE 
03fc					DMARK "SGe" 
03fc f5				push af  
03fd 3a 11 04			ld a, (.dmark)  
0400 32 b4 fe			ld (debug_mark),a  
0403 3a 12 04			ld a, (.dmark+1)  
0406 32 b5 fe			ld (debug_mark+1),a  
0409 3a 13 04			ld a, (.dmark+2)  
040c 32 b6 fe			ld (debug_mark+2),a  
040f 18 03			jr .pastdmark  
0411 ..			.dmark: db "SGe"  
0414 f1			.pastdmark: pop af  
0415			endm  
# End of macro DMARK
0415					CALLMONITOR 
0415 cd c6 18			call break_point_state  
0418				endm  
# End of macro CALLMONITOR
0418				endif 
0418			 
0418 c9				ret 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			; Read Block 
0419			; ---------- 
0419			; 
0419			; With current bank 
0419			;  
0419			; Get block number to read 
0419			; Load physical blocks starting at start block into buffer 
0419			 
0419			; de points to buffer to use 
0419			; hl holds logical block number  
0419			 
0419			storage_read_block: 
0419			 
0419				; TODO bank selection 
0419			 
0419				; for each of the physical blocks read it into the buffer 
0419 06 40			ld b, STORE_BLOCK_PHY 
041b			 
041b				if DEBUG_STORESE 
041b d5					push de 
041c				endif 
041c				 
041c			.rl1:    
041c			 
041c				; read physical block at hl into de 
041c			        ; increment hl and de to next read position on exit 
041c			 
041c e5				push hl 
041d d5				push de	 
041e c5				push bc 
041f			;	if DEBUG_STORESE 
041f			;		push af 
041f			;		ld a, 'R' 
041f			;		ld (debug_mark),a 
041f			;		pop af 
041f			;		CALLMONITOR 
041f			;	endif 
041f cd c0 02			call se_readbyte 
0422			;	if DEBUG_STORESE 
0422			;		ld a,(spi_portbyte) 
0422			;		ld l, a 
0422			;		push af 
0422			;		ld a, '1' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 c1				pop bc 
0423 d1				pop de 
0424 e1				pop hl 
0425 12				ld (de),a 
0426 23				inc hl 
0427 13				inc de 
0428			 
0428			;	if DEBUG_STORESE 
0428			;		push af 
0428			;		ld a, 'r' 
0428			;		ld (debug_mark),a 
0428			;		pop af 
0428			;		CALLMONITOR 
0428			;	endif 
0428			 
0428 10 f2			djnz .rl1 
042a			 
042a				if DEBUG_STORESE 
042a					DMARK "SRB" 
042a f5				push af  
042b 3a 3f 04			ld a, (.dmark)  
042e 32 b4 fe			ld (debug_mark),a  
0431 3a 40 04			ld a, (.dmark+1)  
0434 32 b5 fe			ld (debug_mark+1),a  
0437 3a 41 04			ld a, (.dmark+2)  
043a 32 b6 fe			ld (debug_mark+2),a  
043d 18 03			jr .pastdmark  
043f ..			.dmark: db "SRB"  
0442 f1			.pastdmark: pop af  
0443			endm  
# End of macro DMARK
0443 d1					pop de 
0444			; 
0444			;		push af 
0444			;		ld a, 'R' 
0444			;		ld (debug_mark),a 
0444			;		pop af 
0444					CALLMONITOR 
0444 cd c6 18			call break_point_state  
0447				endm  
# End of macro CALLMONITOR
0447				endif 
0447 c9				ret	 
0448				 
0448			 
0448			; File Size 
0448			; --------- 
0448			; 
0448			;   hl file id 
0448			; 
0448			;  returns in hl the number of blocks 
0448			 
0448			storage_file_size: 
0448 5d				ld e, l 
0449 16 00			ld d, 0 
044b 21 40 00			ld hl, STORE_BLOCK_PHY 
044e					if DEBUG_FORTH_WORDS 
044e						DMARK "SIZ" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 b4 fe			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 b5 fe			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 b6 fe			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "SIZ"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467						CALLMONITOR 
0467 cd c6 18			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a					endif 
046a cd 4c 07			call storage_findnextid 
046d			 
046d cd 72 0f			call ishlzero 
0470			;	ld a, l 
0470			;	add h 
0470			;	cp 0 
0470 c8				ret z			; block not found so EOF 
0471			 
0471 11 07 fc			ld de, store_page 
0474 cd 19 04			call storage_read_block 
0477			 
0477 3a 09 fc			ld a, (store_page+2)	 ; get extent count 
047a 6f				ld l, a 
047b 26 00			ld h, 0 
047d c9			 	ret 
047e			 
047e			 
047e			; Write Block 
047e			; ----------- 
047e			; 
047e			; With current bank 
047e			;  
047e			; Get block number to write 
047e			; Write physical blocks starting at start block from buffer 
047e			  
047e			storage_write_block: 
047e				; TODO bank selection 
047e			 
047e				; for each of the physical blocks read it into the buffer 
047e 06 40			ld b, STORE_BLOCK_PHY 
0480			 
0480				if DEBUG_STORESE 
0480					DMARK "SWB" 
0480 f5				push af  
0481 3a 95 04			ld a, (.dmark)  
0484 32 b4 fe			ld (debug_mark),a  
0487 3a 96 04			ld a, (.dmark+1)  
048a 32 b5 fe			ld (debug_mark+1),a  
048d 3a 97 04			ld a, (.dmark+2)  
0490 32 b6 fe			ld (debug_mark+2),a  
0493 18 03			jr .pastdmark  
0495 ..			.dmark: db "SWB"  
0498 f1			.pastdmark: pop af  
0499			endm  
# End of macro DMARK
0499			 
0499					;push af 
0499					;ld a, 'W' 
0499					;ld (debug_mark),a 
0499					;pop af 
0499					CALLMONITOR 
0499 cd c6 18			call break_point_state  
049c				endm  
# End of macro CALLMONITOR
049c				endif 
049c			 
049c			; might not be working 
049c			;	call se_writepage 
049c			 
049c			;	ret 
049c			; 
049c			 
049c			 
049c			 
049c			.wl1:    
049c			 
049c				; read physical block at hl into de 
049c			        ; increment hl and de to next read position on exit 
049c			 
049c e5				push hl 
049d d5				push de	 
049e c5				push bc 
049f 1a				ld a,(de) 
04a0				;if DEBUG_STORESE 
04a0			;		push af 
04a0			;		ld a, 'W' 
04a0			;		ld (debug_mark),a 
04a0			;		pop af 
04a0			;		CALLMONITOR 
04a0			;	endif 
04a0 cd 1e 02			call se_writebyte 
04a3			;	call delay250ms 
04a3 00				nop 
04a4 00				nop 
04a5 00				nop 
04a6			;	if DEBUG_STORESE 
04a6			;		push af 
04a6			;		ld a, 'w' 
04a6			;		ld (debug_mark),a 
04a6			;		pop af 
04a6			;		CALLMONITOR 
04a6			;	endif 
04a6 c1				pop bc 
04a7 d1				pop de 
04a8 e1				pop hl 
04a9 23				inc hl 
04aa 13				inc de 
04ab			 
04ab			 
04ab 10 ef			djnz .wl1 
04ad			 
04ad				if DEBUG_STORESE 
04ad					DMARK "SW2" 
04ad f5				push af  
04ae 3a c2 04			ld a, (.dmark)  
04b1 32 b4 fe			ld (debug_mark),a  
04b4 3a c3 04			ld a, (.dmark+1)  
04b7 32 b5 fe			ld (debug_mark+1),a  
04ba 3a c4 04			ld a, (.dmark+2)  
04bd 32 b6 fe			ld (debug_mark+2),a  
04c0 18 03			jr .pastdmark  
04c2 ..			.dmark: db "SW2"  
04c5 f1			.pastdmark: pop af  
04c6			endm  
# End of macro DMARK
04c6			 
04c6					;push af 
04c6					;ld a, 'W' 
04c6					;ld (debug_mark),a 
04c6					;pop af 
04c6					CALLMONITOR 
04c6 cd c6 18			call break_point_state  
04c9				endm  
# End of macro CALLMONITOR
04c9				endif 
04c9 c9				ret	 
04ca			 
04ca			; Init bank 
04ca			; --------- 
04ca			; 
04ca			; With current bank 
04ca			; 
04ca			; Setup block 0 config 
04ca			;     Set 0 file id counter 
04ca			;     Set formatted byte pattern 
04ca			;     Zero out bank label 
04ca			;      
04ca			; For every logical block write 0-1 byte as null 
04ca			 
04ca			storage_get_block_0: 
04ca			 
04ca				; TODO check presence 
04ca			 
04ca				; get block 0 config 
04ca			 
04ca 21 00 00			ld hl, 0 
04cd 11 07 fc			ld de, store_page 
04d0 cd 19 04			call storage_read_block 
04d3			 
04d3				if DEBUG_STORESE 
04d3					DMARK "SB0" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 b4 fe			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 b5 fe			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 b6 fe			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "SB0"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec 11 07 fc				ld de, store_page 
04ef			;		push af 
04ef			;		ld a, 'i' 
04ef			;		ld (debug_mark),a 
04ef			;		pop af 
04ef					CALLMONITOR 
04ef cd c6 18			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2				; is this area formatted? 
04f2			 
04f2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f2 2a 08 fc			ld hl, (store_page+1) 
04f5 3e 80			ld a,0x80 
04f7 bd				cp l 
04f8 20 22			jr nz, .ininotformatted 
04fa				; do a double check 
04fa 3e 27			ld a, 0x27 
04fc bc				cp h 
04fd 20 1d			jr nz, .ininotformatted 
04ff			 
04ff				; formatted then 
04ff			 
04ff				if DEBUG_STORESE 
04ff					DMARK "SB1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 b4 fe			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 b5 fe			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 b6 fe			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "SB1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518					;push af 
0518					;ld a, 'I' 
0518					;ld (debug_mark),a 
0518					;pop af 
0518					CALLMONITOR 
0518 cd c6 18			call break_point_state  
051b				endm  
# End of macro CALLMONITOR
051b				endif 
051b c9				ret 
051c			 
051c			.ininotformatted: 
051c				; bank not formatted so poke various bits to make sure 
051c			 
051c				if DEBUG_STORESE 
051c					DMARK "SB2" 
051c f5				push af  
051d 3a 31 05			ld a, (.dmark)  
0520 32 b4 fe			ld (debug_mark),a  
0523 3a 32 05			ld a, (.dmark+1)  
0526 32 b5 fe			ld (debug_mark+1),a  
0529 3a 33 05			ld a, (.dmark+2)  
052c 32 b6 fe			ld (debug_mark+2),a  
052f 18 03			jr .pastdmark  
0531 ..			.dmark: db "SB2"  
0534 f1			.pastdmark: pop af  
0535			endm  
# End of macro DMARK
0535					;push af 
0535					;ld a, 'f' 
0535					;ld (debug_mark),a 
0535					;pop af 
0535					CALLMONITOR 
0535 cd c6 18			call break_point_state  
0538				endm  
# End of macro CALLMONITOR
0538				endif 
0538			 
0538 cd 55 0c			call storage_clear_page 
053b			 
053b 21 07 fc			ld hl, store_page 
053e 3e 00			ld a, 0 
0540				 
0540 77				ld (hl),a   ; reset file counter 
0541			 
0541 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0544 22 08 fc		 	ld (store_page+1), hl	 
0547			 
0547				; set default label 
0547			 
0547 21 e3 05			ld hl, .defaultbanklabl 
054a 11 0a fc		 	ld de, store_page+3 
054d 01 0f 00			ld bc, 15 
0550 ed b0			ldir 
0552			 
0552				; Append the current bank id 
0552 21 13 fc			ld hl, store_page+3+9 
0555 3a ec fb			ld a, (spi_device_id) 
0558 77				ld (hl), a 
0559			 
0559				; save default page 0 
0559			 
0559 21 00 00			ld hl, 0 
055c 11 07 fc			ld de, store_page 
055f				if DEBUG_STORESE 
055f					DMARK "SB3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 b4 fe			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 b5 fe			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 b6 fe			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "SB3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578			;		push af 
0578			;		ld a, 'F' 
0578			;		ld (debug_mark),a 
0578			;		pop af 
0578					CALLMONITOR 
0578 cd c6 18			call break_point_state  
057b				endm  
# End of macro CALLMONITOR
057b				endif 
057b cd 7e 04			call storage_write_block 
057e				if DEBUG_STORESE 
057e					DMARK "SB4" 
057e f5				push af  
057f 3a 93 05			ld a, (.dmark)  
0582 32 b4 fe			ld (debug_mark),a  
0585 3a 94 05			ld a, (.dmark+1)  
0588 32 b5 fe			ld (debug_mark+1),a  
058b 3a 95 05			ld a, (.dmark+2)  
058e 32 b6 fe			ld (debug_mark+2),a  
0591 18 03			jr .pastdmark  
0593 ..			.dmark: db "SB4"  
0596 f1			.pastdmark: pop af  
0597			endm  
# End of macro DMARK
0597			;		push af 
0597			;		ld a, '>' 
0597			;		ld (debug_mark),a 
0597			;		pop af 
0597					CALLMONITOR 
0597 cd c6 18			call break_point_state  
059a				endm  
# End of macro CALLMONITOR
059a				endif 
059a			 
059a 00				nop 
059b 00				nop 
059c 00				nop 
059d			 
059d				; now set 0 in every page to mark as a free block 
059d			 
059d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
059f 21 40 00			ld hl, STORE_BLOCK_PHY 
05a2			 
05a2 3e 00		.setmark1:   	ld a,0 
05a4 e5					push hl 
05a5 c5					push bc 
05a6 cd 1e 02				call se_writebyte 
05a9 3e 0a			ld a, 10 
05ab cd 77 0c			call aDelayInMS 
05ae 23				inc hl 
05af cd 1e 02				call se_writebyte 
05b2 3e 0a			ld a, 10 
05b4 cd 77 0c			call aDelayInMS 
05b7 2b				dec hl 
05b8 c1					pop bc 
05b9 e1					pop hl 
05ba 3e 40				ld a, STORE_BLOCK_PHY 
05bc cd 49 0f				call addatohl 
05bf 10 e1				djnz .setmark1 
05c1			 
05c1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c3 3e 00		.setmark2:   	ld a,0 
05c5 e5					push hl 
05c6 c5					push bc 
05c7 cd 1e 02				call se_writebyte 
05ca 3e 0a			ld a, 10 
05cc cd 77 0c			call aDelayInMS 
05cf 23				inc hl 
05d0 cd 1e 02				call se_writebyte 
05d3 3e 0a			ld a, 10 
05d5 cd 77 0c			call aDelayInMS 
05d8 2b				dec hl 
05d9 c1					pop bc 
05da e1					pop hl 
05db 3e 40				ld a, STORE_BLOCK_PHY 
05dd cd 49 0f				call addatohl 
05e0 10 e1				djnz .setmark2 
05e2			 
05e2					 
05e2			 
05e2			 
05e2 c9				ret 
05e3			 
05e3			 
05e3			 
05e3			 
05e3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05ee			 
05ee			 
05ee			 
05ee			; Label Bank 
05ee			; ---------- 
05ee			; 
05ee			; With current bank 
05ee			; Read block 0 
05ee			; Set label 
05ee			; Write block 0 
05ee			 
05ee			; label str pointer in hl 
05ee			 
05ee			storage_label:     
05ee			 
05ee				if DEBUG_STORESE 
05ee					DMARK "LBL" 
05ee f5				push af  
05ef 3a 03 06			ld a, (.dmark)  
05f2 32 b4 fe			ld (debug_mark),a  
05f5 3a 04 06			ld a, (.dmark+1)  
05f8 32 b5 fe			ld (debug_mark+1),a  
05fb 3a 05 06			ld a, (.dmark+2)  
05fe 32 b6 fe			ld (debug_mark+2),a  
0601 18 03			jr .pastdmark  
0603 ..			.dmark: db "LBL"  
0606 f1			.pastdmark: pop af  
0607			endm  
# End of macro DMARK
0607					CALLMONITOR 
0607 cd c6 18			call break_point_state  
060a				endm  
# End of macro CALLMONITOR
060a				endif 
060a			 
060a e5				push hl 
060b			 
060b cd ca 04			call storage_get_block_0 
060e			 
060e				; set default label 
060e			 
060e e1				pop hl 
060f			 
060f 11 0a fc		 	ld de, store_page+3 
0612 01 0f 00			ld bc, 15 
0615				if DEBUG_STORESE 
0615					DMARK "LB3" 
0615 f5				push af  
0616 3a 2a 06			ld a, (.dmark)  
0619 32 b4 fe			ld (debug_mark),a  
061c 3a 2b 06			ld a, (.dmark+1)  
061f 32 b5 fe			ld (debug_mark+1),a  
0622 3a 2c 06			ld a, (.dmark+2)  
0625 32 b6 fe			ld (debug_mark+2),a  
0628 18 03			jr .pastdmark  
062a ..			.dmark: db "LB3"  
062d f1			.pastdmark: pop af  
062e			endm  
# End of macro DMARK
062e					CALLMONITOR 
062e cd c6 18			call break_point_state  
0631				endm  
# End of macro CALLMONITOR
0631				endif 
0631 ed b0			ldir 
0633				; save default page 0 
0633			 
0633 21 00 00			ld hl, 0 
0636 11 07 fc			ld de, store_page 
0639				if DEBUG_STORESE 
0639					DMARK "LBW" 
0639 f5				push af  
063a 3a 4e 06			ld a, (.dmark)  
063d 32 b4 fe			ld (debug_mark),a  
0640 3a 4f 06			ld a, (.dmark+1)  
0643 32 b5 fe			ld (debug_mark+1),a  
0646 3a 50 06			ld a, (.dmark+2)  
0649 32 b6 fe			ld (debug_mark+2),a  
064c 18 03			jr .pastdmark  
064e ..			.dmark: db "LBW"  
0651 f1			.pastdmark: pop af  
0652			endm  
# End of macro DMARK
0652					CALLMONITOR 
0652 cd c6 18			call break_point_state  
0655				endm  
# End of macro CALLMONITOR
0655				endif 
0655 cd 7e 04			call storage_write_block 
0658			 
0658 c9				ret 
0659			 
0659			 
0659			 
0659			; Read Block 0 - Config 
0659			; --------------------- 
0659			; 
0659			; With current bank 
0659			; Call presence test 
0659			;    If not present format/init bank  
0659			; Read block 0  
0659			;  
0659			 
0659			 
0659			; Dir 
0659			; --- 
0659			; 
0659			; With current bank 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block read byte 2 
0659			;      if first block of file 
0659			;         Display file name 
0659			;         Display type flags for file 
0659			;        
0659			 
0659			; moving to words as this requires stack control 
0659			 
0659			 
0659			; Delete File 
0659			; ----------- 
0659			; 
0659			; With current bank 
0659			; 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block file id 
0659			;      If first block of file and dont have file id 
0659			;         if file to delete 
0659			;         Save file id 
0659			;         Null file id 
0659			;         Write this block back 
0659			;      If file id is one saved 
0659			;         Null file id 
0659			;         Write this block back 
0659			 
0659			 
0659			.se_done: 
0659 e1				pop hl 
065a c9				ret 
065b			 
065b			storage_erase: 
065b			 
065b				; hl contains the file id 
065b			 
065b 5d				ld e, l 
065c 16 00			ld d, 0 
065e 21 40 00			ld hl, STORE_BLOCK_PHY 
0661					if DEBUG_FORTH_WORDS 
0661						DMARK "ERA" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 b4 fe			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 b5 fe			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 b6 fe			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "ERA"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a						CALLMONITOR 
067a cd c6 18			call break_point_state  
067d				endm  
# End of macro CALLMONITOR
067d					endif 
067d cd 4c 07			call storage_findnextid 
0680 cd 72 0f			call ishlzero 
0683 c8				ret z 
0684			 
0684 e5				push hl 
0685			 
0685				; TODO check file not found 
0685			 
0685 11 07 fc			ld de, store_page 
0688 cd 19 04			call storage_read_block 
068b			 
068b cd 72 0f			call ishlzero 
068e ca 59 06			jp z,.se_done 
0691			 
0691					if DEBUG_FORTH_WORDS 
0691						DMARK "ER1" 
0691 f5				push af  
0692 3a a6 06			ld a, (.dmark)  
0695 32 b4 fe			ld (debug_mark),a  
0698 3a a7 06			ld a, (.dmark+1)  
069b 32 b5 fe			ld (debug_mark+1),a  
069e 3a a8 06			ld a, (.dmark+2)  
06a1 32 b6 fe			ld (debug_mark+2),a  
06a4 18 03			jr .pastdmark  
06a6 ..			.dmark: db "ER1"  
06a9 f1			.pastdmark: pop af  
06aa			endm  
# End of macro DMARK
06aa						CALLMONITOR 
06aa cd c6 18			call break_point_state  
06ad				endm  
# End of macro CALLMONITOR
06ad					endif 
06ad 3a 07 fc			ld a, (store_page)	; get file id 
06b0 32 fb fb			ld (store_tmpid), a 
06b3			 
06b3 3a 09 fc			ld a, (store_page+2)    ; get count of extends 
06b6 32 fa fb			ld (store_tmpext), a 
06b9			 
06b9				; wipe file header 
06b9			 
06b9 e1				pop hl 
06ba 3e 00			ld a, 0 
06bc 32 07 fc			ld (store_page), a 
06bf 32 08 fc			ld (store_page+1),a 
06c2 11 07 fc			ld de, store_page 
06c5					if DEBUG_FORTH_WORDS 
06c5						DMARK "ER2" 
06c5 f5				push af  
06c6 3a da 06			ld a, (.dmark)  
06c9 32 b4 fe			ld (debug_mark),a  
06cc 3a db 06			ld a, (.dmark+1)  
06cf 32 b5 fe			ld (debug_mark+1),a  
06d2 3a dc 06			ld a, (.dmark+2)  
06d5 32 b6 fe			ld (debug_mark+2),a  
06d8 18 03			jr .pastdmark  
06da ..			.dmark: db "ER2"  
06dd f1			.pastdmark: pop af  
06de			endm  
# End of macro DMARK
06de						CALLMONITOR 
06de cd c6 18			call break_point_state  
06e1				endm  
# End of macro CALLMONITOR
06e1					endif 
06e1 cd 7e 04			call storage_write_block 
06e4			 
06e4			 
06e4				; wipe file extents 
06e4			 
06e4 3a fa fb			ld a, (store_tmpext) 
06e7 47				ld b, a 
06e8			 
06e8			.eraext:	  
06e8 c5				push bc 
06e9			 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 3a fb fb			ld a,(store_tmpid) 
06ef 5f				ld e, a 
06f0 50				ld d, b	 
06f1					if DEBUG_FORTH_WORDS 
06f1						DMARK "ER3" 
06f1 f5				push af  
06f2 3a 06 07			ld a, (.dmark)  
06f5 32 b4 fe			ld (debug_mark),a  
06f8 3a 07 07			ld a, (.dmark+1)  
06fb 32 b5 fe			ld (debug_mark+1),a  
06fe 3a 08 07			ld a, (.dmark+2)  
0701 32 b6 fe			ld (debug_mark+2),a  
0704 18 03			jr .pastdmark  
0706 ..			.dmark: db "ER3"  
0709 f1			.pastdmark: pop af  
070a			endm  
# End of macro DMARK
070a						CALLMONITOR 
070a cd c6 18			call break_point_state  
070d				endm  
# End of macro CALLMONITOR
070d					endif 
070d cd 4c 07			call storage_findnextid 
0710 cd 72 0f			call ishlzero 
0713 ca 59 06			jp z,.se_done 
0716			 
0716 e5				push hl 
0717 11 07 fc			ld de, store_page 
071a cd 19 04			call storage_read_block 
071d			 
071d				; free block	 
071d			 
071d 3e 00			ld a, 0 
071f 32 07 fc			ld (store_page), a 
0722 32 08 fc			ld (store_page+1),a 
0725 11 07 fc			ld de, store_page 
0728 e1				pop hl 
0729					if DEBUG_FORTH_WORDS 
0729						DMARK "ER4" 
0729 f5				push af  
072a 3a 3e 07			ld a, (.dmark)  
072d 32 b4 fe			ld (debug_mark),a  
0730 3a 3f 07			ld a, (.dmark+1)  
0733 32 b5 fe			ld (debug_mark+1),a  
0736 3a 40 07			ld a, (.dmark+2)  
0739 32 b6 fe			ld (debug_mark+2),a  
073c 18 03			jr .pastdmark  
073e ..			.dmark: db "ER4"  
0741 f1			.pastdmark: pop af  
0742			endm  
# End of macro DMARK
0742						CALLMONITOR 
0742 cd c6 18			call break_point_state  
0745				endm  
# End of macro CALLMONITOR
0745					endif 
0745 cd 7e 04			call storage_write_block 
0748			 
0748 c1				pop bc 
0749 10 9d			djnz .eraext 
074b			 
074b c9				ret 
074c			 
074c			 
074c			; Find Free Block 
074c			; --------------- 
074c			; 
074c			; With current bank 
074c			;  
074c			; From given starting logical block 
074c			;    Read block  
074c			;    If no file id 
074c			;         Return block id 
074c			 
074c			 
074c			; hl starting page number 
074c			; hl contains free page number or zero if no pages free 
074c			; e contains the file id to locate 
074c			; d contains the block number 
074c			 
074c			; TODO change to find file id and use zero for free block 
074c			 
074c			storage_findnextid: 
074c			 
074c				; now locate first 0 page to mark as a free block 
074c			 
074c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
074e			;	ld hl, STORE_BLOCK_PHY 
074e			 
074e					if DEBUG_FORTH_WORDS 
074e					DMARK "FNI" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 b4 fe			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 b5 fe			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 b6 fe			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "FNI"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767						CALLMONITOR 
0767 cd c6 18			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a					endif 
076a			.ff1:   	 
076a e5					push hl 
076b c5					push bc 
076c d5					push de 
076d cd c0 02				call se_readbyte 
0770 5f					ld e,a 
0771 23					inc hl 
0772 cd c0 02				call se_readbyte 
0775 57					ld d, a 
0776 e1					pop hl 
0777 e5					push hl 
0778 cd 67 0f				call cmp16 
077b 28 49				jr z, .fffound 
077d			 
077d d1					pop de 
077e c1					pop bc 
077f e1					pop hl 
0780			 
0780					; is found? 
0780					;cp e 
0780					;ret z 
0780			 
0780 3e 40				ld a, STORE_BLOCK_PHY 
0782 cd 49 0f				call addatohl 
0785 10 e3				djnz .ff1 
0787			 
0787 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0789			.ff2:   	 
0789			 
0789 e5					push hl 
078a c5					push bc 
078b d5					push de 
078c cd c0 02				call se_readbyte 
078f 5f					ld e,a 
0790 23					inc hl 
0791 cd c0 02				call se_readbyte 
0794 57					ld d, a 
0795			 
0795 e1					pop hl 
0796 e5					push hl 
0797 cd 67 0f				call cmp16 
079a 28 2a				jr z, .fffound 
079c			 
079c d1					pop de 
079d c1					pop bc 
079e e1					pop hl 
079f					; is found? 
079f					;cp e 
079f					;ret z 
079f			 
079f 3e 40				ld a, STORE_BLOCK_PHY 
07a1 cd 49 0f				call addatohl 
07a4 10 e3				djnz .ff2 
07a6			 
07a6			 
07a6					if DEBUG_FORTH_WORDS 
07a6					DMARK "FN-" 
07a6 f5				push af  
07a7 3a bb 07			ld a, (.dmark)  
07aa 32 b4 fe			ld (debug_mark),a  
07ad 3a bc 07			ld a, (.dmark+1)  
07b0 32 b5 fe			ld (debug_mark+1),a  
07b3 3a bd 07			ld a, (.dmark+2)  
07b6 32 b6 fe			ld (debug_mark+2),a  
07b9 18 03			jr .pastdmark  
07bb ..			.dmark: db "FN-"  
07be f1			.pastdmark: pop af  
07bf			endm  
# End of macro DMARK
07bf					;	push af 
07bf					;	ld a, 'n' 
07bf					;	ld (debug_mark),a 
07bf					;	pop af 
07bf						CALLMONITOR 
07bf cd c6 18			call break_point_state  
07c2				endm  
# End of macro CALLMONITOR
07c2					endif 
07c2				; no free marks! 
07c2 21 00 00				ld hl, 0 
07c5 c9				ret 
07c6			.fffound: 
07c6				 
07c6			 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9					if DEBUG_FORTH_WORDS 
07c9					DMARK "FNF" 
07c9 f5				push af  
07ca 3a de 07			ld a, (.dmark)  
07cd 32 b4 fe			ld (debug_mark),a  
07d0 3a df 07			ld a, (.dmark+1)  
07d3 32 b5 fe			ld (debug_mark+1),a  
07d6 3a e0 07			ld a, (.dmark+2)  
07d9 32 b6 fe			ld (debug_mark+2),a  
07dc 18 03			jr .pastdmark  
07de ..			.dmark: db "FNF"  
07e1 f1			.pastdmark: pop af  
07e2			endm  
# End of macro DMARK
07e2					;	push af 
07e2					;	ld a, 'n' 
07e2					;	ld (debug_mark),a 
07e2					;	pop af 
07e2						CALLMONITOR 
07e2 cd c6 18			call break_point_state  
07e5				endm  
# End of macro CALLMONITOR
07e5					endif 
07e5 c9				ret 
07e6			 
07e6			 
07e6			 
07e6			; Free Space 
07e6			; ---------- 
07e6			; 
07e6			; With current bank 
07e6			; 
07e6			; Set block count to zero 
07e6			; Starting with first logical block 
07e6			;      Find free block  
07e6			;      If block id given, increment block count 
07e6			; 
07e6			;  
07e6			 
07e6			 
07e6			; hl contains count of free blocks 
07e6			 
07e6			storage_freeblocks: 
07e6			 
07e6				; now locate first 0 page to mark as a free block 
07e6			 
07e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e8 21 40 00			ld hl, STORE_BLOCK_PHY 
07eb 11 00 00			ld de, 0 
07ee			 
07ee			.fb1:   	 
07ee e5					push hl 
07ef c5					push bc 
07f0 d5					push de 
07f1 cd c0 02				call se_readbyte 
07f4 d1					pop de 
07f5 c1					pop bc 
07f6 e1					pop hl 
07f7			 
07f7					; is free? 
07f7 fe 00				cp 0 
07f9 20 01				jr nz, .ff1cont 
07fb 13					inc de 
07fc			 
07fc			.ff1cont: 
07fc			 
07fc			 
07fc 3e 40				ld a, STORE_BLOCK_PHY 
07fe cd 49 0f				call addatohl 
0801 10 eb				djnz .fb1 
0803			 
0803 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0805			.fb2:   	 
0805 e5					push hl 
0806 c5					push bc 
0807 d5					push de 
0808 cd c0 02				call se_readbyte 
080b d1					pop de 
080c c1					pop bc 
080d e1					pop hl 
080e			 
080e					; is free? 
080e fe 00				cp 0 
0810 20 01				jr nz, .ff2cont 
0812 13					inc de 
0813			 
0813			.ff2cont: 
0813			 
0813 3e 40				ld a, STORE_BLOCK_PHY 
0815 cd 49 0f				call addatohl 
0818 10 eb				djnz .fb2 
081a			 
081a eb				ex de, hl 
081b c9				ret 
081c			 
081c			; Get File ID 
081c			; ----------- 
081c			; 
081c			; With current bank 
081c			;  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; For each logical block 
081c			;    Read block file id 
081c			;      If first block of file and dont have file id 
081c			;         if file get id and exit 
081c			 
081c			 
081c			 
081c			 
081c			; Create File 
081c			; ----------- 
081c			; 
081c			; With current bank  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; Increment file id number 
081c			; Save Config 
081c			; Find free block 
081c			; Set buffer with file name and file id 
081c			; Write buffer to free block  
081c			 
081c			 
081c			; hl point to file name 
081c			; hl returns file id 
081c			 
081c			; file format: 
081c			; byte 0 - file id 
081c			; byte 1 - extent number 
081c			; byte 2-> data 
081c			 
081c			; format for extent number 0: 
081c			; 
081c			; byte 0 - file id 
081c			; byte 1 - extent 0 
081c			; byte 2 - extent count 
081c			; byte 3 -> file name and meta data 
081c			 
081c			 
081c			storage_create: 
081c				if DEBUG_STORESE 
081c					DMARK "SCR" 
081c f5				push af  
081d 3a 31 08			ld a, (.dmark)  
0820 32 b4 fe			ld (debug_mark),a  
0823 3a 32 08			ld a, (.dmark+1)  
0826 32 b5 fe			ld (debug_mark+1),a  
0829 3a 33 08			ld a, (.dmark+2)  
082c 32 b6 fe			ld (debug_mark+2),a  
082f 18 03			jr .pastdmark  
0831 ..			.dmark: db "SCR"  
0834 f1			.pastdmark: pop af  
0835			endm  
# End of macro DMARK
0835					CALLMONITOR 
0835 cd c6 18			call break_point_state  
0838				endm  
# End of macro CALLMONITOR
0838				endif 
0838			 
0838 e5				push hl		; save file name pointer 
0839			 
0839 cd ca 04			call storage_get_block_0 
083c			 
083c 3a 07 fc			ld a,(store_page)	; get current file id 
083f 3c				inc a 
0840 32 07 fc			ld (store_page),a 
0843				 
0843 32 fb fb			ld (store_tmpid),a			; save id 
0846			 
0846 21 00 00			ld hl, 0 
0849 11 07 fc			ld de, store_page 
084c				if DEBUG_STORESE 
084c					DMARK "SCw" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 b4 fe			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 b5 fe			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 b6 fe			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SCw"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd c6 18			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 7e 04			call storage_write_block	 ; save update 
086b			 
086b				if DEBUG_STORESE 
086b 11 07 fc				ld de, store_page 
086e					DMARK "SCC" 
086e f5				push af  
086f 3a 83 08			ld a, (.dmark)  
0872 32 b4 fe			ld (debug_mark),a  
0875 3a 84 08			ld a, (.dmark+1)  
0878 32 b5 fe			ld (debug_mark+1),a  
087b 3a 85 08			ld a, (.dmark+2)  
087e 32 b6 fe			ld (debug_mark+2),a  
0881 18 03			jr .pastdmark  
0883 ..			.dmark: db "SCC"  
0886 f1			.pastdmark: pop af  
0887			endm  
# End of macro DMARK
0887					CALLMONITOR 
0887 cd c6 18			call break_point_state  
088a				endm  
# End of macro CALLMONITOR
088a				endif 
088a				;  
088a				 
088a 21 40 00			ld hl, STORE_BLOCK_PHY 
088d 11 00 00			ld de, 0 
0890 cd 4c 07			call storage_findnextid 
0893			 
0893 22 f2 fb			ld (store_tmppageid), hl    ; save page to use  
0896			 
0896				; TODO detect 0 = no spare blocks 
0896			 
0896				; hl now contains the free page to use for the file header page 
0896			 
0896				if DEBUG_STORESE 
0896				DMARK "SCF" 
0896 f5				push af  
0897 3a ab 08			ld a, (.dmark)  
089a 32 b4 fe			ld (debug_mark),a  
089d 3a ac 08			ld a, (.dmark+1)  
08a0 32 b5 fe			ld (debug_mark+1),a  
08a3 3a ad 08			ld a, (.dmark+2)  
08a6 32 b6 fe			ld (debug_mark+2),a  
08a9 18 03			jr .pastdmark  
08ab ..			.dmark: db "SCF"  
08ae f1			.pastdmark: pop af  
08af			endm  
# End of macro DMARK
08af					CALLMONITOR 
08af cd c6 18			call break_point_state  
08b2				endm  
# End of macro CALLMONITOR
08b2				endif 
08b2			 
08b2 22 f2 fb			ld (store_tmppageid), hl 
08b5				 
08b5 3a fb fb			ld a,(store_tmpid)    ; get file id 
08b8			;	ld a, (store_filecache)			; save to cache 
08b8			 
08b8 32 07 fc			ld (store_page),a    ; set page id 
08bb 3e 00			ld a, 0			 ; extent 0 is file header 
08bd 32 08 fc			ld (store_page+1), a   ; set file extent 
08c0			 
08c0 32 09 fc			ld (store_page+2), a   ; extent count for the file 
08c3			 
08c3			;	inc hl 		; init block 0 of file 
08c3			;	inc hl   		; skip file and extent id 
08c3			 ;       ld a, 0 
08c3			;	ld (hl),a 
08c3			;	ld a, (store_filecache+1)  	; save to cache 
08c3			 
08c3			;	inc hl    ; file name 
08c3				 
08c3				 
08c3 11 0a fc			ld de, store_page+3    ; get buffer for term string to use as file name 
08c6				if DEBUG_STORESE 
08c6					DMARK "SCc" 
08c6 f5				push af  
08c7 3a db 08			ld a, (.dmark)  
08ca 32 b4 fe			ld (debug_mark),a  
08cd 3a dc 08			ld a, (.dmark+1)  
08d0 32 b5 fe			ld (debug_mark+1),a  
08d3 3a dd 08			ld a, (.dmark+2)  
08d6 32 b6 fe			ld (debug_mark+2),a  
08d9 18 03			jr .pastdmark  
08db ..			.dmark: db "SCc"  
08de f1			.pastdmark: pop af  
08df			endm  
# End of macro DMARK
08df					CALLMONITOR 
08df cd c6 18			call break_point_state  
08e2				endm  
# End of macro CALLMONITOR
08e2				endif 
08e2 e1				pop hl    ; get zero term string 
08e3 e5				push hl 
08e4 3e 00			ld a, 0 
08e6 cd b2 13			call strlent 
08e9 23				inc hl   ; cover zero term 
08ea 06 00			ld b,0 
08ec 4d				ld c,l 
08ed e1				pop hl 
08ee				;ex de, hl 
08ee				if DEBUG_STORESE 
08ee					DMARK "SCa" 
08ee f5				push af  
08ef 3a 03 09			ld a, (.dmark)  
08f2 32 b4 fe			ld (debug_mark),a  
08f5 3a 04 09			ld a, (.dmark+1)  
08f8 32 b5 fe			ld (debug_mark+1),a  
08fb 3a 05 09			ld a, (.dmark+2)  
08fe 32 b6 fe			ld (debug_mark+2),a  
0901 18 03			jr .pastdmark  
0903 ..			.dmark: db "SCa"  
0906 f1			.pastdmark: pop af  
0907			endm  
# End of macro DMARK
0907					;push af 
0907					;ld a, 'a' 
0907					;ld (debug_mark),a 
0907					;pop af 
0907					CALLMONITOR 
0907 cd c6 18			call break_point_state  
090a				endm  
# End of macro CALLMONITOR
090a				endif 
090a ed b0			ldir    ; copy zero term string 
090c				if DEBUG_STORESE 
090c					DMARK "SCA" 
090c f5				push af  
090d 3a 21 09			ld a, (.dmark)  
0910 32 b4 fe			ld (debug_mark),a  
0913 3a 22 09			ld a, (.dmark+1)  
0916 32 b5 fe			ld (debug_mark+1),a  
0919 3a 23 09			ld a, (.dmark+2)  
091c 32 b6 fe			ld (debug_mark+2),a  
091f 18 03			jr .pastdmark  
0921 ..			.dmark: db "SCA"  
0924 f1			.pastdmark: pop af  
0925			endm  
# End of macro DMARK
0925					CALLMONITOR 
0925 cd c6 18			call break_point_state  
0928				endm  
# End of macro CALLMONITOR
0928				endif 
0928			 
0928				; write file header page 
0928			 
0928 2a f2 fb			ld hl,(store_tmppageid) 
092b 11 07 fc			ld de, store_page 
092e				if DEBUG_STORESE 
092e					DMARK "SCb" 
092e f5				push af  
092f 3a 43 09			ld a, (.dmark)  
0932 32 b4 fe			ld (debug_mark),a  
0935 3a 44 09			ld a, (.dmark+1)  
0938 32 b5 fe			ld (debug_mark+1),a  
093b 3a 45 09			ld a, (.dmark+2)  
093e 32 b6 fe			ld (debug_mark+2),a  
0941 18 03			jr .pastdmark  
0943 ..			.dmark: db "SCb"  
0946 f1			.pastdmark: pop af  
0947			endm  
# End of macro DMARK
0947					;push af 
0947					;ld a, 'b' 
0947					;ld (debug_mark),a 
0947					;pop af 
0947					CALLMONITOR 
0947 cd c6 18			call break_point_state  
094a				endm  
# End of macro CALLMONITOR
094a				endif 
094a cd 7e 04			call storage_write_block 
094d			 
094d 3a fb fb			ld a, (store_tmpid) 
0950 6f				ld l, a 
0951 26 00			ld h,0 
0953				if DEBUG_STORESE 
0953					DMARK "SCz" 
0953 f5				push af  
0954 3a 68 09			ld a, (.dmark)  
0957 32 b4 fe			ld (debug_mark),a  
095a 3a 69 09			ld a, (.dmark+1)  
095d 32 b5 fe			ld (debug_mark+1),a  
0960 3a 6a 09			ld a, (.dmark+2)  
0963 32 b6 fe			ld (debug_mark+2),a  
0966 18 03			jr .pastdmark  
0968 ..			.dmark: db "SCz"  
096b f1			.pastdmark: pop af  
096c			endm  
# End of macro DMARK
096c					CALLMONITOR 
096c cd c6 18			call break_point_state  
096f				endm  
# End of macro CALLMONITOR
096f				endif 
096f c9				ret 
0970				 
0970			 
0970			 
0970			; 
0970			; Read File 
0970			; 
0970			; h - file id to locate 
0970			; l - extent to locate 
0970			; de - pointer to string to read into 
0970			; 
0970			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0970			 
0970			.sr_fail: 
0970 d1				pop de 
0971 c9				ret 
0972			 
0972			storage_read: 
0972			 
0972			 
0972 d5				push de 
0973			 
0973			; TODO BUG the above push is it popped before the RET Z? 
0973			 
0973			; TODO how to handle multiple part blocks 
0973			 
0973				; locate file extent to read 
0973			 
0973 5c				ld e, h 
0974 55				ld d, l 
0975			 
0975			.srext: 
0975 22 05 fc			ld (store_readptr), hl     ; save the current extent to load 
0978 ed 53 03 fc		ld (store_readbuf), de     ; save the current buffer to load in to 
097c			 
097c 21 40 00			ld hl, STORE_BLOCK_PHY 
097f				if DEBUG_STORESE 
097f					DMARK "sre" 
097f f5				push af  
0980 3a 94 09			ld a, (.dmark)  
0983 32 b4 fe			ld (debug_mark),a  
0986 3a 95 09			ld a, (.dmark+1)  
0989 32 b5 fe			ld (debug_mark+1),a  
098c 3a 96 09			ld a, (.dmark+2)  
098f 32 b6 fe			ld (debug_mark+2),a  
0992 18 03			jr .pastdmark  
0994 ..			.dmark: db "sre"  
0997 f1			.pastdmark: pop af  
0998			endm  
# End of macro DMARK
0998					CALLMONITOR 
0998 cd c6 18			call break_point_state  
099b				endm  
# End of macro CALLMONITOR
099b				endif 
099b cd 4c 07			call storage_findnextid 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "srf" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 b4 fe			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 b5 fe			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 b6 fe			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "srf"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd c6 18			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba cd 72 0f			call ishlzero 
09bd			;	ld a, l 
09bd			;	add h 
09bd			;	cp 0 
09bd 28 b1			jr z,.sr_fail			; block not found so EOF 
09bf			 
09bf				; save current address for use by higher level words etc 
09bf			 
09bf 22 f8 fb			ld (store_openaddr),hl 
09c2			 
09c2			 
09c2				; hl contains page number to load 
09c2 d1				pop de   ; get storage 
09c3 ed 53 03 fc		ld (store_readbuf), de     ; current buffer to load in to 
09c7 d5				push de 
09c8				if DEBUG_STORESE 
09c8					DMARK "srg" 
09c8 f5				push af  
09c9 3a dd 09			ld a, (.dmark)  
09cc 32 b4 fe			ld (debug_mark),a  
09cf 3a de 09			ld a, (.dmark+1)  
09d2 32 b5 fe			ld (debug_mark+1),a  
09d5 3a df 09			ld a, (.dmark+2)  
09d8 32 b6 fe			ld (debug_mark+2),a  
09db 18 03			jr .pastdmark  
09dd ..			.dmark: db "srg"  
09e0 f1			.pastdmark: pop af  
09e1			endm  
# End of macro DMARK
09e1					CALLMONITOR 
09e1 cd c6 18			call break_point_state  
09e4				endm  
# End of macro CALLMONITOR
09e4				endif 
09e4 cd 19 04			call storage_read_block 
09e7			 
09e7				; if this a continuation read??? 
09e7			 
09e7 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09ea			 
09ea 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ec cd 49 0f			call addatohl 
09ef 7e				ld a,(hl) 
09f0 fe 00			cp 0 
09f2 28 02			jr z, .markiscont 
09f4 3e ff			ld a, 255 
09f6			 
09f6			.markiscont: 
09f6 32 fa fb			ld (store_readcont), a 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srC" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 b4 fe			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 b5 fe			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 b6 fe			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srC"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd c6 18			call break_point_state  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15				; only short reads enabled 
0a15			 
0a15 3a 02 fc			ld a, (store_longread) 
0a18 fe 00			cp 0 
0a1a ca e7 0a			jp z, .readdone 
0a1d			 
0a1d			; TODO if block has no zeros then need to read next block  
0a1d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a1d			; check last byte of physical block. 
0a1d			; if not zero then the next block needs to be loaded 
0a1d			 
0a1d			 
0a1d 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
0a20			 
0a20 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a22 cd 49 0f			call addatohl 
0a25				;dec hl 
0a25 7e				ld a,(hl) 
0a26				if DEBUG_STORESE 
0a26					DMARK "sr?" 
0a26 f5				push af  
0a27 3a 3b 0a			ld a, (.dmark)  
0a2a 32 b4 fe			ld (debug_mark),a  
0a2d 3a 3c 0a			ld a, (.dmark+1)  
0a30 32 b5 fe			ld (debug_mark+1),a  
0a33 3a 3d 0a			ld a, (.dmark+2)  
0a36 32 b6 fe			ld (debug_mark+2),a  
0a39 18 03			jr .pastdmark  
0a3b ..			.dmark: db "sr?"  
0a3e f1			.pastdmark: pop af  
0a3f			endm  
# End of macro DMARK
0a3f					CALLMONITOR 
0a3f cd c6 18			call break_point_state  
0a42				endm  
# End of macro CALLMONITOR
0a42				endif 
0a42 fe 00			cp 0 
0a44 ca e7 0a			jp z, .readdone 
0a47			 
0a47				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a47			 
0a47 23				inc hl 
0a48			 
0a48 22 03 fc			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4b			 
0a4b ed 5b 05 fc		ld de, (store_readptr)     ; save the current extent to load 
0a4f			 
0a4f eb				ex de, hl 
0a50			 
0a50				; next ext 
0a50			 
0a50 23				inc hl 
0a51 22 05 fc			ld  (store_readptr), hl     ; save the current extent to load 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "sF2" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 b4 fe			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 b5 fe			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 b6 fe			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "sF2"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd c6 18			call break_point_state  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70			 
0a70				; get and load block 
0a70			 
0a70 cd 4c 07			call storage_findnextid 
0a73			 
0a73				if DEBUG_STORESE 
0a73					DMARK "sf2" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 b4 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 b5 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 b6 fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sf2"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd c6 18			call break_point_state  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f cd 72 0f			call ishlzero 
0a92			;	ld a, l 
0a92			;	add h 
0a92			;	cp 0 
0a92 ca 70 09			jp z,.sr_fail			; block not found so EOF 
0a95				 
0a95				; save current address for use by higher level words etc 
0a95			 
0a95 22 f8 fb			ld (store_openaddr),hl 
0a98			 
0a98 cd 19 04			call storage_read_block 
0a9b			 
0a9b				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9b				; we need to pull everything back  
0a9b			 
0a9b ed 5b 03 fc		ld de, (store_readbuf)     ; current buffer to nudge into 
0a9f 2a 03 fc			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa2 23				inc hl 
0aa3 23				inc hl     ; skip id and ext 
0aa4 01 40 00			ld bc, STORE_BLOCK_PHY 
0aa7				if DEBUG_STORESE 
0aa7					DMARK "SR<" 
0aa7 f5				push af  
0aa8 3a bc 0a			ld a, (.dmark)  
0aab 32 b4 fe			ld (debug_mark),a  
0aae 3a bd 0a			ld a, (.dmark+1)  
0ab1 32 b5 fe			ld (debug_mark+1),a  
0ab4 3a be 0a			ld a, (.dmark+2)  
0ab7 32 b6 fe			ld (debug_mark+2),a  
0aba 18 03			jr .pastdmark  
0abc ..			.dmark: db "SR<"  
0abf f1			.pastdmark: pop af  
0ac0			endm  
# End of macro DMARK
0ac0					CALLMONITOR 
0ac0 cd c6 18			call break_point_state  
0ac3				endm  
# End of macro CALLMONITOR
0ac3				endif 
0ac3 ed b0			ldir     ; copy data 
0ac5			 
0ac5				; move the pointer back and pretend we have a full buffer for next recheck 
0ac5			 
0ac5 1b				dec de 
0ac6 1b				dec de 
0ac7			 
0ac7			; TODO do pop below now short circuit loop????? 
0ac7 c1				pop bc     ; get rid of spare de on stack 
0ac8				if DEBUG_STORESE 
0ac8					DMARK "SR>" 
0ac8 f5				push af  
0ac9 3a dd 0a			ld a, (.dmark)  
0acc 32 b4 fe			ld (debug_mark),a  
0acf 3a de 0a			ld a, (.dmark+1)  
0ad2 32 b5 fe			ld (debug_mark+1),a  
0ad5 3a df 0a			ld a, (.dmark+2)  
0ad8 32 b6 fe			ld (debug_mark+2),a  
0adb 18 03			jr .pastdmark  
0add ..			.dmark: db "SR>"  
0ae0 f1			.pastdmark: pop af  
0ae1			endm  
# End of macro DMARK
0ae1					CALLMONITOR 
0ae1 cd c6 18			call break_point_state  
0ae4				endm  
# End of macro CALLMONITOR
0ae4				endif 
0ae4 c3 75 09			jp .srext 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			.readdone:		 
0ae7 e1				pop hl 		 ; return start of data to show as not EOF 
0ae8 23				inc hl   ; past file id 
0ae9 23				inc hl   ; past ext 
0aea				if DEBUG_STORESE 
0aea					DMARK "SRe" 
0aea f5				push af  
0aeb 3a ff 0a			ld a, (.dmark)  
0aee 32 b4 fe			ld (debug_mark),a  
0af1 3a 00 0b			ld a, (.dmark+1)  
0af4 32 b5 fe			ld (debug_mark+1),a  
0af7 3a 01 0b			ld a, (.dmark+2)  
0afa 32 b6 fe			ld (debug_mark+2),a  
0afd 18 03			jr .pastdmark  
0aff ..			.dmark: db "SRe"  
0b02 f1			.pastdmark: pop af  
0b03			endm  
# End of macro DMARK
0b03					CALLMONITOR 
0b03 cd c6 18			call break_point_state  
0b06				endm  
# End of macro CALLMONITOR
0b06				endif 
0b06 c9					ret 
0b07			 
0b07			 
0b07			 
0b07			; 
0b07			; Append File 
0b07			; 
0b07			; hl - file id to locate 
0b07			; de - pointer to (multi block) string to write 
0b07			 
0b07			.sa_notfound: 
0b07 d1				pop de 
0b08 c9				ret 
0b09			 
0b09			 
0b09			storage_append: 
0b09				; hl -  file id to append to 
0b09				; de - string to append 
0b09			 
0b09 d5				push de 
0b0a				 
0b0a				if DEBUG_STORESE 
0b0a					DMARK "AP1" 
0b0a f5				push af  
0b0b 3a 1f 0b			ld a, (.dmark)  
0b0e 32 b4 fe			ld (debug_mark),a  
0b11 3a 20 0b			ld a, (.dmark+1)  
0b14 32 b5 fe			ld (debug_mark+1),a  
0b17 3a 21 0b			ld a, (.dmark+2)  
0b1a 32 b6 fe			ld (debug_mark+2),a  
0b1d 18 03			jr .pastdmark  
0b1f ..			.dmark: db "AP1"  
0b22 f1			.pastdmark: pop af  
0b23			endm  
# End of macro DMARK
0b23					CALLMONITOR 
0b23 cd c6 18			call break_point_state  
0b26				endm  
# End of macro CALLMONITOR
0b26				endif 
0b26			 
0b26 7d				ld a, l 
0b27 32 fb fb			ld (store_tmpid), a 
0b2a			 
0b2a				; get file header  
0b2a			 
0b2a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2c 3a fb fb			ld a, (store_tmpid) 
0b2f 5f				ld e, a 
0b30			 
0b30 21 40 00				ld hl, STORE_BLOCK_PHY 
0b33 cd 4c 07				call storage_findnextid 
0b36			 
0b36 cd 72 0f			call ishlzero 
0b39 28 cc			jr z, .sa_notfound 
0b3b			 
0b3b 22 f2 fb			ld (store_tmppageid), hl 
0b3e			 
0b3e				; TODO handle file id not found 
0b3e			 
0b3e				if DEBUG_STORESE 
0b3e					DMARK "AP2" 
0b3e f5				push af  
0b3f 3a 53 0b			ld a, (.dmark)  
0b42 32 b4 fe			ld (debug_mark),a  
0b45 3a 54 0b			ld a, (.dmark+1)  
0b48 32 b5 fe			ld (debug_mark+1),a  
0b4b 3a 55 0b			ld a, (.dmark+2)  
0b4e 32 b6 fe			ld (debug_mark+2),a  
0b51 18 03			jr .pastdmark  
0b53 ..			.dmark: db "AP2"  
0b56 f1			.pastdmark: pop af  
0b57			endm  
# End of macro DMARK
0b57					CALLMONITOR 
0b57 cd c6 18			call break_point_state  
0b5a				endm  
# End of macro CALLMONITOR
0b5a				endif 
0b5a			 
0b5a				; update file extent count 
0b5a			 
0b5a 11 07 fc			ld de, store_page 
0b5d			 
0b5d cd 19 04			call storage_read_block 
0b60			 
0b60				if DEBUG_STORESE 
0b60					DMARK "AP3" 
0b60 f5				push af  
0b61 3a 75 0b			ld a, (.dmark)  
0b64 32 b4 fe			ld (debug_mark),a  
0b67 3a 76 0b			ld a, (.dmark+1)  
0b6a 32 b5 fe			ld (debug_mark+1),a  
0b6d 3a 77 0b			ld a, (.dmark+2)  
0b70 32 b6 fe			ld (debug_mark+2),a  
0b73 18 03			jr .pastdmark  
0b75 ..			.dmark: db "AP3"  
0b78 f1			.pastdmark: pop af  
0b79			endm  
# End of macro DMARK
0b79					CALLMONITOR 
0b79 cd c6 18			call break_point_state  
0b7c				endm  
# End of macro CALLMONITOR
0b7c				endif 
0b7c			;	ld (store_tmppageid), hl 
0b7c			 
0b7c 3a 09 fc			ld a, (store_page+2) 
0b7f 3c				inc a 
0b80 32 09 fc			ld (store_page+2), a 
0b83 32 fa fb			ld (store_tmpext), a 
0b86				 
0b86				if DEBUG_STORESE 
0b86					DMARK "AP3" 
0b86 f5				push af  
0b87 3a 9b 0b			ld a, (.dmark)  
0b8a 32 b4 fe			ld (debug_mark),a  
0b8d 3a 9c 0b			ld a, (.dmark+1)  
0b90 32 b5 fe			ld (debug_mark+1),a  
0b93 3a 9d 0b			ld a, (.dmark+2)  
0b96 32 b6 fe			ld (debug_mark+2),a  
0b99 18 03			jr .pastdmark  
0b9b ..			.dmark: db "AP3"  
0b9e f1			.pastdmark: pop af  
0b9f			endm  
# End of macro DMARK
0b9f					CALLMONITOR 
0b9f cd c6 18			call break_point_state  
0ba2				endm  
# End of macro CALLMONITOR
0ba2				endif 
0ba2 2a f2 fb			ld hl, (store_tmppageid) 
0ba5 11 07 fc			ld de, store_page 
0ba8 cd 7e 04			call storage_write_block 
0bab			 
0bab				; find free block 
0bab			 
0bab 11 00 00			ld de, 0			 ; file extent to locate 
0bae			 
0bae 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb1 cd 4c 07				call storage_findnextid 
0bb4 cd 72 0f			call ishlzero 
0bb7 ca 07 0b			jp z, .sa_notfound 
0bba			 
0bba					; TODO handle no space left 
0bba					 
0bba 22 f2 fb				ld (store_tmppageid), hl 
0bbd			 
0bbd				if DEBUG_STORESE 
0bbd					DMARK "AP4" 
0bbd f5				push af  
0bbe 3a d2 0b			ld a, (.dmark)  
0bc1 32 b4 fe			ld (debug_mark),a  
0bc4 3a d3 0b			ld a, (.dmark+1)  
0bc7 32 b5 fe			ld (debug_mark+1),a  
0bca 3a d4 0b			ld a, (.dmark+2)  
0bcd 32 b6 fe			ld (debug_mark+2),a  
0bd0 18 03			jr .pastdmark  
0bd2 ..			.dmark: db "AP4"  
0bd5 f1			.pastdmark: pop af  
0bd6			endm  
# End of macro DMARK
0bd6					CALLMONITOR 
0bd6 cd c6 18			call break_point_state  
0bd9				endm  
# End of macro CALLMONITOR
0bd9				endif 
0bd9					; init the buffer with zeros so we can id if the buffer is full or not 
0bd9			 
0bd9 e5					push hl 
0bda c5					push bc 
0bdb			 
0bdb 21 07 fc				ld hl, store_page 
0bde 06 40				ld b, STORE_BLOCK_PHY 
0be0 3e 00				ld a, 0 
0be2 77			.zeroblock:	ld (hl), a 
0be3 23					inc hl 
0be4 10 fc				djnz .zeroblock 
0be6			 
0be6 c1					pop bc 
0be7 e1					pop hl 
0be8			 
0be8					; construct block 
0be8			 
0be8 3a fb fb				ld a, (store_tmpid) 
0beb 32 07 fc				ld (store_page), a   ; file id 
0bee 3a fa fb				ld a, (store_tmpext)   ; extent for this block 
0bf1 32 08 fc				ld (store_page+1), a 
0bf4			 
0bf4 e1					pop hl    ; get string to write 
0bf5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bf7 11 09 fc				ld de, store_page+2 
0bfa			 
0bfa				if DEBUG_STORESE 
0bfa					DMARK "AP5" 
0bfa f5				push af  
0bfb 3a 0f 0c			ld a, (.dmark)  
0bfe 32 b4 fe			ld (debug_mark),a  
0c01 3a 10 0c			ld a, (.dmark+1)  
0c04 32 b5 fe			ld (debug_mark+1),a  
0c07 3a 11 0c			ld a, (.dmark+2)  
0c0a 32 b6 fe			ld (debug_mark+2),a  
0c0d 18 03			jr .pastdmark  
0c0f ..			.dmark: db "AP5"  
0c12 f1			.pastdmark: pop af  
0c13			endm  
# End of macro DMARK
0c13					CALLMONITOR 
0c13 cd c6 18			call break_point_state  
0c16				endm  
# End of macro CALLMONITOR
0c16				endif 
0c16			 
0c16			 
0c16			 
0c16					; fill buffer with data until end of string or full block 
0c16			 
0c16 7e			.appd:		ld a, (hl) 
0c17 12					ld (de), a 
0c18 fe 00				cp 0 
0c1a 28 04				jr z, .appdone 
0c1c 23					inc hl 
0c1d 13					inc de 
0c1e 10 f6				djnz .appd 
0c20			 
0c20 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c21 f5					push af   		; save last byte dumped 
0c22			 
0c22			 
0c22 2a f2 fb			ld hl, (store_tmppageid) 
0c25 11 07 fc			ld de, store_page 
0c28				if DEBUG_STORESE 
0c28					DMARK "AP6" 
0c28 f5				push af  
0c29 3a 3d 0c			ld a, (.dmark)  
0c2c 32 b4 fe			ld (debug_mark),a  
0c2f 3a 3e 0c			ld a, (.dmark+1)  
0c32 32 b5 fe			ld (debug_mark+1),a  
0c35 3a 3f 0c			ld a, (.dmark+2)  
0c38 32 b6 fe			ld (debug_mark+2),a  
0c3b 18 03			jr .pastdmark  
0c3d ..			.dmark: db "AP6"  
0c40 f1			.pastdmark: pop af  
0c41			endm  
# End of macro DMARK
0c41					CALLMONITOR 
0c41 cd c6 18			call break_point_state  
0c44				endm  
# End of macro CALLMONITOR
0c44				endif 
0c44 cd 7e 04				call storage_write_block 
0c47			 
0c47			 
0c47				; was that a full block of data written? 
0c47				; any more to write out? 
0c47			 
0c47				; if yes then set vars and jump to start of function again 
0c47			 
0c47 f1					pop af 
0c48 d1					pop de 
0c49			 
0c49 fe 00				cp 0		 ; no, string was fully written 
0c4b c8					ret z 
0c4c			 
0c4c					; setup vars for next cycle 
0c4c			 
0c4c 3a fb fb				ld a, (store_tmpid) 
0c4f 6f					ld l, a 
0c50 26 00				ld h, 0 
0c52			 
0c52 c3 09 0b			 	jp storage_append	 ; yes, need to write out some more 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			if DEBUG_STORECF 
0c55			storageput:	 
0c55					ret 
0c55			storageread: 
0c55					ld hl, store_page 
0c55					ld b, 200 
0c55					ld a,0 
0c55			.src:		ld (hl),a 
0c55					inc hl 
0c55					djnz .src 
0c55					 
0c55			 
0c55					ld de, 0 
0c55					ld bc, 1 
0c55					ld hl, store_page 
0c55					call cfRead 
0c55			 
0c55				call cfGetError 
0c55				ld hl,scratch 
0c55				call hexout 
0c55				ld hl, scratch+2 
0c55				ld a, 0 
0c55				ld (hl),a 
0c55				ld de, scratch 
0c55				ld a,display_row_1 
0c55				call str_at_display 
0c55				call update_display 
0c55			 
0c55					ld hl, store_page 
0c55					ld (os_cur_ptr),hl 
0c55			 
0c55					ret 
0c55			endif 
0c55			 
0c55			 
0c55			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c55			 
0c55			storage_clear_page: 
0c55 e5				push hl 
0c56 d5				push de 
0c57 c5				push bc 
0c58 21 07 fc			ld hl, store_page 
0c5b 3e 00			ld a, 0 
0c5d 77				ld (hl), a 
0c5e			 
0c5e 11 08 fc			ld de, store_page+1 
0c61 01 18 01			ld bc, STORE_BLOCK_LOG 
0c64			 
0c64 ed b0			ldir 
0c66				 
0c66 c1				pop bc 
0c67 d1				pop de 
0c68 e1				pop hl 
0c69 c9				ret 
0c6a			 
0c6a			; eof 
# End of file firmware_storage.asm
0c6a			  
0c6a			; support routines for above hardware abstraction layer  
0c6a			  
0c6a			include "firmware_general.asm"        ; general support functions  
0c6a			 
0c6a			; word look up 
0c6a			 
0c6a			; in 
0c6a			; a is the index 
0c6a			; hl is pointer start of array 
0c6a			; 
0c6a			; returns 
0c6a			; hl to the word 
0c6a			; 
0c6a			 
0c6a			table_lookup:  
0c6a d5					push de 
0c6b eb					ex de, hl 
0c6c			 
0c6c 6f					ld l, a 
0c6d 26 00				ld h, 0 
0c6f 29					add hl, hl 
0c70 19					add hl, de 
0c71 7e					ld a, (hl) 
0c72 23					inc hl 
0c73 66					ld h,(hl) 
0c74 6f					ld l, a 
0c75			 
0c75 d1					pop de 
0c76 c9					ret 
0c77			 
0c77			; Delay loops 
0c77			 
0c77			 
0c77			 
0c77			aDelayInMS: 
0c77 c5				push bc 
0c78 47				ld b,a 
0c79			msdelay: 
0c79 c5				push bc 
0c7a				 
0c7a			 
0c7a 01 41 00			ld bc,041h 
0c7d cd 95 0c			call delayloop 
0c80 c1				pop bc 
0c81 05				dec b 
0c82 20 f5			jr nz,msdelay 
0c84			 
0c84			;if CPU_CLOCK_8MHZ 
0c84			;msdelay8: 
0c84			;	push bc 
0c84			;	 
0c84			; 
0c84			;	ld bc,041h 
0c84			;	call delayloop 
0c84			;	pop bc 
0c84			;	dec b 
0c84			;	jr nz,msdelay8 
0c84			;endif 
0c84			 
0c84			 
0c84 c1				pop bc 
0c85 c9				ret 
0c86			 
0c86			 
0c86			delay250ms: 
0c86				;push de 
0c86 01 00 40			ld bc, 04000h 
0c89 c3 95 0c			jp delayloop 
0c8c			delay500ms: 
0c8c				;push de 
0c8c 01 00 80			ld bc, 08000h 
0c8f c3 95 0c			jp delayloop 
0c92			delay1s: 
0c92				;push bc 
0c92			   ; Clobbers A, d and e 
0c92 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c95			delayloop: 
0c95 c5			    push bc 
0c96			 
0c96			if BASE_CPM 
0c96				ld bc, CPM_DELAY_TUNE 
0c96			.cpmloop: 
0c96				push bc 
0c96			 
0c96			endif 
0c96			 
0c96			 
0c96			 
0c96			delayloopi: 
0c96			;	push bc 
0c96			;.dl: 
0c96 cb 47		    bit     0,a    	; 8 
0c98 cb 47		    bit     0,a    	; 8 
0c9a cb 47		    bit     0,a    	; 8 
0c9c e6 ff		    and     255  	; 7 
0c9e 0b			    dec     bc      	; 6 
0c9f 79			    ld      a,c     	; 4 
0ca0 b0			    or      b     	; 4 
0ca1 c2 96 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca4			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca4				;pop de 
0ca4			;pop bc 
0ca4			 
0ca4			if BASE_CPM 
0ca4				pop bc 
0ca4				 
0ca4			    dec     bc      	; 6 
0ca4			    ld      a,c     	; 4 
0ca4			    or      b     	; 4 
0ca4			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca4				 
0ca4			 
0ca4			endif 
0ca4			;if CPU_CLOCK_8MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4			 
0ca4			;if CPU_CLOCK_10MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4 c1			    pop bc 
0ca5			 
0ca5 c9				ret 
0ca6			 
0ca6			 
0ca6			 
0ca6			; eof 
# End of file firmware_general.asm
0ca6			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca6			; display routines that use the physical hardware abstraction layer 
0ca6			 
0ca6			 
0ca6			; information window 
0ca6			 
0ca6			; pass hl with 1st string to display 
0ca6			; pass de with 2nd string to display 
0ca6			 
0ca6			info_panel: 
0ca6 e5				push hl 
0ca7			 
0ca7 2a 55 fd			ld hl, (display_fb_active) 
0caa e5				push hl    ; future de destination 
0cab 21 4a fe				ld hl, display_fb0 
0cae 22 55 fd				ld (display_fb_active), hl 
0cb1			 
0cb1			;	call clear_display 
0cb1			 
0cb1				if BASE_CPM 
0cb1				ld a, '.' 
0cb1				else 
0cb1 3e a5			ld a, 165 
0cb3				endif 
0cb3 cd 1a 0d			call fill_display 
0cb6			 
0cb6			 
0cb6 3e 2d			ld a, display_row_3 + 5 
0cb8 cd 28 0d			call str_at_display 
0cbb			 
0cbb e1				pop hl 
0cbc d1				pop de 
0cbd			 
0cbd e5				push hl 
0cbe			 
0cbe			 
0cbe 3e 19			ld a, display_row_2 + 5 
0cc0 cd 28 0d			call str_at_display 
0cc3			 
0cc3			 
0cc3 cd 38 0d			call update_display 
0cc6 cd b2 1e			call next_page_prompt 
0cc9 cd 15 0d			call clear_display 
0ccc			 
0ccc				 
0ccc 21 f9 fd				ld hl, display_fb1 
0ccf 22 55 fd				ld (display_fb_active), hl 
0cd2 cd 38 0d			call update_display 
0cd5			 
0cd5 e1				pop hl 
0cd6			 
0cd6 c9				ret 
0cd7			 
0cd7			 
0cd7			 
0cd7			 
0cd7			; TODO windowing? 
0cd7			 
0cd7			; TODO scroll line up 
0cd7			 
0cd7			scroll_up: 
0cd7			 
0cd7 e5				push hl 
0cd8 d5				push de 
0cd9 c5				push bc 
0cda			 
0cda				; get frame buffer  
0cda			 
0cda 2a 55 fd			ld hl, (display_fb_active) 
0cdd e5				push hl    ; future de destination 
0cde			 
0cde 11 14 00			ld  de, display_cols 
0ce1 19				add hl, de 
0ce2			 
0ce2 d1				pop de 
0ce3			 
0ce3				;ex de, hl 
0ce3 01 4f 00			ld bc, display_fb_len -1  
0ce6			;if DEBUG_FORTH_WORDS 
0ce6			;	DMARK "SCL" 
0ce6			;	CALLMONITOR 
0ce6			;endif	 
0ce6 ed b0			ldir 
0ce8			 
0ce8				; wipe bottom row 
0ce8			 
0ce8			 
0ce8 2a 55 fd			ld hl, (display_fb_active) 
0ceb 11 50 00			ld de, display_cols*display_rows 
0cee 19				add hl, de 
0cef 06 14			ld b, display_cols 
0cf1 3e 20			ld a, ' ' 
0cf3			.scwipe: 
0cf3 77				ld (hl), a 
0cf4 2b				dec hl 
0cf5 10 fc			djnz .scwipe 
0cf7			 
0cf7				;pop hl 
0cf7			 
0cf7 c1				pop bc 
0cf8 d1				pop de 
0cf9 e1				pop hl 
0cfa			 
0cfa c9				ret 
0cfb			 
0cfb			 
0cfb			;scroll_upo: 
0cfb			;	ld de, display_row_1 
0cfb			 ;	ld hl, display_row_2 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_2 
0cfb			 ;	ld hl, display_row_3 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_3 
0cfb			 ;	ld hl, display_row_4 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			 
0cfb			; TODO clear row 4 
0cfb			 
0cfb			;	ret 
0cfb			 
0cfb				 
0cfb			scroll_down: 
0cfb			 
0cfb e5				push hl 
0cfc d5				push de 
0cfd c5				push bc 
0cfe			 
0cfe				; get frame buffer  
0cfe			 
0cfe 2a 55 fd			ld hl, (display_fb_active) 
0d01			 
0d01 11 4f 00			ld de, display_fb_len - 1 
0d04 19				add hl, de 
0d05			 
0d05 e5			push hl    ; future de destination 
0d06			 
0d06 11 14 00			ld  de, display_cols 
0d09 ed 52			sbc hl, de 
0d0b			 
0d0b			 
0d0b d1				pop de 
0d0c			 
0d0c			;	ex de, hl 
0d0c 01 4f 00			ld bc, display_fb_len -1  
0d0f			 
0d0f			 
0d0f				 
0d0f			 
0d0f ed b0			ldir 
0d11			 
0d11				; wipe bottom row 
0d11			 
0d11			 
0d11			;	ld hl, (display_fb_active) 
0d11			;;	ld de, display_cols*display_rows 
0d11			;;	add hl, de 
0d11			;	ld b, display_cols 
0d11			;	ld a, ' ' 
0d11			;.scwiped: 
0d11			;	ld (hl), a 
0d11			;	dec hl 
0d11			;	djnz .scwiped 
0d11			 
0d11				;pop hl 
0d11			 
0d11 c1				pop bc 
0d12 d1				pop de 
0d13 e1				pop hl 
0d14			 
0d14 c9				ret 
0d15			;scroll_down: 
0d15			;	ld de, display_row_4 
0d15			;	ld hl, display_row_3 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_3 
0d15			; 	ld hl, display_row_2 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_2 
0d15			;	ld hl, display_row_1 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;;; TODO clear row 1 
0d15			;	ret 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			; clear active frame buffer 
0d15			 
0d15			clear_display: 
0d15 3e 20			ld a, ' ' 
0d17 c3 1a 0d			jp fill_display 
0d1a			 
0d1a			; fill active frame buffer with a char in A 
0d1a			 
0d1a			fill_display: 
0d1a 06 50			ld b,display_fb_len 
0d1c 2a 55 fd			ld hl, (display_fb_active) 
0d1f 77			.fd1:	ld (hl),a 
0d20 23				inc hl 
0d21 10 fc			djnz .fd1 
0d23 23				inc hl 
0d24 3e 00			ld a,0 
0d26 77				ld (hl),a 
0d27			 
0d27			 
0d27 c9				ret 
0d28			; Write string (DE) at pos (A) to active frame buffer 
0d28			 
0d28 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0d2b 06 00					ld b,0 
0d2d 4f					ld c,a 
0d2e 09					add hl,bc 
0d2f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d30 b7			            OR   A              ;Null terminator? 
0d31 c8			            RET  Z              ;Yes, so finished 
0d32 77					ld (hl),a 
0d33 23				inc hl 
0d34 13			            INC  DE             ;Point to next character 
0d35 18 f8		            JR   .sad1     ;Repeat 
0d37 c9					ret 
0d38			 
0d38			; using current frame buffer write to physical display 
0d38			 
0d38			update_display: 
0d38 e5				push hl 
0d39 2a 55 fd			ld hl, (display_fb_active) 
0d3c cd 85 71			call write_display 
0d3f e1				pop hl 
0d40 c9				ret 
0d41			 
0d41			; TODO scrolling 
0d41			 
0d41			 
0d41			; move cursor right one char 
0d41			cursor_right: 
0d41			 
0d41				; TODO shift right 
0d41				; TODO if beyond max col 
0d41				; TODO       cursor_next_line 
0d41			 
0d41 c9				ret 
0d42			 
0d42			 
0d42			cursor_next_line: 
0d42				; TODO first char 
0d42				; TODO line down 
0d42				; TODO if past last row 
0d42				; TODO    scroll up 
0d42			 
0d42 c9				ret 
0d43			 
0d43			cursor_left: 
0d43				; TODO shift left 
0d43				; TODO if beyond left  
0d43				; TODO     cursor prev line 
0d43				 
0d43 c9				ret 
0d44			 
0d44			cursor_prev_line: 
0d44				; TODO last char 
0d44				; TODO line up 
0d44				; TODO if past first row 
0d44				; TODO   scroll down 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cout: 
0d45				; A - char 
0d45 c9				ret 
0d46			 
0d46			 
0d46			; Display a menu and allow item selection (optional toggle items) 
0d46			; 
0d46			; format: 
0d46			; hl pointer to word array with zero term for items 
0d46			; e.g.    db item1 
0d46			;         db .... 
0d46			;         db 0 
0d46			; 
0d46			; a = starting menu item  
0d46			; 
0d46			; de = pointer item toggle array   (todo) 
0d46			; 
0d46			; returns item selected in a 1-... 
0d46			; returns 0 if back button pressed 
0d46			; 
0d46			; NOTE: Uses system frame buffer to display 
0d46			; 
0d46			; LEFT, Q = go back 
0d46			; RIGHT, SPACE, CR = select 
0d46			; UP, A - Up 
0d46			; DOWN, Z - Down 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			menu: 
0d46			 
0d46					; keep array pointer 
0d46			 
0d46 22 00 fc				ld (store_tmp1), hl 
0d49 32 fe fb				ld (store_tmp2), a 
0d4c			 
0d4c					; check for key bounce 
0d4c			 
0d4c			if BASE_KEV 
0d4c			 
0d4c cd 3a 73		.mbounce:	call cin 
0d4f fe 00				cp 0 
0d51 20 f9				jr nz, .mbounce 
0d53			endif 
0d53					; for ease use ex 
0d53			 
0d53					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d53 21 4a fe				ld hl, display_fb0 
0d56 22 55 fd				ld (display_fb_active), hl 
0d59			 
0d59 cd 15 0d		.mloop:		call clear_display 
0d5c cd 38 0d				call update_display 
0d5f			 
0d5f					; draw selection id '>' at 1 
0d5f			 
0d5f					; init start of list display 
0d5f			 
0d5f 3e 05				ld a, 5 
0d61 32 fc fb				ld (store_tmp3), a   ; display row count 
0d64 3a fe fb				ld a,( store_tmp2) 
0d67 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d6a			 
0d6a					 
0d6a			.mitem:	 
0d6a			 
0d6a			 
0d6a 3a ff fb				ld a,(store_tmp2+1) 
0d6d 6f					ld l, a 
0d6e 26 00				ld h, 0 
0d70 29					add hl, hl 
0d71 ed 5b 00 fc			ld de, (store_tmp1) 
0d75 19					add hl, de 
0d76 7e					ld a, (hl) 
0d77 23					inc hl 
0d78 66					ld h,(hl) 
0d79 6f					ld l, a 
0d7a			 
0d7a cd 72 0f				call ishlzero 
0d7d 28 1a				jr z, .mdone 
0d7f			 
0d7f eb					ex de, hl 
0d80 3a fc fb				ld a, (store_tmp3) 
0d83 cd 28 0d				call str_at_display 
0d86					 
0d86			 
0d86					; next item 
0d86 3a ff fb				ld a, (store_tmp2+1) 
0d89 3c					inc a 
0d8a 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d8d			 
0d8d			 		; next row 
0d8d			 
0d8d 3a fc fb				ld a, (store_tmp3) 
0d90 c6 14				add display_cols 
0d92 32 fc fb				ld (store_tmp3), a 
0d95			 
0d95					; at end of screen? 
0d95			 
0d95 fe 10				cp display_rows*4 
0d97 20 d1				jr nz, .mitem 
0d99			 
0d99			 
0d99			.mdone: 
0d99 cd 72 0f				call ishlzero 
0d9c 28 08				jr z, .nodn 
0d9e			 
0d9e 3e 3c				ld a, display_row_4 
0da0 11 1f 0e				ld de, .mdown 
0da3 cd 28 0d				call str_at_display 
0da6			 
0da6					; draw options to fill the screens with active item on line 1 
0da6					; if current option is 2 or more then display ^ in top 
0da6			 
0da6 3a fe fb		.nodn:		ld a, (store_tmp2) 
0da9 fe 00				cp 0 
0dab 28 08				jr z, .noup 
0dad			 
0dad 3e 00				ld a, 0 
0daf 11 1d 0e				ld de, .mup 
0db2 cd 28 0d				call str_at_display 
0db5			 
0db5 3e 02		.noup:		ld a, 2 
0db7 11 1b 0e				ld de, .msel 
0dba cd 28 0d				call str_at_display 
0dbd			 
0dbd					; if current option + 1 is not null then display V in bottom 
0dbd					; get key 
0dbd cd 38 0d				call update_display 
0dc0			 
0dc0			 
0dc0					; handle key 
0dc0			 
0dc0 cd 29 73				call cin_wait 
0dc3			 
0dc3 fe 05				cp KEY_UP 
0dc5 28 2b				jr z, .mgoup 
0dc7 fe 61				cp 'a' 
0dc9 28 27				jr z, .mgoup 
0dcb fe 0a				cp KEY_DOWN 
0dcd 28 32				jr z, .mgod 
0dcf fe 7a				cp 'z' 
0dd1 28 2e				jr z, .mgod 
0dd3 fe 20				cp ' ' 
0dd5 28 34				jr z, .goend 
0dd7 fe 0c				cp KEY_RIGHT 
0dd9 28 30				jr z, .goend 
0ddb fe 0d				cp KEY_CR 
0ddd 28 2c				jr z, .goend 
0ddf fe 71				cp 'q' 
0de1 28 0b				jr z, .goback 
0de3			 
0de3 fe 0b				cp KEY_LEFT 
0de5 28 07				jr z, .goback 
0de7 fe 08				cp KEY_BS 
0de9 28 03				jr z, .goback 
0deb c3 59 0d				jp .mloop 
0dee			 
0dee			.goback: 
0dee 3e 00			ld a, 0 
0df0 18 1d			jr .goend2 
0df2			 
0df2				; move up one 
0df2			.mgoup: 
0df2 3a fe fb				ld a, (store_tmp2) 
0df5 fe 00				cp 0 
0df7 ca 59 0d				jp z, .mloop 
0dfa 3d					dec a 
0dfb 32 fe fb				ld (store_tmp2), a 
0dfe c3 59 0d				jp .mloop 
0e01			 
0e01				; move down one 
0e01			.mgod: 
0e01 3a fe fb				ld a, (store_tmp2) 
0e04 3c					inc a 
0e05 32 fe fb				ld (store_tmp2), a 
0e08 c3 59 0d				jp .mloop 
0e0b			 
0e0b			 
0e0b			.goend: 
0e0b					; get selected item number 
0e0b			 
0e0b 3a fe fb				ld a, (store_tmp2) 
0e0e 3c					inc a 
0e0f			 
0e0f			.goend2: 
0e0f f5					push af 
0e10			 
0e10					; restore active fb 
0e10					; TODO BUG assumes fb1 
0e10			 
0e10 21 f9 fd				ld hl, display_fb1 
0e13 22 55 fd				ld (display_fb_active), hl 
0e16			 
0e16					; restore main regs 
0e16			 
0e16			 
0e16 cd 38 0d				call update_display 
0e19			 
0e19 f1					pop af 
0e1a			 
0e1a c9				ret 
0e1b			 
0e1b .. 00		.msel:   db ">",0 
0e1d .. 00		.mup:   db "^",0 
0e1f .. 00		.mdown:   db "v",0 
0e21			 
0e21			 
0e21			; eof 
0e21			 
# End of file firmware_display.asm
0e21			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e21			; random number generators 
0e21			 
0e21			 
0e21			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e21			 
0e21			 
0e21			;-----> Generate a random number 
0e21			; output a=answer 0<=a<=255 
0e21			; all registers are preserved except: af 
0e21			random: 
0e21 e5			        push    hl 
0e22 d5			        push    de 
0e23 2a 37 fd		        ld      hl,(randData) 
0e26 ed 5f		        ld      a,r 
0e28 57			        ld      d,a 
0e29 5e			        ld      e,(hl) 
0e2a 19			        add     hl,de 
0e2b 85			        add     a,l 
0e2c ac			        xor     h 
0e2d 22 37 fd		        ld      (randData),hl 
0e30 d1			        pop     de 
0e31 e1			        pop     hl 
0e32 c9			        ret 
0e33			 
0e33			 
0e33			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e33			 
0e33			 
0e33			 
0e33			;------LFSR------ 
0e33			;James Montelongo 
0e33			;optimized by Spencer Putt 
0e33			;out: 
0e33			; a = 8 bit random number 
0e33			RandLFSR: 
0e33 21 3d fd		        ld hl,LFSRSeed+4 
0e36 5e			        ld e,(hl) 
0e37 23			        inc hl 
0e38 56			        ld d,(hl) 
0e39 23			        inc hl 
0e3a 4e			        ld c,(hl) 
0e3b 23			        inc hl 
0e3c 7e			        ld a,(hl) 
0e3d 47			        ld b,a 
0e3e cb 13		        rl e  
0e40 cb 12			rl d 
0e42 cb 11		        rl c  
0e44 17				rla 
0e45 cb 13		        rl e  
0e47 cb 12			rl d 
0e49 cb 11		        rl c  
0e4b 17				rla 
0e4c cb 13		        rl e  
0e4e cb 12			rl d 
0e50 cb 11		        rl c  
0e52 17				rla 
0e53 67			        ld h,a 
0e54 cb 13		        rl e  
0e56 cb 12			rl d 
0e58 cb 11		        rl c  
0e5a 17				rla 
0e5b a8			        xor b 
0e5c cb 13		        rl e  
0e5e cb 12			rl d 
0e60 ac			        xor h 
0e61 a9			        xor c 
0e62 aa			        xor d 
0e63 21 3f fd		        ld hl,LFSRSeed+6 
0e66 11 40 fd		        ld de,LFSRSeed+7 
0e69 01 07 00		        ld bc,7 
0e6c ed b8		        lddr 
0e6e 12			        ld (de),a 
0e6f c9			        ret 
0e70			 
0e70			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e70			 
0e70			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e70			 
0e70			 
0e70			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e70			 
0e70			prng16: 
0e70			;Inputs: 
0e70			;   (seed1) contains a 16-bit seed value 
0e70			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e70			;Outputs: 
0e70			;   HL is the result 
0e70			;   BC is the result of the LCG, so not that great of quality 
0e70			;   DE is preserved 
0e70			;Destroys: 
0e70			;   AF 
0e70			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e70			;160cc 
0e70			;26 bytes 
0e70 2a 31 fd		    ld hl,(seed1) 
0e73 44			    ld b,h 
0e74 4d			    ld c,l 
0e75 29			    add hl,hl 
0e76 29			    add hl,hl 
0e77 2c			    inc l 
0e78 09			    add hl,bc 
0e79 22 31 fd		    ld (seed1),hl 
0e7c 2a 2f fd		    ld hl,(seed2) 
0e7f 29			    add hl,hl 
0e80 9f			    sbc a,a 
0e81 e6 2d		    and %00101101 
0e83 ad			    xor l 
0e84 6f			    ld l,a 
0e85 22 2f fd		    ld (seed2),hl 
0e88 09			    add hl,bc 
0e89 c9			    ret 
0e8a			 
0e8a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8a			 
0e8a			rand32: 
0e8a			;Inputs: 
0e8a			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8a			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8a			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8a			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8a			;   **NOTE: seed2 must be non-zero 
0e8a			;Outputs: 
0e8a			;   HL is the result 
0e8a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8a			;Destroys: 
0e8a			;   AF 
0e8a			;Tested and passes all CAcert tests 
0e8a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8a			;it has a period of 18,446,744,069,414,584,320 
0e8a			;roughly 18.4 quintillion. 
0e8a			;LFSR taps: 0,2,6,7  = 11000101 
0e8a			;291cc 
0e8a			;seed1_0=$+1 
0e8a			;    ld hl,12345 
0e8a			;seed1_1=$+1 
0e8a			;    ld de,6789 
0e8a			;    ld b,h 
0e8a			;    ld c,l 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    inc l 
0e8a			;    add hl,bc 
0e8a			;    ld (seed1_0),hl 
0e8a			;    ld hl,(seed1_1) 
0e8a			;    adc hl,de 
0e8a			;    ld (seed1_1),hl 
0e8a			;    ex de,hl 
0e8a			;seed2_0=$+1 
0e8a			;    ld hl,9876 
0e8a			;seed2_1=$+1 
0e8a			;    ld bc,54321 
0e8a			;    add hl,hl \ rl c \ rl b 
0e8a			;    ld (seed2_1),bc 
0e8a			;    sbc a,a 
0e8a			;    and %11000101 
0e8a			;    xor l 
0e8a			;    ld l,a 
0e8a			;    ld (seed2_0),hl 
0e8a			;    ex de,hl 
0e8a			;    add hl,bc 
0e8a			;    ret 
0e8a			; 
0e8a			 
0e8a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8a			; 20 bytes, 86 cycles (excluding ret) 
0e8a			 
0e8a			; returns   hl = pseudorandom number 
0e8a			; corrupts   a 
0e8a			 
0e8a			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8a			; using the xorshift method: 
0e8a			 
0e8a			; hl ^= hl << 7 
0e8a			; hl ^= hl >> 9 
0e8a			; hl ^= hl << 8 
0e8a			 
0e8a			; some alternative shift triplets which also perform well are: 
0e8a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8a			 
0e8a			;  org 32768 
0e8a			 
0e8a			xrnd: 
0e8a 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0e8d 3e 00		  ld a,0 
0e8f bd			  cp l 
0e90 20 02		  jr nz, .xrnd1 
0e92 2e 01		  ld l, 1 
0e94			.xrnd1: 
0e94			 
0e94 7c			  ld a,h 
0e95 1f			  rra 
0e96 7d			  ld a,l 
0e97 1f			  rra 
0e98 ac			  xor h 
0e99 67			  ld h,a 
0e9a 7d			  ld a,l 
0e9b 1f			  rra 
0e9c 7c			  ld a,h 
0e9d 1f			  rra 
0e9e ad			  xor l 
0e9f 6f			  ld l,a 
0ea0 ac			  xor h 
0ea1 67			  ld h,a 
0ea2			 
0ea2 22 35 fd		  ld (xrandc),hl 
0ea5			 
0ea5 c9			  ret 
0ea6			;  
0ea6			 
0ea6			 
0ea6			;;;; int maths 
0ea6			 
0ea6			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea6			; Divide 16-bit values (with 16-bit result) 
0ea6			; In: Divide BC by divider DE 
0ea6			; Out: BC = result, HL = rest 
0ea6			; 
0ea6			Div16: 
0ea6 21 00 00		    ld hl,0 
0ea9 78			    ld a,b 
0eaa 06 08		    ld b,8 
0eac			Div16_Loop1: 
0eac 17			    rla 
0ead ed 6a		    adc hl,hl 
0eaf ed 52		    sbc hl,de 
0eb1 30 01		    jr nc,Div16_NoAdd1 
0eb3 19			    add hl,de 
0eb4			Div16_NoAdd1: 
0eb4 10 f6		    djnz Div16_Loop1 
0eb6 17			    rla 
0eb7 2f			    cpl 
0eb8 47			    ld b,a 
0eb9 79			    ld a,c 
0eba 48			    ld c,b 
0ebb 06 08		    ld b,8 
0ebd			Div16_Loop2: 
0ebd 17			    rla 
0ebe ed 6a		    adc hl,hl 
0ec0 ed 52		    sbc hl,de 
0ec2 30 01		    jr nc,Div16_NoAdd2 
0ec4 19			    add hl,de 
0ec5			Div16_NoAdd2: 
0ec5 10 f6		    djnz Div16_Loop2 
0ec7 17			    rla 
0ec8 2f			    cpl 
0ec9 41			    ld b,c 
0eca 4f			    ld c,a 
0ecb c9			ret 
0ecc			 
0ecc			 
0ecc			;http://z80-heaven.wikidot.com/math 
0ecc			; 
0ecc			;Inputs: 
0ecc			;     DE and A are factors 
0ecc			;Outputs: 
0ecc			;     A is not changed 
0ecc			;     B is 0 
0ecc			;     C is not changed 
0ecc			;     DE is not changed 
0ecc			;     HL is the product 
0ecc			;Time: 
0ecc			;     342+6x 
0ecc			; 
0ecc			Mult16: 
0ecc			 
0ecc 06 08		     ld b,8          ;7           7 
0ece 21 00 00		     ld hl,0         ;10         10 
0ed1 29			       add hl,hl     ;11*8       88 
0ed2 07			       rlca          ;4*8        32 
0ed3 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed5 19			         add hl,de   ;--         -- 
0ed6 10 f9		       djnz $-5      ;13*7+8     99 
0ed8 c9			ret 
0ed9			 
0ed9			; 
0ed9			; Square root of 16-bit value 
0ed9			; In:  HL = value 
0ed9			; Out:  D = result (rounded down) 
0ed9			; 
0ed9			;Sqr16: 
0ed9			;    ld de,#0040 
0ed9			;    ld a,l 
0ed9			;    ld l,h 
0ed9			;    ld h,d 
0ed9			;    or a 
0ed9			;    ld b,8 
0ed9			;Sqr16_Loop: 
0ed9			;    sbc hl,de 
0ed9			;    jr nc,Sqr16_Skip 
0ed9			;    add hl,de 
0ed9			;Sqr16_Skip: 
0ed9			;    ccf 
0ed9			;    rl d 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    djnz Sqr16_Loop 
0ed9			;    ret 
0ed9			; 
0ed9			; 
0ed9			; Divide 8-bit values 
0ed9			; In: Divide E by divider C 
0ed9			; Out: A = result, B = rest 
0ed9			; 
0ed9			Div8: 
0ed9 af			    xor a 
0eda 06 08		    ld b,8 
0edc			Div8_Loop: 
0edc cb 13		    rl e 
0ede 17			    rla 
0edf 91			    sub c 
0ee0 30 01		    jr nc,Div8_NoAdd 
0ee2 81			    add a,c 
0ee3			Div8_NoAdd: 
0ee3 10 f7		    djnz Div8_Loop 
0ee5 47			    ld b,a 
0ee6 7b			    ld a,e 
0ee7 17			    rla 
0ee8 2f			    cpl 
0ee9 c9			    ret 
0eea			 
0eea			; 
0eea			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eea			; In: Multiply A with DE 
0eea			; Out: HL = result 
0eea			; 
0eea			Mult12U: 
0eea 2e 00		    ld l,0 
0eec 87			    add a,a 
0eed 30 01		    jr nc,Mult12U_NoAdd0 
0eef 19			    add hl,de 
0ef0			Mult12U_NoAdd0: 
0ef0 29			    add hl,hl 
0ef1 87			    add a,a 
0ef2 30 01		    jr nc,Mult12U_NoAdd1 
0ef4 19			    add hl,de 
0ef5			Mult12U_NoAdd1: 
0ef5 29			    add hl,hl 
0ef6 87			    add a,a 
0ef7 30 01		    jr nc,Mult12U_NoAdd2 
0ef9 19			    add hl,de 
0efa			Mult12U_NoAdd2: 
0efa 29			    add hl,hl 
0efb 87			    add a,a 
0efc 30 01		    jr nc,Mult12U_NoAdd3 
0efe 19			    add hl,de 
0eff			Mult12U_NoAdd3: 
0eff 29			    add hl,hl 
0f00 87			    add a,a 
0f01 30 01		    jr nc,Mult12U_NoAdd4 
0f03 19			    add hl,de 
0f04			Mult12U_NoAdd4: 
0f04 29			    add hl,hl 
0f05 87			    add a,a 
0f06 30 01		    jr nc,Mult12U_NoAdd5 
0f08 19			    add hl,de 
0f09			Mult12U_NoAdd5: 
0f09 29			    add hl,hl 
0f0a 87			    add a,a 
0f0b 30 01		    jr nc,Mult12U_NoAdd6 
0f0d 19			    add hl,de 
0f0e			Mult12U_NoAdd6: 
0f0e 29			    add hl,hl 
0f0f 87			    add a,a 
0f10 d0			    ret nc 
0f11 19			    add hl,de 
0f12 c9			    ret 
0f13			 
0f13			; 
0f13			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f13			; In: Multiply A with DE 
0f13			;      Put lowest value in A for most efficient calculation 
0f13			; Out: HL = result 
0f13			; 
0f13			Mult12R: 
0f13 21 00 00		    ld hl,0 
0f16			Mult12R_Loop: 
0f16 cb 3f		    srl a 
0f18 30 01		    jr nc,Mult12R_NoAdd 
0f1a 19			    add hl,de 
0f1b			Mult12R_NoAdd: 
0f1b cb 23		    sla e 
0f1d cb 12		    rl d 
0f1f b7			    or a 
0f20 c2 16 0f		    jp nz,Mult12R_Loop 
0f23 c9			    ret 
0f24			 
0f24			; 
0f24			; Multiply 16-bit values (with 32-bit result) 
0f24			; In: Multiply BC with DE 
0f24			; Out: BCHL = result 
0f24			; 
0f24			Mult32: 
0f24 79			    ld a,c 
0f25 48			    ld c,b 
0f26 21 00 00		    ld hl,0 
0f29 06 10		    ld b,16 
0f2b			Mult32_Loop: 
0f2b 29			    add hl,hl 
0f2c 17			    rla 
0f2d cb 11		    rl c 
0f2f 30 07		    jr nc,Mult32_NoAdd 
0f31 19			    add hl,de 
0f32 ce 00		    adc a,0 
0f34 d2 38 0f		    jp nc,Mult32_NoAdd 
0f37 0c			    inc c 
0f38			Mult32_NoAdd: 
0f38 10 f1		    djnz Mult32_Loop 
0f3a 41			    ld b,c 
0f3b 4f			    ld c,a 
0f3c c9			    ret 
0f3d			 
0f3d			 
0f3d			 
0f3d			; 
0f3d			; Multiply 8-bit values 
0f3d			; In:  Multiply H with E 
0f3d			; Out: HL = result 
0f3d			; 
0f3d			Mult8: 
0f3d 16 00		    ld d,0 
0f3f 6a			    ld l,d 
0f40 06 08		    ld b,8 
0f42			Mult8_Loop: 
0f42 29			    add hl,hl 
0f43 30 01		    jr nc,Mult8_NoAdd 
0f45 19			    add hl,de 
0f46			Mult8_NoAdd: 
0f46 10 fa		    djnz Mult8_Loop 
0f48 c9			    ret 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			;;http://z80-heaven.wikidot.com/math 
0f49			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f49			; 
0f49			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f49			;     ld a,16        ;7 
0f49			;     ld hl,0        ;10 
0f49			;     jp $+5         ;10 
0f49			;.DivLoop: 
0f49			;       add hl,bc    ;-- 
0f49			;       dec a        ;64 
0f49			;       jr z,.DivLoopEnd        ;86 
0f49			; 
0f49			;       sla e        ;128 
0f49			;       rl d         ;128 
0f49			;       adc hl,hl    ;240 
0f49			;       sbc hl,bc    ;240 
0f49			;       jr nc,.DivLoop ;23|21 
0f49			;       inc e        ;-- 
0f49			;       jp .DivLoop+1 
0f49			; 
0f49			;.DivLoopEnd: 
0f49			 
0f49			;HL_Div_C: 
0f49			;Inputs: 
0f49			;     HL is the numerator 
0f49			;     C is the denominator 
0f49			;Outputs: 
0f49			;     A is the remainder 
0f49			;     B is 0 
0f49			;     C is not changed 
0f49			;     DE is not changed 
0f49			;     HL is the quotient 
0f49			; 
0f49			;       ld b,16 
0f49			;       xor a 
0f49			;         add hl,hl 
0f49			;         rla 
0f49			;         cp c 
0f49			;         jr c,$+4 
0f49			;           inc l 
0f49			;           sub c 
0f49			;         djnz $-7 
0f49			 
0f49			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f49			 
0f49			addatohl: 
0f49 85			    add   a, l    ; A = A+L 
0f4a 6f			    ld    l, a    ; L = A+L 
0f4b 8c			    adc   a, h    ; A = A+L+H+carry 
0f4c 95			    sub   l       ; A = H+carry 
0f4d 67			    ld    h, a    ; H = H+carry 
0f4e c9			ret 
0f4f			 
0f4f			addatode: 
0f4f 83			    add   a, e    ; A = A+L 
0f50 5f			    ld    e, a    ; L = A+L 
0f51 8a			    adc   a, d    ; A = A+L+H+carry 
0f52 93			    sub   e       ; A = H+carry 
0f53 57			    ld    d, a    ; H = H+carry 
0f54 c9			ret 
0f55			 
0f55			 
0f55			addatobc: 
0f55 81			    add   a, c    ; A = A+L 
0f56 4f			    ld    c, a    ; L = A+L 
0f57 88			    adc   a, b    ; A = A+L+H+carry 
0f58 91			    sub   c       ; A = H+carry 
0f59 47			    ld    b, a    ; H = H+carry 
0f5a c9			ret 
0f5b			 
0f5b			subafromhl: 
0f5b			   ; If A=0 do nothing 
0f5b			    ; Otherwise flip A's sign. Since 
0f5b			    ; the upper byte becomes -1, also 
0f5b			    ; substract 1 from H. 
0f5b ed 44		    neg 
0f5d ca 66 0f		    jp    z, Skip 
0f60 25			    dec   h 
0f61			     
0f61			    ; Now add the low byte as usual 
0f61			    ; Two's complement takes care of 
0f61			    ; ensuring the result is correct 
0f61 85			    add   a, l 
0f62 6f			    ld    l, a 
0f63 8c			    adc   a, h 
0f64 95			    sub   l 
0f65 67			    ld    h, a 
0f66			Skip: 
0f66 c9				ret 
0f67			 
0f67			 
0f67			; compare hl and de 
0f67			; returns:  
0f67			; if hl = de, z=1, s=0, c0=0 
0f67			; if hl > de, z=0, s=0, c=0 
0f67			; if hl < de, z=0, s=1, c=1 
0f67			cmp16:	 
0f67 b7				or a 
0f68 ed 52			sbc hl,de 
0f6a e0				ret po 
0f6b 7c				ld a,h 
0f6c 1f				rra 
0f6d ee 40			xor 01000000B 
0f6f 37				scf 
0f70 8f				adc a,a 
0f71 c9				ret 
0f72			 
0f72			 
0f72			; test if hl contains zero   - A is destroyed 
0f72			 
0f72			ishlzero:    
0f72 b7				or a     ; reset flags 
0f73 7c				ld a, h 
0f74 b5				or l        	 
0f75			 
0f75 c9				ret 
0f76			 
0f76			 
0f76			 
0f76			 
0f76			if FORTH_ENABLE_FLOATMATH 
0f76			;include "float/bbcmath.z80" 
0f76			include "float/lpfpcalc.asm" 
0f76			endif 
0f76			 
0f76			 
0f76			; eof 
0f76			 
# End of file firmware_maths.asm
0f76			include "firmware_strings.asm"   ; string handling  
0f76			 
0f76			 
0f76			; TODO string len 
0f76			; input text string, end on cr with zero term 
0f76			; a offset into frame buffer to start prompt 
0f76			; d is max length 
0f76			; e is display size TODO 
0f76			; c is current cursor position 
0f76			; hl is ptr to where string will be stored 
0f76			 
0f76			 
0f76			; TODO check limit of buffer for new inserts 
0f76			; TODO check insert does not push beyond buffer 
0f76			; TODO scroll in a limited display area 
0f76			; TODO scroll whole screen on page wrap 
0f76			 
0f76			 
0f76			; TODO handle KEY_PREVWORD 
0f76			; TODO handle KEY_NEXTWORD 
0f76			; TODO handle KEY_HOME 
0f76			; TODO handle KEY_END 
0f76			; TODO use LCD cursor? 
0f76			 
0f76 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f79 81					add c 
0f7a 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f7d 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0f80 79					ld a, c 
0f81 cd 49 0f				call addatohl 
0f84 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f87 7a					ld a,d 
0f88 32 af fe			        ld (input_size), a       ; save length of input area 
0f8b 79					ld a, c 
0f8c 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0f8f 7b					ld a,e 
0f90 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f93					 
0f93					 
0f93			 
0f93			;		ld a,(input_ptr) 
0f93			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f93			 
0f93			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f93					; init cursor shape if not set by the cin routines 
0f93 21 4d fd				ld hl, cursor_shape 
0f96 3e ff				ld a, 255 
0f98 77					ld (hl), a 
0f99 23					inc hl 
0f9a 3e 00				ld a, 0 
0f9c 77					ld (hl), a 
0f9d			 
0f9d 3e 0f				ld a, CUR_BLINK_RATE 
0f9f 32 a9 fe				ld (input_cur_flash), a 
0fa2 3e 01				ld a, 1 
0fa4 32 a8 fe				ld (input_cur_onoff),a 
0fa7			 
0fa7			;	if DEBUG_INPUT 
0fa7			;		push af 
0fa7			;		ld a, 'I' 
0fa7			;		ld (debug_mark),a 
0fa7			;		pop af 
0fa7			;		CALLMONITOR 
0fa7			;	endif 
0fa7			.is1:		; main entry loop 
0fa7			 
0fa7			 
0fa7			 
0fa7					; pause 1ms 
0fa7			 
0fa7 3e 01				ld a, 1 
0fa9 cd 77 0c				call aDelayInMS 
0fac			 
0fac					; dec flash counter 
0fac 3a a9 fe				ld a, (input_cur_flash) 
0faf 3d					dec a 
0fb0 32 a9 fe				ld (input_cur_flash), a 
0fb3 fe 00				cp 0 
0fb5 20 0d				jr nz, .nochgstate 
0fb7			 
0fb7			 
0fb7					; change state 
0fb7 3a a8 fe				ld a,(input_cur_onoff) 
0fba ed 44				neg 
0fbc 32 a8 fe				ld (input_cur_onoff),a 
0fbf			 
0fbf			 
0fbf					; reset on change of state 
0fbf 3e 0f				ld a, CUR_BLINK_RATE 
0fc1 32 a9 fe				ld (input_cur_flash), a 
0fc4			 
0fc4			.nochgstate: 
0fc4					 
0fc4					 
0fc4			 
0fc4					; display cursor  
0fc4			 
0fc4			;		ld hl, (input_start) 
0fc4			;		ld a, (input_cursor) 
0fc4			;		call addatohl 
0fc4			 
0fc4					; get char under cursor and replace with cursor 
0fc4 2a b2 fe		ld hl, (input_ptr) 
0fc7			;		ld a, (hl) 
0fc7			;		ld (input_under_cursor),a 
0fc7			;		ld a, '_' 
0fc7			;		ld (hl), a 
0fc7			 
0fc7					; display string 
0fc7			 
0fc7 ed 5b b0 fe			ld de, (input_start) 
0fcb 3a ad fe				ld a, (input_at_pos) 
0fce cd 28 0d				call str_at_display 
0fd1			;	        call update_display 
0fd1			 
0fd1					; find place to put the cursor 
0fd1			;		add h 
0fd1			;		ld l, display_row_1 
0fd1			;		sub l 
0fd1			; (input_at_pos) 
0fd1					;ld c, a 
0fd1			;		ld a, (input_cursor) 
0fd1			;		ld l, (input_at_pos) 
0fd1			;		;ld b, h 
0fd1			;		add l 
0fd1			;		ld (input_at_cursor),a 
0fd1					;ld l,h 
0fd1			 
0fd1			;		ld h, 0 
0fd1			;		ld l,(input_at_pos) 
0fd1			;		ld a, (input_cursor) 
0fd1			;		call addatohl 
0fd1			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd1			;		call subafromhl 
0fd1			;		ld a,l 
0fd1			;		ld (input_at_cursor), a 
0fd1			 
0fd1				if DEBUG_INPUT 
0fd1					ld a, (hardware_diag) 
0fd1					cp 0 
0fd1					jr z, .skip_input_diag 
0fd1			 
0fd1					ld a,(input_at_pos) 
0fd1					ld hl, LFSRSeed 
0fd1					call hexout 
0fd1					ld a, (input_cursor) 
0fd1					ld hl, LFSRSeed+2 
0fd1					call hexout 
0fd1					ld a,(input_at_cursor) 
0fd1					ld hl, LFSRSeed+4 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_onoff) 
0fd1					ld hl, LFSRSeed+6 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_flash) 
0fd1					ld hl, LFSRSeed+8 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_len) 
0fd1					ld hl, LFSRSeed+10 
0fd1					call hexout 
0fd1					ld hl, LFSRSeed+12 
0fd1					ld a, 0 
0fd1					ld (hl),a 
0fd1					ld a, display_row_4 
0fd1					ld de, LFSRSeed 
0fd1					call str_at_display 
0fd1					.skip_input_diag: 
0fd1				endif 
0fd1			 
0fd1					; decide on if we are showing the cursor this time round 
0fd1			 
0fd1 3a a8 fe				ld a, (input_cur_onoff) 
0fd4 fe ff				cp 255 
0fd6 28 13				jr z, .skipcur 
0fd8			 
0fd8			 
0fd8 3a ab fe				ld a,(input_at_cursor) 
0fdb 11 4d fd				ld de, cursor_shape 
0fde cd 28 0d				call str_at_display 
0fe1			 
0fe1					; save length of current input string 
0fe1 2a b0 fe				ld hl, (input_start) 
0fe4 cd a7 13				call strlenz 
0fe7 7d					ld a,l 
0fe8 32 a3 fe				ld (input_len),a 
0feb			 
0feb			.skipcur: 
0feb			 
0feb cd 38 0d			        call update_display 
0fee					 
0fee			 
0fee			 
0fee					; wait 
0fee				 
0fee					; TODO loop without wait to flash the cursor and char under cursor	 
0fee cd 3a 73				call cin    ; _wait 
0ff1			 
0ff1 fe 00				cp 0 
0ff3 ca a7 0f				jp z, .is1 
0ff6			 
0ff6					; get ptr to char to input into 
0ff6			 
0ff6 4f					ld c,a 
0ff7 2a b0 fe				ld hl, (input_start) 
0ffa 3a 9e fe				ld a, (input_cursor) 
0ffd cd 49 0f				call addatohl 
1000 22 b2 fe				ld (input_ptr), hl 
1003 79					ld a,c 
1004			 
1004					; replace char under cursor 
1004			 
1004			;		ld hl, (input_ptr) 
1004			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1004			;		ld (hl), a 
1004			 
1004			;	if DEBUG_INPUT 
1004			;		push af 
1004			;		ld a, 'i' 
1004			;		ld (debug_mark),a 
1004			;		pop af 
1004			;		CALLMONITOR 
1004			;	endif 
1004 fe 0e				cp KEY_HOME 
1006 20 0e				jr nz, .iske 
1008			 
1008 3a ad fe				ld a, (input_at_pos) 
100b 32 ab fe				ld (input_at_cursor),a 
100e 3e 00				ld a, 0 
1010 32 9e fe				ld (input_cursor), a 
1013 c3 a7 0f				jp .is1 
1016					 
1016 fe 0f		.iske:		cp KEY_END 
1018 20 03				jr nz, .isknw 
101a c3 a7 0f				jp .is1 
101d			 
101d fe 06		.isknw:		cp KEY_NEXTWORD 
101f 20 1b				jr nz, .iskpw 
1021			 
1021 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
1024 7e					ld a,(hl)	 
1025 fe 00				cp 0 
1027 ca a7 0f				jp z, .is1    ; end of string 
102a fe 20				cp ' ' 
102c ca a7 0f				jp z, .is1    ; end of word 
102f 23					inc hl 
1030 22 b2 fe				ld (input_ptr), hl 
1033 3a ab fe				ld a, (input_at_cursor) 
1036 3c					inc a 
1037 32 ab fe				ld (input_at_cursor), a 
103a 18 e5				jr .isknwm 
103c			 
103c fe 07		.iskpw:		cp KEY_PREVWORD 
103e 20 1b				jr nz, .iskl 
1040			.iskpwm:	 
1040 2a b2 fe				ld hl, (input_ptr) 
1043 7e					ld a,(hl)	 
1044 fe 00				cp 0  
1046 ca a7 0f				jp z, .is1    ; end of string 
1049 fe 20				cp ' ' 
104b ca a7 0f				jp z, .is1    ; end of word 
104e 2b					dec hl 
104f 22 b2 fe				ld (input_ptr), hl 
1052 3a ab fe				ld a, (input_at_cursor) 
1055 3d					dec a 
1056 32 ab fe				ld (input_at_cursor), a 
1059 18 e5				jr .iskpwm 
105b			 
105b			 
105b fe 0b		.iskl:		cp KEY_LEFT 
105d 20 27				jr nz, .isk1 
105f			 
105f 3a 9e fe				ld a, (input_cursor) 
1062			 
1062 fe 00				cp 0 
1064 ca a7 0f				jp z, .is1 		; at start of line to ignore  
1067			 
1067 3d					dec  a 		; TODO check underflow 
1068 32 9e fe				ld (input_cursor), a 
106b			 
106b 2a b2 fe				ld hl, (input_ptr) 
106e 2b					dec hl 
106f 22 b2 fe				ld (input_ptr), hl 
1072					 
1072 3a ab fe				ld a, (input_at_cursor) 
1075 3d					dec a 
1076 32 ab fe				ld (input_at_cursor), a 
1079			 
1079 3e 01				ld a, 1		; show cursor moving 
107b 32 a8 fe				ld (input_cur_onoff),a 
107e 3e 0f				ld a, CUR_BLINK_RATE 
1080 32 a9 fe				ld (input_cur_flash), a 
1083			 
1083 c3 a7 0f				jp .is1 
1086			 
1086 fe 0c		.isk1:		cp KEY_RIGHT 
1088 20 2a				jr nz, .isk2 
108a			 
108a 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
108d 5f					ld e,a 
108e 3a 9e fe				ld a, (input_cursor) 
1091 bb					cp e 
1092 ca a7 0f				jp z, .is1		; at the end of string so dont go right 
1095			 
1095 3c					inc  a 		; TODO check overflow 
1096 32 9e fe				ld (input_cursor), a 
1099			 
1099 3a ab fe				ld a, (input_at_cursor) 
109c 3c					inc a 
109d 32 ab fe				ld (input_at_cursor), a 
10a0			 
10a0 2a b2 fe				ld hl, (input_ptr) 
10a3 23					inc hl 
10a4 22 b2 fe				ld (input_ptr), hl 
10a7			 
10a7 3e 01				ld a, 1		; show cursor moving 
10a9 32 a8 fe				ld (input_cur_onoff),a 
10ac 3e 0f				ld a, CUR_BLINK_RATE 
10ae 32 a9 fe				ld (input_cur_flash), a 
10b1			 
10b1 c3 a7 0f				jp .is1 
10b4			 
10b4 fe 05		.isk2:		cp KEY_UP 
10b6			 
10b6 20 26				jr nz, .isk3 
10b8			 
10b8					; swap last command with the current on 
10b8			 
10b8					; move cursor to start of string 
10b8 2a b0 fe				ld hl, (input_start) 
10bb 22 b2 fe				ld (input_ptr), hl 
10be			 
10be 3a ad fe				ld a, (input_at_pos) 
10c1 32 ab fe				ld (input_at_cursor), a 
10c4			 
10c4 3e 00				ld a, 0 
10c6 32 9e fe				ld (input_cursor), a 
10c9					 
10c9					; swap input and last command buffers 
10c9			 
10c9 21 75 f6				ld hl, os_cli_cmd 
10cc 11 74 f7				ld de, os_last_cmd 
10cf 06 ff				ld b, 255 
10d1 7e			.swap1:		ld a, (hl) 
10d2 4f					ld c,a 
10d3 1a					ld a, (de) 
10d4 77					ld (hl), a 
10d5 79					ld a,c 
10d6 12					ld (de),a 
10d7 23					inc hl 
10d8 13					inc de 
10d9 10 f6				djnz .swap1 
10db			 
10db			 
10db			 
10db			 
10db			 
10db c3 a7 0f				jp .is1 
10de			 
10de fe 08		.isk3:		cp KEY_BS 
10e0 20 3c				jr nz, .isk4 
10e2			 
10e2 3a 9e fe				ld a, (input_cursor) 
10e5			 
10e5 fe 00				cp 0 
10e7 ca a7 0f				jp z, .is1 		; at start of line to ignore  
10ea			 
10ea 3d					dec  a 		; TODO check underflow 
10eb 32 9e fe				ld (input_cursor), a 
10ee			 
10ee					; hl is source 
10ee					; de needs to be source - 1 
10ee			 
10ee			;		ld a, 0 
10ee			;		dec hl 
10ee			;		ld (hl), a 
10ee			 
10ee 2a b2 fe				ld hl, (input_ptr) 
10f1 2b					dec hl 
10f2 22 b2 fe				ld (input_ptr), hl 
10f5			 
10f5					; shift all data 
10f5			 
10f5 e5					push hl 
10f6 23					inc hl 
10f7 d1					pop de 
10f8 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fb 4f					ld c,a 
10fc 06 00				ld b,0 
10fe ed b0				ldir  
1100			 
1100			 
1100			 
1100			 
1100 3a ab fe				ld a, (input_at_cursor) 
1103 3d					dec a 
1104 32 ab fe				ld (input_at_cursor), a 
1107			 
1107			 
1107 3e 01				ld a, 1		; show cursor moving 
1109 32 a8 fe				ld (input_cur_onoff),a 
110c 3e 0f				ld a, CUR_BLINK_RATE 
110e 32 a9 fe				ld (input_cur_flash), a 
1111			 
1111					; remove char 
1111 3a ab fe				ld a, (input_at_cursor) 
1114 3c					inc a 
1115 11 9f 11				ld de,.iblank 
1118 cd 28 0d				call str_at_display 
111b			 
111b c3 a7 0f				jp .is1 
111e			 
111e fe 0d		.isk4:		cp KEY_CR 
1120 28 6c				jr z, .endinput 
1122			 
1122					; else add the key press to the end 
1122			 
1122 4f					ld c, a			; save key pressed 
1123			 
1123 7e					ld a,(hl)		; get what is currently under char 
1124			 
1124 fe 00				cp 0			; we are at the end of the string 
1126 20 2f				jr nz, .onchar 
1128					 
1128					; add a char to the end of the string 
1128				 
1128 71					ld (hl),c 
1129 23					inc hl 
112a			;		ld a,' ' 
112a			;		ld (hl),a 
112a			;		inc hl 
112a 3e 00				ld a,0 
112c 77					ld (hl),a 
112d 2b					dec hl 
112e			 
112e 3a 9e fe				ld a, (input_cursor) 
1131 3c					inc a				; TODO check max string length and scroll  
1132 32 9e fe				ld (input_cursor), a		; inc cursor pos 
1135							 
1135 3a ab fe				ld a, (input_at_cursor) 
1138 3c					inc a 
1139 32 ab fe				ld (input_at_cursor), a 
113c			 
113c 2a b2 fe				ld hl, (input_ptr) 
113f 23					inc hl 
1140 22 b2 fe				ld (input_ptr), hl 
1143			 
1143 2a b2 fe				ld hl, (input_ptr) 
1146 23					inc hl 
1147 22 b2 fe				ld (input_ptr), hl 
114a			;	if DEBUG_INPUT 
114a			;		push af 
114a			;		ld a, '+' 
114a			;		ld (debug_mark),a 
114a			;		pop af 
114a			;		CALLMONITOR 
114a			;	endif 
114a 3e 01				ld a, 1		; show cursor moving 
114c 32 a8 fe				ld (input_cur_onoff),a 
114f 3e 0f				ld a, CUR_BLINK_RATE 
1151 32 a9 fe				ld (input_cur_flash), a 
1154 c3 a7 0f				jp .is1 
1157					 
1157			 
1157			 
1157					; if on a char then insert 
1157			.onchar: 
1157			 
1157					; TODO over flow check: make sure insert does not blow out buffer 
1157			 
1157					; need to do some maths to use lddr 
1157			 
1157 e5					push hl   ; save char pos 
1158 c5					push bc 
1159			 
1159 2a b0 fe				ld hl, (input_start) 
115c 3a a3 fe				ld a, (input_len) 
115f cd 49 0f				call addatohl  		; end of string 
1162 23					inc hl 
1163 23					inc hl		; past zero term 
1164 e5					push hl 
1165 23					inc hl 
1166 e5					push hl  
1167			 
1167								; start and end of lddr set, now how much to move? 
1167			 
1167							 
1167 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116a 47					ld b,a 
116b 3a a3 fe				ld a,(input_len) 
116e 5f					ld e,a 
116f 90					sub b 
1170 3c					inc a		;?? 
1171 3c					inc a		;?? 
1172 3c					inc a		;?? 
1173			 
1173 06 00				ld b,0 
1175 4f					ld c,a 
1176			 
1176				if DEBUG_INPUT 
1176					push af 
1176					ld a, 'i' 
1176					ld (debug_mark),a 
1176					pop af 
1176			;		CALLMONITOR 
1176				endif 
1176 d1					pop de 
1177 e1					pop hl 
1178				if DEBUG_INPUT 
1178					push af 
1178					ld a, 'I' 
1178					ld (debug_mark),a 
1178					pop af 
1178			;		CALLMONITOR 
1178				endif 
1178 ed b8				lddr 
117a				 
117a			 
117a			 
117a					; TODO have a key for insert/overwrite mode???? 
117a c1					pop bc 
117b e1					pop hl 
117c 71					ld (hl), c		; otherwise overwrite current char 
117d					 
117d			 
117d			 
117d			 
117d 3a 9e fe				ld a, (input_cursor) 
1180 3c					inc  a 		; TODO check overflow 
1181 32 9e fe				ld (input_cursor), a 
1184			 
1184 3a ab fe				ld a, (input_at_cursor) 
1187 3c					inc a 
1188 32 ab fe				ld (input_at_cursor), a 
118b			 
118b c3 a7 0f				jp .is1 
118e			 
118e			.endinput:	; TODO look for end of string 
118e			 
118e					; add trailing space for end of token 
118e			 
118e 2a b0 fe				ld hl, (input_start) 
1191 3a a3 fe				ld a,(input_len) 
1194 cd 49 0f				call addatohl 
1197 3e 20				ld a, ' ' 
1199 77					ld (hl),a 
119a					; TODO eof of parse marker 
119a			 
119a 23					inc hl 
119b 3e 00				ld a, 0 
119d 77					ld (hl),a 
119e			 
119e			 
119e c9					ret 
119f			 
119f .. 00		.iblank: db " ",0 
11a1			 
11a1			 
11a1 32 ad fe		input_str_prev:	ld (input_at_pos), a 
11a4 22 b0 fe				ld (input_start), hl 
11a7 3e 01				ld a,1			; add cursor 
11a9 77					ld (hl),a 
11aa 23					inc hl 
11ab 3e 00				ld a,0 
11ad 77					ld (hl),a 
11ae 22 b2 fe				ld (input_ptr), hl 
11b1 7a					ld a,d 
11b2 32 af fe				ld (input_size), a 
11b5 3e 00				ld a,0 
11b7 32 9e fe				ld (input_cursor),a 
11ba			.instr1:	 
11ba			 
11ba					; TODO do block cursor 
11ba					; TODO switch cursor depending on the modifer key 
11ba			 
11ba					; update cursor shape change on key hold 
11ba			 
11ba 2a b2 fe				ld hl, (input_ptr) 
11bd 2b					dec hl 
11be 3a 4d fd				ld a,(cursor_shape) 
11c1 77					ld (hl), a 
11c2			 
11c2					; display entered text 
11c2 3a ad fe				ld a,(input_at_pos) 
11c5 cd 58 72		            	CALL fLCD_Pos       ;Position cursor to location in A 
11c8 ed 5b b0 fe	            	LD   de, (input_start) 
11cc cd 60 72		            	CALL fLCD_Str       ;Display string pointed to by DE 
11cf			 
11cf cd 3a 73				call cin 
11d2 fe 00				cp 0 
11d4 28 e4				jr z, .instr1 
11d6			 
11d6					; proecess keyboard controls first 
11d6			 
11d6 2a b2 fe				ld hl,(input_ptr) 
11d9			 
11d9 fe 0d				cp KEY_CR	 ; pressing enter ends input 
11db 28 5a				jr z, .instrcr 
11dd			 
11dd fe 08				cp KEY_BS 	; back space 
11df 20 0f				jr nz, .instr2 
11e1					; process back space 
11e1			 
11e1					; TODO stop back space if at start of string 
11e1 2b					dec hl 
11e2 2b					dec hl ; to over write cursor 
11e3 3a 4d fd				ld a,(cursor_shape) 
11e6					;ld a,0 
11e6 77					ld (hl),a 
11e7 23					inc hl 
11e8 3e 20				ld a," " 
11ea 77					ld (hl),a 
11eb 22 b2 fe				ld (input_ptr),hl 
11ee					 
11ee			 
11ee 18 ca				jr .instr1 
11f0			 
11f0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f2 20 06				jr nz, .instr3 
11f4 2b					dec hl 
11f5 22 b2 fe				ld (input_ptr),hl 
11f8 18 c0				jr .instr1 
11fa				 
11fa fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11fc 20 06				jr nz, .instr4 
11fe 23					inc hl 
11ff 22 b2 fe				ld (input_ptr),hl 
1202 18 b6				jr .instr1 
1204			 
1204 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1206 20 06				jr nz, .instr5 
1208 2b					dec hl 
1209 22 b2 fe				ld (input_ptr),hl 
120c 18 ac				jr .instr1 
120e			 
120e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1210 20 06				jr nz, .instr6 
1212 2b					dec hl 
1213 22 b2 fe				ld (input_ptr),hl 
1216 18 a2				jr .instr1 
1218 fe 05		.instr6:        cp KEY_UP      ; recall last command 
121a 20 0b				jr nz, .instrnew 
121c			 
121c 21 4e f3			ld hl, scratch 
121f 11 74 f7			ld de, os_last_cmd 
1222 cd 40 12			call strcpy 
1225 18 93				jr .instr1 
1227			 
1227			 
1227			.instrnew:	; no special key pressed to see if we have room to store it 
1227			 
1227					; TODO do string size test 
1227			 
1227 2b					dec hl ; to over write cursor 
1228 77					ld (hl),a 
1229 23					inc hl 
122a 3a 4d fd				ld a,(cursor_shape) 
122d 77					ld (hl),a 
122e 23					inc hl 
122f 3e 00				ld a,0 
1231 77					ld (hl),a 
1232			 
1232 22 b2 fe				ld (input_ptr),hl 
1235					 
1235 18 83				jr .instr1 
1237 2b			.instrcr:	dec hl		; remove cursor 
1238 3e 20				ld a,' '	; TODO add a trailing space for safety 
123a 77					ld (hl),a 
123b 23					inc hl 
123c 3e 00				ld a,0 
123e 77					ld (hl),a 
123f			 
123f			 
123f					; if at end of line scroll up    
123f					; TODO detecting only end of line 4 for scroll up  
123f			 
123f					;ld   
123f			 
123f c9					ret 
1240			 
1240			 
1240			; strcpy hl = dest, de source 
1240			 
1240 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1241 b7			            OR   A              ;Null terminator? 
1242 c8			            RET  Z              ;Yes, so finished 
1243 1a					ld a,(de) 
1244 77					ld (hl),a 
1245 13			            INC  DE             ;Point to next character 
1246 23					inc hl 
1247 18 f7		            JR   strcpy       ;Repeat 
1249 c9					ret 
124a			 
124a			 
124a			; TODO string_at  
124a			; pass string which starts with lcd offset address and then null term string 
124a			 
124a			; TODO string to dec 
124a			; TODO string to hex 
124a			; TODO byte to string hex 
124a			; TODO byte to string dec 
124a			 
124a			 
124a			 
124a			; from z80uartmonitor 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124a			; pass hl for where to put the text 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a c5			hexout:	PUSH BC 
124b f5					PUSH AF 
124c 47					LD B, A 
124d					; Upper nybble 
124d cb 3f				SRL A 
124f cb 3f				SRL A 
1251 cb 3f				SRL A 
1253 cb 3f				SRL A 
1255 cd 65 12				CALL tohex 
1258 77					ld (hl),a 
1259 23					inc hl	 
125a					 
125a					; Lower nybble 
125a 78					LD A, B 
125b e6 0f				AND 0FH 
125d cd 65 12				CALL tohex 
1260 77					ld (hl),a 
1261 23					inc hl	 
1262					 
1262 f1					POP AF 
1263 c1					POP BC 
1264 c9					RET 
1265					 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			tohex: 
1265 e5					PUSH HL 
1266 d5					PUSH DE 
1267 16 00				LD D, 0 
1269 5f					LD E, A 
126a 21 72 12				LD HL, .DATA 
126d 19					ADD HL, DE 
126e 7e					LD A, (HL) 
126f d1					POP DE 
1270 e1					POP HL 
1271 c9					RET 
1272			 
1272			.DATA: 
1272 30					DEFB	30h	; 0 
1273 31					DEFB	31h	; 1 
1274 32					DEFB	32h	; 2 
1275 33					DEFB	33h	; 3 
1276 34					DEFB	34h	; 4 
1277 35					DEFB	35h	; 5 
1278 36					DEFB	36h	; 6 
1279 37					DEFB	37h	; 7 
127a 38					DEFB	38h	; 8 
127b 39					DEFB	39h	; 9 
127c 41					DEFB	41h	; A 
127d 42					DEFB	42h	; B 
127e 43					DEFB	43h	; C 
127f 44					DEFB	44h	; D 
1280 45					DEFB	45h	; E 
1281 46					DEFB	46h	; F 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1282			;;    subtract $30, if result > 9 then subtract $7 more 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			atohex: 
1282 d6 30				SUB $30 
1284 fe 0a				CP 10 
1286 f8					RET M		; If result negative it was 0-9 so we're done 
1287 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1289 c9					RET		 
128a			 
128a			 
128a			 
128a			 
128a			; Get 2 ASCII characters as hex byte from pointer in hl 
128a			 
128a			BYTERD: 
128a 16 00			LD	D,00h		;Set up 
128c cd 94 12			CALL	HEXCON		;Get byte and convert to hex 
128f 87				ADD	A,A		;First nibble so 
1290 87				ADD	A,A		;multiply by 16 
1291 87				ADD	A,A		; 
1292 87				ADD	A,A		; 
1293 57				LD	D,A		;Save hi nibble in D 
1294			HEXCON: 
1294 7e				ld a, (hl)		;Get next chr 
1295 23				inc hl 
1296 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1298 fe 0a			CP	00Ah		;Is it 0-9 ? 
129a 38 02			JR	C,NALPHA	;If so miss next bit 
129c d6 07			SUB	007h		;Else convert alpha 
129e			NALPHA: 
129e b2				OR	D		;Add hi nibble back 
129f c9				RET			; 
12a0			 
12a0			 
12a0			; 
12a0			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a0			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a0			; characters (0-9a-f) are accepted. 
12a0			; 
12a0			;get_word        push    af 
12a0			;                call    get_byte        ; Get the upper byte 
12a0			;                ld      h, a 
12a0			;                call    get_byte        ; Get the lower byte 
12a0			;                ld      l, a 
12a0			;                pop     af 
12a0			;                ret 
12a0			; 
12a0			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a0			; the routine get_nibble is used only valid characters are accepted - the  
12a0			; input routine only accepts characters 0-9a-f. 
12a0			; 
12a0 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a1 7e					ld a,(hl) 
12a2 23					inc hl 
12a3 cd c8 12		                call    nibble2val      ; Get upper nibble 
12a6 cb 07		                rlc     a 
12a8 cb 07		                rlc     a 
12aa cb 07		                rlc     a 
12ac cb 07		                rlc     a 
12ae 47			                ld      b, a            ; Save upper four bits 
12af 7e					ld a,(hl) 
12b0 cd c8 12		                call    nibble2val      ; Get lower nibble 
12b3 b0			                or      b               ; Combine both nibbles 
12b4 c1			                pop     bc              ; Restore B (and C) 
12b5 c9			                ret 
12b6			; 
12b6			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b6			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b6			; to the serial line interface. The lower 4 bits of A contain the value of  
12b6			; that particular digit. 
12b6			; 
12b6			;get_nibble      ld a,(hl)           ; Read a character 
12b6			;                call    to_upper        ; Convert to upper case 
12b6			;                call    is_hex          ; Was it a hex digit? 
12b6			;                jr      nc, get_nibble  ; No, get another character 
12b6			 ;               call    nibble2val      ; Convert nibble to value 
12b6			 ;               call    print_nibble 
12b6			 ;               ret 
12b6			; 
12b6			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b6			; A valid hexadecimal digit is denoted by a set C flag. 
12b6			; 
12b6			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b6			;                ret     nc              ; Yes 
12b6			;                cp      '0'             ; Less than '0'? 
12b6			;                jr      nc, is_hex_1    ; No, continue 
12b6			;                ccf                     ; Complement carry (i.e. clear it) 
12b6			;                ret 
12b6			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b6			;                ret     c               ; Yes 
12b6			;                cp      'A'             ; Less than 'A'? 
12b6			;                jr      nc, is_hex_2    ; No, continue 
12b6			;                ccf                     ; Yes - clear carry and return 
12b6			;                ret 
12b6			;is_hex_2        scf                     ; Set carry 
12b6			;                ret 
12b6			; 
12b6			; Convert a single character contained in A to upper case: 
12b6			; 
12b6 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12b8 d8			                ret     c 
12b9 fe 7b		                cp      'z' + 1         ; > 'z'? 
12bb d0			                ret     nc              ; Nothing to do, either 
12bc e6 5f		                and     $5f             ; Convert to upper case 
12be c9			                ret 
12bf			 
12bf			 
12bf			to_lower: 
12bf			 
12bf			   ; if char is in [A-Z] make it lower case 
12bf			 
12bf			   ; enter : a = char 
12bf			   ; exit  : a = lower case char 
12bf			   ; uses  : af 
12bf			 
12bf fe 41		   cp 'A' 
12c1 d8			   ret c 
12c2			    
12c2 fe 5b		   cp 'Z'+1 
12c4 d0			   ret nc 
12c5			    
12c5 f6 20		   or $20 
12c7 c9			   ret 
12c8			 
12c8			; 
12c8			; Expects a hexadecimal digit (upper case!) in A and returns the 
12c8			; corresponding value in A. 
12c8			; 
12c8 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12ca 38 02		                jr      c, nibble2val_1 ; Yes 
12cc d6 07		                sub     7               ; Adjust for A-F 
12ce d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d0 e6 0f		                and     $f              ; Only return lower 4 bits 
12d2 c9			                ret 
12d3			; 
12d3			; Print_nibble prints a single hex nibble which is contained in the lower  
12d3			; four bits of A: 
12d3			; 
12d3			;print_nibble    push    af              ; We won't destroy the contents of A 
12d3			;                and     $f              ; Just in case... 
12d3			;                add     a, '0'             ; If we have a digit we are done here. 
12d3			;                cp      '9' + 1         ; Is the result > 9? 
12d3			;                jr      c, print_nibble_1 
12d3			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d3			;print_nibble_1  call    putc            ; Print the nibble and 
12d3			;                pop     af              ; restore the original value of A 
12d3			;                ret 
12d3			;; 
12d3			;; Send a CR/LF pair: 
12d3			; 
12d3			;crlf            push    af 
12d3			;                ld      a, cr 
12d3			;                call    putc 
12d3			;                ld      a, lf 
12d3			;                call    putc 
12d3			;                pop     af 
12d3			;                ret 
12d3			; 
12d3			; Print_word prints the four hex digits of a word to the serial line. The  
12d3			; word is expected to be in HL. 
12d3			; 
12d3			;print_word      push    hl 
12d3			;                push    af 
12d3			;                ld      a, h 
12d3			;                call    print_byte 
12d3			;                ld      a, l 
12d3			;                call    print_byte 
12d3			;                pop     af 
12d3			;                pop     hl 
12d3			;                ret 
12d3			; 
12d3			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d3			; The byte to be printed is expected to be in A. 
12d3			; 
12d3			;print_byte      push    af              ; Save the contents of the registers 
12d3			;                push    bc 
12d3			;                ld      b, a 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                call    print_nibble    ; Print high nibble 
12d3			;                ld      a, b 
12d3			;                call    print_nibble    ; Print low nibble 
12d3			;                pop     bc              ; Restore original register contents 
12d3			;                pop     af 
12d3			;                ret 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			fourehexhl:  
12d3 7e				ld a,(hl) 
12d4 cd 82 12			call atohex 
12d7 cb 3f				SRL A 
12d9 cb 3f				SRL A 
12db cb 3f				SRL A 
12dd cb 3f				SRL A 
12df 47				ld b, a 
12e0 23				inc hl 
12e1 7e				ld a,(hl) 
12e2 23				inc hl 
12e3 cd 82 12			call atohex 
12e6 80				add b 
12e7 57				ld d,a 
12e8 7e				ld a,(hl) 
12e9 cd 82 12			call atohex 
12ec cb 3f				SRL A 
12ee cb 3f				SRL A 
12f0 cb 3f				SRL A 
12f2 cb 3f				SRL A 
12f4 47				ld b, a 
12f5 23				inc hl 
12f6 7e				ld a,(hl) 
12f7 23				inc hl 
12f8 cd 82 12			call atohex 
12fb 80				add b 
12fc 5f				ld e, a 
12fd d5				push de 
12fe e1				pop hl 
12ff c9				ret 
1300			 
1300			; pass hl. returns z set if the byte at hl is a digit 
1300			;isdigithl:  
1300			;	push bc 
1300			;	ld a,(hl) 
1300			;	cp ':' 
1300			;	jr nc, .isdf 		; > 
1300			;	cp '0' 
1300			;	jr c, .isdf		; < 
1300			; 
1300			;	; TODO find a better way to set z 
1300			; 
1300			;	ld b,a 
1300			;	cp b 
1300			;	pop bc 
1300			;	ret 
1300			; 
1300			;.isdf:	; not digit so clear z 
1300			; 
1300			;	; TODO find a better way to unset z 
1300			; 
1300			;	ld b,a 
1300			;	inc b 
1300			;	cp b 
1300			; 
1300			;	pop bc 
1300			;	ret 
1300				 
1300				 
1300			 
1300			 
1300			; pass hl as the four byte address to load 
1300			 
1300			get_word_hl:  
1300 e5				push hl 
1301 cd a0 12			call get_byte 
1304				 
1304 47				ld b, a 
1305			 
1305 e1				pop hl 
1306 23				inc hl 
1307 23				inc hl 
1308			 
1308			; TODO not able to handle a-f  
1308 7e				ld a,(hl) 
1309			;	;cp ':' 
1309			;	cp 'g' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp 'G' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp '0' 
1309			;	jr c, .single_byte_hl		; < 
1309			 
1309				;call isdigithl 
1309 fe 00			cp 0 
130b 28 06			jr z, .single_byte_hl 
130d			 
130d			.getwhln:   ; hex word so get next byte 
130d			 
130d cd a0 12			call get_byte 
1310 6f				ld l, a 
1311 60				ld h,b 
1312 c9				ret 
1313 68			.single_byte_hl:   ld l,b 
1314 26 00				ld h,0 
1316 c9					ret 
1317			 
1317			 
1317			 
1317			 
1317 21 51 1c			ld hl,asc+1 
131a			;	ld a, (hl) 
131a			;	call nibble2val 
131a cd a0 12			call get_byte 
131d			 
131d			;	call fourehexhl 
131d 32 82 f3			ld (scratch+52),a 
1320				 
1320 21 80 f3			ld hl,scratch+50 
1323 22 71 f6			ld (os_cur_ptr),hl 
1326			 
1326 c9				ret 
1327			 
1327			 
1327			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1327			 
1327			; Decimal Unsigned Version 
1327			 
1327			;Number in a to decimal ASCII 
1327			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1327			;Example: display a=56 as "056" 
1327			;input: a = number 
1327			;Output: a=0,value of a in the screen 
1327			;destroys af,bc (don't know about hl and de) 
1327			DispAToASCII: 
1327 0e 9c			ld	c,-100 
1329 cd 33 13			call	.Na1 
132c 0e f6			ld	c,-10 
132e cd 33 13			call	.Na1 
1331 0e ff			ld	c,-1 
1333 06 2f		.Na1:	ld	b,'0'-1 
1335 04			.Na2:	inc	b 
1336 81				add	a,c 
1337 38 fc			jr	c,.Na2 
1339 91				sub	c		;works as add 100/10/1 
133a f5				push af		;safer than ld c,a 
133b 78				ld	a,b		;char is in b 
133c			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133c f1				pop af		;safer than ld a,c 
133d c9				ret 
133e			 
133e			; Decimal Signed Version 
133e			 
133e			; DispA 
133e			; -------------------------------------------------------------- 
133e			; Converts a signed integer value to a zero-terminated ASCII 
133e			; string representative of that value (using radix 10). 
133e			; -------------------------------------------------------------- 
133e			; INPUTS: 
133e			;     HL     Value to convert (two's complement integer). 
133e			;     DE     Base address of string destination. (pointer). 
133e			; -------------------------------------------------------------- 
133e			; OUTPUTS: 
133e			;     None 
133e			; -------------------------------------------------------------- 
133e			; REGISTERS/MEMORY DESTROYED 
133e			; AF HL 
133e			; -------------------------------------------------------------- 
133e			 
133e			;DispHLToASCII: 
133e			;   push    de 
133e			;   push    bc 
133e			; 
133e			;; Detect sign of HL. 
133e			;    bit    7, h 
133e			;    jr     z, ._DoConvert 
133e			; 
133e			;; HL is negative. Output '-' to string and negate HL. 
133e			;    ld     a, '-' 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			; 
133e			;; Negate HL (using two's complement) 
133e			;    xor    a 
133e			;    sub    l 
133e			;    ld     l, a 
133e			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
133e			;    sbc    a, h 
133e			;    ld     h, a 
133e			; 
133e			;; Convert HL to digit characters 
133e			;._DoConvert: 
133e			;    ld     b, 0     ; B will count character length of number 
133e			;-   ld     a, 10 
133e			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
133e			;    push   af 
133e			;    inc    b 
133e			;    ld     a, h 
133e			;    or     l 
133e			;    jr     nz, - 
133e			; 
133e			;; Retrieve digits from stack 
133e			;-   pop    af 
133e			;    or     $30 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			;    djnz   - 
133e			; 
133e			;; Terminate string with NULL 
133e			;    xor    a 
133e			;    ld     (de), a 
133e			; 
133e			;    pop    bc 
133e			;    pop    de 
133e			;    ret 
133e			 
133e			;Comments 
133e			; 
133e			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
133e			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
133e			;    Note that the output string will not be fixed-width. 
133e			; 
133e			;Example Usage 
133e			; 
133e			;    ld    hl, -1004 
133e			;    ld    de, OP1 
133e			;    call  DispA 
133e			;    ld    hl, OP1 
133e			;    syscall  PutS 
133e			 
133e			 
133e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
133e			 
133e			 
133e			;Converts an ASCII string to an unsigned 16-bit integer 
133e			;Quits when it reaches a non-decimal digit 
133e			 
133e			string_to_uint16: 
133e			atoui_16: 
133e			;Input: 
133e			;     DE points to the string 
133e			;Outputs: 
133e			;     HL is the result 
133e			;     A is the 8-bit value of the number 
133e			;     DE points to the byte after the number 
133e			;Destroys: 
133e			;     BC 
133e			;       if the string is non-empty, BC is HL/10 
133e			;Size:  24 bytes 
133e			;Speed: 42+d(104+{0,9}) 
133e			;       d is the number of digits in the number 
133e			;       max is 640 cycles for a 5 digit number 
133e			;Assuming no leading zeros: 
133e			;1 digit:  146cc 
133e			;2 digit:  250cc 
133e			;3 digit:  354cc or 363cc (avg: 354.126cc) 
133e			;4 digit:  458cc or 467cc (avg: 458.27cc) 
133e			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
133e			;avg: 544.81158447265625cc (544+13297/16384) 
133e			;=============================================================== 
133e 21 00 00		  ld hl,0 
1341			.u16a: 
1341 1a			  ld a,(de) 
1342 d6 30		  sub 30h 
1344 fe 0a		  cp 10 
1346 d0			  ret nc 
1347 13			  inc de 
1348 44			  ld b,h 
1349 4d			  ld c,l 
134a 29			  add hl,hl 
134b 29			  add hl,hl 
134c 09			  add hl,bc 
134d 29			  add hl,hl 
134e 85			  add a,l 
134f 6f			  ld l,a 
1350 30 ef		  jr nc,.u16a 
1352 24			  inc h 
1353 c3 41 13		  jp .u16a 
1356			 
1356			 
1356			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1356			 
1356			;written by Zeda 
1356			;Converts a 16-bit unsigned integer to an ASCII string. 
1356			 
1356			uitoa_16: 
1356			;Input: 
1356			;   DE is the number to convert 
1356			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1356			;Output: 
1356			;   HL points to the null-terminated ASCII string 
1356			;      NOTE: This isn't necessarily the same as the input HL. 
1356 d5			  push de 
1357 c5			  push bc 
1358 f5			  push af 
1359 eb			  ex de,hl 
135a			 
135a 01 f0 d8		  ld bc,-10000 
135d 3e 2f		  ld a,'0'-1 
135f 3c			  inc a 
1360 09			  add hl,bc  
1361 38 fc		   jr c,$-2 
1363 12			  ld (de),a 
1364 13			  inc de 
1365			 
1365 01 e8 03		  ld bc,1000 
1368 3e 3a		  ld a,'9'+1 
136a 3d			  dec a  
136b 09			  add hl,bc  
136c 30 fc		   jr nc,$-2 
136e 12			  ld (de),a 
136f 13			  inc de 
1370			 
1370 01 9c ff		  ld bc,-100 
1373 3e 2f		  ld a,'0'-1 
1375 3c			  inc a  
1376 09			  add hl,bc  
1377 38 fc		   jr c,$-2 
1379 12			  ld (de),a 
137a 13			  inc de 
137b			 
137b 7d			  ld a,l 
137c 26 3a		  ld h,'9'+1 
137e 25			  dec h  
137f c6 0a		  add a,10  
1381 30 fb		   jr nc,$-3 
1383 c6 30		  add a,'0' 
1385 eb			  ex de,hl 
1386 72			  ld (hl),d 
1387 23			  inc hl 
1388 77			  ld (hl),a 
1389 23			  inc hl 
138a 36 00		  ld (hl),0 
138c			 
138c			;Now strip the leading zeros 
138c 0e fa		  ld c,-6 
138e 09			  add hl,bc 
138f 3e 30		  ld a,'0' 
1391 23			  inc hl  
1392 be			  cp (hl)  
1393 28 fc		  jr z,$-2 
1395			 
1395			;Make sure that the string is non-empty! 
1395 7e			  ld a,(hl) 
1396 b7			  or a 
1397 20 01		  jr nz,.atoub 
1399 2b			  dec hl 
139a			.atoub: 
139a			 
139a f1			  pop af 
139b c1			  pop bc 
139c d1			  pop de 
139d c9			  ret 
139e			 
139e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
139e			 
139e			toUpper: 
139e			;A is the char. 
139e			;If A is a lowercase letter, this sets it to the matching uppercase 
139e			;18cc or 30cc or 41cc 
139e			;avg: 26.75cc 
139e fe 61		  cp 'a' 
13a0 d8			  ret c 
13a1 fe 7b		  cp 'z'+1 
13a3 d0			  ret nc 
13a4 d6 20		  sub 'a'-'A' 
13a6 c9			  ret 
13a7			 
13a7			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13a7			 
13a7			; String Length 
13a7			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13a7			 
13a7			; Get the length of the null-terminated string starting at $8000 hl 
13a7			;    LD     HL, $8000 
13a7			 
13a7			strlenz: 
13a7			 
13a7 af			    XOR    A               ; Zero is the value we are looking for. 
13a8 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13a9 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13aa			                           ; 65, 536 bytes (the entire addressable memory space). 
13aa ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13ac			 
13ac			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13ac 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13ad 6f			    LD     L, A             ; number of bytes 
13ae ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b0 2b			    DEC    HL              ; Compensate for null. 
13b1 c9				ret 
13b2			 
13b2			; Get the length of the A terminated string starting at $8000 hl 
13b2			;    LD     HL, $8000 
13b2			 
13b2			strlent: 
13b2			 
13b2			                  ; A is the value we are looking for. 
13b2 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b4 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b6			                           ; 65, 536 bytes (the entire addressable memory space). 
13b6 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13b8			 
13b8			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13b8 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13ba 2e 00		    LD     L, 0             ; number of bytes 
13bc ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13be 2b			    DEC    HL              ; Compensate for null. 
13bf c9				ret 
13c0			 
13c0			 
13c0			;Comparing Strings 
13c0			 
13c0			;IN    HL     Address of string1. 
13c0			;      DE     Address of string2. 
13c0			 
13c0			; doc given but wrong??? 
13c0			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c0			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c0			; tested 
13c0			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c0			 
13c0			strcmp_old: 
13c0 e5			    PUSH   HL 
13c1 d5			    PUSH   DE 
13c2			 
13c2 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c3 be			    CP     (HL)            ; (want to minimize work). 
13c4 38 01		    JR     C, Str1IsBigger 
13c6 7e			    LD     A, (HL) 
13c7			 
13c7			Str1IsBigger: 
13c7 4f			    LD     C, A             ; Put length in BC 
13c8 06 00		    LD     B, 0 
13ca 13			    INC    DE              ; Increment pointers to meat of string. 
13cb 23			    INC    HL 
13cc			 
13cc			CmpLoop: 
13cc 1a			    LD     A, (DE)          ; Compare bytes. 
13cd ed a1		    CPI 
13cf 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d1 13			    INC    DE              ; Update pointer. 
13d2 ea cc 13		    JP     PE, CmpLoop 
13d5			 
13d5 d1			    POP    DE 
13d6 e1			    POP    HL 
13d7 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13d8 be			    CP     (HL) 
13d9 c9			    RET 
13da			 
13da			NoMatch: 
13da 2b			    DEC    HL 
13db be			    CP     (HL)            ; Compare again to affect carry. 
13dc d1			    POP    DE 
13dd e1			    POP    HL 
13de c9			    RET 
13df			 
13df			;; test strmp 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr z, .z1 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z1: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr z, .z2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr c, .c1 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c1: 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr c, .c2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;	NEXTW 
13df			;.str1:   db "string1",0 
13df			;.str2:   db "string2",0 
13df			 
13df			; only care about direct match or not 
13df			; hl and de strings 
13df			; zero set if the same 
13df			 
13df			strcmp: 
13df 1a				ld a, (de) 
13e0 be				cp (hl) 
13e1 28 02			jr z, .ssame 
13e3 b7				or a 
13e4 c9				ret 
13e5			 
13e5			.ssame:  
13e5 fe 00			cp 0 
13e7 c8				ret z 
13e8			 
13e8 23				inc hl 
13e9 13				inc de 
13ea 18 f3			jr strcmp 
13ec				 
13ec				 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			; eof 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
# End of file firmware_strings.asm
13ec			include "firmware_memory.asm"   ; malloc and free  
13ec			 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			.mallocsize: db "Wants malloc >256",0 
13ec			.mallocasize: db "MALLOC gives >256",0 
13ec			.malloczero: db "MALLOC gives zero",0 
13ec			 
13ec			malloc_guard_zerolen: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec				ld de, 0 
13ec			        call cmp16 
13ec				jr nz, .lowalloz 
13ec			 
13ec				push hl 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .malloczero 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec			.lowalloz: 
13ec			 
13ec			 
13ec				pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_entry: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowalloc 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocsize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdone 
13ec			.lowalloc: 
13ec			 
13ec			 
13ec				pop hl 
13ec			.lowdone:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_exit: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowallocx 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocasize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdonex 
13ec			.lowallocx: 
13ec			 
13ec				pop hl 
13ec			.lowdonex:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			endif 
13ec			 
13ec			if MALLOC_2 
13ec			; Z80 Malloc and Free Functions 
13ec			 
13ec			; Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc: 
13ec				 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_entry 
13ec			endif 
13ec			 
13ec			 
13ec			 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "mal" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of size into A 
13ec			    or h               ; Check if size is zero 
13ec			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ec			 
13ec			    ; Allocate memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma1" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    call malloc_internal ; Call internal malloc function 
13ec			    pop af             ; Restore AF register 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret                ; Return 
13ec			 
13ec			; Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free: 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of pointer into A 
13ec			    or h               ; Check if pointer is NULL 
13ec			    jp z, free_exit    ; If pointer is NULL, exit 
13ec			 
13ec			    ; Free memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec			    call free_internal  ; Call internal free function 
13ec			    pop af             ; Restore AF register 
13ec			    ret                ; Return 
13ec			 
13ec			; Internal Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc_internal: 
13ec			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to requested size 
13ec			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			 
13ec			    ; Search for free memory block 
13ec			    ld de, (heap_end)  ; Load end of heap into DE 
13ec			    ld bc, 0           ; Initialize counter 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			malloc_search_loop: 
13ec			    ; Check if current block is free 
13ec			    ld a, (hl)         ; Load current block's status (free or used) 
13ec			    cp 0               ; Compare with zero (free) 
13ec			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ec			 
13ec			    ; Check if current block is large enough 
13ec			    ld a, (hl+1)       ; Load high byte of block size 
13ec			    cp l               ; Compare with low byte of requested size 
13ec			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ec			 
13ec			    ld a, (hl+2)       ; Load low byte of block size 
13ec			    cp h               ; Compare with high byte of requested size 
13ec			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ec			 
13ec			    ; Mark block as used 
13ec			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ec			 
13ec			    ; Calculate remaining space in block 
13ec			    ld bc, 0           ; Clear BC 
13ec			    add hl, bc         ; Increment HL to point to start of data block 
13ec			    add hl, de         ; HL = HL + DE (total size) 
13ec			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to start of data block 
13ec			 
13ec			    ; Save pointer to allocated block in HL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma5" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			malloc_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3           ; Size of management overhead 
13ec			    add hl, bc         ; Move to the next block 
13ec			    inc de             ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e            ; Load low byte of heap end address 
13ec			    cp (hl)            ; Compare with low byte of current address 
13ec			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ec			    ld a, d            ; Load high byte of heap end address 
13ec			    cp 0               ; Check if it's zero (end of memory) 
13ec			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, allocation failed 
13ec			    xor a              ; Set result to NULL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma6" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			malloc_exit: 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma7" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			; Internal Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free_internal: 
13ec			    ld de, (heap_start) ; Load start of heap into DE 
13ec			    ld bc, 0            ; Initialize counter 
13ec			 
13ec			free_search_loop: 
13ec			    ; Check if current block contains the pointer 
13ec			    ld a, l             ; Load low byte of pointer 
13ec			    cp (hl+1)           ; Compare with high byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			    ld a, h             ; Load high byte of pointer 
13ec			    cp (hl+2)           ; Compare with low byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			 
13ec			    ; Mark block as free 
13ec			    ld (hl), 0          ; Set status byte to indicate free block 
13ec			    ret                 ; Return 
13ec			 
13ec			free_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3            ; Size of management overhead 
13ec			    add hl, bc          ; Move to the next block 
13ec			    inc de              ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e             ; Load low byte of heap end address 
13ec			    cp (hl)             ; Compare with low byte of current address 
13ec			    jr nz, free_search_loop  ; If not equal, continue searching 
13ec			    ld a, d             ; Load high byte of heap end address 
13ec			    cp 0                ; Check if it's zero (end of memory) 
13ec			    jr nz, free_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, pointer is not found in heap 
13ec			    ret 
13ec			 
13ec			free_exit: 
13ec			    ret                 ; Return 
13ec			 
13ec			; Define heap start and end addresses 
13ec			;heap_start:    .dw 0xC000   ; Start of heap 
13ec			;heap_end:      .dw 0xE000   ; End of heap 
13ec			 
13ec			endif 
13ec			 
13ec			 
13ec			if MALLOC_1 
13ec			 
13ec			 
13ec			 
13ec			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ec			 
13ec			;moved to firmware.asm 
13ec			;heap_start        .equ  0x9000      ; Starting address of heap 
13ec			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ec			 
13ec			;      .org 0 
13ec			;      jp    main 
13ec			 
13ec			 
13ec			;      .org  0x100 
13ec			;main: 
13ec			;      ld    HL, 0x8100 
13ec			;      ld    SP, HL 
13ec			; 
13ec			;      call  heap_init 
13ec			; 
13ec			;      ; Make some allocations 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9004 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9014 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9024 
13ec			; 
13ec			;      ; Free some allocations 
13ec			;      ld    HL, 0x9014 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9004 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9024 
13ec			;      call  free 
13ec			; 
13ec			; 
13ec			;      halt 
13ec			 
13ec			 
13ec			;------------------------------------------------------------------------------ 
13ec			;     heap_init                                                               : 
13ec			;                                                                             : 
13ec			; Description                                                                 : 
13ec			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ec			;                                                                             : 
13ec			;     The heap is maintained as a linked list, starting with an initial       : 
13ec			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ec			;     the first free block in the heap. Each block then points to the next    : 
13ec			;     free block within the heap, and the free list ends at the first block   : 
13ec			;     with a null pointer to the next free block.                             : 
13ec			;                                                                             : 
13ec			; Parameters                                                                  : 
13ec			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ec			;     address of the heap and its size are required, along with a memory      : 
13ec			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ec			;     principally stores a pointer to the first free block in the heap.       : 
13ec			;                                                                             : 
13ec			; Returns                                                                     : 
13ec			;     Nothing                                                                 : 
13ec			;------------------------------------------------------------------------------ 
13ec			heap_init: 
13ec e5			      push  HL 
13ed			 
13ed			      ; Initialise free list struct 
13ed 21 0e 80		      ld    HL, heap_start 
13f0 22 0a 80		      ld    (free_list), HL 
13f3 21 00 00		      ld    HL, 0 
13f6 22 0c 80		      ld    (free_list+2), HL 
13f9			 
13f9			      ; Insert first free block at bottom of heap, consumes entire heap 
13f9 21 0a 80		      ld    HL, heap_start+heap_size-4 
13fc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13ff 21 fc ff		      ld    HL, heap_size-4 
1402 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1405			 
1405			      ; Insert end of free list block at top of heap - two null words will 
1405			      ; terminate the free list 
1405 21 00 00		      ld    HL, 0 
1408 22 0c 80		      ld    (heap_start+heap_size-2), HL 
140b 22 0a 80		      ld    (heap_start+heap_size-4), HL 
140e			 
140e e1			      pop   HL 
140f			 
140f c9			      ret 
1410			 
1410			 
1410			;------------------------------------------------------------------------------ 
1410			;     malloc                                                                  : 
1410			;                                                                             : 
1410			; Description                                                                 : 
1410			;     Allocates the wanted space from the heap and returns the address of the : 
1410			;     first useable byte of the allocation.                                   : 
1410			;                                                                             : 
1410			;     Allocations can happen in one of two ways:                              : 
1410			;                                                                             : 
1410			;     1. A free block may be found which is the exact size wanted. In this    : 
1410			;        case the block is removed from the free list and retuedn to the      : 
1410			;        caller.                                                              : 
1410			;     2. A free block may be found which is larger than the size wanted. In   : 
1410			;        this case, the larger block is split into two. The first portion of  : 
1410			;        this block will become the requested space by the malloc call and    : 
1410			;        is returned to the caller. The second portion becomes a new free     : 
1410			;        block, and the free list is adjusted to maintain continuity via this : 
1410			;        newly created block.                                                 : 
1410			;                                                                             : 
1410			;     malloc does not set any initial value in the allocated space, the       : 
1410			;     caller is required to do this as required.                              : 
1410			;                                                                             : 
1410			;     This implementation of malloc uses the stack exclusively, and is        : 
1410			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1410			;     advisable to disable interrupts before calling malloc, and recommended  : 
1410			;     to avoid the use of malloc inside ISRs in general.                      : 
1410			;                                                                             : 
1410			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1410			;                                                                             : 
1410			; Parameters                                                                  : 
1410			;     HL  Number of bytes wanted                                              : 
1410			;                                                                             : 
1410			; Returns                                                                     : 
1410			;     HL  Address of the first useable byte of the allocation                 : 
1410			;                                                                             : 
1410			; Flags                                                                       : 
1410			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1410			;                                                                             : 
1410			; Stack frame                                                                 : 
1410			;       |             |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     BC      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     DE      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     IX      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |  prev_free  |                                                       : 
1410			;   +4  +-------------+                                                       : 
1410			;       |  this_free  |                                                       : 
1410			;   +2  +-------------+                                                       : 
1410			;       |  next_free  |                                                       : 
1410			;   +0  +-------------+                                                       : 
1410			;       |             |                                                       : 
1410			;                                                                             : 
1410			;------------------------------------------------------------------------------ 
1410			 
1410			 
1410			;malloc: 
1410			; 
1410			;	SAVESP ON 1 
1410			; 
1410			;	call malloc_code 
1410			; 
1410			;	CHECKSP ON 1 
1410			;	ret 
1410			 
1410			 
1410			malloc: 
1410 c5			      push  BC 
1411 d5			      push  DE 
1412 dd e5		      push  IX 
1414			if DEBUG_FORTH_MALLOC_HIGH 
1414			call malloc_guard_entry 
1414			endif 
1414			 
1414					if DEBUG_FORTH_MALLOC 
1414						DMARK "mal" 
1414						CALLMONITOR 
1414					endif 
1414 7c			      ld    A, H                    ; Exit if no space requested 
1415 b5			      or    L 
1416 ca d5 14		      jp    Z, malloc_early_exit 
1419			 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			; 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			 
1419			 
1419			 
1419			 
1419					if DEBUG_FORTH_MALLOC 
1419						DMARK "maA" 
1419						CALLMONITOR 
1419					endif 
1419			      ; Set up stack frame 
1419 eb			      ex    DE, HL 
141a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
141d 39			      add   HL, SP 
141e f9			      ld    SP, HL 
141f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1423 dd 39		      add   IX, SP 
1425			 
1425			      ; Setup initial state 
1425 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1428 19			      add   HL, DE 
1429			 
1429 44			      ld    B, H                    ; Move want to BC 
142a 4d			      ld    C, L 
142b			 
142b 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
142e dd 75 04		      ld    (IX+4), L 
1431 dd 74 05		      ld    (IX+5), H 
1434			 
1434 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1435 23			      inc   HL 
1436 56			      ld    D, (HL) 
1437 dd 73 02		      ld    (IX+2), E 
143a dd 72 03		      ld    (IX+3), D 
143d eb			      ex    DE, HL                  ; this_free ptr into HL 
143e			 
143e					if DEBUG_FORTH_MALLOC 
143e						DMARK "maB" 
143e						CALLMONITOR 
143e					endif 
143e			      ; Loop through free block list to find some space 
143e			malloc_find_space: 
143e 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
143f 23			      inc   HL 
1440 56			      ld    D, (HL) 
1441			 
1441 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1442 b3			      or    E 
1443 ca cf 14		      jp    Z, malloc_no_space 
1446			 
1446 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1449 dd 72 01		      ld    (IX+1), D 
144c			 
144c			      ; Does this block have enough space to make the allocation? 
144c 23			      inc   HL                      ; Load free block size into DE 
144d 5e			      ld    E, (HL) 
144e 23			      inc   HL 
144f 56			      ld    D, (HL) 
1450			 
1450 eb			      ex    DE, HL                  ; Check size of block against want 
1451 b7			      or    A                       ; Ensure carry flag clear 
1452 ed 42		      sbc   HL, BC 
1454 e5			      push  HL                      ; Store the result for later (new block size) 
1455			 
1455 ca a4 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1458 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145a			 
145a			      ; this_free block is not big enough, setup ptrs to test next free block 
145a e1			      pop   HL                      ; Discard previous result 
145b			 
145b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
145e dd 66 03		      ld    H, (IX+3) 
1461 dd 75 04		      ld    (IX+4), L 
1464 dd 74 05		      ld    (IX+5), H 
1467			 
1467 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146a dd 66 01		      ld    H, (IX+1) 
146d dd 75 02		      ld    (IX+2), L 
1470 dd 74 03		      ld    (IX+3), H 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "MA>" 
1473						CALLMONITOR 
1473					endif 
1473 18 c9		      jr    malloc_find_space 
1475			 
1475			      ; split a bigger block into two - requested size and remaining size 
1475			malloc_alloc_split: 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "MAs" 
1475						CALLMONITOR 
1475					endif 
1475 eb			      ex    DE, HL                  ; Calculate address of new free block 
1476 2b			      dec   HL 
1477 2b			      dec   HL 
1478 2b			      dec   HL 
1479 09			      add   HL, BC 
147a			 
147a			      ; Create a new block and point it at next_free 
147a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
147d dd 56 01		      ld    D, (IX+1) 
1480			 
1480 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1481 23			      inc   HL 
1482 72			      ld    (HL), D 
1483			 
1483 d1			      pop   DE                      ; Store size of new block into new block 
1484 23			      inc   HL 
1485 73			      ld    (HL), E 
1486 23			      inc   HL 
1487 72			      ld    (HL), D 
1488			 
1488			      ; Update this_free ptr to point to new block 
1488 2b			      dec   HL 
1489 2b			      dec   HL 
148a 2b			      dec   HL 
148b			 
148b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
148e dd 56 03		      ld    D, (IX+3) 
1491			 
1491 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1494 dd 74 03		      ld    (IX+3), H 
1497			 
1497			      ; Modify this_free block to be allocation 
1497 eb			      ex    DE, HL 
1498 af			      xor   A                       ; Null the next block ptr of allocated block 
1499 77			      ld    (HL), A 
149a 23			      inc   HL 
149b 77			      ld    (HL), A 
149c			 
149c 23			      inc   HL                      ; Store want size into allocated block 
149d 71			      ld    (HL), C 
149e 23			      inc   HL 
149f 70			      ld    (HL), B 
14a0 23			      inc   HL 
14a1 e5			      push  HL                      ; Address of allocation to return 
14a2			 
14a2 18 19		      jr    malloc_update_links 
14a4			 
14a4			malloc_alloc_fit: 
14a4 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a5			 
14a5					if DEBUG_FORTH_MALLOC 
14a5						DMARK "MAf" 
14a5						CALLMONITOR 
14a5					endif 
14a5			      ; Modify this_free block to be allocation 
14a5 eb			      ex    DE, HL 
14a6 2b			      dec   HL 
14a7 2b			      dec   HL 
14a8 2b			      dec   HL 
14a9			 
14a9 af			      xor   A                       ; Null the next block ptr of allocated block 
14aa 77			      ld    (HL), A 
14ab 23			      inc   HL 
14ac 77			      ld    (HL), A 
14ad			 
14ad 23			      inc   HL                      ; Store address of allocation to return 
14ae 23			      inc   HL 
14af 23			      inc   HL 
14b0 e5			      push  HL 
14b1			 
14b1			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b1 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b4 dd 66 01		      ld    H, (IX+1) 
14b7			 
14b7 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14ba dd 74 03		      ld    (IX+3), H 
14bd			 
14bd			 
14bd			malloc_update_links: 
14bd			      ; Update prev_free ptr to point to this_free 
14bd dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c0 dd 66 05		      ld    H, (IX+5) 
14c3			 
14c3 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c6 dd 56 03		      ld    D, (IX+3) 
14c9			 
14c9 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14ca 23			      inc   HL 
14cb 72			      ld    (HL), D 
14cc			 
14cc					if DEBUG_FORTH_MALLOC 
14cc						DMARK "Mul" 
14cc						CALLMONITOR 
14cc					endif 
14cc			      ; Clear the Z flag to indicate successful allocation 
14cc 7a			      ld    A, D 
14cd b3			      or    E 
14ce			 
14ce d1			      pop   DE                      ; Address of allocation 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "MAu" 
14cf						CALLMONITOR 
14cf					endif 
14cf			 
14cf			malloc_no_space: 
14cf 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d2 39			      add   HL, SP 
14d3 f9			      ld    SP, HL 
14d4			 
14d4 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAN" 
14d5						CALLMONITOR 
14d5					endif 
14d5			 
14d5			malloc_early_exit: 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAx" 
14d5						CALLMONITOR 
14d5					endif 
14d5 dd e1		      pop   IX 
14d7 d1			      pop   DE 
14d8 c1			      pop   BC 
14d9			 
14d9			if DEBUG_FORTH_MALLOC_HIGH 
14d9			call malloc_guard_exit 
14d9			call malloc_guard_zerolen 
14d9			endif 
14d9 c9			      ret 
14da			 
14da			 
14da			;------------------------------------------------------------------------------ 
14da			;     free                                                                    : 
14da			;                                                                             : 
14da			; Description                                                                 : 
14da			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14da			;     returned by malloc, otherwise the behaviour is undefined.               : 
14da			;                                                                             : 
14da			;     Where possible, directly adjacent free blocks will be merged together   : 
14da			;     into larger blocks to help ensure that the heap does not become         : 
14da			;     excessively fragmented.                                                 : 
14da			;                                                                             : 
14da			;     free does not clear or set any other value into the freed space, and    : 
14da			;     therefore its contents may be visible through subsequent malloc's. The  : 
14da			;     caller should clear the freed space as required.                        : 
14da			;                                                                             : 
14da			;     This implementation of free uses the stack exclusively, and is          : 
14da			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14da			;     advisable to disable interrupts before calling free, and recommended    : 
14da			;     to avoid the use of free inside ISRs in general.                        : 
14da			;                                                                             : 
14da			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14da			;                                                                             : 
14da			; Parameters                                                                  : 
14da			;     HL  Pointer to address of first byte of allocation to be freed          : 
14da			;                                                                             : 
14da			; Returns                                                                     : 
14da			;     Nothing                                                                 : 
14da			;                                                                             : 
14da			; Stack frame                                                                 : 
14da			;       |             |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     BC      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     DE      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     IX      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |  prev_free  |                                                       : 
14da			;   +2  +-------------+                                                       : 
14da			;       |  next_free  |                                                       : 
14da			;   +0  +-------------+                                                       : 
14da			;       |             |                                                       : 
14da			;                                                                             : 
14da			;------------------------------------------------------------------------------ 
14da			free: 
14da c5			      push  BC 
14db d5			      push  DE 
14dc dd e5		      push  IX 
14de			 
14de 7c			      ld    A, H                    ; Exit if ptr is null 
14df b5			      or    L 
14e0 ca a4 15		      jp    Z, free_early_exit 
14e3			 
14e3			      ; Set up stack frame 
14e3 eb			      ex    DE, HL 
14e4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14e7 39			      add   HL, SP 
14e8 f9			      ld    SP, HL 
14e9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14ed dd 39		      add   IX, SP 
14ef			 
14ef			      ; The address in HL points to the start of the useable allocated space, 
14ef			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14ef			      ; address of the block itself. 
14ef eb			      ex    DE, HL 
14f0 11 fc ff		      ld    DE, -4 
14f3 19			      add   HL, DE 
14f4			 
14f4			      ; An allocated block must have a null next block pointer in it 
14f4 7e			      ld    A, (HL) 
14f5 23			      inc   HL 
14f6 b6			      or    (HL) 
14f7 c2 9f 15		      jp    NZ, free_done 
14fa			 
14fa 2b			      dec   HL 
14fb			 
14fb 44			      ld    B, H                    ; Copy HL to BC 
14fc 4d			      ld    C, L 
14fd			 
14fd			      ; Loop through the free list to find the first block with an address 
14fd			      ; higher than the block being freed 
14fd 21 0a 80		      ld    HL, free_list 
1500			 
1500			free_find_higher_block: 
1500 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1501 23			      inc   HL 
1502 56			      ld    D, (HL) 
1503 2b			      dec   HL 
1504			 
1504 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1507 dd 72 01		      ld    (IX+1), D 
150a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
150d dd 74 03		      ld    (IX+3), H 
1510			 
1510 78			      ld    A, B                    ; Check if DE is greater than BC 
1511 ba			      cp    D                       ; Compare MSB first 
1512 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1514 30 04		      jr    NC, free_find_higher_block_skip 
1516 79			      ld    A, C 
1517 bb			      cp    E                       ; Then compare LSB 
1518 38 08		      jr    C, free_found_higher_block 
151a			 
151a			free_find_higher_block_skip: 
151a 7a			      ld    A, D                    ; Reached the end of the free list? 
151b b3			      or    E 
151c ca 9f 15		      jp    Z, free_done 
151f			 
151f eb			      ex    DE, HL 
1520			 
1520 18 de		      jr    free_find_higher_block 
1522			 
1522			free_found_higher_block: 
1522			      ; Insert freed block between prev and next free blocks 
1522 71			      ld    (HL), C                 ; Point prev free block to freed block 
1523 23			      inc   HL 
1524 70			      ld    (HL), B 
1525			 
1525 60			      ld    H, B                    ; Point freed block at next free block 
1526 69			      ld    L, C 
1527 73			      ld    (HL), E 
1528 23			      inc   HL 
1529 72			      ld    (HL), D 
152a			 
152a			      ; Check if the freed block is adjacent to the next free block 
152a 23			      inc   HL                      ; Load size of freed block into HL 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e eb			      ex    DE, HL 
152f			 
152f 09			      add   HL, BC                  ; Add addr of freed block and its size 
1530			 
1530 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1533 dd 56 01		      ld    D, (IX+1) 
1536			 
1536 b7			      or    A                       ; Clear the carry flag 
1537 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1539 20 22		      jr    NZ, free_check_adjacent_to_prev 
153b			 
153b			      ; Freed block is adjacent to next, merge into one bigger block 
153b eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153c 5e			      ld    E, (HL) 
153d 23			      inc   HL 
153e 56			      ld    D, (HL) 
153f e5			      push  HL                      ; Save ptr to next block for later 
1540			 
1540 60			      ld    H, B                    ; Store ptr from next block into freed block 
1541 69			      ld    L, C 
1542 73			      ld    (HL), E 
1543 23			      inc   HL 
1544 72			      ld    (HL), D 
1545			 
1545 e1			      pop   HL                      ; Restore ptr to next block 
1546 23			      inc   HL                      ; Load size of next block into DE 
1547 5e			      ld    E, (HL) 
1548 23			      inc   HL 
1549 56			      ld    D, (HL) 
154a d5			      push  DE                      ; Save next block size for later 
154b			 
154b 60			      ld    H, B                    ; Load size of freed block into HL 
154c 69			      ld    L, C 
154d 23			      inc   HL 
154e 23			      inc   HL 
154f 5e			      ld    E, (HL) 
1550 23			      inc   HL 
1551 56			      ld    D, (HL) 
1552 eb			      ex    DE, HL 
1553			 
1553 d1			      pop   DE                      ; Restore size of next block 
1554 19			      add   HL, DE                  ; Add sizes of both blocks 
1555 eb			      ex    DE, HL 
1556			 
1556 60			      ld    H, B                    ; Store new bigger size into freed block 
1557 69			      ld    L, C 
1558 23			      inc   HL 
1559 23			      inc   HL 
155a 73			      ld    (HL), E 
155b 23			      inc   HL 
155c 72			      ld    (HL), D 
155d			 
155d			free_check_adjacent_to_prev: 
155d			      ; Check if the freed block is adjacent to the prev free block 
155d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1560 dd 66 03		      ld    H, (IX+3) 
1563			 
1563 23			      inc   HL                      ; Size of prev free block into DE 
1564 23			      inc   HL 
1565 5e			      ld    E, (HL) 
1566 23			      inc   HL 
1567 56			      ld    D, (HL) 
1568 2b			      dec   HL 
1569 2b			      dec   HL 
156a 2b			      dec   HL 
156b			 
156b 19			      add   HL, DE                  ; Add prev block addr and size 
156c			 
156c b7			      or    A                       ; Clear the carry flag 
156d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
156f 20 2e		      jr    NZ, free_done 
1571			 
1571			      ; Freed block is adjacent to prev, merge into one bigger block 
1571 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1572 69			      ld    L, C 
1573 5e			      ld    E, (HL) 
1574 23			      inc   HL 
1575 56			      ld    D, (HL) 
1576 e5			      push  HL                      ; Save freed block ptr for later 
1577			 
1577 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157a dd 66 03		      ld    H, (IX+3) 
157d 73			      ld    (HL), E 
157e 23			      inc   HL 
157f 72			      ld    (HL), D 
1580			 
1580 e1			      pop   HL                      ; Restore freed block ptr 
1581 23			      inc   HL                      ; Load size of freed block into DE 
1582 5e			      ld    E, (HL) 
1583 23			      inc   HL 
1584 56			      ld    D, (HL) 
1585 d5			      push  DE                      ; Save freed block size for later 
1586			 
1586 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1589 dd 66 03		      ld    H, (IX+3) 
158c 23			      inc   HL 
158d 23			      inc   HL 
158e 5e			      ld    E, (HL) 
158f 23			      inc   HL 
1590 56			      ld    D, (HL) 
1591			 
1591 e1			      pop   HL                      ; Add sizes of both blocks 
1592 19			      add   HL, DE 
1593 eb			      ex    DE, HL 
1594			 
1594 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1597 dd 66 03		      ld    H, (IX+3) 
159a 23			      inc   HL 
159b 23			      inc   HL 
159c 73			      ld    (HL), E 
159d 23			      inc   HL 
159e 72			      ld    (HL), D 
159f			 
159f			free_done: 
159f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a2 39			      add   HL, SP 
15a3 f9			      ld    SP, HL 
15a4			 
15a4			free_early_exit: 
15a4 dd e1		      pop   IX 
15a6 d1			      pop   DE 
15a7 c1			      pop   BC 
15a8			 
15a8 c9			      ret 
15a9			 
15a9			; moved to firmware.asm 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			;                  .dw   0 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_3 
15a9			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15a9			;heap_start        .equ  0x9000      ; Starting address of heap 
15a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15a9			; 
15a9			 ;     .org 0 
15a9			  ;    jp    main 
15a9			; 
15a9			; 
15a9			 ;     .org  0x100 
15a9			;main: 
15a9			 ;     ld    HL, 0x8100 
15a9			  ;    ld    SP, HL 
15a9			; 
15a9			;      call  heap_init 
15a9			 
15a9			      ; Make some allocations 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9004 
15a9			; 
15a9			 ;     ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9014 
15a9			 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9024 
15a9			 
15a9			      ; Free some allocations 
15a9			;      ld    HL, 0x9014 
15a9			;      call  free 
15a9			 
15a9			;      ld    HL, 0x9004 
15a9			;      call  free 
15a9			; 
15a9			;      ld    HL, 0x9024 
15a9			;      call  free 
15a9			 
15a9			 
15a9			 ;     halt 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     heap_init                                                               : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
15a9			;                                                                             : 
15a9			;     The heap is maintained as a linked list, starting with an initial       : 
15a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15a9			;     the first free block in the heap. Each block then points to the next    : 
15a9			;     free block within the heap, and the free list ends at the first block   : 
15a9			;     with a null pointer to the next free block.                             : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
15a9			;     address of the heap and its size are required, along with a memory      : 
15a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15a9			;     principally stores a pointer to the first free block in the heap.       : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;------------------------------------------------------------------------------ 
15a9			heap_init: 
15a9			      push  HL 
15a9			 
15a9			      ; Initialise free list struct 
15a9			      ld    HL, heap_start 
15a9			      ld    (free_list), HL 
15a9			      ld    HL, 0 
15a9			      ld    (free_list+2), HL 
15a9			 
15a9			      ; Insert first free block at bottom of heap, consumes entire heap 
15a9			      ld    HL, heap_start+heap_size-4 
15a9			      ld    (heap_start), HL        ; Next block (end of free list) 
15a9			      ld    HL, heap_size-4 
15a9			      ld    (heap_start+2), HL      ; Block size 
15a9			 
15a9			      ; Insert end of free list block at top of heap - two null words will 
15a9			      ; terminate the free list 
15a9			      ld    HL, 0 
15a9			      ld    (heap_start+heap_size-2), HL 
15a9			      ld    (heap_start+heap_size-4), HL 
15a9			 
15a9			      pop   HL 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     malloc                                                                  : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Allocates the wanted space from the heap and returns the address of the : 
15a9			;     first useable byte of the allocation.                                   : 
15a9			;                                                                             : 
15a9			;     Allocations can happen in one of two ways:                              : 
15a9			;                                                                             : 
15a9			;     1. A free block may be found which is the exact size wanted. In this    : 
15a9			;        case the block is removed from the free list and retuedn to the      : 
15a9			;        caller.                                                              : 
15a9			;     2. A free block may be found which is larger than the size wanted. In   : 
15a9			;        this case, the larger block is split into two. The first portion of  : 
15a9			;        this block will become the requested space by the malloc call and    : 
15a9			;        is returned to the caller. The second portion becomes a new free     : 
15a9			;        block, and the free list is adjusted to maintain continuity via this : 
15a9			;        newly created block.                                                 : 
15a9			;                                                                             : 
15a9			;     malloc does not set any initial value in the allocated space, the       : 
15a9			;     caller is required to do this as required.                              : 
15a9			;                                                                             : 
15a9			;     This implementation of malloc uses the stack exclusively, and is        : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling malloc, and recommended  : 
15a9			;     to avoid the use of malloc inside ISRs in general.                      : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Number of bytes wanted                                              : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     HL  Address of the first useable byte of the allocation                 : 
15a9			;                                                                             : 
15a9			; Flags                                                                       : 
15a9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +4  +-------------+                                                       : 
15a9			;       |  this_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			malloc: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if no space requested 
15a9			      or    L 
15a9			      jp    Z, malloc_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; Setup initial state 
15a9			      ld    HL, 4                   ; want must also include space used by block struct 
15a9			      add   HL, DE 
15a9			 
15a9			      ld    B, H                    ; Move want to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ld    HL, free_list           ; Store prev_free ptr to stack 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    E, (HL)                 ; Store this_free ptr to stack 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ld    (IX+2), E 
15a9			      ld    (IX+3), D 
15a9			      ex    DE, HL                  ; this_free ptr into HL 
15a9			 
15a9			      ; Loop through free block list to find some space 
15a9			malloc_find_space: 
15a9			      ld    E, (HL)                 ; Load next_free ptr into DE 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15a9			      or    E 
15a9			      jp    Z, malloc_no_space 
15a9			 
15a9			      ld    (IX+0), E               ; Store next_free ptr to stack 
15a9			      ld    (IX+1), D 
15a9			 
15a9			      ; Does this block have enough space to make the allocation? 
15a9			      inc   HL                      ; Load free block size into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ex    DE, HL                  ; Check size of block against want 
15a9			      or    A                       ; Ensure carry flag clear 
15a9			      sbc   HL, BC 
15a9			      push  HL                      ; Store the result for later (new block size) 
15a9			 
15a9			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15a9			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15a9			 
15a9			      ; this_free block is not big enough, setup ptrs to test next free block 
15a9			      pop   HL                      ; Discard previous result 
15a9			 
15a9			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15a9			      ld    H, (IX+3) 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15a9			      ld    H, (IX+1) 
15a9			      ld    (IX+2), L 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      jr    malloc_find_space 
15a9			 
15a9			      ; split a bigger block into two - requested size and remaining size 
15a9			malloc_alloc_split: 
15a9			      ex    DE, HL                  ; Calculate address of new free block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      add   HL, BC 
15a9			 
15a9			      ; Create a new block and point it at next_free 
15a9			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      ld    (HL), E                 ; Store next_free ptr into new block 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   DE                      ; Store size of new block into new block 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Update this_free ptr to point to new block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store want size into allocated block 
15a9			      ld    (HL), C 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			      inc   HL 
15a9			      push  HL                      ; Address of allocation to return 
15a9			 
15a9			      jr    malloc_update_links 
15a9			 
15a9			malloc_alloc_fit: 
15a9			      pop   HL                      ; Dont need new block size, want is exact fit 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store address of allocation to return 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      push  HL 
15a9			 
15a9			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15a9			      ld    L, (IX+0)               ; next_free to HL 
15a9			      ld    H, (IX+1) 
15a9			 
15a9			      ld    (IX+2), L               ; HL to this_free 
15a9			      ld    (IX+3), H 
15a9			 
15a9			 
15a9			malloc_update_links: 
15a9			      ; Update prev_free ptr to point to this_free 
15a9			      ld    L, (IX+4)               ; prev_free ptr to HL 
15a9			      ld    H, (IX+5) 
15a9			 
15a9			      ld    E, (IX+2)               ; this_free ptr to DE 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (HL), E                 ; this_free ptr into prev_free 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Clear the Z flag to indicate successful allocation 
15a9			      ld    A, D 
15a9			      or    E 
15a9			 
15a9			      pop   DE                      ; Address of allocation 
15a9			 
15a9			malloc_no_space: 
15a9			      ld    HL, 6                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			      ex    DE, HL                  ; Alloc addr into HL for return 
15a9			 
15a9			malloc_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     free                                                                    : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15a9			;     returned by malloc, otherwise the behaviour is undefined.               : 
15a9			;                                                                             : 
15a9			;     Where possible, directly adjacent free blocks will be merged together   : 
15a9			;     into larger blocks to help ensure that the heap does not become         : 
15a9			;     excessively fragmented.                                                 : 
15a9			;                                                                             : 
15a9			;     free does not clear or set any other value into the freed space, and    : 
15a9			;     therefore its contents may be visible through subsequent malloc's. The  : 
15a9			;     caller should clear the freed space as required.                        : 
15a9			;                                                                             : 
15a9			;     This implementation of free uses the stack exclusively, and is          : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling free, and recommended    : 
15a9			;     to avoid the use of free inside ISRs in general.                        : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Pointer to address of first byte of allocation to be freed          : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			free: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if ptr is null 
15a9			      or    L 
15a9			      jp    Z, free_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; The address in HL points to the start of the useable allocated space, 
15a9			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15a9			      ; address of the block itself. 
15a9			      ex    DE, HL 
15a9			      ld    DE, -4 
15a9			      add   HL, DE 
15a9			 
15a9			      ; An allocated block must have a null next block pointer in it 
15a9			      ld    A, (HL) 
15a9			      inc   HL 
15a9			      or    (HL) 
15a9			      jp    NZ, free_done 
15a9			 
15a9			      dec   HL 
15a9			 
15a9			      ld    B, H                    ; Copy HL to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ; Loop through the free list to find the first block with an address 
15a9			      ; higher than the block being freed 
15a9			      ld    HL, free_list 
15a9			 
15a9			free_find_higher_block: 
15a9			      ld    E, (HL)                 ; Load next ptr from free block 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			 
15a9			      ld    (IX+0), E               ; Save ptr to next free block 
15a9			      ld    (IX+1), D 
15a9			      ld    (IX+2), L               ; Save ptr to prev free block 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ld    A, B                    ; Check if DE is greater than BC 
15a9			      cp    D                       ; Compare MSB first 
15a9			      jr    Z, $+4                  ; MSB the same, compare LSB 
15a9			      jr    NC, free_find_higher_block_skip 
15a9			      ld    A, C 
15a9			      cp    E                       ; Then compare LSB 
15a9			      jr    C, free_found_higher_block 
15a9			 
15a9			free_find_higher_block_skip: 
15a9			      ld    A, D                    ; Reached the end of the free list? 
15a9			      or    E 
15a9			      jp    Z, free_done 
15a9			 
15a9			      ex    DE, HL 
15a9			 
15a9			      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9			      ld    (HL), C                 ; Point prev free block to freed block 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			 
15a9			      ld    H, B                    ; Point freed block at next free block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Check if the freed block is adjacent to the next free block 
15a9			      inc   HL                      ; Load size of freed block into HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      add   HL, BC                  ; Add addr of freed block and its size 
15a9			 
15a9			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_check_adjacent_to_prev 
15a9			 
15a9			      ; Freed block is adjacent to next, merge into one bigger block 
15a9			      ex    DE, HL                  ; Load next ptr from next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save ptr to next block for later 
15a9			 
15a9			      ld    H, B                    ; Store ptr from next block into freed block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore ptr to next block 
15a9			      inc   HL                      ; Load size of next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save next block size for later 
15a9			 
15a9			      ld    H, B                    ; Load size of freed block into HL 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      pop   DE                      ; Restore size of next block 
15a9			      add   HL, DE                  ; Add sizes of both blocks 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    H, B                    ; Store new bigger size into freed block 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_check_adjacent_to_prev: 
15a9			      ; Check if the freed block is adjacent to the prev free block 
15a9			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15a9			      ld    H, (IX+3) 
15a9			 
15a9			      inc   HL                      ; Size of prev free block into DE 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      add   HL, DE                  ; Add prev block addr and size 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_done 
15a9			 
15a9			      ; Freed block is adjacent to prev, merge into one bigger block 
15a9			      ld    H, B                    ; Load next ptr from freed block into DE 
15a9			      ld    L, C 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save freed block ptr for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15a9			      ld    H, (IX+3) 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore freed block ptr 
15a9			      inc   HL                      ; Load size of freed block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save freed block size for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Load size of prev block into DE 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      pop   HL                      ; Add sizes of both blocks 
15a9			      add   HL, DE 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_done: 
15a9			      ld    HL, 4                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			free_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;      .org 0x8000 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			 ;                 .dw   0 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_4 
15a9			 
15a9			; My memory allocation code. Very very simple.... 
15a9			; allocate space under 250 chars 
15a9			 
15a9			heap_init: 
15a9				; init start of heap as zero 
15a9				;  
15a9			 
15a9				ld hl, heap_start 
15a9				ld a, 0 
15a9				ld (hl), a      ; empty block 
15a9				inc hl 
15a9				ld a, 0 
15a9				ld (hl), a      ; length of block 
15a9				; write end of list 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				 
15a9			 
15a9				; init some malloc vars 
15a9			 
15a9				ld hl, 0 
15a9				ld (free_list), hl       ; store last malloc location 
15a9			 
15a9				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15a9				ld a, 0 
15a9				ld (hl), a 
15a9			 
15a9			 
15a9				ld hl, heap_start 
15a9				;  
15a9				  
15a9				ret 
15a9			 
15a9			 
15a9			;    free block marker 
15a9			;    requested size  
15a9			;    pointer to next block 
15a9			;    .... 
15a9			;    next block marker 
15a9			 
15a9			 
15a9			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15a9			; 
15a9			 
15a9			 
15a9			malloc:  
15a9				push de 
15a9				push bc 
15a9				push af 
15a9			 
15a9				; hl space required 
15a9				 
15a9				ld c, l    ; hold space   (TODO only a max of 255) 
15a9			 
15a9			;	inc c     ; TODO BUG need to fix memory leak on push str 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			 
15a9			 
15a9			 
15a9				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15a9			 
15a9				ld a, (free_list+3) 
15a9				cp 0 
15a9				jr z, .contheap 
15a9			 
15a9				ld hl, (free_list)     ; get last alloc 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mrs" 
15a9						CALLMONITOR 
15a9					endif 
15a9				jr .startalloc 
15a9			 
15a9			.contheap: 
15a9				ld hl, heap_start 
15a9			 
15a9			.startalloc: 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mym" 
15a9						CALLMONITOR 
15a9					endif 
15a9			.findblock: 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmf" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9				ld a,(hl)  
15a9				; if byte is zero then clear to use 
15a9			 
15a9				cp 0 
15a9				jr z, .foundemptyblock 
15a9			 
15a9				; if byte is not clear 
15a9				;     then byte is offset to next block 
15a9			 
15a9				inc hl 
15a9				ld a, (hl) ; get size 
15a9			.nextblock:	inc hl 
15a9					ld e, (hl) 
15a9					inc hl 
15a9					ld d, (hl) 
15a9					ex de, hl 
15a9			;	inc hl  ; move past the store space 
15a9			;	inc hl  ; move past zero index  
15a9			 
15a9				; TODO detect no more space 
15a9			 
15a9				push hl 
15a9				ld de, heap_end 
15a9				call cmp16 
15a9				pop hl 
15a9				jr nc, .nospace 
15a9			 
15a9				jr .findblock 
15a9			 
15a9			.nospace: ld hl, 0 
15a9				jp .exit 
15a9			 
15a9			 
15a9			.foundemptyblock:	 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mme" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; TODO has block enough space if reusing??? 
15a9			 
15a9				;  
15a9			 
15a9			; see if this block has been previously used 
15a9				inc hl 
15a9				ld a, (hl) 
15a9				dec hl 
15a9				cp 0 
15a9				jr z, .newblock 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meR" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; no reusing previously allocated block 
15a9			 
15a9			; is it smaller than previously used? 
15a9				 
15a9				inc hl    ; move to size 
15a9				ld a, c 
15a9				sub (hl)        ; we want c < (hl) 
15a9				dec hl    ; move back to marker 
15a9			        jr z, .findblock 
15a9			 
15a9				; update with the new size which should be lower 
15a9			 
15a9			        ;inc  hl   ; negate next move. move back to size  
15a9			 
15a9			.newblock: 
15a9				; need to be at marker here 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meN" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			 
15a9				ld a, c 
15a9			 
15a9				ld (free_list+3), a	 ; flag resume from last malloc  
15a9				ld (free_list), hl    ; save out last location 
15a9			 
15a9			 
15a9				;inc a     ; space for length byte 
15a9				ld (hl), a     ; save block in use marker 
15a9			 
15a9				inc hl   ; move to space marker 
15a9				ld (hl), a    ; save new space 
15a9			 
15a9				inc hl   ; move to start of allocated area 
15a9				 
15a9			;	push hl     ; save where we are - 1  
15a9			 
15a9			;	inc hl  ; move past zero index  
15a9				; skip space to set down new marker 
15a9			 
15a9				; provide some extra space for now 
15a9			 
15a9				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15a9				inc a 
15a9				inc a 
15a9			 
15a9				push hl   ; save where we are in the node block 
15a9			 
15a9				call addatohl 
15a9			 
15a9				; write linked list point 
15a9			 
15a9				pop de     ; get our node position 
15a9				ex de, hl 
15a9			 
15a9				ld (hl), e 
15a9				inc hl 
15a9				ld (hl), d 
15a9			 
15a9				inc hl 
15a9			 
15a9				; now at start of allocated data so save pointer 
15a9			 
15a9				push hl 
15a9			 
15a9				; jump to position of next node and setup empty header in DE 
15a9			 
15a9				ex de, hl 
15a9			 
15a9			;	inc hl ; move past end of block 
15a9			 
15a9				ld a, 0 
15a9				ld (hl), a   ; empty marker 
15a9				inc hl 
15a9				ld (hl), a   ; size 
15a9				inc hl  
15a9				ld (hl), a   ; ptr 
15a9				inc hl 
15a9				ld (hl), a   ; ptr 
15a9			 
15a9			 
15a9				pop hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmr" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			.exit: 
15a9				pop af 
15a9				pop bc 
15a9				pop de  
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			 
15a9			free:  
15a9				push hl 
15a9				push af 
15a9				; get address in hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "fre" 
15a9						CALLMONITOR 
15a9					endif 
15a9				; data is at hl - move to block count 
15a9				dec hl 
15a9				dec hl    ; get past pointer 
15a9				dec hl 
15a9			 
15a9				ld a, (hl)    ; need this for a validation check 
15a9			 
15a9				dec hl    ; move to block marker 
15a9			 
15a9				; now check that the block count and block marker are the same  
15a9			        ; this checks that we are on a malloc node and not random memory 
15a9			        ; OK a faint chance this could be a problem but rare - famous last words! 
15a9			 
15a9				ld c, a 
15a9				ld a, (hl)    
15a9			 
15a9				cp c 
15a9				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15a9			 
15a9				; yes good chance we are on a malloc node 
15a9			 
15a9				ld a, 0      
15a9				ld (hl), a   ; mark as free 
15a9			 
15a9				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15a9			 
15a9			.freeignore:  
15a9			 
15a9				pop af 
15a9				pop hl 
15a9			 
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			; eof 
# End of file firmware_memory.asm
15a9			  
15a9			; device C  
15a9			if SOUND_ENABLE  
15a9				include "firmware_sound.asm"  
15a9			endif  
15a9			  
15a9			include "firmware_diags.asm"  
15a9			; Hardware diags menu 
15a9			 
15a9			 
15a9			config: 
15a9			 
15a9 3e 00			ld a, 0 
15ab 21 d9 15			ld hl, .configmn 
15ae cd 46 0d			call menu 
15b1			 
15b1 fe 00			cp 0 
15b3 c8				ret z 
15b4			 
15b4 fe 01			cp 1 
15b6 cc b2 16			call z, .savetostore 
15b9			 
15b9 fe 02			cp 2 
15bb cc 00 16			call z, .selautoload 
15be fe 03			cp 3 
15c0 cc e9 15			call z, .disautoload 
15c3 fe 04			cp 4 
15c5 cc b0 16			call z, .selbank 
15c8 fe 05			cp 5 
15ca cc 8d 17			call z, .debug_tog 
15cd fe 06			cp 6 
15cf cc d0 18			call z, .bpsgo 
15d2 fe 07			cp 7 
15d4 cc b3 17			call z, hardware_diags 
15d7			 
15d7 18 d0			jr config 
15d9			 
15d9			.configmn: 
15d9 c1 1a			dw prom_c3 
15db d8 1a			dw prom_c2 
15dd ed 1a			dw prom_c2a 
15df 03 1b			dw prom_c2b 
15e1			;	dw prom_c4 
15e1 20 1b			dw prom_m4 
15e3 3b 1b			dw prom_m4b 
15e5 43 1b			dw prom_c1 
15e7 00 00			dw 0 
15e9				 
15e9			 
15e9			 
15e9			 
15e9			.disautoload: 
15e9				if STORAGE_SE 
15e9 3e fe			ld a, $fe      ; bit 0 clear 
15eb 32 ed fb			ld (spi_device), a 
15ee			 
15ee cd ca 04			call storage_get_block_0 
15f1			 
15f1 3e 00			ld a, 0 
15f3 32 28 fc			ld (store_page+STORE_0_AUTOFILE), a 
15f6			 
15f6 21 00 00				ld hl, 0 
15f9 11 07 fc				ld de, store_page 
15fc cd 7e 04			call storage_write_block	 ; save update 
15ff				else 
15ff			 
15ff				ld hl, prom_notav 
15ff				ld de, prom_empty 
15ff				call info_panel 
15ff				endif 
15ff			 
15ff			 
15ff c9				ret 
1600			 
1600			 
1600			 
1600			; Select auto start 
1600			 
1600			.selautoload: 
1600			 
1600				 
1600				if STORAGE_SE 
1600			 
1600 cd d7 16				call config_dir 
1603 21 4e f3			        ld hl, scratch 
1606 3e 00				ld a, 0 
1608 cd 46 0d				call menu 
160b			 
160b fe 00				cp 0 
160d c8					ret z 
160e			 
160e 3d					dec a 
160f			 
160f			 
160f					; locate menu option 
160f			 
160f 21 4e f3				ld hl, scratch 
1612 cd 6a 0c				call table_lookup 
1615			 
1615					if DEBUG_FORTH_WORDS 
1615						DMARK "ALl" 
1615 f5				push af  
1616 3a 2a 16			ld a, (.dmark)  
1619 32 b4 fe			ld (debug_mark),a  
161c 3a 2b 16			ld a, (.dmark+1)  
161f 32 b5 fe			ld (debug_mark+1),a  
1622 3a 2c 16			ld a, (.dmark+2)  
1625 32 b6 fe			ld (debug_mark+2),a  
1628 18 03			jr .pastdmark  
162a ..			.dmark: db "ALl"  
162d f1			.pastdmark: pop af  
162e			endm  
# End of macro DMARK
162e						CALLMONITOR 
162e cd c6 18			call break_point_state  
1631				endm  
# End of macro CALLMONITOR
1631					endif 
1631					; with the pointer to the menu it, the byte following the zero term is the file id 
1631			 
1631 3e 00				ld a, 0 
1633 01 32 00				ld bc, 50   ; max of bytes to look at 
1636 ed b1				cpir  
1638			 
1638					if DEBUG_FORTH_WORDS 
1638						DMARK "ALb" 
1638 f5				push af  
1639 3a 4d 16			ld a, (.dmark)  
163c 32 b4 fe			ld (debug_mark),a  
163f 3a 4e 16			ld a, (.dmark+1)  
1642 32 b5 fe			ld (debug_mark+1),a  
1645 3a 4f 16			ld a, (.dmark+2)  
1648 32 b6 fe			ld (debug_mark+2),a  
164b 18 03			jr .pastdmark  
164d ..			.dmark: db "ALb"  
1650 f1			.pastdmark: pop af  
1651			endm  
# End of macro DMARK
1651						CALLMONITOR 
1651 cd c6 18			call break_point_state  
1654				endm  
# End of macro CALLMONITOR
1654					endif 
1654					;inc hl 
1654			 
1654 7e					ld a, (hl)   ; file id 
1655					 
1655				        ; save bank and file ids 
1655			 
1655 f5					push af 
1656			 
1656			; TODO need to save to block 0 on bank 1	 
1656			 
1656 cd ca 04				call storage_get_block_0 
1659			 
1659					if DEBUG_FORTH_WORDS 
1659						DMARK "AL0" 
1659 f5				push af  
165a 3a 6e 16			ld a, (.dmark)  
165d 32 b4 fe			ld (debug_mark),a  
1660 3a 6f 16			ld a, (.dmark+1)  
1663 32 b5 fe			ld (debug_mark+1),a  
1666 3a 70 16			ld a, (.dmark+2)  
1669 32 b6 fe			ld (debug_mark+2),a  
166c 18 03			jr .pastdmark  
166e ..			.dmark: db "AL0"  
1671 f1			.pastdmark: pop af  
1672			endm  
# End of macro DMARK
1672						CALLMONITOR 
1672 cd c6 18			call break_point_state  
1675				endm  
# End of macro CALLMONITOR
1675					endif 
1675 f1					pop af 
1676			 
1676 32 2b fc				ld (store_page+STORE_0_FILERUN),a 
1679					 
1679					; save bank id 
1679			 
1679 3a ed fb				ld a,(spi_device) 
167c 32 2a fc				ld (store_page+STORE_0_BANKRUN),a 
167f			 
167f					; enable auto run of store file 
167f			 
167f 3e 01				ld a, 1 
1681 32 28 fc				ld (store_page+STORE_0_AUTOFILE),a 
1684			 
1684					; save buffer 
1684			 
1684 21 00 00				ld hl, 0 
1687 11 07 fc				ld de, store_page 
168a					if DEBUG_FORTH_WORDS 
168a						DMARK "ALw" 
168a f5				push af  
168b 3a 9f 16			ld a, (.dmark)  
168e 32 b4 fe			ld (debug_mark),a  
1691 3a a0 16			ld a, (.dmark+1)  
1694 32 b5 fe			ld (debug_mark+1),a  
1697 3a a1 16			ld a, (.dmark+2)  
169a 32 b6 fe			ld (debug_mark+2),a  
169d 18 03			jr .pastdmark  
169f ..			.dmark: db "ALw"  
16a2 f1			.pastdmark: pop af  
16a3			endm  
# End of macro DMARK
16a3						CALLMONITOR 
16a3 cd c6 18			call break_point_state  
16a6				endm  
# End of macro CALLMONITOR
16a6					endif 
16a6 cd 7e 04			call storage_write_block	 ; save update 
16a9			  
16a9			 
16a9			 
16a9			 
16a9 21 4e f3				ld hl, scratch 
16ac cd c4 16				call config_fdir 
16af			 
16af				else 
16af			 
16af				ld hl, prom_notav 
16af				ld de, prom_empty 
16af				call info_panel 
16af			 
16af				endif 
16af c9				ret 
16b0			 
16b0			 
16b0			 
16b0			; Select storage bank 
16b0			 
16b0			.selbank: 
16b0			 
16b0				if STORAGE_SE 
16b0				else 
16b0			 
16b0				ld hl, prom_notav 
16b0				ld de, prom_empty 
16b0				call info_panel 
16b0				endif 
16b0				 
16b0 c9				ret 
16b1			 
16b1			if STORAGE_SE 
16b1			 
16b1			.config_ldir:   
16b1				; Load storage bank labels into menu array 
16b1			 
16b1				 
16b1			 
16b1			 
16b1 c9				ret 
16b2			 
16b2			 
16b2			endif 
16b2			 
16b2			 
16b2			; Save user words to storage 
16b2			 
16b2			.savetostore: 
16b2			 
16b2				if STORAGE_SE 
16b2			 
16b2 cd d7 16				call config_dir 
16b5 21 4e f3			        ld hl, scratch 
16b8 3e 00				ld a, 0 
16ba cd 46 0d				call menu 
16bd					 
16bd 21 4e f3				ld hl, scratch 
16c0 cd c4 16				call config_fdir 
16c3			 
16c3				else 
16c3			 
16c3				ld hl, prom_notav 
16c3				ld de, prom_empty 
16c3				call info_panel 
16c3			 
16c3				endif 
16c3			 
16c3 c9				ret 
16c4			 
16c4			 
16c4			 
16c4			if STORAGE_SE 
16c4			 
16c4			config_fdir: 
16c4				; using the scratch dir go through and release the memory allocated for each string 
16c4				 
16c4 21 4e f3			ld hl, scratch 
16c7 5e			.cfdir:	ld e,(hl) 
16c8 23				inc hl 
16c9 56				ld d,(hl) 
16ca 23				inc hl 
16cb			 
16cb eb				ex de, hl 
16cc cd 72 0f			call ishlzero 
16cf c8				ret z     ; return on null pointer 
16d0 cd da 14			call free 
16d3 eb				ex de, hl 
16d4 18 f1			jr .cfdir 
16d6			 
16d6			 
16d6 c9				ret 
16d7			 
16d7			 
16d7			config_dir: 
16d7			 
16d7				; for the config menus that need to build a directory of storage call this routine 
16d7				; it will construct a menu in scratch to pass to menu 
16d7			 
16d7				; open storage device 
16d7			 
16d7				; execute DIR to build a list of files and their ids into scratch in menu format 
16d7				; once the menu has finished then will need to call config_fdir to release the strings 
16d7				 
16d7				; c = number items 
16d7			 
16d7				 
16d7 cd ca 04			call storage_get_block_0 
16da			 
16da 21 07 fc			ld hl, store_page     ; get current id count 
16dd 46				ld b, (hl) 
16de 0e 00			ld c, 0    ; count of files   
16e0			 
16e0			 
16e0 21 4e f3			ld hl, scratch 
16e3 22 fe fb			ld (store_tmp2), hl    ; location to poke strings 
16e6			 
16e6				; check for empty drive 
16e6			 
16e6 3e 00			ld a, 0 
16e8 b8				cp b 
16e9 ca 83 17			jp z, .dirdone 
16ec			 
16ec				 
16ec					if DEBUG_FORTH_WORDS 
16ec						DMARK "Cdc" 
16ec f5				push af  
16ed 3a 01 17			ld a, (.dmark)  
16f0 32 b4 fe			ld (debug_mark),a  
16f3 3a 02 17			ld a, (.dmark+1)  
16f6 32 b5 fe			ld (debug_mark+1),a  
16f9 3a 03 17			ld a, (.dmark+2)  
16fc 32 b6 fe			ld (debug_mark+2),a  
16ff 18 03			jr .pastdmark  
1701 ..			.dmark: db "Cdc"  
1704 f1			.pastdmark: pop af  
1705			endm  
# End of macro DMARK
1705						CALLMONITOR 
1705 cd c6 18			call break_point_state  
1708				endm  
# End of macro CALLMONITOR
1708					endif 
1708			 
1708			 
1708			.diritem:	 
1708 c5				push bc 
1709				; for each of the current ids do a search for them and if found push to stack 
1709			 
1709 21 40 00				ld hl, STORE_BLOCK_PHY 
170c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
170e 58					ld e,b 
170f			 
170f cd 4c 07				call storage_findnextid 
1712			 
1712			 
1712					; if found hl will be non zero 
1712			 
1712 cd 72 0f				call ishlzero 
1715 28 69				jr z, .dirnotfound 
1717			 
1717					; increase count 
1717			 
1717 c1					pop bc	 
1718 0c					inc c 
1719 c5					push bc 
171a					 
171a			 
171a					; get file header and push the file name 
171a			 
171a 11 07 fc				ld de, store_page 
171d cd 19 04				call storage_read_block 
1720			 
1720					; push file id to stack 
1720				 
1720 3a 07 fc				ld a, (store_page) 
1723 26 00				ld h, 0 
1725 6f					ld l, a 
1726			 
1726					;call forth_push_numhl 
1726					; TODO store id 
1726			 
1726 e5					push hl 
1727			 
1727					; push extent count to stack  
1727				 
1727 21 0a fc				ld hl, store_page+3 
172a			 
172a					; get file name length 
172a			 
172a cd a7 13				call strlenz   
172d			 
172d 23					inc hl   ; cover zero term 
172e 23					inc hl  ; stick the id at the end of the area 
172f			 
172f e5					push hl 
1730 c1					pop bc    ; move length to bc 
1731			 
1731 cd 10 14				call malloc 
1734			 
1734					; TODO save malloc area to scratch 
1734			 
1734 eb					ex de, hl 
1735 2a fe fb				ld hl, (store_tmp2) 
1738 73					ld (hl), e 
1739 23					inc hl 
173a 72					ld (hl), d 
173b 23					inc hl 
173c 22 fe fb				ld (store_tmp2), hl 
173f			 
173f					 
173f			 
173f					;pop hl   ; get source 
173f			;		ex de, hl    ; swap aronund	 
173f			 
173f 21 0a fc				ld hl, store_page+3 
1742					if DEBUG_FORTH_WORDS 
1742						DMARK "CFd" 
1742 f5				push af  
1743 3a 57 17			ld a, (.dmark)  
1746 32 b4 fe			ld (debug_mark),a  
1749 3a 58 17			ld a, (.dmark+1)  
174c 32 b5 fe			ld (debug_mark+1),a  
174f 3a 59 17			ld a, (.dmark+2)  
1752 32 b6 fe			ld (debug_mark+2),a  
1755 18 03			jr .pastdmark  
1757 ..			.dmark: db "CFd"  
175a f1			.pastdmark: pop af  
175b			endm  
# End of macro DMARK
175b						CALLMONITOR 
175b cd c6 18			call break_point_state  
175e				endm  
# End of macro CALLMONITOR
175e					endif 
175e ed b0				ldir 
1760			 
1760					; de is past string, move back one and store id 
1760					 
1760 1b					dec de 
1761			 
1761					; store file id 
1761			 
1761 e1					pop hl 
1762 eb					ex de,hl 
1763 73					ld (hl), e 
1764			 
1764					if DEBUG_FORTH_WORDS 
1764						DMARK "Cdi" 
1764 f5				push af  
1765 3a 79 17			ld a, (.dmark)  
1768 32 b4 fe			ld (debug_mark),a  
176b 3a 7a 17			ld a, (.dmark+1)  
176e 32 b5 fe			ld (debug_mark+1),a  
1771 3a 7b 17			ld a, (.dmark+2)  
1774 32 b6 fe			ld (debug_mark+2),a  
1777 18 03			jr .pastdmark  
1779 ..			.dmark: db "Cdi"  
177c f1			.pastdmark: pop af  
177d			endm  
# End of macro DMARK
177d						CALLMONITOR 
177d cd c6 18			call break_point_state  
1780				endm  
# End of macro CALLMONITOR
1780					endif 
1780					 
1780			.dirnotfound: 
1780 c1					pop bc     
1781 10 85				djnz .diritem 
1783				 
1783			.dirdone:	 
1783			 
1783 3e 00				ld a, 0 
1785 2a fe fb				ld hl, (store_tmp2) 
1788 77					ld (hl), a 
1789 23					inc hl 
178a 77					ld (hl), a 
178b 23					inc hl 
178c					; push a count of the dir items found 
178c			 
178c			;		ld h, 0 
178c			;		ld l, c 
178c			 
178c c9				ret 
178d			 
178d			endif 
178d			 
178d			 
178d			; Settings 
178d			; Run  
178d			 
178d			 
178d			 
178d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
178d			;;hd_menu2:   db "        2: Editor",0   
178d			;hd_menu2:   db "        2: Editor       6: Menu",0   
178d			;hd_menu3:   db "        3: Storage",0 
178d			;hd_menu4:   db "0=quit  4: Debug",0 
178d			;hd_don:     db "ON",0 
178d			;hd_doff:     db "OFF",0 
178d			; 
178d			; 
178d			; 
178d			;hardware_diags_old:       
178d			; 
178d			;.diagmenu: 
178d			;	call clear_display 
178d			;	ld a, display_row_1 
178d			;	ld de, hd_menu1 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_2 
178d			;	ld de, hd_menu2 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_3 
178d			;	ld de, hd_menu3 
178d			;	call str_at_display 
178d			; 
178d			;	ld a,  display_row_4 
178d			;	ld de, hd_menu4 
178d			;	call str_at_display 
178d			; 
178d			;	; display debug state 
178d			; 
178d			;	ld de, hd_don 
178d			;	ld a, (os_view_disable) 
178d			;	cp 0 
178d			;	jr z, .distog 
178d			;	ld de, hd_doff 
178d			;.distog: ld a, display_row_4+17 
178d			;	call str_at_display 
178d			; 
178d			;	call update_display 
178d			; 
178d			;	call cin_wait 
178d			; 
178d			; 
178d			; 
178d			;	cp '4' 
178d			;	jr nz, .diagn1 
178d			; 
178d			;	; debug toggle 
178d			; 
178d			;	ld a, (os_view_disable) 
178d			;	ld b, '*' 
178d			;	cp 0 
178d			;	jr z, .debtog 
178d			;	ld b, 0 
178d			;.debtog:	 
178d			;	ld a,b 
178d			;	ld (os_view_disable),a 
178d			; 
178d			;.diagn1: cp '0' 
178d			;	 ret z 
178d			; 
178d			;;	cp '1' 
178d			;;       jp z, matrix	 
178d			;;   TODO keyboard matrix test 
178d			; 
178d			;	cp '2' 
178d			;	jp z, .diagedit 
178d			; 
178d			;;	cp '6' 
178d			;;	jp z, .menutest 
178d			;;if ENABLE_BASIC 
178d			;;	cp '6' 
178d			;;	jp z, basic 
178d			;;endif 
178d			 ; 
178d			;	jp .diagmenu 
178d			; 
178d			; 
178d			;	ret 
178d			 
178d			 
178d			.debug_tog: 
178d 21 d4 17			ld hl, .menudebug 
1790				 
1790 3a 3f f3			ld a, (os_view_disable) 
1793 fe 2a			cp '*' 
1795 20 04			jr nz,.tdon  
1797 3e 01			ld a, 1 
1799 18 02			jr .tog1 
179b 3e 00		.tdon: ld a, 0 
179d			 
179d			.tog1: 
179d cd 46 0d			call menu 
17a0 fe 00			cp 0 
17a2 c8				ret z 
17a3 fe 01			cp 1    ; disable debug 
17a5 28 04			jr z, .dtog0 
17a7 3e 2a			ld a, '*' 
17a9 18 02			jr .dtogset 
17ab 3e 00		.dtog0: ld a, 0 
17ad 32 3f f3		.dtogset:  ld (os_view_disable), a 
17b0 c3 8d 17			jp .debug_tog 
17b3			 
17b3			 
17b3			hardware_diags:       
17b3			 
17b3			.diagm: 
17b3 21 c6 17			ld hl, .menuitems 
17b6 3e 00			ld a, 0 
17b8 cd 46 0d			call menu 
17bb			 
17bb fe 00		         cp 0 
17bd c8				 ret z 
17be			 
17be fe 02			cp 2 
17c0 ca 1f 18			jp z, .diagedit 
17c3			 
17c3			;	cp '6' 
17c3			;	jp z, .menutest 
17c3			;if ENABLE_BASIC 
17c3			;	cp '6' 
17c3			;	jp z, basic 
17c3			;endif 
17c3			  
17c3 c3 b3 17			jp .diagm 
17c6			 
17c6				 
17c6 da 17		.menuitems:   	dw .m1 
17c8 e5 17				dw .m2 
17ca ec 17				dw .m3 
17cc f4 17				dw .m5 
17ce fa 17				dw .m5a 
17d0 03 18				dw .m5b 
17d2 00 00				dw 0 
17d4			 
17d4			.menudebug: 
17d4 0c 18				dw .m6 
17d6 15 18				dw .m7 
17d8 00 00				dw 0 
17da			 
17da .. 00		.m1:   db "Key Matrix",0 
17e5 .. 00		.m2:   db "Editor",0 
17ec .. 00		.m3:   db "Storage",0 
17f4 .. 00		.m5:   db "Sound",0 
17fa .. 00		.m5a:  db "RAM Test",0 
1803 .. 00		.m5b:  db "LCD Test",0 
180c			 
180c .. 00		.m6:   db "Debug ON",0 
1815 .. 00		.m7:   db "Debug OFF",0 
181f			 
181f			; debug editor 
181f			 
181f			.diagedit: 
181f			 
181f 21 4e f3			ld hl, scratch 
1822			;	ld bc, 250 
1822			;	ldir 
1822				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1822 3e 00			ld a, 0 
1824 77				ld (hl), a 
1825 23				inc hl 
1826 77				ld (hl), a 
1827 23				inc hl 
1828 77				ld (hl), a 
1829			 
1829 cd 15 0d		        call clear_display 
182c cd 38 0d			call update_display 
182f				;ld a, 1 
182f				;ld (hardware_diag), a 
182f			.diloop: 
182f 3e 00			ld a, display_row_1 
1831 0e 00			ld c, 0 
1833 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1835 1e 28			ld e, 40 
1837			 
1837 21 4e f3			ld hl, scratch	 
183a cd 76 0f			call input_str 
183d			 
183d 3e 14			ld a, display_row_2 
183f 11 4e f3			ld de, scratch 
1842 cd 28 0d			call str_at_display 
1845 cd 38 0d			call update_display 
1848			 
1848 c3 2f 18			jp .diloop 
184b			 
184b			 
184b			; pass word in hl 
184b			; a has display location 
184b			display_word_at: 
184b f5				push af 
184c e5				push hl 
184d 7c				ld a,h 
184e 21 53 f6			ld hl, os_word_scratch 
1851 cd 4a 12			call hexout 
1854 e1				pop hl 
1855 7d				ld a,l 
1856 21 55 f6			ld hl, os_word_scratch+2 
1859 cd 4a 12			call hexout 
185c 21 57 f6			ld hl, os_word_scratch+4 
185f 3e 00			ld a,0 
1861 77				ld (hl),a 
1862 11 53 f6			ld de,os_word_scratch 
1865 f1				pop af 
1866 cd 28 0d				call str_at_display 
1869 c9				ret 
186a			 
186a			display_ptr_state: 
186a			 
186a				; to restore afterwards 
186a			 
186a d5				push de 
186b c5				push bc 
186c e5				push hl 
186d f5				push af 
186e			 
186e				; for use in here 
186e			 
186e			;	push bc 
186e			;	push de 
186e			;	push hl 
186e			;	push af 
186e			 
186e cd 15 0d			call clear_display 
1871			 
1871 11 44 1a			ld de, .ptrstate 
1874 3e 00			ld a, display_row_1 
1876 cd 28 0d			call str_at_display 
1879			 
1879				; display debug step 
1879			 
1879			 
1879 11 b4 fe			ld de, debug_mark 
187c 3e 12			ld a, display_row_1+display_cols-2 
187e cd 28 0d			call str_at_display 
1881			 
1881				; display a 
1881 11 4e 1a			ld de, .ptrcliptr 
1884 3e 14			ld a, display_row_2 
1886 cd 28 0d			call str_at_display 
1889			 
1889 f1				pop af 
188a 2a cd fb			ld hl,(cli_ptr) 
188d 3e 1c			ld a, display_row_2+8 
188f cd 4b 18			call display_word_at 
1892			 
1892			 
1892				; display hl 
1892			 
1892			 
1892 11 56 1a			ld de, .ptrclioptr 
1895 3e 1e			ld a, display_row_2+10 
1897 cd 28 0d			call str_at_display 
189a			; 
189a			;	pop hl 
189a 3e 21			ld a, display_row_2+13 
189c 2a cb fb			ld hl,(cli_origptr) 
189f cd 4b 18			call display_word_at 
18a2			; 
18a2			;	 
18a2			;	; display de 
18a2			 
18a2			;	ld de, .regstatede 
18a2			;	ld a, display_row_3 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop de 
18a2			;	ld h,d 
18a2			;	ld l, e 
18a2			;	ld a, display_row_3+3 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display bc 
18a2			 
18a2			;	ld de, .regstatebc 
18a2			;	ld a, display_row_3+10 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop bc 
18a2			;	ld h,b 
18a2			;	ld l, c 
18a2			;	ld a, display_row_3+13 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display dsp 
18a2			 
18a2			;	ld de, .regstatedsp 
18a2			;	ld a, display_row_4 
18a2			;	call str_at_display 
18a2			 
18a2				 
18a2			;	ld hl,(cli_data_sp) 
18a2			;	ld a, display_row_4+4 
18a2			;	call display_word_at 
18a2			 
18a2				; display rsp 
18a2			 
18a2 11 85 1a			ld de, .regstatersp 
18a5 3e 46			ld a, display_row_4+10 
18a7 cd 28 0d			call str_at_display 
18aa			 
18aa				 
18aa 2a 7f fb			ld hl,(cli_ret_sp) 
18ad 3e 4a			ld a, display_row_4+14 
18af cd 4b 18			call display_word_at 
18b2			 
18b2 cd 38 0d			call update_display 
18b5			 
18b5 cd 92 0c			call delay1s 
18b8 cd 92 0c			call delay1s 
18bb cd 92 0c			call delay1s 
18be			 
18be			 
18be cd b2 1e			call next_page_prompt 
18c1			 
18c1				; restore  
18c1			 
18c1 f1				pop af 
18c2 e1				pop hl 
18c3 c1				pop bc 
18c4 d1				pop de 
18c5 c9				ret 
18c6			 
18c6			break_point_state: 
18c6 f5				push af 
18c7			 
18c7				; see if disabled 
18c7			 
18c7 3a 3f f3			ld a, (os_view_disable) 
18ca fe 2a			cp '*' 
18cc 20 02			jr nz, .bpsgo 
18ce f1				pop af 
18cf c9				ret 
18d0			 
18d0			.bpsgo: 
18d0 f1				pop af 
18d1 f5				push af 
18d2 22 3b f3			ld (os_view_hl), hl 
18d5 ed 53 39 f3		ld (os_view_de), de 
18d9 ed 43 37 f3		ld (os_view_bc), bc 
18dd e5				push hl 
18de 6f				ld l, a 
18df 26 00			ld h, 0 
18e1 22 3d f3			ld (os_view_af),hl 
18e4			 
18e4 21 4a fe				ld hl, display_fb0 
18e7 22 55 fd				ld (display_fb_active), hl 
18ea e1				pop hl	 
18eb			 
18eb 3e 31			ld a, '1' 
18ed fe 2a		.bps1:  cp '*' 
18ef 20 03			jr nz, .bps1b 
18f1 32 3f f3			ld (os_view_disable),a 
18f4 fe 31		.bps1b:  cp '1' 
18f6 20 14			jr nz, .bps2 
18f8			 
18f8				; display reg 
18f8			 
18f8				 
18f8			 
18f8 3a 3d f3			ld a, (os_view_af) 
18fb 2a 3b f3			ld hl, (os_view_hl) 
18fe ed 5b 39 f3		ld de, (os_view_de) 
1902 ed 4b 37 f3		ld bc, (os_view_bc) 
1906 cd a0 19			call display_reg_state 
1909 c3 8c 19			jp .bpschk 
190c			 
190c fe 32		.bps2:  cp '2' 
190e 20 08			jr nz, .bps3 
1910				 
1910				; display hl 
1910 2a 3b f3			ld hl, (os_view_hl) 
1913 cd 8a 1a			call display_dump_at_hl 
1916			 
1916 18 74			jr .bpschk 
1918			 
1918 fe 33		.bps3:  cp '3' 
191a 20 08			jr nz, .bps4 
191c			 
191c			        ; display de 
191c 2a 39 f3			ld hl, (os_view_de) 
191f cd 8a 1a			call display_dump_at_hl 
1922			 
1922 18 68			jr .bpschk 
1924 fe 34		.bps4:  cp '4' 
1926 20 08			jr nz, .bps5 
1928			 
1928			        ; display bc 
1928 2a 37 f3			ld hl, (os_view_bc) 
192b cd 8a 1a			call display_dump_at_hl 
192e			 
192e 18 5c			jr .bpschk 
1930 fe 35		.bps5:  cp '5' 
1932 20 08		        jr nz, .bps7 
1934			 
1934				; display cur ptr 
1934 2a cd fb			ld hl, (cli_ptr) 
1937 cd 8a 1a			call display_dump_at_hl 
193a			 
193a 18 50			jr .bpschk 
193c fe 36		.bps7:  cp '6' 
193e 20 08			jr nz, .bps8b 
1940				 
1940				; display cur orig ptr 
1940 2a cb fb			ld hl, (cli_origptr) 
1943 cd 8a 1a			call display_dump_at_hl 
1946 18 44			jr .bpschk 
1948 fe 37		.bps8b:  cp '7' 
194a 20 08			jr nz, .bps9 
194c				 
194c				; display dsp 
194c 2a 7b fb			ld hl, (cli_data_sp) 
194f cd 8a 1a			call display_dump_at_hl 
1952			 
1952 18 38			jr .bpschk 
1954 fe 39		.bps9:  cp '9' 
1956 20 05			jr nz, .bps8c 
1958				 
1958				; display SP 
1958			;	ld hl, sp 
1958 cd 8a 1a			call display_dump_at_hl 
195b			 
195b 18 2f			jr .bpschk 
195d fe 38		.bps8c:  cp '8' 
195f 20 08			jr nz, .bps8d 
1961				 
1961				; display rsp 
1961 2a 7f fb			ld hl, (cli_ret_sp) 
1964 cd 8a 1a			call display_dump_at_hl 
1967			 
1967 18 23			jr .bpschk 
1969 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
196b 20 05			jr nz, .bps8 
196d cd a8 1c			call monitor 
1970			 
1970 18 1a			jr .bpschk 
1972 fe 30		.bps8:  cp '0' 
1974 20 16			jr nz, .bpschk 
1976			 
1976 21 f9 fd				ld hl, display_fb1 
1979 22 55 fd				ld (display_fb_active), hl 
197c cd 38 0d				call update_display 
197f			 
197f				;ld a, (os_view_af) 
197f 2a 3b f3			ld hl, (os_view_hl) 
1982 ed 5b 39 f3		ld de, (os_view_de) 
1986 ed 4b 37 f3		ld bc, (os_view_bc) 
198a f1				pop af 
198b c9				ret 
198c			 
198c			.bpschk:   
198c cd 92 0c			call delay1s 
198f 3e 4f		ld a,display_row_4 + display_cols - 1 
1991 11 b0 1e		        ld de, endprg 
1994 cd 28 0d			call str_at_display 
1997 cd 38 0d			call update_display 
199a cd 29 73			call cin_wait 
199d			 
199d c3 ed 18			jp .bps1 
19a0			 
19a0			 
19a0			display_reg_state: 
19a0			 
19a0				; to restore afterwards 
19a0			 
19a0 d5				push de 
19a1 c5				push bc 
19a2 e5				push hl 
19a3 f5				push af 
19a4			 
19a4				; for use in here 
19a4			 
19a4 c5				push bc 
19a5 d5				push de 
19a6 e5				push hl 
19a7 f5				push af 
19a8			 
19a8 cd 15 0d			call clear_display 
19ab			 
19ab 11 60 1a			ld de, .regstate 
19ae 3e 00			ld a, display_row_1 
19b0 cd 28 0d			call str_at_display 
19b3			 
19b3				; display debug step 
19b3			 
19b3			 
19b3 11 b4 fe			ld de, debug_mark 
19b6 3e 11			ld a, display_row_1+display_cols-3 
19b8 cd 28 0d			call str_at_display 
19bb			 
19bb				; display a 
19bb 11 7c 1a			ld de, .regstatea 
19be 3e 14			ld a, display_row_2 
19c0 cd 28 0d			call str_at_display 
19c3			 
19c3 e1				pop hl 
19c4			;	ld h,0 
19c4			;	ld l, a 
19c4 3e 17			ld a, display_row_2+3 
19c6 cd 4b 18			call display_word_at 
19c9			 
19c9			 
19c9				; display hl 
19c9			 
19c9			 
19c9 11 70 1a			ld de, .regstatehl 
19cc 3e 1e			ld a, display_row_2+10 
19ce cd 28 0d			call str_at_display 
19d1			 
19d1 e1				pop hl 
19d2 3e 21			ld a, display_row_2+13 
19d4 cd 4b 18			call display_word_at 
19d7			 
19d7				 
19d7				; display de 
19d7			 
19d7 11 74 1a			ld de, .regstatede 
19da 3e 28			ld a, display_row_3 
19dc cd 28 0d			call str_at_display 
19df			 
19df e1				pop hl 
19e0			;	ld h,d 
19e0			;	ld l, e 
19e0 3e 2b			ld a, display_row_3+3 
19e2 cd 4b 18			call display_word_at 
19e5			 
19e5			 
19e5				; display bc 
19e5			 
19e5 11 78 1a			ld de, .regstatebc 
19e8 3e 32			ld a, display_row_3+10 
19ea cd 28 0d			call str_at_display 
19ed			 
19ed e1				pop hl 
19ee			;	ld h,b 
19ee			;	ld l, c 
19ee 3e 35			ld a, display_row_3+13 
19f0 cd 4b 18			call display_word_at 
19f3			 
19f3			 
19f3				; display dsp 
19f3			 
19f3 11 80 1a			ld de, .regstatedsp 
19f6 3e 3c			ld a, display_row_4 
19f8 cd 28 0d			call str_at_display 
19fb			 
19fb				 
19fb 2a 7b fb			ld hl,(cli_data_sp) 
19fe 3e 40			ld a, display_row_4+4 
1a00 cd 4b 18			call display_word_at 
1a03			 
1a03				; display rsp 
1a03			 
1a03 11 85 1a			ld de, .regstatersp 
1a06 3e 46			ld a, display_row_4+10 
1a08 cd 28 0d			call str_at_display 
1a0b			 
1a0b				 
1a0b 2a 7f fb			ld hl,(cli_ret_sp) 
1a0e 3e 4a			ld a, display_row_4+14 
1a10 cd 4b 18			call display_word_at 
1a13			 
1a13 cd 38 0d			call update_display 
1a16			 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			 
1a16			 
1a16			;	call next_page_prompt 
1a16			 
1a16				; restore  
1a16			 
1a16 f1				pop af 
1a17 e1				pop hl 
1a18 c1				pop bc 
1a19 d1				pop de 
1a1a c9				ret 
1a1b			 
1a1b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a2f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a44 .. 00		.ptrstate:	db "Ptr State",0 
1a4e .. 00		.ptrcliptr:     db "cli_ptr",0 
1a56 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a60 .. 00		.regstate:	db "Reg State (1/0)",0 
1a70 .. 00		.regstatehl:	db "HL:",0 
1a74 .. 00		.regstatede:	db "DE:",0 
1a78 .. 00		.regstatebc:	db "BC:",0 
1a7c .. 00		.regstatea:	db "A :",0 
1a80 .. 00		.regstatedsp:	db "DSP:",0 
1a85 .. 00		.regstatersp:	db "RSP:",0 
1a8a			 
1a8a			display_dump_at_hl: 
1a8a e5				push hl 
1a8b d5				push de 
1a8c c5				push bc 
1a8d f5				push af 
1a8e			 
1a8e 22 71 f6			ld (os_cur_ptr),hl	 
1a91 cd 15 0d			call clear_display 
1a94 cd ba 1d			call dumpcont 
1a97			;	call delay1s 
1a97			;	call next_page_prompt 
1a97			 
1a97			 
1a97 f1				pop af 
1a98 c1				pop bc 
1a99 d1				pop de 
1a9a e1				pop hl 
1a9b c9				ret 
1a9c			 
1a9c			;if ENABLE_BASIC 
1a9c			;	include "nascombasic.asm" 
1a9c			;	basic: 
1a9c			;	include "forth/FORTH.ASM" 
1a9c			;endif 
1a9c			 
1a9c			; eof 
1a9c			 
1a9c			 
# End of file firmware_diags.asm
1a9c			  
1a9c			include "firmware_prompts.asm"  
1a9c			; Prompts  
1a9c			 
1a9c			; boot messages 
1a9c			 
1a9c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ab1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1ac1			 
1ac1			 
1ac1			; config menus 
1ac1			 
1ac1 .. 00		prom_c3: db "Add Dictionary To File",0 
1ad8 .. 00		prom_c2: db "Select Autoload File",0 
1aed .. 00		prom_c2a: db "Disable Autoload File", 0 
1b03 .. 00		prom_c2b: db "Select Storage Bank",0 
1b17 .. 00		prom_c4: db "Settings",0 
1b20 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b3b .. 00		prom_m4b:   db "Monitor",0 
1b43 .. 00		prom_c1: db "Hardware Diags",0 
1b52			 
1b52			 
1b52 .. 00		prom_notav:    db "Feature not available",0 
1b68 .. 00		prom_empty:    db "",0 
1b69			 
1b69			; eof 
1b69			 
# End of file firmware_prompts.asm
1b69			  
1b69			  
1b69			; eof  
1b69			  
# End of file firmware.asm
1b69			 
1b69			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b69			;if BASE_KEV  
1b69			;baseram: equ 08000h 
1b69			;endif 
1b69			 
1b69			;if BASE_SC114 
1b69			;baseram:     equ    endofcode 
1b69			;endif 
1b69			 
1b69			 
1b69			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1b69			 
1b69			; start system 
1b69			 
1b69			coldstart: 
1b69				; set sp 
1b69				; di/ei 
1b69			 
1b69 f3				di 
1b6a 31 fd ff			ld sp, tos 
1b6d			;	ei 
1b6d			 
1b6d			 
1b6d				; disable breakpoint by default 
1b6d			 
1b6d 3e 2a			ld a,'*' 
1b6f 32 3f f3			ld (os_view_disable),a 
1b72			 
1b72				; init hardware 
1b72			 
1b72				; init keyboard and screen hardware 
1b72			 
1b72 cd 1c 00			call hardware_init 
1b75			 
1b75			 
1b75 cd 92 0c			call delay1s 
1b78 3e 30			ld a, display_row_3+8 
1b7a 11 03 00			ld de, buildtime 
1b7d cd 28 0d			call str_at_display 
1b80 cd 38 0d			call update_display 
1b83			 
1b83 cd 92 0c			call delay1s 
1b86 cd 92 0c			call delay1s 
1b89 cd 92 0c			call delay1s 
1b8c			 
1b8c				; detect if any keys are held down to enable breakpoints at start up 
1b8c			 
1b8c cd 3a 73			call cin  
1b8f fe 00			cp 0 
1b91 28 03			jr z, .nokeys 
1b93			 
1b93				;call hardware_diags 
1b93 cd a9 15			call config 
1b96			 
1b96			;	ld de, .bpen 
1b96			;	ld a, display_row_4 
1b96			;	call str_at_display 
1b96			;	call update_display 
1b96			; 
1b96			;	ld a,0 
1b96			;	ld (os_view_disable),a 
1b96			; 
1b96			;.bpwait: 
1b96			;	call cin 
1b96			;	cp 0 
1b96			;	jr z, .bpwait 
1b96			;	jr .nokeys 
1b96			; 
1b96			; 
1b96			;.bpen:  db "Break points enabled!",0 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			.nokeys: 
1b96			 
1b96			 
1b96				 
1b96			 
1b96			;jp  testkey 
1b96			 
1b96			;call storage_get_block_0 
1b96			; 
1b96			;ld hl, 0 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96				 
1b96			;ld hl, 10 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			;stop:	nop 
1b96			;	jp stop 
1b96			 
1b96			 
1b96			 
1b96			main: 
1b96 cd 15 0d			call clear_display 
1b99 cd 38 0d			call update_display 
1b9c			 
1b9c			 
1b9c			 
1b9c			;	call testlcd 
1b9c			 
1b9c			 
1b9c			 
1b9c cd b7 22			call forth_init 
1b9f			 
1b9f			 
1b9f			warmstart: 
1b9f cd 8d 22			call forth_warmstart 
1ba2			 
1ba2				; run startup word load 
1ba2			        ; TODO prevent this running at warmstart after crash  
1ba2			 
1ba2				if STARTUP_ENABLE 
1ba2					if STORAGE_SE 
1ba2 cd 6b 70					call forth_autoload 
1ba5					endif 
1ba5 cd 7a 6d				call forth_startup 
1ba8			 
1ba8			 
1ba8				endif 
1ba8			 
1ba8				; show free memory after boot 
1ba8 11 42 1c			ld de, freeram 
1bab 3e 00			ld a, display_row_1 
1bad cd 28 0d			call str_at_display 
1bb0			 
1bb0			; Or use heap_size word???? 
1bb0 21 34 f3			ld hl, heap_end 
1bb3 11 0e 80			ld de, heap_start 
1bb6 ed 52			sbc hl, de 
1bb8 e5				push hl 
1bb9 7c				ld a,h	         	 
1bba 21 53 f6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bbd cd 4a 12			call hexout 
1bc0 e1			   	pop hl 
1bc1			 
1bc1 7d				ld a,l 
1bc2 21 55 f6			ld hl, os_word_scratch+2 
1bc5 cd 4a 12			call hexout 
1bc8 21 57 f6			ld hl, os_word_scratch+4 
1bcb 3e 00			ld a, 0 
1bcd 77				ld (hl),a 
1bce 11 53 f6			ld de, os_word_scratch 
1bd1 3e 0d			ld a, display_row_1 + 13 
1bd3 cd 28 0d			call str_at_display 
1bd6 cd 38 0d			call update_display 
1bd9			 
1bd9			 
1bd9				;call demo 
1bd9			 
1bd9			 
1bd9				; init scratch input area for cli commands 
1bd9			 
1bd9 21 75 f6			ld hl, os_cli_cmd 
1bdc 3e 00			ld a,0 
1bde 77				ld (hl),a 
1bdf 23				inc hl 
1be0 77				ld (hl),a 
1be1			 
1be1 3e 00			ld a,0 
1be3 32 74 f7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1be6			 
1be6 32 71 f6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1be9 32 72 f6			ld (os_cur_ptr+1),a	 
1bec			 
1bec 32 53 f6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1bef 32 54 f6			ld (os_word_scratch+1),a	 
1bf2				 
1bf2			 
1bf2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bf2 21 75 f6			ld hl, os_cli_cmd 
1bf5			 
1bf5 3e 00			ld a, 0		 ; init cli input 
1bf7 77				ld (hl), a 
1bf8 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bfa			cli: 
1bfa				; show cli prompt 
1bfa				;push af 
1bfa				;ld a, 0 
1bfa				;ld de, prompt 
1bfa				;call str_at_display 
1bfa			 
1bfa				;call update_display 
1bfa				;pop af 
1bfa				;inc a 
1bfa				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bfa 0e 00			ld c, 0 
1bfc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bfe 1e 28			ld e, 40 
1c00			 
1c00 21 75 f6			ld hl, os_cli_cmd 
1c03			 
1c03				STACKFRAME OFF $fefe $9f9f 
1c03				if DEBUG_STACK_IMB 
1c03					if OFF 
1c03						exx 
1c03						ld de, $fefe 
1c03						ld a, d 
1c03						ld hl, curframe 
1c03						call hexout 
1c03						ld a, e 
1c03						ld hl, curframe+2 
1c03						call hexout 
1c03						ld hl, $fefe 
1c03						push hl 
1c03						ld hl, $9f9f 
1c03						push hl 
1c03						exx 
1c03					endif 
1c03				endif 
1c03			endm 
# End of macro STACKFRAME
1c03			 
1c03 cd 76 0f			call input_str 
1c06			 
1c06				STACKFRAMECHK OFF $fefe $9f9f 
1c06				if DEBUG_STACK_IMB 
1c06					if OFF 
1c06						exx 
1c06						ld hl, $9f9f 
1c06						pop de   ; $9f9f 
1c06						call cmp16 
1c06						jr nz, .spnosame 
1c06						ld hl, $fefe 
1c06						pop de   ; $fefe 
1c06						call cmp16 
1c06						jr z, .spfrsame 
1c06						.spnosame: call showsperror 
1c06						.spfrsame: nop 
1c06						exx 
1c06					endif 
1c06				endif 
1c06			endm 
# End of macro STACKFRAMECHK
1c06			 
1c06				; copy input to last command 
1c06			 
1c06 21 75 f6			ld hl, os_cli_cmd 
1c09 11 74 f7			ld de, os_last_cmd 
1c0c 01 ff 00			ld bc, 255 
1c0f ed b0			ldir 
1c11			 
1c11				; wipe current buffer 
1c11			 
1c11			;	ld a, 0 
1c11			;	ld hl, os_cli_cmd 
1c11			;	ld de, os_cli_cmd+1 
1c11			;	ld bc, 254 
1c11			;	ldir 
1c11				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c11			;	call strcpy 
1c11			;	ld a, 0 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			 
1c11				; switch frame buffer to program  
1c11			 
1c11 21 f9 fd				ld hl, display_fb1 
1c14 22 55 fd				ld (display_fb_active), hl 
1c17			 
1c17			;	nop 
1c17				STACKFRAME ON $fbfe $8f9f 
1c17				if DEBUG_STACK_IMB 
1c17					if ON 
1c17						exx 
1c17						ld de, $fbfe 
1c17						ld a, d 
1c17						ld hl, curframe 
1c17						call hexout 
1c17						ld a, e 
1c17						ld hl, curframe+2 
1c17						call hexout 
1c17						ld hl, $fbfe 
1c17						push hl 
1c17						ld hl, $8f9f 
1c17						push hl 
1c17						exx 
1c17					endif 
1c17				endif 
1c17			endm 
# End of macro STACKFRAME
1c17				; first time into the parser so pass over the current scratch pad 
1c17 21 75 f6			ld hl,os_cli_cmd 
1c1a				; tokenise the entered statement(s) in HL 
1c1a cd 35 23			call forthparse 
1c1d			        ; exec forth statements in top of return stack 
1c1d cd 75 23			call forthexec 
1c20				;call forthexec_cleanup 
1c20			;	call parsenext 
1c20			 
1c20				STACKFRAMECHK ON $fbfe $8f9f 
1c20				if DEBUG_STACK_IMB 
1c20					if ON 
1c20						exx 
1c20						ld hl, $8f9f 
1c20						pop de   ; $8f9f 
1c20						call cmp16 
1c20						jr nz, .spnosame 
1c20						ld hl, $fbfe 
1c20						pop de   ; $fbfe 
1c20						call cmp16 
1c20						jr z, .spfrsame 
1c20						.spnosame: call showsperror 
1c20						.spfrsame: nop 
1c20						exx 
1c20					endif 
1c20				endif 
1c20			endm 
# End of macro STACKFRAMECHK
1c20				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c20			 
1c20 3e 3c			ld a, display_row_4 
1c22 11 54 1c			ld de, endprog 
1c25			 
1c25 cd 38 0d			call update_display		 
1c28			 
1c28 cd b2 1e			call next_page_prompt 
1c2b			 
1c2b				; switch frame buffer to cli 
1c2b			 
1c2b 21 4a fe				ld hl, display_fb0 
1c2e 22 55 fd				ld (display_fb_active), hl 
1c31			 
1c31			 
1c31 cd 15 0d		        call clear_display 
1c34 cd 38 0d			call update_display		 
1c37			 
1c37 21 75 f6			ld hl, os_cli_cmd 
1c3a			 
1c3a 3e 00			ld a, 0		 ; init cli input 
1c3c 77				ld (hl), a 
1c3d			 
1c3d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c3d			 
1c3d				; now on last line 
1c3d			 
1c3d				; TODO scroll screen up 
1c3d			 
1c3d				; TODO instead just clear screen and place at top of screen 
1c3d			 
1c3d			;	ld a, 0 
1c3d			;	ld (f_cursor_ptr),a 
1c3d			 
1c3d				;call clear_display 
1c3d				;call update_display 
1c3d			 
1c3d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3f c3 fa 1b			jp cli 
1c42			 
1c42 .. 00		freeram: db "Free bytes: $",0 
1c50 ..			asc: db "1A2F" 
1c54 .. 00		endprog: db "End prog...",0 
1c60			 
1c60			testenter2:   
1c60 21 80 f3			ld hl,scratch+50 
1c63 22 71 f6			ld (os_cur_ptr),hl 
1c66 c3 fa 1b			jp cli 
1c69			 
1c69			testenter:  
1c69			 
1c69 21 50 1c			ld hl,asc 
1c6c			;	ld a,(hl) 
1c6c			;	call nibble2val 
1c6c cd a0 12			call get_byte 
1c6f			 
1c6f			 
1c6f			;	ld a,(hl) 
1c6f			;	call atohex 
1c6f			 
1c6f			;	call fourehexhl 
1c6f 32 80 f3			ld (scratch+50),a 
1c72			 
1c72			 
1c72			 
1c72 21 52 1c			ld hl,asc+2 
1c75			;	ld a, (hl) 
1c75			;	call nibble2val 
1c75 cd a0 12			call get_byte 
1c78			 
1c78			;	call fourehexhl 
1c78 32 82 f3			ld (scratch+52),a 
1c7b				 
1c7b 21 80 f3			ld hl,scratch+50 
1c7e 22 71 f6			ld (os_cur_ptr),hl 
1c81 c3 fa 1b			jp cli 
1c84			 
1c84			enter:	 
1c84 3a 52 f3			ld a,(scratch+4) 
1c87 fe 00			cp 0 
1c89 28 0c			jr z, .entercont 
1c8b				; no, not a null term line so has an address to work out.... 
1c8b			 
1c8b 21 50 f3			ld hl,scratch+2 
1c8e cd 00 13			call get_word_hl 
1c91			 
1c91 22 71 f6			ld (os_cur_ptr),hl	 
1c94 c3 fa 1b			jp cli 
1c97			 
1c97			 
1c97			.entercont:  
1c97			 
1c97 21 50 f3			ld hl, scratch+2 
1c9a cd a0 12			call get_byte 
1c9d			 
1c9d 2a 71 f6		   	ld hl,(os_cur_ptr) 
1ca0 77					ld (hl),a 
1ca1 23					inc hl 
1ca2 22 71 f6				ld (os_cur_ptr),hl 
1ca5				 
1ca5			; get byte  
1ca5			 
1ca5			 
1ca5 c3 fa 1b			jp cli 
1ca8			 
1ca8			 
1ca8			; basic monitor support 
1ca8			 
1ca8			monitor: 
1ca8				;  
1ca8 cd 15 0d			call clear_display 
1cab 3e 00			ld a, 0 
1cad 11 f5 1c			ld de, .monprompt 
1cb0 cd 28 0d			call str_at_display 
1cb3 cd 38 0d			call update_display 
1cb6			 
1cb6				; get a monitor command 
1cb6			 
1cb6 0e 00			ld c, 0     ; entry at top left 
1cb8 16 64			ld d, 100   ; max buffer size 
1cba 1e 0f			ld e, 15    ; input scroll area 
1cbc 3e 00			ld a, 0     ; init string 
1cbe 21 4c f5			ld hl, os_input 
1cc1 77				ld (hl), a 
1cc2 23				inc hl 
1cc3 77				ld (hl), a 
1cc4 21 4c f5			ld hl, os_input 
1cc7 3e 01			ld a, 1     ; init string 
1cc9 cd 76 0f			call input_str 
1ccc			 
1ccc cd 15 0d		        call clear_display 
1ccf cd 38 0d			call update_display		 
1cd2			 
1cd2 3a 4c f5			ld a, (os_input) 
1cd5 cd 9e 13			call toUpper 
1cd8 fe 48		        cp 'H' 
1cda 28 6f		        jr z, .monhelp 
1cdc fe 44			cp 'D'		; dump 
1cde ca 6c 1d			jp z, .mondump	 
1ce1 fe 43			cp 'C'		; dump 
1ce3 ca 86 1d			jp z, .moncdump	 
1ce6 fe 4d			cp 'M'		; dump 
1ce8 ca f7 1c			jp z, .moneditstart 
1ceb fe 55			cp 'U'		; dump 
1ced 28 14			jr z, .monedit	 
1cef fe 51			cp 'Q'		; dump 
1cf1 c8				ret z	 
1cf2			 
1cf2			 
1cf2				; TODO "S" to access symbol by name and not need the address 
1cf2				; TODO "F" to find a string in memory 
1cf2			 
1cf2 c3 a8 1c			jp monitor 
1cf5			 
1cf5 .. 00		.monprompt: db ">", 0 
1cf7			 
1cf7			.moneditstart: 
1cf7				; get starting address 
1cf7			 
1cf7 21 4e f5			ld hl,os_input+2 
1cfa cd 00 13			call get_word_hl 
1cfd			 
1cfd 22 71 f6			ld (os_cur_ptr),hl	 
1d00			 
1d00 c3 a8 1c			jp monitor 
1d03			 
1d03			.monedit: 
1d03				; get byte to load 
1d03			 
1d03 21 4e f5			ld hl,os_input+2 
1d06 cd a0 12			call get_byte 
1d09			 
1d09				; get address to update 
1d09 2a 71 f6			ld hl, (os_cur_ptr) 
1d0c			 
1d0c				; update byte 
1d0c			 
1d0c 77				ld (hl), a 
1d0d			 
1d0d				; move to next address and save it 
1d0d			 
1d0d 23				inc hl 
1d0e 22 71 f6			ld (os_cur_ptr),hl	 
1d11			 
1d11 c3 a8 1c			jp monitor 
1d14			 
1d14			 
1d14 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d28 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d44 .. 00		.monhelptext3:  db "Q-Quit",0 
1d4b			        
1d4b			.monhelp: 
1d4b 3e 00			ld a, display_row_1 
1d4d 11 14 1d		        ld de, .monhelptext1 
1d50			 
1d50 cd 28 0d			call str_at_display 
1d53 3e 14			ld a, display_row_2 
1d55 11 28 1d		        ld de, .monhelptext2 
1d58					 
1d58 cd 28 0d			call str_at_display 
1d5b 3e 28			ld a, display_row_3 
1d5d 11 44 1d		        ld de, .monhelptext3 
1d60					 
1d60 cd 28 0d			call str_at_display 
1d63 cd 38 0d			call update_display		 
1d66			 
1d66 cd b2 1e			call next_page_prompt 
1d69 c3 a8 1c			jp monitor 
1d6c			 
1d6c			.mondump:    
1d6c 21 4e f5			ld hl,os_input+2 
1d6f cd 00 13			call get_word_hl 
1d72			 
1d72 22 71 f6			ld (os_cur_ptr),hl	 
1d75 cd ba 1d			call dumpcont 
1d78 3e 3c			ld a, display_row_4 
1d7a 11 54 1c			ld de, endprog 
1d7d			 
1d7d cd 38 0d			call update_display		 
1d80			 
1d80 cd b2 1e			call next_page_prompt 
1d83 c3 a8 1c			jp monitor 
1d86			.moncdump: 
1d86 cd ba 1d			call dumpcont 
1d89 3e 3c			ld a, display_row_4 
1d8b 11 54 1c			ld de, endprog 
1d8e			 
1d8e cd 38 0d			call update_display		 
1d91			 
1d91 cd b2 1e			call next_page_prompt 
1d94 c3 a8 1c			jp monitor 
1d97			 
1d97			 
1d97			; TODO symbol access  
1d97			 
1d97			.symbols:     ;; A list of symbols that can be called up  
1d97 4a fe			dw display_fb0 
1d99 .. 00			db "fb0",0  
1d9d 07 fc		     	dw store_page 
1d9f .. 00			db "store_page",0 
1daa			 
1daa			 
1daa			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1daa			 
1daa 3a 4f f3			ld a,(scratch+1) 
1dad fe 00			cp 0 
1daf 28 09			jr z, dumpcont 
1db1			 
1db1				; no, not a null term line so has an address to work out.... 
1db1			 
1db1 21 50 f3			ld hl,scratch+2 
1db4 cd 00 13			call get_word_hl 
1db7			 
1db7 22 71 f6			ld (os_cur_ptr),hl	 
1dba			 
1dba			 
1dba			 
1dba			dumpcont: 
1dba			 
1dba				; dump bytes at ptr 
1dba			 
1dba			 
1dba 3e 00			ld a, display_row_1 
1dbc 2a 55 fd			ld hl, (display_fb_active) 
1dbf cd 49 0f			call addatohl 
1dc2 cd ea 1d			call .dumpbyterow 
1dc5			 
1dc5 3e 14			ld a, display_row_2 
1dc7 2a 55 fd			ld hl, (display_fb_active) 
1dca cd 49 0f			call addatohl 
1dcd cd ea 1d			call .dumpbyterow 
1dd0			 
1dd0			 
1dd0 3e 28			ld a, display_row_3 
1dd2 2a 55 fd			ld hl, (display_fb_active) 
1dd5 cd 49 0f			call addatohl 
1dd8 cd ea 1d			call .dumpbyterow 
1ddb			 
1ddb 3e 3c			ld a, display_row_4 
1ddd 2a 55 fd			ld hl, (display_fb_active) 
1de0 cd 49 0f			call addatohl 
1de3 cd ea 1d			call .dumpbyterow 
1de6			 
1de6 cd 38 0d			call update_display 
1de9			;		jp cli 
1de9 c9				ret 
1dea			 
1dea			.dumpbyterow: 
1dea			 
1dea				;push af 
1dea			 
1dea e5				push hl 
1deb			 
1deb				; calc where to poke the ascii 
1deb			if display_cols == 20 
1deb 3e 10			ld a, 16 
1ded			else 
1ded				ld a, 31 
1ded			endif 
1ded			 
1ded cd 49 0f			call addatohl 
1df0 22 53 f6			ld (os_word_scratch),hl  		; save pos for later 
1df3			 
1df3			 
1df3			; display decoding address 
1df3 2a 71 f6		   	ld hl,(os_cur_ptr) 
1df6			 
1df6 7c				ld a,h 
1df7 e1				pop hl 
1df8 e5				push hl 
1df9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1df9 cd 4a 12			call hexout 
1dfc 2a 71 f6		   	ld hl,(os_cur_ptr) 
1dff			 
1dff 7d				ld a,l 
1e00 e1				pop hl 
1e01 23				inc hl 
1e02 23				inc hl 
1e03 e5				push hl 
1e04			;	ld hl, os_word_scratch+2 
1e04 cd 4a 12			call hexout 
1e07 e1				pop hl 
1e08 23				inc hl 
1e09 23				inc hl 
1e0a				;ld hl, os_word_scratch+4 
1e0a 3e 3a			ld a, ':' 
1e0c 77				ld (hl),a 
1e0d 23				inc hl 
1e0e				;ld a, 0 
1e0e				;ld (hl),a 
1e0e				;ld de, os_word_scratch 
1e0e				;pop af 
1e0e				;push af 
1e0e			;		ld a, display_row_2 
1e0e			;		call str_at_display 
1e0e			;		call update_display 
1e0e			 
1e0e			 
1e0e			;pop af 
1e0e			;	add 5 
1e0e			 
1e0e			if display_cols == 20 
1e0e 06 04			ld b, 4 
1e10			else 
1e10				ld b, 8 
1e10			endif	 
1e10			 
1e10			.dumpbyte: 
1e10 c5				push bc 
1e11 e5				push hl 
1e12			 
1e12			 
1e12 2a 71 f6		   	ld hl,(os_cur_ptr) 
1e15 7e					ld a,(hl) 
1e16			 
1e16					; poke the ascii to display 
1e16 2a 53 f6				ld hl,(os_word_scratch) 
1e19 77					ld (hl),a 
1e1a 23					inc hl 
1e1b 22 53 f6				ld (os_word_scratch),hl 
1e1e			 
1e1e					 
1e1e			 
1e1e			 
1e1e e1					pop hl 
1e1f e5					push hl 
1e20			 
1e20 cd 4a 12				call hexout 
1e23			 
1e23					 
1e23 2a 71 f6		   	ld hl,(os_cur_ptr) 
1e26 23				inc hl 
1e27 22 71 f6		   	ld (os_cur_ptr),hl 
1e2a			 
1e2a e1					pop hl 
1e2b 23					inc hl 
1e2c 23					inc hl 
1e2d 23					inc hl 
1e2e			 
1e2e			 
1e2e			 
1e2e					;ld a,0 
1e2e					;ld (os_word_scratch+2),a 
1e2e					;pop af 
1e2e					;push af 
1e2e			 
1e2e					;ld de, os_word_scratch 
1e2e					;call str_at_display 
1e2e			;		call update_display 
1e2e			;		pop af 
1e2e c1					pop bc 
1e2f c6 03				add 3 
1e31 10 dd			djnz .dumpbyte 
1e33			 
1e33				 
1e33			 
1e33 c9				ret 
1e34			 
1e34			jump:	 
1e34			 
1e34 21 50 f3			ld hl,scratch+2 
1e37 cd 00 13			call get_word_hl 
1e3a				;ld hl,(scratch+2) 
1e3a				;call fourehexhl 
1e3a			 
1e3a 22 71 f6			ld (os_cur_ptr),hl	 
1e3d			 
1e3d e9				jp (hl) 
1e3e			 
1e3e			 
1e3e			 
1e3e			; TODO implement a basic monitor mode to start with 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			; testing and demo code during development 
1e3e			 
1e3e			 
1e3e .. 00		str1: db "Enter some text...",0 
1e51 .. 00		clear: db "                    ",0 
1e66			 
1e66			demo: 
1e66			 
1e66			 
1e66			 
1e66			;	call update_display 
1e66			 
1e66				; init scratch input area for testing 
1e66 21 4e f3			ld hl, scratch	 
1e69 3e 00			ld a,0 
1e6b 77				ld (hl),a 
1e6c			 
1e6c			 
1e6c 3e 14		            LD   A, display_row_2 
1e6e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e6e 11 3e 1e		            LD   DE, str1 
1e71 cd 28 0d			call str_at_display 
1e74			 
1e74			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e74			cloop:	 
1e74 3e 28		            LD   A, display_row_3 
1e76			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e76 11 51 1e		            LD   DE, clear 
1e79			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e79 cd 28 0d				call str_at_display 
1e7c 3e 3c			ld a, display_row_4 
1e7e 11 ae 1e			ld de, prompt 
1e81			 
1e81 cd 28 0d				call str_at_display 
1e84 cd 38 0d			call update_display 
1e87			 
1e87 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e89 16 0a			ld d, 10 
1e8b 21 4e f3			ld hl, scratch	 
1e8e cd 76 0f			call input_str 
1e91			 
1e91			;	call clear_display 
1e91			;'	call update_display 
1e91			 
1e91 3e 00		            LD   A, display_row_1 
1e93			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e93 11 51 1e		            LD   DE, clear 
1e96 cd 28 0d				call str_at_display 
1e99			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e99 3e 00		            LD   A, display_row_1 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 4e f3		            LD   DE, scratch 
1e9e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e9e cd 28 0d				call str_at_display 
1ea1 cd 38 0d			call update_display 
1ea4			 
1ea4 3e 00				ld a,0 
1ea6 21 4e f3			ld hl, scratch 
1ea9 77				ld (hl),a 
1eaa			 
1eaa 00				nop 
1eab c3 74 1e			jp cloop 
1eae			 
1eae			 
1eae			 
1eae			; OS Prompt 
1eae			 
1eae .. 00		prompt: db ">",0 
1eb0 .. 00		endprg: db "?",0 
1eb2			 
1eb2			 
1eb2			; handy next page prompt 
1eb2			next_page_prompt: 
1eb2 e5				push hl 
1eb3 d5				push de 
1eb4 f5				push af 
1eb5 c5				push bc 
1eb6			 
1eb6 3e 4f			ld a,display_row_4 + display_cols - 1 
1eb8 11 b0 1e		        ld de, endprg 
1ebb cd 28 0d			call str_at_display 
1ebe cd 38 0d			call update_display 
1ec1 cd 29 73			call cin_wait 
1ec4 c1				pop bc 
1ec5 f1				pop af 
1ec6 d1				pop de 
1ec7 e1				pop hl 
1ec8			 
1ec8			 
1ec8 c9				ret 
1ec9			 
1ec9			 
1ec9			; forth parser 
1ec9			 
1ec9			; My forth kernel 
1ec9			include "forth_kernel.asm" 
1ec9			; 
1ec9			; kernel to the forth OS 
1ec9			 
1ec9			DS_TYPE_STR: equ 1     ; string type 
1ec9			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ec9			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ec9			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ec9			 
1ec9			FORTH_PARSEV1: equ 0 
1ec9			FORTH_PARSEV2: equ 0 
1ec9			FORTH_PARSEV3: equ 0 
1ec9			FORTH_PARSEV4: equ 0 
1ec9			FORTH_PARSEV5: equ 1 
1ec9			 
1ec9			;if FORTH_PARSEV5 
1ec9			;	FORTH_END_BUFFER: equ 0 
1ec9			;else 
1ec9			FORTH_END_BUFFER: equ 127 
1ec9			;endif 
1ec9			 
1ec9			FORTH_TRUE: equ 1 
1ec9			FORTH_FALSE: equ 0 
1ec9			 
1ec9			if FORTH_PARSEV4 
1ec9			include "forth_stackops.asm" 
1ec9			endif 
1ec9			 
1ec9			if FORTH_PARSEV5 
1ec9			include "forth_stackopsv5.asm" 
1ec9			 
1ec9			; Stack operations for v5 parser on wards 
1ec9			; * DATA stack 
1ec9			; * LOOP stack 
1ec9			; * RETURN stack 
1ec9			 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_DSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_data_sp) 
1ec9				ld de, cli_data_stack 
1ec9				call cmp16 
1ec9				jp c, fault_dsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_RSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_ret_sp) 
1ec9				ld de, cli_ret_stack 
1ec9				call cmp16 
1ec9				jp c, fault_rsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_CHK_LOOP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_loop_sp) 
1ec9				ld de, cli_loop_stack 
1ec9				call cmp16 
1ec9				jp c, fault_loop_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTSTR: macro 
1ec9				; TOSO might need more for checks when used 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_STR 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTNUM: macro 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_INUM 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			; increase data stack pointer and save hl to it 
1ec9				 
1ec9			FORTH_DSP_NEXT: macro 
1ec9				call macro_forth_dsp_next 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			macro_forth_dsp_next: 
1ec9				if DEBUG_FORTH_STACK_GUARD 
1ec9 cd 44 6e				call check_stacks 
1ecc				endif 
1ecc e5				push hl 
1ecd d5				push de 
1ece eb				ex de,hl 
1ecf 2a 7b fb			ld hl,(cli_data_sp) 
1ed2 23				inc hl 
1ed3 23				inc hl 
1ed4			 
1ed4			; PARSEV5 
1ed4 23				inc hl 
1ed5 22 7b fb			ld (cli_data_sp),hl 
1ed8 73				ld (hl), e 
1ed9 23				inc hl 
1eda 72				ld (hl), d 
1edb d1				pop de 
1edc e1				pop hl 
1edd				if DEBUG_FORTH_STACK_GUARD 
1edd cd 44 6e				call check_stacks 
1ee0				endif 
1ee0 c9				ret 
1ee1			 
1ee1			 
1ee1			; increase ret stack pointer and save hl to it 
1ee1				 
1ee1			FORTH_RSP_NEXT: macro 
1ee1				call macro_forth_rsp_next 
1ee1				endm 
1ee1			 
1ee1			macro_forth_rsp_next: 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1 cd 44 6e				call check_stacks 
1ee4				endif 
1ee4 e5				push hl 
1ee5 d5				push de 
1ee6 eb				ex de,hl 
1ee7 2a 7f fb			ld hl,(cli_ret_sp) 
1eea 23				inc hl 
1eeb 23				inc hl 
1eec 22 7f fb			ld (cli_ret_sp),hl 
1eef 73				ld (hl), e 
1ef0 23				inc hl 
1ef1 72				ld (hl), d 
1ef2 d1				pop de 
1ef3 e1				pop hl 
1ef4				if DEBUG_FORTH_STACK_GUARD 
1ef4 cd 44 6e				call check_stacks 
1ef7				endif 
1ef7 c9				ret 
1ef8			 
1ef8			; get current ret stack pointer and save to hl  
1ef8				 
1ef8			FORTH_RSP_TOS: macro 
1ef8				call macro_forth_rsp_tos 
1ef8				endm 
1ef8			 
1ef8			macro_forth_rsp_tos: 
1ef8				;push de 
1ef8 2a 7f fb			ld hl,(cli_ret_sp) 
1efb cd 33 1f			call loadhlptrtohl 
1efe				;ld e, (hl) 
1efe				;inc hl 
1efe				;ld d, (hl) 
1efe				;ex de, hl 
1efe					if DEBUG_FORTH_WORDS 
1efe			;			DMARK "RST" 
1efe						CALLMONITOR 
1efe cd c6 18			call break_point_state  
1f01				endm  
# End of macro CALLMONITOR
1f01					endif 
1f01				;pop de 
1f01 c9				ret 
1f02			 
1f02			; pop ret stack pointer 
1f02				 
1f02			FORTH_RSP_POP: macro 
1f02				call macro_forth_rsp_pop 
1f02				endm 
1f02			 
1f02			 
1f02			macro_forth_rsp_pop: 
1f02				if DEBUG_FORTH_STACK_GUARD 
1f02			;		DMARK "RPP" 
1f02 cd 44 6e				call check_stacks 
1f05					FORTH_CHK_RSP_UNDER 
1f05 e5				push hl 
1f06 d5				push de 
1f07 2a 7f fb			ld hl,(cli_ret_sp) 
1f0a 11 39 fb			ld de, cli_ret_stack 
1f0d cd 67 0f			call cmp16 
1f10 da 58 6f			jp c, fault_rsp_under 
1f13 d1				pop de 
1f14 e1				pop hl 
1f15				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f15				endif 
1f15 e5				push hl 
1f16 2a 7f fb			ld hl,(cli_ret_sp) 
1f19			 
1f19			 
1f19				if FORTH_ENABLE_FREE 
1f19			 
1f19					; get pointer 
1f19			 
1f19					push de 
1f19					push hl 
1f19			 
1f19					ld e, (hl) 
1f19					inc hl 
1f19					ld d, (hl) 
1f19			 
1f19					ex de, hl 
1f19					call free 
1f19			 
1f19					pop hl 
1f19					pop de 
1f19			 
1f19			 
1f19				endif 
1f19			 
1f19			 
1f19 2b				dec hl 
1f1a 2b				dec hl 
1f1b 22 7f fb			ld (cli_ret_sp), hl 
1f1e				; do stack underflow checks 
1f1e e1				pop hl 
1f1f				if DEBUG_FORTH_STACK_GUARD 
1f1f cd 44 6e				call check_stacks 
1f22					FORTH_CHK_RSP_UNDER 
1f22 e5				push hl 
1f23 d5				push de 
1f24 2a 7f fb			ld hl,(cli_ret_sp) 
1f27 11 39 fb			ld de, cli_ret_stack 
1f2a cd 67 0f			call cmp16 
1f2d da 58 6f			jp c, fault_rsp_under 
1f30 d1				pop de 
1f31 e1				pop hl 
1f32				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f32				endif 
1f32 c9				ret 
1f33			 
1f33			 
1f33			 
1f33			; routine to load word pointed to by hl into hl 
1f33			 
1f33			loadhlptrtohl: 
1f33			 
1f33 d5				push de 
1f34 5e				ld e, (hl) 
1f35 23				inc hl 
1f36 56				ld d, (hl) 
1f37 eb				ex de, hl 
1f38 d1				pop de 
1f39			 
1f39 c9				ret 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			; push a number held in HL onto the data stack 
1f3a			; entry point for pushing a value when already in hl used in function above 
1f3a			 
1f3a			forth_push_numhl: 
1f3a			 
1f3a e5				push hl    ; save value to push 
1f3b			 
1f3b			if DEBUG_FORTH_PUSH 
1f3b				; see if disabled 
1f3b			 
1f3b			 
1f3b f5				push af 
1f3c 3a 3f f3			ld a, (os_view_disable) 
1f3f fe 2a			cp '*' 
1f41 28 34			jr z, .pskip2 
1f43 e5				push hl 
1f44 e5			push hl 
1f45 cd 15 0d			call clear_display 
1f48 e1			pop hl 
1f49 7c				ld a,h 
1f4a 21 53 f6			ld hl, os_word_scratch 
1f4d cd 4a 12			call hexout 
1f50 e1				pop hl 
1f51 7d				ld a,l 
1f52 21 55 f6			ld hl, os_word_scratch+2 
1f55 cd 4a 12			call hexout 
1f58			 
1f58 21 57 f6			ld hl, os_word_scratch+4 
1f5b 3e 00			ld a,0 
1f5d 77				ld (hl),a 
1f5e 11 53 f6			ld de,os_word_scratch 
1f61 3e 14				ld a, display_row_2 
1f63 cd 28 0d				call str_at_display 
1f66 11 e0 59			ld de, .push_num 
1f69 3e 00			ld a, display_row_1 
1f6b			 
1f6b cd 28 0d				call str_at_display 
1f6e			 
1f6e			 
1f6e cd 38 0d			call update_display 
1f71 cd 92 0c			call delay1s 
1f74 cd 92 0c			call delay1s 
1f77			.pskip2:  
1f77			 
1f77 f1				pop af 
1f78			endif	 
1f78			 
1f78			 
1f78				FORTH_DSP_NEXT 
1f78 cd c9 1e			call macro_forth_dsp_next 
1f7b				endm 
# End of macro FORTH_DSP_NEXT
1f7b			 
1f7b 2a 7b fb			ld hl, (cli_data_sp) 
1f7e			 
1f7e				; save item type 
1f7e 3e 02			ld a,  DS_TYPE_INUM 
1f80 77				ld (hl), a 
1f81 23				inc hl 
1f82			 
1f82				; get word off stack 
1f82 d1				pop de 
1f83 7b				ld a,e 
1f84 77				ld (hl), a 
1f85 23				inc hl 
1f86 7a				ld a,d 
1f87 77				ld (hl), a 
1f88			 
1f88			if DEBUG_FORTH_PUSH 
1f88 2b				dec hl 
1f89 2b				dec hl 
1f8a 2b				dec hl 
1f8b						DMARK "PH5" 
1f8b f5				push af  
1f8c 3a a0 1f			ld a, (.dmark)  
1f8f 32 b4 fe			ld (debug_mark),a  
1f92 3a a1 1f			ld a, (.dmark+1)  
1f95 32 b5 fe			ld (debug_mark+1),a  
1f98 3a a2 1f			ld a, (.dmark+2)  
1f9b 32 b6 fe			ld (debug_mark+2),a  
1f9e 18 03			jr .pastdmark  
1fa0 ..			.dmark: db "PH5"  
1fa3 f1			.pastdmark: pop af  
1fa4			endm  
# End of macro DMARK
1fa4				CALLMONITOR 
1fa4 cd c6 18			call break_point_state  
1fa7				endm  
# End of macro CALLMONITOR
1fa7			endif	 
1fa7			 
1fa7 c9				ret 
1fa8			 
1fa8			 
1fa8			; Push a string to stack pointed to by hl 
1fa8			 
1fa8			forth_push_str: 
1fa8			 
1fa8			if DEBUG_FORTH_PUSH 
1fa8						DMARK "PSQ" 
1fa8 f5				push af  
1fa9 3a bd 1f			ld a, (.dmark)  
1fac 32 b4 fe			ld (debug_mark),a  
1faf 3a be 1f			ld a, (.dmark+1)  
1fb2 32 b5 fe			ld (debug_mark+1),a  
1fb5 3a bf 1f			ld a, (.dmark+2)  
1fb8 32 b6 fe			ld (debug_mark+2),a  
1fbb 18 03			jr .pastdmark  
1fbd ..			.dmark: db "PSQ"  
1fc0 f1			.pastdmark: pop af  
1fc1			endm  
# End of macro DMARK
1fc1				CALLMONITOR 
1fc1 cd c6 18			call break_point_state  
1fc4				endm  
# End of macro CALLMONITOR
1fc4			endif	 
1fc4			    
1fc4 e5				push hl 
1fc5 e5				push hl 
1fc6			 
1fc6			;	ld a, 0   ; find end of string 
1fc6 cd a7 13			call strlenz 
1fc9			if DEBUG_FORTH_PUSH 
1fc9						DMARK "PQ2" 
1fc9 f5				push af  
1fca 3a de 1f			ld a, (.dmark)  
1fcd 32 b4 fe			ld (debug_mark),a  
1fd0 3a df 1f			ld a, (.dmark+1)  
1fd3 32 b5 fe			ld (debug_mark+1),a  
1fd6 3a e0 1f			ld a, (.dmark+2)  
1fd9 32 b6 fe			ld (debug_mark+2),a  
1fdc 18 03			jr .pastdmark  
1fde ..			.dmark: db "PQ2"  
1fe1 f1			.pastdmark: pop af  
1fe2			endm  
# End of macro DMARK
1fe2				CALLMONITOR 
1fe2 cd c6 18			call break_point_state  
1fe5				endm  
# End of macro CALLMONITOR
1fe5			endif	 
1fe5 eb				ex de, hl 
1fe6 e1				pop hl   ; get ptr to start of string 
1fe7			if DEBUG_FORTH_PUSH 
1fe7						DMARK "PQ3" 
1fe7 f5				push af  
1fe8 3a fc 1f			ld a, (.dmark)  
1feb 32 b4 fe			ld (debug_mark),a  
1fee 3a fd 1f			ld a, (.dmark+1)  
1ff1 32 b5 fe			ld (debug_mark+1),a  
1ff4 3a fe 1f			ld a, (.dmark+2)  
1ff7 32 b6 fe			ld (debug_mark+2),a  
1ffa 18 03			jr .pastdmark  
1ffc ..			.dmark: db "PQ3"  
1fff f1			.pastdmark: pop af  
2000			endm  
# End of macro DMARK
2000				CALLMONITOR 
2000 cd c6 18			call break_point_state  
2003				endm  
# End of macro CALLMONITOR
2003			endif	 
2003 19				add hl,de 
2004			if DEBUG_FORTH_PUSH 
2004						DMARK "PQE" 
2004 f5				push af  
2005 3a 19 20			ld a, (.dmark)  
2008 32 b4 fe			ld (debug_mark),a  
200b 3a 1a 20			ld a, (.dmark+1)  
200e 32 b5 fe			ld (debug_mark+1),a  
2011 3a 1b 20			ld a, (.dmark+2)  
2014 32 b6 fe			ld (debug_mark+2),a  
2017 18 03			jr .pastdmark  
2019 ..			.dmark: db "PQE"  
201c f1			.pastdmark: pop af  
201d			endm  
# End of macro DMARK
201d				CALLMONITOR 
201d cd c6 18			call break_point_state  
2020				endm  
# End of macro CALLMONITOR
2020			endif	 
2020			 
2020 2b				dec hl    ; see if there is an optional trailing double quote 
2021 7e				ld a,(hl) 
2022 fe 22			cp '"' 
2024 20 03			jr nz, .strnoq 
2026 3e 00			ld a, 0      ; get rid of double quote 
2028 77				ld (hl), a 
2029 23			.strnoq: inc hl 
202a			 
202a 3e 00			ld a, 0 
202c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
202d			 
202d 13				inc de ; add one for the type string 
202e 13				inc de ; add one for null term??? 
202f			 
202f				; tos is get string pointer again 
202f				; de contains space to allocate 
202f				 
202f d5				push de 
2030			 
2030 eb				ex de, hl 
2031			 
2031				;push af 
2031			 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PHm" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 b4 fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 b5 fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 b6 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PHm"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd c6 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d cd 10 14			call malloc	; on ret hl now contains allocated memory 
2050				if DEBUG_FORTH_MALLOC_GUARD 
2050 cc 38 5a				call z,malloc_error 
2053				endif 
2053			 
2053				 
2053 c1				pop bc    ; get length 
2054 d1				pop de   ;  get string start    
2055			 
2055				; hl has destination from malloc 
2055			 
2055 eb				ex de, hl    ; prep for ldir 
2056			 
2056 d5				push de   ; save malloc area for DSP later 
2057				;push hl   ; save malloc area for DSP later 
2057			 
2057			if DEBUG_FORTH_PUSH 
2057						DMARK "PHc" 
2057 f5				push af  
2058 3a 6c 20			ld a, (.dmark)  
205b 32 b4 fe			ld (debug_mark),a  
205e 3a 6d 20			ld a, (.dmark+1)  
2061 32 b5 fe			ld (debug_mark+1),a  
2064 3a 6e 20			ld a, (.dmark+2)  
2067 32 b6 fe			ld (debug_mark+2),a  
206a 18 03			jr .pastdmark  
206c ..			.dmark: db "PHc"  
206f f1			.pastdmark: pop af  
2070			endm  
# End of macro DMARK
2070				CALLMONITOR 
2070 cd c6 18			call break_point_state  
2073				endm  
# End of macro CALLMONITOR
2073			endif	 
2073			 
2073			 
2073 ed b0			ldir 
2075			 
2075			 
2075				; push malloc to data stack     macro?????  
2075			 
2075				FORTH_DSP_NEXT 
2075 cd c9 1e			call macro_forth_dsp_next 
2078				endm 
# End of macro FORTH_DSP_NEXT
2078			 
2078				; save value and type 
2078			 
2078 2a 7b fb			ld hl, (cli_data_sp) 
207b			 
207b				; save item type 
207b 3e 01			ld a,  DS_TYPE_STR 
207d 77				ld (hl), a 
207e 23				inc hl 
207f			 
207f				; get malloc word off stack 
207f d1				pop de 
2080 73				ld (hl), e 
2081 23				inc hl 
2082 72				ld (hl), d 
2083			 
2083			 
2083			 
2083			if DEBUG_FORTH_PUSH 
2083 2a 7b fb			ld hl, (cli_data_sp) 
2086						DMARK "PHS" 
2086 f5				push af  
2087 3a 9b 20			ld a, (.dmark)  
208a 32 b4 fe			ld (debug_mark),a  
208d 3a 9c 20			ld a, (.dmark+1)  
2090 32 b5 fe			ld (debug_mark+1),a  
2093 3a 9d 20			ld a, (.dmark+2)  
2096 32 b6 fe			ld (debug_mark+2),a  
2099 18 03			jr .pastdmark  
209b ..			.dmark: db "PHS"  
209e f1			.pastdmark: pop af  
209f			endm  
# End of macro DMARK
209f				CALLMONITOR 
209f cd c6 18			call break_point_state  
20a2				endm  
# End of macro CALLMONITOR
20a2			;	ex de,hl 
20a2			endif	 
20a2				; in case of spaces, skip the ptr past the copied string 
20a2				;pop af 
20a2				;ld (cli_origptr),hl 
20a2			 
20a2 c9				ret 
20a3			 
20a3			 
20a3			 
20a3			; TODO ascii push input onto stack given hl to start of input 
20a3			 
20a3			; identify type 
20a3			; if starts with a " then a string 
20a3			; otherwise it is a number 
20a3			;  
20a3			; if a string 
20a3			;     scan for ending " to get length of string to malloc for + 1 
20a3			;     malloc 
20a3			;     put pointer to string on stack first byte flags as string 
20a3			; 
20a3			; else a number 
20a3			;    look for number format identifier 
20a3			;    $xx hex 
20a3			;    %xxxxx bin 
20a3			;    xxxxx decimal 
20a3			;    convert number to 16bit word.  
20a3			;    malloc word + 1 with flag to identiy as num 
20a3			;    put pointer to number on stack 
20a3			;   
20a3			;  
20a3			  
20a3			forth_apush: 
20a3				; kernel push 
20a3			 
20a3			if DEBUG_FORTH_PUSH 
20a3						DMARK "PSH" 
20a3 f5				push af  
20a4 3a b8 20			ld a, (.dmark)  
20a7 32 b4 fe			ld (debug_mark),a  
20aa 3a b9 20			ld a, (.dmark+1)  
20ad 32 b5 fe			ld (debug_mark+1),a  
20b0 3a ba 20			ld a, (.dmark+2)  
20b3 32 b6 fe			ld (debug_mark+2),a  
20b6 18 03			jr .pastdmark  
20b8 ..			.dmark: db "PSH"  
20bb f1			.pastdmark: pop af  
20bc			endm  
# End of macro DMARK
20bc				CALLMONITOR 
20bc cd c6 18			call break_point_state  
20bf				endm  
# End of macro CALLMONITOR
20bf			endif	 
20bf				; identify input type 
20bf			 
20bf 7e				ld a,(hl) 
20c0 fe 22			cp '"' 
20c2 28 0a			jr z, .fapstr 
20c4 fe 24			cp '$' 
20c6 ca ee 20			jp z, .faphex 
20c9 fe 25			cp '%' 
20cb ca d6 20			jp z, .fapbin 
20ce			;	cp 'b' 
20ce			;	jp z, .fabin 
20ce				; else decimal 
20ce			 
20ce				; TODO do decimal conversion 
20ce				; decimal is stored as a 16bit word 
20ce			 
20ce				; by default everything is a string if type is not detected 
20ce			.fapstr: ; 
20ce fe 22			cp '"' 
20d0 20 01			jr nz, .strnoqu 
20d2 23				inc hl 
20d3			.strnoqu: 
20d3 c3 a8 1f			jp forth_push_str 
20d6			 
20d6			 
20d6			 
20d6			.fapbin:    ; push a binary string.  
20d6 11 00 00			ld de, 0   ; hold a 16bit value 
20d9			 
20d9 23			.fapbinshift:	inc hl  
20da 7e				ld a,(hl) 
20db fe 00			cp 0     ; done scanning  
20dd 28 0b			jr z, .fapbdone  	; got it in HL so push  
20df			 
20df				; left shift de 
20df eb				ex de, hl	 
20e0 29				add hl, hl 
20e1			 
20e1				; is 1 
20e1 fe 31			cp '1' 
20e3 20 02			jr nz, .binzero 
20e5 cb 4d			bit 1, l 
20e7			.binzero: 
20e7 eb				ex de, hl	 ; save current de 
20e8 18 ef			jr .fapbinshift 
20ea			 
20ea			.fapbdone: 
20ea eb				ex de, hl 
20eb c3 3a 1f			jp forth_push_numhl 
20ee			 
20ee			 
20ee			.faphex:   ; hex is always stored as a 16bit word 
20ee				; skip number prefix 
20ee 23				inc hl 
20ef				; turn ascii into number 
20ef cd 00 13			call get_word_hl	; ret 16bit word in hl 
20f2			 
20f2 c3 3a 1f			jp forth_push_numhl 
20f5			 
20f5 00				 nop 
20f6			 
20f6			.fabin:   ; TODO bin conversion 
20f6			 
20f6			 
20f6 c9				ret 
20f7			 
20f7			 
20f7			; get either a string ptr or a 16bit word from the data stack 
20f7			 
20f7			FORTH_DSP: macro 
20f7				call macro_forth_dsp 
20f7				endm 
20f7			 
20f7			macro_forth_dsp: 
20f7				; data stack pointer points to current word on tos 
20f7			 
20f7 2a 7b fb			ld hl,(cli_data_sp) 
20fa			 
20fa				if DEBUG_FORTH_PUSH 
20fa						DMARK "DSP" 
20fa f5				push af  
20fb 3a 0f 21			ld a, (.dmark)  
20fe 32 b4 fe			ld (debug_mark),a  
2101 3a 10 21			ld a, (.dmark+1)  
2104 32 b5 fe			ld (debug_mark+1),a  
2107 3a 11 21			ld a, (.dmark+2)  
210a 32 b6 fe			ld (debug_mark+2),a  
210d 18 03			jr .pastdmark  
210f ..			.dmark: db "DSP"  
2112 f1			.pastdmark: pop af  
2113			endm  
# End of macro DMARK
2113			 
2113 cd 6d 5a				call display_data_sp 
2116				;call break_point_state 
2116				;rst 030h 
2116				CALLMONITOR 
2116 cd c6 18			call break_point_state  
2119				endm  
# End of macro CALLMONITOR
2119				endif 
2119			 
2119 c9				ret 
211a			 
211a			; return hl to start of value on stack 
211a			 
211a			FORTH_DSP_VALUE: macro 
211a				call macro_forth_dsp_value 
211a				endm 
211a			 
211a			macro_forth_dsp_value: 
211a			 
211a				FORTH_DSP 
211a cd f7 20			call macro_forth_dsp 
211d				endm 
# End of macro FORTH_DSP
211d			 
211d d5				push de 
211e			 
211e 23				inc hl ; skip type 
211f			 
211f 5e				ld e, (hl) 
2120 23				inc hl 
2121 56				ld d, (hl) 
2122 eb				ex de,hl  
2123			 
2123 d1				pop de 
2124			 
2124 c9				ret 
2125			 
2125			; return hl to start of value to second item on stack 
2125			 
2125			FORTH_DSP_VALUEM1: macro 
2125				call macro_forth_dsp_value_m1 
2125				endm 
2125			 
2125			macro_forth_dsp_value_m1: 
2125			 
2125				FORTH_DSP 
2125 cd f7 20			call macro_forth_dsp 
2128				endm 
# End of macro FORTH_DSP
2128			 
2128 2b				dec hl 
2129 2b				dec hl 
212a			;	dec hl 
212a			 
212a d5				push de 
212b			 
212b 5e				ld e, (hl) 
212c 23				inc hl 
212d 56				ld d, (hl) 
212e eb				ex de,hl  
212f			 
212f d1				pop de 
2130			 
2130 c9				ret 
2131			 
2131				 
2131			 
2131			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2131			 
2131			FORTH_DSP_POP: macro 
2131				call macro_forth_dsp_pop 
2131				endm 
2131			 
2131			 
2131			; get the tos data type 
2131			 
2131			FORTH_DSP_TYPE:   macro 
2131			 
2131				;FORTH_DSP_VALUE 
2131				FORTH_DSP 
2131				 
2131				; hl points to value 
2131				; check type 
2131			 
2131				ld a,(hl) 
2131			 
2131				endm 
2131			 
2131			; load the tos value into hl 
2131			 
2131			 
2131			FORTH_DSP_VALUEHL:  macro 
2131				call macro_dsp_valuehl 
2131				endm 
2131			 
2131			 
2131			 
2131			macro_dsp_valuehl: 
2131				FORTH_DSP_VALUE 
2131 cd 1a 21			call macro_forth_dsp_value 
2134				endm 
# End of macro FORTH_DSP_VALUE
2134			 
2134				;FORTH_ERR_TOS_NOTNUM 
2134			 
2134				;inc hl   ; skip type id 
2134			 
2134			;	push de 
2134			; 
2134			;	ld e, (hl) 
2134			;	inc hl 
2134			;	ld d, (hl) 
2134			;	ex de,hl  
2134			 
2134			;	pop de 
2134			 
2134				if DEBUG_FORTH_PUSH 
2134						DMARK "DVL" 
2134 f5				push af  
2135 3a 49 21			ld a, (.dmark)  
2138 32 b4 fe			ld (debug_mark),a  
213b 3a 4a 21			ld a, (.dmark+1)  
213e 32 b5 fe			ld (debug_mark+1),a  
2141 3a 4b 21			ld a, (.dmark+2)  
2144 32 b6 fe			ld (debug_mark+2),a  
2147 18 03			jr .pastdmark  
2149 ..			.dmark: db "DVL"  
214c f1			.pastdmark: pop af  
214d			endm  
# End of macro DMARK
214d				CALLMONITOR 
214d cd c6 18			call break_point_state  
2150				endm  
# End of macro CALLMONITOR
2150				endif 
2150 c9				ret 
2151			 
2151			forth_apushstrhl:      
2151				; push of string requires use of cli_origptr 
2151				; bodge use 
2151			 
2151				; get current cli_origptr, save, update with temp pointer  
2151 ed 5b cb fb		ld de, (cli_origptr) 
2155 22 cb fb			ld (cli_origptr), hl 
2158 d5				push de 
2159 cd a3 20			call forth_apush 
215c d1				pop de 
215d ed 53 cb fb		ld (cli_origptr), de 
2161 c9			        ret	 
2162			 
2162			 
2162			; increase loop stack pointer and save hl to it 
2162				 
2162			FORTH_LOOP_NEXT: macro 
2162				call macro_forth_loop_next 
2162				;nop 
2162				endm 
2162			 
2162			macro_forth_loop_next: 
2162				if DEBUG_FORTH_STACK_GUARD 
2162 cd 44 6e				call check_stacks 
2165				endif 
2165 e5				push hl 
2166 d5				push de 
2167 eb				ex de,hl 
2168 2a 7d fb			ld hl,(cli_loop_sp) 
216b 23				inc hl 
216c 23				inc hl 
216d					if DEBUG_FORTH_WORDS 
216d						DMARK "LNX" 
216d f5				push af  
216e 3a 82 21			ld a, (.dmark)  
2171 32 b4 fe			ld (debug_mark),a  
2174 3a 83 21			ld a, (.dmark+1)  
2177 32 b5 fe			ld (debug_mark+1),a  
217a 3a 84 21			ld a, (.dmark+2)  
217d 32 b6 fe			ld (debug_mark+2),a  
2180 18 03			jr .pastdmark  
2182 ..			.dmark: db "LNX"  
2185 f1			.pastdmark: pop af  
2186			endm  
# End of macro DMARK
2186						CALLMONITOR 
2186 cd c6 18			call break_point_state  
2189				endm  
# End of macro CALLMONITOR
2189					endif 
2189 22 7d fb			ld (cli_loop_sp),hl 
218c 73				ld (hl), e 
218d 23				inc hl 
218e 72				ld (hl), d 
218f d1				pop de    ; been reversed so save a swap on restore 
2190 e1				pop hl 
2191				if DEBUG_FORTH_STACK_GUARD 
2191 cd 44 6e				call check_stacks 
2194				endif 
2194 c9				ret 
2195			 
2195			; get current ret stack pointer and save to hl  
2195				 
2195			FORTH_LOOP_TOS: macro 
2195				call macro_forth_loop_tos 
2195				endm 
2195			 
2195			macro_forth_loop_tos: 
2195 d5				push de 
2196 2a 7d fb			ld hl,(cli_loop_sp) 
2199 5e				ld e, (hl) 
219a 23				inc hl 
219b 56				ld d, (hl) 
219c eb				ex de, hl 
219d d1				pop de 
219e c9				ret 
219f			 
219f			; pop loop stack pointer 
219f				 
219f			FORTH_LOOP_POP: macro 
219f				call macro_forth_loop_pop 
219f				endm 
219f			 
219f			 
219f			macro_forth_loop_pop: 
219f				if DEBUG_FORTH_STACK_GUARD 
219f					DMARK "LPP" 
219f f5				push af  
21a0 3a b4 21			ld a, (.dmark)  
21a3 32 b4 fe			ld (debug_mark),a  
21a6 3a b5 21			ld a, (.dmark+1)  
21a9 32 b5 fe			ld (debug_mark+1),a  
21ac 3a b6 21			ld a, (.dmark+2)  
21af 32 b6 fe			ld (debug_mark+2),a  
21b2 18 03			jr .pastdmark  
21b4 ..			.dmark: db "LPP"  
21b7 f1			.pastdmark: pop af  
21b8			endm  
# End of macro DMARK
21b8 cd 44 6e				call check_stacks 
21bb					FORTH_CHK_LOOP_UNDER 
21bb e5				push hl 
21bc d5				push de 
21bd 2a 7d fb			ld hl,(cli_loop_sp) 
21c0 11 b7 fa			ld de, cli_loop_stack 
21c3 cd 67 0f			call cmp16 
21c6 da 5e 6f			jp c, fault_loop_under 
21c9 d1				pop de 
21ca e1				pop hl 
21cb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21cb				endif 
21cb e5				push hl 
21cc 2a 7d fb			ld hl,(cli_loop_sp) 
21cf 2b				dec hl 
21d0 2b				dec hl 
21d1 22 7d fb			ld (cli_loop_sp), hl 
21d4				; TODO do stack underflow checks 
21d4 e1				pop hl 
21d5				if DEBUG_FORTH_STACK_GUARD 
21d5 cd 44 6e				call check_stacks 
21d8					FORTH_CHK_LOOP_UNDER 
21d8 e5				push hl 
21d9 d5				push de 
21da 2a 7d fb			ld hl,(cli_loop_sp) 
21dd 11 b7 fa			ld de, cli_loop_stack 
21e0 cd 67 0f			call cmp16 
21e3 da 5e 6f			jp c, fault_loop_under 
21e6 d1				pop de 
21e7 e1				pop hl 
21e8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21e8				endif 
21e8 c9				ret 
21e9			 
21e9			macro_forth_dsp_pop: 
21e9			 
21e9 e5				push hl 
21ea			 
21ea				; release malloc data 
21ea			 
21ea				if DEBUG_FORTH_STACK_GUARD 
21ea cd 44 6e				call check_stacks 
21ed					FORTH_CHK_DSP_UNDER 
21ed e5				push hl 
21ee d5				push de 
21ef 2a 7b fb			ld hl,(cli_data_sp) 
21f2 11 b5 f8			ld de, cli_data_stack 
21f5 cd 67 0f			call cmp16 
21f8 da 52 6f			jp c, fault_dsp_under 
21fb d1				pop de 
21fc e1				pop hl 
21fd				endm 
# End of macro FORTH_CHK_DSP_UNDER
21fd				endif 
21fd				;ld hl,(cli_data_sp) 
21fd			if DEBUG_FORTH_DOT 
21fd				DMARK "DPP" 
21fd f5				push af  
21fe 3a 12 22			ld a, (.dmark)  
2201 32 b4 fe			ld (debug_mark),a  
2204 3a 13 22			ld a, (.dmark+1)  
2207 32 b5 fe			ld (debug_mark+1),a  
220a 3a 14 22			ld a, (.dmark+2)  
220d 32 b6 fe			ld (debug_mark+2),a  
2210 18 03			jr .pastdmark  
2212 ..			.dmark: db "DPP"  
2215 f1			.pastdmark: pop af  
2216			endm  
# End of macro DMARK
2216				CALLMONITOR 
2216 cd c6 18			call break_point_state  
2219				endm  
# End of macro CALLMONITOR
2219			endif	 
2219			 
2219			 
2219			if FORTH_ENABLE_DSPPOPFREE 
2219			 
2219				FORTH_DSP 
2219 cd f7 20			call macro_forth_dsp 
221c				endm 
# End of macro FORTH_DSP
221c			 
221c 7e				ld a, (hl) 
221d fe 01			cp DS_TYPE_STR 
221f 20 23			jr nz, .skippopfree 
2221			 
2221				FORTH_DSP_VALUEHL 
2221 cd 31 21			call macro_dsp_valuehl 
2224				endm 
# End of macro FORTH_DSP_VALUEHL
2224 00				nop 
2225			if DEBUG_FORTH_DOT 
2225				DMARK "DPf" 
2225 f5				push af  
2226 3a 3a 22			ld a, (.dmark)  
2229 32 b4 fe			ld (debug_mark),a  
222c 3a 3b 22			ld a, (.dmark+1)  
222f 32 b5 fe			ld (debug_mark+1),a  
2232 3a 3c 22			ld a, (.dmark+2)  
2235 32 b6 fe			ld (debug_mark+2),a  
2238 18 03			jr .pastdmark  
223a ..			.dmark: db "DPf"  
223d f1			.pastdmark: pop af  
223e			endm  
# End of macro DMARK
223e				CALLMONITOR 
223e cd c6 18			call break_point_state  
2241				endm  
# End of macro CALLMONITOR
2241			endif	 
2241 cd da 14			call free 
2244			.skippopfree: 
2244				 
2244			 
2244			endif 
2244			 
2244			if DEBUG_FORTH_DOT_KEY 
2244				DMARK "DP2" 
2244				CALLMONITOR 
2244			endif	 
2244			 
2244				; move pointer down 
2244			 
2244 2a 7b fb			ld hl,(cli_data_sp) 
2247 2b				dec hl 
2248 2b				dec hl 
2249			; PARSEV5 
2249 2b				dec hl 
224a 22 7b fb			ld (cli_data_sp), hl 
224d			 
224d				if DEBUG_FORTH_STACK_GUARD 
224d cd 44 6e				call check_stacks 
2250					FORTH_CHK_DSP_UNDER 
2250 e5				push hl 
2251 d5				push de 
2252 2a 7b fb			ld hl,(cli_data_sp) 
2255 11 b5 f8			ld de, cli_data_stack 
2258 cd 67 0f			call cmp16 
225b da 52 6f			jp c, fault_dsp_under 
225e d1				pop de 
225f e1				pop hl 
2260				endm 
# End of macro FORTH_CHK_DSP_UNDER
2260				endif 
2260			 
2260 e1				pop hl 
2261			 
2261 c9				ret 
2262			 
2262			getwordathl: 
2262				; hl points to an address 
2262				; load hl with the word at that address 
2262			 
2262 d5				push de 
2263			 
2263 5e				ld e, (hl) 
2264 23				inc hl 
2265 56				ld d, (hl) 
2266 eb				ex de, hl 
2267			 
2267 d1				pop de 
2268 c9				ret 
2269			 
2269			 
2269			 
2269			 
2269			 
2269			; eof 
2269			 
# End of file forth_stackopsv5.asm
2269			endif 
2269			 
2269			loadwordinhl:	 
2269			 
2269 d5				push de 
226a			 
226a 5e				ld e, (hl) 
226b 23				inc hl 
226c 56				ld d, (hl) 
226d eb				ex de,hl  
226e			 
226e d1				pop de 
226f			 
226f c9				ret 
2270			 
2270			user_word_eol:  
2270				; hl contains the pointer to where to create a linked list item from the end 
2270				; of the user dict to continue on at the system word dict 
2270				 
2270				; poke the stub of the word list linked list to repoint to rom words 
2270			 
2270				; stub format 
2270				; db   word id 
2270				; dw    link to next word 
2270			        ; db char length of token 
2270				; db string + 0 term 
2270				; db exec code....  
2270			 
2270 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2272 77				ld (hl), a		; word id 
2273 23				inc hl 
2274			 
2274 11 3f 24			ld de, sysdict 
2277 73				ld (hl), e		; next word link ie system dict 
2278 23				inc hl 
2279 72				ld (hl), d		; next word link ie system dict 
227a 23				inc hl	 
227b			 
227b			;	ld (hl), sysdict		; next word link ie system dict 
227b			;	inc hl 
227b			;	inc hl 
227b			 
227b			;	inc hl 
227b			;	inc hl 
227b			 
227b 3e 02			ld a, 2			; word length is 0 
227d 77				ld (hl), a	 
227e 23				inc hl 
227f			 
227f 3e 7e			ld a, '~'			; word length is 0 
2281 77				ld (hl), a	 
2282 23				inc hl 
2283 3e 00			ld a, 0			; save empty word 
2285 77				ld (hl), a 
2286			 
2286 c9				ret 
2287			 
2287				 
2287			 
2287			forthexec_cleanup: 
2287				FORTH_RSP_POP 
2287 cd 02 1f			call macro_forth_rsp_pop 
228a				endm 
# End of macro FORTH_RSP_POP
228a c9				ret 
228b			 
228b			forth_call_hl: 
228b				; taking hl 
228b e5				push hl 
228c c9				ret 
228d			 
228d			; this is called to reset Forth system but keep existing uwords etc 
228d			 
228d			forth_warmstart: 
228d				; setup stack over/under flow checks 
228d				if DEBUG_FORTH_STACK_GUARD 
228d cd 2a 6e				call chk_stk_init 
2290				endif 
2290			 
2290				; init stack pointers  - * these stacks go upwards *  
2290 21 39 fb			ld hl, cli_ret_stack 
2293 22 7f fb			ld (cli_ret_sp), hl	 
2296				; set bottom of stack 
2296 3e 00			ld a,0 
2298 77				ld (hl),a 
2299 23				inc hl 
229a 77				ld (hl),a 
229b			 
229b 21 b5 f8			ld hl, cli_data_stack 
229e 22 7b fb			ld (cli_data_sp), hl	 
22a1				; set bottom of stack 
22a1 3e 00			ld a,0 
22a3 77				ld (hl),a 
22a4 23				inc hl 
22a5 77				ld (hl),a 
22a6			 
22a6 21 b7 fa			ld hl, cli_loop_stack 
22a9 22 7d fb			ld (cli_loop_sp), hl	 
22ac				; set bottom of stack 
22ac 3e 00			ld a,0 
22ae 77				ld (hl),a 
22af 23				inc hl 
22b0 77				ld (hl),a 
22b1			 
22b1				; init extent of current open file 
22b1			 
22b1 3e 00			ld a, 0 
22b3 32 f7 fb			ld (store_openext), a 
22b6			 
22b6 c9				ret 
22b7			 
22b7			 
22b7			; Cold Start - this is called to setup the whole Forth system 
22b7			 
22b7			forth_init: 
22b7			 
22b7				; setup stack over/under flow checks 
22b7			 
22b7			;	if DEBUG_FORTH_STACK_GUARD 
22b7			;		call chk_stk_init 
22b7			;	endif 
22b7			 
22b7				; enable auto display updates (slow.....) 
22b7			 
22b7 3e 01			ld a, 1 
22b9 32 c9 fb			ld (cli_autodisplay), a 
22bc			 
22bc				; if storage is in use disable long reads for now 
22bc 3e 00			ld a, 0 
22be 32 02 fc			ld (store_longread), a 
22c1			 
22c1			 
22c1				; show start up screen 
22c1			 
22c1 cd 15 0d			call clear_display 
22c4			 
22c4 3e 00			ld a,0 
22c6 32 eb fb			ld (f_cursor_ptr), a 
22c9			 
22c9				; set start of word list in start of ram - for use when creating user words 
22c9			 
22c9 21 00 80			ld hl, baseram 
22cc 22 4b f6			ld (os_last_new_uword), hl 
22cf cd 70 22			call user_word_eol 
22d2				 
22d2			;		call display_data_sp 
22d2			;		call next_page_prompt 
22d2			 
22d2			 
22d2			 
22d2			 
22d2 c9				ret 
22d3			 
22d3 .. 00		.bootforth: db " Forth Kernel Init ",0 
22e7			 
22e7			; TODO push to stack 
22e7			 
22e7			;  
22e7			 
22e7			if FORTH_PARSEV2 
22e7			 
22e7			 
22e7				include "forth_parserv2.asm" 
22e7			 
22e7			endif 
22e7			 
22e7			 
22e7			; parse cli version 1 
22e7			 
22e7			if FORTH_PARSEV1 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv1.asm" 
22e7			endif 
22e7				 
22e7			if FORTH_PARSEV3 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv3.asm" 
22e7				include "forth_wordsv3.asm" 
22e7			endif 
22e7			 
22e7			if FORTH_PARSEV4 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv4.asm" 
22e7				include "forth_wordsv4.asm" 
22e7			endif 
22e7			 
22e7			if FORTH_PARSEV5 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv5.asm" 
22e7			 
22e7			 
22e7			; A better parser without using malloc and string copies all over the place.  
22e7			; Exec in situ should be faster 
22e7			 
22e7			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
22e7			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
22e7			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
22e7			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
22e7			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
22e7			WORD_SYS_END: equ 0   ; Opcode for all user words 
22e7			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
22e7			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
22e7			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
22e7			 
22e7			; Core word preamble macro 
22e7			 
22e7			CWHEAD:   macro nxtword opcode lit len opflags 
22e7				db WORD_SYS_CORE+opcode             
22e7				; internal op code number 
22e7				dw nxtword            
22e7				; link to next dict word block 
22e7				db len + 1 
22e7				; literal length of dict word inc zero term 
22e7				db lit,0              
22e7				; literal dict word 
22e7			        ; TODO db opflags        
22e7				endm 
22e7			 
22e7			 
22e7			NEXTW: macro  
22e7				jp macro_next 
22e7				endm 
22e7			 
22e7			macro_next: 
22e7			if DEBUG_FORTH_PARSE_KEY 
22e7				DMARK "NXT" 
22e7				CALLMONITOR 
22e7			endif	 
22e7			;	inc hl  ; skip token null term  
22e7 ed 4b cd fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22eb ed 5b cb fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22ef 2a 4f f6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22f2			if DEBUG_FORTH_PARSE_KEY 
22f2				DMARK "}AA" 
22f2				CALLMONITOR 
22f2			endif	 
22f2 c3 f5 23			jp execnext 
22f5				;jp exec1 
22f5			       
22f5			 
22f5			 
22f5			; Another go at the parser to compile  
22f5			 
22f5			 
22f5			; TODO rework parser to change all of the string words to byte tokens 
22f5			; TODO do a search for  
22f5			 
22f5			; TODO first run normal parser to zero term sections 
22f5			; TODO for each word do a token look up to get the op code 
22f5			; TODO need some means to flag to the exec that this is a byte code form    
22f5			 
22f5			 
22f5			forthcompile: 
22f5			 
22f5			; 
22f5			; line parse: 
22f5			;       parse raw input buffer 
22f5			;       tokenise the words 
22f5			;       malloc new copy (for looping etc) 
22f5			;       copy to malloc + current pc in line to start of string and add line term 
22f5			;       save on new rsp 
22f5			; 
22f5			 
22f5			; hl to point to the line to tokenise 
22f5			 
22f5			;	push hl 
22f5 22 4f f6			ld (os_tok_ptr), hl  ; save ptr to string 
22f8			 
22f8			;	ld a,0		; string term on input 
22f8			;	call strlent 
22f8			 
22f8			;	ld (os_tok_len), hl	 ; save string length 
22f8			 
22f8			;if DEBUG_FORTH_TOK 
22f8			;	ex de,hl		 
22f8			;endif 
22f8			 
22f8			;	pop hl 		; get back string pointer 
22f8			 
22f8			if DEBUG_FORTH_TOK 
22f8						DMARK "TOc" 
22f8				CALLMONITOR 
22f8			endif 
22f8 7e			.cptoken2:    ld a,(hl) 
22f9 23				inc hl 
22fa fe 7f			cp FORTH_END_BUFFER 
22fc 28 29			jr z, .cptokendone2 
22fe fe 00			cp 0 
2300 28 25			jr z, .cptokendone2 
2302 fe 22			cp '"' 
2304 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2306 fe 20			cp ' ' 
2308 20 ee			jr nz,  .cptoken2 
230a			 
230a			; TODO consume comments held between ( and ) 
230a			 
230a				; we have a space so change to zero term for dict match later 
230a 2b				dec hl 
230b 3e 00			ld a,0 
230d 77				ld (hl), a 
230e 23				inc hl 
230f 18 e7			jr .cptoken2 
2311				 
2311			 
2311			.cptokenstr2: 
2311				; skip all white space until either eol (because forgot to term) or end double quote 
2311			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2311				;inc hl ; skip current double quote 
2311 7e				ld a,(hl) 
2312 23				inc hl 
2313 fe 22			cp '"' 
2315 28 e1			jr z, .cptoken2 
2317 fe 7f			cp FORTH_END_BUFFER 
2319 28 0c			jr z, .cptokendone2 
231b fe 00			cp 0 
231d 28 08			jr z, .cptokendone2 
231f fe 20			cp ' ' 
2321 28 02			jr z, .cptmp2 
2323 18 ec			jr .cptokenstr2 
2325			 
2325			.cptmp2:	; we have a space so change to zero term for dict match later 
2325				;dec hl 
2325				;ld a,"-"	; TODO remove this when working 
2325				;ld (hl), a 
2325				;inc hl 
2325 18 ea			jr .cptokenstr2 
2327			 
2327			.cptokendone2: 
2327				;inc hl 
2327 3e 7f			ld a, FORTH_END_BUFFER 
2329 77				ld (hl),a 
232a 23				inc hl 
232b 3e 21			ld a, '!' 
232d 77				ld (hl),a 
232e			 
232e 2a 4f f6			ld hl,(os_tok_ptr) 
2331			         
2331			if DEBUG_FORTH_TOK 
2331						DMARK "Tc1" 
2331				CALLMONITOR 
2331			endif 
2331			 
2331				; push exec string to top of return stack 
2331				FORTH_RSP_NEXT 
2331 cd e1 1e			call macro_forth_rsp_next 
2334				endm 
# End of macro FORTH_RSP_NEXT
2334 c9				ret 
2335			 
2335			; Another go at the parser need to simplify the process 
2335			 
2335			forthparse: 
2335			 
2335			; 
2335			; line parse: 
2335			;       parse raw input buffer 
2335			;       tokenise the words 
2335			;       malloc new copy (for looping etc) 
2335			;       copy to malloc + current pc in line to start of string and add line term 
2335			;       save on new rsp 
2335			; 
2335			 
2335			; hl to point to the line to tokenise 
2335			 
2335			;	push hl 
2335 22 4f f6			ld (os_tok_ptr), hl  ; save ptr to string 
2338			 
2338			;	ld a,0		; string term on input 
2338			;	call strlent 
2338			 
2338			;	ld (os_tok_len), hl	 ; save string length 
2338			 
2338			;if DEBUG_FORTH_TOK 
2338			;	ex de,hl		 
2338			;endif 
2338			 
2338			;	pop hl 		; get back string pointer 
2338			 
2338			if DEBUG_FORTH_TOK 
2338						DMARK "TOK" 
2338				CALLMONITOR 
2338			endif 
2338 7e			.ptoken2:    ld a,(hl) 
2339 23				inc hl 
233a fe 7f			cp FORTH_END_BUFFER 
233c 28 29			jr z, .ptokendone2 
233e fe 00			cp 0 
2340 28 25			jr z, .ptokendone2 
2342 fe 22			cp '"' 
2344 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2346 fe 20			cp ' ' 
2348 20 ee			jr nz,  .ptoken2 
234a			 
234a			; TODO consume comments held between ( and ) 
234a			 
234a				; we have a space so change to zero term for dict match later 
234a 2b				dec hl 
234b 3e 00			ld a,0 
234d 77				ld (hl), a 
234e 23				inc hl 
234f 18 e7			jr .ptoken2 
2351				 
2351			 
2351			.ptokenstr2: 
2351				; skip all white space until either eol (because forgot to term) or end double quote 
2351			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2351				;inc hl ; skip current double quote 
2351 7e				ld a,(hl) 
2352 23				inc hl 
2353 fe 22			cp '"' 
2355 28 e1			jr z, .ptoken2 
2357 fe 7f			cp FORTH_END_BUFFER 
2359 28 0c			jr z, .ptokendone2 
235b fe 00			cp 0 
235d 28 08			jr z, .ptokendone2 
235f fe 20			cp ' ' 
2361 28 02			jr z, .ptmp2 
2363 18 ec			jr .ptokenstr2 
2365			 
2365			.ptmp2:	; we have a space so change to zero term for dict match later 
2365				;dec hl 
2365				;ld a,"-"	; TODO remove this when working 
2365				;ld (hl), a 
2365				;inc hl 
2365 18 ea			jr .ptokenstr2 
2367			 
2367			.ptokendone2: 
2367				;inc hl 
2367 3e 7f			ld a, FORTH_END_BUFFER 
2369 77				ld (hl),a 
236a 23				inc hl 
236b 3e 21			ld a, '!' 
236d 77				ld (hl),a 
236e			 
236e 2a 4f f6			ld hl,(os_tok_ptr) 
2371			         
2371			if DEBUG_FORTH_TOK 
2371						DMARK "TK1" 
2371				CALLMONITOR 
2371			endif 
2371			 
2371				; push exec string to top of return stack 
2371				FORTH_RSP_NEXT 
2371 cd e1 1e			call macro_forth_rsp_next 
2374				endm 
# End of macro FORTH_RSP_NEXT
2374 c9				ret 
2375			 
2375			; 
2375			;	; malloc size + buffer pointer + if is loop flag 
2375			;	ld hl,(os_tok_len) 		 ; get string length 
2375			; 
2375			;	ld a,l 
2375			; 
2375			;	cp 0			; we dont want to use a null string 
2375			;	ret z 
2375			; 
2375			;;	add 3    ; prefix malloc with buffer for current word ptr 
2375			; 
2375			;	add 5     ; TODO when certain not over writing memory remove 
2375			; 
2375			;		 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKE" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	ld l,a 
2375			;	ld h,0 
2375			;;	push hl   ; save required space for the copy later 
2375			;	call malloc 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKM" 
2375			;	CALLMONITOR 
2375			;endif 
2375			;	if DEBUG_FORTH_MALLOC_GUARD 
2375			;		push af 
2375			;		call ishlzero 
2375			;;		ld a, l 
2375			;;		add h 
2375			;;		cp 0 
2375			;		pop af 
2375			;		 
2375			;		call z,malloc_error 
2375			;	endif 
2375			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2375			; 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKR" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	FORTH_RSP_NEXT 
2375			; 
2375			;	;inc hl	 ; go past current buffer pointer 
2375			;	;inc hl 
2375			;	;inc hl   ; and past if loop flag 
2375			;		; TODO Need to set flag  
2375			; 
2375			;	 
2375			;	 
2375			;	ex de,hl	; malloc is dest 
2375			;	ld hl, (os_tok_len) 
2375			;;	pop bc 
2375			;	ld c, l                
2375			;	ld b,0 
2375			;	ld hl, (os_tok_ptr) 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKT" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	; do str cpy 
2375			; 
2375			;	ldir      ; copy byte in hl to de 
2375			; 
2375			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			; 
2375			;			DMARK "TKY" 
2375			;	CALLMONITOR 
2375			;endif 
2375			;	;ld a,0 
2375			;	;ld a,FORTH_END_BUFFER 
2375			;	ex de, hl 
2375			;	;dec hl			 ; go back over the space delim at the end of word 
2375			;	;ld (hl),a 
2375			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2375			;	ld a,FORTH_END_BUFFER 
2375			;	ld (hl),a 
2375			;	inc hl 
2375			;	ld a,FORTH_END_BUFFER 
2375			;	ld (hl),a 
2375			; 
2375			;	; init the malloc area data 
2375			;	; set pc for in current area 
2375			;	;ld hl, (os_tok_malloc) 
2375			;	;inc hl 
2375			;	;inc hl 
2375			;	;inc hl 
2375			;	;ex de,hl 
2375			;	;ld hl, (os_tok_malloc) 
2375			;	;ld (hl),e 
2375			;	;inc hl 
2375			;	;ld (hl),d 
2375			; 
2375			; 
2375			;	ld hl,(os_tok_malloc) 
2375			;if DEBUG_FORTH_PARSE_KEY 
2375			;			DMARK "TKU" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	ret 
2375			 
2375			forthexec: 
2375			 
2375			; line exec: 
2375			; forth parser 
2375			 
2375			; 
2375			;       get current exec line on rsp 
2375			 
2375				FORTH_RSP_TOS 
2375 cd f8 1e			call macro_forth_rsp_tos 
2378				endm 
# End of macro FORTH_RSP_TOS
2378			 
2378			;       restore current pc - hl points to malloc of data 
2378			 
2378				;ld e, (hl) 
2378				;inc hl 
2378				;ld d, (hl) 
2378				;ex de,hl 
2378			 
2378			 
2378			exec1: 
2378 22 4f f6			ld (os_tok_ptr), hl 
237b			 
237b				; copy our PC to working vars  
237b 22 cd fb			ld (cli_ptr), hl 
237e 22 cb fb			ld (cli_origptr), hl 
2381			 
2381 7e				ld a,(hl) 
2382 fe 7f			cp FORTH_END_BUFFER 
2384 c8				ret z 
2385			 
2385				; skip any nulls 
2385			 
2385 fe 00			cp 0 
2387 20 03			jr nz, .execword 
2389 23				inc hl 
238a 18 ec			jr exec1 
238c			 
238c			 
238c			.execword: 
238c			 
238c			 
238c			 
238c			if DEBUG_FORTH_PARSE_KEY 
238c						DMARK "KYQ" 
238c				CALLMONITOR 
238c			endif 
238c			;       while at start of word: 
238c			; get start of dict (in user area first) 
238c			 
238c 21 00 80		ld hl, baseram 
238f			;ld hl, sysdict 
238f 22 cf fb		ld (cli_nextword),hl 
2392			;           match word at pc 
2392			;           exec word 
2392			;           or push to dsp 
2392			;           forward to next token 
2392			;           if line term pop rsp and exit 
2392			;        
2392			 
2392			if DEBUG_FORTH_PARSE_KEY 
2392						DMARK "KYq" 
2392				CALLMONITOR 
2392			endif 
2392			 
2392			; 
2392			; word comp 
2392			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2392			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2392			;    move to start of word  
2392			;    compare word to cli_token 
2392			 
2392			.execpnword:	; HL at start of a word in the dictionary to check 
2392			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2392			;	ld (cli_ptr), hl 
2392			 
2392 2a cf fb			ld hl,(cli_nextword) 
2395			 
2395 cd 38 24			call forth_tok_next 
2398			; tok next start here 
2398			;	; TODO skip compiled symbol for now 
2398			;	inc hl 
2398			; 
2398			;	; save pointer to next word 
2398			; 
2398			;	; hl now points to the address of the next word pointer  
2398			;	ld e, (hl) 
2398			;	inc hl 
2398			;	ld d, (hl) 
2398			;	inc l 
2398			; 
2398			;	ex de,hl 
2398			;if DEBUG_FORTH_PARSE_NEXTWORD 
2398			;	push bc 
2398			;	ld bc, (cli_nextword) 
2398			;			DMARK "NXW" 
2398			;	CALLMONITOR 
2398			;	pop bc 
2398			;endif 
2398			; tok next end here 
2398 22 cf fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
239b eb				ex de, hl 
239c			 
239c			 
239c				; save the pointer of the current token - 1 to check against 
239c				 
239c 22 d3 fb			ld (cli_token), hl   
239f				; TODO maybe remove below save if no debug 
239f				; save token string ptr for any debug later 
239f 23				inc hl  
23a0 22 d5 fb			ld (cli_origtoken), hl 
23a3 2b				dec hl 
23a4				; save pointer to the start of the next dictionay word 
23a4 7e				ld a,(hl)   ; get string length 
23a5 47				ld b,a 
23a6			.execpnwordinc:  
23a6 23				inc hl 
23a7 10 fd			djnz .execpnwordinc 
23a9 22 d1 fb			ld (cli_execword), hl      ; save start of this words code 
23ac			 
23ac				; now check the word token against the string being parsed 
23ac			 
23ac 2a d3 fb			ld hl,(cli_token) 
23af 23				inc hl     ; skip string length (use zero term instead to end) 
23b0 22 d3 fb			ld (cli_token), hl 
23b3			 
23b3			if DEBUG_FORTH_PARSE_KEY 
23b3						DMARK "KY2" 
23b3			endif 
23b3			if DEBUG_FORTH_PARSE_EXEC 
23b3				; see if disabled 
23b3			 
23b3				ld a, (os_view_disable) 
23b3				cp '*' 
23b3				jr z, .skip 
23b3			 
23b3				push hl 
23b3				push hl 
23b3				call clear_display 
23b3				ld de, .compword 
23b3				ld a, display_row_1 
23b3				call str_at_display 
23b3				pop de 
23b3				ld a, display_row_2 
23b3				call str_at_display 
23b3				ld hl,(cli_ptr) 
23b3				ld a,(hl) 
23b3			        ld hl, os_word_scratch 
23b3				ld (hl),a 
23b3				ld a,0 
23b3				inc hl 
23b3				ld (hl),a 	 
23b3				ld de, os_word_scratch 
23b3				ld a, display_row_2+10 
23b3				call str_at_display 
23b3				call update_display 
23b3				ld a, 100 
23b3				call aDelayInMS 
23b3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23b3				call delay250ms 
23b3				endif 
23b3				pop hl 
23b3			.skip:  
23b3			endif	 
23b3			.execpnchar:    ; compare char between token and string to parse 
23b3			 
23b3			if DEBUG_FORTH_PARSE_KEY 
23b3						DMARK "Ky3" 
23b3			endif 
23b3			if DEBUG_FORTH_PARSE_EXEC 
23b3				; see if disabled 
23b3			 
23b3				ld a, (os_view_disable) 
23b3				cp '*' 
23b3				jr z, .skip2 
23b3			 
23b3			;	call clear_display 
23b3			ld hl,(cli_token) 
23b3			ld a,(hl) 
23b3			ld (os_word_scratch),a 
23b3				ld hl,(cli_ptr) 
23b3			ld a,(hl) 
23b3				ld (os_word_scratch+1),a 
23b3				ld a,0 
23b3				ld (os_word_scratch+2),a 
23b3				ld de,os_word_scratch 
23b3				ld a,display_row_4 
23b3				call str_at_display 
23b3				call update_display 
23b3			.skip2:  
23b3			endif 
23b3 2a d3 fb			ld hl,(cli_token) 
23b6 7e				ld a, (hl)	 ; char in word token 
23b7 23				inc hl 		; move to next char 
23b8 22 d3 fb			ld (cli_token), hl ; and save it 
23bb 47				ld b,a 
23bc			 
23bc 2a cd fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
23bf 7e				ld a,(hl) 
23c0 23				inc hl 
23c1 22 cd fb			ld (cli_ptr), hl		; move to next char 
23c4 cd 9e 13			call toUpper 		; make sure the input string matches case 
23c7			 
23c7			if DEBUG_FORTH_PARSE 
23c7			endif 
23c7			 
23c7				; input stream end of token is a space so get rid of it 
23c7			 
23c7			;	cp ' ' 
23c7			;	jr nz, .pnskipspace 
23c7			; 
23c7			;	ld a, 0		; make same term as word token term 
23c7			; 
23c7			;.pnskipspace: 
23c7			 
23c7			if DEBUG_FORTH_PARSE_KEY 
23c7						DMARK "KY7" 
23c7			endif 
23c7 b8				cp b 
23c8 c2 de 23			jp nz, .execpnskipword	 ; no match so move to next word 
23cb				 
23cb			;    if same 
23cb			;       scan for string terms 0 for token and 32 for input 
23cb			 
23cb				 
23cb			if DEBUG_FORTH_PARSE_KEY 
23cb						DMARK "KY8" 
23cb			endif 
23cb			 
23cb 80				add b			 
23cc fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
23ce							; TODO need to make sure last word in zero term string is accounted for 
23ce 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
23d0			 
23d0			 
23d0				; at end of both strings so both are exact match 
23d0			 
23d0			;       skip ptr for next word 
23d0			 
23d0 2a cd fb			ld hl,(cli_ptr) 	; at input string term 
23d3 23				inc hl			 ; at next char 
23d4 22 cd fb			ld (cli_ptr), hl     ; save for next round of the parser 
23d7 22 cb fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
23da				 
23da				 
23da			if DEBUG_FORTH_PARSE_KEY 
23da						DMARK "KY3" 
23da			endif 
23da			 
23da			 
23da			 
23da			;       exec code block 
23da			if DEBUG_FORTH_JP 
23da				call clear_display 
23da				call update_display 
23da				call delay1s 
23da				ld hl, (cli_execword)     ; save for next check if no match on this word 
23da				ld a,h 
23da				ld hl, os_word_scratch 
23da				call hexout 
23da				ld hl, (cli_execword)     ; save for next check if no match on this word 
23da				ld a,l 
23da				ld hl, os_word_scratch+2 
23da				call hexout 
23da				ld hl, os_word_scratch+4 
23da				ld a,0 
23da				ld (hl),a 
23da				ld de,os_word_scratch 
23da				call str_at_display 
23da					ld a, display_row_2 
23da					call str_at_display 
23da				ld de, (cli_origtoken) 
23da				ld a, display_row_1+10 
23da					call str_at_display 
23da			 
23da				ld a,display_row_1 
23da				ld de, .foundword 
23da				ld a, display_row_3 
23da				call str_at_display 
23da				call update_display 
23da				call delay1s 
23da				call delay1s 
23da				call delay1s 
23da			endif 
23da			 
23da			if DEBUG_FORTH_PARSE_KEY 
23da						DMARK "KYj" 
23da			endif 
23da				; TODO save the word pointer in this exec 
23da			 
23da 2a d1 fb			ld hl,(cli_execword) 
23dd e9				jp (hl) 
23de			 
23de			 
23de			;    if not same 
23de			;	scan for zero term 
23de			;	get ptr for next word 
23de			;	goto word comp 
23de			 
23de			.execpnskipword:	; get pointer to next word 
23de 2a cf fb			ld hl,(cli_nextword) 
23e1			 
23e1 7e				ld a,(hl) 
23e2 fe 00			cp WORD_SYS_END 
23e4			;	cp 0 
23e4 28 09			jr z, .execendofdict			 ; at end of words 
23e6			 
23e6			if DEBUG_FORTH_PARSE_KEY 
23e6						DMARK "KY4" 
23e6			endif 
23e6			if DEBUG_FORTH_PARSE_EXEC 
23e6			 
23e6				; see if disabled 
23e6			 
23e6				ld a, (os_view_disable) 
23e6				cp '*' 
23e6				jr z, .noskip 
23e6			 
23e6			 
23e6				ld de, .nowordfound 
23e6				ld a, display_row_3 
23e6				call str_at_display 
23e6				call update_display 
23e6				ld a, 100 
23e6				call aDelayInMS 
23e6				 
23e6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23e6					call delay250ms 
23e6				endif 
23e6			.noskip:  
23e6			 
23e6			endif	 
23e6			 
23e6 2a cb fb			ld hl,(cli_origptr) 
23e9 22 cd fb			ld (cli_ptr),hl 
23ec			 
23ec			if DEBUG_FORTH_PARSE_KEY 
23ec						DMARK "KY5" 
23ec			endif 
23ec c3 92 23			jp .execpnword			; else go to next word 
23ef			 
23ef			.execendofdict:  
23ef			 
23ef			if DEBUG_FORTH_PARSE_KEY 
23ef						DMARK "KYe" 
23ef			endif 
23ef			if DEBUG_FORTH_PARSE_EXEC 
23ef				; see if disabled 
23ef			 
23ef				ld a, (os_view_disable) 
23ef				cp '*' 
23ef				jr z, .ispskip 
23ef			 
23ef				call clear_display 
23ef				call update_display 
23ef				call delay1s 
23ef				ld de, (cli_origptr) 
23ef				ld a, display_row_1 
23ef				call str_at_display 
23ef				 
23ef				ld de, .enddict 
23ef				ld a, display_row_3 
23ef				call str_at_display 
23ef				call update_display 
23ef				ld a, 100 
23ef				call aDelayInMS 
23ef				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23ef				call delay1s 
23ef				call delay1s 
23ef				call delay1s 
23ef				endif 
23ef			.ispskip:  
23ef				 
23ef			endif	 
23ef			 
23ef			 
23ef			 
23ef				; if the word is not a keyword then must be a literal so push it to stack 
23ef			 
23ef			; push token to stack to end of word 
23ef			 
23ef				STACKFRAME ON $1efe $2f9f 
23ef				if DEBUG_STACK_IMB 
23ef					if ON 
23ef						exx 
23ef						ld de, $1efe 
23ef						ld a, d 
23ef						ld hl, curframe 
23ef						call hexout 
23ef						ld a, e 
23ef						ld hl, curframe+2 
23ef						call hexout 
23ef						ld hl, $1efe 
23ef						push hl 
23ef						ld hl, $2f9f 
23ef						push hl 
23ef						exx 
23ef					endif 
23ef				endif 
23ef			endm 
# End of macro STACKFRAME
23ef			 
23ef 2a 4f f6		ld hl,(os_tok_ptr) 
23f2 cd a3 20		call forth_apush 
23f5			 
23f5				STACKFRAMECHK ON $1efe $2f9f 
23f5				if DEBUG_STACK_IMB 
23f5					if ON 
23f5						exx 
23f5						ld hl, $2f9f 
23f5						pop de   ; $2f9f 
23f5						call cmp16 
23f5						jr nz, .spnosame 
23f5						ld hl, $1efe 
23f5						pop de   ; $1efe 
23f5						call cmp16 
23f5						jr z, .spfrsame 
23f5						.spnosame: call showsperror 
23f5						.spfrsame: nop 
23f5						exx 
23f5					endif 
23f5				endif 
23f5			endm 
# End of macro STACKFRAMECHK
23f5			 
23f5			execnext: 
23f5			 
23f5			if DEBUG_FORTH_PARSE_KEY 
23f5						DMARK "KY>" 
23f5			endif 
23f5			; move past token to next word 
23f5			 
23f5 2a 4f f6		ld hl, (os_tok_ptr) 
23f8 3e 00		ld a, 0 
23fa 01 ff 00		ld bc, 255     ; input buffer size 
23fd ed b1		cpir 
23ff			 
23ff			if DEBUG_FORTH_PARSE_KEY 
23ff						DMARK "KY!" 
23ff				CALLMONITOR 
23ff			endif	 
23ff			; TODO this might place hl on the null, so will need to forward on??? 
23ff			;inc hl   ; see if this gets onto the next item 
23ff			 
23ff			 
23ff			; TODO pass a pointer to the buffer to push 
23ff			; TODO call function to push 
23ff			 
23ff			; look for end of input 
23ff			 
23ff			;inc hl 
23ff			;ld a,(hl) 
23ff			;cp FORTH_END_BUFFER 
23ff			;ret z 
23ff			 
23ff			 
23ff c3 78 23		jp exec1 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			findnexttok: 
2402			 
2402				; hl is pointer to move 
2402				; de is the token to locate 
2402			 
2402					if DEBUG_FORTH 
2402						DMARK "NTK" 
2402						CALLMONITOR 
2402					endif 
2402 d5				push de 
2403			 
2403			.fnt1:	 
2403				; find first char of token to locate 
2403			 
2403 1a				ld a, (de) 
2404 4f				ld c,a 
2405 7e				ld a,(hl) 
2406 cd 9e 13			call toUpper 
2409					if DEBUG_FORTH 
2409						DMARK "NT1" 
2409						CALLMONITOR 
2409					endif 
2409 b9				cp c 
240a			 
240a 28 03			jr z, .fnt2cmpmorefirst	 
240c			 
240c				; first char not found move to next char 
240c			 
240c 23				inc hl 
240d 18 f4			jr .fnt1 
240f			 
240f			.fnt2cmpmorefirst:	 
240f				; first char of token found.  
240f			 
240f e5				push hl     ; save start of token just in case it is the right one 
2410 d9				exx 
2411 e1				pop hl        ; save it to hl' 
2412 d9				exx 
2413			 
2413			 
2413			.fnt2cmpmore:	 
2413				; compare the rest 
2413				 
2413 23				inc hl 
2414 13				inc de 
2415				 
2415 1a				ld a, (de) 
2416 4f				ld c,a 
2417 7e				ld a,(hl) 
2418 cd 9e 13			call toUpper 
241b			 
241b					if DEBUG_FORTH 
241b						DMARK "NT2" 
241b						CALLMONITOR 
241b					endif 
241b				; c has the token to find char 
241b				; a has the mem to scan char 
241b			 
241b b9				cp c 
241c 28 04			jr z,.fntmatch1 
241e			 
241e				; they are not the same 
241e			 
241e					if DEBUG_FORTH 
241e						DMARK "NT3" 
241e						CALLMONITOR 
241e					endif 
241e d1				pop de	; reset de token to look for 
241f d5				push de 
2420 18 e1			jr .fnt1 
2422				 
2422			.fntmatch1: 
2422			 
2422				; is the same char a null which means we might have a full hit? 
2422					if DEBUG_FORTH 
2422						DMARK "NT4" 
2422						CALLMONITOR 
2422					endif 
2422			 
2422 fe 00			cp 0 
2424 28 0b			jr z, .fntmatchyes 
2426			 
2426				; are we at the end of the token to find? 
2426			 
2426					if DEBUG_FORTH 
2426						DMARK "NT5" 
2426						CALLMONITOR 
2426					endif 
2426 3e 00			ld a, 0 
2428 b9				cp c 
2429			 
2429 c2 13 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
242c			 
242c					if DEBUG_FORTH 
242c						DMARK "NT6" 
242c						CALLMONITOR 
242c					endif 
242c				; token to find is exhusted but no match to stream 
242c			 
242c				; restore tok pointer and continue on 
242c d1				pop de 
242d d5				push de 
242e c3 03 24			jp .fnt1 
2431			 
2431			 
2431			.fntmatchyes: 
2431			 
2431				; hl now contains the end of the found token 
2431			 
2431				; get rid of saved token pointer to find 
2431			 
2431 d1				pop de 
2432			 
2432					if DEBUG_FORTH 
2432						DMARK "NT9" 
2432						CALLMONITOR 
2432					endif 
2432			 
2432				; hl will be on the null term so forward on 
2432			 
2432				; get back the saved start of the token 
2432			 
2432 d9				exx 
2433 e5				push hl     ; save start of token just in case it is the right one 
2434 d9				exx 
2435 e1				pop hl        ; save it to hl 
2436			 
2436 c9				ret 
2437			 
2437			 
2437			; LIST needs to find a specific token   
2437			; FORGET needs to find a spefici token 
2437			 
2437			; SAVE needs to find all tokens by flag 
2437			; WORDS just needs to scan through all  by flag 
2437			; UWORDS needs to scan through all by flag 
2437			 
2437			 
2437			; given hl as pointer to start of dict look up string 
2437			; return hl as pointer to start of word block 
2437			; or 0 if not found 
2437			 
2437			forth_find_tok: 
2437 c9				ret 
2438			 
2438			; given hl as pointer to dict structure 
2438			; move to the next dict block structure 
2438			 
2438			forth_tok_next: 
2438				; hl now points to the address of the next word pointer  
2438				; TODO skip compiled symbol for now 
2438			;	push de 
2438 23				inc hl 
2439 5e				ld e, (hl) 
243a 23				inc hl 
243b 56				ld d, (hl) 
243c 23				inc hl 
243d			 
243d eb				ex de,hl 
243e			if DEBUG_FORTH_PARSE_NEXTWORD 
243e				push bc 
243e				ld bc, (cli_nextword) 
243e						DMARK "NXW" 
243e				CALLMONITOR 
243e				pop bc 
243e			endif 
243e			;	pop de	 
243e c9				ret 
243f			 
243f			 
243f			 
243f			; eof 
# End of file forth_parserv5.asm
243f				include "forth_wordsv4.asm" 
243f			 
243f			; the core word dictionary v4 
243f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
243f			 
243f			; this is a linked list for each of the system words used 
243f			; user defined words will follow the same format but will be in ram 
243f			 
243f			 
243f			; 
243f			; 
243f			; define linked list: 
243f			; 
243f			; 1. compiled byte op code 
243f			; 2. len of text word 
243f			; 3. text word 
243f			; 4. ptr to next dictionary word 
243f			; 5. asm, calls etc for the word 
243f			; 
243f			;  if 1 == 0 then last word in dict  
243f			;   
243f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
243f			;  
243f			;  
243f			; create basic standard set of words 
243f			; 
243f			;  
243f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
243f			; 2DUP 2DROP 2SWAP  
243f			; @ C@ - get byte  
243f			; ! C! - store byte 
243f			; 0< true if less than zero 
243f			; 0= true if zero 
243f			; < >  
243f			; = true if same 
243f			; variables 
243f			 
243f			 
243f			; Hardware specific words I may need 
243f			; 
243f			; IN OUT  
243f			; calls to key util functions 
243f			; calls to hardward abstraction stuff 
243f			; easy control of frame buffers and lcd i/o 
243f			; keyboard  
243f			 
243f			 
243f			;DICT: macro 
243f			; op_code, len, word, next 
243f			;    word: 
243f			;    db op_code 
243f			;    ds word zero term 
243f			;    dw next 
243f			;    endm 
243f			 
243f			 
243f			 
243f			 
243f			; op code 1 is a flag for user define words which are to be handled differently 
243f			 
243f			 
243f			; 
243f			; 
243f			;    TODO on entry to a word this should be the expected environment 
243f			;    hl - tos value if number then held, if string this is the ptr 
243f			;    de -  
243f			 
243f			 
243f			; opcode ranges 
243f			; 0 - end of word dict 
243f			; 255 - user define words 
243f			 
243f			sysdict: 
243f			include "forth_opcodes.asm" 
243f			; op codes for forth keywords 
243f			; free to use code 0  
243f				OPCODE_HEAP: equ  1 
243f				OPCODE_EXEC: equ 2 
243f				OPCODE_DUP: equ 3 
243f				OPCODE_SWAP: equ 4 
243f				OPCODE_COLN: equ 5 
243f				OPCODE_SCOLN: equ 6 
243f				OPCODE_DROP: equ 7 
243f				OPCODE_DUP2: equ 8 
243f				OPCODE_DROP2: equ 9 
243f				OPCODE_SWAP2: equ 10 
243f				OPCODE_AT: equ 11 
243f				OPCODE_CAT: equ 12 
243f				OPCODE_BANG: equ 13 
243f				OPCODE_CBANG: equ 14 
243f				OPCODE_SCALL: equ 15 
243f				OPCODE_DEPTH: equ 16 
243f				OPCODE_OVER: equ 17 
243f				OPCODE_PAUSE: equ 18 
243f				OPCODE_PAUSES: equ 19 
243f				OPCODE_ROT: equ 20 
243f			;free to reuse	OPCODE_WORDS: equ 21 
243f			        OPCODE_NOT: equ 21 
243f				OPCODE_UWORDS: equ 22 
243f				OPCODE_BP: equ 23 
243f				OPCODE_MONITOR: equ 24  
243f				OPCODE_MALLOC: equ 25 
243f				OPCODE_FREE: equ 26 
243f				OPCODE_LIST: equ 27 
243f				OPCODE_FORGET: equ 28 
243f				OPCODE_NOP: equ 29 
243f				OPCODE_COMO: equ 30 
243f				OPCODE_COMC: equ 31 
243f			;free to reuse	OPCODE_ENDCORE: equ 32 
243f				OPCODE_AFTERSOUND: equ 33 
243f				OPCODE_GP2: equ 34 
243f				OPCODE_GP3: equ 35 
243f				OPCODE_GP4: equ 36 
243f				OPCODE_SIN: equ 37 
243f				OPCODE_SOUT: equ 38 
243f				OPCODE_SPIO: equ 39 
243f				OPCODE_SPICEH: equ 40 
243f				OPCODE_SPIOb: equ 41 
243f				OPCODE_SPII: equ 42 
243f				OPCODE_SESEL: equ 43 
243f				OPCODE_CARTDEV: equ 44 
243f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
243f				OPCODE_FB: equ 46 
243f				OPCODE_EMIT: equ 47 
243f				OPCODE_DOTH: equ 48 
243f				OPCODE_DOTF: equ 49 
243f				OPCODE_DOT: equ 50 
243f				OPCODE_CLS: equ 51 
243f				OPCODE_DRAW: equ 52 
243f				OPCODE_DUMP: equ 53 
243f				OPCODE_CDUMP: equ 54 
243f				OPCODE_DAT: equ 55 
243f				OPCODE_HOME: equ 56 
243f				OPCODE_SPACE: equ 57 
243f				OPCODE_SPACES: equ 58 
243f				OPCODE_SCROLL: equ 59 
243f				OPCODE_ATQ: equ 60 
243f				OPCODE_AUTODSP: equ 61 
243f				OPCODE_MENU: equ 62 
243f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
243f				OPCODE_THEN: equ 64 
243f				OPCODE_ELSE: equ 65 
243f				OPCODE_DO: equ 66 
243f				OPCODE_LOOP: equ 67 
243f				OPCODE_I: equ 68 
243f				OPCODE_DLOOP: equ 69  
243f				OPCODE_REPEAT: equ 70  
243f				OPCODE_UNTIL: equ 71 
243f				OPCODE_ENDFLOW: equ 72 
243f				OPCODE_WAITK: equ 73 
243f				OPCODE_ACCEPT: equ 74 
243f				OPCODE_EDIT: equ 75 
243f			;free to reuse	OPCODE_ENDKEY: equ 76 
243f				OPCODE_LZERO: equ 77 
243f				OPCODE_TZERO: equ 78 
243f				OPCODE_LESS: equ 79 
243f				OPCODE_GT: equ 80 
243f				OPCODE_EQUAL: equ 81  
243f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
243f				OPCODE_NEG: equ 83 
243f				OPCODE_DIV: equ 84 
243f				OPCODE_MUL: equ 85 
243f				OPCODE_MIN: equ 86 
243f				OPCODE_MAX: equ 87 
243f				OPCODE_RND16: equ 88 
243f				OPCODE_RND8: equ 89 
243f				OPCODE_RND: equ 90 
243f			;free to reuse	OPCODE_ENDMATHS: equ 91  
243f				OPCODE_BYNAME: equ 92 
243f				OPCODE_DIR: equ 93 
243f				OPCODE_SAVE: equ 94 
243f				OPCODE_LOAD: equ 95 
243f				OPCODE_BSAVE: equ 96 
243f				OPCODE_BLOAD: equ 97 
243f				OPCODE_SEO: equ 98  
243f				OPCODE_SEI: equ 99 
243f				OPCODE_SFREE: equ 100 
243f				OPCODE_SIZE: equ 101 
243f				OPCODE_CREATE: equ 102 
243f				OPCODE_APPEND: equ 103 
243f				OPCODE_SDEL: equ 104 
243f				OPCODE_OPEN: equ 105 
243f				OPCODE_READ: equ 106 
243f				OPCODE_EOF: equ 106 
243f				OPCODE_FORMAT: equ 107 
243f				OPCODE_LABEL: equ 108 
243f				OPCODE_LABELS: equ 109 
243f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
243f				OPCODE_UPPER: equ 111 
243f				OPCODE_LOWER: equ 112 
243f				OPCODE_SUBSTR: equ 113 
243f				OPCODE_LEFT: equ 114 
243f				OPCODE_RIGHT: equ 115 
243f				OPCODE_STR2NUM: equ 116 
243f				OPCODE_NUM2STR: equ 117 
243f				OPCODE_CONCAT: equ 118 
243f				OPCODE_FIND: equ 119 
243f				OPCODE_LEN: equ 120 
243f				OPCODE_CHAR: equ 121 
243f			; free to reuse	OPCODE_STRLEN: equ 122 
243f			; free to reuse	OPCODE_ENDSTR: equ 123 
243f				OPCODE_V0S: equ 124 
243f				OPCODE_V0Q: equ 125 
243f				OPCODE_V1S: equ 126 
243f				OPCODE_V1Q: equ 127 
243f				OPCODE_V2S: equ 128 
243f				OPCODE_V2Q: equ 129 
243f				OPCODE_V3S: equ 130 
243f				OPCODE_V3Q: equ 131 
243f			;free to reuse	OPCODE_END: equ 132 
243f				OPCODE_ZDUP: equ 133 
243f			 
243f			; eof 
# End of file forth_opcodes.asm
243f			 
243f			include "forth_words_core.asm" 
243f			 
243f			; | ## Core Words 
243f			 
243f			;if MALLOC_4 
243f			 
243f			.HEAP: 
243f				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
243f 15				db WORD_SYS_CORE+OPCODE_HEAP             
2440 7e 24			dw .EXEC            
2442 05				db 4 + 1 
2443 .. 00			db "HEAP",0              
2448				endm 
# End of macro CWHEAD
2448			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2448			; | | u1 - Current number of bytes in the heap 
2448			; | | u2 - Remaining bytes left on the heap 
2448			; | |  
2448			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2448			 
2448			 
2448					if DEBUG_FORTH_WORDS_KEY 
2448						DMARK "HEP" 
2448 f5				push af  
2449 3a 5d 24			ld a, (.dmark)  
244c 32 b4 fe			ld (debug_mark),a  
244f 3a 5e 24			ld a, (.dmark+1)  
2452 32 b5 fe			ld (debug_mark+1),a  
2455 3a 5f 24			ld a, (.dmark+2)  
2458 32 b6 fe			ld (debug_mark+2),a  
245b 18 03			jr .pastdmark  
245d ..			.dmark: db "HEP"  
2460 f1			.pastdmark: pop af  
2461			endm  
# End of macro DMARK
2461						CALLMONITOR 
2461 cd c6 18			call break_point_state  
2464				endm  
# End of macro CALLMONITOR
2464					endif 
2464 2a 0a 80				ld hl, (free_list )      
2467 11 0e 80				ld de, heap_start 
246a			 
246a ed 52				sbc hl, de  
246c			 
246c cd 3a 1f				call forth_push_numhl 
246f			 
246f			 
246f ed 5b 0a 80			ld de, (free_list )      
2473 21 34 f3				ld hl, heap_end 
2476			 
2476 ed 52				sbc hl, de 
2478			 
2478 cd 3a 1f				call forth_push_numhl 
247b					 
247b			 
247b					 
247b			 
247b			 
247b			 
247b					NEXTW 
247b c3 e7 22			jp macro_next 
247e				endm 
# End of macro NEXTW
247e			;endif 
247e			 
247e			.EXEC: 
247e			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
247e			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
247e			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
247e			;; > > 
247e			;; > >   
247e			;	STACKFRAME OFF $5efe $5f9f 
247e			; 
247e			;		if DEBUG_FORTH_WORDS_KEY 
247e			;			DMARK "EXE" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	FORTH_DSP_VALUEHL 
247e			; 
247e			;	FORTH_DSP_POP 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX1" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;;	ld e,(hl) 
247e			;;	inc hl 
247e			;;	ld d,(hl) 
247e			;;	ex de,hl 
247e			; 
247e			;;		if DEBUG_FORTH_WORDS 
247e			;;			DMARK "EX2" 
247e			;;			CALLMONITOR 
247e			;;		endif 
247e			;	push hl 
247e			; 
247e			;	;ld a, 0 
247e			;	;ld a, FORTH_END_BUFFER 
247e			;	call strlenz 
247e			;	inc hl   ; include zero term to copy 
247e			;	inc hl   ; include term 
247e			;	inc hl   ; include term 
247e			;	ld b,0 
247e			;	ld c,l 
247e			;	pop hl 
247e			;	ld de, execscratch 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX3" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ldir 
247e			; 
247e			; 
247e			;	ld hl, execscratch 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXe" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	call forthparse 
247e			;	call forthexec 
247e			;;	call forthexec_cleanup 
247e			;;	call forthparse 
247e			;;	call forthexec 
247e			; 
247e			;	STACKFRAMECHK OFF $5efe $5f9f 
247e			; 
247e			;	; an immediate word so no need to process any more words 
247e			;	ret 
247e			;	NEXTW 
247e			 
247e			; dead code - old version  
247e			;	FORTH_RSP_NEXT 
247e			 
247e			;  
247e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
247e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
247e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
247e			;	push hl 
247e			;	push de 
247e			;	push bc 
247e			; 
247e			; 
247e			;		if DEBUG_FORTH_WORDS_KEY 
247e			;			DMARK "EXR" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			; 
247e			; 
247e			;	;v5 FORTH_DSP_VALUE 
247e			;	FORTH_DSP_VALUEHL 
247e			; 
247e			;	; TODO do string type checks 
247e			; 
247e			;;v5	inc hl   ; skip type 
247e			; 
247e			;	push hl  ; source code  
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX1" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ld a, 0 
247e			;	call strlent 
247e			; 
247e			;	inc hl 
247e			;	inc hl 
247e			;	inc hl 
247e			;	inc hl 
247e			; 
247e			;	push hl    ; size 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX2" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	call malloc 
247e			; 
247e			;	ex de, hl    ; de now contains malloc area 
247e			;	pop bc   	; get byte count 
247e			;	pop hl      ; get string to copy 
247e			; 
247e			;	push de     ; save malloc for free later 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX3" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ldir       ; duplicate string 
247e			; 
247e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
247e			;	 
247e			;	; TODO fix the parse would be better than this...  
247e			;	ex de, hl 
247e			;	dec hl 
247e			;	ld a, 0 
247e			;	ld (hl), a 
247e			;	dec hl 
247e			;	ld a, ' ' 
247e			;	ld (hl), a 
247e			;	dec hl 
247e			;	ld (hl), a 
247e			; 
247e			;	dec hl 
247e			;	ld (hl), a 
247e			; 
247e			; 
247e			;	FORTH_DSP_POP  
247e			; 
247e			;	pop hl     
247e			;	push hl    ; save malloc area 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX4" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	call forthparse 
247e			;	call forthexec 
247e			;	 
247e			;	pop hl 
247e			;	if DEBUG_FORTH_WORDS 
247e			;		DMARK "EX5" 
247e			;		CALLMONITOR 
247e			;	endif 
247e			; 
247e			;	if FORTH_ENABLE_FREE 
247e			;	call free 
247e			;	endif 
247e			; 
247e			;	if DEBUG_FORTH_WORDS 
247e			;		DMARK "EX6" 
247e			;		CALLMONITOR 
247e			;	endif 
247e			; 
247e			;	pop bc 
247e			;	pop de 
247e			;	pop hl 
247e			;;	FORTH_RSP_POP	  
247e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
247e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
247e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
247e			; 
247e			;	if DEBUG_FORTH_WORDS 
247e			;		DMARK "EX7" 
247e			;		CALLMONITOR 
247e			;	endif 
247e			;	NEXTW 
247e			 
247e			;.STKEXEC: 
247e			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
247e			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
247e			; 
247e			; 
247e			;		if DEBUG_FORTH_WORDS_KEY 
247e			;			DMARK "STX" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	FORTH_DSP_VALUEHL 
247e			; 
247e			;	ld (store_tmp1), hl    ; count 
247e			; 
247e			;	FORTH_DSP_POP 
247e			;.stkexec1: 
247e			;	ld hl, (store_tmp1)   ; count 
247e			;	ld a, 0 
247e			;	cp l 
247e			;	ret z 
247e			; 
247e			;	dec hl 
247e			;	ld (store_tmp1), hl    ; count 
247e			;	 
247e			;	FORTH_DSP_VALUEHL 
247e			;	push hl 
247e			;	 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXp" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	FORTH_DSP_POP 
247e			; 
247e			;	call strlenz 
247e			;	inc hl   ; include zero term to copy 
247e			;	inc hl   ; include zero term to copy 
247e			;	inc hl   ; include zero term to copy 
247e			;	ld b,0 
247e			;	ld c,l 
247e			;	pop hl 
247e			;	ld de, execscratch 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX3" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ldir 
247e			; 
247e			; 
247e			;	ld hl, execscratch 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXP" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	call forthparse 
247e			;	ld hl, execscratch 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXx" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	call forthexec 
247e			; 
247e			;	jp .stkexec1 
247e			; 
247e			;	ret 
247e			 
247e			 
247e			.DUP: 
247e				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
247e 17				db WORD_SYS_CORE+OPCODE_DUP             
247f f4 24			dw .ZDUP            
2481 04				db 3 + 1 
2482 .. 00			db "DUP",0              
2486				endm 
# End of macro CWHEAD
2486			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2486			 
2486					if DEBUG_FORTH_WORDS_KEY 
2486						DMARK "DUP" 
2486 f5				push af  
2487 3a 9b 24			ld a, (.dmark)  
248a 32 b4 fe			ld (debug_mark),a  
248d 3a 9c 24			ld a, (.dmark+1)  
2490 32 b5 fe			ld (debug_mark+1),a  
2493 3a 9d 24			ld a, (.dmark+2)  
2496 32 b6 fe			ld (debug_mark+2),a  
2499 18 03			jr .pastdmark  
249b ..			.dmark: db "DUP"  
249e f1			.pastdmark: pop af  
249f			endm  
# End of macro DMARK
249f						CALLMONITOR 
249f cd c6 18			call break_point_state  
24a2				endm  
# End of macro CALLMONITOR
24a2					endif 
24a2			 
24a2					FORTH_DSP 
24a2 cd f7 20			call macro_forth_dsp 
24a5				endm 
# End of macro FORTH_DSP
24a5			 
24a5 7e					ld a, (HL) 
24a6 fe 01				cp DS_TYPE_STR 
24a8 20 25				jr nz, .dupinum 
24aa			 
24aa					; push another string 
24aa			 
24aa					FORTH_DSP_VALUEHL     		 
24aa cd 31 21			call macro_dsp_valuehl 
24ad				endm 
# End of macro FORTH_DSP_VALUEHL
24ad			 
24ad				if DEBUG_FORTH_WORDS 
24ad					DMARK "DUs" 
24ad f5				push af  
24ae 3a c2 24			ld a, (.dmark)  
24b1 32 b4 fe			ld (debug_mark),a  
24b4 3a c3 24			ld a, (.dmark+1)  
24b7 32 b5 fe			ld (debug_mark+1),a  
24ba 3a c4 24			ld a, (.dmark+2)  
24bd 32 b6 fe			ld (debug_mark+2),a  
24c0 18 03			jr .pastdmark  
24c2 ..			.dmark: db "DUs"  
24c5 f1			.pastdmark: pop af  
24c6			endm  
# End of macro DMARK
24c6					CALLMONITOR 
24c6 cd c6 18			call break_point_state  
24c9				endm  
# End of macro CALLMONITOR
24c9				endif 
24c9 cd a8 1f				call forth_push_str 
24cc			 
24cc					NEXTW 
24cc c3 e7 22			jp macro_next 
24cf				endm 
# End of macro NEXTW
24cf			 
24cf			 
24cf			.dupinum: 
24cf					 
24cf			 
24cf			 
24cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24cf cd 31 21			call macro_dsp_valuehl 
24d2				endm 
# End of macro FORTH_DSP_VALUEHL
24d2			 
24d2				; TODO add floating point number detection 
24d2			 
24d2				if DEBUG_FORTH_WORDS 
24d2					DMARK "DUi" 
24d2 f5				push af  
24d3 3a e7 24			ld a, (.dmark)  
24d6 32 b4 fe			ld (debug_mark),a  
24d9 3a e8 24			ld a, (.dmark+1)  
24dc 32 b5 fe			ld (debug_mark+1),a  
24df 3a e9 24			ld a, (.dmark+2)  
24e2 32 b6 fe			ld (debug_mark+2),a  
24e5 18 03			jr .pastdmark  
24e7 ..			.dmark: db "DUi"  
24ea f1			.pastdmark: pop af  
24eb			endm  
# End of macro DMARK
24eb					CALLMONITOR 
24eb cd c6 18			call break_point_state  
24ee				endm  
# End of macro CALLMONITOR
24ee				endif 
24ee			 
24ee cd 3a 1f				call forth_push_numhl 
24f1					NEXTW 
24f1 c3 e7 22			jp macro_next 
24f4				endm 
# End of macro NEXTW
24f4			.ZDUP: 
24f4				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
24f4 99				db WORD_SYS_CORE+OPCODE_ZDUP             
24f5 2c 25			dw .SWAP            
24f7 05				db 4 + 1 
24f8 .. 00			db "?DUP",0              
24fd				endm 
# End of macro CWHEAD
24fd			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
24fd			 
24fd					if DEBUG_FORTH_WORDS_KEY 
24fd						DMARK "qDU" 
24fd f5				push af  
24fe 3a 12 25			ld a, (.dmark)  
2501 32 b4 fe			ld (debug_mark),a  
2504 3a 13 25			ld a, (.dmark+1)  
2507 32 b5 fe			ld (debug_mark+1),a  
250a 3a 14 25			ld a, (.dmark+2)  
250d 32 b6 fe			ld (debug_mark+2),a  
2510 18 03			jr .pastdmark  
2512 ..			.dmark: db "qDU"  
2515 f1			.pastdmark: pop af  
2516			endm  
# End of macro DMARK
2516						CALLMONITOR 
2516 cd c6 18			call break_point_state  
2519				endm  
# End of macro CALLMONITOR
2519					endif 
2519					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2519 cd 31 21			call macro_dsp_valuehl 
251c				endm 
# End of macro FORTH_DSP_VALUEHL
251c			 
251c e5					push hl 
251d			 
251d					; is it a zero? 
251d			 
251d 3e 00				ld a, 0 
251f 84					add h 
2520 85					add l 
2521			 
2521 e1					pop hl 
2522			 
2522 fe 00				cp 0 
2524 28 03				jr z, .dup2orig 
2526			 
2526			 
2526 cd 3a 1f				call forth_push_numhl 
2529			 
2529			 
2529				; TODO add floating point number detection 
2529			 
2529			.dup2orig: 
2529			 
2529					NEXTW 
2529 c3 e7 22			jp macro_next 
252c				endm 
# End of macro NEXTW
252c			.SWAP: 
252c				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
252c 18				db WORD_SYS_CORE+OPCODE_SWAP             
252d 6b 25			dw .COLN            
252f 05				db 4 + 1 
2530 .. 00			db "SWAP",0              
2535				endm 
# End of macro CWHEAD
2535			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2535					if DEBUG_FORTH_WORDS_KEY 
2535						DMARK "SWP" 
2535 f5				push af  
2536 3a 4a 25			ld a, (.dmark)  
2539 32 b4 fe			ld (debug_mark),a  
253c 3a 4b 25			ld a, (.dmark+1)  
253f 32 b5 fe			ld (debug_mark+1),a  
2542 3a 4c 25			ld a, (.dmark+2)  
2545 32 b6 fe			ld (debug_mark+2),a  
2548 18 03			jr .pastdmark  
254a ..			.dmark: db "SWP"  
254d f1			.pastdmark: pop af  
254e			endm  
# End of macro DMARK
254e						CALLMONITOR 
254e cd c6 18			call break_point_state  
2551				endm  
# End of macro CALLMONITOR
2551					endif 
2551			 
2551					FORTH_DSP_VALUEHL 
2551 cd 31 21			call macro_dsp_valuehl 
2554				endm 
# End of macro FORTH_DSP_VALUEHL
2554 e5					push hl     ; w2 
2555			 
2555					FORTH_DSP_POP 
2555 cd e9 21			call macro_forth_dsp_pop 
2558				endm 
# End of macro FORTH_DSP_POP
2558			 
2558					FORTH_DSP_VALUEHL 
2558 cd 31 21			call macro_dsp_valuehl 
255b				endm 
# End of macro FORTH_DSP_VALUEHL
255b			 
255b					FORTH_DSP_POP 
255b cd e9 21			call macro_forth_dsp_pop 
255e				endm 
# End of macro FORTH_DSP_POP
255e			 
255e d1					pop de     ; w2	, hl = w1 
255f			 
255f eb					ex de, hl 
2560 d5					push de 
2561			 
2561 cd 3a 1f				call forth_push_numhl 
2564			 
2564 e1					pop hl 
2565			 
2565 cd 3a 1f				call forth_push_numhl 
2568					 
2568			 
2568					NEXTW 
2568 c3 e7 22			jp macro_next 
256b				endm 
# End of macro NEXTW
256b			.COLN: 
256b				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
256b 19				db WORD_SYS_CORE+OPCODE_COLN             
256c f7 26			dw .SCOLN            
256e 02				db 1 + 1 
256f .. 00			db ":",0              
2571				endm 
# End of macro CWHEAD
2571			; | : ( -- )         Create new word | DONE 
2571			 
2571					if DEBUG_FORTH_WORDS_KEY 
2571						DMARK "CLN" 
2571 f5				push af  
2572 3a 86 25			ld a, (.dmark)  
2575 32 b4 fe			ld (debug_mark),a  
2578 3a 87 25			ld a, (.dmark+1)  
257b 32 b5 fe			ld (debug_mark+1),a  
257e 3a 88 25			ld a, (.dmark+2)  
2581 32 b6 fe			ld (debug_mark+2),a  
2584 18 03			jr .pastdmark  
2586 ..			.dmark: db "CLN"  
2589 f1			.pastdmark: pop af  
258a			endm  
# End of macro DMARK
258a						CALLMONITOR 
258a cd c6 18			call break_point_state  
258d				endm  
# End of macro CALLMONITOR
258d					endif 
258d				STACKFRAME OFF $8efe $989f 
258d				if DEBUG_STACK_IMB 
258d					if OFF 
258d						exx 
258d						ld de, $8efe 
258d						ld a, d 
258d						ld hl, curframe 
258d						call hexout 
258d						ld a, e 
258d						ld hl, curframe+2 
258d						call hexout 
258d						ld hl, $8efe 
258d						push hl 
258d						ld hl, $989f 
258d						push hl 
258d						exx 
258d					endif 
258d				endif 
258d			endm 
# End of macro STACKFRAME
258d				; get parser buffer length  of new word 
258d			 
258d				 
258d			 
258d					; move tok past this to start of name defintition 
258d					; TODO get word to define 
258d					; TODO Move past word token 
258d					; TODO get length of string up to the ';' 
258d			 
258d 2a 4f f6			ld hl, (os_tok_ptr) 
2590 23				inc hl 
2591 23				inc hl 
2592			 
2592 3e 3b			ld a, ';' 
2594 cd b2 13			call strlent 
2597			 
2597 7d				ld a,l 
2598 32 4a f3			ld (os_new_parse_len), a 
259b			 
259b			 
259b			if DEBUG_FORTH_UWORD 
259b ed 5b 4f f6		ld de, (os_tok_ptr) 
259f						DMARK ":01" 
259f f5				push af  
25a0 3a b4 25			ld a, (.dmark)  
25a3 32 b4 fe			ld (debug_mark),a  
25a6 3a b5 25			ld a, (.dmark+1)  
25a9 32 b5 fe			ld (debug_mark+1),a  
25ac 3a b6 25			ld a, (.dmark+2)  
25af 32 b6 fe			ld (debug_mark+2),a  
25b2 18 03			jr .pastdmark  
25b4 ..			.dmark: db ":01"  
25b7 f1			.pastdmark: pop af  
25b8			endm  
# End of macro DMARK
25b8				CALLMONITOR 
25b8 cd c6 18			call break_point_state  
25bb				endm  
# End of macro CALLMONITOR
25bb			endif 
25bb			 
25bb			; 
25bb			;  new word memory layout: 
25bb			;  
25bb			;    : adg 6666 ;  
25bb			; 
25bb			;    db   1     ; user defined word  
25bb 23				inc hl    
25bc			;    dw   sysdict 
25bc 23				inc hl 
25bd 23				inc hl 
25be			;    db <word len>+1 (for null) 
25be 23				inc hl 
25bf			;    db .... <word> 
25bf			; 
25bf			 
25bf 23				inc hl    ; some extras for the word preamble before the above 
25c0 23				inc hl 
25c1 23				inc hl 
25c2 23				inc hl 
25c3 23				inc hl 
25c4 23				inc hl 
25c5 23				inc hl  
25c6 23				inc hl 
25c7 23				inc hl 
25c8 23				inc hl 
25c9 23				inc hl 
25ca 23				inc hl 
25cb 23				inc hl 
25cc 23				inc hl     ; TODO how many do we really need?     maybe only 6 
25cd			;       exec word buffer 
25cd			;	<ptr word>   
25cd 23				inc hl 
25ce 23				inc hl 
25cf			;       <word list><null term> 7F final term 
25cf			 
25cf			 
25cf			if DEBUG_FORTH_UWORD 
25cf						DMARK ":02" 
25cf f5				push af  
25d0 3a e4 25			ld a, (.dmark)  
25d3 32 b4 fe			ld (debug_mark),a  
25d6 3a e5 25			ld a, (.dmark+1)  
25d9 32 b5 fe			ld (debug_mark+1),a  
25dc 3a e6 25			ld a, (.dmark+2)  
25df 32 b6 fe			ld (debug_mark+2),a  
25e2 18 03			jr .pastdmark  
25e4 ..			.dmark: db ":02"  
25e7 f1			.pastdmark: pop af  
25e8			endm  
# End of macro DMARK
25e8				CALLMONITOR 
25e8 cd c6 18			call break_point_state  
25eb				endm  
# End of macro CALLMONITOR
25eb			endif 
25eb			 
25eb				 
25eb					; malloc the size 
25eb			 
25eb cd 10 14				call malloc 
25ee 22 4c f3				ld (os_new_malloc), hl     ; save malloc start 
25f1			 
25f1			;    db   1     ; user defined word  
25f1 3e 01				ld a, WORD_SYS_UWORD  
25f3 77					ld (hl), a 
25f4				 
25f4 23				inc hl    
25f5			;    dw   sysdict 
25f5 11 3f 24			ld de, sysdict       ; continue on with the scan to the system dict 
25f8 73				ld (hl), e 
25f9 23				inc hl 
25fa 72				ld (hl), d 
25fb 23				inc hl 
25fc			 
25fc			 
25fc			;    Setup dict word 
25fc			 
25fc 23				inc hl 
25fd 22 46 f3			ld (os_new_work_ptr), hl     ; save start of dict word  
2600			 
2600				; 1. get length of dict word 
2600			 
2600			 
2600 2a 4f f6			ld hl, (os_tok_ptr) 
2603 23				inc hl 
2604 23				inc hl    ; position to start of dict word 
2605 3e 00			ld a, 0 
2607 cd b2 13			call strlent 
260a			 
260a			 
260a 23				inc hl    ; to include null??? 
260b			 
260b				; write length of dict word 
260b			 
260b ed 5b 46 f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
260f 1b				dec de 
2610 eb				ex de, hl 
2611 73				ld (hl), e 
2612 eb				ex de, hl 
2613			 
2613				 
2613			 
2613				; copy  
2613 4d				ld c, l 
2614 06 00			ld b, 0 
2616 ed 5b 46 f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
261a 2a 4f f6			ld hl, (os_tok_ptr) 
261d 23				inc hl 
261e 23				inc hl    ; position to start of dict word 
261f				 
261f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
261f				 
261f				; TODO need to convert word to upper case 
261f			 
261f			ucasetok:	 
261f 7e				ld a,(hl) 
2620 cd 9e 13			call toUpper 
2623 77				ld (hl),a 
2624 ed a0			ldi 
2626 f2 1f 26		 	jp p, ucasetok 
2629			 
2629			 
2629			 
2629				; de now points to start of where the word body code should be placed 
2629 ed 53 46 f3		ld (os_new_work_ptr), de 
262d				; hl now points to the words to throw at forthexec which needs to be copied 
262d 22 44 f3			ld (os_new_src_ptr), hl 
2630			 
2630				; TODO add 'call to forthexec' 
2630			 
2630			if DEBUG_FORTH_UWORD 
2630 c5				push bc 
2631 ed 4b 4c f3		ld bc, (os_new_malloc) 
2635						DMARK ":0x" 
2635 f5				push af  
2636 3a 4a 26			ld a, (.dmark)  
2639 32 b4 fe			ld (debug_mark),a  
263c 3a 4b 26			ld a, (.dmark+1)  
263f 32 b5 fe			ld (debug_mark+1),a  
2642 3a 4c 26			ld a, (.dmark+2)  
2645 32 b6 fe			ld (debug_mark+2),a  
2648 18 03			jr .pastdmark  
264a ..			.dmark: db ":0x"  
264d f1			.pastdmark: pop af  
264e			endm  
# End of macro DMARK
264e				CALLMONITOR 
264e cd c6 18			call break_point_state  
2651				endm  
# End of macro CALLMONITOR
2651 c1				pop bc 
2652			endif 
2652			 
2652			 
2652				; create word preamble which should be: 
2652			 
2652			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2652			 
2652				;    ld hl, <word code> 
2652				;    jp user_exec 
2652			        ;    <word code bytes> 
2652			 
2652			 
2652			;	inc de     ; TODO ??? or are we already past the word's null 
2652 eb				ex de, hl 
2653			 
2653 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2655			 
2655 23				inc hl 
2656 22 40 f3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2659 23				inc hl 
265a			 
265a 23				inc hl 
265b 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
265d			 
265d 01 66 59			ld bc, user_exec 
2660 23				inc hl 
2661 71				ld (hl), c     ; poke address of user_exec 
2662 23				inc hl 
2663 70				ld (hl), b     
2664			 ; 
2664			;	inc hl 
2664			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2664			; 
2664			; 
2664			;	ld bc, macro_forth_rsp_next 
2664			;	inc hl 
2664			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2664			;	inc hl 
2664			;	ld (hl), b     
2664			 ; 
2664			;	inc hl 
2664			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2664			; 
2664			; 
2664			;	inc hl 
2664			;	ld bc, forthexec 
2664			;	ld (hl), c     ; poke address of forthexec 
2664			;	inc hl 
2664			;	ld (hl), b      
2664			; 
2664			;	inc hl 
2664			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2664			; 
2664			;	ld bc, user_dict_next 
2664			;	inc hl 
2664			;	ld (hl), c     ; poke address of forthexec 
2664			;	inc hl 
2664			;	ld (hl), b      
2664			 
2664				; hl is now where we need to copy the word byte data to save this 
2664			 
2664 23				inc hl 
2665 22 42 f3			ld (os_new_exec), hl 
2668				 
2668				; copy definition 
2668			 
2668 eb				ex de, hl 
2669			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2669			;	inc de    ; skip the PC for this parse 
2669 3a 4a f3			ld a, (os_new_parse_len) 
266c 4f				ld c, a 
266d 06 00			ld b, 0 
266f ed b0			ldir		 ; copy defintion 
2671			 
2671			 
2671				; poke the address of where the new word bytes live for forthexec 
2671			 
2671 2a 40 f3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2674			 
2674 ed 5b 42 f3		ld de, (os_new_exec)      
2678				 
2678 73				ld (hl), e 
2679 23				inc hl 
267a 72				ld (hl), d 
267b			 
267b					; TODO copy last user dict word next link to this word 
267b					; TODO update last user dict word to point to this word 
267b			; 
267b			; hl f923 de 812a ; bc 811a 
267b			 
267b			if DEBUG_FORTH_UWORD 
267b c5				push bc 
267c ed 4b 4c f3		ld bc, (os_new_malloc) 
2680						DMARK ":0A" 
2680 f5				push af  
2681 3a 95 26			ld a, (.dmark)  
2684 32 b4 fe			ld (debug_mark),a  
2687 3a 96 26			ld a, (.dmark+1)  
268a 32 b5 fe			ld (debug_mark+1),a  
268d 3a 97 26			ld a, (.dmark+2)  
2690 32 b6 fe			ld (debug_mark+2),a  
2693 18 03			jr .pastdmark  
2695 ..			.dmark: db ":0A"  
2698 f1			.pastdmark: pop af  
2699			endm  
# End of macro DMARK
2699				CALLMONITOR 
2699 cd c6 18			call break_point_state  
269c				endm  
# End of macro CALLMONITOR
269c c1				pop bc 
269d			endif 
269d			if DEBUG_FORTH_UWORD 
269d c5				push bc 
269e ed 4b 4c f3		ld bc, (os_new_malloc) 
26a2 03				inc bc 
26a3 03				inc bc 
26a4 03				inc bc 
26a5 03				inc bc 
26a6 03				inc bc 
26a7 03				inc bc 
26a8 03				inc bc 
26a9 03				inc bc 
26aa			 
26aa						DMARK ":0B" 
26aa f5				push af  
26ab 3a bf 26			ld a, (.dmark)  
26ae 32 b4 fe			ld (debug_mark),a  
26b1 3a c0 26			ld a, (.dmark+1)  
26b4 32 b5 fe			ld (debug_mark+1),a  
26b7 3a c1 26			ld a, (.dmark+2)  
26ba 32 b6 fe			ld (debug_mark+2),a  
26bd 18 03			jr .pastdmark  
26bf ..			.dmark: db ":0B"  
26c2 f1			.pastdmark: pop af  
26c3			endm  
# End of macro DMARK
26c3				CALLMONITOR 
26c3 cd c6 18			call break_point_state  
26c6				endm  
# End of macro CALLMONITOR
26c6 c1				pop bc 
26c7			endif 
26c7			 
26c7			; update word dict linked list for new word 
26c7			 
26c7			 
26c7 2a 4b f6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
26ca 23			inc hl     ; move to next work linked list ptr 
26cb			 
26cb ed 5b 4c f3	ld de, (os_new_malloc)		 ; new next word 
26cf 73			ld (hl), e 
26d0 23			inc hl 
26d1 72			ld (hl), d 
26d2			 
26d2			if DEBUG_FORTH_UWORD 
26d2 ed 4b 4b f6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
26d6			endif 
26d6			 
26d6 ed 53 4b f6	ld (os_last_new_uword), de      ; update last new uword ptr 
26da			 
26da			 
26da			if DEBUG_FORTH_UWORD 
26da						DMARK ":0+" 
26da f5				push af  
26db 3a ef 26			ld a, (.dmark)  
26de 32 b4 fe			ld (debug_mark),a  
26e1 3a f0 26			ld a, (.dmark+1)  
26e4 32 b5 fe			ld (debug_mark+1),a  
26e7 3a f1 26			ld a, (.dmark+2)  
26ea 32 b6 fe			ld (debug_mark+2),a  
26ed 18 03			jr .pastdmark  
26ef ..			.dmark: db ":0+"  
26f2 f1			.pastdmark: pop af  
26f3			endm  
# End of macro DMARK
26f3				CALLMONITOR 
26f3 cd c6 18			call break_point_state  
26f6				endm  
# End of macro CALLMONITOR
26f6			endif 
26f6			 
26f6				STACKFRAMECHK OFF $8efe $989f 
26f6				if DEBUG_STACK_IMB 
26f6					if OFF 
26f6						exx 
26f6						ld hl, $989f 
26f6						pop de   ; $989f 
26f6						call cmp16 
26f6						jr nz, .spnosame 
26f6						ld hl, $8efe 
26f6						pop de   ; $8efe 
26f6						call cmp16 
26f6						jr z, .spfrsame 
26f6						.spnosame: call showsperror 
26f6						.spfrsame: nop 
26f6						exx 
26f6					endif 
26f6				endif 
26f6			endm 
# End of macro STACKFRAMECHK
26f6			 
26f6 c9			ret    ; dont process any remaining parser tokens as they form new word 
26f7			 
26f7			 
26f7			 
26f7			 
26f7			;		NEXT 
26f7			.SCOLN: 
26f7			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
26f7 06				db OPCODE_SCOLN 
26f8 43 27			dw .DROP 
26fa 02				db 2 
26fb .. 00			db ";",0           
26fd			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
26fd					if DEBUG_FORTH_WORDS_KEY 
26fd						DMARK "SCN" 
26fd f5				push af  
26fe 3a 12 27			ld a, (.dmark)  
2701 32 b4 fe			ld (debug_mark),a  
2704 3a 13 27			ld a, (.dmark+1)  
2707 32 b5 fe			ld (debug_mark+1),a  
270a 3a 14 27			ld a, (.dmark+2)  
270d 32 b6 fe			ld (debug_mark+2),a  
2710 18 03			jr .pastdmark  
2712 ..			.dmark: db "SCN"  
2715 f1			.pastdmark: pop af  
2716			endm  
# End of macro DMARK
2716						CALLMONITOR 
2716 cd c6 18			call break_point_state  
2719				endm  
# End of macro CALLMONITOR
2719					endif 
2719					FORTH_RSP_TOS 
2719 cd f8 1e			call macro_forth_rsp_tos 
271c				endm 
# End of macro FORTH_RSP_TOS
271c e5					push hl 
271d					FORTH_RSP_POP 
271d cd 02 1f			call macro_forth_rsp_pop 
2720				endm 
# End of macro FORTH_RSP_POP
2720 e1					pop hl 
2721			;		ex de,hl 
2721 22 4f f6				ld (os_tok_ptr),hl 
2724			 
2724			if DEBUG_FORTH_UWORD 
2724						DMARK "SCL" 
2724 f5				push af  
2725 3a 39 27			ld a, (.dmark)  
2728 32 b4 fe			ld (debug_mark),a  
272b 3a 3a 27			ld a, (.dmark+1)  
272e 32 b5 fe			ld (debug_mark+1),a  
2731 3a 3b 27			ld a, (.dmark+2)  
2734 32 b6 fe			ld (debug_mark+2),a  
2737 18 03			jr .pastdmark  
2739 ..			.dmark: db "SCL"  
273c f1			.pastdmark: pop af  
273d			endm  
# End of macro DMARK
273d				CALLMONITOR 
273d cd c6 18			call break_point_state  
2740				endm  
# End of macro CALLMONITOR
2740			endif 
2740					NEXTW 
2740 c3 e7 22			jp macro_next 
2743				endm 
# End of macro NEXTW
2743			 
2743			.DROP: 
2743				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2743 1b				db WORD_SYS_CORE+OPCODE_DROP             
2744 6e 27			dw .DUP2            
2746 05				db 4 + 1 
2747 .. 00			db "DROP",0              
274c				endm 
# End of macro CWHEAD
274c			; | DROP ( w -- )   drop the TOS item   | DONE 
274c					if DEBUG_FORTH_WORDS_KEY 
274c						DMARK "DRP" 
274c f5				push af  
274d 3a 61 27			ld a, (.dmark)  
2750 32 b4 fe			ld (debug_mark),a  
2753 3a 62 27			ld a, (.dmark+1)  
2756 32 b5 fe			ld (debug_mark+1),a  
2759 3a 63 27			ld a, (.dmark+2)  
275c 32 b6 fe			ld (debug_mark+2),a  
275f 18 03			jr .pastdmark  
2761 ..			.dmark: db "DRP"  
2764 f1			.pastdmark: pop af  
2765			endm  
# End of macro DMARK
2765						CALLMONITOR 
2765 cd c6 18			call break_point_state  
2768				endm  
# End of macro CALLMONITOR
2768					endif 
2768					FORTH_DSP_POP 
2768 cd e9 21			call macro_forth_dsp_pop 
276b				endm 
# End of macro FORTH_DSP_POP
276b					NEXTW 
276b c3 e7 22			jp macro_next 
276e				endm 
# End of macro NEXTW
276e			.DUP2: 
276e				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
276e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
276f b3 27			dw .DROP2            
2771 05				db 4 + 1 
2772 .. 00			db "2DUP",0              
2777				endm 
# End of macro CWHEAD
2777			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2777					if DEBUG_FORTH_WORDS_KEY 
2777						DMARK "2DU" 
2777 f5				push af  
2778 3a 8c 27			ld a, (.dmark)  
277b 32 b4 fe			ld (debug_mark),a  
277e 3a 8d 27			ld a, (.dmark+1)  
2781 32 b5 fe			ld (debug_mark+1),a  
2784 3a 8e 27			ld a, (.dmark+2)  
2787 32 b6 fe			ld (debug_mark+2),a  
278a 18 03			jr .pastdmark  
278c ..			.dmark: db "2DU"  
278f f1			.pastdmark: pop af  
2790			endm  
# End of macro DMARK
2790						CALLMONITOR 
2790 cd c6 18			call break_point_state  
2793				endm  
# End of macro CALLMONITOR
2793					endif 
2793					FORTH_DSP_VALUEHL 
2793 cd 31 21			call macro_dsp_valuehl 
2796				endm 
# End of macro FORTH_DSP_VALUEHL
2796 e5					push hl      ; 2 
2797			 
2797					FORTH_DSP_POP 
2797 cd e9 21			call macro_forth_dsp_pop 
279a				endm 
# End of macro FORTH_DSP_POP
279a					 
279a					FORTH_DSP_VALUEHL 
279a cd 31 21			call macro_dsp_valuehl 
279d				endm 
# End of macro FORTH_DSP_VALUEHL
279d			;		push hl      ; 1 
279d			 
279d					FORTH_DSP_POP 
279d cd e9 21			call macro_forth_dsp_pop 
27a0				endm 
# End of macro FORTH_DSP_POP
27a0			 
27a0			;		pop hl       ; 1 
27a0 d1					pop de       ; 2 
27a1			 
27a1 cd 3a 1f				call forth_push_numhl 
27a4 eb					ex de, hl 
27a5 cd 3a 1f				call forth_push_numhl 
27a8			 
27a8					 
27a8 eb					ex de, hl 
27a9			 
27a9 cd 3a 1f				call forth_push_numhl 
27ac eb					ex de, hl 
27ad cd 3a 1f				call forth_push_numhl 
27b0			 
27b0			 
27b0					NEXTW 
27b0 c3 e7 22			jp macro_next 
27b3				endm 
# End of macro NEXTW
27b3			.DROP2: 
27b3				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
27b3 1d				db WORD_SYS_CORE+OPCODE_DROP2             
27b4 e2 27			dw .SWAP2            
27b6 06				db 5 + 1 
27b7 .. 00			db "2DROP",0              
27bd				endm 
# End of macro CWHEAD
27bd			; | 2DROP ( w w -- )    Double drop | DONE 
27bd					if DEBUG_FORTH_WORDS_KEY 
27bd						DMARK "2DR" 
27bd f5				push af  
27be 3a d2 27			ld a, (.dmark)  
27c1 32 b4 fe			ld (debug_mark),a  
27c4 3a d3 27			ld a, (.dmark+1)  
27c7 32 b5 fe			ld (debug_mark+1),a  
27ca 3a d4 27			ld a, (.dmark+2)  
27cd 32 b6 fe			ld (debug_mark+2),a  
27d0 18 03			jr .pastdmark  
27d2 ..			.dmark: db "2DR"  
27d5 f1			.pastdmark: pop af  
27d6			endm  
# End of macro DMARK
27d6						CALLMONITOR 
27d6 cd c6 18			call break_point_state  
27d9				endm  
# End of macro CALLMONITOR
27d9					endif 
27d9					FORTH_DSP_POP 
27d9 cd e9 21			call macro_forth_dsp_pop 
27dc				endm 
# End of macro FORTH_DSP_POP
27dc					FORTH_DSP_POP 
27dc cd e9 21			call macro_forth_dsp_pop 
27df				endm 
# End of macro FORTH_DSP_POP
27df					NEXTW 
27df c3 e7 22			jp macro_next 
27e2				endm 
# End of macro NEXTW
27e2			.SWAP2: 
27e2				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
27e2 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
27e3 0b 28			dw .AT            
27e5 06				db 5 + 1 
27e6 .. 00			db "2SWAP",0              
27ec				endm 
# End of macro CWHEAD
27ec			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
27ec					if DEBUG_FORTH_WORDS_KEY 
27ec						DMARK "2SW" 
27ec f5				push af  
27ed 3a 01 28			ld a, (.dmark)  
27f0 32 b4 fe			ld (debug_mark),a  
27f3 3a 02 28			ld a, (.dmark+1)  
27f6 32 b5 fe			ld (debug_mark+1),a  
27f9 3a 03 28			ld a, (.dmark+2)  
27fc 32 b6 fe			ld (debug_mark+2),a  
27ff 18 03			jr .pastdmark  
2801 ..			.dmark: db "2SW"  
2804 f1			.pastdmark: pop af  
2805			endm  
# End of macro DMARK
2805						CALLMONITOR 
2805 cd c6 18			call break_point_state  
2808				endm  
# End of macro CALLMONITOR
2808					endif 
2808					NEXTW 
2808 c3 e7 22			jp macro_next 
280b				endm 
# End of macro NEXTW
280b			.AT: 
280b				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
280b 1f				db WORD_SYS_CORE+OPCODE_AT             
280c 3d 28			dw .CAT            
280e 02				db 1 + 1 
280f .. 00			db "@",0              
2811				endm 
# End of macro CWHEAD
2811			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2811			 
2811					if DEBUG_FORTH_WORDS_KEY 
2811						DMARK "AT." 
2811 f5				push af  
2812 3a 26 28			ld a, (.dmark)  
2815 32 b4 fe			ld (debug_mark),a  
2818 3a 27 28			ld a, (.dmark+1)  
281b 32 b5 fe			ld (debug_mark+1),a  
281e 3a 28 28			ld a, (.dmark+2)  
2821 32 b6 fe			ld (debug_mark+2),a  
2824 18 03			jr .pastdmark  
2826 ..			.dmark: db "AT."  
2829 f1			.pastdmark: pop af  
282a			endm  
# End of macro DMARK
282a						CALLMONITOR 
282a cd c6 18			call break_point_state  
282d				endm  
# End of macro CALLMONITOR
282d					endif 
282d			.getbyteat:	 
282d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
282d cd 31 21			call macro_dsp_valuehl 
2830				endm 
# End of macro FORTH_DSP_VALUEHL
2830					 
2830			;		push hl 
2830				 
2830					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2830 cd e9 21			call macro_forth_dsp_pop 
2833				endm 
# End of macro FORTH_DSP_POP
2833			 
2833			;		pop hl 
2833			 
2833 7e					ld a, (hl) 
2834			 
2834 6f					ld l, a 
2835 26 00				ld h, 0 
2837 cd 3a 1f				call forth_push_numhl 
283a			 
283a					NEXTW 
283a c3 e7 22			jp macro_next 
283d				endm 
# End of macro NEXTW
283d			.CAT: 
283d				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
283d 20				db WORD_SYS_CORE+OPCODE_CAT             
283e 66 28			dw .BANG            
2840 03				db 2 + 1 
2841 .. 00			db "C@",0              
2844				endm 
# End of macro CWHEAD
2844			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2844					if DEBUG_FORTH_WORDS_KEY 
2844						DMARK "CAA" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 b4 fe			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 b5 fe			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 b6 fe			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "CAA"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d						CALLMONITOR 
285d cd c6 18			call break_point_state  
2860				endm  
# End of macro CALLMONITOR
2860					endif 
2860 c3 2d 28				jp .getbyteat 
2863					NEXTW 
2863 c3 e7 22			jp macro_next 
2866				endm 
# End of macro NEXTW
2866			.BANG: 
2866				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2866 21				db WORD_SYS_CORE+OPCODE_BANG             
2867 9c 28			dw .CBANG            
2869 02				db 1 + 1 
286a .. 00			db "!",0              
286c				endm 
# End of macro CWHEAD
286c			; | ! ( x w -- ) Store x at address w      | DONE 
286c					if DEBUG_FORTH_WORDS_KEY 
286c						DMARK "BNG" 
286c f5				push af  
286d 3a 81 28			ld a, (.dmark)  
2870 32 b4 fe			ld (debug_mark),a  
2873 3a 82 28			ld a, (.dmark+1)  
2876 32 b5 fe			ld (debug_mark+1),a  
2879 3a 83 28			ld a, (.dmark+2)  
287c 32 b6 fe			ld (debug_mark+2),a  
287f 18 03			jr .pastdmark  
2881 ..			.dmark: db "BNG"  
2884 f1			.pastdmark: pop af  
2885			endm  
# End of macro DMARK
2885						CALLMONITOR 
2885 cd c6 18			call break_point_state  
2888				endm  
# End of macro CALLMONITOR
2888					endif 
2888			 
2888			.storebyteat:		 
2888					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2888 cd 31 21			call macro_dsp_valuehl 
288b				endm 
# End of macro FORTH_DSP_VALUEHL
288b					 
288b e5					push hl 
288c				 
288c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
288c cd e9 21			call macro_forth_dsp_pop 
288f				endm 
# End of macro FORTH_DSP_POP
288f			 
288f					; get byte to poke 
288f			 
288f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
288f cd 31 21			call macro_dsp_valuehl 
2892				endm 
# End of macro FORTH_DSP_VALUEHL
2892 e5					push hl 
2893			 
2893			 
2893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2893 cd e9 21			call macro_forth_dsp_pop 
2896				endm 
# End of macro FORTH_DSP_POP
2896			 
2896			 
2896 d1					pop de 
2897 e1					pop hl 
2898			 
2898 73					ld (hl),e 
2899			 
2899			 
2899					NEXTW 
2899 c3 e7 22			jp macro_next 
289c				endm 
# End of macro NEXTW
289c			.CBANG: 
289c				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
289c 22				db WORD_SYS_CORE+OPCODE_CBANG             
289d c5 28			dw .SCALL            
289f 03				db 2 + 1 
28a0 .. 00			db "C!",0              
28a3				endm 
# End of macro CWHEAD
28a3			; | C!  ( x w -- ) Store x at address w  | DONE 
28a3					if DEBUG_FORTH_WORDS_KEY 
28a3						DMARK "CBA" 
28a3 f5				push af  
28a4 3a b8 28			ld a, (.dmark)  
28a7 32 b4 fe			ld (debug_mark),a  
28aa 3a b9 28			ld a, (.dmark+1)  
28ad 32 b5 fe			ld (debug_mark+1),a  
28b0 3a ba 28			ld a, (.dmark+2)  
28b3 32 b6 fe			ld (debug_mark+2),a  
28b6 18 03			jr .pastdmark  
28b8 ..			.dmark: db "CBA"  
28bb f1			.pastdmark: pop af  
28bc			endm  
# End of macro DMARK
28bc						CALLMONITOR 
28bc cd c6 18			call break_point_state  
28bf				endm  
# End of macro CALLMONITOR
28bf					endif 
28bf c3 88 28				jp .storebyteat 
28c2					NEXTW 
28c2 c3 e7 22			jp macro_next 
28c5				endm 
# End of macro NEXTW
28c5			.SCALL: 
28c5				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
28c5 23				db WORD_SYS_CORE+OPCODE_SCALL             
28c6 f9 28			dw .DEPTH            
28c8 05				db 4 + 1 
28c9 .. 00			db "CALL",0              
28ce				endm 
# End of macro CWHEAD
28ce			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
28ce					if DEBUG_FORTH_WORDS_KEY 
28ce						DMARK "CLL" 
28ce f5				push af  
28cf 3a e3 28			ld a, (.dmark)  
28d2 32 b4 fe			ld (debug_mark),a  
28d5 3a e4 28			ld a, (.dmark+1)  
28d8 32 b5 fe			ld (debug_mark+1),a  
28db 3a e5 28			ld a, (.dmark+2)  
28de 32 b6 fe			ld (debug_mark+2),a  
28e1 18 03			jr .pastdmark  
28e3 ..			.dmark: db "CLL"  
28e6 f1			.pastdmark: pop af  
28e7			endm  
# End of macro DMARK
28e7						CALLMONITOR 
28e7 cd c6 18			call break_point_state  
28ea				endm  
# End of macro CALLMONITOR
28ea					endif 
28ea			 
28ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28ea cd 31 21			call macro_dsp_valuehl 
28ed				endm 
# End of macro FORTH_DSP_VALUEHL
28ed			 
28ed			;		push hl 
28ed			 
28ed					; destroy value TOS 
28ed			 
28ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28ed cd e9 21			call macro_forth_dsp_pop 
28f0				endm 
# End of macro FORTH_DSP_POP
28f0			 
28f0						 
28f0			;		pop hl 
28f0			 
28f0					; how to do a call with hl???? save SP? 
28f0 cd 8b 22				call forth_call_hl 
28f3			 
28f3			 
28f3					; TODO push value back onto stack for another op etc 
28f3			 
28f3 cd 3a 1f				call forth_push_numhl 
28f6					NEXTW 
28f6 c3 e7 22			jp macro_next 
28f9				endm 
# End of macro NEXTW
28f9			.DEPTH: 
28f9				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
28f9 24				db WORD_SYS_CORE+OPCODE_DEPTH             
28fa 36 29			dw .OVER            
28fc 06				db 5 + 1 
28fd .. 00			db "DEPTH",0              
2903				endm 
# End of macro CWHEAD
2903			; | DEPTH ( -- u ) Push count of stack | DONE 
2903					; take current TOS and remove from base value div by two to get count 
2903					if DEBUG_FORTH_WORDS_KEY 
2903						DMARK "DEP" 
2903 f5				push af  
2904 3a 18 29			ld a, (.dmark)  
2907 32 b4 fe			ld (debug_mark),a  
290a 3a 19 29			ld a, (.dmark+1)  
290d 32 b5 fe			ld (debug_mark+1),a  
2910 3a 1a 29			ld a, (.dmark+2)  
2913 32 b6 fe			ld (debug_mark+2),a  
2916 18 03			jr .pastdmark  
2918 ..			.dmark: db "DEP"  
291b f1			.pastdmark: pop af  
291c			endm  
# End of macro DMARK
291c						CALLMONITOR 
291c cd c6 18			call break_point_state  
291f				endm  
# End of macro CALLMONITOR
291f					endif 
291f			 
291f			 
291f 2a 7b fb			ld hl, (cli_data_sp) 
2922 11 b5 f8			ld de, cli_data_stack 
2925 ed 52			sbc hl,de 
2927				 
2927				; div by size of stack item 
2927			 
2927 5d				ld e,l 
2928 0e 03			ld c, 3 
292a cd d9 0e			call Div8 
292d			 
292d 6f				ld l,a 
292e 26 00			ld h,0 
2930			 
2930				;srl h 
2930				;rr l 
2930			 
2930 cd 3a 1f				call forth_push_numhl 
2933					NEXTW 
2933 c3 e7 22			jp macro_next 
2936				endm 
# End of macro NEXTW
2936			.OVER: 
2936				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2936 42				db WORD_SYS_CORE+46             
2937 7d 29			dw .PAUSE            
2939 05				db 4 + 1 
293a .. 00			db "OVER",0              
293f				endm 
# End of macro CWHEAD
293f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
293f					if DEBUG_FORTH_WORDS_KEY 
293f						DMARK "OVR" 
293f f5				push af  
2940 3a 54 29			ld a, (.dmark)  
2943 32 b4 fe			ld (debug_mark),a  
2946 3a 55 29			ld a, (.dmark+1)  
2949 32 b5 fe			ld (debug_mark+1),a  
294c 3a 56 29			ld a, (.dmark+2)  
294f 32 b6 fe			ld (debug_mark+2),a  
2952 18 03			jr .pastdmark  
2954 ..			.dmark: db "OVR"  
2957 f1			.pastdmark: pop af  
2958			endm  
# End of macro DMARK
2958						CALLMONITOR 
2958 cd c6 18			call break_point_state  
295b				endm  
# End of macro CALLMONITOR
295b					endif 
295b			 
295b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
295b cd 31 21			call macro_dsp_valuehl 
295e				endm 
# End of macro FORTH_DSP_VALUEHL
295e e5					push hl    ; n2 
295f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
295f cd e9 21			call macro_forth_dsp_pop 
2962				endm 
# End of macro FORTH_DSP_POP
2962			 
2962					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2962 cd 31 21			call macro_dsp_valuehl 
2965				endm 
# End of macro FORTH_DSP_VALUEHL
2965 e5					push hl    ; n1 
2966					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2966 cd e9 21			call macro_forth_dsp_pop 
2969				endm 
# End of macro FORTH_DSP_POP
2969			 
2969 d1					pop de     ; n1 
296a e1					pop hl     ; n2 
296b			 
296b d5					push de 
296c e5					push hl 
296d d5					push de 
296e			 
296e					; push back  
296e			 
296e e1					pop hl 
296f cd 3a 1f				call forth_push_numhl 
2972 e1					pop hl 
2973 cd 3a 1f				call forth_push_numhl 
2976 e1					pop hl 
2977 cd 3a 1f				call forth_push_numhl 
297a					NEXTW 
297a c3 e7 22			jp macro_next 
297d				endm 
# End of macro NEXTW
297d			 
297d			.PAUSE: 
297d				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
297d 43				db WORD_SYS_CORE+47             
297e b2 29			dw .PAUSES            
2980 08				db 7 + 1 
2981 .. 00			db "PAUSEMS",0              
2989				endm 
# End of macro CWHEAD
2989			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2989					if DEBUG_FORTH_WORDS_KEY 
2989						DMARK "PMS" 
2989 f5				push af  
298a 3a 9e 29			ld a, (.dmark)  
298d 32 b4 fe			ld (debug_mark),a  
2990 3a 9f 29			ld a, (.dmark+1)  
2993 32 b5 fe			ld (debug_mark+1),a  
2996 3a a0 29			ld a, (.dmark+2)  
2999 32 b6 fe			ld (debug_mark+2),a  
299c 18 03			jr .pastdmark  
299e ..			.dmark: db "PMS"  
29a1 f1			.pastdmark: pop af  
29a2			endm  
# End of macro DMARK
29a2						CALLMONITOR 
29a2 cd c6 18			call break_point_state  
29a5				endm  
# End of macro CALLMONITOR
29a5					endif 
29a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29a5 cd 31 21			call macro_dsp_valuehl 
29a8				endm 
# End of macro FORTH_DSP_VALUEHL
29a8			;		push hl    ; n2 
29a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29a8 cd e9 21			call macro_forth_dsp_pop 
29ab				endm 
# End of macro FORTH_DSP_POP
29ab			;		pop hl 
29ab			 
29ab 7d					ld a, l 
29ac cd 77 0c				call aDelayInMS 
29af				       NEXTW 
29af c3 e7 22			jp macro_next 
29b2				endm 
# End of macro NEXTW
29b2			.PAUSES:  
29b2				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
29b2 44				db WORD_SYS_CORE+48             
29b3 21 2a			dw .ROT            
29b5 06				db 5 + 1 
29b6 .. 00			db "PAUSE",0              
29bc				endm 
# End of macro CWHEAD
29bc			; | PAUSE ( n -- )  Pause for n seconds | DONE 
29bc					if DEBUG_FORTH_WORDS_KEY 
29bc						DMARK "PAU" 
29bc f5				push af  
29bd 3a d1 29			ld a, (.dmark)  
29c0 32 b4 fe			ld (debug_mark),a  
29c3 3a d2 29			ld a, (.dmark+1)  
29c6 32 b5 fe			ld (debug_mark+1),a  
29c9 3a d3 29			ld a, (.dmark+2)  
29cc 32 b6 fe			ld (debug_mark+2),a  
29cf 18 03			jr .pastdmark  
29d1 ..			.dmark: db "PAU"  
29d4 f1			.pastdmark: pop af  
29d5			endm  
# End of macro DMARK
29d5						CALLMONITOR 
29d5 cd c6 18			call break_point_state  
29d8				endm  
# End of macro CALLMONITOR
29d8					endif 
29d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d8 cd 31 21			call macro_dsp_valuehl 
29db				endm 
# End of macro FORTH_DSP_VALUEHL
29db			;		push hl    ; n2 
29db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29db cd e9 21			call macro_forth_dsp_pop 
29de				endm 
# End of macro FORTH_DSP_POP
29de			;		pop hl 
29de 45					ld b, l 
29df					if DEBUG_FORTH_WORDS 
29df						DMARK "PAU" 
29df f5				push af  
29e0 3a f4 29			ld a, (.dmark)  
29e3 32 b4 fe			ld (debug_mark),a  
29e6 3a f5 29			ld a, (.dmark+1)  
29e9 32 b5 fe			ld (debug_mark+1),a  
29ec 3a f6 29			ld a, (.dmark+2)  
29ef 32 b6 fe			ld (debug_mark+2),a  
29f2 18 03			jr .pastdmark  
29f4 ..			.dmark: db "PAU"  
29f7 f1			.pastdmark: pop af  
29f8			endm  
# End of macro DMARK
29f8						CALLMONITOR 
29f8 cd c6 18			call break_point_state  
29fb				endm  
# End of macro CALLMONITOR
29fb					endif 
29fb c5			.pauses1:	push bc 
29fc cd 92 0c				call delay1s 
29ff c1					pop bc 
2a00					if DEBUG_FORTH_WORDS 
2a00						DMARK "PA1" 
2a00 f5				push af  
2a01 3a 15 2a			ld a, (.dmark)  
2a04 32 b4 fe			ld (debug_mark),a  
2a07 3a 16 2a			ld a, (.dmark+1)  
2a0a 32 b5 fe			ld (debug_mark+1),a  
2a0d 3a 17 2a			ld a, (.dmark+2)  
2a10 32 b6 fe			ld (debug_mark+2),a  
2a13 18 03			jr .pastdmark  
2a15 ..			.dmark: db "PA1"  
2a18 f1			.pastdmark: pop af  
2a19			endm  
# End of macro DMARK
2a19						CALLMONITOR 
2a19 cd c6 18			call break_point_state  
2a1c				endm  
# End of macro CALLMONITOR
2a1c					endif 
2a1c 10 dd				djnz .pauses1 
2a1e			 
2a1e				       NEXTW 
2a1e c3 e7 22			jp macro_next 
2a21				endm 
# End of macro NEXTW
2a21			.ROT: 
2a21				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2a21 45				db WORD_SYS_CORE+49             
2a22 6f 2a			dw .UWORDS            
2a24 04				db 3 + 1 
2a25 .. 00			db "ROT",0              
2a29				endm 
# End of macro CWHEAD
2a29			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2a29					if DEBUG_FORTH_WORDS_KEY 
2a29						DMARK "ROT" 
2a29 f5				push af  
2a2a 3a 3e 2a			ld a, (.dmark)  
2a2d 32 b4 fe			ld (debug_mark),a  
2a30 3a 3f 2a			ld a, (.dmark+1)  
2a33 32 b5 fe			ld (debug_mark+1),a  
2a36 3a 40 2a			ld a, (.dmark+2)  
2a39 32 b6 fe			ld (debug_mark+2),a  
2a3c 18 03			jr .pastdmark  
2a3e ..			.dmark: db "ROT"  
2a41 f1			.pastdmark: pop af  
2a42			endm  
# End of macro DMARK
2a42						CALLMONITOR 
2a42 cd c6 18			call break_point_state  
2a45				endm  
# End of macro CALLMONITOR
2a45					endif 
2a45			 
2a45					FORTH_DSP_VALUEHL 
2a45 cd 31 21			call macro_dsp_valuehl 
2a48				endm 
# End of macro FORTH_DSP_VALUEHL
2a48 e5					push hl    ; u3  
2a49			 
2a49					FORTH_DSP_POP 
2a49 cd e9 21			call macro_forth_dsp_pop 
2a4c				endm 
# End of macro FORTH_DSP_POP
2a4c			   
2a4c					FORTH_DSP_VALUEHL 
2a4c cd 31 21			call macro_dsp_valuehl 
2a4f				endm 
# End of macro FORTH_DSP_VALUEHL
2a4f e5					push hl     ; u2 
2a50			 
2a50					FORTH_DSP_POP 
2a50 cd e9 21			call macro_forth_dsp_pop 
2a53				endm 
# End of macro FORTH_DSP_POP
2a53			 
2a53					FORTH_DSP_VALUEHL 
2a53 cd 31 21			call macro_dsp_valuehl 
2a56				endm 
# End of macro FORTH_DSP_VALUEHL
2a56 e5					push hl     ; u1 
2a57			 
2a57					FORTH_DSP_POP 
2a57 cd e9 21			call macro_forth_dsp_pop 
2a5a				endm 
# End of macro FORTH_DSP_POP
2a5a			 
2a5a c1					pop bc      ; u1 
2a5b e1					pop hl      ; u2 
2a5c d1					pop de      ; u3 
2a5d			 
2a5d			 
2a5d c5					push bc 
2a5e d5					push de 
2a5f e5					push hl 
2a60			 
2a60			 
2a60 e1					pop hl 
2a61 cd 3a 1f				call forth_push_numhl 
2a64			 
2a64 e1					pop hl 
2a65 cd 3a 1f				call forth_push_numhl 
2a68			 
2a68 e1					pop hl 
2a69 cd 3a 1f				call forth_push_numhl 
2a6c					 
2a6c			 
2a6c			 
2a6c			 
2a6c			 
2a6c			 
2a6c				       NEXTW 
2a6c c3 e7 22			jp macro_next 
2a6f				endm 
# End of macro NEXTW
2a6f			 
2a6f			.UWORDS: 
2a6f				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a6f 50				db WORD_SYS_CORE+60             
2a70 31 2b			dw .BP            
2a72 07				db 6 + 1 
2a73 .. 00			db "UWORDS",0              
2a7a				endm 
# End of macro CWHEAD
2a7a			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2a7a			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2a7a			; | | Following the count are the individual words. 
2a7a			; | | 
2a7a			; | | e.g. UWORDS 
2a7a			; | | BOX DIRLIST 2 
2a7a			; | |  
2a7a			; | | Can be used to save the words to storage via: 
2a7a			; | | UWORDS $01 DO $01 APPEND LOOP 
2a7a				if DEBUG_FORTH_WORDS_KEY 
2a7a					DMARK "UWR" 
2a7a f5				push af  
2a7b 3a 8f 2a			ld a, (.dmark)  
2a7e 32 b4 fe			ld (debug_mark),a  
2a81 3a 90 2a			ld a, (.dmark+1)  
2a84 32 b5 fe			ld (debug_mark+1),a  
2a87 3a 91 2a			ld a, (.dmark+2)  
2a8a 32 b6 fe			ld (debug_mark+2),a  
2a8d 18 03			jr .pastdmark  
2a8f ..			.dmark: db "UWR"  
2a92 f1			.pastdmark: pop af  
2a93			endm  
# End of macro DMARK
2a93					CALLMONITOR 
2a93 cd c6 18			call break_point_state  
2a96				endm  
# End of macro CALLMONITOR
2a96				endif 
2a96 21 00 80				ld hl, baseram 
2a99					;ld hl, baseusermem 
2a99 01 00 00				ld bc, 0    ; start a counter 
2a9c			 
2a9c				; skip dict stub 
2a9c			 
2a9c cd 38 24				call forth_tok_next 
2a9f			 
2a9f			 
2a9f			; while we have words to look for 
2a9f			 
2a9f 7e			.douscan:	ld a, (hl)      
2aa0				if DEBUG_FORTH_WORDS 
2aa0					DMARK "UWs" 
2aa0 f5				push af  
2aa1 3a b5 2a			ld a, (.dmark)  
2aa4 32 b4 fe			ld (debug_mark),a  
2aa7 3a b6 2a			ld a, (.dmark+1)  
2aaa 32 b5 fe			ld (debug_mark+1),a  
2aad 3a b7 2a			ld a, (.dmark+2)  
2ab0 32 b6 fe			ld (debug_mark+2),a  
2ab3 18 03			jr .pastdmark  
2ab5 ..			.dmark: db "UWs"  
2ab8 f1			.pastdmark: pop af  
2ab9			endm  
# End of macro DMARK
2ab9					CALLMONITOR 
2ab9 cd c6 18			call break_point_state  
2abc				endm  
# End of macro CALLMONITOR
2abc				endif 
2abc fe 00				cp WORD_SYS_END 
2abe 28 4d				jr z, .udone 
2ac0 fe 01				cp WORD_SYS_UWORD 
2ac2 20 44				jr nz, .nuword 
2ac4			 
2ac4				if DEBUG_FORTH_WORDS 
2ac4					DMARK "UWu" 
2ac4 f5				push af  
2ac5 3a d9 2a			ld a, (.dmark)  
2ac8 32 b4 fe			ld (debug_mark),a  
2acb 3a da 2a			ld a, (.dmark+1)  
2ace 32 b5 fe			ld (debug_mark+1),a  
2ad1 3a db 2a			ld a, (.dmark+2)  
2ad4 32 b6 fe			ld (debug_mark+2),a  
2ad7 18 03			jr .pastdmark  
2ad9 ..			.dmark: db "UWu"  
2adc f1			.pastdmark: pop af  
2add			endm  
# End of macro DMARK
2add					CALLMONITOR 
2add cd c6 18			call break_point_state  
2ae0				endm  
# End of macro CALLMONITOR
2ae0				endif 
2ae0					; we have a uword so push its name to the stack 
2ae0			 
2ae0 e5				   	push hl  ; save so we can move to next dict block 
2ae1			 
2ae1					; skip opcode 
2ae1 23					inc hl  
2ae2					; skip next ptr 
2ae2 23					inc hl  
2ae3 23					inc hl 
2ae4					; skip len 
2ae4 23					inc hl 
2ae5				if DEBUG_FORTH_WORDS 
2ae5					DMARK "UWt" 
2ae5 f5				push af  
2ae6 3a fa 2a			ld a, (.dmark)  
2ae9 32 b4 fe			ld (debug_mark),a  
2aec 3a fb 2a			ld a, (.dmark+1)  
2aef 32 b5 fe			ld (debug_mark+1),a  
2af2 3a fc 2a			ld a, (.dmark+2)  
2af5 32 b6 fe			ld (debug_mark+2),a  
2af8 18 03			jr .pastdmark  
2afa ..			.dmark: db "UWt"  
2afd f1			.pastdmark: pop af  
2afe			endm  
# End of macro DMARK
2afe					CALLMONITOR 
2afe cd c6 18			call break_point_state  
2b01				endm  
# End of macro CALLMONITOR
2b01				endif 
2b01 03					inc bc 
2b02			 
2b02 c5					push bc 
2b03 cd a8 1f				call forth_push_str 
2b06 c1					pop bc 
2b07			 
2b07 e1					pop hl 	 
2b08			 
2b08 cd 38 24		.nuword:	call forth_tok_next 
2b0b 18 92				jr .douscan  
2b0d			 
2b0d			.udone:		 ; push count of uwords found 
2b0d c5					push bc 
2b0e e1					pop hl 
2b0f			 
2b0f				if DEBUG_FORTH_WORDS 
2b0f					DMARK "UWc" 
2b0f f5				push af  
2b10 3a 24 2b			ld a, (.dmark)  
2b13 32 b4 fe			ld (debug_mark),a  
2b16 3a 25 2b			ld a, (.dmark+1)  
2b19 32 b5 fe			ld (debug_mark+1),a  
2b1c 3a 26 2b			ld a, (.dmark+2)  
2b1f 32 b6 fe			ld (debug_mark+2),a  
2b22 18 03			jr .pastdmark  
2b24 ..			.dmark: db "UWc"  
2b27 f1			.pastdmark: pop af  
2b28			endm  
# End of macro DMARK
2b28					CALLMONITOR 
2b28 cd c6 18			call break_point_state  
2b2b				endm  
# End of macro CALLMONITOR
2b2b				endif 
2b2b cd 3a 1f				call forth_push_numhl 
2b2e			 
2b2e			 
2b2e				       NEXTW 
2b2e c3 e7 22			jp macro_next 
2b31				endm 
# End of macro NEXTW
2b31			 
2b31			.BP: 
2b31				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2b31 54				db WORD_SYS_CORE+64             
2b32 67 2b			dw .MONITOR            
2b34 03				db 2 + 1 
2b35 .. 00			db "BP",0              
2b38				endm 
# End of macro CWHEAD
2b38			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2b38			; | | $00 Will enable the break points within specific code paths 
2b38			; | | $01 Will disable break points 
2b38			; | |  
2b38			; | | By default break points are off. Either the above can be used to enable them 
2b38			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2b38			; | | and on release of the pressed key a message will be disaplayed to notify 
2b38			; | | that break points are enabled. Pressing any key will then continue boot process. 
2b38					; get byte count 
2b38					if DEBUG_FORTH_WORDS_KEY 
2b38						DMARK "BP." 
2b38 f5				push af  
2b39 3a 4d 2b			ld a, (.dmark)  
2b3c 32 b4 fe			ld (debug_mark),a  
2b3f 3a 4e 2b			ld a, (.dmark+1)  
2b42 32 b5 fe			ld (debug_mark+1),a  
2b45 3a 4f 2b			ld a, (.dmark+2)  
2b48 32 b6 fe			ld (debug_mark+2),a  
2b4b 18 03			jr .pastdmark  
2b4d ..			.dmark: db "BP."  
2b50 f1			.pastdmark: pop af  
2b51			endm  
# End of macro DMARK
2b51						CALLMONITOR 
2b51 cd c6 18			call break_point_state  
2b54				endm  
# End of macro CALLMONITOR
2b54					endif 
2b54			 
2b54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b54 cd 31 21			call macro_dsp_valuehl 
2b57				endm 
# End of macro FORTH_DSP_VALUEHL
2b57			 
2b57			;		push hl 
2b57			 
2b57					; destroy value TOS 
2b57			 
2b57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b57 cd e9 21			call macro_forth_dsp_pop 
2b5a				endm 
# End of macro FORTH_DSP_POP
2b5a			 
2b5a			;		pop hl 
2b5a			 
2b5a 3e 00				ld a,0 
2b5c bd					cp l 
2b5d 28 02				jr z, .bpset 
2b5f 3e 2a				ld a, '*' 
2b61			 
2b61 32 3f f3		.bpset:		ld (os_view_disable), a 
2b64			 
2b64			 
2b64					NEXTW 
2b64 c3 e7 22			jp macro_next 
2b67				endm 
# End of macro NEXTW
2b67			 
2b67			 
2b67			.MONITOR: 
2b67				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b67 55				db WORD_SYS_CORE+65             
2b68 9a 2b			dw .MALLOC            
2b6a 08				db 7 + 1 
2b6b .. 00			db "MONITOR",0              
2b73				endm 
# End of macro CWHEAD
2b73			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b73			; | | At start the current various registers will be displayed with contents. 
2b73			; | | Top right corner will show the most recent debug marker seen. 
2b73			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b73			; | | and the return stack pointer (RSP). 
2b73			; | | Pressing: 
2b73			; | |    1 - Initial screen 
2b73			; | |    2 - Display a data dump of HL 
2b73			; | |    3 - Display a data dump of DE 
2b73			; | |    4 - Display a data dump of BC 
2b73			; | |    5 - Display a data dump of HL 
2b73			; | |    6 - Display a data dump of DSP 
2b73			; | |    7 - Display a data dump of RSP 
2b73			; | |    8 - Display a data dump of what is at DSP 
2b73			; | |    9 - Display a data dump of what is at RSP 
2b73			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b73			; | |    * - Disable break points 
2b73			; | |    # - Enter traditional monitor mode 
2b73			; | | 
2b73			; | | Monitor Mode 
2b73			; | | ------------ 
2b73			; | | A prompt of '>' will be shown for various commands: 
2b73			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b73			; | |    C - Continue display a data dump from the last set address 
2b73			; | |    M xxxx - Set start of memory edit at address xx 
2b73			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b73			; | |    Q - Return to previous 
2b73					if DEBUG_FORTH_WORDS_KEY 
2b73						DMARK "MON" 
2b73 f5				push af  
2b74 3a 88 2b			ld a, (.dmark)  
2b77 32 b4 fe			ld (debug_mark),a  
2b7a 3a 89 2b			ld a, (.dmark+1)  
2b7d 32 b5 fe			ld (debug_mark+1),a  
2b80 3a 8a 2b			ld a, (.dmark+2)  
2b83 32 b6 fe			ld (debug_mark+2),a  
2b86 18 03			jr .pastdmark  
2b88 ..			.dmark: db "MON"  
2b8b f1			.pastdmark: pop af  
2b8c			endm  
# End of macro DMARK
2b8c						CALLMONITOR 
2b8c cd c6 18			call break_point_state  
2b8f				endm  
# End of macro CALLMONITOR
2b8f					endif 
2b8f 3e 00				ld a, 0 
2b91 32 3f f3				ld (os_view_disable), a 
2b94			 
2b94					CALLMONITOR 
2b94 cd c6 18			call break_point_state  
2b97				endm  
# End of macro CALLMONITOR
2b97			 
2b97			;	call monitor 
2b97			 
2b97					NEXTW 
2b97 c3 e7 22			jp macro_next 
2b9a				endm 
# End of macro NEXTW
2b9a			 
2b9a			 
2b9a			.MALLOC: 
2b9a				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b9a 56				db WORD_SYS_CORE+66             
2b9b c3 2b			dw .MALLOC2            
2b9d 06				db 5 + 1 
2b9e .. 00			db "ALLOT",0              
2ba4				endm 
# End of macro CWHEAD
2ba4			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ba4					if DEBUG_FORTH_WORDS_KEY 
2ba4						DMARK "ALL" 
2ba4 f5				push af  
2ba5 3a b9 2b			ld a, (.dmark)  
2ba8 32 b4 fe			ld (debug_mark),a  
2bab 3a ba 2b			ld a, (.dmark+1)  
2bae 32 b5 fe			ld (debug_mark+1),a  
2bb1 3a bb 2b			ld a, (.dmark+2)  
2bb4 32 b6 fe			ld (debug_mark+2),a  
2bb7 18 03			jr .pastdmark  
2bb9 ..			.dmark: db "ALL"  
2bbc f1			.pastdmark: pop af  
2bbd			endm  
# End of macro DMARK
2bbd						CALLMONITOR 
2bbd cd c6 18			call break_point_state  
2bc0				endm  
# End of macro CALLMONITOR
2bc0					endif 
2bc0 c3 ea 2b				jp .mallocc 
2bc3			.MALLOC2: 
2bc3				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2bc3 56				db WORD_SYS_CORE+66             
2bc4 01 2c			dw .FREE            
2bc6 07				db 6 + 1 
2bc7 .. 00			db "MALLOC",0              
2bce				endm 
# End of macro CWHEAD
2bce			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bce					; get byte count 
2bce					if DEBUG_FORTH_WORDS_KEY 
2bce						DMARK "MAL" 
2bce f5				push af  
2bcf 3a e3 2b			ld a, (.dmark)  
2bd2 32 b4 fe			ld (debug_mark),a  
2bd5 3a e4 2b			ld a, (.dmark+1)  
2bd8 32 b5 fe			ld (debug_mark+1),a  
2bdb 3a e5 2b			ld a, (.dmark+2)  
2bde 32 b6 fe			ld (debug_mark+2),a  
2be1 18 03			jr .pastdmark  
2be3 ..			.dmark: db "MAL"  
2be6 f1			.pastdmark: pop af  
2be7			endm  
# End of macro DMARK
2be7						CALLMONITOR 
2be7 cd c6 18			call break_point_state  
2bea				endm  
# End of macro CALLMONITOR
2bea					endif 
2bea			.mallocc: 
2bea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bea cd 31 21			call macro_dsp_valuehl 
2bed				endm 
# End of macro FORTH_DSP_VALUEHL
2bed			 
2bed			;		push hl 
2bed			 
2bed					; destroy value TOS 
2bed			 
2bed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bed cd e9 21			call macro_forth_dsp_pop 
2bf0				endm 
# End of macro FORTH_DSP_POP
2bf0			 
2bf0			;		pop hl 
2bf0 cd 10 14				call malloc 
2bf3				if DEBUG_FORTH_MALLOC_GUARD 
2bf3 f5					push af 
2bf4 cd 72 0f				call ishlzero 
2bf7			;		ld a, l 
2bf7			;		add h 
2bf7			;		cp 0 
2bf7 f1					pop af 
2bf8					 
2bf8 cc 38 5a				call z,malloc_error 
2bfb				endif 
2bfb			 
2bfb cd 3a 1f				call forth_push_numhl 
2bfe					NEXTW 
2bfe c3 e7 22			jp macro_next 
2c01				endm 
# End of macro NEXTW
2c01			 
2c01			.FREE: 
2c01				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2c01 57				db WORD_SYS_CORE+67             
2c02 32 2c			dw .LIST            
2c04 05				db 4 + 1 
2c05 .. 00			db "FREE",0              
2c0a				endm 
# End of macro CWHEAD
2c0a			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2c0a					if DEBUG_FORTH_WORDS_KEY 
2c0a						DMARK "FRE" 
2c0a f5				push af  
2c0b 3a 1f 2c			ld a, (.dmark)  
2c0e 32 b4 fe			ld (debug_mark),a  
2c11 3a 20 2c			ld a, (.dmark+1)  
2c14 32 b5 fe			ld (debug_mark+1),a  
2c17 3a 21 2c			ld a, (.dmark+2)  
2c1a 32 b6 fe			ld (debug_mark+2),a  
2c1d 18 03			jr .pastdmark  
2c1f ..			.dmark: db "FRE"  
2c22 f1			.pastdmark: pop af  
2c23			endm  
# End of macro DMARK
2c23						CALLMONITOR 
2c23 cd c6 18			call break_point_state  
2c26				endm  
# End of macro CALLMONITOR
2c26					endif 
2c26					; get address 
2c26			 
2c26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c26 cd 31 21			call macro_dsp_valuehl 
2c29				endm 
# End of macro FORTH_DSP_VALUEHL
2c29			 
2c29			;		push hl 
2c29			 
2c29					; destroy value TOS 
2c29			 
2c29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c29 cd e9 21			call macro_forth_dsp_pop 
2c2c				endm 
# End of macro FORTH_DSP_POP
2c2c			 
2c2c			;		pop hl 
2c2c			if FORTH_ENABLE_MALLOCFREE 
2c2c cd da 14				call free 
2c2f			endif 
2c2f					NEXTW 
2c2f c3 e7 22			jp macro_next 
2c32				endm 
# End of macro NEXTW
2c32			.LIST: 
2c32				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2c32 5c				db WORD_SYS_CORE+72             
2c33 20 2e			dw .FORGET            
2c35 05				db 4 + 1 
2c36 .. 00			db "LIST",0              
2c3b				endm 
# End of macro CWHEAD
2c3b			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2c3b			; | | The quoted word must be in upper case. 
2c3b				if DEBUG_FORTH_WORDS_KEY 
2c3b					DMARK "LST" 
2c3b f5				push af  
2c3c 3a 50 2c			ld a, (.dmark)  
2c3f 32 b4 fe			ld (debug_mark),a  
2c42 3a 51 2c			ld a, (.dmark+1)  
2c45 32 b5 fe			ld (debug_mark+1),a  
2c48 3a 52 2c			ld a, (.dmark+2)  
2c4b 32 b6 fe			ld (debug_mark+2),a  
2c4e 18 03			jr .pastdmark  
2c50 ..			.dmark: db "LST"  
2c53 f1			.pastdmark: pop af  
2c54			endm  
# End of macro DMARK
2c54					CALLMONITOR 
2c54 cd c6 18			call break_point_state  
2c57				endm  
# End of macro CALLMONITOR
2c57				endif 
2c57			 
2c57					FORTH_DSP_VALUEHL 
2c57 cd 31 21			call macro_dsp_valuehl 
2c5a				endm 
# End of macro FORTH_DSP_VALUEHL
2c5a			 
2c5a e5					push hl 
2c5b					FORTH_DSP_POP 
2c5b cd e9 21			call macro_forth_dsp_pop 
2c5e				endm 
# End of macro FORTH_DSP_POP
2c5e c1					pop bc 
2c5f			 
2c5f			; Start format of scratch string 
2c5f			 
2c5f 21 4e f3				ld hl, scratch 
2c62			 
2c62 3e 3a				ld a, ':' 
2c64 77					ld (hl),a 
2c65 23					inc hl 
2c66 3e 20				ld a, ' ' 
2c68 77					ld (hl), a 
2c69			 
2c69					; Get ptr to the word we need to look up 
2c69			 
2c69			;		FORTH_DSP_VALUEHL 
2c69					;v5 FORTH_DSP_VALUE 
2c69				; TODO type check 
2c69			;		inc hl    ; Skip type check  
2c69			;		push hl 
2c69			;		ex de, hl    ; put into DE 
2c69			 
2c69			 
2c69 21 00 80				ld hl, baseram 
2c6c					;ld hl, baseusermem 
2c6c			 
2c6c e5			push hl   ; sacreifical push 
2c6d			 
2c6d			.ldouscanm: 
2c6d e1				pop hl 
2c6e			.ldouscan: 
2c6e				if DEBUG_FORTH_WORDS 
2c6e					DMARK "LSs" 
2c6e f5				push af  
2c6f 3a 83 2c			ld a, (.dmark)  
2c72 32 b4 fe			ld (debug_mark),a  
2c75 3a 84 2c			ld a, (.dmark+1)  
2c78 32 b5 fe			ld (debug_mark+1),a  
2c7b 3a 85 2c			ld a, (.dmark+2)  
2c7e 32 b6 fe			ld (debug_mark+2),a  
2c81 18 03			jr .pastdmark  
2c83 ..			.dmark: db "LSs"  
2c86 f1			.pastdmark: pop af  
2c87			endm  
# End of macro DMARK
2c87					CALLMONITOR 
2c87 cd c6 18			call break_point_state  
2c8a				endm  
# End of macro CALLMONITOR
2c8a				endif 
2c8a				; skip dict stub 
2c8a cd 38 24				call forth_tok_next 
2c8d			 
2c8d			 
2c8d			; while we have words to look for 
2c8d			 
2c8d 7e				ld a, (hl)      
2c8e				if DEBUG_FORTH_WORDS 
2c8e					DMARK "LSk" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 b4 fe			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 b5 fe			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 b6 fe			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "LSk"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7					CALLMONITOR 
2ca7 cd c6 18			call break_point_state  
2caa				endm  
# End of macro CALLMONITOR
2caa				endif 
2caa					;cp WORD_SYS_END 
2caa					;jp z, .lunotfound 
2caa			 
2caa					; if we hit non uwords then gone too far 
2caa fe 01				cp WORD_SYS_UWORD 
2cac c2 dc 2d				jp nz, .lunotfound 
2caf			 
2caf				if DEBUG_FORTH_WORDS 
2caf					DMARK "LSu" 
2caf f5				push af  
2cb0 3a c4 2c			ld a, (.dmark)  
2cb3 32 b4 fe			ld (debug_mark),a  
2cb6 3a c5 2c			ld a, (.dmark+1)  
2cb9 32 b5 fe			ld (debug_mark+1),a  
2cbc 3a c6 2c			ld a, (.dmark+2)  
2cbf 32 b6 fe			ld (debug_mark+2),a  
2cc2 18 03			jr .pastdmark  
2cc4 ..			.dmark: db "LSu"  
2cc7 f1			.pastdmark: pop af  
2cc8			endm  
# End of macro DMARK
2cc8					CALLMONITOR 
2cc8 cd c6 18			call break_point_state  
2ccb				endm  
# End of macro CALLMONITOR
2ccb				endif 
2ccb			 
2ccb					; found a uword but is it the one we want... 
2ccb			 
2ccb c5					push bc     ; uword to find is on bc 
2ccc d1					pop de 
2ccd			 
2ccd e5					push hl  ; to save the ptr 
2cce			 
2cce					; skip opcode 
2cce 23					inc hl  
2ccf					; skip next ptr 
2ccf 23					inc hl  
2cd0 23					inc hl 
2cd1					; skip len 
2cd1 23					inc hl 
2cd2			 
2cd2				if DEBUG_FORTH_WORDS 
2cd2					DMARK "LSc" 
2cd2 f5				push af  
2cd3 3a e7 2c			ld a, (.dmark)  
2cd6 32 b4 fe			ld (debug_mark),a  
2cd9 3a e8 2c			ld a, (.dmark+1)  
2cdc 32 b5 fe			ld (debug_mark+1),a  
2cdf 3a e9 2c			ld a, (.dmark+2)  
2ce2 32 b6 fe			ld (debug_mark+2),a  
2ce5 18 03			jr .pastdmark  
2ce7 ..			.dmark: db "LSc"  
2cea f1			.pastdmark: pop af  
2ceb			endm  
# End of macro DMARK
2ceb					CALLMONITOR 
2ceb cd c6 18			call break_point_state  
2cee				endm  
# End of macro CALLMONITOR
2cee				endif 
2cee cd df 13				call strcmp 
2cf1 c2 6d 2c				jp nz, .ldouscanm 
2cf4				 
2cf4			 
2cf4			 
2cf4					; we have a uword so push its name to the stack 
2cf4			 
2cf4			;	   	push hl  ; save so we can move to next dict block 
2cf4 e1			pop hl 
2cf5			 
2cf5				if DEBUG_FORTH_WORDS 
2cf5					DMARK "LSm" 
2cf5 f5				push af  
2cf6 3a 0a 2d			ld a, (.dmark)  
2cf9 32 b4 fe			ld (debug_mark),a  
2cfc 3a 0b 2d			ld a, (.dmark+1)  
2cff 32 b5 fe			ld (debug_mark+1),a  
2d02 3a 0c 2d			ld a, (.dmark+2)  
2d05 32 b6 fe			ld (debug_mark+2),a  
2d08 18 03			jr .pastdmark  
2d0a ..			.dmark: db "LSm"  
2d0d f1			.pastdmark: pop af  
2d0e			endm  
# End of macro DMARK
2d0e					CALLMONITOR 
2d0e cd c6 18			call break_point_state  
2d11				endm  
# End of macro CALLMONITOR
2d11				endif 
2d11			 
2d11					; skip opcode 
2d11 23					inc hl  
2d12					; skip next ptr 
2d12 23					inc hl  
2d13 23					inc hl 
2d14					; skip len 
2d14 7e					ld a, (hl)   ; save length to add 
2d15				if DEBUG_FORTH_WORDS 
2d15					DMARK "LS2" 
2d15 f5				push af  
2d16 3a 2a 2d			ld a, (.dmark)  
2d19 32 b4 fe			ld (debug_mark),a  
2d1c 3a 2b 2d			ld a, (.dmark+1)  
2d1f 32 b5 fe			ld (debug_mark+1),a  
2d22 3a 2c 2d			ld a, (.dmark+2)  
2d25 32 b6 fe			ld (debug_mark+2),a  
2d28 18 03			jr .pastdmark  
2d2a ..			.dmark: db "LS2"  
2d2d f1			.pastdmark: pop af  
2d2e			endm  
# End of macro DMARK
2d2e					CALLMONITOR 
2d2e cd c6 18			call break_point_state  
2d31				endm  
# End of macro CALLMONITOR
2d31				endif 
2d31			 
2d31					; save this location 
2d31				 
2d31 e5					push hl 
2d32			 
2d32 23					inc hl 
2d33 11 50 f3				ld de, scratch+2 
2d36 4f					ld c, a 
2d37 06 00				ld b, 0 
2d39			 
2d39				if DEBUG_FORTH_WORDS 
2d39					DMARK "LSn" 
2d39 f5				push af  
2d3a 3a 4e 2d			ld a, (.dmark)  
2d3d 32 b4 fe			ld (debug_mark),a  
2d40 3a 4f 2d			ld a, (.dmark+1)  
2d43 32 b5 fe			ld (debug_mark+1),a  
2d46 3a 50 2d			ld a, (.dmark+2)  
2d49 32 b6 fe			ld (debug_mark+2),a  
2d4c 18 03			jr .pastdmark  
2d4e ..			.dmark: db "LSn"  
2d51 f1			.pastdmark: pop af  
2d52			endm  
# End of macro DMARK
2d52					CALLMONITOR 
2d52 cd c6 18			call break_point_state  
2d55				endm  
# End of macro CALLMONITOR
2d55				endif 
2d55			 
2d55					; copy uword name to scratch 
2d55			 
2d55 ed b0				ldir 
2d57			 
2d57 1b					dec de 
2d58 3e 20				ld a, ' '    ; change null to space 
2d5a 12					ld (de), a 
2d5b			 
2d5b 13					inc de 
2d5c			 
2d5c d5					push de 
2d5d c1					pop bc     ; move scratch pointer to end of word name and save it 
2d5e			 
2d5e e1					pop hl 
2d5f 7e					ld a, (hl) 
2d60					;inc hl 
2d60					; skip word string 
2d60 cd 49 0f				call addatohl 
2d63			 
2d63 23					inc hl 
2d64			 
2d64				if DEBUG_FORTH_WORDS 
2d64					DMARK "LS3" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 b4 fe			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 b5 fe			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 b6 fe			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "LS3"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d					CALLMONITOR 
2d7d cd c6 18			call break_point_state  
2d80				endm  
# End of macro CALLMONITOR
2d80				endif 
2d80					; should now be at the start of the machine code to setup the eval of the uword 
2d80					; now locate the ptr to the string defintion 
2d80			 
2d80					; skip ld hl, 
2d80					; then load the ptr 
2d80			; TODO use get from hl ptr 
2d80 23					inc hl 
2d81 5e					ld e, (hl) 
2d82 23					inc hl 
2d83 56					ld d, (hl) 
2d84 eb					ex de, hl 
2d85			 
2d85			 
2d85				if DEBUG_FORTH_WORDS 
2d85					DMARK "LSt" 
2d85 f5				push af  
2d86 3a 9a 2d			ld a, (.dmark)  
2d89 32 b4 fe			ld (debug_mark),a  
2d8c 3a 9b 2d			ld a, (.dmark+1)  
2d8f 32 b5 fe			ld (debug_mark+1),a  
2d92 3a 9c 2d			ld a, (.dmark+2)  
2d95 32 b6 fe			ld (debug_mark+2),a  
2d98 18 03			jr .pastdmark  
2d9a ..			.dmark: db "LSt"  
2d9d f1			.pastdmark: pop af  
2d9e			endm  
# End of macro DMARK
2d9e					CALLMONITOR 
2d9e cd c6 18			call break_point_state  
2da1				endm  
# End of macro CALLMONITOR
2da1				endif 
2da1			 
2da1			; cant push right now due to tokenised strings  
2da1			 
2da1			; get the destination of where to copy this definition to. 
2da1			 
2da1 c5					push bc 
2da2 d1					pop de 
2da3			 
2da3 7e			.listl:         ld a,(hl) 
2da4 fe 00				cp 0 
2da6 28 09				jr z, .lreplsp     ; replace zero with space 
2da8					;cp FORTH_END_BUFFER 
2da8 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2daa 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2dac				 
2dac					; just copy this char as is then 
2dac			 
2dac 12					ld (de), a 
2dad			 
2dad 23			.listnxt:	inc hl 
2dae 13					inc de 
2daf 18 f2				jr .listl 
2db1			 
2db1 3e 20		.lreplsp:	ld a,' ' 
2db3 12					ld (de), a 
2db4 18 f7				jr .listnxt 
2db6			 
2db6			; close up uword def 
2db6			 
2db6			.listdone: 
2db6 12					ld (de), a 
2db7 13					inc de 
2db8 3e 00				ld a, 0 
2dba 12					ld (de), a 
2dbb			 
2dbb			; now have def so clean up and push to stack 
2dbb			 
2dbb 21 4e f3				ld hl, scratch 
2dbe				if DEBUG_FORTH_WORDS 
2dbe					DMARK "Ltp" 
2dbe f5				push af  
2dbf 3a d3 2d			ld a, (.dmark)  
2dc2 32 b4 fe			ld (debug_mark),a  
2dc5 3a d4 2d			ld a, (.dmark+1)  
2dc8 32 b5 fe			ld (debug_mark+1),a  
2dcb 3a d5 2d			ld a, (.dmark+2)  
2dce 32 b6 fe			ld (debug_mark+2),a  
2dd1 18 03			jr .pastdmark  
2dd3 ..			.dmark: db "Ltp"  
2dd6 f1			.pastdmark: pop af  
2dd7			endm  
# End of macro DMARK
2dd7					CALLMONITOR 
2dd7 cd c6 18			call break_point_state  
2dda				endm  
# End of macro CALLMONITOR
2dda				endif 
2dda			 
2dda 18 1f			jr .listpush 
2ddc			 
2ddc			;.lnuword:	pop hl 
2ddc			;		call forth_tok_next 
2ddc			;		jp .ldouscan  
2ddc			 
2ddc			.lunotfound:		  
2ddc			 
2ddc				if DEBUG_FORTH_WORDS 
2ddc					DMARK "LSn" 
2ddc f5				push af  
2ddd 3a f1 2d			ld a, (.dmark)  
2de0 32 b4 fe			ld (debug_mark),a  
2de3 3a f2 2d			ld a, (.dmark+1)  
2de6 32 b5 fe			ld (debug_mark+1),a  
2de9 3a f3 2d			ld a, (.dmark+2)  
2dec 32 b6 fe			ld (debug_mark+2),a  
2def 18 03			jr .pastdmark  
2df1 ..			.dmark: db "LSn"  
2df4 f1			.pastdmark: pop af  
2df5			endm  
# End of macro DMARK
2df5					CALLMONITOR 
2df5 cd c6 18			call break_point_state  
2df8				endm  
# End of macro CALLMONITOR
2df8				endif 
2df8			 
2df8					 
2df8			;		FORTH_DSP_POP 
2df8			;		ld hl, .luno 
2df8			 
2df8					NEXTW			 
2df8 c3 e7 22			jp macro_next 
2dfb				endm 
# End of macro NEXTW
2dfb			 
2dfb			.listpush: 
2dfb				if DEBUG_FORTH_WORDS 
2dfb					DMARK "LS>" 
2dfb f5				push af  
2dfc 3a 10 2e			ld a, (.dmark)  
2dff 32 b4 fe			ld (debug_mark),a  
2e02 3a 11 2e			ld a, (.dmark+1)  
2e05 32 b5 fe			ld (debug_mark+1),a  
2e08 3a 12 2e			ld a, (.dmark+2)  
2e0b 32 b6 fe			ld (debug_mark+2),a  
2e0e 18 03			jr .pastdmark  
2e10 ..			.dmark: db "LS>"  
2e13 f1			.pastdmark: pop af  
2e14			endm  
# End of macro DMARK
2e14					CALLMONITOR 
2e14 cd c6 18			call break_point_state  
2e17				endm  
# End of macro CALLMONITOR
2e17				endif 
2e17 cd a8 1f				call forth_push_str 
2e1a			 
2e1a			 
2e1a			 
2e1a					NEXTW 
2e1a c3 e7 22			jp macro_next 
2e1d				endm 
# End of macro NEXTW
2e1d			 
2e1d			;.luno:    db "Word not found",0 
2e1d			 
2e1d			 
2e1d			 
2e1d			 
2e1d			 
2e1d			;		push hl   ; save pointer to start of uword def string 
2e1d			; 
2e1d			;; look for FORTH_EOL_LINE 
2e1d			;		ld a, FORTH_END_BUFFER 
2e1d			;		call strlent 
2e1d			; 
2e1d			;		inc hl		 ; space for coln def 
2e1d			;		inc hl 
2e1d			;		inc hl          ; space for terms 
2e1d			;		inc hl 
2e1d			; 
2e1d			;		ld a, 20   ; TODO get actual length 
2e1d			;		call addatohl    ; include a random amount of room for the uword name 
2e1d			; 
2e1d			;		 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt1" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;		 
2e1d			; 
2e1d			;; malloc space for the string because we cant change it 
2e1d			; 
2e1d			;		call malloc 
2e1d			;	if DEBUG_FORTH_MALLOC_GUARD 
2e1d			;		push af 
2e1d			;		call ishlzero 
2e1d			;		pop af 
2e1d			;		 
2e1d			;		call z,malloc_error 
2e1d			;	endif 
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt2" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;		pop de 
2e1d			;		push hl    ; push the malloc to release later 
2e1d			;		push hl   ;  push back a copy for the later stack push 
2e1d			;		 
2e1d			;; copy the string swapping out the zero terms for spaces 
2e1d			; 
2e1d			;		; de has our source 
2e1d			;		; hl has our dest 
2e1d			; 
2e1d			;; add the coln def 
2e1d			; 
2e1d			;		ld a, ':' 
2e1d			;		ld (hl), a 
2e1d			;		inc hl 
2e1d			;		ld a, ' ' 
2e1d			;		ld (hl), a 
2e1d			;		inc hl 
2e1d			; 
2e1d			;; add the uname word 
2e1d			;		push de   ; save our string for now 
2e1d			;		ex de, hl 
2e1d			; 
2e1d			;		FORTH_DSP_VALUE 
2e1d			;		;v5 FORTH_DSP_VALUE 
2e1d			; 
2e1d			;		inc hl   ; skip type but we know by now this is OK 
2e1d			; 
2e1d			;.luword:	ld a,(hl) 
2e1d			;		cp 0 
2e1d			;		jr z, .luword2 
2e1d			;		ld (de), a 
2e1d			;		inc de 
2e1d			;		inc hl 
2e1d			;		jr .luword 
2e1d			; 
2e1d			;.luword2:	ld a, ' ' 
2e1d			;		ld (de), a 
2e1d			;;		inc hl 
2e1d			;;		inc de 
2e1d			;;		ld (de), a 
2e1d			;;		inc hl 
2e1d			;		inc de 
2e1d			; 
2e1d			;		ex de, hl 
2e1d			;		pop de 
2e1d			;		 
2e1d			;		 
2e1d			; 
2e1d			;; detoken that string and copy it 
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt2" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;.ldetok:	ld a, (de) 
2e1d			;		cp FORTH_END_BUFFER 
2e1d			;		jr z, .ldetokend 
2e1d			;		; swap out any zero term for space 
2e1d			;		cp 0 
2e1d			;		jr nz, .ldetoknext 
2e1d			;		ld a, ' ' 
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "LtS" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;.ldetoknext:	ld (hl), a 
2e1d			;		inc de 
2e1d			;		inc hl 
2e1d			;		jr .ldetok 
2e1d			; 
2e1d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2e1d			;		ld (hl), a  
2e1d			; 
2e1d			;; free that temp malloc 
2e1d			; 
2e1d			;		pop hl    
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt4" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;		call forth_apushstrhl 
2e1d			; 
2e1d			;		; get rid of temp malloc area 
2e1d			; 
2e1d			;		pop hl 
2e1d			;		call free 
2e1d			; 
2e1d			;		jr .ludone 
2e1d			; 
2e1d			;.lnuword:	pop hl 
2e1d			;		call forth_tok_next 
2e1d			;		jp .ldouscan  
2e1d			; 
2e1d			;.ludone:		 pop hl 
2e1d			; 
2e1d					NEXTW 
2e1d c3 e7 22			jp macro_next 
2e20				endm 
# End of macro NEXTW
2e20			 
2e20			.FORGET: 
2e20				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2e20 5d				db WORD_SYS_CORE+73             
2e21 99 2e			dw .NOP            
2e23 07				db 6 + 1 
2e24 .. 00			db "FORGET",0              
2e2b				endm 
# End of macro CWHEAD
2e2b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2e2b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2e2b			; | |  
2e2b			; | | e.g. "MORE" forget 
2e2b					if DEBUG_FORTH_WORDS_KEY 
2e2b						DMARK "FRG" 
2e2b f5				push af  
2e2c 3a 40 2e			ld a, (.dmark)  
2e2f 32 b4 fe			ld (debug_mark),a  
2e32 3a 41 2e			ld a, (.dmark+1)  
2e35 32 b5 fe			ld (debug_mark+1),a  
2e38 3a 42 2e			ld a, (.dmark+2)  
2e3b 32 b6 fe			ld (debug_mark+2),a  
2e3e 18 03			jr .pastdmark  
2e40 ..			.dmark: db "FRG"  
2e43 f1			.pastdmark: pop af  
2e44			endm  
# End of macro DMARK
2e44						CALLMONITOR 
2e44 cd c6 18			call break_point_state  
2e47				endm  
# End of macro CALLMONITOR
2e47					endif 
2e47			 
2e47				; find uword 
2e47			        ; update start of word with "_" 
2e47				; replace uword with deleted flag 
2e47			 
2e47			 
2e47			;	if DEBUG_FORTH_WORDS 
2e47			;		DMARK "FOG" 
2e47			;		CALLMONITOR 
2e47			;	endif 
2e47			 
2e47			 
2e47					; Get ptr to the word we need to look up 
2e47			 
2e47					FORTH_DSP_VALUEHL 
2e47 cd 31 21			call macro_dsp_valuehl 
2e4a				endm 
# End of macro FORTH_DSP_VALUEHL
2e4a					;v5 FORTH_DSP_VALUE 
2e4a				; TODO type check 
2e4a			;		inc hl    ; Skip type check  
2e4a e5					push hl 
2e4b c1					pop bc 
2e4c			;		ex de, hl    ; put into DE 
2e4c			 
2e4c			 
2e4c 21 00 80				ld hl, baseram 
2e4f					;ld hl, baseusermem 
2e4f			 
2e4f				; skip dict stub 
2e4f			;	call forth_tok_next 
2e4f e5			push hl   ; sacreifical push 
2e50			 
2e50			.fldouscanm: 
2e50 e1				pop hl 
2e51			.fldouscan: 
2e51			;	if DEBUG_FORTH_WORDS 
2e51			;		DMARK "LSs" 
2e51			;		CALLMONITOR 
2e51			;	endif 
2e51				; skip dict stub 
2e51 cd 38 24				call forth_tok_next 
2e54			 
2e54			 
2e54			; while we have words to look for 
2e54			 
2e54 7e				ld a, (hl)      
2e55			;	if DEBUG_FORTH_WORDS 
2e55			;		DMARK "LSk" 
2e55			;		CALLMONITOR 
2e55			;	endif 
2e55 fe 00				cp WORD_SYS_END 
2e57 ca 93 2e				jp z, .flunotfound 
2e5a fe 01				cp WORD_SYS_UWORD 
2e5c c2 51 2e				jp nz, .fldouscan 
2e5f			 
2e5f			;	if DEBUG_FORTH_WORDS 
2e5f			;		DMARK "LSu" 
2e5f			;		CALLMONITOR 
2e5f			;	endif 
2e5f			 
2e5f					; found a uword but is it the one we want... 
2e5f			 
2e5f c5					push bc     ; uword to find is on bc 
2e60 d1					pop de 
2e61			 
2e61 e5					push hl  ; to save the ptr 
2e62			 
2e62					; skip opcode 
2e62 23					inc hl  
2e63					; skip next ptr 
2e63 23					inc hl  
2e64 23					inc hl 
2e65					; skip len 
2e65 23					inc hl 
2e66			 
2e66			;	if DEBUG_FORTH_WORDS 
2e66			;		DMARK "LSc" 
2e66			;		CALLMONITOR 
2e66			;	endif 
2e66 cd df 13				call strcmp 
2e69 c2 50 2e				jp nz, .fldouscanm 
2e6c			; 
2e6c			; 
2e6c			;; while we have words to look for 
2e6c			; 
2e6c			;.fdouscan:	ld a, (hl)      
2e6c			;	if DEBUG_FORTH_WORDS 
2e6c			;		DMARK "LSs" 
2e6c			;		CALLMONITOR 
2e6c			;	endif 
2e6c			;		cp WORD_SYS_END 
2e6c			;		jp z, .fudone 
2e6c			;		cp WORD_SYS_UWORD 
2e6c			;		jp nz, .fnuword 
2e6c			; 
2e6c			;	if DEBUG_FORTH_WORDS 
2e6c			;		DMARK "FGu" 
2e6c			;		CALLMONITOR 
2e6c			;	endif 
2e6c			; 
2e6c			;		; found a uword but is it the one we want... 
2e6c			; 
2e6c			; 
2e6c			;	        pop de   ; get back the dsp name 
2e6c			;		push de 
2e6c			; 
2e6c			;		push hl  ; to save the ptr 
2e6c			; 
2e6c			;		; skip opcode 
2e6c			;		inc hl  
2e6c			;		; skip next ptr 
2e6c			;		inc hl  
2e6c			;		inc hl 
2e6c			;		; skip len 
2e6c			;		inc hl 
2e6c			; 
2e6c			;	if DEBUG_FORTH_WORDS 
2e6c			;		DMARK "FGc" 
2e6c			;		CALLMONITOR 
2e6c			;	endif 
2e6c			;		call strcmp 
2e6c			;		jp nz, .fnuword 
2e6c			 
2e6c			 
2e6c e1			pop hl 
2e6d			 
2e6d				 
2e6d				if DEBUG_FORTH_WORDS 
2e6d					DMARK "FGm" 
2e6d f5				push af  
2e6e 3a 82 2e			ld a, (.dmark)  
2e71 32 b4 fe			ld (debug_mark),a  
2e74 3a 83 2e			ld a, (.dmark+1)  
2e77 32 b5 fe			ld (debug_mark+1),a  
2e7a 3a 84 2e			ld a, (.dmark+2)  
2e7d 32 b6 fe			ld (debug_mark+2),a  
2e80 18 03			jr .pastdmark  
2e82 ..			.dmark: db "FGm"  
2e85 f1			.pastdmark: pop af  
2e86			endm  
# End of macro DMARK
2e86					CALLMONITOR 
2e86 cd c6 18			call break_point_state  
2e89				endm  
# End of macro CALLMONITOR
2e89				endif 
2e89			 
2e89			 
2e89			 
2e89					; we have a uword so push its name to the stack 
2e89			 
2e89			;	   	push hl  ; save so we can move to next dict block 
2e89			;pop hl 
2e89			 
2e89					; update opcode to deleted 
2e89 3e 03				ld a, WORD_SYS_DELETED 
2e8b 77					ld (hl), a 
2e8c			 
2e8c 23					inc hl  
2e8d					; skip next ptr 
2e8d 23					inc hl  
2e8e 23					inc hl 
2e8f					; skip len 
2e8f 23					inc hl 
2e90			 
2e90					; TODO change parser to skip deleted words but for now mark it out 
2e90 3e 5f				ld a, "_" 
2e92 77					ld  (hl),a 
2e93			 
2e93			;		jr .fudone 
2e93			; 
2e93			;.fnuword:	pop hl 
2e93			;		call forth_tok_next 
2e93			;		jp .fdouscan  
2e93			 
2e93			.flunotfound:		  
2e93			 
2e93			 
2e93					 
2e93					FORTH_DSP_POP 
2e93 cd e9 21			call macro_forth_dsp_pop 
2e96				endm 
# End of macro FORTH_DSP_POP
2e96			;		ld hl, .luno 
2e96			;.fudone:		 pop hl 
2e96					NEXTW 
2e96 c3 e7 22			jp macro_next 
2e99				endm 
# End of macro NEXTW
2e99			.NOP: 
2e99				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e99 61				db WORD_SYS_CORE+77             
2e9a c0 2e			dw .COMO            
2e9c 04				db 3 + 1 
2e9d .. 00			db "NOP",0              
2ea1				endm 
# End of macro CWHEAD
2ea1			; | NOP (  --  ) Do nothing | DONE 
2ea1					if DEBUG_FORTH_WORDS_KEY 
2ea1						DMARK "NOP" 
2ea1 f5				push af  
2ea2 3a b6 2e			ld a, (.dmark)  
2ea5 32 b4 fe			ld (debug_mark),a  
2ea8 3a b7 2e			ld a, (.dmark+1)  
2eab 32 b5 fe			ld (debug_mark+1),a  
2eae 3a b8 2e			ld a, (.dmark+2)  
2eb1 32 b6 fe			ld (debug_mark+2),a  
2eb4 18 03			jr .pastdmark  
2eb6 ..			.dmark: db "NOP"  
2eb9 f1			.pastdmark: pop af  
2eba			endm  
# End of macro DMARK
2eba						CALLMONITOR 
2eba cd c6 18			call break_point_state  
2ebd				endm  
# End of macro CALLMONITOR
2ebd					endif 
2ebd				       NEXTW 
2ebd c3 e7 22			jp macro_next 
2ec0				endm 
# End of macro NEXTW
2ec0			.COMO: 
2ec0				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2ec0 6e				db WORD_SYS_CORE+90             
2ec1 12 2f			dw .COMC            
2ec3 02				db 1 + 1 
2ec4 .. 00			db "(",0              
2ec6				endm 
# End of macro CWHEAD
2ec6			; | ( ( -- )  Start of comment | DONE 
2ec6			 
2ec6			 
2ec6 2a 4f f6				ld hl, ( os_tok_ptr) 
2ec9 11 0d 2f			ld de, .closepar 
2ecc					 
2ecc					if DEBUG_FORTH_WORDS 
2ecc						DMARK ").." 
2ecc f5				push af  
2ecd 3a e1 2e			ld a, (.dmark)  
2ed0 32 b4 fe			ld (debug_mark),a  
2ed3 3a e2 2e			ld a, (.dmark+1)  
2ed6 32 b5 fe			ld (debug_mark+1),a  
2ed9 3a e3 2e			ld a, (.dmark+2)  
2edc 32 b6 fe			ld (debug_mark+2),a  
2edf 18 03			jr .pastdmark  
2ee1 ..			.dmark: db ").."  
2ee4 f1			.pastdmark: pop af  
2ee5			endm  
# End of macro DMARK
2ee5						CALLMONITOR 
2ee5 cd c6 18			call break_point_state  
2ee8				endm  
# End of macro CALLMONITOR
2ee8					endif 
2ee8 cd 02 24			call findnexttok  
2eeb			 
2eeb					if DEBUG_FORTH_WORDS 
2eeb						DMARK "IF5" 
2eeb f5				push af  
2eec 3a 00 2f			ld a, (.dmark)  
2eef 32 b4 fe			ld (debug_mark),a  
2ef2 3a 01 2f			ld a, (.dmark+1)  
2ef5 32 b5 fe			ld (debug_mark+1),a  
2ef8 3a 02 2f			ld a, (.dmark+2)  
2efb 32 b6 fe			ld (debug_mark+2),a  
2efe 18 03			jr .pastdmark  
2f00 ..			.dmark: db "IF5"  
2f03 f1			.pastdmark: pop af  
2f04			endm  
# End of macro DMARK
2f04						CALLMONITOR 
2f04 cd c6 18			call break_point_state  
2f07				endm  
# End of macro CALLMONITOR
2f07					endif 
2f07				; replace below with ) exec using tok_ptr 
2f07 22 4f f6			ld (os_tok_ptr), hl 
2f0a c3 78 23			jp exec1 
2f0d			 
2f0d .. 00			.closepar:   db ")",0 
2f0f			 
2f0f				       NEXTW 
2f0f c3 e7 22			jp macro_next 
2f12				endm 
# End of macro NEXTW
2f12			.COMC: 
2f12				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2f12 6f				db WORD_SYS_CORE+91             
2f13 1b 2f			dw .SCRATCH            
2f15 02				db 1 + 1 
2f16 .. 00			db ")",0              
2f18				endm 
# End of macro CWHEAD
2f18			; | ) ( -- )  End of comment |  DONE  
2f18				       NEXTW 
2f18 c3 e7 22			jp macro_next 
2f1b				endm 
# End of macro NEXTW
2f1b			 
2f1b			.SCRATCH: 
2f1b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2f1b 6f				db WORD_SYS_CORE+91             
2f1c 56 2f			dw .INC            
2f1e 08				db 7 + 1 
2f1f .. 00			db "SCRATCH",0              
2f27				endm 
# End of macro CWHEAD
2f27			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2f27			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2f27			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2f27			; | |  
2f27			; | | e.g.    : score $00 scratch ; 
2f27			; | |  
2f27			; | | $00 score ! 
2f27			; | | $01 score +! 
2f27			; | |  
2f27			; | | e.g.   : varword $0a scratch ;  
2f27			; | | 
2f27			; | | $8000 varword ! 
2f27					if DEBUG_FORTH_WORDS_KEY 
2f27						DMARK "SCR" 
2f27 f5				push af  
2f28 3a 3c 2f			ld a, (.dmark)  
2f2b 32 b4 fe			ld (debug_mark),a  
2f2e 3a 3d 2f			ld a, (.dmark+1)  
2f31 32 b5 fe			ld (debug_mark+1),a  
2f34 3a 3e 2f			ld a, (.dmark+2)  
2f37 32 b6 fe			ld (debug_mark+2),a  
2f3a 18 03			jr .pastdmark  
2f3c ..			.dmark: db "SCR"  
2f3f f1			.pastdmark: pop af  
2f40			endm  
# End of macro DMARK
2f40						CALLMONITOR 
2f40 cd c6 18			call break_point_state  
2f43				endm  
# End of macro CALLMONITOR
2f43					endif 
2f43			 
2f43					FORTH_DSP_VALUEHL 
2f43 cd 31 21			call macro_dsp_valuehl 
2f46				endm 
# End of macro FORTH_DSP_VALUEHL
2f46				 
2f46					FORTH_DSP_POP 
2f46 cd e9 21			call macro_forth_dsp_pop 
2f49				endm 
# End of macro FORTH_DSP_POP
2f49			 
2f49 7d					ld a, l 
2f4a 21 73 f8				ld hl, os_var_array 
2f4d cd 49 0f				call addatohl 
2f50			 
2f50 cd 3a 1f				call forth_push_numhl 
2f53			 
2f53				       NEXTW 
2f53 c3 e7 22			jp macro_next 
2f56				endm 
# End of macro NEXTW
2f56			 
2f56			.INC: 
2f56				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f56 6f				db WORD_SYS_CORE+91             
2f57 aa 2f			dw .DEC            
2f59 03				db 2 + 1 
2f5a .. 00			db "+!",0              
2f5d				endm 
# End of macro CWHEAD
2f5d			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f5d					if DEBUG_FORTH_WORDS_KEY 
2f5d						DMARK "+s_" 
2f5d f5				push af  
2f5e 3a 72 2f			ld a, (.dmark)  
2f61 32 b4 fe			ld (debug_mark),a  
2f64 3a 73 2f			ld a, (.dmark+1)  
2f67 32 b5 fe			ld (debug_mark+1),a  
2f6a 3a 74 2f			ld a, (.dmark+2)  
2f6d 32 b6 fe			ld (debug_mark+2),a  
2f70 18 03			jr .pastdmark  
2f72 ..			.dmark: db "+s_"  
2f75 f1			.pastdmark: pop af  
2f76			endm  
# End of macro DMARK
2f76						CALLMONITOR 
2f76 cd c6 18			call break_point_state  
2f79				endm  
# End of macro CALLMONITOR
2f79					endif 
2f79			 
2f79					FORTH_DSP_VALUEHL 
2f79 cd 31 21			call macro_dsp_valuehl 
2f7c				endm 
# End of macro FORTH_DSP_VALUEHL
2f7c			 
2f7c e5					push hl   ; save address 
2f7d			 
2f7d					FORTH_DSP_POP 
2f7d cd e9 21			call macro_forth_dsp_pop 
2f80				endm 
# End of macro FORTH_DSP_POP
2f80			 
2f80					FORTH_DSP_VALUEHL 
2f80 cd 31 21			call macro_dsp_valuehl 
2f83				endm 
# End of macro FORTH_DSP_VALUEHL
2f83			 
2f83					FORTH_DSP_POP 
2f83 cd e9 21			call macro_forth_dsp_pop 
2f86				endm 
# End of macro FORTH_DSP_POP
2f86			 
2f86					; hl contains value to add to byte at a 
2f86				 
2f86 eb					ex de, hl 
2f87			 
2f87 e1					pop hl 
2f88			 
2f88					if DEBUG_FORTH_WORDS 
2f88						DMARK "INC" 
2f88 f5				push af  
2f89 3a 9d 2f			ld a, (.dmark)  
2f8c 32 b4 fe			ld (debug_mark),a  
2f8f 3a 9e 2f			ld a, (.dmark+1)  
2f92 32 b5 fe			ld (debug_mark+1),a  
2f95 3a 9f 2f			ld a, (.dmark+2)  
2f98 32 b6 fe			ld (debug_mark+2),a  
2f9b 18 03			jr .pastdmark  
2f9d ..			.dmark: db "INC"  
2fa0 f1			.pastdmark: pop af  
2fa1			endm  
# End of macro DMARK
2fa1						CALLMONITOR 
2fa1 cd c6 18			call break_point_state  
2fa4				endm  
# End of macro CALLMONITOR
2fa4					endif 
2fa4			 
2fa4 7e					ld a,(hl) 
2fa5 83					add e 
2fa6 77					ld (hl),a 
2fa7			 
2fa7			 
2fa7			 
2fa7				       NEXTW 
2fa7 c3 e7 22			jp macro_next 
2faa				endm 
# End of macro NEXTW
2faa			 
2faa			.DEC: 
2faa				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2faa 6f				db WORD_SYS_CORE+91             
2fab fb 2f			dw .INC2            
2fad 03				db 2 + 1 
2fae .. 00			db "-!",0              
2fb1				endm 
# End of macro CWHEAD
2fb1			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2fb1					if DEBUG_FORTH_WORDS_KEY 
2fb1						DMARK "-s_" 
2fb1 f5				push af  
2fb2 3a c6 2f			ld a, (.dmark)  
2fb5 32 b4 fe			ld (debug_mark),a  
2fb8 3a c7 2f			ld a, (.dmark+1)  
2fbb 32 b5 fe			ld (debug_mark+1),a  
2fbe 3a c8 2f			ld a, (.dmark+2)  
2fc1 32 b6 fe			ld (debug_mark+2),a  
2fc4 18 03			jr .pastdmark  
2fc6 ..			.dmark: db "-s_"  
2fc9 f1			.pastdmark: pop af  
2fca			endm  
# End of macro DMARK
2fca						CALLMONITOR 
2fca cd c6 18			call break_point_state  
2fcd				endm  
# End of macro CALLMONITOR
2fcd					endif 
2fcd			 
2fcd					FORTH_DSP_VALUEHL 
2fcd cd 31 21			call macro_dsp_valuehl 
2fd0				endm 
# End of macro FORTH_DSP_VALUEHL
2fd0			 
2fd0 e5					push hl   ; save address 
2fd1			 
2fd1					FORTH_DSP_POP 
2fd1 cd e9 21			call macro_forth_dsp_pop 
2fd4				endm 
# End of macro FORTH_DSP_POP
2fd4			 
2fd4					FORTH_DSP_VALUEHL 
2fd4 cd 31 21			call macro_dsp_valuehl 
2fd7				endm 
# End of macro FORTH_DSP_VALUEHL
2fd7			 
2fd7					; hl contains value to add to byte at a 
2fd7				 
2fd7 eb					ex de, hl 
2fd8			 
2fd8 e1					pop hl 
2fd9			 
2fd9					if DEBUG_FORTH_WORDS 
2fd9						DMARK "DEC" 
2fd9 f5				push af  
2fda 3a ee 2f			ld a, (.dmark)  
2fdd 32 b4 fe			ld (debug_mark),a  
2fe0 3a ef 2f			ld a, (.dmark+1)  
2fe3 32 b5 fe			ld (debug_mark+1),a  
2fe6 3a f0 2f			ld a, (.dmark+2)  
2fe9 32 b6 fe			ld (debug_mark+2),a  
2fec 18 03			jr .pastdmark  
2fee ..			.dmark: db "DEC"  
2ff1 f1			.pastdmark: pop af  
2ff2			endm  
# End of macro DMARK
2ff2						CALLMONITOR 
2ff2 cd c6 18			call break_point_state  
2ff5				endm  
# End of macro CALLMONITOR
2ff5					endif 
2ff5			 
2ff5 7e					ld a,(hl) 
2ff6 93					sub e 
2ff7 77					ld (hl),a 
2ff8			 
2ff8			 
2ff8			 
2ff8				       NEXTW 
2ff8 c3 e7 22			jp macro_next 
2ffb				endm 
# End of macro NEXTW
2ffb			 
2ffb			.INC2: 
2ffb				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ffb 6f				db WORD_SYS_CORE+91             
2ffc a5 30			dw .DEC2            
2ffe 04				db 3 + 1 
2fff .. 00			db "+2!",0              
3003				endm 
# End of macro CWHEAD
3003			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3003			 
3003					if DEBUG_FORTH_WORDS_KEY 
3003						DMARK "+2s" 
3003 f5				push af  
3004 3a 18 30			ld a, (.dmark)  
3007 32 b4 fe			ld (debug_mark),a  
300a 3a 19 30			ld a, (.dmark+1)  
300d 32 b5 fe			ld (debug_mark+1),a  
3010 3a 1a 30			ld a, (.dmark+2)  
3013 32 b6 fe			ld (debug_mark+2),a  
3016 18 03			jr .pastdmark  
3018 ..			.dmark: db "+2s"  
301b f1			.pastdmark: pop af  
301c			endm  
# End of macro DMARK
301c						CALLMONITOR 
301c cd c6 18			call break_point_state  
301f				endm  
# End of macro CALLMONITOR
301f					endif 
301f			 
301f					; Address 
301f			 
301f					FORTH_DSP_VALUEHL 
301f cd 31 21			call macro_dsp_valuehl 
3022				endm 
# End of macro FORTH_DSP_VALUEHL
3022			 
3022 e5					push hl    ; save address 
3023			 
3023					; load content into de 
3023			 
3023 5e					ld e,(hl) 
3024 23					inc hl 
3025 56					ld d, (hl) 
3026			 
3026					if DEBUG_FORTH_WORDS 
3026						DMARK "+2a" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 b4 fe			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 b5 fe			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 b6 fe			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "+2a"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f						CALLMONITOR 
303f cd c6 18			call break_point_state  
3042				endm  
# End of macro CALLMONITOR
3042					endif 
3042			 
3042					FORTH_DSP_POP 
3042 cd e9 21			call macro_forth_dsp_pop 
3045				endm 
# End of macro FORTH_DSP_POP
3045			 
3045					; Get value to add 
3045			 
3045					FORTH_DSP_VALUE 
3045 cd 1a 21			call macro_forth_dsp_value 
3048				endm 
# End of macro FORTH_DSP_VALUE
3048			 
3048					if DEBUG_FORTH_WORDS 
3048						DMARK "+2v" 
3048 f5				push af  
3049 3a 5d 30			ld a, (.dmark)  
304c 32 b4 fe			ld (debug_mark),a  
304f 3a 5e 30			ld a, (.dmark+1)  
3052 32 b5 fe			ld (debug_mark+1),a  
3055 3a 5f 30			ld a, (.dmark+2)  
3058 32 b6 fe			ld (debug_mark+2),a  
305b 18 03			jr .pastdmark  
305d ..			.dmark: db "+2v"  
3060 f1			.pastdmark: pop af  
3061			endm  
# End of macro DMARK
3061						CALLMONITOR 
3061 cd c6 18			call break_point_state  
3064				endm  
# End of macro CALLMONITOR
3064					endif 
3064			 
3064 19					add hl, de 
3065			 
3065					if DEBUG_FORTH_WORDS 
3065						DMARK "+2+" 
3065 f5				push af  
3066 3a 7a 30			ld a, (.dmark)  
3069 32 b4 fe			ld (debug_mark),a  
306c 3a 7b 30			ld a, (.dmark+1)  
306f 32 b5 fe			ld (debug_mark+1),a  
3072 3a 7c 30			ld a, (.dmark+2)  
3075 32 b6 fe			ld (debug_mark+2),a  
3078 18 03			jr .pastdmark  
307a ..			.dmark: db "+2+"  
307d f1			.pastdmark: pop af  
307e			endm  
# End of macro DMARK
307e						CALLMONITOR 
307e cd c6 18			call break_point_state  
3081				endm  
# End of macro CALLMONITOR
3081					endif 
3081			 
3081					; move result to de 
3081			 
3081 eb					ex de, hl 
3082			 
3082					; Address 
3082			 
3082 e1					pop hl 
3083			 
3083					; save it back 
3083			 
3083 73					ld (hl), e 
3084 23					inc hl 
3085 72					ld (hl), d 
3086			 
3086					if DEBUG_FORTH_WORDS 
3086						DMARK "+2e" 
3086 f5				push af  
3087 3a 9b 30			ld a, (.dmark)  
308a 32 b4 fe			ld (debug_mark),a  
308d 3a 9c 30			ld a, (.dmark+1)  
3090 32 b5 fe			ld (debug_mark+1),a  
3093 3a 9d 30			ld a, (.dmark+2)  
3096 32 b6 fe			ld (debug_mark+2),a  
3099 18 03			jr .pastdmark  
309b ..			.dmark: db "+2e"  
309e f1			.pastdmark: pop af  
309f			endm  
# End of macro DMARK
309f						CALLMONITOR 
309f cd c6 18			call break_point_state  
30a2				endm  
# End of macro CALLMONITOR
30a2					endif 
30a2			 
30a2			 
30a2			 
30a2			 
30a2			 
30a2				       NEXTW 
30a2 c3 e7 22			jp macro_next 
30a5				endm 
# End of macro NEXTW
30a5			 
30a5			.DEC2: 
30a5				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
30a5 6f				db WORD_SYS_CORE+91             
30a6 51 31			dw .GET2            
30a8 04				db 3 + 1 
30a9 .. 00			db "-2!",0              
30ad				endm 
# End of macro CWHEAD
30ad			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
30ad			 
30ad			 
30ad					if DEBUG_FORTH_WORDS_KEY 
30ad						DMARK "-2s" 
30ad f5				push af  
30ae 3a c2 30			ld a, (.dmark)  
30b1 32 b4 fe			ld (debug_mark),a  
30b4 3a c3 30			ld a, (.dmark+1)  
30b7 32 b5 fe			ld (debug_mark+1),a  
30ba 3a c4 30			ld a, (.dmark+2)  
30bd 32 b6 fe			ld (debug_mark+2),a  
30c0 18 03			jr .pastdmark  
30c2 ..			.dmark: db "-2s"  
30c5 f1			.pastdmark: pop af  
30c6			endm  
# End of macro DMARK
30c6						CALLMONITOR 
30c6 cd c6 18			call break_point_state  
30c9				endm  
# End of macro CALLMONITOR
30c9					endif 
30c9			 
30c9					; Address 
30c9			 
30c9					FORTH_DSP_VALUEHL 
30c9 cd 31 21			call macro_dsp_valuehl 
30cc				endm 
# End of macro FORTH_DSP_VALUEHL
30cc			 
30cc e5					push hl    ; save address 
30cd			 
30cd					; load content into de 
30cd			 
30cd 5e					ld e,(hl) 
30ce 23					inc hl 
30cf 56					ld d, (hl) 
30d0			 
30d0					if DEBUG_FORTH_WORDS 
30d0						DMARK "-2a" 
30d0 f5				push af  
30d1 3a e5 30			ld a, (.dmark)  
30d4 32 b4 fe			ld (debug_mark),a  
30d7 3a e6 30			ld a, (.dmark+1)  
30da 32 b5 fe			ld (debug_mark+1),a  
30dd 3a e7 30			ld a, (.dmark+2)  
30e0 32 b6 fe			ld (debug_mark+2),a  
30e3 18 03			jr .pastdmark  
30e5 ..			.dmark: db "-2a"  
30e8 f1			.pastdmark: pop af  
30e9			endm  
# End of macro DMARK
30e9						CALLMONITOR 
30e9 cd c6 18			call break_point_state  
30ec				endm  
# End of macro CALLMONITOR
30ec					endif 
30ec			 
30ec					FORTH_DSP_POP 
30ec cd e9 21			call macro_forth_dsp_pop 
30ef				endm 
# End of macro FORTH_DSP_POP
30ef			 
30ef					; Get value to remove 
30ef			 
30ef					FORTH_DSP_VALUE 
30ef cd 1a 21			call macro_forth_dsp_value 
30f2				endm 
# End of macro FORTH_DSP_VALUE
30f2			 
30f2					if DEBUG_FORTH_WORDS 
30f2						DMARK "-2v" 
30f2 f5				push af  
30f3 3a 07 31			ld a, (.dmark)  
30f6 32 b4 fe			ld (debug_mark),a  
30f9 3a 08 31			ld a, (.dmark+1)  
30fc 32 b5 fe			ld (debug_mark+1),a  
30ff 3a 09 31			ld a, (.dmark+2)  
3102 32 b6 fe			ld (debug_mark+2),a  
3105 18 03			jr .pastdmark  
3107 ..			.dmark: db "-2v"  
310a f1			.pastdmark: pop af  
310b			endm  
# End of macro DMARK
310b						CALLMONITOR 
310b cd c6 18			call break_point_state  
310e				endm  
# End of macro CALLMONITOR
310e					endif 
310e			 
310e eb					ex de, hl 
310f ed 52				sbc hl, de 
3111			 
3111					if DEBUG_FORTH_WORDS 
3111						DMARK "-2d" 
3111 f5				push af  
3112 3a 26 31			ld a, (.dmark)  
3115 32 b4 fe			ld (debug_mark),a  
3118 3a 27 31			ld a, (.dmark+1)  
311b 32 b5 fe			ld (debug_mark+1),a  
311e 3a 28 31			ld a, (.dmark+2)  
3121 32 b6 fe			ld (debug_mark+2),a  
3124 18 03			jr .pastdmark  
3126 ..			.dmark: db "-2d"  
3129 f1			.pastdmark: pop af  
312a			endm  
# End of macro DMARK
312a						CALLMONITOR 
312a cd c6 18			call break_point_state  
312d				endm  
# End of macro CALLMONITOR
312d					endif 
312d			 
312d					; move result to de 
312d			 
312d eb					ex de, hl 
312e			 
312e					; Address 
312e			 
312e e1					pop hl 
312f			 
312f					; save it back 
312f			 
312f 73					ld (hl), e 
3130 23					inc hl 
3131 72					ld (hl), d 
3132			 
3132					if DEBUG_FORTH_WORDS 
3132						DMARK "-2e" 
3132 f5				push af  
3133 3a 47 31			ld a, (.dmark)  
3136 32 b4 fe			ld (debug_mark),a  
3139 3a 48 31			ld a, (.dmark+1)  
313c 32 b5 fe			ld (debug_mark+1),a  
313f 3a 49 31			ld a, (.dmark+2)  
3142 32 b6 fe			ld (debug_mark+2),a  
3145 18 03			jr .pastdmark  
3147 ..			.dmark: db "-2e"  
314a f1			.pastdmark: pop af  
314b			endm  
# End of macro DMARK
314b						CALLMONITOR 
314b cd c6 18			call break_point_state  
314e				endm  
# End of macro CALLMONITOR
314e					endif 
314e			 
314e			 
314e			 
314e			 
314e			 
314e				       NEXTW 
314e c3 e7 22			jp macro_next 
3151				endm 
# End of macro NEXTW
3151			.GET2: 
3151				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3151 6f				db WORD_SYS_CORE+91             
3152 81 31			dw .BANG2            
3154 03				db 2 + 1 
3155 .. 00			db "2@",0              
3158				endm 
# End of macro CWHEAD
3158			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3158					if DEBUG_FORTH_WORDS_KEY 
3158						DMARK "2A_" 
3158 f5				push af  
3159 3a 6d 31			ld a, (.dmark)  
315c 32 b4 fe			ld (debug_mark),a  
315f 3a 6e 31			ld a, (.dmark+1)  
3162 32 b5 fe			ld (debug_mark+1),a  
3165 3a 6f 31			ld a, (.dmark+2)  
3168 32 b6 fe			ld (debug_mark+2),a  
316b 18 03			jr .pastdmark  
316d ..			.dmark: db "2A_"  
3170 f1			.pastdmark: pop af  
3171			endm  
# End of macro DMARK
3171						CALLMONITOR 
3171 cd c6 18			call break_point_state  
3174				endm  
# End of macro CALLMONITOR
3174					endif 
3174			 
3174					FORTH_DSP_VALUEHL 
3174 cd 31 21			call macro_dsp_valuehl 
3177				endm 
# End of macro FORTH_DSP_VALUEHL
3177			 
3177 5e					ld e, (hl) 
3178 23					inc hl 
3179 56					ld d, (hl) 
317a			 
317a eb					ex de, hl 
317b			 
317b cd 3a 1f				call forth_push_numhl 
317e			 
317e				       NEXTW 
317e c3 e7 22			jp macro_next 
3181				endm 
# End of macro NEXTW
3181			.BANG2: 
3181				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3181 6f				db WORD_SYS_CORE+91             
3182 b9 31			dw .CONFIG            
3184 03				db 2 + 1 
3185 .. 00			db "2!",0              
3188				endm 
# End of macro CWHEAD
3188			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3188					if DEBUG_FORTH_WORDS_KEY 
3188						DMARK "2S_" 
3188 f5				push af  
3189 3a 9d 31			ld a, (.dmark)  
318c 32 b4 fe			ld (debug_mark),a  
318f 3a 9e 31			ld a, (.dmark+1)  
3192 32 b5 fe			ld (debug_mark+1),a  
3195 3a 9f 31			ld a, (.dmark+2)  
3198 32 b6 fe			ld (debug_mark+2),a  
319b 18 03			jr .pastdmark  
319d ..			.dmark: db "2S_"  
31a0 f1			.pastdmark: pop af  
31a1			endm  
# End of macro DMARK
31a1						CALLMONITOR 
31a1 cd c6 18			call break_point_state  
31a4				endm  
# End of macro CALLMONITOR
31a4					endif 
31a4			 
31a4					FORTH_DSP_VALUEHL 
31a4 cd 31 21			call macro_dsp_valuehl 
31a7				endm 
# End of macro FORTH_DSP_VALUEHL
31a7			 
31a7 e5					push hl   ; save address 
31a8			 
31a8			 
31a8					FORTH_DSP_POP 
31a8 cd e9 21			call macro_forth_dsp_pop 
31ab				endm 
# End of macro FORTH_DSP_POP
31ab			 
31ab					 
31ab					FORTH_DSP_VALUEHL 
31ab cd 31 21			call macro_dsp_valuehl 
31ae				endm 
# End of macro FORTH_DSP_VALUEHL
31ae			 
31ae					FORTH_DSP_POP 
31ae cd e9 21			call macro_forth_dsp_pop 
31b1				endm 
# End of macro FORTH_DSP_POP
31b1			 
31b1 eb					ex de, hl    ; value now in de 
31b2			 
31b2 e1					pop hl 
31b3			 
31b3 73					ld (hl), e 
31b4			 
31b4 23					inc hl 
31b5			 
31b5 72					ld (hl), d 
31b6			 
31b6			 
31b6				       NEXTW 
31b6 c3 e7 22			jp macro_next 
31b9				endm 
# End of macro NEXTW
31b9			.CONFIG: 
31b9				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
31b9 6f				db WORD_SYS_CORE+91             
31ba ca 31			dw .ENDCORE            
31bc 07				db 6 + 1 
31bd .. 00			db "CONFIG",0              
31c4				endm 
# End of macro CWHEAD
31c4			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
31c4			 
31c4 cd a9 15				call config 
31c7					NEXTW 
31c7 c3 e7 22			jp macro_next 
31ca				endm 
# End of macro NEXTW
31ca			.ENDCORE: 
31ca			 
31ca			; eof 
31ca			 
31ca			 
# End of file forth_words_core.asm
31ca			include "forth_words_flow.asm" 
31ca			 
31ca			; | ## Program Flow Words 
31ca			 
31ca			.IF: 
31ca				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31ca 1e				db WORD_SYS_CORE+10             
31cb bf 32			dw .THEN            
31cd 03				db 2 + 1 
31ce .. 00			db "IF",0              
31d1				endm 
# End of macro CWHEAD
31d1			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31d1			; 
31d1					if DEBUG_FORTH_WORDS_KEY 
31d1						DMARK "IF." 
31d1 f5				push af  
31d2 3a e6 31			ld a, (.dmark)  
31d5 32 b4 fe			ld (debug_mark),a  
31d8 3a e7 31			ld a, (.dmark+1)  
31db 32 b5 fe			ld (debug_mark+1),a  
31de 3a e8 31			ld a, (.dmark+2)  
31e1 32 b6 fe			ld (debug_mark+2),a  
31e4 18 03			jr .pastdmark  
31e6 ..			.dmark: db "IF."  
31e9 f1			.pastdmark: pop af  
31ea			endm  
# End of macro DMARK
31ea						CALLMONITOR 
31ea cd c6 18			call break_point_state  
31ed				endm  
# End of macro CALLMONITOR
31ed					endif 
31ed			; eval TOS 
31ed			 
31ed				FORTH_DSP_VALUEHL 
31ed cd 31 21			call macro_dsp_valuehl 
31f0				endm 
# End of macro FORTH_DSP_VALUEHL
31f0			 
31f0			;	push hl 
31f0				FORTH_DSP_POP 
31f0 cd e9 21			call macro_forth_dsp_pop 
31f3				endm 
# End of macro FORTH_DSP_POP
31f3			;	pop hl 
31f3			 
31f3					if DEBUG_FORTH_WORDS 
31f3						DMARK "IF1" 
31f3 f5				push af  
31f4 3a 08 32			ld a, (.dmark)  
31f7 32 b4 fe			ld (debug_mark),a  
31fa 3a 09 32			ld a, (.dmark+1)  
31fd 32 b5 fe			ld (debug_mark+1),a  
3200 3a 0a 32			ld a, (.dmark+2)  
3203 32 b6 fe			ld (debug_mark+2),a  
3206 18 03			jr .pastdmark  
3208 ..			.dmark: db "IF1"  
320b f1			.pastdmark: pop af  
320c			endm  
# End of macro DMARK
320c						CALLMONITOR 
320c cd c6 18			call break_point_state  
320f				endm  
# End of macro CALLMONITOR
320f					endif 
320f b7				or a        ; clear carry flag 
3210 11 00 00			ld de, 0 
3213 eb				ex de,hl 
3214 ed 52			sbc hl, de 
3216 c2 a0 32			jp nz, .iftrue 
3219			 
3219					if DEBUG_FORTH_WORDS 
3219						DMARK "IF2" 
3219 f5				push af  
321a 3a 2e 32			ld a, (.dmark)  
321d 32 b4 fe			ld (debug_mark),a  
3220 3a 2f 32			ld a, (.dmark+1)  
3223 32 b5 fe			ld (debug_mark+1),a  
3226 3a 30 32			ld a, (.dmark+2)  
3229 32 b6 fe			ld (debug_mark+2),a  
322c 18 03			jr .pastdmark  
322e ..			.dmark: db "IF2"  
3231 f1			.pastdmark: pop af  
3232			endm  
# End of macro DMARK
3232						CALLMONITOR 
3232 cd c6 18			call break_point_state  
3235				endm  
# End of macro CALLMONITOR
3235					endif 
3235			 
3235			; if not true then skip to THEN 
3235			 
3235				; TODO get tok_ptr 
3235				; TODO consume toks until we get to THEN 
3235			 
3235 2a 4f f6			ld hl, (os_tok_ptr) 
3238					if DEBUG_FORTH_WORDS 
3238						DMARK "IF3" 
3238 f5				push af  
3239 3a 4d 32			ld a, (.dmark)  
323c 32 b4 fe			ld (debug_mark),a  
323f 3a 4e 32			ld a, (.dmark+1)  
3242 32 b5 fe			ld (debug_mark+1),a  
3245 3a 4f 32			ld a, (.dmark+2)  
3248 32 b6 fe			ld (debug_mark+2),a  
324b 18 03			jr .pastdmark  
324d ..			.dmark: db "IF3"  
3250 f1			.pastdmark: pop af  
3251			endm  
# End of macro DMARK
3251						CALLMONITOR 
3251 cd c6 18			call break_point_state  
3254				endm  
# End of macro CALLMONITOR
3254						 
3254					endif 
3254 11 9b 32			ld de, .ifthen 
3257					if DEBUG_FORTH_WORDS 
3257						DMARK "IF4" 
3257 f5				push af  
3258 3a 6c 32			ld a, (.dmark)  
325b 32 b4 fe			ld (debug_mark),a  
325e 3a 6d 32			ld a, (.dmark+1)  
3261 32 b5 fe			ld (debug_mark+1),a  
3264 3a 6e 32			ld a, (.dmark+2)  
3267 32 b6 fe			ld (debug_mark+2),a  
326a 18 03			jr .pastdmark  
326c ..			.dmark: db "IF4"  
326f f1			.pastdmark: pop af  
3270			endm  
# End of macro DMARK
3270						CALLMONITOR 
3270 cd c6 18			call break_point_state  
3273				endm  
# End of macro CALLMONITOR
3273					endif 
3273 cd 02 24			call findnexttok  
3276			 
3276					if DEBUG_FORTH_WORDS 
3276						DMARK "IF5" 
3276 f5				push af  
3277 3a 8b 32			ld a, (.dmark)  
327a 32 b4 fe			ld (debug_mark),a  
327d 3a 8c 32			ld a, (.dmark+1)  
3280 32 b5 fe			ld (debug_mark+1),a  
3283 3a 8d 32			ld a, (.dmark+2)  
3286 32 b6 fe			ld (debug_mark+2),a  
3289 18 03			jr .pastdmark  
328b ..			.dmark: db "IF5"  
328e f1			.pastdmark: pop af  
328f			endm  
# End of macro DMARK
328f						CALLMONITOR 
328f cd c6 18			call break_point_state  
3292				endm  
# End of macro CALLMONITOR
3292					endif 
3292				; TODO replace below with ; exec using tok_ptr 
3292 22 4f f6			ld (os_tok_ptr), hl 
3295 c3 78 23			jp exec1 
3298				NEXTW 
3298 c3 e7 22			jp macro_next 
329b				endm 
# End of macro NEXTW
329b			 
329b .. 00		.ifthen:  db "THEN",0 
32a0			 
32a0			.iftrue:		 
32a0				; Exec next words normally 
32a0			 
32a0				; if true then exec following IF as normal 
32a0					if DEBUG_FORTH_WORDS 
32a0						DMARK "IFT" 
32a0 f5				push af  
32a1 3a b5 32			ld a, (.dmark)  
32a4 32 b4 fe			ld (debug_mark),a  
32a7 3a b6 32			ld a, (.dmark+1)  
32aa 32 b5 fe			ld (debug_mark+1),a  
32ad 3a b7 32			ld a, (.dmark+2)  
32b0 32 b6 fe			ld (debug_mark+2),a  
32b3 18 03			jr .pastdmark  
32b5 ..			.dmark: db "IFT"  
32b8 f1			.pastdmark: pop af  
32b9			endm  
# End of macro DMARK
32b9						CALLMONITOR 
32b9 cd c6 18			call break_point_state  
32bc				endm  
# End of macro CALLMONITOR
32bc					endif 
32bc			 
32bc					NEXTW 
32bc c3 e7 22			jp macro_next 
32bf				endm 
# End of macro NEXTW
32bf			.THEN: 
32bf				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32bf 1f				db WORD_SYS_CORE+11             
32c0 e7 32			dw .ELSE            
32c2 05				db 4 + 1 
32c3 .. 00			db "THEN",0              
32c8				endm 
# End of macro CWHEAD
32c8			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32c8					if DEBUG_FORTH_WORDS_KEY 
32c8						DMARK "THN" 
32c8 f5				push af  
32c9 3a dd 32			ld a, (.dmark)  
32cc 32 b4 fe			ld (debug_mark),a  
32cf 3a de 32			ld a, (.dmark+1)  
32d2 32 b5 fe			ld (debug_mark+1),a  
32d5 3a df 32			ld a, (.dmark+2)  
32d8 32 b6 fe			ld (debug_mark+2),a  
32db 18 03			jr .pastdmark  
32dd ..			.dmark: db "THN"  
32e0 f1			.pastdmark: pop af  
32e1			endm  
# End of macro DMARK
32e1						CALLMONITOR 
32e1 cd c6 18			call break_point_state  
32e4				endm  
# End of macro CALLMONITOR
32e4					endif 
32e4					NEXTW 
32e4 c3 e7 22			jp macro_next 
32e7				endm 
# End of macro NEXTW
32e7			.ELSE: 
32e7				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32e7 20				db WORD_SYS_CORE+12             
32e8 0f 33			dw .DO            
32ea 03				db 2 + 1 
32eb .. 00			db "ELSE",0              
32f0				endm 
# End of macro CWHEAD
32f0			; | ELSE ( -- ) Not supported - does nothing | TODO 
32f0			 
32f0					if DEBUG_FORTH_WORDS_KEY 
32f0						DMARK "ELS" 
32f0 f5				push af  
32f1 3a 05 33			ld a, (.dmark)  
32f4 32 b4 fe			ld (debug_mark),a  
32f7 3a 06 33			ld a, (.dmark+1)  
32fa 32 b5 fe			ld (debug_mark+1),a  
32fd 3a 07 33			ld a, (.dmark+2)  
3300 32 b6 fe			ld (debug_mark+2),a  
3303 18 03			jr .pastdmark  
3305 ..			.dmark: db "ELS"  
3308 f1			.pastdmark: pop af  
3309			endm  
# End of macro DMARK
3309						CALLMONITOR 
3309 cd c6 18			call break_point_state  
330c				endm  
# End of macro CALLMONITOR
330c					endif 
330c			 
330c			 
330c					NEXTW 
330c c3 e7 22			jp macro_next 
330f				endm 
# End of macro NEXTW
330f			.DO: 
330f				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
330f 21				db WORD_SYS_CORE+13             
3310 36 34			dw .LOOP            
3312 03				db 2 + 1 
3313 .. 00			db "DO",0              
3316				endm 
# End of macro CWHEAD
3316			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3316			 
3316					if DEBUG_FORTH_WORDS_KEY 
3316						DMARK "DO." 
3316 f5				push af  
3317 3a 2b 33			ld a, (.dmark)  
331a 32 b4 fe			ld (debug_mark),a  
331d 3a 2c 33			ld a, (.dmark+1)  
3320 32 b5 fe			ld (debug_mark+1),a  
3323 3a 2d 33			ld a, (.dmark+2)  
3326 32 b6 fe			ld (debug_mark+2),a  
3329 18 03			jr .pastdmark  
332b ..			.dmark: db "DO."  
332e f1			.pastdmark: pop af  
332f			endm  
# End of macro DMARK
332f						CALLMONITOR 
332f cd c6 18			call break_point_state  
3332				endm  
# End of macro CALLMONITOR
3332					endif 
3332			;  push pc to rsp stack past the DO 
3332			 
3332 2a 4f f6				ld hl, (os_tok_ptr) 
3335 23					inc hl   ; D 
3336 23					inc hl  ; O 
3337 23					inc hl   ; null 
3338					if DEBUG_FORTH_WORDS 
3338						DMARK "DO2" 
3338 f5				push af  
3339 3a 4d 33			ld a, (.dmark)  
333c 32 b4 fe			ld (debug_mark),a  
333f 3a 4e 33			ld a, (.dmark+1)  
3342 32 b5 fe			ld (debug_mark+1),a  
3345 3a 4f 33			ld a, (.dmark+2)  
3348 32 b6 fe			ld (debug_mark+2),a  
334b 18 03			jr .pastdmark  
334d ..			.dmark: db "DO2"  
3350 f1			.pastdmark: pop af  
3351			endm  
# End of macro DMARK
3351						CALLMONITOR 
3351 cd c6 18			call break_point_state  
3354				endm  
# End of macro CALLMONITOR
3354					endif 
3354					FORTH_RSP_NEXT 
3354 cd e1 1e			call macro_forth_rsp_next 
3357				endm 
# End of macro FORTH_RSP_NEXT
3357					if DEBUG_FORTH_WORDS 
3357						DMARK "DO3" 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 b4 fe			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 b5 fe			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 b6 fe			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "DO3"  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd c6 18			call break_point_state  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373			 
3373					;if DEBUG_FORTH_WORDS 
3373				;		push hl 
3373			;		endif  
3373			 
3373			; get counters from data stack 
3373			 
3373			 
3373					FORTH_DSP_VALUEHL 
3373 cd 31 21			call macro_dsp_valuehl 
3376				endm 
# End of macro FORTH_DSP_VALUEHL
3376 e5					push hl		 ; hl now has starting counter which needs to be tos 
3377			 
3377					if DEBUG_FORTH_WORDS 
3377						DMARK "DO4" 
3377 f5				push af  
3378 3a 8c 33			ld a, (.dmark)  
337b 32 b4 fe			ld (debug_mark),a  
337e 3a 8d 33			ld a, (.dmark+1)  
3381 32 b5 fe			ld (debug_mark+1),a  
3384 3a 8e 33			ld a, (.dmark+2)  
3387 32 b6 fe			ld (debug_mark+2),a  
338a 18 03			jr .pastdmark  
338c ..			.dmark: db "DO4"  
338f f1			.pastdmark: pop af  
3390			endm  
# End of macro DMARK
3390						CALLMONITOR 
3390 cd c6 18			call break_point_state  
3393				endm  
# End of macro CALLMONITOR
3393					endif 
3393					FORTH_DSP_POP 
3393 cd e9 21			call macro_forth_dsp_pop 
3396				endm 
# End of macro FORTH_DSP_POP
3396			 
3396					if DEBUG_FORTH_WORDS 
3396						DMARK "DO5" 
3396 f5				push af  
3397 3a ab 33			ld a, (.dmark)  
339a 32 b4 fe			ld (debug_mark),a  
339d 3a ac 33			ld a, (.dmark+1)  
33a0 32 b5 fe			ld (debug_mark+1),a  
33a3 3a ad 33			ld a, (.dmark+2)  
33a6 32 b6 fe			ld (debug_mark+2),a  
33a9 18 03			jr .pastdmark  
33ab ..			.dmark: db "DO5"  
33ae f1			.pastdmark: pop af  
33af			endm  
# End of macro DMARK
33af						CALLMONITOR 
33af cd c6 18			call break_point_state  
33b2				endm  
# End of macro CALLMONITOR
33b2					endif 
33b2			 
33b2					FORTH_DSP_VALUEHL 
33b2 cd 31 21			call macro_dsp_valuehl 
33b5				endm 
# End of macro FORTH_DSP_VALUEHL
33b5			;		push hl		 ; hl now has starting limit counter 
33b5			 
33b5					if DEBUG_FORTH_WORDS 
33b5						DMARK "DO6" 
33b5 f5				push af  
33b6 3a ca 33			ld a, (.dmark)  
33b9 32 b4 fe			ld (debug_mark),a  
33bc 3a cb 33			ld a, (.dmark+1)  
33bf 32 b5 fe			ld (debug_mark+1),a  
33c2 3a cc 33			ld a, (.dmark+2)  
33c5 32 b6 fe			ld (debug_mark+2),a  
33c8 18 03			jr .pastdmark  
33ca ..			.dmark: db "DO6"  
33cd f1			.pastdmark: pop af  
33ce			endm  
# End of macro DMARK
33ce						CALLMONITOR 
33ce cd c6 18			call break_point_state  
33d1				endm  
# End of macro CALLMONITOR
33d1					endif 
33d1					FORTH_DSP_POP 
33d1 cd e9 21			call macro_forth_dsp_pop 
33d4				endm 
# End of macro FORTH_DSP_POP
33d4			 
33d4			; put counters on the loop stack 
33d4			 
33d4			;		pop hl			 ; limit counter 
33d4 d1					pop de			; start counter 
33d5			 
33d5					; push limit counter 
33d5			 
33d5					if DEBUG_FORTH_WORDS 
33d5						DMARK "DO7" 
33d5 f5				push af  
33d6 3a ea 33			ld a, (.dmark)  
33d9 32 b4 fe			ld (debug_mark),a  
33dc 3a eb 33			ld a, (.dmark+1)  
33df 32 b5 fe			ld (debug_mark+1),a  
33e2 3a ec 33			ld a, (.dmark+2)  
33e5 32 b6 fe			ld (debug_mark+2),a  
33e8 18 03			jr .pastdmark  
33ea ..			.dmark: db "DO7"  
33ed f1			.pastdmark: pop af  
33ee			endm  
# End of macro DMARK
33ee						CALLMONITOR 
33ee cd c6 18			call break_point_state  
33f1				endm  
# End of macro CALLMONITOR
33f1					endif 
33f1					FORTH_LOOP_NEXT 
33f1 cd 62 21			call macro_forth_loop_next 
33f4				endm 
# End of macro FORTH_LOOP_NEXT
33f4			 
33f4					; push start counter 
33f4			 
33f4 eb					ex de, hl 
33f5					if DEBUG_FORTH_WORDS 
33f5						DMARK "DO7" 
33f5 f5				push af  
33f6 3a 0a 34			ld a, (.dmark)  
33f9 32 b4 fe			ld (debug_mark),a  
33fc 3a 0b 34			ld a, (.dmark+1)  
33ff 32 b5 fe			ld (debug_mark+1),a  
3402 3a 0c 34			ld a, (.dmark+2)  
3405 32 b6 fe			ld (debug_mark+2),a  
3408 18 03			jr .pastdmark  
340a ..			.dmark: db "DO7"  
340d f1			.pastdmark: pop af  
340e			endm  
# End of macro DMARK
340e						CALLMONITOR 
340e cd c6 18			call break_point_state  
3411				endm  
# End of macro CALLMONITOR
3411					endif 
3411					FORTH_LOOP_NEXT 
3411 cd 62 21			call macro_forth_loop_next 
3414				endm 
# End of macro FORTH_LOOP_NEXT
3414			 
3414			 
3414					; init first round of I counter 
3414			 
3414 22 73 f6				ld (os_current_i), hl 
3417			 
3417					if DEBUG_FORTH_WORDS 
3417						DMARK "DO8" 
3417 f5				push af  
3418 3a 2c 34			ld a, (.dmark)  
341b 32 b4 fe			ld (debug_mark),a  
341e 3a 2d 34			ld a, (.dmark+1)  
3421 32 b5 fe			ld (debug_mark+1),a  
3424 3a 2e 34			ld a, (.dmark+2)  
3427 32 b6 fe			ld (debug_mark+2),a  
342a 18 03			jr .pastdmark  
342c ..			.dmark: db "DO8"  
342f f1			.pastdmark: pop af  
3430			endm  
# End of macro DMARK
3430						CALLMONITOR 
3430 cd c6 18			call break_point_state  
3433				endm  
# End of macro CALLMONITOR
3433					endif 
3433			 
3433					NEXTW 
3433 c3 e7 22			jp macro_next 
3436				endm 
# End of macro NEXTW
3436			.LOOP: 
3436				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3436 22				db WORD_SYS_CORE+14             
3437 4e 35			dw .I            
3439 05				db 4 + 1 
343a .. 00			db "LOOP",0              
343f				endm 
# End of macro CWHEAD
343f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
343f			 
343f				; pop tos as current loop count to hl 
343f			 
343f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
343f			 
343f				FORTH_LOOP_TOS 
343f cd 95 21			call macro_forth_loop_tos 
3442				endm 
# End of macro FORTH_LOOP_TOS
3442 e5				push hl 
3443			 
3443					if DEBUG_FORTH_WORDS_KEY 
3443						DMARK "LOP" 
3443 f5				push af  
3444 3a 58 34			ld a, (.dmark)  
3447 32 b4 fe			ld (debug_mark),a  
344a 3a 59 34			ld a, (.dmark+1)  
344d 32 b5 fe			ld (debug_mark+1),a  
3450 3a 5a 34			ld a, (.dmark+2)  
3453 32 b6 fe			ld (debug_mark+2),a  
3456 18 03			jr .pastdmark  
3458 ..			.dmark: db "LOP"  
345b f1			.pastdmark: pop af  
345c			endm  
# End of macro DMARK
345c						CALLMONITOR 
345c cd c6 18			call break_point_state  
345f				endm  
# End of macro CALLMONITOR
345f					endif 
345f				; next item on the stack is the limit. get it 
345f			 
345f			 
345f				FORTH_LOOP_POP 
345f cd 9f 21			call macro_forth_loop_pop 
3462				endm 
# End of macro FORTH_LOOP_POP
3462			 
3462				FORTH_LOOP_TOS 
3462 cd 95 21			call macro_forth_loop_tos 
3465				endm 
# End of macro FORTH_LOOP_TOS
3465			 
3465 d1				pop de		 ; de = i, hl = limit 
3466			 
3466					if DEBUG_FORTH_WORDS 
3466						DMARK "LP1" 
3466 f5				push af  
3467 3a 7b 34			ld a, (.dmark)  
346a 32 b4 fe			ld (debug_mark),a  
346d 3a 7c 34			ld a, (.dmark+1)  
3470 32 b5 fe			ld (debug_mark+1),a  
3473 3a 7d 34			ld a, (.dmark+2)  
3476 32 b6 fe			ld (debug_mark+2),a  
3479 18 03			jr .pastdmark  
347b ..			.dmark: db "LP1"  
347e f1			.pastdmark: pop af  
347f			endm  
# End of macro DMARK
347f						CALLMONITOR 
347f cd c6 18			call break_point_state  
3482				endm  
# End of macro CALLMONITOR
3482					endif 
3482			 
3482				; go back to previous word 
3482			 
3482 d5				push de    ; save I for inc later 
3483			 
3483			 
3483				; get limit 
3483				;  is I at limit? 
3483			 
3483			 
3483					if DEBUG_FORTH_WORDS 
3483						DMARK "LP1" 
3483 f5				push af  
3484 3a 98 34			ld a, (.dmark)  
3487 32 b4 fe			ld (debug_mark),a  
348a 3a 99 34			ld a, (.dmark+1)  
348d 32 b5 fe			ld (debug_mark+1),a  
3490 3a 9a 34			ld a, (.dmark+2)  
3493 32 b6 fe			ld (debug_mark+2),a  
3496 18 03			jr .pastdmark  
3498 ..			.dmark: db "LP1"  
349b f1			.pastdmark: pop af  
349c			endm  
# End of macro DMARK
349c						CALLMONITOR 
349c cd c6 18			call break_point_state  
349f				endm  
# End of macro CALLMONITOR
349f					endif 
349f			 
349f ed 52			sbc hl, de 
34a1			 
34a1			 
34a1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
34a1			 
34a1 20 26				jr nz, .loopnotdone 
34a3			 
34a3 e1				pop hl   ; get rid of saved I 
34a4				FORTH_LOOP_POP     ; get rid of limit 
34a4 cd 9f 21			call macro_forth_loop_pop 
34a7				endm 
# End of macro FORTH_LOOP_POP
34a7			 
34a7				FORTH_RSP_POP     ; get rid of DO ptr 
34a7 cd 02 1f			call macro_forth_rsp_pop 
34aa				endm 
# End of macro FORTH_RSP_POP
34aa			 
34aa			if DEBUG_FORTH_WORDS 
34aa						DMARK "LP>" 
34aa f5				push af  
34ab 3a bf 34			ld a, (.dmark)  
34ae 32 b4 fe			ld (debug_mark),a  
34b1 3a c0 34			ld a, (.dmark+1)  
34b4 32 b5 fe			ld (debug_mark+1),a  
34b7 3a c1 34			ld a, (.dmark+2)  
34ba 32 b6 fe			ld (debug_mark+2),a  
34bd 18 03			jr .pastdmark  
34bf ..			.dmark: db "LP>"  
34c2 f1			.pastdmark: pop af  
34c3			endm  
# End of macro DMARK
34c3				CALLMONITOR 
34c3 cd c6 18			call break_point_state  
34c6				endm  
# End of macro CALLMONITOR
34c6			endif 
34c6			 
34c6					NEXTW 
34c6 c3 e7 22			jp macro_next 
34c9				endm 
# End of macro NEXTW
34c9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34c9			 
34c9			.loopnotdone: 
34c9			 
34c9 e1				pop hl    ; get I 
34ca 23				inc hl 
34cb			 
34cb			   	; save new I 
34cb			 
34cb			 
34cb					; set I counter 
34cb			 
34cb 22 73 f6				ld (os_current_i), hl 
34ce			 
34ce					if DEBUG_FORTH_WORDS 
34ce						DMARK "LPN" 
34ce f5				push af  
34cf 3a e3 34			ld a, (.dmark)  
34d2 32 b4 fe			ld (debug_mark),a  
34d5 3a e4 34			ld a, (.dmark+1)  
34d8 32 b5 fe			ld (debug_mark+1),a  
34db 3a e5 34			ld a, (.dmark+2)  
34de 32 b6 fe			ld (debug_mark+2),a  
34e1 18 03			jr .pastdmark  
34e3 ..			.dmark: db "LPN"  
34e6 f1			.pastdmark: pop af  
34e7			endm  
# End of macro DMARK
34e7					CALLMONITOR 
34e7 cd c6 18			call break_point_state  
34ea				endm  
# End of macro CALLMONITOR
34ea					endif 
34ea					 
34ea				FORTH_LOOP_NEXT 
34ea cd 62 21			call macro_forth_loop_next 
34ed				endm 
# End of macro FORTH_LOOP_NEXT
34ed			 
34ed			 
34ed					if DEBUG_FORTH_WORDS 
34ed eb						ex de,hl 
34ee					endif 
34ee			 
34ee			;	; get DO ptr 
34ee			; 
34ee					if DEBUG_FORTH_WORDS 
34ee						DMARK "LP7" 
34ee f5				push af  
34ef 3a 03 35			ld a, (.dmark)  
34f2 32 b4 fe			ld (debug_mark),a  
34f5 3a 04 35			ld a, (.dmark+1)  
34f8 32 b5 fe			ld (debug_mark+1),a  
34fb 3a 05 35			ld a, (.dmark+2)  
34fe 32 b6 fe			ld (debug_mark+2),a  
3501 18 03			jr .pastdmark  
3503 ..			.dmark: db "LP7"  
3506 f1			.pastdmark: pop af  
3507			endm  
# End of macro DMARK
3507					CALLMONITOR 
3507 cd c6 18			call break_point_state  
350a				endm  
# End of macro CALLMONITOR
350a					endif 
350a				FORTH_RSP_TOS 
350a cd f8 1e			call macro_forth_rsp_tos 
350d				endm 
# End of macro FORTH_RSP_TOS
350d			 
350d					if DEBUG_FORTH_WORDS 
350d						DMARK "LP8" 
350d f5				push af  
350e 3a 22 35			ld a, (.dmark)  
3511 32 b4 fe			ld (debug_mark),a  
3514 3a 23 35			ld a, (.dmark+1)  
3517 32 b5 fe			ld (debug_mark+1),a  
351a 3a 24 35			ld a, (.dmark+2)  
351d 32 b6 fe			ld (debug_mark+2),a  
3520 18 03			jr .pastdmark  
3522 ..			.dmark: db "LP8"  
3525 f1			.pastdmark: pop af  
3526			endm  
# End of macro DMARK
3526					CALLMONITOR 
3526 cd c6 18			call break_point_state  
3529				endm  
# End of macro CALLMONITOR
3529					endif 
3529				;push hl 
3529			 
3529				; not going to DO any more 
3529				; get rid of the RSP pointer as DO will add it back in 
3529				;FORTH_RSP_POP 
3529				;pop hl 
3529			 
3529				;ld hl,(cli_ret_sp) 
3529				;ld e, (hl) 
3529				;inc hl 
3529				;ld d, (hl) 
3529				;ex de,hl 
3529 22 4f f6			ld (os_tok_ptr), hl 
352c					if DEBUG_FORTH_WORDS 
352c						DMARK "LP<" 
352c f5				push af  
352d 3a 41 35			ld a, (.dmark)  
3530 32 b4 fe			ld (debug_mark),a  
3533 3a 42 35			ld a, (.dmark+1)  
3536 32 b5 fe			ld (debug_mark+1),a  
3539 3a 43 35			ld a, (.dmark+2)  
353c 32 b6 fe			ld (debug_mark+2),a  
353f 18 03			jr .pastdmark  
3541 ..			.dmark: db "LP<"  
3544 f1			.pastdmark: pop af  
3545			endm  
# End of macro DMARK
3545					CALLMONITOR 
3545 cd c6 18			call break_point_state  
3548				endm  
# End of macro CALLMONITOR
3548				endif 
3548 c3 78 23			jp exec1 
354b			 
354b					 
354b			 
354b			 
354b					NEXTW 
354b c3 e7 22			jp macro_next 
354e				endm 
# End of macro NEXTW
354e			.I:  
354e			 
354e				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
354e 5e				db WORD_SYS_CORE+74             
354f 79 35			dw .DLOOP            
3551 02				db 1 + 1 
3552 .. 00			db "I",0              
3554				endm 
# End of macro CWHEAD
3554			; | I ( -- ) Current loop counter | DONE 
3554					if DEBUG_FORTH_WORDS_KEY 
3554						DMARK "I.." 
3554 f5				push af  
3555 3a 69 35			ld a, (.dmark)  
3558 32 b4 fe			ld (debug_mark),a  
355b 3a 6a 35			ld a, (.dmark+1)  
355e 32 b5 fe			ld (debug_mark+1),a  
3561 3a 6b 35			ld a, (.dmark+2)  
3564 32 b6 fe			ld (debug_mark+2),a  
3567 18 03			jr .pastdmark  
3569 ..			.dmark: db "I.."  
356c f1			.pastdmark: pop af  
356d			endm  
# End of macro DMARK
356d						CALLMONITOR 
356d cd c6 18			call break_point_state  
3570				endm  
# End of macro CALLMONITOR
3570					endif 
3570			 
3570 2a 73 f6				ld hl,(os_current_i) 
3573 cd 3a 1f				call forth_push_numhl 
3576			 
3576					NEXTW 
3576 c3 e7 22			jp macro_next 
3579				endm 
# End of macro NEXTW
3579			.DLOOP: 
3579				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3579 5f				db WORD_SYS_CORE+75             
357a 5a 36			dw .REPEAT            
357c 06				db 5 + 1 
357d .. 00			db "-LOOP",0              
3583				endm 
# End of macro CWHEAD
3583			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3583				; pop tos as current loop count to hl 
3583					if DEBUG_FORTH_WORDS_KEY 
3583						DMARK "-LP" 
3583 f5				push af  
3584 3a 98 35			ld a, (.dmark)  
3587 32 b4 fe			ld (debug_mark),a  
358a 3a 99 35			ld a, (.dmark+1)  
358d 32 b5 fe			ld (debug_mark+1),a  
3590 3a 9a 35			ld a, (.dmark+2)  
3593 32 b6 fe			ld (debug_mark+2),a  
3596 18 03			jr .pastdmark  
3598 ..			.dmark: db "-LP"  
359b f1			.pastdmark: pop af  
359c			endm  
# End of macro DMARK
359c						CALLMONITOR 
359c cd c6 18			call break_point_state  
359f				endm  
# End of macro CALLMONITOR
359f					endif 
359f			 
359f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
359f			 
359f				FORTH_LOOP_TOS 
359f cd 95 21			call macro_forth_loop_tos 
35a2				endm 
# End of macro FORTH_LOOP_TOS
35a2 e5				push hl 
35a3			 
35a3					if DEBUG_FORTH_WORDS 
35a3						DMARK "-LP" 
35a3 f5				push af  
35a4 3a b8 35			ld a, (.dmark)  
35a7 32 b4 fe			ld (debug_mark),a  
35aa 3a b9 35			ld a, (.dmark+1)  
35ad 32 b5 fe			ld (debug_mark+1),a  
35b0 3a ba 35			ld a, (.dmark+2)  
35b3 32 b6 fe			ld (debug_mark+2),a  
35b6 18 03			jr .pastdmark  
35b8 ..			.dmark: db "-LP"  
35bb f1			.pastdmark: pop af  
35bc			endm  
# End of macro DMARK
35bc						CALLMONITOR 
35bc cd c6 18			call break_point_state  
35bf				endm  
# End of macro CALLMONITOR
35bf					endif 
35bf				; next item on the stack is the limit. get it 
35bf			 
35bf			 
35bf				FORTH_LOOP_POP 
35bf cd 9f 21			call macro_forth_loop_pop 
35c2				endm 
# End of macro FORTH_LOOP_POP
35c2			 
35c2				FORTH_LOOP_TOS 
35c2 cd 95 21			call macro_forth_loop_tos 
35c5				endm 
# End of macro FORTH_LOOP_TOS
35c5			 
35c5 d1				pop de		 ; de = i, hl = limit 
35c6			 
35c6					if DEBUG_FORTH_WORDS 
35c6						DMARK "-L1" 
35c6 f5				push af  
35c7 3a db 35			ld a, (.dmark)  
35ca 32 b4 fe			ld (debug_mark),a  
35cd 3a dc 35			ld a, (.dmark+1)  
35d0 32 b5 fe			ld (debug_mark+1),a  
35d3 3a dd 35			ld a, (.dmark+2)  
35d6 32 b6 fe			ld (debug_mark+2),a  
35d9 18 03			jr .pastdmark  
35db ..			.dmark: db "-L1"  
35de f1			.pastdmark: pop af  
35df			endm  
# End of macro DMARK
35df						CALLMONITOR 
35df cd c6 18			call break_point_state  
35e2				endm  
# End of macro CALLMONITOR
35e2					endif 
35e2			 
35e2				; go back to previous word 
35e2			 
35e2 d5				push de    ; save I for inc later 
35e3			 
35e3			 
35e3				; get limit 
35e3				;  is I at limit? 
35e3			 
35e3			 
35e3					if DEBUG_FORTH_WORDS 
35e3						DMARK "-L1" 
35e3 f5				push af  
35e4 3a f8 35			ld a, (.dmark)  
35e7 32 b4 fe			ld (debug_mark),a  
35ea 3a f9 35			ld a, (.dmark+1)  
35ed 32 b5 fe			ld (debug_mark+1),a  
35f0 3a fa 35			ld a, (.dmark+2)  
35f3 32 b6 fe			ld (debug_mark+2),a  
35f6 18 03			jr .pastdmark  
35f8 ..			.dmark: db "-L1"  
35fb f1			.pastdmark: pop af  
35fc			endm  
# End of macro DMARK
35fc						CALLMONITOR 
35fc cd c6 18			call break_point_state  
35ff				endm  
# End of macro CALLMONITOR
35ff					endif 
35ff			 
35ff ed 52			sbc hl, de 
3601			 
3601			 
3601				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3601			 
3601 20 26				jr nz, .mloopnotdone 
3603			 
3603 e1				pop hl   ; get rid of saved I 
3604				FORTH_LOOP_POP     ; get rid of limit 
3604 cd 9f 21			call macro_forth_loop_pop 
3607				endm 
# End of macro FORTH_LOOP_POP
3607			 
3607				FORTH_RSP_POP     ; get rid of DO ptr 
3607 cd 02 1f			call macro_forth_rsp_pop 
360a				endm 
# End of macro FORTH_RSP_POP
360a			 
360a			if DEBUG_FORTH_WORDS 
360a						DMARK "-L>" 
360a f5				push af  
360b 3a 1f 36			ld a, (.dmark)  
360e 32 b4 fe			ld (debug_mark),a  
3611 3a 20 36			ld a, (.dmark+1)  
3614 32 b5 fe			ld (debug_mark+1),a  
3617 3a 21 36			ld a, (.dmark+2)  
361a 32 b6 fe			ld (debug_mark+2),a  
361d 18 03			jr .pastdmark  
361f ..			.dmark: db "-L>"  
3622 f1			.pastdmark: pop af  
3623			endm  
# End of macro DMARK
3623				CALLMONITOR 
3623 cd c6 18			call break_point_state  
3626				endm  
# End of macro CALLMONITOR
3626			endif 
3626			 
3626					NEXTW 
3626 c3 e7 22			jp macro_next 
3629				endm 
# End of macro NEXTW
3629				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3629			 
3629			.mloopnotdone: 
3629			 
3629 e1				pop hl    ; get I 
362a 2b				dec hl 
362b			 
362b			   	; save new I 
362b			 
362b			 
362b					; set I counter 
362b			 
362b 22 73 f6				ld (os_current_i), hl 
362e			 
362e					 
362e				FORTH_LOOP_NEXT 
362e cd 62 21			call macro_forth_loop_next 
3631				endm 
# End of macro FORTH_LOOP_NEXT
3631			 
3631			 
3631					if DEBUG_FORTH_WORDS 
3631 eb						ex de,hl 
3632					endif 
3632			 
3632			;	; get DO ptr 
3632			; 
3632				FORTH_RSP_TOS 
3632 cd f8 1e			call macro_forth_rsp_tos 
3635				endm 
# End of macro FORTH_RSP_TOS
3635			 
3635				;push hl 
3635			 
3635				; not going to DO any more 
3635				; get rid of the RSP pointer as DO will add it back in 
3635				;FORTH_RSP_POP 
3635				;pop hl 
3635			 
3635			 
3635 22 4f f6			ld (os_tok_ptr), hl 
3638					if DEBUG_FORTH_WORDS 
3638						DMARK "-L<" 
3638 f5				push af  
3639 3a 4d 36			ld a, (.dmark)  
363c 32 b4 fe			ld (debug_mark),a  
363f 3a 4e 36			ld a, (.dmark+1)  
3642 32 b5 fe			ld (debug_mark+1),a  
3645 3a 4f 36			ld a, (.dmark+2)  
3648 32 b6 fe			ld (debug_mark+2),a  
364b 18 03			jr .pastdmark  
364d ..			.dmark: db "-L<"  
3650 f1			.pastdmark: pop af  
3651			endm  
# End of macro DMARK
3651					CALLMONITOR 
3651 cd c6 18			call break_point_state  
3654				endm  
# End of macro CALLMONITOR
3654				endif 
3654 c3 78 23			jp exec1 
3657			 
3657					 
3657			 
3657			 
3657			 
3657				NEXTW 
3657 c3 e7 22			jp macro_next 
365a				endm 
# End of macro NEXTW
365a			 
365a			 
365a			 
365a			 
365a			.REPEAT: 
365a				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
365a 71				db WORD_SYS_CORE+93             
365b ad 36			dw .UNTIL            
365d 06				db 5 + 1 
365e .. 00			db "REPEAT",0              
3665				endm 
# End of macro CWHEAD
3665			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3665			;  push pc to rsp stack past the REPEAT 
3665					if DEBUG_FORTH_WORDS_KEY 
3665						DMARK "REP" 
3665 f5				push af  
3666 3a 7a 36			ld a, (.dmark)  
3669 32 b4 fe			ld (debug_mark),a  
366c 3a 7b 36			ld a, (.dmark+1)  
366f 32 b5 fe			ld (debug_mark+1),a  
3672 3a 7c 36			ld a, (.dmark+2)  
3675 32 b6 fe			ld (debug_mark+2),a  
3678 18 03			jr .pastdmark  
367a ..			.dmark: db "REP"  
367d f1			.pastdmark: pop af  
367e			endm  
# End of macro DMARK
367e						CALLMONITOR 
367e cd c6 18			call break_point_state  
3681				endm  
# End of macro CALLMONITOR
3681					endif 
3681			 
3681 2a 4f f6				ld hl, (os_tok_ptr) 
3684 23					inc hl   ; R 
3685 23					inc hl  ; E 
3686 23					inc hl   ; P 
3687 23					inc hl   ; E 
3688 23					inc hl   ; A 
3689 23					inc hl   ; T 
368a 23					inc hl   ; zero 
368b					FORTH_RSP_NEXT 
368b cd e1 1e			call macro_forth_rsp_next 
368e				endm 
# End of macro FORTH_RSP_NEXT
368e			 
368e			 
368e					if DEBUG_FORTH_WORDS 
368e						DMARK "REP" 
368e f5				push af  
368f 3a a3 36			ld a, (.dmark)  
3692 32 b4 fe			ld (debug_mark),a  
3695 3a a4 36			ld a, (.dmark+1)  
3698 32 b5 fe			ld (debug_mark+1),a  
369b 3a a5 36			ld a, (.dmark+2)  
369e 32 b6 fe			ld (debug_mark+2),a  
36a1 18 03			jr .pastdmark  
36a3 ..			.dmark: db "REP"  
36a6 f1			.pastdmark: pop af  
36a7			endm  
# End of macro DMARK
36a7						;pop bc    ; TODO BUG ?????? what is this for???? 
36a7						CALLMONITOR 
36a7 cd c6 18			call break_point_state  
36aa				endm  
# End of macro CALLMONITOR
36aa					endif 
36aa			 
36aa					NEXTW 
36aa c3 e7 22			jp macro_next 
36ad				endm 
# End of macro NEXTW
36ad			;	       NEXTW 
36ad			 
36ad			.UNTIL: 
36ad				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36ad 72				db WORD_SYS_CORE+94             
36ae 44 37			dw .ENDFLOW            
36b0 06				db 5 + 1 
36b1 .. 00			db "UNTIL",0              
36b7				endm 
# End of macro CWHEAD
36b7			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36b7			 
36b7				; pop tos as check 
36b7			 
36b7				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36b7			 
36b7				FORTH_DSP_VALUEHL 
36b7 cd 31 21			call macro_dsp_valuehl 
36ba				endm 
# End of macro FORTH_DSP_VALUEHL
36ba			 
36ba					if DEBUG_FORTH_WORDS_KEY 
36ba						DMARK "UNT" 
36ba f5				push af  
36bb 3a cf 36			ld a, (.dmark)  
36be 32 b4 fe			ld (debug_mark),a  
36c1 3a d0 36			ld a, (.dmark+1)  
36c4 32 b5 fe			ld (debug_mark+1),a  
36c7 3a d1 36			ld a, (.dmark+2)  
36ca 32 b6 fe			ld (debug_mark+2),a  
36cd 18 03			jr .pastdmark  
36cf ..			.dmark: db "UNT"  
36d2 f1			.pastdmark: pop af  
36d3			endm  
# End of macro DMARK
36d3						CALLMONITOR 
36d3 cd c6 18			call break_point_state  
36d6				endm  
# End of macro CALLMONITOR
36d6					endif 
36d6			 
36d6			;	push hl 
36d6				FORTH_DSP_POP 
36d6 cd e9 21			call macro_forth_dsp_pop 
36d9				endm 
# End of macro FORTH_DSP_POP
36d9			 
36d9			;	pop hl 
36d9			 
36d9				; test if true 
36d9			 
36d9 cd 72 0f			call ishlzero 
36dc			;	ld a,l 
36dc			;	add h 
36dc			; 
36dc			;	cp 0 
36dc			 
36dc 20 3e			jr nz, .untilnotdone 
36de			 
36de					if DEBUG_FORTH_WORDS 
36de						DMARK "UNf" 
36de f5				push af  
36df 3a f3 36			ld a, (.dmark)  
36e2 32 b4 fe			ld (debug_mark),a  
36e5 3a f4 36			ld a, (.dmark+1)  
36e8 32 b5 fe			ld (debug_mark+1),a  
36eb 3a f5 36			ld a, (.dmark+2)  
36ee 32 b6 fe			ld (debug_mark+2),a  
36f1 18 03			jr .pastdmark  
36f3 ..			.dmark: db "UNf"  
36f6 f1			.pastdmark: pop af  
36f7			endm  
# End of macro DMARK
36f7						CALLMONITOR 
36f7 cd c6 18			call break_point_state  
36fa				endm  
# End of macro CALLMONITOR
36fa					endif 
36fa			 
36fa			 
36fa			 
36fa				FORTH_RSP_POP     ; get rid of DO ptr 
36fa cd 02 1f			call macro_forth_rsp_pop 
36fd				endm 
# End of macro FORTH_RSP_POP
36fd			 
36fd			if DEBUG_FORTH_WORDS 
36fd						DMARK "UN>" 
36fd f5				push af  
36fe 3a 12 37			ld a, (.dmark)  
3701 32 b4 fe			ld (debug_mark),a  
3704 3a 13 37			ld a, (.dmark+1)  
3707 32 b5 fe			ld (debug_mark+1),a  
370a 3a 14 37			ld a, (.dmark+2)  
370d 32 b6 fe			ld (debug_mark+2),a  
3710 18 03			jr .pastdmark  
3712 ..			.dmark: db "UN>"  
3715 f1			.pastdmark: pop af  
3716			endm  
# End of macro DMARK
3716				CALLMONITOR 
3716 cd c6 18			call break_point_state  
3719				endm  
# End of macro CALLMONITOR
3719			endif 
3719			 
3719					NEXTW 
3719 c3 e7 22			jp macro_next 
371c				endm 
# End of macro NEXTW
371c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
371c			 
371c			.untilnotdone: 
371c			 
371c			 
371c			;	; get DO ptr 
371c			; 
371c				FORTH_RSP_TOS 
371c cd f8 1e			call macro_forth_rsp_tos 
371f				endm 
# End of macro FORTH_RSP_TOS
371f			 
371f				;push hl 
371f			 
371f				; not going to DO any more 
371f				; get rid of the RSP pointer as DO will add it back in 
371f				;FORTH_RSP_POP 
371f				;pop hl 
371f			 
371f			 
371f 22 4f f6			ld (os_tok_ptr), hl 
3722					if DEBUG_FORTH_WORDS 
3722						DMARK "UN<" 
3722 f5				push af  
3723 3a 37 37			ld a, (.dmark)  
3726 32 b4 fe			ld (debug_mark),a  
3729 3a 38 37			ld a, (.dmark+1)  
372c 32 b5 fe			ld (debug_mark+1),a  
372f 3a 39 37			ld a, (.dmark+2)  
3732 32 b6 fe			ld (debug_mark+2),a  
3735 18 03			jr .pastdmark  
3737 ..			.dmark: db "UN<"  
373a f1			.pastdmark: pop af  
373b			endm  
# End of macro DMARK
373b					CALLMONITOR 
373b cd c6 18			call break_point_state  
373e				endm  
# End of macro CALLMONITOR
373e				endif 
373e c3 78 23			jp exec1 
3741			 
3741					 
3741			 
3741			 
3741					NEXTW 
3741 c3 e7 22			jp macro_next 
3744				endm 
# End of macro NEXTW
3744			 
3744			 
3744			.ENDFLOW: 
3744			 
3744			; eof 
3744			 
# End of file forth_words_flow.asm
3744			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3744			include "forth_words_logic.asm" 
3744			 
3744			; | ## Logic Words 
3744			 
3744			.NOT: 
3744				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3744 2d				db WORD_SYS_CORE+25             
3745 8c 37			dw .IS            
3747 04				db 3 + 1 
3748 .. 00			db "NOT",0              
374c				endm 
# End of macro CWHEAD
374c			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
374c					if DEBUG_FORTH_WORDS_KEY 
374c						DMARK "NOT" 
374c f5				push af  
374d 3a 61 37			ld a, (.dmark)  
3750 32 b4 fe			ld (debug_mark),a  
3753 3a 62 37			ld a, (.dmark+1)  
3756 32 b5 fe			ld (debug_mark+1),a  
3759 3a 63 37			ld a, (.dmark+2)  
375c 32 b6 fe			ld (debug_mark+2),a  
375f 18 03			jr .pastdmark  
3761 ..			.dmark: db "NOT"  
3764 f1			.pastdmark: pop af  
3765			endm  
# End of macro DMARK
3765						CALLMONITOR 
3765 cd c6 18			call break_point_state  
3768				endm  
# End of macro CALLMONITOR
3768					endif 
3768					FORTH_DSP 
3768 cd f7 20			call macro_forth_dsp 
376b				endm 
# End of macro FORTH_DSP
376b 7e					ld a,(hl)	; get type of value on TOS 
376c fe 02				cp DS_TYPE_INUM  
376e 28 03				jr z, .noti 
3770					NEXTW 
3770 c3 e7 22			jp macro_next 
3773				endm 
# End of macro NEXTW
3773			.noti:          FORTH_DSP_VALUEHL 
3773 cd 31 21			call macro_dsp_valuehl 
3776				endm 
# End of macro FORTH_DSP_VALUEHL
3776			;		push hl 
3776					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3776 cd e9 21			call macro_forth_dsp_pop 
3779				endm 
# End of macro FORTH_DSP_POP
3779			;		pop hl 
3779 3e 00				ld a,0 
377b bd					cp l 
377c 28 04				jr z, .not2t 
377e 2e 00				ld l, 0 
3780 18 02				jr .notip 
3782			 
3782 2e ff		.not2t:		ld l, 255 
3784			 
3784 26 00		.notip:		ld h, 0	 
3786			 
3786 cd 3a 1f				call forth_push_numhl 
3789					NEXTW 
3789 c3 e7 22			jp macro_next 
378c				endm 
# End of macro NEXTW
378c			 
378c			.IS: 
378c				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
378c 2d				db WORD_SYS_CORE+25             
378d b2 37			dw .LZERO            
378f 03				db 2 + 1 
3790 .. 00			db "IS",0              
3793				endm 
# End of macro CWHEAD
3793			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3793					if DEBUG_FORTH_WORDS_KEY 
3793						DMARK "IS." 
3793 f5				push af  
3794 3a a8 37			ld a, (.dmark)  
3797 32 b4 fe			ld (debug_mark),a  
379a 3a a9 37			ld a, (.dmark+1)  
379d 32 b5 fe			ld (debug_mark+1),a  
37a0 3a aa 37			ld a, (.dmark+2)  
37a3 32 b6 fe			ld (debug_mark+2),a  
37a6 18 03			jr .pastdmark  
37a8 ..			.dmark: db "IS."  
37ab f1			.pastdmark: pop af  
37ac			endm  
# End of macro DMARK
37ac						CALLMONITOR 
37ac cd c6 18			call break_point_state  
37af				endm  
# End of macro CALLMONITOR
37af					endif 
37af					NEXTW 
37af c3 e7 22			jp macro_next 
37b2				endm 
# End of macro NEXTW
37b2			.LZERO: 
37b2				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37b2 2d				db WORD_SYS_CORE+25             
37b3 bc 37			dw .TZERO            
37b5 03				db 2 + 1 
37b6 .. 00			db "0<",0              
37b9				endm 
# End of macro CWHEAD
37b9			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37b9					NEXTW 
37b9 c3 e7 22			jp macro_next 
37bc				endm 
# End of macro NEXTW
37bc			.TZERO: 
37bc				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37bc 2e				db WORD_SYS_CORE+26             
37bd 03 38			dw .LESS            
37bf 03				db 2 + 1 
37c0 .. 00			db "0=",0              
37c3				endm 
# End of macro CWHEAD
37c3			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
37c3				; TODO add floating point number detection 
37c3					;v5 FORTH_DSP_VALUE 
37c3					if DEBUG_FORTH_WORDS_KEY 
37c3						DMARK "0=." 
37c3 f5				push af  
37c4 3a d8 37			ld a, (.dmark)  
37c7 32 b4 fe			ld (debug_mark),a  
37ca 3a d9 37			ld a, (.dmark+1)  
37cd 32 b5 fe			ld (debug_mark+1),a  
37d0 3a da 37			ld a, (.dmark+2)  
37d3 32 b6 fe			ld (debug_mark+2),a  
37d6 18 03			jr .pastdmark  
37d8 ..			.dmark: db "0=."  
37db f1			.pastdmark: pop af  
37dc			endm  
# End of macro DMARK
37dc						CALLMONITOR 
37dc cd c6 18			call break_point_state  
37df				endm  
# End of macro CALLMONITOR
37df					endif 
37df					FORTH_DSP 
37df cd f7 20			call macro_forth_dsp 
37e2				endm 
# End of macro FORTH_DSP
37e2 7e					ld a,(hl)	; get type of value on TOS 
37e3 fe 02				cp DS_TYPE_INUM  
37e5 28 00				jr z, .tz_inum 
37e7			 
37e7				if FORTH_ENABLE_FLOATMATH 
37e7					jr .tz_done 
37e7			 
37e7				endif 
37e7					 
37e7			 
37e7			.tz_inum: 
37e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e7 cd 31 21			call macro_dsp_valuehl 
37ea				endm 
# End of macro FORTH_DSP_VALUEHL
37ea			 
37ea			;		push hl 
37ea			 
37ea					; destroy value TOS 
37ea			 
37ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ea cd e9 21			call macro_forth_dsp_pop 
37ed				endm 
# End of macro FORTH_DSP_POP
37ed			 
37ed			;		pop hl 
37ed			 
37ed 3e 00				ld a,0 
37ef			 
37ef bd					cp l 
37f0 20 08				jr nz, .tz_notzero 
37f2			 
37f2 bc					cp h 
37f3			 
37f3 20 05				jr nz, .tz_notzero 
37f5			 
37f5			 
37f5 21 01 00				ld hl, FORTH_TRUE 
37f8 18 03				jr .tz_done 
37fa			 
37fa 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
37fd			 
37fd					; push value back onto stack for another op etc 
37fd			 
37fd			.tz_done: 
37fd cd 3a 1f				call forth_push_numhl 
3800			 
3800					NEXTW 
3800 c3 e7 22			jp macro_next 
3803				endm 
# End of macro NEXTW
3803			.LESS: 
3803				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3803 2f				db WORD_SYS_CORE+27             
3804 6c 38			dw .GT            
3806 02				db 1 + 1 
3807 .. 00			db "<",0              
3809				endm 
# End of macro CWHEAD
3809			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3809				; TODO add floating point number detection 
3809					if DEBUG_FORTH_WORDS_KEY 
3809						DMARK "LES" 
3809 f5				push af  
380a 3a 1e 38			ld a, (.dmark)  
380d 32 b4 fe			ld (debug_mark),a  
3810 3a 1f 38			ld a, (.dmark+1)  
3813 32 b5 fe			ld (debug_mark+1),a  
3816 3a 20 38			ld a, (.dmark+2)  
3819 32 b6 fe			ld (debug_mark+2),a  
381c 18 03			jr .pastdmark  
381e ..			.dmark: db "LES"  
3821 f1			.pastdmark: pop af  
3822			endm  
# End of macro DMARK
3822						CALLMONITOR 
3822 cd c6 18			call break_point_state  
3825				endm  
# End of macro CALLMONITOR
3825					endif 
3825					FORTH_DSP 
3825 cd f7 20			call macro_forth_dsp 
3828				endm 
# End of macro FORTH_DSP
3828					;v5 FORTH_DSP_VALUE 
3828 7e					ld a,(hl)	; get type of value on TOS 
3829 fe 02				cp DS_TYPE_INUM  
382b 28 00				jr z, .less_inum 
382d			 
382d				if FORTH_ENABLE_FLOATMATH 
382d					jr .less_done 
382d			 
382d				endif 
382d					 
382d			 
382d			.less_inum: 
382d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
382d cd 31 21			call macro_dsp_valuehl 
3830				endm 
# End of macro FORTH_DSP_VALUEHL
3830			 
3830 e5					push hl  ; u2 
3831			 
3831					; destroy value TOS 
3831			 
3831					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3831 cd e9 21			call macro_forth_dsp_pop 
3834				endm 
# End of macro FORTH_DSP_POP
3834			 
3834			 
3834					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3834 cd 31 21			call macro_dsp_valuehl 
3837				endm 
# End of macro FORTH_DSP_VALUEHL
3837			 
3837 e5					push hl    ; u1 
3838			 
3838					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3838 cd e9 21			call macro_forth_dsp_pop 
383b				endm 
# End of macro FORTH_DSP_POP
383b			 
383b			 
383b b7			 or a      ;clear carry flag 
383c 01 00 00		 ld bc, FORTH_FALSE 
383f e1			  pop hl    ; u1 
3840 d1			  pop de    ; u2 
3841 ed 52		  sbc hl,de 
3843 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3845			 
3845 01 01 00		 ld bc, FORTH_TRUE 
3848			.lscont:  
3848 c5					push bc 
3849 e1					pop hl 
384a			 
384a					if DEBUG_FORTH_WORDS 
384a						DMARK "LT1" 
384a f5				push af  
384b 3a 5f 38			ld a, (.dmark)  
384e 32 b4 fe			ld (debug_mark),a  
3851 3a 60 38			ld a, (.dmark+1)  
3854 32 b5 fe			ld (debug_mark+1),a  
3857 3a 61 38			ld a, (.dmark+2)  
385a 32 b6 fe			ld (debug_mark+2),a  
385d 18 03			jr .pastdmark  
385f ..			.dmark: db "LT1"  
3862 f1			.pastdmark: pop af  
3863			endm  
# End of macro DMARK
3863						CALLMONITOR 
3863 cd c6 18			call break_point_state  
3866				endm  
# End of macro CALLMONITOR
3866					endif 
3866 cd 3a 1f				call forth_push_numhl 
3869			 
3869					NEXTW 
3869 c3 e7 22			jp macro_next 
386c				endm 
# End of macro NEXTW
386c			.GT: 
386c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
386c 30				db WORD_SYS_CORE+28             
386d d5 38			dw .EQUAL            
386f 02				db 1 + 1 
3870 .. 00			db ">",0              
3872				endm 
# End of macro CWHEAD
3872			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3872				; TODO add floating point number detection 
3872					if DEBUG_FORTH_WORDS_KEY 
3872						DMARK "GRT" 
3872 f5				push af  
3873 3a 87 38			ld a, (.dmark)  
3876 32 b4 fe			ld (debug_mark),a  
3879 3a 88 38			ld a, (.dmark+1)  
387c 32 b5 fe			ld (debug_mark+1),a  
387f 3a 89 38			ld a, (.dmark+2)  
3882 32 b6 fe			ld (debug_mark+2),a  
3885 18 03			jr .pastdmark  
3887 ..			.dmark: db "GRT"  
388a f1			.pastdmark: pop af  
388b			endm  
# End of macro DMARK
388b						CALLMONITOR 
388b cd c6 18			call break_point_state  
388e				endm  
# End of macro CALLMONITOR
388e					endif 
388e					FORTH_DSP 
388e cd f7 20			call macro_forth_dsp 
3891				endm 
# End of macro FORTH_DSP
3891					;FORTH_DSP_VALUE 
3891 7e					ld a,(hl)	; get type of value on TOS 
3892 fe 02				cp DS_TYPE_INUM  
3894 28 00				jr z, .gt_inum 
3896			 
3896				if FORTH_ENABLE_FLOATMATH 
3896					jr .gt_done 
3896			 
3896				endif 
3896					 
3896			 
3896			.gt_inum: 
3896					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3896 cd 31 21			call macro_dsp_valuehl 
3899				endm 
# End of macro FORTH_DSP_VALUEHL
3899			 
3899 e5					push hl  ; u2 
389a			 
389a					; destroy value TOS 
389a			 
389a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
389a cd e9 21			call macro_forth_dsp_pop 
389d				endm 
# End of macro FORTH_DSP_POP
389d			 
389d			 
389d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
389d cd 31 21			call macro_dsp_valuehl 
38a0				endm 
# End of macro FORTH_DSP_VALUEHL
38a0			 
38a0 e5					push hl    ; u1 
38a1			 
38a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a1 cd e9 21			call macro_forth_dsp_pop 
38a4				endm 
# End of macro FORTH_DSP_POP
38a4			 
38a4			 
38a4 b7			 or a      ;clear carry flag 
38a5 01 00 00		 ld bc, FORTH_FALSE 
38a8 e1			  pop hl    ; u1 
38a9 d1			  pop de    ; u2 
38aa ed 52		  sbc hl,de 
38ac 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38ae			 
38ae 01 01 00		 ld bc, FORTH_TRUE 
38b1			.gtcont:  
38b1 c5					push bc 
38b2 e1					pop hl 
38b3			 
38b3					if DEBUG_FORTH_WORDS 
38b3						DMARK "GT1" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 b4 fe			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 b5 fe			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 b6 fe			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "GT1"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc						CALLMONITOR 
38cc cd c6 18			call break_point_state  
38cf				endm  
# End of macro CALLMONITOR
38cf					endif 
38cf cd 3a 1f				call forth_push_numhl 
38d2			 
38d2					NEXTW 
38d2 c3 e7 22			jp macro_next 
38d5				endm 
# End of macro NEXTW
38d5			.EQUAL: 
38d5				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38d5 31				db WORD_SYS_CORE+29             
38d6 40 39			dw .ENDLOGIC            
38d8 02				db 1 + 1 
38d9 .. 00			db "=",0              
38db				endm 
# End of macro CWHEAD
38db			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
38db				; TODO add floating point number detection 
38db					if DEBUG_FORTH_WORDS_KEY 
38db						DMARK "EQ." 
38db f5				push af  
38dc 3a f0 38			ld a, (.dmark)  
38df 32 b4 fe			ld (debug_mark),a  
38e2 3a f1 38			ld a, (.dmark+1)  
38e5 32 b5 fe			ld (debug_mark+1),a  
38e8 3a f2 38			ld a, (.dmark+2)  
38eb 32 b6 fe			ld (debug_mark+2),a  
38ee 18 03			jr .pastdmark  
38f0 ..			.dmark: db "EQ."  
38f3 f1			.pastdmark: pop af  
38f4			endm  
# End of macro DMARK
38f4						CALLMONITOR 
38f4 cd c6 18			call break_point_state  
38f7				endm  
# End of macro CALLMONITOR
38f7					endif 
38f7					FORTH_DSP 
38f7 cd f7 20			call macro_forth_dsp 
38fa				endm 
# End of macro FORTH_DSP
38fa					;v5 FORTH_DSP_VALUE 
38fa 7e					ld a,(hl)	; get type of value on TOS 
38fb fe 02				cp DS_TYPE_INUM  
38fd 28 00				jr z, .eq_inum 
38ff			 
38ff				if FORTH_ENABLE_FLOATMATH 
38ff					jr .eq_done 
38ff			 
38ff				endif 
38ff					 
38ff			 
38ff			.eq_inum: 
38ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ff cd 31 21			call macro_dsp_valuehl 
3902				endm 
# End of macro FORTH_DSP_VALUEHL
3902			 
3902 e5					push hl 
3903			 
3903					; destroy value TOS 
3903			 
3903					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3903 cd e9 21			call macro_forth_dsp_pop 
3906				endm 
# End of macro FORTH_DSP_POP
3906			 
3906			 
3906					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3906 cd 31 21			call macro_dsp_valuehl 
3909				endm 
# End of macro FORTH_DSP_VALUEHL
3909			 
3909					; one value on hl get other one back 
3909			 
3909 e5					push hl 
390a			 
390a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
390a cd e9 21			call macro_forth_dsp_pop 
390d				endm 
# End of macro FORTH_DSP_POP
390d			 
390d 0e 00				ld c, FORTH_FALSE 
390f			 
390f e1					pop hl 
3910 d1					pop de 
3911			 
3911 7b					ld a, e 
3912 bd					cp l 
3913			 
3913 20 06				jr nz, .eq_done 
3915			 
3915 7a					ld a, d 
3916 bc					cp h 
3917			 
3917 20 02				jr nz, .eq_done 
3919			 
3919 0e 01				ld c, FORTH_TRUE 
391b					 
391b			 
391b			 
391b			.eq_done: 
391b			 
391b					; TODO push value back onto stack for another op etc 
391b			 
391b 26 00				ld h, 0 
391d 69					ld l, c 
391e					if DEBUG_FORTH_WORDS 
391e						DMARK "EQ1" 
391e f5				push af  
391f 3a 33 39			ld a, (.dmark)  
3922 32 b4 fe			ld (debug_mark),a  
3925 3a 34 39			ld a, (.dmark+1)  
3928 32 b5 fe			ld (debug_mark+1),a  
392b 3a 35 39			ld a, (.dmark+2)  
392e 32 b6 fe			ld (debug_mark+2),a  
3931 18 03			jr .pastdmark  
3933 ..			.dmark: db "EQ1"  
3936 f1			.pastdmark: pop af  
3937			endm  
# End of macro DMARK
3937						CALLMONITOR 
3937 cd c6 18			call break_point_state  
393a				endm  
# End of macro CALLMONITOR
393a					endif 
393a cd 3a 1f				call forth_push_numhl 
393d			 
393d					NEXTW 
393d c3 e7 22			jp macro_next 
3940				endm 
# End of macro NEXTW
3940			 
3940			 
3940			.ENDLOGIC: 
3940			; eof 
3940			 
3940			 
# End of file forth_words_logic.asm
3940			include "forth_words_maths.asm" 
3940			 
3940			; | ## Maths Words 
3940			 
3940			.PLUS:	 
3940				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3940 15				db WORD_SYS_CORE+1             
3941 9e 39			dw .NEG            
3943 02				db 1 + 1 
3944 .. 00			db "+",0              
3946				endm 
# End of macro CWHEAD
3946			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3946					if DEBUG_FORTH_WORDS_KEY 
3946						DMARK "PLU" 
3946 f5				push af  
3947 3a 5b 39			ld a, (.dmark)  
394a 32 b4 fe			ld (debug_mark),a  
394d 3a 5c 39			ld a, (.dmark+1)  
3950 32 b5 fe			ld (debug_mark+1),a  
3953 3a 5d 39			ld a, (.dmark+2)  
3956 32 b6 fe			ld (debug_mark+2),a  
3959 18 03			jr .pastdmark  
395b ..			.dmark: db "PLU"  
395e f1			.pastdmark: pop af  
395f			endm  
# End of macro DMARK
395f						CALLMONITOR 
395f cd c6 18			call break_point_state  
3962				endm  
# End of macro CALLMONITOR
3962					endif 
3962					; add top two values and push back result 
3962			 
3962					;for v5 FORTH_DSP_VALUE 
3962					FORTH_DSP 
3962 cd f7 20			call macro_forth_dsp 
3965				endm 
# End of macro FORTH_DSP
3965 7e					ld a,(hl)	; get type of value on TOS 
3966 fe 02				cp DS_TYPE_INUM  
3968 28 03				jr z, .dot_inum 
396a			 
396a					NEXTW 
396a c3 e7 22			jp macro_next 
396d				endm 
# End of macro NEXTW
396d			 
396d			; float maths 
396d			 
396d				if FORTH_ENABLE_FLOATMATH 
396d						inc hl      ; now at start of numeric as string 
396d			 
396d					if DEBUG_FORTH_MATHS 
396d						DMARK "ADD" 
396d				CALLMONITOR 
396d					endif 
396d			 
396d					;ld ix, hl 
396d					call CON 
396d			 
396d			 
396d					push hl 
396d					 
396d					 
396d			 
396d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
396d			 
396d					; get next number 
396d			 
396d						FORTH_DSP_VALUE 
396d			 
396d						inc hl      ; now at start of numeric as string 
396d			 
396d					;ld ix, hl 
396d					call CON 
396d			 
396d					push hl 
396d			 
396d			 
396d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
396d			 
396d						; TODO do add 
396d			 
396d						call IADD 
396d			 
396d						; TODO get result back as ascii 
396d			 
396d						; TODO push result  
396d			 
396d			 
396d			 
396d						jr .dot_done 
396d				endif 
396d			 
396d			.dot_inum: 
396d			 
396d			 
396d					if DEBUG_FORTH_DOT 
396d						DMARK "+IT" 
396d f5				push af  
396e 3a 82 39			ld a, (.dmark)  
3971 32 b4 fe			ld (debug_mark),a  
3974 3a 83 39			ld a, (.dmark+1)  
3977 32 b5 fe			ld (debug_mark+1),a  
397a 3a 84 39			ld a, (.dmark+2)  
397d 32 b6 fe			ld (debug_mark+2),a  
3980 18 03			jr .pastdmark  
3982 ..			.dmark: db "+IT"  
3985 f1			.pastdmark: pop af  
3986			endm  
# End of macro DMARK
3986				CALLMONITOR 
3986 cd c6 18			call break_point_state  
3989				endm  
# End of macro CALLMONITOR
3989					endif 
3989			 
3989					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3989 cd 31 21			call macro_dsp_valuehl 
398c				endm 
# End of macro FORTH_DSP_VALUEHL
398c			 
398c				; TODO add floating point number detection 
398c			 
398c e5					push hl 
398d			 
398d					; destroy value TOS 
398d			 
398d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
398d cd e9 21			call macro_forth_dsp_pop 
3990				endm 
# End of macro FORTH_DSP_POP
3990			 
3990			 
3990					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3990 cd 31 21			call macro_dsp_valuehl 
3993				endm 
# End of macro FORTH_DSP_VALUEHL
3993			 
3993					; one value on hl get other one back 
3993			 
3993 d1					pop de 
3994			 
3994					; do the add 
3994			 
3994 19					add hl,de 
3995			 
3995					; save it 
3995			 
3995			;		push hl	 
3995			 
3995					; 
3995			 
3995					; destroy value TOS 
3995			 
3995					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3995 cd e9 21			call macro_forth_dsp_pop 
3998				endm 
# End of macro FORTH_DSP_POP
3998			 
3998					; TODO push value back onto stack for another op etc 
3998			 
3998			;		pop hl 
3998			 
3998			.dot_done: 
3998 cd 3a 1f				call forth_push_numhl 
399b			 
399b					NEXTW 
399b c3 e7 22			jp macro_next 
399e				endm 
# End of macro NEXTW
399e			.NEG: 
399e			 
399e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
399e 17				db WORD_SYS_CORE+3             
399f e1 39			dw .DIV            
39a1 02				db 1 + 1 
39a2 .. 00			db "-",0              
39a4				endm 
# End of macro CWHEAD
39a4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39a4					if DEBUG_FORTH_WORDS_KEY 
39a4						DMARK "SUB" 
39a4 f5				push af  
39a5 3a b9 39			ld a, (.dmark)  
39a8 32 b4 fe			ld (debug_mark),a  
39ab 3a ba 39			ld a, (.dmark+1)  
39ae 32 b5 fe			ld (debug_mark+1),a  
39b1 3a bb 39			ld a, (.dmark+2)  
39b4 32 b6 fe			ld (debug_mark+2),a  
39b7 18 03			jr .pastdmark  
39b9 ..			.dmark: db "SUB"  
39bc f1			.pastdmark: pop af  
39bd			endm  
# End of macro DMARK
39bd						CALLMONITOR 
39bd cd c6 18			call break_point_state  
39c0				endm  
# End of macro CALLMONITOR
39c0					endif 
39c0			 
39c0			 
39c0				; TODO add floating point number detection 
39c0					; v5 FORTH_DSP_VALUE 
39c0					FORTH_DSP 
39c0 cd f7 20			call macro_forth_dsp 
39c3				endm 
# End of macro FORTH_DSP
39c3 7e					ld a,(hl)	; get type of value on TOS 
39c4 fe 02				cp DS_TYPE_INUM  
39c6 28 03				jr z, .neg_inum 
39c8			 
39c8					NEXTW 
39c8 c3 e7 22			jp macro_next 
39cb				endm 
# End of macro NEXTW
39cb			 
39cb			; float maths 
39cb			 
39cb				if FORTH_ENABLE_FLOATMATH 
39cb					jr .neg_done 
39cb			 
39cb				endif 
39cb					 
39cb			 
39cb			.neg_inum: 
39cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39cb cd 31 21			call macro_dsp_valuehl 
39ce				endm 
# End of macro FORTH_DSP_VALUEHL
39ce			 
39ce e5					push hl 
39cf			 
39cf					; destroy value TOS 
39cf			 
39cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39cf cd e9 21			call macro_forth_dsp_pop 
39d2				endm 
# End of macro FORTH_DSP_POP
39d2			 
39d2			 
39d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39d2 cd 31 21			call macro_dsp_valuehl 
39d5				endm 
# End of macro FORTH_DSP_VALUEHL
39d5			 
39d5					; one value on hl get other one back 
39d5			 
39d5 d1					pop de 
39d6			 
39d6					; do the sub 
39d6			;		ex de, hl 
39d6			 
39d6 ed 52				sbc hl,de 
39d8			 
39d8					; save it 
39d8			 
39d8			;		push hl	 
39d8			 
39d8					; 
39d8			 
39d8					; destroy value TOS 
39d8			 
39d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d8 cd e9 21			call macro_forth_dsp_pop 
39db				endm 
# End of macro FORTH_DSP_POP
39db			 
39db					; TODO push value back onto stack for another op etc 
39db			 
39db			;		pop hl 
39db			 
39db cd 3a 1f				call forth_push_numhl 
39de			.neg_done: 
39de			 
39de					NEXTW 
39de c3 e7 22			jp macro_next 
39e1				endm 
# End of macro NEXTW
39e1			.DIV: 
39e1				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
39e1 18				db WORD_SYS_CORE+4             
39e2 2e 3a			dw .MUL            
39e4 02				db 1 + 1 
39e5 .. 00			db "/",0              
39e7				endm 
# End of macro CWHEAD
39e7			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
39e7					if DEBUG_FORTH_WORDS_KEY 
39e7						DMARK "DIV" 
39e7 f5				push af  
39e8 3a fc 39			ld a, (.dmark)  
39eb 32 b4 fe			ld (debug_mark),a  
39ee 3a fd 39			ld a, (.dmark+1)  
39f1 32 b5 fe			ld (debug_mark+1),a  
39f4 3a fe 39			ld a, (.dmark+2)  
39f7 32 b6 fe			ld (debug_mark+2),a  
39fa 18 03			jr .pastdmark  
39fc ..			.dmark: db "DIV"  
39ff f1			.pastdmark: pop af  
3a00			endm  
# End of macro DMARK
3a00						CALLMONITOR 
3a00 cd c6 18			call break_point_state  
3a03				endm  
# End of macro CALLMONITOR
3a03					endif 
3a03				; TODO add floating point number detection 
3a03					; v5 FORTH_DSP_VALUE 
3a03					FORTH_DSP 
3a03 cd f7 20			call macro_forth_dsp 
3a06				endm 
# End of macro FORTH_DSP
3a06 7e					ld a,(hl)	; get type of value on TOS 
3a07 fe 02				cp DS_TYPE_INUM  
3a09 28 03				jr z, .div_inum 
3a0b			 
3a0b				if FORTH_ENABLE_FLOATMATH 
3a0b					jr .div_done 
3a0b			 
3a0b				endif 
3a0b					NEXTW 
3a0b c3 e7 22			jp macro_next 
3a0e				endm 
# End of macro NEXTW
3a0e			.div_inum: 
3a0e			 
3a0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a0e cd 31 21			call macro_dsp_valuehl 
3a11				endm 
# End of macro FORTH_DSP_VALUEHL
3a11			 
3a11 e5					push hl    ; to go to bc 
3a12			 
3a12					; destroy value TOS 
3a12			 
3a12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a12 cd e9 21			call macro_forth_dsp_pop 
3a15				endm 
# End of macro FORTH_DSP_POP
3a15			 
3a15			 
3a15					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a15 cd 31 21			call macro_dsp_valuehl 
3a18				endm 
# End of macro FORTH_DSP_VALUEHL
3a18			 
3a18					; hl to go to de 
3a18			 
3a18 e5					push hl 
3a19			 
3a19 c1					pop bc 
3a1a d1					pop de		 
3a1b			 
3a1b			 
3a1b					if DEBUG_FORTH_MATHS 
3a1b						DMARK "DIV" 
3a1b				CALLMONITOR 
3a1b					endif 
3a1b					; one value on hl but move to a get other one back 
3a1b			 
3a1b			        
3a1b cd a6 0e			call Div16 
3a1e			 
3a1e			;	push af	 
3a1e e5				push hl 
3a1f c5				push bc 
3a20			 
3a20					if DEBUG_FORTH_MATHS 
3a20						DMARK "DI1" 
3a20				CALLMONITOR 
3a20					endif 
3a20			 
3a20					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a20 cd e9 21			call macro_forth_dsp_pop 
3a23				endm 
# End of macro FORTH_DSP_POP
3a23			 
3a23			 
3a23			 
3a23 e1					pop hl    ; result 
3a24			 
3a24 cd 3a 1f				call forth_push_numhl 
3a27			 
3a27 e1					pop hl    ; reminder 
3a28			;		ld h,0 
3a28			;		ld l,d 
3a28			 
3a28 cd 3a 1f				call forth_push_numhl 
3a2b			.div_done: 
3a2b					NEXTW 
3a2b c3 e7 22			jp macro_next 
3a2e				endm 
# End of macro NEXTW
3a2e			.MUL: 
3a2e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a2e 19				db WORD_SYS_CORE+5             
3a2f 73 3a			dw .MIN            
3a31 02				db 1 + 1 
3a32 .. 00			db "*",0              
3a34				endm 
# End of macro CWHEAD
3a34			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a34				; TODO add floating point number detection 
3a34					if DEBUG_FORTH_WORDS_KEY 
3a34						DMARK "MUL" 
3a34 f5				push af  
3a35 3a 49 3a			ld a, (.dmark)  
3a38 32 b4 fe			ld (debug_mark),a  
3a3b 3a 4a 3a			ld a, (.dmark+1)  
3a3e 32 b5 fe			ld (debug_mark+1),a  
3a41 3a 4b 3a			ld a, (.dmark+2)  
3a44 32 b6 fe			ld (debug_mark+2),a  
3a47 18 03			jr .pastdmark  
3a49 ..			.dmark: db "MUL"  
3a4c f1			.pastdmark: pop af  
3a4d			endm  
# End of macro DMARK
3a4d						CALLMONITOR 
3a4d cd c6 18			call break_point_state  
3a50				endm  
# End of macro CALLMONITOR
3a50					endif 
3a50					FORTH_DSP 
3a50 cd f7 20			call macro_forth_dsp 
3a53				endm 
# End of macro FORTH_DSP
3a53					; v5 FORTH_DSP_VALUE 
3a53 7e					ld a,(hl)	; get type of value on TOS 
3a54 fe 02				cp DS_TYPE_INUM  
3a56 28 03				jr z, .mul_inum 
3a58			 
3a58				if FORTH_ENABLE_FLOATMATH 
3a58					jr .mul_done 
3a58			 
3a58				endif 
3a58			 
3a58					NEXTW 
3a58 c3 e7 22			jp macro_next 
3a5b				endm 
# End of macro NEXTW
3a5b			.mul_inum:	 
3a5b			 
3a5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a5b cd 31 21			call macro_dsp_valuehl 
3a5e				endm 
# End of macro FORTH_DSP_VALUEHL
3a5e			 
3a5e e5					push hl 
3a5f			 
3a5f					; destroy value TOS 
3a5f			 
3a5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5f cd e9 21			call macro_forth_dsp_pop 
3a62				endm 
# End of macro FORTH_DSP_POP
3a62			 
3a62			 
3a62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a62 cd 31 21			call macro_dsp_valuehl 
3a65				endm 
# End of macro FORTH_DSP_VALUEHL
3a65			 
3a65					; one value on hl but move to a get other one back 
3a65			 
3a65 7d					ld a, l 
3a66			 
3a66 d1					pop de 
3a67			 
3a67					; do the mull 
3a67			;		ex de, hl 
3a67			 
3a67 cd cc 0e				call Mult16 
3a6a					; save it 
3a6a			 
3a6a			;		push hl	 
3a6a			 
3a6a					; 
3a6a			 
3a6a					; destroy value TOS 
3a6a			 
3a6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6a cd e9 21			call macro_forth_dsp_pop 
3a6d				endm 
# End of macro FORTH_DSP_POP
3a6d			 
3a6d					; TODO push value back onto stack for another op etc 
3a6d			 
3a6d			;		pop hl 
3a6d			 
3a6d cd 3a 1f				call forth_push_numhl 
3a70			 
3a70			.mul_done: 
3a70					NEXTW 
3a70 c3 e7 22			jp macro_next 
3a73				endm 
# End of macro NEXTW
3a73			 
3a73			 
3a73			 
3a73			 
3a73			.MIN: 
3a73				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a73 49				db WORD_SYS_CORE+53             
3a74 f4 3a			dw .MAX            
3a76 04				db 3 + 1 
3a77 .. 00			db "MIN",0              
3a7b				endm 
# End of macro CWHEAD
3a7b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a7b					if DEBUG_FORTH_WORDS_KEY 
3a7b						DMARK "MIN" 
3a7b f5				push af  
3a7c 3a 90 3a			ld a, (.dmark)  
3a7f 32 b4 fe			ld (debug_mark),a  
3a82 3a 91 3a			ld a, (.dmark+1)  
3a85 32 b5 fe			ld (debug_mark+1),a  
3a88 3a 92 3a			ld a, (.dmark+2)  
3a8b 32 b6 fe			ld (debug_mark+2),a  
3a8e 18 03			jr .pastdmark  
3a90 ..			.dmark: db "MIN"  
3a93 f1			.pastdmark: pop af  
3a94			endm  
# End of macro DMARK
3a94						CALLMONITOR 
3a94 cd c6 18			call break_point_state  
3a97				endm  
# End of macro CALLMONITOR
3a97					endif 
3a97					; get u2 
3a97			 
3a97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a97 cd 31 21			call macro_dsp_valuehl 
3a9a				endm 
# End of macro FORTH_DSP_VALUEHL
3a9a			 
3a9a e5					push hl   ; u2 
3a9b			 
3a9b					; destroy value TOS 
3a9b			 
3a9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9b cd e9 21			call macro_forth_dsp_pop 
3a9e				endm 
# End of macro FORTH_DSP_POP
3a9e			 
3a9e					; get u1 
3a9e			 
3a9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9e cd 31 21			call macro_dsp_valuehl 
3aa1				endm 
# End of macro FORTH_DSP_VALUEHL
3aa1			 
3aa1 e5					push hl  ; u1 
3aa2			 
3aa2					; destroy value TOS 
3aa2			 
3aa2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa2 cd e9 21			call macro_forth_dsp_pop 
3aa5				endm 
# End of macro FORTH_DSP_POP
3aa5			 
3aa5 b7			 or a      ;clear carry flag 
3aa6 e1			  pop hl    ; u1 
3aa7 d1			  pop de    ; u2 
3aa8 e5				push hl   ; saved in case hl is lowest 
3aa9 ed 52		  sbc hl,de 
3aab 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3aad			 
3aad e1				pop hl 
3aae					if DEBUG_FORTH_WORDS 
3aae						DMARK "MIN" 
3aae f5				push af  
3aaf 3a c3 3a			ld a, (.dmark)  
3ab2 32 b4 fe			ld (debug_mark),a  
3ab5 3a c4 3a			ld a, (.dmark+1)  
3ab8 32 b5 fe			ld (debug_mark+1),a  
3abb 3a c5 3a			ld a, (.dmark+2)  
3abe 32 b6 fe			ld (debug_mark+2),a  
3ac1 18 03			jr .pastdmark  
3ac3 ..			.dmark: db "MIN"  
3ac6 f1			.pastdmark: pop af  
3ac7			endm  
# End of macro DMARK
3ac7						CALLMONITOR 
3ac7 cd c6 18			call break_point_state  
3aca				endm  
# End of macro CALLMONITOR
3aca					endif 
3aca cd 3a 1f				call forth_push_numhl 
3acd			 
3acd				       NEXTW 
3acd c3 e7 22			jp macro_next 
3ad0				endm 
# End of macro NEXTW
3ad0			 
3ad0			.mincont:  
3ad0 c1				pop bc   ; tidy up 
3ad1 eb				ex de , hl  
3ad2					if DEBUG_FORTH_WORDS 
3ad2						DMARK "MI1" 
3ad2 f5				push af  
3ad3 3a e7 3a			ld a, (.dmark)  
3ad6 32 b4 fe			ld (debug_mark),a  
3ad9 3a e8 3a			ld a, (.dmark+1)  
3adc 32 b5 fe			ld (debug_mark+1),a  
3adf 3a e9 3a			ld a, (.dmark+2)  
3ae2 32 b6 fe			ld (debug_mark+2),a  
3ae5 18 03			jr .pastdmark  
3ae7 ..			.dmark: db "MI1"  
3aea f1			.pastdmark: pop af  
3aeb			endm  
# End of macro DMARK
3aeb						CALLMONITOR 
3aeb cd c6 18			call break_point_state  
3aee				endm  
# End of macro CALLMONITOR
3aee					endif 
3aee cd 3a 1f				call forth_push_numhl 
3af1			 
3af1				       NEXTW 
3af1 c3 e7 22			jp macro_next 
3af4				endm 
# End of macro NEXTW
3af4			.MAX: 
3af4				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3af4 4a				db WORD_SYS_CORE+54             
3af5 75 3b			dw .RND16            
3af7 04				db 3 + 1 
3af8 .. 00			db "MAX",0              
3afc				endm 
# End of macro CWHEAD
3afc			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3afc					if DEBUG_FORTH_WORDS_KEY 
3afc						DMARK "MAX" 
3afc f5				push af  
3afd 3a 11 3b			ld a, (.dmark)  
3b00 32 b4 fe			ld (debug_mark),a  
3b03 3a 12 3b			ld a, (.dmark+1)  
3b06 32 b5 fe			ld (debug_mark+1),a  
3b09 3a 13 3b			ld a, (.dmark+2)  
3b0c 32 b6 fe			ld (debug_mark+2),a  
3b0f 18 03			jr .pastdmark  
3b11 ..			.dmark: db "MAX"  
3b14 f1			.pastdmark: pop af  
3b15			endm  
# End of macro DMARK
3b15						CALLMONITOR 
3b15 cd c6 18			call break_point_state  
3b18				endm  
# End of macro CALLMONITOR
3b18					endif 
3b18					; get u2 
3b18			 
3b18					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b18 cd 31 21			call macro_dsp_valuehl 
3b1b				endm 
# End of macro FORTH_DSP_VALUEHL
3b1b			 
3b1b e5					push hl   ; u2 
3b1c			 
3b1c					; destroy value TOS 
3b1c			 
3b1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1c cd e9 21			call macro_forth_dsp_pop 
3b1f				endm 
# End of macro FORTH_DSP_POP
3b1f			 
3b1f					; get u1 
3b1f			 
3b1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1f cd 31 21			call macro_dsp_valuehl 
3b22				endm 
# End of macro FORTH_DSP_VALUEHL
3b22			 
3b22 e5					push hl  ; u1 
3b23			 
3b23					; destroy value TOS 
3b23			 
3b23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b23 cd e9 21			call macro_forth_dsp_pop 
3b26				endm 
# End of macro FORTH_DSP_POP
3b26			 
3b26 b7			 or a      ;clear carry flag 
3b27 e1			  pop hl    ; u1 
3b28 d1			  pop de    ; u2 
3b29 e5				push hl   ; saved in case hl is lowest 
3b2a ed 52		  sbc hl,de 
3b2c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b2e			 
3b2e e1				pop hl 
3b2f					if DEBUG_FORTH_WORDS 
3b2f						DMARK "MAX" 
3b2f f5				push af  
3b30 3a 44 3b			ld a, (.dmark)  
3b33 32 b4 fe			ld (debug_mark),a  
3b36 3a 45 3b			ld a, (.dmark+1)  
3b39 32 b5 fe			ld (debug_mark+1),a  
3b3c 3a 46 3b			ld a, (.dmark+2)  
3b3f 32 b6 fe			ld (debug_mark+2),a  
3b42 18 03			jr .pastdmark  
3b44 ..			.dmark: db "MAX"  
3b47 f1			.pastdmark: pop af  
3b48			endm  
# End of macro DMARK
3b48						CALLMONITOR 
3b48 cd c6 18			call break_point_state  
3b4b				endm  
# End of macro CALLMONITOR
3b4b					endif 
3b4b cd 3a 1f				call forth_push_numhl 
3b4e			 
3b4e				       NEXTW 
3b4e c3 e7 22			jp macro_next 
3b51				endm 
# End of macro NEXTW
3b51			 
3b51			.maxcont:  
3b51 c1				pop bc   ; tidy up 
3b52 eb				ex de , hl  
3b53					if DEBUG_FORTH_WORDS 
3b53						DMARK "MA1" 
3b53 f5				push af  
3b54 3a 68 3b			ld a, (.dmark)  
3b57 32 b4 fe			ld (debug_mark),a  
3b5a 3a 69 3b			ld a, (.dmark+1)  
3b5d 32 b5 fe			ld (debug_mark+1),a  
3b60 3a 6a 3b			ld a, (.dmark+2)  
3b63 32 b6 fe			ld (debug_mark+2),a  
3b66 18 03			jr .pastdmark  
3b68 ..			.dmark: db "MA1"  
3b6b f1			.pastdmark: pop af  
3b6c			endm  
# End of macro DMARK
3b6c						CALLMONITOR 
3b6c cd c6 18			call break_point_state  
3b6f				endm  
# End of macro CALLMONITOR
3b6f					endif 
3b6f cd 3a 1f				call forth_push_numhl 
3b72				       NEXTW 
3b72 c3 e7 22			jp macro_next 
3b75				endm 
# End of macro NEXTW
3b75			 
3b75			.RND16: 
3b75				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b75 4e				db WORD_SYS_CORE+58             
3b76 a4 3b			dw .RND8            
3b78 06				db 5 + 1 
3b79 .. 00			db "RND16",0              
3b7f				endm 
# End of macro CWHEAD
3b7f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b7f					if DEBUG_FORTH_WORDS_KEY 
3b7f						DMARK "R16" 
3b7f f5				push af  
3b80 3a 94 3b			ld a, (.dmark)  
3b83 32 b4 fe			ld (debug_mark),a  
3b86 3a 95 3b			ld a, (.dmark+1)  
3b89 32 b5 fe			ld (debug_mark+1),a  
3b8c 3a 96 3b			ld a, (.dmark+2)  
3b8f 32 b6 fe			ld (debug_mark+2),a  
3b92 18 03			jr .pastdmark  
3b94 ..			.dmark: db "R16"  
3b97 f1			.pastdmark: pop af  
3b98			endm  
# End of macro DMARK
3b98						CALLMONITOR 
3b98 cd c6 18			call break_point_state  
3b9b				endm  
# End of macro CALLMONITOR
3b9b					endif 
3b9b cd 70 0e				call prng16  
3b9e cd 3a 1f				call forth_push_numhl 
3ba1				       NEXTW 
3ba1 c3 e7 22			jp macro_next 
3ba4				endm 
# End of macro NEXTW
3ba4			.RND8: 
3ba4				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3ba4 60				db WORD_SYS_CORE+76             
3ba5 d9 3b			dw .RND            
3ba7 05				db 4 + 1 
3ba8 .. 00			db "RND8",0              
3bad				endm 
# End of macro CWHEAD
3bad			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bad					if DEBUG_FORTH_WORDS_KEY 
3bad						DMARK "RN8" 
3bad f5				push af  
3bae 3a c2 3b			ld a, (.dmark)  
3bb1 32 b4 fe			ld (debug_mark),a  
3bb4 3a c3 3b			ld a, (.dmark+1)  
3bb7 32 b5 fe			ld (debug_mark+1),a  
3bba 3a c4 3b			ld a, (.dmark+2)  
3bbd 32 b6 fe			ld (debug_mark+2),a  
3bc0 18 03			jr .pastdmark  
3bc2 ..			.dmark: db "RN8"  
3bc5 f1			.pastdmark: pop af  
3bc6			endm  
# End of macro DMARK
3bc6						CALLMONITOR 
3bc6 cd c6 18			call break_point_state  
3bc9				endm  
# End of macro CALLMONITOR
3bc9					endif 
3bc9 2a 35 fd				ld hl,(xrandc) 
3bcc 23					inc hl 
3bcd cd 8a 0e				call xrnd 
3bd0 6f					ld l,a	 
3bd1 26 00				ld h,0 
3bd3 cd 3a 1f				call forth_push_numhl 
3bd6				       NEXTW 
3bd6 c3 e7 22			jp macro_next 
3bd9				endm 
# End of macro NEXTW
3bd9			.RND: 
3bd9				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3bd9 60				db WORD_SYS_CORE+76             
3bda df 3c			dw .ENDMATHS            
3bdc 04				db 3 + 1 
3bdd .. 00			db "RND",0              
3be1				endm 
# End of macro CWHEAD
3be1			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3be1			 
3be1					if DEBUG_FORTH_WORDS_KEY 
3be1						DMARK "RND" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 b4 fe			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 b5 fe			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 b6 fe			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "RND"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa						CALLMONITOR 
3bfa cd c6 18			call break_point_state  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd					 
3bfd					FORTH_DSP_VALUEHL    ; upper range 
3bfd cd 31 21			call macro_dsp_valuehl 
3c00				endm 
# End of macro FORTH_DSP_VALUEHL
3c00			 
3c00 22 39 fd				ld (LFSRSeed), hl	 
3c03			 
3c03					if DEBUG_FORTH_WORDS 
3c03						DMARK "RN1" 
3c03 f5				push af  
3c04 3a 18 3c			ld a, (.dmark)  
3c07 32 b4 fe			ld (debug_mark),a  
3c0a 3a 19 3c			ld a, (.dmark+1)  
3c0d 32 b5 fe			ld (debug_mark+1),a  
3c10 3a 1a 3c			ld a, (.dmark+2)  
3c13 32 b6 fe			ld (debug_mark+2),a  
3c16 18 03			jr .pastdmark  
3c18 ..			.dmark: db "RN1"  
3c1b f1			.pastdmark: pop af  
3c1c			endm  
# End of macro DMARK
3c1c						CALLMONITOR 
3c1c cd c6 18			call break_point_state  
3c1f				endm  
# End of macro CALLMONITOR
3c1f					endif 
3c1f					FORTH_DSP_POP 
3c1f cd e9 21			call macro_forth_dsp_pop 
3c22				endm 
# End of macro FORTH_DSP_POP
3c22			 
3c22					FORTH_DSP_VALUEHL    ; low range 
3c22 cd 31 21			call macro_dsp_valuehl 
3c25				endm 
# End of macro FORTH_DSP_VALUEHL
3c25			 
3c25					if DEBUG_FORTH_WORDS 
3c25						DMARK "RN2" 
3c25 f5				push af  
3c26 3a 3a 3c			ld a, (.dmark)  
3c29 32 b4 fe			ld (debug_mark),a  
3c2c 3a 3b 3c			ld a, (.dmark+1)  
3c2f 32 b5 fe			ld (debug_mark+1),a  
3c32 3a 3c 3c			ld a, (.dmark+2)  
3c35 32 b6 fe			ld (debug_mark+2),a  
3c38 18 03			jr .pastdmark  
3c3a ..			.dmark: db "RN2"  
3c3d f1			.pastdmark: pop af  
3c3e			endm  
# End of macro DMARK
3c3e						CALLMONITOR 
3c3e cd c6 18			call break_point_state  
3c41				endm  
# End of macro CALLMONITOR
3c41					endif 
3c41 22 3b fd				ld (LFSRSeed+2), hl 
3c44			 
3c44					FORTH_DSP_POP 
3c44 cd e9 21			call macro_forth_dsp_pop 
3c47				endm 
# End of macro FORTH_DSP_POP
3c47			 
3c47 e5					push hl 
3c48			 
3c48 e1			.inrange:	pop hl 
3c49 cd 70 0e				call prng16  
3c4c					if DEBUG_FORTH_WORDS 
3c4c						DMARK "RN3" 
3c4c f5				push af  
3c4d 3a 61 3c			ld a, (.dmark)  
3c50 32 b4 fe			ld (debug_mark),a  
3c53 3a 62 3c			ld a, (.dmark+1)  
3c56 32 b5 fe			ld (debug_mark+1),a  
3c59 3a 63 3c			ld a, (.dmark+2)  
3c5c 32 b6 fe			ld (debug_mark+2),a  
3c5f 18 03			jr .pastdmark  
3c61 ..			.dmark: db "RN3"  
3c64 f1			.pastdmark: pop af  
3c65			endm  
# End of macro DMARK
3c65						CALLMONITOR 
3c65 cd c6 18			call break_point_state  
3c68				endm  
# End of macro CALLMONITOR
3c68					endif 
3c68					 
3c68					; if the range is 8bit knock out the high byte 
3c68			 
3c68 ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3c6c			 
3c6c 3e 00				ld a, 0 
3c6e ba					cp d  
3c6f 20 1e				jr nz, .hirange 
3c71 26 00				ld h, 0   ; knock it down to 8bit 
3c73			 
3c73					if DEBUG_FORTH_WORDS 
3c73						DMARK "RNk" 
3c73 f5				push af  
3c74 3a 88 3c			ld a, (.dmark)  
3c77 32 b4 fe			ld (debug_mark),a  
3c7a 3a 89 3c			ld a, (.dmark+1)  
3c7d 32 b5 fe			ld (debug_mark+1),a  
3c80 3a 8a 3c			ld a, (.dmark+2)  
3c83 32 b6 fe			ld (debug_mark+2),a  
3c86 18 03			jr .pastdmark  
3c88 ..			.dmark: db "RNk"  
3c8b f1			.pastdmark: pop af  
3c8c			endm  
# End of macro DMARK
3c8c						CALLMONITOR 
3c8c cd c6 18			call break_point_state  
3c8f				endm  
# End of macro CALLMONITOR
3c8f					endif 
3c8f			.hirange:   
3c8f e5					push hl  
3c90 b7					or a  
3c91 ed 52		                sbc hl, de 
3c93			 
3c93					;call cmp16 
3c93			 
3c93 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c95 e1					pop hl 
3c96 e5					push hl 
3c97			 
3c97					if DEBUG_FORTH_WORDS 
3c97						DMARK "RN4" 
3c97 f5				push af  
3c98 3a ac 3c			ld a, (.dmark)  
3c9b 32 b4 fe			ld (debug_mark),a  
3c9e 3a ad 3c			ld a, (.dmark+1)  
3ca1 32 b5 fe			ld (debug_mark+1),a  
3ca4 3a ae 3c			ld a, (.dmark+2)  
3ca7 32 b6 fe			ld (debug_mark+2),a  
3caa 18 03			jr .pastdmark  
3cac ..			.dmark: db "RN4"  
3caf f1			.pastdmark: pop af  
3cb0			endm  
# End of macro DMARK
3cb0						CALLMONITOR 
3cb0 cd c6 18			call break_point_state  
3cb3				endm  
# End of macro CALLMONITOR
3cb3					endif 
3cb3 ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3cb7					;call cmp16 
3cb7				 
3cb7 b7					or a  
3cb8 ed 52		                sbc hl, de 
3cba 38 8c				jr c, .inrange 
3cbc			 
3cbc e1					pop hl 
3cbd					 
3cbd					if DEBUG_FORTH_WORDS 
3cbd						DMARK "RNd" 
3cbd f5				push af  
3cbe 3a d2 3c			ld a, (.dmark)  
3cc1 32 b4 fe			ld (debug_mark),a  
3cc4 3a d3 3c			ld a, (.dmark+1)  
3cc7 32 b5 fe			ld (debug_mark+1),a  
3cca 3a d4 3c			ld a, (.dmark+2)  
3ccd 32 b6 fe			ld (debug_mark+2),a  
3cd0 18 03			jr .pastdmark  
3cd2 ..			.dmark: db "RNd"  
3cd5 f1			.pastdmark: pop af  
3cd6			endm  
# End of macro DMARK
3cd6						CALLMONITOR 
3cd6 cd c6 18			call break_point_state  
3cd9				endm  
# End of macro CALLMONITOR
3cd9					endif 
3cd9			 
3cd9			 
3cd9 cd 3a 1f				call forth_push_numhl 
3cdc				       NEXTW 
3cdc c3 e7 22			jp macro_next 
3cdf				endm 
# End of macro NEXTW
3cdf			 
3cdf			.ENDMATHS: 
3cdf			 
3cdf			; eof 
3cdf			 
# End of file forth_words_maths.asm
3cdf			include "forth_words_display.asm" 
3cdf			 
3cdf			; | ## Display Words 
3cdf			 
3cdf			.INFO: 
3cdf			 
3cdf				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3cdf 62				db WORD_SYS_CORE+78             
3ce0 fc 3c			dw .ATP            
3ce2 05				db 4 + 1 
3ce3 .. 00			db "INFO",0              
3ce8				endm 
# End of macro CWHEAD
3ce8			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ce8					FORTH_DSP_VALUEHL 
3ce8 cd 31 21			call macro_dsp_valuehl 
3ceb				endm 
# End of macro FORTH_DSP_VALUEHL
3ceb			 
3ceb					FORTH_DSP_POP 
3ceb cd e9 21			call macro_forth_dsp_pop 
3cee				endm 
# End of macro FORTH_DSP_POP
3cee			 
3cee e5					push hl 
3cef			 
3cef					FORTH_DSP_VALUEHL 
3cef cd 31 21			call macro_dsp_valuehl 
3cf2				endm 
# End of macro FORTH_DSP_VALUEHL
3cf2			 
3cf2					FORTH_DSP_POP 
3cf2 cd e9 21			call macro_forth_dsp_pop 
3cf5				endm 
# End of macro FORTH_DSP_POP
3cf5			 
3cf5 d1					pop de 
3cf6			 
3cf6 cd a6 0c				call info_panel 
3cf9			 
3cf9			 
3cf9					NEXTW 
3cf9 c3 e7 22			jp macro_next 
3cfc				endm 
# End of macro NEXTW
3cfc			.ATP: 
3cfc				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3cfc 62				db WORD_SYS_CORE+78             
3cfd 73 3d			dw .FB            
3cff 04				db 3 + 1 
3d00 .. 00			db "AT?",0              
3d04				endm 
# End of macro CWHEAD
3d04			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3d04					if DEBUG_FORTH_WORDS_KEY 
3d04						DMARK "AT?" 
3d04 f5				push af  
3d05 3a 19 3d			ld a, (.dmark)  
3d08 32 b4 fe			ld (debug_mark),a  
3d0b 3a 1a 3d			ld a, (.dmark+1)  
3d0e 32 b5 fe			ld (debug_mark+1),a  
3d11 3a 1b 3d			ld a, (.dmark+2)  
3d14 32 b6 fe			ld (debug_mark+2),a  
3d17 18 03			jr .pastdmark  
3d19 ..			.dmark: db "AT?"  
3d1c f1			.pastdmark: pop af  
3d1d			endm  
# End of macro DMARK
3d1d						CALLMONITOR 
3d1d cd c6 18			call break_point_state  
3d20				endm  
# End of macro CALLMONITOR
3d20					endif 
3d20 3a eb fb				ld a, (f_cursor_ptr) 
3d23			 
3d23			if DEBUG_FORTH_WORDS 
3d23				DMARK "AT?" 
3d23 f5				push af  
3d24 3a 38 3d			ld a, (.dmark)  
3d27 32 b4 fe			ld (debug_mark),a  
3d2a 3a 39 3d			ld a, (.dmark+1)  
3d2d 32 b5 fe			ld (debug_mark+1),a  
3d30 3a 3a 3d			ld a, (.dmark+2)  
3d33 32 b6 fe			ld (debug_mark+2),a  
3d36 18 03			jr .pastdmark  
3d38 ..			.dmark: db "AT?"  
3d3b f1			.pastdmark: pop af  
3d3c			endm  
# End of macro DMARK
3d3c				CALLMONITOR 
3d3c cd c6 18			call break_point_state  
3d3f				endm  
# End of macro CALLMONITOR
3d3f			endif	 
3d3f					; count the number of rows 
3d3f			 
3d3f 06 00				ld b, 0 
3d41 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d42 d6 14				sub display_cols 
3d44 f2 4a 3d				jp p, .atprunder 
3d47 04					inc b 
3d48 18 f7				jr .atpr 
3d4a			.atprunder:	 
3d4a			if DEBUG_FORTH_WORDS 
3d4a				DMARK "A?2" 
3d4a f5				push af  
3d4b 3a 5f 3d			ld a, (.dmark)  
3d4e 32 b4 fe			ld (debug_mark),a  
3d51 3a 60 3d			ld a, (.dmark+1)  
3d54 32 b5 fe			ld (debug_mark+1),a  
3d57 3a 61 3d			ld a, (.dmark+2)  
3d5a 32 b6 fe			ld (debug_mark+2),a  
3d5d 18 03			jr .pastdmark  
3d5f ..			.dmark: db "A?2"  
3d62 f1			.pastdmark: pop af  
3d63			endm  
# End of macro DMARK
3d63				CALLMONITOR 
3d63 cd c6 18			call break_point_state  
3d66				endm  
# End of macro CALLMONITOR
3d66			endif	 
3d66 26 00				ld h, 0 
3d68 69					ld l, c 
3d69 cd 3a 1f				call forth_push_numhl 
3d6c 68					ld l, b  
3d6d cd 3a 1f				call forth_push_numhl 
3d70			 
3d70			 
3d70				NEXTW 
3d70 c3 e7 22			jp macro_next 
3d73				endm 
# End of macro NEXTW
3d73			 
3d73			.FB: 
3d73				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3d73 1b				db WORD_SYS_CORE+7             
3d74 c1 3d			dw .EMIT            
3d76 03				db 2 + 1 
3d77 .. 00			db "FB",0              
3d7a				endm 
# End of macro CWHEAD
3d7a			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3d7a			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3d7a			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3d7a			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3d7a					if DEBUG_FORTH_WORDS_KEY 
3d7a						DMARK "FB." 
3d7a f5				push af  
3d7b 3a 8f 3d			ld a, (.dmark)  
3d7e 32 b4 fe			ld (debug_mark),a  
3d81 3a 90 3d			ld a, (.dmark+1)  
3d84 32 b5 fe			ld (debug_mark+1),a  
3d87 3a 91 3d			ld a, (.dmark+2)  
3d8a 32 b6 fe			ld (debug_mark+2),a  
3d8d 18 03			jr .pastdmark  
3d8f ..			.dmark: db "FB."  
3d92 f1			.pastdmark: pop af  
3d93			endm  
# End of macro DMARK
3d93						CALLMONITOR 
3d93 cd c6 18			call break_point_state  
3d96				endm  
# End of macro CALLMONITOR
3d96					endif 
3d96			 
3d96					FORTH_DSP_VALUEHL 
3d96 cd 31 21			call macro_dsp_valuehl 
3d99				endm 
# End of macro FORTH_DSP_VALUEHL
3d99			 
3d99 7d					ld a, l 
3d9a fe 01				cp 1 
3d9c 20 05				jr nz, .fbn1 
3d9e 21 f9 fd				ld hl, display_fb1 
3da1 18 15				jr .fbset 
3da3 fe 02		.fbn1:		cp 2 
3da5 20 05				jr nz, .fbn2 
3da7 21 57 fd				ld hl, display_fb2 
3daa 18 0c				jr .fbset 
3dac fe 03		.fbn2:		cp 3 
3dae 20 05				jr nz, .fbn3 
3db0 21 a8 fd				ld hl, display_fb3 
3db3 18 03				jr .fbset 
3db5			.fbn3:		 ; if invalid number select first 
3db5 21 f9 fd				ld hl, display_fb1 
3db8 22 55 fd		.fbset:		ld (display_fb_active), hl 
3dbb			 
3dbb					FORTH_DSP_POP 
3dbb cd e9 21			call macro_forth_dsp_pop 
3dbe				endm 
# End of macro FORTH_DSP_POP
3dbe			 
3dbe					NEXTW 
3dbe c3 e7 22			jp macro_next 
3dc1				endm 
# End of macro NEXTW
3dc1			 
3dc1			 
3dc1			.EMIT: 
3dc1				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3dc1 1b				db WORD_SYS_CORE+7             
3dc2 12 3e			dw .DOTH            
3dc4 05				db 4 + 1 
3dc5 .. 00			db "EMIT",0              
3dca				endm 
# End of macro CWHEAD
3dca			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3dca					; get value off TOS and display it 
3dca			 
3dca					if DEBUG_FORTH_WORDS_KEY 
3dca						DMARK "EMT" 
3dca f5				push af  
3dcb 3a df 3d			ld a, (.dmark)  
3dce 32 b4 fe			ld (debug_mark),a  
3dd1 3a e0 3d			ld a, (.dmark+1)  
3dd4 32 b5 fe			ld (debug_mark+1),a  
3dd7 3a e1 3d			ld a, (.dmark+2)  
3dda 32 b6 fe			ld (debug_mark+2),a  
3ddd 18 03			jr .pastdmark  
3ddf ..			.dmark: db "EMT"  
3de2 f1			.pastdmark: pop af  
3de3			endm  
# End of macro DMARK
3de3						CALLMONITOR 
3de3 cd c6 18			call break_point_state  
3de6				endm  
# End of macro CALLMONITOR
3de6					endif 
3de6			 
3de6					FORTH_DSP_VALUEHL 
3de6 cd 31 21			call macro_dsp_valuehl 
3de9				endm 
# End of macro FORTH_DSP_VALUEHL
3de9			 
3de9 7d					ld a,l 
3dea			 
3dea					; TODO write to display 
3dea			 
3dea 32 4c f5				ld (os_input), a 
3ded 3e 00				ld a, 0 
3def 32 4d f5				ld (os_input+1), a 
3df2					 
3df2 3a eb fb				ld a, (f_cursor_ptr) 
3df5 11 4c f5				ld de, os_input 
3df8 cd 28 0d				call str_at_display 
3dfb			 
3dfb			 
3dfb 3a c9 fb				ld a,(cli_autodisplay) 
3dfe fe 00				cp 0 
3e00 28 03				jr z, .enoupdate 
3e02 cd 38 0d						call update_display 
3e05					.enoupdate: 
3e05			 
3e05 3a eb fb				ld a, (f_cursor_ptr) 
3e08 3c					inc a 
3e09 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3e0c			 
3e0c			 
3e0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e0c cd e9 21			call macro_forth_dsp_pop 
3e0f				endm 
# End of macro FORTH_DSP_POP
3e0f			  
3e0f			 
3e0f					NEXTW 
3e0f c3 e7 22			jp macro_next 
3e12				endm 
# End of macro NEXTW
3e12			.DOTH: 
3e12				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e12 1c				db WORD_SYS_CORE+8             
3e13 42 3e			dw .DOTF            
3e15 03				db 2 + 1 
3e16 .. 00			db ".-",0              
3e19				endm 
# End of macro CWHEAD
3e19			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e19					; get value off TOS and display it 
3e19					if DEBUG_FORTH_WORDS_KEY 
3e19						DMARK "DTD" 
3e19 f5				push af  
3e1a 3a 2e 3e			ld a, (.dmark)  
3e1d 32 b4 fe			ld (debug_mark),a  
3e20 3a 2f 3e			ld a, (.dmark+1)  
3e23 32 b5 fe			ld (debug_mark+1),a  
3e26 3a 30 3e			ld a, (.dmark+2)  
3e29 32 b6 fe			ld (debug_mark+2),a  
3e2c 18 03			jr .pastdmark  
3e2e ..			.dmark: db "DTD"  
3e31 f1			.pastdmark: pop af  
3e32			endm  
# End of macro DMARK
3e32						CALLMONITOR 
3e32 cd c6 18			call break_point_state  
3e35				endm  
# End of macro CALLMONITOR
3e35					endif 
3e35 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e37 3e 00			ld a, 0 
3e39 32 ca fb			ld (cli_mvdot), a 
3e3c c3 99 3e			jp .dotgo 
3e3f				NEXTW 
3e3f c3 e7 22			jp macro_next 
3e42				endm 
# End of macro NEXTW
3e42			.DOTF: 
3e42				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e42 1c				db WORD_SYS_CORE+8             
3e43 70 3e			dw .DOT            
3e45 03				db 2 + 1 
3e46 .. 00			db ".>",0              
3e49				endm 
# End of macro CWHEAD
3e49			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3e49					; get value off TOS and display it 
3e49			        ; TODO BUG adds extra spaces 
3e49			        ; TODO BUG handle numerics? 
3e49					if DEBUG_FORTH_WORDS_KEY 
3e49						DMARK "DTC" 
3e49 f5				push af  
3e4a 3a 5e 3e			ld a, (.dmark)  
3e4d 32 b4 fe			ld (debug_mark),a  
3e50 3a 5f 3e			ld a, (.dmark+1)  
3e53 32 b5 fe			ld (debug_mark+1),a  
3e56 3a 60 3e			ld a, (.dmark+2)  
3e59 32 b6 fe			ld (debug_mark+2),a  
3e5c 18 03			jr .pastdmark  
3e5e ..			.dmark: db "DTC"  
3e61 f1			.pastdmark: pop af  
3e62			endm  
# End of macro DMARK
3e62						CALLMONITOR 
3e62 cd c6 18			call break_point_state  
3e65				endm  
# End of macro CALLMONITOR
3e65					endif 
3e65 3e 01			ld a, 1 
3e67 32 ca fb			ld (cli_mvdot), a 
3e6a c3 99 3e			jp .dotgo 
3e6d				NEXTW 
3e6d c3 e7 22			jp macro_next 
3e70				endm 
# End of macro NEXTW
3e70			 
3e70			.DOT: 
3e70				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e70 1c				db WORD_SYS_CORE+8             
3e71 4c 40			dw .CLS            
3e73 02				db 1 + 1 
3e74 .. 00			db ".",0              
3e76				endm 
# End of macro CWHEAD
3e76			        ; | . ( u -- ) Display TOS | DONE 
3e76					; get value off TOS and display it 
3e76			 
3e76					if DEBUG_FORTH_WORDS_KEY 
3e76						DMARK "DOT" 
3e76 f5				push af  
3e77 3a 8b 3e			ld a, (.dmark)  
3e7a 32 b4 fe			ld (debug_mark),a  
3e7d 3a 8c 3e			ld a, (.dmark+1)  
3e80 32 b5 fe			ld (debug_mark+1),a  
3e83 3a 8d 3e			ld a, (.dmark+2)  
3e86 32 b6 fe			ld (debug_mark+2),a  
3e89 18 03			jr .pastdmark  
3e8b ..			.dmark: db "DOT"  
3e8e f1			.pastdmark: pop af  
3e8f			endm  
# End of macro DMARK
3e8f						CALLMONITOR 
3e8f cd c6 18			call break_point_state  
3e92				endm  
# End of macro CALLMONITOR
3e92					endif 
3e92 3e 00			ld a, 0 
3e94 32 ca fb			ld (cli_mvdot), a 
3e97 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e99				 
3e99			 
3e99			.dotgo: 
3e99			 
3e99			; move up type to on stack for parserv5 
3e99					FORTH_DSP 
3e99 cd f7 20			call macro_forth_dsp 
3e9c				endm 
# End of macro FORTH_DSP
3e9c				;FORTH_DSP_VALUE  
3e9c			 
3e9c			if DEBUG_FORTH_DOT 
3e9c				DMARK "DOT" 
3e9c f5				push af  
3e9d 3a b1 3e			ld a, (.dmark)  
3ea0 32 b4 fe			ld (debug_mark),a  
3ea3 3a b2 3e			ld a, (.dmark+1)  
3ea6 32 b5 fe			ld (debug_mark+1),a  
3ea9 3a b3 3e			ld a, (.dmark+2)  
3eac 32 b6 fe			ld (debug_mark+2),a  
3eaf 18 03			jr .pastdmark  
3eb1 ..			.dmark: db "DOT"  
3eb4 f1			.pastdmark: pop af  
3eb5			endm  
# End of macro DMARK
3eb5				CALLMONITOR 
3eb5 cd c6 18			call break_point_state  
3eb8				endm  
# End of macro CALLMONITOR
3eb8			endif	 
3eb8			;		.print: 
3eb8			 
3eb8 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3eb9 23				inc hl   ; position to the actual value 
3eba fe 01			cp DS_TYPE_STR 
3ebc 20 06			jr nz, .dotnum1  
3ebe			 
3ebe			; display string 
3ebe				FORTH_DSP_VALUE  
3ebe cd 1a 21			call macro_forth_dsp_value 
3ec1				endm 
# End of macro FORTH_DSP_VALUE
3ec1 eb				ex de,hl 
3ec2 18 49			jr .dotwrite 
3ec4			 
3ec4			.dotnum1: 
3ec4 fe 02			cp DS_TYPE_INUM 
3ec6 20 44			jr nz, .dotflot 
3ec8			 
3ec8			 
3ec8			; display number 
3ec8			 
3ec8			;	push hl 
3ec8			;	call clear_display 
3ec8			;	pop hl 
3ec8			 
3ec8 5e				ld e, (hl) 
3ec9 23				inc hl 
3eca 56				ld d, (hl) 
3ecb 21 4e f3			ld hl, scratch 
3ece			if DEBUG_FORTH_DOT 
3ece				DMARK "DT1" 
3ece f5				push af  
3ecf 3a e3 3e			ld a, (.dmark)  
3ed2 32 b4 fe			ld (debug_mark),a  
3ed5 3a e4 3e			ld a, (.dmark+1)  
3ed8 32 b5 fe			ld (debug_mark+1),a  
3edb 3a e5 3e			ld a, (.dmark+2)  
3ede 32 b6 fe			ld (debug_mark+2),a  
3ee1 18 03			jr .pastdmark  
3ee3 ..			.dmark: db "DT1"  
3ee6 f1			.pastdmark: pop af  
3ee7			endm  
# End of macro DMARK
3ee7				CALLMONITOR 
3ee7 cd c6 18			call break_point_state  
3eea				endm  
# End of macro CALLMONITOR
3eea			endif	 
3eea			 
3eea cd 56 13			call uitoa_16 
3eed eb				ex de,hl 
3eee			 
3eee			if DEBUG_FORTH_DOT 
3eee				DMARK "DT2" 
3eee f5				push af  
3eef 3a 03 3f			ld a, (.dmark)  
3ef2 32 b4 fe			ld (debug_mark),a  
3ef5 3a 04 3f			ld a, (.dmark+1)  
3ef8 32 b5 fe			ld (debug_mark+1),a  
3efb 3a 05 3f			ld a, (.dmark+2)  
3efe 32 b6 fe			ld (debug_mark+2),a  
3f01 18 03			jr .pastdmark  
3f03 ..			.dmark: db "DT2"  
3f06 f1			.pastdmark: pop af  
3f07			endm  
# End of macro DMARK
3f07				CALLMONITOR 
3f07 cd c6 18			call break_point_state  
3f0a				endm  
# End of macro CALLMONITOR
3f0a			endif	 
3f0a			 
3f0a			;	ld de, os_word_scratch 
3f0a 18 01			jr .dotwrite 
3f0c			 
3f0c 00			.dotflot:   nop 
3f0d			; TODO print floating point number 
3f0d			 
3f0d			.dotwrite:		 
3f0d			 
3f0d					; if c is set then set all '-' to spaces 
3f0d					; need to also take into account .>  
3f0d			 
3f0d 3e 01				ld a, 1 
3f0f b9					cp c 
3f10 20 67				jr nz, .nodashswap 
3f12			 
3f12					; DE has the string to write, working with HL 
3f12			 
3f12 06 ff				ld b, 255 
3f14 d5					push de 
3f15 e1					pop hl 
3f16			 
3f16			if DEBUG_FORTH_DOT 
3f16				DMARK "DT-" 
3f16 f5				push af  
3f17 3a 2b 3f			ld a, (.dmark)  
3f1a 32 b4 fe			ld (debug_mark),a  
3f1d 3a 2c 3f			ld a, (.dmark+1)  
3f20 32 b5 fe			ld (debug_mark+1),a  
3f23 3a 2d 3f			ld a, (.dmark+2)  
3f26 32 b6 fe			ld (debug_mark+2),a  
3f29 18 03			jr .pastdmark  
3f2b ..			.dmark: db "DT-"  
3f2e f1			.pastdmark: pop af  
3f2f			endm  
# End of macro DMARK
3f2f				CALLMONITOR 
3f2f cd c6 18			call break_point_state  
3f32				endm  
# End of macro CALLMONITOR
3f32			endif	 
3f32 7e			.dashscan:	ld a, (hl) 
3f33 fe 00				cp 0 
3f35 28 42				jr z, .nodashswap 
3f37 fe 2d				cp '-' 
3f39 20 03				jr nz, .dashskip 
3f3b 3e 20				ld a, ' ' 
3f3d 77					ld (hl), a 
3f3e 23			.dashskip:	inc hl 
3f3f			if DEBUG_FORTH_DOT 
3f3f				DMARK "D-2" 
3f3f f5				push af  
3f40 3a 54 3f			ld a, (.dmark)  
3f43 32 b4 fe			ld (debug_mark),a  
3f46 3a 55 3f			ld a, (.dmark+1)  
3f49 32 b5 fe			ld (debug_mark+1),a  
3f4c 3a 56 3f			ld a, (.dmark+2)  
3f4f 32 b6 fe			ld (debug_mark+2),a  
3f52 18 03			jr .pastdmark  
3f54 ..			.dmark: db "D-2"  
3f57 f1			.pastdmark: pop af  
3f58			endm  
# End of macro DMARK
3f58				CALLMONITOR 
3f58 cd c6 18			call break_point_state  
3f5b				endm  
# End of macro CALLMONITOR
3f5b			endif	 
3f5b 10 d5				djnz .dashscan 
3f5d			 
3f5d			if DEBUG_FORTH_DOT 
3f5d				DMARK "D-1" 
3f5d f5				push af  
3f5e 3a 72 3f			ld a, (.dmark)  
3f61 32 b4 fe			ld (debug_mark),a  
3f64 3a 73 3f			ld a, (.dmark+1)  
3f67 32 b5 fe			ld (debug_mark+1),a  
3f6a 3a 74 3f			ld a, (.dmark+2)  
3f6d 32 b6 fe			ld (debug_mark+2),a  
3f70 18 03			jr .pastdmark  
3f72 ..			.dmark: db "D-1"  
3f75 f1			.pastdmark: pop af  
3f76			endm  
# End of macro DMARK
3f76				CALLMONITOR 
3f76 cd c6 18			call break_point_state  
3f79				endm  
# End of macro CALLMONITOR
3f79			endif	 
3f79			 
3f79			.nodashswap: 
3f79			 
3f79			if DEBUG_FORTH_DOT 
3f79				DMARK "D-o" 
3f79 f5				push af  
3f7a 3a 8e 3f			ld a, (.dmark)  
3f7d 32 b4 fe			ld (debug_mark),a  
3f80 3a 8f 3f			ld a, (.dmark+1)  
3f83 32 b5 fe			ld (debug_mark+1),a  
3f86 3a 90 3f			ld a, (.dmark+2)  
3f89 32 b6 fe			ld (debug_mark+2),a  
3f8c 18 03			jr .pastdmark  
3f8e ..			.dmark: db "D-o"  
3f91 f1			.pastdmark: pop af  
3f92			endm  
# End of macro DMARK
3f92				CALLMONITOR 
3f92 cd c6 18			call break_point_state  
3f95				endm  
# End of macro CALLMONITOR
3f95			endif	 
3f95			 
3f95 d5					push de   ; save string start in case we need to advance print 
3f96			 
3f96 3a eb fb				ld a, (f_cursor_ptr) 
3f99 cd 28 0d				call str_at_display 
3f9c 3a c9 fb				ld a,(cli_autodisplay) 
3f9f fe 00				cp 0 
3fa1 28 03				jr z, .noupdate 
3fa3 cd 38 0d						call update_display 
3fa6					.noupdate: 
3fa6			 
3fa6			 
3fa6					; see if we need to advance the print position 
3fa6			 
3fa6 e1					pop hl   ; get back string 
3fa7			;		ex de,hl 
3fa7			 
3fa7 3a ca fb				ld a, (cli_mvdot) 
3faa			if DEBUG_FORTH_DOT 
3faa			;		ld e,a 
3faa				DMARK "D>1" 
3faa f5				push af  
3fab 3a bf 3f			ld a, (.dmark)  
3fae 32 b4 fe			ld (debug_mark),a  
3fb1 3a c0 3f			ld a, (.dmark+1)  
3fb4 32 b5 fe			ld (debug_mark+1),a  
3fb7 3a c1 3f			ld a, (.dmark+2)  
3fba 32 b6 fe			ld (debug_mark+2),a  
3fbd 18 03			jr .pastdmark  
3fbf ..			.dmark: db "D>1"  
3fc2 f1			.pastdmark: pop af  
3fc3			endm  
# End of macro DMARK
3fc3				CALLMONITOR 
3fc3 cd c6 18			call break_point_state  
3fc6				endm  
# End of macro CALLMONITOR
3fc6			endif	 
3fc6 fe 00				cp 0 
3fc8 28 44				jr z, .noadv 
3fca					; yes, lets advance the print position 
3fca 3e 00				ld a, 0 
3fcc cd b2 13				call strlent 
3fcf			if DEBUG_FORTH_DOT 
3fcf				DMARK "D-?" 
3fcf f5				push af  
3fd0 3a e4 3f			ld a, (.dmark)  
3fd3 32 b4 fe			ld (debug_mark),a  
3fd6 3a e5 3f			ld a, (.dmark+1)  
3fd9 32 b5 fe			ld (debug_mark+1),a  
3fdc 3a e6 3f			ld a, (.dmark+2)  
3fdf 32 b6 fe			ld (debug_mark+2),a  
3fe2 18 03			jr .pastdmark  
3fe4 ..			.dmark: db "D-?"  
3fe7 f1			.pastdmark: pop af  
3fe8			endm  
# End of macro DMARK
3fe8				CALLMONITOR 
3fe8 cd c6 18			call break_point_state  
3feb				endm  
# End of macro CALLMONITOR
3feb			endif	 
3feb 3a eb fb				ld a, (f_cursor_ptr) 
3fee 85					add a,l 
3fef					;call addatohl 
3fef					;ld a, l 
3fef 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3ff2			 
3ff2			if DEBUG_FORTH_DOT 
3ff2				DMARK "D->" 
3ff2 f5				push af  
3ff3 3a 07 40			ld a, (.dmark)  
3ff6 32 b4 fe			ld (debug_mark),a  
3ff9 3a 08 40			ld a, (.dmark+1)  
3ffc 32 b5 fe			ld (debug_mark+1),a  
3fff 3a 09 40			ld a, (.dmark+2)  
4002 32 b6 fe			ld (debug_mark+2),a  
4005 18 03			jr .pastdmark  
4007 ..			.dmark: db "D->"  
400a f1			.pastdmark: pop af  
400b			endm  
# End of macro DMARK
400b				CALLMONITOR 
400b cd c6 18			call break_point_state  
400e				endm  
# End of macro CALLMONITOR
400e			endif	 
400e			 
400e			.noadv:	 
400e			 
400e					if DEBUG_FORTH_DOT_WAIT 
400e							call next_page_prompt 
400e					endif	 
400e			; TODO this pop off the stack causes a crash. i dont know why 
400e			 
400e			 
400e			if DEBUG_FORTH_DOT 
400e				DMARK "DTh" 
400e f5				push af  
400f 3a 23 40			ld a, (.dmark)  
4012 32 b4 fe			ld (debug_mark),a  
4015 3a 24 40			ld a, (.dmark+1)  
4018 32 b5 fe			ld (debug_mark+1),a  
401b 3a 25 40			ld a, (.dmark+2)  
401e 32 b6 fe			ld (debug_mark+2),a  
4021 18 03			jr .pastdmark  
4023 ..			.dmark: db "DTh"  
4026 f1			.pastdmark: pop af  
4027			endm  
# End of macro DMARK
4027				CALLMONITOR 
4027 cd c6 18			call break_point_state  
402a				endm  
# End of macro CALLMONITOR
402a			endif	 
402a			 
402a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
402a cd e9 21			call macro_forth_dsp_pop 
402d				endm 
# End of macro FORTH_DSP_POP
402d			 
402d			if DEBUG_FORTH_DOT 
402d				DMARK "DTi" 
402d f5				push af  
402e 3a 42 40			ld a, (.dmark)  
4031 32 b4 fe			ld (debug_mark),a  
4034 3a 43 40			ld a, (.dmark+1)  
4037 32 b5 fe			ld (debug_mark+1),a  
403a 3a 44 40			ld a, (.dmark+2)  
403d 32 b6 fe			ld (debug_mark+2),a  
4040 18 03			jr .pastdmark  
4042 ..			.dmark: db "DTi"  
4045 f1			.pastdmark: pop af  
4046			endm  
# End of macro DMARK
4046				CALLMONITOR 
4046 cd c6 18			call break_point_state  
4049				endm  
# End of macro CALLMONITOR
4049			endif	 
4049			 
4049			 
4049					NEXTW 
4049 c3 e7 22			jp macro_next 
404c				endm 
# End of macro NEXTW
404c			 
404c			.CLS: 
404c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
404c 35				db WORD_SYS_CORE+33             
404d 79 40			dw .DRAW            
404f 04				db 3 + 1 
4050 .. 00			db "CLS",0              
4054				endm 
# End of macro CWHEAD
4054			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4054					if DEBUG_FORTH_WORDS_KEY 
4054						DMARK "CLS" 
4054 f5				push af  
4055 3a 69 40			ld a, (.dmark)  
4058 32 b4 fe			ld (debug_mark),a  
405b 3a 6a 40			ld a, (.dmark+1)  
405e 32 b5 fe			ld (debug_mark+1),a  
4061 3a 6b 40			ld a, (.dmark+2)  
4064 32 b6 fe			ld (debug_mark+2),a  
4067 18 03			jr .pastdmark  
4069 ..			.dmark: db "CLS"  
406c f1			.pastdmark: pop af  
406d			endm  
# End of macro DMARK
406d						CALLMONITOR 
406d cd c6 18			call break_point_state  
4070				endm  
# End of macro CALLMONITOR
4070					endif 
4070 cd 15 0d				call clear_display 
4073 c3 87 41				jp .home		; and home cursor 
4076					NEXTW 
4076 c3 e7 22			jp macro_next 
4079				endm 
# End of macro NEXTW
4079			 
4079			.DRAW: 
4079				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4079 36				db WORD_SYS_CORE+34             
407a a4 40			dw .DUMP            
407c 05				db 4 + 1 
407d .. 00			db "DRAW",0              
4082				endm 
# End of macro CWHEAD
4082			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4082					if DEBUG_FORTH_WORDS_KEY 
4082						DMARK "DRW" 
4082 f5				push af  
4083 3a 97 40			ld a, (.dmark)  
4086 32 b4 fe			ld (debug_mark),a  
4089 3a 98 40			ld a, (.dmark+1)  
408c 32 b5 fe			ld (debug_mark+1),a  
408f 3a 99 40			ld a, (.dmark+2)  
4092 32 b6 fe			ld (debug_mark+2),a  
4095 18 03			jr .pastdmark  
4097 ..			.dmark: db "DRW"  
409a f1			.pastdmark: pop af  
409b			endm  
# End of macro DMARK
409b						CALLMONITOR 
409b cd c6 18			call break_point_state  
409e				endm  
# End of macro CALLMONITOR
409e					endif 
409e cd 38 0d				call update_display 
40a1					NEXTW 
40a1 c3 e7 22			jp macro_next 
40a4				endm 
# End of macro NEXTW
40a4			 
40a4			.DUMP: 
40a4				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
40a4 37				db WORD_SYS_CORE+35             
40a5 dc 40			dw .CDUMP            
40a7 05				db 4 + 1 
40a8 .. 00			db "DUMP",0              
40ad				endm 
# End of macro CWHEAD
40ad			; | DUMP ( x -- ) With address x display dump   | DONE 
40ad			; TODO pop address to use off of the stack 
40ad					if DEBUG_FORTH_WORDS_KEY 
40ad						DMARK "DUM" 
40ad f5				push af  
40ae 3a c2 40			ld a, (.dmark)  
40b1 32 b4 fe			ld (debug_mark),a  
40b4 3a c3 40			ld a, (.dmark+1)  
40b7 32 b5 fe			ld (debug_mark+1),a  
40ba 3a c4 40			ld a, (.dmark+2)  
40bd 32 b6 fe			ld (debug_mark+2),a  
40c0 18 03			jr .pastdmark  
40c2 ..			.dmark: db "DUM"  
40c5 f1			.pastdmark: pop af  
40c6			endm  
# End of macro DMARK
40c6						CALLMONITOR 
40c6 cd c6 18			call break_point_state  
40c9				endm  
# End of macro CALLMONITOR
40c9					endif 
40c9 cd 15 0d				call clear_display 
40cc			 
40cc					; get address 
40cc			 
40cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40cc cd 31 21			call macro_dsp_valuehl 
40cf				endm 
# End of macro FORTH_DSP_VALUEHL
40cf				 
40cf					; save it for cdump 
40cf			 
40cf 22 71 f6				ld (os_cur_ptr),hl 
40d2			 
40d2					; destroy value TOS 
40d2			 
40d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d2 cd e9 21			call macro_forth_dsp_pop 
40d5				endm 
# End of macro FORTH_DSP_POP
40d5			 
40d5 cd ba 1d				call dumpcont	; skip old style of param parsing	 
40d8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
40d9					NEXTW 
40d9 c3 e7 22			jp macro_next 
40dc				endm 
# End of macro NEXTW
40dc			.CDUMP: 
40dc				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
40dc 38				db WORD_SYS_CORE+36             
40dd 0c 41			dw .DAT            
40df 06				db 5 + 1 
40e0 .. 00			db "CDUMP",0              
40e6				endm 
# End of macro CWHEAD
40e6			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
40e6					if DEBUG_FORTH_WORDS_KEY 
40e6						DMARK "CDP" 
40e6 f5				push af  
40e7 3a fb 40			ld a, (.dmark)  
40ea 32 b4 fe			ld (debug_mark),a  
40ed 3a fc 40			ld a, (.dmark+1)  
40f0 32 b5 fe			ld (debug_mark+1),a  
40f3 3a fd 40			ld a, (.dmark+2)  
40f6 32 b6 fe			ld (debug_mark+2),a  
40f9 18 03			jr .pastdmark  
40fb ..			.dmark: db "CDP"  
40fe f1			.pastdmark: pop af  
40ff			endm  
# End of macro DMARK
40ff						CALLMONITOR 
40ff cd c6 18			call break_point_state  
4102				endm  
# End of macro CALLMONITOR
4102					endif 
4102 cd 15 0d				call clear_display 
4105 cd ba 1d				call dumpcont	 
4108 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4109					NEXTW 
4109 c3 e7 22			jp macro_next 
410c				endm 
# End of macro NEXTW
410c			 
410c			 
410c			 
410c			 
410c			.DAT: 
410c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
410c 3d				db WORD_SYS_CORE+41             
410d 62 41			dw .HOME            
410f 03				db 2 + 1 
4110 .. 00			db "AT",0              
4113				endm 
# End of macro CWHEAD
4113			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4113					if DEBUG_FORTH_WORDS_KEY 
4113						DMARK "AT." 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 b4 fe			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 b5 fe			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 b6 fe			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "AT."  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd c6 18			call break_point_state  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
412f cd 31 21			call macro_dsp_valuehl 
4132				endm 
# End of macro FORTH_DSP_VALUEHL
4132			 
4132			 
4132					; TODO save cursor row 
4132 7d					ld a,l 
4133 fe 02				cp 2 
4135 20 04				jr nz, .crow3 
4137 3e 14				ld a, display_row_2 
4139 18 12				jr .ccol1 
413b fe 03		.crow3:		cp 3 
413d 20 04				jr nz, .crow4 
413f 3e 28				ld a, display_row_3 
4141 18 0a				jr .ccol1 
4143 fe 04		.crow4:		cp 4 
4145 20 04				jr nz, .crow1 
4147 3e 3c				ld a, display_row_4 
4149 18 02				jr .ccol1 
414b 3e 00		.crow1:		ld a,display_row_1 
414d f5			.ccol1:		push af			; got row offset 
414e 6f					ld l,a 
414f 26 00				ld h,0 
4151					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4151 cd e9 21			call macro_forth_dsp_pop 
4154				endm 
# End of macro FORTH_DSP_POP
4154					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4154 cd 31 21			call macro_dsp_valuehl 
4157				endm 
# End of macro FORTH_DSP_VALUEHL
4157					; TODO save cursor col 
4157 f1					pop af 
4158 85					add l		; add col offset 
4159 32 eb fb				ld (f_cursor_ptr), a 
415c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
415c cd e9 21			call macro_forth_dsp_pop 
415f				endm 
# End of macro FORTH_DSP_POP
415f			 
415f					; calculate  
415f			 
415f					NEXTW 
415f c3 e7 22			jp macro_next 
4162				endm 
# End of macro NEXTW
4162			 
4162			 
4162			.HOME: 
4162				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4162 41				db WORD_SYS_CORE+45             
4163 8f 41			dw .SPACE            
4165 05				db 4 + 1 
4166 .. 00			db "HOME",0              
416b				endm 
# End of macro CWHEAD
416b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
416b					if DEBUG_FORTH_WORDS_KEY 
416b						DMARK "HOM" 
416b f5				push af  
416c 3a 80 41			ld a, (.dmark)  
416f 32 b4 fe			ld (debug_mark),a  
4172 3a 81 41			ld a, (.dmark+1)  
4175 32 b5 fe			ld (debug_mark+1),a  
4178 3a 82 41			ld a, (.dmark+2)  
417b 32 b6 fe			ld (debug_mark+2),a  
417e 18 03			jr .pastdmark  
4180 ..			.dmark: db "HOM"  
4183 f1			.pastdmark: pop af  
4184			endm  
# End of macro DMARK
4184						CALLMONITOR 
4184 cd c6 18			call break_point_state  
4187				endm  
# End of macro CALLMONITOR
4187					endif 
4187 3e 00		.home:		ld a, 0		; and home cursor 
4189 32 eb fb				ld (f_cursor_ptr), a 
418c					NEXTW 
418c c3 e7 22			jp macro_next 
418f				endm 
# End of macro NEXTW
418f			 
418f			 
418f			.SPACE: 
418f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
418f 46				db WORD_SYS_CORE+50             
4190 bd 41			dw .SPACES            
4192 03				db 2 + 1 
4193 .. 00			db "BL",0              
4196				endm 
# End of macro CWHEAD
4196			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4196					if DEBUG_FORTH_WORDS_KEY 
4196						DMARK "BL." 
4196 f5				push af  
4197 3a ab 41			ld a, (.dmark)  
419a 32 b4 fe			ld (debug_mark),a  
419d 3a ac 41			ld a, (.dmark+1)  
41a0 32 b5 fe			ld (debug_mark+1),a  
41a3 3a ad 41			ld a, (.dmark+2)  
41a6 32 b6 fe			ld (debug_mark+2),a  
41a9 18 03			jr .pastdmark  
41ab ..			.dmark: db "BL."  
41ae f1			.pastdmark: pop af  
41af			endm  
# End of macro DMARK
41af						CALLMONITOR 
41af cd c6 18			call break_point_state  
41b2				endm  
# End of macro CALLMONITOR
41b2					endif 
41b2 21 bb 41				ld hl, .blstr 
41b5 cd a8 1f				call forth_push_str 
41b8					 
41b8				       NEXTW 
41b8 c3 e7 22			jp macro_next 
41bb				endm 
# End of macro NEXTW
41bb			 
41bb .. 00		.blstr: db " ", 0 
41bd			 
41bd			.SPACES: 
41bd				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
41bd 47				db WORD_SYS_CORE+51             
41be 58 42			dw .SCROLL            
41c0 07				db 6 + 1 
41c1 .. 00			db "SPACES",0              
41c8				endm 
# End of macro CWHEAD
41c8			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
41c8					if DEBUG_FORTH_WORDS_KEY 
41c8						DMARK "SPS" 
41c8 f5				push af  
41c9 3a dd 41			ld a, (.dmark)  
41cc 32 b4 fe			ld (debug_mark),a  
41cf 3a de 41			ld a, (.dmark+1)  
41d2 32 b5 fe			ld (debug_mark+1),a  
41d5 3a df 41			ld a, (.dmark+2)  
41d8 32 b6 fe			ld (debug_mark+2),a  
41db 18 03			jr .pastdmark  
41dd ..			.dmark: db "SPS"  
41e0 f1			.pastdmark: pop af  
41e1			endm  
# End of macro DMARK
41e1						CALLMONITOR 
41e1 cd c6 18			call break_point_state  
41e4				endm  
# End of macro CALLMONITOR
41e4					endif 
41e4			 
41e4			 
41e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41e4 cd 31 21			call macro_dsp_valuehl 
41e7				endm 
# End of macro FORTH_DSP_VALUEHL
41e7			 
41e7			;		push hl    ; u 
41e7					if DEBUG_FORTH_WORDS 
41e7						DMARK "SPA" 
41e7 f5				push af  
41e8 3a fc 41			ld a, (.dmark)  
41eb 32 b4 fe			ld (debug_mark),a  
41ee 3a fd 41			ld a, (.dmark+1)  
41f1 32 b5 fe			ld (debug_mark+1),a  
41f4 3a fe 41			ld a, (.dmark+2)  
41f7 32 b6 fe			ld (debug_mark+2),a  
41fa 18 03			jr .pastdmark  
41fc ..			.dmark: db "SPA"  
41ff f1			.pastdmark: pop af  
4200			endm  
# End of macro DMARK
4200						CALLMONITOR 
4200 cd c6 18			call break_point_state  
4203				endm  
# End of macro CALLMONITOR
4203					endif 
4203			 
4203					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4203 cd e9 21			call macro_forth_dsp_pop 
4206				endm 
# End of macro FORTH_DSP_POP
4206			;		pop hl 
4206 4d					ld c, l 
4207 06 00				ld b, 0 
4209 21 4e f3				ld hl, scratch  
420c			 
420c					if DEBUG_FORTH_WORDS 
420c						DMARK "SP2" 
420c f5				push af  
420d 3a 21 42			ld a, (.dmark)  
4210 32 b4 fe			ld (debug_mark),a  
4213 3a 22 42			ld a, (.dmark+1)  
4216 32 b5 fe			ld (debug_mark+1),a  
4219 3a 23 42			ld a, (.dmark+2)  
421c 32 b6 fe			ld (debug_mark+2),a  
421f 18 03			jr .pastdmark  
4221 ..			.dmark: db "SP2"  
4224 f1			.pastdmark: pop af  
4225			endm  
# End of macro DMARK
4225						CALLMONITOR 
4225 cd c6 18			call break_point_state  
4228				endm  
# End of macro CALLMONITOR
4228					endif 
4228 3e 20				ld a, ' ' 
422a c5			.spaces1:	push bc 
422b 77					ld (hl),a 
422c 23					inc hl 
422d c1					pop bc 
422e 10 fa				djnz .spaces1 
4230 3e 00				ld a,0 
4232 77					ld (hl),a 
4233 21 4e f3				ld hl, scratch 
4236					if DEBUG_FORTH_WORDS 
4236						DMARK "SP3" 
4236 f5				push af  
4237 3a 4b 42			ld a, (.dmark)  
423a 32 b4 fe			ld (debug_mark),a  
423d 3a 4c 42			ld a, (.dmark+1)  
4240 32 b5 fe			ld (debug_mark+1),a  
4243 3a 4d 42			ld a, (.dmark+2)  
4246 32 b6 fe			ld (debug_mark+2),a  
4249 18 03			jr .pastdmark  
424b ..			.dmark: db "SP3"  
424e f1			.pastdmark: pop af  
424f			endm  
# End of macro DMARK
424f						CALLMONITOR 
424f cd c6 18			call break_point_state  
4252				endm  
# End of macro CALLMONITOR
4252					endif 
4252 cd a3 20				call forth_apush 
4255			 
4255				       NEXTW 
4255 c3 e7 22			jp macro_next 
4258				endm 
# End of macro NEXTW
4258			 
4258			 
4258			 
4258			.SCROLL: 
4258				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4258 53				db WORD_SYS_CORE+63             
4259 85 42			dw .SCROLLD            
425b 07				db 6 + 1 
425c .. 00			db "SCROLL",0              
4263				endm 
# End of macro CWHEAD
4263			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4263					if DEBUG_FORTH_WORDS_KEY 
4263						DMARK "SCR" 
4263 f5				push af  
4264 3a 78 42			ld a, (.dmark)  
4267 32 b4 fe			ld (debug_mark),a  
426a 3a 79 42			ld a, (.dmark+1)  
426d 32 b5 fe			ld (debug_mark+1),a  
4270 3a 7a 42			ld a, (.dmark+2)  
4273 32 b6 fe			ld (debug_mark+2),a  
4276 18 03			jr .pastdmark  
4278 ..			.dmark: db "SCR"  
427b f1			.pastdmark: pop af  
427c			endm  
# End of macro DMARK
427c						CALLMONITOR 
427c cd c6 18			call break_point_state  
427f				endm  
# End of macro CALLMONITOR
427f					endif 
427f			 
427f cd d7 0c			call scroll_up 
4282			;	call update_display 
4282			 
4282					NEXTW 
4282 c3 e7 22			jp macro_next 
4285				endm 
# End of macro NEXTW
4285			 
4285			 
4285			 
4285			;		; get dir 
4285			; 
4285			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4285			; 
4285			;		push hl 
4285			; 
4285			;		; destroy value TOS 
4285			; 
4285			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4285			; 
4285			;		; get count 
4285			; 
4285			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4285			; 
4285			;		push hl 
4285			; 
4285			;		; destroy value TOS 
4285			; 
4285			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4285			; 
4285			;		; one value on hl get other one back 
4285			; 
4285			;		pop bc    ; count 
4285			; 
4285			;		pop de   ; dir 
4285			; 
4285			; 
4285			;		ld b, c 
4285			; 
4285			;.scrolldir:     push bc 
4285			;		push de 
4285			; 
4285			;		ld a, 0 
4285			;		cp e 
4285			;		jr z, .scrollup  
4285			;		call scroll_down 
4285			;		jr .scrollnext 
4285			;.scrollup:	call scroll_up 
4285			; 
4285			;		 
4285			;.scrollnext: 
4285			;		pop de 
4285			;		pop bc 
4285			;		djnz .scrolldir 
4285			; 
4285			; 
4285			; 
4285			; 
4285			; 
4285			;		NEXTW 
4285			 
4285			.SCROLLD: 
4285				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4285 53				db WORD_SYS_CORE+63             
4286 b3 42			dw .ATQ            
4288 08				db 7 + 1 
4289 .. 00			db "SCROLLD",0              
4291				endm 
# End of macro CWHEAD
4291			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4291					if DEBUG_FORTH_WORDS_KEY 
4291						DMARK "SCD" 
4291 f5				push af  
4292 3a a6 42			ld a, (.dmark)  
4295 32 b4 fe			ld (debug_mark),a  
4298 3a a7 42			ld a, (.dmark+1)  
429b 32 b5 fe			ld (debug_mark+1),a  
429e 3a a8 42			ld a, (.dmark+2)  
42a1 32 b6 fe			ld (debug_mark+2),a  
42a4 18 03			jr .pastdmark  
42a6 ..			.dmark: db "SCD"  
42a9 f1			.pastdmark: pop af  
42aa			endm  
# End of macro DMARK
42aa						CALLMONITOR 
42aa cd c6 18			call break_point_state  
42ad				endm  
# End of macro CALLMONITOR
42ad					endif 
42ad			 
42ad cd fb 0c			call scroll_down 
42b0			;	call update_display 
42b0			 
42b0					NEXTW 
42b0 c3 e7 22			jp macro_next 
42b3				endm 
# End of macro NEXTW
42b3			 
42b3			 
42b3			.ATQ: 
42b3				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
42b3 62				db WORD_SYS_CORE+78             
42b4 11 43			dw .AUTODSP            
42b6 04				db 3 + 1 
42b7 .. 00			db "AT@",0              
42bb				endm 
# End of macro CWHEAD
42bb			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
42bb					if DEBUG_FORTH_WORDS_KEY 
42bb						DMARK "ATA" 
42bb f5				push af  
42bc 3a d0 42			ld a, (.dmark)  
42bf 32 b4 fe			ld (debug_mark),a  
42c2 3a d1 42			ld a, (.dmark+1)  
42c5 32 b5 fe			ld (debug_mark+1),a  
42c8 3a d2 42			ld a, (.dmark+2)  
42cb 32 b6 fe			ld (debug_mark+2),a  
42ce 18 03			jr .pastdmark  
42d0 ..			.dmark: db "ATA"  
42d3 f1			.pastdmark: pop af  
42d4			endm  
# End of macro DMARK
42d4						CALLMONITOR 
42d4 cd c6 18			call break_point_state  
42d7				endm  
# End of macro CALLMONITOR
42d7					endif 
42d7			 
42d7			 
42d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42d7 cd 31 21			call macro_dsp_valuehl 
42da				endm 
# End of macro FORTH_DSP_VALUEHL
42da			 
42da					; TODO save cursor row 
42da 7d					ld a,l 
42db fe 02				cp 2 
42dd 20 04				jr nz, .crow3aq 
42df 3e 14				ld a, display_row_2 
42e1 18 12				jr .ccol1aq 
42e3 fe 03		.crow3aq:		cp 3 
42e5 20 04				jr nz, .crow4aq 
42e7 3e 28				ld a, display_row_3 
42e9 18 0a				jr .ccol1aq 
42eb fe 04		.crow4aq:		cp 4 
42ed 20 04				jr nz, .crow1aq 
42ef 3e 3c				ld a, display_row_4 
42f1 18 02				jr .ccol1aq 
42f3 3e 00		.crow1aq:		ld a,display_row_1 
42f5 f5			.ccol1aq:		push af			; got row offset 
42f6 6f					ld l,a 
42f7 26 00				ld h,0 
42f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42f9 cd e9 21			call macro_forth_dsp_pop 
42fc				endm 
# End of macro FORTH_DSP_POP
42fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42fc cd 31 21			call macro_dsp_valuehl 
42ff				endm 
# End of macro FORTH_DSP_VALUEHL
42ff					; TODO save cursor col 
42ff f1					pop af 
4300 85					add l		; add col offset 
4301			 
4301					; add current frame buffer address 
4301 2a 55 fd				ld hl, (display_fb_active) 
4304 cd 49 0f				call addatohl 
4307			 
4307			 
4307			 
4307			 
4307					; get char frame buffer location offset in hl 
4307			 
4307 7e					ld a,(hl) 
4308 26 00				ld h, 0 
430a 6f					ld l, a 
430b			 
430b cd 3a 1f				call forth_push_numhl 
430e			 
430e			 
430e					NEXTW 
430e c3 e7 22			jp macro_next 
4311				endm 
# End of macro NEXTW
4311			 
4311			.AUTODSP: 
4311				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4311 63				db WORD_SYS_CORE+79             
4312 27 43			dw .MENU            
4314 05				db 4 + 1 
4315 .. 00			db "ADSP",0              
431a				endm 
# End of macro CWHEAD
431a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
431a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
431a			 
431a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
431a cd 31 21			call macro_dsp_valuehl 
431d				endm 
# End of macro FORTH_DSP_VALUEHL
431d			 
431d			;		push hl 
431d			 
431d					; destroy value TOS 
431d			 
431d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
431d cd e9 21			call macro_forth_dsp_pop 
4320				endm 
# End of macro FORTH_DSP_POP
4320			 
4320			;		pop hl 
4320			 
4320 7d					ld a,l 
4321 32 c9 fb				ld (cli_autodisplay), a 
4324				       NEXTW 
4324 c3 e7 22			jp macro_next 
4327				endm 
# End of macro NEXTW
4327			 
4327			.MENU: 
4327				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4327 70				db WORD_SYS_CORE+92             
4328 d0 43			dw .ENDDISPLAY            
432a 05				db 4 + 1 
432b .. 00			db "MENU",0              
4330				endm 
# End of macro CWHEAD
4330			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4330			 
4330			;		; get number of items on the stack 
4330			; 
4330				 
4330					FORTH_DSP_VALUEHL 
4330 cd 31 21			call macro_dsp_valuehl 
4333				endm 
# End of macro FORTH_DSP_VALUEHL
4333				 
4333					if DEBUG_FORTH_WORDS_KEY 
4333						DMARK "MNU" 
4333 f5				push af  
4334 3a 48 43			ld a, (.dmark)  
4337 32 b4 fe			ld (debug_mark),a  
433a 3a 49 43			ld a, (.dmark+1)  
433d 32 b5 fe			ld (debug_mark+1),a  
4340 3a 4a 43			ld a, (.dmark+2)  
4343 32 b6 fe			ld (debug_mark+2),a  
4346 18 03			jr .pastdmark  
4348 ..			.dmark: db "MNU"  
434b f1			.pastdmark: pop af  
434c			endm  
# End of macro DMARK
434c						CALLMONITOR 
434c cd c6 18			call break_point_state  
434f				endm  
# End of macro CALLMONITOR
434f					endif 
434f			 
434f 45					ld b, l	 
4350 05					dec b 
4351			 
4351					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4351 cd e9 21			call macro_forth_dsp_pop 
4354				endm 
# End of macro FORTH_DSP_POP
4354			 
4354			 
4354					; go directly through the stack to pluck out the string pointers and build an array 
4354			 
4354			;		FORTH_DSP 
4354			 
4354					; hl contains top most stack item 
4354				 
4354 11 4e f3				ld de, scratch 
4357			 
4357			.mbuild: 
4357			 
4357					FORTH_DSP_VALUEHL 
4357 cd 31 21			call macro_dsp_valuehl 
435a				endm 
# End of macro FORTH_DSP_VALUEHL
435a			 
435a					if DEBUG_FORTH_WORDS 
435a						DMARK "MN3" 
435a f5				push af  
435b 3a 6f 43			ld a, (.dmark)  
435e 32 b4 fe			ld (debug_mark),a  
4361 3a 70 43			ld a, (.dmark+1)  
4364 32 b5 fe			ld (debug_mark+1),a  
4367 3a 71 43			ld a, (.dmark+2)  
436a 32 b6 fe			ld (debug_mark+2),a  
436d 18 03			jr .pastdmark  
436f ..			.dmark: db "MN3"  
4372 f1			.pastdmark: pop af  
4373			endm  
# End of macro DMARK
4373						CALLMONITOR 
4373 cd c6 18			call break_point_state  
4376				endm  
# End of macro CALLMONITOR
4376					endif 
4376 eb					ex de, hl 
4377 73					ld (hl), e 
4378 23					inc hl 
4379 72					ld (hl), d 
437a 23					inc hl 
437b eb					ex de, hl 
437c			 
437c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
437c cd e9 21			call macro_forth_dsp_pop 
437f				endm 
# End of macro FORTH_DSP_POP
437f			 
437f 10 d6				djnz .mbuild 
4381			 
4381					; done add term 
4381			 
4381 eb					ex de, hl 
4382 36 00				ld (hl), 0 
4384 23					inc hl 
4385 36 00				ld (hl), 0 
4387			 
4387				 
4387					 
4387 21 4e f3				ld hl, scratch 
438a			 
438a					if DEBUG_FORTH_WORDS 
438a						DMARK "MNx" 
438a f5				push af  
438b 3a 9f 43			ld a, (.dmark)  
438e 32 b4 fe			ld (debug_mark),a  
4391 3a a0 43			ld a, (.dmark+1)  
4394 32 b5 fe			ld (debug_mark+1),a  
4397 3a a1 43			ld a, (.dmark+2)  
439a 32 b6 fe			ld (debug_mark+2),a  
439d 18 03			jr .pastdmark  
439f ..			.dmark: db "MNx"  
43a2 f1			.pastdmark: pop af  
43a3			endm  
# End of macro DMARK
43a3						CALLMONITOR 
43a3 cd c6 18			call break_point_state  
43a6				endm  
# End of macro CALLMONITOR
43a6					endif 
43a6			 
43a6			 
43a6			 
43a6 3e 00				ld a, 0 
43a8 cd 46 0d				call menu 
43ab			 
43ab			 
43ab 6f					ld l, a 
43ac 26 00				ld h, 0 
43ae			 
43ae					if DEBUG_FORTH_WORDS 
43ae						DMARK "MNr" 
43ae f5				push af  
43af 3a c3 43			ld a, (.dmark)  
43b2 32 b4 fe			ld (debug_mark),a  
43b5 3a c4 43			ld a, (.dmark+1)  
43b8 32 b5 fe			ld (debug_mark+1),a  
43bb 3a c5 43			ld a, (.dmark+2)  
43be 32 b6 fe			ld (debug_mark+2),a  
43c1 18 03			jr .pastdmark  
43c3 ..			.dmark: db "MNr"  
43c6 f1			.pastdmark: pop af  
43c7			endm  
# End of macro DMARK
43c7						CALLMONITOR 
43c7 cd c6 18			call break_point_state  
43ca				endm  
# End of macro CALLMONITOR
43ca					endif 
43ca			 
43ca cd 3a 1f				call forth_push_numhl 
43cd			 
43cd			 
43cd			 
43cd			 
43cd				       NEXTW 
43cd c3 e7 22			jp macro_next 
43d0				endm 
# End of macro NEXTW
43d0			 
43d0			 
43d0			.ENDDISPLAY: 
43d0			 
43d0			; eof 
# End of file forth_words_display.asm
43d0			include "forth_words_str.asm" 
43d0			 
43d0			; | ## String Words 
43d0			 
43d0			.PTR:   
43d0			 
43d0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
43d0 48				db WORD_SYS_CORE+52             
43d1 fd 43			dw .STYPE            
43d3 04				db 3 + 1 
43d4 .. 00			db "PTR",0              
43d8				endm 
# End of macro CWHEAD
43d8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
43d8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
43d8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
43d8			 
43d8					if DEBUG_FORTH_WORDS_KEY 
43d8						DMARK "PTR" 
43d8 f5				push af  
43d9 3a ed 43			ld a, (.dmark)  
43dc 32 b4 fe			ld (debug_mark),a  
43df 3a ee 43			ld a, (.dmark+1)  
43e2 32 b5 fe			ld (debug_mark+1),a  
43e5 3a ef 43			ld a, (.dmark+2)  
43e8 32 b6 fe			ld (debug_mark+2),a  
43eb 18 03			jr .pastdmark  
43ed ..			.dmark: db "PTR"  
43f0 f1			.pastdmark: pop af  
43f1			endm  
# End of macro DMARK
43f1						CALLMONITOR 
43f1 cd c6 18			call break_point_state  
43f4				endm  
# End of macro CALLMONITOR
43f4					endif 
43f4					FORTH_DSP_VALUEHL 
43f4 cd 31 21			call macro_dsp_valuehl 
43f7				endm 
# End of macro FORTH_DSP_VALUEHL
43f7 cd 3a 1f				call forth_push_numhl 
43fa			 
43fa			 
43fa					NEXTW 
43fa c3 e7 22			jp macro_next 
43fd				endm 
# End of macro NEXTW
43fd			.STYPE: 
43fd				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
43fd 48				db WORD_SYS_CORE+52             
43fe 4c 44			dw .UPPER            
4400 06				db 5 + 1 
4401 .. 00			db "STYPE",0              
4407				endm 
# End of macro CWHEAD
4407			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4407					if DEBUG_FORTH_WORDS_KEY 
4407						DMARK "STY" 
4407 f5				push af  
4408 3a 1c 44			ld a, (.dmark)  
440b 32 b4 fe			ld (debug_mark),a  
440e 3a 1d 44			ld a, (.dmark+1)  
4411 32 b5 fe			ld (debug_mark+1),a  
4414 3a 1e 44			ld a, (.dmark+2)  
4417 32 b6 fe			ld (debug_mark+2),a  
441a 18 03			jr .pastdmark  
441c ..			.dmark: db "STY"  
441f f1			.pastdmark: pop af  
4420			endm  
# End of macro DMARK
4420						CALLMONITOR 
4420 cd c6 18			call break_point_state  
4423				endm  
# End of macro CALLMONITOR
4423					endif 
4423					FORTH_DSP 
4423 cd f7 20			call macro_forth_dsp 
4426				endm 
# End of macro FORTH_DSP
4426					;v5 FORTH_DSP_VALUE 
4426			 
4426 7e					ld a, (hl) 
4427			 
4427 f5					push af 
4428			 
4428			; Dont destroy TOS		FORTH_DSP_POP 
4428			 
4428 f1					pop af 
4429			 
4429 fe 01				cp DS_TYPE_STR 
442b 28 09				jr z, .typestr 
442d			 
442d fe 02				cp DS_TYPE_INUM 
442f 28 0a				jr z, .typeinum 
4431			 
4431 21 4a 44				ld hl, .tna 
4434 18 0a				jr .tpush 
4436			 
4436 21 46 44		.typestr:	ld hl, .tstr 
4439 18 05				jr .tpush 
443b 21 48 44		.typeinum:	ld hl, .tinum 
443e 18 00				jr .tpush 
4440			 
4440			.tpush: 
4440			 
4440 cd a8 1f				call forth_push_str 
4443			 
4443					NEXTW 
4443 c3 e7 22			jp macro_next 
4446				endm 
# End of macro NEXTW
4446 .. 00		.tstr:	db "s",0 
4448 .. 00		.tinum:  db "i",0 
444a .. 00		.tna:   db "?", 0 
444c			 
444c			 
444c			.UPPER: 
444c				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
444c 48				db WORD_SYS_CORE+52             
444d 87 44			dw .LOWER            
444f 06				db 5 + 1 
4450 .. 00			db "UPPER",0              
4456				endm 
# End of macro CWHEAD
4456			; | UPPER ( s -- s ) Upper case string s  | DONE 
4456					if DEBUG_FORTH_WORDS_KEY 
4456						DMARK "UPR" 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 b4 fe			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 b5 fe			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 b6 fe			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "UPR"  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f						CALLMONITOR 
446f cd c6 18			call break_point_state  
4472				endm  
# End of macro CALLMONITOR
4472					endif 
4472			 
4472					FORTH_DSP 
4472 cd f7 20			call macro_forth_dsp 
4475				endm 
# End of macro FORTH_DSP
4475					 
4475			; TODO check is string type 
4475			 
4475					FORTH_DSP_VALUEHL 
4475 cd 31 21			call macro_dsp_valuehl 
4478				endm 
# End of macro FORTH_DSP_VALUEHL
4478			; get pointer to string in hl 
4478			 
4478 7e			.toup:		ld a, (hl) 
4479 fe 00				cp 0 
447b 28 07				jr z, .toupdone 
447d			 
447d cd b6 12				call to_upper 
4480			 
4480 77					ld (hl), a 
4481 23					inc hl 
4482 18 f4				jr .toup 
4484			 
4484					 
4484			 
4484			 
4484			; for each char convert to upper 
4484					 
4484			.toupdone: 
4484			 
4484			 
4484					NEXTW 
4484 c3 e7 22			jp macro_next 
4487				endm 
# End of macro NEXTW
4487			.LOWER: 
4487				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4487 48				db WORD_SYS_CORE+52             
4488 c2 44			dw .TCASE            
448a 06				db 5 + 1 
448b .. 00			db "LOWER",0              
4491				endm 
# End of macro CWHEAD
4491			; | LOWER ( s -- s ) Lower case string s  | DONE 
4491					if DEBUG_FORTH_WORDS_KEY 
4491						DMARK "LWR" 
4491 f5				push af  
4492 3a a6 44			ld a, (.dmark)  
4495 32 b4 fe			ld (debug_mark),a  
4498 3a a7 44			ld a, (.dmark+1)  
449b 32 b5 fe			ld (debug_mark+1),a  
449e 3a a8 44			ld a, (.dmark+2)  
44a1 32 b6 fe			ld (debug_mark+2),a  
44a4 18 03			jr .pastdmark  
44a6 ..			.dmark: db "LWR"  
44a9 f1			.pastdmark: pop af  
44aa			endm  
# End of macro DMARK
44aa						CALLMONITOR 
44aa cd c6 18			call break_point_state  
44ad				endm  
# End of macro CALLMONITOR
44ad					endif 
44ad			 
44ad					FORTH_DSP 
44ad cd f7 20			call macro_forth_dsp 
44b0				endm 
# End of macro FORTH_DSP
44b0					 
44b0			; TODO check is string type 
44b0			 
44b0					FORTH_DSP_VALUEHL 
44b0 cd 31 21			call macro_dsp_valuehl 
44b3				endm 
# End of macro FORTH_DSP_VALUEHL
44b3			; get pointer to string in hl 
44b3			 
44b3 7e			.tolow:		ld a, (hl) 
44b4 fe 00				cp 0 
44b6 28 07				jr z, .tolowdone 
44b8			 
44b8 cd bf 12				call to_lower 
44bb			 
44bb 77					ld (hl), a 
44bc 23					inc hl 
44bd 18 f4				jr .tolow 
44bf			 
44bf					 
44bf			 
44bf			 
44bf			; for each char convert to low 
44bf					 
44bf			.tolowdone: 
44bf					NEXTW 
44bf c3 e7 22			jp macro_next 
44c2				endm 
# End of macro NEXTW
44c2			.TCASE: 
44c2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
44c2 48				db WORD_SYS_CORE+52             
44c3 f8 45			dw .SUBSTR            
44c5 06				db 5 + 1 
44c6 .. 00			db "TCASE",0              
44cc				endm 
# End of macro CWHEAD
44cc			; | TCASE ( s -- s ) Title case string s  | DONE 
44cc					if DEBUG_FORTH_WORDS_KEY 
44cc						DMARK "TCS" 
44cc f5				push af  
44cd 3a e1 44			ld a, (.dmark)  
44d0 32 b4 fe			ld (debug_mark),a  
44d3 3a e2 44			ld a, (.dmark+1)  
44d6 32 b5 fe			ld (debug_mark+1),a  
44d9 3a e3 44			ld a, (.dmark+2)  
44dc 32 b6 fe			ld (debug_mark+2),a  
44df 18 03			jr .pastdmark  
44e1 ..			.dmark: db "TCS"  
44e4 f1			.pastdmark: pop af  
44e5			endm  
# End of macro DMARK
44e5						CALLMONITOR 
44e5 cd c6 18			call break_point_state  
44e8				endm  
# End of macro CALLMONITOR
44e8					endif 
44e8			 
44e8					FORTH_DSP 
44e8 cd f7 20			call macro_forth_dsp 
44eb				endm 
# End of macro FORTH_DSP
44eb					 
44eb			; TODO check is string type 
44eb			 
44eb					FORTH_DSP_VALUEHL 
44eb cd 31 21			call macro_dsp_valuehl 
44ee				endm 
# End of macro FORTH_DSP_VALUEHL
44ee			; get pointer to string in hl 
44ee			 
44ee					if DEBUG_FORTH_WORDS 
44ee						DMARK "TC1" 
44ee f5				push af  
44ef 3a 03 45			ld a, (.dmark)  
44f2 32 b4 fe			ld (debug_mark),a  
44f5 3a 04 45			ld a, (.dmark+1)  
44f8 32 b5 fe			ld (debug_mark+1),a  
44fb 3a 05 45			ld a, (.dmark+2)  
44fe 32 b6 fe			ld (debug_mark+2),a  
4501 18 03			jr .pastdmark  
4503 ..			.dmark: db "TC1"  
4506 f1			.pastdmark: pop af  
4507			endm  
# End of macro DMARK
4507						CALLMONITOR 
4507 cd c6 18			call break_point_state  
450a				endm  
# End of macro CALLMONITOR
450a					endif 
450a			 
450a					; first time in turn to upper case first char 
450a			 
450a 7e					ld a, (hl) 
450b c3 95 45				jp .totsiptou 
450e			 
450e			 
450e 7e			.tot:		ld a, (hl) 
450f fe 00				cp 0 
4511 ca d9 45				jp z, .totdone 
4514			 
4514					if DEBUG_FORTH_WORDS 
4514						DMARK "TC2" 
4514 f5				push af  
4515 3a 29 45			ld a, (.dmark)  
4518 32 b4 fe			ld (debug_mark),a  
451b 3a 2a 45			ld a, (.dmark+1)  
451e 32 b5 fe			ld (debug_mark+1),a  
4521 3a 2b 45			ld a, (.dmark+2)  
4524 32 b6 fe			ld (debug_mark+2),a  
4527 18 03			jr .pastdmark  
4529 ..			.dmark: db "TC2"  
452c f1			.pastdmark: pop af  
452d			endm  
# End of macro DMARK
452d						CALLMONITOR 
452d cd c6 18			call break_point_state  
4530				endm  
# End of macro CALLMONITOR
4530					endif 
4530					; check to see if current char is a space 
4530			 
4530 fe 20				cp ' ' 
4532 28 21				jr z, .totsp 
4534 cd bf 12				call to_lower 
4537					if DEBUG_FORTH_WORDS 
4537						DMARK "TC3" 
4537 f5				push af  
4538 3a 4c 45			ld a, (.dmark)  
453b 32 b4 fe			ld (debug_mark),a  
453e 3a 4d 45			ld a, (.dmark+1)  
4541 32 b5 fe			ld (debug_mark+1),a  
4544 3a 4e 45			ld a, (.dmark+2)  
4547 32 b6 fe			ld (debug_mark+2),a  
454a 18 03			jr .pastdmark  
454c ..			.dmark: db "TC3"  
454f f1			.pastdmark: pop af  
4550			endm  
# End of macro DMARK
4550						CALLMONITOR 
4550 cd c6 18			call break_point_state  
4553				endm  
# End of macro CALLMONITOR
4553					endif 
4553 18 63				jr .totnxt 
4555			 
4555			.totsp:         ; on a space, find next char which should be upper 
4555			 
4555					if DEBUG_FORTH_WORDS 
4555						DMARK "TC4" 
4555 f5				push af  
4556 3a 6a 45			ld a, (.dmark)  
4559 32 b4 fe			ld (debug_mark),a  
455c 3a 6b 45			ld a, (.dmark+1)  
455f 32 b5 fe			ld (debug_mark+1),a  
4562 3a 6c 45			ld a, (.dmark+2)  
4565 32 b6 fe			ld (debug_mark+2),a  
4568 18 03			jr .pastdmark  
456a ..			.dmark: db "TC4"  
456d f1			.pastdmark: pop af  
456e			endm  
# End of macro DMARK
456e						CALLMONITOR 
456e cd c6 18			call break_point_state  
4571				endm  
# End of macro CALLMONITOR
4571					endif 
4571					;; 
4571			 
4571 fe 20				cp ' ' 
4573 20 20				jr nz, .totsiptou 
4575 23					inc hl 
4576 7e					ld a, (hl) 
4577					if DEBUG_FORTH_WORDS 
4577						DMARK "TC5" 
4577 f5				push af  
4578 3a 8c 45			ld a, (.dmark)  
457b 32 b4 fe			ld (debug_mark),a  
457e 3a 8d 45			ld a, (.dmark+1)  
4581 32 b5 fe			ld (debug_mark+1),a  
4584 3a 8e 45			ld a, (.dmark+2)  
4587 32 b6 fe			ld (debug_mark+2),a  
458a 18 03			jr .pastdmark  
458c ..			.dmark: db "TC5"  
458f f1			.pastdmark: pop af  
4590			endm  
# End of macro DMARK
4590						CALLMONITOR 
4590 cd c6 18			call break_point_state  
4593				endm  
# End of macro CALLMONITOR
4593					endif 
4593 18 c0				jr .totsp 
4595 fe 00		.totsiptou:    cp 0 
4597 28 40				jr z, .totdone 
4599					; not space and not zero term so upper case it 
4599 cd b6 12				call to_upper 
459c			 
459c					if DEBUG_FORTH_WORDS 
459c						DMARK "TC6" 
459c f5				push af  
459d 3a b1 45			ld a, (.dmark)  
45a0 32 b4 fe			ld (debug_mark),a  
45a3 3a b2 45			ld a, (.dmark+1)  
45a6 32 b5 fe			ld (debug_mark+1),a  
45a9 3a b3 45			ld a, (.dmark+2)  
45ac 32 b6 fe			ld (debug_mark+2),a  
45af 18 03			jr .pastdmark  
45b1 ..			.dmark: db "TC6"  
45b4 f1			.pastdmark: pop af  
45b5			endm  
# End of macro DMARK
45b5						CALLMONITOR 
45b5 cd c6 18			call break_point_state  
45b8				endm  
# End of macro CALLMONITOR
45b8					endif 
45b8			 
45b8			 
45b8			.totnxt: 
45b8			 
45b8 77					ld (hl), a 
45b9 23					inc hl 
45ba					if DEBUG_FORTH_WORDS 
45ba						DMARK "TC7" 
45ba f5				push af  
45bb 3a cf 45			ld a, (.dmark)  
45be 32 b4 fe			ld (debug_mark),a  
45c1 3a d0 45			ld a, (.dmark+1)  
45c4 32 b5 fe			ld (debug_mark+1),a  
45c7 3a d1 45			ld a, (.dmark+2)  
45ca 32 b6 fe			ld (debug_mark+2),a  
45cd 18 03			jr .pastdmark  
45cf ..			.dmark: db "TC7"  
45d2 f1			.pastdmark: pop af  
45d3			endm  
# End of macro DMARK
45d3						CALLMONITOR 
45d3 cd c6 18			call break_point_state  
45d6				endm  
# End of macro CALLMONITOR
45d6					endif 
45d6 c3 0e 45				jp .tot 
45d9			 
45d9					 
45d9			 
45d9			 
45d9			; for each char convert to low 
45d9					 
45d9			.totdone: 
45d9					if DEBUG_FORTH_WORDS 
45d9						DMARK "TCd" 
45d9 f5				push af  
45da 3a ee 45			ld a, (.dmark)  
45dd 32 b4 fe			ld (debug_mark),a  
45e0 3a ef 45			ld a, (.dmark+1)  
45e3 32 b5 fe			ld (debug_mark+1),a  
45e6 3a f0 45			ld a, (.dmark+2)  
45e9 32 b6 fe			ld (debug_mark+2),a  
45ec 18 03			jr .pastdmark  
45ee ..			.dmark: db "TCd"  
45f1 f1			.pastdmark: pop af  
45f2			endm  
# End of macro DMARK
45f2						CALLMONITOR 
45f2 cd c6 18			call break_point_state  
45f5				endm  
# End of macro CALLMONITOR
45f5					endif 
45f5					NEXTW 
45f5 c3 e7 22			jp macro_next 
45f8				endm 
# End of macro NEXTW
45f8			 
45f8			.SUBSTR: 
45f8				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
45f8 48				db WORD_SYS_CORE+52             
45f9 56 46			dw .LEFT            
45fb 07				db 6 + 1 
45fc .. 00			db "SUBSTR",0              
4603				endm 
# End of macro CWHEAD
4603			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4603			 
4603					if DEBUG_FORTH_WORDS_KEY 
4603						DMARK "SST" 
4603 f5				push af  
4604 3a 18 46			ld a, (.dmark)  
4607 32 b4 fe			ld (debug_mark),a  
460a 3a 19 46			ld a, (.dmark+1)  
460d 32 b5 fe			ld (debug_mark+1),a  
4610 3a 1a 46			ld a, (.dmark+2)  
4613 32 b6 fe			ld (debug_mark+2),a  
4616 18 03			jr .pastdmark  
4618 ..			.dmark: db "SST"  
461b f1			.pastdmark: pop af  
461c			endm  
# End of macro DMARK
461c						CALLMONITOR 
461c cd c6 18			call break_point_state  
461f				endm  
# End of macro CALLMONITOR
461f					endif 
461f			; TODO check string type 
461f					FORTH_DSP_VALUEHL 
461f cd 31 21			call macro_dsp_valuehl 
4622				endm 
# End of macro FORTH_DSP_VALUEHL
4622			 
4622 e5					push hl      ; string length 
4623			 
4623					FORTH_DSP_POP 
4623 cd e9 21			call macro_forth_dsp_pop 
4626				endm 
# End of macro FORTH_DSP_POP
4626			 
4626					FORTH_DSP_VALUEHL 
4626 cd 31 21			call macro_dsp_valuehl 
4629				endm 
# End of macro FORTH_DSP_VALUEHL
4629			 
4629 e5					push hl     ; start char 
462a			 
462a					FORTH_DSP_POP 
462a cd e9 21			call macro_forth_dsp_pop 
462d				endm 
# End of macro FORTH_DSP_POP
462d			 
462d			 
462d					FORTH_DSP_VALUE 
462d cd 1a 21			call macro_forth_dsp_value 
4630				endm 
# End of macro FORTH_DSP_VALUE
4630			 
4630 d1					pop de    ; get start post offset 
4631			 
4631 19					add hl, de    ; starting offset 
4632			 
4632 c1					pop bc 
4633 c5					push bc      ; grab size of string 
4634			 
4634 e5					push hl    ; save string start  
4635			 
4635 26 00				ld h, 0 
4637 69					ld l, c 
4638 23					inc hl 
4639 23					inc hl 
463a			 
463a cd 10 14				call malloc 
463d				if DEBUG_FORTH_MALLOC_GUARD 
463d cc 38 5a				call z,malloc_error 
4640				endif 
4640			 
4640 eb					ex de, hl      ; save malloc area for string copy 
4641 e1					pop hl    ; get back source 
4642 c1					pop bc    ; get length of string back 
4643			 
4643 d5					push de    ; save malloc area for after we push 
4644 ed b0				ldir     ; copy substr 
4646			 
4646			 
4646 eb					ex de, hl 
4647 3e 00				ld a, 0 
4649 77					ld (hl), a   ; term substr 
464a			 
464a					 
464a e1					pop hl    ; get malloc so we can push it 
464b e5					push hl   ; save so we can free it afterwards 
464c			 
464c cd a8 1f				call forth_push_str 
464f			 
464f e1					pop hl 
4650 cd da 14				call free 
4653			 
4653					 
4653					 
4653			 
4653			 
4653					NEXTW 
4653 c3 e7 22			jp macro_next 
4656				endm 
# End of macro NEXTW
4656			 
4656			.LEFT: 
4656				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4656 48				db WORD_SYS_CORE+52             
4657 7e 46			dw .RIGHT            
4659 05				db 4 + 1 
465a .. 00			db "LEFT",0              
465f				endm 
# End of macro CWHEAD
465f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
465f					if DEBUG_FORTH_WORDS_KEY 
465f						DMARK "LEF" 
465f f5				push af  
4660 3a 74 46			ld a, (.dmark)  
4663 32 b4 fe			ld (debug_mark),a  
4666 3a 75 46			ld a, (.dmark+1)  
4669 32 b5 fe			ld (debug_mark+1),a  
466c 3a 76 46			ld a, (.dmark+2)  
466f 32 b6 fe			ld (debug_mark+2),a  
4672 18 03			jr .pastdmark  
4674 ..			.dmark: db "LEF"  
4677 f1			.pastdmark: pop af  
4678			endm  
# End of macro DMARK
4678						CALLMONITOR 
4678 cd c6 18			call break_point_state  
467b				endm  
# End of macro CALLMONITOR
467b					endif 
467b			 
467b					NEXTW 
467b c3 e7 22			jp macro_next 
467e				endm 
# End of macro NEXTW
467e			.RIGHT: 
467e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
467e 48				db WORD_SYS_CORE+52             
467f a7 46			dw .STR2NUM            
4681 06				db 5 + 1 
4682 .. 00			db "RIGHT",0              
4688				endm 
# End of macro CWHEAD
4688			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4688					if DEBUG_FORTH_WORDS_KEY 
4688						DMARK "RIG" 
4688 f5				push af  
4689 3a 9d 46			ld a, (.dmark)  
468c 32 b4 fe			ld (debug_mark),a  
468f 3a 9e 46			ld a, (.dmark+1)  
4692 32 b5 fe			ld (debug_mark+1),a  
4695 3a 9f 46			ld a, (.dmark+2)  
4698 32 b6 fe			ld (debug_mark+2),a  
469b 18 03			jr .pastdmark  
469d ..			.dmark: db "RIG"  
46a0 f1			.pastdmark: pop af  
46a1			endm  
# End of macro DMARK
46a1						CALLMONITOR 
46a1 cd c6 18			call break_point_state  
46a4				endm  
# End of macro CALLMONITOR
46a4					endif 
46a4			 
46a4					NEXTW 
46a4 c3 e7 22			jp macro_next 
46a7				endm 
# End of macro NEXTW
46a7			 
46a7			 
46a7			.STR2NUM: 
46a7				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
46a7 48				db WORD_SYS_CORE+52             
46a8 33 47			dw .NUM2STR            
46aa 08				db 7 + 1 
46ab .. 00			db "STR2NUM",0              
46b3				endm 
# End of macro CWHEAD
46b3			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
46b3			 
46b3			 
46b3			; TODO STR type check to do 
46b3					if DEBUG_FORTH_WORDS_KEY 
46b3						DMARK "S2N" 
46b3 f5				push af  
46b4 3a c8 46			ld a, (.dmark)  
46b7 32 b4 fe			ld (debug_mark),a  
46ba 3a c9 46			ld a, (.dmark+1)  
46bd 32 b5 fe			ld (debug_mark+1),a  
46c0 3a ca 46			ld a, (.dmark+2)  
46c3 32 b6 fe			ld (debug_mark+2),a  
46c6 18 03			jr .pastdmark  
46c8 ..			.dmark: db "S2N"  
46cb f1			.pastdmark: pop af  
46cc			endm  
# End of macro DMARK
46cc						CALLMONITOR 
46cc cd c6 18			call break_point_state  
46cf				endm  
# End of macro CALLMONITOR
46cf					endif 
46cf			 
46cf					;FORTH_DSP 
46cf					FORTH_DSP_VALUE 
46cf cd 1a 21			call macro_forth_dsp_value 
46d2				endm 
# End of macro FORTH_DSP_VALUE
46d2					;inc hl 
46d2			 
46d2 eb					ex de, hl 
46d3					if DEBUG_FORTH_WORDS 
46d3						DMARK "S2a" 
46d3 f5				push af  
46d4 3a e8 46			ld a, (.dmark)  
46d7 32 b4 fe			ld (debug_mark),a  
46da 3a e9 46			ld a, (.dmark+1)  
46dd 32 b5 fe			ld (debug_mark+1),a  
46e0 3a ea 46			ld a, (.dmark+2)  
46e3 32 b6 fe			ld (debug_mark+2),a  
46e6 18 03			jr .pastdmark  
46e8 ..			.dmark: db "S2a"  
46eb f1			.pastdmark: pop af  
46ec			endm  
# End of macro DMARK
46ec						CALLMONITOR 
46ec cd c6 18			call break_point_state  
46ef				endm  
# End of macro CALLMONITOR
46ef					endif 
46ef cd 3e 13				call string_to_uint16 
46f2			 
46f2					if DEBUG_FORTH_WORDS 
46f2						DMARK "S2b" 
46f2 f5				push af  
46f3 3a 07 47			ld a, (.dmark)  
46f6 32 b4 fe			ld (debug_mark),a  
46f9 3a 08 47			ld a, (.dmark+1)  
46fc 32 b5 fe			ld (debug_mark+1),a  
46ff 3a 09 47			ld a, (.dmark+2)  
4702 32 b6 fe			ld (debug_mark+2),a  
4705 18 03			jr .pastdmark  
4707 ..			.dmark: db "S2b"  
470a f1			.pastdmark: pop af  
470b			endm  
# End of macro DMARK
470b						CALLMONITOR 
470b cd c6 18			call break_point_state  
470e				endm  
# End of macro CALLMONITOR
470e					endif 
470e			;		push hl 
470e					FORTH_DSP_POP 
470e cd e9 21			call macro_forth_dsp_pop 
4711				endm 
# End of macro FORTH_DSP_POP
4711			;		pop hl 
4711					 
4711					if DEBUG_FORTH_WORDS 
4711						DMARK "S2b" 
4711 f5				push af  
4712 3a 26 47			ld a, (.dmark)  
4715 32 b4 fe			ld (debug_mark),a  
4718 3a 27 47			ld a, (.dmark+1)  
471b 32 b5 fe			ld (debug_mark+1),a  
471e 3a 28 47			ld a, (.dmark+2)  
4721 32 b6 fe			ld (debug_mark+2),a  
4724 18 03			jr .pastdmark  
4726 ..			.dmark: db "S2b"  
4729 f1			.pastdmark: pop af  
472a			endm  
# End of macro DMARK
472a						CALLMONITOR 
472a cd c6 18			call break_point_state  
472d				endm  
# End of macro CALLMONITOR
472d					endif 
472d cd 3a 1f				call forth_push_numhl	 
4730			 
4730				 
4730				       NEXTW 
4730 c3 e7 22			jp macro_next 
4733				endm 
# End of macro NEXTW
4733			.NUM2STR: 
4733				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4733 48				db WORD_SYS_CORE+52             
4734 42 47			dw .CONCAT            
4736 08				db 7 + 1 
4737 .. 00			db "NUM2STR",0              
473f				endm 
# End of macro CWHEAD
473f			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
473f			 
473f			;		; malloc a string to target 
473f			;		ld hl, 10     ; TODO max string size should be fine 
473f			;		call malloc 
473f			;		push hl    ; save malloc location 
473f			; 
473f			; 
473f			;; TODO check int type 
473f			;		FORTH_DSP_VALUEHL 
473f			;		ld a, l 
473f			;		call DispAToASCII   
473f			;;TODO need to chage above call to dump into string 
473f			; 
473f			; 
473f			 
473f				       NEXTW 
473f c3 e7 22			jp macro_next 
4742				endm 
# End of macro NEXTW
4742			 
4742			.CONCAT: 
4742				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4742 48				db WORD_SYS_CORE+52             
4743 f5 47			dw .FIND            
4745 07				db 6 + 1 
4746 .. 00			db "CONCAT",0              
474d				endm 
# End of macro CWHEAD
474d			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
474d			 
474d			; TODO check string type 
474d			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
474d			 
474d					if DEBUG_FORTH_WORDS_KEY 
474d						DMARK "CON" 
474d f5				push af  
474e 3a 62 47			ld a, (.dmark)  
4751 32 b4 fe			ld (debug_mark),a  
4754 3a 63 47			ld a, (.dmark+1)  
4757 32 b5 fe			ld (debug_mark+1),a  
475a 3a 64 47			ld a, (.dmark+2)  
475d 32 b6 fe			ld (debug_mark+2),a  
4760 18 03			jr .pastdmark  
4762 ..			.dmark: db "CON"  
4765 f1			.pastdmark: pop af  
4766			endm  
# End of macro DMARK
4766						CALLMONITOR 
4766 cd c6 18			call break_point_state  
4769				endm  
# End of macro CALLMONITOR
4769					endif 
4769			 
4769			 
4769					FORTH_DSP_VALUE 
4769 cd 1a 21			call macro_forth_dsp_value 
476c				endm 
# End of macro FORTH_DSP_VALUE
476c e5					push hl   ; s2 
476d			 
476d					FORTH_DSP_POP 
476d cd e9 21			call macro_forth_dsp_pop 
4770				endm 
# End of macro FORTH_DSP_POP
4770			 
4770					FORTH_DSP_VALUE 
4770 cd 1a 21			call macro_forth_dsp_value 
4773				endm 
# End of macro FORTH_DSP_VALUE
4773			 
4773 e5					push hl   ; s1 
4774			 
4774					FORTH_DSP_POP 
4774 cd e9 21			call macro_forth_dsp_pop 
4777				endm 
# End of macro FORTH_DSP_POP
4777					 
4777			 
4777					; copy s1 
4777			 
4777				 
4777					; save ptr 
4777 e1					pop hl  
4778 e5					push hl 
4779 3e 00				ld a, 0 
477b cd b2 13				call strlent 
477e					;inc hl    ; zer0 
477e 06 00				ld b, 0 
4780 4d					ld c, l 
4781 e1					pop hl		 
4782 11 4e f3				ld de, scratch	 
4785					if DEBUG_FORTH_WORDS 
4785						DMARK "CO1" 
4785 f5				push af  
4786 3a 9a 47			ld a, (.dmark)  
4789 32 b4 fe			ld (debug_mark),a  
478c 3a 9b 47			ld a, (.dmark+1)  
478f 32 b5 fe			ld (debug_mark+1),a  
4792 3a 9c 47			ld a, (.dmark+2)  
4795 32 b6 fe			ld (debug_mark+2),a  
4798 18 03			jr .pastdmark  
479a ..			.dmark: db "CO1"  
479d f1			.pastdmark: pop af  
479e			endm  
# End of macro DMARK
479e						CALLMONITOR 
479e cd c6 18			call break_point_state  
47a1				endm  
# End of macro CALLMONITOR
47a1					endif 
47a1 ed b0				ldir 
47a3			 
47a3 e1					pop hl 
47a4 e5					push hl 
47a5 d5					push de 
47a6			 
47a6			 
47a6 3e 00				ld a, 0 
47a8 cd b2 13				call strlent 
47ab 23					inc hl    ; zer0 
47ac 23					inc hl 
47ad 06 00				ld b, 0 
47af 4d					ld c, l 
47b0 d1					pop de 
47b1 e1					pop hl		 
47b2					if DEBUG_FORTH_WORDS 
47b2						DMARK "CO2" 
47b2 f5				push af  
47b3 3a c7 47			ld a, (.dmark)  
47b6 32 b4 fe			ld (debug_mark),a  
47b9 3a c8 47			ld a, (.dmark+1)  
47bc 32 b5 fe			ld (debug_mark+1),a  
47bf 3a c9 47			ld a, (.dmark+2)  
47c2 32 b6 fe			ld (debug_mark+2),a  
47c5 18 03			jr .pastdmark  
47c7 ..			.dmark: db "CO2"  
47ca f1			.pastdmark: pop af  
47cb			endm  
# End of macro DMARK
47cb						CALLMONITOR 
47cb cd c6 18			call break_point_state  
47ce				endm  
# End of macro CALLMONITOR
47ce					endif 
47ce ed b0				ldir 
47d0			 
47d0			 
47d0			 
47d0 21 4e f3				ld hl, scratch 
47d3					if DEBUG_FORTH_WORDS 
47d3						DMARK "CO5" 
47d3 f5				push af  
47d4 3a e8 47			ld a, (.dmark)  
47d7 32 b4 fe			ld (debug_mark),a  
47da 3a e9 47			ld a, (.dmark+1)  
47dd 32 b5 fe			ld (debug_mark+1),a  
47e0 3a ea 47			ld a, (.dmark+2)  
47e3 32 b6 fe			ld (debug_mark+2),a  
47e6 18 03			jr .pastdmark  
47e8 ..			.dmark: db "CO5"  
47eb f1			.pastdmark: pop af  
47ec			endm  
# End of macro DMARK
47ec						CALLMONITOR 
47ec cd c6 18			call break_point_state  
47ef				endm  
# End of macro CALLMONITOR
47ef					endif 
47ef			 
47ef cd a8 1f				call forth_push_str 
47f2			 
47f2			 
47f2			 
47f2			 
47f2				       NEXTW 
47f2 c3 e7 22			jp macro_next 
47f5				endm 
# End of macro NEXTW
47f5			 
47f5			 
47f5			.FIND: 
47f5				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
47f5 4b				db WORD_SYS_CORE+55             
47f6 b3 48			dw .LEN            
47f8 05				db 4 + 1 
47f9 .. 00			db "FIND",0              
47fe				endm 
# End of macro CWHEAD
47fe			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
47fe			 
47fe					if DEBUG_FORTH_WORDS_KEY 
47fe						DMARK "FND" 
47fe f5				push af  
47ff 3a 13 48			ld a, (.dmark)  
4802 32 b4 fe			ld (debug_mark),a  
4805 3a 14 48			ld a, (.dmark+1)  
4808 32 b5 fe			ld (debug_mark+1),a  
480b 3a 15 48			ld a, (.dmark+2)  
480e 32 b6 fe			ld (debug_mark+2),a  
4811 18 03			jr .pastdmark  
4813 ..			.dmark: db "FND"  
4816 f1			.pastdmark: pop af  
4817			endm  
# End of macro DMARK
4817						CALLMONITOR 
4817 cd c6 18			call break_point_state  
481a				endm  
# End of macro CALLMONITOR
481a					endif 
481a			 
481a			; TODO check string type 
481a					FORTH_DSP_VALUE 
481a cd 1a 21			call macro_forth_dsp_value 
481d				endm 
# End of macro FORTH_DSP_VALUE
481d			 
481d e5					push hl    
481e 7e					ld a,(hl)    ; char to find   
481f			; TODO change char to substr 
481f			 
481f f5					push af 
4820					 
4820			 
4820			 
4820					if DEBUG_FORTH_WORDS 
4820						DMARK "FN1" 
4820 f5				push af  
4821 3a 35 48			ld a, (.dmark)  
4824 32 b4 fe			ld (debug_mark),a  
4827 3a 36 48			ld a, (.dmark+1)  
482a 32 b5 fe			ld (debug_mark+1),a  
482d 3a 37 48			ld a, (.dmark+2)  
4830 32 b6 fe			ld (debug_mark+2),a  
4833 18 03			jr .pastdmark  
4835 ..			.dmark: db "FN1"  
4838 f1			.pastdmark: pop af  
4839			endm  
# End of macro DMARK
4839						CALLMONITOR 
4839 cd c6 18			call break_point_state  
483c				endm  
# End of macro CALLMONITOR
483c					endif 
483c			 
483c					FORTH_DSP_POP 
483c cd e9 21			call macro_forth_dsp_pop 
483f				endm 
# End of macro FORTH_DSP_POP
483f			 
483f					; string to search 
483f			 
483f					FORTH_DSP_VALUE 
483f cd 1a 21			call macro_forth_dsp_value 
4842				endm 
# End of macro FORTH_DSP_VALUE
4842			 
4842 d1					pop de  ; d is char to find  
4843			 
4843					if DEBUG_FORTH_WORDS 
4843						DMARK "FN2" 
4843 f5				push af  
4844 3a 58 48			ld a, (.dmark)  
4847 32 b4 fe			ld (debug_mark),a  
484a 3a 59 48			ld a, (.dmark+1)  
484d 32 b5 fe			ld (debug_mark+1),a  
4850 3a 5a 48			ld a, (.dmark+2)  
4853 32 b6 fe			ld (debug_mark+2),a  
4856 18 03			jr .pastdmark  
4858 ..			.dmark: db "FN2"  
485b f1			.pastdmark: pop af  
485c			endm  
# End of macro DMARK
485c						CALLMONITOR 
485c cd c6 18			call break_point_state  
485f				endm  
# End of macro CALLMONITOR
485f					endif 
485f					 
485f 01 00 00				ld bc, 0 
4862 7e			.findchar:      ld a,(hl) 
4863 fe 00				cp 0   		 
4865 28 27				jr z, .finddone     
4867 ba					cp d 
4868 28 20				jr z, .foundchar 
486a 03					inc bc 
486b 23					inc hl 
486c					if DEBUG_FORTH_WORDS 
486c						DMARK "FN3" 
486c f5				push af  
486d 3a 81 48			ld a, (.dmark)  
4870 32 b4 fe			ld (debug_mark),a  
4873 3a 82 48			ld a, (.dmark+1)  
4876 32 b5 fe			ld (debug_mark+1),a  
4879 3a 83 48			ld a, (.dmark+2)  
487c 32 b6 fe			ld (debug_mark+2),a  
487f 18 03			jr .pastdmark  
4881 ..			.dmark: db "FN3"  
4884 f1			.pastdmark: pop af  
4885			endm  
# End of macro DMARK
4885						CALLMONITOR 
4885 cd c6 18			call break_point_state  
4888				endm  
# End of macro CALLMONITOR
4888					endif 
4888 18 d8				jr .findchar 
488a			 
488a			 
488a c5			.foundchar:	push bc 
488b e1					pop hl 
488c 18 03				jr .findexit 
488e			 
488e			 
488e							 
488e			 
488e			.finddone:     ; got to end of string with no find 
488e 21 00 00				ld hl, 0 
4891			.findexit: 
4891			 
4891					if DEBUG_FORTH_WORDS 
4891						DMARK "FNd" 
4891 f5				push af  
4892 3a a6 48			ld a, (.dmark)  
4895 32 b4 fe			ld (debug_mark),a  
4898 3a a7 48			ld a, (.dmark+1)  
489b 32 b5 fe			ld (debug_mark+1),a  
489e 3a a8 48			ld a, (.dmark+2)  
48a1 32 b6 fe			ld (debug_mark+2),a  
48a4 18 03			jr .pastdmark  
48a6 ..			.dmark: db "FNd"  
48a9 f1			.pastdmark: pop af  
48aa			endm  
# End of macro DMARK
48aa						CALLMONITOR 
48aa cd c6 18			call break_point_state  
48ad				endm  
# End of macro CALLMONITOR
48ad					endif 
48ad cd 3a 1f			call forth_push_numhl 
48b0			 
48b0				       NEXTW 
48b0 c3 e7 22			jp macro_next 
48b3				endm 
# End of macro NEXTW
48b3			 
48b3			.LEN: 
48b3				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
48b3 4c				db WORD_SYS_CORE+56             
48b4 1d 49			dw .ASC            
48b6 06				db 5 + 1 
48b7 .. 00			db "COUNT",0              
48bd				endm 
# End of macro CWHEAD
48bd			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
48bd			 
48bd					if DEBUG_FORTH_WORDS_KEY 
48bd						DMARK "CNT" 
48bd f5				push af  
48be 3a d2 48			ld a, (.dmark)  
48c1 32 b4 fe			ld (debug_mark),a  
48c4 3a d3 48			ld a, (.dmark+1)  
48c7 32 b5 fe			ld (debug_mark+1),a  
48ca 3a d4 48			ld a, (.dmark+2)  
48cd 32 b6 fe			ld (debug_mark+2),a  
48d0 18 03			jr .pastdmark  
48d2 ..			.dmark: db "CNT"  
48d5 f1			.pastdmark: pop af  
48d6			endm  
# End of macro DMARK
48d6						CALLMONITOR 
48d6 cd c6 18			call break_point_state  
48d9				endm  
# End of macro CALLMONITOR
48d9					endif 
48d9			; TODO check string type 
48d9					FORTH_DSP_VALUE 
48d9 cd 1a 21			call macro_forth_dsp_value 
48dc				endm 
# End of macro FORTH_DSP_VALUE
48dc			 
48dc			 
48dc					if DEBUG_FORTH_WORDS 
48dc						DMARK "CN?" 
48dc f5				push af  
48dd 3a f1 48			ld a, (.dmark)  
48e0 32 b4 fe			ld (debug_mark),a  
48e3 3a f2 48			ld a, (.dmark+1)  
48e6 32 b5 fe			ld (debug_mark+1),a  
48e9 3a f3 48			ld a, (.dmark+2)  
48ec 32 b6 fe			ld (debug_mark+2),a  
48ef 18 03			jr .pastdmark  
48f1 ..			.dmark: db "CN?"  
48f4 f1			.pastdmark: pop af  
48f5			endm  
# End of macro DMARK
48f5						CALLMONITOR 
48f5 cd c6 18			call break_point_state  
48f8				endm  
# End of macro CALLMONITOR
48f8					endif 
48f8 cd a7 13				call strlenz 
48fb					if DEBUG_FORTH_WORDS 
48fb						DMARK "CNl" 
48fb f5				push af  
48fc 3a 10 49			ld a, (.dmark)  
48ff 32 b4 fe			ld (debug_mark),a  
4902 3a 11 49			ld a, (.dmark+1)  
4905 32 b5 fe			ld (debug_mark+1),a  
4908 3a 12 49			ld a, (.dmark+2)  
490b 32 b6 fe			ld (debug_mark+2),a  
490e 18 03			jr .pastdmark  
4910 ..			.dmark: db "CNl"  
4913 f1			.pastdmark: pop af  
4914			endm  
# End of macro DMARK
4914						CALLMONITOR 
4914 cd c6 18			call break_point_state  
4917				endm  
# End of macro CALLMONITOR
4917					endif 
4917			 
4917 cd 3a 1f				call forth_push_numhl 
491a			 
491a			 
491a			 
491a				       NEXTW 
491a c3 e7 22			jp macro_next 
491d				endm 
# End of macro NEXTW
491d			.ASC: 
491d				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
491d 4d				db WORD_SYS_CORE+57             
491e 8b 49			dw .CHR            
4920 04				db 3 + 1 
4921 .. 00			db "ASC",0              
4925				endm 
# End of macro CWHEAD
4925			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4925					if DEBUG_FORTH_WORDS_KEY 
4925						DMARK "ASC" 
4925 f5				push af  
4926 3a 3a 49			ld a, (.dmark)  
4929 32 b4 fe			ld (debug_mark),a  
492c 3a 3b 49			ld a, (.dmark+1)  
492f 32 b5 fe			ld (debug_mark+1),a  
4932 3a 3c 49			ld a, (.dmark+2)  
4935 32 b6 fe			ld (debug_mark+2),a  
4938 18 03			jr .pastdmark  
493a ..			.dmark: db "ASC"  
493d f1			.pastdmark: pop af  
493e			endm  
# End of macro DMARK
493e						CALLMONITOR 
493e cd c6 18			call break_point_state  
4941				endm  
# End of macro CALLMONITOR
4941					endif 
4941					FORTH_DSP_VALUE 
4941 cd 1a 21			call macro_forth_dsp_value 
4944				endm 
# End of macro FORTH_DSP_VALUE
4944					;v5 FORTH_DSP_VALUE 
4944			;		inc hl      ; now at start of numeric as string 
4944			 
4944 e5					push hl 
4945			 
4945					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4945 cd e9 21			call macro_forth_dsp_pop 
4948				endm 
# End of macro FORTH_DSP_POP
4948			 
4948 e1					pop hl 
4949			 
4949					if DEBUG_FORTH_WORDS 
4949						DMARK "AS1" 
4949 f5				push af  
494a 3a 5e 49			ld a, (.dmark)  
494d 32 b4 fe			ld (debug_mark),a  
4950 3a 5f 49			ld a, (.dmark+1)  
4953 32 b5 fe			ld (debug_mark+1),a  
4956 3a 60 49			ld a, (.dmark+2)  
4959 32 b6 fe			ld (debug_mark+2),a  
495c 18 03			jr .pastdmark  
495e ..			.dmark: db "AS1"  
4961 f1			.pastdmark: pop af  
4962			endm  
# End of macro DMARK
4962						CALLMONITOR 
4962 cd c6 18			call break_point_state  
4965				endm  
# End of macro CALLMONITOR
4965					endif 
4965					; push the content of a onto the stack as a value 
4965			 
4965 7e					ld a,(hl)   ; get char 
4966 26 00				ld h,0 
4968 6f					ld l,a 
4969					if DEBUG_FORTH_WORDS 
4969						DMARK "AS2" 
4969 f5				push af  
496a 3a 7e 49			ld a, (.dmark)  
496d 32 b4 fe			ld (debug_mark),a  
4970 3a 7f 49			ld a, (.dmark+1)  
4973 32 b5 fe			ld (debug_mark+1),a  
4976 3a 80 49			ld a, (.dmark+2)  
4979 32 b6 fe			ld (debug_mark+2),a  
497c 18 03			jr .pastdmark  
497e ..			.dmark: db "AS2"  
4981 f1			.pastdmark: pop af  
4982			endm  
# End of macro DMARK
4982						CALLMONITOR 
4982 cd c6 18			call break_point_state  
4985				endm  
# End of macro CALLMONITOR
4985					endif 
4985 cd 3a 1f				call forth_push_numhl 
4988			 
4988				       NEXTW 
4988 c3 e7 22			jp macro_next 
498b				endm 
# End of macro NEXTW
498b			 
498b			.CHR: 
498b				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
498b 4d				db WORD_SYS_CORE+57             
498c c7 49			dw .ENDSTR            
498e 04				db 3 + 1 
498f .. 00			db "CHR",0              
4993				endm 
# End of macro CWHEAD
4993			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4993					if DEBUG_FORTH_WORDS_KEY 
4993						DMARK "CHR" 
4993 f5				push af  
4994 3a a8 49			ld a, (.dmark)  
4997 32 b4 fe			ld (debug_mark),a  
499a 3a a9 49			ld a, (.dmark+1)  
499d 32 b5 fe			ld (debug_mark+1),a  
49a0 3a aa 49			ld a, (.dmark+2)  
49a3 32 b6 fe			ld (debug_mark+2),a  
49a6 18 03			jr .pastdmark  
49a8 ..			.dmark: db "CHR"  
49ab f1			.pastdmark: pop af  
49ac			endm  
# End of macro DMARK
49ac						CALLMONITOR 
49ac cd c6 18			call break_point_state  
49af				endm  
# End of macro CALLMONITOR
49af					endif 
49af					FORTH_DSP_VALUEHL 
49af cd 31 21			call macro_dsp_valuehl 
49b2				endm 
# End of macro FORTH_DSP_VALUEHL
49b2			 
49b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49b2 cd e9 21			call macro_forth_dsp_pop 
49b5				endm 
# End of macro FORTH_DSP_POP
49b5			 
49b5					; save asci byte as a zero term string and push string 
49b5			 
49b5 7d					ld a,l 
49b6 32 4e f3				ld (scratch), a 
49b9			 
49b9 3e 00				ld a, 0 
49bb 32 4f f3				ld (scratch+1), a 
49be			 
49be 21 4e f3				ld hl, scratch 
49c1 cd a8 1f				call forth_push_str 
49c4			 
49c4			 
49c4				       NEXTW 
49c4 c3 e7 22			jp macro_next 
49c7				endm 
# End of macro NEXTW
49c7			 
49c7			 
49c7			 
49c7			 
49c7			.ENDSTR: 
49c7			; eof 
49c7			 
# End of file forth_words_str.asm
49c7			include "forth_words_key.asm" 
49c7			 
49c7			; | ## Keyboard Words 
49c7			 
49c7			.KEY: 
49c7				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
49c7 3e				db WORD_SYS_CORE+42             
49c8 f7 49			dw .WAITK            
49ca 04				db 3 + 1 
49cb .. 00			db "KEY",0              
49cf				endm 
# End of macro CWHEAD
49cf			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
49cf			 
49cf					if DEBUG_FORTH_WORDS_KEY 
49cf						DMARK "KEY" 
49cf f5				push af  
49d0 3a e4 49			ld a, (.dmark)  
49d3 32 b4 fe			ld (debug_mark),a  
49d6 3a e5 49			ld a, (.dmark+1)  
49d9 32 b5 fe			ld (debug_mark+1),a  
49dc 3a e6 49			ld a, (.dmark+2)  
49df 32 b6 fe			ld (debug_mark+2),a  
49e2 18 03			jr .pastdmark  
49e4 ..			.dmark: db "KEY"  
49e7 f1			.pastdmark: pop af  
49e8			endm  
# End of macro DMARK
49e8						CALLMONITOR 
49e8 cd c6 18			call break_point_state  
49eb				endm  
# End of macro CALLMONITOR
49eb					endif 
49eb			; TODO currently waits 
49eb cd 3a 73				call cin 
49ee					;call cin_wait 
49ee 6f					ld l, a 
49ef 26 00				ld h, 0 
49f1 cd 3a 1f				call forth_push_numhl 
49f4					NEXTW 
49f4 c3 e7 22			jp macro_next 
49f7				endm 
# End of macro NEXTW
49f7			.WAITK: 
49f7				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
49f7 3f				db WORD_SYS_CORE+43             
49f8 29 4a			dw .ACCEPT            
49fa 06				db 5 + 1 
49fb .. 00			db "WAITK",0              
4a01				endm 
# End of macro CWHEAD
4a01			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4a01					if DEBUG_FORTH_WORDS_KEY 
4a01						DMARK "WAI" 
4a01 f5				push af  
4a02 3a 16 4a			ld a, (.dmark)  
4a05 32 b4 fe			ld (debug_mark),a  
4a08 3a 17 4a			ld a, (.dmark+1)  
4a0b 32 b5 fe			ld (debug_mark+1),a  
4a0e 3a 18 4a			ld a, (.dmark+2)  
4a11 32 b6 fe			ld (debug_mark+2),a  
4a14 18 03			jr .pastdmark  
4a16 ..			.dmark: db "WAI"  
4a19 f1			.pastdmark: pop af  
4a1a			endm  
# End of macro DMARK
4a1a						CALLMONITOR 
4a1a cd c6 18			call break_point_state  
4a1d				endm  
# End of macro CALLMONITOR
4a1d					endif 
4a1d cd 29 73				call cin_wait 
4a20 6f					ld l, a 
4a21 26 00				ld h, 0 
4a23 cd 3a 1f				call forth_push_numhl 
4a26					NEXTW 
4a26 c3 e7 22			jp macro_next 
4a29				endm 
# End of macro NEXTW
4a29			.ACCEPT: 
4a29				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4a29 40				db WORD_SYS_CORE+44             
4a2a 87 4a			dw .EDIT            
4a2c 07				db 6 + 1 
4a2d .. 00			db "ACCEPT",0              
4a34				endm 
# End of macro CWHEAD
4a34			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4a34					; TODO crashes on push 
4a34					if DEBUG_FORTH_WORDS_KEY 
4a34						DMARK "ACC" 
4a34 f5				push af  
4a35 3a 49 4a			ld a, (.dmark)  
4a38 32 b4 fe			ld (debug_mark),a  
4a3b 3a 4a 4a			ld a, (.dmark+1)  
4a3e 32 b5 fe			ld (debug_mark+1),a  
4a41 3a 4b 4a			ld a, (.dmark+2)  
4a44 32 b6 fe			ld (debug_mark+2),a  
4a47 18 03			jr .pastdmark  
4a49 ..			.dmark: db "ACC"  
4a4c f1			.pastdmark: pop af  
4a4d			endm  
# End of macro DMARK
4a4d						CALLMONITOR 
4a4d cd c6 18			call break_point_state  
4a50				endm  
# End of macro CALLMONITOR
4a50					endif 
4a50 21 4c f5				ld hl, os_input 
4a53 3e 00				ld a, 0 
4a55 77					ld (hl),a 
4a56 3a eb fb				ld a,(f_cursor_ptr) 
4a59 16 64				ld d, 100 
4a5b 0e 00				ld c, 0 
4a5d 1e 28				ld e, 40 
4a5f cd 76 0f				call input_str 
4a62					; TODO perhaps do a type check and wrap in quotes if not a number 
4a62 21 4c f5				ld hl, os_input 
4a65					if DEBUG_FORTH_WORDS 
4a65						DMARK "AC1" 
4a65 f5				push af  
4a66 3a 7a 4a			ld a, (.dmark)  
4a69 32 b4 fe			ld (debug_mark),a  
4a6c 3a 7b 4a			ld a, (.dmark+1)  
4a6f 32 b5 fe			ld (debug_mark+1),a  
4a72 3a 7c 4a			ld a, (.dmark+2)  
4a75 32 b6 fe			ld (debug_mark+2),a  
4a78 18 03			jr .pastdmark  
4a7a ..			.dmark: db "AC1"  
4a7d f1			.pastdmark: pop af  
4a7e			endm  
# End of macro DMARK
4a7e						CALLMONITOR 
4a7e cd c6 18			call break_point_state  
4a81				endm  
# End of macro CALLMONITOR
4a81					endif 
4a81 cd a8 1f				call forth_push_str 
4a84					NEXTW 
4a84 c3 e7 22			jp macro_next 
4a87				endm 
# End of macro NEXTW
4a87			 
4a87			.EDIT: 
4a87				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4a87 40				db WORD_SYS_CORE+44             
4a88 29 4b			dw .ENDKEY            
4a8a 05				db 4 + 1 
4a8b .. 00			db "EDIT",0              
4a90				endm 
# End of macro CWHEAD
4a90			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4a90			 
4a90					; TODO does not copy from stack 
4a90					if DEBUG_FORTH_WORDS_KEY 
4a90						DMARK "EDT" 
4a90 f5				push af  
4a91 3a a5 4a			ld a, (.dmark)  
4a94 32 b4 fe			ld (debug_mark),a  
4a97 3a a6 4a			ld a, (.dmark+1)  
4a9a 32 b5 fe			ld (debug_mark+1),a  
4a9d 3a a7 4a			ld a, (.dmark+2)  
4aa0 32 b6 fe			ld (debug_mark+2),a  
4aa3 18 03			jr .pastdmark  
4aa5 ..			.dmark: db "EDT"  
4aa8 f1			.pastdmark: pop af  
4aa9			endm  
# End of macro DMARK
4aa9						CALLMONITOR 
4aa9 cd c6 18			call break_point_state  
4aac				endm  
# End of macro CALLMONITOR
4aac					endif 
4aac			 
4aac					;FORTH_DSP 
4aac					FORTH_DSP_VALUEHL 
4aac cd 31 21			call macro_dsp_valuehl 
4aaf				endm 
# End of macro FORTH_DSP_VALUEHL
4aaf			;		inc hl    ; TODO do type check 
4aaf			 
4aaf			;		call get_word_hl 
4aaf e5					push hl 
4ab0					if DEBUG_FORTH_WORDS 
4ab0						DMARK "EDp" 
4ab0 f5				push af  
4ab1 3a c5 4a			ld a, (.dmark)  
4ab4 32 b4 fe			ld (debug_mark),a  
4ab7 3a c6 4a			ld a, (.dmark+1)  
4aba 32 b5 fe			ld (debug_mark+1),a  
4abd 3a c7 4a			ld a, (.dmark+2)  
4ac0 32 b6 fe			ld (debug_mark+2),a  
4ac3 18 03			jr .pastdmark  
4ac5 ..			.dmark: db "EDp"  
4ac8 f1			.pastdmark: pop af  
4ac9			endm  
# End of macro DMARK
4ac9						CALLMONITOR 
4ac9 cd c6 18			call break_point_state  
4acc				endm  
# End of macro CALLMONITOR
4acc					endif 
4acc				;	ld a, 0 
4acc cd a7 13				call strlenz 
4acf 23					inc hl 
4ad0			 
4ad0 06 00				ld b, 0 
4ad2 4d					ld c, l 
4ad3			 
4ad3 e1					pop hl 
4ad4 11 4c f5				ld de, os_input 
4ad7					if DEBUG_FORTH_WORDS_KEY 
4ad7						DMARK "EDc" 
4ad7 f5				push af  
4ad8 3a ec 4a			ld a, (.dmark)  
4adb 32 b4 fe			ld (debug_mark),a  
4ade 3a ed 4a			ld a, (.dmark+1)  
4ae1 32 b5 fe			ld (debug_mark+1),a  
4ae4 3a ee 4a			ld a, (.dmark+2)  
4ae7 32 b6 fe			ld (debug_mark+2),a  
4aea 18 03			jr .pastdmark  
4aec ..			.dmark: db "EDc"  
4aef f1			.pastdmark: pop af  
4af0			endm  
# End of macro DMARK
4af0						CALLMONITOR 
4af0 cd c6 18			call break_point_state  
4af3				endm  
# End of macro CALLMONITOR
4af3					endif 
4af3 ed b0				ldir 
4af5			 
4af5			 
4af5 21 4c f5				ld hl, os_input 
4af8					;ld a, 0 
4af8					;ld (hl),a 
4af8 3a eb fb				ld a,(f_cursor_ptr) 
4afb 16 64				ld d, 100 
4afd 0e 00				ld c, 0 
4aff 1e 28				ld e, 40 
4b01 cd 76 0f				call input_str 
4b04					; TODO perhaps do a type check and wrap in quotes if not a number 
4b04 21 4c f5				ld hl, os_input 
4b07					if DEBUG_FORTH_WORDS 
4b07						DMARK "ED1" 
4b07 f5				push af  
4b08 3a 1c 4b			ld a, (.dmark)  
4b0b 32 b4 fe			ld (debug_mark),a  
4b0e 3a 1d 4b			ld a, (.dmark+1)  
4b11 32 b5 fe			ld (debug_mark+1),a  
4b14 3a 1e 4b			ld a, (.dmark+2)  
4b17 32 b6 fe			ld (debug_mark+2),a  
4b1a 18 03			jr .pastdmark  
4b1c ..			.dmark: db "ED1"  
4b1f f1			.pastdmark: pop af  
4b20			endm  
# End of macro DMARK
4b20						CALLMONITOR 
4b20 cd c6 18			call break_point_state  
4b23				endm  
# End of macro CALLMONITOR
4b23					endif 
4b23 cd a8 1f				call forth_push_str 
4b26					NEXTW 
4b26 c3 e7 22			jp macro_next 
4b29				endm 
# End of macro NEXTW
4b29			 
4b29			 
4b29			 
4b29			.ENDKEY: 
4b29			; eof 
4b29			 
# End of file forth_words_key.asm
4b29			include "forth_words_const.asm" 
4b29			 
4b29			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4b29			 
4b29			 
4b29			.SPITIME: 
4b29				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4b29 77				db WORD_SYS_CORE+99             
4b2a 3e 4b			dw .VA            
4b2c 08				db 7 + 1 
4b2d .. 00			db "SPITIME",0              
4b35				endm 
# End of macro CWHEAD
4b35			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4b35			; 
4b35			; | If using BANK devices then leave as is. 
4b35			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4b35			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4b35			 
4b35 21 f1 fb				ld hl, spi_clktime  
4b38 cd 3a 1f				call forth_push_numhl 
4b3b			 
4b3b					NEXTW 
4b3b c3 e7 22			jp macro_next 
4b3e				endm 
# End of macro NEXTW
4b3e			 
4b3e			 
4b3e			.VA: 
4b3e				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4b3e 77				db WORD_SYS_CORE+99             
4b3f 4e 4b			dw .SYMBOL            
4b41 03				db 2 + 1 
4b42 .. 00			db "VA",0              
4b45				endm 
# End of macro CWHEAD
4b45			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4b45 21 b5 fb				ld hl, cli_var_array 
4b48 cd 3a 1f				call forth_push_numhl 
4b4b			 
4b4b					NEXTW 
4b4b c3 e7 22			jp macro_next 
4b4e				endm 
# End of macro NEXTW
4b4e			 
4b4e			.SYMBOL: 
4b4e				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4b4e 77				db WORD_SYS_CORE+99             
4b4f 86 4c			dw .ENDCONST            
4b51 07				db 6 + 1 
4b52 .. 00			db "SYMBOL",0              
4b59				endm 
# End of macro CWHEAD
4b59			;| SYMBOL ( u1 -- )  Get the address of a system sysmbol from a look up table to TOS  | TO TEST 
4b59			;| 
4b59			;| The value is the number reference and the final address is pushed to stack 
4b59			 
4b59					if DEBUG_FORTH_WORDS_KEY 
4b59						DMARK "SYM" 
4b59 f5				push af  
4b5a 3a 6e 4b			ld a, (.dmark)  
4b5d 32 b4 fe			ld (debug_mark),a  
4b60 3a 6f 4b			ld a, (.dmark+1)  
4b63 32 b5 fe			ld (debug_mark+1),a  
4b66 3a 70 4b			ld a, (.dmark+2)  
4b69 32 b6 fe			ld (debug_mark+2),a  
4b6c 18 03			jr .pastdmark  
4b6e ..			.dmark: db "SYM"  
4b71 f1			.pastdmark: pop af  
4b72			endm  
# End of macro DMARK
4b72						CALLMONITOR 
4b72 cd c6 18			call break_point_state  
4b75				endm  
# End of macro CALLMONITOR
4b75					endif 
4b75			 
4b75					FORTH_DSP_VALUEHL 
4b75 cd 31 21			call macro_dsp_valuehl 
4b78				endm 
# End of macro FORTH_DSP_VALUEHL
4b78			 
4b78 7d					ld a, l     
4b79			 
4b79			 
4b79					if DEBUG_FORTH_WORDS 
4b79						DMARK "SY1" 
4b79 f5				push af  
4b7a 3a 8e 4b			ld a, (.dmark)  
4b7d 32 b4 fe			ld (debug_mark),a  
4b80 3a 8f 4b			ld a, (.dmark+1)  
4b83 32 b5 fe			ld (debug_mark+1),a  
4b86 3a 90 4b			ld a, (.dmark+2)  
4b89 32 b6 fe			ld (debug_mark+2),a  
4b8c 18 03			jr .pastdmark  
4b8e ..			.dmark: db "SY1"  
4b91 f1			.pastdmark: pop af  
4b92			endm  
# End of macro DMARK
4b92						CALLMONITOR 
4b92 cd c6 18			call break_point_state  
4b95				endm  
# End of macro CALLMONITOR
4b95					endif 
4b95					 
4b95 f5					push af	 
4b96					FORTH_DSP_POP 
4b96 cd e9 21			call macro_forth_dsp_pop 
4b99				endm 
# End of macro FORTH_DSP_POP
4b99 f1					pop af 
4b9a			 
4b9a cb 27				sla a  
4b9c				 
4b9c					 
4b9c					if DEBUG_FORTH_WORDS 
4b9c						DMARK "SY" 
4b9c f5				push af  
4b9d 3a b1 4b			ld a, (.dmark)  
4ba0 32 b4 fe			ld (debug_mark),a  
4ba3 3a b2 4b			ld a, (.dmark+1)  
4ba6 32 b5 fe			ld (debug_mark+1),a  
4ba9 3a b3 4b			ld a, (.dmark+2)  
4bac 32 b6 fe			ld (debug_mark+2),a  
4baf 18 02			jr .pastdmark  
4bb1 ..			.dmark: db "SY"  
4bb3 f1			.pastdmark: pop af  
4bb4			endm  
# End of macro DMARK
4bb4						CALLMONITOR 
4bb4 cd c6 18			call break_point_state  
4bb7				endm  
# End of macro CALLMONITOR
4bb7					endif 
4bb7			 
4bb7 21 c6 4b				ld hl, sym_table 
4bba cd 49 0f				call addatohl 
4bbd cd 69 22				call loadwordinhl 
4bc0 cd 3a 1f				call forth_push_numhl 
4bc3			 
4bc3			 
4bc3				       NEXTW 
4bc3 c3 e7 22			jp macro_next 
4bc6				endm 
# End of macro NEXTW
4bc6			 
4bc6			sym_table: 
4bc6			 
4bc6			; 0 
4bc6 c9 fb		dw cli_autodisplay 
4bc8 d7 fb		dw cli_buffer 
4bca 7b fb		dw cli_data_sp 
4bcc b5 f8		dw cli_data_stack 
4bce d1 fb		dw cli_execword 
4bd0 7d fb		dw cli_loop_sp 
4bd2 b7 fa		dw cli_loop_stack 
4bd4 ca fb		dw cli_mvdot 
4bd6 cf fb		dw cli_nextword 
4bd8 cb fb		dw cli_origptr 
4bda d5 fb		dw cli_origtoken 
4bdc			; 11 
4bdc cd fb		dw cli_ptr 
4bde 7f fb		dw cli_ret_sp 
4be0 39 fb		dw cli_ret_stack 
4be2 d3 fb		dw cli_token 
4be4 b5 fb		dw cli_var_array 
4be6 51 fd		dw cursor_col 
4be8 4f fd		dw cursor_ptr 
4bea 50 fd		dw cursor_row 
4bec 4d fd		dw cursor_shape 
4bee b4 fe		dw debug_mark 
4bf0			; 21 
4bf0 4a fe		dw display_fb0 
4bf2 f9 fd		dw display_fb1 
4bf4 57 fd		dw display_fb2 
4bf6 a8 fd		dw display_fb3 
4bf8 55 fd		dw display_fb_active 
4bfa 4d f4		dw execscratch 
4bfc eb fb		dw f_cursor_ptr 
4bfe b8 fe		dw hardware_word 
4c00 ab fe		dw input_at_cursor 
4c02 ad fe		dw input_at_pos 
4c04			; 31 
4c04 a9 fe		dw input_cur_flash 
4c06 a8 fe		dw input_cur_onoff 
4c08 9e fe		dw input_cursor 
4c0a ae fe		dw input_display_size 
4c0c a3 fe		dw input_len 
4c0e b2 fe		dw input_ptr 
4c10 af fe		dw input_size 
4c12 b0 fe		dw input_start 
4c14 76 0f		dw input_str 
4c16 ac fe		dw input_under_cursor 
4c18			; 41 
4c18 9d fe		dw key_actual_pressed 
4c1a c8 fe		dw key_fa 
4c1c c4 fe		dw key_face_held 
4c1e c7 fe		dw key_fb 
4c20 c6 fe		dw key_fc 
4c22 c5 fe		dw key_fd 
4c24 ce fe		dw key_held 
4c26 cd fe		dw key_held_prev 
4c28 af 72		dw key_init 
4c2a c9 fe		dw key_repeat_ct 
4c2c			; 51 
4c2c 04 00		dw key_rows 
4c2e 9b fe		dw key_shift 
4c30 9c fe		dw key_symbol 
4c32 cf fe		dw keyscan_scancol 
4c34 d3 fe		dw keyscan_table 
4c36 f8 fe		dw keyscan_table_row1 
4c38 f3 fe		dw keyscan_table_row2 
4c3a ee fe		dw keyscan_table_row3 
4c3c e9 fe		dw keyscan_table_row4 
4c3e e4 fe		dw keyscan_table_row5 
4c40			; 61 
4c40 75 f6		dw os_cli_cmd 
4c42 71 f6		dw os_cur_ptr 
4c44 73 f6		dw os_current_i 
4c46 4c f5		dw os_input 
4c48 74 f7		dw os_last_cmd 
4c4a 4b f6		dw os_last_new_uword 
4c4c 3f f3		dw os_view_disable 
4c4e 3b f3		dw os_view_hl 
4c50 53 f6		dw os_word_scratch 
4c52 c3 00		dw portbctl 
4c54			; 71 
4c54 c1 00		dw portbdata 
4c56 f0 fb		dw spi_cartdev 
4c58 ef fb		dw spi_cartdev2 
4c5a f1 fb		dw spi_clktime 
4c5c ed fb		dw spi_device 
4c5e ec fb		dw spi_device_id 
4c60 ee fb		dw spi_portbyte 
4c62 33 fd		dw stackstore 
4c64			if STORAGE_SE 
4c64 82 00		dw storage_actl 
4c66 80 00		dw storage_adata 
4c68			else 
4c68			dw 0 
4c68			dw 0 
4c68			endif 
4c68			; 81 
4c68 09 0b		dw storage_append 
4c6a			if STORAGE_SE 
4c6a 83 00		dw storage_bctl 
4c6c			else 
4c6c			dw 0 
4c6c			endif 
4c6c 1f fd		dw store_bank_active 
4c6e f4 fb		dw store_filecache 
4c70 02 fc		dw store_longread 
4c72 f8 fb		dw store_openaddr 
4c74 f7 fb		dw store_openext 
4c76 f6 fb		dw store_openmaxext 
4c78 07 fc		dw store_page 
4c7a 03 fc		dw store_readbuf 
4c7c			; 91 
4c7c fa fb		dw store_readcont 
4c7e 05 fc		dw store_readptr 
4c80 fa fb		dw store_tmpext 
4c82 fb fb		dw store_tmpid 
4c84 f2 fb		dw store_tmppageid 
4c86			 
4c86			 
4c86			.ENDCONST: 
4c86			 
4c86			; eof 
4c86			 
4c86			 
# End of file forth_words_const.asm
4c86			 
4c86			if STORAGE_SE 
4c86			   	include "forth_words_storage.asm" 
4c86			 
4c86			; | ## Fixed Storage Words 
4c86			 
4c86			.RECORD: 
4c86			  
4c86				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4c86 3a				db WORD_SYS_CORE+38             
4c87 2a 4d			dw .BREAD            
4c89 07				db 6 + 1 
4c8a .. 00			db "RECORD",0              
4c91				endm 
# End of macro CWHEAD
4c91			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4c91			; | | Compatible with PicoSPINet  
4c91			 
4c91					if DEBUG_FORTH_WORDS_KEY 
4c91						DMARK "REC" 
4c91 f5				push af  
4c92 3a a6 4c			ld a, (.dmark)  
4c95 32 b4 fe			ld (debug_mark),a  
4c98 3a a7 4c			ld a, (.dmark+1)  
4c9b 32 b5 fe			ld (debug_mark+1),a  
4c9e 3a a8 4c			ld a, (.dmark+2)  
4ca1 32 b6 fe			ld (debug_mark+2),a  
4ca4 18 03			jr .pastdmark  
4ca6 ..			.dmark: db "REC"  
4ca9 f1			.pastdmark: pop af  
4caa			endm  
# End of macro DMARK
4caa						CALLMONITOR 
4caa cd c6 18			call break_point_state  
4cad				endm  
# End of macro CALLMONITOR
4cad					endif 
4cad			 
4cad					FORTH_DSP_VALUEHL 
4cad cd 31 21			call macro_dsp_valuehl 
4cb0				endm 
# End of macro FORTH_DSP_VALUEHL
4cb0			 
4cb0 e5					push hl    ; id 
4cb1			 
4cb1					FORTH_DSP_POP 
4cb1 cd e9 21			call macro_forth_dsp_pop 
4cb4				endm 
# End of macro FORTH_DSP_POP
4cb4			 
4cb4					FORTH_DSP_VALUEHL 
4cb4 cd 31 21			call macro_dsp_valuehl 
4cb7				endm 
# End of macro FORTH_DSP_VALUEHL
4cb7			 
4cb7					FORTH_DSP_POP 
4cb7 cd e9 21			call macro_forth_dsp_pop 
4cba				endm 
# End of macro FORTH_DSP_POP
4cba			 
4cba d1					pop de     ; get file id 
4cbb			 
4cbb					; e = file id 
4cbb					; l = file extent 
4cbb			 
4cbb			 
4cbb					; construct request to access file extent 
4cbb			 
4cbb			;		ld a, e 
4cbb 63					ld h, e 
4cbc					 
4cbc					 
4cbc					 
4cbc			 
4cbc					; e has id 
4cbc			 
4cbc 11 07 fc			ld de, store_page 
4cbf					if DEBUG_FORTH_WORDS 
4cbf						DMARK "REr" 
4cbf f5				push af  
4cc0 3a d4 4c			ld a, (.dmark)  
4cc3 32 b4 fe			ld (debug_mark),a  
4cc6 3a d5 4c			ld a, (.dmark+1)  
4cc9 32 b5 fe			ld (debug_mark+1),a  
4ccc 3a d6 4c			ld a, (.dmark+2)  
4ccf 32 b6 fe			ld (debug_mark+2),a  
4cd2 18 03			jr .pastdmark  
4cd4 ..			.dmark: db "REr"  
4cd7 f1			.pastdmark: pop af  
4cd8			endm  
# End of macro DMARK
4cd8						CALLMONITOR 
4cd8 cd c6 18			call break_point_state  
4cdb				endm  
# End of macro CALLMONITOR
4cdb					endif 
4cdb cd 72 09				call storage_read 
4cde cd 72 0f			call ishlzero 
4ce1 28 22			jr z, .recnotfound 
4ce3			 
4ce3			 
4ce3					if DEBUG_FORTH_WORDS 
4ce3						DMARK "REe" 
4ce3 f5				push af  
4ce4 3a f8 4c			ld a, (.dmark)  
4ce7 32 b4 fe			ld (debug_mark),a  
4cea 3a f9 4c			ld a, (.dmark+1)  
4ced 32 b5 fe			ld (debug_mark+1),a  
4cf0 3a fa 4c			ld a, (.dmark+2)  
4cf3 32 b6 fe			ld (debug_mark+2),a  
4cf6 18 03			jr .pastdmark  
4cf8 ..			.dmark: db "REe"  
4cfb f1			.pastdmark: pop af  
4cfc			endm  
# End of macro DMARK
4cfc						CALLMONITOR 
4cfc cd c6 18			call break_point_state  
4cff				endm  
# End of macro CALLMONITOR
4cff					endif 
4cff cd a8 1f			call forth_push_str 
4d02			 
4d02					NEXTW 
4d02 c3 e7 22			jp macro_next 
4d05				endm 
# End of macro NEXTW
4d05			 
4d05			.recnotfound: 
4d05					if DEBUG_FORTH_WORDS 
4d05						DMARK "REf" 
4d05 f5				push af  
4d06 3a 1a 4d			ld a, (.dmark)  
4d09 32 b4 fe			ld (debug_mark),a  
4d0c 3a 1b 4d			ld a, (.dmark+1)  
4d0f 32 b5 fe			ld (debug_mark+1),a  
4d12 3a 1c 4d			ld a, (.dmark+2)  
4d15 32 b6 fe			ld (debug_mark+2),a  
4d18 18 03			jr .pastdmark  
4d1a ..			.dmark: db "REf"  
4d1d f1			.pastdmark: pop af  
4d1e			endm  
# End of macro DMARK
4d1e						CALLMONITOR 
4d1e cd c6 18			call break_point_state  
4d21				endm  
# End of macro CALLMONITOR
4d21					endif 
4d21 21 ff 00			ld hl, 255 
4d24 cd 3a 1f			call forth_push_numhl 
4d27				NEXTW 
4d27 c3 e7 22			jp macro_next 
4d2a				endm 
# End of macro NEXTW
4d2a			 
4d2a			 
4d2a			.BREAD: 
4d2a			  
4d2a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4d2a 3a				db WORD_SYS_CORE+38             
4d2b ad 4d			dw .BWRITE            
4d2d 06				db 5 + 1 
4d2e .. 00			db "BREAD",0              
4d34				endm 
# End of macro CWHEAD
4d34			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4d34			; | | Compatible with PicoSPINet  
4d34				 
4d34					if DEBUG_FORTH_WORDS_KEY 
4d34						DMARK "BRD" 
4d34 f5				push af  
4d35 3a 49 4d			ld a, (.dmark)  
4d38 32 b4 fe			ld (debug_mark),a  
4d3b 3a 4a 4d			ld a, (.dmark+1)  
4d3e 32 b5 fe			ld (debug_mark+1),a  
4d41 3a 4b 4d			ld a, (.dmark+2)  
4d44 32 b6 fe			ld (debug_mark+2),a  
4d47 18 03			jr .pastdmark  
4d49 ..			.dmark: db "BRD"  
4d4c f1			.pastdmark: pop af  
4d4d			endm  
# End of macro DMARK
4d4d						CALLMONITOR 
4d4d cd c6 18			call break_point_state  
4d50				endm  
# End of macro CALLMONITOR
4d50					endif 
4d50			 
4d50				FORTH_DSP_VALUEHL 
4d50 cd 31 21			call macro_dsp_valuehl 
4d53				endm 
# End of macro FORTH_DSP_VALUEHL
4d53			 
4d53				FORTH_DSP_POP 
4d53 cd e9 21			call macro_forth_dsp_pop 
4d56				endm 
# End of macro FORTH_DSP_POP
4d56			 
4d56				; calc block address 
4d56			 
4d56 eb				ex de, hl 
4d57 3e 40			ld a, STORE_BLOCK_PHY 
4d59 cd cc 0e			call Mult16 
4d5c			 
4d5c			 
4d5c 11 07 fc			ld de, store_page 
4d5f			 
4d5f					if DEBUG_FORTH_WORDS 
4d5f						DMARK "BR1" 
4d5f f5				push af  
4d60 3a 74 4d			ld a, (.dmark)  
4d63 32 b4 fe			ld (debug_mark),a  
4d66 3a 75 4d			ld a, (.dmark+1)  
4d69 32 b5 fe			ld (debug_mark+1),a  
4d6c 3a 76 4d			ld a, (.dmark+2)  
4d6f 32 b6 fe			ld (debug_mark+2),a  
4d72 18 03			jr .pastdmark  
4d74 ..			.dmark: db "BR1"  
4d77 f1			.pastdmark: pop af  
4d78			endm  
# End of macro DMARK
4d78						CALLMONITOR 
4d78 cd c6 18			call break_point_state  
4d7b				endm  
# End of macro CALLMONITOR
4d7b					endif 
4d7b			 
4d7b cd 19 04			call storage_read_block 
4d7e			 
4d7e cd 72 0f			call ishlzero 
4d81 20 05			jr nz, .brfound 
4d83			 
4d83 cd 3a 1f			call forth_push_numhl 
4d86 18 22			jr .brdone 
4d88			 
4d88			 
4d88			.brfound: 
4d88 21 09 fc		        ld hl, store_page+2 
4d8b			 
4d8b					if DEBUG_FORTH_WORDS 
4d8b						DMARK "BR2" 
4d8b f5				push af  
4d8c 3a a0 4d			ld a, (.dmark)  
4d8f 32 b4 fe			ld (debug_mark),a  
4d92 3a a1 4d			ld a, (.dmark+1)  
4d95 32 b5 fe			ld (debug_mark+1),a  
4d98 3a a2 4d			ld a, (.dmark+2)  
4d9b 32 b6 fe			ld (debug_mark+2),a  
4d9e 18 03			jr .pastdmark  
4da0 ..			.dmark: db "BR2"  
4da3 f1			.pastdmark: pop af  
4da4			endm  
# End of macro DMARK
4da4						CALLMONITOR 
4da4 cd c6 18			call break_point_state  
4da7				endm  
# End of macro CALLMONITOR
4da7					endif 
4da7			 
4da7 cd a8 1f			call forth_push_str 
4daa			 
4daa			 
4daa			.brdone: 
4daa			 
4daa					NEXTW 
4daa c3 e7 22			jp macro_next 
4dad				endm 
# End of macro NEXTW
4dad			.BWRITE: 
4dad				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4dad 3a				db WORD_SYS_CORE+38             
4dae 42 4e			dw .BUPD            
4db0 07				db 6 + 1 
4db1 .. 00			db "BWRITE",0              
4db8				endm 
# End of macro CWHEAD
4db8			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4db8			; | | Compatible with PicoSPINet  
4db8			 
4db8					if DEBUG_FORTH_WORDS_KEY 
4db8						DMARK "BWR" 
4db8 f5				push af  
4db9 3a cd 4d			ld a, (.dmark)  
4dbc 32 b4 fe			ld (debug_mark),a  
4dbf 3a ce 4d			ld a, (.dmark+1)  
4dc2 32 b5 fe			ld (debug_mark+1),a  
4dc5 3a cf 4d			ld a, (.dmark+2)  
4dc8 32 b6 fe			ld (debug_mark+2),a  
4dcb 18 03			jr .pastdmark  
4dcd ..			.dmark: db "BWR"  
4dd0 f1			.pastdmark: pop af  
4dd1			endm  
# End of macro DMARK
4dd1						CALLMONITOR 
4dd1 cd c6 18			call break_point_state  
4dd4				endm  
# End of macro CALLMONITOR
4dd4					endif 
4dd4			 
4dd4				FORTH_DSP_VALUEHL 
4dd4 cd 31 21			call macro_dsp_valuehl 
4dd7				endm 
# End of macro FORTH_DSP_VALUEHL
4dd7			 
4dd7				; calc block address 
4dd7			 
4dd7 eb				ex de, hl 
4dd8 3e 40			ld a, STORE_BLOCK_PHY 
4dda cd cc 0e			call Mult16 
4ddd			 
4ddd e5				push hl         ; address 
4dde			 
4dde				FORTH_DSP_POP 
4dde cd e9 21			call macro_forth_dsp_pop 
4de1				endm 
# End of macro FORTH_DSP_POP
4de1			 
4de1				FORTH_DSP_VALUEHL 
4de1 cd 31 21			call macro_dsp_valuehl 
4de4				endm 
# End of macro FORTH_DSP_VALUEHL
4de4			 
4de4				FORTH_DSP_POP 
4de4 cd e9 21			call macro_forth_dsp_pop 
4de7				endm 
# End of macro FORTH_DSP_POP
4de7			 
4de7 cd 55 0c			call storage_clear_page 
4dea			 
4dea				; copy string to store page 
4dea			 
4dea e5				push hl     ; save string address 
4deb			 
4deb 3e 00			ld a, 0 
4ded cd b2 13			call strlent 
4df0			 
4df0 23				inc hl 
4df1			 
4df1 4d				ld c, l 
4df2 06 00			ld b, 0 
4df4			 
4df4 e1				pop hl 
4df5 11 09 fc			ld de, store_page + 2 
4df8					if DEBUG_FORTH_WORDS 
4df8						DMARK "BW1" 
4df8 f5				push af  
4df9 3a 0d 4e			ld a, (.dmark)  
4dfc 32 b4 fe			ld (debug_mark),a  
4dff 3a 0e 4e			ld a, (.dmark+1)  
4e02 32 b5 fe			ld (debug_mark+1),a  
4e05 3a 0f 4e			ld a, (.dmark+2)  
4e08 32 b6 fe			ld (debug_mark+2),a  
4e0b 18 03			jr .pastdmark  
4e0d ..			.dmark: db "BW1"  
4e10 f1			.pastdmark: pop af  
4e11			endm  
# End of macro DMARK
4e11						CALLMONITOR 
4e11 cd c6 18			call break_point_state  
4e14				endm  
# End of macro CALLMONITOR
4e14					endif 
4e14 ed b0			ldir 
4e16			 
4e16			 
4e16				; poke the start of the block with flags to prevent high level file ops hitting the block 
4e16			 
4e16 21 ff ff			ld hl, $ffff 
4e19			 
4e19 22 07 fc			ld (store_page), hl	 
4e1c				 
4e1c e1				pop hl    ; get address 
4e1d 11 07 fc			ld de, store_page 
4e20			 
4e20					if DEBUG_FORTH_WORDS 
4e20						DMARK "BW2" 
4e20 f5				push af  
4e21 3a 35 4e			ld a, (.dmark)  
4e24 32 b4 fe			ld (debug_mark),a  
4e27 3a 36 4e			ld a, (.dmark+1)  
4e2a 32 b5 fe			ld (debug_mark+1),a  
4e2d 3a 37 4e			ld a, (.dmark+2)  
4e30 32 b6 fe			ld (debug_mark+2),a  
4e33 18 03			jr .pastdmark  
4e35 ..			.dmark: db "BW2"  
4e38 f1			.pastdmark: pop af  
4e39			endm  
# End of macro DMARK
4e39						CALLMONITOR 
4e39 cd c6 18			call break_point_state  
4e3c				endm  
# End of macro CALLMONITOR
4e3c					endif 
4e3c			 
4e3c cd 7e 04			call storage_write_block 
4e3f			 
4e3f					NEXTW 
4e3f c3 e7 22			jp macro_next 
4e42				endm 
# End of macro NEXTW
4e42			 
4e42			.BUPD: 
4e42				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4e42 3a				db WORD_SYS_CORE+38             
4e43 98 4e			dw .BYID            
4e45 05				db 4 + 1 
4e46 .. 00			db "BUPD",0              
4e4b				endm 
# End of macro CWHEAD
4e4b			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4e4b			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4e4b			; | | or completely different file system structure. 
4e4b			; | | Compatible with PicoSPINet  
4e4b			 
4e4b					if DEBUG_FORTH_WORDS_KEY 
4e4b						DMARK "BUD" 
4e4b f5				push af  
4e4c 3a 60 4e			ld a, (.dmark)  
4e4f 32 b4 fe			ld (debug_mark),a  
4e52 3a 61 4e			ld a, (.dmark+1)  
4e55 32 b5 fe			ld (debug_mark+1),a  
4e58 3a 62 4e			ld a, (.dmark+2)  
4e5b 32 b6 fe			ld (debug_mark+2),a  
4e5e 18 03			jr .pastdmark  
4e60 ..			.dmark: db "BUD"  
4e63 f1			.pastdmark: pop af  
4e64			endm  
# End of macro DMARK
4e64						CALLMONITOR 
4e64 cd c6 18			call break_point_state  
4e67				endm  
# End of macro CALLMONITOR
4e67					endif 
4e67			 
4e67				FORTH_DSP_VALUEHL 
4e67 cd 31 21			call macro_dsp_valuehl 
4e6a				endm 
# End of macro FORTH_DSP_VALUEHL
4e6a			 
4e6a				; calc block address 
4e6a			 
4e6a eb				ex de, hl 
4e6b 3e 40			ld a, STORE_BLOCK_PHY 
4e6d cd cc 0e			call Mult16 
4e70			 
4e70				FORTH_DSP_POP 
4e70 cd e9 21			call macro_forth_dsp_pop 
4e73				endm 
# End of macro FORTH_DSP_POP
4e73			 
4e73			 
4e73 11 07 fc			ld de, store_page 
4e76			 
4e76					if DEBUG_FORTH_WORDS 
4e76						DMARK "BUe" 
4e76 f5				push af  
4e77 3a 8b 4e			ld a, (.dmark)  
4e7a 32 b4 fe			ld (debug_mark),a  
4e7d 3a 8c 4e			ld a, (.dmark+1)  
4e80 32 b5 fe			ld (debug_mark+1),a  
4e83 3a 8d 4e			ld a, (.dmark+2)  
4e86 32 b6 fe			ld (debug_mark+2),a  
4e89 18 03			jr .pastdmark  
4e8b ..			.dmark: db "BUe"  
4e8e f1			.pastdmark: pop af  
4e8f			endm  
# End of macro DMARK
4e8f						CALLMONITOR 
4e8f cd c6 18			call break_point_state  
4e92				endm  
# End of macro CALLMONITOR
4e92					endif 
4e92			 
4e92 cd 7e 04			call storage_write_block 
4e95			 
4e95					NEXTW 
4e95 c3 e7 22			jp macro_next 
4e98				endm 
# End of macro NEXTW
4e98			 
4e98			.BYID: 
4e98			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4e98			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4e98			; 
4e98			;		 
4e98			;		if DEBUG_FORTH_WORDS_KEY 
4e98			;			DMARK "BYID" 
4e98			;			CALLMONITOR 
4e98			;		endif 
4e98			; 
4e98			;		; get direct address 
4e98			; 
4e98			;		FORTH_DSP_VALUEHL 
4e98			; 
4e98			;		FORTH_DSP_POP 
4e98			; 
4e98			;	; calc block address 
4e98			; 
4e98			;	ex de, hl 
4e98			;	ld a, STORE_BLOCK_PHY 
4e98			;	call Mult16 
4e98			;	;	do BREAD with number as param 
4e98			;	; push the file name	 
4e98			;	ld de, store_page 
4e98			;	call storage_read_block 
4e98			 ;       ld hl, store_page+2 
4e98			; 
4e98			; 
4e98			;		NEXTW 
4e98			;.BYNAME: 
4e98				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4e98 3a				db WORD_SYS_CORE+38             
4e99 b1 4e			dw .DIR            
4e9b 06				db 5 + 1 
4e9c .. 00			db "GETID",0              
4ea2				endm 
# End of macro CWHEAD
4ea2			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4ea2			; | | Compatible with PicoSPINet  
4ea2			 
4ea2					; get pointer to file name to seek 
4ea2			 
4ea2					FORTH_DSP_VALUEHL 
4ea2 cd 31 21			call macro_dsp_valuehl 
4ea5				endm 
# End of macro FORTH_DSP_VALUEHL
4ea5			 
4ea5			 
4ea5 cd 40 03				call storage_getid  
4ea8			 
4ea8					FORTH_DSP_POP 
4ea8 cd e9 21			call macro_forth_dsp_pop 
4eab				endm 
# End of macro FORTH_DSP_POP
4eab			 
4eab cd 3a 1f				call forth_push_numhl 
4eae			 
4eae					NEXTW 
4eae c3 e7 22			jp macro_next 
4eb1				endm 
# End of macro NEXTW
4eb1			; 
4eb1			.DIR: 
4eb1				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4eb1 3a				db WORD_SYS_CORE+38             
4eb2 b5 4f			dw .SAVE            
4eb4 04				db 3 + 1 
4eb5 .. 00			db "DIR",0              
4eb9				endm 
# End of macro CWHEAD
4eb9			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4eb9			; | | Compatible with PicoSPINet  
4eb9			 
4eb9					if DEBUG_FORTH_WORDS_KEY 
4eb9						DMARK "DIR" 
4eb9 f5				push af  
4eba 3a ce 4e			ld a, (.dmark)  
4ebd 32 b4 fe			ld (debug_mark),a  
4ec0 3a cf 4e			ld a, (.dmark+1)  
4ec3 32 b5 fe			ld (debug_mark+1),a  
4ec6 3a d0 4e			ld a, (.dmark+2)  
4ec9 32 b6 fe			ld (debug_mark+2),a  
4ecc 18 03			jr .pastdmark  
4ece ..			.dmark: db "DIR"  
4ed1 f1			.pastdmark: pop af  
4ed2			endm  
# End of macro DMARK
4ed2						CALLMONITOR 
4ed2 cd c6 18			call break_point_state  
4ed5				endm  
# End of macro CALLMONITOR
4ed5					endif 
4ed5 cd ca 04			call storage_get_block_0 
4ed8			 
4ed8 21 07 fc			ld hl, store_page     ; get current id count 
4edb 46				ld b, (hl) 
4edc 0e 00			ld c, 0    ; count of files   
4ede					if DEBUG_FORTH_WORDS 
4ede						DMARK "DI1" 
4ede f5				push af  
4edf 3a f3 4e			ld a, (.dmark)  
4ee2 32 b4 fe			ld (debug_mark),a  
4ee5 3a f4 4e			ld a, (.dmark+1)  
4ee8 32 b5 fe			ld (debug_mark+1),a  
4eeb 3a f5 4e			ld a, (.dmark+2)  
4eee 32 b6 fe			ld (debug_mark+2),a  
4ef1 18 03			jr .pastdmark  
4ef3 ..			.dmark: db "DI1"  
4ef6 f1			.pastdmark: pop af  
4ef7			endm  
# End of macro DMARK
4ef7						CALLMONITOR 
4ef7 cd c6 18			call break_point_state  
4efa				endm  
# End of macro CALLMONITOR
4efa					endif 
4efa			 
4efa				; check for empty drive 
4efa			 
4efa 3e 00			ld a, 0 
4efc b8				cp b 
4efd ca 6b 4f			jp z, .dirdone 
4f00			 
4f00				; for each of the current ids do a search for them and if found push to stack 
4f00			 
4f00 c5			.diritem:	push bc 
4f01 21 40 00				ld hl, STORE_BLOCK_PHY 
4f04 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4f06 58					ld e,b 
4f07			 
4f07			;		if DEBUG_FORTH_WORDS 
4f07			;			DMARK "DI2" 
4f07			;			CALLMONITOR 
4f07			;		endif 
4f07			 
4f07 cd 4c 07				call storage_findnextid 
4f0a			 
4f0a			;		if DEBUG_FORTH_WORDS 
4f0a			;			DMARK "DI3" 
4f0a			;			CALLMONITOR 
4f0a			;		endif 
4f0a			 
4f0a					; if found hl will be non zero 
4f0a			 
4f0a cd 72 0f				call ishlzero 
4f0d			;		ld a, l 
4f0d			;		add h 
4f0d			; 
4f0d			;		cp 0 
4f0d 28 59				jr z, .dirnotfound 
4f0f			 
4f0f					; increase count 
4f0f			 
4f0f c1					pop bc	 
4f10 0c					inc c 
4f11 c5					push bc 
4f12					 
4f12			 
4f12					; get file header and push the file name 
4f12			 
4f12 11 07 fc				ld de, store_page 
4f15 cd 19 04				call storage_read_block 
4f18			 
4f18					; push file id to stack 
4f18				 
4f18 3a 07 fc				ld a, (store_page) 
4f1b 26 00				ld h, 0 
4f1d 6f					ld l, a 
4f1e cd 3a 1f				call forth_push_numhl 
4f21			 
4f21					; push extent count to stack  
4f21				 
4f21 3a 09 fc				ld a, (store_page+2) 
4f24 26 00				ld h, 0 
4f26 6f					ld l, a 
4f27 cd 3a 1f				call forth_push_numhl 
4f2a			 
4f2a					; push file name 
4f2a			 
4f2a 21 0a fc				ld hl, store_page+3 
4f2d					if DEBUG_FORTH_WORDS 
4f2d						DMARK "DI5" 
4f2d f5				push af  
4f2e 3a 42 4f			ld a, (.dmark)  
4f31 32 b4 fe			ld (debug_mark),a  
4f34 3a 43 4f			ld a, (.dmark+1)  
4f37 32 b5 fe			ld (debug_mark+1),a  
4f3a 3a 44 4f			ld a, (.dmark+2)  
4f3d 32 b6 fe			ld (debug_mark+2),a  
4f40 18 03			jr .pastdmark  
4f42 ..			.dmark: db "DI5"  
4f45 f1			.pastdmark: pop af  
4f46			endm  
# End of macro DMARK
4f46						CALLMONITOR 
4f46 cd c6 18			call break_point_state  
4f49				endm  
# End of macro CALLMONITOR
4f49					endif 
4f49 cd a8 1f				call forth_push_str 
4f4c					if DEBUG_FORTH_WORDS 
4f4c						DMARK "DI6" 
4f4c f5				push af  
4f4d 3a 61 4f			ld a, (.dmark)  
4f50 32 b4 fe			ld (debug_mark),a  
4f53 3a 62 4f			ld a, (.dmark+1)  
4f56 32 b5 fe			ld (debug_mark+1),a  
4f59 3a 63 4f			ld a, (.dmark+2)  
4f5c 32 b6 fe			ld (debug_mark+2),a  
4f5f 18 03			jr .pastdmark  
4f61 ..			.dmark: db "DI6"  
4f64 f1			.pastdmark: pop af  
4f65			endm  
# End of macro DMARK
4f65						CALLMONITOR 
4f65 cd c6 18			call break_point_state  
4f68				endm  
# End of macro CALLMONITOR
4f68					endif 
4f68			.dirnotfound: 
4f68 c1					pop bc     
4f69 10 95				djnz .diritem 
4f6b				 
4f6b			.dirdone:	 
4f6b					if DEBUG_FORTH_WORDS 
4f6b						DMARK "DI7" 
4f6b f5				push af  
4f6c 3a 80 4f			ld a, (.dmark)  
4f6f 32 b4 fe			ld (debug_mark),a  
4f72 3a 81 4f			ld a, (.dmark+1)  
4f75 32 b5 fe			ld (debug_mark+1),a  
4f78 3a 82 4f			ld a, (.dmark+2)  
4f7b 32 b6 fe			ld (debug_mark+2),a  
4f7e 18 03			jr .pastdmark  
4f80 ..			.dmark: db "DI7"  
4f83 f1			.pastdmark: pop af  
4f84			endm  
# End of macro DMARK
4f84						CALLMONITOR 
4f84 cd c6 18			call break_point_state  
4f87				endm  
# End of macro CALLMONITOR
4f87					endif 
4f87			 
4f87					; push a count of the dir items found 
4f87			 
4f87 26 00				ld h, 0 
4f89 69					ld l, c 
4f8a cd 3a 1f				call forth_push_numhl 
4f8d			 
4f8d					; push the bank label 
4f8d			 
4f8d cd ca 04				call storage_get_block_0 
4f90			 
4f90				 
4f90 21 0a fc		 		ld hl, store_page+3 
4f93			 
4f93					if DEBUG_FORTH_WORDS 
4f93						DMARK "DI8" 
4f93 f5				push af  
4f94 3a a8 4f			ld a, (.dmark)  
4f97 32 b4 fe			ld (debug_mark),a  
4f9a 3a a9 4f			ld a, (.dmark+1)  
4f9d 32 b5 fe			ld (debug_mark+1),a  
4fa0 3a aa 4f			ld a, (.dmark+2)  
4fa3 32 b6 fe			ld (debug_mark+2),a  
4fa6 18 03			jr .pastdmark  
4fa8 ..			.dmark: db "DI8"  
4fab f1			.pastdmark: pop af  
4fac			endm  
# End of macro DMARK
4fac						CALLMONITOR 
4fac cd c6 18			call break_point_state  
4faf				endm  
# End of macro CALLMONITOR
4faf					endif 
4faf cd a8 1f				call forth_push_str 
4fb2			 
4fb2			 
4fb2				 
4fb2					NEXTW 
4fb2 c3 e7 22			jp macro_next 
4fb5				endm 
# End of macro NEXTW
4fb5			.SAVE: 
4fb5			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4fb5			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4fb5			;		NEXTW 
4fb5			;.LOAD: 
4fb5			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4fb5			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4fb5			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4fb5			;; > > The LOAD command can not be used in any user words or compound lines. 
4fb5			; 
4fb5			;		; store_openext use it. If zero it is EOF 
4fb5			; 
4fb5			;		; read block from current stream id 
4fb5			;		; if the block does not contain zero term keep reading blocks until zero found 
4fb5			;		; push the block to stack 
4fb5			;		; save the block id to stream 
4fb5			; 
4fb5			; 
4fb5			;		FORTH_DSP_VALUEHL 
4fb5			; 
4fb5			;;		push hl 
4fb5			; 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LOA" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			;		FORTH_DSP_POP 
4fb5			; 
4fb5			;;		pop hl 
4fb5			; 
4fb5			;		ld h, l 
4fb5			;		ld l, 0 
4fb5			; 
4fb5			;		push hl     ; stack holds current file id and extent to work with 
4fb5			; 
4fb5			; 
4fb5			;		ld de, store_page      ; get block zero of file 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LO0" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			;		call storage_read 
4fb5			; 
4fb5			;		ld a, (store_page+2)    ; max extents for this file 
4fb5			;		ld  (store_openmaxext),a   ; get our limit 
4fb5			; 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LOE" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			; 
4fb5			;; TODO dont know why max extents are not present 
4fb5			;;		cp 0 
4fb5			;;		jp z, .loadeof     ; dont read past eof 
4fb5			; 
4fb5			;;		ld a, 1   ; start from the head of the file 
4fb5			; 
4fb5			;.loadline:	pop hl 
4fb5			;		inc hl 
4fb5			;		ld  a, (store_openmaxext)   ; get our limit 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LOx" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			;		inc a 
4fb5			;		cp l 
4fb5			;		jp z, .loadeof 
4fb5			;		push hl    ; save current extent 
4fb5			; 
4fb5			;		ld de, store_page 
4fb5			; 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LO1" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			;		call storage_read 
4fb5			; 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LO2" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			;	call ishlzero 
4fb5			;	ld a, l 
4fb5			;	add h 
4fb5			;	cp 0 
4fb5			;	jr z, .loadeof 
4fb5			; 
4fb5			;	; not eof so hl should point to data to exec 
4fb5			; 
4fb5			;	; will need to add the FORTH_END_BUFFER flag 
4fb5			 ; 
4fb5			;	ld hl, store_page+2 
4fb5			;	ld bc, 255 
4fb5			;	ld a, 0 
4fb5			;	cpir 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LOt" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			;	dec hl 
4fb5			;	ld a, ' ' 
4fb5			;	ld (hl), a 
4fb5			;	inc hl 
4fb5			;	ld (hl), a 
4fb5			;	inc hl 
4fb5			;	ld (hl), a 
4fb5			;	inc hl 
4fb5			;	ld a, FORTH_END_BUFFER 
4fb5			;	ld (hl), a 
4fb5			; 
4fb5			;	; TODO handle more than a single block read 
4fb5			; 
4fb5			; 
4fb5			;	ld hl, store_page+2 
4fb5			; 
4fb5			;	ld (os_tok_ptr), hl 
4fb5			; 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LO3" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			; 
4fb5			;	call forthparse 
4fb5			;	call forthexec 
4fb5			;	call forthexec_cleanup 
4fb5			; 
4fb5			;	; go to next extent 
4fb5			; 
4fb5			;	; get next block  or mark as eof 
4fb5			;	jp .loadline 
4fb5			; 
4fb5			; 
4fb5			; 
4fb5			;	       NEXTW 
4fb5			;.loadeof:	ld a, 0 
4fb5			;		ld (store_openext), a 
4fb5			; 
4fb5			;	if DEBUG_STORESE 
4fb5			;		DMARK "LOF" 
4fb5			;		CALLMONITOR 
4fb5			;	endif 
4fb5			;		ret 
4fb5			;		;NEXTW 
4fb5			;.BSAVE:   
4fb5			; 
4fb5			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4fb5			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4fb5			;		NEXTW 
4fb5			;.BLOAD: 
4fb5			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4fb5			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4fb5			;		NEXTW 
4fb5			;;;; counter gap 
4fb5			 
4fb5			 
4fb5			.SEO: 
4fb5				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4fb5 64				db WORD_SYS_CORE+80             
4fb6 d4 4f			dw .SEI            
4fb8 04				db 3 + 1 
4fb9 .. 00			db "SEO",0              
4fbd				endm 
# End of macro CWHEAD
4fbd			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4fbd			 
4fbd					; get port 
4fbd			 
4fbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fbd cd 31 21			call macro_dsp_valuehl 
4fc0				endm 
# End of macro FORTH_DSP_VALUEHL
4fc0			 
4fc0 e5					push hl    ; u2 - byte 
4fc1			 
4fc1					; destroy value TOS 
4fc1			 
4fc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fc1 cd e9 21			call macro_forth_dsp_pop 
4fc4				endm 
# End of macro FORTH_DSP_POP
4fc4			 
4fc4					; get byte to send 
4fc4			 
4fc4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fc4 cd 31 21			call macro_dsp_valuehl 
4fc7				endm 
# End of macro FORTH_DSP_VALUEHL
4fc7			 
4fc7 e5					push hl    ; u1 - addr 
4fc8			 
4fc8					; destroy value TOS 
4fc8			 
4fc8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fc8 cd e9 21			call macro_forth_dsp_pop 
4fcb				endm 
# End of macro FORTH_DSP_POP
4fcb			 
4fcb					; one value on hl get other one back 
4fcb			 
4fcb d1					pop de   ; u1 - byte 
4fcc			 
4fcc e1					pop hl   ; u2 - addr 
4fcd			 
4fcd					; TODO Send SPI byte 
4fcd			 
4fcd			 
4fcd 7b					ld a, e 
4fce cd 1e 02				call se_writebyte 
4fd1			 
4fd1					 
4fd1			 
4fd1					NEXTW 
4fd1 c3 e7 22			jp macro_next 
4fd4				endm 
# End of macro NEXTW
4fd4			 
4fd4			.SEI: 
4fd4				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4fd4 65				db WORD_SYS_CORE+81             
4fd5 ee 4f			dw .SFREE            
4fd7 04				db 3 + 1 
4fd8 .. 00			db "SEI",0              
4fdc				endm 
# End of macro CWHEAD
4fdc			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4fdc			 
4fdc					; get port 
4fdc			 
4fdc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fdc cd 31 21			call macro_dsp_valuehl 
4fdf				endm 
# End of macro FORTH_DSP_VALUEHL
4fdf			 
4fdf			;		push hl 
4fdf			 
4fdf					; destroy value TOS 
4fdf			 
4fdf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fdf cd e9 21			call macro_forth_dsp_pop 
4fe2				endm 
# End of macro FORTH_DSP_POP
4fe2			 
4fe2					; one value on hl get other one back 
4fe2			 
4fe2			;		pop hl 
4fe2			 
4fe2			 
4fe2					; TODO Get SPI byte 
4fe2			 
4fe2 cd c0 02				call se_readbyte 
4fe5			 
4fe5 26 00				ld h, 0 
4fe7 6f					ld l, a 
4fe8 cd 3a 1f				call forth_push_numhl 
4feb			 
4feb					NEXTW 
4feb c3 e7 22			jp macro_next 
4fee				endm 
# End of macro NEXTW
4fee			 
4fee			.SFREE: 
4fee				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4fee 67				db WORD_SYS_CORE+83             
4fef 1d 50			dw .SIZE            
4ff1 06				db 5 + 1 
4ff2 .. 00			db "FFREE",0              
4ff8				endm 
# End of macro CWHEAD
4ff8			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4ff8			; | | Compatible with PicoSPINet  
4ff8					if DEBUG_FORTH_WORDS_KEY 
4ff8						DMARK "FFR" 
4ff8 f5				push af  
4ff9 3a 0d 50			ld a, (.dmark)  
4ffc 32 b4 fe			ld (debug_mark),a  
4fff 3a 0e 50			ld a, (.dmark+1)  
5002 32 b5 fe			ld (debug_mark+1),a  
5005 3a 0f 50			ld a, (.dmark+2)  
5008 32 b6 fe			ld (debug_mark+2),a  
500b 18 03			jr .pastdmark  
500d ..			.dmark: db "FFR"  
5010 f1			.pastdmark: pop af  
5011			endm  
# End of macro DMARK
5011						CALLMONITOR 
5011 cd c6 18			call break_point_state  
5014				endm  
# End of macro CALLMONITOR
5014					endif 
5014			 
5014 cd e6 07				call storage_freeblocks 
5017			 
5017 cd 3a 1f				call forth_push_numhl 
501a			 
501a				       NEXTW 
501a c3 e7 22			jp macro_next 
501d				endm 
# End of macro NEXTW
501d			.SIZE: 
501d				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
501d 67				db WORD_SYS_CORE+83             
501e 51 50			dw .CREATE            
5020 05				db 4 + 1 
5021 .. 00			db "SIZE",0              
5026				endm 
# End of macro CWHEAD
5026			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5026			; | | Compatible with PicoSPINet  
5026					if DEBUG_FORTH_WORDS_KEY 
5026						DMARK "SIZ" 
5026 f5				push af  
5027 3a 3b 50			ld a, (.dmark)  
502a 32 b4 fe			ld (debug_mark),a  
502d 3a 3c 50			ld a, (.dmark+1)  
5030 32 b5 fe			ld (debug_mark+1),a  
5033 3a 3d 50			ld a, (.dmark+2)  
5036 32 b6 fe			ld (debug_mark+2),a  
5039 18 03			jr .pastdmark  
503b ..			.dmark: db "SIZ"  
503e f1			.pastdmark: pop af  
503f			endm  
# End of macro DMARK
503f						CALLMONITOR 
503f cd c6 18			call break_point_state  
5042				endm  
# End of macro CALLMONITOR
5042					endif 
5042			 
5042					FORTH_DSP_VALUEHL 
5042 cd 31 21			call macro_dsp_valuehl 
5045				endm 
# End of macro FORTH_DSP_VALUEHL
5045			;		push hl 
5045					FORTH_DSP_POP 
5045 cd e9 21			call macro_forth_dsp_pop 
5048				endm 
# End of macro FORTH_DSP_POP
5048			;		pop hl 
5048 cd 48 04				call storage_file_size 
504b			 
504b cd 3a 1f				call forth_push_numhl 
504e			  
504e			 
504e				       NEXTW 
504e c3 e7 22			jp macro_next 
5051				endm 
# End of macro NEXTW
5051			 
5051			.CREATE: 
5051				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5051 68				db WORD_SYS_CORE+84             
5052 bf 50			dw .APPEND            
5054 07				db 6 + 1 
5055 .. 00			db "CREATE",0              
505c				endm 
# End of macro CWHEAD
505c			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
505c			; | | e.g.  
505c			; | | TestProgram CREATE 
505c			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
505c			; | |  
505c			; | | Max file IDs are 255. 
505c			; | |  
505c			; | | Compatible with PicoSPINet  
505c					 
505c					if DEBUG_FORTH_WORDS_KEY 
505c						DMARK "CRT" 
505c f5				push af  
505d 3a 71 50			ld a, (.dmark)  
5060 32 b4 fe			ld (debug_mark),a  
5063 3a 72 50			ld a, (.dmark+1)  
5066 32 b5 fe			ld (debug_mark+1),a  
5069 3a 73 50			ld a, (.dmark+2)  
506c 32 b6 fe			ld (debug_mark+2),a  
506f 18 03			jr .pastdmark  
5071 ..			.dmark: db "CRT"  
5074 f1			.pastdmark: pop af  
5075			endm  
# End of macro DMARK
5075						CALLMONITOR 
5075 cd c6 18			call break_point_state  
5078				endm  
# End of macro CALLMONITOR
5078					endif 
5078			;		call storage_get_block_0 
5078			 
5078					; TODO pop hl 
5078			 
5078					;v5 FORTH_DSP_VALUE 
5078					FORTH_DSP_VALUE 
5078 cd 1a 21			call macro_forth_dsp_value 
507b				endm 
# End of macro FORTH_DSP_VALUE
507b			 
507b				if DEBUG_STORESE 
507b					DMARK "CR1" 
507b f5				push af  
507c 3a 90 50			ld a, (.dmark)  
507f 32 b4 fe			ld (debug_mark),a  
5082 3a 91 50			ld a, (.dmark+1)  
5085 32 b5 fe			ld (debug_mark+1),a  
5088 3a 92 50			ld a, (.dmark+2)  
508b 32 b6 fe			ld (debug_mark+2),a  
508e 18 03			jr .pastdmark  
5090 ..			.dmark: db "CR1"  
5093 f1			.pastdmark: pop af  
5094			endm  
# End of macro DMARK
5094					CALLMONITOR 
5094 cd c6 18			call break_point_state  
5097				endm  
# End of macro CALLMONITOR
5097				endif 
5097			;		push hl 
5097			;		FORTH_DSP_POP 
5097			;		pop hl 
5097			 
5097			;		inc hl   ; move past the type marker 
5097			 
5097 cd 1c 08				call storage_create 
509a			 
509a				if DEBUG_STORESE 
509a					DMARK "CT1" 
509a f5				push af  
509b 3a af 50			ld a, (.dmark)  
509e 32 b4 fe			ld (debug_mark),a  
50a1 3a b0 50			ld a, (.dmark+1)  
50a4 32 b5 fe			ld (debug_mark+1),a  
50a7 3a b1 50			ld a, (.dmark+2)  
50aa 32 b6 fe			ld (debug_mark+2),a  
50ad 18 03			jr .pastdmark  
50af ..			.dmark: db "CT1"  
50b2 f1			.pastdmark: pop af  
50b3			endm  
# End of macro DMARK
50b3					CALLMONITOR 
50b3 cd c6 18			call break_point_state  
50b6				endm  
# End of macro CALLMONITOR
50b6				endif 
50b6			;		push hl 
50b6					FORTH_DSP_POP 
50b6 cd e9 21			call macro_forth_dsp_pop 
50b9				endm 
# End of macro FORTH_DSP_POP
50b9			;		pop hl 
50b9					; push file id to stack 
50b9 cd 3a 1f				call forth_push_numhl 
50bc			 
50bc			 
50bc			 
50bc				       NEXTW 
50bc c3 e7 22			jp macro_next 
50bf				endm 
# End of macro NEXTW
50bf			 
50bf			.APPEND: 
50bf				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
50bf 69				db WORD_SYS_CORE+85             
50c0 50 51			dw .SDEL            
50c2 07				db 6 + 1 
50c3 .. 00			db "APPEND",0              
50ca				endm 
# End of macro CWHEAD
50ca			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
50ca			; | | e.g. 
50ca			; | | Test CREATE      -> $01 
50ca			; | | "A string to add to file" $01 APPEND 
50ca			; | |  
50ca			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
50ca			; | | Compatible with PicoSPINet  
50ca					if DEBUG_FORTH_WORDS_KEY 
50ca						DMARK "APP" 
50ca f5				push af  
50cb 3a df 50			ld a, (.dmark)  
50ce 32 b4 fe			ld (debug_mark),a  
50d1 3a e0 50			ld a, (.dmark+1)  
50d4 32 b5 fe			ld (debug_mark+1),a  
50d7 3a e1 50			ld a, (.dmark+2)  
50da 32 b6 fe			ld (debug_mark+2),a  
50dd 18 03			jr .pastdmark  
50df ..			.dmark: db "APP"  
50e2 f1			.pastdmark: pop af  
50e3			endm  
# End of macro DMARK
50e3						CALLMONITOR 
50e3 cd c6 18			call break_point_state  
50e6				endm  
# End of macro CALLMONITOR
50e6					endif 
50e6			 
50e6					FORTH_DSP_VALUEHL 
50e6 cd 31 21			call macro_dsp_valuehl 
50e9				endm 
# End of macro FORTH_DSP_VALUEHL
50e9 e5					push hl 	; save file id 
50ea			 
50ea				if DEBUG_STORESE 
50ea					DMARK "AP1" 
50ea f5				push af  
50eb 3a ff 50			ld a, (.dmark)  
50ee 32 b4 fe			ld (debug_mark),a  
50f1 3a 00 51			ld a, (.dmark+1)  
50f4 32 b5 fe			ld (debug_mark+1),a  
50f7 3a 01 51			ld a, (.dmark+2)  
50fa 32 b6 fe			ld (debug_mark+2),a  
50fd 18 03			jr .pastdmark  
50ff ..			.dmark: db "AP1"  
5102 f1			.pastdmark: pop af  
5103			endm  
# End of macro DMARK
5103					CALLMONITOR 
5103 cd c6 18			call break_point_state  
5106				endm  
# End of macro CALLMONITOR
5106				endif 
5106					FORTH_DSP_POP 
5106 cd e9 21			call macro_forth_dsp_pop 
5109				endm 
# End of macro FORTH_DSP_POP
5109			 
5109					FORTH_DSP_VALUEHL 
5109 cd 31 21			call macro_dsp_valuehl 
510c				endm 
# End of macro FORTH_DSP_VALUEHL
510c					;v5 FORTH_DSP_VALUE 
510c e5					push hl 	; save ptr to string to save 
510d			 
510d				if DEBUG_STORESE 
510d					DMARK "AP1" 
510d f5				push af  
510e 3a 22 51			ld a, (.dmark)  
5111 32 b4 fe			ld (debug_mark),a  
5114 3a 23 51			ld a, (.dmark+1)  
5117 32 b5 fe			ld (debug_mark+1),a  
511a 3a 24 51			ld a, (.dmark+2)  
511d 32 b6 fe			ld (debug_mark+2),a  
5120 18 03			jr .pastdmark  
5122 ..			.dmark: db "AP1"  
5125 f1			.pastdmark: pop af  
5126			endm  
# End of macro DMARK
5126					CALLMONITOR 
5126 cd c6 18			call break_point_state  
5129				endm  
# End of macro CALLMONITOR
5129				endif 
5129					FORTH_DSP_POP 
5129 cd e9 21			call macro_forth_dsp_pop 
512c				endm 
# End of macro FORTH_DSP_POP
512c			 
512c d1					pop de 
512d e1					pop hl 
512e				if DEBUG_STORESE 
512e					DMARK "AP2" 
512e f5				push af  
512f 3a 43 51			ld a, (.dmark)  
5132 32 b4 fe			ld (debug_mark),a  
5135 3a 44 51			ld a, (.dmark+1)  
5138 32 b5 fe			ld (debug_mark+1),a  
513b 3a 45 51			ld a, (.dmark+2)  
513e 32 b6 fe			ld (debug_mark+2),a  
5141 18 03			jr .pastdmark  
5143 ..			.dmark: db "AP2"  
5146 f1			.pastdmark: pop af  
5147			endm  
# End of macro DMARK
5147					CALLMONITOR 
5147 cd c6 18			call break_point_state  
514a				endm  
# End of macro CALLMONITOR
514a				endif 
514a					;inc de ; skip var type indicator 
514a			 
514a					; TODO how to append numerics???? 
514a			 
514a cd 09 0b				call storage_append		 
514d			 
514d				       NEXTW 
514d c3 e7 22			jp macro_next 
5150				endm 
# End of macro NEXTW
5150			.SDEL: 
5150				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5150 6a				db WORD_SYS_CORE+86             
5151 9c 51			dw .OPEN            
5153 05				db 4 + 1 
5154 .. 00			db "ERA",0              
5158				endm 
# End of macro CWHEAD
5158			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5158			; | | Compatible with PicoSPINet  
5158					FORTH_DSP_VALUEHL 
5158 cd 31 21			call macro_dsp_valuehl 
515b				endm 
# End of macro FORTH_DSP_VALUEHL
515b			;		push hl 	; save file id 
515b			 
515b					if DEBUG_FORTH_WORDS_KEY 
515b						DMARK "ERA" 
515b f5				push af  
515c 3a 70 51			ld a, (.dmark)  
515f 32 b4 fe			ld (debug_mark),a  
5162 3a 71 51			ld a, (.dmark+1)  
5165 32 b5 fe			ld (debug_mark+1),a  
5168 3a 72 51			ld a, (.dmark+2)  
516b 32 b6 fe			ld (debug_mark+2),a  
516e 18 03			jr .pastdmark  
5170 ..			.dmark: db "ERA"  
5173 f1			.pastdmark: pop af  
5174			endm  
# End of macro DMARK
5174						CALLMONITOR 
5174 cd c6 18			call break_point_state  
5177				endm  
# End of macro CALLMONITOR
5177					endif 
5177				if DEBUG_STORESE 
5177					DMARK "ER1" 
5177 f5				push af  
5178 3a 8c 51			ld a, (.dmark)  
517b 32 b4 fe			ld (debug_mark),a  
517e 3a 8d 51			ld a, (.dmark+1)  
5181 32 b5 fe			ld (debug_mark+1),a  
5184 3a 8e 51			ld a, (.dmark+2)  
5187 32 b6 fe			ld (debug_mark+2),a  
518a 18 03			jr .pastdmark  
518c ..			.dmark: db "ER1"  
518f f1			.pastdmark: pop af  
5190			endm  
# End of macro DMARK
5190					CALLMONITOR 
5190 cd c6 18			call break_point_state  
5193				endm  
# End of macro CALLMONITOR
5193				endif 
5193					FORTH_DSP_POP 
5193 cd e9 21			call macro_forth_dsp_pop 
5196				endm 
# End of macro FORTH_DSP_POP
5196			 
5196			;		pop hl 
5196			 
5196 cd 5b 06				call storage_erase 
5199				       NEXTW 
5199 c3 e7 22			jp macro_next 
519c				endm 
# End of macro NEXTW
519c			 
519c			.OPEN: 
519c				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
519c 6b				db WORD_SYS_CORE+87             
519d 30 52			dw .READ            
519f 05				db 4 + 1 
51a0 .. 00			db "OPEN",0              
51a5				endm 
# End of macro CWHEAD
51a5			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
51a5			; | | e.g. 
51a5			; | | $01 OPEN $01 DO $01 READ . LOOP 
51a5			; | | 
51a5			; | | Will return with 255 blocks if the file does not exist 
51a5			; | | Compatible with PicoSPINet  
51a5			 
51a5					if DEBUG_FORTH_WORDS_KEY 
51a5						DMARK "OPN" 
51a5 f5				push af  
51a6 3a ba 51			ld a, (.dmark)  
51a9 32 b4 fe			ld (debug_mark),a  
51ac 3a bb 51			ld a, (.dmark+1)  
51af 32 b5 fe			ld (debug_mark+1),a  
51b2 3a bc 51			ld a, (.dmark+2)  
51b5 32 b6 fe			ld (debug_mark+2),a  
51b8 18 03			jr .pastdmark  
51ba ..			.dmark: db "OPN"  
51bd f1			.pastdmark: pop af  
51be			endm  
# End of macro DMARK
51be						CALLMONITOR 
51be cd c6 18			call break_point_state  
51c1				endm  
# End of macro CALLMONITOR
51c1					endif 
51c1					; TODO handle multiple file opens 
51c1			 
51c1 3e 01			       	ld a, 1 
51c3 32 f7 fb				ld (store_openext), a 
51c6			 
51c6					; get max extents for this file 
51c6				 
51c6								 
51c6					FORTH_DSP_VALUEHL 
51c6 cd 31 21			call macro_dsp_valuehl 
51c9				endm 
# End of macro FORTH_DSP_VALUEHL
51c9			 
51c9 65					ld h, l 
51ca 2e 00				ld l, 0 
51cc			 
51cc					; store file id 
51cc			 
51cc 7c					ld a, h 
51cd 32 f4 fb				ld (store_filecache), a 
51d0			 
51d0				if DEBUG_STORESE 
51d0					DMARK "OPN" 
51d0 f5				push af  
51d1 3a e5 51			ld a, (.dmark)  
51d4 32 b4 fe			ld (debug_mark),a  
51d7 3a e6 51			ld a, (.dmark+1)  
51da 32 b5 fe			ld (debug_mark+1),a  
51dd 3a e7 51			ld a, (.dmark+2)  
51e0 32 b6 fe			ld (debug_mark+2),a  
51e3 18 03			jr .pastdmark  
51e5 ..			.dmark: db "OPN"  
51e8 f1			.pastdmark: pop af  
51e9			endm  
# End of macro DMARK
51e9					CALLMONITOR 
51e9 cd c6 18			call break_point_state  
51ec				endm  
# End of macro CALLMONITOR
51ec				endif 
51ec			;		push hl 
51ec					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
51ec cd e9 21			call macro_forth_dsp_pop 
51ef				endm 
# End of macro FORTH_DSP_POP
51ef			;		pop hl 
51ef						 
51ef 11 07 fc				ld de, store_page      ; get block zero of file 
51f2 cd 72 09				call storage_read 
51f5 cd 72 0f			call ishlzero 
51f8 20 04			jr nz, .opfound 
51fa			 
51fa				; file does not exist so indicate with 255 extents in use 
51fa			 
51fa 3e ff			ld a, 255 
51fc 18 29			jr .skipopeneof 
51fe			 
51fe			 
51fe			.opfound: 
51fe			 
51fe			 
51fe 3a 09 fc				ld a, (store_page+2)    ; max extents for this file 
5201 32 f6 fb				ld  (store_openmaxext), a   ; get our limit and push 
5204					 
5204				if DEBUG_STORESE 
5204					DMARK "OPx" 
5204 f5				push af  
5205 3a 19 52			ld a, (.dmark)  
5208 32 b4 fe			ld (debug_mark),a  
520b 3a 1a 52			ld a, (.dmark+1)  
520e 32 b5 fe			ld (debug_mark+1),a  
5211 3a 1b 52			ld a, (.dmark+2)  
5214 32 b6 fe			ld (debug_mark+2),a  
5217 18 03			jr .pastdmark  
5219 ..			.dmark: db "OPx"  
521c f1			.pastdmark: pop af  
521d			endm  
# End of macro DMARK
521d					CALLMONITOR 
521d cd c6 18			call break_point_state  
5220				endm  
# End of macro CALLMONITOR
5220				endif 
5220 fe 00				cp 0 
5222 20 03				jr nz, .skipopeneof 
5224					; have opened an empty file 
5224					 
5224 32 f7 fb				ld (store_openext), a 
5227			 
5227			.skipopeneof: 
5227			 
5227 6f					ld l, a 
5228 26 00				ld h, 0 
522a cd 3a 1f				call forth_push_numhl 
522d			 
522d			 
522d				       NEXTW 
522d c3 e7 22			jp macro_next 
5230				endm 
# End of macro NEXTW
5230			.READ: 
5230				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5230 6c				db WORD_SYS_CORE+88             
5231 5a 53			dw .EOF            
5233 05				db 4 + 1 
5234 .. 00			db "READ",0              
5239				endm 
# End of macro CWHEAD
5239			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5239			; | | e.g. 
5239			; | | $01 OPEN $01 DO READ . LOOP 
5239			; | | 
5239			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5239			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5239			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5239			; | | two bytes contain the file id and extent. 
5239			; | |  
5239			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5239			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5239			; | | Compatible with PicoSPINet  
5239			 
5239					if DEBUG_FORTH_WORDS_KEY 
5239						DMARK "REA" 
5239 f5				push af  
523a 3a 4e 52			ld a, (.dmark)  
523d 32 b4 fe			ld (debug_mark),a  
5240 3a 4f 52			ld a, (.dmark+1)  
5243 32 b5 fe			ld (debug_mark+1),a  
5246 3a 50 52			ld a, (.dmark+2)  
5249 32 b6 fe			ld (debug_mark+2),a  
524c 18 03			jr .pastdmark  
524e ..			.dmark: db "REA"  
5251 f1			.pastdmark: pop af  
5252			endm  
# End of macro DMARK
5252						CALLMONITOR 
5252 cd c6 18			call break_point_state  
5255				endm  
# End of macro CALLMONITOR
5255					endif 
5255					; store_openext use it. If zero it is EOF 
5255			 
5255					; read block from current stream id 
5255					; if the block does not contain zero term keep reading blocks until zero found 
5255					; push the block to stack 
5255					; save the block id to stream 
5255			 
5255			 
5255 cd 87 53				call .testeof 
5258 3e 01				ld a, 1 
525a bd					cp l 
525b ca 36 53				jp z, .ateof 
525e			 
525e			 
525e			;		FORTH_DSP_VALUEHL 
525e			 
525e			;		push hl 
525e			 
525e			;	if DEBUG_STORESE 
525e			;		DMARK "REA" 
525e			;		CALLMONITOR 
525e			;	endif 
525e			;		FORTH_DSP_POP 
525e			 
525e			;		pop hl 
525e				 
525e 3a f4 fb				ld a, (store_filecache) 
5261 67					ld h,a 
5262			 
5262 3a f7 fb				ld a, (store_openext) 
5265 6f					ld l, a 
5266					 
5266 fe 00				cp 0 
5268 ca 36 53				jp z, .ateof     ; dont read past eof 
526b			 
526b cd 55 0c				call storage_clear_page 
526e			 
526e 11 07 fc				ld de, store_page 
5271				if DEBUG_STORESE 
5271					DMARK "RE1" 
5271 f5				push af  
5272 3a 86 52			ld a, (.dmark)  
5275 32 b4 fe			ld (debug_mark),a  
5278 3a 87 52			ld a, (.dmark+1)  
527b 32 b5 fe			ld (debug_mark+1),a  
527e 3a 88 52			ld a, (.dmark+2)  
5281 32 b6 fe			ld (debug_mark+2),a  
5284 18 03			jr .pastdmark  
5286 ..			.dmark: db "RE1"  
5289 f1			.pastdmark: pop af  
528a			endm  
# End of macro DMARK
528a					CALLMONITOR 
528a cd c6 18			call break_point_state  
528d				endm  
# End of macro CALLMONITOR
528d				endif 
528d cd 72 09				call storage_read 
5290			 
5290				if DEBUG_STORESE 
5290					DMARK "RE2" 
5290 f5				push af  
5291 3a a5 52			ld a, (.dmark)  
5294 32 b4 fe			ld (debug_mark),a  
5297 3a a6 52			ld a, (.dmark+1)  
529a 32 b5 fe			ld (debug_mark+1),a  
529d 3a a7 52			ld a, (.dmark+2)  
52a0 32 b6 fe			ld (debug_mark+2),a  
52a3 18 03			jr .pastdmark  
52a5 ..			.dmark: db "RE2"  
52a8 f1			.pastdmark: pop af  
52a9			endm  
# End of macro DMARK
52a9					CALLMONITOR 
52a9 cd c6 18			call break_point_state  
52ac				endm  
# End of macro CALLMONITOR
52ac				endif 
52ac cd 72 0f			call ishlzero 
52af			;	ld a, l 
52af			;	add h 
52af			;	cp 0 
52af ca 36 53			jp z, .readeof 
52b2			 
52b2				; not eof so hl should point to data to push to stack 
52b2			 
52b2				if DEBUG_STORESE 
52b2					DMARK "RE3" 
52b2 f5				push af  
52b3 3a c7 52			ld a, (.dmark)  
52b6 32 b4 fe			ld (debug_mark),a  
52b9 3a c8 52			ld a, (.dmark+1)  
52bc 32 b5 fe			ld (debug_mark+1),a  
52bf 3a c9 52			ld a, (.dmark+2)  
52c2 32 b6 fe			ld (debug_mark+2),a  
52c5 18 03			jr .pastdmark  
52c7 ..			.dmark: db "RE3"  
52ca f1			.pastdmark: pop af  
52cb			endm  
# End of macro DMARK
52cb					CALLMONITOR 
52cb cd c6 18			call break_point_state  
52ce				endm  
# End of macro CALLMONITOR
52ce				endif 
52ce cd a8 1f			call forth_push_str 
52d1			 
52d1				if DEBUG_STORESE 
52d1					DMARK "RE4" 
52d1 f5				push af  
52d2 3a e6 52			ld a, (.dmark)  
52d5 32 b4 fe			ld (debug_mark),a  
52d8 3a e7 52			ld a, (.dmark+1)  
52db 32 b5 fe			ld (debug_mark+1),a  
52de 3a e8 52			ld a, (.dmark+2)  
52e1 32 b6 fe			ld (debug_mark+2),a  
52e4 18 03			jr .pastdmark  
52e6 ..			.dmark: db "RE4"  
52e9 f1			.pastdmark: pop af  
52ea			endm  
# End of macro DMARK
52ea					CALLMONITOR 
52ea cd c6 18			call break_point_state  
52ed				endm  
# End of macro CALLMONITOR
52ed				endif 
52ed				; get next block  or mark as eof 
52ed			 
52ed 3a f6 fb			ld a, (store_openmaxext)   ; get our limit 
52f0 4f				ld c, a	 
52f1 3a f7 fb			ld a, (store_openext) 
52f4			 
52f4				if DEBUG_STORESE 
52f4					DMARK "RE5" 
52f4 f5				push af  
52f5 3a 09 53			ld a, (.dmark)  
52f8 32 b4 fe			ld (debug_mark),a  
52fb 3a 0a 53			ld a, (.dmark+1)  
52fe 32 b5 fe			ld (debug_mark+1),a  
5301 3a 0b 53			ld a, (.dmark+2)  
5304 32 b6 fe			ld (debug_mark+2),a  
5307 18 03			jr .pastdmark  
5309 ..			.dmark: db "RE5"  
530c f1			.pastdmark: pop af  
530d			endm  
# End of macro DMARK
530d					CALLMONITOR 
530d cd c6 18			call break_point_state  
5310				endm  
# End of macro CALLMONITOR
5310				endif 
5310 b9				cp c 
5311 28 23			jr z, .readeof     ; at last extent 
5313			 
5313 3c					inc a 
5314 32 f7 fb				ld (store_openext), a 
5317			 
5317				if DEBUG_STORESE 
5317					DMARK "RE6" 
5317 f5				push af  
5318 3a 2c 53			ld a, (.dmark)  
531b 32 b4 fe			ld (debug_mark),a  
531e 3a 2d 53			ld a, (.dmark+1)  
5321 32 b5 fe			ld (debug_mark+1),a  
5324 3a 2e 53			ld a, (.dmark+2)  
5327 32 b6 fe			ld (debug_mark+2),a  
532a 18 03			jr .pastdmark  
532c ..			.dmark: db "RE6"  
532f f1			.pastdmark: pop af  
5330			endm  
# End of macro DMARK
5330					CALLMONITOR 
5330 cd c6 18			call break_point_state  
5333				endm  
# End of macro CALLMONITOR
5333				endif 
5333			 
5333			 
5333				       NEXTW 
5333 c3 e7 22			jp macro_next 
5336				endm 
# End of macro NEXTW
5336			.ateof: 
5336				;	ld hl, .showeof 
5336				;	call forth_push_str 
5336 3e 00		.readeof:	ld a, 0 
5338 32 f7 fb				ld (store_openext), a 
533b			 
533b					 
533b				if DEBUG_STORESE 
533b					DMARK "REF" 
533b f5				push af  
533c 3a 50 53			ld a, (.dmark)  
533f 32 b4 fe			ld (debug_mark),a  
5342 3a 51 53			ld a, (.dmark+1)  
5345 32 b5 fe			ld (debug_mark+1),a  
5348 3a 52 53			ld a, (.dmark+2)  
534b 32 b6 fe			ld (debug_mark+2),a  
534e 18 03			jr .pastdmark  
5350 ..			.dmark: db "REF"  
5353 f1			.pastdmark: pop af  
5354			endm  
# End of macro DMARK
5354					CALLMONITOR 
5354 cd c6 18			call break_point_state  
5357				endm  
# End of macro CALLMONITOR
5357				endif 
5357				       NEXTW 
5357 c3 e7 22			jp macro_next 
535a				endm 
# End of macro NEXTW
535a			 
535a			;.showeof:   db "eof", 0 
535a			 
535a			 
535a			.EOF: 
535a				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
535a 6d				db WORD_SYS_CORE+89             
535b 9c 53			dw .FORMAT            
535d 04				db 3 + 1 
535e .. 00			db "EOF",0              
5362				endm 
# End of macro CWHEAD
5362			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5362			; | | e.g. 
5362			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5362			; | | Compatible with PicoSPINet  
5362					; TODO if current block id for stream is zero then push true else false 
5362			 
5362					if DEBUG_FORTH_WORDS_KEY 
5362						DMARK "EOF" 
5362 f5				push af  
5363 3a 77 53			ld a, (.dmark)  
5366 32 b4 fe			ld (debug_mark),a  
5369 3a 78 53			ld a, (.dmark+1)  
536c 32 b5 fe			ld (debug_mark+1),a  
536f 3a 79 53			ld a, (.dmark+2)  
5372 32 b6 fe			ld (debug_mark+2),a  
5375 18 03			jr .pastdmark  
5377 ..			.dmark: db "EOF"  
537a f1			.pastdmark: pop af  
537b			endm  
# End of macro DMARK
537b						CALLMONITOR 
537b cd c6 18			call break_point_state  
537e				endm  
# End of macro CALLMONITOR
537e					endif 
537e			 
537e					; TODO handlue multiple file streams 
537e			 
537e			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
537e cd 87 53				call .testeof 
5381 cd 3a 1f				call forth_push_numhl 
5384			 
5384			 
5384				       NEXTW 
5384 c3 e7 22			jp macro_next 
5387				endm 
# End of macro NEXTW
5387			 
5387			.testeof: 
5387 2e 01				ld l, 1 
5389 3a f6 fb				ld a, (store_openmaxext) 
538c fe 00				cp 0 
538e 28 09				jr  z, .eofdone   ; empty file 
5390 3a f7 fb				ld a, (store_openext) 
5393 fe 00				cp 0 
5395 28 02				jr  z, .eofdone 
5397 2e 00				ld l, 0 
5399 26 00		.eofdone:	ld h, 0 
539b c9					ret 
539c			 
539c			 
539c			 
539c			 
539c			.FORMAT: 
539c				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
539c 6d				db WORD_SYS_CORE+89             
539d ed 53			dw .LABEL            
539f 07				db 6 + 1 
53a0 .. 00			db "FORMAT",0              
53a7				endm 
# End of macro CWHEAD
53a7			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
53a7			; | | Compatible with PicoSPINet  
53a7					; TODO if current block id for stream is zero then push true else false 
53a7				 
53a7				if DEBUG_STORESE 
53a7					DMARK "FOR" 
53a7 f5				push af  
53a8 3a bc 53			ld a, (.dmark)  
53ab 32 b4 fe			ld (debug_mark),a  
53ae 3a bd 53			ld a, (.dmark+1)  
53b1 32 b5 fe			ld (debug_mark+1),a  
53b4 3a be 53			ld a, (.dmark+2)  
53b7 32 b6 fe			ld (debug_mark+2),a  
53ba 18 03			jr .pastdmark  
53bc ..			.dmark: db "FOR"  
53bf f1			.pastdmark: pop af  
53c0			endm  
# End of macro DMARK
53c0					CALLMONITOR 
53c0 cd c6 18			call break_point_state  
53c3				endm  
# End of macro CALLMONITOR
53c3				endif 
53c3					; Wipes the bank check flags to cause a reformat on next block 0 read 
53c3			 
53c3 21 01 00				ld hl, 1 
53c6 3e 00				ld a, 0 
53c8 cd 1e 02				call se_writebyte 
53cb			 
53cb				if DEBUG_STORESE 
53cb					DMARK "FO0" 
53cb f5				push af  
53cc 3a e0 53			ld a, (.dmark)  
53cf 32 b4 fe			ld (debug_mark),a  
53d2 3a e1 53			ld a, (.dmark+1)  
53d5 32 b5 fe			ld (debug_mark+1),a  
53d8 3a e2 53			ld a, (.dmark+2)  
53db 32 b6 fe			ld (debug_mark+2),a  
53de 18 03			jr .pastdmark  
53e0 ..			.dmark: db "FO0"  
53e3 f1			.pastdmark: pop af  
53e4			endm  
# End of macro DMARK
53e4					CALLMONITOR 
53e4 cd c6 18			call break_point_state  
53e7				endm  
# End of macro CALLMONITOR
53e7				endif 
53e7					; force bank init 
53e7			 
53e7 cd ca 04				call storage_get_block_0 
53ea					 
53ea				       NEXTW 
53ea c3 e7 22			jp macro_next 
53ed				endm 
# End of macro NEXTW
53ed			.LABEL: 
53ed				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
53ed 6d				db WORD_SYS_CORE+89             
53ee 3b 54			dw .STOREPAGE            
53f0 06				db 5 + 1 
53f1 .. 00			db "LABEL",0              
53f7				endm 
# End of macro CWHEAD
53f7			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
53f7			; | | Compatible with PicoSPINet  
53f7					; TODO test to see if bank is selected 
53f7				 
53f7					if DEBUG_FORTH_WORDS_KEY 
53f7						DMARK "LBL" 
53f7 f5				push af  
53f8 3a 0c 54			ld a, (.dmark)  
53fb 32 b4 fe			ld (debug_mark),a  
53fe 3a 0d 54			ld a, (.dmark+1)  
5401 32 b5 fe			ld (debug_mark+1),a  
5404 3a 0e 54			ld a, (.dmark+2)  
5407 32 b6 fe			ld (debug_mark+2),a  
540a 18 03			jr .pastdmark  
540c ..			.dmark: db "LBL"  
540f f1			.pastdmark: pop af  
5410			endm  
# End of macro DMARK
5410						CALLMONITOR 
5410 cd c6 18			call break_point_state  
5413				endm  
# End of macro CALLMONITOR
5413					endif 
5413			;	if DEBUG_STORESE 
5413			;		DMARK "LBL" 
5413			;		CALLMONITOR 
5413			;	endif 
5413					FORTH_DSP_VALUEHL 
5413 cd 31 21			call macro_dsp_valuehl 
5416				endm 
# End of macro FORTH_DSP_VALUEHL
5416					;v5FORTH_DSP_VALUE 
5416					 
5416			;		push hl 
5416					FORTH_DSP_POP 
5416 cd e9 21			call macro_forth_dsp_pop 
5419				endm 
# End of macro FORTH_DSP_POP
5419			;		pop hl 
5419			 
5419			;v5		inc hl   ; move past the type marker 
5419			 
5419				if DEBUG_STORESE 
5419					DMARK "LBl" 
5419 f5				push af  
541a 3a 2e 54			ld a, (.dmark)  
541d 32 b4 fe			ld (debug_mark),a  
5420 3a 2f 54			ld a, (.dmark+1)  
5423 32 b5 fe			ld (debug_mark+1),a  
5426 3a 30 54			ld a, (.dmark+2)  
5429 32 b6 fe			ld (debug_mark+2),a  
542c 18 03			jr .pastdmark  
542e ..			.dmark: db "LBl"  
5431 f1			.pastdmark: pop af  
5432			endm  
# End of macro DMARK
5432					CALLMONITOR 
5432 cd c6 18			call break_point_state  
5435				endm  
# End of macro CALLMONITOR
5435				endif 
5435 cd ee 05				call storage_label 
5438			 
5438				       NEXTW 
5438 c3 e7 22			jp macro_next 
543b				endm 
# End of macro NEXTW
543b			.STOREPAGE: 
543b				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
543b 6d				db WORD_SYS_CORE+89             
543c 6e 54			dw .LABELS            
543e 0a				db 9 + 1 
543f .. 00			db "STOREPAGE",0              
5449				endm 
# End of macro CWHEAD
5449			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5449			; | | Compatible with PicoSPINet  
5449					; TODO test to see if bank is selected 
5449				 
5449					if DEBUG_FORTH_WORDS_KEY 
5449						DMARK "STP" 
5449 f5				push af  
544a 3a 5e 54			ld a, (.dmark)  
544d 32 b4 fe			ld (debug_mark),a  
5450 3a 5f 54			ld a, (.dmark+1)  
5453 32 b5 fe			ld (debug_mark+1),a  
5456 3a 60 54			ld a, (.dmark+2)  
5459 32 b6 fe			ld (debug_mark+2),a  
545c 18 03			jr .pastdmark  
545e ..			.dmark: db "STP"  
5461 f1			.pastdmark: pop af  
5462			endm  
# End of macro DMARK
5462						CALLMONITOR 
5462 cd c6 18			call break_point_state  
5465				endm  
# End of macro CALLMONITOR
5465					endif 
5465			;	if DEBUG_STORESE 
5465			;		DMARK "STP" 
5465			;		CALLMONITOR 
5465			;	endif 
5465			 
5465 21 07 fc			ld hl, store_page 
5468 cd 3a 1f			call forth_push_numhl 
546b			 
546b			 
546b				       NEXTW 
546b c3 e7 22			jp macro_next 
546e				endm 
# End of macro NEXTW
546e			.LABELS: 
546e				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
546e 6d				db WORD_SYS_CORE+89             
546f f8 54			dw .SCONST1            
5471 07				db 6 + 1 
5472 .. 00			db "LABELS",0              
5479				endm 
# End of macro CWHEAD
5479			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5479			; | | *NOT* Compatible with PicoSPINet  
5479					;  
5479			 
5479					; save the current device selected to restore afterwards 
5479				 
5479 3a ed fb				ld a, (spi_device) 
547c f5					push af 
547d			 
547d			 
547d					; run through each of the banks 
547d			 
547d 21 01 00				ld hl, 1 
5480 cd 3a 1f				call forth_push_numhl 
5483 3e ff				ld a, SPI_CE_HIGH 
5485 cb 87				res SPI_CE0, a 
5487 32 ed fb				ld (spi_device), a 
548a cd ca 04				call storage_get_block_0 
548d 21 0a fc				ld hl, store_page+3 
5490 cd a8 1f				call forth_push_str 
5493			 
5493					 
5493 21 02 00				ld hl, 2 
5496 cd 3a 1f				call forth_push_numhl 
5499 3e ff				ld a, SPI_CE_HIGH 
549b cb 8f				res SPI_CE1, a 
549d 32 ed fb				ld (spi_device), a 
54a0 cd ca 04				call storage_get_block_0 
54a3 21 0a fc				ld hl, store_page+3 
54a6 cd a8 1f				call forth_push_str 
54a9			 
54a9					 
54a9 21 03 00				ld hl, 3 
54ac cd 3a 1f				call forth_push_numhl 
54af 3e ff				ld a, SPI_CE_HIGH 
54b1 cb 97				res SPI_CE2, a 
54b3 32 ed fb				ld (spi_device), a 
54b6 cd ca 04				call storage_get_block_0 
54b9 21 0a fc				ld hl, store_page+3 
54bc cd a8 1f				call forth_push_str 
54bf			 
54bf			 
54bf 21 04 00				ld hl, 4 
54c2 cd 3a 1f				call forth_push_numhl 
54c5 3e ff				ld a, SPI_CE_HIGH 
54c7 cb 9f				res SPI_CE3, a 
54c9 32 ed fb				ld (spi_device), a 
54cc cd ca 04				call storage_get_block_0 
54cf 21 0a fc				ld hl, store_page+3 
54d2 cd a8 1f				call forth_push_str 
54d5			 
54d5					 
54d5			 
54d5 21 05 00				ld hl, 5 
54d8 cd 3a 1f				call forth_push_numhl 
54db 3e ff				ld a, SPI_CE_HIGH 
54dd cb a7				res SPI_CE4, a 
54df 32 ed fb				ld (spi_device), a 
54e2 cd ca 04				call storage_get_block_0 
54e5 21 0a fc				ld hl, store_page+3 
54e8 cd a8 1f				call forth_push_str 
54eb			 
54eb					 
54eb					; push fixed count of storage devices (on board) for now 
54eb			 
54eb 21 05 00				ld hl, 5 
54ee cd 3a 1f				call forth_push_numhl 
54f1			 
54f1					; restore selected device  
54f1				 
54f1 f1					pop af 
54f2 32 ed fb				ld (spi_device), a 
54f5			 
54f5				       NEXTW 
54f5 c3 e7 22			jp macro_next 
54f8				endm 
# End of macro NEXTW
54f8			 
54f8			.SCONST1: 
54f8				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
54f8 6d				db WORD_SYS_CORE+89             
54f9 0f 55			dw .SCONST2            
54fb 07				db 6 + 1 
54fc .. 00			db "FILEID",0              
5503				endm 
# End of macro CWHEAD
5503			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5503			; | | Compatible with PicoSPINet  
5503 3a f4 fb				ld a, (store_filecache) 
5506 26 00				ld h, 0 
5508 6f					ld l, a 
5509 cd 3a 1f				call forth_push_numhl 
550c					NEXTW 
550c c3 e7 22			jp macro_next 
550f				endm 
# End of macro NEXTW
550f			.SCONST2: 
550f				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
550f 6d				db WORD_SYS_CORE+89             
5510 27 55			dw .SCONST3            
5512 08				db 7 + 1 
5513 .. 00			db "FILEEXT",0              
551b				endm 
# End of macro CWHEAD
551b			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
551b			; | | Compatible with PicoSPINet  
551b 3a f7 fb				ld a, (store_openext) 
551e 26 00				ld h, 0 
5520 6f					ld l, a 
5521 cd 3a 1f				call forth_push_numhl 
5524					NEXTW 
5524 c3 e7 22			jp macro_next 
5527				endm 
# End of macro NEXTW
5527			.SCONST3: 
5527				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5527 6d				db WORD_SYS_CORE+89             
5528 3f 55			dw .SCONST4            
552a 08				db 7 + 1 
552b .. 00			db "FILEMAX",0              
5533				endm 
# End of macro CWHEAD
5533			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5533			; | | Compatible with PicoSPINet  
5533 3a f6 fb				ld a, (store_openmaxext) 
5536 26 00				ld h, 0 
5538 6f					ld l, a 
5539 cd 3a 1f				call forth_push_numhl 
553c					NEXTW 
553c c3 e7 22			jp macro_next 
553f				endm 
# End of macro NEXTW
553f			.SCONST4: 
553f				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
553f 6d				db WORD_SYS_CORE+89             
5540 55 55			dw .SCONST5            
5542 09				db 8 + 1 
5543 .. 00			db "FILEADDR",0              
554c				endm 
# End of macro CWHEAD
554c			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
554c			; | | Compatible with PicoSPINet  
554c 2a f8 fb				ld hl, (store_openaddr) 
554f cd 3a 1f				call forth_push_numhl 
5552					NEXTW 
5552 c3 e7 22			jp macro_next 
5555				endm 
# End of macro NEXTW
5555			.SCONST5: 
5555				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5555 6d				db WORD_SYS_CORE+89             
5556 6e 55			dw .ENDSTORAGE            
5558 09				db 8 + 1 
5559 .. 00			db "READCONT",0              
5562				endm 
# End of macro CWHEAD
5562			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5562			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5562			; | | a further read should, if applicable, be CONCAT to the previous read. 
5562			; | | Compatible with PicoSPINet  
5562 3a fa fb				ld a, (store_readcont) 
5565 26 00				ld h, 0 
5567 6f					ld l, a 
5568 cd 3a 1f				call forth_push_numhl 
556b					NEXTW 
556b c3 e7 22			jp macro_next 
556e				endm 
# End of macro NEXTW
556e			.ENDSTORAGE: 
556e			; eof 
# End of file forth_words_storage.asm
556e			endif 
556e				include "forth_words_device.asm" 
556e			; Device related words 
556e			 
556e			; | ## Device Words 
556e			 
556e			;if SOUND_ENABLE 
556e			;.NOTE: 
556e			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
556e			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
556e			;		if DEBUG_FORTH_WORDS_KEY 
556e			;			DMARK "NTE" 
556e			;			CALLMONITOR 
556e			;		endif 
556e			; 
556e			;	 
556e			; 
556e			;		NEXTW 
556e			;.AFTERSOUND: 
556e			;endif 
556e			 
556e			 
556e			USE_GPIO: equ 0 
556e			 
556e			if USE_GPIO 
556e			.GP1: 
556e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
556e			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
556e					NEXTW 
556e			.GP2: 
556e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
556e			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
556e			 
556e					NEXTW 
556e			 
556e			.GP3: 
556e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
556e			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
556e			 
556e					NEXTW 
556e			 
556e			.GP4: 
556e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
556e			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
556e			 
556e					NEXTW 
556e			.SIN: 
556e			 
556e			 
556e			endif 
556e			 
556e			 
556e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
556e 33				db WORD_SYS_CORE+31             
556f a3 55			dw .SOUT            
5571 03				db 2 + 1 
5572 .. 00			db "IN",0              
5575				endm 
# End of macro CWHEAD
5575			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5575					if DEBUG_FORTH_WORDS_KEY 
5575						DMARK "IN." 
5575 f5				push af  
5576 3a 8a 55			ld a, (.dmark)  
5579 32 b4 fe			ld (debug_mark),a  
557c 3a 8b 55			ld a, (.dmark+1)  
557f 32 b5 fe			ld (debug_mark+1),a  
5582 3a 8c 55			ld a, (.dmark+2)  
5585 32 b6 fe			ld (debug_mark+2),a  
5588 18 03			jr .pastdmark  
558a ..			.dmark: db "IN."  
558d f1			.pastdmark: pop af  
558e			endm  
# End of macro DMARK
558e						CALLMONITOR 
558e cd c6 18			call break_point_state  
5591				endm  
# End of macro CALLMONITOR
5591					endif 
5591					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5591 cd 31 21			call macro_dsp_valuehl 
5594				endm 
# End of macro FORTH_DSP_VALUEHL
5594			 
5594 e5					push hl 
5595			 
5595					; destroy value TOS 
5595			 
5595					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5595 cd e9 21			call macro_forth_dsp_pop 
5598				endm 
# End of macro FORTH_DSP_POP
5598			 
5598					; one value on hl get other one back 
5598			 
5598 c1					pop bc 
5599			 
5599					; do the sub 
5599			;		ex de, hl 
5599			 
5599 ed 68				in l,(c) 
559b			 
559b					; save it 
559b			 
559b 26 00				ld h,0 
559d			 
559d					; TODO push value back onto stack for another op etc 
559d			 
559d cd 3a 1f				call forth_push_numhl 
55a0					NEXTW 
55a0 c3 e7 22			jp macro_next 
55a3				endm 
# End of macro NEXTW
55a3			.SOUT: 
55a3				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
55a3 34				db WORD_SYS_CORE+32             
55a4 f6 55			dw .SPIO            
55a6 04				db 3 + 1 
55a7 .. 00			db "OUT",0              
55ab				endm 
# End of macro CWHEAD
55ab			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
55ab					if DEBUG_FORTH_WORDS_KEY 
55ab						DMARK "OUT" 
55ab f5				push af  
55ac 3a c0 55			ld a, (.dmark)  
55af 32 b4 fe			ld (debug_mark),a  
55b2 3a c1 55			ld a, (.dmark+1)  
55b5 32 b5 fe			ld (debug_mark+1),a  
55b8 3a c2 55			ld a, (.dmark+2)  
55bb 32 b6 fe			ld (debug_mark+2),a  
55be 18 03			jr .pastdmark  
55c0 ..			.dmark: db "OUT"  
55c3 f1			.pastdmark: pop af  
55c4			endm  
# End of macro DMARK
55c4						CALLMONITOR 
55c4 cd c6 18			call break_point_state  
55c7				endm  
# End of macro CALLMONITOR
55c7					endif 
55c7			 
55c7					; get port 
55c7			 
55c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55c7 cd 31 21			call macro_dsp_valuehl 
55ca				endm 
# End of macro FORTH_DSP_VALUEHL
55ca			 
55ca e5					push hl 
55cb			 
55cb					; destroy value TOS 
55cb			 
55cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
55cb cd e9 21			call macro_forth_dsp_pop 
55ce				endm 
# End of macro FORTH_DSP_POP
55ce			 
55ce					; get byte to send 
55ce			 
55ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55ce cd 31 21			call macro_dsp_valuehl 
55d1				endm 
# End of macro FORTH_DSP_VALUEHL
55d1			 
55d1			;		push hl 
55d1			 
55d1					; destroy value TOS 
55d1			 
55d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
55d1 cd e9 21			call macro_forth_dsp_pop 
55d4				endm 
# End of macro FORTH_DSP_POP
55d4			 
55d4					; one value on hl get other one back 
55d4			 
55d4			;		pop hl 
55d4			 
55d4 c1					pop bc 
55d5			 
55d5					if DEBUG_FORTH_WORDS 
55d5						DMARK "OUT" 
55d5 f5				push af  
55d6 3a ea 55			ld a, (.dmark)  
55d9 32 b4 fe			ld (debug_mark),a  
55dc 3a eb 55			ld a, (.dmark+1)  
55df 32 b5 fe			ld (debug_mark+1),a  
55e2 3a ec 55			ld a, (.dmark+2)  
55e5 32 b6 fe			ld (debug_mark+2),a  
55e8 18 03			jr .pastdmark  
55ea ..			.dmark: db "OUT"  
55ed f1			.pastdmark: pop af  
55ee			endm  
# End of macro DMARK
55ee						CALLMONITOR 
55ee cd c6 18			call break_point_state  
55f1				endm  
# End of macro CALLMONITOR
55f1					endif 
55f1			 
55f1 ed 69				out (c), l 
55f3			 
55f3					NEXTW 
55f3 c3 e7 22			jp macro_next 
55f6				endm 
# End of macro NEXTW
55f6			 
55f6			 
55f6			.SPIO: 
55f6			 
55f6			if STORAGE_SE 
55f6				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
55f6 51				db WORD_SYS_CORE+61             
55f7 07 56			dw .SPICEH            
55f9 07				db 6 + 1 
55fa .. 00			db "SPICEL",0              
5601				endm 
# End of macro CWHEAD
5601			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5601			 
5601 cd c7 01				call spi_ce_low 
5604			    NEXTW 
5604 c3 e7 22			jp macro_next 
5607				endm 
# End of macro NEXTW
5607			 
5607			.SPICEH: 
5607				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5607 51				db WORD_SYS_CORE+61             
5608 18 56			dw .SPIOb            
560a 07				db 6 + 1 
560b .. 00			db "SPICEH",0              
5612				endm 
# End of macro CWHEAD
5612			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5612			 
5612 cd b6 01				call spi_ce_high 
5615			    NEXTW 
5615 c3 e7 22			jp macro_next 
5618				endm 
# End of macro NEXTW
5618			 
5618			 
5618			.SPIOb: 
5618			 
5618				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5618 51				db WORD_SYS_CORE+61             
5619 4a 56			dw .SPII            
561b 05				db 4 + 1 
561c .. 00			db "SPIO",0              
5621				endm 
# End of macro CWHEAD
5621			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5621			 
5621					if DEBUG_FORTH_WORDS_KEY 
5621						DMARK "SPo" 
5621 f5				push af  
5622 3a 36 56			ld a, (.dmark)  
5625 32 b4 fe			ld (debug_mark),a  
5628 3a 37 56			ld a, (.dmark+1)  
562b 32 b5 fe			ld (debug_mark+1),a  
562e 3a 38 56			ld a, (.dmark+2)  
5631 32 b6 fe			ld (debug_mark+2),a  
5634 18 03			jr .pastdmark  
5636 ..			.dmark: db "SPo"  
5639 f1			.pastdmark: pop af  
563a			endm  
# End of macro DMARK
563a						CALLMONITOR 
563a cd c6 18			call break_point_state  
563d				endm  
# End of macro CALLMONITOR
563d					endif 
563d					; get port 
563d			 
563d			 
563d					; get byte to send 
563d			 
563d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
563d cd 31 21			call macro_dsp_valuehl 
5640				endm 
# End of macro FORTH_DSP_VALUEHL
5640			 
5640			;		push hl    ; u1  
5640			 
5640					; destroy value TOS 
5640			 
5640					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5640 cd e9 21			call macro_forth_dsp_pop 
5643				endm 
# End of macro FORTH_DSP_POP
5643			 
5643					; one value on hl get other one back 
5643			 
5643			;		pop hl   ; u2 - addr 
5643			 
5643					; TODO Send SPI byte 
5643			 
5643			;		push hl 
5643			;		call spi_ce_low 
5643			;		pop hl 
5643 7d					ld a, l 
5644 cd b5 00				call spi_send_byte 
5647			;		call spi_ce_high 
5647			 
5647					NEXTW 
5647 c3 e7 22			jp macro_next 
564a				endm 
# End of macro NEXTW
564a			 
564a			.SPII: 
564a				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
564a 52				db WORD_SYS_CORE+62             
564b b3 56			dw .SESEL            
564d 06				db 5 + 1 
564e .. 00			db "SPII",0              
5653				endm 
# End of macro CWHEAD
5653			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5653					if DEBUG_FORTH_WORDS_KEY 
5653						DMARK "SPi" 
5653 f5				push af  
5654 3a 68 56			ld a, (.dmark)  
5657 32 b4 fe			ld (debug_mark),a  
565a 3a 69 56			ld a, (.dmark+1)  
565d 32 b5 fe			ld (debug_mark+1),a  
5660 3a 6a 56			ld a, (.dmark+2)  
5663 32 b6 fe			ld (debug_mark+2),a  
5666 18 03			jr .pastdmark  
5668 ..			.dmark: db "SPi"  
566b f1			.pastdmark: pop af  
566c			endm  
# End of macro DMARK
566c						CALLMONITOR 
566c cd c6 18			call break_point_state  
566f				endm  
# End of macro CALLMONITOR
566f					endif 
566f			 
566f					; TODO Get SPI byte 
566f			 
566f cd dc 00				call spi_read_byte 
5672			 
5672					if DEBUG_FORTH_WORDS 
5672						DMARK "Si2" 
5672 f5				push af  
5673 3a 87 56			ld a, (.dmark)  
5676 32 b4 fe			ld (debug_mark),a  
5679 3a 88 56			ld a, (.dmark+1)  
567c 32 b5 fe			ld (debug_mark+1),a  
567f 3a 89 56			ld a, (.dmark+2)  
5682 32 b6 fe			ld (debug_mark+2),a  
5685 18 03			jr .pastdmark  
5687 ..			.dmark: db "Si2"  
568a f1			.pastdmark: pop af  
568b			endm  
# End of macro DMARK
568b						CALLMONITOR 
568b cd c6 18			call break_point_state  
568e				endm  
# End of macro CALLMONITOR
568e					endif 
568e 26 00				ld h, 0 
5690 6f					ld l, a 
5691					if DEBUG_FORTH_WORDS 
5691						DMARK "Si3" 
5691 f5				push af  
5692 3a a6 56			ld a, (.dmark)  
5695 32 b4 fe			ld (debug_mark),a  
5698 3a a7 56			ld a, (.dmark+1)  
569b 32 b5 fe			ld (debug_mark+1),a  
569e 3a a8 56			ld a, (.dmark+2)  
56a1 32 b6 fe			ld (debug_mark+2),a  
56a4 18 03			jr .pastdmark  
56a6 ..			.dmark: db "Si3"  
56a9 f1			.pastdmark: pop af  
56aa			endm  
# End of macro DMARK
56aa						CALLMONITOR 
56aa cd c6 18			call break_point_state  
56ad				endm  
# End of macro CALLMONITOR
56ad					endif 
56ad cd 3a 1f				call forth_push_numhl 
56b0			 
56b0					NEXTW 
56b0 c3 e7 22			jp macro_next 
56b3				endm 
# End of macro NEXTW
56b3			 
56b3			 
56b3			 
56b3			.SESEL: 
56b3				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
56b3 66				db WORD_SYS_CORE+82             
56b4 5c 57			dw .CARTDEV            
56b6 05				db 4 + 1 
56b7 .. 00			db "BANK",0              
56bc				endm 
# End of macro CWHEAD
56bc			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
56bc					if DEBUG_FORTH_WORDS_KEY 
56bc						DMARK "BNK" 
56bc f5				push af  
56bd 3a d1 56			ld a, (.dmark)  
56c0 32 b4 fe			ld (debug_mark),a  
56c3 3a d2 56			ld a, (.dmark+1)  
56c6 32 b5 fe			ld (debug_mark+1),a  
56c9 3a d3 56			ld a, (.dmark+2)  
56cc 32 b6 fe			ld (debug_mark+2),a  
56cf 18 03			jr .pastdmark  
56d1 ..			.dmark: db "BNK"  
56d4 f1			.pastdmark: pop af  
56d5			endm  
# End of macro DMARK
56d5						CALLMONITOR 
56d5 cd c6 18			call break_point_state  
56d8				endm  
# End of macro CALLMONITOR
56d8					endif 
56d8			 
56d8 3e ff				ld a, 255 
56da 32 f0 fb				ld (spi_cartdev), a 
56dd			 
56dd					; get bank 
56dd			 
56dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
56dd cd 31 21			call macro_dsp_valuehl 
56e0				endm 
# End of macro FORTH_DSP_VALUEHL
56e0			 
56e0			;		push hl 
56e0			 
56e0					; destroy value TOS 
56e0			 
56e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
56e0 cd e9 21			call macro_forth_dsp_pop 
56e3				endm 
# End of macro FORTH_DSP_POP
56e3			 
56e3					; one value on hl get other one back 
56e3			 
56e3			;		pop hl 
56e3			 
56e3			 
56e3 0e ff				ld c, SPI_CE_HIGH 
56e5 06 30				ld b, '0'    ; human readable bank number 
56e7			 
56e7 7d					ld a, l 
56e8			 
56e8					if DEBUG_FORTH_WORDS 
56e8						DMARK "BNK" 
56e8 f5				push af  
56e9 3a fd 56			ld a, (.dmark)  
56ec 32 b4 fe			ld (debug_mark),a  
56ef 3a fe 56			ld a, (.dmark+1)  
56f2 32 b5 fe			ld (debug_mark+1),a  
56f5 3a ff 56			ld a, (.dmark+2)  
56f8 32 b6 fe			ld (debug_mark+2),a  
56fb 18 03			jr .pastdmark  
56fd ..			.dmark: db "BNK"  
5700 f1			.pastdmark: pop af  
5701			endm  
# End of macro DMARK
5701						CALLMONITOR 
5701 cd c6 18			call break_point_state  
5704				endm  
# End of macro CALLMONITOR
5704					endif 
5704			 
5704					; active low 
5704			 
5704 fe 00				cp 0 
5706 28 28				jr z, .bset 
5708 fe 01				cp 1 
570a 20 04				jr nz, .b2 
570c cb 81				res 0, c 
570e 06 31				ld b, '1'    ; human readable bank number 
5710 fe 02		.b2:		cp 2 
5712 20 04				jr nz, .b3 
5714 cb 89				res 1, c 
5716 06 32				ld b, '2'    ; human readable bank number 
5718 fe 03		.b3:		cp 3 
571a 20 04				jr nz, .b4 
571c cb 91				res 2, c 
571e 06 33				ld b, '3'    ; human readable bank number 
5720 fe 04		.b4:		cp 4 
5722 20 04				jr nz, .b5 
5724 cb 99				res 3, c 
5726 06 34				ld b, '4'    ; human readable bank number 
5728 fe 05		.b5:		cp 5 
572a 20 04				jr nz, .bset 
572c cb a1				res 4, c 
572e 06 35				ld b, '5'    ; human readable bank number 
5730			 
5730			.bset: 
5730 79					ld a, c 
5731 32 ed fb				ld (spi_device),a 
5734 78					ld a, b 
5735 32 ec fb				ld (spi_device_id),a 
5738					if DEBUG_FORTH_WORDS 
5738						DMARK "BN2" 
5738 f5				push af  
5739 3a 4d 57			ld a, (.dmark)  
573c 32 b4 fe			ld (debug_mark),a  
573f 3a 4e 57			ld a, (.dmark+1)  
5742 32 b5 fe			ld (debug_mark+1),a  
5745 3a 4f 57			ld a, (.dmark+2)  
5748 32 b6 fe			ld (debug_mark+2),a  
574b 18 03			jr .pastdmark  
574d ..			.dmark: db "BN2"  
5750 f1			.pastdmark: pop af  
5751			endm  
# End of macro DMARK
5751						CALLMONITOR 
5751 cd c6 18			call break_point_state  
5754				endm  
# End of macro CALLMONITOR
5754					endif 
5754			 
5754					; set default SPI clk pulse time as disabled for BANK use 
5754			 
5754 3e 00				ld a, 0 
5756 32 f1 fb				ld (spi_clktime), a 
5759			 
5759					NEXTW 
5759 c3 e7 22			jp macro_next 
575c				endm 
# End of macro NEXTW
575c			 
575c			.CARTDEV: 
575c				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
575c 66				db WORD_SYS_CORE+82             
575d 0a 58			dw .ENDDEVICE            
575f 08				db 7 + 1 
5760 .. 00			db "CARTDEV",0              
5768				endm 
# End of macro CWHEAD
5768			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5768					if DEBUG_FORTH_WORDS_KEY 
5768						DMARK "CDV" 
5768 f5				push af  
5769 3a 7d 57			ld a, (.dmark)  
576c 32 b4 fe			ld (debug_mark),a  
576f 3a 7e 57			ld a, (.dmark+1)  
5772 32 b5 fe			ld (debug_mark+1),a  
5775 3a 7f 57			ld a, (.dmark+2)  
5778 32 b6 fe			ld (debug_mark+2),a  
577b 18 03			jr .pastdmark  
577d ..			.dmark: db "CDV"  
5780 f1			.pastdmark: pop af  
5781			endm  
# End of macro DMARK
5781						CALLMONITOR 
5781 cd c6 18			call break_point_state  
5784				endm  
# End of macro CALLMONITOR
5784					endif 
5784			 
5784					; disable se storage bank selection 
5784			 
5784 3e ff				ld a, SPI_CE_HIGH		; ce high 
5786 32 ed fb				ld (spi_device), a 
5789			 
5789					; get bank 
5789			 
5789					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5789 cd 31 21			call macro_dsp_valuehl 
578c				endm 
# End of macro FORTH_DSP_VALUEHL
578c			 
578c			;		push hl 
578c			 
578c					; destroy value TOS 
578c			 
578c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
578c cd e9 21			call macro_forth_dsp_pop 
578f				endm 
# End of macro FORTH_DSP_POP
578f			 
578f					; one value on hl get other one back 
578f			 
578f			;		pop hl 
578f			 
578f					; active low 
578f			 
578f 0e ff				ld c, 255 
5791			 
5791 7d					ld a, l 
5792					if DEBUG_FORTH_WORDS 
5792						DMARK "CDV" 
5792 f5				push af  
5793 3a a7 57			ld a, (.dmark)  
5796 32 b4 fe			ld (debug_mark),a  
5799 3a a8 57			ld a, (.dmark+1)  
579c 32 b5 fe			ld (debug_mark+1),a  
579f 3a a9 57			ld a, (.dmark+2)  
57a2 32 b6 fe			ld (debug_mark+2),a  
57a5 18 03			jr .pastdmark  
57a7 ..			.dmark: db "CDV"  
57aa f1			.pastdmark: pop af  
57ab			endm  
# End of macro DMARK
57ab						CALLMONITOR 
57ab cd c6 18			call break_point_state  
57ae				endm  
# End of macro CALLMONITOR
57ae					endif 
57ae fe 00				cp 0 
57b0 28 30				jr z, .cset 
57b2 fe 01				cp 1 
57b4 20 02				jr nz, .c2 
57b6 cb 81				res 0, c 
57b8 fe 02		.c2:		cp 2 
57ba 20 02				jr nz, .c3 
57bc cb 89				res 1, c 
57be fe 03		.c3:		cp 3 
57c0 20 02				jr nz, .c4 
57c2 cb 91				res 2, c 
57c4 fe 04		.c4:		cp 4 
57c6 20 02				jr nz, .c5 
57c8 cb 99				res 3, c 
57ca fe 05		.c5:		cp 5 
57cc 20 02				jr nz, .c6 
57ce cb a1				res 4, c 
57d0 fe 06		.c6:		cp 6 
57d2 20 02				jr nz, .c7 
57d4 cb a9				res 5, c 
57d6 fe 07		.c7:		cp 7 
57d8 20 02				jr nz, .c8 
57da cb b1				res 6, c 
57dc fe 08		.c8:		cp 8 
57de 20 02				jr nz, .cset 
57e0 cb b9				res 7, c 
57e2 79			.cset:		ld a, c 
57e3 32 f0 fb				ld (spi_cartdev),a 
57e6			 
57e6					if DEBUG_FORTH_WORDS 
57e6						DMARK "CD2" 
57e6 f5				push af  
57e7 3a fb 57			ld a, (.dmark)  
57ea 32 b4 fe			ld (debug_mark),a  
57ed 3a fc 57			ld a, (.dmark+1)  
57f0 32 b5 fe			ld (debug_mark+1),a  
57f3 3a fd 57			ld a, (.dmark+2)  
57f6 32 b6 fe			ld (debug_mark+2),a  
57f9 18 03			jr .pastdmark  
57fb ..			.dmark: db "CD2"  
57fe f1			.pastdmark: pop af  
57ff			endm  
# End of macro DMARK
57ff						CALLMONITOR 
57ff cd c6 18			call break_point_state  
5802				endm  
# End of macro CALLMONITOR
5802					endif 
5802			 
5802					; set default SPI clk pulse time as 10ms for CARTDEV use 
5802			 
5802 3e 0a				ld a, $0a 
5804 32 f1 fb				ld (spi_clktime), a 
5807					NEXTW 
5807 c3 e7 22			jp macro_next 
580a				endm 
# End of macro NEXTW
580a			endif 
580a			 
580a			.ENDDEVICE: 
580a			; eof 
580a			 
# End of file forth_words_device.asm
580a			 
580a			; var handler 
580a			 
580a			 
580a			.VARS: 
580a				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
580a 77				db WORD_SYS_CORE+99             
580b bb 58			dw .V0            
580d 04				db 3 + 1 
580e .. 00			db "VAR",0              
5812				endm 
# End of macro CWHEAD
5812			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5812			;| 
5812			;| The variable name should consist of a single letter. e.g. "a" 
5812			;! If a full string is passed then only the first char is looked at 
5812			;| Any other char could exceed bounds checks!  
5812			 
5812					if DEBUG_FORTH_WORDS_KEY 
5812						DMARK "VAR" 
5812 f5				push af  
5813 3a 27 58			ld a, (.dmark)  
5816 32 b4 fe			ld (debug_mark),a  
5819 3a 28 58			ld a, (.dmark+1)  
581c 32 b5 fe			ld (debug_mark+1),a  
581f 3a 29 58			ld a, (.dmark+2)  
5822 32 b6 fe			ld (debug_mark+2),a  
5825 18 03			jr .pastdmark  
5827 ..			.dmark: db "VAR"  
582a f1			.pastdmark: pop af  
582b			endm  
# End of macro DMARK
582b						CALLMONITOR 
582b cd c6 18			call break_point_state  
582e				endm  
# End of macro CALLMONITOR
582e					endif 
582e			 
582e					FORTH_DSP_VALUEHL 
582e cd 31 21			call macro_dsp_valuehl 
5831				endm 
# End of macro FORTH_DSP_VALUEHL
5831			 
5831 7e					ld a, (hl)    ; get first char on of the string 
5832			 
5832			 
5832					if DEBUG_FORTH_WORDS 
5832						DMARK "VR1" 
5832 f5				push af  
5833 3a 47 58			ld a, (.dmark)  
5836 32 b4 fe			ld (debug_mark),a  
5839 3a 48 58			ld a, (.dmark+1)  
583c 32 b5 fe			ld (debug_mark+1),a  
583f 3a 49 58			ld a, (.dmark+2)  
5842 32 b6 fe			ld (debug_mark+2),a  
5845 18 03			jr .pastdmark  
5847 ..			.dmark: db "VR1"  
584a f1			.pastdmark: pop af  
584b			endm  
# End of macro DMARK
584b						CALLMONITOR 
584b cd c6 18			call break_point_state  
584e				endm  
# End of macro CALLMONITOR
584e					endif 
584e					 
584e f5					push af	 
584f					FORTH_DSP_POP 
584f cd e9 21			call macro_forth_dsp_pop 
5852				endm 
# End of macro FORTH_DSP_POP
5852 f1					pop af 
5853			 
5853					; convert to upper 
5853			 
5853 cd b6 12				call to_upper 
5856					if DEBUG_FORTH_WORDS 
5856						DMARK "Vaa" 
5856 f5				push af  
5857 3a 6b 58			ld a, (.dmark)  
585a 32 b4 fe			ld (debug_mark),a  
585d 3a 6c 58			ld a, (.dmark+1)  
5860 32 b5 fe			ld (debug_mark+1),a  
5863 3a 6d 58			ld a, (.dmark+2)  
5866 32 b6 fe			ld (debug_mark+2),a  
5869 18 03			jr .pastdmark  
586b ..			.dmark: db "Vaa"  
586e f1			.pastdmark: pop af  
586f			endm  
# End of macro DMARK
586f						CALLMONITOR 
586f cd c6 18			call break_point_state  
5872				endm  
# End of macro CALLMONITOR
5872					endif 
5872 06 41				ld b, 'A' 
5874 90					sub b			; set offset 
5875					if DEBUG_FORTH_WORDS 
5875						DMARK "Vbb" 
5875 f5				push af  
5876 3a 8a 58			ld a, (.dmark)  
5879 32 b4 fe			ld (debug_mark),a  
587c 3a 8b 58			ld a, (.dmark+1)  
587f 32 b5 fe			ld (debug_mark+1),a  
5882 3a 8c 58			ld a, (.dmark+2)  
5885 32 b6 fe			ld (debug_mark+2),a  
5888 18 03			jr .pastdmark  
588a ..			.dmark: db "Vbb"  
588d f1			.pastdmark: pop af  
588e			endm  
# End of macro DMARK
588e						CALLMONITOR 
588e cd c6 18			call break_point_state  
5891				endm  
# End of macro CALLMONITOR
5891					endif 
5891 cb 27				sla a  
5893				 
5893					 
5893					if DEBUG_FORTH_WORDS 
5893						DMARK "VR2" 
5893 f5				push af  
5894 3a a8 58			ld a, (.dmark)  
5897 32 b4 fe			ld (debug_mark),a  
589a 3a a9 58			ld a, (.dmark+1)  
589d 32 b5 fe			ld (debug_mark+1),a  
58a0 3a aa 58			ld a, (.dmark+2)  
58a3 32 b6 fe			ld (debug_mark+2),a  
58a6 18 03			jr .pastdmark  
58a8 ..			.dmark: db "VR2"  
58ab f1			.pastdmark: pop af  
58ac			endm  
# End of macro DMARK
58ac						CALLMONITOR 
58ac cd c6 18			call break_point_state  
58af				endm  
# End of macro CALLMONITOR
58af					endif 
58af			 
58af 21 81 fb				ld hl, cli_var_array2 
58b2 cd 49 0f				call addatohl 
58b5 cd 3a 1f				call forth_push_numhl 
58b8			 
58b8			 
58b8				       NEXTW 
58b8 c3 e7 22			jp macro_next 
58bb				endm 
# End of macro NEXTW
58bb			.V0: 
58bb				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
58bb 78				db WORD_SYS_CORE+100             
58bc d3 58			dw .V0Q            
58be 04				db 3 + 1 
58bf .. 00			db "V0!",0              
58c3				endm 
# End of macro CWHEAD
58c3			;| V0! ( u1 -- )  Store value to v0  | DONE 
58c3			 
58c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58c3 cd 31 21			call macro_dsp_valuehl 
58c6				endm 
# End of macro FORTH_DSP_VALUEHL
58c6			 
58c6 11 b5 fb				ld de, cli_var_array 
58c9			 
58c9 eb					ex de, hl 
58ca 73					ld (hl), e 
58cb 23					inc hl 
58cc 72					ld (hl), d 
58cd			 
58cd					; destroy value TOS 
58cd			 
58cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58cd cd e9 21			call macro_forth_dsp_pop 
58d0				endm 
# End of macro FORTH_DSP_POP
58d0			 
58d0				       NEXTW 
58d0 c3 e7 22			jp macro_next 
58d3				endm 
# End of macro NEXTW
58d3			.V0Q: 
58d3				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
58d3 79				db WORD_SYS_CORE+101             
58d4 e4 58			dw .V1S            
58d6 04				db 3 + 1 
58d7 .. 00			db "V0@",0              
58db				endm 
# End of macro CWHEAD
58db			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
58db 2a b5 fb				ld hl, (cli_var_array) 
58de cd 3a 1f				call forth_push_numhl 
58e1			 
58e1				       NEXTW 
58e1 c3 e7 22			jp macro_next 
58e4				endm 
# End of macro NEXTW
58e4			.V1S: 
58e4				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
58e4 7a				db WORD_SYS_CORE+102             
58e5 fc 58			dw .V1Q            
58e7 04				db 3 + 1 
58e8 .. 00			db "V1!",0              
58ec				endm 
# End of macro CWHEAD
58ec			;| V1! ( u1 -- )  Store value to v1 | DONE 
58ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58ec cd 31 21			call macro_dsp_valuehl 
58ef				endm 
# End of macro FORTH_DSP_VALUEHL
58ef			 
58ef 11 b7 fb				ld de, cli_var_array+2 
58f2				 
58f2 eb					ex de, hl 
58f3 73					ld (hl), e 
58f4 23					inc hl 
58f5 72					ld (hl), d 
58f6			 
58f6					; destroy value TOS 
58f6			 
58f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58f6 cd e9 21			call macro_forth_dsp_pop 
58f9				endm 
# End of macro FORTH_DSP_POP
58f9				       NEXTW 
58f9 c3 e7 22			jp macro_next 
58fc				endm 
# End of macro NEXTW
58fc			.V1Q: 
58fc				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
58fc 7b				db WORD_SYS_CORE+103             
58fd 0d 59			dw .V2S            
58ff 04				db 3 + 1 
5900 .. 00			db "V1@",0              
5904				endm 
# End of macro CWHEAD
5904			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5904 2a b7 fb				ld hl, (cli_var_array+2) 
5907 cd 3a 1f				call forth_push_numhl 
590a				       NEXTW 
590a c3 e7 22			jp macro_next 
590d				endm 
# End of macro NEXTW
590d			.V2S: 
590d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
590d 7c				db WORD_SYS_CORE+104             
590e 25 59			dw .V2Q            
5910 04				db 3 + 1 
5911 .. 00			db "V2!",0              
5915				endm 
# End of macro CWHEAD
5915			;| V2! ( u1 -- )  Store value to v2 | DONE 
5915					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5915 cd 31 21			call macro_dsp_valuehl 
5918				endm 
# End of macro FORTH_DSP_VALUEHL
5918			 
5918 11 b9 fb				ld de, cli_var_array+4 
591b				 
591b eb					ex de, hl 
591c 73					ld (hl), e 
591d 23					inc hl 
591e 72					ld (hl), d 
591f			 
591f					; destroy value TOS 
591f			 
591f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
591f cd e9 21			call macro_forth_dsp_pop 
5922				endm 
# End of macro FORTH_DSP_POP
5922				       NEXTW 
5922 c3 e7 22			jp macro_next 
5925				endm 
# End of macro NEXTW
5925			.V2Q: 
5925				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5925 7d				db WORD_SYS_CORE+105             
5926 36 59			dw .V3S            
5928 04				db 3 + 1 
5929 .. 00			db "V2@",0              
592d				endm 
# End of macro CWHEAD
592d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
592d 2a b9 fb				ld hl, (cli_var_array+4) 
5930 cd 3a 1f				call forth_push_numhl 
5933				       NEXTW 
5933 c3 e7 22			jp macro_next 
5936				endm 
# End of macro NEXTW
5936			.V3S: 
5936				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5936 7c				db WORD_SYS_CORE+104             
5937 4e 59			dw .V3Q            
5939 04				db 3 + 1 
593a .. 00			db "V3!",0              
593e				endm 
# End of macro CWHEAD
593e			;| V3! ( u1 -- )  Store value to v3 | DONE 
593e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
593e cd 31 21			call macro_dsp_valuehl 
5941				endm 
# End of macro FORTH_DSP_VALUEHL
5941			 
5941 11 bb fb				ld de, cli_var_array+6 
5944				 
5944 eb					ex de, hl 
5945 73					ld (hl), e 
5946 23					inc hl 
5947 72					ld (hl), d 
5948			 
5948					; destroy value TOS 
5948			 
5948					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5948 cd e9 21			call macro_forth_dsp_pop 
594b				endm 
# End of macro FORTH_DSP_POP
594b				       NEXTW 
594b c3 e7 22			jp macro_next 
594e				endm 
# End of macro NEXTW
594e			.V3Q: 
594e				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
594e 7d				db WORD_SYS_CORE+105             
594f 5f 59			dw .END            
5951 04				db 3 + 1 
5952 .. 00			db "V3@",0              
5956				endm 
# End of macro CWHEAD
5956			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5956 2a bb fb				ld hl, (cli_var_array+6) 
5959 cd 3a 1f				call forth_push_numhl 
595c				       NEXTW 
595c c3 e7 22			jp macro_next 
595f				endm 
# End of macro NEXTW
595f			 
595f			 
595f			 
595f			 
595f			 
595f			; end of dict marker 
595f			 
595f 00			.END:    db WORD_SYS_END 
5960 00 00			dw 0 
5962 00				db 0 
5963			 
5963			; use to jp here for user dict words to save on macro expansion  
5963			 
5963			user_dict_next: 
5963				NEXTW 
5963 c3 e7 22			jp macro_next 
5966				endm 
# End of macro NEXTW
5966			 
5966			 
5966			user_exec: 
5966				;    ld hl, <word code> 
5966				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5966				;    call forthexec 
5966				;    jp user_dict_next   (NEXT) 
5966			        ;    <word code bytes> 
5966 eb				ex de, hl 
5967 2a 4f f6			ld hl,(os_tok_ptr) 
596a				 
596a				FORTH_RSP_NEXT 
596a cd e1 1e			call macro_forth_rsp_next 
596d				endm 
# End of macro FORTH_RSP_NEXT
596d			 
596d			if DEBUG_FORTH_UWORD 
596d						DMARK "UEX" 
596d f5				push af  
596e 3a 82 59			ld a, (.dmark)  
5971 32 b4 fe			ld (debug_mark),a  
5974 3a 83 59			ld a, (.dmark+1)  
5977 32 b5 fe			ld (debug_mark+1),a  
597a 3a 84 59			ld a, (.dmark+2)  
597d 32 b6 fe			ld (debug_mark+2),a  
5980 18 03			jr .pastdmark  
5982 ..			.dmark: db "UEX"  
5985 f1			.pastdmark: pop af  
5986			endm  
# End of macro DMARK
5986				CALLMONITOR 
5986 cd c6 18			call break_point_state  
5989				endm  
# End of macro CALLMONITOR
5989			endif 
5989			 
5989			 
5989			 
5989 eb				ex de, hl 
598a 22 4f f6			ld (os_tok_ptr), hl 
598d				 
598d				; Don't use next - Skips the first word in uword. 
598d			 
598d c3 78 23			jp exec1 
5990			;	NEXT 
5990			 
5990			 
5990			; eof 
# End of file forth_wordsv4.asm
5990			endif 
5990			;;;;;;;;;;;;;; Debug code 
5990			 
5990			 
5990			;if DEBUG_FORTH_PARSE 
5990 .. 00		.nowordfound: db "No match",0 
5999 .. 00		.compword:	db "Comparing word ",0 
59a9 .. 00		.nextwordat:	db "Next word at",0 
59b6 .. 00		.charmatch:	db "Char match",0 
59c1			;endif 
59c1			if DEBUG_FORTH_JP 
59c1			.foundword:	db "Word match. Exec..",0 
59c1			endif 
59c1			;if DEBUG_FORTH_PUSH 
59c1 .. 00		.enddict:	db "Dict end. Push.",0 
59d1 .. 00		.push_str:	db "Pushing string",0 
59e0 .. 00		.push_num:	db "Pushing number",0 
59ef .. 00		.data_sp:	db "SP:",0 
59f3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5a05 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5a17 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5a29			;endif 
5a29			;if DEBUG_FORTH_MALLOC 
5a29 .. 00		.push_malloc:	db "Malloc address",0 
5a38			;endif 
5a38			 
5a38			 
5a38			 
5a38			; display malloc address and current data stack pointer  
5a38			 
5a38			malloc_error: 
5a38 d5				push de 
5a39 f5				push af 
5a3a e5				push hl 
5a3b cd 15 0d			call clear_display 
5a3e 11 60 5a			ld de, .mallocerr 
5a41 3e 00			ld a,0 
5a43			;	ld de,os_word_scratch 
5a43 cd 28 0d			call str_at_display 
5a46 3e 11			ld a, display_row_1+17 
5a48 11 b4 fe			ld de, debug_mark 
5a4b cd 28 0d			call str_at_display 
5a4e cd 38 0d			call update_display 
5a51				;call break_point_state 
5a51 cd 29 73			call cin_wait 
5a54			 
5a54 3e 20			ld a, ' ' 
5a56 32 3f f3			ld (os_view_disable), a 
5a59 e1				pop hl 
5a5a f1				pop af 
5a5b d1				pop de	 
5a5c				CALLMONITOR 
5a5c cd c6 18			call break_point_state  
5a5f				endm  
# End of macro CALLMONITOR
5a5f c9				ret 
5a60			 
5a60 .. 00		.mallocerr: 	db "Malloc Error",0 
5a6d			;if DEBUG_FORTH_PUSH 
5a6d			display_data_sp: 
5a6d f5				push af 
5a6e			 
5a6e				; see if disabled 
5a6e			 
5a6e 3a 3f f3			ld a, (os_view_disable) 
5a71 fe 2a			cp '*' 
5a73 28 67			jr z, .skipdsp 
5a75			 
5a75 e5				push hl 
5a76 e5				push hl 
5a77 e5			push hl 
5a78 cd 15 0d			call clear_display 
5a7b e1			pop hl 
5a7c 7c				ld a,h 
5a7d 21 53 f6			ld hl, os_word_scratch 
5a80 cd 4a 12			call hexout 
5a83 e1				pop hl 
5a84 7d				ld a,l 
5a85 21 55 f6			ld hl, os_word_scratch+2 
5a88 cd 4a 12			call hexout 
5a8b 21 57 f6			ld hl, os_word_scratch+4 
5a8e 3e 00			ld a,0 
5a90 77				ld (hl),a 
5a91 11 53 f6			ld de,os_word_scratch 
5a94 3e 14				ld a, display_row_2 
5a96 cd 28 0d				call str_at_display 
5a99 11 f3 59			ld de, .wordinhl 
5a9c 3e 00			ld a, display_row_1 
5a9e			 
5a9e cd 28 0d				call str_at_display 
5aa1 11 b4 fe			ld de, debug_mark 
5aa4 3e 11			ld a, display_row_1+17 
5aa6			 
5aa6 cd 28 0d				call str_at_display 
5aa9			 
5aa9				; display current data stack pointer 
5aa9 11 ef 59			ld de,.data_sp 
5aac 3e 1c				ld a, display_row_2 + 8 
5aae cd 28 0d				call str_at_display 
5ab1			 
5ab1 2a 7b fb			ld hl,(cli_data_sp) 
5ab4 e5				push hl 
5ab5 7c				ld a,h 
5ab6 21 53 f6			ld hl, os_word_scratch 
5ab9 cd 4a 12			call hexout 
5abc e1				pop hl 
5abd 7d				ld a,l 
5abe 21 55 f6			ld hl, os_word_scratch+2 
5ac1 cd 4a 12			call hexout 
5ac4 21 57 f6			ld hl, os_word_scratch+4 
5ac7 3e 00			ld a,0 
5ac9 77				ld (hl),a 
5aca 11 53 f6			ld de,os_word_scratch 
5acd 3e 1f				ld a, display_row_2 + 11 
5acf cd 28 0d				call str_at_display 
5ad2			 
5ad2			 
5ad2 cd 38 0d			call update_display 
5ad5 cd 92 0c			call delay1s 
5ad8 cd 92 0c			call delay1s 
5adb e1				pop hl 
5adc			.skipdsp: 
5adc f1				pop af 
5add c9				ret 
5ade			 
5ade			display_data_malloc: 
5ade			 
5ade f5				push af 
5adf e5				push hl 
5ae0 e5				push hl 
5ae1 e5			push hl 
5ae2 cd 15 0d			call clear_display 
5ae5 e1			pop hl 
5ae6 7c				ld a,h 
5ae7 21 53 f6			ld hl, os_word_scratch 
5aea cd 4a 12			call hexout 
5aed e1				pop hl 
5aee 7d				ld a,l 
5aef 21 55 f6			ld hl, os_word_scratch+2 
5af2 cd 4a 12			call hexout 
5af5 21 57 f6			ld hl, os_word_scratch+4 
5af8 3e 00			ld a,0 
5afa 77				ld (hl),a 
5afb 11 53 f6			ld de,os_word_scratch 
5afe 3e 14				ld a, display_row_2 
5b00 cd 28 0d				call str_at_display 
5b03 11 29 5a			ld de, .push_malloc 
5b06 3e 00			ld a, display_row_1 
5b08			 
5b08 cd 28 0d				call str_at_display 
5b0b			 
5b0b				; display current data stack pointer 
5b0b 11 ef 59			ld de,.data_sp 
5b0e 3e 1c				ld a, display_row_2 + 8 
5b10 cd 28 0d				call str_at_display 
5b13			 
5b13 2a 7b fb			ld hl,(cli_data_sp) 
5b16 e5				push hl 
5b17 7c				ld a,h 
5b18 21 53 f6			ld hl, os_word_scratch 
5b1b cd 4a 12			call hexout 
5b1e e1				pop hl 
5b1f 7d				ld a,l 
5b20 21 55 f6			ld hl, os_word_scratch+2 
5b23 cd 4a 12			call hexout 
5b26 21 57 f6			ld hl, os_word_scratch+4 
5b29 3e 00			ld a,0 
5b2b 77				ld (hl),a 
5b2c 11 53 f6			ld de,os_word_scratch 
5b2f 3e 1f				ld a, display_row_2 + 11 
5b31 cd 28 0d				call str_at_display 
5b34			 
5b34 cd 38 0d			call update_display 
5b37 cd 92 0c			call delay1s 
5b3a cd 92 0c			call delay1s 
5b3d e1				pop hl 
5b3e f1				pop af 
5b3f c9				ret 
5b40			;endif 
5b40			 
5b40			include "forth_autostart.asm" 
5b40			; list of commands to perform at system start up 
5b40			 
5b40			startcmds: 
5b40			;	dw test11 
5b40			;	dw test12 
5b40			;	dw test13 
5b40			;	dw test14 
5b40			;	dw test15 
5b40			;	dw test16 
5b40			;	dw test17 
5b40			;	dw ifthtest1 
5b40			;	dw ifthtest2 
5b40			;	dw ifthtest3 
5b40			;	dw mmtest1 
5b40			;	dw mmtest2 
5b40			;	dw mmtest3 
5b40			;	dw mmtest4 
5b40			;	dw mmtest5 
5b40			;	dw mmtest6 
5b40			;	dw iftest1 
5b40			;	dw iftest2 
5b40			;	dw iftest3 
5b40			;	dw looptest1 
5b40			;	dw looptest2 
5b40			;	dw test1 
5b40			;	dw test2 
5b40			;	dw test3 
5b40			;	dw test4 
5b40			;	dw game2r 
5b40			;	dw game2b1 
5b40			;	dw game2b2 
5b40			 
5b40				; start up words that are actually useful 
5b40			 
5b40 b4 5b		    dw spi1 
5b42 0f 5c		    dw spi2 
5b44 9d 5c		    dw spi3 
5b46 45 5c		    dw spi4 
5b48 70 5c		    dw spi5 
5b4a 03 5d		    dw spi6 
5b4c 58 5d		    dw spi7 
5b4e			 
5b4e b0 5d		    dw spi8 
5b50 cf 5d		    dw spi9 
5b52 27 5e		    dw spi10 
5b54			 
5b54 9a 5e			dw longread 
5b56 e1 5e			dw clrstack 
5b58 14 5f			dw type 
5b5a 04 61			dw stest 
5b5c 38 5f			dw strncpy 
5b5e 9a 60			dw list 
5b60 99 5f			dw start1 
5b62 ab 5f			dw start2 
5b64			;	dw start3 
5b64 be 5f			dw start3b 
5b66 3a 60			dw start3c 
5b68			 
5b68				; (unit) testing words 
5b68			 
5b68 7b 61			dw mtesta 
5b6a 30 62			dw mtestb 
5b6c d3 62			dw mtestc 
5b6e 88 63			dw mtestd 
5b70 2c 64			dw mteste 
5b72			 
5b72				; demo/game words 
5b72			 
5b72 38 6b		        dw game3w 
5b74 66 6b		        dw game3p 
5b76 84 6b		        dw game3sc 
5b78 b5 6b		        dw game3vsi 
5b7a e1 6b		        dw game3vs 
5b7c				 
5b7c 2b 69			dw game2b 
5b7e 99 69			dw game2bf 
5b80 e3 69			dw game2mba 
5b82 79 6a			dw game2mbas 
5b84 bb 6a			dw game2mb 
5b86			 
5b86 ec 65			dw game1 
5b88 fd 65			dw game1a 
5b8a 5f 66			dw game1b 
5b8c 94 66			dw game1c 
5b8e ca 66			dw game1d 
5b90 fb 66			dw game1s 
5b92 0f 67			dw game1t 
5b94 24 67			dw game1f 
5b96 58 67			dw game1z 
5b98 9c 67			dw game1zz 
5b9a			 
5b9a e2 64			dw test5 
5b9c 1a 65			dw test6 
5b9e 52 65			dw test7 
5ba0 66 65			dw test8 
5ba2 92 65			dw test9 
5ba4 a8 65			dw test10 
5ba6				 
5ba6 73 68		        dw ssv5 
5ba8 57 68		        dw ssv4 
5baa 3b 68		        dw ssv3 
5bac 05 68		        dw ssv2 
5bae 8c 68		        dw ssv1 
5bb0 d4 68		        dw ssv1cpm 
5bb2			;	dw keyup 
5bb2			;	dw keydown 
5bb2			;	dw keyleft 
5bb2			;	dw keyright 
5bb2			;	dw 	keyf1 
5bb2			;	dw keyf2 
5bb2			;	dw keyf3 
5bb2			;	dw keyf4 
5bb2			;	dw keyf5 
5bb2			;	dw keyf6 
5bb2			;	dw keyf7 
5bb2			;	dw keyf8 
5bb2			;	dw keyf9 
5bb2			;	dw keyf10 
5bb2			;	dw keyf11 
5bb2			;	dw keyf12 
5bb2			;	dw keytab 
5bb2			;	dw keycr 
5bb2			;	dw keyhome 
5bb2			;	dw keyend 
5bb2			;	dw keybs 
5bb2 00 00			db 0, 0	 
5bb4			 
5bb4			; SPI Net support words 
5bb4			 
5bb4			; v0! = node to send to 
5bb4			; ( str count - ) 
5bb4 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5c0f			 
5c0f			; spiputchr ( char node - ) 
5c0f .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5c45			 
5c45			; spigetchr ( - n ) 
5c45 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5c70			 
5c70			; getnode ( - n ) 
5c70 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5c9d			 
5c9d			; ( str node - )  
5c9d .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5d03			; store string ( str i - ) 
5d03			 
5d03			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5d03 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5d58			 
5d58			; get string ( addr i -  )    TO FIX 
5d58			 
5d58 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5db0			 
5db0			 
5db0			; NETCHAT (TODO) 
5db0			; Program to allow two nodes to chat with eachother 
5db0			; 
5db0			; v0 - target node 
5db0			;  
5db0			; accept input at 0,0 
5db0			; if input is string send spitype to target node 
5db0			; starting at row 2,0 , while spigetchr is not zero ->  
5db0			; 
5db0			; 
5db0			; TODO add paging of get request 
5db0			 
5db0			; ( node - ) 
5db0 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5dcf .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5e27 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
5e9a			 
5e9a			 
5e9a			; Long read of currently open file 
5e9a .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5ee1			 
5ee1			; clear stack  
5ee1			 
5ee1 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5f14			 
5f14			; type ( addr count - ) 
5f14 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5f38			 
5f38			; some direct memory words 
5f38			; strncpy ( len t f -- t ) 
5f38			 
5f38 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5f99			 
5f99 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5fab .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5fbe .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
603a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
609a			 
609a			 
609a			; a handy word to list items on the stack 
609a			 
609a .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6104			 
6104			 
6104			; test stack  
6104			; rnd8 stest 
6104			 
6104 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
617b			 
617b			; random malloc and free cycles 
617b			 
617b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6230			 
6230			; fixed malloc and free cycles 
6230			 
6230 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
62d3			 
62d3			; fixed double string push and drop cycle  
62d3			 
62d3 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6388			 
6388			; consistent fixed string push and drop cycle  
6388			 
6388 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
642c			 
642c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
64e2			 
64e2			;test1:		db ": aa 1 2 3 ;", 0 
64e2			;test2:     	db "111 aa 888 999",0 
64e2			;test3:     	db ": bb 77 ;",0 
64e2			;test4:     	db "$02 $01 do i . loop bb",0 
64e2			 
64e2 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
651a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6552 .. 00		test7:     	db ": box hline vline ;",0 
6566 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6592 .. 00		test9:     	db ": sw $01 adsp world ;",0 
65a8 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
65cd .. 00		test11:     	db "hello create .",0 
65dc .. 00		test12:     	db "hello2 create .",0 
65ec			 
65ec			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
65ec			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
65ec			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
65ec			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
65ec			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
65ec			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
65ec			 
65ec			;iftest1:     	db "$0001 IF cls .",0 
65ec			;iftest2:     	db "$0000 IF cls .",0 
65ec			;iftest3:     	db "$0002 $0003 - IF cls .",0 
65ec			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
65ec			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
65ec			 
65ec			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65ec			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65ec			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65ec			 
65ec			 
65ec			 
65ec			; a small guess the number game 
65ec			 
65ec .. 00		game1:          db ": gsn rnd8 v1! ;",0 
65fd .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
665f			 
665f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6694 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
66ca .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
66fb .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
670f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6724 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6758 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
679c			 
679c			; Using 'ga' save a high score across multiple runs using external storage 
679c			 
679c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6805			 
6805			 
6805			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6805			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6805			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6805			 
6805			; simple screen saver to test code memory reuse to destruction 
6805			 
6805 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
683b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6857 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6873 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
688c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
68d4 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
692b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
692b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
692b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
692b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
692b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
692b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
692b			 
692b			 
692b			 
692b			; minesweeper/battleship finding game 
692b			; draws a game board of random ship/mine positions 
692b			; user enters coords to see if it hits on 
692b			; game ends when all are hit 
692b			; when hit or miss says how many may be in the area 
692b			 
692b			; setup the game board and then hide it 
692b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6999 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
69e3			; prompt for where to target 
69e3 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6a79 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6a9e			; TODO see if the entered coords hits or misses pushes char hit of miss 
6a9e .. 00		game2mbht:      db ": mbckht nop ;",0 
6aad .. 00		game2mbms:      db ": mbcms nop ;",0 
6abb			; TODO how many might be near by 
6abb .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6b38			 
6b38			; Game 3 
6b38			 
6b38			; Vert scroller ski game - avoid the trees! 
6b38			 
6b38			; v0 score (ie turns) 
6b38			; v1 player pos 
6b38			; v2 left wall 
6b38			; v3 right wall 
6b38			 
6b38			; Draw side walls randomly 
6b38			 
6b38 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6b66			 
6b66			; Draw player 
6b66 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6b84			 
6b84			; TODO Get Key 
6b84			 
6b84			; TODO Move left right 
6b84			 
6b84			; scroll and move walls a bit 
6b84			 
6b84 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6bb5			 
6bb5			; main game loop 
6bb5			 
6bb5 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6be1 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6c20			 
6c20			; key board defs 
6c20			 
6c20 .. 00		keyup:       db ": keyup $05 ;",0 
6c2e .. 00		keydown:       db ": keydown $0a ;",0 
6c3e .. 00		keyleft:       db ": keyleft $0b ;",0 
6c4e .. 00		keyright:       db ": keyright $0c ;",0 
6c5f .. 00		keyf1:       db ": keyf1 $10 ;",0 
6c6d .. 00		keyf2:       db ": keyf2 $11 ;",0 
6c7b .. 00		keyf3:       db ": keyf3 $12 ;",0 
6c89 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6c97 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6ca5 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6cb3 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6cc1 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6ccf .. 00		keyf9:       db ": keyf9 $18 ;",0 
6cdd .. 00		keyf10:       db ": keyf10 $19 ;",0 
6cec .. 00		keyf11:       db ": keyf11 $1a ;",0 
6cfb .. 00		keyf12:       db ": keyf12 $1b ;",0 
6d0a			 
6d0a .. 00		keytab:       db ": keytab $09 ;",0 
6d19 .. 00		keycr:       db ": keycr $0d ;",0 
6d27 .. 00		keyhome:       db ": keyhome $0e ;",0 
6d37 .. 00		keyend:       db ": keyend $0f ;",0 
6d46 .. 00		keybs:       db ": keybs $08 ;",0 
6d54			 
6d54			   
6d54			 
6d54			 
6d54			 
6d54			; eof 
# End of file forth_autostart.asm
6d54			 
6d54 .. 00		sprompt1: db "Startup load...",0 
6d64 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6d7a			 
6d7a			 
6d7a			 
6d7a			 
6d7a			forth_startup: 
6d7a 21 40 5b			ld hl, startcmds 
6d7d 3e 00			ld a, 0 
6d7f 32 74 f7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6d82			 
6d82 e5			.start1:	push hl 
6d83 cd 15 0d			call clear_display 
6d86 11 54 6d			ld de, sprompt1 
6d89 3e 00		        ld a, display_row_1 
6d8b cd 28 0d			call str_at_display 
6d8e 11 64 6d			ld de, sprompt2 
6d91 3e 14		        ld a, display_row_2 
6d93 cd 28 0d			call str_at_display 
6d96 e1				pop hl 
6d97 e5				push hl 
6d98 5e				ld e,(hl) 
6d99 23				inc hl 
6d9a 56				ld d,(hl) 
6d9b 3e 28		        ld a, display_row_3 
6d9d cd 28 0d			call str_at_display 
6da0 cd 38 0d			call update_display 
6da3			 
6da3			 
6da3 3a 74 f7			ld a, (os_last_cmd) 
6da6 fe 00			cp 0 
6da8 28 05			jr z, .startprompt 
6daa cd 86 0c			call delay250ms 
6dad 18 24			jr .startdo 
6daf				 
6daf				 
6daf			 
6daf			.startprompt: 
6daf			 
6daf 3e 4f			ld a,display_row_4 + display_cols - 1 
6db1 11 b0 1e		        ld de, endprg 
6db4 cd 28 0d			call str_at_display 
6db7 cd 38 0d			call update_display 
6dba cd 92 0c			call delay1s 
6dbd cd 29 73			call cin_wait 
6dc0						 
6dc0 fe 2a			cp '*' 
6dc2 28 5e			jr z, .startupend1 
6dc4 fe 23			cp '#' 
6dc6 20 07			jr nz, .startno 
6dc8 3e 01			ld a, 1 
6dca 32 74 f7			ld (os_last_cmd),a 
6dcd 18 04			jr .startdo 
6dcf fe 31		.startno:	cp '1' 
6dd1 28 3a			jr z,.startnxt  
6dd3			 
6dd3				; exec startup line 
6dd3			.startdo:	 
6dd3 e1				pop hl 
6dd4 e5				push hl 
6dd5				 
6dd5 5e				ld e,(hl) 
6dd6 23				inc hl 
6dd7 56				ld d,(hl) 
6dd8 eb				ex de,hl 
6dd9			 
6dd9 e5				push hl 
6dda			 
6dda 3e 00			ld a, 0 
6ddc				;ld a, FORTH_END_BUFFER 
6ddc cd b2 13			call strlent 
6ddf 23				inc hl   ; include zero term to copy 
6de0 06 00			ld b,0 
6de2 4d				ld c,l 
6de3 e1				pop hl 
6de4 11 4e f3			ld de, scratch 
6de7 ed b0			ldir 
6de9			 
6de9			 
6de9 21 4e f3			ld hl, scratch 
6dec cd 35 23			call forthparse 
6def cd 75 23			call forthexec 
6df2 cd 87 22			call forthexec_cleanup 
6df5			 
6df5 3e 3c			ld a, display_row_4 
6df7 11 54 1c			ld de, endprog 
6dfa			 
6dfa cd 38 0d			call update_display		 
6dfd			 
6dfd 3a 74 f7			ld a, (os_last_cmd) 
6e00 fe 00			cp 0 
6e02 20 09			jr nz, .startnxt 
6e04 cd b2 1e			call next_page_prompt 
6e07 cd 15 0d		        call clear_display 
6e0a cd 38 0d			call update_display		 
6e0d			 
6e0d				; move onto next startup line? 
6e0d			.startnxt: 
6e0d			 
6e0d cd 86 0c			call delay250ms 
6e10 e1				pop hl 
6e11			 
6e11 23				inc hl 
6e12 23				inc hl 
6e13			 
6e13 e5				push hl 
6e14 5e				ld e, (hl) 
6e15 23				inc hl 
6e16 56				ld d, (hl) 
6e17 e1				pop hl 
6e18				; TODO replace 0 test 
6e18			 
6e18 eb				ex de, hl 
6e19 cd 72 0f			call ishlzero 
6e1c			;	ld a,e 
6e1c			;	add d 
6e1c			;	cp 0    ; any left to do? 
6e1c eb				ex de, hl 
6e1d c2 82 6d			jp nz, .start1 
6e20 18 01			jr .startupend 
6e22			 
6e22 e1			.startupend1: pop hl 
6e23			.startupend: 
6e23			 
6e23 cd 15 0d			call clear_display 
6e26 cd 38 0d			call update_display 
6e29 c9				ret 
6e2a			 
6e2a			 
6e2a			; stack over and underflow checks 
6e2a			 
6e2a			; init the words to detect the under/overflow 
6e2a			 
6e2a			chk_stk_init: 
6e2a				; a vague random number to check so we dont get any "lucky" hits 
6e2a 3e 2d			ld a, 45 
6e2c 6f				ld l, a 
6e2d 00				nop 
6e2e 3e 17			ld a, 23 
6e30 67				ld h, a 
6e31			 
6e31 22 35 f3			ld (chk_word), hl     ; the word we need to check against 
6e34			 
6e34			;	ld (chk_stund), hl	; stack points.... 
6e34 22 fd fe			ld (chk_stovr), hl 
6e37 22 79 fb			ld (chk_ret_und), hl 
6e3a 22 37 fb			ld (chk_ret_ovr), hl 
6e3d 22 b5 fa			ld (chk_loop_ovr), hl 
6e40 22 b3 f8			ld (chk_data_ovr), hl 
6e43 c9				ret 
6e44				 
6e44			check_stacks: 
6e44				; check all stack words 
6e44			 
6e44 e5				push hl 
6e45 d5				push de 
6e46			 
6e46			;	ld de,(chk_word) 
6e46			;	ld hl, (chk_stund)	; stack points.... 
6e46			;	if DEBUG_STK_FAULT 
6e46			;		DMARK "FAa" 
6e46			;		CALLMONITOR 
6e46			;	endif 
6e46			;	call cmp16 
6e46			;	jp z, .chk_faulta 
6e46			; 
6e46			;	ld de, sfaultsu 
6e46			;	jp .chk_fault 
6e46			 
6e46 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6e49 ed 5b 35 f3		ld de,(chk_word) 
6e4d				if DEBUG_STK_FAULT 
6e4d					DMARK "FAb" 
6e4d					CALLMONITOR 
6e4d				endif 
6e4d cd 67 0f			call cmp16 
6e50 28 06			jr z, .chk_fault1 
6e52 11 f3 6e			ld de, sfaultso 
6e55 c3 a7 6e			jp .chk_fault 
6e58			.chk_fault1:  
6e58 2a 79 fb			ld hl, (chk_ret_und) 
6e5b ed 5b 35 f3		ld de,(chk_word) 
6e5f				if DEBUG_STK_FAULT 
6e5f					DMARK "FAU" 
6e5f					CALLMONITOR 
6e5f				endif 
6e5f cd 67 0f			call cmp16 
6e62 ca 6b 6e			jp z, .chk_fault2 
6e65 11 03 6f			ld de, sfaultru 
6e68 c3 a7 6e			jp .chk_fault 
6e6b			.chk_fault2:  
6e6b 2a 37 fb			ld hl, (chk_ret_ovr) 
6e6e ed 5b 35 f3		ld de,(chk_word) 
6e72				if DEBUG_STK_FAULT 
6e72					DMARK "FA1" 
6e72					CALLMONITOR 
6e72				endif 
6e72 cd 67 0f			call cmp16 
6e75 ca 7e 6e			jp z, .chk_fault3 
6e78 11 11 6f			ld de, sfaultro 
6e7b c3 a7 6e			jp .chk_fault 
6e7e			.chk_fault3:  
6e7e 2a b5 fa			ld hl, (chk_loop_ovr) 
6e81 ed 5b 35 f3		ld de,(chk_word) 
6e85				if DEBUG_STK_FAULT 
6e85					DMARK "FA2" 
6e85					CALLMONITOR 
6e85				endif 
6e85 cd 67 0f			call cmp16 
6e88 ca 91 6e			jp z, .chk_fault4 
6e8b 11 2b 6f			ld de, sfaultlo 
6e8e c3 a7 6e			jp .chk_fault 
6e91			.chk_fault4:  
6e91 2a b3 f8			ld hl, (chk_data_ovr) 
6e94 ed 5b 35 f3		ld de,(chk_word) 
6e98				if DEBUG_STK_FAULT 
6e98					DMARK "FA3" 
6e98					CALLMONITOR 
6e98				endif 
6e98 cd 67 0f			call cmp16 
6e9b ca a4 6e			jp z, .chk_fault5 
6e9e 11 45 6f			ld de, sfaultdo 
6ea1 c3 a7 6e			jp .chk_fault 
6ea4			 
6ea4			 
6ea4			.chk_fault5:  
6ea4 d1				pop de 
6ea5 e1				pop hl 
6ea6			 
6ea6 c9				ret 
6ea7			 
6ea7 cd 15 0d		.chk_fault: 	call clear_display 
6eaa 3e 14				ld a, display_row_2 
6eac cd 28 0d				call str_at_display 
6eaf 11 d5 6e				   ld de, .stackfault 
6eb2 3e 00				ld a, display_row_1 
6eb4 cd 28 0d				call str_at_display 
6eb7 11 b4 fe				    ld de, debug_mark 
6eba 3e 11				ld a, display_row_1+17 
6ebc cd 28 0d				call str_at_display 
6ebf cd 38 0d				call update_display 
6ec2			 
6ec2				; prompt before entering montior for investigating issue 
6ec2			 
6ec2 3e 3c			ld a, display_row_4 
6ec4 11 54 1c			ld de, endprog 
6ec7			 
6ec7 cd 38 0d			call update_display		 
6eca			 
6eca cd b2 1e			call next_page_prompt 
6ecd			 
6ecd d1				pop de 
6ece e1				pop hl 
6ecf cd a8 1c				call monitor 
6ed2 c3 9f 1b				jp warmstart 
6ed5					;jp 0 
6ed5					;halt 
6ed5			 
6ed5			 
6ed5			 
6ed5 .. 00		.stackfault: 	db "Stack fault:",0 
6ee2			 
6ee2 .. 00		sfaultsu: 	db	"Stack under flow",0 
6ef3 .. 00		sfaultso: 	db	"Stack over flow",0 
6f03 .. 00		sfaultru:	db "RTS underflow",0 
6f11 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6f2b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6f45 .. 00		sfaultdo:	db "DTS overflow", 0 
6f52			 
6f52			 
6f52			fault_dsp_under: 
6f52 11 64 6f			ld de, .dsp_under 
6f55 c3 14 70			jp .show_fault 
6f58			 
6f58			fault_rsp_under: 
6f58 11 72 6f			ld de, .rsp_under 
6f5b c3 14 70			jp .show_fault 
6f5e			fault_loop_under: 
6f5e 11 80 6f			ld de, .loop_under 
6f61 c3 14 70			jp .show_fault 
6f64			 
6f64 .. 00		.dsp_under: db "DSP Underflow",0 
6f72 .. 00		.rsp_under: db "RSP Underflow",0 
6f80 .. 00		.loop_under: db "LOOP Underflow",0 
6f8f			 
6f8f			 
6f8f d5			type_faultn: 	push de 
6f90 e5					push hl 
6f91 cd 15 0d				call clear_display 
6f94 11 bb 6f				   ld de, .typefaultn 
6f97 3e 00				ld a, display_row_1 
6f99 cd 28 0d				call str_at_display 
6f9c 11 b4 fe				    ld de, debug_mark 
6f9f 3e 11				ld a, display_row_1+17 
6fa1 cd 28 0d				call str_at_display 
6fa4 cd 38 0d				call update_display 
6fa7			 
6fa7				; prompt before entering montior for investigating issue 
6fa7			 
6fa7 3e 3c			ld a, display_row_4 
6fa9 11 54 1c			ld de, endprog 
6fac			 
6fac cd 38 0d			call update_display		 
6faf			 
6faf cd b2 1e			call next_page_prompt 
6fb2			 
6fb2 e5					push hl 
6fb3 d5					push de 
6fb4 cd a8 1c				call monitor 
6fb7 c3 9f 1b				jp warmstart 
6fba 76					halt 
6fbb			 
6fbb			 
6fbb .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6fd2			 
6fd2 d5			type_faults: 	push de 
6fd3 e5					push hl 
6fd4 cd 15 0d				call clear_display 
6fd7 11 fd 6f				   ld de, .typefaults 
6fda 3e 00				ld a, display_row_1 
6fdc cd 28 0d				call str_at_display 
6fdf 11 b4 fe				    ld de, debug_mark 
6fe2 3e 11				ld a, display_row_1+17 
6fe4 cd 28 0d				call str_at_display 
6fe7 cd 38 0d				call update_display 
6fea			 
6fea				; prompt before entering montior for investigating issue 
6fea			 
6fea 3e 3c			ld a, display_row_4 
6fec 11 54 1c			ld de, endprog 
6fef			 
6fef cd 38 0d			call update_display		 
6ff2			 
6ff2 cd b2 1e			call next_page_prompt 
6ff5			 
6ff5 e1					pop hl 
6ff6 d1					pop de 
6ff7 cd a8 1c				call monitor 
6ffa c3 9f 1b				jp warmstart 
6ffd			 
6ffd			 
6ffd .. 00		.typefaults: db "STR Type Expected TOS!",0 
7014			 
7014			.show_fault: 	 
7014 d5					push de 
7015 cd 15 0d				call clear_display 
7018 d1					pop de 
7019 3e 00				ld a, display_row_1 
701b cd 28 0d				call str_at_display 
701e 11 b4 fe				    ld de, debug_mark 
7021 3e 11				ld a, display_row_1+17 
7023 cd 28 0d				call str_at_display 
7026 cd 38 0d				call update_display 
7029			 
7029				; prompt before entering montior for investigating issue 
7029			 
7029 3e 3c			ld a, display_row_4 
702b 11 54 1c			ld de, endprog 
702e			 
702e cd 38 0d			call update_display		 
7031			 
7031 cd b2 1e			call next_page_prompt 
7034			 
7034 e1					pop hl 
7035 d1					pop de 
7036 cd a8 1c				call monitor 
7039			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7039			; TODO Make optional fault restart to cli or warm boot? 
7039					;jp warmstart 
7039 c3 fa 1b				jp cli 
703c 76					halt 
703d			 
703d			; handle the auto run of code from files in storage 
703d			 
703d			 
703d			if STORAGE_SE 
703d			 
703d .. 00		sprompt3: db "Loading from start-up file?:",0 
705a .. 00		sprompt4: db "(Y=Any key/N=No)",0 
706b			 
706b			 
706b			forth_autoload: 
706b			 
706b				; load block 0 of store 1 
706b				 
706b 3e fe			ld a, $fe      ; bit 0 clear 
706d 32 ed fb			ld (spi_device), a 
7070			 
7070 cd ca 04			call storage_get_block_0 
7073			 
7073 3a 28 fc			ld a, (store_page+STORE_0_AUTOFILE) 
7076			 
7076 fe 00			cp 0 
7078 c8				ret z     ; auto start not enabled 
7079			 
7079 cd 15 0d			call clear_display 
707c			 
707c				; set bank 
707c			 
707c 3a 2a fc				ld a, (store_page+STORE_0_BANKRUN) 
707f 32 ed fb				ld (spi_device), a 
7082			 
7082				; get file id to load from and get the file name to display 
7082			 
7082 3a 2b fc				ld a, (store_page+STORE_0_FILERUN) 
7085			 
7085 2e 00				ld l, 0 
7087 67					ld h, a 
7088 11 07 fc				ld de, store_page 
708b			 
708b					if DEBUG_FORTH_WORDS 
708b						DMARK "ASp" 
708b f5				push af  
708c 3a a0 70			ld a, (.dmark)  
708f 32 b4 fe			ld (debug_mark),a  
7092 3a a1 70			ld a, (.dmark+1)  
7095 32 b5 fe			ld (debug_mark+1),a  
7098 3a a2 70			ld a, (.dmark+2)  
709b 32 b6 fe			ld (debug_mark+2),a  
709e 18 03			jr .pastdmark  
70a0 ..			.dmark: db "ASp"  
70a3 f1			.pastdmark: pop af  
70a4			endm  
# End of macro DMARK
70a4						CALLMONITOR 
70a4 cd c6 18			call break_point_state  
70a7				endm  
# End of macro CALLMONITOR
70a7					endif 
70a7 cd 72 09				call storage_read 
70aa			 
70aa					if DEBUG_FORTH_WORDS 
70aa						DMARK "ASr" 
70aa f5				push af  
70ab 3a bf 70			ld a, (.dmark)  
70ae 32 b4 fe			ld (debug_mark),a  
70b1 3a c0 70			ld a, (.dmark+1)  
70b4 32 b5 fe			ld (debug_mark+1),a  
70b7 3a c1 70			ld a, (.dmark+2)  
70ba 32 b6 fe			ld (debug_mark+2),a  
70bd 18 03			jr .pastdmark  
70bf ..			.dmark: db "ASr"  
70c2 f1			.pastdmark: pop af  
70c3			endm  
# End of macro DMARK
70c3						CALLMONITOR 
70c3 cd c6 18			call break_point_state  
70c6				endm  
# End of macro CALLMONITOR
70c6					endif 
70c6			 
70c6 cd 72 0f				call ishlzero 
70c9 c8					ret z             ; file not found 
70ca			 
70ca 3e 1e				ld a, display_row_2 + 10 
70cc 11 0a fc				ld de, store_page+3 
70cf cd 28 0d				call str_at_display 
70d2				 
70d2			; 
70d2			 
70d2 3e 05			ld a, display_row_1+5 
70d4 11 3d 70			ld de, sprompt3 
70d7 cd 28 0d			call str_at_display 
70da 3e 37			ld a, display_row_3+15 
70dc 11 5a 70			ld de, sprompt4 
70df cd 28 0d			call str_at_display 
70e2			 
70e2 cd 38 0d			call update_display 
70e5			 
70e5 cd 29 73			call cin_wait 
70e8 fe 6e			cp 'n' 
70ea c8				ret z 
70eb fe 4e			cp 'N' 
70ed c8				ret z 
70ee			 
70ee cd 92 0c			call delay1s 
70f1			 
70f1 3a 09 fc			ld a, (store_page+2) 
70f4 32 f6 fb			ld (store_openmaxext), a    ; save count of ext 
70f7 3e 01			ld a, 1  
70f9 32 f7 fb			ld (store_openext), a    ; save count of ext 
70fc			 
70fc			.autof:  
70fc 6f				ld l , a 
70fd				 
70fd 3a 07 fc			ld a, (store_page) 
7100 67				ld h, a	 
7101 11 07 fc			ld de, store_page 
7104					if DEBUG_FORTH_WORDS 
7104						DMARK "ASl" 
7104 f5				push af  
7105 3a 19 71			ld a, (.dmark)  
7108 32 b4 fe			ld (debug_mark),a  
710b 3a 1a 71			ld a, (.dmark+1)  
710e 32 b5 fe			ld (debug_mark+1),a  
7111 3a 1b 71			ld a, (.dmark+2)  
7114 32 b6 fe			ld (debug_mark+2),a  
7117 18 03			jr .pastdmark  
7119 ..			.dmark: db "ASl"  
711c f1			.pastdmark: pop af  
711d			endm  
# End of macro DMARK
711d						CALLMONITOR 
711d cd c6 18			call break_point_state  
7120				endm  
# End of macro CALLMONITOR
7120					endif 
7120 cd 72 09				call storage_read 
7123 cd 72 0f			call ishlzero 
7126 c8				ret z 
7127			;	jr z, .autoend 
7127			 
7127					if DEBUG_FORTH_WORDS 
7127						DMARK "ASc" 
7127 f5				push af  
7128 3a 3c 71			ld a, (.dmark)  
712b 32 b4 fe			ld (debug_mark),a  
712e 3a 3d 71			ld a, (.dmark+1)  
7131 32 b5 fe			ld (debug_mark+1),a  
7134 3a 3e 71			ld a, (.dmark+2)  
7137 32 b6 fe			ld (debug_mark+2),a  
713a 18 03			jr .pastdmark  
713c ..			.dmark: db "ASc"  
713f f1			.pastdmark: pop af  
7140			endm  
# End of macro DMARK
7140						CALLMONITOR 
7140 cd c6 18			call break_point_state  
7143				endm  
# End of macro CALLMONITOR
7143					endif 
7143 11 09 fc			ld de, store_page+2 
7146 3e 3c			ld a, display_row_4 
7148 cd 28 0d			call str_at_display 
714b			 
714b cd 38 0d			call update_display 
714e cd 86 0c			call delay250ms 
7151			 
7151			 
7151			 
7151 21 09 fc			ld hl, store_page+2 
7154 cd 35 23			call forthparse 
7157 cd 75 23			call forthexec 
715a cd 87 22			call forthexec_cleanup 
715d			 
715d				 
715d 3a f7 fb			ld a, (store_openext) 
7160 3c				inc a 
7161 32 f7 fb			ld (store_openext), a    ; save count of ext 
7164			 
7164 18 96			jr .autof 
7166			;.autofdone: 
7166			; 
7166			;		if DEBUG_FORTH_WORDS 
7166			;			DMARK "ASx" 
7166			;			CALLMONITOR 
7166			;		endif 
7166			;;	call clear_display 
7166			;	ret 
7166			 
7166			 
7166			 
7166			endif 
7166			 
7166			 
7166			; eof 
# End of file forth_kernel.asm
7166			;include "nascombasic.asm" 
7166			 
7166			 
7166			; find out where the code ends if loaded into RAM (for SC114) 
7166			;endofcode:  
7166			;	nop 
7166			 
7166			 
7166			; eof 
7166			 
# End of file main.asm
7166			include "firmware_lcd_4x20.asm" 
7166			; **********************************************************************  
7166			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7166			; **********************************************************************  
7166			;  
7166			; **  Written as a Small Computer Monitor App  
7166			; **  www.scc.me.uk  
7166			;  
7166			; History  
7166			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7166			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7166			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7166			;  
7166			; **********************************************************************  
7166			;  
7166			; This program is an example of one of the methods of interfacing an   
7166			; alphanumeric LCD module.   
7166			;  
7166			; In this example the display is connected to either a Z80 PIO or a   
7166			; simple 8-bit output port.   
7166			;  
7166			; This interfacing method uses 4-bit data mode and uses time delays  
7166			; rather than polling the display's ready status. As a result the   
7166			; interface only requires 6 simple output lines:  
7166			;   Output bit 0 = not used  
7166			;   Output bit 1 = not used  
7166			;   Output bit 2 = RS         High = data, Low = instruction  
7166			;   Output bit 3 = E          Active high  
7166			;   Output bit 4 = DB4  
7166			;   Output bit 5 = DB5  
7166			;   Output bit 6 = DB6  
7166			;   Output bit 7 = DB7  
7166			; Display's R/W is connected to 0v so it is always in write mode  
7166			;  
7166			; This set up should work with any system supporting the RC2014 bus  
7166			  
7166			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7166			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7166			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7166			;  
7166			; **********************************************************************  
7166			  
7166			; **********************************************************************  
7166			; **  Constants  
7166			; **********************************************************************  
7166			; LCD constants required by LCD support module  
7166			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7166			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7166			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
7166			kLCDWidth:  EQU display_cols             ;Width in characters  
7166			  
7166			; **********************************************************************  
7166			; **  Code library usage  
7166			; **********************************************************************  
7166			  
7166			; send character to current cursor position  
7166			; wraps and/or scrolls screen automatically  
7166			  
7166			  
7166			lcd_init:  
7166			  
7166			; SCMonAPI functions used  
7166			  
7166			; Alphanumeric LCD functions used  
7166			; no need to specify specific functions for this module  
7166			  
7166 3e cf		            LD   A, 11001111b  
7168 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
716a 3e 00		            LD   A, 00000000b  
716c d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
716e			  
716e			; Initialise alphanumeric LCD module  
716e cd e7 71		            CALL fLCD_Init      ;Initialise LCD module  
7171			  
7171 c9				ret  
7172			  
7172			;  
7172			;;  
7172			; lcd functions  
7172			;  
7172			;  
7172			  
7172			; what is at cursor position   
7172			  
7172			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7172			;		call curptr  
7172			;		ret  
7172			  
7172			  
7172			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7172			  
7172			curptr:  
7172 c5				push bc  
7173 21 4a fe			ld hl, display_fb0  
7176			cpr:	  
7176				; loop for cursor whole row  
7176 0e 14			ld c, display_cols  
7178 23			cpr1:	inc hl  
7179 0d				dec c  
717a 20 fc			jr nz, cpr1  
717c 05				dec b  
717d 20 f7			jr nz, cpr  
717f			  
717f				; add col	  
717f			  
717f 23			cpr2:	inc hl  
7180 1d				dec e  
7181 20 fc			jr nz, cpr2  
7183			  
7183 c1				pop bc  
7184 c9				ret  
7185				  
7185			  
7185			  
7185			  
7185			  
7185			; write the frame buffer given in hl to hardware   
7185 22 52 fd		write_display: ld (display_write_tmp), hl 	   
7188 3e 00			ld a, kLCD_Line1  
718a cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
718d 06 14			ld b, display_cols  
718f ed 5b 52 fd		ld de, (display_write_tmp)  
7193 cd df 71			call write_len_string  
7196				  
7196				  
7196 2a 52 fd			ld hl, (display_write_tmp)  
7199 11 14 00			ld de, display_cols  
719c 19				add hl,de  
719d 22 52 fd			ld (display_write_tmp),hl  
71a0			  
71a0				  
71a0 3e 40			ld a, kLCD_Line2  
71a2 cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
71a5 06 14			ld b, display_cols  
71a7 ed 5b 52 fd		ld de, (display_write_tmp)  
71ab cd df 71			call write_len_string  
71ae				  
71ae 2a 52 fd			ld hl, (display_write_tmp)  
71b1 11 14 00			ld de, display_cols  
71b4 19				add hl,de  
71b5 22 52 fd			ld (display_write_tmp),hl  
71b8			  
71b8				  
71b8 3e 14			ld a, kLCD_Line3  
71ba cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
71bd 06 14			ld b, display_cols  
71bf ed 5b 52 fd		ld de, (display_write_tmp)  
71c3 cd df 71			call write_len_string  
71c6				  
71c6 2a 52 fd			ld hl, (display_write_tmp)  
71c9 11 14 00			ld de, display_cols  
71cc 19				add hl,de  
71cd 22 52 fd			ld (display_write_tmp),hl  
71d0			  
71d0				  
71d0 3e 54			ld a, kLCD_Line4  
71d2 cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
71d5 06 14			ld b, display_cols  
71d7 ed 5b 52 fd		ld de, (display_write_tmp)  
71db cd df 71			call write_len_string  
71de c9					ret  
71df				  
71df				; write out a fixed length string given in b from de  
71df			  
71df 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
71e0 cd 31 72		            CALL fLCD_Data      ;Write character to display  
71e3 13				inc de  
71e4 10 f9			djnz write_len_string  
71e6 c9				ret  
71e7			  
71e7			; Some other things to do  
71e7			;            LD   A, kLCD_Clear ;Display clear  
71e7			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
71e7			;            LD   A, kLCD_Under ;Display on with underscore cursor  
71e7			;            LD   A, kLCD_On     ;Display on with no cursor  
71e7			;            ;LD   A, kLCD_Off   ;Display off  
71e7			;            CALL fLCD_Inst      ;Send instruction to display  
71e7			;  
71e7			;  
71e7			;            halt  
71e7			;  
71e7			;  
71e7			;MsgHello:   DB  "Hello World!",0  
71e7			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
71e7			  
71e7			; Custom characters 5 pixels wide by 8 pixels high  
71e7			; Up to 8 custom characters can be defined  
71e7			;BitMaps:      
71e7			;; Character 0x00 = Battery icon  
71e7			;            DB  01110b  
71e7			;            DB  11011b  
71e7			;            DB  10001b  
71e7			;            DB  10001b  
71e7			;            DB  11111b  
71e7			;            DB  11111b  
71e7			;            DB  11111b  
71e7			;            DB  11111b  
71e7			;; Character 0x01 = Bluetooth icon  
71e7			;            DB  01100b  
71e7			;            DB  01010b  
71e7			;            DB  11100b  
71e7			;            DB  01000b  
71e7			;            DB  11100b  
71e7			;            DB  01010b  
71e7			;            DB  01100b  
71e7			;            DB  00000b  
71e7			;  
71e7			  
71e7			  
71e7			; **********************************************************************  
71e7			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
71e7			; **********************************************************************  
71e7			;  
71e7			; **  Written as a Small Computer Monitor App   
71e7			; **  Version 0.1 SCC 2018-05-16  
71e7			; **  www.scc.me.uk  
71e7			;  
71e7			; **********************************************************************  
71e7			;  
71e7			; This module provides support for alphanumeric LCD modules using with  
71e7			; *  HD44780 (or compatible) controller  
71e7			; *  5 x 7 pixel fonts  
71e7			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
71e7			; *  Interface via six digital outputs to the display (see below)  
71e7			;  
71e7			; LCD module pinout:  
71e7			;   1  Vss   0v supply  
71e7			;   2  Vdd   5v supply  
71e7			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
71e7			;   4  RS    High = data, Low = instruction  
71e7			;   5  R/W   High = Read, Low = Write  
71e7			;   6  E     Enable signal (active high)  
71e7			;   7  DB0   Data bit 0  
71e7			;   8  DB1   Data bit 1  
71e7			;   9  DB2   Data bit 2  
71e7			;  10  DB3   Data bit 3  
71e7			;  11  DB4   Data bit 4  
71e7			;  12  DB5   Data bit 5  
71e7			;  13  DB6   Data bit 6  
71e7			;  14  DB7   Data bit 7  
71e7			;  15  A     Backlight anode (+)  
71e7			;  16  K     Backlight cathode (-)  
71e7			;  
71e7			; This interfacing method uses 4-bit data mode and uses time delays  
71e7			; rather than polling the display's ready status. As a result the   
71e7			; interface only requires 6 simple output lines:  
71e7			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
71e7			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
71e7			;   LCD DB4 = Microcomputer output port bit 4  
71e7			;   LCD DB5 = Microcomputer output port bit 5  
71e7			;   LCD DB6 = Microcomputer output port bit 6  
71e7			;   LCD DB7 = Microcomputer output port bit 7  
71e7			; Display's R/W is connected to 0v so it is always in write mode  
71e7			; All 6 connections must be on the same port address <kLCDPrt>  
71e7			; This method also allows a decent length of cable from micro to LCD  
71e7			;  
71e7			; **********************************************************************  
71e7			;  
71e7			; To include the code for any given function provided by this module,   
71e7			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
71e7			; the parent source file.  
71e7			; For example:  #REQUIRES   uHexPrefix  
71e7			;  
71e7			; Also #INCLUDE this file at some point after the #REQUIRES statements  
71e7			; in the parent source file.  
71e7			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
71e7			;  
71e7			; These are the function names provided by this module:  
71e7			; fLCD_Init                     ;Initialise LCD  
71e7			; fLCD_Inst                     ;Send instruction to LCD  
71e7			; fLCD_Data                     ;Send data byte to LCD  
71e7			; fLCD_Pos                      ;Position cursor  
71e7			; fLCD_Str                      ;Display string  
71e7			; fLCD_Def                      ;Define custom character  
71e7			;  
71e7			; **********************************************************************  
71e7			;  
71e7			; Requires SCMonAPI.asm to also be included in the project  
71e7			;  
71e7			  
71e7			  
71e7			; **********************************************************************  
71e7			; **  Constants  
71e7			; **********************************************************************  
71e7			  
71e7			; Constants that must be defined externally  
71e7			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
71e7			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
71e7			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
71e7			;kLCDWidth: EQU 20             ;Width in characters  
71e7			  
71e7			; general line offsets in any frame buffer  
71e7			  
71e7			  
71e7			display_row_1: equ 0  
71e7			display_row_2: equ display_row_1+display_cols  
71e7			display_row_3: equ display_row_2 + display_cols  
71e7			display_row_4: equ display_row_3 + display_cols  
71e7			;display_row_4_eol:   
71e7			  
71e7			  
71e7			; Cursor position values for the start of each line  
71e7			kLCD_Line1: EQU 0x00   
71e7			kLCD_Line2: EQU 0x40    
71e7			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
71e7			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
71e7			  
71e7			; Instructions to send as A register to fLCD_Inst  
71e7			kLCD_Clear: EQU 00000001b     ;LCD clear  
71e7			kLCD_Off:   EQU 00001000b     ;LCD off  
71e7			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
71e7			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
71e7			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
71e7			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
71e7			  
71e7			; Constants used by this code module  
71e7			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
71e7			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
71e7			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
71e7			  
71e7			  
71e7			  
71e7			; **********************************************************************  
71e7			; **  LCD support functions  
71e7			; **********************************************************************  
71e7			  
71e7			; Initialise alphanumeric LCD module  
71e7			; LCD control register codes:  
71e7			;   DL   0 = 4-bit mode        1 = 8-bit mode  
71e7			;   N    0 = 1-line mode       1 = 2-line mode  
71e7			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
71e7			;   D    0 = Display off       1 = Display on  
71e7			;   C    0 = Cursor off        1 = Cursor on  
71e7			;   B    0 = Blinking off      1 = Blinking on  
71e7			;   ID   0 = Decrement mode    1 = Increment mode  
71e7			;   SH   0 = Entire shift off  1 = Entire shift on  
71e7 3e 28		fLCD_Init:  LD   A, 40  
71e9 cd 9e 72		            CALL LCDDelay       ;Delay 40ms after power up  
71ec			; For reliable reset set 8-bit mode - 3 times  
71ec cd 88 72		            CALL WrFn8bit       ;Function = 8-bit mode  
71ef cd 88 72		            CALL WrFn8bit       ;Function = 8-bit mode  
71f2 cd 88 72		            CALL WrFn8bit       ;Function = 8-bit mode  
71f5			; Set 4-bit mode  
71f5 cd 84 72		            CALL WrFn4bit       ;Function = 4-bit mode  
71f8 cd 9c 72		            CALL LCDDelay1      ;Delay 37 us or more  
71fb			; Function set  
71fb 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
71fd cd 10 72		            CALL fLCD_Inst      ;2 line, display on  
7200			; Display On/Off control  
7200 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7202 cd 10 72		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7205			; Display Clear  
7205 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7207 cd 10 72		            CALL fLCD_Inst      ;Clear display  
720a			; Entry mode  
720a 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
720c cd 10 72		            CALL fLCD_Inst      ;Increment mode, shift off  
720f			; Display module now initialised  
720f c9			            RET  
7210			; ok to here  
7210			  
7210			; Write instruction to LCD  
7210			;   On entry: A = Instruction byte to be written  
7210			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7210 f5			fLCD_Inst:  PUSH AF  
7211 f5			            PUSH AF  
7212 cd 24 72		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7215 f1			            POP  AF  
7216 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7217 17			            RLA  
7218 17			            RLA  
7219 17			            RLA  
721a cd 24 72		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
721d 3e 02		            LD   A, 2  
721f cd 9e 72		            CALL LCDDelay       ;Delay 2 ms to complete   
7222 f1			            POP  AF  
7223 c9			            RET  
7224 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
7226 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7228 cb df		            SET  kLCDBitE, A  
722a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
722c cb 9f		            RES  kLCDBitE, A  
722e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7230 c9			            RET  
7231			  
7231			  
7231			; Write data to LCD  
7231			;   On entry: A = Data byte to be written  
7231			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7231 f5			fLCD_Data:  PUSH AF  
7232 f5			            PUSH AF  
7233 cd 45 72		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7236 f1			            POP  AF  
7237 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7238 17			            RLA  
7239 17			            RLA  
723a 17			            RLA  
723b cd 45 72		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
723e 3e 96		            LD   A, 150  
7240 3d			Wait:      DEC  A              ;Wait a while to allow data   
7241 20 fd		            JR   NZ, Wait      ;  write to complete  
7243 f1			            POP  AF  
7244 c9			            RET  
7245 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
7247 cb d7		            SET  kLCDBitRS, A  
7249 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
724b cb df		            SET  kLCDBitE, A  
724d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
724f cb 9f		            RES  kLCDBitE, A  
7251 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7253 cb 97		            RES  kLCDBitRS, A  
7255 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7257 c9			            RET  
7258			  
7258			  
7258			; Position cursor to specified location  
7258			;   On entry: A = Cursor position  
7258			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7258 f5			fLCD_Pos:   PUSH AF  
7259 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
725b cd 10 72		            CALL fLCD_Inst      ;Write instruction to LCD  
725e f1			            POP  AF  
725f c9			            RET  
7260			  
7260			  
7260			; Output text string to LCD  
7260			;   On entry: DE = Pointer to null terminated text string  
7260			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7260 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7261 b7			            OR   A              ;Null terminator?  
7262 c8			            RET  Z              ;Yes, so finished  
7263 cd 31 72		            CALL fLCD_Data      ;Write character to display  
7266 13			            INC  DE             ;Point to next character  
7267 18 f7		            JR   fLCD_Str       ;Repeat  
7269 c9					ret  
726a			  
726a			; Define custom character  
726a			;   On entry: A = Character number (0 to 7)  
726a			;             DE = Pointer to character bitmap data  
726a			;   On exit:  A = Next character number  
726a			;             DE = Next location following bitmap  
726a			;             BC HL IX IY I AF' BC' DE' HL' preserved  
726a			; Character is   
726a c5			fLCD_Def:   PUSH BC  
726b f5			            PUSH AF  
726c 07			            RLCA                ;Calculate location  
726d 07			            RLCA                ;  for bitmap data  
726e 07			            RLCA                ;  = 8 x CharacterNumber  
726f f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7271 cd 10 72		            CALL fLCD_Inst      ;Write instruction to LCD  
7274 06 00		            LD   B, 0  
7276 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7277 cd 31 72		            CALL fLCD_Data      ;Write byte to display  
727a 13			            INC  DE             ;Point to next byte  
727b 04			            INC  B              ;Count bytes  
727c cb 58		            BIT  3, B           ;Finish all 8 bytes?  
727e 28 f6		            JR   Z, Loop       ;No, so repeat  
7280 f1			            POP  AF  
7281 3c			            INC  A              ;Increment character number  
7282 c1			            POP  BC  
7283 c9			            RET  
7284			  
7284			  
7284			; **********************************************************************  
7284			; **  Private functions  
7284			; **********************************************************************  
7284			  
7284			; Write function to LCD  
7284			;   On entry: A = Function byte to be written  
7284			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7284 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7286 18 02		            JR   WrFunc  
7288 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
728a f5			WrFunc:     PUSH AF  
728b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
728d cb df		            SET  kLCDBitE, A  
728f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7291 cb 9f		            RES  kLCDBitE, A  
7293 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7295 3e 05		            LD   A, 5  
7297 cd 9e 72		            CALL LCDDelay       ;Delay 5 ms to complete  
729a f1			            POP  AF  
729b c9			            RET  
729c			  
729c			  
729c			; Delay in milliseconds  
729c			;   On entry: A = Number of milliseconds delay  
729c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
729c 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
729e d5			LCDDelay:   PUSH DE  
729f 5f			            LD   E, A           ;Delay by 'A' ms  
72a0 16 00		            LD   D, 0  
72a2 cd 77 0c		            CALL aDelayInMS  
72a5 d1			            POP  DE  
72a6 c9			            RET  
72a7			  
72a7			  
72a7			  
72a7			  
72a7			; eof  
72a7			  
# End of file firmware_lcd_4x20.asm
72a7			include "firmware_key_4x4.asm" 
72a7			  
72a7			  
72a7			; bit mask for each scan column and row for teing the matrix  
72a7			  
72a7			; out   
72a7 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
72ab			; in  
72ab 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
72af			  
72af			; row/col to character map  
72af			  
72af			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
72af			;    
72af			  
72af			; physical key matrix map to face of key  
72af			  
72af			  
72af			;      	1	2	3	A  
72af			;   	abc”	def&	ghi$	s1  
72af			;			  
72af			;	4	5	6	B  
72af			; 	jkl,	mno.	pqr:	s2  
72af			;			  
72af			; 	7	8	9	C  
72af			;	stu;	vwx@	yz?!	s3  
72af			;			  
72af			; 	*	0	#	D  
72af			; 	shift lck '	Space < >	Enter ( )	s4  
72af			;       tab bs 		  
72af			  
72af			  
72af			  
72af			  
72af			key_init:  
72af			  
72af			; SCMonAPI functions used  
72af			  
72af			; Alphanumeric LCD functions used  
72af			; no need to specify specific functions for this module  
72af			  
72af			  
72af 3e cf		            LD   A, 11001111b  
72b1 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
72b3			;            LD   A, 00000000b  
72b3 3e 0f		            LD   A, 00001111b  
72b5 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
72b7			  
72b7			  
72b7				; TODO Configure cursor shapes  
72b7			  
72b7				; Load cursor shapes   
72b7 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
72b9 11 c9 72		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
72bc 06 02		            LD   B, 2           ;Number of characters to define  
72be cd 6a 72		.DefLoop:   CALL fLCD_Def       ;Define custom character  
72c1 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
72c3			  
72c3 3e 01				ld a, 1  
72c5 32 4d fd			ld (cursor_shape),a  
72c8 c9				ret  
72c9			  
72c9			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
72c9			; Up to 8 custom characters can be defined  
72c9			.cursor_shapes:      
72c9			;; Character 0x00 = Normal  
72c9 1f			            DB  11111b  
72ca 1f			            DB  11111b  
72cb 1f			            DB  11111b  
72cc 1f			            DB  11111b  
72cd 1f			            DB  11111b  
72ce 1f			            DB  11111b  
72cf 1f			            DB  11111b  
72d0 1f			            DB  11111b  
72d1			;; Character 0x01 = Modifier  
72d1 1f			            DB  11111b  
72d2 1b			            DB  11011b  
72d3 1b			            DB  11011b  
72d4 1b			            DB  11011b  
72d5 1b			            DB  11011b  
72d6 1f			            DB  11111b  
72d7 1b			            DB  11011b  
72d8 1f			            DB  11111b  
72d9			  
72d9			  
72d9			  
72d9			  
72d9			; Display custom character 0  
72d9			;            LD   A, kLCD_Line1+14  
72d9			;            CALL fLCD_Pos       ;Position cursor to location in A  
72d9			;            LD   A, 0  
72d9			;            CALL fLCD_Data      ;Write character in A at cursor  
72d9			  
72d9			; Display custom character 1  
72d9			;            LD   A, kLCD_Line2+14  
72d9			;            CALL fLCD_Pos      ;Position cursor to location in A  
72d9			;            LD   A, 1  
72d9			;            CALL fLCD_Data     ;Write character in A at cursor  
72d9			  
72d9			; keyboard scanning   
72d9			  
72d9			  
72d9			; key_rows: equ 4  
72d9			; key_cols: equ 4  
72d9			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
72d9			  
72d9			; key_scanr: equ key_row_bitmask  
72d9			; key_scanc: equ key_col_bitmask  
72d9			  
72d9			; key_char_map: equ key_map  
72d9			  
72d9			  
72d9			  
72d9			; character in from keyboard  
72d9			  
72d9 ..			.matrix_to_char: db "D#0*C987B654A321"  
72e9			  
72e9			  
72e9			; map the physical key to a char dependant on state  
72e9			  
72e9			.key_map_fa:   
72e9			  
72e9 ..					db 'D'  
72ea 0d					db KEY_CR    ; cr  
72eb ..					db ' '  
72ec 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
72ed ..					db 'C'  
72ee ..					db 'y'  
72ef ..					db 'v'  
72f0 ..					db 's'  
72f1 ..					db 'B'  
72f2 ..					db 'p'  
72f3 ..					db 'm'  
72f4 ..					db 'j'  
72f5 ..					db 'A'  
72f6 ..					db 'g'  
72f7 ..					db 'd'  
72f8 ..					db 'a'  
72f9			  
72f9			.key_map_fb:  
72f9			  
72f9 ..					db 'A'  
72fa ..					db '+'   
72fb ..					db '<'  
72fc ..					db  "'"    
72fd			  
72fd ..					db 'A'  
72fe ..					db 'z'  
72ff ..					db 'w'  
7300 ..					db 't'  
7301 ..					db 'A'  
7302 ..					db 'q'  
7303 ..					db 'n'  
7304 ..					db 'k'  
7305 ..					db 'A'  
7306 ..					db 'h'  
7307 ..					db 'e'  
7308 ..			 		db 'b'  
7309			  
7309			.key_map_fc:   
7309			  
7309			  
7309 ..					db 'A'  
730a ..					db '-'   
730b ..					db '>'  
730c ..					db  '='   	  
730d ..					db 'A'  
730e ..					db '?'  
730f ..					db 'x'  
7310 ..					db 'u'  
7311 ..					db 'A'  
7312 ..					db 'r'  
7313 ..					db 'o'  
7314 ..					db 'l'  
7315 ..					db 'A'  
7316 ..					db 'i'  
7317 ..					db 'f'  
7318 ..					db 'c'  
7319			  
7319				  
7319			.key_map_fd:  
7319			  
7319 ..					db 'A'  
731a ..					db '/'   
731b ..					db '%'   
731c 08					db KEY_BS  ; back space  
731d ..					db 'A'  
731e ..					db '!'  
731f ..					db '@'  
7320 ..					db ';'  
7321 ..					db 'A'  
7322 ..					db ':'  
7323 ..					db '.'  
7324 ..					db ','  
7325 ..					db 'A'  
7326 ..					db '$'  
7327 ..					db '&'  
7328 ..				 	db '"'  
7329			  
7329					  
7329				  
7329			  
7329			; add cin and cin_wait  
7329			  
7329 cd 3a 73		cin_wait: 	call cin  
732c fe 00			cp 0  
732e 28 f9			jr z, cin_wait   ; block until key press  
7330			  
7330 f5				push af   ; save key pressed  
7331			  
7331 cd 3a 73		.cin_wait1:	call cin  
7334 fe 00			cp 0  
7336 20 f9			jr nz, .cin_wait1  	; wait for key release  
7338			  
7338 f1				pop af   ; get key  
7339 c9				ret  
733a			  
733a			  
733a cd 4b 73		cin: 	call .mtoc  
733d			  
733d				; no key held  
733d fe 00			cp 0  
733f c8				ret z  
7340			  
7340				; stop key bounce  
7340			  
7340			;	ld (key_held),a		 ; save it  
7340 47				ld b, a  
7341			  
7341 c5			.cina1:	push bc  
7342 cd 4b 73			call .mtoc  
7345 c1				pop bc  
7346 b8				cp b  
7347 28 f8			jr z, .cina1  
7349 78				ld a,b		  
734a c9				ret  
734b			  
734b			; detect keyboard modifier key press and apply new overlay to the face key held  
734b			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
734b			  
734b			;.cin_map_modifier:   
734b			;	ld a, (hl)  
734b			;	and 255  
734b			;	ret NZ		; modifier key not flagged  
734b			;  
734b			;	; get key face  
734b			;  
734b			;	ld b,(key_face_held)  
734b			;  
734b			;	ld b, key_cols * key_rows  
734b			;  
734b			;	push de  
734b			;	pop hl  
734b			;  
734b			;.mmod1: ld a,(hl)   ; get map test  
734b			;	cp b  
734b			;	jr z, .mmod2  
734b			;  
734b			;  
734b			;  
734b			;.mmod2: inc hl    ;   
734b			;  
734b			;	  
734b			;  
734b			;	  
734b			;  
734b			;	ld hl,key_actual_pressed  
734b			;	ld (hl),a,  
734b			;	ret  
734b			  
734b				  
734b			  
734b			; map matrix key held to char on face of key  
734b			  
734b			.mtoc:  
734b			  
734b			  
734b				; TODO optimise the code....  
734b			  
734b			; scan keyboard row 1  
734b 3e 80			ld a, 128  
734d 21 d3 fe			ld hl, keyscan_table  
7350 cd 32 74			call .rowscan  
7353			  
7353				   
7353			  
7353 3e 40			ld a, 64  
7355 21 d7 fe			ld hl, keyscan_table+key_cols  
7358 cd 32 74			call .rowscan  
735b			  
735b			  
735b			  
735b			  
735b 3e 20			ld a, 32  
735d 21 db fe			ld hl, keyscan_table+(key_cols*2)  
7360 cd 32 74			call .rowscan  
7363			  
7363			  
7363			  
7363 3e 10			ld a, 16  
7365 21 df fe			ld hl, keyscan_table+(key_cols*3)  
7368 cd 32 74			call .rowscan  
736b			  
736b			  
736b				; flag if key D is held down and remove from reporting  
736b 01 19 73			ld bc, .key_map_fd    
736e 21 d3 fe			ld hl, keyscan_table  
7371 11 c5 fe			ld de, key_fd  
7374 cd c4 73			call .key_shift_hold  
7377 fe ff			cp 255  
7379 28 33			jr z, .cinmap  
737b				; flag if key C is held down and remove from reporting  
737b 01 09 73			ld bc, .key_map_fc    
737e 21 d7 fe			ld hl, keyscan_table+key_cols  
7381 11 c6 fe			ld de, key_fc  
7384 cd c4 73			call .key_shift_hold  
7387 fe ff			cp 255  
7389 28 23			jr z, .cinmap  
738b				; flag if key B is held down and remove from reporting  
738b 01 f9 72			ld bc, .key_map_fb    
738e 21 db fe			ld hl, keyscan_table+(key_cols*2)  
7391 11 c7 fe			ld de, key_fb  
7394 cd c4 73			call .key_shift_hold  
7397 fe ff			cp 255  
7399 28 13			jr z, .cinmap  
739b				; flag if key A is held down and remove from reporting  
739b 01 e9 72			ld bc, .key_map_fa    
739e 21 df fe			ld hl, keyscan_table+(key_cols*3)  
73a1 11 c8 fe			ld de, key_fa  
73a4 cd c4 73			call .key_shift_hold  
73a7 fe ff			cp 255  
73a9 28 03			jr z, .cinmap  
73ab			  
73ab 11 d9 72			ld de, .matrix_to_char  
73ae			  
73ae			  
73ae			.cinmap:   
73ae				if DEBUG_KEY  
73ae			            LD   A, kLCD_Line4  
73ae			            CALL fLCD_Pos       ;Position cursor to location in A  
73ae					push de  
73ae			            LD   DE, keyscan_table  
73ae			            CALL fLCD_Str       ;Display string pointed to by DE  
73ae					pop de  
73ae				endif  
73ae			  
73ae				; scan key matrix table for any held key  
73ae			  
73ae				; de holds either the default matrix or one selected above  
73ae			  
73ae 21 d3 fe			ld hl, keyscan_table  
73b1 06 10			ld b,key_cols*key_rows  
73b3			  
73b3 7e			.cin1:	ld a,(hl)  
73b4 fe 23			cp '#'  
73b6 28 08			jr z, .cinhit  
73b8 23				inc hl  
73b9 13				inc de  
73ba 05				dec b  
73bb 20 f6			jr nz, .cin1  
73bd				; no key found held  
73bd 3e 00			ld a,0  
73bf c9				ret  
73c0 d5			.cinhit: push de  
73c1 e1				pop hl  
73c2 7e				ld a,(hl)  
73c3 c9				ret  
73c4			  
73c4			; flag a control key is held   
73c4			; hl is key pin, de is flag indicator  
73c4			  
73c4			.key_shift_hold:  
73c4 c5				push bc  
73c5 3e 01			ld a, 1  
73c7 32 4d fd			ld (cursor_shape),a  
73ca 06 00			ld b, 0  
73cc 7e				ld a, (hl)  
73cd fe 2e			cp '.'  
73cf 28 0a			jr z, .key_shift1  
73d1 06 ff			ld b, 255  
73d3 3e 2b			ld a, '+'    ; hide key from later scans  
73d5 77				ld (hl),a  
73d6 3e 02			ld a, 2  
73d8 32 4d fd			ld (cursor_shape),a  
73db			.key_shift1:  
73db				; write flag indicator  
73db 78				ld a,b  
73dc 12				ld (de),a  
73dd			  
73dd d1				pop de    ; de now holds the key map ptr  
73de c9				ret  
73df			  
73df				  
73df				  
73df			  
73df			  
73df			  
73df			  
73df			  
73df			  
73df			  
73df			  
73df			  
73df			  
73df c9				ret  
73e0			  
73e0			;	push hl  
73e0			;	push de  
73e0			;	push bc  
73e0			;	call keyscan  
73e0			;	; map key matrix to ascii value of key face  
73e0			;  
73e0			;	ld hl, key_face_map  
73e0			;	ld de, keyscan_table  
73e0			;  
73e0			;	; get how many keys to look at  
73e0			;	ld b, keyscan_table_len  
73e0			;	  
73e0			;  
73e0			;	; at this stage fall out on first key hit  
73e0			;	; TODO handle multiple key press  
73e0			;  
73e0			;map1:	ld a,(hl)  
73e0			;	cp '#'  
73e0			;	jr z, keyhit  
73e0			;	inc hl  
73e0			;	inc de  
73e0			;	dec b  
73e0			;	jr nz, map1  
73e0			;nohit:	ld a, 0  
73e0			;	jr keydone  
73e0			;keyhit: push de  
73e0			;	pop hl  
73e0			;	ld a,(hl)  
73e0			;keydone:  
73e0			;	push bc  
73e0			;	push de  
73e0			; 	push hl  
73e0			;	ret   
73e0			;  
73e0			  
73e0			  
73e0			  
73e0			  
73e0			; scan physical key matrix  
73e0			  
73e0			  
73e0			;keyscan:  
73e0			;  
73e0			;; for each key_row use keyscanr bit mask for out  
73e0			;; then read in for keyscanc bitmask  
73e0			;; save result of row scan to keyscantable  
73e0			;  
73e0			;; scan keyboard row 1  
73e0			;  
73e0			;	ld b, key_rows  
73e0			;	ld hl, key_scanr  
73e0			;	ld de, keyscan_table  
73e0			;  
73e0			;rowloop:  
73e0			;  
73e0			;	ld a,(hl)		; out bit mask to energise keyboard row  
73e0			;	call rowscan  
73e0			;	inc hl  
73e0			;	dec b  
73e0			;	jr nz, rowloop  
73e0			;  
73e0			;	ret  
73e0			;  
73e0			;  
73e0			;; pass a out bitmask, b row number  
73e0			;arowscan:   
73e0			;	push bc  
73e0			;  
73e0			;	ld d, b  
73e0			;  
73e0			;	; calculate buffer location for this row  
73e0			;  
73e0			;	ld hl, keyscan_table	  
73e0			;kbufr:  ld e, key_cols  
73e0			;kbufc:	inc hl  
73e0			;	dec e  
73e0			;	jr nz, kbufc  
73e0			;	dec d  
73e0			;	jr nz, kbufr  
73e0			;  
73e0			;	; energise row and read columns  
73e0			;  
73e0			;	out (portbdata),a  
73e0			;	in a,(portbdata)  
73e0			;	ld c,a  
73e0			;  
73e0			;  
73e0			;	; save buffer loc  
73e0			;  
73e0			;	ld (keybufptr), hl  
73e0			;  
73e0			;	ld hl, key_scanc  
73e0			;	ld d, key_cols  
73e0			;  
73e0			;	; for each column check each bit mask  
73e0			;  
73e0			;colloop:  
73e0			;	  
73e0			;  
73e0			;	; reset flags for the row   
73e0			;  
73e0			;	ld b,'.'  
73e0			;	and (hl)  
73e0			;	jr z, maskskip  
73e0			;	ld b,'#'  
73e0			;maskskip:  
73e0			;	; save  key state  
73e0			;	push hl  
73e0			;	ld hl, (keybufptr)  
73e0			;	ld (hl), b  
73e0			;	inc hl  
73e0			;	ld (keybufptr), hl  
73e0			;  
73e0			;	; move to next bit mask  
73e0			;	pop hl  
73e0			;	inc hl  
73e0			;  
73e0			;	dec d  
73e0			;	jr nz, colloop  
73e0			;  
73e0			;	ret  
73e0			;  
73e0			;  
73e0			;;  
73e0			; lcd functions  
73e0			;  
73e0			;  
73e0			  
73e0			;if DEBUG_KEY_MATRIX  
73e0			  
73e0			; test function to display hardware view of matrix state  
73e0			  
73e0			matrix:  
73e0			  
73e0			  
73e0			  
73e0			; scan keyboard row 1  
73e0 3e 80			ld a, 128  
73e2 21 f8 fe			ld hl, keyscan_table_row1  
73e5 cd 32 74			call .rowscan  
73e8			  
73e8 3e 40			ld a, 64  
73ea 21 f3 fe			ld hl, keyscan_table_row2  
73ed cd 32 74			call .rowscan  
73f0			  
73f0 3e 20			ld a, 32  
73f2 21 ee fe			ld hl, keyscan_table_row3  
73f5 cd 32 74			call .rowscan  
73f8			  
73f8 3e 10			ld a, 16  
73fa 21 e9 fe			ld hl, keyscan_table_row4  
73fd cd 32 74			call .rowscan  
7400			  
7400			; Display text on first line  
7400 3e 00		            LD   A, kLCD_Line1  
7402 cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7405 11 f8 fe		            LD   DE, keyscan_table_row1  
7408			            ;LD   DE, MsgHello  
7408 cd 60 72		            CALL fLCD_Str       ;Display string pointed to by DE  
740b			  
740b			; Display text on second line  
740b 3e 40		            LD   A, kLCD_Line2  
740d cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7410 11 f3 fe		            LD   DE, keyscan_table_row2  
7413 cd 60 72		            CALL fLCD_Str       ;Display string pointed to by DE  
7416 3e 14		            LD   A, kLCD_Line3  
7418 cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
741b 11 ee fe		            LD   DE, keyscan_table_row3  
741e cd 60 72		            CALL fLCD_Str       ;Display string pointed to by DE  
7421 3e 54		            LD   A, kLCD_Line4  
7423 cd 58 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7426 11 e9 fe		            LD   DE, keyscan_table_row4  
7429 cd 60 72		            CALL fLCD_Str       ;Display string pointed to by DE  
742c			  
742c cd 86 0c			call delay250ms  
742f c3 e0 73			jp matrix  
7432			  
7432			; pass de as row display flags  
7432			.rowscan:   
7432 d3 c1			out (portbdata),a  
7434 db c1			in a,(portbdata)  
7436 4f				ld c,a  
7437				; reset flags for the row   
7437 06 2e			ld b,'.'  
7439 e6 01			and 1  
743b 28 02			jr z, .p1on  
743d 06 23			ld b,'#'  
743f			.p1on:  
743f 70				ld (hl), b  
7440 23				inc hl  
7441			  
7441 06 2e			ld b,'.'  
7443 79				ld a,c  
7444 e6 02			and 2  
7446			;	bit 0,a  
7446 28 02			jr z, .p2on  
7448 06 23			ld b,'#'  
744a			.p2on:  
744a 70				ld (hl), b  
744b 23				inc hl  
744c			;  
744c 06 2e			ld b,'.'  
744e 79				ld a,c  
744f e6 04			and 4  
7451			;;	bit 0,a  
7451 28 02			jr z, .p3on  
7453 06 23			ld b,'#'  
7455			.p3on:  
7455 70				ld (hl), b  
7456 23				inc hl  
7457			;;  
7457 06 2e			ld b,'.'  
7459			;;	bit 0,a  
7459 79				ld a,c  
745a e6 08			and 8  
745c 28 02			jr z, .p4on  
745e 06 23			ld b,'#'  
7460			.p4on:  
7460 70				ld (hl), b  
7461 23				inc hl  
7462			  
7462			; zero term  
7462 06 00			ld b,0  
7464 70				ld (hl), b  
7465			  
7465 c9			.rscandone: ret  
7466			  
7466			  
7466			  
7466			;endif  
7466			  
7466			  
7466			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
7466
